Knowledge Representation in
Bicategories of Relations
Evan Patterson
Department of Statistics, Stanford University
Abstract
We introduce the relational ontology log, or relational olog, a knowledge representation
system based on the category of sets and relations. It is inspired by Spivak and Kent‚Äôs
olog, a recent categorical framework for knowledge representation. Relational ologs
interpolate between ologs and description logic, the dominant formalism for knowledge
representation today.
In this paper, we investigate relational ologs both for their
own sake and to gain insight into the relationship between the algebraic and logical
approaches to knowledge representation. On a practical level, we show by example
that relational ologs have a friendly and intuitive‚Äîyet fully precise‚Äîgraphical syntax,
derived from the string diagrams of monoidal categories. We explain several other
useful features of relational ologs not possessed by most description logics, such as a
type system and a rich, Ô¨Çexible notion of instance data. In a more theoretical vein, we
draw on categorical logic to show how relational ologs can be translated to and from
logical theories in a fragment of Ô¨Årst-order logic. Although we make extensive use of
categorical language, this paper is designed to be self-contained and has considerable
expository content. The only prerequisites are knowledge of Ô¨Årst-order logic and the
rudiments of category theory.
1. Introduction
The representation of human knowledge in computable form is among the oldest and most
fundamental problems of artiÔ¨Åcial intelligence. Several recent trends are stimulating continued
research in the Ô¨Åeld of knowledge representation (KR). The birth of the Semantic Web
[BHL01] in the early 2000s has led to new technical standards and motivated new machine
learning techniques to automatically extract knowledge from unstructured text [Nic+16].
In the scientiÔ¨Åc community, successful knowledge bases like the Gene Ontology [Ash+00]
have inspired a proliferation of ontologies across biology and biomedicine [Noy+09]. This
development belongs to a general trend towards greater openness and interconnectivity in
science. Optimists dream of a future science in which all scientiÔ¨Åc knowledge is open, online,
and interpretable by machines [Nie12].
1
arXiv:1706.00526v2  [cs.AI]  1 Nov 2017

Description logic is the dominant formalism for knowledge representation today. In particular,
the language OWL (Web Ontology Language), a W3C standard underlying the Semantic
Web, is a description logic [Gra+08]. Description logics are logical calculi designed speciÔ¨Åcally
for knowledge representation. They lie somewhere between propositional logic and Ô¨Årst-order
predicate logic, striking a trade-oÔ¨Äbetween computational tractability and expressivity.
In parallel with the invention of description logic and the Semantic Web, a mostly disjoint
community of mathematicians, physicists, and computer scientists have discovered that
category theory, popularly known for its abstruseness, is useful not just for describing abstract
mathematical structures, but for modeling such diverse real-world phenomena as databases,
programming languages, electrical circuits, and quantum mechanics [Spi12; LS88; BF15;
AC04]. The ethos of this research program is that category theory can serve as a general-
purpose modeling language for science and engineering. Having internalized this perspective,
it is but a short step to contemplate a general-purpose knowledge representation system based
on category theory. In this spirit, Spivak and Kent have recently introduced the ontology log
(or olog), a simple and elegant categorical framework for knowledge representation [SK12].
An objective of this paper is to understand the relationship between the logical and algebraic
approaches to knowledge representation. To that end, we introduce a third knowledge
representation formalism that interpolates between description logic and ontology logs. We
call it the relational ontology log, or relational olog. Spivak and Kent‚Äôs ologs, which we
sometimes call functional ologs to avoid confusion, are based on Set, the archetypal category
of sets and functions. Relational ologs are based on Rel, the category of sets and relations.
That may sound a small diÔ¨Äerence, since functions and relations are often interchangeable,
but it leads to very diÔ¨Äerent modes of expression. Functional ologs achieve their expressivity
through categorical limits and colimits (products, pullbacks, pushforwards, etc.), while
relational ologs rely mainly on relational algebra (intersections, unions, etc.). In this sense,
relational ologs are actually closer to description logic than to functional ologs.
Practitioners of description logic will Ô¨Ånd in relational ologs several useful features not
possessed by most existing KR systems, including OWL. Some of these features are awkward
to handle in a purely logical system; all emerge automatically from the categorical framework.
First, functors allow instance data to be associated with an ontology in a mathematically
precise way. Instance data can be interpreted as a relational or graph database or can take
more exotic forms. Second, relational ologs are by default typed. We argue that types,
if used judiciously, can mitigate the maintainability challenges posed by the open world
semantics of description logic. Finally, relational ologs have a friendly and intuitive‚Äîyet
fully precise‚Äîgraphical syntax, derived from the string diagrams of monoidal categories. We
expect that this graphical language will appeal to technical and non-technical users alike.
How to read this paper
We have tried to write a paper that is accessible to a diverse
audience. All Remarks and Appendices are technical and can be skipped on a Ô¨Årst reading.
The mathematical prerequisites are limited as follows. We assume the reader is familiar
with the syntax and semantics of Ô¨Årst-order logic. No prior knowledge of description logic is
required. We expect the reader to know the ‚Äúbig three‚Äù concepts of category theory‚Äîcategory,
2

functor, and natural transformation‚Äîbut we do not assume knowledge of categorical logic
or monoidal categories and their graphical languages. References for further reading are
provided where appropriate.
Readers who prefer to begin with an extended example may proceed immediately to Section 5.1,
referring to Section 3 as needed to understand the graphical notation. The core of the paper,
explaining the categorical-relational approach to knowledge representation, is Sections 3 to 7.
The other sections develop extensions of our methodology and make connections to other
branches of mathematics and knowledge representation.
Organization of paper
In the next section, we review description logic as a computationally
tractable subset of Ô¨Årst-order logic and describe several widely used description logics. In
Section 3, we introduce Rel, the category of sets and relations, and use it to illustrate the
general concepts of monoidal categories and their graphical languages. We also make initial
contact with the basic notions of description logic. Motivated by Rel, in Section 4 we present
the bicategory of relations, a categorical abstraction of relational algebra invented by Carboni
and Walters. Section 5 deÔ¨Ånes a relational olog to be a Ô¨Ånitely presented bicategory of
relations and illustrates with an extended example. Sections 6 and 7 discuss the implications
of instance data and types for knowledge representation. In Section 8, we take a sojourn into
categorical logic, proving that regular logic is the internal language of bicategories of relations.
This result establishes a formal connection between relational ologs and a fragment of typed
Ô¨Årst-order logic. In Section 9, we introduce the distributive relational olog, an extension of the
relational olog with high expressivity. In the Ô¨Ånal Section 10, we comment on the philosophy
of categorical knowledge representation and suggest directions for future research. The two
Appendices bring mathematical rigor to the informal discussion of categorical logic in the
main text.
2. Description logic
Early knowledge representation systems, based on semantic networks or frames, often lacked
a formal semantics. The intended meanings of the elements of such systems were deÔ¨Åned only
implicitly or operationally by the inference algorithms that manipulated them. As a result,
researchers found it diÔ¨Écult to reason generally about these systems, independent of any
speciÔ¨Åc implementation. Arguments were advanced that knowledge representation should be
grounded in formal logic [Woo75]. First-order logic, ever the ‚Äúdefault‚Äù logical system, seems
like a natural place to start.
Description logic (DL) is motivated by the deÔ¨Åciencies of Ô¨Årst-order logic as a foundation for
knowledge representation. Chief among these is computational intractability: Ô¨Årst-order logic,
while quite expressive, is undecidable. The basic description logics are subsets of Ô¨Årst-order
logic designed to be decidable (although not always in polynomial time). The tradeoÔ¨Ä
between expressivity and tractability was emphasized by the earliest papers on description
logic [BL84]. Another point, less frequently mentioned, is that description logic is simpler
3

and more user friendly than Ô¨Årst-order logic. As we will see, its syntax suppresses variables,
both bound and free, and imposes strict limits on the logical sentences that can be formed.
Given that most users of knowledge representation systems are domain experts in scientiÔ¨Åc
or business Ô¨Åelds, not professional mathematicians, it is important that KR formalisms be
easily interpretable and maintainable. A knowledge base consisting of a collection of arbitrary
Ô¨Årst-order sentences will probably not meet this requirement.
2.1. Review of description logic
In this section, we briskly review description logic. General introductions to description
logic include the survey [KSH12] and the textbook chapter [BL04, Ch. 9] by Brachman and
Levesque. A comprehensive reference is the Description Logic Handbook [Baa+07]. For the
perspectives of the bioinformatics and Semantic Web communities, see [RB11] and [HKR09],
respectively.
Description logic uses a special nomenclature to specify the features possessed by a given
system. The base system, from which most others are derived, is called AL (for Attributive
Concept Language). Given a collection of atomic concepts, denoted A, and atomic roles,
denoted R or S, the concept descriptions of AL are well-formed terms of the grammar:
C, D
::=
A |
(atomic concept)
‚ä§|
(universal concept)
‚ä•|
(bottom concept)
¬¨A
(atomic negation)
C ‚äìD |
(intersection)
‚àÄR.C |
(value restriction)
‚àÉR.‚ä§
(limited existential quantiÔ¨Åcation).
Note that negating arbitrary concepts is not allowed in AL. Concepts and roles are interpreted
as unary and binary predicates in Ô¨Årst-order logic:
(¬¨A)(x)
iÔ¨Ä
¬¨A(x)
(C ‚äìD)(x)
iÔ¨Ä
C(x) ‚àßD(x)
(‚àÄR.C)(x)
iÔ¨Ä
‚àÄy.(R(x, y) ‚ÜíC(y))
(‚àÉR.‚ä§)(x)
iÔ¨Ä
‚àÉy.R(x, y)
A terminological box or TBox is a collection of terminological axioms of form
C ‚äëD
or
C ‚â°D,
interpreted as the Ô¨Årst-order sentences
‚àÄx.(C(x) ‚ÜíD(x))
or
‚àÄx.(C(x) ‚ÜîD(y)).
4

ID
Name
DL Syntax
FOL Interpretation
C
Concept negation
¬¨C
¬¨C(x)
U
Concept union
C ‚äîD
C(x) ‚à®D(x)
E
Full existential quantiÔ¨Åcation
‚àÉR.C
‚àÉy.(R(x, y) ‚àßC(y))
H
Role axioms
R ‚äëS
‚àÄx, y.(R(x, y) ‚ÜíS(x, y))
R ‚â°S
‚àÄx, y.(R(x, y) ‚ÜîS(x, y))
O
Nominals (concept literals)
{a1, . . . , an}
{a1, . . . , an}
I
Inverse roles
R‚àí
R‚àí(x, y) ‚ÜîR(y, x)
F
Functional role
‚â§1R
see below
N
Number restriction
‚â•nR
see below
= nR
‚â§nR
Q
QualiÔ¨Åed number restriction
‚â•nR.C
see below
= nR.C
‚â§nR.C
N/A
Role intersection
R ‚äìS
R(x, y) ‚àßS(x, y)
N/A
Role union
R ‚äîS
R(x, y) ‚à®S(x, y)
N/A
Role composition
R ‚ó¶S
‚àÉy.R(x, y) ‚àßS(y, z)
R
Regular role inclusion
R1 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶Rn ‚äëS
see below
(D)
Concrete domains (data types)
varies
varies
Table 1: Summary of AL language extensions
An assertional box or ABox is a collection of assertional axioms of form
C(a)
or
R(a, b),
where a, b are names of individuals. A knowledge base or ontology in description logic consists
of a TBox and an ABox. Given the above translations into Ô¨Årst-order logic, there is an
obvious notion of an interpretation or model of a knowledge base. Thus description logic
inherits a model-theoretic semantics from Ô¨Årst-order logic.
More expressive description logics are obtained by adjoining to AL additional concept and
role constructors, identiÔ¨Åed by script letters like C and U. The literature describes countless
such extensions; Table 1 lists the most important ones. As a warning, a few identiÔ¨Åers (like
F and R) are not used consistently across the literature.
Several DL constructs in Table 1 deserve elaboration. The qualiÔ¨Åed number restriction (Q)
term ‚â•nR.C (respectively ‚â§nR.C) denotes the class of elements related by R to at least n
(respectively at most n) elements of class C. In Ô¨Årst-order logic,
(‚â•nR.C)(x)
iÔ¨Ä
‚àÉy1, . . . , yn.
Ô£´
Ô£≠^
1‚â§i‚â§n
(R(x, yi) ‚àßC(yi)) ‚àß
^
1‚â§i<j‚â§n
yi Ã∏= y‚Ä≤
j
Ô£∂
Ô£∏
(‚â§nR.C)(x)
iÔ¨Ä
‚àÄy1, . . . , yn+1.
Ô£´
Ô£≠^
1‚â§i‚â§n
(R(x, yi) ‚àßC(yi)) ‚Üí
_
1‚â§i<j‚â§n+1
yi = y‚Ä≤
j
Ô£∂
Ô£∏.
5

Number restriction (N) and functional roles (F) are special cases of qualiÔ¨Åed number
restriction. Concrete domains ((D)) refer to data types, such as natural numbers or real
numbers, and operations on them, such as addition and multiplication. We return to the
topic of data types in Section 7.
Most descriptions logics do not allow arbitrary intersection, union, or composition of roles.
However, composition-based regular role inclusion (R) is widely used. System R allows
axioms of form R1 ‚ó¶¬∑ ¬∑ ¬∑ ‚ó¶Rn ‚äëS, where R1, . . . , Rn are atomic roles, provided there are no
cycles between axioms. This acyclicity requirement, which we will not make precise, leads to
favorable computational properties. Note that R is sometimes taken to include additional,
ad hoc features like reÔ¨Çexivity, ‚Äúlocal‚Äù reÔ¨Çexivity, irreÔ¨Çexivity, and disjoint roles [HKS05;
HKS06].
A few description logics are privileged in theory or practice. The minimal language AL is too
inexpressive for most applications. The central language in the theory of description logic is
ALC. It is logically equivalent to ALUE, although the shorter name ALC is preferred. In
a break with the standard nomenclature, the language S is ALC plus transitive roles. The
Web Ontology Languages are derived from system S. For example, OWL 1 Lite corresponds
to SHIF(D), OWL 1 DL to SHION(D), and OWL 2 DL to SROIQ(D).
2.2. Structure of description logic
To put the subsequent developments in context, we make a few observations about the
structure of description logic. Since description logic is not a single logical system, but rather
a large federation of systems, it is diÔ¨Écult to make broad generalizations. Nevertheless, some
general themes can be discerned.
An obvious syntactic diÔ¨Äerence between description logic and Ô¨Årst-order logic is that the
former is point-free while the latter is not. By ‚Äúpoint-free‚Äù we mean that the concept and
role constructors of description logic suppress all variables, free and bound. First-order logics
without variables do exist‚ÄîTarksi, for example, studied such systems in his last major work
[TG87]‚Äîbut, outside of description logic, they are rare in research and in practice. In this
respect, relational ologs are like description logic: both the textual and graphical syntaxes of
relational ologs are point-free.
Description logics characteristically impose strict limitations on how concepts and roles may
be combined. Thus, not all Ô¨Årst-order sentences are expressible in description logic. The
same is true of relational ologs: we shall see that when relational ologs are interpreted as
Ô¨Årst-order theories (Section 8), not all Ô¨Årst-order sentences are expressible.
Moreover, there are structural similarities between the Ô¨Årst-order sentences that are expressible
in the two formalisms. In description logic, terminological axioms C ‚äëD and R ‚äëS typically
translate into Ô¨Årst-order sentences of form
‚àÄx1 ¬∑ ¬∑ ¬∑ ‚àÄxn(œï ‚Üíœà),
6

where œï and œà are formulas containing only the connectives and quantiÔ¨Åers ‚àß, ‚à®, ‚ä§, ‚ä•, ‚àÉ.
(Depending on the language, exceptions can arise from value restrictions ‚àÄR.C and number
restrictions like ‚â§nR.C. However, these constructors are acceptable in axioms of form
‚àÄR.C ‚äë‚ä§or ‚àÄR.C ‚äë‚ä•. Concept negations ¬¨C also present exceptions.) The logical system
just described is called coherent logic. The weaker system of regular logic is obtained when
œï and œà are further restricted to the connectives and quantiÔ¨Åers ‚àß, ‚ä§, ‚àÉ. We shall see that
regular logic and coherent logic are closely connected to relational ologs (Sections 8 and 9).
3. The category of relations
In this section we introduce Rel, the category of sets and relations. Although the reader is
doubtless familiar with sets and relations, we think it helpful to start the development in this
very concrete setting. We will introduce monoidal categories and their graphical languages
by equipping Rel with various categorical structures, such as a monoidal product, diagonals
and codiagonals, and a dagger operator. These structures on Rel motivate the more abstract
‚Äúcategories of relations‚Äù needed for knowledge representation (Section 4). We will also make
initial contact with description logic.
Our presentation draws on the physics-oriented survey by Coecke and Paquette [CP10], where
Rel is viewed as a ‚Äúquantum-like‚Äù category, in contrast to the ‚Äúclassical-like‚Äù category Set.
The excellent surveys [BS10] and [Sel10] also provide more detail about monoidal categories
and their applications and graphical languages. General introductions to category theory, in
order of increasing sophistication, are [LS09; Spi14; Awo10; Lei14; Rie16; Mac98].
DeÔ¨Ånition. The category of sets and relations, denoted by Rel, is the category whose objects
are sets and whose morphisms R : X ‚ÜíY are subsets R ‚äÜX √ó Y . The composition of
R : X ‚ÜíY and S : Y ‚ÜíZ, written R ¬∑ S : X ‚ÜíZ or RS : X ‚ÜíZ, is given by
xRSz
iÔ¨Ä
‚àÉy ‚ààY : xRy ‚àßyRz,
where xRy means that (x, y) ‚ààR. For any set X, the identity morphism 1X is the diagonal
relation:
x(1X)x‚Ä≤
iÔ¨Ä
x = x‚Ä≤.
The notion of composition of relations is natural and important. Notice that when R and
S are (graphs of) functions, RS is the usual composition of functions. Also, the identity
morphism is the usual identity function. As a result, Set, the category of sets and functions,
is a subcategory of Rel.
Remark. As illustrated by the deÔ¨Ånition, we compose morphisms in left-to-right or ‚Äúdiagram-
matic‚Äù order. We make this choice for consistency with the graphical syntax, which is read
from left to right. It is also consistent with the notation xRy for (x, y) ‚ààR.
Unlike Set, the category Rel is a special kind of a 2-category.
7

DeÔ¨Ånition. A category C is a locally posetal 2-category if between any two morphisms
f, g : A ‚ÜíB with common domain and codomain, there exists at most one 2-morphism,
written
A
B
f
g
or more succintly f ‚áíg, together with operations of vertical composition,
A
B
f
g
h
‚áù
A
B
f
h
,
and horizontal composition,
A
B
C
f
g
h
k
‚áù
A
C
f¬∑h
g¬∑k
,
such that each hom-set C(A, B) is a poset (partially ordered set) under the relation ‚áí.
In Rel, we stipulate that R ‚áíS if there is a set containment R ‚äÜS. Vertical composition
simply says that set containment is transitive. More interestingly, horizontal composition
says that containment is preserved by composition of relations: if R ‚äÜS and T ‚äÜU, then
R ¬∑T ‚äÜS ¬∑U. Furthermore, the hom-sets are posets because R ‚äÜR and also R = S whenever
R ‚äÜS and S ‚äÜR. Thus Rel is a locally posetal 2-category. In this context, the symbol ‚áí
has a happy double meaning: we can read ‚áías a generic 2-morphism or as logical implication.
In the terminology of description logic, 2-morphisms are subsumptions.
3.1. Monoidal category
We will make Rel into a monoidal category by equipping it with the Cartesian product. We
Ô¨Årst state the general deÔ¨Ånition of a monoidal category.
DeÔ¨Ånition. A (strict) monoidal category (C, , I) is a category C together with a functor
 : C √ó C ‚ÜíC, called the monoidal product, and an object I, called the monoidal unit, such
that (, I) behaves like a monoid on the objects and morphisms of C, in the following sense.
For objects A, B, C, we have
A  (B  C) = (A  B)  C,
A  I = I  A = I,
and for morphisms f, g, h, we have
f  (g  h) = (f  g)  h,
f  1I = 1I  f = f.
8

More explicitly, functorality of the monoidal product  means that for any objects A, B,
1A  1B = 1AB
and for any morphisms f : A ‚ÜíB, g : B ‚ÜíC, h : D ‚ÜíE, k : E ‚ÜíF,
(f ¬∑ g)  (h ¬∑ k) = (f  h) ¬∑ (g  k).
Let us immediately introduce the graphical language of string diagrams that is associated
with any monoidal category. In this language, objects are represented by wires and morphisms
are represented by boxes with incoming and outgoing wires. A generic morphism f : A ‚ÜíB
is represented as
f
A
B
.
The composite fg : A ‚ÜíC of f : A ‚ÜíB and g : B ‚ÜíC is
f
A
g
B
C
and the monoidal product f  g : A  B ‚ÜíC  D of f : A ‚ÜíB and g : C ‚ÜíD is
f
g
A
C
B
D
.
Identity morphisms are represented specially as a bare wire:
1A
=
A
.
Each time we introduce a new monoidal structure, we will augment the graphical language
accordingly.
String diagrams are among the most beautiful aspects of the theory of monoidal categories.
Unlike the diagrams and Ô¨Çowcharts found throughout the engineering literature, which have
no formal meaning, string diagrams provide a formal calculus for reasoning in monoidal
categories. More precisely, coherence theorems guarantee that string diagrams constitute
a sound and complete calculus for equational reasoning with morphisms in a monoidal
category. Coherence theorems are emphasized by Selinger‚Äôs comprehensive survey [Sel10].
All string diagrams in this paper are drawn by the author‚Äôs (highly experimental) library for
computational category theory [Pat17].
9

The Cartesian product makes Rel into a monoidal category in the most straightforward way.
(Later we will see that it is not the only interesting monoidal product on Rel.) On objects,
deÔ¨Åne
X  Y := X √ó Y = {(x, y) : x ‚ààX, y ‚ààY }
and given morphisms R : X ‚ÜíY and S : Z ‚ÜíW, deÔ¨Åne R  S : X  Z ‚ÜíY  W by
(x, z)(R  S)(y, w)
iÔ¨Ä
xRy ‚àßzSw.
The monoidal unit is any singleton set, which we write as I = {‚àó}.
Remark. Technically, Rel is not a strict monoidal category, as deÔ¨Åned above, because the
Cartesian product is not strictly associative: X √ó (Y √ó Z) Ã∏= (X √ó Y ) √ó Z. Of course, there
is a natural isomorphism X √ó (Y √ó Z) ‚àº= (X √ó Y ) √ó Z, mapping (x, (y, z)) to ((x, y), z),
that allows us to identify these two sets. Similarly, X √ó I Ã∏= X but there is a natural
isomorphism X √ó I ‚àº= X that identiÔ¨Åes (x, ‚àó) with x. Such considerations lead to the general
deÔ¨Ånition of a monoidal category, where strict associativity and units are replaced with
associator and unitor natural isomorphisms, subject to some coherence conditions. However,
the coherence theorem for monoidal categories [Mac63] ensures that a general monoidal
category is monoidally equivalent to some strict monoidal category, called its strictiÔ¨Åcation.
As a result, we adopt the common practice of suppressing associators and unitors, eÔ¨Äectively
replacing every monoidal category by its strictiÔ¨Åcation. Note that the graphical language
implicitly performs this strictiÔ¨Åcation. Incidentally, the abstract categories of relations we
construct in Section 8 will actually be strict monoidal categories.
As in most monoidal categories in encountered in practice, in Rel the order of inputs and
outputs can be freely exchanged.
DeÔ¨Ånition. A monoidal category (C, , I) is a symmetric monoidal category if there is a
natural family of isomorphisms
œÉA,B : A  B ‚ÜíB  A,
A, B ‚ààC,
called braidings, satisfying œÉ‚àí1
A,B = œÉB,A.
In the graphical language, braidings are represented by crossed wires:
œÉA,B
=
A
B
B
A
.
The braidings in Rel are deÔ¨Åned by
(x, y) œÉX,Y (y‚Ä≤, x‚Ä≤)
iÔ¨Ä
x = x‚Ä≤ ‚àßy = y‚Ä≤.
In Rel, unlike in Set, there is a fundamental duality between inputs and outputs under which
any input can be turned into an output and vice versa. This duality is captured abstractly
by the following deÔ¨Ånition.
10

DeÔ¨Ånition. A symmetric monoidal category (C, , I) is a compact closed category if for every
object A ‚ààC, there is an object A‚àó, the dual of A, and a pair of morphisms Œ∑A : I ‚ÜíA‚àó A
and œµA : A  A‚àó‚ÜíI, the unit and counit respectively, which satisfy the triangle or zig-zag
identities:
A
A  A‚àó A
A
1AŒ∑A
1A
œµA1A
A‚àó
A‚àó A  A‚àó
A‚àó
Œ∑A1A‚àó
1A‚àó
1A‚àóœµA .
The prototypical example of a compact closed category is (Vectk, ), the category of Ô¨Ånite-
dimensional vector spaces (over a Ô¨Åxed Ô¨Åeld k) and linear maps, equipped with the tensor
product. The monoidal unit is I = C, the one-dimensional vector space. As expected, the
dual A‚àóof a vector space A is the space of linear maps A ‚ÜíC. The unit Œ∑A : I ‚ÜíA‚àó A
maps c to c1A and the counit œµA : A  A‚àó‚ÜíI is the trace operator.
Rel is a self-dual compact closed category. That is, every object is its own dual (X‚àó= X).
The unit Œ∑X : I ‚ÜíX  X and counit œµX : X  X ‚ÜíI are deÔ¨Åned by
(‚àó) Œ∑X (x, x‚Ä≤)
iÔ¨Ä
x = x‚Ä≤
iÔ¨Ä
(x, x‚Ä≤) œµX (‚àó).
In the graphical language, these morphisms are represented as ‚Äúbent wires‚Äù:
Œ∑X
=
X
X
œµX
=
X
X
.
The zig-zag identities assert that ‚Äúzig-zags can be straightened out‚Äù:
=
=
.
Remark. String diagrams for compact closed categories typically include arrowheads on the
wires to distinguish objects
A
‚àí‚àí‚Üífrom their duals
A‚àó
‚àí‚àí‚Üí, which are drawn as reversed arrows
A
‚Üê‚àí‚àí. Because we work in self-dual categories, we can safely omit the arrowheads.
We have amassed enough structure to specify relations of arbitrary arity. Relations B : I ‚ÜíI
whose domain and codomain are the monoidal unit constitute the degenerate case of arity
zero. Since I = {‚àó} is the singleton set, the hom-set Rel(I, I) has only two members: the
11

identity relation 1I = {(‚àó, ‚àó)} and the empty relation ‚àÖ. DeÔ¨Åning ‚ä§:= 1I and ‚ä•:= ‚àÖ, we
interpret relations B : I ‚ÜíI as booleans.
Next, we have unary and binary relations. A unary relation C : X ‚ÜíI is called a class or
concept in the description logic literature. Its elements have the form (x, ‚àó), where x ‚ààX.
In the graphical calculus, wires of type I are not drawn at all, so a concept C : X ‚ÜíI is
represented as
C
X
.
A binary relation R : X ‚ÜíY , or role in description logic jargon, is depicted as
R
X
Y
,
as we have seen.
Finally, we can easily express higher-order relations. A relation of arity n is a morphism of
form R : X1  ¬∑ ¬∑ ¬∑  Xn ‚ÜíI. For instance, here is a ternary relation R : X  Y  Z ‚ÜíI:
R
X
Y
Z
Apparently, there are two conventions for representing a binary relation: as a morphism
R : X ‚ÜíY or a morphism R : X  Y ‚ÜíI. By bending wires, we can pass freely between
the two representations, via the transformations
R
X
Y
‚áù
R
X
Y
and
R
X
Y
‚áù
R
,
which, by the zig-zag identities, are mutually inverse. Most description logics do not support
relations of arity greater than two, in part because the point-free textual syntax becomes quite
awkward [Baa+07, ¬ß5.7]. The graphical language of monoidal categories enables graceful and
intuitive composition even when relations have multiple inputs and outputs.
12

3.2. Dagger category
Every relation R : X ‚ÜíY in Rel has an opposite relation R‚Ä† : Y ‚ÜíX, also known as the
converse or inverse relation, deÔ¨Åned by
yR‚Ä†x
iÔ¨Ä
xRy.
This structure is axiomatized by the following deÔ¨Ånition.
DeÔ¨Ånition. A dagger category is a category C equipped with a contravariant functor (‚àí)‚Ä† :
Cop ‚ÜíC that is the identity on objects and is involutive, i.e., ((‚àí)‚Ä†)‚Ä† = 1C.
More explicitly, a dagger category is a category C such that to every morphism f : A ‚ÜíB
there corresponds a morphism f ‚Ä† : B ‚ÜíA, and the correspondence satisÔ¨Åes
1A
‚Ä† = 1A,
(fg)‚Ä† = g‚Ä†f ‚Ä†,
and
(f ‚Ä†)‚Ä† = f.
When C is a monoidal category, one typically asks that the dagger respect the monoidal
structure.
DeÔ¨Ånition. A symmetric monoidal category C is a dagger symmetric monoidal category if C
is a dagger category and (‚àí)‚Ä† is a symmetric monoidal functor, i.e.,
(f  g)‚Ä† = f ‚Ä†  g‚Ä†
and
œÉ‚Ä†
A,B = œÉB,A = œÉ‚àí1
A,B.
A compact closed category C is a dagger compact category if C is a dagger symmetric monoidal
category and for each object A ‚ààC, there is a commutative diagram
I
A  A‚àó
A‚àó A
œµ‚Ä†
A
Œ∑A
œÉA,A‚àó.
Remark. Dagger compact categories have been introduced and studied in the context of
quantum computing [Sel07].
The prototypical example is Hilb, the category of Ô¨Ånite-
dimensional Hilbert spaces and linear maps, equipped with the tensor product. Here f ‚Ä† is
the usual adjoint (or Hermitian conjugate) of the linear map f. For this reason, in a general
dagger category C, the morphism f ‚Ä† is often called the adjoint of f. To avoid confusion with
the 2-categorical notion of adjoint, invoked in Section 4, we do not use this terminology.
In the graphical language, f ‚Ä† is represented by taking the ‚Äúmirror image‚Äù of f:
f ‚Ä†
B
A
:=
f
B
A
.
Equivalently, given any morphism f drawn as a string diagram‚Äîwhich we read from left to
right, as usual‚Äîwe get f ‚Ä† by reading the same diagram from right to left.
13

With the dagger operation deÔ¨Åned above, Rel is a dagger compact category. However, unlike
most dagger compact categories, Rel is self-dual. Thus there is potentially a second way to
transform a morphism X ‚ÜíY into a morphism Y ‚ÜíX: bend both the input and the output
wires. These two operations are actually the same, which we can express graphically as:
R
=
R
.
This equation is a generalization of the zig-zag identity: if we imagine ‚Äústraightening out‚Äù the
right-hand side by pulling on the ends of the input and output wires, we obtain the left-hand
side. Mathematically speaking, the dagger structure on Rel is superÔ¨Çuous since it can be
reduced to the compact closed structure. We choose to make the dagger structure explicit
because inverse relations occur frequently in practice and the associated graphical language
is succinct and intuitive.
3.3. Diagonals and codiagonals
In our Ô¨Ånal topic of this section, we show that the category of relations has operations
for ‚Äúcopying‚Äù and ‚Äúdeleting‚Äù data and, dually, for ‚Äúmerging‚Äù and ‚Äúcreating‚Äù data. Using
these operations, we can express intersections of classes and relations and, more generally,
logical operations involving conjunction. We also obtain an important characterization of the
‚Äúfunctional relations‚Äù, or maps, in Rel.
The ‚Äúcopying‚Äù and ‚Äúmerging‚Äù operations are deÔ¨Åned by internal comonoids and monoids,
respectively, in Rel. We recall the general deÔ¨Ånition of a (co)monoid in a monoidal category.
DeÔ¨Ånition. Let (C, , I) be a monoidal category. An internal monoid in C is an object
M ‚ààC together with a multiplication morphism ¬µ : M  M ‚ÜíM and a unit morphism
Œ∑ : I ‚ÜíM such that
M  M  M
M  M
M  M
M
1M¬µ
¬µ1M
¬µ
¬µ
I  M
M  M
M  I
M
Œ∑1M
¬µ
1MŒ∑
.
Dually, an internal comonoid in C is an internal monoid in Cop. In concrete terms, an internal
comonoid is an object C together with a comultiplication morphism Œ¥ : C ‚ÜíC  C and a
counit morphism œµ : C ‚ÜíI such that
C
C  C
C  C
C  C  C
Œ¥
Œ¥
Œ¥1C
1CŒ¥
C
I  C
C  C
C  I
Œ¥
œµ1C
1Cœµ
.
14

If C is a symmetric monoidal category, we say that an internal monoid (M, ¬µ, Œ∑) is commutative
if
M  M
M  M
M
œÉM,M
¬µ
¬µ
.
Dually, an internal comonoid (C, Œ¥, œµ) is cocommutative if
C
C  C
C  C
Œ¥
Œ¥
œÉC,C .
Note that an internal monoid in Set is just a monoid in the usual sense, i.e., a set M
equipped an associative binary operation ¬µ and an identity element Œ∑. Likewise, an internal
commutative monoid in Set is just a commutative monoid.
We deÔ¨Åne a family of internal (co)monoids in Rel as follows.
For each set X, deÔ¨Åne
‚àÜX : X ‚ÜíX  X by
x ‚àÜX (x‚Ä≤, x‚Ä≤‚Ä≤)
iÔ¨Ä
x = x‚Ä≤ ‚àßx = x‚Ä≤‚Ä≤,
and deÔ¨Åne ‚ô¶X : X ‚ÜíI by ‚ô¶X = {(x, ‚àó) : x ‚ààX} (so that x(‚ô¶X)‚àóholds for every x ‚ààX).
It is easily veriÔ¨Åed that (X, ‚àÜX, ‚ô¶X) is a cocommutative comonoid in Rel. By taking the
opposite relations
‚àáX := ‚àÜ‚Ä†
X : X  X ‚ÜíX
and
‚ñ°X := ‚ô¶‚Ä†
X : I ‚ÜíX,
we also obtain for each set X a commutative monoid (X, ‚àáX, ‚ñ°X) in Rel. We think of ‚àÜX
as ‚Äúcopying‚Äù or ‚Äúduplicating,‚Äù ‚àáX as ‚Äúmerging,‚Äù ‚ô¶X as ‚Äúdeleting‚Äù or ‚Äúerasing,‚Äù and ‚ñ°X
as ‚Äúcreating.‚Äù These interpretations will be manifest from the graphical language, to be
demonstrated shortly. However, for the graphical language to be consistent, the family of
(co)monoids must satisfy certain coherence axioms, which ensure that they interact properly
with the monoidal product. These axioms are captured by the following deÔ¨Ånition.
DeÔ¨Ånition ([Sel99]). A monoidal category with diagonals is a symmetric monoidal category
C together with a family of morphisms ‚àÜA : A ‚ÜíA  A and ‚ô¶A : A ‚ÜíI, not necessarily
natural in objects A, such that each triple (A, ‚àÜA, ‚ô¶A) is a cocommutative comonoid in C
and obeys the coherence axioms
‚ô¶I = 1I,
‚ô¶AB = ‚ô¶A  ‚ô¶B,
‚àÜAB = (‚àÜA  ‚àÜB)(1A  œÉA,B  1B).
Dually, a monoidal category with codiagonals is a symmetric monoidal category C together
with a family of morphisms ‚àáA : A  A ‚ÜíA and ‚ñ°A : I ‚ÜíA such that each triple
(A, ‚àáA, ‚ñ°A) is commutative monoid in C and obeys the coherence axioms
‚ñ°I = 1I,
‚ñ°AB = ‚ñ°A  ‚ñ°B,
‚àáAB = (1A  œÉB,A  1B)(‚àáA  ‚àáB).
15

Remark. When the monoidal category C is, like Rel, not strict, we also need coherence axioms
asserting that ‚àÜI and ‚àáI are the unitors realizing the isomorphism I ‚àº= I  I.
The graphical language of a monoidal category with diagonals is
‚àÜA
=
A
,
‚ô¶A
=
A
.
Similarly, the graphical language of a monoidal category with codiagonals is
‚àáA
=
A
,
‚ñ°A
=
A
.
By the coherence axioms, we can express the diagonal morphisms for a product A  B in the
graphical language as
‚àÜAB
=
A
B
A
B
A
B
,
‚ô¶AB
=
A
B
.
Of course, there is a dual picture for the codiagonal morphisms.
Under the above deÔ¨Ånitions, Rel is a monoidal category with diagonals and codiagonals.
A quick calculation shows that the intersection R ‚à©S of two relations R, S : X ‚ÜíY with
common domain X and codomain Y is ‚àÜX(R  S)‚àáY or, in graphical language,
R ‚à©S
=
X
R
S
Y
.
As a special case, the intersection of two classes C, D : X ‚ÜíI is
C ‚à©D
=
X
C
D
.
16

We can also express many of the basic concept constructors in description logic. For any
relation R : X ‚ÜíY and class C : Y ‚ÜíI, the ‚Äúlimited‚Äù existential quantiÔ¨Åcation ‚àÉR.‚ä§is the
class
R
X
Y
and the ‚Äúfull‚Äù existential quantiÔ¨Åcation ‚àÉR.C is the class
R
X
C
Y
.
In contrast to description logic, we can retain access to the domain or codomain of the
relation R while restricting its values. For instance, given classes C : X ‚ÜíI and D : Y ‚ÜíI,
the relation
X
R
C
D
Y
consists of all pairs (x, y) ‚ààX √óY satisfying xRy ‚àßxC‚àó‚àßyD‚àó. The value restriction concept
constructor ‚àÄR.C cannot be expressed as a single morphism, but we can achieve the same
eÔ¨Äect by declaring a subsumption of two diÔ¨Äerent morphisms:
R
X
Y
=‚áí
C
Y
.
This 2-morphism asserts that ‚àÄx ‚ààX.‚àÄy ‚ààY.(xRy ‚ÜíyC‚àó).
Finally, we can express a typed variant of the ‚Äúuniversal role‚Äù in description logic. The local
maximum
‚ä§X,Y
:=
X
Y
is the (unique) maximum element of the poset Rel(X, Y ), namely X √ó Y . It generalizes the
top element ‚ä§= ‚ä§I,I = 1I of the booleans Rel(I, I).
Maps
The diagonal structure on Rel leads to an abstract characterization of the relations
that are functions, i.e., the relations R : X ‚ÜíY with the property that for every x ‚ààX,
there exists a unique y ‚ààY such that xRy. This matter is closely connected to the naturality,
or lack thereof, of the diagonal in Rel. In general, a diagonal in a symmetric monoidal
category C is natural if for every morphism f : A ‚ÜíB, we have f‚àÜB = ‚àÜA(f  f) and
f‚ô¶B = ‚ô¶A, or graphically
f
A
B
=
A
f
f
B
B
17

and
f
A
B
=
A
.
The Ô¨Årst equation has the interpretation that applying f, then copying the output is the
same as copying the input, then applying f to both copies; the second that applying f,
then deleting the output is the same as deleting the input. When both equations hold for a
morphism f, we say that f is a comonoid homomorphism. In a general category, we expect
the equations to hold for morphisms that ‚Äúbehave like functions.‚Äù
The diagonal in Rel is not natural because not all relations are functions. However, for any
relation R : X ‚ÜíY , there are 2-morphisms
R
X
Y
=‚áí
X
R
R
Y
Y
R
X
Y
=‚áí
X
.
We say that every morphism in Rel is a lax comonoid homomorphism. Explicitly, the
2-morphisms are the inclusions
{(x, y, y) : xRy} ‚äÜ{(x, y, y‚Ä≤) : xRy ‚àßxRy‚Ä≤}
{(x, ‚àó) : ‚àÉy ‚ààY.xRy} ‚äÜ{(x, ‚àó) : x ‚ààX}.
When the Ô¨Årst inclusion is an equality, R is a partial function; when the second is an equality,
R is total; when both are equalities, R is a function or a map. In other words, the comonoid
homomorphisms in Rel are exactly the relations that are functions.
Of course, for every concept about the diagonal, there is a dual concept about the codiagonal,
whose details we omit. In Rel, we obtain abstract characterizations of the injective, surjective,
and bijective relations.
By combining the diagonal and codiagonal structures, we can
characterize the injective functions, surjective functions, etc.
Interactions between structures
To conclude this section, we consider how the diagonals
and codiagonals of Rel interact with each other and with the previous structures. In fact,
the self-dual compact closed structure is reducible to the (co)diagonals. The unit and counit
morphisms are given by
X
X
=
X
,
X
X
=
X
.
18

We have seen that the dagger is, in turn, reducible to the compact closed structure. Like the
dagger operation, bending arrows is useful enough to merit its own textual and graphical
syntax.
The internal monoids and comonoids in Rel combine to form internal Frobenius algebras
(sometimes called Frobenius monoids) [Koc04]. That is, for each object X, there is a monoid
(X, ‚àáX, ‚ñ°X) and a comonoid (X, ‚àÜX, ‚ô¶X) satisfying the Frobenius equations
(1X  ‚àÜX)(‚àáX  1X) = ‚àáX‚àÜX = (‚àÜX  1X)(1X  ‚àáX)
or, graphically,
=
=
.
The monoid and comonoids are also special, meaning that ‚àÜX‚àáX = 1X or
=
.
Finally, by deÔ¨Ånition, we have ‚àáX = ‚àÜ‚Ä†
X and ‚ñ°x = ‚ô¶‚Ä†
X. These properties can be summarized
by saying that (X, ‚àÜX, ‚ô¶X, ‚àáX, ‚ñ°X) is a special ‚Ä†-Frobenius monoid [BE15].
4. Abstract categories of relations
The category Rel of sets and relations cannot stand alone as a formalism for knowledge
representation. A knowledge representation system must be implementable on a computer,
which requires that each knowledge base admit a Ô¨Ånite description. Yet Rel, far from being
a Ô¨Ånitary object, has as objects every possible set and as morphisms every possible relation!
Moreover, there is no formal system for specifying equations or subsumptions that should
hold between relations. To enable a Ô¨Ånite description of categories that ‚Äúbehave like‚Äù the
category of sets and relations, we must axiomatize the salient structures of Rel. The previous
section provides some clues about how to achieve this axiomatization.
In fact, there are two diÔ¨Äerent notions of an ‚Äúabstract‚Äù category of relations in the category
theory literature. The best known is Freyd‚Äôs allegory, popularized by Freyd and Scedrov
[FS90] and utilized in Johnstone‚Äôs treatise on topos theory [Joh02]. There have been a few
eÔ¨Äorts to apply allegories to real-world phenomena, e.g., in circuit design [BH94; BJ94], logic
19

programming [AL12], and database modeling [ZMS13]. Allegories take intersections and
the dagger (called ‚Äúreciprocation‚Äù) as primitive, characterizing the former by axioms like
reÔ¨Çexivity, commutativity, and, most distinctively, the modular law
RS ‚à©T ‚äÜ(R ‚à©TS‚Ä†)S,
where R ‚äÜS is, by deÔ¨Ånition, equivalent to R‚à©S = R. (The reader can check that this rather
strange law does hold in Rel.) The second notion is the bicategory of relations, introduced by
Carboni and Walters [CW87; Car+08]. In bicategories of relations, the monoidal structures
are primitive, while intersections and the dagger are derived concepts. The two notions
are ostensibly quite diÔ¨Äerent, but it can be shown that the categories of unitary pretabular
allegories and of bicategories of relations are equivalent, in fact isomorphic [KN94; Law15].
Thus, the choice of axiomatization is mostly a matter of preference.
In this paper, we shall take bicategories of relations as our preferred notion of an ‚Äúabstract‚Äù
category of relations. An advantage of this choice is that the graphical language of monoidal
categories is immediately available.
DeÔ¨Ånition ([CW87]). A bicategory of relations is a locally posetal 2-category B that is also
a symmetric monoidal category (B, , I) with diagonals (X, ‚àÜX, ‚ô¶X)X‚ààB, such that
‚Ä¢ every morphism R : X ‚ÜíY is a lax comonoid homomorphism,
R ¬∑ ‚àÜY =‚áí‚àÜX(R  R),
R ¬∑ ‚ô¶Y =‚áí‚ô¶X;
‚Ä¢ the duplication morphisms ‚àÜX and deletion morphisms ‚ô¶X have right adjoints ‚àáX :=
‚àÜ‚àó
X and ‚ñ°X := ‚ô¶‚àó
X;
‚Ä¢ the pairs of morphisms (‚àÜX, ‚àáX) obey the Frobenius equations.
We denote by BiRel the category of (small) bicategories of relations and structure-preserving
functors.
Remark. Our deÔ¨Ånition diÔ¨Äers from Carboni and Walter‚Äôs deÔ¨Ånition in one respect. They ask
not for diagonals but only for internal cocommutative comonoids, subject to the requirement
that they are the unique cocommutative comonoids with right adjoints. However, it appears
that the only use of this uniqueness axiom is to derive the coherence axioms [CW87, Remark
1.3 (ii)]. We think it simpler to just assert the coherence axioms to begin with. By omitting
the uniqueness axiom, we ensure that the theory of bicategories of relations is essentially
algebraic (see below).
Every structure invoked in the deÔ¨Ånition has been introduced in Section 3, with the exception
of adjoints. In this paper we use ‚Äúadjoint‚Äù in the sense of 2-categories [Lac10]. Thus, in a
locally posetal 2-category C, a morphism f : A ‚ÜíB is left adjoint to g : B ‚ÜíA (and g is
right adjoint to f), written f ‚ä£g, if
1A =‚áífg
and
gf =‚áí1B.
If a morphism f has a right adjoint g, then it is unique, for if g‚Ä≤ is another right adjoint, then
g‚Ä≤ ‚áíg‚Ä≤fg ‚áíg and, by symmetry, g ‚áíg‚Ä≤, so that g = g‚Ä≤. Similarly, left adjoints are unique
20

Structure
Name
Notation and deÔ¨Ånition
category
composition
R ¬∑ S
monoidal category
product
R  S
braiding
œÉX,Y
diagonal
copy
‚àÜX
delete
‚ô¶X
codiagonal
merge
‚àáX := ‚àÜ‚àó
X = ‚àÜ‚Ä†
X
create
‚ñ°X := ‚ô¶‚àó
X = ‚ô¶‚Ä†
X
compact closed
unit
Œ∑X := ‚ñ°X ¬∑ ‚àÜX
counit
œµX := ‚àáX ¬∑ ‚ô¶X
dagger
dagger
R‚Ä† := (Œ∑X  1Y )(1X  R  1Y )(1X  œµY )
logical
intersection
R ‚à©S := ‚àÜX(R  S)‚àáY
true
‚ä§:= ‚ô¶I ¬∑ ‚ñ°I = 1I
local maximum
‚ä§X,Y := ‚ô¶X ¬∑ ‚ñ°Y
Table 2: Summary of morphisms in a bicategory of relations
when they exist. In Rel, a relation R : X ‚ÜíY has a right adjoint R‚àó: Y ‚ÜíX if and only
if R is a function, in which case R‚àó= R‚Ä†. Together with the discussion in Section 3, this
proves that Rel is a bicategory of relations. We shall meet other interesting bicategories of
relations in Sections 6 and 8.
Carboni and Walters derive from the axioms of a bicategory of relations all the categorical
structures discussed in Section 3. The situation is perfectly analogous to that of Rel. For
the reader‚Äôs convenience, we summarize the results in Table 2, using the textual syntax for
brevity.
The characterization of maps in Rel also generalizes to an arbitrary bicategory of relations.
A morphism R : X ‚ÜíY in a bicategory of relations B is a map if it has a right adjoint
R‚àó: Y ‚ÜíX. Equivalent conditions are that R is a comonoid homomorphism or that R is left
adjoint to R‚Ä† [CW87, Lemma 2.5]. The collection of maps in B is closed under composition
and monoidal products and hence forms a symmetric monoidal category, which we denote
by Map(B). In the motivating example, Map(Rel) = Set. The diagonal on B is natural
when restricted to Map(B), making Map(B) into a cartesian category. In fact, Map(B) is
the largest subcategory of B that is cartesian. Thus, in the terminology of [Sel99], Map(B)
is the focus of B.
5. Relational ologs
A categorical framework for knowledge representation, generalizing the category of sets and
relations, emerges almost automatically from the abstractions developed in the previous
section. An ontology in this framework is called a ‚Äúrelational olog,‚Äù after Spivak and Kent
[SK12]. We will deÔ¨Åne a relational olog to be any bicategory of relations that admits a Ô¨Ånite
21

description; more precisely, a relational olog is a Ô¨Ånitely presented bicategory of relations.
Intuitively, a Ô¨Ånitely presented bicategory of relations is the ‚Äúgeneric‚Äù or ‚Äúfree‚Äù bicategory
of relations that contains a speciÔ¨Åed Ô¨Ånite collection of basic objects, morphisms, and 2-
morphisms. It is analogous to other free constructions in algebra, such as a free vector space
or a Ô¨Ånitely presented group. Another, more relevant example is a functional olog that does
not involve limits or colimits, which is just a Ô¨Ånitely presented category.
DeÔ¨Ånition. A relational ontology log (or relational olog) is a Ô¨Ånitely presented bicategory of
relations.
In more detail, a relational olog is a bicategory of relations B presented by
‚Ä¢ a Ô¨Ånite set of basic types or object generators;
‚Ä¢ a Ô¨Ånite set of basic relations or morphism generators of form R : X ‚ÜíY , where X, Y
are object expressions;
‚Ä¢ a Ô¨Ånite set of subsumption axioms or 2-morphism generators of form R ‚áíS, where
R, S are well-formed morphism expressions with the same domain and codomain.
Note that while our deÔ¨Ånition does not explicitly include equality axioms, equality of mor-
phisms can be reduced to subsumption. In the sequel, axioms of form R = S are understood
to be shorthand for the two axioms R ‚áíS and S ‚áíR.
We hope that the meaning of the deÔ¨Ånition is intuitively clear but let us be somewhat more
precise about our terminology. By ‚Äúwell-formed morphism expressions‚Äù we mean expressions
constructed from the morphism generators and the syntax of bicategories of relations (see
Table 2) such that domains and codomains are respected in all compositions. Similarly,
‚Äúobject expressions‚Äù are expressions constructed from the object generators and the syntax
of monoidal categories ( and I). A bicategory of relations B is ‚Äúpresented by‚Äù a given
collection of generators B0 if B contains (an isomorphic copy of) B0 and if for every other
bicategory of relations B‚Ä≤ containing B0, there exists a unique functor F : B ‚ÜíB‚Ä≤ preserving
the structure of BiRel and the generators B0. As usual, this universal property guarantees
the uniqueness of B up to isomorphism. For readers concerned about the existence of B we
make the following technical remark.
Remark. The preceding deÔ¨Ånition can be made fully rigorous by formulating the axioms of a
bicategory of relations as an essentially algebraic theory. Roughly speaking, an essentially
algebraic theory is an algebraic theory that allows some operations to be partially deÔ¨Åned,
provided the domain of deÔ¨Ånition is characterized by equations between total operations [Fre72;
PS97]. A motivating example is the theory of categories, where composition of morphisms is
partially deÔ¨Åned. It is well known that deÔ¨Ånition by Ô¨Ånite presentation, also known as the
‚Äúmethod of generators and relations,‚Äù works in any essentially algebraic theory. There are
several methods for constructing a free model from the syntax of the theory. Generalized
algebraic theories, a reformulation of essentially algebraic theories using dependent type
theory, provide a particularly elegant solution [Car86; Pit95].
Alternatively, our foray into categorical logic (Section 8) yields an entirely diÔ¨Äerent and fully
explicit construction of relational ologs. This construction is based not on universal algebra
or dependent type theory but on the proof theory of a subset of Ô¨Årst-order logic.
22

5.1. Example: Friend of a friend
While the formal deÔ¨Ånition of a relational olog is somewhat abstract, the speciÔ¨Åcation of
a particular relational olog is, as a practical matter, simple and intuitive, thanks to the
graphical language of monoidal categories. To illustrate, we specify a relational olog in a toy
domain aÔ¨Äectionately called ‚Äúfriend of a friend‚Äù (or ‚ÄúFOAF‚Äù) [BM14; DV10]. This domain,
involving people, organizations, and their presences online, is often used to showcase the
Semantic Web technologies (RDF and OWL). We take the formal speciÔ¨Åcation of FOAF as
an inspiration only, making no attempt to replicate its interface or general philosophy.
The basic types of the olog are ‚ÄúPerson‚Äù, ‚ÄúOrganization‚Äù, ‚ÄúNumber‚Äù, and ‚ÄúString‚Äù. We shall
introduce the basic relations as we need them. Here are some essential relations for our
ontology:
knows
Person
Person
,
member of
Person
Organization ,
friend of
Person
Person
,
works at
Person
Organization .
The obligatory ‚Äúfriend of a friend‚Äù relation is just the composite
friend of
friend of
.
(All relations are typed but when the types are clear from context we shall suppress the type
labels.) Some of the basic relations are subsumed by others. For instance, if Alice is a friend
of Bob, then Alice knows Bob; thus, the ‚Äúfriend of‚Äù relation is subsumed by the ‚Äúknows‚Äù
relation:
friend of
=‚áí
knows
.
Likewise, the ‚Äúworks at‚Äù relation is subsumed by the ‚Äúmember of‚Äù relation (diagram omitted).
Presumably, if Alice knows Bob, then Bob also knows Alice, so we should declare that the
‚Äúknows‚Äù relation is symmetric:
knows
=
knows
.
Most people would also say that the ‚Äúfriend of‚Äù relation is symmetric.
We can attach some basic data to each person, such as their name and age:
age
Person
Number ,
family name
Person
String ,
given name
Person
String .
We declare that these relations are (total) functions; for instance,
age
=
age
age
,
age
=
.
23

In RDF and OWL, functional relations whose codomains are primitive data types are called
‚Äúproperties‚Äù and are treated specially.
For extra Ô¨Çavor, we complement the ‚Äúfriend of‚Äù relation with an ‚Äúenemy of‚Äù relation. We can
then deÔ¨Åne the notorious relation of ‚Äúfrenemy‚Äù as the intersection of friend and enemy:
frenemy of
:=
friend of
enemy of
.
Next, we model some basic family relationships. Having introduced a ‚Äúchild of‚Äù relation, the
‚Äúparent of‚Äù relation is just its inverse:
parent of
:=
child of
.
An ‚Äúancestor of‚Äù relation should possess several properties. First, it should subsume ‚Äúparent
of‚Äù:
parent of
=‚áí
ancestor of
.
It should be transitive,
ancestor of
ancestor of
=‚áí
ancestor of
,
(an ancestor of an ancestor is an ancestor) and reÔ¨Çexive,
Person
=‚áí
ancestor of
,
(by convention, we regard every person as their own ancestor). Finally, the ancestor relation
should be antisymmetric,
ancestor of
ancestor of
=‚áí
Person
,
(if two people are both ancestors and descendants of each other, then they are the same
person). We can now deduce, rather an declare as an axiom, that the relation ‚Äúgrandparent
of‚Äù is subsumed by ‚Äúancestor of‚Äù:
grandparent of
:=
parent of
parent of
=‚áí
ancestor of
ancestor of
=‚áí
ancestor of
.
24

In summary, ‚Äúancestor of‚Äù is a partial order that subsumes ‚Äúparent of.‚Äù It would be more
precise to declare that ‚Äúancestor of‚Äù is the partial order generated by ‚Äúparent of,‚Äù but that
cannot be expressed in a relational olog.
So far we have seen only relatively simple, binary relations. Let us now consider more complex
compound relations and relations of arity diÔ¨Äerent than two. The class (unary relation) of
employed people can be deÔ¨Åned as the class of people who work at some organization:
is employed
Person
:=
works at
Person
Organization
.
We declare a ternary relation ‚Äúsalary‚Äù with signature
salary
Person
Organization
Number
.
We assert that ‚Äúsalary‚Äù is a partial function (diagram omitted). Its domain of deÔ¨Ånition is
characterized by
salary
=
works at
.
Alternatively, we can take this equation as the deÔ¨Ånition of the ‚Äúworks at‚Äù relation: a person
works at an organization if and only if they draw a salary from that organization. As another
example, a ‚Äúcolleague‚Äù is a person whom you know and with whom you share a membership
at some organization:
colleague of
:=
knows
member of
member of
.
A simple calculation, using the symmetry of ‚Äúknows,‚Äù proves that ‚Äúcolleague of‚Äù is a symmetric
relation. More fancifully, a romantic ‚Äúlove triangle‚Äù is the ternary relation
loves
enemy of
loves
.
Thus, a love triangle consists of two people, mutually enemies, who both love a third person.
Assuming ‚Äúenemy of‚Äù is symmetric, this relation is symmetric in its Ô¨Årst two arguments. As
25

long as we‚Äôre indulging in Shakespearean themes, we can also deÔ¨Åne the quaternary relation
of ‚Äúintergenerational family feud‚Äù:
enemy of
parent of
parent of
enemy of
.
Such a feud consists of two parent-child pairs, where the parents are enemies and the children
are also enemies.
Although it might be entertaining to continue along these lines, we shall stop here. We hope
we have convinced the reader that relational ologs are both expressive and intuitive. With a
little practice, it becomes easy to write down complex relations and read them at a glance.
However, there are certain natural constraints that cannot be expressed in a relational olog,
as developed so far. For instance, if we took our ontology more seriously, we might prefer to
dismiss the possibility of ‚Äúfrenemies‚Äù and declare that ‚Äúfriend of‚Äù and ‚Äúenemy of‚Äù are disjoint
relations. At present we cannot express this constraint because we cannot express the empty
relation. Nor can we express unions, so we cannot declare that, for example, the ‚Äúparent of‚Äù
relation is the union of the ‚Äúmother of‚Äù and ‚Äúfather of‚Äù relations. In Section 9 we explain
how to overcome these limitations.
6. Instance data
A distinguishing feature of categorical knowledge representation, compared to the logical
paradigm, is a rich and Ô¨Çexible notion of instance data. The idea of instance data is simply
that of functorality. To be precise, instance data for a relational olog B in an arbitrary
bicategory of relations D is a structure-preserving functor D : B ‚ÜíD. We call D the data
category for the instance data D. Unsurprisingly, the ‚Äústandard‚Äù data category is Rel, the
category of sets and relations. We study this important case and several others below.
In knowledge representation systems based on description logic, instances are represented by
named constants within the logical system, usually called ‚Äúindividuals.‚Äù There are several
advantages to the categorical notion of instance data. First, there is a clean separation between
universal concepts, stored in the olog B, and instantiations of these concepts, stored in the
functor D : B ‚ÜíD. In description logic, this separation is only partly achieved by partitioning
the axioms of the knowledge base into a ‚ÄúTBox‚Äù and an ‚ÄúABox‚Äù (see Section 2). Besides its
aesthetic appeal, the separation of universal and particular knowledge has important practical
beneÔ¨Åts. In modern ‚Äúbig data‚Äù applications involving a large number of individuals, storing
instance data in a suitable database, rather than as logical sentences, becomes a practical
26

necessity. Of course, one can deÔ¨Åne ad hoc schemes for translating between the logical system
and the database system. The point is that functors provide a simple, mathematically precise
notion of ‚Äútranslation‚Äù between systems.
Another advantage, less easily achieved by ad hoc devices, is that we can deÔ¨Åne ‚Äúnon-standard‚Äù
instance data by using data categories besides Rel. This possibility arises because ologs,
unlike logical theories, are algebraic structures and hence come equipped with a general
notion of structure-preserving maps, namely functors. From this point of view, instance data
for relational ologs is closely connected to functorial semantics in categorical logic. We shall
return to categorical logic in Section 8.
Let us add, parenthetically, that it is possible to represent individuals inside a relational
olog. An individual of type X is a map c : I ‚ÜíX, since a function from the singleton set
I = {‚àó} to X picks out an element of X. In our view, individuals should be used sparingly
to represent concepts that are inherently singletons. For example, there is at any given time
only one Dalai Lama, so it would be reasonable to represent the Dalai Lama as an individual
of type ‚ÄúPerson.‚Äù It should suÔ¨Éce to include most ‚Äúordinary‚Äù people only as instance data. In
general, the olog should contain only universal concepts, even if they are singletons, while the
instance data contains all particular knowledge. (We grant that when building an ontology it
is not always easy to distinguish between universal and particular, but often the diÔ¨Äerence is
clear enough.)
In this section, we consider four diÔ¨Äerent kinds of instance data for relational ologs. The Ô¨Årst
and second are interpreted as relational databases and graph databases, respectively. With
minor modiÔ¨Åcation, these two concepts apply equally well to functional ologs and are treated
by Spivak and Kent [SK12]. The other two kinds of instance data are speciÔ¨Åc to relational
ologs. From the matrix calculus of relations, an extension of the familiar boolean algebra, we
derive instance data in the category of boolean matrices. Finally, we consider ‚Äúnon-standard‚Äù
instance data in the category of linear relations. This data category can be used to model
linear dynamical systems.
6.1. Relational databases
The default category for instance data, suitable for most applications, is the category of sets
and relations. Thus, without further qualiÔ¨Åcation, instance data for a relational olog B is a
structure-preserving functor D : B ‚ÜíRel.
A structure-preserving functor D : B ‚ÜíRel is deÔ¨Åned by the following data. Each basic
type X of B is mapped to a set D(X) and each basic relation R : X ‚ÜíY of B is mapped to
a subset D(R) of D(X) √ó D(Y ). The set D(X) contains the instances of type X and the
subset D(R) tabulates the instances of type X that are in relation R with instances of type
Y . By functorality, this data determines the action of D on every object and every morphism
of B, since B is generated by the basic types and relations. Moreover, in order for D to be
well-deÔ¨Åned, it must preserve all the subsumption axioms of B. Thus, for every subsumption
axiom R ‚áíS, we require that D(R) ‚äÜD(S). If the mapping D satisÔ¨Åes these properties, it
deÔ¨Ånes valid instance data for the olog.
27

Instance data is straightforwardly interpreted as a relational (SQL) database [Cod70]. In
the idealized database interpretation, there is a single-column table D(X) for each basic
type X, which deÔ¨Ånes the primary key of each instance of type X, and a multi-column table
D(R) for each basic relation R, whose columns are foreign keys associated with the domain
and codomain types of R. The tables D(R) are called ‚Äúassociation tables‚Äù or ‚Äújunction
tables‚Äù in SQL jargon. Association tables are the standard way of representing many-to-many
relationships in a relational database. The primary key of the association table is the product
of the foreign keys of the columns.
An example should make this clear. Instance data for a fragment of the ‚Äúfriend of a friend‚Äù
ontology (Section 5.1) is shown below.
Person
ID
P1
P2
P3
P4
Organization
ID
O1
O2
salary
Person
Organization
Number
P1
O1
30,000
P3
O2
40,000
friend of
Person 1
Person 2
P1
P2
P2
P1
knows
Person 1
Person 2
P1
P2
P2
P1
P3
P4
P4
P3
As required by functorality, the ‚Äúfriend of‚Äù and ‚Äúknows‚Äù tables are symmetric and the ‚Äúfriend
of‚Äù table is a subset of the ‚Äúknows‚Äù table. In practice we expect to deviate slightly from
the idealized database interpretation to obtain a more compact database schema. Most
importantly, instead of representing maps as individual tables, e.g.,
Person
ID
P1
P2
P3
P4
age
Person
Number
P1
21
P2
37
P3
22
P4
54
family name
Person
String
P1
Doe
P2
Smith
P3
Williams
P4
Jones
given name
Person
String
P1
Alice
P2
Bob
P3
Carol
P4
David
,
it would be more conventional to combine the maps with common domain into a single table,
e.g.,
Person
ID
age
family name
given name
P1
21
Doe
Alice
P2
37
Smith
Bob
P3
22
Williams
Carol
P4
54
Jones
David
.
28

We could represent partial maps similarly, using NULL to indicate undeÔ¨Åned values.
By formalizing the association of instance data with an olog, it becomes possible to migrate
data in a precise, principled way. Suppose that, in light of new information or a changing
world, we decide to update the concepts in our ontology B, yielding a new ontology B‚Ä≤. Ideally
we can translate the concepts of B into concepts of B‚Ä≤ by means of a functor F : B ‚ÜíB‚Ä≤.
The functor F can then be used to migrate the original data D : B ‚ÜíRel to updated data
D‚Ä≤ : B‚Ä≤ ‚ÜíRel. This paradigm is called functorial data migration and is investigated by
Spivak and collaborators in a series of papers [Spi12; SK12; SW15; Sch+16]. Functorial data
migration has been developed for functional ologs. At least one data migration functor, the
pullback functor, has an obvious analogue for relational ologs. It is an open question whether
the other data migration functors, the left and right pushforward functors, admit analogues.
This question, while important, is not pursued further here.
6.2. Graph databases
Graph databases [AG08; RN10] provide a natural storage model for the instance data of an
ontology. In fact, the development of graph databases can be traced back to the semantic
networks and frame systems of the early era of knowledge representation [AG08, Fig. 1].
Even today it is sometimes suggested that graph databases are knowledge representation
systems. That is not so: graph databases oÔ¨Äer a generic data storage model that need not
impose any logical constraints on the data. Still, the confusion exists precisely because graph
databases are so well-aligned with the practice of knowledge representation. In this section,
we explain how instance data D : B ‚ÜíRel can be interpreted as a graph database.
Unlike relational databases, which are practically synonymous with the Structured Query
Language (SQL), graph databases are an emerging technology with no universally accepted
data model or query language. Our construction maps easily onto Apache TinkerPop3
[Apa15], an open standard for graph databases with moderate vendor adoption.
The
Resource Description Framework (RDF), a core component of the Semantic Web, can also be
regarded as a graph database [AG05], especially when coupled with a graph query language
like SPARQL [PS08].
The interpretation of instance data as a graph database involves a construction called the
‚Äúcategory of elements.‚Äù
DeÔ¨Ånition. Let B be a bicategory of relations. The category of elements of a structure-
preserving functor F : B ‚ÜíRel, denoted
R
B F or
R F, has as objects, the pairs
(X, x)
where
X ‚ààB,
x ‚ààF(X),
and as morphisms (X, x) ‚Üí(Y, y), the morphisms in B
R : X ‚ÜíY
such that
x F(R) y.
Composition and identity morphisms are inherited from B.
29

Remark. Technically, this deÔ¨Ånition is not included in the usual notion of a category of
elements [Rie16, ¬ß2.4], which applies to functors F : C ‚ÜíSet, nor in the more general
Grothendieck construction [Jac99, ¬ß1.10], which applies to functors F : C ‚ÜíCat. However, it
is evidently the same idea, so we will use the same terminology.
A category of elements
R
B F is itself a bicategory of relations, with its structure inherited
from both B and Rel. The monoidal product is deÔ¨Åned by
(X, x)  (Y, y) := (X  Y, (x, y)),
IR
F := (IB, ‚àó).
The diagonal maps are ‚àÜ(X,x) := ‚àÜX and ‚ô¶(X,x) := ‚ô¶X.
These morphisms behave as
expected because F is structure-preserving. For example, there is a copying morphism
‚àÜX : (X, x) ‚Üí(X  X, (x‚Ä≤, x‚Ä≤‚Ä≤)) in
R F if and only if x = x‚Ä≤ and x = x‚Ä≤‚Ä≤. Finally, the
2-morphisms of
R F are just the 2-morphisms of B. (It is tempting to declare that R ‚áíS in
R F whenever F(R) ‚áíF(S) in Rel, but under that deÔ¨Ånition
R F is not necessarily locally
posetal.)
Given instance data D : B ‚ÜíRel, we think of
R D as a graph database as follows. The
vertices of the graph are the objects (X, x) of
R D. The vertex labels (or vertex types) are
the objects X of B, given by the canonical projection functor
R
B D ‚ÜíB. The directed edges
of the graph are morphisms (X, x)
R‚àí‚Üí(Y, y) of
R D. The edge labels (or edge types) are the
morphisms R of B, again given by the projection functor
R
B D ‚ÜíB. As an example, the
instance data for the FOAF ontology yields the graph database:
P1
Person
P2
Person
P3
Person
P4
Person
knows
knows
friend of
friend of
knows
knows
As with relational databases, the idealized graph database interpretation may require modiÔ¨Åca-
tion to accommodate real-world database systems. The size of the graph can be considerably
reduced by representing maps with ‚Äúprimitive type‚Äù codomains (e.g., ‚ÄúNumber‚Äù or ‚ÄúString‚Äù)
as ‚Äúvertex properties,‚Äù a feature supported by most graph databases. Symmetric relations,
such as ‚Äúknows‚Äù and ‚Äúfriend of,‚Äù can be represented by one undirected edge instead of two
directed edges. Another issue, not arising with relational databases, is the representation of
relations whose domain or codomain is a product of basic types, such as the ‚Äúsalary‚Äù relation.
If the database included vertices only for basic types, we would need directed hyperedges
[Gal+93], a feature not supported by most graph databases. The solution is to include
vertices for product types and edges for the projection morphisms. In fact, this encoding is
accomplished automatically by the monoidal product in the category of elements.
30

6.3. Boolean matrices
We now consider instance data derived from the matrix calculus of relations. Unlike relational
and graph databases, the matrix calculus has no analogue for functional ologs. It is a special
case of categorical matrix calculus, which can be performed in any biproduct category [CP10,
¬ß3.5.5], [Har09].
Let B = {0, 1} be the commutative ‚Äúrig‚Äù (commutative ring without negatives) of booleans,
whose operations are deÔ¨Åned by
0 + 0 = 0,
0 + 1 = 1 + 0 = 1,
1 + 1 = 1
0 ¬∑ 0 = 0,
0 ¬∑ 1 = 1 ¬∑ 0 = 0,
1 ¬∑ 1 = 1.
That is, addition in B is logical disjunction and multiplication in B is logical conjunction.
DeÔ¨Ånition. The category Mat(B) of boolean matrices has as objects the natural numbers
and as morphisms m ‚Üín the m √ó n matrices over B. Composition is deÔ¨Åned by matrix
multiplication and the identity morphisms are the identity matrices.
We interpret a matrix R ‚ààBm√ón as a relation with domain [m] = {1, . . . , m} and codomain
[n] = {1, . . . , n}, where individual i ‚àà[m] is in relation R with individual j ‚àà[n] if and only
if Ri,j = 1. As expected, composition in Mat(B) is given by existential quantiÔ¨Åcation:
(R ¬∑ S)i,k = 1
iÔ¨Ä
‚àÉj : Ri,j = 1 ‚àßSj,k = 1.
The category of boolean matrices is a bicategory of relations. There is a 2-morphism R ‚áíS if
and only if R ‚â§S (elementwise). The monoidal product is the tensor product of matrices:
R  S :=
Ô£´
Ô£¨
Ô£¨
Ô£≠
R1,1S
¬∑ ¬∑ ¬∑
R1,nS
...
...
...
Rm,1S
¬∑ ¬∑ ¬∑
Rm,nS
Ô£∂
Ô£∑
Ô£∑
Ô£∏.
The diagonals are deÔ¨Åned by
‚àÜn :=

e1e‚ä§
1
¬∑ ¬∑ ¬∑
ene‚ä§
n

‚ààBn√ón2
and
‚ô¶n :=
Ô£´
Ô£¨
Ô£¨
Ô£≠
1
...
1
Ô£∂
Ô£∑
Ô£∑
Ô£∏‚ààBn√ó1,
where ei is the ith standard basis vector. With these deÔ¨Ånitions, the dagger is simply the
matrix transpose, R‚Ä† = R‚ä§. Given matrices R, S ‚ààBm,n, a quick calculation shows that local
intersections are given by the elementwise (Hadamard) product:
R ‚à©S := ‚àÜm(R  S)‚àán =
Ô£´
Ô£¨
Ô£¨
Ô£≠
R1,1S1,1
¬∑ ¬∑ ¬∑
R1,nS1,n
...
...
...
Rm,1Sm,1
¬∑ ¬∑ ¬∑
Rm,nSm,n
Ô£∂
Ô£∑
Ô£∑
Ô£∏=: R  S.
Thus we recover the usual intersection of relations.
31

Anticipating Section 9, we equip Mat(B) with a second monoidal product, the direct sum of
matrices:
R  S :=
 
R
0
0
S
!
.
DeÔ¨Åne a codiagonal with respect to the direct sum by
‚ñºn :=
 
In
In
!
‚ààB2n√ón
and
‚ñ†n := () = 0 √ó n matrix,
where In is the n √ó n identity matrix. We recover unions of relations from the formula
R ‚à™S := ‚ñ≤m(R  S)‚ñºn = R + S.
This construction will be revisited and generalized in Section 9.
Matrix data‚Äîinstance data in the category of boolean matrices‚Äîfor a relational olog B is
a structure-preserving functor D : B ‚ÜíMat(B). Each basic type X of B is mapped to a
natural number D(X) and each basic relation R : X ‚ÜíY is mapped to a D(X) √ó D(Y )
matrix D(R) over B, such that all the subsumption axioms of B are satisÔ¨Åed. For example,
the instance data for the FOAF ontology becomes
D(friend of) =
Ô£´
Ô£¨
Ô£¨
Ô£¨
Ô£≠
0
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0
Ô£∂
Ô£∑
Ô£∑
Ô£∑
Ô£∏,
D(knows) =
Ô£´
Ô£¨
Ô£¨
Ô£¨
Ô£≠
0
1
0
0
1
0
0
0
0
0
0
1
0
0
1
0
Ô£∂
Ô£∑
Ô£∑
Ô£∑
Ô£∏.
The two matrices are symmetric because the corresponding relations in B are. Note that
relations with (theoretically) inÔ¨Ånite domain or codomain, such as ‚Äúfamily name,‚Äù ‚Äúgiven
name,‚Äù and ‚Äúsalary,‚Äù cannot be represented as matrices.
The matrix representation of relations plays an important role in data analysis applications.
A symmetric relation R with the same domain and codomain, such as the ‚Äúfriend of‚Äù relation,
is often regarded as an undirected graph, with D(R) its adjacency matrix. This simple
observation is the starting point of the spectral analysis of network data, a rich and active
area of statistical research [Mah16]. Matrix data oÔ¨Äers yet another example of how instance
data can be used to connect an ontology to another computational system in a mathematically
precise way.
6.4. Linear relations
Relational and graph databases are both realized by functors D : B ‚ÜíRel, and matrix data
can be regarded as a repackaged functor D : B ‚ÜíFinRel, where FinRel is the category
of Ô¨Ånite sets and relations. On the basis of these examples one might suppose that, in
general, instance data amounts to a functor into Rel. That would be mistaken. In this
section, we describe a counterexample of practical signiÔ¨Åcance, the category of linear relations.
This category has been studied by Baez and Erbele [BE15], and independently by Bonchi,
32

Soboci≈Ñski, and Zanasi [BSZ14], as a model of signal Ô¨Çow diagrams in control theory. Note
that the material in this section is peripheral to the main development of the paper and can
be skipped without loss of continuity.
DeÔ¨Ånition. The category of linear relations, denoted VectRelk, is the category whose
objects are Ô¨Ånite-dimensional vector spaces (over a Ô¨Åxed Ô¨Åeld k) and whose morphisms
L : U ‚ÜíV are linear relations, which are vector subspaces
L ‚äÜU  V.
Composition and identity morphisms are deÔ¨Åned as in Rel; thus, given linear relations
L : U ‚ÜíV and M : V ‚ÜíW, the composite LM : U ‚ÜíW is
LM = {(u, w) | ‚àÉv ‚ààV : (u, v) ‚ààL ‚àß(v, w) ‚ààM} .
The category of linear relations is a bicategory of relations. The 2-morphisms are subspace
inclusions. The monoidal product is the direct sum (which we always write as , not ) and
the monoidal unit is the zero vector space. The diagonal is deÔ¨Åned by
‚àÜV :
( V ‚ÜíV  V
v 7‚Üí(v, v)
and
‚ô¶V :
( V ‚Üí{0}
v 7‚Üí0.
Given these deÔ¨Ånitions, the maps in VectRelk are just linear maps, in the usual sense. Be
warned that the dagger is not the matrix transpose, in contrast to Mat(B); indeed, the
transpose of a linear map is always another linear map, but f ‚Ä† is not a linear map unless f is
invertible. As in Rel, the dagger simply eÔ¨Äects a formal exchange of inputs and outputs.
However, the linear transpose leads to interesting structure not present in Rel. The transpose
of the duplication map ‚àÜV is the addition map
‚ñºV := ‚àÜ‚ä§
V :
( V  V ‚ÜíV
(v1, v2) 7‚Üív1 + v2
and the transpose of the deletion map ‚ô¶V is the zero map
‚ñ†V := ‚ô¶‚ä§
V :
( {0} ‚ÜíV
0 7‚Üí0.
The linear relations ‚ñ≤V := ‚ñº‚Ä†
V : V ‚ÜíV  V and ‚ô¶V := ‚ñ†‚Ä†
V : V ‚Üí{0} are called coaddition
and cozero, respectively.
The family of maps (‚ñºV , ‚ñ†V ) form a codiagonal structure on VectRelk. Moreover, every
linear relation L : U ‚ÜíV is a lax monoid homomorphism with respect to this structure,
meaning that
(L  L)‚ñºV =‚áí‚ñºUL
and
‚ñ†V =‚áí‚ñ†UL.
The duality exhibited here motivates the following deÔ¨Ånition.
33

DeÔ¨Ånition ([CW87, ¬ß5]). An abelian bicategory of relations is locally posetal 2-category
B that is also a symmetric monoidal category (B, , I) with diagonals (X, ‚àÜX, ‚ô¶X) and
codiagonals (X, ‚ñºX, ‚ñ≤X) such that
‚Ä¢ every morphism R : X ‚ÜíY is a lax comonoid homomorphism and a lax monoid
homomorphism;
‚Ä¢ the morphisms ‚àÜX, ‚ô¶X, ‚ñºX, ‚ñ†X have right adjoints, denoted ‚àáX, ‚ñ°X, ‚ñ≤X, ‚ô¶X;
‚Ä¢ both pairs (‚àÜX, ‚àáX) and (‚ñ≤X, ‚ñºX) obey the Frobenius equations.
Remark. An equivalent, more succinct deÔ¨Ånition is that an abelian bicategory of relations is
a locally posetal 2-category B such that both B and Bco are bicategories of relations with
respect to the same monoidal product. Here Bco is the 2-category B with all 2-morphisms
reversed. See Section 9 for further discussion.
The category of linear relations, VectRelk is an abelian bicategory of relations. The usual
category of relations, Rel, is not an abelian bicategory of relations.
The category of linear relations would obviously be an inappropriate data category for
the FOAF ontology. Linear relations are useful for representing systems of linear ordinary
diÔ¨Äerential equations (ODEs), as argued by Baez and Erbele [BE15]. The graphical language of
monoidal categories then formalizes the signal Ô¨Çow diagrams that appear in control theory and
other engineering Ô¨Åelds. In this setting, one takes the Ô¨Åeld k = R(s), the real numbers R with
a formally adjoined indeterminate s. Upon taking Laplace transforms, diÔ¨Äerentiation becomes
the linear operation of scalar multiplication by s and integration becomes multiplication by
1/s. A linear relation L : km ‚Üíkn is a system of linear, constant-coeÔ¨Écient ODEs with m
input signals and n output signals.
The damped, driven harmonic oscillator provides a simple, one-dimensional example. The
equation of motion is
md2x
dt2 + Œ≤ dx
dt + Œ∫x(t) = F(t),
where x is a position or angle and F is a driving force. Provided the oscillations are not too
large, this equation accurately describes a mass on a spring or a pendulum under gravity,
subject to an additional driving force. The system can be represented by a linear relation
k ‚Üík with input F and output x:
m
R
Œ≤
R
Œ∫
The dark nodes are coaddition and the light nodes are coduplication. It is perhaps easier to
read the diagram from right to left, noting that the formal inverse of the integration map
34

R is the diÔ¨Äerentiation map
d
dx. The same diagram is drawn in conventional engineering
notation in [Fri12, Fig. 2.1]. A string diagram for a more complicated system, the ‚Äúinverted
pendulum,‚Äù is presented in [BE15, ¬ß5].
Like the previous data categories, the category of linear relations deserves a more compre-
hensive treatment than space here permits. We include it mainly as a concrete example
of the ‚Äúnon-standard‚Äù instance data enabled by functorial semantics. The possibility of
instance data with extra algebraic or topological structure is a distinctive‚Äîand sometimes
useful‚Äîfeature of categorical knowledge representation that is not easily replicated in a
purely logical system.
7. Types and the open-world assumption
The use of types is another distinctive feature of categorical knowledge representation. Unlike
instance data, types can be added to existing logical systems without too much diÔ¨Éculty; we
shall do so in Section 8. Nonetheless, we regard types as distinctive because category theory
is typed ‚Äúby default,‚Äù while logic is not, and because, as a practical matter, the knowledge
representation systems in common use are untyped. In this section, we discuss the signiÔ¨Åcance
of types for knowledge representation.
The reader may be puzzled by the claim that knowledge representation frameworks based
on description logic are untyped. Isn‚Äôt the assignment of individuals to concepts a form of
typing? Indeed, isn‚Äôt a primary purpose of description logic to taxonomize the types of things
existing in a given domain via a hierarchy of interrelated concepts? If so, what could be the
purpose of adding a second, explicit form of typing to the system? These questions have
merit and we shall try to answer them in this section.
First, we explain why description logic is untyped. Consider the relation ‚Äúfriend of‚Äù from
the FOAF ontology (Section 5.1). We want to express that only people can be friends. In
description logic, we would use a value restriction (see Sections 2 and 3) to ensure that any
two individuals in the ‚Äúfriend of‚Äù relation belong to the concept ‚ÄúPerson.‚Äù Then, given any
two individuals belonging to the disjoint concept ‚ÄúOrganization,‚Äù the answer to the question
‚ÄúAre the two entities friends?‚Äù would be ‚ÄúNo.‚Äù On one view that is a perfectly reasonable
answer. But on another it is confused. We might argue that the answer to the question is
neither ‚Äúyes‚Äù nor ‚Äúno‚Äù because the question does not make sense. Organizations are simply
not the kind of things that can be friends with each other. Merely by asking whether two
organizations are friends, we commit a category mistake‚Äîusing ‚Äúcategory‚Äù in the sense of
Gilbert Ryle, not Eilenberg and Mac Lane. A programmer would call it a type error. These
two possible responses illustrate the philosophical diÔ¨Äerence between classes and types.
More prosaically, in description logic any concepts are comparable, while in relational ologs
only relations with the same domain and codomain are comparable. Thus, in description
logic, there is a universal concept, to which all individuals belong, and it is possible to take
the intersection of any two concepts. By contrast, a relational olog has only local maxima
and local intersections within each collection of typed relations X ‚ÜíY .
35

These distinctions have practical implications for knowledge representation. To bring this
out, we consider two diÔ¨Äerent methods of constructing a taxonomy of entities in a relational
olog. This task, although probably overrepresented in KR research, is important in many
applications. The Ô¨Årst method, eÔ¨Äectively untyped, is based on subsumption of concepts with
a single domain type. The second method creates a hierarchy of diÔ¨Äerent types connected by
inclusion maps.
We shall see that the diÔ¨Äerence between the two methods is related to the open and closed
world assumptions in database theory and knowledge representation [Rei78]. Under the open
world assumption, any statements that are not deducible from a knowledge base are not
assumed to be either true or false. Under the closed world assumption, certain statements that
are not deducible are assumed to be false. The open world assumption is the standard mode
of reasoning in logical systems, including Ô¨Årst-order logic and description logic. The closed
world assumption is commonly used in databases and ruled-based knowledge representation.
For example, in the database for the FOAF ontology (Section 6.1), the absence of a row in
the ‚Äúfriend of‚Äù table for Alice and Carol is interpreted as the absence of friendship between
Alice and Carol‚Äînot the absence of knowledge of whether Alice and Carol are friends. More
generally, closed world reasoning makes assumptions about what is true based on what is not
explicitly stated.
To create a taxonomy in the style of description logic, we work with concepts C : X ‚ÜíI
over a Ô¨Åxed domain type X. The subsumption axiom C ‚áíD asserts that every instance of
concept C : X ‚ÜíI is also an instance of concept D : X ‚ÜíI. A collection of such axioms
implicitly deÔ¨Ånes a hierarchy of concepts and sub-concepts. Inferences about concepts are
made under the open world assumption. In particular, no two concepts C, D are provably
disjoint unless there is a disjointness axiom C ‚à©D ‚áí‚ä•(or disjointness can be inferred
from other axioms). Relational ologs support disjointness axioms through the extensions of
Section 9.
In a relational olog, it is also possible to represent a taxonomy as a hierarchy of types. For
each kind in the taxonomy we deÔ¨Åne a type X. To declare that type X is a subtype of type
Y , we add an inclusion map Œπ : X ‚ÜíY . An inclusion of X into Y is simply a morphism
Œπ : X ‚ÜíY that is an injective map. Injectivity is asserted by the axiom
Œπ
Œπ
X
X
Y
=
Œπ
X
Y
.
Given instance data F : B ‚ÜíRel, the function F(Œπ) associates each element of F(X) with a
unique element of F(Y ), thereby identifying F(X) with a subset of F(Y ). In this way we
interpret X as a subtype of Y . Inferences about types in the hierarchy are made under what
amounts to a closed world assumption: unless explicitly stated, distinct types are unrelated.
Two types unconnected by any morphism are not merely ‚Äúdisjoint,‚Äù they occupy diÔ¨Äerent
universes. It is not permitted to contemplate their intersection.
36

These design patterns are not mutually exclusive, and we expect that they can be proÔ¨Åtably
combined. On one hand, the open world assumption enables inference about concepts that
are not recorded by, or even anticipated by, the creator of the ontology. It embodies the
ethos of the Semantic Web, which, like the World Wide Web, allows ‚Äúanyone to say anything
about anything.‚Äù On the other hand, it can be inconvenient in scientiÔ¨Åc domains with a large
and tightly controlled vocabulary, such as biology and biomedicine. The Gene Ontology, for
example, contains tens of thousands of concepts related to genes and their biological functions
[Ash+00]. Many of them are disjoint, and all these constraints must be recorded. Graphical
ontology editors like Prot√©g√© simplify these tasks [Mus15], but omissions are still easy to
make. We suggest that a judicious use of typing could eliminate the most embarrassing errors
of this kind.
Some authors have tried to augment description logics like OWL with closed world reasoning
[KAH11; SKH11]. This work is partly motivated by the need for closed world reasoning when
an ontology is used ‚Äúlike a database‚Äù to make inferences about particular individuals. In
this context, it is instance data, not typing, that oÔ¨Äers a simple solution. Given a relational
olog B and instance data D : B ‚ÜíRel, inference in B is open world (modulo constraints
imposed by the type system). By contrast, inference in the bicategory of relations D(B),
a subcategory of Rel, is closed world. For any two relations R, S : X ‚ÜíY , there is a
subsumption D(R) ‚áíD(S) in the database if and only if the table D(R) is a subset of
the table D(S). Assuming the database has complete information with respect to a given
population, if a subsumption D(R) ‚áíD(S) holds at the instance level, then we can regard
the subsumption R ‚áíS as valid for that population, even if R ‚áíS cannot be deduced at
the knowledge level (in B). This is a form of closed world reasoning. Again, we see the utility
of a clean separation between universal and particular knowledge.
Another important use of types is to represent ‚Äúconcrete data types‚Äù like integers, real
numbers, and strings within an ontology. All practical description logic systems, including
OWL, support data types, but only though ad hoc extensions of the logical language [Baa+07,
¬ß6.2]. We grant that software implementations may need to handle primitive data types
specially, but think it inelegant to distinguish in the mathematical formalism between
‚Äúabstract‚Äù types like ‚ÄúPerson‚Äù and ‚ÄúOrganization‚Äù and ‚Äúconcrete‚Äù types like numbers and
strings.
As others have observed, category theory builds a bridge between traditional mathematical
logic and programming language theory. In this setting, it connects description logic with
type theory. Relational ologs are based on simple type theory. Of the two basic algebraic
data types, we already have product types, and we shall introduce sum types in Section 9. We
could conceivably use a more sophisticated type system. For example, instead representing
subtypes by inclusions, we could add Ô¨Årst-class subtypes and polymorphism. Polymorphic
and other type theories have been extensively investigated in the context of categorical logic
[Cro93; Jac99].
In the programming language community, it is generally accepted that some amount of typing
increases the robustness and maintainability of software systems (although opinions diÔ¨Äer
greatly as to how much typing is desirable). Apart from low-level assembly languages, there
are virtually no programming languages in common use that are completely untyped. In
37

the same spirit, we argue that at least some typing is desirable in knowledge representation
systems. The extent and sophistication of the typing will depend on the application and on
personal preferences.
8. Categorical logic
There is a fundamental connection between relational ologs and logical formalisms for
knowledge representation. We foreshadowed this connection in Section 3 by deÔ¨Åning the
structures that make Rel into a bicategory of relations using logical, rather than set-theoretic,
notation. In fact, it is possible to reason about any bicategory of relations using Ô¨Årst-order
logic, in eÔ¨Äect pretending that it is Rel. This conclusion is perhaps surprising, since some
bicategories of relations, such as the category VectRel of linear relations (Section 6.4), look
‚Äúfrom the outside‚Äù quite diÔ¨Äerent than Rel.
The purpose of this section, and the attendant Appendix A, is to make precise the connection
between relational ologs and Ô¨Årst-order logic. Our results belong to categorical logic, which
represents both syntax and semantics as categories and interpretations of logical theories as
functors. The Ô¨Åeld was initiated by Lawvere‚Äôs seminal thesis on the functorial semantics of
algebraic theories [Law63]. An important result of categorical logic, perhaps the best known
application of category theory to computer science, is that the simply-typed lambda calculus
is the internal language of cartesian closed categories [LS88; Cro93; Jac99]. In a similar spirit,
we prove that a certain fragment of Ô¨Årst-order logic, called ‚Äúregular logic,‚Äù is the internal
language of bicategories of relations.
We now explain semiformally the correspondence between regular logic and bicategories of
relations. For details and proofs, we refer to Appendix A.
Regular logic is the fragment of Ô¨Årst-order logic with connectives ‚àÉ, ‚àß, ‚ä§, =. Unlike traditional
Ô¨Årst-order logic, regular logic is typed (cf. Section 7). Every variable x, free or bound, is
assigned a type A, expressed by writing x : A. To indicate the types of free variables, every
formula of regular logic is associated with a list of type assignments, called a context. Here
are some examples of formulas in context:
x : A, y : B | R(x, y) ‚àßS(x, y)
x : A, z : C | ‚àÉy : B.(R(x, y) ‚àßS(y, z))
x : A, x‚Ä≤ : A, x‚Ä≤‚Ä≤ : A | (x = x‚Ä≤) ‚àß(x = x‚Ä≤‚Ä≤)
x : A | ‚ä§
In general, a formula in context has form Œì | œï, where œï is a formula and Œì is a context
containing all the free variables of œï.
A theory in regular logic, or regular theory, is deÔ¨Åned by the following data. There is a set of
basic types A, B, . . . and a set of relation symbols R, S, . . . . Each relation symbol R has a
Ô¨Åxed signature (A1, . . . , An) that determines its arity and argument types. A regular theory
also has a set of axioms of form Œì | œï ‚ä¢œà, which we interpret as: ‚Äúby assumption, œï implies
38

œà in the context Œì.‚Äù Given a regular theory T, we say that Œì | œï entails Œì | œà under the theory
T, or that Œì | œï ‚ä¢œà is a theorem of T, if Œì | œà can be deduced from Œì | œï using the axioms of
T and the inference rules of the proof system for regular logic.
As an example, we deÔ¨Åne a regular theory capturing a fragment of the ‚Äúfriend of a friend‚Äù
ontology (Section 5.1). The types of the theory are ‚ÄúPerson,‚Äù ‚ÄúOrganization,‚Äù ‚ÄúNumber,‚Äù
and ‚ÄúString.‚Äù Its relation symbols include
knows : (Person, Person),
friend of : (Person, Person),
works at : (Person, Organization),
salary : (Person, Organization, Number).
The symmetry of the ‚Äúknows‚Äù relation is expressed by the axiom
x : Person, y : Person | knows(x, y) ‚ä¢knows(y, x).
The ‚Äúworks at‚Äù relation is determined by
x : Person, y : Organization | ‚àÉz : Number.(salary(x, y, z)) ‚ä£‚ä¢works at(x, y),
where, as usual, ‚ä£‚ä¢is shorthand for ‚ä¢and ‚ä£(two axioms).
We establish a correspondence between regular theories and bicategories of relations. First,
to every regular theory T, we associate a bicategory of relations Cl(T), called the classifying
category of T. The classifying category is constructed directly from the syntax of regular logic.
Its objects are Ô¨Ånite lists of types A = (A1, . . . , An), which can be regarded as Œ±-equivalence
classes [Œì] of contexts Œì = x : A. Its morphisms are equivalence classes of formulas in context
[Œì; ‚àÜ|œï] : [Œì] ‚Üí[‚àÜ], where equality of formulas is up to Œ±-equivalence (renaming of variables)
and deducible logical equivalence under the axioms of T. For instance, in the ‚Äúfriend of a
friend‚Äù theory, we have
[x : Person; y : Org | ‚àÉz : Number.(salary(x, y, z))] = [a : Person; b : Org | works at(a, b)].
The semicolon in the context partitions the free variables into domain and codomain; it serves
no logical purpose. To make Cl(T) into a bicategory of relations, we deÔ¨Åne composition,
products, and diagonals analogously to Rel (Section 3).
Conversely, to every small bicategory of relations B, we associate a regular theory Lang(B),
called the internal language of B. Its types are the objects of B and its relation symbols are
the morphisms of B. Note that Lang(B) necessarily has inÔ¨Ånitely many types and relation
symbols! The axioms of Lang(B) are chosen to guarantee that formulas corresponding to equal
morphisms are provably equivalent. To make sense of this statement, we must explain how
an arbitrary formula in context Œì | œï of Lang(B) can be interpreted as a morphism JŒì | œïK of
B. The mapping J¬∑K is essentially inverse to the constructions making the classifying category
into a bicategory of relations. We prove a soundness theorem for general interpretations of a
regular theory T in a bicategory of relations B, yielding a categorical semantics for regular
logic.
The main result of this section, proved in Appendix A, is that Cl is inverse to Lang in an
appropriate sense.
39

Theorem. With respect to typed regular logic, for every small bicategory of relations B, there
is an equivalence of categories
Cl(Lang(B)) ‚âÉB
in
BiRel.
Consequently, we can regard regular theories and small bicategories of relations as ‚Äúthe same.‚Äù
Besides enriching our understanding of relational ologs, this result is potentially practically
useful, as it enables the transfer of tools and techniques between category theory and logic.
What should it mean to give ‚Äúinstance data‚Äù for a description logic knowledge base, assuming
it can be expressed as a regular theory T? We simply ask what data is required to give a
structure-preserving functor D : Cl(T) ‚ÜíRel. What should be meant by a ‚Äútranslation‚Äù
T ‚ÜíT‚Ä≤ between knowledge bases T and T‚Ä≤? Again, we need only ask what data is needed
to give a functor F : Cl(T) ‚ÜíCl(T‚Ä≤). We will not carry out these exercises here but it is
instructive to do so.
In the other direction, we can reason about a relational olog B by performing logical inference
in Lang(B). This observation is signiÔ¨Åcant because the computational aspects of category
theory are highly underdeveloped in comparison with logic. Much research on description
logic is directed towards its computability and complexity theory, and there is a long tradition
of computational Ô¨Årst-order logic. Many mature inference engines and theorem provers exist.
By contrast, the theory and practice of computational category theory, especially higher
category theory, is only now emerging [Mim14; KZ15; BKV16].
Bibliographic remarks
Regular logic has been thoroughly studied by categorical logicians
as the simplest fragment of Ô¨Årst-order logic with a quantiÔ¨Åer [Awo09; But98; Oos95]. Our
categorical semantics of regular logic is quite diÔ¨Äerent from the usual one. Conventionally,
a formula Œì | œï is interpreted as a subobject JŒì | œïK of the object JŒìK: an equivalence class
of monomorphisms into JŒìK. A category suitable for such interpretations, called a regular
category, has all Ô¨Ånite limits and ‚Äúwell-behaved‚Äù subobjects. The classifying category of
a regular theory is a regular category whose objects are (equivalence classes of) formulas
in context and whose morphisms are (equivalence classes of) formulas in context that are
provably functional. In our framework, the classifying bicategory of relations has as objects
(equivalence classes of) contexts and as morphisms (equivalence classes of) formulas in context.
The latter perspective seems more natural to us.
The germ of the above theorem is present already in the original paper of Carboni and
Walters [CW87, Remark 2.9 (iii)], but to our knowledge has never been carefully developed.
There are also strong connections between bicategories of relations and regular categories.
Given a regular category C, there is a bicategory of relations Rel(C) with the same objects
as C and with morphisms A ‚ÜíB equal to the subobjects of A √ó B‚Äîa construction that
predates and motivates Carboni and Walters‚Äô paper. Yet not every bicategory of relations
arises in this way. Conversely, if a bicategory of relations B is functionally complete, then
Map(B) is a regular category [CW87, Theorem 3.5]. Yet in general Map(B) need not be a
regular category. Thus, to a limited extent, it is possible to pass between bicategories of
relations and regular categories.
40

9. More expressive relational ologs
Relational ologs, as developed so far, can express local intersections and maxima. As proved in
Section 8, their internal language is the regular (‚àÉ, ‚àß, ‚ä§, =) fragment of Ô¨Årst-order logic. It is
natural to ask for more expressive relational ologs allowing local unions and minima. In logical
terms, they should correspond to the coherent (‚àÉ, ‚àß, ‚à®, ‚ä§, ‚ä•, =) fragment of Ô¨Årst-order logic.
In this section, we develop such highly expressive relational ologs, called distributive relational
ologs. We follow the pattern established by Sections 3 to 5: Ô¨Årst, we present the relevant
monoidal structures on Rel; next, we abstract from Rel to formulate a general categorical
structure, called a distributive bicategory of relations; Ô¨Ånally, we deÔ¨Åne a distributive relational
olog to be a Ô¨Ånitely presented distributive bicategory of relations.
9.1. The category of relations, revisited
The category of relations has another interesting monoidal product, besides the Cartesian
product: the disjoint union. In this section, we explain disjoint unions from a categorical
perspective. As in Section 3, our presentation draws on the survey [CP10], especially ¬ß3.5 on
‚Äúclassical-like‚Äù monoidal products.
The disjoint union (or tagged union) is deÔ¨Åned on objects of Rel by
X  Y := {(x, 1) : x ‚ààX} ‚à™{(y, 2) : y ‚ààY }.
An element of X  Y is either an element of X or an element of Y , plus a special tag to
avoid ambiguity when X and Y intersect. Given morphisms R : X ‚ÜíY and S : Z ‚ÜíW of
Rel, the disjoint union R  S : X  Z ‚ÜíY  W is deÔ¨Åned by
(t, i)(R  S)(s, j)
iÔ¨Ä
Ô£±
Ô£¥
Ô£¥
Ô£≤
Ô£¥
Ô£¥
Ô£≥
R(t, s)
if i = j = 1
S(t, s)
if i = j = 2
‚ä•
otherwise
The monoidal unit is O := ‚àÖ, the empty set. Finally, the braiding morphism œÉX,Y : X  Y ‚Üí
Y  X exchanges the tags. With these deÔ¨Ånitions, (Rel, , O) is a symmetric monoidal
category.
The category of relations is now equipped with two monoidal products. In general, when
working with two monoidal products  and , we call the Ô¨Årst product  the tensor and
the second product  the cotensor. To avoid confusion, we will always use ‚Äúlight‚Äù notation
for structures associated with the tensor and ‚Äúdark‚Äù notation for structures associated with
the cotensor. What that means should become clear shortly.
We would like to reason about both monoidal products using a single graphical language.
Unfortunately, that is not entirely straightforward. The basic problem is that we now have
an eÔ¨Äectively three-dimensional language, with dimensions corresponding to composition,
the tensor, and the cotensor, but drawing pictures in dimensions greater than two is highly
41

impractical. We discuss (two-dimensional!) graphical languages for multiple products below.
For the moment, we work exclusively with the cotensor and can therefore employ, without
ambiguity, the usual graphical language of monoidal categories.
We now consider structures derived from the disjoint union. DeÔ¨Åne the codiagonals ‚ñºX :
X  X ‚ÜíX and ‚ñ†X : O ‚ÜíX on Rel by
(x, i)‚ñºXx‚Ä≤
iÔ¨Ä
x = x‚Ä≤.
Note that the initial morphism ‚ñ†X must be the (typed) empty relation O ‚ÜíX. DeÔ¨Åne the
diagonals ‚ñ≤X := ‚ñº‚Ä†
X : X ‚ÜíX  X and ‚ô¶X := ‚ñ†‚Ä†
X : X ‚ÜíO by duality. As in (Rel, , I),
these morphisms form special ‚Ä†-Frobenius monoids; in particular, they satisfy the Frobenius
equations.
The disjoint union is logically dual to the Cartesian product. The union R‚à™S of two relations
R, S : X ‚ÜíY is ‚ñ≤X(R  S)‚ñºY or, in graphical language,
R ‚à™S
=
X
R
S
Y
.
Similarly, the typed empty relation ‚ä•X,Y : X ‚ÜíY , or local minimum, is ‚ô¶X ¬∑ ‚ñ†Y :
‚ä•X,Y
=
X
Y
.
In particular, the boolean ‚ä•: I ‚ÜíI is ‚ä•I,I = ‚ô¶I ¬∑ ‚ñ†I.
There is a categorical interpretation of logical duality. The familiar principle of 1-categorical
duality establishes a correspondence between a category C and its opposite Cop. In a bicategory
of relations, this form of duality is captured by the dagger functor. By analogy, in a 2-category
B, we can consider the 2-category Bco obtained from B by reversing all 2-morphisms. The
correspondence between B and Bco is duality at the level of 2-morphisms. If B is a bicategory
of relations, then 2-categorical duality is logical duality. Consider the situation in Rel. The
diagonals ‚àÜX and ‚ô¶X are maps, and the codiagonals ‚ñºX and ‚ñ†X are also maps. Equivalently,
the diagonals ‚àÜX and ‚ô¶X are maps in Rel, while the diagonals ‚ñ≤X and ‚ô¶X are maps in
Relco. Thus (Relco, , O) is also a bicategory of relations, provided we verify the axiom on
lax monoid homomorphisms.
In fact, a stronger statement holds, breaking the symmetry between products and sums.
Unlike the diagonals ‚àÜX and ‚ô¶X in (Rel, , I), the codiagonals ‚ñºX and ‚ñ†X in (Rel, , O)
are natural. That is, for every relation R : X ‚ÜíY , we have (R  R)‚ñºY = ‚ñºXR and
‚ñ†XR = ‚ñ†Y , or graphically
R
R
X
X
Y
=
R
X
Y
42

and
R
X
Y
=
Y
.
Likewise, we have ‚ñ≤X(R  R) = R‚ñ≤Y and R‚ô¶Y = ‚ô¶X. This situation motivates the following
deÔ¨Ånition.
DeÔ¨Ånition. Let (C, , O) be a symmetric monoidal category. The monoidal product  on C
is a
‚Ä¢ a (categorical) product if there exists a diagonal (‚ñ≤A, ‚ô¶A), natural in A;
‚Ä¢ a (categorical) coproduct if there exists a codiagonal (‚ñºA, ‚ñ†A), natural in A;
‚Ä¢ a biproduct if it both a product and coproduct, such that for any objects A1, A2, the
projection maps œÄ1 = 1A1  ‚ô¶A2 and œÄ2 = ‚ô¶A1  1A2, the inclusion maps Œπ1 = 1A1  ‚ñ†A2
and Œπ2 = ‚ñ†A1  1A2, and zero maps 0i,j = ‚ô¶Ai‚ñ†Aj satisfy the equations
Œπi ¬∑ œÄj = Œ¥i,j :=
Ô£±
Ô£≤
Ô£≥
1Ai
if i = j
0i,j
if i Ã∏= j ,
i, j = 1, 2.
Remark. Although it is not immediately obvious, these deÔ¨Ånitions of ‚Äúproduct‚Äù and ‚Äúcoproduct‚Äù
agree with the standard deÔ¨Ånitions via universal properties [HV12].
The category of relations is a biproduct category with respect to the disjoint union. Another
prime example of a biproduct category is (Vectk, ), the category of Ô¨Ånite-dimensional vector
spaces and linear maps, equipped with the direct sum. The category of linear relations,
VectRelk, is not a biproduct category.
Interactions between monoidal products
We have hitherto studied the disjoint union only
in isolation. We now consider how the Cartesian product and disjoint union interact in Rel.
On the objects of Rel, there is a natural isomorphism
X  (Y  Z) ‚àº= (X  Y )  (X  Z),
given by (x, (w, i)) 7‚Üí((x, w), i), that expresses the distributivity of products over sums. In
words: having an element of X and an element of Y or Z is the same as having elements of
X and Y or elements of X and Z. Here is one possible general deÔ¨Ånition of distributivity in
a monoidal category.
DeÔ¨Ånition ([Jay93]). A distributive monoidal category is a symmetric monoidal category
(C, , I) with coproduct  that satisÔ¨Åes the distributive law: for any objects A, B, C, the
canonical distributivity morphism
(A  B)  (A  C) ‚ÜíA  (B  C),
determined by the universal property of the coproduct, is an isomorphism.
Remark. A rig category, or bimonoidal category, retains the distributive law but relaxes
the requirements that the tensor be symmetric and that the cotensor be the coproduct. It
categoriÔ¨Åes the classical algebraic structure known as a ‚Äúrig‚Äù (ring without negatives) [BD98].
For the purposes of this paper, the extra generality of rig categories is unnecessary.
43

Besides Set and Rel, examples of distributive monoidal categories include Ab, the category
of abelian groups, and Vectk, the category of Ô¨Ånite-dimensional vector spaces, both equipped
the tensor product  and the direct sum .
The distributive law extends to morphisms of Rel in a familiar way. For any three relations
R, S, T : X ‚ÜíY , we have
R ‚à©(S ‚à™T) = (R ‚à©S) ‚à™(R ‚à©T).
It is tempting to display this equation diagrammatically:
R
S
T
=
R
S
R
T
.
As noted at the beginning of this section, diagrams involving two monoidal products take
us beyond the Ô¨Årmly established graphical language of monoidal categories. The picture
above relies on context derived from the copy and merge nodes to determine which monoidal
product is ‚Äúactive‚Äù at a given point. In this case the notation is unambiguous, but in general
one must take care to avoid coherence problems, especially when working with the monoidal
units. We conjecture that soundness is maintained if the cotensor is restricted to forming
unions (via the morphisms ‚ñ≤X and ‚ñºX) and local minima (via ‚ô¶X and ‚ñ†X). This restricted
language is already suÔ¨Écient for applications that do not directly utilize sum types, a special
case of some practical interest.
In the literature, proof nets are established as a graphical calculus for categories with
two monoidal products. Girad introduced proof nets in his seminal paper on linear logic
[Gir87]. Blute et al generalized the formalism to weakly distributive and ‚àó-autonomous
categories (models of linear logic), adopting a graphical style reminiscent of string diagrams
[Blu+96]. Unfortunately, proof nets are considerably more complicated than string diagrams,
accommodating monoidal units through special ‚Äúthinning links.‚Äù In our view it remains an
open problem to deÔ¨Åne a graphical language for categories with multiple monoidal products
that is provably coherent‚Äîsound and complete‚Äîbut still simple enough for practical use by
nonspecialists.
9.2. Distributive bicategories of relations
Motivated by distributivity in the category of relations, we deÔ¨Åne a categorical abstraction
called a ‚Äúdistributive bicategory of relations.‚Äù We begin with the following more general
deÔ¨Ånition.
44

DeÔ¨Ånition. A union bicategory of relations is a locally posetal 2-category B, a symmetric
monoidal category (B, , I) with diagonals (X, ‚àÜX, ‚ô¶X), and a symmetric monoidal category
(B, , O) with codiagonals (X, ‚ñºX, ‚ñ≤X), such that
‚Ä¢ every morphism R : X ‚ÜíY is a lax comonoid homomorphism and a lax monoid
homomorphism;
‚Ä¢ the morphisms ‚àÜX, ‚ô¶X, ‚ñºX, ‚ñ†X have right adjoints, denoted ‚àáX, ‚ñ°X, ‚ñ≤X, ‚ô¶X;
‚Ä¢ both pairs (‚àÜX, ‚àáX) and (‚ñ≤X, ‚ñºX) obey the Frobenius equations.
Equivalently, a union bicategory of relations is a locally posetal 2-category B such that both
B and Bco are bicategories of relations (not necessarily with respect to the same monoidal
product).
Remark. To our knowledge, this deÔ¨Ånition does not appear in the literature. Note that
Johnstone‚Äôs ‚Äúunion allegory‚Äù insists that unions are preserved by composition [Joh02, ¬ßA3.2];
under our deÔ¨Ånition of ‚Äúunion bicategory of relations,‚Äù the strongest statement that can
be made about the interaction between unions and composition is the logical dual of the
modular law, (R ‚à™TS‚Ä†)S ‚äÜRS ‚à™T.
The deÔ¨Ånition postulates no relationship whatsoever between the two monoidal products. An
abelian bicategory of relations (Section 6.4) is a union bicategory of relations where the two
products coincide. In our main example VectRelk, the union L ‚à™M of two linear relations
L, M ‚äÜU  V is the vector space sum L + M. The other important special case of a union
bicategory of relations is the distributive bicategory of relations.
DeÔ¨Ånition. A distributive bicategory of relations is a union bicategory of relations where
the cotensor is the categorical coproduct.
We denote by DistBiRel the category of (small) distributive bicategories of relations and
structure-preserving functors.
Remark. Carboni and Walters mention ‚Äúdistributive‚Äù bicategories of relations in passing, but
do not clearly state a deÔ¨Ånition [CW87, Remark 3.7]. It seems likely that our deÔ¨Ånition is
what they had in mind. Freyd and Scedrov utilize an analogous concept of ‚Äúdistributive
allegory‚Äù [FS90].
Of course, Rel is a distributive bicategory of relations. Another example is the category of
boolean matrices, Mat(B), introduced in Section 6.3.
Several important properties are implicit in the deÔ¨Ånition.
As the name suggests, the
distributive law holds automatically in a distributive bicategry of relations. In fact, if (C, , I)
is any compact closed category and  is the coproduct, then C is a distributive monoidal
category [Jay93]. Moreover, it can be shown that intersections distribute over unions in
a distributive bicategory of relations. Also, the coproduct in a distributive bicategry of
relations is automatically a biproduct, by the symmetry of a dagger category. (Alternatively,
products or coproducts in a compact closed category are always biproducts [Hou08].) Table 3
summarizes the extra notation associated with a distributive bicategory of relations, extending
Table 2 in Section 4.
45

Structure
Name
Notation and deÔ¨Ånition
biproduct category
biproduct
R  S
braiding
œÉX,Y
merge
‚ñºX
create
‚ñ†X
copy
‚ñ≤X := ‚ñº‚àó
X = ‚ñº‚Ä†
X
delete
‚ô¶X := ‚ñ†‚àó
X = ‚ñ†‚Ä†
X
logical
union
R ‚à™S := ‚ñ≤X(R  S)‚ñºY
false
‚ä•:= ‚ô¶I ¬∑ ‚ñ†I
local minimum
‚ä•X,Y := ‚ô¶X ¬∑ ‚ñ†Y
Table 3: Summary of extra morphisms in a distributive bicategory of relations
Lastly, following the established pattern, we deÔ¨Åne a corresponding notion of olog. All
remarks made in Section 5 about the meaning of ‚ÄúÔ¨Ånitely presented‚Äù remain in force.
DeÔ¨Ånition. A distributive relational olog is a Ô¨Ånitely presented distributive bicategory of
relations.
Distributive relational ologs are very expressive. The only connectives of Ô¨Årst-order logic
not directly expressible are negation and universal quantiÔ¨Åcation. However, the negation,
or complement, of a relation R : X ‚ÜíY can be implicitly deÔ¨Åned by introducing another
relation S : X ‚ÜíY together with the two axioms R ‚à©S ‚áí‚ä•X,Y and ‚ä§X,Y ‚áíR ‚à™S. In
graphical language, the axioms are beautifully symmetric:
X
R
S
Y
=‚áí
X
Y
X
Y
=‚áí
X
R
S
Y
.
This deÔ¨Ånition of negation makes sense in any union bicategory of relations. In Rel, negation
is the usual set-theoretic complement; in VectRelk, it is the subspace complement (internal
direct sum).
9.3. Categorical logic with product and sum types
By now it should be evident that distributive relational ologs correspond, in some sense, to
the fragment of Ô¨Årst-order logic with connectives ‚àÉ, ‚àß, ‚à®, ‚ä§, ‚ä•, =. This fragment is called
coherent logic or, in older literature, geometric logic. Coherent logic, or variants thereof,
has been used in axiomatic geometry [ADM09] and in automated theorem proving [Sto+14;
46

GG16], in part because it is more readily interpretable by humans than richer logics. Coherent
logic is nonetheless as expressive as Ô¨Årst-order logic, in the sense that any Ô¨Årst-order theory
can be translated into an equivalent coherent theory called its Morleyization [Joh02, Lemma
D1.5.13]. In the Morleyized theory, negations are encoded by the two axioms shown above.
Despite the suggestive analogy, a direct translation of Section 8 founders, due to the presence
of sum types. In a bicategory of a relations, any two objects X and Y have a product X  Y ,
but our system of typed regular logic does not include product types. That is, the syntax
does not permit the construction of a type A √ó B from two basic types A and B. This
mismatch is, however, not fatal because products are smuggled into the logical system as
contexts: a context (x : A, y : B) amounts to a single variable of type A√óB. Adding a second
monoidal product puts this device under considerable strain. One could conceivably extend
the syntax of a context to represent a fully ‚Äúdestructured‚Äù element of arbitrary compound
type. A better solution is to augment the logical language with product types A √ó B and
sum types A + B, as well as a unit (singleton) type 1 and zero (empty) type 0. The role of
contexts is downplayed accordingly.
Product and sum types are ubiquitous in programming language theory. The simply typed
lambda calculus is often treated with product and sum types, in both classical and categorical
settings [Sel13; LS88]. By contrast, Ô¨Årst-order logics with non-trivial type systems are rare.
A proof system for Ô¨Årst-order logic with product and sum types does not, to our knowledge,
appear in the literature. We now present such a system, straightforwardly adapted from the
lambda calculus. As in Section 8, the treatment here is informal. Details and proofs are
deferred to Appendix B.
Remark. A clariÔ¨Åcation may be helpful to readers acquainted with the Curry-Howard cor-
respondence [How80; Wad15]. The interpretation of types as propositions, and programs
as proofs, is the subject of a large body of research. However, we are interested in types
with logic, not types as logic. The former is sometimes called ‚Äútwo-level type theory.‚Äù An
example is Gambino and Aczel‚Äôs ‚Äúlogic-enriched type theory,‚Äù a system of Ô¨Årst-order logic
with dependent types [GA06].
By using a non-trivial type system, we commit ourselves to a proper treatment of terms. In
Section 8, we did not bother to distinguish the ‚Äúterms‚Äù of regular logic, which are just typed
variables x : A. We now formally distinguish two kinds of expressions in context: formulas
(also called propositions) and terms. As before, the formulas are generated by the equality
relation, relation symbols, and logical connectives. The terms are generated by variables,
function symbols, and term constructors for the product and sum types.
The term constructors are familiar from typed lambda calculus. Given a term t : A √ó B,
there are projection terms œÄ1(t) : A and œÄ2(t) : B, and given two terms t : A and s : B, there
is a pair term ‚ü®t, s‚ü©: A √ó B. Dually, given terms t : A and s : B, there are inclusion terms
Œπ1(t) : A + B and Œπ2(s) : A + B, and given terms t : A + B, r : C, s : C, there is a copair term
Œ¥ (t, x : A.r, y : B.s) : C. The copair term, or ‚Äúcase statement,‚Äù is interpreted as follows. If
t : A + B is a value of type A, return the term r with variable x replaced by t. If t : A + B is
a value of type B, return the term s with variable y replaced by t. In either case, the result
is a value of type C.
47

We now sketch the correspondence between coherent logic with product and sum types and
distributive bicategories of relations. To every coherent theory T we associate the classifying
category Cl(T), a distributive bicategory of relations. Its objects are the types of T. Note the
diÔ¨Äerence from Section 8, where the objects of Cl(T) are Ô¨Ånite lists of types. The morphisms
of Cl(T) are equivalence classes of formulas in context with exactly two free variables. The
types of these variables are the domain and codomain of the morphism. We make the
classifying category into a distributive bicategory of relations analogously to Rel (Sections 3
and 9.1).
Conversely, every small distributive bicategory of relations B has its internal language
Lang(B), a coherent theory. As before, we interpret an arbitrary formula in context Œì | œï of
Lang(B) as a morphism JŒì | œïK of B. The construction proceeds analogously to Section 8,
with one important addition: terms are interpreted as maps. More precisely, a term in
context Œì | t : A is interpreted as a morphism JŒì | t : AK : JŒìK ‚ÜíJAK of Map(B). Although
the connection between terms and maps is interesting its own right, in the present proof,
the interpretation of terms as maps serves only to establish the base case in the inductive
interpretation of formulas as morphisms.
Our main result, proved in Appendix B, is stated below.
Theorem. With respect to coherent logic with product and sum types, for every small
distributive bicategory of relations B, there is an equivlance of categories
Cl(Lang(B)) ‚âÉB
in
DistBiRel.
It is also possible to realize the correspondence between regular logic and bicategories of
relations using a richer type system than in Section 8. The appropriate logic is regular logic
with product types and a singleton type (but not sum types or an empty type).
Theorem. With respect to regular logic with product types, for every small bicategory of
relations B, there is an equivalence of categories
Cl(Lang(B)) ‚âÉB
in
BiRel.
10. Conclusion and outlook
In this paper, we have propounded a categorical framework for knowledge representation
centered around bicategories of relations. We emphasized three important features that
emerge automatically from category theory: instance data, types, and graphical syntax.
We compared our framework informally to description logic and formally to the regular
and coherent fragments of typed Ô¨Årst-order logic. In this Ô¨Ånal section, we oÔ¨Äer a general
perspective on categorical knowledge representation. We also suggest directions for future
research.
We have extensively discussed the relationship between the algebraic and logical approaches
to knowledge representation, but have said comparatively little about how the two categorical
48

frameworks‚Äîfunctional and relational ologs‚Äîare related. Although a complete answer
is beyond the scope of this work, we will suggest a ‚Äúpattern‚Äù or ‚Äútemplate‚Äù for deÔ¨Åning
categorical ontologies that is general enough to encompass these and other frameworks. This
template can perhaps serve as a Ô¨Årst step towards a uniÔ¨Åed methodology of categorical
knowledge representation.
Doctrines are a useful organizing principle for category theory [KR77]. Informally, a doctrine
is a family of categories or higher categories with extra structure. The most basic doctrine is
the doctrine of categories (with no extra structure). There are also doctrines of categories with
Ô¨Ånite products, of symmetric monoidal categories, of compact closed categories, of 2-categories,
of bicategories of relations, etc. Besides the categories themselves, a doctrine speciÔ¨Åes the
relevant kind of ‚Äústructure-preserving‚Äù functors, and the natural transformations between
these. The concept of doctrine can be formalized, but for us this informal understanding is
perfectly adequate.
Here is a general recipe for constructing a categorical knowledge base. First, choose a doctrine.
This choice should be informed by the phenomena being modeled; we expand on this idea
below. Next, deÔ¨Åne a Ô¨Ånitary speciÔ¨Åcation language for the doctrine. As above, the basic
strategy is Ô¨Ånite presentation, a.k.a. the method of generators and relations, which works
in considerable generality. If the doctrine supports arbitrary limits or colimits, the method
of sketches can be used instead [Wel93; Mak97]. Alternatively, if the doctrine has as its
internal language some well-known logical system, that system could serve as a speciÔ¨Åcation
language. Finally, use the speciÔ¨Åcation language to deÔ¨Åne an ontology. As a mathematical
object, the ontology is simply a Ô¨Ånitely generated category of the doctrine. Instance data for
the ontology is derived from the ‚Äúprototype‚Äù category of the doctrine, such as Set or Rel, or
possibly from a more exotic category.
Some doctrines relevant to knowledge representation are listed in Table 4. Functional ologs
arise from the doctrine of categories with Ô¨Ånite limits and colimits; relational ologs from the
doctrine of bicategories of relations. The typed lambda calculus is the internal language of
the doctrine of cartesian closed categories. Besides its central role in programming language
theory, the lambda calculus has been used to model natural languages [HK98]. This list by
no means exhausts the doctrines that are potentially useful for knowledge representation.
DiÔ¨Äerent doctrines are appropriate for diÔ¨Äerent applications. Bicategories of relations are
designed to model classes of entities (concepts) and the relationships between them (roles).
Description logic shares this orientation. However, creating taxonomies of concepts is hardly
the only worthwhile application of knowledge representation. As an example, the original
impetus for this work was our need to model knowledge about computer programs used
in data analysis. Description logics (and relational ologs) are ill-suited to this project; a
doctrine related to the lambda calculus is much more appropriate. In general, we worry that
the mainstream of KR research has unjustiÔ¨Åably privileged taxonomies over other kinds of
knowledge. Our philosophy is that category theory is a universal modeling language enabling
a more expansive understanding of knowledge representation. In the future, we hope to
see practical, Ô¨Çexible knowledge representation systems that allow doctrines to be rapidly
assembled from the categorical toolbox to meet the needs of particular applications.
49

Doctrine
Prototype(s) Internal language
category
Set
category with Ô¨Ånite (co)limits
Set
bicategory of relations
Rel
regular logic with product
types
distributive bicategory of relations
Rel
coherent logic with product
and sum types
cartesian closed category
Set, CPO
typed lambda calculus with
product types
bicartesian closed category
Set
typed lambda calculus with
product and sum types
Table 4: Selected doctrines relevant to knowledge representation
There are myriad directions for future research on categorical knowledge representation. We
mention a few that are directly relevant to relational ologs.
A glaring omission in this work is any discussion of automated inference. By contrast,
computationally tractable inference has been the prime directive of the description logic
community. The Ô¨Årst step for our project is to acknowledge that inference in a relational
olog is undecidable. This is true even without the extensions of Section 9. (One can see this
algebraically, by reduction from the word problems for monoids or groups, or logically, by
reduction from the decision problem for regular theories.)
There are two possible responses to the problem of undecidability. We could follow the DL
community in imposing language restrictions to achieve provable computational tractability.
The extensive DL literature would doubtless be very helpful in carrying out this program.
However, we worry that imposing ad hoc restrictions would do irredeemable violence to
the formalism‚Äôs elegance and expressivity. A second approach is to allow an unrestricted
language and settle for approximate inference. We share with Doyle and Patil the opinion
that this approach is undervalued by the description logic community [DP91]. In the statistics
and machine learning communities, the need for approximate inference in complex models
is an accepted fact of life. The contrast is especially stark because inference in Ô¨Årst-order
theories is harder than inference in probabilistic models. In any event, developing inference
algorithms for relational ologs, exact or approximate, is an important prerequisite for practical
applications.
Another problem, already raised in Section 9, is to deÔ¨Åne a graphical language for distributive
bicategories of relations that is coherent, yet intuitive. (We think that proof nets fall short
on the second count.) The graphical language of string diagrams is a very appealing feature
of relational ologs. We hope that a satisfactory extension of string diagrams to categories
with multiple monoidal products will be discovered.
50

Acknowledgments
I thank John Baez, David Spivak, and Ryan Wisnesky for helpful comments on the manuscript.
I am grateful to Thomas Icard for his encouragement of this project. Finally, I thank the
many contributors to the nLab for creating an invaluable online resource for aspiring and
professional category theorists.
References
[AC04]
Samson Abramsky and Bob Coecke. ‚ÄúA categorical semantics of quantum proto-
cols‚Äù. Logic in Computer Science, 2004. IEEE. 2004, pp. 415‚Äì425.
[ADM09]
Jeremy Avigad, Edward Dead, and John Mumma. ‚ÄúA formal system for Euclid‚Äôs
Elements‚Äù. The Review of Symbolic Logic 2.4 (2009), pp. 700‚Äì768.
[AG05]
Renzo Angles and Claudio Gutierrez. ‚ÄúQuerying RDF data from a graph database
perspective‚Äù. European Semantic Web Conference. 2005, pp. 346‚Äì360.
[AG08]
Renzo Angles and Claudio Gutierrez. ‚ÄúSurvey of graph database models‚Äù. ACM
Computing Surveys 40.1 (2008), p. 1.
[AL12]
Emilio Jes√∫s Gallego Arias and James B. Lipton. ‚ÄúLogic programming in tabular
allegories‚Äù. Technical Communications of the 28th International Conference on
Logic Programming (ICLP‚Äô12). Vol. 17. Schloss Dagstuhl‚ÄìLeibniz-Zentrum fuer
Informatik, 2012, pp. 334‚Äì347.
[Apa15]
Apache Software Foundation. TinkerPop3 Documentation. 2015. url: http:
//tinkerpop.apache.org/docs/current/reference/ (visited on 03/23/2017).
[Ash+00]
Michael Ashburner et al. ‚ÄúGene Ontology: tool for the uniÔ¨Åcation of biology‚Äù.
Nature Genetics 25.1 (2000), pp. 25‚Äì29.
[Awo09]
Steve Awodey. ‚ÄúIntroduction to Categorical Logic‚Äù. Lecture notes. 2009. url:
http://www.andrew.cmu.edu/user/awodey/catlog/notes/.
[Awo10]
Steve Awodey. Category Theory. 2nd ed. Oxford University Press, 2010.
[Baa+07]
Franz Baader, Diego Calvanese, Deborah L McGuinness, Daniele Nardi, and Peter
F Patel-Schneider, eds. The Description Logic Handbook: Theory, Implementation
and Applications. 2nd ed. Cambridge University Press, 2007.
[BD98]
John Baez and James Dolan. ‚ÄúCategoriÔ¨Åcation‚Äù. arXiv:math/9802029 (1998).
[BE15]
John Baez and Jason Erbele. ‚ÄúCategories in control‚Äù. Theory and Applications of
Categories 30.24 (2015), pp. 836‚Äì881.
[BF15]
John Baez and Brendan Fong. ‚ÄúA compositional framework for passive linear
networks‚Äù. arXiv:1504.05625 (2015).
[BH94]
Carolyn Brown and Graham Hutton. ‚ÄúCategories, allegories and circuit design‚Äù.
Logic in Computer Science, 1994. LICS‚Äô94. IEEE. 1994, pp. 372‚Äì381.
51

[BHL01]
Tim Berners-Lee, James Hendler, and Ora Lassila. ‚ÄúThe Semantic Web‚Äù. ScientiÔ¨Åc
American 284.5 (2001), pp. 28‚Äì37.
[BJ94]
Carolyn Brown and Alan JeÔ¨Ärey. ‚ÄúAllegories of circuits‚Äù. International Symposium
on Logical Foundations of Computer Science. Springer. 1994, pp. 56‚Äì68.
[BKV16]
Krzysztof Bar, Aleks Kissinger, and Jamie Vicary. ‚ÄúGlobular: an online proof
assistant for higher-dimensional rewriting‚Äù. arXiv:1612.01093 (2016).
[BL04]
Ronald Brachman and Hector Levesque. Knowledge Representation and Reasoning.
Elsevier, 2004.
[BL84]
Ronald Brachman and Hector Levesque. ‚ÄúThe tractability of subsumption in
frame-based description languages‚Äù. AAAI-84 Proceedings. AAAI. 1984, pp. 34‚Äì
37.
[Blu+96]
Richard F Blute, J Robin B Cockett, Robert A G Seely, and Todd H Trimble.
‚ÄúNatural deduction and coherence for weakly distributive categories‚Äù. Journal of
Pure and Applied Algebra 113.3 (1996), pp. 229‚Äì296.
[BM14]
Dan Brickley and Libby Miller. FOAF Vocabulary SpeciÔ¨Åcation 0.99. 2014. url:
http://xmlns.com/foaf/spec/20140114.html.
[BS10]
John Baez and Mike Stay. ‚ÄúPhysics, topology, logic and computation: a Rosetta
Stone‚Äù. New Structures for Physics. Springer, 2010, pp. 95‚Äì172.
[BSZ14]
Filippo Bonchi, Pawe≈Ç Soboci≈Ñski, and Fabio Zanasi. ‚ÄúA categorical semantics of
signal Ô¨Çow graphs‚Äù. International Conference on Concurrency Theory (CONCUR
2014). 2014, pp. 435‚Äì450.
[But98]
Carsten Butz. ‚ÄúRegular categories and regular logic‚Äù. BRICS Lecture Series
LS-98-2 (1998).
[Car+08]
Aurelio Carboni, G Max Kelly, Robert FC Walters, and Richard J Wood. ‚ÄúCarte-
sian bicategories II‚Äù. Theory and Applications of Categories 19.6 (2008), pp. 93‚Äì
124.
[Car86]
John Cartmell. ‚ÄúGeneralised algebraic theories and contextual categories‚Äù. Annals
of Pure and Applied Logic 32 (1986), pp. 209‚Äì243.
[CLW93]
Aurelio Carboni, Stephen Lack, and Robert FC Walters. ‚ÄúIntroduction to extensive
and distributive categories‚Äù. Journal of Pure and Applied Algebra 84.2 (1993),
pp. 145‚Äì158.
[Cod70]
Edgar F Codd. ‚ÄúA relational model of data for large shared data banks‚Äù. Com-
munications of the ACM 13.6 (1970), pp. 377‚Äì387.
[CP10]
Bob Coecke and Eric Oliver Paquette. ‚ÄúCategories for the practising physicist‚Äù.
New Structures for Physics. Springer, 2010, pp. 173‚Äì286.
[Cro93]
Roy L Crole. Categories for Types. Cambridge University Press, 1993.
[CW87]
Aurelio Carboni and Robert FC Walters. ‚ÄúCartesian bicategories I‚Äù. Journal of
Pure and Applied Algebra 49.1-2 (1987), pp. 11‚Äì32.
52

[DP91]
Jon Doyle and Ramesh S Patil. ‚ÄúTwo theses of knowledge representation: Language
restrictions, taxonomic classiÔ¨Åcation, and the utility of representation services‚Äù.
ArtiÔ¨Åcial intelligence 48.3 (1991), pp. 261‚Äì297.
[DV10]
Ian Davis and Eric Vitiello Jr. RELATIONSHIP: A vocabulary for describing
relationships between people. 2010. url: http://vocab.org/relationship/.
[FDB06]
Marcelo Fiore, Roberto Di Cosmo, and Vincent Balat. ‚ÄúRemarks on isomorphisms
in typed lambda calculi with empty and sum types‚Äù. Annals of Pure and Applied
Logic 141.1-2 (2006), pp. 35‚Äì50.
[Fre72]
Peter Freyd. ‚ÄúAspects of topoi‚Äù. Bulletin of the Australian Mathematical Society
7.1 (1972), pp. 1‚Äì76.
[Fri12]
Bernard Friedland. Control system design: an introduction to state-space methods.
Courier Dover Publications, 2012.
[FS90]
Peter J Freyd and Andre Scedrov. Categories, Allegories. Elsevier, 1990.
[GA06]
Nicola Gambino and Peter Aczel. ‚ÄúThe generalised type-theoretic interpretation
of constructive set theory‚Äù. Journal of Symbolic Logic (2006), pp. 67‚Äì103.
[Gal+93]
Giorgio Gallo, Giustino Longo, Stefano Pallottino, and Sang Nguyen. ‚ÄúDirected
hypergraphs and applications‚Äù. Discrete Applied Mathematics 42.2 (1993), pp. 177‚Äì
201.
[GG16]
M Ganesalingam and W T Gowers. ‚ÄúA fully automatic theorem prover with
human-style output‚Äù. Journal of Automated Reasoning (2016), pp. 1‚Äì39.
[Gir87]
Jean-Yves Girard. ‚ÄúLinear logic‚Äù. Theoretical Computer Science 50.1 (1987),
pp. 1‚Äì101.
[Gra+08]
Bernardo Cuenca Grau, Ian Horrocks, Boris Motik, Bijan Parsia, Peter Patel-
Schneider, and Ulrike Sattler. ‚ÄúOWL 2: The next step for OWL‚Äù. Web Semantics:
Science, Services and Agents on the World Wide Web 6.4 (2008), pp. 309‚Äì322.
[Har09]
John Harding. ‚ÄúA link between quantum logic and categorical quantum mechan-
ics‚Äù. International Journal of Theoretical Physics 48.3 (2009), pp. 769‚Äì802.
[HK98]
Irene Heim and Angelika Kratzer. Semantics in generative grammar. Blackwell,
1998.
[HKR09]
Pascal Hitzler, Markus Krotzsch, and Sebastian Rudolph. Foundations of Semantic
Web Technologies. CRC Press, 2009.
[HKS05]
Ian Horrocks, Oliver Kutz, and Ulrike Sattler. ‚ÄúThe irresistible SHIQ‚Äù. Proc. of
OWL: Experiences and Directions. 2005.
[HKS06]
Ian Horrocks, Oliver Kutz, and Ulrike Sattler. ‚ÄúThe even more irresistible
SROIQ‚Äù. Proc. 10th Int. Conf. on Principles of Knowledge Representation
and Reasoning (KR‚Äô06). AAAI, 2006, pp. 57‚Äì67.
[Hou08]
Robin Houston. ‚ÄúFinite products are biproducts in a compact closed category‚Äù.
Journal of Pure and Applied Algebra 212.2 (2008), pp. 394‚Äì400.
53

[How80]
William A Howard. ‚ÄúThe formulae-as-types notion of construction‚Äù. To H.B.
Curry: Essays on combinatory logic, lambda calculus and formalism 44 (1980),
pp. 479‚Äì490.
[HV12]
Chris Heunen and Jamie Vicary. Lectures on categorical quantum mechanics.
Computer Science Department, Oxford University. 2012.
[Jac95]
Bart Jacobs. ‚ÄúParameters and parametrization in speciÔ¨Åcation, using distributive
categories‚Äù. Fundamenta informaticae 24.3 (1995), pp. 209‚Äì250.
[Jac99]
Bart Jacobs. Categorical logic and type theory. Vol. 141. Studies in Logic and the
Foundations of Mathematics. Elsevier, 1999.
[Jay93]
C Barry Jay. ‚ÄúTail recursion through universal invariants‚Äù. Theoretical Computer
Science 115.1 (1993), pp. 151‚Äì189.
[Joh02]
Peter T Johnstone. Sketches of an elephant: A topos theory compendium. 2 vols.
Oxford University Press, 2002.
[KAH11]
Matthias Knorr, Jos√© J√∫lio Alferes, and Pascal Hitzler. ‚ÄúLocal closed world
reasoning with description logics under the well-founded semantics‚Äù. ArtiÔ¨Åcial
Intelligence 175.9-10 (2011), pp. 1528‚Äì1554.
[KN94]
Petrus Knijnenburg and Frank Nordemann. Two Categories of Relations. Tech.
rep. 94-32. Leiden University, Department of Computer Science, 1994.
[Koc04]
Joachim Kock. Frobenius algebras and 2-d topological quantum Ô¨Åeld theories.
Cambridge University Press, 2004.
[KR77]
Anders Kock and Gonzalo Reyes. ‚ÄúDoctrines in categorical logic‚Äù. Handbook of
Mathematical Logic. Ed. by Jon Barwise. North Holland, 1977.
[KSH12]
Markus Kr√∂tzsch, Frantisek Simancik, and Ian Horrocks. ‚ÄúA description logic
primer‚Äù. arXiv:1201.4089 (2012).
[KZ15]
Aleks Kissinger and Vladimir Zamdzhiev. ‚ÄúQuantomatic: A proof assistant for
diagrammatic reasoning‚Äù. International Conference on Automated Deduction.
Springer. 2015, pp. 326‚Äì336.
[Lac10]
Stephen Lack. ‚ÄúA 2-categories companion‚Äù. Towards higher categories. 2010,
pp. 105‚Äì191.
[Law15]
Finn Lawler. ‚ÄúFibrations of predicates and bicategories of relations‚Äù. arXiv:1502.08017
(2015).
[Law63]
F. William Lawvere. ‚ÄúFunctorial Semantics of Algebraic Theories‚Äù. PhD thesis.
Columbia University, 1963.
[Lei14]
Tom Leinster. Basic category theory. Vol. 143. Cambridge University Press, 2014.
[LS09]
F William Lawvere and Stephen H Schanuel. Conceptual mathematics: a Ô¨Årst
introduction to categories. 2nd ed. Cambridge University Press, 2009.
[LS88]
Joachim Lambek and Philip J Scott. Introduction to higher-order categorical logic.
Cambridge University Press, 1988.
54

[Mac63]
Saunders Mac Lane. ‚ÄúNatural associativity and commutativity‚Äù. Rice University
Studies 49.4 (1963), pp. 28‚Äì46.
[Mac98]
Saunders Mac Lane. Categories for the working mathematician. 2nd ed. Vol. 5.
Graduate Texts in Mathematics. Springer-Verlag, 1998.
[Mah16]
Michael Mahoney. ‚ÄúLecture notes on spectral graph methods‚Äù. arXiv:1608.04845
(2016).
[Mak97]
Michael Makkai. ‚ÄúGeneralized sketches as a framework for completeness theorems.
Part I‚Äù. Journal of Pure and Applied Algebra 115.1 (1997), pp. 49‚Äì79.
[Mim14]
Samuel Mimram. ‚ÄúTowards 3-dimensional rewriting theory‚Äù. arXiv:1403.4094
(2014).
[Mus15]
Mark A Musen. ‚ÄúThe Prot√©g√© project: A look back and a look forward‚Äù. AI
Matters 1.4 (2015), pp. 4‚Äì12.
[Nic+16]
Maximilian Nickel, Kevin Murphy, Volker Tresp, and Evgeniy Gabrilovich. ‚ÄúA
review of relational machine learning for knowledge graphs‚Äù. Proceedings of the
IEEE 104.1 (2016), pp. 11‚Äì33.
[Nie12]
Michael Nielsen. Reinventing Discovery: The New Era of Networked Science.
Princeton University Press, 2012.
[Noy+09]
Natalya F Noy et al. ‚ÄúBioPortal: ontologies and integrated data resources at the
click of a mouse‚Äù. Nucleic Acids Research (2009).
[Oos95]
Jaap van Oosten. ‚ÄúBasic Category Theory‚Äù. BRICS Lecture Series LS-95-1 (1995).
[Pat17]
Evan Patterson. epatters/Catlab: An experimental library for computational cate-
gory theory. Apr. 2017. doi: 10.5281/zenodo.569966.
[Pit95]
Andrew Pitts. Categorical logic. Tech. rep. University of Cambridge, Computer
Laboratory, 1995.
[PS08]
Eric Prud‚Äôhommeaux and Andy Seaborne, eds. SPARQL Query Language for RDF.
World Wide Web Consortium (W3C). 2008. url: https://www.w3.org/TR/rdf-
sparql-query/.
[PS97]
Frank Piessens and Eric Steegmans. ‚ÄúProving semantical equivalence of data
speciÔ¨Åcations‚Äù. Journal of Pure and Applied Algebra 116.1-3 (1997), pp. 291‚Äì322.
[RB11]
Peter N Robinson and Sebastian Bauer. Introduction to bio-ontologies. CRC Press,
2011.
[Rei78]
Raymond Reiter. ‚ÄúOn closed world data bases‚Äù. Logic and data bases. Springer,
1978, pp. 55‚Äì76.
[Rie16]
Emily Riehl. Category theory in context. Dover, 2016.
[RN10]
Marko A Rodriguez and Peter Neubauer. ‚ÄúConstructions from dots and lines‚Äù.
Bulletin of the American Society for Information Science and Technology 36.6
(2010), pp. 35‚Äì41.
[Sch+16]
Patrick Schultz, David I Spivak, Christina Vasilakopoulou, and Ryan Wisnesky.
‚ÄúAlgebraic databases‚Äù. arXiv:1602.03501 (2016).
55

[Sel07]
Peter Selinger. ‚ÄúDagger compact closed categories and completely positive maps‚Äù.
Electronic Notes in Theoretical Computer Science 170 (2007), pp. 139‚Äì163.
[Sel10]
Peter Selinger. ‚ÄúA survey of graphical languages for monoidal categories‚Äù. New
Structures for Physics. Springer, 2010, pp. 289‚Äì355.
[Sel13]
Peter Selinger. ‚ÄúLecture notes on the lambda calculus‚Äù. arXiv:0804.3434 (2013).
[Sel99]
Peter Selinger. ‚ÄúCategorical structure of asynchrony‚Äù. Electronic Notes in Theo-
retical Computer Science 20 (1999), pp. 158‚Äì181.
[SK12]
David I Spivak and Robert E Kent. ‚ÄúOlogs: a categorical framework for knowledge
representation‚Äù. PLoS One 7.1 (2012).
[SKH11]
Kunal Sengupta, Adila Alfa Krisnadhi, and Pascal Hitzler. ‚ÄúLocal closed world
semantics: Grounded circumscription for OWL‚Äù. International Semantic Web
Conference. Springer. 2011, pp. 617‚Äì632.
[Spi12]
David I Spivak. ‚ÄúFunctorial data migration‚Äù. Information and Computation 217
(2012), pp. 31‚Äì51.
[Spi14]
David I Spivak. Category theory for the sciences. MIT Press, 2014.
[Sto+14]
Sana Stojanoviƒá, Julien Narboux, Marc Bezem, and Predrag Janiƒçiƒá. ‚ÄúA vernacular
for coherent logic‚Äù. International Conference on Intelligent Computer Mathematics.
Springer. 2014, pp. 388‚Äì403.
[SW15]
David I Spivak and Ryan Wisnesky. ‚ÄúRelational foundations for functorial data mi-
gration‚Äù. Proceedings of the 15th Symposium on Database Programming Languages.
ACM. 2015, pp. 21‚Äì28.
[TG87]
Alfred Tarski and Steven Givant. A formalization of set theory without variables.
Vol. 41. American Mathematical Society, 1987.
[Wad15]
Philip Wadler. ‚ÄúPropositions as types‚Äù. Communications of the ACM 58.12 (2015),
pp. 75‚Äì84.
[Wel93]
Charles Wells. ‚ÄúSketches: Outline with References‚Äù. With 2009 addendum. 1993.
url: http://www.cwru.edu/artsci/math/wells/pub/pdf/Sketch.pdf.
[Woo75]
William A Woods. ‚ÄúWhat‚Äôs in a link: Foundations for semantic networks‚Äù. Repre-
sentation and Understanding: Studies in Cognitive Science (1975), pp. 35‚Äì82.
[ZMS13]
Bartosz Zieli≈Ñski, Pawe≈Ç Ma≈õlanka, and ≈öcibor Sobieski. ‚ÄúAllegories for database
modeling‚Äù. International Conference on Model and Data Engineering. Springer.
2013, pp. 278‚Äì289.
A. Regular logic and bicategories of relations
The objective of this appendix to state carefully and prove the theorem of Section 8, estab-
lishing a correspondence between regular logic and bicategories of relations. The development
will be detailed yet terse, as we have already explained the main ideas behind the theorem in
Section 8.
56

Œì | x1 : A1
¬∑ ¬∑ ¬∑
Œì | xn : An
Œì | R(x1, . . . , xn)
(relation symbol R : A)
Œì | x : A
Œì | y : A
Œì | x = y
(equality)
Œì | œï
Œì, x : A | œï
(weakening)
Œì | ‚ä§
(truth)
Œì | œï
Œì | œà
Œì | œï ‚àßœà
(conjunction)
Œì, x : A | œï
Œì | ‚àÉx : A.œï
(existential quantiÔ¨Åer)
Figure 1: Formation rules for regular logic
We Ô¨Årst deÔ¨Åne a formal system for regular logic. The syntax is borrowed from [Awo09] and
the proof system from [Joh02]. We depart from the standard formulation of regular logic only
by dispensing with function symbols. This convention is merely a convenience; Appendix B
shows how to incorporate function symbols.
DeÔ¨Ånition. A (multisorted) signature consists of
‚Ä¢ a set of sorts or basic types, which we write generically as A, B, A1, B1, . . . , and
‚Ä¢ a set of relation symbols, which we write as R, S, . . . , where each relation symbol R is
associated with a (possibly empty) ordered list of types (A1, . . . , An).
For brevity, we often use the vector notation A := (A1, . . . , An). To express that relation
symbol R has types A, we write R : A or R : (A1, . . . , An).
There is a countably inÔ¨Ånite set of variables x, y, z, . . . . Unlike in some typed logical calculi,
the variable symbols do not have Ô¨Åxed types. Instead, we write x : A to express that x is a
variable of type A. A context is a (possibly empty) Ô¨Ånite, ordered list of form
Œì = x : A = (x1 : A1, . . . , xn : An),
where the xi‚Äôs are distinct variables and the Ai‚Äôs are basic types.
With respect to a Ô¨Åxed signature, the formulas in context of the regular language are
expressions of form Œì | œï, where Œì is a context and œï is a formula, as deÔ¨Åned inductively
by the formation rules in Figure 1. Formulas outside of a context have no deÔ¨Ånite meaning.
Note that the only terms in context of the regular language are variables, for which there is a
single formation rule:
Œì, x : A, Œì‚Ä≤ | x : A.
57

œï ‚ä¢œï
(identity)
œï ‚ä¢œá
œá ‚ä¢œà
œï ‚ä¢œà
(cut)
x : A | œï ‚ä¢œà
Œì | t : A
Œì | œï[t/x] ‚ä¢œà[t/x]
(substitution)
œï ‚ä¢x = x
(x = y) ‚àßœï ‚ä¢œï[y/x]
(equality)
œï ‚ä¢‚ä§
(truth)
œï ‚ä¢œà
œï ‚ä¢œá
œï ‚ä¢œà ‚àßœá
œï ‚àßœà ‚ä¢œï
œï ‚àßœà ‚ä¢œà
(conjunction)
Œì, x : A | œï ‚ä¢œà
Œì | (‚àÉx : A.œï) ‚ä¢œà
(existential quantiÔ¨Åer)
Œì | œï ‚àß(‚àÉx : A.œà) ‚ä¢‚àÉx : A.(œï ‚àßœà)
[x /‚ààŒì]
(Frobenius)
Figure 2: Inference rules for regular logic
A sequent is an expression of form Œì | œï ‚ä¢œà, where Œì | œï and Œì | œà are both formulas in
context. The inference rules for sequents are listed in Figure 2.
The statement of the inference rules assumes the following notational conventions. Contexts
that are constant across the premises and conclusion of a rule are omitted. The formulas in
context appearing in the rules are implicitly assumed to be well-formed. For example, the
existential quantiÔ¨Åer rule assumes that x does not appear freely in œà because Œì | œà must be
well-formed. The vector notation x = y is shorthand for x1 = y1 ‚àß¬∑ ¬∑ ¬∑ ‚àßxn = yn; likewise,
‚àÉx : A is shorthand for ‚àÉx1 : A1 ¬∑ ¬∑ ¬∑ ‚àÉxn : An. The expression œï[y/x] denotes the simultaneous
substitution of yi for xi, for 1 ‚â§i ‚â§n, in the formula œï.
Remark. Several inference rules deserve further comment.
‚Ä¢ Substitution: Useful special cases of the substitution rule include the weakening and
strengthening rules
Œì | œï ‚ä¢œà
Œì, x : A | œï ‚ä¢œà
Œì, x : A | œï ‚ä¢œà
Œì | t : A
Œì | œï ‚ä¢œà
.
‚Ä¢ Existential quantiÔ¨Åer: Given the other rules, the bidirectional existential quantiÔ¨Åer rule
is equivalent to the ‚àÉ-introduction and ‚àÉ-elimination rules [Jac99, Lemma 4.1.8]
Œì | t : A
Œì | œï ‚ä¢œà[t/x]
Œì | œï ‚ä¢‚àÉx : A.œà
Œì | œï ‚ä¢‚àÉx : A.œà
Œì, x : A | œà ‚ä¢œá
Œì | œï ‚ä¢œá
.
58

‚Ä¢ Frobenius: The so-called ‚ÄúFrobenius axiom,‚Äù linking conjunction and existential quan-
tiÔ¨Åcation, is superÔ¨Çuous in full Ô¨Årst-order logic with implication but is not deducible
from the other rules of regular logic [Joh02, p. 831]. The converse rule is deducible
[Joh02, p. 832]. The omission of the Frobenius rule in some standard texts on regular
logic, such as [Oos95] and [But98], is apparently an error.
DeÔ¨Ånition. A regular theory (with respect to a Ô¨Åxed signature) is deÔ¨Åned by a set of sequents
in the signature, not necessarily Ô¨Ånite, called the axioms of theory. Under a regular theory
T, a formula œï entails œà, written Œì | œï ‚ä¢T œà, if the sequent Œì | œï ‚ä¢œà is deducible from the
axioms of T using the inference rules of regular logic (Figure 2). In this case we say that the
sequent Œì | œï ‚ä¢œà is an entailment or theorem of T.
We now begin to establish the correspondence between bicategories of relations and regular
logic by constructing the classifying category of a regular theory.
DeÔ¨Ånition. The classifying category of a regular theory T, denoted Cl(T), is the bicategory
of relations deÔ¨Åned as follows. Its objects are Ô¨Ånite lists of basic types A : (A1, . . . , An).
Given a context Œì = x : A, we also write [Œì] := A. Its morphisms A ‚ÜíB are equivalence
classes of formulas in context,
[x : A; y : B | œï],
where the equivalence relation ‚àºis deÔ¨Åned by
(x : A, y : B | œï) ‚àº(x‚Ä≤ : A, y‚Ä≤ : B | œï‚Ä≤)
iÔ¨Ä
x : A, y : B | œï ‚ä£‚ä¢T œï‚Ä≤[x/x‚Ä≤, y/y‚Ä≤].
In other words, the morphisms of Cl(T) are formulas in context up to Œ±-equivalence and
logical equivalence under T. Here ‚ä£‚ä¢T is shorthand for ‚ä£T and ‚ä¢T, and the semicolon in a
context (Œì; Œì‚Ä≤) is an extralogical marker that partitions the context into the domain [Œì] and
codomain [Œì‚Ä≤] of the morphism [Œì; Œì‚Ä≤ | œÜ]. The 2-morphisms of Cl(T) are the entailments of T:
[Œì; Œì‚Ä≤ | œï] =‚áí[Œì; Œì‚Ä≤ | œà]
iÔ¨Ä
Œì, Œì‚Ä≤ | œï ‚ä¢T œà.
We now deÔ¨Åne the requisite structures to make the classifying category into a bicategory of
relations. Composition of morphisms is given by
[x : A; y : B | œï] ¬∑ [y : B; z : C | œà] := [x : A; z : C | ‚àÉy : B.œï ‚àßœà],
and the identity morphisms are
1A := [x : A; x‚Ä≤ : A | x = x‚Ä≤].
The monoidal product is deÔ¨Åned on objects by A  B := (A, B) and on morphisms by
[Œì; ‚àÜ| œï]  [Œì‚Ä≤; ‚àÜ‚Ä≤ | œà] := [Œì, Œì‚Ä≤; ‚àÜ, ‚àÜ‚Ä≤ | œï ‚àßœà].
The monoidal unit is the empty list I := (). The braidings are
œÉA,B := [x : A, y : B; y‚Ä≤ : B, x‚Ä≤ : A | (x = x‚Ä≤) ‚àß(y = y‚Ä≤)].
Finally, the diagonals are
‚àÜA := [x : A; x‚Ä≤ : A, x‚Ä≤‚Ä≤ : A | (x = x‚Ä≤) ‚àß(x = x‚Ä≤‚Ä≤)]
‚ô¶A := [x : A | ‚ä§].
59

Lemma. The classifying category Cl(T) of a regular theory T is a bicategory of relations.
Proof. We must check that every axiom of a bicategory of relations can be deduced from the
inference rules of regular logic. The proofs are tedious but mechanical; we sketch a few to
illustrate what is involved and leave the rest to the reader.
First, we show that Cl(T) is a category. To prove that composition is associative, we must
show that the two formulas
x : A; w : D | ‚àÉy : B.(œï ‚àß‚àÉz : C.(œà ‚àßœá))
x : A; w : D | ‚àÉz : C.(‚àÉy : B.(œï ‚àßœà) ‚àßœá)
are equivalent in regular logic. In fact, both formulas are equivalent to
x : A; w : D | ‚àÉy : B.‚àÉz : C.(œï ‚àßœà ‚àßœá).
The derivation relies crucially on the Frobenius rule. We omit the details and the proof of
the identity axiom of a category.
Next, we prove that Cl(T) is a locally posetal 2-category. It is obvious that Cl(T) is locally
posetal. The vertical composition axiom is immediate from the cut rule. To prove the
horizontal composition axiom, suppose we have two entailments
x : A, y : B | œï ‚ä¢Œ∏
and
y : B, z : C | œà ‚ä¢œá.
By the conjunction and weakening rules,
x : A, y : B, z : C | œï ‚àßœà ‚ä¢Œ∏ ‚àßœá.
Using the ‚àÉ-introduction rule and then the bidirectional ‚àÉ-rule, we obtain
x : A, z : C | ‚àÉy : B.(œï ‚àßœà) ‚ä¢‚àÉy : B.(Œ∏ ‚àßœá),
proving the validity of horizontal composition.
The axiom on lax comonoid homomorphisms amounts to two easily proved entailments,
namely
x : A; y‚Ä≤ : B, y‚Ä≤‚Ä≤ : B | ‚àÉy : B.(œï ‚àß(y = y‚Ä≤) ‚àß(y = y‚Ä≤‚Ä≤)) ‚ä¢œï[y‚Ä≤/y] ‚àßœï[y‚Ä≤‚Ä≤/y]
and
x : A | ‚àÉy : B.œï ‚ä¢‚ä§.
Finally, we mention that the adjoints of ‚àÜA and ‚ô¶A exist and are equal to
‚àáA := [x‚Ä≤ : A, x‚Ä≤‚Ä≤ : A; x : A | (x‚Ä≤ = x) ‚àß(x‚Ä≤‚Ä≤ = x)]
and
‚ñ°A := [; x : A | ‚ä§].
Next, we construct the internal language of a bicategory of relations. A preliminary deÔ¨Ånition
is:
60

DeÔ¨Ånition. An interpretation or model of a signature in a bicategory of relations B is
speciÔ¨Åed by
‚Ä¢ for every basic type A, an object JAK of B;
‚Ä¢ for every relation symbol R : A, a morphism JRK : JAK ‚ÜíI of B, where we deÔ¨Åne
JAK := JA1K  ¬∑ ¬∑ ¬∑  JAnK.
If Œì = x : A is a context, we also write JŒìK := JAK.
An interpretation of a signature extends to the full regular language in that signature. By
induction on the formation rules of regular logic (Figure 1), we assign to each formula in
context Œì, Œì‚Ä≤ | œï a morphism JŒì; Œì‚Ä≤ | œïK : JŒìK ‚ÜíJŒì‚Ä≤K of B. In interpreting a rule, we allow
ourselves to order the context variables and place the context semicolon however is most
convenient, with the understanding that any other arrangement can be achieved by a suitable
braiding and bending of wires. This Ô¨Çexibility greatly simpliÔ¨Åes the notation.
‚Ä¢ Relation symbol: Given a relation symbol R : A,
Jx : A, Œì | R(x)K := JRK  ‚ô¶JŒìK.
‚Ä¢ Equality: There are two cases: when the variables are distinct, set
JŒì, x : A; y : A | x = yK := ‚ô¶JŒìK  1JAK;
when the variables are equal, set
JŒì | x = xK := ‚ô¶JŒìK.
‚Ä¢ Weakening: Given a morphism JŒì | œïK : JŒìK ‚ÜíI,
JŒì, x : A | œïK := JŒì | œïK  ‚ô¶JAK.
‚Ä¢ Truth: JŒì; Œì‚Ä≤ | ‚ä§K := ‚ä§JŒìK,JŒì‚Ä≤K = ‚ô¶JŒìK‚ñ°JŒì‚Ä≤K.
‚Ä¢ Conjunction: Given morphisms JŒì; Œì‚Ä≤ | œïK : JŒìK ‚ÜíJŒì‚Ä≤K and JŒì; Œì‚Ä≤ | œàK : JŒìK ‚ÜíJŒì‚Ä≤K,
JŒì; Œì‚Ä≤ | œï ‚àßœàK := ‚àÜJŒìK ¬∑ (JŒì; Œì‚Ä≤ | œïK  JŒì; Œì‚Ä≤ | œàK) ¬∑ ‚àáJŒì‚Ä≤K.
‚Ä¢ Existential quantiÔ¨Åer: Given a morphism JŒì; x : A | œïK : JŒìK ‚ÜíJAK,
JŒì | ‚àÉx : A.œïK := JŒì; x : A | œïK ¬∑ ‚ô¶JAK.
DeÔ¨Ånition. An interpretation J¬∑K of the signature of a regular theory T in a bicategory of
relations B is an interpretation or model of T in B if it satisÔ¨Åes all the axioms of T, i.e, for
every axiom
Œì | œï ‚ä¢œà
of
T,
there is a 2-morphism
JŒì | œïK =‚áíJŒì | œàK
in
B.
The previous lemma can be interpreted as a completeness theorem, stating that the inference
rules of regular logic are suÔ¨Écient to prove every axiom of a bicategory of relations. The next
lemma is a soundness theorem: it says that every inference rule of regular logic is valid in an
arbitrary bicategory of relations.
61

Lemma. Let J¬∑K be an interpretation of a regular theory T in a bicategory of relations B.
For every theorem
Œì | œï ‚ä¢T œà
of
T,
there is a 2-morphism
JŒì | œïK =‚áíJŒì | œàK
in
B.
Proof. The proof is by induction on the derivation of a theorem of T. By the deÔ¨Ånition of
an interpretation, every axiom of T holds in B. Therefore, it suÔ¨Éces to show that every
inference rule of regular logic (Figure 2) is valid in B. We sketch these proofs below.
‚Ä¢ Identity: Existence of identity 2-morphism.
‚Ä¢ Cut: Vertical composition of 2-morphisms.
‚Ä¢ Substitution: Omitted.
‚Ä¢ Equality: Omitted.
‚Ä¢ Truth: By the lax comonoid homomorphism axiom,
JŒì | œïK = JŒì | œïK ¬∑ ‚ô¶I =‚áí‚ô¶JŒìK = JŒì | ‚ä§K .
‚Ä¢ Conjunction: If JŒì; Œì‚Ä≤ | œïK ‚áíJŒì; Œì‚Ä≤ | œàK and JŒì; Œì‚Ä≤ | œïK ‚áíJŒì; Œì‚Ä≤ | œáK, then
JŒì; Œì‚Ä≤ | œïK = ‚àÜJŒìK(JŒì; Œì‚Ä≤ | œïK  JŒì; Œì‚Ä≤ | œïK)‚àáJŒì‚Ä≤K
‚áí‚àÜJŒìK(JŒì; Œì‚Ä≤ | œàK  JŒì; Œì‚Ä≤ | œáK)‚àáJŒì‚Ä≤K
= JŒì; Œì‚Ä≤ | œà ‚àßœáK .
That proves the Ô¨Årst conjunction rule. For the second, calculate
JŒì; Œì‚Ä≤ | œï ‚àßœàK = ‚àÜJŒìK(JŒì; Œì‚Ä≤ | œïK  JŒì; Œì‚Ä≤ | œàK)‚àáJŒì‚Ä≤K
‚áí‚àÜJŒìK(JŒì; Œì‚Ä≤ | œïK  ‚ô¶JŒìK‚ñ°JŒì‚Ä≤K)‚àáJŒì‚Ä≤K
= JŒì; Œì‚Ä≤ | œïK .
The proof of the third rule is similar.
‚Ä¢ Existential quantiÔ¨Åer: Fix formulas JŒì; x : A | œïK : JŒìK ‚ÜíJAK and JŒì | œàK : JŒìK ‚ÜíI.
By the weakening formation rule, JŒì; x : A | œàK = JŒì | œàK¬∑‚ñ°JAK. If there is an entailment
JŒì; x : A | œïK ‚áíJŒì; x : A | œàK, then
JŒì | ‚àÉx : A.œïK = JŒì; x : A | œïK ‚ô¶JAK
‚áíJŒì; x : A | œàK ‚ô¶JAK
= JŒì | œàK ‚ñ°JAK‚ô¶JAK
= JŒì | œàK .
The proof of the converse rule is similar.
62

‚Ä¢ Frobenius: Given formulas JŒì | œïK : JŒìK ‚ÜíI and JŒì, x : A | œàK : JŒìK ‚ÜíJAK, compute
JŒì | œï ‚àß(‚àÉx : A.œà)K = ‚àÜJŒìK(JŒì | œïK  JŒì | ‚àÉx : A.œàK)
= ‚àÜJŒìK(JŒì | œïK  JŒì, x : A | œàK ‚ô¶JAK)
= ‚àÜJŒìK(JŒì | œïK ‚ñ°JAK  JŒì, x : A | œàK)‚àáJAK‚ô¶JAK
= ‚àÜJŒìK(JŒì, x : A | œïK  JŒì, x : A | œàK)‚àáJAK‚ô¶JAK
= JŒì; x : A | œï ‚àßœàK ‚ô¶JAK
= JŒì | ‚àÉx : A.(œï ‚àßœà)K .
DeÔ¨Ånition. The internal language of a small bicategory of relations B is the regular theory
Lang(B) deÔ¨Åned as follows. Its signature consists of
‚Ä¢ a basic type A for every object A of B, and
‚Ä¢ a relation symbol R : (A1, . . . , An) for every morphism R : A1  ¬∑ ¬∑ ¬∑  An ‚ÜíI of B.
A sequent Œì | œï ‚ä¢œà is an axiom of Lang(B) if and only if JŒì | œïK ‚áíJŒì | œàK in B, where J¬∑K is
the obvious interpretation of the signature of Lang(B) in B.
By the lemma, Lang(B) is interpretable in B and the theorems of Lang(B) are exactly the
2-morphism of B.
Remark. In general, a single morphism of B gives rise to many relation symbols of Lang(B),
e.g., if R : A ‚ÜíI is morphism and A = A1  A2, then there are relation symbols R : (A) and
R : (A1, A2).
We have now developed the machinery to state and prove the main theorem of Section 8.
Theorem. For every small bicategory of relations B, there is an equivalence of categories
Cl(Lang(B)) ‚âÉB
in
BiRel.
Proof. To prove the equivalence, it suÔ¨Éces to construct a structure-preserving functor F :
Cl(Lang(B)) ‚ÜíB that is full, faithful, and essentially surjective on objects [Rie16, Theorem
1.5.9]. DeÔ¨Åne the functor F on objects by
F(A) := JAK = JA1K  ¬∑ ¬∑ ¬∑  JAnK ,
where A = (A1, . . . , An) and each Ai is a basic type of Lang(B). If Œì = x : A is a context,
we also write F(Œì) := JŒìK. DeÔ¨Åne F on morphisms [Œì; Œì‚Ä≤ | œï] : [Œì] ‚Üí[Œì‚Ä≤] by
F([Œì; Œì‚Ä≤ | œï]) := JŒì; Œì‚Ä≤ | œïK : F(Œì) ‚ÜíF(Œì‚Ä≤).
By the construction of the classifying category and the internal language, we have the
fundamental equivalence
[Œì; Œì‚Ä≤ | œï] ‚áí[Œì; Œì‚Ä≤ | œà] in Cl(Lang(B))
iÔ¨Ä
Œì, Œì‚Ä≤ | œï ‚ä¢Lang(B) œà
iÔ¨Ä
JŒì; Œì‚Ä≤ | œïK ‚áíJŒì; Œì‚Ä≤ | œàK in B.
63

In particular, the functor F is well-deÔ¨Åned and faithful. It is full because if R : A ‚ÜíB
is a morphism of B, then there exists a relation symbol R : (A, B) of Lang(B) such that
F(Jx : A; y : B | R(x, y)K) = R. Clearly, F is (essentially) surjective on objects.
It remains to prove that F is a structure-preserving functor. The fundamental equivalence says
that F preserves 2-morphisms. We must show that F also preserves composition, identities,
monoidal products, and all the other structures of a bicategory of relations. We prove that
F preserves composition and products of morphisms and omit the other straightforward
veriÔ¨Åcations. First, given morphisms [x : A; y : B | œï] and [y : B; z : C | œà] of Cl(Lang(B)),
calculate
F([x : A; y : B | œï] ¬∑ [y : B; z : C | œà])
= F([x : A; z : C | ‚àÉy : B.(œï ‚àßœà)])
=
q
x : A; z : C | ‚àÉy : B.(œï ‚àßœà)
y
= (1JAK  Œ∑JCK)
q
x : A, z : C; y : B | œï ‚àßœà
y
‚ô¶JBK
= (1JAK  Œ∑JCK)(
q
x : A; y : B | œï
y

q
z : C; y : B | œà
y
)‚àáJBK‚ô¶JBK
= (1JAK  Œ∑JCK)(
q
x : A; y : B | œï
y

q
y : B; z : C | œà
y‚Ä†)œµJBK
=
q
x : A; y : B | œï
y
¬∑
q
y : B; z : C | œà
y
= F([x : A; y : B | œï]) ¬∑ F([y : B; z : C | œà]).
Given morphisms [x : A; y : B | œï] and [z : C; w : D | œà], calculate
F([x : A; y : B | œï]  [z : C; w : D | œà])
= F([x : A, z : C; y : B, w : D | œï ‚àßœà])
=
q
x : A, z : C; y : B, w : D | œï ‚àßœà]
y
= ‚àÜ(A,C)(
q
x : A, z : C; y : B, w : D | œï
y

q
x : A, z : C; y : B, w : D | œà
y
)‚àá(B,D)
= (‚àÜA  ‚àÜC)(1A  œÉA,C  1C)
(
q
x : A; y : B | œï
y
 ‚ô¶C‚ñ°D  ‚ô¶A‚ñ°B  Jz : C; w : D | œàK)
(1B  œÉD,B  1D)(‚àáB  ‚àáD)
= (‚àÜA  ‚àÜC)(
q
x : A; y : B | œï
y
 ‚ô¶A‚ñ°B  ‚ô¶C‚ñ°D  Jz : C; w : D | œàK)(‚àáB  ‚àáD)
=
q
x : A; y : B | œï
y
 Jz : C; w : D | œàK
= F([x : A; y : B | œï])  F([z : C; w : D | œà]).
The Ô¨Årst calculation is obscured by the wire bending needed to unpack the deÔ¨Ånitions, but
becomes transparent when rendered as a string diagram.
Remark. The inverse functor G : B ‚ÜíCl(Lang(B)) in the equivalence is deÔ¨Åned on objects by
G(A) := A and on morphisms R : A ‚ÜíB by G(R) := [x : A; y : B | R(x, y)]. As an alternate
proof, it is possible to explicitly construct the natural isomorphisms F ¬∑ G ‚àº= 1Cl(Lang(B)) and
G ¬∑ F ‚àº= 1B.
64

B. Coherent logic and distributive bicategories of relations
In this appendix we prove the main theorem of Section 9.3, establishing a correspondence
between coherent logic with product and sum types and distributive bicategories of relations.
We present the logical system carefully because we cannot Ô¨Ånd a comparable logic in the
literature. However, where the proof overlaps with Appendix A, we provide less detail.
We Ô¨Årst deÔ¨Åne a formal system for coherent logic with product and sum types. For the sake
of brevity, we refer to this system simply as ‚Äúcoherent logic.‚Äù We maintain the syntactic
conventions of Appendix A, including the vector notation. Our proof system is an amalgama-
tion of the usual proof systems for typed lambda calculus [Jac99; FDB06] and coherent logic
[Joh02] but with several important diÔ¨Äerences that we shall point out.
DeÔ¨Ånition (cf. [Jac95; Jac99]). A distributive signature consists of
‚Ä¢ a set of basic types, which generates a set of types according to the BNF grammar
A, B ::= C | A √ó B | 1 | A + B | 0,
where C ranges over basic types;
‚Ä¢ a set of function symbols f, g, h, . . . , each with Ô¨Åxed domain type A and codomain type
B, written f : A ‚ÜíB;
‚Ä¢ a set of relation symbols R, S, . . . , each with Ô¨Åxed domain types A and B, written
R : (A, B).
Variables and contexts are deÔ¨Åned as in Appendix A. With respect to a Ô¨Åxed distributive
signature, a term in context is an expression of form Œì | t : A, as deÔ¨Åned inductively by the
formation rules in Figure 3. Likewise, a formula in context is an expression Œì | œï deÔ¨Åned by
the formation rules in Figure 4.
A sequent is an expression Œì | œï ‚ä¢œà, where Œì | œï and Œì | œà are both formulas in context.
The sequent Œì ‚ä¢œï is shorthand for Œì | ‚ä§‚ä¢œï. The inference rules for sequents are listed in
Figure 5. As before, we omit the context when it is the same in the premises and conclusion
of a rule.
Remark. We comment on the inference rules that diÔ¨Äer from both Ô¨Årst-order logic and
equational type theory. Most importantly, product types are treated exactly as in type theory
but sum types have a stronger axiomatization.
‚Ä¢ Distributivity: Like the Frobenius rule, the distributivity axiom linking conjunction
and disjunction is superÔ¨Çuous in full Ô¨Årst-order logic but is not deducible from the
other rules of coherent logic [Joh02, p. 831]. The converse of the distributivity axiom is
deducible.
‚Ä¢ Case: Our case rules cannot be expressed in simple type theory. Instead, type theory
postulates
‚ä¢Œ¥ (t, x : A.s[Œπ1(x)/z], y : B.s[Œπ2(y)/z]) = s[t/z].
Given the other axioms, this rule can be deduced from our Ô¨Årst case rule but not
conversely.
65

Œì, x : A, Œì‚Ä≤ | x : A
(variable)
Œì | t : A
Œì | f(t) : B
(function symbol f : A ‚ÜíB)
Œì | t : A
Œì | s : B
Œì | ‚ü®t, s‚ü©: A √ó B
(pair)
Œì | t : A √ó B
Œì | œÄ1(t) : A
Œì | t : A √ó B
Œì | œÄ2(t) : B
(projection)
Œì | ‚àó: 1
(singleton)
Œì | t : A + B
Œì, x : A | r : C
Œì, y : B | s : C
Œì | Œ¥ (t, x : A.r, y : B.s) : C
(case)
Œì | t : A
Œì | Œπ1(t) : A + B
Œì | t : B
Œì | Œπ2(t) : A + B
(inclusion)
Figure 3: Formation rules for terms of coherent logic
Œì | t : A
Œì | s : B
Œì | R(t, s)
(relation symbol R : (A, B))
Œì | t : A
Œì | s : A
Œì | t = s
(equality)
Œì | œï
Œì, x : A | œï
(weakening)
Œì | ‚ä§
(truth)
Œì | ‚ä•
(falsity)
Œì | œï
Œì | œà
Œì | œï ‚àßœà
(conjunction)
Œì | œï
Œì | œà
Œì | œï ‚à®œà
(disjunction)
Œì, x : A | œï
Œì | ‚àÉx : A.œï
(existential quantiÔ¨Åer)
Figure 4: Formation rules for formulas of coherent logic
66

‚Ä¢ Empty: In simple type theory, the empty type is axiomatized by an empty function
‚ä•A : A obeying the formation and inference rules
t : 0
‚ä•A(t) : A
t : 0
s : A
‚ä¢‚ä•A(t) = s
.
In particular, one can derive Œì, x : 0 | r = s for any terms r, s. We strengthen that result
to Œì, x : 0 | ‚ä•and discard the empty function ‚ä•A.
A coherent theory is deÔ¨Åned analogously to a regular theory.
DeÔ¨Ånition. The classifying category of a coherent theory T, denoted Cl(T), is the distributive
bicategory of relations whose objects are the types of T (basic or compound); whose morphisms
A ‚ÜíB are equivalence classes of formulas in context [x : A, y : B | œï], where equivalence is
up to Œ±-equivalence and provable logical equivalence under T; and whose 2-morphisms are
the theorems of T.
The structures of a distributive bicategory of relations are deÔ¨Åned as follows.
‚Ä¢ Category: Composition is deÔ¨Åned by
[x : A, y : B | œï] ¬∑ [y : B, z : C | œà] := [x : A, z : C | ‚àÉy : B.(œï ‚àßœà)]
and the identity morphisms are 1A := [x : A, x‚Ä≤ : A | x = x‚Ä≤].
‚Ä¢ Tensor: On objects, A  B := A √ó B and I := 1; on morphisms,
[x1 : A1,y1 : B1 | œï]  [x2 : A2, y2 : B2 | œà]
:= [x : A1 √ó A2, y : B1 √ó B2 |
‚àÉx1 : A1.‚àÉy1 : B1.(œï ‚àßœÄ1x = x1 ‚àßœÄ1y = y1)‚àß
‚àÉx2 : A2.‚àÉy2 : B2.(œà ‚àßœÄ2x = x2 ‚àßœÄ2y = y2)]
= [x : A1 √ó A2, y : B1 √ó B2 | œï[œÄ1x/x1, œÄ1y/y1] ‚àßœà[œÄ2x/x2, œÄ2y/y2]].
The braidings are
œÉA,B := [x : A √ó B, y : B √ó A | (œÄ1x = œÄ2y) ‚àß(œÄ2x = œÄ1y)].
‚Ä¢ Cotensor: On objects, A  B := A + B and O := 0; on morphisms,
[x1 : A1,y1 : B1 | œï]  [x2 : A2, y2 : B2 | œà]
:= [x : A1 + A2, y : B1 + B2 |
‚àÉx1 : A1.‚àÉy1 : B1.(œï ‚àßŒπ1x1 = x ‚àßŒπ1y1 = y)‚à®
‚àÉx2 : A2.‚àÉy2 : B2.(œà ‚àßŒπ2x2 = x ‚àßŒπ2y2 = y)].
The braidings are
œÉA,B := [x : A + B, y : B + A |
‚àÉx‚Ä≤ : A.‚àÉy‚Ä≤ : B.((Œπ1x‚Ä≤ = x ‚àßŒπ2x‚Ä≤ = y) ‚à®(Œπ2y‚Ä≤ = x ‚àßŒπ1y‚Ä≤ = y))].
67

œï ‚ä¢œï
(identity)
œï ‚ä¢œá
œá ‚ä¢œà
œï ‚ä¢œà
(cut)
x : A | œï ‚ä¢œà
Œì | t : A
Œì | œï[t/x] ‚ä¢œà[t/x]
(substitution)
‚ä¢x = x
(x = y) ‚àßœï ‚ä¢œï[y/x]
x = y ‚ä¢t = t[y/x]
(equality)
‚ä¢œÄ1(‚ü®t, s‚ü©) = t
‚ä¢œÄ2(‚ü®t, s‚ü©) = s
(projection)
‚ä¢‚ü®œÄ1(t), œÄ2(t)‚ü©= t
(pair)
‚ä¢Œ¥ (Œπ1(t), x : A.r, y : B.s) = r[t/x]
‚ä¢Œ¥ (Œπ2(t), x : A.r, y : B.s) = s[t/y]
(inclusion)
Œì | ‚ä¢(‚àÉx : A.Œπ1(x) = t) ‚à®(‚àÉx : B.Œπ2(x) = t)
Œì | (‚àÉx : A.Œπ1(x) = t) ‚àß(‚àÉx : B.Œπ2(x) = t) ‚ä¢‚ä•
[x /‚ààŒì]
(case)
Œì | t : 1
Œì | ‚ä¢t = ‚àó
Œì, x : 0 | ‚ä¢‚ä•
(singleton & empty)
œï ‚ä¢‚ä§
‚ä•‚ä¢œï
(truth & falsity)
œï ‚ä¢œà
œï ‚ä¢œá
œï ‚ä¢œà ‚àßœá
œï ‚àßœà ‚ä¢œï
œï ‚àßœà ‚ä¢œà
(conjunction)
œï ‚ä¢œá
œà ‚ä¢œá
œï ‚à®œà ‚ä¢œá
œï ‚ä¢œï ‚à®œà
œà ‚ä¢œï ‚à®œà
(disjunction)
œï ‚àß(œà ‚à®œá) ‚ä¢(œï ‚àßœà) ‚à®(œï ‚àßœá)
(distributivity)
Œì, x : A | œï ‚ä¢œà
Œì | (‚àÉx : A.œï) ‚ä¢œà
(existential quantiÔ¨Åer)
Œì | œï ‚àß(‚àÉx : A.œà) ‚ä¢‚àÉx : A.(œï ‚àßœà)
[x /‚ààŒì]
(Frobenius)
Figure 5: Inference rules for coherent logic
68

‚Ä¢ Diagonals and codiagonals:
‚àÜA := [x : A, y : A √ó A | ‚ü®x, x‚ü©= y]
‚ô¶A := [x : A, y : 1 | ‚ä§]
‚ñºA := [x : A + A, y : A | Œ¥ (x, x1 : A.x1, x2 : A.x2) = y]
‚ñ†A := [x : 0, y : A | ‚ä•].
Lemma. The classifying category Cl(T) of a coherent theory T is a distributive bicategory of
relations.
The proof of the lemma is monstrously long but similar in many respects to the completeness
proof in Appendix A. To exemplify the new considerations posed by product and sum types,
we prove a diÔ¨Äerent, ‚Äúobvious‚Äù fact about local unions in the classifying category. We expect
this will exhaust the reader‚Äôs appetite for such calculations. We then proceed directly to the
construction of the internal language of a distributive bicategory of relations.
Proposition. Local unions in the classifying category of a coherent theory are given by logical
disjunction:
[x : A, y : B | œï] ‚à™[x : A, y : B | œà] = [x : A, y : B | œï ‚à®œà].
Proof. In an abuse of notation, we write [œï] := [x : A, y : B | œï] and [œà] := [x : A, y : B | œà].
By deÔ¨Ånition,
[œï] ‚à™[œà] = ‚ñ≤A([œï]  [œà])‚ñºB.
First, use the inclusion rules and the Ô¨Årst case rule to show that
‚ñ≤A = [x : A, y : A + A | (Œπ1x = y) ‚à®(Œπ2x = y)]
‚ñºB = [x : B + B, y : B | (x = Œπ1y) ‚à®(x = Œπ2y)].
Therefore,
([œï]  [œà])‚ñºB = [x‚Ä≤ : A + A, y : B | ‚àÉy‚Ä≤ : B + B.(
((‚àÉx : A.‚àÉÀúy : B.(œï[Àúy/y] ‚àßŒπ1x = x‚Ä≤ ‚àßŒπ1Àúy = y‚Ä≤))‚à®
(‚àÉx : A.‚àÉÀúy : B.(œà[Àúy/y] ‚àßŒπ2x = x‚Ä≤ ‚àßŒπ2Àúy = y‚Ä≤)))
‚àß(y‚Ä≤ = Œπ1y ‚à®y‚Ä≤ = Œπ2y))].
Use the Frobenius rule and the distributivity of existential quantiÔ¨Åers over disjunctions to put
the formula into prenex normal form, then distribute the conjunction over the disjunctions
to put the body into disjunctive normal form:
([œï]  [œà])‚ñºB = [x‚Ä≤ : A + A, y : B | ‚àÉx : A.‚àÉÀúy : B.‚àÉy‚Ä≤ : B + B.(
(œï[Àúy/y] ‚àßŒπ1x = x‚Ä≤ ‚àßŒπ1Àúy = y‚Ä≤ ‚àßŒπ1y = y‚Ä≤)‚à®
(œï[Àúy/y] ‚àßŒπ1x = x‚Ä≤ ‚àßŒπ1Àúy = y‚Ä≤ ‚àßŒπ2y = y‚Ä≤)‚à®
(œà[Àúy/y] ‚àßŒπ2x = x‚Ä≤ ‚àßŒπ2Àúy = y‚Ä≤ ‚àßŒπ1y = y‚Ä≤)‚à®
(œà[Àúy/y] ‚àßŒπ2x = x‚Ä≤ ‚àßŒπ2Àúy = y‚Ä≤ ‚àßŒπ2y = y‚Ä≤))].
69

The Ô¨Årst and last disjuncts are handled by the injectivity of the inclusions (deducible from
the inclusion rules), e.g.,
Œπ1Àúy = y‚Ä≤ ‚àßŒπ1y = y‚Ä≤ ‚ä¢Œπ1Àúy = Œπ1y ‚ä¢Àúy = y.
Eliminate the two cross terms using the second case rule, e.g.,
Œπ1Àúy = y‚Ä≤ ‚àßŒπ2y = y‚Ä≤ ‚ä¢Œπ1Àúy = Œπ2y ‚ä¢‚ä•.
Upon simpliÔ¨Åcation the result is
([œï]  [œà])‚ñºB = [x‚Ä≤ : A + A, y : B | ‚àÉx : A.((œï ‚àßŒπ1x = x‚Ä≤) ‚à®(œà ‚àßŒπ2x = x‚Ä≤))].
The second half of the calculation is very similar and yields
[œï] ‚à™[œà] = ‚ñ≤A([œï]  [œà])‚ñºB = [x : A, y : B | œï ‚à®œà].
DeÔ¨Ånition. An interpretation or model of a distributive signature in a distributive bicategory
of relations B is speciÔ¨Åed by
‚Ä¢ for every basic type C, an object JCK of B;
‚Ä¢ for every function symbol f : A ‚ÜíB, a morphism JfK : JAK ‚ÜíJBK of Map(B);
‚Ä¢ for every relation symbol R : (A, B), a morphism JRK : JAK ‚ÜíJBK of B.
The extension of the interpretation to any type of the signature is implicit in the deÔ¨Ånition:
JA √ó BK = JAK  JBK ,
J1K = I,
JA + BK = JAK  JBK ,
J0K = O.
We also maintain the convention that Jx : AK := JAK := JA1K  ¬∑ ¬∑ ¬∑  JAnK.
An interpretation of a distributive signature extends to the full coherent language in that
signature by induction on the term and formula formation rules. Each term in context Œì|t : A
is interpreted as a morphism JŒì | tK : JŒìK ‚ÜíJAK of Map(B) as follows.
‚Ä¢ Variable: JŒì, x : A, Œì‚Ä≤ | x : AK := ‚ô¶JŒìK  1JAK  ‚ô¶JŒì‚Ä≤K.
‚Ä¢ Function symbol: Given a function symbol f : A ‚ÜíB and a map JŒì | t : AK,
JŒì | f(t) : BK := JŒì | t : AK ¬∑ JfK .
‚Ä¢ Pair: Given maps JŒì | t : AK and JŒì | s : BK,
JŒì | ‚ü®t, s‚ü©: A √ó BK := ‚àÜJŒìK(JŒì | t : AK  JŒì | s : BK).
‚Ä¢ Projection: Given a map JŒì | t : A √ó BK,
JŒì | œÄ1(t) : AK := JŒì | t : A √ó BK (1JAK  ‚ô¶JBK)
JŒì | œÄ2(t) : BK := JŒì | t : A √ó BK (‚ô¶JAK  1JBK).
‚Ä¢ Singleton: JŒì | ‚àó: IK := ‚ô¶JŒìK.
70

‚Ä¢ Case: Given maps JŒì | t : A + BK, JŒì, x : A | r : CK, and JŒì, y : B | s : CK, deÔ¨Åne JŒì | Œ¥ (t, x : A.r, y : B.
to be
‚àÜJŒìK ¬∑ (1JŒìK  JŒì | t : A + BK) ¬∑ dJŒìK,JAK,JBK ¬∑ (JŒì, x : A | rK  JŒì, y : B | sK) ¬∑ ‚ñºJCK,
where dX,Y,Z : X  (Y  Z) ‚Üí(X  Y )  (X  Z) is the family of distributivity
isomorphisms in B.
‚Ä¢ Inclusion: Given maps JŒì | t : AK and JŒì | s : BK,
JŒì | Œπ1(t) : A + BK := JŒì | t : AK  ‚ñ†B
JŒì | Œπ2(s) : A + BK := ‚ñ†A  JŒì | s : BK .
Each formula in context Œì; Œì‚Ä≤ | œï is interpreted as a morphism JŒì; Œì‚Ä≤ | œïK : JŒìK ‚ÜíJŒì‚Ä≤K of B as
follows.
‚Ä¢ Relation symbol: Given a relation symbol R : (A, B) and two maps JŒì | t : AK and
JŒì | s : BK, deÔ¨Åne
JŒì | R(t, s)K := ‚àÜJŒìK(JŒì | t : AK JRK  JŒì | s : BK)œµJBK.
where, as usual, œµJBK = ‚àáJBK‚ô¶JBK.
‚Ä¢ Equality: Given maps JŒì | t : AK and JŒì | s : AK,
JŒì | t = sK := ‚àÜJŒìK(JŒì | t : AK  JŒì | s : AK)œµJAK
‚Ä¢ Falsity: JŒì; Œì‚Ä≤ | ‚ä•K := ‚ä•JŒìK,JŒì‚Ä≤K = ‚ô¶JŒìK‚ñ†JŒì‚Ä≤K.
‚Ä¢ Disjunction: Given morphisms JŒì; Œì‚Ä≤ | œïK : JŒìK ‚ÜíJŒì‚Ä≤K and JŒì; Œì‚Ä≤ | œàK : JŒìK ‚ÜíJŒì‚Ä≤K,
JŒì; Œì‚Ä≤ | œï ‚à®œàK := ‚ñ≤JŒìK ¬∑ (JŒì; Œì‚Ä≤ | œïK  JŒì; Œì‚Ä≤ | œàK) ¬∑ ‚ñºJŒì‚Ä≤K.
The other formation rules‚Äîweakening, truth, conjunction, and existential quantiÔ¨Åer‚Äîare
interpreted exactly as in Appendix A.
An interpretation or model of a coherent theory in a distributive bicategory of relations is
deÔ¨Åned analogously to an interpretation of a regular theory in a bicategory of relations. There
is also a corresponding soundness theorem.
Lemma. Let J¬∑K be an interpretation of a coherent theory T in a distributive bicategory of
relations B. For every theorem
Œì | œï ‚ä¢T œà
of
T,
there is a 2-morphism
JŒì | œïK =‚áíJŒì | œàK
in
B.
Proof. As before, we must show that every inference rule of coherent logic (Figure 5) is valid
in B. We sketch the proofs for the rules that have not already been treated in Appendix A.
71

‚Ä¢ Projection: The Ô¨Årst projection axiom ‚ä¢œÄ1‚ü®t, s‚ü©= t holds because
‚àÜX(f  g)œÄY,Z = ‚àÜX(f  g)(1Y  ‚ô¶Z) = ‚àÜX(f  g‚ô¶Z) = ‚àÜX(f  ‚ô¶X) = f
whenever f : X ‚ÜíY and g : X ‚ÜíZ are maps.
The second projection axiom
‚ä¢œÄ2‚ü®t, s‚ü©= s is proved similarly.
‚Ä¢ Pair: The pair axiom ‚ä¢‚ü®œÄ1(t), œÄ2(t)‚ü©= t amounts to the equality
‚àÜXY (œÄX,Y  œÄ‚Ä≤
X,Y ) = (‚àÜX  ‚àÜY )(1X  œÉX,Y  1Y )(1X  ‚ô¶Y  ‚ô¶X  1Y )
= (‚àÜX  ‚àÜY )(1X  œÉX,Y ‚ô¶Y X  1Y )
= (‚àÜX  ‚àÜY )(1X  ‚ô¶X  ‚ô¶Y  1Y )
= 1X  1Y = 1XY .
‚Ä¢ Inclusion: The two inclusion axioms are dual to the two projection axioms, e.g.,
ŒπX,Y (f  g)‚ñºZ = f for any two morphisms f : X ‚ÜíZ and g : Y ‚ÜíZ (which need not
be maps).
‚Ä¢ Case: The Ô¨Årst case axiom ‚ä¢(‚àÉx : A.Œπ1x = t) ‚à®(‚àÉx : B.Œπ2x = t) amounts to
‚ñ°XY = ‚ñ≤I(‚ñ°XŒπX,Y  ‚ñ°Y Œπ‚Ä≤
X,Y )‚ñºXY .
By the dual of the pair axiom, (ŒπX,Y  Œπ‚Ä≤
X,Y )‚ñºXY = 1XY , it suÔ¨Éces to show that
‚ñ°XY = ‚ñ≤I(‚ñ°X  ‚ñ°Y ), or equivalently
‚ô¶XY = (‚ô¶X  ‚ô¶Y )‚ñºI =: [‚ô¶X, ‚ô¶Y ]
Because the inclusions are maps, we have ŒπX,Y ‚ô¶XY = ‚ô¶X and Œπ‚Ä≤
X,Y ‚ô¶XY = ‚ô¶Y , and
hence the last equation holds by the universal property of the coproduct. We omit the
proof of the second case axiom.
‚Ä¢ Singleton: The unit I of the tensor is terminal in Map(B).
‚Ä¢ Empty: For any objects X, Y of B, there is at most one morphism X  O ‚ÜíY , which
must therefore be ‚ä•XO,Y . A similar result holds, with essentially the same proof, in a
distributive category; we refer to [CLW93, Proposition 3.2].
‚Ä¢ Falsity: Dual to truth.
‚Ä¢ Disjunction: Dual to conjunction.
‚Ä¢ Distributivity: As mentioned in Section 9.2, the distributive law
R ‚à©(S ‚à™T) = (R ‚à©S) ‚à™(R ‚à©T)
holds in any distributive bicategory of relations.
The proof, which we omit, is a
calculation involving the canonical distributivity isomorphism.
DeÔ¨Ånition. The internal language of a small distributive bicategory of relations B is the
coherent theory Lang(B) deÔ¨Åned as follows. Its signature consists of
‚Ä¢ for every object A of B, a basic type A;
‚Ä¢ for every pair of types (A, B) and every morphism f : JAK ‚ÜíJBK of Map(B), a function
symbol f : A ‚ÜíB; and
72

‚Ä¢ for every pair of types (A, B) and every morphism R : JAK ‚ÜíJBK of B, a relation
symbol R : (A, B).
A sequent Œì | œï ‚ä¢œà is an axiom of Lang(B) if and only if JŒì | œïK ‚áíJŒì | œàK in B. Throughout
the deÔ¨Ånition, J¬∑K is the obvious interpretation of the signature of Lang(B) in the category B.
Remark. The expressivity of the internal language is not aÔ¨Äected by including function
symbols for the maps because every map is also associated with a relation symbol.
As in Appendix A, a single morphism of B can give rise to many function and relation
symbols of Lang(B). Moreover, despite replacing lists of types by compound types, it remains
the case that Lang(B) has ‚Äútoo many‚Äù types. For example, if A = A1  A2 is a product in B,
then both A and A1 √ó A2 are types in Lang(B). Although the types are isomorphic, they are
formally distinct. This discrepancy explains why the equivalence of categories in the theorem
below is not an isomorphism of categories.
Theorem. For every small distributive bicategory of relations B, there is an equivalence of
categories
Cl(Lang(B)) ‚âÉB
in
DistBiRel.
Proof. It suÔ¨Éces to construct a structure-preserving functor F : Cl(Lang(B)) ‚ÜíB that
is full, faithful, and essentially surjective on objects. DeÔ¨Åne the functor F on objects by
F(A) := JAK and on morphisms by
F([x : A; y : B | œï]) := Jx : A; y : B | œïK : F(A) ‚ÜíF(B).
The proof that F is well-deÔ¨Åned and has the requisite properties proceeds as in Appendix A.
We leave the details to the reader.
73

