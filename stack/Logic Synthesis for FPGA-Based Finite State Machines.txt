Studies in Systems, Decision and Control 38
Alexander Barkalov
Larysa Titarenko
Malgorzata Kolopienczyk
Kamil Mielcarek
Grzegorz Bazydlo
Logic Synthesis 
for FPGA-Based 
Finite State 
Machines

Studies in Systems, Decision and Control
Volume 38
Series editor
Janusz Kacprzyk, Polish Academy of Sciences, Warsaw, Poland
e-mail: kacprzyk@ibspan.waw.pl

About this Series
The series “Studies in Systems, Decision and Control” (SSDC) covers both new
developments and advances, as well as the state of the art, in the various areas of
broadly perceived systems, decision making and control- quickly, up to date and
with a high quality. The intent is to cover the theory, applications, and perspectives
on the state of the art and future developments relevant to systems, decision
making, control, complex processes and related areas, as embedded in the ﬁelds of
engineering, computer science, physics, economics, social and life sciences, as well
as the paradigms and methodologies behind them. The series contains monographs,
textbooks, lecture notes and edited volumes in systems, decision making and
control spanning the areas of Cyber-Physical Systems, Autonomous Systems,
Sensor Networks, Control Systems, Energy Systems, Automotive Systems,
Biological Systems, Vehicular Networking and Connected Vehicles, Aerospace
Systems, Automation, Manufacturing, Smart Grids, Nonlinear Systems, Power
Systems, Robotics, Social Systems, Economic Systems and other. Of particular
value to both the contributors and the readership are the short publication timeframe
and the world-wide distribution and exposure which enable both a wide and rapid
dissemination of research output.
More information about this series at http://www.springer.com/series/13304

Alexander Barkalov
• Larysa Titarenko
Malgorzata Kolopienczyk
Kamil Mielcarek
• Grzegorz Bazydlo
Logic Synthesis
for FPGA-Based
Finite State Machines
123

Alexander Barkalov
Institute of Informatics and Electronics
University of Zielona Góra
Zielona Góra
Poland
Larysa Titarenko
Institute of Informatics and Electronics
University of Zielona Góra
Zielona Góra
Poland
Malgorzata Kolopienczyk
Institute of Informatics and Electronics
University of Zielona Góra
Zielona Góra
Poland
Kamil Mielcarek
Institute of Informatics and Electronics
University of Zielona Góra
Zielona Góra
Poland
Grzegorz Bazydlo
Institute of Informatics and Electronics
University of Zielona Góra
Zielona Góra
Poland
ISSN 2198-4182
ISSN 2198-4190
(electronic)
Studies in Systems, Decision and Control
ISBN 978-3-319-24200-2
ISBN 978-3-319-24202-6
(eBook)
DOI 10.1007/978-3-319-24202-6
Library of Congress Control Number: 2015949406
Springer Cham Heidelberg New York Dordrecht London
© Springer International Publishing Switzerland 2016
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part
of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission
or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar
methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such names are exempt from
the relevant protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in this
book are believed to be true and accurate at the date of publication. Neither the publisher nor the
authors or the editors give a warranty, express or implied, with respect to the material contained herein or
for any errors or omissions that may have been made.
Printed on acid-free paper
Springer International Publishing AG Switzerland is part of Springer Science+Business Media
(www.springer.com)

Preface
The up-to-day state of the art in the computer science is characterized by three
major factors. The ﬁrst factor is a development of ultra complex VLSI such as
“system-on-programmable chips” having billions of transistors and hundreds of
millions of equivalent gates. The second factor is a development and widespreading
hardware description languages (HDL) such as VHDL and Verilog that permits to
capture a design with tremendous complexness. The third factor is an existence of
different computer-aided design (CAD) tools. It allows designing very complex
projects in the satisfactory time-to-market. These three factors affected signiﬁcantly
the modern process of hardware design. Now the hardware design is very similar to
the development of computer programs. An application of HDLs together with
CAD-tools allows concentrating the designer’s energy on the basic problems of
design, whereas a routine work remains the prerogative of computers.
Tremendous achievements in the area of semiconductor electronics has turned
microelectronics into nanoelectronics. Actually, we observe a real technical boom
connected with achievements in nanoelectronics. It results in development of very
complex integrated circuits, particularly in the area of ﬁeld programmable logic
devices. Our book targets ﬁeld-programmable gate arrays (FPGA). First FPGA
chips were introduced by Xilinx in 1985, i.e. exactly 30 years ago. They were used
mostly as devices implementing simple random and glue logic. Up-to-day FPGAs
have up to 7 billion of transistors. So, they are so huge, that it is enough only one
chip to implement a rather complex digital system including a datapath and a
control unit. Because of the extreme complexity of FPGA chips, it is very important
to develop effective design methods targeting their particular properties. It means
that the design methods should be technology-depended.
As it is known, any digital system can be represented as a composition of a
datapath and a control unit. Logic circuits of operational blocks forming a datapath
have regular structures. It allows using standard library elements of CAD tools
(such as counters, multibit adders, multipliers, multiplexers, decoders and so on) for
their design. A control unit coordinates interplay of other system blocks producing
a sequence of control signals (microoperations). These control signals cause
v

executing required actions by a datapath. As a rule, control units have irregular
structures. It makes process of its design very sophisticated. Many important fea-
tures of a digital system, such as hardware amount, performance, power con-
sumption and so on, depend to a large extent on characteristics of its control unit.
Therefore, to design competitive digital systems with FPGAs, a designer should
have fundamental knowledge in the area of logic synthesis and optimization of
logic circuits of control units. As experience of many scientists shows, design
methods used by standard industrial packages are far from optimal. Especially it is
true in the case of designing complex control units. It means that a designer could
be forced to develop his own design methods, next to program them and at last to
combine them with standard packages to get a result with desired characteristics. To
help such a designer, this book is devoted to solution of the problems of logic
synthesis and reduction of hardware amount in control units. We discuss the case
when a control unit is represented by the model of ﬁnite state machine (FSM). The
book contains many original synthesis and optimization methods based on the
taking into account the peculiarities of FPGA chips and an FSM model in use. One
of the peculiarities of FPGA chips is existence of embedded memory blocks
(EMB). We try to implement with EMBs as much of control unit’s circuits as it is
possible. It results in reducing the irregular part of the control units described by
means of Boolean functions. It permits decreasing for the total number of look-up
table (LUT) elements in comparison with logic circuits based on known models of
FSM. Also, it decreases the number of interconnections in the resulting circuits. In
turn, it makes the problem of place-and-routing much simpler. The third beneﬁt is
the reducing power dissipation in comparison with FSM circuits implemented only
with LUTs. In our book, control algorithms are represented by graph-schemes of
algorithms (GSA). This choice is based on obvious fact that this speciﬁcation
provides the simple explanation of the methods proposed by the authors.
To replace LUT-based subcircuits in FSM logic circuits by EMB-based parts, it
is necessary to diminish the number of arguments in corresponding systems of
Boolean functions. To do it, we propose using the methods of structural decom-
position, such as: (1) the replacement of logical conditions; (2) the encoding of the
collections of microoperations; (3) the transformation of FSM objects, when the
internal states are represented as functions of microoperations and vice versa. Also,
we use the existence of the classes of pseudoequivalent states of Moore FSMs to
compress structure tables and diminish the number of state variables. It simpliﬁes
the system of input memory functions and, therefore, decreases the number of
EMBs in the resulting FSM circuit. We combine this approach with using EMBs for
implementing the system of output functions (microoperations). It allows a sig-
niﬁcant decreasing for the number of LUTs, as well as eliminating a lot of inter-
connections in the FSM logic circuit. It saves area occupied by the circuit and
diminishes the resulting power dissipation. Of course, it leads to more sophisticated
synthesis process than the one targeting only LUT-based circuits.
The process of FSM logic synthesis is reduced to a transformation of a control
algorithm into some tables describing the behaviour of FSM blocks. These tables
are used to ﬁnd the systems of Boolean functions, which can be used to implement
vi
Preface

logic circuits of particular FSM blocks. In order to implement corresponding cir-
cuits, this information should be transformed using data formats of particular
industrial CAD systems. We do not discuss this step is in our book. Our book
contains a lot of examples showing design of FSMs with using the proposed
methods. Some examples are illustrated by logic circuits.
The book contains Introduction, eight chapters and Conclusion. It is written by a
research group from University of Zielona Góra (Poland). Professors Alexander
Barkalov and Larysa Titarenko wrote Introduction, two ﬁrst chapters and
Conclusion. Chapters 3 and 4 are written by Ph.D. Kamil Mielcarek. Chapters 5 and
6 are written by Ph.D. Grzegorz Bazydlo. Chapters 7 and 8 are written by Ph.D.
Malgorzata Kolopienczyk.
Chapter 1 provides some basic issues connected with ﬁnite state machines and
ﬁeld programmable logic devices. The basic models of Mealy and Moore FSMs are
presented. The classical design methods are presented for three kinds of control
units: microprogrammed automata, microprogram control units and compositional
microprogram control units. Main methods of hardware reduction are given for
ﬁnite state machines implemented with ﬁeld programmable logic devices, such as
the replacement of logical conditions, encoding of collections of microoperations
and encoding the ﬁelds of compatible microoperations.
Chapter 2 is devoted to application of ﬁeld programmable gate arrays in design
of logic circuits of FSMs. The basic features of FPGA are analysed. It is shown that
embedded memory blocks allow effective implementing systems of regular Boolean
functions. Next, the basic problems of FSM design are considered. Different state
assignment methods are analysed in details, as well as the methods of functional
decomposition. At last, there are discussed the methods of hardware reduction for
FPGA-based FSMs.
Chapter 3 presents the original methods of hardware reduction based on the
transformation of object codes of Mealy FSMs. The principle of object code
transformation (OCT) is introduced. Two types of objects are introduced: internal
states and collections of microoperations. Two types of basic models of Mealy
FSMs with OCT are described. The design methods are proposed for the
EMB-based FSMs with transformation of the states into the collections of
microoperations. Next, the design methods are shown allowing the transformation
of the collections of microoperations into the states. The models of FSMs with the
replacement of logical conditions and OCT are discussed. At last, the analysis of the
proposed methods is executed giving conditions of their application.
Chapter 4 deals with the original methods of hardware reduction based on the
transformation of object codes of Moore FSMs. Two types of basic models of
Moore FSMs with OCT are described, as well as EMB-based structures corre-
sponding to these models. The design methods are proposed for the EMB-based
FSMs with transformation of states into the collections of microoperations. Next,
the design methods are shown allowing the transformation of the collections of
Preface
vii

microoperations into the states. The models of FSMs with the replacement of
logical conditions and OCT are discussed. The additional hardware reduction is
achieved due to using the classes of pseudoequivalent states.
Chapter 5 deals with optimization of logic circuits of Moore FSMs based on
using two and three sources of codes of classes of pseudoequivalent states (PES).
First of all, the application of this method for CPLD-based FSMs is discussed.
Next, the models with two sources of class codes are discussed and corresponding
design methods are proposed. This approach requires the usage of a multiplexor to
choose a particular source. Also, the models with three sources of class codes are
discussed and corresponding design methods are proposed. It is shown how the
replacement of logical conditions can be used in multisource models of FSMs. At
last, it is shown that the hardware reduction can be obtained due to increasing the
number of class variables.
Chapter 6 is devoted to hardware reduction based on using many directions of
input memory functions in Moore FSMs. First, the hardware reduction methods are
proposed for the two-directional Moore FSMs. They are based on the special state
assignment allowing the decreasing for the number of literals in sum-of-products
representing input memory functions. Next, the design methods are proposed for
the three-directional Moore FSMs. It is shown that the number of directions can be
increased. It leads to simplifying the input memory functions in comparison with
the single-directional models. The last part of the chapter is devoted to combining
the replacement of logical conditions with many directions of state codes.
Chapter 7 deals with design of Mealy FSMs based on using embedded memory
blocks. The methods of trivial EMB-based implementation of logic circuits of
Mealy FSMs are discussed. In this case, only one EMB is enough for implementing
the circuit. Next, the optimization methods are discussed based on encoding of the
collections of microoperations and replacement of logical conditions. Also, the
methods are discussed based on encoding of the rows of FSM structure table. All
these methods lead to two-level models of Mealy FSMs. Next, these methods are
combined together for further optimizing the hardware amount in FSM logic cir-
cuits. The last section considers different methods proposed for diminishing the
hardware amount in LUTer implementing the block of replacement of logical
conditions. The chapter includes a lot of tables with results of investigations of
proposed methods for the standard benchmarks.
Chapter 8 deals with design of Moore FSMs based on using embedded memory
blocks. The methods of trivial EMB-based implementation of logic circuits of
Moore FSMs are discussed. In this case, only a single EMB is enough for imple-
menting the logic circuit. Next, the optimization methods are discussed based on the
structural decomposition leading to two-level models of FSMs. It is shown how to
use the classes of PES for decreasing the number of EMBs in the ﬁnal circuit. The
last section considers different methods proposed for diminishing the hardware
amount in LUTer implementing the block of replacement of logical conditions. It is
shown that at least 17 different models can be used for optimizing the LUTer.
viii
Preface

We hope that our book will be interesting and useful for students and Ph.D.
students in the area of Computer Science, as well as for designers of modern digital
systems. We think that proposed FSM models enlarge the class of models applied
for implementation of control units with modern FPGA chips.
Zielona Góra
Alexander Barkalov
May 2015
Larysa Titarenko
Preface
ix

Contents
1
Background of Finite State Machines and Programmable Logic . . .
1
1.1
Basic Models of FSMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Logic Synthesis for Microprogram Automata . . . . . . . . . . . . . . .
4
1.3
Logic Synthesis for Microprogram Control Units . . . . . . . . . . . .
9
1.4
Logic Synthesis for Compositional MCUs . . . . . . . . . . . . . . . . .
15
1.5
Hardware Reduction for FPLD-Based FSMs. . . . . . . . . . . . . . . .
21
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
2
Field Programmable Gate Arrays in FSM Design . . . . . . . . . . . . . .
33
2.1
General Characteristic of FPGAs. . . . . . . . . . . . . . . . . . . . . . . .
33
2.2
Trivial Implementing FPGA-Based FSMs. . . . . . . . . . . . . . . . . .
38
2.3
Methods of State Assignment . . . . . . . . . . . . . . . . . . . . . . . . . .
45
2.4
Hardware Reduction for FPGA-Based FSMs . . . . . . . . . . . . . . .
50
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3
Object Codes Transformation for Mealy FSMs . . . . . . . . . . . . . . .
65
3.1
Principle of OCT for Mealy FSMs . . . . . . . . . . . . . . . . . . . . . .
65
3.2
Synthesis of FPGA-Based Mealy FSMs with Transformation
of States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
3.3
Synthesis of FPGA-Based Mealy FSMs with Transformation
of CMOs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
3.4
Replacement of Logical Conditions in Mealy FSMs
with OCT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
3.5
Analysis of Proposed Methods . . . . . . . . . . . . . . . . . . . . . . . . .
90
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
4
Object Codes Transformation for Moore FSMs . . . . . . . . . . . . . . .
97
4.1
Principle of OCT for Moore FSMs . . . . . . . . . . . . . . . . . . . . . .
97
4.2
Synthesis of FPGA-Based Moore FSMs with Transformations
of States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
104
4.3
Synthesis of FPGA-Based Moore FSMs with Transformation
of CMOs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
112
xi

4.4
Replacement of Logical Conditions in Moore FSMs
with OCT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
126
5
Distribution of Class Codes in Moore FSMs . . . . . . . . . . . . . . . . . .
129
5.1
The Case of CPLD-Based FSMs. . . . . . . . . . . . . . . . . . . . . . . .
129
5.2
Two Sources of Class Codes in FPGA-Based Moore FSMs . . . . .
133
5.3
Three Sources of Class Codes in FPGA-Based Moore FSMs . . . .
141
5.4
Replacement of Logical Conditions and Distribution
of Class Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
5.5
Increasing the Number of Class Variables . . . . . . . . . . . . . . . . .
147
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
158
6
Hardware Reduction in Multidirectional Moore FSMs . . . . . . . . . .
161
6.1
Hardware Reduction in Two-Directional Moore FSMs. . . . . . . . .
161
6.2
Hardware Reduction in 3-Directional Moore FSMs . . . . . . . . . . .
171
6.3
Replacement of Logical Conditions for K-Directional
Moore FSMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
186
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
191
7
Design of EMB-Based Mealy FSMs . . . . . . . . . . . . . . . . . . . . . . . .
193
7.1
Trivial Implementing Mealy FSMs . . . . . . . . . . . . . . . . . . . . . .
193
7.2
Encoding of Objects in Mealy FSMs. . . . . . . . . . . . . . . . . . . . .
200
7.3
Replacement of Logical Conditions for Mealy FSMs. . . . . . . . . .
211
7.4
Hardware Reduction for BRLC. . . . . . . . . . . . . . . . . . . . . . . . .
223
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
236
8
Design of EMB-Based Moore FSMs . . . . . . . . . . . . . . . . . . . . . . . .
239
8.1
Trivial Implementing Moore FSMs . . . . . . . . . . . . . . . . . . . . . .
239
8.2
Structural Decomposition for Moore FSMs. . . . . . . . . . . . . . . . .
243
8.3
Optimization of BIMF Based on Pseudoequivalent States. . . . . . .
251
8.4
Optimizing LUTer in Replacement of Logical Conditions . . . . . .
257
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
276
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
277
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
279
xii
Contents

Abbreviations
BF
Block of functions
BGSA
Block graph-scheme of algorithm
BIMF
Block of input memory functions
BM
Benchmark
BMO
Block of microoperations
BRAM
Block of random access memory
BRLC
Block of replacement of logical conditions
BSCT
Block of state codes transformer
CAD
Computer-aided design
CLB
Conﬁgurable logic block
CMCU
Compositional microprogram control unit
CMO
Collection of microoperations
CPLD
Complex programmable gate arrays
CT
Counter
DMO
Distribution of microoperations
DRAM
Distributed RAM
EMB
Embedded memory block
EMBer
Logic block consisting from EMBs
FCO
Fields of compatible microoperations
FPGA
Field-programmable gate arrays
FPLD
Field-programmable logic devices
FSM
Finite state machine
FT
Formula of transitions
GAL
Generic array logic
GFT
Generalized formula of transitions
GSA
Graph-scheme of algorithm
IOB
Input–output block
LUT
Look-up table
LUTer
Logic block consisting from LUTs
MCU
Microprogram control unit
MI
Microinstruction
xiii

MO
Microoperation
MPA
Microprogrammed automaton
MPI
Matrix of programmable interconnections
MX
Multiplexer
OCT
Object codes transformation
OLC
Operational linear chain
PAL
Programmable array logic
PEO
Pseudoequivalent outputs
PES
Pseudoequivalent states
PIA
Programmable interconnection array
PLA
Programmable logic array
PLS
Programmable logic sequencer
PROM
Programmable read-only memory
RAM
Random access memory
RG
Register
RLC
Replacement of logical conditions
ROM
Read-only memory
SBF
System of Boolean functions
SFT
System of formulae of transitions
SOP
Sum of products
ST
Structure table
xiv
Abbreviations

Chapter 1
Background of Finite State Machines
and Programmable Logic
1.1 Basic Models of FSMs
Finite state machines (FSM) are sequential devices whose outputs depend on pre-
history of operation [1, 5]. As any digital circuit, an FSM can be represented as a
“black box” having inputs xe ∈X and outputs yn ∈Y (Fig.1.1a).
Let the symbol X(t) stand for the value of inputs in the instant of time t(t =
0, 1, 2, . . .). Let the symbol Y(t) stand for the value of outputs in the instant of time
t(t = 0, 1, 2, . . .). An FSM starts its operation in the instant t = 0. This instant
is determined by the pulse Start. Each instant of time t is determined by the pulse
Clock.
Theprehistoryofoperationisdeterminedbythevector⟨X(0), X(1), . . . , X(t−1)⟩.
It means that each output function yn(n ∈1, . . . , N) is represented as:
yn(t) = fn(X(0), X(1), .., X(t −1), X(t)).
(1.1)
TobeabletoimplementFSMcircuits,itisnecessarytosimplifyfunctions(1.1)[6].
To do it, the internal states are used representing the prehistory of FSM’s opera-
tion [32].
Internal states form the set A = {a1, . . . , aM}. They are represented by binary
strings called state codes [7]. It is enough R binary variables Tr ∈T to encode the
states of FSM, where:
⌈log2M⌉≤R ≤M.
(1.2)
State codes are named “binary” if R = ⌈log2M⌉; they are named “one-hot” if R = M
[13, 46].
To keep state codes, a state memory is used. If an FSM state is changed, then the
content of state memory should be changed, too. To do it, they use input memory
functions creating the set Φ = {φ1, . . . , φR}.
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_1
1

2
1
Background of Finite State Machines and Programmable Logic
Start
Clock
FSM
x1
xL
y1
yN
Combinational
Part
Start
Clock
X
Y
T
State
Memory
(a)
(b)
Fig. 1.1 Simplest modes of FSMs
As a rule, an FSM is represented as a composition of a combinational part and
the state memory (Fig.1.1b) [6]. The combinational part implements systems:
Y = Y(T, X),
(1.3)
Φ = Φ(T, X).
(1.4)
There are two main models of FSMs. In the Mealy FSM, Eq.(1.3) determines output
functions. In the case of Moore FSM, output functions depend only on state variables:
Y = Y(T).
(1.5)
In the practice of digital design, they use D ﬂip-ﬂops to implement the state
memory [16, 37]. In this case, the state memory is represented as a register (RG)
having R of ﬂip-ﬂops. It gives the set Φ = {D1, . . . , DR}. We use this approach in
our book.
To construct functions (1.1)–(1.5), it is necessary to describe the behaviour of
FSM. It can be done in many ways [6, 43]. In this book, we use the language of
graph-schemes of algorithm (GSA) to represent an FSM [6, 7]. Let us name FSM
inputs as “logical conditions” and FSM output functions as “microoperations”.
An GSA Γ is a directed connected graph having ﬁnite set of vertices [6]. There
are 4 different types of vertices shown in Fig.1.2: start, end, operator and conditional.
There is only output in the Start vertex (Fig.1.2a). This vertex corresponds to the
beginning of operation. There is only input in the End vertex (Fig.1.2b). This vertex
corresponds to the ﬁnishing of operation. An operator vertex contains a collection of
Start
End
Yt
1
0
xl
(a)
(b)
(c)
(d)
Fig. 1.2 Types of vertices

1.1 Basic Models of FSMs
3
Fig. 1.3 Graph-scheme of
algorithm Γ1
y3
End
1
1
0
0
Start
x1
x2
y1 y2
y1 y2
y2 y3
y1 y4
microoperations (CMO) Yt ∈Y. These microoperations are produced and executed
during one cycle of FSM’s operation. A conditional vertex contains an element of the
set X used for branching. There are two different values of Boolean variable xe ∈X.
An example of GSA is shown in Fig.1.3.
Two sets can be derived from GSA Γ1: the set of logical conditions X = {x1, x2}
and the set of microoperations Y = {y1, . . . , y4}. There are the following collections
of microoperations in the operator vertices of GSA Γ1: Y1 = {y1, y2}, Y2 = {y3},
Y3 = {y2, y3} and Y4 = {y1, y4}. There is no implicit states visible on GSA Γ1. This
set should be constructed.
FSMs are used for implementing logic circuits of control units [33, 34]. The
methods of logic synthesis depends strongly on the following factors:
1. Type of a control unit.
2. Technology (devices family) used for implementing logic circuits.
3. Peculiarities of an FSM model.
There are three main types of control units used in digital systems [12, 37]:
1. Microprogram automata (MPA).
2. Microprogram control units (MCU).
3. Compositional microprogram control units (CMCU).
Let us discuss the peculiarities of these control units.

4
1
Background of Finite State Machines and Programmable Logic
1.2 Logic Synthesis for Microprogram Automata
Let us start from the simplest Mealy MPA. It is named P Mealy MPA [16] and consists
from two main blocks (Fig.1.4). The block of functions (BF) implements the systems
(1.3) and (1.4). It is a combinational part of MPA. The register RG implements the
state memory having R0 of ﬂip-ﬂops:
R0 = ⌈log2M0⌉.
(1.6)
In (1.6), the symbol M0 stands for the number of states of Mealy MPA.
There are the following steps in the synthesis method of P Mealy MPA [6]:
1. Constructing a marked GSA and ﬁnding the set of internal states A.
2. Executing the state assignment.
3. Constructing the structure table of MPA.
4. Deriving functions Y and Φ from the structure table.
5. Implementing MPA logic circuit using particular logic elements.
Let the symbol P(Γj) stand for the case when the P Mealy MPA is synthesized
starting from a GSA Γj. Let us discuss an example of synthesis for the P(Γ1) Mealy
MPA.
To construct the marked GSA, the following rules are used [6, 7]:
• state a1 marks the output of Start vertex and the input of End vertex;
• there is a mark of state am(m ∈{2, . . . , M0}) on the input of any vertex following
an operator vertex;
• each input is marked only once.
Using these rules, the marked GSA Γ1 is obtained (Fig.1.5a). It is easy to ﬁnd the
set A = {a1, a2, a3} for the Mealy MPA P(Γ1) MPA. It gives the value of R0 = 2
and the sets T = {T1, T2} and Φ = {D1, D2}.
During the second step, a binary code K(am) is assigned for each state am ∈A.
This step is named the state assignment [32]. There are many variants for executing
the state assignment. As a rule, the zero code is assigned for the initial state a1 ∈A.
So, there are 2R0 −1 different ways for encoding the state a2 ∈A. Also, there are
Fig. 1.4 Structural diagram
of P Mealy MPA
Functions
X
Y
Start
Clock
RG
T

1.2 Logic Synthesis for Microprogram Automata
5
y3
End
1
1
0
0
Start
x1
x2
y1 y2
y1 y2
y2 y3
y1 y4
a1
a1
a2
a3
y3
End
1
1
0
0
Start
x1
x2
y1 y2
y1 y2
y2 y3
y1 y4
a1
a1
a2
a3
a4
a5
(a)
(b)
Fig. 1.5 Marked GSA Γ1 with Mealy (a) and Moore (b) states
2R0 −2 different ways for encoding the state a3 ∈A. The following formula shows
the quantity of different variants of the state assignment (nSA):
nSA =
(2R0 −1)!
(2R0 −(M0 −1))!.
(1.7)
Let us use the simplest way of state assignment in the discussed case. It is reduced
to assignment of a binary equivalent of the number (m −1) for the state am ∈A. It
gives the following codes: K(a1) = 00, K(a2) = 01, K(a3) = 10.
A structure table (ST) of MPA represents transitions between states am ∈A. It
is constructed using the rules [6, 7]. The ST includes the following columns: am is
a current state; K(am) is a code of the state am ∈A; as is a next state (a state of
transition); K(as) is a code of the state as ∈A; Xh is an input signal determining
the transition ⟨am, as⟩and it is equal to the conjunction of some logical conditions
(or their complements); Yh is a CMO generated during the transition ⟨am, as⟩; Φh is
a set of input memory functions equal to 1 to load the code K(as) into RG; h is a
number of transition (h ∈{1, . . . , H0}). Table1.1 is an ST for Mealy MPA P(Γ1). It
includes H0 = 5 rows.
Each row h of ST corresponds to a function Fh(h = 1, H0):
Fh = AmhXh.
(1.8)
In (1.8), the symbol Amh stands for the conjunction of state variables Tr ∈T corre-
sponding to the code K(am) from the h-th row of ST(h = 1, H0). Functions Fh are
used as product terms of functions (1.3) and (1.4). Because of it, we use the name
“term” for any function Fh(h = 1, H0).

6
1
Background of Finite State Machines and Programmable Logic
Table 1.1 Structure table of Mealy MPA P(Γ1)
am
K(am)
as
K(as)
Xh
Yh
Φh
h
a1
00
a2
01
1
y1y2
D2
1
a2
01
a3
10
x1
y3
D1
2
a3
10
¯x1x2
y2y3
D1
3
a3
10
¯x1 ¯x2
y1y2
D1
4
a3
10
a1
00
1
y1y4
–
5
There are the following sum-of-products (SOP) forms of functions (1.3) and (1.4)
derived from an ST:
yn =
H0

h=1
CnhFh(n = 1, N);
(1.9)
Dr =
H0

h=1
CrhFh(r = 1, R0).
(1.10)
In these equations, Cnh(Crh) is a Boolean variable equal to 1 if and only if (iff)
the symbol yn(Dr) is written in the h-th row of ST(h = 1, H0).
The following expressions can be derived from Table1.1 for the terms:
F1 = ¯T1 ¯T2; F2 = ¯T1T2x1; F3 = ¯T1 ¯T2 ¯x1x2;
F4 = ¯T1T2 ¯x1 ¯x2; F5 = T1 ¯T2.
(1.11)
There is no state having the code 11. So, this code can be treated as “don’t care”
[31]. Using this code, it is possible to get the following system of terms:
F1 = ¯T1 ¯T2; F2 = T2x1; F3 = T2 ¯x1x2;
F4 = T2 ¯x1 ¯x2; F5 = T1.
(1.12)
Using rules of Boolean algebra [31], it is possible to get the minimized SOP of
functions (1.9) and (1.10):
y1 = F1 ∨F4 = ¯T1 ¯T2 ∨T2 ¯x1 ¯x2 ∨T1;
y2 = F1 ∨F3 ∨F4 = ¯T1 ¯T2 ∨T2x1;
y3 = F2 ∨F3 = T2x1 ∨T2x2;
y4 = F5 = T1;
D1 = F2 ∨F3 ∨F4 = T2;
D2 = F1 = ¯T1 ¯T2.
(1.13)

1.2 Logic Synthesis for Microprogram Automata
7
Functions
Microoperations
X
Y
Start
Clock
RG
Fig. 1.6 Structural diagram of P Moore MPA
These expressions are used for implementing the logic circuit of Mealy FSM P(Γ1).
The circuit of BF is implemented using the system (1.13). The circuit of RG is
implemented in a trivial way. It is a library element for computer-aided design (CAD)
system [21]. The last step of discussed method depends on logic elements in use. We
will discuss it a bit later.
Now, let us discuss the structural diagram of P Moore MPA (Fig.1.6). It includes
the register RG and two combinational blocks. The block of input memory func-
tions (BIMF) implements the system (1.4). The block of microoperations (BMO)
implements the system (1.5).
There are M1 of states in the set A for a Moore MPA. To encode them, it is required
at least R1 of state variables:
R1 = ⌈log2M1⌉.
(1.14)
There are the same steps in synthesis of Mealy and Moore MPAs. But they are
executed in a different way. Let us discuss an example of synthesis for Moore MPA
P(Γ1).
To construct the set A, the following rules are used [6]:
• both Start and End vertices are marked by state a1;
• each operator vertex is marked by a unique state.
ApplyingtheserulestoGSAΓ1 (Fig.1.3)leadstothemarkedGSAshowninFig.1.5b.
There are M1 = 6 elements in the set A. It gives us R1 = 3, T = {T1, T2, T3}
and Φ = {D1, D2, D3}. Let us encode the states am ∈A in the trivial way: K(a1) =
000, . . . , K(a6) = 101.
There are the following columns in ST of Moore MPA: am, K(am), as, K(as), Xh,
Φh, h. There is an CMO Y(am) ⊆Y in the column am. The CMO Y(am) includes
microoperations written in the operator vertex of a GSA marked by the state am ∈A.
In the discussed case, there are H1 = 8 rows in the ST (Table1.2).
This table is used for deriving systems (1.4) and (1.5). The terms Fh of (1.4)
are determined by (1.8). For example, there are the following terms: F1 = ¯T1 ¯T2 ¯T3,
F2 = ¯T1 ¯T2T3x1, F5 = T2 ¯T3. To get the term F5, the “don’t’ care” assignment 110 is
used.

8
1
Background of Finite State Machines and Programmable Logic
Table 1.2 Structure table of Moore MPA P(Γ1)
am
K(am)
aS
K(aS)
Xh
Φh
h
a1(−)
000
a2
001
1
D3
1
a2(y1y2)
001
a3
010
x1
D2
2
a4
011
¯x1x2
D2D3
3
a5
100
¯x1 ¯x2
D1
4
a3(y3)
010
a6
101
1
D1D3
5
a4(y2y3)
011
a6
101
1
D1D3
6
a5(y1y2)
100
a6
101
1
D1D3
7
a6(y1y4)
101
a1
000
1
–
8
Functions yn ∈Y are determined by the following expression:
yn =
R1

r=1
CnmAm(n = 1, N).
(1.15)
In (1.15), the Boolean variable Cnm is equal to 1 iff there is the relation yn ∈Y(am).
The conjunction Am is determined as the following:
Am =
R1

r=1
Tlmr
r
(m = 1, M1).
(1.16)
In (1.6), the symbol lmr stands for the value of r-th bit of the code K(am), where
lmr ∈{0, 1, ∗} and T0
r =
¯Tr, T1
r = Tr, T∗
r = 1 (r = 1, R1). The symbol “*”
corresponds to the “don’t care” value of a particular bit.
Let us point out that the system (1.15) can be represented by a truth table [31]
with inputs Tr ∈T and outputs yn ∈Y. In the discussed case, it is Table1.3.
There is the obvious connection between Tables1.2 and 1.3. Functions yn ∈Y are
determined for more than 50% of possible state assignments. It takes place for any
Moore FSM if they use exactly R1 of state variables. It means that functions (1.5)
are regular [13]. In the next chapters, we show how to use this property.
Table 1.3 Truth table of system Y
K(am)
Y(am)
m
K(am)
Y(am)
m
T1T2T3
y1y2y3y4
T1T2T3
y1y2y3y4
000
0000
1
100
1100
5
001
1100
2
101
1001
6
010
0010
3
110
∗∗∗∗
∗
011
0110
4
111
∗∗∗∗
∗

1.2 Logic Synthesis for Microprogram Automata
9
Using rules of expansion, the following equations can be extracted from Table1.3:
y1 = ¯T1 ¯T2T3 ∨T1; y2 = ¯T1T3 ∨T1 ¯T3; y3 = T2; y4 = T1T3.
(1.17)
Theseequationsinclude6termshaving11literals.Thereare8termshaving15literals
in functions yn ∈Y from (1.13). So, functions (1.5) are simpler than functions (1.3)
for equivalent Mealy and Moore MPAs.
MPAs are equivalent if they are synthesized for the same GSA Γ . There are the
following relations for equivalent Mealy and Moore MPAs:
R0 ≤R1;
(1.18)
H0 ≤H1.
(1.19)
It seems that using models of Mealy MPAs always leads to circuits with less
amount of hardware. But it is not true due to two properties of Moore FSMs [10,
13]:
1. System Y is a system of regular functions.
2. Set A can be divided by classes of pseudoequivalent states.
States am, ai ∈A are pseudoequivalent states (PES) if they mark operator vertices
whose outputs are connected with the input of the same vertex of a GSA Γ [10].
Using this deﬁnition, it could be found a partition ΠA = {B1, . . . , BI} where Bi is a
class of PES.
In the discussed case, there is the partition ΠA = {B1, .., B4} with the classes
B1 = {a1}, B2 = {a2}, B3 = {a3, a4, a5} and B4 = {a6}. It follows from the analysis
of GSA Γ1 (Fig.1.5b).
Let us assume that each class Bi ∈ΠA can be represented by a single block of a
GSA having inputs am ∈Bi and only one output. It leads to a block GSA (BGSA).
In the discussed case, we can get the BGSA B(Γ1) (Fig.1.7).
In the next chapters, we show how to use BGSAs for reducing hardware amount
in circuits of Moore MPAs.
1.3 Logic Synthesis for Microprogram Control Units
Microprogram control units were proposed by Wilkes [44, 45]. In 1951, he proposed
to use the intermediate level between the computer software and hardware. This level
is now named “ﬁrmware” [2, 3]. According to the principle of microprogrammed
control, each computer instruction is represented as a microprogram. A micropro-
gram is a sequence of microinstructions (MI) kept into a control memory of MCU.
There are the following steps [1, 16] in the typical method of MCU’s design:

10
1
Background of Finite State Machines and Programmable Logic
Fig. 1.7 Block
graph-scheme of algorithm
B(Γ1)
B3
a2
B4
a6
B1
a1
1
1
0
0
Start
x1
x2
a3
a4
B3
a5
a1
End
1. Transformation of initial GSA Γ .
2. Constructing the set of microinstructions with a given format.
3. Executing the microinstruction addressing.
4. Executing the encoding of the ﬁelds of MIs.
5. Constructing the MCU logic circuit with particular logic elements.
Thepeculiaritiesofadesignmethoddependtremendouslyonthemodeofmicroin-
struction addressing [42]. There are three main methods of microinstruction address-
ing [36].
1. Compulsory addressing.
2. Natural addressing.
3. Combined addressing.
A microinstruction is divided by ﬁelds such as: FY, FX, FA0, FA1. The ﬁeld FY
is an operational part of MI. It contains a code C(Yt) of a CMO Yt ⊆Y evoked by
a microinstruction. The ﬁeld FX contains a code C(xl) of a logical condition xe ∈X
checked to ﬁnd an address of the next MI to be executed. The ﬁeld FA0 contains an
address of transition for two cases: (a) unconditional transition and (b) transition if
xe = 0. The ﬁeld FA1 contains an address of transition for the case when xe = 1. In
the case of compulsory addressing, there are all these ﬁelds in the microinstruction
format (Fig.1.8).
Let us use the following denotations: xt
e is a logical condition checked in the
instant of time t; [FX]t, [FA0]t, [FA1]t is a content of the corresponding ﬁeld in the
instant of time t; At is an address of microinstruction executed in the instant of time

1.3 Logic Synthesis for Microprogram Control Units
11
FY
FX
FA0
FA1
Fig. 1.8 Format of microinstruction with compulsory addressing
SFA
X
Y
T
Start
Clock
RAMI
TF
R
S
yE
Start
Fetch
CM
FA1
FA0
FX
FY
Fig. 1.9 Structural diagram of MCU with compulsory addressing of microinstructions
t(t = 0, 1, . . .). Let us presume that the following law is used to determine the
address of transition At+1:
At+1 =
⎧
⎨
⎩
[FA0]t if xt
e = 0;
[FA0]t if [FX]t = ∅;
[FA1]t if xt
e = 1.
(1.20)
The second line in (1.20) corresponds to the unconditional transition.
There are four main blocks in MCU with compulsory addressing (Fig.1.9):
address sequencer SFA; register of microinstruction address RAMI; control memory
CM and fetch ﬂip-ﬂop TF.
There is the following mode of operation of MCU from Fig.1.9. A single pulse
Start causes loading an address of the ﬁrst MI into RAMI. At the same time, this
pulse sets up the TF causing Fetch = 1. It allows fetching data from the control
memory.
Let an address At be located into RAMI at time t. The corresponding MI is fetched
from CM. Its operational part is transformed into microoperations yn ∈Y. After
executing the microoperations, there are correct values of logical conditions xe ∈X
on the input of SFA. The second input of SFA receives information from the address
part of MI. The rule (1.20) is used for obtaining the address of transition. This process
is repeated till the last MI containing a special variable yE into its operational part is
fetched. It causes reset (zeroing) the TF leading to Fetch=0. It causes the termination
of MCU operation.
Let us discuss an example of design for MCU (Fig.1.9) using the GSA Γ2
(Fig.1.10).
Let V(Γj) be a set of vertices from a GSA Γj, V0(Γj) be a set of opera-
tor vertices, and Vc(Γj) be a set of conditional vertices. There are the following

12
1
Background of Finite State Machines and Programmable Logic
y3
End
1
1
0
0
Start
x1
x2
y1 y2
y2 y3
y1 y4
b0
b1
b2
b4
b3
b5
b6
bE
y3
End
1
1
0
0
Start
x1
x2
y1 y2
y2 y3
y1y y
4
E
yE
b0
b1
b2
b4
b3
b5
b6
b7
bE
(a)
(b)
Fig. 1.10 Initial GSA Γ2 before (a) and after (b) transformation
sets in the case of GSA Γ2: Vo(Γ2) = {b1, b3, b5, b6}, Vc(Γ2) = {b2, b4}, and
V(Γ2) = {b0, b1, . . . , b6, bE}. Obviously, the symbol b0 denotes the Start vertex
and bE the End vertex. Also, there are the following sets and their parameters:
X = {x1, x2}, L = 2, Y = {y2, . . . , y4} and N = 4.
The transformation of GSA Γ is reduced to providing the mode of termination.
To do it, the variable yE is inserted into vertices bq ∈V0(Γj) connected with bE. If
there are connections among vertices bq ∈Vc(Γj) and bE, then an additional vertex
is inserted into a GSA. It contains yE and it is connected with bE. In the discussed
case, the variable yE is inserted into b6. Also, the vertex b7 is added (Fig.1.10b).
Analysis of MCU operation shows that there are two stages in the execution
of an MI. First, the microoperations are generated. Second, the logical conditions
are checked. So, each MI corresponds to a pair ⟨bq, bt⟩where bq ∈V0(Γj) and
bt ∈Vc(Γj). So, to ﬁnd microinstructions, these pairs should be analysed. There are
four possible conﬁgurations for vertices bq, bt such that the output of bq is connected
with the input of bt (Fig.1.11).
If both vertices are operator (Fig.1.11a), then the vertex bq corresponds to MI
with empty ﬁelds FX and FA1. The analysis should be continued for the vertex bt.
If bq ∈V0(Γj) and bt ∈Vc(Γj), then they form an MI without empty ﬁelds. It
corresponds to the conﬁguration shown in Fig.1.11b. If both vertices are conditional
(Fig.1.11c), then the vertex bt corresponds to an MI with empty ﬁeld FY. The analysis
is continued for bq. If bq ∈Vc(Γj) and bt ∈V0(Γj), then the analysis should be
continued for both vertices.
Using this approach, one can ﬁnd the following MIs denoted as Oi: O1 = ⟨b1, b2⟩,
O2 = ⟨b3, ∅⟩, O3 = ⟨∅, b4⟩, O4 = ⟨b5, ∅⟩, O5 = ⟨b6, ∅⟩and O6 = ⟨b7, ∅⟩. There

1.3 Logic Synthesis for Microprogram Control Units
13
y3
y1 y2
bq
bt
1
0
x1
y1 y2
bq
bt
1
1
0
0
x3
x4
bq
bt
0
1
x1
y1
bq
bt
(a)
(b)
(c)
(d)
Fig. 1.11 Possible conﬁgurations of pairs of vertices
are M2 = 6 microinstructions having the format (Fig.1.8) in the case of GSA Γ2.
It is enough R2 = 3 bits for addressing M2 = 6 microinstructions. It gives the set
T = {T1, T2, T3}.
If Start = 1, then an address of the ﬁrst MI is loaded into RAMI. It means that
A1 = 000, where Am is an address of the MI Om(m = 1, M2). There is no inﬂuence
of the outcome of addressing on the hardware amount of MCU. So, let us address
them in the trivial way: A2 = 001, . . . , A6 = 101.
Obviously, the CM can keep only binary codes. Let us encode the ﬁeld FY using
one-hot codes [16]. In the discussed case, there are nY = 5 bits in the ﬁeld FY. Let
us use the minimal possible amount of bits for encoding of logical conditions:
nL = ⌈log2(L + 1)⌉.
(1.21)
In (1.21), one is added to take into amount unconditional transitions. In the discussed
case, there is nL = 2. Let us use the following codes: K(x1) = 01, K(x2) = 10 and
K(∅) = 00.
Now, there are codes and addresses for all ﬁelds of microinstructions. It allows
constructing the content of CM (Table1.4).
Table 1.4 Content of control memory for MCU with compulsory addressing of microinstructions
Address
FY
FX
FA0
FA1
FT
T1T2T3
y1y2y3y4yE
d1d2
d3d4d5
d6d7d8
000
11000
01
010
001
O1 →
¯x1O3 ∨x1O2
001
00100
00
100
000
O2 →O5
010
00000
10
101
011
O3 →
¯x2O6 ∨x2O4
011
01100
00
100
000
O4 →O5
100
10011
00
000
000
O5 →End
101
00001
00
000
000
O6 →End

14
1
Background of Finite State Machines and Programmable Logic
We use symbols dr(r = 1, nL + 2R2) for the bits from the ﬁelds FX, FA0 and
FA1. The last column contains the formula of transition (FP) for last vertex of the
pair Om.
Synthesis of the logic circuit of MCU is reduced to the synthesis of SFA with
standard multiplexers and synthesis of CM with standard read-only memory (ROM)
blocks. Let us use two variables, z1 and z2, to organize the loading RAMI from CM.
If z1 = 1, then RAMI := CM[FA1]. If z1 = 1, then RAMI := CM[FA0]. So, the
following function should be implemented:
At+1 = z1[FA1]t ∨z2[FA0]t.
(1.22)
In the discussed case, the following expression can be used for z1:
z1 = ¯d1d2x1 ∨d1 ¯d2x2.
(1.23)
That equation can be implemented using a multiplexer whose control inputs are
connected with d1 and d2, and informational inputs with x1 and x2. For unconditional
transitions, it should be z1 = 0. Therefore, it is necessary to connect zero with
informational input corresponding to d1 = d2 = 0.
Let us use D ﬂip-ﬂops to implement RAMI. It allows to transform (1.22) into R2
of the following equations:
D1 = z1d6 ∨z2d3;
D2 = z1d7 ∨z2d4;
D3 = z1d8 ∨z2d5.
(1.24)
It is enough R2 of multiplexers to implement the system (1.24).
Obviously, that z1 is complement to z2. It allows to implement the following circuit
of SFA (Fig.1.12).
z1
MX1
0
1
1
d3
d6
D1
MX2
0
1
1
d4
d7
D2
MX3
0
1
1
d5
d8
D3
d d2
1
“0”x x2
1
MX
Fig. 1.12 Logic circuit of SFA

1.3 Logic Synthesis for Microprogram Control Units
15
Fig. 1.13 Format of
microinstructions with
natural addressing
(a)
0
FX
(b)
1
FX
FA0
There are two microinstruction formats in the case of natural addressing [16]. An
operational microinstruction (OMI) corresponds to an operator vertex (Fig.1.13a). A
conditional microinstruction (CMI) corresponds to a conditional vertex (Fig.1.13b).
They determine the type of MI using the ﬁrst bit of a format. Let us denote this
bit as FA. The following rules are used to ﬁnd the address At [4]:
At+1 =
⎧
⎪⎪⎨
⎪⎪⎩
At + 1, if [FA]t = 0;
At + 1, if (xt
e = 1) ∧([FA]t = 1);
[FA0]t, if (xt
e = 0) ∧([FA]t = 1);
[FA0]t, if ([FX]t = ∅) ∧([FA]t = 1).
(1.25)
If a current MI is an OMI, then the current address is incremented to get the
address of transition. The same is true for conditional transitions with xt
e = 1. The
third line of (1.25) corresponds to the operation “go to”.
Analysis of (1.25) shows that is should be a counter (CT) in the structure of MCU
with natural addressing. We do not discuss the design methods based on (1.25).
They can be found in [12, 16], for example. Counters are used in compositional
microprogram control units [12]. Let us discuss these models of FSMs.
1.4 Logic Synthesis for Compositional MCUs
These models were proposed in 1983 [8]. They can be viewed as MPAs with a
counter (CT) instead of the register. Compositional MCUs (CMCU) are based on the
representing GSA Γ by a set of operational linear chains (OLC). Let us introduce
some deﬁnitions.
Deﬁnition 1.1 An OLC αg of a GSA Γ is a ﬁnite vector of operator vertices αg =
⟨bg1, . . . , bgFg⟩such that eachpair of adjacent vertices⟨bgi, bgi+1⟩corresponds toan
edge of the GSA Γ . Here i is the component number of the vector αg(i = 1, Fg −1).
Let Vg
0 be a set of operator vertices, which are the components of αg.
Deﬁnition 1.2 An operator vertex bg ∈Vg
0 is an input of OLC αg if there is an edge
⟨bt, bg⟩∈E such that bt /∈Vg
0 .
Here E is a set of edges of a GSA Γ . Each edge connects two vertices of GSA.

16
1
Background of Finite State Machines and Programmable Logic
Functions
Microoperations
X
Y
Start
Clock
CT
Start
y0
T
+1
TF
R
S
yE
Fetch
Fig. 1.14 Structural diagram of CMCU with common memory
Deﬁnition 1.3 An input bg ∈Vg
0 is a main input of OLC αg if there is no edge
⟨bt, bg⟩∈E such that bt ∈Vc(Γ ).
Deﬁnition 1.4 An operator vertex bg ∈Vg
0 is an output of OLC αg if there is an
edge ⟨bg, bt⟩∈E such that Bt /∈Vg
0 .
Let us denote a set of OLC inputs as I(Γ ), a set of main inputs as MI(Γ ) and a
set of outputs as O(Γ ). Let us ﬁnd a set of OLC C = {α1, . . . , αG} satisfying the
following conditions:
G
g=1
Vg
0 = V0;
Vj
0 ∩Vj
0 = ∅(i ̸= j; i, j ∈{1, . . . , G});
G →min.
(1.26)
Let the symbol A(bq) stand for the address of microinstruction corresponding to
the vertex bq ∈V0(Γ ). Let us execute the natural addressing of microinstructions
for each OLC αg ∈C. It corresponds to the following expression:
A(bgi+1) = A(bgi) + 1(i = 1, Fg −1; g = 1, G).
(1.27)
Now, a GSA Γ can be interpreted by a CMCU with common memory (Fig.1.14).
This CMCU operates as the following. If Start = 1, then the address of the ﬁrst
MI is loaded into CT. At the same time, the ﬂip-ﬂop TF is set up giving Fetch = 1.
It allows reading microinstructions out the memory represented by BMO. Let CT =
A(bq) in the instant of time t(t = 0, 1, . . .). If bq is not the output of any OLC, then
BMO generates microoperations yn ∈Y(bq), where Y(bq) ⊆Y is a collection of
MOs from the vertex bq ∈V0(Γ ). At the same time, the variable y0 is generated
causing execution the operation CT := CT + 1. The pulse Clock causes loading a
next address of MI in accordance with (1.27). If bq ∈O(Γ ), then y0 = 0. In this case,
the content of CT is determined by functions (1.4) generated by BIMF. If there is an
edge ⟨bq, bE⟩∈E, then yE = 1. It causes Fetch = 0 and the operation is terminated.

1.4 Logic Synthesis for Compositional MCUs
17
Let us compare the CMCU (Fig.1.14) with PY Moore FSM (Fig.1.6). There
are two different features: (a) the RG is replaced by the CT; (b) the ﬂip-ﬂop TF is
added to organize the mode of microinstruction fetching. Let us compare the CMCU
(Fig.1.14) with MCU (Fig.1.9). The SFA is replaced by the BIMF. It allows checking
more than a single logical condition xe ∈X during one cycle of operation. So, there
are the features of MPA and MCU in CMCU. Obviously, states of MPA correspond to
microinstructions; addresses of MIs correspond to state codes. In the case of CMCU,
state codes obey the rule (1.27).
Let us denote the CMCU from Fig.1.14 as U1. Let the symbol U1(Γj) means that
the CMCU U1 is designed using a GSA Γj. Let us discuss an example of design for
U2(Γ3) where the GSA Γ3 is shown in Fig.1.15.
Fig. 1.15 Initial GSAΓ3
y1 y2
1
0
1
0
Start
x1
1
0
x3
x2
b0
b1
b3
b10
b8
b2
y2 y4
b9
END
bE
y3
y3
b4
y6
b7
y2 y4
b5
y3 y5
b6
y2 y4
y1 y2
b13
b11
b12
y3
b14
y3

18
1
Background of Finite State Machines and Programmable Logic
There are the following steps in logic synthesis of CMCU U1 [12]:
1. Constructing the set C of OLCs for a GSA Γ .
2. Executing the natural addressing (1.27).
3. Constructing the table of BIMF.
4. Constructing the table of BMO.
5. Implementing the CMCU logic circuit with particular logic elements.
There are two steps in executing the step 1. Firstly, it should be found the set of
main inputs MI(Γj). Secondly, a set C is constructed using elements of MI(Γj) as
main inputs of OLC αg ∈C. To ﬁnd the set MI(Γj), they should use the Deﬁnition 1.3.
In the discussed case, there are the following sets: the set of vertices V(Γ3) =
{b0, b1, . . . , b14, bE}; the set of operator vertices V0(Γ3) = {b1, b2, b4, . . . , b7, b9,
b11, . . . , b14} having M1(Γ3) = 11 elements; the set of conditional vertices Vc(Γ3) =
{b3, b8, b10}. Using the Deﬁnition 1.3, it can be found the set MI(Γ3) = {b1, b4,
b11, b9}.
Let us form the chain αg starting from b1. In the ﬁrst step, there is α1 = ⟨b1⟩.
There is an edge ⟨b1, b2⟩∈E where b2 ∈V0(Γ3). The vertex b2 is not included into
already constructed OLCs. So, now we have α1 = ⟨b1, b2⟩∈E. There is an edge
⟨b2, b3⟩∈E where b3 ∈Vc(Γ1). Using the Deﬁnition 1.4 we can ﬁnd that b3 is the
output of OLC α1. Using the same approach, the set C = {α1, . . . , α4} is constructed
where α1 = ⟨b1, b2⟩, α2 = ⟨b4, . . . , b7⟩, α3 = ⟨b9⟩, and α4 = ⟨b11, . . . , b14⟩. So,
there is G = 4.
It is enough R2 bits for addressing microinstructions of U1(Γj):
R2 = ⌈log2 M1(Γj)⌉.
(1.28)
There is R2 = 4 in the discussed case. It gives the sets T = {T1, . . . , T4} and Φ =
{D1, . . . , D4}. Table1.5 contains OLCs, vertices and addresses of corresponding MIs
for CMCU U1(Γ3).
To construct the table of BIMF, let us ﬁnd the formulae of transitions for the
vertices bg ∈O(Γ3) = {b2, b7, b9, b14}. The rules from [6, 7] are used for executing
this procedure. There are the following FTs in the discussed case:
b2 →x1b4 ∨¯x1x2b5 ∨¯x1 ¯x2b11;
b7 →x3b4 ∨¯x3b9;
b9 →bE;
b14 →b7.
(1.29)
Table 1.5 Outcome of natural addressing for U1(Γ3)
OLCs
α1
α2
α3
α4
Vertices
b1
b2
b4
b5
b6
b7
b9
b11
b12
b13
b14
Addresses
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010

1.4 Logic Synthesis for Compositional MCUs
19
Table 1.6 Table of BIMF for CMCU U1(Γ3)
bq
A(bq)
bt
A(bt)
Xh
Φh
h
b2
0001
b4
0010
x1
D3
1
b5
0011
¯x1x2
D3D4
2
b11
0111
¯x1 ¯x2
D2D3D4
3
b7
0101
b4
0010
x3
D3
4
b9
0110
¯x3
D2D3
5
b14
1010
b7
0101
1
D2D4
6
Let us point out that the transition ⟨b9, bE⟩is executed using yE = 1. So, this
transition is not placed into the table of BIMF for U1(Γ3). There are the following
columns in the table of BIMF: bq is the output of an OLC αg ∈C; A(bq) is the address
of an MI corresponding to the vertex bq; bt is the input of an OLC αi ∈C; A(bt) is the
address of MI corresponding to bt; Xh is a conjunction of logical conditions xe ∈X
taken from the corresponding term of FT; Φh is a set of input memory functions
equal to 1 to load the address A(bt) into CT; h is the number of transition.
There are 6 terms in the system (1.29) for FTs b2, b7 and b14. So, there are 6
lines in the table of BIMF for the discussed case (Table1.6). There is the obvious
connection between the system (1.29) and Table1.6. The addresses of MIs are taken
from Table1.5.
The BIMF implements the functions (1.4). They depend on terms Fh correspond-
ing the rows of table of BIMF. It is possible to simplify the functions Dr ∈Φ using
the rules of Boolean algebra [31] and “don’t care” combinations of variables Tr ∈T.
In the discussed case, there are the following “don’t care” combinations: 1011, 1100,
1101, 1110, 1111. It follows from Table1.5.
The following equations can be extracted from Table1.6:
D1 = T1T3;
D2 = ¯T1 ¯T2 ¯T3T4 ¯x1 ¯x2 ∨T2 ¯T3T4 ¯x3;
D3 = ¯T1 ¯T3T4;
D4 = ¯T1 ¯T2 ¯T3T4 ¯x1 ∨T1T3.
(1.30)
There are the following columns in the table of BMO: bq is a vertex of GSA Γ ;
A(bq) is an address of MI corresponding to the vertex bq ∈V0(Γj); y0; Y(bq); yE.
There is y0 = 1 for all MIs which do not correspond to outputs of OLC αg ∈C.
There is yE = 1 for all MIs corresponding to vertices bq ∈O(Γj) such that there is
an edge ⟨bq, bE⟩∈E. Using these rules, we construct Table1.7.
The circuit of BMO is implemented using memory blocks [12]. We do not discuss
now this problem. The circuit of BIMF is implemented using expressions similar to
(1.30).
Let us discuss how to control the counter CT. It has two inputs of synchronization.
Let C1 be an input such that pulse Clock causes the adding 1 to the content of CT.

20
1
Background of Finite State Machines and Programmable Logic
Table 1.7 Table of BMO for CMCU U1(Γ3)
bq
A(bq)
y0
Y(bq)
yE
T1
T2
T3
T4
y1
y2
y3
y4
y5
y6
b1
0
0
0
0
1
1
1
0
0
0
0
0
b2
0
0
0
1
0
0
0
1
0
0
0
0
b4
0
0
1
0
0
0
0
1
0
0
0
0
b5
0
0
1
1
1
0
1
0
1
0
0
0
b6
0
1
0
0
1
0
0
1
0
1
0
0
b7
0
1
0
1
0
0
0
0
0
0
1
0
b9
0
1
1
0
0
0
1
0
1
0
0
1
b11
0
1
1
1
1
0
1
0
1
0
0
0
b12
1
0
0
0
1
0
0
1
0
0
0
0
b13
1
0
0
1
1
1
1
0
0
0
0
0
b14
1
0
1
0
0
0
0
1
0
0
0
0
Fig. 1.16 Organization of
counter for CMCU U1(Γ3)
Start
Clock
C C2
1
y0
CT
C C R
1
2
D1 D D D
2
3
4
D1 D D D
2
3
4
T4
T3
T2
T1
1
2
4
3
Let C2 be an input such that pulse Clock causes the loading an address A(bt) into
CT. The following equations can be obtained for C1 and C2:
C1 = y0 · Clock;
C2 = ¯y0 · Clock.
(1.31)
Using these equations, the following circuit (Fig.1.16) can be obtained for the
CT.
There is a feed-back between CT and BIMF (Fig.1.14). It means that variables
y0 and yE can be generated by BIMF. For example, the following Karnaugh map
(Fig.1.17) corresponds to the variable y0 of CMCU U1(Γ3).
It is possible to ﬁnd out the following minimized SOP of y0: y0 = ¯T3 ¯T4 ∨T1 ¯T3 ∨
¯T1
¯
T2T3. Using the same approach, it is possible to ﬁnd that yE = T2 ¯T3T4.
Let us point out that CMCU is used only for interpreting so named linear GSAs
[12]. There is more than 75% of operator vertices in linear GSAs. There are many
models of CMCU corresponding to different conditions [4]. Now, they do not use
MCU in logic design [37]. But some methods are still used such as: (1) replacement

1.4 Logic Synthesis for Compositional MCUs
21
Fig. 1.17 Karnaugh map for
variable y0
of logical conditions(it is executed by SFA); (2) maximal encoding of CMOs Yt ⊆Y;
(3) encoding of the ﬁelds of compatible microoperations [2, 3]. We will show a bit
later how those methods are used in the modern logic design.
Our book is devoted to design of MPAs. We will call them FSMs. We will discuss
some methods of hardware reduction targeting the technology of ﬁeld-programmable
gate arrays (FPGA). Some of these methods are taken from design of FSM targeting
different devices of programmable logic. Let us discuss these methods.
1.5 Hardware Reduction for FPLD-Based FSMs
There is a connection among types of ﬁeld-programmable logic devices (FPLD) and
methods of hardware reduction [8]. In this section, we discuss the following FPLD:
programmable read-only memory (PROM), programmable logic arrays (PLA), pro-
grammable array logic (PAL) and complex programmable logic devices (CPLD). An
FPLD is a general purpose chip whose hardware can be conﬁgured by an end user.
PROMs are the ﬁrst representatives of FPLDs. The ﬁrst PROMs were produced
by Harris Semiconductor in 1970 [12, 16]. They include a ﬁxed array of AND-gates
(AND-array) and a programmable array of OR-gates (OR-array). The AND-array
is an address decoder (DC) of a chip. PROMs are used for implementing regular
systems of Boolean functions [10] represented by truth tables. A PROM has a ﬁxed
amount of address inputs (SA) and outputs (tF). PROMs can be used in PY, PD and
PH models of FSMs (Fig.1.18) [12, 16].
In the case of P Moore FSM (Fig.1.18a), PROM implements the circuit of BMO.
It is denoted as PROM Y. The PY Mealy FSM (Fig.1.18b) is based on the maximal
encoding of CMOs taken from MCU design methods [12, 16].
Let it be T0 different CMOs in the vertices bq ∈V0(Γj). Let us encode each CMO
yt ⊆Y by a binary code C(Yt) having RZ bits:
RZ = ⌈log2 T0⌉.
(1.32)
Let us use variables zr ∈Z for the encoding, where |Z| = RZ. In this case, the
variables zr ∈Z are connected with address inputs of PROMY, whereas the functions
yn ∈Y are the outputs of PROMY.

22
1
Background of Finite State Machines and Programmable Logic
(a)
(b)
(d)
(c)
Fig. 1.18 Models of FSMs using PROM
They used the method of encoding of ﬁelds of compatible microoperations in
microprogramming [20]. Microoperations yn, ym ∈Y are compatible if they do not
belong to the same CMOs:
(yn ∈Yt →ym /∈Yt) = 1(t = 1, T0).
(1.33)
The set Y is divided by subsets Y1, . . . , YK of compatible MOs such that:
K
k=1
Yk = Y;
Yi ∩Yj = ∅(i ̸= j; i, j ∈{1, . . . , K});
K
k=1
log2(|Yt| + 1) →min.
(1.34)
Each set Yk corresponds to a ﬁeld in the control memory having Rk bits:
Rk = ⌈log2(|Yk| + 1)⌉.
(1.35)
The third line of (1.34) means that the partition of Y should minimize the number of
bits in the ﬁeld FY.
Microoperations yn ∈Yk are encoded by binary codes C(yn) having Rk bits and
using variables from set Zk, where |Zk| = Rk(k = 1, K). Next, the content of each
ﬁeld FYk is decoded by a decoder DCk. These decoders form the block D of an
MCU.

1.5 Hardware Reduction for FPLD-Based FSMs
23
Using this approach, the PD Mealy FSM can be organized (Fig.1.18c). The CMOs
Yt ⊆Y are encoded by variables zr ∈Z, where |Z| = RZ. The microoperations
yn ∈Y are encoded by variables zr ∈Z, where |Z| = RK:
RK =
K
	
k=1
Rk.
(1.36)
The PROM D transforms codes C(Yt) into codes K(Yt) where
K(Yt) = C(yn)1 ∗C(yn)2 ∗· · · ∗C(yn)K.
(1.37)
In (1.37), the symbol C(yn)t stands for a code of MO from the ﬁeld Yk(k = 1, K).
The BMO executes functions of decoding for microoperations yn ∈Y. There are
different approaches to implement this block. For example, they can use standard
decoders [9].
In the case of PH Mealy FSM (Fig.1.18d), they encode the functions Fh (1.8)
corresponding to rows of ST. Let us encode each term Fh by a binary code C(Fh)
having RH bits:
RH = ⌈log2 H0⌉.
(1.38)
Let us use the variables zr ∈Z for such encoding, where |Z| = RH. These variable
enter the PROMH generating functions
Φ = Φ(Z);
(1.39)
Y = Y(Z).
(1.40)
The PH Mealy FSM corresponds to the “one-hot” encoding of MOs [20]. In this
case, exactly one bit of PROM corresponds to a single MO yn ∈Y. If CMOs are
encoded, then two models of Mealy FSM are possible. A PHY FSM corresponds to
the maximal encoding of MOs; a PHD FSM corresponds to encoding of the ﬁelds
of compatible MOs.
The PH-models are not used in the case of Moore FSMs. It is connected with the
following condition:
R1 ≤⌈log2 H1⌉.
(1.41)
Programmable logic arrays were introduced in the mid 1970s by Signetics. They
were oriented towards the implementing systems of Boolean functions (SBF) repre-
sented in minimized SOP forms [6]. The peculiarity of PLA is a programmability of
both its arrays (Fig.1.19a).

24
1
Background of Finite State Machines and Programmable Logic
AND
OR
1
S
1
t
1
2
q
1
S
1
q
1
1
q
t
(a)
(b)
Fig. 1.19 Architectures of PLA (a) and PAL (b)
A PLA has S inputs and t outputs. It is possible to implement q conjunctions
of inputs named “product terms”. The sign “×” in Fig.1.19 stands for a connection
between two wires. Let terms Fj depend on input variables xi. Each term Fj can be
represented as:
Fj =
S
i=1
xei
i
(j = 1, q; i = 1, S).
(1.42)
In (1.42), li ∈{0, 1, ∗} is a value of an input xi, where x0
i = ¯xi, x1
i = xi, x∗
i = 1.
Let us denote output functions of PLA as yk(k = 1, t). Each function yk is repre-
sented as
yk =
q
j=1
CjqFj (k = 1, t).
(1.43)
In (1.43), Cjq is a Boolean variable equal to 1 iff the term Fj enters the SOP of yk.
So, PLAs are very ﬂexible devices. As a rule, they have S ≤16, t ≤8, q ≤48
[9]. They were used for implementing combinational parts of FSMs [6].
Let the following conditions take places:
S ≥L + R0;
t ≥N + R0;
q ≥H0.
(1.44)
In this case, a P Mealy FSM is implemented in a trivial way using only a single PLA
chip (Fig.1.20a).

1.5 Hardware Reduction for FPLD-Based FSMs
25
Fig. 1.20 Trivial (a) and
single-level (b) circuits of P
Mealy FSM
PLA
X
Y
T
Start
Clock
RG
Start
Clock
RG
PLA1
PLAI
X1
XI
Y
1
Y
I
T
1
I
(a)
(b)
If conditions (1.44) are violated, then a single-level circuit (Fig.1.20b) can be
implemented [6]. It corresponds to a partition ΠF of set of SOP having minimal
numberofblocksE1, . . . , EI whereeachblocksatisﬁestothefollowingcondition[6]:
|Xi| + R0 ≤S;
|Yi| + |Φi| ≤t;
|Ei| ≤q.
(1.45)
In (1.45), Xi ⊆X is a set of logical conditions which are signiﬁcant for functions
implemented by PLAi(i = 1, I). Also Φi ⊆Φ, Yi ⊆Y are subsets of input memory
functions and microoperations depended on terms Ei and generated by PLAi(i =
1, I).
The single-level P FSMs are the fastest among all possible solutions [6]. But they
are the most expensive because different PLAs can have the same input and output
variables.
To decrease the number of chips, multi-level circuits of FSMs were proposed.
They used the following methods [6, 13, 17]:
1. Replacement of logical conditions.
2. Maximal encoding of the collections of MOs.
3. Maximal encoding of rows of ST.
Let us discuss the ﬁrst approach. Let the transitions from a state am ∈A depend
on logical conditions forming a set X(am) ⊆X. Let it be Lm = |X(am)|(m = 1, M)
and G = max(L1, . . . , LM). Let us form a new set P of additional variables pg ∈P,
where |P| = G. Let us replace the variables xe ∈X by the variables pg ∈P using
the following system of Boolean functions:
pg =
M

m=1
L

L=1
CmeAmxe(g = 1, G).
(1.46)
In (1.46), the Boolean variable Cme = 1 iff a variable pg ∈P replaces the variable
xe ∈X in the set X(am).

26
1
Background of Finite State Machines and Programmable Logic
Fig. 1.21 Structural diagram of MP Mealy FSM
Fig. 1.22 Structural diagram of MPY Mealy FSM
Now it is possible to implement an MP Mealy FSM (Fig.1.21) where the block
of replacement of logical conditions (BRLC) implements the system (1.46).
They use PLAs for implementing circuits of BRLC and BIMF. The BRLC is
represented by a system:
P = P(T, X).
(1.47)
The BIMF is represented by systems:
Y = Y(T, P);
(1.48)
Φ = Φ(T, P).
(1.49)
Using the maximal encoding of CMOs leads to PY Mealy FSMs. Using the
maximal encoding of rows of ST leads to PH Mealy FSMs. Three-level FSM circuits
are possible. For example, the organization of MPY Mealy FSM is shown in Fig.1.22.
In this case, the BRLC implements the system (1.47). The BIMF implements the
system (1.48) and the system
Z = Z(T, P).
(1.50)
The BMO implements the system (1.40).
Let us point out that such a representation of an FSM is named the structural
decomposition [11, 37]. If the circuits of all blocks are implemented with PLAs, it
is a homogeneous circuit [37]. But it is possible to diminish the amount of FPLDs
in the FSM circuit using so called heterogeneous FSMs.

1.5 Hardware Reduction for FPLD-Based FSMs
27
For example, there are the following chips in the heterogeneous MPY Mealy
FSM: standard multiplexers (MX) implement the circuit of BRLC; PLAs implement
the circuit of BIMF; the PROMs implement the circuit of BMO.
As it is pointed before, the programmability of AND-array makes PLAs very
ﬂexible. But, on the other hand, it leads to increasing a chip area because of a lot of
fuses [12].
Functions (1.3) and (1.4) belong to the class of functions deﬁned only for a small
fraction of possible input assignments. Moreover, each of functions yn ∈Y and
Dr ∈Φ appears very rarely in the structure table of FSM. It means that PLAs are
very redundant for implementing, for example, input memory functions. But such
functions can be very efﬁciently implemented using PAL chips [18].
PALs were introduced by Monolithic Memories in 1978 [16]. They include the
programmable AND-array and t ﬁxed OR-gates (Fig.1.19b). One of the new con-
ceptions connected with PAL is the conception of a macrocell. The macrocell is a
part of the PAL chip connected with a single output of the chip. Each macrocell has
S inputs and one output; a PAL chip has S inputs and t outputs (macrocells). Each
macrocell has q terms, as a rule, there is q ≤8.
The same FSM structures can be used for both PAL and PLA-based solutions.
But it should be executed the joint minimization of SBF representing PLA-based
circuits. In the case of PAL, each function is minimized separately, to diminish the
number of its product terms up to q.
It is necessary to have the external state register to keep the state codes. It requires
additional connections on a printed board with an FSM circuit. But this register
can be eliminated if some part of a chip area is occupied by ﬂip-ﬂops. It leads to
programmable logic sequencers (PLS) in the case of PLAs and to generic array logic
(GAL) in the case of PALs [16]. There is a GAL-oriented P Mealy FSM shown in
Fig.1.23.
Using GALs and PLSs, it is possible to represent an FSM as a network of inter-
connected partial FSMs. It is a decomposition of FSM circuit [6, 7]. For example,
some FSM S is decomposed by three FSMs (S1 −S3). Each FSM Si is character-
ized by sets Xi ⊆X and Yi ⊆Y. To evoke the FSM Si, they use the control signal
Ei(i = 1, 3) (Fig.1.24).
Further evolution of electronic technology allows tremendous increasing for the
numbers of transistors per chip [35, 38]. It results in appearance of such FPLDs
Fig. 1.23 Structural
diagram of GAL-oriented P
Mealy FSM
Start
Clock
GAL
x
Y

28
1
Background of Finite State Machines and Programmable Logic
Start
Clock
Start
Clock
Start
Clock
E2
E1
E1
E3
E3
X
3
X
2
X
1
Y
3
Y
2
Y
1
E2
S1
S2
S3
Fig. 1.24 Mealy FSM as a network of FSMs
I/O
I/O
I/O
I/O
PIA
Fig. 1.25 Structural diagram of CPLD
as FPGAs and CPLDs. Now, they are the most popular families of FPLDs used
in logic design [21, 29, 30, 33, 34]. The next chapter, as the rest of the book, is
devoted to FPGA-based design methods. Here we just brieﬂy describe CPLDs. The
vast majority of CPLDs are organized as a simple PAL-cell matrix, a programmable
interconnection array (PIA) and blocks of input-outputs connected with macrocells
(Fig.1.25).
The typical macrocell includes three main blocks: programmable AND-array,
logic allocator and programmable ﬂip-ﬂop (Fig.1.26). The logic allocator connects
product terms with OR-gate. It allows having different amount of terms in macro-
cells. This property makes macrocells more ﬂexible in comparison with macrocells
with ﬁxed amount of product terms. There are two possibilities for organization of
a macrocells. It can have the combinational output (if a ﬂip-ﬂop is bypassed) or
registered output. The output can be connected with I/O blocks or with PIA. The
connection with PIA allows creating feed-backs in the ﬁnal project. As a rule, there
is a tri-stable buffer between the output of a macrocell and I/O block. It is controlled
by a combinational circuit belonging to a macrocell.
In Fig.1.26, the MX1 executes the choice between the combinational (fc) and
registered (fR) outputs of a macrocell. The MX2 makes choice between the output
fm, the output of tri-stable buffer and the data from I/O block.
A lot of technology-dependent methods of FSM design can be found in [14, 19,
22–28, 39–41]. For example, the tri-stable buffer can be used for organization of

1.5 Hardware Reduction for FPLD-Based FSMs
29
MX1
MX2
fc
fR
fm
1
S
Logic
Allocator
TT
D
C
R
I/O
Fig. 1.26 Typical structure of PAL-based macrocell
term expansion without creating multi-level FSM circuits [19]. The wide fan-in of
PAL-macrocells allows using more than one source of state codes [15]. We discuss
this approach in other parts of this book.
So, to design an FSM circuit with desirable characteristics, it is necessary to take
into account the following speciﬁcs:
1. Speciﬁc features of logic elements used for implementing logic circuits. For
example, it is possible to use two or three sources of state codes due to the wide
fan-in of PAL macrocells.
2. Speciﬁc features of an FSM model. For example, it is possible to use memory
blocks for implementing the system of output functions for Moore FSMs.
3. Speciﬁc features of a GSA Γ representing the FSM behaviour. For example, it is
possible to use a counter instead of the state register for linear GSAs.
In further chapters, we show how to use these speciﬁcs in the case of FPGA-based
FSMs.
References
1. M. Adamski, A. Barkalov, Architectural and Sequential Synthesis of Digital Devices (Univer-
sity of Zielona Góra Press, Zielona Góra, 2006)
2. T. Agerwala, Microprogram optimization: a survey. IEEE Trans. Comput. 25(10), 962–973
(1976)
3. A. Agrawala, T. Rauscher, Foundations of Microprogramming (Academic Press, New York,
1976)
4. F. Anceau, The Architecture of Microprocessors (Addison-Wesley, Workingham, 1986)
5. P. Asahar, S. Devidas, A. Newton, Sequential Logic Synthesis (Kluwer Academic Publishers,
Boston, 1992)
6. S. Baranov, Logic Synthesis of Control Automata (Kluwer Academic Publishers, Dordrecht,
1994)
7. S. Baranov, Logic and System Design of Digital Systems (TUT Press, Tallinn, 2008)
8. A. Barkalov, Microprogram control unit as composition of automate with programmable and
hardwired logic. Autom. Comput. Sci. 17(4), 36–41 (1983)
9. A. Barkalov, Multilevel PLA schemes for microprogram automata. Cybern. Syst. Anal. 31(4),
489–495 (1995)

30
1
Background of Finite State Machines and Programmable Logic
10. A. Barkalov, Principles of logic optimization for Moore microprogram automaton. Cybern.
Syst. Anal. 34(1), 54–60 (1998)
11. A. Barkalov, A. Barkalov Jr, Design of Mealy ﬁnite-state machines with the transformation of
object codes. Int. J. Appl. Math. Comput. Sci. 15(1), 151–158 (2005)
12. A. Barkalov, L. Titarenko, Logic Synthesis for Compositional Microprogram Control Units,
vol. 22 (Springer, Berlin, 2008)
13. A. Barkalov, L. Titarenko, Logic Synthesis for FSM-Based Control Units. Lecture Notes in
Electrical Engineering, vol. 53 (Springer, Berlin, 2009)
14. A. Barkalov, L. Titarenko, S. Chmielewski, Reduction in the number of PAL macrocells int
the circuit of a Moore FSM. Int. J. Appl. Math. Comput. Sci. 17(4), 565–675 (2007)
15. A. Barkalov, L. Titarenko, S. Chmielewski, Hardware reduction in CPLD-based Moore FSM.
J. Circuits, Syst., Comput. 23(6), 1450086–1–1450086–21 (2014)
16. A. Barkalov, M. We˛grzyn, Design of Control Units With Programmable Logic (University of
Zielona Góra Press, Zielona Góra, 2006)
17. A. Barkalov, I. Zelenjova, Optimization of replacement of logical conditions for an automaton
with bidirectional transitions. Autom. Control Comput. Sci. 34(5), 48–53. Allerton Press Inc
18. S. Chmielewski, Using structural pecularities of Moore FSM for reduction of number of PALS.
PhD thesis, University of Zielona Góra (2014)
19. R. Czerwinski, D. Kania, Finite State Machine Logic Synthesis for Complex Programmable
Logic Devices. Lecture Notes in Electrical Engineering, vol. 23 (Springer, Berlin, 2013)
20. S. Husson, Microprogramming: Principles and Practices (Prentice Hall, Englewood Cliffs,
1970)
21. J. Jenkins, Design with FPGAs and CPLDs (Prentice Hall, New York, 1995)
22. D. Kania, Two-level logic synthesis on PAL-based CPLD and FPGA using decomposition, in
Proceedings of 25th Euromicro Conference (1999), pp. 278–281
23. D. Kania, Two-level logic synthesis on PALs. Electron. Lett. 17, 879–880 (1999)
24. D. Kania, Coding capacity of PAL-based logic blocks included in CPLDs and FPGAs, in
Proceedings of IFAC Workshop on Programmable Devices and Sysytems (PDS’2000) (Elsevier
Science, 2000), pp. 164–169
25. D. Kania, Decomposition-based synthesis and its application in PAL-oriented technology map-
ping, in Proceedings of 26th Euromicro Conference (IEEE Compuetr Society Press, Maastricht,
2000), pp. 138–145
26. D. Kania, An efﬁcient algorithm for output coding in PAL-based CPLDs. Int. J. Eng. 15(4),
325–328 (2002)
27. D. Kania, Logic synthesis of multi–output functions for PAL-based CPLDs, in Proceedings of
IEEE International Conference on Field-Programmable Technology (2002), pp. 429–432
28. D. Kania, An efﬁcient approach to synthesis of multi-output Boolean functions on PAL-based
devices. IEEE Proc.—Comput. Digital Tech. 150, 143–149 (2003)
29. C. Maxﬁeld, The Design Warrior’s Guide to FPGAs (Academic Press Inc., Orlando, 2004)
30. C. Maxﬁeld, FPGAs: Instant Access (Newnes, 2008)
31. E. McCluskey, Logic Design Principles (Prentice Hall, Englewood Cliffs, 1986)
32. G. De Micheli, Synthesis and Optimization of Digital Circuits (McGraw–Hill, New York, 1994)
33. P. Minns, I. Elliot, FSM-Based Digital Design Using Verilog HDL (Wiley, Chichester, 2008)
34. Z. Navabi, Embedded Core Design with FPGAs (McGraw–Hill, New York, 2007)
35. K. Sakamura, Future SoC possibilities. IEEE Micro. (5), 7 (2002)
36. A. Salisbury, Microprogrammable Computer Architectures (Elsevier Science, New York, 1976)
37. V.Sklyarov,I.Skliarova,A.Barkalov,L.Titarenko,SynthesisandOptimizationofFPGA-Based
Systems. Lecture Notes in Electrical Engineering, vol. 294 (Springer, Berlin, 2014)
38. M. Smith, Application-Speciﬁc Integrated Circuits (Addison-Wesley, Boston, 1997)
39. V. Solovjev, M. Czyzy, Reﬁned CPLD macrocells architecture for effective FSM implemen-
tation, in Proceedings of the 25th EUROMICRO Conference, vol. 1 (Milan, Italy, 1999), pp.
102–109
40. V. Solovjev, M. Czyzy, The universal algorithm for ﬁtting targeted unit to complex program-
mable logic devices, in Proceedings of the 25th EUROMICRO Conference, vol. 1 (Milan, Italy,
1999), pp. 286–289

References
31
41. V. Solovjev, M. Czyzy, Synthesis of sequential circuits on programmable logic devices based
on new models of ﬁnite state machines, in Proceedings of the EUROMICRO Conference, Milan
(2001), pp. 170–173
42. S. Tucker, Microprogram control for system/360. IBM Syst. J. 6(4), 222–241 (1967)
43. T. Villa, T. Kam, R. Brayton, A. Sangiovanni-Vincentelli, A Synthesis of Finite State Machines:
Logic Optimization (Kluwer Academic Publishers, Boston, 1998)
44. M. Wilkes, The best way to design an automatic calculating machine, in Proceedings of
Manchester University Computer Inaugural Conference (1951)
45. M. Wilkes, J. Stringer, Microprogramming and the design of the control circuits in an electronic
digital computer. Proc. Camb. Philos. Soc. 49, 230–238 (1953)
46. S. Yanushkevich, V. Shmerko, Introduction to Logic Design (CRC Press, Boca Raton, 2008)

Chapter 2
Field Programmable Gate Arrays in FSM
Design
2.1 General Characteristic of FPGAs
The ﬁeld programmable gate arrays (FPGA) were introduced in 1984 [53] by Xilinx.
It is very hard to overestimate the FPGA inﬂuence on different areas of electrical
engineering [77]. These chips are very ﬂexible due to their property of reconﬁgura-
bility. Contemporary FPGA chip can replace billions of 2NAND gates [54], called
system gates. In the beginning, FPGAs were used for implementing such parts of
electrical circuits as glue logic. Now, these chips have up to 7 billion transistors [75],
possess clock frequency exceeding the Gigahertz. The most advanced FPGAs have
the technology less than 20nm [2, 52, 58, 64, 89].
First FPGAs, XC2064, were produced by Xilinx in 1985. They included up to
85 000 transistors, 128 logic cells, 64 conﬁgurable logic blocks; they have the clock
frequencyupto50MHz.Buttheymadehugeprogressandnowtheyareverypowerful
devices.
To show this progress, let us start from the family Spartan-3 of Xilinx [89].
These chips were introduced in 2002, were powered by 1, 2 V and used the 90nm
technology.Theyincludedlook-uptable(LUT)elementshaving4inputs.Thesechips
included up to 104 embedded memory blocks named blocks of RAMs (BRAM). So,
it was up to 1,87 Mbits of BRAMs in these FPLDs. They operated with the frequency
from 25 MHz till 325 MHz. Each chip was equivalent from 50 000 to 5×106 system
gates (SG). Some characteristics of Spartan-3 family are shown in Table2.1.
The last column of Table2.1 includes the capacity of memory distributed among
LUTs of the chip. It is named distributed RAM (DRAM).
In this chapter we discuss only the basic features of FPGAs relevant to imple-
menting logic circuits of control units. Let us analyse peculiarities of LUT-based
FPGAs. As a rule, typical FPGAs include four main elements: conﬁgurable logic
blocks (CLB) based on LUTs; matrix of programmable interconnections (MPI);
input-output blocks (IOB) and embedded memory blocks. The organization of an
FPGA chip is shown in Fig.2.1.
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_2
33

34
2
Field Programmable Gate Arrays in FSM Design
Table 2.1 Characteristics of Spartan-3 family
Device
Number
Number
Capacity of
Capacity of
of CLBs
of SGs (K)
BRAMs, bits (K)
DRAM, bits (K)
XC3S50
1 728
50
72
12
XC3S200
4 320
200
216
30
XC3S400
8 064
400
288
56
XC3S1000
17 280
1000
432
120
XC3S1500
29 952
1500
576
208
XC3S2000
46 080
2000
720
320
XC3S4000
62 208
4000
1728
432
XC3S5000
74 880
5000
1872
520
Fig. 2.1 Simpliﬁed
organization of FPGA
Fig. 2.2 Simpliﬁed
organization of CLB
As a rule, LUTs are based on RAM having limited amount of inputs S (S≤6).
A single LUT can implement an arbitrary Boolean function depended on L input
variables (L≤S) and represented by a truth table. A typical CLB included a single
LUT, programmable ﬂip-ﬂop (FF), multiplexer (MX) and logic of clock and set-reset
(LCSR). The simpliﬁed structure of CLB is shown in Fig.2.2.
The output of LUT is connected with FF which could be programmed as D, JK
or T ﬂip-ﬂop. The FF could be by-passed due to programmable MX. So, the output
Oi of a CLB can be either combinational or registered. The existence of ﬂip-ﬂops
allows organization of either registers or counters. Both these devices are used for
FSM implementation.

2.1 General Characteristic of FPGAs
35
Fig. 2.3 Structure diagram of a slice of Virtex-4 family
With development of technology, more and more sophisticated CLBs were intro-
duced. Let us discuss, for example the CLB of Virtex-7. It includes 4 slices having
fast interconnections. A slice includes 2 LUTs, 4 multiplexers, arithmetic logic and
2 programmable ﬂip-ﬂops (Fig.2.3).
This slice includes 2 LUTs; each of them has S = 4 inputs. Each LUT can
implement an arbitrary logic function depended on 4 variables. Using the multiplexer
FS, both LUTs are viewed as a single LUT having S = 5. The multiplexer FX
combines together outputs of FS and FX from other slices. So, a slice can implement
a Boolean functions depending on 5 variables; two slices on 6 variables; four slices (a
CLB) on 7 variables. The arithmetic block allows organizing adders and multipliers.
Multiplexers Y and X determine input data for programmable ﬂip-ﬂops. So, each
CLB can include either RG or CT.
The number of inputs per a LUT is increased up to 5 for Virtex-5 family, whereas
CLBs of Virtex-6 and Virtex-7 include LUTs having S = 6. There are different mod-
iﬁcations of FPGAs for each family. We do not discuss them. Some characteristics
of modern FPGA chips by Xilinx are shown in Table2.2.
Analysis of Tables2.1 and 2.2 proves our statement about the tremendous progress
in FPGAs. Let us point out that modern chips include blocks of digital signal proces-
sors and central processing units. But these blocks are not used for FSM design. So,
we do not discuss them.
At present, ﬁve companies dominate on the FPGA market: Xilinx, Altera, Lattice
Semiconductor, Microsemi and Quicklogic. It can be found all necessary data about
products of these companies on their homepages [2, 52, 58, 64, 89].
As follows from Table2.2, there are powerful EMBs in the modern FPGAs. They
have a property of conﬁgurability. It means that such parameters as number of mem-
ory cells (V ) and their outputs (tF) can be changeable. Of course, there is the constant
size (Vo) of an EMB. Now, there are the following typical conﬁgurations of EMBs:

36
2
Field Programmable Gate Arrays in FSM Design
Table 2.2 Characteristics of FPGAs by Xilinx
Family
Modiﬁcation
Number
Capacity of
Capacity of
Technology,
of Slices
BRAMs, k bits
DRAM, k bits
nm
Virtex-4
LX
10752–89088
1296–6048
168–1392
90
SX
10240–24576
2304–5760
160–384
FX
5472–63168
648–9936
86–987
Virtex-5
LX
4800–51840
1152–10368
320–3420
65
LXT
3120–51840
936–11664
210–3420
SXT
5440–37440
3024–18576
520–4200
TXT
17280–24320
8208–11664
1500–2400
FXT
5120–30720
2448–16416
380–2280
Virtex-6
LXT
11640–118560
5616–25920
1045–8280
40
SXT
49200–74400
25344–38304
5090–7640
HXT
39360–88560
18144–32832
3040–6370
CHT
11640–37680
5616–14976
1045–3650
Virtex-7
T
44700–305400
14760–46512
3475–21550
28
XT
64400–135000
31680–64800
6525–13275
HT
45000–135000
21600–64800
4425–13275
Fig. 2.4 Karnaugh map for
system Y
36K ×1, 18K ×2, 8K ×4, 4K ×8, 2K ×16, 1K ×32 and 512 ×64 (bits) [2, 52,
58, 64, 89]. Let us discuss how these blocks can be used in logic design.
Let an EMB contain V cells having tF outputs. Let Vo be a number of cells if
there is tF = 1. So, the number V can be determined as
V = ⌈Vo/tF⌉.
(2.1)
Let us point out that decreasing tF by 1 leads to doubling for the number of cells
(and vice versa).
Embedded memory blocks could be used for implementing regular functions [8].
Let us discuss the Karnaugh map (Fig.2.4) corresponding to Table1.3.
The following functions can be found from this map:
y1 = T1 ∨¯T2T3;
y2 = ¯T1T3 ∨T1 ¯T3;
y3 = T2; y4 = T1T3.
(2.2)

2.1 General Characteristic of FPGAs
37
(a)
(b)
Fig. 2.5 Logic circuit for system (2.2)
Let us use system gates (LUTs with s = 2) for implementing the system (2.2).
From Fig.2.2 the following negative features could be seen: (1) different propa-
gation time for different output functions; (2) input variables should be connected
with more than one logic element. The second feature leads for necessity of bigger
value of fan-out for inputs T1–T3 than in the case when each input is connected only
with a single logic element. Also, it leads to complications in the routing process.
If an EMB is used for implementing the system (2.2), all these problems are
absent (Fig.2.5b). Each input Tr (r = 1, 3) is connected only with a single input of
EMB. All functions yn (n = 1, 4) have the same propagation time. This example is
very simple. But a simple EMB having the conﬁguration 512 × 64 could replace at
least 64 LUTs. It is possible if a system Y depends on 9 inputs and includes up to
64 different functions. Of course, the circuit includes 64 LUTs having S = 9. But
there is no such LUTs in modern FPGAs. If minimization allows dependence of each
function yn ∈Y on 8 variables, then 256 LUTs with S = 6 are necessary for creating
a logic circuit.
In a typical FPGA 60% of power is consumed by the programmable interconnects,
16% is consumed by programmable logic and 14% by the clock distribution [14].
Replacement of LUTs by EMBs allows decreasing of the number of interconnections.
So, it is very important to use EMBs in implementing FSM circuits.
The exceptional complexity of FPGA requires using computer-aided design
(CAD) tools for designing logic circuits [41]. It assumes development of formal
methods for synthesis and veriﬁcation of control units [36, 37, 43, 59]. For example,
a design process for FPGAs from Xilinx includes the following steps:
1. Speciﬁcation of a project. A design entry can be executed by the schematic
editor (if a design is represented by a circuit), or the state editor (if a design
is represented by a STG) or a program written with some hardware description
language (HDL). The most popular HDLs are VHDL and Verilog [6, 7]. This
initial speciﬁcation is veriﬁed and corrected if necessary.
2. Logic synthesis. During this step, the package FPGA Express executes synthesis
and optimization of an FSM logic circuit. As an outcome of this step, an FPGA

38
2
Field Programmable Gate Arrays in FSM Design
Netlist ﬁle is generated. This ﬁle is represented in either EDIF or XNF format.
During this step, library cells from system and user libraries are used.
3. Simulation. The functional correctness of an FSM is checked. This step is exe-
cuted without taking into account real propagation times in a chip. If the outcome
of simulation is negative, then the previous steps should be repeated.
4. Implementation of logic circuit. Now the Netlist is translated into an inter-
nal format of CAD system. Such physical objects as CLBs and chip pins are
assigned for initial physical elements. This step is named the packing. The step
of mapping is the ﬁrst stage of the packing. The mapping refers to the process
of associating entities such as the gate-level functions in the gate-level netlist
with the LUT-level functions available on the FPGA [53]. It is not a one-to-one
mapping because each LUT can be used to represent a number of logic gates [42].
The mapping step gives results for executing the packing. During this step the
LUTs and ﬂip-ﬂops are packed into the CLBs. Both mapping and packing steps
are very difﬁcult because there are too many variants of their solutions. Following
packing the step of place-and-route is executed. Now we know the connection
between CLBs and parts of a logic function to be implemented. But there are many
ways how these CLBs could be placed in the FPGA. The placement problem is
very difﬁcult because hundreds of thousands or even millions CLBs should be
placed. During the routing it is necessary to decide how to connect all CLBs for
a particular project. This step should be executed in a way giving the maximum
possible performance. Obviously, the outcome of placement affects tremendously
the outcome of routing.
Whenroutingisﬁnished,therealperformancecouldbefound.Also,theBitStream
is formed which will be used for chip programming.
5. Project veriﬁcation. The ﬁnal simulation is performed where the actual values
of delays among the physical elements of a chip are used. If outcome of this step
is negative (the actual performance of an FSM is less than it is necessary), then
the previous steps of the design process should be repeated.
6. Chip programming. This step is connected with the writing of the ﬁnal bit stream
into the chip.
One of the most important roles in the design process plays the step of logic
synthesis. Let us analyse the steps and possible solutions for FPGA-based FSMs.
2.2 Trivial Implementing FPGA-Based FSMs
The process of FSM synthesis can be viewed as a transformation of FSM initial
speciﬁcation into structural speciﬁcations where elements of lower abstraction levels
are used [1, 17, 21]. This process is repeated till each element to be designed is
represented by some library element. In this book, we start from GSAs and ﬁnish by
LUTs and EMBs.

2.2 Trivial Implementing FPGA-Based FSMs
39
Fig. 2.6 Trivial structural
diagrams of LUT-based
Mealy (a) and Moore (b)
FSMs
(a)
(b)
Let us start from LUT-based P Mealy FSM (Fig.2.6a). It includes a LUTer which
is a circuit implemented with LUTs. There is no register in the explicitly as it is in
Fig.1.4. Now, the register is formed by ﬂip-ﬂops distributed among LUT-elements.
Let us discuss an example of design for Mealy FSM P(Γ1). There is the marked
GSA Γ1 shown in Fig.1.5a. To design the circuit of LUTer, it is necessary to ﬁnd
the functions (1.3) and (1.4). In the case of P(Γ1), these functions are represented as
(1.13). Let the symbol L(Dr) stand for the number of literals in the SOP of function
Dr ∈Φ. Let the symbol L(yn) stand for the number of literals in the SOP of function
yn ∈Y. Let the following condition take place:
S ≥max(L(D1), . . . , L(DR), L(y1), . . . , L(yN)).
(2.3)
In (2.3), the symbol S stand for the number of inputs of a LUT. In this case, each
function of FSM is implemented using only a single LUT.
There are the following values of L(Dr) and L(yn) in the case of P(Γ1): L(D1) =
L(y4) = 1, L(D2) = 2, L(D1) = 4, L(y2) = L(y3) = 3. Let us implement the
circuit of P(Γ1) using LUTs having S = 4 inputs. It leads to the circuit shown in
Fig.2.7. Let us point out that we use Eq.(1.13).
There are three LUTs in the part implementing functions yn ∈Y. There is only
a wire T2 in the circuit for y4 = T2. There are two LUTs in the part of the circuit
implementing input memory functions Dr ∈Φ. They have additional inputs for
pulses Start and Clock. Of course, they are not address inputs as it follows, for
example, from Fig.2.2. There is D1 = T2, but it is still necessary a LUT to implement
this function.
Fig. 2.7 Logic circuit of Mealy FSM P(Γ1)

40
2
Field Programmable Gate Arrays in FSM Design
Table 2.3 Table for programming LUT1
T1
T2
x1
x2
y1
T1
T2
x1
x2
y1
T1
T2
x1
x2
y1
T1
T2
x1
x2
y1
0
0
0
0
1
0
1
0
0
1
1
0
0
0
1
1
1
0
0
1
0
0
0
1
1
0
1
0
1
0
1
0
0
1
1
1
1
0
1
1
0
0
1
0
1
0
1
1
0
0
1
0
1
0
1
1
1
1
0
1
0
0
1
1
1
0
1
1
1
0
1
0
1
1
1
1
1
1
1
1
To program LUT1–LUT5, they should construct truth tables corresponding to
functions y1, y2, y3, D1 and D2. Let us discuss this step for the function y1 from
(1.13). It is represented by the following SOP:
y1 = ¯T1 ¯T2 ∨T2 ¯x1 ¯x2 ∨T1.
(2.4)
To form a truth table, this SOP should be transformed into the perfect SOP [55]
where each term has exactly L(y1) literals. To do it, we should ﬁnd the following
functions: ¯T1 ¯T2(x1 ∨¯x1)(x2 ∨¯x2); T2 ¯x1 ¯x2(T1 ∨¯T1); T1(T2 ∨¯T2)(x1 ∨¯x1)(x2 ∨¯x2).
After transformation (2.4), the table of LUT1 can be constructed (Table2.3).
The term ¯T1 ¯T2 is represented by input assignments from 0000 till 0011; the term
T2 ¯x1 ¯x2 by 0100 and 1100; the term T1 by input assignments from 1000 till 1111.
Using this approach, it can be found tables of programming for each function
of FSM. Next, the corresponding bit-streams should be created and loaded into
LUTs [77].
The circuit from Fig.2.7 is a single-level circuit, because there is only a single
level of logic among inputs xe ∈X, Tr ∈T and outputs of FSM. It is possible only
if the condition (2.3) takes place. But it is violated very often in practical cases of
FSM design [77].
A small amount of inputs per LUT creates a big problem for logic design. Let
us consider some input memory function D1 depending on L(D1) = 7 Boolean
variables:
D1 = T1 ¯T2T3x1 ¯x2 ∨T1T2T3x3x4 ∨¯T1 ¯T2 ¯T3 ¯x1x3.
(2.5)
Let LUTs in use have S = 7 inputs. In this case, the logic circuit for D1 includes
only a single LUT Fig.2.8a. Now, let LUT have S = 6. In this case the function
(2.5) should be transformed. It should be represented by some functions f1, f2, . . .
having L( f1) ≤6, L( f2) ≤6, and so on. Let us represent the function (2.5) in the
following form:
D1 = T1( ¯T2T3x1 ¯x2 ∨T2T3x3x4) ∨¯T1 ¯T2T3 ¯x1x3 = T1A ∨B.
(2.6)
The function D1 represented as (2.6) requires two LUTs to be implemented.
Moreover, this circuit Fig.2.8b includes two levels of LUTs. It means that the solution
corresponding to (2.6) is twice slower.

2.2 Trivial Implementing FPGA-Based FSMs
41
(a)
(b)
Fig. 2.8 Implementing function D1 with LUTs having S = 7 (a) and S = 6 (b)
Fig. 2.9 Illustration of the
principle of functional
decomposition
This approach is named functional decomposition. The principle of functional
decomposition is the basic one for FPGA-based design [65, 71]. There are basi-
cally approaches targeting only LUTs. But methods exists using EMBs as tools for
implementing some subfunctions [18, 66].
In general, the method of functional decomposition is based on representation of
a Boolean function F(X) in the following form:
F(X) = H(X0, G1(X2), . . . , G I (X I)).
(2.7)
The Eq.(2.7) corresponds to the implementation of the circuit shown in Fig.2.9.
The negative inﬂuence of functional decomposition is increasing of the propaga-
tion time in comparison with a single-level circuit. It follows from comparison of the
circuits from Fig.2.8. As it is mentioned in [65], the methods of functional decom-
position are far from ideal. Let us point out that it is very important to decrease the
numbers of arguments and product terms in Boolean functions to be implemented.
We discuss these methods a bit further.
Now, let us discuss the trivial LUT-based implementing P Moore FSM. Its struc-
tural diagram is shown in Fig.2.6b. The LUTer1 implements the functions (1.5), the
LUTer2 the functions (1.4). There is a distributed register hidden among LUTs of
LUTer2.

42
2
Field Programmable Gate Arrays in FSM Design
Let us discuss an example of design for Moore FSM P(Γ1). There is the marked
GSA Γ1 shown in Fig.1.5b. To design the logic circuit, it is necessary to ﬁnd the
functions (1.4) and (1.5). In the discussed case, the system (1.5) is represented by
(1.17), whereas the system (1.4) should be derived from Table1.2. It is the following
system:
D1 = ¯T1 ¯T2T3 ¯x1 ¯x2 ∨¯T1T2 ∨T1 ¯T2 ¯T3;
D2 = ¯T1 ¯T2 ¯T3x1 ∨¯T1 ¯T2 ¯T3x2;
D3 = ¯T2 ¯T3 ∨¯T1 ¯T2T3 ¯x1x2 ∨¯T1T2.
(2.8)
If the condition (2.3) takes place, then circuits of LUTer1 and LUTer2 have only
a single level of logic.
In the discussed case, it should be S = 5. Let us point out that functions (1.5) can
be optimized using a proper state assignment.
The following system can be derived from Fig.2.5b:
y1 = A2 ∨A5 ∨A6;
y2 = A2 ∨A4 ∨A5;
y3 = A3 ∨A4; y4 = A6.
(2.9)
Let us encode states of Moore FSM P(Γ1) as it is shown in Fig.2.10.
After minimizing, the following system of equations can be found instead of (2.9):
y1 = T1;
y2 = T2;
y3 = ¯T1T3;
y4 = T1 ¯T2.
(2.10)
It is necessary 2 of LUTs having S = 2 to implement the system (2.10). The
functions y1, y2 ∈Y are represented just by the outputs of LUTs from the LUTer2.
Let us point out that it is necessary 3 of LUTs having S = 3 to implement the system
(1.17). It shows the big importance of the state assignment step.
FPGA-based devices can be found in many areas where the consumed energy is
a critical factor [53]. It concerns portable computing devices, wireless telecommu-
nication equipment, space-based applications [53]. The rising of FPGA complexity
leads to increasing the power consumed by FPGA-based devices. It is well known
that FSMs consume a signiﬁcant amount of power in any FPGA-based project [22].
Therefore, minimizing power consumed by the FSMs can signiﬁcantly reduce the
total power consumed by a device.
Fig. 2.10 State codes of
Moore FSM P(Γ1)

2.2 Trivial Implementing FPGA-Based FSMs
43
The dynamic power dissipated in CMOS circuits can be expressed by the well-
known formula [81]:
P =
N

n=1
Cn fnV 2
DD.
(2.11)
In (2.11), N is the number of elements, Cn is the load capacitance at the output
of the element number n, fn is the frequency of its switching, and VDD is the supply
voltage. One of the ways for decreasing the power dissipation is decreasing of the
switching activity of ﬂip-ﬂops [81].
There is a very interesting result of investigations conducted by the authors of
the article [81]. They found that the smaller FSM circuit consumes less power than
its bigger version. It is clear because a smaller circuit needs less interconnections
than its bigger counterpart. One of the ways leading to smaller FSM circuits is
application of EMBs for implementing some parts of FSM circuits [76]. It is shown
that FSM implementation with EMBs provides some beneﬁts compared to synthesis
with LUTs [34, 72]. The maximum clock frequency of an FSM implemented in a
ROM block is independent on its complexity of course, it is possible if the whole
circuit is implementing using just a single EMB. The memory blocks of FPGAs
provide control signals that allow for module deactivation when the FSM is inactive.
It provides an efﬁcient mechanism for power saving. It has been proved [83] that
complex FSMs consume less power when implemented as memory blocks. Let us
consider some EMB-based models of FSMs.
In the simplest case, P FSMs can be implemented using a single EMB (Fig.2.11).
There is an external register shown in Fig.2.11. If an EMB is synchronized, then
pulses Clock and Start enter the EMB. But it does not change the design method.
The structural diagram (Fig.2.11) is general for both Mealy and Moore FSMs. We
use symbol EMBer to deﬁne the circuit implemented with EMBs.
In the case of P Mealy FSM, the EMBer implements systems (1.3) and (1.4). To
design it, it is necessary to construct the table of EMBer having columns T , X, Y,
Φ, q. Here sets T and X determine addresses of cells, the sets Y and Φ content of
cells, q is the number of a cell.
In the case of Mealy FSM P(Γ1), there are the following sets T = {T1, T2}, X =
{x1, x2}, Y = {y1, . . . , y4} and Φ = {D1, D2}. So, there are R0 = 2, L = 2, N = 4.
It is necessary to have an EMB with 16 cells having up to 6 bits (Table2.4).
Fig. 2.11 Structural diagram
of EMB-based P FSM

44
2
Field Programmable Gate Arrays in FSM Design
Table 2.4 Content of EMBer of Mealy FSM P(Γ1)
T
X
Y
Φ
q
T
X
Y
Φ
q
T1T2
x1x2
y1y2y3y4
D1D2
T1T2
x1x2
y1y2y3y4
D1D2
00
00
1100
01
1
10
00
1001
00
9
00
01
1100
01
2
10
01
1001
00
10
00
10
1100
01
3
10
10
1001
00
11
00
11
1100
01
4
10
11
1001
00
12
01
00
1100
10
5
11
00
0000
00
13
01
01
0110
10
6
11
01
0000
00
14
01
10
0010
10
7
11
10
0000
00
15
01
11
0010
10
8
11
11
0000
00
16
The macrocells 1–4 correspond to row 1 of Table1.1. The macrocell 5 corresponds
torow4,themacrocell6torow3,macrocells7,8torow2ofTable1.1.Themacrocells
9–12 correspond to row 5 of Table1.1. There is no state am having the code 11. So,
the macrocells 13–16 have no counterparts in Table1.1. Their content is ignored and
can be any. They are ﬁlled by zeros in Table2.4.
EMBs of EMBer (Fig.2.11) should satisfy to the following condition:
2R+L ≤V0.
(2.12)
In the case of Mealy FSM, there is R = R0. In the case of Moore FSM, there is
R = R1. The condition (2.12) shows that an EMB has enough cells to implement a
table similar to Table2.4.
The number of EMBs in EMBer can be found using the following expression:
nE M B =
 N + R
tF

.
(2.13)
In (2.13) the symbol R has the same meaning as in (2.12). The value of tF is deter-
mined using (2.1). Obviously, it is very important to minimize the number of EMBs
in the circuit of EMBer.
There are homogenous circuits corresponding to the diagram shown in Fig.2.11.
In the case of Moore FSM, it is possible to use the heterogeneous approach (Fig.2.12).
Fig. 2.12 Heterogeneous
structure of P Moore FSM

2.2 Trivial Implementing FPGA-Based FSMs
45
In this circuit, the LUTer implements the system (1.4), whereas the EMBer the
system (1.5). It allows implementing the ﬁnal circuits using less amount of EMBs
than in the case of completely EMB-based approach (Fig.2.11).
Now, the following condition should be true:
2R1 · N ≤V0.
(2.14)
In this case, it is enough only a single EMB in the EMBer.
For a heterogeneous P Moore FSM, there are the following columns in the table
of EMBer: T (address of the cell) and Y (content of the cell). There is R1 = 3 and
N = 4 for Moore FSM P(Γ1). So it is enough to use an EMB having V = 8×4 = 32
bits to implement the circuit of EMBer.
It is very important to diminish the number of LUTs in circuits of LUTers. One
of the possible ways is a proper state assignment. Let us discuss this step in more
details.
2.3 Methods of State Assignment
If an FSM is speciﬁed by a GSA, then such sets as X, Y and A are known. But
there are no state codes. To obtain them, the step of state assignment is executed
[57]. This step is very important because its outcome has a tremendous inﬂuence
on the hardware amount (the number of LUTs) in the FSM logic circuit [1]. A
strategy of state assignment could target optimization for area, performance, power
consumption, or testability.
One of the most popular state assignment algorithms is JEDI which is distributed
with the system SIS [73, 74]. JEDI targets a multi-level logic implementation. It is
based on the weight assignment for states am ∈A.
The input dominant algorithm assigns higher weights to pairs of present states
which assert similar inputs and produce sets of next states. It allows maximizing
the size of common cubes in the implemented logic function. The output dominated
algorithm assigns higher weights to pairs of next states which are generated by similar
input combinations and similar sets of present states. It maximizes the number of
common cubes in the logic function. This method can be used for the optimal state
assignment based on PES [8]. We discuss this approach a bit later.
In modern industrial packages different state assignment strategies are used. For
example, two optimization criteria are used in the design tool XST of Xilinx: max-
imum performance and minimum hardware [90]. Seven different approaches are
used for state assignment. The automatic state assignment is based on some special
algorithm proposed by Xilinx. It has been never published. The method of one-hot
encoding is based on the following expression:
R = M.
(2.15)

46
2
Field Programmable Gate Arrays in FSM Design
This method is very popular because: (1) it is very simple and (2) each LUT is
connected with a ﬂip-ﬂop. So, this conception is implemented very easy in FPGAs.
In this case, there is a lot of input memory functions but each of them is relatively
small. The compact state assignment is based on the formula (1.6) for a Mealy FSM
and the formula (1.14) for a Moore FSM. In this case the number of input memory
functions is minimum possible, but they are rather complex. In this book we mostly
use this approach and name it a binary state assignment. Two other methods are
based on codes either Gray or Johnson. At last, there is so named speed encoding.
When the performance is maximized and the sequential encoding based on using of
the counter instead of state register.
The master thesis [82] is devoted to investigation of inﬂuence of the state assign-
ment method on characteristics of Mealy FSM. The benchmarks from [91] are used
in the investigation. The results obtained for Mealy FSM are represented in Table2.5.
The investigations are executed for the FPGA XC5VLX30 of Xilinx. The ﬁrst
column of Table2.6 shows the name of a benchmark. The columns “LUT” show
numbers of LUTs in the ﬁnal circuit. The columns “MHz” represent the maximal
frequency of operation for ﬁnal Mealy FSMs.
The best results are produced when the automatic state assignment is used. It gives
the best outcomes for area (58.54% of all benchmarks) and performance (39.02%).
The binary state assignment possesses the second place in this competition. As fol-
lows from Table2.5, the automatic state assignment produces the best results when
both area and performance are optimized (29.27%). The same results are produced
for the compact (binary) state assignment. It is interesting that the one-hot state
assignment can optimize only one parameter of FSM circuit.
Of course, these results are true only for the chip XC5VLX30. But similar con-
clusions are made, for example, in [51]. It allows to suggest that these conclusions
have a rather common nature.
As it was pointed before, it is very important to diminish the power dissipation in
the circuit of FSM [77].
One of the approaches leading to decreasing the power dissipation in FSMs is the
energy-saving state assignment [67]. Main works in low-power FSMs compute ﬁrst
the switching activity and transition probabilities [84]. The key idea of these methods
is the reduction of the average activity by minimizing the bit changes during state
transitions [16, 60]. The state assignment should minimize the Hamming distance
between states with high transition probability. Different variations of this approach
can be found in many works [3, 23, 32, 61]. There are hundreds of articles devoted
to this approach.
Now, let us discuss an approach based on using classes of pseudoequivalent states
in Moore FSMs. Remind, that states am, as ∈A belong to the same class of PES
if corresponding vertices of a GSA are connected with an input of the same vertex
of this GSA [5]. It allows constructing the partition A = {B1, . . . , BI}, where
Bi ∈A is a class of PES. After constructing the partition A, an initial GSA Γ
can be transformed into a block GSA B(Γ ).

2.3 Methods of State Assignment
47
Table 2.5 Outcomes of investigations
FSM
Auto
One-hot
Compact
Sequential
Gray
Johnson
Speed1
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
bbara
11
639
9
966
13
635
13
639
19
589
24
545
13
962
bbsse
29
559
29
559
29
582
29
538
31
538
36
408
38
556
bbtas
5
962
8
966
5
966
5
962
5
955
5
962
9
966
beecount
7
952
19
639
7
952
7
952
7
948
21
625
30
583
ese
49
480
52
477
46
463
50
487
46
454
71
434
72
453
dk14
8
945
29
522
8
945
8
945
8
945
19
623
40
512
dk15
7
1062
19
737
7
1062
7
1062
7
1062
7
1062
19
659
dk16
46
556
46
556
15
625
19
506
27
554
86
355
70
399
dk17
6
952
14
669
6
952
6
952
6
952
7
895
27
571
dk27
5
900
8
906
5
897
5
959
5
955
6
899
10
903
dk512
17
730
17
730
7
899
7
895
7
899
21
437
19
790
ex1
64
586
64
586
74
447
67
478
66
406
106
340
72
605
ex4
15
962
15
962
16
626
15
598
14
748
33
546
15
962
ex6
29
553
30
580
20
621
23
615
22
616
36
426
31
598
keyb
56
384
56
384
65
358
71
382
66
447
62
435
85
374
kirkman
51
874
84
1058
53
569
48
880
51
874
112
451
84
1058
lion
3
1084
5
962
3
1080
3
1080
3
1084
3
1084
5
962
mark1
27
726
27
726
19
708
22
622
18
623
27
574
29
959
me
5
1071
8
1071
5
1071
6
1071
5
1071
5
1071
8
1071
opus
22
596
22
754
21
628
26
585
22
596
26
576
26
671
planet
100
888
100
888
138
389
145
417
149
375
192
346
106
637
planet1
100
888
100
888
138
389
145
417
149
375
192
346
106
637
(continued)

48
2
Field Programmable Gate Arrays in FSM Design
Table 2.5 (continued)
FSM
Auto
One-hot
Compact
Sequential
Gray
Johnson
Speed1
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
LUT
MHz
pma
73
554
73
554
115
438
108
367
112
375
121
405
88
559
s1
77
550
77
550
75
447
89
328
105
368
114
361
81
552
s1488
140
425
140
425
141
432
130
394
147
433
192
334
162
458
s1494
124
412
124
412
143
442
135
383
145
383
192
333
152
462
s208
28
559
28
559
13
669
12
716
15
639
29
483
50
386
s27
4
962
21
636
4
962
7
679
4
962
12
664
21
631
s298
362
406
362
406
330
313
264
311
274
314
716
244
399
397
s386
26
577
31
586
28
581
28
558
29
429
43
22
36
441
s420
28
559
28
559
14
629
12
716
15
639
29
483
36
510
s510
42
900
42
900
39
448
53
440
50
427
123
388
42
900
s820
63
429
63
429
85
395
92
441
93
438
98
366
93
399
s832
63
429
63
429
73
412
77
431
87
394
97
335
108
444
sand
99
569
99
569
121
426
125
421
125
438
189
306
103
490
scf
179
676
179
676
202
338
205
349
197
389
337
327
180
561
shiftreg
0
1584
9
1080
0
1584
4
959
4
959
5
902
4
903
sse
29
559
29
559
28
543
37
548
32
540
44
394
36
612
styr
118
430
118
430
127
369
138
363
138
353
181
323
161
454
tav
6
1556
6
1556
6
911
6
911
5
914
5
914
6
1556
tbk
55
406
179
360
71
465
129
342
137
290
295
276
444
342

2.3 Methods of State Assignment
49
Fig. 2.13 State codes for
Moore FSM P0(Γ1)
Table 2.6 Reduced structure table of Moore FSM P0(Γ1)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
∗00
a2
010
1
D2
1
a3
001
x1
D3
2
B2
∗10
a4
011
¯x1x2
D2D3
3
a5
111
¯x1 ¯x2
D1D2D3
4
B3
∗∗1
a6
100
1
D1
5
Let us encode states am ∈A in such a way that each class Bi ∈A be represented
by the minimal possible amount of generalized intervals of R1-dimensional Boolean
space. Let us name such an approach “optimal state assignment”. For example, there
is the partition A = {B1, . . . , B4} in the case of Moore FSM represented by GSA
Γ1 Fig.1.5b. It corresponds to the BGSA B(Γ1) shown in Fig.1.7.
Let us point out that the JEDI algorithm [73] can be used for the optimal state
assignment. Let us use the symbol P0(Γ j) to show that a Moore FSM is synthesized
using a GSA Γ j and the principle of optimal state assignment. One of the possible
outcomes is shown in Fig.2.13 for the Moore FSM P0(Γ1).
Analysis of B(Γ1) shows that there is only an unconditional transition from state
a6 ∈B4 into state a1. There are no functions Dr = 1 (r = 1, R1) during this
transition. It means that K(a6) can be treated as a “don’t care” state code.
Taking it into account, the following generalized intervals K(Bi) can be found
from the Karnaugh map (Fig.2.13): K(B1) = ∗00, K(B2) = ∗10, K(B3) = ∗∗1.
These cubes can be treated as codes of classes Bi ∈A. Using these codes and
BGSA B(Γ1), the reduced structure table of Moore FSM P0(Γ1) can be constructed
(Table2.6).
We hope that there is obvious connection among BGSA B(Γ1), the state codes
(Fig.2.13) and Table2.6. There are the following terms Fh in the case of this table:
F1 = ¯T2 ¯T3; F2 = T2 ¯T3x1; F3 = T2 ¯T3 ¯x1x2; F4 = T2 ¯T3 ¯x1 ¯x2; F5 = T3.
It allows ﬁnding the following system of input memory functions (after minimiza-
tion):
D1 = T2 ¯T3 ¯x1 ¯x2 ∨T3;
D2 = ¯T2 ¯T3 ∨T2 ¯T3 ¯x1;
D3 = T2 ¯T3.
(2.16)
Each function of the system (2.16) is implemented using only a single LUT having
S ≤4.

50
2
Field Programmable Gate Arrays in FSM Design
Fig. 2.14 State codes for
Moore FSM S1
In the common case, the terms Fh are represented as:
Fh =
R1

r=1
T eir
r
· Xh
(h = 1, H0).
(2.17)
In (2.17), eir ∈{0, 1, ∗} is the value of the r-th bit of K(Bi) from the h-th row of a
reduced structure table, T 0
r = ¯Tr, T 1
r = Tr, T ∗
r = 1.
It follows from comparison of Tables1.1 and 2.6 that there is the same amount of
rows in both of them. It is true if each class Bi ∈A is represented by a single cube.
Because of it, the symbol H0 is used in (2.17).
Let us point out that sometimes it is necessary more than one cube to represent
some class Bi ∈A. For example, let it be the partition A = {B1, . . . , B4} for
some FSM S1. Let it be B1 = {a1}, B2 = {a2, a3, a4}, B3 = {a5, a6, a7}, B4 = {a8}.
There is one of the possible outcomes of the optimal state assignment for S1 shown
in Fig.2.14.
Let us treat as “don’t care” the code of the state a8 ∈A. Even in this case, the class
B2 is represented by two cubes: 00∗and 01∗. If there are conditional transitions from
the state a8 ∈B4, its code cannot be treated as “don’t care”. In this case, two classes
are represented using two cubes each. The class B3 is represented by the cubes 11
and 11∗. In this case, there are more than H0 rows in the reduced structure table. We
deal with this case a bit later.
So,theexistedmethodsofstateassignmentcanbedividedusingthelogicelements
they target. For example, there are PLA-oriented methods [4, 19, 20, 27, 56, 68–70,
86, 87], as well as PAL-oriented methods [9–14, 24–26, 28, 44–50, 78–80]. A lot of
methods deals with FPGA-based FSMs [29–31, 33, 38, 39, 63]. There are a lot of
state assignment methods targeting saving the energy consumed by the FSM circuit
[3, 40, 62, 85, 88], just to name a few.
OurbookisdevotedtoFPGA-basedFSMs.Themaingoalofalldiscussedmethods
is to save the chip area occupied by an FSM circuit. So, we use JEDI-based algorithms
for executing the state assignment.
2.4 Hardware Reduction for FPGA-Based FSMs
As it is mentioned in many works, there are the positive back effects of hard-
ware reduction. The solution of this problem leads to increasing of performance
and decreasing of power consumption of FSM logic circuits [35, 92]. To decrease

2.4 Hardware Reduction for FPGA-Based FSMs
51
Fig. 2.15 Structural
diagram of LUT-based M P
Mealy FSM
the amount of hardware, we use three groups of methods: (1) structural decomposi-
tion; (2) heterogeneous implementation and (3) optimal encoding of states and other
objects of FSMs.
We discussed the method of replacement of logical conditions (RLC) in Sect.1.5.
Let us start with LUT-based M P Mealy FSM (Fig.2.15).
In this circuit, the LUTer1 is equivalent to BRLC from Fig.1.21. It implements
the system (1.47). The LUTer2 executes functions of BIMF from Fig.1.21. It gen-
erates microoperations (1.48) and input memory functions (1.49). The register RG
is distributed among LUTs of LUTer2, so, there are state variables Tr ∈T shown as
the outputs of LUTer2 (Fig.2.15).
There are the following steps in design method for MP Mealy FSM:
1. Constructing the set of states for a GSA Γ .
2. Executing the state assignment.
3. Constructing the tables of LUTer1.
4. Constructing the structure table of MP Mealy FSM.
5. Constructing the tables of LUTer2.
6. Implementing the FSM logic circuit.
Let us discuss an example of design for Mealy FSM M P(Γ4), where a GSA Γ4 is
shown in Fig.2.16. There are marks of states on GSA Γ4. So, it can be found the set
A = {a1, a2, a3} with M0 = 3. It is enough R0 = 2 of state variables to encode the
states am ∈A. Let us encode them in the following way: K(a1) = 00, K(a2) = 01
and K(a3) = 10.
To construct the table of LUTer1 it is necessary to execute the RLC. There are
the following sets X(am) in the discussed case: X(a1) = {x1, x2}, X(a2) = {x3, x4}
and X(a3) = ∅. So, there is G = 2 and P = {p1, p2}.
Table2.7 represents the table of replacement of logical conditions for M P(Γ4).
It includes the columns with states, their codes and logical conditions replaced by
corresponding variables pg ∈P.
There are G circuits in LUTer1. Each of them corresponds to a single function
pg ∈P. Let X(pg) ⊆X be a set of logical conditions replaced by the variable
pg ∈P. There are G tables representing functions pg ∈P. Each table includes the
columns K(am), X(pg), pg. First two columns create the address of the cell, the last
column shows its content. There are the following functions derived from Table2.7.
p1 = ¯T1 ¯T2x1 ∨¯T1T2x3;
p2 = ¯T1 ¯T2x2 ∨¯T1T2x4.
(2.18)

52
2
Field Programmable Gate Arrays in FSM Design
Fig. 2.16 Initial GSA Γ4
Table 2.7 Table of RLC for Mealy FSM M P(Γ4)
am
a1
a2
a3
K(am)
00
01
10
p1
x1
x3
–
p2
x2
x4
–
Table2.8 represents the function p1, whereas Table2.9 the function p2 from the
system (2.18). There are the following sets X(pg) used in these tables: X(p1) =
{x1, x3} and X(p2) = {x2, x4}. There is the obvious connection between system
(2.18) and Tables2.8 and 2.9.
The structure table of M P Mealy FSM includes the same columns as in the case
of P Mealy FSM. But the column Xh is replaced by a column Ph. For example,
the conjunction x1x2 (it determines the transition ⟨a1, a2⟩) is replaced by p1 p2, the

2.4 Hardware Reduction for FPGA-Based FSMs
53
Table 2.8 Table of LUTer1 for function p1
T
X(p1) p1
T
X(p1) p1
T
X(p1) p1
T
X(p1) p1
T1T2
x1x3
T1T2
x1x3
T1T2
x1x3
T1T2
x1x3
00
00
0
01
00
0
10
00
0
11
00
0
00
01
0
01
01
1
10
01
0
11
01
0
00
10
1
01
10
0
10
10
0
11
10
0
00
11
1
01
11
1
10
11
0
11
11
0
Table 2.9 Table of LUTer1 for function p2
T
X(p2) p2
T
X(p2) p2
T
X(p2) p2
T
X(p2) p2
T1T2
x2x4
T1T2
x2x4
T1T2
x2x4
T1T2
x2x4
00
00
0
01
00
0
10
00
0
11
00
0
00
01
0
01
01
1
10
01
0
11
01
0
00
10
1
01
10
0
10
10
0
11
10
0
00
11
1
01
11
1
10
11
0
11
11
0
Table 2.10 Structure table of Mealy FSM M P(Γ4)
am
K(am)
as
K(as)
Ph
Yh
Φh
h
a1
00
a2
01
p1
y1y2
D2
1
a2
01
¯p1 p2
y3y5
D2
2
a2
01
¯p1 p2
y4
D2
3
a2
10
a3
10
p1 p2
y1y2
D1
4
a3
10
p1 ¯p2
y1y3
D1
5
a1
00
¯p1 p2
y3y5
–
6
a1
00
¯p1 ¯p2
y1y2
–
7
a3
10
a2
01
1
y1y2
D2
8
conjunction x1 ¯x2 by p1 ¯p2 and so on. Using these rules and table of RLC, it is possible
to construct the table of M P Mealy FSM. It is Table2.10 in the discussed case.
Similar tables are used for constructing tables of LUTer2. There are R0+ N tables
representing LUTer2. Each of them includes columns K(am), P (address of the cell)
and either yn ∈Y or Dr ∈Φ. All these tables are represented by Table2.11.
The address 0000 corresponds to the row 3 of Table2.10. So, the corresponding
cell contains two ones (y4 and D2). The addresses 0010 and 0011 correspond to the
row 1 of Table2.10. Using the same approach, we ﬁll all rows of Table2.11.
It is possible to implement systems (1.48) and (1.49) by EMBer. It leads to het-
erogeneous M P Mealy FSM (Fig.2.17).
In this case, the LUTer implements the system (1.47), whereas the EMBer the
systems (1.48) and (1.49). There are the same steps in design of both M P FSMs,
but in the heterogeneous case the step 5 is “Constructing the table of EMBer”. In the
discussed case, table of EMBer is the same as Table2.11.

54
2
Field Programmable Gate Arrays in FSM Design
Table 2.11 Table of LUTer2 for Mealy FSM M P(Γ4)
T
P
y1
y2
y3
y4
y5
D1
D2
T
P
y1
y2
y3
y4
y5
D1
D2
T1T2
p1 p2
T1T2
p1 p2
00
00
0
0
0
1
0
0
1
10
00
1
1
0
0
0
0
1
00
01
0
0
1
0
1
0
1
10
01
1
1
0
0
0
0
1
00
10
1
1
0
0
0
0
1
10
10
1
1
0
0
0
0
1
00
11
1
1
0
0
0
0
1
10
11
1
1
0
0
0
0
1
01
00
1
1
0
0
0
0
0
11
00
0
0
0
0
0
0
0
01
01
0
0
1
0
1
0
0
11
01
0
0
0
0
0
0
0
01
10
1
0
1
0
0
1
0
11
10
0
0
0
0
0
0
0
01
11
1
1
0
0
0
0
1
11
11
0
0
0
0
0
0
0
Fig. 2.17 Heterogeneous
structure of M P Mealy FSM
Let the following condition take place:
R0 + |X(pg)| ≤S
(g = 1, G).
(2.19)
In this case, each function pg ∈P is implemented using a single LUT. If this
condition is violated, then it is possible to encode logical conditions [15].
Let us explain this approach on the base of Table2.7. There are two pairs of
conditions in the columns of this table: ⟨x1, x2⟩and ⟨x3, x4⟩. Let us denote this
number as nP. Let us encode each pair using RP variables, where:
RP = ⌈log2 nP⌉.
(2.20)
Let us use the variables zr ∈Z for such encoding where |Z| = RP.
In the discussed case, there are nP = 2, RP = 1 and Z = {z1}. Let us encode the
pairs in the following way: K(x1, x2) = 0, K(x3, x4) = 1. Now, the system (1.47)
can be replaced by the following system:
P = P(Z, X).
(2.21)
It leads to MP P Mealy FSM (Fig.2.18).
In this case, the EMBer implements systems (1.48) and (1.49) and the system:
Z = Z(T, P).
(2.22)

2.4 Hardware Reduction for FPGA-Based FSMs
55
Fig. 2.18 Structural diagram
of MP P Mealy FSM
Table 2.12 Table of RLC for
Mealy FSM MP P(Γ4)
⟨xe, xm⟩
⟨x1, x2⟩
⟨x3, x4⟩
K(xe, xm)
0
1
p1
x1
x3
p2
x2
x4
There is the following table of RLC in the case of MP P(Γ1) (Table2.12).
Now, there are the following functions implemented by the LUTer:
p1 = ¯z1x1 ∨z1x3;
p2 = ¯z1x2 ∨z1x4.
(2.23)
Each function (2.21) is implemented by a single LUT if the following condition
takes place:
RP + |X(pg)| ≤S.
(2.24)
Of course, this approach has sense if there is
RP < R0.
(2.25)
Let us discuss the M P Moore FSM (Fig.2.19) implemented as a heterogeneous
circuit. Here the LUTer1 implements the system (1.47), the LUTer2 the system (1.49)
and the EMBer the system (1.5).
To minimize the circuit of LUTer1, it is possible to apply the encoding of logical
conditions. It leads to MP P Moore FSM (Fig.2.20).
This approach is a general one. It can be used in any model of FSM to diminish
the hardware amount. It uses two main issues: (1) the structural decomposition and
(2) the heterogeneous implementation.
Fig. 2.19 Structural diagram of M P Moore FSM

56
2
Field Programmable Gate Arrays in FSM Design
Fig. 2.20 Structural diagram of MP P Moore FSM
Fig. 2.21 Homogeneous structural diagram of P H Mealy FSM
Fig. 2.22 Heterogeneous structural diagram of P H Mealy FSM
The second approach is based on the encoding of the rows of ST. It can be used
only for Mealy FSMs. It is reduced to encoding of each function Fh by a binary code
C(Fh) having RH bits (h = 1, H0). The value of RH is determined by (1.38). It is
possible either homogeneous (Fig.2.21) or heterogeneous (Fig.2.22) structures of
P H Mealy FSMs.
In both cases, the ﬁrst block corresponds to BIMF (Fig.1.18d), whereas the second
to BMO (Fig.1.18d). For example, the design method for the homogeneous variant
includes the following steps:
1. Constructing the set of states for a GSA Γ .
2. Executing the state assignment.
3. Constructing the structure table of P Mealy FSM.
4. Encoding the rows of ST.
5. Constructing the table of LUTer1.
6. Constructing the table of LUTer2.
7. Implementing the FSM logic circuit.

2.4 Hardware Reduction for FPGA-Based FSMs
57
Table 2.13 Structure table of Mealy FSM P(Γ4)
am
K(am)
as
K(as)
Xh
Yh
Φh
h
a1
00
a2
01
x1
y1y2
D2
1
a2
01
¯x1x2
y3y5
D2
2
a2
01
¯x1 ¯x2
y4
D2
3
a2
01
a3
10
x3x4
y1y2
D1
4
a3
10
x3 ¯x4
y1y3
D1
5
a1
00
¯x3x4
y3y5
–
6
a1
00
¯x3 ¯x4
y1y2
–
7
a3
10
a2
01
1
y1y2
D2
8
Let us discuss an example of design for Mealy FSM P H(Γ4). There is the GSA
Γ4 shown in Fig.2.16. As in the previous case, the following sets can be found for
P(Γ4): X = {x1, . . . , x4}, Y = {y1, . . . , y5}, A = {a1, a2, a3}, Φ = {D1, D2},
T = {T1, T2}. Let us encode the states in the following way: K(a1) = 00, K(a2) =
01, K(a3) = 10. There are H0 = 8 rows in the structure table of FSM P(Γ4)
(Table2.13).
Let the following condition take place:
RH ≤S.
(2.26)
In this case, there is no inﬂuence of codes C(Fh) on the hardware amount in
LUTer2. It is implemented using R + N of LUTs. If this condition is violated, then
the outcome of row encoding can inﬂuence the hardware amount in LUTer2.
In the discussed case, there are H0 = 8 and RH = 3. So, there is the set
Z = {z1, z2, z3}. Let us use LUTs having S = 2. In this case, the condition
(2.26) is violated. There are the following system of Boolean functions derived from
Table2.13:
D1 = F4 ∨F5;
D2 = F1 ∨F2 ∨F3 ∨F8;
y1 = F1 ∨F4 ∨F5 ∨F7 ∨F8;
y2 = F1 ∨F4 ∨F7 ∨F8;
y3 = F2 ∨F5 ∨F6;
y4 = F3;
y5 = F2 ∨F6.
(2.27)
In the worst case, each equation of (2.27) requires two LUTs to be implemented.
Let us encode the rows as it is shown in Fig.2.23.

58
2
Field Programmable Gate Arrays in FSM Design
Fig. 2.23 Codes of rows for
FSM P H(Γ4)
The following equations can be obtained from the Karnaugh map (Fig.2.23):
D1 = ¯z2z3;
D2 = ¯z3;
y1 = ¯z1 ∨¯z2z3;
y2 = ¯z1;
y3 = z1z3 ∨z1z2;
y4 = z1 ¯z2 ¯z3;
y5 = z1z2.
(2.28)
The system (2.28) corresponds to the following circuit of LUTer2 (Fig.2.24).
In the worst case, it is necessary 14 of LUTs, whereas there are only 10 of LUTs
in Fig.2.24. This number can be decreased if there are the following codes of rows
(Fig.2.25).
Using this Karnaugh map, we can ﬁnd the following system of functions:
Fig. 2.24 Logic circuit of LUTer2 for codes from Fig.2.23
Fig. 2.25 Outcome of row
encoding for P H(Γ1)

2.4 Hardware Reduction for FPGA-Based FSMs
59
Fig. 2.26 Logic circuit of LUTer2 corresponding to codes from Fig.2.25
D1 = ¯z2 ¯z3;
D2 = z3;
y1 = z1 ∨¯z2 ¯z3;
y2 = z1;
y3 = ¯z1 ¯z3 ∨¯z1z2;
y4 = z1 ¯z2z3;
y5 = ¯z1z2.
(2.29)
There is the circuit (Fig.2.26) corresponding to the system (2.29). It requires only
8 of LUTs having S = 2.
The table of LUTer1 is constructed on the base of the structure table. The columns
as, K(as), Yh and Φh are deleted from the ST. They are replaced by columns C(Fh),
Zh. There are the variables zr ∈Z in the row h of the table, if there is 1 in the
position number r of K(Fh). In the discussed case, it is the Table2.14.
The table of LUTer1 is constructed using the codes from Fig.2.25. It is used for
deriving the system
Z = Z(T, X).
(2.30)
Table 2.14 Table of LUTer1 for Mealy FSM P H(Γ4)
am
K(am)
Xh
C(Fh)
Zh
h
a1
00
x1
101
z1z2
1
¯x1x2
011
z2z3
2
¯x1 ¯x2
001
z3
3
a2
01
x3x4
100
z1
4
x3 ¯x4
000
–
5
¯x3x4
010
z2
6
¯x3 ¯x4
110
z1z2
7
a3
10
1
111
z1z2z3
8

60
2
Field Programmable Gate Arrays in FSM Design
Table 2.15 Table of LUTer2 for Mealy FSM P H(Γ4)
C(Fh)
Yh
Φh
h
z1z2z3
y1y2y3y4y5
D1D2
000
10100
10
5
001
00010
01
3
010
00101
00
6
011
00101
01
2
100
11000
10
4
101
11000
01
1
110
11000
00
7
111
11000
01
8
It is the following system in the discussed case:
z1 = ¯T1 ¯T2x1 ∨¯T1T2x3x4 ∨¯T1T2 ¯x3 ¯x4 ∨T1 ¯T2;
z2 = ¯T1 ¯T2x1 ∨¯T1 ¯T2x2 ∨¯T1T2 ¯x3 ∨T1 ¯T2;
z3 = ¯T1 ¯T2 ¯x1 ∨T1 ¯T2.
(2.31)
The table of LUTer2 is constructed on the base of the ST. The columns am, K(am),
Xh are replaced by columns C(Fh). In the discussed case, it is Table2.15.
This table is used to ﬁnd the systems (1.39) and (1.40). They are represented by
the system (2.28) in the discussed case.
To design this circuit, we used optimal codes for variables Fh. This example shows
the importance of this step and its inﬂuence on the hardware amount in LUT-based
design.
There are three groups of methods discussed in the next chapters of the book:
1. EMB-based FSMs with RLC and other methods of structural decomposition.
There are two main goals in our approach. First, decreasing for the number of EMBs
in the FSM logic circuit. Second, decreasing the number of LUTs in the circuit
replacing logical conditions.
2. EMB-based FSMs with transformation of object codes. These models are based
on transformation of state codes into codes of collections of microoperations and vice
versa.
3. EMB-based FSMs with more than one source of codes of classes of pseudoe-
quivalent states. These methods concern only Moore FSMs.
References
1. M. Adamski, A. Barkalov, Architectural and Sequential Synthesis of Digital Devices (Univer-
sity of Zielona Góra Press, Zielona Góra, 2006)
2. Altera: http://www.altera.com. Accessed Jan 2015

References
61
3. P. Bacchetta, L. Daldos, D. Sciuto, C. Silvano, Low-power state assignment techniques for
ﬁnite state machines, in Proceedings of the 2000 IEEE International Symposium on Circuits
and Systems (ISCAS’2000), vol. 2, Geneva. IEEE (2000), pp. 641–644
4. S. Baranov, Logic Synthesis of Control Automata (Kluwer Academic Publishers, Dordrecht,
1994)
5. A. Barkalov, Principles of logic optimization for Moore microprogram automaton. Cybern.
Syst. Anal. 34(1), 54–60 (1998)
6. A. Barkalov, A. Barkalov Jr., Synthesis of ﬁnite-state machines with transformation of the
object’s codes, in Proceedings of the International Conference TCSET’2004, Lviv, Ukraina
(2004), pp. 61–64. Lviv Polytechnic National University, Lviv, Publishing House of Lviv
Polytechnic
7. A. Barkalov, A. Barkalov Jr, Design of mealy ﬁnite-state machines with the transformation of
object codes. Int. J. Appl. Math. Comput. Sci. 15(1), 151–158 (2005)
8. A. Barkalov, L. Titarenko, Logic Synthesis for FSM-Based Control Units. Lecture Notes in
Electrical Engineering, vol. 53 (Springer, Berlin, 2009)
9. A. Barkalov, L. Titarenko, S. Chmielewski, Optimization of logic circuit of Moore FSM on
CPLD. Pomiary Automatyka Kontrola 53(5), 18–20 (2007)
10. A. Barkalov, L. Titarenko, S. Chmielewski, Optimization of Moore FSM on CPLD, in Pro-
ceedings of the Sixth International Conference CAD DD’07, vol. 2, Minsk (2007), pp. 39–45
11. A. Barkalov, L. Titarenko, S. Chmielewski, Optimization of Moore FSM on system-on chip, in
Proceedings of IEEE East-West Design and Test Symposium—EWDTS’07, Yerevan, Armenia,
Kharkov (2007), pp. 105–109
12. A. Barkalov, L. Titarenko, S. Chmielewski, Reduction in the number of PAL macrocells int
the circuit of a Moore FSM. Int. J. Appl. Math. Comput. Sci. 17(4), 565–675 (2007)
13. A. Barkalov, L. Titarenko, S. Chmielewski, Decrease of hardware amount in logic circuit of
Moore FSM. Przegla˛d Telekomunikacyjny i Wiadomo´sci Telokomunikacyjne (6), 750–752
(2008)
14. A. Barkalov, L. Titarenko, S. Chmielewski, Optimization of Moore FSM on System-on-chip
using PAL technology, in Proceedings of the International Conference TCSET 2008, Lviv-
Slavsko, Ukraina (2008), pp. 314–317. Ministry of Education and Science of Ukraine, Lviv
Polytechnic National University, Lviv, Publishing House of Lviv Polytechnic
15. A. Barkalov, I. Zelenjova, Optimization of replacement of logical conditions for an automaton
with bidirectional transitions. Autom. Control Comput. Sci. 34(5), 48–53. Allerton Press Inc
16. L. Benini, G. De Micheli, State assignment for low power dissipation. IEEE J. Solid-State
Circuits 30(3), 258–268 (1995)
17. M. Bolton, Digital System Design with Programmable Logic (Addison-Wesley, Boston, 1990)
18. G. Borowik, Synthesis of sequential devices into FPGA with embedded memory blocks. Ph.D.
thesis, Warszawa: WUT (2007). Ph.D. Thesis
19. R. Brayton, G. Hatchel, C. McMullen, A. Sangiovanni-Vincentelli, Logic Minimization Algo-
rithms for VLSI Synthesis (Kluwer Academic Publishers, Boston, 1984)
20. R. Brayton, R. Rudell, A. Sangiovanni-Vincentelli, A. Wang, MIS: a multi-level logic opti-
mization system. IEEE Trans. Comput. -Aided Des. 6(11), 1062–1081 (1987)
21. S. Brown, Z. Vernesic, Fundamentals of Digital Logic with VHDL Design (McGraw–Hill, New
York, 2000)
22. S. Chattopadhyay, P. Chaudhuri, Genetic algorithm based approach for integrated state assign-
ment and ﬂipﬂop selection in ﬁnite state machines synthesis, in Proceedings of the IEEE
International Conference on VLSI Design, Los Alamitos. IEEE Computer Society (1998), pp.
522–527
23. C. Chen, J. Zhao, M. Ahmadi, A semi-gray encoding algorithm for low-power state assignment,
in Proceedings of the 2003 International Symposium on Circuits and Systems, ISCAS’03, vol.
5. IEEE (2003), pp. 389–392
24. R. Czerwi´nski, D. Kania, State assignment method for high speed FSM, in Proceedings of
Programmable Devices and Systems (2004), pp. 216–221

62
2
Field Programmable Gate Arrays in FSM Design
25. R. Czerwi´nski, D. Kania, State assignment for PAL-based CPLDs, in Proceedings of 8th
Euromicro Symposium on Digital System Design (2005), pp. 127–134
26. R. Czerwinski, D. Kania, Finite State Machine Logic Synthesis for Complex Programmable
Logic Devices. Lecture Notes in Electrical Engineering, vol. 23 (Springer, Berlin, 2013)
27. D. Debnath, T. Sasao, Doutput phase optimization for AND-OR-EXOR PLAs with decoders
and its application to design of adders. IFICE Trans. Inf. Syst. E88-D(7), 1492–1500 (2005)
28. S. Deniziak, K. Sapiecha, An efﬁcient algorithm of perfect state encoding for CPLD based
systems, in Proceedings of IEEE Workshop on Design and Diagnostic of Electronic Circuits
and Systems (DDECS’98) (1998), pp. 47–53
29. S. Devadas, H. Ma, A. Newton, A. Sangiovanni-Vincentelli, MUSTANG: state assignment of
ﬁnite state machines targeting multilevel logic implementation. IEEE Trans. Comput.-Aided
Des. 7(12), 1290–1300 (1988)
30. S. Devadas, A. Newton, Exact algorithms for output encoding, state assignment, and four-level
boolean minimization. IEEE Trans. Comput.-Aided Des. 10(1), 143–154 (1991)
31. X. Du, G. Hachtel, B. Lin, A. Newton, MUSE: a multilevel symbolic encoding algorithm for
state assignment. IEEE Trans. Comput.-Aided Des. Integr. Circuits Syst. 10(1), 28–38 (1991)
32. A. El-Maleh, S. Sait, F. Khan, Finite state machine state assignment for area and power mini-
mization, in 2006 IEEE International Symposium on Circuits and Systems, ISCAS 2006. Pro-
ceedings. IEEE (2006), pp. 5303–5306
33. B. Escherman, State assignment for hardwired VLSI control units. ACM Comput. Surv. 25(4),
415–436 (1993)
34. I. Garcia-Vargas, R. Senhadji-Navarro, G. Jiménez-Moreno, A. Civit-Balcells, P. Guerra-
Gutierrez, ROM-based ﬁnite state machine implementation in low cost FPGAs, in IEEE Inter-
national Symposium on Industrial Electronics ISIE 2007. IEEE (2007), pp. 2342–2347
35. I. Grout, Digital Systems Design with FPGAs and CPLDs (Elsevier Science, Oxford, 2008)
36. S. Hassoun, T. Sasao, Logic Synthesis and Veriﬁcation (Kluwer Academic Publishers, Boston,
2002)
37. G. Hatchel, F. Somenzi, Logic synthesis and veriﬁcation algorithms (Kluwer Academic Pub-
lishers, Boston, 2000)
38. H. Hu, H. Xue, J. Bian, A heuristic state assignment algorithm targeting area, in Proceedings
of 5th International Conference on ASIC, vol. 1 (2003), pp. 93–96
39. J. Huang, J. Jou, W. Shen, ALTO: an iterative area/performance algorithms for LUT-based
FPGA technology mapping. IEEE Trans. VLSI Syst. 18(4), 392–400 (2000)
40. A. Iranli, P. Rezvani, M. Pedram, Low power synthesis of ﬁnite state machines with mixed D
and T ﬂip-ﬂops, in Proceedings of the Asia and South Paciﬁc—DAC (2003), pp. 803–808
41. J. Jenkins, Design with FPGAs and CPLDs (Prentice Hall, New York, 1995)
42. A. Kahng, VLSI Physical Design: From Graph Partitioning to Timing Closure (Springer, Berlin,
2011)
43. T. Kam, T. Villa, R. Brayton, A. Sangiovanni-Vincentelli, A Synthesis of Finie State Machines:
Functional Optimization (Kluwer Academic Publishers, Boston, 1998)
44. D. Kania, Two-level logic synthesis on PAL-based CPLD and FPGA using decomposition, in
Proceedings of 25th Euromicro Conference (1999), pp. 278–281
45. D. Kania, Two-level logic synthesis on PALs. Electron. Lett. (17), 879–880 (1999)
46. D. Kania, Coding capacity of PAL-based logic blocks included in CPLDs and FPGAs, in
Proceedings of IFAC Workshop on Programmable Devices and Sysytems (PDS’2000). Elsevier
Science (2000), pp. 164–169
47. D. Kania, Decomposition-based synthesis and its application in PAL-oriented technology map-
ping, in Proceedings of 26th Euromicro Conference. Maastricht: IEEE Compuetr Society Press
(2000), pp. 138–145
48. D. Kania, An efﬁcient algorithm for output coding in PAL-based CPLDs. Int. J. Eng. 15(4),
325–328 (2002)
49. D. Kania, Logic synthesis of multi–output functions for PAL-based CPLDs, in Proceedings of
IEEE International Conference on Field-Programmable Technology (2002), pp. 429–432

References
63
50. D. Kania, An efﬁcient approach to synthesis of multi-output boolean functions on PAL-based
devices. IEEE Proc.—Comput. Digital Tech. 150, 143–149 (2003)
51. H. Kubatova, Design of Embedded Control Systems, chapter Finie State Machine Implemen-
tation in FPGAs (Springer, New York, 2005), pp. 177–187
52. Lattice: http://www.lattice.com. Accessed Feb 2015
53. C. Maxﬁeld, The Design Warrior’s Guide to FPGAs (Academic Press Inc., Orlando, 2004)
54. C. Maxﬁeld, FPGAs: Instant Access (Newnes, 2008)
55. E. McCluskey, Logic Design Principles (Prentice Hall, Englewood Cliffs, 1986)
56. G. De Micheli, Symbolic design of combinational and sequential logic implemented by two-
level macros. IEEE Trans. Comput.-Aided Des. 5(9), 597–616 (1986)
57. G. De Micheli, Synthesis and Optimization of Digital Circuits (McGraw–Hill, New York, 1994)
58. Microsemi: http://www.microsemi.com. Accessed Jan 2015
59. Z. Navabi, Embedded Core Design with FPGAs (McGraw–Hill, New York, 2007)
60. W. Nöth, R. Kolla, Spanning tree based state encoding for low power dissipation, in Proceedings
of the Conference on Design, Automation and Test in Europe. Association for Computing
Machinery (1999), p. 37
61. S. Park, S. Cho, S. Yang, M. Ciesielski, A new state assignment technique for testing and
low power, in Proceedings of the 41st annual Design Automation Conference. Association for
Computing Machinery (2004), pp. 510–513
62. C. Pedram, A. Despain, Low-power state assignment targeting two- and multilevel logic imple-
mentations. IEEE Trans. Comput.-Aided Des. Integr. Circuits Syst. 17(12), 1281–1291 (1998)
63. I. Pomerancz, K. Cheng, STOIC: state assignment based on output/input functions. IEEE Trans.
Comput.-Aided Des. Integr. Circuits Syst. 12(8), 1123–1131 (1993)
64. QuickLogic: http://www.quicklogic.com. Accessed Jan 2015
65. M. Rawski, T. Łuba, Z. Jachna, P. Tomaszewicz, Design of Embedded Control Systems, chapter
The inﬂuence of functional decomposition on modern digital design process (Springer, Boston,
2005), pp. 193–203
66. M. Rawski, H. Selvaraj, T. Łuba, An application of functional decomposition in ROM-based
FSM implementation in FPGA devices. J. Syst. Architect. 51(6–7), 423–434 (2005)
67. K. Roy, S. Prasad, SYCLOP: synthesis of CMOS logic for low power applications, in Pro-
ceedings, IEEE 1992 International Conference on Computer Design: VLSI in Computers and
Processors, ICCD’92. IEEE (1992), pp. 464–467
68. R. Rudell, A. Sangiovanni-Vincentelli, Multiple-valued minimization for PLA optimization.
IEEE Trans. Comput.-Aided Des. 6(5), 727–750 (1987)
69. G. Saucier, M. Depaulet, P. Sicard, ASYL: a rule-based system for controller synthesis. IEEE
Trans. Comput.-Aided Des. 6(11), 1088–1098 (1987)
70. G. Saucier, P. Sicard, L. Bouchet, Multi-level synthesis on programmable devices in the ASYL
system, in Proceedings of Euro ASIC (1990), pp. 136–141
71. C. Scholl, Functional Decomposition with Application to FPGA Synthesis (Kluwer Academic
Publishers, Boston, 2001)
72. R. Senhadji-Navarro, I. Garcia-Vargas, G. Jiménez-Moreno, A. Civit-Balcells, P. Guerra-
Gutierrez, ROM-based FSM implementation using input multiplexing in FPGA devices. Elec-
tron. Lett. 40(20), 1249–1251 (2004)
73. E. Sentowich, K. Singh, L. Lavango, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. Stephan,
R. Bryton, A. Sangiovanni-Vincentelli, SIS: a system for sequential circuit synthesis. Technical
Report, University of California, Berkely (1992)
74. E. Sentowich, K. Singh, L. Lavango, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. Stephan,
R. Bryton, A. Sangiovanni-Vincentelli, SIS: a system for sequential circuit synthesis, in Pro-
ceedings of the International Conference of Computer Design (ICCD’92) (1992), pp. 328–333
75. I. Skliarova, V. Sklyarov, A. Sudnitson, Design of FPGA-Based Circuits Using Hierarchical
Finite State Machines (TUT Press, Tallinn, 2012)
76. V. Sklyarov, Synthesis and implementation of RAM-based ﬁnite state machines in FPGAs, in
Proceedings of Field-Programmable Logic and Applications: The Roadmap to Reconﬁgurable
Computing, Villach. Springer (2000), pp. 718–728

64
2
Field Programmable Gate Arrays in FSM Design
77. V.Sklyarov,I.Skliarova,A.Barkalov,L.Titarenko,SynthesisandOptimizationofFPGA-Based
Systems. Lecture Notes in Electrical Engineering, vol. 294 (Springer, Berlin, 2014)
78. V. Solovjev, M. Czyzy, Reﬁned CPLD macrocells architecture for effective FSM implemen-
tation, in Proceedings of the 25th EUROMICRO Conference, vol. 1, Milan, Italy (1999),
pp. 102–109
79. V. Solovjev, M. Czyzy, The universal algorithm for ﬁtting targeted unit to complex program-
mable logic devices, in Proceedings of the 25th EUROMICRO Conference, vol. 1, Milan, Italy
(1999), pp. 286–289
80. V. Solovjev, M. Czyzy, Synthesis of sequential circuits on programmable logic devices based
on new models of ﬁnite state machines, in Proceedings of the EUROMICRO Conference, Milan
(2001), pp. 170–173
81. G. Sutter, E. Todorovich, S. López-Buedo, E. Boemo, Low-power FSMs in FPGA: encod-
ing alternatives, in Integrated Circuit Design. Power and Timing Modeling, Optimization and
Simulation. Springer (2002), pp. 363–370
82. E. Tatalov, Synthesis of compositional microprogram control units for programmable devices.
Master’s thesis, Donetsk National Technical University, Donetsk (2011)
83. A. Tiwari, K. Tomko, Saving power by mapping ﬁnite-state machines into embedded memory
blocksinFPGAs,inProceedingsoftheConferenceonDesign,AutomationandTestinEurope—
Volume 2. IEEE Computer Society (2004), pp. 916–921
84. C. Tsui, M. Pedram, A. Despain, Exact and approximate methods for calculating signal and
transition probabilities in FSMs, in 31st Conference on Design Automation. IEEE (1994), pp.
18–23
85. G. Venkatamaran, S. Reddy, I. Pomerancz, GALLOP: genetic algorithm based low power
FSM synthesis by simultaneous partitioning and state assignment, in Proceedings of 16th
International Conference on VLSI Design (2003), pp. 533–538
86. T. Villa, T. Saldachna, R. Brayton, A. Sangiovanni-Vincentelli, Symbolic two-level minimiza-
tion. IEEE Trans. Comput.-Aided Des. 16(7), 692–708 (1997)
87. T. Villa, A. Sangiovanni-Vincentelli, NOVA: state assignment of ﬁnite state machines for
optimal two-level logic implememntation. IEEE Trans. Comput.-Aided Des. 9(9), 905–924
(1990)
88. Y. Xia, A. Almani, Genetic algorithm based state assignment for power and area optimization.
IEEE Proc. Comput. Digital Tech. 149, 128–133 (2002)
89. Xilinx: http://www.xilinx.com. Accessed Jan 2015
90. Xilinx: XST User Guide. V. 11.3, http://www.xilinx.com/support/documentation/sw_manuals/
xilinx11/xst.pdf. Accessed Jan 2015
91. S. Yang, Logic synthesis and optimization benchmarks user guide. Technical report, Micro-
electronic Center of North Carolina (1991)
92. B. Zeidman, Designing with FPGAs and CPLDs (CMP Books, Lawrence, 2002)

Chapter 3
Object Codes Transformation for Mealy
FSMs
3.1 Principle of OCT for Mealy FSMs
The principle of object codes transformation (OCT) was proposed in [1] and devel-
oped in [2–6]. In accordance with this principle, there are two kinds of objects in an
FSM. They are internal states am ∈A and CMOs Yt ⊆Y. Let us point out that the
states and collections of microoperations have different nature. So, they are hetero-
geneous objects, in contrast to, for example, state am and state as. In this Chapter,
we discuss some hardware reduction methods based on transformation of codes for
heterogeneous objects.
The discussed methods are based on ﬁnding the one-to-one correspondence
between heterogeneous objects. When it is found, a code of one object is gener-
ated as a function depended on logical conditions xe ∈X and state variables Tr ∈T.
It is a primary object. A code of the second object is generated using variables, rep-
resenting the ﬁrst object, and additional variables, encoding the identiﬁers. It is a
second object.
Let us ﬁnd a one-to-one match A →Y among the states and CMOs, where states
are primary and CMOs are secondary objects. In the case of Mealy FSM, the BIMF
generates functions (1.4) and some additional variables vr ∈V used for encoding of
the identiﬁers. Next, these variables are transformed into codes of CMOs (it could
be unitary codes where each MO yn ∈Y corresponds to a single bit of C(Yt)).
Let us start from PA Mealy FSM (Fig.3.1). Here BIMF generates the system (1.4)
and the system
V = V(T, X).
(3.1)
The variables vr ∈V are used for encoding of identiﬁers. We discuss how to form
this set a bit later .
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_3
65

66
3
Object Codes Transformation for Mealy FSMs
Fig. 3.1 Structural diagram of PA Mealy FSM
(a)
(b)
Fig. 3.2 Structural diagram of PAY (a) and PAD (b) Mealy FSM
There is the following system of functions generated by BMO:
Y = Y(T, V).
(3.2)
Ifwecompareexpressions(1.3)and(3.2),wecanmakeaconclusionthatthevariables
vr ∈V replace the logical conditions xe ∈X. Let it be RV = |V|. If RV ≪L, then
functions (3.2) require less amount of literals in their terms in comparison with
functions (1.3). This allows to hope that it is necessary fewer hardware in BMO in
comparison with the corresponding part of the circuit of P Mealy FSM.
It is possible to encode the collections of MOs. Using the maximal encoding of
CMOs leads to PAY Mealy FSM (Fig.3.2a), whereas the encoding of the ﬁelds of
compatible microoperations leads to PAD Mealy FSM (Fig.3.2b). A block of code
transformer (BCT) implements the system
Z = Z(T, V).
(3.3)
Next, the BMO generates functions (1.40).

3.1 Principle of OCT for Mealy FSMs
67
Fig. 3.3 Structural diagram of MPA Mealy FSM
To show the difference between PAY and PAD FSMs, we use a letter Y (for the
maximal encoding of CMOs) and D (for the encoding of the ﬁelds of compatible
microoperations).
It is possible to use the RLC in the cases of PA, PAY and PAD FSMs. It leads to
MPA, MPAY and MPAD FSMs. For example, there is a structural diagram of MPA
Mealy FSM shown in Fig.3.3.
In MPA FSM, the BRLC implements the system (1.47), the BMO the system
(3.2). The BIMF implements the system (1.49) and the system
V = V(T, P).
(3.4)
Let us ﬁnd a one-to-one match Y →A among the microoperations as primary
objects and the states as secondary objects. It leads to PY (with unitary encoding
of MOs) or PYY (with maximal encoding of CMOs) or PYD (with encoding of the
ﬁelds of compatible microoperations) Mealy FSM (Fig.3.4).
In PY Mealy FSM, the BMO implements systems (1.3) and (3.1). They are trans-
formed by BIMF into the input memory functions
Φ = Φ(V, Y).
(3.5)
In PYY Mealy FSM, the BMOY implements functions (3.1) and (2.30). They are
transformed by BIMF in the functions
Φ = Φ(V, Z).
(3.6)
The functions (1.40) are implemented by BMO.
In PYD Mealy FSM, the BMOD implements the functions (3.1) and (2.30). The
BIMF implements the system (3.6), whereas the BMO the system (1.40).
Using RLC leads to MPY, MPYY and MPYD FSMs. For example, the structural
diagram of MPY Mealy FSM is shown in Fig.3.5.
Let us discuss design methods for FPGA-based Mealy FSMs based on OCT. As
always, there are possible homogeneous or heterogeneous approaches for imple-
menting FSM logic circuits.

68
3
Object Codes Transformation for Mealy FSMs
(a)
(b)
(c)
Fig. 3.4 Structural diagram of PY (a), PYY (b) and PYD (c) Mealy FSM
Fig. 3.5 Structural diagram of MPY Mealy FSM
Basing on results from [2], the following method can be proposed for synthesis
of PA Mealy FSM.
1. Marking the initial GSA Γ and creating a set A.
2. Constructing the FSM structure table.
3. Finding the collections of microoperations Yt ⊆Y.
4. Constructing the set of identiﬁers I.
5. Representing CMOs by pairs ⟨identiﬁer, state⟩.
6. Constructing the table of BIMF.
7. Constructing the table of BMO.
8. Implementing FSM logic circuit.

3.1 Principle of OCT for Mealy FSMs
69
Table 3.1 Structure table of Mealy FSM S1
am
K(am)
as
K(as)
Xh
Yh
Φh
h
a1
000
a2
010
x1
y1y2
D2
1
a3
011
¯x1
y3
D2D3
2
a2
010
a2
010
x2
y1y2
D2
3
a3
011
¯x2x3
y3
D2D3
4
a4
100
¯x2 ¯x3
y1y2
D1
5
a3
011
a4
100
x1
y2y5
D1
6
a5
101
¯x1
y6
D1D3
7
a4
100
a5
101
1
y3y7
D1D3
8
a5
101
a2
010
x2x3
y1y2
D2
9
a3
011
x2 ¯x3
y3
D2D3
10
a5
101
¯x2x4
y3y7
D1D3
11
a1
000
¯x2 ¯x4
–
–
12
Let us discuss an example for design of PA Mealy FSM S1 represented by the
structure table (Table3.1).
There are T0 = 6 different CMOs in Table3.1. They are Y1 = ∅, Y2 = {y1, y2},
Y3 = {y3}, Y4 = {y2, y5}, Y5 = {y6}, Y6 = {y3, y7}.
Let us use the following approach to ﬁnd the set I. Let T(as) be a set of CMOs
generated under transitions into the state as ∈A. Let it be ns = |T(aS)|. Obviously
it is enough ns of identiﬁers to select one of those CMOs.
To identify any of CMOs Yt ∈Y, it is enough K identiﬁers, where K =
max(n1, . . . , nM). They form a set of identiﬁers I = {I1, . . . , IK}.
There are the following sets T(as) in Table3.1: T(a1) = {y1}, T(a2) = {y2},
T(a3) = {y3}, T(a4) = {y2, y4}, T(a5) = {y5, y6}. So, there is K = 2. It gives the
set I = {I1, I2}.
Let us ﬁnd the pairs ⟨Ik, as⟩determining the CMOs Yt ∈Y. If there is only a
single Yt in a set T(as), then Ik = ∅. If there are more than one pair determining
a collection Yt, then these pairs are connected by the sign of disjunction. There are
the following correspondence among the CMOs and pairs in the discussed example:
Y1 = ⟨∅, a1⟩; Y2 = ⟨∅, a2⟩∨⟨I1, a4⟩; Y3 = ⟨∅, a3⟩; Y4 = ⟨I2, a4⟩; Y5 = ⟨I1, a5⟩;
Y6 = ⟨I2, a5⟩.
Let us encode the identiﬁers Ik ∈I. It is enough RV bits for the encoding:
RV = ⌈log2 K⌉.
(3.7)
In the discussed case, there is RV = 1. It determines the set V = {v1}. Let it be
K(I1) = 0 and K(I2) = 1.
There are the following columns in the table of BIMF: am, K(am), as, K(as), Xh,
Ih, K(Ih), Vh, Φh, h. It is constructed on the base of a ST. To do it, the column Yh
is replaced by the columns Ih (identiﬁer for the collection Yt ∈Y), K(Ih) (the code
of Ih) and Vh (the variables vr ∈V in the code K(Ih)). There is the same amount

70
3
Object Codes Transformation for Mealy FSMs
Table 3.2 Table of BIMF for PA Mealy FSM S1
am
K(am)
as
K(as)
Xh
Ih
K(Ih)
Vh
Φh
h
a1
000
a2
010
x1
–
–
∗
D2
1
a3
011
¯x1
–
–
∗
D2D3
2
a2
010
a2
010
x2
–
–
∗
D2
3
a3
011
¯x2x3
–
–
∗
D2D3
4
a4
100
¯x2 ¯x3
I1
0
–
D1
5
a3
011
a4
100
x1
I2
1
v1
D1
6
a5
101
¯x1
I1
0
–
D1D3
7
a4
100
a5
101
1
I2
1
v1
D1D3
8
a5
101
a2
010
x2x3
–
–
∗
D2
9
a3
011
x2 ¯x3
–
–
∗
D2D3
10
a5
101
¯x2x4
I2
1
v1
D1D3
11
a1
000
¯x2 ¯x4
–
–
∗
–
12
of rows in a ST and a corresponding table of BIMF. In the discussed case, there is
H0 = 12 rows in the table of BIMF for PA Mealy FSM S1 (Table3.2). If some CMO
is determined by a pair ⟨∅, as⟩, then there is a sign “–” in the corresponding row of
the table in the column K(Ih).
The sign “*” means that the variables Vh are of no concern for functions (3.2). The
table of BIMF is used to ﬁnd functions (1.4) and (3.1). The functions (3.1) depend on
the same terms as the functions (1.4). There is the following equation derived from
Table3.2:
v1 = ¯T1T2T3 ∨T1 ¯T2.
(3.8)
To get the term T1 ¯T2 from (3.8), we used the “don’t care” assignment from Table3.2.
There are the following columns in the table of BMO: as, K(as), Ih, K(Ih), Yh,
h. This table is constructed on the base of Tables3.1 and 3.2 in the discussed case.
It is Table3.3 in the discussed case. This table has 7 rows, which is the same as the
number of pairs representing CMOs Yt ⊆Y. In the common case, the number HBMO
is determined as:
HBMO =
M0

s=1
ns.
(3.9)
In (3.5), the symbol HBMO stands for the number of rows in the table of BMO.
This table is used for deriving the system (3.2). It is represented as a system having
N following functions:
yn =
HBMO

h=1
CnhAmVh (n = 1, N).
(3.10)

3.1 Principle of OCT for Mealy FSMs
71
Table 3.3 Table of BMO for PA Mealy FSM S1
am
K(am)
Ih
K(Ih)
Yh
h
a1
000
–
–
–
1
a2
010
–
–
y1y2
2
a3
011
–
–
y3
3
a4
100
I1
0
y1y2
4
a4
100
I2
1
y2y5
5
a5
101
I1
0
y6
6
a6
101
I2
1
y3y7
7
In (3.10), the symbol Cnh stands for Boolean variable equal to 1 iff the MO yn ∈Y
is written in the row number h(h = 1, HBMO). Let us point out that there is Vh = 1
if K(Yh) = ′′−′′. It is possible to derive the following equations from Table3.3:
y1 = ¯T1T2 ¯T3 ∨T1 ¯T2 ¯T3 ¯v1;
y2 = ¯T1T2 ¯T3 ∨T1 ¯T2 ¯T3 ¯v1 ∨T1 ¯T2 ¯T3v1 = ¯T1T2 ¯T3 ∨T1 ¯T2 ¯T3;
y3 = ¯T1T2T3 ∨T1 ¯T2T3v1;
y5 = T1 ¯T2 ¯T3v1;
y6 = T1 ¯T2T3 ¯v1;
y7 = T1 ¯T2T3v1.
(3.11)
The same approach can be used for logic synthesis of other models based on the
one-to-one match of states and CMOs. They are the models PAY, PAD, MPA, MPAY
and MPAD. Of course, the corresponding methods should include such steps as
encoding of CMOs, executing of RLC, constructing tables of BRLC, BCTY, BCTD,
BMOY and BMOD. Now let us discuss the methods based on the correspondence
Y →A.
There are the same steps in design methods for PA and PY Mealy FSMs [2]. But
there is a difference in execution of some steps. Moreover, the step 5 is the following:
“Representing the state as ∈A by the pairs ⟨identiﬁer, CMO⟩”.
Let us discuss an example of synthesis for PY Mealy FSM S1 (Table3.1). There
are the set A and collections Yt ⊆Y which were found before.
Let A(Yt) be a set of states such that the microoperations yn ∈Yt are generated
under transitions into these states as ∈A. It is possible to ﬁnd the following sets
A(Yt) for FSM S1: A(Y1) = {a1}, A(Y2) = {a2, a4}, A(Y3) = {a3}, A(Y4) = {a4},
A(Y5) = {a5} and A(Y6) = {a5}. Let it be nt = |A(Yt)|. Now, the number of
identiﬁers can be found as K = max(n1, . . . , nT0). They form a set I = {I1, . . . , IK}.
The formula (3.7) is used to ﬁnd the number of elements in the set V.
In the discussed case, there is K = 2. It determines the set V = {v1}. Let it be
K(I1) = 0 and K(I2) = 1.

72
3
Object Codes Transformation for Mealy FSMs
Table 3.4 Table of BIMF for PY Mealy FSM S1
Yh
Vh
am
K(am)
Φh
h
∅
∗
a1
000
–
1
y1y2
0
a2
010
–
2
y3
∗
a3
011
–
3
y2y5
∗
a4
100
–
4
y1y2
1
a4
100
–
5
y6
∗
a5
101
–
6
y3y7
∗
a6
101
–
7
Let us ﬁnd the pairs ⟨IK, Yt⟩corresponding the states am ∈A. There are the
following formulae in the discussed case: a1 = ⟨∅, Y1⟩, a2 = ⟨I1, Y2⟩, a3 = ⟨∅, Y3⟩,
a4 = ⟨∅, Y4⟩∨⟨I2, Y2⟩, a5 = ⟨∅, Y5⟩∨⟨∅, Y6⟩.
There are the following columns in the table of BIMF: Yh, Vh, am, K(am), Φh,
h. This table is constructed on the base of an ST and the system of pairs discussed
above. The table includes HBIMF rows:
HBIMF =
T0

t=1
nt.
(3.12)
In the discussed case, the BIMF is represented by Table3.4.
This table is used for constructing the system (3.4). For example, the following
equations can be derived from Table3.4:
D1 = y2y5 ∨y1y2v1 ∨y6 ∨y3y7;
D2 = y1y2 ¯v1 ∨y3;
D3 = y3 ∨y6 ∨y3y7 = y3 ∨y6.
(3.13)
There are the following columns in the table of BMO for PY Mealy FSM: am,
K(am), as, Xh, Yh, Vh, h. It is constructed on the base of an ST and the system of
pairs for states am ∈A. In the discussed case, the BMO is represented by Table3.5.
This table is used for deriving the systems (1.3) and (3.1). There is only a single
equation in the system (3.1) for the discussed case:
v1 = ¯T1T2 ¯T3 ¯x2 ¯x3.
(3.14)
Using the “don’t care” state assignment 110, this equation can be minimized up to
v1 = T2 ¯T3 ¯x2 ¯x3.
Let us point out that we use the law of Boolean algebra for optimizing the equation
D3 from (3.13). It is the following law: a ∨ab = a [7].
Now let us discuss FPGA-based approaches for designing FSMs based on the
OCT.

3.2 Synthesis of FPGA-Based Mealy FSMs with Transformation of States
73
Table 3.5 Table of BMO for PY Mealy FSM S1
am
K(am)
as
Xh
Yh
Vh
h
a1
000
a2
x1
y1y2
–
1
a3
¯x1
y3
–
2
a2
010
a2
x2
y1y2
–
3
a3
¯x2x3
y3
–
4
a4
¯x2x3
y1y2
v1
5
a3
011
a4
x1
y2y5
–
6
a5
¯x1
y6
–
7
a4
100
a5
1
y3y7
–
8
a5
101
a2
x2x3
y1y2
–
9
a3
x2 ¯x3
y3
–
10
a5
¯x2x4
y3y7
–
11
a1
¯x2 ¯x4
–
–
12
3.2 Synthesis of FPGA-Based Mealy FSMs with
Transformation of States
Let us start from PA Mealy FSMs (Fig.3.1). Let us start from the homogeneous
approach shown in Fig.3.6. Let us denote this FSM as PA1 Mealy FSM.
In PA1 Mealy FSM, the LUTer1 implements systems (1.4) and (3.1), the LUTer2
the system (3.2). There are the following steps in the design method of PA1 Mealy
FSM:
1. Marking the initial GSA Γ and creating the set A.
2. Constructing the structure table of P Mealy FSM.
3. Finding the collections of microoperations Yt ⊆Y.
4. Constructing the set of identiﬁers I = {I1, . . . , IK}.
5. Representing CMOs by pairs ⟨identiﬁer, state⟩.
6. Constructing the table of LUTer1.
7. Constructing the table of LUTer2.
8. Implementing FSM logic circuit.
Fig. 3.6 Structural diagram
of PA1 Mealy FSM

74
3
Object Codes Transformation for Mealy FSMs
Fig. 3.7 Structural diagram
of PA2 Mealy FSM
There are R0 + RV different subcircuits in the circuit of LUTer1. Let L(f ) be the
number of literals in SOP of some function f . Let the following condition take place:
max(L(D1), . . . , L(DR0), L(v1), . . . , L(vRV )) ≤S.
(3.15)
In this case, there are exactly R0 + Rv of LUTs having S inputs in the circuit of
LUTer1. It is a single-level circuit.
There are N of different subcircuits in the circuit of LUTer2. Let the following
condition take place:
max(L(y1), . . . , L(Yn)) ≤S.
(3.16)
In this case, there are exactly N of LUTs in the circuit of LUTer2.
Let us discuss the PA1 Mealy FSM S1 starting from Table3.1. It is clear that there
are the same steps in the design methods for PA and PA1 Mealy FSMs. So, the LUTer1
is represented by Table3.2 and the LUTer2 by Table3.3. We hope that everything is
clear with this example.
It is possible to implement both blocks of PA FSM with EMBs. It leads to PA2
Mealy FSM (Fig.3.7). In this case, the EMBer1 corresponds to BIMF and the
EMBer2 to BMO. There are the same steps in the design of PA and PA2 FSMs.
But the step 6 is reduced to constructing the table of EMBer1, whereas the step 7 to
constructing the table of EMBer2.
There are the following columns in the table of EMBer1 of PA2 Mealy FSM:
K(am), X (they determine the address of a cell), V, Φ (they determine the content of
a cell), q (the number of a cell). The table has Q1(PA2) rows, where
Q1(PA2) = 2R0+L.
(3.17)
There is Q1(PA2) = 64 in the case of PA2 Mealy FSM S1. To describe transitions
from a state am ∈A, it is necessary H(am) rows, where
H(am) = 2L.
(3.18)
There is H(am) = 8 in the case of PA2 Mealy FSM S1. Table3.6 represents the
part of table of EMBer1 with transitions from the state a3 ∈A. It is constructed on

3.2 Synthesis of FPGA-Based Mealy FSMs with Transformation of States
75
Table 3.6 Part of table of EMBer1 for PA2 Mealy FSM S1
K(am)
X
V
Φ
T1T2T3
x1x2x3
v1
D1D2D3
q
h
011
000
0
110
24
7
011
001
0
110
25
7
011
010
0
110
26
7
011
011
0
110
27
7
011
100
1
100
28
6
011
101
1
100
29
6
011
110
1
100
30
6
011
111
1
100
31
6
the base of Table3.2. We add the column h in this table to show the correspondence
among rows of Tables3.2 and 3.6.
There are cells having addresses from 011000 till 011111 in Table3.6. It corre-
sponds to values of q from 24 till 31. The row 6 of Table3.2 corresponds to the
rows 28–31 of Table3.6. The row 7 of Table3.2 corresponds to the rows 24–27 of
Table3.6. The content of corresponding cells is taken from Table3.2.
Using the same approach, it is possible to ﬁnd all subtables corresponding to table
of BIMF. They are combined together to form the table of EMBer1.
Therearethefollowingcolumns inthetableof EMBer2:K(am), V (theydetermine
the address of a cell), Y (it determines the content of a cell), q. The table has Q2(PA2)
rows:
Q2(PA2) = 2R0+RV .
(3.19)
There is Q2(PA2) = 16 in the case of PA2 Mealy FSM S1. The table of EMBer2 is
represented by Table3.7.
Table 3.7 Table of EMBer2 for PA2 Mealy FSM S1
K(am)
V
Y
K(am)
V
Y
T1T2T3 v1
y1y2y3y4y5y6y7
q
T1T2T3 v1
y1y2y3y4y5y6y7
h
000
0
000000
1
100
0
110000
9
000
1
000000
2
100
1
010100
10
001
0
000000
3
101
0
000010
11
001
1
000000
4
101
1
000001
12
010
0
110000
5
110
0
000000
13
010
1
110000
6
110
1
000000
14
011
0
001000
7
111
0
000000
15
011
1
001000
8
111
1
000000
16

76
3
Object Codes Transformation for Mealy FSMs
(a)
(b)
Fig. 3.8 Heterogeneous structural diagrams of PA Mealy FSM
Table 3.8 Structural diagrams of PAY Mealy FSMs
Block
PA1Y
PA2Y
PA3Y
PA4Y
PA5Y
PA6Y
PA7Y
PA8Y
BIMF
L1
L1
L1
B1
L1
B1
B1
B1
BCTY
L2
L2
B1
L1
B2
B2
L1
B2
BMOY
L3
B1
L2
L2
B3
L3
B2
B3
The rows 1 and 2 correspond to state a1 with Y(a1) = ∅. The rows 3 and 4
correspond to the code 001 which is not used. The same is true for rows 13–16. The
rows 5 and 6 correspond to state a2. There is the CMO Y2 under transition into a2.
Different CMOs are generated under transitions in the state a4. If v1 = 0, then it is
Y2. If v1 = 1, then it is Y4.
Now let us discuss the heterogeneous approach for implementing the PA Mealy
FSM. It is possible to implement the BIMF as LUTer and BMO as EMBer. It leads
to PA3 Mealy FSM (Fig.3.8a). If the BIMF is implemented as EMBer and the BMO
as LUTer, it leads to PA4 Mealy FSM (Fig.3.8b).
It is very easy to work out the design methods for both PA3 and PA4 FSMs. It
can be done on the base of the method for PA1 Mealy FSM. We do not discuss those
methods in this book.
It is possible to make the following conclusion from the previous discussion. If
there are KB blocks in the structural diagram of an FSM, then it is possible
nSD = 2KB
(3.20)
different combinations of LUTers and EMBers in its structural diagram.
Let us discuss different approaches for implementing PAY Mealy FSMs. It follows
from Fig.3.2a that there is KB = 3. So, it is possible 8 different combinations for
FPGA-based PAY Mealy FSMs. They are represented by Table3.8. The symbol Li
stands for LUTeri (i=1, 2, 3), whereas the symbol Bi stands for EMBeri (i=1, 2, 3).
There are the following steps in design methods for PAiY Mealy FSMs (i = 1, 8):
1. Marking the initial GSA Γ and creating the set A.
2. Constructing the structure table of P Mealy FSM.
3. Finding the collections of microoperations Yt ∈Y.

3.2 Synthesis of FPGA-Based Mealy FSMs with Transformation of States
77
Table 3.9 Transformed ST of PY Mealy FSM S1
am
K(am)
as
K(as)
Xh
Yt
C(Yt)
Zh
Φh
h
a1
000
a2
010
x1
y2
001
z3
D2
1
a2
011
¯x1
y3
010
z2
D2D3
2
a2
010
a2
010
x2
y2
001
z3
D2
3
a3
011
¯x2x3
y3
010
z2
D2D3
4
a4
100
¯x2 ¯x3
y3
010
z2
D2D3
5
a3
011
a4
100
x1
y4
011
z2z3
D2
6
a5
101
¯x1
y5
100
z1
D2D3
7
a4
100
a5
101
1
y6
101
z1z3
D1D3
8
a5
101
a2
010
x2x3
y2
001
z3
D2
9
a3
011
x2 ¯x3
y3
010
z2
D2D3
10
a5
101
¯x2x4
y6
101
z1z3
D2D3
11
a1
000
¯x2 ¯x4
–
000
–
–
12
4. Constructing the set of identiﬁers I = {I1, . . . , IK}.
5. Representing CMOs by pairs ⟨Ik, as⟩.
6. Encoding of collections of microoperations.
7. Constructing the transformed ST of PY Mealy FSM.
8. Constructing the table of BIMF.
9. Constructing the table of BCTY.
10. Constructing the table of BMOY.
11. Transformation of tables for implementing LUTers or EMBers.
Let us discuss an example of synthesis for PA6Y Mealy FSM S1. Table3.1 rep-
resents the P Mealy FSM S1. Let us point out that steps 1–6 are already executed.
Remind that there are T0 = 6 of different CMOs in the discussed case: Y1 = ∅,
Y2 = {y1, y2}, Y3{y3}, Y4 = {y2, y5}, Y5 = {y6} and Y6 = {y3, y7}.
Using (1.32), we can ﬁnd RZ = 3. It gives the set Z = {z1, z2, z3}. Let us encode
the CMOs Yt ⊆Y in the trivial way: C(Y1) = 000,…,C(Y6) = 101.
The transformed ST of PY Mealy FSM is constructed on the base of its ST. To do
it, the column Yh is replaced by columns Yt, C(Yt) and Zh. The column Zh includes
the variables zr ∈Z equal 1in the code C(Yt) from h-th row of the table (h = 1, H0).
It is Table3.9 in the discussed case.
BasingonTable3.8,itispossibletoderivethestructuraldiagramshowninFig.3.9.
So, in the PA6Y Mealy FSM, the BIMF is implemented as EMBer1, the BCTY as
EMBer2, and the BMOY as LUTer1.
Tables of BIMF are the same for equivalent PA and PAiY Mealy FSMs. So,
Table3.2 represents the table of BIMF for PA6Y Mealy FSM S1.
There are the following columns in the table of BCTY: as, K(as), Ih, K(Ih),
Yh, C(Yh), Zh, h. This table contains HBMO rows determined by (3.9). Table3.10
represents the table of BCTY in the discussed case. It is based on Table3.3.

78
3
Object Codes Transformation for Mealy FSMs
Fig. 3.9 Structural diagram of PA6Y Mealy FSM
Table 3.10 Table of BCTY for PA6Y Mealy FSM S1
as
K(as)
Ih
K(Ih)
Yh
C(Yh)
Zh
h
a1
000
–
–
y1
000
–
1
a2
010
–
–
y2
001
z3
2
a3
011
–
–
y3
010
z2
3
a4
100
I1
0
y2
001
z3
4
a4
100
I2
1
y4
011
z2z3
5
a5
101
I1
0
y5
100
z1
6
a5
101
I2
1
y6
101
z2z3
7
This table is used for constructing the system (3.3). There are the following
equations derived from Table3.10:
z1 = T1T3;
z2 = T2T3 ∨T1 ¯T2 ¯T3v1;
z3 = T2 ¯T3 ∨T1.
(3.21)
We use codes 110 and 111 to optimize the equations (3.21).
There are the following columns in table of BMOY: Yt, C(Yt), Yh, h. It is Table3.11
in the discussed case.
This table is used to derive the system (1.40). For example, it is possible to ﬁnd
the equations y2 = ¯z1z3 or y3 = ¯z1z2 ¯z3 ∨z1 ¯z2z3 from Table3.11.
As it is pointed before, the tables of BIMF are the same for PA ans PAiY Mealy
FSMs (i = 1, 6). It means that Table3.6 represents the table of EMBer1 for PA6Y
Mealy FSM S1.
Table 3.11 Table of BMOY for PA6Y Mealy FSM S1
Yt
C(Yt)
Yh
h
Yt
C(Yt)
Yh
h
Y1
000
–
1
Y4
011
y2y5
4
Y2
001
y1y2
2
Y5
100
y6
5
Y3
010
y3
3
Y6
101
y3y7
6

3.2 Synthesis of FPGA-Based Mealy FSMs with Transformation of States
79
Table 3.12 Table of EMBer2 for PA6Y Mealy FSM S1
K(as)
V
Z
q
K(as)
V
Z
q
T1T2T3
v1
z1z2z3
T1T2T3
v1
z1z2z3
000
0
000
1
100
0
001
9
000
1
000
2
100
1
011
10
001
0
000
3
101
0
100
11
001
1
000
4
101
1
101
12
010
0
001
5
110
0
000
13
010
1
001
6
110
1
000
14
011
0
010
7
111
0
000
15
011
1
010
8
111
1
000
16
Table 3.13 Table of LUTer2 for PA6Y Mealy FSM S1
C(Yt)
Yt
t
C(Yt)
Yt
t
z1z2z3
y1y2y3y4y5y6y7
z1z2z3
y1y2y3y4y5y6y7
000
000000
1
100
000010
5
001
110000
2
101
000001
6
010
001000
3
110
000000
7
011
010100
4
111
000000
8
Table 3.14 Structural diagrams of PAD Mealy FSMs
Block
PA1D
PA2D
PA3D
PA4D
BIMF
L1
L1
B1
B1
BCTD
L2
B1
L1
B2
BMOD
L3
L2
L2
L1
There are the following columns in the table of EMBer2: K(as), V (they determine
the address of a cell), Z, q. It is Table3.12 in the discussed case.
Table3.12 is constructed on the base of Table3.10. For example, the cells with
q = 5 and q = 6 correspond to the row h = 2 of Table3.10; the cell with q = 9
corresponds to h = 4, and so on.
There are the following columns in the table of LUTer1: C(Yt), Yt, t. In the
discussed case, it has T0 = 8 rows (Table3.13).
This table is constructed on the base ot Table3.11. It determines N of tables for
LUTs forming the circuit of the LUTer1.
There is no sense in using EMBs for implementing the circuit of BMOD. So,
there are four different structures of PAD Mealy FSMs (Table3.14).

80
3
Object Codes Transformation for Mealy FSMs
There are the following steps in design methods for PAiD Mealy FSMs (i = 1, 4):
1. Marking the initial GSA Γ and creating the set A.
2. Constructing the structure table of P Mealy FSM.
3. Finding the collections of microoperations Yt ∈Y.
4. Constructing the set of identiﬁers I = {I1, . . . , IK}.
5. Representing CMOs by pairs ⟨IK, as⟩.
6. Encoding of the ﬁelds of compatible microoperations.
7. Constructing the transformed ST of PD Mealy FSM.
8. Constructing the table of BIMF.
9. Constructing the table of BCTD.
10. Constructing the table of BMOD.
11. Transformation of tables for implementing LUTers and EMBers.
12. Implementing the FSM logic circuit.
We do not discuss this approach in this Chapter. Let us point out that it is possible
using RLC for each of the discussed FSMs. It gives MPAi(i = 1, 4), MPAiY(i = 1, 8)
and MPAiD(i = 1, 4) models of Mealy FSM based on the transformation of am ∈A
into Yt ∈Y. We discuss some examples a bit later in this chapter.
3.3 Synthesis of FPGA-Based Mealy FSMs
with Transformation of CMOs
Let us start from PY Mealy FSM (Fig.3.4a) There are four different structural dia-
grams of this FSM (Table3.15).
TherearethefollowingstepsinthedesignmethodsforPYi MealyFSMs(i = 1, 4):
1. Marking the initial GSA Γ and creating the set A.
2. Constructing the structure table of P Mealy FSM.
3. Finding the collections of microoperations Yt ∈Y.
4. Constructing the set of identiﬁers I = {I1, . . . , IK}.
5. Representing the states am ∈A by pairs ⟨Ik, Yt⟩.
6. Constructing the table of BIMF.
7. Constructing the table of BMO.
8. Transformation of tables for implementing LUTers and EMBers.
9. Implementing the FSM logic circuit.
Table 3.15 Structural diagrams of PYi Mealy FSMs
Block
PY1D
PY2D
PY3D
PY4D
BIMF
L1
L1
B1
B1
BMO
L2
B1
L1
B2

3.3 Synthesis of FPGA-Based Mealy FSMs with Transformation of CMOs
81
Table 3.16 Structure table of Mealy FSM S2
am
K(am)
as
K(as)
Xh
Yt
Φh
h
a1
000
a2
001
x1
y1y2
D3
1
a3
010
¯x1
y3
D2
2
a2
001
a2
001
x2
y1y2
D3
3
a3
010
¯x2x3
y1y4
D2
4
a4
011
¯x2 ¯x3
y1y2
D2D3
5
a3
010
a4
011
x1
y3
D2D3
6
a5
100
¯x1
y1y4
D1
7
a4
011
a5
100
1
y4y5
D1
8
a5
100
a2
001
x2x3
y3
D3
9
a3
010
x2 ¯x3
y6
D2
10
a6
101
¯x2x4
y5y7
D1D3
11
a1
000
¯x2 ¯x4
–
–
12
a6
101
a3
010
1
y6
D2
13
Fig. 3.10 Structural
diagram of PY3 Mealy FSM
Let us discuss an example of design for PY3 Mealy FSM S2. Table3.16 represents
the Mealy FSM S2. It is the structural diagram of PY3 Mealy FSM shown in Fig.3.10.
The following sets can be derived from Table3.16: A = {a1, . . . , a6}, X =
{x1, . . . , x4}, Y = {y1, . . . , y7}, Φ = {D1, D2, D3}, T = {T1, T2, T3}. It gives the
values: M = 6, L = 4, N = 7, R0 = 3. There are T0 = 7 of CMOs in Table3.16:
Y1 = ∅, Y2 = {y1, y2}, Y3 = {y3}, Y4 = {y1, y4}, Y5 = {y4, y5}, Y6 = {y6},
Y7 = {y5, y7}. So, there are executed three steps of the design.
Let us ﬁnd the set I. The CMO Y1 determines only the state a1. The CMO Y2
determines the states a2 and a4. The CMO Y3 determines the states a2, a3, a4. The
CMO Y5 determines the state a5. The CMO Y6 determines the state a3. The CMO
Y7 determines the state a6. Analysis of these connections gives K = 3. So, there is
the set I = {I1, I2, I3}.

82
3
Object Codes Transformation for Mealy FSMs
Table 3.17 Table of BIMF for PY3 Mealy FSM S2
Yt
Ik
K(Ik)
as
K(as)
Φh
h
∅
–
–
a1
000
–
1
y1y2
I1
00
a2
001
D3
2
y1y2
I2
01
a4
011
D2D3
3
y3
I1
00
a2
001
D2D3
4
y3
I2
01
a3
010
D3
5
y3
I3
10
a4
011
D2
6
y1y4
I1
00
a3
010
D2D3
7
y1y4
I2
01
a5
100
D2
8
y4y5
–
–
a5
011
D1
9
y6
–
–
a3
100
D2
10
y5y7
–
–
a6
101
D1D3
11
There are the following formulae for states am ∈A:
a1 = ⟨∅, Y1⟩;
a2 = ⟨I1, Y2⟩∨⟨I1, Y3⟩;
a3 = ⟨I2, Y3⟩∨∅, Y6⟩;
a4 = ⟨I2, Y2⟩∨⟨I2, Y2⟩∨⟨I1, Y4⟩;
a5 = ⟨I2, Y4, ⟩∨⟨∅, Y5⟩;
a6 = ⟨∅, Y7⟩.
(3.22)
There is K = 3 in the discussed case. It gives RV = 2 and the set V = {v1, v2}.
Let us encode the identiﬁers Ik ∈I in the following way: K(I1) = 00, K(I2) = 01
and K(I3) = 10.
There are HBIMF rows in the table of BIMF determined by (3.12). In the discussed
case, there is HBIMF = 11. It follows from the system (3.22), for example. There
are the following columns in the table of BIMF: Yt, Ik, K(Ik), as, K(as), Φh, h. It is
Table3.17 in the discussed case.
It is possible to derive the system (3.5) from the table of BIMF. It is the following
system in the discussed case (after minimizing):
D1 = y1yy ¯v1v2 ∨y4y5 ∨y5y7;
D2 = y1y2 ¯v1v2 ∨y3 ∨y1y4 ¯v1 ¯v2 ∨y6;
D3 = y1y2 ∨y3 ¯v2 ∨y5y7.
(3.23)
There are the following columns in the table of BMO: am, K(am), Xh, Vh,
Yh, h. It is constructed on the base of ST and a system similar to the system (3.22).
It is Table3.18 in the discussed case.

3.3 Synthesis of FPGA-Based Mealy FSMs with Transformation of CMOs
83
Table 3.18 Table of BMO for PY3 Mealy FSM S2
am
K(am)
Xh
Vh
Yh
h
a1
000
x1
–
y1y2
1
¯x1
v2
y3
2
a2
001
x2
–
y1y2
3
¯x2x3
–
y1y4
4
¯x2 ¯x3
v2
y1y2
5
a3
010
x1
v1
y3
6
¯x1
v2
y1y4
7
a4
011
1
–
y4y5
8
a5
100
x2x3
–
y3
9
x2 ¯x3
–
y6
10
¯x2x4
–
y5y7
11
¯x2 ¯x4
–
–
12
a6
101
1
–
y6
13
This table is used for deriving the systems (1.3) and (3.1). For example, the
following equations can be found from Table3.18:
v1 = ¯T1T2 ¯T3x1;
v2 = ¯T1 ¯T2 ¯T3 ¯x1 ∨¯T1 ¯T2T3 ¯x1 ¯x3 ∨¯T1T2 ¯T3 ¯x1.
(3.24)
These equations can be minimized.
The table of BMO should be transformed into the table of LUTer1. The table of
LUTer1 corresponds to N + RV tables for circuits implementing functions vr ∈V
and yn ∈Y. The table of BIMF should be transformed into the table of EMBer1.
Both transformations are executed in the same way as it was done in the previous
cases.
Using the encoding of CMOs Yt ⊆Y leads to PYiY models of Mealy FSMs
(i = 1, 8). The possible models are shown in Table3.19.
This table is based on Fig.3.4b. There are the following steps in the design methods
for PYiY Mealy FSMs (i = 1, 8):
1. Marking the initial GSA Γ and creating the set A.
2. Constructing the structure table of P Mealy FSM.
Table 3.19 Structural diagrams of PYiY Mealy FSMs
Blocks
PY1Y
PY2Y
PY3Y
PY4Y
PY5Y
PY6Y
PY7Y
PY8Y
BMOY
L1
L1
L1
L1
B1
B1
B1
B1
BIMF
L2
L2
B2
B2
L2
L2
B2
B2
BMO
L3
B3
L3
B3
L3
B3
L3
B3

84
3
Object Codes Transformation for Mealy FSMs
Fig. 3.11 Structural diagram of PY7Y Mealy FSM
3. Finding the collections of microoperations Yt ⊆Y.
4. Constructing the set of identiﬁers I = {I1, . . . , IK}.
5. Executing the encoding of CMOs Yt ⊆Y.
6. Representing the states am ∈A by pairs ⟨IK, Yt⟩.
7. Constructing the transformed ST of PY Mealy FSM.
8. Constructing the table of BIMF.
9. Constructing the table of BMOY.
10. Constructing the table of BMO.
11. Transformation of tables for implementing LUTers and EMBers.
12. Implementing the FSM logic circuit.
Let us discuss an example of design for PY7Y Mealy FSM S2 (Table3.16). The
corresponding structural diagram is shown in Fig.3.11.
In PY7Y FSM, the EMBer1 implements the systems (2.30) and (3.1), the EMBer2
the system (3.5), and the LUTer3 the system (1.40).
We have executed the steps 1–4 and 6in the previous example. There is T0 = 7.
Using (1.32), we can ﬁnd the value RZ = 3 and the set Z = {z1, z2, z3}. Let us encode
the CMOs Yt ⊆Y in the trivial way: C(Y1) = 000,…,C(Y7) = 111.
The transformed ST is constructed on the base of an initial ST. To do it , it is
necessary to replace the CMOs by their symbols and to add the columns C(Yh) and
Zh. There are variables zr = 1 in the code C(Yh) in the row h of the transformed ST
(h = 1, H0). In the discussed case, it is Table3.20.
There are the following columns in the table of BIMF: C(Yt), K(Ik) (they deter-
mine the address of a cell), Am, K(am), Φh (it is the content of a cell), h. This table
is constructed in a way similar to the table of BIMF for PY3 FSM discussed before.
For PY7Y Mealy FSM S2, this table is represented by Table3.21.
Comparison shows that Tables3.17 and 3.21 are practically identical. To construct
Table3.21, it is necessary to replace the collections Yt ⊆Y by their codes.
The table of BIMF is used to derive the system (3.6). For example, the following
equation can be derived from Table3.21 (after minimization): D1 = T2T3v2 ∨T1 ¯T3.
To get it, we used the code 11 for K(Ik) and the law of expansion for codes 100 and
110 of C(Yt).

3.3 Synthesis of FPGA-Based Mealy FSMs with Transformation of CMOs
85
Table 3.20 Transformed ST of PY Mealy FSM S2
am
K(am)
as
K(as)
Xh
Yt
C(Yt)
Zh
Φh
h
a1
000
a2
001
x1
Y2
001
z3
D3
1
a3
010
¯x1
Y3
010
z2
D2
2
a2
001
a2
001
x2
Y2
001
z3
D3
3
a3
010
¯x2x3
Y4
011
z2z3
D2
4
a4
011
¯x2 ¯x3
Y2
001
z3
D2D3
5
a3
010
a4
011
x1
Y3
010
z2
D2D3
6
a5
100
¯x1
Y4
011
z2z3
D1
7
a4
011
a5
100
1
Y5
100
z1
D1
8
a5
100
a2
001
x2x3
Y3
010
z2
D3
9
a3
010
x2 ¯x3
Y6
101
z1z3
D2
10
a6
101
¯x2x4
Y7
110
z1z2
D1D3
11
a1
000
¯x2 ¯x4
Y1
000
–
–
11
a6
101
a3
010
1
Y6
101
z1z3
D2
12
Table 3.21 Table of BIMF for PY7Y Mealy FSM S2
C(Yt)
K(Ik)
am
K(am)
Φh
h
000
∗
a1
000
–
1
001
00
a2
001
D3
2
001
01
a4
011
D2D3
3
010
00
a2
001
D3
4
010
01
a3
010
D2
5
010
10
a4
011
D2D3
6
011
01
a3
010
D2
7
011
00
a5
100
D1
8
100
01
a5
100
D1
9
101
∗
a3
010
D2
10
110
∗
a6
101
D1D3
11
To construct the table of BMOY, it is necessary to eliminate the columns
as, K(as), Φh from the transformed ST of PY Mealy FSM. They are replaced by
the columns Ik, K(Ik) and Vh. For example, the state a2 (h=1 in Table3.20) is deter-
mined by the pair ⟨Y2, I1⟩(it follows, for example, from Table3.21). So, it should be
I1 in the column Ik, the code 00in the column K(Ik) and no variables in the column
Vh (h=1 in the table of BMO). Acting in the same way, we construct Table3.22.
Table of BIMF is used for constructing the systems (2.30) and (3.1). For example,
the following equations can be derived from Table3.22:

86
3
Object Codes Transformation for Mealy FSMs
Table 3.22 Table of BMOY for PY7Y Mealy FSM S2
am
K(am)
Xh
Yh
C(Yh)
Zh
Ik
K(Ik)
Vh
h
a1
000
x1
Y2
001
z3
I1
00
–
1
¯x1
Y3
010
z2
I2
01
v2
2
a2
001
x2
Y2
001
z3
I1
00
–
3
¯x2x3
Y4
011
z2z3
I1
00
–
4
¯x2 ¯x3
Y2
001
z3
I2
01
v2
5
a3
010
x1
Y3
010
z2
I3
10
v1
6
¯x1
Y4
011
z2z3
I2
01
v2
7
a4
011
1
Y5
100
z1
–
–
–
8
a5
100
x2x3
Y3
010
z2
I1
00
–
9
x2 ¯x3
Y6
101
z1z3
–
–
–
10
¯x2x4
Y7
110
z1z2
–
–
–
11
¯x2 ¯x4
Y1
000
–
–
–
–
12
a6
101
1
Y6
101
z1z3
–
–
–
13
Table 3.23 Table of LUTer3 for PY7Y Mealy FSM S2
C(Yt)
Y
t
C(Yt)
Y
t
z1z2z3
y1y2y3y4y5y6y7
z1z2z3
y1y2y3y4y5y6y7
000
0000000
1
100
0001100
5
001
1100000
2
101
0000010
6
010
0010000
3
110
0000101
7
011
1001000
4
111
0000000
8
z1 = ¯T1T2T3 ∨T1 ¯T2 ¯T3x2 ¯x3 ∨T1 ¯T2 ¯T3 ¯x2x4;
z2 = ¯T1 ¯T3 ¯x1 ∨¯T1T2 ¯T3 ∨¯T1 ¯T2T3 ¯x2x3 ∨T1 ¯T2 ¯T3(x2x3 ∨¯x2x3);
z3 = ¯T1 ¯T2 ¯T3x1 ∨¯T1 ¯T2T3 ∨¯T1T2 ¯T3 ¯x1 ∨T1 ¯T2 ¯T3x2 ¯x3 ∨T1 ¯T2T3;
v1 = T2 ¯T3x1;
v2 = ¯T1 ¯T3 ¯x1 ∨¯T1 ¯T2T3 ¯x2 ¯x3
(3.25)
Therearethefollowingcolumns inthetableof LUTer3:C(Yt), Y, t. It is Table3.23
in the discussed case.
This table determines N circuits implementing the functions yn ∈Y. These func-
tions are represented in the form (1.40). If the following condition takes place
S ≥RZ,
(3.26)
then there are exactly N of LUTs in the circuit of LUTer3.
There is no sense in using EMBs for implementing microoperations in the case
of encoding of ﬁelds of compatible microoperations. Because of it, the block BMO

3.3 Synthesis of FPGA-Based Mealy FSMs with Transformation of CMOs
87
Table 3.24 Structural diagrams of PYiD Mealy FSMs
Blocks
PY1D
PY2D
PY3D
PY4D
BMOD
L1
B1
L1
B1
BIMF
L2
L1
B1
B2
BMO
L3
L2
L2
L1
Fig. 3.12 Structural diagram of PY1D Mealy FSM
Fig.3.4c is implemented as LUTer. So, there are 4 different structures of FPGA-based
PYD Mealy FSMs (Table3.24).
For example, Fig.3.12 represents the structural diagram of PY1D Mealy FSM.
To develop design methods for PYiD FSMs (i = 1, 4), it is enough to modify the
design methods for PYiY FSMs (i = 1, 8). There are two differences. The point 5 is
the executing the encoding of ﬁelds of compatible microoperations. The point 5 is
the constructing the table of BMOD. We do not discuss these methods in that section.
3.4 Replacement of Logical Conditions in Mealy FSMs
with OCT
It is possible to use the RLC for optimizing any model of Mealy FSM with OCT. It
results in adding the BRLC as it is shown, for example, in Fig.3.5. It has sense to
implement the block BRLC as LUTer.
Letus,forexample,discussthedesignmethodsforMPY7Y MealyFSM(Fig.3.13).
In MPY7Y Mealy FSM, the LUTer1 executes the RLC. It implements the system
(1.47). The EMBer1 implements the system (3.4) and the system
Z = Z(T, P).
(3.27)
The EMBer2 implements the system (3.6). The LUTer3 implements the system
(1.40).
There are the following steps in the design method for MPY7P Mealy FSM:

88
3
Object Codes Transformation for Mealy FSMs
Fig. 3.13 Structural diagram of MPY7Y Mealy FSM
1. Marking the initial GSA Γ and creating the set A.
2. Constructing the ST of Mealy FSM.
3. Finding the collections of microoperations Yt ⊆Y.
4. Constructing the set of identiﬁers I.
5. Executing the maximal encoding of CMOs Yt ⊆Y.
6. Representing the states am ∈A by pairs ⟨Ik, Yt⟩.
7. Executing the replacement of logical conditions.
8. Constructing transformed ST of MPY Mealy FSM.
9. Constructing the table of BIMF.
10. Constructing the table of BMOY.
11. Constructing the table of BMO.
12. Transformation the tables for representing the LUTers and EMBers.
13. Implementing the FSM logic circuit.
We already have executed the points 1–6 of this method for PY7Y Mealy FSM S2.
Let us continue this example for the MPY7Y Mealy FSM S2.
There are the following sets X(am) in Table3.16: X(a1) = {x1}, X(a2) =
{x2, x3}, X(a3) = {x1}, X(a4) = X(a6) = ∅, X(a5) = {x2, x3, x4}. It gives G = 3
and P = {p1, p2, p3}. Let us replace the logical conditions in the following manner
(Table3.25).
Table 3.25 Table of RLC for MP Mealy FSM S2
am
a1
a2
a3
a4
a5
a6
p1
x1
x2
x1
–
x2
–
p2
–
x3
–
–
x3
–
p3
–
–
–
–
x4
–

3.4 Replacement of Logical Conditions in Mealy FSMs with OCT
89
Table 3.26 Transformed ST of MPY Mealy FSM S2
am
K(am)
as
K(as)
Ph
Yt
C(Yt)
Zh
Φh
h
a1
000
a2
001
p1
Y2
001
z3
D3
1
a3
010
¯p1
Y3
010
z2
D2
2
a2
001
a2
001
p1
Y2
001
z3
D3
3
a3
010
¯p2x3
Y4
011
z2z3
D2
4
a4
011
¯p2 ¯x3
Y2
001
z3
D2D3
5
a3
010
a4
011
p1
Y3
010
z2
D2D3
6
a5
100
¯p1
Y4
011
z2z3
D1
7
a4
011
a5
100
1
Y5
100
z1
D1
8
a5
100
a2
001
p1x3
Y3
010
z2
D3
9
a3
010
p1 ¯x3
Y6
101
z1z3
D2
10
a6
101
¯p1x4
Y7
110
z1z2
D1D3
11
a1
000
¯p1 ¯x4
Y1
000
–
–
11
a6
101
a3
010
1
Y6
101
z1z3
D2
12
There are the following functions (1.47) derived from Table3.25:
p1 = ¯T1 ¯T3x1 ∨¯T1 ¯T2T3x2 ∨T1 ¯T2 ¯T3x2;
p2 = x3;
p3 = x4.
(3.28)
Analysis of (3.28) shows that it is necessary only to implement a circuit for the
function p1.
The transformed ST is represented by Table3.26 in the case of MPY Mealy FSM
S2. It is similar to Table3.20, but the column Xh is replaced by column Ph. We do
not replace the conditions x3, x4 ∈X.
There are the same columns in tables of BIMF for PY7Y and MPY7Y Mealy FSM
S2. The same is true for the table of BMO. In the discussed case, it is the same as
Table3.22.
ThetableofBMOYisconstructedinthesamewayasTable3.22.Butitisnecessary
to replace the column Xh by the column Ph. It gives Table3.27.
This table is used for constructing the functions (3.4) and (3.27). For example,
the following functions can be derived from Table3.27:
z1 = T2T3 ∨T1 ¯T2 ¯T3(p1 ¯x3 ∨T1x4) ∨T1T3;
v1 = T2 ¯T3P1.
(3.29)
Acting in the same manner, it is possible to develop design methods for all pro-
posed models of Mealy FSMs with OCT and RLC. We leave this task to a reader.

90
3
Object Codes Transformation for Mealy FSMs
Table 3.27 Table of BMOY for MPY7Y Mealy FSM S2
am
K(am)
Ph
Yh
C(Yh)
Zh
Ik
K(Ik)
Vh
h
a1
000
p1
Y2
001
z3
I1
00
–
1
¯p1
Y3
010
z2
I2
01
v2
2
a2
001
p2
Y2
001
z3
I1
00
–
3
¯p2x3
Y4
011
z2z3
I1
00
–
4
¯p2 ¯x3
Y2
001
z3
I2
01
v2
5
a3
010
p1
Y3
010
z2
I3
10
v1
6
¯p1
Y4
011
z2z3
I2
01
v2
7
a4
011
1
Y5
100
z1
–
–
–
8
a5
100
p1x3
Y3
010
z2
I1
00
–
9
p1 ¯x3
Y6
101
z1z3
–
–
–
10
¯p1x4
Y7
110
z1z2
–
–
–
11
¯p1 ¯x4
Y1
000
–
–
–
–
12
a6
101
1
Y6
101
z1z3
–
–
–
13
3.5 Analysis of Proposed Methods
Using the OCT leads to increasing for the number of functions which can be imple-
mented by EMBs. Let us ﬁnd conditions allowing the application of EMBs. Modern
EMBs have a lot of possible conﬁgurations corresponding to the following expres-
sion:
V · tF = V0.
(3.30)
In (3.30), V0 is a number of memory cells for tF = 1.
Let us start from PA Mealy FSM (Table3.1). It is possible to use EMBs till the
following conditions take places:
2L+R0 ≤V0;
(3.31)
2R0+RV ≤V0.
(3.32)
If the condition (3.31) takes place, then the block BIMF can be implemented as
EMBer. If the condition (3.32) takes place, then the BMO can be implemented as
EMBer.
In the best case, each block is implemented as a single EMB. The best case is
determined for BIMF by the condition(3.33) and for BMO by (3.34):
2L+R0(R0 + RV) ≤V0;
(3.33)
2R0+RV · N ≤V0.
(3.34)

3.5 Analysis of Proposed Methods
91
If the condition (3.31) takes place and the condition (3.33) is violated, then it is
necessary n(BIMF, PA) of blocks for implementing the circuit of BIMF:
n(BIMF, PA) =
R0 + RV
tF

.
(3.35)
If the condition (3.32) takes place and the condition (3.34) is violated, then it is
necessary n(BMO, PA) of blocks for implementing the circuit of BMO for PA Mealy
FSM:
n(BMO, PA) =
 N
tF

.
(3.36)
In the case of PAY Mealy FSM, the corresponding conditions for BIMF are deter-
mined by (3.31), (3.33) and (3.35). To use EMBs for implementing the circuit of
BCTY (Fig.3.2a), it is necessary to satisfy the following condition:
2RV +R0 · RZ ≤V0;
(3.37)
If this condition is violated, but the condition (3.32) takes place, then it is necessary
n(BCTY, PAY) of blocks for implementing the circuit of BCTY:
n(BCTY, PAY) =
RZ
tF

.
(3.38)
EMBs can be used for implementing the circuit of BMOY, if the following con-
dition takes place:
2RZ ≤V0.
(3.39)
In this case, the number of EMBs is determined by the following equation:
n(BMOY, PAY) =
 N
tF

.
(3.40)
As we can see, expressions (3.36) and (3.40) are the same. It is true for the block
BMOD (Fig.3.2b).
If the model of PAD Mealy FSM is used, then there are RD elements in the set Z:
RD =
K

k=1
Rk.
(3.41)
In (3.41), the symbol K stands for the number of classes of compatible MOs. The
symbol Rk stands for the number of bits in the codes for a ﬁeld k(k = 1, K). It is
determined as (1.35).

92
3
Object Codes Transformation for Mealy FSMs
As a rule, the following relation is true:
RD > RZ.
(3.42)
Because of it, it is better to implement the BMOD as a LUTer.
It is possible to use EMBs in the BCTD of PAD Mealy FSM, if the following
condition takes place:
2R0+RV · RD ≤V0.
(3.43)
The number of EMBs in the circuit of BCTD is determined as
n(BCTD, PAY) =
RD
tF

.
(3.44)
Using the RLC leads to adding the BRLC in the structures of PA Mealy FSMs.
This block is implemented as LUTer. In this case, there is a change in conditions for
the BIMF. For example, there are new conditions (3.45) and (3.46) corresponding to
the conditions (3.31) and (3.33), representing as
2G+R0 ≤V0;
(3.45)
2G+R0(R0 + RV) ≤V0.
(3.46)
EMBs can be used for implementing the circuit of BMO for PY Mealy FSM
(Fig.3.4a). The condition (3.31) shows that EMBs can be used for implementing the
BMO. The following condition shows that the circuit of BMO is implemented as a
single EMB:
2L+R0(RV + N) ≤V0.
(3.47)
If the condition (3.31) is true and the condition (3.47) is violated, then it is necessary
n(BMO, PY) of blocks in the BMO:
n(BMO, PY) =
RV + N
tF

.
(3.48)
It is possible to use EMBs in the circuit of BIMF of PY FSM, if the following
condition takes place:
2RV +N ≤V0.
(3.49)

3.5 Analysis of Proposed Methods
93
In this case, the number of EMBs is determined as
n(BIMF, PY) =
R0
tF

.
(3.50)
EMBs can be used in the BMOY (Fig.3.4b), if the condition (3.31) takes place.
It is enough to use a single EMB, if the following condition takes place:
2L+R0(RV + RZ) ≤V0.
(3.51)
If this condition is violated, then it is necessary n(BMOY, PYY) blocks:
n(BMOY, PYY) =
RV + RZ
tF

.
(3.52)
The condition (3.35) determines the using of EMBs in the circuit of BMO for
PYY FSM. The expression (3.40) can be used for ﬁnding the number of blocks in
BMO.
EMBs can be used for implementing the BIMF of PYY FSM, if the following
condition takes place:
2RZ+RV ≤V0.
(3.53)
The expression (3.50) can be used to ﬁnd the number of EMBs in this circuit.
Acting in the same way, it is possible to ﬁnd the conditions for using EMBs in
the circuits of BMOD, BMO and BIMF of PYD Mealy FSMs, respectively:
2R0+L · (RD + RV) ≤V0;
(3.54)
2RD · N ≤V0;
(3.55)
2RD+RV · R0 ≤V0.
(3.56)
If conditions (3.54)–(3.56) take places, then each block of PYD Mealy FSM is imple-
mented as a single EMB. If the conditions are violated, then numbers of EMB can
be calculated as:
n(BMOD, PYD) =
RV + RD
tF

;
(3.57)
n(BMO, PYD) =
 N
tF

;
(3.58)
n(BIMF, PYD) =
R0
tF

.
(3.59)

94
3
Object Codes Transformation for Mealy FSMs
It is possible to use the RLC in all models of PY, PYY and PYD FSM. As it is
pointed before, the BRLC is implemented as a LUTer. It is change for conditions
determining the application of EMBs in BMO, BMOY and BMOD. Now, there are
the following conditions:
2G+R0 · (RV + N) ≤V0;
(3.60)
2G+R0 · (RV + RZ) ≤V0;
(3.61)
2G+R0 · (RV + RD) ≤V0.
(3.62)
If the conditions are violated, then the following formulae determine the number
of EMBs in the circuits of BMO, BMOY and BMOD respectively:
n(BMO, MPY) =
RV + N
tF

;
(3.63)
n(BMOY, MPYY) =
RV + RZ
tF

;
(3.64)
n(BMOD, MPYD) =
RV + RD
tF

.
(3.65)
It is very important to choose a model of FSM having, for example, minimal
amount of hardware. It is possible to make a preliminary choice of a model with
minimal amount of EMBs using the formulae (3.31)–(3.65).
Table 3.28 Characteristics of Mealy FSM with OCT
No
FSM
BRLC
BIMF
BCTA
BMOA
BMO
1
PA
–
V(T, X); Φ(T, X)
–
–
Y(V, T)
2
PAY
–
V(T, X); Φ(T, X)
Z(T, V)
Y(Z)
–
3
PAD
–
V(T, X); Φ(T, X)
Z(T, V)
Y(Z)
–
4
MPA
P(T, X)
V(T, P); Φ(T, P)
–
–
Y(V, T)
5
MPAY
P(T, X)
V(T, P); Φ(T, P)
Z(T, V)
Y(Z)
–
6
MPAD
P(T, X)
V(T, P); Φ(T, P)
Z(T, V)
Y(Z)
–
7
PY
–
Φ(V, Y)
–
–
–
8
PYY
–
Φ(V, Z)
–
Z(T, X); V(T, X)
–
9
PYD
–
Φ(V, Z)
–
Z(T, X); V(T, X)
–
10
MPY
P(T, X)
Φ(V, Y)
–
–
–
11
MPYY
P(T, X)
Φ(V, Z)
–
Z(P, X); V(P, X)
–
12
MPYD
P(T, X)
Φ(V, Z)
–
Z(P, X); V(P, X)
–

3.5 Analysis of Proposed Methods
95
There are 12 basic models of Mealy FSMs with OCT. They are represented by
Table3.28. We use the abbreviations BCTA and BMOA to show the blocks BCTY,
BCTD, BMOY and BMOD.
References
1. A. Barkalov, A. Barkalov Jr, Synthesis of Finite-State Machines with transformation of the
object’s codes. In Proceedings of the International Conference TCSET’2004 pp. 61–64, Lviv,
Ukraina, 2004. Lviv Polytechnic National University, Lviv, Publishing House of Lviv Polytech-
nic
2. A. Barkalov, A. Barkalov Jr, Design of Mealy Finite-State Machines with the transformation of
object codes. Int. J. Appl. Math. Comput. Sci. 15(1), 151–158 (2005)
3. A. Barkalov, L. Titarenko, Logic Synthesis for FSM-based Control Units, vol. 53. Lecture Notes
in Electrical Engineering (Springer, Berlin, 2009)
4. A. Barkalov, L. Titarenko, A. Barkalov Jr, Moore FSM synthesis with coding of compati-
ble microoperations ﬁelds. In Proceedings of IEEE East-West Design & Test Symposium—
EWDTS’07, pp. 644–646, Yerevan, Armenia, Kharkov, 2007. Kharkov National University of
Radioelectronics
5. A. Barkalov, L. Titarenko, A. Barkalov Jr, Structural decomposition as a tool for the optimization
of an FPGA-based implementation of a mealy FSM. Cybern. Syst. Anal. 48(2), 313–322 (2012)
6. A. Barkalov, A. We˛grzyn, A. Barkalov Jr, Synthesis of control units with transformation of
the codes of objects. In Proceedings of the IXth International Conference CADSM 2007 (The
Experience of Designing and Application of CAD Systems in Microelectronics), pp. 260–261,
Lviv - Polyana, Ukraine, 2007. Lviv Polytechnic National University, Lviv, Publishing House
of Lviv Polytechnic National University
7. E. McCluskey, Logic Design Principles (Prentice Hall, Englewood Cliffs, 1986)

Chapter 4
Object Codes Transformation for Moore
FSMs
4.1 Principle of OCT for Moore FSMs
There are the same basic principles for object transformation in the case of Mealy
and Moore FSMs. In both cases, it is necessary to ﬁnd one-to-one correspondences
A →Y (PA Moore FSM) or Y →A (PY Moore FSM). Let us start from PA Moore
FSMs.
Due to dependence (1.5), the P Moore FSM can be viewed as PA Moore FSM.
So, there are no additional blocks in PA Moore FSMs in comparison with P Moore
FSMs.
In the case of PAY Moore FSM, it is necessary to encode the collections Yt ⊆Y
by codes C(Yt) having RZ bits, where RZ is determined by (1.22). It leads to the
following structural diagram (Fig.4.1).
In PAY Moore FSM, the BIMF implements the functions (1.4), whereas BMOY
the functions (1.40). A block of state codes transformer (BSCT) executes transfor-
mation of state codes K(am) into codes of CMOs C(Yt). De facto, it implements the
principle of OCT based on the system
Z = Z(T).
(4.1)
It is possible to use the encoding of the ﬁelds of compatible MOs together with
the principle of OCT. It leads to PAD Moore FSM (Fig.4.2).
Two methods can be used for reducing hardware in BIMF [5]: the optimal state
assignment and the transformation of state codes K(am) in the codes of classes of
PES K(Bi). In the ﬁrst case, there is no change in structural diagrams. But it is quite
possible that some state variables are insigniﬁcant for functions Φ. Let us denote
the corresponding models as P0AY and P0AD. In these FSMs, the BIMF implements
functions
Φ = Φ(T′, X).
(4.2)
In (4.2), there is the relation T′ ⊆T.
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_4
97

98
4
Object Codes Transformation for Moore FSMs
Fig. 4.1 Structural diagram of PAY Moore FSM
Fig. 4.2 Structural diagram of PAD Moore FSM
Let us encode classes Bi ∈ΠA by binary codes K(Bi) having RA bits:
RA = ⌈log2I⌉.
(4.3)
Remind, that there is I = |ΠA|. Let us use variables τr ∈τ for encoding of the class
Bi ∈ΠA. Obviously, there is |τ| = RA. Let us ﬁnd the system
τ = τ(T).
(4.4)
The system (4.4) shows the correspondence among the codes K(am) and K(Bi). To
implement it, it is necessary to use the BSCT. Let us use the letter “E” to show using
of this principle in a Moore FSM. There are the structural diagrams of PEAY and
PEAD Moore FSMs shown in Fig.4.3.
In both cases, the BIMF implements the system
Φ = Φ(τ, X).
(4.5)
whereas the BSCT the systems (4.1) and (4.4).
It is possible to double the number of models adding the BRLC in the all discussed
models. There are four different models of Moore FSMs shown in Fig.4.4. In the
case of MPAY and MPAD models, the BRLC implements the system (1.47) and
the BIMF the system (1.49). In the case of MPEAY and MPEAD models, the BRLC
implements the system
P = P(τ, X).
(4.6)
The BIMF implements the system (4.5). We discuss all these methods a bit later. Of
course, there are models of MP0AY and MP0AD Moore FSMs.

4.1 Principle of OCT for Moore FSMs
99
(a)
(b)
Fig. 4.3 Structural diagrams of PEAY a and PEAD b Moore FSMs
(a)
(b)
(c)
(d)
Fig. 4.4 Structural diagrams of MPAY (a), MPAD (b), MPEAY (c) and MPEAD (d) Moore FSMs

100
4
Object Codes Transformation for Moore FSMs
It follows from Figs.4.1, 4.2, 4.3 and 4.4 that there are no identiﬁers in the PA
Mealy FSM and its modiﬁcations. It is connected with the following relation:
M1 ≥T0.
(4.7)
On the other hand, there is a need for identiﬁers for PY Moore FSMs. They are based
on the correspondence Y →A. In this case, the CMOs Yt ⊆Y are the primary
objects and the states am ∈A are the secondary objects.
Three structures of PY Moore FSMs are possible. It is PY FSM based on the unitary
encoding of MOs. In this case, they use N bits for representing N microoperations
[9]. We can name this approach “N-hot” encoding. There is the structural diagram
of PY Moore FSM shown in Fig.4.5.
In PY FSM, the BMO implements the system (1.5) and the BIMF the system (3.5).
A block of identiﬁers (BI) implements the system (3.1).
Let us encode the CMOs Yt ⊆Y by binary codes having RZ bits, where RZ
is determined by (1.32). This approach is a maximal encoding of collections of
micropoperations [4, 9]. Combining this approach with OCT leads to PYY Moore
FSM Fig.4.6.
In PYY FSM, the BMO implements the system of functions zr ∈Z used for the
maximal encoding of CMOs. It is represented as
Z = Z(T).
(4.8)
The BIMF implements the system (3.6), whereas the BI the system (3.1).
Using the principle of encoding of the ﬁelds of compatible microoperations [2,
17] together with OCT leads to PYD Moore FSM (Fig.4.7). In this model, the BMOD
Fig. 4.5 Structural diagram
of PY Moore FSM
Fig. 4.6 Structural diagram
of PYY Moore FSM

4.1 Principle of OCT for Moore FSMs
101
Fig. 4.7 Structural diagram
of PYD Moore FSM
implements RD of functions (4.8). Other blocks execute the same functions as it is
for PYY Moore FSM.
It is possible to reduce the hardware amount in the circuit of BI taking into account
the existence of PES [5, 9, 18]. There are two approaches based on PES, discussed
beforehand.
Using the optimal state encoding leads to three models of PY Moore FSMs,
namely, to P0Y, P0YY and P0YD models. They have the same structural diagrams as
their counterparts without the optimal state encoding. There is the only difference.
It is possible that functions V will be depended on some part of the set T:
V = V(T′, X).
(4.9)
Three models are based on the transformation of state codes into the codes of
classes of PES. They are the models PEY (Fig.4.8), PEYY (Fig.4.9) and PEYD
(Fig.4.10).
Fig. 4.8 Structural diagram of PEY Moore FSM
Fig. 4.9 Structural diagram of PEYY Moore FSM

102
4
Object Codes Transformation for Moore FSMs
Fig. 4.10 Structural diagram of PEYD Moore FSM
There are the same functions of BMO and BIMF as for their counterparts in
PY Moore FSM (Fig.4.5). The BSCT implements the system (4.4). It executes the
transformation of state codes K(am) into the class codes K(Bi). The BI implements
the system (4.10):
V = V(τ, X).
(4.10)
(a)
(b)
(c)
Fig. 4.11 Structural diagrams of MPYY (a), MP0YY b and MPEYY c Moore FSMs

4.1 Principle of OCT for Moore FSMs
103
The functions of different blocks can be obtained from analysis of Figs.4.6 and
4.8. There are the same functions of BMOY, BMO and BIMF of PEYY FSM as for
their counterparts from PYY FSM. There are the same functions of BSCT and BI as
for their counterparts from PYY Moore FSM.
In PEYD FSM, the BMOD implements the system Z = Z(T), the BMO the system
Y = Y(Z), the BIMF the system Φ = Φ(V, Z). These systems are represented in
the same way as for PYD Moore FSM. The BSCT implements the system τ = τ(T),
the BI implements the system V = V(τ, X). These functions are represented as in
the PEY Moore FSM.
It is possible further hardware reduction in the circuit of BI. It is based on using
the principle of replacement of logical conditions [3]. It is reduced to introduction
of the block BRLC into a structural diagram of any FSM. For example, there are
structural diagrams of MPYY, MP0YY, MPEYY Moore FSMs shown in Fig.4.11.
All these models differ in functions implemented by the blocks BRLC and BI.
There are functions (1.47) and (3.4) in the case of MPYY FSMs. There are functions
P = P(T′, X) and V = V(P, T′) in the case of MP0YY FSMs. There are functions
P = P(τ, X) and V = V(τ, P) in the case of MPEYY FSMs.
It is possible to generate all other models based on the RLC. We leave this task to
our reader. There are characteristics of possible models of FSMs shown in Table 4.1.
As follows from Table4.1, there are 18 different models of Moore FSM based on the
relation Y →A.
Table 4.1 Characteristics of Moore FSM with Y →A
No
FSM
BRLC
BI
BIMF
BMOA
BMO
BSCT
1
PY
–
V(T, X)
Φ(V, Y)
–
Y(T)
–
2
P0Y
–
V(T′, X)
Φ(V, Y)
–
Y(T)
–
3
PEY
–
V(τ, X)
Φ(V, Y)
–
Y(T)
τ(T)
4
PYY
–
V(T, X)
Φ(V, Y)
Z(T)
Y(Z)
–
5
P0YY
–
V(T′, X)
Φ(V, Z)
Z(T)
Y(Z)
–
6
PEYY
–
V(τ, X)
Φ(V, Z)
Z(T)
Y(Z)
τ(T)
7
PYD
–
V(T, X)
Φ(V, Z)
Z(T)
Y(Z)
–
8
P0YD
–
V(T′, X)
Φ(V, Z)
Z(T)
Y(Z)
–
9
PEYD
–
V(τ, X)
Φ(V, Z)
Z(T)
Y(Z)
τ(T)
10
MPY
P(T, X)
V(T, P)
Φ(V, Y)
–
Y(T)
–
11
MP0Y
P(T, X)
V(T′, P)
Φ(V, Y)
–
Y(T)
–
12
MPEY
P(τ, X)
V(τ, P)
Φ(V, Y)
–
Y(T)
τ(T)
13
MPYY
P(T, X)
V(T, P)
Φ(V, Z)
Z(T)
Y(Z)
–
14
MP0YY
P(T, X)
V(T′, P)
Φ(V, Z)
Z(T)
Y(Z)
–
15
MPEYY
P(τ, X)
V(τ, P)
Φ(V, Z)
Z(T)
Y(Z)
τ(T)
16
MPYD
P(T, X)
V(T, P)
Φ(V, Z)
Z(T)
Y(Z)
–
17
MP0YD
P(T, X)
V(T′, P)
Φ(V, Z)
Z(T)
Y(Z)
–
18
MPE0YD
P(τ, X)
V(τ, P)
Φ(V, Z)
Z(T)
Y(Z)
τ(T)

104
4
Object Codes Transformation for Moore FSMs
Table 4.2 Characteristics of Moore FSM with A →Y
No
FSM
BRLC
BIMF
BSCT
BMOA
1
PAY
–
Φ(T, X)
Z(T)
Y(Z)
2
P0AY
–
Φ(T, X)
Z(T)
Y(Z)
3
PEAY
–
Φ(τ, X)
Z(T); τ(T)
Y(Z)
4
PAD
–
Φ(T, X)
Z(T)
Y(Z)
5
P0AD
–
Φ(T, X)
Z(T)
Y(Z)
6
PEAD
–
Φ(τ, X)
Z(T); τ(T)
Y(Z)
7
MPAY
P(T, X)
Φ(T, P)
Z(T)
Y(Z)
8
MP0AY
P(T, X)
Φ(T, P)
Z(T)
Y(Z)
9
MPEAY
P(τ, X)
Φ(τ, P)
Z(T); τ(T)
Y(Z)
10
MPAD
P(T, X)
Φ(T, P)
Z(T)
Y(Z)
11
MP0AD
P(T, X)
Φ(T, P)
Z(T)
Y(Z)
12
MPEAD
P(τ, X)
Φ(τ, P)
Z(T); τ(T)
Y(Z)
It is possible to create the table with different structures of Moore FSMs based on
the relation A →Y. It is Table4.2. As follows from Table4.2, there are 12 different
models of Moore FSM based on the transformation of states codes into collections of
microoperations. In both tables, we used the abbreviation BMOA to determine either
BMOY or BMOD. As follows from Tables4.1 and 4.2, there are 30 different models
of Moore FSMs with OCT. Now, let us discuss how to implement these models using
FPGAs.
4.2 Synthesis of FPGA-Based Moore FSMs
with Transformations of States
Let us start from PAY Moore FSM (Fig.4.1). It includes the following blocks: BIMF,
BSCT and BMOY. Using (3.20), the number nSD = 8 can be found. These possible
structures are shown in Table4.3.
Let us discuss the structural diagram of PA6Y Moore FSM Fig.4.12. In this FSM,
the EMBer1 implements the system Φ = Φ(T, X), the EMBer2 the system Z =
Table 4.3 Structural diagrams of PAiY Moore FSMs
Block
PA1Y
PA2Y
PA3Y
PA4Y
PA5Y
PA6Y
PA7Y
PA8Y
BIMF
L1
L1
L1
B1
L1
B1
B1
B1
BSCT
L2
L2
B1
L1
B2
B2
L1
B2
BMOY
L3
B1
L2
L2
B3
L3
B2
B3

4.2 Synthesis of FPGA-Based Moore FSMs with Transformations of States
105
Fig. 4.12 Structural diagram of PA6Y Moore FSM
Z(T), and LUTer3 the system Y = Y(Z). We used synchronized EMBs in EMBer1,
so there is no register in the circuit shown in Fig.4.12.
There are the following steps in the design method for PA6Y Moore FSM:
1. Marking the initial GSA Γ and creating the set A.
2. Executing the state assignment.
3. Constructing the ST of P Moore FSM.
4. Executing the encoding of CMOs Yt ⊆Y.
5. Constructing the table of EMBer1.
6. Constructing the table of EMBer2.
7. Constructing the table of LUTer3.
8. Implementing the FSM logic circuit.
Let us discuss an example of design for Moore FSM PA6Y(Γ5), where the GSA
Γ5 is shown in Fig.4.13. The following sets can be found from this GSA: X =
{x1, . . . , x4}, Y = {y1, . . . , y7}, A = {a1, . . . , a9}. We use rules [1] for marking the
states. So, there is M=9. It gives R1 = 4 and two sets: T = {T1, . . . , T4} and Φ =
{D1, . . . , D4}. Let us encode the states in the trivial way: K(a1) = 0000, K(a2) =
0001, . . . , K(a9) = 1000. Now, it is possible to execute the point 3 of the method
(Table4.4). There is the column Y(am) showing the CMO generated in the state
am ∈A.
There are the following CMOs in the column Y(am) of Table 4.4: Y1 = ∅, Y2 =
{y1, y2}, Y3 = {y3}, Y4 = {y2, y4}, Y5 = {y3, y5}, Y6 = {y6, y7}, Y7 = {y3, y6}. So,
there is T0 = 7. It gives the value RZ = 3. Let us encode the collections Yt ⊆Y in
the following way (Fig.4.14).
This Karnaugh map can be used for deriving the equations of the system (1.40).
We discuss this step a bit later.
There are the following columns in the table of EMBer1: K(am), X (it is an address
of a cell), T (it is a content of the cell), q (it is a number of a cell). The number of
rows is determined by the following formula:
Q1(PA6Y) = 2R1+L.
(4.11)
It is necessary H(am) cells to represent the transitions from a state am ∈A. This
number is determined by (3.18).

106
4
Object Codes Transformation for Moore FSMs
Fig. 4.13 Initial GSA Γ5
For example, there are the following characteristics of EMBer1 for the discussed
example: Q1(PA6Y) = 256 and H(am) = 16. There is a part of the table of EMBer1
represented by Table4.5.
Table4.5 shows transitions from the state a1 ∈A. It is added the column h to show
the connection between the Tables4.4 and 4.5.
There are the following columns in the table of EMBer2: K(am) (it is an address
of a cell), Z (it is a content of the cell), m. It is constructed on the base of the column
Y(am) of the ST. In the discussed case, it is the Table4.6.
To ﬁll the column Z, we use the codes C(Yt) from Fig.4.14.
There are the following columns in the table of LUTer3: Z (it is an address of a
cell), Y (it is a content of the cell), t. In the discussed case, it is Table4.7.
This table is constructed on the base of the column Y(am) from Table4.4 and the
codes from Table4.14. It corresponds to N circuits for implementing the functions
Y(Z). These functions can be derived from Table4.14:

4.2 Synthesis of FPGA-Based Moore FSMs with Transformations of States
107
Table 4.4 Structure table of Moore FSM PA6Y(Γ5)
am
K(am)
as
K(as)
Xh
Φh
Y(am)
h
a1
0000
a2
0001
x1x2
D4
∅
1
a3
0010
x1 ¯x2
D3
2
a4
0011
¯x1x2
D3D4
3
a5
0100
¯x1 ¯x2
D2
4
a2
0001
a6
0101
1
D2D4
y1y2
5
a3
0010
a6
0101
1
D2D4
y3
6
a4
0011
a6
0101
1
D2D4
y2y4
7
a5
0100
a6
0101
1
D2D4
y3y5
8
a6
0101
a2
0001
x3x4
D4
y3y5
9
a7
0110
x3 ¯x4
D2D3
10
a8
0111
¯x3x4
D2D3D4
11
a9
1000
¯x3 ¯x4
D1
12
a7
0110
a1
0000
1
–
y6y7
13
a8
0111
a1
0000
1
–
y1y2
14
a9
1000
a1
0000
1
–
y3y6
15
Fig. 4.14 Codes of
collections of
microoperations for Moore
FSM PA6Y(Γ5)
y1 = Y2 = ¯z1 ¯z2 ¯z3;
y2 = Y2 ∨Y4 = ¯z2 ¯z3;
y3 = Y3 ∨Y5 ∨Y7 = z3;
y4 = Y4 = z1 ¯z2;
y5 = Y5 = ¯z1z2z3;
y6 = Y7 = z1z3;
y7 = Y6 = z1z2 ¯z3.
(4.12)
Now let us discuss P0AiY Moore FSMs (i = 1, 8). These models can be repre-
sented by the table similar to Table4.3. It is necessary to add the subscript “0” in the
names of models. Let us discuss an example of design for P0A6Y(Γ5) Moore FSM.
There are the following steps in the design method for P0A6Y Moore FSMs:
1. Marking the initial GSA Γ and creating the set A.
2. Constructing the partition ΠA = {B1, . . . , BI}.
3. Executing the optimal state encoding.
4. Constructing the transformed table of P0 Moore FSM.
5. Executing the encoding of CMOs Yt ⊆Y.
6. Constructing the table of EMBer1.

108
4
Object Codes Transformation for Moore FSMs
Table 4.5 Part of table of EMBer1 for Moore FSM PA6Y(Γ5)
K(am)
X
T
q
h
T1T2T3T4
x1x2x3x4
T1T2T3T4
0000
0000
0100
1
4
0000
0001
0100
2
4
0000
0010
0100
3
4
0000
0011
0100
4
4
0000
0100
0011
5
3
0000
0101
0011
6
3
0000
0110
0011
7
3
0000
0111
0011
8
3
0000
1000
0010
9
2
0000
1001
0010
10
2
0000
1010
0010
11
2
0000
1011
0010
12
2
0000
1100
0001
13
1
0000
1101
0001
14
1
0000
1110
0001
15
1
0000
1111
0001
16
1
Table 4.6 Table of EMBer2 for Moore FSM PA6Y(Γ5)
K(am)
Z
m
K(am)
Z
m
T1T2T3T4
z1z2z3
T1T2T3T4
z1z2z3
0000
010
1
1000
111
9
0001
000
2
1001
000
10
0010
001
3
1010
000
11
0011
100
4
1011
000
12
0100
011
5
1100
000
13
0101
011
6
1101
000
14
0110
110
7
1110
000
15
0111
000
8
1111
000
16
7. Constructing the table of EMBer2.
8. Constructing the table of LUTer3.
9. Implementing the FSM logic circuit.
There is the following set ΠA = {B1, . . . , B4} in the discussed case with B1 =
{a1}, B2 = {a2, . . . , a5}, B3 = {a6}, B4 = {a7, a8, a9}. The codes of states am ∈B4
can be treated as “don’t care”, because these states are connected only with the state
a1 (Fig.4.13). Let us encode the states in the way shown in Fig.4.15.

4.2 Synthesis of FPGA-Based Moore FSMs with Transformations of States
109
Table 4.7 Table of LUTer3 for Moore FSM PA6Y(Γ5)
Z
Y
t
Z
Y
t
z1z2z3
y1y2y3y4y5y6y7
z1z2z3
y1y2y3y4y5y6y7
000
1100000
2
100
0101000
4
001
0010000
3
101
0000000
∗
010
0000000
1
110
0000011
6
011
0010100
5
111
0101001
7
Fig. 4.15 State codes for
Moore FSM P0A6Y(Γ5)
There are the following class codes derived from the Karnaugh map (Fig.4.15):
K(B1) = ∗∗00, K(B2) = ∗∗∗1, K(B3) = ∗∗1∗. It gives the set T′ = {T3, T4}.
They use the system of generalised formulae of transitions (GFT) [9] to construct
the transformed ST of P0 Moore FSM. It is the following system in the discussed
case:
B1 →x1x2a2 ∨x1 ¯x2a3 ∨¯x1x2a4 ∨¯x1 ¯x2a5;
B2 →a6;
B3 →x3x4a2 ∨x3 ¯x4a7 ∨¯x3x4a8 ∨¯x3 ¯x4a9.
(4.13)
There are the following columns in the transformed ST: Bi, K(Bi), as, K(as),
Xh, Φh, h. It is constructed using the system of GFT. In the discussed case, it is
Table4.8 having H(P0A6Y(Γ5)) = 9 rows. Let us point out that this number is the
Table 4.8 Transformed ST of Moore FSM P0A6Y(Γ5)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
∗∗00
a2
0001
x1x2
D4
1
a3
0101
x1 ¯x2
D2D4
2
a4
1101
¯x1x2
D1D3D4
3
a5
1001
¯x1 ¯x2
D1D4
4
B2
∗∗∗1
a6
0010
1
D3
5
B3
∗∗1∗
a2
0001
x3x4
D4
6
a7
0110
x3 ¯x4
D2D3
7
a8
1110
¯x3x4
D1D2D3
8
a9
1010
¯x3 ¯x4
D1D3
9

110
4
Object Codes Transformation for Moore FSMs
same as H0(Γ5). The number of transitions are determined by the number of terms
in the system (4.13). Comparison of Tables4.4 and 4.8 shows that there is 60% of
compression for the transformed ST (9 rows instead of 15).
This table is used for deriving the system (4.2). Let us use the symbol RT for the
following relation:
RT = |T′|.
(4.14)
Let us point out that there is the following relation:
RT ≥R0.
(4.15)
In the discussed case, there is R0 = 2 and, therefore, RT = R0. It is the best possible
outcome of the optimal state assignment.
After minimizing, the following system can be derived from Tabel 4.8:
D1 = ¯T3 ¯T4 ¯x1 ∨T3 ¯x3;
D2 = ¯T3 ¯T4x1 ¯x2 ∨T3x3 ¯x4 ∨T3 ¯x3x4;
D3 = ¯T3 ¯T4 ¯x1x2 ∨T4 ∨T3x3 ¯x4 ∨T3 ¯x3;
D4 = ¯T3 ¯T4 ∨T3x3x4.
(4.16)
This system is used in the case of using LUTer for implementing the circuit of BIMf.
The step 5 is already executed in the step 4 of the previous example. So, let us
use the codes from Fig.4.14.
There are the following columns in the table of EMBer1: K(Bi), X (it is an address
of a cell), T (it is a content of the cell), q, h (to show the correspondence between the
transformed ST and the table of EMBer1). The number of required cells is determined
as:
Q1(P0A6Y) = 2RT+L.
(4.17)
The expression (3.18) determines the number of cells used for representing the tran-
sitions for the class Bi ∈ΠA.
There is Q1(P0A6Y) = 64 and H(am) = 16. There are the transitions for the class
B1 represented by Table4.9.
The tables of EMBer2 and LUTer3 are constructed in the same way as their
counterparts for PA6Y Moore FSMs. So, these steps are omitted. Let us point out
that it should be used the codes from Fig.4.15 in the table of EMBer3. The tables of
LUTer3 are the same for PA6Y(Γ5) and P0A6Y(Γ5).
Let us discuss the FPGA-based implementation of PEAY Moore FSMs (Fig.4.3a).
Obviously, there are 8 different models of this FSM. They corresponds to the models
from Table4.3. So, there are the models PEAiY where i = 1, 8.
Let us discuss an example of design for Moore FSM PEA6Y(Γ5). Its design method
is similar to the one for P0A6Y FSM. There are the following differences: (1) it can
be the arbitrary state assignment in the point 3; (2) it should be executed the class
assignment before constructing the transformed ST.

4.2 Synthesis of FPGA-Based Moore FSMs with Transformations of States
111
Table 4.9 Part of table of EMBer1 for Moore FSM P0A6Y(Γ5)
K(Bi)
X
T
q
h
T3T4
x1x2x3x4
T1T2T3T4
00
0000
1001
1
4
00
0001
1001
2
4
00
0010
1001
3
4
00
0011
1001
4
4
00
0100
1011
5
3
00
0101
1011
6
3
00
0110
1011
7
3
00
0111
1011
8
3
00
1000
0101
9
2
00
1001
0101
10
2
00
1010
0101
11
2
00
1011
0101
12
2
00
1100
0001
13
1
00
1101
0001
14
1
00
1110
0001
15
1
00
1111
0001
16
1
So, let us leave the state codes from Table4.4 in the case of PEA6Y(Γ5). There are
the same classes Bi ∈ΠA for PEA6Y(Γ5): B1 = {a1}, B2 = {a2, . . . , a5}, B3 = {a6}
and B4 = {a7, a8, a9}. There are four classes of PES(I=4). It is necessary RA of
variables τr ∈τ for class encoding:
RA = ⌈log2I⌉.
(4.18)
In the discussed case, there is RA = 2. It determines the set τ = {τ1, τ2}.
Let us encode the classes Bi ∈ΠA in the following manner: K(B1) = 00, K(B2) =
01, K(B3) = 10 and K(B4) = 11. As in the previous case, the code K(B4) is treated
as “don’t care”.
They use a system of GFT for constructing the transformed ST of PEA6Y Moore
FSM. It is the system (4.13) in the discussed case. There are the same columns in
transformedSTsforP0A6Y andPEA6Y FSMs.Buttherearetheclasscodesdetermined
by variables τr ∈τ in the column K(Bi) for PEA6Y Moore FSM. It is Table4.10 in
the discussed case. We use the input assignment 11 to simplify the codes K(B2) and
K(B3). Now, they are equal to *1 and 1* respectively. Of course, it is important only
if LUTs are used for implementing the system (4.5).
They use the transformed ST to get the system (4.5). It is the following system in
the discussed case:

112
4
Object Codes Transformation for Moore FSMs
Table 4.10 Transformed ST of Moore FSM PEA6Y(Γ5)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
00
a2
0001
x1x2
D4
1
a3
0010
x1 ¯x2
D3
2
a4
0011
¯x1x2
D3D4
3
a5
0100
¯x1 ¯x2
D2
4
B2
∗1
a6
0101
1
D2D4
5
B3
1∗
a2
0001
x3x4
D4
6
a7
0010
x3 ¯x4
D2D3
7
a8
0111
¯x3x4
D2D3D4
8
a9
1000
¯x3 ¯x4
D1
9
D1 = τ1 ¯x3 ¯x4;
D2 = ¯τ1 ¯τ2 ¯x1 ¯x2 ∨τ2 ∨τ1x3 ¯x4 ∨τ1 ¯x3x4;
D3 = ¯τ1 ¯τ2x1 ¯x2 ∨¯τ1 ¯τ2 ¯x1x2 ∨τ1x3 ¯x4 ∨τ1 ¯x3x4;
D4 = ¯τ1 ¯τ2x2 ∨τ2 ∨τ1x4.
(4.19)
There are the same columns in the tables of EMBer1 for P0A6Y and PEA6Y Moore
FSMs. There are Q1(PEA6Y) cells in the EMBer1:
Q1(PEA6Y) = 2RA+L.
(4.20)
As in all cases, they use the formula (3.18) to ﬁnd the number of cells representing the
transitions from the state am ∈A. There are Q1(PEA6Y(Γ5)) = 64 and H(am) = 16
in the discussed case.
We hope that there is no need in constructing all tables in the discussed case.
Moreover, the tables of EMBer2 and LUTer3 are the same for both PA6Y(Γ5) and
PEA6Y(Γ5) FSMs. We discuss the models based on the RLC in Sect.4.4.
4.3 Synthesis of FPGA-Based Moore FSMs
with Transformation of CMOs
Let us discuss the design methods based on using the encoding of the ﬁelds of
compatible microoperations (FCO). There are many approaches devoted to solution
of this problem [2, 10, 12–17]. There are the following sets Yk in the case of GSA
Γ5 : Y1 = {y1, y3, y4}, Y2 = {y2, y5, y6} and Y3 = {y7}. So, there are R1 = R2 = 2
and R3 = 1 (See (1.35)). It determines the set Z = {z1, . . . , z5}. The variables z1, z2
encode the ﬁeld Y1, the variables z3, z4 the ﬁeld Y2 and the variable z5 the ﬁeld Y3
(Table4.11).

4.3 Synthesis of FPGA-Based Moore FSMs with Transformation of CMOs
113
Table 4.11 Codes of FCO for GSA Γ5
Y1
K(Yn)1
Y2
K(Yn)2
Y3
K(yn)3
z1z2
z3z4
z5
∅
00
∅
00
∅
0
y1
01
y2
01
y7
1
y3
10
y5
10
y5
11
y6
11
Let us start from PYD Moore FSM (Fig.4.7). The LUTs are used for implementing
the circuit of BMO. So, there are 8 different models of FPGA-based Moore FSMs
witch transformation of FCOs (Table4.12).
Design methods are practically the same for all these models. All methods include
the step of encoding of FCO. Let us discuss the design method for PY6D Moore FSM.
It includes the following steps:
1. Marking the initial GSA Γ and creating the set A.
2. Executing the state assignment.
3. Constructing the ST of P Moore FSM.
4. Executing the encoding of FCO.
5. Constructing the set of identiﬁers I = {I1, . . . , IK}.
6. Representing the states am ∈A by the pairs ⟨Ik, Yt⟩.
7. Executing the encoding of identiﬁers Ik ∈I.
8. Constructing the table of EMBer1.
9. Constructing the table of EMBer2.
10. Constructing the table of LUTer3.
11. Constructing the system of equations for BMO.
12. Implementing the FSM logic circuit.
There is the structural diagram of PY6D Moore FSM shown in Fig.4.16. The
LUTer represents the BMO.
Let us discuss an example for design of Moore FSM PY6D(Γ5). There are already
executed the steps 1–4 for the given example. There is the structure table of Moore
FSM P(Γ5) represented by Table4.4. There are the codes of FCO shown in in
Table4.11.
Table 4.12 Structural diagram of PYiD FSMs
Block
PY1D
PY2D
PY3D
PY4D
PY5D
PY6D
PY7D
PY8D
BIMF
L1
L1
L1
B1
L1
B1
B1
B1
BMOD
L2
L2
B1
L1
B2
B2
L1
B2
BI
L3
B1
L2
L2
B3
L3
B2
B3

114
4
Object Codes Transformation for Moore FSMs
Fig. 4.16 Structural diagram of PY6D Moore FSM
Let us ﬁnd the sets A(Yt) in the discussed case. It can be done on the base of
Table4.4. There are the following sets: A(y1) = {a1}, A(y2) = {a2, a8}, A(y3) =
{a3}, A(y4) = {a4}, A(y5) = {a5, a6}, A(y6) = {a7}, A(y7) = {a9}. It gives K = 2
and I = {I1, I2}.
Let us represent the states am ∈A by the pairs ⟨Ik, Yt⟩. Using Table 4.4, the
following formulae can be obtained:
a1 = ⟨∅, y1⟩;
a2 = ⟨I1, y2⟩;
a3 = ⟨∅, y3⟩;
a4 = ⟨∅, y4⟩;
a5 = ⟨I1, y5⟩;
a6 = ⟨I2, y5⟩;
a7 = ⟨∅, y6⟩;
a8 = ⟨I2, y2⟩;
a9 = ⟨∅, y7⟩;
(4.21)
Using (3.7), we can get RV = 1. It gives the set V = {v1}. Let us encode the identiﬁers
in the following way: K(I1) = 0, K(I2) = 1.
The table of EMBer1 (table of BIMF) is constructed from the ST and the system of
pairs ⟨Ik, Yt⟩. There are the following columns in the table of EMBer1: Z, V, T, q, m.
The ﬁrst two columns are determined by the column T. The column m is added to
show the correspondence between the rows of the table and states am ∈A. This table
includes Q1(PY6D) lines:
Q1(PY6D) = 2RD+RV .
(4.22)
In the discussed case, there is Q1(PY6D(Γ5)) = 64.
Table4.13 contains only 9 rows corresponding to the states am ∈A. There are the
decimal equivalents of corresponding addresses in the column q.

4.3 Synthesis of FPGA-Based Moore FSMs with Transformation of CMOs
115
Table 4.13 Part of table of EMBer1 for Moore FSM PY6D(Γ5)
Z
V
T
q
m
z1z2z3z4z5
v1
T1T2T3T4
00000
∗
0000
1
1
01010
0
0001
21
2
10000
∗
0010
33
3
11010
∗
0011
53
4
10100
0
0100
41
5
10100
1
0101
42
6
00111
∗
0110
15
7
01010
1
0111
22
8
10110
∗
1000
45
9
To ﬁnd the code C(Yt), the following formula is used:
C(Yt) = K(yn)1
t ∗K(yn)2
t ∗· · · ∗K(yn)K
t .
(4.23)
The symbol K(yn)k
t stands for the code of MO yn ∈Yt used in the k-th ﬁeld of C(Yt).
For example, let us analyse the CMO Y2 = {y1, y2}.Using Table4.11, it can be found
that C(Y2) = 01010.
It is necessary H(Yt) rows to represent the pair ⟨Ik, Yt⟩where
H(Yt) = 2RV .
(4.24)
So, each symbol “*” in Table4.13 determines 2 cells of an EMB. We show the
decimal equivalent of the ﬁrst cell’s address in the column q of Table4.13. Let us
point out that these equivalents are incremented starting from 1.
TherearethefollowingcolumnsinthetableofEMBer2(tableofBMOD):T, Z, m.
It is Table4.14 in the discussed case.
Table 4.14 Table of EMBer2 for Moore FSM PY6D(Γ5)
T
Z
m
T
Z
m
T1T2T3T4
z1z2z3z4z5
T1T2T3T4
z1z2z3z4z5
0000
00000
1
0101
10100
6
0001
01010
2
0110
00111
7
0010
10000
3
0111
01010
8
0011
11010
4
1000
10110
9
0100
10100
5
1001
00000
10

116
4
Object Codes Transformation for Moore FSMs
We do not show the rows 11–16 because there are no state codes starting from
1001. These rows contain only zeros in the column Z.
There are the following columns in the table of LUTer3 (table of BI): T, X, V, q.
It is necessary to ﬁnd the Eq.(3.2) to construct this table. Let us form the transformed
ST of Moore FSM PA6D(Γ5) (Table4.15).
This table is constructed on the base of Table4.4 and system (4.20). For example,
there is the state as = a2 in the ﬁrst row of Table4.4. It is determined as ⟨I1, Y2⟩.
There is 0in the columns Vh of the ﬁrst row.
There is as = a6 in the row 5 of Table4.4. There is a6 = ⟨I2, Y5⟩. So, there is 1in
the column Vh for the row 5.If there is the pair ⟨∅, Yt⟩, then we sign it as “∗” in the
column Vh.
To optimize the function v1 = v1(T, X), it is possible to use the “don’t care” state
codes (1001–1111) and the term AmXh where there is Vh = ∗. After minimizing, the
following equation can be obtained from Table4.15:
v1 = T2x3 ∨T3 ∨T4.
(4.25)
So, there are the variables T2, T3, T4 in the column T and the variable x3 in the
column X of the table of LUTer3. It is Table4.16.
The rows 10, 12, 14, 16 correspond to the term T2x3 of (4.25); the rows 5–8 and
13–16 to T3; the rows 3, 4, 7, 8, 11, 12, 15, 16 to T4.
Table 4.15 Transformed ST for Moore FSM PY6D(Γ5)
am
K(am)
Xh
Vh
h
a1
0000
x1x2
0
1
x1 ¯x2
∗
2
¯x1x2
∗
3
¯x1 ¯x2
0
4
a2
0001
1
1
5
a3
0010
1
1
6
a4
0011
1
1
7
a5
0100
1
1
8
a6
0101
x3x4
0
9
x3 ¯x4
∗
10
¯x3x4
1
11
¯x3 ¯x4
∗
12
a7
0110
1
∗
13
a8
0111
1
∗
14
a9
1000
1
∗
15

4.3 Synthesis of FPGA-Based Moore FSMs with Transformation of CMOs
117
Table 4.16 Table of LUTer3 for Moore FSM PY6D(Γ5)
T
X
v1
q
T
X
v1
q
T2T3T4
x3
T2T3T4
x3
000
0
0
1
100
0
0
9
000
1
0
2
100
1
1
10
001
0
1
3
101
0
1
11
001
1
1
4
101
1
1
12
010
0
1
5
110
0
1
13
010
1
1
6
110
1
1
14
011
0
1
7
111
0
1
15
011
1
1
8
111
1
1
16
To form the table of LUTer (table of BMO), it is necessary to construct the system
Y(Z). In the discussed example, it can be found from Table4.11:
y1 = ¯z1z2;
y2 = ¯z3z4;
y3 = z1 ¯z2;
y4 = z1z2;
y5 = z3 ¯z4;
y6 = z3z4;
y7 = z5.
(4.26)
To implement these equations, it is enough 6 of LUTs having S = 2. The corre-
sponding tables of LUTs can be found either from Table4.11 or from the system
(4.26).
Let us discuss the models of P0YiD Moore FSMs (i = 1, 8). These models are
the same as the ones shown in Table4.12. But they are based on the optimal state
assignment [5]. Let us discuss the P0Y4D Moore FSM (Fig.4.17).
Fig. 4.17 Structural diagram of P0Y4D Moore FSM

118
4
Object Codes Transformation for Moore FSMs
In this FSM model, the LUTer1 corresponds to BMOD. It implements the system
Z = Z(T). The LUTer2 corresponds to BI and implements the system V = V(T′, X).
Both EMBer1 and LUTer execute the same functions as their counterparts in PY6D
FSM (Fig.4.16).
To design the circuit of P0Y4D Moore FSM, it is necessary to change the point 2
and add some new steps in the design method discussed for the PY6D FSM. Now,
step 2 is “executing the optimal state assignment”. It is necessary to add the following
steps:
1a. Constructing the partition ΠA = {B1, . . . , BI}.
7a. Constructing the transformed ST of P0 Moore FSM.
Let us discuss an example of design for Moore FSM P0Y4D(Γ5). There is the GSA
Γ5 shown in Fig.4.13. The states am ∈A are encoded in the optimal way shown in
the Karnaugh map (Fig.4.15). Using the system (4.13) the transformed ST of Moore
FSM is constructed. There are the codes of FCO for the discussed case shown in
Table4.11.
There are the following columns in the table of LUTer1: T, Z, m. It is similar to
Table4.14, but there are the state codes from Fig.4.15. In the discussed case, the
LUTer1 is represented by Table4.17.
There is a sign “∗” in the column m if there is no state code as the one shown in
the corresponding row of the column Z. This table determines RD = 5 of tables for
LUTer implementing the functions zr ∈Z. These LUTs implement the following
functions:
z1 = T1 ¯T2 ∨T2 ¯T3;
z2 = T1T2 ∨¯T1 ¯T2T4 ∨¯T1T3;
z3 = T1 ¯T2 ∨¯T1T2 ¯T4;
z4 = ¯T1 ¯T2 ∨¯T2T3 ∨T1T2;
z5 = ¯T1T2 ¯T4.
(4.27)
Table 4.17 Table of LUTer1 for Moore FSM P0Y4D(Γ5)
T
Z
m
T
Z
m
T1T2T3T4
z1z2z3z4z5
T1T2T3T4
z1z2z3z4z5
0000
00000
1
1000
00000
∗
0001
01010
2
1001
10100
5
0010
01010
6
1010
10110
9
0011
00000
∗
1011
00000
∗
0100
00000
∗
1100
00000
∗
0101
10000
3
1101
11010
4
0110
01101
7
1110
01010
8
0111
00000
∗
1111
00000
∗

4.3 Synthesis of FPGA-Based Moore FSMs with Transformation of CMOs
119
Analysis of (4.27) shows that only a LUT for z2 requires 4 inputs. To implement
other functions Z(T), it is necessary to use LUTs having S = 3.
It is necessary to form the transformed ST of Moore FSM P0Y4D(Γ5) to ﬁnd the
function v1. It is Table4.18 which is similar to Table4.15. There is the following
equation for the function v1:
v1 = T4 ∨T3 ¯x3.
(4.28)
This equation determines Table4.19.
Comparison of Tables4.16 and 4.19 shows that using the optimal state assignment
results in the decreasing for the number of inputs in LUTs implementing the system
Z = Z(T′, X).
Tables of EMBer1 differ only in the columns T for equivalent Moore FSMs PYiD
and P0YiD. So, there are the codes from Fig.4.15 in the table of EMBer1 (Table4.20).
Tables of LUTer are the same for all equivalent P0YiD Moore FSMs. In the dis-
cussed case, the LUTer is represented by the system (4.26).
Table 4.18 Transformed ST for Moore FSM P0Y4D(Γ5)
Bi
K(Bi)
Xh
Vh
h
B1
∗∗00
x1x2
0
1
x1 ¯x2
∗
2
¯x1x2
∗
3
¯x1 ¯x2
0
4
B2
∗∗∗1
1
1
5
B3
∗∗1∗
x3x4
0
6
x3 ¯x4
∗
7
¯x3x4
1
8
¯x3 ¯x4
∗
9
Table 4.19 Table of LUTer2 for Moore FSM P0Y4D(Γ5)
T
X
v1
q
T
X
v1
q
T3T4
x3
T3T4
x3
00
0
0
1
10
0
1
5
00
1
0
2
10
1
0
6
01
0
1
3
11
0
1
7
01
1
1
4
11
1
1
8

120
4
Object Codes Transformation for Moore FSMs
Table 4.20 Part of table of EMBer1 for Moore FSM P0Y4D(Γ5)
Z
V
T
q
m
z1z2z3z4z5
v1
T1T2T3T4
00000
∗
0000
1
1
01010
0
0001
21
2
10000
∗
0101
33
3
11010
∗
1101
53
4
10100
0
1001
41
5
10100
1
0010
42
6
00111
∗
0110
15
7
01010
1
1110
22
8
10110
∗
1010
45
9
4.4 Replacement of Logical Conditions in Moore FSMs
with OCT
The method of RLC is an universal method. It can be used to improve the hardware
amount in any model of FSM. Let us discuss, for example, MPEYiD Moore FSMs.
They are based on the following model (Fig.4.18).
There is the same nature in the functions Z(T) and τ(T). So, it is possible to
combine the blocks BMOD and BSCT in a single block BMT. It gives the circuit
having 5 blocks and the RG. As in the previous cases, a LUTer is used to implement
the circuit of BMO. Therefore, there are 16 possible models of MPEYiD Moore FSMs
(Table4.21).
There are the following steps in design method for a MPEYiD Moore FSM:
1. Constructing the set of states A.
2. Executing the encoding of states am ∈A.
3. Constructing the ST of P Moore FSM.
4. Constructing the partition ΠA = {B1, . . . , BI}.
5. Executing the encoding of classes Bi ∈ΠA.
Fig. 4.18 Structural diagram of MPEYD Moore FSM

4.4 Replacement of Logical Conditions in Moore FSMs with OCT
121
Table 4.21 Structural diagrams of MPEYiD Moore FSMs
Block
BMT
BRLC
BI
BIMF
1
L1
L2
L3
L4
2
L1
L2
L3
B4
3
L1
L2
B3
L4
4
L1
L2
B3
B4
5
L1
B2
L3
L4
6
L1
B2
L3
B4
7
L1
B2
B3
L4
8
L1
B2
B3
B4
9
B1
L2
L3
L4
10
B1
L2
L3
B4
11
B1
L2
B3
L4
12
B1
L2
B3
B4
13
B1
B2
L3
L4
14
B1
B2
L3
B4
15
B1
B2
B3
L4
16
B1
B2
B3
B4
6. Executing the encoding of FCO.
7. Executing the replacement of logical conditions.
8. Constructing the transformed ST of MP Moore FSM.
9. Constructing the table of BMT.
10. Constructing the table of BRLC.
11. Constructing the table of BI.
12. Constructing the table of BIMF.
13. Constructing the tables of LUter2 and EMBers.
14. Implementing the FSM logic circuit.
Let us discuss an example of design for MPEY1D Moore FSM on the base of
the GSA Γ5 (Fig.4.13). Let us use the results obtained from previous examples for
the steps 1–6. So, there is the ST of P(Γ5) Moore FSM (Table4.4), there is the
transformed ST of PE(Γ5) Moore FSM (Table4.10), the codes of FCO are shown in
Table4.11.
Let the symbol X(Bi) stand for the set of logical conditions determining transitions
from states am ∈Bi. There are the following sets in the discussed case: X(B1) =
{x1, x2}, X(B2) = X(B4) = ∅, X(B3) = {x3, x4}. So, there is G = 2 and P =
{p1, p2}. Let us replace the logical conditions as it is shown in Table4.22.
It is possible to ﬁnd the equations of the system P = P(τ, X) from Table4.22:
p1 = B1x1 ∨B3x3;
p2 = B1x2 ∨B3x3.
(4.29)

122
4
Object Codes Transformation for Moore FSMs
Table 4.22 Table of RLC for MP(Γ5)
Bi
B1
B2
B3
B4
p1
x1
–
x3
–
p2
x2
–
x4
–
There are the following class codes: K(B1) = 00, K(B2) = 01, K(B3) = 10 and
K(B4) = 11. The codes of B2 and B4 are treated as “don’t care”. So, the following
system can be obtained on the base of (4.29):
p1 = ¯τ1x1 ∨τ1x3;
p2 = ¯τ1x2 ∨τ1x4.
(4.30)
They use Tables4.10 and 4.22 to construct the transformed ST of Moore FSM
MP(Γ5) (Table4.23).
This table is used to ﬁnd functions Φ = Φ(τ, P). There are the following mini-
mized functions derived from Table4.23:
D1 = τ1 ¯p1 ¯p2;
D2 = ¯τ1 ¯τ2 ¯p1 ¯p2 ∨τ2 ∨τ1p1 ¯p2 ∨τ1 ¯p1p2;
D3 = ¯τ1 ¯τ2p1 ¯p2 ∨¯τ1 ¯τ2 ¯p1p2 ∨τ1p1 ¯p2 ∨τ1 ¯p1p2;
D4 = ¯τ1 ¯τ2p2 ∨τ2 ∨τ1p2.
(4.31)
There are the following columns in the table of BMT: am, K(am), Bi, K(Bi),
τm, Yt, C(Yt), Zm, m. It is Table4.24 in the discussed example. We use here the codes
C(Yt) from Table4.13.
The table of BMT is used for deriving the functions τ = τ(T) and Z = Z(T). For
example, the following minimized functions can derived from Table4.24:
Table 4.23 Transformed ST of Moore FSM MP(Γ5)
Bi
K(Bi)
as
K(as)
Ph
Φh
h
B1
00
a2
0001
p1p2
D4
1
a3
0010
p1 ¯p2
D3
2
a4
0011
¯p1p2
D3D4
3
a5
0100
¯p1 ¯p2
D2
4
B2
∗1
a6
0101
1
D2D4
5
B3
1∗
a2
0001
p1p2
D4
6
a7
0010
p1 ¯p2
D2D3
7
a8
0111
¯p1p2
D2D3D4
8
a9
1000
¯p1 ¯p2
D1
9

4.4 Replacement of Logical Conditions in Moore FSMs with OCT
123
Table 4.24 Table of BMT for Moore FSM MPEY1D(Γ5)
am
K(am)
Bi
K(Bi)
τm
Yh
C(Yt)
Zm
m
a1
0000
B1
00
–
y1
00000
–
1
a2
0001
B2
01
τ2
y2
01010
z2z4
2
a3
0010
B2
01
τ2
y3
10000
z1
3
a4
0011
B2
01
τ2
y4
11010
z1z2z4
4
a5
0100
B2
01
τ2
y5
10100
z1z3
5
a6
0101
B3
10
τ1
y5
10100
z2z3
6
a7
0110
B4
11
τ1τ2
y6
00111
z3z4z5
7
a8
0111
B4
11
τ1τ2
y2
01010
z2z4
8
a9
1000
B4
11
τ1τ2
y7
10110
z1z3z4
9
τ1 = T1 ∨T2T4 ∨T2T3;
τ2 = T1 ∨T3 ∨¯T2T4;
z1 = T1 ∨T3 ∨¯T2T4;
z2 = T3T4 ∨¯T2T4;
z3 = T1 ∨T2 ¯T3 ∨T2 ¯T4;
z4 = T1 ∨¯T2T4 ∨T2T3;
z5 = T2T3 ¯T4.
(4.32)
To ﬁnd the functions V(τ, P), it is necessary to construct the table of BI. It is
similar to Table4.18 in the way of constructing. There are the following columns in
the table of BI for MPEY1D Moore FSM: Bi, K(Bi), Ph, Vh, h. In the discussed case,
it is Table4.25.
There is the following minimized equation derived from Table4.25:
v1 = τ2 ∨τ1 ¯p1.
(4.33)
Using the Eq.(4.33), the table of LUTer3 can be constructed (Table4.26).
Table 4.25 Table of BI for Moore FSM MPEY1D(Γ5)
Bi
K(Bi)
Ph
Vh
h
B1
00
p1p2
0
1
p1 ¯p2
∗
2
¯p1p2
∗
3
¯p1 ¯p2
0
4
B2
∗1
1
1
5
B3
1∗
p1p2
0
6
p1 ¯p2
∗
7
¯p1p2
1
8
¯p1 ¯p2
∗
9

124
4
Object Codes Transformation for Moore FSMs
Table 4.26 Table of LUTer3 for Moore FSM MPEY1D(Γ5)
τ
P
v1
q
τ
P
v1
q
τ1τ2
P1
τ1τ2
P1
00
0
0
1
10
0
0
5
01
1
0
2
10
1
1
6
10
0
1
3
11
0
1
7
11
1
1
4
11
1
1
8
The table of BIMF includes the following columns: Zh, Vh, Φh, h. It is Table4.27
in the discussed case.
This table is used to derive the system Φ(Z, V). After minimizing each of equa-
tions, it is possible to create the tables of LUTs implementing each of input memory
functions Dr ∈Φ.
Acting in the same way, it is possible to develop design methods for all Moore
FSMs based on both OCT and RLC.Now, let us discuss the ways of improving the
circuits for blocks BRLC and BMOD.
It is possible to change the number of functions P = P(T, X) or P = P(τ, X). To
do it, it is necessary to transform an initial GSA Γ [9]. Let us discuss the following
example.
Let it be the following subgraph Γ (Fig.4.19a). It presents the transitions from
the state a3 ∈A.
Let it be M1 = 19. Let |X(a3)| = max(|X(a1)|, . . . , |X(a13)|). In this case, there
is G = 3 and P = {p1, p2, p3}. The value of G can be diminished by introducing
additional states (additional operator vertices) [9]. Let us add the vertex marked by
the state a14 (Fig.4.19b). Now, there are X(a3) = {x1, x3} and X(a14) = {x2}. It
leads to G = 2. Let us point out that adding the state a14 does not change the value
of R1 = 4. It is very important because there is no change in the required parameters
of either LUTs or EMBs.
Table 4.27 Table of BIMF for Moore FSM MPEY1D(Γ5)
Zh
Vh
Φh
h
¯z1 ¯z2 ¯z3 ¯z4 ¯z5
∗
–
1
¯z1z2 ¯z3z4 ¯z5
¯v1
D4
2
z1 ¯z2 ¯z3 ¯z4 ¯z5
∗
D3
3
z1z2 ¯z3z4 ¯z5
∗
D3D4
4
z1 ¯z2z3 ¯z4 ¯z5
¯v1
D2
5
z1 ¯z2z3 ¯z4 ¯z5
v1
D2D4
6
¯z1 ¯z2z3z4z5
∗
D2D3
7
¯z1z2 ¯z3z4 ¯z5
1
D2D3D4
8
z1 ¯z2z3z4 ¯z5
∗
D1
9

4.4 Replacement of Logical Conditions in Moore FSMs with OCT
125
(a)
(c)
(b)
Fig. 4.19 The subgraph of GSA Γ
Let us introduce the state a15 (Fig.4.19c). Now, there is G = 1. At the same time,
there is no change for the value of R1. So, the introducing the additional states can
decrease the value of G. In turn, it allows using either LUTs or EMBs with smaller
values of inputs. Obviously, such a transformation has sense till there is no changing
for the value of R1.
It is possible to change the value of RD using so called verticalization of initial
GSA Γ [1, 6–8, 11]. Let us discuss the subgraph of a GSA Γi (Fig.4.20a). Let it be
M1 = 21 for the GSA Γi.
Let the CMO Y(a6) determine the number K of the FCO. Obviously, there is
K = 3. Let us divide the state a6 by two states (Fig.4.20b). Now, there are two
CMOs: Y(a6) = {y1, y2} and Y(a22) = {y0, y3}. Now, there is K = 2. The additional
variable y0 shows that all microoperations are generated.
The MOs are loaded into a special register of microoperations (RMO). There is no
execution of MOs after the transition into the state a6 (Fig.4.20b). Now, there are the
MOs y1 and y2 into RMO. There are all MOs (y1, y2, y3) in RMO after the transition
into the state a22. So, this method leads to the delay into a digital systems operation.
Also, it is necessary to have an additional bit of RMO to keep the variable y0.
The number of ﬁelds can be decreased up to 1. To do it, it is necessary to insert
the states a22, a23, a24 into the initial GSA (Fig.4.20c). In this case, the value of RD
is determined by the following expression:

126
4
Object Codes Transformation for Moore FSMs
(a)
(b)
(c)
Fig. 4.20 The subgraph of GSA Γi
RD = ⌈log2 N⌉+ 1.
(4.34)
In (4.34), the one is added to take into account the additional variable y0.
We do not discuss the last two approaches in this chapter. Let us point out that the
using them increases signiﬁcantly the amount of possible models of Moore FSMs
with OCT.
References
1. M. Adamski, A. Barkalov, A. Bukowiec, Structures of mealy FSM logic circuits under imple-
mentation of verticalized ﬂow-chart, in Proceedings of the IEEE East-West Design and Test
Workshop (EWDTW’05), Kharkov National University of Radioelectronics, Kharkov, 2005,
pp. 70–74
2. T. Agerwala, Microprogram optimization: a survey. IEEE Trans. Comput. 25(10), 962–973
(1976)
3. S. Baranov, Logic Synthesis of Control Automata (Kluwer Academic Publishers, 1994)
4. A. Barkalov, Multilevel PLA schemes for microprogram automata. Cybern. Syst. Anal. 31(4),
489–495 (1995)
5. A. Barkalov, Principles of logic optimization for Moore microprogram automaton. Cybern.
Syst. Anal. 34(1), 54–60 (1998)
6. A. Barkalov, O. Beleckij, A. Nedal, Applying of optimization methods of Moore automaton
for synthesis of compositional microprogram control unit. Autom. Control Comput. Sci. 33(1),
44–52 (1999)
7. A. Barkalov, A. Bukowiec, Synthesis of Mealy Finite-States Machines for interpretation of
verticalized ﬂow-charts. Theor. Appl. Inf. 5(5), 39–51 (2005)
8. A. Barkalov, L. Titarenko, Design of control units with programmable logic devices, in Mea-
surements, methods, systems and design, ed. by J. Korbicz (Wydawnictwo Komunikacji i
Ła˛czno´sci, Warsaw, Poland, 2007), pp. 371–391
9. A. Barkalov, L. Titarenko, Logic Synthesis for FSM-Based Control Units, vol. 53, Lecture notes
in electrical engineering (Springer, Berlin, 2009)
10. A. Barkalov, M. We˛grzyn, Design of Control Units With Programmable Logic (University of
Zielona Góra Press, 2006)
11. A. Bukowiec, Synthesis of Finite State Machines for Programmable devices based on multi-
level implementation. Ph.D thesis, University of Zielona Góra, 2008

References
127
12. Y.C. Chu. Computer Organization and Microprogramming (Prentice Hall, 1972)
13. S. Dasgupta, The organization of microprogram stores. ACM Comput. Surv. 24, 101–176
(1979)
14. M.J. Flynn, R.F. Rosin, Microprogramming: an introduction and a viewpoint. IEEE Trans.
Comput. C 20(7), 727–731 (1971)
15. S. Habib, Microprogramming and Firmware Engineering Methods (Wiley, New York, 1988)
16. E. Pugh, L. Johnson, J. Palmer, IBM’s 360 and Early 370 Systems (MIT Press, Cambridge,
MA, 1991)
17. S. Schwartz. An algorithm for minimizing read-only memories for machine control. IEEE 10th
annual symposium on switching and automata theory, 1968, pp. 28–33
18. V.Sklyarov,I.Skliarova,A.Barkalov,L.Titarenko,SynthesisandOptimizationofFPGA-Based
Systems, vol. 294, Lecture notes in electrical engineering (Springer, Berlin, 2014)

Chapter 5
Distribution of Class Codes in Moore FSMs
5.1 The Case of CPLD-Based FSMs
The approach was proposed in [6]. There are design methods for different models
of Moore FSMs presented in [7–10]. There are the results of investigation of this
approach and other known methods in [11]. Let us discuss the CPLD-based approach
of design.
The majority of CPLDs are based on PAL cells with programmable ﬂip-ﬂops
[1, 2, 16]. Each cell can be viewed as q of s-input AND gates connected with OR
gate. The number q determines the upper limit for product terms to be implemented
by a single PAL. This value is rather small (q ≤8) [1, 2, 16]. Some CPLDs include
EMBs, for example, the Delta39K family from Cypress [12, 13]. It allows using
PALers and EMBers in the logic design.
The proposed method [6] uses two peculiarities of CPLD. The ﬁrst is a wide
fan-in of macrocells (around 30). The second is existence of conﬁgurable EMBs.
The ﬁrst feature allows using more than a single source of codes of PES (rather, the
class codes K(Bi)). The second feature results in implementing the system Y(T) by
EMBs. Let us discuss the model of CPLD-based P Moore FSM (Fig.5.1).
APALerisanetworkofPALsimplementingthesystemofinputmemoryfunctions
Φ = Φ(T, X). There is the register RG distributed among the cells producing the
functions Dr ∈Φ. Because of it, there are signals Start and Clock connected with
the PALer. As in the case of FPGA-based Moore FSMs, the EMBer implements the
system of microoperations Y = Y(T).
It is possible to diminish the number of PALs in the PALer using either the optimal
state assignment (P0) or the transformation of the state codes K(am) into the codes
of classes of PES K(Bi). The second approach leads to the PE Moore FSM (Fig.5.2).
In this case, the PALer2 executes the transformation of state codes. It implements
the system τ = τ(T).
There are the same structural diagrams for P0 and P Moore FSM. But it is imple-
mented the system Φ = Φ(T′, X) in the case of P0 Moore FSM.
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_5
129

130
5
Distribution of Class Codes in Moore FSMs
Fig. 5.1 Structural diagram
of CPLD-based P Moore
FSM
X
T
Y
PALer
EMBer
Start
Clock
Fig. 5.2 Structural diagram
of CPLD-based PE Moore
FSM
X
T
Start
Clock
PALer2
Y
τ
PALer1
EMBer
In the case of PE Moore FSM, the PALer1 implements H0 terms. This model is
applied if the number of terms in Φ(T′, X) exceed H0 [3]. There is one very serious
drawback of PE FSM. It includes the PALer2 consuming some resources of a chip.
The main goal of the approach from [3] is to decrease the number of PAL macrocells
in the circuit of PALer2.
Let the partition ΠA be found for some GSA Γ marked by the states of Moore
FSM. Let us encode the states am ∈A in the optimal way [5]. Let the symbol NIi stand
for the number of generalized intervals of R1-dimensional Boolean space required
for representing the code K(Bi). Let us represent the set ΠA as ΠB ∪ΠC where:
NIi > 1 →Bi ∈ΠB;
(5.1)
NIi = 1 →Bi ∈ΠC.
(5.2)
Obviously, it is necessary to transform only PES belonging to ΠB. Let it be IB = |ΠB|.
To encode the classes Bi ∈ΠB, it is enough RB bits:
RB = ⌈log2 (IB + 1)⌉.
(5.3)
In (5.3), we add 1 to take into account the relation Bi /∈ΠB. Now, there are RB
elements in the set τ.
Let us use an EMB having tF outputs for the case
2R1 ≤VO.
(5.4)
There are Δt unused outputs of EMBs forming the EMBer, where:
Δt =
 N
tF

· tF −N.
(5.5)

5.1 The Case of CPLD-Based FSMs
131
Let L(Dr) be the number of literals in the function Dr ∈Φ. Obviously, there is
L(Dr) ≤L + R1(r = 1, R1). Let the following condition take place:
L(Dr) + RB ≤S.
(5.6)
Let the following condition take place:
Δt ≥RA.
(5.7)
In this case the state transformer can be implemented as a part of EMBer. It leads
to PE1 Moore FSM shown in Fig.5.3.
There is no block PALer2 in the PE1 FSM. The EMBer executes the functions of
the PALer2. This solution requires the minimal number of PAL macrocells.
Let the condition (5.7) be violated but the following condition take place:
Δt = 0.
(5.8)
In this case, it is possible to use the PALer1 as a source of codes K(Bi) for Bi ∈ΠC.
The PALer2 generates the codes K(Bi) for Bi ∈ΠB. It leads to PE2 Moore FSM
(Fig.5.4).
The PALer1 implements the functions
Φ = Φ(T, τ, X).
(5.9)
X
T
PALer
EMBer
Start
Clcck
Y
τ
Fig. 5.3 Structural diagram of PE1 Moore FSM
X
T
Y
τ
Start
Clock
PALer1
PALer2
EMBer
Fig. 5.4 Structural diagram of PE2 Moore FSM

132
5
Distribution of Class Codes in Moore FSMs
There are the following terms in the functions (5.9):
Fh =
 RB

r=1
τeir
r

· Xh;
(5.10)
Fh =
 RB

r=1
τ0
r

·
 R1

r=1
Teir
r

· Xh.
(5.11)
The terms (5.10) are used for classes Bi ∈ΠB. Here eir ∈{0, 1} is a value of the
rth bit of the code K(Bi) from the hth row of the ST. The terms (5.11) are used for
the classes Bi ∈ΠC. The ﬁrst part of (5.11) corresponds to the zero code used for
the relation Bi ∈ΠB. The second part of (5.11) corresponds to the code K(Bi) of the
class Bi ∈ΠC from the hth row of the ST. Here there is eir ∈{0, 1, ∗}. Remind that
the terms (5.11) can be used only if the condition (5.6) takes place.
Let the following condition take place:
RB ≤Δt < RA.
(5.12)
In this case, the model of PE3 Moore FSM can be used (Fig.5.5).
In this model, the EMBer executes the function of PALer2 from Fig.5.4. The
PALer implements functions (5.9) based on terms (5.10) and (5.11).
Let the following condition take place:
0 < Δt < RB.
(5.13)
In this case, the EMBer implements only some bits of the codes K(Bi) for Bi ∈ΠB.
The rest of the bits are implemented by the PALer2. It leads to the PE4 Moore FSM
(Fig.5.6).
In this case, the set τ is represented as τ1∪τ2. The PALer2 implements the system
τ1 = τ2(T).
(5.14)
X
T
Y
τ
PALer1
Start
Clock
EMBer
Fig. 5.5 Structural diagram of PE3 Moore FSM

5.1 The Case of CPLD-Based FSMs
133
PALer1
Start
Clock
X
T
τ1
τ2
Y
PALer2
EMBer
Fig. 5.6 Structural diagram of PE4 Moore FSM
The EMBer implements the functions Y(T) and the system
τ2 = τ2(T).
(5.15)
The PALer1 implements the functions (5.9) based on the terms (5.10) and (5.11).
The discussed models are based on using more than a single source of codes
K(Bi). It is possible due to the wide fan-in of PAL macrocells. The investigation of
this approach [15] shows that it allows saving around 18% of hardware in comparison
with equivalent P0 and PE Moore FSMs. Moreover, it gives a gain in performance.
The resulting circuits are up to 24% faster than their counterparts based on P0 or PE
FSMs.
As a rule, it is possible to use the CPLD-based methods for hardware optimizing
the FPGA-based solutions [14]. But the methods should be modiﬁed to take into
account the speciﬁcs of FPGA. The most important speciﬁc of FPGA is a very
limited amount of inputs per LUT [1, 16]. So, it is impossible to satisfy the condition
(5.6). But it is worth trying to use more than one source of class codes in FPGA-based
Moore FSMs.
5.2 Two Sources of Class Codes in FPGA-Based Moore
FSMs
Let us start from the case when the condition (5.8) takes place. In this case, it is
impossible to use EMBs as a source of class codes. In this case we propose the
FPGA-based model of PE1 Moore FSM (Fig.5.7).
Let us discuss this model. The set Φ is divided by the subsets Φ1 and Φ2. The
set X is represented as X′ ∪X′′. In the common case, the following conditions take
places:
Φ1 ∩Φ2 ̸= ∅;
(5.16)
X′ ∩X′′ ̸= ∅.
(5.17)

134
5
Distribution of Class Codes in Moore FSMs
Fig. 5.7 Structural diagram of FPGA-based PE1 Moore FSM
The LUTer1 implements the functions
Φ1 = Φ1(T′, X′).
(5.18)
The variables T′ ∈T are generated by the multiplexer MX. The LUTer2 implements
the functions
Φ2 = Φ2(τ, X′′).
(5.19)
The variables τr ∈τ are generated by the LUTer3. It implements the functions (4.4)
and the function
yM = yM(T).
(5.20)
The function yM is used to implement the following choice:
Φ = yMΦ1 ∨¯yMΦ2.
(5.21)
The function (5.21) is implemented by MX. The ﬂip-ﬂops of RG are distributed
among the LUTs of MX. Because of it, there are the pulses Start and Clock connected
with MX.
There are the following steps in the design method of PE1 Moore FSM:
1. Marking the initial GSA Γ and ﬁnding the set A.
2. Constructing the set ΠA = {B1, . . . , BI}.
3. Executing the optimal state assignment.
4. Constructing the sets ΠB and ΠC.
5. Executing the encoding of classes Bi ∈ΠB.
6. Constructing the table of LUTer1.
7. Constructing the table of LUTer2.
8. Constructing the table of LUTer3.

5.2 Two Sources of Class Codes in FPGA-Based Moore FSMs
135
9. Constructing the table of MX.
10. Constructing the table of EMBer.
11. Implementing the FSM logic circuit.
Let us discuss an example of synthesis for the Moore FSM PE2(Γ6). There is
the GSA Γ6 shown in Fig.5.8. There are the following sets in the case of Moore
FSM P(Γ6): X = {x1, . . . , x6}, Y = {y1, . . . , y8}, A = {a1, . . . , a13}. It is necessary
R1 = 4 of bits to encode the states am ∈A. It gives the sets Φ = {D1, . . . , D4} and
T = {T1, . . . , T4}.
Let us construct the partition ΠA of the states am ∈A by the classes of PES. There
is the following partition ΠA = {B1, . . . , B7}, where B1 = {a1}, B2 = {a2, a3},
B3 = {a4}, B4 = {a5, a6, a7}, B5 = {a8, a9}, B6 = {a10} and B7 = {a11, a12, a13}.
So, there is I = 7.
Let us encode the state codes in the optimal way. One from the possible solutions
is shown in Fig.5.9. Let I(Bi) be a set of generalized intervals of R1-dimensional
Boolean space covering the states am ∈Bi.
There are the following sets I(Bi) derived from the Karnaugh map (Fig.5.9):
I(B1) = {0000}, I(B2) = {0∗01, ∗101}, I(B3) = {001∗}, I(B4) = {010∗, ∗∗11},
I(B5) = {1∗10}, I(B6) = {0110}, I(B7) = {1∗00, 100∗}. Using these sets, it is
possible to ﬁnd the sets ΠB and ΠC: ΠB = {B2, B4, B7} and ΠC = {B1, B3, B5, B6}.
So, it is necessary to use the transformation of state codes for the states am ∈B2 ∪
B4 ∪B7.
Using (5.3), it is possible to ﬁnd the value RB = 2 determining the set τ = {τ1, τ2}.
Let it be the conﬁguration 16×8 in the FPGA chip in use. So, it is enough only a
single EMB to implement the system Y(T). Using tF = 8 and the expression (5.5),
the value Δt = 0 can be found. So, the model PE1 can be used for the FSM P(Γ6)
in the discussed case.
LetusencodetheclassesBi ∈ΠB asthefollowingones:K(B2) = 01,K(B4) = 10
and K(B7) = 11. Let us use the code 00 to present the relation Bi /∈ΠB.
To construct the tables of LUTer1 and LUTer2, it is necessary to construct the
system of GFT. It is the following system in the discussed case:
B1 →x1a2 ∨¯x1a3;
B2 →x2a4 ∨¯x2x3a5 ∨¯x2 ¯x3a6;
B3 →x3a6 ∨¯x3x4a8 ∨¯x3 ¯x4a9;
B4 →x5a8 ∨¯x5x6a11 ∨¯x5 ¯x6a13;
B5 →a10;
B6 →x1a12 ∨¯x1a1;
B7 →x4a1 ∨¯x4x5a13 ∨¯x4 ¯x5x6a7 ∨¯x4 ¯x5 ¯x6a5.
(5.22)
To construct the table of LUTer1, it is necessary to build the table of BIMF1. It is
constructed on the base of the system of GFT. In the discussed case, it is necessary
to extract from (5.22) the formulae for Bi ∈ΠB. It is Table5.1 in the case of Moore
FSM PE1(Γ6).

136
5
Distribution of Class Codes in Moore FSMs
Fig. 5.8 Initial GSA Γ6

5.2 Two Sources of Class Codes in FPGA-Based Moore FSMs
137
Fig. 5.9 State codes of
Moore FSM P0(Γ6)
Table 5.1 Table of BIMF1 for Moore FSM PE1(Γ6)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
0000
a2
0001
x1
D4
1
a3
1101
¯x1
D1D2D4
2
B3
001∗
a6
0111
x3
D2D3D4
3
a8
1110
¯x3x4
D1D2D3
4
a9
1010
¯x3 ¯x4
D1D3
5
B5
1∗10
a10
0110
1
D2D3
6
B6
0110
a12
1001
x1
D1D4
7
a2
0001
¯x1
D4
8
This table is used to derive the equations for Dr ∈Φ1. It is the following system
in the discussed case:
D1 = ¯T1 ¯T2 ¯T3 ¯T4 ¯x1 ∨¯T1 ¯T2T3 ¯x3 ∨¯T1T2T3 ¯T4x1;
D2 = ¯T1 ¯T2 ¯T3 ¯T4 ¯x1 ∨¯T1 ¯T2T3(x3 ∨x4) ∨T1T3 ¯T4;
D3 = ¯T1 ¯T2T3 ∨T1T2T3;
D4 = ¯T1 ¯T2 ¯T3 ¯T4 ∨¯T1 ¯T2T3x3 ∨¯T1T2T3 ¯T4;
(5.23)
The system (5.23) determines four tables for LUTs of the LUTer1. These tables
are constructed in the way discussed in previous chapters.
To construct the table of LUTer2, it is necessary to use the system of GFT and
construct the table of BIMF2. In the discussed case, it is constructed using formulae
for B2, B4, B7 ∈ΠC from (5.22). This table has 10 rows (Table5.2).
This table is used for deriving the equations for system (5.19). The following
equations can be found from Table5.2:
D1 = τ1 ¯τ2 ∨τ1τ2( ¯x4x5 ∨¯x4 ¯x5x6);
D2 = ¯τ1τ2 ¯x2 ∨τ1 ¯τ2(x5 ∨x6) ∨τ1τ2 ¯x4 ¯x5x6;
D3 = ¯τ1τ2(x2 ∨¯x3) ∨τ1 ¯τ2x5 ∨τ1τ2 ¯x4 ¯x5x6;
D4 = ¯τ1τ2 ¯x2 ¯x3 ∨τ1τ2 ¯x4 ¯x5 ¯x6.
(5.24)
The system (5.24) determines R1 = 4 of tables for LUTs implementing the circuit
of LUTer2. We do not discuss this step.

138
5
Distribution of Class Codes in Moore FSMs
Table 5.2 Table of BIMF2 for Moore FSM PE1(Γ6)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B2
01
a4
0010
x2
D3
1
a5
0100
¯x2x3
D2
2
a6
0111
¯x2 ¯x3
D2D3D4
3
B4
10
a8
1110
x5
D1D2D3
4
a11
1100
¯x5x6
D1D2
5
a13
1000
¯x5 ¯x6
D1
6
B7
11
a1
0000
x4
–
7
a13
1000
¯x4x5
D1
8
a7
1111
¯x4 ¯x5x6
D1D2D3D4
9
a5
0100
¯x4 ¯x5 ¯x6
D2
10
To construct the table of LUTer3, it is necessary to ﬁnd the system τ(T). It can
be done using two Karnaugh maps shown in Fig.5.10.
Let us explain the approach used for ﬁlling the cells of the maps. There are the
signs “*” for unused state codes (0011, 0101 and 1011). There are the signs “*” for
the state codes corresponding to states am ∈Bi where Bi ∈ΠC (0000, 0010, 0110,
1110 and 1010). Obviously, there are the following equations:
τ1 = B4 ∨B7;
τ2 = B2 ∨B7.
(5.25)
It follows, for example, from Table5.2.
So, there are 1’s for states am ∈B4 ∪B7 and 0’s for states am ∈B2 (Fig.5.10a).
There are 1’s for states am ∈B2 ∪B7 and 0’s for states am ∈B4 (Fig.5.10b). It leads
to the following equations:
τ1 = ¯T4 ∨T3 ∨¯T2 ¯T4;
τ2 = T1 ¯T3 ∨¯T1 ¯T2.
(5.26)
To implement the system (5.26), it is enough 2 of LUTs having S = 3.
Fig. 5.10 Karnaugh maps
for functions τ1(a) and τ2(b)
(a)
(b)

5.2 Two Sources of Class Codes in FPGA-Based Moore FSMs
139
It is necessary R1 of LUTs having S = 3 to implement the system (5.21). There
is the following equation implemented by rth LUT of MX:
Dr = yMD1
r ∨¯yMD2
r
(r = 1, R1).
(5.27)
There is the superscript 1 for Dr ∈Φ1, whereas there is the superscript 2 for Dr ∈Φ2.
The table of EMBer has the columns T, Y, m. It is constructed in a way we have
discussed in previous chapters.
Now, let us discuss how to get the equation for yM. There are two ways. Firstly,
we can form an equation similar to the equations from (5.25):
yM = B2 ∨B4 ∨B7.
(5.28)
It gives the following minimized expression:
yM = T4 ∨T2 ¯T3 ∨T1 ¯T3.
(5.29)
This equation is implemented by the LUTer3.
Secondly, the class codes can be used to get the equation for yM. It is the following
equation:
yM = τ1 ∨τ2.
(5.30)
This equation is implemented by the LUTer2. It results in the PE2 Moore FSM
(Fig.5.11).
Let us discuss the case when the following conditions take places:
Δt = RB + 1;
(5.31)
RB + 1 < RA.
(5.32)
Fig. 5.11 Structural diagram of FPGA-based PE2 Moore FSM

140
5
Distribution of Class Codes in Moore FSMs
The condition (5.32) shows that the EMBer can be used for generating the functions
τ(T). The condition (5.32) shows that there are no enough outputs of EMBer to
implement the transformation for all classes Bi ∈ΠA.
In this case, the model of PE3 Moore FSM (Fig.5.12) can be used. Here, the
EMBer implements the functions Y(T), τ(T) and yM(T).
There are the same functions of blocks LUTer1 and LUTer2 as they are for PE1
Moore FSM. The EMBer executes the functions of LUTer3. Design methods are the
same for PE1 and PE3 FSMs. But there is no step 8in the case of PE3 FSM.
Let us discuss how to construct the table of EMBer for the Moore FSM PE3(Γ6).
It contains the following columns: T (an address of a cell), Y, τ, yM (the content of
the cell), m. In the discussed case, it is Table5.3. We use here the state codes from
Fig.5.9. The column m contains either the subscript of a corresponding state am ∈A
or the sign “*” for “don’t care” input assignments.
There is yM = 1 for the cells corresponding to am ∈B2 ∪B4 ∪B7. There is the
code 01 for states a2, a3 ∈B2, the code 10 for a5, a6, a7 ∈B4 and the code 11 for
a11, a12, a13 ∈B7 (the column τ of Table5.3). There are the codes of CMOs taken
from the GSA Γ6 (the column Y of Table5.3).
Let the following condition take place:
Δt = RB.
(5.33)
In this case, the function yM is represented as
yM = yM(τ).
(5.34)
It results in the PE4 Moore FSM shown in Fig.5.13. In this model, the LUTer2
implements the function (5.34).
There are the same steps in design of FSMs PE3 and PE4. But there are two
peculiarities in the later case: (1) the LUTer2 implements the function (5.34) and (2)
there is no the column yM in the table of EMBer. In the discussed case, the equation
(5.30) is implemented by the LUTer2.
Fig. 5.12 Structural diagram of PE3 Moore FSM

5.3 Three Sources of Class Codes in FPGA-Based Moore FSMs
141
Table 5.3 Table of EMBer for Moore FSM PE3(Γ6)
T
Y
τ
yM
m
T1T2T3T4
y1y2y3y4y5y6y7y8
τ1τ2
0000
00000000
00
0
1
0001
11000000
01
1
2
0010
01010000
00
0
4
0011
00000000
00
0
∗
0100
00100000
10
1
5
0101
00000000
00
0
∗
0110
01010000
00
0
10
0111
00011000
10
1
6
1000
00001000
11
1
13
1001
00100010
11
1
12
1010
10000010
00
0
9
1011
00000000
00
0
∗
1100
00110000
11
1
11
1101
00100000
01
1
3
1110
01000001
00
0
8
1111
00001100
10
1
7
Fig. 5.13 Structural diagram of PE4 Moore FSM
5.3 Three Sources of Class Codes in FPGA-Based Moore
FSMs
Let the condition (5.13) take place. In this case, we propose the model of PE5 Moore
FSM (Fig.5.14).
The LUTer3 plays the same role as the PALer2 (Fig.5.6). The design methods are
the same for FSMs PE1 and PE5. As in the previous case, the LUTer2 can implement
the function yM. It leads to PE6 Moore FSM (Fig.5.15).

142
5
Distribution of Class Codes in Moore FSMs
Fig. 5.14 Structural diagram of PE5 Moore FSM
Fig. 5.15 Structural diagram of PE6 Moore FSM
In the common case, the LUTer1 corresponds to BIMF1, LUTer2 to BIMF2,
LUTer3 to BCST, EMBer to BMO. It leads to the general model of PE6 Moore FSM
(Fig.5.16).
Fig. 5.16 General structural diagram of PE6 Moore FSM

5.3 Three Sources of Class Codes in FPGA-Based Moore FSMs
143
As in previous cases, different elements can be used for implementing the cir-
cuits of different FSM’s blocks. Analysis of Fig.5.16 shows that the BMO should
be implemented as EMBer, whereas BCST as LUTer, So, there are four different
modiﬁcations of PE6 Moore FSM. Let us show the vectors ⟨BIMF1, BIMF2⟩for
different modiﬁcations.
The PE61 Moore FSM corresponds to the vector ⟨L1, L2⟩, the PE62 Moore FSM
to ⟨L1, B2⟩, the PE63 Moore FSM to ⟨B1, L2⟩and the PE64 Moore FSM to ⟨B1, B2⟩.
All these models are designed using the same general method. But there are different
approaches for designing the circuits for BIMF1 and BIMF2.
Obviously, there are four different modiﬁcations for all discussed PEi FSMs (i =
1, 6). It gives 24 basic models of Moore FSM with the distribution of class codes.
Three approaches can be used for hardware reduction in PEi Moore FSM: (1) the
replacement of logical conditions; (2) the maximal encoding of the collections of
microoperations; (3) the encoding of the ﬁelds of compatible microoperations. Let
us discuss these approaches.
5.4 Replacement of Logical Conditions and Distribution
of Class Codes
In contrast to MP Moore FSM, there are two blocks of RLC in the MPEi FSMs. Let
us discuss the general case for MPE1 Moore FSMs (Fig.5.17). It includes blocks
BRLC1 and BRLC2 executing the replacement of logical conditions.
The BRLC1 implements the system
P′ = P′(T, X′),
(5.35)
whereas the BRLC2 the system
P′′ = P′′(τ, X′′).
(5.36)
Fig. 5.17 General structural diagram of MPE1 Moore FSM

144
5
Distribution of Class Codes in Moore FSMs
The BIMF1 implements the system
Φ1 = Φ1(T, P′),
(5.37)
whereas the BIMF2 the system
Φ2 = Φ2(τ, P′′).
(5.38)
There are the same functions executed by the BSCT and the LUTer3 (Fig.5.7). The
same is true for BMO and EMBer.
There are the following steps in design method for MPE1 Moore FSM:
1. Constructing the set of states for Moore FSM.
2. Constructing the set ΠA = {B1, . . . , BI}.
3. Executing the optimal state assignment.
4. Constructing the sets ΠB and ΠC.
5. Executing the encoding of classes Bi ∈ΠB.
6. Finding the sets P′ and P′′.
7. Executing the RLC for xe ∈X′.
8. Executing the RLC for xe ∈X′′.
9. Constructing the transformed table for BIMF1.
10. Constructing the transformed table for BIMF2.
11. Constructing the table of BSCT.
12. Constructing the table of MX.
13. Constructing the table of BMO.
14. Implementing the FSM logic circuit.
Let us discuss an example of design for Moore FSM MPE14(Γ6). The subscript
14 means that both circuits of BIMF1 and BIMF2 are implemented as EMBers. Let
us point out that the BMO is implemented as EMBer, whereas the BSCT as LUTer.
Let us use the same state codes as it is shown in Fig.5.9. It means that the steps 1–5
are already executed for the discussed example.
Let us form the system of GFTs for PE(Γ6). It is the system (5.22). The set X′
includes logical conditions determining transitions from states am ∈Bi where Bi ∈
ΠC. Analysis of (5.22) gives the set X′ = {x1, x3, x4}. The set X′′ includes logical
conditions xe ∈X determining transitions from states am ∈Bi where Bi ∈ΠB.
Analysis of (5.22) gives the set X′′ = {x2, x3, x4, x5, x6}.
There are the following sets X(Bi) for Bi ∈ΠC: X(B1) = {x1}, X(B3) = {x3, x4},
X(B5) = {}, X(B6) = {x1}. So, there is G1 = 2 and P′ = {p1, p2}. Let us replace the
logical conditions xe ∈X′ as it is shown in Table5.4.
The following sets X(Bi) can be found for the classes Bi ∈ΠB: X(B2) = {x2, x3},
X(B4) = {x5, x6} and X(B7) = {x4, x5, x6}. It gives the set P′′ = {p3, p4, p5}. The
RLC is shown in Table5.5 for xe ∈X′′.

5.4 Replacement of Logical Conditions and Distribution of Class Codes
145
Table 5.4 Table of RLC for xe ∈X′
pg
Bi
B1
B3
B5
B6
p1
x1
x3
–
x1
p2
–
x4
–
–
K(Bi)
0000
001∗
1∗10
0110
Table 5.5 Table of RLC for xe ∈X′′
pg
Bi
B2
B4
B7
p3
x2
x5
x5
p4
x3
x6
x6
p5
–
–
x4
K(Bi)
01
10
11
Table5.4 is used for deriving the system (5.35). It is the following system:
p1 = ¯T1 ¯T2 ¯T3 ¯T4x1 ∨¯T1 ¯T2T3x3 ∨¯T1T2T3 ¯T4x1;
p2 = x4.
(5.39)
Table5.5 is used for deriving the system (5.36). It is the following system:
p3 = ¯τ1τ2x2 ∨τ1x5;
p4 = ¯τ1τ2x3 ∨τ1x6;
p5 = x4.
(5.40)
The system (5.39) determines the LUTer1 consisting from a single LUTerp1. The
system (5.40) determines the LUTer2 consisting from LUTerp3 and LUTerp4. There
is no need in implementing the circuits for variables p2 and p5.
There are the same columns in tables for LUTerp1, LUTerp3 and LUTerp4. But
these columns differ in content. There are the following columns in these tables:
K(Bi), X(Pg), pg, q. For example, the LUTerp3 is represented by Table5.6.
This table is constructed on the base of the corresponding equation from (5.40).
Acting in the same way, it is possible to construct tables for all functions pg ∈P′∪P′′.
Two steps are necessary to construct the transformed tables of BIMF1 and BIMF2.
Firstly, it is necessary to construct the tables similar to Tables5.1 and 5.2. Secondly,
it is necessary to replace the column Xh by the column Ph. There is the transformed
table of BIMF1 represented by Table5.7.
The transformed table of BIMFi (i = 1, 2) is used for constructing the tables for
EMBeri (i = 1, 2). Each table includes the columns: K(Bi), P (an address of a cell),
Φ, q. It is necessary H(Bi) cells to represent the transitions from the states am ∈Bi,
where:
H(Bi) = 2Gj
(j = 1, 2).
(5.41)

146
5
Distribution of Class Codes in Moore FSMs
Table 5.6 Table of LUTerp3 for Moore FSM MPE14(Γ6)
K(Bi)
X(P3)
p3
q
K(Bi)
X(P3)
p3
q
τ1τ2
x2x5
τ1τ2
x2x5
00
00
0
1
10
00
0
9
00
01
0
2
10
01
1
10
00
10
0
3
10
11
0
11
00
11
0
4
10
11
1
12
01
00
0
5
11
00
0
13
01
01
0
6
11
01
1
14
01
10
1
7
11
10
0
15
01
11
1
8
11
11
1
16
Table 5.7 Transformed table of BIMF1 for Moore FSM MPE14(Γ6)
Bi
K(Bi)
as
K(as)
Ph
Φh
h
B1
0000
a2
0001
p1
D4
1
a3
1101
¯p1
D1D2D4
2
B3
001∗
a6
0111
p1
D2D3D4
3
a8
1110
¯p1x4
D1D2D3
4
a9
1010
¯p1 ¯x4
D1D3
5
B5
1∗10
a10
0110
1
D2D3
6
B6
0110
a12
1001
p1
D1D4
7
a2
0001
¯p1
D4
8
Table 5.8 Part of the table of EMBer1 for Moore FSM MPE14(Γ6)
K(Bi)
P
Φ
q
h
Bi
T1T2T3T4
p1x4
D1D2D3D4
0000
00
1101
1
2
B1
0000
01
1101
2
2
0000
10
0001
3
1
0000
11
0001
4
1
0010
00
1010
5
5
B3
0010
01
1110
6
4
0010
10
0111
7
3
0010
11
0111
8
3
0011
00
1010
9
5
0011
01
1110
10
4
0011
10
0111
11
3
0011
11
0111
12
3

5.4 Replacement of Logical Conditions and Distribution of Class Codes
147
A part of the table of EMBer1 is represented by Table5.8.
We add the columns h, Bi to show the correspondence between Tables5.7 and 5.8.
There is no “*” in the code K(Bi). Because of it, it is necessary 4 rows to represent
the corresponding transitions. There is a single “*” in the K(B3). So, it is necessary
8 rows to represent the transitions for the codes 0010 and 0011 (Table5.8).
All other tables can be constructed as it is for the FSM PE1(Γ6). These steps are
already executed.
5.5 Increasing the Number of Class Variables
The variables Tr ∈T are called state variables [4]. By an analogy with state variables,
let us name the variables τr ∈τ class variables. Let us discuss the following approach
for design of FPGA-based Moore FSMs.
Let us ﬁnd the set ΠA = {B1, . . . , BI} where Bi ∈ΠA is a class of PES. Let us
represent the set ΠA as
ΠA = ΠA1 ∪ΠA2 ∪· · · ∪ΠAK.
(5.42)
The following relation takes place for sets ΠAk:
ΠAi ∩ΠAj = ∅(i ̸= j,
i, j ∈{1, . . . , K}).
(5.43)
Let us encode the classes Bi ∈ΠAk by codes K(Bi) having RAk bits:
RAk = ⌈log2 IAk⌉(k = 1, K).
(5.44)
In (5.44), there is IAk = |ΠAk| (k = 1, K). Let us use the variables τr ∈τk to
encode the classes Bi ∈ΠAk.
Let us use the variables zr ∈Z to represent the relations Bi ∈ΠAk (k = 1, K). It
is necessary RK variables to encode each of above mentioned relations:
RK = ⌈log2 K⌉.
(5.45)
Let it be calculated the value of Δt for some Moore FSM P(Γj) and EMBs of a
particular FPGA chip. To calculate Δt, the expression (5.5) is used. Let us discuss
the case (5.8) when there is Δt = 0. It leads to PKE1 Moore FSM (Fig.5.18).
The set τ combines the sets τ1, . . . , τK. The MX is controlled by variables zr ∈Z.
This approach can be viewed as a Moore FSM having K sources of class codes.
The MX executes the choice of Φk as a source for functions Tr ∈T. So, it executes
the function
Φ =
K

k=1
ZkΦk.
(5.46)

148
5
Distribution of Class Codes in Moore FSMs
Fig. 5.18 Structural diagram of PKE1 Moore FSM
In (5.46), the symbol Zk stands for the conjunction of variables zr ∈Z corresponding
to the relation Bi ∈ΠAk.
Let it be S inputs in the LUTs of an FPGA chip used for implementing the FSM’s
circuit. To minimize the hardware amount in MX, it is necessary that each of functions
Dr ∈Φ is implemented using a single LUT. It is possible if the following relation
takes place:
K + RK ≤S.
(5.47)
Using (5.47), one can ﬁnd the maximum possible amount of blocks representing
the BIMF.
Let the following relation take place:
Δt ≥
K

k=1
RAk + RK.
(5.48)
In this case, the BMO generates the functions Z and τ. It leads to PKE2 Moore FSM
(Fig.5.19).
Fig. 5.19 Structural diagram of PKE2 Moore FSM

5.5 Increasing the Number of Class Variables
149
In the case of PKE2 Moore FSM, the block BSCT is absent. It leads to the decreas-
ing for the number of LUTs in comparison with PKE1 Moore FSM.
At last, it is possible that BMO can implement only a part of functions. It is true
if the following condition takes place:
0 < Δt <
K

k=1
RAk + RK.
(5.49)
It leads to PKE3 Moore FSM (Fig.5.20).
In this case, the set τ is divided by sets τBMO and τCT (τBMO ∩τCT = ∅; τBMO ∪
τCT = τ). As in previous cases, the BIMFk implements the functions
Φk = Φk(τk, Xk) (k = 1, K).
(5.50)
Obviously, the PKE3 is the most general model of Moore FSM with K sources of
class codes. There are the following steps in its design method:
1. Constructing the set of states A.
2. Constructing the set ΠA = {B1, . . . , BI}.
3. Constructing the sets ΠAk(k = 1, K).
4. Executing the state assignment.
5. Executing the encoding of classes Bi ∈ΠA.
6. Constructing set Z and encoding of directions.
7. Constructing the tables of BIMFk (k = 1, K).
8. Constructing the table of BSCT.
9. Constructing the table of BMO.
10. Constructing the table of MX.
11. Implementing the FSM logic circuit.
Let us discuss an example of design for Moore FSM P2E1(Γ6). It is possible if the
EMB in use has the conﬁguration 16×8 bits. In this case, there is Δt = 0 (because
Fig. 5.20 Structural diagram of PKE3 Moore FSM

150
5
Distribution of Class Codes in Moore FSMs
of N = 8). The GSA Γ6 is shown in Fig.5.8. There is the set A = {a1, . . . , a13}.
These states are distributed among I = 7 classes Bi ∈ΠA. There is the set ΠA =
{B1, . . . , B7}, where B1 = {a1}, B2 = {a2, a3}, B3 = {a4}, B4 = {a5, a6, a7},
B5 = {a8, a9}, B6 = {a10}, B7 = {a11, a12, a13}.
As follows from the formula P2E1, there is K = 2. So, it is necessary to distribute
the classes Bi ∈ΠA between the sets ΠA1 and ΠA2. Let us use two rules for the
distribution. Firstly, let the amount of classes be approximately the same in the
classes ΠAk(k = 1, K). Secondly, let the following condition take place:
|A(ΠAi) ∩A(ΠAj)| →min(i, j ∈{1, . . . , K}).
(5.51)
In (5.51), the symbol A(ΠAk) means the set of states of transition for the states from
classes Bi ∈ΠAk.
Using these rules, the following sets can be constructed. The set ΠA1
=
{B1, B2, B7} corresponds to the set A(ΠA1) = {a1, a7, a13}. The set ΠA2 =
{B3, . . . , B6} corresponds to the set A(ΠA2) = {a1, a8, . . . , a13}.
Let us encode states am ∈A as it is shown in Fig.5.21. Analysis of this Karnaugh
map shows that: (1) there is T1 = 0 for states am ∈A(ΠA1) and (2) there is T1 = 1
for states am ∈A(ΠA2) (the only difference is for a13).
The are IA1 = 3 and IA2 = 4 in the discussed case. Using (5.44), the following
values can be found: RA1 = RA2 = 2. It gives the set τ = {τ1, . . . , τ4} with τ1 =
{τ1, τ2} and τ2 = {τ3, τ4}. Let us encode the classes Bi ∈ΠA as the following:
K(B1) = K(B3) = 00, K(B2) = K(B4) = 01, K(B5) = K(B7) = 10 and K(B6) =
11.
There are two sources of codes used by the MX. So, there is K = 2; it gives
RK = 1 and the set Z = {z1}. Let z1 = 0 mean that the input memory functions are
generated by the BIMF1. Obviously, the BIMF2 is determined by z1 = 1.
ThetableofBIMFk isconstructedonthebaseofthesystemofGFT.Itisthesystem
(5.22) in the discussed case. Table5.9 represents the table of BIMF1. Table5.10
represents the BIMF2.
Table5.9 is used to derive the system
Φ1 = Φ1(τ1, X1).
(5.52)
Fig. 5.21 State codes for
Moore FSM P(Γ6)

5.5 Increasing the Number of Class Variables
151
Table 5.9 Table of BIMF1 for Moore FSM P2E1(Γ6)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
00
a2
1000
x1
D1
1
a3
1001
¯x1
D1D4
2
B2
01
a4
1010
x2
D1D3
3
a5
1100
¯x2x3
D1D2
4
a6
0111
¯x2 ¯x3
D2D3D4
5
B7
10
a1
0000
x4
–
6
a13
0110
¯x4x5
D2D3
7
a7
1110
¯x4 ¯x5x6
D1D2D3
8
a5
1101
¯x4 ¯x5 ¯x6
D1D2D4
9
Table 5.10 Table of BIMF2 for Moore FSM P2E1(Γ6)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B3
00
a6
0111
x3
D2D3D4
a8
0001
¯x3x4
D4
a9
0010
¯x3 ¯x4
D3
B4
01
a8
0001
x5
D4
a11
0100
¯x5x6
D2
a13
0110
¯x5 ¯x6
D2D3
B5
10
a10
0011
1
D3D4
B6
11
a12
0101
x1
D2D4
a1
0000
¯x1
–
Table5.10 is used to derive the system
Φ2 = Φ2(τ2, X2).
(5.53)
For example, the following equations can be derived from Table5.9:
D1 = ¯τ1 ¯τ2 ∨¯τ1τ2(x2 ∨x3) ∨τ1 ¯τ2 ¯x4 ¯x5;
D2 = ¯τ1τ2 ¯x2 ∨τ1 ¯τ2 ¯x4;
D3 = ¯τ1τ2(x2 ∨¯x3) ∨τ1 ¯τ2( ¯x4x5 ∨¯x4 ¯x5x6);
D4 = ¯τ1 ¯τ2 ¯x1 ∨¯τ1τ2 ¯x2 ¯x3 ∨τ1 ¯τ2 ¯x4 ¯x5 ¯x6.
(5.54)
Let us point out that some function Dr = 1 if the variable Tr = 1 in the codes of
states am ∈A(ΠAk). If a variable Tr = 0 for all codes of states am ∈A(ΠAk), then
the variable Dr = 0 for all rows of the corresponding table of BIMFk. There are no
such variables in Table5.9, but the variable T1 = 0 for all rows of Table5.10.

152
5
Distribution of Class Codes in Moore FSMs
The following equations can be derived from Table5.10:
D1 = 0;
D2 = ¯τ3 ¯τ4x3 ∨¯τ3τ4 ¯x5 ∨τ3τ4x1;
D3 = ¯τ3 ¯τ4(x3 ∨¯x4) ∨¯τ3τ4 ¯x5 ∨τ3 ¯τ4;
D4 = ¯τ3 ¯τ4(x3 ∨x4) ∨¯τ3τ4x5 ∨τ3 ¯τ4 ∨τ3τ4 ¯x1.
(5.55)
If LUTs are used for implementing, for example, the BIMF1, then the Eq.(5.54)
are transformed into four tables of LUTerD1–LUTerD4. If EMBs are used to imple-
ment the circuit of BIMF1, then Table5.9 are transformed into the table of EMBer1.
The same is true for the BIMF2.
In the common case, there are the following ﬁelds in a code K(Bi): K(MX) is a
code of a direction for MX, K(Bi)1 is a code of a class Bi ∈ΠA1, . . . , K(Bi)K is a
code of a class Bi ∈ΠAK. In the discussed case, there are 5 bits in the code K(Bi):
K(Bi) = ⟨z1, τ1, τ2, τ3, τ4⟩.
(5.56)
So, there are ﬁve outputs in the block BSCT in the discussed case.
There are the following columns in the table of BSCT: K(am), Z, τ, m. It is
Table5.11 in the discussed example.
Let us explain how this table is constructed. The code 0000 belongs to the state
a1 ∈B1. There is the following relation B1 ∈ΠA1. So, there is z1 = 0 (input
memory functions are taken from the BIMF1) and τ1 = τ2 = 0 (it corresponds to
the K(B1) = 00), whereas τ3 = τ4 = ∗(“don’t care”). The ﬁrst row is completed.
The second row contains the code K(a8) and a8 ∈B5 where B5 ∈ΠA2. So, there are
z1 = 1, τ1 = τ2 = ∗and τ1 = 1, τ2 = 0 in the second row of the table. And so on.
The table of BSCT is used for deriving the systems Z = Z(T) and τ = τ(T).
They are the systems (4.8) and (4.4), correspondingly. If the BSCT is implemented
as a LUTer, then the equations should be minimized. For example, the following
equations can be derived from Table5.11:
Table 5.11 Table of BSCT for Moore FSM P2E1(Γ6)
K(am)
Z
τ
m
K(am)
Z
τ
m
T1T2T3T4
z1
τ1τ2τ3τ4
T1T2T3T4
z1
τ1τ2τ3τ4
0000
0
00∗∗
1
1000
0
01∗∗
2
0001
1
∗∗10
8
1001
0
01∗∗
3
0010
1
∗∗10
9
1010
1
∗∗00
4
0011
1
∗∗11
10
1011
∗
∗∗∗∗
∗
0100
0
10∗∗
11
1100
1
∗∗01
5
0101
0
10∗∗
12
1101
∗
∗∗∗∗
∗
0110
0
10∗∗
13
1110
1
∗∗01
7
0111
1
∗∗01
6
1111
∗
∗∗∗∗
∗

5.5 Increasing the Number of Class Variables
153
z1 = T1T2 ∨T3T4 ∨¯T1 ¯T2T4 ∨¯T2T3;
τ1 = T2;
τ2 = T1;
τ3 = T1T2;
τ4 = T1T2 ∨T3T4 = τ3 ∨T3T4.
(5.57)
We do not discuss the tables of MX and BMO for this example. These tables are
constructed as we do it before.
Now let us discuss an example of design for P3E3(Γ7). There is the GSA Γ7 shown
in Fig.5.22.
Fig. 5.22 Initial GSA Γ7

154
5
Distribution of Class Codes in Moore FSMs
There are the following sets derived from GSA Γ7: A = {a1, . . . , a16}, X =
{x1, . . . , x7}, Y = {y1, . . . , y9}. So, there are the following sets and parameters:
M = 16, R1 = 4, T = {T1, . . . , T4}, Φ = {D1, . . . , D4}, L = 7, N = 9. There
are the following classes of PES: B1 = {a1}, B2 = {a2, a3}, B3 = {a4, a5}, B4 =
{a6, a7, a8}, B5 = {a9, a10}, B6 = {a11}, B7 = {a12, a13}, B8 = {a14}, B9 =
{a15, a16}. So, there is I = 9 and ΠA = {B1, . . . , B9}. It means that there is RA = 4.
There is the following equality in the discussed case:
R1 = RA.
(5.58)
It means that the transformation of state codes does not reduce the number of literals
in functions Φ.
Let the FPGA chip include LUTs having S = 5. Using (5.47), we can ﬁnd that:
K ≤3, RK ≤2. Let us choose K = 3. It gives RK = 2 and Z = {z1, z2}. Let
us encode the sets ΠAk ⊆ΠA as the following: K(ΠA1) = 00, K(ΠA2) = 01 and
K(ΠA3) = 10.
Let us form the following sets ΠAk: ΠA1 = {B1, B2, B3}, ΠA2 = {B4, B5, B6},
ΠA3 = {B7, B8, B9}. It gives the sets A(ΠA1) = {a2, a3, a4, . . . , a8}, A(ΠA2) =
{a9, a10, a11, a12, a13}, A(ΠA3) = {a14, a15, a16, a1}. Let us encode the states am ∈
A as it is shown in Fig.5.23.
Analysis of Fig.5.23 shows that there is T1 = 0 for all states am ∈A(ΠA1). Also,
there is T1 = 1 for all states am ∈A(ΠA2) and for states a14, a15, a16 ∈A(ΠA3). It
allows simplifying equations for functions Dr ∈Φ.
Let us encode the classes Bi ∈ΠA. There is IAk = 3 for ΠAk ⊆ΠA(k = 1, 3).
It means that there is RAk = 2. Now we have the following sets: Z = {z1, z2},
τ1 = {τ1, τ2}, τ2 = {τ3, τ4} and τ3 = {τ5, τ6}. Let us encode the classes Bi ∈ΠA
as the following: K(B1) = K(B4) = K(B7) = 00; K(B2) = K(B5) = K(B8) = 01;
K(B3) = K(B6) = K(B9) = 10. Let us encode the sets ΠAk ⊆ΠA in the following
manner: K(ΠA1) = 00, K(ΠA2) = 01, K(ΠA3) = 10.
To construct the tables of BIMFk, it is necessary to construct the system of GFT.
It is the following system in the discussed case:
Fig. 5.23 State codes for
P3K3(Γ7)

5.5 Increasing the Number of Class Variables
155
ΠA1
⎧
⎨
⎩
B1 →x1a2 ∨¯x1a3;
B2 →x2a4 ∨¯x2a5;
B3 →x3a6 ∨¯x3x4a7 ∨¯x3 ¯x4a8;
ΠA2
⎧
⎨
⎩
B4 →x5a9 ∨¯x5a10;
B5 →a11;
B6 →x6a12 ∨¯x6a13;
ΠA3
⎧
⎨
⎩
B7 →a14;
B8 →x7a15;
B9 →x3a1 ∨¯x3a14
(5.59)
The table of BIMFk is constructed using the part ΠAk(k = 1, 3) from the system
(5.59). These blocks are represented by Tables5.12, 5.13 and 5.14.
Let us denote as Dk
r the function Dr ∈Φ implemented by BIMFk (k = 1, K).
In the discussed case, there is the following system of equations derived from
Table 5.12 Table of BIMF1 for Moore FSM P3E3(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
00
a2
0001
x1
D4
1
a3
0010
¯x1
D3
2
B2
01
a4
0011
x2
D3D4
3
a5
0100
¯x2
D2
4
B3
10
a6
0101
x3
D2D4
5
a7
0110
¯x3x4
D2D3
6
a8
0111
¯x3 ¯x4
D2D3D4
7
Table 5.13 Table of BIMF2 for Moore FSM P3E3(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B4
00
a9
1000
x5
D1
1
a10
1001
¯x5
D1D4
2
B5
01
a11
1010
1
D1D3
3
B6
10
a12
1011
x6
D1D3D4
4
a13
1100
¯x6
D1D2
5
Table 5.14 Table of BIMF3 for Moore FSM P3E3(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B7
00
a14
1101
1
D1D2D4
1
B8
01
a15
1111
x7
D1D2D3D4
2
a16
1110
¯x7
D1D2D3
3
B9
10
a1
0000
x3
–
4
a14
1101
¯x3
D1D2D4
5

156
5
Distribution of Class Codes in Moore FSMs
Tables5.12, 5.13 and 5.14:
D1
1 = 0;
D1
2 = τ2 ¯x2 ∨τ1;
D1
3 = ¯τ1 ¯τ2 ¯x1 ∨τ2x2 ∨τ1 ¯x3;
D1
4 = ¯τ1 ¯τ2x1 ∨τ2x2 ∨τ1x3 ∨τ1 ¯x4;
D2
1 = 1;
D2
2 = τ3 ¯x6;
D2
3 = τ4 ∨τ3x6;
D2
4 = ¯τ3 ¯τ4 ¯x5 ∨τ3x6;
D3
1 = ¯τ5 ∨τ5 ¯x3 = D3
2;
D3
3 = τ6;
D3
4 = ¯τ5 ¯τ6 ∨τ6x7 ∨τ5 ¯x3.
(5.60)
Analysis of system (5.60) shows that it can be implemented using 8 LUTs having
S ≤5. There are no LUTs necessary for implementing the functions D1
2, D2
1, D3
2 and
D3
3.
The MX is represented using the following equations:
D1 = ¯z1 ¯z2 · 0 ∨z2D2
1 ∨z1D3
1 = z2 ∨z1D3
1;
D2 = ¯z1 ¯z2D1
2 ∨z2D2
2 ∨z1D3
2;
D3 = ¯z1 ¯z2D1
3 ∨z2D2
3 ∨z1D3
3;
D4 = ¯z1 ¯z2D1
4 ∨z2D2
4 ∨z1D3
4.
(5.61)
There are the following columns in the table of BSCT: am, K(am), Bi, K(Bi),
ΠAk, K(ΠAk), m. The EMBer can implement Δt functions f ∈ZUτ. To ﬁnd these
functions, let us ﬁnd the minimized functions Z(T) and τ(T).
Let A(Bk
i ) ⊆A be a set of states from the classes Bi ∈ΠAk. There are three
such sets in the discussed case: A(B1
i ) = {a1, . . . , a5}, A(B2
i ) = {a6, . . . , a11},
A(B3
i ) = {a12, . . . , a16}. Let us construct the Karnaugh maps for functions τ1, τ2 ∈τ
(Fig.5.24).
Fig. 5.24 Karnaugh maps
for functions τ1(a) and τ2(b)
(a)
(b)

5.5 Increasing the Number of Class Variables
157
These maps are ﬁlled using the following equations:
B1 = A1;
B2 = A2 ∨A3;
B3 = A4 ∨A5.
(5.62)
It gives the following equations:
τ1 = A4 ∨A5;
τ2 = A2 ∨A3.
(5.63)
The BIMF1 operates if there is z1 = z2 = 0. So, for z1 = z2 = 0 all am give “don’t
care” values if am ∈A(B1
i ). It explains the signs “*” in the Karnaugh maps from
Fig.5.24.
The following equations can be obtained from (5.63):
τ1 = T2 ∨T3T4;
τ2 = ¯T3T4 ∨T3 ¯T4.
(5.64)
Acting in the same way, the following equations can be obtained:
z1 = T1T2 ∨T1T3T4;
z2 = ¯T1T2T4 ∨¯T1T2T3 ∨T1 ¯T2 ¯T3 ∨T1 ¯T2 ¯T4;
τ3 = T1T3;
τ4 = T1 ¯T3;
τ5 = T2T3;
τ6 = ¯T3T4.
(5.65)
Next, we should choose the equations requiring the most complicated circuits for
implementation with EMBer. For example, if there is S = 2, then the equations for
τ1, z1 and z2 should be implemented by EMBer. If there is S = 3, then it is a must to
implement the equation z2 by EMBer.
In the discussed case, EMBs in use have tF = 12. It means that Δt = 3. Let us
take the functions z1, z2 and τ1 for implementing with EMBer. So, there are 5 of
different tables for LUTs from the BSCT. These tables are constructed in the trivial
way.
There are the following columns in the table of BMO: am, K(am), Y(am), Z(am),
τ(am), m. In the discussed case, it is Table5.15.
We take the microoperations yn ∈Y(am) from Fig.5.22. The state codes are taken
from Fig.5.23. The column Z(am) includes the variables zr ∈Z equal to 1 for the
states am ∈A(Bk
i ). So, there is the value of z1 = 1 for the states am ∈A(B3
i ), the value
of z2 = 1 is for the states am ∈A(B2
i ). It is found due to the codes K(ΠA1) = 00,
K(ΠA2) = 01 and K(ΠA3) = 10. The column τ(am) includes the function τ1 for the
classes Bi ∈ΠA1. In the discussed case it is the class B3 = {a4, a5}.

158
5
Distribution of Class Codes in Moore FSMs
Table 5.15 Table of BMO for Moore FSM P3E3(Γ7)
am
K(am)
Y(am)
Z(am)
τ(am)
m
a1
0000
–
–
–
1
a2
0001
y1y2
–
–
2
a3
0010
y3
–
–
3
a4
0011
y4
–
τ1
4
a5
0100
y2y5
–
τ1
5
a6
0101
y1y4y6
z2
–
6
a7
0110
y3
z2
–
7
a8
0111
y5y7
z2
–
8
a9
1000
y7y8
z2
–
9
a10
1001
y9
z2
–
10
a11
1010
y1y2
z2
–
11
a12
1011
y1y2
z1
–
12
a13
1100
y7y9
z1
–
13
a14
1101
y3
z1
–
14
a15
1110
y4
z1
–
15
a16
1111
y8y9
z1
–
16
Let us point out that two options are possible for each block BIMFk (k = 1, K).
The block’s circuit can be implemented either as LUTer or as EMBer. It gives 2K
different models for each FSM PKEi(i = 1, 3). We do not discuss these models in
our book.
Let us point out that the models PE1–PE6 discussed before have K = 2. It means
that they should correspond to the variable z1 ∈Z. It gives the set Z = {z1}. In the
next Chapter, we use these denotations for above mentioned models.
To diminish the number of LUTs in the circuit of BIMFk (k = {1, 2, . . . , K}), it
is necessary to diminish the number of literals in the functions Φk ⊆Φ. It can be
achieved by the RLC. There are other methods of hardware reduction discussed in
the Chap.6 together with the RLC for PKEi Moore FSMs.
References
1. Altera: http://www.altera.com. Accessed Jan 2015
2. Atmel: http://www.atmel.com. Accessed Jan 2015
3. P. Bacchetta, L. Daldos, D. Sciuto, C. Silvano, Low-power state assignment techniques for
ﬁnite state machines, in Proceedings of the 2000 IEEE International Symposium on Circuits
and Systems (ISCAS’2000), vol. 2, Geneva. IEEE (2000), pp. 641–644
4. S. Baranov, Logic Synthesis of Control Automata (Kluwer Academic Publishers, Dordrecht,
1994)

References
159
5. A. Barkalov, Principles of logic optimization for Moore microprogram automaton. Cybern.
Syst. Anal. 34(1), 54–60 (1998)
6. A. Barkalov, L. Titarenko, S. Chmielewski, Reduction in the number of PAL macrocells int
the circuit of a Moore FSM. Int. J. Appl. Math. Comput. Sci. 17(4), 565–675 (2007)
7. A. Barkalov, L. Titarenko, S. Chmielewski, Decrease of hardware amount in logic circuit of
Moore FSM. Przegla˛d Telekomunikacyjny i Wiadomo´sci Telokomunikacyjne (6), 750–752
(2008)
8. A. Barkalov, L. Titarenko, S. Chmielewski, Optimization of Moore control unit with reﬁned
state encoding, in Proceedings of the 15th International Conference MIXDES 2008, Pozna´n,
Poland. Department of Microelectronics and Computer Science, Technical University of Łódz
(2008), pp. 417–420
9. A. Barkalov, L. Titarenko, S. Chmielewski, Optimization of Moore FSM on system-on-chip
using PAL technology, in Proceedings of the International Conference TCSET 2008, Lviv-
Slavsko, Ukraina. Ministry of Education and Science of Ukraine, Lviv Polytechnic National
University, Lviv, Publishing House of Lviv Polytechnic (2008), pp. 314–317
10. A. Barkalov, L. Titarenko, S. Chmielewski, Hardware reduction in CPLD-based Moore FSM.
J. Circuits, Syst., Comput. 23(6), 1450086–1–1450086–21 (2014)
11. S. Chmielewski, Using structural peculiarities of Moore FSM for reduction of number of PALS.
Ph.D. thesis, University of Zielona Góra (2014)
12. Cypress Semiconductor Corporation: http://www.cypress.com. Accessed Jan 2015
13. Cypress Semiconductor Corporation: Cypress programmable logic: delta 39K. Data sheet,
http://cypress.com/pld/delta39k.html. Accessed Jan 2015
14. R. Czerwinski, D. Kania, Finite State Machine Logic Synthesis for Complex Programmable
Logic Devices. Lecture Notes in Electrical Engineering, vol. 23 (Springer, Berlin, 2013)
15. J. Rho, F. Hatchel, R. Somenzi, R. Jacoby, Exact and heuristic algorithms for the minimization
of incompletely speciﬁed state machines. IEEE Trans. Comput.-Aided Des. 13(2), 167–177
(1994)
16. Xilinx: http://www.xilinx.com. Accessed Jan 2015

Chapter 6
Hardware Reduction in Multidirectional
Moore FSMs
6.1 Hardware Reduction in Two-Directional Moore FSMs
We show in Chap.5 that it could be K of sources of state codes in Moore FSMs. Let
us name such FSMs K-directional Moore FSMs. Let us start from an approach of
hardware reduction for K = 2.
The structural diagram of P2E1 Moore FSM is shown in Fig.6.1. It can be applied
if the condition (5.8) takes place.
If K = 2, then the set ΠA is represented as ΠA1 ∪ΠA2. Using (5.44), we can
ﬁnd RK = 1 and Z = {z1}. Let us encode the sets ΠA1, ΠA2 in the following way:
K(ΠA1) = 0 and K(ΠA2) = 1. If z1 = 0, then the functions Φ1 are transited through
the MX. If z1 = 1, the MX transfers the functions Φ2. So, the functions Φ2(Φ1)
are ignored if there is z1 = 0(z1 = 1). This property can be used for the hardware
reduction.
The proposed approach is based on the optimal state assignment. So, let us denote
as P20E1 FSM the P2E1 FSM based on the proposed method of hardware reduction.
Let us explain this approach using an example of design for Moore FSM P20E1(Γ8).
The GSA Γ8 is shown in Fig.6.2.
Analysis of GSA Γ8 gives the following sets and their cardinality numbers: X =
{x1, ..., x7}, L = 7, Y = {y1, ..., y8}, N = 8, A = {a1, ..., a15}, M1 = 15. Using
(1.14), the value R1 = 4 is obtained. It gives the sets T = {T1, ..., T4} and Φ =
{D1, ..., D4}.
Using the deﬁnition of PES [1], the the following set ΠA is constructed: ΠA =
{B1, ..., B7}.ItincludestheclassesB1 = {a1}, B2 = {a2, a3, a4}, B3 = {a5, a6}, B4 =
{a7, a8}, B5 = {a9, a10}, B6 = {a11, a12, a13} and B7 = {a14, a15}.
Let us represent the set ΠA as ΠA1 ∪ΠA2 where ΠA1 = {B2, B3, B4, B5} and
ΠA2 = {B1, B6, B7}. Let us encode the states am ∈A in a way shown in Fig.6.3.
There is K = 2. It gives RK = 1 and Z = {z1}. Let us encode the directions in the
following way: K(ΠA1) = 0 and K(ΠA2) = 1. If z1 = 0, then the state assignments
are treated as insigniﬁcant for the states am ∈A(B2
i ). It gives the Karnaugh map
shown in Fig.6.4.
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_6
161

162
6
Hardware Reduction in Multidirectional Moore FSMs
BIMF1
BIMF2
X
MX
T
T’
Z
X’
X’’
BMO
2
Y
BSCT
Clock
Start
Fig. 6.1 Structural diagram of P2E1 Moore FSM
It is possible to derive the following class codes from Fig.6.4: K(B2) =
00∗∗, K(B3) = 01∗∗, K(B4) = 11∗∗and K(B5) = 10∗∗. It gives the set
T′ = {T1, T2}.
There are three classes in the set ΠA2. It gives IA2 = 3. Using (5.43), we can ﬁnd
RA2 = 2 and τ2 = {τ1, τ2}. Let us encode the classes Bi ∈ΠA2 as the following:
K(B1) = 00, K(B6) = ∗1 and K(B7) = 1∗. To get the codes of B6, B7 ∈ΠA2, they
use the “don’t care” class assignment 11.
Let us construct the system of GFT for GSA Γ8. It is the following one:
B1 →x1a2 ∨¯x1x2a3 ∨¯x1 ¯x2a4;
B2 →x3a5 ∨¯x3x4a6 ∨¯x3 ¯x4a4;
B3 →x2a7 ∨¯x2a8;
B4 →x5a7 ∨¯x5x6a5 ∨¯x5 ¯x6a10;
B5 →x3x7a11 ∨x3 ¯x7a12 ∨¯x3a13;
B6 →x1a4 ∨¯x1a15;
B7 →x4a14 ∨¯x4a1.
(6.1)
Tables of BIMFk (k = 1, 2) are constructed as we did it before. They include the
following columns: Bi, K(Bi), as, K(as), Xh, Φh, h. The tables use the corresponding
formulae from the system of GFT. There is the table of BIMF1 represented by
Table6.1, whereas the table of BIMF2 by Table6.2. We use the state codes (Fig.6.3)
in these tables.
The table of BIMF1 is used for deriving the system (5.18). Analysis of Table6.1
shows that there are the sets T′ = {T1, T2} and X′ = {x2, ..., x7}. The table of BIMF2
is used for deriving the system (5.19). Analysis of Table6.2 shows that there is the
set X′′ = {x1, x2, x4}. The system (6.2) is derived from Table6.1. The system (6.3)
is derived from Table6.2. Both systems are minimized using the rules of Boolean
algebra [2].

6.1 Hardware Reduction in Two-Directional Moore FSMs
163
Fig. 6.2 Initial GSA Γ8

164
6
Hardware Reduction in Multidirectional Moore FSMs
Fig. 6.3 State codes for
Moore FSM P(Γ8)
Fig. 6.4 Karnaugh map for
A(B1
i )
Table 6.1 Table of BIMF1 for Moore FSM P20E1(Γ8)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B2
00∗∗
a5
0100
x3
D2
1
a6
0101
¯x3x4
D2D4
2
a4
0011
¯x3 ¯x4
D3D4
3
B3
01∗∗
a7
1100
x2
D1D2
4
a8
1101
¯x2
D1D2D4
5
B4
11∗∗
a7
1100
x5
D1D2
6
a9
1000
¯x5x6
D1
7
a10
1001
¯x5 ¯x6
D1D4
8
B5
10∗∗
a11
0111
x3x7
D2D3D4
9
a12
1011
x3 ¯x7
D1D3D4
10
a13
1111
¯x3
D1D2D3D4
11
Table 6.2 Table of BIMF2 for Moore FSM P20E1(Γ8)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
00
a2
0001
x1
D4
1
a3
0010
¯x1x2
D3
2
a4
0011
¯x1 ¯x2
D3D4
3
B3
∗1
a4
0011
x1
D3D4
4
a15
0110
¯x1
D2D3
5
B4
1∗
a14
1010
x4
D1D3
6
a1
0000
¯x4
–
7

6.1 Hardware Reduction in Two-Directional Moore FSMs
165
Table 6.3 Table of BSCT for Moore FSM P20E1(Γ8)
am
K(am)
Z(am)
τ(am)
m
a1
0000
z1
–
1

B1
a1
0000
z1
τ2
11

B6
a1
0000
z1
τ2
12
a1
0000
z1
τ2
13
a1
0000
z1
τ1
14

B7
a1
0000
z1
τ1
15
D1
1 = T2 ∨T1 ¯T2( ¯x3 ∨¯x7);
D1
2 = ¯T1 ¯T2(x3 ∨x4) ∨¯T1T2 ∨T1T2x5 ∨T1 ¯T2 ¯x3;
D1
3 = ¯T1 ¯T2 ¯x3 ¯x4 ∨T1 ¯T2;
D1
4 = ¯T1 ¯T2 ¯x3 ∨¯T1T2 ¯x2 ∨T1T2 ¯x5 ¯x6 ∨T1 ¯T2.
(6.2)
D2
1 = τ1x4;
D2
2 = τ2 ¯x1;
D2
3 = ¯τ1 ¯τ2 ¯x1 ∨τ2 ∨τ1x4;
D2
4 = ¯τ1 ¯τ2(x1 ∨¯x2) ∨τ2x1.
(6.3)
Let it be the conﬁguration 16×8 for EMBs used in this example. There is N = 8.
Using (5.5), it is possible to ﬁnd the value of Δt = 0. So, the model of P20E1 can be
used.
There are the following columns in the table of BSCT: am, K(am), Z(am),
τ(am), m. The table is constructed for the states am ∈A(B2
i ). It is Table6.3 in the
discussed case.
This table is used for deriving the systems Z(T) and τ(T). After minimizing, the
following equations are obtained:
z1 = ¯T1 ¯T2 ¯T3 ¯T4 ∨T2T3 ∨T1T3;
τ1 = T2T3 ¯T4 ∨T1T3 ¯T4;
τ2 = T2T3T4 ∨T1T3T4.
(6.4)
There are the following columns in the table of BMO: am, K(am), Y(am), m. It is
constructed in the trivial way. We do not show it for the discussed example.
Let it be LUTs having S = 6 for the FPGA chip used in the discussed case. In
this case, any equation from (6.2)–(6.4) is implemented as a single LUT. The same
is true to the equations representing MX:
D1 = ¯z1D1
1 ∨z1D2
1;
D2 = ¯z1D1
2 ∨z1D2
2;
D3 = ¯z1D1
3 ∨z1D2
3;
D4 = ¯z1D1
4 ∨¯z1D2
4.
(6.5)

166
6
Hardware Reduction in Multidirectional Moore FSMs
Clock
Start
LUT
4
2
3
5
6
8
9
LUT
2
3
4
5
8
9
LUT
12
20
24
14
15
16
LUT
11
19
23
14
15
16
LUT
10
18
22
14
15
16
LUT
9
17
21
14
15
16
LUT
1
3
7
8
9
LUT
13
8
9
10
11
LUT
14
8
9
10
11
LUT
15
8
9
10
11
LUT
7
1
4
12
13
LUT
8
1
2
12
13
LUT
5
4
12
LUT
6
1
13
LUT
3
3
4
8
9
y4
x4
T4
y5
x5
y6
x6
y7
x7
y8
y3
x3
T3
z1
y2
x2
T2
y1
x1
T1
1
2
EMB
BMO
1
2
3
4
1
2
3
4
5
6
7
8
BIMF1
BIMF2
MX
1
2
z1
T1
D
1
1
D
2
1
D
1
2
D
2
2
D
1
3
D
2
3
D
1
4
D
2
4
T2
T3
T4
14
12
8
21
22
23
24
20
15
14
13
12
10
11
9
8
7
6
5
4
3
2
1
16
19
18
17
9
10
11
13
Fig. 6.5 Logic circuit of Moore FSM P20E1(Γ8)
There is the logic circuit of Moore FSM P20E1(Γ8) shown in Fig.6.5.
The circuit of BIMF1 is implemented by LUT1–LUT4. The circuit of BIMF2 is
implemented by LUT5–LUT8. The circuit of MX is implemented by LUT9–LUT12.
Let us point out that only 3 inputs are required in LUT9–LUT12. But we show that the
pulses Clock and Start are used to control the D ﬂip-ﬂops inside these LUTs. So, the
register RG is hidden inside the LUTs of MX. The circuit of BMO is implemented as
a single EMB. The tables for each LUT can be constructed using the corresponding
equations from the systems (6.2)–(6.5).
Obviously, the functions Z can be implemented by the BIMF2 as
Z = Z(τ).
(6.6)
It leads to P20E2 Moore FSM (Fig.6.6).
Let us point out that it is possible to optimize the circuit of BSCT for P20E1(Γ8).
Obviously, it is correct to treat the states am ∈A(B1
i ) as insigniﬁcant for z1 = 1. It
gives the following Karnaugh map (Fig.6.7).

6.1 Hardware Reduction in Two-Directional Moore FSMs
167
BIMF1
BIMF2
X
MX
T
T’
X’
X’’
BMO
Z
2
Y
BSCT
Clock
Start
Fig. 6.6 Structural diagram of P20E2 Moore FSM
Fig. 6.7 Karnaugh map for
A(B2
i )
T3T4
T1T2
a1
∗
∗
∗
∗
∗
a15
a11
∗
∗
a14
a12
∗
∗
∗
a13
B6
B1
B7
There are the following class codes found from Fig.6.7: K(B1) = ∗∗0∗, K(B6) =
∗∗∗1, K(B7) = ∗∗10. It means that the functions Dr ∈Φ2 can be represented as
Φ2 = Φ2(X′′, T′′).
(6.7)
It leads to P1
20E1 Moore FSM (Fig.6.8).
BIMF1
BIMF2
X
MX
T
T’
Z
X’
X’’
BMO
2
Y
BSCT
Clock
Start
T’’
Fig. 6.8 Structural diagram of P1
20E1 Moore FSM

168
6
Hardware Reduction in Multidirectional Moore FSMs
Table 6.4 Table of BIMF2 for Moore FSM P1
20E1(Γ8)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
∗∗0∗
a2
0001
x1
D4
1
a3
0010
¯x1x2
D3
2
a4
0011
¯x1 ¯x2
D3D4
3
B6
∗∗∗1
a4
0011
x1
D3D4
4
a15
0110
¯x1
D2D3
5
B7
∗∗10
a14
1010
x4
D1D3
6
a1
0000
¯x4
–
7
The BSCT implements only the equation z1(T) for P1
20E1 Moore FSM. There is
the table of BIMF2 for the Moore FSM P1
20E1(Γ8) represented by Table6.4.
The system (6.7) is derived from the table of BIMF2. It is the following system
in the discussed case:
D2
1 = T3 ¯T4x4;
D2
2 = T4 ¯x1;
D2
3 = ¯T3 ¯x1 ∨T3 ∨T3 ¯T4x4;
D2
4 = ¯T3(x1 ∨¯x2) ∨T4x1.
(6.8)
The BSCT should implement the ﬁrst equation of (6.4). Obviously, there are no
LUT14 and LUT15 in the circuit of P1
20E1(Γ8). So, this approach allows saving two
LUTs (and 8 interconnections) in comparison with P20E1(Γ8).
So, there are three models of the two-directional Moore FSMs for the case Δt = 0.
They are the models P20E1, P1
20E1 and P20E2.
Let the following condition take place:
Δt ≥RA2 + 1.
(6.9)
In this case, the model of P20E3 Moore FSM (Fig.6.9) can be used.
BIMF1
BIMF2
X
MX
T
T’
Z
X’
X’’
BMO
2
Y
Clock
Start
Fig. 6.9 Structural diagram of P20E3 Moore FSM

6.1 Hardware Reduction in Two-Directional Moore FSMs
169
BIMF1
BIMF2
X
MX
T
T’
Z
X’
X’’
BMO
2
Y
Clock
Start
Fig. 6.10 Structural diagram of P20E4 Moore FSM
BIMF1
BIMF2
X
MX
T
T’
Z
X’
X’’
BMO
2
Y
Clock
Start
T’’
Fig. 6.11 Structural diagram of P1
20E3 Moore FSM
The function z1 can be implemented by the BIMF2. It leads to P20E4 Moore FSM
(Fig.6.10).
This model should be applied if the following condition takes place:
Δt = RA2.
(6.10)
Obviously, it is possible to use the model of P1
20E3 (Fig.6.11). It can be used if
Δt = 1.
(6.11)
Let the following condition take place:
0 < Δt < RA2 + 1.
(6.12)
In this case, the P20E5 Moore FSM (Fig.6.12) can be used.
Two more models are possible. In case of P1
20E5 FSM, the BMO implements only
the function z1 (Fig.6.13). In case of P20E6 FSM (Fig.6.14), the functions Z are
implemented by BIMF2.

170
6
Hardware Reduction in Multidirectional Moore FSMs
BIMF1
BIMF2
X
MX
T
T’
Z
1
2
X’
X’’
BMO
2
Y
BSCT
Clock
Start
Fig. 6.12 Structural diagram of P20E5 Moore FSM
BIMF1
BIMF2
X
MX
T
T’
z1
X’
X’’
BMO
2
Y
Clock
Start
T’’
Fig. 6.13 Structural diagram of P1
20E5 Moore FSM
BIMF1
BIMF2
X
MX
T
T’
Z
1
2
X’
X’’
BMO
2
Y
BSCT
Clock
Start
Fig. 6.14 Structural diagram of P20E6 Moore FSM
If functions zr ∈Z are implemented as Z(τ), then it is necessary to use one code
K(Bi) for the relation Bi /∈ΠA2. In this case, the formula (5.43) is changed. Now it
is the following formula:
RA2 = ⌈log2(IA2 + 1)⌉.
(6.13)

6.1 Hardware Reduction in Two-Directional Moore FSMs
171
Table 6.5 Characteristics of two-directional Moore FSMs
No
FSM
BIMF1
BIMF2
BSCT
BMO
1
P20E1
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(τ, X′′)
Z = Z(T)
Y = Y(t)
τ = τ(T)
2
P20E2
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(τ, X′′)
τ = τ(T)
Y = Y(t)
Z = Z(τ)
3
P1
20E1
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(T′′, X′′)
Z = Z(T)
Y = Y(t)
4
P20E3
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(τ, X′′)
–
Y = Y(t)
Z = Z(T)
τ = τ(T)
5
P20E4
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(τ, X′′)
–
Y = Y(t)
Z = Z(τ)
τ = τ(T)
6
P1
20E3
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(T′′, X′′)
–
Y = Y(t)
Z = Z(T)
7
P20E5
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(τ, X′′)
Z = Z(T)
Y = Y(t)
τ1 = τ1(T)
τ2 = τ2(T)
8
P20E6
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(τ, X′′)
τ1 = τ1(T)
Y = Y(t)
Z = Z(τ)
τ2 = τ2(T)
9
P1
20E5
Φ1 = Φ1(T′, X′)
Φ2 = Φ2(T′′, X′′)
–
Y = Y(t)
Z = Z(T)
There are 9 different structures of two-directional Moore FSM (Table6.5). Let
us point out that each of these models has 4 modiﬁcations. A modiﬁcation is
determined by the elements used for implementing circuits of BIMF1 and BIMF2:
⟨LUTer, LUTer⟩, ⟨LUTer, EMBer⟩, ⟨EMBer, LUTer⟩and ⟨EMBer, EMBer⟩.
These FSMs are designed in the ways we discussed in this section. Analysis
of Table6.5 shows that the BIMF1 always implements the functions (5.18). The
functions of other blocks depend on the model. The type of the model to be used
depends on the relations between such parameters as Δt and RK.
6.2 Hardware Reduction in 3-Directional Moore FSMs
They can increase the number of directions till the relation (5.46) is true. If there is
S = 6, then it is possible to have K ∈{2, 3, 4}. We discussed the case K = 2 in the
previous section. Now, let us discuss the case when K = 3.
Let us encode the states am ∈A(ΠA1) in the optimal way. In this case, the BIMF1
implements the functions (5.18). It leads to P30E1 Moore FSM (Fig.6.15). This model
is used if the condition (5.8) takes place.

172
6
Hardware Reduction in Multidirectional Moore FSMs
BIMF1
BIMF2
BIMF3
MX
T
T’
Z
2
3
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.15 Structural diagram of P30E1 Moore FSM
There are the following steps in the design method of P30E1 Moore FSM:
1. Constructing the set of states A.
2. Constructing the set ΠA = {B1, ..., BI}.
3. Representing the set ΠA as ΠA1 ∪ΠA2 ∪ΠA3.
4. Executing the optimal state assignment.
5. Executing the encoding of the sets ΠAk ⊂ΠA.
6. Executing the class assignment for Bi ∈ΠA2 ∪ΠA3.
7. Constructing the tables of BIMFk (k = 1, 3).
8. Constructing the table of MX.
9. Constructing the table of BMO.
10. Constructing the table of BSCT.
11. Implementing the FSM logic circuit.
Let us discuss an example of design for P30E1(Γ7). The GSA Γ7 is shown in
Fig.5.22. It includes 16 states divided by IA = 9 classes of PES: B1 = {a1}, B2 =
{a2, a3}, B3 = {a4, a5}, B4 = {a6, a7, a8}, B5 = {a9, a10}, B6 = {a11}, B7 =
{a12, a13}, B8 = {a14} and B9 = {a15, a16}. Let us execute the step 3 of the pro-
posed procedure.
Let us use the following rules for creating the set Π1: 1) it includes 4 of classes
Bi ∈ΠA; 2) each class Bi ∈ΠA1 should include not more than 4 states. Other sets
ΠAk(k = 2, 3) should include approximately the same amount of classes. Using these
rules, the following sets can be found: ΠA1 = {B2, B3, B4, B5}, ΠA2 = {B1, B6, B7}
and ΠA3 = {B8, B9}. Let us encode the states am ∈A as it is shown in Fig.6.16a.
There is the part of a map corresponding to the set ΠA1 ⊂ΠA (Fig.6.16b). There
are the signs “*” for the states am /∈A(B1
i ). The following codes can be found from
the Karnaugh map (Fig.6.16b): K(B2) = ∗∗00, K(B3) = ∗∗01, K(B4) = ∗∗10 and
K(B5) = ∗∗11. So, there is T′ = {T3, T4}.

6.2 Hardware Reduction in 3-Directional Moore FSMs
173
Fig. 6.16 State codes of
FSM P30E1(Γ7) (a) and the
part of codes for ΠA1 (b)
T3T4
T1T2
a1 a11
a14
a12
a2
a4
a6
a9
a15 a16
a8
a13
a3
a5
a7
a10
T3T4
T1T2
∗
∗
∗
∗
a2
a4
a6
a9
∗
∗
a8
∗
a3
a5
a7
a10
(a)
(b)
Table 6.6 Class codes for Moore FSM P30E1(Γ7)
ΠA2
K(Bi)
ΠA3
K(Bi)
τ1τ2
τ3
B1
00
B8
0
B6
∗1
B9
1
B7
1∗
Using (5.44), the value RK = 2 can be found. Let us encode the sets ΠAk :
K(ΠA1) = 00, K(ΠA2) = ∗1 and K(ΠA3) = 1∗. The Karnaugh map (Fig.6.16b)
corresponds to the code K(ΠA1) = 00.
There are Ik2 = 3 and Ik3 = 2. It gives the sets τ2 = {τ1, τ2} and τ3 = {τ3} due
to Rk1 = 2 and Rk2 = 1. Let us encode the classes Bi /∈ΠA1 in the following way
(Table6.6).
There are the same columns in tables of BIMFk (k = 1, 3): Bi, K(Bi), as, K(as),
Xh, Φh, h. These tables are constructed on the base of a system of GFT. It is the
system (5.57) in the discussed case.
The BIMF1 is represented by Table6.7. This table is used to derive the functions
(5.18). The BIMF2 is represented by Table6.8. This table is used for deriving the
system
Φ2 = Φ2(τ2, X2).
(6.14)
Table 6.7 Table of BIMF1 for Moore FSM P30E1(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B2
∗∗00
a4
0101
x2
D2D4
1
a5
1101
¯x2
D1D2D4
2
B3
∗∗01
a6
0110
x3
D2D3
3
a7
1110
¯x3x4
D1D2D3
4
a8
1010
¯x3 ¯x4
D1D3
5
B4
∗∗10
a9
0111
x5
D2D3D4
6
a10
1111
¯x5
D1D2D3D4
7
B5
∗∗11
a11
0001
1
D4
8

174
6
Hardware Reduction in Multidirectional Moore FSMs
Table 6.8 Table of BIMF2 for Moore FSM P30E1(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
00
a2
0101
x1
D2
1
a3
1101
¯x1
D1D2
2
B6
∗1
a12
0111
x6
D3D4
3
a13
1111
¯x6
D1D3D4
4
B7
1∗
a14
0001
1
D3
5
Table 6.9 Table of BIMF3 for Moore FSM P30E1(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B8
0
a15
1000
x7
D1
1
a16
1001
¯x7
D1D4
2
B9
1
a1
0000
x3
–
3
a14
0010
¯x3
D3
4
The BIMF3 is represented by Table6.9. This table is used for deriving the system
Φ3 = Φ3(τ3, X3).
(6.15)
There are the state codes from Fig.6.16 used in those three tables.
There is the system Φ1 represented as (6.16), the system Φ2 as (6.17) and the
system Φ3 as (6.18). There are the corresponding superscripts for functions Dk
r ∈
Φ(k = 1, 3; r = 1, R1) The equations are minimized for all those systems.
D1
1 = ¯T3 ¯T4 ¯x2 ∨¯T3T4 ¯x3 ∨T3 ¯T4 ¯x5;
D1
2 = ¯T4 ∨¯T3T4(x3 ∨x4);
D1
3 = ¯T3T4 ∨T3 ¯T4;
D1
4 = ¯T4 ∨T3T4.
(6.16)
D2
1 = ¯τ1 ¯τ2 ¯x1 ∨τ2 ¯x6;
D2
2 = ¯τ1 ¯τ2;
D2
3 = τ2 ∨τ1;
D2
4 = τ2.
(6.17)
D3
1 = ¯τ3;
D3
2 = 0;
D3
3 = τ3 ¯x3;
D3
4 = ¯τ3 ¯x7.
(6.18)
If LUTs are used for implementing the circuit of BIMFk, then the corresponding
equations of the system Φk are transformed into the tables of LUTs. If EMBs are

6.2 Hardware Reduction in 3-Directional Moore FSMs
175
Table 6.10 Table of MX for Moore FSM P30E1(Γ7)
k
K(ΠAk)
D1
D2
D3
D4
1
00
D1
1
D1
2
D1
3
D1
4
2
∗1
D2
1
D2
2
D2
3
D2
4
3
1∗
D3
1
D3
2
D3
3
D3
4
Table 6.11 Table of BSCT for Moore FSM P30E1(Γ7)
am
K(am)
Bi
K(Bi)
ΠAk
K(ΠAk)
τm
Zm
m
a1
0000
B1
00
ΠA2
01
–
z2
1
a11
0001
B6
01
ΠA2
01
τ2
z2
2
a12
0011
B7
10
ΠA2
01
τ1
z2
3
a13
1011
B7
10
ΠA2
01
τ1
z2
4
a14
0010
B8
0
ΠA3
10
–
z1
5
a15
1000
B9
1
ΠA3
10
τ3
z1
6
a16
1001
B9
1
ΠA3
10
τ3
z1
7
used, then the corresponding table of BIMFk is transformed into the table of EMBerk
(k = 1, 3).
ThereisthetableofMXrepresentedbyTable6.10.Itisusedtoderivetheequations
for LUTs implementing the circuit of MX.
For example, the following equation can be derived from Table6.10:
D1 = ¯z1 ¯z2D1
1 ∨z2D2
1 ∨z1D3
1.
(6.19)
Similar equations can be obtained for each of functions generated by the MX.
ThetableofBMOisconstructedinthewaywehavediscussedbefore.Therearethe
following columns in the table of BSCT: am, K(am), Bi, K(Bi), ΠAk, K(ΠAk), τm,
Zm, m. The meaning of these columns follows from Table6.11.
This table is used to derive the systems τ(T) and Z(T). For example, the following
equations can be derived from Table6.11: τ3 = T1 ¯T2 ¯T3; z1 = ¯T1 ¯T2T3 ¯T4 ∨T1 ¯T2 ¯T3.
Next, the equations can be transformed into tables of corresponding LUTs.
Let us point out, that there are no states am ∈A(B1
i ) in Table6.11. It follows from
the fact that there is K(ΠA1) = 00.
Now let us discuss the structural diagram of P1
30E1 Moore FSM (Fig.6.17). As
follows from Fig.6.16, the functions τr ∈τ are necessary only for the BIMF3. The
functions Dr ∈Φ2 are represented by the system:
Φ2 = Φ2(T′′, X2).
(6.20)
Let us construct the Karnaugh map (Fig.6.18) for the states am ∈A(B2
i ). It is
constructed on the base of the Karnaugh map (Fig.6.16) for the FSM P30E1(Γ7).

176
6
Hardware Reduction in Multidirectional Moore FSMs
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
Z
3
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.17 Structural diagram of P1
30E1 Moore FSM
Fig. 6.18 State codes for
ΠA2
T3T4
T1T2
a1 a11
∗
a12
∗
∗
∗
∗
∗
∗
∗
a13
∗
∗
∗
∗
The analysis of this Karnaugh map gives the following codes: K(B1) = ∗∗∗0,
K(B6) = ∗∗01 and K(B7) = ∗∗1∗. So, there is T′′ = {T3, T4}. Each class Bi ∈ΠA2
is represented by a single interval of 4-dimensional Boolean space. So, it is possible
to use the model of P1
30E1 Moore FSM in the case of GSA Γ7.
There is no change for tables of BIMF1, BIMF3, MX and BMO in the case of
P1
30E1 FSM in comparison with the equivalent P30E1 FSM. In the discussed case, the
BIMF2 is represented by Table6.12, whereas the BSCT by Table6.13.
The table of BIMF2 is used to derive the system (6.20). It is the following system
in the discussed case:
Table 6.12 Table of BIMF2 for Moore FSM P1
30E1(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
∗∗∗0
a2
0100
x1
D1
1
a3
1100
¯x1
D1D4
2
B6
∗∗01
a12
0011
x6
–
3
a13
1011
¯x6
D3
4
B7
∗∗1∗
a14
0010
1
D3
4

6.2 Hardware Reduction in 3-Directional Moore FSMs
177
Table 6.13 Table of BSCT for Moore FSM P1
30E1(Γ7)
am
K(am)
Bi
K(Bi)
ΠAk
K(ΠAk)
τm
Zm
m
a1
0000
B1
∗∗∗0
ΠA2
01
–
z2
1
a11
0001
B6
∗∗01
ΠA2
01
–
z2
2
a12
0011
B7
∗∗1∗
ΠA2
01
–
z2
3
a13
1011
B7
∗∗1∗
ΠA2
01
–
z2
4
a14
0010
B8
0
ΠA3
10
–
z1
5
a15
1000
B9
1
ΠA3
10
τ3
z1
6
a16
1001
B9
1
ΠA3
10
τ3
z1
7
D2
1 = ¯T4 ¯x1 ∨¯T3T4 ¯x6;
D2
2 = ¯T4;
D2
3 = T3 ∨T4;
D2
4 = ¯T3T4.
(6.21)
As follows from Table6.13, there is the set τ3 = {τ1}. The following equations
can be derived from Table6.13:
τ1 = T1 ¯T2 ¯T3;
z1 = ¯T1 ¯T2T3 ¯T4 ∨T1 ¯T2 ¯T3;
z2 = ¯T1 ¯T2 ¯T3 ∨¯T2T3T4.
(6.22)
Next, let us discuss the structural diagram of P2
30E1 Moore FSM (Fig.6.19). In
this case, the BSCT generates only the functions Z = Z(T). There is no need in
functions τr ∈τ.
In this case, the BIMF3 implements the system
Φ3 = Φ3(T′′′, X3).
(6.23)
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
T’’’
Z
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.19 Structural diagram of P2
30E1 Moore FSM

178
6
Hardware Reduction in Multidirectional Moore FSMs
Fig. 6.20 State codes for
ΠA3
Table 6.14 Table of BIMF3 for Moore FSM P2
30E1(Γ7)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B8
∗∗1∗
a15
1000
x7
D1
1
a16
1001
¯x7
D1D4
2
B9
∗∗0∗
a1
0000
x3
–
3
a13
0010
¯x3
D3
4
The BIMF1 implements the functions (5.18), the BIMF2 the functions (6.7).
Let us analyse the Karnaugh map (Fig.6.20). It corresponds to the set ΠA3 of the
Moore FSM P30E1(Γ7).
The following codes can be found from this Karnaugh map: K(B8) = ∗∗1∗and
K(B9) = ∗∗0∗. Now,there is the following table of BIMF3 (Table6.14).
There is the following system (6.23) derived from Table6.14:
D3
1 = T3;
D3
2 = 0;
D3
3 = ¯T3 ¯x3;
D3
4 = ¯T3x7.
(6.24)
The BIMF1 is represented by the system (6.16), the BIMF2 by the system (6.21).
There is τ = ∅for P2
30E1 Moore FSMs. So, the BSCT is represented by Table6.15
in the discussed case.
Table 6.15 Table of BSCT for Moore FSM P2
30E1(Γ7)
am
K(am)
ΠAk
K(ΠAk)
Zm
m
a1
0000
ΠA2
01
z2
1
a11
0001
ΠA2
01
z2
2
a12
0011
ΠA2
01
z2
3
a13
1011
ΠA2
01
z2
4
a14
0010
ΠA3
10
z1
5
a15
1000
ΠA3
10
z1
6
a16
1001
ΠA3
10
z1
7

6.2 Hardware Reduction in 3-Directional Moore FSMs
179
BIMF1
BIMF2
BIMF3
MX
T
T’
Z
2
3
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
Z2
Z1
3
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
(a)
(b)
Fig. 6.21 Structural diagram of P20E1 (a) and P30E3 (b) Moore FSM
There are the same equations for z1, z2 ∈Z as they are in system (6.22).
AnalysisofTable6.14showsthatitispossibletodistributethefunctionsz1, z2 ∈Z
between the BIMF2 and BIMF3. It can be done for P30E1 Moore FSM. It is possible
to implement the functions z1 by the BIMF3 in the case of P1
30E1 Moore FSM. To do
it, the code should be added to indicate that Bi /∈ΠA2 and Bi /∈ΠA3. In the case of
P2
30E1 FSM, the functions Z can be implemented only by BSCT. So, two additional
models are possible for the 3-directional Moore FSM with Δt = 0. They are shown
in Fig.6.21.
So, there are ﬁve different models of Moore FSM with K = 3 for Δt = 0. Their
characteristics are shown in Table6.16.
Let us point out that the BIMF1 always executes the functions (5.18), whereas
the BMO the functions (1.5). Due to it, we do not show these blocks in Table6.16.
Now let us discuss the case when
Δt ̸= 0.
(6.25)

180
6
Hardware Reduction in Multidirectional Moore FSMs
Table 6.16 Characteristics of 3-directional Moore FSMs (Δt = 0)
No
FSM
BIMF2
BIMF3
BSCT
1
P30E1
Φ2 = Φ2(T2, X2)
Φ3 = Φ3(τ3, X3)
Z = Z(T)
τ2 = τ2(T)
τ3 = τ3(T)
2
P1
30E2
Φ2 = Φ2(T′′, X2)
Φ3 = Φ3(τ3, X3)
Z = Z(T)
τ3 = τ3(T)
3
P2
30E1
Φ2 = Φ2(T′′, X2)
Φ3 = Φ3(T′′′, X3)
Z = Z(T)
4
P30E2
Φ2 = Φ2(τ2, X2)
Φ3 = Φ3(τ3, X3)
τ2 = τ2(T)
z2 = z2(τ2)
z1 = z1(τ3)
τ3 = τ3(T)
5
P30E3
Φ2 = Φ2(T′′, X2)
Φ3 = Φ3(τ3, X3)
τ3 = τ3(T)
z1 = z1(τ3)
z2 = z2(T)
In this case, the BMO can execute a part of functions executed by the BSCT (or even
all of them).
Let the states am ∈A be encoded in the way when the model P30E1 can be used.
Let the following condition take place:
Δt = RA2 + RA3 + RK.
(6.26)
In this case, the BMO can implement the functions zr ∈Z and τr ∈τ2 ∪τ3. It
leads to P30E4 Moore FSM shown in Fig.6.22.
Let the following condition take place:
Δt = RA2 + RA3.
(6.27)
BIMF1
BIMF2
BIMF3
MX
T
T’
Z
2
3
X
1
X
2
X
3
BMO
2
3
Y
Clock
Start
Fig. 6.22 Structural diagram of P30E4 Moore FSM

6.2 Hardware Reduction in 3-Directional Moore FSMs
181
BIMF1
BIMF2
BIMF3
MX
T
T’
Z
2
3
X
1
X
2
X
3
BMO
2
3
Y
Clock
Start
Fig. 6.23 Structural diagram of P30E5 Moore FSM
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
Z
3
X
1
X
2
X
3
BMO
2
3
Y
Clock
Start
Fig. 6.24 Structural diagram of P1
30E4 Moore FSM
In this case, the functions zr ∈Z can be implemented by the BIMF2 and BIMF3. It
leads to P30E5 Moore FSM (Fig.6.23).
Let it be possible to use the model P1
30E1 Moore FSM. Let the following condition
take place:
Δt = RA3 + RK.
(6.28)
In this case, the BMO implements the functions zr ∈Z and τr ∈τ3. It leads to P1
30E4
Moore FSM (Fig.6.24).
Let the following condition take place:
Δt = RA3 + 1.
(6.29)
In this case, the function z1 ∈Z is implemented by the BIMF3. The BMO implements
the functions z2 ∈Z and τ3. It results in P30E6 Moore FSM (Fig.6.25).

182
6
Hardware Reduction in Multidirectional Moore FSMs
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
z2
z1
3
X
1
X
2
X
3
BMO
2
3
Y
Clock
Start
Fig. 6.25 Structural diagram of P30E6 Moore FSM
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
T’’’
Z
X
1
X
2
X
3
BMO
2
3
Y
Clock
Start
Fig. 6.26 Structural diagram of P2
30E4 Moore FSM
Let it be possible to use the model of P2
30E1 Moore FSM. Let the following
condition take place:
Δt = RK.
(6.30)
In this case, the BMO implements the functions zr ∈Z. It leads to P2
30E4 Moore
FSM (Fig.6.26).
So, there are ﬁve models of 3-directional Moore FSMs which do not use the
BSCT. Its functions are executed by the BMO. Table6.17 shows those models. As
for Table6.16, there are the same functions of BIMF1 as they are in Table6.17. Also,
there is no column “BSCT” because this block is not used for those ﬁve models. The
column “Cond.” contains the number of a formula showing the condition for using
a given model.
Comparison of Tables6.16 and 6.17 shows that there are the same functions of
blocks for P30Ei and P30E(i+3), where i ∈{1, 2, 3}. So, the same methods are used for
implementing the corresponding pairs of models ⟨P30E1, P30E4⟩, ⟨P1
30E1, P1
30E4⟩, ...,

6.2 Hardware Reduction in 3-Directional Moore FSMs
183
Table 6.17 Characteristics of 3-directional Moore FSMs without BSCT
No
FSM
BIMF2
BIMF3
BSCT
Cond.
1
P30E4
Φ2 = Φ2(T2, X2)
Φ3 = Φ3(τ3, X3)
Y = Y(T)
6.26
Z = Z(T)
τ2 = τ2(T)
τ3 = τ3(T)
2
P1
30E4
Φ2 = Φ2(T′′, X2)
Φ3 = Φ3(τ3, X3)
Y = Y(T)
6.27
Z = Z(T)
τ3 = τ3(T)
3
P2
30E4
Φ2 = Φ2(T′′, X2)
Φ3 = Φ3(T′′′, X3)
Y = Y(T)
6.28
Z = Z(T)
4
P30E5
Φ2 = Φ2(τ2, X2)
Φ3 = Φ3(τ3, X3)
Y = Y(T)
6.29
z2 = z2(τ2)
z1 = z1(τ3)
τ2 = τ2(T)
τ3 = τ3(T)
5
P30E6
Φ2 = Φ2(T′′, X2)
Φ3 = Φ3(τ3, X3)
Y = Y(T)
6.30
z1 = z1(τ3)
τ3 = τ3(T)
z2 = z2(T)
⟨P30E3, P30E6⟩. There is the only difference: the functions of BSCT are executed by
BMO. So, there are different tables of BMO for the corresponding pairs of models.
In the case of models from Table6.16, the table of BMO contains only the columns
K(am), Y(am), m. In the case of models from Table6.17, the columns Z(am), τ2(am)
or τ3(am) can be added.
Now, let us discuss the case when the BMO can implement only some part of
BSCT’s functions. It is possible if the condition (6.25) is true.
Let it be possible to use the model P30E1. Let the following condition take place:
RA2 + RA3 = Δt.
(6.31)
It leads to P30E7 Moore FSM (Fig.6.27).
In the case of P30E7 FSM, the BSCT implements the functions zr ∈Z, whereas
the functions τ2, τ3 ∈τ are generated by the BMO.
Let it be possible to use the model of P1
30E1 Moore FSM. Let the following
condition take place:
RA3 = Δt.
(6.32)
It leads to the P1
30E7 Moore FSM (Fig.6.28).
Let it be possible to use the model of P2
30E1 Moore FSM. Let the following
condition take place:
Δt = 1.
(6.33)

184
6
Hardware Reduction in Multidirectional Moore FSMs
BIMF1
BIMF2
BIMF3
MX
T
T’
Z
3
2
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.27 Structural diagram of P30E7 Moore FSM
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
Z
3
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.28 Structural diagram of P1
30E7 Moore FSM
In this case, the functions zr ∈Z are distributed between the BMO and BSCT. It
leads to P2
30E7 Moore FSM (Fig.6.29).
It is possible to use the model of P30E8 Moore FSM (Fig.6.30).
It is possible to use the model of P30E9 Moore FSM (Fig.6.31).
Let us point out that these models correspond to the following conditions, respec-
tively:
Δt = RK2.
(6.34)
Δt = RK3.
(6.35)
These models correspond to some extreme conditions. It is quite possible that
functions τ are distributed between the BMO and BSCT for P30E7. The same is
true for functions Z. So, there are many modiﬁcations of the basic models shown in
Figs.6.27, 6.28, 6.29, 6.30, and 6.31. The number of these models is determined by
the values of RA2, RA3 and RK. So, their number can be different for each GSA Γ .

6.2 Hardware Reduction in 3-Directional Moore FSMs
185
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
T’’’
z1
z2
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.29 Structural diagram of P2
30E7 Moore FSM
BIMF1
BIMF2
BIMF3
MX
T
T’
z1
z2
2
3
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.30 Structural diagram of P30E8 Moore FSM
BIMF1
BIMF2
BIMF3
MX
T
T’
T’’
z2
z1
3
X
1
X
2
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.31 Structural diagram of P30E9 Moore FSM

186
6
Hardware Reduction in Multidirectional Moore FSMs
Let us point out that it is possible to use either LUTs or EMBs for implementing the
circuits of BIMF1–BIMF3. It gives 8 different implementations for each of discussed
models. For example, Table6.16 determines 40 different circuits. The same is true
for Table6.17.
There are the following positive features of the proposed models. There is less
amount of literals in the partial SOPs for functions Dk
r then for the function Dr(k =
1, k; r = 1, R1).
Each function Dk
r depends on less amount of state variables than it is for P0 Moore
FSMs. Each function Dk
r depends on less amount of class variables than it is for PE
Moore FSMs. So, it allows to get the circuit of Moore FSM having less hardware
than it is for equivalent P0 or PE FSMs.
But there is a rapid growth for the number of possible solutions with the increas-
ing for the number of directions, K. It results in complex algorithms of: 1) state
assignment and 2) distribution of classes Bi ∈ΠA among the sets ΠAk(k = 1, K).
Both problems are NP-complex [3]. It means that it is necessary to work out heuristic
algorithms for solution of above mentioned problems.
We do not discuss the Moore FSMs with K > 3. The corresponding models are
developed using the same approach as the one used for K = 2 and K = 3.
6.3 Replacement of Logical Conditions for K-Directional
Moore FSMs
It is possible to reduce the hardware amount in circuits of BIMFk (k = 1, K) due to
using the method of RLC. It has sense to use the RLC if there is saving of LUTs in
the particular block in comparison with its implementing without the RLC.
Let us, for example, discuss the structural diagram of M3P1
30E1 Moore FSM
(Fig.6.32). There are three blocks BRLCk in this FSM. It is shown by the sub-
script 3 in M3. The block BRLCk implements the system of additional variables Pk
used for the replacement of logical conditions xe ∈X. So, the set P is represented as
BIMF1
BRLC1
BIMF2
BRLC2
BIMF3
BRLC3
MX
T
T’
T’
T’’
T’’
Z
3
P
1
X
1
P
2
X
2
P
3
X
3
BMO
2
3
Y
BSCT
Clock
Start
Fig. 6.32 Structural diagram of M3P1
30E1 Moore FSM

6.3 Replacement of Logical Conditions for K-Directional Moore FSMs
187
P =
K

k=1
Pk.
(6.36)
In M3P1
30E1 Moore FSM, the blocks BRLCk and BIMFk execute the following
functions, respectively:
P1 = P1(T′, X1);
(6.37)
P2 = P2(T′′, X2);
(6.38)
P3 = P3(τ3, X3);
(6.39)
Φ1 = Φ1(T′, P1);
(6.40)
Φ2 = Φ2(T′′, P2);
(6.41)
Φ3 = Φ3(τ3, P3).
(6.42)
The blocks BSCT, MX and BMO execute the same functions as in P1
30E1 Moore
FSM.
There are the following steps in the design method for M3P1
30E1 Moore FSMs:
1. Constructing the set of states A = {a1, ..., aM1}.
2. Constructing the set ΠA = {B1, ..., BI}.
3. Distribution the classes Bi ∈ΠA among the sets ΠAk.
4. Executing the optimal state assignment.
5. Executing the encoding of the sets ΠAk ∈ΠA.
6. Executing the class assignment for Bi ∈ΠAk.
7. Finding the sets Pk for classes Bi ∈ΠAk.
8. Constructing the tables of BRLCk.
9. Constructing the tables of BIMFk.
10. Constructing the table of BMO.
11. Constructing the table of MX.
12. Constructing the table of BSCT.
13. Implementing the FSM logic circuit.
Let us discuss an example of design for M3P1
30E1(Γ7). The GSA Γ7 is shown
in Fig.5.22. It includes M1 = 16 states distributed among IA = 9 classes of PES.
There are the following classes: B1 = {a1}, B2 = {a2, a3}, B3 = {a4, a5}, B4 =
{a6, a7, a8}, B5 = {a9, a10}, B6 = {a11}, B7 = {a12, a13}, B8 = {114} and B9 =
{a15, a16}. The steps 1–6 are already executed in the previous sections. There are
the optimal state codes shown in Fig.6.16. There are the following sets ΠAk ⊂Π :
ΠA1 = {B2, B3, B4, B5}, ΠA2 = {B1, B6, B7} and ΠA3 = {B8, B9}. They have the
codes K(ΠA1) = 00, K(ΠA2) = 01 and K(ΠA3) = 10. The classes Bi ∈ΠA3
are encoded as the following ones: K(B8) = 0 and K(B9) = 1. There are the sets
Z = {z1, z2} and τ3 = {τ1}.

188
6
Hardware Reduction in Multidirectional Moore FSMs
Table 6.18 Table of BRLC1 for Moore FSM M3P1
30E1(Γ7)
Pg
Bi
B2
B3
B4
B5
p1
x2
x3
–
–
p2
–
x4
x5
–
K(Bi)
∗∗00
∗∗01
∗∗10
∗∗11
Table 6.19 Table of BRLC2 for Moore FSM M3P1
30E1(Γ7)
Pg
Bi
B1
B6
B7
p3
x1
x6
–
K(Bi)
∗∗∗0
∗∗01
∗∗1∗
Table 6.20 Table of BRLC3 for Moore FSM M3P1
30E1(Γ7)
Pg
Bi
B8
B9
p4
x7
x3
K(Bi)
0
1
Let us analyse the system of GFT (5.57). It allows ﬁnding the sets Pk : P1 =
{p1, p2} used for replacing xe ∈X′ = {x2, ..., x5}; P2 = {p3} used for replacing the
logical conditions xe ∈X2 = {x1, x6}; P3 = {p4} used for replacing the logical con-
ditions from the set X3 = {x3, x7}. Let us construct the tables of BRLCk (Tables6.18,
6.19, and 6.20).
We take the class codes from Table6.7 to use them into Table6.18. The codes
from Table6.12 are used in Table6.19. The class codes Bi ∈ΠA3 are taken from
Table6.8 and used in Table6.20.
These tables are used to derive the equations for systems (6.37)–(6.39). There are
the following equations:
p1 = ¯T4x2 ∨T4x3;
p2 = ¯T3x4 ∨T3x5;
p3 = ¯T4x1 ∨¯T3T4x6;
p4 = ¯τ1x7 ∨τ1x3.
(6.43)
The equations (6.43) are used to implement the circuits of BRLC1–BRLC3 in the
discussed case.
The tables of BIMFk are constructed on the base of Tables6.7, 6.12 and 6.9 for
k = 1, 2, 3 correspondingly. They are the Tables6.21, 6.22, and 6.23.
The following systems of equations can be derived from Tables6.21, 6.22, and
6.23:

6.3 Replacement of Logical Conditions for K-Directional Moore FSMs
189
Table 6.21 Table of BIMF1 for Moore FSM M3P1
30E1(Γ7)
am
K(am)
as
K(as)
Ph
Φh
h
B2
∗∗00
a4
0101
p1
D2D4
1
a5
1101
¯p1
D1D2D4
2
B3
∗∗01
a6
0110
p1
D2D3
3
a7
1101
¯p1p2
D1D2D3
4
a8
1010
¯p1 ¯p2
D1D3
5
B4
∗∗10
a9
0111
p2
D2D3D4
6
a10
1111
¯p2
D1D2D3D4
7
B5
∗∗11
a11
0001
1
1
8
Table 6.22 Table of BIMF2 for Moore FSM M3P1
30E1(Γ7)
am
K(am)
as
K(as)
Ph
Φh
h
B1
∗∗∗0
a2
0100
p3
D2
1
a3
1100
¯p3
D1D2
2
B6
∗∗01
a12
0011
p3
D3D4
3
a13
1011
¯p3
D1D3D4
4
B7
∗∗1∗
a14
0010
1
D3
5
Table 6.23 Table of BIMF3 for Moore FSM M3P1
30E1(Γ7)
am
K(am)
as
K(as)
Ph
Φh
h
B8
0
a15
1000
p4
D1
1
a15
1001
¯p4
D1D4
2
B9
1
a1
0000
p4
–
3
a14
0010
¯p4
D3
4
D1
1 = ¯T3 ∨T3T4 ¯p2;
D1
2 = ¯T3 ∨T3 ¯T4;
D1
3 = ¯T3T4 ∨T3 ¯T4;
D1
4 = ¯T4.
(6.44)
D2
1 = ¯T4 ¯P3 ∨¯T3T4 ∨t3;
D2
2 = ¯T4;
D2
3 = ¯T3T4 ∨T3;
D2
4 = ¯T3T4.
(6.45)
D2
1 = ¯τ1;
D2
2 = 0;
D2
3 = τ1p4;
D2
4 = ¯τ1 ¯p4.
(6.46)

190
6
Hardware Reduction in Multidirectional Moore FSMs
BIMF1
BIMF3
BIMF2
MX
T
P1
P2
T3
T3
T3
T4
T4
T4
Z
z1
z2
3
1
x3
x1
x2x3x4x5
x7
x6
BMO
2
Y
3
BSCT
Clock
Start
BRCL
1
Fig. 6.33 Structural diagram of M1P1
30E1(Γ7) Moore FSM
Table 6.24 Table of BMO
for Moore FSM M3P1
30E1(Γ7)
am
K(am)
Y(am)
a1
0000
–
a2
0100
y1y2
a3
1100
y3
a4
0101
y4
a5
1101
y2y5
a6
0110
y1y4y6
a7
1110
y3
a8
1010
y5y7
a9
0111
y7y8
a10
1111
y9
a11
0001
y1y2
a12
0011
y1y2
a13
1011
y7y9
a14
0010
y3
a15
1000
y4
a16
1001
y8y9
Comparison of systems (6.16) and (6.44) shows that the equations of (6.4) are
much simpler. So, there is sense to use the BRLC1. Comparison of (6.21) and (6.45)
shows that there is no saving. So, there is no sense in using the BRLC2. The same is
true for the BRLC3. So, it is better to use the model M1P1
30E1(Γ7) shown in Fig.6.33.
The MX is represented by Table6.10. The BSCT is represented by Table6.13.
The table of BMO is constructed in the usual way. It is Table6.24 in the discussed
case.

6.3 Replacement of Logical Conditions for K-Directional Moore FSMs
191
Using this approach, it is possible to develop the design method for any model of
Moore FSM with RLC. Let us point out that it is possible to add up to K blocks of
BRLC in any K-directional model. It leads to increasing for the number of possible
solutions and makes more difﬁcult the problem of the choice of the best model for a
given GSA Γ and a given chip of FPGA.
References
1. A. Barkalov, Principles of logic optimization for Moore microprogram automaton. Cybernetics
and System Analysis 34(1), 54–60 (1998)
2. E. McCluskey, Logic Design Principles (Prentice Hall, Englewood Cliffs, 1986)
3. G. De Micheli, Synthesis and Optimization of Digital Circuits (McGraw–Hill, 1994)

Chapter 7
Design of EMB-Based Mealy FSMs
7.1 Trivial Implementing Mealy FSMs
Let us remind some basic information about FPGAs. A as it is shown before, the
majority of FPGAs include three main blocks: look-up table (LUT) elements con-
nected with programmable ﬂip-ﬂops, embedded memory blocks (EMB), and a matrix
of programmable interconnections [1, 2]. One LUT together with a ﬂip-ﬂop forms
a logic element (LE), two LEs form a slice, two slices form a conﬁgurable logic
block (CLB). The fast interconnections are used inside a CLB [3], but it is a very
rear situation when only one CLB is enough for implementing an FSM logic circuit.
The ﬂip-ﬂop of LE can be bypassed, so the output of LUT can be either registered
or combinational. As a rule, the number of LUT’s inputs is rather small (S ≤6) [3,
4]. If the number of arguments of a Boolean function exceeds the number of LUT’s
inputs, then more than one LUT is necessary to implement the corresponding combi-
national circuit. In this case, the methods of functional decomposition are used [5–7].
It leads to increasing for the number of layers of logic in a resulting circuit and to
complication for interconnections. In turn, it results in increasing for the propagation
time and power consumption [8, 9]. To improve the parameters of an FSM circuit,
the EMBs should be used for implementing some parts of a circuit [10–14].
As it is mentioned before, the EMBs of up-to-day FPGAs have a property of
conﬁgurability. It means that such parameters as the number of cells and their outputs
can be changed [1, 2]. Typical conﬁgurations of modern EMBs are the following:
16K × 1, 8K × 2, 4K × 4, 2K × 8, 1K × 18, 512 × 36 (bits) [1, 2].
So, the modern EMBs are very ﬂexible and can be tuned to meet a particular
design project. Let an EMB contain V cells and tF outputs. Let V0 be a number of
cells if there is tF = 1. The number V can be determined as (2.1).
Let us discuss a case when a single EMB is enough for implementing an FSM’s
logic circuit. Let the following condition take place:
2L+R0 · (R0 + N) ≤V0.
(7.1)
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_7
193

194
7
Design of EMB-Based Mealy FSMs
Fig. 7.1 Structural diagram
of EMB-based P Mealy FSM
Y
RG
T
X
Start
Clock
EMB
In this case a Mealy FSM can be implemented in a trivial way [15] using one
EMB and R of ﬂip-ﬂops forming the register (Fig.7.1). Obviously, it is EMB-based
P Mealy FSM.
In P Mealy FSM, the EMB implements the functions (1.3)–(1.4). If an EMB is a
synchronous one, then there is no need in the RG.
Let us discuss an example of design for EMB-based Mealy FSM P(Γ9). The GSA
Γ9 is shown in Fig.7.2. The following sets and their parameters can be derived from
Fig.7.2: A = {a1, a2}, M = 2, X = {x1, x2}, L = 2, Y = {y1, . . . , y4}, N = 4,
Ro = 1, T = {T1} and Φ = {D1}.
It is enough a single EMB having SA = 3 and tF ≥5 to implement the circuit of
P(Γ9). There are the same steps in the design of EMB-based P FSM as it is in [16].
But the step of the transformation of initial ST is added [17].
Let us encode the states of P(Γ9) in the following way K(a1) = 0, K(a2) = 1.
Now it is possible to construct the ST (Table7.1). It includes H0 = 5 rows.
Let us transform Table7.1 and construct the table of EMB (Table7.2). The number
of cells of EMB is determined by (3.17).
Fig. 7.2 Graph-scheme of
algorithm Γ9
End
Start
a1
a2
1
0
x1
y1y2
1
0
x1
a1
y2y4
y3
1
0
x2

7.1 Trivial Implementing Mealy FSMs
195
Table 7.1 Structure table of Mealy FSM P(Γ9)
am
K(am)
as
K(as)
Xh
Yh
Φh
h
a1
0
a2
1
x1
y1y2
D1
1
a2
1
¯x1
y3
D1
2
a2
1
a1
0
x1
y2y4
–
3
a1
0
¯x1x2
–
–
4
a2
1
¯x1¯x2
y3
D1
5
Table 7.2 Table of EMB for
Mealy FSM P(Γ9)
K(am)
X
Y
Φ
v
T1
x1x2
y1y2y3y4
D1
0
00
0010
1
1
0
01
0010
1
2
0
10
1100
1
3
0
11
1100
1
4
1
00
0010
1
5
1
01
0000
0
6
1
10
0101
0
7
1
11
0101
0
8
We have discussed similar tables in previous chapters. Let us point out that the
number of transitions for each state am ∈A is determined as (3.18).
There is a functional circuit of P(Γ9) shown in Fig.7.3. The LUT1 is used as D
ﬂip-ﬂop. So, it is controlled by the pulses Start and Clock.
This solution leads to circuits with the highest performance. But the area of its
practical application is limited [17]. It can be applied for rather simple GSAs.
We use standard benchmarks [18] to investigate different design methods dis-
cussed in this chapter This library includes 53 benchmarks taken from the practice of
FSM design. There are characteristics of benchmarks shown in Table7.3. It includes
characteristics of Mealy and Moore FSMs.
Fig. 7.3
Logic circuit of
Mealy FSM P(Γ9)
EMB
1
2
3
1
2
3
4
5
y1
y2
y3
y4
LUT1
T1
x1
x2
Start
Clock
D1

196
7
Design of EMB-Based Mealy FSMs
Table 7.3 Characteristics of benchmarks
No
Name
L
N
M0
H0
M1
H1
1
bbara
4
2
10
60
12
72
2
bbsse
7
7
16
56
26
104
3
bbtas
2
2
6
24
9
36
4
bbcount
3
4
7
28
10
40
5
cse
7
7
16
91
32
183
6
dk14
3
5
7
56
26
208
7
dk15
3
5
4
32
17
136
8
dk16
2
3
27
108
75
300
9
dk17
2
3
8
32
16
64
10
dk27
1
2
7
14
10
20
11
dk512
1
3
15
30
24
48
12
donﬁle
2
1
24
96
24
98
13
ex1
9
19
20
138
80
634
14
ex2
2
2
19
72
25
92
15
ex3
2
2
10
36
14
44
16
ex4
6
9
14
21
18
28
17
ex5
2
2
9
32
16
52
18
ex6
5
8
8
34
14
61
19
ex7
2
2
10
36
17
56
20
keyb
7
2
19
170
22
193
21
kirkman
12
6
16
328
138
3951
22
lion
2
1
4
11
5
14
23
lion9
2
1
9
25
11
31
24
mark1
5
16
15
36
22
50
25
mc
3
5
4
10
8
20
26
modulo12
1
1
12
24
12
24
27
opus
5
6
10
30
10
30
28
planet
7
19
48
115
103
248
29
planet1
7
19
48
115
103
248
30
pma
8
8
24
73
49
132
31
s1
8
6
20
107
20
107
32
s1488
8
19
48
251
168
912
33
s1494
8
19
48
250
168
1030
34
s1a
8
6
20
107
20
107
35
s208
11
2
18
153
37
309
36
s27
4
1
6
34
6
34
37
s298
3
6
218
1096
332
1669
38
s386
7
7
13
64
23
127
(continued)

7.1 Trivial Implementing Mealy FSMs
197
Table 7.3 (continued)
No
Name
L
N
M0
H0
M1
H1
39
s420
19
2
18
137
37
282
40
s510
19
7
47
77
73
113
41
s8
4
1
5
20
5
20
42
s820
18
19
25
232
70
613
43
s832
18
19
25
245
70
707
44
sand
11
9
32
184
88
654
45
scf
27
56
121
286
141
330
46
shifreg
1
1
8
16
16
32
47
sse
7
7
16
56
26
104
48
styr
9
10
30
166
57
366
49
tav
4
4
4
49
27
322
50
tbk
6
3
32
1568
60
2940
51
tma
7
6
20
44
20
44
52
train11
2
1
11
25
14
34
53
train4
2
1
4
14
6
21
There are the most important characteristics of FSMs shown in Table7.3. It
includes the numbers of logical conditions (L), microoperations (N), states of Mealy
FSMs (M0), transitions of Mealy FSMs (H0), states of Moore FSMs (M1) and tran-
sitions of Moore FSMs (H1).
To investigate different design methods, it is necessary to choose some chips for
implementing the circuits. Let us use the XC5VLX30 chip of Virtex-5 by Xilinx as a
base for investigations [19]. This chip includes 32 blocks of RAM (BRAM) having
the following conﬁgurations: 36K × 1, 18K × 2, 9K × 4, 4K × 9, 2K × 18, 1K
× 36, 512 × 72 (bits).
There are some results of investigations for some of benchmarks. All tables are
organized in the same way. The ﬁrst column of these tables contains the name of
a benchmark, the next three columns contain numbers of slices, slice ﬂip-ﬂops and
LUTs, respectively. The last column includes the number of EMBs required for
implementing the corresponding logic circuit.
There are the characteristics of P FSMs shown in Table7.4. We marked as “+” the
case when a circuit can be implemented as s single EMB. There are 39 of benchmarks
marked by “+” in Table7.4. It means that up to 73.5% of all FSMs (benchmarks)
can be implemented as a single EMB using XC5VLX30 chip.
Our analysis of Tables7.3 and 7.4 shows that the sign “+” marks rather simple
FSMs. We cannot get the results for such complex benchmarks as s420, s510, s820
and so on. So, the area of trivial approach is rather limited. So, it is necessary to
use different methods of structural decomposition to reduce the hardware amount in
FSM circuits based on EMBs [17].

198
7
Design of EMB-Based Mealy FSMs
Table 7.4 Results of investigations for P Mealy FSMs
Name
Slice
Slice FF
LUT
BRAM
bbara
1
4
0
1
+
bbsse
1
4
0
1
+
bbtas
1
3
0
1
+
bbcount
1
3
0
1
+
cse
16
17
40
0
+
dk14
1
3
0
1
+
dk15
1
2
0
1
+
dk16
2
5
0
1
+
dk17
1
3
0
1
+
dk27
1
3
0
1
+
dk512
1
4
0
1
+
donﬁle
2
5
0
1
+
ex1
2
5
0
12
–
ex2
5
11
12
0
+
ex3
3
10
6
0
+
ex4
1
4
0
1
+
ex5
3
9
5
0
+
ex6
1
3
0
1
+
ex7
3
9
5
0
+
keyb
27
15
74
0
+
kirkman
21
16
54
0
+
lion
1
2
0
1
+
lion9
3
9
5
0
+
mark1
11
19
20
0
+
mc
1
2
0
1
+
modulo12
1
4
0
1
+
opus
9
13
21
0
+
planet
2
6
0
7
–
planet1
2
6
0
7
–
pma
36
21
89
0
+
s1
2
5
0
3
–
s1488
2
6
0
13
–
s1494
2
6
0
13
–
s1a
2
5
0
3
–
s208
6
12
13
0
+
s27
1
3
0
1
+
s298
2
8
0
1
+
(continued)

7.1 Trivial Implementing Mealy FSMs
199
Table 7.4 (continued)
Name
Slice
Slice FF
LUT
BRAM
s386
1
4
0
1
+
s8
5
7
8
0
+
sand
2
5
0
28
–
shifreg
1
3
0
1
+
sse
1
4
0
1
+
styr
2
5
0
8
–
tav
1
2
0
1
+
tbk
2
5
0
1
+
tma
20
17
52
0
+
train11
4
9
5
0
+
train4
1
2
0
1
+
Toinvestigatethemethodsdiscussedinthischapter,wedevelopedspecialprogram
tools. We call it K2F.
The software K2F was created using PHP language. The main task of this software
is to translate the KISS2 ﬁle into a structure of FSM described using VHDL. On
execution, the K2F program generates a ﬁle describing (with VHDL language) all
the structures of FSMs presented in this chapter, which realize the control algorithm
represented by the input KISS2 ﬁle.
The next step can be the synthesis and simulation of the results with the use of
Active-HDL environment and the implementation using e.g. Xilinx ISE package. A
typical design path with the use of K2F is shown on Fig.7.4.
KISS2 file
K2F
software
VHDL
ACTIVE HDL
Xilinix ISE
FPGA
synthesis and 
simulation
synthesis and 
implementation
Fig. 7.4 Typical design path with the use of K2F

200
7
Design of EMB-Based Mealy FSMs
Fig. 7.5 Example of headers
KISS2
.i <number of inputs>
.o <number of outputs>
.p <number of products>
.s <number of states used>
.r <reset state>
<input> <current-state > <next-state> <output>
.
.
.
<input> <current-state > <next-state> <output>
.e
The KISS2 format is a very popular text format for describing the behaviour of a
control unit [18]. A KISS2 ﬁle is divided into two parts: header and a state transition
table. The header contains generic parameters of control unit, i.e. the number of
inputs, the number of outputs, the number of states and the number of terms. There
is an example of headers in Fig.7.5.
The ﬁeld ⟨inputs⟩is a sequence of ⟨number of inputs⟩chars from the set {0, 1, −}.
It represents a condition that must be met to make the transition from ⟨current state⟩
to ⟨next state⟩. The ﬁeld ⟨output⟩is a sequence of ⟨number of outputs⟩chars from the
set {0, 1, −}. It represents the state of outputs of the control unit after the transition
to a new state. The symbol “–” represents don’t care values. The optional attribute .e
indicates the end of the state transition table.
We use the Xilinx ISE 14.1 package for synthesis and implementation of bench-
marking FSMs. We use the platform XC5VLX30FF324 by Virtex-5 of Xilinx. It
includes 32 blocks of RAM (BRAM) having the following conﬁgurations: 36K ×
1, 18K × 2, 9K × 4, 4K × 9, 2K × 18, 1K × 36 and 512 × 72 (bits).
7.2 Encoding of Objects in Mealy FSMs
The trivial circuit can be implemented if the following condition takes place:
2L+R0 ≤V0.
(7.2)
In this case, the number of EMBs is determined by the following expression:
nEMB =
N + R0
tF

.
(7.3)
In (7.3), the symbol tF means the value of EMB’s outputs in the case when the
condition (7.2) takes place.

7.2 Encoding of Objects in Mealy FSMs
201
RG
X
Z
Start
Clock
BIMF
Y
BMO
T
RG
X
Z
Start
Clock
EMB1
Y
EMB2
T
(a)
(b)
Fig. 7.6 Structural diagram of PY Mealy FSM for common case (a) and EMB-based (b)
If (7.2) is violated, then the number of EMBs increases drastically in the circuit
of FSM [17]. Let us discuss the case when the condition (7.2) takes place. In this
case, the value of nEMB can be decreased due to encoding of: (1) collections of
microoperations and (2) rows of ST. Let us name CMOs and rows as objects of
FSM.
Let us start from the EMB-based PY Mealy FSM. The CMOs Yt ⊆Y are encoded
by binary codes C(Yt) having RZ bits. The expression (1.32) is used for determining
the value of RZ. The variables zr ∈Z are used for encoding of CMOs, where
|Z| = RZ. It leads to PY Mealy FSM (Fig.7.6).
In the common case, the BIMF implements the systems (1.4) and (2.30). Functions
Z enter the BMO (Fig.7.6a). The BMO implements the functions (1.40). In the case
of EMB-based PY FSM (Fig.7.6b), the EMB1 corresponds to the BIMF and EMB2
to BMO.
There are the following steps in the design method of PY Mealy FSM:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of Mealy FSM.
4. Encoding of collections of microoperations.
5. Constructing the transformed structure table.
6. Constructing the table of BIMF.
7. Constructing the table of BMO.
8. Implementing the FSM logic circuit with EMBs.
This method can be applied if the following conditions take places:
2L+R0 · (R0 + RY) ≤V0;
(7.4)
N · 2RY ≤V0.
(7.5)
Let us discuss an example of design for Mealy FSM PY(Γ10). The GSA Γ10 is
shown in Fig.7.7.
There are the following sets and their parameters derived from GSA Γ10: A =
{a1, . . . , a5}, M0 = 5, X = {x1, x2, x3}, L = 3, Y = {y1, . . . , y7}, N = 7, R0 = 3,
T = {T1, T2, T3} and Φ = {D1, D2, D3}. Let us encode the states am ∈A in the
trivial way: K(a1) = 000, . . . , K(a5) = 100.

202
7
Design of EMB-Based Mealy FSMs
Fig. 7.7 Initial GSA Γ10
y3y6y7
Start
y1y2y3
End
0
1
x1
x3
x2
y2y5
y3y6
0
0
1
1
a1
y2y5
y1y4
y1y4
1
0
x3
a1
a2
a3
a4
a5
Let us use the FPGA chip having EMBs with V0 = 384. Let the following
conﬁgurations exist for these EMBs: 64 × 6 and 32 × 1, bits. Using (7.1), it can be
found that it is necessary 640 bits of memory to implement the circuit of P(Γ10). So,
this model cannot be used. Let us try using the model PY(Γ10).
There are T0 = 6 of CMOs in operator vertices of GSA Γ10. They are the fol-
lowing: Y1 = ∅, Y2 = {y1, y2, y3}, Y3 = {y2, y4}, Y4 = {y3, y6, y7}, Y5 = {y2, y5},
Y6 = {y3, y6}. So, there are RZ = 3 and Z = {z1, z2, z3}.
Let us check the conditions (7.4)–(7.5). The expression (7.4) leads to the equal-
ity 384 = 384. The expression (7.5) results in inequality 56 ≤384. So, there is
possibility in using the model PY(Γ10).
There are H0(Γ10) = 9 rows in the structure table of P(Γ10). It is represented by
Table7.5.
Because EMBs are used for implementing all combinational parts of a circuit, the
collections of microoperations can be encoded in the arbitrary manner. Let us encode
them in the following manner: C(Y0) = 000, C(Y1) = 001, . . . , C(Y5) = 101.
To construct the transformed structure table, the column Yh of initial table should
be replaced by columns Yt and C(Yt). Obviously, the number of rows in the trans-
formed structure table is the same as for the initial structure table of Mealy FSM.
The transformed structure table of Mealy FSM PY(Γ10) is represented by Table7.6
The transformed ST is used for constructing the table of EMB1. It includes the
following columns: K(am), X, Z, Φ, q. The columns K(am), X form an address of a
cell. The content of this cell is determined by the columns Z and Φ. There is L = 3,

7.2 Encoding of Objects in Mealy FSMs
203
Table 7.5 Structure table of Mealy FSM P(Γ10)
am
K(am)
as
K(as)
Xh
Yh
Φh
h
a1
000
a2
001
1
y1y2y3
D3
1
a2
001
a3
010
x1
y1y4
D2
2
a5
100
¯x1x2
y2y5
D1
3
a5
100
¯x1 ¯x2
y3y6
D1
4
a3
010
a4
011
1
y3y6y7
D2D3
5
a4
011
a4
011
x3
y3y6y7
D2D3
6
a1
000
¯x3
–
–
7
a5
100
a1
000
x3
y2y5
–
8
a1
000
¯x3
y1y4
–
9
Table 7.6 Transformed structure table of Mealy FSM PY(Γ10)
am
K(am)
as
K(as)
Xh
Yt
C(Yt)
Φh
h
a1
000
a2
001
1
Y1
001
D3
1
a2
001
a3
010
x1
Y2
010
D2
2
a5
100
¯x1x2
Y3
011
D1
3
a5
100
¯x1 ¯x2
Y4
100
D1
4
a3
010
a4
011
1
Y5
101
D2D3
5
a4
011
a4
011
x3
Y5
101
D2D3
6
a1
000
¯x3
Y0
000
–
7
a5
100
a1
000
x3
Y3
011
–
8
a1
000
¯x3
Y2
010
–
9
Table 7.7 The part of table
of EMB1 (for state a2)
K(am)
X
Z
Φ
q
h
T1T2T3
x1x2x3
z1z2z3
D1D2D3
001
000
100
100
9
4
001
001
100
100
10
4
001
010
011
100
11
3
001
011
011
100
12
3
001
100
010
010
13
2
001
010
010
010
14
2
001
110
010
010
15
2
001
111
010
010
16
2
so H(am) = 8. It means that: (1) there are 64 rows in the table of EMB1 and (2) only
40 rows carry useful information. The part of this table is represented by Table7.7.
There are transitions from the state a2 ∈A shown in Table7.7. We add the column
h to show the connection between Tables7.6 and 7.7.

204
7
Design of EMB-Based Mealy FSMs
Table 7.8 Table of EMB2
for Mealy FSM PY(Γ10)
C(Yt)
Yt
q
z1z2z3
y1y2y3y4y5y6y7
000
0000000
1
001
1110000
2
010
1001000
3
011
0100100
4
100
0010010
5
101
0010011
6
110
0000000
7
111
0000000
8
There are the following columns in the table of BMO: C(Yt), Yt, q. It corresponds
to the table of EMB2. This table has 2RZ = 8 rows (Table7.8). There are no CMOs
encoded using the codes 110 and 111. So, these rows are ﬁlled by zeros in Table7.8.
The Table7.7 (together with other similar tables) is used for programming the
EMB1. The Table7.8 is used for programming the EMB2. There is the logic circuit
of Mealy FSM PY(Γ10) shown in Fig.7.8. Let us point out that the EMB1 is organized
as 64 × 6, whereas the EMB2 as 32 × 8 memory block.
Tables7.9 presents the results of investigations for some of benchmarks. As we
can see, sometimes the CAD tools do not allow using EMBs in the circuit. We cannot
overcome this tendency of Xilinx.
It is possible to use the method of encoding of the ﬁelds of compatible MOs for
optimising the EMB-based Mealy FSMs. Of course, it is necessary to use LUTs for
implementing the ﬁnal decoders [17]. In this case, the CMOs are used as objects,
too.
There is the structural diagram of EMB-based PD Mealy FSM (Fig.7.9). It is
similar to PY FSM Fig.7.6b. But there is the LUTer instead of EMB2. There are
additional steps in the design method of PD FSM. They are connected with: (1)
EMB2
1
2
3
4
5
6
7
8
x1
Start
Clock
y1
y2
y3
y4
EMB1
1
2
3
4
T1
T2
T3
D1
D2
D3
LUT1
LUT2
LUT3
T1
z1
T2
z2
T3
z3
5
6
1
2
3
4
5
6
x2
x3
1
2
3
4
5
y5
y6
y7
Fig. 7.8 Logic circuit of Mealy FSM PY(Γ10)

7.2 Encoding of Objects in Mealy FSMs
205
Table 7.9 Results of investigations for PY Mealy FSMs
Name
Slices
FF
LUTs
BRAMs
bbara
1
4
0
2
bbsse
1
4
0
2
bbtas
1
3
0
1
bbcount
1
3
0
1
cse
1
4
0
2
dk14
1
3
0
2
dk15
1
2
0
1
dk16
5
8
3
1
dk17
3
6
3
1
dk27
1
3
0
1
dk512
1
4
0
1
donﬁle
3
6
1
1
ex1
2
5
0
7
ex2
13
13
27
0
ex3
6
13
9
0
ex4
1
4
0
2
ex5
5
11
7
0
ex6
1
3
0
1
ex7
2
5
1
1
keyb
3
7
2
1
kirkman
29
16
77
1
lion
2
3
1
1
lion9
5
10
5
0
mark1
6
12
13
1
mc
1
2
0
2
modulo12
0
0
0
0
opus
8
11
17
1
planet
2
6
0
5
planet1
2
6
0
5
pma
30
15
85
1
s1
2
5
0
3
s1488
2
6
0
7
s1494
2
6
0
7
s1a
0
0
0
0
s208
2
5
0
15
s27
2
4
1
1
s298
7
14
5
1
s386
1
4
0
2
(continued)

206
7
Design of EMB-Based Mealy FSMs
Table 7.9 (continued)
Name
Slices
FF
LUTs
BRAMs
s8
0
0
0
0
sand
2
5
0
23
shifreg
2
4
0
1
sse
1
4
0
2
styr
2
5
0
6
tav
1
2
0
1
tbk
4
8
3
1
tma
23
15
59
1
train11
5
11
7
0
train4
2
3
1
1
Fig. 7.9 Structural diagram
of EMB-based PD Mealy
FSM
RG
X
Z
Start
Clock
EMB1
Y
LUTer
T
constructing the sets of compatible MOs and (2) executing the encoding of the ﬁelds
of compatible MOs [17].
This model can be applied if the following condition takes place:
2K+R0 · (R0 + RD) ≤V0.
(7.6)
In (7.6), the symbol RD stands for the general amount of bits required for the
encoding of all ﬁelds. It is determined as (3.41). Let us discuss an example of design
for Mealy FSM PD(Γ10). Some steps of design are already executed in the previ-
ous example. Now, let us ﬁnd the partition Y = {Y1, . . . , YK} for the discussed
example. Remind that Yk is a k-th class of compatible MOs.
There are the following classes Yk in the discussed case: Y1 = {y1, y5, y6}, Y2 =
{y2, y4, y7} and Y3 = {y3}. Therefore, K = 3, N1 = N2 = 3 and N3 = 1. Using
(1.35) and (3.41) the following values can be found: R1 = R2 = 2, R3 = 1 and
RD = 5. It means that Z1 = {z1, z2}, Z2 = {z3, z4} and Z3 = {z5}.
Let the FPGA chip in use have V0 = 512 (bits) and let the conﬁguration 64 ×
8 exist. It was found that V0 ≥640 is required for implementing the logic circuit

7.2 Encoding of Objects in Mealy FSMs
207
of P(Γ10). So, it is impossible to use this model. The expression (7.6) produces the
equality 512 = 512. Therefore, it is possible to use the model PD(Γ10).
Let us encode the microoperations yn ∈Yk as it is shown in Table7.10.
There are the same columns in the transformed table of PD as it is for PY FSM.
It is Table7.11 in the discussed case.
Let us explain how the column K(Yt) is ﬁlled. The code K(Yt) of a collection
of microoperations Yt ⊆Y can be represented as a concatenation of codes K(yn)k
(k = 1, K), where yn ∈Yt:
Yt = K(yn)1 ∗K(yn)2 ∗· · · ∗K(yn)K.
(7.7)
In (7.7), the sign * denotes the concatenation.
For example, there is Y1 = {y1, y2, y3}. From Table7.10 we can derive that
K(y1) = 01, K(y2) = 01 and K(y3) = 1. Therefore, the ﬁrst row of Table7.11
should include the code 01011in the column C(Yt). The collection Y4 = {y3, y6}
and y3 ∈Y3, y6 ∈Y1. So, this collection does not include microoperations yn ∈Y2.
It means that the code K(∅)2 = 00 should be used. It gives the code C(Y4) = 11001.
All other codes C(Yt) are formed in this very manner.
Table7.11 is used for constructing the table of EMB1. It includes 64 rows in the
discussed case. Some part of this table is represented by Table7.12. It contains the
transitions for the state a2 ∈A.
Table 7.10 Codes of microoperations for FSM PD(Γ10)
yn ∈Y1
K(yn)1
yn ∈Y2
K(yn)2
yn ∈Y3
K(yn)3
z1z2
z3z4
z5
∅
0 0
∅
0 0
∅
0
y1
0 1
y2
0 1
y3
1
y5
1 0
y4
1 0
y6
1 1
y7
1 1
Table 7.11 Transformed ST of Mealy FSM PD(Γ10)
am
Kam)
as
K(as)
Xh
Yt
C(Yt)
Φh
h
a1
000
a2
001
1
Y1
01011
D3
1
a2
001
a3
010
x1
Y2
01100
D2
2
a5
100
¯x1x2
Y3
10010
D1
3
a5
100
¯x1 ¯x2
Y4
11001
D1
4
a3
010
a4
011
1
Y5
11111
D2D3
5
a4
011
a4
011
x3
Y5
11111
D2D3
6
a1
000
¯x3
Y0
00000
–
7
a5
100
a1
000
x3
Y3
10010
–
8
a1
000
¯x3
Y2
01100
–
9

208
7
Design of EMB-Based Mealy FSMs
Table 7.12 Table of EMB1 for state a2 ∈A of Mealy FSM PD(Γ10)
K(am)
X
Z
Φ
q
h
T1T2T3
x1x2x3
z1z2z3z4z5
D1D2D3
001
000
11001
100
9
4
001
001
11001
100
10
4
001
010
10010
100
11
3
001
011
10010
100
12
3
001
100
01100
010
13
2
001
101
01100
010
14
2
001
110
01100
010
15
2
001
111
01100
010
16
2
In the case of PD FSM, there is no need in the table of BMO. The system Y(Z) can
be derived from the table with codes of microoperations. In the discussed example,
the following system can be derived from Table7.10: y1 = ¯z1z2, y2 = ¯z3z4, y3 = z5,
y4 = z1 ¯z2, y6 = z1z2, y7 = z3z4.
The logic circuit of FSM PD(Γ10) is shown in Fig.7.10.
The circuit of BIMF is implemented using a single EMB having 64 × 8 bits. Three
logic elements are used for implementing the circuit of RG. At last, six LUTs are used
to implement the circuit of BMO. Obviously, the equation y3 = z5 is implemented
without LUTs.
Now let us discuss Mealy FSM based on the encoding of rows of ST. There is the
structural diagram of EMB-based PH Mealy FSM shown in Fig.7.11.
x1
Start
Clock
y1
y3
EMB1
1
2
3
4
T1
T2
T3
D1
D2
D3
LUT1
LUT2
LUT3
T1
T2
T3
5
6
x2
x3
y5
1
2
3
4
5
6
7
8
LUT4
1
2
3
4
5
1
2
LUT5
1
2
y6
LUT6
1
2
y2
LUT7
3
4
y4
LUT8
3
4
y7
LUT9
3
4
5
Z
z1
z2
z3
z4
z5
Fig. 7.10 Logic circuit of Mealy FSM PD(Γ10)

7.2 Encoding of Objects in Mealy FSMs
209
EMB1
RG
X
T
Start
Clock
EMB2
Y
Z
Fig. 7.11 Structural diagram of EMB-based PH Mealy FSM
The EMB1 represents the block of encoding of rows (BER) implementing the
system (2.30). The EMB2 represents the BIMF implementing the system (1.40). Let
the following conditions take places:
2L+R0 · RH ≤V0;
(7.8)
(N + R0) · 2RH ≤V0.
(7.9)
Remind, the value of RH is determined as (1.38). It shows the number of bits in
the codes K(Fh), where Fh is a term of ST (1.8).
In conditions (7.8)–(7.9) take places, then there are the following steps in the
design method of PH Mealy FSM:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of Mealy FSM.
4. Encoding of the rows of structure table.
5. Constructing the transformed structure table.
6. Constructing the table of BER.
7. Constructing the table of BIMF.
8. Implementing the logic circuit of FSM using EMBs.
Let us discus an example of design for Mealy FSM PH(Γ10). It is possible to ﬁnd
the following sets for GSA Γ10: A = {a1, . . . , a5}, M = 5, X = {x1, x2, x3}, L = 3,
Y = {y1, . . . , y7}, N = 7, R = 3, T = {T1, T2, T3} and Φ = {D1, D2, D3}. Let us
encode the states am ∈A in the trivial way: K(a1) = 000, . . . , K(a5) = 100.
Let the FPGA chip in use have V0 = 256 with conﬁgurations 256 × 1, 128 × 2,
64 × 4, 32 × 8 and 16 × 16 (bits). Because 640 bits are necessary for implementing
the logic circuit of P(Γ10), the model of P FSM cannot be used.
There is H0 = 9 (see Table7.5), so we can ﬁnd RH = 4 and Z = {z1, . . . , z4}.
There are the following conditions for PH(Γ10): 64 × 4=256 and 10 ×16 < 256.
Therefore, it has sense to use the model of Mealy FSM PH(Γ10). Let us encode the
rows Fh ∈F in the trivial way: K(F1) = 0000, . . . , K(F9) = 1000.
To construct the transformed structure table, it is enough to replace the columns
Yh and Φh of the initial structure table by the column K(Fh). Obviously, this column

210
7
Design of EMB-Based Mealy FSMs
contains a code for corresponding row. The transformed structure table for PH(Γ10)
is represented by Table7.13.
The transformed structure table is used for constructing the table of BER. In the
case of PH FSM, this table includes the following columns: K(am), X, K(Fh), q.
For the Mealy FSM PH(Γ10), this table has 64 rows. There is the part of this table
shown in Table7.14. It represents the transitions from the state a2 ∈A.
The table of BIMF includes the following columns: K(Fh), Φ, Y, h. The ﬁrst
column contains the address of the cell of EMB2. The contents of cells are determined
by columns Φ and Y. This table is ﬁlled in the trivial way. The contents of columns Φ
and Y are taken from the structure table. In the case of FSM PH(Γ10), it is Table7.15.
The logic circuit of FSM PH(Γ10) is shown in Fig.7.12. There are three of LUTs
used for implementing the circuit of RG. The content of EMB1 (EMB2) is taken
from Table7.14 (Table7.15).
We investigated the possibility of using this model for the benchmarks [18]. The
results of investigations is shown in Table7.16. Comparison of Tables7.9 and 7.16
shows that there is a gain in the hardware amount in the case of PH FSMs. This
gain increases with the growth of the complexness of a benchmarks. For example,
Table 7.13 Transformed structure table of Mealy FSM PH(Γ10)
am
K(am)
as
K(as)
Xh
K(Fh)
h
a1
000
a2
001
1
0000
1
a2
001
a3
010
x1
0001
2
a5
100
¯x1x2
0010
3
a5
100
¯x1 ¯x2
0011
4
a3
010
a4
011
1
0100
5
a4
011
a4
011
x3
0101
6
a1
000
¯x3
0110
7
a5
100
a1
000
x3
0111
8
a1
000
¯x3
1000
9
Table 7.14 The part of table
of BER for Mealy FSM
PH(Γ10)
K(am)
X
Z
q
h
T1T2T3
x1x2x3
z1z2z3z4
001
000
0011
9
4
001
001
0011
10
4
001
010
0010
11
3
001
011
0010
12
3
001
100
0001
13
2
001
101
0001
14
2
001
110
0001
15
2
001
111
0001
16
2

7.2 Encoding of Objects in Mealy FSMs
211
Table 7.15 Table of EMB2
for Mealy FSM PY(Γ10)
K(Fh)
Φ
Yt
q
z1z2z3z4
D1D2D3
y1y2y3y4y5y6y7
0000
001
1110000
1
0001
010
1001000
2
0010
100
0100100
3
0011
100
0010010
4
0100
011
0010011
5
0101
011
0010011
6
0110
000
0000000
7
0111
000
0100100
8
1000
000
1001000
9
EMB2
1
2
3
4
5
6
7
8
x1
Start
Clock
y1
y2
y3
y4
EMB1
1
2
3
4
T1
T2
T3
D1
D2
D3
LUT1
LUT2
LUT3
T1
z1
T2
z2
T3
z3
5
6
1
2
3
4
x2
x3
1
2
3
4
y5
y6
y7
z4
9
10
T
Fig. 7.12 Logic circuit of Mealy FSM PH(Γ10)
it is necessary 23 of BRAMs for sand (Table7.9), whereas this number is decreased
up to 17 or PH FSM (Table7.16).
7.3 Replacement of Logical Conditions for Mealy FSMs
If condition (7.2) is violated, then the hardware reduction can be achieved due to
applying the method of RLC. Let us ﬁnd the value of G and form the set P =
{p1, . . . , pG} for some Mealy FSM. Let the following condition take place:
2G+R0 · (N + R0) ≤V0.
(7.10)
In this case, it is possible to use the model of EMB-based MP Mealy FSM
(Fig.7.13). There is only a single EMB in this circuit.

212
7
Design of EMB-Based Mealy FSMs
Table 7.16 Results of investigations for PH Mealy FSMs
Name
Slices
FF
LUTs
BRAMs
bbara
1
4
0
1
bbsse
1
4
0
1
bbtas
1
3
0
1
bbcount
1
3
0
1
cse
12
15
19
1
dk14
1
3
0
1
dk15
1
2
0
1
dk16
2
5
0
1
dk17
1
3
0
1
dk27
1
3
0
1
dk512
1
4
0
1
donﬁle
2
5
0
1
ex1
2
5
0
5
ex2
6
11
11
1
ex3
4
10
6
1
ex4
1
4
0
1
ex5
1
4
0
1
ex6
1
3
0
1
ex7
3
9
5
1
keyb
20
12
44
1
kirkman
33
14
88
1
lion
1
2
0
1
lion9
3
9
5
1
mark1
1
4
0
2
mc
1
2
0
1
modulo12
1
4
0
1
opus
5
9
10
1
planet
2
6
0
3
planet1
2
6
0
3
pma
35
15
89
1
s1
2
5
0
3
s1488
2
6
0
5
s1494
2
6
0
5
s1a
2
5
0
3
s208
14
12
28
16
s27
1
3
0
1
s298
2
8
0
2
s386
1
4
0
1
(continued)

7.3 Replacement of Logical Conditions for Mealy FSMs
213
Table 7.16 (continued)
Name
Slices
FF
LUTs
BRAMs
s8
4
8
5
1
sand
2
5
0
17
shifreg
1
3
0
1
sse
1
4
0
1
styr
2
5
0
5
tav
1
2
0
1
tbk
2
5
0
2
tma
18
11
38
1
train11
4
9
5
1
train4
1
2
0
1
LUTer
RG
X
T
Start
Clock
EMB
Y
P
Fig. 7.13 Structural diagram of MP Mealy FSM
In the MP Mealy FSM, a block LUTer represents the block of replacement of
logical conditions (BRLC). It is implemented using LUTs of an FPGA chip. The
LUTer implements the system (1.47) which can be represented as the following:
p1 = p1(T, X1);
...
pG = pG(T, XG).
(7.11)
In (7.11), the set Xg includes logical conditions xl ∈X replaced by the variable
pg ∈P. It is quite possible that the following relation is true:
Xi ∩Xj ̸= ∅(i ̸= j; i, j ∈{1, . . . , G}).
(7.12)
A block EMB represents the block of input memory functions (BIMF). It imple-
ments the systems (1.48)–(1.49).

214
7
Design of EMB-Based Mealy FSMs
The design method of MP Mealy FSM includes the following steps:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of P Mealy FSM.
4. Replacement of logical conditions.
5. Constructing the system (7.11).
6. Constructing the transformed structure table.
7. Constructing the table of BIMF.
8. Implementing the FSM logic circuit with EMB and LUTs of a particular FPGA
chip.
Let us discuss an example of design for Mealy FSM MP(Γ11). There is the GSA
Γ11 shown in Fig.7.14.
There are the following sets and their characteristics for Mealy FSM MP(Γ11):
A = {a1, . . . , a4}, M0 = 4, X = {x1, . . . , x6}, L = 6, Y = {y1, . . . , y6}, N = 6,
R0 = 2, T = {T1, T2} and Φ = {D1, D2}. Let us encode the states am ∈A in the
trivial way: K(a1) = 00, . . . , K(a4) = 11.
Fig. 7.14 Initial
graph-scheme of algorithm
Γ11
Start
a1
1
0
x1
x2
y2y3
y3y4y5
y1y2
x3
x4
y3y6
x5
x6
y4y6
y1y2
End
a1
0
1
a2
0
1
0
1
a3
0
1
0
1
a4

7.3 Replacement of Logical Conditions for Mealy FSMs
215
Table 7.17 Structure table of Mealy FSM P(Γ11)
am
K(am)
as
K(as)
Xh
Yh
Φh
h
a1
00
a2
01
x1
y1y2
D2
1
a2
01
¯x1x2
y2y3
D2
2
a2
01
¯x1 ¯x2
y3y4y5
D2
3
a2
01
a2
01
x3
y1y2
D2
4
a3
10
¯x3x4
y3y6
D1
5
a2
01
¯x3 ¯x4
y3y4y5
D2
6
a3
10
a4
11
x5
y4y6
D1D2
7
a4
11
¯x5x6
y4y6
D1D2
8
a1
00
¯x5 ¯x6
y1y2
–
9
a4
11
a1
00
1
y1y2
–
10
Let the FPGA chip in use have V0 = 128 and let the following conﬁgurations
of EMB exist: 128 × 1, 64 × 2, 32 × 4, 16 × 8 (bits). It is necessary 2048 bits of
memory to implement the circuit of P(Γ11). So, this model cannot be used.
There are 10 rows in ST of P(Γ11) (Table7.17). There are the following sets X(am)
derived from Table7.17: X(a1) = {x1, x2}, X(a2) = {x3, x4}, X(a3) = {x5, x6},
X(a4) = ∅. Obviously, there is G = 2. It gives the set P = {p1, p2}. There are
G +R0 = 4 and R0 +N = 8. So, the condition (7.10) is true. It means that the model
of MP(Γ11) can be used.
Let us replace the logical conditions as it is shown in the Table7.18. There are no
the same logical conditions in the sets X(am) ⊆X for the discussed case. Because of
it, the distribution of the logical conditions among the variables pg ∈P is executed in
the trivial way. If there is X(ai)∩X(aj) ̸= ∅, then the distribution should be executed
in such a way that the intersection for any pair of sets Xg(g = 1, G) has the minimum
capacity [16].
The following system of equations can be derived from Table7.18:
p1 = A1x1 ∨A2x3 ∨A3x5;
p2 = A1x1 ∨A2x4 ∨A3x6.
(7.13)
If the variables Am(m = 1, M) are replaced by corresponding state codes, the
system (7.13) is transformed into the following one:
p1 = ¯T1 ¯T2x1 ∨¯T1T2x3 ∨T1 ¯T2x5;
p2 = ¯T1 ¯T2x1 ∨¯T1T2x4 ∨T1 ¯T2x6.
(7.14)
Table 7.18 Table of
replacement of logical
conditions for Mealy FSM
MP(Γ11)
am
a1
a2
a3
a4
p1
x1
x3
x5
–
p2
x2
x4
x6
–

216
7
Design of EMB-Based Mealy FSMs
Table 7.19 Transformed ST of Mealy FSM MP(Γ11)
am
K(am)
as
K(as)
Ph
Yh
Φh
h
a1
00
a2
01
p1
y1y2
D2
1
a2
01
¯p1p2
y2y3
D2
2
a2
01
¯p1 ¯p2
y3y4y5
D2
3
a2
01
a2
01
p1
y1y2
D2
4
a3
10
¯p1p2
y3y6
D1
5
a2
01
¯p1 ¯p2
y3y4y5
D2
6
a3
10
a4
11
p1
y4y6
D1D2
7
a4
11
¯p1p2
y4y6
D1D2
8
a1
00
¯p1 ¯p2
y1y2
–
9
a4
11
a1
00
1
y1y2
–
10
This system corresponds to two of LUTs having S = 5. The tables of LUTs are
constructed in the way discussed before.
There are practically the same columns in the ST and transformed ST [17]. But
there is the column Ph in the transformed ST replacing the column Xh from the initial
ST. In the discussed case, the transformation of tables leads to Table7.19.
This table is a base for constructing the table of BIMF containing the following
columns: K(am), P, Y, Φ, q. The columns K(am) and P form the addresses of cells.
The table of BIMF includes V(Γ1) = 16 rows for the discussed case. The number
of rows H(P) for representing transitions from any state is determined as:
H(P) = 2G.
(7.15)
In the discussed case, there is H(P) = 4. The table of BIMF is represented by
Table7.20. The logic circuit of FSM MP(Γ11) is shown in Fig.7.15. We take LUTs
having S = 5. In allows implementing each equation from (7.14) using only a single
LUT. It is possible in the common case, if the following condition takes place:
R + |Xg| ≤S
(g = 1, G).
(7.16)
So, the are 4 of LUTs in the circuit of MP(Γ11). The LUT3 and LUT4 are used
to implement the circuit of RG.
This method can be applied for all benchmarks [18]. The results of investigations
are shown in Table7.21.
It is possible to use the method of RLC together with other methods of structural
decomposition [17]. For example, the MPY Mealy FSM is based on combining the
methods of RLC and maximal encoding of CMOs. Its structural diagram in shown
in Fig.7.16.
It is possible to combine the RLC and encoding of ﬁelds of compatible MOs. It
leads to MPD Mealy FSM (Fig.7.17).

7.3 Replacement of Logical Conditions for Mealy FSMs
217
Table 7.20 Table of BIMF of
Mealy FSM MP(Γ11)
K(am)
P
Y
Φ
v
h
T1T2
p1p2
y1y2y3y4y5y6
D1D2
00
00
001110
01
1
3
00
01
011000
01
2
2
00
10
110000
01
3
1
00
11
110000
01
4
1
01
00
001110
01
5
6
01
01
001001
10
6
5
01
10
110000
01
7
4
01
11
110000
01
8
4
10
00
110000
00
9
9
10
01
000101
11
10
8
10
10
000101
11
11
7
10
11
000101
11
12
7
11
00
110000
00
13
10
11
01
110000
00
14
10
11
10
110000
00
15
10
11
11
110000
00
16
10
x1
Start
Clock
y1
y2
y3
y4
D2
LUT3
LUT4
T2
EMB
1
2
3
1
2
3
4
5
6
LUT1
x5
x3
T1
T2
7
8
4
x2
LUT2
x6
x4
T2
T1
T1
T2
p1
p2
T1
D1
y6
y5
T
Fig. 7.15 Logic circuit of Mealy FSM MP(Γ11)
It is possible to combine the RLC and the encoding of the rows of ST. It leads to
MPH Mealy FSM (Fig.7.18).
We do not discuss these models in our book. The reader can combine correspond-
ing methods to work out the design methods for FSM shown in Figs.7.16, 7.17
and 7.18. We investigated these methods for the benchmarks [18]. Some results are
shown in Tables7.22 and 7.23. As follows from these tables, the proposed models
can be used in practical cases.

218
7
Design of EMB-Based Mealy FSMs
Table 7.21 Results of investigations for MP Mealy FSMs
Name
Slice
Slice FF
LUT
BRAM
bbara
4
4
4
1
bbsse
6
4
8
1
bbtas
3
3
2
1
bbcount
3
3
3
1
cse
27
18
63
0
dk14
3
3
3
1
dk15
1
2
0
1
dk16
4
5
2
1
dk17
1
3
0
1
dk27
2
3
1
1
dk512
2
4
1
1
donﬁle
3
5
2
1
ex1
12
5
18
2
ex2
5
11
12
0
ex3
3
10
6
0
ex4
4
4
4
1
ex5
3
9
5
0
ex6
3
3
2
1
ex7
4
9
5
0
keyb
43
12
99
0
kirkman
79
17
188
0
lion
1
2
0
1
lion9
3
9
5
0
mark1
4
4
4
1
mc
3
2
2
1
modulo12
2
4
1
1
opus
3
4
6
1
planet
13
6
29
2
planet1
13
6
29
2
pma
9
5
15
1
s1
13
6
24
3
s1488
16
6
27
3
s1494
12
8
23
3
s1a
13
6
24
3
s208
12
12
19
0
s27
4
3
4
1
s298
5
8
4
1
s386
7
4
9
1
(continued)

7.3 Replacement of Logical Conditions for Mealy FSMs
219
Table 7.21 (continued)
Name
Slice
Slice FF
LUT
BRAM
s8
5
7
11
0
sand
13
5
30
2
shifreg
1
3
0
1
sse
9
4
9
1
styr
13
5
20
2
tav
1
2
0
1
tbk
2
5
0
1
tma
24
20
54
0
train11
4
9
5
0
train4
1
2
0
1
LUTer
RG
X
T
Start
Clock
EMB1
Y
P
EMB2
Z
Fig. 7.16 Structural diagram of EMB-based MPY Mealy FSM
LUTer1
RG
X
T
Start
Clock
EMB1
Y
P
LUTer2
Z
Fig. 7.17 Structural diagram of MPD Mealy FSM
To improve the characteristics of FSM with BRLC, it has sense to diminish the
number of LUTs in this block. It can result in decreasing for both the propagation
time and consumed energy of the ﬁnal circuit.

220
7
Design of EMB-Based Mealy FSMs
LUTer1
RG
X
T
Start
Clock
EMB1
Y
P
LUTer2
Z
Fig. 7.18 Structural diagram of MPH Mealy FSM
Table 7.22 Results of investigations for MPY Mealy FSMs
Name
Slice
Slice FF
LUT
BRAM
bbara
3
4
4
1
bbsse
7
4
8
2
bbtas
3
3
2
1
bbcount
3
3
3
1
cse
6
4
8
2
dk14
3
3
3
1
dk15
1
2
0
1
dk16
6
8
5
1
dk17
3
6
3
1
dk27
2
3
1
2
dk512
2
4
1
1
donﬁle
5
6
3
1
ex1
10
5
18
2
ex2
7
13
15
0
ex3
6
3
9
0
ex4
3
4
4
2
ex5
4
11
7
0
ex6
2
3
2
1
ex7
3
5
3
1
keyb
11
7
25
1
kirkman
40
17
99
1
lion
2
3
1
1
lion9
4
10
5
0
mark1
4
4
4
1
mc
3
2
2
1
modulo12
0
0
0
0
opus
3
4
6
1
(continued)

7.3 Replacement of Logical Conditions for Mealy FSMs
221
Table 7.22 (continued)
Name
Slice
Slice FF
LUT
BRAM
planet
11
6
29
2
planet1
11
6
29
2
pma
9
5
15
1
s1
13
6
24
3
s1488
12
6
27
3
s1494
11
7
23
3
s1a
0
0
0
0
s208
6
5
9
2
s27
4
4
5
1
s298
9
14
9
1
s386
7
4
9
2
s8
0
0
0
0
sand
13
5
30
2
shifreg
2
4
0
1
sse
7
4
9
1
styr
11
5
20
2
tav
1
2
0
1
tbk
4
8
3
1
tma
20
15
49
1
train11
5
11
7
0
train4
2
3
1
0
Table 7.23 Results of investigations for MPH Mealy FSMs
Name
Slice
Slice FF
LUT
BRAM
bbara
3
4
4
1
bbsse
8
4
8
1
bbtas
2
3
2
1
bbcount
2
3
3
1
cse
13
15
27
1
dk14
2
3
3
1
dk15
1
2
0
1
dk16
3
5
2
1
dk17
1
3
0
1
dk27
2
3
1
1
dk512
2
4
1
1
donﬁle
3
5
2
1
(continued)

222
7
Design of EMB-Based Mealy FSMs
Table 7.23 (continued)
Name
Slice
Slice FF
LUT
BRAM
ex1
11
5
18
2
ex2
7
11
13
1
ex3
5
10
8
1
ex4
4
4
4
1
ex5
2
4
2
1
ex6
3
3
2
1
ex7
5
9
7
1
keyb
19
12
44
1
kirkman
136
15
409
1
lion
1
2
0
1
lion9
3
9
5
1
mark1
3
4
4
2
mc
3
2
2
1
modulo12
2
4
1
1
opus
4
4
6
1
planet
10
6
29
2
planet1
10
6
29
2
pma
11
5
15
1
s1
4
5
24
3
s1488
11
6
27
2
s1494
10
6
23
2
s1a
14
5
24
3
s208
17
12
37
1
s27
5
3
4
1
s298
4
8
4
2
s386
4
4
9
1
s8
4
8
5
1
sand
13
5
30
2
shifreg
1
3
0
1
sse
9
4
9
1
styr
10
5
20
2
tav
1
2
0
1
tbk
2
5
0
2
tma
22
16
42
1
train11
4
9
5
1
train4
1
2
0
1

7.4 Hardware Reduction for BRLC
223
7.4 Hardware Reduction for BRLC
Let us discus the case when the following condition takes place:
SA > G + R.
(7.17)
In (7.17), the value SA determines the number of address bits of EMB for given
tF. If (7.17) is true, then the following condition takes place:
S0 = SA −(G + R) > 0.
(7.18)
The value S0 is equal to the number of “free” address inputs of EMB. These inputs
are not connected with variables Tr ∈T and pg ∈P. We propose to use them for
optimization of the circuit of LUTer.
Let us start from MP Mealy FSM. Let us represent the set X as X1 ∪X2 where
the following condition takes place:
X1 ∩X2 = ∅;
X1 ∪X2 = X;
|X1| = S0;
|X2| = L −S0.
(7.19)
Let us replace the logical conditions xl ∈X2 by additional variables pg ∈P. It
leads to M0P Mealy FSM shown in Fig.7.19.
In M0P FSM, the LUTer executes the replacement of logical conditions xl ∈X2.
It implements the system
P = P(T, X2).
(7.20)
The EMB implements functions
Y = Y(T, P, X1);
(7.21)
Φ = Φ(T, P, X1).
(7.22)
EMB
Y
RG
T
X2
Start
Clock
P
LUTer
X1
Fig. 7.19 Structural diagram of M0P Mealy FSM

224
7
Design of EMB-Based Mealy FSMs
The following design method is proposed for M0P Mealy FSM.
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of Mealy FSM.
4. Partitioning the set X and ﬁnding the sets X1 and X2.
5. Replacement of logical conditions xl ∈X2.
6. Constructing the transformed structure table of Mealy FSM M0P(Γj).
7. Constructing the table of BIMF.
8. Implementing the logic circuit of FSM for a given FPGA chip.
Let us discus an example of design for Mealy FSM M0P(Γ11). Let us use the
FPGA chip including the EMBs having the following conﬁgurations: 512 × 1, 256
× 2, 128 × 4 and 64 × 8 (bits). For the Mealy FSM P(Γ11), there is N + R0 = 8.
Therefore, the conﬁguration 64 × 8 can be used with SA = 6. There is R0 = 2, then
it is possible to have G + S0 = 4.
There is the structure table of Mealy FSM P(Γ11) shown in Table7.17. Let us
ﬁnd the sets X(am) from this table. There are the following sets: X(a1) = {x1, x2},
X(a2) = {x3, x4}, X(a3) = {x5, x6}. Let us represent each set X(am) ⊆X as X(am)1∪
X(am)2 where X(am)1 ∩X(am)2 = ∅(m = 1, M). Let us ﬁnd the sets X1 and X2
using the rules:
X1 =
M

m=1
X(am)1;
(7.23)
X2 =
M

m=1
X(am)2.
(7.24)
Let us construct the following sets: X(a1)1 = {x1}, X(a1)2 = {x2}, X(a2)1 =
{x3}, X(a2)2 = {x4}, X(a3)1 = {x5} and X(a3)2 = {x6}. It leads to the sets X1 =
{x1, x3, x5} and X2 = {x2, x4, x6}. Obviously, there is G = 1 and p1 = A1x2 ∨A2x4 ∨
A3x6.
The transformed structure table of Mealy FSM M0P(Γj) includes the follow-
ing columns: am, K(am), as, K(as), X1
h, Ph, Yh, Φh, h. In the discussed case, it is
Table7.24.
The table of BIMF includes the following columns: K(am), X1,P, Y, Φ, v, h.
The ﬁrst three columns create the address of some cell of EMB. This table includes
V3(Γj) rows where:
Q3(Γj) = 2S0+G+R0.
(7.25)
It can be found that Q3(Γ11) = 64. There is the following expression determining
the number of cells required to represent the transitions from the state am ∈A:
H(am) = 2S0+G.
(7.26)

7.4 Hardware Reduction for BRLC
225
Table 7.24 Transformed structure table of Mealy FSM M0P(Γ11)
am
K(am)
as
K(as)
X1
h
Ph
Yh
Φh
h
a1
00
a2
01
x1
1
y1y2
D2
1
a2
01
¯x1
p1
y2y3
D2
2
a2
01
¯x1
¯p1
y3y4y5
D2
3
a2
01
a2
01
x3
1
y1y2
D2
4
a3
10
¯x3
p1
y3y6
D1
5
a2
11
¯x3
¯p1
y3y4y5
D2
6
a3
10
a4
11
x5
1
y4y6
D1D2
7
a4
11
¯x5
p1
y4y6
D1D2
8
a1
00
¯x5
¯p1
y1y2
–
9
a4
11
a1
00
1
1
y1y2
–
10
Table 7.25 Part of table of BIMF of Mealy FSM M0P(Γ11)
K(am)
X1
P
Y
Φ
v
h
T1T2
x1x3x5
p1
y1y2y3y4y5y6
D1D2
00
000
0
001110
01
1
3
00
000
1
011000
01
2
2
00
001
0
001110
01
3
3
00
001
1
011000
01
4
2
00
010
0
001110
01
5
3
00
010
1
011000
01
6
2
00
011
0
001110
01
7
3
00
011
1
011000
01
8
2
00
100
0
110000
01
9
1
00
100
1
110000
01
10
1
00
101
0
110000
01
11
1
00
101
1
110000
01
12
1
00
110
0
110000
01
13
1
00
110
1
110000
01
14
1
00
111
0
110000
01
15
1
00
111
1
110000
01
16
1
There is H(am) = 16 in the discussed case.
There is a part of the table of BIMF for FSM M0P(Γ11) represented by Table7.25.
This table represents the transitions from the state a1 ∈A.
There is the logic circuit of FSM M0P(Γ11) shown in Fig.7.20. We use LUTs
with S = 5 for implementing the circuit of LUTer. It is enough a single LUT to
implement the LUTer. There are two LUTs used for implementing the RG.

226
7
Design of EMB-Based Mealy FSMs
x2
Start
Clock
y1
y2
y3
y4
D2
LUT2
LUT3
T2
EMB
1
2
3
1
2
3
4
5
6
LUT1
x6
x4
T1
T2
7
8
4
T1
T2
p1
T1
D1
y6
y5
T
5
6
x1
x5
x3
Fig. 7.20 Logic circuit of Mealy FSM M0P(Γ11)
We investigated this approach for the benchmarks [18]. The results of investiga-
tions are represented by Table7.26.
As follows from Table7.26, this approach cannot be used for some benchmarks.
It is connected with the equality S0 = 0 for these cases. But it is quite possible that
the model of M0P FSM can be used for other FPGA chips.
Now let us discuss the ways for hardware reduction of LUTer for MPY Mealy
FSMs. Three approaches can be used [17]. The ﬁrst approach is based on the splitting
the set X. The second is connected with the special state assignment. The third
approach is based on the encoding of the logical conditions [17].
The splitting the set X by subsets X1, X2 is executed in the same manner as for
M0P Mealy FSM. It leads to M0PY Mealy FSM shown in Fig.7.21.
The LUTer implements the system P = P(T, X2), the block EMB1 the system
Φ = Φ(T, X1, P) and the system of additional variables
Z = Z(T, P, X1).
(7.27)
The block EMB2 implements the microoperations Y = Y(Z).
There are the following conditions determining the possibility for using the M0PY
FSM:
2S0+G+R0 · (R0 + RZ) ≤V0;
(7.28)
2RZ · N ≤V0.
(7.29)
The proposed design method for Mealy FSM M0PY(Γj) includes the following
steps:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of FSM P(Γj).

7.4 Hardware Reduction for BRLC
227
Table 7.26 Results of investigations for M0P Mealy FSMs
Name
Slice
Slice FF
LUT
BRAM
bbara
3
4
2
1
bbsse
4
4
3
1
bbtas
2
3
1
1
bbcount
2
3
1
1
cse
20
15
52
0
dk14
2
3
1
1
dk15
1
2
0
1
dk16
3
5
1
1
dk17
1
3
0
1
dk27
– – M0P cannot be used – –
dk512
– – M0P cannot be used – –
donﬁle
3
5
1
1
ex1
6
5
8
12
ex2
12
11
26
0
ex3
3
10
6
0
ex4
3
4
2
1
ex5
3
9
5
0
ex6
2
3
1
1
ex7
4
9
5
0
keyb
30
16
73
0
kirkman
28
21
59
0
lion
1
2
0
1
lion9
3
9
5
0
mark1
3
4
2
1
mc
2
2
1
1
modulo12
– – M0P cannot be used – –
opus
13
13
30
0
planet
9
6
14
7
planet1
9
6
14
7
pma
4
5
5
1
s1
7
5
11
3
s1488
5
6
7
7
s1494
5
6
7
7
s1a
7
5
11
3
s208
10
12
15
0
s27
2
3
2
1
s298
3
8
2
1
s386
3
4
3
1
s8
4
7
8
0
sand
5
5
6
28
(continued)

228
7
Design of EMB-Based Mealy FSMs
Table 7.26 (continued)
Name
Slice
Slice FF
LUT
BRAM
shifreg
– – M0P cannot be used – –
sse
4
4
3
1
styr
6
5
10
8
tav
1
2
0
1
tbk
2
5
0
1
tma
28
16
70
0
train11
5
9
5
0
train4
1
2
0
1
EMB1
Y
RG
T
X2
Start
Clock
P
LUTer
EMB2
X1
Z
Fig. 7.21 Structure diagram of M0PY Mealy FSM
4. Partitioning the set X by classes X1 and X2.
5. Replacement of logical conditions xl ∈X2.
6. Encoding of the collections of microoperations.
7. Constructing the transformed structure table.
8. Constructing the the table of BIMF.
9. Constructing the table of BMO.
10. Implementing the FSM logic circuit.
Let us discuss an example of design for Mealy FSM M0PY(Γ12). There is the
GSA Γ12 shown in Fig.7.22.
It is possible to ﬁnd the following sets and their parameters: X = {x1, . . . , x5},
L = 5, Y = {y1, . . . , y10}, N = 10, A = {a1, . . . , a6}, M = 6, R0 = 3, T =
{T1, T2, T3}, Φ = {D1, D2, D3}. Let us execute the state assignment in the trivial
way: K(a1) = 000, . . . , K(a6) = 101.
It allows constructing ST of Mealy FSM P(Γ12) This table includes H0 = 12
rows (Table7.27).
Let the FPGA chip in use include EMBs with the following conﬁgurations: 512
× 1, 256 × 2, 128 × 4, 64 × 8, 32 × 16 (bits). To implement the circuit of FSM
P(Γ12), it is necessary V0 = 28 × 13 = 3328 (bits). So, the replacement of logical
conditions should be used.
There are T0 = 7 different collections of microoperations in the vertices of GSA
Γ12. They are the following: Y1 = ∅, Y2 = {y1, y2, y8}, Y3 = {y3, y9}, Y4 = {y2, y4},

7.4 Hardware Reduction for BRLC
229
Start
End
a1
y1y2y8
a2
1
0
a5
x1
y3y9
y4y6y10
1
0
x1
x3
0
1
0
x2
y5y7
1
0
x4
a1
1
y3y9
y2y4
y3y5
y1y2y8
1
0
x5
a3
a4
a6
Fig. 7.22
Initial GSA Γ12
Y5 = {y3, y5}, Y6 = {y4, y6, y10}, Y7 = {y5, y7}. It is enough RZ = 3 variables zr ∈Z
for encoding of these collections.
Because of R0 +RZ = 6, the conﬁguration 64 × 8 should be chosen with SA = 6.
It gives G = 1, S0 = 2; therefore, there is |X1| = 2, |X2| = 3.
Let us represent the set X as X = X1 ∪X2 where X1 = {x2, x3} and X2 =
{x1, x4, x5}. The table of replacement of logical conditions for FSM M0PY(Γ12) is
represented by Table7.28.
The following equation can be derived from Table7.28
p1 = ¯T1 ¯T2x1 ∨T1 ¯T2 ¯T3x4 ∨T1 ¯T2T3x5.
(7.30)
There are six literals in the equation (7.30). It means that it is enough a single
LUT with S = 6 to implement the circuit of LUTer for Mealy FSM M0PY(Γ12).
Let us encode the collections of microoperations Yt ⊆Y in the trivial way:
K(Y1) = 000, . . . , K(Y7) = 110. Now, the transformed structure table of Mealy
FSM M0PY(Γj) can by constructed. The table includes the columns am, K(am), as,

230
7
Design of EMB-Based Mealy FSMs
Table 7.27 Structure table of Mealy FSM P1(Γ12)
am
K(am)
as
K(as)
Xh
Yh
Φh
h
a1
000
a2
001
x1x2
y1y2y8
D3
1
a2
001
x1¯x2
y3y9
D3
2
a3
010
¯x1
y2y4
D2
3
a2
001
a5
100
x1
y4y6y10
D1
4
a6
101
¯x1x3
y3y9
D1D3
5
a4
011
¯x1¯x3
y3y5
D2D3
6
a3
010
a4
011
1
y3y5
D2D3
7
a4
011
a6
101
1
y1y2y8
D1D3
8
a5
100
a2
001
x4
y1y2y8
D3
9
a1
000
¯x4
y5y7
–
10
a6
101
a1
000
x5
–
–
11
a4
011
¯x5
y3y5
D2D3
12
Table 7.28 Replacement of logical conditions for Mealy FSM M0PY(Γ12)
am
a1
a2
a3
a4
a5
a6
p1
x1
x1
–
–
x4
x5
Table 7.29 Transformed table of Mealy FSM M0PY(Γ12)
am
K(am)
as
K(as)
X1
h
Ph
Zh
Φh
h
a1
000
a2
001
x2
p1
z3
D3
1
a2
001
¯x2
p1
z2
D3
2
a3
010
1
¯p1
z2z3
D2
3
a2
001
a5
100
1
p1
z1z3
D1
4
a6
101
x3
¯p1
z2
D1D3
5
a4
011
¯x3
¯p1
z1
D2D3
6
a3
010
a4
011
1
1
z1
D2D3
7
a4
011
a6
101
1
1
z3
D1D3
8
a5
100
a2
001
1
p1
z3
D3
9
a1
000
1
¯p1
z1z2
–
10
a6
101
a1
000
1
p1
–
–
11
a4
011
1
¯p1
z1
D2D3
12
K(as), X1
h, Ph, Zh, Φh, h. The column Zh contains additional variables zr ∈Z which
are equal to 1 in the code K(Yt) written in the h-th row of the table. The transformed
ST of Mealy FSM M0PY(Γ12) is represented by Table7.29.
This table is a base for constructing the table of BIMF. The table of BIMF includes
the following columns: K(am), P, X1, Z, Φ, q. In the discussed case, transitions from
each state am ∈A are represented by 8 rows of the table of BIMF. There is the part of

7.4 Hardware Reduction for BRLC
231
Table 7.30 Part of table of BIMF for Mealy FSM M0PY(Γ12)
K(am)
P
X1
Z
Φ
q
h
T1T2T3
p1
x2x3
x1x2x3
D1D2D3
000
0
00
011
101
1
3
000
0
01
011
101
2
3
000
0
10
011
011
3
3
000
0
11
011
011
4
3
000
1
00
010
001
5
2
000
1
01
010
001
6
2
000
1
10
001
001
7
1
000
1
11
001
001
8
1
Table 7.31 Table of BMO for Mealy FSM M0PY(Γ12)
K(Yt)
Y
t
z1z2z3
y1
y2
y3
y4
y5
y6
y7
y8
y9
y10
000
0
0
0
0
0
0
0
0
0
0
1
001
1
1
0
0
0
0
0
1
0
0
2
010
0
0
1
0
0
0
0
0
1
0
3
011
0
1
0
1
0
0
0
0
0
0
4
100
0
0
1
0
1
0
0
0
0
0
5
101
0
0
0
1
0
1
0
0
0
1
6
110
0
0
0
0
1
0
1
0
0
0
7
111
0
0
0
0
0
0
0
0
0
0
8
this table for the discussed case (Table7.30). It represents the transitions from state
a1 ∈A.
The table of BMO includes the columns K(Yt), Y, t. In the discussed case, this
table is represented by Table7.31.
Let the FPGA chip in use include LUTs having S = 4. It means that the expression
(7.30) should be transformed in the following way:
p1 = ¯T1 ¯T2x1 ∨T1( ¯T2 ¯T3x4 ∨¯T2T3x5) = A ∨T1B.
(7.31)
There is the circuit of BRLC corresponding to the Eq.(7.31) shown in Fig.7.23a.
It includes three of LUTs.
The number of LUTs in the circuit of BRLC can be decreased due to the special
state assignment [17]. In this case set A is represented as A1 ∪A2. The set A1 includes
states am ∈A with conditional transitions, as well as the initial state a1 ∈A. The set
A2 includes states am ∈A with the unconditional transitions. The state assignment

232
7
Design of EMB-Based Mealy FSMs
T1
LUT1
T2
x1
x5
A
T2
LUT2
T3
x4
B
LUT3
T1
p1
T1
LUT1
T2
x4
p1
C
LUT2
T1
x5
x1
(a)
(b)
Fig. 7.23 Logic circuit of BRLC for Mealy FSM M0PY(Γ12) (a) and MEPY(Γ12) (b)
Fig. 7.24 Outcome of
special state assignment for
Mealy FSM P(Γ12)
starts from the states am ∈A1. The codes K(am) for states am ∈A1 correspond to
decimal numbers from 0 to M1 −1, where |A1| = M1.
It is enough RE variables Tr ∈T for encoding of the states am ∈A1, where
RE =

log2 M1

.
(7.32)
In the discussed case, there are the following sets: A1 = {a1, a2, a5, a6} and
A2 = {a3, a4}. There is RE = 2, so, the states am ∈A1 can be determined using only
state variables T2 and T3 (Fig.7.24).
This approach leads to MEPY Mealy FSM (Fig.7.25). There are RE variables in
the set T′ ⊆T. The only difference between the models of M0PY and MEPY FSMs
is reduced to the different forms of the system P. In the later case, it is represented
as
P = P(T′, X2).
(7.33)
EMB1
Y
RG
T
X2
Start
Clock
P
LUTer
EMB2
X1
Z
T
T
Fig. 7.25 Structural diagram of MEPY Mealy FSM

7.4 Hardware Reduction for BRLC
233
In the discussed case, the following equation can be found for the function p1 ∈P:
p1 = ¯T2x1 ∨T2 ¯T3x4 ∨T2T3x5 = ¯T2x1 ∨C.
(7.34)
There is the logic circuit of BRLC Fig.7.23b corresponding to (7.34). It requires
1,5 less amount of LUTs than its counterpart shown in Fig.7.23a.
The only difference between design methods for M0PY and MEPY FSMs is
reduced to the different state assignments. For MEPY Mealy FSM, the special state
assignment should be executed.
If G = 1, then the approach of encoding of logical conditions can be applied.
Let the symbol X(P) stand for the set of logical conditions replaced by the variable
pg ∈P. It is enough RL variables for encoding of the logical conditions xl ∈X(P):
RL =

log2 |X(P)|

.
(7.35)
Let us use the variables br ∈B for encoding of logical conditions. This approach
leads to MCPY Mealy FSM (Fig.7.26).
There are the following functions that differ this model from others. The LUTer
implements the function
P = P(B, X2).
(7.36)
The EMB1 implements the functions B used for the encoding of logical conditions.
It is the following system:
B = B(T, P, X1).
(7.37)
The design method for Mealy FSM MCPY(Γj) includes all steps of the method
for M0PY FSM. But the encoding of logical conditions is executed before the step of
their replacement. Let us discuss an example of design for Mealy FSM MCPY(Γ12).
The steps from 1 to 4 are executed before. There is the set X(P) = X2 =
{x1, x4, x5} with LP = 3. These logical conditions can be encoded using RL = 2
variables. It gives the set B = {b1, b2}. Let us encode the logical conditions in the
following manner: K(x1) = 00, K(x4) = 01 and K(x5) = 10. It gives the following
equation for the block BRLC:
EMB1
Y
RG
X2
Start
Clock
P
LUTer
EMB2
X1
Z
B
T
B
Fig. 7.26 Structural diagram of MCPY Mealy FSM

234
7
Design of EMB-Based Mealy FSMs
Table 7.32 Structure table of Mealy FSM MCPY(Γ12)
am
K(am)
as
K(as)
X1
h
Ph
Zh
Bh
Φh
h
a1
000
a2
001
x2
p1
z3
–
D3
1
a2
001
¯x2
p1
z2
–
D3
2
a3
010
1
¯p1
z2z3
–
D2
3
a2
001
a5
100
1
p1
z1z3
–
D1
4
a6
101
x3
¯p1
z2
–
D1D3
5
a4
011
¯x3
¯p1
z1
–
D2D3
6
a3
010
a4
011
1
1
z1
–
D2D3
7
a4
011
a6
101
1
1
z3
–
D1D3
8
a5
100
a2
001
1
p1
z3
b2
D3
9
a1
000
1
¯p1
z1z2
b2
–
10
a6
101
a1
000
1
p1
–
b1
–
11
a4
011
1
¯p1
z1
b1
D2D3
12
p1 = ¯b1 ¯b2x1 ∨b2x4 ∨b1x5 = A ∨C.
(7.38)
Let us encode the collections of microoperations as it is done for the M0PY(Γ7).
The transformed structure table of MCPY Mealy FSM includes all columns of its
counterpart for M0PY Mealy FSM. Also, it includes the column Bh with the variables
br ∈B equal to 1in the code K(xl) from the h-th row of the table.
Table7.32 represents the transformed ST of Mealy FSM MCPY(Γ12). There is
the additional column Bh in the table of BIMF. It contains the code K(xl). There are
the same tables of BMO for equivalent M0PY and MCPY Mealy FSMs. There is the
logic circuit of Mealy FSM MCPY(Γ12) shown in Fig.7.27.
This approach can be used if the following condition takes place:
b1
Start
Clock
D2
EMB1
1
2
3
LUT1
b2
4
z2
B
D1
5
y1
y2
y3
y4
EMB2
1
2
3
4
5
6
7
8
y6
y5
LUT3
z3
D3
T1
T2
T3
p1
x4
x5
6
LUT2
x1
b1
b2
1
2
3
4
5
6
7
8
x2
x3
T1
T2
T3
9
10
11
12
13
14
16
15
y7
y8
y9
y10
1
2
3
4
5
b1
b2
T
z1
z2
z3
z1
„0”
LUT3
LUT3
Fig. 7.27 Logic circuit of Mealy FSM MCPY(Γ12)

7.4 Hardware Reduction for BRLC
235
2R0+S0+G · (R0 + RZ + RL) ≤V0.
(7.39)
It there is G > 1, then logical conditions from different sets X(pg) should be
encoded using different variables br ∈B. We do not discus this approach in this
Chapter. Let us point out that the symbol RL in (7.39) stands for the number of bits
required for encoding the variables br ∈B.
There are different numbers of LUTs in different models of Mealy FSMs. We
show them in the ﬁnal table for the benchmarks [18]. It is Table7.33.
As we can see, there is diminishing for the number of LUTs for some benchmarks.
For example, it is necessary less than 50 % of LUTs for ex1 and planet. Sometimes,
there is increasing for this value. So, it is necessary to use a lot of different models for
Table 7.33 Results of investigations for different models of Mealy FSMs
Module
Number of LUT
Name
P
MP
PY
MPY
PH
MPH
M0P
M0PY
bbara
0
4
0
4
0
4
2
2
bbsse
0
8
0
8
0
8
3
3
bbtas
0
2
0
2
0
2
1
1
bbcount
0
3
0
3
0
3
1
5
cse
40
63
0
8
19
27
52
37
dk14
0
3
0
3
0
3
1
1
dk15
0
0
0
0
0
0
0
0
dk17
0
0
3
3
0
0
0
3
dk27
0
1
0
1
0
1
Not use
Not use
dk512
0
1
0
1
0
1
Not use
Not use
donﬁle
0
2
1
3
0
2
1
1
ex1
0
18
0
18
0
18
8
8
ex2
12
12
27
15
11
13
26
27
ex3
6
6
9
9
6
8
6
6
ex4
0
4
0
4
0
4
2
2
ex5
5
5
7
7
0
2
5
5
ex6
0
2
0
2
0
2
1
1
ex7
5
5
1
3
5
7
5
5
keyb
74
99
2
25
44
44
73
60
kirkman
54
188
77
99
88
409
59
106
lion
0
0
1
1
0
0
0
0
lion9
5
5
5
5
5
5
5
5
mark1
20
4
13
4
0
4
2
2
mc
0
2
0
2
0
2
1
1
modulo12
0
1
0
0
0
1
Not use
Not use
opus
21
6
17
6
10
6
30
19
(continued)

236
7
Design of EMB-Based Mealy FSMs
Table 7.33 (continued)
Module
Number of LUT
Name
P
MP
PY
MPY
PH
MPH
M0P
M0PY
planet
0
29
0
29
0
29
14
14
planet1
0
29
0
29
0
29
14
14
pma
89
15
85
15
89
15
5
5
s1
0
24
0
24
0
24
11
11
s1488
0
27
0
27
0
27
7
7
s1494
0
23
0
23
0
23
7
7
s1a
0
24
0
0
0
24
11
0
s208
13
19
0
9
28
37
15
15
s27
0
4
1
5
0
4
2
2
s298
0
4
5
9
0
4
2
7
s386
0
9
0
9
0
9
3
3
s8
8
11
0
0
5
5
8
9
sand
0
30
0
30
0
30
6
6
shifreg
0
0
0
0
0
0
Not use
Not use
sse
0
9
0
9
0
9
3
3
styr
0
20
0
20
0
20
10
10
tav
0
0
0
0
0
0
0
0
tbk
0
0
3
3
0
0
0
3
tma
52
54
59
49
38
42
70
60
train11
5
5
7
7
5
5
5
5
train4
0
0
1
1
0
0
0
0
the same GSA Γ . It means that an expert system is necessary in CAD tools used to
design FSM circuits. This system should make choosing the best model for a given
GSA Γ and a given FPGA chip.
References
1. I. Grout, Digital Systems Design with FPGAs and CPLDs (Elsevier Science, Oxford, 2008)
2. C. Maxﬁeld, The Design Warrior’s Guide to FPGAs (Academic Press Inc, Orlando, 2004)
3. Xilinx, http://www.xilinx.com. Accessed Jan 2015
4. Altera, http://www.altera.com. Accessed Jan 2015
5. T. Kim, T. Vella, R. Brayton, A. Sangiovanni-Vincentalli, Synthesis of Finite State Machines:
Functional Optimization (Kluwer Academic Publishers, Boston, 1997)
6. M. Nowicka, T. Łuba, M. Rawski, FPGA-based decomposition of Boolean functions: algo-
rithms and implementation. Adv Comput Syst, 502–509 (1999)
7. C. Scholl, Functional Decomposition with Application to FPGA Synthesis (Kluwer Academic
Publishers, Boston, 2001)

References
237
8. G. Sutter, E. Todorovich, S. López-Buedo, E. Boemo, Low-power FSMs in FPGA: encod-
ing alternatives, in Integrated Circuit Design. Power and Timing Modeling, Optimization and
Simulation (Springer, 2002), pp. 363–370
9. X. Wu, M. Pedram, L. Wang, Multi-code state assignment for low-power design. IEEE Proc.
Circuits Devices Syst. 147, 271–275 (2000)
10. J. Cong, K. Yan, Synthesis for FPGAs with embedded memory blocks, in Proceedings of the
2000 ACM/SIGDA 8th International Symposium on FPGAs (2000), pp. 75–82
11. M. Rawski, H. Selvaraj, T. Łuba, An application of functional decomposition in ROM-based
FSM implementation in FPGA devices. J. Syst. Archit. 51(6–7), 423–434 (2005)
12. M. Rawski, P. Tomaszewicz, G. Borowski, T. Łuba, Logic Synthesis Method of Digital Circuits
Designed for Implementation with Embedded Memory Blocks on FPGAs, in Design of Digital
Systems and Devices, LNEE 79, ed. by M. Adamski, A. Barkalov, M. We˛grzyn (Springerg,
Berlin, 2011), pp. 121–144
13. V. Sklyarov, Synthesis and implementation of RAM-based ﬁnite state machines in FPGAs, in
Proceedings of Field-Programmable Logic and Applications: The Roadmap to Reconﬁgurable
Computing (Springer, Villach, 2000), pp. 718–728
14. A. Tiwari, K. Tomko, Saving power by mapping ﬁnite-state machines into Embedded Memory
Blocks in FPGAs, in Proceedings of the conference on Design, Automation and Test in Europe,
vol. 2 (IEEE Computer Society, 2004), pp. 916–921
15. L. Garcia-Vargas, R. Senhadji-Navarro, A. Civit-Balcells, P. Guerra-Gutierrezz, ROM-based
ﬁnite state machine implementation in low cost FPGAs, in IEEE International Simposium on
Industrial Electronics (Vigo, 2007), pp. 2342–2347
16. S. Baranov, Logic Synthesis of Control Automata (Kluwer Academic Publishers, 1994)
17. V. Sklyarov, I. Skliarova, A. Barkalov, L. Titarenko, Synthesis and Optimization of FPGA-based
Systems, vol. 294, Lecture notes in electrical engineering (Springer, Berlin, 2014)
18. LGSynth93, International Workshop on logic synthesis benchmark suite (LGSynth93).
TAR, Benchmarks test, http://www.cbl.ncsu.edu:16080/benchmarks/LGSynth93/LGSynth93.
tar (1993)
19. Xilinx, Virtex-5 Family Overview. PDF, Xilinx Corporation, http://www.xilinx.com/support/
documentation/data_sheets/ds100.pdf, 2009

Chapter 8
Design of EMB-Based Moore FSMs
8.1 Trivial Implementing Moore FSMs
A Moore FSM can be implemented using single EMB if the following condition
takes place:
2L+R1 · (R1 + N) ≤V0.
(8.1)
In this case a single EMB represents both blocks BIMF and BMO (Fig.8.1). It is
a P Moore FSM.
There are the following steps in the design method of P Moore FSM:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table.
4. Constructing the table of EMB.
5. Implementing the FSM logic circuit with EMBs and LUTs of given FPGA chip.
Let us discuss an example of design for the Moore FSM P(Γ13). The GSA Γ13 is
showninFig.8.2.ItismarkedbystatesofMooreFSMusingtherules[2].Itispossible
to derive the following sets and their parameters from GSA Γ13: A = {a1, . . . , a5},
M1 = 5, X = {x1}, L = 1, Y = {y1, . . . , y4}, N = 4, R1 = 3, T = {T1, T2, T3},
and Φ = {D1, D2, D3}.
Letusencodethestatesam ∈A inthetrivialway: K(a1) = 000,…, K(a5) = 100.
Now, the ST can be constructed for the FSM P(Γ13). It is Table8.1. The column am
includes both the current state and the collection of MOs Y(am) ⊆Y.
There are the following columns in the table of EMB: K(am), X, Φ, Y, q. In the
discussed case, it includes 16 rows, but only 10 of them contain the useful data (the
input memory functions and microoperations). These rows are shown in Table8.2.
We add columns m (to show the current state am) and h (to shown the correspondence
among the rows of ST and table of EMB).
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6_8
239

240
8
Design of EMB-Based Moore FSMs
Fig. 8.1 Structural diagram
of single EMB-based P
Moore FSM
Functions
X
Y
Start
Clock
RG
Φ
T
Fig. 8.2 Graph-scheme of
algorithm Γ13
End
Start
a1
y1y2
a2
a3
a4
1
0
a5
a1
x1
y2y3
y3
y1y4
Table 8.1 Structure table of Moore FSM P(Γ13)
am
K(am)
as
K(as)
Xh
Φh
h
a1
000
a2
001
1
D3
1
a2(y1y2)
001
a3
010
x1
D2
2
a4
011
¯x1
D2D3
3
a3(y3)
010
a5
100
1
D1
4
a4(y1y4)
011
a5
100
1
D1
5
a5(y2y3)
100
a1
000
1
–
6
Analysis of benchmarks [9] shows that the condition (8.1) takes place for approx-
imately 20% of all examples. There is more probability that the following conditions
take places:
2L+R1 · (R1 + N) > V0;
(8.2)
R1 · 2L+R1 ≤V0;
(8.3)
N · 2R1 ≤V0.
(8.4)

8.1 Trivial Implementing Moore FSMs
241
Table 8.2 Table of EMB for Moore FSM P(Γ13)
K(am)
X
Φ
Y
q
m
h
T1T2T3
x1
D1D2D3
y1y2y3y4y5
000
0
001
00000
1
1
1
000
1
001
00000
2
1
1
001
0
011
11000
3
2
3
001
1
010
11000
4
2
2
010
0
100
00100
5
3
4
010
1
100
00100
6
3
4
011
0
100
10010
7
4
5
011
1
100
10010
8
4
5
100
0
000
01100
9
5
6
100
1
000
01100
10
5
6
EMB1
RG
X
T
Start
Clock
EMB2
Y
Φ
Fig. 8.3 Structural diagram of P Moore FSM
The condition (8.2) shows that it is impossible to use the model shown in Fig.8.1.
The condition (8.3) shows that it is enough a single EMB to implement the system
(1.4). The condition (8.4) shows that it is enough a single EMB to im3plement the
system (1.5). In this case, it is enough two of EMBs to implement the circuit of P
Moore FSM (Fig.8.3). Let us name this model as P Moore FSM, whereas the Pt
Moore FSM describes the model shown in Fig.8.1.
In P FSM, the EMB1 implements the system of input memory functions Φ,
whereas the EMB2 the system of MOs Y. There are the following steps in the design
method of P Moore FSM:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table.
4. Transformation of the structure table. Constructing the table of EMB1.
5. Constructing the table of microoperations (Table of EMB2).
6. Implementing the FSM logic circuit with EMBs and LUTs of given FPGA chip.

242
8
Design of EMB-Based Moore FSMs
Table 8.3 Transformed structure table of Moore FSM P(Γ13)
K(am)
X
Φ
q
h
T1T2T3
x1
D1D2D3
000
0
001
1
1
000
1
001
2
1
001
0
011
3
3
001
1
010
4
2
010
0
100
5
4
010
1
100
6
4
011
0
100
7
5
011
1
100
8
5
100
0
000
9
6
100
1
000
10
6
Table 8.4 Table of microoperations of Moore FSM P(Γ13)
K(am)
Y
m
T1T2T3
y1y2y3y4
000
0000
1
001
1100
1
010
0010
3
011
1001
2
100
0110
4
Let us discuss an example when the GSA Γ13 is used for implementing P Moore
FSM. We execute steps 1–3 before. There is the transformed ST of Moore FSM
P(Γ13) represented by Table8.3. Table8.4 represents the table of BMO for the dis-
cussed case.
Comparison of Tables8.2, 8.3 and 8.4 shows that Table8.3 includes three ﬁrst
columns of Table8.2. There are only 5 rows in the table of BMO in contrast to 10
rows of Table8.2. It is connected with the fact that the system Y does not depend on
logical conditions xe ∈X.
Let an FPGA chip in use include EMB having conﬁgurations 16 × 4 and 8 × 8.
The ﬁrst of them is used for implementing the transformed structure table. Both
conﬁgurations can be used for implementing the table of microoperations. Let us
choose the conﬁguration 8 × 8 for implementing the system Y. There is the logic
circuit of Moore FSM P(Γ13) shown in Fig.8.4.
In this circuit, LUT1–LUT3 are used for implementing the register RG. Let us
point out that both EMB1 and EMB2 have unused resources. If there are special
inputs of synchronization in EMBs, then there are no LUTs used in EMB-based
Moore FSMs.

8.1 Trivial Implementing Moore FSMs
243
EMB2
1
2
3
1
2
3
4
5
6
7
8
x1
Start
Clock
y1
y2
y3
y4
EMB 1
1
2
3
1
2
3
4
4
T1
T2
T3
D1
D2
D3
LUT1
LUT2
LUT3
T1
T1
T2
T3
T3
T
T2
Fig. 8.4 Logic circuit of Moore FSM P(Γ13)
If the conditions (8.3)–(8.4) are violated, then it is necessary to use different
methods of structural decomposition [2, 4, 5, 12] to diminish the hardware amount
in the EMB-based circuits of Moore FSMs.
The structural decomposition is reduced to increasing the number of structural
levels in an FSM circuit. There are the following methods of structural decompo-
sition [2, 4, 12]: (1) replacement of logical conditions; (2) encoding of collections
of microoperations; (3) encoding of the ﬁelds of compatible microoperations; (4)
encoding of the rows of structure table. Some of these methods were discussed in
this book. Let us continue the discussion.
8.2 Structural Decomposition for Moore FSMs
Let X(am) be a set of logical conditions determining transitions from the stateam ∈A
and let us deﬁne the following variable:
G = max(|X(a1)|, . . . , |X(am)|).
(8.5)
If the following condition takes place
G ≪L,
(8.6)
then the method of replacement of logical conditions [2] can be applied. Let P =
{p1, . . . , pG} be a set of additional variables used for the replacement of logical
conditions. To execute the replacement, a special table of replacement of logical
conditions should be constructed. In this table, the columns are marked by variables
pg ∈P, whereas the rows by states am ∈A. So, the table includes G columns and M
rows. If a variable pg ∈P replaces a logical condition xl ∈X in a state am ∈A, then
the symbol xl should be written on the intersection of the row am and the column
pg of the table. To minimize the hardware amount for a logic circuit used for the

244
8
Design of EMB-Based Moore FSMs
BRLC
RG
X
T
Start
Clock
BIMF
Y
P
BMO
Φ
Fig. 8.5 Structural diagram of M P Moore FSM
BER
RG
X
T
Start
Clock
BIMF
Y
Z
Φ
Fig. 8.6 Structural diagram of P H Moore FSM
replacement, the distribution of logical conditions is executed in such a manner that
each variable xl ∈X is always placed in the same column of the table. Of course,
such a distribution is not always possible.
The following system can be derived from the table of replacement:
P = P(T, X).
(8.7)
This system is implemented by a LUTer corresponding to the BRLC. It leads to
M P Moore FSM shown in Fig.8.5.
We discussed the methods of encoding of CMOs and ﬁelds of compatible MOs in
previous Chapters. In the case of Moore FSM, they are used only with the methods
of OCT. But it is possible to use the encoding of the rows of ST in case of Moore
FSM. It leads to the P H Moore FSM (Fig.8.6).
In P H FSM, the BER implements the functions (2.30). The number of variables
zr ∈Z is determined as
RH1 = ⌈log2H1⌉.
(8.8)
If EMBs are used for implementing the P H Moore FSM, then blocks BER and
BIMF are represented by the blocks EMB1 and EMB2, respectively (Fig.8.7).

8.2 Structural Decomposition for Moore FSMs
245
EMB 1
RG
X
T
Start
Clock
EMB2
Y
Z
Φ
Fig. 8.7 Structural diagram of EMB-based PH Moore FSM
There are the following steps in the design of PH Moore FSM:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of Moore FSM P(Γ j).
4. Encoding of the rows of structure table.
5. Constructing the transformed structure table.
6. Constructing the table of BER.
7. Constructing the table of BIMF.
8. Implementing the logic circuit of FSM with a particular FPGA chip.
Let us discuss an example of design for Moore FSM P H(Γ13). We executed the
ﬁrst three steps of this method before. There is H1 = 6 (it follows from Table8.1).
Using (8.8), the value RH1 = 3 can be found, as well as the set Z = {z1, z2, z3}.
Let us encode the terms Fh in the trivial way: K(F1) = 000, . . . , K(F6) = 101.
There are the following columns in the transformed ST: am, K(am), Xh, K(Fh), Zh,
h. There are the functions zr ∈Z shown in the columns Zh if the corresponding bits
are equal to 1 in the row h of the initial ST (h = 1, H1). There is the transformed ST
of Moore FSM P H(Γ13) represented by the Table8.5.
The table of BER is constructed on the base of the transformed ST. It includes the
following columns: K(am), X, Z, q. There are 16 rows in this table but only 10 of
them contains the useful data (Table8.6).
Table 8.5 Transformed table of Moore FSM P H(Γ13)
am
K(am)
Xh
K(Fh)
Zh
h
a1
000
1
000
–
1
a2
001
x1
001
z3
2
¯x1
010
z2
3
a3
010
1
011
z2z3
4
a4
011
1
100
z1
5
a5
100
1
101
z1z3
6

246
8
Design of EMB-Based Moore FSMs
Table 8.6 Table of BER of Moore FSM P H(Γ13)
K(am)
X
Z
q
h
T1T2T3
x1
z1z2z3
000
0
000
1
1
000
1
000
2
1
001
0
010
3
3
001
1
001
4
2
010
0
011
5
4
010
1
011
6
4
011
0
100
7
5
011
1
100
8
5
100
0
101
9
6
100
1
101
10
6
Table 8.7 Table of BIMF of Moore FSM P H(Γ13)
K(Fh)
Φ
X
h
z1z2z3
D1D2D3
y1y2y3
000
001
0000
1
001
011
1100
2
010
011
1100
3
011
100
0010
4
100
100
1001
5
101
000
0110
6
This table is constructed if BER is implemented using EMBs. If LUTs are used for
implementing the circuit of BER, then the functions Z(T, X) should be derived from
the transformed ST. There are RH1 of such equations. Each equation determines a
logic circuit of a particular LUTerzr (r = 1, RH1).
The table of BIMF is constructed on the base of the initial ST. It includes the
following columns: K(Fh), Φ, Y, h. In the discussed case, it is Table8.7.
We use the codes K(as) from the h-th row of the initial ST to ﬁll the column Φ
of the table of BIMF. The CMOs Yt ⊆Y are repeated for the rows corresponding to
the same current state am ∈A. Because of it, there is the same CMO in the rows 2
and 3 of Table8.7.
The P H model can be used if the following conditions take places:
2L+R1 · RH1 ≤V0;
(8.9)
2RH1 · (N + R1) ≤V0.
(8.10)

8.2 Structural Decomposition for Moore FSMs
247
BER
RG
X
T
Start
Clock
BIMF
Y
1
Z
Φ
Y
2
Fig. 8.8 Structural diagram of P H1 Moore FSM
Let it be violated the condition (8.10). Let us denote as t1(t2) the number of outputs
for EMB1 (EMB2). Let it be Δt free outputs in EMB1, where
Δt = t1 = RH1.
(8.11)
In this case, it is possible to implement up to Δt functions Φ ∪Y using the free
outputs of EMB1. Now, the following condition should be checked:
 N + R1 −Δt
t2

= 1.
(8.12)
In the condition (8.12) takes place, then the BIMF is implemented as a single
EMB. It leads to P H1 Moore FSM (Fig.8.8).
As follows from Fig.8.8, the set Y is divided by two disjoint sets Y 1 and Y 2.
There are up to Δt microoperations in the set Y 1.
Let us discuss the following examples. Let it be the following conﬁgurations of
EMB for a particular FPGA chip: 16 × 4 and 8 × 4, bits. Let us check the conditions
(8.9)–(8.10) for the Moore FSM P(Γ13). There is V0 = 64 (for EMB1) and V0 = 48
(for EMB2). So the following relations can be obtained:
16 × 4 ≤64;
(8.13)
8 × 7 = 56 > 48;
(8.14)
Δt = 1;
(8.15)
8 × 6 = 48.
(8.16)
The following conclusion can be done from analysis of (8.13)–(8.16). It is enough
a single EMB to implement the circuit of BER. It is necessary more than one EMB
to implement the BIMF. It is possible to implement one additional function by BER.
If one MO is deleted from Y, then it is possible to implement the circuit of BIMF by
a single EMB. There is the logic circuit of Moore FSM P H1(Γ13) shown in Fig.8.9.

248
8
Design of EMB-Based Moore FSMs
EMB2
1
2
3
4
5
6
x1
Start
Clock
y1
y2
y4
EMB1
1
2
3
4
T1
T2
T3
D1
D2
D3
LUT1
LUT2
LUT3
T1
z1
T2
z2
T3
z3
1
2
3
4
1
2
3
y1
T
Fig. 8.9 Logic circuit of Moore FSM P H1(Γ13)
EMB1
Y
RG
T
X
Start
Clock
Φ
P
LUTer
EMB2
Fig. 8.10 Structural diagram of M P Moore FSM
Let us name this approach as the distribution of microoperations (DMO). Let us
point out that this approach can be used in other models of FSMs (including Mealy
FSMs).
The RLC can be used for optimization of P Moore FSM. It leads to MP Moore
FSM (Fig.8.10). A block LUTer represents BRLC, a block EMB1 represents BIMF,
and a block EMB2 represents BMO.
As in the case of M P Mealy FSM, the LUTer implements the system (1.47). The
EMB1 implements functions (1.49), whereas the EMB2 the system (1.5). This model
can be applied if the following conditions take places:
2G+R1 · R1 ≤V0;
(8.17)
2R · N ≤V0.
(8.18)
There are the following steps in the design method of M P Moore FSM:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of FSM P(Γ j).
4. Replacement of logical conditions.
5. Constructing the system (1.47).
6. Constructing the transformed structure table.
7. Constructing the table of BIMF.

8.2 Structural Decomposition for Moore FSMs
249
Fig. 8.11 Initial GSA Γ14
Start
a5
1
0
x1
x2
y3
y1y2
x3
x4
y6y7
y3y5y6
End
a1
0
1
a2
0
1
0
1
a3
a4
a1
y2y4
a6
8. Constructing the table of BMO.
9. Implementing the FSM logic circuit with EMBs and LUTs of a particular FPGA
chip.
Let us discuss an example of design for Moore FSM M P(Γ14). The GSA Γ14 is
shown in Fig.8.11.
This GSA is marked by states of Moore FSM using the rules from [10]. The
following sets and their characteristics can be found for Moore FSM P(Γ14): A =
{a1, . . . , a6}, M1 = 6, X = {x1, . . . , x4}, L = 4, Y = {y1, . . . , y7}, N = 7, R = 3,
T = {T1, T2, T3} and Φ = {D1, D2, D3}.
Let the FPGA chip in use have V0 = 128 and let the following conﬁgurations of
EMBs exist: 128 × 1, 64 × 2, 32 × 4 and 16 × 8 (bits). For the FSM P(Γ14) the
following relation takes place: 2L+R1 · R1 = 128 × 3 > 128. Therefore, this model
cannot be used in the discussed case.
Let us encode the states am ∈A in the trivial way: K(a1) = 000, . . . , K(a6) =
101. Now, the ST can be constructed (Table8.8) for the Moore FSM P(Γ14).
As follows from this table, there are the following sets X(am) ⊆X: X(a1) =
{x1, x2}, X(a2) = X(a3) = X(a4) = {x3, x4}, X(a5) = X(a6) = ∅. Obviously,
there is G = 2 and P = {p1, p2}.
Let us check the conditions (8.17)–(8.18). For the discussed case there are:
25 · 3 = 96 < 128;
23 · 7 = 56 < 128.

250
8
Design of EMB-Based Moore FSMs
Table 8.8 Structure table of FSM P(Γ14)
am
K(am)
as
K(as)
Xh
Φh
h
a1(–)
000
a2
001
x1
D3
1
a3
010
¯x1x2
D2
2
a4
011
¯x1 ¯x2
D2D3
3
a2(y1y2)
001
a5
100
x3
D1
4
a6
101
¯x3x4
D1D3
5
a4
011
¯x3 ¯x4
D2D3
6
a3(y3)
010
a5
100
x3
D1
7
a6
101
¯x3x4
D1D3
8
a4
011
¯x3 ¯x4
D2D3
9
a4(y2y4)
011
a5
100
x3
D1
10
a6
101
¯x3x4
D1D3
11
a4
011
¯x3 ¯x4
D2D3
12
a5(y3y5y6)
100
a1
000
1
–
13
a6(y6y7)
101
a1
000
1
–
14
Table 8.9 Table of replacement of logical conditions for Moore FSM M P(Γ14)
am
a1
a2
a3
a4
a5
a6
p1
x1
x3
x3
x3
–
–
p2
x2
x4
x4
x4
–
–
It means that the model M P(Γ14) can be used. The table of replacement of logical
conditions is represented by Table8.9.
The following system of equations can be derived from Table8.9:
p1 = A1x1 ∨(A2 ∨A3 ∨A4)x3;
p2 = A1x2 ∨(A2 ∨A3 ∨A4)x4.
(8.19)
If variables Am ∈A are replaced by corresponding conjunctions, the system (8.19)
represents the system (1.47) for the given example.
The transformed structure table of Moore FSM M P(Γ j) is constructed in the
same way as its counterpart for Mealy FSM M P(Γ j). In the discussed example, it
is represented by Table8.10.
This table is a base for constructing the table of BIMF containing the following
columns: K(am), P, Φ, q. In the discussed example, this table includes 32 rows.
It is necessary 4 rows to represent transitions from any state am ∈A. Table8.11
represents the part of table BIMF for the state a3 ∈A.

8.3 Optimization of BIMF Based on Pseudoequivalent States
251
Table 8.10 Transformed structure table of Moore FSM M P(Γ14)
am
K(am)
as
K(as)
Ph
Φh
h
a1(–)
000
a2
001
p1
D3
1
a3
010
¯p1 p2
D2
2
a4
011
¯p1 ¯p2
D2D3
3
a2(y1y2)
001
a5
100
p1
D1
4
a6
101
¯p1 p2
D1D3
5
a4
011
¯p1 ¯p2
D2D3
6
a3(y3)
010
a5
100
p1
D1
7
a6
101
¯p1 p2
D1D3
8
a4
011
¯p1 ¯p2
D2D3
9
a4(y2y4)
011
a5
100
p1
D1
10
a6
101
¯p1 p2
D1D3
11
a4
011
¯p1 ¯p2
D2D3
12
a5(y3y5y6)
100
a1
000
1
–
13
a6(y6y7)
101
a1
000
1
–
14
Table 8.11 Part of table of BIMF for FSM M P(Γ14)
K(am)
P
Φ
v
h
T1T2T3
p1 p2
D1D2D3
010
00
011
9
9
010
01
101
10
8
010
10
100
11
7
010
11
100
12
7
8.3 Optimization of BIMF Based on Pseudoequivalent States
One of the speciﬁc features of Moore FSM is existence of classes of pseudoequivalent
states [4]. The states am, as ∈A are pseudoequivalent states if outputs of correspond-
ing operator vertices are connected with the input of the same vertex of GSA Γ . Lets
us ﬁnd the partition A of the set A by classes of pseudoequivalent states B1, . . . , BI.
Let us repeat the main issues concerning the methods based on PES. Let us point
out that the corresponding methods where proposed for FPGA-based Moore FSM
in [12].
Two approaches can be used for optimizing the BIMF of Moore FSM. The ﬁrst of
them is the optimal state assignment. In this case, the states are encoded in such a way
that each class Bi ∈A is represented by minimum possible amount of generalized
intervals of R1-dimensional Boolean space. The second approach is connected with
encoding of the classes Bi ∈A. Let us discuss these approaches and corresponding

252
8
Design of EMB-Based Moore FSMs
T3T4
T1T2
00
01
11
10
0
1
a1
a2
a5
a3
∗
∗
∗
a4
Fig. 8.12 Optimal state codes for Moore FSM P(Γ13)
EMB1
RG
X
T
Start
Clock
EMB2
Y
Φ
T
’
Fig. 8.13 Structural diagram of P0 Moore FSM
model of EMB-based Moore FSMs. Let us use the GSA Γ13 for illustrating these
approaches.
There is the following partition A = {B1, . . . , B4} for the GSA Γ13 (Fig.8.2).
There are the following classes Bi ∈A: B1 = {a1}, B2 = {a2}, B3 = {a3, a4} and
B4 = {a5}. So there is I = 4. Let us encode the states am ∈A in the optimal way
(Fig.8.12).
The transitions from the state a5 do not present in the structure table because they
are executed automatically (using only pulse Clock). Because of it, the code of state
a5 can be treated as “don’t care” and can be included into the cubes for one of other
classes Bi ∈A.
Taking it into account, the following codes can be obtained for classes Bi ∈A
in the discussed case: K(B1) = ∗∗0, K(B2) = ∗01, K(B3) = ∗11. So, the value
of T1 is not signiﬁcant to determine the classes Bi ∈A. In the general case this
approach leads to EMB-based Moore FSM P0(Γ j). Its structural diagram is shown
in Fig.8.13.
In the P0 FSM, the BIMF is represented by the block EMB1. It implements the
system
Φ = Φ(T ′, X).
(8.20)
The block EMB2 implements the system (1.5). The following condition should take
place for implementing this model:
R1 · 2L+RE ≤V0.
(8.21)

8.3 Optimization of BIMF Based on Pseudoequivalent States
253
The value of RE is determined by the capital number of the set T ′ ⊆T . The
proposed design method for P0 Moore FSM is the following one:
1. Constructing the set of states A.
2. Optimal state assignment.
3. Constructing the transformed structure table.
4. Constructing the table of BIMF.
5. Constructing the table of microoperations.
6. Implementation of the FSM logic circuit.
Let us discuss an example of design for P0(Γ13). Let it be the EMBs with the
following conﬁgurations: 32 × 1, 16 × 2, 8 × 4, bits. Because there is R1 = 3, the
conﬁguration 8 × 4 should be chosen. But because of R1 + L = 4, the number of
cells should be equal to 16 for tF = 4. It is tF = 2 for V = 16. So, the model P(Γ13)
cannot be used.
Let us use the state codes from Fig.8.12. Analysis of the state codes shows that
there is RE = 2. Now, there is 21+2 × 3 = 24 < 32. It means that the condition
(8.21) is satisﬁed and it is possible to use the model P0(Γ13).
To construct the transformed structure table of P0 Moore FSM, it is necessary to
construct the system of generalized formulae of transitions for classes Bi ∈A. This
system does not include the class B4 ∈A because the state a5 ∈B4 is connected
only with state a1 ∈A. The following system can be derived from GSA Γ13:
B1 →a2;
B2 →x1a3 ∨¯x1a4;
B3 →a5.
(8.22)
The system (8.22) is the base for constructing the transformed ST of Moore FSM
P0(Γ13) shown by the Table8.12.
Using this table, it is possible to construct the table of BIMF. It contains the
columns K(Bi), X, Φ, q. It includes only 8 rows for discussed case (Table8.13).
We hope there is the transparent connection between Tables8.12 and 8.13. For
example, four rows of Table8.13 (namely, the rows 1, 2, 5 and 6) correspond to the
row 1 of the Table8.12. Next, two rows of Table8.13 (rows 7, 8) correspond to the
row 4 of Table8.12. And so on.
Table 8.12 Transformed structure table of Moore FSM P0(Γ13)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
**0
a2
001
1
D3
1
B2
*01
a3
011
x1
D2D3
2
a4
111
¯x1
D1D2D3
3
B3
*11
a5
010
1
D2
4

254
8
Design of EMB-Based Moore FSMs
Table 8.13 Table of BIM of Moore FSM P0(Γ13)
K(Bi)
X
Φ
q
h
T2T3
x1
D1D2D3
00
0
001
1
1
00
1
001
2
1
01
0
111
3
3
01
1
011
4
2
10
0
001
5
1
10
1
001
6
1
11
0
010
7
4
11
1
010
8
4
Table 8.14 Table of microoperations of Moore FSM P0(Γ13)
K(am)
Y
m
T1T2T3
y1y2y3y4
000
0000
1
001
1100
2
010
0110
3
011
0010
4
100
0000
5
101
0000
6
110
0000
7
111
1001
8
There is the same approach used for constructing the table of MOs as, for exam-
ple, for P Moore FSM. In the discussed case, the table of MOs is represented by
Table8.14.
There is the logic circuit of FSM P0(Γ13) shown in Fig.8.14. We use EMBs with
the conﬁguration 8 × 4 to implement the circuits of BIMF and BMO.
It is quite possible the situation when T ′ = T after the execution of optimal state
assignment [4]. In this case the following approach can be used.
Let us encode each class Bi ∈A by a binary code K(Bi) having RA bits. The
value of RA is determined as (4.17).
Let us use the variables τr ∈τ for the encoding, where |τ| = RA. Let the following
condition take place:
2RA+L · R1 ≤V0;
2R · (N + RA) ≤V0.
(8.23)
In this case, we propose to use the PC Moore FSM. Its structural diagram is shown
in Fig.8.15.

8.3 Optimization of BIMF Based on Pseudoequivalent States
255
EMB2
1
2
3
1
2
3
4
x1
Start
Clock
y1
y2
y3
y4
EMB 1
1
2
3
1
2
3
4
T2
T3
D1
D2
D3
LUT1
LUT2
LUT3
T1
T1
T2
T2
T3
T3
T’
T
Fig. 8.14 Logic circuit of Moore FSM P0(Γ13)
EMB1
RG
X
T
Start
Clock
EMB2
Y
Φ
τ
Fig. 8.15 Structural diagram of PC Moore FSM
In PC Moore FSM, the block EMB1 corresponds to BIMF. It implements the
system of input memory functions
Φ = Φ(τ, X).
(8.24)
The block EMB2 implements the circuit of BMO. It generates the functions Y
and the system of additional variables
τ = τ(T ).
(8.25)
The proposed design method for PC Moore FSM includes the following steps:
1. State assignment.
2. Finding the partition A = {B1, . . . , BI}.
3. Encoding of the classes Bi ∈A.
4. Constructing the transformed structure table.
5. Constructing the table of BIMF.
6. Constructing the table of BMO.
7. Implementation of the FSM logic circuit.

256
8
Design of EMB-Based Moore FSMs
Table 8.15 Transformed structure table of Moore FSM PC(Γ13)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
00
a2
001
1
D3
1
B2
01
a3
010
x1
D2
2
a4
011
¯x1
D2D3
3
B3
10
a5
100
1
D1
4
Table 8.16 Table of BIMF of Moore FSM PC(Γ13)
K(Bi)
X
Φ
v
h
τ1τ2
x1
D1D2D3
00
0
001
1
1
00
1
001
2
1
01
0
011
3
3
01
1
010
4
2
10
0
100
5
4
10
1
100
6
4
11
0
000
7
0
11
1
000
8
0
Let us discuss an example of design for Moore FSM PC(Γ13). The set A includes
M1 = 5 elements and there is R1 = 3. Let us encode the states am ∈A in the trivial
way: K(a1) = 000, . . . , K(a5) = 100.
There is the partition A = {B1, . . . , B4} with IA = 4. It gives RA = 2. Let us
encode the classes Bi ∈A in the trivial way: K(B1) = 00, . . . , K(B4) = 11.
To construct the transformed structure table, the system of generalized formulae
of transitions should be derived from a GSA Γ j. In the discussed case, this system is
represented by (8.22). The transformed structure table of PC Moore FSM includes
the same columns as its counterpart for P0 Moore FSM (Table8.15).
The table of BIMF is constructed on the base of the transformed structure table.
In the discussed case, it is represented by Table8.16.
The table of BMO includes the additional column τ (Table8.17). If there is am ∈
Bi, then the row corresponding to the state am includes the code K(Bi).
There is the logic circuit of Moore FSM PC(Γ13) shown in Fig.8.16. There is an
EMB with conﬁguration 8 × 6 required for implementing the circuit of BMO.
It is possible to decrease the requirements to EMBs implementing the BIMF. But
using PES makes impossible the applying DMO approach. There are not all variables
Tr ∈T entering the BIMF for P0 Moore FSM. There are no variables Tr ∈T entering
the BIMF for PC Moore FSM.

8.4 Optimizing LUTer in Replacement of Logical Conditions
257
Table 8.17 Table of BMO of Moore FSM PC(Γ13)
K(am)
Y
τ
m
T1T2T3
y1y2y3y4
τ1τ2
000
0000
00
1
001
1100
01
2
010
0010
10
3
011
1001
10
4
100
0110
11
5
101
0000
00
6
110
0000
00
7
111
1001
00
8
EMB2
1
2
3
1
2
3
4
x1
Start
Clock
y1
y2
y3
y4
EMB1
1
2
3
1
2
3
4
1
2
D1
D2
D3
LUT1
LUT2
LUT3
T1
T2
T3
5
6
1
2
τ
τ
τ
τ
τ
Fig. 8.16 Logic circuit of FSM of PC(Γ13)
8.4 Optimizing LUTer in Replacement of Logical Conditions
There are eight different approaches targeting the hardware reduction for LUT-based
BRLC. There are the following approaches for Moore FSMs [6, 12]:
1. Optimal state assignment (ME PE FSMs).
2. Transforming the codes of PES into the codes of classes of PES (MC PC FSMs).
3. Splitting logical conditions (M0P FSMs).
4. Special state assignment (MS P FSMs).
5. Special class assignment (MS PC FSMs).
6. Splitting logical conditions and optimal state assignment (M0E PE FSMs).
7. Splitting logical conditions and transformation of PES (M0C PC FSMs).
8. Encoding of logical conditions (MK P FSMs).
Let us discuss these approaches. The approaches 1, 2, 5, 6, 7 are based on the partition
ΠA = {B1, . . . , BI}.

258
8
Design of EMB-Based Moore FSMs
EMB1
Y
RG
T
X
2
Start
Clock
Φ
P
LUTer
EMB2
X
1
Fig. 8.17 Structural diagram of FSM of PC(Γ13)
Let us start from the splitting logical conditions. Let the following condition take
place:
SA > G + R1.
(8.26)
It means that there are S0 “free” inputs of EMB implementing the circuit of BIMF.
As it is for the case of Mealy FSMs, we propose to use these inputs for optimizing
the LUTer representing the BRLC [8]. The number S0 is determined as:
S0 = SA −(G + R1).
(8.27)
As it is in the case of M0P Mealy FSMs, let us split the set X and represent it as
X1 ∪X2. Let the following condition take place:
SA = G + R1 + |X1|.
(8.28)
It means that only logical conditions xl ∈X2 should be transformed by the
LUTer. The logical conditions xl ∈X1 enter the BIMF. It leads to M0P Moore FSM
(Fig.8.17).
The LUTer implements the system (7.20), the EMB1 implements the system
(7.21). As in the previous case, the EMB2 implements the system (1.5). This model
can be used if the following condition takes place:
2G+SC+R1 · R1 ≤V0.
(8.29)
There are the following steps in the design method for M0P Moore FSM:
1. Constructing the set of states A.
2. State assignment.
3. Constructing the structure table of FSM P(Γ j).
4. Partitioning the set X by subsets X1 and X2.
5. Replacement of logical conditions xl ∈X2.
6. Constructing the transformed structure table.
7. Constructing the table of BIMF.
8. Constructing the table of BMO.
9. Implementing the FSM logic circuit.

8.4 Optimizing LUTer in Replacement of Logical Conditions
259
Let us discus an example of design for Moore FSM M0P(Γ14). In the previous
sections, we found all sets and their parameters for the FSM P(Γ14). Let us encode
the states am ∈A in the trivial way: K(a1) = 000, . . . , K(a6) = 101. The ST of
P(Γ14) is represented by Table8.8.
Let an FPGA chip in use include EMBs having the following conﬁgurations:
256 × 1, 128 × 2, 64 × 4, 32 × 8 (bits). In this case the model P(Γ14) cannot
be applied. For Moore FSM M P(Γ14), there is G = 2. So, there is 2G+R1 · R1 =
32 × 3 = 96 < 256. It means that the model M P(Γ14) can be used. In this case,
there are 160 bits of EMB which are not used. Let us try to use them due to applying
the model M0P(Γ14).
There is R1 = 3, then the conﬁguration 64×4 can be chosen. In this case SA = 6
and SA −R1 = 3. So, two possibilities can be used for the replacement of logical
conditions: (1) G = 2 and |X1| = 1 and (2) G = 1 and |X1| = 2. There are the
following sets X(am) ⊆X: X(a1) = {x1, x2}, X(a2) = X(a3) = X(a4) = {x3, x4}
and X(a5) = X(a6) = ∅. Let us divide the set X by following subsets: X1 = {x2, x4}
and X2 = {x1, x3}. It gives P = {p1} and the following equation can be found:
p1 = A1x1 ∨A2x3 ∨A3x3 ∨A4x3.
(8.30)
There is the ST of Moore FSM M0P(Γ14) shown in Table8.18. It is constructed
as a transformation of the initial ST (Table8.8).
There are Q = 64 rows in the table of BIMF in the discussed case. It is determined
by the formula
Q = 2G+R1+L1.
(8.31)
Table 8.18 Transformed structure table of Moore FSM M0 P(Γ14)
am
K(am)
as
K(as)
X1
h
Ph
Φh
h
a1(−)
000
a2
001
1
p1
D3
1
a3
010
x2
¯p1
D2
2
a4
011
¯x2
¯p1
D2D3
3
a2(y1y2)
001
a5
100
1
p1
D1
4
a6
101
x4
¯p1
D1D3
5
a4
011
¯x4
¯p1
D2D3
6
a3(y3)
010
a5
100
1
p1
D1
7
a6
101
x4
¯p1
D1D3
8
a4
011
¯x4
¯p1
D2D3
9
a4(y2y4)
011
a5
100
1
p1
D1
10
a6
101
x4
¯p1
D1D3
11
a4
011
¯x4
¯p1
D2D3
12
a5(y3y5y6)
100
a1
000
1
1
–
13
a6(y6y7)
101
a1
000
1
1
–
14

260
8
Design of EMB-Based Moore FSMs
Table 8.19 Part of table of BIMF of Moore FSM M0 P(Γ14)
K(am)
X1
P
Φ
v
h
T1T2T3
x2x4
p1
D1D2D3
000
00
0
011
1
3
000
00
1
001
2
1
000
01
0
011
3
3
000
01
1
001
4
1
000
10
0
010
5
2
000
10
1
001
6
1
000
11
0
010
7
2
000
11
1
001
8
1
x1
Start
Clock
D2
LUT3
LUT4
EMB1
1
2
3
1
2
3
4
LUT1
T1
x3
T2
T3
4
x2
x4
T1
T2
p1
D1
T
T1
T2
T3
5
y1
y2
y3
y4
EMB2
1
2
3
1
2
3
4
5
6
7
8
4
„0”
y5
LUT2
T3
D3
T1
T2
T3
6
5
„0”
y6
Fig. 8.18 Logic circuit of Moore FSM M0 P(Γ14)
There is L1 = |X1| in the formula (8.31). Table8.19 represents a part of the table
of BIMF for M0P(Γ14). There are the transitions from the state a1 ∈A shown in
Table8.19.
The table of BMO is the same as for P(Γ14). There is a logic circuit of Moore
FSM M0P(Γ14) shown in Fig.8.18. It is enough a single LUT having S = 5 to
implement the LUTer. To implement the circuit of BIMF, they use an EMB with
the conﬁguration 64 × 4. There is an EMB with the conﬁguration 32 × 8 used for
implementing the circuit of BMO. Let us point out that both EMBs have free outputs.
There is one free output for EMB1 and two free outputs for EMB2.
Let us use the state codes K(am) and represent the Eq.(8.30) as the following
one:
p1 = ¯T1 ¯T2 ¯T3x1 ∨¯T1 ¯T2T3x3 ∨¯T1T2 ¯T3x3 ∨T1 ¯T2 ¯T3x3.
(8.32)
We used LUT with S = 5 to implement this equation.
Now let us discuss the case when there is S = 4.
If there is S = 4, then the expression (8.32) should be transformed using the rules
of functional decomposition [1, 7]. The transformed equation is the following:
p1 = ¯T1( ¯T2 ¯T3x1 ∨¯T2T3x3 ∨T2 ¯T3x3) ∨T1( ¯T2 ¯T3x3).
(8.33)

8.4 Optimizing LUTer in Replacement of Logical Conditions
261
Fig. 8.19 Logic circuit of
LUTer for S = 4
T2
LUT1
T3
x1
x3
p1
A
T2
LUT2
T3
x3
B
LUT3
T1
Fig. 8.20 Optimal state
codes for Moore FSM
P(Γ14)
T3T4
T1T2
00
01
11
10
0
1
a1
a2
a5
a3
∗
a4
a6
∗
Fig. 8.21 Optimal circuit of
LUTer
T2
LUT1
T3
x1 x3
p1
p1
x1
T3
x3
LUT1
(a)
(b)
The equation (8.33) corresponds to the logic circuit of LUTer shown in Fig.8.19.
In Fig.8.19, there are A = ¯T2 ¯T3x1 ∨¯T2T3x3 ∨T2 ¯T3x3 and B = ¯T2 ¯T3x3. This
circuit has 2 levels and uses 3 LUTs with S = 4. Let us try to improve this circuit
using pseudoequivalent states of Moore FSM [11, 13].
There is the partition A = {B1, B2, B3} in the case of Moore FSM P(Γ14). There
are the following classes Bi ∈A: B1 = {a1}, B2 = {a1, a2, a3} and B3 = {a5, a6}.
Let us encode the states am ∈A as it is shown in Fig.8.20.
Using this codes, we can ﬁnd that the Eq.(8.32) is transformed into the following
one:
p1 = ¯T2 ¯T3x1 ∨T3x3.
(8.34)
This equation corresponds to the single-level logic circuit shown in Fig. 8.21a.
Because X(a5) = X(a6) = ∅, their codes can be treated as “don’t care” for
function p1. It allows obtaining the following equation:
p1 = ¯T3x1 ∨T3x3.
(8.35)

262
8
Design of EMB-Based Moore FSMs
EMB1
Y
RG
T
X
2
Start
Clock
Φ
P
LUTer
EMB2
X
1
T
’
Fig. 8.22 Structural diagram of Moore FSM M0E PE(Γ j)
It is enough a single LUT having S = 3 to implement the circuit of LUTer
corresponding to (8.35). This circuit is shown in Fig.8.21.
Obviously, this approach is based on the optimal state assignment [3]. Using this
approach, the model of M0E PE Moore FSM can be proposed (Fig.8.22).
In this model, the LUTer implements the system
P = P(T ′, X2).
(8.36)
The EMB1 implements the system
Φ = Φ(T ′, P, X2).
(8.37)
Let it be RE = |T ′|. In this case the proposed model can be used if the following
condition takes place:
2RE+S0+G · R1 ≤V0.
(8.38)
There are the following codes K(Bi) derived from Fig.8.20: K(B1) = ∗00,
K(B2) = ∗∗1 and K(B3) = ∗10. It gives T ′ = {T2, T3} and RE = 2.
There are the following steps in the design method for M0E PE Moore FSM:
1. Constructing the set of states A.
2. Constructing the partition ΠA = {B1, . . . , BI}.
3. Optimal state assignment.
4. Constructing the structure table of Moore FSM PE(Γ j).
5. Partitioning the set X by subsets X1 and X2.
6. Replacement of logical conditions xl ∈X2.
7. Constructing the transformed structure table.
8. Constructing the table of BIMF.
9. Constructing the table of BMO.
10. Implementing the FSM logic circuit.
Let us discuss an example of design of Moore FSM M0E PE(Γ14). There are the
sets A = {a1, . . . , a6} and ΠA = {B1, B2, B3} found before. Let us encode the states
am ∈A in the optimal way as it is shown in Fig.8.20.

8.4 Optimizing LUTer in Replacement of Logical Conditions
263
Table 8.20 Structure table of PE(Γ14)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
*00
a2
001
x1
D3
1
a3
011
¯x1x2
D2D3
2
a4
101
¯x1 ¯x2
D1D3
3
B2
**1
a5
010
x3
D2
4
a6
110
¯x3x4
D1D2
5
a4
101
¯x3 ¯x4
D1D3
6
B3
*10
a1
000
1
–
7
To construct the structure table of PE(Γ14), let us ﬁnd the system of generalized
formulae of transitions [4]. In the discussed case, it is the following system:
B1 →x1a2 ∨¯x1x2a3 ∨¯x1 ¯x2a4;
B2 →x3a5 ∨¯x3x4a6 ∨¯x3 ¯x4a4;
B3 →a1.
(8.39)
This system is used for constructing the transformed ST of Moore FSM PE(Γ14).
It is Table8.20. This table includes the following columns: Bi, K(Bi), as, K(as),
Xh, Φh, h. The codes K(Bi) of classes Bi ∈A are taken from Fig.8.20, as well as
the codes of states am ∈A.
Let the FPGA chip in use have EMBs with the following conﬁgurations: 128×1,
64 × 2, 32 × 4, 16 × 8 (bits). Because there is R1 = 3, we should choose the
conﬁguration 32 × 4 for implementing the circuit of BIMF. There is T ′ = {T2, T3}
and, therefore, RE = 2. For given conﬁguration, there is SA = 5. It means that three
inputs can be used for logical conditions xl ∈X1 and additional variables pg ∈P.
Let us make the following partition of the set X: X1 = {x2, x4} and X2 = {x1, x3}.
It gives P = {p1}.
It is possible to derive the following equation from Table8.20:
p1 = B1x1 ∨B2x3 = ¯T2 ¯T3x1 ∨T3x3.
(8.40)
Let X(Bi) be a set of logical conditions determining transitions from states am ∈
Bi (i = 1, I). Because X(B3) = ∅, the codes of states a5, a6 ∈B3 can be treated as
“don’t cares”. It gives the ﬁnal form of the system (1.47) for the given example:
p1 = T3x1 ∨T3x3.
(8.41)
There are the following columns in the transformed ST of M0E PE Moore FSM:
Bi, K(Bi), as, K(as), Ph, X1
h, Φh, h. In the discussed case it is represented by
Table8.21.

264
8
Design of EMB-Based Moore FSMs
Table 8.21 Transformed structure table of Moore FSM M0E PE(Γ14)
Bi
K(Bi)
as
K(as)
Ph
X1
h
Φh
h
B1
*00
a2
001
p1
1
D3
1
a3
011
¯p1
x2
D2D3
2
a4
101
¯p1
¯x2
D1D3
3
B2
**1
a5
010
p1
1
D2
4
a6
110
¯p1
x4
D1D2
5
a4
101
¯p1
¯x4
D1D3
6
B3
*10
a1
000
1
1
–
7
Table 8.22 Part of the table of BIMF for Moore FSM M0E PE(Γ14)
K(Bi)
P
X1
Φ
v
h
T2T3
p1
x2x4
D1D2D3
00
0
00
101
1
3
00
0
01
101
2
3
00
0
10
011
3
2
00
0
11
011
4
2
00
1
00
001
5
1
00
1
01
001
6
1
00
1
10
001
7
1
00
1
11
001
8
1
The table of BIMF of M0E PE Moore FSM includes the following columns:
K(Bi), P, X1, Φ, h. The columns K(Bi), P, X1 create the address of a cell inside the
EMB. In the discussed case, the transitions from each class Bi ∈A are represented
by 8 rows of this table. The transitions from the class B1 ∈A are represented by
Table8.22.
The table of BMO is always the same for given GSA. It includes the columns
K(am), Y, m. The address of a cell is determined by the state code K(am). We do
not show this table for M0E PE Moore FSM.
Let us use the following logic elements for implementing the logic circuit of
M0E PE(Γ14): a LUT having S = 3, EMBs with the conﬁgurations 32 × 4 and
16 × 8. In this case, all parts of the FSM circuit are implemented as single elements.
The only difference is that RG required R1 of LUTs. There is the logic circuit of
M0E PE(Γ14) shown in Fig.8.23.
Due to the optimal state encoding, the circuit of BRLC is implemented using only
one LUT with S = 3. To implement the Eq.(8.32) with LUTs having three inputs,
it should be decomposed: p1 = T1(T2 ¯T3x3) ∨¯T1(T2( ¯T3x3) ∨¯T2( ¯T3x1 ∨T3x3)) =
T1A ∨¯T1(T2B ∨¯T2C) = T1A ∨¯T1D.
This equation corresponds to the circuit having three layers formed by 5 LUTs.
This circuit is shown in Fig.8.24.

8.4 Optimizing LUTer in Replacement of Logical Conditions
265
x1
Start
Clock
D2
LUT3
LUT4
EMB1
1
2
3
1
2
3
4
LUT1
x3
T3
4
x2
x4
T2
P1
D1
T
T1
T2
T3
5
y1
y2
y3
y4
EMB2
1
2
3
1
2
3
4
5
6
7
8
4
„0”
y6
y5
LUT2
T3
D3
T1
T2
T3
T’
T’
p1
Fig. 8.23 Logic circuit of Moore FSM M0E PE(Γ14)
T2
LUT1
T3
T2
x3
p1
A
T3
x3
B
T1
T3
x1
x3
C
LUT2
LUT3
LUT4
LUT5
D
Fig. 8.24 Logic circuit of BRLC based on trivial state codes
BIMF
Y
RG
T
X
Start
Clock
Φ
P
LUTer
BMO
T
'
Fig. 8.25 Structural diagram of ME PE Moore FSM
So, the proposed approach allows 5 times reduction for the hardware of BRLC,
as well as 3 times acceleration for the propagation time. Of course, it is true only for
the given example.
There are two approaches combined in M0E PE Moore FSM: (1) the splitting
logicalconditionsand(2)theoptimalstateassignment.LetuspointoutthattheLUTer
can be improved without the splitting logical conditions. It is possible if S0 = 0. In
this case, the Moore FSM is represented by ME PE Moore FSM (Fig.8.25).

266
8
Design of EMB-Based Moore FSMs
EMB1
Y
RG
T
X
2
Start
Clock
Φ
P
LUTer
EMB2
X
1
τ
Fig. 8.26 Structure diagram of M0C PC Moore FSM
There is the following system P implemented by LUTer:
P = P(T ′, X).
(8.42)
There are the same steps in design methods of M P and ME PE FSMs. The only
difference is reduced to the method of state assignment.
If there is no hardware reduction due to the optimal state assignment, then they
can use the transformation of state codes am ∈Bi into the class codes Bi ∈A.
There are RA bits in the codes K(Bi). This value is determined by (4.3).
Let the following conditions take places:
S0 = SA −(RA + G) > 0;
(8.43)
2RA+S0+G · R1 ≤V0.
(8.44)
The condition (8.43) shows that it is possible to use the splitting logical conditions.
The condition (8.44) shows that only single EMB is enough to implement the circuit
of BIMF. In this case, we propose the model of M0C PC Moore FSM (Fig.8.26).
In this FSM, the LUTer implements the system of additional variables
P = P(τ, X2).
(8.45)
The block EMB1 implements the system of input memory functions
Φ = Φ(τ, X1, P).
(8.46)
The block EMB2 implements microoperations yn ∈Y and the system (4.4).
There are the following steps in the design method for M0C PC Moore FSM:
1. State assignment.
2. Encoding of the classes Bi ∈A.
3. Constructing the structure table of PCY Moore FSM.
4. Partitioning the set X by subsets X1 and X2.
5. Replacement of logical conditions xl ∈X2.
6. Constructing the transformed structure table.

8.4 Optimizing LUTer in Replacement of Logical Conditions
267
Fig. 8.27 Initial GSA Γ15
Start
a5
1
0
x1
x2
y3y4
y1y2
x3
x4
y2y4y6
End
a1
0
1
a2
0
1
0
1
a3
a4
a1
y5y6
a6
y1y3
a7
y3y4
x4
0
x5
1
a8
y3y4
1
0
7. Constructing the table of BIMF.
8. Constructing the table of BMO.
9. Implementing the FSM logic circuit.
Let us discuss an example of design for FSM M0C PC(Γ15). There is GSA Γ15
shown in Fig.8.27.
Let us analyse the GSA Γ15. It is possible to ﬁnd the following sets and their
parameters from this analysis: A = {a1, . . . , a8}, M1 = 8, X = {x1, . . . , x5},
L = 5, Y = {y1, . . . , y6}, N = 6, R1 = 3, T = {T1, T2, T3}, Φ = {D1, D2, D3}.
The following partition ΠA can be found for Moore FSM: ΠA = {B1, . . . , B4},
where B1 = {a1}, B2 = {a2, a3, a4}, B3 = {a5, a6, a7}, B4 = {a8}. So, there is
IA = 4 and RB = 2. A state assignment is treated as optimal if any class Bi ∈A
is represented by a single generalized interval of R1-dimensional Boolean space [3].
It is impossible to encode the states am ∈A in this way for the discussed example.
Because of it, let us encode the states in the trivial way: K(a1) = 000, . . . , K(a8) =
111.
Because of RA = 2, there is τ = {τ1, τ2}. Let us encode the classes Bi ∈A
in the trivial way: K(B1) = 00, . . . , K(B4) = 11. Let us point out that there is no
need in the representing the transitions from state a8 ∈B4 by the structure table. In

268
8
Design of EMB-Based Moore FSMs
the case of D ﬂip-ﬂops such transitions are executed automatically (using only pulse
Clock). Therefore, the code 11 can be treated as “don’t care” input assignment.
To construct the structure table of PC Moore FSM, it is necessary to construct the
system of generalized formulae of transitions. In the discussed case, this system is
the following one:
B1 →x1a2 ∨¯x1x2a3 ∨¯x1 ¯x2a4;
B2 →x3a5 ∨¯x3x4a6 ∨¯x3 ¯x4a7;
B3 →x4a5 ∨¯x4x5a8 ∨¯x4 ¯x5a7.
(8.47)
Let us point out that there is no formula for the class B4 ∈A in the system
(8.47). It is connected with the fact that this class is treated as “don’t care”.
There are the following columns in the ST of PC Moore FSM: Bi, K(Bi), as,
K(as), Xh, Φh, h. This table is constructed using the system of GFT. In the discussed
case, they use the system (8.47) to construct the Table8.23.
Let us use the FPGA chip including EMBs with the following conﬁgurations:
256 × 1, 128 × 2, 64 × 4, 32 × 8 (bits). It is necessary to use EMBs with V0 =
23+8·3 = 6144 bits on the case of Moore FSM M P(Γ15). Obviously, the replacement
of logical conditions should be used in the discussed case.
In the discussed case, there is R1 = 3. It means that the conﬁguration 64×4 must
be used. Because there is RA = 2, the EMB has SA −RA = 6 −2 = 4 free inputs.
It gives |X1| = 3, |X2| = 2 and G = 1. Let us represent the set X as X1 ∪X2 where
X1 = {x2, x3, x5} and X2 = {x1, x4}.
Now, let us replace the logical conditions xl ∈X2. The RLC is shown in
Table8.24.
Table 8.23 Structure table of Moore FSM PC(Γ15)
Bi
K(Bi)
as
K(as)
Xh
Φh
h
B1
00
a2
001
x1
D3
1
a3
010
¯x1x2
D2
2
a4
011
¯x1 ¯x2
D2D3
3
B2
01
a5
100
x3
D1
4
a6
101
¯x3x4
D1D3
5
a7
110
¯x3 ¯x4
D1D2
6
B3
10
a5
100
x4
D1
7
a8
111
¯x4x5
D1D2D3
8
a7
110
¯x4 ¯x5
D1D2
9
Table 8.24 Table of replacement of logical conditions for Moore FSM M0 PC(Γ15)
Bi
B1
B2
B3
B4
p1
x1
x4
x4
–

8.4 Optimizing LUTer in Replacement of Logical Conditions
269
Table 8.25 Transformed structure table of Moore FSM M0C PC(Γ15)
Bi
K(Bi)
as
K(as)
X1
h
Ph
Φh
h
B1
00
a2
001
1
p1
D3
1
a3
010
x2
¯p1
D2
2
a4
011
¯x2
¯p1
D2D3
3
B2
01
a5
100
x3
1
D1
4
a6
101
¯x3
p1
D1D3
5
a7
110
¯x3
¯p1
D1D2
6
B3
10
a5
100
1
p1
D1
7
a8
111
x5
p1
D1D2D3
8
a7
110
¯x5
p1
D1D2
9
The following equation can be derived from Table8.24: p1 = B1x1 ∨B2x4 ∨
B3x4 = ¯τ1 ¯τ2x1 ∨¯τ1τ2x4 ∨τ1 ¯τ2x4. This formula can be implemented as a single-
level circuit using LUTs with S ≥4. Let us point out that this equation can be
simpliﬁed due to appropriate encoding of the classes Bi ∈A. For example, if there
is K(B1) = 00, K(B2) = 10, K(B3) = 11, K(B4) = 01, then there is the following
equation: p1 = ¯τ1x1 ∨τ1x4. It can be implemented using only one LUT having
S = 3.
There are the following columns in the transformed ST of M0C PC Moore FSM:
Bi, K(Bi), as, K(as), X1
h, Ph, Φh, h. It is Table8.25 in discussed case.
The table of BIMF includes the same columns as it is for the case of FSM M0E PE.
In the discussed case, the transitions from each class Bi ∈A are represented by
16 rows of the table. The table of BMO includes the following columns: K(am), Y,
K(Bi), m. The column K(Bi) includes the code of class Bi ∈A such that am ∈Bi
(for the row number m of the table). In the case of Moore FSM M0C PC(Γ15) this
table is represented by Table8.26.
Table 8.26 Table of BMO for Moore FSM M0C PC(Γ15)
K(am)
Y
K(Bi)
m
T1T2T3
y1y2y3y4y5y6
τ1τ2
000
000000
00
1
001
110000
01
2
010
001100
01
3
011
000011
01
4
100
101000
10
5
101
010101
10
6
110
001100
10
7
111
101000
11
8

270
8
Design of EMB-Based Moore FSMs
τ
τ
τ
τ
τ
τ
τ
Fig. 8.28 Logical circuit of Moore FSM M0C PC(Γ15)
τ
Φ
Fig. 8.29 Structural diagram of MC PC Moore FSM
There is the logic circuit of Moore FSM M0C PC(Γ15) shown in Fig.8.28. There is
a single LUT with S = 4 used for implementing the circuit of LUTer. To implement
the circuit of BIMF, it is enough an EMB having the conﬁguration 64×4 (one output
is free). They need the conﬁguration 8 × 8 to implement the circuit of BMO.
It is possible to use the transformation of PES without the splitting logical condi-
tions. It results in MC PC Moore FSM (Fig.8.29).
Now, let us discuss the models based on the special state assignments. It is reduced
to representing the set A as two disjoint sets AC and AU. If there is X(am) ̸= ∅, then
the state am ∈A is placed into the set AU.
Let us discuss the following example. There is an FSM S1 with A = {a1, . . . , a16}
and ΠA = {B1, . . . , B10}. Let it be the following classes Bi ∈ΠA: B1 = {a1},
B2 = {a2, a3}, B3 = {a4, a5, a6}, B4 = {a7, a8}, B5 = {a9}, B6 = {a10, a11, a12},
B7 = {a13}, B8 = {a14}, B9 = {a15}, B10 = {a16}. Let the logical conditions xl ∈X
be represented by the additional variables pg ∈P as it is show in Table8.27.
Table 8.27 Table of RLC for Moore FSM S1
Bi
B1
B2
B3
B4
B5
B6
B7
B8
B9
B10
am
a1
a2
a3
a4
a5
a6
a7
a8
a9
a10
a11
a12
a13
a14
a15
a16
p1
x1
x2
x2
–
–
–
–
–
x1
x6
x6
x6
–
–
–
–
p2
–
x3
x3
–
–
–
–
–
x5
x4
x4
x4
–
–
–
–

8.4 Optimizing LUTer in Replacement of Logical Conditions
271
Fig. 8.30 Optimal state
codes for Moore FSM S1
T1T2
T3T4
00
01
11
10
00
01
11
10
a1
a2
a10
a∗
8
a9
a3
a11
a∗
13
a∗
4
a∗
5
a∗
6
a∗
7
a∗
14 a∗
15
a12
a∗
16
It is possible to derive the following equations from the Table8.27:
p1 = A1x1 ∨(A2 ∨A3)x2 ∨A9x1 ∨(A10 ∨A11 ∨A12)x6;
(8.48)
p2 = (A2 ∨A3)x3 ∨A9x5 ∨(A10 ∨A11 ∨A12)x4.
(8.49)
Let us encode the states in the trivial way: K(a1) = 0000, . . . , K(a16) = 1111.
Let us discuss the expression (8.48).
There is the following expression for p1 corresponding the this style of state
assignment:
p1 = ¯T1 ¯T2x1 ∨T2 ¯T3x2 ∨T1 ¯T3x2 ∨T2T3 ¯T4x6 ∨T1T3 ¯T4x6.
(8.50)
Let us use the LUTs having S = 4 for implementing the LUTer. It is possible to
ﬁnd that there are 6 LUTs in the circuit corresponding to (8.50). This circuit has 4
layers.
Let us divide the set A by following subsets: AC = {a1, a2, a3, a9, . . . , a12},
AU = {a4, . . . , a8, a13, . . . , a16}. To optimize the expressions for pg ∈P, we can
treat as “don’t care” the state codes for am ∈AU. Let us encode the states am ∈A
in the optimal way: if xl ∈X is replaced by pg for states am, as ∈AC, then the
codes K(am) and K(as) should be placed into the same generalized interval of
R1-dimensional Boolean space. There is the outcome of this approach shown in
Fig.8.30.
There is the sign “*” near the states am ∈AU. These states are treated as “don’t
care”. The following expression can be derived from Fig.8.30:
p1 = ¯T1 ¯T2x1 ∨T2x2 ∨T1x6.
(8.51)
There are 2 of LUTs with S = 4 in the circuit corresponding to (8.51). Analysis
of (8.51) shows that there is a set T ′ ⊆T whose elements are used in this equation.
It is the set T ′ = {T1, T2}.
This approach leads to MS P Moore FSM (Fig.8.31). In this FSM, the LUTer
implements the system
P = P(T ′, X).
(8.52)

272
8
Design of EMB-Based Moore FSMs
EMB1
Y
RG
T
X
Start
Clock
Φ
P
LUTer
EMB2
T'
Fig. 8.31 Structural diagram of MS P Moore FSM
EMB1
Y
RG
T
X2
Start
Clock
Φ
P
LUTer
EMB2
X1
T'
Fig. 8.32 Structural diagram of M0S P Moore FSM
It is possible to combine this approach with the splitting logical conditions. It
leads to M0S P Moore FSM shown in Fig.8.32.
In this model, the LUTer implements the system
P = P(T ′, X2).
(8.53)
The same approach can be used for MC PC Moore FSM. Let us discuss the
FSM S1. As follows from Table8.27, there is IA = 9. It determines RA = 4
and τ = {τ1, . . . , τ4}. Let us encode the classes Bi ∈A in the trivial way:
K(B1) = 0000, . . . , K(B10) = 1001. In this case, the following expression can
be constructed for the function p1:
p1 = ¯τ1 ¯τ2x1 ∨τ2 ¯τ4x2 ∨τ2τ3x6.
(8.54)
This equation can be implemented using four of LUTs having S = 4. The circuit
has two layers of logic.
Now, let us divide the set A by two disjoint subsets AC and AU. If there are
conditional transitions from states am ∈Bi, then Bi ∈AC. Otherwise there is the
following relation: Bi ∈AU. There are the following sets in the discussed case:
AC = {B1, B2, B5, B6} and AU = {B3, B4, B7, . . . , B10}.
Let us encode the classes Bi ∈AC in the optimal way: if the logical condition
xl ∈X is replaced by variable pg ∈P for the states am ∈Bi ∪B j, then the these
classes should have codes from the same generalized interval of RA-dimensional
Boolean space. There is one of the possible outcomes of optimal class assignment
shown in Fig.8.33.

8.4 Optimizing LUTer in Replacement of Logical Conditions
273
τ1τ2
τ3τ4
00
01
11
10
00
01
11
10
B1 B2
B3
∗
B5 B∗
4
B∗
6
∗
B∗
7 B∗
8
B9
B∗
10
∗
∗
∗
∗
Fig. 8.33 Optimal class codes for Moore FSM S1
EMB1
Y
RG
T
X
Start
Clock
Φ
P
LUTer
EMB2
’τ
τ
τ
Fig. 8.34 Structural diagram of MCS PC Moore FSM
There is the sign “*” near the classes Bi ∈AU. It means that their codes are
treated as insigniﬁcant input assignments. Using this rule, it is possible to get the
following equation:
p1 = ¯τ1 ¯τ2x1 ∨τ2x2 ∨τ1x6.
(8.55)
The comparison of (8.54) and (8.55) shows that the later is much simpler. It
corresponds to the logic circuit with only two LUTs having S = 4. Also let us point
out that there is only a subset τ′ of the set τ in equation (8.55). There is τ′ = {τ1, τ2}.
Let us denote the Moore FSM based on this approach as MCS PC Moore FSM. Its
structural diagram is shown in Fig.8.34.
In this FSM, the LUTer implements the system
P = P(τ′, X).
(8.56)
Both EMB1 and EMB2 execute the same function as it is for MC PC Moore FSM.
This approach can be combined with the splitting logical conditions. It leads to
M0CS PC Moore FSM (Fig.8.35).
In this model, the LUTer generates the functions
P = P(τ′, X2).
(8.57)
All discussed models can be modiﬁed using the method of encoding of logical
conditions [6, 12]. We discussed it before in this book. For example, there are four
pairs of logical conditions in the Table8.27: ⟨x1, −⟩, ⟨x2, x3⟩, ⟨x1, x5⟩and ⟨x4, x6⟩.

274
8
Design of EMB-Based Moore FSMs
EMB1
Y
RG
T
X2
Start
Clock
Φ
P
LUTer
EMB2
X1
’τ
τ
τ
Fig. 8.35 Structural diagram of M0CS PC Moore FSM
EMB1
Y
RG
T
X
Start
Clock
Φ
P
LUTer
EMB
Z
τ
Fig. 8.36 Structural diagram of MZ PC Moore FSM
So, there is nP = 4. Using (2.20), it is possible to ﬁnd the value of RP = 2. Let us
use the variables zr ∈Z for encoding the pairs ⟨xl, xm⟩. Let us use the following
codes: K(x1, −) = 00, K(x2, x3) = 01, K(x1, x5) = 10 and K(x4, x6) = 11. Now,
it is possible to construct the following system of equations:
p1 = ¯z2x1 ∨¯z1z2x2 ∨z1z2x6;
p2 = z2x3 ∨z1x5 ∨z1z2x4.
(8.58)
Each of equations (8.58) corresponds to the logic circuit having 2 LUTs with
S = 4. Let us point out that the variables zr ∈Z should be generated by BMO.
For example, there is a structural diagram of MZ PC Moore FSM shown in
Fig.8.36. It is based on the encoding of logical conditions and transformation of
PES.
In this model, the LUTer implements the system
P = P(Z, X).
(8.59)
The EMB2 implements the systems (1.5), (4.1) and (4.4).
There are the characteristics of different models of Moore FSMs with replacement
of logical conditions shown in Table8.28.
The row 17 of Table8.28 represents the M P Moore FSM where everything is
encoded in the trivial way. The rows 1–16 show different approach used for hardware
reducing in the blocks BRLC or/and BIMF. We have discussed some of these models.
It is possible to work out design methods for each of models from Table8.28. It is

8.4 Optimizing LUTer in Replacement of Logical Conditions
275
Table 8.28 Characteristics of Moore FSM with RLC
No
FSM
BRLC
BIMF
BMO
1.
M0 P
P = P(T, X2)
Φ = Φ(T, P, X1)
Y = Y(T)
2.
M0E PE
P = P(T ′, X2)
Φ = Φ(T ′, P, X1)
Y = Y(T)
3.
M0C PC
P = P(τ, X2)
Φ = Φ(τ, P, X1)
Y = Y(T)
τ = τ(T)
4.
MC PC
P = P(τ, X)
Φ = Φ(τ, X)
Y = Y(T)
τ = τ(T)
5.
Ms P
P = P(T ′, X)
Φ = Φ(T ′X)
Y = Y(T)
6.
M0S P
P = P(T ′, X2)
Φ = Φ(T ′, X1, P)
Y = Y(T)
7.
MCS PC
P = P(τ′, X)
Φ = Φ(τ, P)
Y = Y(T)
τ = τ(T)
8.
M0CS PC
P = P(τ′, X2)
Φ = Φ(τ, P, X1)
Y = Y(T)
τ = τ(T)
9.
M0Z P
P = P(Z, X2)
Φ = Φ(T, P, X1)
Y = Y(T)
Z = Z(T )
10.
M0E Z PE
P = P(Z, X2)
Φ = Φ(T ′, P, X1)
Y = Y(T)
Z = Z(T )
11.
M0C Z PC
P = P(Z, X2)
Φ = Φ(τ, P, X1)
Y = Y(T)
τ = τ(T)
Z = Z(T )
12.
MC Z PC
P = P(Z, X)
Φ = Φ(τ, X)
Y = Y(T)
τ = τ(T)
Z = Z(T )
13.
MSZ P
P = P(Z, X)
Φ = Φ(T ′, X)
Y = Y(T)
Z = Z(T )
14.
M0SZ P
P = P(Z, X2)
Φ = Φ(T ′, X1, P)
Y = Y(T)
Z = Z(T )
15.
MCSZ PC
P = P(Z, X)
Φ = Φ(τ, P)
Y = Y(T)
τ = τ(T)
Z = Z(T )
16.
M0CS PC
P = P(Z, X2)
Φ = Φ(τ, P, X1)
Y = Y(T)
τ = τ(T)
Z = Z(T )
17.
M PE
P = P(X, T )
Φ = Φ(T, X)
Y = Y(T)
necessary to have an expert system assisting in the choice of the approach leading to
the circuit with minimum amount of LUTs in BRLC.
If input memory functions depend on variables Tr ∈T , then it is possible to
use the method of distribution of microoperations. It is necessary to optimize the
hardware amount in BMO. This method can be applied for M P, M0P, and M0Z P
Moore FSM. We do not discuss these models in our book.

276
8
Design of EMB-Based Moore FSMs
References
1. Altera, http://www.altera.com. Accessed Jan 2015
2. S. Baranov, Logic Synthesis of Control Automata (Kluwer Academic Publishers, 1994)
3. A. Barkalov, Principles of logic optimization for Moore microprogram automaton. Cybern.
Syst. Anal. 34(1), 54–60 (1998)
4. A. Barkalov, L. Titarenko, Logic Synthesis for FSM-Based Control Units (Springer, Berlin,
2009)
5. A. Barkalov, L. Titarenko, A. Barkalov, Structural decomposition as a tool for the optimization
of an FPGA-based implementation of a Mealy FSM. Cybern. Syst. Anal. 48(2), 313–323 (2012)
6. A. Barkalov, I. Zelenjova, Optimization of replacement of logical conditions for an automaton
with bidirectional transitions. Autom. Control Comput. Sci. 34(5), 48–53, Allerton Press Inc
7. I. Grout, Digital Systems Design with FPGAs and CPLDs (Elsevier Science, Oxford, 2008)
8. M. Kołopie´nczyk, A. Barkalov, L. Titarenko, Hardware reduction for RAM-based Moore
FSMs, in 7th International Conference on Human System Interactions—HSI 2014, Lisbon,
Portugal (2014), pp. 255–260 [B.m.]
9. LGSynth93, International Workshop on logic synthesis benchmark suite (LGSynth93).
TAR, Benchmarks test, http://www.cbl.ncsu.edu:16080/benchmarks/LGSynth93/LGSynth93.
tar (1993)
10. C. Maxﬁeld, The Design Warrior’s Guide to FPGAs (Academic Press Inc, Orlando, 2004)
11. C. Scholl, Functional Decomposition with Application to FPGA Synthesis (Kluwer Academic
Publishers, Boston, 2001)
12. V. Sklyarov, I. Skliarova, A. Barkalov, L. Titarenko, Synthesis and Optimization of FPGA-based
Systems, vol. 294, Lecture notes in electrical engineering (Springer, Berlin, 2014)
13. Xilinx, http://www.xilinx.com. Accessed Jan 2015

Conclusion
Now we are witnesses of the intensive development of design methods targeting
FPGA-based circuits and systems. The complexity of digital systems to de designed
increases drastically, as well as the complexity of FPGA chips used for the design.
The up-to-day FPGAs include up to seven billions of transistors and it is not a limit.
Development of digital systems with such complex logic elements is impossible
without application of hardware description languages, computer-aided design tools
and design libraries. But even the application of all these tools does not guarantee
that some competitive product will be designed for appropriate time-to-market. To
solve this problem, a designer should know not only CAD tools, but the design
and optimization methods, too. It is especially important in case of such irregular
devices as control units. Because of irregularity, their logic circuits are implemented
without using of the standard library cells; only LUTs and EMBs of a particular
FPGA chip can be used in FSM logic circuit design. In this case, the knowledge and
experience of a designer become a crucial factor of the success. Many experiments
conducted with use of standard industrial packages show that outcomes of their
operation are, especially in case of complex control units design, too far from optimal.
Thus, it is necessary to develop own program tools oriented on FSM optimization and
use them together with industrial packages. This problem cannot be solved without
fundamental knowledge in the area of logic synthesis. Besides, to be able to develop
new design and optimization methods, a designer should know the existed methods.
We think that new FSM models and design methods proposed in our book will
help in solution of this very important problem. We hope that our book will be
useful for the designers of digital systems and scholars developing synthesis and
optimization methods targeting implementation of logic circuits of FPGA-based
ﬁnite state machines.
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6
277

Index
A
Addressing of microinstructions
combined, 10
compulsory, 10, 13
natural, 16
B
Block of
code transformer, 66
functions, 4
identiﬁers, 100
input memory functions, 7, 213
microoperations, 7
state codes transformer, 97
Boolean
function, 193
space, 49, 130, 135, 176, 251, 267, 271,
272
variable, 3, 6, 8, 24, 25, 40
BRAM, 197, 200, 211
C
Circuit
LUT-based, 39, 41
Class of
pseudoequivalent states, 9, 46
CLB, 33, 34
Collection of microoperations, 2, 207
Combinational circuit, 28, 193
Complex
programmable
logic
device
(CPLD), 21
Compositional microprogram control unit
(CMCU), 3, 15, 16, 18
Computer aided design (CAD) system, 7
Consumed power, 37, 42, 50
D
Decomposition, 27
functional, 193, 260
structural, 26, 197, 216, 243
Don’t care input assignment, 140, 268, 273
E
Embedded memory block (EMB), 193
F
Field-programmable gate array (FPGA), 21,
33
Field-programmable logic device (FPLD),
21
Fields of compatible microoperations, 21,
22, 66, 100, 112, 143, 243
Finite state-machine (FSM), 1
Mealy, 2
Moore, 2
Flip-ﬂop, 2
G
Generalized formula of transitions, 253, 256,
263, 268
Generalized interval of Boolean space, 267,
271, 272
Generic array logic (GAL), 27
Graph-schemes of algorithm
block, 2, 3, 10
H
Hardware
amount, 13, 45, 57, 60, 101, 120, 148,
186, 197, 210, 243, 275
© Springer International Publishing Switzerland 2016
A. Barkalov et al., Logic Synthesis for FPGA-Based Finite State Machines,
Studies in Systems, Decision and Control 38, DOI 10.1007/978-3-319-24202-6
279

280
Index
reduction, 21, 50, 65, 103, 143, 158, 161,
211, 226, 257, 266
Hardware description language, 37
I
Interconnections, 33, 37, 43, 193
J
JEDI, 45, 49, 50
K
Karnaugh map, 20, 105, 109, 161, 166, 172
L
Logical condition, 2
M
Macrocell, 27
Microoperation, 2
Model of FSM, 2, 22
Multiplexer, 14, 27, 34, 134
O
Object codes transformation (OCT), 65, 97
Object of FSM
heterogeneous, 65
Operational linear chain (OLC), 15
P
PALer, 129
Performance, 38, 45, 46, 50, 133, 195
Product term, 5, 24, 27, 28, 41, 129
Programmable array logic (PAL), 21
Programmable logic array (PLA), 21
Programmable logic sequencer (PLS), 27
Programmable read-only memory (PROM),
21
Pseudoequivalent states, 9, 46, 60, 251, 261
R
Read-only memory (ROM), 14
S
State
code, 1
internal, 1
variables, 2
State assignment
energy-saving, 46
Structural diagram, 4, 7, 11, 16, 26–28
Sum-of-products (SOP), 6
Synchronization, 19, 242
Synthesis, 3, 4, 14, 18, 37, 38, 43, 68, 71, 77,
135
System of
Boolean functions, 25, 57
generalized formulae of transitions, 253,
256, 263, 268
T
Table of
BCT, 66, 77, 78
BIMF, 18, 19, 69, 72, 75, 77, 82, 84, 124,
135, 145, 150, 155, 162, 168, 175, 176,
210, 216, 224, 230, 234, 246, 250, 253,
256, 259, 264, 269
BMO, 19, 70, 72, 78, 82, 85, 89, 157,
165, 175, 183, 190, 204, 208, 231, 242,
256, 260, 264, 269
BSCT, 152, 156, 175
EMBer, 43, 45, 74, 78, 83, 105, 106, 110,
114, 115, 119, 140, 152, 175
LUTer, 51, 59, 60, 79, 83, 86, 106, 116–
118, 123, 135, 138
MX, 175
Transformation of
initial GSA, 12
object codes, 60, 65, 97
state codes, 60, 97, 101, 129, 135, 154,
266
Transformed
structure table, 202, 209, 224, 229, 234,
242, 250, 253, 256
Truth table, 8
V
Vertex
conditional, 3
end, 2
operator, 2
start, 2
Verticalization of GSA, 125

