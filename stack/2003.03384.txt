AutoML-Zero: Evolving Machine Learning Algorithms From Scratch
Esteban Real * 1 Chen Liang * 1 David R. So 1 Quoc V. Le 1
Abstract
Machine learning research has advanced in multi-
ple aspects, including model structures and learn-
ing methods. The effort to automate such re-
search, known as AutoML, has also made sig-
niﬁcant progress.
However, this progress has
largely focused on the architecture of neural net-
works, where it has relied on sophisticated expert-
designed layers as building blocks—or similarly
restrictive search spaces. Our goal is to show that
AutoML can go further: it is possible today to au-
tomatically discover complete machine learning
algorithms just using basic mathematical opera-
tions as building blocks. We demonstrate this by
introducing a novel framework that signiﬁcantly
reduces human bias through a generic search
space. Despite the vastness of this space, evo-
lutionary search can still discover two-layer neu-
ral networks trained by backpropagation. These
simple neural networks can then be surpassed by
evolving directly on tasks of interest, e.g. CIFAR-
10 variants, where modern techniques emerge
in the top algorithms, such as bilinear interac-
tions, normalized gradients, and weight averag-
ing. Moreover, evolution adapts algorithms to
different task types: e.g., dropout-like techniques
appear when little data is available. We believe
these preliminary successes in discovering ma-
chine learning algorithms from scratch indicate a
promising new direction for the ﬁeld.
1. Introduction
In recent years, neural networks have reached remarkable
performance on key tasks and seen a fast increase in their
popularity [e.g. He et al., 2015; Silver et al., 2016; Wu et al.,
2016]. This success was only possible due to decades of
machine learning (ML) research into many aspects of the
*Equal contribution 1Google Brain/Google Research, Moun-
tain View, CA, USA. Correspondence to: Esteban Real <ereal@
google.com>.
Proceedings of the 37 th International Conference on Machine
Learning, Vienna, Austria, PMLR 119, 2020. Copyright 2020 by
the author(s).
ﬁeld, ranging from learning strategies to new architectures
[Rumelhart et al., 1986; LeCun et al., 1995; Hochreiter
& Schmidhuber, 1997, among many others]. The length
and difﬁculty of ML research prompted a new ﬁeld, named
AutoML, that aims to automate such progress by spend-
ing machine compute time instead of human research time
(Fahlman & Lebiere, 1990; Hutter et al., 2011; Finn et al.,
2017). This endeavor has been fruitful but, so far, mod-
ern studies have only employed constrained search spaces
heavily reliant on human design. A common example is
architecture search, which typically constrains the space
by only employing sophisticated expert-designed layers as
building blocks and by respecting the rules of backprop-
agation (Zoph & Le, 2016; Real et al., 2017; Tan et al.,
2019). Other AutoML studies similarly have found ways
to constrain their search spaces to isolated algorithmic as-
pects, such as the learning rule used during backpropagation
(Andrychowicz et al., 2016; Ravi & Larochelle, 2017), the
data augmentation (Cubuk et al., 2019a; Park et al., 2019) or
the intrinsic curiosity reward in reinforcement learning (Alet
et al., 2019); in these works, all other algorithmic aspects
remain hand-designed. This approach may save compute
time but has two drawbacks. First, human-designed com-
ponents bias the search results in favor of human-designed
algorithms, possibly reducing the innovation potential of
AutoML. Innovation is also limited by having fewer op-
tions (Elsken et al., 2019b). Indeed, dominant aspects of
performance are often left out (Yang et al., 2020). Second,
constrained search spaces need to be carefully composed
(Zoph et al., 2018; So et al., 2019; Negrinho et al., 2019),
thus creating a new burden on researchers and undermining
the purported objective of saving their time.
To address this, we propose to automatically search for
whole ML algorithms using little restriction on form and
only simple mathematical operations as building blocks.
We call this approach AutoML-Zero, following the spirit
of previous work which aims to learn with minimal hu-
man participation [e.g. Silver et al., 2017]. In other words,
AutoML-Zero aims to search a ﬁne-grained space simulta-
neously for the model, optimization procedure, initialization,
and so on, permitting much less human-design and even al-
lowing the discovery of non-neural network algorithms. To
demonstrate that this is possible today, we present an initial
solution to this challenge that creates algorithms competitive
arXiv:2003.03384v2  [cs.LG]  30 Jun 2020

AutoML-Zero
with backpropagation-trained neural networks.
The genericity of the AutoML-Zero space makes it more dif-
ﬁcult to search than existing AutoML counterparts. Existing
AutoML search spaces have been constructed to be dense
with good solutions, thus deemphasizing the search method
itself. For example, comparisons on the same space found
that advanced techniques are often only marginally superior
to simple random search (RS) (Li & Talwalkar, 2019; Elsken
et al., 2019b; Negrinho et al., 2019). AutoML-Zero is dif-
ferent: the space is so generic that it ends up being quite
sparse. The framework we propose represents ML algo-
rithms as computer programs comprised of three component
functions, Setup, Predict, and Learn, that performs ini-
tialization, prediction and learning. The instructions in these
functions apply basic mathematical operations on a small
memory. The operation and memory addresses used by
each instruction are free parameters in the search space, as
is the size of the component functions. While this reduces
expert design, the consequent sparsity means that RS can-
not make enough progress; e.g. good algorithms to learn
even a trivial task can be as rare as 1 in 1012. To overcome
this difﬁculty, we use small proxy tasks and migration tech-
niques to build highly-optimized open-source infrastructure
capable of searching through 10,000 models/second/cpu
core. In particular, we present a variant of functional equiv-
alence checking that applies to ML algorithms. It prevents
re-evaluating algorithms that have already been seen, even
if they have different implementations, and results in a 4x
speedup. More importantly, for better efﬁciency, we move
away from RS.1
Perhaps surprisingly, evolutionary methods can ﬁnd solu-
tions in the AutoML-Zero search space despite its enormous
size and sparsity. By randomly modifying the programs and
periodically selecting the best performing ones on given
tasks/datasets, we discover reasonable algorithms. We will
ﬁrst show that starting from empty programs and using data
labeled by “teacher” neural networks with random weights,
evolution can discover neural networks trained by gradient
descent (Section 4.1). Next, we will minimize bias toward
known algorithms by switching to binary classiﬁcation tasks
extracted from CIFAR-10 and allowing a larger set of possi-
ble operations. The result is evolved models that surpass the
performance of a neural network trained with gradient de-
scent by discovering interesting techniques like multiplica-
tive interactions, normalized gradient and weight averaging
(Section 4.2). Having shown that these ML algorithms are
attainable from scratch, we will ﬁnally demonstrate that it
is also possible to improve an existing algorithm by initial-
izing the population with it. This way, evolution adapts
the algorithm to the type of task provided. For example,
1We
open-source
our
code
at
https://github.
com/google-research/google-research/tree/
master/automl_zero#automl-zero
dropout-like operations emerge when the task needs reg-
ularization and learning rate decay appears when the task
requires faster convergence (Section 4.3). Additionally, we
present ablation studies dissecting our method (Section 5)
and baselines at various compute scales for comparisons by
future work (Suppl. Section S10).
In summary, our contributions are:
• AutoML-Zero, the proposal to automatically search for
ML algorithms from scratch with minimal human design;
• A novel framework with open-sourced code1 and a search
space that combines only basic mathematical operations;
• Detailed results to show potential through the discovery
of nuanced ML algorithms using evolutionary search.
2. Related Work
AutoML has utilized a wide array of paradigms, including
growing networks neuron-by-neuron (Stanley & Miikku-
lainen, 2002), hyperparameter optimization (Snoek et al.,
2012; Loshchilov & Hutter, 2016; Jaderberg et al., 2017)
and, neural architecture search (Zoph & Le, 2016; Real
et al., 2017). As discussed in Section 1, AutoML has tar-
geted many aspects of neural networks individually, using
sophisticated coarse-grained building blocks. Mei et al.
(2020), on the other hand, perform a ﬁne-grained search
over the convolutions of a neural network. Orthogonally, a
few studies beneﬁt from extending the search space to two
such aspects simultaneously (Zela et al., 2018; Miikkulainen
et al., 2019; Noy et al., 2019). In our work, we perform a
ﬁne-grained search over all aspects of the algorithm.
An important aspect of an ML algorithm is the optimiza-
tion of its weights, which has been tackled by AutoML in
the form of numerically discovered optimizers (Chalmers,
1991; Andrychowicz et al., 2016; Vanschoren, 2019). The
output of these methods is a set of coefﬁcients or a neu-
ral network that works well but is hard to interpret. These
methods are sometimes described as “learning the learning
algorithm”. However, in our work, we understand algorithm
more broadly, including the structure and initialization of
the model, not just the optimizer. Additionally, our algo-
rithm is not discovered numerically but symbolically. A
symbolically discovered optimizer, like an equation or a
computer program, can be easier to interpret or transfer. An
early example of a symbolically discovered optimizer is that
of Bengio et al. (1994), who optimize a local learning rule
for a 4-neuron neural network using genetic programming
(Holland, 1975; Forsyth et al., 1981; Koza & Koza, 1992).
Our search method is similar but represents the program as
a sequence of instructions. While they use the basic opera-
tions {+, −, ×, ÷}, we allow many more, taking advantage
of dense hardware computations. Risi & Stanley (2010)
tackle the discovery of a biologically informed neural net-
work learning rule too, but with a very different encoding.

AutoML-Zero
More recently, Bello et al. (2017) also search for a symbolic
optimizer, but in a restricted search space of hand-tuned
operations (e.g. “apply dropout with 30% probability”, “clip
at 0.00001”, etc.). Our search space, on the other hand,
aims to minimize restrictions and manual design. Unlike
these three studies, we do not even assume the existence of
a neural network or of gradients.
We note that our work also relates to program synthesis
efforts. Early approaches have proposed to search for pro-
grams that improve themselves (Lenat, 1983; Schmidhuber,
1987). We share similar goals in searching for learning
algorithms, but focus on common machine learning tasks
and have dropped the self-reﬂexivity requirement. More re-
cently, program synthesis has focused on solving problems
like sorting (Graves et al., 2014), string manipulation (Gul-
wani et al., 2017; Balog et al., 2017), or structured data
QA (Liang et al., 2016). Unlike these studies, we focus on
synthesizing programs that solve the problem of doing ML.
Suppl. Section S1 contains additional related work.
3. Methods
AutoML-Zero concerns the automatic discovery of algo-
rithms that perform well on a given set of ML tasks T . First,
search experiments explore a very large space of algorithms
A for an optimal and generalizable a∗∈A. The quality of
the algorithms is measured on a subset Tsearch ⊂T , with
each search experiment producing a candidate algorithm.
In this work, we apply random search as a baseline and
evolutionary search as the main search method due to their
simplicity and scalability. Once the search experiments are
done, we select the best candidate by measuring their perfor-
mances on another subset of tasks Tselect ⊂T (analogous
to standard ML model selection with a validation set). Un-
less otherwise stated, we use binary classiﬁcation tasks
extracted from CIFAR-10, a collection of tiny images each
labeled with object classes (Krizhevsky & Hinton, 2009),
and we calculate the average accuracy across a set of tasks
to measure the quality of each algorithm. To lower compute
costs and achieve higher throughput, we create small proxy
tasks for Tsearch and Tselect by using one random matrix for
each task to project the input features to lower dimensional-
ity. The projected dimensionality is 8 ≤F ≤256. Finally,
we compare the best algorithm’s performance against hand-
designed baselines on the CIFAR-10 data in the original
dimensionality (3072), holding out the CIFAR-10 test set
for the ﬁnal evaluation. To make sure the improvement is
not speciﬁc to CIFAR-10, we further show the gain gener-
alizes to other datasets: SVHN (Netzer et al., 2011), Ima-
geNet (Chrabaszcz et al., 2017), and Fashion MNIST (Xiao
et al., 2017). The Experiment Details paragraphs in Sec-
tion 4 contain the speciﬁcs of the tasks. We now describe
the search space and search method with sufﬁcient detail to
understand the results. For reproducibility, we provide the
minutiae in the Supplement and the open-sourced code.
3.1. Search Space
We represent algorithms as computer programs that act on
a small virtual memory with separate address spaces for
scalar, vector and matrix variables (e.g. s1, v1, m1), all of
which are ﬂoating-point and share the dimensionality of
the task’s input features (F). Programs are sequences of
instructions. Each instruction has an operation—or op—
that determines its function (e.g. “multiply a scalar with a
vector”). To avoid biasing the choice of ops, we use a simple
criterion: those that are typically learned by high-school
level. We purposefully exclude machine learning concepts,
matrix decompositions, and derivatives. Instructions have
op-speciﬁc arguments too. These are typically addresses
in the memory (e.g. “read the inputs from scalar address 0
and vector address 3; write the output to vector address 2”).
Some ops also require real-valued constants (e.g. µ and σ
for a random Gaussian sampling op), which are searched for
as well. Suppl. Section S2 contains the full list of 65 ops.
# (Setup, Predict, Learn) = input ML algorithm.
# Dtrain / Dvalid = training / validation set.
# sX/vX/mX: scalar/vector/matrix var at address X.
def Evaluate(Setup, Predict, Learn, Dtrain,
Dvalid):
# Zero-initialize all the variables (sX/vX/mX).
initialize_memory()
Setup() # Execute setup instructions.
for (x, y) in Dtrain:
v0 = x # x will now be accessible to Predict.
Predict() # Execute prediction instructions.
# s1 will now be used as the prediction.
s1 = Normalize(s1) # Normalize the prediction.
s0 = y # y will now be accessible to Learn.
Learn() # Execute learning instructions.
sum_loss = 0.0
for (x, y) in Dvalid:
v0 = x
Predict() # Only Predict(), not Learn().
s1 = Normalize(s1)
sum_loss += Loss(y, s1)
mean_loss = sum_loss / len(Dvalid)
# Use validation loss to evaluate the algorithm.
return mean_loss
Figure 1: Algorithm evaluation on one task. We represent an
algorithm as a program with three component functions (Setup,
Predict, Learn). These are evaluated by the pseudo-code above,
producing a mean loss for each task. The search method then uses
the median across tasks as an indication of the algorithm’s quality.
Inspired by supervised learning work, we represent an al-
gorithm as a program with three component functions that
we call Setup, Predict, and Learn (e.g. Figure 5). The
algorithm is evaluated as in Fig 1. There, the two for-loops
implement the training and validation phases, processing

AutoML-Zero
def Setup():
def Predict(v0):
s9 = arctan(s2)
s9 = mean(v5)
def Learn(v0, s0):
v1 = s9 * v1
def Setup():
s4 = 0.5
s5 = 0.5
m4 = gauss(0,1)
def Predict(v0):
v1 = v0 - v9
m4 = s2 * m4
def Learn(v0, s0):
m2 = m2 + m4)
def Setup():
def Predict(v0):
def Learn(v0, s0):
def Setup():
s4 = 0.5
def Predict(v0):
v1 = v0 - v9
v5 = v0 + v9
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
def Setup():
def Predict(v0):
def Learn(v0, s0):
v4 = v2 - v1
s3 = mean(v2)
s4 = mean(v1)
s3 = s3 + s4)
def Setup():
def Predict(v0):
s9 = arctan(s2)
s9 = mean(v5)
def Learn(v0, s0):
v1 = s9 * v1
def Setup():
s4 = 0.5
s5 = 0.5
m4 = gauss(0,1)
def Predict(v0):
v1 = v0 - v9
m4 = s2 * m4
def Learn(v0, s0):
m2 = m2 + m4)
def Setup():
def Predict(v0):
def Learn(v0, s0):
def Setup():
s4 = 0.5
def Predict(v0):
v1 = v0 - v9
v5 = v0 + v9
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
def Setup():
def Predict(v0):
def Learn(v0, s0):
v4 = v2 - v1
s3 = mean(v2)
s4 = mean(v1)
s3 = s3 + s4)
Step 1
oldest
newest
def Setup():
s4 = 0.5
s5 = 0.5
m4 = gauss(0,1)
def Predict(v0):
v1 = v0 - v9
m4 = s2 * m4
def Learn(v0, s0):
m2 = m2 + m4)
def Setup():
def Predict(v0):
def Learn(v0, s0):
def Setup():
s4 = 0.5
def Predict(v0):
v1 = v0 - v9
v5 = v0 + v9
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
def Setup():
def Predict(v0):
def Learn(v0, s0):
v4 = v2 - v1
s3 = mean(v2)
s4 = mean(v1)
s3 = s3 + s4)
Step 2
best
def Setup():
s4 = 0.5
s5 = 0.5
m4 = gauss(0,1)
def Predict(v0):
v1 = v0 - v9
m4 = s2 * m4
def Learn(v0, s0):
m2 = m2 + m4)
def Setup():
def Predict(v0):
def Learn(v0, s0):
def Setup():
s4 = 0.5
def Predict(v0):
v1 = v0 - v9
v5 = v0 + v9
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
def Setup():
def Predict(v0):
def Learn(v0, s0):
v4 = v2 - v1
s3 = mean(v2)
s4 = mean(v1)
s3 = s3 + s4)
def Setup():
s4 = 0.5
def Predict(v0):
v1 = v0 - v9
v5 = v0 + v9
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
Step 3
copy best
def Setup():
s4 = 0.5
s5 = 0.5
m4 = gauss(0,1)
def Predict(v0):
v1 = v0 - v9
m4 = s2 * m4
def Learn(v0, s0):
m2 = m2 + m4)
def Setup():
def Predict(v0):
def Learn(v0, s0):
def Setup():
s4 = 0.5
def Predict(v0):
v1 = v0 - v9
v5 = v0 + v9
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
def Setup():
def Predict(v0):
def Learn(v0, s0):
v4 = v2 - v1
s3 = mean(v2)
s4 = mean(v1)
s3 = s3 + s4)
def Setup():
s4 = 0.5
def Predict(v0):
v1 = v0 - v9
v5 = v0 + v9
m1 = s2 * m2
def Learn(v0, s0):
s3 = abs(s1)
Step 4
mutate
Figure 2: One cycle of the evolutionary method (Goldberg & Deb,
1991; Real et al., 2019). A population of P algorithms (here,
P=5; laid out from left to right in the order they were discovered)
undergoes many cycles like this one. First, we remove the oldest
algorithm (step 1). Then, we choose a random subset of size T
(here, T=3) and select the best of them (step 2). The best is copied
(step 3) and mutated (step 4).
the task’s examples one-at-a-time for simplicity. The train-
ing phase alternates Predict and Learn executions. Note
that Predict just takes in the features of an example (i.e.
x)—its label (i.e. y) is only seen by Learn afterward.
Then, the validation loop executes Predict over the val-
idation examples. After each Predict execution, what-
ever value is in scalar address 1 (i.e. s1) is considered
the prediction—Predict has no restrictions on what it
can write there. For classiﬁcation tasks, this prediction
in (−∞, ∞) is normalized to a probability in (0, 1) through
a sigmoid (binary classiﬁcation) or a softmax (multi-class).
This is implemented as the s1 = Normalize(s1) instruc-
tion. The virtual memory is zero-initialized and persis-
tent, and shared globally throughout the whole evalua-
tion. This way, Setup can initialize memory variables (e.g.
the weights), Learn can adjust them during training, and
Predict can use them. This procedure yields an accuracy
for each task. The median across D tasks is used as a mea-
sure of the algorithm’s quality by the search method.
3.2. Search Method
Search experiments must discover algorithms by modify-
ing the instructions in the component functions (Setup,
Predict, and Learn; e.g. Figure 5). Unless otherwise
def Setup():
s4 = 0.5
def Predict(v0):
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
def Setup():
s4 = 0.5
def Predict(v0):
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s2 = sin(v1)
s3 = abs(s1)
def Setup():
s4 = 0.5
def Predict(v0):
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
v3 = abs(s1)
def Setup():
s4 = 0.5
def Predict(v0):
m1 = s2 * m2
def Learn(v0, s0):
s0 = mean(m1)
s5 = arctan(s7)
def Setup():
s4 = 0.5
def Predict(v0):
m1 = s2 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
def Setup():
s4 = 0.5
def Predict(v0):
m1 = s7 * m2
def Learn(v0, s0):
s4 = s0 - s1
s3 = abs(s1)
Type (i)
Type (ii)
Type (iii)
parent
child
Figure 3: Mutation examples. Parent algorithm is on the left; child
on the right. (i) Insert a random instruction (removal also possible).
(ii) Randomize a component function. (iii) Modify an argument.
stated, we use the regularized evolution search method be-
cause of its simplicity and recent success on architecture
search benchmarks (Real et al., 2019; Ying et al., 2019; So
et al., 2019). This method is illustrated in Figure 2. It keeps
a population of P algorithms, all initially empty—i.e. none
of the three component functions has any instructions/code
lines. The population is then improved through cycles. Each
cycle picks T < P algorithms at random and selects the
best performing one as the parent, i.e. tournament selection
(Goldberg & Deb, 1991). This parent is then copied and
mutated to produce a child algorithm that is added to the
population, while the oldest algorithm in the population is
removed. The mutations that produce the child from the
parent must be tailored to the search space; we use a random
choice among three types of actions: (i) insert a random
instruction or remove an instruction at a random location
in a component function, (ii) randomize all the instructions
in a component function, or (iii) modify one of the argu-
ments of an instruction by replacing it with a random choice
(e.g. “swap the output address” or “change the value of a
constant”). These are illustrated in Figure 3.
In order to reach a throughput of 2k–10k algorithms/sec-
ond/cpu core, besides the use of small proxy tasks, we apply
two additional upgrades: (1) We introduce a version of func-
tional equivalence checking (FEC) that detects equivalent
supervised ML algorithms, even if they have different imple-
mentations, achieving a 4x speedup. To do this, we record

AutoML-Zero
the predictions of an algorithm after executing 10 training
and 10 validation steps on a ﬁxed set of examples. These
are then truncated and hashed into a ﬁngerprint for the al-
gorithm to detect duplicates in the population and reuse
previous evaluation scores. (2) We add hurdles (So et al.,
2019) to reach further 5x throughput. In addition to (1) and
(2), to attain higher speeds through parallelism, we distribute
experiments across worker processes that exchange models
through migration (Alba & Tomassini, 2002); each process
has its own P-sized population and runs on a commodity
CPU core. We denote the number of processes by W. Typi-
cally, 100<W<1000 (we indicate the exact numbers with
each experiment2). Workers periodically upload randomly
selected algorithms to a central server. The server replies
with algorithms randomly sampled across all workers, re-
placing half the local population (i.e. random migration).
To additionally improve the quality of the search, we allow
some workers to search on projected binary MNIST tasks,
in addition to projected binary CIFAR-10, to promote diver-
sity (see e.g. (Wang et al., 2019)). More details about these
techniques can be found in Suppl. Section S3. Section 5 and
Suppl. Section S9 contain ablation studies showing that all
these techniques are beneﬁcial.
For each experimental result, we include an Experiment
Details paragraph with the exact values for meta-parameters
like P and T. None of the meta-parameters were tuned
in the ﬁnal set of experiments at full compute scale. Most
of them were either decided in smaller experiments (e.g.
P), taken from previous work (e.g. T), or simply not tuned
at all. In some cases, when uncertain about a parameter’s
appropriate value, we used a range of values instead (e.g.
“100 ≤P ≤1000”); different worker processes within the
experiment use different values within the range.
Details: Generally, we use T=10, 100 ≤P ≤1000. Each
child algorithm is mutated with probability U=0.9. Run time: 5
days. Migration rate adjusted so that each worker process has
fewer than 1 migration/s and at least 100 migrations throughout
the expt. Speciﬁcs for each expt. in Suppl. Section S5. Suppl.
Section S3 describes additional more general methods minutiae.
4. Results
In the next three sections, we will perform experiments to
answer the following three questions, respectively: “how
difﬁcult is searching the AutoML-Zero space?”, “can we
use our framework to discover reasonable algorithms with
minimal human input?”, and “can we discover different
algorithms by varying the type of task we use during the
search experiment?”
2The electricity consumption for our experiments (which were
run in 2019) was matched with purchases of renewable energy.
4.1. Finding Simple Neural Nets in a Difﬁcult Space
We now demonstrate the difﬁculty of the search space
through random search (RS) experiments and we show that,
nonetheless, interesting algorithms can be found, especially
with evolutionary search. We will explore the beneﬁts of
evolution as we vary the task difﬁculty. We start by search-
ing for algorithms to solve relatively easy problems, such as
ﬁtting linear regression data. Note that without the following
simpliﬁcations, RS would not be able to ﬁnd solutions.
Experiment Details: we generate simple regression tasks
with 1000 training and 100 validation examples with random 8-
dim. feature vectors {xi} and scalar labels {L(xi)}. L is ﬁxed
for each task but varies between them. To get afﬁne tasks, L(xi)=
u·xi+a, where u and a are a random vector and scalar. For linear
tasks, a=0. All random numbers were Gaussian (µ=0, σ=1).
Evaluations use RMS error and the Normalize() instruction in
Figure 1 is the identity. We restrict the search space by only
using necessary ops and ﬁxing component function lengths to
those of known solutions. E.g., for a linear dataset, Learn has 4
instructions because linear SGD requires 4 instructions. To keep
lengths ﬁxed, insert/remove-instruction mutations are not allowed
and component functions are initialized randomly. RS generates
programs where all instructions are random (see Section 3.2) and
selects the best at the end. Evolution expts. are small (W=1; D=
3; 10k algs./expt.); We repeat expts. until statistical signiﬁcance
is achieved. Full conﬁgs. in Suppl. Section S5. Note that the
restrictions above apply *only* to this section (4.1).
We quantify a task’s difﬁculty by running a long RS experi-
ment. We count the number of acceptable algorithms, i.e.
those with lower mean RMS error than a hand-designed
reference (e.g. linear regressor or neural network). The
ratio of acceptable algorithms to the total number of algo-
rithms evaluated gives us an RS success rate. It can also
be interpreted as an estimate of the “density of acceptable
algorithms” in the search space. We use this density as a
measure of problem difﬁculty. For example, in the linear
regression case, we looked for all algorithms that do better
than a linear regressor with gradient descent. Even in this
trivial task type, we found only 1 acceptable algorithm ev-
ery 107, so we deﬁne 107 to be the difﬁculty of the linear
regression task. We then run the evolution experiments with
the same combined total number of evaluations as for RS.
We measure the ratio of acceptable algorithms to the total
number of algorithms evaluated, to get an evolution success
rate. However, we only count at most 1 acceptable algo-
rithm from each experiment; this biases the results against
evolution but is necessary because a single experiment may
yield multiple copies of a single acceptable algorithm. Even
in the simple case of linear regression, we ﬁnd that evolution
is 5 times more efﬁcient than RS. This stands in contrast
to many previous AutoML studies, where the solutions are
dense enough that RS can be competitive (Section 1).
Figure 4 summarizes the result of this analysis for 4 task
types: the discovery of a full-algorithm/only-the-learning

AutoML-Zero
106
107
109
1012
task difficulty
2.9
5.6
150
23000
evolution / RS success   
Affine regressor
Affine regressor
(learning only)
Linear regressor
Linear regressor (learning only)
Figure 4: Relative success rate of evolution and random search
(RS). Each point represents a different task type and the x-axis
measures its difﬁculty (deﬁned in the main text). As the task
type becomes more difﬁcult, evolution vastly outperforms RS,
illustrating the complexity of AutoML-Zero when compared to
more traditional AutoML spaces.
for linear/afﬁne regression data. The AutoML-Zero search
space is generic but this comes at a cost: even for easy prob-
lems, good algorithms are sparse. As the problem becomes
more difﬁcult, the solutions become vastly more sparse and
evolution greatly outperforms RS.
As soon as we advance to nonlinear data, the gap widens
and we can no longer ﬁnd solutions with RS. To make sure
a good solution exists, we generate regression tasks using
teacher neural networks and then verify that evolution can
rediscover the teacher’s code.
Experiment Details: tasks as above but the labeling function
is now a teacher network: L(xi)=u·ReLU(Mxi), where M is a
random 8 × 8 matrix, u is a random vector. Number of training
examples up to 100k. Single expt. Same search space restrictions
as above, but now allowing ops used in 2-layer fully connected
neural nets. After searching, we select the algorithm with the
smallest RMS loss. Full conﬁgs. in Suppl. Section S5. Note that
the restrictions above apply *only* to this section (4.1).
When the search method uses only 1 task in Tsearch (i.e.
D=1), the algorithm evolves the exact prediction function
used by the teacher and hard-codes its weights. The results
become more surprising as we increase the number of tasks
in Tsearch (e.g. to D=100), as now the algorithm must ﬁnd
different weights for each task. In this case, evolution not
only discovers the forward pass, but also “invents” back-
propagation code to learn the weights (Figure 5). Despite
its difﬁculty, we conclude that searching the AutoML-Zero
space seems feasible and we should use evolutionary search
instead of RS for more complex tasks.
4.2. Searching with Minimal Human Input
Teacher datasets and carefully chosen ops bias the results
in favor of known algorithms, so in this section we replace
them with more generic options. We now search among a
# sX/vX/mX = scalar/vector/matrix at address X.
# “gaussian” produces Gaussian IID random numbers.
def Setup():
# Initialize variables.
m1 = gaussian(-1e-10, 9e-09) # 1st layer weights
s3 = 4.1 # Set learning rate
v4 = gaussian(-0.033, 0.01) # 2nd layer weights
def Predict():
# v0=features
v6 = dot(m1, v0) # Apply 1st layer weights
v7 = maximum(0, v6) # Apply ReLU
s1 = dot(v7, v4) # Compute prediction
def Learn():
# s0=label
v3 = heaviside(v6, 1.0) # ReLU gradient
s1 = s0 - s1 # Compute error
s2 = s1 * s3 # Scale by learning rate
v2 = s2 * v3 # Approx. 2nd layer weight delta
v3 = v2 * v4 # Gradient w.r.t. activations
m0 = outer(v3, v0) # 1st layer weight delta
m1 = m1 + m0 # Update 1st layer weights
v4 = v2 + v4 # Update 2nd layer weights
Figure 5: Rediscovered neural network algorithm. It implements
backpropagation by gradient descent. Comments added manually.
long list of ops selected based on the simplicity criterion
described in Section 3.1. The increase in ops makes the
search more difﬁcult but allows the discovery of solutions
other than neural networks. For more realistic datasets, we
use binary classiﬁcation tasks extracted from CIFAR-10 and
MNIST.
Experiment Details: We extract tasks from the CIFAR-10
and MNIST training sets; each of the datasets are searched on
by half of the processes. For both datasets, the 45 pairs of the 10
classes yield tasks with 8000 train / 2000 valid examples. 36 pairs
are randomly selected to constitute Tsearch, i.e. search tasks; 9
pairs are held out for Tselect, ı.e tasks for model selection. The
CIFAR-10 test set is reserved for ﬁnal evaluation to report results.
Features are projected to 8 ≤F ≤256 dim. Each evaluation is
on 1 ≤D ≤10 tasks. W =10k. From now on, we use the full
setup described in Section 3.2. In particular, we allow variable
component function length. Number of possible ops: 7/ 58/ 58 for
Setup/ Predict/ Learn, resp. Full conﬁg. in Suppl. Section S5.
Figure 6 shows the progress of an experiment. It starts with
a population of empty programs and automatically invents
improvements, several of which are highlighted in the plot.
These intermediate discoveries are stepping stones available
to evolution and they explain why evolution outperforms
RS in this space. Each experiment produces a candidate
algorithm using Tsearch. We then evaluate these algorithms
on unseen pairs of classes (Tselect) and compare the results
to a hand-designed reference, a 2-layer fully connected
neural network trained by gradient descent. The candidate
algorithms perform better in 13 out of 20 experiments. To
make sure the improvement is not speciﬁc to the small proxy
tasks, we select the best algorithm for a ﬁnal evaluation on
binary classiﬁcation with the original CIFAR-10 data.
Since we are evaluating on tasks with different dimensional-

AutoML-Zero
0
0.5
0.9
Best Accuracy Found
Empty Algorithm
10
12
Experiment Progress (Log # Algorithms Evaluated)
Linear Model
(No SGD)
Linear Model
(Flawed SGD)
Loss Clipping
Linear Model (SGD)
Random Learning Rate
Better
HParams
Gradient Divided
by Input Norm
Hard-coded LR
ReLU
Random Weight Init
Gradient Normalization
Multiplicative Interactions
(Flawed SGD)
Multiplicative Interactions
(SGD)
Best Evolved Algorithm
def Setup():
def Predict():
def Learn():
def Setup():
# Init weights
v1 = gaussian(0.0, 0.01)
s2 = -1.3
def Predict(): # v0=features
s1 = dot(v0, v1) # Prediction
def Learn(): # s0=label
s3 = s1 / s2 # Scale predict.
s1 = s0 + s3 # Compute error
v2 = s1 * v0 # Gradient
v1 = v1 + v2 # Update weights
Normalize:
y = f(o) ∈ (0, 1)
Error:
𝛿 = y* - y
Weights: 
o = aTWb
Gradient:
g = 𝛿abT
Unit Vector: 
gW = g / |g|
Noisy Input: 
a = x + 𝝴 
b = x - 𝝴
Accumulated Weights: 
W' = 𝜮t Wt
Update W 
Forward
Backward 
Input: x
Label: y*
def Setup():
s4 = 1.8e-3 # Learning rate
def Predict(): # v0=features
v2 = v0 + v1 # Add noise
v3 = v0 - v1 # Subtract noise
v4 = dot(m0, v2) # Linear
s1 = dot(v3, v4) # Mult.interac.
m0 = s2 * m2 # Copy weights
def Learn(): # s0=label
s3 = s0 - s1 # Compute error
m0 = outer(v3, v0) # Approx grad
s2 = norm(m0) # Approx grad norm
s5 = s3 / s2 # Normalized error
v5 = s5 * v3
m0 = outer(v5, v2) # Grad
m1 = m1 + m0 # Update weights
m2 = m2 + m1 # Accumulate wghts.
m0 = s4 * m1
# Generate noise
v1 = uniform(2.4e-3, 0.67)
Figure 6: Progress of one evolution experiment on projected binary CIFAR-10. Callouts indicate some beneﬁcial discoveries. We also
print the code for the initial, an intermediate, and the ﬁnal algorithm. The last is explained in the ﬂow diagram. It outperforms a simple
fully connected neural network on held-out test data and transfers to features 10x its size. Code notation is the same as in Figure 5. The
x-axis gap is due to infrequent recording due to disk throughput limitations.
ity in the ﬁnal evaluation, we treat all the constants in the
best evolved algorithm as hyperparameters and tune them
jointly through RS using the validation set. For compari-
son, we tune two hand-designed baselines, one linear and
one nonlinear, using the same total compute that went into
discovering and tuning the evolved algorithm. We ﬁnally
evaluate them all on unseen CIFAR-10 test data. Evaluating
with 5 different random seeds, the best evolved algorithm’s
accuracy (84.06 ± 0.10%) signiﬁcantly outperforms the lin-
ear baseline (logistic regression, 77.65 ± 0.22%) and the
nonlinear baseline (2-layer fully connected neural network,
82.22 ± 0.17%). This gain also generalizes to binary classi-
ﬁcation tasks extracted from other datasets: SVHN (Netzer
et al., 2011) (88.12% for the best evolved algorithm vs.
59.58% for the linear baseline vs. 85.14% for the nonlinear
baseline), downsampled ImageNet (Chrabaszcz et al., 2017)
(80.78% vs. 76.44% vs. 78.44%), Fashion MNIST (Xiao
et al., 2017) (98.60% vs. 97.90% vs. 98.21%). This algo-
rithm is limited by our simple search space, which cannot
currently represent some techniques that are crucial in state-
of-the-art models, like batch normalization or convolution.
Nevertheless, the algorithm shows interesting characteris-
tics, which we describe below.
As a case study, we delve into the best algorithm, shown
in Figure 6. The code has been cleaned for readability; we
removed and rearranged instructions when this caused no
difference in performance (raw code in Suppl. Section S6).
The algorithm has the following notable features, whose
usefulness we veriﬁed through ablations (more details in
Suppl. Section S8): (1) Noise is added to the input, which,
we suspect, acts as a regularizer:
a = x + u; b = x −u; u ∼U(α, β)
where x is the input, u is a random vector drawn from a
uniform distribution. (2) Multiplicative interactions (Jayaku-
mar et al., 2020) emerge in a bilinear form: o = a⊺Wb,
where o is the output, and W is the weight matrix. (3) The
gradient g w.r.t. the weight matrix W is computed correctly
and is then normalized to be a unit vector:
gw = g
|g|; g = δab⊺; δ = y∗−y;
where δ is the error, y is the predicted probability, and y∗
is the label. Normalizing gradients is a common heuris-

AutoML-Zero
tic in non-convex optimization (Hazan et al., 2015; Levy,
2016). (4) The weight matrix W′ used during inference
is the accumulation of all the weight matrices {Wt} after
each training step t, i.e.: W′ = P
t Wt. This is reminis-
cent of the averaged perceptron (Collins, 2002) and neural
network weight averaging during training (Polyak & Judit-
sky, 1992; Goodfellow et al., 2016). Unlike these studies,
the evolved algorithm accumulates instead of averaging, but
this difference has no effect when measuring the accuracy
of classiﬁcation tasks (it does not change the prediction).
As in those techniques, different weights are used at train-
ing and validation time. The evolved algorithm achieves
this by setting the weights W equal to W′ at the end of
the Predict component function and resetting them to Wt
right after that, at the beginning of the Learn component
function. This has no effect during training, when Predict
and Learn alternate in execution. However, during val-
idation, Learn is never called and Predict is executed
repeatedly, causing W to remain as W′.
In conclusion, even though the task used during search is
simple, the results show that our framework can discover
commonly used algorithms from scratch.
4.3. Discovering Algorithm Adaptations
In this section, we will show wider applicability by search-
ing on three different task types. Each task type will impose
its own challenge (e.g. “too little data”). We will show that
evolution speciﬁcally adapts the algorithms to meet the chal-
lenges. Since we already reached reasonable models from
scratch above, now we save time by simply initializing the
populations with the working neural network of Figure 5.
Experiment Details: The basic expt. conﬁguration and
datasets (binary CIFAR-10) are as in Section 4.2, with the fol-
lowing exceptions: W =1k; F =16; 10 ≤D ≤100; critical
alterations to the data are explained in each task type below. Full
conﬁgs. in Suppl. Section S5.
Few training examples. We use only 80 of the training
examples and repeat them for 100 epochs. Under these
conditions, algorithms evolve an adaptation that augments
the data through the injection of noise (Figure 7a). This is
referred to in the literature as a noisy ReLU (Nair & Hinton,
2010; Bengio et al., 2013) and is reminiscent of Dropout
(Srivastava et al., 2014). Was this adaptation a result of the
small number of examples or did we simply get lucky? To
answer this, we perform 30 repeats of this experiment and
of a control experiment. The control has 800 examples/100
epochs. We ﬁnd that the noisy ReLU is reproducible and
arises preferentially in the case of little data (expt: 8/30,
control: 0/30, p<0.0005).
Fast training. Training on 800 examples/10 epochs leads
to the repeated emergence of learning-rate decay, a well-
known strategy for the timely training of an ML model
(Bengio, 2012). An example can be seen in Figure 7b. As
a control, we increase the number of epochs to 100. With
overwhelming conﬁdence, the decay appears much more
often in the cases with fewer training steps (expt: 30/30,
control: 3/30, p<10−14).
Multiple classes. When we use all 10 classes of the CIFAR-
10 dataset, evolved algorithms tend to use the transformed
mean of the weight matrix as the learning rate (Figure 7c).
(Note that to support multiple classes, labels and outputs are
now vectors, not scalars.) While we do not know the rea-
son, the preference is statistically signiﬁcant (expt: 24/30,
control: 0/30, p<10−11).
Altogether, these experiments show that the resulting algo-
rithms seem to adapt well to the different types of tasks.
def Predict():
...
# Omitted/irrelevant code
# v0=features; m1=weight matrix
v6 = dot(m1, v0) # Apply weights
# Random vector, μ=-0.5 and σ=0.41
v8 = gaussian(-0.5, 0.41)
v6 = v6 + v8 # Add it to activations
v7 = maximum(v9, v6) # ReLU, v9≈0
...
ReLU:
max(0, Wx + n)
Noise: n = N(μ,σ)
Input: x
Linear: Wx
(a) Adaptation to few examples.
def Setup():
# LR = learning rate
s2 = 0.37 # Init. LR
...
def Learn():
# Decay LR
s2 = arctan(s2)
...
0
8
Log # Train Steps 
-4
1
Log LR
(b) Adaptation to fast train-
ing.
def Learn():
s3 = mean(m1) # m1 is the weights.
s3 = abs(s3)
s3 = sin(s3)
# From here down, s3 is used as
# the learning rate.
...
Weights mean:
𝛼 = Σ Wi,j / n
Transform:
LR = sin(abs(𝛼))
(c) Adaptation to multiple classes.
Figure 7: Adaptations to different task types. (a) When few examples are available, evolution creates a noisy ReLU. (b) When fast training
is needed, we get a learning rate decay schedule implemented as an iterated arctan map (top) that is nearly exponential (bottom). (c) With
multiple classes, the mean of the weight matrix is transformed and then used as the learning rate. Same notation as in Figure 5; full
algorithms in Suppl. Section S6.

AutoML-Zero
5. Conclusion and Discussion
In this paper, we proposed an ambitious goal for AutoML:
the automatic discovery of whole ML algorithms from basic
operations with minimal restrictions on form. The objective
was to reduce human bias in the search space, in the hope
that this will eventually lead to new ML concepts. As a start,
we demonstrated the potential of this research direction by
constructing a novel framework that represents an ML algo-
rithm as a computer program comprised of three component
functions (Setup, Predict, Learn). Starting from empty
component functions and using only basic mathematical
operations, we evolved neural networks, gradient descent,
multiplicative interactions, weight averaging, normalized
gradients, and the like. These results are promising, but
there is still much work to be done. In the remainder of
this section, we motivate future work with concrete observa-
tions.
The search method was not the focus of this study but to
reach our results, it helped to (1) add parallelism through
migration, (2) use FEC, (3) increase diversity, and (4) ap-
ply hurdles, as we detailed in Section 3.2. The effects can
be seen in Figure 8. Suppl. Section S9 shows that these
improvements work across compute scales (today’s high-
compute regime is likely to be tomorrow’s low-compute
regime, so ideas that do not scale with compute will be
shorter-lived). Preliminary implementations of crossover
and geographic structure did not help in our experiments.
The silver lining is that the AutoML-Zero search space pro-
vides ample room for algorithms to distinguish themselves
(e.g. Section 4.1), allowing future work to attempt more so-
phisticated evolutionary approaches, reinforcement learning,
Bayesian optimization, and other methods that have helped
AutoML before.
Base
+Migration
(1)
+FEC
(2)
+MNIST
(3)
+Hurdle
(4)
0.69
0.76
Best Accuracy Found
(CIFAR-10)
Figure 8: Search method ablation study. From left to right, each
column adds an upgrade, as described in the main text.
Evaluating evolved algorithms on new tasks requires hy-
perparameter tuning, as is common for machine learning
algorithms, but without inspection we may not know what
each variable means (e.g. “Is s7 the learning rate?”). Tun-
ing all constants in the program was insufﬁcient due to
hyperparameter coupling, where an expression happens to
produce a good value for a hyperparameter on a speciﬁc
set of tasks but won’t generalize. For example, evolution
may choose s7=v2·v2 because v2·v2 coincides with a good
value for the hyperparameter s7. We address this through
manual decoupling (e.g. recognizing the problematic code
line and instead setting s7 to a constant that can be tuned
later). This required time-consuming analysis that could be
automated by future work. More details can be found in
Suppl. Section S7.
Interpreting evolved algorithms also required effort due
to the complexity of their raw code (Suppl. Section S8).
The code was ﬁrst automatically simpliﬁed by removing
redundant instructions through static analysis. Then, to de-
cide upon interesting code snippets, Section 4.3 focused on
motifs that reappeared in independent search experiments.
Such convergent evolution provided a hypothesis that a code
section may be beneﬁcial. To verify this hypothesis, we
used ablations/knock-outs and knock-ins, the latter being
the insertion of code sections into simpler algorithms to
see if they are beneﬁcial there too. This is analogous to
homonymous molecular biology techniques used to study
gene function. Further work may incorporate other tech-
niques from the natural sciences or machine learning where
interpretation of complex systems is key.
Search space enhancements have improved architecture
search dramatically. In only two years, for example, compa-
rable experiments went from requiring hundreds of GPUs
(Zoph et al., 2018) to only one (Liu et al., 2019b). Sim-
ilarly, enhancing the search space could bring signiﬁcant
improvements to AutoML-Zero. Also note that, despite our
best effort to reduce human bias, there is still implicit bias
in our current search space that limits the potential to dis-
cover certain types of algorithms. For instance, to keep our
search space simple, we process one example at a time, so
discovering techniques that work on batches of examples
(like batch-norm) would require adding loops or higher-
order tensors. As another case in point, in the current search
space, a multi-layer neural network can only be found by
discovering each layer independently; the addition of loops
or function calls could make it easier to unlock such deeper
structures.
Author Contributions
ER and QVL conceived the project; ER led the project;
QVL provided advice; ER designed the search space, built
the initial framework, and demonstrated plausibility; CL
designed proxy tasks, built the evaluation pipeline, and
analyzed the algorithms; DRS improved the search method
and scaled up the infrastructure; ER, CL, and DRS ran the
experiments; ER wrote the paper with contributions from
CL; all authors edited the paper and prepared the ﬁgures;
CL open-sourced the code.

AutoML-Zero
Acknowledgements
We would like to thank Samy Bengio, Vincent Vanhoucke,
Doug Eck, Charles Sutton, Yanping Huang, Jacques Pienaar,
and Jeff Dean for helpful discussions, and especially Gabriel
Bender, Hanxiao Liu, Rishabh Singh, Chiyuan Zhang, Hieu
Pham, David Dohan and Alok Aggarwal for useful com-
ments on the paper, as well as the larger Google Brain team.
References
Alba, E. and Tomassini, M. Parallelism and evolutionary
algorithms. IEEE transactions on evolutionary computa-
tion, 2002.
Alet, F., Schneider, M. F., Lozano-Perez, T., and Kaelbling,
L. P. Meta-learning curiosity algorithms. In International
Conference on Learning Representations, 2019.
Andrychowicz, M., Denil, M., Gomez, S., Hoffman, M. W.,
Pfau, D., Schaul, T., and de Freitas, N. Learning to learn
by gradient descent by gradient descent. In NIPS, 2016.
Angeline, P. J., Saunders, G. M., and Pollack, J. B. An
evolutionary algorithm that constructs recurrent neural
networks. IEEE transactions on Neural Networks, 1994.
Baker, B., Gupta, O., Naik, N., and Raskar, R. Designing
neural network architectures using reinforcement learn-
ing. In ICLR, 2017.
Balog, M., Gaunt, A. L., Brockschmidt, M., Nowozin, S.,
and Tarlow, D. Deepcoder: Learning to write programs.
ICLR, 2017.
Bello, I., Zoph, B., Vasudevan, V., and Le, Q. V. Neural
optimizer search with reinforcement learning. ICML,
2017.
Bengio, S., Bengio, Y., and Cloutier, J. Use of genetic
programming for the search of a new learning rule for
neural networks. In Evolutionary Computation, 1994.
Bengio, Y. Practical recommendations for gradient-based
training of deep architectures. In Neural networks: Tricks
of the trade. Springer, 2012.
Bengio, Y., Léonard, N., and Courville, A. Estimating
or propagating gradients through stochastic neurons for
conditional computation. arXiv preprint, 2013.
Bergstra, J. and Bengio, Y.
Random search for hyper-
parameter optimization. JMLR, 2012.
Cai, H., Zhu, L., and Han, S. Proxylessnas: Direct neural
architecture search on target task and hardware. ICLR,
2019.
Chalmers, D. J. The evolution of learning: An experiment in
genetic connectionism. In Connectionist Models. Elsevier,
1991.
Chen, X., Liu, C., and Song, D. Towards synthesizing
complex programs from input-output examples. arXiv
preprint arXiv:1706.01284, 2017.
Chrabaszcz, P., Loshchilov, I., and Hutter, F. A downsam-
pled variant of imagenet as an alternative to the cifar
datasets. arXiv preprint arXiv:1707.08819, 2017.
Collins, M. Discriminative training methods for hidden
markov models: Theory and experiments with perceptron
algorithms. In Proceedings of the ACL-02 conference
on Empirical methods in natural language processing-
Volume 10, pp. 1–8. Association for Computational Lin-
guistics, 2002.
Cubuk, E. D., Zoph, B., Mane, D., Vasudevan, V., and Le,
Q. V. Autoaugment: Learning augmentation policies
from data. CVPR, 2019a.
Cubuk, E. D., Zoph, B., Shlens, J., and Le, Q. V. Ran-
daugment: Practical automated data augmentation with a
reduced search space. arXiv preprint arXiv:1909.13719,
2019b.
Devlin, J., Uesato, J., Bhupatiraju, S., Singh, R., rahman
Mohamed, A., and Kohli, P. Robustﬁll: Neural program
learning under noisy i/o. In ICML, 2017.
Elsken, T., Metzen, J. H., and Hutter, F. Efﬁcient multi-
objective neural architecture search via lamarckian evolu-
tion. In ICLR, 2019a.
Elsken, T., Metzen, J. H., and Hutter, F. Neural architec-
ture search. In Automated Machine Learning. Springer,
2019b.
Fahlman, S. E. and Lebiere, C. The cascade-correlation
learning architecture. In NIPS, 1990.
Finn, C., Abbeel, P., and Levine, S. Model-agnostic meta-
learning for fast adaptation of deep networks. In ICML,
2017.
Forsyth, R. et al. Beagle-a darwinian approach to pattern
recognition. Kybernetes, 10(3):159–166, 1981.
Gaier, A. and Ha, D. Weight agnostic neural networks. In
NeurIPS, 2019.
Ghiasi, G., Lin, T.-Y., and Le, Q. V. Nas-fpn: Learning
scalable feature pyramid architecture for object detection.
In CVPR, 2019.
Goldberg, D. E. and Deb, K. A comparative analysis of
selection schemes used in genetic algorithms. FOGA,
1991.

AutoML-Zero
Goodfellow, I., Bengio, Y., and Courville, A. Deep learning.
MIT press, 2016.
Graves, A., Wayne, G., and Danihelka, I. Neural turing
machines. arXiv preprint arXiv:1410.5401, 2014.
Gulwani, S., Polozov, O., Singh, R., et al. Program synthesis.
Foundations and Trends R⃝in Programming Languages,
2017.
Hazan, E., Levy, K., and Shalev-Shwartz, S. Beyond convex-
ity: Stochastic quasi-convex optimization. In Advances in
Neural Information Processing Systems, pp. 1594–1602,
2015.
He, K., Zhang, X., Ren, S., and Sun, J. Delving deep
into rectiﬁers: Surpassing human-level performance on
imagenet classiﬁcation. In ICCV, 2015.
Hochreiter, S. and Schmidhuber, J. Long short-term memory.
Neural Computation, 1997.
Holland, J. Adaptation in natural and artiﬁcial systems: an
introductory analysis with application to biology. Control
and artiﬁcial intelligence, 1975.
Hutter, F., Hoos, H. H., and Leyton-Brown, K. Sequential
model-based optimization for general algorithm conﬁgu-
ration. In LION, 2011.
Jaderberg, M., Dalibard, V., Osindero, S., Czarnecki, W. M.,
Donahue, J., Razavi, A., Vinyals, O., Green, T., Dunning,
I., Simonyan, K., et al. Population based training of
neural networks. arXiv, 2017.
Jayakumar, S. M., Menick, J., Czarnecki, W. M., Schwarz,
J., Rae, J., Osindero, S., Teh, Y. W., Harley, T., and
Pascanu, R. Multiplicative interactions and where to ﬁnd
them. In ICLR, 2020.
Kim, M. and Rigazio, L. Deep clustered convolutional
kernels. arXiv, 2015.
Koza, J. R. and Koza, J. R. Genetic programming: on the
programming of computers by means of natural selection.
MIT press, 1992.
Krizhevsky, A. and Hinton, G. Learning multiple layers
of features from tiny images. Master’s thesis, Dept. of
Computer Science, U. of Toronto, 2009.
Lake, B. M., Salakhutdinov, R., and Tenenbaum, J. B.
Human-level concept learning through probabilistic pro-
gram induction. Science, 350(6266):1332–1338, 2015.
LeCun, Y., Bengio, Y., et al. Convolutional networks for
images, speech, and time series. The handbook of brain
theory and neural networks, 1995.
LeCun, Y., Cortes, C., and Burges, C. J. The mnist database
of handwritten digits, 1998.
Lenat, D. B. Eurisko: a program that learns new heuristics
and domain concepts: the nature of heuristics iii: program
design and results. Artiﬁcial intelligence, 21(1-2):61–98,
1983.
Levy, K. Y. The power of normalization: Faster evasion of
saddle points. arXiv preprint arXiv:1611.04831, 2016.
Li, K. and Malik, J. Learning to optimize. ICLR, 2017.
Li, L. and Talwalkar, A.
Random search and re-
producibility for neural architecture search.
CoRR,
abs/1902.07638, 2019. URL http://arxiv.org/
abs/1902.07638.
Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A., and
Talwalkar, A. Hyperband: A novel bandit-based approach
to hyperparameter optimization. JMLR, 2018.
Liang, C., Berant, J., Le, Q. V., Forbus, K. D., and Lao, N.
Neural symbolic machines: Learning semantic parsers on
freebase with weak supervision. In ACL, 2016.
Liang, C., Norouzi, M., Berant, J., Le, Q. V., and Lao,
N. Memory augmented policy optimization for program
synthesis and semantic parsing. In NeurIPS, 2018.
Liu, C., Zoph, B., Shlens, J., Hua, W., Li, L.-J., Fei-Fei, L.,
Yuille, A., Huang, J., and Murphy, K. Progressive neural
architecture search. ECCV, 2018.
Liu, C., Chen, L.-C., Schroff, F., Adam, H., Hua, W., Yuille,
A. L., and Fei-Fei, L. Auto-deeplab: Hierarchical neural
architecture search for semantic image segmentation. In
CVPR, 2019a.
Liu, H., Simonyan, K., and Yang, Y. Darts: Differentiable
architecture search. ICLR, 2019b.
Loshchilov, I. and Hutter, F. Cma-es for hyperparameter
optimization of deep neural networks. arXiv preprint
arXiv:1604.07269, 2016.
Mei, J., Li, Y., Lian, X., Jin, X., Yang, L., Yuille, A., and
Yang, J. Atomnas: Fine-grained end-to-end neural archi-
tecture search. ICLR, 2020.
Mendoza, H., Klein, A., Feurer, M., Springenberg, J. T., and
Hutter, F. Towards automatically-tuned neural networks.
In Workshop on Automatic Machine Learning, 2016.
Metz, L., Maheswaranathan, N., Cheung, B., and Sohl-
Dickstein, J. Meta-learning update rules for unsupervised
representation learning. In ICLR, 2019.

AutoML-Zero
Miikkulainen, R., Liang, J., Meyerson, E., Rawal, A., Fink,
D., Francon, O., Raju, B., Shahrzad, H., Navruzyan, A.,
Duffy, N., et al. Evolving deep neural networks. In
Artiﬁcial Intelligence in the Age of Neural Networks and
Brain Computing. Elsevier, 2019.
Nair, V. and Hinton, G. E. Rectiﬁed linear units improve
restricted boltzmann machines. In ICML, 2010.
Neelakantan, A., Le, Q. V., and Sutskever, I. Neural pro-
grammer: Inducing latent programs with gradient descent.
CoRR, abs/1511.04834, 2015.
Negrinho, R., Gormley, M., Gordon, G. J., Patil, D., Le, N.,
and Ferreira, D. Towards modular and programmable
architecture search. In NeurIPS, 2019.
Netzer, Y., Wang, T., Coates, A., Bissacco, A., Wu, B.,
and Ng, A. Y. Reading digits in natural images with
unsupervised feature learning. 2011.
Noy, A., Nayman, N., Ridnik, T., Zamir, N., Doveh, S.,
Friedman, I., Giryes, R., and Zelnik-Manor, L. Asap:
Architecture search, anneal and prune. arXiv, 2019.
Orchard, J. and Wang, L. The evolution of a generalized
neural learning rule. In IJCNN, 2016.
Parisotto, E., rahman Mohamed, A., Singh, R., Li, L., Zhou,
D., and Kohli, P. Neuro-symbolic program synthesis.
ArXiv, abs/1611.01855, 2016.
Park, D. S., Chan, W., Zhang, Y., Chiu, C.-C., Zoph, B.,
Cubuk, E. D., and Le, Q. V. Specaugment: A simple data
augmentation method for automatic speech recognition.
Proc. Interspeech, 2019.
Pitrat, J. Implementation of a reﬂective system. Future
Generation Computer Systems, 12(2-3):235–242, 1996.
Polozov, O. and Gulwani, S. Flashmeta: a framework for
inductive program synthesis. In OOPSLA 2015, 2015.
Polyak, B. T. and Juditsky, A. B. Acceleration of stochastic
approximation by averaging. SIAM journal on control
and optimization, 30(4):838–855, 1992.
Ramachandran, P., Zoph, B., and Le, Q. Searching for
activation functions. ICLR Workshop, 2017.
Ravi, S. and Larochelle, H. Optimization as a model for
few-shot learning. ICLR, 2017.
Real, E., Moore, S., Selle, A., Saxena, S., Suematsu, Y. L.,
Le, Q., and Kurakin, A. Large-scale evolution of image
classiﬁers. In ICML, 2017.
Real, E., Aggarwal, A., Huang, Y., and Le, Q. V. Regu-
larized evolution for image classiﬁer architecture search.
AAAI, 2019.
Reed, S. E. and de Freitas, N.
Neural programmer-
interpreters. CoRR, abs/1511.06279, 2015.
Risi, S. and Stanley, K. O. Indirectly encoding neural plastic-
ity as a pattern of local rules. In International Conference
on Simulation of Adaptive Behavior, 2010.
Rumelhart, D. E., Hinton, G. E., and Williams, R. J. Learn-
ing representations by back-propagating errors. Nature,
1986.
Runarsson, T. P. and Jonsson, M. T. Evolution and design
of distributed learning rules. In ECNN, 2000.
Schmidhuber, J. Evolutionary principles in self-referential
learning, or on learning how to learn: the meta-meta-
... hook. PhD thesis, Technische Universität München,
1987.
Schmidhuber, J. Optimal ordered problem solver. Machine
Learning, 54(3):211–254, 2004.
Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L.,
Van Den Driessche, G., Schrittwieser, J., Antonoglou, I.,
Panneershelvam, V., Lanctot, M., et al. Mastering the
game of go with deep neural networks and tree search.
Nature, 2016.
Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou,
I., Huang, A., Guez, A., Hubert, T., Baker, L., Lai, M.,
Bolton, A., et al. Mastering the game of go without
human knowledge. Nature, 2017.
Snoek, J., Larochelle, H., and Adams, R. P.
Practical
bayesian optimization of machine learning algorithms.
In NIPS, 2012.
So, D. R., Liang, C., and Le, Q. V. The evolved transformer.
In ICML, 2019.
Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I.,
and Salakhutdinov, R. Dropout: A simple way to prevent
neural networks from overﬁtting. JMLR, 2014.
Stanley, K. O. and Miikkulainen, R. Evolving neural net-
works through augmenting topologies. Evol. Comput.,
2002.
Stanley, K. O., Clune, J., Lehman, J., and Miikkulainen,
R. Designing neural networks through neuroevolution.
Nature Machine Intelligence, 2019.
Suganuma, M., Shirakawa, S., and Nagao, T. A genetic
programming approach to designing convolutional neural
network architectures. In GECCO, 2017.
Sun, Y., Xue, B., Zhang, M., and Yen, G. G. Evolving deep
convolutional neural networks for image classiﬁcation.
IEEE Transactions on Evolutionary Computation, 2019.

AutoML-Zero
Tan, M., Chen, B., Pang, R., Vasudevan, V., Sandler, M.,
Howard, A., and Le, Q. V. Mnasnet: Platform-aware
neural architecture search for mobile. In CVPR, 2019.
Valkov, L., Chaudhari, D., Srivastava, A., Sutton, C. A., and
Chaudhuri, S. Houdini: Lifelong learning as program
synthesis. In NeurIPS, 2018.
Vanschoren, J. Meta-learning. Automated Machine Learn-
ing, 2019.
Wang, R., Lehman, J., Clune, J., and Stanley, K. O. Paired
open-ended trailblazer (poet): Endlessly generating in-
creasingly complex and diverse learning environments
and their solutions. GECCO, 2019.
Wichrowska, O., Maheswaranathan, N., Hoffman, M. W.,
Colmenarejo, S. G., Denil, M., de Freitas, N., and Sohl-
Dickstein, J. Learned optimizers that scale and generalize.
ICML, 2017.
Wilson, D. G., Cussat-Blanc, S., Luga, H., and Miller, J. F.
Evolving simple programs for playing atari games. In
Proceedings of the Genetic and Evolutionary Computa-
tion Conference, pp. 229–236, 2018.
Wu, Y., Schuster, M., Chen, Z., Le, Q. V., Norouzi, M., et al.
Google’s neural machine translation system: Bridging
the gap between human and machine translation. arXiv,
2016.
Xiao, H., Rasul, K., and Vollgraf, R. Fashion-mnist: a
novel image dataset for benchmarking machine learning
algorithms. arXiv preprint arXiv:1708.07747, 2017.
Xie, L. and Yuille, A. Genetic CNN. In ICCV, 2017.
Xie, S., Kirillov, A., Girshick, R., and He, K. Exploring
randomly wired neural networks for image recognition.
In Proceedings of the IEEE International Conference on
Computer Vision, pp. 1284–1293, 2019.
Yang, A., Esperança, P. M., and Carlucci, F. M. Nas evalua-
tion is frustratingly hard. ICLR, 2020.
Yao, Q., Wang, M., Chen, Y., Dai, W., Yi-Qi, H., Yu-Feng,
L., Wei-Wei, T., Qiang, Y., and Yang, Y. Taking hu-
man out of learning applications: A survey on automated
machine learning. arXiv, 2018.
Yao, X. Evolving artiﬁcial neural networks. IEEE, 1999.
Ying, C., Klein, A., Real, E., Christiansen, E., Murphy, K.,
and Hutter, F. Nas-bench-101: Towards reproducible
neural architecture search. ICML, 2019.
Zela, A., Klein, A., Falkner, S., and Hutter, F. Towards au-
tomated deep learning: Efﬁcient joint neural architecture
and hyperparameter search. ICML AutoML Workshop,
2018.
Zhong, Z., Yan, J., Wu, W., Shao, J., and Liu, C.-L. Practical
block-wise neural network architecture generation. In
CVPR, 2018.
Zoph, B. and Le, Q. V. Neural architecture search with
reinforcement learning. In ICLR, 2016.
Zoph, B., Vasudevan, V., Shlens, J., and Le, Q. V. Learning
transferable architectures for scalable image recognition.
In CVPR, 2018.

AutoML-Zero: Evolving Machine Learning Algorithms From Scratch
Supplementary Material
S1. Additional Related Work
Because our approach simultaneously searches all the as-
pects of an ML algorithm, it relates to previous work that
targets each aspect individually. As there are many such
aspects (e.g. architecture, hyperparameters, learning rule),
previous work is extensive and impossible to exhaustively
list here. Many examples belong within the ﬁeld of AutoML.
A frequently targeted aspect of the ML algorithm is the struc-
ture of the model; this is known as architecture search. It has
a long history [Fahlman & Lebiere, 1990; Angeline et al.,
1994; Yao, 1999; Stanley & Miikkulainen, 2002; Bergstra
& Bengio, 2012; Mendoza et al., 2016; Baker et al., 2017;
Zoph & Le, 2016; Real et al., 2017; Xie & Yuille, 2017;
Suganuma et al., 2017; Liu et al., 2018, and many others]
and continues today [Liu et al., 2019b; Elsken et al., 2019a;
Cai et al., 2019; Liu et al., 2019a; Ghiasi et al., 2019; Sun
et al., 2019; Xie et al., 2019, and many others]. Reviews
provide more thorough background (Elsken et al., 2019b;
Stanley et al., 2019; Yao et al., 2018). Recent works have
obtained accurate models by constraining the space to only
look for the structure of a block that is then stacked to form
a neural network. The stacking is ﬁxed and the block is
free to combine standard neural network layers into patterns
that optimize the accuracy of the model (Zoph et al., 2018;
Zhong et al., 2018). Mei et al. (2020) highlight the impor-
tance of ﬁner-grained search spaces and take a step in that
direction by splitting convolutions into channels that can
be handled separately. Other speciﬁc architecture aspects
have also been targeted, such as the hyperparameters (Snoek
et al., 2012; Loshchilov & Hutter, 2016; Jaderberg et al.,
2017; Li et al., 2018), activation functions (Ramachandran
et al., 2017), a speciﬁc layer (Kim & Rigazio, 2015), the
full forward pass (Gaier & Ha, 2019), the data augmenta-
tion (Cubuk et al., 2019a; Park et al., 2019; Cubuk et al.,
2019b), etc. Beyond these narrowly targeted search spaces,
more inclusive spaces are already demonstrating promise.
For example, a few studies have combined two seemingly
disparate algorithmic aspects into a single search space: the
inner modules and the outer structure (Miikkulainen et al.,
2019), the architecture and the hyperparameters (Zela et al.,
2018), the layers and the weight pruning (Noy et al., 2019),
and so on. We extend this to all aspects of the algorithm,
including the optimization.
An important aspect of an ML algorithm is optimization,
which has been tackled by AutoML in the form of numeri-
cally discovered optimizers. Chalmers (1991) formalizes the
update rule for the weights as wi,j ←wi,j + F(x1, x2, ...),
where xi are local signals and F combines them linearly.
The coefﬁcients of the linear combination constitute the
search space and are encoded as a bit string that is searched
with a genetic algorithm. This is an example of a numeri-
cally learned update rule: the ﬁnal result is a set of coef-
ﬁcients that work very well but may not be interpretable.
Numerically learned optimizers have improved since then.
Studies found that Chalmers’ F formula above can be re-
placed with more advanced structures, such as a second
neural network (Runarsson & Jonsson, 2000; Orchard &
Wang, 2016), an LSTM (Ravi & Larochelle, 2017), a hierar-
chical RNN (Wichrowska et al., 2017), or even a different
LSTM for each weight (Metz et al., 2019). Numerically
or otherwise, some studies center on the method by which
the optimizer is learned; it can vary widely from the use of
gradient descent (Andrychowicz et al., 2016), to reinforce-
ment learning (Li & Malik, 2017), to evolutionary search
with sophisticated developmental encodings (Risi & Stanley,
2010). All these methods are sometimes collectively labeled
as meta-learning (Vanschoren, 2019) or described as “learn-
ing the learning algorithm”, as the optimizer is indeed an
algorithm. However, in this work, we understand algorithm
more broadly and it will include also the structure and the
initialization of the model. Additionally, our algorithm is
not learned numerically, but discovered symbolically. A
symbolically discovered optimizer, like an equation or a
computer program, can be easier to interpret or transfer.
An early example of a symbolically discovered optimizer
is that of Bengio et al. (1994), who represent F as a tree:
the leaves are the possible inputs to the optimizer (i.e. the
xi above) and the nodes are one of {+, −, ×, ÷}. F is
then evolved, making this an example of genetic program-
ming (Holland, 1975; Forsyth et al., 1981; Koza & Koza,
1992). Our search method is similar to genetic programming
but we choose to represent the program as a sequence of
instructions—like a programmer would type it—rather than
a tree. Another similarity with Bengio et al. (1994) is that
they also use simple mathematical operations as building
blocks. We use many more, however, including vector and

AutoML-Zero
matrix instructions that take advantage of dense hardware
computations. More recently, Bello et al. (2017) revisited
symbolically learned optimizers to apply them to a modern
neural network. Their goal was to maximize the ﬁnal accu-
racy of their models and so they restrict the search space by
allowing hand-tuned operations (e.g. “apply dropout with
30% probability”, “clip at 0.00001”, etc.). Our search space,
on the other hand, aims to minimize restrictions and manual
design. Both Bengio et al. (1994) and Bello et al. (2017)
assume the existence of a neural network with a forward
pass that computes the activations and a backward pass that
provides the weight gradients. Thus, the search process can
just focus on discovering how to use these activations and
gradients to adjust the network’s weights. In contrast, we
do not assume the existence of a neural network model or
of the gradient. They must therefore be discovered in the
same way as the rest of the algorithm.
We note that our work also relates to program synthesis
efforts. Early approaches have proposed to search for pro-
grams that improve themselves (Lenat, 1983; Schmidhuber,
1987; Pitrat, 1996). We share similar goals in searching for
learning algorithms, but focus on common machine learn-
ing tasks and have dropped the self-reﬂexivity requirement.
More recently, program synthesis has focused on solving
problems like sorting, addition, counting (Schmidhuber,
2004; Graves et al., 2014; Reed & de Freitas, 2015; Valkov
et al., 2018), string manipulations (Polozov & Gulwani,
2015; Parisotto et al., 2016; Devlin et al., 2017), character
recognition (Lake et al., 2015), competition-style program-
ming (Balog et al., 2017), structured data QA (Neelakantan
et al., 2015; Liang et al., 2016; 2018), program parsing
(Chen et al., 2017), and game playing (Wilson et al., 2018),
to name a few. These studies are increasingly making more
use of ML to solved the said problems (Gulwani et al., 2017).
Unlike these studies, we focus on synthesizing programs
that solve the problem of doing ML.
S2. Search Space Additional Details
Supplementary Table S1 describes all the ops in our search
space. They are ordered to reﬂect how we chose them:
we imagined a typical school curriculum up to—but not
including—calculus (see braces to the right of the table). In
particular, there are no derivatives so any gradient computa-
tion used for training must be evolved.
S3. Search Method Additional Details
The mutations that produce the child from the parent must
be tailored to the search space. We use a uniformly ran-
dom choice among the following three transformations: (i)
add or remove an instruction; instructions are added at a
random position and have a random op and random argu-
ments; to prevent programs from growing unnecessarily,
instruction removal is twice as likely as addition; (ii) com-
pletely randomize all instructions in a component function
by randomizing all their ops and arguments; or (iii) modify
a randomly chosen argument of a randomly selected exist-
ing instruction. All categorical random choices are uniform.
When modifying a real-valued constant, we multiply it by a
uniform random number in [0.5, 2.0] and ﬂip its sign with
10% probability.
We upgrade the regularized evolution search method (Real
et al., 2019) to improve its performance in the following
ways. These upgrades are justiﬁed empirically through
ablation studies in Supplementary Section S9.
Functional Equivalence Checking (FEC). The lack of
heavy design of the search space allows for mutations that
do not have an effect on the accuracy (e.g. adding an in-
struction that writes to an address that is never read). When
these mutations occur, the child algorithm behaves identi-
cally to its parent. To prevent these identically functioning
algorithms from being repeatedly evaluated (i.e. trained and
validated in full many times), we keep an LRU cache map-
ping evaluated algorithm ﬁngerprints to their accuracies.
Before evaluating an algorithm, we ﬁrst quickly ﬁngerprint
it and consult the cache to see if it has already been eval-
uated. If it has, we reuse the stored accuracy instead of
computing it again. This way, we can keep the different
implementations of the same algorithm for the sake of di-
versity: even though they produce the same accuracy now,
they may behave differently upon further mutation.
To ﬁngerprint an algorithm, we train it for 10 steps and
validate it on 10 examples. The 20 resulting predictions are
then truncated and hashed to produce an integer ﬁngerprint.
The cache holds 100k ﬁngerprint–accuracy pairs.
Parallelism. In multi-process experiments, each process
runs regularized evolution on its own population and the
worker processes exchange algorithms through migration
(Alba & Tomassini, 2002). Every 100–10000 evaluations,
each worker uploads 50 algorithms (half the population)
to a central server. The server replies with 50 algorithms
sampled randomly across all workers that are substituted
into the worker’s population.
Dataset Diversity. While the ﬁnal evaluations are on binary
CIFAR-10, in the experiments in Sections 4.2 and 4.3, 50%
of the workers train and evaluate on binary MNIST instead
of CIFAR-10. MNIST is a dataset of labeled hand-written
digits (LeCun et al., 1998). We project MNIST to 256
dimensions in the same way we do for CIFAR-10. Supple-
mentary Section S9 demonstrates how searching on multiple
MNIST-based and CIFAR-based tasks improves ﬁnal perfor-
mance on CIFAR-10, relative to searching only on multiple
MNIST-based tasks or only on multiple CIFAR-based tasks.

AutoML-Zero
Hurdles. We adopt the hurdles upgrade to the evolutionary
algorithm. This upgrade uses statistics of the population
to early-stop the training of low performing models (So
et al., 2019). The early-stopping criterion is the failure
to reach a minimum accuracy—the hurdle. We alter the
original implementation by setting the hurdle to the 75th
percentile of unique accuracies of the evolving population
on a rolling basis (as opposed to the stationary value used in
the original implementation). This alteration gives us more
predictability over the resource savings: we consistently
save 75% of our compute, regardless of how the accuracy
distribution shifts over the course of the search experiment.
Terminating Degenerate Algorithms. We terminate algo-
rithms early if their calculations produce NaN or Inf values,
and assign them a ﬁxed minimum accuracy amin (we use
amin=0). Similarly, if an algorithm’s error on any training
example exceeds a threshold emax≫1 (we use emax=100),
we also stop that algorithm and assign it the accuracy amin.
Lastly, we time each algorithm as it is being executed and
terminate it if its run-time exceeds a ﬁxed threshold; we set
this threshold to 4x the run-time of a plain neural network
trained with gradient descent.
The experiment’s meta-parameters (e.g. P and T) were ei-
ther decided in smaller experiments (e.g. P), taken from
previous work (e.g. T), or not tuned. Even when tuning
parameters in smaller experiments, this was not done exten-
sively (e.g. no multi-parameter grid searches); typically, we
tried a handful of values independently when each feature
was introduced. For each experiment, we scaled—without
tuning—some meta-parameters based on compute or hard-
ware limitations. For example, compute-heavy tasks use
smaller populations in order to save frequent checkpoints in
Table S1: Ops vocabulary. s, ⃗v and M denote a scalar, vector, and matrix, resp. Early-alphabet letters (a, b, etc.) denote memory addresses.
Mid-alphabet letters (e.g. i, j, etc.) denote vector/matrix indexes (“Index” column). Greek letters denote constants (“Consts.” column).
U(α, β) denotes a sample from a uniform distribution in [α, β]. N(µ, σ) is analogous for a normal distribution with mean µ and standard
deviation σ. 1X is the indicator function for set X. Example: “M (i,j)
a
= U(α, β)” describes the operation “assign to the i,j-th entry of
the matrix at address a a value sampled from a uniform random distribution in [α, β]”.
Op
Code
Input Args
Output Args
Description
ID
Example
Addresses
Consts.
Address
Index
(see caption)
/ types
/ type
OP0
no_op
–
–
–
–
–
OP1
s2=s3+s0
a,b / scalars
–
c / scalar
–
sc = sa + sb

















Arithmetic
OP2
s4=s0-s1
a,b / scalars
–
c / scalar
–
sc = sa −sb
OP3
s8=s5*s5
a,b / scalars
–
c / scalar
–
sc = sa sb
OP4
s7=s5/s2
a,b / scalars
–
c / scalar
–
sc = sa/sb
OP5
s8=abs(s0)
a / scalar
–
b / scalar
–
sb = |sa|
OP6
s4=1/s8
a / scalar
–
b / scalar
–
sb = 1/sa
OP7
s5=sin(s4)
a / scalar
–
b / scalar
–
sb = sin(sa)

















Trigonometry
OP8
s1=cos(s4)
a / scalar
–
b / scalar
–
sb = cos(sa)
OP9
s3=tan(s3)
a / scalar
–
b / scalar
–
sb = tan(sa)
OP10
s0=arcsin(s4)
a / scalar
–
b / scalar
–
sb = arcsin(sa)
OP11
s2=arccos(s0)
a / scalar
–
b / scalar
–
sb = arccos(sa)
OP12
s4=arctan(s0)
a / scalar
–
b / scalar
–
sb = arctan(sa)
OP13
s1=exp(s2)
a / scalar
–
b / scalar
–
sb = esa















Pre-Calculus
OP14
s0=log(s3)
a / scalar
–
b / scalar
–
sb = log sa
OP15
s3=heaviside(s0)
a / scalar
–
b / scalar
–
sb = 1R+(sa)
OP16
v2=heaviside(v2)
a / vector
–
b / vector
–
⃗v (i)
b
= 1R+(⃗v (i)
a ) ∀i
OP17
m7=heaviside(m3)
a / matrix
–
b / matrix
–
M (i,j)
b
= 1R+(M (i,j)
a
) ∀i, j
OP18
v1=s7*v1
a,b / sc,vec
–
c / vector
–
⃗vc = sa ⃗vb





















Linear Algebra
OP19
v1=bcast(s3)
a / scalar
–
b / vector
–
⃗v (i)
b
= sa
∀i
OP20
v5=1/v7
a / vector
–
b / vector
–
⃗v (i)
b
= 1/⃗v (i)
a
∀i
OP21
s0=norm(v3)
a / scalar
–
b / vector
–
sb = |⃗va|
OP22
v3=abs(v3)
a / vector
–
b / vector
–
⃗v (i)
b
= |⃗v (i)
a |
∀i
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .[Table continues on the next page.] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

AutoML-Zero
Table S1: Ops vocabulary (continued)
Op
Code
Input Args
Output Args
Description
ID
Example
Addresses
Consts
Address
Index
(see caption)
/ types
/ type
OP23
v5=v0+v9
a,b / vectors
–
c / vector
–
⃗vc = ⃗va + ⃗vb

































































































Linear Algebra
OP24
v1=v0-v9
a,b / vectors
–
c / vector
–
⃗vc = ⃗va −⃗vb
OP25
v8=v1*v9
a,b / vectors
–
c / vector
–
⃗v (i)
c
= ⃗v (i)
a
⃗v (i)
b
∀i
OP26
v9=v8/v2
a,b / vectors
–
c / vector
–
⃗v (i)
c
= ⃗v (i)
a /⃗v (i)
b
∀i
OP27
s6=dot(v1,v5)
a,b / vectors
–
c / scalar
–
sc = ⃗v T
a ⃗vb
OP28
m1=outer(v6,v5)
a,b / vectors
–
c / matrix
–
Mc = ⃗va ⃗v T
b
OP29
m1=s4*m2
a,b / sc/mat
–
c / matrix
–
Mc = sa Mb
OP30
m3=1/m0
a / matrix
–
b / matrix
–
M (i,j)
b
= 1/M (i,j)
a
∀i, j
OP31
v6=dot(m1,v0)
a,b / mat/vec
–
c / vector
–
⃗vc = Ma ⃗vb
OP32
m2=bcast(v0,axis=0)
a / vector
–
b / matrix
–
M (i,j)
b
= ⃗v (i)
a
∀i, j
OP33
m2=bcast(v0,axis=1)
a / vector
–
b / matrix
–
M (j,i)
b
= ⃗v (i)
a
∀i, j
OP34
s2=norm(m1)
a / matrix
–
b / scalar
–
sb = ||Ma||
OP35
v4=norm(m7,axis=0)
a / matrix
–
b / vector
–
⃗v (i)
b
= |M (i,·)
a
| ∀i
OP36
v4=norm(m7,axis=1)
a / matrix
–
b / vector
–
⃗v (j)
b
= |M (·,j)
a
| ∀j
OP37
m9=transpose(m3)
a / matrix
–
b / matrix
–
Mb = |M T
a |
OP38
m1=abs(m8)
a / matrix
–
b / matrix
–
M (i,j)
b
= |M (i,j)
a
| ∀i, j
OP39
m2=m2+m0
a,b / matrixes
–
c / matrix
–
Mc = Ma + Mb
OP40
m2=m3+m1
a,b / matrixes
–
c / matrix
–
Mc = Ma −Mb
OP41
m3=m2*m3
a,b / matrixes
–
c / matrix
–
M (i,j)
c
= M (i,j)
a
M (i,j)
b
∀i, j
OP42
m4=m2/m4
a,b / matrixes
–
c / matrix
–
M (i,j)
c
= M (i,j)
a
/M (i,j)
b
∀i, j
OP43
m5=matmul(m5,m7)
a,b / matrixes
–
c / matrix
–
Mc = Ma Mb
OP44
s1=minimum(s2,s3)
a,b / scalars
–
c / scalar
–
sc = min(sa, sb)



















































































Probability and Statistics
OP45
v4=minimum(v3,v9)
a,b / vectors
–
c / vector
–
⃗v (i)
c
= min(⃗v (i)
a ,⃗v (i)
b
) ∀i
OP46
m2=minimum(m2,m1)
a,b / matrixes
–
c / matrix
–
M (i,j)
c
= min(M (i,j)
a
, M (i,j)
b
) ∀i, j
OP47
s8=maximum(s3,s0)
a,b / scalars
–
c / scalar
–
sc = max(sa, sb)
OP48
v7=maximum(v3,v6)
a,b / vectors
–
c / vector
–
⃗v (i)
c
= max(⃗v (i)
a ,⃗v (i)
b
) ∀i
OP49
m7=maximum(m1,m0)
a,b / matrixes
–
c / matrix
–
M (i,j)
c
= max(M (i,j)
a
, M (i,j)
b
) ∀i, j
OP50
s2=mean(v2)
a / vector
–
b / scalar
–
sb = mean(⃗va)
OP51
s2=mean(m8)
a / matrix
–
b / scalar
–
sb = mean(Ma)
OP52
v1=mean(m2,axis=0)
a / matrix
–
b / vector
–
⃗v (i)
b
= mean(M (i,·)
a
) ∀i
OP53
v3=std(m2,axis=0)
a / matrix
–
b / vector
–
⃗v (i)
b
= stdev(M (i,·)
a
) ∀i
OP54
s3=std(v3)
a / vector
–
b / scalar
–
sb = stdev(⃗va)
OP55
s4=std(m0)
a / matrix
–
b / scalar
–
sb = stdev(Ma)
OP56
s2=0.1
–
γ
a / scalar
–
sa = γ
OP57
v3[5]=-2.4
–
γ
a / vector
i
⃗v (i)
a
= γ
OP58
m2[5,1]=-0.03
–
γ
a / matrix
i, j
M (i,j)
a
= γ
OP59
s4=uniform(-1,1)
–
α, β
a / scalar
–
sa = U(α, β)
OP60
v1=uniform(0.4,0.8)
–
α, β
a / vector
–
⃗v (i)
a
= U(α, β) ∀i
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .[Table continues on the next page.] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

AutoML-Zero
Table S1: Ops vocabulary (continued)
Op
Code
Input Args
Output Args
Description
ID
Example
Addresses
Consts
Address
Index
(see caption)
/ types
/ type
OP61
m0=uniform(-0.5,0.6)
–
α, β
a / matrix
–
M (i,j)
a
= U(α, β) ∀i, j











Prob. and Stats.
OP62
s4=gaussian(0.1,0.7)
–
µ, σ
a / scalar
–
sa = N(µ, σ)
OP63
v8=gaussian(0.4,1)
–
µ, σ
a / vector
–
⃗v (i)
a
= N(µ, σ) ∀i
OP64
m2=gaussian(-2,1.3)
–
µ, σ
a / matrix
–
M (i,j)
a
= N(µ, σ) ∀i, j
case of machine reboots. Additional discrepancies between
experiment conﬁgurations in the different sections are due
to different researchers working independently.
S4. Task Generation Details
Sections 4.2 and 4.3 employ many binary classiﬁcation tasks
grouped into two sets, Tsearch and Tselect. We now describe
how these tasks are generated. We construct a binary clas-
siﬁcation task by randomly selecting a pair of classes from
CIFAR-10 to yield positive and negative examples. We
then create a random projection matrix by drawing from a
Gaussian distribution with zero mean and unit variance. We
use the matrix to project the features of all the examples
corresponding to the class pair to a lower dimension (i.e.
from the original 3072 to, for example, 16). The projected
features are then standardized. This generates a proxy task
that requires much less compute than the non-projected ver-
sion. Each class pair and random projection matrix produce
a different task. Since CIFAR-10 has 10 classes, there are
45 different pairs. For each pair we perform 100 different
projections. This way we end up with 4500 tasks, each
containing 8000/2000 training/validation examples. We use
all the tasks from 36 of the pairs to form the Tsearch task
set. The remaining tasks form Tselect.
S5. Detailed Search Experiment Setups
Here we present details and method meta-parameters for
experiments referenced in Section 4. These complement the
“Experiment Details” paragraphs in the main text.
Experiments in Section 4.1, Figure 4: Scalar/vector/ma-
trix number of addresses: 4/3/1 (linear), 5/3/1 (afﬁne). Fixed
num. instructions for Setup/Predict/Learn: 5/1/4 (lin-
ear), 6/2/6 (afﬁne). Expts. in this ﬁgure allow only minimal
ops to discover a known algorithm, as follows. For “linear
backprop” expts.: allowed Learn ops are {OP3, OP4, OP19,
OP24}. For “linear regressor” expts.: allowed Setup ops
are {OP56, OP57}, allowed predict ops are {OP27}, and al-
lowed Learn ops are {OP2, OP3, OP18, OP23}. For “afﬁne
backprop” expts.: allowed Learn ops are {OP1, OP2, OP3,
OP18, OP23}. For “afﬁne regressor” expts.: allowed Setup
ops are {OP56, OP57}, allowed Predict ops are {OP1,
OP27}, and allowed Learn ops are {OP1, OP2, OP3, OP18,
OP23}. 1 process, no server. Tasks: see Experiment Details
paragraph in main text. Evolution expts.: P=1000; T=10;
U=0.9; we initialize the population with random programs;
evals. per expt. for points in plot (left to right): 10k, 10k,
10k, 100k (optimized for each problem difﬁculty to nearest
factor of 10). Random search expts.: same num. memory
addresses, same component function sizes, same total num-
ber of evaluations. These experiments are intended to be as
simple as possible, so we do not use hurdles or additional
data.
Experiment in Section 4.1, Figure 5: Scalar/vector/ma-
trix number of addresses: 4/8/2. Fixed num. instructions
for Setup/Predict/Learn: 21/3/9. In this ﬁgure, we only
allow as ops those that appear in a two-layer neural net-
work with gradient descent: allowed Setup ops are {OP56,
OP63, OP64}, allowed Predict ops are {OP27, OP31,
OP48}, and allowed Learn ops are {OP2, OP3, OP16,
OP18, OP23, OP25, OP28, OP40}. Tasks: see Experiment
Details paragraph in main text. P=1000. T=10. U=0.9.
W =1k. Worker processes are uniformly divided into 4
groups, using parameters T/D/P covering ranges in a log
scale, as follows: 100k/100/100, 100k/22/215, 10k/5/464,
and 100/1/1000. Uses FEC. We initialize the population
with random programs.
Experiments in Section 4.2: Scalar/vector/matrix num-
ber of addresses: 8/14/3.
Maximum num. instructions
for Setup/Predict/Learn: 21/21/45. All the initializa-
tion ops are now allowed for Setup: {OP56, OP57, OP58,
OP59, OP60, OP61, OP62, OP63, OP64}. Predict and
Learn use a longer list of 58 allowed ops: {OP0, OP1,
OP2, OP3, OP4, OP5, OP6, OP7, OP8, OP9, OP10, OP11,
OP12, OP13, OP14, OP15, OP16, OP17, OP18, OP19,
OP20, OP21, OP22, OP23, OP24, OP25, OP26, OP27,
OP28, OP29, OP30, OP31, OP32, OP33, OP34, OP35,
OP36, OP37, OP38, OP39, OP40, OP41, OP42, OP43,
OP44, OP45, OP46, OP47, OP48, OP49, OP50, OP51,
OP52, OP53, OP54, OP55, OP60, OP61}—all these ops

AutoML-Zero
are available to both Predict and Learn. We use all the
optimizations described in Section 5, incl. additional pro-
jected binary MNIST data. Worker processes are uniformly
divided to perform each possible combination of tasks:
{projected binary CIFAR-10, projected binary MNIST} ⊗
{N =800 & E=1, N =8000 & E=1, N =800 & E=10}
⊗{D=1, D=10} ⊗{F=8, F=16, F=256}; where N is
the number of training examples, E is the number of train-
ing epochs, and other quantities are deﬁned in Section 3.
P =100. T =10. U =0.9. W =10k processes (commod-
ity CPU cores). We initialize the population with empty
programs.
Experiments in Section 4.3: Scalar/vector/matrix number
of addresses: 10/16/4. Maximum num. instructions for
Setup/Predict/Learn: 21/21/45. Allowed ops for Setup
are {OP56, OP57, OP58, OP59, OP60, OP61, OP62, OP63,
OP64}, allowed ops for Predict and Learn are {OP0,
OP1, OP2, OP3, OP4, OP5, OP6, OP7, OP8, OP9, OP10,
OP11, OP12, OP13, OP14, OP15, OP16, OP17, OP18,
OP19, OP20, OP21, OP22, OP23, OP24, OP25, OP26,
OP27, OP28, OP29, OP30, OP31, OP32, OP33, OP34,
OP35, OP36, OP37, OP38, OP39, OP40, OP41, OP42,
OP43, OP44, OP45, OP46, OP47, OP48, OP49, OP50,
OP51, OP52, OP53, OP54, OP55, OP63, OP64}. These are
the same ops as in the paragraph above, except for the minor
accidental replacement of uniform for Gaussian initializa-
tion ops. We use FEC and hurdles. Workers use binary
CIFAR-10 dataset projected to dimension 16. Half of the
workers use D = 10 (for faster evolution), and the other
half use D=100 (for more accurate evaluation). P =100.
T=10. U=0.9. Section 4.3 considers three different task
types: (1) In the “few training examples” task type (Fig-
ure 7a), experiments train each algorithm on 80 examples
for 100 epochs for the experiments, while controls train on
800 examples for 100 epochs. (2) In the “fast training” task
type (Figure 7b), experiments train on 800 examples for
10 epochs, while controls train on 800 examples for 100
epochs. (3) In the “multiple classes” task type (Figure 7c),
experiments evaluate on projected 10-class CIFAR-10 clas-
siﬁcation tasks, while controls evaluate on the projected
binary CIFAR-10 classiﬁcation tasks described before. The
10-class tasks are generated similarly to the binary tasks,
as follows. Each task contains 45K/5K training/validation
examples. Each example is a CIFAR-10 image projected to
16 dimensions using a random matrix drawn from a Gaus-
sian distribution with zero mean and unit variance. This
projection matrix remains ﬁxed for all examples within a
task. The data are standardized after the projection. We use
1000 different random projection matrices to create 1000
different tasks. 80% of these tasks constitute Tsearch and
the rest form Tselect. Since Section 4.2 showed that we can
discover reasonable models from scratch, in Section 4.3, we
initialize the population with the simple two-layer neural
network with gradient descent of Figure 5 in order to save
compute.
S6. Evolved Algorithms
In this section, we show the raw code for algorithms discov-
ered by evolutionary search in Sections 4.2 and 4.3. The
code in those sections was simpliﬁed and therefore has su-
perﬁcial differences with the corresponding code here.
Supplementary Figure S1a shows the raw code for the best
evolved algorithm in Section 4.2. For comparison, Fig-
ure S1b shows the effect of removing redundant instruc-
tions through automated static analysis (details in Supple-
mentary Section S8). For example, the instruction v3 =
gaussian(0.7,0.4) has been deleted this way.
def Setup():
s4 = uniform(0.6,0.2)
v3 = gaussian(0.7,0.4)
v12= gaussian(0.2,0.6)
s1 =
uniform(-0.1,-0.2)
def Predict():
v1 = v0 - v9
v5 = v0 + v9
v6 = dot(m1, v5)
m1 = s2 * m2
s1 = dot(v6, v1)
s6 = cos(s4)
def Learn():
s4 = s0 - s1
s3 = abs(s1)
m1 = outer(v1,v0)
s5 = sin(s4)
s2 = norm(m1)
s7 = s5 / s2
s4 = s4 + s6
v11= s7 * v1
m1 = heaviside(m2)
m1 = outer(v11,v5)
m0 = m1 + m0
v9 = uniform(2e-3,0.7)
s7 = log(s0)
s4 = std(m0)
m2 = m2 + m0
m1 = s4 * m0
(a)
def Setup():
def Predict():
v1 = v0 - v9
v5 = v0 + v9
v6 = dot(m1,v5)
m1 = s2 * m2
s1 = dot(v6,v1)
def Learn():
s4 = s0 - s1
m1 = outer(v1,v0)
s5 = sin(s4)
s2 = norm(m1)
s7 = s5 / s2
v11= s7 * v1
m1 = outer(v11,v5)
m0 = m1 + m0
v9 =
uniform(2e-3,0.7)
s4 = std(m0)
m2 = m2 + m0
m1 = s4 * m0
(b)
Figure S1: (a) Raw code for the best evolved algorithm in Fig-
ure 6 (bottom–right corner) in Section 4.2. (b) Same code after
redundant instructions have been removed through static analysis.
Finally, the fully simpliﬁed version is in the bottom right
corner of Figure 6 in the main text. To achieve this simpli-
ﬁcation, we used ablation studies to ﬁnd instructions that
can be removed or reordered. More details can be found
in Supplementary Section S8. For example, in going from
Supplementary Figure S1b to Figure 6, we removed s5 =
sin(s4) because its deletion does not signiﬁcantly alter the
accuracy. We also consistently renamed some variables (of

AutoML-Zero
def Setup():
s3 = 4.0e-3
def Predict():
v7 = v5 - v0
v3 = dot(m0, v0)
s8 = s9 / s3
v3 = v3 + v1
m1 = heaviside(m3)
v4 = maximum(v3, v7)
s1 = dot(v4, v2)
s4 = log(s9)
v3 = bcast(s8)
s7 = std(v1)
v3 = v14 + v0
m2 = matmul(m0, m2)
def Learn():
v1 = gaussian(-0.50, 0.41)
s4 = std(m0)
s4 = s0 - s1
v5 = gaussian(-0.48, 0.48)
m1 = transpose(m3)
s4 = s3 * s4
v15 = v15 * v6
v6 = s4 * v4
v2 = v2 + v6
v7 = s4 * v2
v8 = heaviside(v3)
v7 = v8 * v7
m1 = outer(v7, v0)
m0 = m0 + m1
(a) Raw code for the adaptation to
few examples in Figure 7a.
def Setup():
s3 = 0.37
s1 = uniform(0.42, 0.66)
s2 = 0.31
v13 = gaussian(0.69, 0.61)
v1 = gaussian(-0.86, 0.97)
def Predict():
m3 = m1 + m2
s6 = arccos(s0)
v3 = dot(m0, v0)
v3 = v3 - v0
v11 = v2 + v9
m2 = m0 - m2
s4 = maximum(s8, s0)
s7 = 1 / s6
s6 = arctan(s0)
s8 = minimum(s3, s1)
v4 = maximum(v3, v10)
s1 = dot(v4, v2)
s1 = s1 + s2
def Learn():
v1 = dot(m0, v5)
s4 = s0 - s1
s4 = s3 * s4
s2 = s2 + s4
m3 = matmul(m0, m3)
m2 = bcast(v2, axis=0)
v13 = s4 * v4
v15 = v10 + v12
v2 = v11 + v13
v7 = s4 + v11
v11 = v7 + v8
s8 = s9 + s1
m2 = m3 * m0
s3 = arctan(s3)
v8 = heaviside(v3)
m2 = transpose(m1)
s8 = heaviside(s6)
s8 = norm(m3)
v7 = v8 * v7
m3 = outer(v7, v0)
m0 = m0 + m3
(b) Raw code for the adaptation to
fast training in Figure 7b.
def Setup():
m3 = uniform(0.05, 0.11)
s1 = uniform(0.31, 0.90)
v18 = uniform(-0.49, 4.41)
s1 = -0.65
m5 = uniform(0.21, 0.22)
v9 = gaussian(0.64, 7.8e-3)
s1 = -0.84
def Predict():
s1 = abs(s1)
v15 = norm(m1, axis=1)
v15 = dot(m0, v0)
v8 = v19 - v0
v15 = v8 + v15
v7 = max(v1, v15)
v13 = min(v5, v4)
m2 = transpose(m2)
v10 = v13 * v0
m7 = heaviside(m3)
m4 = transpose(m7)
v2 = dot(m1, v7)
v6 = max(v2, v9)
v2 = v2 + v13
v11 = heaviside(v17)
s1 = sin(s1)
m3 = m6 - m5
v19 = heaviside(v14)
v10 = min(v12, v7)
def Learn():
m5 = abs(m7)
v8 = v1 - v2
m2 = transpose(m2)
v8 = s1 * v8
v15 = v15 - v4
v4 = v4 + v8
s1 = arcsin(s1)
v15 = mean(m3, axis=1)
v12 = v11 * v11
m4 = heaviside(m5)
m6 = outer(v8, v7)
s1 = sin(s1)
s1 = exp(s0)
m1 = m1 + m3
m5 = outer(v15, v6)
m2 = transpose(m1)
s1 = exp(s0)
v12 = uniform(0.30, 0.33)
s1 = minimum(s0, s1)
m5 = m5 * m7
v9 = dot(m2, v8)
v9 = v10 * v9
v3 = norm(m7, axis=1)
s1 = mean(m1)
m2 = outer(v9, v0)
m0 = m0 + m2
(c) Raw code for the adaptation to
multiple classes in Figure 7c.
Figure S2: Raw evolved code for algorithm snippets in Figure 7 in Section 4.3.
course, this has no effect on the execution of the code).
Supplementary Figure S2 shows the raw code for the algo-
rithms in Figure 7 in Section 4.3. Note that in Figure 7, we
display a code snippet containing only a few selected instruc-
tions, while Supplementary Figure S2 shows the programs
in full.

AutoML-Zero
S7. Algorithm Selection and Evaluation
We ﬁrst run search experiments evaluating algorithms on the
projected binary classiﬁcation tasks sampled from Tsearch
and collect the best performing candidate from each experi-
ment. The measure of performance is the median accuracy
across tasks. Then, we rank these candidates by evaluat-
ing them on tasks sampled from Tselect and we select the
highest-ranking candidate (this is analogous to typical model
selection practice using a validation set). The highest rank-
ing algorithm is ﬁnally evaluated on the binary classiﬁcation
tasks using CIFAR-10 data with the original dimensionality
(3072).
Because the algorithms are initially evolved on tasks with
low dimensionality (16) and ﬁnally evaluated on the full-size
dimensionality (3072), their hyperparameters must be tuned
on the full-size dimensionality before that ﬁnal evaluation.
To do this, we treat all the constants in the algorithms as
hyperparameters and jointly tune them using random search.
For each random search trial, each constant is scaled up
or down by a random factor sampled between 0.001 and
1000 on a log-scale. We allowed up to 10k trials to tune the
hyperparameters, but only a few hundred were required to
tune the best algorithm in Figure 6—note that this algorithm
only has 3 constants. To make comparisons with baselines
fair, we tune these baselines using the same amount of re-
sources that went into tunining and evolving our algorithms.
All hyperparameter-tuning trials use 8000 training and 2000
validation examples from the CIFAR-10 training set. After
tuning, we ﬁnally run the tuned algorithms on 2000 exam-
ples from the held-out CIFAR-10 test set. We repeat this
ﬁnal evaluation with 5 different random seeds and report the
mean and standard deviation. We stress that the CIFAR-10
test set was used only in this ﬁnal evaluation, and never in
Tsearch or Tselect.
In our experiments, we found a hyperparameter coupling
phenomenon that hinders algorithm selection and tuning.
ML algorithms usually make use of hyperparameters (e.g.
learning rate) that need to be tuned for different datasets
(for example, when the datasets have very different input
dimensions or numbers of examples). Similarly, the evolved
algorithms also contain hyperparameters that need to be
adjusted for different datasets. If the hyperparameters are
represented as constants in the evolved algorithm, we can
identify and tune them on the new dataset by using random
search. However, it is harder to tune them if a hyperparame-
ter is instead computed from other variables. For example,
in some evolved algorithms, the learning rate s2 was com-
puted as s2 = norm(v1) because the best value for s2
coincides with the L2-norm of v1 on Tsearch. However,
when we move to a new dataset with higher dimensions,
the L2-norm of v1 might no longer be a good learning rate.
This can cause the evolved algorithms’ performance to drop
dramatically on the new dataset. To resolve this, we identify
these parameters by manual inspection of the evolved code.
We then manually decouple them: in the example, we would
set s2 to a constant that we can tune with random-search.
This recovers the performance. Automating the decoupling
process would be a useful direction for future work.
S8. Interpreting Algorithms
It is nontrivial to interpret the raw evolved code and decide
which sections of it are important. We use the following
procedures to help with the interpretation of discovered
algorithms:
(a) We clean up the raw code (e.g. Figure S1a) by automati-
cally simplifying programs. To do this, we remove redun-
dant instructions through static analysis, resulting in code
like that in Figure S1b. Namely, we analyze the computa-
tions that lead to the ﬁnal prediction and remove instructions
that have no effect. For example, we remove instructions
that initialize variables that are never used.
(b) We focus our attention on code sections that reappear
in many independent search experiments. This is a sign
that such code sections may be beneﬁcial. For example,
Section 4.3 applied this procedure to identify adaptations to
different tasks.
(c) Once we have hypotheses about interesting code sections,
we perform ablations/knock-outs, where we remove the code
section from the algorithm to see if there is a signiﬁcant loss
in accuracy. As an example, for Section 4.2, we identiﬁed
6 interesting code sections in the best evolved algorithm
to perform ablations. For each ablation, we removed the
relevant code section, then tuned all the hyperparameters /
constants again, and then computed the loss in validation
accuracy. 4 out of the 6 ablations caused a large drop in ac-
curacy. These are the ones that we discussed in Section 4.2.
Namely, (1) the addition of noise to the input (−0.16%); (2)
the bilinear model (−1.46%); (3) the normalized gradients
(−1.20%); and (4) the weight averaging (−4.11%). The
remaining 2 code sections show no signiﬁcant loss upon
ablation, and so were removed for code readability. Also for
readability, we reorder some instructions when this makes
no difference to the accuracy either (e.g. we move related
code lines closer to each other). After this procedure, the
code looks like that in Figure 6.
(d) If an ablation suggests that a code section is indeed
helpful to the original algorithm, we then perform a knock-in.
That is, we insert the code section into simpler algorithms
to see if it improves their performance too. This way we
conﬁrmed the usefulness of the 4 code sections mentioned
in (c), for example.

AutoML-Zero
Table S2: Ablation studies. Each row summarizes the results of 30 search runs under one given experimental setting. Rows #0–4 all use
the same setting, except for the search method: each row implements an upgrade to the method and shows the resulting improvement.
“Best Accuracy” is the accuracy of the best algorithm for each experiment (±2 SEM), evaluated on unseen projected binary CIFAR-10
tasks. “Success Fraction” is the fraction (±2σ) of those experiments that produce algorithms that are more accurate than a plain neural
network trained with gradient descent (0.750). This fraction helps us estimate the likelihood of high performing outliers, which we
are keenly interested in. The experimental setting for row #5 is the same as row #3, except that instead of using both projected binary
CIFAR-10 and projected binary MNIST data for the search, we use only projected binary MNIST data (as for other rows, the accuracy is
reported on projected binary CIFAR-10 data). Row #5 indicates that searching completely on MNIST data is not as helpful as searching
partially on it (row #3). Overall, rows #0–4 suggest that all four upgrades are beneﬁcial.
INDEX
DESCRIPTION
BEST ACCURACY
SUCCESS FRACTION
0
BASELINE
0.703 ± 0.002
0.00 ± 0.00
1
+ MIGRATION
0.707 ± 0.004
0.00 ± 0.00
2
+ FUNCTIONAL EQUIVALENCE CHECK
0.724 ± 0.006
0.13 ± 0.12
3
+ 50% MNIST DATA
0.729 ± 0.008
0.27 ± 0.16
4
+ HURDLES
0.738 ± 0.008
0.53 ± 0.18
5
EXPERIMENT 3 W/ 100% MNIST DATA
0.720 ± 0.003
0.00 ± 0.00
S9. More Search Method Ablations
To verify the effectiveness of the upgrades mentioned in
Supplementary Section S3, we conduct ablation studies
using the experiment setup of Section 4.2, except for the
following simpliﬁcations to reduce compute: (i) we limit
the ops to only those that are necessary to construct a neu-
ral network trained with gradient descent (as was done
for Figure 5), i.e. allowed Setup ops are {OP57, OP64,
OP65}, allowed Predict ops are {OP28, OP32, OP49},
and allowed Learn ops are {OP3, OP4, OP17, OP19, OP24,
OP26, OP29, OP41}; (ii) we reduce the projected dimen-
sionality from 256 to 16, and (iii) we use 1k processes for
5 days. Additionally, the ablation experiments we present
use T = 8000, E = 10 for all tasks. This slight difference
is not intentionally introduced, but rather is a product of our
having studied our method before running our experiments
in the main text; we later on found that using more epochs
did not change the conclusions of the studies or improve the
results.
Supplementary Tables S2, S3, and S4 display the results.
Note that Figure 8 presents a subset of this data in plot
form (the indexes 1–4 along the horizontal axis labels in
that ﬁgure coincide with the “Index” column in this table).
We ﬁnd that all four upgrades are beneﬁcial across the three
different compute scales tested.
S10. Baselines
The focus of this study was not the search method but we
believe there is much room for future work in this regard.
To facilitate comparisons with other search algorithms on
the same search space, in this section we provide convenient
baselines at three different compute scales.
All baselines use the same setting, a simpliﬁed version of
that in Section 4.2, designed to use less compute. In par-
ticular, here we severely restrict the search space to be
able to reach results quickly. Scalar/vector/matrix num-
ber of addresses: 5/9/2. Maximum num. instructions for
Setup/Predict/Learn: 7/11/23.
Allowed Setup ops:
{OP57, OP60, OP61, OP62, OP63, OP64, OP65}, allowed
Predict ops: {OP2, OP24, OP28, OP32, OP49}, allowed
Learn ops: {OP2, OP3, OP4, OP17, OP19, OP24, OP26,
OP29, OP41}. Experiments end after each process has
run 100B training steps—i.e. the training loop described
in Section 3.1 runs 100B times. (We chose “training steps”
instead of “number of algorithms” as the experiment-ending
criterion because the latter varies due to early stopping,
FEC, etc. We also did not choose “time” as the experiment-
ending criterion to make comparisons hardware-agnostic.
For reference, each experiment took roughly 12 hours on
our hardware.) P=100; T=10, U=0.9. All workers eval-
uate on the same projected binary CIFAR-10 tasks as in
Section 4.2, except that we project to 16 dimensions instead
of 256. Each search evaluation is on 10 tasks and the num-
bers we present here are evaluations on Tselect using 100
tasks. We initialize the population with empty programs.
The results of performing 100 repeats of these experiments
at three different compute scales are summarized in Ta-
ble S5; note, each process is run on a single commodity
CPU core. We additionally compare our full search method
from Section 4.2, labeled “Full”, and a more “Basic” search

AutoML-Zero
Table S3: This is the same as Supplementary Table S2, except at a lower compute scale (100 processes). Each setup was run 100 times.
The results are similar to those with more compute and support the same conclusions. Thus, the observed beneﬁts are not speciﬁc to a
single compute scale.
INDEX
DESCRIPTION
BEST ACCURACY
SUCCESS FRACTION
0
BASELINE
0.700 ± 0.002
0.00 ± 0.00
1
+ MIGRATION
0.704 ± 0.000
0.00 ± 0.00
2
+ FUNCTIONAL EQUIVALENCE CHECK
0.706 ± 0.001
0.00 ± 0.00
3
+ 50% MNIST DATA
0.710 ± 0.002
0.02 ± 0.03
4
+ HURDLES
0.714 ± 0.003
0.10 ± 0.06
5
EXPERIMENT 3 W/ 100% MNIST DATA
0.700 ± 0.004
0.00 ± 0.00
Table S4: This is the same as Supplementary Tables S2 and S3, except at an even lower compute scale (10 processes). Each setup was run
100 times. The results are consistent with those with more compute, but we no longer observe successes (“successes” deﬁned in Table S2).
INDEX
DESCRIPTION
BEST ACCURACY
SUCCESS FRACTION
0
BASELINE
0.700 ± 0.001
0.00 ± 0.00
1
+ MIGRATION
0.701 ± 0.001
0.00 ± 0.00
2
+ FUNCTIONAL EQUIVALENCE CHECK
0.702 ± 0.001
0.00 ± 0.00
3
+ 50% MNIST DATA
0.704 ± 0.001
0.00 ± 0.00
4
+ HURDLES
0.705 ± 0.001
0.00 ± 0.00
5
EXPERIMENT 3 W/ 100% MNIST DATA
0.694 ± 0.002
0.00 ± 0.00
Table S5: Baselines on the simpliﬁed setting with the restricted search space (see Supplementary Section S10 for details). “Best Accuracy”
is the best evaluated accuracy on unseen projected binary classiﬁcation tasks for each run (±2 SEM), “Linear Success Fraction” is the
fraction (±2σ) of those accuracies that are above the evaluated accuracy of logistic regression trained with gradient descent (0.702), and
“NN Success Fraction” is the fraction (±2σ) of those accuracies that are above the evaluated accuracy of a plain neural network trained
with gradient descent (0.729). Using success fractions as a metric helps us estimate the likelihood of discovering high performing outliers,
which we are keenly interested in. Each experiment setup was run 100 times. The “Full” method is the one we used in Section 4.2; the
“Basic” method is the same, but with no FEC, no hurdles, and no MNIST data.
METHOD
NUMBER OF PROCESSES
BEST ACCURACY
LINEAR SUCCESS FRACTION
NN SUCCESS FRACTION
BASIC
1
0.671 ± 0.004
0.01 ± 0.02
0.00 ± 0.00
BASIC
10
0.681 ± 0.005
0.07 ± 0.05
0.00 ± 0.00
BASIC
100
0.691 ± 0.004
0.26 ± 0.09
0.00 ± 0.00
FULL
1
0.684 ± 0.003
0.03 ± 0.03
0.00 ± 0.00
FULL
10
0.693 ± 0.003
0.23 ± 0.08
0.03 ± 0.03
FULL
100
0.707 ± 0.003
0.59 ± 0.10
0.11 ± 0.06
setup, which does not use FEC, hurdles, or MNIST data.

