Theory Comput Syst (2019) 63:488–505
https://doi.org/10.1007/s00224-018-9873-2
Process Algebra with Strategic Interleaving
J. A. Bergstra1 ·C. A. Middelburg1
Published online: 8 August 2018
© The Author(s) 2018
Abstract In process algebras such as ACP (Algebra of Communicating Processes),
parallel processes are considered to be interleaved in an arbitrary way. In the
case of multi-threading as found in contemporary programming languages, parallel
processes are actually interleaved according to some interleaving strategy. An inter-
leaving strategy is what is called a process-scheduling policy in the field of operating
systems. In many systems, for instance hardware/software systems, we have to do
with both parallel processes that may best be considered to be interleaved in an
arbitrary way and parallel processes that may best be considered to be interleaved
according to some interleaving strategy. Therefore, we extend ACP in this paper with
the latter form of interleaving. The established properties of the extension concerned
include an elimination property, a conservative extension property, and a unique
expansion property.
Keywords Process algebra · Arbitrary interleaving · Strategic interleaving ·
Abstract scheduler · Interleaving history
 C. A. Middelburg
C.A.Middelburg@uva.nl
J. A. Bergstra
J.A.Bergstra@uva.nl
1
Informatics Institute, Faculty of Science, University of Amsterdam, Science Park 904,
1098 XH Amsterdam, The Netherlands

Theory Comput Syst (2019) 63:488–505
489
1 Introduction
In algebraic theories of processes, such as ACP [5, 7], CCS [18, 21] and CSP [12, 19],
processes are discrete behaviours that proceed by doing steps in a sequential fashion.
The parallel composition of two processes is usually considered to incorporate all
conceivable interleavings of their steps. In each interleaving, the steps of both pro-
cesses occur in some order where each time one step is taken from either of the pro-
cesses. According to many, this interpretation of parallel composition, called arbitrary
interleaving, is a plausible, general, if not idealized interpretation. Underlying the
usual justification of this claim is the assumption that at most one step is done at each
point in time. However, others contend that interpretations in which this simplifying
assumption is fulfilled are not faithful. Be that as it may, arbitrary interleaving turns out
to be appropriate for many applications and to facilitate formal algebraic reasoning.
Multi-threading as found in programming languages such as Java [16] and C#
[17], gives rise to parallel composition of processes. In the case of multi-threading,
however, the steps of the processes concerned are interleaved according to a process-
scheduling policy. We use the term strategic interleaving for this more constrained
form of interleaving; and we further use the term interleaving strategy instead of
process-scheduling policy. Arbitrary interleaving and strategic interleaving are quite
different. The following points illustrate this: (a) whether the interleaving of certain
processes leads to inactiveness depends on the interleaving strategy used; (b) some-
times inactiveness occurs with a particular interleaving strategy whereas arbitrary
interleaving would not lead to inactiveness and vice versa.
In previous work, we studied strategic interleaving in the setting of thread algebra,
which is built on a specialized algebraic theory of processes devoted to the behaviours
produced by instruction sequences under execution (see e.g. [8–10]). We have, for
instance, given demonstrations of points (a) and (b) above in this setting. Nowadays,
multi-threading is often used in the implementation of systems. Because of this, in
many systems, for instance hardware/software systems, we have to do with parallel
processes that may best be considered to be interleaved in an arbitrary way as well
as parallel processes that may best be considered to be interleaved according to some
interleaving strategy. This is what motivated us to do the work presented in this paper,
namely extending ACP such that it supports both arbitrary interleaving and strategic
interleaving.
To our knowledge, there exists no work on strategic interleaving in the setting of a
general algebraic theory of processes like ACP, CCS and CSP. In the work presented
in this paper, we consider strategic interleaving where process creation is taken into
account. The approach to process creation followed in this paper originates from the
one first followed in [6] to extend ACP with process creation and later followed in
[2, 3, 11] to extend different timed versions of ACP with process creation. The only
other approach that we know of is the approach, based on [1], that has for instance
been followed in [4, 14]. However, with that approach, it is most unlikely that data
about the creation of processes can be made available for the decision making con-
cerning the strategic interleaving of processes.
The extension of ACP presented in this paper covers a generic interleaving strat-
egy that can be instantiated with different specific interleaving strategies. We found

490
Theory Comput Syst (2019) 63:488–505
two plausible ways to deal with inactiveness of a process whose steps are being inter-
leaved with steps of other processes in the case of strategic interleaving. This gives
rise to two plausible extensions of ACP. We will treat only one of them in detail.
The rest of this paper is organized as follows. In Section 2, we review ACP
(Section 2.1), guarded recursion in the setting of ACP (Section 2.2), and some rele-
vant results about the latter (Section 2.3). In Section 3, we extend ACP with strategic
interleaving (Section 3.1) and establish some important properties of the extension
(Section 3.2). In Section 4, we make some concluding remarks.
2 ACP with Guarded Recursion
In this section, we give a survey of ACP (Algebra of Communicating Processes),
guarded recursion in the setting of ACP, and some relevant results about the extension
of ACP with guarded recursion. For a comprehensive overview, the reader is referred
to [5, 13].
2.1 ACP
In ACP, it is assumed that a fixed but arbitrary set A of actions, with δ /∈A, has been
given. We write Aδ for A∪{δ}. It is further assumed that a fixed but arbitrary commu-
tative and associative communication function γ : Aδ × Aδ →Aδ, with γ (δ, a) = δ
for all a ∈Aδ, has been given. The function γ is regarded to give the result of
synchronously performing any two actions for which this is possible, and to give δ
otherwise.
The signature of ACP consists of the following constants and operators:
–
for each a ∈A, the action constant a ;
–
the inaction constant δ ;
–
the binary alternative composition operator + ;
–
the binary sequential composition operator
·
;
–
the binary parallel composition operator ∥;
–
the binary left merge operator
⌊⌊
;
–
the binary communication merge operator | ;
–
for each H ⊆A, the unary encapsulation operator ∂H.
We assume that there are infinitely many variables, including x, y, z. Terms are built
as usual. We use infix notation for the binary operators. The precedence conventions
used with respect to the operators of ACP are as follows: + binds weaker than all
others, · binds stronger than all others, and the remaining operators bind equally
strong.
The constants and operators of ACP can be explained as follows:
–
the constant a denotes the process that is only capable of first performing action
a and next terminating successfully;
–
the constant δ denotes the process that is not capable of doing anything;

Theory Comput Syst (2019) 63:488–505
491
–
a closed term of the form t+t′ denotes the process that behaves either as the
process denoted by t or as the process denoted by t′, but not both;
–
a closed term of the form t ·t′ denotes the process that first behaves as the process
denoted by t and on successful termination of that process it next behaves as the
process denoted by t′;
–
a closed term of the form t∥t′ denotes the process that behaves as the process
that proceeds with the processes denoted by t and t′ in parallel;
–
a closed term of the form t ⌊⌊t′ denotes the process that behaves the same as
the process denoted by t∥t′, except that it starts with performing an action of the
process denoted by t;
–
a closed term of the form t|t′ denotes the process that behaves the same as the
process denoted by t∥t′, except that it starts with performing an action of the
process denoted by t and an action of the process denoted by t′ synchronously;
–
a closed term of the form ∂H(t) denotes the process that behaves the same as the
process denoted by t, except that actions from H are blocked.
The operators ⌊⌊and | are of an auxiliary nature. They are needed to axiomatize ACP.
The axioms of ACP are the equations given in Table 1. In these equations, a, b
and c stand for arbitrary constants of ACP, and H stands for an arbitrary subset of
A. Moreover, γ (a, b) stands for the action constant for the action γ (a, b). In D1 and
D2, side conditions restrict what a and H stand for.
In other presentations of ACP, γ (a, b) is regularly replaced by a|b in CM5–CM7.
By CM12, which is more often called CF, these replacements give rise to an equiv-
alent axiomatization. In other presentations of ACP, CM10 and CM11 are usually
absent. These equations are not derivable from the other axioms, but all there closed
substitution instances are derivable from the other axioms. Moreover, CM10 and
CM11 hold in virtually all models of ACP that have been devised.
Table 1 Axioms of ACP
x + y = y + x
A1
x ∥y = x ⌊⌊y + y ⌊⌊x + x | y
CM1
(x + y) + z = x + (y + z)
A2
a ⌊⌊x = a · x
CM2
x + x = x
A3
a · x ⌊⌊y = a · (x ∥y)
CM3
(x + y) · z = x · z + y · z
A4
(x + y) ⌊⌊z = x ⌊⌊z + y ⌊⌊z
CM4
(x · y) · z = x · (y · z)
A5
a · x | b = γ (a, b) · x
CM5
x + δ = x
A6
a | b · x = γ (a, b) · x
CM6
δ · x = δ
A7
a · x | b · y = γ (a, b) · (x ∥y)
CM7
(x + y) | z = x | z + y | z
CM8
∂H (a) = a
if a /∈H
D1
x | (y + z) = x | y + x | z
CM9
∂H (a) = δ
if a ∈H
D2
δ | x = δ
CM10
∂H (x + y) = ∂H (x) + ∂H (y)
D3
x | δ = δ
CM11
∂H (x · y) = ∂H (x) · ∂H (y)
D4
a | b = γ (a, b)
CM12

492
Theory Comput Syst (2019) 63:488–505
Table 2 Axioms for guarded
recursion
⟨X|E⟩= ⟨tX|E⟩
if X=tX ∈E
RDP
E ⇒X = ⟨X|E⟩
if X ∈V(E)
RSP
In the sequel, we will use the sum notation 
i<n ti. For each i ∈N, let ti be a
term of ACP or an extension of ACP . Then 
i<0 ti = δ and, for each n ∈N1,1 the
term 
i<n ti is defined by induction on n as follows: 
i<1 ti = t0 and 
i<n+1 ti =

i<n ti+tn.
2.2 Guarded Recursion
A closed ACP term denotes a process with a finite upper bound to the number of
actions that it can perform. Guarded recursion allows the description of processes
without a finite upper bound to the number of actions that it can perform.
Let T be ACP or a concrete extensions of ACP,2 and let t be a T term containing a
variable X. Then an occurrence of X in t is guarded if t has a subterm of the form a·t′
where a ∈A and t′ is a T term containing this occurrence of X.
Let T be ACP or a concrete extension of ACP. Then a T term t is a guarded T
term if all occurrences of variables in t are guarded.
Let T be ACP or a concrete extension of ACP. Then a guarded recursive spec-
ification over T is a finite or countably infinite set of recursion equations E =
{X = tX | X ∈V }, where V is a set of variables and each tX is either a guarded T
term in which variables other than the variables from V do not occur or a T term
rewritable to such a term using the axioms of T in either direction and/or the equa-
tions in E, except the equation X = tX, from left to right. We write V(E) for the
set of all variables that occur in E. A solution of E in some model of T is a set
{PX | X ∈V(E)} of elements of the carrier of that model such that the equations of
E hold if, for all X ∈V(E), X is assigned PX. We are only interested models of
ACP and concrete extensions of ACP in which guarded recursive specifications have
unique solutions.
Let T be ACP or a concrete extension of ACP. We extend T with guarded recur-
sion by adding constants for solutions of guarded recursive specifications over T and
axioms concerning these additional constants. For each guarded recursive specifica-
tion E over T and each X ∈V(E), we add a constant standing for the unique solution
of E for X to the constants of T . The constant standing for the unique solution of E
for X is denoted by ⟨X|E⟩. We use the following notation. Let t be a T term and E be
a guarded recursive specification. Then we write ⟨t|E⟩for t with, for all X ∈V(E),
all occurrences of X in t replaced by ⟨X|E⟩. We add the equation RDP and the con-
ditional equation RSP given in Table 2 to the axioms of T . In RDP and RSP, X stands
1We write N1 for the set {n ∈N | n ≥1} of positive natural numbers.
2A concrete extension of ACP is an extension of ACP that does not offer the possibility of abstraction
from certain actions. All extensions of ACP introduced in this paper are concrete extensions.

Theory Comput Syst (2019) 63:488–505
493
for an arbitrary variable, tX stands for an arbitrary T term, and E stands for an arbi-
trary guarded recursive specification over T . Side conditions restrict what X, tX and
E stand for. We write Trec for the resulting theory.
The equations ⟨X|E⟩=⟨tX|E⟩for a fixed E express that the constants ⟨X|E⟩make
up a solution of E. The conditional equations E ⇒X = ⟨X|E⟩express that this
solution is the only one.
In extensions of ACP whose axioms include RSP, we have to deal with condi-
tional equational formulas with a countably infinite number of premises. Therefore,
infinitary conditional equational logic is used in deriving equations from the axioms
of extensions of ACP whose axioms include RSP. A complete inference system for
infinitary conditional equational logic can be found in, for example, [15]. It is note-
worthy that derivations are allowed to be of countably infinite length in infinitary
conditional equational logic.
2.3 Some Results about Guarded Recursion
This section is concerned with legitimate ways of manipulating guarded recursive
specifications and with guarded terms of a special form.
Let T be ACP or a concrete extension of ACP. Then, each guarded recursive spec-
ification over T can be manipulated in several ways that are justified by RDP and
RSP.
Proposition 1 (Manipulation) Let T be ACP or a concrete extension of ACP. Then,
for all guarded recursive specifications E over T , for all X ∈V(E):
(1)
if Y = tY ∈E and tY = t′
Y is derivable from the axioms of T , then ⟨X|E⟩=
⟨X|(E \ {Y = tY }) ∪

Y = t′
Y

⟩is derivable from the axioms of T , RDP and
RSP;
(2)
if Y = tY ∈E, Z = tZ ∈E, and t′
Y is tY with some occurrence of Z in tY
replaced by tZ, then ⟨X|E⟩= ⟨X|(E \{Y = tY })∪

Y = t′
Y

⟩is derivable from
the axioms of T , RDP and RSP;
(3)
if Y /∈V(E) and tY is a guarded T term in which variables other than the
variables from V(E) do not occur, then ⟨X|E⟩= ⟨X|E∪{Y = tY }⟩is derivable
from the axioms of T , RDP and RSP.
Proof In case (1), first we apply RDP for each recursion equation in E, next we
apply tY = t′
Y to ⟨Y|E⟩= ⟨tY |E⟩, and finally we apply RSP to the resulting set of
equations. In case (2), first we apply RDP for each recursion equation in E, next we
apply ⟨Z|E⟩= ⟨tZ|E⟩to ⟨Y|E⟩= ⟨tY |E⟩, and finally we apply RSP to the resulting
set of equations. In case (3), we first apply RDP for each recursion equation in E ∪
{Y = tY } and then we apply RSP to the resulting set of equations.3
Proposition 1 will be used in the proof of Theorem 1 in Section 3.2.
3Further details on cases (1) and (2) can be found in the proof of Theorem 4.3.2 from [13].

494
Theory Comput Syst (2019) 63:488–505
Let T be ACP or a concrete extension of ACP. Then the set HNF of head normal
forms of T is inductively defined by the following rules:
–
δ ∈HNF;
–
if a ∈A, then a ∈HNF;
–
if a ∈A and t is a T term, then a · t ∈HNF;
–
if t, t′ ∈HNF, then t+t′ ∈HNF.
Each head normal form of T is derivably equal to a head normal form of the form

i<n ai · ti+ 
j<m bi, where n, m ∈N, for all i ∈N with i < n, ai ∈A and ti is a
T term, and, for all j ∈N with j < m, bj ∈A.
It is well-known that each guarded ACPrec term is derivably equal to a head normal
form of ACPrec (see also Lemma 2.4.7 in [5]).
Proposition 2 (Head normal form) For each guarded ACPrec term t, there exists a
head normal form t′ of ACP such that t = t′ is derivable from the axioms of ACPrec.
Proof The proof is analogous to the proof of Proposition 3 in Section 3.2.
3 Strategic Interleaving
In this section, we extend ACP with strategic interleaving, i.e. interleaving according
to some interleaving strategy. Interleaving strategies are abstractions of schedul-
ing algorithms. Interleaving according to some interleaving strategy is what really
happens in the case of multi-threading as found in contemporary programming
languages.
3.1 ACP with Strategic Interleaving
In the extension of ACP with strategic interleaving presented below, it is expected
that an interleaving strategy uses the interleaving history in one way or another to
make process-scheduling decisions.
The set H of interleaving histories is the subset of (N1 × N1)∗that is inductively
defined by the following rules:
–
⟨⟩∈H ;
–
if i ≤n, then (i, n) ∈H ;
–
if h↷(i, n) ∈H , j ≤n, and n−1 ≤m ≤n+1, then h↷(i, n)↷(j, m) ∈H .4
The intuition concerning interleaving histories is as follows: if the kth pair of an
interleaving history is (i, n), then the ith process got a turn in the kth interleaving step
and after its turn there were n processes to be interleaved. The number of processes to
4We write ⟨⟩for the empty sequence, d for the sequence having d as sole element, and α ↷α′ for the
concatenation of sequences α and α′. We assume that the usual identities, such as ⟨⟩↷α = α and
(α ↷α′) ↷α′′ = α ↷(α′ ↷α′′), hold.

Theory Comput Syst (2019) 63:488–505
495
be interleaved may increase due to process creation (introduced below) and decrease
due to successful termination of processes.
The presented extension of ACP is called ACP+SI ( ACP with Strategic Interleav-
ing). It covers a generic interleaving strategy that can be instantiated with different
specific interleaving strategies that can be represented in the way that is explained
below.
In ACP+SI, it is assumed that the following has been given:
–
a fixed but arbitrary set S;
–
for each n ∈N1, a fixed but arbitrary function σn:H × S →{1, . . . , n};
–
for each n ∈N1, a fixed but arbitrary function ϑn:H ×S ×{1, . . . , n}× A →S.
The elements of S are called control states, σn is called an abstract scheduler (for
n processes), and ϑn is called a control state transformer (for n processes). The
intuition concerning S, σn, and ϑn is as follows:
–
the control states from S encode data that are relevant to the interleaving strategy,
but not derivable from the interleaving history;
–
if σn(h, s) = i, then the ith process gets the next turn after interleaving history h
in control state s;
–
if ϑn(h, s, i, a) = s′, then s′ is the control state that arises from the ith process
doing a after interleaving history h in control state s.
Thus, S, ⟨σn⟩n∈N1, and ⟨ϑn⟩n∈N1 make up a way to represent an interleaving strategy.
This way to represent an interleaving strategy is engrafted on [22].
Consider the case where S is a singleton set, for each n ∈N1, σn is defined by
σn(⟨⟩, s) = 1 ,
σn(h ↷(j, n) , s) = (j + 1) mod n ,
and, for each n ∈N1, ϑn is defined by
ϑn(h, s, i, a) = s .
In this case, the interleaving strategy corresponds to the round-robin scheduling
algorithm. More advanced strategies can be obtained if the scheduling makes more
advanced use of the interleaving history and the control state. The interleaving his-
tory may, for example, be used to factor the individual lifetimes of the processes to be
interleaved and their creation hierarchy into the process-scheduling decision making.
Individual properties of the processes to be interleaved that depend on the actions
performed by them can be taken into account by making use of the control state. The
control state may, for example, be used to factor the processes being interleaved that
currently wait to acquire a lock from a process that manages a shared resource into
the process-scheduling decision making.5
In ACP+SI, it is also assumed that a fixed but arbitrary set D of data and a fixed
but arbitrary function φ:D →P , where P is the set of all closed terms over the
5In [8], various examples of interleaving strategies are given in the setting of the relatively unknown thread
algebra. The representation of the more serious of these examples in the current setting demands nontrivial
use of the control state.

496
Theory Comput Syst (2019) 63:488–505
signature of ACP+SI (given below), have been given and that, for each d ∈D and
a, b ∈A, cr(d), cr(d) ∈A, γ (cr(d), a) = δ, and γ (a, b) ̸= cr(d). The action cr(d)
can be considered a process creation request and the action cr(d) can be considered
a process creation act. They represent the request to start the process denoted by
φ(d) in parallel with the requesting process and the act of carrying out that request,
respectively.
The signature of ACP+SI consists of the constants and operators from the
signature of ACP and in addition the following operators:
–
for each n ∈N1, h ∈H , and s ∈S, the n-ary strategic interleaving operator
∥n
h,s;
–
for each n, i ∈N1 with i ≤n, h ∈H , and s ∈S, the n-ary positional strategic
interleaving operator ⌋⌊n,i
h,s.
The strategic interleaving operators can be explained as follows:
–
a closed term of the form ∥n
h,s (t1, . . . , tn) denotes the process that results from
interleaving of the n processes denoted by t1, . . . , tn after interleaving history
h in control state s, according to the interleaving strategy represented by S,
⟨σn⟩n∈N1, and ⟨ϑn⟩n∈N1.
The positional strategic interleaving operators are auxiliary operators used to axiom-
atize the strategic interleaving operators. The role of the positional strategic inter-
leaving operators in the axiomatization is similar to the role of the left merge operator
found in ACP.
The axioms of ACP+SI are the axioms of ACP and in addition the equations given
in Table 3. In the additional equations, n and i stand for arbitrary numbers from N1
with i ≤n, h stands for an arbitrary interleaving history from H , s stands for an
arbitrary control state from S, a stands for an arbitrary action constant that is not of
the form cr(d) or cr(d), and d stands for an arbitrary datum d from D.
Table 3 Axioms for strategic interleaving
∥n
h,s(x1, . . . , xn) = ⌋⌊n,σn(h,s)
h,s
(x1, . . . , xn)
SI1
⌋⌊n,i
h,s(x1, . . . , xi−1, δ, xi+1, . . . , xn) = δ
SI2
⌋⌊1,i
h,s(a) = a
SI3
⌋⌊n+1,i
h,s
(x1, . . . , xi−1, a, xi+1, . . . , xn+1) =
a · ∥n
h↷(i,n),ϑn+1(h,s,i,a)(x1, . . . , xi−1, xi+1, . . . , xn+1)
SI4
⌋⌊n,i
h,s(x1, . . . , xi−1, a · x′
i, xi+1, . . . , xn) =
a · ∥n
h↷(i,n),ϑn(h,s,i,a)(x1, . . . , xi−1, x′
i, xi+1, . . . , xn)
SI5
⌋⌊n,i
h,s(x1, . . . , xi−1, cr(d), xi+1, . . . , xn) =
cr(d) · ∥n
h↷(i,n),ϑn(h,s,i,cr(d))(x1, . . . , xi−1, xi+1, . . . , xn, φ(d))
SI6
⌋⌊n,i
h,s(x1, . . . , xi−1, cr(d) · x′
i, xi+1, . . . , xn) =
cr(d) · ∥n+1
h↷(i,n+1),ϑn(h,s,i,cr(d))(x1, . . . , xi−1, x′
i, xi+1, . . . , xn, φ(d))
SI7
⌋⌊n,i
h,s(x1, . . . , xi−1, x′
i + x′′
i , xi+1, . . . , xn) =
⌋⌊n,i
h,s(x1, . . . , xi−1, x′
i, xi+1, . . . , xn) + ⌋⌊n,i
h,s(x1, . . . , xi−1, x′′
i , xi+1, . . . , xn)
SI8

Theory Comput Syst (2019) 63:488–505
497
Table 4 Alternative axioms for SI2
⌋⌊1,i
h,s(δ) = δ
SI2a
⌋⌊n+1,i
h,s
(x1, . . . , xi−1, δ, xi+1, . . . , xn+1) =
∥n
h↷(i,n),ϑn+1(h,s,i,δ)(x1, . . . , xi−1, xi+1, . . . , xn+1) · δ
SI2b
Axiom SI2 expresses that, in the event of inactiveness of the process whose turn
it is, the whole becomes inactive immediately. A plausible alternative is that, in the
event of inactiveness of the process whose turn it is, the whole becomes inactive
only after all other processes have terminated or become inactive. In that case, the
functions ϑn: H ×S ×{1, . . . , n}× A →S must be extended to functions ϑn :H ×
S × {1, . . . , n} × (A ∪{δ}) →S and axiom SI2 must be replaced by the axioms in
Table 4.
In (ACP+SI)rec, i.e. ACP+SI extended with guarded recursion in the way
described in Section 2, the processes that can be created are restricted to the ones
denotable by a closed ACP+SI term. This restriction stems from the requirement that
φ is a function from D to the set of all closed ACP+SI terms. The restriction can
be removed by relaxing this requirement to the requirement that φ is a function from
D to the set of all closed (ACP+SI)rec terms. We write (ACP+SI)+
rec for the theory
resulting from this relaxation. In other words, (ACP+SI)+
rec differs from (ACP+SI)rec
in that it is assumed that a fixed but arbitrary function φ : D →P , where P is the
set of all closed terms over the signature of (ACP+SI)rec, has been given.
It is customary to associate transition systems with closed terms of the language of
an ACP-like theory of processes by means of structural operational semantics and to
use this to construct a model in which closed terms are identified if their associated
transition systems are bisimilar. The structural operational semantics of ACP can be
found in [5, 13]. The additional transition rules for the strategic interleaving operators
and the positional strategic interleaving operators are given in Appendix A.
3.2 Basic Properties of ACP with Strategic Interleaving
In this section, the subject of concern is the connection between ACP and ACP+SI.
The main results are an elimination result and a conservative extension result. We
begin with establishing some results that will be used in the proof of those main
results.
Each guarded ACP+SI term is derivably equal to a head normal form of ACP+SI.
Proposition 3 (Head normal form) For each guarded ACP+SI term t, there exists
a head normal form t′ of ACP+SI such that t = t′ is derivable from the axioms of
ACP+SI.
Proof The proof is straightforward by induction on the structure of t. The case where
t is of the form δ and the case where t is of the form a (a ∈A) are trivial. The case
where t is of the form t1 · t2 follows immediately from the induction hypothesis and
the claim that, for all head normal forms t1 and t2 of ACP+SI, there exists a head

498
Theory Comput Syst (2019) 63:488–505
normal form t′ of ACP+SI such that t1 · t2 = t′ is derivable from the axioms of
ACP+SI. This claim is easily proved by induction on the structure of t1. The case
where t is of the form t1+t2 follows immediately from the induction hypothesis. The
cases where t is of one of the forms t1 ⌊⌊t2, t1 | t2, ∂H(t1) or ⌋⌊n,i
h,s(t1, . . . , tn) are
proved along the same lines as the case where t is of the form t1 · t2. In the case that
t is of the form t1 | t2, each of the cases to be considered in the inductive proof of the
claim demands a proof by induction on the structure of t2. In the case that t is of the
form ⌋⌊n,i
h,s(t1, . . . , tn), the claim is of course proved by induction on the structure of
ti instead of t1. The case that t is of the form t1 ∥t2 follows immediately from the
case that t is of the form t1 ⌊⌊t2 and the case that t is of the form t1 |t2. The case that t
is of the form ∥n
h,s(t1, . . . , tn) follows immediately from the case that t is of the form
⌋⌊n,i
h,s(t1, . . . , tn). Because t is a guarded ACP+SI term, the case where t is a variable
cannot occur.
Each of the four theorems to come refer to several process algebras. It is implicit
that the same set A of actions and the same communication function γ are assumed
in the process algebras referred to.
Each guarded recursive specification over ACP+SI can be reduced to a guarded
recursive specification over ACP.
Theorem 1 (Reduction) For each guarded recursive specification E over ACP+SI
and each X ∈V(E), there exists a guarded recursive specification E′ over ACP such
that ⟨X|E⟩= ⟨X|E′⟩is derivable from the axioms of (ACP+SI)+
rec.
Proof Let E be a guarded recursive specification over ACP+SI. Assume that, for
each equation X = tX from E, tX is a guarded ACP+SI term. It follows from
Proposition 1 that this assumption does not lead to loss of generality.
Let X = tX be an equation from E. Now, by Proposition 3, there exist n, m ∈N
such that, for each i ∈N with i < n and j ∈N with j < m, there exist an ai ∈A,
an ACP+SI term ti, and a bj ∈A such that tX = 
i<n ai · ti+ 
j<m bj is derivable
from the axioms of ACP+SI. For each i ∈N with i < n, let t′
i be ti with, for each
equation Y = tY from E, each unguarded occurrence of Y in ti replaced by the
guarded ACP+SI term tY . For each i ∈N with i < n, by its construction, the term t′
i
is a guarded ACP+SI terms in which variables other than the ones from V(E) do not
occur. Now, by Proposition 1, the equation Xi = t′
i, where Xi is a fresh variable, can
be added to E for each i ∈N with i < n and the equation X = tX can be replaced
by the equation X = 
i<n ai · Xi+ 
j<m bj in E. The other equations from E can
be replaced by a set of equations in the same way as the equation X = tX.
The set of equations so obtained can be manipulated following the same pro-
cedure as in the case of E, but the manipulation can be restricted to the added
equations. Repeating this procedure, perhaps countably infinitely many times, we
obtain a guarded recursive specification E′ over ACP for which ⟨X|E⟩= ⟨X|E′⟩is
derivable from the axioms of (ACP+SI)+
rec.
The next three theorems will be proved by means of term rewriting systems.
In Appendix B, basic definitions and results regarding term rewriting systems are

Theory Comput Syst (2019) 63:488–505
499
collected. This appendix also serves to fix the terminology on term rewriting systems
used in the proofs of the next three theorems.
Each closed (ACP+SI)+
rec term is derivably equal to a closed ACPrec term.
Theorem 2 (Elimination) For each closed (ACP+SI)+
rec term t, there exists a closed
ACPrec term t′ such that t = t′ is derivable from the axioms of (ACP+SI)+
rec.
Proof We prove this by means of a term rewriting system that takes equational
axioms of (ACP+SI)+
rec and equations derivable from the axioms of (ACP+SI)+
rec as
rewrite rules. Thus, the proof boils down to showing that (a) the term rewriting sys-
tem concerned has the property that each (ACP+SI)+
rec term has a unique normal
form modulo axioms A1 and A2 and (b) each closed (ACP+SI)+
rec term that is a nor-
mal form modulo axioms A1 and A2 is a closed ACPrec term. Henceforth, we will
write AC for the set of equations that consists of axioms A1 and A2.
Let R be a set of equations that contains for each guarded recursive specification
E over ACP+SI and X ∈V(E) an equation ⟨X|E⟩= ⟨X|E′⟩, where E′ is a guarded
recursive specification over ACP, that is derivable from the axioms of (ACP+SI)+
rec.
Such a set R exists by Theorem 1. Consider the term rewriting system R((ACP +
SI)+
rec) that consists of the axioms of (ACP+SI)+
rec, with the exception of A1, A2,
RDP, and RSP, and the equations from R taken as rewrite rules.
We show that R((ACP+SI)+
rec) has the property that each (ACP+SI)+
rec term has
a unique normal form modulo AC by proving that R((ACP+SI)+
rec) is terminating
modulo AC and confluent modulo AC.
First, we show that R((ACP+SI)+
rec) is terminating modulo AC. This can be
proved by the reduction ordering > induced by the extended integer polynomials θ(t)
associated with (ACP+SI)+
rec terms t as follows:6
θ(X) = X ,
θ(a) = 2 ,
θ(δ) = 2 ,
θ(cr(d)) = θ(φ(d))2 + 1 ,
θ(t1 + t2) = θ(t1) + θ(t2) ,
θ(t1 · t2) = θ(t1)2 · θ(t2) ,
θ(t1 ∥t2) = 3 · (θ(t1) · θ(t2))2 + 1 ,
θ(t1 ⌊⌊t2) = (θ(t1) · θ(t2))2 ,
θ(t1 | t2) = (θ(t1) · θ(t2))2 ,
θ(∂H(t)) = 2θ(t) ,
θ(∥n
h,s(t1, . . . , tn) = (θ(t1) · . . . · θ(tn))2 + 1 ,
θ(⌋⌊n,i
h,s(t1, . . . , tn)) = (θ(t1) · . . . · θ(tn))2 ,
θ(⟨X|E⟩) =
 2 if E is a guarded recursive specification over ACP
3 otherwise,
where it is assumed that, for each variable X over processes, X is a variable over
integers. The following is easy to see: (a) t > t′ for all rewrite rules t = t′ of
R((ACP+SI)+
rec) and (b) t > t′ implies s > s′ for all (ACP+SI)+
rec terms s and s′
for which t = s and t′ = s′ are derivable from AC.7 Hence, R((ACP+SI)+
rec) is
terminating modulo AC.
6Here, extended polynomials differ from polynomials in that both variables and expressions of the form
2X, where X is a variable, are allowed where only variables are allowed in polynomials.
7We do not have that t > t′ for all rewrite rules t = s if SI2 is replaced by SI2a and SI2b (see Table 4).

500
Theory Comput Syst (2019) 63:488–505
Next, we show that R((ACP+SI)+
rec) is confluent modulo AC. It follows from
Theorems 5 and 16 in [20] and the fact that R((ACP+SI)+
rec) is terminating modulo
AC that R((ACP+SI)+
rec) is confluent modulo AC if it does not give rise to critical
pairs modulo AC that are not convergent. It is easy to see that all critical pairs modulo
AC arise from overlappings of (a) A3 on A4, CM4, CM8, CM9, D3, and SI8, (b) A6
on A4, CM4, CM8, CM9, D3, and SI8, (c) A7 on CM3, CM5, CM6, CM7, D4, and
SI5, (d) CM10 on CM9, and (e) CM11 on CM8. It is straightforward to check that all
critical pairs concerned are convergent. Hence, R((ACP+SI)+
rec) is confluent modulo
AC.
Above, we have shown that R((ACP+SI)+
rec) is terminating modulo AC and con-
fluent modulo AC and by this that it has the property that each (ACP+SI)+
rec term
has a unique normal form modulo AC. It remains to be shown that each closed
(ACP+SI)+
rec term that is a normal form modulo AC is a closed ACPrec term. It is not
hard to see that, for each closed (ACP+SI)+
rec term in which other operators than +
and · occur, a reduction step modulo AC is still possible in R((ACP+SI)+
rec). Because
a reduction step modulo AC is impossible for a normal form modulo AC, no other
operators than + or · can occur in a closed (ACP+SI)+
rec term that is a normal form
modulo AC. Hence, each closed (ACP+SI)+
rec term that is a normal form modulo AC
is a closed ACPrec term.
Each equation between closed ACP terms that is derivable in ACP+SI is also
derivable in ACP.
Theorem 3 (Conservative extension) For each two closed ACP terms t and t′, t = t′
is derivable from the axioms of ACP+SI only if t = t′ is derivable from the axioms
of ACP.
Proof We prove this by means of a restriction of the term rewriting system from
the proof of Theorem 2. Consider the term rewriting system R(ACP+SI) that con-
sists of the axioms of ACP+SI, with the exception of A1 and A2. R(ACP+SI)
is R((ACP+SI)+
rec) restricted to ACP+SI terms. Just like R((ACP+SI)+
rec),
R(ACP+SI) is terminating modulo AC and confluent modulo AC. The proofs of
these properties for R((ACP+SI)+
rec) carry over to R(ACP+SI).
Let t and t′ be two closed ACP terms such that t = t′ is derivable from the axioms
of ACP+SI. Reduce t and t′ to normal forms s and s′, respectively, by means of the
term rewriting system R(ACP+SI). By Theorem 5 in [20], being confluent modulo
AC is equivalent to being Church-Rosser modulo AC for a term rewriting system
that is terminating modulo AC. This means that t and t′ have the same normal form
modulo AC. In other words, s = s′ is derivable from axioms A1 and A2. Because (a)
no other operators than + and · occur in t and t′ and (b) no rewrite rule introduces
one or more of the other operators if one or more of the other operators was not
already in its left-hand side, each rewrite rule applied in the reduction from t to s or
the reduction from t′ to s′ is one of the axioms of ACP. Therefore, each rewrite rule
involved in the reduction from t to s or the reduction from t′ to s′ is an axiom of ACP.
Hence, the reduction from t to s shows that t = s is derivable from the axioms of

Theory Comput Syst (2019) 63:488–505
501
ACP and the reduction from t′ to s′ shows that t′ = s′ is derivable from the axioms
of ACP. From this and the fact that s = s′ is derivable from axioms A1 and A2, it
follows t = t′ is derivable from the axioms of ACP.
The following theorem concerns the expansion of minimal models of ACP to
models of ACP+SI.
Theorem 4 (Unique expansion) Each minimal model of ACP has a unique expan-
sion to a model of ACP+SI.
Proof We write f A , where A is a model of ACP or ACP+SI and f is a constant
or operator from the signature of A , for the interpretation of f in A . We write tA ,
where A is a model of ACP or ACP+SI and t is a closed term over the signature of
A , for the interpretation of t in A .
Let A be a minimal model of ACP. Let CT be a function from the carrier of A
to the set of all closed ACP terms such that, for each element p of the carrier of A ,
CT(p)A = p. Because A is a minimal model of ACP, CT(p) is a total function. We
write p, where p is an element of the carrier of A , for CT(p). Let NF be a function
from the set of all closed ACP+SI terms to the set of all closed ACP terms such
that, for each closed ACP+SI term t, NF(t) is one of the normal forms that t can
be reduced to by means of the term rewriting system R(ACP+SI) from the proof of
Theorem 3.
We start with constructing an expansion of A with interpretations of the addi-
tional operators of ACP+SI. Let B be the expansion of A with interpretations of the
additional operators of ACP+SI where these interpretations are defined as follows:
∥n
h,s
B(p1, . . . , pn) = NF(∥n
h,s(p1, . . . , pn))A ,
⌋⌊n,i
h,s
B(p1, . . . , pn) = NF(⌋⌊n,i
h,s(p1, . . . , pn))
A ,
for all p1, . . . , pn from the carrier of A .
We proceed with proving that B is a model of ACP+SI. By Theorem 3, it is
sufficient to prove that B satisfies axioms SI1–SI8. By its construction, B is a min-
imal algebra and consequently it is sufficient to prove that B satisfies all closed
substitution instances of SI1–SI8. We use the following three claims to prove this:
–
for all closed substitution instances t = t′ of SI1–SI8, tB = NF(t)A ;
–
for all closed substitution instances t = t′ of SI1–SI8, t′B = NF(t′)A ;
–
for all closed substitution instances t = t′ of SI1–SI8, NF(t)A = NF(t′)A .
The first claim follows easily from the definitions of the interpretations of the addi-
tional operators of ACP+SI given above. The second claim follows easily from these
definitions and the proof of the first claim. Because R(ACP+SI) is Church-Rosser
modulo AC (see the proof of Theorem 3), we have that NF(t) = NF(t′) is deriv-
able from axioms A1 and A2. From this, the third claim follows immediately. It is
an immediate consequence of the three claims that B satisfies all closed substitution
instances of SI1–SI8.
We still have to prove that B is the only expansion of A to a model of ACP+SI.
We can prove this by contradiction. Assume that C is an expansion of A to a model of

502
Theory Comput Syst (2019) 63:488–505
ACP+SI that differs from B. Then at least one of the additional operators of ACP+SI
has different interpretations in B and C . By the definitions of the interpretations of the
additional operators of ACP+SI in B, this means that there exists a closed ACP+SI
term t such that tC ̸= NF(t)A . Moreover, because because t = NF(t) is derivable
from the axioms of ACP+SI, tC = NF(t)C . Hence, NF(t)C ̸= NF(t)A . Because
NF(t) is a closed ACP term, this contradicts the fact that C is an expansion of A .
4 Concluding Remarks
We have extended the algebraic theory of processes known as ACP with the form of
interleaving that underlies multi-threading as found in contemporary programming
languages. We have also established some basic properties of the resulting theory. It
remains an open question whether strategic interleaving is definable in an established
extension of ACP.
Acknowledgements
We thank an anonymous referee for carefully reading a preliminary version of this
paper, for pointing out an error in one of the proofs, and for suggesting improvements of the presentation.
Open Access
This article is distributed under the terms of the Creative Commons Attribution 4.0
International License (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted use, dis-
tribution, and reproduction in any medium, provided you give appropriate credit to the original author(s)
and the source, provide a link to the Creative Commons license, and indicate if changes were made.
Appendix A: Structural Operational Semantics of ACP+SI
It is customary to associate transition systems with closed terms of the language of an
ACP-like theory about processes by means of structural operational semantics and to
use this to construct a model in which closed terms are identified if their associated
transition systems are bisimilar. The structural operational semantics of ACP can be
found in [5, 13]. The additional transition rules for the strategic interleaving operators
and the positional strategic interleaving operators are given in Table 5. In this table,
–
t
a→√indicates that t is capable of performing action a and then terminating
successfully;
–
t
a→t′ indicates that t is capable of performing action a and then behaving as t′.
The transition rules for the strategic interleaving operator are similar to the transition
rules for the positional strategic interleaving operators. However, each transition rule
for the strategic interleaving operator has the side-condition i = σn(h, s).
Appendix B: Term Rewriting Systems
In this appendix, basic definitions and results regarding term rewriting systems are
collected. This appendix also serves to fix the terminology on term rewriting systems
used in the proofs that make use of term rewriting systems.

Theory Comput Syst (2019) 63:488–505
503
Table 5 Transition rules for strategic interleaving
x
a−→√
∥1
h,s(x)
a−→√
xi
a−→√
i = σn(h, s)
∥n+1
h,s (x1, . . . , xn+1)
a−→∥n
h↷(i,n),ϑn+1(h,s,i,a)(x1, . . . , xi−1, xi+1, . . . , xn+1)
xi
a−→x′
i
i = σn(h, s)
∥n
h,s(x1, . . . , xn)
a−→∥n
h↷(i,n),ϑn(h,s,i,a)(x1, . . . , xi−1, x′
i, xi+1, . . . , xn)
xi
cr(d)
−−−→√
i = σn(h, s)
∥n
h,s(x1, . . . , xn)
cr(d)
−−−→∥n
h↷(i,n),ϑn(h,s,i,cr(d))(x1, . . . , xi−1, xi+1, . . . , xn, φ(d))
xi
cr(d)
−−−→x′
i
i = σn(h, s)
∥n
h,s(x1, . . . , xn)
cr(d)
−−−→∥n+1
h↷(i,n+1),ϑn(h,s,i,cr(d))(x1, . . . , xi−1, x′
i, xi+1, . . . , xn, φ(d))
x
a−→√
⌋⌊1,i
h,s(x)
a−→√
xi
a−→√
⌋⌊n+1,i
h,s
(x1, . . . , xn+1)
a−→∥n
h↷(i,n),ϑn+1(h,s,i,a)(x1, . . . , xi−1, xi+1, . . . , xn+1)
xi
a−→x′
i
⌋⌊n,i
h,s(x1, . . . , xn)
a−→∥n
h↷(i,n),ϑn(h,s,i,a)(x1, . . . , xi−1, x′
i, xi+1, . . . , xn)
xi
cr(d)
−−−→√
⌋⌊n,i
h,s(x1, . . . , xn)
cr(d)
−−−→∥n
h↷(i,n),ϑn(h,s,i,cr(d))(x1, . . . , xi−1, xi+1, . . . , xn, φ(d))
xi
cr(d)
−−−→x′
i
⌋⌊n,i
h,s(x1, . . . , xn)
cr(d)
−−−→∥n+1
h↷(i,n+1),ϑn(h,s,i,cr(d))(x1, . . . , xi−1, x′
i, xi+1, . . . , xn, φ(d))
We assume that a set of constants, a set of operators with fixed arities, and a set of
variables have been given; and we consider an arbitrary term rewriting system R for
terms that can be built from the constants, operators, and variables in these sets.
A rewrite rule is a pair of terms t →s, where t is not a variable and each variable
occurring in s occurs in t as well. A term rewriting system is a set of rewrite rules.
A reduction step of R is a pair t →s such that for some substitution instance
t′ →s′ of a rewrite rule of R, t′ is a subterm of t, and s is t with t′ replaced by s′.
Here, t′ is called the redex of the reduction step. A reduction of R is a pair t ↠s
such that either t ≡s or there exists a finite sequence t1 →t2, . . . , tn →tn+1 of
consecutive reduction steps of R such that t ≡t1 and s ≡tn+1.
A term t is a normal form of R if there does not exist a term s such that t →s
is a reduction step of R. A term t has a normal form in R if there exists a reduction
t ↠s of R and s is a normal form of R. R is terminating on term t if there does
not exist an infinite sequence t →t1, t1 →t2, t2 →t3, . . . of consecutive reduction
steps of R. R is terminating if R is terminating on all terms. R is confluent if for all
reductions t ↠s1 and t ↠s2 of R there exist reductions s1 ↠s and s2 ↠s of R.
If R is terminating and confluent, then each term has a unique normal form in R.

504
Theory Comput Syst (2019) 63:488–505
A reduction ordering for R is a well-founded ordering on terms that is closed
under substitutions and contexts. R is terminating if and only if there exists a
reduction ordering > for R such that t > s for each rewrite rule t →s of R.
A unifier of two terms s and t is a substitution σ such that σ(s) ≡σ(t). A critical
pair of R is a pair (t1, t2) of terms for which there exist rewrite rules s →s′ and
t →t′ of R and a ‘most general unifier’ σ of s and a non-variable subterm of t such
that t1 ≡σ(t′′) and t2 ≡σ(t′), where t′′ is t with σ(s) replaced by σ(s′).8 A critical
pair (t1, t2) of R is convergent if there exist reductions t1 ↠s and t2 ↠s of R. If R
is terminating, then R is confluent if and only if all critical pairs of R are convergent.
Henceforth, we consider an arbitrary set E of equations between terms.
A reduction step modulo E of R is a pair t →E s such that there exists a reduction
step t′ →s′ of R such that t = t′ and s = s′ are derivable from E. A reduction
modulo E of R is pair t ↠E s such that either t = s is derivable from E or there
exists a finite sequence t1 →E t2, . . . , tn →E tn+1 of consecutive reduction steps
modulo E of R such that t ≡t1 and s ≡tn+1.
A term t is a normal form modulo E of R if there does not exist a term s such that
t →E s is a reduction step modulo E of R. A term t has a normal form modulo E in
R if there exists a reduction modulo E t ↠E s of R and s is a normal form modulo
E of R. R is terminating modulo E on term t if there does not exist an infinite
sequence t →E t1, t1 →E t2, t2 →E t3, . . . of consecutive reduction steps modulo
E of R. R is terminating modulo E if R is terminating modulo E on all terms. R is
confluent modulo E if for all reductions modulo E t ↠E s1 and t ↠E s2 of R there
exist reductions modulo E s1 ↠E s and s2 ↠E s of R. If R is terminating modulo
E and confluent modulo E, then each term has a unique normal form modulo E in R.
A reduction ordering > for R is E-compatible if t > s implies t′ > s′ for all
terms t′ and s′ for which t = t′ and s = s′ are derivable from E. R is terminating
modulo E if and only if there exists an E-compatible reduction ordering > for R
such that t > s for each rewrite rule t →s of R.
A unifier modulo E of two terms s and t is a substitution σ such that σ(s) = σ(t)
is derivable from E. A critical pair modulo E of R is a pair (t1, t2) of terms for
which there exist rewrite rules s →s′ and t →t′ of R and a substitution σ from
a ‘complete set of unifiers modulo E′ of s and a non-variable subterm of t such that
t1 ≡σ(t′′) and t2 ≡σ(t′), where t′′ is t with σ(s) replaced by σ(s′).8 If R is
terminating modulo E, then R is confluent modulo E if and only if all critical pairs
modulo E of R are convergent.
An E-equality step is a pair t |−|E s such that, for some substitution instance t′ = s′
of an equation from E, either t′ is a subterm of t and s is t with t′ replaced by s′ or
s′ is a subterm of t and s is t with s′ replaced by t′. An R ∪E-equality step is a pair
t |=|E s such that t →s is a reduction step of R or s →t is a reduction step of R or
t |−|E s is an E-equality step. An R∪E-equality is a pair t |=∗|E s such that either t ≡s
or there exists a finite sequence t1 |=|E t2, . . . , tn |=|E tn+1 of consecutive R ∪E-
equality steps such that t ≡t1 and s ≡tn+1. R is Church-Rosser modulo E if for all
8See e.g. Definition 10 in [20] for the definitions of most general unifier and complete set of unifiers
modulo E.

Theory Comput Syst (2019) 63:488–505
505
R ∪E-equalities t |=∗|E t′ there exist reductions modulo E t →
→E s and t′ →
→E s of
R. If R is terminating modulo E, then R is Church-Rosser modulo E if and only if
R is confluent modulo E.
Publisher’s Note
Springer Nature remains neutral with regard to jurisdictional claims in published maps
and institutional affiliations.
References
1. America, P., de Bakker, J.W.: Designing equivalent semantic models for process creation. Theor.
Comput. Sci. 60(2), 109–176 (1988)
2. Baeten, J.C.M., Bergstra, J.A.: Real space process algebra. Form. Asp. Comput. 5(6), 481–529 (1993)
3. Baeten, J.C.M., Middelburg, C.A.: Process Algebra with Timing. Monographs in Theoretical Com-
puter Science, an EATCS Series. Springer, Berlin (2002)
4. Baeten, J.C.M., Vaandrager, F.W.: An algebra of process creation. Acta Informatica 29(4), 303–334
(1992)
5. Baeten, J.C.M., Weijland, W.P.: Process Algebra Cambridge Tracts in Theoretical Computer Science,
vol. 18. Cambridge University Press, Cambridge (1990)
6. Bergstra, J.A.: A process creation mechanism in process algebra. In: Baeten, J.C.M. (ed.) Applica-
tions of Process Algebra, Cambridge Tracts in Theoretical Computer Science, vol. 17, pp. 81–88.
Cambridge University Press, Cambridge (1990)
7. Bergstra, J.A., Klop, J.W.: Process algebra for synchronous communication. Inf. Control. 60(1–3),
109–137 (1984)
8. Bergstra, J.A., Middelburg, C.A.: Thread algebra for strategic interleaving. Form. Asp. Comput. 19(4),
445–474 (2007)
9. Bergstra, J.A., Middelburg, C.A.: A thread algebra with multi-level strategic interleaving. Theory
Comput. Syst. 41(1), 3–32 (2007)
10. Bergstra, J.A., Middelburg, C.A.: Distributed strategic interleaving with load balancing. Futur. Gener.
Comput. Syst. 24(6), 530–548 (2008)
11. Bergstra, J.A., Middelburg, C.A., Usenko, Y.S.: Discrete time process algebra and the semantics of
SDL. In: Bergstra, J.A., Ponse, A., Smolka, S.A. (eds.) Handbook of Process Algebra, pp. 1209–1268.
Elsevier, Amsterdam (2001)
12. Brookes, S.D., Hoare, C.A.R., Roscoe, A.W.: A theory of communicating sequential processes. J.
ACM 31(3), 560–599 (1984)
13. Fokkink, W.J.: Introduction to Process Algebra. Texts in Theoretical Computer Science, an EATCS
Series. Springer, Berlin (2000)
14. Gehrke, T., Rensink, A.: Process creation and full sequential composition in a name-passing calculus.
Electron. Notes Theor. Comput. Sci. 7, 141–160 (1997)
15. van Glabbeek, R.J., Vaandrager, F.W.: Modular specification of process algebras. Theor. Comput. Sci.
113(2), 293–348 (1993)
16. Gosling, J., Joy, B., Steele, G., Bracha, G. The Java Language Specification, 2nd edn. Addison-
Wesley, Reading (2000)
17. Hejlsberg, A., Wiltamuth, S., Golde, P.: C# Language Specification. Addison-Wesley, Reading (2003)
18. Hennessy, M., Milner, R.: Algebraic laws for non-determinism and concurrency. J. ACM 32(1), 137–
161 (1985)
19. Hoare, C.A.R.: Communicating Sequential Processes. Prentice-Hall, Englewood Cliffs (1985)
20. Jouannaud, J.P., Kirchner, H.: Completion of a set of rules modulo a set of equations. SIAM J. Comput.
15(4), 1155–1194 (1986)
21. Milner, R.: Communication and Concurrency. Prentice-Hall, Englewood Cliffs (1989)
22. Sabelfeld, A., Sands, D.: Probabilistic noninterference for multi-threaded programs. In: Computer
Security Foundations Workshop 2000, pp. 200–214. IEEE Computer Society Press (2000)

