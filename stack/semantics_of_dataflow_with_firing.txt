4
The semantics of dataﬂow with ﬁring
Edward A. Lee
University of California, Berkeley
Eleftherios Matsikoudis
University of California, Berkeley
Abstract
Dataﬂow models of computation have intrigued computer scientists since
the 1970s. They were ﬁrst introduced by Jack Dennis as a basis for
parallel programming languages and architectures, and by Gilles Kahn
as a model of concurrency. Interest in these models of computation has
been recently rekindled by the resurrection of parallel computing, due
to the emergence of multicore architectures. However, Dennis and Kahn
approached dataﬂow very diﬀerently. Dennis’ approach was based on
an operational notion of atomic ﬁrings driven by certain ﬁring rules.
Kahn’s approach was based on a denotational notion of processes as
continuous functions on inﬁnite streams. This paper bridges the gap
between these two points of view, showing that sequences of ﬁrings deﬁne
a continuous Kahn process as the least ﬁxed point of an appropriately
constructed functional. The Dennis ﬁring rules are sets of ﬁnite preﬁxes
satisfying certain conditions that ensure determinacy. These conditions
result in ﬁring rules that are strictly more general than the blocking
reads of the Kahn–MacQueen implementation of Kahn process networks,
and solve some compositionality problems in the dataﬂow model. This
work was supported in part by the Center for Hybrid and Embedded
Software Systems (CHESS) at UC Berkeley, which receives support from
the National Science Foundation (NSF awards #0720882 (CSR-EHS:
PRET), #0647591 (CSR-SGER), and #0720841 (CSR-CPS)), the US
Army Research Oﬃce (ARO #W911NF-07-2-0019), the US Air Force
Oﬃce of Scientiﬁc Research (MURI #FA9550-06-0312 and AF-TRUST
#FA9550-06-1-0244), the Air Force Research Lab (AFRL), the State of
California Micro Program, and the following companies: Agilent, Bosch,
DGIST, National Instruments, and Toyota.
From Semantics to Computer Science Essays in Honour of Gilles Kahn,
eds Yves
Bertot, G´erard Huet, Jean-Jacques L´evy and Gordon Plotkin. Published by Cambridge
University Press.
c
⃝Cambridge University Press 2009.
71
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

72
E. A. Lee and E. Matsikoudis
4.1 Introduction
Three major variants of the dataﬂow model of computation have
emerged in the literature: Kahn process networks [15], Dennis dataﬂow
[10], and dataﬂow synchronous languages [2]. The ﬁrst two are closely
related, while the third is quite diﬀerent. This paper deals only with
the ﬁrst two, which have a key diﬀerence. In Dennis dataﬂow, a process
is implemented as an execution of atomic ﬁrings of actors. Although
Dennis dataﬂow can be viewed as a special case of Kahn process
networks [18], the notion of ﬁring has been absent from semantic models,
which are most developed for Kahn process networks and dataﬂow
synchronous languages.
Dennis and Kahn approach dataﬂow very diﬀerently. Dennis’ approach
is based on an operational notion of atomic ﬁrings driven by the
satisfaction of ﬁring rules. Kahn’s approach is based on a denotational
notion of processes as continuous functions on inﬁnite streams. Dennis’
approach inﬂuenced computer architecture [1, 26], compiler design, and
concurrent programming languages [14]. Kahn’s approach has inﬂuenced
process algebras (see for example [6]) and semantics of concurrent
systems (see for example [4, 20]). It has had practical realizations in
stream languages [28] and operating systems (such as Unix pipes).
Recently, interest in these models of computation has been rekindled
by the resurrection of parallel computing, motivated by multicore
architectures [8]. Dataﬂow models of computation are being explored for
programming parallel machines [30], distributed systems [17, 21, 24], and
embedded systems [19, 13]. Considerable eﬀort is going into improved
execution policies [31, 11, 32, 18] and standardization [22, 12].
This paper bridges the gap between Dennis and Kahn, showing
that the methods pioneered by Kahn extend naturally to Dennis
dataﬂow, embracing the notion of ﬁring. This is done by establishing
the relationship between a ﬁring function and the Kahn process
implemented as a sequence of ﬁrings of that function. A consequence
of this analysis is a formal characterization of ﬁring rules and ﬁring
functions that preserve determinacy.
4.2 Review of Kahn process networks
4.2.1 Ordered sets
We begin with a brief review of ordered sets [9].
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
73
An order relation ⩽on a set A is a binary relation on A that is
reﬂexive (a ⩽a′), transitive (if a ⩽a′ and a′ ⩽a′′, then a ⩽a′′), and
antisymmetric (if a ⩽a′ and a′ ⩽a, then a = a′). Of course, we can
deﬁne a corresponding irreﬂexive relation, denoted by <, with a < a′ if
and only if a ⩽a′ and a ̸= a′. The structure ⟨A, ⩽⟩is an ordered set. If
the order relation is partial, in the sense that there exist a, a′ ∈A such
that a ̸⩽a′ and a′ ̸⩽a, then we will often refer to ⟨A, ⩽⟩as a partially
ordered set, or simply a poset. If, on the other hand, the order relation
is total, in the sense that for all a, a′ ∈A, a ⩽a′ or a′ ⩽a, then we will
refer to ⟨A, ⩽⟩as a totally ordered set, or a chain.
For any ordered set ⟨A, ⩽⟩and any B ⊆A, an element a is an upper
bound of B in ⟨A, ⩽⟩, iﬀfor any b ∈B, b ⩽a. a is the least upper bound
of B in ⟨A, ⩽⟩iﬀit is an upper bound of B, and for any other upper
bound a′ of B, a ⩽a′. We write  B to denote the least upper bound
of B. The notion of lower bound and that of greatest lower bound are
deﬁned dually. In the case of two elements a1 and a2, we typically write
a1∨a2 and a1∧a2, instead of  {a1, a2} and  {a1, a2}. These are called
the join and meet of a1 and a2.
A set D ⊆A is directed in ⟨A, ⩽⟩iﬀit is non-empty and every ﬁnite
subset of D has an upper bound in ⟨A, ⩽⟩. If every directed subset of
A has a least upper bound in ⟨A, ⩽⟩, then ⟨A, ⩽⟩is a directed-complete
ordered set. If ⟨A, ⩽⟩is directed-complete and has a least element, then
⟨A, ⩽⟩is a complete partial order, or cpo. If ⟨A, ⩽⟩is directed-complete,
and every non-empty subset of A has a greatest lower bound in ⟨A, ⩽⟩,
then ⟨A, ⩽⟩is a complete semilattice.
4.2.2 Sequences
We henceforth assume a non-empty set V of values. Each value
represents a token, an atomic unit of data exchanged between the
autonomous computing stations. We consider the set of all ﬁnite and
inﬁnite sequences over V.
A ﬁnite sequence of values, or simply a ﬁnite sequence, is a function
from the set {0, . . . , n −1} for some natural number n into the set V.
Notice that in the case of n = 0, {0, . . . , n −1} →V = ∅→V = {∅}.
The empty set is therefore a ﬁnite sequence, which we call the empty
sequence and denote by ε. We denote the set of all ﬁnite sequences of
values by V∗. This is of course the well known Kleene closure of the set V.
An inﬁnite sequence of values, or simply an inﬁnite sequence, is a
function from the set of all natural numbers ω into the set V. We denote
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

74
E. A. Lee and E. Matsikoudis
the set of all inﬁnite sequences of values by Vω. This is just another
notation for the set ω →V. We denote the set of all such sequences of
values, ﬁnite or inﬁnite, by S; that is, S = V∗∪Vω.
For any ﬁnite sequence s, the length of s is the cardinal number of
dom s, which we denote by |s|. This is just the number of elements in s.
Informally, a sequence is just an ordered list of values. For any
particular sequence s, we often list its values explicitly, writing
⟨v0, v1, . . . , v|s|−1⟩if s is ﬁnite, and ⟨v0, v1, . . .⟩if s is inﬁnite. If s is the
empty sequence ε, then we simply write ⟨⟩.
A sequence s1 is a preﬁx of a sequence s2, and we write s1 ⊑s2, if and
only if s1 ⊆s2. We make use of the set-theoretic deﬁnition of function
here, according to which the graph of a function is the function itself.
We caution the reader not to misread our statement: not every subset
of a sequence is a preﬁx. If that subset is a sequence, however, then it
must be a preﬁx of the original sequence.
Informally, s1 is a preﬁx of s2 if and only if the ﬁrst |s1| values of s2
are the values of s1 in the same order as in s1; that is, for any natural
number i ∈dom s1, s2(i) = s1(i).
The preﬁx relation ⊑⊂S × S is of course an order relation, and for
any sequence s, ε ⊑s. The ordered set ⟨S, ⊑⟩is actually a complete
semilattice. For any subset X of S, we write
X to denote the greatest
lower bound of X in ⟨S, ⊑⟩, namely the greatest common preﬁx of the
sequences in X, and X to denote the least upper bound of X in ⟨S, ⊑⟩,
provided of course that this exists. In the case of two sequences s1 and
s2, we typically write s1 ⊓s2 and s1 ⊔s2 for the meet and join of s1 and
s2.
If s1 is a ﬁnite sequence and s2 an arbitrary sequence, then we write
s1.s2 to denote the concatenation of s1 and s2. It is the unique sequence
s with dom s = {0, . . . , |s1| + |s2| −1} if s2 is ﬁnite, and dom s = ω
otherwise, such that for any i ∈dom s, s(i) = s1(i) if i < |s1|, and
s(i) = s2(i −|s1|) otherwise.
Informally, s1.s2 is the result of appending the ordered list of values
of s2 right after the end of s1. Note that any ﬁnite s1 is a preﬁx of a
sequence s iﬀthere is a sequence s2 such that s1.s2 = s. It should be
clear that s2 is unique.
4.2.3 Tuples of sequences
A sequence of values models the traﬃc of tokens over a single communi-
cation line. A typical process network will have several communication
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
75
lines, and a typical process will communicate over several of those.
Thus, it will be useful to group together several diﬀerent sequences and
manipulate them as a single object. We do this using the notion of tuple.
A tuple is just a ﬁnite enumeration of objects. Here we are interested in
tuples of sequences. For any natural number n, an n-tuple of sequences,
or simply a tuple, is a function from {0, . . . , n −1} into S. We let Sn
denote the set of all n-tuples of sequences. For convenience, we identify
S1 with S. Note that when n = 0, Sn = ∅→S = {∅}. The empty set is
thus a tuple, which we call the empty tuple.
We use boldface letters to denote tuples. If s is an n-tuple, then for
any i ∈{0, . . . , n −1}, we often write si instead of s(i). Also, we often
list the sequences within a tuple explicitly, writing ⟨s0, . . . , sn−1⟩.
We say that an n-tuple is ﬁnite if and only if for any i ∈{0, . . . , n −1},
si is a ﬁnite sequence. This is of course vacuously true for the empty tuple.
The preﬁx order on sequences induces an order on n-tuples for any
ﬁxed n. The order we have in mind is the pointwise order. We say that an
n-tuple s1 is a preﬁx of an n-tuple s2, and we write s1 ⊑s2, if and only
if for any i ∈{0, . . . , n −1}, s1(i) ⊑s2(i). Notice that the n-tuple of
empty sequences, denoted by εn, is a preﬁx of every other n-tuple. The
ordered set ⟨Sn, ⊑⟩is a complete semilattice, where inﬁma and suprema
are calculated pointwise, simply because ⟨S, ⊑⟩is a complete semilattice
itself.
If s1 is a ﬁnite n-tuple and s2 an arbitrary n-tuple, then we write
s1.s2 to denote the pointwise concatenation of s1 and s2. It is the unique
n-tuple s such that for any i ∈{0, . . . , n −1}, s(i) = s1(i).s2(i).
When n = 0, Sn has only one element, the empty tuple ∅. Hence,
it must be the case that ∅.∅= ∅. This is precisely what the pointwise
concatenation evaluates to. Note again that for any ﬁnite s1, s1 ⊑s if
and only if there is some tuple s2 such that s1.s2 = s, in which case,
this tuple s2 is unique.
4.2.4 Kahn processes
Before we can formalize the notion of a process, we must review a
technical condition that we will need to impose.
A function F:Sm →Sn is monotone if and only if for all s1, s2 ∈Sm,
s1 ⊑s2 =⇒F(s1) ⊑F(s2).
Informally, feeding a computing station that realizes a monotone
function with additional input can only cause it to produce additional
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

76
E. A. Lee and E. Matsikoudis
output. This is really a notion of causality, in that “future input concerns
only future output” (see [15]).
A function F:Sm →Sn is Scott-continuous, or simply continuous, if
and only if F is monotone, and for any subset D of Sm that is directed
in ⟨Sm, ⊑⟩,
F(D) = {F(s) | s ∈D}.
Notice here that since F is monotone, the set {F(s) | s ∈D} is itself
directed in ⟨Sn, ⊑⟩, and hence has a least upper bound therein.
In order to better understand the importance of this notion, we must
take notice of the additional structure that our ordered sets have. For
any natural number m, the complete semilattice ⟨Sm, ⊑⟩is algebraic:
for every s ∈Sm,
s = {s′ ⊑s | s′ is ﬁnite}.
The set {s′ ⊑s | s′ is ﬁnite} is of course directed in ⟨Sm, ⊑⟩. Hence,
we can obtain every m-tuple as the least upper bound of a set of ﬁnite
tuples that is directed in ⟨Sm, ⊑⟩. The response of a continuous function
to an input tuple is therefore completely deﬁned by its responses to the
ﬁnite preﬁxes of that tuple. This is really a computability notion, in
that a computing station cannot churn out some output only after it has
received an inﬁnite amount of input.
We remark here that continuity in this context is exactly the
topological notion of continuity in a particular topology, which is called
the Scott topology. In this topology, the set of all tuples with a particular
ﬁnite preﬁx is an open set, and the collection of all these sets is a base
for the topology.
A Kahn process, or just a process, is a continuous function F:Sm →Sn
for some m and n. If m = 0, then we say that F is a source; Sm =
S0 = {∅} has a single member, the empty tuple, and hence F is trivially
constant. If n = 0, then we say that F is a sink. In either case, F is
trivially continuous.
Not every monotone function is continuous, and thus a Kahn process.
For instance, consider a function F:S →S such that for any sequence s,
F(s) =

⟨⟩
if s is ﬁnite;
⟨v⟩
otherwise.
Here v is some arbitrary value. It is easy to verify that F is monotone
but not continuous.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
77
s1
s3
s2
s4
s1
s3
s2
s1
s3
s2
s1
s2
s3
s4
s5
Fig. 4.1. Examples of compositions of processes.
For an example of a continuous function, consider the unit delay
process Dv:S →S, such that for any sequence s,
Dv(s) = ⟨v⟩.s,
(4.1)
where v is an arbitrary but ﬁxed value. The eﬀect of this process is to
output an initial token of value v before starting to churn out the tokens
arriving at its input, in the same order in which they arrive. We will
have more to say about the unit delay below.
4.2.5 Compositions of Kahn processes and determinacy
A ﬁnite composition of Kahn processes is a collection {s1, . . . , sp} of
sequences and a collection {F1, . . . , Fq} of processes relating them,
such that no sequence is the output of more than one process. Any
sequence that is not the output of any of the functions is an input to
the composition.
A composition is determinate if and only if given the input sequences,
all other sequences are uniquely determined. Obviously, a Kahn process
by itself is determinate, since it is a functional mapping from input
sequences to output sequences.
Examples of ﬁnite compositions of Kahn processes are shown in
Figure 4.1. In each of these examples, given the component processes,
it is obvious how to construct a process that maps the input sequences
(those that are not outputs of any process) to the other sequences. Each
of these compositions is thus determinate. Following Broy [5], we can
iteratively compose processes using patterns like those in Figure 4.1 to
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

78
E. A. Lee and E. Matsikoudis
Fig. 4.2. Feedback (a directed self-loop).
argue that arbitrary compositions are determinate. The most challenging
part of this strategy is to handle feedback. (An alternative approach to
this composition problem is given by Stark [27]).
Feedback compositions of Kahn processes may or may not be
determinate. Consider for example the identity function I, such that
for any sequence s, I(s) = s. I is trivially continuous, and thus a Kahn
process. Suppose that we form a very simple composition of the identity
process by feeding back the output to the input, letting F = I in
Figure 4.2. There are no inputs to the composition, which is therefore
determinate if and only if the sequence s is uniquely determined.
However, any sequence s satisﬁes the constraint of the composition, so
it is not uniquely determined.
4.2.6 Least-ﬁxed-point semantics
There is an alternative interpretation due to Kahn [15] that makes
the example in Figure 4.2 determinate. Under this interpretation, any
process composition is determinate. Moreover, this interpretation is
consistent with the execution policies often used for such systems (their
operational semantics), and hence it is an entirely reasonable denota-
tional semantics for the composition. This interpretation is known as
the least-ﬁxed-point semantics, and in particular as the Kahn principle.
The Kahn principle is based on a well-known ﬁxed-point theorem
stating that a continuous function F:X →X on a cpo ⟨X, ⩽⟩has a least
ﬁxed point x in ⟨X, ⩽⟩; that is, there is an x ∈X such that F(x) = x,
and for any other y ∈X for which F(y) = y, x ⩽y. Furthermore, the
theorem is constructive, providing an algorithmic procedure for ﬁnding
the least ﬁxed point: the least ﬁxed point of F is the least upper bound
of all ﬁnite iterations of F starting from the least element in ⟨X, ⩽⟩.
To put it into our context, suppose that F:Sn →Sn is a process, and
consider the following sequence of n-tuples:
s0 = εn, s1 = F(s0), s2 = F(s1), . . . .
(4.2)
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
79
s1
s2
s4
Fig. 4.3. Composition with a source of an inﬁnite sequence.
Since F is monotone, and the tuple of empty sequences εn is a preﬁx
of any other n-tuple, si ⊑sj if and only if i ≤j. Hence, {s0, s1, . . .} is
a chain, and thus directed in ⟨Sn, ⊑⟩, and since the latter is directed-
complete, {s0, s1, . . .} has a least upper bound in ⟨Sn, ⊑⟩. The ﬁxed-
point theorem states that this least upper bound is the least ﬁxed point
of F.
This theorem is quite similar to the well-known Knaster–Tarski ﬁxed-
point theorem, which applies to complete lattices rather than complete
partial orders. For this reason, this approach to semantics is sometimes
called Tarskian. The application of the theorem to programming
language semantics was pioneered by Scott [25]. However, Kahn [15] was
the ﬁrst to recognize its potential in modelling and design of complex
distributed systems.
Under this least-ﬁxed-point principle, the value of s in Figure 4.2 is
uniquely determined as the empty sequence ε when F is the identity
process I. This is consistent with our intuition; the identity process will
not produce an output token, unless there is some input token to cause
it to.
Notice that (4.2) might suggest a reasonable execution policy for
a network: start with every sequence empty, and begin iterating the
evaluation of every process. In the limit, every sequence will converge
to the least ﬁxed point of the composite process, in accordance with the
interpretation suggested by the Kahn principle.
4.2.7 Practical issues
There are serious practical problems with using (4.2) as an execution
policy. If any process in the composition evaluates to an inﬁnite tuple
at some stage of the iteration, then the execution of that process will
never terminate, and thus preclude the progress of the iteration. This
will happen immediately in a composition like the one in Figure 4.3,
where the process F2 is a source of an inﬁnite sequence.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

80
E. A. Lee and E. Matsikoudis
In practice, we need to partially evaluate processes, carefully
controlling the length of each sequence. The problem is addressed
by Parks [23], who devises a general strategy to avoid accumulating
unbounded numbers of unconsumed tokens, whenever it is possible to do
so. All partially evaluated sequences are guaranteed to be preﬁxes of the
sequences corresponding to the denotational semantics of the process
composition (although, as pointed out in [11], there is no assurance of
convergence to those sequences, which may not be desirable anyway).
4.3 Dataﬂow with ﬁring
4.3.1 Dataﬂow actors
We begin with a simple deﬁnition and generalize later. Our ﬁrst attempt
will serve as a gentle introduction, and help motivate the need for the
more general case.
A dataﬂow actor, or simply an actor, with m inputs and n outputs is
a pair ⟨R, f⟩, where
(i) R is a set of ﬁnite m-tuples;
(ii) f:Sm →Sn is a (possibly partial) function deﬁned at least on R;
(iii) f(r) is ﬁnite for every r ∈R;
(iv) for all r, r′ ∈R, if r ̸= r′, then {r, r′} does not have an upper bound
in ⟨Sm, ⊑⟩.
We call each r ∈R a ﬁring rule, and f the ﬁring function of the actor.
The last condition is equivalent to the following statement: for any
given m-tuple s, there is at most one ﬁring rule r in R such that r ⊑s.
We remark here that because ⟨Sm, ⊑⟩is a complete semilattice, r and
r′ have an upper bound in ⟨Sm, ⊑⟩if and only they have a least upper
bound in ⟨Sm, ⊑⟩, or alternatively, if their join r ⊓r′ is deﬁned.
If m = 0, then R is a subset of the singleton set {∅}, and condition (iv)
is trivially satisﬁed. If n = 0, then condition (iii) is trivially satisﬁed.
4.3.2 Dataﬂow processes
Let ⟨R, f⟩be a dataﬂow actor with m inputs and n outputs. We want to
deﬁne a Kahn process F:Sm →Sn based on this actor, and a reasonable
condition to impose is that for any m-tuple s,
F(s) =

f(r).F(s′)
if there exists r ∈R such that s = r.s′;
εn
otherwise.
(4.3)
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
81
Of course, this is not a deﬁnition. It is by no means obvious that such
an F exists, nor that this F is unique, or even a process. Nonetheless, it
is possible to use the least-ﬁxed-point principle to resolve these issues,
and turn (4.3) into a proper deﬁnition. Before we can do this, however,
we will need to review some order-theoretic facts about functions over
tuples of sequences.
For ﬁxed m and n, we write Sm →Sn to denote the set of all functions
from Sm into Sn. The preﬁx order on n-tuples induces a pointwise order
on this set. We shall say that the function F:Sm →Sn is a preﬁx of
the function G:Sm →Sn, and write F ⊑G, if and only if F(s) ⊑
G(s) for any m-tuple s. Notice that the function s &→εn mapping
every m-tuple s to the n-tuple of empty sequences is a preﬁx of any
other function in the set. The ordered set ⟨Sm →Sn, ⊑⟩is a complete
semilattice, simply because ⟨Sn, ⊑⟩is a complete semilattice. For our
purposes here, however, it suﬃces to know that ⟨Sm →Sn, ⊑⟩is a cpo.
Now consider the functional φ:(Sm →Sn) →(Sm →Sn) associated
with the actor ⟨R, f⟩, deﬁned such that for any F ∈Sm →Sn and any
m-tuple s,
φ(F)(s) =

f(r).F(s′)
if there exists r ∈R such that s = r.s′;
εn
otherwise.
(4.4)
Theorem 4.1 φ is monotone.
Proof
Let F1 and F2 be arbitrary functions of type Sm →Sn, and
suppose that F1 ⊑F2.
If there is a ﬁring rule r ∈R such that r ⊑s, then by condition
(iv), r is unique, and hence φ(F1)(s) = f(r).F1(s′) and φ(F2)(s) =
f(r).F2(s′), where s = r.s′. However, by assumption, F1(s′) ⊑F2(s′)
for any m-tuple s′, and hence φ(F1)(s) ⊑φ(F2)(s).
Otherwise, φ(F1)(s) = εn = φ(F2)(s).
In either case, φ(F1)(s) ⊑φ(F2)(s), and hence φ is monotone.
Since φ is a monotone function over the cpo ⟨Sm →Sn, ⊑⟩, it has a
least ﬁxed point F in ⟨Sm →Sn, ⊑⟩[9], which must satisfy (4.3). This is
reassuring, but we can actually go a step further, and give a constructive
procedure for ﬁnding that least ﬁxed point.
Theorem 4.2 φ is continuous.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

82
E. A. Lee and E. Matsikoudis
Proof
Let D ⊆Sm →Sn be directed in ⟨Sm →Sn, ⊑⟩, and s an
arbitrary m-tuple.
If there is a ﬁring rule r ∈R such that r ⊑s, then by condition (iv),
r is unique, and hence for every F ∈Sm →Sn, φ(F)(s) = f(r).F(s′),
where s = r.s′. Thus,
{φ(F)(s) | F ∈D} = {f(r).F(s′) | F ∈D}
= f(r).{F(s′) | F ∈D}
= f(r).(D)(s′)
= φ(D)(s).
Notice that since D is directed in ⟨Sm →Sn, ⊑⟩, it has a least upper
bound therein, ⟨Sm →Sn, ⊑⟩being a cpo.
Otherwise, for every F ∈Sm →Sn, φ(F)(s) = εn, and hence
{φ(F)(s) | F ∈D} = εn = φ(D)(s).
In either case,
{φ(F)(s) | F ∈D} = φ(D)(s),
and hence φ is continuous.
Since φ is continuous, not only does it have a least ﬁxed point, but
there is a constructive procedure for ﬁnding that least ﬁxed point [9]. We
can start with the least element in ⟨Sm →Sn, ⊑⟩, the function s &→εn
mapping every m-tuple s to the empty sequence, and iterate φ to obtain
the following sequence of functions:
F0 = s &→εn, F1 = φ(F1), F2 = φ(F1), . . . .
(4.5)
Since φ is monotone, and s &→εn is a sequence of every other function,
the set {F0, F1, . . .} is a chain, and hence directed in ⟨Sm →Sn, ⊑⟩.
Thus, it has a least upper bound therein, which is the least ﬁxed point
of φ.
Let us examine this chain more closely for some ﬁxed m-tuple s.
Suppose that there is some sequence of ﬁring rules ⟨r1, r2, . . .⟩such that
s = r1.r2. . . .. Then, for this particular m-tuple, we can rewrite (4.5) in
the following form:
F0(s) = εn
F1(s) = f(r1)
F2(s) = f(r1).f(r2)
. . .
(4.6)
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
83
This is an exact description of the operational semantics in Dennis
dataﬂow, with respect to a single actor. Start with the actor producing
only the empty sequence. Then ﬁnd the preﬁx of the input that matches
a ﬁring rule, and invoke the ﬁring function on that preﬁx, producing a
partial output. Notice here that because of condition (iv), no more than
one ﬁring rule can match a preﬁx of the input at any time. Then ﬁnd the
preﬁx of the remaining input that matches another ﬁring rule, invoke
the ﬁring function on that preﬁx, and concatenate the result with the
output.
In general, even when s is inﬁnite, it is possible that there is only a
ﬁnite sequence of ﬁring rules ⟨r0, . . . , rp⟩such that s = r0. . . . .rp.s′,
with s′ having no preﬁx in R. In both the operational semantics of
Dennis dataﬂow and the denotational interpretation of (4.6), the ﬁrings
simply stop, and the output is ﬁnite.
When m = 0, the least ﬁxed point of φ is a source process, and if
∅∈R, then it produces the sequence f(∅).f(∅). · · · . If f(∅) is non-
empty, then this is inﬁnite and periodic. This might seem limiting for
dataﬂow processes that act as sources, but in fact it is not; a source
with a more complicated output sequence can be constructed using a
feedback composition, as in Figure 4.2.
When n = 0, the least ﬁxed point of φ is a sink process, producing
the sequence ∅.∅. · · · = ∅.
In view of this perfect coincidence with the operational semantics,
we are tempted to deﬁne a Kahn process based on the actor ⟨R, f⟩as
this least ﬁxed point of φ. In order to do this, however, we still need to
prove that in the general case, this least ﬁxed point of φ is actually a
continuous function, and thus a Kahn process. It suﬃces to prove the
following theorem.
Theorem 4.3 For any F:Sm →Sn, if F is continuous, then φ(F) is
also continuous.
Proof Let F:Sm →Sn be a continuous function, and D ⊆Sm directed
in ⟨Sm, ⊑⟩.
Suppose, toward contradiction, that there are r1, r2 ∈R and s1, s2 ∈
D such that r1 ̸= r2, but r1 ⊑s1 and r2 ⊑s2. Then since D is directed
in ⟨Sm, ⊑⟩, {s1, s2} has an upper bound in D, which is also an upper
bound of {r1, r2}, in contradiction to (iv).
Therefore, there is at most one r ∈R that is a preﬁx of some tuple
in D.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

84
E. A. Lee and E. Matsikoudis
If there is such an r ∈R, then
{φ(F)(s) | s ∈D} = {f(r).F(s′) | r.s′ ∈D}
= f(r).{F(s′) | r.s′ ∈D}
= f(r).F({s′ | r.s′ ∈D})
= φ(F)(D).
Notice that since D is directed in ⟨Sm, ⊑⟩, {s′ | r.s′ ∈D} is also directed
in ⟨Sm, ⊑⟩, and in particular, r.{s′ | r.s′ ∈D} = D.
Otherwise, there is no ﬁring rule in R that is a preﬁx of some tuple
in D, and hence
{φ(F)(s) | s ∈D} = εn = φ(F)(D).
In either case,
{φ(F)(s) | s ∈D} = φ(F)(D),
and hence φ(F) is continuous.
Since s &→εn is trivially continuous, and continuous functions are
closed under pointwise suprema [9], an easy induction suﬃces to see that
the least ﬁxed point of φ is a continuous function. Note here that the
ﬁring function f need not be continuous. In fact, it does not even need to
be monotone. The continuity of the least ﬁxed point of φ is guaranteed if
⟨R, f⟩is a valid actor description according to conditions (i) through (iv).
4.3.3 Examples of ﬁring rules
Consider a system where the set of token values is V = {0, 1}. Let us
examine some possible sets R ⊂S of ﬁring rules for unary ﬁring functions
f:S →S.
The following sets of ﬁring rules all satisfy condition (iv) above:
{⟨⟩};
{⟨0⟩};
{⟨0⟩, ⟨1⟩};
{⟨0, 0⟩, ⟨0, 1⟩, ⟨1, 0⟩, ⟨1, 1⟩}.
(4.7)
The ﬁrst of these corresponds to a function that consumes no tokens
from its input sequence, and can ﬁre inﬁnitely regardless of the length of
the input sequence. The second consumes only the leading zeros from the
input sequence, and then stops ﬁring. The third consumes one token from
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
85
the input on every ﬁring, regardless of its value. The fourth consumes
two tokens on the input on every ﬁring, again regardless of the values.
An example of a set of ﬁring rules that does not satisfy condition (iv) is:
{⟨⟩, ⟨0⟩, ⟨1⟩}.
(4.8)
Such ﬁring rules would correspond to an actor that could non-
deterministically consume or not consume an input token upon ﬁring.
The ﬁring rules in (4.8) would also correspond to the ﬁring rules of
the unit delay deﬁned in (4.1), so such a process cannot be a dataﬂow
actor under this deﬁnition. In fact, delays in dataﬂow actor networks
are usually implemented directly as initial tokens on an arc. Thus, if
we admit such an implementation, then there is no loss of generality
here. The implementation cost is lower, and this strategy avoids having
to have special ﬁring rules for delays that, if allowed in general, could
introduce non-determinism. Furthermore, once we admit this sort of
implementation for the unit delay, it is easy to model arbitrary actors
with state using a single self-loop initialized to their initial state.
Let us examine now some possible sets R ⊂S2 of ﬁring rules for
binary ﬁring functions f:S2 →S.
The following sets of ﬁring rules all satisfy condition (iv):
{⟨⟨0⟩, ⟨0⟩⟩, ⟨⟨0⟩, ⟨1⟩⟩, ⟨⟨1⟩, ⟨0⟩⟩, ⟨⟨1⟩, ⟨1⟩⟩};
{⟨⟨0⟩, ⟨⟩⟩, ⟨⟨1⟩, ⟨0⟩⟩, ⟨⟨1⟩, ⟨1⟩⟩};
{⟨⟨0⟩, ⟨⟩⟩, ⟨⟨1⟩, ⟨⟩⟩}.
(4.9)
The ﬁrst of these corresponds to an actor that consumes one input
token from each of its inputs. For example, this could implement a logic
function such as AND or OR. The second corresponds to a conditional
actor, where the ﬁrst input provides a control token on every ﬁring.
If the control token has value ‘1’, then a token is consumed from the
second input. Otherwise, no token is consumed from the second input.
The third corresponds to an actor that has eﬀectively one input, never
consuming a token from the second input.
The following set of ﬁring rules does not satisfy condition (iv):
{⟨⟨0⟩, ⟨⟩⟩, ⟨⟨1⟩, ⟨⟩⟩, ⟨⟨⟩, ⟨0⟩⟩, ⟨⟨⟩, ⟨1⟩⟩}.
(4.10)
These would be the ﬁring rules of a non-determinate merge, a process
that can consume a token on either input and copy it to its output. The
non-determinate merge is not a monotone process, and so use of it in a
Kahn process network could result in non-determinism.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

86
E. A. Lee and E. Matsikoudis
Fig. 4.4. If F is an identity process, the appropriate ﬁring rules are (4.10).
It is interesting to notice that the sets of ﬁring rules of (4.7) and
(4.9) can all be implemented in a blocking-read fashion, according to
the Kahn–MacQueen implementation of Kahn process networks [16]. An
example of a process that cannot be implemented using blocking reads
has the ﬁring rules:
{⟨⟨1⟩, ⟨0⟩, ⟨⟩⟩, ⟨⟨0⟩, ⟨⟩, ⟨1⟩⟩, ⟨⟨⟩, ⟨0⟩, ⟨1⟩⟩}.
(4.11)
These ﬁring rules satisfy (iv) and correspond to the Gustave function
[3], a function deﬁning a process which is stable, but not sequential as
the other examples.
While actors that satisfy conditions (i) through (iv) above yield
continuous Kahn processes, these conditions are somewhat more
restrictive than what is really necessary. The ﬁring rules in (4.10), for
example, are not only the ﬁring rules for the dangerous non-determinate
merge, but also the ﬁring rules for a perfectly harmless two-input,
two-output identity process. At ﬁrst glance, it might seem that this sort
of identity process could be implemented using the ﬁrst set of ﬁring
rules of (4.9), though this will not work. The two examples in Figure 4.4
show why not. In the ﬁrst example, the ﬁrst (top) input and output
should be the empty sequence under the least-ﬁxed-point semantics,
so there will never be a token to trigger any ﬁring rule of (4.9). In
the second of these examples, the second (bottom) input and output
present the same problem. The ﬁring rules of (4.10), however, have no
diﬃculty with these cases. We next replace condition (iv) with a more
general rule that solves such problems.
4.3.4 Commutative ﬁrings
Many dataﬂow models having a notion of ﬁring are not compositional.
These compositionality issues are discussed in a very general framework
by Talcott [29]. In our context, the problem is simply that an aggregation
of actors that can be individually described using ﬁring rules and ﬁring
functions cannot be collectively described in this way. This problem was
alluded to in the ﬁnal example of the last sub-section, which is the
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
87
Fig. 4.5. A two-input, two-output identity process described as an aggregation
of two one-input one-output identity processes.
simplest example illustrating the problem. It is possible to think of a two-
input, two-output identity process as an aggregation of two one-input,
one-output identity processes, as in Figure 4.5. One-input, one-output
identity processes are trivially described as actors that satisfy conditions
(i) through (iv), but a two-input, two-output identity process cannot be
so described.
In order to solve this problem, we replace condition (iv) with the
following more elaborate condition:
(iv′) for all r, r′ ∈R, if r ̸= r′ and {r, r′} has an upper bound in
⟨Sm, ⊑⟩, then f(r).f(r′) = f(r′).f(r) and r ⊓r′ = εm.
This condition states that if any two ﬁring rules are consistent, namely
they have a common upper bound, and therefore can possibly be enabled
at the same time, then it makes no diﬀerence in what order we use these
ﬁring rules; the values of the ﬁring function at these consistent rules
commute with respect to the concatenation operator. Furthermore, any
two consistent ﬁring rules have no common preﬁx other than the m-tuple
of empty sequences.
It is easy to see that when condition (iv′) is satisﬁed,
r ⊔r′ = r.r′ = r′.r;
(4.12)
that is, the least common extension (least upper bound) of any two
consistent ﬁring rules is their concatenation, in either order.
We also need to reconstruct the functional that we used to deﬁne the
Kahn process. For convenience, let PR(s) denote the set {r ∈R | r ⊑s}.
This is a possibly empty ﬁnite set. The functional φ′ is deﬁned such that
for any function F:Sm →Sn and any m-tuple s,
φ′(F)(s) =

f(r1). · · · .f(rp).F(s′)
if PR(s) ̸= ∅and {r1, . . . , rp} = PR(s);
εn
otherwise.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

88
E. A. Lee and E. Matsikoudis
Fig. 4.6. A composition that is invalid under condition (iv), but not under
condition (iv′).
Here, we assume, as before, that s = r1. . . . .rp.s′. Notice that because
of (4.12), for any permutation π on {1, . . . , p},
r1. . . . .rp = rπ(1). . . . .rπ(p),
and similarly, because of condition (iv′),
f(r1). · · · .f(rp) = f(rπ(1)). · · · .f(rπ(p)).
Therefore, it makes no diﬀerence in what order we invoke the enabled
ﬁring rules. As before, we deﬁne the Kahn process F corresponding to
the dataﬂow actor ⟨R, f⟩to be the least ﬁxed point of the functional φ′.
Although notationally tedious, it is straightforward to extend the
results on φ to conclude that both the functional φ′ and its least ﬁxed
point F are continuous; the proofs are practically identical.
Going back to the example of Figure 4.5, we see that we can use the
ﬁring rules of (4.10), and a ﬁring function f:S2 →S2 such that for any
ﬁring rule r, f(r) = r, to obtain a dataﬂow actor for the two-input,
two-output identity process that is valid under condition (iv′). More
interestingly, we can use the same ﬁring rules to implement a process
with ﬁring function f:S2 →S such that for each ﬁring rule r,
f(r) =

⟨1⟩
if r = ⟨⟨1⟩, ⟨⟩⟩or r = ⟨⟨⟩, ⟨1⟩⟩;
⟨⟩
otherwise.
This process is interesting because it is neither sequential nor stable,
and thus cannot be implemented under condition (iv).
As a ﬁnal example, consider the composition of Figure 4.6. The top
process is an identity process, and the bottom one a source of the inﬁnite
sequence ⟨0, 0, . . .⟩. A reasonable ﬁring function for the source process
would be the function ∅&→⟨0⟩. The question now is how to deﬁne the
ﬁring rules R and ﬁring function f of the composition.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
89
A ﬁrst, naive attempt would be to let R = {⟨0⟩, ⟨1⟩}. However, with
the feedback arc in Figure 4.6, this results in no ﬁring rule ever becoming
enabled. Instead, we need R = {⟨0⟩, ⟨1⟩, ⟨⟩}, which violates condition
(iv). However, if we deﬁne the ﬁring function such that
f(⟨0⟩) = ⟨⟨0⟩, ⟨⟩⟩,
f(⟨1⟩) = ⟨⟨1⟩, ⟨⟩⟩, and
f(⟨⟩) = ⟨⟨⟩, ⟨0⟩⟩,
then condition (iv′) is satisﬁed and the composition behaves as an
aggregate of its parts.
4.3.5 Compositionality
The examples of Figure 4.5 and 4.6 indicate certain compositionality
issues that can be successfully resolved using the notion of commutative
ﬁrings. We can generalize this to every composition of the same type.
Consider a slight generalization of Figure 4.1(a), where s1 is an m-
tuple, s2 is an n-tuple, s3 is a p-tuple, and s4 is a q-tuple. It is possible
to prove that the aggregation of F1 and F2 is compositional, in the
sense that it can always be described as a set of ﬁring rules and a ﬁring
function.
Assume for simplicity that m > 0 and p > 0 (generalizing to allow
zero values is easy), and suppose that F1 is deﬁned by ⟨R1, f1⟩and F2
by ⟨R2, f2⟩. Let
R′
1 = {r1 × εp | r1 ∈R1}
and
R′
2 = {εm × r2 | r2 ∈R2},
where we loosely write r1 ×εp to denote the unique (m+p)-tuple s that
has s(i) = r1(i) if i < m, and s(i) = εp(i−m) otherwise, etc. The set R
of ﬁring rules for the composite process F:Sm+p →Sn+q is deﬁned by
R = R′
1 ∪R′
2.
The ﬁring function f:Sm+p →Sn+q of the composite process is deﬁned
such that for any ﬁnite (m + p)-tuple r,
f(r) =







f1(r1) × εq
if r ∈R′
1 and r = r1 × εp;
εn × f2(r2)
if r ∈R′
2 and r = εm × r2;
εn+q
otherwise.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

90
E. A. Lee and E. Matsikoudis
Fig. 4.7. An example of a process network where it might be undesirable from
a practical perspective to insist that the operational semantics coincide with
the denotational semantics.
It is now straightforward to verify that if ⟨R1, f2⟩and ⟨R2, f2⟩both
satisfy condition (iv′), then so does ⟨R, f⟩.
4.3.6 Practical issues
The constructive procedure given by (4.6) ensures that repeated ﬁrings
converge to the appropriate Kahn process deﬁned by the actor. If any
such sequence of ﬁrings is ﬁnite, then it is only necessary to invoke a ﬁnite
number of ﬁrings. In practice, it is common for such ﬁring sequences to
be inﬁnite, in which case a practical issue of fairness arises. In particular,
since there are usually many actors in a system, in order to have the
operational semantics coincide with the denotational semantics, it is
necessary to ﬁre each actor inﬁnitely often, if possible.
It turns out that such a fairness condition is not always desirable.
It may result in unbounded memory requirements for execution of a
dataﬂow process network. In some such cases, there is an alternative
ﬁring schedule that is also inﬁnite, but requires only bounded memory.
That schedule may not conform to the denotational semantics, and
nonetheless be preferable to one that does.
A simple example is shown in Figure 4.7. The actor labeled ‘SELECT’
has the following set of ﬁring rules:
{⟨⟨1⟩, ⟨⟩, ⟨1⟩⟩, ⟨⟨0⟩, ⟨⟩, ⟨1⟩⟩, ⟨⟨⟩, ⟨1⟩, ⟨0⟩⟩, ⟨⟨⟩, ⟨0⟩, ⟨0⟩⟩},
where the order of inputs is top-to-bottom. If the bottom input (the
control input) has value ‘1’ (for TRUE), then a token of any value is
consumed from the top input, and no token is consumed from the middle
input. If the control input has value ‘0’ (for FALSE), then a token of
any value is consumed from the middle input, and no token is consumed
from the top input.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
91
Suppose that the actors A, B, and D, all of which are sources, are
deﬁned to each produce an inﬁnite sequence, and that C, which is a
sink, is deﬁned to consume an inﬁnite sequence. Suppose further that the
output from D is the constant sequence ⟨0, 0, . . .⟩. Then tokens produced
by actor A will never be consumed. In most practical scenarios, it is
preferable to avoid producing them if they will never be consumed,
despite the fact that this violates the denotational semantics, which state
that the output of actor A is an inﬁnite sequence. This problem is solved
by Parks [23], who also shows that the obvious solution for the example
in Figure 4.7, the demand-driven execution, does not solve the problem
in general. Another, more specialized solution, achieved by restricting
the semantics, is presented by Caspi in [7].
4.4 Conclusion
We have shown how the formal semantic methods of Kahn dataﬂow
can be adapted to Dennis dataﬂow, which is based on the notion of an
actor ﬁring. Kahn dataﬂow is deﬁned in terms of continuous processes,
which map input sequences to output sequences, while Dennis dataﬂow
is deﬁned in terms of ﬁring functions, which map input tokens to output
tokens, and are evaluated only when input tokens satisfy certain ﬁring
rules. We have formally deﬁned ﬁring rules and ﬁring functions, and
have shown how a Kahn process can be deﬁned as the least ﬁxed point
of a continuous functional that is constructed using the ﬁring rules and
ﬁring function of an actor. Furthermore, we have speciﬁed conditions on
the ﬁring rules and ﬁring functions that solve certain compositionality
problems in dataﬂow, in the sense that certain compositions of actors
are actors themselves.
Bibliography
[1]
Arvind, L. Bic and T. Ungerer. Evolution of data-ﬂow computers. In J.-
L. Gaudiot and L. Bic (eds), Advanced Topics in Data-Flow Computing.
Prentice-Hall, 1991.
[2]
A. Benveniste, P. Caspi, P. L. Guernic and N. Halbwachs. Data-
ﬂow synchronous languages. In J. W. d. Bakker, W.-P. d. Roever and
G.
Rozenberg,
(eds),
A
Decade
of
Concurrency
–
Reﬂections
and
Perspectives, Volume 803 Lecture Notes in Computer Science, pp. 1–45.
Springer-Verlag, 1994.
[3]
G. Berry. Bottom-up computation of recursive programs. Revue Fran¸caise
d’Automatique, Informatique et Recherche Op´erationnelle, 10(3):47–82,
1976.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

92
E. A. Lee and E. Matsikoudis
[4]
J. D. Brock and W. B. Ackerman. Scenarios, a model of non-determinate
computation.
In
Conference
on
Formal
Deﬁnition
of
Programming
Concepts, volume 107, Lecture Notes in Computer Science, pp. 252–259.
Springer-Verlag, 1981.
[5]
M.
Broy.
Functional
speciﬁcation
of
time-sensitive
communicating
systems. ACM Transactions on Software Engineering and Methodology,
2(1):1–46, 1993.
[6]
M. Broy and G. Stefanescu. The algebra of stream processing functions.
Theoretical Computer Science, 258:99–129, 2001.
[7]
P. Caspi. Clocks in dataﬂow languages. Theoretical Computer Science,
94(1), 1992.
[8]
M. Creeger. Multicore CPUs for the masses. ACM Queue, 3(7):63–64,
2005.
[9]
B. A. Davey and H. A. Priestley. Introduction to Lattices and Order.
Cambridge University Press, 1990.
[10]
J. B. Dennis. First Version Data Flow Procedure Language. Technical
Report MAC TM61, MIT Laboratory for Computer Science, 1974.
[11]
M. Geilen and T. Basten. Requirements on the execution of Kahn
process networks. In European Symposium on Programming Languages and
Systems, Lecture Notes in Computer Science, pp. 319–334, Springer, 2003.
[12]
C.-J. Hsu, F. Keceli, M.-Y. Ko, S. Shahparnia and S. S. Bhattacharyya.
DIF: An interchange format for dataﬂow-based design tools. In International
Workshop on Systems, Architectures, Modeling, and Simulation, Samos,
Greece, July 2004.
[13]
A. Jantsch and I. Sander. Models of computation and languages for
embedded system design. IEE Proceedings on Computers and Digital
Techniques, 152(2):114–129, 2005.
[14]
W. M. Johnston, J. R. P. Hanna and R. J. Millar. Advances in dataﬂow
programming languages. ACM Computing Surveys, 36(1):1–34, 2004.
[15]
G. Kahn. The semantics of a simple language for parallel programming.
In Proc. of the IFIP Congress 74. North-Holland Publishing Co., 1974.
[16]
G. Kahn and D. B. MacQueen. Coroutines and networks of parallel
processes. In B. Gilchrist (ed.), Information Processing, pages 993–998.
North-Holland Publishing Co., 1977.
[17]
D. Lazaro Cuadrado, A. P. Ravn and P. Koch. Automated distributed
simulation in Ptolemy II. In Parallel and Distributed Computing and
Networks (PDCN). Acta Press, 2007.
[18]
E. A. Lee and T. M. Parks. Dataﬂow process networks. Proceedings of
the IEEE, 83(5):773–801, 1995.
[19]
Y. Lin, R. Mullenix, M. Woh, S. Mahlke, T. Mudge, A. Reid and
K. Flautner. SPEX: A programming language for software deﬁned radio.
In Software Deﬁned Radio Technical Conference and Product Exposition,
Orlando, 2006.
[20]
S. G. Matthews. An extensional treatment of lazy data ﬂow deadlock.
Theoretical Computer Science, 151(1):195–205, 1995.
[21]
A. G. Olson and B. L. Evans. Deadlock detection for distributed process
networks. In ICASSP, 2005.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

The semantics of dataﬂow with ﬁring
93
[22]
O. M. G. (OMG). A UML proﬁle for MARTE, beta 1. OMG Adopted
Speciﬁcation ptc/07–08–04, August 2007.
[23]
T. M.
Parks.
Bounded
Scheduling
of
Process
Networks.
PhD, UC Berkeley, 1995.
[24]
T. M. Parks and D. Roberts. Distributed process networks in Java. In
International Parallel and Distributed Processing Symposium, Nice, France,
April 2003.
[25]
D. Scott. Outline of a mathematical theory of computation. In 4th
Annual Princeton Conference on Information Sciences and Systems, pp.
169–176, 1970.
[26]
V. Srini. An architectural comparison of dataﬂow systems. Computer,
19(3), 1986.
[27]
E. W.
Stark.
An
algebra
of
dataﬂow
networks.
Fundamenta
Informaticae, 22(1-2):167–185, 1995.
[28]
R. Stephens. A survey of stream processing. Acta Informatica, 34(7),
1997.
[29]
C. L. Talcott. Interaction semantics for components of distributed
systems. In Formal Methods for Open Object-Based Distributed Systems
(FMOODS), 1996.
[30]
W. Thies, M. Karczmarek and S. Amarasinghe. StreamIt: A language
for streaming applications. In 11th International Conference on Compiler
Construction, volume 2304, Lecture Notes in Computer Science, Grenoble,
France, 2002, Springer-Verlag.
[31]
W. Thies, M. Karczmarek, J. Sermulins, R. Rabbah and S. Amarasinghe.
Teleport messaging for distributed stream programs. In PPoPP, Chicago,
Illinois, USA, 2005. ACM.
[32]
A. Turjan,
B. Kienhuis and E. Deprettere.
Solving out-of-order
communication
in
Kahn
process
networks.
Journal on VLSI Signal
Processing-Systems for Signal, Image, and Video Technology, 2003.
https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

https://doi.org/10.1017/CBO9780511770524.005 Published online by Cambridge University Press

