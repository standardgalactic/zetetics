
ISOSURFACES

This page intentionally left blank
This page intentionally left blank

ISOSURFACES
GEOMETRY, TOPOLOGY,
AND ALGORITHMS
REPHAEL WENGER

CRC Press
Taylor & Francis Group
6000 Broken Sound Parkway NW, Suite 300
Boca Raton, FL 33487-2742
© 2013 by Taylor & Francis Group, LLC
CRC Press is an imprint of Taylor & Francis Group, an Informa business
No claim to original U.S. Government works
Version Date: 20121214
International Standard Book Number-13: 978-1-4665-7102-0 (eBook - PDF)
This book contains information obtained from authentic and highly regarded sources. Reasonable efforts have been made to publish reliable data and information, but 
the author and publisher cannot assume responsibility for the validity of all materials or the consequences of their use. The authors and publishers have attempted to 
trace the copyright holders of all material reproduced in this publication and apologize to copyright holders if permission to publish in this form has not been obtained. 
If any copyright material has not been acknowledged please write and let us know so we may rectify in any future reprint.
Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or utilized in any form by any electronic, mechanical, 
or other means, now known or hereafter invented, including photocopying, microfilming, and recording, or in any information storage or retrieval system, without 
written permission from the publishers.
For permission to photocopy or use material electronically from this work, please access www.copyright.com (http://www.copyright.com/) or contact the Copyright 
Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 978-750-8400. CCC is a not-for-profit organization that provides licenses and registration for a 
variety of users. For organizations that have been granted a photocopy license by the CCC, a separate system of payment has been arranged.
Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for identification and explanation without intent to 
infringe.
Visit the Taylor & Francis Web site at
http://www.taylorandfrancis.com
and the CRC Press Web site at
http://www.crcpress.com

To my wife, Shifra,
for her love, companionship, and support.

This page intentionally left blank
This page intentionally left blank

CONTENTS
Preface
xi
Acknowledgments
xiii
1
Introduction
1
1.1
What Are Isosurfaces? . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Applications of Isosurfaces . . . . . . . . . . . . . . . . . . . . .
3
1.3
Isosurface Properties . . . . . . . . . . . . . . . . . . . . . . . .
4
1.4
Isosurface Construction
. . . . . . . . . . . . . . . . . . . . . .
6
1.5
Limitations of Isosurfaces
. . . . . . . . . . . . . . . . . . . . .
7
1.6
Multivalued Functions and Vector Fields . . . . . . . . . . . . .
8
1.7
Deﬁnitions and Basic Techniques . . . . . . . . . . . . . . . . .
9
2
Marching Cubes and Variants
17
2.1
Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
2.2
Marching Squares . . . . . . . . . . . . . . . . . . . . . . . . . .
18
2.3
Marching Cubes
. . . . . . . . . . . . . . . . . . . . . . . . . .
30
2.4
Marching Tetrahedra . . . . . . . . . . . . . . . . . . . . . . . .
45
2.5
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
52
3
Dual Contouring
55
3.1
Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
3.2
Surface Nets . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.3
Dual Marching Cubes
. . . . . . . . . . . . . . . . . . . . . . .
75
3.4
Comparison of Algorithms . . . . . . . . . . . . . . . . . . . . .
90
3.5
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
93
4
Multilinear Interpolation
97
4.1
Bilinear Interpolation: 2D . . . . . . . . . . . . . . . . . . . . .
98
4.2
The Asymptotic Decider: 3D . . . . . . . . . . . . . . . . . . .
102
4.3
Trilinear Interpolation . . . . . . . . . . . . . . . . . . . . . . .
110
4.4
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
113
vii

viii
CONTENTS
5
Isosurface Patch Construction
115
5.1
Deﬁnitions and Notation . . . . . . . . . . . . . . . . . . . . . .
116
5.2
Isosurface Patch Construction . . . . . . . . . . . . . . . . . . .
118
5.3
Isosurface Table Construction . . . . . . . . . . . . . . . . . . .
122
5.4
Marching Polyhedra Algorithm . . . . . . . . . . . . . . . . . .
123
5.5
Isohull . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
5.6
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
159
6
Isosurface Generation in 4D
161
6.1
Deﬁnitions and Notation . . . . . . . . . . . . . . . . . . . . . .
162
6.2
Isosurface Table Generation in 4D
. . . . . . . . . . . . . . . .
164
6.3
Marching Hypercubes
. . . . . . . . . . . . . . . . . . . . . . .
171
6.4
Marching Simplices . . . . . . . . . . . . . . . . . . . . . . . . .
190
6.5
Marching Polytopes
. . . . . . . . . . . . . . . . . . . . . . . .
198
6.6
IsoHull4D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
203
6.7
4D Surface Nets
. . . . . . . . . . . . . . . . . . . . . . . . . .
206
6.8
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
208
7
Interval Volumes
209
7.1
Deﬁnitions and Notation . . . . . . . . . . . . . . . . . . . . . .
210
7.2
MCVol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
211
7.3
Automatic Table Generation
. . . . . . . . . . . . . . . . . . .
214
7.4
MCVol Interval Volume Properties . . . . . . . . . . . . . . . .
219
7.5
Tetrahedral Meshes . . . . . . . . . . . . . . . . . . . . . . . . .
232
7.6
Convex Polyhedral Meshes . . . . . . . . . . . . . . . . . . . . .
235
7.7
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
238
8
Data Structures
239
8.1
Uniform Grid Partitions . . . . . . . . . . . . . . . . . . . . . .
241
8.2
Octrees
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
242
8.3
Span Space Priority Trees . . . . . . . . . . . . . . . . . . . . .
253
8.4
Seed Sets
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
264
8.5
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
278
9
Multiresolution Tetrahedral Meshes
281
9.1
Bisection of Tetrahedra
. . . . . . . . . . . . . . . . . . . . . .
282
9.2
Multiresolution Isosurfaces . . . . . . . . . . . . . . . . . . . . .
292
9.3
Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
315
10 Multiresolution Polyhedral Meshes
317
10.1 Multiresolution Convex Polyhedral Mesh . . . . . . . . . . . . .
318
10.2 Multiresolution Surface Nets
. . . . . . . . . . . . . . . . . . .
334
10.3 Multiresolution in 4D
. . . . . . . . . . . . . . . . . . . . . . .
339
10.4 Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
352

CONTENTS
ix
11 Isovalues
355
11.1 Counting Grid Vertices . . . . . . . . . . . . . . . . . . . . . . .
357
11.2 Counting Grid Edges and Grid Cubes
. . . . . . . . . . . . . .
363
11.3 Measuring Gradients . . . . . . . . . . . . . . . . . . . . . . . .
369
11.4 Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
376
12 Contour Trees
379
12.1 Examples of Contour Trees
. . . . . . . . . . . . . . . . . . . .
379
12.2 Deﬁnition of Contour Tree . . . . . . . . . . . . . . . . . . . . .
383
12.3 Join, Split, and Merge Trees . . . . . . . . . . . . . . . . . . . .
389
12.4 Constructing Join, Split, and Merge Trees . . . . . . . . . . . .
394
12.5 Constructing Contour Trees . . . . . . . . . . . . . . . . . . . .
400
12.6 Theory and Proofs . . . . . . . . . . . . . . . . . . . . . . . . .
407
12.7 Simpliﬁcation of Contour Trees . . . . . . . . . . . . . . . . . .
416
12.8 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
418
12.9 Notes and Comments . . . . . . . . . . . . . . . . . . . . . . . .
420
A
Geometry
423
A.1 Aﬃne Hull
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
423
A.2 Convexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
423
A.3 Convex Polytope . . . . . . . . . . . . . . . . . . . . . . . . . .
424
A.4 Simplex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
425
A.5 Barycentric Coordinates . . . . . . . . . . . . . . . . . . . . . .
425
A.6 Linear Function . . . . . . . . . . . . . . . . . . . . . . . . . . .
426
A.7 Congruent and Similar . . . . . . . . . . . . . . . . . . . . . . .
426
B
Topology
427
B.1
Interiors and Boundaries . . . . . . . . . . . . . . . . . . . . . .
427
B.2
Homeomorphism . . . . . . . . . . . . . . . . . . . . . . . . . .
428
B.3
Manifolds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
429
B.4
Triangulations
. . . . . . . . . . . . . . . . . . . . . . . . . . .
430
B.5
Convex Polytopal Meshes . . . . . . . . . . . . . . . . . . . . .
430
B.6
Orientation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
431
B.7
Piecewise Linear Functions
. . . . . . . . . . . . . . . . . . . .
432
B.8
Paths and Loops . . . . . . . . . . . . . . . . . . . . . . . . . .
433
B.9
Separation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
434
B.10 Compact . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
434
B.11 Connected . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
435
B.12 Homotopy Map . . . . . . . . . . . . . . . . . . . . . . . . . . .
438
B.13 Embeddings . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
439
C Graph Theory
445

x
CONTENTS
D Notation
447
Greek Letters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
447
Roman Letters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
448
Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
452
Bibliography
453
Index
469

PREFACE
Ever since Lorensen and Cline published their 1987 paper on the Marching
Cubes algorithm, isosurfaces have been a standard technique for visualization
of three-dimensional volumetric data. Nevertheless, there is no book speciﬁcally
devoted to isosurfaces. Part of this is because of the elegance and simplicity of
the Marching Cubes algorithm, which can easily be described in a few pages.
Yet, extensive work has been done since 1987 on extensions and variations of the
Marching Cubes algorithm, on other algorithms for isosurface construction,
on isosurface simpliﬁcation, and on isosurface topology.
This book is my attempt to give a clear presentation of the basic algorithms
for isosurface construction. It is also an attempt at a more rigorous, mathemat-
ical perspective for some of the algorithms and results. My targeted audience
is designers of visualization software who would like an organized overview of
the various algorithms associated with isosurfaces; graduate students pursuing
research in visualization who need a solid introduction to research in the areas;
and visualization researchers for whom this can serve as a reference for the vast
amount of literature on isosurfaces.
The mathematical proofs in this book are more rigorous and challenging than
one might see in a typical graphics or visualization text. Despite the many read-
ers who will skip the proofs, I have included them because they are “guarantors”
of the correctness of the claims about the various algorithms. Starting with the
paper by Lorensen and Cline, numerous papers on isosurfaces contain erroneous,
obscure, or unsubstantiated claims. The proofs in this book are an attempt to
remedy this deﬁciency. I have tried to place the proofs in separate sections so
that readers who wish to avoid them can easily do so.
Of course, it is possible (and probable) that some of the claims and/or proofs
in this book are incorrect. Providing the proofs will hopefully help others uncover
and correct any erroneous claims.
Because some readers will be interested only in a subset of the topics in this
book, I have tried to make the chapters as self-contained as possible. Unfortu-
nately, this resulted in some redundancy in the text, for which I apologize.
Everyone should read Chapters 1 and 2, the introduction and the Marching
Cubes algorithm. Chapters 5, 6, and 7 on isosurface patch construction, four-
xi

xii
Preface
dimensional isosurfaces, and interval volumes are related and should be read in
order. Chapter 9 on multiresolution tetrahedral meshes should be read before
Section 10.1 on multiresolution convex polyhedral meshes. Chapter 3 on dual
contouring should be read before Section 10.2 on multiresolution surface nets.
The other chapters are relatively independent and can be read independently.

ACKNOWLEDGMENTS
I am indebted to many people for their support and assistance. First and fore-
most is my colleague Tamal Dey, who continually challenged me to apply rigorous
methods to geometric modeling. He is a source of inspiration and a role model
for research excellence. Roger Crawﬁs initiated my interest in isosurfaces during
a graduate seminar on isosurfaces. That seminar led to a joint paper on general-
izing the Marching Cubes algorithm to four dimensions and my ongoing interest
and research in isosurfaces. Colleagues and collaborators, Han-Wei Shen and
Yusu Wang, were also sources of encouragement and inspiration.
A special thanks to Josh Levine who carefully reviewed this book and sug-
gested numerous corrections and improvements. Thanks also to my former and
current students, Ramakrishnan Khaziyur-Mannar, Marc Khoury, and Arindam
Bhattacharya. Thanks to Hamish Carr at University of Leeds and Carlos Schei-
degger from ATT Labs for numerous conversations about isosurfaces and scalar
data sets. Thanks also for support from the National Science Foundation.
Many of the images in this text were produced from data sets compiled by
Michael Meissner at www.volvis.org and the data sets at the Volume Library,
www.stereofx.org, compiled by Stefan Roettger. These data sets are an invalu-
able resource for research in volume graphics.
Finally, thanks to my wife, Shifra. Without her encouragement and support,
I would never have completed this book.
xiii

This page intentionally left blank
This page intentionally left blank

CHAPTER 1
INTRODUCTION
1.1
What Are Isosurfaces?
A scalar ﬁeld is a function φ which assigns a scalar value (a real number) to each
point in Rd. The value d is known as the dimension of the scalar ﬁeld. Examples
of three-dimensional scalar ﬁelds are densities, pressures, or temperatures asso-
ciated with points in R3. If these values change with time, then the addition of
time as a fourth dimension gives a four-dimensional scalar ﬁeld.
Given a scalar ﬁeld φ : Rd →R and a constant σ ∈R, the set {x : φ(x) = σ}
is called a level set1 of φ. We use the notation φ−1(σ) to represent the level set
{x : φ(x) = σ}. If φ is a continuous function, then the level set φ−1(σ) separates
Rd into two sets of points, those with scalar value above σ and those with scalar
value below σ.
In two dimensions (d = 2), level sets are called isocontours or contour lines.
Contour lines in topographic maps are a familiar example of isocontours. Each
contour line on a topographic map represents a speciﬁc elevation. Walking along
the contour line means walking along a level path that does not change elevation.
Crossing contour lines means climbing up or down and changing elevations.
In three dimensions (d = 3), level sets are also called implicit surfaces or isosur-
faces. In computer graphics, the term implicit surface is generally used to refer
to surfaces deﬁned by explicitly providing a function φ. Problems include ren-
dering such a surface, converting the implicit representation to a parameterized
one, and computing intersections of implicit surfaces.
1This mathematical formulation of level sets should not be confused with the level set
method for segmentation. The level set method deﬁnes a continuous, smooth function g based
on the input data and then uses the level sets from this function to segment the data.
1

2
1. Introduction
(a)
(b)
(c)
(d)
Figure 1.1. (a) Isosurface (isovalue 3) forming a torus. Scalar data set is a 20× 20× 20
regular grid with origin (0, 0, 0) measuring the distance to a circle with radius 6 centered
at (9.5, 9.5, 9.5). (b) Torus isosurface edges. (c) Isosurface (isovalue 600) of a micro
CT scan of a tooth using a GE Industrial Micro CT scanner. Data set created by GE
Aircraft Engines. (d) Isosurface (isovalue 80) of CT scan of an engine block. Data set
created by General Electric.
Isosurface is the term for level sets used in volume visualization. Generally,
it refers to a surface constructed from a ﬁnite set of input points, each associated
with a scalar value. (See Figure 1.1.) This set of input points is a sampling of
some continuous function φ and the isosurface is an approximation of the level
set of φ. Of course, numerous functions take on the same value at a ﬁnite set
of sample points, so the function φ and the isosurface are not uniquely deﬁned.
In addition, sample data often contains noise and so is not even a precise rep-
resentation of φ at the sample points.
Finally, the very idea that the input
data represents a sampling of some continuous function φ is itself a modeling
assumption and may be misleading.

1.2. Applications of Isosurfaces
3
Unfortunately, the term isosurface is sometimes used to represent the level
set of a function φ and at other times is used to represent an approximation to a
level set. In this book, we will always use level set to refer to the mathematically
deﬁned set φ−1(σ). We use the term isosurface to refer to an approximation to a
level set φ−1(σ) where function φ is represented by a ﬁnite set of sample points.
The value σ is called the isovalue of the isosurface.
1.2
Applications of Isosurfaces
Two well-established procedures in medical imaging produce extensive scalar
ﬁeld data. Computerized tomography (CT) scanners send beams of radiation
through a person and measure the amount of radiation that arrives at various
detectors. The radiation measurements are processed to produce a (radiation)
density at various sample points within the person. Magnetic resonance imaging
(MRI) scanners measure changes in a magnetic ﬁeld caused by excited hydrogen
nuclei in water. Mathematical transformations map these measurements to wa-
ter density values at sample points within the person. The CT and MRI density
measurements implicitly represent a scalar density ﬁeld on the scanned person
with each point associated with a density. Since CT and MRI scans are mea-
suring diﬀerent material properties, they have diﬀerent relative strengths and
weaknesses. CT scans excel at imaging solid organs while MRI scans are better
at imaging subtle diﬀerences in soft tissue.
The output of a CT or MRI scan is simply a set of values associated with
sample points, usually on a regular grid.
Regions within this data represent
individual objects such as skin, muscle, or bones or pathologies such as tumors,
hemorrhages, or bowel obstructions. There are two approaches to visualizing
objects within this data. One, called direct volume rendering, is to cast imaginary
rays from a speciﬁed eye location through the data and integrate a color along
the rays based on the density values. A transfer function determines how the color
is constructed from the density values. By varying the transfer function, the user
can view or highlight diﬀerent objects within the data. Direct volume rendering
can produce excellent images, but it is computationally expensive and produces
only a visual image of a speciﬁc view of the data.
In addition, the transfer
function is diﬃcult to set and adjust.
The other approach to visualizing data is to produce surfaces representing the
boundaries of objects within the data. This approach is called surface reconstruc-
tion. Once such surfaces are produced, they can be rendered from any viewpoint
using standard computer graphics techniques. Moreover, the surfaces model the
object boundaries and can be used to measure object volume and surface area.
The most direct way to produce surfaces from volumetric data is to construct an
isosurface that approximates the level set of a scalar ﬁeld implicitly represented
by the data.

4
1. Introduction
Computational ﬂuid dynamics also produces extensive scalar ﬁeld data. In
computational ﬂuid dynamics, the ﬂow space is partitioned into small elements
(polyhedra). Each element has a ﬂow density that is derived by solving a set of
ﬁnite diﬀerence equations. The ﬂow density of an element can be thought of as
the density of some point within the element, perhaps the barycenter. Usually
this density varies with time. The objects of interest in ﬂuid ﬂow are high or low
pressure regions, perhaps representing shock waves or turbulence. Again, either
direct volume rendering or surface reconstruction can be used to visualize such
regions at a ﬁxed time.
1.3
Isosurface Properties
As previously mentioned, we use the term isosurface to refer to an approximation
of a level set. There are inﬁnitely many approximations to a level set. What
properties are required or desired in such an approximation?
One obvious property is that the isosurface should be a surface. However,
this is not as simple as it seems. For example, the level set is not necessarily
a surface: the level set of the constant function, φ(x, y, z) = σ, is all of R3 for
isovalue σ and the empty set for all other isovalues. If g : R3 →R is the distance
from (x, y, z) to the origin, then the level set of isovalue 0 is a point.
Another problem is what exactly is meant by surface. Consider the union of
two unit spheres in R3, one lying above and one below the x−y plane, such that
the two spheres touch at the origin. Is the union of these two spheres a surface?
The union of two spheres tangent at the origin separates points inside the spheres
from points outside the spheres. On the other hand, in the neighborhood of the
origin this set of points looks like two surfaces glued together at a single point.
In technical terms, the union of two spheres is not a 2-manifold. Should the
isosurface be a 2-manifold?
An isosurface is an approximation to a level set of a continuous scalar ﬁeld
φ. However, only a ﬁnite sampling P of φ is given. There are numerous scalar
ﬁelds φ with drastically diﬀerent geometry and topology that have the same
scalar values on P. These diﬀerent scalar ﬁelds can give rise to very diﬀerent
isosurfaces. How do we choose among such isosurfaces?
One assumption we will make is that function φ is continuous. Under this
assumption, it is possible to at least identify some line segments that are inter-
sected by the level set φ−1(σ).
Let p and p′ be points in P where p has scalar values above σ ∈R and
p′ has scalar values below σ. For any continuous ﬁeld φ, the level set φ−1(σ)
intersects line segment (p, p′). Thus, any isosurface approximation of such a level
set should intersect line segment (p, p′).
On the other hand, if p and p′ both have scalar values above or both have
scalar values below σ, then the level set φ−1(σ) may or may not intersect line
segment (p, p′). In general, the isosurface should not intersect such an edge.

1.3. Isosurface Properties
5
10
10
4
1
4
4
1
0
7
4
4
3
7
1
0
1
4
4
3
7
4
7
6
7
7
v∗
14
10
4
6
8
16
10
6
8
12
6
4
2
0
8
12
8
16
10
4
8
12
14
10
12
e
(a)
(b)
Figure 1.2. (a) Scalar grid sampling the function φa(x, y) = (x −2)2 −3|y −2| + 6,
the red level set φ−1
a (6) and the green isocontour with isovalue 6. Four branches of
the level set and four edges of the isocontour meet at the grid center, v∗. (b) Scalar
grid sampling the function φb(x, y) = 2x −|4y −10| + 10, the red level set φ−1
b (11) and
the green isocontour with isovalue 11. The red level set intersects the blue grid edge e
twice.
The boundary of many objects, particularly manufactured ones, is often
piecewise smooth but with sharp edges or corners connecting the pieces. An
isosurface representing such a boundary should not smooth over such edges or
corners.
We summarize some of the desirable properties of an isosurface:
1. It separates sample points with scalar value above isovalue from scalar
points with value below isovalue.
2. It does not intersect a grid edge more than once.
3. It does not intersect grid edges with both endpoint scalar values above or
both endpoint scalar values below the isovalue.
4. It is a manifold.
5. It represents sharp edges and corners.
Not all of these properties are always desirable. For instance, Figure 1.2(a)
displays a scalar grid sampling the function φa(x, y) = (x −2)2 −3|y −2| + 6.
The vertex v∗at the grid center has scalar value 6, so any isocontour with
isovalue 6 should pass through this vertex. Each of the four squares surrounding
v∗contains a grid edge with scalar values of 4 and 7 so the isocontour passes
through each such grid edge. The result is that four isocontour edges meet at
v∗, and the isocontour is not a manifold. However, the isocontour does faithfully
represent the topology of φ−1
a (6) which has four curves meeting at v∗.

6
1. Introduction
Some of the properties listed above are mutually exclusive. Figure 1.2(b)
displays a scalar grid sampling the function φb(x, y) = 2x−|4y−10|+10. The red
level set φ−1
b (11) has a sharp corner at (0.5,2.5) and intersects the blue grid edge
e twice. The green isocontour does not properly represent the sharp corner at
(0.5,2.5) and does not intersect grid edge e. Any isocontour that reproduces the
sharp corner, satisfying Property 5, would intersect grid edge e twice, violating
Properties 2 and 3.
1.4
Isosurface Construction
There are four basic approaches to isosurface construction. The ﬁrst and ear-
liest approach is to partition volumetric data into two-dimensional (2D) slices,
construct isocontours in each slice, and then “stitch” together the slices using
triangles. This approach mimics the way early radiologists used CT and MRI
data by examining slices of the data. The diﬃculty is in the stitching, which is
both time-consuming and error-prone. This approach has been superseded by
volumetric methods, which construct the isosurface directly in 3-space.
The second approach is to partition space into cubes and associate each cube
with a scalar value. The isosurface is the boundary of all cubes with scalar val-
ues below a given value. This approach was motivated by pixel graphics, which
represents images as a collection of square pixels. The obvious drawback is that
the boundary of a set of cubes is extremely nonsmooth, with faces meeting at
ninety-degree angles. In visualization, this problem can be mitigated by ren-
dering the surface using “phony” surface normals constructed from the original
data. Alternatively, smoothing techniques can be applied to the choppy surface
but with potential loss of some detail.
The third and most popular approach is the Marching Cubes algorithm
and its variants introduced by Lorensen and Cline [Lorensen and Cline, 1987a]
in 1987. The Marching Cubes algorithm partitions the volume into cubes and
then independently constructs surface patches within each cube. Each patch is a
small triangulated surface with a boundary on the cube. Based on a comparison
of the scalar values of the cube corners and the isovalue, a cube is classiﬁed into
one of 256 cases. The surface patches are constructed using a precomputed table
based on these 256 cases.
The original Marching Cubes algorithm sometimes created cube patches
that did not properly meet the patches of adjacent cubes. A number of solutions
were proposed, the simplest being a change to the precomputed table of 256
cases.
Variants of the Marching Cubes algorithm include using tetrahedra instead
of cubes and extending the algorithm to higher dimensions.
The last and most recent approach is called dual contouring. The volume is
partitioned into cubes and each cube is replaced by a single point. Points in

1.5. Limitations of Isosurfaces
7
adjacent cubes are connected to form a surface using quadrilaterals that are the
dual of cube edges. Dual contouring has the nice property of producing surfaces
that are tiled by quadrilaterals, not triangles. It can also be easily used with
multiresolution techniques where the volume partitioning may not be uniform.
On the other hand, the surfaces produced by dual contouring are usually not
manifolds.
1.5
Limitations of Isosurfaces
Using isosurfaces to model object boundaries from volumetric data has some
signiﬁcant advantages. Isosurfaces encode basic, simple structures of the scalar
ﬁeld sampled in the input data. They are easy to deﬁne and understand. They
correspond to a formal mathematical object, the level set of a scalar ﬁeld, and
so lend themselves to rigorous mathematical analysis. They can be constructed
in time proportional to the size of the input data (linear time).
Unfortunately, isosurfaces have some signiﬁcant deﬁciencies and limitations
as models for object boundaries. These deﬁciencies are caused by problems of
sampling and noise and by the lack of any global criterion in the isosurface
deﬁnition. We list some below:
1. undersampling of the spatial domain,
2. high-frequency noise,
3. low-frequency noise,
4. overspeciﬁcation of the scalar values,
5. lack of smoothness criterion,
6. choice of isosurface,
7. lack of global information,
8. lack of a priori information.
Undersampling and high-frequency noise generate adjacent samples with large
variations in scalar value. These scalar variations create surfaces with compli-
cated geometric and topological features that are not representative of the object.
In regions where scalar values are constant or near-constant, using scalar values
with precision beyond the range of the scanner creates isosurfaces which wind
arbitrarily through the regions. Without any smoothness criterion, isosurfaces
have no restrictions on their susceptibility to undersampling and noise, even
though most objects are best represented by some smooth or piecewise smooth
boundaries.

8
1. Introduction
Applying smoothing and noise reduction ﬁlters to the raw data helps miti-
gate some of the problems described above but at the expense of losing some
of the ﬁne isosurface features and nonsmooth features that may be present in
the data. On the other hand, one of the beneﬁts of isosurfaces is their faith-
fulness to the data, including all the irregularities and noise in the data. The
trade-oﬀbetween smooth ﬁltering versus exact data representation is data- and
application-dependent and is best left to the individual researcher or clinician.
Low-frequency noise produces shifts in scalar values in diﬀerent regions of
the data. The boundary of the object or objects of interest may have diﬀerent
scalar values in diﬀerent regions of the data. One isosurface will capture the
objects in one region while a diﬀerent isosurface with a diﬀerent isovalue will
bound the objects in the other region. Between the two regions, an isosurface
may give object fragments, representing portions of the object. Normalizing the
data across regions by adjusting scalar values may help, but it creates the danger
of introducing normalization errors.
Isosurfaces depend upon a single parameter, the isovalue of the points on
the isosurface. Choosing this parameter is itself a challenging task. Both visu-
alization and data analysis tools exist to help in ﬁnding interesting or relevant
isovalues.
Isosurfaces are intrinsically local with no global criteria about their shape
or structure.
In almost all applications such global criteria do exist and are
known to researchers or clinicians. On the other hand, because isosurfaces make
no application or data-speciﬁc assumptions, they are versatile structures that
can be used in almost any geometric application.
They are a basic tool for
anyone visualizing or modeling data but only as the building blocks for more
sophisticated data-speciﬁc tools.
1.6
Multivalued Functions and Vector Fields
Many applications produce more than a single scalar value at each point. The
simplest example is color images that have an RGB (red, green, blue) value
associated with each pixel. In ﬂuid ﬂow simulation, both a pressure and temper-
ature could be associated with sample points in the ﬂow. Combinations of scans
from diﬀerent instruments, such as a CT scan and an MRI scan of the same
individual, can produce a radiation density and a water density at each sample
point.
Visualizing and modeling multivalued data is much more diﬃcult than ana-
lyzing scalar ﬁelds. Sometimes multiple values are combined into a single scalar
value at each point producing a single scalar ﬁeld. Isosurfaces can then be used to
visualize and model objects in that scalar ﬁeld. The resulting surface is highly
sensitive to the function used to create the scalar ﬁeld from the multivalued
functions.

1.7. Deﬁnitions and Basic Techniques
9
Vector ﬁelds are multivalued functions that map Rd to Rd. In ﬂuid ﬂow sim-
ulation, they can represent direction and speed of the ﬂow. Critical points in a
vector ﬁeld are points that are assigned the zero vector, (0, 0, . . . , 0). Visual-
ization and modeling of vector ﬁelds usually relies upon identiﬁcation of critical
points and representation of the ﬂow between critical points.
Various transformations can be used to transform a vector ﬁeld into a scalar
one—for instance, by replacing each vector by its length. Such transformations
are usually too crude to extract all but the most rudimentary information.
1.7
Deﬁnitions and Basic Techniques
Before discussing isosurface construction, we need to review some basic deﬁni-
tions and techniques that are used throughout this book.
1.7.1
Deﬁnitions
Regular scalar grid. Isosurface construction algorithms take as input a sample
set of points. This sample set is often represented by a regular grid.
In two dimensions, a regular grid is a partition of a large rectangle into small
congruent rectangles.
More generally, a regular grid in Rd is a partition of a
large hyperrectangle into small congruent hyperrectangles.
(See Figure 1.3.)
The vertices and edges of the regular grid are the vertices and edges of the
small hyperrectangles. A typical example of a regular grid is the partition of
the region [0, m1] × [0, m2] × [0, m3] into m1 × m2 × m3 cubes. Note that along
each axis d this regular grid has md edges and (md + 1) vertices. The grid has
(m1 + 1) × (m2 + 1) × (m3 + 1) vertices.
(a) A 2D regular grid.
(b) A 3D regular grid.
Figure 1.3. (a) A 2D regular grid with vertex dimensions 5 × 4 and cube dimensions
4 × 3. (b) A 3D regular grid with vertex dimensions 5 × 4 × 3 and cube dimensions
4 × 3 × 2.

10
1. Introduction
The vertex dimensions of a regular grid is the number of vertices along each
axis. A regular grid of cubes with vertex dimensions n1 ×n2 ×n3 has nd vertices
along each axis, n1 × n2 × n3 vertices, and (n1 −1) × (n2 −1) × (n3 −1) cubes.
The cube dimensions of a regular grid is the number of edges along each axis.
A regular grid of cubes with cube dimensions m1 × m2 × m3 has md edges
along each axis, (m1 + 1) × (m2 + 1) × (m3 + 1) vertices, and m1 × m2 × m3
cubes. A regular grid with cube dimensions m1 ×m2×m3 has vertex dimensions
(m1 + 1) × (m2 + 1) × (m3 + 1).
Unless otherwise noted, the dimensions of a grid refers to its vertex dimen-
sions. Thus, an n1 × n2 × n3 regular grid has vertex dimensions n1 × n2 × n3
and cube dimensions (n1 −1) × (n2 −1) × (n3 −1).
A regular scalar grid is a regular grid where each grid vertex vi is associated
with a scalar value si ∈R. A simple example is a grayscale image—for instance,
a black-and-white picture.2 The sample points are the pixel centers. The scalar
value at each point is the grayscale value of the pixel containing the point.
Triangulation. Isosurfaces are often triangulations, sets of triangles or simplices
with appropriate intersection conditions.
Deﬁnition 1.1. A triangulation τ is a set of simplices such that for every pair of
simplices t, t′ ∈τ, the intersection t∩t′ is either empty or a face of each simplex.
For instance, if triangulation τ is a set of triangles, then the intersection t∩t′
is either empty, a common vertex of t and t′, or a common edge of t and t′. (See
Figure 1.4.)
Mathematics texts usually add a formal requirement that if simplex t is in
τ, then every face of t is in τ. See Appendix B.4 for further discussion and
deﬁnitions.
a
b
c
(a)
(b)
Figure 1.4. (a) A triangulation of a rectangle.
(b) A partition of a rectangle into
triangles, which is not a triangulation. The intersection of triangles a and c is a line
segment that is not an edge of c. The intersection of triangles b and c is also not an
edge of c.
2The term black-and-white is a bit misleading since black-and-white pictures generally con-
tain all diﬀerent shades of gray.

1.7. Deﬁnitions and Basic Techniques
11
The notation |τ| represents the set of all points in all triangles of τ, i.e.,
|τ| = 
t∈τ t.
Deﬁnition 1.2. A set X ⊆Rd is piecewise linear if X equals |τ| for some triangula-
tion τ.
Convex Polyhedral Mesh. In many instances, a scalar ﬁeld is represented not by
a regular scalar grid but by a mesh composed of triangles or convex polyhedra.
Deﬁnition 1.3. A convex polyhedral mesh Γ is a set of convex polyhedra in R3 such
that for every pair of convex polyhedra c, c′ ∈Γ, the intersection c ∩c′ is either
empty or a face of each convex polyhedron.
Mathematics texts usually add a formal requirement that if convex polyhe-
dron c is in Γ, then every face of c is in Γ.
The notation |Γ| represents the set of all points in all elements of Γ, i.e.,
|Γ| = 
c∈Γ c.
A tetrahedral mesh is a convex polyhedral mesh where every mesh element is
a tetrahedron. A scalar mesh is a mesh where each mesh vertex vi is associated
with a scalar value si ∈R.
The generalization of a convex polyhedral mesh to Rd is called a convex
polytopal mesh. The deﬁnition is given in Appendix B.5. A convex polytopal
mesh where every mesh element is a simplex is a triangulation. It is also sometimes
called a simplicial mesh.
Orientation. Let L be a line segment L with vertices {v0, v1}. The orientation of
L is an ordering of the vertices of L, either (v0, v1) or (v1, v0).
Let t be a triangle with vertices {v0, v1, v2}. The orientation of t is a cyclic
order of the vertices of t. (See Figure 1.5(a).) There are two possible cyclic
v0
v1
v2
(v0, v1, v2)
v0
v1
v2
(v2, v1, v0)
v0
v1
v2
v3
v4
e1
e2
(a)
(b)
(c)
Figure 1.5. (a) Triangle orientation (v0, v1, v2). (b) Triangle orientation (v2, v1, v0).
(c) Triangle orientations (v0, v1, v2),
(v1, v3, v2),
and (v4, v3, v2).
Orientations
(v0, v1, v2) and (v1, v3, v2) are consistent.
Orientation (v0, v1, v2) induces the orien-
tation (v1, v2) on edge e1 while (v1, v3, v2) induces the opposite orientation (v2, v1) on
edge e1. Orientations (v1, v3, v2) and (v4, v3, v2) are not consistent. Both orientations
induce the same orientation (v3, v2) on edge e2.

12
1. Introduction
orders, either (v0, v1, v2) or (v2, v1, v0). The sequences (v1, v2, v0) and (v2, v0, v1)
represent the same cyclic order as (v0, v1, v2).
Only the starting vertex has
changed. Similarly, the sequences (v1, v0, v2) and (v0, v2, v1) represent the same
cyclic order as (v2, v1, v0).
The cyclic order (v0, v1, v2) induces orientations, (v0, v1), (v1, v2), and (v2, v0)
of the edges of t. The reverse cyclic order (v2, v1, v0) induces opposite orienta-
tions (v1, v0), (v2, v1), and (v0, v2) of the edges of t. Two oriented triangles,
t1 and t2, which share an edge e have consistent orientations if the orientation
of e induced by t1 is the opposite of the orientation of e induced by t2. (See
Figure 1.5(c).)
The orientation (v0, v1, v2) of a triangle t in R3 determines the vector
u
=
(v1 −v0) × (v2 −v0)
=
v1 × v2 −v0 × v2 −v1 × v0
=
v0 × v1 + v1 × v2 + v2 × v0,
where × is the cross product.
Vector u is orthogonal to t.
The sequence
(v1, v2, v0) determines the vector (v2 −v1)×(v0 −v1) = v0 ×v1 +v1 ×v2 +v2 ×v0
that is u. Similarly, (v2, v0, v1) determines the vector (v0 −v2)× (v1 −v2), which
equals u. Thus, the vector u is independent of the representation of the cycle
(v0, v1, v2). The orientation (v2, v1, v0) determines the vector
(v1 −v2) × (v0 −v2)
=
v1 × v0 −v1 × v2 −v2 × v0
=
v1 × v0 + v2 × v1 + v0 × v2
=
−u.
Thus, the two orientations of t determine two opposite vectors, u and −u, which
are both orthogonal to t.
In computer graphics, triangle orientations are used to determine the front
and back faces of triangles. Triangle shading is often dependent on whether the
viewer is seeing a front or back face. Thus, it is important that any two triangles
that share a common edge have consistent orientations.
Orientations are deﬁned for higher dimensional simplices, where they are also
represented by sequences of simplex vertices. The orientation of a (d−1)-simplex
in Rd determines a unique vector u orthogonal to the simplex. The opposite
orientation determines the vector −u. Appendix B.6 contains the deﬁnition and
discussion of orientations in higher dimensional simplices.
Separation. An important property of isosurfaces is that they “separate” those
points with scalar value above the isovalue from those points with scalar value
below the isovalue [Nielson et al., 2003]. We give the following formal deﬁnition
of this concept.
Let X and Y be sets of points in Rd. We ﬁrst deﬁne what it means for X to
separate two points in Y.

1.7. Deﬁnitions and Basic Techniques
13
Deﬁnition 1.4.
• Set X separates point p ∈Y from point q ∈Y if every path in Y connecting
p to q intersects X.
• Set X strictly separates p from q if X separates p from q and neither p nor q
is in X.
We next deﬁne what it means for X to separate two subsets of Y.
Deﬁnition 1.5.
• Set X separates Y1 ⊆Y from Y2 ⊆Y if X separates every p ∈Y2 from
every q ∈Y2.
• Set X strictly separates Y1 ⊆Y from Y2 ⊆Y if X separates Y1 from Y2 and
X does not intersect Y1 or Y2.
(See Appendix B.9 for further discussion of separation and its properties.)
Manifolds. A manifold is a mathematical formalization of the intuitive concept
of a surface.
Let Bk be the k-dimensional open ball with radius one centered at the origin.
Ball B1 is an open line segment and B2 is an open disk. A k-dimensional manifold
(k-manifold) is a set of points that locally resembles Bk. Examples of 1-manifolds
are circles or simple, closed curves. Every point of a 1-manifold has a small neigh-
borhood that is topologically equivalent to an open line segment (B1). Examples
of 2-manifolds are spheres, tori, or double tori. Every point of a 2-manifold has
a small neighborhood that is topologically equivalent to an open disk (B2).
Let Bk+ be the intersection of the open ball Bk and the closed half-space
{(x1, . . . , xk) : xk ≥0}. Note that Bk+ is neither closed nor open. B1+ is a
line segment open at one endpoint and closed at the other. B2+ is a half-disk,
open along the disk and closed at the bounding edge. B3+ is a half-sphere, open
along the sphere and closed at the bounding disk. A k-dimensional manifold with
boundary (k-manifold with boundary) is a set of points which locally resembles either
Bk or Bk+. Examples of 1-manifolds with boundary are line segments or simple
curves with two endpoints. Examples of 2-manifolds with boundary are disks or
convex polygons (including the polygon interior.) Examples of 3-manifolds with
boundary are closed balls or cubes (including the cube interior.) For more precise
deﬁnitions of k-manifold and k-manifold with boundary, see Appendix B.3.
Piecewise linear manifold. A k-manifold (possibly with boundary) is piecewise
linear if it is the union of a set of k-simplices that form a triangulation of the
manifold. A piecewise linear manifold is orientable if every simplex in the man-
ifold can be assigned an orientation and these orientations are consistent. The
orientation of the manifold is the orientation of all its simplices. If a piecewise

14
1. Introduction
linear manifold is connected and orientable, then assigning an orientation to one
simplex ﬁxes the orientations of all the other manifold simplices.
1.7.2
Linear Interpolation
A basic step in Marching Cubes and its variants is approximating the inter-
section of a level set and a line segment. These algorithms use linear interpolation
to ﬁnd a point on the line segment that approximates the intersection.
Let φ : Rd →R be a scalar ﬁeld and let σ ∈R be an isovalue deﬁning the
level set φ−1(σ). Given two grid vertices p and q where φ(p) ̸= φ(q), if σ is
between φ(p) and φ(q), then the level set intersects line segment [p, q]. We wish
to approximate the intersection of φ−1(σ) and line segment [p, q]. We do so by
deﬁning a linear function φ based on the two scalar values φ(p) and φ(q) and
calculating the point r ∈[p, q] where φ(r) = σ.
Every point on line segment [p, q] can be described as a linear combination of
p and q. More speciﬁcally, every point on line segment [p, q] equals (1 −α)p+ αq
for some α where 0 ≤α ≤1. For example, in R3 where p equals (px, py, pz) and
q equals (qx, qy, qz), the linear combination is
((1 −α)px + αqx, (1 −α)py + αqy, (1 −α)pz + αqz).
Deﬁne φ : [p, q] →R by
φ((1 −α)p + αq) = (1 −α)φ(p) + αφ(q).
Note that φ(p) = φ(p) (α = 0) and φ(q) = φ(q) (α = 1). Values of φ vary
linearly with α.
We approximate the intersection of φ−1(σ) with [p, q] as the point r where
φ(r) equals σ. Since r is on line segment [p, q], point r equals (1 −αr)p + αrq
for some αr. Thus,
σ = φ(r) = φ((1 −αr)p + αrq) = (1 −αr)φ(p) + αrφ(q).
Solving for αr gives
αr =
σ −φ(p)
φ(q) −φ(p).
Note that since φ(p) ̸= φ(q), the denominator φ(q) −φ(p) is nonzero.
In R3, the equations for the coordinates of r = (rx, ry, rz) are
rx
=
(1 −αr)px + αrqx,
ry
=
(1 −αr)py + αrqy,
rz
=
(1 −αr)pz + αrqz.

1.7. Deﬁnitions and Basic Techniques
15
Input
: Points p, q ∈Rd, scalar values sp, sq, and an isovalue σ.
Requires
: sp ̸= sq and either sp ≤σ ≤sq or sp ≥σ ≥sq.
Output
: Point r lying on [p, q].
LinearInterpolation(p, sp, q, sq, σ)
1 α ←σ−sp
sq−sp ;
2 for i = 1 to d do
3
ri ←(1 −α)pi + αqi;
4 end
5 return (r);
Algorithm 1.1. Linear interpolation.
More generally, in Rd the equations for the coordinates of r = (r1, r2, . . . , rd) are
r1
=
(1 −αr)p1 + αrq1,
r2
=
(1 −αr)p2 + αrq2,
· · ·
rd
=
(1 −αr)pd + αrqd.
Pseudocode is given in Algorithm 1.1.
The assumption for all these algorithms is that φ(p) does not equal φ(q). If
both φ(p) and φ(q) equal σ, then the level set contains both p and q and there
is no way to approximate the intersection of φ−1(σ) and [p, q] by a single point.
Where or whether the isosurface approximation intersects line segment [p, q] is
dependent upon the speciﬁc isosurface construction algorithm.
1.7.3
Mesh Representation
The output of surface reconstruction algorithms is a mesh consisting of a set of
small, simple surface elements. Typical surface elements are triangles or quadri-
laterals. In curve reconstruction, the elements are line segments, while in higher
dimensions the elements are simplices, cubes or hypercubes.
A mesh is represented by a list of mesh vertices, L1, followed by a list,
L2, of surface elements. The list L1 of mesh vertices contains the mesh vertex
coordinates, the location of each mesh vertex in Rd. This representation is called
an indexed mesh or a face-vertex mesh.
The list L2 of surface elements contains the element vertices, the mesh ver-
tices determining the element.
For instance, triangles are speciﬁed by three
vertices, while quadrilaterals are speciﬁed by four vertices in order around the

16
1. Introduction
1
1
2
2
3
3
4
4
5
v0 :(1, 1)
v1 :(2, 3)
v2 :(3, 2)
v3 :(4, 4)
v4 :(5, 1)
Figure 1.6.
Triangle mesh.
List of vertices (speciﬁed by vertex coordinates):
((1, 1), (2, 3), (3, 2), (4, 4), (5, 1)).
List of triangles (speciﬁed by triangle vertices):
((v0, v2, v1), (v1, v2, v3), (v2, v4, v3)).
quadrilateral. Each mesh vertex stored in L2 is actually a reference to a mesh
vertex in the list L1.
Figure 1.6 contains an example of a triangle mesh.
The list L1 of mesh
vertices for this mesh is ((1, 1), (2, 3), (3, 2), (4, 4), (5, 1)). The list L2 of mesh
triangles is ((v0, v2, v1), (v1, v2, v3), (v2, v4, v3)).

CHAPTER 2
MARCHING CUBES
AND VARIANTS
In the introduction, we mentioned four diﬀerent approaches to isosurface con-
struction.
In this chapter, we describe one of those approaches to isosurface
construction, the widely used Marching Cubes algorithm by Lorensen and
Cline [Lorensen and Cline, 1987a].
The Marching Cubes algorithm is based on two ideas. First, the isosurface
can be constructed piecewise within each cube of the grid without reference to
other grid cubes. Second, the combinatorial structure of each isosurface patch
in a grid cube can be retrieved from a lookup table. Since the main operation
is retrieving this structure from the lookup table, the algorithm runs in time
proportional to the number of grid cubes.
We ﬁrst present a two-dimensional version of the algorithm, called Marching
Squares, for constructing two-dimensional isocontours. Before discussing the
Marching Squares algorithm, we deﬁne some terminology that will be used
by the algorithms in this chapter.
2.1
Deﬁnitions
Given a regular scalar grid and an isovalue σ, it is convenient to assign “+” and
“−” labels to each grid vertex based on the relationship between its scalar value
and σ.
Deﬁnition 2.1.
• A grid vertex is positive, “+”, if its scalar value is greater than or equal to σ.
• A grid vertex is negative, “−”, if its scalar value is less than σ.
• A positive vertex is strictly positive if its scalar value does not equal σ.
17

18
2. Marching Cubes and Variants
Since the scalar value of a negative vertex never equals the isovalue, there is no
point in deﬁning a similar “strictly negative” term.
Grid edges can be characterized by the labels at their endpoints.
Deﬁnition 2.2.
• A grid edge is positive if both its endpoints are positive.
• A grid edge is negative if both its endpoints are negative.
• A positive grid edge is strictly positive if both its endpoints are strictly pos-
itive.
• A grid edge is bipolar if one endpoint is positive and one endpoint is nega-
tive.
Note that a grid vertex or edge is only positive or negative in relationship to
some isovalue.
The deﬁnitions given above apply not just to regular scalar grids but also to
curvilinear grids. They also apply to the vertices and edges of polyhedral meshes
such as tetrahedral and simplicial meshes.
2.2
Marching Squares
2.2.1
Algorithm
Input to the Marching Squares algorithm is an isovalue and a set of scalar
values at the vertices of a two-dimensional regular grid.
The algorithm has
three steps. (See Figure 2.1.) Read in the isocontour lookup table from a pre-
constructed data ﬁle. For each square, retrieve from the lookup table a set of
Read isocontour lookup table

For each grid square, retrieve isocontour edges

Compute isocontour vertex coordinates using linear interpolation
Figure 2.1. Marching Squares.

2.2. Marching Squares
19
6
7
8
1
2
3
4
5
14
15
16
9
10
11
12
13
Figure 2.2. Square conﬁgurations. Black vertices are positive.
6
7
8
1
2
3
4
5
14
15
16
9
10
11
12
13
Figure 2.3. Square isocontours. Conﬁgurations 1 and 9 have no isocontour. Isocontours
for conﬁgurations 2–7 and 10–15 are single line segments. Isocontours for conﬁgurations
8 and 16 are two line segments.
isocontour edges representing the combinatorial structure of the isocontour. The
endpoints of these edges form the isocontour vertices. Assign geometric locations
to the isocontour vertices based on the scalar values at the square edge endpoints.
We explain the last two steps of the algorithm next.
Each grid vertex is labeled positive or negative as described in Section 2.1.
(See Figure 2.4(b) for an example.) Since a square has four vertices, there are
24 = 16 diﬀerent conﬁgurations of square vertex labels. These conﬁgurations are
listed in Figure 2.2.
The combinatorial structure of the isocontour within each square is deter-
mined from the conﬁguration of the square’s vertex labels. In order to separate
the positive vertices from the negative ones, the isocontour must intersect any
square edge that has one positive and one negative endpoint. An isocontour
that intersects a minimal number of grid edges will not intersect any square edge
whose endpoints are both strictly positive or whose endpoints are both negative.
For each square conﬁguration κ, let E+/−
κ
be the set of bipolar edges. Note
that the size of E+/−
κ
is either zero, two, or four. Pair the edges of E+/−
κ
. Each
such pair represents an isocontour edge with endpoints on the two elements
of the pair.
Figure 2.3 contains the sixteen square conﬁgurations and their

20
2. Marching Cubes and Variants
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
(a) Scalar grid.
(b) The +/−grid.
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
(c) Midpoint vertices.
(d) Isocontour.
Figure 2.4. (a) 2D scalar grid. (b) Black vertices are positive. Vertex v with scalar
value sv is positive if sv >= 5 and negative if sv < 5. Note that sv = 5 for one grid
vertex v. (c) Isocontour with vertices at edge midpoints (before linear interpolation).
(d) Isocontour with isovalue 5.
isocontours. The isocontour lookup table, Table, contains sixteen entries, one for
each conﬁguration. Each entry, Table[κ] is a list of the E+/−
κ
pairs.
In Figure 2.3 the isocontour edges are drawn connecting the midpoints of
each square edge. This is for illustration purposes only. The geometric locations
of the isocontour vertices are not deﬁned by the lookup table.
The isocontour lookup table is constructed on the unit square with vertices
(0, 0), (1, 0), (0, 1), (1, 1). To construct the isocontour in grid square (i, j), we
have to map pairs of unit square edges to pairs of square (i, j) edges.
Each
vertex v = (vx, vy) of the unit square maps to v + (i, j) = (vx, vy) + (i, j) =
(vx + i, vy + j). Each edge e of the unit square with endpoints (v, v′) maps to
edge e + (i, j) = (v + (i, j), v′ + (i, j)). Finally, each edge pair (e1, e2) maps to
(e1 + (i, j), e2 + (i, j)).
The endpoints of the isocontour edges are the isocontour vertices. To map
each isocontour edge to a geometric line segment, we use linear interpolation to

2.2. Marching Squares
21
Input
: F is a 2D array of scalar values.
Coord is a 2D array of (x, y) coordinates.
σ is an isovalue.
Result
: A set Υ of isocontour line segments.
MarchingSquares(F, Coord, σ, Υ)
1 Read Marching Squares lookup table into Table;
/* Assign “+” or “−” signs to each vertex
*/
2 foreach grid vertex (i, j) do
3
if F[i, j] < σ then Sign[i, j] ←“−”;
4
else Sign[i, j] ←“+”;
/* F[i, j] ≥σ */
5 end
6 S ←∅;
/* For each grid square, retrieve isocontour edges
*/
7 foreach grid square (i, j) do
/* Grid square vertices are (i, j), (i+1, j), (i, j+1), (i+1, j+1)
*/
8
κ ←(Sign[i, j], Sign[i+1, j], Sign[i, j+1], Sign[i+1, j+1]);
9
foreach edge pair (e1, e2) ∈Table[κ] do
10
Insert edge pair (e1 + (i, j), e2 + (i, j)) into S;
11
end
12 end
/* Compute isocontour vertex coordinates using linear interpolation
*/
13 foreach bipolar grid edge e with endpoints (i1, j1) and (i2, j2) do
/* Compute the isosurface vertex we on edge e
*/
14
we ←LinearInterpolation
15
(Coord[i1, j1], F[i1, j1], Coord[i2, j2], F[i2, j2], σ);
16 end
/* Convert S to set of line segments
*/
17 Υ ←∅;
18 foreach pair of edges (e1, e2) ∈S do
19
Υ ←Υ ∪{(we1, we2)};
20 end
Algorithm 2.1. Marching Squares.
position the isocontour vertices as described in Section 1.7.2. Each isocontour
vertex v lies on a grid edge [p, q]. If sp and sq are the scalar values at p and q
and σ is the isovalue, then map v to (1 −α)p + αq where α = (σ −sp)/(sq −sp).
Note that since p and q have diﬀerent signs, scalar sp does not equal sq and the
denominator (sq −sp) is never zero.
The Marching Squares algorithm is presented in Algorithm 2.1. Function
LinearInterpolation, called by this algorithm, is deﬁned in Algorithm 1.1 in
Section 1.7.2.

22
2. Marching Cubes and Variants
Figure 2.4 contains an example of a scalar grid, an assignment of positive and
negative labels to the grid vertices, the isocontour before linear interpolation, and
the ﬁnal isocontour after linear interpolation.
2.2.2
Running Time
The Marching Squares algorithm runs in linear time.
Proposition 2.3. Let N be the total number of vertices of a 2D scalar grid. The
running time of the Marching Squares algorithm on the scalar grid is Θ(N).
Proof: Reading the Marching Square lookup table takes constant time. Each
grid square is processed once.
At each grid square, at most two isocontour
edges are retrieved from the lookup table. Since the number of grid squares is
bounded by the number of grid vertices, determining the isocontour edges takes
O(N) time.
Computing the isocontour vertex on each grid edge takes time proportional
to the number of isocontour vertices.
Since each grid edge has at most one
isocontour edge, the time to compute isocontour vertices is proportional the
number of grid edges. The number of grid edges is less than twice the number
of grid vertices, so the number of grid edges is at most 2N. Thus computing the
isocontour vertices takes O(N) time.
The algorithm examines every grid square, so its running time has an Ω(N)
lower bound. Thus, the running time of the Marching Squares algorithm is
Θ(N).
□
2.2.3
Isocontour Properties
To properly discuss the output produced by the Marching Squares algorithm,
we need to diﬀerentiate between two cases based on the isovalue. In the ﬁrst
case, the isovalue does not equal the scalar value of any grid vertex. In this
case, the Marching Squares algorithm produces a piecewise linear 1-manifold
with boundary. The boundary of the 1-manifold lies on the boundary of the
grid. In the second case, the isovalue equals the scalar value of one or more grid
vertices. In this case, the Marching Squares algorithm may not produce a
1-manifold with boundary or the boundary may not lie on the boundary of the
grid. For instance, the Marching Squares algorithm applied to the 3×3 grids
in Figures 2.5 and 2.6 produces non-manifold isocontours or isocontours with
boundary not on the scalar grid. In Figure 2.5(a), four isocontour line segments
intersect at a single point; in Figure 2.5(b), the isocontour is a single point, and
in Figure 2.6, the boundary of the isocontour lies inside the grid.
The two cases also diﬀer in the nature of the line segments produced by the
algorithm. The isocontour produced by the Marching Squares algorithm is

2.2. Marching Squares
23
3
4
2
2
1
2
4
2
4
5
1
5
1
1
0
1
3
1
2
1
2
2
2
2
1
2
2
4
4
4
1
0
(a)
(b)
Figure 2.5. Examples of non-manifolds produced by Marching Squares (isovalue 3).
Black vertices are positive. (a) Four curves joining at the grid vertex with isovalue 3.
(b) Isosurface includes an isolated point at the grid vertex with isovalue 3.
3
3
1
2
1
0
1
2
1
2
2
1
4
4
4
2
Figure 2.6. Examples of a manifold produced by Marching Squares whose boundary
does not lie on the grid boundary (isovalue 3). Black vertices are positive.
a set of line segments whose vertices lie on the grid edges. If the isovalue does
not equal the scalar value of any grid vertex, then these line segments all have
positive length. If the isovalue equals the scalar value of one or more grid vertices,
then the isocontour may have zero-length edges. For instance, the Marching
Squares algorithm applied to the three grids in Figure 2.7 produces isocontours
for isovalue 3 with zero-length edges.
In Figure 2.7(a), the lower-left grid square has conﬁguration 4, producing a
single isocontour edge, but both endpoints of that edge map to the vertex in the
middle of the grid. In Figure 2.7(b), each grid square produces an isocontour
edge, but all four edges have zero length and collapse to a single point.
In
Figure 2.7(c), leftmost and rightmost grid squares produce zero-length isocontour
edges and two middle grid squares produce two duplicate isocontour edges on a
grid edge.
Marching Squares returns a ﬁnite set, Υ, of line segments. The isocontour
is the union of those line segments. The vertices of the isocontour are the endpoints
of the line segments.
The following properties apply to all isocontours produced by the Marching
Squares algorithm.

24
2. Marching Cubes and Variants
3
2
2
2
2
4
5
4
1
3
2
2
2
2
2
2
1
3
2
2
1
2
2
2
2
2
1
2
1
3
(a)
(b)
(c)
Figure 2.7. Examples of zero-length contour edges produced by Marching Squares
(isovalue 3). Black vertices are positive. (a) Isocontour with one zero-length isocontour
edge (from lower-left grid square).
(b) Isocontour with four zero-length isocontour
edges. (c) Another isocontour with four zero-length isocontour edges. Isocontour also
has two duplicate nonzero isocontour edges (from the two middle grid squares).
Property 1.
The isocontour is piecewise linear.
Property 2.
The vertices of the isocontour lie on grid edges.
Property 3.
The isocontour intersects every bipolar grid edge at exactly one
point.
Property 4.
The isocontour does not intersect any negative or strictly positive
grid edges.
Property 5.
The isocontour separates positive grid vertices from negative grid
vertices and strictly separates strictly positive grid vertices from negative grid
vertices.
Set Y ⊆X separates point p ∈X from point q ∈X if every path in X connecting
p to q intersects Y. Set Y strictly separates p from q if Y separates p from q and
neither p nor q is on Y. (See Section 1.7.1 and Appendix B.9.)
Properties 3 and 4 imply that the isocontour intersects a minimum number
of grid edges. If both endpoints of a grid edge have scalar value equal to the
isovalue, then the isocontour may intersect the grid edge zero, one, or two times
or may contain the grid edge. (See Figure 2.8.)
A grid vertex may have scalar value equal to the isovalue and yet no iso-
contour passes through any edge containing that grid vertex. For instance, the
Marching Squares algorithm returns the empty set when run on the scalar
grid in Figure 2.9 with isovalue 3. Each vertex, including the center vertex, is
positive, so each grid square has conﬁguration 9 (Figure 2.2) and has no isocon-
tour edges.
By Property 3, the isocontour intersects every bipolar grid edge. However,
the bipolar grid edge may be intersected by zero-length isocontour edges as in
Figure 2.7(b).
The following properties apply to Marching Squares isocontours whose
isovalues do not equal the scalar value of any grid vertex.

2.2. Marching Squares
25
4
4
4
2
4
4
2
2
2
1
2
2
1
2
1
4
2
2
4
4
3
3
5
5
4
4
2
1
4
3
3
3
3
3
3
2
2
2
5
4
4
2
1
2
1
2
2
2
2
2
1
2
1
2
2
2
4
4
2
2
4
4
2
4
(a)
(b)
(c)
(d)
e
e
e
e
Figure 2.8. Examples of grid edges with both endpoint scalar values equal to the
isovalue (3). Black vertices are positive. (a) Red grid edge e does not intersect the
isocontour. (b) Red grid edge e intersects the isocontour at one endpoint. (c) Red grid
edge e intersects the isocontour at both endpoints. (d) Red grid edge e is contained in
the isocontour.
4
4
4
5
4
5
3
4
4
Figure 2.9. Example of a scalar grid whose Marching Squares isocontour is the
empty set, even though the center grid vertex has scalar value equal to the isovalue 3.
All vertices are positive.
Property 6.
The isocontour is a piecewise linear 1-manifold with boundary.
Property 7.
The boundary of the isocontour lies on the boundary of the grid.
Property 8.
Set Υ does not contain any zero-length line segments or dupli-
cate line segments, and the line segments in Υ form a “triangulation” of the
isocontour.
The triangulation in Property 8 simply means that line segments in Υ inter-
sect at their endpoints. The isocontour is one-dimensional and does not contain
any triangles.
2.2.4
Proof of Isocontour Properties
We give a proof of each of the properties listed in the previous section.
Property 1.
The isocontour is piecewise linear.
Property 2.
The vertices of the isocontour lie on grid edges.

26
2. Marching Cubes and Variants
6
7
8
1
2
3
4
5
14
15
16
9
10
11
12
13
Figure 2.10. Red, positive regions and blue, negative regions for each square conﬁgu-
ration. The green isocontour is part of the positive region. Black vertices are positive.
Proof of Properties 1 & 2: The Marching Squares isocontour consists of a ﬁnite
set of line segments, so it is piecewise linear. These line segments intersect only at
their endpoints and thus form a triangulation of the isocontour. The endpoints
of these line segments lie on the grid edges, conﬁrming Property 2.
□
Property 3.
The isocontour intersects every bipolar grid edge at exactly one
point.
Property 4.
The isocontour does not intersect any negative or strictly positive
grid edges.
Proof of Properties 3 & 4: Each isocontour edge is contained in a grid square. Since
the grid squares are convex, only isocontour edges with endpoints (vertices) on
the grid edge intersect the grid edge. If the grid edge has one positive and one
negative endpoint, the unique location of the isocontour vertex on the grid edge
is determined by linear interpolation. Thus the isocontour intersects a bipolar
grid edge at only one point.
If the grid edge is negative or strictly positive, then no isocontour vertex lies
on the grid edge. Thus the isocontour does not intersect negative or strictly
positive grid edges.
□
Within each grid square the isocontour partitions the grid square into two
regions. Let the positive region for a grid square c be the set of points which can
be reached by a path ζ from a positive vertex. More precisely, a point p is in the
positive region of c if there is some path ζ ⊂c connecting p to a positive vertex
of c such that the interior of ζ does not intersect the isocontour. A point p is
in the negative region of c if there is some path ζ ⊂c connecting p to a negative
vertex of c such that ζ does not intersect the isocontour. Since any path ζ ⊂c
from a positive to a negative vertex must intersect the isocontour, the positive
and negative regions form a partition of the square c. Figure 2.10 illustrates the
positive and negative regions, colored red and blue, respectively, for each square
conﬁguration.

2.2. Marching Squares
27
c1
c2
c3
c4
e1
e2
e3
Figure 2.11. Adjacent grid squares, c1, c2, c3, and c4, and their positive (red) regions,
R+
c1, R+
c2, R+
c3 and R+
c4, respectively. Yellow edges e1, e2 and e3 separate the squares.
Positive regions agree on the grid square boundaries, i.e., R+
c1 ∩e1 = R+
c2 ∩e1 and
R+
c2 ∩e2 = R+
c3 ∩e2 and R+
c3 ∩e3 = R+
c4 ∩e3.
Note the asymmetry in the deﬁnitions of the positive and negative regions.
For the positive region the interior of ζ does not intersect the isocontour, while
for the negative region the entire path ζ must not intersect the isocontour. Thus,
the positive region contains the isocontour while the negative region does not.
The positive region is also closed. Any point within the positive region that does
not lie in the isocontour has a neighborhood contained in the positive region.
Every negative vertex is contained in the negative region since the zero-length
path connects the vertex to itself. Similarly, every positive vertex is contained
in the positive region.
Let R+
c be the positive region for a grid square c. We claim that positive and
negative regions agree on the grid square boundaries. For instance, in Figure 2.11
R+
c1 ∩e1 equals R+
c2 ∩e1 where R+
c1 and R+
c2 are the positive regions for grid
squares c1 and c2, respectively, and e1 is the edge between c1 and c2. Similarly,
R+
c2 ∩e2 equals R+
c3 ∩e2 and R+
c3 ∩e3 equals R+
c4 ∩e3.
Lemma 2.4. Let c1 and c2 be adjacent grid squares where each vertex of c1 and
c2 has a positive or a negative label. Let p be a point in c1 ∩c2. Point p is in
R+
c1 if and only if p is in R+
c2.
Proof: If p is a grid vertex, then p is in R+
c1 and R+
c2 if it is positive and not in
R+
c1 or R+
c2 if it is negative. Otherwise, p must be in the interior of some grid
edge e. If edge e is positive, then p is in R+
c1 and R+
c2. If edge e is negative, then
p is not in R+
c1 or R+
c2. If one endpoint, v1, is positive and the other endpoint,
v2, is negative, then the isocontour in both grid squares intersects the grid edge
in the same interpolated point q. The closed segment [v1, q] is in both R+
c1 and
R+
c2 while the segment (q, v2] (open at q and closed at v2) is in neither. Thus if
p is in [v1, q], then p is in both R+
c1 and R+
c2 and if p is in (q, v2], then p is in
neither.
□
Using Lemma 2.4, we prove that the isocontour separates positive vertices
from negative ones.

28
2. Marching Cubes and Variants
Property 5.
The isocontour separates positive grid vertices from negative grid
vertices and strictly separates strictly positive grid vertices from negative grid
vertices.
Proof: For all the possible conﬁgurations, a path from a positive vertex to a
negative one in a grid square must intersect the isocontour. We must show that
this also holds true for paths through many grid squares.
Let R+ be the union of the positive regions over all the grid squares. Consider
a path ζ in the grid from a positive grid vertex to a negative one. The positive
grid vertex lies in R+ while the negative one does not. Thus ζ must intersect some
point p on the boundary of R+ where it crosses out of R+. Every neighborhood
of p must contain points that are not in R+.
Since R+ is closed, point p lies in R+. Thus point p lies in R+
c′ for some grid
square c′. By Lemma 2.4, point p lies in R+
c for every grid square c containing
p. Assume p is not on the isocontour. Within each grid square containing p,
some neighborhood of p is contained in the positive region for that grid square.
The union of those neighborhoods is a neighborhood of p within the grid and is
contained in R+. Thus ζ does not cross out of R+ at p. We conclude that p must
lie on the isocontour and that ζ intersects the isocontour. Thus the isocontour
separates positive from negative grid vertices.
If the scalar value of a grid vertex does not equal the isovalue, then the grid
vertex does not lie on the isocontour. Thus the isocontour strictly separates
strictly positive grid vertices from negative ones. (By deﬁnition, the scalar value
of a negative vertex never equals the isovalue.)
□
To prove properties 6 and 7, we prove something slightly more general.
Proposition 2.5. Let p be any point on the Marching Squares isocontour that
is not a grid vertex with scalar value equal to the isovalue.
1. If p is in the interior of the grid, then the isocontour restricted to some
suﬃciently small neighborhood of p is a 1-manifold.
2. If p is on the boundary of the grid, then the isocontour restricted to some
suﬃciently small neighborhood of p is a 1-manifold with boundary.
Proof: Let v be a grid vertex with scalar value sv. If sv is not the isovalue, then
the isocontour does not contain v, so point p is not v. If sv equals the isovalue,
then, by assumption, point p is not v. Therefore, point p is not a grid vertex.
If p lies in the interior of a grid square, then it lies in the interior of some
isocontour edge. The interior of this edge is a 1-manifold containing p.
Assume p lies on the boundary of a grid square but not on the boundary of
the grid. Since p is not a grid vertex, point p must lie in the interior of some
grid edge e with one positive and one negative vertex. The two grid squares
containing e each contain a single contour edge with endpoint at p. The interior
of these two contour edges and the point p form a 1-manifold containing p.

2.2. Marching Squares
29
Finally, assume p lies on the boundary of the grid. Since p is not a grid
vertex, point p is contained in a single grid square. This grid square contains
a single contour edge with endpoint at p. This contour edge is a manifold with
boundary containing p.
□
Properties 6 and 7 apply to Marching Squares isocontours whose isovalues
do not equal the scalar value of any grid vertex.
Property 6.
The isocontour is a piecewise linear 1-manifold with boundary.
Property 7.
The boundary of the isocontour lies on the boundary of the grid.
Proof of Properties 6 & 7: Consider a point p on the isocontour. Since the isovalue
does not equal the scalar value of any grid vertex, point p is not a grid vertex. By
Proposition 2.5, the isocontour restricted to some suitably small neighborhood of
point p is either a 1-manifold or a 1-manifold with boundary. Thus the isocontour
is a 1-manifold with boundary. Since the restricted isocontour is a 1-manifold
whenever p is in the interior of the grid, the boundary of the isocontour must lie
on the grid boundary.
□
The last property is that Υ does not contain any zero-length or duplicate
edges and forms a triangulation of the isocontour.
Property 8.
Set Υ does not contain any zero-length line segments or dupli-
cate line segments, and the line segments in Υ form a “triangulation” of the
isocontour.
Proof: Since no grid vertex has scalar value equal to the isovalue, no isocontour
vertex lies on a grid vertex. By Property 4, each bipolar grid edge contains only
one isocontour vertex. Thus, the linear interpolation on isocontour vertices does
not create any zero-length or duplicate isocontour edges. Since isocontour edges
intersect only at their endpoints, Υ forms a triangulation of the isocontour.
□
2.2.5
2D Ambiguity
Set E+/−
κ
is the set of bipolar square edges for conﬁguration κ. The combinatorial
structure of the isocontour depends upon the matching of the elements of E+/−
κ
.
If E+/−
κ
has two elements, then there is no choice. However, if E+/−
κ
has four
bipolar edges, then there are two possible pairings and two possible isocontours
that could be constructed for conﬁguration κ. Conﬁgurations 8 and 16 from
Figure 2.2 have four bipolar edges.
They are called ambiguous conﬁgurations.
These two ambiguous conﬁgurations are shown in Figure 2.12 along with the
two combinatorially distinct isocontours for each ambiguous conﬁguration.
Choosing diﬀerent isocontours for the ambiguous conﬁgurations will change
the topology of the overall isocontour. For instance, Figure 2.13 shows the same

30
2. Marching Cubes and Variants
8−I
16−I
16−II
8−II
16
8
Figure 2.12. Ambiguous square conﬁgurations.
1
4
2
2
2
2
1
1
2
1
2
2
4
2
1
1
1
4
2
2
2
2
1
1
2
1
2
2
4
2
1
1
Figure 2.13. Topologically distinct isocontours created by using diﬀerent isocontours
for the ambiguous conﬁguration in the central grid square.
scalar grid with two topologically distinct isocontours created by diﬀerent resolu-
tions of the ambiguous conﬁgurations. The ﬁrst isocontour has two components
while the second has one.
While the choice of isocontours for the ambiguous conﬁgurations changes
the isocontour topology, any of the choices will produce isocontours that are 1-
manifolds and strictly separate strictly positive vertices from negative vertices.
As we shall see, this is not true in three dimensions.
2.3
Marching Cubes
2.3.1
Algorithm
The three-dimensional Marching Cubes algorithm follows precisely the steps
in the two-dimensional Marching Squares algorithm. Input to the March-

2.3. Marching Cubes
31
Read isosurface lookup table

For each grid cube, retrieve isosurface triangles

Compute isosurface vertex coordinates using linear interpolation
Figure 2.14. Marching Cubes.
ing Cubes algorithm is an isovalue and a set of scalar values at the vertices of a
three-dimensional regular grid. The algorithm has three steps. (See Figure 2.14.)
Read the isosurface lookup table from a preconstructed data ﬁle. For each cube,
retrieve from the lookup table a set of isosurface triangles representing the com-
binatorial structure of the isosurface. The vertices of these triangles form the
isosurface vertices. Assign geometric locations to the isosurface vertices based
on the scalar values at the cube edge endpoints. We explain the last two steps
below.
Grid vertices are labeled positive or negative as described in Section 2.1. Grid
edges are labeled positive, negative, or bipolar.
The combinatorial structure of the isosurface within each cube is determined
from the conﬁguration of the cube’s vertex labels. In order to separate the posi-
tive vertices from the negative ones, the isosurface must intersect any cube edge
that has one positive and one negative endpoint. An isosurface that intersects
a minimal number of grid edges will not intersect any edge whose endpoints are
both strictly positive or whose endpoints are both negative.
Since each vertex is either positive or negative and a cube has eight vertices,
there are 28 = 256 diﬀerent conﬁgurations of cube vertex labels. Many of these
conﬁgurations are rotations or reﬂections of one another.
By exploiting this
symmetry, the number of distinct conﬁgurations can be reduced to twenty-two.1
These distinct conﬁgurations are listed in Figure 2.15. All other conﬁgurations
are rotations or reﬂections of these twenty-two.
For each cube conﬁguration κ, let E+/−
κ
be the set of edges with one positive
and one negative endpoint. The isosurface lookup table contains 256 entries,
one for each conﬁguration κ. Each entry is a list of triples of edges of E+/−
κ
.
Each triple (e1, e2, e3) represents a triangle whose vertices lie on e1, e2, and e3.
The list of triples deﬁne the combinatorial structure of the isosurface patch for
1Lorensen and Cline’s original paper on Marching Cubes [Lorensen and Cline, 1987a] listed
only ﬁfteen conﬁgurations. For reasons discussed in Section 2.3.5, twenty-two conﬁgurations
are preferable.

32
2. Marching Cubes and Variants
Zero
One
Two
Three
Four
Five
Six
Seven
Eight
2A
2B
2C
0
1
3A
3B
3C
4A
4B
4C
4D
4E
4F
5A
5B
5C
6A
6B
6C
7
8
# Positive
Vertices
Figure 2.15. Twenty-two distinct cube conﬁgurations. Black vertices are positive.

2.3. Marching Cubes
33
# Positive
Vertices
Zero
One
Two
Three
Four
Five
Six
Seven
Eight
2A
2C
0
1
3A
3B
3C
4A
4B
4C
4D
4E
4F
5A
5B
5C
6A
6B
6C
7
8
2B
Figure 2.16. Isosurfaces for twenty-two distinct cube conﬁgurations.

34
2. Marching Cubes and Variants
(a)
(b)
Figure 2.17. (a) Adjacent conﬁgurations sharing a common face. (b) Incompatible
isosurface patches for the adjacent conﬁgurations.
Figure 2.18.
Compatible isosurface patches for adjacent conﬁgurations in Fig-
ure 2.17(a).
conﬁguration κ. The isosurface patch intersects every edge of E+/−
κ
exactly once
and does not intersect any other grid cube edges.
To deﬁne the 256 entries in the table, it is only necessary to determine the
table entries for the twenty-two distinct conﬁgurations. The table entries for
the other conﬁgurations can be derived using rotation and reﬂection symme-
try. Figure 2.16 contains the twenty-two distinct cube conﬁgurations and their
isosurfaces.
The isosurface lookup table is constructed on the unit cube with vertices
(0, 0, 0), (1, 0, 0), (0, 1, 0), . . ., (0, 1, 1), (1, 1, 1). To construct the isosurface in grid
cube (i, j, k), we have to map unit cube edges to edges of cube (i, j, k). Each
vertex v = (vx, vy, vz) of the unit cube maps to v + (i, j, k) = (vx, vy, vz) +
(i, j, k) = (vx + i, vy + j, vz + k). Each edge e of the unit square with endpoints
(v, v′) maps to edge e + (i, j, k) = (v + (i, j, k), v′ + (i, j, k)). Finally, each edge
triple (e1, e2, e3) maps to (e1 + (i, j, k), e2 + (i, j, k), e3 + (i, j, k)).
In Figure 2.16, the isosurface vertices lie on the midpoints of the grid edges.
This is for illustration purposes only. The geometric locations of the isosurface
vertices are not deﬁned by the lookup table.
The vertices of the isosurface triangles are the isosurface vertices. To map
each isosurface triangle to a geometric triangle, we use linear interpolation to
position the isosurface vertices as described in Section 1.7.2. Each isosurface
vertex v lies on a grid edge [p, q]. If sp and sq are the scalar values at p and q
and σ is the isovalue, then map v to (1 −α)p + q where α = (σ −sp)/(sq −sp).

2.3. Marching Cubes
35
Input
: F is a 3D array of scalar values.
Coord is a 3D array of (x, y, z) coordinates.
σ is an isovalue.
Result
: A set Υ of isosurface triangles.
MarchingCubes(F, Coord, σ, Υ)
1 Read Marching Cubes lookup table into Table;
/* Assign “+” or “−” signs to each vertex
*/
2 foreach grid vertex (i, j, k) do
3
if F[i, j, k] < σ then Sign[i, j, k] ←“−”;
4
else Sign[i, j, k] ←“+”;
/* F[i, j, k] ≥σ */
5 end
6 T ←∅;
/* For each grid cube, retrieve isosurface triangles
*/
7 foreach grid cube (i, j, k) do
/* Cube vertices are (i, j, k), (i+1, j, k), . . . , (i+1, j+1, k+1)
*/
8
κ ←(Sign[i, j, k], Sign[i+1, j, k], Sign[i, j+1, k], . . ., Sign[i+1, j+1, k+1]);
9
foreach edge triple (e1, e2, e3) ∈Table[κ] do
10
Insert edge triple (e1 + (i, j, k), e2 + (i, j, k), e3 + (i, j, k)) into T;
11
end
12 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
13 foreach bipolar grid edge e with endpoints (i1, j1, k1) and (i2, j2, k2) do
/* Compute the isosurface vertex we on edge e
*/
14
we ←LinearInterpolation
15
(Coord[i1, j1, k1], F[i1, j1, k1], Coord[i2, j2, k2], F[i2, j2, k2], σ);
16 end
/* Convert T to set of triangles
*/
17 Υ ←∅;
18 foreach triple of edges (e1, e2, e3) ∈T do
19
Υ ←Υ ∪{(we1, we2, we3)};
20 end
Algorithm 2.2. Marching Cubes.
Note that since p and q have diﬀerent sign, scalar sp does not equal sq and the
denominator (sq −sp) is never zero.
The Marching Cubes algorithm is presented in Algorithm 2.2. Function
LinearInterpolation, called by this algorithm, is deﬁned in Algorithm 1.1 in
Section 1.7.2.
Two conﬁgurations can be adjacent to one another if the face they share in
common has the same set of positive and negative vertices. Figure 2.17 contains

36
2. Marching Cubes and Variants
(a)
(b)
Figure 2.19. (a) Spherical isosurface of noisy point cloud. (b) Isosurface of noisy point
cloud constructed using incorrect isosurface lookup table. The sphere interior is colored
red and is visible through holes in the sphere. The holes are caused by incompatible
isosurface patches in the isosurface lookup table.
an example of two such conﬁgurations. The isosurface patches for each conﬁg-
uration should be constructed so that their boundaries align on the common
face. As shown in Figure 2.17, two reasonable isosurface patches for adjacent
conﬁgurations can have boundaries that do not align on the common face and
so are incompatible.
Isosurfaces constructed using such incompatible isosur-
face patches for adjacent conﬁgurations may have “holes” and may not be a
2-manifold. (See Figure 2.19.) Compatible isosurface patches for the conﬁgura-
tion in Figure 2.17(a) are given in Figure 2.18.
The isosurface patches for the twenty-two distinct conﬁgurations in Fig-
ure 2.16 were constructed so that they and all the 256 derived conﬁgurations
are compatible. The isosurface patch boundaries align on the common face of
any two adjacent conﬁgurations. As will be discussed in Section 2.3.5, Lorensen
and Cline’s original Marching Cubes algorithm [Lorensen and Cline, 1987a]
lacked this property.
If the constructed isosurface is a manifold, then the manifold is orientable.
After the construction of the isosurface, the isosurface can be assigned an orien-
tation by assigning consistent orientations to all its triangles. However, a better
approach is to properly orient the triangles in the lookup table. Each isosurface
patch in a lookup table entry separates a positive region from a negative one. As
noted in Section 1.7.1, a triangle orientation determines a vector orthogonal to
the triangle. Orient each triangle in the isosurface patch so that the induced or-
thogonal vector points toward the positive region. Retrieve the oriented triangles
from the lookup table to determine the orientation of the isosurface triangles.
The orientations of the triangles are consistent and form an orientation of the
isosurface.

2.3. Marching Cubes
37
2.3.2
Running Time
The Marching Cubes algorithm runs in linear time.
Proposition 2.6. Let N be the total number of vertices of a 3D scalar grid. The
running time of the Marching Cubes algorithm on the scalar grid is Θ(N).
The proof is similar to the proof for the 2D Marching Squares algorithm
in Section 2.2.2 and is omitted.
2.3.3
Isosurface Properties
The isosurface produced by the Marching Cubes algorithm has the same prop-
erties as the isocontour produced by the Marching Squares algorithm. As in
the 2D version, we diﬀerentiate between the case where the isovalue equals the
scalar value of one or more grid vertices and the case where it does not. If the
isovalue does not equal the scalar value of any grid vertices, then the isosurface
is a piecewise linear, orientable 2-manifold with boundary. If the isovalue equals
the scalar value of some grid vertex, then the isosurface may not be a 2-manifold
and the isosurface may have zero-length edges and zero-area triangles.
Marching Cubes returns a ﬁnite set, Υ, of oriented triangles. The isosur-
face is the union of these triangles. The vertices of the isosurface are the triangle
vertices.
The following properties apply to all isosurfaces produced by the Marching
Cubes algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on grid edges.
Property 3.
The isosurface intersects every bipolar grid edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
grid edges.
Property 5.
The isosurface separates positive grid vertices from negative ones
and strictly separates strictly positive grid vertices from negative grid vertices.
Properties 3 and 4 imply that the isosurface intersects a minimum number
of grid edges. As in two dimensions, if both endpoints of a grid edge have scalar
value equal to the isovalue, then the isosurface may intersect the grid edge zero,
one, or two times or may contain the grid edge.
By Property 3, the isosurface intersects every bipolar grid edge. However,
the bipolar grid edge may be intersected by zero-area isosurface triangles.

38
2. Marching Cubes and Variants
The following properties apply to the Marching Cubes isosurfaces whose
isovalues do not equal the scalar value of any grid vertex.
Property 6.
The isosurface is a piecewise linear, orientable 2-manifold with
boundary.
Property 7.
The boundary of the isosurface lies on the boundary of the grid.
Property 8.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
Scanning devices usually produce data sets whose scalar values are 8-bit,
12-bit, or 16-bit integers. For such data sets, a Marching Cubes isosurface
with noninteger isovalues has no degenerate triangles and is always a manifold.
Typically, the isovalue (x + 0.5) is used, where x is some integer.
2.3.4
Proof of Isosurface Properties
We give a proof of each of the properties listed in Section 2.3.3. The proofs are
the same as the proofs for Marching Squares isocontours.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on grid edges.
Proof of Properties 1 & 2: The Marching Cubes isosurface consists of a ﬁnite
set of triangles, so it is piecewise linear. By construction, the vertices of these
triangles lie on the grid edges.
□
Property 3.
The isosurface intersects every bipolar grid edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
grid edges.
Proof of Properties 3 & 4: Each isosurface triangle is contained in a grid cube.
Since the grid cubes are convex, only isosurface triangles with vertices on the
grid edge intersect the grid edge. If the grid edge has one positive and one neg-
ative endpoint, the unique location of the isosurface vertex on the grid edge is
determined by linear interpolation. Thus the isosurface intersects a bipolar grid
edge at exactly one point.
If the grid edge is negative or strictly positive, then no isosurface vertex lies
on the grid edge.
Thus the isosurface does not intersect negative or strictly
positive grid edges.
□

2.3. Marching Cubes
39
Zero
One
Two
Three
Four
Five
Six
Seven
Eight
2A
2C
0
1
3A
3B
3C
4A
4B
4C
4D
4E
4F
5A
5B
5C
6A
6C
7
8
2B
6B
# Positive
Vertices
Figure 2.20. Positive regions (red) for the twenty-two distinct cube conﬁgurations.
Visible portion of each isosurface is green. Portion of the isosurface behind each positive
region is colored dark red.

40
2. Marching Cubes and Variants
c1
c2
f
f
Figure 2.21. Adjacent cubes c1 and c2 and (red) positive regions R+
c1 and R+
c2. Black
cube vertices are positive. Shared facet f lies between the two cubes. Note that R+
c1 ∩f
equals R+
c2 ∩f.
The proof of Property 5, the separation property, is similar to the proof of
Property 5 for the Marching Squares isosurface (Section 2.2.4).
We ﬁrst
extend the deﬁnition of positive and negative regions from grid squares to grid
cubes.
Within each grid cube the isosurface partitions the grid cube into two regions.
Deﬁne the positive region for a grid cube c to be points p ∈c where some path
ζ ⊂c connects p to a positive vertex of c and the interior of ζ does not intersect
the isosurface (Figure 2.20). Deﬁne the negative region for a grid cube c to be
points p ∈c where some path ζ ⊂c connects p to a negative vertex of c and
ζ does not intersect the isosurface. Since any path ζ ⊂c from a positive to a
negative vertex must intersect the isosurface, the positive and negative regions
form a partition of the cube c.
The positive region is closed and contains the isosurface. Any point within the
positive region that does not lie on the isosurface has a neighborhood contained
in the positive region.
Every negative vertex is contained in the negative region since the zero-
length path connects the vertex to itself. Every positive vertex is contained in
the positive region since a path in a cube from any negative cube vertex to a
positive one must intersect the isosurface.
We claim that positive and negative regions agree on the grid cube boundaries
(Figure 2.21). Let R+
c be the positive region for a grid cube c.
Lemma 2.7. Let c1 and c2 be adjacent grid cubes where each vertex of c1 and c2
has a positive or a negative label. Let p be a point in c1 ∩c2. Point p is in R+
c1
if and only if p is in R+
c2.
The proof of Lemma 2.7 is based on an exhaustive examination of all possible
adjacent conﬁgurations and is omitted. A more detailed and satisfying analysis
is given in Chapter 5, which contains an algorithm for generating the lookup
table for the Marching Cubes and similar algorithms.

2.3. Marching Cubes
41
Using Lemma 2.7, we prove that the isosurface separates positive vertices
from negative ones.
Property 5.
The isosurface separates positive grid vertices from negative ones
and strictly separates strictly positive grid vertices from negative grid vertices.
Proof: For all the possible conﬁgurations, a path from a positive vertex to a
negative one in a grid cube must intersect the isosurface. We must show that
this also holds true for paths through many grid cubes.
Consider a path ζ in the grid from a positive grid vertex to a negative one.
The positive grid vertex lies in R+ while the negative one does not. Thus ζ must
intersect some point p on the boundary of R+ where it crosses out of R+. Every
neighborhood of p must contain points that are not in R+.
Since R+ is closed, point p lies in R+. Thus point p lies in R+
c′ for some
grid cube c′. By Lemma 2.7, point p lies in R+
c for every grid cube c containing
p. If p does not lie on the isosurface, then some neighborhood of p is contained
in the positive region R+
c of each grid cube c containing p. The union of those
neighborhoods is a neighborhood of p within the grid and is contained in R+.
Thus ζ does not cross out of R+ at p.
We conclude that p must lie on the
isosurface and that ζ intersects the isosurface. Thus the isosurface separates
positive from negative grid vertices.
If the scalar value of a grid vertex does not equal the isovalue, then the
grid vertex does not lie on the isosurface. Thus the isosurface strictly separates
strictly positive grid vertices from negative ones. (By deﬁnition, the scalar value
of a negative vertex never equals the isovalue.)
□
As in two dimensions, to prove Properties 6 and 7, we ﬁrst prove something
slightly more general.
Proposition 2.8. Let p be any point on the Marching Cubes isosurface that is
not a grid vertex with scalar value equal to the isovalue.
1. If p is in the interior of the grid, then the isosurface restricted to some
suﬃciently small neighborhood of p is a 2-manifold.
2. If p is on the boundary of the grid, then the isosurface restricted to some
suﬃciently small neighborhood of p is a 2-manifold with boundary.
Proof: Let v be a grid vertex with scalar value sv. If sv is not the isovalue, then
the isosurface does not contain v, so point p is not v. If sv equals the isovalue,
then, by assumption, point p is not v. Therefore, point p is not a grid vertex.
If p lies in the interior of a grid cube, then it lies in the interior of some
isosurface patch. The interior of this patch is a 2-manifold containing p.
Assume p lies on the boundary of a grid cube but not on the boundary of the
grid. Since p is not a grid vertex, point p either lies in the interior of a grid edge

42
2. Marching Cubes and Variants
or the interior of a square grid facet. If point p lies in the interior of a square
grid facet, then it is contained in two isosurface triangles lying in two adjacent
grid cubes. The interior of the union of these two isosurface triangles forms a
2-manifold containing p. If point p lies in the interior of a grid edge e, then p
is contained in four isosurface patches lying in the four grid cubes containing e.
The interior of the union of these four patches forms a 2-manifold containing p.
Finally, assume p lies on the boundary of the grid. Since p is not a grid
vertex, point p either lies in one or two grid cubes. If p lies in a single grid cube,
then a single isosurface triangle in this grid cube contains p. This triangle is
a 2-manifold with boundary containing p. If p lies in two grid cubes, then the
union of the isosurface patches in these two grid cubes form a 2-manifold with
boundary containing p.
□
Properties 6 and 7 apply to Marching Cubes isosurfaces whose isovalues
do not equal the scalar value of any grid vertex.
Property 6.
The isosurface is a piecewise linear, orientable 2-manifold with
boundary.
Property 7.
The boundary of the isosurface lies on the boundary of the grid.
Proof of Properties 6 & 7: Consider a point p on the isosurface. Since the isovalue
does not equal the scalar value of any grid vertex, point p is not a grid vertex. By
Proposition 2.8, the isosurface restricted to some suitably small neighborhood of
point p is either a 2-manifold or a 2-manifold with boundary. Thus the isosurface
is a 2-manifold with boundary. All of the triangles in the isosurface are oriented
so that the induced orthogonal vector points toward the positive vertices; thus,
all the triangle orientations are consistent and the manifold is orientable.
Since the restricted isosurface is a 2-manifold whenever p is in the interior of
the grid, the boundary of the isosurface must lie on the grid boundary.
□
The last property is that Υ does not contain any zero-area or duplicate tri-
angles and forms a triangulation of the isosurface.
Property 8.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
Proof: Since no grid vertex has scalar value equal to the isovalue, no isosurface
vertex lies on a grid vertex. By Property 3, each bipolar grid edge contains only
one isosurface vertex. Thus, the linear interpolation on isosurface vertices does
not create any zero-area or duplicate isosurface triangles. The isosurface triangles
within a grid cube are a subset of the triangulation of an isosurface patch and
so the nonempty intersection of any two such triangles is either a vertex or an
edge of both. The isosurface patches in Figure 2.16 were constructed so that
the intersection of any two isosurface triangles in adjacent grid cubes is either a
vertex or an edge of both. Since the nonempty intersection of any two triangles
in Υ is a face of both triangles, Υ forms a triangulation of the isosurface.
□

2.3. Marching Cubes
43
2.3.5
3D Ambiguity
The 256 conﬁgurations of positive and negative vertices are generated from the
twenty-two conﬁgurations in Figure 2.15 using rotational and reﬂection symme-
try. There is another kind of symmetry that is not being used. Conﬁguration κ1
is the complement of conﬁguration κ2 if κ1 can be derived from κ2 by switching
κ2’s positive and negative vertex labels. The conﬁgurations with ﬁve, six, seven,
or eight positive vertices are all complements of conﬁgurations with three, two,
one, and zero positive vertices. Complementary symmetry reduces the number
of unique conﬁgurations from twenty-two to fourteen.
Unfortunately, complementary symmetry creates incompatible isosurface
patches in the isosurface table. For instance, the conﬁguration on the left in
Figure 2.17 is a rotation of conﬁguration 6B from Figure 2.15 while the conﬁg-
uration on the right is a rotation of conﬁguration 2B. Conﬁguration 2B is the
complement of conﬁguration 6B. Both isosurface patches on the left and on the
right come from a rotation of the isosurface patch for 6B in Figure 2.16. The
boundaries of the isosurface patches clearly do not align on the square between
the two cubes.
Lorensen and Cline’s paper [Lorensen and Cline, 1987a] used complementary
symmetry and so created incompatible isosurface patches in the isosurface table
[D¨urst, 1988].2 The problem conﬁgurations were the ones that had ambiguous
conﬁgurations on their square facets. These are conﬁgurations 2B, 3B, 3C, 4C,
4E, 4F, 5B, 5C and 6B. Numerous papers were written on how to handle these
problematic conﬁgurations.
The most widely adopted approach, proposed in
[Montani et al., 1994] and in [Zhou et al., 1994], is to simply drop complementary
symmetry. This is the approach adopted in the previous section.
As discussed in Section 2.2.5, the two-dimensional ambiguous conﬁgurations
have two isocontour edges and two combinatorially diﬀerent ways to position
those edges.
One of these edge positions separates the two negative vertices
by isocontour edges (8-I and 16-I in Figure 2.12) while the other separates the
positive vertices (8-II and 16-II in Figure 2.12).
The border of a cube’s three-dimensional isosurface patch deﬁnes an isocon-
tour on each of the cube’s square facets. If some conﬁguration’s isosurface patch
separates the negative vertices on the facet while an adjacent conﬁguration’s
isosurface patch separates the positive ones, then the isosurface edges on the
common facet will not align. The isosurface patches in Figure 2.16 do not sepa-
rate the positive vertices on any facet.3 Moreover, the derived isosurface surface
patches in any rotation or reﬂection of the conﬁgurations also do not separate
positive vertices on any facet. Thus the isosurface patches in any two adjacent
2Lorensen and Cline’s paper did not use reﬂection symmetry and so they had ﬁfteen, not
fourteen, distinct conﬁgurations.
3Note that in conﬁguration 2C, the two positive vertices do not share a facet. The isosurface
patch separates the two positive vertices, but not on any facet. Since these vertices do not
share a facet, the isosurface patch aligns with all possible adjacent conﬁgurations.

44
2. Marching Cubes and Variants
2C−I
2C−II
6C−I
6C−II
3C−I
4E−II
3C−II
3B−I
2B−I
4C−I
4E−I
4F−I
4F−II
4C−II
3B−II
6B−I
2B−II
5B−I
5C−I
5C−II
5B−II
6B−II
Figure 2.22. Two “natural” isosurface patches for the ambiguous 3D conﬁgurations.
Isosurface patches in the ﬁrst and third rows separate negative vertices.
Isosurface
patches in the second and fourth rows separate positive vertices.
cubes are properly aligned on their boundaries. An equally valid, but combina-
torially distinct, isosurface table could be generated by using isosurface patches
that do not separate the negative vertices on any square facet.
The ambiguous conﬁgurations in R3 are 2B, 2C, 3B, 3C, 4C, 4E, 4F, 5B,
5C, 6B and 6C. These conﬁgurations have topologically distinct piecewise linear
isosurfaces with all the properties listed in the previous section.
Ambiguous
conﬁgurations admit two “natural” isosurface patches, one separating positive
vertices and one separating negative vertices. (See Figure 2.22.)
As we have already discussed, conﬁgurations 2B, 3B, 3C, 4C, 4E, 4F, 5B, 5C
and 6B have square facets with ambiguous 2D conﬁgurations. Conﬁgurations 2C
and 6C are the exceptions.4 None of their square facets have an ambiguous con-
ﬁguration, yet they admit two topologically distinct piecewise linear isosurfaces.
(See Figure 2.22.) Usually, isosurface patches 2C-II and 6C-I are used since they
each require only two isosurface triangles and do not create the “tunnel” in 2C-I
and 6C-II.
4The numerous papers on resolving the ambiguous 3D conﬁgurations do not discuss these
two, but they do admit topologically distinct isosurfaces and they are ambiguous.

2.4. Marching Tetrahedra
45
Figure 2.23. Curvilinear grid. Grid cells are quadrilaterals.
2.3.6
Curvilinear Grids
Sections 2.2 and 2.3 describe the Marching Squares and Marching Cubes
algorithms for regular grids where each grid element is a geometric square or
cube. These algorithms work equally well for curvilinear grids that have the
same combinatorial structure as regular grids but whose elements are convex
quadrilaterals or hexahedra. (See Figure 2.23.) The grid vertices are assigned
positive and negative labels just as in the case of the regular grid. The same
lookup table is used to determine the combinatorial structure of each isocontour
or isosurface patch within a grid element. The isosurface geometry is determined
by using linear interpolation to position the grid vertices along each grid edge.
2.4
Marching Tetrahedra
The Marching Cubes algorithm applies to regular and curvilinear grids. How-
ever, many applications decompose space into unstructured tetrahedral meshes
composed of tetrahedral mesh elements. Marching Tetrahedra is a modiﬁed
version of the Marching Cubes algorithm.
2.4.1
Algorithm
Input to the Marching Tetrahedra algorithm is an isovalue, a tetrahedral
mesh, and a set of scalar values at the vertices of the tetrahedra. The mesh
tetrahedra must form a triangulation of some three-dimensional region, i.e., the
intersection of any two tetrahedra is a vertex, edge, or facet of both tetrahedra
or is empty.

46
2. Marching Cubes and Variants
Read isosurface lookup table for tetrahedra

For each mesh tetrahedron, retrieve isosurface triangles

Compute isosurface vertex coordinates using linear interpolation
Figure 2.24. Marching Tetrahedra.
6
7
8
1
2
3
4
5
14
15
16
9
10
11
12
13
Figure 2.25. Tetrahedral conﬁgurations. Black vertices are positive.
The algorithm has three steps. (See Figure 2.24.) Read in the isosurface
lookup table from a preconstructed data ﬁle.
For each tetrahedron, retrieve
from the lookup table a set of isosurface triangles representing the combinatorial
structure of the isosurface. The endpoints of these edges form the isosurface
vertices. Assign geometric locations to the isosurface vertices based on the scalar
values at the triangle edge endpoints. We explain the last two steps next.
Mesh vertices are labeled positive or negative, as described in Section 2.1.
Mesh edges are labeled positive, negative, or bipolar.
Since each vertex is either positive or negative and a tetrahedron has four
vertices, there are 24 = 16 diﬀerent conﬁgurations of tetrahedron vertex labels.
These conﬁgurations are listed in Figure 2.25. Applying aﬃne transformations,
only ﬁve of these conﬁgurations are distinct (Figure 2.26).
The combinatorial structure of the isosurface within each tetrahedron is de-
termined from the conﬁguration of the tetrahedron’s vertex labels. In order to
separate the positive vertices from the negative ones, the isosurface must inter-
sect a tetrahedron edge that has one positive and one negative endpoint. An
isosurface which intersects a minimal number of mesh edges will not intersect
any edge whose endpoints are both strictly positive or both negative.
Each isosurface patch separates the tetrahedron into two regions, a positive
one containing the positive vertices and a negative one containing the negative

2.4. Marching Tetrahedra
47
2
3
4
1
0
Figure 2.26. Distinct tetrahedral conﬁgurations. Conﬁguration k has exactly k positive
(black) vertices.
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
Figure 2.27. Tetrahedral isosurface patches.
vertices. Each tetrahedron on the isosurface patch is oriented so that the induced
normal points to the positive region.
In Figure 2.27, the isosurface vertices lie on the midpoints of the grid edges.
This is for illustration purposes only. The geometric locations of the isosurface
vertices are not deﬁned by the lookup table.
For each tetrahedral conﬁguration κ, let E+/−
κ
be the set of edges with one
positive and one negative endpoint.
The isosurface lookup table contains 16
entries, one for each conﬁguration κ. Each entry is a list of triples of edges of
E+/−
κ
. Each triple (e1, e2, e3) represents an oriented triangle whose vertices lie
on e1 and e2 and e3. The orientation of the triangle is given by the order, e1,
e2, e3. The list of triples deﬁnes the combinatorial structure of the isosurface
patch for conﬁguration κ. The isosurface patch intersects every edge of E+/−
κ
exactly once and does not intersect any other grid tetrahedron edges.
To determine the isosurface patch for a speciﬁc mesh tetrahedron, match the
vertices of the mesh tetrahedron to the vertices of the tetrahedron in the lookup
table by numbering the vertices of the mesh tetrahedron from 1 to 4. The vertex
numbering can be arbitrary and will not aﬀect the isosurface topology, although
it may alter slightly the isosurface triangulation and geometry. Determine the
lookup table conﬁguration that matches the conﬁguration of positive and nega-
tive vertices in the mesh tetrahedron and retrieve the isosurface patch from the
lookup table.
To map each isosurface triangle to a geometric triangle, we use linear interpo-
lation to position the isosurface vertices as described in Section 1.7.2. Each iso-
surface vertex v lies on a grid edge [p, q]. If sp and sq are the scalar values at p and
q and σ is the isovalue, then map v to (1−α)p+αq where α = (σ−sp)/(sq −sp).

48
2. Marching Cubes and Variants
2.4.2
Isosurface Properties
The isosurface produced by Marching Tetrahedra has the same properties
as the isosurface produced by the Marching Cubes algorithm (Section 2.3.3).
The proofs are the same as the proofs in Section 2.3.4 and are omitted.
Marching Tetrahedra returns a ﬁnite set, Υ, of oriented triangles. The
isosurface is the union of these triangles. The vertices of the isosurface are the
triangle vertices.
The following properties apply to all isosurfaces produced by the Marching
Tetrahedra algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on grid edges.
Property 3.
The isosurface intersects every bipolar grid edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
grid edges.
Property 5.
The isosurface separates positive grid vertices from negative ones
and strictly separates strictly positive grid vertices from negative grid vertices.
Properties 3 and 4 imply that the isosurface intersects a minimum number
of grid edges. As with Marching Cubes, if both endpoints of a grid edge have
scalar value equal to the isovalue, then the isosurface may intersect the grid edge
zero, one, or two times or may contain the grid edge.
By Property 3, the isosurface intersects every bipolar grid edge. However,
the bipolar grid edge may be intersected by zero-area isosurface triangles.
Under appropriate conditions, the isosurface produced by Marching Tetra-
hedra is a 2-manifold with boundary. One condition is that the isovalue does
not equal the scalar value of any grid vertex. Marching Tetrahedra can be
applied to any tetrahedral mesh, as long as the tetrahedra form a triangulation.
As shown in Figure 2.28, the isosurface produced by Marching Tetrahedra
may not be a manifold, even if the isovalue does not equal the scalar value. The
problem is that the underlying space is not a manifold. A similar problem could
face an isosurface constructed by Marching Cubes from an arbitrary mesh of
cubes. In Section 2.3, we applied Marching Cubes to a regular grid whose
underlying space is a manifold.
Consider a tetrahedral mesh that has the following two conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The tetrahedral mesh is a partition of a 3-manifold with boundary.

2.4. Marching Tetrahedra
49
Figure 2.28. Non-manifold isosurface produced by Marching Tetrahedra.
The
tetrahedral mesh consists of two tetradedra sharing an edge. The region covered by
the tetrahedral mesh is not a manifold with boundary.
Under these conditions, the isosurface produced by Marching Tetrahedra
has the following two properties:
Property 6.
The isosurface is a piecewise linear, orientable 2-manifold with
boundary.
Property 7.
The boundary of the isosurface lies on the boundary of the grid.
Property 8.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
One signiﬁcant diﬀerence between Marching Cubes and Marching Tetra-
hedra is that Marching Tetrahedra has no ambiguous conﬁgurations. The
four vertices of each tetrahedron are connected by tetrahedron edges and each
such edge is intersected at most once by the isosurface, so there is no possible
ambiguity in the isosurface construction.
2.4.3
Cube Tetrahedralization
Marching Tetrahedra can be used for isosurface construction in regular grids
by tetrahedralizing the grid cubes. There are two distinct ways to tetrahedralize
a grid cube, one that breaks the cube into ﬁve tetrahedra and one that breaks
it into six. (See Figure 2.29.) The decomposition into ﬁve tetrahedra consists of
a single large tetrahedra in the cube center and four smaller tetrahedra cutting
oﬀfour corners of the cube. The decomposition into six tetrahedra consists of
six congruent tetrahedra that all share a diagonal edge between two opposing
corners of the cube.
The decomposition of a grid cube into tetrahedra creates diagonal edges on
the square facets of the cube. These diagonals must match the diagonals cre-
ated on adjacent cubes for the decomposition to be a triangulation. If all cubes

50
2. Marching Cubes and Variants
Figure 2.29. Subdivision of a cube into ﬁve or six tetrahedra.
(a)
(b)
Figure 2.30. (a) Duplicate tetrahedralizations of two cubes into ﬁve tetrahedra with
mismatching diagonals on the common face between the two cubes. (b) Alternating
tetrahedralization of cube into ﬁve tetrahedra with matching diagonals on common
faces between cubes.
are decomposed in the same manner into six tetrahedra, then these diagonals do
match. However, if the cubes are decomposed in the same manner into ﬁve tetra-
hedra, then the diagonals of adjacent cubes will fail to match (Figure 2.30(a)).
Two decompositions into ﬁve tetrahedra must be used in an alternating manner
for the diagonals to match (Figure 2.30(b)).
The regular grid cubes have ambiguous conﬁgurations while the tetrahe-
dral decomposition does not. What happened to the ambiguous conﬁgurations?
These conﬁgurations are resolved by the choice of triangulation. For instance,
in Figure 2.31, the ﬁrst triangulation gives an isosurface patch with two compo-

2.4. Marching Tetrahedra
51
Figure 2.31. Diﬀerent tetrahedralizations of a cube into six tetrahedra.
nents corresponding to 2B-II in Figure 2.22 while the second gives an isosurface
patch with one component corresponding to 2B-I.
Using Marching Tetrahedra on a triangulated regular grid in place of
Marching Cubes increases the number of triangles in resulting isosurfaces. The
size of that increase depends upon the diﬀerent conﬁgurations and the manner
in which the tetrahedral decomposition intersects those conﬁgurations.
2.4.4
Isocontouring a Triangular Mesh
A two-dimensional simpliﬁed version of Marching Tetrahedra can be used
to isocontour a triangular mesh.5 The simpliﬁed version does not require a table
lookup since each mesh triangle contains at most one isocontour edge.
Input to the isocontouring algorithm is an isovalue, a triangular mesh, and
a set of scalar values at the vertices of the mesh. The mesh triangles must form
a triangulation of some two-dimensional region, i.e., the intersection of any two
triangles must be a vertex or edge of both triangles or must be empty.
For each bipolar mesh edge [p, q], use linear interpolation to position the
isosurface vertex on [p, q] as described in Section 1.7.2. If sp and sq are the
scalar values at p and q and σ is the isovalue, then map the isosurface vertex to
αp + (1 −α)q where α = (sq −σ)/(sq −sp).
5While the name “Marching Triangles” might be appropriate for the two-dimensional ver-
sion of Marching Tetrahedra, the name is already used by Hilton et al. [Hilton et al.,
1996] for a completely diﬀerent algorithm that constructs a triangular mesh on an implicit
surface.

52
2. Marching Cubes and Variants
A triangle contains zero, one, two, or three positive vertices. If a triangle
contains one or two positive vertices, then it contains two mesh edges with one
positive and one negative endpoint. Connect the isocontour vertices lying on each
of these mesh edges by an isocontour edge. If the isovalue equals the isovalue of
exactly one of the triangle vertices v and is less than the isovalue of the other
two vertices, then the isocontour vertices for each of these mesh edges will both
be located at v. In that case, either connect them by a zero-length isocontour
edge or merge them into a single vertex.
The resulting isocontour has all the same properties listed in Section 2.2.3 as
the isocontour produced by Marching Squares. As with tetrahedral meshes,
triangular meshes have no ambiguous conﬁgurations of positive and negative
vertices.
2.5
Notes and Comments
Lorensen and Cline published the Marching Cubes algorithm in 1987 [Lorensen
and Cline, 1987a]. A year earlier, Wyvill, McPheeters, and Wyvill [Wyvill et al.,
1986] published a somewhat similar isosurface extraction algorithm, but without
the use of isosurface patch lookup tables. A US patent [Lorensen and Cline,
1987b] for the Marching Cubes algorithm was granted in 1987 and the patent
expired in 2005.
D¨urst [D¨urst, 1988] noted the problem discussed in Section 2.3.5 of incom-
patible surface patches in Lorensen and Cline’s isosurface lookup table. Mon-
tani, Scateni, and Scopigno [Montani et al., 1994] and Zhou, Shu, and Kankan-
halli [Zhou et al., 1994] proposed the corrected isosurface lookup tables described
in this chapter.
Wilhelms and Gelder [Gelder and Wilhelms, 1990] explored
diﬀerent techniques for consistently resolving ambiguous facets.
Nielson and
Hamann [Nielson and Hamann, 1991] used bilinear interpolation to resolve am-
biguous facets.
Their algorithm, the Asymptotic Decider, is described in
Chapter 4.
The Marching Tetrahedra algorithm was proposed by a number of peo-
ple [Bloomenthal, 1988,Bloomenthal, 1994,Carneiro et al., 1996,Payne and Toga,
1990, Shirley and Tuchman, 1990] although not necessarily under that name.
Chan and Purisima [Chan and Purisima, 1998] apply Marching Tetrahe-
dra to a tetrahedralization based on the body-centered cubic lattice. Theußl,
M¨oller, and Gr¨oller [Theußl et al., 2001] show that the body-centered cube lat-
tice provides more accurate sampling than the regular grid. Carr, M¨oller, and
Snoeyink [Carr et al., 2001, Carr et al., 2006b] discuss the eﬀects of diﬀerent
tetrahedral subdivisions on isosurfaces generation.
The cube conﬁgurations in Figure 2.15 are distinct under the transformations
of rotation and reﬂection. In [Banks et al., 2004], Banks, Linton, and Stockmeyer
discuss counting the number of distinct conﬁgurations of cubes, hypercubes, and
other convex polyhedra using computational group theory software.

2.5. Notes and Comments
53
The Marching Cubes algorithm does not produce good representations of
sharp edges or corners. Kobbelt et al. [Kobbelt et al., 2001] modiﬁed the March-
ing Cubes algorithm to more accurately reconstruct sharp edges and corners
when input is the distance to a given surface. Other algorithms for reproducing
sharp edges and corners are presented in [Ho et al., 2005] and [Schaefer and
Warren, 2004]. Dual contouring algorithms for reconstructing sharp edges and
corners are referenced in the notes and comments section of Chapter 3.
The algorithms in [Ho et al., 2005,Schaefer and Warren, 2004] and the dual
contouring algorithms can also create multiresolution isosurfaces (multiresolution
isosurfaces are deﬁned and discussed in Chapters 9 and 10). All the algorithms
for reconstructing sharp edges and corners require accurate measurements of the
gradients or surface normals at isosurface vertices.
The Marching Cubes and Marching Tetrahedra algorithms produce
triangulated isosurface meshes with many small, thin triangles. There are nu-
merous geometric algorithms for improving the quality and reducing the size of
a triangle surface mesh. (See the surveys [Cignoni et al., 1998,Luebke, 2001,van
Kaick and Pedrini, 2006, Alliez et al., 2007].) We will only mention the work
speciﬁc to isosurface generation.
The Marching Cubes and Marching Tetrahedra algorithms produce
poor quality triangles when the isosurface passes close to a grid or mesh vertex.
Tzeng [Tzeng, 2004] improves triangle quality by warping the underlying reg-
ular grid so that isosurface vertices are near grid edge midpoints and far from
the grid vertices.
Improvements on Marching Tetrahedra triangle qual-
ity based on “snapping” tetrahedral mesh vertices to the isosurface are given
in [Hall and Warren, 1990,Treece et al., 1999,Labelle and Shewchuk, 2007]. La-
belle and Schewchuk [Labelle and Shewchuk, 2007] provide guaranteed bounds
on isosurface triangle quality using a “snapping”-based algorithm. Raman and
Wenger [Raman and Wenger, 2008] provide guaranteed bounds on Marching
Cubes isosurface triangle quality using the “snapping” of regular grid vertices
to the isosurface.
Various triangulations can be used for isosurface patches in the March-
ing Cubes lookup table. Dietrich et al. [Dietrich et al., 2008, Dietrich et al.,
2009a, Dietrich et al., 2009b] improve the quality of the isosurface triangles by
modifying and selecting the “best” triangulation. Nielson [Nielson, 2003a] gives
triangulations for all cases in the lookup table such that the projection to some
coordinate plane is one-to-one. This allows local representation of the isosurface
as a function of the two axes of the coordinate plane.
Alternative approaches have been developed for generating isosurface meshes
with quality elements. Schreiner et al. [Schreiner et al., 2006] use an advancing
front technique to generate high-quality isosurfaces. Dey and Levine [Dey and
Levine, 2007] present a quality isosurface mesh generation algorithm using the
Voronoi diagram of a set of sample points on the isosurface.
Both methods
are adaptive, with more triangles inserted in areas of high curvature. Based
on a related paper [Cheng et al., 2004], Dey and Levine’s algorithm provides

54
2. Marching Cubes and Variants
guarantees of triangle quality but at the expense of potentially adding large
numbers of triangles in high curvature areas. Both the advancing front technique
and the Voronoi-based technique take time that is an order of magnitude longer
than the running time of the Marching Cubes algorithm.
Isosurface patches in the isosurface lookup table can be constructed of smooth
elements such as bicubic or Bezier surfaces instead of piecewise linear triangles.
Smooth isosurface patches are described in [Gallagher and Nagtegaal, 1989,Hall
and Warren, 1990,Hamann et al., 1997,Theisel, 2002].
Nielson et al. [Nielson et al., 2003] present an algorithm to improve smooth-
ness of the Marching Cubes isosurface by moving isosurface vertices along grid
edges.
The SpiderWeb algorithm by Karron [Karron, 1992] constructs an isosur-
face by placing an isosurface vertex on each bipolar grid edge and connecting
those vertices to another isosurface vertex within the grid cube. It produces
substantially more isosurface triangles than Marching Cubes or dual contour-
ing and creates non-manifold “bubbles” whenever a grid facet has four bipolar
edges (i.e., the grid facet is ambiguous). Properties and proofs of SpiderWeb
isosurfaces are discussed in [Karron and Cox, 1992] and [Karron et al., 1993].
Dual contouring algorithms, isosurface construction in four dimensions, and
interval volumes are in the notes and comments sections of Chapters 3, 6, and 7.
Approximating isosurface normals from volumetric data is discussed in [Cline
et al., 1988, M¨oller et al., 1997a, M¨oller et al., 1997b, Nielson et al., 2002, Lee
et al., 2008,Hossain et al., 2011]. Approximating Gaussian and mean curvature
is discussed in [Nielson, 2003a,Kindlmann et al., 2003].
Patera and Skala [Patera and Skala, 2004] compare the accuracy of the
Marching Cubes isosurface with the accuracy of isosurfaces extracted from
tetrahedralizations of the regular grid and with isosurfaces extracted from the
body-centered cubic lattice.
Etiene et al. [Etiene et al., 2009] describe techniques for assessing the cor-
rectness of isosurface extraction programs. P¨othkow and Hege [P¨othkow and
Hege, 2011] give a method for computing the positional uncertainy of isosurface
vertices. They represent this uncertainty by coloring the isosurface.
Nooruddin and Turk [Nooruddin and Turk, 2003] use isosurfaces to repair
polygonal models. They convert the polygonal model to a volumetric data set.
Grid vertices with scalar value 1 lie inside the model while grid vertices with
scalar value 0 lie outside. They extract a Marching Cubes isosurface with
scalar value between 0 and 1. As noted in Section 2.3.3, this isosurface is a
manifold. Ju [Ju, 2004] gives a variation of this algorithm using dual contouring.
Ju’s approach detects and patches hole boundaries. Bischoﬀ, Pavic, and Kobbelt
[Bischoﬀet al., 2005] repair polygonal models by using morphological operators
to close the holes. They also use dual contouring to reconstruct the polygonal
surface. Ju in [Ju, 2009] surveys techniques for repairing polynomial models.
Newman and Yi in [Newman and Yi, 2006] provide an excellent survey of the
Marching Cubes algorithm and its variants.

CHAPTER 3
DUAL CONTOURING
Dual contouring1 is an isosurface construction technique that places isosurface
vertices inside mesh elements instead of on mesh edges. Isosurface vertices in
adjacent mesh elements are connected by isosurface edges and facets.
In the simplest form, each mesh element intersected by the isosurface contains
exactly one isosurface vertex. In more complicated versions, multiple isosurface
vertices can appear within a single mesh element.
Each such isosurface ver-
tex lies on a diﬀerent connected component of the mesh element’s isosurface
patch.
Dual contouring on regular grids produces quadrilateral patches instead of
triangles. The ability to place a vertex anywhere within a mesh element allows
better representation of sharp vertices and edges. The simpler versions of dual
contouring, with one vertex per mesh element, extend easily to higher dimen-
sional grids and multiresolution grids, as discussed in Sections 6.7 and 10.2. On
the other hand, the placement of isosurface vertices is less precise in dual con-
touring. When dual contouring uses only one isosurface vertex per mesh element,
the isosurface is usually not a manifold.
We present here two dual contouring algorithms, Surface Nets and Dual
Marching Cubes. Surface nets is the ﬁrst and simplest dual contouring
algorithm, where each mesh element contains at most one isosurface vertex.
Dual Marching Cubes is a more sophisticated version, where an isosurface
vertex is generated for each connected component in a mesh element’s isosurface
patch.
1Dual contouring constructs an isosurface that is a subset of the dual mesh of the original
mesh, hence the name “dual contouring.”
55

56
3. Dual Contouring
3.1
Deﬁnitions
Positive and negative vertices and faces. The deﬁnitions of positive, strictly
positive, and negative vertices and edges given here are the same as in Section 2.1.
However, the deﬁnitions are extended to grid facets and grid cubes.
Deﬁnition 3.1.
• A grid vertex is positive, “+”, if its scalar value is greater than or equal to
the isovalue σ.
• A grid vertex is negative, “−”, if its scalar value is less than σ.
• A positive vertex is strictly positive if its scalar value does not equal to σ.
Deﬁnition 3.2.
• A grid face (vertex, edge, facet, or cube) is positive if all of its vertices are
positive.
• A grid face is negative if all of its vertices are negative.
• A positive grid face is strictly positive if all of its vertices are strictly positive.
The deﬁnitions given in the beginning of this section apply not just to regular
scalar grids but also to curvilinear grids. They also apply to the vertices and
faces of polyhedral meshes such as tetrahedral and simplicial meshes.
Bipolar edges and active faces. The deﬁnitions of bipolar edges is the same as
in Section 2.1. We add a similar term for grid squares, cubes, and their faces
that contain one negative and one positive vertex.
Deﬁnition 3.3.
• A grid edge is bipolar if one endpoint is positive and one endpoint is nega-
tive.
• A grid square or cube or any face of a square or cube is active if it has at
least one negative and one positive vertex.
Interior and boundary edges and cubes. We need to distinguish grid edges and
cubes that are on the boundary of the grid from edges and cubes that are in the
interior.
Deﬁnition 3.4.
• An interior grid edge is a grid edge that is contained in four grid cubes.
• A boundary grid edge is a grid edge that is contained in three or fewer grid
cubes.

3.2. Surface Nets
57
Deﬁnition 3.5.
• An interior grid cube is a grid cube whose edges are all interior grid edges.
• A boundary grid cube is a grid cube that contains at least one boundary grid
edge.
Let Γ be a regular grid in R3. We use the notation Γinner to denote the regular
subgrid of Γ consisting of the interior grid cubes of Γ. We let Γouter represent
the st of boundary grid cubes of Γ.
Centroid. Let P = {p1, p2, . . . , pk} be a set of k points in R2 or R3.
Deﬁnition 3.6. The centroid of P is
p1 + p2 + . . . + pk
k
.
The centroid of p represents a point in the “center” of P.
3.2
Surface Nets
Gibson described the ﬁrst dual contouring algorithm for regular grids, which
she called Surface Nets [Gibson, 1998a,Gibson, 1998b]. We ﬁrst describe a
two-dimensional version of her algorithm.
3.2.1
2D Surface Nets
Let Γ be a two-dimensional regular grid with scalar values assigned to the vertices
of Γ. Add an isocontour vertex wc to each active grid square c ∈Γ. For each
bipolar grid edge separating two squares, c and c′, connect vertices wc and wc′
by an isocontour edge (Figure 3.1(c)).
We would like to position the isocontour vertex within each grid square at
the “center” of the isocontour patch in the grid square. To do so, we use linear
interpolation as described in Section 1.7.2 to approximate the intersection of
the isocontour and all the bipolar edges and then take the centroid of all the
approximation points.
More speciﬁcally, let σ be the isovalue and sp be the scalar value at a grid
vertex p. For each bipolar edge e = [p, q], let we be the point (1 −α)p + αq
where α = (σ −sp)/(sq −sp). If we1, . . . , wek are the interpolation points in
the grid square c, then locate vertex wc at (we1 + · · · + wek)/k, the centroid of
we1, . . . , wek.
The 2D Surface Nets algorithm is presented in Figure 3.2.

58
3. Dual Contouring
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
(a) Scalar grid.
(b) +/−grid.
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
1
2
2
3
3
3
3
4
4
5
6
6
6
6
7
7
7
7
8
8
8
8
8
9
9
(c) Isocontour edges.
(d) Isocontour.
Figure 3.1. (a) 2D scalar grid. (b) Positive (red) or negative (blue) labels on grid
vertices. Vertex v with scalar value sv is positive (red) if sv ≥5 and negative (blue) if
sv < 5. (c) Surface Nets isocontour with vertices at square centers (before computing
centroids). (d) Surface Nets isocontour with isovalue 5.
For each active grid square c,
create new isocontour vertex wc

For each bipolar edge separating two squares, c and c′,
connect vertices wc and wc′ by an isocontour edge

Compute isocontour vertex coordinates
Figure 3.2. Surface Nets 2D.

3.2. Surface Nets
59
Figure 3.1(d) contains an example of the isocontour produced by the algo-
rithm. Note that an isocontour vertex may be incident on four isocontour edges.
Thus the isocontour is not a simple closed curve or a 1-manifold.
3.2.2
3D Surface Nets
The three-dimensional Surface Nets algorithm is a direct generalization of the
two-dimensional version. (See Figure 3.3.) Let Γ be a three-dimensional regular
grid with scalar values assigned to the vertices of Γ. Add an isosurface vertex wc
to each grid cube c with at least one positive and at least one negative vertex.
For each bipolar grid edge contained in four cubes, c1, c2, c3, and c4, add an
isosurface quadrilateral with vertices wc1, wc2, wc3, and wc4. The cyclic order of
the vertices around the quadrilateral should match the cyclic order of the cubes
around the edge.
To position the isosurface vertex within each grid cube, use linear interpola-
tion as described in Section 1.7.2 to approximate the intersection of the isosurface
and all the bipolar edges. For each bipolar edge e = [p, q], let we be the point
(1−α)p+αq where α = (σ−sp)/(sq−sp). Take the centroid, (we1 +· · ·+wek)/k,
of all the approximation points as the location of the isosurface vertex.
Figure 3.4 contains examples of the isosurface produced by the algorithm. If
every grid edge is a bipolar edge (see conﬁguration 4F in Figure 3.5), then an
isosurface vertex may be incident on twelve isosurface quadrilaterals. Thus the
isosurface is not necessarily a 2-manifold with boundary.
For each active grid cube c,
create new isosurface vertex wc

For each bipolar edge contained in four cubes, c1, c2, c3, and c4,
add an isosurface quadrilateral with vertices wc1, wc2, wc3, and wc4

Compute isosurface vertex coordinates

Triangulate the isosurface quadrilaterals
Figure 3.3. Surface Nets 3D.

60
3. Dual Contouring
(a)
(b)
Figure 3.4.
Examples of isosurfaces and quadrilateral meshes produced by Sur-
faceNets. (a) Isosurface (isovalue 3) forming a torus. Scalar data set is a 20× 20× 20
regular grid with origin (0, 0, 0) measuring the distance to a circle with radius 6 centered
at (9.5, 9.5, 9.5). (b) Isosurface (isovalue 80) of CT scan of an engine block (close-up).
Data set created by General Electric.
4F
4F
Figure 3.5. Conﬁguration 4F. The isosurface vertex is incident on 12 isosurface quadri-
laterals. The isosurface is not a manifold.
The algorithm just described uses the intersection of the isosurface and the
bipolar edges to position the isosurface vertex within a grid cube. If the surface
normals at the intersection points can also be computed, then these normals
can be used in determining the location of the isosurface vertex. In particular,
the normals can position isosurface vertices on sharp corners or edges in the
isosurface, to accurately represent such corners or edges [Ju et al., 2002,Zhang
et al., 2004].

3.2. Surface Nets
61
Figure 3.6. Triangle patch of four triangles whose boundary is a quadrilateral q around
bipolar edge e. Each triangle is formed by joining we (magenta vertex) to one of the
four edges of q.
(a) Tetrahedron.
(b) Envelope of e.
Figure 3.7. (a) Convex hull of bipolar edge e and a quadrilateral edge. (b) Union of
the four tetrahedra around e forming the envelope of e.
3.2.3
Triangulation
Dual contouring creates a quadrilateral mesh but these quadrilaterals are not
necessarily planar, i.e., their four vertices do not necessarily lie on a single plane.
In fact, unless isosurface vertices are placed at the center of each grid cube, it is
highly unlikely that the four quadrilateral vertices will lie on a single plane. To
create a piecewise linear surface, one needs to replace each quadrilateral with a
patch of triangles whose boundary is the quadrilateral.
The simplest approach is to add a diagonal to each quadrilateral, splitting it
into two triangles. Unfortunately, adding diagonals can create self-intersections
in the isosurface [Ju and Udeshi, 2006]. The problem is that a diagonal from one
quadrilateral can intersect the triangles of another quadrilateral.
Ju and Udeshi [Ju and Udeshi, 2006] solve this problem by breaking a quadri-
lateral into four, not two triangles. Consider the bipolar edge e contained in four
cubes, c1, c2, c3, and c4, listed in order around e. Let we be the point on e
constructed using linear interpolation as described in the previous section. The
quadrilateral around e has four edges. Replace this quadrilateral with four tri-
angles formed from joining we to each of the four edges (Figure 3.6).
Why does this new triangulation not have self-intersections? The convex hull
of quadrilateral edge (wc1, wc2) and e is a tetrahedron (Figure 3.7(a)). Similarly,

62
3. Dual Contouring
wc1
wc2
wc3
wc4
v
v′
Δ
wc1
wc2
wc3
wc4
v
v′
(a)
(b)
Figure 3.8. Isosurface triangles outside the envelope of (v, v′).
Quadrilateral edges
are colored red. (a) Plane containing triangle Δ = (wc1, wc2, wc3) does not strictly
separate v from v′. (b) Plane containing v and quadrilateral diagonal (wc1, wc3) does
not strictly separate wc2 from wc4.
the convex hull of the other quadrilateral edges and e are also tetrahedra. The
union of these four tetrahedra is a polyhedron with eight triangular faces (Fig-
ure 3.7(b)), although this polyhedron is not necessarily convex. Ju and Udeshi
call this polyhedron the envelope of e. The four triangles sharing vertex we are
contained in the envelope of e.
The envelopes of two diﬀerent grid edges intersect only on shared vertices,
edges, or facets.
Since the four triangles sharing vertex we are contained in
the envelope for e, they only intersect triangles from other quadrilaterals on
shared vertices or edges. Thus, the resulting triangulated surface has no self-
intersections.
In contrast, the two triangles formed by adding a diagonal to
the quadrilateral around e may not be contained in the envelope of e and may
intersect the interior of triangles from other quadrilaterals.
Adding four triangles per quadrilateral instead of two increases the number
of triangles representing the isosurface by a factor of two. If the two triangles
formed by a diagonal lie inside the envelope, then there is no need to use four
triangles. By the argument above, they will only intersect triangles from other
quadrilaterals on shared edges or vertices.
Orientation tests can be used to determine if the two triangles formed by a
diagonal lie inside the envelope of e [Wang, 2011]. Without loss of generality,
assume the diagonal is (wc1, wc3). Let v and v′ be the endpoints of e. The
two triangles Δ1 = Δ(wc1, wc2, wc3) and Δ2 = Δ(wc1, wc3, wc4) lie inside the
envelope of (v, v′) if and only if the planes through each triangle strictly separate
v from v′ and the plane through v and diagonal (wc1, wc3) strictly separates wc2
from wc4. Figure 3.8 illustrates violations of those two conditions.

3.2. Surface Nets
63
Find the diagonal d of quadrilateral q
that minimizes the maximum triangle angle

Diagonal d splits q into two triangles, Δ1 and Δ2;
if Δ1 and Δ2 are in the envelope of e, return Δ1 and Δ2

Otherwise
• Compute we ∈e using linear interpolation
• Return the four triangles formed by joining we
to each of the four edges of quadrilateral q
Figure 3.9. Triangulation of isosurface quadrilateral q around bipolar edge e.
Joining v and v′ to triangles Δ1 and Δ2 gives four oriented tetrahedra:
t1 = (wc1, wc2, wc3, v), t2 = (wc1, wc2, wc3, v′), t3 = (wc1, wc3, wc4, v), and
t4 = (wc1, wc3, wc4, v′). The plane through Δ1 strictly separates v from v′ if
and only if the orientations of t1 and t2 are nonzero and not equal. The plane
through Δ2 strictly separates v from v′ if and only if the orientations of t3 and t4
are nonzero and not equal. The plane through v and diagonal (wc1, wc3) strictly
separates wc2 from wc4 if and only if t1 and t3 have the same orientation. Thus,
we can determine if the triangles Δ1 and Δ2 lie inside the envelope of (v, v′) by
computing and comparing the orientations of tetrahedra t1, t2, t3, and t4. (See
Appendix B.6 on computing the orientation of four points.)
Each quadrilateral has two possible choices for a diagonal. We use the diag-
onal that minimizes the maximum triangle angle. Using this diagonal reduces
the number of long, skinny triangles.
We select diagonal d, which minimizes the maximum triangle angle. Diagonal
d splits quadrilateral q into two triangles, Δ1 and Δ2. If Δ1 and Δ2 are in the
envelope of bipolar edge e, we replace quadrilateral q with triangles Δ1 and Δ2.
If they are not, then we calculate the interpolated point we and form the four
triangles with vertex we as described above. (See Figure 3.9.)
Forming a patch of triangles is one way of determining the surface bounded
by a quadrilateral. Bilinear interpolation, Hermite surfaces, B´ezier patches, and
B-Splines can also be used to create smoother surfaces. As long as those surfaces
are contained within the envelope of the corresponding bipolar edge, the resulting
isosurface will not self-intersect.

64
3. Dual Contouring
3.2.4
Isosurface Properties
The Surface Nets algorithm produces an isosurface whose vertices may and
usually do lie in the interior of the grid cubes. Thus the boundary of that isosur-
face is not usually on the boundary of the grid. A path connecting positive and
negative grid vertices can bypass the isosurface in boundary grid cubes. How-
ever, if we restrict the path to interior grid cubes, then the path must intersect
the isosurface. Restricted to interior grid cubes, the isosurface separates the
positive and negative grid vertices.
If none of the grid vertices have scalar value equal to the isovalue, then the
isosurface is minimal in the sense that it intersects interior bipolar grid edges
exactly once and does not intersect positive or negative grid edges. The isosurface
is not necessarily a manifold, even if none of the grid vertices have scalar value
equal to the isovalue.
There are numerous variations on Surface Nets depending on the place-
ment of the vertices within each grid cube and the construction of the surface
bounded by each quadrilateral. The properties listed below apply to Surface
Nets as described in the previous section, where vertices are placed at the cen-
troid of edge-isosurface intersection points and the quadrilaterals are triangulated
into two or four triangles based on the envelope.
Surface Nets returns a ﬁnite set, Υ, of triangles. The isosurface is the
union of these triangles. The vertices of the isosurface are the triangle vertices.
As deﬁned in Section 3.1, Γinner is the subgrid of interior grid cubes of Γ.
The following properties apply to all isosurfaces produced by the Surface
Nets algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
Set Υ contains at most 4m triangles where m is the number of
bipolar grid edges.
Property 3.
The isosurface does not contain any grid vertices whose scalar
values do not equal the isovalue.
Property 4.
The isosurface intersects at exactly one point every interior bipolar
grid edge whose positive endpoint is strictly positive.
Property 5.
The isosurface does not intersect any negative or strictly positive
grid edges.
Property 6.
The isosurface strictly separates the strictly positive vertices of
Γinner from the negative vertices of Γinner.
Properties 3–5 imply that the isosurface intersects a minimum number of grid
edges.
The following properties apply to the Surface Nets isosurfaces whose iso-
values do not equal the scalar value of any grid vertex.

3.2. Surface Nets
65
Property 7.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
3.2.5
Proof of Isosurface Properties 1–5
Property 1.
The isosurface is piecewise linear.
Proof: The isosurface is a ﬁnite union of triangles and thus is piecewise linear.□
Property 2.
Set Υ contains at most 4m triangles where m is the number of
bipolar grid edges.
Proof: Surface Nets constructs a quadrilateral for each bipolar edge e con-
tained in four grid cubes and splits that quadrilateral into at most four triangles.
Since the number of such grid edges is at most m, the number of triangles is at
most 4m.
□
Property 3.
The isosurface does not contain any grid vertices whose scalar
values do not equal the isovalue.
Proof: Let v be a grid vertex whose scalar value does not equal the isovalue.
If v were to lie on the isosurface, then it would have to be contained in some
isosurface triangle formed from some bipolar edge e. Edge e would have to be
in a grid cube incident on v. We consider two cases depending upon whether e
itself is incident on v.
Consider a bipolar edge e incident on v.
Let P be the plane through v
orthogonal to e. Surface Nets uses linear interpolation to determine a point
we ∈e that approximates the intersection of e and the isosurface. Since the
scalar value of v does not equal the isovalue, this point is not v. For every grid
cube c containing e, the point wc is the centroid of a set of points in c that
includes point we. Thus, we pulls wc away from the plane P and none of the
triangles formed from the quadrilateral around e contain v.
Now consider a bipolar edge e that is not incident on v. Let c be a grid cube
containing e and v and let f be a facet of c that contains v but does not intersect
e. Let P be the plane containing f. Let we ∈e be the linear interpolation point
on e. For every grid cube c′ containing e and v, point we pulls wc′ away from
plane P. Thus, none of the triangles formed from the quadrilateral around e
contain v.
□
As deﬁned in Section 3.1, an interior grid edge e is a grid edge contained in
four grid cubes. To prove Property 4, we ﬁrst show that every interior bipolar
grid edge intersects the isosurface.
Lemma 3.7. If e is an interior bipolar grid edge, then e intersects the isosurface.

66
3. Dual Contouring
Proof: Let q be the quadrilateral around e.
Let Σe be the isosurface patch
generated by splitting q into triangles. By construction, Σe is contained in the
envelope of e and its boundary is q. Since e passes through q and has endpoints
on the envelope of e, edge e intersects Σe.
□
As deﬁned in Section 3.1, a grid cube or grid face is active if it contains at
least one negative and at least one positive vertex. For each active grid cube
c, algorithm Surface Nets constructs a point wc ∈c by approximating the
intersections of the isosurface and the cube edges and taking the centroid of these
intersections.
Lemma 3.8. If v is a strictly positive vertex of an active cube c and f is a facet
of c containing v, then wc does not lie on f.
Proof: Let f ′ be the facet of c parallel to f. We consider three cases based on
whether f ′ is active, negative, or positive.
Case I: Facet f ′ is active.
Since f ′ is active, it has a bipolar edge e′. Some point r′ ∈e′ approxi-
mates the intersection of the isosurface and e′. Point wc is the centroid of a
set of points in c that includes point r′. Since r′ is not on f, point r′ pulls
wc away from f and wc does not lie on f.
Case II: Facet f ′ is negative.
Let e = (v, v′) be the edge from v to a vertex v′ in f ′. Since f ′ is negative,
vertex v′ is negative and edge e is bipolar. Some point r ∈e approximates
the intersection of the isosurface and e. Since v is strictly positive, point r
does not equal v and does not lie on f. Thus r pulls wc away from f and
wc does not lie on f.
Case III: Facet f ′ is positive.
Since cube c is active, cube c must contain some negative vertex v′′.
Since f ′ is positive, negative vertex v′′ must lie on f. Let e = (v′′, v′) be the
edge from v′′ to a vertex v′ in f ′. Since f ′ is positive, edge e is bipolar. Some
point r ∈e approximates the intersection of the isosurface and e. Since v′′
is negative, point r′ does not equal v and does not lie on f. Thus r′ pulls
wc away from f and wc does not lie on f.
□
Property 4.
The isosurface intersects at exactly one point every interior bipolar
grid edge whose positive endpoint is strictly positive.
Proof: Let e be an interior edge with one endpoint scalar value greater than
the isovalue and one endpoint scalar value less than the isovalue. Since neither
scalar value equals the isovalue, the isosurface does not contain either endpoint
(Property 3).

3.2. Surface Nets
67
Let c1, c2, c3, and c4 be the four grid cubes containing e. By Lemma 3.7, the
isosurface intersects e. By Lemma 3.8, none of the wci lie on facets containing
e. If the quadrilateral around e is split into four triangles, then each of these
triangles intersect e at point we, proving the property. If the quadrilateral around
e is split into two triangles by a diagonal d, then either both triangles intersect
e at d ∩e or one triangle intersects e at a single point and the other does not
intersect e.
□
Property 5.
The isosurface does not intersect any negative or strictly positive
grid edges.
Proof: Let e be a grid edge whose scalar values are both greater or both less
than the isovalue. Since the scalar values at the endpoints of e do not equal the
isovalue, the isosurface does not contain any endpoint (Property 3).
Since e is not a bipolar edge, edge e does not generate any isosurface triangles.
Let e′ be a bipolar grid edge. By construction, all the triangles generated by e′
are contained in the envelope of e′. If e′ does not intersect e, the envelope of e′
does not intersect e and none of the isosurface triangles generated by e′ intersect
e. If e′ shares an endpoint with e, then the envelope of e′ intersects e only at
this endpoint. Since the isosurface does not contain this endpoint, none of the
triangles generated by e′ intersect e. Thus e does not intersect the isosurface.□
3.2.6
Proof of Isosurface Property 6
To prove Property 6, we ﬁrst show that a simpliﬁed version of the Surface Nets
isosurface separates positive from negative vertices. We then apply a homotopy
map from the simpliﬁed version to the Surface Nets isosurface, which preserves
the separation.
For each cube c, let ac be the center of c. For each edge e, let ae be the
midpoint of e. Remap the set of triangles Υ by mapping each isosurface vertex
wc to the cube center ac and each isosurface vertex we to the edge midpoint ae.
Let Υ be the resulting set of triangles. Each interior bipolar edge corresponds
to two or four triangles in Υ that together form a square that is orthogonal to
the edge and passes through the edge midpoint. Set |Υ| is the union of all the
triangles in Υ. (See the example in Figure 3.10.)
Let a0 be the center of the grid cube with the lowest x, y, and z coordinates
and let a1 be the center of the grid cube with the highest x, y, and z coordinates.
If grid Γ is composed of unit cubes and has origin (0, 0, 0) and vertex dimensions
nx × ny × nz, then a0 is the point (0.5, 0.5, 0.5) and a1 is the point (nx −0.5,
ny −0.5, nz −0.5).
Let X∗
Γ be the rectangular region from a0 to a1.
(See
Figure 3.11 for a 2D illustration.) The isosurface |Υ| is contained in X∗
Γ. The
boundary of this isosurface is contained in ∂X∗
Γ.
We will show that a path that lies in X∗
Γ from a positive vertex of Γinner to
a negative vertex of Γinner must intersect |Υ| (Lemma 3.13). We ﬁrst consider a

68
3. Dual Contouring
(a) |Υ|.
(b) |Υ|.
Figure 3.10. Dual contouring isosurfaces of torus. Only quadrilateral edges are dis-
played. (a) Isosurface |Υ| produced by Surface Nets. (b) Isosurface |Υ| produced by
positioning vertices at cube centers and edge midpoints.
a0
a1
Figure 3.11. Two-dimensional illustration of rectangular region X∗
Γ (blue). Point a0 is
the center of the grid cube with the lowest x and y coordinates. Point a1 is the center
of the grid cube with the largest x and y coordinates.
path ζ in a single grid cube and show how it can be mapped to the edges and
faces of the cube (Lemmas 3.9 and 3.10 and Corollary 3.11). We show that a
path ζ from a negative vertex to a positive vertex of a grid cube will intersect
|Υ| (Corollary 3.12). Finally, we divide grid cubes into negative and positive
regions separated by |Υ| and prove that these regions agree on the faces between
grid cubes. Any path in X∗
Γ from a negative vertex to a positive vertex of Γinner
would have have to cross from a negative region to a positive one and would
have to intersect |Υ| (Lemma 3.13).
We start by showing how paths in grid cube c can be mapped to faces and
edges of c. Deﬁne a mapping μc : (c −ac) →∂c from (c −ac) to the boundary
of c as follows. For each point x ∈c −ac, there is a ray rx from ac through x
that intersects ∂c at exactly one point. Let μc(x) equal rx ∩∂c. Mapping μc is
called a radial projection of (c −ac). (See Figure 3.12(a).)

3.2. Surface Nets
69
ac
p
μc(p)
af
p
μf(p)
(a) μc(p).
(b) μf (p).
Figure 3.12. Radial projections. (a) Radial projection of p ∈c −{ac} to μc(p) ∈∂c.
Point ac is the center of cube c. (b) Radial projection of p ∈f −{af} to μf(p) ∈∂f.
Point af is the center of face f.
We deﬁne a similar mapping μf for each grid facet f. For each grid facet
f, let af be the center of f. For each point x ∈f −af, there is a ray rx from
af through x that intersects ∂f at exactly one point. Let μf(x) equal rx ∩∂f.
Mapping μf is a radial projection of (f −af). (See Figure 3.12(b).)
Lemma 3.9.
1. For all x ∈c −ac, x ∈|Υ| if and only if μc(xc) ∈|Υ|.
2. For all x ∈f −af, x ∈|Υ| if and only if μf(xf) ∈|Υ|.
Proof of 1: If x is in |Υ|, then x lies in some square in |Υ| with vertex ac. Point
μc(x) also lies in this square so μc(x) is in |Υ|.
On the other hand, if μc(x) is in |Υ|, then μc(x) lies in some square in |Υ|
with vertex ac. Line segment (ac) is contained in this square and x lies on this
lines segment, so x is in |Υ|.
□
The proof of Statement 2 in Lemma 3.9 is similar to the proof of Statement
1 and is omitted.
Let p be a point in c −ac. Note that p is in X∗
Γ if and only if μc(p) is in X∗
Γ.
Similarly, if p is a point in f −af, then p is in X∗
Γ if and only if μf(p) is in X∗
Γ.
The 1-skeleton of a cube is the union of all the vertices and edges of the cube.
Lemma 3.10. Let c be a grid cube of Γ, let e be an edge of c, and let ζ be a path
in c ∩X∗
Γ from a negative vertex of c to some point p ∈e ∩X∗
Γ. If ζ does not
intersect |Υ|, then there is a negative endpoint v of e such that v is in X∗
Γ and
the closed line segment [v, p] does not intersect |Υ|.

70
3. Dual Contouring
Proof: If all the vertices in c are negative, then |Υ| does not intersect c. The
closed line segment from a vertex of e in X∗
Γ to p does not intersect |Υ|, satisfying
the conclusion.
Assume some vertex of c is positive. Since c contains at least one negative
vertex, |Υ| intersects c and contains ac, the center of c.
Let ζ be a path in c∩X∗
Γ that does not intersect |Υ| from a negative vertex v
of c to point p ∈e∩X∗
Γ. By Lemma 3.9, there is a continuous map μc that takes
c −ac to ∂c, maps points in |Υ| to points on |Υ| and points in c −|Υ| to points
in ∂c −|Υ|. Since path ζ does not intersect the |Υ|, path ζ does not contain ac.
Apply the mapping μc to ζ to get a path ζ′ lying in ∂c that connects v and p.
Since ζ does not intersect |Υ|, neither does ζ′. Since ζ is in X∗
Γ, path ζ′ is in X∗
Γ.
Path ζ′ may pass through the center ag of some facets g of c. If it does, then
we can perturb it slightly to form a path ζ′′ ⊂∂c that does not pass through
the center ag of any facet g of c and remains in X∗
Γ. If the perturbation is small
enough, then ζ′′ will not intersect |Υ|.
By Lemma 3.9, there is a continuous map μg that takes g −ag to ∂g, maps
points in |Υ| to points on |Υ|, and points in f −|Υ| to points in ∂f −|Υ|. Since
ζ′′ does not contain ac, applying the mapping μg to ζ′′ for each facet g gives a
path ζ′′′ that intersects neither the interior of c nor that of any facet of c. Thus,
path ζ′′′ is contained in the 1-skeleton of the cube. Since ζ′′ is in X∗
Γ, path ζ′′′ is
also in X∗
Γ. Path ζ′′′ connects a negative vertex of c to p.
Every bipolar edge of c intersects |Υ| at its midpoint. Since path ζ′′′ does
not intersect |Υ|, it does not contain any bipolar edge of c. To reach p, path
ζ′′′ must pass through a sequence of grid vertices (v1, v2, . . . , vk) of c. Since ζ′′′
does not contain any bipolar edge of c and v1 is negative, each of the vertices
vi must be negative. In particular, vertex vk must be negative. Since vk is the
last grid vertex contained in ζ′′′, it must be an endpoint of edge e. Since ζ′′′ is
in X∗
Γ, vertex vk is in X∗
Γ.
Path ζ′′′ contains a subpath ζe ⊂e that connects vk to p. Since ζe does not
intersect |Υ|, the closed line segment [vk, p] does not intersect |Υ|, proving the
lemma.
□
Corollary 3.11. Let c be a grid cube of grid Γ, let f be a face of c, and let ζ be a
path in c ∩X∗
Γ from a negative vertex of c to some point p ∈f ∩X∗
Γ. If ζ does
not intersect |Υ|, then there is a path in f ∩X∗
Γ that does not intersect |Υ| from
a negative vertex of f to p.
Proof: We consider two cases depending upon whether p is at the center of f.
Case I: Point p is not at the center of f.
Since p is not at the center of f, the map μ can be applied to p. Point
μf(p) is on an edge e of f. Since p is in X∗
Γ, so is μf(p). By Lemma 3.10,
edge e has a negative endpoint v such that v is in X∗
Γ and the closed line

3.2. Surface Nets
71
segment [v, μf(p)] does not intersect |Υ|. Since p is not in |Υ|, line segment
[μf(p), p] does not intersect |Υ|. Since p and μf(p) are in X∗
Γ, line segment
[μf(p), p] is in X∗
Γ. Thus the path (v, μf(p), p) is in f ∩X∗
Γ and does not
intersect |Υ|.
Case II: Point p is at the center of f.
Perturb p slightly to a point p′ such that closed line segment [p, p′] does
not intersect |Υ| and p′ is in X∗
Γ. By Case I, there is a path ζf in f ∩X∗
Γ
from some negative vertex v of f to p′. Adding [p′, p] to this path gives a
path ζ in f ∩X∗
Γ from v to p that does not intersect |Υ|.
□
Corollary 3.12. Let c be a grid cube of Γ. If ζ is a path in c ∩X∗
Γ from a negative
vertex to a positive vertex of c, then ζ intersects |Υ|.
Proof: Assume ζ was a path in c ∩X∗
Γ from a negative vertex of c to a positive
vertex v of c that did not intersect |Υ|. Let e be an edge of c containing v. By
Lemma 3.10, edge e has a negative endpoint v′ such that v′ is in X∗
Γ and the
closed line segment [v, v′] does not intersect |Υ|. Since v is positive and v′ is
negative, vertices v and v′ must be distinct and (v, v′) must equal e. Since e has
a positive endpoint v and a negative endpoint v′, edge e = (v, v′) intersects |Υ|
at the midpoint of e, a contradiction. Thus ζ intersects |Υ|.
□
Note that Corollary 3.12 requires that ζ be contained in X∗
Γ. If ζ is not in
X∗
Γ, then there may be a path that does not intersect |Υ| from a negative vertex
to a positive vertex in c.
Lemma 3.13. Every path ζ in X∗
Γ from a positive vertex of Γinner to a negative
vertex of Γinner intersects |Υ|.
Proof: For each grid cube c of grid Γ, let the negative region for c ∩X∗
Γ be the set
of points that can be reached by a path in X∗
Γ from a negative vertex such that
the path does not intersect |Υ|. Let the positive region for c ∩X∗
Γ be all the other
points in c ∩X∗
Γ. The positive region contains |Υ| ∩c and is closed. Any point
within the positive region that does not lie on |Υ| has a neighborhood in c ∩X∗
Γ
contained in the positive region.
By construction of Υ, no grid vertex is contained in |Υ|. Since a zero-length
path connects a negative vertex to itself, every negative vertex of c in c ∩X∗
Γ is
contained in the negative region. On the other hand, by Corollary 3.12 any path
in c ∩X∗
Γ from a negative vertex of c to a positive vertex c must intersect |Υ|.
We claim that positive and negative regions agree on shared boundaries of
grid cubes. Let R−
1 and R−
2 be the negative regions of c1 ∩X∗
Γ and c2 ∩X∗
Γ for
two adjacent grid cubes, c1 and c2. Let f be the intersection of the two grid
cubes. Note that f may be a grid vertex, a grid edge, or a square grid facet.

72
3. Dual Contouring
By Corollary 3.11, if point p lies in R−
1 ∩f, then some path in f ∩X∗
Γ does not
intersect |Υ| and connects a negative vertex to p. Since f is a face of c2, this
path also lies in c2 and so p is in R−
2 . A symmetric argument shows that if p is
in R−
2 , then p is in R−
1 . Thus the positive and negative regions agree on shared
boundaries of grid cubes.
Let R+ be the union of the positive regions of c ∩X∗
Γ over all the grid cubes
c ∈Γ. Consider a path ζ in X∗
Γ from a positive grid vertex to a negative one.
The positive grid vertex lies in R+ while the negative one does not. Thus ζ must
intersect some point p on the boundary of R+ where it crosses out of R+. Every
neighborhood of p must contain points that are not in R+.
Since R+ is closed, point p lies in R+. Since positive regions agree on the grid
cube boundaries, point p lies in the positive region of each grid cube containing p.
Assume p is not in |Υ|. Within each grid cube containing p, some neighborhood
of p is contained in the positive region for that grid cube. The union of those
neighborhoods is a neighborhood of p within the grid and is contained in R+.
Thus ζ does not cross out of R+ at p. We conclude that p must lie on |Υ| and
that ζ intersects |Υ|.
□
Set |Υ| is the union of all the triangles in Υ. Therefore, set |Υ| is the set of
points on the isosurface created by Surface Nets.
Property 6.
The isosurface strictly separates the strictly positive vertices of
Γinner from the negative vertices of Γinner.
Proof: Each vertex of a triangle in Υ is the midpoint ae of some bipolar edge e
or the center ac of some active cube c. For bipolar edges e and active cubes c,
deﬁne the homotopy
η(ae, α) = (1 −α)ae + αwe,
η(ac, α) = (1 −α)ac + αwc.
Linearly extend the homotopy η to all the triangles in Υ giving a homotopy
η : |Υ| →|Υ|.
By Lemma 3.13, every path in X∗
Γ from a positive vertex of Γinner to a negative
vertex of Γinner intersects set |Υ|. Set |Υ| does not contain any vertices of Γinner.
Map η is a homotopy map that never passes through any negative or strictly
positive vertices in Γinner. Since wc is contained in cube c, set {η(x, α) : x ∈
|Υ| ∩∂X∗
Γ} is a subset of R3 −|Γinner|. By Lemma B.19 in Appendix B, every
path in |Γinner| from a negative to a strictly positive vertex of Γinner intersects
|Υ|. Thus |Υ| separates the negative vertices of Γinner from the strictly positive
vertices of Γinner. By Property 3, isosurface |Υ| does not contain any negative
or strictly positive vertices of Γinner. Thus |Υ| strictly separates the negative
vertices of Γinner from the strictly positive vertices of Γinner.
□

3.2. Surface Nets
73
3.2.7
Proof of Isosurface Property 7
Property 7.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
Proof: Let q be a quadrilateral around edge e. Since the isovalue does not equal
the scalar value of any grid vertex, the points wc are in the interior of their
respective cubes c.
Thus no two vertices of e coincide and no four vertices
of e are colinear. Three vertices can be colinear, but the degenerate triangle
containing the three vertices has a 180-degree angle and so the diagonal splitting
this triangle will be selected. Thus, if q is split into two triangles, neither triangle
will have zero area.
Let (wc1, wc2) be an edge of q. Since no point wc lies on a grid facet, points
wc1, wc2, and we are not colinear. Thus triangle Δ(wc1, wc2, we) does not have
zero area.
Each quadrilateral around an edge e is replaced by two or four triangles.
By construction, this triangular patch is contained in the envelope of bipolar
edge e.
Since the envelopes of two diﬀerent bipolar edges intersect only at
shared vertices, edges, or facets, the triangles in diﬀerent triangular patches
intersect only at shared vertices or edges. Thus Υ forms a triangulation of the
isosurface.
□
3.2.8
Non-Manifold Isosurface Patches
Let c be some active grid cube. Since all the isosurface quadrilaterals created by
bipolar edges of c are incident on wc, there are no topological choices about the
construction of the isosurface patch in c. (There is a choice of the triangulation,
but this choice aﬀects the geometry, not the topology, of the isosurface.) Thus,
the ambiguous Marching Cubes conﬁgurations listed in Section 2.3.5 do not
create any ambiguity for the Surface Nets algorithm.
However, the ambiguous Marching Cubes conﬁgurations do create another
problem for Surface Nets. Surface Nets applied to any of these conﬁgu-
rations creates a non-manifold in the neighborhood of wc. The non-manifold
around wc may be viewed as the price to pay for avoiding any ambiguity.
The non-manifold conﬁgurations and their isosurface patches are illustrated
in Figure 3.13.
Note that even the isosurface patches for conﬁgurations 2C
and 6C are not manifolds, even though none of the facets of these conﬁgura-
tions are ambiguous. Note also that the isosurface quadrilaterals are artiﬁcially
truncated. They actually extend further into adjacent cubes.

74
3. Dual Contouring
5C
3B
2C
2B
4C
4E
4F
6B
6C
5B
3C
Figure 3.13. Non-manifold isosurface patches. Black vertices are positive.
3.2.9
Convex Polyhedral Meshes
Algorithm Surface Nets extends easily to convex polyhedral meshes. A mesh
element is active if it contains at least one negative and at least one positive
vertex. For each active mesh element c, construct an isosurface vertex wc. For
each bipolar mesh edge contained in mesh elements c1, c2, . . . , ck, add an iso-
surface polygon with vertices wc1, wc2, . . . , wck. Note that this polygon is not
necessarily a quadrilateral.
To position the isosurface vertices within each grid cube, use linear interpola-
tion as described in Section 1.7.2 to approximate the intersection of the isosurface
and all the bipolar edges. Take the centroid of all the approximation points as
the location of the isosurface vertex.
The isosurface polygon (wc1, wc2, . . . , wck) is not necessarily planar. To cre-
ate a piecewise linear surface, triangulate the isosurface polygons.

3.3. Dual Marching Cubes
75
3.3
Dual Marching Cubes
The Surface Nets algorithm places a single isosurface vertex in each active
grid cube. This single vertex causes the surface to be a non-manifold for some
conﬁgurations. The Dual Marching Cubes algorithm by Nielson [Nielson,
2004] attempts to remedy this problem by sometimes adding more than one
vertex per cube.
For each bipolar grid edge, Dual Marching Cubes creates an isosurface
quadrilateral connecting four isosurface vertices in the four incident grid cubes.
If the grid cube contains more than one isosurface vertex, the appropriate vertex
is chosen by using a lookup table. The isosurface quadrilaterals are then split
into two triangles.
As will be discussed in Section 3.3.3, there is a correspondence between the
Dual Marching Cubes lookup table and the Marching Cubes lookup table
(Figure 2.16). The name Dual Marching Cubes comes from this correspon-
dence between the two lookup tables.
For most conﬁgurations in Figure 3.13, Dual Marching Cubes creates two,
three or four isosurface vertices in the grid cube. However, for two conﬁgurations,
2B and 3B, Dual Marching Cubes still adds only a single isosurface vertex. As
discussed in Section 3.3.4, these conﬁgurations can create non-manifold surfaces.
A small modiﬁcation of Dual Marching Cubes changes the isosurface
patches for some instances of conﬁgurations 2B and 3B, avoiding non-manifold
edges created by those conﬁgurations. The modiﬁed algorithm, called Manifold
Dual Marching Cubes, produces an isosurface which is guaranteed to be a
manifold if the isovalue does not equal the scalar value of any grid vertex. The
modiﬁed algorithm is described in Section 3.3.5.
We ﬁrst describe a two dimensional version of the algorithm, which we call
Dual Marching Squares.
3.3.1
Dual Marching Squares
Input to the Dual Marching Squares algorithm is an isovalue and a set of
scalar values at the vertices of a two-dimensional regular grid. The algorithm
has three steps. (See Figure 3.14.) Read in the isocontour lookup table from a
preconstructed data ﬁle. For each interior bipolar grid edge e, retrieve from the
lookup table the two isocontour vertices associated with e and add an isocontour
edge between those vertices. Assign geometric locations to the isocontour vertices
based on the scalar values at the square edge endpoints. We explain the last two
steps below.
Since each square vertex is either positive or negative and a square has four
vertices, there are 24 = 16 diﬀerent conﬁgurations of square vertex labels. These
conﬁgurations are listed in Figure 2.2 in Chapter 2.

76
3. Dual Contouring
Read isocontour lookup table

For each interior bipolar grid edge, construct a dual isocontour edge

Compute isocontour vertex coordinates
Figure 3.14. Dual Marching Squares.
The number and connectivity of the isocontour vertices within each square
c is determined from the conﬁguration of the square’s vertex labels.
If the
conﬁguration has two bipolar edges, then the conﬁguration has a single vertex,
w1
c, associated with both bipolar edges. This vertex will be an endpoint of the
isocontour edges dual to each bipolar edge. If the conﬁguration has four bipolar
edges, then the conﬁguration has two isocontour vertices, w1
c and w2
c, one for each
positive vertex. Associate the isocontour vertex corresponding to negative vertex
v with the two square edges incident on v. Similarly, associate the isocontour
vertex corresponding to negative vertex v′ with the two square edges incident on
v′. Each vertex will be an endpoint of two isocontour edges dual to the associated
square edges. The isocontour generated for each conﬁguration is illustrated in
Figure 3.18.
The isocontour lookup table stores the association between isocontour ver-
tices and square edges. An entry in the table is referenced as Table[κ, e], where κ is
a conﬁguration of square vertex labels and e is a bipolar edge of κ. Each entry is
1 or 2 corresponding to isocontour vertex w1 or vertex w2, respectively. If a con-
ﬁguration κ has two bipolar edges, e1 and e2, then Table[κ, e1] = Table[κ, e2] = 1.
representing the single isocontour vertex, w1, for conﬁguration κ. If a conﬁgura-
tion κ has four bipolar edges, e1, e2, e3, and e4, and e1 and e2 share a negative
vertex, and e3 and e4 share a negative vertex, then Table[κ, e1] = Table[κ, e2] = 1,
representing vertex w1, and Table[κ, e3] = Table[κ, e4] = 2, representing w2. Ver-
tices w1 and w2 are the two isocontour vertices for conﬁguration κ.
The algorithm for positioning the isocontour vertices, wm
c , is similar to the
one in Surface Nets, but uses only the bipolar edges associated with wm
c . For
each bipolar edge e, approximate the intersection we of e and the isocontour
using linear interpolation as described in Section 1.7.2. Point we equals (1 −α)p
+ αq where α = (σ−sp)/(sq −sp). Locate isocontour vertex wm
c at the midpoint
of line segment (we, we′), where e and e′ are the edges associated with wm
c .
The Dual Marching Squares algorithm is presented in Figures 3.14–
3.17. Function LinearInterpolation, called by this algorithm, is deﬁned in
Algorithm 1.1 in Section 1.7.2.

3.3. Dual Marching Cubes
77
c1 ←grid square below/left edge e
c2 ←grid square above/right edge e

w1 ←isocontour vertex of c1 associated with edge e
w2 ←isocontour vertex of c2 associated with edge e

Return segment (w1, w2)
Figure 3.15. Construct isocontour edge dual to grid edge e.
κ ←conﬁguration of vertex signs of c

e′ ←edge of unit square corresponding to edge e of c

m ←Table[κ, e′]

Return(wm
c )
Figure 3.16. Return isocontour vertex of grid square c associated with edge e.
For each bipolar grid edge e = (v, v′),
we ←LinearInterpolation(v, F(v), v′, F(v′), σ)

For each grid square c,
For each isosurface vertex wm
c in c,
(e, e′) ←edges of c associated with wm
c ;
coordinates(wm
c ) ←midpoint of (we, we′)
Figure 3.17. Compute vertex coordinates. F(v) is the scalar value of v and σ is the
isovalue.

78
3. Dual Contouring
16
8
7
6
15
14
13
12
11
10
9
5
4
3
2
1
Figure 3.18. Dual Marching Squares isocontours.
3.3.2
3D Dual Marching Cubes
Input to the Dual Marching Cubes algorithm is an isovalue and a set of
scalar values at the vertices of a three-dimensional regular grid. The algorithm
has four steps. (See Figure 3.19.) Read in the isocontour lookup table from a
preconstructed data ﬁle. For each interior bipolar grid edge e, retrieve from the
lookup table the four isosurface vertices associated with e and add an isosurface
quadrilateral between those vertices. Assign geometric locations to the isocon-
tour vertices based on the scalar values at the square edge endpoints. Triangulate
the isosurface quadrilaterals. We explain the last three steps next.
Since each cube vertex is either positive or negative and a cube has eight
vertices, there are 28 = 256 diﬀerent conﬁgurations of cube vertex labels. These
conﬁgurations are listed in Figure 2.15 in Chapter 2.
Read isosurface lookup table

For each interior bipolar grid edge,
construct a dual isosurface quadrilateral

Compute isosurface vertex coordinates

Triangulate the isosurface quadrilaterals
Figure 3.19. Dual Marching Cubes.

3.3. Dual Marching Cubes
79
(c1, c2, c3, c4) ←grid cubes containing e
(listed in circular order around e)

For i ←1 to 4,
wi ←isosurface vertex of ci associated with edge e

Return quadrilateral (w1, w2, w3, w4)
Figure 3.20. Construct isosurface quadrilateral dual to grid edge e.
κ ←conﬁguration of vertex signs of c

e′ ←edge of unit cube corresponding to edge e of c

m ←Table[κ, e′]

Return(wm
c )
Figure 3.21. Return isosurface vertex of grid cube c associated with edge e.
For each bipolar grid edge e = (v, v′),
we ←LinearInterpolation(v, F(v), v′, F(v′), σ)

For each grid cube c,
For each isosurface vertex wm
c in c,
coordinates(wm
c ) ←
centroid of {we : edge e is associated with wm
c }
Figure 3.22. Compute vertex coordinates.
F(v) is the scalar value of v.
σ is the
isovalue.

80
3. Dual Contouring
4F
4C
2A
Zero
One
Two
Three
Four
Five
Six
Seven
Eight
2B
2C
0
1
3A
3B
3C
4A
4B
4D
4E
5A
5B
5C
6A
6B
6C
7
8
# Positive
Vertices
Figure 3.23. Dual Marching Cubes isosurface patches.

3.3. Dual Marching Cubes
81
The number and connectivity of the isosurface vertices within each cube
is determined from the conﬁguration of the cube’s vertex labels.
There are
22 distinct cube conﬁgurations after rotation and/or reﬂection. The isosurface
vertices and edges for the twenty-two distinct conﬁgurations are represented in
Figure 3.23.
Conﬁguration 1 with a single positive vertex has a single isosurface vertex
associated with its three bipolar edges. This vertex will be an endpoint of the
isosurface edges dual to each bipolar edge. Conﬁguration 2A with two adjacent
positive vertices also has a single isosurface vertex associated with its four bipo-
lar edges. Conﬁguration 2C with two nonadjacent positive vertices, v and v′,
has two isosurface vertices. Isosurface quadrilaterals incident to one isosurface
vertex intersect the three cube edges incident on v. Isosurface quadrilaterals
incident to the other isosurface vertex intersect the three cube edges incident
on v′.
Conﬁguration 4F generates four isosurface vertices, the most for any
conﬁguration.
The isosurface lookup table, Table stores the association between isosurface
vertices and cube edges. An entry in the table is referenced as Table[κ, e], where
κ is a conﬁguration of cube vertex labels and e is a bipolar edge of κ. Each entry
is 1, 2, 3, or 4 corresponding to isosurface vertex w1, w2, w3, or w4. An additional
table, NumVertices, stores the number of isosurface vertices for conﬁguration κ.
For instance, when κ is conﬁguration 1 with three bipolar edges, e1, e2, and
e3, then Table[κ, e1] = Table[κ, e2] = Table[κ, e3] = 1 and NumVertices[κ] = 1.
When κ is conﬁguration 2C with two positive grid vertices, v and v′, with grid
edges e1, e2, and e3 incident on v and grid edges e′
1, e′
2, and e′
3 incident on v′,
then Table[κ, e1] = Table[κ, e2] = Table[κ, e3] = 1 and Table[κ, e′
1] = Table[κ, e′
2] =
Table[κ, e′
3] = 2 and NumVertices[κ] = 2. (See Figure 3.24.)
v
v′
e1
e2
e3
e′
1
e′
2
e′
3
Figure 3.24. Conﬁguration 2C: Grid edges intersected by the Dual Marching Cubes
isosurface.

82
3. Dual Contouring
Input
: F is a 3D array of scalar values.
Coord is a 3D array of (x, y, z) coordinates.
σ is an isovalue.
Result
: Set Quad of isosurface quadrilaterals and array VertexCoord of
vertex coordinates.
DualMarchingCubes(F,Coord, σ, Quad)
1 Read Dual Marching Cubes lookup table into Table;
/* Assign “+” or “−” signs to each vertex
*/
2 foreach grid vertex (i, j, k) do
3
if F[i, j, k] < σ then Sign[i, j, k] ←“−”;
4
else Sign[i, j, k] ←“+”;
/* F[i, j, k] ≥σ */
5 end
6 ConstructQuadrilaterals (Sign, Quad);
7 ComputeVertexCoordinates (F, Coord, σ, Sign, VertexCoord);
Algorithm 3.1. Dual Marching Cubes.
The algorithm for positioning the isosurface vertices is similar to the one
in Surface Nets but uses only the bipolar edges associated with wm
c .
For
each bipolar edge e, approximate the intersection we of e and the isosurface
using linear interpolation as described in Section 1.7.2. Point we equals (1 −α)p
+ αq where α = (σ −sp)/(sq −sp).
Let e1, e2, . . . , ek be the bipolar grid
edges associated with isosurface vertex wm
c .
Locate isosurface vertex wm
c
at
the centroid, (we1 + we2 + · · · + wek)/k, of the points we1, we2, . . . , wek, where
e1, e2, . . . , ek are the bipolar grid edges associated with isosurface vertex wm
c .
As with Surface Nets, we replace each quadrilateral around bipolar edge
e by two or four triangles, depending on the envelope of e. To construct the
isosurface patch with two triangles, we use the diagonal that minimizes the
maximum triangle angle.
The Dual Marching Cubes algorithm is presented in Algorithm 3.1. Func-
tion LinearInterpolation, called by this algorithm, is deﬁned in Algorithm 1.1
in Section 1.7.2.
3.3.3
Lookup Table Duality
The Dual Marching Cubes lookup table in Figure 3.23 is dual to the March-
ing Cubes lookup table in Figure 2.16. Let κ be a conﬁguration of positive and
negative cube vertices.
Each connected component λdual of the isosurface patch for κ in the Dual
Marching Cubes lookup table corresponds to a connected component λ of the
isosurface patch for κ in the Marching Cubes lookup table. Each isosurface

3.3. Dual Marching Cubes
83
ConstructQuadrilaterals(Sign, Quad)
1 Quad ←∅;
2 foreach interior grid bipolar grid edge e do
/* construct isosurface quadrilateral dual to e
*/
3
for l = 1 to 4 do
4
(i, j, k) ←index of l’th grid cube (in circular order) containing e;
5
κ ←(Sign[i, j, k], Sign[i, j, k+1], . . . , Sign[i+1, j+1, k+1]);
6
m ←GetVertexIndex(i, j, k, e, κ);
7
QuadVert[l] ←(i, j, k, m);
8
end
9
Quad ←Quad ∪{(QuadVert[1], QuadVert[2], QuadVert[3], QuadVert[4])};
10 end
ComputeVertexCoordinates(F, Coord, σ, Sign, VertexCoord)
/* Approximate intersection of isocontour and bipolar edges
*/
1 foreach bipolar grid edge e with endpoints (i1, j1, k1) and (i2, j2, k2) do
2
we ←LinearInterpolation
3
(Coord[i1, j1, k1], F[i1, j1, k1], Coord[i2, j2, k2], F[i2, j2, k2], σ);
4 end
/* Compute vertex coordinates
*/
5 foreach grid cube (i, j, k) do
6
κ ←(Sign[i, j, k], Sign[i, j, k+1], . . . , Sign[i+1, j+1, k+1]);
7
for m ←1 to NumVertices[κ] do
8
VertexCoord[i, j, m] ←(0, 0, 0);
9
NumIncident[m] ←0;
10
end
11
foreach bipolar edge e of grid cube (i, j, k) do
12
m ←GetVertexIndex(i, j, k, e, κ);
13
VertexCoord[i, j, k, m] ←VertexCoord[i, j, k, m] + we;
14
NumIncident[m] ←NumIncident[m] + 1;
15
end
16
for m ←1 to NumVertices[κ] do
17
VertexCoord[i, j, m] ←VertexCoord[i, j, m]/NumIncident[m];
18
end
19 end
Function GetVertexIndex(i, j, k, e, κ)
1 e′ ←edge of unit cube corresponding to edge e in cube (i, j, k);
2 m ←Table[κ, e′];
3 return (m);
Algorithm 3.2. Subroutines for Dual Marching Cubes.

84
3. Dual Contouring
3B
4C
4F
3B
4C
4F
Figure 3.25. Examples of isosurface patches from the Dual Marching Cubes lookup
table for conﬁgurations 3B, 4C, and 4F and the corresponding patches for Marching
Cubes.
quadrilateral in λdual intersecting bipolar edge e corresponds to an isosurface
vertex in λ lying on bipolar edge e.
On the other hand, λdual contains one and only one isosurface vertex. Thus,
each isosurface vertex of the isosurface patch for κ in the Dual Marching
Cubes lookup table corresponds to a connected component of the isosurface
patch for κ in the Marching Cubes lookup table.
Figure 3.25 contains three examples of isosurface patches for the Dual
Marching Cubes lookup table and the corresponding isosurface patches for
Marching Cubes.
3.3.4
Non-Manifold Isosurface Patches
By adding more than one isosurface vertex per grid cube, Dual Marching
Cubes avoids many of the Surface Nets non-manifold constructions discussed
in Section 3.2.8. Unfortunately, Dual Marching Cubes still has some non-
manifold constructions. As shown in Figure 3.26, if cubes with conﬁgurations
2B and 3B are adjacent, then four isosurface quadrilaterals can meet in a single
isosurface edge. The problem is that the two near-vertical edges in conﬁgurations
2B and 3B in Figure 3.23 have the same two endpoints, and so merge into a single
isosurface edge.

3.3. Dual Marching Cubes
85
2B
2B
3B
3B
2B
3B
Figure 3.26. Dual Marching Cubes non-manifold constructions.
3.3.5
Manifold Dual Marching Cubes
The non-manifold problem described in the previous section could be solved by
adding more complex isosurface patches for conﬁgurations 2B and 3B. However,
there is a simple solution that avoids adding complexity to the isosurface patches.
Note that conﬁgurations 2B and 3B contain exactly one ambiguous facet.
They are the only conﬁgurations in Figure 3.23 containing exactly one ambiguous
facet. The only case in which four isosurface quadrilaterals share an edge is when
a grid cube with conﬁguration 2B or 3B shares its ambiguous facet with another
grid cube with conﬁguration 2B or 3B.
As discussed in Section 2.3.5 and illustrated in Figure 2.22, every ambiguous
conﬁguration has two “natural” Marching Cubes isosurface patches, one sep-
arating negative vertices and one separating positive vertices. Similarly, every
ambiguous conﬁguration has two “natural” Dual Marching Cubes isosurface
patches. The two Dual Marching Cubes isosurface patches for conﬁgurations
2B and 3B are illustrated in Figure 3.27. For each conﬁguration, one isosurface
patch has a single connected component and the other isosurface patch has two
connected components.
Manifold Dual Marching Cubes avoids creating non-manifold edges by
using isosurface patches 2B-II and 3B-II instead of 2B-I and 3B-I whenever two
cubes with conﬁgurations 2B and 3B share their ambiguous facets. Note that
the isosurface patches for both cubes must be replaced, otherwise the patches
will not align along their boundaries as discussed in Section 2.3.5. Moreover, if
a cube c with conﬁguration 2B or 3B shares an ambiguous facet with a cube
c′ with conﬁguration other than 2B or 3B, isosurface patch 2B-I or 3B-I should
be used. Cube c′ will have two isosurface vertices connected by two distinct
isosurface edges to the isosurface vertex in c, and each isosurface edge will have
only two incident quadrilaterals. If isosurface patch 2B-II or 3B-II were used for
cube c, then there would be misalignment between the isosurface patches in c
and c′.

86
3. Dual Contouring
2B−II
2B−I
3B−I
3B−II
Figure 3.27.
Isosurface patches 2B-I, 2B-II, 3B-I, and 3B-II for Manifold Dual
Marching Cubes.
Manifold Dual Marching Cubes uses a modiﬁcation of the algorithm
in Figure 3.21 for retrieving the isosurface vertex of grid cube c associated with
edge e. Let Table1 be the Dual Marching Cubes isosurface lookup table as
described in Section 3.3.2. Let Table2 be the same as Table1, except that conﬁgu-
rations 2B and 3B use isosurface patches 2B-II and 3B-II. If cube c with conﬁg-
uration type 2B or 3B shares its ambiguous facet with a cube with conﬁguration
type 2B or 3B, then return Table2[κ, e′] instead of Table1[κ, e′] (Figure 3.28). All
other routines are exactly the same.
3.3.6
Isosurface Properties
Properties 1–6 of the Manifold Dual Marching Cubes isosurface are the
same as Properties 1–6 of the Surface Nets isosurface. The isosurface pro-
duced by Manifold Dual Marching Cubes depends on the placement of
the vertices within each grid cube and the construction of the surface bounded
by each quadrilateral. The properties listed below apply to Manifold Dual
Marching Cubes where vertices are placed at the centroid of edge-isosurface
intersection points and each quadrilateral is triangulated into two or four tri-
angles. A quadrilateral around grid edge e is triangulated into two triangles,
Δ1 and Δ2, using the diagonal that minimizes the maximum triangle angle.
A quadrilateral is triangulated into four triangles if Δ1 or Δ2 are not in the
envelope of e.
Manifold Dual Marching Cubes returns a ﬁnite set, Υ, of triangles.
The isosurface is the union of these triangles. The vertices of the isosurface are

3.3. Dual Marching Cubes
87
κ ←conﬁguration of vertex signs of c

e′ ←edge of unit cube corresponding to edge e of c

If c shares an ambiguous facet f with cube c′ and
f is the only ambiguous facet of c and c′, then
m ←Table2[κ, e′]
else
m ←Table1[κ, e′]

Return(wm
c )
Figure 3.28. Manifold Dual Marching Cubes: Return isosurface vertex of grid
cube c associated with edge e.
the triangle vertices. As deﬁned in Section 3.1, Γinner is the subgrid of interior
grid cubes of Γ.
The following properties apply to all isosurfaces produced by Manifold
Dual Marching Cubes.
Property 1.
The isosurface is piecewise linear.
Property 2.
Set Υ contains at most 4m triangles where m is the number of
bipolar grid edges.
Property 3.
The isosurface does not contain any grid vertices whose scalar
values do not equal the isovalue.
Property 4.
The isosurface intersects at exactly one point every interior bipolar
grid edge whose positive endpoint is strictly positive.
Property 5.
The isosurface does not intersect any negative or strictly positive
grid edges.
Property 6.
The isosurface strictly separates the strictly positive grid vertices of
Γinner from the negative vertices of Γinner.
Properties 3–5 imply that the isosurface intersects a minimum number of grid
edges.

88
3. Dual Contouring
As deﬁned in Section 3.1, the Γouter is the set of boundary grid cubes of Γ.
The following properties apply to a Manifold Dual Marching Cubes iso-
surface whose isovalues do not equal the scalar value of any grid vertex.
Property 7.
The isosurface is a piecewise linear, orientable 2-manifold with
boundary.
Property 8.
The boundary of the isosurface is contained in Γouter.
Property 9.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
3.3.7
Proof of Isosurface Properties
The proof of Properties 1–6 are similar to the proofs in Sections 3.2.5–3.2.7 for
Surface Nets and are omitted.
We ﬁrst prove that Υ is a triangulation of the isosurface (Property 9). To
prove this property, we need some lemmas about the separation of isosurface
vertices and about the separation of envelopes around bipolar edges.
Lemma 3.14. Let e and e′ be distinct bipolar edges of cube c. Let w and w′ be
distinct isosurface vertices in cube c where w is associated with edge e and w′ is
associated with edge e′. If no vertex of c has scalar value equal to the isovalue,
then some plane separates w ∪e from w′ ∪e′ and does not contain w or w′.
Proof: Cube c must have a conﬁguration that contains at least two distinct iso-
surface vertices. For conﬁgurations 2B, 2C, 3B, 3C, 4E, 4F, 5B, 5C, 6B, and 6C,
either w or w′ are incident on exactly three isosurface quadrilaterals. (Conﬁgu-
rations 2B and 3B have two isosurface vertices when we use isosurface patches
2B-II and 3B-II.) Without loss of generality, assume that w is incident on exactly
three isosurface quadrilaterals.
Isosurface vertex w is the centroid of exactly three points on three cube edges,
and these three cube edges are incident on a single grid vertex v. The convex
hull of v and its three incident cube edges are a tetrahedron. Let f be the facet
of this tetrahedron that does not contain v, and let h be the plane containing f.
Plane h separates w ∪e from w′ ∪e′. Because no vertex of c has scalar value
equal to the isovalue, point w is the centroid of three points that lie on one side
of h, so w is not on h. Similarly, point w′ is the centroid of points that lie on
the other side of h, so w′ is not on h.
For conﬁgurations 4C, let h be the plane through the two positive grid edges.
Plane h separates w ∪e from w′ ∪e′. Since no vertex of c has scalar value equal
to the isovalue, point w is the centroid of four points that lie on one side of
h, and point w′ is the centroid of four points that lie on the other side. Thus,
neither w nor w′ lie on h.
□

3.3. Dual Marching Cubes
89
Each interior bipolar edge e is associated with four isosurface vertices, one in
each grid cube containing e. These four isosurface vertices determine an envelope
around e as described in Section 3.2.3.
Lemma 3.15. The envelopes of two diﬀerent interior bipolar grid edges intersect
only at shared vertices, edges, or facets.
Proof: Let e and e′ be two diﬀerent interior bipolar grid edges.
Let c be a
grid cube containing both e and e′. Let w be the isosurface vertex in cube c
associated with e. Let w′ be the isosurface vertex in cube c′ associated with e′.
By Lemma 3.14, if w does not equal w′, then there is some plane that separates
w ∪e from w′ ∪e′. This plane separates the two envelopes. The two envelopes
may only intersect if they share isosurface vertices and/or a vertex at e ∩e′.
If they share such vertices, then their intersection is a vertex, edge, or facet
determined by such shared vertices.
□
Property 9.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
The proof that set Υ does not contain any zero-area triangles or duplicate
triangles is exactly the same as the proof in Section 3.2.7 for Surface Nets,
and is omitted.
Proof that set Υ is a triangulation: Each envelope around an interior bipolar edge
contains two or four isosurface triangles.
The nonempty intersection of any
two triangles within an envelope is a vertex or edge of each. By Lemma 3.15,
envelopes of diﬀerent bipolar edges intersect only at shared vertices, edges, or
facets. Thus, the triangles in diﬀerent envelopes intersect only at shared edges
or vertices.
□
Finally, we prove that the isosurface is a 2-manifold.
Property 7.
The isosurface is a piecewise linear, orientable 2-manifold with
boundary.
Property 8.
The boundary of the isosurface is contained in Γouter.
Proof: Since Υ is a triangulation of the isosurface, we need only check that ev-
ery isosurface edge is contained in at most two isosurface triangles and that the
neighborhood of every isosurface vertex is a disk. Inspection of the isosurface
patches in Figure 3.23 shows that this is true for all conﬁgurations except for
conﬁgurations 2B and 3B. As discussed in Section 3.3.4, when a cube c with
conﬁguration 2B or 3B shares its ambiguous facet with another cube c′ with
conﬁguration 2B or 3B, an isosurface edge is shared by four isosurface triangles.
However, in this case, the Manifold Dual Marching Cubes algorithm re-
places isosurface patches 2B-1 or 3B-I with 2B-II or 3B-II, respectively, in both

90
3. Dual Contouring
cubes. Each edge in these isosurface patches lies in only two triangles, and the
neighborhood of each vertex is a disk. Because c and c′ have only one ambiguous
facet, the new isosurface patches in c and c′ still align with all of their neighbors.
Let w be an isosurface vertex in grid cube c ∈Γinner. The triangles containing
w form a topological disk, and w is in the interior of this disk. Every isosurface
edge incident on w is contained in exactly two triangles. Thus, neither w nor
any isosurface edge incident on w is on the boundary of the isosurface. The only
vertices on the boundary of the isosurface are isosurface vertices contained in
Γouter. The only edges on the boundary of the isosurface are edges connecting
vertices in Γouter and are also contained in Γouter. Thus, the boundary of the
isosurface is contained in Γouter.
□
3.4
Comparison of Algorithms
Table 3.1 compares isosurfaces constructed by Marching Cubes, Surface
Nets, and Manifold Dual Marching Cubes on engine, carp, and tooth
data sets. The vertex and triangle counts for Nielson’s original Dual Marching
Cubes are almost exactly the same as for Manifold Dual Marching Cubes
and are omitted. As can be seen, the number of isosurface vertices and triangles
is about the same in each. The only signiﬁcant diﬀerence is Tooth with isovalue
386.
This is a particularly noisy isosurface with many small components of
noise.
Figure 3.29 displays isosurfaces constructed by Marching Cubes, Surface
Nets, Dual Marching Cubes, and Manifold Dual Marching Cubes.
Data set
Isovalue
Algorithm
# Vertices
# Triangles
Engine
80.5
Marching Cubes
298,000
594,000
Engine
80.5
Surface Nets
297,000
592,000
Engine
80.5
Manifold Dual MC
297,000
592,000
Carp
1150.5
Marching Cubes
670,000
1,342,000
Carp
1150.5
Surface Nets
662,000
1,340,000
Carp
1150.5
Manifold Dual MC
672,000
1,340,000
Tooth
386.5
Marching Cubes
3,374,000
6,898,000
Tooth
386.5
Surface Nets
2,904,000
6,690,000
Tooth
386.5
Manifold Dual MC
3,345,000
6,690,000
Tooth
640.5
Marching Cubes
64,000
128,000
Tooth
640.5
Surface Nets
64,000
128,000
Tooth
640.5
Manifold Dual MC
64,000
128,000
Table 3.1. Comparison of isosurfaces produced by Marching Cubes, Surface Nets,
and Manifold Dual Marching Cubes, including the number of vertices and number
of triangles in each isosurface.

3.4. Comparison of Algorithms
91
(a) Marching Cubes.
(b) Surface Nets.
(c) Dual Marching Cubes.
(d) Manifold Dual MC.
Figure 3.29. Skeleton of the tail of a carp. Subsampled (8:1) carp data set. Isovalue
1150.5. (a) Marching Cubes isosurface. (b) Surface Nets triangulated isosurface.
(c) Dual Marching Cubes triangulated isosurface. (d) Manifold Dual Marching
Cubes triangulated isosurface. (Data set was created by Michael Scheuring, Computer
Graphics Group, University of Erlangen, Germany.)

92
3. Dual Contouring
(a) Dual Marching Cubes.
(b) Manifold Dual MC.
Figure 3.30.
Isosurface of quadrilaterals from the carp data set, isovalue 1150.5.
(a) Dual Marching Cubes isosurface. (b) Manifold Dual Marching Cubes iso-
surface.
The isosurface is the skeleton of a carp. The isovalue, 1150.5, does not equal
the scalar value of any grid vertex, so the Marching Cubes and Manifold
Dual Marching Cubes isosurfaces are manifolds. (The scalar values of the
grid vertices are all integers.)
The data set was subsampled (8:1) to better
show the mesh edges and to illustrate the diﬀerences among the algorithms.
The isosurface is particularly challenging for isosurface reconstruction algorithms
because of the narrow bone structures. (The subsampling adds to the diﬃculty.)
Figure 3.30 displays the quadrilaterals in the Dual Marching Cubes and
Manifold Dual Marching Cubes isosurfaces.
Visual comparison of the Marching Cubes isosurface (Figure 3.29(a)) with
the other isosurfaces (Figures 3.29(b), (c), and (d)) shows many more thin, small
angle triangles in the Marching Cubes isosurface. The small, thin triangles
create distracting visual artifacts in the isosurface. They also make the mesh
unsuitable for ﬁnite element methods [Shewchuk, 2002].
The Marching Cubes isosurface is a manifold, whereas the Surface Nets
and Dual Marching Cubes isosurfaces are not.
Many of the long bones
are pinched in the Surface Nets isosurface. (Compare the rectangular green
regions in Figures 3.29(a), (b), and (c).) The Dual Marching Cubes isosurface
does a much better job of modeling the ﬁne bone structure than the Surface
Nets algorithm does. However, even the Dual Marching Cubes has some
pinching to a line segment. (See regions circled in red in Figure 3.29(c).) This

3.5. Notes and Comments
93
pinching is caused by the non-manifold cases discussed in Section 3.3.4 and
illustrated in Figure 3.26.
The Manifold Dual Marching Cubes isosurface is a manifold.
The
non-manifold pinched regions have been eliminated by changes in the isosurface
patches around those regions. However, those changes have also changed the
isosurface topology, disconnecting some of the bones. (See regions circled in red
in Figure 3.29(d).)
We should note that the pinching in Figure 3.29 is a result of the subsampling
of the data set. As shown in Figures 3.31(b) and (c), the full-resolution Sur-
face Nets and Dual Marching Cubes isosurfaces have no such pinching and
look similar to the full-resolution Marching Cubes isosurface (Figure 3.29(a)).
Similarly, the full-resolution Manifold Dual Marching Cubes isosurface in
Figure 3.31(d) does not have disconnected bones and also looks similar to the
other three isosurfaces.
The pinching in Figure 3.29 is also a result of the long, narrow bone structure
being modeled by the isosurface. For many isosurfaces, the subsampled Surface
Nets isosurface has no such problems.
Even though the full-resolution Surface Nets isosurface in Figure 3.31(b)
looks much better than its subsampled version, the isosurface still has about
8,000 non-manifold edges and 1,100 non-manifold vertices.
Even the full-
resolution Dual Marching Cubes isosurface has 875 non-manifold edges. The
Manifold Dual Marching Cubes algorithm changes the isosurface patches
in 1,750 (= 2 × 875) cubes from 2B-I or 3B-I to 2B-II or 3B-II to avoid such
non-manifold edges.
3.5
Notes and Comments
Gibson, in [Gibson, 1998a, Gibson, 1998b], introduced the Surface Nets al-
gorithm. The term dual contouring was used in [Ju et al., 2002] to describe
isosurface construction algorithms similar to Surface Nets, which place ver-
tices inside grid cubes.
Surface normals at the intersection points of grid edges and the isosurface can
be used to locate isosurface vertices on sharp corners or edges in the isosurface.
Using these surface normals with dual contouring, Ju et al. [Ju et al., 2002]
constructed isosurfaces with sharp features. Further details of their algorithm
are included in [Schaefer and Warren, 2002]. To allow ﬁner control over small
features, Varadhan et al. [Varadhan et al., 2003] modiﬁed the dual contouring
algorithm to model two intersections of the isosurface and each grid edge. Zhang,
Hong, and Kaufman [Zhang et al., 2004] modiﬁed the algorithm further to model
even more complicated structures within a grid cube.
These papers assume
that the input includes a continuous scalar function, either explicitly deﬁned or

94
3. Dual Contouring
(a) Marching Cubes.
(b) Surface Nets.
(c) Dual Marching Cubes.
(d) Manifold Dual MC.
Figure 3.31. Full-resolution isosurfaces from the carp data set, isovalue 1150.5. (a) Full-
resolution Marching Cubes isosurface. (b) Full-resolution Surface Nets isosurface.
(c) Full-resolution Dual Marching Cubes isosurface. (d) Full-resolution Manifold
Dual Marching Cubes isosurface.

3.5. Notes and Comments
95
deﬁned as the signed distance to a polygonal mesh, and they compute the surface
normals using that function.
Dual contouring algorithms are easily adaptable to multiresolution isosurface
construction. Constructing multiresolution isosurfaces using dual contouring is
discussed in Section 10.2.
Dual Marching Cubes by Nielson [Nielson, 2004] reads a “dual contour-
ing” lookup table to place and connect isosurface vertices in grid cubes. The
Dual Marching Cubes lookup table is “dual” to the Marching Cubes
lookup table. Schaefer, Ju, and Warren [Schaefer et al., 2007] generalize Nielson’s
algorithm to multiresolution isosurfaces.
Ashida and Badler [Ashida and Badler, 2003] and Greß and Klein [Greß and
Klein, 2004] give dual contouring algorithms that produce isosurfaces similar to
the Dual Marching Cubes isosurface with multiple isosurface vertices in a
grid cube. Their algorithms determine connectivity between isosurface vertices
directly from the grid without using a lookup table.
Ju and Udeshi [Ju and Udeshi, 2006] discuss the problem of self-intersections
in the dual contouring isosurface caused by triangulating the isosurface quadri-
lateral. They present a solution by adding a vertex on the bipolar edge sur-
rounded by the quadrilateral and adding four triangles incident on this vertex.
Wang [Wang, 2011] describes orientation tests for determining when four trian-
gles are necessary.

This page intentionally left blank
This page intentionally left blank

CHAPTER 4
MULTILINEAR INTERPOLATION
The Marching Cubes and dual contouring algorithms construct isosurfaces as
approximations to the level set φ−1(σ). However, the scalar function φ is not
given; only function values at the vertices of the regular grid are known. In what
sense does an isosurface approximate a level set φ−1(σ) when φ is unknown?
One way to answer this question is to build a continuous scalar function,
φ, from the regular scalar grid. The level set φ−1(σ) is well-deﬁned and the
isosurface can be measured against φ. Natural scalar functions on the 2D square
and the 3D cube are the bilinear and trilinear interpolants. Applying the bilinear
interpolant to each 2D grid square and combining the results gives a function on
the entire grid. Similarly, combining the trilinear interpolants applied to each
3D grid cube gives a function on a 3D grid.
As discussed in Sections 2.2.5 and 2.3.5, Marching Squares and March-
ing Cubes have ambiguous conﬁgurations where there are multiple ways of
connecting the isosurface vertices into an isosurface patch. In Chapter 2, the
ambiguous conﬁgurations were resolved by choosing a single isosurface patch for
each conﬁguration. In 3D, it is necessary to make sure that these choices are
compatible, i.e., the isosurface patches in any two adjacent cubes match on their
shared facet.
The bilinear and trilinear interpolants give an alternate method for resolving
ambiguous conﬁgurations. Instead of always using the same isosurface patch for
a conﬁguration, use the isosurface patch that matches the topology of the level
set of the bilinear or trilinear interpolants. By doing so, one builds an isosurface
that is homeomorphic to the level set φ−1(σ) where φ is the function determined
by the bilinear or trilinear interpolant.
In Section 4.1, we discuss bilinear interpolation and its use in resolving the
ambiguous cases in Marching Squares. The Asymptotic Decider algo-
rithm by Nielson and Hamann [Nielson and Hamann, 1991] uses bilinear inter-
polation on grid facets to resolve ambiguities on the grid facets. In Section 4.2, we
present a variation of the algorithm from [Nielson and Hamann, 1991]. Finally,
in Section 4.3, we brieﬂy discuss trilinear interpolation and its use in isosurface
construction.
97

98
4. Multilinear Interpolation
5
5.2
5.4
5.6
5.8
6
0
0.2
0.4
0.6
0.8
1
0
0.2
0.4
0.6
0.8
1
0
0.2
0.4
0.6
0.8
1
0
0.2
0.4
0.6
0.8
1
0
0.2
0.4
0.6
0.8
1
0
0.2
0.4
0.6
0.8
1
(a) Level sets of φ.
(b) φ−1(5.0).
(c) φ−1(6.0).
Figure 4.1. (a) Level sets of the bilinear function φ(x, y) = 2(1 −x)(1 −y) + 7x(1 −y)
+ 9(1 −x)y + 4xy. Function φ is the bilinear interpolant of scalar values s0,0 = 2 and
s0,1 = 9 and s1,0 = 7 and s1,1 = 4. (b) Level set φ−1(5.0). Vertices (1, 0) and (0, 1)
have scalar value greater than 5.0. (c) Level set φ−1(6.0). Vertices (1, 0) and (0, 1)
have scalar value greater than 6.0.
4.1
Bilinear Interpolation: 2D
4.1.1
The Bilinear Interpolant
Consider the unit square cU with vertices (0, 0), (0, 1), (1, 0), and (1, 1) and with
scalar values s0,0, s0,1, s1,0, and s1,1, respectively. Points in the unit square are
(x, y) where 0 ≤x ≤1 and 0 ≤y ≤1. The function φ : R2 →R where
φ(x, y) = (1 −x, x)

s0,0
s0,1
s1,0
s1,1
 
1 −y
y

(4.1)
is the bilinear interpolant of the scalar values at the vertices. Equivalently,
φ(x, y) = (1 −x)(1 −y)s0,0 + x(1 −y)s1,0 + (1 −x)ys0,1 + xys1,1.
The bilinear interpolant can be constructed on grid squares other than cU by
translating them to cU, and then applying the bilinear interpolant on cU.
For almost all σ ∈R, the level set {(x, y) : φ(x, y) = σ} consists of a hyper-
bola with two branches. Figure 4.1(a) contains an example of the level sets of a
bilinear function. The function is the bilinear interpolant of the scalar values 2,
7, 9, and 4, at the square vertices (0, 0), (1, 0), (0, 1), and (1, 1), respectively. Fig-
ure 4.1(b) contains an example of the level set φ−1(5.0). Figure 4.1(b) contains
an example of the level set φ−1(6.0).
The two branches of the hyperbola deﬁned by φ−1(σ) may not both inter-
sect the unit square. In Figures 4.2(b) and 4.2(c), only one hyperbola branch

4.1. Bilinear Interpolation: 2D
99
1.5
1
0.5
–0.5
–1
2
1.5
1
0.5
–0.5
–1
1.5
1
0.5
–0.5
–1
2
1.5
1
0.5
–0.5
–1
1.5
1
0.5
–0.5
–1
2
1.5
1
0.5
–0.5
–1
(a) φ−1(1.0).
(b) φ−1(3.0).
(c) φ−1(8.0).
Figure 4.2. (a) Level set φ−1(1.0). Neither branch of the hyperbola intersects the unit
square. All four unit square vertices have scalar value greater than 1.0. (b) Level set
φ−1(3.0). One hyperbola branch intersects the unit square. Vertices (1, 0), (0, 1), and
(1, 1) have scalar value greater than 3.0. (c) Level set φ−1(8.0). One hyperbola branch
intersects the unit square. Vertex (1, 0) has scalar value greater than 8.0.
intersects the unit square. In Figures 4.2(a), neither branch of the hyperbola
representing φ−1(1) intersect the unit square.
As in Chapter 2, label a vertex as positive, “+”, if its scalar value is greater
than or equal to the isovalue σ, and negative, “−”, if its scalar value is below
the isovalue σ. Grid edges whose two endpoints are positive are called positive
edges. Grid edges whose two endpoints are negative are called negative edges.
When neither branch of the hyperbola intersects the square (Figure 4.2(a)),
either all the square vertices are positive or all the square vertices are negative.
When one hyperbola branch intersects the square (Figures 4.2(b) and 4.2(c)),
either exactly one vertex is positive or one vertex is negative or one edge is
positive and one edge is negative. None of these conﬁgurations are ambiguous.
The level set, φ−1(σ), intersects the square boundary at exactly two points.
The Marching Squares algorithm connects these two points by a single line
segment.
If both branches of the hyperbola deﬁned by φ−1(σ) intersect the unit square,
then two diagonally opposite square vertices are positive and the other two ver-
tices are negative. This is the 2D ambiguous conﬁguration. (See Figure 4.3.)
Conversely, if two diagonally opposite square vertices are positive and the other
two vertices are negative, then both hyperbola branches deﬁned by φ−1(σ) must
intersect the unit square.
There are two possible ways that the two hyperbola branches can intersect the
unit square. Either the two hyperbola branches separate the two negative square
vertices (Figure 4.1(b)) or they separate the two positive vertices (Figure 4.1(c)).

100
4. Multilinear Interpolation
16
8
8−I
16−I
16−II
8−II
Figure 4.3. Ambiguous square conﬁgurations.
Similarly, there are two possible ways to resolve a 2D ambiguous conﬁguration
with a pair of line segments. Either the two isocontour line segments separate
the two negative square vertices (8-I or 16-I in Figure 4.3) or the two isocontour
line segments separate the two positive vertices (8-II or 16-II in Figure 4.3).
4.1.2
The 2D Asymptotic Decider
The 2D Asymptotic Decider uses the bilinear interpolant to resolve 2D am-
biguous conﬁgurations. For each ambiguous grid square c, let φc be the bilinear
interpolant determined by the scalar values at the vertices of c. The level set,
φ−1
c (σ), of this bilinear interpolant is two hyperbola branches that both inter-
sect the grid square. If the hyperbola branches separate the negative vertices,
then the Asymptotic Decider adds two isocontour line segments separating
the negative vertices (8-I or 16-I). Otherwise, the hyperbola branches separate
the positive vertices and the Asymptotic Decider adds two isocontour line
segments separating the positive vertices (8-II or 16-II).
There is no need to actually construct the hyperbola branches to determine
how it intersects the unit square. Instead, one can determine the contour value
α such that φ−1(α) is the intersecting horizontal and vertical asymptotes. If
the isovalue σ is less than α, then the hyperbola branches separate the negative
vertices as in Figure 4.1(b). Otherwise, the hyperbola branches separate the
positive vertices as in Figure 4.1(c).

4.1. Bilinear Interpolation: 2D
101
Read isocontour lookup table

For each grid square,
retrieve isocontour edges from lookup table
using the bilinear interpolant to resolve ambiguous cases
(Algorithm BilinearIsoSquare)

Compute isocontour vertex coordinates using linear interpolation
Figure 4.4. Asymptotic Decider: 2D.
Equation 4.1 expands out to
φ(x, y)
=
s0,0 + x(s1,0 −s0,0) + y(s0,1 −s0,0)
+ xy(s0,0 −s0,1 −s1,0 + s1,1).
The asymptotes are given by either choosing x so that the coeﬃcient of y becomes
zero or choosing y so that the coeﬃcient of x become zero:

(x, y) : x =
s0,0 −s0,1
s0,0 −s0,1 −s1,0 + s1,1

,

(x, y) : y =
s0,0 −s1,0
s0,0 −s0,1 −s1,0 + s1,1

.
Plugging these values back into φ(x, y) gives
α =
s0,0s1,1 −s1,0s0,1
s0,0 −s0,1 −s1,0 + s1,1
.
The ambiguous conﬁguration is resolved by comparing the isovalue to this α. If
the isovalue is less than α, then two line segments are added that separate the
negative vertices as in 8-I and 16-I of Figure 4.3. If the isovalue is greater or
equal to α, then two line segments are added that separate the positive vertices
as in 8-II and 16-II of the ﬁgure.
Figure 4.5 contains Algorithm BilinearIsoSquare for resolving ambiguities
using the bilinear interpolant. The 2D Asymptotic Decider algorithm is in
Figure 4.4.

102
4. Multilinear Interpolation
κ ←type (1-16) of“+”/“−”conﬁguration
of the grid square vertices
If κ = 8 and
κ = 16
(not ambiguous)
then
else
Retrieve isocontour edges
from the lookup table
α =
s0,0s1,1 −s1,0s0,1
s0,0 −s0,1 −s1,0 + s1,1
If σ < α
then
else
Use isocontour edges
from κ-I (8-I or 16-I)
Use isocontour edges
from κ-II (8-II or 16-II)
Figure 4.5. BilinearIsoSquare: Retrieve isocontour edges (isovalue σ) from the
lookup table for a grid square using the bilinear interpolant to resolve ambiguous cases;
sx,y is the scalar value at vertex (x, y).
4.2
The Asymptotic Decider: 3D
The Marching Cubes algorithm presented in Chapter 2 resolves ambiguous
conﬁgurations arbitrarily.
Nielson and Hamann [Nielson and Hamann, 1991]
proposed using the bilinear interpolant to determine isosurface patches for the

4.2. The Asymptotic Decider: 3D
103
6C
2C
6B
5C
5B
4F
4E
4C
3C
3B
2B
Figure 4.6. Ambiguous cube conﬁgurations.
ambiguous 3D conﬁgurations.
We give an overview of their algorithm (Sec-
tion 4.2.1), and then present a variation based on pyramidal decomposition
(Section 4.2.2), which is easy to implement.
4.2.1
Resolving Ambiguous Facets
The intersection of an isosurface and a grid facet is an isocontour on that facet.
Instead of creating the isosurface patch within each cube, ﬁrst create the iso-
contour on each grid facet. Each grid facet has a conﬁguration of positive and
negative vertices given in Figure 2.2. Conﬁgurations 8 and 16 are the ambiguous
2D conﬁgurations. For all the nonambiguous conﬁgurations, use the isocontour
table in Figure 2.3 to determine the line segment forming the isocontour. For the
two ambiguous conﬁgurations, use the algorithm BilinearIsoSquare in Fig-
ure 4.5 to choose between isocontours 8-I and 8-II or 16-I and 16-II given in
Figure 4.3.
Each edge e of a grid cube c lies on two facets, f and f ′, of c. If edge e has
one positive and one negative endpoint, then both f and f ′ contain an isocontour
edge with endpoint on e. The isocontour edges on all six facets of c join together
to form one or more cycles forming an isocontour on the boundary of c. The
remaining problem is to add an isosurface patch inside the cube whose boundary
edges exactly match the computed isocontour edges.
Ambiguous conﬁgurations 2B, 3B, 5B, and 6B all have a single facet with
an ambiguous conﬁguration. Each of these conﬁgurations has two possible iso-
contours on its boundary. These isocontours are easy to connect with isosurface
patches. Figure 4.7 contains two isosurface patches for each such conﬁguration,
corresponding to the two possible isocontours. The choice of the 2D isocontour
in the single ambiguous facet determines the choice of isosurface patch in 3D.
The 2D isocontour separates the positive vertices in the facet if and only if the
3D isosurface separates the positive vertices in the cube.

104
4. Multilinear Interpolation
5B−I
5B−II
6B−II
6B−I
2B−I
2B−II
3B−II
3B−I
Figure 4.7. Isosurface patches for ambiguous cube conﬁgurations with one ambiguous
facet: 2B, 3B, 5B, and 6B.
2C
6C
Figure 4.8. Isosurface patches for ambiguous cube conﬁgurations with zero ambiguous
facets: 2C and 6C.
Conﬁgurations 2C and 6C have no ambiguous facets. They are ambiguous
because there are two possible isosurface patches for these conﬁgurations, one
separating two opposing vertices with two triangles and one connecting them
by a tunnel. (See Figure 2.22.) As in the Marching Cubes algorithm, the
Asymptotic Decider always uses the isosurface patches formed by two trian-
gles (Figure 4.8).
All other ambiguous 3D conﬁgurations have two or more facets with ambigu-
ous 2D conﬁgurations. Unfortunately, constructing the isosurface patch in these
cases is more diﬃcult.
Consider conﬁguration 4C where the top and bottom facets have ambiguous
conﬁgurations. If the isocontours in both the top and bottom facets separate
the negative vertices, then the isosurface patch in 4C-I has the desired isocon-
tour boundary. If the isocontours in both the top and bottom facets separate
the positive vertices, then the isosurface patch in 4C-II has the desired isocon-
tour boundary. However, what if the isocontour on the top boundary separates
the positive vertices while the isocontour on the bottom separates the negative
vertices? (See conﬁguration 4C-III in Figure 4.9.)

4.2. The Asymptotic Decider: 3D
105
4C−I
4C−IV
4C−II
4C−IV
4C−I
4C−III
4C−III
4C−II
Figure 4.9. Four isocontour conﬁgurations for ambiguous conﬁguration 4C and their
isosurface patches. Isosurface patches in 4C-III and 4C-IV require an additional point.
5C−I
5C−II
4F−I
4F−II
3C−II
3C−I
4E−II
4E−I
4C−II
4C−I
Figure 4.10. Isosurface patches for cubes with two or more ambiguous facets.
It would be preferable to construct an isosurface patch for 4C-III that uses
only the cube vertices. Unfortunately, it is impossible to do so.1
Figure 4.9
contains isosurface patches for isocontour conﬁgurations 4C-III and 4C-IV, which
use additional points as isosurface vertices.
The remaining conﬁgurations are 3C, 4E, 4F, and 5C. Each of these conﬁg-
urations has two or more ambiguous facets. For some isocontours on the cube
boundary, there are natural isosurface patches. Figure 4.10 contains two isosur-
face patches for each conﬁguration. Let κ be the conﬁguration type, i.e., κ is
3C, 4E, 4F, and 5C. If in each ambiguous facet the isocontour edges separate the
negative vertices (cases 8-I and 16-I from Figure 4.3), then isosurface patches κ-I
(3C-I, 4E-I, 4F-I, or 5C-I) have the appropriate isocontours. If in each ambigu-
1See [Nielson and Hamann, 1991] for a simple proof.

106
4. Multilinear Interpolation
ous facet the isocontour edges separate the positive vertices (cases 8-II and 16-II
from Figure 4.3), then isosurface patches κ-I (3C-I, 4E-I, 4F-I, or 5C-I) have the
appropriate isocontours. As with conﬁguration 4C, the problem arises when in
some facets the isocontour edges separate the negative vertices while in other
facets the isocontour edges separate the positive vertices.
It is possible to exhaustively analyze the possible isocontours for each con-
ﬁguration and construct isosurface patches as done for conﬁguration 4C. Some
of these isosurface patches require adding a new point in the interior of the cube
as an isosurface vertex.
The exhaustive analysis of all the isocontour conﬁgurations and their isosur-
face patches is complicated. Writing a program to handle all the conﬁgurations
is diﬃcult. Instead of the exhaustive analysis, we show how isosurface patches
can be constructed for the isocontours by decomposing the cube into pyramids.
4.2.2
Isosurface Lookup Table for Pyramids
By adding a point p to the center of a cube, a cube can be partitioned into six
pyramids (Figure 4.11). Each of the pyramids contains the point p as its apex
and one of six facets as its base. Each of pyramids has four triangles formed by
p and the four edges of a facet.
Partitioning a cube into six pyramids does not partition any of the cube
facets.
The intersection of every pyramid with the boundary of the cube is
a face of the cube. Thus a regular grid that has some cubes partitioned into
pyramids is still a convex polyhedral mesh, i.e., the intersection of every pair
of mesh elements is a vertex, edge, or facet of each.
(See Appendix B.5 for
the deﬁnition of convex polyhedral meshes.) The partitioned grid is a convex
polyhedral mesh no matter which subset of cubes is partitioned into pyramids.
A pyramid with a square base has ﬁve vertices and 25 = 32 conﬁgurations of
“+” and “−” vertices. Twelve of these conﬁgurations are distinct. The distinct
conﬁgurations and their isosurface patches are shown in Figure 4.12.
Conﬁgurations 2C and 3C are the only ambiguous pyramid conﬁgurations.
Conﬁguration 3C is the complement of 2C, with the positive vertices exchange
for negative ones.
Both conﬁguration 2C and 3C have one ambiguous facet.
There are two possible isosurface patches for each conﬁguration, one separating
the positive vertices and one separating the negative vertices. Figure 4.13 shows
the isosurface patches for each conﬁguration.
Algorithm BilinearIsoSquare can be used to choose isosurface patches
for the ambiguous pyramid conﬁgurations. Consider a pyramid whose “+”/“−”
vertex labels form conﬁguration 2C. Apply BilinearIsoSquare to the square
pyramid base f to determine the isocontour on f. If the isocontour separates the
negative vertices on f, then use isosurface patch 2C-I. Otherwise, the isocontour
separates the positive vertices on f. Use isosurface patch 2C-II. Similarly, use
BilinearIsoSquare to choose the isosurface patch for conﬁguration 3C.

4.2. The Asymptotic Decider: 3D
107
Figure 4.11. Six pyramids partitioning the cube. Apex is at cube center.
3C
5
Zero
One
Two
Three
3B
Four
Five
3A
4A
4B
2A
1B
1A
0
2B
2C
# Positive
Vertices
Figure 4.12. Isosurfaces for the twelve pyramid conﬁgurations.

108
4. Multilinear Interpolation
3C−II
2C−II
2C−I
3C−I
Figure 4.13. Ambiguous pyramid conﬁgurations 2C and 3C.
κ ←type of “+”/“−” conﬁguration
of the pyramid vertices
If κ = 2C and
κ = 3C
(not ambiguous)
then
else
Retrieve isosurface triangles
from the pyramid lookup table
Apply BilinearIsoSquare
to the square facet.
If the square
facet
is 8-I or 16-I
then
else
Use isosurface patch
from κ-I (2C-I or 3C-I)
Use isosurface patch
from κ-II (2C-II or 3C-II)
Figure 4.14. BilinearIsoPyramid: Retrieve isosurface patch from the lookup table
for a grid pyramid using the bilinear interpolant to resolve ambiguous cases.

4.2. The Asymptotic Decider: 3D
109
Algorithm BilinearIsoPyramid for retrieving the isosurface patch from a
pyramid is shown in Figure 4.14.
4.2.3
Algorithm
Input to the 3D Asymptotic Decider is an isovalue and a set of scalar values
at the vertices of a three-dimensional regular grid. The algorithm has four steps.
(See Figure 4.15.) Read the Marching Cubes isosurface lookup table (Fig-
ure 2.16) from a preconstructed data ﬁle. Read the pyramid isosurface lookup
table (Figure 4.12) from a preconstructed data ﬁle. For each cube, construct
a set of isosurface triangles representing the combinatorial structure of the iso-
surface using a subdivision into pyramids and BilinearIsoSquare to resolve
ambiguous cases.
Assign geometric locations to the isosurface vertices based
on the scalar values at the cube edge endpoints.
We explain the third step,
constructing the isosurface patches, next.
Let c be the grid cube under consideration. If no facet of c is ambiguous,
then retrieve the isosurface triangles from the cube isosurface lookup table. Note
that if c has the ambiguous conﬁguration 2C or 3C, the isosurface patch is still
retrieved directly from the lookup table.
Let κ be the type of “+”/“−” conﬁguration of the cube vertices as given
by Figure 2.15, i.e., κ = 0, 1, 2A, 2B, 2C, etc. Apply the algorithm Bilin-
earIsoSquare to each of the ambiguous facets of c to construct the isocontours
in these facets. If every ambiguous facet is of type 8-I or 16-I, then use isosurface
Read cube isosurface lookup table

Read pyramid isosurface lookup table

For each grid cube,
retrieve isosurface triangles from lookup table
using subdivision into pyramids and the bilinear interpolant
to resolve ambiguous cases (Algorithm BilinearIsoCube)

Compute isocontour vertex coordinates using linear interpolation
Figure 4.15. Asymptotic Decider: 3D.

110
4. Multilinear Interpolation
6B−I
6B−II
5B−II
5B−I
2B−I
2B−II
5C−I
5C−II
3C−I
3C−II
3B−I
3B−II
4C−I
4F−I
4F−II
4C−II
4E−I
4E−II
Figure 4.16. Isosurface patches for the 3D conﬁgurations with ambiguous facets.
patch κ-I from Figure 4.16. If every ambiguous facet is of type 8-II or 16-II, then
use isosurface patch κ-2 from the ﬁgure. Otherwise, partition the cube into six
pyramids sharing an apex at the center of the cube. Apply Algorithm Bilin-
earIsoPyramid to construct an isosurface patch in each pyramid. Algorithm
BilinearIsoCube is presented in Figure 4.17.
4.3
Trilinear Interpolation
Let cU be the unit cube {(x, y, z) : x, y, z ∈[0, 1]}. Let sx,y,z be the scalar value
of the vertex with coordinates (x, y, z). The trilinear interpolant of the scalar values
sx,y,z is the function
φ(x, y, z) =(1 −x)(1 −y)(1 −z)s0,0,0 + x(1 −y)(1 −z)s1,0,0
+ (1 −x)y(1 −z)s0,1,0 + (1 −x)(1 −y)zs0,0,1
+ xy(1 −z)s1,1,0 + x(1 −y)zs1,0,1 + (1 −x)yzs0,1,1 + xyzs1,1,1.
The trilinear interpolant on a grid cube c other than cU is by translating c to
cU and then applying the trilinear interpolant to cU.

4.3. Trilinear Interpolation
111
κ ←type of ‘+’/‘−’ conﬁguration
of the grid cube vertices
If no facet of κ
is ambiguous
then
else
Retrieve isosurface triangles
from the lookup table
For each ambiguous facet,
apply BilinearIsoSquare
If every
ambiguous facet
is 8-I or 16-I
then
else
Use isosurface patch κ-I
If every
ambiguous facet
is 8-II or 16-II
then
else
Use isosurface patch κ-II
Partition cube into 6 pyramids
Apply BilinearIsoPyramid
to each pyramid
Figure 4.17. BilinearIsoCube: Retrieve isocontour triangles (isovalue σ) from the
lookup table for a grid cube using subdivision into pyramids and the bilinear interpolant
to resolve ambiguous cases.

112
4. Multilinear Interpolation
2
−14
16
2
4
−14
12
0
(a) Cube isovalues.
(b) Marching Cubes.
(c) Asymptotic Decider.
(d) Trilinear interpolant.
Figure 4.18. Isosurfaces and level sets for a cube. Isovalue = 1. Cube conﬁguration
5C (from Figure 2.16). Front faces are colored green. Back faces are colored magenta.
(a) Scalar values at cube vertices.
Black vertices have scalar value greater than 1.
(b) Marching Cubes isosurface. (c) Asymptotic Decider isosurface. (d) Level set
of the trilinear interpolant.
The trilinear interpolant is a generalization of the bilinear interpolant to
three dimensions. The restriction of the trilinear interpolant to a grid facet is
the bilinear interpolant on that facet.
The 3D Asymptotic Decider uses the bilinear interpolant to determine
how the isosurface intersects grid facets. However, this is not the same as using
the trilinear interpolant to determine how the isosurface should intersect the
grid cubes. Figure 4.18 compares the Marching Cubes isosurface, ΣMC, the
Asymptotic Decider isosurface, ΣAD, and the level set, ΣT I, of the trilinear
interpolant of a cube. Restricted to the boundary of the cube, ΣAD and ΣT I are
topologically the same and intersect the grid edges in the same order. However,
ΣAD has two connected components, both disks, while ΣT I is a cylinder.
Lookup tables for the trilinear interpolant can be found in [Carr and Max,
2010, Chernyaev, 1995, Lopes and Brodlie, 2003, Nielson, 2003b]. The lookup

4.4. Notes and Comments
113
table has about ﬁfty distinct cases. Conﬁgurations are based on the relative
value of the isovalue and the scalar values at the grid vertices, located at critical
points on the cube facets and at critical points inside the cube. Isosurfaces built
using the trilinear interpolant lookup table have the same topological structure
as the level set of the trilinear function.
4.4
Notes and Comments
Nielson and Hamann [Nielson and Hamann, 1991] proposed the Asymptotic
Decider algorithm, a modiﬁcation of Marching Cubes using the bilinear in-
terpolant on grid cube faces. Matveyev [Matveyev, 1994] suggested an implemen-
tation of the Asymptotic Decider that does not require explicitly computing
the face saddle.
Matveyev [Matveyev, 1994], Natarajan [Natarajan, 1994], and Chernyaev
[Chernyaev, 1995] presented approaches to constructing an isosurface that matches
the topology of the level set of the trilinear interpolant. An excellent review of
these papers is in the introduction to [Lopes and Brodlie, 2003].
Chernyaev [Chernyaev, 1995] gave a modiﬁed isosurface patch lookup table
for constructing such isosurfaces. For certain conﬁgurations of “+” or “−” labels,
the lookup table contains multiple possible isosurface patches. Computations
of the facet and body saddle points of the trilinear interpolant of the grid cube
determine which patch is chosen. Lin and Ching [Lin and Ching, 1997] suggested
a more eﬃcient method for computing body saddles.
Later descriptions of algorithms based on the trilinear interpolant are in
[Cignoni et al., 2000, Lewiner et al., 2003, Lopes and Brodlie, 2003, Nielson,
2003b,Carr and Snoeyink, 2009,Carr and Max, 2010]. These papers give more
explicit algorithm descriptions, better lookup tables, or better explanations of
the topological cases determined by the trilinear interpolant.
Zhang and Qian [Zhang and Qian, 2012] give a dual contouring algorithm
to produce an isosurface matching the topology of the level set of the trilinear
interpolant.
Etiene et al., in [Etiene et al., 2012], describe a technique for verifying that
an isosurface matches the topology of the level set of the trilinear interpolant.

This page intentionally left blank
This page intentionally left blank

CHAPTER 5
ISOSURFACE PATCH
CONSTRUCTION
The Marching Cubes algorithm can be generalized to other convex mesh ele-
ments such as pyramids or bipyramids. Each such mesh element has a diﬀerent
isosurface lookup table. The table entries correspond to diﬀerent conﬁgurations
of positive and negative vertices.
Each entry contains a list of edge triples,
(e1, e2, e3), representing triangles with vertices on edges e1, e2, and e3.
Marching Cubes can also be generalized to a mixture of convex mesh
elements, such as cubes, pyramids, and tetrahedra.
Care must be taken to
ensure that the isosurfaces align properly on the ambiguous facets, i.e., that the
ambiguous conﬁgurations are resolved consistently across facets of adjacent mesh
elements.
One could generate a set of tables for each of the various mesh elements by
hand and check for consistency. Instead of doing so, we describe an algorithm
for automatically generating isosurface patches within convex mesh elements.
The idea behind this algorithm was independently proposed by Lachaud and
Montanvert [Lachaud and Montanvert, 2000] and Bhaniramka, Wenger, and
Crawﬁs [Bhaniramka et al., 2000, Bhaniramka et al., 2004a]. As discussed in
Chapters 6 and 7, the algorithm can be used to generate isosurface patches in
dimensions higher than three and to generate interval volumes.
We ﬁrst present the algorithm for constructing the entries in the isosurface
lookup table and then present the algorithm for isosurface construction. The
isosurface construction algorithm and the properties of the resulting isosurface
parallel exactly the Marching Squares, Marching Cubes, and Marching
Tetrahedra algorithms in Chapter 2. Before discussing constructing the iso-
surface lookup table, we deﬁne some terminology and notation that will be used
in this chapter.
115

116
5. Isosurface Patch Construction
5.1
Deﬁnitions and Notation
Vertex and edge properties. The deﬁnitions of positive, strictly positive, and
negative for convex polyhedral meshes are similar to the deﬁnitions in Section 2.1.
Deﬁnition 5.1.
• A mesh vertex is positive, “+”, if its scalar value is greater than or equal
to the isovalue σ.
• A mesh vertex is negative, “−”, if its scalar value is less than σ.
• A positive vertex is strictly positive if its scalar value does not equal σ.
Let c be a convex polyhedron and Γ a convex polyhedral mesh where every
vertex of c and Γ is labeled negative, positive, or strictly positive. We charac-
terize the edges of c and Γ by the labels at their endpoints.
Deﬁnition 5.2.
• An edge of c or Γ is positive if both its endpoints are positive.
• An edge of c or Γ is negative if both its endpoints are negative.
• A positive edge of c or Γ is strictly positive if both its endpoints are strictly
positive.
• An edge of c or Γ is bipolar if one endpoint is positive and one endpoint is
negative.
Denote by V +
c
the set of positive vertices of polyhedron c and by V −
c
the set
of negative vertices of c. Denote by Mc the set of midpoints of bipolar edges
of c. The algorithm for isosurface patch construction uses the convex hull of a
set of points. Convex hulls are discussed in Appendix A.2. The convex hull of a
set of points P is denoted conv(P).
Isosurface vertex sets. In Section 5.2, we will generate isosurface patches from
the midpoints, Mc, of bipolar edges of c. Later in this chapter, we will generate
isosurface patches from other points along the bipolar edges of c. In Chapter 7,
we will generate interval volumes using points that are 1/3 of the distance from
some edge endpoint. Thus, it is useful to have a general characterization of the
set of points used in isosurface patch construction.
Deﬁnition 5.3.
• An isosurface vertex set Uc of convex polyhedron c is a ﬁnite set of points
lying on the edges of c such that every bipolar edge of c contains one and
only one point of Uc and no point of Uc lies on a strictly positive vertex or
negative vertex or negative edge of c.

5.1. Deﬁnitions and Notation
117
(a)
c1
c2
(b)
c1
c2
p1
p2
(c)
c1
c2
Figure 5.1. (a) Grid Γ of two cubes. Black vertices are positive. (b) An isosurface
vertex set U (green vertices) for grid Γ. Points p1 and p2 are both positive grid vertices
and elements of U. Thus isosurface vertex set U is not proper. (c) A proper isosurface
vertex set U ′ (green vertices) for grid Γ.
• An isosurface vertex set U of mesh Γ is a ﬁnite set of points lying on the
edges of Γ such that every bipolar edge of Γ contains one and only one
point of U and no point of U lies on a strictly positive vertex or negative
vertex or negative edge of Γ.
Figure 5.1(b) contains an example of an isosurface vertex set.
A grid vertex whose scalar value equals the isovalue is positive. As a result,
the Marching Cubes isosurface can contain a positive grid vertex but never a
negative grid vertex. Similarly, the isosurface vertex set can contain a positive
mesh vertex but not a negative one.
Points of an isosurface vertex set may lie on positive edges of the mesh or
polyhedron. For instance, in Figure 5.1(b) point p2 lies on three edges in cube
c2, and all three of those edges are positive. Points of an isosurface vertex set
may also lie on positive vertices that are not strictly positive. Thus a point of
the isosurface vertex set could be an endpoint of a bipolar edge. For instance, in
Figure 5.1(b) point p1 ∈U is the endpoint of two bipolar edges in c1 and point
p2 ∈U is the endpoint of one bipolar edge in c1.
Deﬁnition 5.4.
• An isosurface vertex set Uc of convex polyhedron c is proper if every point
in Uc lies in the interior of a bipolar edge of c.
• An isosurface vertex set U of mesh Γ is proper if every point in U lies in
the interior of a bipolar edge of Γ.
The set Mc of midpoints of bipolar edges of c is an example of a proper isosurface
vertex set of c. Figure 5.1(c) contains an example of a proper isosurface vertex
set that is not the set of midpoints of bipolar edges.

118
5. Isosurface Patch Construction
The algorithm for isosurface patch construction uses the convex hull of a set
of points. Convex hulls are discussed in Appendix A.2. The convex hull of a
set of points is denoted conv(P).
5.2
Isosurface Patch Construction
Let c be a convex polyhedron in R3 where each vertex of c has a positive or a
negative label. We show how to construct an isosurface patch in c whose vertices
are Mc, the midpoints of bipolar edges of c.
Compute the set Mc of midpoints of the bipolar edges of c. Construct the
convex hull of Mc ∪V +
c , the midpoints of bipolar edges and the positive vertices.
The boundary of the convex hull1 is composed of convex polygons. Triangulate
the boundary of the convex hull by triangulating each convex polygon without
adding any additional vertices. Orient the triangles so that the induced normals
point toward the convex hull. Let T +
c be the oriented triangles in this triangu-
lation that do not lie on the boundary of c. We shall prove (Lemma 5.5) that
the vertices of T +
c are all from Mc. The triangles in T +
c form the triangulated
isosurface patch whose vertices are Mc. This isosurface patch separates the pos-
itive vertices from the negative vertices of c. We call the algorithm IsoMid3D.
Algorithm IsoMid3D is presented in Figure 5.2 and illustrated in Figure 5.3.
Compute the midpoints of the bipolar edges of the mesh polyhedron

Construct the convex hull of the positive vertices
and the midpoints of the bipolar edges

Triangulate the boundary of the convex hull

Remove triangles on polyhedron boundary
Figure 5.2. Algorithm IsoMid3D for construction of 3D isosurface patches from mid-
points of bipolar edges.
1Data structures representing the convex hull of a set of points usually represent the bound-
ary of the convex hull. Thus computer scientists often fail to distinguish between the convex
hull of a set of points and its boundary. We will try to keep that distinction clear and refer
explicitly to the boundary wherever appropriate.

5.2. Isosurface Patch Construction
119
(a)
(b)
(c)
(d)
Figure 5.3. Isosurface patch generation.
(a) Cube conﬁguration.
(b) Midpoints of
bipolar edges. (c) The convex hull of Mc ∪V +
c , the set of midpoints, and positive
vertices. (d) Removal of triangles on cube boundary, leaving isosurface.
+
−
−
+
+
−
−
+
+
−
−
+
+
−
−
+
(a)
(b)
(c)
(d)
Figure 5.4. Isocontour generation. (a) Square conﬁguration. (b) Midpoints of bipolar
edges. (c) The convex hull of Mc ∪V +
c , the set of midpoints, and positive vertices.
(d) Removal of line segments on square boundary, leaving isocontour.
The combinatorial structure of the isosurface within c is determined from the
conﬁguration of the polyhedron’s vertex labels. The isosurface does not intersect
any edge whose endpoints have the same label.
As will be discussed in Chapter 6, the algorithm for isosurface patch con-
struction can be generalized to any dimension. For illustrative purposes, it is
useful to present here the two-dimensional version. Let c be a square in R2 whose
vertices have positive or negative labels. Deﬁne Mc as the midpoints of bipolar
edges. Construct the convex hull of Mc ∪V +
c
and let L+
c be the line segments
on the boundary of the convex hull that do not lie on the boundary of c. The
line segments in L+
c form the isocontour in c.
Figure 5.4 gives an example applied to square conﬁguration 7 from Figure 2.2
(Chapter 2). The construction produces exactly the isocontour given in Fig-
ure 2.3. More generally, the construction applied to any of the conﬁgurations in
Figure 2.2 produces the corresponding isocontours in Figure 2.3.
Figure 5.6 presents examples of the 3D algorithm applied to the cube conﬁgu-
rations 1, 2A, 2B, and 4C from Figure 2.15. For each conﬁguration in Figure 2.15,
the construction produces the isosurface patches given by Figure 2.16. The only

120
5. Isosurface Patch Construction
+
−
+
+
−
−
+
+
−
−
+
+
−
−
+
−
(a)
(b)
(c)
(d)
Figure 5.5. Isocontour generation using negative vertices. (a) Square conﬁguration.
(b) Midpoints of bipolar edges. (c) The convex hull of Mc ∪V −
c , the set of midpoints,
and negative vertices. (d) Removal of line segments on square boundary, leaving iso-
contour.
(a)
(b)
(c)
(d)
Figure 5.6. Isosurface patch generation.
(a) Cube conﬁguration.
(b) Midpoints of
bipolar edges. (c) The convex hull of Mc ∪V +
c , the set of midpoints, and positive
vertices. (d) Removal of triangles on cube boundary, leaving isosurface.

5.2. Isosurface Patch Construction
121
(a)
(b)
(c)
(d)
Figure 5.7. Isosurface patch generation. (a) Cube conﬁguration 2C. (b) Midpoints of
bipolar edges. (c) The convex hull of Mc ∪V +
c , the set of midpoints, and positive
vertices. (d) Removal of triangles on cube boundary, leaving isosurface.
exception is conﬁguration 2C. The isosurface patch construction for conﬁgura-
tion 2C is illustrated in Figure 5.7. The isosurface patch is not the same as
the one given in Figure 2.16 for conﬁguration 2C. Instead, it is the alternate
isosurface 2C-I from the isosurface patches for ambiguous conﬁgurations given
in Figure 2.22.
The 3D algorithm applied to the tetrahedra conﬁgurations in Figure 2.25
gives the isosurface patches in Figure 2.27.
Algorithm IsoMid3D could be modiﬁed in two simple ways. First, the set
of midpoints, Mc, could be replaced by any set of points Uc from the interiors of
bipolar edges. The choice of points does not change the topology of the isosurface
patch, although it could change its triangulation.
Second, instead of using the positive vertices, V +
c , one could construct the
convex hull of Mc ∪V −
c , triangulate its boundary, and let T −
c be the triangles in
this triangulation that do not lie on the boundary of c. For each of the ambiguous
conﬁgurations in Figure 2.22, set T −
c is the alternate isosurface patch given in
that ﬁgure.
In two dimensions, L−
c is the line segments on the boundary of conv(Mc∪V −
c )
that do not lie on the boundary of c. Figure 5.5 gives a 2D example of isocontour
construction using the negative vertices, V −
c , on conﬁguration 7 from Figure 2.2.
This generates the isocontour 7-II from Figure 2.12. For each of the ambiguous
conﬁgurations in Figure 2.12, set L−
c is the alternate isocontour given in that
ﬁgure.
Any triangle in the triangulation of conv(Mc ∪V +
c ) that contains a vertex
of V +
c
is on the boundary of c and thus not a triangle of T +
c
(Corollary 5.7).
However, the converse is not true. There may be triangles that lie on some facet
of c but whose vertices all come from Mc. (See Figure 5.8.) Since these triangles
lie on a facet of c, they are not included in T +
c .
Isosurface patches in adjacent mesh elements should properly align on their
boundaries. As was discussed in Section 2.3.5, if some isosurface patches separate
positive vertices while others separate negative vertices, proper alignment may
not occur. The isosurface patches separating positive vertices are deﬁned by

122
5. Isosurface Patch Construction
Figure 5.8. Triangulation of the boundary of conv(Mc ∪V +
c ) from the fourth row of
Figure 5.6. Blue triangles lie on a facet of c but their vertices are all from Mc.
T +
c while the isosurface patches separating negative vertices are deﬁned by T −
c .
Thus, while either T +
c
or T −
c
can be used to generate the isosurface lookup
tables, only one or the other should be used for all table entries. This applies
not only within a single table but between the diﬀerent lookup tables for diﬀerent
convex mesh elements. Because the isosurface patches must align on the common
boundary between two such mesh elements, only T +
c or only T −
c should be used
for all the isosurface lookup tables.
As discussed in Section 2.3.5, conﬁguration 2C is the only conﬁguration where
the isosurface lookup table in Figure 2.16 separates the positive vertices, not
the negative vertices. Because no facet of conﬁguration 2C has an ambiguous
conﬁguration, isosurface patches 2C-I and 2C-II from Figure 2.22 have the same
boundary. Thus, either patch can be used. If the isosurface table is constructed
from the positive vertices (i.e., the isosurface triangulation is T +
c ,) then the tube
connecting the two positive vertices in 2C-I will be the isosurface patch. This is
the only diﬀerence between the automatically constructed lookup table for cubes
and the table in Figure 2.16.
5.3
Isosurface Table Construction
As in the previous section, let c be a convex polyhedron in R3. Let n be the
number of vertices of c. In the isosurface extraction algorithm, the vertices of c
receive positive and negative labels representing their relationship to the isovalue.
A vertex that has scalar value below the isovalue will receive a negative label,
“−”. A vertex with scalar value above or equal to the isovalue receives a positive
label, “+”.
Since each vertex is either positive or negative, there are 2n conﬁgurations
of positive and negative vertex labels. The isosurface lookup table contains 2n

5.4. Marching Polyhedra Algorithm
123
entries, one for each conﬁguration κ. Each entry is a list of triples of bipolar
edges of c. Each triple (e1, e2, e3) represents an oriented triangle whose vertices
lie on e1 and e2 and e3. The list of triples deﬁne the combinatorial structure
of the isosurface patch for conﬁguration κ. This isosurface patch is constructed
using algorithm IsoMid3D in the previous section. The triangles in this isosur-
face patch are the set T +
c . The isosurface patch intersects every bipolar edge
of c exactly once and does not intersect any positive or negative polyhedron
edges.
5.4
Marching Polyhedra Algorithm
We assume that the mesh is composed of a ﬁxed, predeﬁned set of polyhedra
classes. Elements within each class are aﬃne transformations of one another.2
For instance, all cubes and rectangular regions are aﬃne transformations of
the unit cube and are in the same class.
Similarly, all tetrahedra are aﬃne
transformations of each other and all pyramids with rectangular bases are aﬃne
transformations of each other. One “generic” convex polyhedron is chosen from
each class and an isosurface lookup table is built on that polyhedron with the
algorithm described in the previous section.
We will call the variation of Marching Cubes applied to convex polyhe-
dra, the Marching Polyhedra algorithm. (See Figure 5.9.) The Marching
Polyhedra algorithm follows the steps of the Marching Cubes and March-
ing Tetrahedra algorithms. Input to the Marching Polyhedra algorithm
is an isovalue, a three-dimensional convex polyhedral mesh, a set of scalar values
at the vertices of the mesh and a set of polyhedra classes.
Read isosurface lookup tables for each polyhedron class

For each mesh polyhedron, retrieve isosurface triangles

Compute isosurface vertex coordinates using linear interpolation
Figure 5.9. Marching Polyhedra.
2A more general approach is to divide mesh elements into classes of combinatorially equiv-
alent polyhedra.

124
5. Isosurface Patch Construction
The algorithm has three steps. The ﬁrst step is reading the isosurface lookup
tables for each class from preconstructed data ﬁles. The next two steps of the
algorithm follow the Marching Cubes and Marching Tetrahedra algo-
rithms. For each mesh element, retrieve from the appropriate lookup table a set
of isosurface triangles representing the combinatorial structure of the isosurface.
The vertices of these triangles form the isosurface vertices. Assign geometric
locations to the isosurface vertices based on the scalar values at the mesh edge
endpoints.
To map each isosurface triangle to a geometric triangle, we use linear interpo-
lation to position the isosurface vertices as described in Section 1.7.2. Each iso-
surface vertex v lies on a grid edge [p, q]. If sp and sq are the scalar values at p and
q and σ is the isovalue, then map v to (1−α)p+αq where α = (σ−sp)/(sq −sp).
5.4.1
Isosurface Properties
We claim the following properties for the isosurface produced by the Marching
Polyhedra algorithm. These properties are the same as those for the isosurface
produced by Marching Cubes. As with Marching Cubes, the isosurface is
a 2-manifold with boundary under appropriate conditions.
Marching Polyhedra returns a ﬁnite set, Υ, of oriented triangles. The
isosurface is the union of these triangles. The vertices of the isosurface are the
triangle vertices.
The following properties apply to all isosurfaces produced by the Marching
Polyhedra algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on mesh edges.
Property 3.
The isosurface intersects every bipolar mesh edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
mesh edges.
Property 5.
The isosurface separates positive mesh vertices from negative ones
and strictly separates strictly positive mesh vertices from negative mesh vertices.
Properties 3 and 4 imply that the isosurface intersects a minimum number of
mesh edges. As with Marching Cubes, if both endpoints of a mesh edge have
scalar value equal to the isovalue, then the isosurface may intersect the mesh
edge zero, one, or two times or may contain the mesh edge.
By Property 3, the isosurface intersects every bipolar mesh edge. However,
the bipolar mesh edge may be intersected by zero-area isosurface triangles.

5.4. Marching Polyhedra Algorithm
125
(a)
(b)
(c)
Figure 5.10. (a) Convex mesh polyhedron. (b) Isosurface patch. (c) Self intersecting
interpolated isosurface patch.
Under appropriate conditions, the isosurface produced by Marching Poly-
hedra is a 2-manifold with boundary. As with the Marching Tetrahedra
algorithm, the isovalue should not equal the scalar value of any vertex and the
underlying space must be a manifold. However, a third condition is necessary.
Consider the convex polyhedron in Figure 5.10. The algorithm in Section 5.2
will construct a proper isosurface patch, but linear interpolation on the vertices
may cause that isosurface patch to self-intersect.3
To avoid this pathological
case, we use a restricted set of mesh elements. While this set can certainly be
enlarged, we tried to include the most typical ones.
Consider a convex polyhedral mesh and isovalue that has the following three
conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The mesh is a partition of a 3-manifold with boundary.
• The mesh elements are aﬃne transformations of cubes, tetrahedra, square
pyramids, triangular bipyramids, and octahedra.
Under these conditions, the isosurface produced by Marching Polyhedra
has the following three properties:
Property 6.
The isosurface is a piecewise linear, oriented 2-manifold with bound-
ary.
Property 7.
The boundary of the isosurface lies on the boundary of the mesh.
Property 8.
Set Υ does not contain any zero-area triangles or duplicate triangles,
and the triangles in Υ form a triangulation of the isosurface.
3Applying ﬁrst linear interpolation, computing the convex hull of the interpolated vertices
and the positive vertices, and then constructing the isosurface patch from this convex hull
avoids this problem of self-intersection. The IsoHull algorithm in Section 5.5 does exactly
this.
The drawback is the necessity of constructing a convex hull for each mesh element
intersected by the isosurface.

126
5. Isosurface Patch Construction
(a)
(b)
(c)
(d)
Figure 5.11. (a) Set V +
c
(black vertices). (b) Isosurface vertex set Uc (green vertices).
(c) Set R+
c (Uc), the convex hull of Uc ∪V +
c .
(d) Set T +
c (Uc), the triangles in the
triangulation of ∂R+
c (Uc) that do not lie on the cube boundary.
5.4.2
Proofs of Isosurface Properties 1–4
Isosurface vertex sets and proper isosurface vertex sets were deﬁned in Sec-
tion 5.1. The set of midpoints of bipolar edges is an example of a proper isosur-
face vertex set.
The Marching Polyhedra algorithm uses isosurface patches constructed
from the set of midpoints of bipolar edges. However, the properties of these iso-
surface patches hold for any proper isosurface vertex set. Many of the properties
also hold for isosurface vertex sets that are not proper. We will need proper-
ties of isosurface vertex sets, both proper and not proper, later in this chapter.
Therefore, we state and prove the lemmas in this section and the following two
sections in the more general setting of isosurface vertex sets instead of restricting
ourselves to sets of midpoints.
Let Uc be an isosurface vertex set of a convex polyhedron c. Let R+
c (Uc)
equal conv(Uc ∪V +
c ), the convex hull of Uc and the positive vertices of c (Fig-
ure 5.11(c)). Triangulate the boundary of R+
c (Uc) by triangulating each convex
polygon in the boundary without adding any additional vertices.
Orient the
triangles so that the induced normals point toward R+
c (Uc). Let T +
c (Uc) be the
oriented triangles in the triangulation of ∂R+
c (Uc) that do not lie on the bound-
ary of c (Figure 5.11(d)). Set T +
c (Uc) is itself a triangulation. We will often
abbreviate R+
c (Uc) and T +
c (Uc), as R+
c and T +
c , respectively.
The set Mc of midpoints of bipolar edges of c is a proper isosurface vertex
set of c. Abbreviate R+
c (Mc) as RM+
c
and T +
c (Mc) as T M+
c
.
Proofs of Properties 1 and 2 are the same as in Section 2.3.4 for Marching
Cubes and are omitted.
To prove Property 3, we need to show that Uc is the set of vertices of T +
c (Uc).
We ﬁrst show that the set of vertices of T +
c (Uc) is a subset of Uc.
Lemma 5.5. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is an isosurface vertex set for c, then the set
of vertices of T +
c (Uc) is a subset of Uc.

5.4. Marching Polyhedra Algorithm
127
t
h
v
w
Figure 5.12. Isosurface triangle t with a positive vertex w that is also a cube vertex.
The interior of bipolar edge (w, v) is separated from the isosurface patch by the plane
h containing t.
Proof: Let w be a vertex of T +
c (Uc) (abbreviated as T +
c ). The vertices of R+
c =
conv(Uc ∪V +
c ) are Uc ∪V +
c . Since T +
c is a subset of a triangulation of ∂R+
c that
does not add any vertices, vertex w is in Uc ∪V +
c .
If w is not in V +
c , then w must be in Uc, establishing the claim. Assume that
vertex w is in V +
c .
Since w is in T +
c , it must be incident on some triangle t that is not on a facet
of c. (See Figure 5.12.) Let h be the plane containing t. Since h intersects the
interior of c and h contains w, there is some edge (w, v) of c that is separated
from R+
c by h and does not lie on h. Thus,
(w, v) ∩R+
c = w.
Since vertex v is not in R+
c , vertex v must have a negative label. Thus, (w, v)
is a bipolar edge. By deﬁnition, the isosurface vertex set Uc contains some point
p on (w, v). Since p is in R+
c and (w, v) ∩R+
c equals w, point p must equal w.
Thus w is in Uc, proving the claim.
□
Lemma 5.5 applies to any isosurface vertex set.
The corollaries apply to
proper isosurface vertex sets.
Corollary 5.6. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set for c, then the
set of vertices of T +
c (Uc) equals Uc.
Proof: By Lemma 5.5, if w is a vertex of T +
c , then w is in Uc. On the other
hand, if w is in Uc, then some triangle t in the triangulation of ∂conv(Uc ∪V +
c )
contains w and is not on a facet of c. This triangle is in T +
c . Thus w is a vertex
of T +
c .
□

128
5. Isosurface Patch Construction
Corollary 5.7. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set for c, then no
vertex of c is in the set of vertices of T +
c (Uc).
Proof: By Lemma 5.5, the set of vertices of T +
c (Uc) is a subset of Uc. Since
isosurface vertex set Uc is proper, no vertex of c is in Uc. Thus, no vertex of c
is in the set of vertices of T +
c (Uc).
□
Let μ be the aﬃne transformation that maps each mesh element c to the
corresponding predeﬁned “generic” polyhedron. If the vertices of c are labeled
“+” or “−”, then vertices of μ(c) receive “+” or “−” labels from the correspond-
ing vertices of c. Thus, μ(v) is positive if and only if v is positive and μ(v) is
negative if and only if v is negative.
Property 3.
The isosurface intersects every bipolar mesh edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
mesh edges.
Proof of Properties 3 & 4: The isosurface is constructed by retrieving triangles from
a lookup table and then determining their vertex positions using linear interpola-
tion. Let c be a mesh element containing a mesh edge e. Vertices of c are labeled
“+” or “−” based on the relationship of their scalar value to the isovalue. The
isosurface patch for μ(c) is a subset of conv(Mμ(c) ∪V +
μ(c)), the convex hull of
the midpoints of bipolar edges and positive vertices of μ(c).
Since c is convex, only isosurface triangles with vertices on e intersect e. By
Corollary 5.6, the vertices of T +
μ(c)(Mμ(c)) (abbreviated T M+
μ(c)) are midpoints of
edges of μ(c). Thus, the isosurface patch in μ(c) intersects μ(e) at most once.
If e is bipolar, then so is μ(e). The midpoint of μ(e) is in Mμ(c). Set T M+
μ(c)
contains some triangle containing this midpoint. Thus, the isosurface patch in
μ(c) intersects μ(e) at exactly one point p. Point p ∈μ(e) maps to a single
point on e determined by linear interpolation. Thus the isosurface intersects e
at exactly one point.
If e is negative or strictly positive, then no isosurface vertex lies on e. Thus
the isosurface does not intersect negative or strictly positive grid edges.
□
5.4.3
Proof of Isosurface Property 5
The Marching Polyhedra algorithm retrieves isosurface patches for a mesh
element c from the isosurface lookup table for μ(c), where μ(c) is a prede-
ﬁned “generic” polyhedron and μ is an aﬃne transformation. The algorithm
then embeds those isosurface patches using linear interpolation on the isosurface

5.4. Marching Polyhedra Algorithm
129
Construct isosurface patches in each mesh polyhedron
using Algorithm IsoMid3D

Compute isosurface vertex coordinates using linear interpolation
Figure 5.13. Variation of Marching Polyhedra without a lookup table.
μ(c)
 T M+
μ(c)
μ−1

O
O
O
O
O
O
O
O
O
O
O
O
c
μ

 T M+
c
 ΣM+
c
(σ)
Figure 5.14. The Marching Polyhedra algorithm constructs the isosurface patch
ΣM+
c
(σ) by mapping polyhedron c to μ(c), retrieving T M+
μ(c) from the isosurface lookup
table and mapping T M+
μ(c) to ΣM+
c
(σ) using linear interpolation. The isosurface patch
ΣM+
c
(σ) could be constructed directly from c by computing T M+
c
directly on c and
then mapping T M+
c
to ΣM+
c
(σ).
vertices. Isosurface patches in the lookup table are constructed by applying Al-
gorithm IsoMid3D to μ(c). In place of using the lookup table, we could have
constructed isosurface patches by applying IsoMid3D directly to each mesh el-
ement c. (See Figure 5.13.) We argue that doing so would give the exact same
isosurface.
If μ : R3 →R3 is some aﬃne transformation of R3, then μ(conv(P)) equals
conv(μ(P)) for any point set P ⊆R3. Thus, μ(RM+
c
) equals RM+
μ(c) and μ(T M+
c
)
equals T M+
μ(c). Applying μ−1 to T M+
μ(c) gives a triangulation T M+
c
, which is isomor-
phic to T M+
μ(c). (See Figure 5.14.)
Marching Polyhedra embeds T M+
μ(c) in c using linear interpolation on the
isosurface vertices.
The location of the isosurface vertices depends upon the
isovalue σ. Let ΣM+
c
(σ) (abbreviated ΣM+
c
) represent the resulting isosurface
patch for c.
Because T M+
μ(c) and T M+
c
are isomorphic, the algorithm could have constructed
ΣM+
c
from T M+
c
by reembedding T M+
c
in c using linear interpolation on its
vertices. Each vertex vi of T M+
c
is the midpoint mi of some edge ei. Vertex vi
is remapped to the interpolated point wi ∈ei. Map each vertex vi of T M+
c
to
(1 −α)vi + αwi. Linearly extend the mapping to each triangle in T M+
c
.

130
5. Isosurface Patch Construction
The algorithm uses μ(c) to construct ΣM+
c
because it is faster to retrieve
the precomputed values of T M+
μ(c) from the lookup table than to compute T M+
c
.
However, for the proofs of Properties 5–8 we will view ΣM+
c
as a homotopy of
T M+
c
.
To prove Property 5, it is necessary to show that there are no cracks between
isosurface patches in adjacent polyhedra. This was done by case analysis for
Marching Cubes and Marching Tetrahedra. Case analysis will not work
for the Marching Polyhedra algorithm and we need a more general proof.
We ﬁrst show that for each polyhedron c, set |T M+
c
| separates the positive
vertices of c from the negative ones (Corollary 5.12).
(|T M+
c
| represents the
union of all the triangles of T M+
c
.) We next show that for two adjacent poly-
hedra, c1 and c2, region RM+
c1
and RM+
c2
agree on their adjacent boundaries
(Corollary 5.15). This implies that there are no “cracks” between |T M+
c1
| and
|T M+
c2
| in adjacent polyhedra and that 
c∈Γ |T M+
c
| separates the positive ver-
tices of Γ from the negative ones. We also show that the triangulations T M+
c1
and T M+
c2
agree on their adjacent boundaries, i.e., t1 ∩t2 is a face of t1 and a
face of t2 for every t1 ∈T M+
c1
and t2 ∈T M+
c2
(Corollary 5.17). Thus, 
c∈Γ T M+
c
is a triangulation (Lemma 5.21). We deﬁne a homotopy map η that maps this
triangulation to the isosurface. Since this homotopy map does not cross any
vertices, the resulting isosurface separates the positive vertices of Γ from the
negative ones.
As previously noted, we present the lemmas in this section in the more general
setting of isosurface vertex sets instead of restricting the lemmas to the midpoints
of bipolar edges. Some of the lemmas apply only to isosurface vertex sets that
are proper, while others have no such restriction.
We start by showing that if Uc is a proper isosurface vertex set, then R+
c (Uc)
is three-dimensional.
Lemma 5.8. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set of c and at
least one vertex of c is positive, then R+
c (Uc) is a three-dimensional convex set.
Proof: Let v be a positive vertex of c. Since v is positive, some interior point of
every edge incident on v is in R+
c . Since there are at least three edges incident
on v and these edges are not coplanar, R+
c is three-dimensional. Since R+
c is the
convex hull of the set Uc ∪V +
c , set R+
c is convex.
□
Corollary 5.9. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set of c, then
R+
c (Uc) is either a three-dimensional convex set or the empty set.
Proof: By deﬁnition, points in Uc do not lie on negative edges of c. Thus, if V +
c
is empty, then Uc must also be empty. By Lemma 5.8, if V +
c
is not empty, then
R+
c (Uc) is not empty.
□

5.4. Marching Polyhedra Algorithm
131
Figure 5.15. Let Y2 be the red region and Y1 be the rectangle containing Y2. The
yellow curve, Y2 ∩cl(Y1 −Y2), separates the red region, Y1, from the blue region,
cl(Y1 −Y2).
Lemma 5.8 and its corollary require Uc to be proper. When Uc is an isosurface
vertex set that is not proper, R+
c (Uc) can have any dimension from zero to three.
Let Y2 ⊂Y1 be a d-dimensional region in Rd. Set cl(Y1−Y2) is the closure of
Y1 −Y2. The set Y2 ∩cl(Y1 −Y2) separates Y1 from Y1 −Y2. (See Appendix B,
Lemma B.8.) For instance, in Figure 5.15 the red region is Y2, the rectangle
is Y1 and the blue region is cl(Y1 −Y2). The green curve, Y2 ∩cl(Y1 −Y2),
separates the red region, Y2, from the blue region, cl(Y1 −Y2).
Let c be a convex polyhedron in R3 where each vertex of c has a positive or
a negative label and let Uc be an isosurface vertex set (not necessarily proper)
of c. We deﬁne S+
c (Uc) (abbreviated S+
c ) to be the set that separates R+
c (Uc)
(abbreviated R+
c ) from cl(c −R+
c (Uc)), as follows:
S+
c (Uc) = R+
c (Uc) ∩cl(c −R+
c (Uc)).
In abbreviated form, S+
c is deﬁned as
S+
c = R+
c ∩cl(c −R+
c ).
Algorithm IsoMid3D in Section 5.2 returns a set of triangles T M+
c
forming an
isosurface patch. The corollary to the following lemma shows that this isosurface
patch is exactly S+
c (Mc).
Lemma 5.10. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label and let Uc be an isosurface vertex set of c. If R+
c (Uc)
has dimension three, then T +
c (Uc) is a triangulation of S+
c (Uc).
Proof: We show that 
t∈T +
c t equals S+
c . By deﬁnition, S+
c equals R+
c ∩cl(c−R+
c ).
Every triangle t ∈T +
c is in both R+
c and cl(c −R+
c ). Thus, 
t∈T +
c t ⊆S+
c .
Assume p is a point in S+
c = R+
c ∩cl(c −R+
c ). Since R+
c is not empty, some
vertex v of c is positive. Since p ∈cl(c −R+
c ), point p is not in the interior of
R+
c and so is on ∂R+
c . Moreover, some triangle t in the triangulation of ∂R+
c
containing p is in cl(c−R+
c ). Since R+
c is three-dimensional and t is in cl(c−R+
c ),
triangle t cannot lie on ∂c. Thus, t intersects int(c) and so is in T +
c . Thus, S+
c

132
5. Isosurface Patch Construction
is a subset of 
t∈T +
c t. We already showed that 
t∈T +
c t is a subset of S+
c so S+
c
equals 
t∈T +
c t.
Since T +
c is a subset of a triangulation, it is also a triangulation. Thus, T +
c
is a triangulation of S+
c .
□
Corollary 5.11. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set, then T +
c (Uc)
is a triangulation of S+
c (Uc).
Proof: By Lemma 5.8, R+
c (Uc) is three-dimensional. By Lemma 5.10, T +
c (Uc) is
a triangulation of S+
c (Uc).
□
The following corollary is not used in the proof of Property 5.
(It is su-
perseded by Corollary 5.20.) However, it illustrates how |T +
c | behaves within a
single polyhedron c.
Corollary 5.12. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set, then |T +
c (Uc)|
separates the positive vertices of c from the negative ones.
Proof: By Corollary 5.11, |T +
c | equals S+
c . The deﬁnition of S+
c is R+
c ∩cl(c−R+
c ).
By Lemma B.8 in Appendix B, S+
c separates R+
c from (c −R+
c ). Region R+
c
contains all the positive vertices of c while (c −R+
c ) contains all the negative
ones. Thus |T +
c | = S+
c separates the positive vertices of c from the negative
ones.
□
We next show that if c1 and c2 are adjacent polyhedra, then R+
c1 and R+
c2
agree on shared faces of c1 and c2. It will follow that there are no “cracks”
between adjacent isosurface patches.
We ﬁrst extend our deﬁnitions of R+
c from c to the faces of c. Let c be a
convex polyhedron in R3 where each vertex of c has a positive or a negative label.
For each face f of c, let V +
f
be the set of positive vertices of f. Let Uf be the
points of Uc that lie on f. Let R+
f (Uf) (abbreviated as R+
f ) equal conv(Uf ∪V +
f ).
In these deﬁnitions, face f can have dimension 0, 1, 2, or 3.
Lemma 5.8 states that if Uc is a proper isosurface vertex set, then R+
c (Uc) is
three-dimensional. The following lemma generalizes Lemma 5.8 to R+
f (Uf).
Lemma 5.13. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label and let f be a k-dimensional face of c. If Uc is a
proper isosurface vertex set of c and at least one vertex of f is positive, then
R+
f (Uf) is a k-dimensional convex set.
Proof: Let v be a positive vertex of f. Since v is positive, some interior point of
every edge of f incident on v is in R+
f . Since there are at least k edges incident
on v and these edges are not contained in any (k−1)-dimensional subspace, R+
f
is k-dimensional. Since R+
f
is the convex hull of the set Uc ∪V +
c , set R+
f
is
convex.
□

5.4. Marching Polyhedra Algorithm
133
(a)
(b)
f
f
Figure 5.16. (a) Cube c, green isosurface vertex set Uc, and red region R+
c . Black cube
vertices are positive. (b) Front facet f of cube c, set Uf = Uc ∩f, and red region R+
f .
Region R+
c ∩f equals R+
f .
We show that if f is a face of c, then R+
c ∩f equals R+
f .
For example,
Figure 5.16(a) displays a cube c, its positive vertices, isosurface vertex set Uc,
and region R+
c . Figure 5.16(b) displays the front facet f of cube c, the set Uc ∩f,
and region R+
f . As claimed, R+
c ∩f equals R+
f .
Lemma 5.14. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label and let Uc be an isosurface vertex set of c. For every
face f of polyhedron c, set R+
c (Uc) ∩f equals R+
f (Uc ∩f).
Proof: Since f is a face of c,
R+
c ∩f = conv(Uc ∪V +
c ) ∩f = conv((Uc ∪V +
c ) ∩f).
Since (Uc ∪V +
c ) ∩f equals Uf ∪V +
f ,
conv((Uc ∪V +
c ) ∩f) = conv(Uf ∪V +
f ) = R+
f .
Thus,
R+
c ∩f = R+
f .
□
As an immediate corollary, R+
c1 and R+
c2 agree on shared faces of c1 and c2.
Corollary 5.15. Let c1 and c2 be adjacent convex polyhedra in R3 where each ver-
tex of c1 and c2 has a positive or a negative label. Let Uc1 and Uc2 be isosurface
vertex sets of c1 and c2, respectively.
If f is a face of both c1 and c2, then
R+
c1(Uc1) ∩f equals R+
c2(Uc2) ∩f.
Proof: Applying Lemma 5.14,
R+
c1 ∩f = R+
f = R+
c2 ∩f.

134
5. Isosurface Patch Construction
c1
c2
f
f
Figure 5.17. Adjacent cubes c1 and c2, green isosurface set Uc, and red regions R+
c1
and R+
c2. Black cube vertices are positive. Shared facet f lies between the two cubes.
Region R+
c1 ∩f equals R+
c2 ∩f.
Figure 5.17 illustrates Corollary 5.15. In the statement of Lemma 5.14 and its
corollary, face f can have dimensions 0, 1, 2, or 3, although the three-dimensional
case is trivial.
Corollary 5.15 indicates that Rc1 and Rc2 agree on adjacent polyhedra c1
and c2. We need also to show that triangulations Tc1 and Tc2 agree on their
adjacent boundaries. We ﬁrst show that the nonempty intersection of a triangle
in T +
c and a face f of c is a vertex or edge of R+
f .
If f is two-dimensional and Uc is proper, then R+
f (Uf) is a convex polygon.
The edges and vertices of R+
f (Uf) are the edges and vertices of its boundary. If
f is zero- or one-dimensional or Uc is not proper, then R+
f (Uf) may be a line
segment or a point. In this case, R+
f (Uf) is either a single vertex or an edge and
two vertices.
Lemma 5.16. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label, let Uc be an isosurface vertex set of c, and let f be
a proper face of c. If t is a triangle in Tc(Uc) that intersects f, then t ∩f is a
vertex or edge of t and a vertex or edge of R+
f (Uc ∩f).
Proof: If R+
c has dimension two or less, then T +
c is the empty set and the lemma
is trivially true. Assume that R+
c is three-dimensional.
Let g equal t ∩f. Since f is on the boundary of c and t is contained in c,
region g = t ∩f is a face of t. Since T +
c does not contain any triangles on the
boundary of c, triangle t is not contained in f. Thus g is a vertex or edge of t.
By Lemma 5.14, the intersection R+
c ∩f equals R+
f (Uc ∩f) (abbreviated R+
f )
and so R+
f is a face of R+
c . Thus the triangulation of ∂R+
c contains the vertices
and edges of R+
f . Since t is in the triangulation of ∂R+
c , its face g is a vertex or
edge of R+
f .
□
As a corollary to Lemma 5.16, triangulations Tc1 and Tc2 agree on their adjacent
boundaries.

5.4. Marching Polyhedra Algorithm
135
Corollary 5.17. Let c1 and c2 be adjacent convex polyhedra in R3 where each ver-
tex of c1 and c2 has a positive or a negative label. Let Uc1 and Uc2 be isosurface
vertex sets of c1 and c2, respectively, If t1 is a triangle in T +
c1(Uc1) and t2 is a
triangle in T +
c1(Uc2), then t1 ∩t2 is a face of t1 and a face of t2.
Proof: If t1 does not intersect t2, then the corollary is trivially true. Assume t1
intersects t2. The intersection t1 ∩t2 lies on some face f of both c1 and c2.
Let g1 equal t1 ∩f and g2 equal t2 ∩f. Since t1 ∩t2 is a subset of f, the
intersection t1 ∩t2 equals g1 ∩g2.
By Lemma 5.16, g1 and g2 are vertices or edges of R+
f (= R+
f (Uc ∩f).) Since
the edges of R+
f intersect only at the vertices of R+
f , the intersection g1 ∩g2 is
a face of g1. By Lemma 5.16, g1 is a face of t1, so the intersection g1 ∩g2 is a
face of t1. Since t1 ∩t2 equals g1 ∩g2, the intersection t1 ∩t2 is a face of t1.
Similarly, the intersection t1 ∩t2 is a face of t2.
□
In the statement of Lemma 5.16 and its corollary, f is a proper face of c
and can have dimensions 0, 1, or 2. Note that Lemmas 5.14 and 5.16 and their
corollaries do not require that isosurface vertex sets Uc or Uc1 or Uc2 be proper.
For a convex polyhedral mesh Γ, let U be an isosurface vertex set for Γ, and
let Uc equals c ∩U for each polyhedron c ∈Γ. Note that Uc is an isosurface
vertex set for c and that if U is proper, then each Uc is proper.
Deﬁne MΓ, ΣM+
Γ
(σ), T +
Γ (U), R+
Γ (U), and S+
Γ (U) as
MΓ
=

c∈Γ
Mc,
ΣM+
Γ
(σ)
=

c∈Γ
ΣM+
c
(σ),
T +
Γ (U)
=

c∈Γ
T +
c (Uc),
R+
Γ (U)
=

c∈Γ
R+
c (Uc),
S+
Γ (U)
=
R+
Γ (U) ∩cl(|Γ| −R+
Γ (U)).
|Γ| is the union of all the elements of mesh Γ. Abbreviate ΣM+
Γ
(σ), T +
Γ (U),
R+
Γ (U), and S+
Γ (U) as ΣM+
Γ
, T +
Γ , R+
Γ , and S+
Γ , respectively. Abbreviate T +
Γ (MΓ)
and S+
Γ (MΓ) as T M+
Γ
and SM+
Γ
. Note that S+
Γ separates R+
Γ from |Γ|−R+
Γ . (See
Lemma B.8 in Appendix B.)
We show that S+
Γ (U) equals 
c∈Γ S+
c (U ∩c) if U is a proper isosurface vertex
set.
Lemma 5.18. Let Γ be a convex polyhedral mesh in R3 where each vertex of Γ has
a positive or negative label. If U is a proper isosurface vertex set of Γ, then set
S+
Γ (U) equals 
c∈Γ S+
c (U ∩c).

136
5. Isosurface Patch Construction
Proof: Abbreviate R+
c (U ∩c) and S+
c (U ∩c) as R+
c and S+
c , respectively. We
ﬁrst prove that |Γ| −R+
Γ equals 
c∈Γ(c −R+
c ).
Let p be a point in |Γ|−R+
Γ . Point p lies in some polyhedron c0 ∈Γ. Since p
is not in R+
Γ , point p is not in R+
c0. Thus, p is in c0 −R+
c0 and in 
c∈Γ(c −R+
c ).
Thus, |Γ| −R+
Γ is a subset of 
c∈Γ(c −R+
c ).
Now assume that p is a point in 
c∈Γ(c −R+
c ). Point p lies in c0 −R+
c0 for
some polyhedron c0 ∈Γ. Thus, point p is not in R+
c0. By Corollary 5.15, point
p does not lie in R+
c for any polyhedron c ∈Γ. Thus, point p is in |Γ| −R+
Γ and

c∈Γ(c−R+
c ) is a subset of |Γ|−R+
Γ . Since |Γ|−R+
Γ is a subset of 
c∈Γ(c−R+
c )
and 
c∈Γ(c −R+
c ) is a subset of |Γ| −R+
Γ , the two are equal.
We proceed to the proof of the lemma. Let p be a point in 
c∈Γ S+
c . Point p is
in S+
c0 for some polyhedron c0 ∈Γ. By deﬁnition, set S+
c0 equals R+
c0 ∩cl(c−R+
c0).
Since point p is in R+
c0, point p is in R+
Γ = 
c∈Γ R+
c .
Since point p is in
cl(c0 −R+
c0), point p is in

c∈Γ
cl(c −R+
c ) = cl
	 
c∈Γ
(c −R+
c )

= cl(|Γ| −R+
Γ ).
Thus, 
c∈Γ S+
c
is a subset of R+
Γ ∩cl(|Γ| −R+
Γ ).
By deﬁnition, S+
Γ equals
R+
Γ ∩cl(|Γ| −R+
Γ ). Thus, 
c∈Γ S+
c is a subset of S+
Γ .
Now let p be a point in S+
Γ . As previously noted, S+
Γ equals R+
Γ ∩cl(|Γ|−R+
Γ ).
Since R+
Γ equals 
c∈Γ R+
c , point p is in R+
c1 for some c1 ∈Γ. Since cl(|Γ| −R+
Γ )
equals 
c∈Γ cl(c −R+
c ), point p is in cl(c2 −R+
c2) for some c2 ∈Γ. If c1 equals
c2, then p is in S+
c1 and therefore in 
c∈Γ S+
c . Assume c1 does not equal c2.
The intersection of c1 and c2 is a face f of both polyhedra, and point p is
in f. By Lemma 5.14, point p is in R+
c2. Thus, p is in R+
c2 ∩cl(c2 −R+
c2). By
deﬁnition, S+
c2 equals R+
c2 ∩cl(c2 −R+
c2). Thus, p is in 
c∈Γ S+
c and S+
Γ is a
subset of 
c∈Γ S+
c .
Since 
c∈Γ S+
c is a subset of S+
Γ and S+
Γ is a subset of 
c∈Γ S+
c , set S+
Γ equals

c∈Γ S+
c .
□
Corollary 5.19. Let Γ be a convex polyhedral mesh in R3 where each vertex of Γ
has a positive or negative label. If U is a proper isosurface vertex set of Γ, then
|T +
Γ (U)| equals S+
Γ (U).
Proof: By Lemma 5.18, S+
Γ equals 
c∈Γ S+
c (Uc). By Corollary 5.11, |T +
c (Uc)|
equals S+
c (Uc) for each c. Thus,
|T +
Γ (U)| =

c∈Γ
|T +
c (Uc)| =

c∈Γ
S+
c (Uc) = S+
Γ (U).
□
As another corollary, |T +
Γ (U)| separates the positive vertices of Γ from the
negative ones. (|T +
Γ (U)| is the union of all the triangles in T +
Γ (U).)

5.4. Marching Polyhedra Algorithm
137
Corollary 5.20. Let Γ be a convex polyhedral mesh in R3 where each vertex of Γ
has a positive or negative label. If U is a proper isosurface vertex set of Γ, then
|T +
Γ (U)| strictly separates the positive vertices of Γ from the negative ones.
Proof: By Corollary 5.19, |T +
Γ | equals S+
Γ .
By deﬁnition, S+
Γ
equals R+
Γ ∩
cl(|Γ| −R+
Γ ). By Lemma B.8 in Appendix B, S+
Γ separates R+
Γ from (|Γ| −R+
Γ ).
Region R+
Γ contains all the positive vertices of Γ while (|Γ|−R+
Γ ) contains all the
negative ones. Thus |T +
Γ | separates the positive vertices of Γ from the negative
ones. By Corollary 5.7, no vertex of Γ is a vertex of T +
Γ . Thus |T +
Γ | does not
contain any vertices of Γ and |T +
Γ | strictly separates the positive vertices of Γ
from the negative ones.
□
T +
Γ (U) is deﬁned as 
c∈Γ T +
c (Uc), the union of sets of triangles. Each T +
c (Uc)
is a subset of a triangulation of the boundary of R+
c (Uc) so each T +
c (Uc) is itself
a triangulation. However, we have yet to establish that T +
Γ (U) is a triangulation.
We need this fact to deﬁne a homotopy on |T +
Γ (U)|.
Lemma 5.21. Let Γ be a convex polyhedral mesh in R3 where each vertex of Γ
has a positive or negative label. If U is a proper isosurface vertex set of Γ, then
T +
Γ (U) is a triangulation of S+
Γ (U).
Proof: Consider two triangles t1, t2 ∈T +
Γ (U). By deﬁnition, t1 is in Tc1(U ∩c1)
for some polyhedron c1 and t2 is in Tc2(U ∩c2) for some polyhedron c2.
By construction, T +
c1(U ∩c1) is itself a triangulation since it is a subset of
a triangulation of ∂Rc1(Uc ∩c1). Thus, if c1 equals c2, then t1 ∩t2 is a face
of t1 and a face of t2. On the other hand, if c1 does not equal c2, then, by
Corollary 5.17, t1 ∩t2 is a face of t1 and a face of t2. This proves that T +
Γ (U)
is a triangulation.
By Corollary 5.19, |T +
Γ (U)| equals S+
Γ (U). Thus T +
Γ (U) is a triangulation of
S+
Γ (U).
□
MΓ is the set of all midpoints of bipolar edges of Γ. Since T +
Γ (MΓ) (abbre-
viated T M+
Γ
) is a triangulation of S+
Γ (MΓ) (abbreviated SM+
Γ
), the homotopy η
can be extended to all of SM+
Γ
. Each vertex vi of T M+
Γ
is the midpoint mi of
some edge ei. Vertex vi is remapped to the interpolated point wi ∈ei. For each
vertex vi of T M+
Γ
, deﬁne η(vi, α) as (1 −α)vi + αwi. Extend η to all of SM+
Γ
by
linearly extending η on each triangle in T M+
Γ
. Because T M+
Γ
is a triangulation of
SM+
Γ
, homotopy η is well-deﬁned on every point of SM+
Γ
. Thus η : SM+
Γ
×[0, 1] is
a homotopy from SM+
Γ
to ΣM+
Γ
(σ) where η(SM+
Γ
, 0) equals SM+
Γ
and η(SM+
Γ
, 1)
equals ΣM+
Γ
(σ).
Our last lemma shows that ΣM+
Γ
does not contain mesh vertices whose scalar
values do not equal the isovalue.
Lemma 5.22. Let Γ be a convex polyhedral mesh in R3 where each vertex of Γ has
a scalar value. If v is a vertex of Γ whose scalar value does not equal σ ∈R,
then ΣM+
Γ
(σ) does not contain v.

138
5. Isosurface Patch Construction
Proof: Let v be a mesh vertex whose scalar value, sv, does not equal σ.
By
Property 3, every edge e incident on v intersects ΣM+
Γ
(σ) (abbreviated ΣM+
Γ
) at
most once. Assume e intersects ΣM+
Γ
. Since e ∩ΣM+
Γ
is determined by linear
interpolation and sv does not equal σ, point e ∩ΣM+
Γ
is not equal to v. Thus, v
does not lie on ΣM+
Γ
.
□
Applying Corollary 5.20, the homotopy map η and Lemma 5.22, gives Prop-
erty 5.
Property 5.
The isosurface separates positive mesh vertices from negative ones
and strictly separates strictly positive mesh vertices from negative mesh vertices.
Proof: By Corollary 5.20, set |T M+
Γ
| strictly separates the positive vertices of
Γ from the negative ones. Map η is a homotopy map from SM+
Γ
to ΣM+
Γ
(σ),
which never passes through any vertices of Γ. Vertices of SM+
Γ
that lie on the
boundary of |Γ| remain on the boundary of |Γ| throughout the homotopy η. Thus
η(SM+
Γ
∩∂|Γ|, α) is a subset of ∂|Γ| for all α ∈[0, 1]. By Lemma B.18, ΣM+
Γ
(σ)
separates the positive vertices of Γ from the negative ones.
By Lemma 5.22, ΣM+
Γ
(σ) does not contain any mesh vertices whose scalar
values equal the isovalue σ. Therefore, ΣM+
Γ
(σ) strictly separates vertices with
scalar values greater than σ from vertices with scalar value less than σ.
□
5.4.4
Proof of Isosurface Properties 6, 7, and 8
In Section 5.4.3, we proved that if c1 and c2 are adjacent polyhedra, then
R+
c1(Uc1) and R+
c2(Uc2) agree on shared faces of c1 and c2 (Corollary 5.15). To
prove Property 6, we need to show that if Uc1 and Uc2 are proper, then S+
c1(Uc1)
and S+
c2(Uc2) agree on shared faces of c1 and c2. We ﬁrst extend the deﬁnition
of Sc from c to faces of c.
Let f be a face of c. As in Section 5.4.3, set V +
f
is the set of positive vertices
of f, set Uf is the points of Uc that lie on f, and R+
f (Uf) (abbreviated R+
f ) equals
conv(Uf ∪V +
f ). Deﬁne S+
f (Uf) (abbreviated S+
f ) as
S+
f (Uf) = R+
f (Uf) ∩cl(f −R+
f (Uf)).
As in Section 5.4.3, face f need not be two-dimensional.
Lemma 5.14 shows that R+
c ∩c equals R+
f . To prove that S+
c1 ∩f equals
S+
c2 ∩f, we need a similar lemma for the complements of R+
c and R+
f .
Lemma 5.23. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label, and let Uc be a proper isosurface vertex set of c. For
every face f of polyhedron c, cl(c −R+
c (Uc)) ∩f equals cl(f −R+
f (Uc ∩f)).

5.4. Marching Polyhedra Algorithm
139
(a)
(b)
f
f
v1
v1
v2
v2
Figure 5.18. (a) Cube c, green isosurface vertex set Uc, and blue region c −R+
c . Black
cube vertices are positive. Vertices v1 and v2 are both cube vertices and elements of
Uc. (b) Front facet f of cube c, set Uf = Uc ∩f, and red region R+
f . Region cl(f −R+
f )
is the empty set while cl(c −R+
c ) ∩f is line segment (v1, v2).
Proof: By Lemma 5.14, set Rf equals R+
c ∩f. Thus, f −Rf equals (c −R+
c ) ∩f
and cl(f −R+
f ) is a subset of cl(c −R+
c ) ∩f.
Let p be a point in cl(c −R+
c ) ∩f. If p is in (c −R+
c ) ∩f, then p is in f −Rf,
proving the lemma.
Assume that p is a point in cl(c −R+
c ) ∩f but p is not in (c −R+
c ) ∩f. Since
p is in f, point p is not in c −R+
c . Thus p must be in R+
c .
Since p is in cl(c−R+
c ) and p is in R+
c , point p is in S+
c = R+
c ∩cl(c−R+
c ). By
Lemma 5.10, point p lies on some triangle t ∈T +
c . Let h be the plane through
triangle t. By Corollary 5.6, the vertices of triangle t are in Uc. Since Uc is
proper, the vertices of t are in the interior of edges of c. Thus, plane h intersects
the interior of f and, for every neighborhood Np ⊆R3 of p, set Np ∩f contains
points in f −R+
f . Thus, p is in cl(f −R+
f ) and cl(c −R+
c ) ∩f is a subset of
cl(f −R+
f ).
Since cl(f −R+
f ) is a subset of cl(c −R+
c ) ∩f and cl(c −R+
c ) ∩f is a subset
of cl(f −R+
f ), set cl(f −R+
f ) equals cl(c −R+
c ) ∩f.
□
Lemma 5.23 requires that the isosurface vertex set be proper. Figure 5.18
contains an example of an isosurface set that is not proper and where cl(f −R+
f )
is empty while cl(c −R+
c ) ∩f is a line segment in f. Lemmas 5.14 and 5.16 and
their corollaries do not require the isosurface vertex sets to be proper.
We apply Lemma 5.23 to show that S+
f equals S+
c ∩f.
Lemma 5.24. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label and let Uc be a proper isosurface vertex set of c. For
every face f of polyhedron c, S+
c (Uc) ∩f equals S+
f (Uc ∩f).

140
5. Isosurface Patch Construction
(a)
(b)
f
f
v1
v1
v2
v2
Figure 5.19. (a) Cube c, green isosurface vertex set Uc, and isosurface patch S+
c . Black
cube vertices are positive. Vertices v1 and v2 are both cube vertices and elements of
Uc. (b) Front facet f of cube c and set Uf = Uc ∩f. Set S+
f is the empty set.
Proof: Set S+
c equals R+
c ∩cl(c −R+
c ). By Lemma 5.14, set R+
c ∩f equals R+
f .
By Lemma 5.23, set cl(c −R+
c ) ∩f equals cl(f −R+
f ). Thus,
S+
c ∩f
=
R+
c ∩cl(c −R+
c ) ∩f
=
(R+
c ∩f) ∩(cl(c −R+
c ) ∩f)
=
R+
f ∩cl(f −R+
f )
=
S+
f .
□
As a corollary to Lemma 5.24, we show that that S+
c1 and S+
c2 agree on a
shared face of c1 and c2.
Corollary 5.25. Let c1 and c2 be adjacent convex polyhedra in R3 where each ver-
tex of c1 and c2 has a positive or a negative label. Let Uc1 and Uc2 be isosurface
vertex sets for c1 and c2, respectively, where Uc1 ∩f equals Uc2 ∩f. If Uc1 and
Uc2 are proper isosurface vertex sets, then S+
c1(Uc1) ∩f equals S+
c2(Uc2) ∩f.
Proof: Applying Lemma 5.24,
S+
c1 ∩f = Sf = S+
c2 ∩f.
Lemma 5.24 and its corollary require that the isosurface vertex sets be proper.
Figure 5.19 contains an example of an isosurface set that is not proper and where
S+
f is the empty set while S+
c ∩f is a line segment in f.
To prove Properties 6 and 7, we prove that if isosurface vertex set U is proper,
then S+
Γ (U) is a piecewise linear, orientable 2-manifold whose boundary lies on
∂|Γ|.
Lemma 5.26. Let Γ be a convex polyhedral mesh where each vertex of Γ has a
positive or negative label. Let U be a proper isosurface vertex set for Γ. If the
underlying points set, |Γ|, of Γ is a 3-manifold with boundary, then set S+
Γ (U) is
a piecewise linear, orientable 2-manifold whose boundary lies on ∂|Γ|.

5.4. Marching Polyhedra Algorithm
141
Proof: For any mesh element c ∈Γ, region R+
c is either empty or a three-
dimensional convex set (Corollary 5.9). Since R+
c is a three-dimensional convex
set, the boundary of R+
c is a two-dimensional manifold.
Let p be a point in S+
Γ .
Case I: Point p is in the interior of some mesh element c.
By Corollary 5.11, T +
c is a triangulation of S+
c . Thus, S+
c ∩int(c) equals
∂R+
c ∩int(c). Since ∂R+
c is a two-dimensional manifold, ∂R+
c ∩int(c) is a two-
dimensional manifold. Thus some neighborhood of p in S+
c is homeomorphic
to R2.
Case II: Point p is in the interior of some two-dimensional facet f ∈Γ.
By Lemma 5.21, T +
Γ is a triangulation of S+
Γ . Thus, point p is in some
triangle t1 ∈T +
Γ . Triangle t1 is contained in T +
c1 for some polyhedron c1.
Since p lies on t1∩int(f) and the vertices of t1 lie on edges of c (Lemma 5.5),
point p lies in the interior of some edge ˆe of t1.
Since ∂R+
c1 is two dimensional, there is another triangle t′
1 ̸= t1 that
is in the triangulation of ∂R+
c1 and contains ˆe. Since R+
c1 ∩f is not empty,
facet f must contain some positive vertex v ∈c. By Lemma 5.13, R+
f
is
two-dimensional. By Lemma 5.14, R+
c1 ∩f equals R+
f . Since R+
c1 ∩f is two-
dimensional, triangle t′
1 lies in f. Since triangle t′
1 lies in f, it is not in T +
c1.
Thus, triangle t1 is the only triangle of T +
c1 containing ˆe and point p.
If p is in the interior of |Γ|, then f lies on some other polyhedron c2 ∈Γ.
By Corollary 5.24, S+
c1 ∩f equals S+
c2 ∩f. By deﬁnition, t1 is not contained
in f and so is not in c2. By Corollary 5.11, T +
c2 is a triangulation of S+
c2.
Thus some triangle t2 ∈T +
c2 contains ˆe. As argued for T +
c1, triangle t2 is the
only triangle in T +
c2 that contains ˆe. Since point p lies on an edge ˆe between
two triangles, a neighborhood of p in S+
Γ is homeomorphic to R2.
If p is on the boundary of |Γ|, then p is not contained in any polyhedron
of |Γ| and so is not in any triangle other than t1. Since p lies on the boundary
of t1, some neighborhood of p is homeomorphic to a half-space in R2.
Case III: Point p lies on some mesh edge e of Γ.
Consider any triangle t ∈T +
Γ containing p. Triangle t lies in some mesh
element c ∈Γ. By Lemma 5.5, the vertices of t are a subset of U ∩c. Since
only one point of U lies on e, triangle t intersects e at most once. Thus
point p is a vertex of t. Since U is proper, point p lies in the interior of e.
Let c be a polyhedron containing e. Let τc be the set of triangles that
contain p in the triangulation of ∂R+
c .
Since ∂R+
c is a two-dimensional
manifold, the triangles of τc form a disk. Point p lies in the interior of this
disk. Since p is in S+
c , at least one of these triangles lies in T +
c .
Let f and f ′ be the two facets of c containing e. Since R+
c intersects e,
an endpoint v of e must be positive. Since v is positive, R+
f and R+
f ′ are
two-dimensional. Thus, f contains at least one triangle of τc and so does f ′.

142
5. Isosurface Patch Construction
The triangles of τc that lie in f or f ′ form a disk with p on its boundary.
Removing these triangles from τc leaves a set of triangles forming another
disk with p on its boundary. Thus, the triangles in T +
c that contain p form
a disk with p on the boundary.
If p is in the interior of |Γ|, then the polyhedron containing p form a
cycle around edge e. Within each polyhedron c containing p, some subset
of S+
c is a disk containing p on its boundary. By Corollary 5.25, these disks
agree on their boundaries. Together they form a disk surrounding p. Thus,
some neighborhood of p in S+
Γ is homeomorphic to R2.
If p is on the boundary of |Γ|, then the polyhedron containing p form a
chain around edge e. Within each polyhedron c containing p, some subset
of S+
c
is a disk containing p on its boundary.
By Corollary 5.25, these
disks agree on their boundaries. Together they form a disk with p on the
boundary. Thus, some neighborhood of p in S+
Γ is homeomorphic to a half-
space in R2.
Since every point p ∈S+
Γ has a neighborhood in S+
Γ homeomorphic to R2 or a
half-space in R2, set S+
Γ is a 2-manifold with boundary. Since the neighborhood
of p in S+
Γ is homeomorphic to R2 if p is in the interior of |Γ| and homeomorphic
to a half-space in R2 if p is on the boundary of |Γ|, the boundary of S+
Γ equals
|Γ| ∩S+
Γ .
By Lemma 5.21, set T +
Γ is a triangulation of S+
Γ . Each triangles in T +
Γ is
oriented so that the induced normal points to the positive region.
Thus the
triangles have consistent orientations and the manifold is orientable.
□
The isosurface ΣM+
Γ
(σ) is an embedding of S+
Γ (MΓ) into |Γ|. If S+
Γ (MΓ) is
a 2-manifold with boundary and this embedding is one-to-one, then ΣM+
Γ
(σ) is
also a 2-manifold with boundary. However, as shown in Figure 5.10, the mapping
from S+
c (Mc) to ΣM+
c
(σ) may not be one-to-one, even for a single mesh element
c. We claim that if c is a cube, tetrahedron, square pyramid, octahedron, or
bipyramid, then the embedding is one-to-one.
Lemma 5.27. Let σ be a scalar value. Let c be a cube, tetrahedron, square pyra-
mid, octahedron, or bipyramid where each vertex v of c has a scalar value, sv,
and each vertex v has a negative label if sv < σ or a positive label if sv ≥σ. If
no vertex of c has scalar value equal to σ, then the mapping from S+
c (Mc) to
ΣM+
c
(σ) is one-to-one.
Unfortunately, the only proof we have for Lemma 5.27 is a tedious case
analysis for each polyhedron. Thus, we omit the proof of this lemma.
Property 6.
The isosurface is a piecewise linear, oriented 2-manifold with bound-
ary.
Property 7.
The boundary of the isosurface lies on the boundary of the mesh.

5.5. Isohull
143
Proof of Properties 6 & 7: By Lemma 5.26, the set S+
Γ (MΓ) (abbreviated S+
Γ ) is a
piecewise linear, orientable 2-manifold with boundary whose boundary lies on
∂|Γ|. Set ΣM+
Γ
(σ) (abbreviated ΣM+
Γ
) is an embedding of S+
Γ into |Γ|. We claim
that this embedding is one-to-one.
Let p be some point in ΣM+
Γ
. Since no mesh vertex value equals the isovalue,
set ΣM+
Γ
does not contain any mesh vertices (Lemma 5.22). Moreover, any point
of ΣM+
Γ
on a mesh edge e is the image of e∩S+
Γ , which can only be the midpoint
of e. Thus, if p lies on a mesh edge e, then it is the image of only one point
in S+
Γ .
Assume p is on the interior of a mesh facet f. Point p lies on a line segment
in ΣM+
Γ
∩f connecting two mesh edges e and e′. This line segment is the image
of the edge ˆe in S+
Γ connecting the midpoints of e and e′. Since the mapping
of ˆe to ΣM+
Γ
is linear, this mapping is one-to-one. Thus p is again the image of
only one point in S+
Γ .
Finally, assume p lies in the interior of some mesh element c. By Lemma 5.27,
the mapping from S+
c (Mc) to ΣM+
c
(σ) is one-to-one. Since ΣM+
Γ
∩int(c) equals
ΣM+
c
(σ) ∩int(c), point p is not the image of any points in S+
Γ −S+
c (Mc). Thus
p is the image of only one point in S+
Γ .
Since the mapping from S+
Γ to ΣM+
Γ
is one-to-one and S+
Γ is an orientable
2-manifold with boundary, set ΣM+
Γ
is an orientable 2-manifold with boundary.
Since ∂S+
Γ lies on ∂|Γ| and all points on ∂S+
Γ ∩∂|Γ| are mapped to ∂|Γ|, the
boundary of ΣM+
Γ
also lies on ∂|Γ|.
□
The last property is that Υ does not contain any zero-area or duplicate tri-
angles and forms a triangulation of the isosurface.
Property 8.
Set Υ does not contain any zero-area triangles or duplicate triangles,
and the triangles in Υ form a triangulation of the isosurface.
Proof: Since no mesh vertex has scalar value equal to the isovalue, no isosurface
vertex lies on a mesh vertex. By Property 3, each bipolar mesh edge contains
only one isosurface vertex. Thus, the linear interpolation on isosurface vertices
does not create any zero-area or duplicate isosurface triangles.
Set Υ is the image of T +
Γ under the embedding which takes S+
Γ to ΣM+
Γ
. Since
this embedding is one-to-one and T +
Γ deﬁnes a triangulation of S+
Γ (Lemma 5.21),
set Υ deﬁnes a triangulation of ΣM+
Γ
.
□
5.5
Isohull
Instead of using the isosurface patch construction algorithm in Section 5.2 to
construct an isosurface lookup table, one could use the algorithm directly on the
mesh elements. The disadvantage is that this will typically be slower than using a

144
5. Isosurface Patch Construction
lookup table. However, it does have some advantages. Firstly, one can avoid the
problem of self-intersection (Figure 5.10) by constructing the isosurface patches
directly on the isosurface vertices. Thus, Properties 6 and 7 in Section 5.4.1 are
no longer restricted to meshes composed of cubes, tetrahedra, square pyramids,
etc., but apply to any convex polyhedral mesh. Secondly and perhaps more im-
portantly, one can avoid the construction of degenerate triangles when isosurface
vertices lie on mesh vertices. As discussed in Section 5.5.5, one can also have a
mixed algorithm, which uses table lookup for well-behaved mesh elements and
constructs the isosurface patch directly in all other cases.
5.5.1
Isosurface Patch Construction
The isosurface patch construction algorithm in Section 5.5.1 uses edge midpoints
to construct isosurface patches. We generalize that algorithm to use points other
than midpoints, including edge endpoints.
Let c be a convex polyhedron in R3 where each vertex of c is labeled positive
or negative and positive vertices may be labeled strictly positive.
Edges of c
are positive, negative, or bipolar as deﬁned in Section 5.1. Positive edges may
be strictly positive.
Isosurface vertex sets and proper isosurface vertex sets are deﬁned in Sec-
tion 5.1. Let Uc be an isosurface vertex set of c, although not necessarily a
proper one. Let V +
c
be the vertices of c with positive labels, let V −
c
be the
vertices with negative labels, and let R+
c (Uc) equal conv(Uc ∪V +
c ), the convex
hull of Uc ∪V +
c . Construct R+
c (Uc).
We distinguish three cases, based on the dimension of R+
c (Uc). If R+
c (Uc)
has dimension three, then ∂R+
c (Uc), the boundary of R+
c (Uc), is composed of
two-dimensional convex polygons. Triangulate ∂R+
c (Uc) by triangulating each
convex polygon without adding any additional vertices. Orient the triangles so
that the induced normals point to R+
c (Uc). Let T +
c (Uc) be the set of oriented
triangles in the triangulation of ∂R+
c (Uc) that do not lie on facets of c. If R+
c (Uc)
has dimension two and is a subset of some facet of c, then let T +
c (Uc) be the
set of all triangles in the triangulation of R+
c (Uc). Orient the triangles so that
the induced normal points away from c. Otherwise, let T +
c (Uc) be the empty
set.
The triangles in T +
c (Uc) form the triangulated isosurface patch whose vertices
are Uc. This isosurface patch separates V −
c from V +
c . The algorithm is presented
in Figure 5.20 and illustrated in Figure 5.21.
Note the diﬀerence between T +
c (Uc), deﬁned in Section 5.4.2, and T +
c (Uc).
Set T +
c (Uc) is a triangulation of cl(∂R+
c (Uc) −∂c). If R+
c (Uc) has dimension
three, then T +
c (Uc) equals T +
c (Uc). If R+
c (Uc) has dimension two and is a subset
of some facet of c, then T +
c (Uc) is the triangulation of R+
c (Uc) while T +
c (Uc) is
empty.

5.5. Isohull
145
Construct the convex hull of the positive vertices
and isosurface vertex set Uc

If the convex hull is three-dimensional, then
1. Triangulate the boundary of the convex hull
2. Remove triangles on the polyhedron boundary

If the convex hull is a two-dimensional subset
of some polyhedron facet, then
triangulate the convex hull

Otherwise, return the empty set
Figure 5.20. Algorithm IsoPatch3D for 3D isosurface patch construction from isosur-
face vertex set Uc.
(a)
(b)
(c)
(d)
Figure 5.21. Isosurface patch generation. (a) Cube conﬁguration. (b) Isosurface vertex
set Uc. (c) Set R+
c (Uc), the convex hull of Uc and positive vertices. (d) Isosurface
composed of triangles in R+
c (Uc) ∩cl(c −R+
c (Uc)).
Algorithm IsoPatch3D is almost the same as the midpoint-based algorithm
IsoMid3D in Section 5.2. The only diﬀerence is the case where R+
c (Uc) is two-
dimensional. If we let Uc equal Mc, the set of midpoints of the bipolar edges of c,
then algorithm IsoPatch3D constructs an isosurface patch on the midpoints of
the bipolar edges of c. Since the set R+
c (Mc) = R+
c is always three-dimensional
(Corollary 5.9), this isosurface patch is the same as the one constructed by Iso-
Mid3D. Thus the examples in Figure 5.6 also illustrate algorithm IsoPatch3D.
In the case where R+
c (Uc) is two-dimensional and a subset of ∂c, algorithm
IsoPatch3D returns a set of triangles that lie on the boundary of c. As illus-
trated in Figure 5.22, omitting such triangles might leave a hole in the isosurface.

146
5. Isosurface Patch Construction
(a)
(b)
c
c
Figure 5.22. Example where R+
c (Uc) is a two-dimensional subset of a facet of c. Gold
vertices have scalar value equal to the isovalue. Black vertices have scalar value greater
than the isovalue. Set R+
c (Uc) is a single triangle lying on the facet of c containing
the three gold vertices. (a) Removing this triangle creates a hole in the isosurface.
(b) Algorithm IsoPatch3D retains this triangle.
Algorithm IsoPatch3D could use the negative vertices V −
c
in place of V +
c .
Let R−
c (Uc) equal conv(Uc ∪V +
c ) and triangulate ∂R+
c (Uc). If R−
c (Uc) is three-
dimensional, let T −
c (Uc) be the set of triangles in the triangulation of ∂R+
c (Uc)
that do not lie on the boundary of c. If R−
c (Uc) is two-dimensional and is a subset
of some facet of c, let T −
c (Uc) be the set of all triangles in the triangulation of
R−
c (Uc). Otherwise, let T −
c (Uc) be the empty set.
In order for T −
c (Uc) to separate V −
c from V +
c , the restrictions on Uc must also
change. Instead of points in Uc not lying on negative vertices or negative edges of
c, points in Uc must not lie on positive vertices or positive edges of c. Without
this restriction, T −
c (Uc) may not separate V −
c
from V +
c .
More signiﬁcantly,
isosurfaces constructed from isosurface patches without this restriction may have
holes. (See Figure 5.23.) As previously discussed, one should not mix isosurface
patches of the form T +
c (Uc) with isosurface patches of the form T −
c (Uc).
Isosurface patches constructed from Uc can be diﬀerent than isosurface patches
constructed from edge midpoints that are then remapped to Uc. Figure 5.24

5.5. Isohull
147
(a)
(b)
c
c
Figure 5.23. Example of isosurface construction using R−
c (Uc).
Gold vertices have
scalar value equal to the isovalue. Black vertices have scalar value greater than the
isovalue. (a) If vertices with scalar value equal to the isovalue are positive (i.e., in set
V +
c ), then V −
c
and R−
c (Uc) are empty, creating a hole in the isosurface. (b) If vertices
with scalar value equal to the isovalue are negative (i.e., in set V −
c ), then V −
c
contains
the three gold vertices and R−
c (Uc) contains a triangle.
(a)
(b)
(c)
Figure 5.24. Example of diﬀerent triangulations produced by algorithms IsoMid3D
and IsoPatch3D. (a) Triangulation produced by IsoMid3D with vertices at midpoints.
(b) Triangulation produced by mapping vertices of the IsoMid3D triangulation to
points U. (c) Triangulation produced by IsoPatch3D directly on isosurface vertex
set U.

148
5. Isosurface Patch Construction
(a)
(b)
Figure 5.25. Example of degenerate triangulation produced by algorithm IsoMid3D
but not by IsoPatch3D. (a) Triangulation produced by IsoMid3D with vertices at
midpoints. Gray triangle becomes degenerate when vertices are mapped to points U
in (b). (b) Triangulation produced by IsoPatch3D directly on isosurface vertex set
U. Note that the triangulation produced by mapping vertices of the IsoMid3D trian-
gulation to points U would look the same, but would contain an invisible degenerate
triangle corresponding to the gray triangle in (a).
shows such diﬀerences. Because the triangulation of the patch constructed from
Uc is diﬀerent from the triangulation of the patch constructed from edge mid-
points, the isosurface is diﬀerent. Figure 5.25 shows the diﬀerence when a point
of Uc lies on a vertex. The midpoint construction creates degenerate triangles
while the construction from Uc does not.
For simplicity, we often abbreviate R+
c (Uc) and T +
c (Uc) as R+
c and T +
c , re-
spectively, whenever set Uc is clear from context.
5.5.2
Algorithm
We use algorithm IsoPatch3D from the previous section to construct isosur-
faces. We call the algorithm IsoHull3D. Algorithm IsoHull3D is similar to
the Marching Polyhedra algorithm, but instead of ﬁrst constructing isosur-
face patches and then interpolating their vertices, it ﬁrst computes the vertices
and then construct isosurface patches directly on those vertices. Input to Iso-
Hull3D is an isovalue, a three-dimensional convex polyhedral mesh and a set
of scalar values at the vertices of the mesh.
The algorithm has two steps. The ﬁrst step is computing the location of the
isosurface vertices. For each mesh edge [p, q] with one positive and one negative
endpoint, apply linear interpolation as in Section 1.7.2 to compute a point on
[p, q] representing the intersection of the isosurface with [p, q]. If sp and sq are
the scalar values at p and q and σ is the isovalue, then map v to (1 −α)p + αq
where α = (σ −sp)/(sq −sp). Let U be the set of all such interpolated points
over all mesh edges with one positive and one negative endpoint.

5.5. Isohull
149
Compute isosurface vertex coordinates using linear interpolation

For each mesh polyhedron,
construct an isosurface patch (algorithm IsoPatch3D)
Figure 5.26. Algorithm IsoHull3D.
(a)
c1
c2
v
(b)
c1
c2
v
(c)
c1
c2
v
Figure 5.27. (a) Grid Γ of two cubes. Black vertices are positive. Note that vertex v
lies on a bipolar edge in cube c1 but not in c2. (b) Green vertices forming an isosurface
vertex set U for grid Γ. Vertex v is both a positive grid vertex and an element of U.
Thus isosurface vertex set U is not proper. Set Uc2 = U ∩c2 is an isosurface vertex
set for c2 even though v ∈Uc2 does not lie on any bipolar edge in c2. (c) Isosurface
formed from the isosurface vertex set U.
If the positive endpoint of [p, q] is strictly positive, then 0 < α < 1 and
αp + (1 −α)q is in the interior of [p, q]. Thus no point of U lies on a strictly
positive vertex of c.
Linear interpolation on multiple mesh edges that share the same endpoint
could return that endpoint for each such edge. Since U is a set, it contains only
a single copy of that endpoint.
The second step is constructing isosurface patches on those vertices.
For
each mesh polyhedron c, let Uc be the points of U that lie in c. Each bipolar
edge of c contains one and only one point of Uc, and no point of Uc lies on a
strictly positive vertex or a negative vertex or a negative edge. Apply algorithm
IsoPatch3D (Section 5.5.1) using the points Uc. Return the union of all the
triangle sets T +
c (Uc) over all mesh polyhedron c.
Note that not every point of Uc must lie on a bipolar edge of c. (See Fig-
ure 5.27.) Since there is no restriction on points of Uc lying on positive edges,
algorithm IsoPatch3D can still be applied.

150
5. Isosurface Patch Construction
2
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
8
8
Figure 5.28. With isovalue 8, ten grid edges (colored magenta) incident on the two
interior vertices are bipolar. For each grid cube c, set R+
c is either a point or a line
segment so S+
c is the empty set. None of the bipolar edges intersect the IsoHull3D
isosurface. (IsoHull3D returns the empty set as the isosurface.)
5.5.3
Isosurface Properties
IsoHull3D returns a ﬁnite set, Υ, of oriented triangles. The isosurface is the
union of these triangles. The vertices of the isosurface are the triangle vertices.
We claim the following properties for the isosurface and triangulation pro-
duced by IsoHull3D. All properties other than Properties 3 and 5 are the same
as the Marching Cubes isosurface properties. As with Marching Cubes, the
isosurface is a 2-manifold with boundary under appropriate conditions.
Property 3 is similar to Property 3 of Marching Cubes and Marching
Polyhedra isosurfaces, but no longer guarantees that bipolar edges are inter-
sected by the isosurface. If the scalar value of one endpoint of the bipolar edge
equals the isovalue, the isosurface may not intersect the bipolar edge. For in-
stance, there are ten bipolar edges in the grid in Figure 5.28 but none of them
intersect the IsoHull3D isosurface.
Property 5 is also a property (Property 8) of Marching Cubes and March-
ing Polyhedra isosurfaces, but only under the restriction that isovalue does
not equal the scalar value of any mesh vertex. There is no such restriction on
Property 5 for IsoHull3D isosurfaces. Because IsoHull3D does not position
isosurface vertices after constructing the triangulation, it does not create zero-
area triangles.
The following properties apply to all isosurfaces produced by the IsoHull3D
algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on mesh edges.

5.5. Isohull
151
Property 3.
The isosurface intersects every bipolar mesh edge at most once and
intersects every bipolar edge with a strictly positive endpoint at exactly one point.
Property 4.
The isosurface does not intersect any negative or strictly positive
mesh edges.
Property 5.
Set Υ does not contain any zero-area triangles.
To claim that the isosurface separates strictly positive mesh vertices from
strictly negative ones, we need the following condition on the mesh:
• The mesh is a partition of a 3-manifold with boundary.
Under this condition we have the following separation property:
Property 6.
The isosurface strictly separates strictly positive mesh vertices from
negative mesh vertices.
Note that Property 6 no longer claims anything about mesh vertices with
scalar value equal to the isovalue. These vertices may be on either side of the
isosurface.
As with Marching Cubes, if both endpoints of a mesh edge have scalar
value equal to the isovalue, then the isosurface may intersect the mesh edge
zero, one, or two times or may contain the mesh edge.
Under appropriate conditions, the isosurface produced by IsoHull3D is a
2-manifold with boundary. As with the Marching Polyhedra algorithm, the
isovalue should not equal the scalar value of any vertex and the underlying space
must be a manifold. However, unlike the Marching Polyhedra algorithm,
there is no restriction on the mesh elements.
IsoHull3D will not create a
self-intersecting surface, even for the pathological case in Figure 5.10.
Consider a convex polyhedral mesh and isovalue that has the following two
conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The mesh is a partition of a 3-manifold with boundary.
Under these conditions, the isosurface produced by IsoHull3D has the fol-
lowing three properties:
Property 7.
The isosurface is a piecewise linear, orientable 2-manifold with
boundary.
Property 8.
The boundary of the isosurface lies on the boundary of the mesh.
Property 9.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
The fact that Υ does not contain any zero-area triangles is already stated in
Property 5 and is restated in Property 9 for completeness.

152
5. Isosurface Patch Construction
5.5.4
Proof of Isosurface Properties
Proofs of Properties 1 and 2 are the same as in Section 2.3.4 for Marching
Cubes and are omitted.
Many of the other proofs are similar to those for
Marching Polyhedra in Sections 5.4.2, 5.4.3, and 5.4.4.
As deﬁned in Section 5.5.1, let R+
c (Uc) (abbreviated R+
c ) be the convex hull
of Uc ∪V +
c . If R+
c is three-dimensional, then let T +
c (Uc) (abbreviated T +
c ) be
the triangles in a triangulation of ∂R+
c that do not lie on the boundary of c.
Orient the triangles so that the induced normals point toward R+
c . If R+
c is two-
dimensional and R+
c is a subset of some facet of c, then let T +
c be the triangles
in a triangulation of R+
c . Orient the triangles so that the induced normals point
away from c. Otherwise, let T +
c
be the empty set. Set 
c∈Γ T +
c
is the set Υ
returned by IsoHull3D.
To prove Property 3, we need the following lemma, which shows that the
vertices of T +
c (Uc) are all from the set Uc. This lemma is similar to Lemma 5.5
from Section 5.4.2 and its proof relies upon that lemma.
Lemma 5.28. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is an isosurface vertex set for c, then the set
of vertices of T +
c (Uc) is a subset of Uc.
Proof: As deﬁned in Section 5.4.2, T +
c (Uc) (abbreviated T +
c ) are the triangles
in a triangulation of ∂R+
c that do not lie on the boundary of c.
If R+
c (Uc)
(abbreviated R+
c ) is three-dimensional, then T +
c (Uc) (abbreviated T +
c ) equals
T +
c . By Lemma 5.5, the vertices of T +
c are a subset of Uc, proving the claim.
If R+
c is a two-dimensional subset of some facet of c, then T +
c is a triangulation
of R+
c . Let w be a vertex of T +
c . Since R+
c equals conv(Uc ∪V +
c ), vertex w is in
Uc ∪V +
c .
If w is not in V +
c , then w must be in Uc, establishing the claim. Assume that
vertex w is in V +
c .
Let f be the facet of c containing R+
c . Let (w, v) be the edge of c incident
on w that is not contained in f. Since R+
c is contained in f,
(w, v) ∩R+
c = w.
Since vertex v is not in R+
c , vertex v must have a negative label. Thus, (w, v)
is a bipolar edge. By deﬁnition, the isosurface vertex set Uc contains some point
p on (w, v). Since p is in R+
c and (w, v) ∩R+
c equals w, point p must equal w.
Thus w is in Uc, proving the claim.
□
The set | T +
c (Uc)| is the union of the triangles in T +
c .
Corollary 5.29. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label, and let Uc be an isosurface vertex set for c. If e is
a bipolar edge of c, then
e ∩| T +
c (Uc)| ⊆e ∩Uc.

5.5. Isohull
153
Proof: Since c is convex, only isosurface triangles with vertices on e intersect e.
By Lemma 5.28, every vertex of T +
c (Uc) (abbreviated T +
c ) must be in Uc. Set
Uc intersects e in a single point e ∩Uc. Thus e ∩Uc is the only point of e that
could lie on | T +
c | and so e ∩| T +
c | ⊆e ∩Uc.
□
If R+
c is zero- or one-dimensional, then T +
c
is the empty set.
Thus, it is
possible that e ∩| T +
c | is empty, while e ∩Uc is not.
Property 3.
The isosurface intersects every bipolar mesh edge at most once and
intersects every bipolar edge with a strictly positive endpoint at exactly one point.
Property 4.
The isosurface does not intersect any negative or strictly positive
mesh edges.
Proof of Properties 3 & 4: Let e be a mesh edge. Since mesh elements are convex,
only isosurface triangles with vertices on e intersect e.
Assume e is bipolar and e intersects | T +
c |. By Corollary 5.29, for every mesh
element c containing e, set | T +
c | ∩e is a subset of e ∩Uc. Since Uc equals U ∩c,
for every mesh element c containing e, set | T +
c | ∩e is a subset of e ∩U. Since
e ∩U is a single point, the isosurface intersects e at most once.
Assume the positive endpoint of e is strictly positive. By deﬁnition, set Uc
does not contain either the strictly positive or the negative endpoint of e. Thus
set Uc must contain some point p in the interior of e. Point p is a vertex of some
triangle t ∈Tc(Uc). Thus p is on the isosurface and the isosurface intersects e
at exactly one point.
If e is negative or strictly positive, then no isosurface vertex lies on e. Thus
the isosurface does not intersect negative or strictly positive grid edges.
□
Because IsoHull3D does not position isosurface vertices after constructing
the triangulation, it does not create zero-area triangles.
Property 5.
Set Υ does not contain any zero-area triangles.
Proof: Set Υ equals 
c∈Γ T +
c . For each mesh element c, set T +
c (Uc) is the subset
of the triangles in a triangulation of ∂R+
c (Uc). Since none of the triangles in the
triangulation of ∂R+
c (Uc) have zero area, none of the triangles in T +
c (Uc) have
zero area. Thus, no triangle returned by IsoHull3D has zero area.
□
In Section 5.4.3, we deﬁned S+
c as R+
c ∩cl(c −R+
c ).
When R+
c is three-
dimensional or is a two-dimensional subset of ∂c, set T +
c
is a triangulation of
S+
c . (See the proof of 5.30 below.) However, if R+
c has dimension zero or one
or has dimension two but is not a subset of ∂c, then Sc will be nonempty while
T +
c will be the empty set. We need to modify S+
c so that it corresponds to the
region triangulated by T +
c .

154
5. Isosurface Patch Construction
Deﬁne S+
c (Uc) as
S+
c (Uc) =
⎧
⎨
⎩
R+
c (Uc) ∩cl(R+
c (Uc))
if dim(R+
c (Uc)) = 3,
R+
c (Uc)
if dim(R+
c (Uc)) = 2 and R+
c (Uc) ⊂∂c,
∅
otherwise,
where dim(R+
c (Uc)) is the dimension of R+
c (Uc). Abbreviate S+
c (Uc) as S+
c . Set
Sc equals Sc when R+
c has dimension three and int(R+
c ), the interior of R+
c ,
is the empty set when R+
c has a dimension less than three. Thus Sc strictly
separates int(R+
c ) from (c −R+
c ).
We claim that T +
c is a triangulation of S+
c and thus | T +
c | equals S+
c .
Lemma 5.30. Let c be a convex polyhedron in R3 where each vertex of c has a
positive or a negative label. If Uc is an isosurface vertex set of c, then T +
c (Uc)
is a triangulation of S+
c (Uc).
Proof: As deﬁned in Section 5.4.2, T +
c are the triangles in a triangulation of ∂R+
c
that do not lie on the boundary of c and S+
c equals R+
c ∩cl(c −R+
c ). If R+
c is
three-dimensional, then T +
c equals T +
c and S+
c equals S+
c . By Lemma 5.10, T +
c
is a triangulation of S+
c , proving the lemma.
Since R+
c is convex, R+
c is a subset of c if and only if it is a subset of some
facet of c. If R+
c is two-dimensional and a subset of c, then S+
c equals R+
c and
T +
c is a triangulation of R+
c . Thus, T +
c is a triangulation of S+
c .
If R+
c has dimension zero or one, then both T +
c
and S+
c are empty, again
proving the lemma.
□
In Section 5.4.2, we deﬁned R+
Γ (U) as the union of R+
c (Uc) over all the
polyhedra c ∈Γ. When U is a proper isosurface vertex set, each region R+
c (Uc) is
three-dimensional and R+
Γ (U) is three-dimensional. However, if U is not proper,
then some regions R+
c (Uc) can have dimensions zero, one, or two and R+
Γ (U) can
have subregions with dimensions zero, one, or two. To strip these subregions from
R+
Γ (U), we take the closure of the interior of R+
Γ (U), denoted cl(int(R+
Γ (U))).
Let Γ be a convex polyhedral mesh where every vertex of Γ has a positive or
a negative label. Let |Γ| be the union of all the polyhedra in Γ, and let U be
an isosurface vertex set of Γ. For each polyhedron c ∈Γ, let Uc equal U ∩c.
Deﬁne T +
Γ (U), R+
Γ (U), R+
Γ (U), and S+
Γ (U) (abbreviated T +
Γ , R+
Γ , R+
Γ , and S+
Γ ,
respectively) as
T +
Γ (U)
=

c∈Γ
T +
c (Uc),
R+
Γ (U)
=

c∈Γ
R+
c (Uc),
R+
Γ (U)
=
cl(int(R+
Γ (U))),
S+
Γ (U)
=
R+
Γ (U) ∩cl(|Γ| −R+
Γ (U)).

5.5. Isohull
155
(The deﬁnition of R+
Γ was given in Section 5.4.3 and is repeated here for com-
pleteness.) Set TΓ(U) is the set Υ returned by IsoHull3D. By Lemma B.8 in
Appendix B, S+
Γ separates R+
Γ from |Γ| −R+
Γ .
SΓ and Sc have substantially diﬀerent deﬁnitions. If Γ is composed of a single
convex polyhedron, then SΓ and Sc may not be equal. Thus, S+
Γ (U) does not
necessarily equal 
c∈Γ S+
c (Uc). Nevertheless, we claim that S+
Γ (U) is a subset
of 
c∈Γ S+
c (Uc).
Lemma 5.31. Let Γ be a convex polyhedral mesh in R3 where each vertex of Γ has
a positive or negative label. If U is an isosurface vertex set of Γ and Uc equals
U ∩c for each polyhedron c ∈Γ, then S+
Γ (U) is a subset of 
c∈Γ S+
c (Uc).
Proof: Let p be a point in S+
Γ . Triangulate S+
Γ so that every triangle is contained
in some grid cube. Since p has local dimension two in S+
Γ , point p must lie on
some triangle t ⊆S+
Γ . Since R+
Γ is a subset of R+
Γ and R+
Γ equals 
c∈Γ R+
c ,
triangle t is in R+
c1 for some c1 ∈Γ.
By Lemma B.2 in Appendix B, cl(|Γ| −R+
Γ ) equals cl(|Γ| −R+
Γ ). Thus, t
is in cl(|Γ| −R+
Γ ). Since cl(|Γ| −R+
Γ ) equals 
c∈Γ cl(c −R+
c ), triangle t is in
cl(c2 −R+
c2) for some c2 ∈Γ. If c1 equals c2, then t is in S+
c1 and therefore in

c∈Γ S+
c . Assume c1 does not equal c2.
The intersection of c1 and c2 is a facet f of both polyhedra, and triangle t is in
f. By Lemma 5.14, triangle t is in R+
c2. Since triangle t is in cl(c2 −R+
c2), region
R+
c2 must be contained in f. By deﬁnition, S+
c2 equals R+
c2 and thus contains t.
Thus p is S+
c2 and is therefore in 
c∈Γ S+
c .
□
Property 6 follows from Lemma 5.31.
Property 6.
The isosurface strictly separates strictly positive mesh vertices from
negative mesh vertices.
Proof: Let v1 and v2 be vertices of Γ with scalar values above and below the
isovalue, respectively. Since v1 is strictly positive and v2 is negative, neither
vertex is in set U. By Lemma 5.28, neither v1 nor v2 is a vertex of T +
c for any
c and thus neither lies on | T +
c | for any c.
By Lemmas 5.30 and 5.31, S+
Γ is a subset of | T +
Γ |. Since | T +
Γ | equals 
c∈Γ | T +
c |,
neither v1 nor v2 lie on | T +
Γ |. The strictly positive vertex v1 lies in the interior
of R+
Γ while the negative vertex v2 lies in |Γ| −R+
Γ . By Lemma B.8, S+
Γ strictly
separates int( R+
Γ ) from |Γ| −R+
Γ . Thus | T +
Γ | strictly separates v1 from v2.
□
The proof of Properties 7 and 8 for IsoHull3D is similar to the proof of Prop-
erties 6 and 7 for the Marching Polyhedra algorithm. Because IsoHull3D
does not move isosurface vertices after the creation of isosurface patches, there is

156
5. Isosurface Patch Construction
no problem of self-intersection within a mesh element as for Marching Poly-
hedra (Figure 5.10). Thus there is no restriction other than convexity on the
type of mesh elements.
Property 7.
The isosurface is a piecewise linear, orientable 2-manifold with
boundary.
Property 8.
The boundary of the isosurface lies on the boundary of the mesh.
Proof of Properties 7 & 8: Since no vertex of Γ has scalar value equal to the iso-
value, all points in U lie in the interior of bipolar edges. Thus U is a proper
isosurface vertex set for Γ. By Corollary 5.9, R+
c is three-dimensional or empty
for each polyhedron c. Thus set R+
Γ (U) equals R+
Γ (U), set T +
Γ (U) equals T +
Γ (U),
and set S+
Γ (U) equals S+
Γ (U).
Applying Lemma 5.26 from Section 5.4.4, S+
Γ (U) = S+
Γ (U) is a piecewise
linear, orientable 2-manifold whose boundary lies on ∂|Γ|.
By Lemma 5.21,
T +
Γ (U) = T +
Γ (U) is a triangulation of S+
Γ (U) = S+
Γ (U). Thus Υ = | T +
Γ (U)| is
a piecewise linear, orientable 2-manifold with boundary whose boundary lies on
the boundary of Γ.
□
The last property is that Υ does not contain any zero-area or duplicate tri-
angles and forms a triangulation of the isosurface.
Property 9.
Set Υ does not contain any zero-area triangles or duplicate triangles
and the triangles in Υ form a triangulation of the isosurface.
Proof: By Property 5, Υ does not contain any zero-area triangles.
Since no mesh vertex has scalar value equal to the isovalue, all points in
U lie in the interior of bipolar edges. and U is a proper isosurface vertex set.
Thus every isosurface triangle is contained in one and only one mesh element.
Since the isosurface triangles within a mesh element are unique, Υ contains no
duplicate triangles.
Since U is a proper isosurface vertex set, set T +
Γ (U) equals T +
Γ and S+
Γ (U)
equals S+
Γ (U). By Lemma 5.21, T +
Γ (U) = T +
Γ (U) is a triangulation of S+
Γ (U) =
S+
Γ (U). Thus Υ = T +
Γ (U) is a triangulation of the isosurface.
□
5.5.5
IsoHull3D with Table Lookup
The IsoHull3D algorithm can be combined with table lookup. A table can
be constructed and used for the most common polyhedral mesh elements such
as cubes, tetrahedra, and pyramids, which satisfy Lemma 5.27. For all other
mesh elements or for any mesh element containing a vertex whose scalar value
equals the isovalue, the direct isosurface patch construction can be performed as
in Section 5.5.1.

5.5. Isohull
157
(a)
(b)
Figure 5.29. Example of degenerate triangulation produced by algorithm IsoMid3D.
(a) Triangulation produced by IsoMid3D with vertices at midpoints. Gray triangle
becomes degenerate when vertices are mapped to a gold vertex whose scalar value
equals the isovalue. (b) Resulting isosurface after mapping vertices to a gold vertex
whose scalar value equals the isovalue. The isosurface contains an invisible degenerate
triangle corresponding to the gray triangle in (a).
(a)
2
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
8
8
(b)
2
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
8
8
Figure 5.30. (a) Isosurface triangles generated by IsoMid3D. (b) Isosurface composed
of degenerate triangles forming a line segment.

158
5. Isosurface Patch Construction
Figure 5.31. Examples of isosurfaces produced with “+” and “−” and “=” labels.
Black vertices are labelled positive and gold vertices are labelled equals.
Figure 5.32. Isosurface consisting of two duplicate triangles that do not enclose any
three-dimensional regions. The three gold vertices have scalar value equal to the iso-
value. All other vertices have scalar value less than the isovalue. A single isosurface
triangle is generated from the isosurface lookup table for each cube. Since the two tri-
angles lie in the common facet shared by the two cubes, the two triangles are identical.
5.5.6
Expanded Isosurface Tables
The Marching Cubes, Marching Tetrahedra, and Marching Polyhe-
dra algorithms construct isosurfaces by treating points with scalar value equal
to the isovalue as points whose scalar value is above the isovalue. The subsequent
remapping of isosurface vertices creates degenerate triangles as in Figure 5.29.
It also creates one- or zero-dimensional isosurface components as in Figure 5.30.
The isosurface patch construction algorithm in Section 5.5.1 can be used to
properly handle points whose scalar value equals the isovalue. As before, label
points with scalar value greater than the isovalue with a “+” and label points
with scalar value below the isovalue with a “−”. However, label points whose
value equals the isovalue with an “=”.
Each vertex now has three possible
labellings.
A cube c has eight vertices and so there are 38 or 6561 possible
conﬁgurations. Let Uc be the set of all midpoints of edges with one “+” and one
“−” endpoint and the set of all “=” vertices. Let R+
c (Uc) equal conv(Uc ∪V +
c ).
Construct the isosurface patches as in Section 5.5.1. Examples of some of the
components are in Figure 5.31.

5.6. Notes and Comments
159
Since no isosurface vertex is mapped to a mesh vertex unless it was already
there, the remapping of isosurface vertices does not create any degenerate trian-
gles. It also does not create any zero- or one-dimensional isosurface components.
It can still create some two-dimensional components that do not enclose any
three-dimensional regions. (See Figure 5.32.)
5.6
Notes and Comments
Using the convex hull to generate isosurface patches was independently proposed
by Lachaud and Montanvert [Lachaud and Montanvert, 2000] and Bhaniramka
et al. [Bhaniramka et al., 2000,Bhaniramka et al., 2004a]. Generating isosurface
lookup tables based on three vertex labels, “−”, “+”, and “=” is described by
Raman and Wenger in [Raman and Wenger, 2008].

This page intentionally left blank
This page intentionally left blank

CHAPTER 6
ISOSURFACE GENERATION IN 4D
Time varying scalar data is inherently four-dimensional, with the fourth dimen-
sion being time. Tremendous advancements in memory size and processing speed
have greatly the reduced the cost of gathering or generating such data sets.
Typically, time varying data is visualized by constructing and rendering iso-
surfaces at each three-dimensional time slice. Rendered images are composed to
form an animation of the isosurface in time. In this chapter we discuss a diﬀer-
ent approach of creating a single continuous isosurface from the four-dimensional
data. This isosurface can be sliced along the time but it can also be sliced along
diﬀerent axes to give diﬀerent representations of the data. It can also be dec-
imated to create a compact representation of the isosurface and smoothed to
create an isosurface that varies smoothly with time.
Parametric studies are another source of four-dimensional scalar data sets.
Multiple three-dimensional scalar data sets are generated by varying a single pa-
rameter in a simulation or experiment. Adjoining the three-dimensional data sets
gives a four-dimensional scalar data set with the fourth dimension representing
the varying parameter.
Perhaps the most useful application of isosurface generation in R4 is the auto-
matic construction of three-dimensional interval volumes. An interval volume is
a region bounded by isosurfaces. In Chapter 7 we will deﬁne and discuss interval
volumes and their construction by lifting to R4.
In R3, generic level sets1 and their isosurface approximations are two-di-
mensional, either two-dimensional manifolds or the union of such manifolds. In
R4, generic level sets and isosurfaces are three-dimensional.
Piecewise linear
isosurfaces in R4 are composed of tetrahedra.
1As noted in Chapter 1, a level set can be a the entire space or a single point. In fact, it can
be any subset of the space. However, if f : R3 →R and all its derivatives are diﬀerentiable,
then f−1(c) is a 2-manifold for “almost all” values of c. Similarly, if f : R4 →R and all its
derivatives are diﬀerentiable, then f−1(c) is a 3-manifold for “almost all” values of c.
161

162
6. Isosurface Generation in 4D
Both variations of Marching Cubes and the dual contouring algorithms ex-
tend to four dimensions. In this chapter, we describe four-dimensional variations
of the algorithms Marching Cubes, IsoHull3D, and Surface Nets.
6.1
Deﬁnitions and Notation
Visibility. In this chapter, we deﬁne two types of triangulations, lexicographic
triangulations and incremental triangulations. In analyzing these triangulations,
we need the following deﬁnition.
Deﬁnition 6.1. Let {p1, . . . , pm} be a set of points, let τ be some triangulation of
conv(p1, . . . , pm), and let q be a point that is not in conv(p1, . . . , pm). A simplex
t is visible from q if, for each p ∈t, the open line segment (p, q) does not intersect
conv(p1, . . . , pm).
Figure 6.1 illustrates edges in 2D that are visible from a point q1 and triangles
in 3D that are visible from a point q2.
Vertex and edge properties. The deﬁnitions of vertex and edge properties and
isosurface vertex sets given here are the same as the 3D deﬁnitions in Section 5.1.
For review, we summarize them here.
A mesh vertex is positive if its scalar value is greater than or equal to σ and
negative if its scalar value is less than σ. A positive vertex is strictly positive if its
scalar value does not equal the isovalue.
Let c be a polytope in R4 where each vertex of c has a positive or a negative
label. Set V +
c
is the set of positive vertices of c, set V −
c
is the set of negative
vertices of c, and set Mc is the set of midpoints of bipolar edges of c.
e1
e2
e3
e4
e5
q1
q2
(a)
(b)
Figure 6.1. (a) Edges e1, e2, and e3 are visible from q1. Edges e4 and e5 are not visible
from q1. (b) Red triangles are visible from q2. Blue triangles are not visible from q2.

6.1. Deﬁnitions and Notation
163
An edge of c is positive if both its endpoints are positive. An edge of c is
negative if both its endpoints are negative. A positive edge is strictly positive if
both its endpoints are strictly positive. An edge of c is bipolar if one endpoint is
positive and one endpoint is negative.
Isosurface vertex sets. Let Γ be a convex polytopal mesh in R4 and c a convex
polytope in R4 where every vertex of Γ and c is labeled negative, positive, or
strictly positive. An isosurface vertex set U of Γ (respectively Uc of c) is a ﬁnite
set of points lying on the edges of Γ (respectively c) such that every bipolar edge
of Γ (respectively c) contains one and only one point of U (respectively Uc),
and no point of U (respectively Uc) lies on a strictly positive vertex or negative
vertex or negative edge of Γ (respectively c.) A proper isosurface vertex set is an
isosurface vertex set U of Γ (respectively Uc of c) such that every point in U
(respectively Uc) lies in the interior of a bipolar edge of Γ (respectively c.) The
set Mc of midpoints of bipolar edges of c is an example of a proper isosurface
vertex set of c.
Interior and boundary edges and cubes. The deﬁnitions of interior and bound-
ary edges and cubes for a 4D grid parallel the 3D deﬁnitions from Section 3.1.
Deﬁnition 6.2. Let Γ be a regular grid in R4.
• An interior grid edge in R4 is a grid edge that is contained in eight grid
cubes.
• An boundary grid edge in R4 is a grid edge that is contained in seven or
fewer grid cubes.
Deﬁnition 6.3.
• An interior grid cube is a grid cube whose edges are all interior grid edges.
• A boundary grid cube is a grid cube that contains at least one boundary grid
edge.
Let Γ be a regular grid in R4.
We use the notation Γinner to denote the
regular subgrid of Γ composed of the interior grid cubes of Γ.
Centroid. The centroid of a set of points P = {p1, p2, . . . , pk} is
p1 + p2 + . . . + pk
k
.

164
6. Isosurface Generation in 4D
6.2
Isosurface Table Generation in 4D
The algorithm for isosurface table generation in 4D is a direct generalization of
the 3D algorithm described in Chapter 5. The only diﬀerence is that the trian-
gulation step must ensure that triangulations of adjacent isosurface patches are
compatible. As in 3D, we present an algorithm that constructs isosurface patches
in any (bounded) four-dimensional convex polytope, not just a hypercube.
6.2.1
Lexicographic Triangulations
As in three dimensions, the boundary of isosurface patches in 4D should align
with the boundary of adjacent isosurface patches. In 3D, the boundary of an
isosurface patch consists of line segments, so the only issue is matching these line
segments. In 4D, the boundary consists of triangulated convex polygons. Not
only should the convex polygons in adjacent patches match but the triangulation
of these convex polygons should also match. To ensure this matching, we use a
speciﬁc triangulation that we call a lexicographic triangulation.
Deﬁnition 6.4. Point p = (x1, . . . , xd) precedes point q = (y1, . . . , yd) in lexico-
graphic order if, for some k ≤d,
• xi = yi for all i < k,
• xk < yk.
For instance, point (5.0, 2.0, 3.0, 6.0) precedes point (5.0, 2.0, 6.0, 2.0) in lexico-
graphic order. Lexicographic order is similar to the dictionary ordering of equal
length words. Denote p precedes q by p ≺q. A sequence of distinct points,
(p1, . . . , pm) is listed in lexicographic order if pi ≺pj whenever i < j.
For a set of simplices τ, let F ∗(τ) be the set τ and all faces of elements of
τ. If τ is a triangulation and p is a vertex of some simplex in τ, then τ −{p} is
the set of simplices in F ∗(τ) that do not contain vertex p. Let conv(p1, . . . , pm)
denote the convex hull of point set {p1, . . . , pm}.
The deﬁnition of a lexicographic triangulation is recursive.
Deﬁnition 6.5. Let (p1, . . . , pm) be a sequence of points in Rd listed in lexico-
graphic order. A triangulation τ of conv(p1, . . . , pm) is a lexicographic triangulation
if
• τ is a single vertex, or
• τ −pm is a lexicographic triangulation of conv(p1, . . . , pm−1).
If one includes all the lower-dimensional faces, the lexicographic triangulation
of the convex hull of a set of points is unique.
More precisely, if τ and τ′

6.2. Isosurface Table Generation in 4D
165
P3
P2
P1
P7
P5
P6
P4
x
y
Figure 6.2. A lexicographic triangulation of a point set. The lexicographic order of the
vertices is (p1, p2, p3, p4, p5, p6, p7).
are lexicographic triangulations of conv(p1, . . . , pm), then F ∗(τ) equals F ∗(τ ′)
(Lemma 6.9).
The dimension of conv(p1, . . . , pm) may be k < d, in which case the largest
simplices in τ are k-simplices. Note that the dimension of conv(p1, . . . , pm−1)
may be less than the dimension of conv(p1, . . . , pm). Thus, even if τ contains
k-simplices, the largest simplices in τ −pm could be (k −1)-simplices. Figure 6.2
contains an example of a set of points and their lexicographic triangulation.
The deﬁnition of lexicographic triangulation extends to the boundary of a
convex hull.
The boundary of a k-dimensional convex polytope is composed
of (k−1) dimensional convex facets. The lexicographic triangulation of ∂conv(p1,
. . . , pm), which is the boundary of conv(p1, . . . , pm), is the union of the lexico-
graphic triangulations of all the facets. Equivalently, let τ be the lexicographic
triangulation of conv(p1, . . . , pm).
The lexicographic triangulation of ∂conv(p1,
. . . , pm) is the triangulation of ∂conv(p1, . . . , pm) determined by the (k −1)-
dimensional simplices of τ that lie on ∂conv(p1, . . . , pm) (Lemma 6.10). It fol-
lows from the second deﬁnition that the intersection of any two simplices in the
lexicographic triangulation of ∂conv(p1, . . . , pm) is a face of each simplex.
The recursive deﬁnition of a lexicographic triangulation leads directly to an
incremental algorithm for constructing one. Initially, let τ represent a triangula-
tion consisting of a single point. At the start of the ith iteration, the triangulation
forms a lexicographic triangulation of conv(p1, . . . , pi−1). With the addition of
point pi, we also add simplices connecting pi to those simplices on the boundary
of conv(p1, . . . , pi−1) that are visible from pi. The enlarged set of simplices forms
a triangulation of conv(p1, . . . , pi).

166
6. Isosurface Generation in 4D
p1
p2
p3
p4
p5
p6
p7
p7
(a)
(b)
p7
p7
(c)
(d)
Figure 6.3. Illustration of the Incremental Convex Hull algorithm.
(a) Points
(p1, . . . , p7) in R3. (b) Convex hull of {p1, . . . , p6}. Red simplices are in conv(p1, . . . , p6)
but not in conv(p1, . . . , p7). (c) Convex hull of {p1, . . . , p6}, minus deleted red simplices.
Deleting red simplices creates a “hole” whose boundary is colored red. (d) Convex hull
of {p1, . . . , p7}. New simplices are colored green.
6.2.2
The Incremental Convex Hull Algorithm
The Incremental Convex Hull algorithm is an algorithm for constructing the
convex hull of a set {p1, . . . , pm} of points in Rd. More precisely, the algorithm
constructs a triangulation of ∂conv(p1, . . . , pm), the boundary of the convex hull
of {p1, . . . , pm}.
The algorithm starts with the set {p1}, which is its own convex hull.
It
adds points one at a time, constructing a triangulation of ∂conv(p1, . . . , pi+1)
from the triangulation of ∂conv(p1, . . . , pi).
The algorithm identiﬁes and re-
moves those simplices of ∂conv(p1, . . . , pi) that are not in ∂conv(p1, . . . , pi+1)
(Figure 6.3(c)). Removal of the simplices creates a “hole” whose boundary is
a set of (d−2)-dimensional simplices. The algorithm adds pi+1 to each of the
boundary simplices to form a set of (d−1)-dimensional simplices that ﬁll the hole
(Figure 6.3(d)). A detailed 3D version of the algorithm is given in [O’Rourke,
1998] and a higher-dimensional version in [Clarkson et al., 1993].
As described previously, the Incremental Convex Hull algorithm returns
a triangulation of the boundary of the convex hull.
A variation of the algo-
rithm [Preparata and Shamos, 1985, Edelsbrunner, 1987] returns the facets of
the convex hull instead of a triangulation. The variation is called the Beneath-
Beyond Method in [Preparata and Shamos, 1985, Edelsbrunner, 1987]. Re-
turning a triangulation of ∂conv(p1, . . . , pm) is actually simpler than returning

6.2. Isosurface Table Generation in 4D
167
the facets, since the simplices in the triangulation have a simple, uniform de-
scription. Because we want a triangulation of isosurface patches, we use the
algorithm [O’Rourke, 1998,Clarkson et al., 1993], which returns a triangulation.
The triangulation constructed by the Incremental Convex Hull algo-
rithm is determined by the order in which the points pi are processed. If points
are added in lexicographic order, the algorithm constructs a lexicographic trian-
gulation of the boundary of conv(p1, p2, . . . , pm).
6.2.3
Isosurface Patch Construction
Let c be a polytope in R4 where each vertex of c has a positive or a negative
label. Let Mc be the midpoints of the bipolar edges of c. We show how to
construct an isosurface patch in c using set Mc as its vertices.
Compute the set Mc of midpoints of the bipolar edges of c. As deﬁned in
Section 6.1, set V +
c
is the set of positive vertices of c. Construct the convex
hull of Mc ∪V +
c
and the lexicographic triangulation of its boundary. Orient the
tetrahedra in this triangulation so that the induced normals point toward the
convex hull. Let T +
c be the set of oriented tetrahedra that do not lie on facets of
c. We shall prove (Corollary 6.7) that the vertices of T +
c are all from Mc. The
tetrahedra in T +
c form the triangulated isosurface patch whose vertices are Mc.
This isosurface patch separates the positive vertices from the negative vertices
of c.
We call the algorithm IsoMid4D. Algorithm IsoMid4D is presented in Fig-
ure 6.4.
Compute the midpoints of the bipolar edges of the polytope

Construct the convex hull of the positive vertices
and the midpoints of the bipolar edges

Construct a lexicographic triangulation of the convex hull boundary

Remove tetrahedra on the polytope boundary
Figure 6.4. Algorithm IsoMid4D for construction of isosurface patches from midpoints
of bipolar edges of a 4D polytope.

168
6. Isosurface Generation in 4D
The combinatorial structure of the isosurface within c is determined from the
conﬁguration of the polytope’s vertex labels. The isosurface does not intersect
any edge whose endpoints have the same label.
As in three dimensions, instead of using the positive vertices, V +
c , one could
use the negative vertices, V −
c . Construct the convex hull of Mc ∪V −
c
and the
lexicographic triangulation of its boundary. Let T −
c
be the tetrahedra in this
triangulation that do not lie on the boundary of c. The tetrahedra in T −
c form
an alternate isosurface patch for c.
Any tetrahedron in the triangulation of conv(Mc∪V +
c ) that contains a vertex
of V +
c is on the boundary of c and thus not a tetrahedron of T +
c (Corollary 6.8).
However, the converse is not true. There may be tetrahedra that lie on some
facet of c but whose vertices all come from Mc. Since these tetrahedra lie on a
facet of c, they are not included in T +
c .
A primary requirement is that isosurface patches in adjacent grid elements
properly align on their boundaries. As was discussed in Section 2.3.5, if some iso-
surface patches separate positive vertices while others separate negative vertices,
proper alignment may not occur. The isosurface patches separating positive ver-
tices are deﬁned by T +
c while the isosurface patches separating negative vertices
are deﬁned by T −
c . Thus, while either T +
c or T −
c
can be used to generate the
isosurface lookup tables, only one or the other should be used for all table entries.
Other triangulations such as the one in [Max, 2001] can be used in place of the
lexicographic triangulation of the convex hull boundary. The key requirement
is that two adjacent isosurface patches have the same triangulation on their
common border. In Section 6.3.5, we will show that lexicographic triangulations
satisfy this requirement (Lemma 6.18). We prefer lexicographic triangulations
because such triangulations are naturally created by the Incremental Convex
Hull algorithm when vertices are added in lexicographic order.
6.2.4
Isosurface Table Construction
Let c be the unit hypercube in R4 whose vertices are (0, 0, 0, 0), (1, 0, 0, 0), . . .,
(1, 1, 1, 1). The combinatorial structure of a four-dimensional hypercube is de-
picted in Figure 6.5. In the isosurface extraction algorithm, the sixteen vertices
of c receive positive and negative labels representing their relationship to the iso-
value. A vertex that has scalar value below the isovalue will receive a negative
label, “−”. A vertex with scalar value above or equal to the isovalue receives a
positive label, “+”.
Since each vertex is either positive or negative, there are 216 = 65, 536 con-
ﬁgurations of positive and negative vertex labels.2 The isosurface lookup table
contains 216 entries, one for each conﬁguration κ. Each entry is a list of quadru-
2Under rotational symmetry and reﬂections, the number of distinct conﬁgurations is 222
[Banks et al., 2004].

6.2. Isosurface Table Generation in 4D
169
Figure 6.5. Four-dimensional hypercube with 16 vertices, 32 edges, 24 two-dimensional
faces, and 8 three-dimensional facets.
ples of bipolar edges of c. Each quadruple (e1, e2, e3, e4) represents an oriented
tetrahedron whose vertices lie on e1 and e2 and e3 and e4. The list of quadruples
deﬁne the combinatorial structure of the isosurface patch for conﬁguration κ.
This isosurface patch is constructed using algorithm IsoMid4D in the previous
section. The tetrahedra in this isosurface patch are the set T +
c . The isosurface
patch intersects every bipolar edge of c exactly once and does not intersect any
other hypercube edges.
Two conﬁgurations can be adjacent to one another if the face they share in
common has the same set of positive and negative vertices. The boundaries of the
isosurface patches for each conﬁguration should align on the common face. Note
that a 4D hypercube has eight three-dimensional cubes as faces as well as lower-
dimensional squares, edges, and points.
As in R3, two reasonable isosurface
patches for adjacent conﬁgurations can have boundaries that do not align on
the common face and so are incompatible. Isosurfaces constructed using such
incompatible isosurface patches for adjacent conﬁgurations may have “holes”
and may not be a 3-manifold.
Compatibility of isosurface patches in R4 is more subtle than in R3. The
isosurface lookup table stores a set of tetrahedra forming a triangulation (tetrahe-
dralization) of the isosurface patches. If two hypercubes share a three-dimensional
cube as a facet, then the intersection between their two isosurface patches is a
two-dimensional region (or the empty set.) The triangulation of each isosurface
patch determines a triangulation of this two-dimensional region. The two trian-
gulations determined by the two isosurface patches should be the same. Thus
triangulations of isosurface patches should be constructed so that the triangu-
lations align on a common face.
Triangulation alignment between isosurface
patches was not a problem in 3D since isosurface patches in adjacent cubes in
3D intersect in a single line segment.
If triangulations of isosurface patches do not align on a common face, then
isosurface tetrahedra will intersect in subsets of faces. Thus, the isosurface tetra-
hedra will not form a triangulation of the isosurface. More importantly, the

170
6. Isosurface Generation in 4D
2C−II
2C−I
2C
Figure 6.6. Ambiguous 3D conﬁguration 2C. Isosurface patches 2C-I and 2C-II.
geometric position of each isosurface tetrahedron is determined by the location
of the isosurface vertices. Depending upon the location of isosurface vertices,
“holes” or “pockets” could form in the isosurface or the isosurface could inter-
sect itself. Algorithm IsoMid4D constructs an isosurface lookup table where
isosurfaces in any two adjacent conﬁgurations are compatible. The isosurface
patch boundaries and their triangulations align on the common face of any two
adjacent conﬁgurations.
6.2.5
Opposite Positive Vertices
Conﬁguration 2C in 3D has exactly two positive vertices on opposite corners
of the cube (Figure 6.6). As discussed in Section 5.2, this conﬁguration is spe-
cial. This conﬁguration has two “natural” isosurface patches, one consisting of
a cylinder connecting the two positive vertices (2C-I in Figure 6.6) and one con-
sisting of two triangles splitting each of the positive vertices from the rest of
the cube (2C-II in Figure 6.6). Because the intersection of each of these isosur-
face patches and the cube boundary is exactly the same, either isosurface patch
can be used without creating any inconsistencies with adjacent conﬁgurations.
Algorithm IsoMid3D generates a cylindrical isosurface patch around those two
vertices but this cylindrical patch can be replaced by two triangles.
A similar property holds in 4D when exactly two positive vertices are on op-
posite corners of the hypercube in 4D. (See Figure 6.7(a).) Algorithm IsoMid4D
generates a “cylindrical”3 isosurface patch around those two vertices. This cylin-
drical patch can be replaced by two tetrahedra splitting the two positive vertices
from the fourteen negative ones. Since no hypercube facet contains these two
vertices, the replacement by two tetrahedra does not change the boundary of the
isosurface patch and so is compatible with the isosurface patches in all the other
conﬁgurations. There are eight conﬁgurations with exactly two positive vertices
on opposite corners of the hypercube.
3The isosurface patch will be homeomorphic to S2 × [0, 1].

6.3. Marching Hypercubes
171
(a)
(b)
Figure 6.7. (a) Positive vertices (black dots) at opposite corners of the hypercube.
(b) Positive vertices (black dots) at opposite corners of a 3D facet of the hypercube.
Note that the two positive vertices must lie on opposite corners of the 4D
hypercube, not of some 3D facet of the hypercube. (See Figure 6.7(b).) Switching
the isosurface for two positive tetrahedra splitting oﬀopposite corners of a 3D
facet can create inconsistencies with adjacent conﬁgurations.
6.3
Marching Hypercubes
6.3.1
Algorithm
The basic steps of the Marching Hypercubes algorithm are the same as the
steps of the 3D Marching Cubes algorithm. Just as a three-dimensional regular
grid is composed of three-dimensional cubes, a four-dimensional regular grid
is composed of four-dimensional hypercubes. The algorithm iterates over the
hypercubes of the four-dimensional grid.
Input to the Marching Hypercubes algorithm is an isovalue and a set of
scalar values at the vertices of a four-dimensional regular grid. The algorithm
has three steps.
(See Figure 6.8.)
Read the isosurface lookup table from a
preconstructed data ﬁle. For each grid hypercube, retrieve from the lookup table
a set of oriented isosurface tetrahedra representing the combinatorial structure
of the isosurface. The vertices of these tetrahedra form the isosurface vertices.
Assign geometric locations to the isosurface vertices based on the scalar values
at the hypercube edge endpoints. Construction of the Marching Hypercubes
lookup table was described in Section 6.2.4. We explain the last two steps of the
algorithm below.
The isosurface lookup table is constructed on the unit hypercube with vertices
(0, 0, 0, 0), (1, 0, 0, 0), (0, 1, 0, 0), . . ., (0, 1, 1, 1), (1, 1, 1, 1). To construct isosurface

172
6. Isosurface Generation in 4D
Read hypercube isosurface lookup table

For each grid hypercube, retrieve isosurface tetrahedra

Compute isosurface vertex coordinates using linear interpolation
Figure 6.8. Marching Hypercubes.
edges in grid hypercube (ix, iy, iz, iw), we have to map unit hypercube edges to
edges of hypercube (ix, iy, iz, iw). Each vertex v = (vx, vy, vz, vw) of the unit
hypercube maps to
v + (ix, iy, iz, iw) = (vx, vy, vz, vw) + (ix, iy, iz, iw)
= (vx + ix, vy + iy, vz + iz, vw + iw).
Each edge e of the unit square with endpoints (v, v′) maps to edge
e + (ix, iy, iz, iw) = (v + (ix, iy, iz, iw), v′ + (ix, iy, iz, iw)).
Finally, each edge quadruple (e1, e2, e3, e4) maps to
(e1 + (ix, iy, iz, iw), e2 + (ix, iy, iz, iw), e3 + (ix, iy, iz, iw), e4 + (ix, iy, iz, iw)).
The isosurface lookup table determines only the edge containing each isosur-
face vertex. The geometric location of the isosurface vertex along that edge is
not deﬁned by the lookup table.
The vertices of the isosurface tetrahedra are the isosurface vertices. To map
each isosurface tetrahedra to a geometric tetrahedra, we use linear interpolation
to position the isosurface vertices as described in Section 1.7.2. Each isosurface
vertex v lies on a grid edge [p, q]. If sp and sq are the scalar values at p and q
and σ is the isovalue, then map v to (1 −α)p + αq where α = (σ −sp)/(sq −sp).
The Marching Hypercubes algorithm is presented in Algorithm 6.1. Func-
tion LinearInterpolation, called by this algorithm, is deﬁned in Algorithm 1.1
in Section 1.7.2.
6.3.2
Isosurface Properties
Properties for the Marching Hypercubes isosurface are similar to those for
the Marching Cubes isosurface. Under appropriate conditions the isosurface
is a 3-manifold with boundary.

6.3. Marching Hypercubes
173
Input
: F is a 4D array of scalar values.
Coord is a 4D array of (x, y, z, w) coordinates.
σ is an isovalue.
Result
: A set Υ of isosurface tetrahedra.
MarchingHypercubes(F, Coord, σ, Υ)
1 Read Marching Hypercubes lookup table into Table;
/* Assign “+” or “−” signs to each vertex
*/
2 foreach grid vertex (ix, iy, iz, iw) do
3
if F[ix, iy, iz, iw] < σ then Sign[ix, iy, iz, iw] ←“−”;
4
else Sign[ix, iy, iz, iw] ←“+”;
/* F[ix, iy, iz, iw] ≥σ */
5 end
6 T ←∅;
/* For each grid hypercube, retrieve isosurface tetrahedra
*/
7 foreach grid hypercube (ix, iy, iz, iw) do
8
I ←(ix, iy, iz, iw);
/* Cube vertices are I, I + (1, 0, 0, 0), . . ., I + (1, 1, 1, 1)
*/
9
κ ←(Sign[I], Sign[I + (1, 0, 0, 0)], . . ., Sign[I + (1, 1, 1, 1)]);
10
foreach edge quadruple (e1, e2, e3, e4) ∈Table[κ] do
11
Insert edge quadruple (e1 + I, e2 + I, e3 + I, e4 + I) into T;
12
end
13 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
14 foreach bipolar grid edge e with endpoints I = (ix, iy, iz, iw) and
J = (jx, jy, jz, jw) do
15
we ←LinearInterpolation (Coord[I], F[I], Coord[J], F[J], σ);
16 end
/* Convert T to set of tetrahedra
*/
17 Υ ←∅;
18 foreach quadruple of edges (e1, e2, e3, e4) ∈T do
19
Υ ←Υ ∪{(we1, we2, we3, we4)};
20 end
Algorithm 6.1. Marching Hypercubes.
Marching Hypercubes returns a ﬁnite set, Υ, of tetrahedra.
The iso-
surface is the union of these tetrahedra. The vertices of the isosurface are the
tetrahedra vertices.
The following properties apply to all isosurfaces produced by the Marching
Hypercubes algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on grid edges.

174
6. Isosurface Generation in 4D
Property 3.
The isosurface intersects every bipolar grid edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
grid edges.
Property 5.
The isosurface separates positive grid vertices from negative ones
and strictly separates strictly positive grid vertices from negative grid vertices.
Properties 3 and 4 imply that the isosurface intersects a minimum number
of grid edges. As with Marching Cubes, if both endpoints of a grid edge have
scalar value equal to the isovalue, then the isosurface may intersect the grid edge
zero, one, or two times or may contain the grid edge.
By Property 3, the isosurface intersects every bipolar grid edge. However,
the bipolar grid edge may be intersected by zero-volume isosurface tetrahedra.
The following properties apply to the Marching Hypercubes isosurfaces
whose isovalues do not equal the scalar value of any grid vertex.
Property 6.
The isosurface is a piecewise linear, orientable 3-manifold with
boundary.
Property 7.
The boundary of the isosurface lies on the boundary of the grid.
Property 8.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra, and the tetrahedra in Υ form a triangulation of the isosurface.
6.3.3
Proof of Isosurface Properties 1–4
Most of the proofs of the Marching Hypercubes isosurface properties are
simply 4D versions of the 3D proofs of the Marching Polyhedra isosurface
properties presented in Sections 5.4.2–5.4.4.
We highly recommend that the
reader review the proofs in that section before looking at the 4D versions here.
For lemmas with proofs that are exactly the same, we have omitted the proofs
and refer back to the proofs in Sections 5.4.2–5.4.4.
Isosurface vertex sets and proper isosurface vertex sets were deﬁned in Sec-
tion 6.1. As with the proofs for Marching Polyhedra, we state the lemmas
in this section and the following three sections in the general setting of isosur-
face vertex sets instead of restricting ourselves to the set of midpoints used in
IsoMid4D.
Let c be a convex polytope in R4. Let Uc be an isosurface vertex set of c. Let
R+
c (Uc) equal conv(Uc ∪V +
c ), the convex hull of Uc and the positive vertices of
c. Construct the lexicographic triangulation of ∂R+
c (Uc), which is the boundary
of R+
c (Uc). Let T +
c (Uc) be the tetrahedra in the lexicographic triangulation of
∂R+
c (Uc) that do not lie on the boundary of c. Since T +
c (Uc) is the subset of

6.3. Marching Hypercubes
175
a triangulation, set T +
c (Uc) is itself a triangulation. We will often abbreviate
R+
c (Uc) and T +
c (Uc), as R+
c and T +
c , respectively.
The set Mc of midpoints of bipolar edges of c is a proper isosurface vertex
set of c. Abbreviate R+
c (Mc) as RM+
c
and T +
c (Mc) as T M+
c
.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on grid edges.
Proof of Properties 1 & 2: The Marching Hypercubes isosurface is the union of
a ﬁnite set of tetrahedra, so it is piecewise linear. By construction, the vertices
of these tetrahedra lie on the grid edges.
□
To prove Property 3, we need to show that Uc is the set of vertices of T +
c (Uc).
We ﬁrst show that the set of vertices of T +
c (Uc) is a subset of Uc. The proof of the
following lemma is almost the same as the proof of Lemma 5.5 from Section 5.4.2,
with the separating plane replaced by a separating hyperplane.
Lemma 6.6. Let c be a convex polytope in R4 where each vertex of c has a positive
or a negative label. If Uc is an isosurface vertex set for c, then the set of vertices
of T +
c (Uc) is a subset of Uc.
Proof: Let w be a vertex of T +
c = T +
c (Uc). The vertices of R+
c = conv(Uc ∪V +
c )
are Uc ∪V +
c . Since T +
c (Uc) is a subset of a triangulation of ∂R+
c that does not
add any vertices, vertex w is in Uc ∪V +
c .
If w is not in V +
c , then w must be in Uc, establishing the claim. Assume that
vertex w is in V +
c .
Since w is in T +
c , it must be incident on some tetrahedron t that is not on a
facet of c. Let h be the hyperplane containing t. Since h intersects the interior
of c and h contains w, there is some edge (w, v) of c that is separated from R+
c
by h and does not lie on h. Thus,
(w, v) ∩R+
c = w.
Since vertex v is not in R+
c , vertex v must have a negative label. Thus, (w, v)
is a bipolar edge. By deﬁnition, the isosurface vertex set Uc contains some point
p on (w, v). Since p is in R+
c and (w, v) ∩R+
c equals w, point p must equal w.
Thus w is in Uc, proving the claim.
□
Proofs of the following corollaries to Lemma 6.6 are the same as the proofs
to the corollaries of Lemma 5.5 in Section 5.4.2 and are omitted.
Corollary 6.7. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set for c, then the
set of vertices of T +
c (Uc) equals Uc.

176
6. Isosurface Generation in 4D
Corollary 6.8. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set for c, then no
vertex of c is in the set of vertices of T +
c (Uc).
Let μ be the translation that maps each grid hypercube c to the unit hyper-
cube used in constructing the isosurface lookup table. If the vertices of c are
labeled “+” or “−”, then vertices of μ(c) receive “+” or “−” labels from the
corresponding vertices of c. Thus, μ(v) is positive if and only if v is positive and
μ(v) is negative if and only if v is negative.
Property 3.
The isosurface intersects every bipolar grid edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
grid edges.
Proof of Properties 3 & 4: The isosurface is constructed by retrieving tetrahedra
from a lookup table and then determining their vertex positions using linear
interpolation. Let c be a grid hypercube containing a grid edge e. Vertices of
c are labeled “+” or “−” based on the relationship of their scalar value to the
isovalue. The isosurface patch for μ(c) is a subset of conv(Mμ(c) ∪V +
μ(c)), the
convex hull of the midpoints of bipolar edges and positive vertices of μ(c).
Since c is convex, only isosurface tetrahedra with vertices on e intersect e.
By Corollary 6.8, the vertices of T +
μ(c)(Mμ(c)) (abbreviated T M+
μ(c)) are midpoints
of edges of μ(c). Thus, the isosurface patch in μ(c) intersects μ(e) at most once.
If e is bipolar, then so is μ(e). The midpoint of μ(e) is in Mμ(c). Set T M+
μ(c)
contains some tetrahedron containing this midpoint. Thus, the isosurface patch
in μ(c) intersects μ(e) at exactly one point p. Point p ∈μ(e) maps to a single
point on e determined by linear interpolation. Thus the isosurface intersects e
at exactly one point.
If e is negative or strictly positive, then no isosurface vertex lies on e. Thus
the isosurface does not intersect negative or strictly positive grid edges.
□
6.3.4
Lexicographic Triangulation Properties
Before proving the rest of the isosurface properties, we need to state and prove
two lemmas about lexicographic triangulations.
Let P be a ﬁnite set of points in Rd. We claim that the convex hull of a ﬁnite
set of points P has only one lexicographic triangulation when one includes all
lower-dimensional faces in the triangulation. As previously deﬁned, for a set τ
of simplices, F ∗(τ) is the set τ and all the faces of elements of τ.
Lemma 6.9. If P is a ﬁnite set of points and τ and τ′ are lexicographic triangu-
lations of conv(P), then F ∗(τ) equals F ∗(τ ′).

6.3. Marching Hypercubes
177
Proof: The proof is by induction on the number of points in P.
If P has exactly one point, then F ∗(τ) and F ∗(τ ′) consist of the zero-
dimensional simplex p1 and the lemma is trivially true.
Assume that F ∗(τm) equals F ∗(τ ′
m) for any two lexicographic triangulations
τm and τ′
m of the convex hull of m points. We wish to show that F ∗(τm+1)
equals F ∗(τ ′
m+1) for any two lexicographic triangulations τm+1 and τ′
m+1 of the
convex hull of m + 1 points.
Let {p1, p2, . . . , pm+1} be a set of m + 1 points listed in lexicographic order.
Let τm+1 and τ ′
m+1 be lexicographic triangulations of conv(p1, . . . , pm+1). Let τm
and τ ′
m equal τm+1 −{pm+1} and τ ′
m+1 −{pm+1}, respectively. By deﬁnition, τm
and τ ′
m are lexicographic triangulations of conv(p1, p2, . . . , pm). By the inductive
assumption, F ∗(τm) equals F ∗(τ ′
m).
If pm+1 is in conv(p1, p2, . . . , pm), then F ∗(τm+1) equals F ∗(τm) and F ∗(τ ′
m+1)
equals F ∗(τ ′
m). Thus, F ∗(τm+1) equals F ∗(τ ′
m+1).
Assume pm+1 is not in conv(p1, p2, . . . , pm). A simplex t1 is in F ∗(τm+1) if
and only if t1 is in F ∗(τm) or t1 equals conv(pm+1 ∪t0) where t0 ∈F ∗(τm) and
t0 is visible from pm+1. Since F ∗(τm) equals F ∗(τ ′
m), any simplex in F ∗(τm)
that is visible from pm+1 is also a simplex in F ∗(τ ′
m) that is visible from pm+1
and vice versa. Thus F ∗(τm+1) equals F ∗(τ ′
m+1), proving the claim.
□
Let P be a ﬁnite set of points in Rd. If f is a face of conv(P) and τ is a
triangulation of conv(P), let τ ∩f denote the set {t ∩f : t ∈τ and t ∩f ̸= ∅}.
Lemma 6.10. Let P be a ﬁnite set of points in Rd, and let f be a face of conv(P).
If τ is a lexicographic triangulation of conv(P) and τ′ is a lexicographic trian-
gulation of conv(P ∩f), then F ∗(τ) ∩f equals F ∗(τ ′).
Proof: The proof is by induction on the number of points in P.
If P has exactly one point, then τ consists of the zero-dimensional simplex
p1 whose only face is p1 and the lemma is trivially true.
Assume the lemma is true when P has m points. We wish to show that the
the lemma is true when P has m + 1 points.
Let Pm+1 = {p1, p2, . . . , pm+1} be a set of m+1 points listed in lexicographic
order. Let Pm = {p1, p2, . . . , pm} be the ﬁrst m points in Pm+1. Let τm and
τm+1 be lexicographic triangulations of conv(Pm) and conv(Pm+1), respectively.
Let f be a face of conv(Pm+1). Let τ ′
m and τ′
m+1 be lexicographic triangulations
of conv(Pm ∩f) and conv(Pm+1 ∩f), respectively.
If pm+1 is not in f, then f is also a face of conv(Pm). By Lemma 6.9, set
F ∗(τ ′
m+1) equals F ∗(τ ′
m) and F ∗(τm+1) ∩f equals F ∗(τm) ∩f. By the inductive
assumption, F ∗(τ ′
m) equals F ∗(τm) ∩f. Thus, F ∗(τ ′
m+1) equals F ∗(τm+1) ∩f.
Assume pm+1 is in f. Let g equal f ∩conv(Pm). If g is the empty set, then
conv(Pm+1 ∩f) is just the point pm+1 and f is the point pm+1.
Thus both
τm+1 ∩f and τ′
m+1 equal pm+1 and so F ∗(τm+1) ∩f equals F ∗(τ ′
m+1).
Assume g is not the empty set. Let t1 be a simplex in F ∗(τm+1) containing
pm+1. Let t0 be the facet of t1 that does not contain pm+1. By Lemma 6.9, facet

178
6. Isosurface Generation in 4D
t0 ∈F ∗(τm)


t1 ∈F ∗(τm+1)

t′
0 ∈F ∗(τ ′
m)
 t′
1 ∈F ∗(τ ′
m+1)
(a)
t0


t1 = conv(t0 ∪pm+1)

t′
0 = t0 ∩g
 t′
1 = conv(t′
0 ∪pm+1)
and t′
1 = t1 ∩f
(b)
Figure 6.9.
(a) Triangulations τm and τm+1 are lexicographic triangulations of
conv(Pm) and conv(Pm+1), respectively. Triangulations τ ′
m and τ ′
m+1 are lexicographic
triangulations of conv(Pm ∩g) and conv(Pm+1 ∩f), respectively. (b) Simplices t1 and
t′
1 equal conv(t0 ∪pm+1) and conv(t′
0 ∪pm+1), respectively. Simplices t′
0 and t′
1 equal
t0 ∩g and t1 ∩f, respectively.
t0 is a simplex in F ∗(τm). Let t′
0 equal t0 ∩g. By the inductive assumption, t′
0
is in F ∗(τ ′
m). By Lemma 6.9, t′
1 = conv(t′
0 ∪pm+1) is in F ∗(τ ′
m+1). Since t1 ∩f
equals conv(t′
0 ∪{pm+1}), the simplex t1 ∩f equals t′
1. (See Figure 6.9.) This
proves that F ∗(τm+1) ∩f is a subset of F ∗(τ ′
m+1).
Conversely, let t′
1 be a simplex in F ∗(τ ′
m+1) containing pm+1. Let t′
0 be the
facet of t′
1 which does not contain pm+1. By Lemma 6.9, facet t′
0 is a simplex
in F ∗(τ ′
m).
By the inductive assumption, simplex t′
0 equals t0 ∩g for some
t0 ∈F ∗(τm). By Lemma 6.9, t1 = conv(t0 ∪pm+1) is a simplex of F ∗(τm+1).
Since t1∩f equals conv(t′
0∪{pm+1}), the simplex t1∩f equals t′
1. Thus F ∗(τ ′
m+1)
is a subset of F ∗(τm+1) ∩f.
Since F ∗(τm+1) ∩f is a subset of F ∗(τ ′
m+1) and F ∗(τ ′
m+1) is a subset of
F ∗(τm+1) ∩f, triangulation F ∗(τ ′
m+1) equals F ∗(τm+1) ∩f.
□
6.3.5
Proof of Isosurface Property 5
The Marching Hypercubes algorithm retrieves isosurface patches for a grid
hypercube c from the isosurface lookup table for the unit hypercube. The al-
gorithm then embeds those isosurface patches using linear interpolation on the
isosurface vertices. Isosurface patches in the lookup table are constructed by ap-
plying Algorithm IsoMid4D to the unit hypercube. In place of using the lookup
table, we could have constructed isosurface patches by applying IsoMid4D di-

6.3. Marching Hypercubes
179
Construct isosurface patches in each grid hypercube
using Algorithm IsoMid4D

Compute isosurface vertex coordinates using linear interpolation
Figure 6.10. Variation of Marching Hypercubes without a lookup table.
μ(c)
 T M+
μ(c)
μ−1

O
O
O
O
O
O
O
O
O
O
O
O
c
μ

 T M+
c
 ΣM+
c
(σ)
Figure 6.11. The Marching Hypercubes algorithm constructs the isosurface patch
ΣM+
c
(σ) by mapping cube c to μ(c), retrieving T M+
μ(c) from the isosurface lookup table
and mapping T M+
μ(c) to ΣM+
c
(σ) using linear interpolation. The isosurface patch ΣM+
c
(σ)
could be constructed directly from c by computing T M+
c
directly on c and then mapping
T M+
c
to ΣM+
c
(σ).
rectly to each grid hypercube c. (See Figure 6.10.) We argue that doing so would
give the exact same isosurface.
If μ : R4 →R4 is a translation in R4, then μ(conv(P)) equals conv(μ(P)) for
any point set P ⊆R4. Thus, μ(RM+
c
) equals RM+
μ(c) and μ(T M+
c
) equals T M+
μ(c).
Applying μ−1 to T M+
μ(c) gives a triangulation T M+
c
of SM+
c
, which is isomorphic
to T M+
μ(c). (See Figure 6.11.)
Marching Hypercubes embeds T M+
μ(c) in c using linear interpolation on
the isosurface vertices. The location of the isosurface vertices depends upon the
isovalue σ. Let ΣM+
c
(σ) (abbreviated ΣM+
c
) represent the resulting isosurface
patch for c.
Because T M+
μ(c) and T M+
c
are isomorphic, the algorithm could have constructed
ΣM+
c
from T M+
c
by reembedding T M+
c
in c using linear interpolation on its
vertices. Each vertex vi of T M+
c
is the midpoint mi of some edge ei. Vertex vi
is remapped to the interpolated point wi ∈ei. Map each vertex vi of T M+
c
to
(1 −α)vi + αwi. Linearly extend the mapping to each tetrahedron in T M+
c
.
The algorithm uses μ(c) to construct ΣM+
c
because it is faster to retrieve
the precomputed values of T M+
μ(c) from the lookup table than to compute T M+
c
.
However, for the proofs of Properties 5–8 we will view ΣM+
c
as a homotopy of
T M+
c
.

180
6. Isosurface Generation in 4D
To prove Property 5, it is necessary to show that there are no cracks between
isosurface patches in adjacent hypercubes. We ﬁrst show that for each cube c, set
|T M+
c
| separates the positive vertices of c from the negative ones (Corollary 6.14).
(|T M+
c
| represents the union of all the tetrahedra of T M+
c
.) We next show that
for two adjacent cubes, c1 and c2, region RM+
c1
and RM+
c2
agree on their adjacent
boundaries (Corollary 6.17). This implies that there are no “cracks” between
|T M+
c1
| and |T M+
c2
| in adjacent cubes and that 
c∈Γ |T M+
c
| separates the positive
vertices of Γ from the negative ones. We also show that the triangulations T M+
c1
and T M+
c2
agree on their adjacent boundaries, i.e., t1 ∩t2 is a face of t1 and a
face of t2 for every t1 ∈T M+
c1
and t2 ∈T M+
c2
(Lemma 6.18). Thus, 
c∈Γ T M+
c
is a triangulation (Lemma 6.22). We deﬁne a homotopy map η, which maps
this triangulation to the isosurface. Since this homotopy map does not cross
any vertices, the resulting isosurface separates the positive vertices of Γ from the
negative ones.
As previously noted, we present the lemmas in this section in the more general
setting of isosurface vertex sets instead of restricting the lemmas to the midpoints
of bipolar edges. Some of the lemmas apply only to isosurface vertex sets that
are proper, while others have no such restriction.
We start by showing that if Uc is a proper isosurface vertex set, then R+
c (Uc)
is four-dimensional.
Lemma 6.11. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set of c and at
least one vertex of c is positive, then R+
c (Uc) is a four-dimensional convex set.
Proof: Let v be a positive vertex of c. Since v is positive, some interior point of
every edge incident on v is in R+
c . Since there are at least four edges incident
on v and these edges are not contained in any three-dimensional subspace, R+
c
is four-dimensional. Since R+
c is the convex hull of the set Uc ∪V +
c , set R+
c is
convex.
□
Corollary 6.12. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set of c, then
R+
c (Uc) is either a four-dimensional convex set or the empty set.
Proof: By deﬁnition, points in Uc do not lie on negative edges of c. Thus, if V +
c
is empty, then Uc must also be empty. By Lemma 6.11, if V +
c is not empty, then
R+
c (Uc) is not empty.
□
Lemma 6.11 and its corollary require Uc to be proper. When Uc is an iso-
surface vertex set that is not proper, R+
c (Uc) can have any dimension from zero
to three.
Let c be a convex polytope in R4 where each vertex of c has a positive or
a negative label and let Uc be an isosurface vertex set (not necessarily proper)

6.3. Marching Hypercubes
181
of c. We deﬁne S+
c (Uc) (abbreviated S+
c ) to be the set that separates R+
c (Uc)
(abbreviated R+
c ) from cl(c −R+
c (Uc)):
S+
c (Uc) = R+
c (Uc) ∩cl(c −R+
c (Uc)).
In abbreviated form, S+
c is deﬁned as
S+
c = R+
c ∩cl(c −R+
c ).
(See Section 5.4.3 for a more detailed discussion of separation.)
Algorithm IsoMid4D in Section 6.2.3 returns a set of tetrahedra T M+
c
form-
ing an isosurface patch. The corollary to the following lemma shows that this
isosurface patch is exactly S+
c (Mc). Proofs of the lemma and its corollaries are
exactly the same as the proofs to Lemma 5.10 and its corollaries in Section 5.4.3
and are omitted.
Lemma 6.13. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label and let Uc be an isosurface vertex set of c. If R+
c (Uc)
has dimension four, then T +
c (Uc) is a triangulation of S+
c (Uc).
Corollary 6.14. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set, then T +
c (Uc)
is a triangulation of S+
c (Uc).
Corollary 6.15. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label. If Uc is a proper isosurface vertex set, then |T +
c (Uc)|
separates the positive vertices of c from the negative ones.
We next claim that if c1 and c2 are adjacent polytopes, then R+
c1 and R+
c2
agree on shared faces of c1 and c2. It will follow that there are no “cracks”
between adjacent isosurface patches.
We ﬁrst extend our deﬁnitions of Rc from c to the faces of c. Let c be a
convex polytope in R4 where each vertex of c has a positive or a negative label.
For each face f of c, let V +
f
be the set of positive vertices of f. Let Uf be the
points of Uc that lie on f. Let R+
f (Uf) (abbreviated as R+
f ) equal conv(Uf ∪V +
f ).
In these deﬁnitions, face f can have dimension 0, 1, 2, 3, or 4.
The proofs of the following lemma and its corollary are exactly the same as
the proofs of Lemma 5.14 and its corollary in Section 5.4.3 and are omitted.
Lemma 6.16. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label and let Uc be an isosurface vertex set of c. For every
face f of polytope c, R+
c (Uc) ∩f equals R+
f (Uc ∩f).
Corollary 6.17. Let c1 and c2 be adjacent convex polytopes in R4 where each ver-
tex of c1 and c2 has a positive or a negative label. Let Uc1 and Uc2 be isosurface
vertex sets of c1 and c2, respectively.
If f is a face of both c1 and c2, then
R+
c1(Uc1) ∩f equals R+
c2(Uc2) ∩f.

182
6. Isosurface Generation in 4D
In the statement of Lemma 6.16 and its corollary, face f can have dimensions
0, 1, 2, 3 or 4, although the four dimensional case is trivial.
Corollary 6.17 indicates that Rc1 and Rc2 agree on adjacent polytopes c1
and c2. We also need to show that triangulations Tc1 and Tc2 agree on their
adjacent boundaries.
Lemma 6.18. Let c1 and c2 be adjacent convex polytopes in R4 where each vertex
of c1 and c2 has a positive or a negative label. Let Uc1 and Uc2 be isosurface
vertex sets of c1 and c2, respectively, If t1 is a tetrahedron in T +
c1(Uc1) and t2 is
a tetrahedron in T +
c1(Uc2), then t1 ∩t2 is a face of t1 and a face of t2.
Proof: Let f equal c1 ∩c2, the grid face between c1 and c2. Let τ1 and τ2 be
the lexicographic triangulations of R+
c1 and R+
c2, respectively. By Lemma 6.10,
{t ∩f : t ∈τ1 and t ∩f ̸= ∅} equals the lexicographic triangulation τf of R+
f .
Similarly, {t ∩f : t ∈τ2 and t ∩f ̸= ∅} equals τf.
Let t1 and t2 be tetrahedra in T +
c1 and T +
c2, respectively. Since T +
c1 is a subset
of τ1, t1 ∩f is a face g1 in τf. Since T +
c2 is a subset of τ2, t1 ∩f is a face g2 in
τf. Since τf is a triangulation, the intersection g1 ∩g2 is a face of g1 and a face
of g2. Since g1 ∩g2 equals t1 ∩t2 and g1 is a face of t1 and g2 is a face of t2,
the intersection t1 ∩t2 is a face of t1 and a face of t2.
□
In the statement of Lemma 6.18, f is a proper face of c and can have dimen-
sions 0, 1, 2, or 3. Note that Lemmas 6.16 and 6.18 and their corollaries do not
require that isosurface vertex sets Uc or Uc1 or Uc2 be proper.
For a convex polytopal mesh Γ, let U be an isosurface vertex set for Γ, and
let Uc equals c ∩U for each polytope c ∈Γ. Note that Uc is an isosurface vertex
set for c and that if U is proper, then each Uc is proper.
Deﬁne MΓ, ΣM+
Γ
(σ), T +
Γ (U), R+
Γ (U) and S+
Γ (U) as
MΓ
=

c∈Γ
Mc,
ΣM+
Γ
(σ)
=

c∈Γ
ΣM+
c
(σ),
T +
Γ (U)
=

c∈Γ
T +
c (Uc),
R+
Γ (U)
=

c∈Γ
R+
c (Uc),
S+
Γ (U)
=
R+
Γ (U) ∩cl(|Γ| −R+
Γ (U)).
Set |Γ| is the union of all the elements of mesh Γ. Abbreviate ΣM+
Γ
(σ), T +
Γ (U),
R+
Γ (U) and S+
Γ (U) as ΣM+
Γ
, T +
Γ , R+
Γ , and S+
Γ , respectively. Abbreviate T +
Γ (MΓ)
and S+
Γ (MΓ) as T M+
Γ
and SM+
Γ
. Note that S+
Γ separates R+
Γ from |Γ|−R+
Γ . (See
Lemma B.8 in Appendix B.)

6.3. Marching Hypercubes
183
We claim that S+
Γ (U) equals 
c∈Γ S+
c (U ∩c) if U is a proper isosurface vertex
set. The proofs of the lemma and its two corollaries are exactly the same as the
proof of Lemma 5.18 and its corollaries in Section 5.4.3 and are omitted.
Lemma 6.19. Let Γ be a convex polytopal mesh in R4 where each vertex of Γ has
a positive or negative label. If U is a proper isosurface vertex set of Γ, then set
S+
Γ (U) equals 
c∈Γ S+
c (U ∩c).
Corollary 6.20. Let Γ be a convex polytopal mesh in R4 where each vertex of Γ
has a positive or negative label. If U is a proper isosurface vertex set of Γ, then
|T +
Γ (U)| equals S+
Γ (U).
Corollary 6.21. Let Γ be a convex polytopal mesh in R4 where each vertex of Γ
has a positive or negative label. If U is a proper isosurface vertex set of Γ, then
|T +
Γ (U)| separates the positive vertices of Γ from the negative ones.
T +
Γ (U) is deﬁned as 
c∈Γ T +
c (Uc), the union of sets of tetrahedra.
Each
T +
c (Uc) is a subset of a triangulation of the boundary of R+
c (Uc), so each T +
c (Uc)
is itself a triangulation. The following lemma claims that T +
Γ (U) is a triangu-
lation of S+
Γ (U). The proof is exactly the same as the proof of Lemma 5.21 in
Section 5.4.3 and is omitted.
Lemma 6.22. Let Γ be a convex polytopal mesh in R4 where each vertex of Γ has
a positive or negative label. If U is a proper isosurface vertex set of Γ, then
T +
Γ (U) is a triangulation of S+
Γ (U).
MΓ is the set of all midpoints of bipolar edges of Γ. Since T +
Γ (MΓ) (abbre-
viated T M+
Γ
) is a triangulation of S+
Γ (MΓ) (abbreviated SM+
Γ
), the homotopy
η can be extended to all of SM+
Γ
. Each vertex vi of T M+
Γ
is the midpoint mi
of some edge ei. Vertex vi is remapped to the interpolated point wi ∈ei. For
each vertex vi of T M+
Γ
, deﬁne η(vi, α) as (1 −α)vi + αwi. Extend η to all of
SM+
Γ
by linearly extending η on each tetrahedron in T M+
Γ
. Because T M+
Γ
is a
triangulation of SM+
Γ
, homotopy η is well-deﬁned on every point of SM+
Γ
. Thus
η : SM+
Γ
× [0, 1] is a homotopy from SM+
Γ
to ΣM+
Γ
(σ) where η(SM+
Γ
, 0) equals
SM+
Γ
and η(SM+
Γ
, 1) equals ΣM+
Γ
(σ).
Our last lemma shows that ΣM+
Γ
does not contain mesh vertices whose
scalar values do not equal the isovalue.
The proof is the same as the proof
of Lemma 5.22 in Section 5.4.3 and is omitted.
Lemma 6.23. Let Γ be a convex polytopal mesh in R4 where each vertex of Γ has
a scalar value. If v is a vertex of Γ whose scalar value does not equal σ ∈R,
then ΣM+
Γ
(σ) does not contain v.
Applying Corollary 6.21, the homotopy map η, and Lemma 6.23 gives Prop-
erty 5.

184
6. Isosurface Generation in 4D
Property 5.
The isosurface separates positive grid vertices from negative ones
and strictly separates strictly positive grid vertices from negative grid vertices.
Proof: By Corollary 6.21, set |T M+
Γ
| strictly separates the positive vertices of
Γ from the negative ones. Map η is a homotopy map from SM+
Γ
to ΣM+
Γ
(σ)
that never passes through any vertices of Γ. Vertices of SM+
Γ
that lie on the
boundary of |Γ| remain on the boundary of |Γ| throughout the homotopy η.
Thus η(SM+
Γ
) ∩∂|Γ|, α) is a subset of ∂|Γ| for all α ∈[0, 1]. By Lemma B.18,
ΣM+
Γ
(σ) separates the positive vertices of Γ from the negative ones.
By Lemma 6.23, ΣM+
Γ
(σ) does not contain any mesh vertices whose scalar
values equal the isovalue σ. Therefore, ΣM+
Γ
(σ) strictly separates vertices with
scalar values greater than σ from vertices with scalar value less than σ.
□
6.3.6
Proof of Isosurface Properties 6, 7, and 8
Property 6 states that if no grid scalar value equals the isovalue, then ΣM+
Γ
(σ)
is a manifold.
To prove this property we ﬁrst show that if Uc1 and Uc2 are
proper, then S+
c1(Uc1) and S+
c2(Uc2) agree on shared faces of c1 and c2 (Corol-
lary 6.26). (We already established in Section 6.3.5, Corollary 6.17, that R+
c1(Uc1)
and R+
c2(Uc2) agree on shared faces of c1 and c2.) We next show that for every
point p ∈S+
Γ (MΓ) there is a hyperplane h containing p such that the orthogo-
nal projection of S+
Γ (MΓ) ∩Np onto h is one-to-one for some suﬃciently small
neighborhood Np of p (Lemma 6.30). From this we show that S+
Γ (MΓ) is an
orientable 3-manifold with boundary (Lemma 6.31). Since the mapping from
S+
Γ (MΓ) to ΣM+
Γ
is one-to-one and onto, ΣM+
Γ
is also an orientable 3-manifold
with boundary.
We start by extending the deﬁnition of Sc from c to faces of c. Let f be a face
of c. As in Section 5.4.3, set V +
f
is the set of positive vertices of f, set Uf is the
points of Uc that lie on f, and R+
f (Uf) (abbreviated R+
f ) equals conv(Uf ∪V +
f ).
Deﬁne S+
f (Uf) (abbreviated S+
f ) as
S+
f (Uf) = R+
f (Uf) ∩cl(f −R+
f (Uf)).
As in Section 6.3.5, face f need not be three-dimensional.
Lemma 6.16 shows that R+
c ∩c equals R+
f . We claim a similar lemma holds
for the complements of R+
c and R+
f . Proofs of Lemma 6.24 and Lemma 6.25
and its corollary are the same as the proofs of Lemma 5.23 and Lemma 5.24 in
Section 5.4.4 and are omitted.
Lemma 6.24. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label and let Uc be a proper isosurface vertex set of c. For
every face f of polytope c, cl(c −R+
c (Uc)) ∩f equals cl(f −R+
f (Uc ∩f)).

6.3. Marching Hypercubes
185
Lemma 6.25. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label and let Uc be a proper isosurface vertex set of c. For
every face f of polytope c, S+
c (Uc) ∩f equals S+
f (Uc ∩f).
Corollary 6.26. Let c1 and c2 be adjacent convex polytopes in R4 where each ver-
tex of c1 and c2 has a positive or a negative label. Let Uc1 and Uc2 be isosurface
vertex sets for c1 and c2, respectively, where Uc1 ∩f equals Uc2 ∩f. If Uc1 and
Uc2 are proper isosurface vertex sets, then S+
c1(Uc1) ∩f equals S+
c2(Uc2) ∩f.
Lemma 6.25 and its corollary require that the isosurface vertex sets be proper.
To prove Properties 6 and 7, we prove that if isosurface vertex set U is proper,
then S+
Γ (U) is a piecewise linear, orientable 3-manifold whose boundary lies on
∂|Γ|.
In R3, we proved that S+
Γ is a manifold whose boundary lies on ∂|Γ|. We did
this by case analysis of the intersection of S+
Γ and edges, facets, and interiors of
grid cubes. In R4, this case analysis becomes rather diﬃcult. Instead, for each
point p ∈S+
Γ , we construct a hyperplane hp such that for some neighborhood
Np of p in S+
Γ the orthogonal projection onto hp is a homeomorphism from Np
to hp ∩Bp ∩|Γ| for some suﬃciently small ball Bp around p. Since hp ∩Bp ∩|Γ|
is homeomorphic to R3 or a half-space in R3, we have a homeomorphism from
Np to R3 or a half-space in R3.
Lemma 6.11 established that if Uc is a proper isosurface vertex set then
R+
c (Uc) is four-dimensional. We need a similar lemma about R+
c ∩f for each
face f of c.
Lemma 6.27. Let c be a convex polytope in R4 where each vertex of c has a
positive or a negative label and let f be a j-dimensional face of c. If Uc is a
proper isosurface vertex set of c and at least one vertex of f is positive, then
R+
c ∩f has dimension j.
Proof: Let v be a positive vertex of f. Since v is positive, some point of Uc lies
on the interior of every edge incident on v. There are at least j edges incident on
v and contained in f. Since these edges are edges of f, they span a j-dimensional
space. Thus the convex hull of (Uc ∩f) ∪v has dimension j. Since R+
f (Uc ∩f)
contains that convex hull, R+
f (Uc ∩f) is j-dimensional. By Lemma 6.16, set
R+
c ∩f equals R+
f (Uc ∩f), so R+
c ∩f is j-dimensional.
□
By Lemma 6.11, set R+
f
has the same dimension as f. The relative interior
of R+
f , denoted relint(R+
f ), is the interior of R+
f when R+
f is considered as a j-
dimensional set lying in Rj. (See Section B.1 in Appendix B for a more rigorous
discussion and deﬁnition.) We prove that if p and p′ are points in R+
f and at
least one of these points is in relint(R+
f ), then the open line segment (p, p′) does
not intersect S+
f . (See Figure 6.12(a).)
Lemma 6.28. Let c be a convex polytope in R4 where each vertex of c has a
positive or negative label, let f be a face of c, let Uc be a proper isosurface vertex

186
6. Isosurface Generation in 4D
p
p′
p
p′
(a)
(b)
Figure 6.12. Red region is R+
f
and the green line segments are S+
f . Point p′ is in
relint(R+
f ). (a) Point p is in R+
f . The open line segment (p, p′) does not intersect S+
f .
(b) Point p is in f −R+
f . The open line segment (p, p′) intersects S+
f
at exactly one
point.
set of c, and let Uf equal Uc ∩f. If p is in R+
f (Uf) and p′ is in relint(R+
f (Uf)),
then open line segment (p, p′) does not intersect S+
f (Uf).
Proof: Since p′ is in relint(R+
f ), some open neighborhood Np′ of p′ in f is con-
tained in relint(R+
f ). The convex hull of Np′ ∪{p} is contained in R+
f . Since
open line segment (p, p′) is a subset of relint(conv(Np′ ∪{p})), open line segment
(p, p′) is a subset of relint(R+
f ). Thus (p, p′) ∩cl(f −R+
f ) is the empty set. Since
S+
f is a subset of cl(f −R+
f ), set (p, p′) ∩S+
f is also the empty set.
□
The following corollary gives a condition for line segment (p, p′) to intersect
S+
f at exactly one point.
Corollary 6.29. Let c be a convex polytope in R4 where each vertex of c has a
positive or negative label, let f be a face of c, let Uc be a proper isosurface vertex
set of c and let Uf equal Uc ∩f. If p is a point in f −R+
f (Uf) and p′ is in
relint(R+
f (Uf)), then open line segment (p, p′) intersects S+
f (Uf) at one and only
one point.
Proof: Assume p is in f −R+
f . Since p′ ∈relint(R+
f ) and p ∈f −R+
f , open line
segment (p, p′) intersects R+
f ∩cl(f −R+
f ) = S+
f . Thus (p, p′) intersects S+
f
at
least at one point q.
Assume that (p, p′) intersected S+
f
at two points q and q′. Without loss of
generality, assume that the points on (p, p′) lie in the order p, q, q′, p′. Since q
is in S+
f , point q is in R+
f . By Lemma 6.28, open line segment (q, p′) does not
intersect S+
f . However, q′ is in (q, p′) and in S+
f , a contradiction. Thus (p, p′)
intersects S+
f at exactly one point.
□
Corollary 6.29 is illustrated in Figure 6.12(b).

6.3. Marching Hypercubes
187
p
p′
p′′
h
L
Figure 6.13. Red region is R+
f and the green line segments are S+
f . Point p is on S+
f ,
point p′ is in relint(R+
f ), and point p′′ is in f −relint(R+
f ). Line L passes through
points p, p′, and p′′. The hyperplane h is orthogonal to L. Only a one-dimensional
cross section of h is shown in the ﬁgure.
Let p be a point in S+
c and let h be a hyperplane containing p. Under appro-
priate conditions, the orthogonal projection of R4 onto h is a homeomorphism
of some neighborhood of p in S+
c to some neighborhood of p in h ∩c.
Lemma 6.30. Let c be a convex polytope in R4 where each vertex of c has a
positive or negative label, let f be a face of c, let Uc be a proper isosurface vertex
set of c, and let Uf equal Uc ∩f. Let p be a point in S+
f (Uf) ∩relint(f), let p′ be
a point in relint(R+
f (Uf)), and let h be a hyperplane containing p and orthogonal
to the line through p and p′. If π : R4 →h is the orthogonal projection of R4
onto a hyperplane h, then there is some neighborhood Np of p in S+
c (Uc) such
that π restricted to Np is a homeomorphism from Np to some neighborhood of p
in h ∩c.
Proof: By Corollary 6.7, point p does not lie on a vertex of Γ. Let j ≥1 be the
dimension of f. By Lemma 6.27, R+
c ∩f is j-dimensional. By Lemma 6.16, R+
f
is also j-dimensional.
Let L be the line through p and p′. Since point p is in relint(f), there is a
point p′′ ∈relint(f)∩L such that p lies on line segment (p′, p′′). (See Figure 6.13.)
By Lemma 6.28, p′′ is not in R+
f or else p would not be in S+
f . Since R+
f is a
closed set, some open neighborhood of p′′ in f does not intersect R+
f .
Let Bp, Bp′, and Bp′′ be open balls in R4 around p, p′, and p′′, respectively,
such that
• Bp, Bp′, and Bp′′ have the same radius;
• Bp′ ∩c is contained in R+
c ;
• Bp′′ ∩c does not intersect R+
c .

188
6. Isosurface Generation in 4D
Let A equal conv(Bp′, Bp′′). Set S+
c ∩A is a neighborhood of p in S+
c . Set
h ∩Bp ∩c is a neighborhood of p in h ∩c. Projection π maps S+
c ∩A into
h ∩Bp ∩c. We claim that π restricted to S+
c ∩A is a homeomorphism from
S+
c ∩A to h ∩Bp ∩c.
Let q be a point on S+
c ∩A. Let Lq be the line parallel to L passing through
q. Line Lq intersects Bp′ at some point q′ and intersects Bp′′ at some point q′′.
By Corollary 6.29, line segment (q′, q′′) intersects S+
c at only one point. Thus π
restricted to S+
c ∩A is a one-to-one mapping of S+
c ∩A into h ∩Bp ∩c.
Now, let ˜q be a point in h ∩Bp ∩c. Let L˜q be the line parallel to L passing
through ˜q, let q′ be a point in Lq ∩Bp′ ∩c, and let q′′ be a point in Lq ∩Bp′′ ∩c.
Point ˜q lies in the relative interior of some face g of c (where g may equal c.)
Points q′ and q′′ must also lie on g. By Corollary 6.29, line segment (q′, q′′)
intersects S+
g at exactly one point q. Thus π(S+
c ∩A) covers h ∩Bp ∩c. Since
π restricted to S+
c ∩A is continuous and the inverse mapping taking h ∩Bp ∩c
to S+
c ∩A is also continuous, π restricted to S+
c ∩A is a homeomorphism from
S+
c ∩A to to h ∩Bp ∩c.
□
Lemma 6.31. Let Γ be a regular grid where each vertex of Γ has a positive or
negative label. Set S+
Γ is a piecewise linear, orientable 3-manifold whose boundary
lies on ∂|Γ|.
Proof: Let p be a point on S+
Γ . Point p lies in the interior of some face f of Γ. By
Corollary 6.8, point p does not lie on a vertex of Γ. Let j ≥1 be the dimension
of f. By Lemma 6.27, R+
Γ ∩f is j-dimensional.
Let p′ be a point in the relative interior of R+
f . By Lemma 6.25, S+
Γ ∩f equals
S+
f . Since point p′ is not in S+
f , point p′ cannot be in S+
Γ .
Let L be the line through points p and p′, and let h be a hyperplane orthog-
onal to L. Let π : R4 →h be the orthogonal projection of R4 onto h.
By Lemma 6.30, for each hypercube c containing f there is a neighborhood
Np,c of p in S+
c such that π restricted to Np,c is a homeomorphism from Np,c to
some neighborhood of p in h∩c. Choose some neighborhood Np of p in S+
Γ , such
that Np ∩c is a subset of Np,c for each c containing f. By Lemma 6.25, S+
c ∩f
equals S+
c′ ∩f for every pair of hypercubes c, c′ containing f. Thus, mapping
π restricted to Np is a continuous, one-to-one, and onto mapping from Np to
some neighborhood N′
p of p in h ∩|Γ|. Since the inverse mapping from N′
p is also
continuous, π restricted to Np is a homeomorphism from the neighborhood Np
of p in S+
p to some neighborhood N′
p of p in h ∩|Γ|.
Let Bp be a small four-dimensional ball around p such that Bp ∩h ∩|Γ| is a
subset of N′
p. If p is in the interior of |Γ|, then set Bp ∩h ∩|Γ| is homeomorphic
to R3. If p is on the boundary of |Γ|, then set Bp ∩h ∩|Γ| is homeomorphic to
a half-space in R3. Thus some neighborhood of p in S+
Γ is homeomorphic to R3
or a half-space of R3, and this neighborhood is homeomorphic to a half-space of
R3 if and only if p is on the boundary of |Γ|. It follows that S+
Γ is a manifold
with boundary, and the boundary of S+
Γ lies on the boundary of |Γ|.

6.3. Marching Hypercubes
189
By Lemma 6.22, set Υ is a triangulation of ΣM+
Γ
. The tetrahedra in Υ are
oriented so that their induced normals point toward the positive region. Thus,
their orientation is consistent and ΣM+
Γ
is orientable.
□
Since T +
Γ is a triangulation of S+
Γ , the isosurface Σ+
Γ is the image of S+
Γ under
a continuous, piecewise linear mapping. Thus isosurface Σ+
Γ is an embedding of
S+
Γ into |Γ|. If S+
Γ is an orientable 3-manifold with boundary and this embedding
is one-to-one, then Σ+
Γ is also an orientable 3-manifold with boundary. However,
as in R3, the mapping from S+
Γ to Σ+
Γ may not be one-to-one. We claim that if
c is a hypercube in R4, then the embedding is one-to-one.
Lemma 6.32. If c is a hypercube in R4 with scalar values at its vertices such
that no vertex value equals the isovalue, then the mapping from S+
c to Σ+
c is
one-to-one.
The proof for Lemma 6.32 is a computer-based case analysis and is omitted.
Property 6.
The isosurface is a piecewise linear, orientable 3-manifold with
boundary.
Property 7.
The boundary of the isosurface lies on the boundary of the grid.
Proof of Properties 6 & 7: By Lemma 6.31, the set S+
Γ (MΓ) (abbreviated S+
Γ ) is
a piecewise linear 3-manifold with boundary whose boundary lies on ∂|Γ|. Set
ΣM+
Γ
(σ) (abbreviated ΣM+
Γ
) is an embedding of S+
Γ into |Γ|. We claim that this
embedding is one-to-one.
Let p be some point in ΣM+
Γ
. Since no grid vertex value equals the isovalue,
set ΣM+
Γ
does not contain any grid vertices (Lemma 6.23). Moreover, any point
of ΣM+
Γ
on a grid edge e is the image e ∩S+
Γ , which can only be the midpoint of
e. Thus, if p lies on a grid edge e, then it is the image of only one point in S+
Γ .
Assume p ∈ΣM+
Γ
is on the interior of some hypercube c. By Lemma 6.32,
the mapping from S+
c to Σ+
c is one-to-one. Since only points in S+
c map to the
interior of c, point p is the image of only one point in ΣM+
Γ
.
Assume p ∈ΣM+
Γ
is in the interior of some proper grid face f. By Lemma 6.32,
the mapping from S+
c to Σ+
c is one-to-one for each hypercube c containing f.
Thus, the mapping from S+
c ∩f to Σ+
c is one-to-one. By Lemma 6.25, S+
c ∩f
equals S+
c′ ∩f for each pair of hypercubes c, c′ containing f. Since only points
in ΣM+
Γ
∩f map to f, only points in hypercubes containing f map to f. Thus,
point p is the image of only one point in ΣM+
Γ
.
Since the mapping from ΣM+
Γ
to ΣM+
Γ
is one-to-one and ΣM+
Γ
is an orientable
3-manifold with boundary, set ΣM+
Γ
is an orientable 3-manifold with boundary.
Since ∂ΣM+
Γ
lies on ∂|Γ| and all points on ∂ΣM+
Γ
∩∂|Γ| are mapped to ∂|Γ|, the
boundary of ΣM+
Γ
also lies on ∂|Γ|.
□
The last property is that Υ does not contain any zero-volume or duplicate
tetrahedra and forms a triangulation of the isosurface.

190
6. Isosurface Generation in 4D
Property 8.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra, and the tetrahedra in Υ form a triangulation of the isosurface.
Proof: Since no grid vertex has scalar value equal to the isovalue, no isosurface
vertex lies on a grid vertex. By Property 3, each bipolar grid edge contains only
one isosurface vertex. Thus, the linear interpolation on isosurface vertices does
not create any zero-volume or duplicate isosurface tetrahedra.
Set Υ is the image of T +
Γ under the embedding that takes S+
Γ to ΣM+
Γ
. Since
this embedding is one-to-one and T +
Γ deﬁnes a triangulation of S+
Γ (Lemma 6.22),
set Υ is a triangulation of ΣM+
Γ
.
□
6.4
Marching Simplices
A four-dimensional simplex is called a 4-simplex. A modiﬁed version of March-
ing Hypercubes constructs an isosurface in a four-dimensional mesh composed
of 4-simplices. The basic idea follows the Marching Hypercubes algorithm.
An isosurface lookup table is built on a “generic” simplex, cS, in R4. Each sim-
plex in the simplicial mesh is mapped to cS, the isosurface patch is retrieved
from the lookup table, and the vertices of the isosurface patch are positioned us-
ing linear interpolation on the mesh edges. The algorithm is called Marching
Simplices.
As with Marching Hypercubes, it is extremely important that the tri-
angulation of one isosurface patch match the triangulation of an adjacent one.
This can also be a problem for a simplicial mesh. The facet of a 4-simplex is a
3-simplex. If two of the vertices of that 3-simplex are positive and two are nega-
tive, then the intersection of the isosurface and that 3-simplex has four vertices
and two triangles. If two adjacent 4-simplices, c and c′, share such a common 3-
simplex, then the two triangles generated for c should be the same two triangles
generated for c′. This may or may not happen depending upon the mapping of
c and c′ to the “generic” simplex cS.
The Marching Hypercubes algorithm translates each grid cube to the unit
hypercube. The lookup table for the unit hypercube contains lexicographic trian-
gulations of the isosurface patches. These lexicographic triangulations translate
to lexicographic triangulations of isosurface patches in the mesh element. Since
the lexicographic triangulations of two adjacent isosurface patches agree on their
common boundaries, the resulting set of tetrahedra form a triangulation of the
isosurface. Positioning the isosurface vertices changes the surface geometry but
preserves the triangulation.
The problem with using lexicographic triangulations for simplices is that the
mapping of a mesh simplex to cS is often not a translation but some other aﬃne
transformation. Aﬃne transformations do not preserve the lexicographic order

6.4. Marching Simplices
191
of points. Moreover, even an aﬃne transformation of a simplex that preserves
the lexicographic order of the simplex vertices may not preserve the lexicographic
order of midpoints of simplex edges. We introduce a new type of triangulation,
called incremental triangulations, to handle these problems.
6.4.1
Incremental Triangulation
Let (p1, . . . , pm) be a sequence of points in Rd and let conv(p1, . . . , pm) be the
convex hull of set {p1, p2, . . . , pm}. If τ is a triangulation and p is a vertex of
some simplex in τ, then τ −{p} is the set of simplices in F ∗(τ) that do not
contain vertex p. (set F ∗(τ) is the set τ and all faces of elements of τ.)
Deﬁnition 6.33. Triangulation τ is an incremental triangulation of convex set
conv(p1, . . . , pm) induced by the sequence (p1, . . . , pm) if
• triangulation τ is a single vertex, or
• set τ −{pm} is an incremental triangulation of conv(p1, . . . , pm−1) induced
by the sequence (p1, . . . , pm−1).
Note that diﬀerent sequences may induce diﬀerent incremental triangulations.
The lexicographic triangulation of conv(p1, . . . , pm) is an incremental triangula-
tion of conv(p1, . . . , pm) induced by the lexicographic order of {p1, . . . , pm}.
The dimension of conv(p1, . . . , pm) may be k < d, in which case the largest
simplices in τ are k-simplices. Also, the dimension of conv(p1, . . . , pm−1) may be
less than the dimension of conv(p1, . . . , pm). Thus, even if τ contains k-simplices,
the largest simplices in τ −pm could be (k −1)-simplices.
The two properties of lexicographic triangulations given in Section 6.3.4 also
apply to incremental triangulations. The proofs of the following two lemmas are
exactly the same as the proofs of Lemmas 6.9 and 6.10 and are omitted.
Lemma 6.34. If (p1, . . . , pm) is a sequence of points in Rd, and if τ and τ ′
are incremental triangulations of conv(p1, p2, . . . , pm) induced by the sequence
(p1, p2, . . . , pm), then F ∗(τ) equals F ∗(τ ′).
Lemma 6.35. Let (p1, . . . , pm) be a sequence of points in Rd, let f be a face
of conv(P), and let (q1, q2, . . . , qk) be the subsequence of (p1, . . . , pm) consist-
ing of points in f. If τ is an incremental triangulation of conv(P) induced by
(p1, p2, . . . , pm), and τ ′ is an incremental triangulation of conv(P ∩f) induced
by (q1, q2, . . . , qk), then F ∗(τ) ∩f equals F ∗(τ ′).
Incremental triangulations are so named because they are the triangulations
constructed by the Incremental Convex Hull algorithm described in Sec-
tion 6.2.2. If the Incremental Convex Hull algorithm processes the sequence
of points (p1, . . . , pm) in the given order, then the algorithm returns the incre-
mental triangulation of conv(p1, . . . , pm) induced by the sequence (p1, . . . , pm).

192
6. Isosurface Generation in 4D
6.4.2
Induced Order of Edges
An ordering of polytope vertices induces an ordering on the polytope edges. This
ordering will be used to determine the incremental triangulation of isosurface
patches.
Let ZP be a sequence of points.
Let E be a set of line segments whose
endpoints are the points in ZP . Let e = (p, q) and e′ = (p′, q′) be line segments in
E where p ≺q and p′ ≺q′ in ZP . Line segment e = (p, q) precedes e′ = (p′, q′) if
• p ≺p′ in ZP , or
• p = p′ and q ≺q′ in ZP .
Denote “e precedes e′” by e ≺e′. The ordering of E induced by ZP is (e1, e2, . . . , ek)
where ei ≺ei+1 for i = 1, . . . , k −1.
Since polytope vertices are points and polytope edges are line segments, an
order on polytope vertices induces an order on the polytope edges.
6.4.3
Isosurface Patch Construction
We present an algorithm, IsoPoly4D, that constructs isosurface patches in any
(bounded) four-dimensional convex polytope, not just a simplex. The algorithm
is similar to Algorithm IsoMid4D in Section 6.2.3 but it uses incremental trian-
gulations. Input to IsoPoly4D includes an order on the polytope vertices that
determines the sequence inducing the incremental triangulation. IsoPoly4D
also uses proper isosurface vertex sets in place of edge midpoints. While the ap-
plication of IsoPoly4D is restricted to edge midpoints in this chapter, we will
use IsoPoly4D on other isosurface vertex sets in constructing interval volumes
in Chapter 7.
Let c be a polytope in R4 where each vertex of c has a positive or a negative
label. The vertices of c are ordered. Let Uc be a proper isosurface vertex set of
c. We show how to construct an isosurface patch in c using set Uc as its vertices.
Let V +
c be the vertices of c with positive labels and let V −
c be the vertices with
negative labels. Let R+
c (Uc) equal conv(Uc ∪V +
c ), the convex hull of Uc ∪V +
c .
Set R+
c (Uc) has a three-dimensional boundary denoted ∂R+
c (Uc).
To build an incremental triangulation of ∂R+
c , we must ﬁx an order for Uc ∪
V +
c . The order of V +
c is simply given by the order on the vertices of c. The order
of Uc corresponds to the order on the bipolar edges induced by the order on the
vertices of c. More formally, let Z+
V be the sequence of positive vertices, V +
c ,
whose order matches the input order. Let ZE be the sequence of bipolar edges
of c whose order is induced by the input order on c’s vertices. Each ue ∈Uc lies
on some bipolar edge e of c. Let ZU be the sequence (ue1, ue2, . . . , uek) where ei
is the ith element of ZE. Let Z+ be the sequence Z+
V ◦ZU, the concatenation
of Z+
V with ZU.

6.4. Marching Simplices
193
Construct the convex hull of the positive vertices
and proper isosurface vertex set Uc

Z+
V ←Sequence of positive vertices in order
ZE ←Sequence of bipolar edges in order induced by the vertex order
ZU ←(ue1, ue2, . . . , uek) where uei is the element of Uc on ei and
ei is the ith element of ZE

Construct an incremental triangulation induced by Z+
V ◦ZU
of the convex hull boundary

Remove tetrahedra on the polytope boundary
Figure 6.14. Algorithm IsoPoly4D for construction of isosurface patches from proper
isosurface set Uc. Input includes an order on the vertices of c. Algorithm IsoPoly4D
produces an incremental triangulation of the surface patch.
Construct R+
c (Uc) and the incremental triangulation induced by sequence
Z+ of ∂R+
c (Uc). Let T +
c (Uc) be the set of tetrahedra in this triangulation that
do not lie on facets of c. Orient the tetrahedra in this triangulation so that
the induced normals point toward R+
c (Uc). Although some of the vertices of
∂R+
c (Uc) are from the set V +
c , none of the vertices of T +
c
are from this set.
The tetrahedra in T +
c (Uc) form the triangulated isosurface patch whose vertices
are Uc. This isosurface patch separates the positive vertices from the negative
vertices of c.
We call the algorithm IsoPoly4D. Algorithm IsoPoly4D is presented in
Figure 6.14.
The combinatorial structure of the isosurface within c is determined from the
conﬁguration of the polytope’s vertex labels. The isosurface does not intersect
any edge whose endpoints have the same label.
One could use R−
c (Uc) = conv(Uc ∪V −
c ) instead of R+
c (Uc). Let Z−
V be the
sequence of negative vertices whose order matches the input order and let Z−be
Z−
V ◦ZU. Construct an incremental triangulation of ∂R−
c (Uc) induced by Z−,
and let T −
c (Uc) be the set of tetrahedra of that triangulation that does not lie
on facets of c. The tetrahedra in T −
c (Uc) form an alternate isosurface patch for
c with vertices Uc.

194
6. Isosurface Generation in 4D
6.4.4
Isosurface Table Construction
Let c be a convex polytope in R4. Let n be the number of vertices of c. In the
isosurface extraction algorithm, the n vertices of c receive positive and negative
labels representing their relationship to the isovalue. A vertex that has scalar
value below the isovalue will receive a negative label, “−”. A vertex with scalar
value above or equal to the isovalue receives a positive label, “+”.
Since each vertex is either positive or negative, there are 2n conﬁgurations
of positive and negative vertex labels. The isosurface lookup table contains 2n
entries, one for each conﬁguration κ. Each entry is a list of quadruples of bipolar
edges of c.
Each quadruple (e1, e2, e3, e4) represents an oriented tetrahedron
whose vertices lie on e1 and e2 and e3 and e4. The list of quadruples deﬁne the
combinatorial structure of the isosurface patch for conﬁguration κ. Let M κ
c be
the midpoints of the bipolar edges for conﬁguration κ. Lexicographically sort the
vertices of c. Construct the isosurface patch by applying Algorithm IsoPoly4D
to the isosurface vertex set M κ
c . The tetrahedra in this isosurface patch are the
set T +
c (M κ
c ). The isosurface patch intersects every bipolar edge of c exactly once
and does not intersect any other edges of c.
6.4.5
Algorithm
Input to the Marching Simplices algorithm is an isovalue, a four-dimensional
simplicial mesh and a set of scalar values at the vertices of the mesh. The al-
gorithm has three steps. (See Figure 6.15.) Read the isosurface lookup table
from a preconstructed data ﬁle. For each simplex, retrieve from the lookup ta-
ble a set of isosurface tetrahedra representing the combinatorial structure of the
isosurface. The vertices of these tetrahedra form the isosurface vertices. As-
sign geometric locations to the isosurface vertices based on the scalar values at
the simplex endpoints.
The basic algorithm is the same as Marching Hy-
percubes. The diﬀerences are in the construction of the lookup table using
IsoPoly4D and in the retrieval of the isosurface tetrahedra from the lookup
table.
The isosurface lookup table is built on a “generic” 4-simplex cS with vertices
and vertex order
(0, 0, 0, 0), (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1).
Any other 4-simplex or any other order on the vertices could also have been
used. Algorithm IsoPoly4D is applied to each of the 25 = 32 conﬁgurations of
positive and negative vertex labels to generate 32 isosurface patches in 32 table
entries.
For each mesh simplex c, the isosurface patch triangulation retrieved from
the lookup table depends on how the simplex is mapped to cS. There are 4! ways

6.4. Marching Simplices
195
Read 4-simplex isosurface lookup table

For each mesh simplex, retrieve isosurface tetrahedra

Compute isosurface vertex coordinates using linear interpolation
Figure 6.15. Marching Simplices.
to map the vertices of c to cS. Each such mapping represents a diﬀerent aﬃne
transformation of c to cS. However, only one such mapping preserves the lex-
icographic order of the vertices. If v1, v2, v3, v4, and v5 are the vertices of c in
lexicographic order, then map vertex v1 to (0, 0, 0, 0), vertex v2 to (1, 0, 0, 0),
vertex v3 to (0, 1, 0, 0), vertex v4 to (0, 0, 1, 0), and vertex v5 to (0, 0, 0, 1). This
mapping sends the ith vertex of c in lexicographic order to the ith vertex of cS
in lexicographic order.
Consider two adjacent mesh simplices c and c′ sharing a common face f. Sort
the vertices of c and c′ in lexicographical order. Let Z+
c and Z+
c′ be the sequence
of positive vertices and midpoints of bipolar edges of c and c′, respectively,
as described in Section 6.4.3.
Restricted to face f, the subsequence Z+
c ∩f
equals Z+
c′ ∩f. Because the mapping of c to cS preserves the lexicographic order
of vertices of c, the triangulation retrieved from the lookup table for c is an
incremental triangulation induced by Z+
c . This triangulation restricted to f is
an incremental triangulation induced by Z+
c ∩f. Similarly, the triangulation for
c′ is an incremental triangulation induced by Zc′. The triangulation induced
by Zc′ restricted to f is an incremental triangulation induced by Z+
c′ ∩f. Since
Z+
c ∩f equals Z+
c′ ∩f, these two triangulations match on face f.
The isosurface lookup table determines only the edge containing each isosur-
face vertex. The geometric location of the isosurface vertex along that edge is
not deﬁned by the lookup table.
The vertices of the isosurface tetrahedra are the isosurface vertices. To map
each isosurface tetrahedra to a geometric tetrahedra, we use linear interpolation
to position the isosurface vertices as described in Section 1.7.2. Each isosurface
vertex v lies on a grid edge [p, q]. If sp and sq are the scalar values at p and q
and σ is the isovalue, then map v to (1 −α)p + αq where α = (σ −sp)/(sq −sp).
The Marching Simplices algorithm is presented in Algorithm 6.2. Function
LinearInterpolation, called by this algorithm, is deﬁned in Algorithm 1.1 in
Section 1.7.2.

196
6. Isosurface Generation in 4D
Input
: Γ is a 4D simplicial mesh.
F is an array of the scalar values of each mesh vertex.
σ is an isovalue.
Result
: A set Υ of isosurface tetrahedra.
MarchingSimplices(Γ, F, σ, Υ)
1 Read Marching Simplices lookup table into Table;
2 cS ←“generic” simplex from Marching Simplices lookup table;
3 (vS
1 , vS
2 , vS
3 , vS
4 , vS
5 ) ←vertices of cS in lexicographic order;
/* Assign “+” or “−” signs to each vertex
*/
4 foreach mesh vertex v do
5
if F[v] < σ then Sign[v] ←“−”;
6
else Sign[v] ←“+”;
/* F[v] ≥σ */
7 end
8 T ←∅;
/* For each mesh simplex, retrieve isosurface tetrahedra
*/
9 foreach mesh simplex c do
10
(v1, v2, v3, v4, v5) ←vertices of c in lexicographic order;
11
κ ←(Sign[v1], Sign[v2], Sign[v3], Sign[v4], Sign[v5]);
12
foreach edge quadruple (eS
1 , eS
2 , eS
3 , eS
4 ) ∈Table[κ] do
13
for i ←1 to 4 do ei ←(vj, vk) where eS
i = (vS
j , vS
k );
14
Insert edge quadruple (e1, e2, e3, e4) into T;
15
end
16 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
17 foreach bipolar grid edge e with endpoints v and v′ do
18
we ←LinearInterpolation (v.coord, F[v], v′.coord, F[v′], σ);
19 end
/* Convert T to set of tetrahedra
*/
20 Υ ←∅;
21 foreach quadruple of edges (e1, e2, e3, e4) ∈T do
22
Υ ←Υ ∪{(we1, we2, we3, we4)};
23 end
Algorithm 6.2. Marching Simplices.
6.4.6
Isosurface Properties
The isosurface produced by Marching Simplices has the same properties as
the one produced by Marching HyperCubes. Under appropriate conditions,
the isosurface is a 3-manifold with boundary.

6.4. Marching Simplices
197
Marching Simplices returns a ﬁnite set, Υ, of oriented tetrahedra. The
isosurface is the union of these tetrahedra. The vertices of the isosurface are the
tetrahedra vertices.
The following properties apply to all isosurfaces produced by the Marching
Simplices algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on mesh edges.
Property 3.
The isosurface intersects every bipolar mesh edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
mesh edges.
Property 5.
The isosurface separates positive mesh vertices from negative ones
and strictly separates strictly positive mesh vertices from negative mesh vertices.
Properties 3 and 4 imply that the isosurface intersects a minimum number
of mesh edges. As with Marching Hypercubes, if both endpoints of a mesh
edge have scalar value equal to the isovalue, then the isosurface may intersect
the mesh edge zero, one, or two times or may contain the mesh edge.
By Property 3, the isosurface intersects every bipolar mesh edge. However,
the bipolar mesh edge may be intersected by zero-volume isosurface tetrahedra.
Consider a simplicial mesh that has the following conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The mesh is a partition of a 4-manifold with boundary.
Under these conditions, the isosurface produced by Marching Simplices has
the following properties:
Property 6.
The isosurface is a piecewise linear orientable 3-manifold with
boundary.
Property 7.
The boundary of the isosurface lies on the boundary of the mesh.
Property 8.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra and the tetrahedra in Υ form a triangulation of the isosurface.
Proofs of the properties for the Marching Simplices isosurface are similar
to the proofs for the Marching Hypercubes isosurface and are omitted.

198
6. Isosurface Generation in 4D
6.5
Marching Polytopes
The three-dimensional Marching Polyhedra algorithm generalizes to four-
dimensional convex meshes. The algorithm is called Marching Polytopes.
6.5.1
Algorithm
As with Marching Simplices, care must be taken to ensure that triangulations
of adjacent isosurface patches match. To do so, we require an additional input,
an ordering of all the mesh vertices. This ordering will be used to control the
mapping to the isosurface lookup tables so that triangulations of adjacent isosur-
face patches match. This ordering could be a lexicographic ordering on all the
mesh vertices. However, as we shall see for a mesh of pyramids, it is sometimes
preferable to use a diﬀerent ordering of mesh vertices.
As in the 3D Marching Polyhedra, we assume that the mesh is composed
of a ﬁxed, predeﬁned set of polytope classes (Section 5.4). Each class a has a
precomputed isosurface lookup table built on a “generic” polytope ca. In 3D, a
mesh polytope c is in class a if there is an aﬃne transformation from c to ca.
Because triangulations of adjacent isosurface patches must match, this partition
into classes needs to be further reﬁned in 4D.
The ordering of mesh vertices input to Marching Polytopes induces an or-
dering of the vertices of each mesh element. For each class a, the “generic” poly-
tope ca has an ordering on its vertices that is used in constructing the isosurface
lookup table for class a. More speciﬁcally, this order determines the incremental
triangulation of each isosurface patch constructed by Algorithm IsoPoly4D. A
mesh polytope c is in class a if there is an aﬃne transformation from c to ca
that preserves the vertex order. In other words, the aﬃne transformation should
map the ith vertex of c (given by the input ordering of mesh vertices) to the ith
vertex of ca.
If c and ca are 4-simplices, then there is always an aﬃne transformation of
c to ca that preserves vertex order. For this reason, the Marching Simplices
algorithm needs only one isosurface lookup table. However, for other mesh ele-
ments, say four-dimensional pyramids whose bases are three-dimensional cubes,
there may be no aﬃne transformation preserving vertex order. There may have
to be multiple isosurface lookup tables built for such multiple elements, one for
each ordering of the vertices.
Input to the Marching Polytopes algorithm is an isovalue, a four-dimen-
sional convex polytopal mesh, a set of scalar values at the vertices of the mesh,
a sequence of all the mesh vertices, and a set of polytope classes.
The Marching Polytopes algorithm has three steps. (See Figure 6.16.)
The ﬁrst step is reading the isosurface lookup tables for each class from precon-
structed data ﬁles. Next, for each mesh element, a triangulated isosurface patch

6.5. Marching Polytopes
199
Read isosurface lookup tables for each polytope class

For each mesh polytope, retrieve isosurface tetrahedra

Compute isosurface vertex coordinates using linear interpolation
Figure 6.16. Marching Polytopes.
is retrieved from the appropriate table. Finally, the vertices of the isosurface
patch are assigned geometric locations using linear interpolation. We explain
the last two steps in more detail.
Let c be a mesh element. The input sequence of mesh vertices represents
an ordering of the mesh vertices. Restricted to the vertices of c, this ordering
gives an ordering of the vertices of c. Let a be the polytope class of c where
some aﬃne transformation preserving vertex order maps c to ca. To retrieve an
isosurface patch for mesh element c from the isosurface lookup table for class
a, the ith vertex of c is mapped to the ith vertex of the lookup table polytope.
This mapping determines a conﬁguration of positive and negative vertices that
identiﬁes the appropriate entry in the lookup table.
The isosurface lookup table determines only the edge containing each isosur-
face vertex. The geometric location of the isosurface vertex along that edge is
not deﬁned by the lookup table.
The vertices of the isosurface tetrahedra are the isosurface vertices. To map
each isosurface tetrahedron to a geometric tetrahedron, we use linear interpola-
tion to position the isosurface vertices as described in Section 1.7.2. Each isosur-
face vertex v lies on a mesh edge [p, q]. If sp and sq are the scalar values at p and
q and σ is the isovalue, then map v to (1 −α)p + q where α = (σ −sp)/(sq −sp).
The Marching Polytopes algorithm is presented in Algorithm 6.3. Func-
tion LinearInterpolation, called by this algorithm, is deﬁned in Algorithm 1.1
in Section 1.7.2.
6.5.2
Isosurface Properties
The isosurface produced by Marching Polytopes has the same properties as
the one produced by Marching Simplices. Under appropriate conditions the
isosurface is a 3-manifold with boundary.

200
6. Isosurface Generation in 4D
Input
: Γ is a 4D simplicial mesh.
F is an array of the scalar values of each mesh vertex.
σ is an isovalue.
ZΓ is a sequence of the vertices of Γ.
TableClasses is a set of isosurface lookup table classes.
Result
: A set Υ of isosurface tetrahedra.
MarchingPolytopes(Γ,F, σ,ZΓ, TableClasses, Υ)
1 foreach a ∈TableClasses do
2
Read in isosurface lookup table, Table[a], for class a;
3
ca ←“generic” polytope of Table[a];
4
(va
1, va
2, va
3, . . .) ←ordered sequence of vertices of ca;
5 end
/* Assign “+” or “−” signs to each vertex
*/
6 foreach mesh vertex v do
7
if F[v] < σ then Sign[v] ←“−”;
8
else Sign[v] ←“+”;
/* F[v] ≥σ */
9 end
10 T ←∅;
/* For each mesh polytope, retrieve isosurface tetrahedra
*/
11 foreach mesh polytope c do
12
(v1, v2, v3, . . .) ←subsequence of ZΓ containing vertices of c;
13
κ ←(Sign[v1], Sign[v2], . . .);
14
a ←class of polytope c;
/* Requirement: There exists an aﬃne transformation from c to ca
that maps (v1, v2, v3, . . .) to (va
1, va
2, va
3, . . .)
*/
15
foreach edge quadruple (ea
1, ea
2, ea
3, ea
4) ∈Table[a, κ] do
16
for i ←1 to 4 do ei ←(vj, vk) where ea
i = (va
j , va
k);
17
Insert edge quadruple (e1, e2, e3, e4) into T;
18
end
19 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
20 foreach bipolar mesh edge e with endpoints v and v′ do
21
we ←LinearInterpolation (v.coord, F[v], v′.coord, F[v′], σ);
22 end
/* Convert T to set of tetrahedra
*/
23 Υ ←∅;
24 foreach quadruple of edges (e1, e2, e3, e4) ∈T do
25
Υ ←Υ ∪{(we1, we2, we3, we4)};
26 end
Algorithm 6.3. Marching Polytopes.

6.5. Marching Polytopes
201
Marching Polytopes returns a ﬁnite set, Υ, of oriented tetrahedra. The
isosurface is the union of these tetrahedra. The vertices of the isosurface are the
tetrahedra vertices.
The following properties apply to all isosurfaces produced by the Marching
Polytopes algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on mesh edges.
Property 3.
The isosurface intersects every bipolar mesh edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
mesh edges.
Property 5.
The isosurface separates positive mesh vertices from negative ones
and strictly separates strictly positive mesh vertices from negative mesh vertices.
Properties 3 and 4 imply that the isosurface intersects a minimum number of
mesh edges. As with Marching Simplices, if both endpoints of a mesh edge
have scalar value equal to the isovalue, then the isosurface may intersect the
mesh edge zero, one, or two times or may contain the mesh edge.
By Property 3, the isosurface intersects every bipolar mesh edge. However,
the bipolar mesh edge may be intersected by zero-volume isosurface tetrahedra.
As in 3D, “complex” mesh elements could create isosurface patches that self-
intersect, even if the isovalue does not equal the scalar value of any mesh vertex.
To ensure a manifold, we restrict the mesh elements to a few simple types, such
as cubes, 4-simplices, and pyramids. This list is not meant to be exhaustive
and many other convex polytopes could probably be added. Consider a mesh of
convex polytopes that has the following conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The mesh is a partition of a 3-manifold with boundary.
• The mesh elements are aﬃne transformations of cubes, 4-simplices, and
pyramids over a cube base.
Under these conditions, the isosurface produced by Marching Polytopes has
the following properties:
Property 6.
The isosurface is a piecewise linear, orientable 3-manifold with
boundary.
Property 7.
The boundary of the isosurface lies on the boundary of the mesh.

202
6. Isosurface Generation in 4D
Property 8.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra and the tetrahedra in Υ form a triangulation of the isosurface.
Proofs of the properties for the Marching Polytopes isosurface are similar
to the proofs for the Marching Hypercubes isosurface and are omitted.
6.5.3
Ordering of Mesh Vertices
The Marching Polytopes algorithm requires some ordering of mesh vertices
to determine the mapping of mesh elements to their isosurface lookup tables.
This ordering could simply be a lexicographic ordering of mesh vertices. In this
section, we give an example of a pyramidal mesh where a diﬀerent ordering is
preferable.
Consider a three-dimensional cube and a four-dimensional hypercube. Adding
a vertex v to the center of the cube and connecting vertex v to the six facets of
the cube decomposes the cube into six pyramids. Each pyramid has apex at v
and a square base. Similarly, adding a vertex v to the center of the hypercube
and connecting vertex v to the eight facets of the hypercube decomposes the
cube into eight pyramids. Since the facets of a hypercube are three-dimensional
cubes, each pyramid has apex at v and a three-dimensional cube base.
Decompose a regular four-dimensional grid of hypercubes into a mesh of
pyramids of four-dimensional pyramids by adding a vertex at the center of each
hypercube. Any two mesh elements, c and c′, are aﬃne transformations of each
other.
However, if c is a pyramid whose apex is ﬁrst in lexicographic order
and c′ is a pyramid whose apex is last in lexicographic order, then no aﬃne
transformation of c to c′ preserves the lexicographic order of vertices. There are
actually three diﬀerent classes of pyramids based on lexicographic vertex order:
one where the apex is ﬁrst, one where the apex is last, and one where the apex
is exactly in the middle of the order. (See Figure 6.17 for a three-dimensional
illustration.)
If a lexicographic order of mesh vertices is supplied to Marching Poly-
topes, then the algorithm requires three diﬀerent lookup tables based on the
three diﬀerent locations of the apex in the lexicographic order. Instead, we give
a diﬀerent ordering where only one lookup table is required. Each mesh ver-
tex either is a pyramid apex or is contained in a pyramid base. It cannot be
both. Let ZA be the sequence of mesh vertices at pyramid apices sorted in lex-
icographic order and let ZB be the sequence of mesh vertices in pyramid bases
sorted in lexicographic order. The sequence composition ZA ◦ZB is an ordering
on all the mesh vertices. Under this ordering, the apex appears ﬁrst in the vertex
order of each mesh element. Between any two mesh elements, there is an aﬃne
transformation that preserves the vertex order. Thus, when ZA ◦ZB is used
as the input sequence for this mesh, Marching Polytopes requires only one
isosurface lookup table.

6.6. IsoHull4D
203
(a)
(b)
(c)
(d)
Figure 6.17. (a) Decomposition of a 3D cube into six pyramids. (b) Pyramid apex
is last in lexicographic order. (c) Pyramid apex is in the middle of the lexicographic
order of the vertices. (d) Pyramid apex is ﬁrst in lexicographic order.
Instead of decomposing all hypercubes, one could decomposed only some
hypercubes into eight pyramids. The resulting set of pyramids and hypercubes
is still a mesh.
Let ZA be the sequence of mesh vertices at pyramid apices
sorted in lexicographic order. Let ZB be the sequence of all other mesh vertices
sorted in lexicographic order.
Let ZA ◦ZB be an ordering on all the mesh
vertices.
Between any two hypercubes, there is a translation that preserves
the vertex order. Between any two pyramids, there is an aﬃne transformation
preserving the vertex order. When ZA ◦ZB is used as the input sequence for
this mesh, Marching Polytopes requires two isosurface lookup tables, one for
hypercubes and one for pyramids.
6.6
IsoHull4D
The IsoHull3D algorithm, in Section 5.5, can also be extended to four dimen-
sions. As in IsoHull3D, we ﬁrst locate the isosurface vertex on mesh edges
using linear interpolation and then we construct the isosurface patches directly
from the isosurface vertices.
Algorithm Isohull4D has two steps (Figure 6.18). The ﬁrst step is com-
puting the location of the isosurface vertices. For each bipolar mesh edge [p, q],
apply linear interpolation as in Section 1.7.2 to compute a point on [p, q] repre-
senting the intersection of the isosurface with [p, q]. If sp and sq are the scalar
values at p and q and σ is the isovalue, then this point is (1 −α)p + αq, where
α = (σ −sp)/(sq −sp). Let U be the set of all such interpolated points over all
bipolar mesh edges.
If the positive endpoint of [p, q] is strictly positive, then 0 < α < 1 and
αp + (1 −α)q is in the interior of [p, q]. Thus no point of U lies on a strictly
positive vertex of c.

204
6. Isosurface Generation in 4D
Compute isosurface vertex coordinates using linear interpolation

For each mesh polytope,
construct an isosurface patch (Algorithm Isopatch4D)
Figure 6.18. Algorithm Isohull4D.
Linear interpolation on multiple mesh edges that share the same endpoint
could return that endpoint for each such edge. Since U is a set, it contains only
a single copy of that endpoint.
The second step is constructing isosurface patches on those vertices. For each
mesh polytope c, let Uc be the points of U that lie in c. Each bipolar edge of
c contains one and only one point of Uc and no point of Uc lies on a strictly
positive vertex or a negative vertex or a negative edge. Construct a region R+
c
that is the convex hull of Uc and the positive vertices of c.
As in 3D, we diﬀerentiate three cases. If R+
c is four-dimensional, then we
triangulate the boundary of R+
c and remove tetrahedra that lie on facets of c.
We orient the remaining tetrahedra so that the induced normals point toward
R+
c . If R+
c is three-dimensional and R+
c is contained in some facet of c, then
we triangulate R+
c and retain all the tetrahedra. We orient the tetrahedra so
that the induced normals point toward c. Otherwise, we don’t construct any
isosurface tetrahedra from R+
c .
Algorithm Isopatch4D for constructing the 4D isosurface patches is de-
scribed in Figure 6.19. Apply Isopatch4D to each mesh polytope c. The isosur-
face is represented by all the tetrahedra produced by all the calls to Isopatch4D.
6.6.1
Isosurface Properties
The isosurface produced by IsoHull4D has the following properties:
Property 1.
The isosurface is piecewise linear.
Property 2.
The vertices of the isosurface lie on mesh edges.
Property 3.
The isosurface intersects every bipolar mesh edge at exactly one
point.
Property 4.
The isosurface does not intersect any negative or strictly positive
mesh edges.

6.6. IsoHull4D
205
Construct the convex hull of the positive vertices
and isosurface vertex set Uc

If the convex hull is four-dimensional, then
1. Triangulate the boundary of the convex hull
2. Remove tetrahedra on the polytope boundary

If the convex hull is three-dimensional and
a subset of some polytope facet, then
triangulate the convex hull

Otherwise, return the empty set
Figure 6.19.
Algorithm Isopatch4D for isosurface patch construction in R4 from
isosurface vertex set Uc.
Property 5.
Set Υ does not contain any zero-volume tetrahedra.
To claim that the isosurface separates strictly positive mesh vertices from
strictly negative ones, we need the following condition on the mesh:
• The mesh is a partition of a 4-manifold with boundary.
Under this condition we have the following separation property:
Property 6.
The isosurface strictly separates strictly positive mesh vertices from
negative mesh vertices.
Consider a 4D convex polytopal mesh and isovalue that has the following two
conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The mesh is a partition of a 4-manifold with boundary.
Under these conditions, the isosurface produced by IsoHull3D has the fol-
lowing three properties:
Property 7.
The isosurface is a piecewise linear, orientable 3-manifold with
boundary.

206
6. Isosurface Generation in 4D
Property 8.
The boundary of the isosurface lies on the boundary of the mesh.
Property 9.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra and the tetrahedra in Υ form a triangulation of the isosurface.
6.7
4D Surface Nets
The Surface Nets algorithm, described in Section 3.2, extends directly to four
dimensions. Let Γ be a four-dimensional regular grid with scalar values assigned
to the vertices of Γ.
Add an isosurface vertex wc to each grid hypercube c
with at least one positive and at least one negative vertex. In R4, eight grid
hypercubes can contain a single grid edge. For each bipolar grid edge contained
in eight such hypercubes, c1, c2, . . ., c8, add an isosurface hexahedron with
vertices wc1, wc2, . . ., wc8 that is the dual of the eight hypercubes. For each pair
of hypercubes that share a three-dimensional facet, the isosurface hexahedron
has an edge. For each four hypercubes that share a two-dimensional face, the
isosurface hexahedron has a quadrilateral.
To position the isosurface vertex within each grid cube, use linear interpola-
tion as described in Section 1.7.2 to approximate the intersection of the isosurface
and all the bipolar edges. For each bipolar edge e = [p, q], let we be the point
(1−α)p+αq where α = (σ−sp)/(sq−sp). Take the centroid, (we1 +· · ·+wek)/k,
of all the approximation points as the location of the isosurface vertex.
Dual contouring creates a hexahedral mesh but the vertices of each hexahe-
dral element do not necessarily lie in a single 3-space. In fact, unless isosurface
vertices are placed at the center of each grid cube, it is highly unlikely that the
eight hexahedron vertices will lie in a single 3-space. To create a piecewise linear
surface, one needs to triangulate each hexahedra, subdividing it into tetrahedra.
For each mixed grid hypercube c,
create new isosurface vertex wc

For each bipolar edge contained in eight cubes, c1, c2, . . . , c8,
add an isosurface hexahedron with vertices wc1, wc2, . . . , wc8

Compute isosurface vertex coordinates
Figure 6.20. Surface Nets 4D.

6.7. 4D Surface Nets
207
Hexahedra can be triangulated using ﬁve or six tetrahedra without adding
any new vertices. (See Figure 2.29 in Section 2.4.) The triangulation of the
hexahedron induces a triangulation of each of the quadrilateral facets of the
hexahedron into two triangles.
To produce a triangulation of the isosurface,
the triangulation of the quadrilateral facet of a hexahedron must match the
triangulation of the quadrilateral facet of the adjacent hexahedron. Figure 2.29
depicts a triangulation into six tetrahedra such that each tetrahedra shares a
diagonal edge from one corner to an opposing corner of the cube. Using this
triangulation into six tetrahedra guarantees that the facet triangulations will
match.
As discussed in Section 3.2.3 for 3D, simply breaking isosurface quadrilaterals
produced by Surface Nets into two triangles could produce self-intersections
in the isosurface. The same problem exists for the triangulation of hexahedra
in 4D. Ju et al. [Ju and Udeshi, 2006] solved the problem in 3D by adding an
additional isosurface vertex and breaking quadrilaterals into four triangles. It
is possible that their approach generalizes to 4D, but no 4D solution has been
published.
6.7.1
Isosurface Properties
As in 3D, the boundary of the Surface Nets isosurface is not usually on the
boundary of the grid. A path connecting positive and negative grid vertices can
bypass the isosurface in boundary grid cubes. However, if we restrict the path
to interior grid cubes, then the path must intersect the isosurface. Restricted
to interior grid cubes, the isosurface separates the positive and negative grid
vertices.
If none of the grid vertices have scalar value equal to the isovalue, then the
isosurface is minimal in the sense that it intersects interior bipolar grid edges
exactly once and does not intersect positive or negative grid edges. The isosurface
is not necessarily a manifold, even if none of the grid vertices have scalar value
equal to the isovalue.
Surface Nets returns a ﬁnite set, Υ, of tetrahedra. The isosurface is the
union of these triangles. The vertices of the isosurface are the tetrahedra vertices.
The following properties apply to all isosurfaces produced by the Surface
Nets algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
Set Υ contains at most 6m tetrahedra where m is the number of
bipolar grid edges.
Property 3.
The isosurface does not contain any grid vertices whose scalar
values do not equal the isovalue.

208
6. Isosurface Generation in 4D
Property 4.
The isosurface intersects at exactly one point every interior bipolar
grid edge whose positive endpoint is strictly positive.
Property 5.
The isosurface does not intersect any negative or strictly positive
grid edges.
Property 6.
The isosurface strictly separates the strictly positive vertices of
Γinner from the negative vertices of Γinner.
Properties 3–5 imply that the isosurface intersects a minimum number of grid
edges.
The following properties apply to the Surface Nets isosurface whose iso-
values do not equal the scalar value of any grid vertex.
Property 7.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra.
Since tetrahedra in Υ may intersect in their interiors, set Υ is not necessarily
a triangulation of the isosurface.
Proofs of these properties are the direct 4D generalizations of the proofs of
properties for Surface Nets 3D given in Sections 3.2.5, 3.2.6, and 3.2.7 and
are omitted.
6.8
Notes and Comments
Weigle and Banks [Weigle and Banks, 1996,Weigle and Banks, 1998] proposed the
ﬁrst algorithm for isosurface construction in four dimensions. Their algorithm
decomposes the regular 4D grid into simplices and then constructs isosurface
patches in each simplex.
Roberts and Hill [Roberts and Hill, 1999] extended Marching Cubes to
isosurface construction in 4D using isosurface lookup tables for 4D hypercubes.
Their algorithm retrieves isosurface patches from the lookup table for each grid
hypercube. The lookup tables were built by case analysis of conﬁgurations of
“+” and “−” vertex labels.
Lachaud and Montanvert [Lachaud and Montanvert, 2000] and Bhaniramka
et al. [Bhaniramka et al., 2000,Bhaniramka et al., 2004a] gave similar algorithms
for automatically generating isosurface patches in 4D hypercubes using convex
hulls. The algorithms in this chapter are based on their work. The algorithms
can be used to generate isosurface patches in any convex polytope, not just 4D
hypercubes.

CHAPTER 7
INTERVAL VOLUMES
The region between two level sets is called an interval volume.
Formally, the
interval volume for a function φ : R3 →R is deﬁned as
Iφ(σ0, σ1) = {x ∈R3 : σ0 ≤φ(x) ≤σ1},
where σ0, σ1 ∈R and σ0 < σ1.
Interval volumes are represented by a set of tetrahedra forming some approx-
imation of Iφ(σ0, σ1). Typically, this representation is the triangulation of the
region between two piecewise linear isosurface approximations of the level sets
φ−1(σ0) and φ−1(σ1). Unfortunately, the term interval volume is used both for
the well-deﬁned set Iφ(σ0, σ1) and for the piecewise linear approximation to that
set.
To visualize an interval volume Iφ(σ0, σ1), the set of tetrahedra representing
Iφ(σ0, σ1) are volume rendered. Thus, interval volumes represent an interme-
diate step between direct volume rendering on all the data and rendering the
triangulated isosurface. The advantage of interval volumes over direct volume
rendering is that a much smaller region of interest is being processed and ren-
dered, leading to much faster rendering times. The advantage of interval volumes
over isosurfaces is that a range of values are represented in the image, allowing
more complex visualizations of data. Interval volumes also enable visualization
of surfaces with unclear boundaries that are not associated with a single isovalue.
Interval volumes were introduced by Guo in [Guo, 1995] and Fujishiro, Maeda,
and Takeshima in [Fujishiro et al., 1996]. Nielson and Sung [Nielson and Sung,
1997] gave a Marching Tetrahedra-type algorithm for constructing inter-
val volume representations using a manually constructed interval volume lookup
table.
Bhaniramka et al. in [Bhaniramka et al., 2004b, Bhaniramka et al., 2004a]
showed how the problem of constructing an interval volume in R3 can be trans-
formed into constructing an isosurface in R4. One could apply this transfor-
mation, construct the isosurface in R4, and then project it back down to R3.
209

210
7. Interval Volumes
Instead, we use this transformation to construct an interval volume lookup table
for a Marching Cubes-type algorithm for constructing interval volumes. Doing
so is more eﬃcient than constructing an isosurface in 4D and then projecting it
back to 3D. We ﬁrst give the algorithm for generating the interval volume using
a lookup table and then discuss automatic generation of the lookup table.
7.1
Deﬁnitions and Notation
Because an interval volume, Iφ(σ0, σ1), is based on two scalar values, σ0 and
σ1, the deﬁnitions of vertex and edge properties for interval volumes are slightly
diﬀerent than in previous chapters.
Deﬁnition 7.1. Let v be a mesh vertex with scalar value sv.
• Vertex v is positive, “+”, if sv > σ1.
• Vertex v is negative, “−”, if sv < σ0.
• Vertex v has a star label, “∗”, if σ0 ≤sv ≤σ1.1
Since σ0 is less than σ1, every vertex gets one of these three labels. (See Fig-
ure 7.1(a).) Note that a vertex with scalar value equal to σ1 gets a “∗” label,
not a positive label.
(a)
(b)
−
−
−
−
−
−
+
+
+
+
+
+
+
+
∗
∗
∗
∗
Figure 7.1. (a) Conﬁguration “−+ ∗+ −+ ∗+” and representative interval volume.
(b) Interval volume triangulation vertices and their labels.
1This diﬀers slightly from the convention in [Nielson and Sung, 1997] where a vertex with
scalar value equal to σ0 receives a positive label and a vertex with scalar value equal to σ1
receives a negative label.

7.2. MCVol
211
Let c be a convex polyhedron and Γ a convex polyhedral mesh where every
vertex of c and Γ is labeled negative, positive, or strictly positive. We charac-
terize the edges of c and Γ by the labels at their endpoints.
Deﬁnition 7.2.
• An edge of c or Γ is positive if both its endpoints are positive.
• An edge of c or Γ is negative if both its endpoints are negative.
7.2
MCVol
Input to the MCVol algorithm is two isovalues, σ0 and σ1 with σ0 < σ1, and
a set of scalar values at the vertices of a three-dimensional regular grid. The
algorithm has three steps. (See Figure 7.2.) Read in the interval volume lookup
table from a preconstructed data ﬁle. For each cube, retrieve from the lookup
table a set of interval volume tetrahedra representing the combinatorial structure
of the interval volume. The vertices of these tetrahedra form the interval volume
vertices. Assign geometric locations to the interval volume vertices based on the
scalar values at the cube edge endpoints. We ﬁrst describe the interval volume
lookup table.
7.2.1
Lookup Table
Since each vertex is labeled positive, negative, or star, and a cube has eight
vertices, there are 38 = 6,561 diﬀerent conﬁgurations of cube vertex labels. The
interval volume lookup table contains 6,561 entries, one for each conﬁguration κ.
Read interval volume lookup table

For each grid cube, retrieve interval volume tetrahedra

Compute vertex coordinates using linear interpolation
Figure 7.2. MCVol. Algorithm to construct a piecewise linear approximation to the
interval volume.

212
7. Interval Volumes
Each entry contains a list of oriented tetrahedra forming the triangulation of
the interval volume for conﬁguration κ. However, unlike vertices of triangles in
the isosurface lookup table, vertices of tetrahedra in the interval volume lookup
table may be cube vertices. Furthermore, a cube edge e can contain more than
one tetrahedron vertex, although not more than two such vertices.
If a tetrahedron vertex lies in the interior of a cube edge e, then it represents a
point that lies on φ−1(σ0)∩e or φ−1(σ1)∩e. If a tetrahedron vertex lies on a cube
vertex, then it represents a point that is not on φ−1(σ0) or φ−1(σ1). Thus, we can
label a tetrahedra vertex, “−”, “+”, or “∗”, depending on whether it represents
a point on φ−1(σ0) or φ−1(σ1) or neither, respectively. (See Figure 7.1(b).) Each
tetrahedron vertex is represented by a pair, (g, L), where g is a vertex or edge
and L is a “−”, “+”, or “∗” label.
The entries in the interval volume lookup table are lists of quadruplets,
((g1, L1), (g2, L2), (g3, L3), (g4, L4)). Each quadruplet represents a tetrahedron
whose vertices lie on g1 and g2 and g3 and g4. The list of quadruplets deﬁne the
combinatorial structure of the isosurface patch for conﬁguration κ.
An algorithm to construct each of the 6,561 entries in the interval volume
lookup table is described in Section 7.3. We ﬁrst complete the description of
algorithm MCVol.
7.2.2
Algorithm
The ﬁrst step in algorithm MCVol is reading in the interval volume lookup table
from a preconstructed data ﬁle. The next step is retrieving from the lookup table
the appropriate list of interval volume tetrahedra for each grid cube.
Each grid vertex is labeled positive, negative, or star. The eight vertices of
each grid cube determine a vector of eight vertex labels. Retrieve a list of interval
volume tetrahedra from the corresponding entry in the interval volume lookup
table.
The interval volume lookup table is constructed on the unit cube with ver-
tices (0, 0, 0), (1, 0, 0), (0, 1, 0), . . ., (0, 1, 1), (1, 1, 1). To construct the interval vol-
ume in grid cube (ix, iy, iz), we have to map unit cube edges to edges of cube
(ix, iy, iz). Each vertex v = (vx, vy, vz) of the unit cube maps to v + (ix, iy, iz) =
(vx, vy, vz)+(ix, iy, iz) = (vx +ix, vy +iy, vz +iz). Each edge e of the unit square
with endpoints (v, v′) maps to edge e+(ix, iy, iz) = (v+(ix, iy, iz), v′+(ix, iy, iz)).
Finally, each quadruplet ((g1, L1), . . . , (g4, L4)) in the interval volume lookup ta-
ble maps to ((g1 + (ix, iy, iz), L1), . . . , (g4 + (ix, iy, iz), L4)).
The interval volume tetrahedra form a triangulation of the interval volume.
The triangulation vertices are the vertices of the interval volume tetrahedra. The
ﬁnal step is mapping each triangulation vertex to its geometric location. We use
linear interpolation as described in Section 1.7.2 to position the triangulation
vertices.

7.2. MCVol
213
Input
: F is a 3D array of scalar values.
Coord is a 3D array of (x, y, z) coordinates.
σ0, σ1 are scalar values with σ0 < σ1.
Result
: A set Υ of interval volume tetrahedra.
MCVol(F, Coord, σ0, σ1, Υ)
1 Read interval volume lookup table into Table;
/* Assign “+” or “−” or “∗” labels to each vertex
*/
2 foreach grid vertex (ix, iy, iz) do
3
if F[ix, iy, iz] < σ0 then Label[ix, iy, iz] ←“−”;
4
else if F[ix, iy, iz] > σ1 then Label[ix, iy, iz] ←“+”;
5
else Label[ix, iy, iz] ←“∗”;
/* σ0 ≤F[ix, iy, iz] ≤σ1 */
6 end
7 T ←∅;
/* For each grid cube, retrieve interval volume tetrahedra
*/
8 foreach grid cube (i, j, k) do
/* Cube vertices are (ix, iy, iz), (ix+1, iy, iz), . . . , (ix+1, iy+1, iz+1)
*/
9
κ ←(Label[ix, iy, iz], Label[ix+1, iy, iz], . . . , Label[ix+1, iy+1, iz+1]);
10
foreach ((g1, L1), (g2, L2), (g3, L3), (g4, L4)) ∈Table[κ] do
11
Insert ((g1 + (ix, iy, iz), L1), . . . , (g4 + (ix, iy, iz), L4)) into T;
12
end
13 end
/* Compute vertex coordinates using linear interpolation
*/
14 foreach grid edge e = (i, j) labeled (−, ∗) or (−, +) do
15
w(e,−) ←LinearInterpolation
16
(Coord[ix, iy, iz], F[ix, iy, iz], Coord[jx, jy, jz], F[jx, jy, jz], σ0);
17 end
18 foreach grid edge e = (i, j) labeled (+, ∗) or (−, +) do
19
w(e,+) ←LinearInterpolation
20
(Coord[ix, iy, iz], F[ix, iy, iz], Coord[jx, jy, jz], F[jx, jy, jz], σ1);
21 end
/* Store vertex coordinates
*/
22 foreach grid vertex v with label “∗” do
23
w(v,∗) ←(vx, vy, vx);
24 end
/* Convert T to set of triangles
*/
25 Υ ←∅;
26 foreach quadruplet ((g1, L1), (g2, L2), (g3, L3), (g4, L4)) ∈T do
27
Υ ←Υ ∪{(w(g1,L1), w(g2,L2), w(g3,L3), w(g4,L4))};
28 end
Algorithm 7.1. MCVol.

214
7. Interval Volumes
Each pair (g, L) corresponds to a vertex in the triangulation of the interval
volume. For each such pair, element g is either a grid vertex or a grid edge. If g
is a grid vertex v, then the location of vertex (g, L) is the location of vertex v.
Assume g is a grid edge [p, q]. Let sp and sq be the scalar values at p and q. If
L is “−”, then map (g, L) to (1 −α0)p + α0q where α0 = (σ0 −sp)/(sq −sp).
If L is “+”, then map (g, L) to (1 −α1)p + α1q where α1 = (σ1 −sp)/(sq −sp).
Note that if L is “−” or “+”, then p and q must have diﬀerent labels. Thus,
scalar sp does not equal sq and the denominator (sq −sp) is never zero.
Pseudocode for algorithm MCVol is given in Algorithm 7.1.
Function
LinearInterpolation, called by this algorithm, is deﬁned in Algorithm 1.1
in Section 1.7.2.
7.3
Automatic Table Generation
The interval volume lookup table consists of representative interval volumes,
one for each cube conﬁguration. To generate the interval volume for a given
conﬁguration, we embed the cube in a four-dimensional hypercube, construct an
isosurface in that hypercube, and then project the tetrahedra in that isosurface
to the three-dimensional cube to form the interval volume.
We ﬁrst discuss the relationship between interval volumes in R3 and isosur-
faces in R4.
7.3.1
Interval Volumes and Isosurfaces
Let
Iφ(σ0, σ1) = {x ∈R3 : σ0 ≤φ(x) ≤σ1}
be the interval volume for function φ for the interval [σ0, σ1] where σ0 < σ1.
Deﬁne the scalar function Ψ : R3 × [0, 1] →R as follows:
Ψ(px, py, pz, α) = φ(px, py, pz) −((1 −α)σ0 + ασ1),
where 0 ≤α ≤1. Note that {(px, py, pz) : Ψ(px, py, pz, 0) = 0} equals φ−1(σ0)
and {(px, py, pz) : Ψ(px, py, pz, 1) = 0} equals φ−1(σ1).
We claim that the isosurface Ψ−1(0) is homeomorphic to the interval volume
Iφ(σ0, σ1). Let π : R4 →R3 be the orthogonal projection of R4 onto R3 where
π(px, py, pz, pw) = (px, py, pz).
Theorem 7.3. If φ : R3 →R is a scalar ﬁeld in R3 and σ0 < σ1, then π restricted
to Ψ−1(0) is a homeomorphism from the isosurface Ψ−1(0) to the interval volume
Iφ(σ0, σ1).

7.3. Automatic Table Generation
215
Proof: Let π′ be the restriction of π to Ψ−1(0). Every point (px, py, pz, α) on the
isosurface Ψ−1(0) satisﬁes the equation
φ(px, py, pz) −((1 −α)σ0 + ασ1) = 0
or, equivalently,
φ(px, py, pz) = (1 −α)σ0 + ασ1.
Since α is between 0 and 1, inclusive, φ(px, py, pz) is between σ0 and σ1, inclusive,
and so (px, py, pz) is in Iφ(σ0, σ1). Thus, π′(Ψ−1(0)) is a subset of Iφ(σ0, σ1).
For every point (px, py, pz) ∈Iφ(σ0, σ1), scalar φ(px, py, pz) is between σ0
and σ1, inclusive. Thus, there is some scalar α ∈[0, 1] such that φ(px, py, pz) =
(1 −α)σ0 + ασ1.
Since φ(px, py, pz) −((1 −α)σ0 + ασ1) equals zero, point
(px, py, pz, α) is in Ψ−1(0). Since projection π′(px, py, pz, α) equals (px, py, pz),
point (px, py, pz) is in π′(Ψ−1(0)). Thus, π′(Ψ−1(0)) equals Iφ(σ0, σ1).
Since σ0 does not equal σ1, for every scalar y ∈R, there is a unique α such
that y = (1−α)σ0+ασ1. Thus, for each point (px, py, pz) ∈Iφ(σ0, σ1), the scalar
α ∈[0, 1] such that φ(px, py, pz) = (1−α)σ0+ασ1 is unique and π′ is one-to-one.
Since π′ is a continuous, one-to-one mapping from Ψ−1(0) onto I(σ0, σ1), π′ is
a homeomorphism.
□
7.3.2
Interval Volume Patch Construction
We present an algorithm, IVolPatch3D, that constructs interval volume patches
in any three-dimensional convex polyhedron, not just a cube. Input to this al-
gorithm is a convex polyhedron c in R3 where each vertex of c has a positive,
negative, or star label, and an ordering of the vertices of c. The ordering of the
vertices of c determines the triangulation of the interval volume.
As in the previous section, π : R4 →R3 is the orthogonal projection of
R4 onto R3 where π(px, py, pz, pw) = (px, py, pz). The set c × [0, 1] is a convex
polytope in R4. Set c × [0, 1] equals {(px, py, pz, α) : (px, py, pz) ∈c and α ∈
[0, 1]}. When c is a cube, set c × [0, 1] is a hypercube. Note that π(c × [0, 1])
equals c.
The interval volume in c is a region that contains all the star vertices and
separates the positive from the negative vertices. We show how to construct the
interval volume in c by constructing a three-dimensional isosurface in c × [0, 1]
and then projecting that isosurface back into c.
The vertices of c × [0, 1] lie on the hyperplanes
h0 = {(px, py, pz, pw) : pw = 0},
h1 = {(px, py, pz, pw) : pw = 1}.
Label the vertices of c × [0, 1] as follows.
• If v = (vx, vy, vz) has a positive label, then label vertices (vx, vy, vz, 0) and
(vx, vy, vz, 1) of c × [0, 1] positive.

216
7. Interval Volumes
Label vertices of c × [0, 1] as follows:
For each vertex v = (vx, vy, vz) of the labeled cube
1. If v is negative, label (vx, vy, vz, 0) and (vx, vy, vz, 1) as negative
2. If v is positive, label (vx, vy, vz, 0) and (vx, vy, vz, 1) as positive
3. If v has a star label,
label (vx, vy, vz, 0) as positive and (vx, vy, vz, 1) as negative

Construct a proper isosurface vertex set as follows:
For each bipolar edge e = (v, v′) of the unit hypercube
(where v is negative and v′ is positive)
1. If e is in hyperplane h0, then uI
e ←(2/3)v + (1/3)v′
2. Else if e is in hyperplane h1, then uI
e ←(1/3)v + (2/3)v′
3. Else uI
e ←(1/2)v + (1/2)v′

Zc ←Sequence of vertices of c in order
Zc×[0,1] ←((v1, 0), (v1, 1), (v2, 0), (v2, 1), . . . , (vi, 0), (vi, 1), . . .)
where vi is ith element of Zc

Construct an isosurface patch in c × [0, 1] ⊂R4
using isosurface vertex set U I = {uI
e} and order Zc×[0,1]

Orthogonally project each tetrahedron in the isosurface patch
into c in R3

Label interval volume vertices as follows:
1. If uI
e ∈U I is on h0, assign label “−” to π(uI
e)
2. Else if uI
e ∈U I is on h1, assign label “+” to π(uI
e)
3. Else assign label “∗” to π(uI
e)
Figure 7.3. Algorithm IVolPatch3D for interval volume construction in a 3D convex
polyhedron.

7.3. Automatic Table Generation
217
(a)
(b)
(c)
−
−
−
−
−
−
−
−
−
−
−
−
+
+
+
+
+
+
+
∗
(d)
(e)
(f)
−
−
−
−
−
−
−
−
−
+
+
+
+
+
+
∗
∗
Figure 7.4. Two-dimensional example of interval volume construction in square c using
isosurface in c × [0, 1]. (a) Square c with vertices labeled “−”, “+”, or “∗”. (b) Cube
c × [0, 1] with vertices labeled “−” or “+” based on the labeling of the vertices of
c.
(c) Isosurface vertex set U I
c×[0,1] for c × [0, 1]. (d) Isosurface patch in c × [0, 1].
(e) Interval volume in c formed by projecting the isosurface patch in c × [0, 1] into c.
(f) Labels “−”, “+”, and “∗” of interval volume vertices.
• If v = (vx, vy, vz) has a negative label, then label both (vx, vy, vz, 0) and
(vx, vy, vz, 1) negative.
• If v = (vx, vy, vz) has a star label, then label (vx, vy, vz, 0) positive and
(vx, vy, vz, 1) negative.
See Figure 7.4(b) for a two-dimensional example.
Construct a proper isosurface vertex set U I
c×[0,1] for c × [0, 1] as follows.
Edges of c × [0, 1] are contained in the hyperplane h0 or are contained in the
hyperplane h1 or have one vertex on h0 and one vertex on h1. For each bipolar
edge e = (v, v′) of c × [0, 1], we determine a point uI
e ∈e. Without loss of
generality, assume that v is negative and v′ is positive.
• If e is contained in hyperplane h0, let uI
e be the point (2/3)v + (1/3)v′.
(Point uI
e is the point on e one-third of the way from v to v′.)
• If e is contained in hyperplane h1, let uI
e be the point (1/3)v + (2/3)v′.
(Point uI
e is the point on e two-thirds of the way from v to v′.)
• If one vertex of e is on hyperplane h0 while the other vertex is on hyper-
plane h1, let uI
e be the point (1/2)v + (1/2)v′. (Point uI
e is the midpoint
of e.)

218
7. Interval Volumes
See Figure 7.4(c) for a two-dimensional example. Let U I
c×[0,1] be the set { uI
e :
e is a bipolar edge of c × [0, 1] }.
Let (v1, v2, v3, . . .) be the input ordering on the vertices of c.
Construct
the isosurface S+
c×[0,1](U I
c×[0,1]) of c × [0, 1] and its triangulation using the algo-
rithm IsoPoly4D in Section 6.4.3.
Input to IsoPoly4D is the proper iso-
surface vertex set U I
c×[0,1] and polytope c × [0, 1] with vertices in the order
((v1, 0), (v1, 1), (v2, 0), (v2, 1), (v3, 0), (v3, 1), . . .).
Set U I
c×[0,1] is the set of ver-
tices of the triangulated isosurface (see Corollary 6.7).
The triangulation is
three-dimensional and composed of oriented tetrahedra. Orthogonally project
each tetrahedron in the triangulation into R3 (Figure 7.4(e)). The union of the
projected tetrahedra form the interval volume in c.
There are three types of vertices in U I
c×[0,1]: those that lie on the hyperplane
h0, those that lie on the hyperplane h1, and those that lie between the two
hyperplanes. The projections of the ﬁrst two types lie in the interiors of edges
of c. The projections of the last type lie on vertices of c.
Algorithm MCVol determines the geometric location of the interval volume
vertices using linear interpolation. For this interpolation step, it is necessary to
distinguish between diﬀerent types of vertices. If u ∈U I
c×[0,1] lies on hyperplane
h0, then assign a negative label to π(u). If u ∈U I
c×[0,1] lies on hyperplane h1,
then assign a positive label to π(u). If u ∈U I
c×[0,1] is between h0 and h1, then
assign a star label to π(u). (See Figure 7.4(f).) Algorithm IVolPatch3D is
presented in Figure 7.3.
7.3.3
Interval Volume Table Construction
As discussed in Section 7.2.1, the interval volume lookup table has 38 = 6,561
entries, one for each conﬁguration of cube vertex labels. For each conﬁguration,
construct an interval volume patch using algorithm IVolPatch3D. Input to
IVolPatch3D is the cube (0, 0, 0), (1, 0, 0), (0, 1, 0), . . ., (1, 1, 1) with vertices
sorted in lexicographic order.
Algorithm IVolPatch3D returns a set of oriented tetrahedra representing a
triangulation of the interval volume. Note that this is not a lexicographic trian-
gulation of the interval volume but it is an incremental one. (See Section 6.4.1
for the deﬁnition and discussion of incremental triangulations.)
An interval volume tetrahedron with vertices (w1, w2, w3, w4) is represented
in the isosurface lookup table by a quadruplet:
((g1, L1), (g2, L2), (g3, L3), (g4, L4)).
Symbol gi is the cube edge or cube vertex containing wi. Symbol Li is the label
(−, +, or ∗) of wi.

7.4. MCVol Interval Volume Properties
219
7.4
MCVol Interval Volume Properties
The Marching Cubes isosurface is a 2-manifold with boundary if no grid point
has scalar value equal to the isovalue. Similarly, the interval volume produced
by MCVol is a piecewise linear, orientable 3-manifold with boundary if no grid
point has scalar value equal to σ0 or to σ1. If some grid point has scalar value
equal to σ0 or to σ1, then the interval volume may not be a 3-manifold.
MCVol returns a ﬁnite set, Υ, of oriented tetrahedra. The interval volume
is the union of these tetrahedra. The vertices of the interval volume are the
tetrahedra vertices.
The following properties apply to all interval volumes produced by the MCVol
algorithm. The scalar value at a grid vertex v is denoted sv.
Property 1.
The interval volume is piecewise linear.
Property 2.
The vertices of the interval volume lie on grid vertices or grid edges.
Property 3.
The interval volume contains every grid vertex v where σ0 ≤sv ≤σ1
and intersects each grid edge (v, ˜v) where sv < σ1 and s˜v > σ0 (or vice versa)
in a line segment.
Property 4.
The interval volume does not contain any grid vertex v where
sv < σ0 or sv > σ1 and does not intersect any grid edges (v, ˜v) where both
sv and s˜v are strictly less than σ0 or where both sv and s˜v are strictly greater
than σ1.
Property 5.
The interval volume strictly separates vertices with scalar values
less than σ0 from vertices with scalar value greater than σ1.
Properties 3 and 4 imply that the interval volume intersects a minimum
number of grid edges.
The following property applies to the MCVol interval volumes when no grid
vertex has scalar value equal to σ0 or σ1.
Property 6.
The interval volume is a piecewise linear, orientable 3-manifold
with boundary.
Property 7.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra and the tetrahedra in Υ form a triangulation of the interval volume.
7.4.1
Proofs of Interval Volume Properties 1–4
We start with a mathematical description of the interval volume constructed by
Algorithm IVolPatch3D and prove some properties of this interval volume.

220
7. Interval Volumes
These properties apply to interval volume patches constructed in any convex
polyhedron, not just in cubes.
Let c be a convex polyhedron and Γ be a convex polyhedral mesh in R3 where
each vertex of c and of Γ has the label “−”, “+”, or “∗”. Let π : R4 →R3 be
the orthogonal projection of R4 onto R3 where π(px, py, pz, pw) = (px, py, pz).
Projection π maps c × [0, 1] ⊂R4 to c ⊂R3 and Γ × [0, 1] ⊂R4 to Γ ⊂R3.
Note that π maps each vertex of c × [0, 1] or Γ × [0, 1] to a vertex of c or Γ,
respectively.
Let χ(c) equal c × [0, 1] and χ(Γ) equal Γ × [0, 1], where vertices of χ(c) and
χ(Γ) are labeled as follows:
• A vertex v in χ(c) or χ(Γ) has a negative label if π(v) has a negative label.
• A vertex v ∈χ(c) has a positive label if π(v) has a positive label.
• A vertex v0 = (v1, v2, v3, 0) in χ(c) or χ(Γ) has a positive label if π(v0) has
a star label.
• A vertex v1 = (v1, v2, v3, 1) in χ(c) or χ(Γ) has a negative label if π(v1)
has a star label.
Deﬁne hyperplanes h0, h1 ⊂R4 as
h0
=
{(px, py, pz, pw) ∈R4 : pw = 0},
h1
=
{(px, py, pz, pw) ∈R4 : pw = 1}.
For each bipolar edge e = (v, v′) in χ(c) or χ(Γ), deﬁne a point uI
e as in
Section 7.3.2. Assume that v is negative and v′ is positive.
• If e = (v, v′) is on hyperplane h0, then uI
e equals (2/3)v + (1/3)v′.
• If e = (v, v′) is on hyperplane h1, then uI
e equals (1/3)v + (2/3)v′.
• If e = (v, v′) has one endpoint on h0 and one endpoint on h1, then uI
e
equals (1/2)v + (1/2)v′.
Let U I
χ(c) equal {uI
e : e is a bipolar edge of χ(c)}. Let U I
χ(Γ) equal {uI
e : e is
a bipolar edge of χ(Γ)}. Sets U I
χ(c) and U I
χ(Γ) are proper isosurface vertex sets
of χ(c) and χ(Γ), respectively.
Let T I
χ(c) be the set of tetrahedra in the incremental triangulation of the iso-
surface patch constructed by algorithm IsoPoly4D (Chapter 6) using isosurface
vertex set U I
χ(c). Let T I
c = {π(t) : t ∈T I
χ(c)} be the orthogonal projection of T I
χ(c)
into c. Set T I
c is the set of tetrahedra returned by algorithm IVolPatch3D.
Let μ be a translation of convex polyhedron c. Since μ(c) is a translation of
c, polyhedron χ(μ(c)) is a translation of χ(c) and |T I
χ(μ(c))| is a translation of
|T I
χ(c)|. (Sets |T I
χ(μ(c))| and |T I
χ(c)| are the unions of all the tetrahedra in T I
χ(μ(c))

7.4. MCVol Interval Volume Properties
221
μ(c)
 T I
χ(μ(c))
μ−1

π
 T I
μ(c)
μ−1

O
O
O
O
O
O
O
O
O
O
O
O
O
O
c
μ

 T I
χ(c)
π
 T I
c
 Υc(σ0, σ1)
Figure 7.5. The MCVol algorithm constructs the interval volume patch Υc(σ0, σ1) by
mapping cube c to μ(c), retrieving T I
μ(c) from the interval volume lookup table and
mapping T I
μ(c) to Υc(σ0, σ1) using linear interpolation. The isosurface patch Υc(σ0, σ1)
could be constructed directly from c by lifting c to χ(c), constructing the isosurface
patch |T I
χ(c)| in χ(c), projecting T I
χ(c) into T I
c , and then mapping T I
c to Υc(σ0, σ1).
and T I
χ(c), respectively.) Since incremental triangulations are invariant under
translations, T I
χ(μ(c)) and T I
μ(c) are translations of T I
χ(c) and T I
c , respectively.
(See Figure 7.5.)
Algorithm MCVol constructs the interval volume for a grid cube c using the
interval volume lookup table for μ(c), where μ(c) is the unit cube with vertices
(0, 0, 0), . . ., (1, 1, 1) and μ is a translation of c to this unit cube. The algorithm
retrieves from the lookup table T I
μ(c) and then embeds T I
μ(c) in c using linear
interpolation to position the vertices of T I
μ(c).
Because T I
μ(c) and T I
c are isomorphic, the algorithm could have constructed
the interval volume from T I
c by reembedding T I
c in c using linear interpolation
on its vertices. The algorithm uses μ(c) to construct the interval volume because
it is faster to retrieve the precomputed values of T I
μ(c) from the lookup table than
to compute T I
c . However, for the analysis we will view the interval volume as
an embedding of T I
c into c.
Let U I
c be the set of vertices of T I
c . Algorithm IVolPatch3D assigns a
label, “−”, “+”, or “∗” to each vertex in U I
c . For each ui ∈U I
c , deﬁne point wi
as follows:
• If ui has the label “∗”, then wi = ui.
• If ui has the label “−”, then wi = (1 −α0)v + α0˜v where (v, ˜v) is the edge
of c containing ui and α0 = (σ0 −sv)/(s˜v −sv).
• If ui has the label “+”, then wi = (1 −α1)v + α1˜v where (v, ˜v) is the edge
of c containing ui and α1 = (σ1 −sv)/(s˜v −sv).
Linearly extend the mapping from ui to wi to each tetrahedron in T I
c .
Let
Υc(σ0, σ1) be the resulting set of tetrahedra.

222
7. Interval Volumes
Let Γ be a regular grid with scalar values at its vertices. Deﬁne ΥΓ(σ0, σ1)
as
ΥΓ(σ0, σ1) =

c∈Υ
Υc(σ0, σ1).
Sets |Υc(σ0, σ1)| and |ΥΓ(σ0, σ1)| are the union of all the tetrahedra in Υc(σ0, σ1)
and ΥΓ(σ0, σ1), respectively. Algorithm MCVol returns set ΥΓ(σ0, σ1) repre-
senting the interval volume |ΥΓ(σ0, σ1)|.
Properties 1 and 2 come directly from the construction of ΥΓ(σ0, σ1).
Property 1.
The interval volume is piecewise linear.
Property 2.
The vertices of the interval volume lie on grid vertices or grid edges.
Proof of Properties 1 & 2: Let Γ be a regular grid with scalar values at its vertices.
Set |ΥΓ(σ0, σ1)| is composed of a ﬁnite set of tetrahedra, so it is piecewise lin-
ear. By construction, the vertices of these tetrahedra lie on grid edges or grid
vertices.
□
We need a few lemmas to prove Properties 3 and 4, A vertex of c is a vertex
of T I
c if and only if it has the label “∗”.
Lemma 7.4. Let c be a convex polyhedron in R3 where each vertex of c has the
label “−”, “+”, or “∗”. Vertex v of c is a vertex of some tetrahedron in T I
c if
and only if the label of vertex v is “∗”.
Proof: Vertex v of c is the projection π(p0) and π(p1) of two vertices p0 and p1
of c × [0, 1]. Vertex v is a vertex of some tetrahedron in T I
c if and only if (p0, p1)
is a bipolar edge in c × [0, 1]. Edge (p0, p1) is bipolar if and only if vertex v has
the label “∗”. Thus vertex v is a vertex of some tetrahedron in T I
c if and only if
vertex v has the label “∗”.
□
As deﬁned in Section 7.1, an edge of c is positive if both endpoints of e are
positive and negative if both endpoints of e are negative. If an edge is neither
positive nor negative, then exactly two vertices and one edge of T I
c lie on e.
Lemma 7.5. Let c be a convex polyhedron in R3 where each vertex of c has the
label “−”, “+”, or “∗” and let e be an edge of c. If e is not positive and not
negative, then edge e contains some edge (w, w′) of some tetrahedron in T I
c and
no tetrahedra vertices of T I
c other than w and w′ lie on e.
Proof: Let v = (v1, v2, v3) and ˜v = (˜v1, ˜v2, ˜v3) be the endpoints of e. Let p0 =
(v1, v2, v3, 0), p1 = (v1, v2, v3, 1), ˜p0 = (˜v1, ˜v2, ˜v3, 0), and ˜p1 = (˜v1, ˜v2, ˜v3, 1) be the
corresponding vertices of c × [0, 1]. Square (p0, p1, ˜p0, ˜p1) is a face f of c × [0, 1].
Note that π(f) equals e.
Algorithm IVolPatch3D constructs an isosurface
patch of c × [0, 1]. The intersection of this isosurface patch and f is an isocontour
in f separating positive and negative vertices of f. We claim that this intersection
is a single line segment in f. We prove this based on case analysis of the labels
of v and ˜v.

7.4. MCVol Interval Volume Properties
223
Case I: (v, ˜v) have labels (−, +) or (+, −).
Without loss of generality, assume that v has the label “−” and ˜v has
the label “+”. By construction, vertices p0 and p1 have negative labels and
˜p0 and ˜p1 have positive labels. The isocontour in f is a single line segment
from edge (p0, ˜p0) to edge (p1, ˜p1).
Case II: (v, ˜v) have labels (−, ∗) or (∗, −).
Without loss of generality, assume that v has the label “−” and ˜v has
the label “∗”. By construction, vertices p0, p1, and ˜p1 have negative labels
and ˜p0 has a positive label. The isocontour in f is a single line segment from
edge (p0, ˜p0) to edge (˜p0, ˜p1).
Case III: (v, ˜v) have labels (+, ∗) or (∗, +).
This case is similar to Case II, with positive labels interchanged with
negative ones. Without loss of generality, assume that v has the label “+”
and ˜v has the label “∗”.
By construction, vertices p0, p1, and ˜p0 have
positive labels and ˜p1 has a negative label. The isocontour in f is a single
line segment from edge (p1, ˜p1) to edge (˜p0, ˜p1).
Case IV: (v, ˜v) have labels (∗, ∗).
By construction, vertices p0 and ˜p0 have positive labels and p1 and ˜p1
have negative labels. The isocontour in f is a single line segment from edge
(p0, p1) to edge (˜p0, ˜p1).
Let line segment (u, ˜u) be the intersection of f and the isosurface patch of
c × [0, 1]. Line segment (u, ˜u) is an edge of some tetrahedron in the incremental
triangulation of this isosurface patch. Its projection, (π(u), π(˜u)), is an edge of
some tetrahedron in T I
c . Tetrahedra vertices u and ˜u are the only isosurface
vertices on f. Thus π(u) and π(˜u) are the only vertices of T I
c on e.
□
We are ﬁnally ready to prove Properties 3 and 4. Because Property 4 is used
in the proof of Property 3, we prove Property 4 ﬁrst.
Property 4.
The interval volume does not contain any grid vertex v where
sv < σ0 or sv > σ1 and does not intersect any grid edges (v, ˜v) where both
sv and s˜v are strictly less than σ0 or where both sv and s˜v are strictly greater
than σ1.
Proof: Let Γ be a regular grid with scalar values at its vertices. We prove that
|ΥΓ(σ0, σ1)| does not contain any grid vertex where sv < σ0 or sv > σ1. Let v be
a grid vertex with scalar value sv less than σ0 or greater than σ1. Such a vertex
has the label “−” or “+”. By Lemma 7.4, no interval volume vertex with label
“∗” lies on v. The location of interval volume vertices with labels “−” and “+”
are determined by linear interpolation. Since sv does not equal σ0 or σ1, such
vertices do not lie on v. Thus no interval volume vertex lies on v. Since each

224
7. Interval Volumes
interval volume tetrahedron is contained in some grid cube, no interval volume
tetrahedron contains v. Thus, |ΥΓ(σ0, σ1)| does not contain v.
Finally, consider a grid edge e = (v, ˜v) where both sv and s˜v are strictly
less than σ0 or both sv and s˜v are strictly greater than σ1. No interval volume
vertices lie on e. Since each interval volume tetrahedron is contained in some
grid cube and e does not intersect the interior of any grid cube, |ΥΓ(σ0, σ1)| does
not intersect e.
□
Property 3.
The interval volume contains every grid vertex v where σ0 ≤sv ≤σ1
and intersects each grid edge (v, ˜v) where sv < σ1 and s˜v > σ0 (or vice versa)
in a line segment.
Proof: Let Γ be a regular grid with scalar values at its vertices. We ﬁrst prove
that |ΥΓ(σ0, σ1)| contains every grid vertex v where σ0 ≤sv ≤σ1. Such a grid
vertex has the label “∗”. By Lemma 7.4, vertex v is a vertex of some tetrahedron
in T I
c . The linear interpolation step of algorithm MCVol does not move vertices
with label “∗”, so v is in the interval volume constructed by MCVol.
We now prove that |ΥΓ(σ0, σ1)| intersects each grid edge s = (v, ˜v) where
sv < σ1 and s˜v > σ0 (or vice versa) in a line segment.
Since sv < σ1 and
s˜v > σ0, edge e is neither positive nor negative.
Let c be a grid cube containing e. By Lemma 7.5, two vertices, ui and uj,
and one edge, (ui, uj), of T I
c lie on edge e. The two vertices ui and uj map to
two interval volume vertices, wi and wj, on edge e.
The geometric locations of wi and wj depend upon the labels of ui and
uj, respectively. If ui has a star label, then wi is an endpoint of e. If ui has a
negative label, then wi is the point (1−α0)v+α0˜v where α0 = (σ0−sv)/(s˜v−sv).
Similarly, if ui has a positive label, then wi is the point (1 −α1)v + α1˜v where
α1 = (σ1 −sv)/(s˜v −sv). The same applies to wj.
We claim that wi and wj are diﬀerent points. The proof is by case analysis
on the labels of sv and s˜v. Since sv < σ1 and s˜v > σ0, vertex v cannot have a
positive label and ˜v cannot have a negative label.
Case I: (v, ˜v) have labels (−, +).
Since (v, ˜v) have labels (−, +), vertices (ui, uj) have labels (−, +) or
(+, −). Without loss of generality, assume (ui, uj) have labels (−, +). Since
σ0 does not equal σ1, the scalar α0 = (σ0 −sv)/(s˜v −sv) does not equal
α1 = (σ1 −sv)/(s˜v −sv) and wi = (1 −α0)v + α0)˜v does not equal wj =
(1 −α1)v + α1˜v.
Case II: (v, ˜v) have labels (−, ∗).
Since (v, ˜v) have labels (−, ∗), vertices (ui, uj) have labels (−, ∗) or (∗, −).
Without loss of generality, assume (ui, uj) have labels (−, ∗). By Lemma 7.4,
vertex wj lies on ˜v. Since s˜v > σ0, the scalar α0 = (σ0 −sv)/(s˜v −sv) does
not equal one and vertex wi = (1 −α0)v + α0˜v does not equal ˜v.

7.4. MCVol Interval Volume Properties
225
Case III: (v, ˜v) have labels (∗, +).
Since (v, ˜v) have labels (∗, +), vertices (ui, uj) have labels (∗, +) or (+, ∗).
Without loss of generality, assume (ui, uj) have labels (∗, +). By Lemma 7.4,
vertex wi lies on v. Since sv < σ1, the scalar α1 = (σ1 −sv)/(s˜v −sv) does
not equal zero and vertex wj = (1 −α1)v + α1˜v does not equal v.
Case IV: (v, ˜v) have labels (∗, ∗).
Since (v, ˜v) have labels (∗, ∗), vertices (ui, uj) have labels (∗, ∗).
By
Lemma 7.4, vertex wi lies on v and vertex wj lies on ˜v or vice versa. There-
fore, wi does not equal wj.
Since wi does not equal wj, line segment (ui, uj) maps to line segment
(wi, wj). Thus, |Υc(σ0, σ1)| ∩e equals line segment (wi, wj).
Let c′ be any other grid cube containing e. By the argument given above,
|Υc′(σ0, σ1)|∩e is a line segment. The labels of the endpoints of this line segment
and hence their geometric locations are determined by the labels of the endpoints
of e. Thus, |Υc′(σ0, σ1)| ∩e equals |Υc(σ0, σ1)| ∩e and their union is a line
segment.
We lastly must consider a grid cube c′ that contains only one endpoint of e.
By Property 4, if this endpoint has a negative or positive label, then the interval
volume patch of c′ does not contain this vertex. By Lemma 7.4, if this endpoint
has a star label, then it is a vertex of some tetrahedron in T I
c′. This vertex is in
|Υc′(σ0, σ1)| but it also is in |Υc(σ0, σ1)|. Thus, |Υc′(σ0, σ1)| ∩e is a subset of
|Υc(σ0, σ1)| ∩e and again their union is a line segment.
□
7.4.2
Proof of Interval Volume Properties 5-7
Deﬁne T I
Γ as the union of all the isosurface patch triangulations T I
c :
T I
Γ =

c∈Γ
T I
c .
Set |T I
Γ | is the union of all the tetrahedra in T I
Γ .
To prove Property 5, we show that |T I
Γ | separates the positive vertices of Γ
from the negative ones. We also show that T I
Γ is a triangulation. We deﬁne
a homotopy map η that maps this triangulation to the interval volume. Since
this triangulation does not cross any vertices, the interval volume separates the
positive vertices of Γ from the negative ones. Since the interval volume does
not contain any positive or negative vertices (Property 4), the interval volume
strictly separates the positive vertices of Γ from the negative ones.
In Sections 6.3.3 and 6.3.5, we gave deﬁnitions of positive regions and sep-
arating surfaces in 4D polytopes and meshes. We give similar deﬁnitions here

226
7. Interval Volumes
for the 4D convex polytope χ(c) and the 4D mesh χ(Γ). We use the proper
isosurface vertex sets U I
χ(c) as deﬁned in the previous section:
V +
χ(c)
=
the positive vertices of χ(c),
RI
χ(c)
=
conv

U I
χ(c) ∪V +
χ(c)

,
SI
χ(c)
=
RI
χ(c) ∩cl

χ(c) −RI
χ(c)

,
T I
χ(Γ)
=

c∈Γ
T I
χ(c),
RI
χ(Γ)
=

c∈Γ
RI
χ(c),
SI
χ(Γ)
=
RI
χ(Γ) ∩cl

|χ(Γ)| −RI
χ(Γ)

,
where |χ(Γ)| is the union of all the polytopes in χ(Γ). Note that the isosurface
vertex set U I
χ(c) is ﬁxed. In Chapter 6, we used a “+” superscript to indicate that
we are using positive, not negative, vertices of the polytope. For convenience,
we have dropped the “+” superscript in this chapter.
We also need to deﬁne positive regions and separating surfaces on the cube
facet χ(c) ∩h0 and the subgrid Γ ∩h0:
R0
χ(c)
=
conv((U I
χ(c) ∪V +
χ(c)) ∩h0),
S0
χ(c)
=
R0
χ(c) ∩cl((χ(c) ∩h0) −R0
χ(c)),
R0
χ(Γ)
=

c∈Γ
R0
χ(c),
S0
χ(Γ)
=
R0
χ(Γ) ∩cl(|χ(Γ) ∩h0| −R0
χ(Γ)).
We now show that S0
χ(Γ) equals SI
χ(Γ) ∩h0.
Lemma 7.6. If Γ is a convex polyhedral mesh in R3 where each vertex of Γ has
the label “−”, “+”, or “∗”, then S0
χ(Γ) equals SI
χ(Γ) ∩h0.
Proof:
S0
χ(Γ) =

c∈Γ
S0
χ(c)
(Lemma 6.19)
=

c∈Γ
(SI
χ(c) ∩h0)
(Lemma 6.25)
= h0 ∩

c∈Γ
SI
χ(c)
= h0 ∩SI
χ(Γ).
(Lemma 6.19)
Lemmas 6.25 and 6.19 are from Section 6.3.5.
□

7.4. MCVol Interval Volume Properties
227
(a)
(b)
−
−
−
−
−
−
−
+
+
+
+
∗
Figure 7.6. Two-dimensional example of interval π(RI
χ(c)). (a) Positive region RI
χ(c)
(red). (b) Red region is the projection π(RI
χ(c)). Blue region is π(f0 −R0
χ(c)), where f0
equals c ∩h0. Green line segment is π(SI
χ(c) ∩h0). Cyan vertices are in π(Uf0 ∪V +
f0 ).
Magenta vertices are in π((U I
χ(c) ∪V +
χ(c)) −(Uf0 ∪V +
f0 )).
As a corollary to Lemma 7.6, |T I
Γ | separates the positive vertices of Γ from
the negative ones.
Corollary 7.7. If Γ is a convex polyhedral mesh in R3 where each vertex of Γ has
the label “−”, “+”, or “∗”, then |T I
Γ | separates the positive vertices of Γ from
the negative ones.
Proof: Let π : R4 →R3 be the orthogonal projection of R4 onto R3. Set T I
Γ
is the orthogonal projection of T I
χ(Γ) into R3. By Lemma 6.22 (Section 6.3.5),
T I
χ(Γ) is a triangulation of SI
χ(Γ). By Lemma 7.6, S0
χ(Γ) is a subset of SI
χ(Γ). By
Lemma B.8 in Appendix B, S0
χ(Γ) separates R0
χ(Γ) from |χ(Γ) ∩h0| −R0
Γ. The
positive vertices in χ(Γ) ∩h0 are contained in R0
χ(Γ) while the negative ones are
contained in |χ(Γ) ∩h0| −R0
Γ.
Let v be a vertex in χ(Γ) ∩h0. If π(v) is positive, then v is positive. If π(v)
is negative, then v is negative. Let π0 be the restriction of π to the hyperplane
h0. Mapping π0 is a one-to-one mapping from h0 to R3. Since S0
χ(Γ) separates
the positive vertices of χ(Γ) ∩h0 from the negative ones, its projection π(S0
χ(Γ))
separates the positive vertices of Γ from the negative ones. Since |T I
Γ | contains
π(S0
χ(Γ)), set |T I
Γ | separates the positive vertices of Γ from the negative ones. □
By Lemma 6.22 (Section 6.3.5), T I
χ(Γ) is a triangulation of SI
χ(Γ). Set T I
Γ is
the projection of this triangulation into R3. To show that T I
Γ is a triangulation,
we show that this projection is one-to-one when restricted to SI
χ(Γ). We ﬁrst give
two properties of the projection π(RI
χ(c)) of RI
χ(c).

228
7. Interval Volumes
Lemma 7.8. Let c be a convex polyhedron in R3 where each vertex of c has the
label “−”, “+”, or “∗”. If π : R4 →R3 is the orthogonal projection of R4 onto
R3, then
1. projection π(RI
χ(c)) equals π(RI
χ(c) ∩h0),
2. projection π(RI
χ(c) −h0) does not intersect π(SI
χ(c) ∩h0).
Proof of 1: Let f0 equal h0 ∩χ(c). Deﬁne Uf0 and Vf0 as
Uf0 = U I
χ(c) ∩h0,
V +
f0 = V +
χ(c) ∩h0.
Note that R0
χ(c) equals conv(Uf0∪V +
f0 ). By Lemma 6.16 (Section 6.3.5), RI
χ(c)∩h0
equals R0
χ(c).
Case analysis (omitted) shows that π(U I
χ(c)∪V +
χ(c)) is contained in the convex
hull of π(Uf0 ∪V +
f0 ). (See 2D example in Figure 7.6.) Thus,
π

RI
χ(c)

= π

conv

U I
χ(c) ∪V +
χ(c)

= conv

π

U I
χ(c) ∪V +
χ(c)

⊆conv

π

Uf0 ∪V +
f0

= π

conv

Uf0 ∪V +
f0

= π

R0
χ(c)

= π

RI
χ(c) ∩h0

.
Since π(RI
χ(c) ∩h0) is clearly a subset of π(RI
χ(c)), the projection π(RI
χ(c)) equals
π(RI
χ(c) ∩h0).
□
Proof of 2: Let f0 equal h0 ∩χ(c).
Case analysis (omitted) shows that
π(U I
χ(c) −Uf0) does not intersect π(cl(f0 −R0
χ(c))). (See 2D example in Fig-
ure 7.6.) Similarly, π(V +
χ(c) −Vf0) does not intersect π(cl(f0 −R0
χ(c))). Thus
π(conv(U I
χ(c) ∪V +
χ(c)) −(Uf0 ∪V +
f0 )) does not intersect π(cl(f0 −R0
χ(c))).
Every point p ∈RI
χ(c) can be expressed as a convex combination of the points
in U I
χ(c) ∪V +
χ(c):
p =

qi∈UI
χ(c)∪V +
χ(c)
αiqi,
where 0 ≤αi ≤1.
If point p is not on hyperplane h0, then αi is greater
than zero for some qi ̸∈Uf0 ∪V +
f0 .
Since π(cl(f0 −R0
χ(c))) does not contain
qi, region π(cl(f0 −R0
χ(c))) does not contain p. Therefore, π(RI
χ(c) −h0) does
not intersect π(cl(f0 −R0
χ(c))). Since S0
χ(c) is contained in cl(f0 −R0
χ(c)), region
π(RI
χ(c) −h0) does not intersect π(S0
χ(c)). By Lemma 6.25 (Section 6.3.5), S0
χ(c)
equals SI
χ(c) ∩h0, so region π(RI
χ(c) −h0) does not intersect π(SI
χ(c) ∩h0).
□

7.4. MCVol Interval Volume Properties
229
*
p
(a)
(b)
(c)
−
−
−
−
−
−
−
−
−
−
−
−
+
+
+
+
+
+
+
q
q0
Figure 7.7. Two-dimensional example of π(SI
χ(c)). (a) Point p ∈π(SI
χ(c)). (b) Positive
region RI
χ(c) (red). (c) Point q0 equals π−1(p)∩h0. Line segment (q0, q) equals π−1(p)∩
RI
χ(c).
We show that the projection when restricted to an isosurface patch SI
χ(c) in
a single polyhedron χ(c) is one-to-one.
Lemma 7.9. Let c be a convex polyhedron in R3 where each vertex of c has the
label “−”, “+”, or “∗”. Let π : R4 →R3 be the orthogonal projection of R4 onto
R3. The projection π when restricted to SI
χ(c) is one-to-one.
Proof: Let p be a point in π(SI
χ(c)). The preimage, π−1(p), of p is a line in R4. By
Lemma 7.8, π(RI
χ(c)) equals π(RI
χ(c) ∩h0). Thus, line π−1(p) ∩RI
χ(c) intersects
h0 at some point q0 ∈h0. (See 2D example in Figure 7.7.)
We consider two cases, depending upon whether q0 is in S0
χ(c).
Case I: S0
χ(c) contains q0.
By Lemma 6.25 (Section 6.3.5), point q0 is in SI
χ(c) ∩h0 and p is in
π(SI
χ(c) ∩h0). By Lemma 7.8, π(RI
χ(c) −h0) does not intersect π(SI
χ(c) ∩h0).
Thus, q0 is the only point on π−1(p) ∩RI
χ(c) and thus the only point in
π−1(p) ∩SI
χ(c).
Case II: S0
χ(c) does not contain q0.
By Lemma 6.25, point q0 is not in SI
χ(c). By deﬁnition of SI
χ(c), point q0
is not in cl(χ(c) −RI
χ(c)).
Since RI
χ(c) is convex, line π−1(p) intersects RI
χ(c) in a point or a line
segment. Since q0 is in π−1(p) ∩RI
χ(c) but not in π−1(p) ∩SI
χ(c), the inter-
section π−1 ∩RI
χ(c) is not a single point. Thus line π−1(p) intersects RI
χ(c)
in a line segment. One endpoint of this line segment is the point q0. Let q
be the other endpoint.

230
7. Interval Volumes
Since RI
χ(c) is convex and q0 is not in cl(χ(c) −RI
χ(c)), no point of
π−1(p) ∩RI
χ(c) is in cl(χ(c) −RI
χ(c)) other than q. Thus q is the only point
on SI
χ(c) whose projection π(q) equals p.
□
As a corollary, the mapping π, restricted to SI
χ(Γ), is one-to-one.
Corollary 7.10. Let Γ be a convex polyhedral mesh in R3 where each vertex of Γ
has the label “−”, “+”, or “∗”. Let π : R4 →R3 be the orthogonal projection of
R4 onto R3. The projection π, when restricted to SI
χ(Γ), is one-to-one.
Proof: By Lemma 6.19 (Section 6.3.5), SI
χ(Γ) equals 
c∈Γ SI
χ(c). By Lemma 7.9,
the mapping π is one-to-one for every isosurface patch SI
χ(c) in a polytope χ(c).
By Corollary 6.26 (Section 6.3.5), Sχ(c) ∩f equals SI
χ(c′) ∩f for every pair of
polytopes χ(c) and χ(c′) sharing a face f. Thus π is one-to-one when restricted
to SI
χ(Γ).
□
As another corollary to Lemma 7.9, set T I
Γ is a triangulation.
Corollary 7.11. If Γ is a convex polyhedral mesh in R3 where each vertex of Γ has
the label “−”, “+”, or “∗”, then T I
Γ is a triangulation.
Proof: T I
Γ is the image of T I
χ(Γ) under the projection π. By Lemma 6.22 (Sec-
tion 6.3.5), T I
χ(Γ) is a triangulation of SI
χ(Γ). By Corollary 7.10, π is one-to-one
when restricted to SI
χ(Γ). Thus T I
Γ is a triangulation of π(SI
χ(Γ)).
□
Let Γ be a regular grid with scalar values at each of the grid vertices. Each
vertex vi of T I
Γ is mapped to some vertex wi of ΥΓ(σ0, σ1). For each vertex vi
of T I
Γ , deﬁne η(vi, α) as (1 −α)vi + αwi. Extend η to all of |T I
Γ | by linearly
extending η on each tetrahedron in T I
Γ . Thus η : T I
Γ × [0, 1] is a homotopy from
T I
Γ to |ΥΓ(σ0, σ1)| where η(T I
Γ , 0) equals |T I
Γ | and η(T I
Γ , 1) equals |ΥΓ(σ0, σ1)|.
We are ﬁnally ready to show that |ΥΓ(σ0, σ1)| strictly separates grid vertices
with scalar values less than σ0 from grid vertices with scalar values greater
than σ1.
Property 5.
The interval volume strictly separates vertices with scalar values
less than σ0 from vertices with scalar value greater than σ1.
Proof: Let v1 and v2 be vertices of Γ where v1 has scalar value less than σ0 and
v2 has scalar value greater than σ1. By Corollary 7.7, |T I
Γ | separates v1 from v2.
Map η is a homotopy from |T I
Γ | to |ΥΓ(σ0, σ1)| that never passes through v1
or v2. Vertices of |T I
Γ | that lie on the boundary of |Γ| remain on the boundary
of |Γ| throughout the homotopy η. Thus η(T I
Γ ∩∂|Γ|, α) is a subset of ∂|Γ| for
all α ∈[0, 1]. By Lemma B.18, |ΥΓ(σ0, σ1)| separates v1 from v2.
By Property 4, neither v1 nor v2 are in |ΥΓ(σ0, σ1)|. Thus |ΥΓ(σ0, σ1)| strictly
separates v1 from v2.
□

7.4. MCVol Interval Volume Properties
231
Set |ΥΓ(σ0, σ1)| is an embedding of |T I
Γ | into |Γ|. Even restricted to a single
cube, this embedding is not necessarily one-to-one. However, this embedding is
one-to-one when no vertex has scalar value equal to σ0 or σ1.
Deﬁne η1 : R3 →R3 as
η1(p) = η(p, 1),
where η is the homotopy map from |T I
Γ | to |ΥΓ(σ0, σ1)|.
Mapping η1 is the
embedding of |T I
Γ | into |Γ| that maps |T I
Γ | to |ΥΓ(σ0, σ1)|.
Lemma 7.12. Let σ0 and σ1 be scalar values with σ0 < σ1. Let c be a cube in R3
where each vertex v of c has a scalar value, sv, and each vertex v has a negative
label if sv < σ0, a positive label if sv > σ1, or a star label if σ0 ≤sv ≤σ1. If no
vertex of c has scalar value equal to σ0 or σ1, then η1 : |T I
c | →|Υc(σ0, σ1)| is
one-to-one and orientation preserving.
The proof for Lemma 7.12 is a computer-based analysis and is omitted.
We claim that if no vertex of regular grid Γ has scalar value σ0 or σ1, then
η1 is one-to-one. The proof is a corollary to the following lemma.
Lemma 7.13. Let σ0 and σ1 be scalar values with σ0 < σ1. Let c be a convex
polyhedron in R3 where each vertex v of c has a scalar value, sv, and each vertex
v has a negative label if sv < σ0, a positive label if sv > σ1, or a star label if
σ0 ≤sv ≤σ1. Let f be a vertex, edge, or face of c. If no vertex of f has scalar
value σ0 or σ1, then η1(|T I
Γ |) ∩f equals η1(|T I
Γ | ∩f).
Proof: Since T I
c is the triangulation of |T I
c |,
η1(|T I
c |) =

t∈T I
c
η1(t).
Let t be a tetrahedron in T I
c . Since no vertex of f has scalar value σ0 or σ1, a
vertex v of t lies on f if and only if η1(t) lies on f. Since η1 is linear on t and t
is the convex hull of its vertices, η1(t) ∩f equals η1(t ∩f). Thus,
η1(|T I
c |) ∩f
=

t∈T I
c
(η1(t) ∩f) =

t∈T I
c
η1(t ∩f) = η1
⎛
⎝
t∈T I
c
(t ∩f)
⎞
⎠
=
η1(|T I
c | ∩f).
□
Corollary 7.14. Let σ0 and σ1 be scalar values with σ0 < σ1. Let Γ be a regular
grid in R3 where each vertex v of c has a scalar value, sv, and each vertex v has a
negative label if sv < σ0, a positive label if sv > σ1, or a star label if σ0 ≤sv ≤σ1.
If no vertex of f has scalar value σ0 or σ1, then η1 : |T I
Γ | →|ΥΓ(σ0, σ1)| is one-
to-one.

232
7. Interval Volumes
Proof: Assume that there are distinct points p, p′ ∈|T I
Γ | such that η1(p) equals
η1(p′). By Lemma 7.12, function η1 is one-to-one when restricted to |T I
c | for a
single cube c. Thus points p and p′ must belong to diﬀerent grid cubes c and c′.
Since c contains η1(|T I
c |) and c′ contains η1(|T I
c′|), point η1(p) = η1(p′) must lie
in f = c ∩c′. Since Γ is a regular grid, f is a face of c.
By assumption, no vertex of f has value σ0 or σ1. By Lemma 7.13, η1(|T I
c |)∩f
equals η1(|T I
c | ∩f). Thus η1(p) ∈η1(|T I
c |) ∩f must be equal η1(q) for some
q ∈|T I
c | ∩f.
Since η1 is one-to-one on |T I
c |, point p must equal q and so
p ∈|T I
c | ∩f. Since f is a face of c′, point p is also in c′. Since η1 is one-to-one
on |T I
c′| and p, p′ ∈|T I
c′|, point p must equal p′, a contradiction. We conclude
that η1 : |T I
Γ | →|ΥΓ(σ0, σ1)| is one-to-one.
□
Finally, we show that if no grid vertex has scalar value equal to σ0 or σ1,
then |ΥΓ(σ0, σ1)| is a three-dimensional manifold with boundary.
Property 6.
The interval volume is a piecewise linear, orientable 3-manifold
with boundary.
Proof: By Lemma 6.31 (Section 6.3.5), the set SI
χ(Γ) is a piecewise linear, ori-
entable 3-manifold with boundary. By Lemma 7.9, the projection of SI
χ(Γ) into
R3 is one-to-one and so |T I
Γ | is an orientable 3-manifold with boundary. Set
|ΥΓ(σ0, σ1)| is an embedding of |T I
Γ | into |Γ|. By Corollary 7.14, this embedding
is one-to-one. Thus, |ΥΓ(σ0, σ1)| is an orientable 3-manifold with boundary. □
Property 7.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra and the tetrahedra in Υ form a triangulation of the interval volume.
Proof: By Corollary 7.11, T I
Γ is a triangulation.
Function η1 maps tetrahe-
dra in T I
Γ to tetrahedra in ΥΓ(σ0, σ1). Since η1 is continuous and one-to-one,
ΥΓ(σ0, σ1) is a triangulation of |ΥΓ(σ0, σ1)| and has no duplicate tetrahedra.
Since no tetrahedron in T I
Γ has zero volume, no tetrahedron in ΥΓ(σ0, σ1) has
zero volume.
□
7.5
Tetrahedral Meshes
Nielson and Sung [Nielson and Sung, 1997] gave a version of MCVol for tetra-
hedral meshes. Their algorithm stores triangulated interval volume patches in an
interval volume lookup table and retrieves the patches to build interval volumes
within each tetrahedra. We call the algorithm MTetVol. Just as with cubes,
it is important that the triangulation of an interval volume patch matches the
triangulation of neighboring patches. Nielson and Sung constructed the lookup
table by hand, but we use algorithm IVolPatch3D to generate the interval
volume patches in the lookup table.

7.5. Tetrahedral Meshes
233
Read tetrahedral interval volume lookup table

For each mesh tetrahedron, retrieve interval volume tetrahedra

Compute vertex coordinates using linear interpolation
Figure 7.8. MTetVol. Algorithm to construct a piecewise linear approximation to
the interval volume in a tetrahedral mesh.
7.5.1
Algorithm
Input to the MTetVol algorithm is two scalar values, σ0 and σ1, a three-
dimensional tetrahedral mesh and a set of scalar values at the vertices of the
mesh. The algorithm has three steps. (See Figure 7.8.) Read an interval volume
lookup table from a preconstructed data ﬁle. For each mesh tetrahedron, retrieve
from the lookup table a set of isosurface tetrahedra representing the combinato-
rial structure of the isosurface. The vertices of the isosurface tetrahedra form the
isosurface vertices. Assign geometric locations to the isosurface vertices based
on the scalar values at the simplex endpoints.
The isosurface lookup table is built on the “generic” tetrahedron cT whose
vertices are
(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1).
Any other tetrahedron could also have been used. Algorithm IVolPatch3D
is applied to each of the 34 = 81 conﬁgurations of positive, negative, and star
vertex labels to generate 81 interval volume patches in 81 table entries.
For each mesh tetrahedron c, the the isosurface patch triangulation retrieved
from the lookup table depends on how the simplex is mapped to cT . There are
4! ways to map the vertices of c to cT . Each such mapping represents a diﬀerent
aﬃne transformation of c to cT . However, only one such mapping preserves the
lexicographic order of the vertices. If v1, v2, v3, and v4 are the vertices of c in
lexicographic order, then map vertex v1 to (0, 0, 0), vertex v2 to (1, 0, 0), vertex
v3 to (0, 1, 0), and vertex v4 to (0, 0, 1). This mapping sends the ith vertex of c
in lexicographic order to the ith vertex of cT in lexicographic order.
The ﬁnal step is mapping each triangulation vertex to its geometric loca-
tion. We use linear interpolation as described in Section 1.7.2 to position the
triangulation vertices.

234
7. Interval Volumes
Each pair (g, L) corresponds to a vertex in the triangulation of the interval
volume. For each such pair, element g is either a grid vertex or a grid edge. If g
is a grid vertex v, then the location of vertex (g, L) is the location of vertex v.
Assume g is a grid edge [p, q]. Let sp and sq be the scalar values at p and q. If L
is “−”, then map (g, L) to (1 −α0)p + α0q where α0 = (σ0 −sp)/(sq −sp). If L
is “+”, then map (g, L) to (1 −α1)p + α1q where α1 = (σ1 −sp)/(sq −sp). Note
that if L is “−” or “+”, then p and q must have diﬀerent labels. Thus, scalar sp
does not equal sq and the denominator (sq −sp) is never zero.
7.5.2
Interval Volume Properties
The interval volume produced by MTetVol has the same properties as the one
produced by MCVol. Under appropriate conditions the interval volume is a
3-manifold with boundary
MTetVol returns a ﬁnite set, Υ, of orientable tetrahedra.
The interval
volume is the union of these tetrahedra. The vertices of the interval volume are
the tetrahedra vertices.
The following properties apply to all interval volumes produced by the MTet-
Vol algorithm. The scalar value at a mesh vertex v is denoted sv.
Property 1.
The interval volume is piecewise linear.
Property 2.
The vertices of the interval volume lie on mesh vertices or mesh
edges.
Property 3.
The interval volume contains every mesh vertex v where σ0 ≤sv ≤
σ1 and intersects each mesh edge (v, ˜v) where sv < σ1 and s˜v > σ0 (or vice
versa) in a line segment.
Property 4.
The interval volume does not contain any mesh vertex v where
sv < σ0 or sv > σ1 and does not intersect any mesh edges (v, ˜v) where both sv
and s˜v are strictly less than σ0 or both sv and s˜v are strictly greater than σ1.
Property 5.
The interval volume strictly separates vertices with scalar values
less than σ0 from vertices with scalar value greater than σ1.
Properties 3 and 4 imply that the interval volume intersects a minimum
number of mesh edges.
Consider a simplicial mesh which has the following conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The mesh is a partition of a 4-manifold with boundary.
Under these conditions, the interval volume produced by MTetVol has the
following properties:

7.6. Convex Polyhedral Meshes
235
Property 6.
The interval volume is a piecewise linear, orientable 3-manifold
with boundary.
Property 7.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra and the tetrahedra in Υ form a triangulation of the interval volume.
Proofs of the properties for the MTetVol interval volume are similar to the
proofs for the MCVol interval volume and are omitted.
7.6
Convex Polyhedral Meshes
Algorithm MCVol also generalizes to meshes of convex polyhedral elements.
The three-dimensional Marching Polyhedra algorithm generalizes to four-
dimensional convex meshes. The algorithm is called MPolyVol.
7.6.1
Algorithm
As with MTetVol, care must be taken to ensure that triangulations of adja-
cent interval volume patches match. To do so, we require an additional input,
an ordering of all the mesh vertices. This ordering will be used to control the
mapping to the isosurface lookup tables so that triangulations of adjacent iso-
surface patches match. This ordering could be a lexicographic ordering on all
the mesh vertices but other orders may be preferable.
As in the Marching Polyhedra algorithm for isosurface construction, we
assume that the mesh is composed of a ﬁxed, predeﬁned set of polytope classes
(Section 5.4.) Each class a has a precomputed isosurface lookup table built on
a “generic” polytope ca. For isosurface construction, a mesh polytope c is in
class a if there is an aﬃne transformation from c to ca. Because triangulations
of adjacent interval volume patches must match, this partition into classes needs
to be further reﬁned for interval volume construction.
The ordering of mesh vertices input to MPolyVol induces an ordering of the
vertices of each mesh element. For each class a, the “generic” polytope ca has an
ordering on its vertices that is used in constructing the isosurface lookup table
for class a. More speciﬁcally, this order determines the incremental triangulation
of each interval volume patch constructed by algorithm IVolPatch3D. A mesh
polytope c is in class a if there is an aﬃne transformation from c to ca that
preserves the vertex order. In other words, the aﬃne transformation should map
the ith vertex of c (given by the input ordering of mesh vertices) to the ith vertex
of ca.
Input to MPolyVol algorithm is two scalar values, σ0 and σ1, a three-
dimensional convex polyhedral mesh, a set of scalar values at the vertices of the
mesh, a sequence of all the mesh vertices, and a set of polyhedron classes.

236
7. Interval Volumes
Read interval volume lookup tables for each polyhedron class

For each mesh polytope, retrieve interval volume tetrahedra

Compute vertex coordinates using linear interpolation
Figure 7.9. MPolyVol. Algorithm to construct a piecewise linear approximation to
the interval volume in a convex polyhedral mesh.
The MPolyVol algorithm has three steps.
The ﬁrst step is reading the
interval volume lookup tables for each class from preconstructed data ﬁles. Next,
for each mesh element, a triangulated interval volume patch is retrieved from the
appropriate table. Finally, the vertices of the interval volume patch are assigned
geometric locations using linear interpolation. We explain the last two steps in
more detail.
Let c be a mesh element. The input sequence of mesh vertices represents
an ordering of the mesh vertices. Restricted to the vertices of c, this ordering
gives an ordering of the vertices of c. Let a be the polytope class of c where
some aﬃne transformation preserving vertex order maps c to ca. To retrieve an
isosurface patch for mesh element c from the isosurface lookup table for class
a, the ith vertex of c is mapped to the ith vertex of the lookup table polytope.
This mapping determines a conﬁguration of positive, negative, and star vertices
that identiﬁes the appropriate entry in the lookup table.
The ﬁnal step is mapping each triangulation vertex to its geometric loca-
tion. We use linear interpolation as described in Section 1.7.2 to position the
triangulation vertices.
Each pair (g, L) corresponds to a vertex in the triangulation of the interval
volume. For each such pair, element g is either a mesh vertex or a mesh edge. If
g is a mesh vertex v, then the location of vertex (g, L) is the location of vertex
v. Assume g is a mesh edge [p, q]. Let sp and sq be the scalar values at p and q.
If L is “−”, then map (g, L) to α0p + (1 −α0)q where α0 = (sp −σ0)/(sq −sp).
If L is “+”, then map (g, L) to α1p + (1 −α1)q where α1 = (sp −σ1)/(sq −sp).
Note that if L is “−” or “+”, then p and q must have diﬀerent labels. Thus,
scalar sp does not equal sq and the denominator (sq −sp) is never zero.
MPolyVol requires some ordering of mesh vertices to determine the map-
ping of mesh elements to their isosurface lookup tables. This ordering could
simply be a lexicographic ordering of mesh vertices. However, as noted in Sec-
tion 6.5.3, alternate orderings may be preferable. For instance, the lexicographic

7.6. Convex Polyhedral Meshes
237
ordering of vertices in a pyramidal decomposition of the regular grid requires
three pyramid isosurface lookup tables, one for each possible location of the
pyramid apex in the order. The ordering given in Section 6.5.3 requires only a
single pyramid isosurface vertex lookup table.
7.6.2
Interval Volume Properties
The interval volume produced by MPolyVol has the same properties as the
one produced by MCVol. Under appropriate conditions the interval volume is
a 3-manifold with boundary
MPolyVol returns a ﬁnite set, Υ, of oriented tetrahedra.
The interval
volume is the union of these tetrahedra. The vertices of the interval volume are
the tetrahedra vertices.
The following properties apply to all interval volumes produced by the MPoly-
Vol algorithm. The scalar value at a mesh vertex v is denoted sv.
Property 1.
The interval volume is piecewise linear.
Property 2.
The vertices of the interval volume lie on mesh vertices or mesh
edges.
Property 3.
The interval volume contains every mesh vertex v where σ0 ≤sv ≤
σ1 and intersects each mesh edge (v, ˜v) where sv < σ1 and s˜v > σ0 (or vice
versa) in a line segment.
Property 4.
The interval volume does not contain any mesh vertex v where
sv < σ0 or sv > σ1 and does not intersect any mesh edges (v, ˜v) where both sv
and s˜v are strictly less than σ0 or both sv and s˜v are strictly greater than σ1.
Property 5.
The interval volume strictly separates vertices with scalar values
less than σ0 from vertices with scalar value greater than σ1.
Properties 3 and 4 imply that the interval volume intersects a minimum
number of mesh edges.
As with Marching Polytopes, “complex” mesh elements could create in-
terval volume patches that self-intersect, even if the isovalue does not equal the
scalar value of any mesh vertex. To ensure a manifold, we restrict the mesh ele-
ments to a few simple types, such as cubes, tetrahedra, and pyramids. This list is
not meant to be exhaustive and many other convex polytopes could probably be
added. Consider a mesh of convex polytopes that has the following conditions:
• The isovalue does not equal the scalar value of any mesh vertex.
• The mesh is a partition of a 3-manifold with boundary.

238
7. Interval Volumes
• The mesh elements are aﬃne transformations of cubes, tetrahedra, and
pyramids over a square base.
Under these conditions, the interval volume produced by MPolyVol has the
following properties:
Property 6.
The interval volume is a piecewise linear, orientable 3-manifold
with boundary.
Property 7.
Set Υ does not contain any zero-volume tetrahedra or duplicate
tetrahedra and the tetrahedra in Υ form a triangulation of the interval volume.
Proofs of the properties for the MPolyVol interval volume are similar to
the proofs for the MCVol interval volume and are omitted.
7.7
Notes and Comments
Guo [Guo, 1995] and Fujishiro et al. [Fujishiro et al., 1996] independently intro-
duced interval volumes. Guo constructed the interval volumes using Delaunay
triangulations. Fujishiro et al. constructed interval volumes as the diﬀerence of
two solid regions bounded by isosurfaces. Nielson and Sung [Nielson and Sung,
1997] gave the algorithm presented in Section 7.5 for constructing an interval
volume from a tetrahedral mesh. They built the lookup table by hand instead
of automatically generating it using algorithm IVolPatch3D.
The interval volume algorithms in Sections 7.2, 7.3, and 7.6 are described
in [Bhaniramka et al., 2004b] and are based on techniques from [Bhaniramka
et al., 2000,Bhaniramka et al., 2004a].
Labelle and Schewchuk use interval volumes in [Labelle and Shewchuk, 2007]
to construct tetrahedral meshes with good tetrahedral mesh elements. They give
guaranteed lower and upper bounds on the dihedral angles of the tetrahedra
forming the mesh.

CHAPTER 8
DATA STRUCTURES FOR FASTER
ISOSURFACE CONSTRUCTION
Much of the running time of the Marching Cubes algorithm and its variants is
spent processing grid cubes that are not intersected by the isosurface. While it is
theoretically possible for an isosurface to intersect every grid cube in the input,
in practice a single isosurface intersects only a small fraction of the input grid
cubes. A grid cube that is not intersected by a given isosurface is called an empty
cube. Of course, whether a cube is empty depends upon the given isosurface.
To improve the running time of isosurface extraction algorithms, data struc-
tures have been designed for quickly identifying the grid cubes intersected by
isosurfaces. These data structures can be divided into three categories: parti-
tions of the domain, partitions of the range, and seed sets. The domain is the
volume covered by the input grid. The range is the interval from the smallest to
the largest scalar value at any grid vertex.
The span of a set C of grid cubes or mesh elements is the interval from the
minimum scalar value smin(C) to the maximum scalar value smax(C) of any cube
vertex or element vertex. For instance, the cube in Figure 8.1 has span [2,7]. If
an isovalue lies in the span of a cube, then the corresponding isosurface intersects
the cube. If the isovalue lies in the span of a set of cubes, then the isosurface
intersects at least one cube in that set.
Both domain and range data structures compute the spans of sets of cubes
and compare those spans to the isovalue to determine if the isosurface intersects
the set. The diﬀerence is that domain-based structures group together cubes
that are geometrically close to one another while the range data structures group
together cubes that have similar spans.
Uniform partitioning (Section 8.1) and octrees (Section 8.2) are both domain-
based methods. In uniform partitioning, the grid is divided into a set of uniform
239

240
8. Data Structures
2
3
4
4
5
5
7
7
Figure 8.1. Cube with span [2,7].
k × k × k regions while octrees represent multiple layers of subdivisions of the
grid. The root of the octree represents the entire grid while the leaves represent
individual grid cubes.
The span space priority tree (Section 8.3) is a range-based method. The grid
cubes are organized in a priority tree whose keys are based on the spans of the
grid cubes.
The third approach to faster isosurface retrieval is based on “growing” iso-
surfaces from a small set of cubes. Starting from an initial “seed set” of cubes,
one determines which cubes in the seed set are intersected by the isosurface. One
then grows the isosurface from each such seed cube, checking whether neighbor-
ing cubes are intersected by the isosurface. If a neighboring cube is intersected
by the isosurface, then it is processed and its neighbors are checked.
If no cube in the seed set intersects the isosurface, then seed growing will not
ﬁnd any of the cubes intersecting the isosurface. Even if the seed set intersects
the isosurface, seed growing may ﬁnd only a subset of the cubes intersecting
an isosurface with more than one connected component. The challenge is to
ﬁnd a small seed set such that for any isovalue seed growing ﬁnds all the cubes
intersecting the isosurface.
Each data structure is associated with two algorithms, one to build the data
structure and one to search the data structure and retrieve cubes intersected
by the isosurface.
The data structures reduce isosurface extraction time by
avoiding the processing of empty grid cubes that do not intersect the isosurface.
However, building a data structure requires processing each cube in the grid.
If only a single isosurface is to be extracted from a grid, then the time saved
in the extraction phase is outweighed by the time to create the data structure.
Thus, using data structures is only productive if more than one isosurface is to
be extracted from a scalar grid.

8.1. Uniform Grid Partitions
241
2
1
3
4
5
4
2
1
3
3
5
6
7
5
4
4
8
9
5
6
7
[5,9]
[1,5]
[3,6]
[4,7]
[2,6]
[3,8]
2
6
5
(a)
(b)
(c)
Figure 8.2. Example of uniform partitioning into 2 × 2 regions. (a) 2D scalar grid; (b)
Uniform partition into 2 × 2 regions. Note that some regions extend beyond the grid
boundary. (c) Span associated with each grid region.
8.1
Uniform Grid Partitions
Uniform partitioning is the partitioning of a grid into regions of cube dimensions
k × k × k, i.e., every region edge is composed of k grid edges. (See Section 1.7.1
for the deﬁnition and an example of cube dimensions.) The span of each region
is computed and stored. To identify the cubes intersected by the isosurface, the
span of each region is compared with the isovalue. If the isovalue is contained in
the span, then isosurface patches are extracted from the k3 cubes in the region.
Of course, some cubes may be empty, in which case their isosurface patches
will be empty. If the isovalue is not contained in the region’s span, then the
cubes in the region are ignored, saving the time to compare k3 cubes with the
isovalue. The method is simple, yet results in signiﬁcant reductions of isosurface
extraction time.
For each k × k × k region, we store the span of the region, the minimum and
maximum values of all grid vertices in the region. We also store a reference to
the grid cube with the lowest coordinates in the region. All the other grid cubes
in the region can be computed from this reference grid cube.
If the grid has cube dimensions mx × my × mz and some mi is not a multiple
of k, then the grid cannot be exactly partitioned into k × k × k regions. Instead,
we let some regions extend beyond the grid boundary. (See Figure 8.2 for a
two-dimensional example.) These partial regions contain fewer than k3 cubes.
Because it is easier and faster to process full regions than partial ones, the partial
regions should be kept in a list separate from the full ones.

242
8. Data Structures
rx ←⌈mx/k⌉
ry ←⌈my/k⌉
rz ←⌈mz/k⌉

Uniformly partition [0, krx] × [0, kry] × [0, krz]
into rx × ry × rz cubic regions of dimensions k × k × k

For each region R,
R.minvalue ←min{sv : Grid vertex v is in region R }
R.maxvalue ←max{sv : Grid vertex v is in region R }
Figure 8.3. BuildUniform. Input is a positive integer k and a scalar grid with cube
dimensions mx × my × mz.
Input
: Isovalue is the isovalue.
Regions is a set of regions.
Each region has a minvalue and a maxvalue.
SearchUniformPartition(Isovalue, Regions)
1 foreach R ∈Regions do
2
if (R.minvalue ≤Isovalue ≤R.maxvalue) then
3
foreach cube c ∈R do
4
if (c.minvalue ≤Isovalue ≤c.maxvalue) then
5
Report(c);
6
end
7
end
8
end
9 end
Algorithm 8.1. SearchUniformPartition.
8.2
Octrees
While uniform grid partitions are simple, they have two drawbacks. First, users
must decide on a region size k for the k×k×k regions. Diﬀerent region sizes may
be better for diﬀerent scalar data sets. Even for a ﬁxed data set, the optimal

8.2. Octrees
243
Figure 8.4. Partition of a cube into eight octants.
region sizes may depend upon the isovalue. Second, even for a ﬁxed data set and
scalar value, some portions of the data set may have large empty regions while
others have smaller ones. Using a single region size for the entire set may also
result in suboptimal performance.
8.2.1
Full Octrees
An octree is a tree representing a decomposition of some three-dimensional vol-
ume. Each node in the tree represents some subregion of the volume. A region
is partitioned into eight octants by dividing the region with three axis-parallel
planes through a “center” point. (See Figure 8.4.) What constitutes the “cen-
ter” point for a region depends upon the application. Each internal node has
eight children representing the eight octants, hence the name “octree.” The root
represents the entire volume.
A similar data structure in two dimensions is a quadtree where each region is
partitioned into four quadrants by two axis-parallel lines through a center point.
(See Figure 8.6.) The data structure can also be generalized to d dimensions,
where each region is partitioned into 2d regions by d axis-parallel planes. Un-
fortunately, the data structure is misleadingly still called an octree in higher
dimensions, even though each node has 2d, not eight, children.
In isosurface construction, octrees are used to partition regular grids into
subregions. The leaves of the octree represent individual grid cubes. The parents
of leaves represent 2×2×2 regions, each containing eight grid cubes. The parents
of those nodes represent 4× 4 × 4 regions, each containing eight 2 × 2 × 2 regions
and 64 grid cubes. Nodes at height h in the tree represent regions with dimension
2h × 2h × 2h, each containing 23h cubes. The root represents the entire grid.

244
8. Data Structures
Create root node Root

Root.cube0 ←reference to cube (0, 0, 0)

GrowFullNode(Root,h)
Figure 8.5. BuildIsoOctree. Input is a scalar grid with cube dimensions 2h×2h×2h.
2
1
3
4
5
4
2
1
3
3
5
6
7
5
4
4
8
5
6
5
6
5
4
3
5
[4:8]
[4:7]
[1:5]
[3:6]
[1:8]
[4:8] [4:8] [4:7] [5:7]
[3:5] [4:7] [5:7]
[3:5]
[2:5] [4:6] [4:6]
[1:2] [1:4] [3:5] [3:5]
[1:3]
(a)
(b)
(c)
(d)
(e)
Figure 8.6. Example of a quadtree. (a) Scalar grid. (b) Span intervals at grid cubes.
(c) Span intervals at 2×2 regions. (d) Span intervals at 4×4 regions. (e) Full quadtree.

8.2. Octrees
245
A full octree is an octree whose internal nodes have exactly eight children. If
a grid has cube dimensions 2h × 2h × 2h, then it can be represented by a full
octree, all of whose leaves are at depth h in the tree. A 2h × 2h × 2h grid divides
perfectly into eight 2h−1×2h−1×2h−1 regions. Each 2i×2i×2i regions subdivides
perfectly into eight 2i−1×2i−1×2i−1 and the 2×2×2 regions subdivide perfectly
into eight cubes. However, if a grid has cube dimensions m × m × m and m is
not a power of two, or if a grid has cube dimensions mx × my × mz and the mi
have diﬀerent values, then there is no such perfect subdivision. We shall discuss
octrees for such grids in the next section. For now, we restrict ourselves to the
idealized case of grids with cube dimensions 2h × 2h × 2h.
At each node in the octree, we store the span of the corresponding region, by
storing the minimum and maximum values of all grid vertices in the region. We
also store a reference to the grid cube with the lowest coordinates in the region.
Each internal octree node has eight children. Instead of storing eight refer-
ences, we allocate the nodes representing the eight children in a single array of
eight nodes and store a reference to the array. The jth child of the node is the
jth node in this array.
The octree is built recursively, starting at the root. At the root we store a
reference to cube (0,0,0), the cube with lowest coordinates in the grid. To add
children to the root we call the procedure GrowFullNode (Algorithm 8.2).
GrowFullNode takes two parameters, a node from the octree and the height
of the node.
The height of the octree root is h where 2h × 2h × 2h are the
dimensions of the input grid.
GrowFullNode processes its input node as follows. If the height of the
node is zero, then the node is a leaf of the tree corresponding to a single cube.
The node contains a reference to that cube. GrowFullNode computes the
minimum and maximum scalar values over all vertices of that cube and stores
those values to represent the span of the node.
If the height of the node is not zero, then the node is an internal one. The
node represents a region of dimensions 2Height × 2Height × 2Height starting at the
cube referenced by the node. GrowFullNode creates an array of eight child
nodes and stores a reference to that array in the parent node.
Let L equal 2Height−1. Each child node represents an L × L × L region and
contains a reference to the cube with lowest coordinates in that region. The
cube for the ﬁrst child node is the same as the cube for its parent. The re-
gion and cube for the second child node are translates along the x-axis of the
region and cube for the ﬁrst child node. Let (x0, y0, z0) be the coordinates of
the cube for the ﬁrst child node. The cube for the second child node has coor-
dinates (x0, y0, z0) + (L, 0, 0) = (x0 + L, y0, z0). The cubes for the third through
eighth child nodes are translates of the cube for the ﬁrst child node in directions
(0, L, 0), (L, L, 0), (0, 0, L), (L, 0, L), (0, L, L), and (L, L, L), respectively. For each
child node, GrowFullNode stores a reference to the cube with the appropriate
coordinates.

246
8. Data Structures
Input
: Node is an octree node.
Height is the height of Node in the octree.
GrowFullNode(Node, Height)
1 if Height = 0 then
2
Node.minvalue ←minimum scalar value of any vertex of Node.cube0;
3
Node.maxvalue ←maximum scalar value of any vertex of Node.cube0;
4
return;
5 end
6 L ←2Height−1 ;
7 (x0, y0, z0) ←coordinates of Node.cube0;
8 Create array, NodeArray, of eight new octree nodes;
9 Node.child ←reference to array NodeArray;
10 j ←0;
11 for ix = 0 to 1 do
12
for iy = 0 to 1 do
13
for iz = 0 to 1 do
14
(x, y, z) ←(x0 + ix × L, y0 + iy × L, z0 + iz × L);
15
NodeArray[j].cube0 ←reference to cube (x, y, z);
16
j ←j + 1;
17
end
18
end
19 end
20 for i = 0, . . . , 7 do
21
GrowFullNode(NodeArray[i], Height-1);
22 end
23 Node.minvalue ←minimum of {NodeArray[i].minvalue }i=0,...,7;
24 Node.maxvalue ←maximum of {NodeArray[i].maxvalue }i=0,...,7;
Algorithm 8.2. GrowFullNode.
To create subtrees at each child node, GrowFullNode recursively calls it-
self on each child node. The recursive call sets the minimum and maximum scalar
values for each child node. These values represent the minimum and maximum
scalar values over all vertices in the corresponding region. GrowFullNode
sets the minimum and maximum scalar values for the parent node by comput-
ing the minimum over all the minimum scalar values and the maximum over all
maximum scalar values of the child nodes.
The algorithm to search the octree takes an isovalue σ as input. Starting
at the octree root, the search algorithm processes an internal octree node by
determining if σ lies in the interval between the nodes minimum and maximum
values. If σ lies in the interval, then the search algorithm recursively processes

8.2. Octrees
247
Input
: Isovalue is the isovalue.
Node is an octree node.
Height is the height of Node in the octree.
SearchBON(Isovalue, Node, Height)
1 if (Node.minvalue ≤Isovalue ≤Node.maxvalue) then
2
if Height = 0 then
3
Report(Node.cube0);
4
else
5
k ←Node.numChildren;
6
for j = 0, . . . , k −1 do
7
SearchBON(Isovalue, Node.child (j), Height-1);
8
end
9
end
10 end
Algorithm 8.3. SearchBON.
the node’s children. If σ does not lie in the interval, then the search algorithm
does not intersect the region represented by the node and the entire subtree
rooted at that node is ignored.
The search algorithm recursively processes internal nodes until it reaches
the octree leaves. It again determines if σ lies in the interval between the nodes
minimum and maximum values. If σ lies in the interval, then the cube referenced
at that node is added to a list of intersected cubes.
8.2.2
Branch on Need Octrees
When a grid does not have cube dimensions 2h × 2h × 2h, then its subdivisions
cannot be represented by a full octree. One solution might be to pad the grid
with extra cubes until it has dimensions 2h × 2h × 2h. Unfortunately, such a
padding of an m × m × m grid could increase the number of cubes by a factor of
eight. If the grid has cube dimensions mx × my × mz where not all the mi are
equal, the increase could be much larger.
The solution presented here is the branch-on-need (BON) octree proposed by
Wilhelms and Van Gelder [Wilhelms and Gelder, 1992]. Let mx×my×mz be the
cube dimensions of the input grid and let (0, 0, 0) be its vertex with lowest coordi-
nates. Let 2h be the smallest power of two that is greater than max(mx, my, mz).
The root of the octree represents a 2h × 2h × 2h region extending from (0, 0, 0)
to (2h, 2h, 2h). This region covers the grid. If mi does not equal 2h, then this
region will extend beyond the edge of the grid.

248
8. Data Structures
The root region is partitioned into eight congruent octants by dividing it
with three axis-parallel planes through the point (2h−1, 2h−1, 2h−1). Some of
these octants will intersect the grid but some may not.
Add a child to the
root for each octant that contains one or more grid cubes. Octants that do not
contain any grid cubes are not represented in the tree, hence the name “Branch
on Need.”
Each internal node in the tree represents a cubical region that intersects
the input grid. The three axis-parallel planes through the center of the region
partition the region into eight congruent octants. As with the root, some of the
octants will intersect the input grid but some may not. The node contains a
child for each octant that contains one or more grid cubes. Each internal nodes
has one to eight children.
The leaves of the octree are individual grid cubes. Because every node of the
tree at depth d represents a 2h−d × 2h−d × 2h−d region, every leaf has depth h.
Thus all leaves are at the same level in the tree.
The number of leaves in the branch-on-need octree is mx × my × mz, the
number of cubes in the input grid. The nodes at height one in the tree represent
cubical regions of dimension 2×2×2. They form a grid of dimensions ⌈mx/2⌉×
⌈my/2⌉× ⌈mz/2⌉where the cubes in the grid are 2 × 2 × 2 regions. If some mi
are odd, then some of these 2 × 2 × 2 regions will extend beyond the end of the
input grid.
Nodes at height j of the tree represent cubical regions of dimension 2j×2j×2j.
These regions form a grid of dimensions ⌈mx/2j⌉× ⌈my/2j⌉× ⌈mz/2j⌉where
the cubes in the grid are 2j × 2j × 2j regions. If some mi is not divisible by j,
then some of these 2j × 2j × 2j regions will extend beyond the end of the input
grid.
As in the full octree, each node in the branch-on-need octree contains the
minimum and maximum values of all grid vertices in its corresponding region
and a reference to the grid cube with the lowest coordinates in the region. Each
internal node contains a reference to a single array of nodes that stores its chil-
dren. The kth child of the node is the kth node in this array. However, the
number of children is not necessarily eight as it is in the full octree. Each inter-
nal node in the branch-on-need octree explicitly stores its number of children.
To build the branch-on-need octree on an mx × my × mz input grid, we ﬁrst
compute the smallest h such that 2h ≥max(mx, my, mz). The root of the octree
represents a 2h × 2h × 2h region.
The octree is built recursively, starting at the root. At the root we store
a reference to cube (0,0,0), the cube with the lowest coordinates in the grid.
To add children to the root we call the procedure GrowBON (Algorithm 8.4).
GrowBON takes two parameters, a node from the octree and the height of the
node. The height of the octree root is h.
GrowBON processes its input node as follows. If the height of the node
is zero, then the node is a leaf of the tree corresponding to a single cube. The
node contains a reference to that cube. GrowBON computes the minimum and

8.2. Octrees
249
Input
: Node is an octree node.
Height is the height of Node in the octree.
GrowBON(Node, Height)
1 if Height = 0 then
2
Node.minvalue ←minimum scalar value of any vertex of Node.cube0;
3
Node.maxvalue ←maximum scalar value of any vertex of Node.cube0;
4
return;
5 end
6 L ←2Height−1 ;
7 (x0, y0, z0) ←coordinates of Node.cube0;
8 if (x0 + L < mx) then kx ←2; else kx ←1;
9 if (y0 + L < my) then ky ←2; else ky ←1;
10 if (z0 + L < mz) then kz ←2; else kz ←1;
11 k ←kx × ky × kz;
12 Node.numChildren ←k;
13 Create array, NodeArray, of k new octree nodes;
14 Node.child ←reference to array NodeArray;
15 j ←0;
16 for ix = 0 to kx −1 do
17
for iy = 0 to ky −1 do
18
for iz = 0 to kz −1 do
19
(x, y, z) ←(x0 + ix × L, y0 + iy × L, z0 + iz × L);
20
NodeArray[j].cube0 ←reference to cube (x, y, z);
21
j ←j + 1;
22
end
23
end
24 end
25 for j = 0 to k −1 do
26
GrowBON (NodeArray[j], Height-1);
27 end
28 Node.minvalue ←minimum of {NodeArray[j].minvalue }j=0,...,k−1;
29 Node.maxvalue ←maximum of {NodeArray[j].maxvalue }j=0,...,k−1;
Algorithm 8.4. GrowBON.
maximum scalar values over all vertices of that cube and stores those values to
represent the span of the node.
If the height of the node is not zero, then the node is an internal one. We
need to determine the number of children of the node. Let (x0, y0, z0) be the
coordinates of the cube referenced by the node. The node represents a region
of dimensions 2Height × 2Height × 2Height starting at cube (x0, y0, z0). Let L equal

250
8. Data Structures
2Height−1.
Let kx equal one if x0 + L is less than mx and let kx equal two,
otherwise. Similarly, let ky equal one if y0 + L is less than my and equal two,
otherwise, and let kz equal one if z0 +L is less than mz and equal two, otherwise.
The node has k = kx × ky × kz children. Create an array of m child nodes and
store a reference to this array and its length at the parent node.
To set the cubes for each of the child nodes we index the child nodes by
(ix, iy, iz) where 0 ≤ix < kx and 0 ≤iy < ky and 0 ≤iz < kz. Note that ix, iy,
and iz have values zero or one. There are m such indices corresponding to the m
children. The cube for child (ix, iy, iz) is (x0 + ix × L, y0 + iy × L, z0 + iz × L). We
store a reference to that cube in the child node. The cube represents an octant
of the parent node which intersects the input grid.
The rest of the algorithm follows the algorithm GrowFullOctree for the
full octree. To create subtrees at each child node, GrowBON recursively calls
itself on each child node. The recursive call sets the minimum and maximum
scalar values for each child node.
These values represent the minimum and
maximum scalar values over all vertices in the corresponding region. GrowBON
sets the minimum and maximum scalar values for the parent node by computing
the minimum over all the minimum scalar values and the maximum over all
maximum scalar values of the child nodes.
The algorithm to search the branch-on-need octree takes an isovalue σ as
input. Starting at the octree root, the search algorithm processes an internal
octree node by determining if σ lies in the interval between the node’s minimum
and maximum values. If σ lies in the interval, then the search algorithm recur-
sively processes the node’s children. If σ does not lie in the interval, then the
search algorithm does not intersect the region represented by the node and the
entire subtree rooted at that node is ignored.
The search algorithm recursively processes internal nodes until it reaches
the octree leaves. It again determines if σ lies in the interval between the nodes
minimum and maximum values. If σ lies in the interval, then the cube referenced
at that node is added to a list of intersected cubes.
8.2.3
Space and Time Analysis
Full octree. We ﬁrst give an analysis of the space and time complexity for a full
octree of cube dimensions 2h × 2h × 2h. The total number of cubes in the octree
is 23h. The number of nodes in the octree is
23h + 23h/8 + 23h/82 + . . . + 82 + 8 + 1 < (8/7)23h.
Thus the space used by the octree is Θ(N) where N = 23h is the number of
cubes in the octree. The height of the full octree is h = log8(N).
The time to build the octree (algorithm BuildIsoOctree, Figure 8.5) is
proportional to the size of the octree. Thus, the time to build the octree is also
Θ(N).

8.2. Octrees
251
Input
: Isovalue is the isovalue.
Node is an octree node.
Height is the height of Node in the octree.
SearchFullNode(Isovalue, Node, Height)
1 if (Node.minvalue ≤Isovalue ≤Node.maxvalue) then
2
if Height = 0 then
3
Report(Node.cube0);
4
else
5
for i = 0, . . . , 7 do
6
SearchFullNode(Isovalue, Node.child (i), Height-1);
7
end
8
end
9 end
Algorithm 8.5. SearchFullNode.
We search the octree by recursively calling Algorithm 8.5 SearchFullNode.
For each cube whose span contains the input isovalue, σ, we make at most
log8(N) recursive calls to SearchFullNode. Thus searching the octree takes
O(1 + M log(N)) time where M is the number of cubes whose span contains σ.
We summarize the space and running times in the following proposition.
Proposition 8.1. Let N = 23h be the number of cubes in the input grid with cube
dimensions 2h × 2h × 2h.
• Algorithm BuildIsoOctree creates an octree of size Θ(N) and height
⌊log8(N)⌋.
• Algorithm BuildIsoOctree runs in Θ(N) time.
• Algorithm SearchFullNode runs in O(1 + M log(N)) time where M is
the number of cubes whose span contains the input isovalue.
If the span of every cube contains σ, then searching the octree takes only
O(M) time since we can make at most one recursive call to SearchFullNode
for each node in the octree. Thus O(1 + M log(N)) time is not a tight upper
bound.
Branch-on-need (BON) octree. Consider a grid Γ with cube dimensions mx ×
my ×mz. Without loss of generality, assume that mx ≥my ≥mz. Let m′
x = 2hx
be the smallest power of two that is greater than mx. Similarly, let m′
y = 2hy
and m′
z = 2hz be the smallest powers of two that are greater than my and mz,
respectively. Note that m′
x < 2mx and m′
y < 2my and m′
z < 2mz. Let Γ′ be a
grid with cube dimensions m′
x × m′
y × m′
z.

252
8. Data Structures
The octree for grid Γ′ contains the octree for grid Γ. We bound the size and
height of the octree for grid Γ by bounding the size and height of the octree for
grid Γ′.
Nodes in the ﬁrst hx −hy −1 levels of the octree for grid Γ′ each have only
two nonempty children. The total number of nodes in these levels is
1 + 2 + 22 + 23 + . . . + 2hx−hy−1 < 2hx−hy ≤m′
x.
The nodes in the next hy −hz −1 levels of the octree each have four nonempty
children. There are exactly 2hx−hy nodes at level hx −hy and the number of
nodes increases by a factor of four at each level. The total number of nodes in
these levels is
2hx−hy(1 + 4 + 42 + 43 + . . . + 4hy−hz−1) < 2hx−hy4hy−hz
= 2hx−hy22hy−2hz
≤2hx2hy ≤m′
xm′
y.
The interior nodes in the next hz+1 levels of the octree each have eight nonempty
children. There are exactly 2hx−hy4hy−hz nodes at level hx −hz.
The total
number of nodes in these levels is
2hx−hy4hy−hz(1 + 8 + 82 + 83 + . . . + 8hz) < 2hx−hy4hy−hz8hz+1
= 2hx−hy22hy−2hz23hz+1
= 2 × 2hx2hy2hz = 2m′
xm′
ym′
z.
Thus total number of nodes in the BON octree for grid Γ′ is Θ(m′
xm′
ym′
z). Since
m′
x/2 < mx ≤m′
x and m′
y/2 < my ≤m′
y and m′
z/2 < mz ≤m′
z, the total
number of nodes in the BON octree for grid Γ is Θ(mxmymz) or Θ(N) where
N = mxmymz is the number of cubes in the grid.
The height of the BON octree for both grid Γ and grid Γ′ is hx = log2(m′
x).
Since m′
x/2 < mx ≤m′
x, the height of the BON octree for grid Γ is Θ(log2(mx)).
Since mx ≤N ≤m3
x, the height of the BON octree for grid Γ is Θ(log2(N)).
The time to build the octree (Algorithm BuildBONOctree, Figure 8.7) is
proportional to the size of the octree. Thus, the time to build the octree is also
O(N).
We search the octree by recursively calling Algorithm 8.5 SearchFullNode.
For each cube whose span contains the input isovalue, σ, we make at most
log2(N) recursive calls to SearchFullNode. Thus searching the octree takes
O(1 + M log(N)) time where M is the number of cubes whose span contains σ.
We summarize the space and running times in the following proposition.
Proposition 8.2. Let N be the number of cubes in the input grid.
• Algorithm BuildBONOctree creates an octree of size Θ(N) and height
at most Θ(log(N)).

8.3. Span Space Priority Trees
253
Create root node Root

Root.cube0 ←reference to cube (0, 0, 0)

h ←min{j : 2j ≥max(mx, my, mz)}

GrowBON(Root,h)
Figure 8.7. BuildBONOctree. Input is a scalar grid with cube dimensions mx ×
my × mz.
• Algorithm BuildBONOctree runs in Θ(N) time.
• Algorithm SearchBON runs in O(1 + M log(N)) time where M is the
number of cubes whose span contains the input isovalue.
8.3
Span Space Priority Trees
Octrees cluster grid cubes together based on their geometric location in space.
Span space data structures cluster grid cubes together based on the proximity
of cube spans. In this section, we present a data structure similar to one given
with Livnat et al. in [Livnat et al., 1996] but replace the kd-tree in their paper
by McCreight’s priority tree [McCreight, 1985]. The modiﬁcation using priority
trees was suggested by Bajaj et al. in [Bajaj et al., 1996].
8.3.1
Span Space
As previously deﬁned, the span of a grid cube c is the interval from the minimum
scalar value smin(c) to the maximum scalar value smax(c) of the cube. The span
space of a set of cubes c1, c2, c3, . . . is the set of points P = {(xi, yi) : [xi, yi] is
the span of cube ci}. Note that P is actually a multiset, i.e., the same point can
occur multiple times in P.
Given an isovalue σ, we want to ﬁnd the cubes ci such that xi ≤σ ≤yi. Plot
the points (xi, yi) in the plane. The horizontal and vertical lines through the

254
8. Data Structures
(0,4)
(4,9)
(4,9)
(2,6)
(0,4)
(1,8)
(3,7)
(4,5)
(2,6)
(1,8)
(3,7)
(4,5)
Figure 8.8. Two priority trees on the same set of points. The priority tree on the right
is an almost complete binary tree.
point (σ, σ) divide the plane into four quadrants. The points of P in the upper-
left quadrant correspond exactly to the cubes ci where xi ≤σ ≤yi. Finding
these cubes becomes the problem of ﬁnding all points in this upper-left quadrant.
In [McCreight, 1985], McCreight presented an eﬃcient data structure for
reporting all points (x, y) ∈P that lie in a query region {(x, y) : xmin ≤x ≤xmax
and y ≥ymin}. If we let xmin equal −∞and xmax = ymin = σ, then this region
is the upper-left quadrant deﬁned by the horizontal and vertical lines through
(σ, σ). The reported set is exactly the points (xi, yi) such that xi ≤σ ≤yi.
Thus, we can use McCreight’s priority trees to solve the problem of reporting
cubes based on their span.
Instead of McCreight’s priority trees, octrees or kd-trees could be used to
report the points (xi, yi) such that xi ≤σ ≤yi.
(See [Samet, 1990b] for a
description of an octree for reporting points. See [Livnat et al., 1996] for deﬁni-
tion and discussion of kd-trees.) We use priority trees because their worst-case
query time is O(log n + k) where n is the number of grid elements and k is the
number of reported points. Octrees and kd-trees have worst-case query time of
O(√n + k). (The octree for reporting points in the span space should not be
confused with the octree in Section 8.2 that recursively partitions the grid into
octants. Because grid cubes are evenly distributed across the grid, the octree in
Section 8.2 has an O(k log(n)) upper bound on its query time. The span space
points have no structure and can be distributed in any manner.)
8.3.2
McCreight Priority Trees
A priority tree is a binary tree with a point (x, y) assigned to each node such that
each node satisﬁes the following two conditions:

8.3. Span Space Priority Trees
255
Compute the span [x, y] of each grid cube

Sort the grid cubes in increasing order by x (of the [x, y] span)
and store in sequence Seq

Root ←GrowPriority (Seq)
Figure 8.9. BuildPriority. Input is a scalar grid.
1. Points in the left subtree of the node have an x-coordinate less than or
equal to points in the right subtree of the node.
2. Coordinate y is greater than or equal to the y-coordinates of any descen-
dants of the node.
A priority tree can be viewed as a combination of a binary search tree built on
the x-coordinates and a heap built on the y-coordinates. There can be many
diﬀerent priority trees for a given set of points.
Our description of priority trees is specialized for the problem of isosurface
extraction. Each node in a priority tree contains a reference to some cube in the
search grid. It contains an x- and a y-coordinate representing the span [x, y] of
the referenced cube. It also contains a value minX, representing the minimum
x value of any node in the subtree rooted at the node. Finally, it contains a
reference to its left and right child.
To build the span space priority tree, construct a sequence of all the grid
cubes and their [x, y] spans. Each element of the sequence contains a reference
to a cube and the x and y values of its span. Sort the sequence in increasing
order by the x-coordinate. Call the subroutine GrowPriority, which creates
a priority tree and returns the root of that tree. (See Figure 8.9.)
GrowPriority creates the priority tree as follows. Let h equal ⌊log2(n)⌋.
As explained in the next section, h will be the height of the priority tree. Create
a new tree node and store the minimum x value of any element of the sequence
at that node. Find the maximum y value of any element of the sequence and a
sequence element with that maximum y value. (Break ties by choosing the last
element of the sequence with the maximum y value.) Copy the x, y, and cube
reference of the sequence element into new node. Delete this element from the
sequence.
Let nL equal min{2h −1, n′ −(2h−1 −1)} where n′ is the number of elements
remaining in the sequence. Let LeftSeq be the ﬁrst nL elements of the sequence

256
8. Data Structures
Input
: Seq is a sequence of points sorted by increasing x value.
GrowPriority(Seq)
1 if Seq = ∅then return NULL;
2 numElem ←number of elements of Seq;
3 Height ←⌊log2(numElem)⌋;
4 Create new tree node Node;
5 Node.minX ←Seq[0].x;
6 maxY ←maxi{Seq[i].y};
7 j ←max{i : Seq[i].y = maxY};
8 Node.cube ←Seq[j].cube;
9 Node.x ←Seq[j].x;
10 Node.y ←Seq[j].y;
11 Delete element j from Seq;
12 numElem ←numElem −1;
13 numLeft ←min{2Height −1, numElem −(2Height−1 −1)};
14 numRight ←numElem −numLeft;
15 LeftSeq ←ﬁrst numLeft elements of Seq;
16 RightSeq ←last numRight elements of Seq;
17 Node.left ←GrowPriority(LeftSeq);
18 Node.right ←GrowPriority(RightSeq);
19 return reference to Node;
Algorithm 8.6. GrowPriority.
and RightSeq be the last n′ −nL elements of the sequence. Value nL is chosen so
that GrowPriority creates an almost complete binary tree as will be deﬁned
in Section 8.3.4. Either the nodes in LeftSeq will form a complete binary subtree
or the nodes in RightSeq will form a complete binary subtree.
Recursively call GrowPriority on sequence LeftSeq. GrowPriority re-
turns the root of a priority tree on the nodes in LeftSeq. Set the left child of
the current node to this root.
Similarly, recursively call GrowPriority on
RightSeq and set the right child of the current node to this root.
The left and right subtrees at each node satisfy the ﬁrst condition on priority
tree nodes while the node’s y value satisﬁes the second condition. Thus Grow-
Priority creates a priority tree. In the next section, we show that this priority
tree has height h = ⌊log2(n)⌋.
The algorithm to search the priority tree takes an isovalue as input. Starting
at the priority tree root, the algorithm processes node v by comparing the iso-
value to v.minX. The v.minX is the minimum x value over all nodes in the subtree
rooted at v. If the isovalue is less than or equal to v.minX, then the isovalue is
less than or equal to x for every node in the subtree rooted at v. The algorithm

8.3. Span Space Priority Trees
257
Input
: Isovalue is the isovalue.
Node is a priority tree node.
SearchPriority(Isovalue, Node)
1 if (Isovalue ≤Node.minX) then return;
2 if (Isovalue > Node.y) then return;
3 if (Node.x ≤Isovalue) then
4
Report(Node.cube);
5 end
6 if Node.left ̸= NULL then
7
SearchPriority(Isovalue,Node.left);
8 end
9 if Node.right ̸= NULL then
10
SearchPriority(Isovalue,Node.right);
11 end
Algorithm 8.7. SearchPriority.
skips the entire subtree. If the isovalue is greater than v.y, then the isovalue is
greater than the y value of every node in the subtree rooted at v. Again, the
algorithm skips the entire subtree.
The remaining case is that the isovalue is in the range [v.minX, v.y]. If the
isovalue is in the range [v.x, v.y], then the algorithm reports the cube at node v.
Whether or not the isovalue is in the range [v.x, v.y], the algorithm recursively
processes the left and right subtrees of node v.
8.3.3
Space and Time Analysis
Let N be the number of cubes in the input grid. Each recursive call to algorithm
GrowPriority creates one tree node for each element of the input sequence.
Therefore, the size of the priority tree is Θ(N).
BuildPriority takes Θ(N) time to compute the span of each cube and
Θ(N log(N)) time to sort the cubes. To compute the running time of Grow-
Priority, we represent the recursive calls to GrowPriority in a recursion
tree. Each node in the tree represents a recursive call and the two children of
the node represent the two recursive calls in Statements 17 and 18. The ﬁrst call
to GrowPriority is the root of the tree. The leaves of the recursion tree are
calls to GrowPriority with input Seq equal to the empty set. The internal
nodes of the recursion tree represents a call to GrowPriority, which creates a
new node in the priority tree. Therefore, the internal nodes correspond to nodes
in the priority tree. As shown in the next section, the priority tree has height
⌊log2(N)⌋. Thus, the recursion tree has height ⌊log2(N)⌋+ 1.

258
8. Data Structures
Let Nv be the size of Seq in the recursive call associated with node v of
the recursion tree.
The recursive call takes Θ(Nv) time to ﬁnd maxY and
max{i :
Seq[i].x = maxY} in steps 6 and 7.
Splitting Seq into the subse-
quence LeftSeq and RightSeq takes Θ(Nv) time. Thus, the running time for this
recursive call of GrowPriority is Θ(Nv).
The total running time is Θ(
v Nv). Let Vk be the set of nodes at depth
k in the tree. Rewrite 
v Nv as h
k=0

v∈Vk Nv where h is the height of the
tree. Because LeftSeq and RightSeq share no elements, each cube is in at most
one sequence at a recursive call of depth k. Thus, 
v∈Vk Nv is at most N and

v
Nv =
h

k=0

v∈Vk
Nv ≤
h

k=0
N = Nh.
Since the height h of the tree is ⌊log2(N)⌋+1, the running time of GrowPrior-
ity is Θ(N log(N)). Thus, the running time of BuildPriority is Θ(N log(N)).
Finally, we analyze the running time of SearchPriority. Let M be the
number of elements reported by SearchPriority.
Each recursive call to
SearchPriority takes Θ(1) time.
Let v be the current node in the prior-
ity tree. If the input isovalue is at most v.minX or if the isovalue is greater than
v.y, then the recursive call returns immediately.
We charge this time to the
parent routine, i.e., the routine that called the current one. If the isovalue is in
the range [v.x, v.y], then we associate this time with the element being reported.
There are M such recursive calls and they take a total of Θ(M) time. We are
left with recursive calls where the isovalue is in the range [v.minX, v.x].
Because nodes in the priority tree are ordered from left to right by x value,
if the isovalue is less than v.right.minX, then the isovalue is less than v′.minX
for every node v′ in the subtree rooted at v.right.
If the isovalue is greater
than v.right.minX, then the isovalue is greater than v′.x for every node v′ in the
subtree rooted at v.left. Thus, if the isovalue is in the ranges [v′.minX, v′.x] and
[v′′.minX, v′′.x] for two nodes v′ and v′′, then one of these nodes must be a descen-
dant of the other. The nodes v′ where the isovalue is in the range [v′.minX, v′.x]
must lie on a path from the root to some leaf. Since the priority tree has height
⌊log2(N)⌋, there are at most ⌊log2(N)⌋such nodes. Processing such nodes takes
a total of Θ(log(N)) time.
Thus, the running time of SearchPriority is
Θ(log(N) + M).
We summarize the space and running times in the following proposition.
Proposition 8.3. Let N be the number of cubes in the input grid.
• Algorithm BuildPriority creates a priority of size Θ(N) and height
⌊log2(N)⌋.
• Algorithm BuildPriority runs in Θ(N log(N)) time.
• Algorithm SearchPriority runs in Θ(log(N) + M) time where M is the
number of cubes whose span contains the input isovalue.

8.3. Span Space Priority Trees
259
Figure 8.10. Complete binary tree of height three.
8.3.4
Almost Complete Binary Trees
The running time of the search algorithm depends upon the height of the priority
tree. As previously noted, there are many possible priority trees on a given set
of nodes. We claim that Algorithm BuildPriority creates a very specialized
tree called an almost complete binary tree. In Section 8.3.5, we will discuss how
almost complete binary trees have very simple, compact implementations.
A complete binary tree is a binary tree where all internal nodes have degree two
and all leaves have the same depth. (See Figure 8.10.) Alternately, a complete
binary tree of height h > 0 has the following recursive property:
The left and right subtrees of the root of a complete binary tree of
height h are complete binary trees of height h −1.
A single node is a complete binary tree of height zero.
A complete binary tree of height h has exactly 2h+1 −1 nodes and all its
leaves are at depth h. Thus there is no complete binary tree on n nodes if n + 1
is not a power of two. An almost complete binary tree is a relaxation of the
requirements of a complete binary tree to accommodate any number of nodes.
A single node is an almost complete binary tree of height zero. An almost
complete binary tree of height one is either a complete binary tree of height
one or a root node and a leaf node with the leaf as the left child of the root.
An almost complete binary tree of height h > 1 has one of the following two
recursive properties:
(a) The left subtree of the root is a complete binary tree of height h −1 and
the right subtree is an almost complete binary tree of height h −1.
(b) The left subtree of the root is an almost complete binary tree of height
h −1 and the right subtree is a complete binary tree of height h −2.
See Figure 8.11 for an example of an almost complete binary tree.
We claim the following properties of almost complete binary trees.

260
8. Data Structures
Figure 8.11. Almost complete binary tree of height three. The left subtree of the root
is an almost complete binary tree of height two while the right subtree of the root is a
complete binary tree of height one.
Proposition 8.4.
1. If n is the number of nodes and h is the height of an almost complete binary
tree, then 2h ≤n < 2h+1, or, equivalently, h = ⌊log2(n)⌋.
2. An almost complete binary tree on 2h+1 −1 nodes is a complete binary tree
of height h.
Proof of 1: The proof is by induction on n. Assume that every almost complete
binary tree on k < n nodes has height ⌊log2(k)⌋.
Consider an almost binary tree on n nodes with height h. Let nL be the
number of elements in the left subtree and nR be the number of elements in the
right subtree. Note that n equals nL + nR + 1. We consider two cases based on
whether the tree has recursive property (a) or (b).
If the tree has recursive property (a), then the left subtree is a complete
binary tree of height h −1 and nL equals 2h −1. The right subtree is an almost
complete binary tree of height h −1. By induction, 2h−1 ≤nR < 2h. Thus,
2h ≤2h −1 + 2h−1 + 1 ≤nL + nR + 1 < 2h+1 and 2h ≤n < 2h+1.
If the tree has recursive property (b), then the right subtree is a complete
binary tree of height h−2 and nR equals 2h−1 −1. The left subtree is an almost
complete binary tree of height h −1. By induction, 2h−1 ≤nL < 2h. Thus,
2h ≤nL + nR + 1 < 2h + 2h−1 < 2h+1 and 2h ≤n < 2h+1.
□
Proof of 2: The proof is by induction on h. When h equals zero, the tree is a
single leaf node at depth zero. When h equals one, the tree is the complete
binary tree on three nodes. Assume that for all h′ < h, an almost complete
binary tree on 2h′+1 −1 nodes is a complete binary tree of height h′.
Consider an almost complete binary tree on 2h −1 nodes. The left and right
subtrees of the root of an almost complete binary tree of height h are almost
complete binary trees of height h−1 or h−2. By Statement 1 in this proposition,
the left and right subtrees each have at most 2h −1 nodes. Since the original

8.3. Span Space Priority Trees
261
tree has 2h+1 −1 nodes, the left and right subtrees must each have exactly 2h −1
nodes. By the inductive assumption, the left and right subtrees are complete
binary trees of height h −1. Thus, the original tree is a complete binary tree of
height h.
□
We claim that algorithm BuildPriority constructs an almost complete
binary tree.
Proposition 8.5. Let N be the number of cubes in the input grid.
Algorithm
BuildPriority constructs an almost complete binary tree of height ⌊log2(N)⌋.
Proof: Algorithm BuildPriority calls GrowPriority to build the priority
tree.
We prove that GrowPriority constructs an almost complete binary
tree. The proof is by induction on the number of elements in the input sequence.
When there are no elements or a single element, GrowPriority creates the
empty tree or a tree with one element, both of which are almost complete binary
trees. Assume that on sequences of k < N elements, GrowPriority creates
an almost complete binary tree. Let h equal ⌊log2(N)⌋. By Steps 12 and 13 in
Algorithm 8.6, the number of nodes in the left subtree is min(2h −1, N −2h−1).
We consider two cases based on the values of h and N.
Case I: 2h −1 < N −2h−1:
Since (2h −1) is less than (N −2h−1), GrowPriority creates a left
subtree with (2h −1) nodes and a right subtree with (N −2h) nodes. By
induction, both subtrees are almost complete binary trees.
By Proposition 8.4, the left subtree is a complete binary tree of height
(h −1) and the right subtree has height ⌊log2(N −2h)⌋. Since the initial
tree had height h, the right subtree has height less than h. By assumption,
N −2h−1 > 2h −1 or N −2h−1 ≥2h. Thus,
⌊log2(N −2h)⌋= ⌊log2(N −2h−1 −2h−1)⌋
≥⌊log2(2h −2h−1)⌋= ⌊log2(2h−1)⌋= h −1.
Thus, ⌊log2(N −2h)⌋equals (h −1). The left subtree is a complete binary
tree of height (h −1) and the right subtree is an almost complete binary
tree of height (h−1), so the tree is an almost complete binary tree of height
h = ⌊log2(N)⌋.
Case II: 2h −1 ≥N −2h−1:
Since (2h −1) is at least (N −2h−1), GrowPriority creates a left
subtree with (N −2h−1) nodes and a right subtree with (2h−1 −1) nodes.
By induction, both subtrees are almost complete binary trees.
By Proposition 8.4, the left subtree is a nearly complete binary tree of
height ⌊log2(N −2h−1)⌋and the right subtree is a complete binary tree of

262
8. Data Structures
e
d
c
b
a
f
8
7
6
5
4
3
2
1
i
h
j
g
i
h
g
f
e
d
c
b
a
j
0
9
Figure 8.12. Array representation of an almost complete binary tree. Left child of A[i]
is A[2i + 1]. Right child of A[i] is A[2i + 2].
height (h−2). Since the initial tree had height h, the left subtree has height
less than h. Since N ≥2h,
⌊log2(N −2h−1)⌋≥⌊log2(2h −2h−1)⌋≥⌊log2(2h−1)⌋= h −1.
Thus, ⌊log2(N−2h−1)⌋equals (h−1). The left subtree is an almost complete
binary tree of height (h −1) and the right subtree is a complete binary tree
of height (h −2), so the tree is an almost complete binary tree of height
h = ⌊log2(N)⌋.
□
8.3.5
Priority Tree Implementation
As stated in Proposition 8.5, BuildPriority creates an almost complete binary
tree. An almost complete binary tree on N nodes has a very eﬃcient represen-
tation as an array, A, with N elements. Each element of the array from A[0] to
A[N −1] represents a node of the tree. (See Figure 8.12.)
The root of the tree is A[0]. The left child of the root is A[1] and its right
child is A[2]. More generally, the left child of A[i] is A[2i + 1] and the right child
Left(i)
/* Return index of left child of ith node */
return 2*i+1;
Right(i)
/* Return index of right child of ith node */
return 2*i+2;
Algorithm 8.8. Left and Right.

8.3. Span Space Priority Trees
263
Input
: A is an array storing the tree nodes.
A[i] is the current node.
Seq is a sequence of points sorted by increasing x value.
GrowPriority2(A, i, Seq)
1 if Seq = ∅then return;
2 numElem ←number of elements of Seq;
3 Height ←⌊log2(numElem)⌋;
4 A[i].minX ←Seq[0].x;
5 maxY ←maxi{Seq[i].y};
6 j ←max{i : Seq[i].x = maxY};
7 A[i].cube ←Seq[j].cube;
8 A[i].x ←Seq[j].x;
9 A[i].y ←Seq[j].y;
10 Delete element j from Seq;
11 numElem ←numElem −1;
12 numLeft ←min{2Height −1, numElem −(2Height−1 −1)};
13 numRight ←numElem −numLeft;
14 LeftSeq ←ﬁrst numLeft elements of Seq;
15 RightSeq ←last numRight elements of Seq;
16 GrowPriority2(A, Left(i), LeftSeq);
17 GrowPriority2(A, Right(i), RightSeq);
18 return;
Algorithm 8.9. GrowPriority2.
is A[2i + 2]. If 2i + 1 is greater than or equal to N, then A[i] has no left child.
Similarly, if 2i + 2 is greater than or equal to N, then A[i] has no right child.
The modiﬁed versions of GrowPriority and SearchPriority are in Al-
gorithms 8.9 and 8.10.
8.3.6
Homogeneous Cubes
A cube is homogeneous if the scalar values of all its vertices are identical. Let
sc be the scalar values of all the vertices of homogeneous cube c. If sc is not
the isovalue, then the isosurface does not intersect c and cube c can be ignored.
Even if sc equals the isovalue, cube c does not generate any isosurface triangles
so c can again be ignored. Thus homogeneous cubes need not be inserted in the
span space priority tree.
Many data sets have a signiﬁcant number of homogeneous cubes. Duﬀy et.
al. [Duﬀy et al., 2012] analyzed benchmark data sets from www.volvis.org and
www.stereofx.org. They reported that on average 30% of the cubes in the 8-bit
data sets and 9% of the cubes in the 12-bit data sets were homogeneous.

264
8. Data Structures
Input
: Isovalue is the isovalue.
A is an array storing the tree nodes.
N is the length of array A.
A[i] is the current node.
SearchPriority2(Isovalue, A, N, i)
1 if (Isovalue ≤A[i].minX) then return;
2 if (Isovalue > A[i].y) then return;
3 if (A[i].x < Isovalue) then
4
Report(A[i].cube);
5 end
6 if Left(i) < N then
7
SearchPriority2(Isovalue,A,N,Left(i));
8 end
9 if Right(i) < N then
10
SearchPriority2(Isovalue,A,N,Right(i));
11 end
Algorithm 8.10. SearchPriority2.
8.4
Seed Sets
Our last approach to speeding up isosurface retrieval is a method for identifying
the cubes intersected by the isosurface from a small initial set of grid cubes,
called a seed set. We identify those grid cubes in the seed set whose spans contain
the isovalue, i.e., those cubes that intersect the isosurface. We “grow” this set
of identiﬁed cubes by adding adjacent grid cubes that intersect the isosurface,
repeating the process until no adjacent cubes can be added.
The technique
is called isosurface propagation and produces a set of cubes that intersect the
isosurface.
In order for isosurface propagation to ﬁnd the cubes intersecting the isosur-
face, some cube in the seed set must intersect the isosurface. If the isosurface has
multiple connected components, then each component needs to be intersected by
the seed set.1 An isosurface component that is not intersected by the seed set
may be missed by the isosurface propagation algorithm.
In Section 8.4.1, we discuss isosurface propagation in greater detail. In Sec-
tion 8.4, we give a formal deﬁnition of seed sets and discuss how to compute
small ones. Finally, in Section 8.4.3, we discuss how isosurface propagation can
1This is not quite true. If some grid cube intersects two connected components, then the
seed set need only intersect one of the two components.

8.4. Seed Sets
265
be combined with the span space priority trees of Section 8.3.
Methods for
computing small seed sets based on contour trees are described in Section 12.8.
8.4.1
Isosurface Propagation
Grid cubes can be adjacent in diﬀerent ways. They can share facets, edges, or
vertices. For isosurface propagation, we use facet adjacency. Two grid cubes are
facet adjacent if they share a common facet.
In order to avoid processing a cube more than once, we need a marker bit
for each cube. This bit is used to mark the cubes that have been processed. We
preprocess the cubes by setting each marker bit to false. (See Algorithm 8.11,
IsoPropagateInit.) These bits can either be stored with the individual cubes
or in a separate array.
The isosurface propagation algorithm proceeds as follows.
For each cube
c0 in the seed set, we call SeedGrow to ﬁnd adjacent cubes intersecting the
isosurface. Algorithm SeedGrow ﬁrst checks if the isovalue is in the span of c0
and if c0 is not marked. If both conditions are true, then SeedGrow reports
and marks c0 and adds c0 to a ﬁrst-in-ﬁrst-out queue Q. While Q is not empty,
SeedGrow removes and processes the ﬁrst element of the queue. Let c be the
ﬁrst element of Q. For each grid cube c′ that shares a facet f with c, SeedGrow
checks if the isovalue is in the span of f and if c′ is marked. If both conditions
are true, then SeedGrow marks and reports c′ and adds c′ to the end of the
queue. The span of facet f is the interval from the minimum to the maximum
scalar value of any vertex on f.
After SeedGrow is applied to all elements of the seed set, we unmark all
the reported (i.e., marked) cubes. If the reported cubes are stored in some list,
then the time to unmark the cubes is proportional to the length of the list, not
the size of the grid. By unmarking the reported cubes, we can apply algorithm
IsoPropagate to a diﬀerent isovalue without the costly step of reinitializing all
the marker bits.
The running time of the initialization algorithm IsoPropagateInit and the
reporting algorithm IsoPropagate are as follows:
Proposition 8.6.
• Algorithm IsoPropagateInit runs in Θ(N) time where N is the total
number of grid cubes.
• Algorithm IsoPropagate runs in Θ(M1 + M2) time where M1 is the
number of cubes reported by the algorithm and M2 is the size of the seed
set.
The output of algorithm IsoPropagate depends upon the seed set provided
to the algorithm. If that seed set misses the isosurface or some connected com-
ponent of the isosurface, then IsoPropagate will fail to produce all the cubes

266
8. Data Structures
Input
: G is a regular grid.
IsoPropagateInit(G)
1 Unmark all cubes in G;
Algorithm 8.11. IsoPropagateInit.
Input
: Isovalue is the isovalue.
SeedSet is a set of seed cubes.
Precondition: All grid cubes are unmarked.
IsoPropagate(Isovalue, SeedSet)
1 foreach cube c0 in SeedSet do
2
SeedGrow (Isovalue, c0);
3 end
4 Unmark all reported cubes;
Algorithm 8.12. IsoPropagate.
that intersect the isosurface. In the next section, we discuss seed set properties
that will guarantee that IsoPropagate produces all the cubes intersecting the
isosurface.
Note that our algorithm IsoPropagate processes all the cubes reachable
from one seed cube before it processes the next seed cube. This makes it more
likely that adjacent cubes are reported together in the output. Algorithm Iso-
Propagate processes cubes in a ﬁrst-in-ﬁrst-out order. This gives a breadth-
ﬁrst search, as opposed to depth-ﬁrst search, of the cubes intersecting the isosur-
face. A breadth-ﬁrst search also increases the number of adjacent cubes reported
together in the output. Reporting adjacent cubes together may help isosurface
extraction algorithms identify isosurface vertices shared across cubes. It also
helps build triangle strips, strips of contiguous triangles, which can be rendered
faster than isolated triangles.
8.4.2
Constructing Small Seed Sets
Algorithm IsoPropagate starts from a set of cubes called a seed set. This
seed set is precomputed from the scalar grid and is independent of any speciﬁc
isovalue. An obvious requirement is that the seed set intersects every possible
isosurface. However, if an isosurface has more than one connected component,
then even a seed set that intersects one component of the isosurface may fail to
ﬁnd the cubes that intersect the other components.

8.4. Seed Sets
267
2
6
7
9
3
3
7
7
2
4
7
6
6
4
4
6
3
6
3
7
3
4
6
8
4
2
4
4
3
8
6
1
6
7
6
Figure 8.13. Two-dimensional example of graph Gσ (isovalue 5). Vertices (green) of Gσ
are squares whose span contains isovalue 5. Edges (green) of Gσ are (c, c′) where c and
c′ share an edge e and the span of e contains isovalue 5. Graph Gσ has four connected
components. (One component is a single, isolated vertex.) Yellow cubes form a seed
set intersecting all the connected components of Gσ.
Connected isosurface components are outputs of isosurface construction algo-
rithms, not intrinsic properties of the scalar grid. Even the Marching Cubes al-
gorithm can produce topologically diﬀerent isosurfaces with diﬀerent numbers of
connected components, depending on the lookup table used. (See Section 2.2.5,
Figure 2.13.) Bajaj et al. [Bajaj et al., 1996] gave seed set requirements based
on the spans of facet adjacent cubes. We give a slightly modiﬁed but equivalent
presentation of those requirements.
For each isovalue σ, deﬁne a graph Gσ as follows. The vertices of Gσ are the
set of grid cubes whose spans contain the isovalue σ. If cubes c1 and c2 share
a facet f and the span of f contains σ, then (c1, c2) is an edge of graph Gσ. A
connected component of Gσ is a maximal connected subset of Gσ. Figure 8.13
contains a 2D example of Gσ.
Note that two cubes c and c′ could share a facet f, and both have spans con-
taining σ, and yet be in diﬀerent connected components of Gσ. Correspondingly,
if the span of facet f does not contain σ, then algorithm IsoPropagate may
report c but not c′.
If algorithm IsoPropagate on input isovalue σ reports grid cube c, then
it will also report all the grid cubes in the connected component of Gσ contain-
ing c. Thus, if the seed set intersects every connected component of Gσ, then
IsoPropagate will report all cubes whose spans contain σ.

268
8. Data Structures
Input
: Isovalue is the isovalue.
c0 is a seed cube.
SeedGrow(Isovalue, c0)
1 if (Isovalue is not in the span of c0) or (c0 is marked) then return;
2 Mark c0;
3 Report(c0);
/* Q is a ﬁrst-in-ﬁrst-out queue
*/
4 Q.Enqueue(c0);
5 while Q is not empty do
6
c ←Q.Dequeue();
7
foreach cube c′ facet-adjacent to c do
8
f ←common facet of c and c′;
9
if (Isovalue is in the span of f) and (c′ is not marked) then
10
Mark c′;
11
Report(c′);
12
Q.Enqueue(c′);
13
end
14
end
15 end
Algorithm 8.13. SeedGrow.
A complete seed set is a set of cubes that intersect every component of Gσ for
every isovalue σ.
Proposition 8.7. For every isovalue σ, if the seed set input to algorithm Iso-
Propagate is complete, then IsoPropagate will report all the cubes whose
span contains σ.
Proof: Algorithm SeedGrow (Algorithm 8.13) processes every cube in the con-
nected component of Gσ intersected by c0. Since a complete seed set intersects
every connected component of GΣ, every cube in Gσ is reported by algorithm
IsoPropagate.
□
Now that we have a deﬁnition of a complete seed set, the next problem is to
ﬁnd a “small” complete seed set. Van Kreveld et al. [van Kreveld et al., 1997]
describe a polynomial time algorithm for ﬁnding a minimum size complete seed
set, but the polynomial is large. Fortunately, we do not really need to ﬁnd a
minimum size complete seed set, just a small one.
A number of heuristics have been proposed for ﬁnding small, complete seed
sets [Bajaj et al., 1996,Itoh and Koyamada, 1994,Itoh and Koyamada, 1995,Itoh

8.4. Seed Sets
269
et al., 1996, Itoh et al., 2001, van Kreveld et al., 1997]. We present a simple
heuristic based on ideas in [Itoh and Koyamada, 1995] by Itoh and Koyamada.
The minimum and maximum scalar values of any vertex of cube c are denoted
smin(c) and smax(c), respectively. A grid vertex v is a local minimum if its scalar
value equals smin(c) for every cube c containing v. A grid vertex v is a local
maximum if its scalar value equals smax(c) for every cube c containing v. A grid
vertex is an extremum if it is a local minimum or local maximum.
As previously deﬁned, set Y ⊆X separates point p ∈X from point q ∈X if
every path in X connecting p to q intersects Y. We claim that any connected
isosurface component separates some local minimum grid vertex from some local
maximum grid vertex. Because isosurface components are algorithm dependent,
we formally state this as a property of connected components of Gσ.
Connected components of Gσ are sets of cubes. A sequence (c1, . . . , ck) of
cubes from point p to point q is a vertex-connected path of cubes from p to q if
c1 contains p and ck contains q and every ci shares at least one vertex with
ci+1. A set C of cubes cube separates point p from point q in a grid if every
vertex-connected path of grid cubes from p to q contains some cube in C.
Proposition 8.8. For every isovalue σ, every connected component of Gσ cube
separates some local minimum grid vertex from some local maximum grid vertex.
The proof of Proposition 8.8 is given in Section 8.4.4.
Corollary 8.9. A set C of cubes is a complete seed set if for every local minimum
vertex v and every local maximum vertex v′ there is a vertex-connected path of
cubes in C from v to v′.
Proof: Let λ be a connected component of Gσ. By Proposition 8.8, there is some
local minimum vertex v and some local maximum vertex v′ such that λ cube
separates v from v′. Since C contains a vertex-connected path from v to v′, some
cube in C must also lie in λ. Thus, C contains some cube in every connected
component of Gσ for every σ. Therefore, C is a complete seed set.
□
Note that the corollary gives suﬃcient but not necessary conditions for a seed
set to be complete.
Finding the minimum size set of cubes satisfying the conditions in Corol-
lary 8.9 is a diﬃcult problem. It is similar to the NP-complete Geometric Steiner
Tree Problem [Garey and Johnson, 1979] and is probably also NP-complete. Itoh
and Koyamada in [Itoh and Koyamada, 1995] and [Itoh et al., 2001] give heuris-
tics for solving this problem.
Instead of presenting a heuristic to ﬁnd a small set of cubes connecting the
extremum vertices, we give a simple algorithm that performs well when extrema
are uniformly distributed across the grid. Let N be the number of grid cubes and
K be the number of extrema vertices in the grid. If the extrema are uniformly
distributed across the grid, then the smallest vertex-connected path of cubes

270
8. Data Structures
y
y
x
x
z
(a)
(b)
Figure 8.14. (a) 2D example of spine. (b) 3D seed set spine.
connecting an extremum to its closest neighbor will have on average (N/K)1/3
cubes.
Thus a set of cubes connecting all K extrema grid vertices will have
K × (N/K)1/3 or K2/3N 1/3 cubes. We show how to build a complete seed set
with approximately 2K2/3N 1/3 cubes.
Let mx × my × mz be the cube dimensions of the grid. Relabel the axis of
the grid so that mx ≤my ≤mz. Note that mx × my × mz equals N.
Label the cubes (ix, iy, iz) where ix, iy, iz are integers starting at 0 and let
k equal ⌈(N/K)1/3⌉. The seed set consists of two parts, a set of cubes forming
a spine and a set of cubes connecting the extrema grid vertices to the spine.
The spine consists of all cubes (ix, 0, 0), all cubes (ix, iy, 0) where (ix mod k)
equals zero, and all cubes (ix, iy, iz) where (ix mod k) and (iy mod k) equal zero
(Figure 8.14).
Connect each extremum grid vertex v to the spine as follows. Let (ix, iy, iz)
be the cube with the smallest ix, iy, and iz coordinates containing v. Let jx
equal ix −(ix mod k) and jy equal iy −(iy mod k). The cube (jx, jy, iz) is in
the spine. Connect cube (jx, jy, iz) to cube (ix, iy, iz) by a diagonal set of cubes
followed by a stack of cubes in either the x or the y direction (Figure 8.15). More
speciﬁcally, let dx equal (ix −jx) and dy equal (iy −jy). If dx is greater than or
equal to dy, then connect (jx, jy, iz) to (ix, iy, iz) by the cubes (jx + h, jy + h, iz)
for h = 1, . . . , dy and (jx + h, iy, iz) for h = dy, . . . , dx. If dy is greater than
dx, then connect (jx, jy, iz) to (ix, iy, iz) by the cubes (jx + h, jy + h, iz) for
h = 1, . . . , dx and (ix, jy + dy, iz) for h = dx, . . . , dy. The number of grid cubes
used to connect (ix, iy, iz) to the spine is max(dx, dy) ≤m. The algorithm for
constructing the seed set is presented in Algorithm 8.14.

8.4. Seed Sets
271
Figure 8.15. Cubes connecting (jx, jy, iz) to (ix, iy, iz) where jx = ix −(ix mod 8) and
jy = iy −(iy mod 8).
Input
: G is a regular scalar grid.
k determines spacing between rows and columns in the
spine.
Output
: A complete seed set for G.
ExtremumSeedSet(G, k)
1 SeedSetx ←cubes (ix, 0, 0);
2 SeedSety ←cubes (ix, iy, 0) where ix mod k = 0;
3 SeedSetz ←cubes (ix, iy, iz) where ix mod k = 0 and iy mod k = 0;
4 SeedSet ←SeedSetx

SeedSety

SeedSetz;
5 VE ←extremum grid vertices ;
6 foreach v ∈VE do
7
(ix, iy, iz) ←cube with lowest indices containing v;
8
dx ←ix mod k;
9
dy ←iy mod k;
10
jx ←ix −dx;
11
jy ←iy −dy;
/* Add cubes connecting (jx, jy, iz) to (ix, iy, iz) to SeedSet
*/
/* Add cubes along diagonal
*/
12
Add cubes {(jx + h, jy + h, iz) : 1 ≤h ≤min(dx, dy)} to SeedSet;
13
if dx ≥dy then
/* Add cubes in x direction
*/
14
Add cubes {(jx + h, iy, iz) : dy < h ≤dx} to SeedSet;
15
else
/* Add cubes in y direction
*/
16
Add cubes {(ix, jy + h, iz) : dx < h ≤dy} to SeedSet;
17
end
18 end
19 return (SeedSet);
Algorithm 8.14. ExtremumSeedSet.

272
8. Data Structures
The spine has mx + (mx/k) × my + (mx/k) × (my/k) × mz cubes. Since
mx ≤my ≤mz, length mx is at most N 1/3 and mx ×my is at most N 2/3. Thus,
mx + (mx/k) × my + (mx/k) × (my/k) × mz ≤N 1/3 + N 2/3/k + N/k2.
At most k cubes connect each extremum to the spine for a total of kK cubes.
Thus the total number of cubes in the seed set is N 1/3 + N 2/3/k + N/k2 + kK.
Since k equals ⌈(N/K)1/3⌉, this is approximately N 1/3 +N 1/3K1/3+2N 1/3K2/3
cubes. Dropping the low-order terms gives approximately 2N 1/3K2/3 cubes in
the seed set.
Algorithm ExtremumSeedSet may add the same cube more than once to
the seed set. Having multiple references to the same cube in the seed set is not
a problem for algorithmIsoPropagate. After the ﬁrst reference to a cube is
processed, the cube will be marked, and subroutine SeedGrow immediately
returns if it receives an already marked cube. However, multiple references to
the same cube can be eliminated by sorting the cube references in SeedSet and
scanning the sorted list for repeated references.
If a cube has two vertices with the same scalar value, then both could be
extrema vertices. Large clusters of adjacent vertices with the same scalar value
can create large clusters of adjacent cubes in the seed set. Clusters of adjacent
vertices could be identiﬁed in a preprocessing step and at most one vertex marked
as an extremum in the cluster.
A simpler solution is to symbolically perturb the scalar values of vertices so
that no two vertices have precisely the same scalar value. Let (vx, vy, vz) be the
coordinates of grid vertex v and let sv be its scalar value. For each grid vertex
v, deﬁne a new scalar value,
s′
v = sv + ϵvx + ϵ2vy + ϵ3vz,
for some extremely small ϵ > 0. The same ϵ is used to deﬁne all s′
v. If the value
of ϵ is very small, then s′
u < s′
v whenever su < sv and no two values s′
v are equal.
Instead of deﬁning a precise ϵ, we symbolically perturb the scalar values as
follows. For each pair of grid vertices u and v, deﬁne u ≺v if
• su < sv, or
• su = sv and ux < vx, or
• su = sv and ux = vx and uy < vy, or
• su = sv and ux = vx and uy = vy and uz < vz.
Note that u ≺v whenever su < sv. If u and v have diﬀerent coordinates, then
either u ≺v or v ≺u. A grid vertex u is a local minimum for this symbolically
perturbed grid if u ≺v for every vertex v ̸= u in every cube containing u. A

8.4. Seed Sets
273
grid vertex u is a local maximum if v ≺u for every vertex v ̸= u in every cube
containing u. A grid vertex is an extremum if it is either a local minimum or a
local maximum.
Proposition 8.8 and Corollary 8.9 still hold for the local minima and maxima
of symbolically perturbed grids. We use the extrema of the symbolically per-
turbed grid in Step 5 of algorithm ExtremumSeedSet to compute the complete
seed set.
8.4.3
Seed Sets and Span Space Priority Trees
Seed sets require that the entire seed set be searched, even if the isosurface only
intersects a few grid cubes. For large seed sets, this searching can be costly. Bajaj
et al. [Bajaj et al., 1996] suggest storing the seed set in a span space priority
tree, such as the one described in Section 8.3. The time to report the cubes
intersecting the isosurface Θ(log(K) + M) where K is the number of cubes in
the seed set and M is the number of reported cubes. The priority tree uses Θ(K)
space. Algorithm IsoPropagate still requires Θ(N) space for cube markers.
8.4.4
Seed Set Proofs
In this section, we prove Proposition 8.8, which states that every connected
component of Gσ cube separates some local minimum grid vertex from some
local maximum grid vertex. The vertices of Gσ are the set of grid cubes whose
spans contain the isovalue σ. The edges of Gσ are pairs of cubes that share a
facet f whose span contains σ.
As previously deﬁned, smin(c) and smax(c) are the minimum and maximum
scalar values, respectively, of any vertex of grid cube c. Minimum smin(C) and
maximum smax(C) are the minimum and maximum of smin(c) and smax(c), re-
spectively, over all cubes c ∈C. Deﬁne smin(f) and smax(f) are the minimum
and maximum scalar values, respectively, of any vertex of grid facet f.
Let G−
σ be a graph whose vertices are the set of grid cubes {c : smin(c) ≤σ}.
If cubes c1 and c2 share a facet f and smin(f) is less than or equal to σ, then
(c1, c2) is an edge of graph G−
σ . Figure 8.16(a) contains a 2D example of G−
σ .
Similarly, let G+
σ be a graph whose vertices are the set of grid cubes {c :
smax(c) ≥σ}. If cubes c1 and c2 share a facet f and smax(f) is greater than or
equal to σ, then (c1, c2) is an edge of graph G+
σ . Figure 8.16(b) contains a 2D
example of G+
σ .
To understand the connected components of Gσ, we need to look at facets of
cubes in Gσ whose span does not contain σ. Deﬁne sets of facets Fσ, F +
σ , and
F −
σ as follows:

274
8. Data Structures
2
4
4
6
8
3
3
6
3
7
6
7
9
3
3
2
4
7
7
7
6
6
4
4
6
2
4
4
3
7
6
6
8
1
6
2
6
7
9
3
3
7
7
2
4
7
6
6
4
4
6
3
6
3
7
3
4
6
8
4
2
4
4
3
8
6
1
6
7
6
(a) Graph G−
σ .
(b) Graph G+
σ .
Figure 8.16. Two-dimensional example. (a) Graph G−
σ (isovalue 5). Vertices (blue) of
G−
σ are squares c where smin(c) ≤5. Edges (blue) of G−
σ are (c, c′) where c and c′
share an edge e and smin(e) ≤5. Red grid edges are F −
σ . (b) Graph G+
σ (isovalue 5).
Vertices (red) of G+
σ are squares c where smax(c) ≥5. Edges (red) of G+
σ are (c, c′)
where c and c′ share an edge e and smax(e) ≥5. Blue grid edges are F +
σ .
Fσ = {f : f is a facet of some cube of Gσ and smax(f) < σ or σ < smin(f)};
F −
σ = {f : f is a facet of some cube of G−
σ and smin(f) > σ};
F +
σ = {f : f is a facet of some cube of G+
σ and smax(f) < σ}.
Figure 8.17 contains a 2D example of Fσ, F −
σ , and F +
σ .
Each facet in Fσ is either in F −
σ or in F +
σ .
Lemma 8.10. Fσ = F −
σ ∪F +
σ .
Proof: Let f be a facet in Fσ. By deﬁnition, f is a facet of some cube c whose
span contains σ. Thus cube c is a vertex in G−
σ and a vertex in G+
σ . Since f is
in Fσ, either smax(f) < σ or smin(f) > σ. If smax(f) < σ, then f is in F +
σ . If
smin(f) > σ, then f is in F −
σ .
Now assume that f is a facet in F +
σ . By deﬁnition, f is a facet of some cube
c where smax(c) is greater than or equal to σ. Since f is in F +
σ , the vertices of
f all have scalar value less than σ. Thus the span of c contains σ and so c is a
vertex of Gσ. Since f is the facet of c and smax(f) is less than σ, facet f is in Fσ.
By similar reasoning, if f is a facet in F −
σ , then f is in Fσ.
Since f is in Fσ if and only if f is in F −
σ ∪F +
σ , set Fσ equals F −
σ ∪F +
σ .
□

8.4. Seed Sets
275
2
6
7
9
3
4
7
6
6
4
4
8
6
1
6
6
3
6
3
7
3
4
6
8
4
6
2
4
2
3
7
7
4
3
7
2
6
7
9
3
4
7
6
6
4
4
1
6
6
3
6
3
7
3
4
6
8
4
2
6
4
2
3
7
7
4
3
7
6
8
(a) Graph Gσ and set Fσ.
(b) Sets F −
σ and F +
σ .
Figure 8.17. Two-dimensional example. (a) Graph Gσ (green vertices and edges) and
set Fσ (magenta grid edges). (b) Sets F −
σ (red grid edges) and F +
σ (blue grid edges).
Note that Fσ equals F −
σ ∪F +
σ (Lemma 8.10) and that |F −
σ | does not intersect |F +
σ |
(Lemma 8.11).
Let |Fσ|, |F −
σ |, and |F +
σ | be the union of the facets in Fσ, F −
σ , and F +
σ ,
respectively. The following lemma, that |F −
σ | does not intersect |F +
σ |, is central
to the proof of Proposition 8.8.
Lemma 8.11. |F −
σ | ∩|F +
σ | = ∅.
Proof: Sets |F −
σ | and |F +
σ | are unions of grid facets that intersect only at their
edges and vertices. Thus, |F −
σ | intersects |F +
σ | if and only if some grid vertex is
in |F −
σ | ∩|F +
σ |.
Consider any grid vertex v. If v had scalar value less than or equal to σ, then
every facet incident on v would have minimum scalar value less than or equal to
σ. Thus, no facet incident on v would be in F −
σ and v would not be in |F −
σ |. On
the other hand, if v had scalar value greater than or equal to σ, then no facet
incident on v would be in F +
σ and v would not be in |F +
σ |. Thus no vertex v is
in |F −
σ | ∩|F +
σ |, proving the lemma.
□
We now consider a connected component of Gσ. Let λ be a connected com-
ponent of Gσ (Figure 8.18(a)).
Since both G−
σ and G+
σ contain Gσ, both G−
σ
and G+
σ
contain λ.
Let λ−be the connected component of G−
σ
containing
λ (Figure 8.18(b)). Let λ+ be the connected component of G+
σ containing λ

276
8. Data Structures
8
6
4
4
7
3
6
3
3
2
6
7
9
3
7
7
3
2
4
7
6
6
4
4
6
6
8
6
1
6
2
4
4
3
7
v−
v+
8
6
4
4
7
3
6
3
3
2
6
7
9
3
7
7
3
2
4
7
6
6
4
4
6
6
8
6
1
6
2
4
4
3
7
v−
8
6
4
4
7
3
6
3
3
2
6
7
9
3
7
7
3
2
4
7
6
6
4
4
6
6
8
6
1
6
2
4
4
3
7
  
v+
(a) Component λ.
(b) Component λ−.
(c) Component λ+.
Figure 8.18. Two-dimensional example. (a) Connected component λ of Gσ. Set Cλ is
the set of squares containing (green) vertices of Gσ. Any vertex-connected path from
grid vertex v−to grid vertex v+ must contain some cube in Cλ. (b) Connected compo-
nent λ−of G−
σ containing λ. Set Cλ−is the set of squares containing (blue) vertices of
G−
σ . Grid vertex v−has minimum scalar value over all vertices of Cλ−. (c) Connected
component λ+ of G+
σ containing λ.
Set Cλ+ is the set of squares containing (red)
vertices of G+
σ . Grid vertex v+ has maximum scalar value over all vertices of Cλ+.
(Figure 8.18(c)). Let Cλ, Cλ−and Cλ+ be the cubes corresponding to the ver-
tices of λ, λ−, and λ+, respectively.
By Lemma B.8 in Appendix B, set |Cλ| ∩cl(|Γ| −|Cλ|) separates |Cλ| from
the points of |Γ| that are not in |Cλ|. Similarly, |Cλ−|∩cl(|Γ|−|Cλ−|) and |Cλ+|∩
cl(|Γ| −|Cλ+|) separate |Cλ−| from (|Γ| −|Cλ−|) and |Cλ+| from (|Γ| −|Cλ+|),
respectively. The following lemma relates these separation sets to Fσ, F −
σ , and
F +
σ .
Lemma 8.12.
1. |Cλ| ∩cl(|Γ| −|Cλ|) ⊆|Fσ|.
2. |Cλ−| ∩cl(|Γ| −|Cλ−|) ⊆|F −
σ |.
3. |Cλ+| ∩cl(|Γ| −|Cλ+|) ⊆|F +
σ |.
Proof: Since grid cubes intersect only on their facets, edges, and vertices, set
|Cλ| ∩cl(|Γ| −|Cλ|) is the union of a set of grid facets.
Let f be a facet of
|Cλ| ∩cl(|Γ| −|Cλ|). Since f is in |Cλ|, facet f is incident on some cube c ∈Cλ.
Since f is in cl(|Γ| −|Cλ|), facet f is incident on some grid cube c′ ̸∈Cλ. Since
c is in Cλ and c′ is not, the span of f does not contain σ. Thus f is in Fσ.
Similar arguments prove Statements 2 and 3.
□

8.4. Seed Sets
277
The proof of the next lemma (Lemma 8.13) relies upon the proposition that
if Y1 is connected and Y2 is connected and the boundaries of Y1 and Y2 do not
intersect, then Y1 ∩Y2 is connected. The proof of Lemma 8.13 requires a slightly
more general form of the proposition that replaces the boundaries by separating
sets. The formal statement of the proposition and its proof are Lemma B.12 in
Appendix B.
Lemma 8.13. Cλ = Cλ+ ∩Cλ−.
Proof: By deﬁnition, Cλ is a subset of Cλ−and a subset of Cλ+, so Cλ is a subset
of Cλ−∩Cλ+. We show that Cλ−∩Cλ+ is a subset of Cλ.
The facets of F −
σ do not intersect |Cλ−| or they lie on the boundary of |Cλ−|
or they separate two cubes in Cλ−that do not share an edge in λ−. Since λ−is
connected, the set Y−= |Cλ−|−|F −
σ | is connected. Similarly, Y+ = |Cλ+|−|F +
σ |
is connected.
By Lemma 8.12, set |F −
σ | contains cl(Y−) ∩cl(|Γ| −Y−) and set |F +
σ | con-
tains cl(Y+) ∩cl(|Γ| −Y+). By Lemma 8.11, |F −
σ | does not intersect |F +
σ |. By
Lemma B.12 in Appendix B, Y−∩Y+ is connected.
Let p be a point in the interior of |Cλ|. Let q be a point in Y−∩Y+. Since
Y−∩Y+ is connected, there is a path ζ in Y−∩Y+ from p to q. This path does
not intersect |F −
σ | or |F +
σ |. By Lemma 8.12, |Cλ| ∩cl(|Γ| −|Cλ|) is contained in
|Fσ|. Since |Fσ| is a subset of |F −
σ | ∪|F +
σ | (Lemma 8.10), |Cλ| ∩cl(|Γ| −|Cλ|)
is contained in |F −
σ | ∪|F +
σ |.
Thus ζ does not intersect |Cλ| ∩cl(|Γ| −|Cλ|).
By Lemma B.8 in Appendix B, set |Cλ| ∩cl(|Γ| −|Cλ|) separates |Cλ| from
|Γ| −|Cλ|. Since ζ does not intersect |Cλ| ∩cl(|Γ| −|Cλ|), point q is also in |Cλ|.
Thus |Y−∩Y+| is a subset of |Cλ|. Thus Cλ−∩Cλ+ is a subset of Cλ.
Since Cλ is a subset of Cλ−∩Cλ+ and Cλ−∩Cλ+ is a subset of Cλ, set Cλ
equals Cλ−∩Cλ+.
□
Let v−be a vertex of Cλ−with minimum value and let v+ be a vertex of
Cλ+ with maximum value. (See Figures 8.18(b) and 8.18(c).) We show that v−
is a local minimum and v+ is a local maximum. In the proof of Proposition 8.8,
we will show that any vertex-connected path of cubes from v−and v+ intersects
Cλ. (See Figure 8.18(a) for a 2D example.)
Lemma 8.14.
1. If v−is a vertex of a cube Cλ−with scalar value smin(Cλ−), then v−is a
local minimum.
2. If v+ is a vertex of a cube in Cλ+ with scalar value smax(Cλ+), then v+ is
a local maximum.
Proof: We prove Statement 1.
Let v−be a vertex of some cube in Cλ−with scalar value smin(Cλ−). Vertex
v−has scalar value less than or equal to σ. Thus, every cube and facet containing

278
8. Data Structures
v−has minimum scalar value less than or equal to σ and all cubes containing v−
are in Cλ−. Since vertex v−has scalar value less than or equal to the minimum
value of each such grid cube, vertex v−is a local minimum vertex.
A similar argument proves Statement 2.
□
Finally, we come to the proof of Proposition 8.8.
Proposition 8.8.
For every isovalue σ, every connected component of Gσ cube
separates some local minimum grid vertex from some local maximum grid vertex.
Proof: Let λ be a connected component of Gσ. Let λ−be the connected compo-
nent of G−
σ containing λ, and let λ+ be the connected component of G+
σ containing
λ, as deﬁned above. Let Cλ, Cλ−, and Cλ+ be the cubes corresponding to the
vertices of λ, λ−, and λ+, respectively.
Let v−be a vertex of a cube Cλ−whose scalar value is smax(Cλ−). Sim-
ilarly, let v+ be a vertex of a cube in Cλ+ whose scalar value is smin(Cλ+).
By Lemma 8.14, vertex v−is a local minimum vertex and vertex v+ is a local
maximum vertex.
By Lemmas 8.10 and 8.12, set |F −
σ |∪|F +
σ | separates |Cλ| from |Γ|−|Cλ|. Set
cl(|Γ| −|Cλ|) is composed of connected components. By Lemma 8.11, |F −
σ | does
not intersect |F +
σ |. Thus each connected component of cl(|Γ| −|Cλ|) is either
separated from |Cλ| by |F −
σ | or by |F +
σ |.
Let ζc = (c1, . . . , ck) be a vertex-connected path of cubes from v−to v+. If
v−is not in cl(|Γ| −|Cλ|), then c1 is in Cλ and ζc intersects Cλ. If v+ is not in
cl(|Γ| −|Cλ|), then ck is in Cλ and again ζc intersects Cλ.
Assume neither v−nor v+ are in cl(|Γ|−|Cλ|). Since v−is in Cλ−, vertex v−
is in a component of cl(|Γ| −|Cλ|) separated from |Cλ| by F +
σ . (Remember that
F +
σ consists of facets f such that smax(f) < σ. These facets are on the boundary
of |Cλ+|.) Since v+ is in Cλ+, vertex v+ is in a component of cl(|Γ| −|Cλ|)
separated from |Cλ| by F −
σ . Thus v−and v+ are in separate components of
cl(|Γ| −|Cλ|) and ζc intersects Cλ. Thus any vertex-connected path of cubes
from v−to v+ intersects Cλ and Cλ cube separates v−from v+.
□
8.5
Notes and Comments
Samet’s books [Samet, 1990a,Samet, 1990b,Samet, 2005] on spatial data struc-
tures contain a full treatment of quadtrees and octrees.
Wilhelms and Van
Gelder [Wilhelms and Gelder, 1992] proposed the branch-on-need (BON) octree.
Shi and Jaja [Shi and JaJa, 2006] give a modiﬁcation of the BON octree that
supports fast, view-dependent isosurface extraction and fast extraction of the 3D
isosurface formed by slicing a 4D isosurface with a hyperplane. Their algorithm

8.5. Notes and Comments
279
runs in O(M + log(N)) time where N is the total number of grid cubes and M
is the number of cubes whose span contains the isovalue.
Span (range) space algorithms are given in [Giles and Haimes, 1990, Gal-
lagher, 1991,Shen and Johnson, 1995]. The span space algorithm in Section 8.3.1
is based on the one by Livnat et al. [Livnat et al., 1996] but with the kd-tree
replaced by McCreight’s priority tree [McCreight, 1985] as suggested in [Bajaj
et al., 1996].
Shen et al. [Shen et al., 1996] proposed a variation of [Livnat
et al., 1996] where the kd-tree is replaced by a uniform partition. Cignoni et
al. [Cignoni et al., 1997] use interval trees over the span space to select cubes
intersected by the isosurface.
Bloomenthal [Bloomenthal, 1988] and Howie and Blake [Howie and Blake,
1994] present seed growing algorithms to construct isosurfaces but do not de-
scribe how to ﬁnd or precompute seed sets. The algorithm for ﬁnding small seed
sets in Section 8.4.2 is based on [Itoh and Koyamada, 1995] by Itoh and Koya-
mada. Van Kreveld et al. [van Kreveld et al., 1997] and Carr and Snoeyink [Carr
and Snoeyink, 2003] construct small seed sets using contour trees. (See Sec-
tion 12.8.)
Other approaches to seed set construction are in [Bajaj et al.,
1996,Itoh and Koyamada, 1994,Itoh et al., 1996,Itoh et al., 2001].
In [Sutton et al., 2000], Sutton et al. compare data structures for isosurface
extraction, including the branch-on-need (BON) octree, three span space data
structures, and isosurface propagation from a seed set.
They found that all
approaches were two to three times faster than Marching Cubes. Cache misses
caused one of the span space data structures, the interval tree [Cignoni et al.,
1997], to have a noticeably worse performance than the other data structures.
View-dependent isosurface extraction is discussed in [Livnat and Hansen,
1998, Shi and JaJa, 2006]. Data structures for isosurface extraction from time-
varying data ﬁelds are discussed in [Shen, 1998,Shen et al., 1999,Vrolijk et al.,
2004,Gregorski et al., 2004,Wang and Chiang, 2009].
The data structures described in this chapter are not suitable for large data
sets that will not ﬁt into core memory. Out of core techniques for faster isosurface
extraction are described in [Chiang and Silva, 1997,Chiang et al., 1998,Chiang
and Silva, 1999, Sutton and Hansen, 2000, Gregorski et al., 2002, Chiang et al.,
2001,Bordoloi and Shen, 2003,Waters et al., 2006].

This page intentionally left blank
This page intentionally left blank

CHAPTER 9
MULTIRESOLUTION
TETRAHEDAL MESHES
The Marching Cubes algorithm and its variants create isosurfaces composed
of tremendous numbers of vertices and triangles. Such “large” isosurfaces require
considerable memory and are time-consuming to process and render.
The size of a mesh of simplices is the number of vertices and simplices in the
mesh. There are two diﬀerent approaches to reducing the size of an isosurface
mesh. The ﬁrst approach is to post-process the isosurface mesh, collapsing mesh
edges and triangles to create a smaller isosurface. The smaller isosurface should
approximate the original one, both geometrically and topologically. Reducing
the number of mesh elements by eliminating or collapsing elements is called
mesh decimation.
Mesh decimation is not unique to isosurface meshes and can be applied to any
surface mesh, regardless of how it was originally constructed. For this reason,
this book does not cover mesh decimation algorithms. Interested readers are
encouraged to see the book Tutorials on Multiresolution in Geometric Modelling
[Iske et al., 2002] or the survey papers [Cignoni et al., 1998], [Garland, 1999],
or [Luebke, 2001].
The second approach to reducing isosurface size is to use diﬀerent resolution
grids or meshes in diﬀerent portions of the scalar ﬁeld. In regions of high interest,
the isosurface is extracted from high-resolution subgrids while low-resolution
subgrids are used in areas of less interest. Special mesh elements are used to
connect the high-resolution and low-resolution subgrids. Extracting isosurfaces
using multiple levels of resolution is called multiresolution isosurface extraction.
Figure 9.1 contains two images of multiresolution isosurfaces. Figure 9.1(a)
is an image of a torus whose upper-left and lower-right regions are at high res-
olution.
Figure 9.1(b) contains a close-up of a tooth with one root at high
resolution. The torus isosurface has 3,608 triangles and the entire tooth isosur-
face (not shown) has 5,768 triangles. If the entire torus and tooth isosurfaces
281

282
9. Multiresolution Tetrahedral Meshes
(a)
(b)
Figure 9.1. Multiresolution isosurfaces.
(a) Multiresolution torus.
Upper-left and
lower-right regions on torus are at higher resolution. (b) Multiresolution tooth (close-
up). Data set created by GE Aircraft Engines.
were constructed at high resolution, they would have 5,344 and 13,888 triangles,
respectively.
In this chapter, we present an algorithm for multiresolution isosurface ex-
traction using multiresolution tetrahedral meshes. Our description follows the
presentation by Zhou, Chen, and Kaufmann in [Zhou et al., 1997] and by Gerst-
ner and Pajarola in [Gerstner and Pajarola, 2000]. In the following chapter, we
describe other algorithms for multiresolution isosurface extraction.
9.1
Bisection of Tetrahedra
9.1.1
2D Recursive Bisection
We start with a two-dimensional illustration of a multiresolution triangle mesh.
The diagonal (p0, p3) of a square (p0, p1, p2, p3) splits the square into two con-
gruent triangles. (See Figure 9.2.) Each triangle contains the diagonal and two
square edges. The center q0 of the diagonal is the center of the square. Bisect
the two triangles at q0, creating four congruent triangles. Each such triangle
contains one square edge. Bisect each triangle at the center of its square edge,
creating eight congruent triangles. Each of these eight triangles is a replica of
one of the two original triangles scaled by a factor of one-half.
The eight triangles form a triangle subdivision of the square.
Since they
are similar to the original triangles, the two bisections can be applied to these
triangles, creating a subdivision of the square into thirty-two triangles.
(See

9.1. Bisection of Tetrahedra
283
p0
p0
p0
p1
p1
p1
p2
p2
p2
p3
p3
p3
q0
q0
Figure 9.2. Triangle bisection.
p0
p0
p0
p1
p1
p1
p2
p2
p2
p3
p3
p3
Figure 9.3. Recursive triangle bisection.
Figure 9.3.) Each of these triangles is similar to the original triangles. Repeated
application of the bisection steps can lead to triangles of arbitrarily small size.
The triangles form a binary tree whose root is the original square.
(See
Figure 9.4.)
Each tree node other than the root represents a triangle.
The
two children of a node representing triangle t are the two triangles created by
splitting t into two congruent subtriangles. All the triangles represented at a
given level in the tree are congruent.
Note that each triangle edge is horizontal, vertical, or at 45 degrees. All
triangles are isosceles right triangles. After two bisections, the triangles form a
subdivision of the four subsquares of the original square. After four bisections,
the triangles form a subdivision of sixteen subsquares. Bisecting the triangles
2k times gives a subdivision of the 4k squares in a (2k + 1) × (2k + 1) grid.
By choosing to bisect only some of the triangles, we can construct a multires-
olution triangulation. For instance, in Figure 9.5 the original two triangles are
bisected into four triangles but only three of those four triangles are split again.
The next bisection is applied to only four triangles, the following bisection is
applied to three triangles, and the ﬁnal bisection to only two. The resulting tri-
angulation has triangles of various sizes, although all are either similar to triangle
(p0, p1, p3) or to triangle (p0, p1, q0).
In bisecting some but not all of the triangles, we still require that the resulting
set of triangles form a triangulation, i.e., that the intersection of every two triangles
is the empty set or a vertex of each triangle or an edge of each triangle. (See
Appendix B.5.) To ensure this property, we apply the following rule:

284
9. Multiresolution Tetrahedral Meshes
p0
p1
p2
p3
Figure 9.4. Binary tree representation.
p0
p0
p0
p0
p0
p0
p1
p1
p1
p1
p1
p1
p2
p2
p2
p2
p2
p2
p3
p3
p3
p3
p3
p3
q0
q0
Figure 9.5. Multiresolution triangulation.

9.1. Bisection of Tetrahedra
285
(a)
(b)
(c)
(d)
p0
p0
p0
p0
p1
p1
p1
p1
p2
p2
p2
p2
p3
p3
p3
p3
q0
q0
q0
q0
q1
q1
q1
q1
q2
q2
q2
q2
q3
q3
q3
q3
Figure 9.6. (a) Initial triangulation. (b) Split of triangle (q0, q1, p2) at q2 forces split
of triangle (q0, p2, p3).
(c) Split of triangle (q0, q1, p2) at q2 forces split of triangle
(q0, q3, p2). (d) Multiresolution triangulation. The intersection of every two triangles
is the empty set or a vertex of each triangle or an edge of each triangle.
Bisection Rule (2D, N×N). If triangle t is split at point q and q lies in the interior
of an edge of triangle t′, then triangle t′ is split.
For instance, in Figure 9.6, splitting triangle (q0, q1, p2) at q2 forces the split
of triangle (q0, p2, p3). Note that triangle (q0, p2, p3) is split at q3, not at q2.
Triangle (q0, p2, p3) splits into two triangles, (q0, q3, p2) and (q0, q3, p3). Point
q2 lies in the interior of edge (q0, p2) of triangle (q0, q3, p2). Therefore, triangle
(q0, q3, p2) is split into two triangles. This time the split is at q2. The ﬁnal set
of triangles form a triangulation of the square.
Proposition 9.1. Let τ c be a triangulation of the square into two triangles sharing
a square diagonal. If a sequence of splits of τc follows the Bisection Rule, then
the resulting set τ of triangles is a triangulation of the square.
Proof: Assume that the nonempty intersection of two triangles t, t′ ∈τ is not a
vertex or edge of t. Since the triangles in τ partition the square, the interiors of
t and t′ do not intersect. Thus the intersection must be a point or line segment
on an edge e of t. If the intersection is a point, then this point must be a vertex
q of t′. If the intersection is a line segment on edge e of t, then, by assumption,
this line segment does not equal e. Some endpoint of this line segment lies in
the interior of e. This endpoint is again a vertex q of t′.
Vertex q was created by splitting some triangle t′′ at q. Point q is in the
interior of an edge of t but t is not split, violating the Bisection Rule.
We
conclude that the intersection of every two triangles of τ is the empty set or a
vertex or edge of t. Thus τ is a triangulation of the square.
□
9.1.2
3D Recursive Bisection
A three-dimensional cube can be subdivided into six tetrahedra as in Figure 9.7.
Each of the tetrahedra is the convex hull of cube diagonal (p0, p7) and one of the
six cube edges not incident on p0 or p7.

286
9. Multiresolution Tetrahedral Meshes
p0
p1
p2
p3
p4
p5
p6
p7
Figure 9.7. Subdivision of a cube into six tetrahedra. Each tetrahedron is the convex
hull of the red diagonal (p0, p7) and one of the green cube edges. All six tetrahedra are
congruent.
p0
p0
p0
p0
p0
p0
p1
p1
p1
p1
p2
p2
p2
p3
p3
p3
p3
p4
p4
p4
p5
p5
p5
p6
p6
p6
p7
p7
p7
p7
q0
q0
q0
q1
q1
q1
q1
q2
q2
q2
q2
q2
Type A
Type B
Type C
Figure 9.8. Recursive tetrahedral bisection.
All six of the tetrahedra are congruent. Each tetrahedron has three edges
that are cube edges, two edges that are facet diagonals, and one edge (p0, p7)
that is a diagonal of the cube. The center q0 of diagonal (p0, p7) is the center
of the cube. Consider tetrahedron (p0, p1, p3, p7). Bisecting this tetrahedron at
point q0 splits the tetrahedron into two congruent tetrahedra. (See Figure 9.8.)
Each of these tetrahedra contains one edge that is the diagonal of a cube facet.
For instance, tetrahedron (p0, p1, p3, q0) has an edge (p0, p3), which is the diag-
onal of the bottom facet of the cube. Bisecting tetrahedron (p0, p1, p3, q0) at
the center q1 of diagonal (p0, p3) splits it into two congruent tetrahedra. Each of
these tetrahedra contains one edge that is an edge of the original cube. Bisecting

9.1. Bisection of Tetrahedra
287
p0
p0
p1
p1
p2
p2
p3
p3
p4
p4
p5
p5
p6
p6
p7
p7
q0
q0
q1
q1
q2
q2
Figure 9.9. Tetrahedron (p0, p1, p3, p7) is similar to tetrahedron (p0, q2, q1, q0). Tetra-
hedron (p0, q2, q1, q0) is the result of three bisections of tetrahedron (p0, p1, p3, p7).
tetrahedron (p0, p1, q1, q0) at the midpoint q2 of edge (p0, p1) split it into two con-
gruent tetrahedra. These two tetrahedra are similar to the original tetrahedron,
(p0, p1, p3, p7), i.e., they are congruent to the tetrahedron formed by shrinking
(p0, p1, p3, p7) by a factor of one-half. (See Figure 9.9.)
The original six congruent tetrahedra sharing the diagonal (p0, p7) divide into
twelve congruent tetrahedra, each containing one facet diagonal. These twelve
tetrahedra subdivide into twenty-four congruent tetrahedra, each containing ex-
actly one cube edge. These twenty-four tetrahedra subdivide into forty-eight
tetrahedra.
Since these forty-eight tetrahedra are similar to the original six
tetrahedra, the three bisection steps can be repeated on these forty-eight tetra-
hedra, creating tetrahedra whose edges are one-fourth the original size. Repeated
application of the bisection steps can lead to tetrahedra of arbitrarily small size.
The tetrahedra form a tree whose root is the original cube. The root has
six children, one for each of the six tetrahedra in the triangulation of the cube.
Each tree node other than the root represents a tetrahedron. The two children
of a node representing tetrahedron t are the two tetrahedra created by splitting
t into two congruent tetrahedra. All the tetrahedra represented at a given level
in the tree are congruent.
Let Γ be a (2k + 1)×(2k + 1)×(2k + 1) grid containing 23k cubes. Triangulate
the cubic region covered by Γ with six tetrahedra sharing the diagonal from vertex
(0, 0, 0) to vertex (2k, 2k, 2k). Recursively bisect these tetrahedra 3k times. The
set of all tetrahedra produced by 3k or fewer bisections form a tree. We call this
a full-resolution tree of Γ.
We note a few things about this recursive bisection scheme. First, all tetra-
hedra can be divided into three types of similar tetrahedra. The three types are
shown in Figure 9.8. Second, after three bisection steps, each of the resulting
forty-eight tetrahedra has an edge from one of the cube vertices pi to q0, the cen-
ter of the cube. Conversely, for each cube vertex pi, exactly six of the forty-eight
tetrahedra contain the edge (pi, q0) and these six tetrahedra form a triangulation
of the cube with opposite vertices pi and q0. Thus the three bisection steps con-
vert a triangulation of a cube into a triangulation of the eight subcubes of that
cube. Repeating the bisection steps another three times gives a triangulation of

288
9. Multiresolution Tetrahedral Meshes
82 subcubes of the original cube. Repeating the bisection steps 3k times gives a
triangulation of the 23k cubes in a (2k + 1) × (2k + 1) × (2k + 1) grid.
By choosing to bisect only some of the tetrahedra, we can construct a mul-
tiresolution triangulation. As in 2D, we require that the resulting set of tetrahe-
dra form a triangulation, i.e., that the intersection of every two tetrahedra is either
the empty set or a vertex, edge, or face of each tetrahedron. (See Appendix B.5.)
We apply the following rule to enforce this property:
Bisection Rule (3D, N×N×N). If tetrahedron t is split at point q, and if q lies in
the interior of an edge of tetrahedron t′, then tetrahedron t′ is split.
A sequence of splits that follows the Bisection Rule creates a triangulation
of the cube.
Proposition 9.2. Let τ c be a triangulation of the cube into six tetrahedra sharing
a cube diagonal. If a sequence of splits of τc follows the Bisection Rule, then the
resulting set τ of tetrahedra is a triangulation of the cube.
Proof is left for Section 9.1.3.
For each tetrahedron t in the full-resolution tree of Γ, let qsplit(t) be the point
used to split t into two congruent tetrahedra. Point qsplit(t) is the midpoint of
some edge of t.
Let Pj(Γ) be the partition of grid Γ into cubes with edge length 2j. Let P∗(Γ)
be the set of all the cubes in Pj(Γ) for j = 2 to k. The vertices, edges, and facets
in P∗(Γ) are the set of vertices, edges, and facets, respectively, of all the cubes in
Pj(Γ) for j = 2 to k. Let qcenter(c), qcenter(f) and qcenter(e) represent the centers
of cube c, facet f, and edge e, respectively.
The following propositions relates the tetrahedra in the full-resolution tree
to the centers of edges, facets, and cubes in Pj(Γ).
Proposition 9.3. Let Γ be a (2k + 1) × (2k + 1) × (2k + 1) grid containing 23k
cubes. If tA, tB, and tC are type A, type B, and type C tetrahedra, respectively,
in the full-resolution tree of Γ, then there exists cube c, a facet f, and an edge e
in P∗(Γ) such that
• qsplit(tA) equals qcenter(c),
• qsplit(tB) equals qcenter(f),
• qsplit(tC) equals qcenter(e).
Moreover,
1. if bisecting tA creates tB, then f is a facet of c;
2. if bisecting tB creates tC, then e is an edge of f;
3. if bisecting tC creates tA, then qcenter(e) is a vertex of c.

9.1. Bisection of Tetrahedra
289
qA
qA
qA
qB
qB
qC
qC
qC
tA
tA
tB
tB
tC
tC
c
c
c
f
f
f
f
e
e
e
e
c′
c′
(a)
(b)
(c)
Figure 9.10. Bisecting tetrahedra. (a) Bisecting tetrahedron tA creates tetrahedron
tB. Facet f is a facet of cube c. Point qA is qsplit(c). Point qB is qsplit(f). (b) Bisecting
tetrahedron tB creates tetrahedron tC.
Edge e is an edge of facet f.
Point qB is
qsplit(f). Point qC is qsplit(e). (c) Bisecting tetrahedron tC creates tetrahedron tA.
Edge e is an edge of cube c′. Cube c is a subcube of cube c′. Point qC is qsplit(e) and
a vertex of cube c. Point qA is qsplit(c).
Note that statements 1, 2, and 3 in the proposition are independent. In the
ﬁrst statement, f is a facet of c. In the second, e is an edge of f. In the third, c
is a cube whose edge length is half the length of e. Obviously, all three of these
properties cannot be simultaneously true.
Proof of Proposition 9.3: Let 2j be the length of the edges of tA that are parallel
to the coordinate axes. Tetrahedron tA shares its vertices with some cube c in
Pj(Γ). Tetrahedron tA is split at the center of c. (See Figure 9.10(a).)
Tetrahedron tB is created by bisecting some type A tetrahedron. Without
loss of generality, assume this tetrahedron is tA. Tetrahedron tB is split at some
point at the center of a facet f of c.
Tetrahedron tC is created by bisecting some type B tetrahedron. Without
loss of generality, assume this tetrahedron is tB. Tetrahedron tC is split at the
center of some edge e of f. (See Figure 9.10(b).)
Now assume tetrahedron tA is created by bisecting tetrahedron tC. Cube c is
one of the eight subcubes of a cube c′ ∈Pj+1(Γ). Tetrahedron tC is split at the
center of some edge e of c′ and qcenter(e) is a vertex of c. (See Figure 9.10(c).)□
The following proposition is the converse of the previous one.

290
9. Multiresolution Tetrahedral Meshes
Proposition 9.4. Let Γ be a (2k + 1) × (2k + 1) × (2k + 1) grid containing 23k
cubes.
1. If c is a cube in P∗and f is a facet of c and e is an edge of f, then the
full-resolution tree contains a type A tetrahedron tA, a type B tetrahedron
tB, and a type C tetrahedron tC such that
• qsplit(tA) equals qcenter(c),
• qsplit(tB) equals qcenter(f),
• qsplit(tC) equals qcenter(e),
• splitting tA creates tB,
• splitting tB creates tC.
2. If c is a cube in P∗and v is a vertex of c and is not a corner of grid Γ, then
the full-resolution tree contains a type A tetrahedron tA and a tetrahedron
t such that
• qsplit(tA) equals qcenter(c),
• qsplit(t) equals v,
• tA is contained in t.
Tetrahedron t in Statement 2 is not necessarily a type C tetrahedron.
Proof: If c is a cube in P∗(Γ), then the full-resolution tree contains six type A
tetrahedra that share a diagonal of c and that triangulate c.
Each of these
tetrahedra are split at the center of c.
The six type A tetrahedra triangulating c split into twelve type B tetrahedra.
Since f is a facet of c, two of these share the diagonal of f. These two are split
at the center of f.
Since e is an edge of f, one of the twelve type B tetrahedra contains both e
and the diagonal of f. The bisection of this type B tetrahedra creates a type C
tetrahedra tC containing e. Tetrahedron tC is split at the center of e.
Assume v is a vertex of c and is not a corner of grid Γ. Since v is not a
corner of Γ, vertex v was created by the bisection of some tetrahedron t in the
full-resolution tree. Tetrahedron t was split at v.
Tetrahedron t intersects the interior of c. Thus at least one of the six type
A tetrahedra triangulating c is contained in t.
□
9.1.3
3D Bisection Proof
We present the proof of Proposition 9.2. For convenience, we restate the propo-
sition.

9.1. Bisection of Tetrahedra
291
(a)
(b)
(c)
t
t
t
f
f
t′
t′
t′
t′′
t′′
t′′
tk
tk+1
q
q
Figure 9.11. Intersecting tetrahedra. (a) Tetraheda t′′ and t are congruent and share
a face f. Tetrahedron t′ is a subset of t′′. (b) Tetrahedron tk where t′ ⊂tk ⊂t′′
and tk ∩t = f.
(c) Tetrahedron tk+1 produced by splitting tk at point q.
Note
t′ ⊂tk+1 ⊂tk ⊂t′′. The intersection tk+1 ∩t is not a face of t.
Proposition 9.2.
Let τ c be a triangulation of the cube into six tetrahedra sharing
a cube diagonal. If a sequence of splits of τc follows the Bisection Rule, then the
resulting set τ of tetrahedra is a triangulation of the cube.
Proof: For a tetrahedron t in the full-resolution tree, let τcong(t) be the set of
all tetrahedra congruent to t in the full-resolution tree. Set τcong(t) forms a
triangulation of the cube. Every tetrahedron t′ that is not congruent to t is
either contained in some tetrahedron congruent to t or contains some tetrahedron
congruent to t.
Let t and t′ be two intersecting tetrahedra in τ. Since the tetrahedra in τ
partition the cube, t is not a subset of t′ and t′ is not a subset of t. Without
loss of generality, assume that t′ is contained in a tetrahedron t′′ ∈τcong(t)
congruent to t. (See Figure 9.11(a).)
Since τcong(t) is a triangulation, t∩t′′ is a face f of t′′. Since t∩t′ is a subset
of t ∩t′′, intersection t ∩t′ is a face of t′.
We need to show that t ∩t′ is a face of t. Assume that t ∩t′ is not a face of
t. Since t ∩t′′ is a face of t, tetrahedron t′ is not equal to t′′. Thus tetrahedron
t′′ must be split.

292
9. Multiresolution Tetrahedral Meshes
Let t0, t1, . . . , tm be a sequence of splits where
1. tetrahedron t0 equals t′′,
2. tetrahedron tm equals t′,
3. tetrahedron ti+1 is one of the two tetrahedra created by splitting ti.
Since t0 equals t′′ and tm equals t′, it follows that t′ ⊆ti ⊆t′′ for all i.
Let tk be the smallest tetrahedron in the sequence such that t ∩tk equals
t∩t′′ (Figure 9.11(b)). Since t∩t′ does not equal t∩t′′, tetrahedron tk does not
equal tm. Thus tk is split at some point q. Since t ∩tk is face of t and t ∩tk+1
is not, point q lies on the interior of an edge of t. (See Figure 9.11(c).)
Point q is in the interior of an edge of t but t is not split, violating the
Bisection Rule. We conclude that t ∩t′ is a face of t. Since t ∩t′ is a face of t
and of t′ for every two intersecting tetrahedra t, t′ ∈τ, set τ is a triangulation
of the cube.
□
9.2
Multiresolution Isosurfaces
9.2.1
Multiresolution Grid
We need a quick, eﬃcient way to determine if a tetrahedron is split in a multires-
olution triangulation. Let Γ be a (2k + 1) × (2k + 1) × (2k + 1) grid containing
23k cubes.
Let t be any tetrahedron in an internal node of the full-resolution tree. Be-
cause the grid vertices are the coordinates from (0, 0, 0) to (2k, 2k, 2k), point
qsplit(t) always lies on a grid vertex. For instance, if t is one of initial six tetra-
hedra, then qsplit(t) is the midpoint of the diagonal ((0, 0, 0), (2k, 2k, 2k)). This
midpoint is the grid vertex (2k−1, 2k−1, 2k−1). After the ﬁrst split, two of the
tetrahedra, t′ and t′′, contain the edge ((0, 0, 0), (2k, 2k, 0)). These two tetra-
hedra are split at (2k−1, 2k−1, 0), the midpoint of edge ((0, 0, 0), (2k, 2k, 0)), and
thus qsplit(t′) = qsplit(t′′) = (2k−1, 2k−1, 0).
If tetrahedron t is a leaf of the full-resolution tree, then it lies entirely in one
grid cube and its vertices lie on the corners of that cube. Point qsplit(t) is the
center of the cube, which is not a grid vertex.
We represent the multiresolution triangulation by a multiresolution grid ΓM of
(2k + 1) × (2k + 1) × (2k + 1) Boolean values. The grid vertices represent the
points qsplit(t) for all tetrahedra t at internal nodes of the full-resolution tree.
The points qsplit(t) for tetrahedra t at the leaves of the tree are not represented
but tetrahedra at the leaves are never split into smaller tetrahedra.

9.2. Multiresolution Isosurfaces
293
The multiresolution grid ΓM deﬁnes a partition of the grid into tetrahedra.
Starting from the initial six tetrahedra, bisect tetrahedron t if ΓM(qsplit(t)) is
true. Repeat this process on the resulting tetrahedra until either t is a leaf of the
full-resolution tree or ΓM(qsplit(t)) is false. The resulting tetrahedra partition
the grid into tetrahedra. However, the sequence of splits does not necessarily
satisfy the Bisection Rule from Section 9.1.2, and the resulting set of tetrahedra
is not necessarily a triangulation. To ensure a triangulation, we must impose a
condition on the multiresolution grid.
In order for the multiresolution grid to represent a multiresolution triangu-
lation, we require that the multiresolution grid satisfy the following condition:
Multiresolution Condition (N×N×N). Let tetrahedron t be an internal node of the
full-resolution tree. If t is a child of tetrahedron t′ in the full-resolution tree and
ΓM(qsplit(t)) is true, then ΓM(qsplit(t′)) is true.
Note that the Multiresolution Condition implies that if t is a descendant of
t′ in the full-resolution tree and ΓM(qsplit(t)) is true, then ΓM(qsplit(t′)) is true.
We claim that the multiresolution grid satisfying the Multiresolution Condition
deﬁnes a triangulation of the grid.
Proposition 9.5. If a multiresolution grid of a cubic region satisﬁes the Multires-
olution Condition, then the set of tetrahedra deﬁned by the multiresolution grid
is a triangulation of the cubic region.
Proof: Consider two tetrahedra, t and t′, such that qsplit(t) lies on the interior
of an edge of t′. Assume t is split. We wish to show that t′ is split.
Let τ be the triangulation of the grid via bisection into tetrahedra that are
all congruent to t. Some tetrahedron t′′ in τ contains t∩t′ and is contained in t′.
Since qsplit(t) lies in the interior of an edge of t and t∩t′′ is an edge or facet of t,
point qsplit(t) lies in the interior of an edge of t′′. Since t′′ is congruent to t, point
qsplit(t′′) equals qsplit(t) and ΓM(qsplit(t′′) equals ΓM(qsplit(t)). Since t is split,
ΓM(qsplit(t)) is true and so ΓM(qsplit(t′′)) = ΓM(qsplit(t)) is true. Tetrahedron t′
contains t′′. By the Multiresolution Condition, ΓM(qsplit(t′)) is also true. Thus
tetrahedron t′ is split, satisfying the Bisection Rule. By Proposition 9.2, the
resulting set of tetrahedra is a triangulation of the grid.
□
Given a grid of Boolean values, we wish to turn it into a multiresolution
grid satisfying the Multiresolution Condition. We do so by changing some of the
false values to true. Of course, we could satisfy the Multiresolution Condition by
setting all values to true, but then we would have a full-resolution triangulation,
not a multiresolution one.
The challenge is to set values to true only where
necessary.
A multiresolution grid ΓM violates the Multiresolution Condition if tetrahe-
dron t is a child of tetrahedron t′ in the full-resolution tree and ΓM(qsplit(t)) is
true while ΓM(qsplit(t′)) is false. To ﬁx this violation, we need to set ΓM(qsplit(t′))

294
9. Multiresolution Tetrahedral Meshes
to true. We could create and process a full-resolution tree but it is much more
eﬃcient to work directly on the multiresolution grid ΓM.
As in Section 9.1.2, let Pj(ΓM) be the partition of grid ΓM into cubes of
edge length 2j. Let c be a cube in Pj(ΓM), f a facet of c, and e an edge of
f. By Proposition 9.4, there are tetrahedra tA, tB, and tC such that qsplit(tA),
qsplit(tB), and qsplit(tC) are the centers of c, f, and e, respectively, and splitting
tA creates tB and splitting tB creates tC. Thus, if ΓM(qcenter(f)) is true and
ΓM(qcenter(c)) is false, then the multiresolution grid violates the Multiresolution
Condition. Similarly, if ΓM(qcenter(e)) is true and ΓM(qcenter(f)) is false, then
there is also a violation of the multiresolution condition. To ﬁx such violations,
set ΓM(qcenter(c)) to true whenever ΓM(qcenter(f)) is true for any facet f of c,
and set ΓM(qcenter(f)) to true whenever ΓM(qcenter(e)) is true for any edge e
of f.
Let v be a vertex of c that is not a corner of the grid ΓM. By Proposition 9.4,
there is a type A tetrahedron tA and a tetrahedron t such that qsplit(tA) is the
center of c and qsplit(t) equals v and tA is contained in t. If ΓM(qcenter(c)) is
true and ΓM(v) is false, then the multiresolution grid violates the Multiresolution
Condition. Set ΓM(v) to true whenever qcenter(c) is true for any edge vertex v
of c.
Changing ΓM(qsplit(t)) from false to true for tetrahedron t can create new
violations of the Multiresolution Condition. If tetrahedron t′ is the parent of t
in the full-resolution grid and ΓM(qsplit(t′)) is false, then setting ΓM(qsplit(t)) to
true creates a violation at t and t′. To eliminate all violations of the Multires-
olution Condition, we need to ﬁrst process cubic regions of edge length 2, then
cubic regions of edge length 4, etc. Within each cubic region c, we ﬁrst check
edge midpoints to see if facet centers must be set to true. We then check facet
centers to see if qcenter(c) must be set to true. Finally, we check qcenter(c) to see
if the corners of c must be set to true. Pseudocode for procedure SatisfyMul-
tiresN×N×N is presented in Algorithm 9.1.
We claim that the multiresolution grid produced by SatisfyMultires-
N×N×N satisﬁes the Multiresolution Condition.
Proposition 9.6. Let ΓM be an n×n×n grid of Boolean values where n = 2k +1.
After the application of procedure SatisfyMultiresN×N×N to ΓM, grid ΓM
satisﬁes the Multiresolution Condition.
Proof: Let t be a child of tetrahedron t′ in the full-resolution tree. We need to
show that if ΓM(qsplit(t)) is true, then ΓM(qsplit(t′)) is true.
Case I: Tetrahedron t is a type A tetrahedron.
Let ct be the cube in P∗(g) such that qcenter(ct) equals qsplit(t). Since t
is type A, tetrahedron t′ must be type C. By Proposition 9.3, point qsplit(t′)
is a vertex of ct.

9.2. Multiresolution Isosurfaces
295
Input
: ΓMis an n × n × n array of Boolean values where n = 2k + 1.
k determines the dimensions of ΓM.
SatisfyMultiresNxNxN(ΓM, k)
1 for j = 1 to k do
/* Pj(ΓM) is the partition of ΓMinto cubes of edge length 2j
*/
2
foreach edge e in Pj(ΓM) do
/* qcenter(e) is the midpoint of edge e
*/
3
if (ΓM(qcenter(e)) = true) then
4
foreach facet f ∈Pj(ΓM) containing e do
/* qcenter(f) is the center of facet f
*/
5
ΓM(qcenter(f)) ←true;
6
end
7
end
8
end
9
foreach facet f in Pj(ΓM) do
10
if (ΓM(qcenter(f)) = true) then
11
foreach cube c ∈Pj(ΓM) containing f do
/* qcenter(c) is the center of cube c
*/
12
ΓM(qcenter(c)) ←true;
13
end
14
end
15
end
16
foreach cube c in Pj(ΓM) do
17
if (G(qcenter(c)) = true) then
18
foreach corner v of c do
19
ΓM(v) ←true;
20
end
21
end
22
end
23 end
Algorithm 9.1. SatisfyMultiresN×N×N for n × n × n grids where n =
2k + 1.
Cube ct is in Pj for some j. Consider the jth iteration of the main loop
of SatisfyMultiresN×N×N. In Steps 16–22, if ΓM(qcenter(ct)) is true,
then ΓM(v) is set to true for every vertex v of c. Note that Steps 16–22
do not modify ΓM(qcenter(ct)). The value of ΓM(qcenter(ct)) can never be
modiﬁed after Step 22, since j increases at the next iteration of the main
loop. Thus, if ΓM(qsplit(t)) is true, then ΓM(qsplit(t′)) is true.

296
9. Multiresolution Tetrahedral Meshes
Case II: Tetrahedron t is a type B tetrahedron.
Since t is type B, tetrahedron t′ must be type A. Let ft be the facet and
ct′ be the cube in P∗(G) such that qcenter(ft) equals qsplit(t) and qcenter(ct′)
equals qsplit(t′). By Proposition 9.3, ft is a facet of ct′.
Cube ct′ is in Pj for some j. Consider the jth iteration of the main loop
of SatisfyMultiresN×N×N. In Steps 9–15, if ΓM(qcenter(ft)) is true, then
the value of ΓM(qcenter(ct′)) is set to true. Note that Steps 9–22 do not
modify ΓM(qcenter(ft)). The value of ΓM(qcenter(ft)) can never be modiﬁed
after Step 22, since j increases at the next iteration of the main loop. Thus,
if ΓM(qsplit(t)) is true, then ΓM(qsplit(t′)) is true.
Case III: Tetrahedron t is a type C tetrahedron.
Since t is type C, tetrahedron t′ must be type B. Let et be the edge and
ft′ be the facet in P∗(G) such that qcenter(et) equals qsplit(t) and qcenter(ft′)
equals qsplit(t′). By Proposition 9.3, et is an edge of ft′.
Facet ft′ is in Pj for some j. Consider the jth iteration of the main loop
of SatisfyMultiresN×N×N. In Steps 2–8, if ΓM(qcenter(et)) is true, then
the value of ΓM(qcenter(ft′)) is set to true. Note that Steps 2–22 do not
modify ΓM(qcenter(et)). The value of ΓM(qcenter(et)) can never be modiﬁed
after Step 22, since j increases at the next iteration of the main loop. Thus,
if ΓM(qsplit(t)) is true, then ΓM(qsplit(t′)) is true.
□
9.2.2
Isosurface Extraction
Algorithm Multiresolution Marching Tetrahedra N×N×N extracts a
multiresolution isosurface from a multiresolution triangulation of an n × n × n
grid where n = 2k + 1. Input to the algorithm is a scalar grid, ΓS; an array,
Coord, of grid coordinates; a set, RegionList, of high-resolution regions; and a
scalar value σ. (See Figure 9.12 and Algorithm 9.2.)
The algorithm has four steps. The ﬁrst step is to convert the high-resolution
regions to a multiresolution grid, ΓM (Algorithm 9.3, CreateMultiresGrid-
N×N×N). Every vertex within the high-resolution regions is set to true. All other
vertices are set to false. Procedure SatisfyMultiresN×N×N (Algorithm 9.1)
is applied to the multiresolution grid so that it satisﬁes the Multiresolution Con-
dition.
The second step in the algorithm is to read the isosurface lookup table from
a preconstructed data ﬁle. Entries in the table correspond to conﬁgurations of
(“+”,“−”) labels of a tetrahedron.
The multiresolution grid represents a multiresolution triangulation.
The
third algorithm step is to extract isosurface patches from the tetrahedra in this
triangulation. Instead of explicitly constructing the triangulation, we recursively
descend the full-resolution tree, identifying and processing the tetrahedra in the

9.2. Multiresolution Isosurfaces
297
Input
: ΓS is an n × n × n array of scalar values where n = 2k + 1 for
some integer k.
Coord is a 3D array of (x, y, z) coordinates.
RegionList is a list of regions in ΓS.
σ is an isovalue.
MultiresMarchingTetNxNxN(ΓS, Coord, RegionList, σ)
1 CreateMultiresGridNxNxN(ΓS,RegionList,ΓM);
2 Read Marching Cubes lookup table into Table;
3 T ←∅;
4 τ c ←triangulation of grid ΓM into six tetrahedra sharing edge
((0, 0, 0), (2k, 2k, 2k));
5 foreach tetrahedron t ∈τc do
6
Let (p0, p1, p2, p3) be the vertices of t where:
p0 = (0, 0, 0) and
p1 ∈{(2k, 0, 0), (0, 2k, 0), (0, 0, 2k)} and
p2 ∈{(2k, 2k, 0), (2k, 0, 2k), (0, 2k, 2k)} and
p3 = (2k, 2k, 2k).
7
MultiresRecursiveA(ΓS,ΓM,σ,p0, p1, p2, p3, 2k,T, Table);
8 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
9 E ←
(e1,e2,e3)∈T{e1, e2, e3};
10 foreach edge e ∈E with endpoints (i1, j1, k1) and (i2, j2, k2) do
11
ue ←LinearInterpolation
12
(Coord[i1, j1, k1], ΓS[i1, j1, k1], Coord[i2, j2, k2], ΓS[i2, j2, k2], σ);
13 end
/* Convert T to set of triangles
*/
14 Υ ←∅;
15 foreach triple of edges (e1, e2, e3) ∈T do
16
Υ ←Υ ∪{(ue1, ue2, ue3)};
17 end
Algorithm 9.2. Multiresolution Marching Tetrahedra N×N×N for
n × n × n grids where n = 2k + 1.
tree. Upon reaching a tetrahedron t, if t is a leaf of the tree or if ΓM(qsplit(t))
is false, then an isosurface patch is extracted from t. Otherwise, t is split into
two tetrahedra, t′ and t′′, and we repeat the procedure on t′ and t′′.
The isosurface vertices lie on bipolar edges of a multiresolution triangulation
of the grid. The ﬁnal step in the algorithm is to assign geometric locations to the
isosurface vertices based on the scalar values at the endpoints of these bipolar
edges.

298
9. Multiresolution Tetrahedral Meshes
Create a multiresolution grid satisfying the Multiresolution Condition

Read isosurface lookup table

Extract the isosurface from the multiresolution triangulation
represented by the multiresolution grid

Compute isosurface vertex coordinates using linear interpolation
Figure 9.12. Multiresolution Marching Tetrahedra N×N×N for n × n × n grids
where n = 2k + 1.
Input
: ΓS is an n × n × n array of scalar values where n = 2k + 1 for
some integer k.
RegionList is a list of regions in ΓS.
Output
: ΓMis an n × n × n array of Boolean values satisfying the
Multiresolution Condition.
CreateMultiresGridNxNxN(ΓS, RegionList, ΓM)
1 Initialize ΓM(v) to false for all vertices v;
2 foreach region R in RegionList do
3
foreach vertex v in R do
4
ΓM(v) ←true;
5
end
6 end
7 SatisfyMultiresNxNxN (ΓM, k);
Algorithm 9.3. Procedure CreateMultiresGridN×N×N for n×n×n grids
where n = 2k + 1.
We describe the third algorithm step, extracting the isosurface, in more de-
tail.
Grid ΓM has a triangulation comprised of six tetrahedra sharing edge
((0, 0, 0), (2k, 2k, 2k)). We call procedure MultiresRecursiveA (Algorithm 9.4)
on each of the six tetrahedra.
Procedure MultiresRecursiveA takes as input the scalar grid ΓS, the
multiresolution grid ΓM, the isovalue σ, the four vertices, p0, p1, p2, p3, of a type

9.2. Multiresolution Isosurfaces
299
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
ΓMis an n1 × n2 × n3 array of Boolean values satisfying
the Multiresolution Condition.
σ is an isovalue.
p0, p1, p2, p3 are vertices of a type A tetrahedron.
L is the length of line segment (p0, p1).
T is a set of edge triples representing isosurface triangles.
Table is the isosurface lookup table.
MultiresRecursiveA(ΓS, ΓM, σ, p0, p1, p2, p3,L, T,Table)
1 if (L = 1) then
2
ExtractIsoPatch(ΓS, σ, p0, p1, p2, p3,T,Table);
3 else
4
q0 ←midpoint of line segment (p0, p3);
5
if (ΓM(q0) = false) then
6
ExtractIsoPatch(ΓS, σ, p0, p1, p2, p3,T,Table);
7
else
8
MultiresRecursiveB(ΓS,ΓM,p0, p1, p2,q0, L, T,Table);
9
MultiresRecursiveB(ΓS,ΓM,p3, p2, p1,q0, L, T,Table);
10
end
11 end
**********
Input
: ΓS, ΓM, σ, L and T are as deﬁned above.
p0, p1, p2,q0 are vertices of a type B tetrahedron.
MultiresRecursiveB(ΓS, ΓM, σ, p0, p1, p2, q0,L, T, Table)
1 q1 ←midpoint of line segment (p0, p2);
2 if (ΓM(q1) = false) then
3
ExtractIsoPatch(ΓS, σ, p0, p1, p2, q0, T, Table);
4 else
5
MultiresRecursiveC(ΓS,ΓM,p0, p1,q1,q0, L, T, Table);
6
MultiresRecursiveC(ΓS,ΓM,p2, p1,q1,q0, L, T, Table);
7 end
**********
Input
: ΓS, ΓM, σ, L and T are as deﬁned above.
p0, p1, q1, q0 are vertices of a type C tetrahedron.
MultiresRecursiveC(ΓS, ΓM, σ, p0, p1, q1, q0,L, T, Table)
1 q2 ←midpoint of line segment (p0, p1);
2 if (ΓM(q2) = false) then
3
ExtractIsoPatch(ΓS, σ, p0, p1, q1, q0,T,Table);
4 else
5
MultiresRecursiveA(ΓS,ΓM,p0, q2, q1, q0, L/2, T, Table);
6
MultiresRecursiveA(ΓS,ΓM,p2, q2, q1, q0, L/2, T, Table);
7 end
Algorithm 9.4. Multires Recursive.

300
9. Multiresolution Tetrahedral Meshes
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
σ is an isovalue.
p0, p1, p2, p3 are vertices of a tetrahedron.
T is a set of edge triples representing isosurface triangles.
Table is the isosurface lookup table.
ExtractIsoPatch(ΓS, σ, p0, p1, p2, p3, T, Table)
/* Assign “+” or “−” signs to each vertex
*/
1 for i = 0 to 3 do
2
if ΓS(pi) < σ then Sign[pi] ←“−”;
3
else Sign[pi] ←“+”;
/* ΓS(pi) ≥σ */
4 end
5 κ ←(Sign[p0], Sign[p1], Sign[p2], Sign[p3]);
6 foreach edge triple (e1, e2, e3) ∈Table[κ] do
7
for j = 1 to 3 do
8
e′
i ←edge of tetrahedron (p0, p1, p2, p3) corresponding to ei;
9
end
10
Insert edge triple (e′
1, e′
2, e′
3) into T;
11 end
Algorithm 9.5. ExtractIsoPatch.
A tetrahedron, and the length L of line segment (p0, p1). (See Figure 9.8 for an
illustration of the three types of tetrahedra.) The vertices of the tetrahedron
should be a subset of the vertices of an L × L × L cubic region with p0 and p3 on
opposite corners of the cubic region. Line segments (p0, p1), (p1, p2), and (p2, p3)
should be edges of the cubic region.
If length L equals one, then tetrahedron t = (p0, p1, p2, p3) is as small as
possible and can be split no further. MultiresRecursiveA calls procedure
ExtractIsoPatch (Algorithm 9.5) to extract the isosurface patch from tetra-
hedron t.
Otherwise, MultiresRecursiveA computes the midpoint, q0, of
line segment (p0, p3). Point q0 is a grid vertex. If ΓM(q0) is false, then tetrahe-
dron t is not split and MultiresRecursiveA calls ExtractIsoPatch on t.
If ΓM(q0) is true, then tetrahedron t is split into two tetrahedra, (p0, p1, p2, q0)
and (p3, p2, p1, q0), of type B. Procedure MultiresRecursiveA calls Procedure
MultiresRecursiveB on these two tetrahedra.
Procedure MultiresRecursiveB takes as input the scalar grid ΓS, the mul-
tiresolution grid ΓM, the isovalue σ, the four vertices, p0, p1, p2, q0, of a type B
tetrahedron, and the length L of line segment (p0, p1). Vertices (p0, p1, p2) should
be a subset of the vertices of an L×L×L cubic region with q0 at the cube center.
Line segments (p0, p1) and (p1, p2) should be edges of that cubic region.

9.2. Multiresolution Isosurfaces
301
Procedure MultiresRecursiveB computes the midpoint, q1, of line seg-
ment (p0, p1). Point q1 is a grid vertex. If ΓM(q1) is false, then tetrahedron
t = (p0, p1, p2, q0) is not split and MultiresRecursiveB calls procedure Ex-
tractIsoPatch on t. If ΓM(q1) is false, then tetrahedron t is split into two
tetrahedra, (p0, p1, q1, q0) and (p2, p1, q1, q0), of type C. Procedure Multires-
RecursiveB calls procedure MultiresRecursiveC on these two tetrahedra.
Procedure MultiresRecursiveC takes as input the scalar grid ΓS, the mul-
tiresolution grid ΓM, the isovalue σ, the four vertices, p0, p1, q1, q0, of a type B
tetrahedron, and the length L of line segment (p0, p1). Line segment (p0, p1)
should be an edge of an L × L × L cubic region with q0 at the cube center and
q1 at the center of a cube facet.
Procedure MultiresRecursiveC computes the midpoint, q2, of line seg-
ment (p0, p1). Point q2 is a grid vertex. If ΓM(q2) is false, then tetrahedron
t = (p0, p1, q1, q0) is not split and MultiresRecursiveC calls Procedure Ex-
tractIsoPatch on t. If ΓM(q2) is true, then tetrahedron t is split into two
tetrahedra, (p0, q2, q1, q0) and (p2, q2, q1, q0), of type A. Procedure Multires-
RecursiveC calls Procedure MultiresRecursiveA on these two tetrahedra.
Note that line segments (p0, q2) and (p2, q2) have length L/2.
9.2.3
n1 × n2 × n3 Grids
So far we have assumed that the input grid ΓS has vertex dimensions (2k + 1) ×
(2k+1)×(2k+1) for some integer k. This condition on ΓS is highly restrictive. In
this section we show how to modify the algorithms from Sections 9.2.1 and 9.2.2
to apply to grids with any dimensions.
Let Γ be a scalar grid with vertex dimensions n1 × n2 × n3. Let |Γ| be the
union of all the grid cubes in Γ.
Partition |Γ| into cubic regions as follows.
Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3). Let c∗be
a cubic region with edge length 2k and with opposing vertices at (0, 0, 0) and
(2k, 2k, 2k).
Region c∗contains |Γ|.
If |Γ| does not equal c∗, divide c∗into
eight cubic subregions. Recursively subdivide each of the subregions until each
subregion is either contained in |Γ| or is disjoint from the interior of |Γ|. After k
partitions, each subregion has edge length one. Thus the recursive subdivision
stops after at most k steps. Let Poct be the set of cubic subregions that are
contained in |Γ|. Set Poct forms a partition of |Γ|.
Region c∗and its subdivisions form an octree containing |Γ|.
(See Sec-
tion 8.2.1 for a deﬁnition of octrees.) Set Poct is the leaves of this octree that
represent regions contained in |Γ|. We call Poct the octree partition of |Γ|.
For each cubic subregion c ∈Poct, triangulate c using six congruent tetrahe-
dra sharing a common edge. This common edge connects opposing vertices of c.
There are four possible ways to create such a triangulation of c, corresponding
to the four pairs of opposing vertices of c. If c does not equal c∗, then c was
created by subdividing a cubic region c′ into eight octants. The center of c′ is

302
9. Multiresolution Tetrahedral Meshes
a vertex q0 of c. Let dsplit(c) be the diagonal of c connecting q0 to the opposite
vertex in c. If c equals c∗, then let dsplit(c) be the diagonal from (0, 0, 0) to
(2k, 2k, 2k). (Cube c ∈Poct can only equal c∗if c∗equals |Γ|. In that case, Poct
contains only c∗.) Choose the triangulation of c whose tetrahedra share edge
dsplit(c). Label this triangulation τc.
The union of the triangulations τc form a subdivision of |Γ| into tetrahedra,
although not necessarily a triangulation of |Γ|. We show how to turn this subdi-
vision into a multiresolution triangulation of |Γ| by applying recursive bisection
from Section 9.1.2 to the tetrahedra.
Each tetrahedron t ∈
r∈Poct τ c is of type A. (See Figure 9.8.) Tetrahedron
t splits into two tetrahedra of type B and these two split into four tetrahedra
of type C. Splitting the type C tetrahedra creates type A tetrahedra. Splitting
continues until the tetrahedra vertices are a subset of the vertices of a unit grid
cube.
The subdivisions of τc form a full-resolution tree as described in Section 9.2.1.
The root of this tree contains the cubic region c. The children of the root are
the six tetrahedra in τc.
Every other internal node of the tree has exactly
two children formed by splitting its tetrahedron. Leaves of the tree represent
tetrahedra whose vertices are a subset of the vertices of the unit cube.
The collection of all full-resolution trees over all c ∈Poct form a full-resolution
forest. Each node in this forest represents a cubic region c ∈Poct or a tetrahe-
dron. Diﬀerent trees in the forest have diﬀerent heights. The height of a tree
depends upon the size of the cubic region c at its root.
As with the (2k +1)×(2k +1)×(2k +1) grid, we represent the multiresolution
triangulation of the n1 × n2 × n3 grid by an n1 × n2 × n3 grid ΓMof Boolean
values. The grid vertices represent the points qsplit(t) for all tetrahedra t at
internal nodes of the full-resolution forest. The points qsplit(t) for tetrahedra t
at leaves of the forest are not represented but they are never split into smaller
tetrahedra.
The multiresolution grid ΓMrepresents a multiresolution subdivision of |Γ| as
follows. Starting from the triangulations τc for all c ∈Poct, bisect tetrahedron
t ∈τc if qsplit(t) is true. Repeat this process on the resulting tetrahedra until
either t is either a leaf of the full-resolution forest or ΓM(qsplit(t)) is false. The
resulting tetrahedra form a multiresolution subdivision of |Γ|.
To ensure that this multiresolution subdivision is a triangulation, we need
additional conditions on the multiresolution grid. The Multiresolution Condition
in Section 9.2.1 generalizes to the following condition on full-resolution forests:
Multiresolution Conditions (Forest).
Let tetrahedron t be an internal node, and
let cubic region c be a root node in the full-resolution forest.
1. If t is a child of tetrahedron t′ in the full-resolution tree and qsplit(t) is
true, then qsplit(t′) is true.
2. Every corner v of region c is true.

9.2. Multiresolution Isosurfaces
303
Input
: ΓMis an n1 × n2 × n3 array of Boolean values.
SatisfyMultires(ΓM)
1 Poct ←octree partition of ΓM;
2 foreach cubic region c ∈Poct do
3
foreach corner v of c do
4
ΓM(v) ←true;
5
end
6 end
7 Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3);
8 for j = 1 to k do
/* Pj(ΓM) is the partition of subgrid ΓM
j
of ΓM into cubes of length
2j where ΓM
j
is the largest subgrid of ΓM containing (0, 0, 0) that
can be partitioned into cubes of length 2j.
*/
9
foreach edge e in Pj(ΓM) do
/* qcenter(e) is the midpoint of edge e
*/
10
if (ΓM(qcenter(e)) = true) then
11
foreach facet f ∈Pj(ΓM) containing e do
/* qcenter(f) is the center of facet f
*/
12
ΓM(qcenter(f)) ←true;
13
end
14
end
15
end
16
foreach facet f in Pj(ΓM) do
17
if (ΓM(qcenter(f)) = true) then
18
foreach cube c ∈Pj(ΓM) containing f do
/* qcenter(c) is the center of cube c
*/
19
ΓM(qcenter(c)) ←true;
20
end
21
end
22
end
23
foreach cube c in Pj(ΓM) do
24
if (ΓM(qcenter(c)) = true) then
25
foreach corner v of c do
26
ΓM(v) ←true;
27
end
28
end
29
end
30 end
Algorithm 9.6. SatisfyMultires for n1 × n2 × n3 grids.

304
9. Multiresolution Tetrahedral Meshes
Create a multiresolution grid satisfying the Multiresolution Condition

Read isosurface lookup table

Extract the isosurface from the multiresolution triangulation
represented by the multiresolution grid

Compute isosurface vertex coordinates using linear interpolation
Figure 9.13. Multiresolution Marching Tetrahedra (Recursive) for n1 × n2 ×
n3 grids.
We claim that a multiresolution grid that satisﬁes the Multiresolution Con-
ditions deﬁnes a multiresolution triangulation.
Proposition 9.7. If an n1 ×n2 ×n3 multiresolution grid ΓMsatisﬁes the Multires-
olution Conditions, then the set of tetrahedra deﬁned by ΓMis a triangulation of
the region covered by ΓM.
The proof is left for the next section.
The algorithm to convert an array of Boolean values into a multiresolution
grid satisfying the Multiresolution Conditions is almost exactly the same as
procedure SatisfyMultiresN×N×N in Section 9.2.1. One diﬀerence is that
the corners of each cubic region in the octree partition of |Γ| must be set to
true. The only other diﬀerence is that it may not be possible to partition an
n1 × n2 × n3 grid ΓM into cubic regions of edge length 2j for some values of
j. Instead, let ΓM
j
be the largest subgrid of ΓM containing (0, 0, 0) that can be
partitioned into cubic regions of edge length 2j. For instance, if ΓM has cube
dimensions 5 × 7 × 8, then ΓM
1
has cube dimensions 4 × 6 × 8 and ΓM
2
has cube
dimensions 4×4×8. (Cube dimensions are the number of edges along each axis.
See Section 1.7.1.) Let Pj(ΓM) be the partition of subgrid ΓM
j
into cubic regions
of edge length 2j.
Within each cubic region c of Pj(ΓM), ﬁrst check edge centers to see if facet
centers must be set to true. Next, check facet centers to see if qc must be set to
true. Finally, check qc to see if the vertices of c must be set to true. Pseudocode
for procedure SatisfyMultires is presented in Algorithm 9.6.
The algorithm for extracting an isosurface from the multiresolution triangu-
lation is called Multiresolution Marching Tetrahedra (Algorithm 9.7).

9.2. Multiresolution Isosurfaces
305
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
Coord is a 3D array of (x, y, z) coordinates.
RegionList is a list of regions in ΓS.
σ is an isovalue.
MultiresMarchingTetRecursive(ΓS, Coord, RegionList, σ)
1 CreateMultiresGrid(ΓS,RegionList,ΓM);
2 Read tetrahedron isosurface lookup table into Table;
3 T ←∅;
4 Poct ←octree partition of ΓS;
5 foreach cubic region c ∈Poct do
6
τ c ←triangulation of cubic region c into six tetrahedra sharing edge
dsplit(c);
7
L ←length of the edges of c;
8
foreach tetrahedron t ∈τ c do
9
Let (p0, p1, p2, p3) be the vertices of t where:
p0 and p3 are endpoints of dsplit(c) and
|(p0, p1)| = |(p1, p2)| = |(p2, p3)|.
10
MultiresRecursiveA(ΓS,ΓM,σ,p0, p1, p2, p3, L,T,Table);
11
end
12 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
13 E ←
(e1,e2,e3)∈T{e1, e2, e3};
14 foreach edge e ∈E with endpoints (i1, j1, k1) and (i2, j2, k2) do
15
ue ←LinearInterpolation
16
(Coord[i1, j1, k1], ΓS[i1, j1, k1], Coord[i2, j2, k2], ΓS[i2, j2, k2], σ);
17 end
/* Convert T to set of triangles
*/
18 Υ ←∅;
19 foreach triple of edges (e1, e2, e3) ∈T do
20
Υ ←Υ ∪{(ue1, ue2, ue3)};
21 end
Algorithm 9.7. Multiresolution Marching Tetrahedra (Recursive)
for n1 × n2 × n3 grids.
It is almost the same as the algorithm Multiresolution Marching Tetra-
hedra N×N×N (Algorithm 9.2) for n × n × n grids where n = 2k + 1. The only
diﬀerence is the construction and use of an octree partition on the grid.
Input to Multiresolution Marching Tetrahedra is a scalar grid, ΓS;
an array, Coord, of grid coordinates; a set, RegionList, of high-resolution regions;
and a scalar value σ. Start by converting the high-resolution regions to a mul-

306
9. Multiresolution Tetrahedral Meshes
Input
: ΓS is an n1 × n2 × n3 grid.
RegionList is a list of regions in ΓS.
Output
: ΓMis an n1 × n2 × n3 array of Boolean values satisfying the
Multiresolution Condition.
CreateMultiresGrid(ΓS, RegionList, ΓM)
1 Initialize ΓM(v) to false for all vertices v;
2 foreach region R in RegionList do
3
foreach vertex v in R do
4
ΓM(v) ←true;
5
end
6 end
7 SatisfyMultires (ΓM);
Algorithm 9.8. CreateMultiresGrid for n1 × n2 × n3 grids.
tiresolution grid ΓM (Algorithm 9.8). Set every vertex within the high-resolution
regions to true. Set all other vertices to false. Apply procedure SatisfyMul-
tires (Algorithm 9.6) to the multiresolution grid so that it satisﬁes the Mul-
tiresolution Conditions.
Read the isosurface lookup table from a preconstructed data ﬁle. To extract
the isosurface, create an octree partition Poct of ΓS. For each cubic region c
in Poct, construct the triangulation τc consisting of six tetrahedra sharing the
edge dsplit(c). Call procedure MultiresRecursiveA (Algorithm 9.4) on each
tetrahedron t ∈τc. If ΓM(qsplit(t)) is false, then MultiresRecursiveA splits
t and calls MultiresRecursiveB, which may call MultiresRecursiveC.
These procedures descend the full-resolution tree rooted at c, extracting iso-
surface patches from the multiresolution triangulation deﬁned by the multireso-
lution grid. Note Multiresolution Marching Tetrahedra and Multires-
olution Marching Tetrahedra N×N×N use exactly the same procedures,
MultiresRecursiveA, MultiresRecursiveB, and MultiresRecursiveC,
to extract isosurface patches from the multiresolution triangulation.
In the ﬁnal step, assign geometric locations to the isosurface vertices based
on the scalar values at the endpoints of these bipolar edges.
9.2.4
Isosurface Properties
By Proposition 9.5, the set of tetrahedra represented by the multiresolution grid
form a tetrahedral mesh. Algorithm Multiresolution Marching Tetrahe-
dra is equivalent to applying Marching Tetrahedra (Section 2.4) to that
tetrahedral mesh. Thus, the properties of the Multiresolution Marching

9.2. Multiresolution Isosurfaces
307
Tetrahedra isosurface are exactly the properties listed in Section 2.4.2 for the
Marching Tetrahedra isosurface.
Multiresolution Marching Tetrahedra constructs an isosurface from
a tetrahedral mesh covering a rectangular region. Thus, the condition in Sec-
tion 2.4.2 about the tetrahedral mesh covering a 3-manifold with boundary is
implicit and can be omitted.
As with Marching Tetrahedra, algorithm Multiresolution March-
ing Tetrahedra has no ambiguous conﬁgurations. However, the topology of
the constructed isosurface often depends upon the resolution used in its con-
struction.
9.2.5
Triangulation Proof
We present a proof that multiresolution grids that satisfy the Multiresolution
Conditions deﬁne triangulations (Proposition 9.7.) We start by modifying the
Bisection Rule to apply to octree partitions for n1 × n2 × n3 grids.
Bisection Rules (3D Octree Partition).
1. If tetrahedron t is split at point q and q lies in the interior of an edge of
tetrahedron t′, then tetrahedron t′ is split.
2. If q is the corner of some region in the octree partition and q lies in the
interior of an edge of tetrahedron t′, then tetrahedron t′ is split.
To prove that a sequence of splits that follows the Bisection Rule creates a
triangulation, we need the following two lemmas.
Lemma 9.8. Let Poct be an octree partition of an n1 × n2 × n3 grid Γ and let
t be a tetrahedron in the full-resolution forest of Poct. If τcong(t) is the set of
all tetrahedron congruent to t in the full-resolution forest, then τcong(t) is a
triangulation.
Note that some small regions in Poct may not contain any tetrahedra con-
gruent to t, so τ may not cover the entire grid.
Proof of Lemma 9.8: Let k be the smallest integer such that
2k + 1 ≥max(n1, n2, n3),
(9.1)
and let n equal 2k + 1. Let Γ′ be an n × n × n grid containing Γ with origin
(0, 0, 0). Let τ′
cong(t) be the set of all tetrahedron in the full-resolution tree of Γ′
that are congruent to t. By Lemma 9.9, every tetrahedron in the full-resolution
forest of Γ is in the full-resolution tree of Γ′. Thus, every tetrahedron in τcong(t)
is in τ′
cong(t). Since τ′
cong(t) is a triangulation and τcong(t) is a subset of τ ′
cong(t),
set τ′
cong(t) is also a triangulation.
□

308
9. Multiresolution Tetrahedral Meshes
Lemma 9.9. Let Γ be an n1 × n2 × n3 grid, let k be the smallest integer such
that 2k + 1 ≥max(n1, n2, n3), and let n equal 2k + 1. Let Γ′ be an n × n × n
grid containing Γ with origin (0, 0, 0). If τ is the set of all tetrahedra in the
full-resolution forest of Γ and τ′ is the set of all tetrahedra in the full-resolution
tree of Γ′, then τ is a subset of τ′.
Proof: If Γ equals Γ′, then τ is a full-resolution tree on Γ and so τ equals τ′.
Assume Γ is a subgrid of Γ′.
Let t be a tetrahedron in τ.
Let c be the cubic region containing t in
the octree partition Poct of Γ. Tetrahedron t is contained in some tetrahedron
t′ ∈τc.
Since Γ does not equal Γ′, region c is not at the root of this octree. Thus
region c has some parent, c′, in the octree on Γ′. Region c′ is split into eight
octants sharing the point qcenter(c′) at the center of c′.
Region c′ is triangulated by six tetrahedra from τ′ sharing a common edge.
After three bisection steps, these six tetrahedra become forty-eight tetrahedra.
All forty-eight of these tetrahedra have a vertex at qcenter(c′). Six of these forty-
eight tetrahedra form a triangulation of c. Diagonal dsplit(c) is the diagonal of c
containing qcenter(c′). Since the six tetrahedra in c share a vertex at qcenter(c′),
they share a common edge dsplit(c). By deﬁnition of triangulation τc, these six
tetrahedra also form the triangulation τc of c. Thus, one of these tetrahedra is t′
and tetrahedron t′ is in τ′. All tetrahedra derived t′ are also in τ′. In particular,
tetrahedron t is in τ′. Thus, τ is a subset of τ′.
□
We prove that a sequence of splits that follows the Bisection Rule creates a
triangulation.
Proposition 9.10. Let Poct be an octree partition of an n1×n2×n3 grid. For each
cubic region c ∈Poct, let τ c be the triangulation of c into six tetrahedra sharing
the cube diagonal dsplit(c). If a sequence of splits of τ = 
r∈Poct τ c follows the
Bisection Rule, then the resulting set τ′ of tetrahedra is a triangulation of the
grid.
Proof: Let t and t′ be tetrahedra in τ such that t intersects t′. If t and t′ lie in
the same cubic region c ∈Poct, then, by Proposition 9.2 in Section 9.1.2, t ∩t′
is a vertex, edge, or facet of t and of t′.
By Lemma 9.8, the set of all tetrahedra congruent to t form a triangulation.
If tetrahedron t′ is congruent to t, then t′ is part of this triangulation and t ∩t′
is a vertex, edge, or face of t and of t′.
Assume that t and t′ lie in diﬀerent regions of Poct and that tetrahedron t′
is not congruent to t. Tetrahedron t′ is either contained in some tetrahedron
congruent to t or contains some tetrahedron congruent to t. Without loss of gen-
erality, assume that tetrahedron t′ is contained in some tetrahedron congruent
to t.

9.2. Multiresolution Isosurfaces
309
Let τcong(t) be the set of all tetrahedra congruent to t in the full-resolution
forest. We ﬁrst show that t′ is contained in some tetrahedron in τcong(t). Assume
that it is not. Let c and c′ be the cubic regions in Poct containing t and t′,
respectively. Consider an octree on the region c. Let ct be the smallest cubic
region in this octree that contains t. Since t′ is not congruent to t and not
contained in any tetrahedron in τcong(t), region c′ is smaller than region ct.
Let τct be the six tetrahedra in the full-resolution forest of Poct that form a
triangulation of ct. Tetrahedron t is not necessarily one of these six tetrahedra.
It may be one of the twelve or twenty-four tetrahedra created by splitting an
element of τct one or two times. However, t either equals or is contained in one
of these six tetrahedron ˜t.
Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3). Let c∗be
a cubic region with edge length 2k and with opposing vertices at (0, 0, 0) and
(2k, 2k, 2k). Region c′ is contained in some region c′′ congruent to ct in the
octree on c∗. Since tetrahedron t intersects t′, tetrahedron ˜t contains t, and
region c′′ contains t′, tetrahedron ˜t intersects c′′.
Tetrahedron ˜t intersects c′′ at a vertex, edge, or facet of ˜t. If tetrahedron ˜t
intersects c′′ at a vertex, then t ∩t′ is a vertex of t and of t′. Otherwise, ˜t and
c′′ share some edge e. Edge e is also an edge of c and therefore an edge of t as
well.
Since c′ is smaller than c′′, region c′′ must be split into subregions in the
octree partition Poct.
At least one of these subregions has a vertex on the
interior of e. Thus some vertex of a subregion lies on the interior of an edge of
t, violating the Bisection Rule for 3D Octree Partitions. We conclude that t′ is
contained in some tetrahedron t′′ ∈τcong(t).
The rest of the proof proceeds as in Proposition 9.2. Let t′′ be the tetrahedron
in τcong(t) that contains t′. By Lemma 9.8, τcong(t) is a triangulation. Thus,
t ∩t′′ is a face of t′′. Since t ∩t′ is a subset of t ∩t′′, intersection t ∩t′ is a face
of t′.
We need to show that t ∩t′ is a face of t. Assume that it is not. Since t ∩t′′
is a face of t, tetrahedron t′ is not equal to t′′. Thus tetrahedron t′′ must be
split.
Let t0, t1, . . . , tm be a sequence of splits where
1. tetrahedron t0 equals t′′,
2. tetrahedron tm equals t′,
3. tetrahedron ti+1 is one of the two tetrahedra created by splitting ti.
Since t0 equals t′′ and tm equals t′, it follows that t′ ⊆ti ⊆t′′ for all i.
Let tk be the smallest tetrahedron in the sequence such that t ∩tk equals
t∩t′′. Since t∩t′ does not equal t∩t′′, tetrahedron tk does not equal tm. Thus
tk is split at some point q. Since t ∩tk is face of t and t ∩tk+1 is not, point q
lies on the interior of an edge of t.

310
9. Multiresolution Tetrahedral Meshes
Point q is in the interior of an edge of t but t is not split, violating the
Bisection Rule. We conclude that t ∩t′ is a face of t. Since t ∩t′ is a face of t
and of t′ for every two intersecting tetrahedra t, t′ ∈τ ′, set τ′ is a triangulation
of the grid.
□
We give the proof of Proposition 9.7. For convenience, the proposition is
restated here.
Proposition 9.7.
If an n1 × n2 × n3 multiresolution grid ΓMsatisﬁes the Mul-
tiresolution Conditions, then the set of tetrahedra deﬁned by ΓMis a triangulation
of the region covered by ΓM.
Proof: We wish to show that the splits deﬁned by the multiresolution grid satisfy
the Bisection Condition for 3D Octree Partitions.
Case I: Tetrahedron t is split at point qsplit(t) and qsplit(t) lies in the interior of
an edge of tetrahedron t′.
Let τcong(t) be the tetrahedra in the full-resolution forest that are con-
gruent to t. Since qsplit(t) lies in the interior of an edge of t′, tetrahedron
t′ is triangulated by a subset of τcong(t). Some tetrahedron t′′ in τcong(t)
contains t ∩t′ and is contained in t′. Since qsplit(t) lies in the interior of
an edge of t and t ∩t′′ is an edge or facet of t, point qsplit(t) lies in the
interior of an edge of t′. Since t′′ is congruent to t, point qsplit(t′′) equals
qsplit(t). Since t is split, qsplit(t) is true and so qsplit(t′′) = qsplit(t) is true.
Tetrahedron t′ contains t′′. By the Multiresolution Conditions, qsplit(t′) is
also true. Thus tetrahedron t′ is split, satisfying the ﬁrst condition of the
Bisection Rule.
Case II: Point q is the corner of some region c in the octree partition of ΓM and
lies in the interior of an edge of tetrahedron t′.
Let c′ be the region in the octree partition containing t′. Since q lies in
the interior of an edge of t′, region c′ is larger than region c. Consider the
octree partition of c′. Let c′′ be the smallest region in this octree partition
containing t′.
Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3). Let c∗
be a cubic region with edge length 2k and with opposing vertices at (0, 0, 0)
and (2k, 2k, 2k). Region c is contained in some region ˜c congruent to c′′ in
the octree on c∗. Since point q lies in the interior of an edge e of t′ and
point q lies in ˜c, edge e lies on the boundary of ˜c.
Since c is smaller than ˜c, region ˜c is split into eight octants in construct-
ing the octree partition of ΓM. Thus the midpoint q′ of e is a corner of
some region in the octree partition of Poct. Point q′ may not be qsplit(t′)
but it is equal to qsplit(t′′) for some descendant t′′ of t′. By the Multireso-
lution Conditions, ΓM(q′) is true. By the Multiresolution Conditions, since
ΓM(qsplit(t′′)) is true, ΓM(qsplit(t′)) is true. Therefore, t′ is split, satisfying
the second condition of the Bisection Rule.

9.2. Multiresolution Isosurfaces
311
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
RegionList is a list of regions in ΓS.
Output
: ΓMis an n1 × n2 × n3 array of Boolean values satisfying the
Multiresolution Conditions.
CreateMultiresGrid(ΓS, RegionList, ΓM)
1 Initialize ΓM(v) to false for all vertices v;
2 foreach region R in RegionList do
3
k ←R.Subsample;
4
V ←vertices (ix, iy, iz) ∈ΓS where (ix ≡iy ≡iz ≡0) mod k;
5
foreach vertex v ∈V that lies in R do
6
ΓM(v) ←true;
7
end
8 end
9 SatisfyMultires (ΓM);
Algorithm 9.9. CreateMultiresGrid2.
Since the sequence of splits deﬁned by the multiresolution grid satisfy the
Bisection Rule, the resulting set of tetrahedra form a triangulation of the grid.□
9.2.6
More on Creating Multiresolution Grids
Procedure CreateMultiresGrid (Algorithm 9.8) from Section 9.2.3 uses full-
resolution tetrahedra in the regions listed in RegionList. Instead of using the
maximum resolution for every such region, it is possible to specify diﬀerent reso-
lutions for each such region. For each region R ∈RegionList, associate a subsam-
pling rate, R.Subsample. This subsample rate should be a nonnegative power
of two. Let V be the grid vertices (ix, iy, iz) where ix, iy, and iz are congruent
to zero modulo R.Subsample. The vertices of V form a subgrid of the original
grid where each element of the subgrid contains k3 cubes from the original grid.
Every vertex of V that lies in R is set to true. Procedure SatisfyMultires
(Algorithm 9.6) is applied to the multiresolution grid so that it satisﬁes the Mul-
tiresolution Conditions. Pseudocode for procedure CreateMultiresGrid2 is
presented in Algorithm 9.9.
Regions in RegionList may overlap. By setting one of the regions to be the
entire region covered by the grid, we can specify a minimum resolution for the
entire grid.
9.2.7
Iterative Isosurface Extraction
Algorithm 9.7 makes approximately two recursive calls for each element in the
multiresolution triangulation. For low-resolution isosurfaces, this is not a prob-

312
9. Multiresolution Tetrahedral Meshes
Create a multiresolution grid satisfying the Multiresolution Condition

Read isosurface lookup table

For each tetrahedron t in the full-resolution forest,
if t is in the multiresolution triangulation,
then extract an isosurface patch from t

Compute isosurface vertex coordinates using linear interpolation
Figure 9.14. Multiresolution Marching Tetrahedra (Iterative) for n1×n2×n3
grids.
lem. However, for full- and near full-resolution isosurfaces, the numerous recur-
sive calls take signiﬁcant time. We present an iterative version of Multireso-
lution Marching Tetrahedra, which runs faster than the recursive version
when extracting high-resolution isosurfaces.
The ﬁrst two steps of the iterative algorithm are the same as the ﬁrst two steps
of the recursive algorithm. (See Figure 9.14.) The iterative algorithm creates
a multiresolution grid satisfying the Multiresolution Condition and then reads
the isosurface lookup table. The diﬀerence between the recursive and iterative
algorithm is in the third step. Instead of recursively splitting tetrahedra, the
iterative algorithm enumerates and processes all tetrahedra in the full-resolution
forest. For each tetrahedron t in the full-resolution forest, if t is in the mul-
tiresolution triangulation, the algorithm extract an isosurface patch from t. The
fourth step of the iterative algorithm, computing isosurface vertex coordinates,
is again the same as the fourth step of the recursive algorithm. We explain the
third step in more detail. We start by showing how to nonrecursively enumerate
tetrahedra in the full-resolution forest.
Let |Γ| be the region covered by grid ΓM. Let c∗be a cubic region with
edge length 2k containing |Γ| and with opposing vertices (0, 0, 0) and (2k, 2k, 2k).
Consider the octree of height k on c∗.
Every node in this octree represents
a cubic region. Each tetrahedron t in the full-resolution forest lies inside and
shares at least one edge with a cubic region in the octree.
A cubic region c divides into six type A tetrahedra sharing a diagonal of c.
There are four distinct diagonals connecting opposite vertices in a cubic region.
These four diagonals correspond to four diﬀerent subdivisions of the cubic region

9.2. Multiresolution Isosurfaces
313
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
Coord is a 3D array of (x, y, z) coordinates.
RegionList is a list of regions in ΓS.
σ is an isovalue.
MultiresMarchingTetIterative(ΓS, Coord, RegionList, σ)
1 CreateMultiresGrid(ΓS,RegionList,ΓM);
2 Read tetrahedron isosurface lookup table into Table;
3 T ←∅;
4 foreach unit cube c in ΓM do
5
foreach tetrahedron t ∈τ c
A do
6
if (ΓM(qprevsplit(t)) = true) then
7
(p0, p1, p2, p3) ←vertices of t;
8
ExtractIsoPatch(ΓS, σ, p0, p1, p2, p3,T,Table);
9
end
10
end
11 end
12 Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3);
13 for j = 1 to k do
/* Pj(ΓM) is the partition of subgrid ΓM
j
of ΓM into cubes of length 2j
where ΓM
j
is the largest subgrid of ΓM containing (0, 0, 0) that can be
partitioned into cubes of length 2j.
*/
14
foreach cubic region c in Pj(ΓM) do
15
foreach tetrahedron t ∈τ c
A ∪τ c
B ∪τ c
C do
16
if (ΓM(qprevsplit(t)) = true and ΓM(qsplit(t)) = false) then
17
(p0, p1, p2, p3) ←vertices of t;
18
ExtractIsoPatch(ΓS, σ, p0, p1, p2, p3,T,Table);
19
end
20
end
21
end
22 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
23 E ←
(e1,e2,e3)∈T{e1, e2, e3};
24 foreach edge e ∈E with endpoints (i1, j1, k1) and (i2, j2, k2) do
25
ue ←LinearInterpolation
26
(Coord[i1, j1, k1], ΓS[i1, j1, k1], Coord[i2, j2, k2], ΓS[i2, j2, k2], σ);
27 end
/* Convert T to set of triangles
*/
28 Υ ←∅;
29 foreach triple of edges (e1, e2, e3) ∈T do
30
Υ ←Υ ∪{ue1, ue2, ue3};
31 end
Algorithm 9.10. Multiresolution Marching Tetrahedra (Itera-
tive). for n1 × n2 × n3 grids

314
9. Multiresolution Tetrahedral Meshes
into six type A tetrahedra sharing the diagonal. The tetrahedra in only one of
these subdivisions is in the full-resolution forest.
Every region c other than c∗is created by splitting a region c′ into eight oc-
tants. As in Section 9.2.3, let dsplit(c) be the diagonal of c containing qcenter(c′).
If c equals c∗, let dsplit(c) be the diagonal containing (0, 0, 0). Let τc
A be the set
of six type A tetrahedra sharing edge dsplit(c). The full-resolution forest contains
τ c
A.
Each tetrahedron in τ c
A splits into two type B tetrahedra. Let τc
B be the set
of twelve type B tetrahedra formed by splitting each tetrahedron in τc
A. Let τc
C
be the set of twenty-four type C tetrahedra formed by splitting each tetrahedron
in τ c
B. The tetrahedra in the full-resolution forest are enumerated by processing
each octree region c contained in |Γ|, and generating τc
A and τ c
B and τc
C.
We enumerate the octree regions contained in |Γ| without explicitly construct-
ing the octree. Let ΓM
j
be the largest subgrid of ΓM containing (0, 0, 0) that can
be partitioned into cubic regions of edge length 2j. Let Pj(ΓM) be the partition
of ΓM
j
into cubic regions of edge length 2j. These cubic regions are the octree
regions that are contained in |Γ|.
We determine if a tetrahedron from the full-resolution forest is in the mul-
tiresolution triangulation as follows. Let ΓM be a multiresolution grid satisfying
the Multiresolution Condition. Let t be a tetrahedron in the full-resolution forest
on grid ΓM. If t is the child of a tetrahedron t′, then t is in the multiresolution
mesh if t′ is split and t is not. Equivalently, t is in the multiresolution mesh if
ΓM(qsplit(t′)) is true and ΓM(qsplit(t)) is false. If t is at a root node, then t is
in the multiresolution mesh if t is not split, i.e., ΓM(qsplit(t)) is false.
We can determine qsplit(t′) without explicitly constructing t′. Let c be the
cubic region sharing at least one edge with t. Let 2j be the edge length of c. If t
has type B, let qprevsplit(t) be the vertex of t at the center of c. If t has type C,
let qprevsplit(t) be the vertex of t at the center of some facet of c. If t has type A
and c is the child of region c′ in an octree, let qprevsplit(t) be the vertex of t at
the midpoint of an edge of c′. Equivalently, if t has type A and c is contained
in a 2j+1 × 2j+1 × 2j+1 region c′ in the partition Pj+1(G), then qprevsplit(t) is
the vertex of t at the midpoint of an edge of c′. If t has type A and c is at the
root of an octree, let qprevsplit(t) be the point the endpoint of dsplit(c) furthest
from the origin. In all cases, if t is the child of tetrahedron t′, then qprevsplit(t)
equals qsplit(t′).
The third step in the iterative algorithm is as follows. Let ΓM be the n1 ×
n2 × n3 multiresolution grid constructed in the ﬁrst step. Let k be the smallest
integer such that 2k + 1 ≥max(n1, n2, n3). For each unit cube c in ΓM and
each type A tetrahedron t sharing edge dsplit(c), if ΓM(qprevsplit(t)) is true, then
extract an isosurface patch from t. For j equals one to k, let ΓM
j
be the largest
scalar grid of ΓM containing (0, 0, 0) that can be partitioned into cubic regions
of edge length 2j. Let Pj(ΓM) be the partition of ΓM
j
into cubic regions of edge
length 2j. For each cubic region c in Pj(ΓM), construct τ c
A ∪τ c
B ∪τ c
C. For each

9.3. Notes and Comments
315
tetrahedron t in τc
A ∪τ c
B ∪τ c
C, if ΓM(qprevsplit(t)) is true and ΓM(qsplit(t)) is true,
then extract the isosurface patch from t. Pseudocode is given in Algorithm 9.10.
Multiresolution Marching Tetrahedra (Iterative) produces the ex-
act same sets of triangles and vertices as Multiresolution Marching Tetra-
hedra (Recursive). Thus, all the properties in Section 2.4.2 apply to an isosur-
face produced by Multiresolution Marching Tetrahedra (Iterative).
9.3
Notes and Comments
Initial work on multiresolution isosurfaces partitioned the domain into cubes or
rectangular regions of varying sizes. Because adjacent cubes did not necessar-
ily have the same size, the partition did not form a convex polyhedral mesh.
Isosurface patches in diﬀerent cubes did not necessarily align on their bound-
aries, creating “cracks” in the isosurface. These cracks were eliminated either
by adding polygons to ﬁll the cracks [Shu et al., 1995] or by moving isosur-
face vertices [M¨uller and Stark, 1993, Shekhar et al., 1996, He et al., 1996] to
align the patch boundaries. An alternative approach [Bloomenthal, 1988,Poston
et al., 1998,Westermann et al., 1999,Bai et al., 2006] ﬁrst constructs the isosur-
face patch boundaries, ensuring that adjacent boundaries align, and then adds
isosurface triangles within the boundaries.
Cignoni et al. [Cignoni et al., 1994] extract isosurfaces from multiresolution
tetrahedral meshes where the mesh is a Delaunay triangulation at every level of
resolution. Chiang and Lu [Chiang and Lu, 2003] give an algorithm for simpli-
fying tetrahedral meshes while ensuring that isosurface topology is preserved.
The recursive tetrahedral bisection in Section 9.1.2 and the resulting multires-
olution grid was described by Maubach in [Maubach, 1995]. Zhou et al. [Zhou
et al., 1997] were the ﬁrst to apply this subdivision to multiresolution isosurface
extraction. Gerstner and Pajarola in [Gerstner and Pajarola, 2000] present a
simple recursive algorithm for traversing the tetrahedral mesh that is given in
Section 9.2.2. Gerstner and Rumpf [Gerstner and Rumpf, 2000] give criteria for
choosing the amount of reﬁnement at a location in the isosurface. They also dis-
cuss load balancing when extracting a multiresolution isosurface using multiple
processors.
Pascucci and Bajaj [Pascucci and Bajaj, 2000] use multiresolution meshes
for fast interactive rendering of isosurfaces. Weiss and De Floriani [Weiss and
De Floriani, 2008] and [Weiss and De Floriani, 2010] use recursive tetrahedral
bisection to produce compact representations of isosurfaces and interval volumes.
Gerstner [Gerstner, 2002] shows how to quickly sort the multiresolution mesh
produced from recursive tetrahedral bisection in a view dependent ordering. This
ordering can be used to eﬃciently render transparent isosurfaces using alpha
blending.

316
9. Multiresolution Tetrahedral Meshes
Balmelli et al. [Balmelli et al., 2002] warp the regular grid to concentrate grid
cubes in regions of interest. The isosurface extracted from this warped grid has
higher resolution in regions with high concentrations of grid cubes.
Bischoﬀand Kobbelt [Bischoﬀand Kobbelt, 2002] simplify isosurface topol-
ogy by using morphological operators such as erosion and dilation. Szymczak
and Vanderhyde [Szymczak and Vanderhyde, 2003] simplify topology by starting
with a crude genus-0 approximation to the isosurface and adding tunnels. Wood
et al. [Wood et al., 2004] start with a full-resolution isosurface and ﬁll in tunnels
and handles by modifying scalar values in the underlying grid.
Surveys on mesh decimation for polygonal meshes can be found in [Cignoni
et al., 1998,Garland, 1999,Luebke, 2001,Iske et al., 2002]. An algorithm that
simultaneously constructs and decimates an isosurface is presented in [Attali
et al., 2005].

CHAPTER 10
MULTIRESOLUTION
POLYHEDRAL MESHES
In the previous chapter, we presented an algorithm for constructing an isosurface
using a multiresolution tetrahedral mesh.
This algorithm requires the entire
mesh to be broken into tetrahedra, even if most of the mesh is uniform and only
a small portion is at high resolution.
Tetrahedral meshes have two drawbacks compared with regular grids of cubes.
First, the isosurface created using tetrahedral meshes tends to be less smooth
and to contain more visual artifacts compared with the isosurface from a regular
grid. Second, a full-resolution tetrahedral mesh creates an isosurface with about
three times the number of triangles created by Marching Cubes. Unless the
multiresolution isosurface has large areas at low resolution, the multiresolution
isosurface created from a tetrahedral mesh can have more triangles than the full-
resolution isosurface created by Marching Cubes. When this happens, one
is better oﬀusing Marching Cubes instead of a multiresolution tetrahedral
mesh.
In this chapter, we present an algorithm to construct a mesh of cubes, pyra-
mids, and tetrahedra and to extract the isosurface from that mesh. The uniform
regions in the mesh are covered by cubes with pyramids and tetrahedra only
used to connect regions at diﬀerent resolution.
The Surface Nets algorithm in Chapter 3 generalizes easily to construct
multiresolution isosurfaces from a multiresolution partition of the grid into cubic
regions. The multiresolution algorithm is presented in Section 10.2. Section 10.3
gives algorithms for multiresolution isosurfaces in 4D.
317

318
10. Multiresolution Polyhedral Meshes
10.1
Multiresolution Convex Polyhedral Mesh
In this section, we show how to create multiresolution meshes that include cubic
grid elements. Pyramid and tetrahedral elements are used to connect cubes of
diﬀerent resolutions.
10.1.1
Subdivisions of Cubes, Pyramids, and Tetrahedra
Just as the multiresolution tetrahedral mesh is based on bisections of tetrahe-
dra, the multiresolution mesh of cubes, pyramids, and tetrahedra is based on
subdivisions of these polyhedra.
A cube is divided in one of two ways. A cube is sometimes divided into eight
congruent subcubes sharing a vertex at the cube center. A cube can also be
divided into six congruent square pyramids whose apices are the cube center and
whose bases are the six square cube facets. (A square pyramid is a pyramid whose
base is a square.)
A square pyramid is also divided in two ways. A square pyramid can be
divided into four square subpyramids by splitting its square base into four squares
and connecting its apex to each of the four squares. It can also be divided into
four tetrahedra by splitting its square base into four triangles and connecting its
apex to each of the four triangles.
If a cube is divided into six square pyramids and these square pyramids are
divided into tetrahedra, then the resulting tetrahedra are similar to the type
C tetrahedra in Figure 9.8 in the multiresolution tetrahedra. These tetrahedra
share one edge with the original cube. They are bisected at the midpoint of this
edge into two smaller type A tetrahedra.
Note that the angle between a square pyramid or tetrahedral edge and a
coordinate axis is zero, forty-ﬁve, or ninety degrees.
Creation of the multiresolution mesh starts by creating an octree partition as
described in Section 9.2.3. Each region in this octree partition is a cube. Each
cubic region in the octree partition either is not subdivided, is subdivided into
eight subcubes, or is subdivided into six square pyramids. Similarly any cubic
region created through subdivision is either not subdivided or subdivided into
eight subcubes or subdivided into six square pyramids.
Each square pyramid either is not subdivided, is subdivided into four square
subpyramids, or is subdivided into four type C tetrahedra. Subpyramids of a
square pyramid are never subdivided. Each type C tetrahedron either is not
subdivided or is subdivided into two type A tetrahedra. Type A tetrahedra are
never subdivided.
A convex polyhedral mesh is a set of convex polytopes such that the intersec-
tion of any two polytopes is a face of each. (See Appendix B.5.) The recursive
application of the subdivisions listed above creates a set of cubes, square pyra-

10.1. Multiresolution Convex Polyhedral Mesh
319
mids, and tetrahedra that partition the grid. To ensure that these polyhedra
form a convex polyhedral mesh, one could formulate a list of rules similar to the
Bisection Rules in Section 9.2.5. However, such a list is fairly long and compli-
cated. Instead, we deﬁne a multiresolution grid to determine when and how the
polyhedra are subdivided and show that the resulting polyhedral subdivision is
a convex polyhedral mesh.
10.1.2
Multiresolution Grids for a Convex Polyhedral Mesh
As with tetrahedral meshes, we rely upon a multiresolution grid, ΓM, to specify
the multiresolution convex polyhedral mesh. However, the multiresolution grid
for the polyhedral mesh indicates not only whether to split a mesh element but
also the split type.
For each vertex q of grid ΓM, grid element ΓM(q) has a Boolean value,
ΓM(q).b, and a split type, ΓM(q).t. We say that ΓM(q) is true or false or has
type X or Y to mean that ΓM(q).b is true or false or that ΓM(q).t equals X or Y.
For each polyhedron ψ, we deﬁne a point qsplit(ψ) that determines if and how
ψ is split into smaller polyhedra. For a cube c, point qsplit(c) is the center of c.
For a square pyramid p, point qsplit(p) is the center of the square base of p. For
a tetrahedron tC of type C, point qsplit(tC) is the midpoint of the edge that tC
shares with the cubic region containing tC. A tetrahedron tA of type A is never
split and qsplit(tA) is undeﬁned.
Point qsplit(ψ) is always the center of some cubic region or the center of some
face of a cubic region. Because these cubic regions have edge length 2j, point
qsplit(ψ) is a grid vertex whenever j is greater than zero. Point qsplit(ψ) is not
a grid vertex only if ψ is a unit cube or if ψ is contained in a unit cube. In all
such cases, ψ is never subdivided and qsplit(ψ) is irrelevant.
Let q equal qsplit(ψ) for mesh element ψ where ψ is not a unit cube and is
not contained in a unit cube. If ΓM(q).b is true, then ψ is split. If ψ is a cube,
then ψ is split into eight subcubes whenever ΓM(q).t is X and is split into six
pyramids whenever ΓM(q).t is Y. If ψ is a pyramid, then ψ is split into four
subpyramids whenever ΓM(q).t is X and is split into four tetrahedra whenever
ΓM(q).t is Y. If ψ is a tetrahedron and ΓM(q).b is true, then ΓM(q).t is always
Y and ψ is split into two tetrahedra. If ΓM(q).b is false, then ψ is not split and
ΓM(q).t is undeﬁned.
The cubic subdivisions of a cubic region form a tree. The root of the tree
represents the original cubic region. Each node in the tree represents a cubic
subregion c with edge length 2j. If j is positive, then the node has eight children,
one for each subcube of c.
If j is zero, then the node is a leaf.
The cubic
subdivisions of an octree partition form a cube forest. The root of each tree in
this forest is a cubic region in the octree partition. Each tree represents the
cubic subdivisions of its corresponding region.

320
10. Multiresolution Polyhedral Meshes
Input
: ΓMis an n1 × n2 × n3 array of Boolean values.
SatisfyMultiresPoly(ΓM)
1 Poct ←octree partition of ΓM;
2 SatisfyCondition1(ΓM, Poct);
3 Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3);
4 for j = 1 to k do
5
SatisfyCondition2(ΓM, j);
6
SatisfyCondition3(ΓM, j);
7
SatisfyCondition4(ΓM, j);
8 end
Algorithm 10.1. Procedure SatisfyMultiresPoly for multiresolution
mesh of cubes, pyramids, and tetrahedra.
For each square f and cube c, let qcenter(f) and qcenter(c) be the centers of f
and c, respectively. For each line segment e, let qcenter(e) be the midpoint of e.
Multiresolution Conditions (Convex Polyhedral Mesh).
Let c be a cubic region at
an internal node in the cube forest.
1. For every corner q of a region in the octree partition, ΓM(q).b is true and
has type X.
2. Let f be a facet of c and let e be an edge of f.
(a) If ΓM(qcenter(c)) is true and has type X, then ΓM(qcenter(f)).b is true
and has type X.
(b) If ΓM(qcenter(f)) is true and has type X, then ΓM(qcenter(e)).b is true.
3. Let f be a facet of c and let e be an edge of f.
(a) If ΓM(qcenter(e)).b is true, then ΓM(qcenter(f)).b is true.
(b) If ΓM(qcenter(f)).b is true, then ΓM(qcenter(c)).b is true.
4. If c is a child of region c′ in the cube forest, and if ΓM(qcenter(c)).b is true,
then ΓM(qcenter(c′)) is true and has type X.
We claim that a multiresolution grid that satisﬁes the Multiresolution Con-
ditions deﬁnes a multiresolution convex polyhedral mesh.
Proposition 10.1. If an n1 × n2 × n3 multiresolution grid satisﬁes the Multires-
olution Conditions, then the set of cubes, pyramids, and tetrahedra determined
by that grid form a convex polyhedral mesh.
Proof is in Section 10.1.5.

10.1. Multiresolution Convex Polyhedral Mesh
321
Input
: ΓMis an n1 × n2 × n3 array of Boolean values.
2j is the length of the cubic regions begin processed.
SatisfyCondition1(ΓM, j)
1 foreach region c in Pj(ΓM) do
2
foreach corner v of c do
3
ΓM(v).b ←true;
4
ΓM(v).t ←X;
5
end
6 end
Algorithm 10.2. SatisfyCondition1.
Input
: ΓMis an n1 × n2 × n3 array of Boolean values.
2j is the length of the cubic regions begin processed.
SatisfyCondition2(ΓM, j)
1 foreach region c in Pj(ΓM) do
2
if (ΓM(qcenter(c)).b = true and ΓM(qcenter(c)).t = X) then
3
foreach facet f of c do
4
ΓM(qcenter(f)).b ←true;
5
ΓM(qcenter(f)).t ←X;
6
end
7
end
8 end
9 foreach facet f in Pj(ΓM) do
10
if (ΓM(qcenter(f)).b = true and ΓM(qcenter(f)).t = X) then
11
foreach edge e of f do
12
ΓM(qcenter(e)).b ←true;
13
end
14
end
15 end
Algorithm 10.3. SatisfyCondition2.
As in Section 9.2.3, we wish to turn a grid of Boolean values into a mul-
tiresolution grid satisfying the Multiresolution Conditions for convex polyhedral
meshes. We present procedure SatisfyMultiresPoly for doing so. (See Algo-
rithm 10.1.)
Procedure SatisfyMultiresPoly processes cubic regions in the cube forest
of ΓM, modifying ΓM(v) for vertices v at the center of region faces to satisfy each

322
10. Multiresolution Polyhedral Meshes
Input
: ΓMis an n1 × n2 × n3 array of Boolean values.
2j is the length of the cubic regions begin processed.
SatisfyCondition3(ΓM, j)
1 foreach facet f in Pj(ΓM) do
2
foreach edge e of f do
3
if (ΓM(qcenter(e)).b = true and ΓM(qcenter(f)).b = false) then
4
ΓM(qcenter(f)).b ←true;
5
ΓM(qcenter(f)).t ←Y ;
6
end
7
end
8 end
9 foreach region c in Pj(ΓM) do
10
foreach facet f of c do
11
if (ΓM(qcenter(f)).b = true and ΓM(qcenter(c)).b = false) then
12
ΓM(qcenter(c)).b ←true;
13
ΓM(qcenter(c)).t ←Y ;
14
end
15
end
16 end
Algorithm 10.4. SatisfyCondition3.
of the Multiresolution Conditions. As in Section 9.2.2, let ΓM
j
be the largest
subgrid of ΓM containing (0, 0, 0) that can be partitioned into cubic regions of
edge length 2j. Let Pj(ΓM) be the partition of subgrid ΓM
j
into cubic regions of
edge length 2j.
For each corner v of a region in the octree partition, set ΓM(v) to true
and type X satisfying Multiresolution Condition 1 (Algorithm 10.2). For each
cubic region c in Pj(ΓM), if ΓM(qcenter(c)) is true and has type X, then set
ΓM(qcenter(f)) to true and type X for each facet f of c satisfying Multiresolution
Condition 2a (Algorithm 10.3). For each facet f in Pj(ΓM), if ΓM(qcenter(f)) is
true and has type X, then set ΓM(qcenter(e)) to true for each edge e of f satisfying
Multiresolution Condition 2b.
For each facet f in Pj(ΓM) and each edge e of f, if ΓM(qcenter(e)).b is true
and ΓM(qcenter(f)).b is false, then set ΓM(qcenter(f)) to true and type Y satis-
fying Multiresolution Condition 3a (Algorithm 10.4). For each cubic region c
in Pj(ΓM) and each facet f of c, if ΓM(qcenter(f)).b is true and ΓM(qcenter(c)).b
is false, then set ΓM(qcenter(c)) to true and type Y satisfying Multiresolution
Condition 3b.

10.1. Multiresolution Convex Polyhedral Mesh
323
Input
: ΓMis an n1 × n2 × n3 array of Boolean values.
2j is the length of the cubic regions begin processed.
SatisfyCondition4(ΓM, j)
1 foreach region c in Pj(ΓM) do
2
if ΓM(qcenter(c)).b = true then
3
if c is one of the 8 subcubes of a cubic region c′ ∈Pj+1(ΓM) then
4
ΓM(qcenter(c′)).b ←true;
5
ΓM(qcenter(c′)).t ←X;
6
end
7
end
8 end
Algorithm 10.5. SatisfyCondition4.
Input
: ΓMis an n1 × n2 × n3 array of Boolean values satisfying the
Multiresolution Conditions.
IdentifyX(ΓM)
1 Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3);
2 for j = 1 to k do
3
foreach facet f in Pj(ΓM) do
4
if ΓM(qcenter(e).b is true for every edge e of f then
5
ΓM(qcenter(f)).t ←X;
6
end
7
end
8
foreach cubic region c in Pj(ΓM) do
9
if ΓM(qcenter(f)).b is true for every facet f of c then
10
ΓM(qcenter(c)).t ←X;
11
end
12
end
13 end
Algorithm 10.6. IdentifyX.
Finally, for each cubic region c in Pj(ΓM), if c is one of the eight subcubes of a
cubic region c′ in Pj+1(ΓM) and ΓM(qcenter(c)).b is true, then set ΓM(qcenter(c′))
to true and type X satisfying Multiresolution Condition 4 (Algorithm 10.5).
The order in which these operations are applied is important. Smaller cubic
regions should be processed before larger ones. The operations to satisfy con-

324
10. Multiresolution Polyhedral Meshes
Input
: ΓS is an n1 × n2 × n3 grid.
RegionList is a list of regions in ΓS.
Output
: ΓMis an n1 × n2 × n3 array of Boolean values satisfying the
Multiresolution Condition.
CreateMultiresPolyGrid(ΓS, RegionList, ΓM)
1 Initialize ΓM(v) to false for all vertices v;
2 foreach region R in RegionList do
3
foreach vertex v in R do
4
ΓM(v) ←true;
5
end
6 end
7 SatisfyMultiresPoly (ΓM);
8 IdentifyX (ΓM);
Algorithm 10.7. CreateMultiresPolyGrid.
ditions 2a and 2b should be applied to all cubic regions of a given size before
operations to satisfy conditions 3a and 3b.
While procedure SatisfyMultiresPoly (Algorithm 10.1) solves the prob-
lem of satisfying the Multiresolution Conditions, we present an additional proce-
dure, IdentifyX, that increases the number of type X vertices in a multiresolu-
tion grid. (See Algorithm 10.6.) For each facet f of Pj(ΓM), if ΓM(qcenter(e)).b is
true for each edge e of f, set ΓM(qcenter(f)).t to type X. For each cubic region c of
Pj(ΓM), if ΓM(qcenter(f)).b is true for each facet f of c, then set ΓM(qcenter(c)).t
to type X. After these two operations are applied to all facets and all cubic re-
gions, Multiresolution Conditions 2a and 2b are still satisﬁed. Procedure Iden-
tifyX causes subdivisions of cubes into subcubes to be preferred to subdivisions
into pyramids and subdivisions of pyramids into subpyramids to be preferred to
subdivisions into tetrahedra.
A cube c divides into only six pyramids. However, if ΓM(qcenter(f)).b is true
for each facet of c, then each pyramid will be subdivided into four subpyramids
or tetrahedra. Similarly, a pyramid p with square base f divides into only four
tetrahedra, but, if ΓM(qcenter(e)).b is true for each edge of f, then each tetrahe-
dron will be split into two. Thus, procedure IdentifyX reduces the number of
elements in the polyhedral subdivision.
10.1.3
Isosurface Extraction
The algorithm for extracting an isosurface from the multiresolution mesh of
cubes, pyramids, and tetrahedra is called Multiresolution Marching CPT
(Algorithm 10.8).
CPT stands for cubes, pyramids, and tetrahedra.
The

10.1. Multiresolution Convex Polyhedral Mesh
325
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
Coord is a 3D array of (x, y, z) coordinates.
RegionList is a list of regions in ΓS.
σ is an isovalue.
MultiresMarchingCPT(ΓS, Coord, RegionList, σ)
1 CreateMultiresPolyGrid(ΓS,RegionList,ΓM);
2 Read cube lookup table into TableC;
3 Read pyramid lookup table into TableP ;
4 Read tetrahedron lookup table into TableT ;
5 T ←∅;
6 Poct ←octree partition of ΓS;
7 foreach cubic region c ∈Poct do
8
MultiresCube(ΓS,ΓM,σ,c, T, TableC, TableP , TableT );
9 end
/* Compute isosurface vertex coordinates using linear interpolation
*/
10 E ←
(e1,e2,e3)∈T{e1, e2, e3};
11 foreach edge e ∈E with endpoints (i1, j1, k1) and (i2, j2, k2) do
12
ue ←LinearInterpolation
13
(Coord[i1, j1, k1], ΓS[i1, j1, k1], Coord[i2, j2, k2], ΓS[i2, j2, k2], σ);
14 end
/* Convert T to set of triangles
*/
15 Υ ←∅;
16 foreach triple of edges (e1, e2, e3) ∈T do
17
Υ ←Υ ∪{ue1, ue2, ue3};
18 end
Algorithm 10.8. Multiresolution Marching CPT.
algorithm is similar to Multiresolution Marching Tetrahedra (Algo-
rithm 9.7).
Input to Multiresolution Marching CPT is a scalar grid, ΓS; an array,
Coord, of grid coordinates; a set, RegionList, of high-resolution regions; and a
scalar value σ. Start by converting the high-resolution regions to a multireso-
lution grid, ΓM (Algorithm 10.7). Set every vertex within the high-resolution
regions to true. Set all other vertices to false. Apply procedure SatisfyMul-
tiresPoly (Algorithm 10.1) to the multiresolution grid so that it satisﬁes the
Multiresolution Conditions for multiresolution meshes of cubes, pyramids, and
tetrahedra. Apply procedure IdentifyX (Algorithm 10.6) to reduce the number
of polyhedral elements in the multiresolution mesh.
Multiresolution Marching CPT requires three isosurface lookup tables:
one for cubes, one for pyramids, and one for tetrahedra. Read the three isosurface
lookup tables from preconstructed data ﬁles.

326
10. Multiresolution Polyhedral Meshes
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
ΓMis an n1 × n2 × n3 array of Boolean values
satisfying the Multiresolution Condition.
σ is an isovalue.
c is a cubic region whose edges lengths are a power of 2.
T is a set of edge triples representing isosurface triangles.
TblC is the isosurface lookup table for cubes.
TblP is the isosurface lookup table for pyramids.
TblT is the isosurface lookup table for tetrahedra.
MultiresCube(ΓS, ΓM, σ, c, T, TblC, TblP , TblT )
1 L ←length of the edges of c;
2 if (L = 1 or ΓM(qcenter(c)).b = false) then
3
ExtractIsoFromCube(ΓS, σ, c, T, TblC);
4 else
5
if ΓM(qcenter(c)).t = X) then
6
foreach vertex v of cubic region c do
7
c′ ←cubic region with opposite vertices v and qcenter(c);
8
MultiresCube(ΓS, ΓM, σ, c′, T, TblC, TblP , TblT ) ;
9
end
10
else
/* ΓM(qcenter(c)).t = Y
*/
11
foreach facet f of cubic region c do
12
p ←pyramid with base f and apex qcenter(c);
13
MultiresPyramid(ΓS, ΓM, σ, p, T, TblP , TblT );
14
end
15
end
16 end
Algorithm 10.9. Multires Cube.
To extract the isosurface, create an octree partition Poct of ΓS. For each
cubic region c in Poct, call procedure Multires Cube (Algorithm 10.9).
Input to procedure Multires Cube is the scalar grid, ΓS; the multiresolu-
tion grid ΓM; the isovalue σ; a cubic region c; and the three isosurface lookup
tables for cubes, pyramids, and tetrahedra. If c is a 1 × 1 × 1 unit cube or
ΓM(qcenter(c)).b is false, then call procedure ExtractIsoFromCube (Algo-
rithm 10.12) to extract an isosurface patch from c. Otherwise, divide c into
subcubes or pyramids, depending on the value of ΓM(qcenter(c)).t.
If ΓM(qcenter(c)).t equals X, then divide c into eight subcubes and recur-
sively call MultiresCube (Algorithm 10.9) on each subcube. If ΓM(qcenter(c)).t
equals Y , then divide c into six pyramids with apex qcenter(c) and call procedure
MultiresPyramid (Algorithm 10.10) on each pyramid.

10.1. Multiresolution Convex Polyhedral Mesh
327
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
ΓMis an n1 × n2 × n3 array of Boolean values
satisfying the Multiresolution Condition.
σ is an isovalue.
p is a pyramid.
T is a set of edge triples representing isosurface triangles.
TblP is the isosurface lookup table for pyramids.
TblT is the isosurface lookup table for tetrahedra.
MultiresPyramid(ΓS, ΓM, σ, p, T, TblP , TblT )
1 f ←square base of pyramid p;
2 q ←apex of pyramid p;
3 if (ΓM(qcenter(f)).b = false) then
4
ExtractIsoFromPyramid(ΓS, σ, p,T,TblP );
5 else
6
if (ΓM(qcenter(f).t = X) then
7
foreach vertex v of square f do
8
f ′ ←square with opposite vertices v and qcenter(f);
9
p′ ←pyramid with apex q and base f ′;
10
ExtractIsoFromPyramid(ΓS, σ, p′,T,TblP );
11
end
12
else
/* (ΓM(qcenter(f).t = Y )
*/
13
foreach edge e of square f do
14
(v1, v2) ←endpoints of edge e;
/* Construct isosurface in tetrahedron (v1, v2, qcenter(f), q)
*/
15
MultiresTet(ΓS, ΓM, σ, v1, v2, qcenter(f), q, T, TblT );
16
end
17
end
18 end
Algorithm 10.10. Multires Pyramid.
Input to procedure MultiresPyramid is the scalar grid ΓS; the multireso-
lution grid ΓM; the isovalue σ; a pyramid p; and the isosurface lookup tables for
pyramids and tetrahedra. Let q be the apex and f the square base of pyramid p.
If ΓM(qcenter(f)).b is false, then call procedure ExtractIsoFromPyramid (Al-
gorithm 10.13) to extract an isosurface patch from pyramid p. Otherwise, divide
p into subpyramids or tetrahedra, depending on the value of ΓM(qcenter(p)).t.
If ΓM(qcenter(p)).t equals X, then divide f ′ into four subsquares and divide p
into four subpyramids whose bases are the four subsquares of f. Call procedure
ExtractIsoFromPyramid to extract an isosurface patch from each subpyra-

328
10. Multiresolution Polyhedral Meshes
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
ΓMis an n1 × n2 × n3 array of Boolean values
satisfying the Multiresolution Condition.
σ is an isovalue.
v1, v2, v3, v4 are the tetrahedron vertices.
v1 and v2 are also vertices of the cubic region containing
the tetrahedron.
T is a set of edge triples representing isosurface triangles.
TblT is the isosurface lookup table for tetrahedra.
MultiresTet(ΓS, ΓM, σ, v1, v2, v3, v4, T, TblT )
1 q ←midpoint of edge (v1, v2);
2 if (ΓM(q).b = false) then
3
ExtractIsoFromTet(ΓS, σ, v1, v2, v3, v4);
4 else
5
ExtractIsoFromTet(ΓS, σ, v1, q, v3, v4);
6
ExtractIsoFromTet(ΓS, σ, q, v2, v3, v4);
7 end
Algorithm 10.11. Multires Tet.
mid. If ΓM(qcenter(p)).t equals Y , then divide p into four tetrahedra, one for
each edge of square f. The four vertices of a tetrahedra are the endpoints of
an edge of f, the point qcenter(f) at the center of f, and the apex q of p. Call
Procedure MultiresTet (Algorithm 10.11) on each tetrahedron.
Input to procedure MultiresTet is the scalar grid ΓS; the multiresolution
grid ΓM; the isovalue σ; the four vertices, v1, v2, v3 and v4 of a tetrahedron t; and
the isosurface lookup table for tetrahedra. Vertices v1 and v2 are also vertices
of the cubic region containing the tetrahedron. Let q be the midpoint of line
segment (v1, v2). If ΓM(q).b is false, then call procedure ExtractIsoFromTet
(Algorithm 10.14) to extract an isosurface patch from the tetrahedron. If ΓM(q).b
is false, then split t into two congruent tetrahedra, t′ and t′′, at point q and call
ExtractIsoFromTet on t′ and t′′.
The ﬁnal step of Multiresolution Marching CPT is assigning geometric
locations to the isosurface vertices.
10.1.4
Isosurface Properties
By Proposition 10.1, the set of cubes, pyramids, and tetrahedra represented by
the multiresolution grid form a convex polyhedral mesh. Algorithm Multires-
olution Marching CPT is equivalent to applying Marching Polyhedra

10.1. Multiresolution Convex Polyhedral Mesh
329
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
σ is an isovalue.
c is a cubic region.
T is a set of edge triples representing isosurface triangles.
TblC is the isosurface lookup table for cubic regions.
ExtractIsoFromCube(ΓS, σ, c, T, TblT )
1 (v1, v2, . . . , v8) ←vertices of c in lexicographic order;
/* Assign “+” or “−” signs to each vertex
*/
2 for i = 1 to 8 do
3
if ΓS(qi) < σ then Sign[vi] ←“−”;
4
else Sign[qi] ←“+”;
/* ΓS(vi) ≥σ */
5 end
6 κ ←(Sign[v1], Sign[v2], . . . , Sign[v8]);
7 foreach edge triple (e1, e2, e3) ∈TableC[κ] do
8
for j = 1 to 3 do
9
e′
i ←edge of c corresponding to ei;
10
end
11
Insert edge triple (e′
1, e′
2, e′
3) into T;
12 end
Algorithm 10.12. ExtractIsoFromCube.
(Section 5.4) to that polyhedral mesh. Thus, the properties of the Multires-
olution Marching CPT isosurface are exactly the properties listed in Sec-
tion 5.4.1 for the Marching Polyhedra isosurface.
Multiresolution Marching CPT constructs an isosurface from a tetra-
hedral mesh covering a rectangular region. Thus, the condition in Section 5.4.1
about the tetrahedral mesh covering a 3-manifold with boundary is implicit and
can be omitted. The condition about the mesh elements being aﬃne transfor-
mations of cubes, tetrahedra, and pyramids is also automatically fulﬁlled.
10.1.5
Triangulation Proof
In this section, we prove Proposition 10.1. To prove this proposition, we must
show that the intersection of every two polyhedra of the polyhedral subdivision
is either the empty set or a vertex, edge, or facet of each polyhedron.
(See
Appendix B.5.)
Lemma 10.2. Let ΓM be an n1 × n2 × n3 multiresolution grid satisfying the Mul-
tiresolution Conditions. If q is a vertex of the polyhedral subdivision deﬁned by
ΓM, then ΓM(q).b is true.

330
10. Multiresolution Polyhedral Meshes
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
σ is an isovalue.
p is a pyramid.
T is a set of edge triples representing isosurface triangles.
TblP is the isosurface lookup table for pyramids.
ExtractIsoFromPyramid(ΓS, σ, p, T, TblT )
1 q0 ←apex of pyramid p;
2 f ←square base of pyramid p;
3 q1, q2, q3, q4 ←vertices of f;
/* Assign “+” or “−” signs to each vertex
*/
4 for i = 0 to 4 do
5
if ΓS(qi) < σ then Sign[qi] ←“−”;
6
else Sign[qi] ←“+”;
/* ΓS(qi) ≥σ */
7 end
8 κ ←(Sign[q0], Sign[q1], Sign[q2], Sign[q3], Sign[q4]);
9 foreach edge triple (e1, e2, e3) ∈TblP [κ] do
10
for j = 1 to 3 do
11
e′
i ←edge of pyramid p corresponding to ei;
12
end
13
Insert edge triple (e′
1, e′
2, e′
3) into T;
14 end
Algorithm 10.13. ExtractIsoFromPyramid.
Proof: If q is an initial vertex of the octree subdivision of ΓM, then ΓM(q).b is
true by Multiresolution Condition 4.
If q was created by dividing a cubic region ψ into six pyramids or a pyramid
ψ into four tetrahedra or a tetrahedron ψ into two tetrahedra, then q equals
qsplit(ψ). Since ψ is subdivided, ΓM(qsplit(ψ)) = ΓM(q) must be true.
Assume q was created by dividing a cubic region c into eight subcubes. Since
c is divided into subcubes, ΓM(qcenter(c)) is true and of type X. By Multiresolu-
tion Condition 2a, ΓM(qcenter(f)) is true and has type X for every facet f of ψ.
By Multiresolution Condition 2b, ΓM(qcenter(e)).b is true for every edge e of c.
Thus ΓM(q) is true for every vertex q created by dividing a cubic region c into
eight subcubes.
Assume q was created by dividing a pyramid p into four subpyramids. Let
f be the square face of c. Point qsplit(p) equals qcenter(f). Since p is divided
into subpyramids, ΓM(qcenter(f)) is true and of type X. By Multiresolution Con-
dition 2b, ΓM(qcenter(e)).b is true for every edge e of c. Thus ΓM(q) is true for
every vertex q created by dividing a pyramid p into four subpyramids.
□

10.1. Multiresolution Convex Polyhedral Mesh
331
Input
: ΓS is an n1 × n2 × n3 array of scalar values.
σ is an isovalue.
v1, v2, v3, v4 are the tetrahedron vertices.
T is a set of edge triples representing isosurface triangles.
TblT is the isosurface lookup table for tetrahedra.
ExtractIsoFromTet(ΓS, σ, v1, v2, v3, v4, T, TblT )
/* Assign “+” or “−” signs to each vertex
*/
1 for i = 1 to 4 do
2
if ΓS(vi) < σ then Sign[vi] ←“−”;
3
else Sign[vi] ←“+”;
/* ΓS(vi) ≥σ */
4 end
5 κ ←(Sign[v1], Sign[v2], Sign[v3], Sign[v4]);
6 foreach edge triple (e1, e2, e3) ∈TblT [κ] do
7
for j = 1 to 3 do
8
e′
i ←edge of tetrahedron t corresponding to ei;
9
end
10
Insert edge triple (e′
1, e′
2, e′
3) into T;
11 end
Algorithm 10.14. ExtractIsoFromTet.
Lemma 10.3. Let ΓM be an n1 × n2 × n3 multiresolution grid satisfying the Mul-
tiresolution Conditions. Let F be the set of all cubic regions in the cube forest
on ΓM and all edges and facets of those cubic regions. If q is a vertex of the
polyhedral subdivision deﬁned by ΓM and q lies in the interior of g ∈F, then
ΓM(qcenter(g)).b is true.
Proof: By Lemma 10.2, ΓM(q).b is true. Point q equals qcenter(g′) for some g′ ∈
F. If g equals g′, then the lemma is proven.
Assume g does not equal g′. Let c and c′ be the smallest cubic regions in
F that contain g and g′, respectively. If c′ equals c, then g′ is an edge or facet
of g. By Multiresolution Conditions 3a and 3b, ΓM(qcenter(g)).b is true, proving
the lemma.
Assume c′ does not equal c. Since q equals qcenter(g′) and lies on the interior
of g, region c′ must be a proper subset of c. Since c′ is a subset of c, region c′
is a descendant of region c in the cube forest. By Multiresolution Condition 4,
ΓM(qcenter(c)) is true and has type X. By Multiresolution Conditions 2a and 2b,
ΓM(qcenter(g)).b is true.
□
For each pyramid p created by subdividing a cubic region c into six pyramids,
let C(p) equal c. For each cubic region c, let C(c) equal c. For every other
polyhedron ψ created by subdivisions of a pyramid p, let C(ψ) equal C(p).

332
10. Multiresolution Polyhedral Meshes
Polyhedron ψ is created by subdivisions of cubic region C(ψ). Note that if ψ
is the subpyramid of a pyramid or a type A tetrahedron, then C(ψ) is not the
smallest cubic region containing ψ. Rather, if ψ is the subpyramid of a pyramid
or a type A tetrahedron, then the smallest cubic region containing ψ is one of
the eight octants of C(ψ).
Lemma 10.4. Let ΓM be an n1 × n2 × n3 multiresolution grid satisfying the Mul-
tiresolution Conditions. If v is a vertex and ψ is a polyhedron in the polyhedral
subdivision deﬁned by ΓM, then v does not lie in the interior of any edge or facet
of ψ.
Proof: Assume that v was in the interior of an edge or facet g of ψ. We consider
three cases, based on ψ.
Case I: Polyhedron ψ is a cubic region c.
By Lemma 10.3, ΓM(qcenter(g)).b is true.
By Multiresolution Condi-
tions 3a and 3b, ΓM(qcenter(c)).b is true and c is divided into smaller poly-
hedra, a contradiction.
Case II: Polyhedron ψ is a pyramid p.
Since pyramid p is contained in C(p), region C(p) is divided into six
pyramids. Because any further subdivisions of these pyramids only adds
vertices on the boundary of C(p), g must either be the square base f of p
or an edge of that base.
If p is one of the six pyramids in the subdivision of C(p), then g is
an edge or facet of C(p).
By Lemma 10.3, ΓM(qcenter(g)).b is true. By
Multiresolution Condition 1a, ΓM(qcenter(f)).b is true and p is divided into
smaller polyhedra, a contradiction.
If p is a subpyramid of a pyramid, then g is an edge or facet of some cubic
region c′ properly contained in C(p). By Lemma 10.3, ΓM(qcenter(g)).b is
true. By Multiresolution Conditions 3a and 3b, ΓM(qcenter(c′)).b is true.
By Multiresolution Condition 2, ΓM(qcenter(C(p))) is true and has type X.
Thus, C(p) is divided into eight subcubes, a contradiction.
Case III: Polyhedron ψ is a tetrahedron t.
Since tetrahedron t is contained in C(t), region C(t) is divided into six
pyramids. Since any further subdivisions of these six pyramids only adds
vertices on the boundary of C(t), v must lie on the boundary of C(t).
If t is a type A tetrahedron and v equals qsplit(t), then t is split smaller
tetrahedra, a contradiction. If t is not a type A tetrahedron or v does not
equal qsplit(t), then v is not at the center of any edge or facet of C(t). Let
c′ be a subcube of C(t) containing v. Since v is not at the center of any
edge or facet of C(t), vertex v must lie in the interior of an edge or facet g′
of c′. By Lemma 10.3, ΓM(qcenter(g)).b is true. By Multiresolution Condi-
tions 3a and 3b, ΓM(qcenter(c′)).b is true. By Multiresolution Condition 4,
ΓM(qcenter(C(t))) is true and has type X. Thus, C(t) is divided into eight
subcubes, a contradiction.
□

10.1. Multiresolution Convex Polyhedral Mesh
333
Corollary 10.5. Let ΓM be an n1 × n2 × n3 multiresolution grid satisfying the
Multiresolution Conditions. If ψ and ψ′ are distinct polyhedra in the polyhedron
subdivision deﬁned by ΓM, and C(ψ) equals C(ψ′), then ψ ∩ψ′ is a face of ψ
and of ψ′.
Proof: In any subdivision of C(ψ) = C(ψ′) into pyramids and tetrahedra, either
the intersection of two polyhedra is a face of both or the vertex of one polyhedron
lies in the interior of an edge or facet of the other. By Lemma 10.4, no vertex
of ψ lies on the interior of an edge or facet of ψ′ and no vertex of ψ′ lies on the
interior of an edge or facet of ψ. Thus, the intersection of ψ and ψ′ is a face of
ψ and of ψ′.
□
Lemma 10.6. Let ΓM be an n1 × n2 × n3 multiresolution grid satisfying the Mul-
tiresolution Conditions.
Let ψ be a polyhedron in the polyhedron subdivision
deﬁned by ΓM. If v is in the interior of a facet of C(ψ) and ΓM(v) is true and
has type X, then ψ is a subpyramid of a pyramid.
Proof: Let f be the facet of c = C(ψ) containing v.
We claim that v is the
center of f. If not, then v lies in the interior of an edge or facet of one of the
eight congruent subcubes of c. Let c′ be one of the subcubes containing v. By
Multiresolution Conditions 3a and 3b, ΓM(qcenter(c′)).b is true. By Multiresolu-
tion Condition 4, ΓM(qcenter(c)) is true and has type X. Thus, c is divided into
eight subcubes and ψ cannot be a polyhedron in the polyhedron subdivision, a
contradiction. We conclude that v must be at the center of f and ΓM(qcenter(f))
is true and has type X.
Since ΓM(qcenter(f)).b is true, ΓM(qcenter(c)).b is also true (Multiresolution
Condition 3b). If ΓM(qcenter(c)) had type X, then c would be divided into eight
subcubes and again ψ would not be a polyhedron in the polyhedron subdivision.
Thus, ΓM(qcenter(c)) is true and has type Y.
Cubic region c is divided into six pyramids. One of these six pyramids con-
tains f as its base. Let p be that pyramid. Since ΓM(qcenter(f)).b is true, p is
divided into four subpyramids sharing the vertex v. No other polyhedra in c
contain v. Thus ψ must be a subpyramid of a pyramid.
□
For convenience, Proposition 10.1 is restated here.
Proposition 10.1.
If an n1 × n2 × n3 multiresolution grid satisﬁes the Multires-
olution Conditions, then the set of cubes, pyramids, and tetrahedra determined
by that grid form a convex polyhedral mesh.
Proof: Let ψ and ψ′ be polyhedra in the subdivision. Assume ψ ∩ψ′ was not a
facet of ψ. By Lemma 10.4, no vertex of ψ′ lies in the interior of an edge or facet
of ψ.
If ψ was a tetrahedron, then some vertex of ψ′ would be in the interior of an
edge or facet of ψ, a contradiction. The same holds if ψ′ were a cube or pyramid.
The remaining cases are ψ is a cube or pyramid and ψ′ is a tetrahedron t.

334
10. Multiresolution Polyhedral Meshes
Assume ψ′ is a tetrahedron t. Some vertex v of t lies at the center of a facet
f of C(t). By Corollary 10.5, C(ψ) does not equal C(t). Since v does not in
the interior of an edge or facet of ψ and no vertex of ψ lies in the interior of
an edge or facet of t (Lemma 10.4), v must be a vertex of ψ. To conclude our
proof, we will show that ΓM(v) is true and has type X. By Lemma 10.6, ψ′ is a
subpyramid of a pyramid, contradicting the assumption that ψ′ is a tetrahedron.
We consider three cases, one where ψ is a cube, one where ψ is one of the
six pyramids in the subdivision of C(ψ), and one where ψ is a subpyramid of a
pyramid.
Case I: Polyhedron ψ is a cube c and ψ′ is a tetrahedron t.
Some vertex v of c lies in the interior of f. If c is a region in the octree
partition, then, by Multiresolution Condition 1, ΓM(v) is true and has type
X. If c is not a region in the octree partition, then c is created by the division
of some cubic region c′ into cubes. Square f is a facet of c′ and vertex v
is the center of f. By Multiresolution Conditions 2a and 4, ΓM(v) is again
true and has type X. By Lemma 10.6, ψ′ is a subpyramid of a pyramid and
cannot be a tetrahedron.
Case IIa: Polyhedron ψ is a pyramid p in the division of C(p) into six pyramids
and ψ′ is a tetrahedron t.
If C(p) is a region in the octree partition, then, by Multiresolution Con-
dition 1, ΓM(v) is true and has type X. If C(p) is not a region in the octree
partition, then C(p) is created by the division of some cubic region c′ into
cubes. Square f is a facet of c′ and vertex v is the center of f. By Multireso-
lution Conditions 2a and 4, ΓM(v) is true and has type X. By Lemma 10.6,
ψ′ is a subpyramid of a pyramid and cannot be a tetrahedron.
Case IIb: Polyhedron ψ is the subpyramid p of a pyramid p′ and ψ′ is a tetra-
hedron t.
Square f is the base of p′ and vertex v is the center of f. Since p′ is split
into subpyramids, ΓM(v) is true and has type X. By Lemma 10.6, ψ′ is a
subpyramid of a pyramid and cannot be a tetrahedron.
□
10.2
Multiresolution Surface Nets
The dual contouring algorithm Surface Nets (Section 3.2) can be easily mod-
iﬁed to produce multiresolution isosurfaces. We call this algorithm Multires-
olution Surface Nets.
10.2.1
Deﬁnitions
Vertex, edge, and face properties. Many of the deﬁnitions of vertex, edge, and
face properties are the same as in Section 3.1. For review, we summarize them
here.

10.2. Multiresolution Surface Nets
335
A grid vertex is positive if its scalar value is greater than or equal to σ and
negative if its scalar value is less than σ. A positive vertex is strictly positive if its
scalar value does not equal the isovalue.
A grid face (vertex, edge, facet, or cube) is positive if all its vertices are
positive and and negative if all its vertices are negative. A positive grid face is
strictly positive if all its vertices are strictly positive.
A grid edge is bipolar if one endpoint is positive and one endpoint is negative.
A grid square or cube or any face of a square or cube is active if it has at least
one negative and one positive vertex.
The centroid of a set of points P = {p1, p2, . . . , pk} is
p1 + p2 + . . . pk
k
.
Vertices and edges of cubic regions. A convex polyhedral mesh has the property
that the intersection of every two mesh elements c and c′ is a face of c and a face
of c′. A partition of the regular grid into cubic regions of diﬀerent sizes does not
have this property and does not form a convex polyhedral mesh. Nevertheless, a
partition of a set of cubic regions of diﬀerent sizes may have the following weaker
property.
Deﬁnition 10.7. A set of cubic regions is aligned if the intersection of every two
cubic regions c and c′ is a face of either c or a face of c′.
A set of cubic regions that form a convex polyhedral mesh is aligned but the
converse may not be true. If a set of cubic regions form a convex polyhedral
mesh, then the intersection of every two regions c and c′ is a face of c and a face
of c′.
In a set C of cubic regions, there are some edges that are not split into smaller
edges by any other vertices or edges of C. We call such edges primary edges.
Deﬁnition 10.8. An edge e in a set of cubic regions is a primary edge if the in-
tersection of e and every cubic region is the empty set or an endpoint of e or e
itself.
If e is an edge in an aligned set of cubic regions, then the set of primary edges
contained in e cover e and partition e.
We characterize the vertices of a set of cubic regions as follows.
Deﬁnition 10.9. Let V be the set of vertices of a set C of cubic regions.
1. A vertex v ∈V is hanging if it lies in the interior of some edge or facet of
some c ∈C.
2. A vertex v ∈V is conforming if it is not hanging.

336
10. Multiresolution Polyhedral Meshes
Interior and boundary faces and regions. In Section 3.2, we identiﬁed interior
edges of a regular grid as edges that were contained in four grid cubes. This
deﬁnition is not appropriate for a set of cubic regions of diﬀerent sizes. Instead,
we give a topological deﬁnition.
If C is a set of cubic regions, then |C| is the union of all the cubic regions
in C.
Deﬁnition 10.10. Let C be a set of cubic regions.
• An edge e of C is an interior edge if the interior of e is contained in the
interior of |C|.
• An edge of C is a boundary edge if the interior of e is not contained in the
interior of |C|.
• A facet f of C is an interior facet if the interior of f is contained in the
interior of |C|.
• A facet of C is a boundary facet if the interior of f is not contained in the
interior of |C|.
Note that a primary edge may be contained in only three cubic regions and
still be an interior edge.
The deﬁnition of interior and boundary cubes is based on interior and bound-
ary edges and facets.
Deﬁnition 10.11. Let C be a set of cubic regions.
• A cubic region c of C is an interior region if every edge and facet of c is an
interior edge or facet.
• A cubic region c of C is a boundary region if some edge or facet of c is a
boundary edge or facet.
Let C be a a set of cubic regions. We use the notation Cinner to denote the
set of inner cubic regions of C.
10.2.2
Algorithm
Input to Multiresolution Surface Nets is an isovalue, an aligned set C
of cubic regions partitioning a regular grid, and a scalar value assigned to each
vertex of C. Add an isosurface vertex wc to each grid cube c with at least one
positive and at least one negative vertex. A primary interior edge e is contained
in three or four cubes. For each primary interior edge e, if e is bipolar and
contained in three cubes, c1, c2, and c3, add an isosurface triangle with vertices
wc1, wc2, and wc3. If e is bipolar and contained in four cubes, c1, c2, c3 and

10.2. Multiresolution Surface Nets
337
For each mixed grid cube c,
create new isosurface vertex wc

For each bipolar, primary edge contained in three cubes, c1, c2, c3,
add an isosurface triangle with vertices wc1, wc2, and wc3

For each bipolar, primary edge contained in four cubes, c1, c2, c3, c4,
add an isosurface quadrilateral with vertices wc1, wc2, wc3, and wc4

Compute isosurface vertex coordinates
Figure 10.1. Multiresolution Surface Nets (3D).
c4, add an isosurface quadrilateral with vertices wc1, wc2, wc3, and wc4, which
is the dual of the four cubes. (See Figure 10.1.)
To position the isosurface vertex within each grid cube, use linear interpola-
tion (Section 1.7.2) to approximate the intersection of the isosurface and all the
bipolar edges. Take the centroid of all the approximation points as the location
of the isosurface vertex.
More speciﬁcally, let σ be the isovalue and sv be the scalar value at a grid
vertex v. For each bipolar edge e = [u, v], let pe be the point αu+(1−α)v where
α = (sv −σ)/(sv −su). Note that since u and v have diﬀerent sign, scalar su
does not equal sv and the denominator (sv −su) is never zero. If p1, . . . , pk are
the interpolation points in the grid cube c, then locate isosurface vertex wc at
(p1 + · · · + pk)/k, the centroid of p1, . . . , pk.
Multiresolution Surface Nets creates a mesh of tetrahedra and quadri-
laterals but the vertices of each quadrilateral do not necessarily lie in a plane.
To create a piecewise linear surface, triangulate each quadrilateral, subdividing
it into triangles.
10.2.3
Isosurface Properties
Multiresolution Surface Nets builds the isosurface from an aligned, mul-
tiresolution set of cubic regions. Because the cubic regions do not form a convex
polyhedral mesh, Multiresolution Surface Nets isosurfaces do not have
many of the properties of Surface Nets isosurfaces.

338
10. Multiresolution Polyhedral Meshes
0
0
0
0
0
0
0
0
100
100
100
2
2
w0
w1
w2
w3
Figure 10.2. Example of an isocontour with isovalue 1 that intersects two negative
primary edges (blue) and does not intersect a bipolar primary edge (green). Isocontour
vertices w0, w1, w2, and w3 are at the centroid of the interpolated intersection points
(red) of the isocontour and the primary square edges.
As shown in a 2D illustration in Figure 10.2, the Multiresolution Sur-
face Nets isosurface may not intersect a bipolar primary edge. The isosurface
may intersect a primary, negative edge or a primary, strictly positive edge. How-
ever, the isosurface intersects all bipolar, primary edges whose endpoints are
both conforming. The isosurface does not intersect any primary, negative edges
or primary, strictly positive edges whose endpoints are both conforming.
Multiresolution Surface Nets returns a ﬁnite set, Υ, of triangles. The
isosurface is the union of these triangles. The vertices of the isosurface are the
triangle vertices.
The following properties apply to all isosurfaces produced by the Surface
Nets algorithm.
Property 1.
The isosurface is piecewise linear.
Property 2.
Set Υ contains at most 2m triangles where m is the number of
bipolar primary edges.
Property 3.
The isosurface does not contain any conforming vertices whose
scalar values do not equal the isovalue.
Property 4.
The isosurface intersects at exactly one point every interior, bipolar,
primary edge whose positive endpoint is strictly positive and whose endpoints are
both conforming.
Property 5.
The isosurface does not intersect any primary, negative edges or
any primary, strictly positive edges whose endpoints are both conforming.
Property 6.
The isosurface strictly separates the strictly positive conforming
vertices of Cinner from the negative conforming vertices of Cinner.

10.3. Multiresolution in 4D
339
The following property applies to the Multiresolution Surface Nets
isosurfaces whose isovalues do not equal the scalar value of any vertex.
Property 7.
Set Υ does not contain any zero-area triangles or duplicate triangles.
The Multiresolution Surface Nets isosurface is typically not a mani-
fold, even if the isovalue does not equal the scalar value of any vertex.
Proofs of all the Multiresolution Surface Nets properties are similar
to proofs for Surface Nets (Section 3.2.5, 3.2.6, and 3.2.7) and are omitted.
Algorithm Multiresolution Surface Nets positions isosurface vertices
at the centroids of the intersections of the isosurface and primary grid edges.
There are numerous possible variations on this step of the algorithm.
10.3
Multiresolution in 4D
Sections 10.3.1 and 10.3.2 contain an extension of Multiresolution March-
ing Tetrahedra to four dimensions. Sections 10.3.3 and 10.3.4 contain the
four-dimensional extension of Multiresolution Marching CPT.
In Section 6.7, we extended Algorithm Surface Nets to four dimensions.
For each bipolar, 4D edge e, we generated an isosurface hexahedron. This hex-
ahedron is dual to the eight grid hypercubes containing e. In a multiresolution
grid of hypercubes, a “primary” edge can be contained in four, ﬁve, six, seven, or
eight hypercubes. The dual of these hypercubes may not be realizable as a poly-
tope. Because of this diﬃculty, we could not ﬁnd a satisfactory generalization of
Multiresolution Surface Nets to four dimensions.
10.3.1
Multiresolution Triangulations
Let ΓS be a scalar grid with vertex dimensions n1 × n2 × n3 × n4. Let |Γ| be
the region covered by grid ΓS. We describe how to construct a multiresolution
triangulation of |Γ|.
As in Section 9.2.3 for 3D, we ﬁrst partition |Γ| into four-dimensional cubic
regions. Let k be the smallest integer such that 2k +1 ≥max(n1, n2, n3, n4). Let
c∗be a hypercube with edge length 2k and with opposing vertices at (0, 0, 0, 0)
and (2k, 2k, 2k, 2k). Region c∗contains |Γ|. If |Γ| does not equal c∗, divide c∗
into sixteen hypercubes. Recursively subdivide each of the hypercubes until each
hypercube is either contained in |Γ| or is disjoint from the interior of |Γ|. After k
partitions, each hypercube has edge length one. Thus the recursive subdivision
stops after at most k steps. Let Poct be the set of hypercubes that are contained
in |Γ|. Set Poct forms a partition of |Γ|.
Region c∗and its subdivisions form an octree containing |Γ|.
(See Sec-
tion 8.2.1 for a deﬁnition of octrees. As previously noted, the term octree is

340
10. Multiresolution Polyhedral Meshes
misleading in four dimensions. Each hypercube is partitioned into sixteen, not
eight, hypercubes.) Set Poct is the leaves of this octree that represent regions
contained in |Γ|. We call Poct the octree partition of |Γ|.
We triangulate each hypercube in the octree partition as follows. Consider
the hypercube c ∈Poct with opposing vertices v0 and v15. Vertex v0 lies in four
facets f1, f2, f3, and f4 of c. Each facet has a diagonal di connecting v0 to the
facet vertex opposite v0. For instance, if v0, v1, . . . , v7 are the vertices of f1 and
v7 is opposite v0 in f1, then di connects v0 to v7.
Each facet fi has a triangulation into six tetrahedra sharing edge di. The
convex hulls of each of these tetrahedra and point v15 form polyhedra in four
dimensions. This polyhedra each has ﬁve vertices and are four-dimensional sim-
plices. Since c has four facets containing v0 and each facet has six tetrahedra,
this construction creates twenty-four simplices. These twenty-four simplices tri-
angulate c. Each simplex contains the diagonal (v0, v15) of c as an edge.
Let t be a four-dimensional simplex and let q be some point at the interior of
some edge e of t. Let p0 and p1 be the endpoints of e and let p2, p3, and p4 be
the other vertices of t. To split simplex t at point q, we replace t with simplices
t′
0 and t′
1 where t′
0 has vertices p0, q, p2, p3, p4 and t′
1 has vertices q, p1, p2, p3, p4.
Simplices t′
0 and t′
1 partition t. Simplex t is bisected at point q, if t′
0 and t′
1 are
congruent.
Consider a tetrahedron t lying in f1 and the simplex t that is the convex
hull of t and v15. Point qcenter(c), the center of c, is also the midpoint of edge
(v0, v15) of t. Split t at qcenter(c) into two congruent simplices, t′
1 and t′
2, one
containing vertex v0 and the other containing vertex v15.
A four-dimensional simplex has type A if it is similar to t, i.e., it is congruent
to some scalar multiple of t. A simplex has type B if it is similar to t′
1 and t′
2.
Point qcenter(f1), the center of facet f1, is also the midpoint of an edge of t′
0
and t′
1. Split t′
0 and t′
1 at qcenter(f1) into four congruent simplices.
Let t′′ be a subsimplex of t′
0 or t′
1. A simplex has type C if it is similar to t′′.
Simplex t′′ contains qcenter(g), the center of g, for some two-dimensional face g
of c. Split t′′ at qcenter(g).
Let t′′′ be a subsimplex of t′′. A simplex has type D if it is similar to t′′.
Simplex t′′′ shares one edge e with c. Split t′′′ at point qcenter(e), the midpoint
of edge e. Splitting t′′′ at qcenter(e) creates two simplices that are similar to
simplex t, i.e., they are congruent to the simplex formed by shrinking t by a
factor of one-half.
The original twenty-four type A simplices sharing diagonal (v0, v15) divide
into forty-eight congruent type B simplices, each containing the center of some
facet of c. These forty-eight simplices divide into ninety-six congruent type C
simplices, each containing the center of some two-dimensional face of c. The
ninety-six simplices divide into 192 type D simplices, each sharing exactly one
edge with c. The 192 simplices divide into 384 type A simplices. Since these 384
simplices are similar to the original 24 simplices, the four bisection steps can be
repeated on the 384 simplices, creating simplices whose edges are one-fourth the

10.3. Multiresolution in 4D
341
original size. Repeated application of the bisection steps can lead to simplices
of arbitrarily small size.
We note a few things about this recursive bisection scheme. First, the angle
between a simplicial edge and a coordinate axis is zero, forty-ﬁve, or ninety
degrees. Second, all simplices are divided into four types of similar simplices.
Third, after four bisection steps, each of the resulting 384 simplices has an edge
from one of the original hypercube vertices vi to qcenter(c), the center of the
hypercube. Conversely, for each cube vertex vi, exactly forty-eight of the 384
simplices contain the edge (vi, qcenter(c)), and these forty-eight simplices form a
triangulation of the hypercube with opposite vertices vi and qcenter(c). Thus the
four bisection steps convert a triangulation of a hypercube into a triangulation of
the sixteen subcubes of that hypercube. Repeating the bisection steps another
four times gives a triangulation of 162 subcubes of the original cube. If all the
edges of c have length 2k + 1, then repeating the bisection steps 4k times gives
a triangulation of the 24k unit hypercubes in c.
A hypercube c in the octree partition Poct has eight diagonals. Each diag-
onal generates a diﬀerent triangulation of c composed of simplices sharing that
diagonal as an edge. If c does not equal c∗, then c was created by subdividing a
hypercube c′ into sixteen octants. The center qcenter(c′) of c′ is a vertex of c. Let
dsplit(c) be the diagonal of c connecting qcenter(c′) to the opposite vertex in c. If
c equals c∗, then let dsplit(c) be the diagonal from (0, 0, 0, 0) to (2k, 2k, 2k, 2k).
(As in 3D, c ∈Poct can only equal c∗if c∗equals |Γ|. In that case, Poct contains
only c∗.)
Choose the triangulation of c whose simplices share edge dsplit(c).
Label this triangulation τc.
Hypercube c and its subdivisions form a tree called the full-resolution tree on c.
The root of the tree represents the entire region c. The root has forty-eight chil-
dren, one for each simplex in τc. Each tree node other than the root represents
a four-dimensional simplex. The two children of a node representing simplex t
are the two simplices created by bisecting t into two congruent simplices. All the
simplices represented at a given level in the tree are congruent. The height of the
tree is 3j + 1 where 2j is the length of the edges of c. Every simplex produced
by 3j or fewer bisections of τ c is represented by some node in the tree. The
union of all the full-resolution trees over all hypercubes in the octree subdivision
is called the full-resolution forest.
The union of the triangulations τc form a subdivision of |Γ| into simplices,
although not necessarily a triangulation of |Γ|.
Bisecting simplices increases
the resolution of the subdivision. By choosing to bisect some simplices but not
others, we can increase the resolution in areas of interest.
As in 3D, we use an n1 × n2 × n3 × n4 multiresolution grid ΓM to determine
which simplices are bisected. For each simplex t, let qsplit(t) be the point used
to split t into two congruent tetrahedra. Point qsplit(t) is the midpoint of some
edge of t. For instance, if t is a type A tetrahedron containing a diagonal of
hypercube c, then qsplit(t) is the center, qcenter(c), of c.

342
10. Multiresolution Polyhedral Meshes
If simplex t is not a leaf of the full-resolution forest, then the coordinates
of qsplit(t) are all integers and qsplit(t) is represented by a vertex in grid ΓM.
Simplex t is bisected if and only if t is not at a leaf of the full-resolution forest
and ΓM(qsplit(t)) is true. If simplex t is a leaf of the full-resolution forest, then
qsplit(t) is not represented by any vertex in ΓM but t is never split into smaller
simplices.
The multiresolution grid ΓMrepresents a multiresolution subdivision of |Γ| as
follows. Starting from the triangulations τc for all c ∈Poct, bisect simplex t ∈τc
if qsplit(t) is true. Repeat this process on the resulting simplices until either t
is either a leaf of the full-resolution forest or qsplit(t) is false.
The resulting
simplices form a multiresolution subdivision of |Γ|.
To ensure that this multiresolution subdivision is a triangulation, we need
additional conditions on the multiresolution grid.
Multiresolution Conditions (4D, Forest).
Let simplex t be an internal node and
let hypercube c be represented by a root node in the full-resolution forest.
1. If t is a child of tetrahedron t′ in the full-resolution forest and qsplit(t) is
true, then qsplit(t′) is true.
2. Every corner v of region c is true.
We claim that a multiresolution grid that satisﬁes the Multiresolution Con-
ditions deﬁnes a multiresolution triangulation.
Proposition 10.12. If an n1 × n2 × n3 × n4 multiresolution grid ΓMsatisﬁes the
Multiresolution Conditions, then the set of simplices deﬁned by ΓMis a triangu-
lation of the region covered by ΓM.
The proof is similar to the proof of 9.7 and is omitted.
The 4D algorithm for converting an array of Boolean values into a multireso-
lution grid satisfying the Multiresolution Conditions parallels Algorithm 9.6 for
3D multiresolution grids. The only diﬀerence is that we must consider 2D face
centers in addition to grid edges and facets.
Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3, n4). Let ΓM
j
be the largest subgrid of ΓM containing (0, 0, 0, 0) that can be partitioned into
hypercubes of edge length 2j. Let Pj(ΓM) be the partition of ΓM
j into hypercubes
with edge length 2j.
For j from one to k, if ΓM(qcenter(e)) is true for some
edge e in Pj(ΓM), then set ΓM(qcenter(g)) to true for all two-dimensional faces
g ∈Pj(ΓM) containing e. If ΓM(qcenter(g)) is true for some two-dimensional face
g in Pj(ΓM), then set ΓM(qcenter(f)) to true for all three-dimensional facets f ∈
Pj(ΓM) containing g. If ΓM(qcenter(f)) is true for some three-dimensional facet
f in Pj(ΓM), then set ΓM(qcenter(c)) to true for all four-dimensional hypercubes
c ∈Pj(ΓM) containing f.
As in three dimensions, d-dimensional faces must
be processed before (d+1)-dimensional faces, and Pj(ΓM) must be processed
before Pj+1(ΓM). Pseudocode for Procedure SatisfyMultires4D is presented
in Algorithm 10.15.

10.3. Multiresolution in 4D
343
Input
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values.
SatisfyMultires4D(ΓM)
1 Poct ←octree partition of ΓM;
2 foreach hypercube c ∈Poct do
3
foreach corner v of c do
4
ΓM(v) ←true;
5
end
6 end
7 Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3, n4);
8 for j = 1 to k do
/* Pj(ΓM) is the partition of subgrid ΓM
j
of ΓM into hypercubes of
length 2j where ΓM
j
is the largest subgrid of ΓM containing (0, 0, 0)
that can be partitioned into hypercubes of length 2j.
*/
9
for d ←1 to 3 do
10
foreach d-dimensional face f in Pj(ΓM) do
/* qcenter(f) is the center of face f
*/
11
if (ΓM(qcenter(f)) = true) then
12
foreach (d + 1)-dimensional face g ∈Pj(ΓM) containing f do
13
ΓM(qcenter(g)) ←true;
14
end
15
end
16
end
17
end
18
foreach hypercube c in Pj(ΓM) do
19
if (ΓM(qcenter(c)) = true) then
20
foreach corner v of c do
21
ΓM(v) ←true;
22
end
23
end
24
end
25 end
Algorithm 10.15. Algorithm SatisfyMultires4D for four-dimensional
grids.
10.3.2
Multiresolution Marching Simplices (4D)
Algorithm Multiresolution Marching Simplices (Figure 10.3) is the ap-
plication of the 4D Marching Simplices from Section 6.4.5 to a multiresolu-

344
10. Multiresolution Polyhedral Meshes
Create a multiresolution grid satisfying the Multiresolution Condition

Read isosurface lookup table

Extract the isosurface from the multiresolution triangulation
represented by the multiresolution grid

Compute isosurface vertex coordinates using linear interpolation
Figure 10.3. Multiresolution Marching Simplices (4D) for n1 × n2 × n3 × n4
grids.
tion simplicial mesh. However, instead of constructing the multiresolution mesh
and then applying Marching Simplices, Multiresolution Marching Sim-
plices constructs each element of the multiresolution mesh and directly extracts
the isosurface patch from that element.
Input to Multiresolution Marching Simplices is a scalar grid, ΓS; an
array, Coord, of grid coordinates; a set, RegionList, of high-resolution regions; and
a scalar value σ. Start by converting the high-resolution regions to a multires-
olution grid, ΓM. (See Algorithm 10.16, CreateMultiresGrid4D.) Set every
vertex within the high-resolution regions to true. Set all other vertices to false.
Apply procedure SatisfyMultires (Algorithm 10.15) to the multiresolution
grid so that it satisﬁes the Multiresolution Conditions.
Read the isosurface lookup table from a preconstructed data ﬁle. To extract
the isosurface, create an octree partition Poct of ΓS. For each hypercube c in
Poct, construct the triangulation τc consisting of forty-eight simplices sharing
the edge dsplit(c). Recursively descend the full-resolution tree on c, identifying
and processing simplices in the tree. Upon reaching a simplex t, if t is a leaf
of the tree or if ΓM(qsplit(t)) is false, then extract an isosurface patch from t.
Otherwise, t is split into two simplices, t′ and t′′, and we repeat the procedure
on t′ and t′′.
In the ﬁnal step, assign geometric locations to the isosurface vertices based
on the scalar values at the endpoints of these bipolar edges.
To extract an isosurface patch from t, determine the entry in the isosurface
lookup table matching the conﬁguration of positive and negative vertex labels
on t. Retrieve from this entry the set of isosurface tetrahedra representing the
isosurface patch.

10.3. Multiresolution in 4D
345
Input
: ΓS is an n1 × n2 × n3 × n4 grid.
RegionList is a list of regions in ΓS.
Output
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values satisfying the
Multiresolution Condition.
CreateMultiresGrid4D(ΓS, RegionList, ΓM)
1 Initialize ΓM(v) to false for all vertices v;
2 foreach region R in RegionList do
3
foreach vertex v in R do
4
ΓM(v) ←true;
5
end
6 end
7 SatisfyMultires4D (ΓM);
Algorithm 10.16. Procedure CreateMultiresGrid4D for four-dimen-
sional grids.
Let tS be the “generic” simplex used in building the lookup table. As with
Marching Simplices, it is important to map the ith vertex of t in lexicographic
order to the ith vertex of tS. If this order is not preserved, then the isosurface
could have “cracks” or self-intersections as discussed in Section 6.4.
Instead of recursively constructing simplices in the multiresolution mesh, we
could iteratively enumerate and process all tetrahedra in the full-resolution for-
est. The iterative algorithm is a 4D version of Algorithm 9.10 in Section 9.2.7.
Details are left to the reader.
10.3.3
Multiresolution Convex Polyhedral Mesh
To extend Multiresolution Marching CPT to four dimensions, we need
to build multiresolution convex polyhedral meshes in four dimensions. In 3D,
the mesh is built from three convex polyhedra, cubes, square pyramids, and
tetrahedra. In 4D, the mesh is built from four convex polytopes, hypercubes,
two diﬀerent types of pyramids, and four-dimensional simplices. The two types
of pyramids have diﬀerent convex polyhedra as bases. If the 4D pyramid has a
3D cube as a base, then we call it a pyramid over a cube. If the 4D pyramid has
a 3D square pyramid as a base, then we call it a pyramid over a (square) pyramid.
A hypercube is divided in one of two ways. A hypercube is sometimes divided
into sixteen congruent subcubes sharing a vertex at the hypercube center. A
hypercube can also be divided into eight congruent pyramids over cubes whose
apices are the hypercube center and whose bases are the eight hypercube facets.
A pyramid over a cube is divided in two ways. A pyramid over a cube is
sometimes divided into eight congruent pyramids over cubes by splitting its base

346
10. Multiresolution Polyhedral Meshes
into eight subcubes and connecting its apex to each of the eight subcubes. A
pyramid over a cube can also be divided into six pyramids over square pyramids.
Divide the cube forming the base of the pyramid into six square pyramids by
connecting the center of the cube to the six square cube facets. Connect each
of the square pyramids to the apex of the original pyramid over a cube, forming
six pyramids over pyramids.
A pyramid over a square pyramid can also be divided in two ways. A pyramid
over a square pyramid can be divided into four pyramids over square pyramids
as follows. Let p be a 3D square pyramid and let p′ be a 4D pyramid whose
base is p. Split p into four square pyramids by splitting its square face into four
subsquares and joining each subsquare with the apex of p. Split p′ into four
pyramids over a pyramid by joining each of the four square subpyramids of p
with the apex of p′.
A pyramid over a square pyramid can also be divided into four simplices.
Again let p be a 3D square pyramid and let p′ be a 4D pyramid whose base is
p. Split p into four tetrahedra by splitting its square base into four triangles
and connecting each triangle with the apex of p. Split p′ into four simplices by
connecting each of the four tetrahedra to the apex of p′. These simplices have
type D as deﬁned in Section 10.3.1.
A type D simplex t is created by splitting a hypercube c into pyramids over
cubes, splitting one of these pyramids over cubes into pyramids over pyramids,
and splitting one of the pyramids over pyramids into simplices. Simplex t shares
one edge e with hypercube c. Bisecting t at the midpoint of e splits it into two
type A simplices. Type A simplices are never subdivided. Similarly, if a pyramid
over a cube is subdivided into eight pyramids over cubes, then the eight sub-
pyramids are never subdivided. If a pyramid over a pyramid is subdivided into
four pyramids over pyramids, then the four subpyramids are never subdivided.
As in 3D, we use a multiresolution grid, ΓM, to specify the multiresolution
convex polyhedral mesh. Each grid element ΓM(q) has a Boolean value, ΓM(q).b,
and a split type, ΓM(q).t. We say that ΓM(q) is true or false or has type X or
Y to mean that ΓM(q).b is true or false or ΓM(q).t equals X or Y.
For each polytope ψ, we deﬁne a point qsplit(ψ) that determines if and how
ψ is split into smaller polyhedra. For a hypercube c, point qsplit(c) is the center
of c. For a pyramid, p, over a cube, point qsplit(p) is the center of the base of
p. For a pyramid, p, over a square pyramid, p′, point qsplit(p) is the center of
the base of p′. For a tetrahedron tD of type D, point qsplit(tD) is the midpoint
of the edge tD shares with the cubic region containing tD. A tetrahedron tA of
type A is never split and qsplit(tA) is undeﬁned.
Point qsplit(ψ) is always the center of some hypercube or the center of some
face of a hypercube.
Because these cubic regions have edge length 2j, point
qsplit(ψ) is a grid vertex whenever j is greater than zero. Point qsplit(ψ) is not a
grid vertex only if ψ is a unit hypercube or if ψ is contained in a unit hypercube.
In all such cases, ψ is never subdivided and qsplit(ψ) is irrelevant.

10.3. Multiresolution in 4D
347
Let q equal qsplit(ψ) for mesh element ψ where ψ is not a unit hypercube
and is not contained in a unit hypercube. If ΓM(q).b is true, then ψ is split. If
ψ is a hypercube, then ψ is split into sixteen hypercubes whenever ΓM(q).t is
X and is split into eight pyramids over cubes whenever ΓM(q).t is Y. If ψ is a
pyramid over a cube, then ψ is split into eight pyramids over cubes whenever
ΓM(q).t is X and is split into six pyramids over pyramids whenever ΓM(q).t is Y.
If ψ is a pyramid over a square pyramid, then ψ is split into four pyramids over
square pyramids whenever ΓM(q).t is X and is split into four simplices whenever
ΓM(q).t is Y. If ψ is a simplex and ΓM(q).b is true, then ΓM(q).t is always Y and
ψ is split into two simplices. If ΓM(q).b is false, then ψ is not split and ΓM(q).t
is undeﬁned.
The cubic subdivisions of a hypercube form a tree.
The root of the tree
represents the original hypercube. Each node in the tree represents a hypercube
c with edge length 2j. If j is positive, then the node has sixteen children, one for
each subcube of c. If j is zero, then the node is a leaf. The cubic subdivisions of
an octree partition form a hypercube forest. The root of each tree in this forest is
a hypercube in the octree partition. Each tree represents the cubic subdivisions
of its corresponding region.
For each face f of a hypercube c, let qcenter(f) be the center of f. When f is a
vertex of c, qcenter(f) equals f. When f is an edge of c, qcenter(f) is the midpoint
of f. Face f can equal the entire hypercube c, in which case, qcenter(f) equals the
center of c = f.
Multiresolution Conditions (4D Convex Polyhedral Mesh).
Let d equal 1, 2, or
3. Let c be a hypercube at an internal node in the hypercube forest, let f be a
(d+1)-dimensional face of c, and let g be a d-dimensional face of f.
1. For every corner q of a region in the octree partition, ΓM(q).b is true and
has type X.
2. If ΓM(qcenter(f)) is true and has type X, then ΓM(qcenter(g)) is true and
has type X.
3. If ΓM(qcenter(g)) is true, then ΓM(qcenter(f)) is true.
4. If c is a child of region c′ in the hypercube forest, and ΓM(qcenter(c)).b is
true, then ΓM(qcenter(c′)) is true and has type X.
We sometimes use the term d-face in place of d-dimensional face. Note that
a hypercube c is a four-dimensional face of itself. Thus Multiresolution Condi-
tions 2 and 3 apply to each hypercube c and each facet g of c. A multiresolution
grid that satisﬁes the Multiresolution Conditions deﬁnes a multiresolution convex
polyhedral mesh.
Proposition 10.13. If an n1×n2×n3×n4 resolution grid satisﬁes the Multiresolu-
tion Conditions, then the set of hypercubes, pyramids over cubes, pyramids over
square pyramids, and simplices determined by that grid form a convex polyhedral
mesh.

348
10. Multiresolution Polyhedral Meshes
Input
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values.
SatisfyMultiresPoly4D(ΓM)
1 Poct ←octree partition of ΓM;
2 Satisfy4DCondition1(ΓM, Poct);
3 Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3, n4);
4 for j = 1 to k do
5
Satisfy4DCondition2(ΓM, j);
6
Satisfy4DCondition3(ΓM, j);
7
Satisfy4DCondition4(ΓM, j);
8 end
Algorithm 10.17. SatisfyMultiresPoly4D.
Input
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values.
2j is the length of the cubic regions begin processed.
Satisfy4DCondition1(ΓM, j)
1 foreach hypercube c in Pj(ΓM) do
2
foreach corner v of c do
3
ΓM(v).b ←true;
4
ΓM(v).t ←X;
5
end
6 end
Algorithm 10.18. Satisfy4DCondition1.
The proof is similar to the proof of Proposition 10.1 and is omitted.
Given a grid of Boolean values, we modify it to satisfy the Multiresolution
Conditions by setting ΓM(qcenter(f)).b to true as appropriate (Algorithm 10.17,
SatisfyMultiresPoly4D). Let ΓM
j
be the largest subgrid of ΓM containing
(0, 0, 0) that can be partitioned into cubic regions of edge length 2j. Let Pj(ΓM)
be the partition of subgrid ΓM
j
into cubic regions of edge length 2j. Process
the edges, 2-faces, and facets of Pj(ΓM) to satisfy each of the four Multires-
olution Conditions (Algorithms 10.18, 10.19, 10.20, and 10.21). The order in
which faces are processed is important, since setting ΓM(qcenter(f)).b to true or
ΓM(qcenter(f)).t to X can aﬀect ΓM(qcenter(g)) for faces g containing or contained
in f.
Procedure SatisfyMultiresPoly4D (Algorithm 10.17) satisﬁes the Mul-
tiresolution Condition but an additional procedure, IdentifyX4D, increases the
number of vertices of type X (Algorithm 10.22). For each face f of Pj(ΓM), if

10.3. Multiresolution in 4D
349
Input
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values.
2j is the length of the cubic regions begin processed.
Satisfy4DCondition2(ΓM, j)
1 for d = 3, 2, 1 do
2
foreach (d+1)-dimensional face f in Pj(ΓM) do
3
if (ΓM(qcenter(f)).b = true and ΓM(qcenter(f)).t = X) then
4
foreach d-dimensional face g of f do
5
ΓM(qcenter(g)).b ←true;
6
ΓM(qcenter(g)).t ←X;
7
end
8
end
9
end
10 end
Algorithm 10.19. Satisfy4DCondition2.
Input
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values.
2j is the length of the cubic regions begin processed.
Satisfy4DCondition3(ΓM, j)
1 for d = 1, 2, 3 do
2
foreach (d+1)-dimensional face f in Pj(ΓM) do
3
foreach d-dimensional face g of f do
4
if (ΓM(qcenter(g)).b = true and ΓM(qcenter(f)).b = false) then
5
ΓM(qcenter(f)).b ←true;
6
ΓM(qcenter(f)).t ←Y ;
7
end
8
end
9
end
10 end
Algorithm 10.20. Satisfy4DCondition3.
ΓM(qcenter(g)).b is true for all the subfaces of f, then set ΓM(qcenter(g)).t to type
X. The Boolean (ΓM(qcenter(g)).b must already be true, since ΓM satisﬁes the
Multiresolution Conditions.) Increasing the number of type X vertices decreases
the number of elements in the multiresolution mesh and the number of elements
in the isosurface.

350
10. Multiresolution Polyhedral Meshes
Input
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values.
2j is the length of the cubic regions begin processed.
Satisfy4DCondition4(ΓM, j)
1 foreach hypercube c in Pj(ΓM) do
2
if ΓM(qcenter(c)).b = true then
3
if c is one of the 16 subcubes of a hypercube c′ ∈Pj+1(ΓM) then
4
ΓM(qcenter(c′)).b ←true;
5
ΓM(qcenter(c′)).t ←X;
6
end
7
end
8 end
Algorithm 10.21. Satisfy4DCondition4.
Input
: ΓMis an n1 × n2 × n3 × n4 array of Boolean values satisfying the
Multiresolution Conditions.
IdentifyX4D(ΓM)
1 Let k be the smallest integer such that 2k + 1 ≥max(n1, n2, n3, n4);
2 for j = 1 to k do
3
for d = 1, 2, 3 do
4
foreach face f of dimension (d+1) in Pj(ΓM) do
5
if ΓM(qcenter(g).b is true for every d-face g of f then
6
ΓM(qcenter(f)).t ←X;
7
end
8
end
9
end
10 end
Algorithm 10.22. IdentifyX4D.
10.3.4
Multiresolution Marching HPS
The four-dimensional version of Multiresolution Marching CPT is called
Multiresolution Marching HPS (Figure 10.4). HPS stands for hypercubes,
pyramids, and simplices.
Input to Multiresolution Marching HPS is a scalar grid, ΓS; an array,
Coord, of grid coordinates; a set, RegionList, of high-resolution regions; and a
scalar value σ. In its ﬁrst step, the algorithm converts the high-resolution regions

10.3. Multiresolution in 4D
351
Create a multiresolution grid satisfying the Multiresolution Condition
for 4D convex polyhedral meshes

Read the isosurface lookup tables for 4D hypercubes,
pyramids over cubes, pyramids over square pyramids,
and four-dimensional simplices

Extract the isosurface from the multiresolution convex polyhedral mesh
represented by the multiresolution grid

Compute isosurface vertex coordinates using linear interpolation
Figure 10.4. Multiresolution Marching HPS for four-dimensional grids.
to a multiresolution grid, ΓM. Set every vertex within a high-resolution region to
true. Set all other vertices to false. Apply procedure SatisfyMultiresPoly4D
to the multiresolution grid so that is satisﬁes the Multiresolution Conditions.
Apply procedure IdentifyX4D to reduce the number of polyhedral elements in
the multiresolution grid.
In the second step, the algorithm reads four isosurface lookup tables, one for
each polytope type. In the third step, Multiresolution Marching HPS ex-
tracts the isosurface from the multiresolution mesh. Create a 4D octree partition,
Poct(ΓM), of ΓM.
For each cubic region c ∈Poct(ΓM), if ΓM(qcenter(c)).b is false, then extract
an isosurface patch from cube c using the isosurface lookup table for cubes. If
ΓM(qcenter(c)) is true and has type X, then divide c into sixteen hypercubes and
recursively process each hypercube. If ΓM(qcenter(c)) is true and has type Y,
then divide c into eight pyramids over cubes.
For each pyramid p over a cube, if ΓM(qcenter(p)) is false, then extract an
isosurface patch from pyramid p using the isosurface lookup table for pyramids
over cubes. If ΓM(qcenter(p)) is true and has type X, then divide p into eight
pyramids over cubes. Extract an isosurface patch from each of the eight subpyra-
mids using the isosurface lookup table for pyramids over cubes. If ΓM(qcenter(p))
is true and has type Y, then divide p into six pyramids over square pyramids.
For each pyramid p over a square pyramid, if ΓM(qcenter(p)) is false, then
extract an isosurface patch from pyramid p using the isosurface lookup table for
pyramids over square pyramids. If ΓM(qcenter(p)) is true and has type X, then

352
10. Multiresolution Polyhedral Meshes
divide p into four pyramids over square pyramids. Extract an isosurface patch
from each of the four subpyramids using the isosurface lookup table for pyramids
over pyramids. If ΓM(qcenter(p)) is true and has type Y, then divide p into four
type D simplices.
For each type D simplex t, if ΓM(qcenter(t)) is false, then extract an isosurface
patch from simplex t using the isosurface lookup table for four-dimensional sim-
plices. If ΓM(qcenter(t)) is true, then split t into two congruent type A simplices.
Type A simplices are never subdivided. Extract the isosurface patch from each
of the type A simplices using the isosurface lookup table for four-dimensional
simplices.
In the ﬁnal step, assign geometric locations to the isosurface vertices using
linear interpolation.
As discussed in Section 6.3.1, it is crucial that isosurface patch triangula-
tions match along their common boundary. The isosurface lookup tables for the
diﬀerent polytopes must be compatible and the mesh vertices must be properly
mapped to the isosurface table vertices. As discussed in Section 6.5.3, the apex
of a 4D pyramid over a cube should be mapped to the apex in the isosurface
lookup table while the base vertices should be mapped in lexicographic order.
Similarly, to map a 4D pyramid p over a 3D square pyramid p′ to a 4D pyramid
ψ over a 3D square pyramid ψ′ in the isosurface lookup table, the apex of p
should map to the apex of ψ, the apex of p′ should map to the apex of ψ′, and
the base vertices of p′ should map in lexicographic order to the base vertices
of ψ′.
10.4
Notes and Comments
Weber et al. [Weber et al., 2001] give a multiresolution polyhedral mesh with
grids of cubes connected by pyramids and tetrahedra. They analyze 64 conﬁg-
urations of pyramids and tetrahedra to form these connections, exploiting some
symmetry to simplify the analysis.
The multiresolution CPT (cube, pyramid, and tetrahedra) mesh presented
in this chapter is a special case of diamond hierarchies discussed by Pascucci
in [Pascucci, 2002].
Weiss and De Floriani in [Weiss and De Floriani, 2011]
discuss variations and applications of these diamond hierarchies.
Other algorithms that construct multiresolution isosurfaces are described in
[Ho et al., 2005,Schaefer and Warren, 2004,Kazhdan and Hoppe, 2007,Manson
and Schaefer, 2010]. In general, the isosurfaces constructed by these algorithms
are manifolds.
Multiresolution dual contouring algorithms are presented in [Perry and Fris-
ken, 2001,Ju et al., 2002,Schaefer and Warren, 2002,Varadhan et al., 2003,Zhang
et al., 2004]. Multiresolution dual contouring algorithms that produce manifolds
are described in [Ashida and Badler, 2003,Greß and Klein, 2004,Schaefer et al.,
2007].

10.4. Notes and Comments
353
Barry and Wood [Barry and Wood, 2007] give a dual contouring algorithm
for constructing a multiresolution isosurface with a detailed normal map. The
normal map contains information about the surface normals in low resolution
regions.

This page intentionally left blank
This page intentionally left blank

CHAPTER 11
ISOVALUES
The previous chapters presented algorithms and data structures for building
an isosurface for a given isovalue. In this chapter, we discuss algorithms and
techniques for choosing this isovalue.
Choice of isovalue is application dependent. Diﬀerent imaging devices, dif-
ferent materials, and diﬀerent areas of interest dictate diﬀerent choices for the
isovalue. Nevertheless, there are some generic algorithms and techniques that
can assist in ﬁnding the isovalue that determines the desired isosurface.
Diﬀerent materials are often represented by diﬀerent isovalues within a vol-
umetric data set. (See Figures 11.1 and 11.2.) Each of the isosurfaces corre-
sponding to each of the isovalues represents a diﬀerent material surface. Thus,
the goal is to determine a set of isovalues, not necessarily a single one, that may
be signiﬁcant.
Often a range of isovalues generates similar isosurfaces with small, insigniﬁ-
cant diﬀerences between them. Isovalues within the range generate “equivalent”
isosurfaces. Thus, the goal may be restated as determining a set of potentially
signiﬁcant isovalue ranges. Sampling one isovalue from each range and construct-
ing the corresponding isosurface gives a set of potentially signiﬁcant isosurfaces.
The simplest technique for choosing isovalues is to plot the frequency of each
scalar value among the set of grid vertices. Using this plot, one selects a sample
set of isovalues representing signiﬁcantly diﬀerent isosurfaces. Frequency plots
of vertex scalar values are discussed in Section 11.1.
If the data set consists of scalar integers, use isovalues (x + 0.5), where x
is an integer. For data sets of integers and noninteger isovalues, the March-
ing Cubes and Manifold Dual Marching Cubes isosurfaces are always
manifolds, and the returned sets of triangles contain no zero-area or duplicate
triangles (Sections 2.3.3 and 3.3.6).
Another approach to representing scalar frequencies is to plot the number of
grid edges or grid cubes containing each scalar value. As deﬁned in Chapter 8,
the span of a grid cube is the interval from the minimum to the maximum
355

356
11. Isovalues
(a)
(b)
Figure 11.1. (a) Engine isosurface, isovalue 80. (b) Engine isosurface, isovalue 170.
(a)
(b)
Figure 11.2. (a) Tooth isosurface, isovalue 640. (b) Isosurface of tooth enamel, isovalue
920.

11.1. Counting Grid Vertices
357
scalar value of any cube vertex. The span of a grid edge is the interval from
the minimum to the maximum scalar value of the two edge vertices. The plot
represents the number of grid edges or grid cubes whose spans contain each scalar
value. Frequency plots based on spans of grid edges and cubes are discussed in
Section 11.2.1.
As discussed in Section 11.1, frequency plots of vertex scalar values represent
interval volumes, the volume between two isosurfaces. In contrast, frequency
plots of grid edges or grid cubes represent isosurface area. Section 11.2.2 de-
scribes how grid edges and grid cubes can be used to represent interval volumes.
The boundary between materials in a scalar ﬁeld is often marked by a sharp
change in the scalar values at the boundary. This change is reﬂected in a gra-
dient with a large magnitude. Representations of the gradient are discussed in
Section 11.3.
11.1
Counting Grid Vertices
The frequency of scalar value σ in a scalar grid is the number of grid vertices
with scalar value σ. Let Fv(σ) denote the frequency of scalar value σ. When
the scalar values are integers in a small range, the frequency of scalar values can
be represented by a histogram, a bar graph representing the frequencies. The
height of the bar corresponding to scalar value σ is Fv(σ), the frequency of σ.
Figure 11.3 contains an example of a histogram of scalar frequencies. Note the
the y-axis is represented on a logarithmic scale.
100
1000
10000
100000
1e+06
1e+07
0
50
100
150
200
250
Figure 11.3. Histogram of scalar frequencies of engine data set.

358
11. Isovalues
100
1000
10000
100000
1e+06
1e+07
0
50
100
150
200
250
(a) Engine data set.
1
10
100
1000
10000
100000
1e+06
1e+07
0
50
100
150
200
250
(b) Visible male data set.
Figure 11.4. Frequency polygons representing scalar frequencies.
When the scalar values are integers in a large range or the image resolution is
small, the bars in a histogram become very dense. It is then better to represent
the frequencies by the polygonal line with vertices (σ, Fv(σ)). (See Figure 11.4.)
Such a polygonal line is called a frequency polygon.
Scalar values may also be ﬂoating point numbers. In that case, the range
[smin, smax] of scalar values is partitioned into some ﬁxed number, k, of uniform
size bins. Bin i < k has a subrange [si−1, si) or, equivalently, {σ : si−1 ≤σ < si}.
Note that this subrange is closed at si−1 and open at si. The value of s0 and sk
are smin and smax, respectively. We count the number of scalar values in each
subrange.
The frequency of scalar values in the range [σ0, σ1) (i.e., {σ : σ0 ≤σ < σ1})
is the number of grid vertices with scalar values in the range [σ0, σ1).
This
frequency is denoted Fv(σ0, σ1).

11.1. Counting Grid Vertices
359
10
100
1000
0
50
100
150
200
250
Figure 11.5.
Histogram of scalar frequencies of Marschner-Lobb data set.
The
Marschner-Lobb data set is a sampling of the Marschner-Lobb function in the region
[−1, 1]×[−1, 1]×[−1, 1] on a regular 41×41×41 grid. See Figure 11.9 for the deﬁnition
of the Marschner-Lobb function.
The range [σ0, σ1) is open at σ1.
It is useful to have a slightly diﬀerent
version of Fv on the closed range [σ0, σ1]. Let Fv(σ0, σ1) denote the number of
grid vertices with scalar values in the closed range [σ0, σ1].
The frequency of scalar values in bin i < k is the frequency, Fv(si−1, si), of
scalar values in [si−1, si). The frequency of scalar values in bin k is the frequency,
Fv(sk−1, sk), of scalar values in [sk−1, sk].
The frequency of scalar values is
plotted either as a histogram or as a frequency polygon.
Bins are also useful on small grids of integer scalar values. On small grids
with relatively few vertices, sampling frequencies of consecutive integers can vary
greatly, creating “noisy” plots. (See Figure 11.5.) Partitioning the range into
a small number of bins and counting the frequency of scalar values within each
bin eﬀectively smooths these plots, creating a much more useful representation
of the data. (See Figure 11.6.)
The plot of scalar frequencies typically has some “peaks” of high-frequency
scalar values separating regions of scalar values with approximately uniform
frequencies.
The high-frequency scalar values are often not good choices for
isovalues. Zero typically has the highest frequency, often an order of magnitude
larger than the frequency of any other scalar value. Isovalues at or near zero do
not usually generate interesting or signiﬁcant isosurfaces.
High-frequency scalar values other than zero often represent transitions be-
tween two surfaces representing diﬀerent materials. (See Figures 11.7 and 11.8.)

360
11. Isovalues
1000
10000
0
50
100
150
200
250
Figure 11.6. Plot of scalar frequencies of Marschner-Lobb data set using bins of size
eight. Note that the range of frequencies has changed by about a factor of eight since
each bin represents eight values instead of one.
Scalar values from the regions between “peaks” represent the materials them-
selves and are a better choice for isovalues than scalar values at the peaks.
To compare plots of frequencies from diﬀerent data sets, it is useful to have a
normalized version of the frequency. To normalize the frequencies, Fv(σ0, σ1) we
divide by the total number, NΓ, of the grid vertices of Γ, and by the size σ1 −σ0
of the bin. (Note that NΓ is the total number of vertices, not the number of
vertices along a grid axis. For an n × n × n grid, NΓ equals n3.)
Deﬁne the normalized frequency of scalar values as
F∗
v (σ0, σ1)
=
Fv(σ0, σ1)
NΓ × (σ1 −σ0),
F
∗
v(σ0, σ1)
=
Fv(σ0, σ1)
NΓ × (σ1 −σ0).
When the range of scalar values is partitioned into some ﬁxed number of bins of
uniform size α, the normalized frequencies are simply the bin frequencies divided
by NΓ × α.
As either the number of grid vertices, NΓ, or the bin size, (σ1 −σ0), increase,
the values Fv(σ0, σ1) and Fv(σ0, σ1) increase proportionally, so F∗
v (σ0, σ1) and
F
∗
v(σ0, σ1) remain relatively the same. Thus the normalized frequency measures
depend primarily on the function φ, not on the grid or bin sizes.

11.1. Counting Grid Vertices
361
 1
 10
 100
 1000
 10000
 100000
 1e+06
 1e+07
 0
 200
 400
 600
 800
 1000
 1200
a
b
c
d
e
Figure 11.7. Scalar frequencies of tooth data set. Labeled points correspond to isoval-
ues of images in Figure 11.8.
(a)
(b)
(c)
(d)
(e)
Figure 11.8. Tooth data set. (a) Isovalue 187. Isosurface represents container around
tooth and root of tooth. Isosurface is clipped to show root of tooth. (b) High-frequency
isovalue 386. Isosurface represents the transition between the container surface (iso-
value 187) and the tooth surface (isovalue 640). (c) Isovalue 640. Isosurface represents
tooth surface. (d) High-frequency isovalue 828. Isosurface represents the transition
between the tooth surface (isovalue 640) and the tooth enamel surface (isovalue 920).
(e) Isovalue 920. Isosurface represents tooth enamel.

362
11. Isovalues
0.001
0.01
 0
 50
 100
 150
 200
 250
21×21×21 grid, bin size 16
41×41×41 grid, bin size 8
129×129×129 grid, bin size 6
257×257×257 grid, bin size 4
Figure 11.9.
Normalized
scalar
frequencies for
the Marschner-Lobb function
φ(x, y, z) = (1 −sin(πz/2)) + (1 + cos(12π cos(πr/2)))/10 where r =

x2 + y2 and
−1 ≤x, y, z ≤1. The function was sampled on four diﬀerent regular grids. Plots of
normalized frequencies on a 21 × 21 × 21 grid with bin size 16, a 41 × 41 × 41 grid with
bin size 8, a 127 × 127 × 127 grid with bin size 6, and a 257 × 257 × 257 grid with bin
size 4.
Figure 11.9 contains an example of normalized scalar frequency plots of the
Marschner-Lobb function using diﬀerent grid and bin sizes. Figure 11.10 contains
normalized plots for the engine, visible male, and Marschner-Lobb data sets.
If the range [smin, smax] of scalar values are partitioned into k bins [si−1, si),
then
k−1

i=1
(F∗
v (si−1, si) × (si −si−1)) + F
∗
v(sk−1, sk) × (sk −sk−1) = 1.
What property of the data is being measured by the frequency of scalar
values? Let f : D →R deﬁne a scalar ﬁeld on a rectangular region D ⊂R3
and let Γ be a regular grid sampling of φ. To make the dependence of Fv and
Fv on Γ explicit, we use the notation Fv(σ0, σ1, Γ) and Fv(σ0, σ1, Γ) in place of
Fv(σ0, σ1) and Fv(σ0, σ1), respectively.
The value Fv(σ0, σ1, Γ) is the number of vertices of Γ in the region {x ∈
R3 : σ0 ≤φ(x) ≤σ1}. This region is Iφ(σ0, σ1), the interval volume deﬁned
in Chapter 7. The ratios Fv(σ0, σ1, Γ)/NΓ and Fv(σ0, σ1, Γ)/NΓ approximate
|Iφ(σ0, σ1)|/|D| where |Iφ(σ0, σ1)| is the volume of Iφ(σ0, σ1) and |D| is the
volume of the domain D.
By repeatedly partitioning each cube in a grid into eight subcubes, we get a
sequence of grids, each one with eight times the number of cubes and approx-

11.2. Counting Grid Edges and Grid Cubes
363
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0.1
1
0
50
100
150
200
250
Engine
Visible male
Marschner-Lobb
Figure 11.10. Normalized scalar frequencies of engine, visible male, and Marschner-
Lobb data sets. The Marschner-Lobb data set samples the Marschner-Lobb function
on a 41 × 41 × 41 regular grid. Plot of Marschner-Lobb data set uses size eight bins.
imately eight times the number of vertices of its predecessor. As the number
of grid vertices, NΓ, goes to inﬁnity, Fv(σ0, σ1, Γ)/NΓ and Fv(σ0, σ1, Γ)/NΓ ap-
proach |Iφ(σ0, σ1)|/|D|.
11.2
Counting Grid Edges and Grid Cubes
Grid edges and grid cubes can be used to measure isosurface area and to measure
the interval volume between isosurfaces.
11.2.1
Measuring Isosurface Area
As previously deﬁned, the span of a grid cube is the interval from the minimum
to the maximum scalar value of any cube vertex. The span of a grid edge is
the interval from the minimum to the maximum scalar value of the two edge
vertices.
When the scalar values are integers, we plot the number of grid edges or grid
cubes whose span contains each scalar value. When the scalar values are ﬂoating
point numbers, the range [smin, smax] of scalar values is sampled at regular inter-
vals by a ﬁxed number of scalar values. We plot the number of grid edges or grid
cubes whose span intersects each scalar value. Plots can either be histograms or
polygonal lines. Figure 11.11 contains examples of plots.

364
11. Isovalues
1
10
100
1000
10000
100000
1e+06
1e+07
0
200
400
600
800
1000
1200
Edge frequency
1
10
100
1000
10000
100000
1e+06
1e+07
0
200
400
600
800
1000
1200
Cube frequency
(a)
(b)
Figure 11.11. Tooth data set. (a) Number of grid edges whose spans contain the scalar
value. (b) Number of grid cubes whose spans contain the scalar value.
As with plots of scalar frequencies, we deﬁne a normalized plot of frequencies
of edge or cube spans. Let Fe(σ) and Fc(σ) be the number of edges or cubes,
respectively, whose spans contain the scalar value σ.
To normalize the plot of edge and cube frequencies, we divide by the sum
of Fe(σ) or Fc(σ) and by the average bin size. Let {si : i = 0, . . . , k} be the
k + 1 scalar values of the range [smin, smax] sampled at regular intervals where
s0 = smin and sk = smax. Let α = (smax −smin)/k be the average bin size.
Deﬁne normalized values F∗
e (σ) and F∗
c (σ) as
F∗
e (σ)
=
Fe(σ)
α k
i=0 Fe(si)
,
F∗
c (σ)
=
Fc(σ)
α k
i=0 Fc(si)
.
Note that as the number k of samples increases, the decrease in the average
bin size, α, is proportional to the increase in k
i=0 Fc(si), so F∗
e (σ) and F∗
c (σ)
remain approximately the same.
The normalized frequencies sum to 1/α so that
α
k

i=0
F∗
e (si)
=
1,
α
k

i=0
F∗
c (si)
=
1.
As illustrated in Figure 11.12, normalized edge and cube frequencies depend
primarily on the function φ, not the grid or bin sizes.

11.2. Counting Grid Edges and Grid Cubes
365
0.001
0.01
0
50
100
150
200
250
21×21×21 grid, bin size 16
41×41×41 grid, bin size 8
129×129×129 grid bin size 6
257×257×257 grid, bin size 4
(a) Edge span frequencies.
0.001
0.01
0
50
100
150
200
250
21×21×21 grid, bin size 16
41×41×41 grid, bin size 8
129×129×129 grid, bin size 6
257×257×257 grid, bin size 4
(b) Cube span frequencies.
Figure 11.12. Normalized edge and cube span frequencies of the Marschner-Lobb func-
tion for a 21 × 21 × 21 grid with bin size 16, a 41 × 41 × 41 grid with bin size 8, a
129 × 129 × 129 grid with bin size 6, and a 257 × 257 × 257 grid with bin size 4.

366
11. Isovalues
1e–08
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0.1
1
0
200
400
600
 800
1000
1200
Scalar frequency
Edge frequency
Cube frequency
1e–05
0.0001
0.001
0.01
0.1
1
0
50
100
150
200
250
Scalar frequency
Edge frequency
Cube frequency
(a) Tooth data set.
(b) Engine data set.
Figure 11.13. Graphs of F∗
v , F∗
e , and F∗
c .
The functions Fe(σ) and Fc(σ) approximate the number of edges and cubes,
respectively, intersecting the level set φ−1(σ). This number can be used as a
relative measure of the area |φ−1(σ)| of φ−1(σ).
More speciﬁcally, let f : D →R deﬁne a scalar ﬁeld on a rectangular region
D ⊂R3 and let Γ be a regular grid sampling of φ. To make the dependence of Fe
and Fc on Γ explicit, we use the notation Fe(σ, Γ) and Fc(σ, Γ) in place of Fe(σ)
and Fc(σ), respectively. The ratios Fe(σ, Γ)/Fe(σ′, Γ) and Fc(σ, Γ)/Fc(σ′, Γ)
approximate the ratio of areas |φ−1(σ)|/|φ−1(σ′)| where σ and σ′ are scalar
values in the range of φ.
By repeatedly partitioning each cube in a grid into eight subcubes, we get a
sequence of grids, each one with eight times the number of cubes and approxi-
mately eight times the number of vertices of its predecessor. As the number of
grid vertices goes to inﬁnity, Fe(σ, Γ)/Fe(σ′, Γ) and Fc(σ, Γ)/Fc(σ′, Γ) approach
|φ−1(σ)/|φ−1(σ′)|.
11.2.2
Measuring Interval Volumes
Functions Fe and Fc approximate isosurface area while Fv approximates the
interval volume between two isosurfaces. The two measures are not necessarily
the same, even after normalization. (See Figure 11.13.) The measure of the
interval volume between two isosurfaces with isovalues σ0 and σ1 depends upon
the “distance” between the isosurfaces. In contrast, the area of the isosurface
with isovalue σ0 is independent of its “distance” to any other isosurface.
The interval volume can be measured using grid edges or grid cubes. Consider
an edge whose endpoints p and q have scalar values sp and sq, respectively. If
the interval [σ0, σ1] intersects the edge span [sp, sq], then the interval volume
Iφ(σ0, σ1) intersects edge (p, q). However, if |sq−sp| is much larger than |σ1−σ0|,

11.2. Counting Grid Edges and Grid Cubes
367
1e–09
1e–08
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0.1
1
0
200
400
600
800
1000
1200
Scalar frequency
Edge frequency
Interval volume (edge based)
1e–05
0.0001
0.001
0.01
0.1
1
0
50
100
150
200
250
Scalar frequency
Edge frequency
Interval volume (edge based)
(a) Tooth data set.
(b) Engine data set.
Figure 11.14. Graphs of F∗
v , F∗
e , and Vol∗
e.
then Iφ(σ0, σ1) will intersect only a fraction of edge (p, q).
This fraction is
|σ1 −σ0|/|sq −sp|.1
Let E(σ0, σ1) be the set of grid edges (p, q) whose span, [sp, sq], intersects
[σ0, σ1]. Deﬁne Vole(σ0, σ1) as
Vole(σ0, σ1) =

(p,q)∈E(σ0,σ1)
|sp−sq|≤|σ1−σ0|
1
3 +

(p,q)∈E(σ0,σ1)
|sq−sp|>|σ1−σ0|
|σ1 −σ0|
3|sq −sp|.
The division by 3 is to compensate for the number of grid edges being about
three times the number of grid vertices. Note that the values in the second sum
are always less than or equal to one. The value Vole(σ0, σ1) approximates the
size of the interval volume Iφ(σ0, σ1).
To normalize Vole, we divide by the sum of Vole and by the bin size, σ1 −σ0.
Let {si : i = 0, . . . , k} be the k +1 scalar values of the range [smin, smax] sampled
at regular intervals where s0 = smin and sk = smax. Deﬁne normalized values
Vol∗
e(σ0, σ1) as
Vol∗
e(σ0, σ1) =
Vole(σ0, σ1)
(σ1 −σ0) k
i=1 Vole(si−1, si)
.
Figure 11.14 contains examples comparing F∗
e and Vol∗
e.
To measure the interval volume using grid cubes, let Span(c) be the span of
cube c, i.e., the interval [σ, σ′] where σ is the lowest scalar value of any vertex
in c and σ′ is the greatest. The notation |Span(c)| = |σ′ −σ| represents the size
of the span of c. Let C(σ0, σ1) be the set of grid cubes whose span intersects
1Alternate derivations ( [Bachthaler and Weiskopf, 2008] and [Scheidegger et al., 2008]) are
based on the coarea formula. See notes and comments in Section 11.4.

368
11. Isovalues
1e–08
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0.1
1
0
200
400
600
800
1000
1200
Scalar frequency
Cube frequency
Interval volume (cube based)
1e–05
0.0001
0.001
0.01
0.1
1
0
50
100
150
200
250
Scalar frequency
Cube frequency
Interval volume (cube based)
(a) Tooth data set.
(b) Engine data set.
Figure 11.15. Graphs of F∗
v , F∗
c , and Vol∗
c.
1e–09
1e–08
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0.1
1
0
200
400
600
800
1000
1200
Scalar frequency
Interval volume (edge based)
Interval volume (cube based)
 1e–05
0.0001
0.001
0.01
0.1
1
0
50
100
150
200
250
Scalar frequency
Interval volume (edge based)
Interval volume (cube based)
(a) Tooth data set.
(b) Engine data set.
Figure 11.16. Graphs of F∗
v , Vol∗
e, and Vol∗
c.
[σ0, σ1]. Deﬁne Volc(σ0, σ1) as
Volc(σ0, σ1) =

c∈C(σ0,σ1)
|Span(c)|≤|σ1−σ0|
1 +

(p,q)∈E(σ0,σ1)
|Span(c)|>|σ1−σ0|
|σ1 −σ0|
|Span(c)|.
The value Volc(σ0, σ1) approximates the size of the interval volume Iφ(σ0, σ1).
Deﬁne Vol∗
c(σ0, σ1), the normalized version of Volc(σ0, σ1), as
Vol∗
c(σ0, σ1) =
Volc(σ0, σ1)
(σ1 −σ0) k
i=1 Volc(si−1, si)
.
Since the number of grid cubes is approximately the number of grid vertices,
there is no division by 3.
Figure 11.15 contains examples comparing F∗
c and Vol∗
c. Figure 11.16 con-
tains examples comparing F∗
v , Vol∗
e, and Vol∗
c.

11.3. Measuring Gradients
369
11.3
Measuring Gradients
Given a scalar ﬁeld φ : R3 →R, the gradient of φ is
∇φ =
∂φ
∂x, ∂φ
∂y , ∂φ
∂z

.
The magnitude of the gradient is
|∇φ| =
∂φ
∂x
2
+
∂φ
∂y
2
+
∂φ
∂z
2
.
High gradient magnitudes often indicate changes in the materials represented by
the data set. High gradient magnitudes are often better indicators of signiﬁcant
isosurfaces than scalar frequencies.
There are two measures of gradients over a level set. The total gradient of φ
over a level set σ = φ−1(σ) is

S=φ−1(σ)
|∇φ|dS.
The total gradient integrates the gradient magnitude over the entire level set.
Thus level sets with large gradients but a small area can have the same total
gradient as level sets with small gradients but a large area. The mean gradient of
φ over a level set σ = φ−1(σ) is

S=φ−1(σ) |∇φ|dS
|φ−1(σ)|
,
where |φ−1(σ)| is the area of φ−1(σ).
It is sometimes a better indicator of
signiﬁcant isovalues than the total gradient.
Edge and cube spans can be used to approximate the relative magnitude
of gradients (Section 11.3.1). They can also be computed using the Laplacian
(Section 11.3.2).
11.3.1
Gradients Based on Grid Edges and Grid Cubes
The simplest approximation to the gradient is the diﬀerence between the scalar
values of grid edge endpoints. Summing |sq−sp| over all edges (p, q) that intersect
an isosurface gives a relative measure of the total gradient.
Let E(σ) be the set of grid edges (p, q) that intersect the isosurface with
isovalue σ. Deﬁne TotalGrade(σ) as
TotalGrade(σ) =

(p,q)∈E(σ)
|sq −sp|
3
.

370
11. Isovalues
1e–08
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0
200
400
600
800
1000
1200
Total gradient (edge based)
Total gradient (cube based)
0.0001
0.001
0.01
0
50
100
150
200
250
Total gradient (edge based)
Total gradient (cube based)
(a) Tooth data set.
(b) Engine data set.
Figure 11.17. Graphs of TotalGrad∗
e and TotalGrad∗
c.
Again, the division by 3 compensates for the number of grid edges being about
three times the number of grid vertices.
The ratio TotalGrade(σ)/TotalGrade(σ′) approximates the ratio of total gra-
dients,

S=φ−1(σ) |∇φ|dS

S′=φ−1(σ′) |∇φ|dS′ .
Cube spans can also be used for a relative measure of the total gradient. As
in Section 11.2.2, let Span(c) be the interval [σ, σ′] where σ is the lowest scalar
value of any vertex in c and σ′ is the greatest. Let C(σ) be the set of grid cubes
that intersect the isosurface with isovalue σ. Deﬁne TotalGradc(σ) as
TotalGradc(σ) =

c∈C(σ)
|Span(c)|.
The ratio TotalGradc(σ)/TotalGradc(σ′) also approximates the corresponding
ratio of total gradients.
As with all other measures, normalized versions are useful for comparing
diﬀerent data sets. Let {si : i = 0, . . . , k} be the k + 1 scalar values of the
range [smin, smax] sampled at regular intervals where s0 = smin and sk = smax.
Let α = (smax −smin)/k be the average bin size. The normalized versions of
TotalGrade(σ) and TotalGradc(σ) are
TotalGrad∗
e(σ)
=
TotalGrade(σ)
α k
i=0 TotalGrade(si)
,
TotalGrad∗
c(σ)
=
TotalGradc(σ)
α k
i=0 TotalGradc(si)
.
As before, α equals the average bin size, (smax −smin)/k.
Figure 11.17 contains examples of plots of TotalGrad∗
e and TotalGrad∗
c.

11.3. Measuring Gradients
371
0.0001
0.001
0.01
0
200
400
600
800
1000
1200
Mean gradient (edge based)
Mean gradient (cube based)
0.0001
0.001
0.01
0
50
100
150
200
250
Mean gradient (edge based)
Mean gradient (cube based)
(a) Tooth data set.
(b) Engine data set.
Figure 11.18. Graphs of MeanGrad∗
e and MeanGrad∗
c.
The edge frequency, Fe(σ), approximates the isosurface area (up to a con-
stant factor.) The mean gradient is computed by dividing by Fe(σ).
Deﬁne
MeanGrade(σ) and MeanGradc(σ) as
MeanGrade(σ)
=
TotalGrade(σ)
Fe(σ)
,
MeanGradc(σ)
=
TotalGradc(σ)
Fe(σ)
.
We use Fe(σ), not Fc(σ), in the deﬁnition of MeanGradc. We could have used
Fc(σ), but Fe(σ) seems to be a slightly more accurate measure of relative iso-
surface area.
Normalized versions of MeanGrade(σ) and MeanGradc(σ) are
MeanGrad∗
e(σ)
=
MeanGrade(σ)
α k
i=0 MeanGrade(si)
,
MeanGrad∗
c(σ)
=
MeanGradc(σ)
α k
i=0 MeanGradc(si)
.
Figure 11.18 contains examples of plots of MeanGrad∗
e and MeanGrad∗
c.
Figure 11.19 compares plots of the scalar frequency, isosurface area, total
gradient, and mean gradient. The plots of the scalar frequency and isosurface
area are similar but not quite the same.
Peaks in those plots correspond to
isosurfaces representing transitions between surfaces.
These isosurfaces have
large amounts of noise. The signiﬁcant isosurfaces lie between the peaks. Some
of the peaks in the plot of total gradient correspond to signiﬁcant isosurfaces, but
others correspond to isosurfaces with large amounts of noise. Some signiﬁcant
isovalues also fail to correspond to any peak.

372
11. Isovalues
1e–08
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0.1
1
0
200
400
600
800
1000
1200
Scalar frequency
Isosurface area (edge based)
Total gradient (edge based)
Mean gradient (edge based)
1e–05
0.0001
0.001
0.01
0.1
1
0
50
100
150
200
250
Scalar frequency
Isosurface area (edge based)
Total gradient (edge based)
Mean gradient (edge based)
(a) Tooth data set.
(b) Engine data set.
Figure 11.19. Comparisons of scalar frequency, isosurface area, total gradient, and
mean gradient.
The most useful plot in Figure 11.19 is the plot of the mean gradient. The
three distinct peaks in the tooth data set correspond to three distinct, signiﬁcant
isovalues. Similarly, the two distinct peaks in the engine data set correspond to
two distinct, signiﬁcant isovalues.
11.3.2
Gradients Based on the Laplacian
Let Ψ : R3 →R3 be a continuously diﬀerentiable vector ﬁeld deﬁned as
Ψ(x, y, z) = (Ψx(x, y, z), Ψy(x, y, z), Ψz(x, y, z)).
The divergence of Ψ is
div(Ψ) = ∂Ψx(x, y, z)
∂x
+ ∂Ψy(x, y, z)
∂y
+ ∂Ψz(x, y, z)
∂z
.
Let X be a compact volume with piecewise-smooth boundary ∂X. The divergence
theorem is

X
div(Ψ)dX =

S=∂X
Ψ · n dS,
where n is the unit normal vector to S that points away from X. The divergence
theorem is a special case of Stoke’s theorem.
When Ψ is the gradient vector ﬁeld ∇φ = ( ∂φ
∂x, ∂φ
∂y , ∂φ
∂z ) of a continuously
diﬀerentiable scalar ﬁeld φ : R3 →R and X equals {x : φ(x) ≥σ}, the divergence
theorem becomes

X=φ−1([σ,∞])
div(∇φ)dX =

S=φ−1(σ)
|∇φ| dS.

11.3. Measuring Gradients
373
The divergence of the gradient of φ is called the Laplacian of φ and is denoted
Δφ. The Laplacian can also be deﬁned directly as
Δφ = ∂2φ
∂x2 + ∂2φ
∂y2 + ∂2φ
∂z2 .
Using the Laplacian, the divergence theorem becomes

X=φ−1([σ,∞])
ΔφdX =

S=φ−1(σ)
|∇φ| dS.
(11.1)
Pekar, Wiemker, and Hempel [Pekar et al., 2001] used the Laplacian and
Equation (11.1) to compute total and mean gradients over a level set. Let VΓ be
the set of grid vertices of grid Γ. Deﬁne TotalGradL(σ) as
TotalGradL(σ) =

p∈VΓ
φ(p)≥σ
Δφ(p).
If {si : i = 0, . . . , k} are k + 1 scalar values in increasing order, then
TotalGradL(si) = TotalGradL(si+1) +

p∈VΓ
si≤φ(p)<si+1
Δφ(p).
(11.2)
Algorithm 11.1 applies Equation (11.2) to compute TotalGradL.
Computing TotalGradL requires computing the Laplacian at grid points
(ix, iy, iz). The partial second derivatives can be computed by the formulas [Che-
ney and Kincaid, 2007]
∂2φ
∂x2 (ix, iy, iz)
=
φ(ix −1, iy, iz) −2φ(ix, iy, iz) + φ(ix + 1, iy, iz),
∂2φ
∂y2 (ix, iy, iz)
=
φ(ix, iy −1, iz) −2φ(ix, iy, iz) + φ(ix, iy + 1, iz),
∂2φ
∂z2 (ix, iy, iz)
=
φ(ix, iy, iz −1) −2φ(ix, iy, iz) + φ(ix, iy, iz + 1).
Note that these formulas only work for points at the grid interior. The Laplacian
is computed by summing the three partial derivatives. (See Algorithm 11.2.)
The running time of Algorithm 11.1 depends upon the time to divide the
interior grid vertices into bins (Step 1). If the scalar values in S are spaced at
regular intervals, then the bin containing a grid vertex can be determined in
constant time and Step 1 takes time proportional to the number of grid vertices.
The rest of the algorithm takes time proportional to the number of grid vertices.

374
11. Isovalues
Input
: F is a 3D array of scalar values.
S is an array of scalar values in increasing order.
k is the index of the last element of array S.
Result
: An array G where G[i] is total gradient of the isosurface with
isovalue S[i].
LaplacianTotalGradient(F,Coord,S)
1 Divide the interior grid vertices (ix, iy, iz) into k bins where:
• (ix, iy, iz) ∈Bin[j] for j < k if S[j] ≤F[ix, iy, iz] < S[j + 1], and
• (ix, iy, iz) ∈Bin[k] if S[k] ≤F[ix, iy, iz];
2 G[k] ←0;
3 foreach interior grid vertex (ix, iy, iz) ∈Bin[k] do
4
G[k] ←G[k]+Laplace(F, ix, iy, iz);
5 end
6 for j ←k −1 downto 0 do
7
G[j] ←G[j + 1];
8
foreach interior grid vertex (ix, iy, iz) ∈Bin[j] do
9
G[j] ←G[j]+Laplace(F, ix, iy, iz);
10
end
11 end
Algorithm 11.1. LaplacianTotalGradient.
Input
: F is a 3D array of scalar values.
Coordinates ix, iy and iz of an interior grid point.
Output
: The Laplacian of F at (ix, iy, iz).
Laplace(F, ix, iy, iz)
1 ddx ←F[ix −1, iy, iz] −2F[ix, iy, iz] + F[ix + 1, iy, iz];
2 ddy ←F[ix, iy −1, iz] −2F[ix, iy, iz] + F[ix, iy + 1, iz];
3 ddz ←F[ix, iy, iz −1] −2F[ix, iy, iz] + F[ix, iy, iz + 1];
4 L ←ddx + ddy + ddz;
5 return L;
Algorithm 11.2. Laplace.
Algorithm 11.1 ignores the Laplacian of vertices on the grid boundary. A
modiﬁed formula could be used to compute the Laplacian of boundary vertices,
but in practice the Laplacian of the boundary vertices has little eﬀect on the
sum.
TotalGradL(σ) approximates the total gradient 
S=φ−1(σ) |∇φ|dS. Note that
this contrasts with TotalGrade(σ) and TotalGradc(σ), which approximate the
total gradient only up to some constant factor. (See Figure 11.20.)

11.3. Measuring Gradients
375
 0.0001
0.001
0.01
0
50
100
150
200
250
Total gradient (edge based)
Total gradient (cube based)
Total gradient (Laplacian)
0.0001
0.001
0.01
0
50
100
150
200
250
Total gradient (edge based)
Total gradient (cube based)
Total gradient (Laplacian)
(a) Total gradient.
(b) Normalized values.
Figure 11.20.
Engine data set.
(a) Functions TotalGrade,
TotalGradc, and
TotalGradL. Function TotalGradL is the Laplacian-based approximation for the total
gradient. (b) Normalized versions: TotalGrad∗
e, TotalGrad∗
c, and TotalGrad∗
L.
The normalized version of TotalGradL, the Laplacian-based computation of
the mean gradient, and its normalized version are
TotalGrad∗
L(σ)
=
TotalGradL(σ)
α k
i=0 TotalGradL(si)
,
MeanGradL(σ)
=
TotalGradL(σ)
Fe(σ)
,
MeanGrad∗
L(σ)
=
MeanGradL(σ)
α k
i=0 MeanGradL(si)
.
Equation 11.1 still holds if φ is deﬁned on some subset D of R3 as long as
X = {x ∈D : φ(x) ≥σ} is bounded by φ−1(σ). However, if the level set φ−1(σ)
has a boundary, then it no longer bounds X. Thus, TotalGradL(σ) is not a good
measure of the total gradient of isosurfaces with boundary. (It is also not a good
measure if the points {p ∈VΓ : φ(p) ≥σ} lie between the isosurface and the grid
boundary.)
For example, Figure 11.21(a) contains a plot of TotalGrade and TotalGradL
for the Gaussian function φ(x, y, z) = e−(x2+y2+z2)/2 over the domain D =
{(x, y, z) : −1 ≤x, y, z ≤1}.
Note that TotalGrade(σ) and TotalGradL(σ)
agree for σ > 0.6 but diverge drastically when σ < 0.6. (The actual point of
divergence is σ = e−1/2 ≈0.6065.) The reason that TotalGradL diverges from
the total gradient for σ < 0.6 is that isosurfaces with isovalue σ intersect the
grid boundary and no longer “contain” the set {p ∈VΓ : φ(p) ≥σ}.

376
11. Isovalues
0
200
400
600
800
1000
1200
1400
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Total gradient (edge based)
Total gradient (Laplacian)
(a) Total gradient.
(b) Isosurface (isovalue 0.55).
Figure 11.21. Gaussian function φ(x, y, z) = e−(x2+y2+z2)/2 for −1 ≤x, y, z ≤1. (a)
TotalGrade and TotalGradL. (b) Isosurface for isovalue 0.55. The boundaries of the
isosurface lie on the bounding box of the grid.
11.4
Notes and Comments
Bajaj, Pascucci, and Schikore [Bajaj et al., 1997] suggested plotting isosurface
metrics as a function of isovalue and using those metrics to select isovalues. They
call the set of computed metrics the contour spectrum of the scalar ﬁeld. Pekar
et al. [Pekar et al., 2001] gave the algorithm in Section 11.3.2 for computing the
total and mean gradients using the Laplacian.
Carr, Duﬀy, and Denby [Carr et al., 2006a] and Scheidegger et al. [Scheidegger
et al., 2008] analyze the relationship between histograms of scalar values and
isosurface area. Duﬀy, Carr, and Moller [Duﬀy et al., 2012] discuss the eﬀects
of quantization of the scalar values associated with grid or mesh vertices on
computing isosurface statistics.
Scheidegger et al. [Scheidegger et al., 2008] and Bachthaler and Weiskopf
[Bachthaler and Weiskopf, 2008] relate the isosurface area to the interval volume
based on the coarea formula by Federer.
(See [Morgan, 2009] for a thorough
explanation of the formula.) The formula relates the integral over an interval
volume to an integral over a range of level sets. The coarea formula is

x∈Iφ(σ0,σ1)
ψ(x)|∇φ(x)|dV =

σ0≤h≤σ1
	
x∈φ−1(h)
ψ(x)dS

dh,
where φ and ψ are functions from R3 to R and Iφ(σ0, σ1) is the interval volume
between σ0 and σ1 and |∇φ(x)| is the magnitude of the gradient of φ. The term
on the left of the equal sign integrates ψ directly over the entire volume while
the term on the right integrates ψ over the isosurfaces φ−1(h). The formula

11.4. Notes and Comments
377
indicates that a scaling factor of |∇φ(x)| must be used in transforming from an
integral over the volume to an integral over isosurfaces.
Instead of representing attributes as a function of scalar value, one could
compute two (or more) attributes for each grid vertex or cube and plot these
attributes as points. For instance, plot the point (smin(c), smax(c)) for each grid
cube c. For another example, let sv be the scalar value and let gv be the gradient
at grid vertex v. Plot (sv, gv) for each grid vertex v. Such plots are called scatter
plots. For large data sets, it is necessary to subsample the data set before creating
the scatter plot.
Scatter plots are simply collection of points. It is often hard to see structure in
such collections of points. Bachthaler and Weisskopf [Bachthaler and Weiskopf,
2008, Bachthaler and Weiskopf, 2009] describe a continuous version of scatter
plots for scalar data sets that often gives better insight into the data set.
Tenginakai et al. [Tenginakai et al., 2001, Tenginakai and Machiraju, 2002]
compute moments of scalar values in windows around grid vertices. They use
such moments to determine scalar values near boundary regions in the data set.
Such scalar values are good candidates for isovalues.
Pekar et al. in [Pekar et al., 2001] suggest comparing isovalues by computing
the fractal dimension of the correspoinding isosurfaces.
Khoury and Wenger
[Khoury and Wenger, 2010] give a simple way for computing the isosurface fractal
dimension. They show that the isosurface fractal dimension is correlated with
noise in the isosurface and inversely correlated with the gradient magnitude.
Plotting the fractal dimension as a function of the isovalue gives another graph
of isovalue properties and another way to look for signiﬁcant isovalues.
Bruckner and M¨oller [Bruckner and M¨oller, 2010] compute the similarity be-
tween isosurfaces for diﬀerent isovalues. This computation can be used to identify
stable isovalues where small perturbations in the isovalue will not substantially
change the isosurface. It also identiﬁes ranges of isovalues that generate similar
isosurfaces.
Marschner and Lobb [Marschner and Lobb, 1994] suggested the function in
Figure 11.9 for evaluating surface reconstruction algorithms. The Marschner-
Lobb data set is a sampling of this function.

This page intentionally left blank
This page intentionally left blank

CHAPTER 12
CONTOUR TREES
Let φ : D →R be a continuous scalar ﬁeld where D is a rectangular region in
Rd. More generally, D is homeomorphic to a closed ball in Rd. A connected
component of a level set φ−1(σ) is a maximally connected subset of φ−1(σ),
i.e., a connected subset of φ−1(σ) that is not contained in any other connected
subset of φ−1(σ). As σ changes, the connected components of φ−1(σ) change.
New components appear, existing components disappear, multiple components
join together to form one component, or a single component splits apart into
multiple components. A contour tree is a graph that represents these components
and their changes.
In this chapter, we present an elegant algorithm by Carr, Snoeyink, and
Axen [Carr et al., 2003] for constructing the contour tree of a piecewise linear
scalar ﬁeld deﬁned by a tetrahedral mesh. The algorithm constructs a “join” tree
representing the joining of contours and a “split” tree representing the splitting
of contours, and then the algorithm combines the two trees into a “merge” tree.
This merge tree is equivalent to the contour tree.
Section 12.2 contains a formal deﬁnition of contour trees and some contour
tree properties. Section 12.3 gives the deﬁnition of join, split, and merge trees.
Section 12.4 presents algorithms for constructing the join, split, and merge trees.
Section 12.5 presents algorithms for constructing contour trees from tetrahedral
meshes and from regular grids. Proofs of all propositions are contained in Sec-
tion 12.6.
12.1
Examples of Contour Trees
The standard, intuitive deﬁnition of a contour tree for a scalar ﬁeld φ : D →R
is as follows. Collapse each connected component of each level set φ−1(σ) into a
single point. The resulting “graph” is a contour tree.
379

380
12. Contour Trees
–0.2
0
0.2
0.4
0.6
0.8
1
p1
p2
p3
p4
p5
Figure 12.1. Contour lines for a scalar ﬁeld φ : D →R.
Domain D is the region
bounded by the outermost contour. Point p1 is a local minimum. Points p4 and p5 are
local maxima. Connected components of contours are joined at point p2 and split at
point p3. The outermost contour is also a local minimum.
–0.
0
0.2
0.4
0.6
0.8
1
p1
p2
p3
p4
p5
c2
c1
c2
c3
c4
c5
c6
(a) Contour lines.
(b) Contour tree.
Figure 12.2. (a) Contour lines lifted into 3D. (b) Vertices c1, c4, and c5 correspond
to points p1, p4, and p5, respectively. Vertices c2 and c3 correspond to the contour
lines through p2 and p3, respectively. Vertex c6 corresponds to the outermost contour,
which is the boundary of D.

12.1. Examples of Contour Trees
381
For instance, Figure 12.1 contains contours of the function
φ(x, y) =e−(x2+y2) + (2/3)e−5((x−1)2+(y+1)2) −(2/3)e−5((x+0.5)2+(y+0.6)2).
(12.1)
Set D is the region bounded by the outermost contour.
The scalar function
φ forms a surface {(x, y, φ(x, y))} in R3. Figure 12.2(a) displays a plot of the
contours on that surface.
Collapsing the connected components of the contours of φ into level sets gives
the contour tree in Figure 12.2(b). The collapse is perhaps best visualized by
comparing Figure 12.2(a) with Figure 12.2(b). The connected components on
the horizontal plane z = σ map to points at height σ in the contour tree.
For isovalues in the range [-0.8,0.06], the isocontour has two components,
one around the point p1 and one near the boundary of the domain D. Contour
tree edge (c1, c2) corresponds to the isocontours around p1. Contour tree edge
(c6, c2) corresponds to the isocontours near ∂D. These two components join at
scalar value 0.06. The isocontour at scalar value 0.06 passes through point p2.
Edges (c1, c2) and (c6, c2) join at contour tree vertex c2. Contour tree vertex c2
corresponds to the isocontour passing through point p2.
For isovalues in the range [0.06,0.6], the isocontour has one component. Con-
tour tree edge (c2, c3) corresponds to this set of isocontours. At scalar value 0.6,
this component splits into two components, one around point p4 and one around
point p5. The isocontour at scalar value 0.6 passes through point p3. Similarly,
contour tree edge (c2, c3) splits at c3 into edge (c3, c4) and edge (c3, c5). Contour
tree vertex c3 corresponds to the isocontour through point p3. Contour tree edge
(c3, c4) corresponds to the isocontours around p4 and contour tree edge (c3, c5)
corresponds to the isocontours around p5.
For a 3D example, Figure 12.3(a) contains the contour tree for the hydrogen
atom data set.1
Each node corresponds to a connected component in some
isosurface. The values inside the nodes correspond to the scalar value of the
connected components. In this data set, connected components only split apart,
they never join together.
For isovalues in the range [0,12], the isosurface consists of two components
(Figure 12.3(b)). One of these components is a torus, while the other is two
spheres connected by a tube through the torus. At isovalue 12, the component
of two spheres connected by a tube splits into three parts. For isovalues in the
range [12,36], the isosurface has four components (Figure 12.3(c)). At isovalue
50, the torus disappears, leaving three connected components (Figure 12.3(d)).
1The hydrogen atom data is “a simulation of the probability distribution of the electron in
a hydrogen atom residing in a strong magnetic ﬁeld” (www.volvis.org).

382
12. Contour Trees
0
12
36
80
80
250
(a) Contour tree.
(b) Isovalue 8.
(c) Isovalue 20.
(c) Isovalue 50.
Figure 12.3. (a) Contour tree (simpliﬁed) of the hydrogen atom data set. (Two tree
nodes representing artifacts in the data set were removed.) (b) Isosurface for isovalue
8, which has two connected components. (The two spheres at either end are connected
by a tube throught the center of the torus and form a single component.) (c) Isosurface
for isovalue 20, which has four connected components. (d) Isosurface for isovalue 50,
which has three connected components.
As another 3D example, Figure 12.4(a) contains a simpliﬁed version of the
contour tree for the nucleon data set.2 In this data set, connected components
only join together; they never split apart.
For isovalues in the range [13,103], the isosurface consists of three com-
ponents, a sphere containing two other spheres (Figure 12.4(b)). At isovalue
103, one of the inner spheres joins the outer sphere. For isovalues in the range
[103,161], the isosurface has two components (Figure 12.4(c)). At isovalue 161,
the two components merge into a single component (Figure 12.4(d)).
2The nucleon data is a “simulation of the two-body distribution probability of a nu-
cleon in the atomic nucleus 160 if a second nucleon is known to be positioned at
r′ = (2 fm, 0.0)” (www.volvis.org).

12.2. Deﬁnition of Contour Tree
383
0
103
0
161
13
249
(a) Contour tree.
(b) Isovalue 90.
(c) Isovalue 110.
(c) Isovalue 170.
Figure 12.4. (a) Simpliﬁed contour tree of the nucleon data set. (b) Clipped view of
isosurface for isovalue 90. Isosurface has three connected components. (c) Clipped view
of isosurface for isovalue 110. Isosurface has two connected components. (d) Clipped
view of isosurface for isovalue 170. Isosurface has one connected component.
12.2
Deﬁnition of Contour Tree
While the description of contour trees based on collapsing connected components
to points is quite intuitive, the formal deﬁnition requires using equivalence classes
and topological quotients. Moreover, while the resulting set has the appearance
of a graph, formally deﬁning the vertices and edges of that graph can be tricky.
A diﬀerent way of viewing contour trees is as a tree whose vertices are a set
of connected components of contours. Tree edges represent the containment or
nesting of one contour component inside another. Such a tree is called a nesting
diagram. We will give a formal deﬁnition of contour trees based on this approach.
This deﬁnition will be used throughout this chapter.

384
12. Contour Trees
-0.2
 0
 0.2
 0.4
 0.6
 0.8
 1
p1
p2
p3
p4
p5
p6
p7
p8
p9
p10
p11
p12
Figure 12.5. Contour lines for a scalar ﬁeld φ : D′ →R where domain D′ is the
rectangle region [−1.3 : 1.4] × [−2 : 1.5]. Points p1, p9, p10, p11, and p12 are local
minima. Points p4 and p5 are local maxima. Connected components of contours are
joined at points p2, p6, and p8 and split at point p3.
p1
p2
p3
p4
p5
p6
p7
p8
p9
p10
p11
p12
c1
c2
c3
c4
c5
c6
c7
c8
c9
c10
c11
c12
(a) Contour lines.
(b) Contour tree.
Figure 12.6.
(a) Critical connected components of the scalar ﬁeld in Figure 12.5.
(b) Vertices c1, c4, c5, c9, c10, c11, and c12 correspond to points p1, p4, p5, p9, p10, p11,
and p12, respectively. Vertices c2, c3, c6, c7, and c8 correspond to the contour lines
through p2, p3, p6, p7, and p8, respectively.

12.2. Deﬁnition of Contour Tree
385
–0.2
0
0.2
0.4
0.6
0.8
1
p1
p2
p3
p4
p5
Figure 12.7. Critical connected components of the scalar ﬁeld in Figure 12.1.
To represent changes in level set components, we need to identify components
where changes occur. Let φ : D →R be a continuous scalar ﬁeld. A connected
component λ of a level set of φ is a local minimum if φ(p) ≥φ(λ) for every point p in
a suﬃciently small neighborhood of λ. Component λ is a local maximum if φ(p) ≤
φ(λ) for every point p in a suﬃciently small neighborhood of λ. Typically, local
minima and local maxima are single points, although they could be arbitrary
connected sets.
For example, point p1 in Figure 12.1 is a local minimum.
Points p4 and
p5 are local maxima. The boundary of the domain D is also a local minimum
since φ : D →R is locally minimal on its boundary. A diﬀerent domain with a
diﬀerent boundary would have a diﬀerent local minimum.
A connected component λ of a level set is regular if λ is not a local minimum or
local maximum and D −λ has exactly two connected components. Component
λ is critical if it is not regular.3
Figure 12.7 contains the critical connected
components of the level sets of φ : D →R.
The critical components depend upon the domain D.
If the domain D
changes, then the critical connected components of φ : D →R change.
In
Figure 12.1, the domain D is bounded by a contour. In Figure 12.5, the function
φ is the same, but the domain D′ is the rectangular region [−1.3 : 1.4]×[−2 : 1.5].
Each of the corners of D′ are local minima. For instance, p9 is the lower-left cor-
ner of D′. There is a small neighborhood Np9 ⊂D′ of p9, such that φ(p) ≥φ(p9)
for every point p ∈Np9. Note that Np9 is restricted to D′. Set Np9 is not a
neighborhood of p9 within R2, only within rectangle D′.
In Figure 12.5, the components of level sets through points p6, p7, and p8
partition D′ into three separate pieces. Thus these level set components are also
3This usage of the terms regular and critical is diﬀerent from the usage in diﬀerential
geometry and Morse theory, although the regular level sets deﬁned here play a similar role to
the regular and critical sets in diﬀerential geometry.

386
12. Contour Trees
p1
p2
p3
p4
p5
(a)
p1
p2
p3
p4
p5
(b)
c1
c2
c3
c4
c5
(c)
Figure 12.8. Contour lines for a scalar ﬁeld φ : D′′ →R where domain D′′ is the
rectangle region [−1.3 : −0.4]× [−2 : 0.0]. Function φ is given by equation 12.1. Points
p1, p3, and p4 are local minima. Point p4 is a local maximum. Connected components
of contours are joined at point p2.
critical. However, when φ is deﬁned over D, these components separate D into
two pieces and are regular.
Another example is provided in Figure 12.8. The function φ is the same as
before but the domain D′′ is the rectangle [−1.3 : −0.4] × [−2 : 0.0]. Corner
point p4 is a local minimum and corner point p5 is a local maximum. The two
other corner points are not minima or maxima. Point p3 on the boundary of D
is also a local minima.
A set of connected components induces a graph whose vertices correspond to
the connected components.
Deﬁnition 12.1. Let Σ be a closed subset of D and let Λ be the set of connected
components of Σ. Set Λ induces graph G if
1. for each connected component λ ∈Λ, graph G has a vertex vλ;
2. graph G has edge (vλ, vλ′) if λ and λ′ are both on the boundary of some
connected component μ of D −Σ.

12.2. Deﬁnition of Contour Tree
387
λ1
λ2
λ3
λ4
λ5
λ6
λ7
c1
c2
c3
c4
c5
c6
c7
(a) Connected components.
(b) Induced graph.
Figure 12.9. (a) Connected components, λ1, λ2, . . . , λ7. Component λ6 is the union
of a circle and an ellipse. (b) Graph induced by set Λ = {λ1, . . . , λ7}. Note that the
graph is not a tree.
For instance, in Figure 12.9(a) set Λ is the set of points and curves {λ1, . . . , λ7}.
Set Σ is the union, ∪iλi, of the elements of Λ. If D is the region bounded by λ7,
then D −Σ is the white space between the points and curves in Figure 12.9(a).
Set Λ induces the graph in Figure 12.9(b).
We will let Λ be some connected components of level sets of some function
φ : D →R. In general, the graph G induced by Λ is not a tree. However, under
appropriate conditions, G is a tree.
Proposition 12.2. Let φ : D →R be a continuous scalar ﬁeld and let Λ be some
of the connected components of level sets of φ. If
1. D is homeomorphic to an open or closed ball in Rd,
2. Λ contains all the critical connected components of level sets of φ,
then the graph G induced by Λ is a tree.
The proof is in Section 12.6.1.
If Λ equals the set of critical connected components of the level set of φ and
contains no other components, then we call the graph induced by Λ the contour
tree of φ.
Deﬁnition 12.3. Let D ⊂Rd be a region homeomorphic to an open or closed ball
in Rd. The contour tree of a continuous function φ : D →R is the graph induced
by the set of critical connected components of the level sets of φ.
Figure 12.6(b) is an example of a contour tree. Each tree vertex corresponds
to a critical connected component in Figure 12.6(a).
The critical connected

388
12. Contour Trees
0
0.2
0.4
0.6
0.8
1
–2
–1.
–1
–0.
0
 0.5
1
 1.5
–2
–1
0
1
p1
p2
p2
p2
p3
p3
p4
p5
p5
p5
p6
p7
p8
p9
p10
p11
p12
p13
p14
p15
p16
Figure 12.10. Contour lines for the scalar ﬁeld φ′ : D →R where the domain D is
[−2.25, 2]×[−2.5, 3]. Function φ′ is given by equation 12.2. Points p3, p6, p10, p12, p14,
and p16 are local minimum. Points p2, p8, and p9 are local maxima. Contour lines join
together or split apart at points p1, p4, p5, p7, p11, p13, and p15.
components lie on the boundary of white regions in Figure 12.6(a). Two ver-
tices in the contour tree are connected by an edge if the corresponding critical
connected components lie on the boundary of the same white region.
Another example of a contour tree is in Figure 12.8(c). Contour tree ver-
tex c2 corresponds to a critical connected component through point p2, which
bounds four separate white regions. (See Figure 12.8(b).) Therefore, vertex c2
is connected to four other vertices in the contour tree.
The contour trees constructed so far have been fairly simple. Figures 12.10
and 12.11 contain an example of a slightly more complicated contour tree. The
function to generate this contour tree is
φ′(x, y)
=
e−(x2+y2) +
1
2

e−10((x−1)2+(y−1)2) +
1
8

e−10((x+1.2)2+(y−2)2)
−
1
3

e−10((x+0.9)2+y2)) −
1
2

e−10((x−0.1)2+(y+0.1)2).
(12.2)
Let Λ be some connected components of level sets of φ : D →R. When
Λ properly contains the set of critical connected components of φ, the graph
induced by Λ is called the augmented contour tree of φ.

12.3. Join, Split, and Merge Trees
389
-2
-1.5
-1
-0.5
 0
 0.5
 1
 1.5
 2
-2
-1
0
1
2
3
p1
p2
p3
p4
p5
p6 p7
p8
p9
p10
p11
p12
p13
p14
p15
p16
c1
c2
c3
c4
c5
c6
c7
c8
c9
c10
c11
c12
c13
c14
c15
c16
(a) Critical connected components.
(b) Contour tree.
Figure 12.11. (a) Critical connected components of level sets of φ′ : D →R where the
domain D is [−2.25, 2] × [−2.5, 3]. (b) Contour tree of φ′ : D →R.
Deﬁnition 12.4. Let D ⊂Rd be a region homeomorphic to an open or closed
ball in Rd. The augmented contour tree of a continuous function φ : D →R is
the graph induced by a set of connected components of the level sets of φ that
properly contains the set of critical connected components of the level sets of φ.
Since regular connected components of the level sets of φ split D exactly into
two components, an augmented contour tree is a subdivision of a contour tree
of φ.
The following sections describe how to build a contour tree for a piecewise
linear function determined by a simplicial mesh.
12.3
Join, Split, and Merge Trees
A contour tree can be “decomposed” into two trees, a “join tree” representing
contours that join together and a “split tree” representing contours that split
apart as the scalar value increases.
Conversely, the join and split trees of a
contour tree can be “merged” to reconstruct the contour tree.
Join and split trees are deﬁned for any graph with scalar values at the vertices,
not just for contour trees. This section contains deﬁnitions and properties of join
and split trees. In Section 12.4.1, we describe how to construct join and split
trees and in Section 12.4.2 we present an algorithm for merging join and split
trees of a contour tree.

390
12. Contour Trees
39
64
53
66
16
32
25
45
62
51
58
30
v1
v2
v3
v4
v5
v6
v7
v8
v9
v10
v11
v12
a1
a2
a3
a4
a5
a6
a7
a8
a9
a10
a11
a12
b1
b2
b3
b4
b5
b6
b7
b8
b9
b10
b11
b12
c1
c2
c3
c4
c5
c6
c7
c8
c9
c10
c11
c12
(a) Scalar graph G.
(b) Join tree.
(c) Split tree.
(d) Merge tree.
Figure 12.12. (a) Scalar values are written inside the circles representing the vertices.
Blue vertices v5, v10, and v12 are local minima. Magenta vertices v2, v4, and v9 are
local maxima. Light green vertex v11 joins two sets of vertices. Dark green vertex v6
splits two sets of vertices. Green vertex v8 both joins and splits sets of vertices. White
vertices are neither local minima nor local maxima and do not join or split any sets of
vertices. (b) Join tree TJ of G. (c) Split tree TS of G. Note that the root b5 of the split
tree is drawn at the bottom and the leaves are drawn at the top. (d) Merge tree of TJ
and TS and of the scalar graph G.
12.3.1
Join and Split Trees
A scalar graph is a graph where each node has a scalar value.4 (See Figure 12.12.)
A scalar tree is a scalar graph which is a tree. Note that a contour tree is a scalar
tree.
A distinct valued graph is a scalar graph where no two nodes have the same
scalar value.
We deﬁne join and split trees on distinct valued graphs.
Let G be a connected, distinct valued graph on n vertices, {v1, v2, . . . , vn}. Let
G−(s) be the subgraph of G induced by vertices whose scalar values are less than
s. A connected component of G−(s) is a maximally connected induced subgraph
of G−(s).
(See Appendix C.)
As s increases, new connected components of
G−(s) appear and multiple components join together to form one component.
Components of G−(s) do not disappear and do not split apart. The join tree of
G represents the connected components of G−(s) as a function of s.
For notational convenience, let G−(vi) be G−(vi.scalar) where vi is a vertex
of G and vi.scalar is the scalar value of vi. Vertex vi is connected to a connected
component of G−(vi) if there is an edge between vi and some vertex of G−(vi).
4Scalar graphs are called “height graphs” by Carr et al. in [Carr et al., 2003].

12.3. Join, Split, and Merge Trees
391
39
64
66
16
32
25
45
62
51
58
53
30
v1
v2
v3
v4
v5
v6
v7
v8
v9
v10
v11
v12
39
64
66
16
32
25
45
62
51
58
53
30
v1
v2
v3
v4
v5
v6
v7
v8
v9
v10
v11
v12
39
64
66
32
16
25
62
51
58
53
45
30
v1
v2
v3
v4
v5
v6
v7
v8
v9
v10
v11
v12
(a) Join at v11.
(b) Split at v6.
(c) Join and split at v8.
Figure 12.13.
Examples of joins and splits.
The join or split vertex is colored
green. Blue vertices have scalar value below the join or split vertex. Magenta ver-
tices have scalar values above the join or split vertex. (a) Vertex v11 joins vertex v10
to vertices {v1, v3, v5, v6, v8, v12}. (b) Vertex v6 splits vertices {v2, v3} from vertices
{v4, v7, v8, v9, v10, v11}. (c) Vertex v8 joins vertices {v1, v5, v6} to vertex v12 and splits
vertex v9 from {v4, v7, v10, v11}.
Deﬁnition 12.5. The join tree of G is a tree with a vertex ai that corresponds to
each vertex vi of G. Vertex ai is a child of vertex aj in the join tree of G if
1. vertex vj is connected to some connected component λ of G−(vj),
2. vertex vi is the vertex of λ with maximum scalar value.
For instance, in Figure 12.13(a), vertices v1, v3, v5, v6, v8, v10, and v12 have scalar
values less than v11. Vertices v1, v3, v5, v6, v8, and v12 form one component while
vertex v10 forms another. Vertex v3 has the highest scalar value in its component
so a3 is a child of a11. Similarly, vertex v10 has the highest scalar value in its
component and so a10 is a child of a11. The join tree is given in Figure 12.13(b).
The number of children of vertex aj corresponds to the number of connected
components of G−(vj) that join together at vj. The root ar of the join tree
corresponds to the vertex vr of G with the highest scalar value.
Since G is
connected, vertex vr is connected to every connected component of G−(vr).
Let G+(s) be the subgraph of G induced by vertices whose scalar values are
greater than s. As s increases, connected components of G+(s) disappear and
single components split apart to form multiple components.
Components of
G+(s) do not appear and do not split apart. The split tree of G represents the
connected components of G+(s) as a function of s.
Let G+(vi) be G+(vi.scalar) where vi is a vertex of G and vi.scalar is the scalar
value of vi. Vertex vi is connected to a connected component of G+(vi) if there
is an edge between vi and some vertex of G+(vi).

392
12. Contour Trees
c1
c2
c3
c4
c5
c6
c7
c8
c9
c10
c11
c12
c13
c14
c15
c16
a1
a2
a3
a4
a5
a6
a7
a8
a9
a10
a11
a12
a13
a14
a15
a16
b1
b2
b3
b4
b5
b6
b7
b8
b9
b10
b11
b12
b13
b14
b15
b16
(a) Contour tree.
(b) Join tree.
(c) Split tree.
Figure 12.14. The contour tree from Figure 12.11 and its join and split trees. Vertex
a9 is the root of the join tree. Vertex b14 is the root of the split tree.
Deﬁnition 12.6. The split tree of G is a tree with a vertex bi that corresponds to
each vertex vi of G. Vertex bi is a child of vertex bj in the split tree of G if
1. vertex vj is connected to some connected component λ of G+(vj),
2. vertex vi is the vertex of λ with minimum scalar value.
In Figure 12.13(b), vertices v2, v3, v4, v7, v8, v9, v10, and v11 have scalar values
greater than v6. Vertices v2 and v3 form one connected component while vertices
v4, v7, v8, v9, v10, v11 form another. Since vertex v3 has the lowest scalar value in
its component, vertex b3 is a child of b6 in the split tree. Similarly, v8 has the
lowest scalar value in its component, so b8 is also a child of b6. The split tree is
given in Figure 12.12(c).
The number of children of vertex bj corresponds to the number of connected
components of G+(vj) that are connected to vj. The root br′ of the split tree
corresponds to the vertex vr′ of G with the lowest scalar value.
Since G is
connected, vertex vr′ is connected to every connected component of G+(vr′).
A vertex can both split and join sets of vertices.
For instance, in Fig-
ure 12.13(c), vertex v8 joins vertices v1, v5, and v6 to vertex v12.
Vertex v8
also splits vertices v4, v7, v10, and v11 from vertex v9. Thus, in Figure 12.12,
vertex a8 has two children in the join tree and vertex b8 has two children in the
split tree.

12.3. Join, Split, and Merge Trees
393
v1
v2
v3
v4
v5
v6
10
40
70
60
80
50
a1
a2
a3
a4
a5
a6
b1
b2
b3
b4
b5
b6
(a) Scalar graph.
(b) Join tree.
(c) Split tree.
Figure 12.15. (a) A scalar graph G with no merge tree. Scalar values are written inside
the circles representing the vertices. (b) Join tree of G. (c) Split tree of G.
As previously noted, a contour tree TC is a scalar graph. If TC is distinct
valued, then it has join and split trees. For instance, Figure 12.14 presents the
join and split trees of the contour tree from Figure 12.11.
The join tree of a contour tree represents connected components of level
sets that join together as the scalar value increases. The split tree represents
connected components of level sets that split apart.
12.3.2
Merge Trees
Let TJ and TS be the join and split trees of some connected, distinct valued
graph G.
Deﬁnition 12.7. The merge tree of TJ and TS is a scalar tree TM such that TJ and
TS are join and split trees of TM. The merge tree of a scalar graph G is the merge
tree of its join and split trees.
Figure 12.12 contains an example of a merge tree.
Not every graph G has a merge tree. For instance, Figure 12.15 contains a
graph G and its join tree TJ and split tree TS. There is no tree T such that TJ
and TS are the join and split trees of T . (See Section 12.6.3 for an explanation
of why there is no such T for this graph.) Note that graph G in Figure 12.15 is
the vertices and edges of a regular grid.
If a pair of join and split trees have a merge tree, then that merge tree is
unique.
Proposition 12.8. If TJ and TS are the join and split trees, respectively, of two
trees, T and T ′, then T is isomorphic to T ′.
(See Appendix C for a deﬁnition of graph isomorphism.) The proof is in Sec-
tion 12.6.
A scalar simplicial mesh is a simplicial mesh with a scalar value associated to
each vertex. Simplicial mesh Γ determines a piecewise linear function φ that is

394
12. Contour Trees
linear in each simplex of the mesh. (See Appendix B.7.) Let λ be the connected
components of levels sets of φ that contain the vertices of Γ. Since level sets
only merge or split at mesh vertices, set λ contains all the critical connected
components of level sets of φ. Let TC be the augmented contour tree of φ induced
by λ. We call TC the augmented contour tree of scalar simplicial mesh Γ.
A scalar simplicial mesh, Γ, is distinct valued if no two mesh vertices have the
same scalar value. The 1-skeleton of a scalar simplicial mesh is the scalar graph
consisting of the vertices and edges of Γ. The augmented contour tree of Γ is
the merge tree of its 1-skeleton.
Proposition 12.9. Let Γ be a distinct valued simplicial mesh covering a rectangu-
lar region in Rd. If G is the 1-skeleton of Γ, then the augmented contour tree of
Γ is the merge tree of G.
In the next section, we describe an algorithm for constructing the merge tree
of TS and TJ. By Proposition 12.9, this merge tree is the augmented contour
of G.
12.4
Constructing Join, Split, and Merge Trees
In this section, we present algorithms by Carr, Snoeyink, and Axen [Carr et al.,
2003] for constructing the join, split, and merge trees of a graph G. To construct
the join tree of a graph G, sort the vertices of G by increasing scalar value,
“grow” G by adding vertices one at a time in order, and add edges to the join tree
whenever two connected components in G are joined together. Do the same to
construct the split tree of G, except that the vertices are processed by decreasing
scalar value. Combine the join and split trees of G into the merge tree by pruning
leaves from the join or split trees and adding corresponding leaves to the merge
tree.
Section 12.4.1 contains the algorithms for constructing the join and split
trees. Section 12.4.2 contains the algorithm for constructing the merge tree and
some properties from [Carr et al., 2003] that form the basis of the algorithm.
12.4.1
Constructing Join and Split Trees
To construct a join tree, we must be able to detect when two sets of mesh vertices
are joined by a vertex v. Fortunately, there is an eﬃcient union-ﬁnd data structure
for detecting the union of disjoint sets. A union-ﬁnd data structure supports an
operation union, which forms the union of two sets, and the operation ﬁnd, which
ﬁnds a representative element of a set. Eﬃcient implementations and analysis
of the union-ﬁnd data structure can be found in [Cormen et al., 2001].

12.4. Constructing Join, Split, and Merge Trees
395
Input
: Scalar graph G.
Sequence (v1, v2, . . . , vn) of vertices of G sorted
by increasing scalar value.
Result
: A join tree.
ConstructJoin(G, (v1, v2, . . . , vn))
1 for i = 1 to n do
2
CreateSet(i);
3
Create join node ai;
4
ai.parent ←NULL;
5
vi.jNode ←ai;
6
foreach vertex vj ∈V (G) adjacent to vi do
7
if (j < i) and (Set(i) ̸= Set(j)) then
8
k ←MaxSet(j);
9
a ←vk.jNode;
10
a.parent ←vi.jNode;
11
Union(i,j);
/* Note: i now equals MaxSet(j)
*/
12
end
13
end
14 end
Algorithm 12.1. Construct Join.
In addition to the union and ﬁnd operations, we will also need to retrieve the
maximum element of a set. We can do this eﬃciently by storing this maximum
element for each set. When applying the union operation to two sets, A and B,
compare their maxima, mA and mB, respectively, and set the maximum of the
new set to be the maximum of mA and mB.
We construct a join tree of a scalar graph by ﬁrst sorting vertices in increasing
order of scalar value. We process the vertices by increasing order as follows.
For vertex vi, we create a set containing index i. Create a join tree node ai.
For each graph vertex vj adjacent to vi, if vj.scalar < vi.scalar and the set
containing i is diﬀerent from the set containing j, get the maximum element k
of the set containing j and make ai the parent of ak in the join tree. Union the
set containing i with the set containing j. The algorithm, Construct Join, is
presented in Algorithm 12.1.
Construction of a split tree is similar to construction of a join tree. Instead of
storing and retrieving maximum elements of sets, we store and retrieve minimum
elements of sets. When applying the union operation to two sets, A and B,
compare their minima, mA and mB, respectively, and set the minima of the new
set to be the minima of mA and mB.

396
12. Contour Trees
Input
: Scalar graph G.
Sequence (v1, v2, . . . , vn) of vertices of G sorted
by increasing scalar value.
Result
: A split tree.
ConstructSplit(G, (v1, v2, . . . , vn))
1 for i = n downto 1 do
2
CreateSet(i);
3
Create split node b;
4
bi.parent ←NULL;
5
vi.sNode ←bi;
6
foreach vertex vj ∈V (G) adjacent to vi do
7
if (j > i) and (Set(i) ̸= Set(j)) then
8
k ←MinSet(j);
9
b ←vk.sNode;
10
b.parent ←vi.sNode;
11
Union(i,j);
/* Note: i now equals MinSet(j)
*/
12
end
13
end
14 end
Algorithm 12.2. Construct Split.
As in construction of a join tree, sort vertices in order of scalar value. How-
ever, instead of processing vertices in increasing order, process them in decreasing
order. For vertex vi, create a set containing index i. Create a split tree node
bi. For each graph vertex vj adjacent to vi, if vj.scalar > vi.scalar and the set
containing i is diﬀerent from the set containing j, get the minimum element k
of the set containing j and make bi the parent of bk in the split tree. Union the
set containing i with the set containing j. The algorithm, Construct Split,
is presented in Algorithm 12.2.
12.4.2
Merging Join and Split Trees
Before describing the merge tree algorithm, we present some propositions from
[Carr et al., 2003] that form the basis of the algorithm. The proofs of all these
propositions are in Section 12.6.
Both join and split trees have a root vertex. The root of the join tree is the
vertex with highest scalar value while the root of the split tree is the vertex with

12.4. Constructing Join, Split, and Merge Trees
397
the lowest scalar value. For each edge (vi, vj) of a rooted tree, either vi is a child
of vj or vj is a child of vi. (See Appendix C for properties of rooted trees.)
For a vertex ai of a join tree, let ai.numChildren be the number of children of
ai in the join tree. Similarly, let bi.numChildren be the number of children of a
vertex bi in a corresponding split tree.
The following proposition relates the number of children of ai and bi to the
degree of ci.
Proposition 12.10. Let T be a tree whose join and split trees are TJ and TS. For
each vertex ci ∈V (T ) corresponding to vertices ai ∈V (TJ) and bi ∈V (TS), the
degree of ci equals (ai.numChildren + bi.numChildren).
The following proposition allows us to identify some of the merge tree edges.
Proposition 12.11. Let TJ and TS be the join and split trees, respectively, of scalar
tree T , where ai ∈V (TJ) and bi ∈V (TS) correspond to ci ∈V (T ).
1. If ai has no children and aj ∈V (TJ) is the parent of ai, then (ci, cj) is an
edge of T .
2. If bi has no children and bj ∈V (TS) is the parent of bi, then (ci, cj) is an
edge of T .
The deletion of a vertex vi from a graph G, denoted G −vi, is the removal of
vi and all its incident edges from the graph. Formally,
V (G −vi)
=
V (G) −{vi},
E(G −vi)
=
E(G) −{(vi, vj) : (vi, vj) ∈E(G)}.
The reduction of a rooted tree T by a vertex vi, denoted T ⊖vi, is the deletion
of vi from T and the connection of each child of vi in T to the parent of vi in
T . Formally,
V (T ⊖vi) = V (T −vi),
E(T ⊖vi) = E(T −vi) ∪{(vj, vk) : vj is a child and vk is a parent of vi in T }.
If vi is the root of T , then the reduction of T by vi is equivalent to the deletion
of vi from T . Each child of vi becomes a root.
Let ai and bi be corresponding nodes of join and split trees, TJ and TS, of
the merge tree TM. If aj.numChildren + bj.numChildren equals one, then aj, bj,
and cj can be removed from TM, TJ, and TS as shown in Proposition 12.12.
Proposition 12.12. Let TJ and TS be the join and split trees, respectively, of
scalar tree T , where ai ∈V (TJ) and bi ∈V (TS) correspond to ci ∈V (T ).

398
12. Contour Trees
If aj.numChildren + bj.numChildren equals one, then
1. the join tree of T −cj is TJ ⊖aj,
2. the split tree of T −cj is TS ⊖bj.
The next proposition guarantees that for at least some ck ∈V (TM), Propo-
sition 12.12 applies.
Proposition 12.13. Let TJ and TS be the join and split trees, respectively, of a
tree T with n ≥2 vertices, where ai ∈V (TJ) and bi ∈V (TS) correspond to
vi ∈V (G). For at least one k ∈[1, . . . , n],
ak.numChildren + bk.numChildren = 1.
Propositions 12.10–12.13 can be applied to an algorithm to construct a tree
TM whose join and split trees are TJ and TS.
By Proposition 12.13, (ak.numChildren + bk.numChildren) equals one for some
k ∈[1, . . . , n]. By Proposition 12.12, the join and split trees of TM −ck are TJ ⊖ak
and TS ⊖bk. Thus, TM −ck is the merge tree of TJ ⊖ak and TS ⊖bk. Recursively,
apply the algorithm to construct TM −ck. Applying Proposition 12.11 gives an
edge e incident on ck in TM. By Proposition 12.10, vertex ck has degree one in
TM, so only edge e is incident on ck. Construct TM by adding vertex ck and edge
e to TM −ck.
More speciﬁcally, algorithm Merge Join Split creates a merge tree as fol-
lows. Start by creating a queue containing all i ∈[1, . . . , n] such that the sum
ai.numChildren+bi.numChildren is one. While the queue has two or more elements,
remove one element i from the queue and do the following.
If ai ∈TJ has no children, then let ak be the parent of ai in the join tree.
(Note that ai cannot be the root of TJ. If ai were the root of TJ, then TJ would
have only one vertex and the queue would have only one element.) Add edge
(ci, ck) to the merge tree. Delete ai from TJ. Replace bi in TS with an edge
connecting its child and its parent. (If bi is the root of TS, then make the child of
bi the root of TS.) If ak.numChildren+ bk.numChildren is one, add k to the queue.
If ai ∈TJ has one or more children, then bi ∈TS has no children. Let bk be
the parent of bi in the split tree. (Note that bi cannot be the root of TS.) Add
edge (ci, ck) to the contour tree. Delete bi from TS. Replace ai in TJ with an
edge connecting its child and its parent. (If ai is the root of TJ, then make the
child of ai the root of TJ.) If ak.numChildren + bk.numChildren is one, add k to
the queue. Pseudocode is presented in Algorithm 12.3.
12.4.3
Running Time Analysis
The running times of Construct Join (Algorithm 12.1) and Construct
Split (Algorithm 12.2) are dominated by the time to perform the Union and

12.4. Constructing Join, Split, and Merge Trees
399
Input
: A join tree TJ with vertices {a1, . . . , an}.
A split tree TS with vertices {b1, . . . , bn}.
Vertex ai ∈TJ corresponds to vertex bi ∈TS.
Result
: A merge tree TM with vertices {c1, . . . , cn}.
Vertex ci is a join (minimum) vertex in TM if and only if
ai is a join (minimum) vertex in TJ.
Vertex ci is a split (maximum) vertex in TC if and only if
bi is a split (maximum) vertex in TS.
MergeJoinSplit(TJ,TS)
1 foreach vertex pair (ai, bi) where ai ∈TJ and bi ∈TS do
2
Create contour tree vertex ci;
3
if (ai.numChildren + bi.numChildren = 1) then Q.Enqueue(i);
4 end
5 while (Q.Size() > 1) do
6
i ←Q.Dequeue();
7
if (ai.numChildren = 0) then
8
k ←index such that ak = ai.parent;
9
ci.parent ←ck;
10
else
11
k ←index such that bk = bi.parent;
12
ci.parent ←ck;
13
end
14
TJ ←TJ ⊖ai;
15
TS ←TS ⊖bi;
16
if (ak.numChildren + bk.numChildren = 1) then Q.Enqueue(k);
17 end
Algorithm 12.3. Merge Join Split.
Set operations. If implemented using a union-ﬁnd data structure as described
in [Cormen et al., 2001], the total running time is Θ(mα(n)) where n is the
number of graph vertices and m is the number of graph edges. Function α(n)
is the inverse of the Ackermann function and grows very slowly. (See [Cormen
et al., 2001] for the analysis of the union-ﬁnd data structure.)
Both Construct Join and Construct Split assume that the input se-
quence of vertices is already sorted by increasing scalar value. Sorting the input
vertices would require additional time. General purpose sorting algorithms re-
quire Θ(n log n) time. However, if the input scalar values are integers in a ﬁxed
range, say 0 to 4095 (212 −1), then counting sort can be used to sort the ver-
tices in Θ(n) time. (See [Cormen et al., 2001] for a description and analysis of
counting sort.)

400
12. Contour Trees
Algorithm Merge Join Split (Algorithm 12.3) contains one for (Steps 1–4)
loop and one while loop (Steps 5–17). The for loop executes in Θ(n) time. At
each iteration of the while loop, one node is removed from TJ and one node is
removed from TS. Thus the while loop also takes Θ(n) time and the algorithm
takes Θ(n) time.
The running times are summarized in the following proposition.
Proposition 12.14. Let n be the number of graph vertices and m the number of
graph edges.
• Algorithm Construct Join creates a join tree from a sequence of graph
vertices sorted by increasing scalar value in Θ(mα(n)) time.
• Algorithm Construct Split creates a split tree from a sequence of graph
vertices sorted by increasing scalar value in Θ(mα(n)) time.
• Algorithm Merge Join Split merges a join and split tree in Θ(n) time.
12.5
Constructing Contour Trees
To construct the contour tree for a scalar simplicial mesh Γ, we simply construct
the merge tree of the 1-skeleton of Γ. We handle vertices with identical scalar
values by symbolically perturbing the scalar values.
Constructing a contour tree from a regular grid is more diﬃcult. In Propo-
sition 12.17, we show that the isosurfaces constructed by Marching Cubes
(using an appropriate lookup table) are homeomorphic to level sets of a particu-
lar triangulation of the regular grid. We construct the contour tree of the regular
grid by constructing the merge tree of the 1-skeleton of this triangulation.
12.5.1
Simplicial Meshes
Let Γ be a distinct valued scalar simplicial mesh and let φ : R3 →R be the
piecewise linear function determined by Γ. Let G be the 1-skeleton of Γ. Let TJ
and TS be the join and split trees, respectively, of G. By Proposition 12.9, the
merge tree of TJ and TS is an augmented contour tree of φ.
Algorithm Construct CTree is as follows. (See Figure 12.16.) Sort the
vertices of G in increasing order. Apply algorithms Construct Join and Con-
struct Split (Algorithms 12.1 and 12.2) to construct the join and split trees
of G. Apply algorithm Merge Join Split (Algorithm 12.3) to construct the
merge tree of G from the join and split trees.

12.5. Constructing Contour Trees
401
Sort graph vertices by increasing scalar value
(Break ties arbitrarily)

Construct the join tree, TJ (algorithm Construct Join)

Construct the split tree, TS (algorithm Construct Split)

Merge TJ and TS to form the merge tree TM
(algorithm Merge Join Split)
Figure 12.16. Algorithm Construct CTree. Input is a regular scalar graph. If G
represents a continuous scalar ﬁeld φ : Rd →R, then TM is an augmented contour tree
of φ.
Starting with Section 12.3, we have assumed that all vertices of the scalar
graph G have diﬀerent scalar values. We can drop this assumption by symbol-
ically perturbing each scalar value by a small amount so that no two vertices
have the same scalar value. To simulate this perturbation, simply break ties ar-
bitrarily when sorting the vertices of G by scalar value. If vertex vi comes before
vj in sorted order, then the perturbed value vi.scalar + ϵi of vi is strictly less
than the perturbed value vj.scalar + ϵj of vj. Note that algorithm Construct
CTree never uses the scalar values after sorting the vertices and so the rest of
the algorithm is unchanged.
Let n be the number of vertices and m the number of edges of a scalar
simplicial mesh.
By Proposition 12.14 (Section 12.4.3), the running time of
Construct Join and Construct Split is Θ(mα(n)). The running time of
Merge Join Split is Θ(n). We can always use a general purpose sorting algo-
rithm to sort the mesh vertices in Θ(n log n) time. Thus, algorithm Construct
CTree runs in Θ(n log n + mα(n)) time.
Proposition 12.15. Let n be the number of mesh vertices and m the number of
mesh edges. Algorithm Construct CTree creates a contour tree in Θ(n log n+
mα(n)) time.
If G has numerous vertices with the same scalar value, then its contour tree
may have large connected clusters of vertices with the same scalar value. The
join and merge vertices in these clusters are a result of the arbitrary way ties
were broken in the sorting by scalar value.
Thus, it is desirable to collapse

402
12. Contour Trees
34
39
28
28
12
28
52
28
21
v1
v2
v3
v4
v5
v6
v7
v8
v9
c1
c2
c3
c4
c5
c6
c7
c8
c9
c1
c2
c3
c4
c5
c6
c7
c8
c9
c2
c3
c4
c7
c9
c∗
(a)
(b)
(c)
(d)
Figure 12.17. Diﬀerent contour trees produced by diﬀerent ordering of vertices with
identical scalar values. (a) Scalar graph G. Scalar values of vertices v1, v5, v6, and v8 are
identical. Scalar values are written inside the circles representing the vertices. (b) Aug-
mented contour tree for vertex order (v1, v5, v6, v8) of identical vertices. (c) Augmented
contour tree for vertex order (v8, v6, v5, v1) of identical vertices. (d) Tree produced by
collapsing vertices c1, c5, c6, and c8 into a single vertex c∗.
Input
: A tree T with vertices {c1, . . . , cn}.
Result
: Modify T by merging adjacent vertices with the same scalar
value.
MergeIdenticalScalar(T )
1 foreach tree edge (ci, cj) do
2
if (ci.scalar = cj.scalar) then
3
foreach vertex ck adjacent to cj do
4
if (ck ̸= ci) then Add edge (ci, ck) to T ;
5
end
6
Delete cj from T ;
7
end
8 end
Algorithm 12.4. Merge Identical Scalar.
such clusters into single vertices.
(See Figure 12.17.)
For each contour tree
edge (vi, vj) where vi.scalar equals vj.scalar, delete vertex vj and connect all its
incident edges to vi. Pseudocode for algorithm Merge Identical Scalar is
presented in Algorithm 12.4.
Algorithm Construct CTree constructs an augmented contour tree, TC.
To reduce TC to a contour tree, we must remove the vertices that are not join,
split, local minima, or local maxima. A vertex of an augmented contour tree
is regular if it is not a join, split, local minima, or local maxima vertex.
A
vertex is regular if and only if it is adjacent to exactly one vertex vj with

12.5. Constructing Contour Trees
403
c1
c2
c3
c4
c5
c6
c7
c8
c9
c10
c11
c12
c2
c3
c4
c5
c6
c8
c9
c10
c11
c12
(a)
(b)
Figure 12.18. (a) Augmented contour tree. (b) Contour tree. Regular vertices c1 and
c7 are in the augmented contour tree but not in the contour tree.
Input
: A tree T with vertices {c1, . . . , cn}.
Result
: Modify T by removing each regular vertex and connecting its
adjacent vertices by an edge.
RemoveRegularVertices(T )
1 foreach tree vertex ci do
2
if (ci is adjacent to exactly one cj with ci.scalar > cj.scalar) and
3
(ci is adjacent to exactly one ck with ci.scalar < ck.scalar) then
4
Add edge (cj, ck) to T ;
5
Delete ci from T ;
6
end
7 end
Algorithm 12.5. Remove Regular Vertices.
vi.scalar > vj.scalar and exactly one vertex vk with vi.scalar < vk.scalar. We
delete each such vi from TC and connect its two adjacent vertices by an edge.
(See Figure 12.18.). Pseudocode for algorithm Remove Regular Vertices is
presented in Algorithm 12.5.
12.5.2
Regular Scalar Grids
To construct a contour tree from a regular scalar grid, we could uniformly tetra-
hedralize the grid cubes into six tetrahedra as described in Section 2.4.3 and
construct a contour tree on the resulting tetrahedral mesh. This contour tree will

404
12. Contour Trees
represent the topology of the isosurfaces constructed by applying the March-
ing Simplices algorithm to the tetrahedral mesh. However, the topology of
the Marching Cubes isosurfaces does not necessarily match the topology of
the isosurfaces created by applying Marching Simplices to the tetrahedralized
grid. Diﬀerent connected components in the Marching Cubes isosurface may
form a single component in the Marching Simplices isosurface and vice versa.
The uniform tetrahedralization into six tetrahedra is not the only way to
tetrahedralize a cube. In Section 6.4.1, we deﬁned the incremental triangulation
of conv(p1, p2, . . . , pn) induced by the sequence (p1, p2, . . . , pn). The incremental
triangulation is the triangulation of conv(p1, p2, . . . , pn) induced by adding points
to the convex hull in the order p1, p2, . . . , pn.
Let Γ be a regular grid and let (v1, v2, . . . , vn) be a sequence of vertices of
Γ.
The sequence determines an incremental triangulation of each cube of Γ.
Moreover, the triangulations of any two adjacent grid cubes match on their
common face so the union of all the tetrahedra form a triangulation of the entire
grid.
Deﬁnition 12.16. The triangulation of regular grid Γ induced by the sequence (v1, v2,
. . . , vn) of vertices of Γ is the union of the incremental triangulations of each
cube of Γ induced by the sequence (v1, v2, . . . , vn).
In Section 5.2, we described an algorithm, IsoMid3D, to automatically gen-
erate an isosurface lookup table for 3D cubes. The table generated by this algo-
rithm is exactly the same as the isosurface lookup table for Marching Cubes
(Figure 2.16) except for ambiguous conﬁguration 2C. In conﬁguration 2C, Iso-
Mid3D generates the isosurface patch 2C-I in Figure 2.22.
A scalar grid is distinct valued if no two vertices of the grid have the same
value.
Proposition 12.17. Let Γ be a distinct valued regular scalar grid. Let τ be the
triangulation of Γ induced by sorting the vertices of Γ in decreasing order of scalar
value. Let φ be the piecewise linear function determined by τ. For each scalar
value σ, the level set φ−1(σ) is homeomorphic to the isosurfaces constructed by
Marching Cubes using the IsoMid3D lookup table.
Given a distinct valued regular grid, Γ, we construct the triangulation τ
induced by sorting the vertices of Γ in decreasing order of scalar value.
We
compute the contour tree of τ. The contour tree of τ represents the isosurface
generated by the Marching Cubes algorithm using the IsoMid3D lookup
table.
Constructing a triangulation τ of Γ is time- and space-consuming for any
reasonably sized grid Γ. However, we can construct the contour tree of τ directly
from Γ as described below.
The 1-skeleton of a regular scalar grid Γ is the scalar graph consisting of its
vertices and edges. The 26-connectivity graph of Γ is the scalar graph for every

12.5. Constructing Contour Trees
405
Input
: Regular grid Γ.
Sequence (v1, v2, . . . , vn) of vertices of Γ sorted
by increasing scalar value.
Result
: A join tree.
GridConstructJoin(Γ, (v1, v2, . . . , vn))
1 for i = 1 to n do
2
CreateSet(i);
3
Create join node ai;
4
ai.parent ←NULL;
5
vi.jNode ←ai;
6
foreach edge (vi, vj) of Γ do
7
if (j < i) and (Set(i) ̸= Set(j)) then
8
k ←MaxSet(j);
9
a ←vk.jNode;
10
a.parent ←vi.jNode;
11
Union(i,j);
/* Note: i now equals MaxSet(j)
*/
12
end
13
end
14 end
Algorithm 12.6. Grid Construct Join.
cube c ∈Γ; every pair of vertices v, v′ ∈c are connected by an edge. (A vertex
in the interior of Γ is connected to 26 vertices in the 26-connectivity graph.)
The following proposition relates the 1-skeleton of τ to the 1-skeleton and 26-
connectivity graph of Γ.
Proposition 12.18. Let Γ be a distinct valued regular scalar grid. Let τ be the
triangulation of Γ induced by sorting the vertices of Γ in decreasing order of
scalar value. Let Gτ be the 1-skeleton of τ, let G be the 1-skeleton of Γ, and let
G be the 26-connectivity graph of Γ.
1. The join tree of Gτ is the join tree of G.
2. The split tree of Gτ is the split tree of G.
Algorithm 12.6, Grid Construct Join, constructs the join tree of the 1-
skeleton G of Γ. By Proposition 12.18, this join tree is also the join tree of the
1-skeleton of τ. The edges of G are simply the edges of Γ, so there is no need to
explicitly construct G.
Algorithm 12.7, Grid Construct Split, constructs the split tree of the
26-connectivity graph G of Γ. By Proposition 12.18, this split tree is also the

406
12. Contour Trees
Input
: Regular grid Γ.
Sequence (v1, v2, . . . , vn) of vertices of Γ sorted
by increasing scalar value.
Result
: A split tree.
GridConstructSplit(Γ, (v1, v2, . . . , vn))
1 for i = n downto 1 do
2
CreateSet(i);
3
Create split node bi;
4
bi.parent ←NULL;
5
vi.sNode ←bi;
6
foreach vertex vj, which shares a grid cube with vi do
7
if (j > i) and (Set(i) ̸= Set(j)) then
8
k ←MaxSet(j);
9
b ←vk.sNode;
10
b.parent ←vi.sNode;
11
Union(i,j);
/* Note: i now equals MaxSet(j)
*/
12
end
13
end
14 end
Algorithm 12.7. Grid Construct Split.
split tree of the 1-skeleton of τ. The edges of G are determined by the cubes of
Γ, so again there is no need to explicitly construct G.
Algorithm Grid Construct CTree constructs a contour tree from a regu-
lar scalar grid as follows. (See Figure 12.19.) Sort the grid vertices by increasing
scalar value. Symbolically perturb the scalar values to break any ties. Call Grid
Construct Join and Grid Construct Split to construct the join and split
trees. Call Merge Join Split to merge the join and split trees into a contour
tree.
The running times of Grid Construct Join and Grid Construct Split
are the same as the running times of Construct Join and Construct Split.
Thus the running time of Grid Construct CTree is the same as the running
time of Construct CTree. However, the number of edges in the regular grid
is about three times the number N of grid vertices, so the running time can be
expressed just in terms of N. Since (Nα(N)) is less than (N log N) for large N,
the (Nα(N)) term is absorbed into the (N log N) term.
Proposition 12.19. Let N be the number of vertices of a regular scalar grid Γ.
Algorithm Grid Construct CTree creates a contour tree from grid Γ in
Θ(N log N) time.

12.6. Theory and Proofs
407
Sort grid vertices by increasing scalar value
(break ties arbitrarily)

Construct the join tree, TJ (algorithm Grid Construct Join)

Construct the split tree, TS (algorithm Grid Construct Split)

Merge TJ and TS to form the merge tree TM
(algorithm Merge Join Split)
Figure 12.19. Algorithm Grid Construct CTree. Input is a scalar grid Γ.
Algorithms Merge Identical Scalar and Remove Regular Vertices
can be used to merge vertices with identical scalar values and remove regular
vertices from a contour tree produced from a regular scalar grid.
12.6
Theory and Proofs
12.6.1
Contour Tree Proofs
We prove that if D is homeomorphic to an open or closed ball and λ contains
the critical connected components of level sets of φ, then the graph induced by
λ is a tree.
Proposition 12.2.
Let φ : D →R be a continuous scalar ﬁeld and let Λ be some
of the connected components of level sets of φ. If
1. D is homeomorphic to an open or closed ball in Rd,
2. Λ contains all the critical connected components of level sets of φ,
then the graph G induced by Λ is a tree.
Proof: Let Λ be a set of connected components of the level sets of φ that contains
all the critical connected components of the level sets of φ. Let Σ be the union
of all the elements of Λ. Let G be the graph induced by Λ.

408
12. Contour Trees
Since Λ contains all the critical connected components of level sets, each
connected component μ of D−Σ is bounded by at most two elements, λ1 and λ2,
of Λ. Thus, each edge e = (vλ1, vλ2) of G corresponds to a connected component
μ of D −Σ. Region μ separates λ1 from λ2 so deleting e from G disconnects vλ1
from vλ2. Thus G has no cycles.
There is a path in D between any two elements of Λf, so there is a path in G
between the corresponding vertices in G. Thus G is connected.
Since G is a connected graph with no cycles, G is a tree.
□
12.6.2
Merge Tree Proofs
This section contains all the proofs of Propositions 12.8–12.13. The proof of
Proposition 12.8 requires Propositions 12.10, 12.12, and 12.13 and is delayed
until the end of this section.
As previously deﬁned, G−(vi) is the subgraph of a scalar graph G induced by
vertices whose scalar values are less than vi.scalar, the scalar value of vi. Graph
G+(vi) is the subgraph of a scalar graph G induced by vertices whose scalar
values are greater than vi.scalar. Similarly, T −(ci) is the subgraph of the scalar
tree T induced by vertices whose scalar values are less than vi.scalar and T +(ci)
is the subgraph of T induced by vertices whose scalar values are greater than
vi.scalar.
Proposition 12.9 relates the augmented contour tree of a scalar simplicial
mesh to the scalar graph formed by its vertices and edges.
Proposition 12.9.
Let Γ be a distinct valued simplicial mesh covering a rectan-
gular region in Rd. If G is the 1-skeleton of Γ, then the augmented contour tree
of Γ is the merge tree of G.
Proof: Let Γ be a distinct valued scalar simplicial mesh and let G be the scalar
graph formed by the vertices and edges of Γ. Let φ : D →R be the piecewise
linear function deﬁned by Γ.
Consider a level set φ−1(vi.scalar) for some mesh vertex vi. This level set sep-
arates D into connected components and partitions the vertices of Γ into subsets
where two vertices are in the same subset if they are in the same component.
(See an example in Figure 12.20.) The vertices of each subset either all have
scalar value less than vi.scalar or all have scalar value greater than vi.scalar. The
subsets whose vertices have scalar value less than vi.scalar are exactly the sets
of vertices of the connected components of G−(vi). The subsets whose vertices
have scalar value greater than vi.scalar are exactly the sets of vertices of the
components of G+(vi).
Let TC be the augmented contour tree of Γ. Let TJ and T ′
J be the join trees
of TC and G, respectively. Let ai, a′
i, and ci be the vertices of TJ, T ′
J, and TC
that correspond to mesh vertex vi.

12.6. Theory and Proofs
409
58
51
32
62
25
16
66
64
39
53
45
30
v1
v2
v3
v4
v5
v6
v7
v8
v9
v10
v11
v12
Figure 12.20. Level set φ−1(v8.scalar) where φ is the piecewise linear function deﬁned
by the scalar mesh.
Let λi be the connected component of the level set φ−1(vi.scalar) that con-
tains vi. The connected components of D −φ−1(vi.scalar) that have λi on its
boundary correspond to the connected components of G−(vi) and G+(vi), which
are connected to vi. Thus U is the set of vertices of some connected component
λ of T −
C (ci) if and only if {vj : cj ∈U} is the set of vertices of some connected
component λ′ of G−(vi). Moreover, ci is connected to λ if and only if vi is con-
nected to λ′. Thus, aj ∈TJ is a child of ai ∈TJ if and only if a′
j ∈T ′
J is a child
of a′
i ∈T ′
J and the join tree of TC is isomorphic to the join tree of G. Similarly,
the split tree of TC is isomorphic to the split tree of G.
Since the join and split trees of TC are isomorphic to T ′
J and T ′
S, respectively,
tree TC is the merge tree of T ′
J and T ′
S. By deﬁnition, TC is the merge tree of G.□
The degree of a vertex vi ∈G is the number of edges incident on vi. For
a scalar graph G, deﬁne the down degree of a vertex vi as the number of edges
(vi, vj) incident on vi where vi.scalar > vj.scalar. Deﬁne the up degree of a vertex
vi as the number of edges (vi, vj) incident on vi where vi.scalar < vj.scalar.
The following lemma relates up and down degrees of merge tree vertices to
the number of children in the join and split trees.
Lemma 12.20. Let T be a scalar tree whose fully augmented join and split trees
are TJ and TS. For each vertex ci ∈V (T ) corresponding to vertices ai ∈V (TJ)
and bi ∈V (TS),
1. the down degree of ci equals ai.numChildren.
2. the up degree of ci equals bi.numChildren.
Proof: The number of children of ai is the number of connected components of
T −(ci). Since T is a tree, the number of connected components of T −(ci) is the
down degree of ci. Thus, the number of children of ai is the down degree of ci.
By a similar argument, the number of children of bi is the up degree of ci.
□

410
12. Contour Trees
Proposition 12.10.
Let T be a tree whose join and split trees are TJ and TS.
For each vertex ci ∈V (T ) corresponding to vertices ai ∈V (TJ) and bi ∈V (TS),
the degree of ci equals (ai.numChildren + bi.numChildren).
Proof: The degree of ci equals the down degree plus the up degree of ci. By
Lemma 12.20, the down degree plus the up degree equals
(ai.numChildren + bi.numChildren).
□
Proposition 12.11.
Let TJ and TS be the join and split trees, respectively, of
scalar tree T , where ai ∈V (TJ) and bi ∈V (TS) correspond to ci ∈V (T ).
1. If ai has no children and aj ∈V (TJ) is the parent of ai, then (ci, cj) is an
edge of T .
2. If bi has no children and bj ∈V (TS) is the parent of bi, then (ci, cj) is an
edge of T .
Proof: We prove only Statement 1 of the proposition. The proof of Statement 2
is similar.
Let ai be a vertex of TJ with no children and let aj be the parent of ai.
By deﬁnition of the join tree (Deﬁnition 12.5), vertex cj is connected to some
component λ of T −(cj) where ci is the element of λ with the maximum scalar
value. By Lemma 12.20, the down degree of ci is zero. Thus, ci is not connected
to any vertices ck ∈λ with scalar value less than ci.scalar. On the other hand,
ci has maximum scalar value in λ so ci is not connected to any vertices ck ∈λ
with scalar value greater than ci.scalar. Thus ci is not connected to any other
vertices in λ. Since ci is in λ and λ is connected, vertex ci is only the vertex in
λ. Since cj is connected to λ, (ci, cj) is an edge of T .
□
Proposition 12.21. Let TJ and TS be the join and split trees, respectively, of
scalar tree T , where ai ∈V (TJ) and bi ∈V (TS) correspond to ci ∈V (T ).
If aj.numChildren + bj.numChildren equals one, then
1. the join tree of T −cj is TJ ⊖aj,
2. the split tree of T −cj is TS ⊖bj.
Proof: Let T ′ equal T −{cj}. By Proposition 12.10, vertex cj has degree one
and so T ′ is a tree. Let T ′
J be the join tree of T ′ and a′
i be the vertex of T ′
J
corresponding to ci ∈T ′.
We show that every edge in TJ ⊖aj corresponds to an edge of T ′
J. We consider
two cases based on the number of children of aj.

12.6. Theory and Proofs
411
Case I: Vertex aj has zero children.
Consider an edge (ai, ak) ∈TJ ⊖aj where ai is a child of ak. Since aj
has zero children, ai is also a child of ak in TJ. By deﬁnition of the join tree
(Deﬁnition 12.5), vertex ci is the vertex with maximum scalar value in some
connected component λ of T −(ck) and ck is connected to λ. If cj is not an
element of λ, then λ is also a connected component of T ′−(ck) and ci is a
vertex with maximum scalar value in λ. Thus, a′
i is a child of a′
k in T ′
J. If cj
is an element of λ, then λ −cj is a connected component of T ′−(ck) (since
cj has degree one). Vertex ci is still the vertex with maximum scalar value
in λ −cj. Again a′
i is a child of a′
k in T ′
J.
Case II: Vertex aj has one child.
Consider an edge (ai, ak) ∈TJ ⊖aj where ai is a child of ak. Assume ai is
not the child of aj in TJ. In this case, ai is a child of ak in TJ. By deﬁnition
of the join tree (Deﬁnition 12.5), vertex ci is the vertex with maximum
scalar value in some connected component λ of T −(ck) and ck is connected
to λ. If cj is not an element of λ, then λ′ = λ is a connected component of
T ′−(ck). If cj is an element of λ, then λ′ = λ−cj is a connected component
of T ′−(ck). In either case, ci is a vertex with maximum scalar value in λ′,
so a′
i is a child of a′
k in T ′
J.
Assume ai is the child of aj in TJ. Since ai is the child of ak in TJ ⊖aj,
vertex aj is the child of ak in TJ. Let λ be the connected component of
T −(ck) containing cj. Since cj has degree one, λ′ = λ −cj is connected.
Since ck is connected to λ, vertex ck is also connected to λ′. Thus λ′ is a
connected component of T ′−
k . Since ai is the child of aj in TJ vertex ci is in
λ and λ′ is the vertex with maximum scalar value in λ′. Thus, a′
i is a child
of a′
k in T ′
J.
Since aj has at most one child in TJ, graph TJ ⊖aj is a tree. Since every edge
(ai, ak) in TJ ⊖aj corresponds to an edge (a′
i, a′
k) in T ′
J and trees TJ ⊖aj and T ′
J
have the same number of vertices and edges, T ′
J is isomorphic to TJ ⊖aj.
A similar argument shows that the split tree of T ′ is T ′
S ⊖bj.
□
Proposition 12.22. Let TJ and TS be the join and split trees, respectively, of a
tree T with n ≥2 vertices, where ai ∈V (TJ) and bi ∈V (TS) correspond to
vi ∈V (G). For at least one k ∈[1, . . . , n],
ak.numChildren + bk.numChildren = 1.
Proof: Let n be the number of vertices of TJ and TS. Since a tree on n vertices
has n −1 edges,
n

i=1
ai.numChildren
=
n −1,
n

i=1
bi.numChildren
=
n −1.

412
12. Contour Trees
Thus,
n

i=1
(ai.numChildren + bi.numChildren) = 2(n −1),
and (ak.numChildren + bk.numChildren) ≤1 for some k ∈[1, . . . , n].
Let vk be the vertex of G corresponding to ak and bk. Since G is connected and
has at least two vertices, vk is adjacent to some vertex vj of G. If vj.scalar is less
than vk.scalar, then vk is connected to some component of G−
k and ak is at least
one. If vj.scalar is greater than vk.scalar, then vk is connected to some component
of G+
k and bk is at least one. Thus (ak.numChildren + bk.numChildren) ≥1 and so
(ak.numChildren + bk.numChildren) equals 1.
□
Finally, we prove that the merge tree is unique.
Proposition 12.8.
If TJ and TS are the join and split trees, respectively, of two
trees, T and T ′, then T is isomorphic to T ′.
Proof: Let ci and c′
i be the vertices of T and T ′, respectively, corresponding to
vertex ai of TJ and bi of TS. We prove there is an isomorphism from T to T ′
that maps ci to c′
i. The proof is by induction. If TJ and TS each contain one or
two vertices, then the claim is trivially true.
Assume that the claim holds when each tree has n vertices. We show that
the claim holds when each tree has n + 1 vertices.
By Proposition 12.13, there is some k ∈[1, . . . , n + 1] such that (ak + bk)
equals one. Assume that ak has zero children and bk has one child. Let aj be
the parent of ak in the join tree. By Proposition 12.10, vertices ck and c′
k have
degree one. Thus edge (ck, cj) is the sole edge of T incident on ck and (c′
k, c′
j) is
the sole edge of T incident on c′
k. By Proposition 12.12, the join tree of T −ck
and of T ′ −c′
k is TJ ⊖ak and the split tree of T −ck and of T ′ −c′
k is TS ⊖bk.
By the induction assumption, there is an isomorphism from T −ck to T ′ −c′
k
that maps ci ∈V (T −ck) to c′
i ∈V (T ′ −c′
k). Extending this by mapping ck to
c′
k gives an isomorphism from T to T ′, which maps ci ∈V (T ) to c′
i ∈V (T ′). □
12.6.3
No Merge Tree
In Section 12.3.2, Figure 12.15, we gave an example of a scalar graph formed
from the edges of a regular grid that we claimed had no merge tree. In this
section, we prove that claim.
Proposition 12.23. There is no merge tree for the scalar graph G in Figure 12.15.
Proof: The join tree, TJ, and the split tree, TS, of G are drawn in Figures 12.21(a)
and 12.21(b), respectively. Assume that there was some tree TM such that the

12.6. Theory and Proofs
413
a1
a2
a3
a4
a5
a6
b1
b2
b3
b4
b5
b6
c1
c2
c3
c6
(a) Join tree TJ.
(b) Split tree TS.
(c) Problem edges.
Figure 12.21. A pair of join and split trees that have no merge tree. (a) Join tree TJ of
the scalar graph in Figure 12.15. (b) Split tree TS of the scalar graph in Figure 12.15.
(c) A merge tree of TJ and TS would have to contain edges (c1, c2), (c3, c1), and (c3, c6).
However, TJ cannot be the join tree of any graph with those edges.
join tree of TM was TJ and the split tree of TM was TS. Let ci be the vertex of
TM corresponding to vertex ai of TJ and vertex bi of TS.
Vertex b2 has no children in TS. By Proposition 12.11, (c1, c2) is an edge of
TM. By Proposition 12.10, there is no other edge incident on c2 in TM. Vertex
b3 has two children in TS. By Lemma 12.20, the up degree of c3 is two. There
are only three vertices, c1, c2, and c6, whose scalar values are greater than c3.
Since (c1, c2) is the only edge incident on c2, vertex c3 must be connected to c1
and c6. (See Figure 12.21(c).)
Since c3 is connected to c1 and c6, vertices c1 and c3 lie in the same connected
component of T −
M (c6). By deﬁnition of the join tree, vertex a3 is not a child of
a6 in the join tree of TM. Thus, TJ is not the join tree of TM, contradicting the
assumption that TM is the merge tree of TJ and TS. We conclude that there is
no tree TM whose join and split trees are TJ and TS.
□
12.6.4
Regular Grid Proofs
This section contains the proofs of Propositions 12.17 and 12.18 from Sec-
tion 12.5.2.
As in Chapter 2, a vertex is positive, “+” if its scalar value is greater than or
equal to the isovalue, and negative, “−”, if its scalar value is below the isovalue.
An edge is positive if both its endpoints are positive and is negative if both
endpoints are negative.
Proposition 12.17.
Let Γ be a distinct valued regular scalar grid. Let τ be the
triangulation of Γ induced by sorting the vertices of Γ in decreasing order of scalar
value. Let φ be the piecewise linear function determined by τ. For each scalar

414
12. Contour Trees
value σ, the level set φ−1(σ) is homeomorphic to the isosurfaces constructed by
Marching Cubes using the IsoMid3D lookup table.
Proof: Assign a positive, “+”, label to grid vertices whose scalar values are
greater than or equal to σ and a negative, “−”, label to vertices whose scalar
values are less than σ. Let c be some cube of the grid. Since the triangulation τ
is induced by sorting vertices in decreasing scalar order, the positive vertices in
c are connected by positive edges of τ. The level set φ−1(σ) does not intersect
any positive edges. Therefore, the level set φ−1(σ) does not separate any of the
positive vertices in c. Similarly, φ−1(σ) does not separate any positive vertices
on any face f of c.
Algorithm IsoMid3D constructs an isosurface patch in c that also does not
separate any of the positive vertices in c or in any face f of c. Let Sσ be the
isosurface with isovalue σ constructed by the Marching Cubes algorithm and let
F be the union of all the grid faces of Γ. Since both φ−1(σ) and Sσ do not
separate positive vertices in face f, some curve of φ−1(σ) ∩f connects grid edges
e1 and e2 if and only if some curve in Sσ ∩f connects e1 and e2. Thus, there is
a homeomorphism that maps φ−1(σ) ∩F to Sσ ∩F.
For all isosurface lookup table conﬁgurations, except 2C, the isosurface patch
is a union of disks. For all such conﬁgurations, φ−1(σ) ∩c is a union of corre-
sponding disks. For conﬁguration 2C, the isosurface patch is a cylinder contain-
ing two diagonally opposite positive vertices. These two vertices have greatest
scalar value in c, so τ contains the diagonal edge connecting these vertices and
φ−1(σ) ∩c is a cylinder containing the two vertices. Thus, for every grid cube
c, the homeomorphism from φ−1(σ) ∩F to Sσ ∩F can be extended to the level
set and isosurface in the interior of each grid cube. Thus the homeomorphism
can be extended to the entire level set and isosurface.
□
The following lemma is used in proving Proposition 12.18.
Lemma 12.24. Let Γ be a distinct valued regular scalar grid. Let τ be the trian-
gulation of Γ induced by sorting the vertices of Γ in decreasing order of scalar
value. Let Gτ be the 1-skeleton of τ, let G be the 1-skeleton of Γ, and let G be
the 26-connectivity graph of Γ.
1. If (v, v′) is an edge of Gτ, then there is some path from v to v′ in G whose
vertices all have scalar values at most max(v.scalar, v′.scalar).
2. If (v, v′) is an edge of G, then there is some path from v to v′ in Gτ whose
vertices all have scalar values at least min(v.scalar, v′.scalar).
Proof of 1: Edge (v, v′) is either an edge of G or the diagonal of some grid face f
or the diagonal of some grid cube c. We consider each of the three cases.
Case I: Edge (v, v′) is an edge of G.
Statement 1 is trivially true since (v, v′) is a path from v to v′.

12.6. Theory and Proofs
415
Case II: Edge (v, v′) is the diagonal of some grid face f.
Triangulation τ restricted to f is a triangulation of f containing edge
(v, v′). Since τ is induced by adding vertices in decreasing scalar order, some
third vertex v′′ of f must have scalar value less than v.scalar and v′.scalar.
Thus (v, v′′, v′) is a path from v to v′ whose vertices all have scalar value at
most max(v.scalar, v′.scalar).
Case III: Edge (v, v′) is the diagonal of some grid cube c.
Let s equal max(v.scalar, v′.scalar). Let W be the set of three vertices
in cube c adjacent to v and let W ′ be the set of three vertices in cube c
adjacent to v′.
Triangulation τ restricted to c is a triangulation of c containing edge
(v, v′). Diagonal (v, v′) passes through the interior of triangle formed by
the three vertices of W. Since τ is induced by adding vertices in decreasing
scalar order, at least one of the scalar values of the vertices in W. must be
less than s. Similarly, at least one of the scalar values of the vertices in W ′
must be less than s.
Let w and w′ be the vertices in W and W ′, respectively, where w.scalar
and w′.scalar are less than s. If (w, w′) is an edge of cube c, then (v, w, w′, v′)
is a path from v to v′ whose vertices all have scalar value at most max(v.scalar,
v′.scalar). If (w, w′) is not an edge of cube c, then (w, w′) is a diagonal of the
cube. Let W ′′ be the four vertices of c that are not v, v′, w, or w′. Diagonal
(v, v′) passes thought the interior of the convex hull of W ′′. Thus w′′.scalar
is less than s for at least one vertex w′′ ∈W ′′. If vertex w′′ is adjacent to
w, then (v, w, w′′, v′) is a path from v to v′ whose vertices all have scalar
value at most max(v.scalar, v′.scalar). Otherwise, vertex w′′ is adjacent to
w′ and (v, w′′, w′, v′) is a path from v to v′ whose vertices all have scalar
value at most max(v.scalar, v′.scalar).
□
Proof of 2: Since (v, v′) is an edge of G, some cube c of Γ contains both v and v′.
Let W be the vertices of c whose scalar values are at least min(v.scalar, v′.scalar).
Since triangulation τ is induced by adding vertices in decreasing scalar order,
triangulation τ restricted to the vertices of W form a triangulation of the convex
hull of W. Since the convex hull is connected, there is a path from v to v′ in W.
Thus, there is a path from v to v′ whose vertices all have scalar value at least
min(v.scalar, v′.scalar).
□
Proposition 12.18.
Let Γ be a distinct valued regular scalar grid. Let τ be
the triangulation of Γ induced by sorting the vertices of Γ in decreasing order of
scalar value. Let Gτ be the 1-skeleton of τ, let G be the 1-skeleton of Γ, and let
G be the 26-connectivity graph of Γ.
1. The join tree of Gτ is the join tree of G.
2. The split tree of Gτ is the split tree of G.

416
12. Contour Trees
Proof of 1: As in Section 12.3, let G−(vi) and G−
τ (vi) be the set of vertices of G
and Gτ with scalar value strictly less than vi.scalar. Since G is a subset of Gτ,
every connected component of G−(vi) is contained in a connected component of
G−
τ (vi). By Lemma 12.24, Statement 1, if (v, v′) are an edge of G−
τ (vi), then v
and v′ are connected by some path in G−(vi). Thus, two vertices are in the same
connected component of G−
τ (vi) if and only if they are in the same component
of G−(vi). Similarly, vertex vi is connected to the component containing vj in
G−
τ (vi) if and only if vj is connected to the component containing vj in G−
τ (vi).
Since the deﬁnition of the join tree is based on the connected components of
G−(vi) and G−
τ (vi) that are connected to vi, the join tree of G is the same as the
join tree of Gτ.
□
Proof of 2: As in Section 12.3, let G+(vi) and G+
τ (vi) be the set of vertices of G
and Gτ with scalar value strictly greater than vi.scalar. Since Gτ is a subset of
G, every connected component of G+
τ (vi) is contained in a connected component
of G+(vi). By Lemma 12.24, Statement 2, if (v, v′) are an edge of G+(vi), then v
and v′ are connected by some path in G+
τ (vi). Thus, two vertices are in the same
connected component of G+(vi) if and only if they are in the same component
of G−
τ (vi). Similarly, vertex vi is connected to the component containing vj in
G+(vi) if and only if vj is connected to the component containing vj in G+
τ (vi).
Since the deﬁnition of the split tree is based on the connected components of
G+(vi) and G+
τ (vi) that are connected to vi, the split tree of G is the same as
the split tree of Gτ.
□
12.7
Simpliﬁcation of Contour Trees
Even isosurfaces in the simplest, computer-generated data sets may contain many
small connected components that are artifacts of the grid sampling or of the data
set boundary. The small connected components create numerous nodes in the
contour tree, making it diﬃcult to visualize. For instance, the full contour tree of
the nucleon data (Figure 12.4) contains 41 nodes. Figure 12.4(a) is a simpliﬁed
version of the contour tree with many nodes removed.
Data sets created by imaging devices contain numerous connected compo-
nents caused by noise in the data. The full contour tree of the engine data set
in Figure 11.1 contains 123,864 nodes. The full contour tree of the tooth data
set in Figure 11.2 contains 576,118 nodes.
Numerous metrics can be used to remove nodes from contour trees. One sim-
ple metric is the scalar value associated with the nodes. Consider Figure 12.22
containing part of the full contour tree. The tree nodes contain the scalar val-
ues of the associated contour trees. All the tree nodes in this portion of the
contour tree contain scalar values of 247, 248, or 249. Since the scalar values

12.7. Simpliﬁcation of Contour Trees
417
247
248
248
248
248
248
248
248
248
249
249
249
249
249
249
249
249
Figure 12.22. Part of the full contour tree of the nucleon data set. Tree nodes contain
the scalar values of the associated isosurface component.
in the data set vary from 0 to 249, the diﬀerence between 247, 248, and 249 is
insigniﬁcant. Thus these nodes can all be collapsed into a single node, as is done
in Figure 12.4(a).
Another metric is the size of the region bounded by the isosurface component.
The number of grid vertices in a region is a good approximation to its size. Each
contour tree node is associated with a region in the mesh or grid and a set of
mesh or grid vertices contained in that region. Remove leaves whose associated
vertices are fewer than a certain threshold.
Figure 12.23 shows a full contour tree of the hydrogen atom data set. Each
node represents some connected component in an isosurface. It contains the
number of grid vertices in a region bounded by that component. Two leaves
have fewer than 200 vertices in their associated regions. These leaves represent
connected components near the boundary that separate a small number of grid
vertices from the rest of the grid. These leaves were eliminated from the hydrogen
atom contour tree previously shown in Figure 12.3(a).
Connected components of isosurfaces that pass through grid vertices corre-
spond to nodes of the fully augmented join tree and the fully augmented split
tree. The number of grid vertices in the region bounded by such a component is
the number of nodes in the subtree rooted at the corresponding node in the join

418
12. Contour Trees
804636
509907
17
686152
197
214697
57030
57038
58781
Figure 12.23. The full contour tree of the hydrogen atom data set. Each node contains
the number of grid vertices in an associated region.
or split tree. The number of nodes in all such subtrees can be computed in linear
time. Thus, the number of grid vertices in the region bounded by a component
can be computed in linear time.
Carr, Snoeyink, and van de Panne in [Carr et al., 2004] discuss other mea-
sures that can be used for contour tree simplication. They also give an explicit
algorithm for simplifying the contour trees under these metrics.
12.8
Applications
Contour trees contain a wealth of information about scalar ﬁelds. As shown in
Figures 12.3 and 12.4, they show how isosurfaces change as the isovalue changes.
They also show the relationship between isosurfaces of diﬀerent scalar values.
Contour trees can be used to select isovalues. Isovalues at joins or splits in the
contour tree produce joins or splits of connected components in the isosurface.
These isovalues may warrant further investigation. On the other hand, there
are no joins or splits of the connected components represented by a contour tree
edge. The isosurface component from a single isovalue chosen along that contour
edge may suﬃce to represent all the components represented by that edge.

12.8. Applications
419
Contour trees do not model geometric changes in the isosurface. They also
do not model the creation of tunnels in the isosurface, although such information
can be added to the contour tree. (See [Pascucci and Cole-McLaughlin, 2002].)
Thus, there are limits on the information provided by contour trees and on their
ability to indicate all signiﬁcant isovalues.
In Section 8.4, we discussed constructing an isosurface by starting from a
seed set of grid cubes, determining which elements of the seed set intersect the
isosurface, and propagating the isosurface from those cube. A key problem is to
ﬁnd a small or the smallest complete seed set of grid cubes that intersects every
connected component of every isovalue.
A grid vertex v with scalar value sv is contained in some connected component
of the isosurface with isovalue sv. Grid vertex v maps to the point χ(v) in the
contour tree corresponding to this connected component. A grid edge e = (v0, v1)
maps to the path ζe from χ(v0) to χ(v1) in the contour tree. A grid cube c has
a vertex v0 with minimum scalar value and a vertex v1 with maximum scalar
value. Cube c maps to the path ζc from χ(v0) to χ(v1) in the contour tree. A
complete seed set of grid cubes corresponds to a set C of grid cubes such that
{ζc : c ∈C} covers the entire contour tree. A minimal complete seed set is a
minimal covering of the contour tree by the ζc. Van Kreveld et al. [van Kreveld
et al., 1997] solve the minimal covering problem to construct a minimal complete
seed set.
The seed set constructed by van Kreveld et al. [van Kreveld et al., 1997]
may contain a large number of seeds scattered across the grid. In a diﬀerent
approach, Carr and Snoeyink [Carr and Snoeyink, 2003] show that seed sets
for connected components corresponding to a contour tree edge can be quickly
constructed from the seed set for the connected components corresponding to the
edge endpoints. The seed set is the set of cubes intersected by a path in the grid
from grid vertex v0 to grid vertex v1 where χ(v0) is one endpoint of the contour
tree edge and χ(v1) is another. To construct an isosurface for a given isovalue,
determine all the contour tree edges whose span contains the isovalue, construct
the seed sets corresponding to those edges, and propagate the isosurface from
those seed sets.
Contour trees can also be used to select and reconstruct individual connnected
components of an isosurface [Carr and Snoeyink, 2003]. Each contour tree edge
corresponds to a seed set. A point on the contour tree edge corresponds to an
isosurface component intersecting a grid cube in that seed set. Select a point with
scalar value σ on some contour tree edge, construct the seed set corresponding
the contour tree edge, ﬁnd the grid cube whose span contains σ, and propagate
the isosurface from that grid cube.
The correspondence between contour tree edges and connected components
allows one to select or deselect individual isosurface components for display.
Moreover, one can also simultaneously select and display connected components
from isosurfaces with diﬀerent isovalues.

420
12. Contour Trees
1
10
100
1000
10000
100000
0
200
400
600
800
1000
1200
Num components
1e–08
1e–07
1e–06
1e–05
0.0001
0.001
0.01
0.1
1
0
200
400
600
800
1000
1200
Num components
Scalar frequency
(a)
(b)
Figure 12.24. Tooth data set. (a) Number of connected components. (b) Number of
connected components (normalized) and scalar frequencies (normalized).
In the previous section, we discussed contour tree simpliﬁcation. Contour
tree simpliﬁcation can be used to simplify isosurfaces. Removing leaves and their
incident edges from the contour tree corresponds to removing the corresponding
connected components from the isosurface. Each point in the simpliﬁed contour
tree corresponds to a connected component of some isosurface. Extending the
approach in [Carr and Snoeyink, 2003], Carr et al. [Carr et al., 2004] show how
to ﬁnd a grid cube that intersects that component from the simpliﬁed contour
tree.
Finally, contour trees can be used to count the number of components even
in complex or noisy data set. Figure 12.24(a) contains a plot of the number of
components as a function of the scalar value for the tooth data set. The plot was
produced by ﬁrst constructing the contour tree for the data set and then comput-
ing the number of contour tree edges intersecting scalar values from 0 to 1,300.
Scalar values with large numbers of components correspond to noisy isosurfaces.
The peaks correspond to the peaks in the graph of the scalar frequencies. (See
Figure 12.24(b).)
12.9
Notes and Comments
Boyell and Ruston described contour trees in [Boyell and Ruston, 1963] and used
them to represent contour lines on 2D terrains. Van Kreveld et al. [van Kreveld
et al., 1997] gave an algorithm to compute contour trees of 2D scalar meshes in
Θ(N log N) time algorithm where N is the number of mesh elements. Tarasov
and Vyalyi [Tarasov and Vyalyi, 1998] showed how to compute contour trees in
3D scalar meshes.
The algorithms in Sections 12.4 and 12.5 are from [Carr et al., 2003] by
Carr, Snoeyink, and Axen.
The algorithm computes contour trees for scalar

12.9. Notes and Comments
421
meshes in any dimension and runs in Θ(n log n + Nα(N)) time where n is the
number of mesh vertices and N is the number of mesh simplices. The function
α(n) is the inverse of the Ackermann function and grows very slowly. Carr and
Snoeyink [Carr and Snoeyink, 2009] show how the contour tree algorithm can
be modiﬁed to model the variation in isosurface topology produced by diﬀerent
isosurface construction algorithms. Pascucci and Cole-McLaughlin [Pascucci and
Cole-McLaughlin, 2002] add the computation of Betti numbers to the algorithm
in [Carr et al., 2003].
Pascucci and Cole-McLaughlin [Pascucci and Cole-McLaughlin, 2002] present
an algorithm for constructing contour trees that runs in Θ(n+k log k) time where
k is the number of “critical” points. Chiang et al. [Chiang et al., 2005] give an
algorithm that runs in Θ(n+k′ log k′) time where k′ is the number of “component
critical” mesh vertices. (See the references for the deﬁnitions of “critical” and
“component critical.”) Both papers improved the running time of [Carr et al.,
2003] by reducing the time to construct join and split trees.
Van Kreveld et al. [van Kreveld et al., 1997] and Carr and Snoeyink [Carr
and Snoeyink, 2003] use contour trees to construct small seed sets. Carr et al.
in [Carr et al., 2004] discuss techniques for simplifying contour trees. Cox et
al. [Cox et al., 2003] use an augmented split tree to partition the scalar data into
“topological zones” and reduce I/O and disk seek times in constructing isosurface
on large data sets. (They call the split tree a “criticality tree”.)
Contour trees are special cases of Reeb graphs deﬁned by and named after
Georges Reeb [Reeb, 1946]. Algorithms for computing Reeb graphs are in [Shi-
nagawa and Kunii, 1991,Cole-McLaughlin et al., 2003,Doraiswamy and Natara-
jan, 2008,Doraiswamy and Natarajan, 2009,Pascucci et al., 2007,Tierny et al.,
2009,Harvey et al., 2010,Parsa, 2012].

This page intentionally left blank
This page intentionally left blank

APPENDIX A
GEOMETRY
A.1
Afﬁne Hull
A set of points X ⊆Rd is an afﬁne subspace of Rd if, for every pair of points
p1, p2 ∈X, the line through p1 and p2 is in X.
Equivalently, X is an afﬁne
subspace if, for every ﬁnite subset {p1, . . . , pk} ⊆X, set X contains the set
{α1p1 + α2p2 + . . . + αkpk : α1, α2, . . . , αk ∈R and α1 + α2 + . . . + αk = 1}.
Examples of aﬃne subspaces are a point, a line, a plane, or a hyperplane.
Each aﬃne subspace X ⊆Rd is congruent to Rk for some k, i.e., there is a
one-to-one and onto mapping of X to Rk that preserves distances between points.
The dimension of X is k where X is congruent to Rk.
The afﬁne hull of a set X ⊆Rd is the smallest aﬃne subspace containing X.
Equivalently, the afﬁne hull of a set X ⊂Rd is the set
{α1p1 + α2p2 + . . . + αkpk : {p1, p2, . . . , pk} is a ﬁnite subset of X and
α1, α2, . . . , αk ∈R and α1 + α2 + . . . + αk = 1}.
A ﬁnite set P of points is in general position if, for every p ∈P, the aﬃne hull
of P −{p} does not contain p. Equivalently, a set P of k + 1 ≤d + 1 points is
in general position in Rd if no k-dimensional aﬃne subspace of Rd contains P.
A.2
Convexity
A set of points X ⊆Rd is convex if, for every pair of points p1, p2 ∈X, the line
segment from p1 to p2 is in X. Equivalently, X is convex if, for every ﬁnite subset
423

424
A. Geometry
{p1, . . . , pk} ⊆X, set X contains the set
{α1p1 + α2p2 + . . . + αkpk : α1, α2, . . . , αk ∈R and α1 + α2 + . . . + αk = 1 and
α1, α2, . . . , αk ≥0}.
Examples of convex sets are a line segment, a triangle, a tetrahedron, or a cube.
Other examples of convex sets are the area bounded by a circle or ellipse in R2
or the volume bounded by a sphere or ellipsoid in R3. Note that every aﬃne
subspace is convex.
The convex hull of a set X ⊆Rd is the smallest convex set containing X.
Equivalently, the convex hull of a set X ⊂Rd is the set
conv(X) = {α1p1+α2p2 + . . . + αkpk :
(A.1)
{p1, p2, . . . , pk} is a ﬁnite subset of X and
α1, α2, . . . , αk ∈R and α1 + α2 + . . . + αk = 1 and
α1, α2, . . . , αk ≥0}.
The convex hull of X is contained in the aﬃne hull of X.
A.3
Convex Polytope
A convex polytope c is the convex hull of a ﬁnite set of points P in Rd. Examples
of convex polytopes are a triangle, a tetrahedron, or a cube. The dimension of a
convex polytope c is the dimension of the aﬃne hull of c. A three-dimensional
convex polytope is called a convex polyhedron.
A vertex of a convex polytope c is a point p ∈c such that conv(c −{p}) does
not equal c. If P is a ﬁnite point set and V is the set of vertices of the convex
polytope conv(P), then V is a subset of P. Thus, a convex polytope has a ﬁnite
set of vertices.
Let c be a convex polytope and let V be its set of vertices. The (polytope)
interior of c is the set
int(c) = {α1p1+α2p2 + . . . + αkpk :
(A.2)
{p1, p2, . . . , pk} is a ﬁnite subset of P and
α1, α2, . . . , αk ∈R and α1 + α2 + . . . + αk = 1 and
α1, α2, . . . , αk > 0}.
Note the diﬀerence from Equation A.1. In Equation A.1, each αi is greater than
or equal to zero. In Equation A.2, each αi is strictly greater than zero.
The (polytope) boundary of c, denoted ∂c, is all the points not on the interior
of c, i.e., c −int(c).

A.4. Simplex
425
Let c be a convex polytope and let V be its set of vertices. A face of c is
conv(V ′) where V ′ is a subset of V and the aﬃne hull of V ′ does not intersect
conv(V −V ′). A d-face of c is a d-dimensional face of c. The convex polytope c
is a face of itself. The proper faces of c are the faces of c except for c.
A hyperplane h supports a convex polytope c if h intersects c and one of the
closed half-spaces bounded by h contains c. Set f is a face of c if and only if f
equals h ∩c for some supporting hyperplane h of c.
A.4
Simplex
A simplex is the simplest type of convex polytope.
A k-simplex in Rd is the
convex hull of a set of k + 1 ≤d + 1 points in general position in Rd. The
points are called the simplex vertices. A triangle is a 2-simplex. A tetrahedron is a
3-simplex.
The faces of a k-simplex t are the convex hulls of all subsets of the vertices
of t. Simplex t is a face of itself. The proper faces of a k-simplex t are the convex
hulls of all proper subsets of the vertices of t. Equivalently, the proper faces of
t are the faces of t except for t.
The boundary of a simplex t, denoted ∂t, is the union of all its proper faces.
The interior of a simplex t, denoted int(t), is all the points not in the boundary
of t, i.e., t −∂t. Note that the simplex vertices, simplex boundary, and simplex
interior of a simplex t are the same as the polytope vertices, polytope boundary,
and polytope interior of t.
A.5
Barycentric Coordinates
Let {p1, . . . , pd+1} be a set of d+1 points in general position in Rd. For each point
q ∈Rd and scalar values α1, . . . , αd+1 ∈R consider the set d + 1 of equations:
d+1

i=1
αipi
=
q,
(A.3)
d+1

i=1
αi
=
1.
(A.4)
Note that Equation A.3 represents d separate equations. Equations A.3 and A.4
are d + 1 equations in d + 1 unknowns αi ∈R. Since the points pi are in general
position, these equations are independent and have a single unique solution. The
set α1, . . . , αd+1 satisfying these equations are called the barycentric coordinates
of point q.

426
A. Geometry
A.6
Linear Function
A function μ : Rd →R is linear if it can be written as
μ(x1, x2, . . . , xd) = a1x1 + a2x2 + . . . + adxd
for some scalar constants a1, a2, . . . , ad ∈Rd.
Let {p1, . . . , pd+1} be a set of d + 1 points in general position in Rd where
each pi is associated with a scalar si. The scalar values si determine a linear
function μ : Rd →R deﬁned as
μ(q) =
d+1

i=1
αisi,
where (α1, . . . , αd+1) are the barycentric coordinates of q.
Note that μ(pi)
equals si.
A function μ : Rd →R is aﬃne if it can be written as μ(x1, x2, . . . , xd) =
a0 + a1x1 + a2x2 + . . . + adxd for some scalar constants a0, a1, a2, . . . , ad ∈Rd.
Let X and Y be subsets of Rd. An afﬁne transformation is an aﬃne function μ
such that μ(X) equals Y.
A.7
Congruent and Similar
Two convex polytopes in Rd are congruent if they have the same shape and size.
More speciﬁcally, convex polytope c1 is congruent to convex polytope c2 if there
is a sequence of translations, rotations, and reﬂections that transforms c1 into c2.
Two convex polytopes in Rd are similar if they have the same shape. More
speciﬁcally, convex polytope c1 is similar to convex polytope c2 if c1 can be scaled
uniformly in all directions into a polytope c′
1 such that c′
1 is congruent to c2.

APPENDIX B
TOPOLOGY
B.1
Interiors and Boundaries
The (topological) interior of a set of points X ⊆Rd, denoted int(X), is the points
of X that have neighborhoods contained in X. The (topological) boundary of a set
X ⊆Rd, denoted ∂X, is the set of points of cl(X), the closure of X, that do not
have neighborhoods contained in X. Formally,
int(X)
=
{p ∈X : Np ⊆X for some neighborhood Np of p},
∂X
=
cl(X) −int(X)
=
{p ∈cl(X) : Np ̸⊆X for any neighborhood Np of p}.
Note that by deﬁnition int(X) is a subset of X.
The topological boundaries and interiors of set P depends on the ambient
space Rd containing X. If X is a two-dimensional disk in R2, then ∂X is a circle
and int(X) is the open two-dimensional disk bounded by this circle. However, if
X is a two-dimensional disk in R3, then all points in X are on the boundary of
X and int(X) is the empty set.
To deﬁne a variation of interior and boundary that is independent of the
ambient space Rd, we use the aﬃne hull. As deﬁned in Appendix A, Section A.1,
the afﬁne hull of a set X ⊆Rd of points is the smallest aﬃne subspace containing
X. The relative interior of a set X ⊆Rd, denoted relint(X), is the set of all points
p ∈X with some neighborhood Np such that Np ∩aﬀ(X) ⊆X.
The relative
boundary of X, denoted relbnd(X), is the set of points in cl(X) that are not in
relint(X). Formally,
relint(X) = {p ∈X : Np ∩aﬀ(X) ⊆X for some neighborhood Np of p},
relbnd(X) = cl(X) −relint(X).
427

428
B. Topology
If c is a convex polytope, then the polytope boundary and polytope interior of
c as deﬁned in Appendix A, Section A.3, are the relative boundary and relative
interior, respectively, of c.
The following two lemmas relate the closure and interior of a point set X.
Lemma B.1. For any closed set X ⊆Rd,
cl(int(X)) ⊆X.
Proof: Let p be a point in cl(int(X)). Since p is in cl(int(X)), there is an inﬁnite
sequence q1, q2, . . . of points qi ∈int(X) such that
lim
n→∞qi = p.
Since int(X) is a subset of X, each qi is in X. Since X is closed, point p is in X.
Thus, cl(int(X)) is a subset of X.
□
Lemma B.2. Let Y1 be a closed subset of X ⊆Rd. If Y2 equals cl(int(Y1)), then
cl(X −Y1) equals cl(X −Y2).
Proof: By Lemma B.1, set Y2 is a subset of Y1. Thus X −Y1 is a subset of Y2
and so cl(X −Y1) is a subset of cl(X −Y2).
Let p be a point in cl(X −Y2). Since p is in cl(X −Y2), for every ϵ > 0, there
is a point q ∈X −Y2 = X −cl(int(Y1)) that is distance at most ϵ/2 from p. Let
Nq be the set of all points in X at distance at most ϵ/2 from q. Since q is not
an element of int(Y1), set Nq is not a subset of Y1. Thus there exists a q′ ∈Nq
such that q′ is not in Y1. Since the distance from q′ to q is at most ϵ/2 and the
distance from q to p is at most ϵ/2, the distance from q′ to p is at most ϵ. For
every ϵ there is a point q′ ∈X −Y1 at distance at most ϵ from p. Thus point p
is in cl(X −Y1) and cl(X −Y2) is a subset of cl(X −Y1).
Since cl(X −Y1) is a subset of cl(X −Y2) and cl(X −Y2) is a subset of
cl(X −Y1), set cl(X −Y1) equals cl(X −Y2).
□
B.2
Homeomorphism
Let X and Y be subsets of Rd. Function μ : X →Y is a homeomorphism from
X to Y if μ is continuous, one-to-one, and onto and has continuous inverse μ−1.
Two spaces, X and Y, are homeomorphic if there is a homeomorphism from X to
Y.
A (closed) topological ball is a set X that is homeomorphic to a closed ball
Bd. The dimension of the topological ball is d. A simple curve is a set X that is

B.3. Manifolds
429
homeomorphic to the unit interval [0, 1]. A simple closed curve is a set X that is
homeomorphic to the unit circle {(x, y) : x2 + y2 = 1}.
If X is closed and bounded and μ is continuous, one-to-one, and onto, then
μ−1 is continuous and μ is a homeomorphism.
Lemma B.3. Let X and Y be subsets of Rd.
If X is closed and bounded, and
μ : X →Y is continuous, one-to-one, and onto, then μ is a homeomorphism
from X to Y.
Proof: Let (y1, y2, y3, . . .) be a sequence of points in Y that approach some limit
point y ∈Rd. Since μ is one-to-one, it has an inverse function μ−1 : Y →X.
Let xi equal μ−1(yi).
Since X is closed and bounded, some subsequence of
(x1, x2, x3, . . .) approaches a limit point x ∈X. Since μ is continuous, the cor-
responding subsequence of (μ(x1), μ(x2), μ(x3), . . .) approaches μ(x). However,
(μ(x1), μ(x2), μ(x3), . . .) equals (y1, y2, y3, . . .), which approaches y. Thus μ(x)
equals y. Since μ is onto, point y is in Y. Since the subsequence (y1, y2, y3, . . .)
approaches point y ∈Y and (μ−1(y1), μ−1(y2), μ−1(y3), . . .) approaches x =
μ−1(y), function μ−1 is continuous. Since μ is continuous, one-to-one, and onto
and μ−1 is continuous, function μ is a homeomorphism.
□
B.3
Manifolds
A k-dimensional manifold (k-manifold) is a set of points whose local topology is
the same as Rk. A simple closed curve is a 1-manifold while a two-dimensional
surface such as a sphere is a 2-manifold. Formally, a k-manifold M is a topo-
logical space such that for every point p ∈M, some open neighborhood of p is
homeomorphic to Rk.
A k-manifold with boundary is a set of points whose local topology is either
the same as Rk or as some half-space in Rk. A half-space in R3 or a ball in R3
are examples of manifolds with boundary. Let Rk+ be the half-space consisting
of all points whose last coordinate is greater than or equal to zero. A k-manifold
with boundary, labeled M, is a topological space such that for every point p ∈M,
some open neighborhood of p is either homeomorphic to Rk or homeomorphic
to Rk+.
The (manifold) interior of M, denoted int(M), is the set of points p ∈M such
that some open neighborhood of p is homeomorphic to Rk. The (manifold) bound-
ary of M, denoted ∂M, is the set of points p ∈M such that a homeomorphism
maps p to the origin and some neighborhood of p to Rk+.
The topological interior and boundary of a manifold M can diﬀer from the
manifold interior and boundary of M.
For instance, if M is the unit disk
{(x, y, 0) : x2 + y2 ≤1} lying in the xy-plane in R3, then the topological
interior of M is the empty set, while the manifold interior is the open disk

430
B. Topology
{(x, y, 0) : x2 + y2 < 1}. The topological boundary of M is all of M while the
manifold boundary interior is the circle {(x, y, 0) : x2 + y2 = 1}. If M is a k-
manifold whose aﬃne hull has dimension k, then the relative interior of M equals
the manifold interior of M and the relative boundary of M equals the manifold
boundary of M.
Every convex polytope c is a manifold with boundary. The polytope dimen-
sion of convex polytope c as deﬁned in Appendix A, Section A.3, equals the
manifold dimension of c. The polytope interior and boundary of c equal the
manifold interior and boundary of c.
Every k-simplex t is a k-manifold with boundary. The simplex interior and
boundary of t equal the manifold interior and boundary of t.
B.4
Triangulations
As deﬁned in Appendix A, Section A.4, a k-simplex in Rd is the convex hull of a
set of k + 1 ≤d + 1 points in general position in Rd.
Deﬁnition B.4. A triangulation τ is a set of simplices such that for every pair of
simplices t, t′ ∈τ, the intersection, t ∩t′, is either empty or a face of each
simplex.
Mathematics texts usually add a formal requirement to Deﬁnition B.4 that
if simplex t is in τ, then every face of t is in τ. Since we represent the triangu-
lation of a d-dimensional region by a set of d-dimensional simplices, it is more
convenient not to include this requirement in the deﬁnition. A triangulation τ
can always be made to conform to this requirement by adding to τ all faces of
all simplices in τ.
The set 
t∈τ t is denoted by |τ|. It is the set of all points in all simplices
of τ. We refer to τ as a triangulation of a space X ⊆Rd if X equals |τ|. A
tetrahedralization of a space X ⊆Rd is a triangulation of X whose simplices are a
set of tetrahedra (3-simplices) and their faces.
A set X ⊆Rd is piecewise linear if X has some triangulation.
B.5
Convex Polytopal Meshes
As deﬁned in Appendix A, Section A.3, a convex polyhedron is the convex hull of
a ﬁnite set P of points in R3, and a convex polytope is the convex hull of a ﬁnite
set P of points in Rd.

B.6. Orientation
431
Deﬁnition B.5. A convex polytopal mesh Γ is a set of convex polytopes in Rd such
that for every pair of convex polytopes c, c′ ∈Γ, the intersection, c∩c′, is either
empty or a face of each convex polytope.
Mathematics texts usually add a formal requirement that if convex polytope
c is in Γ, then every face of c is in Γ.
The set 
c∈Γ c is denoted by |Γ|. It is the set of all points in all polyhedra
in Γ.
A convex polytopal mesh in R3 is called a convex polyhedral mesh. A tetrahe-
dral mesh is a convex polytopal mesh where every mesh element is a tetrahedron.
By deﬁnition, a convex polytopal mesh where every mesh element is a simplex
is a triangulation. It is also sometimes called a simplicial mesh.
B.6
Orientation
Let v1, v2, . . . , vk+1 be the vertices of a k-simplex t. There are (k + 1)! permu-
tations of the vertices of t. A transposition of a permutation is the exchange of
two elements of the permutation. For instance, given permutation (v1, v2, v3, v4),
the transposition of v2 and v4 gives the permutation (v1, v4, v3, v2). Given any
permutation, we can generate any other permutation by a sequence of transpo-
sitions.
Let permutations Z1 and Z2 of the vertices of t be equivalent if the number
of transpositions needed to transform Z1 into Z2 is even. This equivalence de-
termines two equivalence classes on the set of all permutations of the vertices of
t. These two equivalence classes are called the two orientations of t. A permuta-
tion Z of the vertices of t determines an orientation of t, namely the equivalence
class containing Z. An oriented simplex is a simplex with a given orientation. The
simplex and orientation is deﬁned by giving some permuation of the vertices of
the simplex.
The facets of a k-simplex are (k−1)-simplices. The orientation of a k-simplex
t induces an orientation of its facets as follows. Without loss of generality, as-
sume that the orientation of t is given by the permutation (v1, v2, . . . , vk+1). (If
not, relabel the vertices so that the orientation of t is given by this permuta-
tion.)
A facet of t has all the same vertices as t except for one, vj. If j is
odd, then the induced orientation of the facet is the orientation that contains
the permutation (v1, v2, . . . , vj−1, vj+1, . . . , vk+1). If j is even, then the induced
orientation of the facet is the orientation that does not contain the permutation
(v1, v2, . . . , vj−1, vj+1, . . . , vk+1).
Let t1 and t2 be two oriented k-simplices that share a common facet f. The
orientations of t1 and t2 are consistent if the orientation of f induced by t1 is the
opposite of the orientation of f induced by t2.

432
B. Topology
The orientation of an oriented d-simplex t = (v1, . . . , vd+1) in Rd can be
calculated using determinants. Let (v1
i , v2
i , . . . , vd
i ) be the coordinates of vertex
vi. Deﬁne the determinant of (v1, . . . , vd+1) as
det(v1, . . . , vd+1) = det
⎛
⎜
⎜
⎜
⎝
v1
1
v2
1
. . .
vd
1
1
v1
2
v2
2
. . .
vd
2
1
...
...
...
...
v1
d+1
v2
d+1
. . .
vd
d+1
1
⎞
⎟
⎟
⎟
⎠.
Since the vertices of t are in general position, this determinant is nonzero. Per-
mutations of the vertices of t that have the same orientation produce the same
values for this determinant. Permutations of the vertices of t that have the op-
posite orientation produce the value (−det(v1, . . . , vd+1)) for this determinant.
Thus, the sign of the determinant indicates the orientation of the simplex.
If the sign of det(v1, . . . , vd+1) is positive, then we say that t has positive
orientation.
If the sign of det(v1, . . . , vd+1) is negative, then t has negative
orientation.
The orientation, (v1, . . . , vd), of a (d−1)-simplex t in Rd determines a vector
orthogonal to t. In R3, this vector is u = (v2 −v1) × (v3 −v1) where × denotes
the cross product. Note that other permutations of (v1, v2, v3) that represent
the same orientation generate the same vector u. Permutations that represent
the opposite orientation generate the vector −u.
In Rd, construct the (d−1)×d matrix A = {aij} whose ith row is vi−v1. Let
Cij be the cofactor of aij in A. The orientation (v1, . . . , vd) determines the vector
u = (C11, C22, . . . , Cdd) that is orthogonal to t. Vector u is called the generalized
cross product of ((v2 −v1), (v3 −v1), . . . , (vd −v1)). Again, any other permutation
of (v1, . . . , vd) that represents the same orientation generate the same vector u.
Permutations that represent the opposite orientation generate the vector −u.
B.7
Piecewise Linear Functions
Let {p1, . . . , pd+1} be a set of d + 1 points in general position in Rd where each
pi is associated with a scalar si. As deﬁned in Appendix A, Section A.6, the
scalar values si determine a linear function μ : Rd →R deﬁned as
μ(q) =
d+1

i=1
αisi,
where (α1, . . . , αd+1) are the barycentric coordinates of q.

B.8. Paths and Loops
433
A scalar simplicial mesh is a simplicial mesh where each simplex vertex vi is
associated with a scalar values si.
Let Γ be a scalar simplicial mesh in Rd.
Within each simplex of tj ∈Γ, the scalar values at the vertices of tj determine
a linear function μj on tj. When two simplices tj and tj′ share a common face
f, the piecewise linear functions μj and μj′ agree on f. Putting all the linear
functions μj together gives a function φ where
φ(q) = μj(q) if q ∈tj.
Function φ is the piecewise linear function determined by the scalar simplicial
mesh Γ.
B.8
Paths and Loops
A path ζ connecting p ∈Rd to q ∈Rd is a continuous map ζ from the unit interval
[0, 1] to Rd such that ζ(0) equals p and ζ(1) equals q. If ζ is a homeomorphism,
then the image of ζ is a simple curve in Rd and thus a 1-manifold with boundary.
The interior of a path ζ is the set {ζ(α) : 0 < α < 1}, i.e., the image of ζ
restricted to the open interval (0, 1). When ζ is a homeomorphism, the interior
of path ζ is the same as the manifold interior of ζ[0, 1].
The interior of path ζ is usually not the same as the topological interior of
ζ([0, 1]) ⊂Rd. For instance, if ζ : [0, 1] →R2 is
ζ(α) = (α, α2),
then the topological interior of ζ([0, 1]) is the empty set, while the interior of
path ζ is {(α, α2) : 0 < α < 1}.
Let ζ1 : [0, 1] →Rd and ζ2 : [0, 1] →Rd be two paths where the last point
p in ζ1 is the ﬁrst point in ζ2, i.e., ζ1(1) equals ζ2(0). These two paths can be
joined at p to form a new path denoted ζ2 ◦ζ1. Formally, ζ2 ◦ζ1 is deﬁned as a
path ζ : [0, 1] →Rd where
ζ(α) =
⎧
⎨
⎩
ζ1(2 ∗α)
if α ∈[0, 1/2],
ζ2(2 ∗α −1)
if α ∈(1/2, 1].
Note that ζ is continuous since both ζ1(2 ∗(1/2)) and ζ2(2 ∗(1/2) −1) equal p.
A loop ζ in Rd is a continuous map ζ from the unit circle S1 to Rd.
If
ζ : S1 →Rd is a homeomorphism, then ζ(S1) is a simple closed curve in Rd and
thus a 1-manifold.

434
B. Topology
B.9
Separation
Let X and Y be subsets of Rd.
Deﬁnition B.6.
• Set X separates point p ∈Y from point q ∈Y if every path in Y connecting
p to q intersects X.
• Set X strictly separates p from q if X separates p from q and neither p nor q
is in X.
Deﬁnition B.7.
• Set X separates Y2 ⊆Y from Y3 ⊆Y if X separates every p ∈Y2 from
every q ∈Y3.
• Set X strictly separates Y2 ⊆Y from Y3 ⊆Y if X separates Y2 from Y3 and
does not intersect Y2 or Y3.
Lemma B.8. Let Y1 be a closed subset of Rd and let Y2 be a closed subset of Y1.
Set X = Y2 ∩cl(Y1 −Y2) separates Y2 from Y1−Y2 and strictly separates Y2 −X
from Y1 −Y2.
Proof: Let ζ ⊂Y1 be a path from Y1 −Y2 to Y2.
Let p be the ﬁrst point
along ζ that lies in Y2. Since Y2 is closed, there is such a ﬁrst point p. Since
all points preceding p are in Y1 −Y2, point p is in cl(Y1 −Y2). Thus p is in
Y2 ∩cl(Y1 −Y2) = X and X separates Y2 from Y1 −Y2. Since X does not
intersect Y1 −Y2 or Y2 −X, set X strictly separates Y2 −X from Y1 −Y2.
□
Corollary B.9. Let Y be a subset of Rd. The boundary ∂Y of Y strictly separates
int(Y) from Rd −Y.
Proof: By Lemma B.8, set X = Y ∩cl(Rd −Y) strictly separates Y −X from
Rd −Y. Set X is a subset of ∂Y, so ∂Y strictly separates Y −X from Rd −Y.
Since int(Y) is a subset of Y−X, the boundary ∂Y strictly separates int(Y) from
Rd −Y.
□
B.10
Compact
A subset X of Rd is compact if X is closed and bounded.
A cover of X is a
collection C of subsets of Rd such that 
Y∈C Y contains X. A subcover of C is a
cover of X that is a subset of C.

B.11. Connected
435
A cover C of X can contain an inﬁnite and even uncountable number of
subsets. A ﬁnite subcover of C is a subcover of C that has a ﬁnite number of
elements. Proof of the following theorem can be found in [Armstrong, 1983] or
any introductory text in point set topology.
Theorem B.10. A set X is compact if and only if every cover of X by a collection
of open sets has a ﬁnite subcovering.
The conclusion of Theorem B.10 is often used as the deﬁnition of compact, i.e.,
a set X is compact if every cover of X by a collection of open sets has a ﬁnite
subcovering. Under this deﬁnition of compactness, a related theorem is that a
set X ⊂Rd is compact if and only X is closed and bounded.
B.11
Connected
Let X be a subset of Rd. Set X is connected if, for any pair of points p, q ∈X,
there is a path from p to q in X. A connected component of X is a maximal
connected subset of X, i.e., a connected subset of X that is not contained in
any other connected subset of X. Every subset of Rd can be partitioned into
connected components.
B2 is the closed unit disk (ball) in R2. Let Y1 and Y2 be subsets of B2 and let
p and q be points in ∂B2 ∩Y1 ∩Y2. Lemma B.11 gives conditions under which
points p and q are in the same connected component of Y1 ∩Y2.
Because we make no assumptions about Y1 and Y2, the proof of Lemma B.11
is a bit technical.
Lemma B.11. Let Y1 and Y2 be subsets of the unit disk B2 where
cl(Y1) ∩cl(B2 −Y1) ∩cl(Y2) ∩cl(B2 −Y2) = ∅.
(B.1)
If p and q are distinct points on ∂B2, the boundary of B2 where one of the arcs
of ∂B2 from p to q is contained in Y1 and the other is contained in Y2, then
there is some path from p to q in Y1 ∩Y2.
Proof: By Equation B.1, each point r in B2 is not in cl(Y1), cl(Y2), cl(B2 −Y1),
or cl(B2 −Y2). Since cl(Y1) is closed, if point r is not in cl(Y1), then there
is an disk around r that does not intersect cl(Y1). The same holds for cl(Y2),
cl(B2 −Y1), and cl(B2 −Y2). Thus each point in B2 lies in some open disk that
does not intersect cl(Y1), cl(Y2), cl(B2 −Y1), or cl(B2 −Y2).
The open disks around points in B2 form a covering of B2. Since B2 is closed
and bounded (compact), there is a ﬁnite subset D of the open disks such that D
covers B2 and no disk of D is contained in any other disk of D.
Let d ∈D be a disk that intersects Y1 and Y2. Since d is in D, either d
does not intersect cl(B2 −Y1) or d does not intersect cl(B2 −Y2). If d does

436
B. Topology
p
q
ζ1
ζ2
Figure B.1. Arc ζ1 from p to q is in Y1. Arc ζ2 from p to q is in Y2. Blue curves bound
region Y1 and red curves bound region Y2. Note that Y1 is outside the blue ovals and
Y2 is outside the red oval. Blue and red curves do not intersect.
not intersect cl(B2 −Y1), then d is contained in Y1. If d does not intersect
cl(B2 −Y2), then d is contained in Y2. Thus either d is contained in Y1 or d is
contained in Y2 (or d is contained in both.)
Let D1 ⊆D be the disks in D that are contained in Y1. Let D2 ⊆D be
the disks in D that are contained in Y2. Every open disk that contains p or q
intersects Y1 and Y2. By the previous argument, if an open disk d contains p
or q, then d is either contained in Y1 or contained in Y2 (or contained in both).
Thus d is in D1 ∪D2.
Let ζ1 be the arc of ∂B2 from p to q that is contained in Y1 (Figure B.1).
Let ζ2 be the arc of ∂B2 from p to q that is contained in Y2.
Assume a disk d ∈D1 intersects a disk d′ ∈D2. The boundaries of these two
disks intersect in two points that may or may not be contained in B2. Assume
some point r is in B2 ∩∂d∩∂d′. Since d and d′ are open, they do not contain r.
Thus some other disk d′′ ∈D contains r. Disk d′′ contains a neighborhood of
r so d′′ intersects both d and d′. Thus d′′ intersects both Y1 and Y2. By the
previous argument, d′′ is either contained in Y1 or contained in Y2. Thus d′′ is
in D1 ∪D2.
Similarly, consider a disk d ∈D1 that intersects ζ2 and a point r is in
B2 ∩∂d ∩ζ2.
Since r is not in d, some disk d′′ ∈D contains r.
Since d′′
intersects d ⊆Y1 and ζ2 ⊆Y2, disk d′′ is either contained in Y1 or contained in
Y2 (or contained in both) and is in D1 ∪D2.

B.11. Connected
437
Finally, consider a disk d ∈D2 that intersects ζ1 and a point r in B2∩∂d∩ζ1.
Some disk d′′ ∈D contains r. Disk d′′ is contained in Y1 or Y2 and is in D1∪D2.
Let d be a disk in D1 and d′ be a disk in D2. The sets d ∩d′ and d ∩ζ2 and
d′ ∩ζ1 are all contained in Y1 ∩Y2. Let Z be the union of all such sets over all
d ∈D1 and d′ ∈D2. Formally, deﬁne Z as

d∈D1,d′∈D2

(d ∩d′) ∪(d ∩ζ2) ∪(d′ ∩ζ1)

.
Note that p is in Z since p is in (d ∩ζ2) for some d ∈D1 or p is in (d′ ∩ζ1)
for some d′ ∈D2. Similarly, q is in Z.
We claim that there is a path in Z connecting p to q. Assume that it is not.
Let Zp be the connected component of Z containing p. Since there is no path
from p to q in Zp, some connected component X of cl(Zp)∩cl(B2 −Zp) separates
p from q in B2. To separate p from q, X must intersect both ζ1 and ζ2. Let r1
and r2 be the points on X ∩ζ1 and X ∩ζ2, respectively, that are closest to q. Let
ζ3 be a path in X from r1 to r2.
Since every point in Zp is inside a disk of D1 or D2, set D1 ∩D2 covers Zp.
Some subset of D1 ∪D2 covers ζ3. Let (d1, d2, . . . , dk) be a sequence of disks
from D1 ∪D2 such that  di covers ζ3, set di−1 ∩di intersects ζ3 for i = 2, . . . , k,
set d1 contains r1, and set dk contains rk.
If di−1 was in D1 and di was in D2 or vice versa, then di−1 ∩di would be in
Zp. Since X is in cl(B2 −Zp), set X and path ζ3 would not intersect di−1 ∩di.
Thus all the di are in D1 or all the di are in D2.
If all the di are in D1, then dk ∩ζ2 is in Zp. Since r2 is in dk and dk is open,
there is some point r ∈dk ∩ζ2 that is closer to point q than r2. Since no point
of X ∩ζ2 is closer to q than r2, the arc from r to q does not intersect X. Thus,
r ∈Zp is not separated by X from q, a contradiction. A similar argument gives a
contradiction if all the di are in D2. Thus, cl(Zp) ∩cl(D −Zp) does not separate
p from q and point q is in Zp. Since Zp is a subset of Y1 ∩Y2, there is a path
from p to q in Y1 ∩Y2.
□
Set Z ⊆Rd is simply connected if Z is connected and every loop ζ : S1 →Z
can be extended to a map μ : B2 →Z from the unit disk into Z such that μ
agrees with ζ on every point of S1 = ∂B2.
The following lemma gives conditions under which the intersection of two
connected subsets of a simply connected set are connected.
Lemma B.12. Let Y1 and Y2 be subsets of a simply connected set Z ⊆Rd. If Y1
is connected and Y2 is connected and
cl(Y1) ∩cl(Z −Y1) ∩cl(Y2) ∩cl(Z −Y2) = ∅,
(B.2)
then Y1 ∩Y2 is connected.

438
B. Topology
Proof: Let p and q be points in Y1 ∩Y2. Since Y1 is connected, there is a path
ζ1 ⊆Y1 from p to q. Since Y2 is connected, there is a path ζ2 ⊆Y2 from q to p.
Combining these two loops gives a path ζ = ζ2 ◦ζ1 that starts and ends at p.
Since Z is simply connected, there is a map μ from the unit disk B2 into Z
such that μ agrees with ζ on every point of S1. Some point p′ on S1 maps to p
and some point q′ maps to q. One arc from p′ to q′ maps to ζ1 while the other
arc maps to ζ2. Deﬁne Y′
1 ⊆B2 as {r ∈B2 : μ(r) ∈Y1}. Similarly, deﬁne
Y′
2 ⊆B2 as {r ∈B2 : μ(r) ∈Y2}.
Sets cl(Y′
1) and cl(Y′
2) are subsets of cl(Y1) and cl(Y2), respectively. Sim-
ilarly, cl(B2 −Y′
1) and cl(B2 −Y′
2) are subsets of cl(Z −Y1) and cl(Z −Y′
2),
respectively. Thus if some point r is in cl(Y′
1)∩cl(B2 −Y′
1)∩cl(Y′
2)∩cl(B2 −Y2),
then μ(r) would be in cl(Y1)∩cl(Z−Y1)∩cl(Y2)∩cl(Z−Y2). By Equation B.2,
cl(Y1) ∩cl(Z −Y1) ∩cl(Y2) ∩cl(Z −Y2) is the empty set, so
cl(Y′
1) ∩cl(B2 −Y′
1) ∩cl(Y′
2) ∩cl(B2 −Y2) = ∅.
By Lemma B.11, there is some path ζ′ from p′ to q′ in Y′
1 ∩Y′
2. Mapping
path ζ′ into Z using μ gives a path μ(ζ) from p to q in Y1 ∩Y2. Since there is a
path between every two points in Y1 ∩Y2, set Y1 ∩Y2 is connected.
□
B.12
Homotopy Map
Let X and Y be subsets of Rd. A homotopy map is a continuous function η :
X × [0, 1] →Y. If μ0 : X →Y is the function μ0(x) = η(x, 0) and μ1 : X →Y is
the function μ1(x) = η(x, 1), then η is a homotopy map from function μ0 to function
μ1.
If X is a subset of Y, then the inclusion map, ι : X →Y, is the map ι(x) = x
for all x ∈X. If X0 is a subset of Y and map η is a homotopy map from the
inclusion map ι0 : X0 →Y to some map μ : X0 →Y, then we say that η is a
homotopy map from set X0 to X1 = μ(X0). Equivalently, η is a homotopy map
from set X0 to X1 if η(x, 0) = x for all x ∈X0 and {η(x, 1) : x ∈X0} equals X1.
A constant map is a map μ : X →Y where μ(x) = y for all x ∈X and some
point y ∈Y. A function μ : X →Y is null-homotopic if there is a homotopy map
from μ0 to some constant map.
The identity map on X is μ(x) = x for all x ∈X. A set X is contractible if
the identity map is null-homotopic, i.e., if there is a homotopy map from the
identity map on X to some constant map.
Let η1 : X × [0, 1] →Y and η2 : X × [0, 1] →Y be homotopy maps where
η1(x, 1) equals η2(x, 0) for all x ∈X. Maps η1 and η2 can be combined to form
a new homotopy map, denoted η2 ◦η1, which ﬁrst applies η1 and then applies η2

B.13. Embeddings
439
to X. Formally, η2 ◦η1 is deﬁned as a homotopy map η : X × [0, 1] →Y where
η(x, α) =
 η1(x, 2 ∗α)
if α ∈[0, 1/2],
η2(x, 2 ∗α −1)
if α ∈(1/2, 1].
Note that η is continuous since η1(x, 2 ∗(1/2)) equals η2(x, 2 ∗(1/2) −1) for all
x ∈X.
The following lemma relates the inclusion map ι to another map μp.
Lemma B.13. Let X be a subset of Rd, let p be a point in Rd −X, and let μp :
X →Sd−1 be the map
μp(x) = x −p
|x −p|.
The inclusion map ι : X →Rd −{p} is null-homotopic if and only if μp : X →
Sd−1 is null-homotopic.
Proof: Assume there is a homotopy η : X × [0, 1] →Rd −{p} from the inclusion
map ι : X →Rd −{p} to a constant map. Deﬁne the homotopy η′ : X × [0, 1] →
Sd−1 as
η′(x, α) = μp(η(x, α)).
Since η(x, α) is never equal to p, map η′ is well-deﬁned. Since η(x, 1) is a constant
map, map η′(x, 1) is a constant map. Map η′ is a homotopy map from μp to a
constant map. Thus, if ι is null-homotopic, then μp is null-homotopic.
To prove the converse, assume there is a homotopy η′ : X × [0, 1] →Sd−1
from μp : X →Sd−1 to a constant map. Let μ′
p : X →Rd −{p} be the function
μ′
p(x) = μp(x) + p. Deﬁne the homotopy maps η′′ : X × [0, 1] →Rd −{p} and
η′′′ : X × [0, 1] →Rd −{p} as
η′′(x, α) = (1 −α)(x −p) + αμp(x) + p,
η′′′(x, α) = η′(x, α) + p.
Since (x −p) and μp(x) are nonzero vectors with the same direction, η′(x, α)
is never equal to p. Map η′′ is a homotopy map from the inclusion map ι to
μ′
p. Since η′(x, 1) is a constant map, map η′′′ is a homotopy map from μ′
p to a
constant map. Combining η′′ and η′′′ into a map η = η′′′ ◦η′′ gives a homotopy
map η : X × [0, 1] →Rd −{p} from ι to a constant map. Thus, if μp is null-
homotopic, then ι is null-homotopic.
□
B.13
Embeddings
Let X be a closed, bounded subset of Rd. Set Rd −X has one or more connected
components. One of these components is unbounded. The Borsuk separation

440
B. Topology
theorem gives conditions for a point p ∈Rd −X to be in this unbounded com-
ponent. A proof can be found in [Hocking and Young, 1961, p. 275].
Theorem B.14 (Borsuk separation theorem). Let X be a closed, bounded subset of
Rd and let p be a point in Rd −X. Let μp : X →Sd−1 be the map
μp(x) = x −p
|x −p|.
(B.3)
Map μp is null-homotopic if and only if point p is in the unbounded connected
component of Rd −X.
The following corollary replaces the map μp : X →Sd−1 with the inclusion
map ι : X →Rd −{p}.
Corollary B.15. Let X be a closed, bounded subset of Rd and let p be a point in
Rd −X. The inclusion map ι : X →Rd −{p} is null-homotopic if and only if
point p is in the unbounded connected component of Rd −X.
Proof: Let μ : X →Sd−1 be the map
μp(x) = x −p
|x −p|,
as in Equation B.3. By Lemma B.13, the inclusion map ι : X →Rd −{p} is
null-homotopic if and only if map μp is null-homotopic. By Theorem B.14, the
Borsuk separation theorem, map μp is null-homotopic if and only if point p is
in the unbounded connected component of Rd −X.
Thus the inclusion map
ι : X →Rd −{p} is null-homotopic if and only if point p is in the unbounded
connected component of Rd −X.
□
A second corollary applies the theorem to apply to the separation of two
points in Rd. We ﬁrst deﬁne a mapping φq : Rd −{q} →Rd −{q} that maps the
neighborhood of a point q ∈Rd to points near inﬁnity.
Consider Rd as a subspace of Rd+1. Embed the unit sphere Sd in Rd+1 so
that Rd is a tangent hyperplane to Sd that touches Sd at q. Let q′ ∈Sd be the
point antipodal to q. Rays from q′ through Sd −{q} give a homeomorphism φ′
from Sd −{q′} to Rd. Translate Rd so that it is tangent to Sd at q′, and take
rays from q ∈Sd through Sd −{q} for another homeomorphism φ′′ from Sd −{q}
to Rd. Let φq = φ′′ ◦φ′ be the combination of these homeomorphisms. Function
φq maps the neighborhood of q to points near inﬁnity.
Corollary B.16. Let p and q be points in Rd and let X be a closed, bounded subset
of Rd that does not contain p or q. Points p and q are in the same connected
component of Rd −X if and only if the inclusion map ι : φq(X) →Rd −{φq(p)}
is null-homotopic.

B.13. Embeddings
441
Proof: Let X′ equal φq(X). Since X is closed and bounded, set X′ is closed and
bounded. Points p and q are in the same connected component of Rd −X′ if
and only if point φq(p) is in the unbounded component of Rd −X′. By Corollary
B.15, point φq(p) is in the unbounded component of Rd −X′ if and only if the
inclusion map ι is null-homotopic.
□
A homotopy map η : X × [0, 1] does not pass through point p if p ̸∈η(X, α)
for any α ∈[0, 1].
Let Y be a closed, bounded subset of Rd and let X1 be a closed subset of Y
that strictly separates point p ∈Y from q ∈Y. Let η : X1 × [0, 1] →Rd be a
homotopy map from X1 to X2 that never passes through p or q. The following
three lemmas give conditions under which X2 also strictly separates p from q in
Y. The ﬁrst lemma (Lemma B.17) is the simplest case where Y equals Rd.
Lemma B.17. Let p and q be points in Rd and let X0 be a closed, bounded subset
of Rd that strictly separates p from q. If η : X0 × [0, 1] →Rd is a homotopy
map from X0 to X1 that never passes through p or q, then X1 strictly separates
p from q.
Proof: Points p and q are in diﬀerent connected components of Rd −X0. By
Corollary B.16, the inclusion map ι0 : φq(X0) →Rd −{φq(p)} is not homotopic
to the constant map.
Let ι1 : φq(X1) →Rd −{φq(p)} be the inclusion map of φq(X1) into Rd −
{φq(p)}. Deﬁne a homotopy map η′ : X0 × [0, 1] →Rd from ι0 to ι1 as η′(x, α) =
φq(η(x, α)). Note that φ′(X0, 0) equals φq(X0) and η′(X0, 1) equals φq(X1).
If there was a homotopy map η′′ from ι1 to the constant map, then η′′ ◦η′
would be a homotopy map from ι0 to the constant map. Since ι0 is not homotopic
to the constant map, neither is ι1. By Corollary B.16, points p and q are in
diﬀerent connected components of Rd −X1 and X1 strictly separates p from q.□
Lemma B.17 assumed that X0 separated p and q in Rd. The next lemma
assumes that X0 separates p and q in some Y ⊆Rd, i.e., that any path in Y
connecting p and q intersects X0.
Lemma B.18. Let Y be a closed, bounded subset of Rd, and let X0 be a closed
subset of Y that strictly separates point p ∈Y from point q ∈Y. Let η : X0 ×
[0, 1] →Y be a homotopy map from X0 to X1 = {η(x, 1) : x ∈X0}. If η never
passes through p or q and {η(x, α) : x ∈X0 ∩∂Y} is a subset of ∂Y for all
α ∈[0, 1], then X1 strictly separates p from q.
Proof: Let Yp be the connected component of Y −X0 that contains p. Since Yp
is bounded, it is possible to construct a closed and bounded set Y′
p ⊆Rd such
that Y∩Y′
p equals cl(Yp) and Y∩∂Y′
p is a subset of X0. (See Figure B.2.) Since
Yp is a subset of Y −X0 and Y ∩∂Y′
p is a subset of X0, set Yp is a subset of the
interior of Y′
p. Thus p is in the interior of Y′
p. On the other hand, q is not in Y′
p.
By Corollary B.9, ∂Y′
p strictly separates p from q in Rd.

442
B. Topology
p
q
X0
Y
Yp
Y′
p
Z0
Figure B.2. Red curve X0 strictly separates p from q in Y (region bounded by black
curve). Region Yp (bounded by green curve) is the connected component of Y −X0
containing p. Region Y′
p (bounded by blue curve Z0) is an extension of Yp such that
Y ∩Y′
p equals cl(Yp) and Y ∩∂Y′
p is a subset of X0.
Let Z0 denote ∂Y′
p. Extend η to a homotopy map η′ : Z0 × [0, 1] →Rd that
agrees with η on X0 and always maps Z0−X0 to Rd−Y. More speciﬁcally, η′(x, α)
equals η(x, α) for all x ∈Z0 ∩X0 and α ∈[0, 1], and {η′(x, α) : x ∈Z0 −X0}
is a subset of Rd −Y for all α ∈[0, 1]. Let Z1 equal {η′(x, 1) : x ∈Z0}. By
deﬁnition, Z1 ∩Y equals X1.
Map η′ is a homotopy map from Z0 to Z1 that does not pass through p or
q. Set Z0 strictly separates p from q in Rd. By Lemma B.17, set Z1 strictly
separates p from q in Rd.
Assume there is path ζ ⊆Y from p to q. Set Z1 strictly separates p from q so
path ζ intersects Z1. Since ζ is a subset of Y, path ζ does not intersect Rd −Y
and so must intersect X1 = Z1 ∩Y. Thus X1 strictly separates p from q in Y. □
Lemma B.18 assumed that η(x, α) was a subset of ∂Y for all x ∈X0 ∩∂Y
and α ∈[0, 1]. The next lemma is based on two sets, Y, Y ⊆Rd, where Y ⊆Y.
The lemma assumes that η(x, α) is a subset of Rd −Y for all x ∈X0 ∩∂Y.
Lemma B.19. Let Y and Y be closed, bounded subsets of Rd where Y ⊆Y, let p, q
be distinct points of Y, and let X0 be a closed subset of Y such that p, q ̸∈X0

B.13. Embeddings
443
p
q
X0
Y
Y
Yp
Y′
p
Z0
Figure B.3. Region Y (bounded by magenta curve) is contained in region Y (bounded
by black curve). Red curve X0 strictly separates p from q in region Y (bounded by black
curve). Region Yp (bounded by green curve) is the connected component of Y −X0
containing p. Region Y′
p (bounded by blue curve Z0) is an extension of Yp such that
Y ∩Y′
p equals cl(Yp) and Y ∩∂Y′
p is a subset of X0.
and every path in Y connecting p to q intersects X0. Let η : X0 × [0, 1] →Y be a
homotopy map from X0 to X1 = {η(x, 1) : x ∈X0}. If η never passes through p
or q and {η(x, α) : x ∈X0 ∩∂Y} is a subset of cl(Rd −Y) for all α ∈[0, 1], then
every path from p to q in Y intersects X1 ∩Y.
Proof: Let Yp be the connected component of Y −X0 that contains p. Since Yp
is bounded, it is possible to construct a closed and bounded set Y′
p ⊆Rd such
that Y∩Y′
p equals cl(Yp) and Y∩∂Y′
p is a subset of X0. (See Figure B.3.) Since
Yp is a subset of Y −X0 and Y ∩∂Y′
p is a subset of X0, set Yp is a subset of the
interior of Y′
p. Thus p is in the interior of Y′
p. On the other hand, q is not in Y′
p.
By Corollary B.9, ∂Y′
p strictly separates p from q in Rd.
Let Z0 denote ∂Y′
p. Extend η to a homotopy map η′ : Z0 × [0, 1] →Rd that
agrees with η on X0 and always maps Z0−X0 to Rd−Y. More speciﬁcally, η′(x, α)
equals η(x, α) for all x ∈Z0 ∩X0 and α ∈[0, 1], and {η′(x, α) : x ∈Z0 −X0}
is a subset of Rd −Y for all α ∈[0, 1]. Let Z1 equal {η′(x, 1) : x ∈Z0}. By
deﬁnition, Z1 ∩Y equals X1 ∩Y.

444
B. Topology
Map η′ is a homotopy map from Z0 to Z1 that does not pass through p
or q. Set Z0 strictly separates p from q in Rd. By Lemma B.17, set Z1 strictly
separates p from q in Rd.
Assume there is path ζ ⊆Y from p to q. Set Z1 strictly separates p from
q so path ζ intersects Z1. Since ζ is a subset of Y, path ζ does not intersect
Rd −Y and so must intersect Z1 ∩Y = X1 ∩Y. Thus every path from p to q in
Y intersects X1 ∩Y.
□

APPENDIX C
GRAPH THEORY
A graph G is a set V (G) = {v1, v2, . . .} of objects and a set E(G) of pairs (vi, vj)
of elements of V (G). The set V (G) is called the graph vertices and the set E(G)
is called the graph edges. If edge e equals (vi, vj), then vi and vj are called the
endpoints of edge e. A vertex v ∈V (G) is incident on edge e ∈E(G) if v is an
endpoint of e. Vertex vi is adjacent to vertex vj if (vi, vj) is an edge of G. The
degree of a graph vertex v is the number of edges incident on v. Equivalently,
the degree of a graph vertex v is the number of vertices adjacent to v.
A subgraph of a graph G is a graph whose vertices and edges are a subset
of the vertices and edges of G. An induced subgraph of G is a subset V ′ of the
vertices of G and a subset E′ of the edges of G containing every edge e ∈E(G)
whose endpoints are both in V ′.
A path in a graph is a sequence of vertices (vi1, vi2, . . . , vik) such that (vij , vij+1)
is an edge of the graph for every ij. A path is simple if no two vertices in the
sequence are the same. A cycle in a graph is a sequence of three or more distinct
vertices (vi1, vi2, . . . , vik) such that (vi1, vi2, . . . , vik) is a path and (vi1, vik) is an
edge. The length of a path or cycle is the number of edges in the path or cycle.
The length of a path equals the number of path vertices minus one. The length
of a cycle equals the number of cycle vertices.
A vertex vi ∈V (G) is connected to a vertex vj ∈V (G) if there is a path from
vi to vj in G. A graph G is connected if every vertex vi ∈V (G) is connected
to every other vertex vj ∈V (G). A connected component of G is a maximally
connected, induced subgraph of G, i.e., an induced subgraph G′ of G that is
connected such that any induced subgraph containing G′ is not connected.
A tree is a connected graph with no cycles. A leaf of a tree is a vertex that
has a degree of one.
A tree may have a special vertex called the root of the tree. Such trees are
sometimes called rooted trees. For every vertex v in a rooted tree, there is a
unique simple path from v to the root. Vertex vi is an ancestor of vertex vj and
vj is a descendant of vi if the simple path from vj to the root contains vi. Vertex
445

446
C. Graph Theory
vi is a parent of vertex vj and vj is a child of vi if vi is an ancestor of vj and
(vi, vj) is a tree edge. Every vertex other than the root has a single parent.
The depth of a vertex in a rooted tree is the length of the path from the vertex
to the root. The height of a tree is the maximum depth of any vertex in the tree.
A level of a rooted tree is a set of tree vertices at the same depth in the tree.
A height graph is a graph where each node has a scalar value representing its
“height”.
A graph G is isomorphic to graph G′ if there is a one-to-one and onto mapping
ι : V (G) →V (G′) such that (vi, vj) ∈E(G) if and only if (ι(vi), ι(vj)) ∈E(G′).

APPENDIX D
NOTATION
Greek Letters
α
Scalar value.
Δ
Triangle.
Γ
Regular grid or convex polyhedral mesh.
Γinner
Subgrid of the regular grid Γ composed of interior grid cube cubes
of Γ.
Γouter
Set of boundary grid cubes of Γ.
η
Homotopy map.
ι
Inclusion map ι : X →Y where ι(x) = x.
κ
Conﬁguration of negative and positive vertices. An assignment of
“−” and “+” labels to polytope vertices.
λ
Connected component.
λ−
Connected component of G−
σ containing the connected component
λ of Gσ.
λ+
Connected component of G+
σ containing the connected component
λ of Gσ.
Λ
Set of connected components.
447

448
D. Notation
π
Orthogonal projection.
μ
Aﬃne transformation, homeomorphism, or continuous map.
σ
Isovalue.
σ0, σ1
Lower and upper scalar bounds on the interval volume
{x : σ0 ≤φ(x) ≤σ1}.
Σ+
c (σ)
Isosurface patch for isovalue σ in polytope c.
ΣΓ(σ)
Isosurface for isovalue σ in grid or mesh Γ.
φ
Scalar function.
τ
Triangulation.
τc
Triangulation of cube c.
τcong(t)
Set of tetrahedra or simplices congruent to tetrahedron or simplex
t.
χ(c), χ(Γ)
Mapping of polytope c to c × [0, 1] and mesh Γ to Γ × [0, 1] for
constructing interval volumes. Vertices of χ(c) and χ(Γ) receive
“−” and “+” labels based on “−”, “+”, and “∗” labels of c and Γ.
ζ
Path.
ζc
Path of cubes.
ψ
Polyhedron or polytope.
Ψ
Function from R3 × [0, 1] to R that “lifts” the interval volume
Iφ(σ0, σ1) ⊂R3 to the isosurface in Ψ−1(0) ⊂R4.
Υ
Set of isocontour line segments or isosurface triangles, tetrahedra
or simplices, or interval volume tetrahedra.
Roman Letters
ac, af
Center of cube c or face f.
Bd
Unit ball in Rd.
c
Cube, hypercube, convex polyhedron, or convex polytope.
C
Set of cubic regions.

D. Notation
449
Cinner
Set of inner cubic regions.
Cλ
Set of cubes corresponding to the connected component λ of Gσ.
Cλ−
Set of cubes corresponding to the connected component λ−of G−
σ .
Cλ+
Set of cubes corresponding to the connected component λ+ of G+
σ .
d
Disk or diagonal.
D
Function domain.
e
Edge.
E+/−
κ
Set of bipolar edges of conﬁguration κ.
f
Face or facet of a simplex, polytope, or regular grid.
F
Set of faces or facets.
Fc(σ)
Number of cubes whose span contains scalar value σ.
Fe(σ)
Number of edges whose span contains scalar value σ.
Fv(σ)
Frequency of scalar value σ.
Fv(σ0, σ1)
Frequency of scalar values in the range [σ0, σ1).
Fv(σ0, σ1)
Frequency of scalar values in the closed range [σ0, σ1].
F∗
v (σ0, σ1)
Normalized frequency.
h
Plane or hyperplane.
g
Face or facet of a grid or polytope.
G
Graph.
G−(s)
Subgraph of G induced by vertices whose scalar values are less
than s.
G+(s)
Subgraph of G induced by vertices whose scalar values are greater
than s.
Gσ
Graph representing grid cubes and facets whose spans contain the
isovalue σ. Vertices of Gσ are grid cubes { c : span of c contains σ }.
Edges of Gσ are { (c,c′) : cubes c and c′ share a common facet f
and the span of f contains σ}.

450
D. Notation
G−
σ
Graph representing grid cubes c and facets f where smin(c) ≤σ
and smin(f) ≤σ. Vertices of G−
σ are cubes { c : smin(c) ≤σ}.
Edges of G−
σ are { (c,c′) : cubes c and c′ share a common facet f
and smin(f) ≤σ}.
G+
σ
Graph representing grid cubes c and facets f where smax(c) ≥σ
and smax(f) ≥σ. Vertices of G+
σ are cubes { c : smax(c) ≥σ}.
Edges of G+
σ are { (c,c′) : cubes c and c′ share a common facet f
and smax(f) ≥σ}.
Iφ(σ0, σ1)
Interval volume {x : σ0 ≤φ(x) ≤σ1}.
L
Interval volume vertex label “−”, “+”, or “∗”.
L+
c (Uc)
Line segments on the boundary of R+
c (Uc) that do not lie on the
boundary of the square c. Abbreviated as L+
c .
Mc
Midpoints of bipolar edges in polytope c.
ni
Number of grid vertices along the ith axis. Vertex dimensions of a
3D grid are n1 × n2 × n3.
nx, ny, nz, nw
Number of grid vertices along axes x, y, z, or w.
Np
Neighborhood of point p.
N v, N v
Γ
Number of vertices in a grid Γ.
N c, N c
Γ
Number of cubes in a grid Γ.
mi
Number of grid edges along the ith axis. Cube dimensions of a 3D
grid are m1 × m2 × m3.
M
Manifold.
q
Quadrilateral.
re
Isosurface vertex on edge e.
r
Ray.
R
Real numbers.
Rd
Real d-dimensional coordinate space.
RM+
c
Abbreviation for R+
c (Mc).
sv
Scalar value at vertex v.

D. Notation
451
R+
c (Uc)
Positive region in polytope c. Deﬁned as conv(Uc ∪V +
c ). Abbrevi-
ated as R+
c .
smin(c)
Minimum scalar value of any vertex of cube c.
smin(f)
Minimum scalar value of any vertex of facet f.
smin(C)
Minimum of smin(c) over all cubes c ∈C.
smax(c)
Maximum scalar value of any vertex of cube c.
smax(f)
Maximum scalar value of any vertex of facet f.
smax(C)
Maximum of smax(c) over all cubes c ∈C.
S+
c (Uc)
Surface separating R+
c (Uc) from c −R+
c (Uc).
Deﬁned as R+
c (Uc) ∩cl(c −R+
c (Uc)). Abbreviated as S+
c .
Sd
Unit sphere in Rd.
t
Triangle, tetrahedron, or simplex.
T +
c (Uc)
Triangles or simplices in the triangulation of the boundary of R+
c (Uc)
that do not lie on the boundary of polytope c. Abbreviated as T +
c .
T M+
c
Abbreviation for T +
c (Mc).
T +
Γ (U)
Union of T +
c (U ∩c) over all polytopes c ∈Γ.
T +
c (Uc)
Equals T +
c (Uc) when R+
c (Uc) has the same dimension as c. Equals
a triangulation of R+
c (Uc) when R+
c (Uc) is contained in a facet of c
and has dimension equal to the dimension of the facet. Abbreviated
as T +
c .
TC
Contour tree.
TJ
Join tree.
TS
Split tree.
u
Element of an isosurface vertex set.
U
Isosurface vertex set.
Uc
Isosurface vertex set for polytope c.
v
Vertex.
V +
c
Positive vertices of polytope c.
V −
c
Negative vertices of polytope c.

452
D. Notation
Volc(σ0, σ1) Approximate measure of an interval volume based on the number
of cubes intersecting the volume.
Vole(σ0, σ1) Approximate measure of an interval volume based on the number
of edges intersecting the volume.
w
Isosurface vertex.
Z
Sequence or permutation.
ZE
Sequence of bipolar edges.
ZU
Sequence of elements of an isosurface vertex set U.
Z+
V
Sequence of positive vertices.
Operators
∂c
Boundary of a convex polytope c.
∂M
Manifold boundary of a manifold M.
∂P
Topological boundary of a set of points P.
aﬀ(P)
Aﬃne hull of a set of points P.
cl(P)
Closure of a set of points P.
conv(P)
Convex hull of a set of points P.
int(c)
Interior of a convex polytope c.
int(M)
Manifold interior of a manifold M.
int(P)
Topological interior of a set of points P.
relbnd(P)
Relative boundary of a set of points P.
relint(P)
Relative interior of a set of points P.

BIBLIOGRAPHY
[Alliez et al., 2007] Alliez, P., Attene, M., Gotsman, C., and Ucelli, G. (2007). Recent
advances in remeshing of surfaces. In Floriani, L. D. and Spagnuolo, M., editors,
Shape Analysis and Structuring, pages 53–82. Springer-Verlag, Berlin.
[Armstrong, 1983] Armstrong, M. A. (1983). Basic topology. Undergraduate texts in
mathematics. Springer-Verlag, New York.
[Ashida and Badler, 2003] Ashida, K. and Badler, N. I. (2003).
Feature preserving
manifold mesh from an octree. In Proceedings of the Eighth ACM Symposium on
Solid Modeling and Applications, pages 292–297, New York. ACM Press.
[Attali et al., 2005] Attali, D., Cohen-Steiner, D., and Edelsbrunner, H. (2005). Ex-
traction and simpliﬁcation of iso-surfaces in tandem. In Proceedings of the Eurograph-
ics Symposium on Geometry Processing, pages 139–148, Aire-la-Ville, Switzerland.
Eurographics Association.
[Bachthaler and Weiskopf, 2008] Bachthaler, S. and Weiskopf, D. (2008).
Continu-
ous scatterplots.
IEEE Transactions on Visualization and Computer Graphics,
14(6):1428–1435.
[Bachthaler and Weiskopf, 2009] Bachthaler, S. and Weiskopf, D. (2009).
Eﬃcient
and adaptive rendering of 2-D continuous scatterplots. Computer Graphics Forum,
28(3):743–750.
[Bai et al., 2006] Bai, Y., Han, X., and Prince, J. (2006).
Octree-based topology-
preserving isosurface simpliﬁcation. In Proceedings of the 2006 Conference on Com-
puter Vision and Pattern Recognition, page 81, Washington, DC. IEEE Computer
Society.
[Bajaj et al., 1997] Bajaj, C. L., Pascucci, V., and Schikore, D. (1997). The contour
spectrum. In Proceedings of IEEE Visualization 1997, pages 167–173, Los Alamitos,
CA. IEEE Computer Society.
[Bajaj et al., 1996] Bajaj, C. L., Pascucci, V., and Schikore, D. R. (1996). Fast isocon-
touring for improved interactivity. In Proceedings of the 1996 Symposium on Volume
Visualization, pages 39–46, Los Alamitos, CA. IEEE Computer Society.
[Balmelli et al., 2002] Balmelli, L., Morris, C. J., Taubin, G., and Bernardini, F.
(2002). Volume warping for adaptive isosurface extraction. In Proceedings of IEEE
Visualization 2002, pages 467–474, Los Alamitos, CA. IEEE Computer Society.
453

454
Bibliography
[Banks et al., 2004] Banks, D. C., Linton, S. A., and Stockmeyer, P. K. (2004). Count-
ing cases in substitope algorithms. IEEE Transactions on Visualization and Com-
puter Graphics, 10:371–384.
[Barry and Wood, 2007] Barry, M. and Wood, Z. (2007). Direct extraction of normal
mapped meshes from volume data. In Proceedings of the International Conference
on Advances in Visual Computing, pages 816–826, Berlin. Springer-Verlag.
[Bhaniramka et al., 2000] Bhaniramka, P., Wenger, R., and Crawﬁs, R. (2000). Iso-
surfacing in higher dimensions. In Proceedings of IEEE Visualization 2000, pages
267–273, Los Alamitos, CA. IEEE Computer Society.
[Bhaniramka et al., 2004a] Bhaniramka, P., Wenger, R., and Crawﬁs, R. (2004a). Iso-
surface construction in any dimension using convex hulls. IEEE Transactions on
Visualization and Computer Graphics, 10(2):130–141.
[Bhaniramka et al., 2004b] Bhaniramka, P., Zhang, C., Xue, D., Crawﬁs, R., and
Wenger, R. (2004b). Volume interval segmentation and rendering. In Proceedings of
the 2004 IEEE Symposium on Volume Visualization and Graphics, pages 55–62, Los
Alamitos, CA. IEEE Computer Society.
[Bischoﬀand Kobbelt, 2002] Bischoﬀ, S. and Kobbelt, L. P. (2002).
Isosurface re-
construction with topology control. In Proceedings of the 10th Paciﬁc Conference
on Computer Graphics and Applications, pages 246–255, Los Alamitos, CA. IEEE
Computer Society.
[Bischoﬀet al., 2005] Bischoﬀ, S., Pavic, D., and Kobbelt, L. (2005).
Automatic
restoration of polygon models. ACM Transactions on Graphics, 24(4):1332–1352.
[Bloomenthal, 1988] Bloomenthal, J. (1988). Polygonization of implicit surfaces. Com-
puter Aided Geometric Design, 5(4):341–355.
[Bloomenthal, 1994] Bloomenthal, J. (1994). An implicit surface polygonizer. In Heck-
bert, P., editor, Graphics Gems IV, pages 324–349. Academic Press, Boston.
[Bordoloi and Shen, 2003] Bordoloi, U. and Shen, H.-W. (2003). Space eﬃcient fast
isosurface extraction for large datasets. In Proceedings of IEEE Visualization 2003,
pages 201–208, Los Alamitos, CA. IEEE Computer Society.
[Boyell and Ruston, 1963] Boyell, R. L. and Ruston, H. (1963). Hybrid techniques for
real-time radar simulation. In Proceedings of the 1963 Fall Joint Computer Confer-
ence, pages 445–458, New York. ACM Press.
[Bruckner and M¨oller, 2010] Bruckner, S. and M¨oller, T. (2010). Isosurface similarity
maps. Computer Graphics Forum, 29(3):773–782.
[Carneiro et al., 1996] Carneiro, B. P., Silva, C. T., and Kaufman, A. E. (1996). Tetra-
cubes: An algorithm to generate 3D isosurfaces based upon tetrahedra.
In Pro-
ceedings of IX Brazilian Symposium on Computer Graphics, Image Processing and
Vision, pages 205–210, Los Alamitos, CA. IEEE Computer Society.
[Carr et al., 2006a] Carr, H., Duﬀy, B., and Barry, D. (2006a). On histograms and
isosurface statistics. IEEE Transactions on Visualization and Computer Graphics,
12(5):1259–1266.
[Carr and Max, 2010] Carr, H. and Max, N. (2010). Subdivision analysis of the tri-
linear interpolant.
IEEE Transactions on Visualization and Computer Graphics,
16:533–547.

Bibliography
455
[Carr et al., 2001] Carr, H., M¨oller, T., and Snoeyink, J. (2001).
Simplicial subdi-
visions and sampling artifacts. In Proceedings of IEEE Visualization 2001, pages
99–106, Los Alamitos, CA. IEEE Computer Society.
[Carr et al., 2006b] Carr, H., M¨oller, T., and Snoeyink, J. (2006b). Artifacts caused by
simplicial subdivision. IEEE Transactions on Visualization and Computer Graphics,
12:231–242.
[Carr and Snoeyink, 2003] Carr, H. and Snoeyink, J. (2003). Path seeds and ﬂexible
isosurfaces using topology for exploratory visualization. In Proceedings of the Sym-
posium on Data Visualisation, pages 49–58, Aire-la-Ville, Switzerland. Eurographics
Association.
[Carr and Snoeyink, 2009] Carr, H. and Snoeyink, J. (2009). Representing interpolant
topology for contour tree computation. In Hege, H.-C., Polthier, K., and Scheuer-
mann, G., editors, Topology-Based Methods in Visualization II, Mathematics and
Visualization, pages 59–73. Springer-Verlag, Berlin.
[Carr et al., 2003] Carr, H., Snoeyink, J., and Axen, U. (2003). Computing contour
trees in all dimensions. Computational Geometry: Theory and Applications, 24:75–
94.
[Carr et al., 2004] Carr, H., Snoeyink, J., and van de Panne, M. (2004). Simplifying
ﬂexible isosurfaces using local geometric measures. In Proceedings of IEEE Visual-
ization 2004, pages 497–504, Los Alamitos, CA. IEEE Computer Society.
[Chan and Purisima, 1998] Chan, S. and Purisima, E. (1998). A new tetrahedral tes-
selation scheme for isosurface generation. Computers & Graphics, 22(1):83–90.
[Cheney and Kincaid, 2007] Cheney, E. W. and Kincaid, D. R. (2007).
Numerical
Mathematics and Computing. Brooks/Cole Publishing Co., Paciﬁc Grove, CA.
[Cheng et al., 2004] Cheng, S.-W., Dey, T. K., Ramos, E. A., and Ray, T. (2004). Sam-
pling and meshing a surface with guaranteed topology and geometry. In Proceedings
of the Annual Symposium on Computational Geometry, pages 280–289, New York.
ACM Press.
[Chernyaev, 1995] Chernyaev, E. V. (1995). Marching cubes 33: Construction of topo-
logically correct isosurfaces. Technical Report CN/95-17, CERN, Geneva, Switzer-
land.
[Chiang et al., 2001] Chiang, Y.-J., Farias, R., Silva, C. T., and Wei, B. (2001). A uni-
ﬁed infrastructure for parallel out-of-core isosurface and volume rendering of unstruc-
tured grids. In Symposium on Parallel and Large-Data Visualization and Graphics,
pages 59–66, 151, New York. ACM Press.
[Chiang et al., 2005] Chiang, Y.-J., Lenz, T., Lu, X., and Rote, G. (2005).
Simple
and optimal output-sensitive construction of contour trees using monotone paths.
Computational Geometry: Theory and Applications, 30:165–195.
[Chiang and Lu, 2003] Chiang, Y.-J. and Lu, X. (2003). Progressive simpliﬁcation of
tetrahedral meshes preserving all isosurface topologies. Computer Graphics Forum,
22(3):493–504.
[Chiang and Silva, 1997] Chiang, Y.-J. and Silva, C. T. (1997). I/O optimal isosurface
extraction. In Proceedings of IEEE Visualization 1997, pages 293–300, Los Alamitos,
CA. IEEE Computer Society.

456
Bibliography
[Chiang and Silva, 1999] Chiang, Y.-J. and Silva, C. T. (1999). External memory tech-
niques for isosurface extraction in scientiﬁc visualization. In Abello, J. M. and Vitter,
J. S., editors, External Memory Algorithms, pages 247–277. American Mathematical
Society, Boston.
[Chiang et al., 1998] Chiang, Y.-J., Silva, C. T., and Schroeder, W. J. (1998). Interac-
tive out-of-core isosurface extraction. In Proceedings IEEE Visualization 1998, pages
167–174, Los Alamitos, CA. IEEE Computer Society.
[Cignoni et al., 1994] Cignoni, P., De Floriani, L., Montani, C., Puppo, E., and
Scopigno, R. (1994).
Multiresolution modeling and visualization of volume data
based on simplicial complexes. In Proceedings of the 1994 Symposium on Volume
Visualization, pages 19–26, New York. ACM Press.
[Cignoni et al., 2000] Cignoni, P., Ganovelli, F., Montani, C., and Scopigno, R. (2000).
Reconstruction of topologically correct and adaptive trilinear isosurfaces. Computers
& Graphics, 24:399–418.
[Cignoni et al., 1997] Cignoni, P., Marino, P., Montani, C., Puppo, E., and Scopigno,
R. (1997). Speeding up isosurface extraction using interval trees. IEEE Transactions
on Visualization and Computer Graphics, 3(2):158–170.
[Cignoni et al., 1998] Cignoni, P., Montani, C., and Scopigno, R. (1998). A comparison
of mesh simpliﬁcation algorithms. Computers & Graphics, 22(1):37–54.
[Clarkson et al., 1993] Clarkson, K. L., Mehlhorn, K., and Seidel, R. (1993).
Four
results on randomized incremental constructions. Computational Geometry: Theory
and Applications, 3:185–212.
[Cline et al., 1988] Cline, H., Lorensen, W., Ludke, S., Crawford, C., and Teeter, B.
(1988). Two algorithms for the three-dimensional reconstruction of tomograms. Med-
ical Physics, 15(3):320–327.
[Cole-McLaughlin et al., 2003] Cole-McLaughlin, K., Edelsbrunner, H., Harer, J.,
Natarajan, V., and Pascucci, V. (2003). Loops in Reeb graphs of 2-manifolds. In
Proceedings of the Annual Symposium on Computational Geometry, pages 344–350,
New York. ACM Press.
[Cormen et al., 2001] Cormen, T. H., Leiserson, C. E., Rivest, R. L., and Stein (2001).
Introduction to Algorithms. MIT Press, Cambridge, MA.
[Cox et al., 2003] Cox, J., Karron, D. B., and Ferdous, N. (2003). Topological zone
organization of scalar volume data. Journal of Mathematical Imaging and Vision,
18:95–117.
[Dey and Levine, 2007] Dey, T. K. and Levine, J. A. (2007).
Delaunay meshing of
isosurfaces. In International Conference on Shape Modeling and Applications, pages
241–250, Los Alamitos, CA. IEEE Computer Society.
[Dietrich et al., 2008] Dietrich, C., Scheidegger, C., Comba, J., Nedel, L., and Silva, C.
(2008). Edge groups: An approach to understanding the mesh quality of marching
methods. IEEE Transactions on Visualization and Computer Graphics, 14(6):1651–
1666.
[Dietrich et al., 2009a] Dietrich, C., Scheidegger, C., Comba, J., Nedel, L., and Silva,
C. (2009a). Marching cubes without skinny triangles. Computing in Science Engi-
neering, 11(2):82–87.

Bibliography
457
[Dietrich et al., 2009b] Dietrich, C., Scheidegger, C., Schreiner, J., Comba, J., Nedel,
L., and Silva, C. (2009b). Edge transformations for improving mesh quality of march-
ing cubes. IEEE Transactions on Visualization and Computer Graphics, 15(1):150–
159.
[Doraiswamy and Natarajan, 2008] Doraiswamy, H. and Natarajan, V. (2008). Eﬃ-
cient output-sensitive construction of Reeb graphs. In Proceedings of the 19th Inter-
national Symposium on Algorithms and Computing, pages 556–567, Berlin. Springer-
Verlag.
[Doraiswamy and Natarajan, 2009] Doraiswamy, H. and Natarajan, V. (2009). Eﬃ-
cient algorithms for computing Reeb graphs. Computational Geometry: Theory and
Applications, 42:606–616.
[Duﬀy et al., 2012] Duﬀy, B., Carr, H., and M¨oller, T. (2012).
Integrating isosur-
face statistics and histograms. IEEE Transactions on Visualization and Computer
Graphics, 19(2):263–277.
[D¨urst, 1988] D¨urst, M. J. (1988). Additional reference to Marching Cubes. Computer
Graphics, 22(2):72–73.
[Edelsbrunner, 1987] Edelsbrunner, H. (1987). Algorithms in Combinatorial Geometry.
Springer-Verlag, New York.
[Etiene et al., 2012] Etiene, T., Nonato, L. G., Scheidegger, C., Tierny, J., Peters,
T. J., Pascucci, V., Kirby, R. M., and Silva, C. T. (2012). Topology veriﬁcation for
isosurface extraction. IEEE Transactions on Visualization and Computer Graphics,
18:952–965.
[Etiene et al., 2009] Etiene, T., Scheidegger, C., Nonato, L. G., Kirby, R. M., and Silva,
C. (2009). Veriﬁable visualization for isosurface extraction. IEEE Transactions on
Visualization and Computer Graphics, 15:1227–1234.
[Fujishiro et al., 1996] Fujishiro, I., Maeda, Y., Sato, H., and Takeshima, Y. (1996).
Volumetric data exploration using interval volume. IEEE Transactions on Visual-
ization and Computer Graphics, 2(2):144–155.
[Gallagher, 1991] Gallagher, R. S. (1991). Span ﬁltering: an optimization scheme for
volume visualization of large ﬁnite element models. In Proceedings of IEEE Visual-
ization 1991, pages 68–75, Los Alamitos, CA. IEEE Computer Society.
[Gallagher and Nagtegaal, 1989] Gallagher, R. S. and Nagtegaal, J. C. (1989). An eﬃ-
cient 3-D visualization technique for ﬁnite element models and other coarse volumes.
In Proceedings of the 16th Annual Conference on Computer Graphics and Interactive
Techniques, SIGGRAPH 1989, pages 185–194, New York. ACM Press.
[Garey and Johnson, 1979] Garey, M. R. and Johnson, D. S. (1979). Computers and
Intractability: A Guide to the Theory of NP-Completeness. W. H. Freeman, New
York.
[Garland, 1999] Garland, M. (1999).
Multiresolution modeling: Survey and future
opportunities. In State of the Art Report, Eurographics, pages 111–131.
[Gelder and Wilhelms, 1990] Gelder, A. V. and Wilhelms, J. (1990). Topological con-
siderations in isosurface generation. Computer Graphics, 24(5):79–86.
[Gerstner, 2002] Gerstner, T. (2002).
Multiresolution extraction and rendering of
transparent isosurfaces. Computers & Graphics, 26(2):219–228.

458
Bibliography
[Gerstner and Pajarola, 2000] Gerstner, T. and Pajarola, R. (2000).
Topology pre-
serving and controlled topology simplifying multiresolution isosurface extraction. In
Proceedings of IEEE Visualization 2000, pages 259–266, Los Alamitos, CA. IEEE
Computer Society.
[Gerstner and Rumpf, 2000] Gerstner, T. and Rumpf, M. (2000).
Multiresolutional
parallel isosurface extraction based on tetrahedral bisection. In Chen, M., Kauf-
man, A., and Yagel, R., editors, Volume Graphics, pages 267–278. Springer-Verlag,
London.
[Gibson, 1998a] Gibson, S. F. F. (1998a). Constrained elastic surface nets: Generating
smooth surfaces from binary segmented data. In Proceedings of the First Interna-
tional Conference on Medical Image Computing and Computer-Assisted Intervention,
MICCAI 1998, pages 888–898, Berlin. Springer-Verlag.
[Gibson, 1998b] Gibson, S. F. F. (1998b). Using distance maps for accurate surface
representation in sampled volumes. In Proceedings of the 1998 IEEE Symposium on
Volume Visualization, pages 23–30, Los Alamitos, CA. IEEE Computer Society.
[Giles and Haimes, 1990] Giles, M. and Haimes, R. (1990). Advanced interactive visu-
alization for CFD. Computing Systems in Engineering, 1(1):51–62.
[Gregorski et al., 2002] Gregorski, B., Duchaineau, M., Lindstrom, P., Pascucci, V.,
and Joy, K. I. (2002). Interactive view-dependent rendering of large isosurfaces. In
Proceedings of IEEE Visualization 2002, pages 475–484, Los Alamitos, CA. IEEE
Computer Society.
[Gregorski et al., 2004] Gregorski, B., Senecal, J., Duchaineau, M. A., and Joy, K. I.
(2004).
Adaptive extraction of time-varying isosurfaces.
IEEE Transactions on
Visualization and Computer Graphics, 10(6):683–694.
[Greß and Klein, 2004] Greß, A. and Klein, R. (2004).
Eﬃcient representation and
extraction of 2-manifold isosurfaces using kd-trees.
Graphical Models, 66(6):370–
397.
[Guo, 1995] Guo, B. (1995). Interval set: A volume rendering technique generalizing
isosurface extraction. In Proceedings of IEEE Visualization 1995, pages 3–10, Los
Alamitos, CA. IEEE Computer Society.
[Hall and Warren, 1990] Hall, M. and Warren, J. (1990). Adaptive polygonalization of
implicitly deﬁned surfaces. IEEE Comput. Graph. Appl., 10(6):33–42.
[Hamann et al., 1997] Hamann, B., Trotts, I. J., and Farin, G. E. (1997).
On ap-
proximating contours of the piecewise trilinear interpolant using triangular rational-
quadratic B´ezier patches. IEEE Transactions on Visualization and Computer Graph-
ics, 3(3):215–227.
[Harvey et al., 2010] Harvey, W., Wang, Y., and Wenger, R. (2010). A randomized
O(m log m) time algorithm for computing Reeb graphs of arbitrary simplicial com-
plexes. In Proceedings of the Annual Symposium on Computational Geometry, pages
267–276, New York. ACM Press.
[He et al., 1996] He, T., Hong, L., Varshney, A., and Wang, S. W. (1996). Controlled
topology simpliﬁcation. IEEE Transactions on Visualization and Computer Graph-
ics, 2(2):171–184.

Bibliography
459
[Hilton et al., 1996] Hilton, A., Stoddart, A., Illingworth, J., and Windeatt, T. (1996).
Marching triangles: Range image fusion for complex object modeling. In Interna-
tional Conference on Image Processing, pages 381–384, Los Alamitos, CA. IEEE
Computer Society.
[Ho et al., 2005] Ho, C., Wu, F., Chen, B., and Ouhyoung, M. (2005). Cubical march-
ing squares: Adaptive feature preserving surface extraction from volume data. Com-
puter Graphics Forum, 24:195–201.
[Hocking and Young, 1961] Hocking, J. and Young, G. (1961).
Topology.
Addison-
Wesley series in mathematics. Dover Publications, New York.
[Hossain et al., 2011] Hossain, Z., Alim, U. R., and M¨oller, T. (2011). Toward high-
quality gradient estimation on regular lattices. IEEE Transactions on Visualization
and Computer Graphics, 17(4):426–439.
[Howie and Blake, 1994] Howie, C. T. and Blake, E. H. (1994). The Mesh Propagation
algorithm for isosurface construction. Computer Graphics Forum, 13(3):65–74.
[Iske et al., 2002] Iske, A., Quak, E., and Floater, M. S., editors (2002). Tutorials on
Multiresolution in Geometric Modelling: Summer School Lectures Notes. Springer-
Verlag, Berlin.
[Itoh and Koyamada, 1994] Itoh, T. and Koyamada, K. (1994). Isosurface generation
by using extrema graphs. In Proceedings of IEEE Visualization 1994, pages 77–84,
Los Alamitos, CA. IEEE Computer Society.
[Itoh and Koyamada, 1995] Itoh, T. and Koyamada, K. (1995). Automatic isosurface
propagation using an extrema graph and sorted boundary cell lists. IEEE Transac-
tions on Visualization and Computer Graphics, 1(4):319–327.
[Itoh et al., 1996] Itoh, T., Yamaguchi, Y., and Koyamada, K. (1996). Volume thinning
for automatic isosurface propagation. In Proceedings of IEEE Visualization 1996,
pages 303–310, Los Alamitos, CA. IEEE Computer Society.
[Itoh et al., 2001] Itoh, T., Yamaguchi, Y., and Koyamada, K. (2001). Fast isosurface
generation using the volume thinning algorithm. IEEE Transactions on Visualization
and Computer Graphics, 7(1):32–46.
[Ju, 2004] Ju, T. (2004). Robust repair of polygonal models. ACM Transactions on
Graphics, 23(3):888–895.
[Ju, 2009] Ju, T. (2009). Fixing geometric errors on polygonal models: a survey. J.
Comput. Sci. Technol., 24(1):19–29.
[Ju et al., 2002] Ju, T., Losasso, F., Schaefer, S., and Warren, J. (2002). Dual con-
touring of hermite data. ACM Transactions on Graphics, 21(3):339–346.
[Ju and Udeshi, 2006] Ju, T. and Udeshi, T. (2006). Intersection-free contouring on an
octree grid. Paper presented at the 14th Paciﬁc Conference on Computer Graphics
and Applications, Taipei, Taiwan, October 11–13.
[Karron, 1992] Karron, D. (1992). SpiderWeb algorithm for surface construction in
noisy volume data. In Proceedings of the Conference on Visualization in Biomedical
Computing, pages 462–476, Bellingham, WA. SPIE.

460
Bibliography
[Karron and Cox, 1992] Karron, D. and Cox, J. (1992). Mathematical analysis of “Spi-
derWeb” surface construction algorithm. In 14th Annual Conference of the IEEE
Engineering in Medicine and Biology Society, volume 3, pages 1250–1252, Los Alami-
tos, CA. IEEE Computer Society.
[Karron et al., 1993] Karron, D., Cox, J. L., and Mishra, B. (1993). The SpiderWeb
algorithm for surface construction from medical volume data: Geometric properties
of its surface. Innovations et Technologie en Biologie et M`edecine, 14(6):634–656.
[Kazhdan and Hoppe, 2007] Kazhdan, M., K. A. D. K. and Hoppe, H. (2007). Uncon-
strained isosurface extraction on arbitrary octrees. In Proceedings of the Eurograph-
ics Symposium on Geometry Processing, pages 125–133, Aire-la-Ville, Switzerland.
Eurographics Association.
[Khoury and Wenger, 2010] Khoury, M. and Wenger, R. (2010). On the fractal dimen-
sion of isosurfaces. IEEE Transactions on Visualization and Computer Graphics,
16(6):1198–1205.
[Kindlmann et al., 2003] Kindlmann, G., Whitaker, R., Tasdizen, T., and M¨oller, T.
(2003). Curvature-based transfer functions for direct volume rendering: Methods
and applications. In Proceedings of IEEE Visualization 2003, pages 513–520, Los
Alamitos, CA. IEEE Computer Society.
[Kobbelt et al., 2001] Kobbelt, L. P., Botsch, M., Schwanecke, U., and Seidel, H.-P.
(2001). Feature sensitive surface extraction from volume data. In Proceedings of the
28th Annual Conference on Computer Graphics and Interactive Techniques, SIG-
GRAPH 2001, pages 57–66, New York. ACM Press.
[Labelle and Shewchuk, 2007] Labelle, F. and Shewchuk, J. R. (2007). Isosurface stuﬀ-
ing: Fast tetrahedral meshes with good dihedral angles.
ACM Transactions on
Graphics, 26(3):57.1–57.10.
[Lachaud and Montanvert, 2000] Lachaud, J.-O. and Montanvert, A. (2000). Continu-
ous analogs of digital boundaries: A topological approach to iso-surfaces. Graphical
Models, 62:129–164.
[Lee et al., 2008] Lee, J. K., Maskey, M., Newman, T., Wood, B., and Wang, C. (2008).
Evaluation of high order approximating normals for marching cubes. In IEEE South-
eastcon 2008, pages 593–598, Los Alamitos, CA. IEEE Computer Society.
[Lewiner et al., 2003] Lewiner, T., Lopes, H., Vieira, A. W., and Tavares, G. (2003).
Eﬃcient implementation of marching cubes’ cases with topological guarantees. Jour-
nal of Graphics Tools, 8(2):1–15.
[Lin and Ching, 1997] Lin, C. and Ching, Y. (1997). A note on computing the saddle
values in isosurface polygonization. The Visual Computer, 13(7):342–344.
[Livnat and Hansen, 1998] Livnat, Y. and Hansen, C. (1998).
View dependent iso-
surface extraction. In Proceedings of IEEE Visualization 1998, pages 175–180, Los
Alamitos, CA. IEEE Computer Society.
[Livnat et al., 1996] Livnat, Y., Shen, H.-W., and Johnson, C. R. (1996).
A near
optimal isosurface extraction algorithm using the span space. IEEE Transactions on
Visualization and Computer Graphics, 2:73–84.

Bibliography
461
[Lopes and Brodlie, 2003] Lopes, A. and Brodlie, K. (2003). Improving the robustness
and accuracy of the marching cubes algorithm for isosurfacing. IEEE Transactions
on Visualization and Computer Graphics, 9(1):16–29.
[Lorensen and Cline, 1987a] Lorensen, W. and Cline, H. (1987a). Marching cubes: A
high resolution 3D surface construction algorithm. Computer Graphics, 21(4):163–
170.
[Lorensen and Cline, 1987b] Lorensen, W. and Cline, H. (1987b). System and method
for the display of surface structures contained within the interior region of a solid
body. U.S. Patent 4,710,876.
[Luebke, 2001] Luebke, D. P. (2001). A developer’s survey of polygonal simpliﬁcation
algorithms. IEEE Comput. Graph. Appl., 21(3):24–35.
[Manson and Schaefer, 2010] Manson, J. and Schaefer, S. (2010). Isosurfaces over sim-
plicial partitions of multiresolution grids. Computer Graphics Forum, 29(2):377–385.
[Marschner and Lobb, 1994] Marschner, S. R. and Lobb, R. J. (1994). An evaluation
of reconstruction ﬁlters for volume rendering. In Proceedings of IEEE Visualization
1994, pages 100–107, Los Alamitos, CA. IEEE Computer Society.
[Matveyev, 1994] Matveyev, S. V. (1994). Approximation of isosurface in the Marching
Cube: Ambiguity problem. In Proceedings of IEEE Visualization 1994, pages 288–
292, Los Alamitos, CA. IEEE Computer Society.
[Maubach, 1995] Maubach, J. (1995). Local bisection reﬁnement for n-simplicial grids
generated by reﬂection. SIAM Journal on Scientiﬁc Computing, 16(1):210–227.
[Max, 2001] Max, N. (2001). Consistent subdivision of convex polyhedra into tetrahe-
dra. Journal of Graphics Tools, 6(3):29–36.
[McCreight, 1985] McCreight, E. M. (1985). Priority search trees. SIAM Journal on
Computing, 14(2):257–276.
[M¨oller et al., 1997a] M¨oller, T., Machiraju, R., Mueller, K., and Yagel, R. (1997a).
A comparison of normal estimation schemes. In Proceedings of IEEE Visualization
1997, pages 19–26, Los Alamitos, CA. IEEE Computer Society.
[M¨oller et al., 1997b] M¨oller, T., Machiraju, R., Mueller, K., and Yagel, R. (1997b).
Evaluation and design of ﬁlters using a Taylor series expansion. IEEE Transactions
on Visualization and Computer Graphics, 3(2):184–199.
[Montani et al., 1994] Montani, C., Scateni, R., and Scopigno, R. (1994). A modiﬁed
look-up table for implicit disambiguation of marching cubes. The Visual Computer,
10(6):353–355.
[Morgan, 2009] Morgan, F. (2009). Geometric Measure Theory: A Beginner’s Guide.
Academic Press, Burlington, MA.
[M¨uller and Stark, 1993] M¨uller, H. and Stark, M. (1993).
Adaptive generation of
surfaces in volume data. The Visual Computer, 9(4):182–199.
[Natarajan, 1994] Natarajan, B. K. (1994).
On generating topologically consistent
isosurfaces from uniform samples. The Visual Computer, 11(1):52–62.
[Newman and Yi, 2006] Newman, T. S. and Yi, H. (2006). A survey of the marching
cubes algorithm. Computers & Graphics, 30(5):854–879.

462
Bibliography
[Nielson et al., 2002] Nielson, G., Huang, A., and Sylvester, S. (2002). Approximating
normals for marching cubes applied to locally supported isosurfaces. In Proceedings
of IEEE Visualization 2002, pages 459–466, Los Alamitos, CA. IEEE Computer
Society.
[Nielson, 2003a] Nielson, G. M. (2003a). MC*: Star functions for Marching Cubes.
In Proceedings of IEEE Visualization 2003, pages 67–74, Los Alamitos, CA. IEEE
Computing Society.
[Nielson, 2003b] Nielson, G. M. (2003b). On Marching Cubes. IEEE Transactions on
Visualization and Computer Graphics, 9:283–297.
[Nielson, 2004] Nielson, G. M. (2004). Dual Marching Cubes. In Proceedings of IEEE
Visualization 2004, pages 489–496, Los Alamitos, CA. IEEE Computer Society.
[Nielson et al., 2003] Nielson, G. M., Graf, G., Holmes, R., Huang, A., and Phielipp,
M. (2003). Shrouds: Optimal separating surfaces for enumerated volumes. In Pro-
ceedings of the Symposium on Data Visualisation, VISSYM 2003, pages 75–84, Aire-
la-Ville, Switzerland. Eurographics Association.
[Nielson and Hamann, 1991] Nielson, G. M. and Hamann, B. (1991). The Asymptotic
Decider: Resolving the ambiguity in Marching Cubes. In Proceedings of IEEE Vi-
sualization 1991, pages 83–91, Los Alamitos, CA. IEEE Computer Society.
[Nielson and Sung, 1997] Nielson, G. M. and Sung, J. (1997). Interval volume tetra-
hedrization. In Proceedings of IEEE Visualization 1997, pages 221–228, Los Alami-
tos, CA. IEEE Computer Society.
[Nooruddin and Turk, 2003] Nooruddin, F. S. and Turk, G. (2003).
Simpliﬁcation
and repair of polygonal models using volumetric techniques.
IEEE Transactions
on Visualization and Computer Graphics, 9(2):191–205.
[O’Rourke, 1998] O’Rourke, J. (1998).
Computational Geometry in C.
Cambridge
University Press, New York, 2nd edition.
[Parsa, 2012] Parsa, S. (2012). A deterministic O(m log m) time algorithm for the
Reeb graph. In Proceedings of the Symposium on Computational Geometry, pages
269–276, New York. ACM Press.
[Pascucci, 2002] Pascucci, V. (2002). Slow growing subdvisions (SGS) in any dimen-
sion: Towards removing the curse of dimensionality.
Computer Graphics Forum,
21(3):451–460.
[Pascucci and Bajaj, 2000] Pascucci, V. and Bajaj, C. L. (2000).
Time critical iso-
surface reﬁnement and smoothing. In Proceedings of the 2000 IEEE Symposium on
Volume Visualization, pages 33–42, New York. ACM Press.
[Pascucci and Cole-McLaughlin, 2002] Pascucci, V. and Cole-McLaughlin, K. (2002).
Eﬃcient computation of the topology of level sets. In Proceedings of IEEE Visual-
ization 2002, pages 187–194, Los Alamitos, CA. IEEE Computer Society.
[Pascucci et al., 2007] Pascucci, V., Scorzelli, G., Bremer, P.-T., and Mascarenhas, A.
(2007). Robust on-line computation of Reeb graphs: simplicity and speed. ACM
Transactions on Graphics, 26(3):58.
[Patera and Skala, 2004] Patera, J. and Skala, V. (2004). A comparison of fundamental
methods for iso-surface extraction. Machine Graphics & Vision, 13(4):329–343.

Bibliography
463
[Payne and Toga, 1990] Payne, B. A. and Toga, A. W. (1990). Medical imaging: Sur-
face mapping brain function on 3D models. IEEE Computer Graphics and Applica-
tions, 10(5):33–41.
[Pekar et al., 2001] Pekar, V., Wiemker, R., and Hempel, D. (2001). Fast detection
of meaningful isosurfaces for volume data visualization.
In Proceedings of IEEE
Visualization 2001, pages 223–230, Los Alamitos, CA. IEEE Computer Society.
[Perry and Frisken, 2001] Perry, R. N. and Frisken, S. F. (2001). Kizamu: a system
for sculpting digital characters. In Proceedings of the 28th Annual Conference on
Computer Graphics and Interactive Techniques, SIGGRAPH 2001, pages 47–56, New
York. ACM Press.
[Poston et al., 1998] Poston, T., Wong, T.-T., and Heng, P.-A. (1998). Multiresolution
isosurface extraction with adaptive skeleton climbing. Computer Graphics Forum,
17(3):137–148.
[P¨othkow and Hege, 2011] P¨othkow, K. and Hege, H.-C. (2011). Positional uncertainty
of isocontours: Condition analysis and probabilistic measures. IEEE Transactions
on Visualization and Computer Graphics, 17:1393–1406.
[Preparata and Shamos, 1985] Preparata, F. P. and Shamos, M. I. (1985). Computa-
tional Geometry: An Introduction. Springer-Verlag, New York.
[Raman and Wenger, 2008] Raman, S. and Wenger, R. (2008). Quality isosurface mesh
generation using an extended Marching Cubes lookup table.
Computer Graphics
Forum, 27:791–798.
[Reeb, 1946] Reeb, G. (1946). Sur les points singuliers d’une forme de Pfaﬀcomplement
integrable ou d’une fonction numerique. Comptes Rendus de L’Academie ses Seances,
Paris, 222:847–849.
[Roberts and Hill, 1999] Roberts, J. C. and Hill, S. (1999). Piecewise linear hypersur-
faces using the Marching Cubes algorithm. In Erbacher, R. F. and Pang, A., editors,
Visual Data Exploration and Analysis VI, volume 3643 of Proceedings of SPIE, pages
170–181. IS&T and SPIE.
[Samet, 1990a] Samet, H. (1990a). Applications of Spatial Data Structures: Computer
Graphics, Image Processing and GIS.
Addison-Wesley Longman Publishing Co.,
Inc., Boston.
[Samet, 1990b] Samet, H. (1990b). The Design and Analysis of Spatial Data Structures.
Addison-Wesley Longman Publishing Co., Inc., Boston.
[Samet, 2005] Samet, H. (2005). Foundations of Multidimensional and Metric Data
Structures.
The Morgan Kaufmann Series in Computer Graphics and Geometric
Modeling. Morgan Kaufmann Publishers Inc., San Francisco.
[Schaefer et al., 2007] Schaefer, S., Ju, T., and Warren, J. (2007). Manifold dual con-
touring. IEEE Transactions on Visualization and Computer Graphics, 13(3):610–
619.
[Schaefer and Warren, 2002] Schaefer, S. and Warren, J. (2002). Dual contouring: The
secret sauce. Technical Report TR 02-408, Dept. of Computer Science, Rice Univer-
sity.

464
Bibliography
[Schaefer and Warren, 2004] Schaefer, S. and Warren, J. (2004). Dual marching cubes:
Primal contouring of dual grids. In Proceedings of the Computer Graphics and Appli-
cations, 12th Paciﬁc Conference, pages 70–76, Los Alamitos, CA. IEEE Computer
Society.
[Scheidegger et al., 2008] Scheidegger, C. E., Schreiner, J. M., Duﬀy, B., Carr, H., and
Silva, C. T. (2008). Revisiting histograms and isosurface statistics. IEEE Transac-
tions on Visualization and Computer Graphics, 14(6):1659–1666.
[Schreiner et al., 2006] Schreiner, J., Scheidegger, C., and Silva, C. (2006).
High-
quality extraction of isosurfaces from regular and irregular grids. IEEE Transactions
on Visualization and Computer Graphics, 12(5):1205–1212.
[Shekhar et al., 1996] Shekhar, R., Fayyad, E., Yagel, R., and Cornhill, J. F. (1996).
Octree-based decimation of marching cubes surfaces. In Yagel, R. and Nielson, G. M.,
editors, Proceedings of IEEE Visualization 1996, pages 335–344, Los Alamitos, CA.
IEEE Computer Society.
[Shen, 1998] Shen, H.-W. (1998). Isosurface extraction in time-varying ﬁelds using a
temporal hierarchical index tree. In Proceedings of IEEE Visualization 1998, pages
159–166, Los Alamitos, CA. IEEE Computing Society.
[Shen et al., 1999] Shen, H.-W., Chiang, L.-J., and Ma, K.-L. (1999). A fast volume
rendering algorithm for time-varying ﬁelds using a time-space partitioning (TSP)
tree. In Proceedings of IEEE Visualization 1999, pages 371–377, Los Alamitos, CA.
IEEE Computer Society.
[Shen et al., 1996] Shen, H.-W., Hansen, C. D., Livnat, Y., and Johnson, C. R. (1996).
Isosurfacing in span space with utmost eﬃciency (ISSUE). In Proceedings of Visu-
alization 1996, pages 287–294, Los Alamitos, CA. IEEE Computer Society.
[Shen and Johnson, 1995] Shen, H.-W. and Johnson, C. R. (1995). Sweeping simplices:
A fast iso-surface extraction algorithm for unstructured grids. In Proceedings of IEEE
Visualization 1995, pages 143–150, Los Alamitos, CA. IEEE Computer Society.
[Shewchuk, 2002] Shewchuk, J. R. (2002). What is a good linear element? Interpo-
lation, conditioning and quality measures. In Proceedings of the 11th International
Meshing Roundtable, pages 115–126, Berlin. Springer-Verlag.
[Shi and JaJa, 2006] Shi, Q. and JaJa, J. (2006). Isosurface extraction and spatial ﬁl-
tering using persistent octree (pot). IEEE Transactions on Visualization and Com-
puter Graphics, 12(5):1283–1290.
[Shinagawa and Kunii, 1991] Shinagawa, Y. and Kunii, T. L. (1991). Constructing a
Reeb graph automatically from cross sections. IEEE Comput. Graph. Appl., 11:44–
51.
[Shirley and Tuchman, 1990] Shirley, P. and Tuchman, A. (1990). A polygonal approx-
imation to direct scalar volume rendering. In Proceedings of the 1990 Workshop on
Volume Visualization, pages 63–70, New York. ACM Press.
[Shu et al., 1995] Shu, R., Zhou, C., and Kankanhalli, M. S. (1995). Adaptive marching
cubes. The Visual Computer, 11(4):202–217.
[Sutton and Hansen, 2000] Sutton, P. M. and Hansen, C. D. (2000). Accelerated iso-
surface extraction in time-varying ﬁelds. IEEE Transactions on Visualization and
Computer Graphics, 6(2):98–107.

Bibliography
465
[Sutton et al., 2000] Sutton, P. M., Hansen, C. D., Shen, H.-W., and Schikore, D.
(2000). A case study of isosurface extraction algorithm performance. In Data Visu-
alization 2000, pages 259–268, New York. Springer.
[Szymczak and Vanderhyde, 2003] Szymczak, A. and Vanderhyde, J. (2003). Extrac-
tion of topologically simple isosurfaces from volume datasets. In Proceedings of IEEE
Visualization 2003, pages 67–74, Los Alamitos, CA. IEEE Computer Society.
[Tarasov and Vyalyi, 1998] Tarasov, S. P. and Vyalyi, M. N. (1998). Construction of
contour trees in 3D in O(n log n) steps. In Proceedings of the Annual Symposium
on Computational Geometry, pages 68–75, New York. ACM Press.
[Tenginakai et al., 2001] Tenginakai, S., Lee, J., and Machiraju, R. (2001).
Salient
iso-surface detection with model-independent statistical signatures. In Proceedings
of IEEE Visualization 2001, pages 231–238, Los Alamitos, CA. IEEE Computer
Society.
[Tenginakai and Machiraju, 2002] Tenginakai, S. and Machiraju, R. (2002). Statistical
computation of salient iso-values. In Proceedings of the Symposium on Data Visual-
isation 2002, pages 19–24, Aire-la-Ville, Switzerland. Eurographics Association.
[Theisel, 2002] Theisel, H. (2002). Exact isosurfaces for Marching Cubes. Computer
Graphics Forum, 21(1):19–32.
[Theußl et al., 2001] Theußl, T., M¨oller, T., and Gr¨oller, M. (2001). Optimal regular
volume sampling.
In Proceedings of IEEE Visualization 2001, pages 91–546, Los
Alamitos, CA. IEEE Computer Society.
[Tierny et al., 2009] Tierny, J., Gyulassy, A., Simon, E., and Pascucci, V. (2009). Loop
surgery for volumetric meshes: Reeb graphs reduced to contour trees. IEEE Trans-
actions on Visualization and Computer Graphics, 15(6):1177–1184.
[Treece et al., 1999] Treece, G., Prager, R., and Gee, A. (1999). Regularised marching
tetrahedra: Improved iso-surface extraction. Computers & Graphics, 23(4):593–598.
[Tzeng, 2004] Tzeng, L. (2004).
Warping Cubes:
Better triangles from Marching
Cubes.
European Workshop on Computational Geometry, Seville, Spain, March
24.
[van Kaick and Pedrini, 2006] van Kaick, O. M. and Pedrini, H. (2006). A compara-
tive evaluation of metrics for fast mesh simpliﬁcation. Computer Graphics Forum,
25(2):197–210.
[van Kreveld et al., 1997] van Kreveld, M., van Oostrum, R., Bajaj, C., Pascucci, V.,
and Schikore, D. (1997). Contour trees and small seed sets for isosurface traversal. In
Proceedings of the Annual Symposium on Computational Geometry, pages 212–220,
New York. ACM Press.
[Varadhan et al., 2003] Varadhan, G., Krishnan, S., Kim, Y. J., and Manocha, D.
(2003). Feature-sensitive subdivision and isosurface reconstruction. In Proceedings of
IEEE Visualization 2003, pages 99–106, Los Alamitos, CA. IEEE Computer Society.
[Vrolijk et al., 2004] Vrolijk, B., Botha, C. P., and Post, F. H. (2004).
Fast time-
dependent isosurface extraction and rendering. In Proceedings of the 20th Spring
Conference on Computer graphics, pages 45–54, New York. ACM Press.

466
Bibliography
[Wang, 2011] Wang, C. (2011). Intersection-free dual contouring on uniform grids: An
approach based on convex/concave analysis. Technical report, Dept. of Mechanical
and Automation Engineering, The Chinese University of Hong Kong, Hong Kong.
[Wang and Chiang, 2009] Wang, C. and Chiang, Y.-J. (2009). Isosurface extraction
and view-dependent ﬁltering from time-varying ﬁelds using persistent time-octree
(ptot). IEEE Transactions on Visualization and Computer Graphics, 15:1367–1374.
[Waters et al., 2006] Waters, K., Co, C., and Joy, K. (2006). Using diﬀerence inter-
vals for time-varying isosurface visualization. Visualization and Computer Graphics,
IEEE Transactions on, 12(5):1275–1282.
[Weber et al., 2001] Weber, G. H., Kreylos, O., Ligocki, T. J., Shalf, J. M., Hagen, H.,
Hamann, B., and Joy, K. I. (2001). Extraction of crack-free isosurfaces from adaptive
mesh reﬁnement data. In Proceedings of the Joint Eurographics and IEEE TCVG
Symposium on Visualization, pages 25–34, Aire-la-Ville, Switzerland. Eurographics
Association.
[Weigle and Banks, 1996] Weigle, C. and Banks, D. (1996). Complex-valued contour
meshing. In Proceedings of IEEE Visualization 1996, pages 173–180, Los Alamitos,
CA. IEEE Computer Society.
[Weigle and Banks, 1998] Weigle, C. and Banks, D. C. (1998). Extracting iso-valued
features in 4-dimensional scalar ﬁelds. In Proceedings of the IEEE Symposium on
Volume Visualization, pages 103–110, Los Alamitos, CA. IEEE Computing Society.
[Weiss and De Floriani, 2008] Weiss, K. and De Floriani, L. (2008). Multiresolution in-
terval volume meshes. In IEEE/EG Symposium on Volume and Point-Based Graph-
ics, pages 65–72, Aire-la-Ville, Switzerland. Eurographics Association.
[Weiss and De Floriani, 2010] Weiss, K. and De Floriani, L. (2010). Isodiamond hierar-
chies: An eﬃcient multiresolution representation for isosurfaces and interval volumes.
IEEE Transactions on Visualization and Computer Graphics, 16(4):583–598.
[Weiss and De Floriani, 2011] Weiss, K. and De Floriani, L. (2011). Simplex and dia-
mond hierarchies: Models and applications. Computer Graphics Forum, 30(8):2127–
2155.
[Westermann et al., 1999] Westermann, R., Kobbelt, L., and Ertl, T. (1999). Real-
time exploration of regular volume data by adaptive reconstruction of iso-surfaces.
The Visual Computer, 15:100–111.
[Wilhelms and Gelder, 1992] Wilhelms, J. and Gelder, A. V. (1992). Octrees for faster
isosurface generation. ACM Transactions on Graphics, 11(3):201–227.
[Wood et al., 2004] Wood, Z., Hoppe, H., Desbrun, M., and Schroder, P. (2004). Re-
moving excess topology from isosurfaces. ACM Transactions on Graphics, 23(2):190–
208.
[Wyvill et al., 1986] Wyvill, G., McPheeters, C., and Wyvill, B. (1986). Data structure
for soft objects. The Visual Computer, 2(4):227–234.
[Zhang et al., 2004] Zhang, N., Hong, W., and Kaufman, A. (2004). Dual contour-
ing with topology-preserving simpliﬁcation using enhanced cell representation. In
Proceedings of IEEE Visualization 2004, pages 505–512, Los Alamitos, CA. IEEE
Computer Society.

Bibliography
467
[Zhang and Qian, 2012] Zhang, Y. and Qian, J. (2012).
Dual contouring for do-
mains with topology ambiguity. In Proceedings of the 20th International Meshing
Roundtable, pages 41–60, Berlin. Springer-Verlag.
[Zhou et al., 1994] Zhou, C., Shu, R., and Kankanhalli, M. S. (1994). Handling small
features in isosurface generation using Marching Cubes.
Computers & Graphics,
18(6):845–848.
[Zhou et al., 1997] Zhou, Y., Chen, B., and Kaufman, A. (1997). Multiresolution tetra-
hedral framework for visualizing regular volume data. In Proceedings of IEEE Visu-
alization 1997, pages 135–142, Los Alamitos, CA. IEEE Computer Society.

This page intentionally left blank
This page intentionally left blank


