Ralf Schindler (Ed.) 
Ways of Proof Theory 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
ontos mathematical logic 
 
edited by Wolfram Pohlers, Thomas Scanlon, Ernest Schimmerling 
Ralf Schindler, Helmut Schwichtenberg 
 
Volume 2 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
Ralf Schindler (Ed.) 
 
 
Ways of Proof Theory 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Bibliographic information published by Die Deutsche Bibliothek 
Die Deutsche Bibliothek lists this publication in the Deutsche Nationalbibliographie; 
detailed bibliographic data is available in the Internet at http://dnb.ddb.de 
 
 
North and South America by 
Transaction Books 
Rutgers University 
Piscataway, NJ 08854-8042 
trans@transactionpub.com 
 
 
United Kingdom, Ire Iceland, Turkey, Malta, Portugal by 
Gazelle Books Services Limited 
White Cross Mills 
Hightown 
LANCASTER, LA1 4XS 
sales@gazellebooks.co.uk 
 
 
 
 
Livraison pour la France et la Belgique: 
Librairie Philosophique J.Vrin 
6, place de la Sorbonne ; F-75005 PARIS 
Tel. +33 (0)1 43 54 03 47 ; Fax  +33 (0)1 43 54 48 18 
www.vrin.fr 
 
 
2010 ontos verlag 
P.O. Box 15 41, D-63133 Heusenstamm 
www.ontosverlag.com 
 
ISBN 978-3-86838-087-3 
2010 
 
No part of this book may be reproduced, stored in retrieval systems or transmitted  
in any form or by any means, electronic, mechanical, photocopying, microfilming, recording or otherwise  
without written permission from the Publisher, with the exception of any material supplied specifically for the  
purpose of being entered and executed on a computer system, for exclusive use of the purchaser of the work 
 
Printed on acid-free paper  
ISO-Norm 970-6 
FSC-certified (Forest Stewardship Council) 
This hardcover binding meets the International Library standard 
 
Printed in Germany 
by buch bücher.de 
 

Wolfram Pohlers

Preface
Wolfram Pohlers is one of the leading researchers in the proof theory of ordinal
analysis. On the occasion of his retirement the Institut f¨ur Mathematische Logik
und Grundlagenforschung of the University of M¨unster organized a colloquium and
a workshop which took place July 17 – 19, 2008. This event brought together proof
theorists from many parts of the world who have been acting as teachers, students
and collaborators of Wolfram Pohlers and who have been shaping the ﬁeld of proof
theory over the years.
The organizer of the colloquium and workshop gratefully acknowledges ﬁnancial
support from the University of M¨unster, the DVMLG (the German Logic Society),
and Springer–Verlag. The present volume collects papers by the speakers of the
colloquium and workshop; and they produce a documentation of the state of the art
of contemporary proof theory.
We thank Martina Pfeifer and Jan–Carl Stegert for helping us organize the col-
loquium and workshop and produce this volume. We dedicate this volume to Wol-
fram Pohlers, who has always been an inspiring mathematician, an extraordinary
colleague, and a great friend. This book is an attempt to tell him that we are well
aware of how much we owe him.
M¨unster, June 01, 2010
Ralf Schindler

Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
III
Wolfram Pohlers — Life and Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
Justus Diller
The Proof Theory of Classical and Constructive Inductive Deﬁnitions. A
Forty Year Saga, 1968 – 2008 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
Solomon Feferman
A New Approach to Predicative Set Theory . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
Arnon Avron
Characterising Deﬁnable Search Problems in Bounded Arithmetic via
Proof Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
Arnold Beckmann and Samuel R. Buss
On Topological Models of GLP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
Program Extraction via Typed Realisability for Induction and Coinduction . . 157
Ulrich Berger and Monika Seisenberger
Another Reduction of Classical IDν to Constructive IDi
ν . . . . . . . . . . . . . . . . 183
Wilfried Buchholz
Elementary Constructive Operational Set Theory . . . . . . . . . . . . . . . . . . . . . . 199
Andrea Cantini and Laura Crosilla
Functional Interpretations of Classical Systems . . . . . . . . . . . . . . . . . . . . . . . . 241
Justus Diller
Towards a Formal Theory of Computability . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
Σ1
1 Choice in a Theory of Sets and Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl

V
An Extended Predicative Deﬁnition of the Mahlo Universe . . . . . . . . . . . . . . 315
Reinhard Kahle and Anton Setzer
ITTMs with Feedback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
Robert S. Lubarsky
Logspace without Bounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
Isabel Oitavem
Investigations of Subsystems of Second Order Arithmetic and Set Theory
in Strength between Π1
1-CA and Δ1
2-CA + BI: Part I. . . . . . . . . . . . . . . . . . 363
Michael Rathjen
Weak Theories of Operations and Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
Thomas Strahm
Computing Bounds from Arithmetical Proofs . . . . . . . . . . . . . . . . . . . . . . . . . 469
Stanley S. Wainer

Wolfram Pohlers — Life and Work
Justus Diller
Institut f¨ur Mathematische Logik und Grundlagenforschung
Westf¨alische Wilhelms-Universit¨at M¨unster
Einsteinstraße 62, 48149 M¨unster, Germany
dillerj@math.uni-muenster.de
Coming from Munich in 1985, Wolfram Pohlers followed a call to the depart-
ment of mathematics of the University of M¨unster. From that time to his retirement
in the summer of 2008, he occupied the chair of Heinrich Scholz, the ﬁrst chair in
mathematical logic and foundational research in German speaking Central Europe.
During this period, he represented the Bavarian element in our department, by ac-
cent as well as by temper. For somebody born in Leipzig to a Saxonian father and
a Norwegian mother, that may seem somewhat surprising. He proved his character
by energetic engagement in many ﬁelds, by stubbornness — which is said to be
characteristic for Westfalians, too — showing a deﬁnite conservative tendency over
the years, and by an ability to compromise resulting out of his respect for his part-
ners in negotiations — which is not a matter of course among mathematicians. We
review his activities in administration, scientiﬁc organization, and science in due
brevity.
Wolfram Pohlers served on several committees of our department. He was our
dean for two years, from 1990 to 1992, and he was our ﬁrst dean to hold that job
for the full period of two consecutive years. Until then, we had not requested of
each other to carry the dean’s burden for so long. In his period of ofﬁce, he, among
other things, resuscitated the deans’ conference of our alma mater.
Since then, he represented his colleagues in the senate of our university for about
14 years, and he was speaker of professors in the senate for a considerable number
of years. Such a position naturally brings about a close, but also time consuming
cooperation with the university administration. It was obviously a consequence
of that positive cooperation that the rector of the university of M¨unster, Prof. Ur-
sula Nelles, seized the opportunity to address the conference in honor of Pohlers’
retirement in person.
Membership in the senate brought with it tasks of which most of us have never
heard, for example in university sports. The central unit university sport is a large
organization which moves considerable amounts of money. The steering of this
unit lies in the hands of a steering committee, and Wolfram Pohlers presided over
this committee for many years. The last meeting over which he presided must
have been a moving farewell party. On the other hand, it seems almost a matter

2
Justus Diller
of course that for many years he also worked on the university’s central IV– (in-
formation processing–) committee. Even more important tasks come up, when the
university looks for a new chancellor or a new rector. Such a person is not found
spontaneously; rather, she or he is looked for by a search committee. If we add
to these the committee for the delicate preselection of candidates for the university
council — Hochschulrat, a product of recent legislation of our state — we have the
impression that within his last ﬁve to eight years on our senate, Wolfram Pohlers
has been on every such committee of our university.
Even a science with a small faculty like mathematical logic has its own na-
tional scientiﬁc union. Wolfram Pohlers has served many years on the board of
the DVMLG, the German logic union. He is also a member of the editorial staff
of the two journals on mathematical logic that appear in Germany, the Mathemat-
ical Logic Quarterly and the Archive for Mathematical Logic. Of the latter he
was editor–in–chief until 2008 when he passed that job on to our colleague Ralf
Schindler. In recent years, he is also active as scientiﬁc area editor for the Journal
of Applied Logic which, following trends of our time, appears in Singapore.
A noticeable event was the European summer meeting 2002 of the ASL, the as-
sociation of symbolic logic, which Pohlers organized in M¨unster, together with the
president of the DVMLG, Professor Koepke from Bonn. With more than 200 par-
ticipants from all over the world, this summer meeting was a big conference, con-
sidering the standards of our department in those days. Our Institute as a whole was
for quite a while pretty busy with the preparation and implementation of the con-
ference. With such determined engagement of manpower and resources, it proved
to be an advantage that once upon a time Wolfram Pohlers had been ofﬁcer of our
federal army. Smaller workshops on proof theory were also organized under his
supervision.
To a large part, these fruitful activities would not have taken place in M¨unster,
if, in 1995, he had followed a call to the university of Vienna. After some inner
struggle he turned down this honourable offer. The “old” logic institute of the
1990’s maintains deeply felt gratitude to him for his staying in M¨unster.
All this is only the outer framework for his central activity, which is research and
teaching of mathematical logic. Wolfram Pohlers graduated from high school in
Munich in 1964 where, after two years of military service, he began his studies of
mathematics at the Ludwig-Maximilians University. He married his wife Renate
in 1970, and passed his diploma in mathematics in March 1971. The day after he
had completed his diploma, he started work as scientiﬁc assistant with Kurt Sch¨utte
with whom he completed his dissertation in mathematical logic in 1973. The area
of research from which the topic of his dissertation was taken was to become his
research ﬁeld for all of his career: it is the proof–theoretic ﬁeld of ordinal analysis,
a central topic in the foundations of mathematics. We cast a quick glance at what

Wolfram Pohlers — Life and Work
3
ordinal analysis is about, and what Wolfram Pohlers has contributed to this ﬁeld in
the last 39 years.
G¨odel’s second incompleteness theorem of 1931 showed that the original goal
of Hilbert’s program was unattainable: a mathematically relevant theory like Peano
Arithmetic (elementary number theory) PA cannot prove its own consistency. Al-
ready in 1936, however, Gerhard Gentzen found a way out of this dilemma. He
proved the consistency of PA employing a transﬁnite induction up to the ordinal
number ϵ0 in an otherwise ﬁnitary, completely combinatorial proof. Here, ϵ0 is the
limit of iterated ω–powers, the ﬁrst ﬁxed point of the function ωα, i.e. the small-
est ordinal α such that ωα = α. (ω designates the ﬁrst transﬁnite ordinal.) By
his proof, he had isolated transﬁnite induction up to ϵ0 as the transﬁnite feature
which transcends the means of PA. He had thus proved the consistency of PA by
constructive, though not ﬁnitary methods. In short: he had shown ϵ0 to be the
proof–theoretic ordinal of PA. By this proof, Gentzen had started a revised version
of Hilbert’s program which until today plays a central role in the foundations of
mathematics. In the 1950’s and 1960’s, Kurt Sch¨utte, Gaisi Takeuti, and Solomon
Feferman began to tackle stronger mathematical systems. Feferman and Sch¨utte
worked in particular on predicative analysis which allows quantiﬁcation over sets
of natural numbers, however, only in a strictly constructive, so–called predicative
way. They proved the ﬁrst strongly critical ordinal Γ0, the ﬁrst common ﬁxed point
of the Veblen hierarchy, to be the proof–theoretic ordinal of predicative analysis.
After this success, impredicative systems of classical mathematics moved into
focus. These were, on the one hand, theories of inductive deﬁnitions. In this area,
Howard 1972 proved the so–called Howard–Bachmann ordinal to be the proof–
theoretic ordinal for one inductive deﬁnition, and Pohlers 1978 made an ordinal
analysis of iterated inductive deﬁnitions. On the other hand, there were subsystems
of classical analysis, i.e. of second order number theory. To the ordinal analysis of
these, Pohlers’ dissertation of 1973 made an important contribution.
The study of both of these areas of research and their interrelations came to
some completion, when, in 1980, the authors Buchholz, Feferman, Pohlers, and
Sieg published the volume “Iterated inductive deﬁnitions and subsystems of analy-
sis: Recent proof–theoretical studies” in the Lecture notes in mathematics. It was
coordinated by Solomon Feferman and based on the habilitation theses of Pohlers
and Bucholz and the PhD thesis of Sieg. In this volume, Pohlers developed his
method of local predicativity which presented an essential progress in the ordinal
analysis of stronger and stronger impredicative systems. As Gentzen succeeded
in isolating the transﬁnite element in ﬁrst order number theory, Pohlers’ method of
local predicativity allows the isolation of the impredicative elements of strong theo-
ries. His method simpliﬁes the still troublesome computations of the corresponding
proof theoretic ordinals considerably.

4
Justus Diller
Given fresh impetus by this new method, proof theorists now also attacked sys-
tems of set theory. While in 1950, Heinz Bachmann was the ﬁrst to make use of an
uncountable number, i.e. ℵ1, to denote countable ordinals, since 1979 hardly any
large cardinal was safe from the grip of ordinal analysts. The hunt was to a large
part led by students of Sch¨utte and Pohlers. Gerhard J¨ager in Munich, now Bern,
was the ﬁrst to make use of inaccessible cardinals, and around 1990, Michael Rath-
jen in M¨unster, now Leeds, proceeded to Mahlo and other large cardinals. Rathjen
ﬁnally succeeded in an ordinal analysis of Π1
2–analysis, a theory much stronger
than methods used by classical mathematicians outside measure theory.
The ambition of the M¨unster school of proof theory — that is an established term
meanwhile — does not only go to still larger, still more complex systems. It also
aims at restructuring the already analyzed terrain, at including constructive theories,
at applications to other areas of mathematics, computer science, and logic. Michael
Rathjen has meanwhile included constructive systems like Martin–L¨of theory and
constructive set theory in his proof theoretic analysis. Andreas Weiermann, now
in Gent, discovered deep connections between ordinal analysis and pure mathe-
matics. For instance, he proved stunning results in proof theory by methods of
analytic number theory. Also lower complexities were analyzed. Theories relevant
in bounded arithmetic satisfy the conditions of G¨odel’s second incompleteness the-
orem only in a restricted sense, and their classical proof theoretic ordinal is ω2 in all
relevant cases. Arnold Beckmann, now in Swansea, developed so–called dynamic
ordinals which allow to distinguish between the proof theoretic strengths of some
of these theories. They are not ordinals in the classical sense, they may be viewed
as cloudy objects assembled around ω. It would be a triumph for proof theory, if
they could be used to separate the right theories of bounded arithmetic according
to their proof theoretic strength. For that would shed light on the P/NP–problem,
the fundamental problem of theoretical computer science, and it would yield the
desired answer P ̸= NP.
Finally, Michael M¨ollerfeld developed a recursion theory of Π1
2-analysis. Thus,
after set theory, constructivism, and complexity theory, one more ﬁeld of math-
ematical logic could be brought into contact with the proof theoretic subject of
ordinal analysis.
Wolfram Pohlers accompanied this drive to new frontiers in many ways, in recent
years in particular with systematizing publications. These include his “Proof The-
ory, An Introduction”, but even more so his thorough survey chapter “Subsystems
of set theory and second order number theory” in the Handbook of Proof Theory
and his recent book “Proof Theory: The First Step into Impredicativity”.
Adding up, Wolfram Pohlers as a researcher has contributed substantially to the
ﬁeld of ordinal analysis; as an academic teacher he has founded the M¨unster school
of proof theory. To keep this group and other friends in contact, the Pohlers cou-

Wolfram Pohlers — Life and Work
5
ple regularly arranges a summer party at their home in Nienberge. Only on rare
occasions at these parties, an old double bass comes into appearance which many
years ago helped Wolfram Pohlers ﬁnance his student days in Munich and which,
during a rafting tour down the Isar, is said to have gone down the river part of the
way on its own. Well, out of his school of proof theory, there emerged a number
of scientists who work in several countries and have produced remarkable results.
Ordinal analysis has become more complex under Pohlers’ inﬂuence, but it is also
rather more vital and more applicable to neighbouring ﬁelds than could have been
expected thirty years ago.


The Proof Theory of Classical and Constructive
Inductive Deﬁnitions.
A Forty Year Saga, 1968 – 2008
Solomon Feferman∗
Department of Mathematics
Stanford University
Stanford, CA 94305-2125, USA
sf@csli.stanford.edu
1 Pohlers and The Problem
I ﬁrst met Wolfram Pohlers at a workshop on proof theory organized by Walter
Felscher that was held in T¨ubingen in early April, 1973. Among others at that
workshop relevant to the work surveyed here were Kurt Sch¨utte, Wolfram’s teacher
in Munich, and Wolfram’s fellow student Wilfried Buchholz. This is not meant to
slight in the least the many other ﬁne logicians who participated there.1 In T¨ubingen
I gave a couple of survey lectures on results and problems in proof theory that had
been occupying much of my attention during the previous decade. The following
was the central problem that I emphasized there:
The need for an ordinally informative, conceptually clear, proof-theoretic re-
duction of classical theories of iterated arithmetical inductive deﬁnitions to
corresponding constructive systems.
∗This is a somewhat revised text of a lecture that I gave for a general audience at the PohlersFest,
M¨unster, 18 July 2008 in honor of Wolfram Pohlers, on the occasion of his retirement from the
Institute for Mathematical Logic at the University of M¨unster. Wolfram was an invited participant
at a conference in my honor at Stanford in 1998, and it was a pleasure, in reciprocation, to help
celebrate his great contributions as a researcher, teacher and expositor. In my lecture I took special
note of the fact that the culmination of Wolfram’s expository work with his long awaited Proof
Theory text was then in the ﬁnal stages of production; it has since appeared as Pohlers (2009). In
that connection, one should mention the many ﬁne expositions of proof theory that he had previously
published, including Pohlers (1987, 1989, 1992, and 1998).
1That meeting was organized by Walter Felscher under the sponsorship of the Volkswagen Stiftung;
there were no published proceedings. It is Pohlers’ recollection that besides him and Felscher, of
course, the audience included Wilfried Buchholz, Justus Diller, Ulrich Felgner, Wolfgang Maas,
Gert M¨uller, Helmut Pfeiffer, Kurt Sch¨utte and Helmut Schwichtenberg. By the way, Felscher
passed away in the year 2000.

8
Solomon Feferman
As will be explained below, meeting that need would be signiﬁcant for the then
ongoing efforts at establishing the constructive foundation for and proof-theoretic
ordinal analysis of certain impredicative subsystems of classical analysis. I also
spoke in T¨ubingen about possible methods to tackle the central problem, includ-
ing both cut-elimination applied to (prima-facie) uncountably inﬁnite derivations
and functional interpretation on the one hand, and the use of naturally developed
systems of ordinal notation on the other. I recall that my wife and I had driven to
T¨ubingen that morning from Oberwolfach after an unusually short night’s sleep,
and that I was going on pure adrenalin, so that my lectures were particularly in-
tense. Perhaps this, in addition to the intrinsic interest of the problems that I raised,
contributed to Wolfram’s excited interest in them. Within a year or so he made the
ﬁrst breakthrough in this area (Pohlers 1975), which was to become the core of his
Habilitationsschrift with Professor Sch¨utte (Pohlers 1977). The 1975 breathrough
was the start of a ﬁve year sustained effort in developing a variety of approaches
to the above problem by Wolfram Pohlers, Wilfried Buchholz and my student Wil-
fried Sieg. The results of that work were jointly reported in the Lecture Notes in
Mathematics volume 897, Iterated Inductive Deﬁnitions and Subsystems of Analy-
sis. Recent proof-theoretical studies (Buchholz et al. 1981). In the next section I
will give a brief review of what led to posing the above problem in view of several
results by Harvey Friedman, William Tait and me at the 1968 Buffalo conference on
intuitionism and proof-theory, with some background from a 1963 seminar on the
foundations of analysis led by Georg Kreisel at Stanford in which formal theories
of “generalized” inductive deﬁnitions (i.e., with arithmetical closure conditions)
were ﬁrst formulated.
The goals of proof-theoretic reduction and of proof-theoretic ordinal analysis in
one form or another of the relativized Hilbert program (not only for theories of
inductive deﬁnitions) are here taken at face value, though I have examined both
critically; see Feferman (1988, 1993, 2000). In addition to meeting those aims in
the problem formulated above are the demands that the solutions be informative
and conceptually clear in short, perspicuous. Granted that these are subjective cri-
teria, nevertheless in practice we are able to make reasonably objective judgments
of comparison. For example, we greatly valued Sch¨utte’s extension of Gentzen’s
cut-elimination theorem for the predicate calculus to “semi-formal” systems with
inﬁnitary rules of inference, because it exhibited a natural and canonical role for
ordinals as lengths of derivations and bounds of cut-rank (cf. Sch¨utte 1977) in the
case of arithmetic and its extensions to ramiﬁed analysis. To begin with, the Cantor
ordinal ε0 emerged naturally as the upper bound of the lengths of cut-free deriva-
tions in the semi-formal system of arithmetic with ω-rule, obtained by eliminating
cuts from the (translations into that system of) proofs in Peano Arithmetic PA; by
comparison the role of ε0 in Gentzen’s consistency proof of PA still had an ad hoc

Proof Theory of Inductive Deﬁnitions
9
appearance.2 And the determination by Sch¨utte and me in the mid 1960s of Γ0 as
the upper bound for the ordinal of predicativity simply fell out of his ordinal anal-
ysis of the systems of ramiﬁed analysis translated into inﬁnitary rules of inference
when one added the condition of autonomy. Incidentally, because of the connection
with predicativity, these kinds of proof-theoretical methods due to Sch¨utte — of or-
dinal analysis via cut-elimination theorems for semi-formal systems with countably
inﬁnitary rules of inference — have come to be referred to as predicative.
The proof-theoretical work on systems of single and (ﬁnitely or transﬁnitely)
iterated arithmetical inductive deﬁnitions were the ﬁrst challenges to obtaining per-
spicuous ordinal analyses and constructive reductions of impredicative theories.
The general problem was both to obtain exact bounds on the provably recursive or-
dinals and to reduce inductive deﬁnitions described ”from above” as the least sets
satisfying certain arithmetical closure conditions to those constructively generated
“from below”. In the event, the work on these systems took us only a certain way
into the impredicative realm, but the method of local predicativity for semi-formal
systems with uncountably inﬁnitary rules of inference that Pohlers developed to
deal with them turned out to be of wider application. What I want to emphasize
in the following is, ﬁrst of all, that ordinal analysis and constructive reduction are
separable goals and that in various cases, each can be done without the other, and,
secondly, that the aim to carry these out in ever more perspicuous ways has led
to recurrent methodological innovations. The most recent of these is the applica-
tion of a version of the method of functional interpretation to theories of inductive
deﬁnitions by Avigad and Towsner (2008), following a long period in which cut-
elimination for various semi-formal systems of uncountably inﬁnitary derivations
had been the dominant method, and which itself evolved methodologically with
perspicuity as the driving force. It is not possible in a survey of this length — and
at the level of detail dictated by that — to explain or state results in full; for exam-
ple, I don’t state conservation results that usually accompany theorems on proof-
theoretical reduction. Nor is it possible to do justice to all the contributions along
the way, let alone all the valuable work on related matters. For example, except
for a brief mention in sec. 7 below, I don’t go into the extensive proof-theoretical
work on iterated ﬁxed point theories. I hope the interested reader will ﬁnd this sur-
vey useful both as an informative overview and as a point of departure to pursue in
more detail not only the topics discussed but also those that are only indicated in
passing. Finally, this survey offers an opportunity to remind one of open questions
and to raise some interesting new ones.
2That role became less mysterious as a result of the work of Buchholz (1997, 2001) explaining
Gentzen-style and Takeuti-style reduction steps in inﬁnitary terms.

10
Solomon Feferman
2 From 1968 to 1981, with some prehistory
In my preface, Feferman (1981), to Buchholz et al. (1981), I traced the develop-
ments that led up to that work; in this section I’ll give a brief summary of that
material.
The consideration of formal systems of “generalized” inductive deﬁnitions origi-
nated with Georg Kreisel (1963) in a seminar that he led on the foundations of anal-
ysis held at Stanford in the summer of 1963.3 Kreisel’s aim there was to assess the
constructivity of Spector’s consistency proof of full second-order analysis (Spector
1962) by means of a functional interpretation in the class of so-called bar recursive
functionals. The only candidate for a constructive foundation of those functionals
would be the hereditarily continuous functionals given by computable representing
functions in the sense of (Kleene 1959) or (Kreisel 1959). So Kreisel asked whether
the intuitionistic theory of inductive deﬁnitions given by monotonic arithmetical
closure conditions, denoted ID1(mon)i below, serves to generate the class of (in-
dices of) representing functions of the bar recursive functionals. Roughly speaking,
ID1(mon), whether classical or intuitionistic, has a predicate PA for each arith-
metic A(P, x) (with a placeholder predicate symbol P) which has been proved to
be monotonic in P, together with axioms expressing that PA is the least predicate
deﬁnable in the system that satisﬁes the closure condition ∀x(A(P, x) →P(x)).
In the event, Kreisel showed that the representing functions for bar recursive func-
tionals of types ≤2 can be generated in an ID1(mon)i but not in general those of
type ≥3.
Because of this negative result, Kreisel did not personally pursue the study of
theories of arithmetical inductive deﬁnitions any further, but he did suggest consid-
eration of theories of ﬁnitely and transﬁnitely iterated such deﬁnitions as well as
special cases involving restrictions on the form of the closure conditions A(P, x).
For example, those A in which the predicate symbol P has only positive occur-
rences are readily established to be monotonic in P. And of special interest among
such A are those that correspond to the accessible (i.e., well-founded part) of an
arithmetical relation. And, ﬁnally, paradigmatic for those are the classes of recur-
sive ordinal number classes Oα introduced in Church and Kleene (1936) and con-
tinued in Kleene (1938). The corresponding formal systems for α times iterated
inductive deﬁnitions (α an ordinal) are denoted (in order of decreasing generality)
IDα(mon), IDα(pos), IDα(acc) and IDα(O) in both classical and intuitionistic
logic, where the restriction to the latter is signalled with a superscript ’i’.4 For limit
3The notes for that seminar are assembled in the unpublished volume Seminar on the Foundations of
Analysis, Stanford University 1963. Reports, of which only a few mimeographed copies were made;
one copy is available in the Mathematical Sciences Library of Stanford University.
4The positivity requirement has to be modiﬁed in the case of intuitionistic systems.

Proof Theory of Inductive Deﬁnitions
11
ordinals λ we shall also be dealing with ID<λ(−), the union of the IDλ(−) for
α < λ, of each of these kinds, whether classical or intuitionistic. Finally, when no
qualiﬁcation of IDα or ID<λ(−) is given, it is meant that we are dealing with the
corresponding IDα(pos) or ID<λ(pos), since — as will be explained in sec. 5 be-
low — there is a relatively easy reduction of the monotonic case to the positive case.
The IDα(O) theories, or similar ones for constructive tree classes, are of particular
interest, because the elements of those classes wear their build-up on their sleeves,
i.e. can be retraced constructively; some of the IDα(acc) classes considered below
share that signiﬁcant feature.
Kreisel’s initiative led one to study the relationship between such theories to sub-
systems of classical analysis considered independently of Spector’s approach and
as the subject of proof-theoretical investigation in their own right. The ﬁrst such
result was obtained by William Howard some time around 1965, though it was not
published until 1972. He showed in Howard (1972) that the proof-theoretic ordinal
of ID1(acc)i is ϕε(Ω+1)0, as measured in the hierarchy of normal functions intro-
duced in Bachmann (1950). Howard’s method of proof proceeded via an extension
of G¨odel’s functional interpretation. This was the ﬁrst ordinally informative char-
acterization of an impredicative system using a system of ordinal notation based on
a natural system of ordinal functions. What was left open by Howard’s work was
whether one could obtain a reduction of the general classical ID1 to ID1(acc)i
(and even better to ID1(O)i) and thus show that the proof-theoretic ordinal is the
same, and similarly for the systems of iterated inductive deﬁnitions more gener-
ally.5
Turning now to the 1968 Buffalo Conference on Intuitionism and Proof Theory,
here, in brief, is what was done in the three papers I mentioned above.
1. (Friedman 1970) proved that the system Σ1
n+1 −AC is of the same strength
as Δ1
n+1 −CA and is conservative over (Π1
n −CA)<ε0 for suitable classes of
sentences. For n = 1 this tied up with the following two results:
2. (Feferman 1970) gave an interpretation of (Π1
1 −CA)α in IDα for various α,
including α = ω, and of (Π1
1 −CA)<λ in ID<λ for various limit λ, including
λ = ε0.6
3. (Tait 1970) established the consistency of Σ1
2 −AC via a certain theory of in-
ductive deﬁnitions by informally constructive cut-elimination methods applied
to uncountably long propositional derivations.
5As will be explained in sec. 6, below, Zucker (1971, 1973) showed the ordinals to be the same without
a reduction argument and by a method that did not evidently extend to the iterated case.
6Actually, the interpretation took one into iterated classical accessibility IDs.

12
Solomon Feferman
These results and the prior work of Takeuti (1967) containing constructive proofs
of consistency of (Π1
1 −CA) and (Π1
1 −CA) + BI gave hope that one could
obtain a constructive reduction of some of the above second order systems via a
reduction of classical theories of iterated inductive deﬁnitions to their intuitionistic
counterparts.7 For, among the results of my Buffalo conference article was that the
system (Π1
1−CA)+BI is prooftheoretically equivalent to IDω. What Takeuti had
done was to carry out his consistency proofs by an extension of Gentzen’s methods
with cut-reduction steps measured in certain partially ordered systems that Takeuti
called ordinal diagrams; these are not based on natural systems of ordinal functions
such as those in the Bachmann hierarchy. Takeuti proved the well-foundedness of
the ordering of ordinal diagrams by constructive arguments that could be formu-
lated in suitable intuitionistic iterated accessible IDs. These methods were later
extended to (Δ1
2 −CA) + BI in Takeuti and Yasugi (1973).
Before proceeding, a few words are necessary about the systems of ordinal func-
tions involved in proof-theoretic ordinal analysis at that time and in subsequent
work. Bachmann had extended the classical Veblen hierarchy ϕα (or λα, β.ϕα(β))
of critical functions of countable ordinals by use of indices α to certain uncountable
ordinals — including those up to the ﬁrst ϵ-number greater than Ω — by diagonal-
izing at α of coﬁnality Ω, e.g. deﬁning ϕΩβ to be ϕβ0. This method was carried
out systematically by Helmut Pfeiffer (1964) by reference to the ﬁnite ordinal num-
ber classes whose initial ordinals are the Ωn for n < ω, and then by David Isles
(1970) via the number classes up to the ﬁrst inaccessible ordinal. Each such exten-
sion required more and more complicated assignment of fundamental sequences to
the ordinals actually drawn from each number class. In 1970, in informal discus-
sions with Peter Aczel, I proposed an alternative method of generating the requi-
site ordinals and associated functions θα in place of the ϕα without any appeal to
fundamental sequences and in a uniform way from the function enumerating the
initial ordinals Ων of the number classes. Aczel quickly worked out the idea in
unpublished notes in a preliminary way; this was then developed systematically by
Jane Bridge in her 1972 Oxford dissertation, the results of which were published in
Bridge (1975). She showed how to match up the notations obtained in this way with
those obtained by the Bachmann-Pfeiffer-Isles procedures, and she initiated work
to show that the countable ordinals generated by these means are recursive. The
latter veriﬁcation was carried out systematically and in full in Buchholz (1975);
a detailed exposition of the deﬁnition and properties of the θ functions was later
given in Sch¨utte (1977) in the ﬁrst sections of Ch. IX. (We’ll return below to a
much later simpliﬁcation leading to the ψ functions in Buchholz (1992).)
The ﬁrst successful results on ordinal analysis for theories of iterated inductive
7BI is the scheme of Bar Induction, i.e. the implication from well-foundedness to transﬁnite induction.

Proof Theory of Inductive Deﬁnitions
13
deﬁnitions were obtained only on the intuitionistic side by Per Martin-L¨of (1971)
via normalization theorems for the IDn(acc)i systems as formulated in calculi of
natural deduction. He conjectured the bounds ϕε(Ωn+1)0 in the Bachmann-Pfeiffer
hierarchies for these and proved that their supremum is the ordinal of ID<ω(acc)i
by use of Takeuti (1967).
The ﬁrst breakthrough on the problems of ordinal analysis for the classical sys-
tems was made by Pohlers (1975) to give ordinal upper bounds for the ﬁnite IDn
also by an adaptation of the methods of Takeuti (1967); this was extended later in
his Habilitationsschrift, Pohlers (1977), to arbitrary α, with the result that
|IDα| ≤θε(Ωα+1)0
as measured in the modiﬁed hierarchies described above. In addition, Buchholz
and Pohlers (1978) showed this to be best possible by veriﬁcation of
θε(Ωα+1)0 ≤|IDα(acc)i|
using a constructive well-ordering proof of each proper initial segment of a natural
recursive ordering of order type θε(Ωα+1)0. These results lent further hope to the
solution of the reductive problem posed above. Independently of their work, in
his Stanford dissertation, Sieg (1977) adapted and extended the method of Tait
(1970) followed by a formalization of the cut-elimination argument to reduce IDα
to IDα+1(O)i, and thence ID<λ to ID<λ(O)i, for limit λ, without requiring any
involvement of ordinal bounds.
In view of these results, it was decided to exposit all this work together, with
the addition of suitable background material, in a Lecture Notes in Mathematics
volume. As it turned out, the resulting joint publication Buchholz et al. (1981)
contained important new contributions to the basic problems about theories of iter-
ated inductive deﬁnitions, and though that volume has been superseded in various
respects by later work, it still has much of value and I would recommend it as a
starting point to the reader interested in studying this subject in some depth. In
particular, my preface (Feferman 1981) to the volume ﬁlls out the historical pic-
ture to that point. Then the ﬁrst chapter, Feferman and Sieg (1981a), goes over
reductive relationships between various subsystems of Σ1
2 −AC, systems of it-
erated inductive deﬁnitions, and subsystems of the system T0 of explicit mathe-
matics from Feferman (1975). The second chapter, Feferman and Sieg (1981b)
showed how to obtain the reductions of Σ1
n+1 −AC to (Π1
n −AC)<ε0 by proof-
theoretic arguments (based on a method called Herbrand analysis by Sieg), in place
of the modeltheoretic arguments that had been used by Friedman. Following that,
Sieg (1981) presented the work of his thesis in providing the reductions of IDα
to IDα+1(O)i and of ID<λ to ID<λ(O)i for limit λ, without the intervention of

14
Solomon Feferman
ordinal analysis. In the next two chapters Buchholz (1981a, 1981b) introduced un-
countably inﬁnitary semi-formal systems making use of a special new Ωα+1-rule
in order, in the ﬁrst of these, to obtain the proof-theoretical reduction of the IDα to
suitable IDα(acc)i, and in the second to reestablish the ordinal bounds previously
obtained by Pohlers. Finally, in the last chapter, Pohlers (1981) presented a new ap-
proach called the method of local predicativity, to accomplish the very same results
in a different way. This dispensed with the earlier dependence on the methods of
Takeuti’s (1967); the more perspicuous method of local predicativity, in its place,
utilizes a kind of extension to uncountably branching proof trees of the methods of
predicative proof theory. But both Buchholz’ and Pohlers’ work in the Buchholz et
al. (1981) volume required the use of certain syntactically deﬁned collapsing func-
tions, in order to reduce prima-facie uncountable derivations to countable ones in a
way that allows one to obtain the recursive ordinal bounds. As will be described in
sec. 4, this was superseded a decade later by the work of Buchholz (1992) showing
how to obtain the same bounds without the use of such collapsing functions.
3 Admissible proof theory
Insofar as the work in Buchholz et al. (1981) settled the basic problem posed at
the beginning, it could be considered the end of the story. But the aim to develop
conceptually still clearer methods had already been underway, beginning with the
dissertation of Gerhard J¨ager (1979), also under Sch¨utte’s direction, but in that case
with Pohlers’ assistance. The novel element there was to embed various of the sub-
systems of analysis, both predicative and impredicative, in theories of admissible
sets, and to carry out the ordinal analysis of the latter by means of a cut-elimination
theorem for associated semi-formal systems of ramiﬁed set theory. The connec-
tion is that one can identify the minimal models of the theories of admissible sets
in question as natural initial segments of the constructible hierarchy. This method
was further elaborated in J¨ager’s Habilitationsschrift (1986) (though that relies on
the earlier publication for certain prooftheoretic results about ramiﬁed set theory).
The systems of admissible set theory considered by J¨ager are taken to have a set
of urelements interpreted as the set N of natural numbers given with its successor
relation. KPN has the usual axioms for Kripke-Platek set theory with urelements
(e.g. from Barwise (1975)), including the full induction scheme (INDN) on the
natural numbers and (IND∈) on the membership relation. KPN w is the system
obtained from KPN by replacing the ∈-induction scheme by the corresponding set
induction axiom, KPN r is obtained by further replacing the N-induction scheme
by the corresponding set induction axiom, and, ﬁnally, KPN 0 is obtained by com-
pletely dropping induction on the membership relation. We may also represent

Proof Theory of Inductive Deﬁnitions
15
KPN w as KPN r + INDN. Also considered are the extensions KPL and KPI
of KPN, obtained by adding the axioms that the universe is a limit of admissible
sets, and that the universe is an admissible limit of admissible sets, respectively;
these are also considered in the ’w’, ’r’, ’0’ restricted versions as for KPN.8 The
minimal constructible model Lα of KPI is that for which α is the least recursively
inaccessible ordinal.
Among the results of J¨ager (1986) is that KPI0 is a kind of universal theory for
systems having Γ0 as their proof theoretic ordinal, in the sense that all such systems
(up to that point) have natural embeddings in KPI0. Among these is Friedman’s
theory ATR0, which also has Γ0 as a lower bound. The proof theoretic treatement
of KPI0 via ramiﬁed set theory takes the place of the earlier proof by Friedman,
McAloon and Simpson (1982) of Γ0 as the ordinal of ATR0 via model-theoretic
arguments. Incidentally, ATR0 is already embeddable in KPL0, so KPI0 is
no stronger than that. Moving on to impredicative systems, ID1 is embedded in
KPN, which was shown to have the Howard ordinal as upper bound in J¨ager
(1979). The strongest system considered in J¨ager (1986) is KPI, and among the
further notable results for restricted subsystems of that are:
(Σ1
2 −AC)0 ≡KPIr, and Σ1
2 −AC ≡KPN r + INDN ≡KPIr + INDN,
where ≡is the relation of proof-theoretical equivalence; in both cases, the ordinal
analysis of the set-theoretic side is obtained via cut-elimination via the semi-formal
system of ramiﬁed set theory. The main upper bound result for the full KPI was
obtained in J¨ager and Pohlers (1983) using the method of local predicativity to
establish the ordinal upper bound, while (as explained below) the lower bound
follows from the work of J¨ager (1983):
Σ1
2 −AC + BI ≡KPI and |KPI| = ψΩ(εI+1),
where, for simplicity, I am using the notation introduced later by Buchholz (1992)
for the ψ functions in place of the θ functions. For example, the ordinal of IDα in
these terms is ψΩ(εΩα+1) in place of θε(Ωα+1)0.
In the survey article Pohlers (1998) it is shown how various subsystems of KPI
match up both with subsystems of Σ1
2 −AC + BI and with theories of iterated
inductive deﬁnitions, and their proof-theoretic ordinals are identiﬁed in terms of
the ψ functions; an informative table is given op. cit. p. 333. For example, we have
IDω ≡Π1
1−AC+BI ≡KPL. Among these are systems lying between Σ1
2−AC
8J¨ager (1986) uses KPu, KPl and KPi for what is here denoted by KPN, KPL and KPI,
resp. NB: the system denoted KPN in J¨ager (1979, 1980) is the same as KPur + INDN in the
notation of J¨ager (1986), and of KPNw, or alternatively KPNr + INDN, in the notation used
here. KPN is equivalent in strength to the system often denoted as KPω.

16
Solomon Feferman
and Σ1
2 −AC +BI in strength (alternatively described, between KPIw and KPI)
studied by Michael Rathjen in his dissertation (1988) at M¨unster under Pohlers’ di-
rection, including autonomously iterated theories of inductive deﬁnitions and cor-
responding systems of autonomously iterated Π1
1 −CA and of admissible sets; see
Pohlers (1998) sec. 3.3.5 for a partial account, since the work of Rathjen(1988) has
otherwise not yet been published.
The work on admissible proof theory has also been useful in dealing with sys-
tems of explicit mathematics that were formulated and studied in Feferman (1975,
1979). These systems have notions of operations f, g, . . . and classes (a.k.a. clas-
siﬁcations, properties, or [variable] types) A, B, C, . . ., both objects in a universe
V of individuals; relations R, S, . . . are treated as classes of pairs, using a basic
pairing operation on V . Operations are in general partial, but may apply to any
element of V , including operations and classes. The strongest system of explicit
mathematics dealt with op. cit. in which the operations have an interpretation as
partial recursive functions is denoted T0. For present purposes, I want only to con-
centrate on one axiom group of T0, concerning a general operation i of inductive
generation. Given any A and (binary) R, i(A, R) is always deﬁned and its value is
a class I that satisﬁes:
∀x ∈A[∀y((y, x) ∈R →y ∈I) →x ∈I]
In addition we have induction on I, which is either taken in the restricted class-
induction form
∀x ∈A[∀y((y, x) ∈R →y ∈X) →x ∈X] →I ⊆X.
or as a scheme obtained by substituting for X all formulas of the language of T0.
The system T0(res −IG) assumes only class-induction, while full T0 includes
the full scheme; the latter does not follow from the former since classes are only
assumed to satisfy predicative comprehension in T0. Informally, i(A, R) is the
well-founded part of the relation R, hereditarily in A.
It is easily seen that ID<ε(0)(acc)i is contained in T0(res −IG)i. Moreover,
T0(res −IG) is interpretable in Δ1
2 −CA. So, by the results described in the
preceding section we have
ID<ε0(acc)i ≡T0(res −IG)i ≡T0(res −IG) ≡Σ1
2 −AC.
Turning next to full T0, what J¨ager showed in his 1983 paper was that by use of a
primitive recursive ordering ⪯of order type ψΩ(εI+1), the well-ordering of each
initial segment of the ⪯relation can be established in T i
0. I had given an (easy)
interpretation of T0 in Δ1
2 −CA + BI. So that combined with the (much, much

Proof Theory of Inductive Deﬁnitions
17
harder) work of J¨ager and Pohlers (1983) and J¨ager (1983) established
T i
0 ≡T0 ≡Σ1
2 −AC + BI.
In analogy to the above, I conjecture that there is a suitable system ID<λ(acc)i in
some sense that can be added to the left of these equivalences.
4 A simpliﬁed version of local predicativity
That is the title of Buchholz (1992), the next main methodological improvement in
this approach. As he writes at the beginning of that paper:
The method of local predicativity as developed by Pohlers . . . and extended
to subsystems of set theory by J¨ager . . . is a very powerful tool for the ordinal
analysis of strong impredicative theories. But up to now it suffers considerably
from the fact that it is based on a large amount of very special ordinal theoretic
prerequisites. . . . The purpose of the present paper is to expose a simpliﬁed
and conceptually improved version of local predicativity which . . . requires
only amazingly little ordinal theory. . . . The most important feature of our
new approach however seems to be its conceptual clarity and ﬂexibility, and in
particular the fact that its basic concepts (i.e. the inﬁnitary system RS∞and
the notion of an H-controlled RS∞derivation) are in no way related to any
system of ordinal notations or collapsing functions. (Buchholz 1992, p. 117).
Buchholz there goes on to show how to carry out the ordinal analysis of KPI by
this new method in full, absorbable detail. Thenceforth, this simpliﬁed method of
local predicativity became the gold standard for admissible proof theory. It was
continued by Rathjen (1994) in a revised treatment of his 1991 ordinal analysis of
KPM, i.e. KP with an axiom saying that the universe is at the level of a Mahlo-
admissible ordinal. As he writes (op. cit.) p. 139, KPM is “somewhat at the verge
[i.e., upper margin] of admissible proof theory . . . Roughly speaking the central
scheme of KPM falls under the heading of ‘Π2-reﬂection with constraints’.” The
ﬁrst steps in moving beyond admissible proof theory to systems of analysis like
Π1
2 −CA, required dealing with Πn-reﬂection for arbitrary n, as discussed op. cit.,
pp. 142ff. For more recent progress — going far beyond our principal concerns
here — see Rathjen (2006).
5 Monotone inductive deﬁnitions
Though the formal theories of generalized inductive deﬁnitions as originally pro-
posed by Kreisel (1963) were of the form IDn(mon)i, their relationship to the sys-
tems IDn(acc)i was left unsettled by the work of Buchholz et al. (1981), as was the

18
Solomon Feferman
relationship for the corresponding classical systems.9 This was ﬁrst taken up in my
paper Feferman (1982a) for the 1981 Brouwer Centenary Symposium. I showed
there that, at least on the classical side, IDn(mon) is a conservative extension of
IDn(O) for all n. The method of proof is via an interpretation of IDn(mon) in a
predicative second order extension IDn(O)(2) which is easily shown to be a con-
servative extension of IDn(O). The main work goes into showing that if A(P, x) is
an arithmetical formula such that IDn−1(O)(2) proves the monotonicity condition
∀X∀Y ∀x[A(X, x) ∧X ⊆Y →A(X, x)] then one can deﬁne a predicate PA in
IDn(O)(2) to provably satisfy the required closure and induction scheme axioms.
In the same paper I also sketched how to generalize these arguments and results to
the case of ‘α’ in place of ‘n’. It follows from the work of Buchholz and Pohlers
described in sec. 2 that in general IDα(mon) is proof-theoretically reducible to
IDα(acc)i and the proof-theoretic ordinals are the same. Incidentally, as noted
by Kreisel in 1963, there is no obvious informal argument for the constructivity of
ID1(mon)i short of quantiﬁcation over species in the intuitionistic sense.
At the conclusion of Feferman (1982a) I brought attention to the formulation of
monotonic inductive deﬁnitions in the much more general setting of explicit math-
ematics. By an operation f from classes to classes, in symbols Cl −Op(f), we
mean one such that ∀X∃Y (fX = Y ); then by Mon(f) we mean C1 −Op(f) ∧
∀X∀Y [X ⊆Y →fX ⊆fY ]. The assertion ELFP(f) that f has a least
ﬁxed point is expressed as ∃X[fX ⊆X ∧∀Y (fY ⊆Y →X ⊆Y )]. I sug-
gested adding the following axiom MID for Monotone Inductive Deﬁnitions to
T0 : ∀f[Mon(f) →ELFP(f)], i.e. the statement that every monotonic operation
from classes to classes has a least ﬁxed point. And ﬁnally, I raised the question
whether T0 +MID is any stronger than T0, since as I wrote: “[it] includes all con-
structive formulations of the iteration of monotone inductive deﬁnitions of which I
am aware, while T0 (in its IG axiom) is based squarely on the general iteration of
accessibility inductive deﬁnitions. Thus it would be of great interest for the present
subject to settle the relationship between these theories.” At the time I thought that
my interpretation of T0 in Σ1
2 −AC + BI could somehow be extended to one for
T0 + MID, and thus give a general reduction of monotone to accessibility induc-
tive deﬁnitions. But as I said loc. cit., I did not succeed in doing this. In fact, it was
not obvious how to produce any model of T0 + MID, let alone one bounding its
strength by that of T0.
9At ﬁrst sight, one could obtain a simple reduction of the ID(mon) theories to the ID(pos) theories
(whether classical or intuitionistic) by an application of Lyndon’s interpolation theorem to formulas
of the form A(Q, P, x)∧∀u[P(u) →P ′(u)] →A(Q, P ′, x), derived from prior axiom schemes.
This was indeed stated in Sieg (1977); however, Buchholz pointed out to Sieg soon after that there is
a gap in the argument, since one should allow both P and P ′ to be used together in those schemes.
There is no obvious way to get around this obstacle.

Proof Theory of Inductive Deﬁnitions
19
The ﬁrst progress on these questions was made by my student Shuzuo Takahashi
in his PhD dissertation at Stanford, published as Takahashi (1989). He proved
that T0 + MID is interpretable in Π1
2 −CA + BI; this required a surprisingly
difﬁcult model construction, while no lower bound in strength was revealed by
Takahashi’s work. Meanwhile I had raised the question of the status of a uniform
version UMID of the MID axiom, obtained by adding a constant lfp to the lan-
guage of T0 with the statement that for any f, if Mon(f) then lfp(f) is a least
ﬁxed point of f; the consistency of T0 + UMID was unsettled by Takahashi’s
interpretation. These questions of strength were later addressed in a series of pa-
pers by Michael Rathjen (1996, 1998, 1999) and a joint one with Thomas Glass
and Andreas Schl¨uter (1997), all surveyed with some further extensions in Rathjen
(2002). Here, brieﬂy, are some of the results.
First of all, it was shown in Rathjen (1996) that T0 + MID is in fact stronger
than T0; in fact T0(res−IG)+MID proves the existence of a model of T0. Then
in Glass, Rathjen and Schl¨uter (1997) it was shown that
T0(res −IG) + MID ≡(Σ1
2 −AC)−+ (Π1
2 −CA)−, and
T0(res −IG) + INDN + MID ≡Σ1
2 −AC + (Π1
2 −CA)−,
where the minus sign superscript on a scheme indicates that there are no class
parameters (i.e. free class variables). Following that, Rathjen (2002) proved that
T0 + MID is bounded in strength by a theory K that is slightly stronger than
Σ1
2 −AC + (Π1
2 −CA)−+ BI.
Rathjen (1999, 2002) also obtained results about the strength of UMIDN
(which is the UMID principle relativized to subclasses of N), including the fol-
lowing:
T0(res −IG) + UMIDN ≡(Π1
2 −CA)0,
while
Π1
2 −CA < T0 + UMIDN ≤Π1
2 −CA + BI.
Rathen conjectured (2002), p. 339, that the ≤here can be replaced by ≡and that
UMID gives no stronger theory than UMIDN. Finally, it is shown there that
T0 + MID < T0 + UMIDN.
All these results are for the systems of explicit mathematics as based on classical
logic. About the intuitionistic side of these various theories, Rathjen wrote (loc.
cit.) that virtually nothing is known. However, subsequently, Sergei Tupailo (2004)
established that the classical and intuitionistic versions of T0(res−IG)+UMIDN
are of the same strength, by an indirect argument via the so-called μ-calculus.10
10Michael Rathjen has informed me that there is an alternative more direct argument to obtain Tupailo’s

20
Solomon Feferman
A number of problems about the MID and UMID principles in explicit math-
ematics are still left open by this work, especially on the intuitionistic side.
6 The method of functional interpretation, 1968-2008
All of the proof-theoretical analyses of classical theories of iterated inductive def-
initions surveyed above made use of cut-elimination arguments applied to suit-
able uncountably inﬁnitary sequent-style systems. But for the purely reductive part
of the problem, it seemed to me from the beginning that an extension of G¨odel’s
method of functional interpretation could serve to establish the expected results us-
ing ﬁnite formulas throughout. In an unpublished lecture that I gave at the 1968
Buffalo conference — though circulated in mimeographed notes Feferman (1968)
— I obtained a semi-constructive functional interpretation of ID1 in the classical
system ID1(T), where the set T of constructive countable tree ordinals is a variant
of O. The hope was to then reduce ID1(T) to a suitable ID1(acc)i and thereby
show that |ID1| is the Howard ordinal, but I did not see how to get around the obsta-
cle of essential use of numerical quantiﬁcation (in its guise as the non-constructive
minimum operator μ) in doing so. The next attempts to approach this and the iter-
ated case via functional interpretation were made by my student Jeffery Zucker in
his dissertation (1971), the work from which was published in Zucker (1973). In-
terestingly, Zucker showed that |ID1| = |ID1(acc)i| by application of Howard’s
majorization technique to my functional interpretation with the μ-operator. How-
ever, he did not see a way to extend this to the iterated case. What he was able
to do was give a Kreisel-style modiﬁed realizability functional interpretation of
IDn(acc)i in a theory of constructive tree classes up to level n for each n < ω and
show that they have the same provably recursive ordinals; he also sketched how
this could be extended to transﬁnite α.
My notes Feferman (1968) and questions about its approach did not see the gen-
eral light of day until they were outlined in sec. 9 of my survey with Jeremy Avigad
in the Handbook of Proof Theory of G¨odel’s functional interpretation, Avigad and
Feferman (1998); I included that section there in the hopes that someone would see
how to overcome the obstacle that I had met. To my great satisfaction, that was
ﬁnally achieved by Avigad with his student Henry Towsner in 2008 by a variant
functional interpretation; the fact that this took place in the year of celebration of
Wolfram Pohlers’ retirement is the reason why I subtitled this piece a forty year
result via an application of the double negation translation to the operator theory T OP
<ω of Rathjen
(1998), which is of the same strength as T0(res −IG) + UMIDN; moreover the same method
applies to T OP
<ε(0) which is of the same strength as T0(res −IG) + INDN + UMIDN and
thence of its intuitionistic version.

Proof Theory of Inductive Deﬁnitions
21
long saga. Since this is relatively new and unfamiliar material, I want to sketch
how the approach in Avigad and Towsner (2008) proceeds.
As background, let’s look brieﬂy at G¨odel’s original Dialectica (or D-) inter-
pretation (1958, 1972) and its consequences; subsequent work follows a broadly
similar pattern. G¨odel applied the D-interpretation to Heyting Arithmetic HA to
reduce it to a quantiﬁer-free theory of primitive recursive functionals of ﬁnite type
over N that he simply denoted by ’T’. This is carried out via an intermediate
translation which sends each formula A of arithmetic into a formula AD of the
form ∃z∀xAD(z, x) where z, x are sequences of variables of ﬁnite type (possibly
empty) and AD is a quantiﬁer free formula of the language of T. The main theorem
was that if HA ⊢A then T ⊢AD(t, x) for some sequence t of terms of the same
type as z; this gives the reduction HA ≤T. A is equivalent to AD under the as-
sumption of the Axiom of Choice, which in this setting is constructively accepted,
plus the non-constructive Markov’s Principle and a principle called Independence
of Premises. But the interpretation of A by AD can be applied in combination with
the double negation translation of PA into HA to show that these systems have
the same provably recursive functions and that, moreover, they are the same as the
functions of type 1 generated by the terms of T. For if PA ⊢∀x∃yR(x, y) with R
primitive recursive then HA ⊢∀x¬¬∃yR(x, y) and so by Markov’s Principle and
the Axiom of Choice we have ∃z∀xR(x, z(x)); ﬁnally, by the D-interpretation,
there is a closed term of type 1 such that T ⊢R(x, t(x)). The set of functions of
type 1 generated by the primitive recursive functionals of ﬁnite type is called the
1-section of T. So this result can be summarized by the equations
Prov −Rec(PA) = Prov −Rec(HA) = 1 −sec(T).
Further work must be done if one wants to use this to recapture the result of Kreisel
(1952) that the provably recursive functions of PA and HA are just those obtained
by recursion on ordinals α < ε0. This can be obtained via the normalization of the
terms of T using an assignment to them of ordinals < ε0. That was ﬁrst carried out
by Tait (1965) and later by Howard (1970) in ways akin to the use of ordinals < ε0
in the cut elimination arguments for PA by Sch¨utte and Gentzen, respectively.
The details for the functional interpretation of theories of inductive deﬁnition
are only given in full for ID1 in Avigad and Towsner (2008) and sketched for
arbitrary IDn in their ﬁnal section, though they say it can be extended to transﬁnite
iterations. The ﬁrst step, for a given arithmetical A(P, x), is to translate ID1 into
the classical theory OR1 of abstract countable tree ordinals extended by axioms (I)
for a predicate I(x, α) of natural numbers and (tree) ordinals, interpreted as x ∈Iα
in the approximations from below to the least ﬁxed point of A. The functional
interpretation is then used to obtain a reduction of OR1 + (I) to an ID1(acc)i
via a quantiﬁer-free theory TΩ of primitive recursive functionals of ﬁnite type over

22
Solomon Feferman
the tree ordinals and two of its extensions, QTΩ, which allows quantiﬁers over all
ﬁnite type variables, and Q0TΩ, which allows only numerical quantiﬁcation; unless
otherwise indicated both are in classical logic. Avigad and Towsner show that
OR1 +(I) ≤Q0TΩ by the Diller-Nahm-Shoenﬁeld variant of the D-interpretation.
The problem then is to get rid of Q0 and pass to intuitionistic logic, which was
essentially the obstacle that I and Zucker had met. The novel key step is to establish
the reduction Q0TΩ ≤(QTΩ)i, using an adaptation of the argument in Sieg (1981)
to formalize cut-elimination for a semi-formal version of Q0TΩ in (QTΩ)i. Finally,
the model of TΩ and thence of (QTΩ)i in the hereditarily recursive operations over
the recursive countable tree ordinals may be formalized in ID1(O)i. Chaining
together these successive reductions, Avigad and Towsner obtain:
ID1 ≤ID1(O)i, |ID1| = |ID1(O)i|, and
Prov −Rec(ID1) = Prov −Rec(ID1(O)i) = 1 −Sec(TΩ).
As I said, they assert that the same methods serve to establish IDα ≤IDα(O)i
and |IDα| = |IDα(O)i| in general; it would be good to see the details of that
presented in full. But assuming that is the case, on the basis of present evidence this
work of Avigad and Towsner is an improvement on both Sieg (1977, 1981), which
only obtained IDα ≤IDα+1(O)i, and Buchholz (1981a), which only obtained
IDα ≤IDα(acc)i. In addition, their functional interpretation has the advantage
of giving a mathematical characterization of the provable recursive functions of
a given ID theory in terms of the 1-section of a natural class of functionals. Of
course, one would need to use something like the methods of local predicativity
with ordinal analysis in order to further describe those functions in terms of suitable
ordinal recursions.
7 Conclusion
All the work surveyed here illustrates how the initial aim to use the constructive
reduction and ordinal analysis of theories of iterated inductive deﬁnitions for the
extension of Hilbert’s program to impredicative systems of analysis became trans-
muted into a subject of interest in its own right. In addition, the continuing desire
for conceptually clear arguments led to successive methodological improvements,
which in turn proved useful in other applications. Though the proof theory of it-
erated inductive deﬁnitions as ﬁrst order systems falls far short of serving to deal
with the next level of impredicative systems of analysis such as Π1
2 −CA, the work
described in sec. 5 on classical and constructive theories of monotonic inductive
deﬁnitions suggests that suitable second order theories of such may be useful for
that purpose.

Proof Theory of Inductive Deﬁnitions
23
To conclude, here are some questions suggested by the work that has been sur-
veyed above.
1. One does not have to be a devotee of purity of method to ask whether an al-
ternative, more purely functional interpretation approach might be possible to
arrive at the reduction IDα ≤IDα(O)i in general. Recall that Zucker (1973)
showed that the proof theoretic ordinals of ID1 and TΩ are the same by ap-
plying the majorization argument of Howard (1973) to the semi-constructive
functional interpretation of my 1968 notes. For me, this is reminiscent of the
use by Kohlenbach (1992) of his method of monotone functional interpretation
to eliminate numerical quantiﬁcation in the reduction of the system WKL to
PRA.
So the question is whether the appeal to cut-elimination in the ﬁnal step of
the Avigad and Towsner work both for ID1 and in general for IDα can be
avoided by an application of the monotone functional interpretation or one of
its variants, such as the bounded functional interpretation of Ferreira and Oliva
(2005). Incidentally, I was misled by the work of Avigad and Towsner (2008)
into thinking that they had somehow reﬁned Sieg’s argument to replace ’α+1’
by ’α’ in the target system. But it seems that that was only possible in com-
bination with their use of functional interpretation. So if a purely functional
interpretation approach does not succeed to obtain a proof-theoretic reduction
of IDα to IDα(O)i, it is still a question whether a reﬁnement of Sieg’s argu-
ments using cut elimination can achieve the same result.
2. What part of mathematics can be carried out in ID1? A recent interesting
case study is provided by Avigad and Towsner (2009) (cf. also Avigad (2009)
sec. 5): a version of the structure theorem in combinatorial ergodic theory
due to Furstenberg (1977) can be formalized in ID1, via the interpretation in
Q0TΩ + (I) described in the preceding section. That theorem was used by
Furstenberg to prove by conceptually high level means the famous theorem
of Szemer´edi (1975), whose original combinatorial proof was very difﬁcult.
The work of Beleznay and Foreman (1996) suggests that the full Furstenberg
structure theorem is equivalent to the Π1
1 comprehension axiom. But the work
of Avigad and Towsner shows that the full strength of the structure theorem is
far from necessary for the ergodic-theoretic proof of the Szemer´edi theorem.
As this example shows, it may be that the pursuit of what other mathematics
can be formalized in ID1 is more conveniently examined in proof-theoretically
equivalent systems in which ordinals play an explicit role, such as the theory
OR1 + (I) or its functional interpretations in the preceding section.
3. What about what can be done in iterated IDs?

24
Solomon Feferman
4. Ordinal analysis only tells us something about the provably countable ordinals
of a theory. In the case of the IDαs, it would seem to make sense to talk about
their provably uncountable ordinals. How would that be deﬁned, and what can
be established about them?
5. ID1 is similar to Peano Arithmetic in various respects. In Feferman (1996) I
introduced the general notion of an open-ended schematic axiom system and its
unfolding, to explain the idea of what we ought to accept if we have accepted
given notions and given principles concerning them. In Feferman and Strahm
(2000) we showed that the full unfolding of a very basic schematic system
NFA for non-ﬁnitist arithmetic is proof-theoretically equivalent to predicative
analysis. There is a natural formulation of a basic schematic system NFI
which stands to ID1 as NFA stands to PA. What is its unfolding?
6. A side development of the work on theories of iterated inductive deﬁnitions
is that on theories of iterated ﬁxed point theories ID∧
α, whose basic axiom
for a given A takes the form ∀x[A(PA, x) ↔PA(x)]. Building on work of
Aczel characterizing the strength of ID∧
1 , I showed in Feferman (1982b) that
the union of the ﬁnitely iterated ﬁxed point theories is equivalent in strength
to predicative analysis. That work was continued into the transﬁnite by J¨ager,
Kahle, Setzer and Strahm (1999) who showed that even though one thereby
goes beyond predicativity in strength, the methods of predicative proof theory
can still be applied. They thus introduced the term metapredicativity for the
study of systems that can be treated by such means. In unpublished work by
J¨ager and Strahm, that even goes beyond ID1. One should try to characterize
the domain of metapredicativity in terms analogous to those used at the out-
set to characterize predicativity as the limit of the autonomous progression of
ramiﬁed systems. Assuming that, I would conjecture that the full unfolding of
the schematic system NFI suggested above is proof-theoretically equivalent to
the union of the metapredicative systems.
7. The set-theoretical treatment of least ﬁxed points of monotonic operator apply
to operators on subsets of arbitrary sets M. Are there reasonable theories of
IDs over other sets than the natural numbers, e.g. the real numbers? What can
be said about their strength?
8 Acknowledgements
I wish to thank Jeremy Avigad, Wilfried Buchholz, Gerhard J¨ager, Grigori Mints,
Michael Rathjen, Wilfried Sieg, Thomas Strahm and Henry Towsner for their use-
ful comments on a draft of this article.

Proof Theory of Inductive Deﬁnitions
25
References
[1] P. Aczel, H. Simmons and S. Wainer, eds. (1992), Proof Theory, Cambridge University
Press, Cambridge.
[2] J. Avigad (2009), The metamathematics of ergodic theory, Annals of Pure and Applied
Logic 157, 64-76.
[3] J. Avigad and S. Feferman (1998), G¨odel’s functional (“Dialectica”) interpretation, in
Buss (1998), 337-405.
[4] J. Avigad and H. Towsner (2008), Functional interpretation and inductive deﬁnitions,
http://arxiv.org/abs/0802.1938; to appear in J. Symbolic Logic.
[5] J. Avigad and H. Towsner (2009), Metastability in the Furstenberg-Zimmer tower,
http://arxiv.org/abs/0902.0356.
[6] H. Bachmann (1950), Die Normalfunktionen und das Problem der ausgezeichneten
Folgen von Ordnungzahlen, Vierteljahresschr. Nat. Ges., Z¨urich 95, 5-37.
[7] J. Barwise (1975), Admissible Sets and Structures, Springer-Verlag, Berlin.
[8] F. Beleznay and M. Foreman (1996), The complexity of the collection of measure-
distal transformations, Ergodic Theory and Dynamical Systems 16, 929-962.
[9] J. Bridge (1975), A simpliﬁcation of the Bachmann method for generating large count-
able ordinals, J. Symbolic Logic 40, 171-185.
[10] W. Buchholz (1975), Normalfunktionen und konstruktiven Systeme von Ordi-
nalzahlen, in Proof Theory Symposion, Kiel 1974, Lecture Notes in Mathematics 500,
4-25.
[11] W. Buchholz (1981a), The Ωμ+1-rule, in Buchholz et al. (1981), 188-233.
[12] W. Buchholz (1981b), Ordinal analysis of IDν, in Buchholz et al. (1981), 234-260.
[13] W. Buchholz (1992), A simpliﬁed version of local predicativity, in Aczel et al. (1992),
115-147.
[14] W. Buchholz (1997) Explaining Gentzen’s consistency proof within inﬁnitary proof
theory, in G. Gottlob, A. Leitsch and D. Mundici (eds.), Computational Logic and
Proof Theory. KGC ’97, Lecture Notes in Computer Science 1298.
[15] W. Buchholz (2001) Explaining the Gentzen-Takeuti reduction steps: A second-order
system, Archive for Mathematical Logic 40,
[16] W. Buchholz, S. Feferman, W. Pohlers and W. Sieg (1981), Iterated Inductive Deﬁni-
tions and Subsystems of Analysis: Recent proof-theoretical studies, Lecture Notes in
Mathematics 897.
[17] W. Buchholz and W. Pohlers (1978), Provable well-orderings of formal theories for
transﬁnitely iterated inductive deﬁnitions, J. Symbolic Logic 43, 118-125.
[18] S. R. Buss, ed. (1998), Handbook of Proof Theory, Elsevier, Amsterdam.

26
Solomon Feferman
[19] A. Church and S. C. Kleene (1936), Formal deﬁnitions in the theory of ordinal num-
bers, Fundamenta Mathematicae 28, 11-21.
[20] S. Feferman (1968), Ordinals associated with theories for one inductively deﬁned set.
(Unpublished notes.)
[21] S. Feferman (1970) Formal theories for transﬁnite iteration of generalized inductive
deﬁnitions and some subsystems of analysis, in Kino et al. (1970), 303-326.
[22] S. Feferman (1975), A language and axioms for explicit mathematics, in J. N. Crossley
(ed.) Algebra and Logic, Lecture Notes in Mahtematics 450, 87-139.
[23] S. Feferman (1979), Constructive theories of functions and classes, in M. Boffa et al.
(eds.) Logic Colloquium ’78, North-Holland, Amsterdam, 159-224.
[24] S. Feferman (1981), How we got from there to here, in Buchholz et al. (1981), 1-15.
[25] S. Feferman (1982a), Iterated inductive ﬁxed-point theories: application to Hancock’s
conjecture, in G. Metakides (ed.), Patras Logic Symposion, North-Holland, Amster-
dam, 171-196.
[26] S. Feferman (1982b), Monotone inductive deﬁnitions, in A. S. Troelstra and D. van
Dalen (eds.), The L.E.J. Brouwer Centenary Symposium, North-Holland, Amsterdam,
77- 89.
[27] S. Feferman (1988), Hilbert’s program relativized: proof-theoretical and foundational
reductions, J. Symbolic Logic 53, 364-384.
[28] S. Feferman (1993), What rests on what? The proof-theoretical and foundational anal-
ysis of mathematics, in J. Czermak (ed.), Philosophy of Mathematics, Vol.I, Verlag-
H¨older- Pichler-Tempsky, Vienna, 147-171. Reprinted in Feferman 1998, 187-208.
[29] S. Feferman (1996), G¨odel’s program for new axioms: Why, where, how and what?, in
P. H´ajek (ed.), G¨odel ’96, Lecture Notes in Logic 6, 3-22.
[30] S. Feferman (1998), In the Light of Logic, Oxford University Press, New York.
[31] S. Feferman (2000) Does reductive proof theory have a viable rationale?, Erkenntnis
53, 63-96.
[32] S. Feferman and W. Sieg (1981a), Iterated inductive deﬁnitions and subsystems of
analysis, in Buchholz et al. (1981), 16-77.
[33] S. Feferman and W. Sieg (1981b) Proof theoretic equivalences between classical and
constructive theories for analysis, in Buchholz et al. (1981) 78-142.
[34] S. Feferman and T. Strahm (2000), The unfolding of non-ﬁnitist arithmetic, Annals of
Pure and Applied Logic 104, 75 - 96.
[35] F. Ferreira and P. Oliva (2005), Bounded functional interpretation, Annals of Pure and
Applied Logic 135, 73-112.
[36] H. M. Friedman (1970) Iterated inductive deﬁnitions and Σ1
2 −AC, in Kino, Myhill
and Vesley 1970, 435-442.

Proof Theory of Inductive Deﬁnitions
27
[37] H. M. Friedman, K. McAloon, and S. G. Simpson (1982), A ﬁnite combinatorial prin-
ciple which is equivalent to the 1-consistency of predicative analysis, in G. Metakides
(ed.), Patras Logic Symposion, North-Holland, Amsterdam, 197-230.
[38] H. Furstenberg (1977), Ergodic behavior of diagonal measures and a theorem of Sze-
mer´edi on arithmetic progressions, J. d’Analyse Mathematique 31, 204-256.
[39] T. Glass, M. Rathjen and A. Schl¨uter (1997), The strength of monotone inductive deﬁ-
nitions in explicit mathematics, Annals of Pure and Applied Logic 85, 1-46.
[40] K. G¨odel (1958), ¨Uber eine bisher noch nicht ben¨uzte Erweiterung des ﬁniten Stand-
punktes, Dialectica 12, 280-287. Reproduced with English translation in G¨odel (1990),
241-251.
[41] K. G¨odel (1972), On an extension of ﬁnitary methods which has not yet been used, in
G¨odel (1990), 271-280.
[42] K. G¨odel (1990), Collected Works,Vol. II. Publications 1938-1974 (S. Feferman, et al.,
eds.), Oxford University Press, New York.
[43] A. Heyting, ed. (1959), Constructivity in Mathematics, North-Holland, Amsterdam.
[44] W. A. Howard (1970), Assignment of ordinals to terms for primitive recursive func-
tionals of ﬁnite type, in Kino et al. (1970), 453-468.
[45] W. A. Howard (1972), A system of abstract constructive ordinals, J. Symbolic Logic
37, 355-374.
[46] W. A. Howard (1973), Hereditarily majorizable functionals of ﬁnite type, in Troelstra
(1973), 454-461.
[47] D. Isles (1970), Regular ordinals and normal forms, in Kino et al. (1970), 339-361. 25
[48] G. J¨ager (1979), Die Konstruktible Hierarchie als Hilfsmittel zur beweistheoretischen
Untersuchung von Teilsystemen der Mengenlehre und Analysis, Dissertation, Ludwig-
Maximilians-Universit¨at, Munich.
[49] G. J¨ager (1980), Beweistheorie von KPN, Archiv f¨ur Mathematische Logik und Grund-
lagenforschung 20,
[50] G. J¨ager (1983), A well-ordering proof for Feferman’s theory T0, Archive for Mathe-
matical Logic 23, 65-77.
[51] G. J¨ager (1986), Theories for Admissible Sets. A unifying approach to proof theory,
Bibliopolis, Naples.
[52] G. J¨ager, R. Kahle, A. Setzer and T. Strahm (1999), The proof-theoretic analysis of
transﬁnitely iterated ﬁxed point theories, J. Symbolic Logic 64, pp. 53 - 67.
[53] G. J¨ager and W. Pohlers (1983), Eine beweistheoretische Untersuchung von (Δ1
2 −
CA) + (BI) und verwandter Systeme, Bayerische Akademie der Wissenschaften,
Sitzungsberichte 1982, 1-28.
[54] A. Kino, J. Myhill and R. Vesley, eds. (1970), Intuitionism and Proof Theory, North-
Holland, Amsterdam.

28
Solomon Feferman
[55] S. C. Kleene (1938), On notation for ordinal numbers, J. Symbolic Logic 3, 150-155.
[56] S. C. Kleene (1959), Countable functionals, in Heyting (1959), 81-100.
[57] U. Kohlenbach (1992), Effective bounds from ineffective proofs in analysis: an ap-
plication of functional interpretation and majorization, J. Symbolic Logic 57, 1239-
1273.
[58] G. Kreisel (1952), On the interpretation of non-ﬁnitist proofs, part II: interpretation of
number theory, applications, J. Symbolic Logic17, 43-58.
[59] G. Kreisel (1959) Interpretation of analysis by means of constructive functionals of
ﬁnite type, in Heyting (1959), 101-128.
[60] G. Kreisel (1963), Generalized inductive deﬁnitions, in Seminar on the Foundations
of Analysis, Stanford 1963. Reports (mimeographed), Mathematical Sciences Library,
Stanford University, 3.1-3.25.
[61] P. Martin-L¨of (1971), Hauptsatz for the intuitionistic theory of iterated inductive deﬁ-
nitions, in J. E. Fenstad (ed.), Proceedings of the Second Scandinavian Logic Sympo-
sium, North-Holland, Amsterdam, 179-216.
[62] H. Pfeiffer (1964), Ausgezeichnete Folgen f¨ur gewisse Abschnitte der zweiten und
weiteren Zahlklassen, Dissertation, Technische Hochschule Hannover.
[63] W. Pohlers (1975), An upper bound for the provability of transﬁnite induction in sys-
tems with N-times iterated inductive deﬁnitions, in J. Diller and G. H. M¨uller (eds.),
ISILC Proof Theory Symposium, Lecture Notes in Mathematics 500, 271-289.
[64] W. Pohlers (1977), Beweistheorie der iterierten induktiven Deﬁnitionen, Habilitation-
sschrift, Ludwig-Maximilians-Universit¨at, Munich.
[65] W. Pohlers (1981) Proof-theoretical analysis of IDν by the method of local predica-
tivity, in Buchholz et al. (1981), 261-357.
[66] W. Pohlers (1987), Contributions of the Sch¨utte school in Munich to proof theory, in
Takeuti (1987), 406-431.
[67] W. Pohlers (1989) Proof Theory. An introduction, Lecture Notes in Mathematics, v.
1407.
[68] W. Pohlers (1992) A short course in ordinal analysis, in Aczel et al. (1992), 27-78.
[69] W. Pohlers (1998) Subsystems of set theory and second order number theory, in Buss
(1998), 209-335.
[70] W. Pohlers (2009) Proof Theory. The ﬁrst step into impredicativity, Springer-Verlag,
Berlin.
[71] M. Rathjen (1988), Untersuchungen zu Teilsystemen der Zahlentheorie zweiter Stufe
und der Mengenlehre mit einer zwischen Δ1
2 −CA und Δ1
2 −CA + BI liegenden
Beweisst¨arke, Doctoral thesis, University of M¨unster.
[72] M. Rathjen (1994), Admissible proof theory and beyond, in D. Prawitz, B. Skyrms,
and D. Westerstahl (eds.), Logic, Methodology and Philosophy of Science IX, Elsevier,
Amsterdam.

Proof Theory of Inductive Deﬁnitions
29
[73] M. Rathjen (1996), Monotone inductive deﬁnitions in explicit mathematics, J. Sym-
bolic Logic 61, 125-146
[74] M. Rathjen (1998), Explicit mathematics with the monotone ﬁxed point principle, J.
Symbolic Logic 63, 509-542.
[75] M. Rathjen (1999), Explicit mathematics with the monotone ﬁxed point principle. II:
Models, J. Symbolic Logic 64, 517-550.
[76] M. Rathjen (2002), Explicit mathematics with monotone inductive deﬁnitions: A sur-
vey, in Sieg, et al. (2002), 329-346.
[77] M. Rathjen (2006), The art of ordinal analysis, in Proceedings of the International
Congress of Mathematicians, Vol. II, European Mathematical Society, 45-69.
[78] K. Sch¨utte (1977), Proof Theory, Springer-Verlag, Berlin.
[79] W. Sieg (1977), Trees in Metamathematics. Theories of inductive deﬁnitions and sub-
systems of analysis, PhD Dissertation, Stanford University.
[80] W. Sieg (1981), Inductive deﬁnitions, constructive ordinals, and normal derivations, in
Buchholz et al. (1981), 143-187.
[81] W. Sieg, R. Sommer and C. Talcott, eds. (2002), Reﬂections on the Foundations of
Mathematics. Essays in honor of Solomon Feferman, Lecture Notes in Logic 15, As-
soc. for Symbolic Logic, A.K. Peters, Ltd., Natick.
[82] C. Spector (1962), Provably recursive functions of analysis: a consistency proof of
analysis by an extension of principles formulated in current intuitionistic mathematics,
in J. C. E. Dekker (ed.), Recursive Function Theory. Proc. Symposia in Pure Mathe-
matics 5, AMS, Rhode Island, 1-27.
[83] E. Szemer´edi (1975), On sets of integers containing no k elements in arithmetic pro-
gression, Acta Arithmetica 27, 199-245.
[84] W. W. Tait (1965), Inﬁnitely long terms of transﬁnite type, in J. N. Crossley and M. A.
E. Dummett (eds.), Formal Systems and Recursive Functions, North-Holland, Amster-
dam, 176-185.
[85] W. W. Tait (1970) Applications of the cut elimination theorem to some subsystems of
classical analysis, in Kino et al. (1970), 475-488.
[86] S. Takahashi (1989), Monotone inductive deﬁnitions in a constructive theory of func-
tions and classes, Annals of Pure and Applied Logic 42, 255-279.
[87] G. Takeuti (1967), Consistency proofs of subsystems of classical analysis, Annals of
Mathematics 86, 299-348.
[88] G. Takeuti (1987), Proof Theory, North-Holland, Amsterdam, 2nd edn, (with appen-
dices by G. Kreisel, W. Pohlers, S. Simpson and S. Feferman).
[89] G. Takeuti and M. Yasugi (1973), The ordinals of the system of second order arithmetic
with the provably Δ1
2-comprehension axiom and with the Δ1
2-comprehension axiom
respectively, Japanese J. of Mathematics 41, 1-67.

30
Solomon Feferman
[90] A. S. Troelstra, ed. (1973), Metamathematical Investigation of Intuitionistic Arithmetic
and Analysis, Lecture Notes in Mathematics 344.
[91] S. Tupailo (2004), On the intuitionistic strength of monotone inductive deﬁnitions, J.
Symbolic Logic 69, 790-798.
[92] J. I. Zucker (1971), Proof Theoretic Studies of Systems of Iterated Inductive Deﬁni-
tions and Subsystems of Analysis, PhD Dissertation, Stanford University. J. I. Zucker
(1973), Iterated inductive deﬁnitions, trees and ordinals, in Troelstra (1973) 392-453.
Stanford University.

A New Approach to Predicative Set Theory
Arnon Avron
School of Computer Science
Tel Aviv University
Tel Aviv, Israel
aa@cs.tau.ac.il
Abstract We suggest a new basic framework for the Weyl-Feferman pred-
icativist program by constructing a formal predicative set theory PZF
which resembles ZF. The basic idea is that the predicatively acceptable
instances of the comprehension schema are those which determine the col-
lections they deﬁne in an absolute way, independent of the extension of the
“surrounding universe”. This idea is implemented using syntactic safety re-
lations between formulas and sets of variables. These safety relations gen-
eralize both the notion of domain-independence from database theory, and
G¨odel notion of absoluteness from set theory. The language of PZF is type-
free, and it reﬂects real mathematical practice in making an extensive use of
statically deﬁned abstract set terms. Another important feature of PZF is
that its underlying logic is ancestral logic (i.e. the extension of FOL with a
transitive closure operation).
1 Introduction
The predicativist program for the foundations of mathematics, initiated by Poincar´e
in [35, 36] 1, and ﬁrst seriously developed by Weyl in [50], seeks to establish cer-
tainty in mathematics without revolutionizing it (as the intuitionistic program does).
The program as is usually conceived nowadays (following Weyl and Feferman) is
based on the following two basic principles:
(PRE) Higher order constructs, such as sets or functions, are acceptable only when
introduced through deﬁnitions. These deﬁnitions cannot be circular. Hence in
deﬁning a new construct one can only refer to constructs which were intro-
duced by previous deﬁnitions.
(NAT) The natural-numbers sequence is a basic well understood mathematical
concept, and as a totality it constitutes a set.
1Though its kernel can be found in Richard’s discussion of his paradox [38].

32
Arnon Avron
The ﬁrst of these principles, (PRE), was interpreted by Russell according to his
philosophical views of logic, [39], [40], and incorporated as the ramiﬁed type theory
(RTT) in Principia Mathematica ( [51]). In RTT objects are divided into types, and
each higher-order type is further divided into levels. However, the use of levels
makes it impossible to develop mathematics in RTT, and so Russell had to add a
special axiom of reducibility which practically destroyed the predicative nature of
his system ( [37]). The principle was then taken again by Weyl in [50], but instead
of Russell’s ramiﬁed hierarchy, Weyl adopted the second principle, (NAT), which
also goes back to Poincar´e. Weyl’s predicativist program was later extensively
pursued by Feferman, who in a series of papers (see e.g. [15,17,19,20]) developed
proof systems for predicative mathematics. Feferman’s systems are less complex
than RTT, and he has shown that a very large part of classical analysis can be
developed within them. He further conjectured that predicative mathematics in fact
sufﬁces for developing all the mathematics that is actually indispensable to present-
day natural sciences.
Despite this success, Feferman’s systems failed to receive in the mathematical
community the interest they deserve. Unlike constructive mathematics, they were
also almost totally ignored in the computer science community. The main reason
for this seems to be the fact that on the one hand Feferman’s systems are not “rev-
olutionary” (since they allow the use of classical logic), but on the other hand they
are still rather complicated in comparison to the impredicative formal set theory
ZF, which provides the standard foundations and framework for developing math-
ematics. In particular: Feferman’s systems still use complicated systems of types,
and both functions and classes are taken in them as independent primitives. There-
fore working within Feferman’s systems is not easy for someone used to ZF (or
something similar).
The main goal of this paper is to suggest a new framework for the Weyl-Feferman
predicativist program by constructing an absolutely (at least in our opinion) reliable
predicative set theory PZF which is suitable for mechanization, and has the fol-
lowing properties:
1. Its language is type-free, and it reﬂects real mathematical practice by making
an extensive use of abstract set terms (i.e. terms of the form {x | ϕ}). 2.
2. Like ZF, it is a pure set theory, in which everything (including functions) is
assumed to be a set. Moreover: from a platonic point of view, the universe V
of ZF (whatever this universe is) is a model of it.
2The use of such terms, albeit in a somewhat cumbersome form, more complicated than that actually
used in mathematical texts, is also a major feature of the systems developed in [8,9].

A New Approach to Predicative Set Theory
33
3. ZF itself (or each intuitively true extension of it) is obtainable from it in a
straightforward way.
2 The Main Ideas
2.1 Interpreting and Implementing Principle (PRE)
According to our approach, a predicative set theory need not exclude the possibility
that “arbitrary (undeﬁnable) sets of integers”, or “real numbers”, or even “arbitrary
sets of reals”, do exist in some sense, and that propositions about them might be
meaningful. However, it cannot be committed to the existence of such entities. Ac-
cordingly, one may formulate and use in such a theory propositions that refer to all
sets. However, only those of them which are true independently of the exact exten-
sion of “the true universe V of sets” may be theorems. Therefore classical logic is
acceptable, but there should be restrictions on principles that entail the existence “in
the universe” of certain objects. Now the major existence principle of naive set the-
ory is given by the comprehension scheme, and so it is this principle that should be
restricted. We suggest that principle (PRE) means that the predicatively acceptable
instances of the comprehension scheme are those which determine the collections
they deﬁne in an absolute way, independently of any “surrounding universe”. In
other words: according to our interpretation of (PRE) in the context of set theory, a
formula ψ is predicative (with respect to x) if the collection {x | ψ(x, y1, . . . ,yn)}
is completely and uniquely determined by the identity of the parameters y1, . . . ,yn,
and the identity of other objects referred to in the formula (all of which should
be well-determined beforehand). 3 Next we translate this idea into an exact deﬁ-
nition. For simplicity of presentation, we assume in our deﬁnition the “platonic”
cumulative universe V of ZF.
Notation. We denote by Fv(exp) the set of free variables of exp, and by
ϕ{t1/x1, . . . , tn} the result of simultaneously substituting the term ti for the free
occurrences of xi in ϕ (i = 1, . . . , n).
Deﬁnition 2.1. Let T be a set theory, and let Fv(ϕ) = {y1, . . . , yn, x1, . . . , xk}.
We say that ϕ is predicative in T for {x1, . . . , xk} if {⟨x1, . . . , xk⟩| ϕ} is a set for
all values of the parameters y1, . . . , yn, and the following is true (in V ) for every
transitive model M of T:
∀y1 . . . ∀yn.y1 ∈M ∧. . . ∧yn ∈M →[ϕ ↔(x1 ∈M ∧. . . ∧xk ∈M ∧ϕM)]
3Our notion of predicativity of formulas seems to be less restrictive than that used by Weyl and Fefer-
man, since it makes the l.u.b. principle valid for predicatively acceptable sets of reals.

34
Arnon Avron
Thus a formula ϕ(x) is predicative (in T) for x if it has the same extensions in
all transitive models of T which contains the values of its other parameters. Note
on the other hand that ϕ is predicative for ∅iff it is absolute in the usual sense of
set theory. (see e.g. [33]).
The main problem in formulating a predicative, type-free, set theory is how to
syntactically impose this predicativity property on formulas without introducing
syntactic types or levels. The solution suggested here to this problem comes from
the observation that this is an instance of a more general task, not peculiar only to
set Theory. In fact, in [3] and [6] an appropriate purely logical framework that can
be used for this task has been introduced. This framework uniﬁes different notions
of “safety” of formulas, coming from different areas of mathematics and computer
science, like: domain independence in database theory ( [1, 48]), decidability of
arithmetical formulas in computability theory and metamathematics, and absolute-
ness in set theory. In the next deﬁnition we review (an improved version of) this
framework.
Deﬁnition 2.2.
1. Let Fv(ϕ) = {x1, . . . ,xn, y1, . . . ,ym}, and let S1 and S2 be two structures.
ϕ is d.i. (domain-independent) for S1 and S2 with respect to {x1, . . . ,xn}
(notation: ϕ ≻S1;S2 {x1, . . . ,xn}), if for all b1 . . . , bm ∈S1 ∩S2: 4
{−→x ∈Sn
2 | S2 ⊨ϕ(−→x , −→b )} = {−→x ∈Sn
1 | S1 ⊨ϕ(−→x , −→b )}
2. A safety-signature is a pair (σ, F), where σ is an ordinary ﬁrst-order signa-
ture with equality and no function symbols, and F is a function which as-
signs to every n-ary predicate symbol from σ (other than equality) a subset of
P({1, . . . , n}).
3. Let (σ, F) be a safety-signature, and let S1 and S2 be structures for σ. S1 and
S2 are (σ, F)−compatible if:
a) Constants are interpreted identically in S1 and S2.
b) p(x1, . . . ,xn) ≻S1;S2 {xi1, . . . , xik} in case p is n-ary, x1, . . . ,xn are
distinct, and {i1, . . . , ik} ∈F(p).
4Below we use the informal notation S ⊨ϕ(a1, . . . , an) (or even just ϕ(a1, . . . , an), in case S is
the “universe of sets”) instead of the more precise, but cumbersome, “S, V ⊨ϕ, where Fv(ϕ) =
{x1, . . . ,xn}, and V is an assignment in S such that V (xi) = ai (i = 1, . . . , n)”. This notation
should not be confused with the notation ϕ{t1/x1, . . . , tn/xn} for substituting terms of a language
for variables. The informal notation {−
→
x ∈Sn | S ⊨ϕ(−
→
x , −
→b )} has a similar obvious meaning.
Note also that for convenience we use the same name (e.g. S) for a structure and for its domain.

A New Approach to Predicative Set Theory
35
4. S2 is a (σ, F)−extension of S1 if S1 and S2 are (σ, F)−compatible, and
S1 ⊆S2.
5. Let (σ, F) be a safety signature.
• A formula ϕ is called (σ, F)−safe w.r.t. X (ϕ ≻(σ,F ) X) if ϕ ≻S1;S2 X
whenever S1 and S2 are (σ, F)−compatible.
• ϕ is (σ, F)−d.i. if ϕ ≻(σ,F ) Fv(ϕ).
• ϕ is (σ, F)−absolute if ϕ ≻(σ,F ) ∅.
Examples.
• Let σ−
→
P
= {P1, . . . , Pk}.
Assume that the arity of Pi is ni, and deﬁne
F−
→
P (Pi) = {{1, . . . , ni}}.
Then ϕ is (σ−
→
P , F−
→
P )−d.i.
iff it is domain-
independent in the sense of database theory (see [1,48]).
• Let σN = {0, <, P+, P×}, where 0 is a constant, < is binary, and P+, P× are
ternary. Deﬁne FN (<) = {{1}}, FN (P+) = FN (P×) = {∅}. Then the
standard structure N for σN (with the usual interpretations of 0 and <, and the
(graphs of the) operations + and × on N as the interpretations of P+ and P×,
respectively) is a (σN , FN )-extension of a structure S for σN iff the domain of
S is an initial segment of N (where the interpretations of the relation symbols
are the corresponding reductions of the interpretations of those symbols in
N). It was shown in [6] that every Δ0-formula of σN is (σN, FN)-absolute,
that every (σN, FN)-absolute formula deﬁnes a decidable relation on the set
of natural numbers, and that a relation on the natural numbers is r.e. iff it
is deﬁnable by a formula of the form ∃y1, . . . , ynψ, where the formula ψ is
(σN , FN )-absolute.
• Let σZF
=
{∈} and let FZF (∈)
=
{{1}}.
Then S2
is a
(σZF , FZF )−extension of S1 iff S1 ⊆S2, and x1 ∈x2 ≻S1;S2 {x1}. The
latter condition means that S1 is a transitive substructure of S2 (In particular,
the universe V is a (σZF , FZF )−extension of the transitive sets and classes).
Accordingly, ϕ(x1, . . . , xn, y1, . . . , yk) ≻(σZF ,FZF ) {x1, . . . , xn} iff the fol-
lowing holds whenever S1∩S2 is transitive, and y1, . . . , yk are assigned values
from S1 ∩S2:
{⟨x1, . . . , xn⟩| S1 ⊨ϕ} = {⟨x1, . . . , xn⟩| S2 ⊨ϕ}
In particular, a formula is (σZF , FZF )-absolute iff it is absolute in the usual
sense this notion is used in set theory.

36
Arnon Avron
Obviously, “domain independence” and “predicativity” in the sense of “universe
independence” are very close relatives. Accordingly, a plausible interpretation of
principle (PRE) is that ϕ is predicative with respect to x iff ϕ ≻(σZF ,FZF ) {x}.
However, it follows from results in [6] that the relation ≻(σZF ,FZF ) is undecid-
able. Therefore in order to base predicative formal systems on this interpretation
of principle (PRE) we should replace the semantic relation of (σ, F)-safety by a
useful syntactic approximation. Now the most natural way to deﬁne a syntactic
approximation of a semantic logical relation concerning formulas is by a structural
induction. Such an inductive deﬁnition should be based on the behavior with re-
spect to the original semantic relation of the atomic formulas and of the logical
connectives and quantiﬁers. The next theorem from [6] lists the most obvious and
useful relevant properties that every relation ≻(σ,F ) has in the ﬁrst-order frame-
work:
Theorem 2.3. ≻(σ,F ) has the following properties:
1. p(t1, . . . , tn) ≻(σ,F ) X in case p is an n-ary predicate symbol of σ, and there
is I ∈F(p) such that:
a) For every x ∈X there is i ∈I such that x = ti.
b) X ∩Fv(tj) = ∅for every j ∈{1, . . . , n} −I.
2.
a) ϕ ≻(σ,F ) {x} if ϕ ∈{x ̸= x, x = t, t = x}, and x ̸∈Fv(t).
b) t = s ≻(σ,F ) ∅.
3. ¬ϕ ≻(σ,F ) ∅if ϕ ≻(σ,F ) ∅.
4. ϕ ∨ψ ≻(σ,F ) X if ϕ ≻(σ,F ) X and ψ ≻(σ,F ) X.
5. ϕ ∧ψ ≻(σ,F ) X ∪Y if ϕ ≻(σ,F ) X, ψ ≻(σ,F ) Y , and Y ∩Fv(ϕ) = ∅.
6. ∃yϕ ≻(σ,F ) X −{y} if y ∈X and ϕ ≻(σ,F ) X.
7. If ϕ ≻(σ,F ) {x1, . . . , xn}, and ψ≻(σ,F ) ∅, then ∀x1 . . . xn(ϕ →ψ)≻(σ,F ) ∅.
By a “safety relation” we shall henceforth mean a relation ≻between formulas
of σZF and ﬁnite sets of variables which satisﬁes the clauses in Theorem 2.3 with
respect to FZF 5. The least safety relation is a plausible syntactic approximation of
predicativity. However, a better approximation is obtained if greater power is given
to the ﬁrst two clauses by providing a much more extensive set of terms than that
5Property 7 is easily derivable from the others. Hence if ∀and →are taken as deﬁned in terms of
the other logical constants, then the same relation is obtained if we omit property 7 from the list in
Theorem 2.3.

A New Approach to Predicative Set Theory
37
provided by σZF (the only terms of which are its variables). This is achieved by
allowing {x | ψ} to be a legal term whenever ψ ≻{x}. Note that this is in full
coherence with our intended meaning of ≻. Moreover, this move is still justiﬁed
by Theorem 2.3, since its proof remains valid also for languages which include
complex terms (not just variables and constants), as long as x = t ≻(σ,F ) {x}
whenever x ̸∈Fv(t).
2.2 Interpreting and Implementing Principle (NAT)
First we note that by “acceptance of the set N of natural numbers” we understand
here also acceptance of principles and ideas implicit in the construction of N. This
includes proofs by mathematical induction, as well as the idea of iterating (an op-
eration or a relation) an arbitrary (ﬁnite) number of times. Hence ﬁnitary inductive
deﬁnitions of sets, relations, and functions are accepted. In particular, the ability
to form the transitive closure of a given relation (like forming the notion of an an-
cestor from the notion of a parent) should be taken as a major ingredient of our
logical abilities (even prior to our understanding of the natural numbers). In fact,
in [2] it was argued that this concept is the key for understanding ﬁnitary inductive
deﬁnitions and reasoning, and evidence was provided for the thesis that systems
which are based on it provide the right framework for the formalization and mech-
anization of mathematics. This suggestion will be used as our main tool for im-
plementing (NAT). Hence in addition to allowing the use of set terms we shall also
go beyond FOL (First-Order Logic) by introducing an operation TC for transitive
closure6. The corresponding language and semantics are deﬁned as follows (see,
e.g., [13,28–30,34,47]):
Deﬁnition 2.4. Let σ be a signature for a ﬁrst-order language with equality. The
language L1
T C(σ) is deﬁned like the usual ﬁrst-order language which is based on
σ, but with the addition of the following clause: If ϕ is a formula, x, y are distinct
variables, and t, s are terms, then (TCx,yϕ)(s, t) is a formula (in which all occur-
rences of x and y in ϕ are bound). The intended meaning of (TCx,yϕ)(s, t) is the
following “inﬁnite disjunction”: (where w1, w2, . . . , are all new variables):
ϕ{s/x, t/y} ∨∃w1(ϕ{s/x, w1/y}) ∧ϕ{w1/x, t/y})∨
∨∃w1∃w2(ϕ{s/x, w1/y} ∧ϕ{w1/x, w2/y} ∧ϕ{w2/x, t/y}) ∨. . .
The most important relevant facts shown in [2] concerning TC are:
6It is well known (see [47]) that the language of FOL enriched with TC is equivalent in its expressive
power to the language of weak SOL. So taking “transitive closure” as primitive is equivalent to
taking “ﬁnite set” as primitive (which is the approach of [23], though the system presented there is
essentially ﬁrst-order). We prefer the former as primitive, because it allows a very natural treatment
of induction as a logical rule, as well as a neat extension of the safety relation - see below.

38
Arnon Avron
1. If σ contains a constant 0 and a (symbol for a) pairing function, then all types of
ﬁnitary inductive deﬁnitions of relations and functions (as deﬁned by Feferman
in [21]) are available in L1
T C(σ). This result, in turn, allows for presenting a
simple version of Feferman’s framework FS0, demonstrating that TC-logics
provide an excellent framework for mechanizing formal systems.
2. Let V0 be the smallest set including 0 and closed under the operation of pairing.
Then a subset S of V0 is recursively enumerable iff there exists a formula ϕ(x)
of PTC+ such that S = {x ∈V0 | ϕ(x)}, where the language PTC+ is
deﬁned as follows:
Terms of PTC+
a) The constant 0 is a term.
b) Every (individual) variable is a term.
c) If t and s are terms then so is (t, s).
Formulas of PTC+
a) If t and s are terms then t = s is a formula.
b) If ϕ and ψ are formulas then so are ϕ ∨ψ and ϕ ∧ψ.
c) If ϕ is a formula, x, y are two different variables, and t, s are terms,
then (TCx,yϕ)(t, s) is a formula.
3. By generalizing a particular case which has been used by Gentzen in [26],
mathematical induction can be presented as a logical rule of languages with
TC. Indeed, Using a Gentzen-type format, a general form of this principle can
be formulated as follows:
Γ, ψ, ϕ ⇒Δ, ψ{y/x}
Γ, ψ{s/x}, (TCx,yϕ)(s, t) ⇒Δ, ψ{t/x}
where x and y are not free in Γ, Δ, and y is not free in ψ.
Now in order to combine the two central ideas described above, a clause con-
cerning TC should be added to the list of clauses in Theorem 2.3. Such a clause
was suggested in [2]. To understand it, let us look at the ﬁrst three disjuncts in the
inﬁnite disjunction θ which corresponds to (TCx,yϕ)(x, y):
ϕ(x, y)∨∃w1(ϕ(x, w1)∧ϕ(w1, y))∨∃w1∃w2(ϕ(x, w1)∧ϕ(w1, w2)∧ϕ(w2, y))

A New Approach to Predicative Set Theory
39
Call this ﬁnite disjunction ψ. From the clauses in Theorem 2.3 concerning ∧, ∃
and ∨it follows that if ϕ ≻(σ,F ) X and y ∈X (or x ∈X) then ψ ≻(σ,F ) X.
This remains true for every ﬁnite subdisjunction of θ. Hence every such ﬁnite
subdisjunction is safe with respect to X, and this easily implies that so is the whole
disjunction. This observation leads to the following new condition (in which the
variables x and y may be elements of X):
• (TCx,yϕ)(x, y) ≻(σ,F ) X if either ϕ ≻(σ,F ) X ∪{x} or ϕ ≻(σ,F ) X ∪{y}.
3 PZF and Its Formal Counterparts
In this section we use the ideas described in the previous section for introducing
a family of systems for predicative set theory. All these systems share the same
language and the same axioms. They differ only with respect to the strength of
their formal underlying apparatus. We shall denote by PZF the strongest (and
non-axiomatizable) system in this family.
3.1 Language
We deﬁne the terms and formula of the language LP ZF , as well as the safety rela-
tion ≻P ZF between formulas and ﬁnite sets of variables, by simultaneous recursion
as follows (where Fv(exp) denotes the set of free variables of exp):
Terms:
• Every variable is a term.
• If x is a variable, and ϕ is a formula such that ϕ ≻P ZF {x}, then {x | ϕ}
is a term (and Fv({x | ϕ}) = Fv(ϕ) −{x}).7
Formulas:
• If t and s are terms than t = s and t ∈s are atomic formulas.
• If ϕ and ψ are formulas, and x is a variable, then ¬ϕ, (ϕ ∧ψ), (ϕ ∨ψ),
and ∃xϕ are formulas (where Fv(∃xϕ) = Fv(ϕ) −{x}).
7Note that for convenience, we use in this paper the notation {x | ϕ} in the formal language LP ZF
as well as in our metalanguage. This should not cause a confusion.

40
Arnon Avron
• If ϕ is a formula, t and s are terms, and x and y are distinct variables then
(TCx,yϕ)(t, s) is a formula, and
Fv((TCx,yϕ)(t, s)) = (Fv(ϕ) −{x, y}) ∪Fv(t) ∪Fv(s)
The Safety Relation ≻P ZF :
1.
a) ϕ ≻P ZF ∅if ϕ is atomic.
b) ¬ϕ ≻P ZF ∅if ϕ ≻P ZF ∅.
2. ϕ ≻P ZF {x} if ϕ ∈{x ∈x, x = t, t = x, x ∈t}, and x ̸∈Fv(t).
3. ϕ ∨ψ ≻P ZF X if ϕ ≻P ZF X and ψ ≻P ZF X.
4. ϕ∧ψ ≻P ZF X∪Y if ϕ ≻P ZF X, ψ ≻P ZF Y and either Y ∩Fv(ϕ) = ∅
or X ∩Fv(ψ) = ∅.
5. ∃yϕ ≻P ZF X −{y} if y ∈X and ϕ ≻P ZF X.
6. (TCx,yϕ)(x, y) ≻P ZF X if ϕ ≻P ZF X ∪{x}, or ϕ ≻P ZF X ∪{y}.
Note 3.1. The intended intuitive meaning of “ϕ ≻P ZF {y1, . . . , yk}”, where
Fv(ϕ) = {x1, . . . , xn, y1, . . . , yk}, is that for every “accepted” sets a1, . . . , an,
the collection of all tuples ⟨y1, . . . , yk⟩such that ϕ(a1, . . . , an, y1, . . . , yk) is a set
which is constructed in an absolute, “universe independent” way from previously
“accepted” sets and from (elements in the transitive closure of) a1, . . . , an. Since
this is an imprecise explanation, it cannot be proved in the strict sense of the word.
However, it is not difﬁcult to convince oneself that ≻P ZF indeed has this prop-
erty. For example, assume that θ = ϕ ∧ψ, where Fv(ϕ) = {x, z}, Fv(ψ) =
{x, y, z}, ϕ ≻P ZF {x}, and ψ ≻P ZF {y}. Given some absolute set c, by induc-
tion hypothesis the collection Z(c) of all x such that ϕ(x, c) is an absolute set.
Again by induction hypothesis, for every d in this set the collection W(c, d) of all
y such that ψ(d, y, c) is an absolute set. Now the collection of all ⟨x, y⟩such that
θ(x, y, c) is the union for d ∈Z(c) of the sets {d}×W(c, d). Hence it is a set con-
taining only previously accepted, absolute collections, and its identity is obviously
absolute too. This is exactly what θ ≻P ZF {x, y} (which holds in this case by the
clause concerning conjunction in the deﬁnition of ≻P ZF ) intuitively means.
Note 3.2. Ofﬁcially, the language we use does not include the universal quantiﬁer
∀and the implication connective →. Below they are taken therefore as deﬁned (in
the usual way) in terms of the ofﬁcial connectives and ∃.
Note 3.3. It is not difﬁcult to show that ≻P ZF has the following properties:

A New Approach to Predicative Set Theory
41
• If ϕ ≻P ZF X then X ⊆Fv(ϕ).
• If ϕ ≻P ZF X and Z ⊆X, then ϕ ≻P ZF Z.
• If ϕ ≻P ZF {x1, . . . , xn}, v1, . . . vn are n distinct variables not occurring in
ϕ, and ϕ′ is obtained from ϕ by replacing all (not only the free) occurrences
of xi by vi (i = 1, . . . ,n), then ϕ′ ≻P ZF {v1, . . . , vn}.
• If x ̸∈Fv(t), and ϕ ≻P ZF ∅, then both ∀x(x ∈t →ϕ) ≻P ZF ∅, and
∃x(x ∈t ∧ϕ) ≻P ZF ∅. Hence ϕ ≻P ZF ∅for every Δ0 formula ϕ in LZF .
The following proposition can easily be proved:
Proposition 3.4. There is an algorithm which given a string of symbols E deter-
mines whether E is a term of LP ZF, a formula of LP ZF , or neither, and in case E
is a formula it returns the set of all X such that E ≻P ZF X.
3.2 Axioms
We turn to the axioms of PZF and its formal counterparts. The basic idea here
is to use a version of the “ideal calculus” ( [14]) for naive set theory, in which the
comprehension schema is applicable only to safe formulas. In addition we include
also ∈-induction, which seems to be quite natural within a predicative framework.
Here is the resulting list of axioms:
Extensionality:
• ∀z(z ∈x ↔z ∈y) →x = y
The Comprehension Schema:
8
• ∀x(x ∈{x | ϕ} ↔ϕ)
The Regularity Schema (∈-induction):
• (∀x(∀y(y ∈x →ϕ{y/x}) →ϕ)) →∀xϕ
8This name is justiﬁed here because for ϕ which is predicative with respect to x (i.e. ϕ ≻P ZF {x})
it easily entails the usual formulation: ∃Z∀x(x ∈Z ↔ϕ).

42
Arnon Avron
3.3 Logic
The logic which underlies PZF is TC-logic (transitive closure logic, also called
ancestral logic): the logic which corresponds to ordinary ﬁrst-order logic (with
equality) augmented with TC, the operator which produces the transitive closure
of a given binary relation. Now the set of valid formulas of this logic is not r.e.
(or even arithmetical). Hence no sound and complete formal system for it exists. It
follows that PZF, our version of predicative set theory, cannot be fully formalized.
The problem whether the above set of axioms is sound and complete for predica-
tive set theory should therefore be understood as being relative to this underlying
logic. This means that according to our approach, no single formal system can
capture the whole of predicative mathematics. It also follows that the problem of
producing formal systems for actually using PZF (for making formal deductions
in predicative mathematics) reduces to ﬁnding appropriate formal approximations
of this underlying logic. Hence what we introduce here together with PZF is really
a family of formal systems.
One crucial logical rule that should be available in any such approximation is the
general rule of induction formulated in subsection 2.2:
Γ, ψ, ϕ ⇒Δ, ψ{y/x}
Γ, ψ{s/x}, (TCx,yϕ)(s, t) ⇒Δ, ψ{t/x}
(where x and y are not free in Γ, Δ, and y is not free in ψ). Two other obvious rules
introduce TC on the right hand side of sequents: 9
Γ ⇒Δ, ϕ{t/x, s/y}
Γ ⇒Δ, (TCx,yϕ)(t, s)
Γ ⇒Δ, (TCx,yϕ)(r, s)
Γ ⇒Δ, (TCx,yϕ)(s, t)
Γ ⇒Δ, (TCx,yϕ)(r, t)
Henceforth we denote by PZF0 the formal approximation of PZF in which the
underlying formal logic is the extension of ﬁrst-order logic with these three rules for
TC. PZF0 sufﬁces for everything we do below, and we believe (but this remains
to be conﬁrmed) that it should in fact sufﬁce for (most of) applicable mathematics.
Now PZF0 is relatively a week system. Thus it can easily be interpreted in Kripke-
Platek set theory KP together with the inﬁnity axiom (see [7,11,31])10. However,
it should again be emphasized that PZF as a whole is open-ended, and transcends
any given formal system.
9The resulting system is equivalent to Myhill’s system for ancestral logic in [34].
10KP itself includes the Δ0-collection schema, which is not predicatively justiﬁed.

A New Approach to Predicative Set Theory
43
Note 3.5. In addition to having TC (which is the major difference between our un-
derlying logic and FOL), one should also note that the language of PZF provides
a class of terms which is much richer than those allowed in orthodox ﬁrst-order sys-
tems. In particular: a variable can be bound in it within a term. The notion of a term
being free for substitution should be generalized accordingly (also for substitutions
within terms!). As usual this amounts to avoiding the capture of free variables
within the scope of an operator which binds them. Otherwise the rules/axioms con-
cerning the quantiﬁers and terms remain unchanged (for example: ∀xϕ →ϕ{t/x}
is valid for every term t which is free for x in ϕ). We also assume α-conversion to
be a part of the logic11.
For simplicity of presentation and understanding, we again assume in the rest
of this paper the platonic cumulative universe V (although its exact extension is
irrelevant). Predicatively meaningful counterparts of our various claims can be
formulated and proved, but we leave this task to another opportunity.
The straightforward proof of the following proposition was practically given in
Note 3.1 (see [5] for a proof of a stronger claim):
Proposition 3.6. V is a model of PZF.
4 The Expressive Power of P ZF
4.1 Some Standard Notations for Sets
In LP ZF we can introduce as abbreviations most of the standard notations for sets
used in mathematics. Note that all these abbreviations can be introduced in a purely
static way: unlike in the extension by deﬁnition procedure (see [46]), no formal
proofs within the system (of corresponding justifying existence and uniqueness
propositions) are needed before introducing them.
• ∅=Df {x | x ∈x}.
• {t1, . . . , tn} =Df {x | x = t1 ∨. . . ∨x = tn} (where x is new).
• ⟨t, s⟩=Df {{t}, {t, s}}
• {x ∈t | ϕ} =Df {x | x ∈t ∧ϕ}, provided ϕ ≻P ZF ∅. (where x ̸∈Fv(t)).
• {t | x ∈s} =Df {y | ∃x.x ∈s ∧y = t} (where y is new, and x ̸∈Fv(s)).
11Other rules, like substitution of equals for equals within any context (under the usual conditions
concerning bound variables) are derivable from the usual ﬁrst-order axioms for equality by using
the axioms of PZF.

44
Arnon Avron
• s × t =Df {x | ∃a∃b.a ∈s ∧b ∈t ∧x = ⟨a, b⟩} (where x, a and b are new).
• s ∩t =Df {x | x ∈s ∧x ∈t} (where x is new).
• s ∪t =Df {x | x ∈s ∨x ∈t} (where x is new).
• S(x) =Df x ∪{x}
•  t =Df {x | ∃y.y ∈t ∧x ∈y} (where x and y are new).
•  t =Df {x | x ∈ t ∧∀y(y ∈t →x ∈y)} (where x, y are new).
• ιxϕ =Df
{x | ϕ} (provided ϕ ≻P ZF {x}).
• P1(z)
=Df
ιx.∃v∃y(v
∈
z ∧x
∈
v ∧y
∈
v ∧z
=
⟨x, y⟩)
(⊢P ZF0 P1(⟨t, s⟩) = t).
• P2(z)
=Df
ιy.∃v∃x(v
∈
z ∧x
∈
v ∧y
∈
v ∧z
=
⟨x, y⟩)
(⊢P ZF0 P2(⟨t, s⟩) = s).
• ω =Df {x | x = ∅∨∃y.y = ∅∧(TCx,y(x = S(y)))(x, y)}
• TH(x) =Df x ∪{y | (TCx,yy ∈x)(x, y)} (the transitive hull of x).
Our term above for  t is valid (and so denotes a set) whenever t is valid. It
is easy to see that if t denotes a non-empty set A, then  t indeed denotes the
intersection of all the elements of A. On the other hand, if the set denoted by t is
empty, then the set denoted by the term  t is empty as well. With the help of the
extensionality axiom this in turn implies that our term above for ιxϕ is meaningful
for every ϕ such that ϕ ≻P ZF {x}. This term denotes ∅if there is no set which
satisﬁes ϕ, and it denotes the intersection of all the sets which satisfy ϕ otherwise.
In particular: if there is exactly one set which satisﬁes ϕ then ιxϕ denotes this
unique set. All these facts are theorems of PZF0. In particular we have:
Proposition 4.1. If ϕ ≻P ZF {x} then ⊢P ZF0 ∃!xϕ →∀x(ϕ ↔x = ιxϕ).
From Proposition 4.1 it follows that if a formula ϕ(y1, . . . ,yn, x) implicitly de-
ﬁnes in PZF a function fϕ such that for all y1, . . . ,yn, fϕ(y1, . . . ,yn) is the unique
x such that ϕ(y1, . . . ,yn, x), and if ϕ ≻P ZF {x}, then there is a term in PZF
which explicitly denotes fϕ, and no extension by deﬁnitions of the language is
needed for introducing it. Moreover: in PZF we can introduce as abbreviations
the terms used in the λ-calculus for handling explicitly deﬁned functions (except
that our terms for functions should specify the domains of these functions, which
should be explicitly deﬁnable sets):

A New Approach to Predicative Set Theory
45
• λx ∈s.t =Df {⟨x, t⟩| x ∈s}
(where x ̸∈Fv(s))
• f(x) =Df ιy.∃z∃v(z ∈f ∧v ∈z ∧y ∈v ∧z = ⟨x, y⟩)
• Dom(f) =Df {x | ∃z∃v∃y(z ∈f ∧v ∈z ∧y ∈v ∧x ∈v ∧z = ⟨x, y⟩}
• Rng(f) =Df {y | ∃z∃v∃x(z ∈f ∧v ∈z ∧y ∈v ∧x ∈v ∧z = ⟨x, y⟩}
• f ↾s =Df {⟨x, f(x)⟩| x ∈s}
(where x is new).
Identifying ⊥from domain theory with ∅, we can easily check now that rules β
and η obtain in PZF:
• ⊢P ZF0 u ∈s →(λx ∈s.t)u = t{u/x}
(if u is free for x in t).
• ⊢P ZF0 u ̸∈s →(λx ∈s.t)u = ⊥
(if u is free for x in t).
• ⊢P ZF0 λx ∈s.tx = t ↾s
(in case x ̸∈Fv(t)).
4.2 RST and Rudimentary Functions
Let LRST and ≻RST be deﬁned like LP ZF and ≻P ZF (respectively), but without
using the TC operator. Let RST be the ﬁrst-order system in LRST which is based
on the three axioms of PZF (and with a suitable version of ordinary ﬁrst-order
logic as the underlying logic). It should be noted that with the exception of ω and
TH(x), all the constructions above have actually been done in the framework of
LRST (and can be justiﬁed in RST). Now HF, the set of hereditarily ﬁnite sets, is
a model of RST. Hence ω is not deﬁnable in LRST , and so TC is indeed necessary
for its deﬁnition. 12
Note 4.2. RST can be shown to be equivalent to Gandy’s basic set theory ( [25]),
and to the system called BST0 in [43].
The following theorem and its two corollaries determine the expressive power of
LRST , and connect it (and ≻RST ) with the class of rudimentary set functions — a
reﬁned version of G¨odel basic set functions (from [27]) which was independently
introduced by Gandy in [25] and Jensen in [32] (See also [10]).
12It is known (see e.g. [25]) that the property of being a ﬁnite ordinal is deﬁnable by a Δ0-formula
ϕ(x) , but this ϕ does not satisfy ϕ ≻P ZF {x} (it only satisﬁes ϕ ≻RST ∅, like any other
Δ0-formula). Hence {x | ϕ} is not a legal term of RST.

46
Arnon Avron
Theorem 4.3.
1. If F is an n-ary rudimentary function, then there exists a formula ϕF with the
following properties:
a) Fv(ϕF ) ⊆{y, x1, . . . ,xn}
b) ϕF ≻RST {y}
c) F(x1, . . . ,xn) = {y | ϕF }.
2. If ϕ is a formula of LRST such that:
a) Fv(ϕ) ⊆{y1, . . . ,yk, x1, . . . ,xn}
b) ϕ ≻RST {y1, . . . ,yk}
then there exists a rudimentary function Fϕ such that:
Fϕ(x1, . . . ,xn) = {⟨y1, . . . ,yk⟩| ϕ}
(= {x | ∃y1, . . . ,yk.x = ⟨y1, . . . ,yk⟩∧ϕ}).
3. If t is a term of LRST such that Fv(t) ⊆{x1, . . . ,xn}, then there exists a
rudimentary function Ft such that Ft(x1, . . . ,xn) = t for every x1, . . . ,xn.
Proof: We prove part (1) by induction, following the deﬁnition of the rudimentary
functions given in [10]:
• If F(x1, . . . ,xn) = xi then ϕF is y ∈xi. Here ϕF ≻RST {y} by clause (2)
of the deﬁnition of ≻RST .
• If F(x1, . . . ,xn) = {xi, xj} then ϕF is y = xi ∨y = xj. Here ϕF ≻RST {y}
by clauses (2) and (3) of the deﬁnition of ≻RST .
• If F(x1, . . . ,xn) = xi −xj then ϕF is y ∈xi ∧¬(y ∈xj).
Here
ϕF ≻RST {y} by clause (2), (1a), (1b), and (4) of the deﬁnition of ≻RST .
• Suppose F(x1, . . . ,xn) = H(G1(x1, . . . ,xn), . . . ,Gk(x1, . . . ,xn)), where H
and G1, . . . ,Gk are rudimentary. Let w1, . . . ,wk be new variables. Then ϕF is
∃w1 . . . wk(w1 = {y | ϕG1} ∧. . . ∧wk = {y | ϕGk} ∧ϕH(y, w1, . . . ,wk)).
Here ϕF ≻RST {y} by clauses (2), (4), and (5) of the deﬁnition of ≻RST .
• Suppose F(x1, . . . ,xn) = 
z∈x1 G(z, x2, . . . ,xn), where G is rudimentary.
Then ϕF is ∃z(z ∈x1 ∧ϕG(y, z, x2, . . . ,xn)). Here again ϕF ≻RST {y} by
clauses (2), (4), and (5) of the deﬁnition of ≻RST.

A New Approach to Predicative Set Theory
47
Next we prove parts (2) and (3) together by induction on the complexity of ϕ
and t.
• If t is xi then Ft(x1, . . . ,xn) = xi.
• If t is {y | ϕ}, where ϕ ≻RST {y}, then Ft = Fϕ.
• If ϕ is t = s and k = 0 then
Fϕ(x1, . . . ,xn) =
{∅} Ft(x1, . . . ,xn) = Fs(x1, . . . ,xn)
∅
Ft(x1, . . . ,xn) ̸= Fs(x1, . . . ,xn)
The case in which ϕ is t ∈s and k = 0 is treated similarly.
• If ϕ is ¬ψ and k = 0 then Fϕ(x1, . . . ,xn) = {∅} −Fψ(x1, . . . ,xn).
• If ϕ is y1 ̸= y1 (and k = 1), then Fϕ(x1, . . . ,xn) = ∅.
• If ϕ is y1
= t or t = y1, where y1
̸∈Fv(t) (and k
= 1), then
Fϕ(x1, . . . ,xn) = {Ft(x1, . . . ,xn)}.
• If ϕ is y1 ∈t, where y1 ̸∈Fv(t) (and k = 1), then Fϕ(x1, . . . ,xn) =
Ft(x1, . . . ,xn).
• If ϕ is ψ1 ∨ψ2 then Fϕ(x1, . . . ,xn) = Fψ1(x1, . . . ,xn) ∪Fψ2(x1, . . . ,xn).
• If ϕ is ψ ∧θ, where ψ ≻RST {y1, . . . ,yl} (l ≤k), θ ≻RST {yl+1, . . . ,yk},
and Fv(ψ) ∩{yl+1, . . . ,yk} = ∅, then
Fϕ(x1, . . . ,xn) =

⟨y1,...,yl⟩∈Fψ(x1,...,xn)

⟨yl+1,...,yk⟩∈Fθ(x1,...,xn,y1,...,yl)
{⟨y1, . . . ,yk⟩}
• Suppose ϕ = ∃zψ, where ψ ≻RST {z, y1, . . . ,yk}. Then Fϕ(x1, . . . ,xn) =

⟨z,y1,...,yk⟩∈Fψ(x1,...,xn){⟨y1, . . . ,yk⟩}.
It is not difﬁcult to see that all functions deﬁned above are indeed rudimentary.
Corollary 4.4. Every term of LRST with n free variables explicitly deﬁnes an n-
ary rudimentary function. Conversely, every rudimentary function is deﬁned by
some term of LRST .
Corollary 4.5. If Fv(ϕ) = {x1, . . . ,xn}, and ϕ ≻RST ∅, then ϕ deﬁnes a rudi-
mentary predicate P. Conversely, if P is a rudimentary predicate, then there is a
formula ϕ such that ϕ ≻RST ∅, and ϕ deﬁnes P.

48
Arnon Avron
4.3 Recursion and Inductive Deﬁnitions
The inclusion of the operation TC in LP ZF strongly extends its expressive power.
As a simple example of this power we take primitive recursion on ω:
Proposition 4.6. Assume g is a function on ω2 which is deﬁnable by a (closed) term
of LP ZF . Let f be a function on ω deﬁned by f(0) = a, f(n + 1) = g(n, f(n))
(where a is deﬁnable in LP ZF). Then f is deﬁnable (as a set of pairs) by a closed
term of LP ZF .
Proof: Assume tg is a term which deﬁnes g in LP ZF . Let ψ1(z, w) be the for-
mula (TCz,ww = ⟨S(P1(z)), tg(z)⟩)(z, w) (note that we use here the notation
for function application which was introduced in subsection 4.1). Let ψ2 be the
formula z = ⟨0, a⟩∧ψ1(z, w) ∧P1(w) = n ∧P2(w) = x, and ϕ the formula
∃z∃wψ2. Since w = ⟨S(P1(z)), tg(z)⟩≻P ZF {w}, also ψ1 ≻P ZF {w} (by the
clause concerning TC in the deﬁnition of ≻P ZF ). Hence ψ2 ≻P ZF {z, w, n, x}
(by the clauses concerning ∧and = in the deﬁnition of ≻P ZF ). It follows that
ϕ ≻P ZF {n, x}, and so ιxϕ is deﬁned. Since it is easy to prove by induction that
⊢P ZF0 ∀n ∈ω∃!xϕ, Proposition 4.1 entails that λn ∈ω.ιxϕ is a term as required.
Proposition 4.6 is only a special case of the following much more general theorem,
which implies that all types of ﬁnitary inductive deﬁnitions (as characterized in
[21]) are available in LP ZF . Its proof is similar to the proof of Theorem 15 in [2]:
Theorem 4.7. For 1 ≤j ≤p, let ϕ1(y, x1, . . . ,xn1), . . . ,ϕp(y, x1, . . . ,xnp) be
p formulas such that ϕj ≻P ZF {y}, and let k1(j), . . . , knj(j) and o(j) be (not
necessarily distinct) natural numbers between 1 and m. Assume that A1, . . . ,Am
are sets, and that B1, . . . ,Bm are the least X1, . . . ,Xm which satisfy the following
conditions (for 1 ≤i ≤m and 1 ≤j ≤p):
(1) Ai ⊆Xi
(2) If a1 ∈Xk1(j), . . . ,anj ∈Xknj (j) and ϕj(b, a1, . . . ,anj) then b ∈Xo(j)
Then B1, . . . ,Bm are deﬁnable by terms of LP ZF with parameters A1, . . . ,Am.
Example: The set HF of hereditarily ﬁnite sets is the least X such that {∅} ⊆X,
and y ∈X whenever a ∈X, b ∈X, and y = a ∪{b}. Hence HF is deﬁned by a
closed term of LP ZF.
5 The Predicativity of P ZF
The following theorem implies that PZF indeed satisﬁes condition (PRE):

A New Approach to Predicative Set Theory
49
Theorem 5.1.
1. If ϕ ≻P ZF X then ϕ is predicative (see Deﬁnition 2.1) in PZF for X.
2. If t is a valid term of PZF then t is predicative in the sense that it satisﬁes the
following condition: If Fv(t) = {y1, . . . , yn} then the following is true (in V )
for every transitive model M of PZF:
∀y1 . . . ∀yn.y1 ∈M ∧. . . ∧yn ∈M →tM = t
where tM denotes the relativization of t to M.
Proof: By a simultaneous induction on the complexity of t and ϕ.
Discussion. By Theorem 5.1, every term t of LP ZF has the same interpretation in
all transitive models of PZF which contains the values of its parameters. Thus the
identity of the set denoted by t is independent of the exact extension of the assumed
universe of sets. This already justiﬁes seeing PZF as predicative. However, we
want to argue that the predicativity of PZF intuitively goes deeper than this. The
argument will necessarily be less exact (and on a more intuitive level) than that
given by Theorem 5.1.
The problem with Theorem 5.1 is that it is a theorem of platonistic mathematics,
and so it assumes an all-encompassing collection V which includes all potential
“sets” and contains all “universes”, but is itself a universe too (meaning that classi-
cal logic holds within it). This assumption is doubtful from a predicativist point of
view13. To see how we can do without it, call two universes M1 and M2 strongly
compatible if the following conditions are satisﬁed:
1. Suppose a is an object in both M1 and M2. then
{x ∈M1 | M1 ⊨x ∈a} = {x ∈M2 | M2 ⊨x ∈a}
2. Suppose a and b are objects in M1 and M2 (respectively), and that the collec-
tions {x ∈M1 | M1 ⊨x ∈a} and {x ∈M2 | M2 ⊨x ∈b} are identical.
Then a and b are identical. (Note that here we again use the notation {x | A}
in the metalanguage to denote classes of objects.)
It is now not difﬁcult to check that if t is a term of LP ZF then the value of t for
the assignment x1 := a1, . . . ,xn := an (where Fv(t) = {x1, . . . ,xn}) is the same
in any two strongly compatible universes which include {a1, . . . ,an}. This is what
we really had in mind when we talked above about “universe independence” (note
13Thus both Sanchis in [42] and Weaver in [49] argue that classical logic is unsuitable for dealing with
the whole of V , and intuitionistic logic should be used for it instead.

50
Arnon Avron
that if the platonic universe V exists, then every two transitive subcollections of V
are compatible according to the deﬁnition above).
Turning next to Principle (NAT), we ﬁrst of all note again that the set of all natu-
ral numbers is available in PZF in the form of ω. This easily implies that PA, the
ﬁrst-order Peano’s Arithmetics, has a natural interpretation in PZF0 (see Proposi-
tion 4.6 for a partial proof). However, the availability of ω alone is not sufﬁcient for
getting the full power of mathematical induction, since the full separation schema
is not available in PZF. Nevertheless, the fact that the underlying logic is the TC-
logic implies that the following induction schema is available (alternatively, this
schema can be derived from the availability of ω with the help of ∈-induction):
⊢P ZF0 ϕ{∅/x} ∧∀x(ϕ →ϕ{S(x)/x}) →∀x.x ∈ω →ϕ
No less crucial than the ability to use induction is the ability to use inductive deﬁni-
tions. Theorem 4.7 (see also Proposition 4.6) entails that the most important form
of using such deﬁnitions is available in LP ZF .
Note 5.2. Unlike in the case of proofs by induction (where ∈-induction would do),
the TC-machinery is essential for the ability to use in PZF inductive deﬁnitions.
Now in previous systems for predicative mathematics, recursion in ω was obtained
using Δ-comprehension (or Δ-collection). The explanation was that a Δ-formula
ϕ is both upward absolute and downward absolute, and so it is absolute. This
argument implicitly assumes the platonic universe V , and so it is doubtful in view
of the discussion of (PRE) in this section (without V as a maximal universe, or some
other doubtful assumptions concerning universes, I do not see why the combination
of upward absoluteness and of downward absoluteness entails absoluteness).
6 Relations with the Axioms of ZF
The deﬁnability of {t, s},  t, and ω means that the axioms of pairing, union, and
inﬁnity are provable in PZF. On the other hand {x ∈t | ϕ} is a valid term
only if ϕ ≻P ZF ∅. Hence we do not have in PZF the full power of the other
comprehension axioms of ZF. Instead we have the following counterparts:
The predicative separation schema: If ϕ ≻P ZF ∅; ψ is equivalent in PZF0 to
ϕ; x, w, Z are distinct variables and Z ̸∈Fv(ψ), then:
⊢P ZF0 ∀w∃Z∀x(x ∈Z ↔x ∈w ∧ψ)
The predicative replacement schema: If x, y, w, Z are distinct variables, and
Z, x ̸∈Fv(t) then
⊢P ZF0 ∀w∃Z∀x(x ∈Z ↔∃y.y ∈w ∧x = t)

A New Approach to Predicative Set Theory
51
The predicative collection schema: If ϕ ≻P ZF {x}; ψ is equivalent in PZF0 to
ϕ; x, y, w, Z are distinct variables, and Z ̸∈Fv(ψ), then:
⊢P ZF0 ∀w∃Z∀x(x ∈Z ↔∃y.y ∈w ∧ψ)
The predicative powerset schema: If ϕ ≻P ZF {x}; ψ is equivalent in PZF0 to
ϕ; x, w, Z are distinct variables, and Z ̸∈Fv(ψ), then:
⊢P ZF0 ∀w∃Z∀x(x ∈Z ↔x ⊆w ∧ψ)
Thus although P(ω), the powerset of ω, is not available in PZF (This easily fol-
lows from Theorem 5.1, and the fact that P(ω) is not absolute), every set of the
form {x ∈P(ω) | ϕ} where ϕ ≻P ZF {x} is available nevertheless.
At this point it is interesting to note that TZF, a system similar to PZF0 which is
intuitively sound (from a platonistic point of view), and does have the full power of
ZF (though not ZFC), can be deﬁned in a way similar to PZF0, but using another
relation ≻T ZF , instead of ≻P ZF . ≻T ZF is the relation obtained by adding to the
deﬁnition of LP ZF the following three conditions:
1. ϕ ≻T ZF ∅for every formula ϕ.
2. x ⊆t ≻T ZF {x} if x ̸∈Fv(t).
3. ∃yϕ ∧∀y(ϕ →ψ) ≻T ZF X if ψ ≻T ZF X, and X ∩Fv(ϕ) = ∅.
In [4,5] it was shown that a ﬁrst-order system which is equivalent to ZF (but more
natural and easier to mechanize than the usual presentation of ZF) is obtained from
TZF if the underlying logic is changed to classical ﬁrst-order logic (in a ﬁrst-order
language enriched with abstract terms), and instead of using TC, a special constant
for ω is added to the language, together with Peano’s axioms for it. This shows that
ZF and PZF are indeed close in spirit.
7 The Minimal Model of P ZF
7.1 The Basic Universe
Next we show that in the spirit of (PRE), we may take our universe to be the col-
lection of predicatively deﬁnable sets.
Deﬁnition 7.1. PD0 (for “predicatively Deﬁnable”) is the set (in V ) of all sets (in
V ) which are deﬁned by closed terms of LP ZF .

52
Arnon Avron
Lemma 7.2. Let s be a term of LP ZF .
1. If s is free for y in the term t of LP ZF , then t{s/y} is a term of LP ZF.
2. If s is free for y in the formula ϕ of LP ZF , ϕ ≻P ZF X, y ̸∈X, and
Fv(s) ∩X = ∅, then ϕ{s/y} ≻P ZF X.
The proof is by a simultaneous induction on the complexity of t and ϕ.
Notation.
1. If t is a term of LP ZF , and v is an assignment in V , we denote by
∥t∥v the value (in V ) that t gets under v. In case t is closed we denote by ∥t∥
the value of t in V .
2. Let ϕ be a formula of LP ZF , and let v be an assignment in V . v ⊨ϕ denotes
that v satisﬁes ϕ in V .
3. If ϕ is a formula of LP ZF , X ⊆Fv(ϕ), and v is an assignment in V , we
denote by ∥ϕ∥X
v the class of all a ∈V for which there exists an assignment v′
such that a = v′(x) for some x ∈X, v′(y) = v(y) for y ̸∈X, and v′ ⊨ϕ.
Lemma 7.3. Let Fv(t) = {x1, . . . ,xn}, and let s1, . . . ,sn be closed terms of
LP ZF . Suppose v is an assignment such that v(xi) = ∥si∥for i = 1, . . . ,n. Then
∥t∥v = ∥t{s1/x1, . . . ,sn/xn}∥.
Theorem 7.4. PD0 is transitive (in other words: all elements of a predicatively
deﬁnable set are themselves predicatively deﬁnable).
Proof: Denote by HPD0 (for “Hereditarily Predicatively Deﬁnable”) the set of
all sets a ∈V such that TC({a}) ⊆PD0. Obviously, HPD0 is a transitive
subset of PD0. Hence it sufﬁces to show that PD0 ⊆HPD0 (implying that
PD0 = HPD0). For this we prove the following by a simultaneous induction on
the complexity of t and ϕ:
1. ∥t∥v ∈HPD0 if t is a term of LP ZF , and v is an assignment in HPD0.
2. ∥ϕ∥X
v
⊆HPD0 in case ϕ ≻P ZF X, and v is an assignment in HPD0
(Equivalently: if ϕ ≻P ZF X, v ⊨ϕ, and v(x) ∈HPD0 for x ̸∈X, then
v(x) ∈HPD0 also for x ∈X).
• The case where t is a variable is trivial.
• Suppose t is {x | ϕ}. Then ∥t∥v ∈PD0 by Lemma 7.3. Obviously a ∈∥t∥v
iff a ∈∥ϕ∥{x}
v
. Hence ∥t∥v ⊆HPD0 by the I.H. for ϕ. It follows that
∥t∥v ∈HPD0.

A New Approach to Predicative Set Theory
53
• The cases where ϕ ≻P ZF ∅and X = ∅, or ϕ is x ∈x and X = {x} are
trivial.
• Suppose ϕ is x ∈t where x ̸∈Fv(t), and X = {x}. Then ∥ϕ∥X
v = ∥t∥v.
Hence ∥ϕ∥X
v ⊆HPD0 by the I.H. concerning t and the transitivity of HPD0.
• Suppose ϕ is x = t (or t = x) where x ̸∈Fv(t), and X = {x}. Then
∥ϕ∥X
v = {∥t∥v}. Hence ∥ϕ∥X
v ⊆HPD0 by the I.H. concerning t.
• Suppose ϕ is ϕ1 ∨ϕ2, where ϕ1 ≻P ZF X and ϕ2 ≻P ZF X. Then ∥ϕ∥X
v =
∥ϕ1∥X
v ∪∥ϕ2∥X
v . Hence ∥ϕ∥X
v ⊆HPD0 by the I.H. concerning ϕ1 and ϕ2.
• Suppose ϕ is ϕ1 ∧ϕ2, where ϕ1 ≻P ZF Y , ϕ2 ≻P ZF Z, X = Y ∪Z, and
Z ∩Fv(ϕ1) = ∅. To prove the claim for ϕ and X, it sufﬁces to show that
if v′ ⊨ϕ, and v′(w) ∈HPD0 in case w ̸∈X, then v′(x) ∈HPD0 also
for x ∈X. So let v′ be such an assignment. Then v′ ⊨ϕ1 and v′ ⊨ϕ2.
Let v1 be any assignment such that v1(x) = v′(x) for x ̸∈Z, and v1(x) ∈
HPD0 if x ∈Z. Since Z ∩Fv(ϕ1) = ∅, also v1 ⊨ϕ1. By the induction
hypothesis concerning ϕ1 and Y , this and the fact that v1(x) ∈HPD0 in case
x ̸∈Y together imply that v1(x) ∈HPD0 also in case x ∈Y . It follows that
v′(x) ∈HPD0 in case x ∈Y , and that v1 is an assignment in HPD0. Now
v′ differs from v1 only for variables in Z. This and the facts that v′ ⊨ϕ2 and
ϕ2 ≻P ZF Z, together entail that v′(z) ∈∥ϕ2∥Z
v1 for every z ∈Z. Hence the
I.H. for ϕ2 implies that v′(z) ∈HPD0 in case z ∈Z. Since we have already
shown that v′(y) ∈HPD0 in case y ∈Y , it follows that v′(x) ∈HPD0 for
every x ∈X.
• Suppose ϕ is ∃zψ, where ψ ≻P ZF X∪{z}. Then ∥ϕ∥X
v ⊆∥ψ∥X∪{z}
v
. Hence
∥ϕ∥X
v ⊆HPD0 by the I.H. concerning ψ.
• Suppose ϕ is (TCx,yψ)(x, y), where ψ ≻P ZF X ∪{y} (say). For n ≥0, let
ϕn be ∃w1 . . . ∃wn.ψ(x, w1) ∧ψ(w1, w2) ∧. . . ∧ψ(wn−1, wn) ∧ψ(wn, y)
(where w1, . . . ,wn are distinct variables not occurring in ϕ). Then ∥ϕ∥X
v =

n≥0 ∥ϕn∥X
v . Now it is easy to show by induction on n (using the I.H. for
ψ and the cases concerning ∧and ∃already dealt with above) that∥ϕn∥X
v is a
subset of HPD0 for every n ≥0. Hence ∥ϕ∥X
v ⊆HPD0.
Let now a ∈PD0. Then there is a closed term t of LP ZF such that a = ∥t∥.
Hence a ∈HPD0 as a special case of (1), and so a ⊆PD0.
Deﬁnition 7.5. Let the language LM
P ZF be deﬁned like LP ZF , but with the addi-
tional constant M. For every term t and formula ϕ of LP ZF we deﬁne in LM
P ZF
the corresponding relativization tM and ϕM (respectively):

54
Arnon Avron
• xM = {y ∈M | y ∈x}.
• {x | ϕ}M = {x | x ∈M ∧ϕM}
• (sRt)M = sMRtM for R in {∈, =}.
• (¬ϕ)M = ¬ϕM
• (ϕ ∗ψ)M = ϕM ∗ψM for ∗in {∨, ∧}.
• (∃xϕ)M = ∃x.x ∈M ∧ϕM.
• ((TCx,yϕ)(s, t))M = (TCx,yx ∈M ∧y ∈M ∧ϕM)(sM, tM).
Theorem 7.6. Suppose the constant M is interpreted in V as PD0.
1. If t is term of LP ZF and v is an assignment in PD0 then ∥tM∥v = ∥t∥v.
2. Suppose that ϕ is a formula of LP ZF s. t. Fv(ϕ) = {y1, . . . , yn, x1, . . . , xk},
and ϕ ≻P ZF {x1, . . . , xk}. Then the following is true in V :
∀y1 . . . ∀yn.y1 ∈M∧. . .∧yn ∈M →[ϕ ↔(x1 ∈M∧. . .∧xk ∈M∧ϕM)]
Proof: As usual, the proof is by a simultaneous induction on the complexity of t
and ϕ.
• If t is a variable x then ∥t∥v = ∥tM∥v follows from Theorem 7.4, because in
this case ∥xM∥v = ∥x∥v ∩PD0, and ∥x∥v ∈PD0.
• If t is {x | ϕ} then the claim for t follows from the I.H. concerning ϕ.
• If ϕ is s ∈t or s = t then the claim for ϕ immediately follows from the I.H.
concerning t and s.
• If ϕ is x ∈t, where x ̸∈Fv(t), then the claim for ϕ follows from Lemma 7.3,
Theorem 7.4, and the I.H. concerning t.
• If ϕ is x = t or t = x, where x ̸∈Fv(t), then the claim for ϕ follows from
Lemma 7.3, and the I.H. concerning t.
The proofs of the other cases are similar to those given in the proof of the predica-
tivity of LP ZF, and are left for the reader.
Theorem 7.7. PD0 is a minimal model of PZF.
Proof: That PD0 is a model of PZF easily follows from Theorem 7.4 and Theo-
rem 7.6. Minimality is obvious from the fact that every element in PD0 is denoted
by some closed term of LP ZF (and the absoluteness of the interpretations of these
closed terms).

A New Approach to Predicative Set Theory
55
7.2 Ordinals in P D0
Theorem 7.8. If α is an ordinal and α < ωω then α ∈PD0.
Proof: We prove that for every n ∈N there exists a term tn of PZF such that
Fv(tn) = {a}, and for every assignment v in V , if v(a) is an ordinal, then ∥tn∥v =
v(a) + ωn. Obviously, t0 is S(a) (see subsection 4.1). Assume that tn has been
constructed, and let tn+1 be {y | (TCa,yy = tn)(a, y)}. Given v, from the
induction hypothesis concerning tn it follows that ∥tn+1∥v is 
k∈N v(a) + ωnk.
Hence ∥tn+1∥v = v(a) + ωn+1.
Now let sn be the closed term obtained from tn by substituting 0 (i.e. ∅) for
a. From what we have proved it follows that ∥sn∥= ωn. Hence ωn ∈PD0 for
every n ∈N. Since for every α < ωω there exists n ∈N such that α ∈ωn, the
transitivity of PD0 implies that α ∈PD0 for every α < ωω.
Theorem 7.9. ρ(a) < ωω for every a ∈PD0 (where ρ(a) is the rank of a).
Proof: We ﬁrst show the following two facts:
1. For every term t of LP ZF there exists n(t) ∈N such that the following in-
equality obtains for every assignment v in V :
ρ(v(t)) < max{ρ(v(y)) | y ∈Fv(t)} + ωn(t)
2. Let ϕ be a formula of LP ZF such that Fv(ϕ) = X ⊎Y , and ϕ ≻P ZF X.
Then there exists n(ϕ) ∈N for which the following inequality obtains for
every assignment v in V such that v ⊨ϕ:
max{ρ(v(x)) | x ∈X} < max{ρ(v(y)) | y ∈Y } + ωn(ϕ)
The proof is by a simultaneous induction on the complexity of t and ϕ:
• If t is a variable we take n(t) = 0.
• Suppose t is {x | ϕ}. By the induction hypothesis concerning ϕ, we can take
n(t) = n(ϕ) + 1.
• The cases where ϕ ≻P ZF ∅and X = ∅, or ϕ is x ∈x and X = {x} are
trivial.
• If ϕ is x ∈t or x = t (and X = {x}) then we take n(ϕ) = n(t).
• Suppose ϕ is ϕ1 ∨ϕ2, where ϕ1 ≻P ZF X and ϕ2 ≻P ZF X. Take n(ϕ) =
max{n(ϕ1), n(ϕ2)}.

56
Arnon Avron
• Suppose ϕ is ϕ1 ∧ϕ2, where ϕ1 ≻P ZF X1, ϕ2 ≻P ZF X2, X = X1 ∪X2,
and X2 ∩Fv(ϕ1) = ∅. By induction hypothesis for ϕ1:
max{ρ(v(x)) | x ∈X1} < max{ρ(v(y)) | y ∈Y } + ωn(ϕ1)
While by induction hypothesis for ϕ2:
max{ρ(v(x)) | x ∈X2} < max{ρ(v(y)) | y ∈Y ∪X1} + ωn(ϕ2)
Together these two inequalities imply:
max{ρ(v(x)) | x ∈X} < max{ρ(v(y)) | y ∈Y } + ωn(ϕ1) + ωn(ϕ2)
It follows that we can take n(ϕ) = max{n(ϕ1), n(ϕ2)} + 1.
• Suppose ϕ is ∃zψ, where ψ ≻P ZF X ∪{z}. Then obviously we can take
n(ϕ) = n(ψ).
• Suppose ϕ is (TCz,yψ)(z, y), where ψ ≻P ZF X ∪{z} (say, where possibly
z ∈X), and suppose v ⊨ϕ. Then for some k ∈N:
v ⊨∃w1 . . . ∃wn.ψ(z, w1) ∧ϕ(w1, w2) ∧. . . ∧ϕ(wn−1, wn) ∧ϕ(wn, y)
(where w1, . . . ,wn are distinct variables not occurring in ϕ). By induction
hypothesis for ψ applied k times, this entails:
max{ρ(v(x)) | x ∈X} < max{ρ(v(y)) | y ∈Y } + ωn(ψ) · k
It follows that we can take n(ϕ) = n(ψ) + 1.
This ends the proof of the two facts. Now in case t is a closed term of LP ZF fact
(1) implies that ρ(∥t∥) < ωω. From this the theorem is immediate.
Corollary 7.10. ωω ̸∈PD0.
Corollary 7.11. ωω is the set of ordinals in PD0.
Corollary 7.12. Ordinal addition (+) is not deﬁnable by a term of LP ZF
Proof: Had + been deﬁnable, so would have been (using TC) multiplication by ω
(since such a multiplication is equivalent to a repeated addition of the same ordinal).
Again using TC, this would have made the set {ωn | n ∈N} deﬁnable, and
so its union, ωω, would have been deﬁnable too, in contradiction to the previous
corollary.

A New Approach to Predicative Set Theory
57
Theorem 7.13. Suppose F is a monotonic set operation deﬁnable by some term of
LP ZF . Deﬁne a transﬁnite sequence of operations F (α) by:
• F (0)(a) = a
• F (α+1)(a) = F(F (α)(a))
• F (α)(a) = 
β<α F (β)(a) in case α is a limit ordinal.
Than for every α < ωω, F (α) is deﬁnable by some term of LP ZF .
Proof: The following two facts can easily be shown:
1. F (α+β) = F (β) ◦F (α)
2. F (α·β) = (F (α))(β)
Since every ordinal α < ωω can be obtained from 0, 1, and ω using addition and
multiplication, it follows from these two facts that it sufﬁces to prove that F (ω) is
deﬁnable whenever F is. So let t be a term of LP ZF such that Fv(t) = {a}, and t
deﬁnes F. Then the term a ∪{x | (TCa,xx = t)(a, x)} deﬁnes F (ω).
Corollary 7.14. If F is a monotonic set operation deﬁnable by some term of LP ZF ,
and a ∈PD0, then F (α)(a) ∈PD0 for every α < ωω.
Note 7.15. Theorem 7.8 is a special case of Corollary 7.14 (take F = S).
Corollary 7.16. Jα ∈PD0 for every α < ωω.
Proof: Jα+1 is obtained from Jα using a ﬁnitary inductive deﬁnition (it is the
closure of Jα under the 9 operations listed in Lemma 1.11 of Chapter VI of [10]).
Hence this monotonic operation is deﬁned by a term of LP ZF. The claim follows
therefore from Corollary 7.14.
Theorem 7.17. PD0 = Jωω
Proof: From Corollary 7.16 it follows that Jωω ⊆PD0.
For the converse, we ﬁrst prove the following two facts:
1. For any term t of LP ZF there exists a natural number n(t) and a term t∗of
LRST such that Fv(t∗) ⊆Fv(t)∪{w} (where w ̸∈Fv(t))), and the following
holds for every ordinal α and valuation v: If v(x) ∈Jα for every x ∈Fv(t),
and v(w) = Jβ where β ≥α + ωn(t), then ∥t∥v = ∥t∗∥v.

58
Arnon Avron
2. Let X = {x1, . . . ,xn}. For any formula ϕ of LP ZF such that ϕ ≻P ZF X
and w ̸∈Fv(ϕ), there exist a natural number n(ϕ) and a formula ϕ∗of LRST
such that Fv(ϕ∗) ⊆Fv(ϕ) ∪{w}, and for every ordinal α and valuation v, if
v(y) ∈Jα for every y ∈Fv(ϕ) −X, and v(w) = Jβ where β ≥α + ωn(ϕ),
then ∥{⟨x1, . . . ,xn⟩| ϕ}∥v = ∥{⟨x1, . . . ,xn⟩∈Jβ | ϕ∗}∥v.
As usual, the proof of these two facts is by induction on the structure of t and ϕ, and
is similar to the proof of Theorem 7.9. The only case which is not straightforward
is when ϕ is (TCy,xψ)(y, x), where ψ ≻P ZF {x} (for simplicity, we suppress
other variables). In this case n(ϕ) = n(ψ) + 1, and ϕ∗is:
∃f ∈w∃n ∈N.F(f) ∧Dom(f) = n + 1 ∧f(0) = y∧
f(n) = x ∧∀k < n.ψ∗(f(k), f(k + 1))
where F(f) is the Δ0 formula which says that F is a function.
Suppose now that a ∈PD0. Then a = ∥t∥for some closed term t of LP ZF .
By (1) it follows that a = ∥t∗∥v, where v is a valuation such that v(w) = Jωn(t).
Since Jωn(t) ∈Jωω, Jωω is closed under rudimentary functions, and t∗is a term
of LRST (and so deﬁnes a rudimentary function by Corollary 4.4), ∥t∗∥v ∈Jωω.
Hence a ∈Jωω. It follows that PD0 ⊆Jωω.
8 Directions for Further Research
8.1 Strengthening P ZF
PZF is a rich set theory, which is sufﬁcient for the goals described in the intro-
duction. Still, it is far from capturing the potential of predicative set theory. Thus
although ωn is deﬁnable in PZF for each n, and there is an effective procedure
to derive a deﬁnition of ωn+1 from a a deﬁnition of ωn, the set {ωn | n ∈N}
and the function λn ∈N.ωn are not deﬁnable in LP ZF , even though their iden-
tity is clearly absolute and predicatively acceptable. There are at least ﬁve possible
directions to remedy this by extending the deﬁnability power of PZF:
New Constants and Autonomous Progressions: A system RSTω where ω is de-
ﬁnable can be obtained from RST by adding to LRST a constant HF that
denotes the set of sets which are deﬁned by terms of RST, and by adding to
RST appropriate closure axioms concerning HF. 14 Similarly, it is not difﬁ-
cult to show that by adding to LP ZF a constant denoting Jωω with appropriate
14A similar analysis to that given above for PZF shows that ω · 2 is the set of ordinals which are
deﬁnable by some closed term of RSTω.

A New Approach to Predicative Set Theory
59
closure axioms, we get a system in which it is easy to construct closed terms
for λn ∈N.ωn and for ωω, and prove their main properties. Obviously this
process can be repeated using transﬁnite recursion, creating by this a transﬁ-
nite progression of languages and theories. To do so, we need ﬁrst of all to
precisely deﬁne the process of passing from a theory Tα to Tα+1, and of con-
structing Tα for limit α. Moreover, like in the systems for predicative analysis
of Feferman and Sch¨utte (see [15,44]), the progression should be autonomous,
in the sense that only ordinals justiﬁed in previous systems may be used. Now
instead of using indirect systems of (numerical) notations for ordinals, it would
be much more natural to use terms of our systems which provably denote in
them von Neumann’s ordinals. We expect that every ordinal less than Γ0, the
Feferman-Sch¨utte ordinal for predicativity ( [15, 17, 44, 45]), can be obtained
in this way.
Decoding: Although {ωn | n ∈N} and λn ∈N.ωn are not deﬁnable in PZF,
{⌜ωn⌝| n ∈N} and λn ∈N.⌜ωn⌝are deﬁnable, where ⌜ωn⌝is some natural
G¨odel code in HF for the term of LP ZF that deﬁnes ωn. Now there should
exist predicatively acceptable methods for passing from, say, {⌜ωn⌝| n ∈N}
to {ωn | n ∈N}, and the language and proof system of PZF might be
extended using these methods.
Dynamic Safety Relations: The safety relations we used in our 3 basic systems
are all static, and are prior to the proof system. More power can be gained
by allowing dynamic connections between safety and provability. Thus Δ-
comprehension is equivalent to the following dynamic condition: ∃yϕ(y) ≻∅
in case ϕ(y) ≻∅, ψ(z) ≻∅, and ⊢P ZF ∃yϕ(y) ↔∀zψ(z).
Inductive Deﬁnitions: The use of TC makes it possible to provide inductive deﬁ-
nitions of relations and functions which are sets. In certain cases it also allows
for deﬁning global relations (using formulas of the language). However, its use
is quite limited for inductively deﬁning global operations. Take e.g. the ternary
operation G(n, k, a) = a+ωn·(k+1) (where n, k ∈N). G can be inductively
deﬁned as follows: G(0, 0, a) = a ∪{a}, G(n + 1, 0, a) = 
k∈N G(n, k, a),
G(n+1, k+1, a) = G(n+1, 0, G(n+1, k, a)). Intuitively, G should therefore
be a predicatively acceptable operation. However, it is not deﬁnable in LP ZF
by a term t(n, k, a). Another possible direction for extending the power of
LP ZF is therefore to allow stronger methods of inductive deﬁnitions over the
natural numbers, as well as predicatively accepted transﬁnite recursion.
Introducing Classes Introducing global operations might be done by allowing
terms for classes (of the form [x : ϕ] where ϕ ≻P ZF ∅).

60
Arnon Avron
8.2 Other Directions
A necessary direction of research is to determine the relations of our framework and
systems with previous works concerned with predicative set theory. This includes
ﬁrst of all Feferman’s various systems for predicative mathematics, especially his
system PS1E for predicative set theory ( [16, 18]), and his system W from [20].
Also relevant are the proof-theoretic investigations of systems of Kripke-Platek
set theory by J¨ager, Pohlers, and Rathjen (a partial list), as well as the works on
constructive set theory by Aczel, Beeson, Friedman, Gambino, Rathjen, and many
others. Another work that seems closely related is Weaver’s recent work (see e.g.
[49]) on predicative mathematics.
Beyond this, a major future project should be to produce concrete formal systems
within the framework of PZF (based on valid, sufﬁciently strong formal systems
for TC-logics), to determine their proof-theoretical strength, and to actually devel-
oped large portions of classical mathematics in them.
References
[1] Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases, Addison-Wesley, 1995.
[2] Avron A., Transitive Closure and the mechanization of Mathematics, In Thirty Five
Years of Automating Mathematics (F. Kamareddine, ed.), 149-171, Kluwer Aca-
demic Publishers, 2003.
[3] Avron A., Safety Signatures for First-order Languages and Their Applications, In
First-Order Logic Revisited (Hendricks et all,, eds.), 37-58, Logos Verlag Berlin,
2004.
[4] Avron A., Formalizing Set Theory as It Is Actually Used, In Proceedings of Mathe-
matical Knowledge Management (MKM 2004) (A. Asperti, G. Banecerek, and A.
Trybulec, eds.), 32-43, LNCS 3119, Springer, 2004.
[5] Avron A., A Framework for Formalizing Set Theories Based on the Use of Static Set
Terms, In Pillars of Computer Science, (A. Avron, N. Dershowitz, and A. Rabinovich,
eds.), 87–106, LNCS 4800, Springer, 2008.
[6] Avron
A.,
Constructibility
and
Decidability
versus
Domain
Independence
and Absoluteness,
Theoretical Computer Science 394 (2008),
pp. 144–158
(http://dx.doi.org/10.1016/j.tcs.2007.12.008).
[7] Barwise J., Admissible Sets and Structures, Springer, 1975.
[8] Cantone D., Ferro A., and Omodeo E., Computable Set Theory, Clarendon Press,
Oxford, 1989.
[9] Cantone D., Omodeo E., and Policriti A., Set Theory for Computing: From Deci-
sions Procedures to Declarative Programming with Sets, Springer, 2001.

A New Approach to Predicative Set Theory
61
[10] K. J. Devlin, Constructibility, Perspectives in Mathematical Logic, Springer-Verlag,
1984.
[11] Y. L. Ershov, Deﬁnability and Computability, Siberian School of Algebra and Logic,
Consultants Bureau, New-York, 1996.
[12] Ewald W., From Kant to Hilbert, Clarendon Press, London (1996).
[13] Ebbinghaus H. D., and Flum J., Finite Model Theory (2nd ed.), Perspectives in Math-
ematical Logic, Springer, 1999.
[14] A. Fraenkel, Y. Bar-Hillel, and A. Levy, Foundations of Set Theory, North-Holland,
Amsterdam, 1973.
[15] Feferman S., Systems of Predicative Analysis I, Journal of Symbolic Logic 29 (1964),
pp. 1-30.
[16] Feferman S., Predicative Provability in Set Theory, Bulletin of the American Mathe-
matical Society 72 (1966), pp. 486-489.
[17] Feferman S., Systems of Predicative Analysis II, Journal of Symbolic Logic 29 (1968),
pp. 193-220.
[18] Feferman S., Predicatively Reducible Systems of Set Theory, in Axiomatic Set Theory
Proceedings of Symposia in Pure Mathematics, Vol. 13, Part 2, pp. 11-32, American
Mathematical Society, Providence, 1974.
[19] Feferman S., A More Perspicuous Formal System for Predicativity, In Konstruktionen
versus Positionen, beitra¨ge zur Diskussion um die Konstruktive Wissenschaftsthe-
orie (K. Lorenz, ed.), Walter de Gruyter, Berlin, 1978.
[20] Feferman S., Weyl Vindicated: Das Kontinuum seventy years later, In Remi e prospet-
tive della logica e della scienza contemporanee, vol. I. (C. Celluci and G. Sambin,
eds.), Cooperative Libraria Universitaria Editrice, Bologna (1988); Reprinted in [22].
[21] Feferman S., Finitary Inductively Presented Logics, in: Logic Colloquium 1988
(1989), Amsterdam, North-Holland, pp. 191-220. Reprinted in [24], pp. 297-328.
[22] Feferman S., In the Light of Logic, Oxford University Press, Oxford (1998).
[23] Feferman S., and Hellman G., Predicative Foundations of Arithmetics, Journal Of
Philosophical Logic 24 (1995), pp. 1-17.
[24] Gabbay D., editor, What is a Logical System? Oxford Science Publications, Claren-
don Press, Oxford, 1994.
[25] Gandy, R. O., Set-theoretic functions for elementary syntax, In Axiomatic set theory,
Part 2, AMS, Providence, Rhode Island, 103-126, 1974.
[26] Gentzen G., Neue Fassung des Widerspruchsfreiheitsbeweises f¨ur die reine Zahlen-
theorie, Forschungen zur Logik, N.S., No. 4, pp. 19-44 (English translation in: The
collected work of Gerhard Gentzen, edited by M.E. Szabo, North-Holland, Amster-
dam, (1969)).

62
Arnon Avron
[27] K. G¨odel, The Consistency of the Continuum Hypothesis, Annals of Mathematical
Studies, No. 3, Princeton University Press, Princeton, N.J., 1940.
[28] Gr¨adel E., On Transitive Closure Logic, in: Computer Science Logic (Bern 1991),
Springer LNCS 626, 1992, pp. 149-163.
[29] Gurevich Y., Logic and the Challenge of Computer Science, in: B¨orger E., ed., Trends
in Theoretical Computer Science, Computer Science Press Inc., Rockville, Mary-
land, USA (1988), pp. 1-58.
[30] Immerman, N., Languages which Capture Complexity Classes, in: 15th Symposium
on Theory of Computing, Association for Computing Machinery (1983), pp. 347-354.
[31] J¨ager G., Theories for Admissible Sets: a Unifying Approach to Proof Theory,
Bibliopolis, Naples, 1986.
[32] R. B. Jensen, The Fine Structure of the Constructible Hierarchy, Annals of Mathemat-
ical Logic 4, pp. 229-308, 1972.
[33] Kunen K., Set Theory: an Introduction to Independence Proofs, North-Holland,
Amsterdam, 1980.
[34] Myhill J., A Derivation of Number Theory from Ancestral Theory, Journal of Symbolic
Logic 17, pp. 192-297, 1952.
[35] Poincar´e H., Les Math´ematiques et la Logique, II, III, Revue de M´etaphysique et
Morale 14 (1906), pp. 17-34, 294-317; translated in [12].
[36] Poincar´e H., Derni`ere Pens´ees, Flammarion, Paris (1913); trans. by J. Bolduc as
Mathematics and Science: Last Essays, Dover Press, New-York (1963).
[37] Ramsey F., The foundations of mathematics, Proceedings of the London Mathematical
Society, 2nd series, 25(5), 1925.
[38] Richard, J., Letter `a Monnsieur le r´edacteur de la Revue g´en´eral de Sciences. Acta
Mathematica, 30, pp. 295-96. 1905
[39] Russelll B., Les Paradoxes de la logique, Revue de M´etaphisique et de Morale, 14,
(September 1906) Part of an exchange with Poincar´e. English version entitled “On
‘Insolubilia’ and their Solution by Symbolic Logic” (chapter 9 of [41]).
[40] Russelll B., Mathematical Logic as based on a theory of logical types, Am. Journal of
Mathematics 30, 1908.
[41] Russelll B. Essays in Analysis, edited by D. Lackey, Braziller New York, 1973.
[42] Sanchis L. E., Set Theory — An Operational Approach, Gordon and Breach Scien-
tiﬁc Publishers, 1996.
[43] V. Y. Sazonov, On Bounded Set Theory, Proceedings of the 10th International Congress
on Logic, Methodology and Philosophy of Sciences, Florence, August 1995, in Volume
I: Logic and Scientiﬁc Method, Kluwer Academic Publishers, 85-103, 1997.
[44] Sch¨utte K., Predicative Well-ordering, in Formal Systems and Recursive Functions
(J. Crossley and M. Dummett, eds.), North-Holland, pp. 279-302.

A New Approach to Predicative Set Theory
63
[45] Sch¨utte K., Proof Theory, Springer-Verlag, 1977.
[46] Shoenﬁeld J. R., Mathematical Logic, Addison-Wesley, 1967.
[47] Shapiro S., Foundations Without Foundationalism: A Case for Second-order
Logic, Oxford University Press, Oxford, 1991.
[48] Ullman, J.D.: Principles of database and knowledge-base systems, Computer Sci-
ence Press, 1988.
[49] Weaver N., Mathematical Conceptualism, unpublished manuscript (available from
http://www.math.wustle.edu/nweaver/concept.pdf).
[50] Weyl H., Das Kontinuum: Kritische Untersuchungen ¨uber die Grundlagen der
Analysis, Veit, Leipzig (1918).
[51] Whitehead A., and Russell B., Principia Mathematica, vols. I, II, and III, Cambridge
University Press, Cambridge (1910-13); 2nd edition, Cambridge University Press,
Cambridge (1925-27).


Characterising Deﬁnable Search Problems in
Bounded Arithmetic via Proof Notations
Arnold Beckmann∗and Samuel R. Buss†
Department of Computer Science
Swansea University
Swansea SA2 8PP, UK
a.beckmann@swansea.ac.uk
Department of Mathematics
University of California, San Diego
La Jolla, CA 92093-0112, USA
sbuss@math.ucsd.edu
Abstract The complexity class of Πp
k-Polynomial Local Search (PLS)
problems with Πp
ℓ-goals is introduced, and is used to give new characteri-
sations of deﬁnable search problems in fragments of Bounded Arithmetic.
The characterisations are established via notations for propositional proofs
obtained by translating Bounded Arithmetic proofs using the Paris-Wilkie-
translation. For ℓ≤k, the Σb
ℓ+1-deﬁnable search problems of Tk+1
2
are
exactly characterised by Πp
k-PLS problems with Πp
ℓ-goals. These Πp
k-PLS
problems can be deﬁned in a weak base theory such as S1
2, and proved to
be total in Tk+1
2
. Furthermore, the Πp
k-PLS deﬁnitions can be Skolemised
with simple polynomial time functions. The Skolemised Πp
k-PLS deﬁni-
tions give rise to a new ∀Σb
1(α) principle conjectured to separate Tk
2(α)
from Tk+1
2
(α).
1 Introduction
Bounded Arithmetic in the form introduced by the second author [Bus86] denotes
a collection of theories of arithmetic which have a strong connection to compu-
tational complexity. An important goal in Bounded Arithmetic is to give good
descriptions of the functions that are deﬁnable in a certain theory by a certain class
of formulas. For the sake of simplicity of this introduction, we will concentrate
only on the Bounded Arithmetic theories Si
2. These theories are given as ﬁrst order
∗Supported in part by EPSRC grant EP/D03809X/1.
†Supported in part by NSF grant DMS-0700533.

66
Arnold Beckmann and Samuel R. Buss
theories of arithmetic in a language which suitably extends that of Peano Arith-
metic, where induction is restricted in two ways. First, logarithmic induction is
considered which only inducts over a logarithmic part of the universe of discourse.
ϕ(0) ∧(∀x)(ϕ(x) →ϕ(x + 1)) →(∀x)ϕ(|x|) .
Here, |x| denotes the length of the binary representation of the natural number x,
which deﬁnes a kind of logarithm on natural numbers. As in these theories ex-
ponentiation will not be a total function, this is a proper restriction. Second, the
properties which can be inducted on, must be described by a suitably restricted
(“bounded”) formula. The class of formulas used here are the Σb
i -formulas which
exactly characterise Σp
i , that is, properties of the i-th level of the polynomial time
hierarchy of predicates. The main axioms of the theory Si
2 are the instances of
logarithmic induction for Σb
i formulas.
Let a (multi-)function f be called Σb
j -deﬁnable in Si
2, if its graph can be
expressed by a Σb
j -formula ϕ, such that the totality of f, which renders as
(∀x)(∃y)ϕ(x, y), is provable from the Si
2-axioms in ﬁrst-order logic. The main
results characterising deﬁnable (multi-)functions in Bounded Arithmetic are the
following.
• Buss [Bus86] characterised the Σb
i -deﬁnable functions of Si
2 as FPΣp
i−1, the
i-th level of the polynomial time hierarchy of functions.
• Kraj´ıˇcek [Kra93] characterised the Σb
i+1-deﬁnable multi-functions of Si
2 as
the class FPΣp
i [wit, O(log n)] of multi-functions which can be computed in
polynomial time using a witness oracle from Σp
i , where the number of oracle
queries is restricted to O(log n) many (n being the length of the input).
• Buss and Kraj´ıˇcek [BK94] characterised the Σb
1-deﬁnable multi-functions of
S2
2 as projections of solutions to polynomial local search problems. This result
extends to higher levels as well: the Σb
i−1-deﬁnable multi-functions of Si
2 are
exactly the projections of solutions to problems from PLSΣp
i−2, which is the
class of polynomial local search problems relativised to Σp
i−2-oracles.
• Pollett [Pol99] showed that the Σb
j+1-deﬁnable multi-functions in Si
2 for j > i
are exactly FPΣp
j [wit, O(1)].
The characterisation of the Σb
i -deﬁnable functions of Sk+1
2
for 0 < i < k turned
out to be more difﬁcult, but recently some advances have been made. Kraj´ıˇcek,
Skelley, and Thapen [KST07] characterised the Σb
1-deﬁnable functions of S3
2 in
terms of coloured PLS problems, and the Σb
1-deﬁnable functions of S4
2 in terms

Deﬁnable Search Problems in Bounded Arithmetic
67
of a kind of reﬂection principle, and also in terms of a kind of recursion called
veriﬁable recursion. Subsequently, Skelley and Thapen [ST07] characterised the
Σb
1-deﬁnable functions of Sk+1
2
, for all k ≥2, in terms of a combinatorial principle
for k-turn games. An earlier, more complex, game characterisation of the same
functions was given by Pudl´ak [Pud06] using a combinatorial analysis of Herbrand
disjunctions, which has been improved later by the same author [Pud07].
In this article we will provide characterisations for all pairs of bounded formula
class Σb
ℓ+1 and theory Sk+2
2
, for ℓ< k, in terms of generalisations of PLS problems
which we call Πb
k-PLS problems with Πb
ℓ-goals. We will deﬁne the new complexity
classes in Section 3. An instance of a Πb
k-PLS problem with Πb
ℓ-goal will consist,
on input a, of a polynomially bounded set of feasible solutions of complexity Πb
k
and a goal set of complexity Πb
ℓ, an initial value function computing a feasible
solution, a cost function computing the cost of a feasible solution, and a neighbour-
hood function computing from a given feasible solution another feasible solution
(its neighbour), such that either the computed neighbour is identical to the original
solution, or the neighbour is of lower cost — these functions have to be polynomial
time computable. The goal set has to satisfy that it consists of exactly those fea-
sible solutions for which the neighbourhood function is the identity. An important
requirement will be that these conditions are provable in a weak theory like S1
2, as
without such requirements we can easily construct for any total function f given
by (∀x)ϕ(x, f(x)) with ϕ polynomial time computable and polynomially bounded
(that is, for any (x, y) with ϕ(x, y), |y| is polynomial in |x|), a Πb
1-PLS problem
with goal ϕ — some of the requirements will then depend on the totality of the
function and can thus only be proved in a theory which already proves the totality
of the function.
The new characterisations have been obtained during a research visit of the ﬁrst
author at the second author’s institution in autumn 2007. Prior to this visit, these
new characterisations had been partially guessed based on recent results about ob-
taining the above-mentioned known characterisations of deﬁnable functions via
notations for propositional proofs and cut-reduction [AB09]. Then, during the re-
search visit, two different proofs for the new characterisations have been obtained,
one extending the idea of notations for propositional proofs, and the other based on
witnessing arguments.
Witnessing arguments form the dominant method for characterising deﬁnable
(multi-)functions in Bounded Arithmetic.
For example, the above-mentioned
known characterisation of deﬁnable (multi-)functions in Bounded Arithmetic all
have been proven by specially tailored witnessing arguments. The characterisation
based on witnessing arguments has been reported at a different place [BB08].
In this article, we present the new characterisations based on proof notations,

68
Arnold Beckmann and Samuel R. Buss
that is, via notations for propositional proofs which are obtained by translating
ﬁrst order proofs and applying cut-reduction. We will compare this approach with
the above-mentioned witnessing argument at the end of this introduction after we
have given an idea of how the new characterisations based on proof notations work.
First, we brieﬂy describe the general idea of proof notations as presented in [AB09],
which will also be one half of the idea for the new characterisations. Suppose
(∀x)(∃y)ϕ(x, y), describing the totality of some multi-function, is provable in
some Bounded Arithmetic theory. Fix a particularly nice formal proof P of this.
Given a ∈N we want to describe a procedure which ﬁnds some b such that ϕ(a, b)
is true (a is some canonical term in the language of Bounded Arithmetic with value
a.) Invert the proof P of (∀x)(∃y)ϕ(x, y) to a proof of (∃y)ϕ(x, y), where x is now
a free variable of the proof, then substitute a for all occurrences of x. This yields
a proof of (∃y)ϕ(a, y). Now we want to translate this proof to propositional logic.
The propositional translation used here is well-known in proof-theoretic investiga-
tions; the translation has been described by Tait [Tai68], and later was indepen-
dently discovered by Paris and Wilkie [PW85]. In the Bounded Arithmetic world it
is known as the Paris-Wilkie translation. As these translations in general produce
exponential size formulas and proofs, we cannot directly work with the resulting
objects, but have to use notations for them. Applying cut-reduction appropriately
to notations of propositional proofs, we obtain a proof with all cut-formulas of (at
most) the same logical complexity as ϕ. It should be noted that a notation h(a) for
this proof can be computed in time polynomial in |a| (cf. [AB09].)
The general local search problem which ﬁnds a witness for (∃y)ϕ(a, y) can now
be characterised as follows. Its instance is given by a. The set of possible solutions
are those notations of a suitable size which denote derivations of a suitable cut-
rank (cut-rank is the maximal level of cut-formulas occurring in the derivation).
Furthermore, they must satisfy that the formula which they derive is equivalent to
(∃y)ϕ(a, y) ∨ψ1 ∨· · · ∨ψl, where all ψi are of low complexity and false. An
initial solution is given by h(a). A neighbour to a solution h is a solution which
denotes an immediate subderivation of the derivation denoted by h, if this exists,
and h otherwise. The cost of a notation is the height of the proof-tree represented
by the notation. The search task is to ﬁnd a notation in the set of solutions which is a
ﬁxed point of the neighbourhood function. Obviously, a solution to the search task
must exist. In fact, any solution of minimal cost has this property. Now consider
any solution to the search problem. It must have the property that none of the
immediate subderivations is in the solution space. This can only happen if the last
inference derives (∃y)ϕ(a, y) from a true statement ϕ(a, b) for some b ∈N. Thus
b is a witness to (∃y)ϕ(a, y), and we can output b as a solution to our original
witnessing problem.
This approach works ﬁne if the difference between the complexity of induction

Deﬁnable Search Problems in Bounded Arithmetic
69
and the level of deﬁnability we are interested in is not too big. For the known char-
acterisations mentioned above, things can be arranged such that, depending on the
complexity of logarithmic induction present in the Bounded Arithmetic theory we
started with, and the level of deﬁnability, we obtain local search problems deﬁned
by functions of some level of the polynomial time hierarchy, and different bounds to
the cost function [AB09]. For example, if we start with the Σb
i -deﬁnable functions
of Si
2, we obtain a local search problem deﬁned by properties in FPΣb
i−1, where the
cost function is bounded by |a|O(1). Thus, by following the canonical path through
the search problem which starts at the initial value and iterates the neighbourhood
function until reaching a solution, we obtain a path of polynomial length, which
describes a procedure in FPΣb
i−1 to compute a witness.
For the new characterisations however, the complexity of induction is much big-
ger than the level of deﬁnability, Σb
j versus Σb
i with j >> i say. The above-
described strategy would deal with this difference by applying an appropriate num-
ber of cut-reductions (j +1−i). But if j +1−i is too big, too many cut-reductions
would have to be applied, resulting in a search space which explodes: the search
space would contain too many objects as well as objects of too big size (iterated
exponentiation in input length.) In such a situation the solution will be to apply
a maximal number of cut-reductions such that the search space does not explode,
and then change the above-described local search problem so that a feasible solu-
tion still contains a notation for derivation as above, but now the complexity of ψj
does not necessarily match that of ϕ but can be bigger. This is compensated by ac-
companying the notation with an auxiliary search problem for determining the truth
of ψj. In other words, a feasible solution in the overall search problem contains a
notation h and a position s in an auxiliary search problem for a formula ψ which
is related to h. A solution to the auxiliary search problem for ψ will determine
the truth of ψ, and allow us to choose an appropriate immediate subderivation of h
to continue the overall search problem. Overall, we end up with search problems
where the set of feasible solutions has high computational complexity (due to the
assertion that all ψj are false) but, e.g., the neighbourhood function is still of low
computational complexity (due to the use of the auxiliary search problems.) For
example, we obtain for the Σb
1-deﬁnable multi-functions of Sk+2
2
that the set of
feasible solutions has complexity Πp
k, but the neighbourhood function, cost func-
tion and initial value function are polynomial time computable — this deﬁnes an
instance of the above-mentioned Πb
k-PLS problems.
An important property of our characterisation is that the Πb
k-PLS conditions that
the functions and predicates have to satisfy, are provable in S1
2. Furthermore, these
conditions can be written in a prenex form which can be Skolemised with simple
polynomial time computable functions, such that the resulting conditions are still

70
Arnold Beckmann and Samuel R. Buss
provable in S1
2. This has several consequences: First, we obtain a much stronger
algorithmic description of the Σb
ℓ+1-deﬁnable functions, as Πb
k-PLS problems with
Πb
ℓ-goals in Skolem form, in which all conditions are given as ∀Πb
1 conditions. Sec-
ond, using the description in Skolem form we can deﬁne search principles classes
based on some generic principle (involving second order symbols representing the
functions and predicates that make up a Πb
k-PLS problem with Πb
ℓ-goal in Skolem
form) which can be seen to characterise the ∀Σb
ℓ+1-consequences of Tk+1
2
. This,
third, leads to the conjecture that the generic principle separates relativised theories,
i.e. Tk+1
2
(α) from Tk
2(α).
It is worth mentioning at this point that there are connections between the ap-
proach described here and the approach considered in [ST07]. The main similarity
is that [ST07] also makes use of a translation of Tk+1
2
proofs into exponential sized
propositional proofs of some special purpose propositional proof systems which
are described by polynomial time relations.
To come back to a comparison between the proof notation approach to the new
characterisations presented here, and the witnessing arguments given in [BB08],
the difference between them goes beyond obtaining the same results with two dif-
ferent methods. The layout of the witnessing argument is such that its inductive
formulation has to incorporate the cut-reduction part of the proof notation argu-
ment. This in particular means that the witnessing argument directly deals with
sequents of formulas as complex as induction formulas, where the notation argu-
ment directly deals with sequents of formulas of one level below that. So, on one
hand the witnessing argument is direct but more involved, whereas for the notation
argument it takes a while to set up the necessary machinery (mainly by repeating
parts of [AB09]), but after that is pretty straightforward. Both approaches have in
common that they use auxiliary search problems to determine the truth of formu-
las. The difference between the two approaches becomes even more visible when
it comes to reﬁnements of the results by Skolemising properties of the resulting
search problems. While this is a technical but straightforward task for proof no-
tations, it is more involved for the witnessing argument which needs to prove a
stronger Skolemisation result due to its inductive layout and higher formula com-
plexities.
The next section will brieﬂy introduce Bounded Arithmetic in a way suitable for
our proof-theoretic investigations. Section 3 deﬁnes the search problem classes
of Πb
k-polynomial local search, and their generalisations. Sections 4 and 5 re-
view necessary deﬁnitions and results on notations and cut-reduction in general,
and for Bounded Arithmetic in particular, from [AB09]. Section 6 then introduces
the auxiliary search problems to determine the truth of formulas. This is followed
by the section deﬁning the search problems which come from proofs in Bounded

Deﬁnable Search Problems in Bounded Arithmetic
71
Arithmetic, and stating our main result concerning the characterisation of deﬁnable
multi-functions in terms of Πb
k-PLS. The next two sections deal with a strength-
ening of our main results by showing that the conditions for Πb
k-PLS problems
extracted from Bounded Arithmetic proofs can be Skolemised with simple, poly-
nomial time computable Skolem-functions. In the ﬁnal section we will use the
Skolemised Πb
k-PLS problems to deﬁne ∀Σb
1(α)-sentences which we conjecture to
separate relativised Bounded Arithmetic theories Sk+1
2
(α) from Sk+2
2
(α).
2 Bounded Arithmetic
We introduce Bounded Arithmetic very brieﬂy, and in a slightly nonstandard way
which better suits our proof-theoretic investigations. The reader interested in the
general theory of Bounded Arithmetic is kindly referred to the literature [Bus86].
The standard model for Bounded Arithmetic is N, the set of natural numbers.
For a ∈N let |a| denote the length of the binary representation of a.
Deﬁnition 2.1 (Language of Bounded Arithmetic). We deﬁne the language LBA
of Bounded Arithmetic as in [Bus86] with a few additional symbols for polynomial
time computable functions:
LBA = {S, +, ×, | · |, #, =, ≤} ∪{ca : a∈N} ∪{2|·|, ·−, min, pair, (·)1, (·)2}
To explain the meaning of these symbols we brieﬂy indicate their interpretation
in the standard model N: = and ≤denote the binary relations “equality” and
“less than or equal”. ca for a∈N denotes a constant with standard interpretation
cN
a = a. We will often write a instead of ca, and 0 for c0. S, | · | and 2|·| are
unary function symbols whose standard interpretations are given by the successor
function, | · |N : a →|a|, and 2|·|N : a →2|a|. +, ×, ·−, min and # are bi-
nary function symbols whose standard interpretation are addition, multiplication,
·−N : a, b →max(a−b, 0), minimisation, and #N : a, b →2|a|·|b|. pair, (·)1, (·)2
deﬁne some feasible pairing function like the Cantor pairing function with corre-
sponding projections.
Atomic formulas are of the form s = t or s ≤t where s and t are terms. Literals
are expressions of the form A or ¬A where A is an atomic formula. Formulas
are built up from literals by means of ∧, ∨, (∀x), (∃x). The negation ¬C for a
formula C is deﬁned via de Morgan’s laws. Negation extends to sets of formulas
in the usual way by applying it to their members individually. A →B is an
abbreviation of ¬A ∨B.
Let FV(A) denote the free variables occurring in formula A. With Ax(t) we de-
note the result of replacing all free occurrences of the variable x in A by t. Similar
deﬁnitions are used for substitution into terms.

72
Arnold Beckmann and Samuel R. Buss
Deﬁnition 2.2 (BASIC). With a valid disjunction of literals we mean a disjunction
A of literals such that A is true in N under any assignment. Let BASIC denote a set
of valid disjunctions of literals which is sufﬁcient to deﬁne the non-logical symbols
in LBA. More precisely, we consider the set BASIC to be the natural reformulation
of the axioms BASIC from [Bus86] into a set of disjunctions of literals, extended
by suitable axioms deﬁning the new symbols. We assume that the following axioms
are included:
(pair(a, b))1 = a
(pair(a, b))2 = b
(c)1 ≤c
(c)2 ≤c
a, b ≤t →pair(a, b) ≤B(t) for some LBA-term B
min(a, b) = a ∨min(a, b) = b
min(a, b) = min(b, a)
a ≤b →min(a, b) = a
min(a, b) = a →a ≤b
a ·−a = 0
(S a) ·−(S b) = a ·−b
a ≤b →a ·−b = 0
a ·−b = 0 →a ≤b
Deﬁnition 2.3 (Bounded Quantiﬁcation). Bounded quantiﬁers are introduced in
the following way: (∀x ≤t)A denotes (∀x)Ax(min(x, t)), and (∃x ≤t)A denotes
(∃x)Ax(min(x, t)), where x may not occur in t.
Our introduction of bounded quantiﬁers is a bit nonstandard. It has the advan-
tage that already the usual cut-reduction procedure gives optimal results. The more
standard abbreviation of bounded quantiﬁcation, where e.g. (∃x ≤t)A denotes
(∃x)(x ≤t ∧A), would need a modiﬁcation of cut-reduction to produce optimal
bounds, as two logical connectives are to be removed for one bounded quanti-
ﬁer. Nevertheless, the two kind of abbreviations are equivalent over a weak base
theory like Buss’ BASIC (c.f. [Bus86]) assuming that this base theory includes
some standard axiomatisation of min using ≤like a ≤b →min(x, y) = x and
min(a, b) = min(b, a). Also, either way makes use of a nonlogical symbol (“≤”
versus “min”).
Another approach to formalise bounded quantiﬁers is followed in [Bus86], where
bounded quantiﬁers are treated as new logical symbols, not as abbreviations, and
have their own, new kind of inference rules.
Deﬁnition 2.4 (Bounded Formulas). The set Δ0 of bounded LBA-formulas is the
set of LBA-formulas consisting of literals and being closed under ∧, ∨, (∀x ≤t),
(∃x ≤t).
We now deﬁne a delineation of bounded formulas. The literature sometimes
distinguishes between “strict” or “prenex” versions versus more liberal ones. We

Deﬁnable Search Problems in Bounded Arithmetic
73
do not want to make such a distinction here to keep the focus on our proof-theoretic
investigations, and deﬁne the classes only in their restricted form.
Deﬁnition 2.5. The set sΣb
i is the smallest subset of bounded LBA-formulas that
is closed under taking subformulas and that contains all formulas of the form
(∃x1 ≤t1)(∀x2 ≤t2) · · · (Qxi ≤ti)(Qxi+1 ≤|ti+1|)A(⃗x) ,
with Q and Q being of the corresponding alternating quantiﬁer shape and A being
quantiﬁer free. A and the ti’s may involve variables not mentioned here.
Let sΠb
i be the set

¬ϕ: ϕ ∈sΣb
i

, and let sΣb
∞be 
d<∞sΣb
d.
Deﬁnition 2.6 (Rank). The rank of a formula ϕ, rk(ϕ), is deﬁned as the minimal
k such that ϕ ∈sΣb
k ∪sΠb
k, if such a k exists, and ∞otherwise.
Deﬁnition 2.7. Let Ind(A, z, t) denote the expression
Az(0) ∧(∀z ≤t)(A →Az(z + 1)) →Az(t) .
We will base our deﬁnition of Bounded Arithmetic theories on a different normal
form of induction than usually considered in the literature.
Deﬁnition 2.8. Let Ti
2 denote the theory consisting of (universal closures of) for-
mulas in BASIC and of (universal closures of) formulas of the form Ind(A, z, 2|t|)
with A ∈sΣb
i , z a variable, and t an LBA-term.
Let S1
2 denote the theory consisting (of universal closures) of formulas in BASIC
and (of universal closures) of formulas of the form Ind(A, z, |t|) with A ∈sΣb
1, z
a variable and t an LBA-term.
Our versions of Ti
2 and S1
2 are different from the standard versions as for example
deﬁned in [Bus86]. They are adapted to suit the proof-theoretic investigations we
want to pursue. Nevertheless, they are equivalent in that the sets of consequences
are the same. This follows from the fact that the restricted form of induction as
used in Deﬁnition 2.8 implies the usual form, because the following can be proven
from BASIC alone:
Ind(A(min(t, z)), z, 2|t|) →Ind(A(z), z, t) .
Deﬁnition 2.9. Let Σb
i (resp. Πb
i ) be the set of formulas ϕ such that there exist
ψ ∈sΣb
i (resp. ψ ∈sΠb
i ) with S1
2 ⊢ϕ ↔ψ.
Let Δb
1 be the set of formulas ϕ such that there exist formulas σ ∈sΣb
1 and
π ∈sΠb
1 with S1
2 ⊢(ϕ ↔σ) ∧(ϕ ↔π).

74
Arnold Beckmann and Samuel R. Buss
3 Πp
k-Polynomial Local Search
A binary relation R ⊆N × N is called polynomially bounded iff there is a polyno-
mial p such that (x, y) ∈R implies |y| ≤p(|x|). R is called total if for all x there
exists a y with (x, y) ∈R.
Deﬁnition 3.1 (Total and Deﬁnable Search Problems). Let R ⊆N×N be a polyno-
mially bounded, total relation. The (total) search problem associated with R is this:
Given input x ∈N, return a y ∈N such that (x, y) ∈R. R is called Σb
ℓ+1-deﬁnable
in Tk+1
2
if there exists a Πb
ℓ-formula ϕ(x, y) (Δb
1 if ℓ= 0) and an LBA-term t(x),
both with all free variables shown, such that (x, y) ∈R iff N ⊨ϕ(x, y), and such
that Tk+1
2
⊢(∀x)(∃y ≤t(x))ϕ(x, y).
The class PLS was deﬁned by Johnson, Papadimitriou and Yannakakis [JPY88].
In the next deﬁnition we deﬁne generalisations of PLS. The setup of (generalised)
PLS is intended to guarantee totality of the underlying search task.
Deﬁnition 3.2 (Πp
k-PLS Problems with Πp
ℓ-Goals). A Πp
k-Polynomial Local Search
(PLS) problem with Πp
ℓ-goal, for k ≥ℓ≥0, is a tuple L = (F, G, N, c, i) consist-
ing of, for a given input x, a set F(x) of feasible solutions with a polynomial bound
d, a goal set G(x), a neighbourhood function N(x, s) mapping a conﬁguration s
to another conﬁguration, a function c(x, s) computing the cost of a conﬁguration
s, and a function i(x) computing an initial feasible solution. The following proper-
ties have to be fulﬁlled: the functions N, c and i are polynomial time computable,
F ∈Πp
k and G ∈Πp
ℓ, and the following ﬁve conditions are satisﬁed:
(∀x, s)(s ∈F(x) →|s| ≤d(|x|))
(3.1)
(∀x)(i(x) ∈F(x))
(3.2)
(∀x, s)(s ∈F(x) →N(x, s) ∈F(x))
(3.3)
(∀x, s)(N(x, s) = s ∨c(x, N(x, s)) < c(x, s))
(3.4)
(∀x, s)(s ∈G(x) ↔(N(x, s) = s ∧s ∈F(x)))
(3.5)
For a given input x, the search task is to ﬁnd some s with s ∈G(x).
Usually, the polynomial bound to F, d, is thought to be understood from the
context and not explicitely mentioned. If we want to make it explicit we sometimes
write L = (d, F, G, N, c, i). We have introduced F and G as sets. When we
focus on their complexity or their deﬁnability in Bounded Arithmetic, we treat
“s ∈F(a)” etc. as relations in s, a.
Without any further requirements, Πp
k-PLS problems with Πp
ℓ-goals do not say
much about the complexity of the underlying search task. For example, let R be

Deﬁnable Search Problems in Bounded Arithmetic
75
a polynomial time computable, total relation with polynomial bound p, deﬁning
a total search problem. Then we can deﬁne a Πp
1-PLS problem with goal R as
follows: Let T(x) be 2p(|x|), and observe that p(|x|)<T(x). A feasible solution
s∈F(x) is given if s<T(x) and R(x, s), or, in case s=T(x)+s′, if |s′|≤p(|x|)
and (∀y<s′)(x, y)/∈R; the initial value is T(x); the neighbourhood function takes
an s and outputs s if s<T(x), or, in case s=T(x)+s′, produces T(x)+s′+1 if
|s′+1|≤p(|x|) and (x, s′)/∈R, and s′ otherwise; and the cost of an s is computed as
2T(x) ·−s for s ≥T(x), and 0 otherwise. This deﬁnes a Πp
1-PLS problem with goal
R satisfying conditions (3.1)-(3.5). The problem with this deﬁnition is that a proof
of its condition (3.3) already requires a proof that R is a total search problem.
To formulate a Πp
k-PLS local search principle so as to guarantee the totality of a
search problem without actually presupposing it, we have to ensure that the condi-
tions (3.1)–(3.5) have “simple” proofs. We make this precise in the next deﬁnition
by requiring that they are provable in S1
2.
Deﬁnition 3.3 (Formalised Πp
k-PLS Problems with Πp
ℓ-Goals). A Πp
k-PLS prob-
lem with Πp
ℓ-goal is formalised in S1
2 provided the functions N, c, and i are
Σb
1-deﬁnable in S1
2, the predicate F is given by a Πb
k-formula, the predicate G
is given by a Πb
ℓ-formula (Δb
1 if ℓ= 0), and the deﬁning conditions (3.1)–(3.5) are
provable in S1
2.
A Πp
k-PLS problem with Πp
ℓ-goal which is formalised in S1
2 will be called a
Πb
k-PLS problem with Πb
ℓ-goal (with superscript “b” instead of “p”.)
The direction “→” in condition (3.5) of a Πb
k-PLS problem with Πb
ℓ-goal is
inessential, dropping it would result in an equivalent class of search problems.
To make this more precise, let us denote with Πb
k-PLS’ problems with Πb
ℓ-goals
the class of search problems which are deﬁned similar to Πb
k-PLS problems with
Πb
ℓ-goals, with the only difference that in (3.5) equivalence “↔” is replaced by re-
verse implication “←”. To see that Πb
k-PLS’ problems with Πb
ℓ-goals are equivalent
to Πb
k-PLS problems with Πb
ℓ-goals, ﬁrst observe that any Πb
k-PLS problem with
Πb
ℓ-goal is also a Πb
k-PLS’ problem with Πb
ℓ-goal. Secondly, we can transform any
Πb
k-PLS’ problem with Πb
ℓ-goal L′ = (d′, F ′, G′, N ′, c′, i′) into a Πb
k-PLS prob-
lem with Πb
ℓ-goal L = (d, F, G, N, c, i) which solves L′, in the following way:
Let T(x) be 2d′(|x|). We set d to 2d′, and i(x) as T(x)+i′(x). Let s∈F(x) if
either s<T(x) and s∈G(x), or, in case s=T(x)+s′, if s′∈F ′(x). Set N(x, s) to
be s if s<T(x), or, in case s=T(x)+s′, to be T(x)+N ′(x, s′) if N ′(x, s′)̸=s′,
and s′ otherwise. Finally, deﬁne c(x, s) to be 0 if s<T(x), and 1+c′(x, s′) in case
s=T(x)+s′. It is easy to see that this deﬁnes a Πb
k-PLS problem with Πb
ℓ-goal,
which solves L′.

76
Arnold Beckmann and Samuel R. Buss
Theorem 3.4. Let k ≥ℓ≥0.
The Πb
k-PLS problems with Πb
ℓ-goals are
Σb
ℓ+1-deﬁnable search problems in Tk+1
2
.
Proof. Let L = (F, G, N, c, i) be a Πb
k-PLS problem with Πb
ℓ-goal. Let x be given.
The set A := {c(x, s): s ∈F(x)} is non-empty by (3.2), and can be expressed by
a Σb
k+1 formula. Tk+1
2
proves minimisation for Σb
k+1-formulas, thus, arguing in
Tk+1
2
, we can choose some minimal c ∈A. Pick s ∈F(x) with c(x, s) = c, and
let s′ := N(x, s). Then s′ ∈F(x) by (3.3). By construction c(x, s′) ≥c(x, s),
hence (3.4) shows s′ = N(x, s) = s. Hence, (3.5) shows s ∈G(x).
That {(x, s): s ∈G(x)} can be described by some Πb
ℓformula is clear by deﬁ-
nition.
The converse of the last theorem is also true and forms one of our main results
in this article. It will be proven in Section 7.2.
Theorem 3.5. Let 0 ≤ℓ≤k. The Σb
ℓ+1-deﬁnable total search problems in
Tk+1
2
can be characterised by Πb
k-PLS problems with Πb
ℓ-goals. This character-
isation satisﬁes in addition that the goal formula is syntactically identical to the
Πb
ℓ-subformula of the original Σb
ℓ+1-formula.
3.1 Search Problem Classes
Deﬁnition 3.2 gives rise to search principles which can be expressed by one for-
mula PiPLS(d, F, G, N, c, i) in second order parameters d, F, G, N, c, i, which is
deﬁned as
(3.1) ∧(3.2) ∧(3.3) ∧(3.4) ∧(3.5) →(∀x)(∃y)G(x, y) .
By choosing appropriate substitutions for the parameters, this generic formula
can be used to deﬁne syntactic search problem classes which characterise the
∀Σb
ℓ+1-consequences of Tk+1
2
: Let PiPLS(k, ℓ) be the set of all formulas obtained
by replacing in PiPLS(d, F, G, N, c, i), d by some polynomial, N, c, i by polyno-
mial time computable functions (represented by their Σb
1-deﬁnition in S1
2), F by
some formula in Πb
k, and G by some formula in Πb
ℓ. The proof of Theorem 3.4
shows that each formula in PiPLS(k, l) is provable in Tk+1
2
. A converse is also
true and can be shown using Theorem 3.5.
Corollary 3.6. Over S1
2, the theories PiPLS(k, l) and Tk+1
2
have the same
∀Σb
ℓ+1-consequences.

Deﬁnable Search Problems in Bounded Arithmetic
77
Proof. We already argued for one inclusion. We still have to show that if Tk+1
2
proves (∀x)ϕ(x) with ϕ ∈Σb
ℓ+1, then this formula also follows from a formula in
PiPLS(k, l) over S1
2.
Applying Theorem 3.5 we obtain a formalised Πp
k-PLS problem with goal for-
mula identical to ϕ. Consider the formula PiPLS(d, F, G, N, c, i) in PiPLS(k, l)
coming from this characterisation. The conditions (3.1)–(3.5) are now provable in
S1
2, so over S1
2 we immediately obtain (∀x)ϕ(x) from PiPLS(d, F, G, N, c, i).
In Sections 8 and 9, we will see that a strengthening of Theorem 3.5 can also be
proven, in which the conditions (3.1)–(3.5) will be transformed into some canonical
Skolem form, see Corollary 9.8. This will reduce the complexity of the search
principle class to match the complexity of the goal formulas. In particular we will
obtain a set of ∀Σb
1 formulas characterising the ∀Σb
1-consequences of the theories
Tk+1
2
, for k ≥0, see Corollary 10.2.
4 Notation Systems for Formulas and Proofs
In this section we review notation systems for propositional formulas and proofs,
and cut-reduction for them from [AB09]. They provide the basic machinery for
dealing with search problems based on proof notations.
4.1 Proof Systems
We begin with an abstract deﬁnition of proof systems, which will be at the heart of
several derivation systems considered later.
Deﬁnition 4.1 (Notation System for Formulas). A notation system for formulas is
a triple ⟨F, ≈, rk⟩where F is a set (of formulas), ≈an equivalence relation on
F (identity between formulas), and rk: P(F) × F →N a function (rank). Here,
P(F) denotes the power set of F.
We always write C-rk(A) instead of rk(C, A).
With ≈Γ we denote the set
{G: (∃F ∈Γ)(G ≈F)}.
Deﬁnition 4.2. A proof system S over ⟨F, ≈, rk⟩is given by a set of formal
expressions called inference symbols (syntactic variable I), and for each infer-
ence symbol I an ordinal |I| ≤ω, a sequent Δ(I) and a family of sequents
(Δι(I))ι<|I|.
Proof systems may have inference symbols of the form CutC for C ∈F; these
are called “cut inference symbols” and their use will (in Deﬁnition 4.4) be measured
by the C-cut-rank.

78
Arnold Beckmann and Samuel R. Buss
Notation 4.3. By writing
. . . Δι . . . (ι < I)
(I)
Δ
we declare I as an inference
symbol with |I| = I many hypotheses, with conclusion Δ(I) = Δ, and ι-th
hypothesis Δι(I) = Δι for ι < I. If |I| = n we write
Δ0 Δ1 . . . Δn−1
Δ
instead of
. . . Δι . . . (ι < I)
Δ
.
S-quasi derivations, to be deﬁned next, are (inﬁnite) terms built up from infer-
ence symbols. An S-quasi derivation will always have the form of an inference
symbol I, followed by “(”, followed by a sequence of length |I| of S-quasi deriva-
tions, followed by “)”. For example, the simplest S-quasi derivations are given as
I() in case I is an inference symbol with |I| = 0. We will write a sequence of the
form (d0, . . . , dn−1) as (dι)ι<n.
Deﬁnition 4.4 (Inductive deﬁnition of S-quasi derivations). If I is an infer-
ence symbol of S, and (dι)ι<|I| is a sequence of S-quasi derivations, then let
d := I(dι)ι<|I| be an S-quasi derivation with end-sequent
Γ(d) := Δ(I) ∪

ι<|I|
(Γ(dι) \ ≈Δι(I)) ,
last inference last(d) := I, subderivations d(ι) := dι for ι < |I|, height
hgt(d) := sup {hgt(dι) + 1: ι < |I|} ,
size (provided S has inference symbols of ﬁnite arity only)
sz(d) := (

ι<|I|
sz(dι)) + 1 ,
and cut-rank
C-crk(d) := sup({C-rk(I)} ∪{C-crk(dι): ι < |I|}) .
Here we deﬁne C-rk(I), the cut-rank of I, to be C-rk(C) + 1 if I is of the form
I = CutC with C ̸∈C, and to be 0 otherwise.
Deﬁnition 4.5. d ⊢≈Γ is deﬁned as Γ(d) ⊆≈Γ.
A translation of ﬁrst order proofs into propositional ones, like the Paris-Wilkie
translation, usually comes in two steps: First, ﬁrst order formulas are translated
into propositional ones; Second, ﬁrst order proofs are translated into propositional
proofs. In the next subsection, we introduce notation systems for propositional

Deﬁnable Search Problems in Bounded Arithmetic
79
formulas of the type obtained by the Paris-Wilkie translation of ﬁrst order formu-
las. The subsequent section deﬁnes our propositional proof system. Then, Sub-
section 4.4 describes polynomial-size notations for exponential-size propositional
proofs that are obtained by the translation of ﬁrst order proofs.
4.2 Notations for Propositional Formulas
Translating ﬁrst order formulas into propositional ones via the Paris-Wilkie trans-
lation PW transforms a bounded quantiﬁer of the form (∀x ≤t(a))ϕ(x) into the
propositional formula 	
i≤t(a)Nϕ(i)PW. The length of this propositional formula is
exponential in |a|, thus we need notation systems for such propositional formulas
which allow us to deal with them in a feasible way. The next deﬁnition collects all
necessary ingredients and properties of notation systems for propositional formu-
las.
Deﬁnition 4.6. We deﬁne ¬ as a function on the symbols {⊤, ⊥, 	, 
} in the
following way: ¬(⊤) = ⊥, ¬(⊥) = ⊤, ¬(	) = 
, and ¬(
) = 	.
Deﬁnition 4.7. A notation system ⟨F, tp, ·[·], ¬, rk, ≈⟩for (inﬁnitary) proposi-
tional formulas is a notation system ⟨F, ≈, rk⟩for formulas together with functions
tp: F →{⊤, ⊥, 	, 
}, ·[·]: F × N →F, and ¬: F →F, called outermost con-
nective, subformula, and negation, respectively, such that tp(¬(f)) = ¬(tp(f)),
¬(f)[n] = ¬(f[n]), C-rk(f) = C-rk(¬f), C-rk(f[n]) < C-rk(f) for f /∈C and
n < | tp(f)|, and f ≈g implies tp(f) = tp(g), f[n] ≈g[n], ¬(f) ≈¬(g) and
C-rk(f) = C-rk(g).
In the previous deﬁnition, the obvious idea behind f[n] for f ∈F and n ∈N
is that it denotes the n-th subformula of f. But observe that the situation we are
describing is a bit more general. It does not exclude non-wellfounded notation
systems, which may contain a notation f for which 0 < | tp(f)| continues to hold
for f[0], f[0][0], etc. ad inﬁnitum. The cut-elimination results summarised in the
following are still valid also in such a situation.
4.3 Propositional Proofs
The propositional proof system we are concerned with is directly based on notation
systems for propositional formulas. There is of course a propositional proof system
for (usual) propositional formulas in the background which is obtained by unfold-
ing notations for propositional formulas into (usual) propositional formulas. This
background proof system is not necessary for our technical developments, therefore
we omit it. The interested reader will ﬁnd a more detailed discussion in [AB09].

80
Arnold Beckmann and Samuel R. Buss
Deﬁnition 4.8. Let F = ⟨F, tp, ·[·], ¬, rk, ≈⟩be a notation system for proposi-
tional formulas. The (propositional) proof system SF over F is the proof system
over F which is given by the following set of inference symbols.
(AxA)
A for A ∈F with tp(A) = ⊤
...
C[n]
...
(n ∈N)
(	
C)
C
for C ∈F with tp(C) = 	
C[i]
(
i
C)
C
for C ∈F with tp(C) = 
 and i ∈N
C
¬C
(CutC)
∅
for C ∈F with tp(C) ∈{⊤, 	}
∅
(Rep)
∅
Abbreviations
For tp(C) ∈{⊥, 
} let
C
¬C
(CutC)
∅
denote
¬C
C
(Cut¬C)
∅
4.4 Notations for Propositional Proofs and Cut-Elimination
The translation of ﬁrst order proofs in Bounded Arithmetic into the proposi-
tional proof system deﬁned in Deﬁnition 4.8 may generate proofs of exponen-
tial size.
E.g., an application of
ϕ(min(x, t(a)))
(∀)
(∀x ≤t(a))ϕ(x)
is translated into
ϕ(0)PW
. ..
ϕ(t(a)N)PW
(	)
(∀x ≤t(a))ϕ(x)PW
which may have exponentially in |a| many
premises. Thus, besides notations for propositional formulas, we also need no-
tations for propositional proofs obtained by translation in order to be able to deal
with them in a feasible way. The necessary ingredients for this are collected in the
next deﬁnition. With Pﬁn(S) we denote the set of all ﬁnite subsets of S.
Deﬁnition 4.9. Let F be a notation system for formulas, and SF the propositional
proof system over F from Deﬁnition 4.8.
A notation system H = ⟨H, tp, ·[·], Γ, crk, o, |·|⟩for SF is a set H of no-
tations and functions tp: H →SF, ·[·]: H × N →H, Γ: H →Pﬁn(F),
crk: P(F) × H →N, and o, |·|: H
→
N \ {0} called denoted last infer-
ence, denoted subderivation, denoted end-sequent, denoted cut-rank, denoted
height and size, such that C-crk(h[n]) ≤C-crk(h), tp(h) = CutC implies

Deﬁnable Search Problems in Bounded Arithmetic
81
C-rk(C) < C-crk(h) for C /∈C, o(h[n]) < o(h) for n < | tp(h)|, and the fol-
lowing local faithfulness property holds for h ∈H:
Δ(tp(h)) ⊆≈Γ(h)
and
∀ι < | tp(h)| h[ι] ⊢≈Γ(h), Δι(tp(h)) .
We observe that the size function in the last deﬁnition is not denoted. The idea is
that it measures the size of the notation, not of the denoted proof. The size function
will be important later when we try to measure the effect which cut-elimination has
on notations, to identify those cases where the effect is feasible, i.e. does not lead
to an exponential blow-up typical for cut-elimination on (regular) proofs.
The next deﬁnition gives the canonical propositional translation of proof nota-
tions into propositional proofs. The observation following this deﬁnition states the
connection between key structural functions for notations and for connected propo-
sitional derivations.
Deﬁnition 4.10. Let H = ⟨H, tp, ·[·], Γ, crk, o, |·|⟩be a notation system for SF.
The interpretation [[h]] of a notation h ∈H is inductively deﬁned as the following
SF-derivation:
[[h]] := tp(h)([[h[ι]]])ι<| tp(h)|
Observation 4.11. We make use of the functions deﬁned in Deﬁnition 4.4. For
h ∈H we have
last([[h]]) = tp(h)
[[h]](ι) = [[h[ι]]]
for ι < | tp(h)|
Γ([[h]]) ⊆≈Γ(h)
We explained in the introduction of this paper that our characterisation of deﬁn-
able search problems in Bounded Arithmetic will be based on translating Bounded
Arithmetic proofs into propositional ones, and applying cut-reduction to the result-
ing propositional proofs. Thus, we also have to add to our notation system for
propositional logic some notations for cut-reduction on propositional proofs. This
can be done very uniformly, as presented in the next deﬁnition. Our approach fol-
lowing [AB09] is based on Mints’ continuous cut-elimination procedure [Min78]
in its technical smooth presentation by Buchholz [Buc91, Buc97] and utilises no-
tations for certain operators of propositional proofs. Readers interested in a fuller
account of this situation are kindly referred to [AB09]. The intuition behind the
notations for operators for cut-reduction are as follows:
• The symbol Ik
C denotes an inversion operator which satisﬁes the following: If
h ⊢≈Γ, C and tp(C) = 	 then Ik
Ch ⊢≈Γ, C[k], C-crk(Ik
Ch) ≤C-crk(h)
and o(Ik
Ch) ≤o(h).

82
Arnold Beckmann and Samuel R. Buss
• The symbol RC denotes a one-cut-reduction operator which satisﬁes the
following: If h0 ⊢≈Γ, C, h1 ⊢≈Γ, ¬C and tp(C) ∈{⊤, 	}, then
RCh0h1 ⊢≈Γ, C-crk(RCh0h1) ≤max{C-crk(h0), C-crk(h1), C-rk(C)} and
o(RCh0h1) ≤o(h0) + o(h1).
• The symbol E denotes a highest-cut-elimination operator which satisﬁes: If
h ⊢≈Γ then Eh ⊢≈Γ and C-crk(Eh) ≤C-crk(h) ·−1 and o(Eh) < 2o(h).
Deﬁnition 4.12. The notation system CH for cut-elimination on H is given by the
set of terms CH which are inductively deﬁned by
• H ⊂CH,
• h ∈CH, C ∈F with tp(C) = 	, k < ω
⇒
Ik
Ch ∈CH,
• h0, h1 ∈CH, C ∈F with tp(C) ∈{⊤, 	}
⇒
RCh0h1 ∈CH,
• h ∈CH
⇒
Eh ∈CH,
where I, R, E are new symbols, and functions tp: CH →SF, ·[·]: CH×N →CH,
Γ: CH →Pﬁn(F), crk: P(F) × CH →N, o: CH →N \ {0} and |·|: CH →N
deﬁned by recursion on the complexity of h ∈CH:
• If h ∈H then all functions are inherited from H.
• h = Ik
Ch0: Let Γ(h) := {C[k]} ∪(Γ(h0) \ ≈{C}), C-crk(h) := C-crk(h0),
o(h) := o(h0), and |h| := |h0| + 1.
Case 1.
tp(h0) ∈{	
D : D ≈C}.
Then let tp(h) := Rep, and deﬁne
h[0] := Ik
Ch0[k].
Case 2. Otherwise, let tp(h) := tp(h0), and h[i] := Ik
Ch0[i].
• h = RCh0h1: Let I := tp(h1). We deﬁne
Γ(h) := (Γ(h0) \ ≈{C}) ∪(Γ(h1) \ ≈{¬C}) ,
C-crk(h) := max{C-crk(h0), C-crk(h1), C-rk(C)} ,
o(h) := o(h0) + o(h1), and |h| := |h0| + |h1| + 1. For tp(h) and h[i] we
consider the following two cases:
Case 1. Δ(I) ∩≈{¬C} = ∅: Then let tp(h) := I, and h[i] := RCh0h1[i].
Case 2. Otherwise, Δ(I) ∩≈{¬C} ̸= ∅. Since tp(C) ∈{⊤, 	} and
no inference symbol I′ of SF has D ∈Δ(I′) with tp(D) = ⊥, we must
have tp(C) = 	. Thus I = 
k
D for some k ∈N and D ≈¬C. Then let
tp(h) := CutC[k] and h[0] := Ik
Ch0, h[1] := RCh0h1[0].

Deﬁnable Search Problems in Bounded Arithmetic
83
• h = Eh0: Let Γ(h) := Γ(h0), C-crk(h) := C-crk(h0) ·−1, o(h) := 2o(h0) −1,
and |h| := |h0| + 1.
Case 1. tp(h0) = CutC: Then let tp(h) := Rep, and
h[0] :=

RCEh0[0]Eh0[1]
if tp(C) ∈{⊤, 	},
R¬CEh0[1]Eh0[0]
if tp(C) /∈{⊤, 	}.
Case 2. Otherwise, let tp(h) := tp(h0), and h[i] := Eh0[i].
It has been shown in [AB09] that the notation system for cut-elimination on H
is a notation system in the sense of Deﬁnition 4.9.
4.5 Size Bounds of Notations for Cut-Elimination
Notation systems for propositional formulas and proofs will, as we will see later, be
feasible in situations related to deﬁnable search problems of Bounded Arithmetic.
We will now analyse the feasibility of notations for cut-reduction on propositional
proofs, by studying the size of notations for cut-reduction. We will just state the
necessary deﬁnitions and results, more details including full proofs can be found
in [AB09].
Deﬁnition 4.13. H is called bounded if |h[i]| ≤|h| for all h ∈H, i < | tp(h)|.
Deﬁnition 4.14. We deﬁne a “size function” ϑ: N →N by induction on the induc-
tive deﬁnition of CH as follows.
• For h ∈H we set ϑ(h) = |h|.
• ϑ(Ik
Ch) = ϑ(h) + 1
• ϑ(RCh0h1) = max{|h0|+1+ϑ(h1) , ϑ(h0)+1}
• ϑ(Eh) = o(h)(ϑ(h) + 2)
Proposition 4.15. If H is bounded then for every h ∈CH we have |h| ≤ϑ(h).
Theorem 4.16. If H is bounded, h ∈CH and i < | tp(h)|, then ϑ(h) ≥ϑ(h[i]).
Deﬁnition 4.14, Proposition 4.15 and Theorem 4.16 together show that cut-
reduction can behave feasibly on proof notations. E.g., assume that we have a
proof notation h(a) depending on some parameter a — such a notation may origi-
nate from a ﬁrst order proof of a universal statement (∀x)ϕ(x), where we inverted

84
Arnold Beckmann and Samuel R. Buss
the outermost universal quantiﬁer and substituted the constant a for the new free
variable x, thus considering a proof of ϕ(a) for a ∈N — such that o(h(a)) and
|h(a)| are polynomial in |a|. Applying cut-reduction once to h(a) gives a proposi-
tional proof in which all subproofs can be denoted by a notation of size polynomial
in |a|: Consider a subproof h′ of Eh(a) which is given by the path i1, . . . , ik, i.e.
h′ = Eh(a)[i1] · · · [ik]. By Proposition 4.15, |h′| ≤ϑ(h′), and by Theorem 4.16,
ϑ(h′) ≤ϑ(Eh(a)). By Deﬁnition 4.14, the latter can be computed to
ϑ(Eh(a)) = o(h(a)) · (ϑ(h(a))+2) = o(h(a)) · (|h(a)|+2)
which is polynomial in |a|.
In the next section we will deﬁne concrete notation systems for propositional for-
mulas and proofs based on translating Bounded Arithmetic according to the Paris-
Wilkie translation. Together with the results from this section they provide the
machinery for characterising deﬁnable search problems via proof notations.
5 Notations based on Bounded Arithmetic
We start by deﬁning a notation system for propositional formulas obtained by trans-
lating the language of Bounded Arithmetic according to the Paris-Wilkie transla-
tion, as given in [AB09].
Let FBA be the set of closed formulas in Δ0. We deﬁne the outermost connective
function on FBA by
tp(A) :=
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
⊤
A true literal
⊥
A false literal
	
A is of the form A0 ∧A1 or (∀x)B

A is of the form A0 ∨A1 or (∃x)B ,
and the subformula function on FBA × N by
A[n] :=
⎧
⎪
⎨
⎪
⎩
A
A literal
Amin(n,1)
A is of the form A0 ∧A1 or A0 ∨A1
Bx(n)
A is of the form (∀x)B or (∃x)B .
To deﬁne a suitable rank function on FBA, we ﬁrst deﬁne an auxiliary rank func-
tion rk’. Let C be a subset of FBA, and A in FBA. We deﬁne C-rk’(A) by induction
on the complexity of A. If A ∈C ∪¬C, let C-rk’(A) := −1. For A /∈C ∪¬C,
C-rk’(A) is deﬁned as follows:

Deﬁnable Search Problems in Bounded Arithmetic
85
• Let C-rk’(A) := 1 + max{C-rk’(B), C-rk’(C)} in case A = B ∧C or
A = B ∨C.
• If A = (∀x)B or A = (∃x)B, let C-rk’(A) := 1 + C-rk’(B).
Using the auxiliary rank function rk’, we deﬁne the C-rank of A, denoted C-rk(A),
by C-rk(A) := max{0, C-rk’(A)}. Observe that sΣb
i -rk(A) ≤sΣb
i+1-rk(A) + 1. If
C is the set of quantiﬁer-free formulas, and ϕ ∈sΣb
∞, then the rank of ϕ as deﬁned
in Section 2 is the same as C-rk(ϕ), i.e. C-rk(ϕ) computes the minimal k such that
ϕ ∈sΣb
k ∪sΠb
k.
The negation function for the notation system is the same as deﬁned for LBA.
Intensional equality is deﬁned in the following way: For t a closed term its numer-
ical value tN ∈N is deﬁned in the obvious way. Let →1
N denote the term rewriting
relation on LBA-terms and LBA-formulas obtained from the following binary rela-
tion:

(t, tN): t a closed term

.
Let ≈N denote the reﬂexive, symmetric and transitive closure of →1
N. For example,
(∀x)((3 + 1) · x = 1 + 5) ≈N (∀x)(4 · x = 6).
Proposition 5.1. The system ⟨FBA, tp, ·[·], ¬, rk, ≈N⟩which we have just deﬁned
forms a notation system for formulas in the sense of Deﬁnition 4.7.
Let ≈Nk denote the restriction of ≈N to expressions of depth ≤k. In a feasible
G¨odel numbering, like the one deﬁned in [Bus86], the G¨odel number for ca has
size proportional to |a|. Thus, for each k, the relation ≈Nk is a polynomial time
predicate. We will always assume that FBA implicitly contains such a constant
k without explicitly mentioning it. All formulas and terms used in FBA are thus
assumed to obey the abovementioned restriction on depth. We will come back to
this restriction at relevant places. The next observation already makes use of this
assumption.
Observation 5.2. All relations and functions in FBA are polynomial time com-
putable.
Deﬁnition 5.3. Let BA∞denote the propositional proof system over FBA accord-
ing to Deﬁnition 4.8.
Deﬁnition 5.4. We deﬁne the ﬁnitary proof system BA⋆as the proof system over
⟨Δ0, ≈N, rk⟩which is given by the following set of inference symbols:

86
Arnold Beckmann and Samuel R. Buss
(AxΔ)
if 
 Δ ∈BASIC
Δ
A0
A1
(	
A0∧A1)
A0 ∧A1
Ak
(
k
A0∨A1)
A0 ∨A1
Ax(y)
(	y
(∀x)A)
(∀x)A
Ax(t)
(
t
(∃x)A)
(∃x)A
¬F, Fy(y + 1)
(INDy,t
F )
¬Fy(0), Fy(2|t|)
¬F, Fy(y + 1)
(INDy,n,i
F
)
¬Fy(n), Fy(n + 2i)
C
¬C
(CutC)
∅
for C ∈Δ0 with C atomic or tp(C) = 	
where in case (
k
A0∨A1) we have that k ∈{0, 1}, and in case (INDy,n,i
F
) that
n, i ∈N.
According to Deﬁnition 4.4, BA⋆-quasi derivations h are equipped with func-
tions Γ(h) denoting the endsequent of h, hgt(h) denoting the height of h, and
sz(h) denoting the size of h.
In the following we will not need the cut-rank function which comes with
BA⋆-quasi derivations, but we will need a more general cut-rank function gcrk,
which will also bound the rank of induction formulas.
Deﬁnition 5.5. Let h be a BA⋆-quasi derivation, h = Ih0 · · · hn−1. We deﬁne
C-gcrk(h) := sup({C-grk(I)} ∪{C-gcrk(hi): i < n})
where C-grk(I), the generalised cut-rank of I, is C-rk(C) + 1 if I is of the form
CutC, INDy,t
C or INDy,n,i
C
for C /∈C, and 0 otherwise.
Observe that sΣb
i -gcrk(h) ≤sΣb
i+1-gcrk(h) + 1, which immediately follows
from sΣb
i -gcrk(I) ≤sΣb
i+1-gcrk(I) + 1.
Deﬁnition 5.6 (Inductive deﬁnition of ⃗x: h and BA⋆-derivations). For ⃗x a ﬁnite list
of disjoint variables and h = Ih0 · · · hn−1 a BA⋆-quasi-derivation we inductively
deﬁne the relation ⃗x: h that h is a BA⋆-derivation with free variables among ⃗x as
follows.
• If ⃗x, y: h0 and I ∈{	y
(∀x)A, INDy,t
F , INDy,n,i
F
} for some A, F, t, n, i, and
FV(t) ∪FV(Γ(Ih0)) ⊂{⃗x} then ⃗x: Ih0.
• If ⃗x: h0 and FV((∃x)A), FV(t) ⊆{⃗x} then ⃗x: 
t
(∃x)Ah0.
• If ⃗x: h0, ⃗x: h1 and FV(C) ⊆{⃗x} then ⃗x: CutCh0h1.

Deﬁnable Search Problems in Bounded Arithmetic
87
• If FV(Δ) ⊆{⃗x} then ⃗x: AxΔ,
• If ⃗x: h0, ⃗x: h1 and I = 	
A0∧A1 with FV(A0 ∧A1) ⊂{⃗x} then ⃗x: Ih0h1.
• If ⃗x: h0 and I = 
k
A0∨A1 with FV(A0 ∨A1) ⊂{⃗x} then ⃗x: Ih0.
We call a BA⋆-derivation h closed, if ∅: h.
Deﬁnition 5.7. For h a BA⋆-derivation, y a variable and t a closed term of
Bounded Arithmetic we deﬁne the substitution h(t/y) inductively by setting
(Ih0 · · · hn−1)(t/y) to be I(t/y)h0(t/y) · · · hn−1(t/y) if I is not of the form
	y
(∀x)A, INDy,t
F , or INDy,n,i
F
with the same variable y, and Ih0 · · · hn−1 other-
wise.
Substitution for inference symbols is deﬁned by setting
AxΔ(t/y)
= AxΔ(t/y)
	
A0∧A1(t/y) = 	
(A0∧A1)(t/y)

k
A0∧A1(t/y) = 
k
(A0∧A1)(t/y)
	z
(∀x)A(t/y) = 	z
((∀x)A)(t/y)

t′
(∃x)A(t/y)
= 
t′(t/y)
((∃x)A)(t/y)
INDz,t′
F (t/y) = INDz,t′(t/y)
F (t/y)
INDz,n,i
F
(t/y) = INDz,n,i
F (t/y)
The next Lemma shows the substitution property for BA⋆-derivations.
The
strange looking “⊆” instead of the expected equality comes from the fact that a
substitution may make formulas equal which are not equal without the substitution.
Lemma 5.8. Assume ⃗x: h and let y be a variable and t a closed term, then
⃗x \ {y}: h(t/y) and moreover Γ(h(t/y)) ⊆(Γ(h))(t/y).
We will now deﬁne the ingredients for a notation system HBA for BA∞accord-
ing to Deﬁnition 4.9. The interpretation [[h]] for h ∈HBA according to Deﬁni-
tion 4.10 formalises a translation of closed BA⋆-derivations into BA∞, which is
called an embedding.
Let HBA be the set of closed BA⋆-derivations. For each h ∈HBA we deﬁne the

88
Arnold Beckmann and Samuel R. Buss
denoted last inference tp(h) as follows: Let h = Ih0 · · · hn−1,
tp(h) :=
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
AxA
if I = AxΔ, where A is the
“least” true literal in Δ
	
A0 ∧A1
if I = 	
A0 ∧A1

k
A0 ∨A1
if I = 
k
A0 ∨A1
	
(∀x)A
if I = 	y
(∀x)A

tN
(∃x)A
if I = 
t
(∃x)A
Rep
if I = INDy,t
F
Rep
if I = INDy,n,0
F
CutFy(n+2i)
if I = INDy,n,i+1
F
CutC
if I = CutC
For each h ∈HBA and j ∈N we deﬁne the denoted subderivation h[j] as
follows: Let h = Ih0 · · · hn−1. If j ≥| tp(h)| let h[j] := Ax0=0. Otherwise,
assume j < | tp(h)| and deﬁne
h[j] :=
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
hmin(j,1)
if I = 	
A0 ∧A1
h0
if I = 
k
A0 ∨A1
h0(j/y)
if I = 	y
(∀x)A
h0
if I = 
t
(∃x)A
INDy,0,|t|N
F
h0
if I = INDy,t
F
h0(n/y)
if I = INDy,n,0
F
INDy,n,i
F
h0
if I = INDy,n,i+1
F
and j = 0
INDy,n+2i,i
F
h0
if I = INDy,n,i+1
F
and j = 1
hj
if I = CutC
The denoted end-sequent function on HBA is given by Γ. The size function |·|
on HBA is given by |h| := sz(h). We deﬁne the denoted cut-rank function for
h ∈HBA to be C-crk(h) := C-gcrk(h). We observe that C-crk(h[ι]) ≤C-crk(h)
for ι < | tp(h)|, and that C-rk(C) < C-crk(h) if tp(h) = CutC and C /∈C.
To deﬁne the denoted height function we need some analysis yielding an upper
bound to the log of the lengths of inductions which may occur during the embed-
ding (we take the log as this bounds the height of the derivation tree which embeds
an application of induction). Let us ﬁrst assume m is such an upper bound, and
let us deﬁne the denoted height om(h) of h relative to m: For a BA⋆-derivation

Deﬁnable Search Problems in Bounded Arithmetic
89
h = Ih0 · · · hn−1 we deﬁne
om(h) :=
⎧
⎪
⎨
⎪
⎩
om(h0) + i + 1
if I = INDy,n,i
F
om(h0) + m + 1
if I = INDy,t
F
1 + supi<n om(hi)
otherwise
Observe that om(h) > 0 (in particular, o(AxΔ) = 1).
To ﬁll the gap of providing a suitable upper bound function of BA⋆-derivations
we ﬁrst need to ﬁx monotone bounding terms for any term in LBA.
Bounding Terms for Language and Proofs
For a term t we deﬁne a term bd(t) which represents a monotone function with the
following property: If FV(t) = {⃗x} then
(∀⃗n)
t⃗x(⃗n)N
≤
bd(t)⃗x(⃗n)N
The precise deﬁnition of bd(t) is not essential here, we can for example use the
meta-function σ from [Bus86, p.77], or the explicit deﬁnition given in [AB09].
For h ∈HBA, the bounding term bd(h) is intended to bound any variable which
occurs during the embedding of h. Then, the term |bd(h)| will bound the length
of any induction which occurs during the embedding of h. This situation is related
to the notion proofs restricted by parameter variables as deﬁned in [Bus86, Sec-
tion 4.5], where proofs are transformed in such a way that bounds to inductions
and quantiﬁcation only depend on the parameter variables of the proof — then the
above mentioned bounding term bd(h) can simply be obtained by collecting all
such bounds and taking their maximum. Let h = Ih0 · · · hn−1 be in HBA. Let
max(n1, . . . , nk) denote the maximal value amongst {n1, . . . , nk}, where we set
max() = 0. We deﬁne
bd(h) :=
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎩
max(bd(h0(bd(t)/y)), bd(t))
if I = 	y
(∀x≤t)A
max(bd(h0), bd(t))
if I = 
t
(∃x)A
max(bd(h0(2| bd(t)|/y)), 2| bd(t)|)
if I = INDy,t
F
max(bd(h0(n + 2i/y)), n + 2i)
if I = INDy,n,i
F
max(bd(h0), . . . , bd(hn−1))
otherwise.
Now we deﬁne for h ∈HBA the denoted height function o(h) as o|bd(h)|(h).
Theorem 5.9. The just deﬁned system ⟨HBA, tp, ·[·], Γ, crk, o(·), |·|⟩forms a nota-
tion system for BA∞in the sense of Deﬁnition 4.9. Furthermore, HBA is bounded
in the sense of Deﬁnition 4.13.

90
Arnold Beckmann and Samuel R. Buss
A proof of this Theorem can be found in [AB09]. The fact that HBA is bounded
is easily observed by inspection.
Observation 5.10. We assume that we have ﬁxed a k ∈N bounding depths of
formulas and terms as explained in the remark on page 85, and some feasible G¨odel
numbering like the one in [Bus86]. Then, the following relations and functions
are polynomial time computable (when interpreted as relations and functions on
the corresponding G¨odel numbers of syntactical objects): the ﬁnitary proof system
BA⋆, the set of BA⋆-quasi derivations and the functions h →Γ(h), h →hgt(h),
and h →sz(h) denoting the endsequent, the height and the size for a BA⋆-quasi
derivation h; the bounding term t →bd(t) for terms t occurring in FBA and the
relations bd(h) ≤m on HBA × N; the set HBA and the functions h →tp(h),
h, i →h[i], h →Γ(h), m, h →om(h) and h →|h|.
We now provide a connection between BA⋆/HBA and the theories of Bounded
Arithmetic as deﬁned in Section 2. This step also includes some proof normal-
isation which is similar to known ones in the literature, for example free cut-
elimination in [Bus86] or partial cut-elimination in [Bec03].
Theorem 5.11 (Partial Cut-elimination). Assume Tj
2 ⊢ϕ with ϕ ∈Δ0 and
FV(ϕ) ⊆{x}. Then, there is some BA⋆-derivation h such that FV(h) ⊆{x},
Γ(h) = {ϕ}, sΣb
j -gcrk(h) = 0 and o(h(a/x)) = |a|O(1).
A proof of the last theorem can be found in [AB09].
5.1 Complexity Notions for BA⋆
In order to describe local search problems based on proof notations we need some
notions describing key complexity properties of BA⋆proof notations. Again, we
will just state the necessary deﬁnitions and results, more details including full
proofs can be found in [AB09].
Deﬁnition 5.12. We extend the deﬁnition of bounding terms bd(h) from HBA to
CHBA by induction on h ∈CHBA in the following way:
• If h ∈HBA then the deﬁnition of bd(h) is inherited from the deﬁnition of
bd(h) on HBA.
• bd(Ik
Ch0) := bd(h0).
• bd(RCh0h1) := max{bd(h0), bd(h1)}.
• bd(Eh0) := bd(h0).

Deﬁnable Search Problems in Bounded Arithmetic
91
Lemma 5.13. Let h ∈CHBA.
1. bd(h[j]) ≤bd(h) for all j.
2. If tp(h) = 
k
C then k ≤bd(h).
Deﬁnition 5.14. For h a BA⋆-derivation or h ∈CHBA, we deﬁne the set of decora-
tions of h, deco(h), by induction on h. deco(h) will be a ﬁnite set of LBA-terms and
formulas in Δ0. Let h = Ih0 · · · hn−1, where I ranges over BA⋆∪{Ik
C, RC, E}.
We deﬁne
deco(h) := deco(I) ∪

i<n
deco(hi)
where
deco(I) := Δ(I) for I = AxΔ, 	
A0∧A1, 
k
A0∨A1
deco(	y
(∀x)A) := {(∀x)A, y}
deco(
t
(∃x)A) := {(∃x)A, t}
deco(INDy,t
F ) := {F, ¬Fy(0), Fy(2|t|), y, t}
deco(INDy,n,i
F
) := {F, ¬Fy(n), Fy(n + 2i), y, cn}
deco(CutC) := {C}
deco(Ik
C) := {C, C[k], ck}
deco(RC) := {C}
deco(E) := ∅.
Observation 5.15. We have Γ(h) ⊆deco(h).
Deﬁnition 5.16. Let Φ be a set of LBA-terms and formulas in Δ0, and let K ∈N
be a size parameter. With ΦK we denote the set obtained by enlarging Φ by the
set {ci : 0 ≤i ≤K} and the set of formulas and terms which result from formulas
and terms in Φ by substituting constants from {ci : 0 ≤i ≤K} for some (possibly
none, possibly all) of the free variables.
Lemma 5.17. Let Φ be a set of LBA-terms and formulas in Δ0, such that Φ∩Δ0 is
closed under negation and taking subformulas. Let j, K ∈N and y be a variable.
1. If j ≤K and C ∈Φ ∩Δ0, then C[j] ∈ΦK.
2. If h ∈BA⋆with deco(h) ⊆Φ, and j ≤K, then deco(h(j/y)) ⊆ΦK.

92
Arnold Beckmann and Samuel R. Buss
3. Δ(tp(h)) ⊆deco(h)bd(h) with the subscript understood in the sense of Deﬁ-
nition 5.16.
4. If h ∈CHBA is given which satisﬁes deco(h) ⊆Φ and j ≤K, then
deco(h[j]) ⊆Φmax{K,bd(h)}.
Lemma 5.18. For h ∈CHBA we have that the cardinality of Γ(h) is bounded
above by 2 · sz(h).
6 Searching for Truth
As explained in the introduction, the deﬁnition of search problems based on proof
notations has to deal with properties whose computational complexity is too com-
plicated to decide them directly. Therefore, instead of deciding them, we will re-
place them by some canonical search problem which determines their truth. This
section will provide the deﬁnition and basic properties for such canonical search
problems. In the next subsection we will present some general notation for tu-
ples and sequences which will also be useful in later sections when we discuss the
Skolemisation of prenex formulas that arise from search problems. The subsequent
subsection then introduces canonical search problems for properties in sΠb
k.
6.1 Notations for Tuples and Sequences
In order to have succinct notations for prenex formulas and for our discussion of
Skolemisation, we introduce formal tuples, and in particular tuples of variables and
quantiﬁers, and tuple quantiﬁcation for tuples of variables. These tuples are formed
and used on the meta level, they are not available in LBA.
At the end of the section we will also introduce sequence coding which will
be available within LBA. Sequences will be used to deﬁne various functions and
relations related to search problems.
Deﬁnition 6.1 (General Tuples). A tuple of length k is an expression of the form
[t1, . . . , tk] with ti some formal expression. We will use the letter t as a meta-
variable for general tuples. We will use subscripts of the form ti only to denote the
i-th element ti of t. Let [t1, . . . , tk]⌈ℓdenote [t1, . . . , tmin(k,ℓ)].
Deﬁnition 6.2 (Tuples of Variables). A tuple of variables of length k is an expres-
sion of the form [z1, . . . , zk] with zi being a formal variable in LBA. We will use
the letter z (possibly with superscripts) as a meta-variable for tuples of variables. zi
and z⌈ℓare deﬁned as for general tuples.

Deﬁnable Search Problems in Bounded Arithmetic
93
Deﬁnition 6.3 (Tuples of Quantiﬁers). A tuple of quantiﬁers of length k is an ex-
pression of the form [Q1, . . . , Qk] with Qi ∈{∃, ∀}. We will use the letter Q
(possibly with super-scripts) as a meta-variable for tuples of quantiﬁers.
Let Q = [Q1, . . . , Qk] be a tuple of quantiﬁers of length k. The expression ¬Q
denotes the tuple [¬Q1, . . . , ¬Qk] where ¬∀denotes ∃, and ¬∃denotes ∀. The
expression ∀k denotes the tuple [∀, . . . , ∀] of length k. The expression ∀∃k denotes
the tuple [∀, ∃, ∀, ∃, . . .] of length k. The expression ∃∀k denotes the tuple ¬∀∃k.
Deﬁnition 6.4 (Tuple Quantiﬁcation). Let Q = [Q1, . . . , Qk] be a tuple of quanti-
ﬁers of length k, and z = [z1, . . . , zk] a tuple of variables of length k. The expres-
sion (Qz)β denotes the formula
(Q1z1)(Q2z2) · · · (Qkzk)β .
We now ﬁx a coding of sequences of numbers of ﬁxed length. As the length
of sequences will always be ﬁxed on the meta-level, we can choose a sequence
coding based on a feasible pairing function. In principle we could deﬁne a concrete
pairing function which does not use the #-function, but the mere existence will
sufﬁce for our investigations. This deﬁnition of sequence coding may however play
a role in investigations of fragments of bounded arithmetic which do not include
the #-function, but we do not pursue these here.
Let us remind that a feasible pairing function a, b →pair(a, b) with projection
functions c →(c)1 and c →(c)2 are ﬁxed in LBA which satisfy (pair(a, b))1 = a
and (pair(a, b))2 = b and some natural bounding conditions like (c)i ≤c and
a, b ≤t →pair(a, b) ≤B(t) for some LBA-term B.
Deﬁnition 6.5 (Sequence Coding). We use pairing to deﬁne sequences of ﬁxed
length by letting ⟨⟩= 0, and ⟨a1, . . . , ak+1⟩= pair(a1, ⟨a2, . . . , ak+1⟩) with
corresponding projections pi. The projection function pi picks out the i-th element
of a sequence; that is, pi(⟨a1, . . . , ak⟩) = ai.
We use s (possibly with superscripts) as meta-variables to denote sequences. For
sequences denoted by s, we often write si to denote the i-th element, pi(s), of s.
We also use well-known list notation for sequences. The empty sequence of length
0 is denoted by ⟨⟩. If s is a sequence of length l, then ⟨a | s⟩denotes the sequence
of length l + 1 given by ⟨a | s⟩= pair(a, s). We also use expressions of the form
⟨a, b, c | s⟩= ⟨a | ⟨b | ⟨c | s⟩⟩⟩, and ⟨a, b, c⟩= ⟨a, b, c | ⟨⟩⟩, etc.
We also deﬁne the application of the projection function pi to formal tuples
t = [t1, . . . , tk] to denote the application of pi to each of the elements of t, that
is, pi(t) = [pi(t1), . . . , pi(tk)].

94
Arnold Beckmann and Samuel R. Buss
6.2 Canonical Search Problems for Properties in sΠb
k
In this subsection we deﬁne a canonical search problem for each formula in sΣb
∞.
The canonical search problem will be used to determine the truth of the formula.
To deﬁne the search space for a formula ϕ, we need an upper bound to all values
which may occur as quantiﬁed values in the evaluation of ϕ. The next deﬁnition
provides the necessary requirements which we will need for such upper bounds.
Deﬁnition 6.6 (Strict Upper Bounds). Let ϕ be of the form (Qz)β for some
quantiﬁer-free β, Q = [Q1, . . . , Qk] and z = [z1, . . . , zk]. An LBA-term D is
called a strict upper bound (s.u.b.) for ϕ if its free variables are amongst those
of ϕ, and if it satisﬁes the following properties: Let Qi := [Qi+1, . . . , Qk] and
zi := [zi+1, . . . , zk]. For all 1 ≤i ≤k with Qi = ∀,
S1
2 ⊢(∀z1) · · · (∀zi−1)

(∀zi < D)(Qizi)β →(∀zi)(Qizi)β

,
and for all i with Qi = ∃,
S1
2 ⊢(∀z1) · · · (∀zi−1)

(∃zi)(Qizi)β →(∃zi < D)(Qizi)β

.
Deﬁnition 6.7. For ϕ ∈sΣb
∞we can deﬁne the canonical s.u.b. Dϕ for ϕ induc-
tively as follows:
• If ϕ is quantiﬁer free, then let Dϕ := 0.
• If ϕ is of the form (∀x ≤t)ψ or (∃x ≤t)ψ, then let Dϕ be the term
max{bd(t) + 1, Dψ(x/ bd(t))}.
We observe that Dϕ represents a monotone function in its variables. Dϕ is a
s.u.b. in the sense of Deﬁnition 6.6, which can be shown immediately by induction
on the complexity of ϕ.
Notation 6.8. Let 0k denote the sequence of length k consisting only of zeros.
Let ϕ be a formula in sΣb
∞and ⃗a a list of variables such that FV(ϕ) ⊆{⃗a}.
Let D = D(⃗a) be a s.u.b. for ϕ. We deﬁne the canonical search problem SD
ϕ
for ϕ whose aim is to determine the truth value for ϕ. SD
ϕ is deﬁned similar to a
Πb
k-PLS problem with Πb
ℓ-goal from Deﬁnition 3.2, but instead of a goal set, SD
ϕ
has an answer set AD
ϕ of low computational complexity which determines the truth
of ϕ: For a solution s to the search problem, ϕ is true iff s ∈Aϕ. The answer
set will later be used to deﬁne the neighbourhood function for Πb
k-PLS problems,
which has to be of low complexity. The idea to determine the truth of ϕ of, say,

Deﬁnable Search Problems in Bounded Arithmetic
95
the form (∃x < D)ψ(x) is to successively “search” for the truth of ψ(0), ψ(1),...,
ψ(D −1). If any of these intermediate searches are successful, the overall search
will be successful and will yield a value d (usually the ﬁrst such) for which ψ(d)
produces success; otherwise the overall search will yield the value D indicating
that none of the intermediate searches were successful.
We start by deﬁning the conﬁguration space and cost function which only depend
on rank of formulas and not on their actual form.
Deﬁnition 6.9 (Conﬁguration Space). Let k ≥0 and D ≥1. The conﬁgura-
tion space Ck,D is the set of all sequences of length k of elements ≤D, i.e.
{⟨u1, . . . , uk⟩: u1, . . . , uk ≤D}. The cost function cD can be deﬁned on all se-
quences as
cD(⟨uk, . . . , u1⟩) :=
k

i=1
(D ·−ui)(D + 1)(i−1)
It has the properties that 0 ≤cD(s) < (D + 1)k for all s ∈Ck,D, and that
cD(s1) > cD(s2) if s1 is smaller than s2 w.r.t. the lexicographical order on tuples
in Ck,D.
Deﬁnition 6.10. The canonical search problem SD
ϕ of ϕ, given by the system
(CD
ϕ , F D
ϕ , AD
ϕ , N D
ϕ , cD
ϕ ), consists of a conﬁguration space CD
ϕ , a set of feasible
solutions F D
ϕ which is a subset of the conﬁguration space, an answer set AD
ϕ which
is a subset of the conﬁguration space, a neighbourhood function N D
ϕ which maps
conﬁgurations to conﬁgurations, and a cost function cD
ϕ deﬁned for conﬁgurations.
The goal of the search problem is to ﬁnd some s ∈F D
ϕ with ND
ϕ (s) = s.
The deﬁned sets and functions all implicitly depend on the parameters ⃗a of ϕ.
We will usually not mention D as it is understood from the context.
The conﬁguration space CD
ϕ is Crk(ϕ),D from the previous deﬁnition, and the
cost function cD
ϕ is the cost function cD from the previous deﬁnition with domain
restricted to CD
ϕ .
The set of feasible solutions Fϕ, the neighbourhood function Nϕ and the answer
set Aϕ also implicitly include parameter variables ⃗a. They are deﬁned by induction
on the complexity of ϕ.
If ϕ is in sΣb
0 ∪sΠb
0 we deﬁne
Fϕ := {⟨⟩}
Nϕ(⟨⟩) := ⟨⟩
⟨⟩∈Aϕ : ⇔ϕ
Let ϕ be in sΣb
k+1 \ sΠb
k+1 of the form (∃x)ψ. ψ has (potentially) one free
variable in addition to ϕ which is x. Thus, when deﬁning F, N and A in the

96
Arnold Beckmann and Samuel R. Buss
following, their ﬁrst argument will denote the value for this additional parameter.
We will make this dependency explicit by writing ψx in the index of F, N, A, resp.
We deﬁne
Fϕ := {⟨d | s⟩∈Cϕ : s ∈Fψx(d) ∧(∀x < d)¬ψ(x)}
Nϕ(⟨d | s⟩) :=
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
⟨d | Nψx(d, s)⟩
if d < D ∧Nψx(d, s) ̸= s
⟨d | s⟩
if d < D ∧Nψx(d, s) = s ∈Aψx(d)

d + 1 | 0k
if d < D ∧Nψx(d, s) = s /∈Aψx(d)
⟨d | s⟩
if d = D
⟨d | s⟩∈Aϕ ⇔d < D
For ϕ ∈sΠb
k+1 \ sΣb
k+1 we deﬁne
Fϕ := F¬ϕ
Nϕ(s) := N¬ϕ(s)
Aϕ := Cϕ \ A¬ϕ
The latter choices imply for ϕ of the form (∀x)ψ that
Fϕ := {⟨d | s⟩∈Cϕ : s ∈Fψx(d) ∧(∀x < d)ψ(x)}
Nϕ(⟨d | s⟩) :=
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
⟨d | Nψx(d, s)⟩
if d < D ∧Nψx(d, s) ̸= s
⟨d | s⟩
if d < D ∧Nψx(d, s) = s /∈Aψx(d)

d + 1 | 0k
if d < D ∧Nψx(d, s) = s ∈Aψx(d)
⟨d | s⟩
if d = D
⟨d | s⟩∈Aϕ ⇔d = D
assuming s ∈Cψ
Deﬁnition 6.11. Let ϕ ∈sΣb
∞, and let SD
ϕ = (Cϕ, Fϕ, Aϕ, Nϕ, cϕ) be the canon-
ical search problem for ϕ. Let k be the rank of ϕ. We extend the deﬁnition of Fϕ,
Aϕ and Nϕ to sequences of length ℓ> k in the obvious way:
⟨u1, . . . , uℓ⟩∈Fϕ
:⇐⇒
⟨u1, . . . , uk⟩∈Fϕ
⟨u1, . . . , uℓ⟩∈Aϕ
:⇐⇒
⟨u1, . . . , uk⟩∈Aϕ
and if Nϕ(⟨u1, . . . , uk⟩) = ⟨v1, . . . , vk⟩then
Nϕ(⟨u1, . . . , uℓ⟩)
:=
⟨v1, . . . , vk, uk+1, . . . , uℓ⟩.

Deﬁnable Search Problems in Bounded Arithmetic
97
(0, 0)
(0, D)
(D, 0)
(D, D)
Cϕ:
Nψ(d1)(e1) ̸= e1
(d1, e1)
(d1, e1+1)
(d2, e2)
Nψ(d2)(e2) = e2 ∈Aψ(d2)
(d3, e3)
(d3 + 1, 0)
Nψ(d3)(e3) = e3 /∈Aψ(d3)
(D, e4)
Nϕ
Nϕ
Nϕ
Nϕ
Nϕ
Nϕ
Figure 1: The canonical search problem Sϕ = (Cϕ, Fϕ, Aϕ, Nϕ, cϕ) for ϕ in
sΣb
2 \ sΠb
2 of the form (∃x)ψ(x), and D a strict upper bound for ϕ. The con-
ﬁguration space Cϕ is a grid consisting of all points ⟨d, e⟩with 0 ≤d ≤D and
0 ≤e ≤D. Nϕ is deﬁned for all points on the grid. Its behaviour at ⟨d, e⟩depends
on the behaviour of the canonical search problem for Sψx(d) = Sψ(d), in particular
on Nψx(d, e) = Nψ(d)(e) and Aψx(d) = Aψ(d).

98
Arnold Beckmann and Samuel R. Buss
To explain the previous two deﬁnitions let us calculate Fϕ for ϕ of rank k > 0:
For k = 1 and ϕ ≡(∃x)β(x) we have ⟨u | s⟩∈Fϕ ≡(∀x<u)¬β(x). If k = 2
and ϕ ≡(∃x)(∀y)β(x, y) then ⟨u, v | s⟩∈Fϕ has the form
(∀x<u)(∃y)¬β(x, y) ∧(∀y<v)β(u, y) .
If k = 3 and ϕ ≡(∃x)(∀y)(∃z)β(x, y, z) we have that ⟨u, v, w | s⟩∈Fϕ is of the
form
(∀x<u)(∃y)(∀z)¬β(x, y, z) ∧(∀y<v)(∃z)β(u, y, z) ∧(∀z<w)¬β(u, v, z) .
For the general case assume ϕ ≡(∃x)(∀y)ψ(x, y). Then ⟨u, v | s⟩∈Fϕ has the
form
(∀x<u)(∃y)¬ψ(x, y) ∧(∀y<v)ψ(u, y) ∧s ∈Fψxy(u, v) .
Observation 6.12. Let ϕ ∈sΣb
∞, and let k be the rank of ϕ according to Deﬁni-
tion 2.6. Let Sϕ = (Cϕ, Fϕ, Aϕ, Nϕ, cϕ) be the canonical search problem for ϕ.
Then, Cϕ, Aϕ, Nϕ and cϕ are polynomial time computable, and Fϕ is in the level
Πp
k of the polynomial time hierarchy. More precisely, we observe that s ∈Cϕ(a),
s ∈Aϕ(a) and Nϕ(a, s) = s′ can be deﬁned by sΣb
0-formulas, cϕ(a, s) can be
deﬁned by LBA-terms, and s ∈Fϕ(a) is equivalent to a sΠb
k-formula in BASIC.
Proposition 6.13. Let ϕ ∈sΣb
∞\ sΣb
1 ∪sΠb
1, let D an s.u.b. for ϕ, and let
SD
ϕ = (CD
ϕ , F D
ϕ , AD
ϕ , N D
ϕ , cD
ϕ ) be the canonical search problem for ϕ. The fol-
lowing is provable in BASIC. Assume N D
ϕ (s) = s, then either s1 = D, or s1 < D
and s2 = D.
Proof. It is enough to consider ϕ of the form (∃x)(∀y)ψ(x, y), because we have
N D
¬ϕ(s) = N D
ϕ (s). Let s = ⟨d, e | s′⟩and assume N D
ϕ (s) = s and d ̸= D, then
we have to show d < D and e = D. The deﬁnition of N D
ϕ implies d < D and
⟨e | s′⟩∈AD
(∀y)ψ(x,y)(d). By deﬁnition of AD
(∀y)ψ(d,y) the latter shows e = D.
Corollary 6.14. Let SD
ϕ = (CD
ϕ , F D
ϕ , AD
ϕ , N D
ϕ , cD
ϕ ) be the canonical search prob-
lem for a formula ϕ ∈sΣb
∞, and D an s.u.b. for ϕ. Then, the following are provable
in BASIC:
1. If rk(ϕ) ≥2, Nϕ(s) = s, and either tp(ϕ) = 
 and s ∈Aϕ, or tp(ϕ) = 	
and s /∈Aϕ, then s2 = D.
2. If rk(ϕ) ≥1, Nϕ(s) = s, and either tp(ϕ) = 
 and s /∈Aϕ, or tp(ϕ) = 	
and s ∈Aϕ, then s1 = D.

Deﬁnable Search Problems in Bounded Arithmetic
99
Proof. For both 1. and 2., it is enough to consider the case tp(ϕ) = 
 as the
“either.. . or” cases are equivalent due to the deﬁnition of Aϕ. For 1. we observe
that the deﬁnition of s ∈Aϕ implies s1 < D. Thus, s2 = D by the previous
Proposition. In case 2. the deﬁnition of s /∈Aϕ implies s1 ̸< D, hence s1 = D.
The next proposition validates that canonical search problems correctly deter-
mine truth.
Proposition 6.15. Let ϕ ∈sΣb
∞, and let Sϕ = (Cϕ, Fϕ, Aϕ, Nϕ, cϕ) be the canon-
ical search problem for ϕ. The following is provable in S1
2:
Nϕ(s) = s ∧s ∈Fϕ
⇒
(ϕ
⇔
s ∈Aϕ)
Proof. The proof is by induction on the rank of ϕ. It is enough to consider ϕ of
the form (∃x)ψ(x), because the assertion is trivial for ϕ of rank 0, and for ϕ of the
form (∀x)ψ(x) we can use Nϕ = N¬ϕ, Fϕ = F¬ϕ, and Aϕ = Cϕ \ A¬ϕ.
We argue in S1
2. Let s = ⟨d | s′⟩and assume Nϕ(s) = s ∈Fϕ. Assume
ﬁrst d < D, hence s ∈Aϕ. We will show ψ(d), which implies ϕ. By deﬁni-
tion of Nϕ we have Nψx(d, s′) = s′ and s′ ∈Aψx(d). The deﬁnition of Fϕ
shows s′ ∈Fψx(d). If rk(ϕ) = 1 we have s′ = ⟨⟩. Thus, s′ ∈Aψx(d) implies
⟨⟩∈Aψ(d), hence ψ(d). For rk(ϕ) > 1 we obtain by induction hypothesis ψ(d)
iff s′
1 = D. As s1 = d < D, Proposition 6.13 shows s′
1 = s2 = D. Hence ψ(d).
Now assume d = D, hence s /∈Aϕ. We have (∀x < D)¬ψ(x) by deﬁnition of
Fϕ. As D is s.u.b. for ϕ, the latter shows (∀x)¬ψ(x) (this is the only place where
we need S1
2). Hence ¬ϕ.
The ﬁnal proposition states that canonical search problems have the properties
of search problems.
Proposition 6.16. Let Sϕ = (Cϕ, Fϕ, Aϕ, Nϕ, cϕ) be the canonical search prob-
lem for a formula ϕ ∈sΣb
∞of rank k. The following can be proven in S1
2.
1. 0k ∈Fϕ.
2. If s ∈Fϕ, then Nϕ(s) ∈Fϕ
3. If Nϕ(s) = s′ and s ̸= s′, then cϕ(s′) < cϕ(s).
Proof. The ﬁrst and third assertion follow immediately from the deﬁnitions, and
can be proven already in BASIC. The proof of the second assertion is by induction
on the rank of ϕ. The non-trivial cases are that ϕ is of the form (∃x)ψ(x), and
that s = ⟨d | s′⟩and Nϕ(s) ̸= s. If Nϕ(s) = ⟨d | Nψx(d, s′)⟩the assertion follows
immediately from induction hypothesis. In case Nϕ(s) =

d + 1 | 0k
the assertion
follows using Proposition 6.15 to ensure (∀x<d+1)ψ(x).

100
Arnold Beckmann and Samuel R. Buss
7 Search problems deﬁned by proof notations
We are now ready to put things together: We ﬁrst deﬁne a general local search prob-
lem based on proof notations which will be used in Subsection 7.2 to provide the
characterisation of Σb
ℓ+1-deﬁnable search problems in Tk+1
2
in terms of Πb
k-PLS
problems with Σb
ℓ-goals.
7.1 Parameterised Local Search Problems based on Proof Notations
Let us start by describing the idea for computing witnesses using proof trees. As-
sume we have a Tk+1
2
-proof of a formula (∃y)ϕ(y) in Σb
ℓ+1 and we want to com-
pute an n such that ϕ(n) is true — in case we are interested in deﬁnable search
problems, such a situation is obtained from a proof of (∀x)(∃y)ϕ(x, y) by invert-
ing the universal quantiﬁer to some a ∈N. Assume further, we have applied some
proof theoretical transformations to obtain a BA∞derivation d0 of (∃y)ϕ(y) with
sΣb
0-crk(d0) ≤k. Then we can deﬁne a path through d0, represented by sub-
derivations d1, d2, d3 . . . , such that
• dj+1 = dj(ι) for some ι ∈| last(dj)|
• Γ(dj) = (∃y)ϕ(y), Γj where all formulas A ∈Γj are false and in sΣb
k ∪sΠb
k.
Such a path must be ﬁnite as hgt(dj) is strictly decreasing. Say it ends with some
dℓ. In this situation we must have that last(dℓ) = 
k
(∃y)ϕ(y) and that ϕ(k) is true.
Hence we found our witness.
The path which we have just described can be viewed as the canonical path
through a related local search problem. Before explaining this, let us ﬁx the notion
of a local search problem.
Deﬁnition 7.1. An instance of a local search problem consists of a set F of possible
solutions, a goal set G which is a subset of F, an initial value d ∈F, a cost
function c: F →N, and a neighbourhood function N : F →F which satisfy that
c(N(d)) < c(d) if N(d) ̸= d, and that d ∈G iff d ∈F and N(d) = d. A solution
to a local search problem, called a local optimum, is any d ∈G.
Observe that the ingredients of a local search problem guarantee the existence of
a local optimum, by starting with the initial value and iterating the neighbourhood
function (this deﬁnes the canonical path through the search problem.)
Now we deﬁne a local search problem whose canonical path is the one de-
scribed above.
The set F of possible solutions is deﬁned as the set of all
BA∞-derivations d which have the properties that sΣb
0-crk(d0) ≤k, and that all

Deﬁnable Search Problems in Bounded Arithmetic
101
formulas A ∈Γ(d) \ {(∃y)ϕ(y)} are false and in sΣb
k∪sΠb
k. The cost of a possible
solution d ∈F is given by the height hgt(d) of the proof tree d. We have already
ﬁxed some initial value d0 ∈F. The neighbourhood function N : BA∞→BA∞
is deﬁned by case distinction on the shape of last(d) for d ∈F:
• last(d) = AxA cannot occur as all atomic formulas in Γ(d) are false by deﬁ-
nition of F.
• last(d) = 	
A0 ∧A1, then A0 ∧A1 must be false, hence some of A0, A1 must
be false. Let N(d) := d(0) if A0 is false, and d(1) otherwise.
• last(d) = 
k
A0 ∨A1, then A0 ∨A1 must be false, hence both A0, A1 must be
false. Let N(d) := d(0).
• last(d) = 	
(∀x)A(x). As (∀x)A(x) is false there is some i such that A(i) is
false. Let N(d) := d(i).
• last(d) = 
k
(∃x)A(x). If (∃x)A(x) is different from (∃y)ϕ(y) then (∃x)A(x)
must be false; let N(d) := d(0). Otherwise, if ϕ(k) is false let N(d) = d(0),
and if it is true let N(d) = d. Observe that in the latter case we found our
witness.
• last(d) = CutC. If C is false let N(d) := d(0), otherwise let N(d) := d(1).
Obviously, this deﬁnes a local search problem according to Deﬁnition 7.1. As re-
marked above, a local optimal solution to the search problem allows us to determine
a witness.
The previous description covers the main idea for deﬁning search problem via
proof notations. It is not exactly the version we are looking for, as we want to have
neighbourhood functions which are polynomial time computable, but the one that
we describe above has to decide sΣb
k−1-formulas (in case of a cut) and maintain
in some way the promise that the endsequent of elements in F consists of false
formulas besides (∃y)ϕ(y). The adjustment we have to make is to incorporate the
canonical search problems for deciding formulas from the previous section, instead
of deciding formulas directly. We also have to store promised witnesses for false
sΠb
k formulas in the endsequent of derivations, in order to obtain the optimal com-
plexity for the set of feasible solutions. We do this by extending the set of possible
solutions in the forthcoming Deﬁnition 7.3 to triples of the form ⟨d, f, s⟩, where d
denotes a BA∞-derivations as above, f stores witnesses of ∀quantiﬁers, and s is a
position in a potential canonical search problems for deciding some formula related
to the last inference of d.

102
Arnold Beckmann and Samuel R. Buss
In the next deﬁnition we ﬁx some canonical choice function for the outermost
quantiﬁer of a sharply bounded formula. This is followed by the formal deﬁnition
of parameterised local search problems, given as the adjustment of the local search
problem described above.
Deﬁnition 7.2. Let ϵ denote the following choice function: For ψ ∈sΠb
0, let
ϵ(ψ) = j for the smallest j such that ψ[j] is false, and let ϵ(ψ) = 0 in all other
cases, e.g., if such a j cannot be found, or ψ /∈sΠb
0, or ψ[j] is not deﬁned, etc.
Deﬁnition 7.3. We deﬁne a local search problem L given by the following param-
eters:
• Complexity levels ℓ, k with 0 ≤ℓ≤k, denoting the formula classes sΣb
ℓand
sΣb
k.
• A BA⋆-derivation ¯h.
We deﬁne an initial value function h• : N →CHBA
based on ¯h, which maps a →ha := E¯h(a/x).
• A formula (∃y)ϕ(x, y) ∈sΣb
ℓ+1.
These parameters have to satisfy the following, provably in S1
2: for a ∈N,
• Γ(ha) ⊆{(∃y)ϕ(a, y)},
• sΣb
0-crk(ha) ≤k,
• o(ha) = 2|a|O(1),
• ϑ(ha) = |a|O(1).
We denote such a parametrisation by L = ⟨ℓ, k, ¯h, (∃y)ϕ(x, y)⟩.
An instance of L is given by a ∈N which deﬁnes the following functions and
relations of a local search problem:
• Let Φ be deco(¯h) together with the closure of deco(¯h) ∩Δ0 under negation
and taking subformulas.
• Da := bd(ha) + 1.
Da deﬁnes a strict upper bound for all formulas in
Φmax(a,bd(ha)) in the sense of Deﬁnition 6.6.
• The (ﬁnite) set of potential conﬁgurations C(a) consists of those pairs (h, f)
of h ∈CHBA and f : A →{0, . . . , Da −1} for some ﬁnite subset A of FBA,
which satisfy:
1. Γ(h) \ {(∃y)ϕ(a, y)} ⊂sΣb
k ∪sΠb
k,

Deﬁnable Search Problems in Bounded Arithmetic
103
2. dom(f) consists of all ψ ∈Γ(h) with tp(ψ) = 	 and ψ /∈sΠb
0,
3. sΣb
0-crk(h) ≤k,
4. o(h) ≤o(ha),
5. bd(h) ≤bd(ha),
6. ϑ(h) ≤ϑ(ha),
7. deco(h) ⊆Φmax(a,bd(ha)).
• The set of conﬁgurations is given by
C(a) := {d: d < Da} ∪

⟨h, f, s⟩: (h, f) ∈C(a) and s ∈Ck,Da

.
• The initial value function is given by i(a) :=

ha, ∅, 0k
.
• The cost function is deﬁned as
c(a, ⟨h, f, s⟩) := o(h) · (Da + 1)k + c(s)
and
c(a, d) := 0
for d < Da.
• The neighbourhood function is deﬁned by case distinction as follows:
for d < Da let N(a, d) := d;
for tp(h) = Axψ let N(a, ⟨h, f, s⟩) := ⟨h, f, s⟩;
for tp(h) = Rep let N(a, ⟨h, f, s⟩) :=

h[0], f r, 0k
, where f r denotes the
restriction of f to Γ(h[0]) — similar in future cases;
for tp(h) = 
i
ψ let N(a, ⟨h, f, s⟩) be deﬁned as
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩

h[0], f r, 0k
if ψ ∈sΣb
0,

h, f, Nψ[i](s)

if ψ /∈sΣb
0, Nψ[i](s) ̸= s,

h[0], f ′, 0k
if ψ /∈sΣb
0, Nψ[i](s) = s, s /∈Aψ[i]
and f ′ = (f ∪{ψ[i] →s1})r if ψ /∈sΣb
1
or f′ = fr if ψ ∈sΣb
1,
⟨h, f, s⟩
if ψ /∈sΣb
0, ψ ̸= (∃y)ϕ(a, y),
Nψ[i](s) = s, s ∈Aψ[i],
i
if ψ = (∃y)ϕ(a, y), Nϕ(a,i)(s) = s, s ∈Aϕ(a,i) ;

104
Arnold Beckmann and Samuel R. Buss
for tp(h) = 	
ψ let
N(a, ⟨h, f, s⟩) :=

h[f(ψ)], f r, 0k
if ψ /∈sΠb
0,

h[ϵ(ψ)], f r, 0k
if ψ ∈sΠb
0 ;
and for tp(h) = Cutψ let N(a, ⟨h, f, s⟩) be deﬁned as
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎩
⟨h, f, Nψ(s)⟩
if Nψ(s) ̸= s,

h[1], fr, 0k
if Nψ(s) = s, s ∈Aψ,

h[0], f ′, 0k
if Nψ(s) = s, s /∈Aψ
and f ′ = (f ∪{ψ →s1})r if ψ /∈sΠb
0
or f′ = fr if ψ ∈sΠb
0 .
• The set of feasible solutions F(a) is given by those ⟨h, f, s⟩which satisfy
– ⟨h, f, s⟩∈C(a) and tp(h) ̸= Axψ;
– for all ψ ∈Π := dom(f) we have that ψ[f(ψ)] is false;
– for ψ ∈Σ := Γ(h) \ ({(∃y)ϕ(a, y)} ∪Π) we have that ψ is false;
– tp(h) = Cutψ implies s ∈Fψ;
– tp(h) = 
i
ψ implies s ∈Fψ[i];
together with those d < Da such that ϕ(a, d) holds.
• The goal set G(a) := {d < Da : ϕ(a, d)} ⊂F(a).
We will now argue that the relations and functions deﬁned above deﬁne a
Πb
k-PLS problem with Πb
ℓ-goal according to Deﬁnition 3.2. One of the main con-
siderations for this is to see that the computational complexity of the involved re-
lations and functions fall into the right classes, in particular, that the set of con-
ﬁgurations and the neighbourhood function are polynomial time computable. This
is not difﬁcult to see once we understood how notations for derivations are coded:
any h ∈CHBA is a term of inference symbols, and each inference symbol is given
by its decoration consisting of formulas and terms and numbers — the formulas
and terms have to come from Φ, and the numbers are bounded by max(a, bd(ha)).
Thus, a natural feasible G¨odel numbering of such terms, as deﬁned in [Bus86], will
give us a suitable set of codes on which all necessary functions are easy to compute,
as they all are either performing syntactic checks according to inference symbols
and their decoration, or evaluating (in the case of feasible solutions) formulas in Φ
(which is a ﬁnite set) under a numerical substitution.

Deﬁnable Search Problems in Bounded Arithmetic
105
Proposition 7.4. The local search problem L from Deﬁnition 7.3, parameterised
by ⟨Φ, ℓ, k, h, (∃y)ϕ(x, y)⟩, provides a Πb
k-PLS problem with Πb
ℓ-goal according
to Deﬁnition 3.2.
Proof. As shown in [AB09] the functions a →i(a) = ha, a →bd(ha),
a →o(ha), a →ϑ(ha), and a →deco(ha) are polynomial time computable. Fur-
thermore, the relations CHBA, sΣb
0-crk(h) ≤k, bd(h) ≤m and deco(h) ⊆Φm
are polynomial time computable, and once bd(h) ≤m is established we also can
compute o(h) ≤m′ and then o(h) in polynomial time. Hence, the cost function c
is polynomial time computable. Also, the functions tp(h) and h[i] are polynomial
time computable on CHBA. Using Observation 6.12, this shows that N is polyno-
mial time computable, because the case distinction which deﬁnes N depends only
on essentially ﬁnitely many Nψ: Each such ψ is obtained from a formula in Φ
(which is a ﬁnite set) by substituting constants for free variables.
To check that F ∈Πb
k we look at the critical cases — here we use, similar to the
case above, that the deﬁnition of F depends essentially only on ﬁnitely many Nψ.
“d ∈F(a)”, for d < Da, is a Πb
l -property. The deﬁnition of “(h, f, s) ∈F(a)”
has three critical entries: Observe that Σ∪Π ⊆Γ(h) ⊆deco(h) ⊆Φbd(ha), hence
for ψ ∈Π the condition “ψ[f(ψ)] is false” is a Πb
k−1-property, and for ψ ∈Σ the
condition “ψ is false” is a Πb
k-property; the condition “s ∈Fψ” for ψ of rank ≤k
is Πb
k according to Observation 6.12.
That “s ∈G(a)” is in Πb
ℓis obvious by deﬁnition.
So it remains to show that the properties (3.1)-(3.5) of Deﬁnition 3.2 do hold.
For (3.1), (∀x, s)(s ∈F(x) →|s| ≤d(|x|)), we observe that if (h, f) ∈C(a),
then h is a term built up from inference symbols, the length of the term, i.e. the
number of inference symbols, is ϑ(h) ≤ϑ(ha) = |a|O(1), and each occurring
inference symbol is decorated with expressions from deco(h) ⊆Φmax(a,bd(ha))
with | bd(ha)| = |a|O(1). Thus, the polynomial bound d can be found assuming
a feasible G¨odel numbering as in [Bus86]. Property (3.2), (∀x)(i(x) ∈F(x)), is
obvious. The last one, (3.5),
(∀x, s)(s ∈G(x) ↔(N(x, s) = s ∧s ∈F(x)))
also follows from the deﬁnition. For this, observe that for “←” the premise of
the implication N(x, s) = s ∧s ∈F(x) implies that s cannot be of the form
⟨h, f, s⟩: Assume it is, then either tp(h) = Axψ which would imply ψ ∈Γ(h)
and ψ true, or tp(h) = 
i
ψ, ψ ̸= (∃y)ϕ(a, y), Nψ[i](s) = s, s ∈Aψ[i], and
s ∈F(x) implies s ∈Fψ[i], thus Proposition 6.15 shows ψ[i], hence ψ, is true;
both times we get a contradiction to the fact implied by s ∈F(a) that all formulas
in Γ(h) \ {(∃y)ϕ(a, y)} are false.

106
Arnold Beckmann and Samuel R. Buss
Property (3.3)
(∀x, s)(s ∈F(x) →N(x, s) ∈F(x))
follows by case distinction according to the deﬁnition N(x, s), using the corre-
sponding properties for canonical search problems as shown in Proposition 6.16.
For example, consider the case that s = ⟨h, f, s⟩∈F(x) with tp(h) = 	
ψ
and ψ /∈sΠb
0.
Then N(a, s) =

h[f(ψ)], f r, 0k
and we have to show that
(h[f(ψ)], f r) ∈
C(a).
Let j = f(ψ), then h[j] ⊢≈Γ(h), ψ[j] thus obvi-
ously Γ(h[j]) ⊂sΣb
k ∪sΠb
k.
As tp(ψ) = 	 and ψ ∈sΣb
∞, it follows
that tp(ψ[j]) ̸= 	, thus dom(f r) satisﬁes the property under 2.
We com-
pute that sΣb
0-crk(h[j]) ≤sΣb
0-crk(h) ≤k, that o(h[j]) < o(h) ≤o(ha), that
bd(h[j]) ≤bd(h) ≤bd(ha) by Lemma 5.13, 1., that ϑ(h[j]) ≤ϑ(h) ≤ϑ(ha)
by Theorem 4.16, and that deco(h) ⊆Φmax(a,bd(ha)), j = f(ψ) ≤bd(ha) and
bd(h) ≤bd(ha) together imply
deco(h[j]) ⊆(Φmax(a,bd(ha)))max(bd(ha),bd(h)) = Φmax(a,bd(ha))
by Lemma 5.17, 4.
Other interesting cases occur when s ∈F(x) is of the form s = ⟨h, f, s⟩
with tp(h) = 
i
ψ, ψ /∈sΣb
0 and Nψ[i](s) = s. If s /∈Aψ[i] and ψ /∈sΣb
1,
then N(a, s) =

h[0], f′, 0k
and f ′ = (f ∪{ψ[i] →s1})r.
The condition
⟨h[0], f ′⟩∈C(a) can be shown as before. If ψ[i] ∈dom(f′) we also have to
show that ψ[i][s1] is false. s can be written as ⟨d | s′⟩because rk(ψ) ≥2. As
s ∈F(x) we have s ∈Fψ[i] by deﬁnition of F(x), which implies s′ ∈Fψ[i][d] by
deﬁnition of Fψ[i]. By assumptions we also have Nψ[i](s) = s and s /∈Aψ[i]. As
tp(ψ[i]) = 	, s /∈Aψ[i] shows d < Da, hence both Nψ[i](s) = s and s /∈Aψ[i]
together with the deﬁnition of Nψ[i] show Nψ[i][d](s′) = s′ and s′ /∈Aψ[i][d]. Now
we can conclude using Proposition 6.15 that ψ[i][d] is false.
If s ∈Aψ[i] and ψ ̸= (∃y)ϕ(a, y), then N(x, s) = s and there is nothing to
show.
Finally, if s ∈Aψ[i] and ψ = (∃y)ϕ(a, y), then N(x, s) = i and we have to
show that i < Da and that ϕ(a, i) is true. Lemma 5.13, 2., shows that i < bd(h),
thus i < bd(ha) ≤Da. Again, s ∈F(x) implies s ∈Fψ[i]. Thus the assumptions
Nψ[i](s) = s and s ∈Aψ[i] together with Proposition 6.15 show that ψ[i] is true,
that is ϕ(a, i) is true.
Finally, Property (3.4)
(∀x, s)(N(x, s) = s ∨c(x, N(x, s)) < c(x, s))

Deﬁnable Search Problems in Bounded Arithmetic
107
also follows immediately from the deﬁnitions. Because, for s = ⟨h, f, s⟩with
N(x, s) = ⟨h′, f ′, s′⟩̸= s, either h′ = h[j] for some j, and then o(h′) < o(h), or
h′ = h and s′ = Nψ(s) ̸= s and then c(s′) < c(s) using Proposition 6.16.
7.2 Σb
ℓ+1-deﬁnable search problems in Tk+1
2
for ℓ≤k
Let 0 ≤ℓ≤k and assume that (∃y)ϕ(x, y) ∈sΣb
ℓ+1 with ϕ ∈sΠb
ℓ, such
that Tk+1
2
⊢(∀x)(∃y)ϕ(x, y).
Inverting the (∀x) quantiﬁer we obtain that
Tk+1
2
⊢(∃y)ϕ(x, y). Applying partial cut-elimination, Theorem 5.11, to this we
obtain some BA⋆-derivation h such that FV(h) ⊆{x}, Γ(h) = {(∃y)ϕ(x, y)},
sΣb
k+1-gcrk(h) = 0, and o(h(a/x)) = |a|O(1).
Let Φ be deco(h) together with the closure of deco(h) ∩Δ0 under negation
and taking subformulas. Then L = ⟨Φ, ℓ, k, h, (∃y)ϕ(x, y)⟩deﬁnes a local search
problem according to Deﬁnition 7.3, because the following are provable in S1
2:
• Γ(ha) = Γ(Eh(a/x)) = Γ(h(a/x)) ⊆Γ(h)(a/x) = {(∃y)ϕ(a, y)}, where
we used Lemma 5.8 for “⊆”;
• sΣb
0-crk(ha) = sΣb
0-crk(Eh(a/x)) = sΣb
0-crk(h(a/x)) ·−1
= sΣb
0-gcrk(h(a/x)) ·−1 = sΣb
0-gcrk(h) ·−1
≤(sΣb
k+1-gcrk(h) + k + 1) ·−1 = k ,
using the properties mentioned directly after Deﬁnition 5.5 for “≤”;
• o(ha) = o(Eh(a/x)) = 2o(h(a/x)) −1 = 2|a|O(1);
• ϑ(ha) = ϑ(Eh(a/x)) = o(h(a/x)) · (ϑ(h(a/x)) + 2)
= |a|O(1) · (|h(a/x)| + 2) = |a|O(1) · (|h| + 2) = |a|O(1) ;
• deco(ha) = deco(Eh(a/x)) = deco(h(a/x)) ⊆Φa, where we have used
Lemma 5.17, 2. for the last inclusion.
By Proposition 7.4, this deﬁnes a search problem in Πb
k-PLS with Πb
ℓ-goal. Thus
we have proven Theorem 3.5, that the Σb
ℓ+1-deﬁnable total search problems in
Tk+1
2
can be characterised by Πb
k-PLS problems with Πb
ℓ-goals. Together with
Theorem 3.4 we obtain a full characterisation of the Σb
ℓ+1-deﬁnable total search
problems in Tk+1
2
:
Corollary 7.5. Let 0 ≤ℓ≤k. The Σb
ℓ+1-deﬁnable total search problems in Tk+1
2
are exactly characterised by Πb
k-PLS problems with Πb
ℓ-goals.

108
Arnold Beckmann and Samuel R. Buss
8 Skolemising Search for Truth
In the remaining sections we will strengthen our results by showing that the prop-
erties (3.1)–(3.5) of Πb
k-PLS problems extracted from Tk+1
2
-proofs according to
Theorem 3.5 can be written in a prenex form which can be skolemised by simple
polynomial time functions, provably in S1
2.
Notation 8.1. We use α, β,...to range over formulas in Σb
0.
Deﬁnition 8.2 (Prenex forms). ψ is called a prenex form of ϕ iff ψ has the shape
(Qz)β for some β ∈Σb
0, such that BASIC ⊢ϕ ↔ψ.
Deﬁnition 8.3 (Simple Skolemisation). Let (Qz)β(x, z) with β ∈Σb
0 be a prenex
form for ϕ(x), where z = [z1, . . . , zk] and Q = [Q1, . . . , Qk]. Let f be some
function symbol. We say that
(∀x)(ϕ(x) →ϕ(f(x)))
admits simple Skolem functions iff there are polynomial time computable functions
f1, . . . , fk such that
(∀x)(∀kz)(β(x, t1, . . . , tk) →β(f(x), t′
1, . . . , t′
k))
is provable in S1
2, where
ti
:=

zi
if Qi = ∃
fi(x, z1, . . . , zi)
otherwise
t′
i
:=

fi(x, z1, . . . , zi)
if Qi = ∃
zi
otherwise
The main result of this section will be to ﬁx a suitable prenex form for s ∈Fϕ in
such a way that the canonical prenex form of
(∀s)(s ∈Fϕ →Nϕ(s) ∈Fϕ)
(8.1)
admits simple Skolem functions — we explain later what we mean by a canonical
prenex form. In the next subsection we ﬁx a suitable prenex form for s ∈Fϕ; that
it enjoys the above mentioned property will be shown later in Theorem 8.5.

Deﬁnable Search Problems in Bounded Arithmetic
109
8.1 A suitable prenex form for s ∈Fϕ
Formulas have many prenex forms. We will now pick a suitable one for the formula
s ∈Fϕ. Remember that we deﬁned the application of the projection function pi to
formal tuples t = [t1, . . . , tk] as pi(t) = [pi(t1), . . . , pi(tk)].
Theorem 8.4. Let ϕ be a strict formula of rank k, and D a s.u.b. for ϕ. Then there
is a sΣb
0-formula γϕ such that the following are provable in BASIC:
1. s ∈Fϕ
⇔
(∀∃kz)γϕ(s, z).
2. (∀s)(∀kz1)(∀kz2)
 	
1≤i,j≤k pj(z1
i ) = pj(z2
i ) ∧γϕ(s, z1) →γϕ(s, z2)

.
3. (∀kz)γϕ(0k, z).
4. If k ≥1 and ϕ ≡(∃∀kz)β(z), then
γϕ(s, z) →(pk(z1) < s1 →¬β(pk(z)))
Observe that pk(z) denotes [pk(z1), . . . , pk(zk)].
5. If k ≥2 and ϕ ≡(∃∀kz)β(z), then
γϕ(s, z) →(pk−1(z1) < s2 →β(s1, pk−1(z⌈k−1)))
Observe that pk−1(z⌈k−1) denotes [pk−1(z1), . . . , pk−1(zk−1)].
Proof. The deﬁnition and proof are by induction on k. If k = 0 let γϕ be the
formula 0 = 0. All properties are obviously satisﬁed.
For k > 0 and ϕ ≡(∀x)β(x) we deﬁne γϕ(s, z) to be the same as γ¬ϕ(s, z).
For k = 1 and ϕ ≡(∃x)β(x) we have ⟨u⟩∈Fϕ ≡(∀x<u)¬β(x). Let
γϕ(⟨u⟩, x) be the formula
(p1(x)<u →¬β(p1(x)))
Again it is easy to see that all properties are satisﬁed.
Although the general inductive case is for k ≥2 already, we write out the cases
for k = 2 and k = 3 explicitly, to make the deﬁnition of γϕ more clear. The
mentioning of “ ∧0 = 0” in the following case is to suit the general inductive
case. Let k = 2 and ϕ ≡(∃x)(∀y)β(x, y). Then ⟨u, v⟩∈Fϕ has the form
(∀x<u)(∃y)¬β(x, y) ∧(∀y<v)β(u, y) .

110
Arnold Beckmann and Samuel R. Buss
Let γϕ(⟨u, v⟩, x, y) be the formula
(p2(x)<u →¬β(p2(x), p2(y)))
∧(p1(x)<v →β(u, p1(x)))
∧0 = 0 .
If k = 3 and ϕ ≡(∃x)(∀y)(∃z)β(x, y, z) we have that ⟨u, v, w⟩∈Fϕ is of the
form
(∀x<u)(∃y)(∀z)¬β(x, y, z) ∧(∀y<v)(∃z)β(u, y, z) ∧(∀z<w)¬β(u, v, z) .
Let γϕ(⟨u, v, w⟩, x, y, z) be the formula
(p3(x)<u →¬β(p3(x), p3(y), p3(z)))
∧(p2(x)<v →β(u, p2(x), p2(y)))
∧(p1(z)<w →¬β(u, v, p1(z))) .
For all cases considered so far it is easy to verify that the assertions 1.–6. are sat-
isﬁed. We have explicitly written out case k = 3 to stress the dependency of
quantiﬁers: It will be crucial for our later developments that the 3rd conjunct uses
“z” and not “x” as a naive inductive continuation might suggest.
For the general inductive case we now assume that ϕ ≡(∃x)(∀y)ψ(x, y),
ψ ≡(∃∀kz)β(x, y, z) and rk(ψ) = k ≥0. Then ⟨u, v | s⟩∈Fϕ has the form
(∀x<u)(∃y)¬ψ(x, y) ∧(∀y<v)ψ(u, y) ∧s ∈Fψxy(u, v)
⇔
(∀x)(∃y)(∀∃kz)(x<u →¬β(x, y, z))
∧(∀y)(∃∀kz)(y<v →β(u, y, z))
∧((∀∃kz)γψxy(u, v, s, z)
⇔
(∀x)(∃y)(∀∃kz)γϕ(⟨u, v | s⟩, x, y, z)
where we deﬁne γϕ(⟨u, v | s⟩, x, y, z) to be the formula
(pk+2(x)<u →¬β(pk+2(x), pk+2(y), pk+2(z)))
∧(pk+1(x)<v →β(u, pk+1(x), pk+1(y), pk+1(z⌈k−1)))
∧γψxy(u, v, s, z) .
This choice of γϕ obviously satisﬁes all assertions.

Deﬁnable Search Problems in Bounded Arithmetic
111
8.2 A simple Skolemisation for (∀s)(s ∈Fϕ →Nϕ(s) ∈Fϕ)
Now that we have ﬁxed prenex forms for s ∈Fϕ, we choose a suitable prenex form
of (∀s)(s ∈Fϕ →Nϕ(s) ∈Fϕ) in a canonical way:
(∀s)(s ∈Fϕ →Nϕ(s) ∈Fϕ)
⇔
(∀s)

(∀∃kz)γϕ(s, z) →(∀∃k¯z)γϕ(Nϕ(s),¯z)

⇔
(∀s)(∀¯z1)(∃z1)(∀z2)(∃¯z2)(∀¯z3)(∃z3) · · ·

γϕ(s, z) →γϕ(Nϕ(s),¯z)

The latter is the prenex form which we ﬁx.
Theorem 8.5. Let ϕ be a strict formula of rank k, and D a s.u.b for ϕ. The prenex
form which we ﬁxed for (∀s)(s ∈Fϕ →Nϕ(s) ∈Fϕ) admits simple Skolem
functions.
Proof. We have to show that there are polynomial time computable functions
f1(s, z1), f2(s, z1, z2), f3(s, z1, z2, z3), . . .
such that
(∀s, z1, z2, z3, . . . )

γϕ(s, f1(s, z1), z2, f3(s, z1, z2, z3), z4, . . . )
→γϕ(Nϕ(s), z1, f2(s, z1, z2), z3, f4(. . . , z4), . . . )

.
(8.2)
In the following we will suppress the argument s from the Skolem func-
tions. The Skolem functions may also depend on further parameters of ϕ which
we also will not mention.
We say that the i-th slice of f1(z1) (f2(z1, z2),
f3(z1, z2, z3), ...respectively) is chosen canonically if pi(f1(z1)) = pi(z1)
(pi(f2(z1, z2)) = pi(z2), pi(f3(z1, z2, z3)) = pi(z3), ...respectively.) Choosing
the i-th slice of f1, f2, f3, . . . canonically implies that
pi([f1(z1), z2, f3(z1, z2, z3), z4, . . .])
= pi([z1, z2, z3, z4, . . .])
= pi([z1, f2(z1, z2), z3, f4(z1, z2, z3, z4), . . .])
We now deﬁne the Skolem functions and prove (8.2) by induction on k.

112
Arnold Beckmann and Samuel R. Buss
If k = 0 there is nothing to show. If k = 1 and ϕ ≡(∃x)β(x) we choose the
ﬁrst slice of f1 canonically. Then (8.2) is equivalent to
(∀u, x)(γϕ(⟨u⟩, f1(x)) →γϕ(Nϕ(⟨u⟩), x))
⇔
(∀u, ¯u, x)

Nϕ(⟨u⟩) = ⟨¯u⟩∧(p1(x) < u →¬β(p1(x)))
→(p1(x) < ¯u →¬β(p1(x)))

The non-trivial case is when Nϕ(⟨u⟩) = ⟨¯u⟩, ¯u = u+1 and p1(x) = u. By
deﬁnition of Nϕ this implies ¬β(u), hence (8.2) follows.
For the inductive case we consider ϕ ≡(∃x)(∀y)ψ(x, y) such that ψ(x, y) is of
the form (∃∀kz)β(x, y, z) with k ≥0. Then (8.2) is equivalent to
(∀u, v, ¯u, ¯v, s,¯s, z1, z2, . . . )

Nϕ(⟨u, v | s⟩) = ⟨¯u, ¯v |¯s⟩
∧(pk+2(f1(z1))<u
→¬β(pk+2([f1(z1), z2, f3(z1, z2, z3), z4, . . .])))
∧(pk+1(f1(z1))<v →β(u, pk+1([f1(z1), z2, f3(. . . ), . . .])))
∧γψxy(u, v, s, f3(z1, z2, z3), z4, . . . )
→(pk+2(z1)<¯u →¬β(pk+2([z1, f2(z1, z2), z3, f4(. . . ), . . .])))
∧(pk+1(z1)<¯v →β(¯u, pk+1([z1, f2(z1, z2), z3, . . .])))
∧γψxy(¯u, ¯v,¯s, z3, f4(z1, z2, z3, z4), . . . )

(8.3)
Let u, v, ¯u, ¯v, s,¯s, z1, z2, z3, . . . be given with Nϕ(⟨u, v | s⟩) = ⟨¯u, ¯v |¯s⟩. The
possible cases for Nϕ are that Nϕ(⟨u, v | s⟩) = ⟨u, v | s⟩which is trivial, or that
Nϕ(⟨u, v | s⟩) ̸= ⟨u, v | s⟩, in which case we distinguish the following three sub-
cases according to the deﬁnition of Nϕ:
1. Nψxy(u, v, s) = s′ ̸= s, thus
Nϕ(⟨u, v | s⟩) = ⟨u, v | s′⟩.
2. Nψxy(u, v, s) = s and s ∈Aψxy(u, v), thus
Nϕ(⟨u, v | s⟩) =

u, v + 1 | 0k
.
3. Nψxy(u, v, s) = s and s /∈Aψxy(u, v), thus
Nϕ(⟨u, v | s⟩) =

u + 1, 0 | 0k
.

Deﬁnable Search Problems in Bounded Arithmetic
113
As Nψxy and Aψxy are polynomial time computable, and u, v, ¯u, ¯v, s,¯s are pa-
rameters to all Skolem functions, we can deﬁne the Skolem functions by case dis-
tinction according to the above three cases.
Case 1. We have ¯u = u, ¯v = v, ¯s = s′. By induction hypothesis there are
f3, f4, . . . such that
γψxy(u, v, s, f3(z1, z2, z3), z4, . . . )
→γψxy(u, v, s′, z3, f4(z1, z2, z3, z4), . . . )
where the functions do not yet depend on z1, z2. By Deﬁnition 8.4, 2. this still
holds if we modify slice k + 1 and k + 2 of f3, f4, . . . . We choose slices k + 1 and
k + 2 of f1, f2, f3, f4, . . . canonically. Then (8.3) turns into
(pk+2(z1)<u →¬β(pk+2([z1, z2, z3, . . .])))
∧(pk+1(z1)<v →β(u, pk+1([z1, z2, z3, . . .])))
∧γψxy(u, v, s, f3(z1, z2, z3), z4, . . . )
→(pk+2(z1)<u →¬β(pk+2([z1, z2, z3, . . .])))
∧(pk+1(z1)<v →β(u, pk+1([z1, z2, z3, . . .])))
∧γψxy(u, v, s′, z3, f4(z1, z2, z3, z4), . . . )
which is obviously satisﬁed using the induction hypothesis.
Case 2. We have ¯u = u, ¯v = v+1, and ¯s = 0k. Observe that γψxy(u, v+1, 0k, . . . )
is always true by Theorem 8.4, 3. We choose slice k+2 of the Skolem functions
canonically. Thus, (8.3) follows from
(pk+1(f1(z1)) < v →β(u, pk+1([f1(z1), z2, f3(. . . ), . . .])))
∧γψxy(u, v, s, f3(z1, z2, z3), z4, . . . )
→(pk+1(z1) < v + 1 →β(u, pk+1([z1, f2(z1, z2), z3, . . .])))
(8.4)
If pk+1(z1) ̸= v choose all slices of Skolem functions canonically, then (8.4) is
obviously satisﬁed.
Now assume pk+1(z1) = v. If k = 0 we choose all slices of Skolem functions
canonically. Then (8.4) is equivalent to β(u, v) which is satisﬁed, because we have
by construction of Nϕ that s ∈Aβ(x,y)xy(u, v), which implies that β(u, v) is true.
If k ≥1, we choose Skolem functions in the following way:
pk+1(f2(z1, z2)) = s1
pk−1(f3(z1, z2, z3)) = pk+1(z3)
pk+1(f4(. . . , z4)) = pk−1(z4)
pk−1(f5(. . . , z5)) = pk+1(z5)
pk+1(f6(. . . , z6)) = pk−1(z6)
. . .

114
Arnold Beckmann and Samuel R. Buss
and all other slices canonically. Assuming the antecedent of (8.4) we have to show
β(u, v, s1, pk+1(z3), pk−1(z4), pk+1(z5), . . . ).
If k = 1, the deﬁnition of Nϕ shows s ∈A(∃z)β(x,y,z)(u, v), which by construc-
tion implies that β(u, v, s1) is true.
In case k ≥2 we obtain from Theorem 8.4, 5 that
γψxy(u, v, s, t) →(pk−1(t1) < s2 →β(u, v, s1, pk−1(t⌈k−1)))
for t = [f3(z1, z2, z3), z4, f5(. . . ), . . .]. Together with the antecedent of (8.4) this
implies
pk−1(f3(z1, z2, z3)) < s2 →β(u, v, s1, pk−1([f3(z1, z2, z3), z4, . . .])) .
By our choice of Skolem functions the latter simpliﬁes to
pk+1(z3) < s2 →β(u, v, s1, pk+1(z3), pk−1(z4), pk+1(z5), . . . ) .
As s ∈Aψxy(u, v) and tp(ψ) = 
 we have s2 = D by Corollary 6.14, thus
β(u, v, s1, pk+1(z3), pk−1(z4), pk+1(z5), . . . ) is satisﬁed.
Case 3. We have ¯u = u + 1, ¯v = 0 and ¯s = 0k. Observe that the formula
γψxy(u + 1, 0, 0k, . . . ) is always true by Theorem 8.4, 3. Thus, (8.3) follows from
(pk+2(f1(z1)) < u →¬β(pk+2([f1(z1), z2, f3(. . . , z3), . . .])))
∧γψxy(u, v, s, f3(z1, z2, z3), z4, . . . )
→(pk+2(z1) < u + 1 →¬β(pk+2([z1, f2(z1, z2), z3, . . .])))
(8.5)
If pk+2(z1) ̸= u choose all slices of Skolem functions canonically, then (8.5) is
obviously satisﬁed.
Now assume pk+2(z1) = u. We choose Skolem functions in the following way:
pk+2(f2(z1, z2)) = v
pk(f3(z1, z2, z3)) = pk+2(z3)
pk+2(f4(. . . , z4)) = pk(z4)
pk(f5(. . . , z5)) = pk+2(z5)
pk+2(f6(. . . , z6)) = pk(z6)
. . .
and all other slices canonically. Assuming the antecedent of (8.5) we thus have to
show ¬β(u, v, pk+2(z3), pk(z4), pk+2(z5), . . . ).
If k = 0, the deﬁnition of Nϕ shows s /∈Aβ(x,y)(u, v) which by construction
implies that ¬β(u, v) is true.
In case k ≥1 we obtain from Theorem 8.4, 4 that
γψxy(u, v, s, t) →(pk(t1) < s1 →¬β(u, v, pk(t)))

Deﬁnable Search Problems in Bounded Arithmetic
115
for t = [f3(z1, z2, z3), z4, f5(. . . ), . . .]. Together with the antecedent of (8.5) this
implies
pk(f3(z1, z2, z3)) < s1 →¬β(u, v, pk([f3(z1, z2, z3), z4, . . .])) .
By our choice of Skolem functions the latter simpliﬁes to
pk+2(z3) < s1 →¬β(u, v, pk+2(z3), pk(z4), pk+2(z5), . . . ) .
As s /∈Aψxy(u, v) and tp(ψ) = 
 we have s1 = D by Corollary 6.14, thus the
latter implies ¬β(u, v, pk+2(z3), pk(z4), pk+2(z5), . . . ).
Deﬁnition 8.6. Let ϕ be a strict formula of rank k, and D a s.u.b. for ϕ. We extend
γϕ from Deﬁnition 8.4 to sequences of length ℓ> k in the obvious way:
γϕ(⟨u1, . . . , uℓ⟩, z)
:⇐⇒
γϕ(⟨u1, . . . , uk⟩, z) .
9 Skolemising Πb
k-PLS Conditions
We have seen in Proposition 7.4 that the local search problem L parameterised
by ⟨Φ, ℓ, k, h, (∃y)ϕ(x, y)⟩deﬁnes a Πb
k-PLS problem with Πb
ℓ-goal. In this sec-
tion, we are going to show that the Πb
k-PLS conditions (3.1)-(3.5) for L can be
skolemised by simple polynomial time Skolem functions. For the rest of this sec-
tion, we assume the parametrisation for L is ﬁxed.
Deﬁnition 9.1. For each strict formula we ﬁx a notation of its syntactic form. Let
k = rk(ψ) and choose βψ(z1, . . . , zk) ∈sΣb
0 ∪sΠb
0 such that the following holds:
If tp(ψ) = 
 then ψ ≡(∃∀kz)βψ(z); if tp(ψ) = 	 then ψ ≡(∀∃kz)βψ(z). Further
parameters to ψ may be denoted as convenient.
We are now going to ﬁx a suitable prenex form of s ∈F(a), which will then
be used to show that the Πb
k-PLS conditions (3.1)-(3.5) admit simple Skolem func-
tions.
First, let us bring the formula s ∈F(a) into a more readable form: s ∈F(a) is
equivalent to

s <Da ∧ϕ(a, s)

∨

s ≥Da ∧s = ⟨h, f, s⟩∧s ∈C(a) ∧tp(h) ̸= Axψ
∧(∀σ)

σ = ⟨1, ψ, ν⟩∧Cond1(s, ψ, ν) →¬ψ[f(ψ)]

∧

σ = ⟨2, ψ, ν⟩∧Cond2(s, ψ, ν) →¬ψ

∧

σ = ⟨3, ψ, ν⟩∧Cond3(s, ψ, ν) →s ∈Fψ
  
using the following abbreviations:

116
Arnold Beckmann and Samuel R. Buss
• Cond1(⟨h, f, s⟩, ψ, ν) expresses
ν = rk(ψ) ∧ψ ∈dom(f)
• Cond2(⟨h, f, s⟩, ψ, ν) expresses
ν = rk(ψ) ∧ψ ∈Γ(h) \

dom(f) ∪{(∃y)ϕ(a, y)}

• Cond3(⟨h, f, s⟩, ψ, ν) expresses
ν = rk(ψ) ∧

tp(h) = Cutψ ∨

tp(h) = 
i
χ ∧ψ = χ[i]

To increase readability, we have included additional informal parameters as in
“s = ⟨h, f, s⟩”, which, when making everything formal, would have to be replaced
by appropriate projections, e.g. “h” by “p1(s)” etc.
The occurrence of ν is currently superﬂuous but will play a role later. The con-
ditions s ∈C(a) and Cond1 to Cond3 are obviously polynomial time computable
and thus can be expressed by sharply bounded formulas. Thus, their exact shape
is irrelevant for determining a suitable prenex form. The evaluation of formulas
¬ψ[f(ψ)] and ¬ψ can be expressed because each ψ has to be a numerical substitu-
tion of a formula from Φ which is a ﬁnite set.
We continue to determine a suitable prenex form of s ∈F(a). Using the suitable
prenex form which we have ﬁxed for s ∈Fψ in Section 8, and the notation ﬁxed in
Deﬁnition 9.1, we transform s ∈F(a) equivalently into

s < Da ∧(∀∃ℓz)βϕ(a, s, z)

∨

s ≥Da ∧s = ⟨h, f, s⟩∧s ∈C(a) ∧tp(h) ̸= Axψ ∧(∀σ)


σ = ⟨1, ψ, ν⟩∧Cond1(s, ψ, ν) →¬

(∀∃νz)βψ(z)[f(ψ)]
 
∧

σ = ⟨2, ψ, ν⟩∧Cond2(s, ψ, ν) →¬(∃∀νz)βψ(z)

∧

σ = ⟨3, ψ, ν⟩∧Cond3(s, ψ, ν) →(∀∃νz)γψ(s, z)
  
.
This is equivalent to
(∀σ)(∀∃kz)Ψ(a, s, σ, z)
(9.1)

Deﬁnable Search Problems in Bounded Arithmetic
117
for Ψ(a, s, σ, z) expressing

s < Da ∧βϕ(a, s, pℓ(z⌈ℓ))

∨

s ≥Da ∧s = ⟨h, f, s⟩∧s ∈C(a) ∧tp(h) ̸= Axψ
∧

σ = ⟨1, ψ, ν⟩∧Cond1(s, ψ, ν) →¬βψ(f(ψ), pν−1(z⌈ν−1))

∧

σ = ⟨2, ψ, ν⟩∧Cond2(s, ψ, ν) →¬βψ(pν(z⌈ν))

∧

σ = ⟨3, ψ, ν⟩∧Cond3(s, ψ, ν) →γψ(s, z⌈ν)
 
.
All these equivalences are provable in BASIC. The prenex form (9.1) is the one
we ﬁx for s ∈F(a).
We have implicitly used several independent quantiﬁers, i.e. we are reading z
as [z1, . . . , zk] where each variable zi consists of k “slices” p1(zi), ..., pk(zi).
Slice i is used for formulas of rank i. As Da is an s.u.b. for all formulas we have
to consider, we may assume w.l.o.g. that the slices in each zi are strictly bounded
by Da, and that quantiﬁcation and Skolem functions also respect this. We could
enforce this by adding further conditions to Ψ, but we refrain from doing so as it
only makes the exposition less clear.
Based on the above prenex form of s ∈F(a), we now consider the Πb
k-PLS
conditions (3.1)-(3.5) for the ﬁxed parameterised local search problem L, and we
show that they have prenex forms which admit simple Skolem functions, provable
in BASIC. We start with the simplest case ﬁrst.
9.1 Πb
k-PLS condition (3.4)
Condition (3.4) of a Πb
k-PLS problem in general has the form
(∀a, s)(N(a, s) ̸= s →c(a, N(a, s)) < c(a, s)) .
As N and c are polynomial time functions, this condition is equivalent to some
sΠb
1-formula, so there is nothing to show.
9.2 Πb
k-PLS condition (3.2)
This condition has the form
(∀a)(i(a) ∈F(a))
which, as we just showed, is equivalent to
(∀a, σ)(∀∃kz)Ψ(a, i(a), σ, z)

118
Arnold Beckmann and Samuel R. Buss
The latter obviously follows from the following stronger form:
(∀a, σ)(∀kz)Ψ(a, i(a), σ, z)
(9.2)
Theorem 9.2. (9.2) is provable in BASIC.
Proof. We argue in BASIC. Let a, σ, z be given, and assume σ = ⟨j, ψ, ν⟩. By
deﬁnition, i(a) =

ha, ∅, 0k
. The deﬁnition of L shows that

ha, ∅, 0k
∈C(a)
and that tp(ha) ̸= Axψ. We observe that Cond1(s, ψ, ν) and Cond2(s, ψ, ν)
are false as Γ(ha) ⊆{(∃y)ϕ(a, y)}.
For j
= 3 we observe that s = 0k
and γψ(0k, z⌈rk(ψ)) is true by Theorem 8.4, 3 and Deﬁnition 8.6.
Hence
Ψ(a,

ha, ∅, 0k
, σ, z) is true.
9.3 Πb
k-PLS condition (3.1)
This condition has the form
(∀a, s)(s ∈F(a) →|s| ≤d(|a|))
which can be transformed equivalently over BASIC in the following way:
(∀a, s)(s ∈F(a) →|s| ≤d(|a|))
⇔
(∀a, s)

(∀σ)(∀∃kz)Ψ(a, s, σ, z) →|s| ≤d(|a|)

⇔
(∀a, s)(∃σ)(∃∀kz)

Ψ(a, s, σ, z) →|s| ≤d(|a|)

The latter obviously follows from the following stronger form:
(∀a, s, σ)(∀kz)

Ψ(a, s, σ, z) →|s| ≤d(|a|)

(9.3)
Theorem 9.3. (9.3) is provable in BASIC.
Proof. We argue in BASIC. Let a, s, σ, z be given with Ψ(a, s, σ, z). If s < Da
then obviously |s| ≤d(|a|) by deﬁnition of d. Otherwise, s ≥Da, and we obtain
s ∈C(a) by deﬁnition of Ψ. Again we obtain |s| ≤d(|a|) by construction of d as
indicated in the proof of Proposition 7.4.
9.4 Πb
k-PLS condition (3.3)
This condition has the form
(∀a, s)(s ∈F(a) →N(a, s) ∈F(a)) .

Deﬁnable Search Problems in Bounded Arithmetic
119
Using the prenex form ﬁxed in (9.1), this formula can be transformed equivalently
over BASIC in the following way:
(∀a, s)(s ∈F(a) →N(a, s) ∈F(a))
⇔
(∀a, s)

(∀σ)(∀∃kz)Ψ(a, s, σ, z) →(∀¯σ)(∀∃k¯z)Ψ(a, N(a, s), ¯σ,¯z)

⇔
(∀a, s, ¯σ, ¯z1)(∃σ, z1)(∀z2)(∃¯z2)(∀¯z3)(∃z3)(∀z4) · · ·

Ψ(a, s, σ, z1, z2, . . . ) →Ψ(a, N(a, s), ¯σ, ¯z1, ¯z2, . . . )

(9.4)
Formula (9.4) is the prenex form which we ﬁx for Condition (3.3).
Theorem 9.4. The prenex formula (9.4) admits simple Skolem functions.
Proof. We have to show that there are polynomial time functions
hσ(a, s, σ, z1), h1(a, s, σ, z1), h2(a, s, σ, z1, z2), h3(a, s, σ, z1, z2, z3), . . .
such that S1
2 proves
(∀a, s, σ, z1, z2, z3, z4, . . . )

Ψ(a, s, hσ(a, s, σ, z1), h1(a, s, σ, z1), z2, h3(. . . , z3), z4, . . . )
→Ψ(a, N(a, s), σ, z1, h2(. . . , z2), z3, h4(. . . , z4), . . . )

(9.5)
In the following we suppress the arguments a, s from the Skolem functions. We
say that hσ(σ, z1) (resp., h1(σ, z1), h2(σ, z1, z2), ...) is chosen canonically if
hσ(σ, z1) = σ (resp., h1(σ, z1) = z1, h2(σ, z1, z2) = z2, ....)
Let a, s, σ, z1, z2, z3, . . . be given. We consider cases according to the deﬁnition
of N(a, s).
Let us start with some simple cases. Let us assume s =

h, f, 0k
, ψ /∈sΠb
0
and N(a, s) =

h[f(ψ)], f r, 0k
with tp(h) = 	
ψ and 0 < ν := rk(ψ) ≤k. If
σ is different from ⟨2, ψ[f(ψ)], ν−1⟩or Cond2(N(a, s), ψ[f(ψ)], ν−1) is false,
then choosing Skolem functions canonically obviously satisﬁes (9.5). So let us
assume that σ = ⟨2, ψ[f(ψ)], ν−1⟩and that Cond2(N(a, s), ψ[f(ψ)], ν−1) is
true. Choose hσ(. . . ) = ⟨1, ψ, ν⟩and all other Skolem functions canonically. Then
Cond1(s, ψ, ν) is satisﬁed, and (9.5) is equivalent to
¬βψ(f(ψ), pν−1([z1, . . . , zν−1])) →¬βψ[f(ψ)](pν−1([z1, . . . , zν−1]))
which is obviously true.
Another simple case occurs if s = ⟨h, f, s⟩and N(a, s) = ⟨h, f, Nψ(s)⟩with
tp(h) = Cutψ, ν := rk(ψ) and Nψ(s) ̸= s. If Cond3(N(a, s), ψ, ν) is false

120
Arnold Beckmann and Samuel R. Buss
or σ ̸= ⟨3, ψ, ν⟩, then choosing Skolem functions canonically obviously satis-
ﬁes (9.5). So assume σ = ⟨3, ψ, ν⟩and Cond3(N(a, s), ψ, ν) is true. Choose
hσ canonically. As Cond3(s, ψ, ν) is obviously satisﬁed, (9.5) is equivalent to
γψ(s, h1(σ, z1), z2, h3(. . . ), . . . ) →γψ(Nψ(s), z1, h2(σ, z1, z2), z3, . . . ) .
Choosing h1, h2, . . . according to Theorem 8.5 will satisfy this implication.
We now list all non-trivial cases. In all other cases not mentioned here, choos-
ing canonical Skolem functions immediately proves the assertion, as above. Let
s = ⟨h, f, s⟩, then the following cases in the deﬁnition of F(a, s) have to be con-
sidered:
1. N(a, s) =

h[ϵ(ψ)], f r, 0k
with tp(h) = 	
ψ and ψ ∈sΠb
0.
2. N(a, s) =

h[0], f ′, 0k
with tp(h) = 
i
ψ, ψ /∈sΣb
1, Nψ[i](s) = s, s /∈Aψ[i]
and f ′ = (f ∪{ψ[i] →s1})r.
3. N(a, s) = i with tp(h) = 
i
(∃y)ϕ(a,y), Nϕ(a,i)(s) = s and s ∈Aϕ(a,i).
4. N(a, s) =

h[1], fr, 0k
with tp(h) = Cutψ, ψ /∈sΠb
0, Nψ(s) = s and
s ∈Aψ.
5. N(a, s) =

h[0], f ′, 0k
with tp(h) = Cutψ, ψ /∈sΠb
0, Nψ(s) = s, s /∈Aψ,
and f ′ = (f ∪{ψ →s1})r.
We will now study these cases one by one, thereby considering only critical
sub-cases; for all other sub-cases the canonical choices for Skolem functions will
already satisfy (9.5).
Case 1.
N(a, s) =

h[ϵ(ψ)], f r, 0k
with tp(h) = 	
ψ and ψ ∈sΠb
0.
If
σ = ⟨2, ψ[ϵ(ψ)], 0⟩such that Cond2(N(a, s), ψ[ϵ(ψ)], 0) is true, we choose
hσ(σ, . . . ) = ⟨2, ψ, 0⟩and all other Skolem functions canonically. Then (9.5)
is equivalent to ¬βψ
→¬βψ[ϵ(ψ)] which is satisﬁed by deﬁnition of ϵ(ψ), cf.
Deﬁnition 7.2.
Case 2. N(a, s) =

h[0], f ′, 0k
with tp(h) = 
i
ψ, ψ /∈sΣb
1, Nψ[i](s) = s,
s /∈Aψ[i] and f ′ = f r ∪{ψ[i] →s1}. Then ψ has to be of the form (∃∀νz)βψ(z)
with ν ≥2. Assume σ = ⟨1, ψ[i], ν−1⟩and Cond1(N(a, s), ψ[i], ν−1). Let
j := s1, then f ′(ψ[i]) = j.
If ν = 2 then s /∈Aψ[i] implies ¬ψ[i][j], thus ¬βψ[i][j]. In this situation, the
conclusion of (9.5) is of the form ¬βψ[i][j] which is true. Hence, any choice of
Skolem functions will satisfy (9.5).

Deﬁnable Search Problems in Bounded Arithmetic
121
Now assume ν > 2. Choose hσ(σ, . . . ) = ⟨3, ψ[i], ν−1⟩and all other Skolem
functions canonically. Cond3(s, ψ[i], ν−1) is obviously satisﬁed, thus (9.5) is
equivalent to
γψ[i](s, z1, z2, . . . ) →¬βψ[i][j](t)
with t = pν−2([z1, z2, z3, . . .]).
Assume γψ[i](s, z1, z2, . . . ).
In this situation
we have rk(ψ[i]) = ν−1 and tp(ψ[i]) = 	. Thus, Theorem 8.4, 5 shows that
pν−2(z1) < s2 →¬βψ[i](s1, t). As Nψ[i](s) = s, s /∈Aψ[i] and tp(ψ[i]) = 	,
we have s2 = Da by Corollary 6.14, 1. Hence, the latter implies ¬βψ[i](s1, t)
which is the same as ¬βψ[i][j](t).
Case 3. N(a, s) = i with tp(h) = 
i
(∃y)ϕ(a,y), Nϕ(a,i)(s) = s and s ∈Aϕ(a,i).
We have that ϕ(a, i) is of the form (∀∃ℓz)βϕ(a,i)(z).
If ℓ= 0 then s ∈Aϕ(a,i) implies ϕ(a, i), which is the same as βϕ(a,i). This
implies the succedent of (9.5), which is of the form βϕ(a, i).
If ℓ> 0, choose hσ(σ, . . . ) = ⟨3, ϕ(a, i), ℓ⟩and all other Skolem functions
canonically. Cond3(s, ϕ(a, i), ℓ) is obviously satisﬁed, thus (9.5) is equivalent to
γϕ(a,i)(s, z1, z2, . . . ) →βϕ(a,i)(t)
with t = pℓ([z1, z2, z3, . . .]). Assume γϕ(a,i)(s, z1, z2, . . . ). As rk(ϕ) = ℓand
tp(ϕ) = 	, Theorem 8.4, 4, shows pℓ(z1) < s1 →βϕ(a,i)(t). As Nϕ(a,i)(s) = s,
s ∈Aϕ(a,i) and tp(ϕ(a, i)) = 	, we have s1 = Da by Corollary 6.14, 2. Hence,
the latter implies βϕ(a,i)(t).
Case 4. N(a, s) =

h[1], f r, 0k
with tp(h) = Cutψ, Nψ(s) = s and s ∈Aψ.
We have that ψ ≡(∀∃νz)βψ(z) for ν = rk(ψ). Assume σ = ⟨2, ¬ψ, ν⟩and
Cond2(N(a, s), ¬ψ, ν) is true.
If ν = 0, choose Skolem functions arbitrarily. Then, the conclusion of (9.5) is
equivalent to βψ, which is satisﬁed because s ∈Aψ already implies ψ which is the
same as βψ.
Now assume ν > 0, and choose hσ(σ, . . . ) = ⟨3, ψ, ν⟩and all other Skolem
functions canonically. Cond3(s, ψ, ν) is obviously satisﬁed. Then (9.5) is equiva-
lent to
γψ(s, z1, z2, . . . ) →βψ(t)
with t = pν([z1, z2, z3, . . .]).
Assume γψ(s, z1, z2, . . . ).
As rk(ψ) = ν and
tp(ψ) = 	, Theorem 8.4, 4, shows pν(z1) < s1 →βψ(t). By assumption
Nψ(s) = s, s ∈Aψ and tp(ψ) = 	, so s1 = Da by Corollary 6.14, 2. Hence
βψ(t) follows.

122
Arnold Beckmann and Samuel R. Buss
Case 5. N(a, s) =

h[0], f′, 0k
with tp(h) = Cutψ, ψ /∈sΠb
0, Nψ(s) = s,
s /∈Aψ, and f ′ = (f ∪{ψ →s1})r. We have that ψ ≡(∀∃νz)βψ(z) for ν = rk(ψ),
and ν > 0. Let j := s1.
If ν = 1, the assumption s /∈Aψ implies ¬ψ[s1] which is ¬βψ[j]. Now the
critical case is σ = ⟨1, ψ, 1⟩, when the conclusion of (9.5) has the form ¬βψ[f(ψ)]
which is the same as ¬βψ[j], and is satisﬁed. Arbitrary choices for Skolem func-
tions will satisfy (9.5).
Finally, assume ν > 1. The critical case now is that σ = ⟨1, ψ, ν⟩and that
Cond1(N(a, s), ψ, ν) is true, that is ψ ∈dom(f ′), and f ′(ψ) = j by deﬁni-
tion. Choose hσ(σ, . . . ) = ⟨3, ψ, ν⟩and all other Skolem functions canonically.
Cond3(s, ψ, ν) is obviously satisﬁed. Then (9.5) is equivalent to
γψ(s, z1, z2, . . . ) →¬βψ[j](t)
with t = pν−1([z1, z2, z3, . . .]), as j = f(ψ). Assume γψ(s, z1, z2, . . . ). As
tp(ψ) = 	 and rk(ψ) = ν, Theorem 8.4, 5, shows pν−1(z1) < s2 →¬βψ(s1, t).
As Nψ(s) = s, s /∈Aψ and tp(ψ) = 	, we have s2 = Da by Corollary 6.14, 1.
Hence ¬βψ(s1, t) follows, which is the same as ¬βψ[j](t).
9.5 Πb
k-PLS condition (3.5)
Condition (3.5) can be divided into two parts which we consider independently:
(∀a, s)(s ∈G(a) →(N(a, s) = s ∧s ∈F(a)))
(9.6)
and
(∀a, s)((N(a, s) = s ∧s ∈F(a)) →s ∈G(a))
(9.7)
The goal set G(a) is given as the set of all s < Da with ϕ(a, s). Using the
prenex form ﬁxed for ϕ according to Deﬁnition 9.1, and the prenex form ﬁxed
for s ∈F(a) in (9.1), formula (9.6) can be transformed equivalently as follows,
provably in BASIC:
(∀a, s)

s ∈G(a) →(N(a, s) = s ∧s ∈F(a))

⇔(∀a, s)

s < Da ∧(∀∃ℓz)βϕ(a, s, pℓ(z))
→N(a, s) = s ∧(∀σ)(∀∃k¯z)Ψ(a, s, σ,¯z)

⇔(∀a, s)(∀σ)(∀¯z1)(∃z1)(∀z2)(∃¯z2) · · ·

s < Da ∧βϕ(a, s, pℓ([z1, z2, . . .]))
→N(a, s) = s ∧Ψ(a, s, σ, ¯z1, ¯z2, . . . )

.

Deﬁnable Search Problems in Bounded Arithmetic
123
The latter assertion obviously follows from the following stronger one:
(∀a, s, σ, z1, z2, z3, . . . )

s < Da ∧βϕ(a, s, pℓ([z1, z2, . . .]))
→N(a, s) = s ∧Ψ(a, s, σ, z1, z2, . . . )

.
(9.8)
We show that (9.8) is provable in S1
2.
Theorem 9.5. S1
2 proves (9.8).
Proof. We argue in S1
2. Let a, s, σ, z1, z2, z3, . . . be given, and assume s < Da
and βϕ(a, s, pℓ([z1, z2, . . .])).
Hence, N(a, s) = s by deﬁnition of N, and
Ψ(a, s, σ, z1, z2, . . . ) by deﬁnition of Ψ.
We now turn to condition (9.7). Instead of working directly with this condition
we split it into two according to whether s < Da or not, and simplify the resulting
conditions according to their meaning.
(∀a, s)((N(a, s) = s ∧s < Da ∧s ∈F(a)) →s ∈G(a))
(9.9)
and
(∀a, s)((N(a, s) = s ∧s ≥Da →s /∈F(a)))
(9.10)
We observe that (9.9) and (9.10) together imply (9.7) in BASIC.
We consider conditions (9.9) and (9.10) in turn. The former is straight forward
to deal with. We transform (9.9) equivalently as follows, provable in BASIC:
(∀a, s)

(N(a, s) = s ∧s < Da ∧s ∈F(a)) →s ∈G(a)

⇔(∀a, s)

N(a, s) = s ∧s < Da ∧(∀σ)(∀∃kz)Ψ(a, s, σ, z)
→(∀∃ℓ¯z)βϕ(a, s, pℓ(¯z))

⇔(∀a, s)(∀¯z1)(∃σ)(∃z1) (∀z2)(∃¯z2) (∀¯z3)(∃z3) (∀z4)(∃¯z4) . . .

N(a, s) = s ∧s < Da ∧Ψ(a, s, σ, z1, z2, z3, . . . )
→βϕ(a, s, pℓ([¯z1, ¯z2, ¯z3, . . .]))

.
The latter is the prenex form which we ﬁx for (9.9). We now show that this prenex
form admits simple Skolem functions.
Theorem 9.6. The prenex form ﬁxed for (9.9) admits simple Skolem functions.

124
Arnold Beckmann and Samuel R. Buss
Proof. We have to show that there are polynomial time functions
hσ(a, s, z1), h1(a, s, z1), h2(a, s, z1, z2), h3(a, s, z1, z2, z3), . . .
such that the following is provable in S1
2:
(∀a, s, z1, z2, z3, z4, . . . )

N(a, s) = s ∧s < Da
∧Ψ(a, s, hσ(a, s, z1), h1(a, s, z1), z2, h3(. . . , z3), . . . )
→βϕ(a, s, pℓ([z1, h2(a, s, z1, z2), z3, h4(. . . , z4), . . .]))

.
(9.11)
We argue in S1
2.
Let a, s, z1, z2, z3, z4, . . . be given with N(a, s) = s and
s < Da. Choose hσ(. . . ) = 0, and all other Skolem functions canonically. As-
sume Ψ(a, s, 0, z1, z2, z3, z4 . . . ), then βϕ(a, s, pℓ([z1, z2, z3, z4, . . .])) follows by
deﬁnition of Ψ(a, s, 0, 0, z1, z2, z3, z4 . . . ) as s < Da.
We now turn to condition (9.10) to transform it into a suitable prenex form.
This is not at all obvious because the canonical prenex form does not admit sim-
ple Skolem functions. The premise of the implication is of low complexity and
can be ignored for the prenex form and later the Skolemisation. The only rel-
evant part is the formula “s/∈F(a)”. First, we double this part to the formula
“s/∈F(a) ∨s/∈F(a)” to obtain two independent sets of quantiﬁers. This step is
inessential and could have been incorporated already in the prenex form that we
ﬁxed for “s/∈F(a)”. In the second step, we pull out quantiﬁers, but not in the
canonical way (that is those of the same level at the same time, putting universal
before existential ones.) Instead, we ﬁrst pull out the ﬁrst (∃, ∀) quantiﬁer pair of
the ﬁrst “s/∈F(a)”, followed by the ﬁrst (∃, ∀) pair of the second “s/∈F(a)”. Then
comes the second (∃, ∀) pair of the ﬁrst “s/∈F(a)”, followed by the second (∃, ∀)
pair of the second “s/∈F(a)”, and so on. As “s/∈F(a)” is of rank k, we produce in
this way a prenex formula of rank 2k, where the canonical prenex form would be
of rank k. Thus, we transform (9.10) equivalently as follows, provable in BASIC,

Deﬁnable Search Problems in Bounded Arithmetic
125
where the very last equivalence just renames variables:
(∀a, s)

(N(a, s) = s ∧s ≥Da →s /∈F(a))

⇔(∀a, s)

(N(a, s) = s ∧s ≥Da →s /∈F(a) ∨s /∈F(a))

⇔(∀a, s)

N(a, s) = s ∧s ≥Da →(∃σ1)(∃∀kz1)¬Ψ(a, s, σ1, z1)
∨(∃σ2)(∃∀kz2)¬Ψ(a, s, σ2, z2)

⇔(∀a, s)(∃σ1, σ2)(∃z1
1)
(∀z1
2)(∃z2
1) (∀z2
2)(∃z1
3) (∀z1
4)(∃z2
3) · · ·

N(a, s) = s ∧s ≥Da →¬Ψ(a, s, σ1, z1
1, z1
2, z1
3, . . . )
∨¬Ψ(a, s, σ2, z2
1, z2
2, z2
3, . . . )

⇔(∀a, s)(∃σ1, σ2)(∃z1
1)
(∀z1
2)(∃z2
2) (∀z2
3)(∃z1
3) (∀z1
4)(∃z2
4) · · ·

N(a, s) = s ∧s ≥Da →¬Ψ(a, s, σ1, z1
1, z1
2, z1
3, . . . )
∨¬Ψ(a, s, σ2, z2
2, z2
3, z2
4, . . . )

.
The latter is the prenex form which we ﬁx for (9.10). We now show that this prenex
form admits simple Skolem functions.
Theorem 9.7. The prenex form ﬁxed for (9.10) admits simple Skolem functions.
Proof. We have to show that there are polynomial time functions
hσ1(a, s), hσ2(a, s),
h1(a, s), h2(a, s, z2), h3(a, s, z2, z3), h4(a, s, z2, z3, z4), . . .
such that the following is provable in S1
2:
(∀a, s, z2, z3, z4, . . . )

N(a, s) = s ∧s ≥Da
→¬Ψ(a, s, hσ1(a, s), h1(a, s), z2, h3(a, s, z2, z3), . . . )
∨¬Ψ(a, s, hσ2(a, s), h2(a, s, z2), z3, h4(. . . , z4), . . . )

.
(9.12)
We argue in S1
2. Let a, s, z2, z3, z4, . . . be given with N(a, s) = s and s ≥Da.
Then N(a, s) = s implies by deﬁnition of N that s = ⟨h, f, s⟩, tp(h) = 
i
ψ,
ν := rk(ψ[i]) > 0, Nψ[i](s) = s, s ∈Aψ[i] and ψ ̸≡(∃y)ϕ(a, y). Choose
hσ1(a, s) = ⟨2, ψ, ν+1⟩, hσ2(a, s) = ⟨3, ψ[i], ν⟩, pν+1(h1(a, s)) = i,
pν(hj(. . . , zj)) = pν+1(zj)
pν+1(hj(. . . , zj)) = pν(zj)

126
Arnold Beckmann and Samuel R. Buss
for j = 2, . . . , k, and all remaining slices canonically. Let
t := [pν+1(z2), pν(z3), pν+1(z4), pν(z5), . . .]
then we have
pν+1([h1(a, s), z2, h3(a, s, z2, z3), . . .]) = [i, t1, t2, t3, . . .]
(9.13)
pν([h2(a, s, z2), z3, h4(. . . , z4), . . .]) = [t1, t2, t3, . . .]
(9.14)
Now, (9.12) is equivalent to
¬Ψ(a, s, ⟨2, ψ, ν+1⟩, h1(a, s), z2, h3(a, s, z2, z3), . . . )
∨¬Ψ(a, s, ⟨3, ψ[i], ν⟩, h2(a, s, z2), z3, h4(. . . , z4), . . . )
⇔
βψ(pν+1([h1(a, s), z2, h3(a, s, z2, z3), . . .]))
∨¬γψ[i](s, h2(a, s, z2), z3, h4(. . . , z4), . . . )
⇔
βψ(i, t⌈ν) ∨¬γψ[i](s, h2(a, s, z2), z3, h4(. . . , z4), . . . )
(9.15)
using (9.13) for the last equivalence. To show the last statement (9.15), assume
γψ[i](s, h2(a, s, z2), z3, h4(. . . , z4), . . . ). As tp(ψ[i]) = 	 and rk(ψ[i]) = ν, The-
orem 8.4, 4, shows
pν(h2(. . . , z2)) < s1 →βψ[i](t⌈ν)
using (9.14). Now, Nψ[i](s) = s, s ∈Aψ[i] and tp(ψ[i]) = 	 show s1 = Da
by Corollary 6.14, 2. Hence, the latter implies βψ[i](t⌈ν) which is the same as
βψ(i, t⌈ν).
The next Corollary summarises the results obtained in this section.
Corollary 9.8. Let 0 ≤ℓ≤k. The Σb
ℓ+1-deﬁnable total search problems in Tk+1
2
can be characterised by Πb
k-PLS problems with Πb
ℓ-goals, such that conditions
(3.1)–(3.5) have prenex forms (over BASIC) which admit simple Skolem functions.
10 A Proposed Hard Principle for Tk
2
The separation problem of Bounded Arithmetic, i.e. the question whether the hier-
archy of Bounded Arithmetic theories is strict or not, is one of the central problems
in this area, due to the connections of Bounded Arithmetic theories to complex-
ity classes. There are several ways to approach the separation question. One path
which is followed in current research, is by studying relativised theories. Rela-
tivised Bounded Arithmetic theories can be obtained by adding one unspeciﬁed set

Deﬁnable Search Problems in Bounded Arithmetic
127
variable α to the language of Bounded Arithmetic, which counts as a new atomic
formula and is allowed in sΣb
k(α)-formulas and in induction formulas. Relativised
separations have been obtained between all relativised Bounded Arithmetic theo-
ries [KPT91, Bus95, Zam96, Jeˇr09], the goal in current research is to improve the
separations, ultimately to ﬁnd ∀Σb
1(α) principles which separate the theories, or
even ∀Πb
1(α) principles — ∀Πb
1 is the complexity of consistency statements.
In this section we will derive, for each k, a generic ∀Σb
1(α) principle from the
results of the previous sections, and show that it gives rise to a class of ∀Σb
1 for-
mulas which characterise the ∀Σb
1 consequences of Tk+1
2
. The generic form of the
principle is therefore conjectured to separate Tk+1
2
(α) from Tk
2(α). Such generic
principles are well-known in the literature. We will brieﬂy discuss later the relation
of the principle which we will deﬁne here to the game principles deﬁned in [ST07].
Fix k ≥0. The Skolemisation of the Πb
k-PLS conditions from the previous
section forms the basis for the generic ∀sΣb
1(α)-principle which we will denote
by Pk. We replace the polynomial time functions and predicates in the Skolemised
versions of (3.1)-(3.5) from the previous section by new function and predicate
symbols in the following way: Let N, c, i be new function symbols which will
be used for the neighbourhood function, the cost function, and the initial value
function respectively. Let G, F ′ be new relation symbols, where G is binary and
is used for the goal set, and F ′ is k+2-ary and represents Ψ(a, s, σ, z1, z2, . . . , zk)
from the prenex form (9.1) ﬁxed for s ∈F(a) in the previous section. Let b
be a parameter, and let a = p1(b), a1 = p1(p2(b)) and a2 = p2(p2(b)). We
assume Da = a1, and that a2 serves as a bound for all quantiﬁers. The Skolemised
versions of (3.1)-(3.5) read as follows — strictly speaking, (3.1)SK below is not the
Skolemisation of (3.1), but a reformulation and adaptation to the current setting, as
the original (3.1) is unsuitable. We take b as a parameter to these formulas, from
which a, a1 and a2 can be computed.
(3.1)SK
i(a) < a2 ∧(∀s < a2)(N(a, s) < a2)
(3.2)SK
(∀σ, z1, . . . , zk < a2)F ′(a, i(a), σ, z1, . . . , zk)
(3.3)SK
(∀s, σ, z1, . . . , zk < a2)
(F ′(a, s, hσ(a, s, σ, z1), h1(a, s, σ, z1), z2, h3(a, s, σ, z1, z2, z3), . . . )
→F ′(a, N(a, s), σ, z1, h2(a, s, σ, z1, z2), z3, h4(. . . , z4), . . . ))
(3.4)SK
(∀s < a2)(N(a, s) = s ∨c(a, N(a, s)) < c(a, s))
(3.5a)SK
(∀s, z1, z2, . . . , zk < a2)(N(a, s) = s ∧s < a1
∧F ′(a, s, 0, z1, z2, z3, . . . ) →G(a, s))

128
Arnold Beckmann and Samuel R. Buss
(3.5b)SK
(∀s, z2, . . . , zk, zk+1 < a2)(N(a, s) = s ∧s ≥a1
→¬F ′(a, s, gσ,1(a, s), g1(a, s), z2, g3(a, s, z2, z3), . . . )
∨¬F ′(a, s, gσ,2(a, s), g2(a, s, z2), z3, g4(. . . , z4), . . . ))
where hσ, h1, h2, . . . and gσ,1, gσ,2, g1, g2, . . . are further function symbols repre-
senting polynomial time Skolem functions. We have used only one direction of the
equivalence in the Skolemisation of (3.5), as we only need this one to prove the
principle Pk. This direction comes in two parts, (3.5a)SK and (3.5b)SK.
Let X be the list of new function and predicate symbols, that is
X = G, F ′, N, c, i, hσ, h1, h2, . . . , gσ,1, gσ,2, g1, g2, . . .
Observe that (3.1)SK-(3.5b)SK are all sΠb
1(X)-formulas. Then the principle Pk(X)
is given by the ∀sΣb
1(X)-formula obtained from
(∀b)(a1 < a2 ∧(3.1)SK ∧· · · ∧(3.5b)SK →(∃s < a)G(a, s))
(10.1)
by turning the independent bounded existential quantiﬁers into one using the pair-
ing function and its bound B(z). We observe that the shape of Pk depends on
k.
Theorem 10.1. Tk+1
2
(X) ⊢Pk(X)
Proof. The proof is similar to that of Theorem 3.4. We argue in Tk+1
2
(X). Let b be
given, Let a = p1(b), a1 = p1(p2(b)) and a2 = p2(p2(b)). Assume that a1 < a2,
and that (3.1)SK-(3.5b)SK are satisﬁed. Let s ∈F(b) denote the formula
s < a2 ∧(∀σ<a2)(∀z1<a2)(∃z2<a2) · · · F ′(a, s, σ, z1, z2, . . . , zk) .
Consider the set X := {c(a, s): s < a2 ∧s ∈F(b)}. This set can be described
by some sΣb
k+1(X)-formula. By (3.1)SK and (3.2)SK we have c(a, i(a)) ∈X. As
Tk+1
2
(X) proves minimisation for sΣb
k+1(X)-properties, we can ﬁnd some c ∈X
which is minimal in X. Choose s < a2 and s ∈F(b) with c = c(a, s).
As (3.3)SK is derived from the Skolemisation of a prenex form for (3.3), we
obtain that s ∈F(b) →N(a, s) ∈F(b). Thus N(a, s) ∈F(b). We also have
that N(a, s) < a2 by (3.1)SK, hence c(a, N(a, s)) ∈X. As c is minimal in X we
obtain that c(a, s) = c ≤c(a, N(a, s)). Hence with (3.4)SK
N(a, s) = s .
As (3.5b)SK is derived from the Skolemisation of a prenex form for one part of
(3.5), we obtain
N(a, s) = s ∧s ≥a1 →s /∈F(b) .

Deﬁnable Search Problems in Bounded Arithmetic
129
As N(a, s) = s and s ∈F(b) we thus have
s < a1 .
Also, (3.5a)SK is derived from the Skolemisation of a prenex form for another
part of (3.5). Here we obtain
N(a, s) = s ∧s < a1 ∧s ∈F(b) →G(a, s) .
Hence we have G(a, s). Altogether this shows s < a1 ∧G(a, s).
By choosing appropriate substitutions for the parameters, this generic formula
can be used to deﬁne syntactic search problem classes which characterise the
∀Σb
1-consequences of Tk+1
2
: Let PiPLSSK(k) be the set of all formulas obtained
by replacing in Pk(X), the list of function and predicate symbols X by polyno-
mial time computable functions and relations (i.e., their deﬁnitions in S1
2.) Note
that PiPLSSK(k) is a Skolemized version of the principle PiPLS(k, 0) deﬁned in
Section 3. The last theorem shows that each formula in PiPLSSK(k) is provable in
Tk+1
2
. A converse is also true and can be shown using the results from Section 9.
The next Corollary is a reﬁnement of Corollary 3.6.
Corollary 10.2. Over S1
2, the theories PiPLSSK(k) and Tk+1
2
have the same
∀Σb
1-consequences.
Proof. We already argued for one inclusion. We still have to show that if Tk+1
2
proves (∀x)ϕ(x) with ϕ ∈Σb
1, then this formula also follows from a formula in
PiPLSSK(k) over S1
2.
By Theorem 3.5 and the strengthening in Section 9, we obtain a formalised
Πp
k-PLS problem with goal formula identical to ϕ, whose condition (3.1)–(3.5)
have prenex forms which can be Skolemised as described in Section 9, and be
proven in S1
2. Let X be the list of polynomial time computable functions and pred-
icates coming from this characterisation.
Let Da be an s.u.b. for the search problem, and d the polynomial bound on the
feasible solutions. W.l.o.g. we may assume that d also bounds all occurring σ, i.e.,
all triples ⟨i, ψ, ν⟩with i ≤3, ν ≤k, and ψ an instance of a formula in the set
of decorations obtained from the original Tk+1
2
-proof of (∀x)ϕ(x), by substituting
free variables with constants for values < Da. Let E(a) be 2d(|a|). Then let b
be pair(a, pair(a1, a2)), for a1 = Da and a2 = B(B(. . . B(Da + E(a)) . . . )),
where B is iterated k times (here, B is the term giving a bound on the size of pairs:

130
Arnold Beckmann and Samuel R. Buss
x, y < z →pair(x, y) < B(z).) We deﬁne
N ′(a, s) =

N(a, s)
if s<E(a) ∧N(a, s)<E(a)
E(a)
otherwise
c′(a, s) =
⎧
⎪
⎨
⎪
⎩
c(a, s) + 2
if s < E(a)
1
if s > E(a)
0
if s = E(a)
Let X ′ be X in which N, resp. c, has been replaced by N ′, resp. c′. Consider
the formula Pk(X ′) in PiPLSSK(k) deﬁned by X ′. Given an input a, we choose
an instance b for Pk(X ′) as described above. Then it is easy to show that the
strengthenings of the formalised Πp
k-PLS problem proved in Section 9 imply
a1 < a2 ∧(3.1)SK ∧· · · ∧(3.5b)SK
in S1
2, from which we immediately obtain ϕ(a) over S1
2 assuming Pk(X ′).
We brieﬂy discuss some cases for the above: (3.1)SK follows immediately from
the deﬁnitions. (3.2)SK follows immediately from the related case in Section 9.
Same for (3.4)SK.
To show (3.3)SK let s, σ, z1, . . . , zk < a2 such that
F ′(a, s, hσ(a, s, σ, z1), h1(. . . ), z2, . . . ) .
Thus Ψ(a, s, hσ(a, s, σ, z1), h1(. . . ), z2, . . . ) is true which implies by Theorem 9.4
that also Ψ(a, N(a, s), σ, z1, h2(a, s, σ, z1, z2), z3, h4(. . . , z4), . . . ) is satisﬁed.
Theorem 9.3 shows that s, N(a, s) < E(a). Thus, N′(a, s) = N(a, s) and we
obtain F ′(a, N ′(a, s), σ, z1, h2(. . . ), . . . ). The cases (3.5a)SK and (3.5b)SK are
similar.
We observe that it is possible to deﬁne similar generic principles for the
∀Σb
ℓ+1-consequences of Tk+1
2
.
As the principle PiPLSSK(k) characterises all ∀Σb
1 consequences of Tk+1
2
, we
conjecture that its generic version Pk(X) deﬁned in (10.1) will separate Tk
2(X)
from Tk+1
2
(X).
Conjecture 10.3. Tk
2(X) ⊬Pk
By applying standard techniques using bit-graphs of functions and coding differ-
ent relations into one, the principle Pk can be transformed into a principle which

Deﬁnable Search Problems in Bounded Arithmetic
131
depends on only one relation variable α. The resulting principle is still a ∀sΣb
1(α)
sentence conjectured to separate Tk
2(α) from Tk+1
2
(α).
The formula Pk can also be transformed into a propositional principle con-
jectured to provide exponential separations between constant-depth propositional
proof systems, by using well-known connections between Bounded Arithmetic and
constant-depth propositional proof systems via the Paris-Wilkie translation. There
are different ways to view the resulting propositional principle. One way is to read
it as a polynomial size set of clauses, where each clause is a logarithmic size set of
literals.
We do not go into more depth on these constructions, as they are discussed in
detail in the related paper [BB08]. The interested reader is kindly referred to that
exposition.
We ﬁnish this section by comparing our approach to the characterisation of the
∀Σb
ℓ+1-consequences of Tk+1
2
to the results in [ST07]. The game principles GIk
from [ST07] and the principle PiPLSSK(k + 1) deﬁned here both characterise the
∀Σb
1 consequences of Tk+2
2
over S1
2. From this we immediately obtain that they are
reducible to each other under the canonical reduction of total Σb
1 search problems
as discussed e.g. in [ST07]: Let A = (∀x)(∃y)ϕ(x, y) and B = (∀u)(∃v)ψ(u, v)
be two total Σb
1 search problems, then we call A reducible to B, in symbols A ≤B,
if there are two polynomial time computable functions f and g, such that for any x,
if v is a solution to B on input f(x), i.e. ψ(f(x), v), then g(x, v) is a solution to A
on input x, i.e. ϕ(x, g(x, v)). The results of [ST07] show that for any formula A in
PiPLSSK(k +1), there is an instance B in GIk with A ≤B, provable in S1
2. In the
other direction, using the results obtained here, we obtain that for any B in GIk,
there is a formula A in PiPLSSK(k+1) with B ≤A, provable in S1
2. An inspection
of the proof of Corollary 10.2 shows that in the latter case the reducing functions
are given by the identity for f and a projection to the last component of the second
argument (which codes, using the pairing function, the values of several existential
quantiﬁers into one) for g. It is also possible to give a simple direct reduction from
the GIk principle to an instance of Pk+1 by a construction that directly matches the
combinatorial structure of GIk. It is not clear whether there is a similarly simple
direct reduction from Pk+1 to GIk.
References
[AB09]
Klaus Aehlig and Arnold Beckmann. On the computational complexity of cut-
reduction, 2009. Accepted for publication, DOI 10.1016/j.apal.2009.06.004.
[BB08]
Arnold Beckmann and Samuel R. Buss. Polynomial local search in the polynomial
hierarchy and witnessing in fragments of bounded arithmetic. Technical Report

132
Arnold Beckmann and Samuel R. Buss
CSR15-2008, Department of Computer Science, Swansea University, December
2008. Accepted for publication in Journal of Mathematical Logic, May 2010.
[Bec03]
Arnold Beckmann. Dynamic ordinal analysis. Arch. Math. Logic, 42:303–334,
2003.
[BK94]
Samuel R. Buss and Jan Kraj´ıˇcek. An application of Boolean complexity to sepa-
ration problems in bounded arithmetic. Proc. London Math. Soc. (3), 69(1):1–21,
1994.
[Buc91]
Wilfried Buchholz. Notation systems for inﬁnitary derivations. Archive for Math-
ematical Logic, 30:277–296, 1991.
[Buc97]
Wilfried Buchholz.
Explaining Gentzen’s consistency proof within inﬁnitary
proof theory. In Computational logic and proof theory (Vienna, 1997), volume
1289 of Lecture Notes in Comput. Sci., pages 4–17. Springer, Berlin, 1997.
[Bus86]
Samuel R. Buss. Bounded arithmetic, volume 3 of Studies in Proof Theory. Lec-
ture Notes. Bibliopolis, Naples, 1986.
[Bus95]
Samuel R. Buss. Relating the bounded arithmetic and the polynomial time hierar-
chies. Annals of Pure and Applied Logic, 75:67–77, 1995.
[Jeˇr09]
Emil Jeˇr´abek. Approximate counting by hashing in bounded arithmetic. Journal
of Symbolic Logic, 74(3):829–860, 2009.
[JPY88] David S. Johnson, Christos H. Papadimitriou, and Mihalis Yannakakis. How easy
is local search? J. Comput. System Sci., 37(1):79–100, 1988. 26th IEEE Confer-
ence on Foundations of Computer Science (Portland, OR, 1985).
[KPT91] Jan Kraj´ıˇcek, Pavel Pudl´ak, and Gaisi Takeuti. Bounded arithmetic and the poly-
nomial hierarchy. Annals of Pure and Applied Logic, 52:143–153, 1991.
[Kra93]
Jan Kraj´ıˇcek. Fragments of bounded arithmetic and bounded query classes. Trans.
Amer. Math. Soc., 338(2):587–598, 1993.
[KST07] Jan Kraj´ıˇcek, Alan Skelley, and Neil Thapen. NP search problems in low frag-
ments of bounded arithmetic. J. Symbolic Logic, 72(2):649–672, 2007.
[Min78] Grigori E. Mints. Finite investigations of transﬁnite derivations. Journal of Soviet
Mathematics, 10:548–596, 1978. Translated from: Zap. Nauchn. Semin. LOMI
49 (1975). Cited after Grigori Mints. Selected papers in Proof Theory.Studies in
Proof Theory. Bibliopolis, 1992.
[Pol99]
Chris Pollett. Structure and deﬁnability in general bounded arithmetic theories.
Ann. Pure Appl. Logic, 100(1-3):189–245, 1999.
[Pud06]
Pavel Pudl´ak. Consistency and games—in search of new combinatorial principles.
In Logic Colloquium ’03, volume 24 of Lect. Notes Log., pages 244–281. Assoc.
Symbol. Logic, La Jolla, CA, 2006.
[Pud07]
Pavel Pudl´ak. Fragments of bounded arithmetic and the lengths of proofs, 2007.
Preprint.

Deﬁnable Search Problems in Bounded Arithmetic
133
[PW85]
J. Paris and A. Wilkie. Counting problems in bounded arithmetic. In A. Dold
and B. Eckmann, editors, Methods in Mathematical Logic (Proceedings Caracas
1983), number 1130 in Lecture Notes in Mathematics, pages 317–340. Springer,
1985.
[ST07]
Alan Skelley and Neil Thapen. The provable total search problems of bounded
arithmetic, 2007. Preprint.
[Tai68]
William W. Tait. Normal derivability in classical logic. In J. Barwise, editor, The
Syntax and Semantics of Inﬁnitatry Languages, number 72 in Lecture Notes in
Mathematics, pages 204–236. Springer, 1968.
[Zam96] Domenico Zambella.
Notes on polynomially bounded arithmetic.
Journal of
Symbolic Logic, 61:942–966, 1996.


On Topological Models of GLP
Lev Beklemishev∗, Guram Bezhanishvili, and Thomas Icard
Steklov Mathematical Institute
Gubkina str. 8, 119991 GSP-1, Moscow, Russian Federation
lbekl@yandex.ru
Department of Mathematical Sciences
New Mexico State University
Las Cruces NM 88003, USA
gbezhani@nmsu.edu
Department of Philosophy
Stanford University
Stanford, CA 94305-2155, USA
icard@stanford.edu
Abstract We develop topological semantics of a polymodal provability
logic GLP. Our main result states that the bimodal fragment of GLP,
although incomplete with respect to relational semantics, is topologically
complete. The topological (in)completeness of GLP remains an interesting
open problem.
1 Introduction
In this paper we initiate a study of topological models of an important polymodal
provability logic GLP due to Japaridze [21,22]. This system describes in the style
of provability logic all the universally valid schemata for the reﬂection principles
of restricted logical complexity in arithmetic. Thus, it is complete with respect to a
very natural kind of arithmetical semantics.
The logic GLP, and its restricted bimodal version GLB, have been extensively
studied in the early 1990s by Ignatiev [19,20] and Boolos, who simpliﬁed and ex-
tended Japaridze’s work. Boolos incorporated a very readable treatment of GLB
into his popular book on provability logic [11]. More recently, interesting applica-
tions of GLP have been found in proof theory and ordinal analysis of arithmetic.
In particular, GLP gives rise to a natural system of ordinal notation for the ordinal
∗Supported by the Russian Foundation for Basic Research (RFBR), Dutch Organization for Scientiﬁc
Research (NWO), Russian Presidential Council for Support of Leading Scientiﬁc Schools, and the
ECO-NET cooperation project “Computational interpretations of modal logic.”

136
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
ϵ0. Based on this system and the use of GLP, the ﬁrst author of this paper gave
a simple proof of consistency of Peano Arithmetic `a la Gentzen and formulated a
new independent combinatorial principle. This stimulated further interest towards
GLP (see [3,4] for a detailed survey).
The main difﬁculty in the modal-logical study of GLP comes from the fact that
it is incomplete with respect to its relational semantics; that is, GLP is the logic
of no class of frames. On the other hand, a suitable class of relational models for
which GLP is sound and complete was developed in [5]. However, these models
are sufﬁciently complicated to warrant a search for an alternative and simpler kind
of semantics.
Many standard modal logics enjoy a natural topological interpretation. Topolog-
ically, propositions are interpreted as subsets of a topological space and boolean
connectives correspond to the standard set-theoretic operations. For logics contain-
ing the reﬂection axiom ϕ →3ϕ, one usually interprets the modal 3 as the closure
operator of a topological space. However, provability logics fall outside this class
due to the presence of L¨ob’s axiom which contradicts reﬂection. For these logics
one takes a different approach that reads 3 as the derived set operator d mapping a
set A to the set of limit points of A. The study of this interpretation was suggested
in the Appendix of [25], and was developed by Esakia (see [13, 14] and [7] for a
survey). In particular, Esakia noticed that a topological space satisﬁes L¨ob’s axiom
iff it is scattered. The concept of a scattered space goes all the way back to Cantor.
Typical examples of scattered spaces are ordinals (in the interval topology). In fact,
it was shown independently by Abashidze [2] and Blass [10] that the provability
logic GL is complete with respect to any ordinal α ≥ωω.
When generalizing topological interpretation to several modalities we deal with
polytopological spaces; that is, sets equipped with several topologies τ0, τ1, ...
The corresponding derived set operators d0, d1, ... then interpret the diamond
modalities ⟨0⟩, ⟨1⟩, ... of our language in the usual way. The axioms of GLP
impose restrictions on the relevant class of polytopological spaces, which leads to
the concept of a GLP-space (or, of a GLB-space for the language with just two
modalities).
It is well known that GL is complete with respect to its relational semantics; in
fact, GL is the logic of ﬁnite irreﬂexive transitive trees (see, e.g., [11]). In contrast,
GLB is incomplete with respect to its relational semantics. But the main result of
this paper states that GLB is topologically complete. Thus, GLB appears to be
the ﬁrst naturally occurring example of a modal logic which is topologically com-
plete but incomplete with respect to its relational semantics (artiﬁcial examples of
this kind have already been known; see, e.g., [15,16]). It is also worth pointing out
that in [26] it was stated as an open problem whether there existed a topologically
complete but relationally incomplete ﬁnitely axiomatizable modal logic. The ques-

On Topological Models of GLP
137
tion was stated for the case of modal logics with one modality and in this stronger
form it still remains open. Nevertheless, since GLB is ﬁnitely axiomatizable, our
results provide an answer to the bimodal version of the problem.
Our technique (which is based on the construction in [5]) does not obviously
extend to the case with three or more modalities. Therefore, the topological com-
pleteness of GLP remains an interesting open problem. At the end of the paper
we discuss some negative results indicating that the situation here could be signif-
icantly more complicated and the question of topological completeness of GLP
might be independent of the axioms of Zermelo–Fraenkel set theory ZFC with the
axiom of choice.
On the other hand, the third author of this paper established the topological com-
pleteness of the closed fragment of GLP (in the language with ω-many modali-
ties) with respect to a natural polytopological space on the ordinal ϵ0 (see [17,18]).
However, this space fails to be a GLP-space.
The paper is organized as follows. In Section 2 we introduce GLP and its
bimodal fragment GLB, and discuss their relational, algebraic, and topological
semantics. We also discuss Stone-like duality for GLP-algebras and the resulting
descriptive frames. In Section 3 we prove topological completeness of GLB with
respect to the class of GLB-spaces. We ﬁnish the paper with a discussion of some
further results and remaining open questions.
2 Relational, algebraic, and topological semantics for GLP .
2.1 GLP and its relational semantics
GLP is a propositional modal logic formulated in a language with inﬁnitely many
modalities [0], [1], [2], . .. As usual, ⟨n⟩ϕ stands for ¬[n]¬ϕ.
Deﬁnition 2.1. GLP is given by the following axiom schemata and rules.
Axioms:
(i) Boolean tautologies;
(ii) [n](ϕ →ψ) →([n]ϕ →[n]ψ);
(iii) [n]([n]ϕ →ϕ) →[n]ϕ (L¨ob’s axiom);
(iv) [m]ϕ →[n]ϕ, for m < n;
(v) ⟨m⟩ϕ →[n]⟨m⟩ϕ, for m < n.

138
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
Rules:
(i) ⊢ϕ, ⊢ϕ →ψ ⇒⊢ψ (modus ponens);
(ii) ⊢ϕ ⇒⊢[n]ϕ, for each n ∈ω (necessitation).
In other words, for each modality we have the G¨odel-L¨ob Logic GL, and (iv)
and (v) are the two axioms relating modalities to one another.
We denote by GLB the bimodal fragment of GLP, restricted to the language
with only [0] and [1], and by GLP0 the letterless fragment of GLP, restricted to
the language without variables (we assume propositional constants ⊤and ⊥to be
part of the language).
As usual, we would like to know what class of frames, if any, these logics deﬁne.
Relational models of GLP0 have been studied extensively, ﬁrst in [19] and [20],
and later in [6]; see also [17, 18]. Unfortunately, for the fragments with variables,
and already in the case of GLB, there is no single non-trivial frame for which we
have soundness. To see this, we brieﬂy recall relational semantics for GL.
A (unimodal) frame is a pair F = ⟨W, R⟩, where W is a nonempty set and R is a
binary relation on W; F is transitive if wRvRu implies wRu for each w, v, u ∈W
and irreﬂexive if wRw for no w ∈W; a transitive frame F is dually well-founded
if for each nonempty subset U of W there exists w ∈U such that wRu for no
u ∈U. In such a case we call R a dually well-founded relation. It is well known
that F ⊨GL iff F is dually well-founded. Typical examples of dually well-founded
frames are ﬁnite transitive irreﬂexive frames, and in fact, GL is the logic of these
(see, e.g., [11]).
Next we recall that a (polymodal) frame is a tuple F = ⟨W, {Rn}n∈ω⟩, where W
is a nonempty set and each Rn is a binary relation on W. For A ⊆W let −A denote
the complement of A in W. We recall that a valuation is a map v : Var →2W
from the set of propositional variables to the powerset of W and that v extends to
all formulas as follows:
• v(ϕ ∨ψ) = v(ϕ) ∪v(ψ), v(¬ϕ) = −v(ϕ), v(⊤) = W, v(⊥) = ∅,
• v(⟨n⟩ϕ) = {x ∈W : ∃y (xRny & y ∈v(ϕ))}
• v([n]ϕ) = {x ∈W : ∀y (xRny ⇒y ∈v(ϕ))}.
We will write F, x ⊨v ϕ for x ∈v(ϕ). If v is ﬁxed, we abbreviate F, x ⊨v ϕ by
F, x ⊨ϕ or even x ⊨ϕ. A formula ϕ is valid in F, denoted F ⊨ϕ, if v(ϕ) = W
for all v.
In order for F to be a GLP-frame, each Rn should be a dually well-founded
relation and in addition F should validate axioms (iv) and (v). The next lemma,
which is well-known, gives necessary and sufﬁcient conditions for this.

On Topological Models of GLP
139
Lemma 2.2. Let m < n. Then:
1. F ⊨[m]ϕ →[n]ϕ iff wRnv implies wRmv.
2. F ⊨⟨m⟩ϕ →[n]⟨m⟩ϕ iff wRmv and wRnu imply uRmv.
Proof. See, e.g., [11].
Remark 2.3. Let F be a (polymodal) frame, R−1
n
denote the inverse of Rn,
Rn(U) := {w ∈W : ∃u ∈U, uRnw}, and R−1
n (U) := {w ∈W : ∃u ∈
U, wRnu}. We call U an Rn-upset if it is upward closed with respect to Rn; that
is, u ∈U and uRnw imply w ∈U. (Similarly, we call U an Rn-downset if u ∈U
and wRnu imply w ∈W.) Then axiom (iv) states that Rn ⊆Rm and axiom (v)
states that each set of the form R−1
m (U) is an Rn-upset.
We show that no non-trivial frame satisﬁes all of these requirements. Suppose for
a contradiction that GLB is sound with respect to a frame F with R1 nonempty.
Then there are w, v ∈W such that wR1v. By Lemma 2.2(1), wR0v, and by
Lemma 2.2(2), vR0v, which contradicts to R0 being dually well-founded. Con-
sequently, if F ⊨GLB then R1 = ∅, so [1]⊥becomes valid. This obviously
generalizes to GLP. Thus, we obtain:
Theorem 2.4. GLP is incomplete with respect to its class of frames. In particular,
GLP is not sound on any frame for which Rn ̸= ∅for n > 0.
2.2 Algebraic semantics and descriptive frames
As we saw, GLP is incomplete with respect to relational semantics, and as we will
see, topological completeness of GLP remains an open problem. Nevertheless,
there is a semantics for which completeness of GLP is automatic, viz. algebraic
semantics. Of course, algebraic semantics is not as informative as either relational
or topological semantics, but completeness is straightforward through the well-
known Lindenbaum construction. Moreover, Stone-like duality for GLP-algebras
can be developed without much trouble.
We recall that a pair A = ⟨B, δ⟩is a GL-algebra (also known as a diagonaliz-
able algebra or a Magari algebra) if B is a boolean algebra and δ : B →B is a
unary function on B such that δ0 = 0, δ(a ∨b) = δa ∨δb, and δa = δ(a −δa).
Given a GL-algebra A = ⟨B, δ⟩, let τa = −δ(−a). It is well known that if we in-
terpret formulas as elements of a GL-algebra A = ⟨B, δ⟩, boolean connectives as
boolean operations of B, and 3 as δ (and hence 2 as τ), then GL-algebras provide
an adequate semantics for GL.

140
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
Deﬁnition 2.5. We call a tuple A = ⟨B, {δn}n∈ω⟩a GLP-algebra if
(i) ⟨B, δn⟩is a GL-algebra for each n ∈ω;
(ii) δna ≤δma for each m < n and a ∈B;
(iii) δma ≤τnδma for each m < n and a ∈B.
In particular, a triple A = ⟨B, δ0, δ1⟩is a GLB-algebra if both ⟨B, δ0⟩and ⟨B, δ1⟩
are GL-algebras, δ1a ≤δ0a, and δ0a ≤τ1δ0a for each a ∈B.
A standard argument shows that GLP-algebras provide an adequate semantics
for GLP, and GLB-algebras provide an adequate semantics for GLB. We give
three types of examples of GLP-algebras.
Example 2.6 (free algebras). Free n-generated GLP-algebras, also known as Lin-
denbaum algebras, are obtained from the set of all formulas of GLP in the lan-
guage with n propositional variables by identifying GLP-equivalent formulas and
deﬁning the boolean algebra operations by logical connectives. The modal oper-
ators δn map the equivalence class of a formula ϕ to the equivalence class of the
formula ⟨n⟩ϕ. In particular, the free 0-generated algebra is the Lindenbaum algebra
of the letterless fragment GLP0.
Another kind of GLP-algebras come from GLP-spaces (see next section).
Example 2.7. Let X be a GLP-space. The boolean algebra of all subsets of
X enriched with the derived set operators dn, for each n ≥0, acting on 2X is
obviously a GLP-algebra.
Perhaps the most intriguing examples of GLP-algebras come from proof theory,
where they have been introduced under the name of graded provability algebras [3].
Example 2.8 (provability algebras). Let T be a ﬁrst order arithmetical theory
containing a sufﬁciently large fragment of Peano arithmetic PA. T is called n-
consistent if the union of T and all true Πn-sentences is consistent. If ϕ is an
arithmetical sentence, let ⟨n⟩T ϕ denote a natural formalization of the statement
that the theory T + ϕ is n-consistent. (Such a formalization is equivalent to the
so-called uniform Σn-reﬂection principle for T + ϕ.)
This deﬁnes a function
δn : ϕ →⟨n⟩T ϕ, which is correctly deﬁned on the equivalence classes of sen-
tences modulo provable equivalence in T. The Lindenbaum algebra of T enriched
with all the operators δn happens to be a GLP-algebra. This example plays a
fundamental role in the proof-theoretic analysis of PA based on provability logic
(see [3,4]).

On Topological Models of GLP
141
Of course, GLP-algebras (respectively, GLB-algebras) in general are rather
abstract entities. Therefore, it is desirable to have a good representation for them.
This is done through the well-known Stone construction.
Let X be a topological space. We recall that a subset A of X is clopen if A
is both closed and open, and that X is zero-dimensional if clopen subsets form a
basis for X. We also recall that X is a Stone space if it is compact, Hausdorff, and
zero-dimensional.
It is a celebrated result of Stone that boolean algebras can be represented as
the algebras of clopen subsets of Stone spaces. We recall that given a boolean
algebra B, the dual Stone space X of B is constructed as the space of ultraﬁlters
of B and that a topology on X is deﬁned by declaring {ϕ(a) : a ∈B} to be a
basis for the topology, where ϕ(a) = {x ∈X : a ∈x}. Let Cp(X) denote
the set of clopen subsets of X. Then Cp(X) with set-theoretic operations ∩, ∪, −
is a boolean algebra, and ϕ : B →Cp(X) is a boolean algebra isomorphism.
This 1-1 correspondence between boolean algebras and Stone spaces extends to a
categorical dual equivalence between the category of boolean algebras and boolean
algebra homomorphisms and the category of Stone spaces and continuous maps.
This representation of boolean algebras was extended to a representation of GL-
algebras by Magari [24] and by Esakia and Abashidze [1] (see also [12] and [8]).
Let X be a Stone space and R a transitive relation on X. For a clopen A ⊆X
we call x ∈A a strongly maximal point of A if xRy for no y ∈A. In particular,
a strongly maximal point is irreﬂexive. Now we call a pair ⟨X, R⟩a descriptive
GL-frame if X is a Stone space and R is a transitive binary relation on X such
that R(x) is closed for each x ∈X, A clopen implies R−1(A) is clopen, and for
each clopen A and x ∈A, either x is strongly maximal or there exists a strongly
maximal point y ∈A such that xRy.1
Let ⟨B, δ⟩be a GL-algebra and let X be the Stone space of B. We deﬁne R on
X by xRy iff a ∈y implies δa ∈x for each a ∈B. Since in each GL-algebra
we have δδa ≤δa, it is easy to verify that R is transitive. It is also standard to
show that R(x) is closed for each x ∈X, A clopen implies R−1(A) is clopen, and
ϕ(δa) = R−1(ϕ(a)). In fact, ⟨X, R⟩is a descriptive GL-frame. This follows from
the following lemma proved in [1].
Lemma 2.9. If ⟨B, δ⟩is a GL-algebra and ⟨X, R⟩is the dual of ⟨B, δ⟩, then
⟨X, R⟩is a descriptive GL-frame.
Proof. (Sketch) Let A be a clopen subset of X. It is sufﬁcient to show that for each
x ∈A, either x is a strongly maximal point or there exists a strongly maximal point
y ∈A such that xRy. If x /∈R−1(A), then x is a strongly maximal point. Suppose
1Descriptive GL-frames were called strong transits in [1].

142
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
that x ∈R−1(A). Since A is clopen, there exists a ∈B such that A = ϕ(a).
Therefore, x ∈R−1(ϕ(a)). As R−1(ϕ(a)) = ϕ(δa), we obtain x ∈ϕ(δa). But
δa = δ(a−δa). Thus, x ∈ϕ(δ(a−δa)) = R−1(ϕ(a−δa)). This implies that there
exists y ∈ϕ(a −δa) such that xRy. Now as y ∈ϕ(a −δa) = ϕ(a) −R−1(ϕ(a)),
y must be a strongly maximal point of ϕ(a) = A.
It follows that if A = ⟨B, δ⟩is a GL-algebra, then X = ⟨X, R⟩is a descriptive
GL-frame and ϕ : ⟨B, δ⟩→⟨Cp(X), R−1⟩is an isomorphism of GL-algebras.
Thus, each GL-algebra can be represented as the algebra of clopen subsets of the
corresponding descriptive GL-frame. In particular, if A is countable, then X is
second-countable.
As in the case of boolean algebras and Stone spaces, this representation extends
to a dual equivalence of the appropriate categories, however we will not address
this here and refer the interested reader to [1,8].
This representation of GL-algebras extends in an obvious way to GLP-algebras
and GLB-algebras.
Deﬁnition 2.10. We call a tuple X = ⟨X, {Rn}n∈ω⟩a descriptive GLP-frame if
(i) ⟨X, Rn⟩is a descriptive GL-frame for each n ∈ω;
(ii) Rn ⊆Rm for each m < n;
(iii) xRmy and xRnz imply zRmy for each m < n.
In particular, a triple X = ⟨X, R0, R1⟩is a descriptive GLB-frame if both ⟨X, R0⟩
and ⟨X, R1⟩are descriptive GL-frames, R1 ⊆R0, and xR0y and xR1z imply
zR0y.
Let A = ⟨B, {δn}n∈ω⟩be a GLP-algebra, X the Stone space of B, and xRny
iff a ∈y implies δna ∈x for each n ∈ω and a ∈B.
Lemma 2.11.
If A
=
⟨B, {δn}n∈ω⟩is a GLP-algebra,
then X
=
⟨X, {Rn}n∈ω⟩is a descriptive GLP-frame. Moreover, ϕ : ⟨B, {δn}n∈ω⟩→
⟨Cp(X), {R−1
n }n∈ω⟩is an isomorphism of GLP-algebras.
Proof. In view of the representation of GL-algebras, all we have to verify is that
Rn ⊆Rm and xRmy and xRnz imply zRmy for each m < n. Let xRny and
a ∈y. Then δna ∈x. Since δna ≤δma, also δma ∈x. Therefore, xRmy, and so
Rn ⊆Rm. Now let xRmy and xRnz. Suppose that a ∈y. Since xRmy, we have
δma ∈x. If δma /∈z, then −δma ∈z. As xRnz, we have δn(−δma) ∈x. But
δma ∈x and δma ≤−δn(−δma) imply −δn(−δma) ∈x, a contradiction. Thus,
δma ∈z, and so zRmy.

On Topological Models of GLP
143
In particular, Lemma 2.11 implies that if A = ⟨B, δ0, δ1⟩is a GLB-algebra,
then X = ⟨X, R0, R1⟩is a descriptive GLB-frame, and ϕ : ⟨B, δ0, δ1⟩→
⟨Cp(X), R−1
0 , R−1
1 ⟩is an isomorphism of GLB-algebras.
2.3 Topological semantics
Our main interest in this paper is in topological semantics. Ordinarily, when modal
logics are interpreted topologically, modal diamond is read as topological closure.
However, as we already pointed out in the introduction, this only works if the logic
in question contains the reﬂection axiom, since each set is a subset of its closure.
For logics that do not contain the reﬂection axiom, of which GL, GLB, and GLP
are all examples, 3 can instead be interpreted as the derived set operator.
Deﬁnition 2.12. Let X be a topological space and A ⊆X. We recall that x ∈X is
a limit point of A if for each neighborhood U of x we have A∩(U −{x}) ̸= ∅. Let
d(A) denote the set of limit points of A. As usual, we call d(A) the derived set of
A. Obviously, the topological closure of A can then be deﬁned as cl(A) = A∪d(A)
and topological interior as int(A) = A ∩t(A), where t(A) := −d(−A).
Interpreting 3 as a derived set operator provides an adequate semantics for GL.
Let X be a topological space and let v : Var →2X be a valuation. We extend v to
the set of all formulas by setting
• v(ϕ ∨ψ) = v(ϕ) ∪v(ψ), v(¬ϕ) = −v(ϕ), v(⊤) = X, v(⊥) = ∅,
• v(3ϕ) = d(v(ϕ)), v(2ϕ) = t(v(ϕ)).
We will also write X, x
top
⊨v ϕ for x ∈v(ϕ). When the valuation v is clear from the
context this can also be written as X, x
top
⊨ϕ.
Deﬁnition 2.13. A formula ϕ is valid in X (denoted X
top
⊨ϕ) if ∀v, v(ϕ) = X.
The logic of X is the set of all formulas valid in X. If C is a class of spaces, the
logic of C is the set of formulas valid in all members X ∈C.
Given a topological space X, we recall that x ∈X is an isolated point of X
if {x} is an open subset of X. Note that the set of isolated points of a subspace
Y of X coincides with Y −d(Y ). We call X a scattered space if each nonempty
subspace of X has an isolated point.
Theorem 2.14 ( [13]). A topological space X is scattered iff X
top
⊨GL; moreover,
GL is the logic of the class of all scattered spaces.

144
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
Typical examples of scattered spaces are ordinals (in the interval topology). The-
orem 2.14 can be improved by showing that GL is the logic of all ordinals. In fact,
GL is the logic of any ordinal α ≥ωω:
Theorem 2.15 ( [2,10]). GL is the logic of the class of all ordinals. In fact, GL
is the logic of any ordinal α ≥ωω. In particular, GL is the logic of ωω.2
For the case of the polymodal language of GLP we consider polytopological
spaces; that is, sets X equipped with a family of topologies {τn}n∈ω. As our
immediate task, we would like to understand which polytopological spaces satisfy
all the axioms of GLP.
Let X = ⟨X, {τn}n∈ω⟩be a polytopological space. Let, for each n ∈ω, dn
denote the derived set operator and tn its dual with respect to τn. Theorem 2.14
tells us that each τn should be a scattered topology. Now we give necessary and
sufﬁcient conditions for axioms (iv) and (v) to be valid in X.
Proposition 2.16. Let X = ⟨X, {τn}n∈ω⟩be a polytopological space and let m <
n.
1. For each A ⊆X we have dm(A) is τn-open iff dm(A) ⊆tn(dm(A)).
2. τm ⊆τn iff dn(A) ⊆dm(A) for each A ⊆X.
Proof. (1) We have:
dm(A) is τn-open iff dm(A) = intn(dm(A))
iff dm(A) = dm(A) ∩tn(dm(A))
iff dm(A) ⊆tn(dm(A)).
(2) Let τm ⊆τn. Suppose that A ⊆X, x ∈dn(A), and U is a τm-open
neighborhood of x. Then U is also a τn-open neighborhood of x, and so A ∩
(U −{x}) ̸= ∅, which implies that x ∈dm(A). Conversely, let τm ̸⊆τn. Then
there exists U ∈τm such that U /∈τn. Since U /∈τn, there exists x ∈U such
that for each τn-open neighborhood V of x we have V ∩−U ̸= ∅. Therefore,
U ∩dn(−U) ̸= ∅and yet U ∩dm(−U) = ∅. Thus, dn(−U) ⊈dm(−U).
Theorem 2.14 and Proposition 2.16 suggest the following deﬁnition of a GLP-
space.
Deﬁnition 2.17. Let X = ⟨X, {τn}n∈ω⟩be a polytopological space. We call X a
GLP-space if
2For a simpliﬁed proof of this result we refer to [9].

On Topological Models of GLP
145
(i) Each τn is a scattered topology;
(ii) τn ⊆τn+1;
(iii) dn(A) is τn+1-open for each A ⊆X.
In particular, a bitopological space ⟨X, τ0, τ1⟩is a GLB-space if both τ0 and τ1
are scattered topologies, τ0 ⊆τ1, and d0(A) is τ1-open for each A ⊆X.
Note that, because of condition (ii), condition (i) can be weakened to the re-
quirement that only τ0 be scattered. From Theorem 2.14 and Proposition 2.16 we
directly obtain:
Theorem 2.18. A polytopological space X = ⟨X, {τn}n∈ω⟩is a GLP-space iff
X
top
⊨GLP, and a bitopological space ⟨X, τ0, τ1⟩is a GLB-space iff X
top
⊨GLB.
An obvious question is whether GLP (resp. GLB) is complete with respect
to this semantics. But ﬁrst we should be able to give examples of GLP-spaces
(resp. GLB-spaces). Note that conditions (i) and (ii) are natural topological condi-
tions and are easy to satisfy. On the other hand, condition (iii) is rather strong and
somewhat unusual. Nevertheless, we will see shortly how to satisfy it.
Of course, if ⟨X, τ0⟩is a scattered space and τ1 is a discrete topology on X, then
⟨X, τ0, τ1⟩is trivially a GLB-space. The ﬁrst example of a GLB-space with two
non-discrete topologies was given by Leo Esakia (private communication).
Example 2.19 (Esakia space). Let α be an ordinal. Let τ0 consist of all <-downsets
and let τ1 be the interval topology. It is easy to verify that both τ0 and τ1 are
scattered topologies and that τ0 ⊂τ1. Let A ⊆α. To see that d0(A) is τ1-open
observe that d0(A) = {x ∈α : x > min(A)}, which is clearly τ1-open. Thus,
⟨α, τ0, τ1⟩is a GLB-space.
On the other hand, the next lemma shows that in order to deﬁne a third non-
discrete topology on α, the ordinal should be very large. Recall that a topological
space X is ﬁrst-countable if every point x ∈X has a countable basis of open
neighborhoods.
Proposition 2.20. For any GLB-space ⟨X, τ0, τ1⟩, if τ0 is Hausdorff and ﬁrst-
countable, then τ1 is discrete.
Proof. It is easy to see that if ⟨X, τ0⟩is ﬁrst-countable and Hausdorff, then every
point a ∈X is a (unique) limit of a countable sequence of points A = {an}n∈ω.
Hence, there is a set A ⊆X such that d0(A) = {a}. By condition (iii), this means
that {a} is τ1-open.

146
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
Going back to ⟨α, τ0, τ1⟩, observe that ⟨α, τ1⟩is always Hausdorff, and that
⟨α, τ1⟩is ﬁrst-countable iff α ≤ω1. Therefore, in order for us to be able to deﬁne a
non-discrete τ2 on α, the ordinal should be at least ω1 +1. This is, in fact, sufﬁcient
as the following example shows.
Example 2.21 (club topology). Recall that coﬁnality cf(α) of a limit ordinal α is
the least order type of an unbounded subset of α. If α is not a limit ordinal, we
set cf(α) = 0. A set A ⊆α is called a club in α if it is τ1-closed (in the interval
topology on α) and unbounded in α.
Deﬁne a topology τ2 on α as follows: a set U is τ2-open if, for each β ∈U,
either cf(β) ≤ω or there is a club C in β such that C ⊆U.
If cf(β) > ω, the intersection of countably many clubs in β is again a club.
Hence, it is easy to check that τ2 is indeed a topology. The ﬁlter of neighborhoods
of β in τ2 (restricted to β) coincides with the so-called club ﬁlter on β — a well-
known concept in set theory (see [23]). Therefore, we call this topology the club
topology.
Proposition 2.22. ⟨α, τ1, τ2⟩is a GLB-space. In fact, the club topology τ2 is the
coarsest topology τ such that ⟨α, τ1, τ⟩is a GLB-space.
Proof. To verify condition (iii) notice that a set of the form d1(A) ∩β is a club in
any β ∈d1(A). Hence, d1(A) is τ2-open. The other conditions are obvious.
On the other hand, assume ⟨α, τ1, τ⟩is a GLB-space. We show that every τ2-
open neighborhood of any β ∈α contains a τ-open neighborhood. If cf(β) ≤ω
then either β is isolated already in τ1 (in the case β is not a limit ordinal), or β is
a unique limit of an increasing ω-sequence A of ordinals. Then {β} = d1(A) and
hence β is isolated in τ. If cf(β) > ω and C is a club in β, then d1(C) ⊆C ∪{β}
is a τ-open neighborhood of β.
We are mainly interested in topological completeness of GLP and GLB. Note
that no Esakia space can be an exact model of GLB. Looking at ⟨α, τ0, τ1⟩, ob-
serve that τ0 consists of the <-downsets of α. Since α is a linear order, the linearity
axiom [0]([0]+p →q) ∨[0]([0]+q →p) is valid in ⟨α, τ0, τ1⟩, where [0]+ϕ is an
abbreviation of ϕ ∧[0]ϕ.
As far as the GLB-space ⟨α, τ1, τ2⟩is concerned, the situation is more compli-
cated. We know that it is consistent with ZFC that GLB is incomplete with respect
to this space. This follows from a result of Blass [10] who analyzed the question
of completeness of GL with respect to the club topology τ2.3 In particular, he has
shown that it is consistent with ZFC that GL is incomplete with respect to τ2 on
3Blass did not introduce the topology explicitly, but formulated an equivalent semantics in terms of the
club ﬁlter.

On Topological Models of GLP
147
any ordinal. He has also shown that, under the assumption V = L, GL is complete
with respect to the space ⟨ℵω, τ2⟩. We conjecture that this result can be extended to
a completeness result for GLB with respect to ⟨ℵω, τ1, τ2⟩.
In the next section we will be able to prove topological completeness of GLB
while standing ﬁrmly on the basis of ZFC. However, the question of topological
(in)completeness of any fragment of GLP with more than two modalities remains
open. At the least, our method of proving completeness of GLB does not immedi-
ately generalize to three or more modalities.
While the full GLP, so far, eludes completeness, we note that the letterless frag-
ment GLP0 allows for a simple topological treatment. Namely, GLP0 is sound and
complete with respect to a natural polytopological space deﬁned on the ordinal ϵ0.
This space, however, is not a GLP-space (see [17,18]).
3 Topological Completeness of GLB
In this section we work in the language with two modalities [0] and [1]. Before we
prove our main result, we need a few auxiliary notions.
3.1 The logic J
Our proof of topological completeness will make use of a subsystem of GLB in-
troduced in [5] and denoted J. This logic is deﬁned by weakening axiom (iv) of
GLB to the following axioms (vi) and (vii) both of which are theorems of GLB:
(vi) [0]ϕ →[1][0]ϕ;
(vii) [0]ϕ →[0][1]ϕ.
J is the logic of a simple class of frames, which is established by standard methods
( [5, Theorem 1]).
Lemma 3.1. J is sound and complete with respect to the class of (ﬁnite) frames
⟨W, R1, R2⟩such that, for all x, y, z ∈W,
1. R0 and R1 are transitive and dually well-founded;
2. If xR1y, then xR0z iff yR0z;
3. xR0y and yR1z imply xR0z.

148
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
If we let R1 denote the reﬂexive, symmetric, transitive closure of R1, then we
call each R1 equivalence class a 1-sheet. By (2), all points in a 1-sheet are R0
incomparable. But R0 deﬁnes a natural ordering on 1-sheets in the following sense:
if α and β are 1-sheets, then αR0β, iff ∃x ∈α, ∃y ∈β, xR0y. By standard
techniques, one can improve on Lemma 3.1 to show that J is complete for such
frames, in which each 1-sheet is a tree under R1, and if αR0β then xR0y for all
x ∈α, y ∈β (see [5, Theorem 2 and Corollary 3.3]). Thus, models of J can be
seen as R0-orders (and even tree-like orders), in which the nodes are 1-sheets that
are themselves R1-trees. We call such frames tree-like J-frames.
As shown in [5], GLB is reducible to J in the following sense. Let
M(ϕ) :=

i<s
([0]ϕi →[1]ϕi),
where [0]ϕi, i < s, are all subformulas of ϕ of the form [0]ψ. Also, let
M +(ϕ) := M(ϕ) ∧[0]M(ϕ) ∧[1]M(ϕ).
Proposition 3.2 ( [5]). GLB ⊢ϕ iff J ⊢M +(ϕ) →ϕ.
This proposition generalizes straightforwardly to the case of GLP. In fact, we
obtain another proof of this proposition, for the case of GLB, as a byproduct of
the topological completeness proof below.4
3.2 Some notions related to partial orderings
Let ⟨X, ≺⟩be a dually well-founded strict partial ordering. We consider bitopolog-
ical spaces of the form ⟨X, τ0, τ1⟩, where τ0 is the upset topology on ⟨X, ≺⟩and
τ1 is generated by all semi-open intervals of the form
[a, b) := {x ∈X : a ⪯x ≺b}
for a ≺b, and
[a, ∞) := {x ∈X : a ⪯x}.
Notice that if ⟨X, ≺⟩is a strict linear ordering, then τ1 is the usual interval topology
on X, and thus ⟨X, τ0, τ1⟩is the Esakia space of the ordinal dual to ⟨X, ≺⟩.
Lemma 3.3. ⟨X, τ0, τ1⟩is a GLB-space.
4It is worth noting that Ignatiev’s proof of arithmetical completeness of GLP establishes a similar
reduction of GLP to a different frame complete subsystem of GLP.

On Topological Models of GLP
149
Proof. Clearly τ0 ⊆τ1. We show that sets of the form d0(A) are τ1-open for any
A ⊆X. Let max(A) denote the set of maximal points of A. Since ⟨X, ≺⟩is dually
well-founded, d0(A) consists of all points below max(A); that is,
d0(A) =

a≺b∈max(A)
[a, b).
Hence, d0(A) is a union of τ1-open sets.
We call such GLB-spaces general Esakia spaces.
Next, we recall a few standard operations on strict partial orderings.5 The disjoint
union of the orderings X and Y is denoted X ⊔Y . The sum of X and Y is denoted
X + Y ; that is, the ordering is obtained by putting Y on top of X. In particular,
when X is a singleton {a}, {a} + Y denotes the result of adding a new node at the
bottom of Y .
A more general operation of ordered sum of a family {Ai : i ∈I} of orderings
Ai = ⟨Ai, ≺i⟩, where ⟨I, ≺⟩is a strict partially ordered index set, is the ordering
⟨Y, ≺Y ⟩such that Y = 
i∈I Ai. For x, y ∈Y , we declare x ≺Y y iff either
x, y ∈Ai and x ≺i y for some i ∈I; or x ∈Ai and y ∈Aj for some i ≺j.
We denote this ordering by 
i∈I Ai. In particular, if ⟨I, ≺⟩is the ordering ⟨ω, >⟩
and all Ai are isomorphic to the same ordering A, the ordering 
i∈I A consists of
countably many copies of A ordered by ω∗and is denoted A · ω∗.
3.3 Topological completeness theorem
Theorem 3.4 (Main Theorem). GLB is complete w.r.t. the class of general Esakia
spaces.
Proof. Assume GLB ⊬ϕ. Consider a ﬁnite tree-like J-model A such that A ⊭
M +(ϕ) →ϕ. We denote by Greek letters α, β, . . . the elements of A.
Following [5], we associate with A a strict partial ordering called the topological
blow-up of A. First, we associate with each 1-sheet S of A a strict partial ordering
Sω by induction on the R1-depth of S. Second, we consider the set S(A) of all
1-sheets of A ordered by R0 and take the ordered sum of orders Sω with respect to
this index set. This idea is expressed by the following two formal deﬁnitions.
5The notations we use are dual to those given in [5], but they are more in line with the standard usage.

150
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
Deﬁnition 3.5.
• If Aα = ⟨Aα, R1⟩is a tree with the root α, deﬁne a strict partial ordering Aω
α
by induction on the depth of α:
Aω
α := {α} +
 n
 
i=1
Aω
αi

· ω∗,
where αi are all the R1-children of α. Aω
α := {α} if Aα is the singleton {α}.
• Bω(A) := 
S∈S(A) Sω.
The ordering Bω(A) is called the topological blow-up of A and will deﬁne the
general Esakia space we seek. The order relation on Bω(A) will be denoted ≺; τ0
and τ1 are the topologies of the associated general Esakia space; d0 and d1 are the
corresponding derived set operators.
It is worth noting that the blow-up construction here is much simpler than the one
in [5] for two main reasons. Firstly, we only deal with the case of two modalities
which avoids the iterative process involved in [5] and the complicated limit con-
struction. Secondly, the type of the resulting structure is simpler (it is just a strict
partial order) and, in addition, it needs fewer new points. The latter seems to be
a helpful feature of the topological semantics we consider compared to relational
semantics.
Next, we make a couple observations about the deﬁned structures. Firstly, there
is a natural embedding of Aω
β as an upset into Aω
α whenever α ≺β. This is easy
to verify by induction on R1-depth of α. Secondly, a natural projection map πα :
Aω
α →Aα is deﬁned inductively as follows: if x ∈Aω
αi, then πα(x) := παi(x);
otherwise, πα(x) := α. This extends to a map π : Bω(A) →A in the obvious
way.
Lemma 3.6.
1. Assume x ∈Aω
α and πα(x)R1y in Aα. Then there is a sequence (xn)n∈ω ∈
Aω
α such that x ∈d1({xn : n ∈ω}) and πα(xn) = y for all n ∈ω.
2. For all x, y ∈Bω(A), if π(x)R1y, then x ∈d1(π−1(y)).
Proof. (1) We argue by induction on the R1-depth of α. If α has depth 0, the claim
is trivial (no such x, y exist). Otherwise, Aω
α = {α} +
n
i=1 Aω
αi

· ω∗.
If x belongs to some copy of Aω
αi, we can select a sequence xn in (the same
copy of) Aω
αi by the induction hypothesis. We obviously have that πα(xn) = y by
the deﬁnition of πα. Also, x ∈d1({xn : n ∈ω}) in Aω
αi. Since ⟨Aω
αi, τ1⟩is a

On Topological Models of GLP
151
subspace of ⟨Aω
α, τ1⟩(any interval in one space is an interval in the other), we also
have x ∈d1({xn : n ∈ω}) in Aω
α.
If x is the root of Aω
α, then πα(x) = α. Suppose y is an immediate successor of
α. Then Aω
α contains a sequence of copies of Aω
y the roots of which converge to x.
Otherwise, let β be the son of α such that β ≺y. Select an element z ∈Aω
β such
that πβ(z) = y. Let zn be the element corresponding to z within the n-th copy of
Aω
β above x. Then zn’s converge to x in Aω
α.
(2) If π(x)R1y, then π(x), y belong to the same 1-sheet Aα, x ∈Aω
α and π = πα
on Aω
α. Hence, one can apply (1) and obtain a sequence (xn) in Aω
α such that
xn ∈π−1(y) and x ∈d1({xn : n ∈ω}).
Lemma 3.7. For all x, y ∈Bω(A), if x ∈d1(Y ), then π(x)R1π(y) for inﬁnitely
many y ∈Y .
Proof. Let Aα be the 1-sheet of π(x). If x ∈d1(Y ), then Y is inﬁnite because τ1
is a T1-topology; that is, each ﬁnite set is closed. Since Aω
α is a semi-open interval
in Bω(A), there are inﬁnitely many y ∈Y such that y ∈Aω
α. Without loss of
generality assume that this holds for all y ∈Y and that x /∈Y . We prove that
π(x)R1π(y) for inﬁnitely many y ∈Y by induction on the R1-depth of α.
If the depth of α is 0, then Aω
α = {α}. Therefore, all y ∈Y must coincide with
α, contradicting that Y is inﬁnite. Otherwise, Aω
α = {α} +
n
i=1 Aω
αi

· ω∗.
Suppose x belongs to some copy of Aαi. Since this copy is a semi-open inter-
val in Aω
α, inﬁnitely many y ∈Y are in this interval. By induction hypothesis,
π(x)R1π(y) for inﬁnitely many y ∈Y .
If x is the root of Aω
α, then π(x) = πα(x) = α. If y ∈Y then y ̸= x by
assumption, and by the construction of Aω
α, π(y) ̸= π(x) = α. Since π(y) ∈Aα
and α is the minimum of Aα, we have αR1π(y).
We deﬁne a valuation v : Var →2Bω(A) by
x ∈v(p) iff A, π(x) ⊨p.
Lemma 3.8. For each subformula ψ of ϕ,
Bω(A), x
top
⊨ψ iff A, π(x) ⊨ψ.
Proof. By induction on the build-up of ψ. We only treat the cases of modalities.
Let X := Bω(A) and v(ψ) := {x ∈X : X, x
top
⊨ψ}.
1. Suppose A, π(x) ⊨⟨1⟩ψ. Then there is a y such that π(x)R1y and A, y ⊨ψ.
Since π(x)R1y, we have x ∈d1(π−1(y)). By inductive hypothesis, π−1(y) ⊆
v(ψ), hence x ∈d1(v(ψ)) and X, x
top
⊨⟨1⟩ψ.

152
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
2. Suppose X, x
top
⊨⟨1⟩ψ. Then x ∈d1(v(ψ)). Setting Y := v(ψ), by Lemma
3.7, there is a y ∈Y such that π(x)R1π(y). By inductive hypothesis, A, π(y) ⊨ψ,
hence A, π(x) ⊨⟨1⟩ψ.
3. If A, π(x) ⊨⟨0⟩ψ, then ∃y (π(x)R0y & A, y ⊨ψ). Since π is a p-morphism,
there is a y′ ≻x such that π(y′) = y. This yields X, y′
top
⊨ψ and X, x
top
⊨⟨0⟩ψ.
4. If X, x
top
⊨⟨0⟩ψ, then ∃y (x ≺y & X, y
top
⊨ψ). We have π(x)R0π(y) or
π(x),π(y) belong to the same 1-sheet. In the ﬁrst case we are done. In the second
case, let α be the R1-maximal point such that x ∈Aω
α, and let z be the ≺-minimal
point of Aω
α. Obviously π(z) = α.
Notice that Aω
β is an upwards closed submodel of Aα whenever αR1β. Then,
since x ∈Aω
α, we must also have y ∈Aω
α; hence z ≺y. Since π(z) = α and
z ≺y, we have π(z)R1π(y). By inductive hypothesis, A, π(y) ⊨ψ and hence
A, π(z) ⊨⟨1⟩ψ. By the monotonicity axioms in A this yields A, π(z) ⊨⟨0⟩ψ.
Since π(x) belongs to the same 1-sheet as α = π(z), we also have A, π(x) ⊨
⟨0⟩ψ.
Hence, we obtain Bω(A) ̸
top
⊨ϕ, which proves the theorem.
Corollary 3.9. GLB ⊢ϕ iff J ⊢M+(ϕ) →ϕ.
Proof. The non-trivial implication from left to right follows from the proof of topo-
logical completeness theorem. We have shown that if the conclusion is false, there
must exist a GLB-space falsifying ϕ, hence GLB ⊬ϕ.
4 Discussion
We have established topological completeness results for two fragments of GLP:
for the bimodal fragment GLB, and for the the letterless fragment GLP0 (see
[18]). There are some questions that remain open, which we summarize below.
1. Is GLP topologically complete?
2. Is GLB complete with respect to the GLB-space ⟨α, τ1, τ2⟩, for some ordinal
α, under the assumption V = L? (Here, τ1 is the interval topology and τ2 is
the club topology on α.)
3. There is a natural notion of an ordinal GLP-space. Consider a space of the
form ⟨α, {τn}n∈ω⟩, where τ1 is the interval topology on α, and τn+1 is gen-
erated from τn and all sets of the form dn(A), for A ⊆α. Is GLP complete
with respect to some ordinal GLP-space?

On Topological Models of GLP
153
From the results of Blass (see our discussion of Problem 2 at the end of Sec-
tion 2.3) we know that a positive answer to Problem 3 would require some set-
theoretic assumptions outside ZFC. Some partial results in this direction have al-
ready been obtained. In particular, we know that the assumption that the third
topology τ3 of an ordinal GLP-space is nontrivial is equiconsistent with the ex-
istence of a weakly compact cardinal. In other words, non-discreteness of τ3 (and
similarly for further topologies τn) is a large cardinal assumption. We do not know
the exact consistency strength of this assumption for n > 3. However, we know a
reasonable sufﬁcient condition for all τn to be non-discrete — the existence of the
so-called Π1
n-indescribable cardinals for each n ∈ω.6 Therefore, it is hopeful to
obtain completeness of GLP with respect to an ordinal GLP-space if we simulta-
neously assume things like V = L and the existence of Π1
n-indescribable cardinals.
These results, in fact, show that there are deeper connections between the theory of
ordinal GLP-spaces and parts of set theory dealing with inﬁnitary combinatorics
and stationary reﬂection.
Acknowledgements.
The ﬁrst author initiated the work on this paper during
his stay at the University of M¨unster in the summer of 2008 at the invitation of Wol-
fram Pohlers. He acknowledges support from Alexander von Humboldt Foundation
and would like to thank Wolfram Pohlers, Ralf Schindler and the whole logic group
in M¨unster for their hospitality and for the fruitful atmosphere they have created.
References
[1] M. Abashidze. Some properties of Magari algebras. In Studies in logic and semantics,
pages 111–127. “Metsniereba”, Tbilisi, 1981. In Russian.
[2] M. Abashidze. Ordinal completeness of the G¨odel-L¨ob modal system. In Intensional
logics and the logical structure of theories, pages 49–73. Metsniereba, Tbilisi, 1985.
In Russian.
[3] L.D. Beklemishev. Provability algebras and proof-theoretic ordinals, I. Annals of Pure
and Applied Logic, 128:103–123, 2004.
[4] L.D. Beklemishev. Reﬂection principles and provability algebras in formal arithmetic.
Uspekhi Matematicheskikh Nauk, 60(2):3–78, 2005. In Russian. English translation in:
Russian Mathematical Surveys, 60(2): 197–268, 2005.
[5] L.D. Beklemishev. Kripke semantics for provability logic GLP. Annals of Pure and
Applied Logic, 161: 756–774, 2010. Preprint: Logic Group Preprint Series 260, Uni-
versity of Utrecht, November 2007. http://preprints.phil.uu.nl/lgps/.
6The ﬁrst author thanks Philipp Schlicht for ﬁnding this condition and for further advice on set theory
involved here.

154
Lev Beklemishev, Guram Bezhanishvili, and Thomas Icard
[6] L.D. Beklemishev, J. Joosten, and M. Vervoort. A ﬁnitary treatment of the closed frag-
ment of Japaridze’s provability logic. Journal of Logic and Computation, 15(4):447–
463, 2005.
[7] J. van Benthem and G. Bezhanishvili. Modal logics of space. In Handbook of spatial
logics, pages 217–298. Springer, Dordrecht, 2007.
[8] C. Bernardi and P. d’Aquino. Topological duality for diagonalizable algebras. Notre
Dame Journal of Formal Logic, 29(3):345–364, 1988.
[9] G. Bezhanishvili and P. J. Morandi. Scattered and hereditarily irresolvable spaces in
modal logic. Archive for Mathematical Logic, 49(3):343–365, 2010.
[10] A. Blass.
Inﬁnitary combinatorics and modal logic.
Journal of Symbolic Logic,
55(2):761–778, 1990.
[11] G. Boolos. The Logic of Provability. Cambridge University Press, Cambridge, 1993.
[12] W. Buszkowski and T. Prucnal. Topological representation of co-diagonalizable alge-
bras. In G. Wechsung, editor, Frege Conference’ 1984, pages 63–65, Berlin, 1984.
Akademie-Verlag.
[13] L. Esakia. Diagonal constructions, L¨ob’s formula and Cantor’s scattered spaces. In
Studies in logic and semantics, pages 128–143. Metsniereba, Tbilisi, 1981. In Russian.
[14] L. Esakia. Intuitionistic logic and modality via topology. Annals of Pure and Applied
Logic, 127:155–170, 2003.
[15] M. Gerson. An extension of S4 complete for the neighbourhood semantics but incom-
plete for the relational semantics. Studia Logica, 34(4):333–342, 1975.
[16] M. Gerson. A neighbourhood frame for T with no equivalent relational frame. Z.
Math. Logik Grundlagen Math., 22(1):29–34, 1976.
[17] T.F. Icard, III. Models of the polymodal provability logic. M.Sc. Thesis, ILLC, Univer-
sity of Amsterdam, http://www.illc.uva.nl/Publications/ ResearchReports/MoL-2008-
06.text.pdf, 2008.
[18] T.F. Icard, III.
A topological study of the closed fragment of GLP.
Journal of
Logic and Computation,
Advance Access published online on August 12, 2009,
doi:10.1093/logcom/exp043.
[19] K.N. Ignatiev. The closed fragment of Dzhaparidze’s polymodal logic and the logic
of Σ1-conservativity. ITLI Prepublication Series X–92–02, University of Amsterdam,
1992.
[20] K.N. Ignatiev. On strong provability predicates and the associated modal logics. The
Journal of Symbolic Logic, 58:249–290, 1993.
[21] G.K. Japaridze. The modal logical means of investigation of provability. Thesis in
Philosophy, in Russian, Moscow, 1986.
[22] G.K. Japaridze. The polymodal logic of provability. In Intensional Logics and Logical
Structure of Theories: Materials from the fourth Soviet–Finnish Symposium on Logic,
Telavi, May 20–24, 1985, pages 16–48. Metsniereba, Tbilisi, 1988. In Russian.

On Topological Models of GLP
155
[23] T. Jech. Set Theory. The Third Millenium Edition. Springer, 2002.
[24] R. Magari. The diagonalizable algebras (the algebraization of the theories which ex-
press Theor.:II). Bollettino della Unione Matematica Italiana, Serie 4, 12, 1975. Suppl.
fasc. 3, 117–125.
[25] J. C. C. McKinsey and A. Tarski. The algebra of topology. Annals of Mathematics,
45:141–191, 1944.
[26] V. Shehtman. On neighbourhood semantics thirty years later. In S. Artemov et al.,
editors, We Will Show Them! Essays in Honour of Dov Gabbay, v.2, pages 663–692.
King’s College Publications, 2005.


Program Extraction via Typed Realisability
for Induction and Coinduction
Ulrich Berger and Monika Seisenberger
Department of Computer Science
Swansea University
Swansea, SA2 8PP, Wales, UK
{u.berger,m.seisenberger}@swansea.ac.uk
Abstract We study a realisability interpretation for inductive and coinduc-
tive deﬁnitions and discuss its application to program extraction in construc-
tive analysis. A speciality of this interpretation is that realisers are given by
terms that correspond directly to programs in a lazy functional programming
language such as Haskell.
1 Introduction
In this paper we give a realisability interpretation for a constructive theory of strictly
positive inductive and coinductive deﬁnitions. The motivation is to provide a the-
oretical foundation for ongoing work on program extraction from proofs involving
such deﬁnitions.
Our theory is an extension of intuitionistic ﬁrst-order predicate logic with pred-
icate variables and the deﬁnition of predicates as least and greatest ﬁxed points
of strictly positive operators. Since operators may depend strictly positively on
other free predicate variables, these deﬁnitions may “interleave”. An example of
an interleaved inductive/coinductive deﬁnition is the predicate C1, discussed in the
conclusion of this paper, which characterises uniformly continuous functions on
the real interval [−1, 1]. In the context of classical propositional modal logic a
system allowing similar interleavings is known as the μ-calculus [BS07]. M¨oller-
feld [M¨03] studied the ﬁrst-order version of the μ-calculus, which is equivalent
to the classical version of our system, and proved that it has the enormous proof-
theoretic strength of Π1
2-comprehension. Tupailo [Tup04] showed that the latter
system can be embedded into its intuitionistic counterpart via a double-negation
translation – hence preserving the proof-theoretic strength – however at the cost
of introducing non-strictly positive inductive deﬁnitions. If one forbids interleav-
ings, one obtains the proof-theoretically weaker system ID<ω of ﬁnitely iterated
inductive deﬁnitions [BFPS81].

158
Ulrich Berger and Monika Seisenberger
In the present paper we are concerned with the application of our theory to
program extraction via realisability.
The realisability interpretation we are go-
ing to study is related to interpretations given by Tatsuta [Tat98] and Miranda-
Perea [MP05]. We try to point out the main similarities and differences. While
Miranda-Perea extracts terms in a strongly normalising extension of the second-
order polymorphic λ-calculus with “Mendler-style” (co)inductive types [Men91,
Mat01,AMU05] (see also related work by Krivine and Parigot [KP90,Par92]), our
realisers are taken from a λ-calculus with full recursion, ML-style polymorphic
and recursive types and a call-by-name operational semantics. Hence our realisers
can be directly understood as programs in a lazy functional programming language
such as, for example, Haskell. Terms do not terminate in general, but those re-
alising a formula do. Tatsuta’s realisers can be viewed as an untyped version of
ours. However, he works with realisability with truth whilst we omit the “truth”
component.
From a practical point of view the most important difference to Tatsuta’s interpre-
tation is that we treat quantiﬁers uniformly in the realisability interpretation (as Mi-
randa does): M r ∀x A(x) is deﬁned as ∀x (M r A(x)) (but not ∀x (M x r A(x))
and M r ∃x A(x) is deﬁned as ∃x (M r A(x)) (but not π2(M) r A(π1(M))). In
general, a realiser never depends on variables of the object language in that lan-
guage, i.e. the object language and the language of realisers are kept strictly sepa-
rate. Realisers are extracted exclusively from the “propositional skeleton”of a proof
ignoring the ﬁrst-order part, the latter being important for the correctness of the re-
alisers only. This widens the scope of applications considerably because it allows
to deal with abstract structures that are not necessarily “constructively” given. Our
uniform treatment of ﬁrst-order quantiﬁers can also be seen as a special case of
the interpretations studied by Schwichtenberg [Sch08], Hernest and Oliva [HO08]
and Ratiu and Trifonov [RT10], which allow for a ﬁne control of the amount of
computational information extracted from proofs.
2 Inductive and coinductive deﬁnitions
We ﬁx a ﬁrst-order language L. Terms, r, s, t . . ., are built from constants, ﬁrst-
order variables and function symbols as usual. Formulas, A, B, C . . ., are s = t,
P(⃗t) where P is a predicate (see below), A ∧B, A ∨B, A →B, ∀x A,
∃x A. A predicate is either a predicate constant P, or a predicate variable X, or
a comprehension term {⃗x | A}, or an inductive predicate μX.P, or a coinductive
predicate νX.P where P is a predicate of the same arity as the predicate variable
X and which is strictly positive (s.p.) in X, i.e. X does not occur free in any
premise of a subformula of P which is an implication. The application, P(⃗t), of a

Program Extraction via Typed Realisability
159
predicate P to a list of terms ⃗t is a primitive syntactic construct, except when P is
a comprehension term, P = {⃗x | A}, in which case P(⃗t) stands for A[⃗t/⃗x].
We will sometimes use the notation ⃗x ∈P for of P(⃗x), P ⊆Q for ∀⃗x (P(⃗x) →
Q(⃗x)) and P ∩Q for {⃗x | P(⃗x) ∧Q(⃗x)} etc. We also write {t | A} as an
abbreviation for {x | ∃⃗y (x = t ∧A)} where x is a fresh variable and ⃗y =
FV(t) ∩FV(A), as well as f(P) for {f(x) | x ∈P}. Furthermore, we introduce
operators Φ := λ ⃗X.P, and write Φ( ⃗Q) for the predicate P[ ⃗Q/ ⃗X] where the latter
is the usual substitution of the predicates ⃗Q for the predicate variables ⃗X. Φ is
called a s.p. operator if P is s.p. in X. In this case we also write μΦ and νΦ for
μX.P and νX.P. A formula, predicate, or operator is called non-computational,
if it contains neither free predicate variables nor the propositional connective ∨
nor the construct ν (formation of a greatest ﬁxed point). Otherwise it is called
computational.
The proof rules are the usual ones of intuitionistic predicate calculus with equal-
ity augmented by rules expressing that μΦ and νΦ are the least and greatest ﬁxed
points of the operator Φ. As is well-known, the ﬁxed point property can be replaced
by appropriate inclusions. Hence we stipulate the axioms
Closure
Φ(μΦ) ⊆μΦ
Induction
Φ(Q) ⊆Q →μΦ ⊆Q
Coclosure νΦ ⊆Φ(νΦ)
Coinduction Q ⊆Φ(Q) →Q ⊆νΦ
for all s.p. operators Φ and predicates Q. In addition we allow any axioms ex-
pressible by non-computational formulas that hold in the intended model. We write
Γ ⊢A if A is derivable from assumptions in Γ in this system. If A is deriv-
able without assumptions we write ⊢A, or even just A. Falsity can be deﬁned as
⊥:= μX.X where X is a propositional variable (i.e. a 0-ary predicate variable).
From the induction axiom for ⊥follows ⊥→A for every formula A.
Lemma 2.1 (Instantiation). If Γ(X) ⊢A(X), then Γ(P) ⊢A(P).
Proof. Straightforward induction on derivations.
Lemma 2.2 (Monotonicity). Let Φ, Ψ be s.p. operators, P, Q predicates, Γ a
context and X a predicate variable not free in Γ.
(a) If Γ ⊢Φ(X) ⊆Ψ(X), then Γ ⊢μΦ ⊆μΨ and Γ ⊢νΦ ⊆νΨ.
(b) P ⊆Q ⊢Φ(P) ⊆Φ(Q).
Proof. (a) Assume Γ. We show μΦ ⊆μΨ using the Induction Axiom. Hence,
we have to show Φ(μΨ) ⊆μΨ. By the hypothesis of the lemma, the Instantiation
Lemma 2.1, and the closure axiom, we have Φ(μΨ) ⊆Ψ(μΨ) ⊆μΨ. The proof
for ν is similar.

160
Ulrich Berger and Monika Seisenberger
(b) Straightforward induction on the built-up of Φ, using (a) in the case of induc-
tive and coinductive predicates.
Lemma 2.3 (Fixed Point). Let Φ be an operator.
(a) Φ(μΦ) = μΦ.
(b) Φ(νΦ) = νΦ.
Proof. Because of the closure axiom, it sufﬁces for (a) to show μΦ ⊆Φ(μΦ). We
use the induction rule. Thus it sufﬁces to show Φ(Φ(μΦ)) ⊆Φ(μΦ). But this
follows from the closure axiom and the Monotonicity Lemma 2.2. The proof of (b)
is similar.
As a running example we use the ﬁrst-order language of the ordered real num-
bers. As axioms we adopt any non-computational formulas that are true in the struc-
ture of real numbers, e.g. the axioms of a real closed ﬁeld where the linearity of the
order is expressed non-computationally, e.g. by ∀x, y (y ̸< x ∧x ̸< y →x = y).
All sets we deﬁne in the following are subsets of the set of real numbers. We deﬁne
the set N of natural numbers as usual inductively by
N := μX.{0} ∪{x + 1 | X(x)}
Next we deﬁne coinductively a set which, as we will see later, is closely connected
to the signed digit representation of real numbers. First we deﬁne the set of signed
binary digits by SD := {0, 1, −1} = {i | i = 0 ∨i = 1 ∨i = −1}. Now we
deﬁne coinductively
C0 := νX.{(i + x)/2 | SD(i) ∧X(x) ∧|(i + x)/2| ≤1}
It is easy to see that, classically, C0 coincides with the closed interval I := [−1, 1].
The point is that from a constructive proof of C0(x) we can extract a program
computing an inﬁnite signed digit representation of x.
3 An idealised functional programming language
In this section we introduce an extended λ-calculus which we will use as the lan-
guage of realisers in Sect. 4. For this calculus we deﬁne a denotational and an
operational semantics and relate the two by an Adequacy Theorem. We also in-
troduce types and deﬁne typable map operators, iterators and coiterators that will
serve as realisers of monotonicity, induction and coinduction.

Program Extraction via Typed Realisability
161
3.1 The untyped language
First, we introduce an untyped λ-calculus with constructors, pattern matching and
recursion. Its terms are generated by the following formation rules.
Variables: x, y, z, . . ..
Constructor terms: C(M1, . . . , Mn) where C is taken from a set C of construc-
tors each of which has a ﬁxed arity and M1, . . . , Mn are terms.
Case analysis: case M of{C1( ⃗x1) →R1 ; . . . ; Cn( ⃗xn) →Rn} where M,
R1, . . . Rn are terms, the Ci are distinct constructors and each ⃗xi is a vector of
distinct variables.
λ-abstraction: λx.M where x is a variable and M is a term.
Application: M N where M and N are terms.
Recursion: rec x . M where x is a variable and M is a term.
The free variables FV(M) of a term M is deﬁned as expected, for ex-
ample FV(case M of{C1( ⃗x1) →R1 ; . . .}) = FV(M) ∪
i(FV(Ri) \ ⃗xi),
FV(rec x . M) = FV(M) \ x. The usual conventions concerning bound variables
apply. In particular, all deﬁnitions will be robust against bound renaming. M[N/x]
denotes the capture avoiding substitution of all free occurrences of x in M by N.
We axiomatise this calculus by the equations
case Ci( ⃗K) of{C1( ⃗x1) →R1 ; . . .} = Ri[ ⃗K/⃗xi]
(λx.M)N = M[N/x]
rec x . M = M[rec x . M/x]
We write ⊢M = N if the equation M = N can be derived from these axioms by
the usual rules of equational logic.
Of particular interest are closed terms built exclusively from constructors. We
call these terms data and denote them by d, e, . . ..
3.2 Denotational semantics
In the following we mean by a domain a Scott-domain, i.e. an algebraic, countably
based, bounded complete, dcpo [GHK+03]. Every domain has a least element ⊥
w.r.t. the domain ordering ⊑. Let C be a set of constructors and assume that every
C ∈C has a ﬁxed arity. Let D be deﬁned by the recursive domain equation
D =

C∈C
Darity(C) + [D →D]
where + and the symbol  denote the separated sum and [· →·] the continuous
function space. Of course, this domain equation holds only “up to isomorphism”,

162
Ulrich Berger and Monika Seisenberger
however, we will usually suppress the isomorphism notationally. Hence, every
element of D is of exactly one of the following forms: ⊥, C(a1, . . . , an) where
C ∈C, n = arity(C) and ai ∈D, or abst(f) where f is a continuous function
from D to D. Moreover, the functions C : Darity(C) →D and abst : [D →D] →
D are continuous injections with disjoint ranges covering all of D\⊥. For a, b ∈D
we deﬁne a b := f(b) if a = abst(f) and a b := ⊥, otherwise.
In the proof of the Adequacy Theorem we will exploit the algebraicity of the
domain D. Let D0 be the set of compact elements of D, i.e. those elements a0 ∈D
such that for every directed set A ⊆D, if a0 ⊑⊔A, then a0 ⊑a for some a ∈A.
That D is algebraic means that every element of D is the directed supremum of
compact elements. Since compact elements are generated at some ﬁnite stage in
the construction of D, there is a rank function rk(·) : D0 →N with the following
properties:
(rk1) C(a1, . . . , an) is compact iff all the ai are, and in that case we have for all i,
rk(C(a1, . . . , an)) > rk(ai).
(rk2) If abst(f) compact, then for every a ∈D, f(a) is compact with rk(f(a)) <
rk(abst(f)), and there exists a compact a0 ⊑a with rk(a0) < rk(abst(f))
and f(a0) = f(a).
The rank of a compact element can also be explained as the size of a suitable nota-
tion for the corresponding ﬁnite consistent set in the Information System represen-
tation of domains [Win93].
From standard facts in domain theory it follows that every program term M
deﬁnes in a natural way a continuous function [[M]] : DVar →D which for the
purpose of this paper is most conveniently deﬁned by the formula
[[M]] :=
 
n∈N
[[M]]n
where the continuous functions [[M]]n : DVar →D are deﬁned by recursion on
n ∈N. We set [[M]]0ξ = ⊥. The deﬁnition of [[M]]n+1ξ depends on the syntactic
form of M. We use the notation ⃗a →⃗b to denote the partial map sending ai to bi

Program Extraction via Typed Realisability
163
where ⃗a = a1, . . . , an with different ai and⃗b = b1, . . . , bn.
[[x]]n+1ξ = ξ(x)
[[C(M1, . . . , Mk)]]n+1ξ = C([[M1]]nξ, . . . , [[Mk]]nξ)
[[case M of{C1( ⃗x1) →R1 ; . . .}]]n+1ξ = [[Ri]]nξ[⃗xi →⃗a] if [[M]]nξ = Ci(⃗a)
= ⊥otherwise
[[λx.M]]n+1ξ = abst(f) where f(a) := [[M]]nξ[x →a]
[[M N]]n+1ξ = ([[M]]nξ) ([[N]]nξ)
[[rec x . M]]n+1ξ = [[M]]nξ[x →[[rec x . M]]nξ]
Clearly, [[M]]n increases in the domain ordering if n increases. Therefore, [[M]] is
well-deﬁned. If one removes the superscripts from the equations above one obtains
valid equations for [[M]]. By the deﬁnition of compactness we have the following:
Lemma 3.1. If a is compact and a ⊑[[M]]ξ, then a ⊑[[M]]nξ for some n.
It is easy to see that this interpretation of terms turns D into a model of the
axioms in Sect. 3:
Lemma 3.2 (Model). If ⊢M = N, then [[M]] = [[N]].
For closed terms M the value [[M]]ξ does not depend on ξ. Hence we sometimes
write, somewhat ambiguously, [[M]] for [[M]]ξ where ξ is an arbitrary assignment,
for example ξ(x) = ⊥for all variables x.
3.3 Operational semantics
A closure is a pair (M, η) where M is a term and η is an environment, i.e. a ﬁnite
mapping from variables to closures, such that all free variables of M are in the
domain of η. Note that this is an inductive deﬁnition on the meta-level. A value is a
closure (M, η) where M is an intro term, i.e. a term of the form C(M1, . . . , Mn),
or λx.M0. We let range c, c′, . . . over closures and v, v′, . . . over values. We in-
ductively deﬁne the relation c −→v (big-step reduction), where for partial maps
f, g we write f[g] to denote the partial map with domain dom(f) ∪dom(g) and
f[g](a) = g(a) if a ∈dom(g) and = f(a) if a ∈dom(f) \ dom(g).
(i) v −→v
(ii)
η(x) −→v
(x, η) −→v

164
Ulrich Berger and Monika Seisenberger
(iii)
(M, η) −→(Ci( ⃗K), η′)
(Ri, η[⃗xi →( ⃗K, η′)]) −→v
(case M of{C1( ⃗x1) →R1 ; . . . ; Cn( ⃗xn) →Rn}, η) −→v
(iv)
(M, η) −→(λx.M0, η′)
(M0, η′[x →(N, η)]) −→v
(M N, η) −→v
(v)
(M, η[x →(rec x . M, η)]) −→v
(rec x . M, η) −→v
Note that arguments of a constructor are not reduced: since (C( ⃗M), η) is a value,
the only possible “reduction” is (C( ⃗M), η) −→(C( ⃗M), η). In order to reduce
under a constructor we need a further ‘print’ relation c =⇒d between closures c
and data terms d.
c −→(C(M1, . . . , Mn), η)
(M1, η) =⇒d1
. . .
(Mn, η) =⇒dn
c =⇒C(d1, . . . , dn)
Clearly, the inductive deﬁnitions of −→and =⇒give rise to an algorithm comput-
ing d from c whenever c =⇒d. Since this algorithm corresponds to a call-by-name
evaluation of terms one can conclude that, for closed M, whenever (M, ∅) =⇒d,
then in a call-by-name language such as Haskell the evaluation of the program cor-
responding to M will terminate with a result corresponding to d (provided M is
typeable).
To every closure c we assign a term c by ‘ﬂattening’, i.e. removing the structure
provided by the nested environments:
(M, η) = M[η(x)/x | x ∈dom(η)]
Note that this is a recursive deﬁnition on the meta-level.
Lemma 3.3 (Correctness). (a) If c −→v, then ⊢c = v.
(b) If c =⇒d, then ⊢c = d.
Proof. (a) can be proven by straightforward induction on the deﬁnition of c −→v.
(b) Follows from (a) and induction on the deﬁnition of c =⇒d.
3.4 Adequacy
Now we prove that denotational and operational semantics are equivalent w.r.t.
data. By the Correctness Lemma 3.3 we know already that for a closed term M, if
(M, ∅) =⇒d, then ⊢M = d and therefore [[M]] = d, by the Model Lemma 3.2.
The Adequacy Theorem shows that the converse implication holds as well.

Program Extraction via Typed Realisability
165
Theorem 3.4 (Adequacy). If [[M]] = d, then (M, ∅) =⇒d.
The rest of this section is devoted to the proof of this theorem. The proof we
present can be viewed as a type free version of Plotkin’s Adequacy Theorem for
PCF [Plo77]. It is based on a variant of the reducibility or candidate method [Gir71,
Tai75] where the role of types is taken over by compact domain elements (see
also [Rey74,Win93,BC94,Pit94]). In [CS06] and [Ber05] a similar technique was
applied to prove strong normalisation of typed λ-calculi with rewrite rules.
The properties of the rank function for compact domain elements discussed in
Sect. 3.2 allow us to deﬁne for every compact a a set Cl(a) of closures, by recursion
on rk(a):
Cl(⊥) = the set of all closures
Cl(C(⃗a)) = {c | ∃⃗M, η (c −→(C( ⃗M), η) ∧∀i (Mi, η) ∈Cl(ai)}
Cl(abst(f)) = {c | ∃x, M, η (c −→(λx.M, η) ∧∀a∈D0 (rk(a) < rk(abst(f))
→∀c′ ∈Cl(a) (M, η[x →c′]) ∈Cl(f(a))))}
Note that the sets Cl(a) are deﬁned in analogy with the reducibility or computabil-
ity predicates mentioned above.
Lemma 3.5. If a, b are compact with a ⊑b, then Cl(a) ⊇Cl(b).
Proof. Induction on the maximum of rk(a) and rk(b). The only interesting case
is abst(f) ⊑abst(g). Then f ⊑g (pointwise). Let c ∈Cl(abst(g)). Then
c −→(λx.M, η), and for all compact b with rk(b) < rk(abst(g)) and all c′ ∈
Cl(b) we have (M, η[x →c′]) ∈Cl(g(b)). We show c ∈Cl(abst(f)) using
the same witness (λx.M, η). Let a be compact with rk(a) < rk(abst(f)) and let
c′ ∈Cl(a). By (rk2), there exists a compact b ⊑a with rk(b) < rk(abst(g))
and g(b) = g(a). By induction hypothesis, Cl(b) ⊇Cl(a), hence c′ ∈Cl(b). It
follows (M, η[x →c′]) ∈Cl(g(b)) = Cl(g(a)).
Lemma 3.6. c ∈Cl(a) iff there exists a value v with c −→v and v ∈Cl(a).
Proof. This can be seen by a trivial induction in rk(a) using the fact that for values
v, v′ we have v −→v′ iff v = v′.
Lemma 3.7. If c ∈Cl(d), where d is a data, then c =⇒d.
Proof. Straightforward induction on d.
Lemma 3.8 (Coincidence). If (M, η) ∈Cl(a) and η(x) = η′(x) for all x ∈
FV(M), then (M, η′) ∈Cl(a).

166
Ulrich Berger and Monika Seisenberger
Proof. Straightforward induction on the rk(a).
We call a total or partial assignment ξ compact if ξ(x) is compact for all x ∈
dom(ξ), and write ξ ⊑ξ′ if dom(ξ) = dom(ξ′) and ξ(x) ⊑ξ′(x) for all x ∈
dom(ξ). We write η ∈Cl(ξ) if η is an environment with dom(η) ⊆dom(ξ), ξ is
compact and η(x) ∈Cl(ξ(x)) for all x ∈dom(η).
Lemma 3.9 (Approximation). If η ∈Cl(ξ) and a is compact with a ⊑[[M]]ξ, then
(M, η) ∈Cl(a).
Proof. By Lemma 3.1 it is enough to show:
If η ∈Cl(ξ) and a is compact with a ⊑[[M]]nξ, then (M, η) ∈Cl(a).
We prove this by induction on n ∈N. The induction base, n = 0, is easy, since
[[M]]0ξ = ⊥and therefore a = ⊥, and Cl(⊥) is the set of all closures.
In the induction step, n + 1, we do a case analysis on the shape of M. We may
assume a ̸= ⊥, since otherwise the assertion is trivial.
Case x. By assumption, a ⊑[[x]]n+1ξ = ξ(x) and η(x) ∈Cl(ξ(x)). By
Lemma 3.5, η(x) ∈Cl(a). By Lemma 3.6, there exists a value v with η(x) −→v
and v ∈Cl(a). It follows (x, η) −→v and therefore (x, η) ∈Cl(a), again by
Lemma 3.6.
Case C( ⃗M). By assumption we have a ⊑[[C( ⃗M)]]n+1ξ = C([[ ⃗M]]nξ). Hence
a = C(⃗a) with ai ⊑[[Mi]]nξ.
By induction hypothesis, (Mi, η) ∈Cl(ai).
Since (C( ⃗M), η) −→(C( ⃗M), η) (recall that (C( ⃗M), η) is a value), it follows
that (C( ⃗M), η) ∈Cl(C(⃗a)).
Case λx.M. By assumption, a ⊑[[λx.M]]n+1ξ = abst(g) where g(b) =
[[M]]nξ[x →b].
Hence, a = abst(f) with f ⊑g.
By induction hypothe-
sis, (M, η[x →c]) ∈Cl(f(b)), for all compact b and all c ∈Cl(b). Since
(λx.M, η) −→(λx.M, η), it follows (λx.M, η) ∈Cl(abst(f)).
Case case M of{C( ⃗x1) →R1 ; . . .}. By assumption a ⊑[[case M of{C( ⃗x1) →
R1 ; . . .}]]n+1ξ. Since a ̸= ⊥we have, [[M]]nξ = Ci(⃗b) for some i and a ⊑
[[Ri]]nξ[⃗xi →⃗b]. Since a is compact and the function mapping⃗b to [[Ri]]nξ[⃗xi →⃗b]
is continuous it follows that a ⊑[[Ri]]nξ[⃗xi →⃗b0] for some compact ⃗b0 ⊑⃗b. By
induction hypothesis, (M, η) ∈Cl(C(⃗b0)). Hence, (M, η) −→(C( ⃗
M0), η0) with
( ⃗
M0, η0) ∈Cl(⃗b0). Again, by induction hypothesis, (Ri, η[x →η0 ⃗
M0]) ∈Cl(a).
By Lemma 3.6, (Ri, η[x →η0 ⃗
M0]) −→v) for some value v ∈Cl(a). It follows
(case M of{C( ⃗x1) →R1 ; . . .}, η) −→v and consequently (case M of{C( ⃗x1) →
R1 ; . . .}, η) ∈Cl(a), again by Lemma 3.6.
Case M N. By assumption, a ⊑[[M N]]n+1ξ. Since a ̸= ⊥we have, [[M]]nξ =
abst(f) and a ⊑f([[N]]nξ). Since function application is continuous, there are a

Program Extraction via Typed Realisability
167
compact f0 ⊑f and a compact b ⊑[[N]]nξ with a ⊑f0(b). By (rk2), we may
assume rk(b) < rk(abst(f0)). By induction hypothesis, (M, η) ∈Cl(abst(f0))
and (N, η) ∈Cl(b). Therefore, M −→(λx.M0, η0) such that (M0, η0[x →
(N, η)]) ∈Cl(f0(b)). By Lemma 3.6, (M0, η0[x →(N, η)]) −→v for some v ∈
Cl(f0(b)). It follows (M N, η) −→v and hence (M N, η) ∈Cl(f0(b)) ⊆Cl(a),
by Lemma 3.6 and Lemma 3.5.
Case rec x . M. By assumption, we have a ⊑[[rec x . M]]n+1ξ = [[M]]nξ[x →
[[rec x . M]]nξ]. By a similar continuity argument as earlier in the proof, there ex-
ists a compact b ⊑[[rec x . M]]nξ such that a ⊑[[M]]nξ[x →b]. By induction
hypothesis, (rec x . M, η) ∈Cl(b) and (M, η[x →(rec x . M, η)]) ∈Cl(a). By
Lemma 3.6, (M, η[x →(rec x . M, η)]) −→v for some value v ∈Cl(a), therefore
(rec x . M, η) −→v, and ﬁnally, (rec x . M, η) ∈Cl(a).
Proof of the Adequacy Theorem (Thm. 3.4). Assume [[M]] = d for some data
d. Since d is compact, it follows, by the Approximation Lemma 3.9, (M, ∅) ∈
Cl(d). Hence (M, ∅) =⇒d, by Lemma 3.7.
3.5 Types, map, iteration and coiteration
The typing discipline we introduce now serves two purposes. First, types are used
as indices for families of terms realising monotonicity, induction and coinduction.
Second, we will show that all extracted programs are typeable and hence are valid
programs in a typed functional programming language such as Haskell or ML.
Types are constructed from type variables α, β, . . . ∈TVar according to the
grammar
Type ∋ρ, σ, τ ::= α | 1 | ρ + σ | ρ × σ | ρ →σ | ﬁx α.ρ
We consider the instance of our term language determined by the constructors Nil
(nullary), Left, Right (unary), Pair (binary) and Inﬁx α.ρ (unary) for every ﬁxed
point type ﬁx α.ρ, and deﬁne inductively the relation Γ ⊢M : ρ (term M is of type
ρ in typing context Γ).
(i) Γ, x : ρ ⊢x : ρ
(ii) Γ ⊢Nil : 1
(iii)
Γ, x : ρ ⊢M : σ
Γ ⊢λx.M : ρ →σ
Γ ⊢M : ρ →σ
Γ ⊢N : ρ
Γ ⊢M N : σ

168
Ulrich Berger and Monika Seisenberger
(iv)
Γ ⊢M : ρ
Γ ⊢N : σ
Γ ⊢Pair(M, N) : ρ × σ
Γ ⊢M : ρ × σ
Γ, x1 : ρ, x2 : σ ⊢R : τ
Γ ⊢case M of{Pair(x1, x2) →R} : τ
(v)
Γ ⊢M : ρ
Γ ⊢Left(M) : ρ + σ
Γ ⊢M : σ
Γ ⊢Right(M) : ρ + σ
Γ ⊢M : ρ + σ
Γ, x1 : ρ ⊢L : τ
Γ, x2 : σ ⊢R : τ
Γ ⊢case M of{Left(x1) →L ; Right(x2) →R} : τ
(vi) Let ρ = ρ(⃗α) = ﬁx α.ρ0(α, ⃗α):
Γ ⊢M : ρ0(ρ(⃗σ),⃗σ)
Γ ⊢Inρ(M) : ρ(⃗σ)
Γ ⊢M : ρ(⃗σ)
Γ, x : ρ0(ρ(⃗σ),⃗σ) ⊢R : τ
Γ ⊢case M of{Inρ(x) →R} : τ
(vii)
Γ, x : τ ⊢M : τ
Γ ⊢rec x . M : τ
The following deﬁnition refers to a ﬁxed one-to-one assignment of variables fα
to type variables α. For every list of type variables ⃗α and every type ρ which is
s.p. in ⃗α we deﬁne a program term Map⃗α;ρ with FV(Map⃗α;ρ) = {fα | α ∈
⃗α ∩FTV(ρ)} by induction on the structure of ρ.
Map⃗α;αi = fi,
Map⃗α;ρ = λx. x, if no αi occurs in ρ,
Map⃗α;ρ+σ = λx.case x of{Left(y) →Left(Map⃗α;ρy) ;
Right(z) →Right(Map⃗α;σz)}
Map⃗α;ρ×σ = λx. case x of{Pair(y, z) →Pair(Map⃗α;ρy, Map⃗α;σz)}
Map⃗α;ρ→σ = λx. λy. Map⃗α;σ(x y)
Map⃗α;ﬁx α.ρ = rec fα . λx. case x of{Inﬁx α.ρ(y) →Inﬁx α.ρ(Map⃗α,α;ρy)}

Program Extraction via Typed Realisability
169
A type is called regular if in its construction the clause ﬁx α.ρ is applied only if
ρ is s.p. in α. In the following all mentioned types are assumed to be regular.
Lemma 3.10. Let ρ = ρ(⃗α) be s.p. in ⃗α. Consider a context Γ = fα1 : σ1 →
τ1, . . . , fαn : σn →τn. Then
Γ ⊢Map⃗α;ρ : ρ(⃗σ) →ρ(⃗τ)
Proof. We give a detailed derivation only for the case that ρ(⃗α) is of the form
ﬁx α.ρ0(α, ⃗α). In the derivation below we set ρ⃗σ := ρ(⃗σ) = ﬁx α.ρ0(α,⃗σ).
x: ρ⃗σ ⊢x: ρ⃗σ
Γ, fα : ρ⃗σ →ρ⃗τ ⊢Map⃗α,α;ρ0 : ρ0(ρ⃗σ,⃗σ)→ρ0(ρ⃗τ,⃗τ)
y: ρ0(ρ⃗σ,⃗σ) ⊢y: ρ0(ρ⃗σ,⃗σ)
Γ, fα : ρ⃗σ →ρ⃗τ, y: ρ0(ρ⃗σ,⃗σ) ⊢Map⃗α,α;ρ0y: ρ0(ρ⃗τ,⃗τ)
Γ, fα : ρ⃗σ →ρ⃗τ, y: ρ0(ρ⃗σ,⃗σ) ⊢Inρ(Map⃗α,α;ρ0y): ρ⃗τ
Γ, x: ρ⃗σ, fα : ρ⃗σ →ρ⃗τ ⊢case x of{Inρ(y) →Inρ(Map⃗α,α;ρ0y)}: ρ⃗τ
Γ, fα : ρ⃗σ →ρ⃗τ ⊢λx.case x of{Inρ(y) →Inρ(Map⃗α,α;ρ0y)}: ρ⃗σ →ρ⃗τ
Γ ⊢rec fα . λx.case x of{Inρ(y) →Inρ(Map⃗α,α;ρ0y)}: ρ⃗σ →ρ⃗τ
i.e. Γ ⊢Map⃗α;ρ : ρ⃗σ →ρ⃗τ
We introduce the abbreviations
map⃗α;ρ := λfα1, . . . , fαn. Map⃗α;ρ,
inﬁx α.ρ := λy. Inﬁx α.ρ(y),
outﬁx α.ρ := λx. case x of{Inﬁx α.ρ(y) →y}.
Lemma 3.11.
(map⃗α;ﬁx α.ρ ⃗f) ◦inﬁx α.ρ = inﬁx α.ρ ◦(map⃗α,α;ρ(⃗α,α) ⃗f(map⃗α;ﬁx α.ρ ⃗f))
Proof. By the deﬁnition of map; we have map⃗α;ﬁx α.ρ(⃗α) ⃗f(Inﬁx α.ρ(y)) =
(rec fα . λx. case x of{Inﬁx α.ρ(y) →Inﬁx α.ρ(map⃗α,α;ρ(⃗α,α) ⃗ffαy)})
(Inﬁx α.ρ(y)) = Inﬁx α.ρ(map⃗α,α;ρ(⃗α,α) ⃗f(map⃗α;ﬁx α.ρ(⃗α) ⃗f)y).
For every (regular) type ﬁx α.ρ we deﬁne the closed terms
Itﬁx α.ρ := λs. rec f . λx. case x of{Inﬁx α.ρ(y) →s(mapα;ρfy)}
Coitﬁx α.ρ := λs.rec f . λx.Inﬁx α.ρ(mapα;ρf(s x))
which will later be used as realisers for induction and coinduction. The following
is an immediate consequence of Lemma 3.10.

170
Ulrich Berger and Monika Seisenberger
Lemma 3.12 (Typability of iterator and coiterator). For all types σ,⃗σ
⊢Itﬁx α.ρ : (ρ(σ,⃗σ) →σ) →ﬁx α.ρ(⃗σ) →σ
⊢Coitﬁx α.ρ : (σ →ρ(σ,⃗σ)) →σ →ﬁx α.ρ(⃗σ)
Lemma 3.13. (a) ⊢Itﬁx α.ρs ◦inﬁx α.ρ = s ◦map⃗α;ρ(Itﬁx α.ρs)
(b) ⊢outﬁx α.ρ ◦Coitﬁx α.ρs = mapα;ρ(Coitﬁx α.ρs) ◦s
Proof. Immediate by the deﬁnitions.
4 Realisability
In this section we introduce a formalised realisability interpretation of the theory
of inductive and coinductive deﬁnitions of Sect. 2. To this end we need a system
that can talk about mathematical objects and realisers. Therefore we extend our
ﬁrst-order language L to a language r(L) by adding a new sort for program terms.
All logical operations including inductive and coinductive deﬁnitions, as well as
axioms and rules for L including closure, induction, coclosure and coinduction and
the rules for equality, are extended mutatis mutandis for r(L). In addition, we have
as extra axioms the equations given in Sect. 3.1.
4.1 Uniform realisability
We assign to every L-formula A a unary r(L)-predicate r(A) denoting a subset
of D. Intuitively, r(A)(a), sometimes also written a r A, states that a “realises”
A. The predicate r(A) is deﬁned relative to a ﬁxed one-to-one mapping from L-
predicate variables X to r(L)-predicate variables 
X with one extra argument place
for domain elements. The deﬁnition of r(A) is such that if the formula A has the
free predicate variables X1, . . . , Xn, then the predicate r(A) has the free predicate
variables !
X1, . . . , !
Xn. Simultaneously with r(A) we deﬁne a predicate r(P) for
every predicate P, where r(P) has one extra argument place for domain elements.
We also deﬁne regular types τ(A) and τ(P) relative to a ﬁxed assignment of a type
variable αX to each predicate variable X.

Program Extraction via Typed Realisability
171
If A is non-computational:
r(A) = {Nil | A}
τ(A) = 1
If A is non-computational but B is:
r(A ∧B) =
τ(A ∧B) =
r(B ∧A) = {x | A ∧r(B)(x)}
τ(B ∧A) = τ(B)
r(A→B) = {x | A →r(B)(x)}
τ(A→B) = τ(B)
In all other cases:
r(P(⃗t)) = {x | r(P)(x,⃗t)}
τ(P(⃗t)) = τ(P)
r(A ∧B) = Pair(r(A), r(B))
τ(A ∧B) = τ(A) × τ(B)
r(A ∨B) = Left(r(A)) ∪Right(r(B))
τ(A ∨B) = τ(A) + τ(B)
r(A→B) = {f | f(r(A)) ⊆r(B)}
τ(A→B) = τ(A)→τ(B)
r(∀y A) = {x | ∀y (r(A)(x))}
τ(∀y A) = τ(A)
r(∃y A) = {x | ∃y (r(A)(x))}
τ(∃y A) = τ(A)
If P is non-computational:
r(P) = {(Nil, ⃗x) | P(⃗x)}
τ(P) = 1
Otherwise:
r({⃗x | A}) = {(y, ⃗x) | r(A)(y)}
τ({⃗x | A}) = τ(A)
r(X) = 
X
τ(X) = αX
r(μX.P) = μ 
X.{(In(y), x) | r(P)(y, x)}
τ(μX.P) = ﬁx αX.τ(P)
r(νX.P) = ν 
X.{(In(y), x) | r(P)(y, x)}
τ(νX.P) = ﬁx αX.τ(P)
where in the last two equations In := Inﬁx αX.τ(P).
Let us see what we get when we apply realisability to our examples from the In-
troduction. The type associated with the inductively deﬁned set N of natural num-
bers is τ(N) = ﬁx α.1 + α, the usual recursive deﬁnition of the data type of unary
natural numbers. Its canonical inhabitants are the numerals k := inrk(inl(Nil)))
(k ∈N). Realisability for N, r(N), is the least relation such that
r(N) = {(inl(Nil), 0)} ∪{(inr(n), x + 1) | r(N)(n, x)}
Hence, we have for a data d and k ∈R that d r N(k) holds iff k is a natural number
and d = k, i.e. d is a unary representation of k.

172
Ulrich Berger and Monika Seisenberger
If in the second example we identify notationally the set SD with the type 1 +
1 + 1, then τ(C0) = ﬁx α.SD × α, the type of inﬁnite streams of signed digits.
r(C0) is the largest predicate such that
r(C0) = {(Pair(di, a), (i + x)/2)) | i ∈SD ∧|(i + x)/2| ≤1 ∧r(C0)(a, x)}
It is easy to see that r(C0)(a, x) means that the signed digit stream a = a0, a1, . . .
represents x i.e. x = Σ∞
i=02−(i+1) ∗ai.
4.2 Soundness
Now we prove that the realisability interpretation is sound in the sense that from
every proof of a formula A one can extract a term M of type τ(A) and a proof that
M realises A.
For every L-operator Φ = λX.P we deﬁne a r(L)-operator r(Φ) := λ 
X.r(P).
Lemma 4.1 (Substitution). r(Φ)(r(Q)) = r(Φ(Q)).
Proof. Straightforward induction on the (syntactic) size of Φ.
In the next lemmas we consider predicates in the language r(L) whose ﬁrst ar-
guments range over predicate terms. The following deﬁnitions will be used:
P ◦f := {(x, ⃗y) | (f x, ⃗y) ∈P}
f ∗P := {(f x, ⃗y) | (x, ⃗y) ∈P}
Clearly, (P ◦f) ◦g = P ◦(f ◦g) and f ∗(g ∗P) = (f ◦g) ∗P. The rationale for
these deﬁnitions is that they allow us to neatly write certain sets of realisers:
r(P ⊆Q) = {f | r(P) ⊆r(Q) ◦f} = {f | f ∗r(P) ⊆r(Q)}
r(μX.P) = μ 
X.in ∗r(P)
r(νX.P) = ν 
X.in ∗r(P)
where in the last two clauses in := inﬁx αX.τ(P).
The following easy lemma, which says that the operations f →P ◦f and
f →f ∗P are adjoints, will allow for an analogous treatment of induction and
coinduction.
Lemma 4.2 (Adjunction). Q ⊆P ◦f ⇔f ∗Q ⊆P
Setting Q := P ◦f or P := f ∗Q in the adjunction lemma, we immediately get
f ∗(P ◦f) ⊆P and Q ⊆(f ∗Q) ◦f.

Program Extraction via Typed Realisability
173
Lemma 4.3 (Map). Let Φ = λX.P′ be a (strictly positive) operator in the lan-
guage L, α := αX, and ρ := τ(P′). Then mapα;ρ realises the monotonicity of Φ,
that is
mapα;ρ r (P ⊆Q →Φ(P) ⊆Φ(Q))
for all L-predicates P and Q. By the deﬁnition of realisability and the Adjunction
Lemma 4.2 this is equivalent to each of the following two statements about arbitrary
r(L)-predicates P and Q of appropriate arity and all f:
(a) P ⊆Q ◦f →r(Φ)(P) ⊆r(Φ)(Q) ◦mapα;ρf
(b) f ∗P ⊆Q →mapα;ρf ∗r(Φ)(P) ⊆r(Φ)(Q)
Furthermore, setting in (a) P := Q ◦f and in (b) Q := f ∗P one obtains
(c) r(Φ)(Q ◦f) ⊆r(Φ)(Q) ◦mapα;ρf
(d) mapα;ρf ∗r(Φ)(P) ⊆r(Φ)(f ∗P)
Proof. We show a slight generalisation of (a). Let Φ = λ ⃗X.P′ be an operator with
n arguments, αi = αXi and ρ = ρ(⃗α) = τ(P′). Then we have for all predicates
⃗P = P1, . . . , Pn, ⃗Q = Q1, . . . , Qn in the language r(L) and ⃗f = f1, . . . , fn
P1 ⊆Q1 ◦f1 →. . . →Pn ⊆Qn ◦fn →r(Φ)(⃗P) ⊆r(Φ)( ⃗Q) ◦mapα;ρ ⃗f
The proof is by induction on the structure of P′. Recall that r(Φ) = λ⃗
X.r(P′).
Case: No Xi occurs freely in P′. Then map⃗α;ρ ⃗f is the identity. Furthermore,
the operator r(Φ) is constant. Therefore, the assertion clearly holds. In the follow-
ing we assume that there is an Xi occurring freely in P′.
We only look at the remaining interesting cases, namely those where P′ is Xi
for some i, μZ.P0 or νZ.P0.
Case P′ = Xi. Then r(Φ)(⃗
X) = !
Xi. Since map⃗α;αi ⃗f = fi, the assertion
holds.
Case P′ = μZ.P0.
Let Φ0 := λ ⃗X, Z.P0.
Then r(Φ)(⃗
X) = μ Z.inρ ∗
r(Φ0)(⃗
X, Z).
Let Qn+1 := r(Φ)( ⃗Q) = μ Z.inρ ∗r(Φ0)( ⃗Q, Z).
Assume
Pi ⊆Qi ◦f for all i ≤n. Then we need to show
μ Z.inρ ∗r(Φ0)(⃗P, Z) ⊆Qn+1 ◦mapα;ρ ⃗f
We use induction on μ Z.inρ ∗r(Φ0)(⃗P, Z). Hence, it remains to show
inρ ∗r(Φ0)(⃗P, Qn+1 ◦map⃗α;ρ ⃗f) ⊆Qn+1 ◦map⃗α;ρ ⃗f

174
Ulrich Berger and Monika Seisenberger
i.e., using the Adjunction Lemma 4.2,
r(Φ0)(⃗P, Qn+1 ◦map⃗α;ρ ⃗f) ⊆Qn+1 ◦map⃗α;ρ ⃗f ◦inρ
In the ﬁrst step of the following we use the induction hypothesis with our assump-
tion and Pn+1 := Qn+1 ◦map⃗α;ρ ⃗f.
r(Φ0)(⃗P, Pn+1)
i.h.
⊆r(Φ0)( ⃗Q, Qn+1) ◦map⃗α,α;ρ(⃗α,α) ⃗f(map⃗α;ρ ⃗f)
Lemma 4.2
⊆
(inρ ∗r(Φ0)( ⃗Q, Qn+1)) ◦inρ ◦map⃗α,α;ρ(⃗α,α) ⃗f(map⃗α;ρ ⃗f)
Lemma 3.11
=
(inρ ∗r(Φ0)( ⃗Q, Qn+1)) ◦((mapα;ρ ⃗f) ◦inρ)
=
(inρ ∗r(Φ0)( ⃗Q, μ Z.inρ ∗r(Φ0)( ⃗Q, Z))) ◦((mapα;ρ ⃗f) ◦inρ)
ﬁxed point
=
μ Z.inρ ∗r(Φ0)( ⃗Q, Z) ◦((mapα;ρ ⃗f) ◦inρ)
=
Qn+1 ◦((mapα;ρ ⃗f) ◦inρ)
Case P′ = νZ.P0.
Let Φ0 := λ ⃗X, Z.P0.
Then r(Φ)(⃗
X) = ν Z.inρ ∗
r(Φ0)(⃗
X, Z). In this case it is more convenient to use and prove the formula-
tion of (the generalisation of) (b). Assume fi ∗Pi ⊆Qi for all i ≤n. Setting
Pn+1 := r(Φ)(⃗P) = ν Z.inρ ∗r(Φ0)(⃗P, Z), we have to show
map⃗α;ρ ⃗f ∗Pn+1 ⊆ν Z.inρ ∗r(Φ0)( ⃗Q, Z)
We use coinduction on ν Z.r(Φ0)( ⃗Q, Z). This reduces the problem to showing
map⃗α;ρ ⃗f ∗Pn+1 ⊆inρ ∗r(Φ0)( ⃗Q, map⃗α;ρ ⃗f ∗Pn+1)
inρ ∗r(Φ0)( ⃗Q, map⃗α;ρ ⃗f ∗Pn+1)
i.h.
⊇
inρ ∗((map⃗α,α;ρ(⃗α,α) ⃗f(map⃗α;ρ ⃗f)) ∗r(Φ0)(⃗P, Pn+1))
=
(inρ ◦(map⃗α,α;ρ(⃗α,α) ⃗f(map⃗α;ρ ⃗f))) ∗r(Φ0)(⃗P, Pn+1)
Lemma 3.11
=
((map⃗α;ρ ⃗f) ◦inρ) ∗r(Φ0)(⃗P, Pn+1)
=
(map⃗α;ρ ⃗f) ∗(inρ ∗r(Φ0)(⃗P, Pn+1))
ﬁxed point
=
(map⃗α;ρ ⃗f) ∗Pn+1

Program Extraction via Typed Realisability
175
Theorem 4.4 (Soundness). From a closed derivation of a formula A one can ex-
tract a program term M such that r(A)(M) and M : τ(A) are derivable.
Proof. As usual, one shows by induction on derivations the following more
general statement: From a derivation B1, . . . , Bn, ⃗C ⊢A where ⃗C are non-
computational assumptions one can extract a program term M with free variables
among x1 : τ(B1), . . . , xn : τ(Bn) such that
r(B1)(x1), . . . , r(Bn)(xn), ⃗C ⊢r(A)(M)
and x1 : τ(B1), . . . , xn : τ(Bn) ⊢M : τ(A). In the following, we concentrate on
the interesting cases: (Co)closure and (Co)induction. Let in the following α :=
αX, ρ := ρ(α) := τ(Φ(X)) and Φ = λX.P.
Closure. We show that M := inﬁx α.ρ realises closure, i.e.
r(Φ(μΦ)) ⊆r(μΦ) ◦inﬁx α.ρ
Using both, Adjunction Lemma 4.2 and Substitution Lemma 4.1, it sufﬁces to show
inﬁx α.ρ ∗(r(Φ)(r(μΦ))) ⊆r(μΦ)
i.e., since ∗and substitution commute,
(λ 
X.inﬁx α.ρ ∗r(P))(r(μΦ)) ⊆r(μΦ)
But the latter is the closure axiom for r(μΦ). Moreover, we have x : ρ(ﬁx α.ρ) ⊢
Inﬁx α.ρ(x) : ﬁx α.ρ, that is, ⊢M : ρ(ﬁx α.ρ) →ﬁx α.ρ (= τ(Φ(μΦ) ⊆μΦ)).
Coclosure. Similar, by setting M := outﬁx α.ρ.
outﬁx α.ρ r μΦ ⊆Φ(μΦ)
can be derived from the coclosure axiom for r(νϕ) = ν 
X.inﬁx α.ρ ∗r(P).
Induction. By the Substitution Lemma 4.1, we have r(Φ(Q)⊆Q →μΦ⊆Q) =
{f | ∀s (r(Φ)(r(Q)) ⊆r(Q) ◦s →r(μΦ) ⊆r(Q) ◦fs)}. Hence, in order to
show that Itﬁx α.ρ (=: M) realises induction, we assume
r(Φ)(r(Q)) ⊆r(Q) ◦s
(∗)
and show r(μΦ) ⊆r(Q)◦Itﬁx α.ρs. We use induction on r(μΦ) which reduces the
problem to showing (λ 
X.inﬁx α.ρ ∗r(P))(r(Q) ◦Itﬁx α.ρs) ⊆r(Q) ◦Itﬁx α.ρs,
i.e., using the Adjunction Lemma to
(λ 
X.r(P))(r(Q) ◦Itﬁx α.ρs) ⊆r(Q) ◦Itﬁx α.ρs ◦inﬁx α.ρ.

176
Ulrich Berger and Monika Seisenberger
r(Φ)(r(Q) ◦Itﬁx α.ρs)
Lemma 4.3 (c)
⊆
r(Φ)(r(Q)) ◦mapα;ρ(Itﬁx α.ρs)
(∗)
⊆
r(Q) ◦s ◦mapα;ρ(Itﬁx α.ρs)
Lemma 3.13 (a)
=
r(Q) ◦Itﬁx α.ρs ◦inﬁx α.ρ
Moreover, Lemma 3.12 shows that M has the desired type.
Coinduction. Using the Substitution Lemma and the Adjunction Lemma we have
r(Q⊆Φ(Q) →Q⊆μΦ)
= {f | ∀s (s ∗r(Q) ⊆r(Φ)(r(Q)) →fs ∗r(Q) ⊆r(νΦ))}
Similar to the induction case, we can now show that M := Coitﬁx α.ρ is a re-
aliser of the coinduction axiom by using the coinduction axiom for r(νΦ) and
Lemma 4.3 (d) as well as Lemma 3.13 (b).
4.3 Program extraction
We now combine the Soundness Theorem and the Adequacy Theorem to a theo-
rem essentially saying that extracted programs compute the expected results. By
“result” we can, from the user’s perspective, only mean observable data, i.e. data as
deﬁned in Sect. 3.1, namely terms built from constructors only. Hence we restrict
our attention to a class of formula where all realisers are data. We call an L-formula
a data formula if it contains neither free predicate variables nor coinductive deﬁ-
nitions, and every subformula which is an implication is non-computational. Let
Data be a formal representation of the set of all data, i.e. the r(L)-predicate
Data = μX.

C constructor
{C(⃗x) | ⃗x ∈X}
Lemma 4.5 (Data formulas). r(A) ⊆Data for every data formula A.
Proof. We show more generally: if A is an L-formula such that every subformula
which is an implication is non-computational (but A may contain free predicate
variables), then
r(A)Data ⊆Data
where r(A)Data is obtained from r(A) by replacing every n+1-ary r(L)-predicate
variable 
X by the r(L)-predicate Data′ := {(x, ⃗y) | Data(x)} of the same arity.

Program Extraction via Typed Realisability
177
The proof is by induction on the structure of A. All other cases are straightforward,
except (μX.P)(⃗t). In the latter case we have
r((μX.P)(⃗t)) = {In(y) | (μ 
X.r(P))(y,⃗t)}
Therefore, it sufﬁces to show μ 
X.r(P)′ ⊆Data′. Where r(P)′ is is obtained
from r(P) by replacing every r(L)-predicate variable Y by Data′, except 
X. We
show this by induction. Hence we have to show r(P)′[Data′/ 
X] ⊆Data′, i.e.
r(P)Data ⊆Data′, i.e. ∀⃗x (r(P)(⃗x)Data ⊆Data). The latter follows from the
(structural) induction hypothesis.
Theorem 4.6 (Program Extraction). From a proof of a data formula A one can
extract a program term M with the property that (M, ∅) =⇒d for some data d
provably realising A, i.e. d r A is provable.
Proof. By the Soundness Theorem, we obtain from a proof of A a program term
M and a proof of M r A. By Lemma 4.5, Data(M) is provable and therefore true
in D, i.e. [[M]] = d for some data d. By the Adequacy Theorem, (M, ∅) =⇒d,
and by Lemma 3.3, M = d is provable. It follows that d r A is provable.
Let us continue our examples from Sect. 2 and Sect. 4.1. Suppose we have
proved C0(x) for some real number x ∈I. In order to obtain observable infor-
mation about x, for example for a given natural number n a dyadic rational that
approximates x with an error ≤2−10, we need to prove that there exist an integer
z < 2−n such that |x −z/(2n)| ≤2−n. From the proof we can then extract a
representation of z and hence of the approximating rational z/(210). First, let us
deﬁne inductively a predicate Z such that Z(z, n) means that n is a natural number
and z is an integer < 2n.
Z = μX.{(0, 0)} ∪{(2ni + z, n + 1) | i ∈SD ∧X(z, n)}
It easy to see that a realiser of Z(z, n) is a signed binary representation of z (per-
mitting leading zeros).
Lemma 4.7 (Printing digits).
∀n (N(n) →∀x (C0(x) →∃z (Z(z, n) ∧|x −z
2n | ≤1
2n )))
Proof. Induction on N(n). Set P := {n | ∀x (C0(x) →∃z (Z(z, n) ∧|x−z
2n | ≤
1
2n ))}. We have to show (1) P(0), (2) ∀n (P(n) →P(n + 1). For (1), we can take
z := 0, since C0(x) implies |x| ≤1. For (2), assume P(n) (i.h.) and C0(x). Let

178
Ulrich Berger and Monika Seisenberger
i ∈SD such that x = (i + y)/2 for some y with C0(y). By i.h. there exists z such
that Z(z, n) and |y −
z
2n | ≤
1
2n . It follows Z(2ni + z, n + 1) and
|x −2ni + z
2n+1 | = 1
2|y −z
2n | ≤
1
2n+1
The program extracted from this proof takes as inputs a (unary) natural number
n and a signed digit stream a representing some real number in I, and computes a
signed binary representation of an integer z < 2n such that |x −z/2n| ≤1/2n.
In fact, the digits of that representation will be exactly the ﬁrst n elements of the
stream a. Hence, the extracted program is essentially Haskell’s function take that
computes the ﬁrst n elements of a stream.
5 Conclusion and further work
In this paper we laid the programming-technological and proof-theoretic founda-
tions for program extraction from proofs in a constructive theory of inductive and
coinductive deﬁnitions. We showed that the realising programming language has an
adequate denotational and operational semantics and the realisability interpretation
is sound. Both results together imply that from proofs of formulas with associ-
ated observable types (data formulas) one can extract programs that compute data
realising the formula.
In our opinion, one of the main advantages of program extraction over the tradi-
tional specify-implement-verify method is that it is possible to carry out proofs in
a very simple formal system. Neither complicated data types (lists, streams, trees,
function types, etc.) nor programming constructs (recursion, lambda-abstraction)
need to be formalised by the user; these are all generated by the realisability inter-
pretation automatically.
On the basis of the results of this paper one can now begin to formalise parts of
constructive analysis and other branches of mathematics where inductive and coin-
ductive deﬁnitions are used (or can be used), with the aim of extracting nontrivial
certiﬁed programs. Currently, we are investigating a generalisation of the predicate
C0 ⊆R (one of our running examples) to predicates Cn ⊆RIn characterising the
(constructively) uniformly continuous function from In to I [Ber09]. For n = 1 the
deﬁnition is
C1 :=
νF.μG.{f ∈II | ∃i ∈SD ∃f′ (f = avi◦f ′ ∧F(f′)) ∨∀i ∈SD G(f ◦avi)}

Program Extraction via Typed Realisability
179
where F and G range over subsets of RI and avi(x) := (i + x)/2. To see the
analogy with C0 it is useful to rewrite the deﬁnition of the latter equivalently as
C0 := νX.{x ∈I | ∃i ∈SD ∃x′ (x = avi(x′) ∧X(x′))}
The predicate C0 characterises real numbers in I as objects perpetually emitting
digits. A continuous function f : I →I, which can be viewed as a real number in I
that depends on an input in I, perpetually emits digits as well, but before an emis-
sion can take place f may have to gain information about the input by absorbing
ﬁnitely many digits from it in order to decide which digit to emit. The absorption
part is formalised in C1 by the inner “μG . . . G(f ◦avi)”. The data type associated
with C1 is
τ(C1) = να.μβ.SD × α + β3
which is the type of non-wellfounded trees with two kinds of nodes, one labelled
by a signed digit and one child (emitting a digit), the other without label and three
children (absorbing a digit). The fact that β is quantiﬁed by μ means that only those
trees are legal members of τ(C1) that have on each path inﬁnitely many emitting
nodes. A similar type of trees has been studied independently in [GHP06], however,
not in the context of analysis and realisability. The deﬁnition of C1 is motivated by
earlier works on the development and veriﬁcation of exact real number algorithms
based on the signed digit representation of real numbers [MRE07,GNSW07,EH02]
some of which make use of coinductive methods [CDG06,Ber07,BH08,Niq08].
Based on the characterisation of uniformly continuous functions by the pred-
icates Cn implementations of elementary arithmetic functions have been ex-
tracted [Ber09]. Further work in progress studies integration and analytic functions
based on this approach. We are also extending this work to more general situations
where the interval I and the maps avi are replaced by an arbitrary bounded met-
ric space with a system of contractions (see [Scr08] for related work), or even to
non-metric situations.
Currently, we are adapting the existing implementation of program extraction in
the Minlog proof system [BBS+98] to our setting.
References
[AMU05]
A. Abel, R. Matthes, and T. Uustalu. Iteration and coiteration schemes for
higher-order and nested datatypes. Theor. Comput. Sci., 333:3–66, 2005.
[BBS+98]
H. Benl, U. Berger, H. Schwichtenberg, M. Seisenberger, and W. Zuber. Proof
theory at work: Program development in the Minlog system. In W. Bibel and
P.H. Schmitt, editors, Automated Deduction – A Basis for Applications, vol-
ume II of Applied Logic Series, pages 41–71. Kluwer, Dordrecht, 1998.

180
Ulrich Berger and Monika Seisenberger
[BC94]
B. Blaaberg and C. Clausen. Adequacy for a lazy functional language with
recursive and polymorphic types. Theor. Comput. Sci., 136(1):243–275, 1994.
[Ber05]
U. Berger. Strong normalization for applied lambda calculi. Logical Methods
in Comput. Sci., 1(2):1–14, 2005.
[Ber07]
Y. Bertot.
Afﬁne functions and series with co-inductive real numbers.
Math. Struct. Comput. Sci., 17:37–63, 2007.
[Ber09]
U. Berger. From coinductive proofs to exact real arithmetic. In E. Gr¨adel and
R. Kahle, editors, Computer Science Logic, volume 5771 of LNCS, pages 132–
146. Springer, 2009.
[BFPS81]
W. Buchholz, F. Feferman, W. Pohlers, and W. Sieg. Iterated Inductive Deﬁ-
nitions and Subsystems of Analysis: Recent Proof–Theoretical Studies, volume
897 of Lecture Notes in Mathematics. Springer, Berlin, 1981.
[BH08]
U. Berger and T. Hou. Coinduction for exact real number computation. Theory
of Computing Systems, 43:394–409, 2008.
[BS07]
J. Bradﬁeld and C. Stirling. Modal mu-calculi. In P. Blackburn, J. van Benthem,
and F. Wolter, editors, Handbook of Modal Logic, volume 3 of Studies in Logic
and Practical Reasoning, pages 721–756. Elsevier, 2007.
[CDG06]
A. Ciaffaglione and P. Di Gianantonio. A certiﬁed, corecursive implementation
of exact real numbers. Theor. Comput. Sci., 351:39–51, 2006.
[CS06]
T. Coquand and A. Spiwack. A proof of strong normalisation using domain the-
ory. In Proceedings of the 21st Annual IEEE Symposium on Logic in Computer
Science (LICS’06), pages 307–316. IEEE Computer Society Press, 2006.
[EH02]
A. Edalat and R. Heckmann. Computing with real numbers: I. The LFT ap-
proach to real number computation; II. A domain framework for computational
geometry. In G. Barthe, P. Dybjer, L. Pinto, and J. Saraiva, editors, Applied
Semantics - Lecture Notes from the International Summer School, Caminha,
Portugal, pages 193–267. Springer, 2002.
[GHK+03] G. Gierz, K.H. Hofmann, K. Keimel, J.D. Lawson, M. Mislove, and D.S. Scott.
Continuous Lattices and Domains, volume 93 of Encyclopedia of Mathematics
and its Applications. Cambridge University Press, 2003.
[GHP06]
N. Ghani, P. Hancock, and D. Pattinson. Continuous functions on ﬁnal coalge-
bras. Electr. Notes in Theoret. Comput. Sci., 164, 2006.
[Gir71]
J-Y. Girard. Une extension de l’interpr´etation de G¨odel `a l’analyse, et son ap-
plication `a l’´elimination des coupures dans l’analyse et la th´eorie des types. In
J.E. Fenstad, editor, Proceedings of the Second Scandinavian Logic Symposium,
pages 63–92. North–Holland, 1971.
[GNSW07] H. Geuvers, M. Niqui, B. Spitters, and F. Wiedijk. Constructive analysis, types
and exact real numbers. Math. Struct. Comput. Sci., 17(1):3–36, 2007.

Program Extraction via Typed Realisability
181
[HO08]
M. D. Hernest and P. Oliva. Hybrid functional interpretations. In A. Beckmann,
C. Dimitracopoulos, and B. L¨owe, editors, CiE 2008: Logic and Theory of
Algorithms, volume 5028 of LNCS, pages 251–260. Springer, 2008.
[KP90]
Jean-Louis Krivine and Michel Parigot. Programming with proofs. Elektronis-
che Informationsverarbeitung und Kybernetik, 26(3):149–167, 1990.
[M¨03]
M. M¨ollerfeld. Generalized inductive deﬁnitions. PhD thesis, Westf¨alische
Wilhelms-Universit¨at M¨unster, 2003.
[Mat01]
R. Matthes. Monotone inductive and coinductive constructors of rank 2. In
L Fribourg, editor, Computer Science Logic (Proceedings of the Fifteenth CSL
Conference), number 2142 in LNCS, pages 600–615. Springer, 2001.
[Men91]
N.P. Mendler. Inductive types and type constraints in the second-order lambda
calculus. Ann. Pure Appl. Logic, 51:159–172, 1991.
[MP05]
F. Miranda-Perea. Realizability for monotone clausular (co)inductive deﬁni-
tions. Electr. Notes in Theoret. Comput. Sci., 123:179–193, 2005.
[MRE07]
J. R. Marcial-Romero and M. H. Escardo. Semantics of a sequential language
for exact real-number computation. Theor. Comput. Sci., 379(1-2):120–141,
2007.
[Niq08]
M. Niqui. Coinductive formal reasoning in exact real arithmetic. Logical Meth-
ods in Computer Science, 4(3:6):1–40, September 2008.
[Par92]
M. Parigot.
Recursive programming with proofs.
Theor. Comput. Sci.,
94(2):335–356, 1992.
[Pit94]
A.M. Pitts.
Computational adequacy via ”mixed” inductive deﬁnitions.
In
Proceedings of the 9th International Conference on Mathematical Foundations
of Programming Semantics, pages 72–82, London, UK, 1994. Springer-Verlag.
[Plo77]
G.D. Plotkin. LCF considered as a programming language. Theor. Comput. Sci.,
5:223–255, 1977.
[Rey74]
J.C. Reynolds. On the relation between direct and continuation semantics. In
Proceedings of the 2nd Colloquium on Automata, Languages and Program-
ming, pages 141–156, London, UK, 1974. Springer-Verlag.
[RT10]
D. Ratiu and T. Trifonov. Exploring the computational content of the inﬁnite
pigeonhole principle. To appear in Journal of Logic and Computation, 2010.
[Sch08]
H. Schwichtenberg. Realizability interpretation of proofs in constructive anal-
ysis. Theory of Computing Systems, 43(3-4):583–602, 2008.
[Scr08]
A. Scriven. A functional algorithm for exact real integration with invariant
measures. Electron. Notes Theor. Comput. Sci., 218:337–353, 2008.
[Tai75]
W.W. Tait. A realizability interpretation of the theory of species. In R. Parikh,
editor, Logic Colloquium Boston 1971/72, volume 453 of Lecture Notes in
Mathematics, pages 240–251. Springer, 1975.

182
Ulrich Berger and Monika Seisenberger
[Tat98]
M. Tatsuta. Realizability of monotone coinductive deﬁnitions and its appli-
cation to program synthesis. In R. Parikh, editor, Mathematics of Program
Construction, volume 1422 of Lecture Notes in Mathematics, pages 338–364.
Springer, 1998.
[Tup04]
S. Tupailo. On the intuitionistic strength of monotone inductive deﬁnitions.
Jour. Symb. Logic, 69(3):790–798, 2004.
[Win93]
G. Winskel. The Formal Semantics of Programming Languages. Foundations
of Computing Series. The MIT Press, Cambridge, Massachusetts, 1993.

Another Reduction of Classical IDν to
Constructive IDi
ν
Wilfried Buchholz
Mathematisches Institut
Ludwig-Maximilians-Universit¨at M¨unchen
Theresienstr. 39, D-80333 M¨unchen, Germany
buchholz@mathematik.uni-muenchen.de
Introduction. One of the major problems in reductive proof theory in the early
1970s was to give a proof-theoretic reduction of classical theories of iterated arith-
metical inductive deﬁnitions to corresponding constructive systems. This problem
was solved in [BFPS] in various ways which all where based on the method of cut-
elimination (normalization, reps.) for inﬁnitary Tait-style sequent calculi (inﬁni-
tary systems of natural deduction, resp.). Only quite recently Avigad and Towsner
[AT09] succeeded in giving a reduction of classical iterated ID theories to construc-
tive ones by the method of functional interpretation. For a thorough exposition and
discussion of all this cf. [Fef].
In the present paper we give yet another reduction of classical IDν to IDi
ν(W)
based on cut-elimination arguments.
W is a particularly simple accessibility
ID; its corresponding operator form W(P, Q, y, x) (cf. [BFPS]) has the shape
A(x, y)
∧
∀z( Q(t(x), z) →Pq(x, z)) with primitive recursive A, t, q, and
Q(u, z) :≡u ≥1 ∧(u ≥2 →Q(u −· 2, z)). There are two reasons which, as we
hope, justify a publication of this additional proof. First, it is considerably more di-
rect then all the existing ones. Second, the method used here stems to a great extent
from [Ge36] and therefore may be interesting for historical reasons too. Actually I
have already used a variant of this method under the label “notations for inﬁnitary
derivations” in several papers (e.g. [Bu91], [Bu97], [Bu01]) without mentioning
its close relationship to [Ge36]. When writing [Bu91] I was deﬁnitely not aware of
this connection; but cf. [Bu95]. The method from [Ge36] can be roughly described
as follows: By (primitive) recursion on the build-up of h, for each derivation h
in a suitably designed ﬁnitary proof system Z of ﬁrst order arithmetic a family
(h[i])i∈Ih of Z-derivations is deﬁned such that
. . . Γ(d[i]) . . . (i ∈Ih)
Γ(h)
(where
Γ(h) denotes the endsequent of h) forms an inference in cutfree ω-arithmetic (with
repetition-rule). Then the consistency of Z is obtained by quantiﬁerfree transﬁnite
induction over the relation ≺:= {(h[i], h) : h ∈Z & i ∈Ih}. In the present
paper we proceed similarly. Let IDν be the ﬁnitary Tait-style system of ν-fold

184
Wilfried Buchholz
iterated inductive deﬁnitions as introduced in [Bu02]. We extend IDν by certain
inferences E, Dσ, SΠ
P,F (which do not alter the set of derivable sequents) to a ﬁni-
tary system ID∗
ν. This step corresponds very much to the passage from BI−
1 to
BI∗
1 in [Bu01]. Then by primitive recursion on the height of h, for each closed
ID∗
ν-derivation h we deﬁne a family (h[ι])ι∈Ih of closed ID∗
ν-derivations such that
. . . Γ(h[ι]) . . . (ι ∈Ih)
Γ(h)
is an inference in the inﬁnitary system ID∞
ν . Formulated
more technical, we assign to h an inference symbol tp(h) of ID∞
ν , and for each
ι ∈|tp(h)| a closed ID∗
ν-derivation h[ι] such that
. . . Γ(h[ι]) . . . (ι ∈|tp(h)|)
Γ(h)
is a tp(h)-inference (0.10). On ﬁrst sight the present system ID∞
ν looks exactly
like the system ID∞
ν in [Bu02] (which itself is the Tait-style version of the natural
deduction system ID∞
ν from [Bu81]), but there is some subtle difference concern-
ing the index sets |ΩP | of instances of the Ω-rule. In [Bu02], |ΩP | is a set of
inﬁnitary derivations while in the present paper |ΩP | is a set of ﬁnite derivations,
namely |ΩP | = Iμ = set of all closed ID∗
ν-derivations h with deg(h) = 0 and
Γ(h) ⊆Posμ, where μ := lev(P). Now let Wσ be the accessible part of the
relation {(h[ι], h) : h ∈Iσ & ι ∈|tp(h)|W}, where |I|W := Wμ if I = ΩP
with μ := lev(P) < σ, and |I|W := |I| otherwise. The proof-theoretic reduc-
tion of IDν to IDi
ν(W) will be established by a proof of transﬁnite induction over
the relation {(h[i], h) : h ∈I0 & i ∈|tp(h)|} which can be locally formalized
in IDi
ν(W). The difﬁculty here is to come along without the uppermost set Wν,
which would be available in IDi
ν+1(W) but not in IDi
ν(W). We overcome this dif-
ﬁculty by using (a generalization of) Gentzen’s technique (cf. [Ge43]) for proving
transﬁnite induction up to ordinals < ε0 within Z.
In order to avoid some annoying but inessential technicalities we restrict our
treatment to ν < ω. So in the whole paper ν is a ﬁxed natural number > 0.
Preliminaries.
For the reader’s convenience we repeat some basic deﬁnitions
and abbreviations from [Bu02] (with some minor deviations). Let L be an arbitrary
ﬁrst order language (i.e. set of function and predicate symbols). Atomic L-formulas
are Rt1...tn where R is an n-ary predicate symbol (of L), and t1, ..., tn are L-
terms. Expressions of the shape A or ¬A, where A is an atomic L-formula, are
called literals. L-formulas are built up from literals by means of ∧, ∨, ∀x, ∃x.
FV(A) denotes the set of free variables of A. A formula or term A is called closed
if FV(A) = ∅. The negation ¬A of a non-atomic formula A is deﬁned via de
Morgan’s laws. The rank rk(A) of a formula A is deﬁned by: rk(A) := 0 if A is
a literal, rk(A ∧B) := rk(A ∨B) := max{rk(A), rk(B)} + 1, rk(∀xA) :=
rk(∃xA) := rk(A)+1. By A(x/t) we denote the result of substituting t for (every

Another Reduction of Classical IDν to Constructive IDi
ν
185
free occurrence of) x in A (renaming bound variables if necessary). Expressions
λx.F (where F is a formula) are called predicates and denoted by F. For F =
λx.F we set F(t) := F(x/t). If P is a unary predicate symbol then B(P/F)
denotes the result of substituting F for P in B, i.e. the formula resulting from B
be replacing every atom Pt by F(t). Let X be a unary predicate symbol not in L.
A positive operator form in L is an L ∪{X}-formula A in which X occurs only
positively (i.e. A has no subformula ¬Xt) and which has at most one free variable
x. We use the following abbreviations: A(F, t) := A(x/t)(X/F), A(F) ⊆F :=
∀x(A(F, x) →F(x)). For each positive operator form A we introduce a new
unary predicate symbol PA. Finite sets of formulas are called sequents. They are
denoted by Γ, Δ, Π. We mostly write A1, ..., An for {A1, ..., An}, and A, Γ, Δ for
{A} ∪Γ ∪Δ, etc.
Deﬁnition 0.1 (Lσ, Posσ, level). Let L0 be a language consisting of the constant 0
(zero), the unary function symbol S (successor), and some predicate symbols R for
primitive recursive relations, such that the set TRUE0 of all true closed L0-literals
is itself primitive recursive (under some canonical arithmetization of syntax). The
only closed L0-terms are the numerals 0, S0, SS0, ... which we identify with the
corresponding natural numbers (elements of IN). Arbitrary L0-terms will be de-
noted by t, t1, ..., and (number) variables by x, y.
• Lσ+1 := L0 ∪{PA : A positive operator form in Lσ} (σ < ω)
• Posσ := set of all Lσ+1-formulas C such every PA occurring negatively in C
belongs to Lσ.
• lev(PA) := lev(PAt) := min{σ : PAt ∈Posσ} (level)
Note that this “level” is not exactly the same as “level” in [Bu02].
Proposition 0.2.
(1) Lσ-formulas ⊆Posσ ⊆Lσ+1-formulas
(2) PAt ∈Posσ ⇒A(PA, t) ∈Posσ.
Abbreviations.
• L0-lit := set of all L0-literals.
• 	-for := set of all formulas of the shape A ∧B or ∀xA.
• C ∈	+-for :⇔C ∈	-for or C has the shape PAt

186
Wilfried Buchholz
• C[k] :=

Ck
if C = C0
∧
∨C1 and k ∈{0, 1}
A(x/k)
if C = ∃
∀xA and k ∈IN
Deﬁnition 0.3 (Inference symbols). An inference symbol is a formal expression I
for which the following entities are given
• a set |I| (the arity of I),
• a sequent Δ(I) (principal formula(s)),
• for each ι ∈|I| a sequent Δι(I) (minor formula(s)).
An inference symbol is called (in)ﬁnitary if its arity is (in)ﬁnite.
Notation. By writing
(I)
. . . Δι . . . (ι∈I)
Δ
we declare I as an inference symbol with |I| = I, Δ(I) = Δ, Δι(I) = Δι.
If I = {0, ..., n−1} we write
Δ0 Δ1 . . . Δn−1
Δ
,
instead of . . . Δι . . . (ι∈I)
Δ
.
Inference symbols I with |I| = ∅are called axioms.
Deﬁnition 0.4 (Proof systems). A proof system is given by a language L and a set
of inference symbols in this language, where “I in L” means that all elements of
Δ(I) ∪
ι∈|I| Δι(I) are L-formulas. A proof system is called ﬁnitary if all its
inference symbols are ﬁnitary; otherwise it is called inﬁnitary.
From now on the letters A, B, C always denote Lν-formulas, and P ranges over
predicate symbols PA ∈Lν.
Deﬁnition 0.5 (The ﬁnitary proof systems IDν and ID∗
ν). The language of IDν is
Lν, and the inference symbols of IDν are
(AxΓ)
Γ
if Γ ∈Ax(ν) where Ax(ν) is a set of Lν-sequents such that
(i) Γ ∈Ax(ν) =⇒Γ(⃗x/⃗t) ∈Ax(ν)
(ii) Γ ∈Ax(ν) & FV(Γ) = ∅=⇒Γ ∩TRUE0 ̸= ∅or Γ = {¬Pn, Pn}
or Γ = {n ̸= n, ¬Pn, Pn}
(iii) {¬A, A} ∈Ax(ν) for each atomic Lν-formula A
(	
A0 ∧A1)
A0
A1
A0 ∧A1
,
(
k
A0 ∨A1)
Ak
A0 ∨A1
(k ∈{0, 1}) ,

Another Reduction of Classical IDν to Constructive IDi
ν
187
(	y
∀xA)
A(x/y)
∀xA
,
(
t
∃xA)
A(x/t)
∃xA
,
(CutC)
C
¬C
∅
(C ∈	+-for ∪L0-lit),
(Indt
F)
¬F(0), ¬∀x(F(x) →F(Sx)), F(t) ,
(ClPAt)
A(PA, t)
PAt
,
(IndPAt
F
)
¬(A(F)⊆F), ¬PAt, F(t) .
The inference symbols AxΓ, 	
A ∧B, 
k
A ∨B, 
t
∃xA, ClPAt, and CutC with C ∈
L0-lit are called simple.
The proof system ID∗
ν is obtained from IDν by adding the following inference
symbols
(Jt
∀xA)
∀xA
A(x/t) ,
(Jk
A0 ∧A1)
A0 ∧A1
Ak
,
(SΠ
P,F)
Π
¬(A(F) ⊆F), Π(P/F)
with P = PA and Π ⊆Poslev(P) ,
(E)
∅
∅,
(Dσ)
∅
∅(σ < ν).
The role of E and Dσ will become clear in the deﬁnition of h+ below.
Inductive Deﬁnition of ID∗
ν-derivations: If I is an inference symbol of ID∗
ν of
arity l and h0, . . . , hl−1 are ID∗
ν-derivations such that for Γ := Δ(I)∪
i<l(Γ(hi)\
Δi(I)) we have
• I = 	y
∀xA ⇒y ̸∈FV(Γ),
• I = CutC ⇒FV(C) ⊆FV(Γ),
• I = 
t
C ⇒FV(t) ⊆FV(Γ),
• I = SΠ
P,F ⇒FV(Π) ⊆FV(Γ) and h0 = Dσh00 with σ := lev(P),
• I = Dσ ⇒Γ(h0) ⊆Posσ & deg(h0) = 0,
then h := Ih0 . . . hl−1 is an ID∗
ν-derivation and Γ(h) := Γ (endsequent of h),
deg(h) :=
⎧
⎪
⎨
⎪
⎩
deg(h0) −· 1
if I = E
max{rk(C), deg(h0), deg(h1)}
if I = CutC
supi<l deg(hi)
otherwise

188
Wilfried Buchholz
An IDν-derivation h is called closed if its endsequent Γ(h) is closed, i.e. if
FV(Γ(h)) = ∅.
Abbreviations.
• ID∗
ν := set of all closed ID∗
ν-derivations.
• h ⊢m Γ :⇔h ∈ID∗
ν with Γ(h) ⊆Γ and deg(h) ≤m.
• h ⊢σ
m Γ :⇔h ⊢m Γ and Γ ⊆Posσ.
• Iσ := {Dσh : h ⊢σ
0 Γ(h)} (= {Dσh : h ∈ID∗
ν & deg(h) = 0 & Γ(h) ⊆
Posσ}) (σ < ν)
Deﬁnition 0.6 (Substitution of numerals). For h = Ih0 . . . hn−1 let
h(y/k) :=

h
if I = 	y
∀xA
I(y/k)h0(y/k) . . . hl−1(y/k)
otherwise
where I(y/k) is deﬁned as expected, i.e., in such a way that the following holds:
h ⊢m Γ ⇒h(y/k) ⊢m Γ(y/k).
Convention. From now on we use h as syntactic variable for closed ID∗
ν-
derivations (i.e., elements of ID∗
ν).
Deﬁnition 0.7 (The inﬁnitary proof system ID∞
ν ). The language of ID∞
ν consists
of all closed Lν-formulas.
We use P as syntactic variable for formulas of the form PAn with PA ∈Lν.
The inference symbols of ID∞
ν are
• All simple inference symbols of IDν (restricted to closed formulas)
where Δ(AxΓ) is slightly modiﬁed, namely
Δ(AxΓ) :=

Γ ∩TRUE0
if Γ ∩TRUE0 ̸= ∅
Γ
otherwise
• (	
∀xA)
. . . A(x/i) . . . (i∈IN)
∀xA
,
(CutC)
C
¬C
∅
(C ∈	+-for),
• (Rep)
∅
∅,
• (ΩP )
P
. . . Γ(q) \ {P} . . . (q ∈Iμ)
∅
with μ := lev(P).

Another Reduction of Classical IDν to Constructive IDi
ν
189
Deﬁnition 0.8. (h+, tp(h), h[ι]). To each h ∈ID∗
ν we assign
• an inference symbol tp(h) of ID∞
ν ,
• for each ι ∈|tp(h)|, a derivation h[ι] ∈ID∗
ν.
For the sake of conciseness we write
h+ = I

hι

ι∈I for tp(h) = I & |I| = I & ∀ι ∈I(h[ι] = hι).
The deﬁnition proceeds by (primitive) recursion on the height of h. In clause 3.
we make use of the following abbreviation:
Cut◦
C(h0, h1) :=

CutC(h0, h1)
if C ∈	+-for ∪L0-lit
Cut¬C(h1, h0)
otherwise
Further we denote by dA the canonical cutfree IDν-derivation of {¬A, A}.
1.1. (Ih0...hl−1)+ := I(hi)i<l if I is simple.
1.2. (	y
∀xAh)+ := 	
∀xA
h(y/i)

i∈IN
1.3. (IndPn
F )+ := ΩPnAx{¬Pn,Pn}

S{Pn}
P,F q

q∈Iμ with μ := lev(P).
2.
(Indn
F)+ := Rep(dn) with d0 := dF(0),
di+1 :=
"i
∃x(F(x) ∧¬F(Sx))

F(i) ∧¬F(Si)didF(Si)
3. If C ∈	+-for and h+
1 = I

h1ι

ι∈I then:
(CutCh0h1)+ :=
⎧
⎪
⎨
⎪
⎩
I

CutCh0h1ι

ι∈I
if ¬C ̸∈Δ(I)
Cut◦
C[k]

Jk
Ch0, CutCh0h10

if I = 
k
¬C
Rep(h0)
if ¬C ∈Δ(I) and C = Pn
4.
If h+ = I(hι)ι∈I then
(Eh)+ :=

Rep

CutCEh0Eh1

if I = CutC with C ∈	+-for
I

Ehι

ι∈I
otherwise

190
Wilfried Buchholz
5.
If C ∈	-for and h+ = I

hι

ι∈I then
(Jk
Ch)+ :=

Rep

Jk
Chk

if I = 	
C
I

Jk
Chι

ι∈I
otherwise
6.
Assume that h = SΠ
P,Fd with P = PA, μ := lev(P) (< ν), d ∈Iμ, and
d+ = I(dι)ι∈I.
6.1. If I = ClPn with Pn ∈Π then
h+ := 
n
¬(A(F)⊆F)
	
A(F,n) ∧¬F(n)(SΠ∪Δ0(I)
P,F
d0)dF(n)

.
6.2. If I = 	
A, 
k
A with A ∈Π then h+ := I∗
SΠ∪Δι(I)
P,F
dι

ι∈I
where (	
A)∗:= 	
A(P/F), (
k
A)∗:= 
k
A(P/F).
6.3. Otherwise: h+ := I

SΠ
P,Fdι

ι∈I.
7.
If h+ = I

hι

ι∈I then
(Dσh)+ :=

Rep

DσhDμh0

if I = ΩP with μ := lev(P) ≥σ
I

Dσhι)ι∈I
otherwise
Deﬁnition 0.9.
• ID∞
ν ⌈σ := ID∞
ν \ {ΩP : lev(P) ≥σ}
• deg(I) :=

rk(C) + 1
if I = CutC with C ∈	+-for
0
otherwise
Lemma 0.10. If h ⊢σ
m Γ & h+ = I(hι)ι∈I then
I ∈ID∞
ν ⌈σ & Δ(I) ⊆Γ & deg(I) ≤m & ∀ι ∈I(hι ⊢σ
m Γ, Δι(I)).
Proof. The proof of this lemma is routine and can be left to the reader (cf. Theorem
3 in [Bu97] and Theorem 5 in [Bu01]).
Deﬁnition 0.11 (Iterated Inductive Deﬁnition of Wσ (σ < ν)).
1. If h ∈Iσ with |tp(h)| ⊆IN and ∀i ∈|tp(h)|(h[i] ∈Wσ) then h ∈Wσ.
2. If h ∈Iσ with tp(h) = ΩP , lev(P) < σ and ∀ι ∈Wlev(P )(h[ι] ∈Wσ) then
h ∈Wσ.

Another Reduction of Classical IDν to Constructive IDi
ν
191
Note that (according to Lemma 0.10) if h ∈Iσ and tp(h) =
ΩP then
lev(P) < σ.
Note further that Wσ is by deﬁnition a subset of Iσ.
Our goal is now to show that IDν is Π0
2-conservative over IDi
ν(W) (where
W denotes the operator form corresponding to the iterated inductive deﬁnition of
(Wσ)σ<ν). We will achieve this goal by giving an informal proof of
“If h is an IDν-derivation of a Π0
2-sentence A and
if h has height and degree ≤m then A holds.”
(1)
which for each ﬁxed m ∈IN can be formalized in IDi
ν(W).
Abbreviations.
• W∗:= {h : ∀σ < ν(h ⊢σ
0 Γ(h) ⇒Dσh ∈Wσ)},
• FALSE0 := {¬A : A ∈TRUE0},
• Emh := E . . . E
# $% &
m times
h.
Lemma 0.12. Let R be a binary relation symbol of L0.
(a) If h is an IDν-derivation of ∃yR(x, y) with deg(h) = m, then for all n we
have:
Emh(x/n) ∈W∗⇒W0 ∋D0Emh(x/n) ⊢∃yR(n, y).
(b) W0 ∋h ⊢Γ, ∃yR(n, y) with Γ ⊆FALSE0 ⇒there exists k with R(n, k).
Proof. (a) Obviously Emh(x/n) ⊢0
0 ∃yR(n, y) which yields the claim.
(b) Induction over W0: We have h+ = I(hi)i∈I with hi ∈W0 for all i ∈I.
By Lemma 0.10 one of the following cases holds:
1. I = Rep and h0 ⊢Γ, ∃yR(n, y).
2. I = CutC with C ∈FALSE0 and h0 ⊢Γ, C, ∃yR(n, y).
3. I = CutC with ¬C ∈FALSE0 and h1 ⊢Γ, ¬C, ∃yR(n, y).
4. I = 
k
∃yR(n,y) with R(n, k) ∈FALSE0 and h0 ⊢Γ, R(n, k), ∃yR(n, y).
5. I = 
k
∃yR(n,y) and R(n, k) ∈TRUE0.

192
Wilfried Buchholz
In cases 1–4 the claim follows immediately from the IH (induction hypothesis). In
case 5 we are done.
Now for establishing (1) it remains to prove:
Emh ∈W∗holds for each closed IDν-derivation h and each m ∈IN.
(2)
Deﬁnition 0.13. For I ∈ID∞
ν let
|I|W :=

{0} ∪Wμ
if I = ΩP and μ = lev(P)
|I|
if I is not of the form ΩP
Note that |I|W ⊆|I| (since Wμ ⊆Iμ).
Φ(X) := {h : ∀ι ∈|tp(h)|W(h[ι] ∈X)} and Prog(X)
:⇔
Φ(X) ⊆X,
where X ranges over subsets of ID∗
ν.
Then Wσ (for σ < ν) satisﬁes the following “axioms”:
(Wσ.1) Iσ ∩Φ(Wσ) ⊆Wσ,
(Wσ.2) Iσ ∩Φ(X) ⊆X ⇒Wσ ⊆X.
Lemma 0.14.
Prog(W∗).
Proof. Let Hσ := {h : deg(h) = 0 & Γ(h) ⊆Posσ}. Then W∗= {h : ∀σ <
ν(h ∈Hσ ⇒Dσh ∈Wσ)}.
Suppose h ∈Φ(W∗) & σ < ν & h ∈Hσ.
To prove: Dσh ∈Wσ. Trivially Dσh ∈Iσ.
1. tp(h) = ΩP with σ ≤μ := lev(P): From h ∈Hσ by Lemma 0.10 we get
h[0] ∈Hσ ⊆Hμ. Together with h ∈Φ(W∗) this yields q := Dμh[0] ∈Wμ. From
q ∈Wμ and h ∈Hσ ∩Φ(W∗) we conclude h[q] ∈Hσ∩W∗. Hence Dσh[q] ∈Wσ
which yields Dσh ∈Wσ, since (Dσh)+ = Rep(Dσh[q]).
2. Otherwise: Then tp(Dσh) = tp(h), |tp(h)|W ⊆|tp(h)| and (Dσh)[ι] =
Dσh[ι] for all ι ∈|tp(h)| (∗).
From h ∈Hσ ∩Φ(W∗) by L.1 we get ∀ι ∈|tp(h)|W(h[ι] ∈Hσ ∩W∗), and
then ∀ι ∈|tp(h)|W(Dσh[ι] ∈Wσ). Together with (∗) this yields Dσh ∈Wσ.
Remark 0.15. Now for establishing (2) it remains to prove
Prog(X) ⇒h ∈X,
for each closed IDν-derivation h and each X,
(3)
and to ﬁnd a jump operation X →X (´a la [Ge43]) such that
h ∈X ⇒Eh ∈X
and
Prog(X) ⇒Prog(X).
(4)

Another Reduction of Classical IDν to Constructive IDi
ν
193
Lemma 0.16.
Prog(X) & lev(P) = σ < ν & d ∈Wσ
⇒
SΠ
P,Fd ∈X.
Proof. By induction on “d ∈Wσ”: Assume d ∈Wσ with d+ = I(dι)ι∈|I|. Then
d ∈Iσ and ∀ι ∈|I|W(dι ∈Wσ). We have to prove: h := SΠ
P,Fd ∈X.
1.1. I = ClPn with Pn ∈Π: Then
h+ =
"n
¬(A(F)⊆F)

A(F,n) ∧¬F(n)(SΠ∪Δ0(I)
P,F
d0)dF(n)

.
(*)
By IH from d0 ∈Wσ we get SΠ∪Δ0(I)
P,F
d0 ∈X. Further, the premise Prog(X)
yields dF(n) ∈X.
From SΠ∪Δ0(I)
P,F
d0 ∈X & dF(n) ∈X by (∗) and Prog(X) we get h ∈X.
1.2. I = 	
A, 
k
A with A ∈Π: Then h+ = I∗
SΠ∪Δi(I)
P,F
di

i∈|I| (∗).
By IH we get ∀i ∈|I|(SΠ∪Δi(I)
P,F
di ∈X), and then h ∈X by (∗) and Prog(X).
1.3. otherwise: Then h+ = I

SΠ
P,Fdι

i∈|I| (∗).
By IH we get ∀ι ∈|I|W(SΠ
P,Fdι ∈X), and then h ∈X by (∗) and Prog(X).
Lemma 0.17.
Prog(X) & C ∈	-for
⇒
Prog({h0 : Jk
Ch0 ∈X}).
Proof. Left to the reader.
Deﬁnition 0.18. X C,h0 := {h1 : CutCh0h1 ∈X}
Lemma 0.19. Assume Prog(X).
(a) C ∈	-for & ∀k(Jk
Ch0 ∈X)
⇒
Prog(X C,h0)
(b) h0 ∈X
⇒
Prog(X P,h0).
Proof. (a) Assume C ∈	-for & ∀k(Jk
Ch0 ∈X) & h1 ∈Φ(X C,h0).
To prove: h1 ∈X C,h0, i.e. h := CutCh0h1 ∈X.
Assume h+
1 = I(h1ι)ι∈I.
Then ∀ι ∈|I|W(h1ι ∈X C,h0) and thus ∀ι ∈|I|W(CutCh0h1ι ∈X).
1. ¬C ̸∈Δ(I): From h+ = I(CutCh0h1ι)ι∈I and ∀ι ∈|I|W(CutCh0h1ι ∈
X) we get h ∈Φ(X) ⊆X.
2. I = 
k
¬C: Then h+ = Cut◦
C[k](Jk
Ch0, CutCh0h10) with Jk
Ch0 ∈X (by
assumption) and CutCh0h10 ∈X as shown above. Hence h ∈Φ(X) ⊆X.
(b) is proved in the same way as (a).
Lemma 0.20. For each closed IDν-derivation h and each X we have:
Prog(X)
⇒
h ∈X.

194
Wilfried Buchholz
Proof. By induction on the height of h: Assume Prog(X).
1.
h = Ih0...hl−1 with simple I:
Then h+
= I

hi

i<l and, by IH,
h0, . . . , hl−1 ∈X. Hence h ∈Φ(X) ⊆X.
2. h = 	y
∀xAh: Then h+ = 	
∀xA(h(y/i))i∈IN and, by IH, ∀i ∈IN(h(y/i) ∈
X), i.e. h ∈Φ(X) ⊆X.
3. h = CutCh0h1 with C ∈	+-for: By IH we get h0 ∈X.
3.1. C ∈	-for: By Lemma 0.17 we get ∀k.Prog({d : Jk
Cd ∈X}) and then,
by IH, ∀k(h0 ∈{d : Jk
Cd ∈X}), i.e. ∀k(Jk
Ch0 ∈X). From Prog(X) & h0 ∈
X & ∀k(Jk
Ch0 ∈X) by Lemma 0.19 a we conclude Prog(X C,h0) and then, by IH,
h1 ∈X C,h0, i.e. h ∈X.
3.2.
C = P: From Prog(X) & h0 ∈X by Lemma 0.19 b we conclude
Prog(X P,h0) and then, by IH, h1 ∈X P,h0, i.e. h ∈X.
4. h = Indn
F: Then h+ = Rep(dn) with d0 := dF(0),
di+1 := 
i
∃x(F(x) ∧¬F(Sx))
	
F(i) ∧¬F(Si)didF(Si).
Using Prog(X) one easily shows di ∈X by induction on i.
5. h = IndPn
F : Then h+ = ΩP Ax{¬P,P }

S{P }
P,Fd

d∈Iσ with σ := lev(P) and
P := Pn.
Prog(X) yields Ax{¬P,P }
∈
X, and by Lemma 0.16 we have ∀d
∈
Wσ(S{P }
P,Fd ∈X). Hence h ∈Φ(X) ⊆X.
Now we come to the last part of our proof, which begins with the deﬁnition of
the jump operation X →X mentioned in (4) above.
Remark. ID∗
ν-derivations have been introduced as terms in polish (preﬁx) notation
build up from inference symbols each of which has a ﬁxed ﬁnite arity. So every
ID∗
ν-derivation is a ﬁnite sequence of inference symbols.
In the following we use a, a′ as syntactic variables for arbitrary ﬁnite sequences
of inference symbols – including the empty sequence ε. Concatination is expressed
by juxtaposition. Example: If a = CutCh0Jk
DCutBh1 then ah2 is the derivation
CutCh0h with h := Jk
DCutBh1h2.
Deﬁnition 0.21 (Finitary Inductive Deﬁnition of Q(X)).
• (Q1) ε ∈Q(X).
• (Q2) a ∈Q(X) & C ∈	-for ⇒a Jk
C ∈Q(X).
• (Q3) a ∈Q(X) & C ∈	-for & ∀k(a Jk
Ch ∈X) ⇒a CutCh ∈Q(X).
• (Q4) a ∈Q(X) & ah ∈X ⇒a CutP h ∈Q(X).

Another Reduction of Classical IDν to Constructive IDi
ν
195
Note that Q(X) is arithmetical in X.
Deﬁnition 0.22.
X := {h : ∀a ∈Q(X)(aEh ∈X)}.
Remark 0.23.
(i) h ∈X ⇒Eh ∈X.
(ii) h ∈X & a ∈Q(X) & C ∈	+-for ⇒aCutCEh ∈Q(X).
Lemma 0.24. Let a ∈Q(X).
(a) h+ = CutA(h0, h1) ⇒(ah)+ = CutA(ah0, ah1).
(b) h+ = Rep(h0) ⇒(ah)+ = Rep(ah0).
Proof. By induction on “a ∈Q(X)”.
Lemma 0.25. If Prog(X) and a ∈Q(X) then the following holds:
h+ = I(hι)ι∈I & ∀ι ∈|I|W(ahι ∈X) ⇒ah ∈X
Proof. By induction on “a ∈Q(X)”:
1. a = ε: In this case the premises immediately yield h ∈Φ(X) ⊆X.
2. a = a′Jk
C with a′ ∈Q(X):
2.1. I = 	
C: Then (Jk
Ch)+ = Rep

Jk
Chk

and (ah)+ = (a′Jk
Ch)+
L.8b
=
Rep(a′Jk
Chk) = Rep(ahk).
From Prog(X) & (ah)+ = Rep(ahk) & ahk ∈X we get ah ∈Φ(X) ⊆X.
2.2. otherwise: Then (Jk
Ch)+ = I

Jk
Chι

ι∈I (∗).
Prog(X) & a′ ∈Q(X) & (∗) & ∀ι ∈|I|W(a′Jk
Chι = ahι ∈X)
IH
⇒ah =
a′Jk
Ch ∈X.
3. a = a′CutCh′ with a′ ∈Q(X) & C ∈	-for & ∀k(a′Jk
Ch′ ∈X):
3.1. ¬C ̸∈Δ(I): Then (CutCh′h)+ = I

CutCh′hι

ι∈I (∗).
Prog(X) & a′ ∈Q(X) & (∗) & ∀ι ∈|I|W(a′CutCh′hι = ahι ∈X)
IH
⇒ah =
a′CutCh′h ∈X.
3.2. I = 
k
¬C: Then (CutCh′h)+ = Cut◦
C[k](Jk
Ch′, CutCh′h0) and
(ah)+ = (a′CutCh′h)+
L.8a
= Cut◦
C[k](a′Jk
Ch′, a′CutCh′h0) = Cut◦
C[k](a′Jk
Ch′, ah0).
Further a′Jk
Ch′ ∈X and ah0 ∈X. Hence ah ∈Φ(X) ⊆X.

196
Wilfried Buchholz
4. a = a′CutP h′ with a′ ∈Q(X) & a′h′ ∈X:
4.1. ¬P ̸∈Δ(I): As 3.1.
4.2.
¬P
∈
Δ(I):
Then (CutP h′h)+
=
Rep(h′) and thus (ah)+
=
(a′CutCh′h)+ L.8b
= Rep(a′h′).
Together with a′h′ ∈X this yields ah ∈Φ(X) ⊆X.
Lemma 0.26.
Prog(X) ⇒Prog(X).
Proof. Assume Prog(X) & h ∈Φ(X) & a ∈Q(X). To prove aEh ∈X. For
this it sufﬁces to prove aEh ∈Φ(X).
Let h+ = I(hι)ι∈I. Then ∀ι ∈|I|W(hι ∈X) and thus ∀ι ∈|I|W(aEhι ∈X).
1. I = CutC with C ∈	+-for: Then (Eh)+ = Rep(CutCEh0Eh1) and there-
fore, by Lemma 0.24 b,(aEh)+ = Rep(aCutCEh0Eh1).
From h0, h1 ∈X
& a ∈Q(X) we get (by Remark (ii)) aCutCEh0 ∈
Q(X) & h1 ∈X, and then aCutCEh0Eh1 ∈X. Hence aEh ∈Φ(X) ⊆X.
2. otherwise: From (Eh)+ = I(Ehι)ι∈I & ∀ι ∈|I|W(aEhι ∈X) we conclude
aEh ∈X by Lemma 0.25.
References
[AT09] J. Avigad and H. Towsner, Functional interpretation and inductive deﬁnitions, JSL
74 (2009), pp. 1100-1120
[BFPS] W. Buchholz, S. Feferman, W. Pohlers and W. Sieg, Iterated Inductive Deﬁnitions
and Subsystems of Analysis: Recent proof-theoretical studies, LNM 897, Springer
(1981).
[Bu81] W. Buchholz: The Ωμ+1-rule, in Buchholz et al. (1981), 188-233.
[Bu91] W. Buchholz: Notation systems for inﬁnitary derivations, Arch. Math. Logic 30,
pp. 277-296 (1991)
[Bu95] W. Buchholz: On Gentzen’s consistency proofs for arithmetic. Oberwolfach 1995.
[Bu97] W. Buchholz, Explaining Gentzen’s Consistency Proof within Inﬁnitary Proof The-
ory, in G. Gottlob, A. Leitsch and D. Mundici (eds.) Computational Logic and Proof
Theory. KGC’97, Lecture Notes in Computer Science 1289, pp. 4-17 (1997)
[Bu01] W. Buchholz, Explaining the Gentzen-Takeuti reduction steps: a second order sys-
tem, Arch. Math. Logic 40, pp. 255–272 (2001)
[Bu02] W. Buchholz, Assigning ordinals to proofs in a perspicious way, in W. Sieg, R.
Sommer and C. Talcott (eds.), Reﬂections on the Foundations of Mathematics: Es-
says in honor of Solomon Feferman, Lecture Notes in Logic 15, pp. 37-59 (2002)
[Fef]
S. Feferman, The proof theory of classical and constructive inductive deﬁnitions. A
40 year saga, 1968-2008. This volume.

Another Reduction of Classical IDν to Constructive IDi
ν
197
[Ge36] G. Gentzen, Die Widerspruchsfreiheit der reinen Zahlentheorie, Math. Ann. 112
(1936), pp. 493-565
[Ge43] G. Gentzen, Beweisbarkeit und Unbeweisbarkeit von Anfangsf¨allen der transﬁniten
Induktion in der reinen Zahlentheorie, Math. Ann. 119 (1943), pp. 149-161


Elementary Constructive Operational Set Theory
Andrea Cantini and Laura Crosilla∗
Dipartimento di Filosoﬁa
Universit`a degli studi di Firenze
via Bolognese 52,50139 Firenze, Italy
Cantini@philos.unifi.it
School of Mathematics
University of Leeds
LS2 9JT, UK
matmlc@leeds.ac.uk
Abstract We introduce an operational set theory in the style of [5] and [16].
The theory we develop here is a theory of constructive sets and operations.
One motivation behind constructive operational set theory is to merge a con-
structive notion of set ( [1], [2]) with some aspects which are typical of
explicit mathematics [14]. In particular, one has non-extensional operations
(or rules) alongside extensional constructive sets. Operations are in general
partial and a limited form of self–application is permitted. The system we
introduce here is a fully explicit, ﬁnitely axiomatised system of constructive
sets and operations, which is shown to be as strong as HA.
1 Introduction
This article is a follow-up of [9], where a constructive set theory with operations
was introduced. Constructive operational set theory (COST) is a constructive
theory of sets and operations which has similarities with Feferman’s (classical)
Operational Set Theory ( [16], [17], [20], [21], [22]) and Beeson’s Intuitionistic
set theory with rules [5]. In this article a fully explicit fragment, called EST,
of COST is singled out. This system is ﬁnitely axiomatized and is shown to be
proof–theoretically as strong as Peano Arithmetic, PA, (section 5).
One motivation behind constructive operational set theory is to merge a con-
structive notion of set ( [25], [1], [2]) with some aspects which are typical of ex-
plicit mathematics [14]. In particular, one has non-extensional operations (or rules)
∗The research is part of a project supported by PRIN 2006 (Dimostrazioni, Operazioni, Insiemi). The
second author gratefully acknowledges a grant by the John Templeton Foundation. She would also
like to thank the School of Mathematics, University of Leeds, for the hospitality.

200
Andrea Cantini and Laura Crosilla
alongside extensional constructive sets. Operations are in general partial and a lim-
ited form of self–application is permitted.
The informal concept of rule plays a prominent role in constructive mathemat-
ics. Both Feferman and Beeson have repeatedly called attention to the distinction
between rules and set–theoretic functions (see e.g. [15], [3]). There are several ex-
amples of intuitive rules which can not be represented by the set–theoretic concept
of function. For example the operation of pair, which given two sets a and b enables
us to form a new set, the set–theoretic pair of a and b. In operational set theory we
have primitive operations corresponding to some set–theoretic rules, among which
that of pair. In a sense, rules can be regarded as generalized algorithms or abstract
rules. Without entering a detailed conceptual analysis of the notion of rule, we
simply adopt the view that rules are represented by sets, and that it makes sense to
apply a set c ‘qua rule’ to another set b as input; and this possibly provides a result,
whenever the algorithm encoded by c produces a computation converging to b. The
application structure is speciﬁed by a ternary application relation, which satisﬁes
very general closure conditions, in that it embodies at least pure combinatory logic
with a number of primitive set–theoretic rules. As Beeson has emphasised e.g.
in [5] this approach has the advantage of allowing for a natural computation system
based on set theory. The idea is that while functions as graphs are hardly of any
use in programming, a notion of operation can be utilised to obtain a polymorphic
computation system based on set theory. Such a computation system is the main
motivation for the theory of sets and rules, called IZFR, introduced in [5]. This is
an operational version of intuitionistic Zermelo–Fraenkel set theory, IZF (see [3]);
in particular, like that theory it is fully impredicative.
Quite different is Feferman’s motivation in developing operational set theory.
Feferman observes that analogues of ‘small large cardinal notions’ (those consis-
tent with V = L) have emerged in different contexts, like admissible set theory,
admissible recursion theory, explicit mathematics, recursive ordinal notations and
constructive set and type theory. His aim in deﬁning operational set theory is to
develop a common language in which such notions can be expressed and can be
interpreted both in their original classical form and in their analogue form in each
of these special constructive and semi-constructive cases. Feferman’s system OST
is inherently classical, due to the presence of a choice operator (see section 3.4).
We see the present paper, though founded on [9], as a preliminary and rather
experimental attempt in studying constructive operational set theory. It is hoped
that the results here presented will contribute to both Feferman and Beeson’s aims.
We stress, however, our more parsimonious approach to the foundations for (con-
structive) mathematics: constructive operational set theory is based on intuitionistic
logic and also complies with a notion of generalised predicativity.
The system COST of [9] had urelements at the base of the set–theoretic uni-

Elementary Constructive Operational Set Theory
201
verse, representing the elements of an applicative structure with natural numbers.
The main idea was to carefully endow the whole universe of sets with a natural ex-
tension of the base application relation. In [9] COST was shown to be of the same
strength as CZF ( [1], [2], [12]). Furthermore, a subtheory was singled out and
shown to be of the same proof–theoretic strength as PA. The theory COST and
its subsystems were introduced so to resemble as much as possible the constructive
set theory CZF (and subsystems). In particular, COST had schemata of strong
and subset collection, thus retaining all the mathematical expressivity of CZF.
However, the presence of implicit principles of collection was not entirely satisfac-
tory if one wished to have an explicit theory of sets and operations. In addition, as
already noted in the introduction to [9], an inspection of the proofs in that paper
(especially sections 3 - 5) shows that many of them can already be conducted in an
explicit fragment of COST. For this reason we here single out such a fragment,
EST, and show that it has the same strength as PA. Note further that in this article
we work with pure sets, i.e. we do not introduce urelements.1 One could also say
that with COST and its subsystems we aimed at expressive theories, though of
limited proof–theoretic strength. With EST we single out a more elegant, ﬁnitely
axiomatized theory, though at the price of a more limited expressivity. We wish to
note, however, that Friedman’s system B ( [18]) can be interpreted in the theory
EST plus bounded (or limited) Dependent Choice (LDC) (section 4.3), so that
we are persuaded we have a theory which is foundationally meaningful.
One contribution of the present paper is the use of the technique of partial cut
elimination and asymmetric interpretation ( [6]) to determine the strength of EST.
We are not aware of other attempts to introduce this technique to systems of con-
structive set theory (see [21] for an application of this technique in the context of a
proof–theoretic analysis of strong systems of classical operational set theory).
As to the contents of this paper, section 2 describes language and axioms of the
theory EST. Section 3 collects elementary facts linking the set–theoretic and the
applicative structures. In particular, we show that extensionality and totality of
operations can not be assumed in general in the present context. In addition, we
study the relations between the notions of set–theoretic function and operation and
also assess the status of some choice principles on the basis of EST.
Section 4 is dedicated to clarifying the relation between EST and Beeson’s
1Urelements had a twofold motivation in [9]. On the one side, in the authors’ opinion, including
urelements at the ground of the set–theoretic universe appears as a constructively justiﬁed option.
On the other side, urelements played a useful technical role, as they allowed for a separation between
the principles of induction on the natural numbers and on sets. As a result we could deﬁne theories
which had full induction on sets but bounded induction on the natural numbers. These theories had
a considerable expressive power and a very limited proof–theoretic strength. However, in this paper
we look for a more fundamental and simpler theory, and thus focus on a pure subsystem of COST
with no set–induction.

202
Andrea Cantini and Laura Crosilla
IZFR, Feferman’s OST and Friedman’s B, respectively.
Finally, section 5 shows that EST has the same proof–theoretic strength as PA.
The lower bound is easily achieved. The upper bound is addressed by a series
of steps. First an auxiliary constructive set theory, ECST∗, is introduced. This
is reduced to a classical axiomatic theory of abstract self–referential truth, Tc,
which is conservative over PA. The interpretation is obtained by an appropriate
modiﬁcation of [9]’s realisability interpretation. The reduction of EST to ECST∗
is obtained by ﬁrst introducing a Gentzen–style formulation of EST (in fact of a
strengthening of it). A partial cut elimination theorem holds for such a system.
Finally, we deﬁne an asymmetric interpretation of the operational set theory in
ECST∗, which allows us to obtain the desired upper bound.
2 The theory EST
2.1 Language and conventions
The language of EST is the following applicative extension, LO, of the usual ﬁrst
order language of Zermelo–Fraenkel set theory, L.
The language includes the predicate symbols ∈and =. The logical symbols are
all the intuitionistic operators: ⊥, ∧, ∨, →, ∃, ∀. We have in addition:
• the combinators K and S;
• a ternary predicate symbol, App, for application; App(x, y, z) is read as x
applied to y yields z;
• el for the ground operation representing membership;
• pair , un , im , sep , for set operations;
• ∅, ω, set constants;
• IT for ω–iterator.2
For convenience we also use the bounded quantiﬁers ∃x ∈y and ∀x ∈y, as
abbreviations for ∃x (x ∈y ∧. . .) and ∀x (x ∈y →. . .).
As customary, we deﬁne ϕ ↔ψ by (ϕ →ψ) ∧(ψ →ϕ) and ¬ϕ by ϕ →⊥.
We also write a ⊆b for ∀z (z ∈a →z ∈b).
Terms and formulas. Terms and formulas are inductively deﬁned as usual.
To increase perspicuity, we consider a deﬁnitional extension of LO with appli-
cation terms, deﬁned inductively as follows.
2The idea of postulating an iteration principle as primitive is already present in Weyl’s Das Kontinuum
(chapter 1, section 7).

Elementary Constructive Operational Set Theory
203
(i) Each variable and constant is an application term.
(ii) If t, s are application terms then ts is an application term.
Application terms will be used in conjunction with the following abbreviations.
(i) t ≃x for t = x when t is a variable or constant.
(ii) ts ≃x for ∃y ∃z (t ≃y
∧s ≃z
∧App(y, z, x)).
(iii) t ↓for ∃x (t ≃x).
(iv) t ≃s for ∀x (t ≃x ↔s ≃x).
(v) ϕ(t, . . . ) for ∃x (t ≃x ∧ϕ(x, . . . )).
(vi) t1t2 . . . tn for (. . . (t1t2) . . . )tn.
To ease readability we sometimes use the notation t(x, y) for txy.
In the language LO, the notion of bounded formula needs to be appropriately
modiﬁed.
Deﬁnition 2.1 (Bounded formulas). A formula of LO is bounded, or Δ0, if and
only if all quantiﬁers occurring in it, if any, are bounded and in addition it does not
contain application App.
Classes are introduced as usual in set theory, as abbreviations for abstracts {x :
ϕ(x)} for any formula ϕ of the language LO. In particular, we let V := {x : x ↓}.
For A and B sets or classes, we write f : A →B for ∀x ∈A (fx ∈B) and
f : V →B for ∀x (fx ∈B). By f : A2 →B and f : V2 →B we indicate
∀x ∈A ∀y ∈A (fxy ∈B) and ∀x ∀y (fxy ∈B), respectively. This can be
clearly extended to arbitrary exponents n > 2. Finally, for set a, f : a →V means
that f is everywhere deﬁned on a.
Truth values. We may represent false and truth by the empty set and the single-
ton empty set, respectively; that is we let ⊥:= ∅and ⊤:= {∅}.
Let Ω be the class P⊤, the powerset of ⊤. Then x ∈Ω is an abbreviation for
⊥⊆x ⊆⊤. The class Ω intuitively represents the class of truth values (or of
propositions). Note that in the presence of exponentiation if Ω is taken to be a set
then full powerset follows (see Aczel [1], Proposition 2.3).
Relations and set–theoretic functions. The notions of relation between two
sets, of domain and range of a relation can be deﬁned in the obvious way in EST.
In the following we write Dom(R) and Ran(R) to denote the domain and the
range of a relation, respectively. In remark 3.9 we shall see that in EST there is

204
Andrea Cantini and Laura Crosilla
an operator opair internally representing the ordered pair of two sets. In addi-
tion, also the range and the domain of a relation correspond to internal operations,
respectively.
We also have a standard notion of set–theoretic function which we can express
by a formula, Fun(F), stating that F is a set encoding a total binary relation which
satisﬁes the obvious uniqueness condition. We shall use upper case letters F, G, . . .
for set–theoretic functions and lower case letters f, g, . . . for operations (that is
if they formally occur as operators in application terms or as ﬁrst coordinates in
App–contexts). Given a set–theoretic function F, we write ⟨x, y⟩∈F or also
F(x) = y for opair xy ∈F. We shall investigate the relation between the notions
of operation and set–theoretic function in section 3.3.
Finally, in deﬁning the axiom of inﬁnity we shall make use of the following
successor operation.
Deﬁnition 2.2. Let Suc := λx.un (pair x(pair xx))
2.2 Axioms of EST
Deﬁnition 2.3. EST is the LO theory whose principles are all the axioms and
rules of ﬁrst order intuitionistic logic with equality, plus the following principles.
Extensionality
• ∀x (x ∈a ↔x ∈b) →a = b
General applicative axioms
• App(x, y, z) ∧App(x, y, w) →z = w
• Kxy = x ∧Sxy↓∧Sxyz ≃xz(yz)
Membership operation
• el : V2 →Ω and el xy ≃⊤↔x ∈y

Elementary Constructive Operational Set Theory
205
Set constructors
• ∀x (x /∈∅)
• pair xy ↓∧∀z (z ∈pair xy ↔z = x ∨z = y)
• un a ↓∧∀z (z ∈un a ↔∃y ∈a(z ∈y))
• (f : a →Ω) →sep fa ↓∧∀x (x ∈sep fa ↔x ∈a ∧fx ≃⊤)
• (f : a →V ) →im fa ↓∧∀x (x ∈im fa ↔∃y ∈a(x ≃fy))
Strong inﬁnity
• (ω1)
∅∈ω ∧∀y ∈ω (Suc y ∈ω)
• (ω2)
∀x (∅∈x ∧∀y(y ∈x →Suc y ∈x) →ω ⊆x)
ω–Iteration
•
∀F[[Fun(F) ∧dom(F) = a ∧Ran(F) ⊆a]
→∀x ∈a ∃z [IT(F, a, x) ≃z ∧Fun(z) ∧Dom(z) = ω
∧Ran(z) ⊆a ∧z(∅) = x ∧∀n ∈ω(z(Suc n) = F(z(n)))]].
Remark 2.4. The principles ruling sep and im embody the explicit character of
the separation and replacement schemata in the present operational context: sep
provides – uniformly in any given f : a →Ω – the set of all elements satisfying the
“propositional function” deﬁned by f; on the other hand, im yields – uniformly in
any given operation f deﬁned on a set a – the image of a under f.
Deﬁnition 2.5 (The theory ESTE). Let ESTE be obtained from EST by remov-
ing ω–iteration and by adding a new constant exp to the language together with
the following explicit version of Myhill’s exponentiation axiom [25]:
exp ab ↓∧∀x(x ∈exp ab ↔(Fun(x) ∧Dom(x) = a ∧Ran(x) ⊆b)).
3 Elementary properties of EST
In this section we present some properties of EST. In particular, we aim at clari-
fying the status of extensionality and intensionality in EST. We also look at some
aspects of the relationship between functions as operations and as graphs and the

206
Andrea Cantini and Laura Crosilla
status of some choice principles. Finally, we show that the theory ESTE proves ω–
iteration. Part of this section draws on [9], however adapting the arguments to the
present context. For the reader’s convenience we shall recall some of the arguments
of [9]. First of all, as a consequence of the axioms for combinators, the universe of
sets is closed under abstraction and recursion for operations (see e.g. [29]).
Lemma 3.1.
(i) For each term t, there exists a term λx.t with free variables
those of t other than x and such that
λx.t ↓∧(λx.t)y ≃t[x := y].
(ii) (Second recursion theorem) There exists a term rec with
recf ↓∧(recf = e →ex ≃fex).
We now show that the logical operations generating bounded formulas are mir-
rored by internal operations.
Lemma 3.2. There are application terms eq , and , all , exists , imp , or such that
(i) eq : V2 →Ω and eq xy ≃⊤↔x = y;
(ii) x ∈Ω
∧y ∈Ω →and xy ∈Ω
∧
(and xy ≃⊤↔(x ≃⊤∧
y ≃⊤));
(iii) (f : a →Ω) →all fa ∈Ω ∧(all fa ≃⊤↔∀x ∈a (fx ≃⊤));
(iv) (f : a →Ω) →exists fa ∈Ω ∧(exists fa ≃⊤↔∃x ∈a (fx ≃⊤));
(v) x ∈Ω ∧(x = ⊤→y ∈Ω) →imp xy ∈Ω ∧(imp xy ≃⊤↔(x ≃
⊤→y ≃⊤));
(vi) x ∈Ω ∧y ∈Ω →or xy ∈Ω
∧
(or xy ≃⊤↔(x ≃⊤∨y ≃⊤)).
Proof. See Lemma 3.2 of [9].
Proposition 3.3.
(i) For each Δ0 formula ϕ with free variables contained in
{x1, . . . , xk}, there is an application term fϕ such that fϕ ↓, fϕ : Vk →Ω
and
fϕ x1 . . . xk ≃⊤↔ϕ(x1, . . . , xk).
(ii) To each Δ0 formula ϕ(x, y1 . . . yk), we can associate an application term cϕ
such that
cϕay1 . . . yk ↓
∧∀u(u ∈cϕay1 . . . yk ↔u ∈a ∧ϕ(u, y1, . . . , yk)).
(3.1)

Elementary Constructive Operational Set Theory
207
Proof. (i) A simple induction applies, making use of Lemma 3.2. (ii) follows from
(i) and explicit separation.
Remark 3.4.
(i) the schema (3.1) is naturally called uniform bounded separation schema (i.e.
restricted to Δ0-formulas, which do not contain App);
(ii) uniform bounded separation with application terms: we are allowed to use
application terms as genuine terms insofar as they are deﬁned. In the special
case of separation, if t, s are application terms such that t ↓, s ↓and s : t →Ω,
then there exists an application term r := sep st such that
∀u(u ∈r ↔u ∈t ∧su ≃⊤).
Instead of r, we write {u ∈t : su ≃⊤}. Similarly, if ϕ is Δ0 with free
variables x, y, and t, s are application terms such that t ↓, s ↓, then there exists
an application term rϕ := cϕts such that
∀u(u ∈rϕ ↔u ∈t ∧ϕ(u, s)).
Instead of rϕ, we again stick to the more familiar and perspicuous notation
{u ∈t : ϕ(u, s)}.
The main tool in proving the results in the next subsection is the following
Lemma. This is a consequence of proposition 3.3, and states that we can express an
operator representing deﬁnition by cases on the universe for bounded predicates.
Lemma 3.5. Let ϕ(x, y) be Δ0 (with the free variables shown). Then there exists
an operation Dϕ such that Dϕuvab ↓and
ϕ(u, v) →Dϕuvab = a
(3.2)
¬ϕ(u, v) →Dϕuvab = b.
(3.3)
Proof. By uniform bounded separation (see proposition 3.3) and uniform union,
there exists an operation Dϕ such that
Dϕ = λuλvλaλb.{x ∈a : ϕ(u, v)} ∪{x ∈b : ¬ϕ(u, v)}.
By λ-abstraction, Dϕuvab ↓. By extensionality, Dϕ satisﬁes (3.2) – (3.3).

208
Andrea Cantini and Laura Crosilla
Note that in the particular case in which a is ⊤and b is ⊥, even if ϕ(u, v) is
undecidable, then Dϕuv⊤⊥equals the proposition (the truth value) associated to
ϕ(u, v), i.e an element of Ω.
Indeed, as a special case we have the following.
Corollary 3.6. There exists an operation EQ such that EQuv ↓and
u = v →EQ(u, v) = ⊤
¬u = v →EQ(u, v) = ⊥.
We stress again that = is not decidable in general.
In the following we shall make use of the usual notation  for the uniform oper-
ation of union, un , and write ∪for the obvious deﬁnition of a uniform version of
binary union.
3.1 Non–extensionality and partiality of operations
As observed in [9], the combination of operations and sets needs to be accom-
plished with care. The following argument shows that totality and extensionality
can not be assumed in general.We also show that separation can not be extended to
formulas with bounded quantiﬁers and App.
We say that two operations f and g are extensional if they satisfy the following:
∀x (fx ≃gx) →f = g.
(3.4)
Proposition 3.7. EST refutes extensionality for operations and totality of appli-
cation:
• ¬[∀x (fx ≃gx) →f = g];
• ¬∀x ∀y ∃z App(x, y, z).
Proof. The argument is standard. First of all, recall a (folklore) preliminary fact
about partial combinatory algebras (pcas for short). By a pca we understand a
non-empty set endowed with a partial binary function (i.e. application) and two
special elements K and S satisfying the standard axioms for combinators (see def-
inition 2.3). A pca is extensional if it satisﬁes extensionality for operations (3.4).
Extensional pcas satisfy the ﬁxed point property for total operations: if g is a total
operation, then for some e, ge = e (for the proof see [9] Lemma 3.11).
Now, assume extensionality, deﬁne ϕ(u, v) ≡(u = v) and let NOTu =
Dϕu⊤⊥⊤. Then
u = ⊤→NOTu = ⊥
¬u = ⊤→NOTu = ⊤.

Elementary Constructive Operational Set Theory
209
Note that NOT is total; hence by the previous remark, there exists a ﬁxed point
e such that NOTe = e and
e = ⊤→e = ⊥
(3.5)
¬e = ⊤→e = ⊤.
(3.6)
The ﬁrst implication implies ¬e = ⊤: if we assume e = ⊤, then by (3.5) e = ⊥,
which yields ⊤= ⊥, i.e. ∅∈∅, absurd. Hence by (3.6) we conclude e = ⊤:
contradiction! On the other hand, if totality of application is assumed, the ﬁxed
point theorem of full lambda calculus holds and we can derive the inconsistency as
well.
Proposition 3.8. EST with uniform separation for bounded conditions containing
App3 is inconsistent.
Proof. By uniform separation including App-conditions, there would exist a total
operation g such that
gfz = {x ∈⊤: fz ≃x}.
By lemma 3.1 (second recursion theorem), there exists some e such that gez ≃ez.
Since g is total, e is total; hence ee ↓and satisﬁes ee = {x ∈⊤: ee = x}. Were
x ∈ee, then x = ∅∧x = ee. Then ee = ∅and hence x ∈∅: contradiction!
3.2 EP–recursion
In [9] we noted that we can recast a form of set computability in a weak system of
operational set theory. Already Beeson observed the link between his intuitionistic
set theory with rules and a variant of set recursion (Beeson [5], see also [26]). In
[27] Rathjen introduced a form of extended set recursion (inspired by [24]) named
EP–computability. According to this form of set recursion, exponentiation is taken
as one of the basic operations which are used to deﬁne set computability. Therefore,
for a and b sets, the set ab of all set–theoretic functions from a to b, is computable.
This notion of set recursion is used by Rathjen to develop an interpretation for
CZF in itself which is a self validating semantics for that system of constructive
set theory. This interpretation is called the formulas–as–classes interpretation. We
showed in [9] that we can naturally capture EP–computability in a subsystem of
COST. In particular, in operational set theory application is primitive and we
can thus avoid the detour of [27] through coding and an inductive deﬁnition. In
Proposition 4.3 of [9] we showed that the clauses deﬁning EP-computability in
3This means the schema (3.1), where App is allowed to occur in the bounded formula ϕ; see also
remark 3.4.

210
Andrea Cantini and Laura Crosilla
Deﬁnition 4.1 of [27] can be carried out in a subsystem of COST. Here we note
that the proof of the proposition can be carried out in the theory ESTE.4
For the reader’s convenience we now brieﬂy recall the content of Lemma 4.1 and
that part of Proposition 4.3 of [9] which are needed in the following.
Remark 3.9.
(i) There are operations int, prod , dom , ran , opair , proji (i = 0, 1), rep-
resenting: binary intersection, cartesian product, domain and range of a set–
theoretic function, ordered pair and projections, respectively. (See Lemma
4.1 of [9]).
(ii) There is a term fa such that for any set–theoretic function F and for any
x ∈Dom(F), fa Fx ≃F(x). In fact, we can take fa to be : λF.λx. {y ∈
Ran(F) : ⟨x, y⟩∈F} (by uniform pair, union, separation). In addition,
there is an operation ab such that, for each f which is deﬁned (or total) on
a, ab fa ≃H, with H a set–theoretic function with domain a and such that
∀x ∈a (H(x) ≃fx). In fact, if f : a →V, then by im we can ﬁnd b
such that ∀x ∈a ∃y ∈b (y ≃fx). By (i) we have an operator prod which
gives the cartesian product of a and b. Thus we can form {⟨x, y⟩∈prod ab :
eq (fx)y ≃⊤} (see Remark 3.4) and obtain the desired operation. Note that
both (i) and (ii) hold in EST.
3.3 Operations and functions
In operational set theory we have set–theoretic functions and operations. We now
wish to address the question of the relationship between them. Note that differences
occur both with [9], where we had full replacement at our disposal, and with [17],
where use is made of the choice operator.
According to Remark 3.9 (ii), in the theory EST to each set–theoretic function
F there corresponds an operation which coincides with F on the common domain.
In addition, for every operation total on a set a there is a set–theoretic function
representing it.
We can consistently (see section 5.3) achieve a sort of “harmony” between func-
tions and operations by assuming Beeson’s axiom FO (see [5]). FO asserts that
4Note, however, that due to the lack of set–induction, we can not prove in the present context Theorem
4.4 of [9] which showed that Rathjen’s construction can be recast in COST. Note also that the
proof of the existence of dependent products in Proposition 4.3 of [9] needs exponentiation, and
thus in the present context requires the theory ESTE.

Elementary Constructive Operational Set Theory
211
every set–theoretic function is an operation, more precisely5:
(FO)
∀f (Fun(f) →∀x∀y (⟨x, y⟩∈f ↔fx ≃y)).
From Remark 3.9 (ii), when working in the theory ESTE, the set exp ab con-
tains a representative of each total operation f : a →b. If we add FO to ESTE
then every element of the set exp ab is an operation from a to b, that is
f ∈exp ab →∀x ∈a∀y ∈b (⟨x, y⟩∈f ↔fx ≃y).
One might now wonder if it is consistent to assume the existence of a set of all
operations from a to b:
opab := { f : ∀x ∈a ∃y ∈b (fx ≃y)}.
Pierluigi Minari has observed that if opab is deﬁned (and hence is a set), then one
can reproduce the ﬁxed point argument of Proposition 3.8.
Lemma 3.10. EST + ∀a∀b ∃c(op ab = c) is inconsistent.
The interaction between operations and functions is well exempliﬁed in the sec-
tion 3.5 on ω–Iteration in the theory ESTE.
3.4 Choice principles
The full axiom of choice is validated in constructive type theory, where the Curry–
Howard correspondence holds. However, the axiom of choice is not constructively
acceptable in the context of set theory with extensionality and (bounded) sepa-
ration, since it implies the (bounded) law of excluded middle by a well known
argument (see [13] and [19]).
It is thus natural to ask what is the status of choice principles for operations.
In addition, as Feferman’s theory OST is formulated with a choice operator
( [16]), it is also worth exploring what is the status of such an operator on the basis
of EST.
First of all we consider two forms of choice for operations. Let OAC be the
following principle:
∀x ∈a ∃y ϕ(x, y) →∃f ∀x ∈a ϕ(x, fx).
(3.7)
Let GAC be its generalized class form:
∀x (ϕ(x) →∃y ψ(x, y)) →∃f ∀x (ϕ(x) →ψ(x, fx)).
(3.8)
5Unfortunately, in [9], section 5, the axiom FO appears to be stated incorrectly. However, the correct
principle is used in the interpretation in Theorem 6.4.

212
Andrea Cantini and Laura Crosilla
Finally, let GAC ! be GAC with the uniqueness restriction on the quantiﬁer ∃y in
the antecedent of (3.8).
Lemma 3.11.
(i) EST + OAC proves ϕ ∨¬ϕ for arbitrary bounded formu-
las.
(ii) Moreover, EST + GAC and EST + GAC ! are inconsistent.
Proof. (i) The standard argument, as presented for example by Goodman and My-
hill [19], can be applied here, too. (ii) See Beeson [7, p. 228] or [9] Lemma
5.4.
Let’s consider Feferman’s choice operator. Uniform choice is one of the princi-
ples of OST and is deﬁned as follows (for a new constant C):
(C)
∃x (fx ≃⊤) →(Cf ↓∧f(Cf) ≃⊤).
In [20], Theorem 6, J¨ager shows that the theory KPω + (AC) is a subsystem of
OST (where KPω is Kripke–Platek set theory with inﬁnity axiom). An essential
part of the proof consists in showing that OST proves bounded collection and that
it proves the axiom of choice. The axiom of Choice is here taken in the form
(AC)
∀x ∈a∃y(y ∈x) →∃F(Fun(F)
∧Dom(F) = a ∧∀x ∈a (F(x) ∈x)).
It is not difﬁcult to see that J¨ager’s proof that bounded Collection and (AC) hold
in OST carries through to EST plus (C).
Thus to conclude: EST plus (C) proves bounded Collection and (AC). Due to
the latter fact, this theory is constructively unacceptable.
3.5 The ω–iteration theorem in ESTE
We now show that in the theory ESTE we can prove the existence of an operation
of ω-iteration.
First of all, note that strong inﬁnity allows us to derive bounded induction on the
natural numbers. In the following we also write 0 for ∅.
(Δ0 −INDω)
ϕ(0) ∧∀x ∈ω (ϕ(x) →ϕ(Suc x)) →∀x ∈ω (ϕ(x)),
where ϕ(x) is Δ0.
Lemma 3.12. The principle (Δ0 −INDω) holds in EST.

Elementary Constructive Operational Set Theory
213
Proof. This is proved by a simple application of proposition 3.3 and strong inﬁnity.
In the reminder of this section let F be a set–theoretic function with domain a
and range ⊆a, and x ∈a. Let Iter(H, F, a, x) be the bounded formula expressing
the fact that Fun(H), Dom(H) = ω, Ran(H) ⊆a and H is deﬁned by iterating
F along ω with initial value x, i.e.
H(0) = x ∧∀n ∈ω(H(Suc n) = F(H(n))).
By (Δ0 −INDω) we easily verify the following.
Lemma 3.13. EST without ω-iteration proves:
Iter(H, F, a, x) ∧Iter(G, F, a, x) →H = G.
Thus the IT-operator chooses the unique such H uniformly in the data F, a, x.
Let’s now consider the following bounded formula: Iter∗(H, F, Suc m, a, x)
expressing the fact that Fun(H) and Dom(H) = Suc m and Ran(H) ⊆a and
H is deﬁned by iterating F along Suc m with initial value x.
By bounded induction on the natural numbers we also have the following ana-
logue of lemma 3.13.
Lemma 3.14. EST without ω-iteration proves:
Iter∗(H, F, Suc m, a, x) ∧Iter∗(G, F, Suc j, a, x) →
(∀n ∈m ∩j)(H(n) = G(n)).
In addition,
the following holds by uniform exponentiation exp and
(Δ0 −INDω).
Lemma 3.15. ESTE proves:
∀m ∈ω(exp(Suc m)a) ↓(and hence is a set).
We write aSuc m for exp(Suc m)a.
Theorem 3.16. ESTE proves ω-iteration.
Proof. We ﬁrst prove the following:
∀m ∈ω ∃G ∈aSuc m Iter∗(G, F, Suc m, a, x).
(3.9)

214
Andrea Cantini and Laura Crosilla
Observe that we can apply (Δ0 −INDω) to verify (3.9) (here it is essential to
have a set bound for G).
The case m = 0 is obvious; at the successor step
m = Suc j, we simply expand any function G′ such that Iter∗(F, G′, Suc j, a, x)
(which exists by IH) with the pair ⟨Suc j, F(G′(j))⟩. The resulting set G satisﬁes
Iter∗(G, F, (Suc m), a, x). For every m ∈ω let
J(F, a, x, m) = {G ∈aSuc m : Iter∗(F, G, Suc m, a, x)}
is a set. By uniform bounded separation (see proposition 3.3), J(F, a, x, m) can be
regarded as an application term, as well as
H(F, a, x) =
 
{J(F, a, x, m) : m ∈ω},
which is a set by explicit union, explicit replacement (im ) and strong inﬁnity.
Now, H(F, a, x) is a set (uniformly in F, a, x) and in fact a function with do-
main ω and range a, deﬁned by iterating F along ω with initial value x ∈a
(apply the uniqueness lemma above and (3.9)).
Hence we can choose IT =
λFλaλx.H(F, a, x).
4 Relations with other theories
As already mentioned, the theory EST may be regarded as the pure and explicit
fragment of COST ( [9]). In particular, there are no urelements, no ∈–induction
and no implicit principles, i.e. Strong Collection and Subset Collection.6
We now wish to explore the relations between EST and the operational theo-
ries IZFR of [5] and OST of [16]. We also clarify the relation of EST with
Friedman’s system B ( [18]).
4.1 Relation with Beeson’s IZFR.
The theory IZFR is formulated on the basis of Beeson’s logic of partial terms,
LPT (see [4], [3]). We here consider a variant of IZFR with the application
predicate App in place of LPT.
6As to the term ‘implicit’, we mean that strong collection and subset collection have no associated
operation witnessing the sets asserted to exist, uniformly depending on the given data. For instance,
if ∀x ∈a∃yϕ(x, y), by collection there exists some b, such that ∀x ∈a∃y ∈b ϕ(x, y, c); this
schema is called implicit, since no operation collϕ is assumed to exist, such that collϕ(a, c) ↓and
it yields d such that ∀x ∈a∃y ∈d ϕ(x, y, c).

Elementary Constructive Operational Set Theory
215
The theory has natural numbers as urelements, and is thus formulated in an ex-
tension of LO with two predicates, S and N, for being a set and a natural number,
respectively. In addition, there are constants 0, SucN, d for the natural number
zero, successor and case distinction on the natural numbers, respectively. Finally,
there are a new constant P for powerset and one cϕ for each primitive formula ϕ.
A formula is primitive if it does not contain App or any constant cψ.
The theory IZFR is based on intuitionistic logic with equality and includes the
following principles.
1. Applicative axioms and extensionality: as in EST.
2. Basic set–theoretic axioms: empty set, pair, union, image, all essentially as in
EST. Note that in the presence of urelements the axiom of pair, for example,
is written as follows:
S(pair yz) ∧∀x (x ∈pair yz ↔x = y ∨x = z).
In addition:
∈-induction axiom schema:
(∈−IND)
∀x (∀y ∈x ϕ(y) →ϕ(x)) →∀x ϕ(x).
The axiom of inﬁnity, asserting the existence of a set of natural numbers as
urelements.
3. Ontological axiom and Natural numbers: The following axiom:
z ∈x →S(x).
In addition, principles expressing the desired properties of successor on the
natural numbers and distinction by numerical cases and the schema of full
induction on the natural numbers.
4. Separation:
(SEP)
S(cϕ(a, y1, . . . , yn))
∧∀x(x ∈cϕ(a, y1, . . . , yn) ↔x ∈a ∧ϕ(x, y1, . . . , yn)),
where ϕ is primitive.
5. Powerset:
(POW)
S(Pa) ∧∀x (x ∈Pa ↔S(x) ∧∀z ∈x(z ∈a)).

216
Andrea Cantini and Laura Crosilla
It is well–known that intuitionistic set theory with natural numbers as urelements
can be interpreted in the corresponding “pure” (i.e. set only) theory. See e.g. Bee-
son [3], p. 166 (exercises 7 and 8). As a consequence, we can prove the following
proposition.
Proposition 4.1. IZFR is interpretable in EST+ (SEP) + (POW) + (∈–Ind).
Remark 4.2. The referee has asked about the converse direction of proposition
4.1. As far as we can see, there is no direct interpretation of the theory EST+
(SEP) + (POW) + (∈–Ind) in IZFR because of the membership operation el and
its corresponding axiom.
4.2 Relation with OST
Let OST be the theory deﬁned in [16], see also [20]. Brieﬂy, OST may be formu-
lated in an extension of LO with constants ⊤, ⊥, non, dis, all and C.7 The theory
OST is based on classical logic and includes the following principles.
1. Applicative axioms and extensionality: as in EST.
2. Basic set–theoretic axioms: empty set, pair, union, inﬁnity, ∈–induction (all
formulated as in Zermelo–Fraenkel set theory).
3. Logical operations axioms. Let B := {⊤, ⊥} (which is a set by pair).
(i) ⊤̸= ⊥
(ii) (el : V2 →B) ∧∀x ∀y (el xy ≃⊤↔x ∈y)
(iii) (non : B →B) ∧∀x ∈B (non(x) ≃⊤↔x ≃⊥)
(iv) (dis : B2 →B) ∧∀x, y ∈B (disxy ≃⊤↔(x ≃⊤∨y ≃⊤))
(v) (f : a →B) →(allfa ∈B ∧(allfa ≃⊤↔∀x ∈a (fx ≃⊤))).
4. Operational set–theoretic axioms: uniform bounded separation and image
(as in EST, with B replacing Ω) and the uniform choice principle (C) as de-
ﬁned in section 3.4.
Note ﬁrst of all that ∈–induction implies full induction on the natural numbers.
We now show that in the presence of the choice operator and of full induction on
the natural numbers, we can derive the existence of an ω–iterator.
7The constants pair , un , IT, ∅, ω of LO are not needed for deﬁning OST. Note also that in [20]
and subsequent papers, J¨ager introduces a constant for the bounded existential quantiﬁer, with corre-
sponding axiom, instead of all. In [21] J¨ager investigates the proof–theoretic strength of extensions
of OST by operators for Powerset and unbounded Existential quantiﬁer.

Elementary Constructive Operational Set Theory
217
Lemma 4.3 (OST). OST proves ω-iteration.
Proof. Similarly as in Theorem 3.16 we here show that for any set–theoretic func-
tion F with domain a and range ⊆a, for x ∈a
∀m ∈ω∃G [Iter∗(G, F, Suc m, a, x)].
Note, however, that in the present case, where exponentiation is not available, the
existential quantiﬁer is unbounded. The claim is hence proved by unbounded in-
duction on the natural numbers, which is available in OST. We can now note
that by proposition 3.3 there is a term, say tIter∗, representing the Δ0 formula
Iter∗(G, F, Suc m, a, x), that is
∀m ∈ω∃G[tIter∗(G, F, Suc m, a, x) ≃⊤].
We can now apply uniform choice (C) to obtain
∀m ∈ω [C(λy.tIter∗(y, F, Suc m, a, x)) ↓
∧tIter∗(C(λy.tIter∗(y, F, Suc m, a, x)), F, Suc m, a, x) ≃⊤].
Thus
∀m ∈ω [C(λy.tIter∗(y, F, Suc m, a, x)) ↓
∧Iter∗(C(λy.tIter∗(y, F, Suc m, a, x)), F, Suc m, a, x)].
We deduce that λm.C(λy.tIter∗(y, F, Suc m, a, x)) : ω →V. We can now apply
im and un to obtain the iterator:
λFλaλx.un (un (im (λm.C(λy.tIter∗(y, F, Suc m, a, x)))ω)).
Let (EM) denote the principle of Excluded Middle. Let P be a new constant for
powerset and (P) denote uniform powerset (that is the pure, i.e. set only, version
of IZFR’s (POW)):
(P)
P : V →V ∧∀a ∀x (x ∈Pa ↔∀z ∈x(z ∈a)).

218
Andrea Cantini and Laura Crosilla
Proposition 4.4.
(i) EST + (C) + (∈−IND) + (EM) = OST.
(ii) ESTE + (C) + (∈−IND) + (EM) = OST + P.
Proof. (i): Note ﬁrst of all that in the presence of EM, Ω = B. The applicative
axioms, extensionality and the operational axioms of membership, separation and
image in EST and OST are thus equivalent. Showing ﬁrst of all that EST is a
subtheory of OST, we note that one can show that in the latter theory there are
terms representing operations of unordered pair and union (see [16], Corollary 2).
The same corollary of Feferman shows that in OST we can deﬁne constants for
the emptyset and for the ﬁrst inﬁnite ordinal. Thus one can easily derive EST’s
axioms of emptyset and inﬁnity (where (ω 2) requires set–induction). Finally, by
Lemma 4.3 we obtain ω–iteration.
In the opposite direction, showing that OST is contained in EST + (C) +
(∈−IND) + (EM), we note ﬁrst of all that the implicit axioms of emptyset, pair
and union are consequences of their explicit counterparts. Inﬁnity follows from
(ω1). As to the logical operations axioms, we can interpret ⊥and ⊤with ∅and
{∅} (i.e. pair ∅∅), respectively. Finally, by Lemma 3.2, we may let non =
λx.imp x∅, dis = or and all = all .
(ii) To see that ESTE is contained in OST + P, note that for sets a and b the
following is a set
D := {F ∈P(prod ab) : Fun(F) ∧Dom(F) = a ∧Ran(F) ⊆b}.
By Proposition 3.3 the set D may be regarded as an application term, too, so that
λaλb.D uniformly represents exponentiation.
We now show that in the given extension of ESTE there is an application term
representing the powerset operation. We note ﬁrst of all that
∀F ∈Ba∃u (∀x ∈a(⟨x, ⊤⟩∈F ↔x ∈u)).
Let’s write t(a, F, u) or simply t for the term representing the bounded formula
∀x ∈a(⟨x, ⊤⟩∈F ↔x ∈u). We can thus apply OST’s choice operator to
obtain
∀F ∈Ba[(Cλy.t) ↓∧∀x ∈a (⟨x, ⊤⟩∈F ↔x ∈(Cλy.t))].
Thus we have an operation λF.(Cλy.t(a, F, y)) : Ba →V. We can thus apply im
to obtain λa.im (λF.(Cλy.t(a, F, y)))Ba, which represents the powerset operation.

Elementary Constructive Operational Set Theory
219
4.3 Relation with Friedman’s system B.
The theory EST has analogies with Friedman’s constructive set theory B deprived
of the principle of Δ0–Dependent Choice (also called Limited Dependent Choice,
LDC in [18]. See also [3]). Let’s call B−the system obtained from B by omitting
LDC. It is easy to see that B−can be interpreted in EST.8 Friedman’s system
includes a principle of abstraction which takes the place of ZF’s replacement. This
states:
∀x ∃z (z = {{u ∈x : ϕ(⃗y, u)} : ⃗y ∈x}), for ϕ(⃗y, u) a Δ0 formula.
Abstraction is clearly derivable in EST by bounded separation and image.
5 Proof theoretic reduction
In this section we show that the proof–theoretic strength of EST is the same as that
of PA.
Theorem 5.1 (The recursive content of EST). A number theoretic function f is of
type ω →ω provably in EST iff f is provably recursive in PA (hence in HA).
The proof is given in two steps, the lower bound and the upper bound.
5.1 Lower bound
Theorem 5.2. HA is interpretable in EST.
Proof. The domain of the interpretation is ω; the constant ‘0’ is interpreted as
the empty set, while the successor operation is the map x →Suc x. The usual
properties of 0 and successor are easily veriﬁed. Also HA’s induction schema
is given by Δ0 −INDω (Lemma 3.12). We now verify that we can deﬁne two
ternary relations SUM and TIMES on ω, which exist as sets and encode the graphs
of addition and multiplication on ω.
Existence of SUM
Let S be the set–theoretic function corresponding to Suc ; this function exists
in EST (by uniform union, pairing, (ω1), explicit separation, image constructor
and extensionality). Then by ω-iteration there exists an operation f such that, for
m ∈ω,
fm = IT(S, ω, m).
8The interpretation of B−in EST can also be seen as another way of obtaining the lower bound for
EST’s proof–theoretic strength (see section 5.1).

220
Andrea Cantini and Laura Crosilla
By explicit replacement there exists the set
H = im (λm.fm, ω)
of all set–theoretic functions deﬁned by iterating S from m, when m ∈ω. Let
ω3 = prod (ω(prod ωω)). Then by explicit bounded separation there is a set:
SUM ={u ∈ω3 : (∃F ∈H)(∃x, y, z ∈ω)[u = ⟨x, y, z⟩
∧Fun(F(x)) ∧Dom(F(x)) = ω
∧Ran(F(x)) ⊆ω ∧⟨y, z⟩∈F(x)]}.
We claim that SUM is the graph of number theoretic addition.
First of all
∀x ∈ω ∀y ∈ω ∃z ∈ω(⟨x, y, z⟩∈SUM).
Indeed, given x, y ∈ω, there exists a set–theoretic function F(x) := IT(S, ω, x),
which is deﬁned by ω-iteration with initial value x. Hence for every y ∈ω we
can ﬁnd z ∈ω such that ⟨y, z⟩∈F(x). Then we can also verify uniqueness, for
x, y, z ∈ω:
⟨x, y, z⟩∈SUM ∧⟨x, y, w⟩∈SUM →z = w.
Indeed, assume ⟨x, y, z⟩∈SUM and ⟨x, y, w⟩∈SUM. Then there exist elements
u1,u2,u3, v1,v2,v3 in ω , and G, G′ ∈H such that
⟨x, y, z⟩=⟨u1, u2, u3⟩∧Fun(G(u1)) ∧Dom(G(u1)) = ω
∧Ran(G(u1)) ⊆ω ∧⟨u2, u3⟩∈G(u1)
⟨x, y, w⟩=⟨v1, v2, v3⟩∧Fun(G′(v1)) ∧Dom(G′(v1)) = ω
∧Ran(G′(v1)) ⊆ω ∧⟨v2, v3⟩∈G′(v1).
By ordered pairing:
Fun(G(x)) ∧Dom(G(x)) = ω ∧Ran(G(x)) ⊆ω ∧⟨y, z⟩∈G(x)
Fun(G′(x)) ∧Dom(G′(x)) = ω ∧Ran(G′(x)) ⊆ω ∧⟨y, w⟩∈G′(x).
Since G and G′ are both deﬁned by iterating S from the same initial value x, they
coincide by lemma 3.13 and hence z = w.
Existence of TIMES.
Let Fm be the set–theoretic function:
{c ∈ω2 : (∃u, v ∈ω)(c = ⟨u, v⟩∧⟨u, m, v⟩∈SUM)}

Elementary Constructive Operational Set Theory
221
which exists by explicit separation. By ω-iteration, there exists an operation g such
that for all m ∈ω:
gm = IT(Fm, ω, 0).
Clearly (gm)(n) = m · n. By explicit replacement there exists the set G =
im (λm.(gm))ω. Hence by explicit separation there exists a set:
TIMES = {u ∈ω3 :(∃H ∈G)(∃x, y, z ∈ω)(u = ⟨x, y, z⟩
∧Dom(H(x)) = ω ∧Ran(H(x)) ⊆ω ∧⟨y, z⟩∈H(x)}.
Now, given x, y ∈ω, there exists a function H(x) := IT(Fm, ω, 0) deﬁned by
ω-iteration with initial value 0, and we can choose ⟨y, z⟩∈H(x). Hence
(∀x ∈ω)(∀y ∈ω)(∃z ∈ω)(⟨x, y, z⟩∈TIMES).
The veriﬁcation of uniqueness, for x, y, z, w in ω
⟨x, y, z⟩∈TIMES ∧⟨x, y, w⟩∈TIMES →z = w
is similar to the case of addition and follows again by lemma 3.13.
5.2 Upper bound
In this section we introduce two auxiliary theories, ECST∗and Tc, and show that:
(i) (a suitable extension of) EST can be interpreted in ECST∗; (ii) ECST∗can
be interpreted in Tc and thence has the same strength as HA.
Elementary Constructive Set Theory
In [2] the authors introduce a subsystem of CZF called ECST (for Elementary
Constructive Set Theory). They show that many standard set–theoretic construc-
tions may be carried out already in this fragment of constructive set theory. We
shall here be interested in a strengthening of ECST by addition of exponentiation.
The language of ECST is the same language as that of Zermelo–Fraenkel set
theory. In this context, the notion of Δ0 formula is the standard one, that is, a
formula is Δ0 or bounded if no unbounded quantiﬁer occurs in it.
Deﬁnition 5.3. The theory ECST includes the principles of ﬁrst order intuition-
istic logic plus the following set–theoretic principles.
1. Extensionality;
2. Pair;

222
Andrea Cantini and Laura Crosilla
3. Union;
4. Δ0-Separation;
5. Replacement;
6. Strong Inﬁnity.
Here Strong Inﬁnity is the following principle:
∃a [Ind(a) ∧∀z (Ind(z) →a ⊆z)],
where we use the following abbreviations:
• Empty(y) for (∀z ∈y) ⊥,
• Suc(x, y) for ∀z [z ∈y ↔z ∈x ∨z = x],
• Ind(a) for (∃y ∈a)Empty(y) ∧(∀x ∈a)(∃y ∈a)Suc(x, y).
As usual, we write ω also for the set deﬁned by strong inﬁnity (which is unique by
extensionality).
Note that ECST differs from CZF in that it only has Replacement in place of
Strong Collection and it omits both Subset Collection and ∈-Induction. Rathjen
( [28]) has shown that ECST is very weak, as for example it does not prove the
existence of the addition function on ω.
Let exponentiation be the axiom:
∀a, b ∃c ∀F (F ∈c ↔(Fun(F) ∧Dom(F) = a ∧Ran(F) ⊆b)),
where as usual Fun is a bounded formula expressing the fact that F is a set–
theoretic function, Dom(F) and Ran(F) are the domain and range of F, respec-
tively.
Deﬁnition 5.4. The theory ECST∗is obtained from ECST by adding the axiom
of exponentiation.
To establish the upper bound we need to show that (a suitable extension of) EST
can be interpreted in ECST∗and that in turn ECST∗can be reduced to PA. We
start from the latter problem.

Elementary Constructive Operational Set Theory
223
Reducing ECST∗to PA
We here modify the interpretation of [9] of a system of constructive set theory with
urelements in a classical theory, Tc, of abstract self–referential truth. The ﬁnal
result relies on the fact that Tc is conservative over PA ( [7]). The main idea of
the interpretation in [9] was to rephrase, in the new context, Aczel’s interpreta-
tion of CZF in Constructive Type Theory and combine it with a suitable form of
realizability.
First of all, let’s recall the theory Tc.
The theory Tc
The basic ﬁrst order language LT of Tc comprises the predicate symbols =, T ,
Nat , the binary function symbol ap (application), combinators K, S, successor,
predecessor, deﬁnition by cases on numbers, pairing with projections. Terms are
inductively generated from variables and individual constants via application. As
usual ts := ap(t, s); missing brackets are restored by associating to the left. For-
mulas are inductively generated from atoms of the form t = s, T (t), Nat(t) by
means of sentential operations and quantiﬁers. We adopt the following conventions:
(i) By [ϕ] we denote a term representing the propositional function associated
with ϕ and such that FV([ϕ]) = FV(ϕ). We ﬁx distinct closed terms ˆ∀, ˆ∃,
ˆ¬ ˆ∧, ..., naming the logical constants. In addition, ˆ=, ˆN name the equality
and the number predicates, respectively. Then [ϕ] is inductively deﬁned by
stipulating [t = s] = (ˆ= ts), [Nat(s)] =
ˆ
Nats, [T (s)] = s and closing un-
der application of the “small hat” operations, noting that [∀xϕ] = ˆ∀(λx[ϕ]),
[∃xϕ] = ˆ∃(λx[ϕ]).
(ii) Given a formula ϕ we deﬁne abstraction by letting {x : ϕ} := λx.[ϕ].
(iii) We deﬁne intensional membership, η , as follows:
x η a := T (ax);
x ¯η a := T (ˆ¬(ax)).
(iv) The notion of class (or classiﬁcation) is so speciﬁed:
Cl(a) := ∀x (x η a ∨x ¯η a).
(v) A formula ϕ is T –positive iff ϕ is inductively generated from prime formulas
of the form T (t), t = s, ¬t = s, Nat(t), ¬Nat(t) by means of ∨, ∧, ∀, ∃.

224
Andrea Cantini and Laura Crosilla
(vi) A formula ϕ is T –positive operative in v (in short, a positive operator) iff
ϕ belongs to the smallest class of formulas inductively generated from prime
formulas of the form T (t), s η v, t = s, ¬t = s, Nat(t), ¬Nat(t) by means
of ∨, ∧, ∀y, ∃y, where y is distinct from v and v does not occur in t, s.
(vii) For each formula ϕ, ﬁxed points are deﬁned by letting:
I(ϕ) := Y(λv.{x : ϕ(x, v)})
where Y is Curry’s ﬁxed point combinator.
The system Tc comprises the following prinicples, besides classical predicate
calculus with equality.
1. The base theory TON−(see e. g. [23]), which formalises the notion of to-
tal extensional combinatory algebra expanded with natural numbers. This in-
cludes the obvious axioms on combinators, pairing, projections. In addition,
closure axioms for the predicate Nat deﬁning a copy of the natural numbers,
together with number theoretic conditions on the basic operations of successor
SUC, predecessor PRED, 0, deﬁnition by cases on the natural numbers.
2. A ﬁxed point axiom (Tr) for abstract truth
Tr(x, T ) ↔T (x).
Here Tr(x, T ) is a formula encoding the closure properties:
a = b
T [a = b]
¬(a = b)
T [¬(a = b)]
Nat(a)
T [Nat(a)]
¬Nat(a)
T [¬Nat(a)]
for the basic atomic formulas with = and Nat. Further, the following addi-
tional clauses for the compound formulas:
T (a)
T (ˆ¬ˆ¬a)
T a
T b
T (a ˆ∧b)
T (ˆ¬a) [ or T ˆ¬b]
T (ˆ¬(a ˆ∧b))
∀x T (ax)
T (ˆ∀a)
∃x T ˆ¬ax
T (ˆ¬ˆ∀a)
3. Consistency axiom: ¬(T x ∧T ˆ¬x).

Elementary Constructive Operational Set Theory
225
4. Induction on natural numbers Nat for classes:
Cl(a) ∧ClosNat(a) →∀x(Nat(x) →x η a)
with ClosNat(a) := 0ηa ∧∀x (xηa →(SUCx)ηa).
5. The principle GID, ensuring the minimality of the ﬁxed points: if ϕ(x, v) is
a positive operator
Closϕ(ψ) →∀x (xηI(ϕ) →ψ(x))
with Closϕ(ψ) := ∀x (ϕ(x, ψ) →ψ(x)).9
T−is the theory Tc without number theoretic induction.
Let CL be {x : Cl(x)} (which is provably not a class). Then we can show that CL
has natural closure conditions which are essential for the interpretation of ECST∗.
That is, T−is closed under elementary comprehension, generalized disjoint union,
generalized disjoint product. It satisﬁes a form of positive comprehension: if ϕ is
T –positive, then T [ϕ] ↔ϕ and ∀x (xη{u : ϕ} ↔ϕ[u := x]). Also a version of
the second recursion theorem holds: if ϕ is positive ∀x (xηI(ϕ) ↔ϕ(x, I(ϕ)));
for the proofs, see [8], II.9B, II.10A.
Theorem 5.5. Tc is proof–theoretically equivalent to PA.
Proof. See [9], Theorem 7.3 or [7].
Reducing ECST∗to Tc
In the following, unless otherwise stated, we work in the theory T−. We deﬁne
a suitable counterpart of a universe VN of sets, in a similar vein as in [9] (see
also [10], [11]). A point of departure from [9] is however the treatment of inﬁnity,
as the subsystem of COST utilised there had urelements for natural numbers. For
the present purpose it is instead crucial that the set of von Neumann natural numbers
is interpreted in our weak theory, so to ensure that strong inﬁnity holds under the
given interpretation. For this purpose we add an initial condition to our version
of Aczel’s universe, adapting to our case a trick of Rathjen ( [28]). In particular,
in addition to the usual condition which deﬁnes sets as elements of the type of
iterative sets, we also introduce a separate rule which deﬁnes the natural numbers
as elements of the same type.
9Here ϕ(x, ψ) is the formula obtained by replacing each occurrence of the formula t η v in ϕ(x, v)
by means of ψ(t).

226
Andrea Cantini and Laura Crosilla
Let (x, y) denote the basic pairing operation which is built-in the axioms of T−;
(x, y, z) stands for (x, (y, z)), and, if u = (x, y, z), u0 = x, u1 = y and u2 = z.
Let N be the class {x : Nat(x)} and
Nk := {m : m η N ∧m <N k},
where <N represents the ordering relation on N. Henceforth, we simply write <
instead of <N. Note that Nk is a class for every k η N. We also write sup(a, f) for
(1, a, f).
Choose by the ﬁxed point theorem an operation ν such that
νx = sup(Nx, ν).
(5.1)
Informally, the idea is that sup(Nk, ν) represents the von Neumann ordinal associ-
ated to the number k.
The universe of sets VN is deﬁned by means of two rules, one for initial ﬁnite
segments of natural numbers and one for sets:
k η N
sup(Nk, ν) η VN
and
Cl(a)
∀u η a (fu η VN)
sup(a, f) η VN
.
Lemma 5.6.
If m η N and k η N then Nm = Nk ↔m = k.
Proof. Obvious from right to left. Conversely, note that, if Nm = Nk and m ̸= k,
we obtain a contradiction.
Proposition 5.7. There exists a closed term VN such that
(i)
a η VN ↔∃n η N (a = sup(Nn, ν))
∨(a = sup(a1, a2) ∧Cl(a1) ∧∀u η a1 (( a2u) η VN));
(ii) ∀x(V(x, ϕ) →ϕ(x)) →∀x (xηVN →ϕ(x)),
where ϕ is an arbitrary formula and V(x, ϕ) is an abbreviation for ∃n η N (x =
sup(Nn, ν)) ∨(x = sup(x1, x2) ∧Cl(x1) ∧(∀u η x1)(ϕ( x2u))).
Proof. See [9], Proposition 8.1. Observe that (ii) is an application of GID.

Elementary Constructive Operational Set Theory
227
Note that, as Ni is a class for each i η N, and νi = sup(Ni, ν), we have
sup(Ni, ν) η VN ↔Cl(Ni) ∧∀k η Ni(νk η VN);
hence, by proposition 5.7 (i):
a η VN ↔a = sup(a1, a2) ∧Cl(a1) ∧∀u η a1 (( a2u) η VN).
In the following, applications of proposition 5.7 (ii) will be simply referred to as
proofs by induction on VN.
Proposition 5.8. There are operations assigning ¯a and a to each a η VN and such
that Cl(¯a) and a : ¯a →VN (that is ∀xη¯a (axηVN)).
Proof. By induction on VN, using the recursion theorem.
We next deﬁne recursively an equivalence relation, .=, on VN.
If a ∈VN, let
Nat(a) := ∃k(k η N ∧a = sup(Nk, ν)).
Lemma 5.9. There exists a term .= such that
a .= b ↔a η VN ∧b η VN ∧[∃k(k η N ∧Nk = ¯a = ¯b ∧a = b = ν) ∨
∨(¬(Nat(a) ∧Nat(b)) ∧∀x η ¯a ∃y η ¯b (ax .= by) ∧
∧∀y η ¯b ∃x η ¯a (ax .= by))].
Lemma 5.10. For a, b, c η VN the following holds
1. a .= a
2. a .= b →b .= a
3. a .= b ∧b .= c →a .= c.
Deﬁnition 5.11. Let a, b ηVN:
a ˙∈b := ∃x η ¯b (a .= bx).
The interpretation proceeds similarly as in [9], section 8. We here present only
the most relevant steps of the interpretation.
Lemma 5.12 (Extensionality). Let a, b η VN.
∀x η VN (x ˙∈a ↔x ˙∈b) →a .= b.

228
Andrea Cantini and Laura Crosilla
Proof. Case 1: Assume a = sup(Nm, ν), b = sup(Nk, ν) and
∀x(x ˙∈a ↔x ˙∈b).
This easily implies
(∀i < m)(∃j < k)(sup(Ni, ν) .= sup(Nj, ν))
(∀j < k)(∃i < m)(sup(Nj, ν) .= sup(Ni, ν)).
By lemma 5.9
(∀i < m)(i < k) ∧(∀i < k)(i < m),
which implies m = k, that is by deﬁnition sup(Nm, ν) .= sup(Nk, ν).
Case 2: At least one between a, b is generated in VN according to the second
clause. Suppose z η ¯a. Then az η VN and az ˙∈a, so that by hypothesis, also az ˙∈b.
Then there exists a y such that y η ¯b and az .= by. Similarly one proves the other
conjunct in the deﬁnition of a .= b.
Lemma 5.13. For a, b η VN,
T [a .= b] ∨T [¬a .= b];
T [a ˙∈b] ∨T [¬a ˙∈b].
Proof. See [9], Lemma 8.12.
Proposition 5.14. The structure ⟨VN, .=, ˙∈⟩is a model of the theory ECST∗
without replacement and exponentiation, provably in Tc.
Proof. See Proposition 8.1 of [9]. The main differences with that proposition con-
cern extensionality, which is taken care of by Lemma 5.12, and strong inﬁnity,
which we address in the following.
Deﬁne ˆω := sup(N, j) where, for m η N:
j(m) = sup(Nm, ν).
We need to show that:
1. ˆω η VN and ˆω is inductive (i.e. ˆω contains the empty set and is closed under
the set–theoretic successor, as deﬁned within VN);
2. if a η VN and a is inductive, then ˆω ⊆a.

Elementary Constructive Operational Set Theory
229
The ﬁrst half of the ﬁrst claim is obvious by construction. The second half requires
class induction. As to the second claim, we assume that a is inductive and by class
induction, using lemma 5.13, we show that
(∀i η N)(∃v η ¯a)(av .= ji = sup(Ni, ν)).
If i = 0, we are done by assumption on a. Let i = SUCm and assume by IH that
for some v η ¯a, av .= sup(Nm, ν). For c η VN, let’s write (c ∪{c}) also for the
appropriate interpretation of the successor in VN (obtained by interpreting pair and
union as appropriate). Now av ˙∈a; by deﬁnition of inductive set, we also know that
(av ∪{av}) ˙∈a and hence, for some w η ¯a, aw ˙∈a and aw .= (av ∪{av}). Then
also (jm ∪{jm}) ˙∈a. Since we can easily verify that
(jm ∪{jm}) .= j(SUCm)
we have the expected conclusion j(SUCm) .= ai.
Finally, to give an interpretation of the theory ECST∗(including replacement
and exponentiation) we can deﬁne a suitable notion of realisability in the theory
Tc. First of all, if ϕ is a bounded formula of ECST∗, we inductively deﬁne a
map ϕ →∥ϕ∥, where (roughly) ∥ϕ∥collects the proof objects for ϕ, provided the
parameters range over VN.
Let ⊤denote the classiﬁcation which only has the empty classiﬁcation as ele-
ment, while a + b := {u : u = (u0, u1) ∧((u0 = 0 ∧u1 η a) ∨(u0 = 1 ∧
u1 η b))} represents the direct sum of a, b.
Deﬁnition 5.15.
∥⊥∥= {e η ⊤: 0 = 1};
∥a = b∥= {e : e = 0 ∧∃k(k η N ∧Nk = ¯a = ¯b ∧a = b = ν)}
+ {e : e = (e0, e1) ∧¬(Nat(a) ∧Nat(b)) ∧
∧∀u η ¯a (e0u)0 η ¯b ∧(e0u)1 η ∥au = b(e0u)0∥∧
∧∀v η ¯b (e1v)0 η ¯a ∧(e1v)1 η ∥a(e1v)0 = bv∥};
∥a ∈b∥= {e : e = (e0, e1) ∧e0 η ¯b ∧e1 η ∥a = be0∥};
∥ϕ ∧ψ∥= {e : e = (e0, e1) ∧e0 η ∥ϕ∥∧e1 η ∥ψ∥};
∥ϕ ∨ψ∥= ∥ϕ∥+ ∥ψ∥;
∥ϕ →ψ∥= {e : ∀q η ∥ϕ∥(eq η ∥ψ∥)};
∥∃x ∈a ϕ(x)∥= {e : e = (e0, e1) ∧e0 η ¯a ∧e1 η ∥ϕ(ae0)∥};
∥∀x ∈a ϕ(x)∥= {e : ∀u η ¯a (eu η ∥ϕ(au)∥)}.

230
Andrea Cantini and Laura Crosilla
Formally speaking, the deﬁnition of ∥ϕ∥above makes sense only after showing
by a ﬁxed point argument in T−that there exists an operation H(a, b) satisfying
the equation for ∥a = b∥(hence the deﬁnition inductively extends H to arbitrary
bounded conditions).
Deﬁnition 5.16. Let ϕ be an arbitrary formula of ECST∗; we inductively deﬁne
a formula e ⊩ϕ of Tc with the same free variables as ϕ and a fresh variable e:
1. if ϕ is a bounded formula of ECST∗, then
e ⊩ϕ iff e η ∥ϕ∥;
else:
2.
e ⊩ϕ →ψ iff ∀f(f ⊩ϕ →ef ⊩ψ) ;
e ⊩ϕ ∧ψ iff e = (e0, e1) ∧e0 ⊩ϕ ∧e1 ⊩ψ ;
e ⊩ϕ ∨ψ iff (e = (0, e1) ∧e1 ⊩ϕ) ∨(e = (1, e1) ∧e1 ⊩ψ) ;
e ⊩∀x ∈a ϕ(x) iff ∀x η ¯a (ex ⊩ϕ(ax)) ;
e ⊩∃x ∈a ϕ(x) iff e = (e0, e1) ∧e0 η ¯a ∧e1 ⊩ϕ(ae0) ;
e ⊩∃x ϕ iff e = (e0, e1) ∧e0 η VN ∧e1 ⊩ϕ(e0) ;
e ⊩∀x ϕ iff ∀x η VN (ex ⊩ϕ(x)) .
Lemma 5.17. Let ϕ be a bounded formula of ECST∗. Then T−proves
⃗x ∈VN →Cl(∥ϕ(⃗x)∥);
e ⊩ϕ(⃗x) iff e η ∥ϕ(⃗x)∥.
Theorem 5.18. Every theorem of ECST∗is realized in Tc, i.e. if ECST∗⊢
ϕ(⃗x), then there exists a closed term e such that, provably in Tc, for ⃗a ∈VN
e⃗a ⊩ϕ(⃗a).
Proof. See Theorem 8.22 of [9].

Elementary Constructive Operational Set Theory
231
5.3 Interpreting ΓBEST in ECST∗
Let BEST be ESTE + FO. We shall prove that BEST is conservative over
ECST∗for a suitable class of formulas in the common language. This is achieved
through two steps. First we give a sequent style formulation of BEST, called
ΓBEST, so that the active formulas are positive in App and a partial cut elimination
theorem holds. Then we give an asymmetric interpretation of ΓBEST in ECST∗,
which yields the ﬁnal result.
Step 1
We only give a sketch of the theory ΓBEST. As usual, capital Greek
letters Γ, Λ, . . . denote ﬁnite sequences of formulas of ΓBEST. Sequents are of
the form Γ ⇒Λ. The system ΓBEST is an extension of the intuitionistic Gentzen
calculus ( [30]). The logical rules consist of the usual rules for intuitionistic logic,
including cut and =. In addition, there are the structural rules of weakening, ex-
change and contraction. In the following we ﬁrst present the axioms and rules
involving application; in particular, we include trivial independence conditions on
constants for operations. Then we state the main rules for the set–theoretic con-
structors of ΓBEST.
In order to simplify the statements, we extend the language by adding new terms
as follows:
(*) if t, s are terms, so are Kt, St, pairt, imt, sept, elt, expt, Sts.10
Finally, note that in the following, separation and explicit replacement are split
into distinct rules to ease the asymmetric interpretation of section 5.4.
Gentzen-style presentation of non-logical axioms and rules.
ΓBEST
includes (the closure under substitution of) the following sequents and rules:
1. Uniqueness:
Γ, ts ≃p, ts ≃q ⇒p = q
2. let C be a constant among K, S, pair, im, sep, el, exp; then
Γ ⇒Ct ≃Ct
Γ ⇒Sts ≃Sts
10Formally, the special terms can be eliminated by means of a set–theoretically deﬁned ordered pairing
operation ⟨−, −⟩and 8 distinct sets c1,. . . , c8, e.g. to be identiﬁed with distinct elements of ω. For
example, Kt, can be identiﬁed with ⟨c1, t⟩.

232
Andrea Cantini and Laura Crosilla
3. Combinatory completeness:
Γ ⇒Kts ≃t
Γ ⇒tr ≃u
Γ ⇒sr ≃v
Γ ⇒uv ≃w
Γ ⇒Stsr ≃w
4. Independence:
• let C1, C2 ∈{K, S, pair, un , im, sep, el, exp}; then
Γ , C1 = C2 ⇒
• let C1, C2 ∈{K, S, pair, im, sep, el, exp}; then
Γ , C1
t = C2
s ⇒t = s ∧C1 = C2
• let C1, C2 ∈{S}; then
C1
ts = C2
pq ⇒t = p ∧s = q ∧C1 = C2
5. Extensionality:
Γ, ∀x (x ∈p ↔x ∈q) ⇒p = q
6. Empty-set:
Γ ⇒∀x(x /∈∅)
7. Representing elementhood:
Γ ⇒∃z[z ⊆⊤∧elab ≃z ∧∀u(u ∈z ↔u = ⊥∧a ∈b)]
8. Union:
Γ ⇒∃z[una ≃z ∧∀u(u ∈z ↔∃y ∈a (u ∈y))]
9. Pairing:
Γ ⇒∃z[pairab ≃z ∧∀u(u ∈z ↔u ∈a ∨u ∈b)]

Elementary Constructive Operational Set Theory
233
10. Strong inﬁnity:
Γ ⇒∅∈ω
Γ, t ∈ω ⇒S t ∈ω
Γ, ∅∈t ∧∀y(y ∈t →Suc y ∈t) ⇒ω ⊆t
11. Separation:
Γ ⇒(∀u ∈a)(∃y ⊆⊤)(fu ≃y)
Γ ⇒∃z[(∀u ∈z)(fu ≃⊤∧u ∈a) ∧
∧(∀u ∈a)(∀y(fu ≃y →y = ⊤) →u ∈z)]
From the premisses
• Γ ⇒(∀u ∈a)(∃y ⊆⊤)(fu ≃y)
• Γ ⇒(∀u ∈z)(fu ≃⊤∧u ∈a)
• Γ ⇒(∀u ∈a)(∀y(fu ≃y →y = ⊤) →u ∈z)
infer:
Γ ⇒sepaf ≃z
12. Explicit replacement:
Γ ⇒(∀x ∈a)∃y(fx ≃y)
Γ ⇒∃z[(∀y ∈z)(∃x ∈a)(fx ≃y) ∧(∀x ∈a)(∃y ∈z)(fx ≃y)]
From the premisses
• Γ ⇒(∀u ∈a)∃y(fu ≃y)
• Γ ⇒(∀y ∈z)(∃x ∈a)(fx ≃y)
• Γ ⇒(∀x ∈a)(∃y ∈z)(fx ≃y)
infer:
Γ ⇒imaf ≃z

234
Andrea Cantini and Laura Crosilla
13. Exponentiation:
Γ ⇒∃z[expab ≃z ∧
∧∀F(F ∈z ↔(Fun(F) ∧dom(F) = a ∧Ran(F) ⊆b))]
14. Beeson’s axiom FO: every function is an operation, i.e.
Γ, Fun(F), ⟨x, y⟩∈F ⇒Fx ≃y
Γ, Fun(F), Fx ≃y ⇒⟨x, y⟩∈F.
We stress that the active formulas of the inferences and axioms are positive in
App.
Theorem 5.19 (Quasi-normal form). A ΓBEST-derivation D can be effectively
transformed into a ΓBEST-derivation D∗of the same sequent, such that every cut
formula occurring in D∗is positive in ≃.
5.4 Step 2. The asymmetric interpretation
We now deﬁne an asymmetric interpretation of ΓBEST into ECST∗: the idea is
to replace App by its ﬁnite stages Appn which, for each given n, can be explicitly
deﬁned and proved to exist in the pure set–theoretic language of ECST∗. Thus the
ﬁnite approximations of the rules can be justiﬁed in the App-free system ECST∗.
However, the interpretation is asymmetric in the sense that it depends on a pair of
number parameters m ≤n; in particular the positive occurrences of App are sep-
arated from the negative ones (the former being replaced by Appn and the second
by Appm).
Let A(x, y, z, P) be the App-positive formula, inductively generating the appli-
cation predicate. The formula belongs to the language of ECST∗, except (i) for
the ternary predicate symbol P and (ii) for the terms of the form Ct, Sts (C being
a constant among K, S, im, sep, el, exp, pair). Since these special terms can be
readily eliminated (in the sense that we can deﬁne a translation thereof in the pure
set–theoretic language), we can assume that A(x, y, z, P) belongs to the language
of ECST∗, expanded with P.
Deﬁnition 5.20. Let ⊥also be an abbreviation for K = S and deﬁne inductively:
App0(x, y, z) := ⊥
Appk+1(x, y, z) := A(x, y, z, Appk).
Here above A(x, y, z, Appk) is obtained from A(x, y, z, P) by replacing P every-
where with Appk.

Elementary Constructive Operational Set Theory
235
Deﬁnition 5.21.
(i) We inductively deﬁne A[m, n], where A is a formula of ΓBEST: uniformly in
n, m.
A[m, n] := A provided A has the form t = s or t ∈s
App(t, s, r)[m, n] := Appn(t, s, r)
(A →B)[m, n] := (A[n, m] →B[m, n]);
moreover A →A[m, n] commutes with ∧, ∨, ∀, ∃.
(ii) If Γ := {A1, . . . , Ap}, Γ[m, n] := {A1[m, n], . . . , Ap[m, n]};
(iii) (Γ ⇒Δ)[m, n] := Γ[n, m] ⇒Δ[m, n].
Lemma 5.22.
(i) For each k ∈ω, Appk is a formula of ECST∗.
(ii) In addition we have, provably in ECST∗,
k ≤m ⇒Appk(x, y, z) →Appm(x, y, z);
(iii) if A is App-positive (negative), then A[m, n] := An (A[m, n] := Am); if A is
App-free, A[m, n] := A.
Lemma 5.23 (Persistence).
Let m ≤p ≤q ≤n. Then provably in ECST∗:
A[p, q] →A[m, n];
A[n, m] →A[q, p].
Below we also use the more suggestive notation xy
≃m
z instead of
Appm(x, y, z).
Lemma 5.24 (Uniqueness). Provably in ECST∗: If Fun(F), Dom(F) = a,
Ran(F) ⊆a and x ∈a then
Iter(z, F, a, x) ∧Iter(y, F, a, x) →z = y.
(5.2)
Furthermore, for each given m ∈ω:
xy ≃m z ∧xy ≃m w →z = w.
(5.3)

236
Andrea Cantini and Laura Crosilla
Proof. As to (5.2), this is analogous to Lemma 3.13.
As to (5.3), we argue informally by outer induction on m ∈ω. If m = 0, the
conclusion is trivial. As to the veriﬁcation of the induction step m = j +1, we ﬁrst
apply the independence axioms. This immediately yields uniqueness in all trivial
cases where x is among un, pair, exp, K, S.
Assume xy ≃j+1 z, xy ≃j+1 w, i.e. A(x, y, z, Appj) and A(x, y, w, Appj).
Then, for some a, b, c, d, we obtain x = Sab and x = Scd. By independence,
a = c, b = d and hence Saby ≃j+1 z, Saby ≃j+1 w, which imply, for some p, q,
r, s:
• ay ≃j p, by ≃j q, pq ≃j z
• ay ≃j r, by ≃j s, rs ≃j w.
By IH p = r, q = s and hence pq ≃j z, pq ≃j w, which yields z = w again by IH.
Consider the case where imaf ≃j+1 z, imaf ≃j+1 w (we implicitly use inde-
pendence conditions on terms of the form ima). Then we have
• (∀u ∈z)(∃x ∈a)(fx ≃j u) ∧(∀x ∈a)(∃u ∈z)(fx ≃j u);
• (∀u ∈w)(∃x ∈a)(fx ≃j u) ∧(∀x ∈a)(∃u ∈w)(fx ≃j u).
We prove z ⊆w. Let u ∈z: then by the ﬁrst condition above fx ≃j u, for some
x ∈a. Then by the second condition, fx ≃j v, for some v ∈w. By IH u = v and
hence u ∈w. We also easily verify that w ⊆z and hence w = z by extensionality.
Theorem 5.25. Let D be a ΓBEST-derivation of Γ ⇒Δ. Then there exists a
natural number c ≡cD such that, for every m > 0 and every n such that n ≥c+m,
(Γ ⇒Δ)[m, n]
is derivable in ECST∗.
Proof. By the preparation lemma we can assume that the given derivation of Γ ⇒
Δ is quasi-normal, i.e. cuts occur only on App-positive formulas. Furthermore, by
the previous lemma 5.23 it is enough to check, for some constant c depending on
the given quasi-normal derivation,
(Γ ⇒Δ)[m, c + m].
(5.4)

Elementary Constructive Operational Set Theory
237
Cut Assume that our derivation D ends with a cut on an App-positive formula C
and that the immediate subderivations of D end with Γ ⇒C and C, Γ ⇒A.
By IH we have, for some c0, c1, for each m > 0:
Γ[c0 + m, m] ⇒Cc0+m
Cm, Γ[c1 + m, m] ⇒A[m, c1 + m].
Choose m := c0 + m in the second sequent. Then, for c = c0 + c1, we obtain:
Cc0+m, Γ[c + m, c0 + m] ⇒A[c0 + m, c + m].
Hence with a cut
Γ[c + m, c0 + m], Γ[c0 + m, m] ⇒A[c0 + m, c + m].
But m ≤c0 + m ≤c + m and hence by persistence:
Γ[c + m, m], Γ[c + m, m] ⇒A[m, c + m].
The conclusion follows by contraction.
Explicit replacement By IH, for some c0, for every m > 0, we have:
. Γ[c0 + m, m] ⇒(∀x ∈a)(∃y)(fx ≃c0+m y)
As y is unique, by replacement, there exists a function F (hence a set), de-
pending on c0 + m, such that
(∀x ∈a)(fx ≃c0+m F(x)).
Hence we can choose a set z = {F(x) | x ∈a}, depending on c0 + m; z
satisﬁes the asymmetric translation of the conclusion choosing c := c0, i.e. we
can derive in ECST∗the sequent whose antecedent is Γ[c+m, m] and whose
succedent is
(∀y ∈z)(∃x ∈a)(y ≃c+m fx) ∧(∀x ∈a)(∃y ∈z)(fx ≃c+m y).
On the other hand, by IH we have
• Γ[c0 + m, m] ⇒(∀u ∈a)(∃y)(fu ≃c0+m y)

238
Andrea Cantini and Laura Crosilla
• Γ[c0 + m, m] ⇒(∀y ∈z)(∃x ∈a)(fx ≃c0+m y)
• Γ[c0 + m, m] ⇒(∀x ∈a)(∃y ∈z)(fx ≃c0+m y).11
Hence by deﬁnition of the operator deﬁning ≃we have, for c = c0 + 1:
Γ[c + m, m] ⇒imaf ≃c+m z.
Separation By IH, for some c0, for every m > 0, we have:
Γ[c0 + m, m] ⇒(∀x ∈a)(∃y ⊆⊤)(fx ≃c0+m y).
By replacement, there exists a function F (hence a set), depending on c0 + m,
such that
(∀x ∈a)(F(x) ⊆⊤∧fx ≃c0+m F(x)).
Hence
z = {x ∈a | ⟨x, ⊤⟩∈F}
is a set by bounded separation and it satisﬁes the asymmetric interpretation of
the conclusion choosing c = c0. As in the previous case, we can derive by
deﬁnition of the operator deﬁning ≃, for c = c0 + 1:
Γ[c + m, m] ⇒sepaf ≃c+m z
provided z satisﬁes the asymmetric interpretation of the premisses of the sec-
ond separation rule.
Exp, Union, Pairing, Elementhood by the appropriate corresponding axioms
choosing c = 0.
Corollary 5.26. Every ΓBEST-derivation of an App-free condition can be effec-
tively transformed into a derivation in ECST∗.
11Strictly speaking, each premiss will be assigned its own bounding constant ci, where i = 1, 2, 3, but
by persistence we can replace it by c0 = max{c1, c2, c3}.

Elementary Constructive Operational Set Theory
239
References
[1] P. ACZEL, The Type Theoretic Interpretation of Constructive Set Theory, in: A.
MacIntyre, L. Pacholski, J. Paris (eds.), Logic Colloquium ’77 (North–Holland,
Amsterdam-New York, 1978).
[2] P. ACZEL, M. RATHJEN, Notes on Constructive Set Theory, Draft available
at the address:
http://www.mittag-leffler.se/preprints/meta/
AczelMon\_Sep\_24\_09\_16\_56.rdf.html.
[3] M. BEESON, Foundations of Constructive Mathematics, (Springer Verlag, Berlin,
1985).
[4] M. BEESON, Proving programs and programming proofs, in: R. BARCAN MARCUS
ET AL., EDS., Logic, Methodology and Philosophy of Science VII, Proceedings of
the meeting in Salzburg, Austria, July 1983, (North–Holland, Amsterdam, 1986), 51-
82.
[5] M. BEESON, Towards a computation system based on set theory, Theoretical Com-
puter Science 60 (1988) pp. 297–340.
[6] A. CANTINI, On the Relation Between Choice and Comprehension Principles in Sec-
ond Order Arithmetic, Journal of Symbolic Logic, 51 (1986) pp. 360–373.
[7] A. CANTINI, Levels of implication and type free theories of partial classiﬁcations
with approximation operator, Zeitschrift f¨ur mathematische Logik und Grundlagen
der Mathematik 38 (1992) pp. 107–141.
[8] A. CANTINI, Logical Frameworks for Truth and Abstraction, (North Holland, Am-
sterdam, 1996).
[9] A. CANTINI, L. CROSILLA, Constructive set theory with operations, in A. Andretta,
K. Kearnes, D. Zambella eds., Logic Colloquium 2004, Association of Symbolic
Logic, Lecture notes in Logic, 29, 2008.
[10] L. CROSILLA, Realizability Models for Constructive Set Theories with Restricted
Induction Principles, University of Leeds, Ph. D. Thesis, Department of Pure Mathe-
matics, September 2000.
[11] L. CROSILLA, M. RATHJEN, Inaccessible set axioms may have little consistency
strength, Annals of Pure and Applied Logic 115/1-3 (2001) pp. 33–70.
[12] L. CROSILLA, Constructive and intuitionistic ZF, in: Stanford Encyclopedia of Phi-
losophy, February 2009, available at the address: http://plato.stanford.
edu/entries/set-theory-constructive/.
[13] R. DIACONESCU, Axiom of choice and complementation Proc. Amer. Math. Soc. 51
(1975) pp. 176–178.
[14] S. FEFERMAN, A language and axioms for explicit mathematics in: J. Crossley (ed.),
Algebra and Logic, Lecture Notes in Mathematics, vol 450, (Springer, Berlin 1975)
pp. 87–139.

240
Andrea Cantini and Laura Crosilla
[15] S. FEFERMAN, Constructive theories of functions and classes, in M. Boffa, D. van
Dalen, K. McAloon (eds.) Logic Colloquium ’78, (North Holland, Amsterdam, 1979)
pp. 159–224.
[16] S. FEFERMAN, Notes on Operational Set Theory I. Generalization of “small” large
cardinals in classical and admissible set theory, unpublished, Stanford University
(2001) pp. 1–10.
[17] S. FEFERMAN, Operational Set Theory and small large cardinals, Information and
Computation, Vol 207, issue 10, 2009, pp. 971-979 .
[18] H. FRIEDMAN, Set-theoretic foundations for constructive analysis, Annals of Math-
ematics 105 (1977) pp. 1–28.
[19] N.D. Goodman, J. Myhill: Choice implies excluded middle. Z. Math. Logik Grund-
lag. Math. 24 (1978) p. 461.
[20] G. J ¨AGER, On Feferman’s operational set theory OST, Annals of Pure and Applied
Logic, 150 (2007) pp. 19–39 .
[21] G. J ¨AGER, Full operational set theory with unbounded existential quantiﬁcation and
powerset, Annals of Pure and Applied Logic, 160(1), pp. 33-52.
[22] G. J ¨AGER, Operations, sets and classes, Logic, Methodology and Philosophy of
Science: Proceedings of the thirteen International Congress, ed. by C. Glymour, W.
Wei, E. Westerstahl, College Publications (2009)
[23] G. J ¨AGER, T. STRAHM, Totality in applicative theories, Annals of Pure and Applied
Logic, vol. 74 (1995) pp. 105–120.
[24] L. S. MOSS, Power set Recursion, Annals of Pure and Applied Logic 71 (1995) pp.
247–306.
[25] J. MYHILL, Constructive Set Theory, The Journal of Symbolic Logic 40 (1975) pp.
347–382.
[26] D. NORMANN, Set Recursion, Generalized Recursion Theory II (North Holland,
Amsterdam, 1978) pp. 303–320.
[27] M. RATHJEN, The formulae as classes interpretation of constructive set theory, Proof
technology and computation, 279–322 (NATO Sci. Ser. III Comput. Sys. Sci., 2000,
Amsterdam, 2006).
[28] M. RATHJEN, The natural numbers in constructive set theory, Mathematical Logic
Quarterly 54 (2008) n.1, 83–97.
[29] A. S. TROELSTRA AND D. VAN DALEN, Constructivism in Mathematics: an Intro-
duction, volumes I and II (North–Holland, Amsterdam, 1988).
[30] A.S.TROELSTRA, H.SCHWICHTENBERG, Basic Proof Theory, Cambridge Univer-
sity Press, Cambridge 2000 (2nd ed.).
[31] H. WEYL, Das Kontinuum (Leipzig, 1918).

Functional Interpretations of Classical Systems
Justus Diller
Institut f¨ur Mathematische Logik und Grundlagenforschung
Westf¨alische Wilhelms-Universit¨at M¨unster
Einsteinstraße 62, 48149 M¨unster, Germany
dillerj@math.uni-muenster.de
Abstract In contrast to G¨odel’s Dialectica interpretation, the Diller-Nahm
interpretation extends to systems of arithmetic in all ﬁnite types as well as to
systems of set theory. We present a uniﬁed treatment of functional interpre-
tations of Peano arthmetic and Kripke-Platek set theory, both of the standard
classical theories as well as of their versions in all ﬁnite types. We also
give axiomatic characterizations of the functional translations in question by
weak axioms of choice.
1 Functional translations of classical systems, common
features
G¨odel’s 1958 Dialectica interpretation D of Heyting arithmetic HA in his
quantiﬁer-free theory T of primitive recursive functionals of ﬁnite types [11] does
not extend to Heyting arithmetic in all ﬁnite types HAω, as Howard’s example
shows. For the same reason, D as well as Shoenﬁeld’s interpretation S of Peano
arithmetic PA [16] do not extend to Peano arithmetic in all ﬁnite types PAω.
Also Kripke-Platek set theory (with axiom of inﬁnity) KPω cannot be D- or S-
interpreted by constructive functionals, but only by use of a non-constructive choice
functional (cf. [6]). Burr [4] gives a functional interpretation of KPω by a hybrid
∨of the ∧- (cf. [9]) and the S-interpretation. Concerning the background of func-
tional interpretations, see [1], [5], [7], and [18].
We present a uniﬁed approach by giving a ∧-interpretation of PAω as well as of
KPω and its ﬁnite type extension KPωω. For this purpose, it is adequate to work
in the negative fragment, i.e. in the {∃, ∨}free fragment of ﬁrst order logic. In this
fragment, stability is the one logical principle that extends intuitionistic to classical
logic. It is an elementary theorem of intuitionistic logic (cf [19]) that in intuitionis-
tic theories iTh stability of arbitrary negative, i.e. {∃, ∨}free formulae is derivable
from the stability of their atomic formulae:

242
Justus Diller
1.1 Stability lemma. For all negative formulae A in L(iTh)
iTh + {¬¬P →P | P atomic } ⊢¬¬A →A
The intuitionistic functional theories that we refer to are G¨odel’s theory T (cf. [11],
[10], [17], [14]) and its extension T∧by a bounded universal quantiﬁer ∀x < t
(cf.[9]) on the one hand and Burr’s theory T∈of constructive set functionals (cf.
[3], [8]) on the other.
These theories do not contain unbounded quantiﬁers. We choose formulations of
T (as in [10] and [14]) and T∧in the negative fragment. The language of T∈(cf.
[3]) is the closure of its Δ0-language - which in turn is the closure of the type o
equations of L(T∈) and ⊥under ∧, ∨, →, ∀x ∈t and ∃x ∈t - and its equations of
higher type under ∧, →, and ∀x ∈t.
1.2 Deﬁnition of classical functional theories T c, T c
∧, T c
∈. Let
Stab(=) ≡{¬¬a = b →a = b | a, b terms of the same type }
For FT one of the theories T, T∧or T∈, the classical version FT c of FT is
FT c :≡FT + Stab(=)
1.3 Lemma. For FT any of T, T∧, T∈, FT c satisﬁes stability in general:
FT c ⊢¬¬A →A
for all formulae
A ∈L(FT c)
Proof. For T and T∧, the lemma is an immediate consequence of the stability
lemma 1.1, because the atomic formulae of L(T) and L(T∧) are, besides ⊥, only
equations. In T∈, any Δ0-formula A is equivalent to an equation {0 | A} = 1
by explicit Δ0-separation (cf. [3],[8], and proposition 3.1 below). Therefore, any
formula of L(T∈) is in T∈equivalent to a negative formula, and by the stability
lemma, the lemma follows.
Since the type o fragments T0 of T and T∧0 of T∧prove Stab(=) within their re-
spective language, T0 and T∧0 are themselves already classical functional theories;
we have T c
0 ≡T0 and T c
∧0 ≡T∧0. This does not hold for T∈0.
1.4 Theories of classical arithmetic and set theory. We identify Peano arithmetic
PA with the negative fragment of Heyting arithmetic HA. Similarly, Peano arith-
metic in all ﬁnite types PAω is the natural span of PA and T c
∧. It is deﬁned as
the negative fragment of HAω, extended by the schema Stab(=), and with the
bounded universal quantiﬁer ∀x < t restricted to L(T∧). Its type o fragment PAω
0 ,
like T∧0, does not need Stab(=) as an axiom.
Let KPω (cf. [2]) be formulated in the negative fragment of the language of set

Functional Interpretations of Classical Systems
243
theory. Its ﬁnite type version KPωω is the natural span of KPω and T c
∈, also
formulated in the negative fragment: its language is the closure of the negative
fragment of L(T∈) under ∧, →and ∀xτ for all types τ; its axioms and rules are
the axioms of KPω and of T c
∈, the rule of transﬁnite induction extended to the full
language, and the rule of type-extensionality T-EXT with side formulae restricted
to L(T∈) (weak extensionality). (Because of the rule T-EXT, KPωω violates the
deduction theorem.)
These classical theories are to be ∧-interpreted and - if possible - Dialectica in-
terpreted in the functional theories mentioned in 1.2. We attempt a simultaneous
deﬁnition of functional translation and interpretation for the arithmetical as well as
for the set-theoretic case.
1.5 Convention. For the remaining part of this section, let Th stand alternatively
for PAω or KPωω or their subtheories, FT for a functional theory, T∧∈for T∧or
T∈, ∀x <∈t for ∀x < t or ∀x ∈t, and I for D or ∧.
1.6 Recursive deﬁnition of the I-translation on Th. To any formula A ∈L(Th),
I assigns an expression AI ≡∃v∀wAI[v, w] with AI[v, w] a formula of L(FT)
and disjoint tuples of variables v, w not occurring free in A, as follows:
L(T)D
AD ≡A for A ∈L(T)
L(T∧∈)I AI ≡A for A ∈L(T∧∈)
otherwise
Let AI be as above and BI ≡∃y∀zBI[y, z]; then
(∧)I
(A ∧B)I
≡∃vy∀wz(AI[v, w] ∧BI[y, z])
(→)D (A →B)D ≡∃WY ∀vz(AD[v, Wvz] →BD[Y v, z])
(→)∧(A →B)∧≡∃XWY ∀vz(∀x <∈Xvz A∧[v, Wxvz] →B∧[Y v, z])
in case the tuple w is not empty
(→)∧
0 (A →B)∧≡∃Y ∀vz(A∧[v] →B∧[Y v, z]) for empty w
(∀)I
(∀uA[u])I ≡∃V ∀uwAI[u, V u, w]
So, for D, the deﬁnition for the set theoretic case is identical with the one for the
arithmetical case, with the (unavoidable) exception of the starting clause. For ∧, the
set theoretic case is generated from the arithmetical case by simply writing ∀x ∈t
for ∀x < t and thus substituting T∈for T∧. If, for ∧, closure of L(Th) under
∀x <∈t is preferred - which is not necessary, but occasionally useful - , a clause
(∀<∈)∧
(∀x <∈t A[x])∧≡∃V ∀w(∀x <∈t A∧[x, V x, w])
has to be added to the deﬁnition. - The Dialectica translation D is obtained from the
∧-translation by writing D for ∧and by cancelling, in (→)∧, the bounded universal
quantiﬁer ∀x <∈Xvz and the variables X and x.

244
Justus Diller
1.7 Deﬁnition. The functional translation I is a functional interpretation of a
theory Th in a functional theory FT, we write
Th
I→FT,
if for Th ⊢A and AI ≡∃v∀wAI[v, w], there is a tuple of terms b of L(FT) (with
variables among the variables free in A) such that
FT ⊢AI[b, w]
In this case, A is called I-interpretable in FT, and the terms b are called (a tuple
of) I-interpreting terms of A.
1.8 Negative version. Expressions AI ≡∃v∀wAI[v, w] are, for non-empty tuple
v, not in the negative fragment of a language. The formula A−is the negative
version of A, if A−is obtained from A by replacing any non-empty tuple of quan-
tiﬁers ∃v in A by ¬∀v¬ and any disjunction B ∨C in A by ¬(¬B ∧¬C) . Then
AI−is a formula of L(Th), if A is.
1.9 Characterization problem. A class Γ of formulae of L(Th) which does not
refer to I is said to characterize I on the basis of Th, if
Th + Γ ≡Th + {A ↔AI−| A ∈L(Th)}
The characterization problem for I is the task to ﬁnd a suitable class of additional
axioms Γ characterizing I. The problem is independent of the I-interpretability of
Th, and it may have different solutions for a theory Th in all ﬁnite types and its
type o fragment.
We look at common features of characterization problems for ∧and D.
In intuitionistic theories, for quantiﬁer free A, the I-translation of ∀x∃yA[x, y] is
∃Y ∀xA[x, Y x], for I = D as well as for I = ∧. Thus,
B →BI with B ≡∀x∃y A[x, y]
is an axiom of choice with qf matrix A for both I in question. Combining these
translations with the negative version complicates the situation.
1.10 Axioms of choice in classical context. For A in L(T) or in L(T∈), respec-
tively, and non-empty tuples x, y of variables of arbitrary type, let
(qf −AC)
∀x¬∀y¬A[x, y] →¬∀Y ¬∀x A[x, Y x]
which is (AC)−with quantiﬁer free matrix A.

Functional Interpretations of Classical Systems
245
Up to a double negation which is irrelevant in Th due to the stability lemma,
(qf −AC) is of the form
B →BD−with B ≡(∀x∃y A[x, y])−
Similarly, for A in L(T∧∈) and tuples x, y as above, let
(qf −ARC)
∀x¬∀y¬A[x, y] →¬∀S, Y ¬∀x¬∀s <∈Sx ¬A[x, Y sx]
This quantiﬁer free axiom of restricting choice is literally of the form
B →B∧−with B ≡(∀x∃y A[x, y])−
We therefore put
(qf −ACD) :≡(qf −AC) and (qf −AC∧) :≡(qf −ARC)
and let (qf −ACI) refer to either.
1.11 Lemma. For A, B, A[u] negative, u a - possibly empty - tuple of variables,
Th proves:
1. AI−↔A for A in L(FT)
2. (A ∧B)I−↔AI−∧BI−
3. (A →B)I−→AI−→BI−
4. (∀u¬A[u])I−→∀u¬(A[u])I−; furthermore
5. Th + (qf −ACI) ⊢∀u¬(A[u])I−→(∀u¬A[u])I−
Proof. 1. to 3. are straightforward.
4.: For A[u]I ≡∃v∀w AI[u, v, w], we have
(∀u¬A[u])D−≡(∃W∀uv¬AD[u, v, Wuv])−and
(∀u¬A[u])∧−≡(∃XW∀uv¬∀x <∈Xuv A∧[u, v, Wxuv])−
Either formula implies
(1)
(∀uv∃w¬AI[u, v, w])−
which up to two double negations is ∀u¬(A[u])I−.
5.: By (qf −ACI), (1) implies for I = D
(∃W∀uv¬AD[u, v, Wuv])−≡(∀u¬A[u])D−

246
Justus Diller
and for I = ∧
(∃XW∀uv∃x <∈Xuv¬A∧[u, v, Wxuv])−
which up to a double negation is (∀u¬A[u])∧−.
1.12 Deﬁnition. A formula B ∈L(Th) is prenex, if
B ≡∀u1¬...∀un¬C[u1, ..., un]
with n ≥0, - possibly empty - tuples u1, ..., un of variables, and
C[u1, ..., un] ∈L(T∧∈).
For the Dialectica-translation D, the following result goes back to [12].
1.13 Relative characterization theorems
Th + (qf −ACI) ≡Th + {B ↔BI−| B prenex}
If Th is I-interpretable in FT, then
Th + (qf −ACI) ≡Th + {A ↔AI−}
Proof. Let B ≡∀u1¬...∀un¬C[u1, ..., un] be prenex. Then
Th + (qf −ACI) ⊢B ↔BI
follows by 1. and n applications of 4. and 5. in Lemma 1.11.
Conversely, the schema (qf −ACI), as mentioned in 1.10, is a set of formulae
B →BI−with prenex B.
Let Th be I-interpretable, and for a given formula A of L(Th), let B be a prenex
normal form of A. Then
Th ⊢A ↔B . Therefore, by I-interpretability of Th,
Th ⊢(A ↔B)I−, which by 2. and 3. in 1.11 implies
Th ⊢AI−↔BI−, and, as already shown,
Th + (qf −ACI) ⊢B ↔BI−
Putting the ﬁrst, the fourth, and the third of these equivalences together, we obtain
Th + (qf −ACI) ⊢A ↔AI−.

Functional Interpretations of Classical Systems
247
2 Interpretations of classical arithmetical theories
G¨odel’s Dialectica interpretation of HA in T0, HA
D
→T0 , which in fact is also
a Dialectica interpretation of HAω
0 in T0, automatically yields Dialectica interpre-
tations of Peano arithmetic PA and of PAω
0 as subsystems of HA and of HAω
0
respectively:
2.1 Dialectica interpretation theorems
PA
D
→T0
and
PAω
0
D
→T0
The Dialectica interpretation does not extend to PAω, as the following example
shows.
2.2 Example, communicated by W. A. Howard
(1)
PAω ⊢(∀u1∃yo(yo = 0 ↔u1 = 01))−,
a form of excluded middle for the equation u1 = 01.
Modulo a double negation, the formula (1) is Dialectica translated into
∃Y ∀u1 (Y u1 = 0 ↔u1 = 01)
However, there is no functional Y : 1 →o in T for which
(2)
T c ⊢Y u1 = 0 ↔u1 = 01
This follows from the fact that the functionals Y : 1 →o in T are continuous, i.e.
for each u1, Y u1 depends only on ﬁnitely many values of u1, and solutions Y of
(2) are not continuous (cf. [17]).
On the other hand, the formula (1) is ∧-translated as
∃XY ¬∀x < Xu1¬(Y u1x = 0 ↔u1 = 01),
and since
(3)
T∧⊢¬∀y < 2 ¬(y = 0 ↔u1 = 01),
the functionals X = λu1.2 and Y = λu1x.x are ∧-interpreting terms for (1).
Since Stab(=) is its own ∧-translation and HAω, even HAω + {A ↔A∧} is
∧-interpretable in T∧(cf. [9]), we have:
2.3 ∧-interpretation theorems
PAω
∧
→T c
∧,
even
HAω + {A ↔A∧} + Stab(=)
∧
→T c
∧
The last statement does not transfer to PAω, because I-interpretability of A in
T∧does not imply I-interpretability of A−in T c
∧. It is, however, easily seen by

248
Justus Diller
induction on deductions:
2.4 Lemma
HAω + Stab(=) ⊢A
implies
PAω ⊢A−
The ∧-interpretation theorem 2.3 and the relative characterization theorem 1.13
yield as an immediate corollary:
2.5 Characterization theorem for the ∧-translation on PAω
PAω + (qf −ARC) ≡PAω + {A ↔A∧−}
Any negative formula ∧-interpretable in T c
∧is derivable in PAω + (qf −ARC).
Proof of the second statement. Let A be ∧-interpretable in T c
∧. Then A∧is derivable
in HAω + Stab(=), and by lemma 2.4, A∧−is derivable in PAω. Thus, together
with A∧−↔A, A is derivable in PAω + (qf −ARC).
2.6 Extended ∧-interpretation theorem
PAω + (qf −ARC)
∧
→T c
∧
Proof. In addition to the interpretation theorem 2.3, we only have to show that
(qf −ARC) is ∧-interpretable in T c
∧. However, (qf −ARC) is an instance of
B →B∧−, as pointed out in 1.10. So, it sufﬁces to ∧-interpret B →B∧−in T c
∧
for arbitrary negative B.
Let B∧≡∃v∀w B∧[v, w]. Then, after a change of bound variables,
B∧−≡¬∀y¬∀z B∧[y, z],
B∧−∧≡∃TY ∀SZ (∃t < TSZ ∀s < S(Y tSZ) B∧[Y tSZ, Zs(Y tSZ)])−,
and ﬁnally
(B →B∧−)∧≡∃XWTY ∀vSZ (∀x < XvSZ B∧[v, WxvSZ] →
∃t < TvSZ∀s < S(Y tvSZ) B∧[Y tvSZ, Zs(Y tvSZ)])−
∧-interpreting functionals X, W, T, Y are given by
Y tvSZ = v, TvSZ = 1, WxvSZ = Zxv, XvSZ = Sv
The matrix (B →B∧−)∧then reduces to
∀x < Sv B∧[v, Zxv] →∀s < Sv B∧[v, Zsv]
which is a tautology in T∧.
Corresponding results also hold for the Dialectica interpretation of PAω
0 , because
D may be viewed as a more efﬁcient formulation of ∧, if restricted to PAω
0 :

Functional Interpretations of Classical Systems
249
2.7 Proposition. For A ∈L(PAω
0 )
PAω
0 ⊢AD−↔A∧−
On the basis of PAω
0 , the schemata (qf −AC) and (qf −ARC) are equivalent.
Proof. The equivalence in the ﬁrst statement is the negative version of the equiva-
lence
HAω
0 ⊢AD ↔A∧
shown in [9]. Therefore, the statement follows by lemma 2.4, restricted to type o
language, because, following [13], HAω is a conservative extension of HAω
0 .
The second statement follows from the ﬁrst, because, as remarked in 1.10, axioms
(qf −AC) and (qf −ARC) are of the form B →BD−and B →B∧−respec-
tively, for the same B.
As corollaries to the characterization theorem 2.5 and the extended interpretation
theorem 2.6, this proposition implies:
2.8 Characterization and extended interpretation theorem for the Dialectica
translation
(1) On the basis of PAω
0 , the schemata (qf −AC) and {A ↔AD−} are equiva-
lent:
PAω
0 + (qf −AC) ≡PAω
0 + {A ↔AD−}
(2) Negative formulae D-interpretable in T0 are derivable in PAω
0 + (qf −AC).
(3)
PAω
0 + (qf −AC)
D
→T0
Proof. (1) follows from the characterization theorem 2.5 by restricting the language
of PAω to its type o fragment and applying proposition 2.7. By the same argument,
(2) follow from the second statement in 2.5.
To prove (3), only a D-interpretation of (qf −AC) must be added to theorem 2.1.
(qf −AC) is of the form B →BD−, and that is D-interpreted as follows:
Let BD ≡∃v∀wBD[v, w] and BD−≡¬∀y¬∀zBD[y, z]. Then
BD−D ≡∃Y ∀Z¬¬BD[Y Z, Z(Y Z)]
and ﬁnally
(B →BD−)D ≡∃WY ∀vZ(BD[v, WvZ] →¬¬BD[Y vZ, Z(Y vZ)])
D-interpreting functionals W, Y are now given by Y vZ = v and WvZ = Zv.
These can also be extracted from the ∧-interpretation of (qf −ARC).

250
Justus Diller
These results complete the discussion of the Dialectica interpretation of PAω
0 and
its characterization. Concerning the relation of the translations D and ∧on PAω
proper, some details remain to be settled, some rest unsolved.
2.9 Proposition. Let (qf −AC)0 denote the schema (qf −AC), restricted to
formulae of type o.
(1)
PAω + (qf −AC) ⊢(qf −ARC)
(2)
PAω + (qf −ARC) ⊢(qf −AC)0
(3)
PAω ̸⊢(qf −AC)0
(4)
PAω ̸⊢(qf −ARC)
(5) PAω + (qf −ARC) ⊢(qf −AC) iff (qf −AC) is ∧-interpretable in T c
∧.
Proof. (1) Clearly, (∃Y ′∀xA[x, Y ′x])−implies (∃S, Y ∀x∃s < SxA[x, Y sx])−,
simply by putting Sx = 1 and, given Y ′, Y sx = Y ′x. Therefore, any axiom
(qf −AC) implies the corresponding axiom (qf −ARC).
(2) is an immediate consequence of proposition 2.7.
(3) Let T denote Kleene’s T-predicate. For any numeral e,
∀x∃y Texy →∃Y ∀x Tex(Y x)
is an instance of (qf −AC)0. Now let e be an index of a total recursive function
which is not provably recursive in PAω. In the model NF of primitive recursive
functionals in normal form (cf. [17], there called CTNF), we have
NF ⊨∀x∃yTexy, but for no Y : NF ⊨∀xTex(Y x)
Therefore NF ̸⊨(qf −AC)0, and (3) follows, as NF is a model of PAω.
(4) is immediate from (2) and (3).
(5) is an application of the characterization theorem 2.5 (2) and the extended ∧-
interpretation theorem 2.6.
By (1) of this proposition, the sequence of theories
PAω + (qf −AC)
PAω + (qf −ARC)
PAω
is of decreasing strength, and by (4), the second theory is properly stronger than
the last. We conjecture that PAω + (qf −ARC) ̸⊢(qf −AC).
Due to the lack of a D-interpretation theorem for PAω, it remains an open problem
whether PAω + (qf −AC) ⊢A ↔AD for all A ∈L(PAω).
3 Interpretation of Kripke-Platek set theories
The theories T∈and T c
∈allow quite ﬂexible operations on sets. To a part, this is
due to explicit Δ0-separation in T∈:

Functional Interpretations of Classical Systems
251
3.1 Proposition, explicit Δ0-separation. To any Δ0-formula A and any term t : o
with x : o not in t, there exists a separation term {x ∈t | A[x]} such that
T∈⊢y ∈{x ∈t | A[x]} ↔y ∈t ∧A[y]
Any Δ0-formula A possesses a characteristic term {0 | A} = {x ∈1 | A} with x
not in A such that
T∈⊢0 ∈{0 | A} ↔{0 | A} = 1 ↔A
For a proof, see [3] or [8].
In analogy to the situation in T∧, a principle of induction holds in T∈which is the
essential technical tool for the ∧-interpretation of transﬁnite induction (T IND).
As an alternative to [3], we give a proof of this principle closely related to the proof
of the corresponding principle in T∧(Satz 1 in [9] ).
3.2 Proposition, generalized transﬁnite induction. Given a term X, a term tuple
W with variables a, u, x : o and a variable tuple z, all not in X, W, such that
(1)
T∈⊢∀u ∈a ∀x ∈Xaz B[u, Wxaz] →B[a, z]
Then
T∈⊢B[t, z]
for any term t : o.
Proof. Let TC{t} be the transitive closure of {t} and S := Finseq(TC{t}) the
set of ﬁnite sequences of elements from TC{t} (cf. [2] and [3]). By simultaneous
ω-recursion on S, we deﬁne a term tuple X1, Z by
Zy⟨⟩= z
Z⟨x, y⟩⟨s, u⟩= Wxa(Zys)
X1⟨⟩= 1
X1⟨s, u⟩
= {⟨x, y⟩| x ∈Xa(Zys), y ∈X1s}
Assuming a ∈TC{t}, s ∈S, we have
(2) ∀u ∈a(∀y ∈X1⟨s, u⟩B[u, Zy⟨s, u⟩] ↔
∀y ∈X1s ∀x ∈Xa(Zys) B[u, Wxa(Zys)])
(1), with Zys substituted for z, may be rewritten under this equivalence as
∀u ∈a∀y ∈X1⟨s, u⟩B[u, Zy⟨s, u⟩] →∀y ∈X1s B[a, Zys]
After distribution of a ∈TC{t} and ∀s ∈S over this implication, (T IND)
yields
T∈⊢t ∈TC{t} →∀s ∈S∀y ∈X1s B[t, Zys]
For s = ⟨⟩, this implies T∈⊢B[t, z], as was to be shown.

252
Justus Diller
Propositions 3.1 and 3.2 are derivability results within the constructive functional
theory T∈, independent of Stab(=). We now turn to the problem of functional
interpretability of KPω and KPωω in T c
∈.
3.3 Proposition. Already the type o theory KPω is not Dialectica interpretable in
T c
∈.
Proof by example. KPω (with a constant 0 for the empty set) proves
∀x(∀y ¬y ∈x →x = 0)
This has the D-translation
∃Y ∀x(¬Y x ∈x →x = 0)
Any Y satisfying this formula is necessarily a classical choice functional which is
not a constructive set functional.
However, the ∧-translation of this formula is
∃ZY ∀x (∀z ∈Zx ¬Y z ∈x →x = 0),
and ∧-interpreting functionals Z, Y are given by Zx = x and Y z = z.
Here we made use of a simpliﬁcation of the ∧-translation which will be useful later,
too:
3.4 Lemma. A formula ∀y A[y] →B with A, B in L(T∈), y : o may be ∧-
translated as
∃Y (∀y ∈Y A[y] →B)
Proof. (∀y A[y] →B)∧is literally ∃XY ′(∀x ∈X A[Y ′x] →B). Y is obtained
from X, Y ′ by Y = {Y ′x | x ∈X}, and X, Y ′ are obtained from Y by X = Y
and Y ′x = x. Moreover, in the translation of longer formulae, the tuple of variables
X, Y ′ and the variable Y are handled in exactly the same way.
3.5 ∧-interpretation theorem for KPωω
KPωω is ∧-interpretable in T c
∈:
KPωω
∧
→T c
∈
Proof by induction on deductions. KPωω, including its Δ0-sublanguage, is for-
mulated in the negative fragment of ﬁrst order logic. The ∧-interpretation of the
axioms and rules of this fragment, including identity, may be taken over from [9],
replacing < by ∈. Results from T∧which are used there have to be transferred to
T∈. That, however, is easily done, in particular by exploiting explicit Δ0-separation

Functional Interpretations of Classical Systems
253
3.1 (cf [3] and [8]).
Stab(=), type extensionality (T-EXT), with side formulae restricted to L(T∈),
as well as the axiom of set-extensionality (ext), written as a Δ0-formula, are all
interpreted by the empty tuple.
(Δ0-separation)
¬∀b¬∀x(x ∈b ↔x ∈t ∧A[x])
for all Δ0-formulae A[x] and terms t : o with b not in A[x] and b, x not in t.
The part of this axiom following ∀b may be rewritten as a Δ0-formula. Hence, by
lemma 3.4, the axiom may be ∧-translated as
∃Y ¬∀b ∈Y ¬∀x(x ∈b ↔x ∈t ∧A[x])
By explicit Δ0-separation 3.1, the only relevant b ∈Y is the separation term {x ∈
t | A[x]}, and the singleton of this separation term is a ∧-interpreting term Y.
Axioms (Pair), (Union), (Infinity) are interpreted analogously, making use of
the set functionals available in T∈(cf. [3]).
(Δ0-collection) ∀x ∈a ¬∀y¬A[x, y] →¬∀z¬∀x ∈a∃y ∈z A[x, y]
for Δ0-formulae A[x, y]
The ∧-translation of this formula is, using lemma 3.4,
∃Z∀Y (∀x ∈a ∃y ∈Y x A[x, y] →∃z ∈ZY ∀x ∈a ∃y ∈z A[x, y])−
Given Y satisfying the antecedent, there is one canonical z satisfying the conse-
quent, namely z = {Y x | x ∈a}. The implication (Δ0-collection) is therefore
∧-interpreted by the term Z with the value ZY = {{Y x | x ∈a}}.
(T IND) ∀u ∈a F[u] →F[a] ⊢F[t]
By I.H., there are terms and term tuples X, W, Y0 such that
(3)
T c
∈⊢∀x ∈Xavz ∀u ∈a F∧[u, vu, Wxavz] →F∧[a, Y0va, z]
We deﬁne terms Y by simultaneous transﬁnite recursion
Y a = Y0(Y ↾a)a,
substitute Y ↾a for v in (3), and obtain
T c
∈⊢∀x ∈Xa(Y ↾a)z ∀u ∈a F∧[u, Y u, Wxa(Y ↾a)z] →F∧[a, Y a, z]
Here, the terms Xa(Y
↾a)z,
Wxa(Y
↾a)z are terms X′az, W ′xaz, and
F∧[a, Y a, z] is a formula B[a, z] satisfying (1) in proposition 3.2. So, by gen-
eralized transﬁnite induction, F∧[t, Y t, z] follows.
This completes the proof of the ∧-interpretation theorem. For related proofs using,
however, different translations, cf. [3], [4], [15]. An immediate consequence is:

254
Justus Diller
3.6 Corollary, conservativity and relative consistency. KPωω is a conservative
extension of T c
∈. The consistency of T c
∈implies the consistency of KPωω.
The characterization problem for the ∧-translation on KPωω is solved by theorem
1.13:
3.7 Characterization theorem
KPωω + (qf −ARC) ≡KPωω + {A ↔A∧−}
KPωω + (qf −ARC) proves any negative formula ∧-interpretable in T c
∈.
It may be conjectured that KPωω + (qf −ARC) ̸⊢(qf −AC) and that therefore
(qf −AC) is not ∧-interpretable in T c
∈. On the other hand, a ∧-interpretation
of (qf −ARC) in T c
∈is obtained by simply substituting ∈for < in the proof of
theorem 2.6:
3.8 Extended ∧-interpretation theorem for KPωω + (qf −ARC)
KPωω + (qf −ARC)
∧
→T c
∈
References
[1] Avigad, J., and S. Feferman: G¨odel’s functional (’Dialectica’) interpretation, in: S. Buss
(Ed.), Handbook of Proof Theory, Studies in Logic and the Foundations of Mathematics,
Vol. 137, Elsevier, Amsterdam 1998, 337 - 406.
[2] Barwise, J.: Admissible Sets and Structures, Springer-Verlag, Berlin Heidelberg New
York 1975.
[3] Burr, W.: Functional interpretation of Aczel’s constructive set theory, APAL 104 (2000)
31 - 73.
[4] Burr, W.: A Diller-Nahm-style functional interpretation of KPω, Arch. Math. Logic 39
(2000) 599 - 604.
[5] Burr, W.: Concepts and aims of functional interpretations: Towards a functional inter-
pretation of constructive set theory, Synthese 133 (2002) 257 - 274.
[6] Burr, W., and V. Hartung: A characterization of Σ1-deﬁnable functions of KPω +
(uniformAC), Arch. Math. Logic 37 (1998) 199 - 214.
[7] Diller, J.: Logical problems of functional interpretations, APAL 114 (2002) 27 - 42.
[8] Diller, J.: Functional interpretations of constructive set theory in all ﬁnite types. Dialec-
tica 62 (2008) 149 - 177.
[9] Diller, J., and W. Nahm: Eine Variante zur Dialectica-Interpretation der Heyting-
Arithmetik endlicher Typen, Arch. Math. Logik Grundl. 16 (1974) 49 - 66.
[10] Diller, J., and K. Sch¨utte: Simultane Rekursionen in der Theorie der Funktionale

Functional Interpretations of Classical Systems
255
endlicher Typen, Arch. Math. Logik Grundl. 14 (1971) 69 - 74.
[11] G¨odel, K.: ¨Uber eine bisher noch nicht ben¨utzte Erweiterung des ﬁniten Standpunktes,
Dialectica 12 (1958) 280 - 287.
[12] Kreisel, G.: Interpretation of analysis by means of constructive functionals of ﬁnite
type, in: A. Heyting (Ed.), Constructivity in Mathematics, North Holland Publ. Co., Ams-
terdam 1959, 101 - 128.
[13] Rath, P.:
Eine verallgemeinerte Funktionalinterpretation der Heyting-Arithmetik
endlicher Typen, Ph.D. thesis, University of M¨unster, 1978.
[14] Sch¨utte, K.: Proof Theory, Springer-Verlag, Heidelberg/New York 1977.
[15] Schulte, D.: Hybrids of the ×-translation for CZF ω, J. Applied Logic 6 (2008) 443 -
458.
[16] Shoenﬁeld, J.R.: Mathematical Logic, Addison-Wesley Publ. Comp., Reading, MA,
1967.
[17] Troelstra, A.S.: Metamathematical investigation of intuitionistic arithmetic and analy-
sis, Lecture Notes in Mathematics 344, Springer, Heidelberg/New York 1973.
[18] Troelstra, A.S.: Introductory Note to 1958 and 1972, in: K. G¨odel, Collected Works,
vol. II, Publications 1938 - 1974, S. Feferman (Ed.), The Clarendon Press, Oxford Univer-
sity Press, New York 1990.
[19] Troelstra, A.S., and D. van Dalen: Constructivism in Mathematics, Vol. I, North Hol-
land, Amsterdam 1988.


Towards a Formal Theory of Computability
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
Mathematisches Institut
Ludwig-Maximilians-Universit¨at M¨unchen
Theresienstr. 39, D-80333 M¨unchen, Germany
shuber@math.lmu.de
karadais@math.lmu.de
schwicht@math.lmu.de
Abstract We sketch a constructive formal theory TCF+ of computable
functionals, based on the partial continuous functionals as their intended do-
main. Such a task had long ago been started by Dana Scott [12, 15], under
the well-known abbreviation LCF (logic of computable functionals). The
present approach differs from Scott’s in two aspects.
(i) The intended semantical domains for the base types are non-ﬂat free
algebras, given by their constructors, where the latter are injective and
have disjoint ranges; both properties do not hold in the ﬂat case.
(ii) TCF+ has the facility to argue not only about the functionals them-
selves, but also about their ﬁnite approximations.
In this setting we give an informal proof (based on Berger [2]) of Kreisel’s
density theorem [7], and an adaption of Plotkin’s deﬁnability theorem [10,
11]. We then show that both proofs can be formalized in TCF+.
The naive model of a ﬁnitely typed theory like TCF+ is the full set theoretic
hierarchy of functionals of ﬁnite types. However, this immediately leads to higher
cardinalities, and does not lend itself well for a constructive theory of computabil-
ity. A more appropriate semantics for typed languages has its roots in work of
Kreisel [7] (where formal neighborhoods are used) and Kleene [6]. This line of
research was developed in a mathematically more satisfactory way by Scott [13]
and Ershov [3]. Today this theory is usually presented in the context of abstract
domain theory (see [1, 16]); it is based on classical logic. The present work can
be seen as an attempt to develop a constructive theory of formal neighborhoods for
continuous functionals, in a direct and intuitive style. The task is to replace abstract
domain theory by a more concrete, ﬁnitary theory of representations. As a frame-
work we use Scott’s information systems (see [8, 14, 16]). In this setup the basic
notion is that of a “token”, or unit of information. The elements or points of the

258
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
domain appear as abstract or “ideal” entities: possibly inﬁnite sets of tokens, which
are “consistent” and “deductively closed”.
The paper is organized as follows. Section 1 collects basic facts about informa-
tion systems, and section 2 contains informal proofs of the density and deﬁnability
theorems for the case of the non-ﬂat natural numbers, in enough detail to guide the
formalization. Section 3 develops the language and axioms of the theory TCF+.
The formalization of both theorems in TCF+ is discussed in section 4.
1 Partial Continuous Functionals
1.1 Information systems
The basic idea of information systems is to provide an axiomatic setting to describe
approximations of abstract objects (like functions or functionals) by concrete, ﬁnite
ones. The axioms below are a minor modiﬁcation of Scott’s [14], due to Larsen and
Winskel [8].
An information system is a structure (A, Con, ⊢) where A is a countable set (the
tokens), Con is a nonempty set of ﬁnite subsets of A (the consistent sets) and ⊢is
a subset of Con × A (the entailment relation), which satisfy
U ⊆V ∈Con →U ∈Con,
{a} ∈Con,
U ⊢a →U ∪{a} ∈Con,
a ∈U ∈Con →U ⊢a,
U, V ∈Con →∀a∈V (U ⊢a) →V ⊢b →U ⊢b.
The elements U of Con are called formal neighborhoods. We use U, V, W to denote
ﬁnite sets, and write
U ⊢V
for
U ∈Con ∧∀a∈V (U ⊢a),
a ↑b
for
{a, b} ∈Con
(a, b are consistent),
U ↑V
for
∀a∈U,b∈V (a ↑b).
The ideals (also called objects) of an information system A = (A, Con, ⊢) are
deﬁned to be those subsets x of A which satisfy
U ⊆x →U ∈Con
(x is consistent),
x ⊇U ⊢a →a ∈x
(x is deductively closed).
For example the deductive closure U := { a | U ⊢a } of U is an ideal. The set of
all ideals of A is denoted by |A|.

Towards a Formal Theory of Computability
259
•
0
•
S ∗
@
@
@
•
S 0

•
S(S ∗)
@
@
@
•
S(S 0)

•
S(S(S ∗))
@
@
@
•
S(S(S 0))


...
Figure 1: Tokens and entailment for N
Examples. Every countable set A can be turned into a ﬂat information system by
letting the set of tokens be A, Con := {∅} ∪{ {a} | a ∈A } and U ⊢a mean
a ∈U. In this case the ideals are just the elements of Con.
Consider the algebras B (booleans), N (natural numbers), P (positive numbers
written binary), D (derivations) given by the constructors
ttB, ffB
for B,
0N and SN→N (successor) for N,
1P, sP→P
0
(append 0) and sP→P
1
(append 1) for P,
0D (axiom) and CD→D→D (rule) for D.
For each of them we deﬁne an information system Cι = (Tokι, Conι, ⊢ι):
(a) The tokens a ∈Tokι are the constructor expressions Ca∗
1 . . . a∗
n where a∗
i is an
extended token, i.e., a token or the special symbol ∗which carries no informa-
tion.
(b) A ﬁnite set U of tokens in Tokι is consistent (i.e., ∈Conι) if its elements start
with the same n-ary constructor C, say U = {C ⃗a∗
1, . . . , C ⃗
a∗m}, and Ui ∈Conι
where Ui consists of the (proper) tokens among a∗
1i, . . . , a∗
mi.
(c) {C ⃗a∗
1, . . . , C ⃗
a∗m} ⊢ι C′ ⃗a∗is deﬁned to mean C = C′, m ≥1 and Ui ⊢a∗
i ,
with Ui as in (b) above (and U ⊢∗deﬁned to be true).
For example, the tokens for N are shown in Figure 1. For tokens a, b we have
{a} ⊢b if and only if there is a path from a (up) to b (down). In D, the set
{C0∗, C∗0} is consistent, and {C0∗, C∗0} ⊢C00.
A token is called total if it has the form C⃗a with a total token ai at every argument
position. For example, the total tokens for N are all Sn 0, and for D all ∗-free
constructor trees built from 0 and C.

260
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
By induction on the formation of tokens, one easily sees the following.
Lemma 1.1 (Comparability). If ι has at most unary constructors, then any two
consistent tokens a, b are comparable, i.e., {a} ⊢b or {b} ⊢a.
1.2 Function spaces
Let A = (A, ConA, ⊢A) and B = (B, ConB, ⊢B) be information systems. Deﬁne
the function space A →B = (C, Con, ⊢) by
C := ConA × B,
{ (Ui, bi) | i ∈I } ∈Con := ∀J⊆I(

j∈J
Uj ∈ConA →{ bj | j ∈J } ∈ConB).
For the deﬁnition of the entailment relation ⊢it is helpful to ﬁrst deﬁne the notion
of an application of W := { (Ui, bi) | i ∈I } ∈Con to U ∈ConA:
{ (Ui, bi) | i ∈I }U := { bi | U ⊢A Ui }.
From the deﬁnition of Con we know that this set is in ConB. Now deﬁne W ⊢
(U, b) by WU ⊢B b. Clearly application is monotone in the second argument, in
the sense that U ⊢A U ′ implies WU ′ ⊆WU, hence WU ⊢B WU ′. Application
is also monotone in the ﬁrst argument, i.e.,
W ⊢W ′
implies
WU ⊢B W ′U.
Using this one easily proves that A →B is an information system provided A and
B are.
For any information system A the set of all OU := { x ∈|A| | U ⊆x }
with U ∈Con forms the basis of a topology on |A|, the Scott topology. The
continuous functions (w.r.t. the Scott topology) from |A| to |B| are in a natural
bijective correspondence with the ideals of A →B:
(a) With any ideal r ∈|A →B| we can associate a continuous function
|r|: |A| →|B| by |r|z := { b ∈B | (U, b) ∈r for some U ⊆z }. We call
|r|z the application of r to z.
(b) Conversely, with any continuous function f : |A| →|B| we can associate an
ideal ˆf : A →B by ˆf := { (U, b) | b ∈f(U) }.
These assignments are inverse to each other, i.e., f = | ˆf| and r = '
|r|. We usually
write rz for |r|z, and similarly (U, b) ∈f for (U, b) ∈ˆf.

Towards a Formal Theory of Computability
261
Lemma 1.2 (Approximable maps [14]). Let A = (A, ConA, ⊢A) and B =
(B, ConB, ⊢B) be information systems. The ideals of A →B are exactly the
approximable maps from A to B, i.e., the relations r ⊆ConA × B with
(a) If (U, b1), . . . , (U, bn) ∈r, then {b1, . . . , bn} ∈ConB;
(b) If (U, b1), . . . , (U, bn) ∈r and {b1, . . . , bn} ⊢B b, then (U, b) ∈r;
(c) If (U ′, b) ∈r and U ⊢A U ′, then (U, b) ∈r.
Types are built from base types ι (the algebras above) by ρ →σ. For every type ρ
we deﬁne the information system Cρ = (Tokρ, Conρ, ⊢ρ) starting from the Cι by
formation of function spaces Cρ→σ := Cρ →Cσ. The set |Cρ| of ideals in Cρ is
the set of partial continuous functionals of type ρ. A partial continuous functional
x ∈|Cρ| is computable if it is recursively enumerable when viewed as a set of
tokens. The information systems Cρ enjoy the pleasant property of “coherence”,
which amounts to the possibility of locating inconsistencies in two-element sets of
data objects. Generally, an information system A = (A, Con, ⊢) is coherent if it
satisﬁes: U ⊆A is consistent if and only if all of its two-element subsets are.
It is easy to see that every constructor C generates a continuous function
rC := { (⃗U, C ⃗a∗) |
⃗U
⊢
⃗a∗} in the function space (where (⃗U, b) means
(U1, . . . (Un, b) . . . )), and that
|rC|⃗x ⊆|rC|⃗y ↔⃗x ⊆⃗y.
If C1, C2 are distinct constructors of ι, then |rC1|⃗x ̸= |rC2|⃗y, since the two ide-
als are non-empty and disjoint. Hence constructors are injective and have disjoint
ranges. Notice that neither property holds for ﬂat information systems, since for
them, by monotonicity, constructors need to be strict (i.e., if one argument is the
empty ideal, then the value is as well). But then
|rC|∅y = ∅= |rC|x∅,
|rC1|∅= ∅= |rC2|∅,
where C is a binary and C1, C2 are unary constructors.
2 Computable functionals
2.1 Terms and their denotational semantics
Terms are built from (typed) variables and (typed) constants (constructors C or
deﬁned constants D, see below) by application and abstraction:
M, N ::= xρ | Cρ | Dρ | (λxρMσ)ρ→σ | (Mρ→σNρ)σ.

262
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
Every deﬁned constant D comes with a system of computation rules, consisting
of ﬁnitely many equations D ⃗Pi(⃗yi) = Mi (i = 1, . . . , n) with free variables of
⃗Pi(⃗yi) and Mi among ⃗yi, where the ⃗Pi(⃗yi) must be “constructor patterns”, i.e.,
lists of applicative terms built from constructors and distinct variables, with each
constructor C occurring in a context C⃗P (of base type). We assume that ⃗Pi and ⃗Pj
for i ̸= j are non-uniﬁable. Examples are
(i) the predecessor function P: N →N deﬁned by the computation rules P0 =
0, P(S n) = n,
(ii) G¨odel’s primitive recursion operators Rτ
N : N →τ →(N →τ →τ) →τ
with computation rules R0fg = f, R(S n)fg = gn(Rnfg), and
(iii) the least-ﬁxed-point operators Yρ of type (ρ →ρ) →ρ deﬁned by the com-
putation rule Yρf = f(Yρf).
For every closed term λ⃗xM of type ⃗ρ →σ we inductively deﬁne a set [[λ⃗xM]] of
tokens of type ⃗ρ →σ.
Ui ⊢b
(⃗U, b) ∈[[λ⃗xxi]]
(V ),
(⃗U, V, c) ∈[[λ⃗xM]]
(⃗U, V ) ⊆[[λ⃗xN]]
(⃗U, c) ∈[[λ⃗x(MN)]]
(A).
For every constructor C and deﬁned constant D we have
⃗V ⊢⃗b∗
(⃗U, ⃗V , C⃗b∗) ∈[[λ⃗xC]]
(C),
(⃗U, ⃗V , b) ∈[[λ⃗x,⃗yM]]
⃗W ⊢⃗P(⃗V )
(⃗U, ⃗W, b) ∈[[λ⃗xD]]
(D),
with one such rule (D) for every computation rule D ⃗P(⃗y ) = M.
Here (⃗U, V ) ⊆[[λ⃗xM]] means (⃗U, b) ∈[[λ⃗xM]] for all (ﬁnitely many) b ∈V ,
and (⃗U, b) denotes (U1, . . . (Un, b) . . . ). For a constructor pattern ⃗P(⃗x ) and a list
⃗V of the same length and types as ⃗x, ⃗P(⃗V ) is a list of formal neighborhoods of the
same length and types as ⃗P(⃗x ): x(V ) is V , and
(C⃗P)(⃗V ) := { C⃗b∗| b∗
i ∈Pi(⃗Vi) if Pi(⃗Vi) ̸= ∅, and b∗
i = ∗otherwise }.
The height of a derivation of (⃗U, b) ∈[[λ⃗xM]] is deﬁned as usual, by adding 1 at
each rule. We deﬁne its D-height similarly, where only rules (D) count.
Theorem 2.1. (a) For every term M, [[λ⃗xM]] is an ideal.
(b) If a term M converts to M ′ by βη-conversion or application of a computation
rule, then its value is preserved, i.e., [[M]] = [[M ′]].

Towards a Formal Theory of Computability
263
For a term M with free variables among ⃗x and an assignment ⃗x →⃗u of ideals ⃗u
to ⃗x let [[M]]⃗u
⃗x := 
⃗U⊆⃗u[[M]]⃗U
⃗x with [[M]]⃗U
⃗x := { b | (⃗U, b) ∈[[λ⃗xM]] }. Notice that
a consequence of (A) is
c ∈[[MN]]⃗u
⃗x ↔∃V ⊆[[N]]⃗u
⃗x((V, c) ∈[[M]]⃗u
⃗x)
(continuity of application). (2.1)
Proposition 2.2. For every n > 0, there is a derivation of (W, b) ∈[[Y ]] with
D-height n if and only if W n∅⊢b.
Proof. Every derivation of (W, b) ∈[[Y ]] must have the form
ˆW ⊢(V, b)
( ˆW, V, b) ∈[[λff]]
( ˆW, Wi, bi) ∈[[λfY ]]
ˆW ⊢(Vij, bij)
( ˆW, Vij, bij) ∈[[λff]]
( ˆW, bi) ∈[[λf(Y f)]]
( ˆW, b) ∈[[λf(f(Y f))]]
(D), assuming W ⊢ˆW
(W, b) ∈[[Y ]]
with V := { bi | i ∈I }, Wi := { (Vij, bij) | j ∈Ii }.
“→”. By induction on the D-height. We have ( ˆW, Wi, bi) ∈[[λfY ]], ˆW ⊢Wi
and ˆW ⊢(V, b). By induction hypothesis W ni
i ∅⊢bi, and ˆW ni∅⊢W ni
i ∅by
monotonicity of application. Because of ˆW n+1∅⊢ˆW n∅(proved by induction on
n, using monotonicity) we obtain ˆW n∅⊢bi with n := max ni, i.e., ˆW n∅⊢V .
Recall that ˆW ⊢(V, b) was deﬁned to mean ˆWV ⊢b. Hence ˆW( ˆW n∅) ⊢b and
therefore W n+1∅⊢b.
“←”. By induction on n. Let W(W n∅) ⊢b, i.e., W ⊢(V, b) with V :=
W n∅=: { bi | i ∈I }. Then W n∅⊢bi, hence by induction hypothesis (W, bi) ∈
[[Y ]]. Substituting W for ˆW and all Wi in the derivation above gives the claim
(W, b) ∈[[Y ]].
Corollary 2.3. The ﬁxed point operator Y has the property
b ∈[[Y ]]w ↔∃k(b ∈wk+1∅).
(2.2)
Proof. Since wk+1∅for ﬁxed k is continuous in w, from b ∈wk+1∅we can infer
W k+1∅⊢b for some W ⊆w, and conversely. Moreover b ∈[[Y ]]w is equivalent
to (W, b) ∈[[Y ]] for some W ⊆w, by (A). Now apply the proposition.
2.2 Total functionals
We now single out the total continuous functionals from the partial ones. Our main
goal will be the density theorem, which says that every ﬁnite functional can be
extended to a total one.

264
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
The total ideals x of type ρ (notation x ∈Gρ) and the equivalence relation
x1 ≈x2 between them are deﬁned inductively.
(a) For an algebra ι, the total ideals x are those of the form C⃗z with C a constructor
of ι and ⃗z total (C denotes the continuous function |rC|). Two total ideals
x1, x2 are equivalent (written x1 ≈ι x2) if both are of the form C⃗zi with the
same constructor C of ι, and z1j ≈ι z2j for all j.
(b) An ideal r of type ρ →σ is total if and only if for all total z of type ρ, the
result |r|z of applying r to z is total. For f, g ∈Gρ→σ deﬁne f ≈ρ→σ g by
∀x∈Gρ(fx ≈σ gx).
We show that x ≈ρ y implies fx ≈σ fy, following Longo and Moggi [9].
Lemma 2.4 (Extension). If f ∈Gρ, g ∈|Cρ| and f ⊆g, then g ∈Gρ.
Proof. By induction on ρ. For base types ι use induction on the deﬁnition of f ∈
Gι. Case ρ →σ. Assume f ∈Gρ→σ and f ⊆g. We show g ∈Gρ→σ. So let
x ∈Gρ. We show gx ∈Gσ. But gx ⊇fx ∈Gσ, so the claim follows by the
induction hypothesis.
Lemma 2.5. (f1 ∩f2)x = f1x ∩f2x, for f1, f2 ∈|Cρ→σ| and x ∈|Cρ|.
Proof. By the deﬁnition of |r|,
|f1 ∩f2|x
= { b ∈Tokσ | ∃U⊆x((U, b) ∈f1 ∩f2) }
= { b ∈Tokσ | ∃U1⊆x((U1, b) ∈f1) } ∩{ b ∈Tokσ | ∃U2⊆x((U2, b) ∈f2) }
= |f1|x ∩|f2|x.
The part “⊆” of the middle equality is obvious. For “⊇”, let Ui ⊆x with (Ui, b) ∈
fi be given. Choose U = U1 ∪U2. Then clearly (U, b) ∈fi (as {(Ui, b)} ⊢(U, b)
and fi is deductively closed).
Lemma 2.6. f ≈ρ g if and only if f ∩g ∈Gρ, for f, g ∈Gρ.
Proof. By induction on ρ. For ι use induction on the deﬁnitions of f ≈ι g and Gι.
Case ρ →σ.
f ≈ρ→σ g ↔∀x∈Gρ(fx ≈σ gx)
↔∀x∈Gρ(fx ∩gx ∈Gσ)
by induction hypothesis
↔∀x∈Gρ((f ∩g)x ∈Gσ)
by the last lemma
↔f ∩g ∈Gρ→σ.

Towards a Formal Theory of Computability
265
Theorem 2.7. x ≈ρ y implies fx ≈σ fy, for x, y ∈Gρ and f ∈Gρ→σ.
Proof. Since x ≈ρ y we have x ∩y ∈Gρ by the previous lemma. Now fx, fy ⊇
f(x ∩y) and hence fx ∩fy ∈Gσ. But this implies fx ≈σ fy again by the
previous lemma.
We prove the density theorem, which says that every ﬁnitely generated functional
(i.e., every U with U ∈Conρ) can be extended to a total one. A type ρ is called
dense if
∀U∈Conρ∃x∈Gρ(U ⊆x)
(i.e., Gρ ⊆|Cρ| is dense w.r.t. the Scott topology), and separating if
∀U,V ∈Conρ(U ̸↑ρ V →∃⃗z∈G(U⃗z ̸↑ι V ⃗z )).
We prove that every type ρ is both dense and separating. Deﬁne the height |a∗| of
an extended token a∗, and |U| of a formal neighborhood U, by
|Ca∗
1 . . . a∗
n| := max{ |a∗
i | | i = 1, . . . , n } + 1,
| ∗| := 0,
|(U, b)| := max{|U|, |b|} + 1,
|{ ai | i ∈I }| := max{ |ai| + 1 | i ∈I }.
Remark 2.8. Let U ∈Conι be non-empty. Then every token in U starts with
the same constructor C. Let Ui consist of all tokens at the i-th argument position
of some token in U. Then C⃗U ⊢U (and also U ⊢C⃗U), and |Ui| < |U| (where
C⃗U := { C ⃗a∗| a∗
i ∈Ui if Ui ̸= ∅, and a∗
i = ∗otherwise }).
We write Gιa to mean that a is a total token (i.e., a constructor tree without ∗),
and GιU to mean that U contains a total token. For W = { (Ui, ai) | i < n } we
have Wx := { ai | Ui ⊆x }. Hence if x is decidable, then so is Wx.
Theorem 2.9 (Density). For every type ρ = ρ1 →. . . →ρp →ι we have decid-
able formulas TExtρ and Sepi
ρ (i = 1, . . . , p) such that
(a) ∀U∈Conρ(U ⊆{ a | TExtρ(U, a) } ∈Gρ) and
(b) ∀U,V ∈Conρ(U ̸↑ρ V →⃗zU,V ∈G ∧U⃗zU,V ̸↑ι V ⃗zU,V ), where ⃗zU,V =
zU,V,1, . . . , zU,V,p and zU,V,i = { a | Sepi
ρ(U, V, a) }.
Proof. By induction on ρ.
Case ι, (a). Given U ∈Conι we deﬁne a token aU by induction on the height
|U| such that {aU} ⊢U and GιaU. For U = ∅let aU be the nullary constructor
of ι. If U ̸= ∅, deﬁne Ui from U as in the remark above; then C⃗U ⊢U and |Ui| <

266
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
|U|. Hence for aU := CaU1 . . . aUn we have GιaU by induction hypothesis, and
{aU} ⊢C ⃗U ⊢U by the deﬁnition of entailment. So we can put TExtι(U, a) :=
({aU} ⊢a).
Case ι, (b). There is nothing to show.
Case ρ →σ, (a). Fix W = { (Ui, ai) | i < n } ∈Conρ→σ. Consider i < j < n
with ai ̸↑aj, thus Ui ̸↑Uj. By induction hypothesis (b) for ρ we have ⃗zij ∈G
such that Ui⃗zij ̸↑ι Uj⃗zij. Deﬁne for every U ∈Conρ a set IU of indices k < n
such that “U behaves as Uk with respect to the ⃗zij”:
IU := { k < n | ∀i<k(ai ̸↑ak →U⃗zik ⊢ι Uk⃗zik) ∧
∀j>k(ak ̸↑aj →U⃗zkj ⊢ι Uk⃗zkj) }.
Notice that k ∈IUk. We ﬁrst show
VU := { ak | k ∈IU } ∈Conσ.
It sufﬁces to prove ai ↑aj for i, j ∈IU with i < j. Since ai ↑aj is decidable
we can argue indirectly. Assume ai ̸↑aj. Then U⃗zij ⊢ι Uj⃗zij and U⃗zij ⊢ι Ui⃗zij,
thus Ui⃗zij ↑ι Uj⃗zij. But Ui⃗zij ̸↑ι Uj⃗zij by the choice of the ⃗zij for Ui ̸↑Uj.
By induction hypothesis (a) VU ⊆yVU := { a | TExtσ(VU, a) } ∈Gσ. Let
r := { (U, a) | (a ∈yVU ∧∀i,j<n(ai ̸↑aj →Gι(U⃗zij))) ∨VU ⊢a },
(2.3)
We claim W ⊆r ∈Gρ→σ; then we can deﬁne TExtρ→σ(W, (U, a)) to be the
deﬁning formula of r. Since k ∈IUk we have ak ∈VUk, thus (Uk, ak) ∈r. For
r ∈|Cρ→σ| we verify the properties of approximable maps.
First we show that (U, a) ∈r and (U, b) ∈r imply a ↑b. But from the premises
we obtain a, b ∈yVU and hence a ↑b.
Next we show that (U, b1), . . . , (U, bn) ∈r and {b1, . . . , bn} ⊢b imply (U, b) ∈
r. We argue by cases. If the left hand side of the disjunction in (2.3) holds for
one bk, then {b1, . . . , bn} ⊆yVU , hence b ∈yVU and thus (U, b) ∈r. Otherwise
VU ⊢{b1, . . . , bn} ⊢b and therefore (U, b) ∈r as well.
Finally we show that (U, a) ∈r and U ′ ⊢U imply (U ′, a) ∈r. We again argue
by cases. If the left hand side of the disjunction in (2.3) holds, we have a ∈yVU ,
and from U ′ ⊢U we obtain ∀i,j<n(ai ̸↑aj →Gι(U ′⃗zij)). We show a ∈yVU′ .
But U⃗zij and U ′⃗zij both contain a total token, for every i, j with ai ̸↑aj, which
must be the same since U′ ⊢U. Thus IU = IU′, hence VU = VU ′. Now assume
VU ⊢a. But U′ ⊢U implies IU ⊆IU ′, hence VU ⊆VU ′, hence VU ′ ⊢a and
therefore (U ′, a) ∈r.
It remains to prove r ∈Gρ→σ. Let x ∈Gρ. We show that rx ∈Gσ, i.e.,
{ a ∈Tokσ | ∃U⊆x((U, a) ∈r) } ∈Gσ.

Towards a Formal Theory of Computability
267
Recall ⃗zij ∈G for all i < j < n with ai ̸↑aj. Hence x⃗zij ∈Gι for all such i, j.
Since every total ideal of base type contains a total token we have Uij ⊆x with
Gι(Uij⃗zij). Let U be the union of all Uij’s. Then Gι(U⃗zij). Hence (U, a) ∈r for
all a ∈yVU , i.e., yVU ⊆rx and therefore rx ∈Gσ, by the Extension Lemma.
Case ρ →σ, (b). Let W1, W2 ∈Conρ→σ with W1 ̸↑W2. Pick (Ui, ai) ∈Wi
such that U1 ↑U2 and a1 ̸↑a2. By induction hypothesis (a) for ρ
U1 ∪U2 ⊆zU1,U2 := { a | TExtρ(U1 ∪U2, a) } ∈Gρ.
Then ai ∈WizU1,U2. From the induction hypothesis (b) for σ we obtain ⃗za1,a2 ∈G
such that
{a1}⃗za1,a2 ̸↑ι {a2}⃗za1,a2,
where σ = σ1 →. . . →σp →ι and za1,a2,i := { a | Sepi
σ({a1}, {a2}, a) } for
i = 1, . . . , p. Hence W1zU1,U2⃗za1,a2 ̸↑ι W2zU1,U2⃗za1,a2. Therefore
Sep1
ρ→σ(W1, W2, a) := TExtρ(U1 ∪U2, a),
Sepi+1
ρ→σ(W1, W2, a) := Sepi
σ({a1}, {a2}, a).
2.3 Deﬁnability
There will be two kinds of (natural) numbers: (i) total tokens in the algebra N, and
(ii) total ideals of type N. Recall that the total tokens in N are iterated applica-
tions of the successor constructor S to the zero constructor 0. We call them index
numbers and write n ∈N for the n-th such token. Then n is a total ideal of type N.
In the statement of the deﬁnability theorem below we will need ﬁxed enumera-
tions (en)n∈N of all tokens and (En)n∈N of all formal neighborhoods, one for each
type. We will also need some special computable functionals:
The parallel conditional pcond: B →ρ →ρ →ρ
It is deﬁned by the clauses
U ⊢tt →V ⊢a →(U, V, W, a) ∈pcond,
(2.4)
U ⊢ff →W ⊢a →(U, V, W, a) ∈pcond,
(2.5)
V ⊢a →W ⊢a →(U, V, W, a) ∈pcond.
(2.6)
We also need the least-ﬁxed-point axiom, which says that any set of tokens
(U, V, W, a) satisfying (2.4)–(2.6) is a superset of pcond. It is easy to see that
pcond is an ideal.

268
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
Lemma 2.10 (Properties of pcond).
tt ∈z →pcond(z, x, y) = x,
(2.7)
ff ∈z →pcond(z, x, y) = y,
(2.8)
a ∈x →a ∈y →a ∈pcond(z, x, y).
(2.9)
Proof. (2.7). Assume tt ∈z. “⊇”. Let a ∈x. We show a ∈pcond(z, x, y). It
sufﬁces to ﬁnd U ⊆z, V ⊆x and W ⊆y such that (U, V, W, a) ∈pcond. Since
({tt}, {a}, ∅, a) ∈pcond by (2.4) we can take {tt} for U, {a} for V and ∅for
W. “⊆”. Let a ∈pcond(z, x, y). We show a ∈x. By continuity of application
we have U ⊆z, V ⊆x and W ⊆y such that (U, V, W, a) ∈pcond. It sufﬁces
to show V ⊢a. This will follow from the rules for pcond, since (because of
tt ∈z) the token (U, V, W, a) must have entered pcond by clause (2.4) or (2.6).
Formally we make use of the least-ﬁxed-point axiom for pcond, and apply it to
C := { (U, V, W, a) | {tt} ⊢U →V ⊢a }. We show that C satisﬁes (2.4)–(2.6).
For (2.5) we must show
U ⊢ff →W ⊢a →{tt} ⊢U →V ⊢a.
This follows from ex-falso-quodlibet, since {tt} ⊢U and U ⊢ff implies {tt} ⊢ff,
a contradiction. (2.4) and (2.6) have the desired conclusion V ⊢a among their
premises. But now the least-ﬁxed-point axiom for pcond implies (U, V, W, a) ∈C
(since tt ∈z and U ⊆z imply {tt} ⊢U) and hence V ⊢a.
(2.8) is proved similarly. (2.9). It sufﬁces to have V ⊆x and W ⊆y such that
(∅, V, W, a) ∈pcond. Use (2.6) with {a} for V and W.
A continuous variant of the union for N
For ideals in the algebra N, the union (i.e., essentially the maximum) is not a
continuous function. However, there is a continuous variant ∪#, which refers in its
second argument to the ﬁxed enumeration of the tokens of type N. The type of ∪#
is N →N →N, and its deﬁning clauses are
U ⊢en →V ⊢n →U ⊢a →(U, V, a) ∈∪#,
(2.10)
{en} ⊢a →V ⊢n →(U, V, a) ∈∪#,
(2.11)
and again we require the least-ﬁxed-point axiom. It is easy to see that ∪# is an
ideal.
Lemma (Properties of ∪#).
∀a∈x(a ↑en) →x ∪# n = x ∪{en},
(2.12)
en ∈x ∪# n.
(2.13)

Towards a Formal Theory of Computability
269
Proof. (2.12). Assume a ↑en for all a ∈x.
“⊇”. Let a ∈x ∪{en}. We show a ∈x ∪# n. It sufﬁces to ﬁnd U ⊆x,
V ⊆n such that (U, V, a) ∈∪#. By the Comparability Lemma either a ⊢{en}
or {en} ⊢a. In the ﬁrst case take U = {a}, and in the second U = ∅. Then
(U, {n}, a) ∈∪# by (2.10) or (2.11), respectively.
“⊆”. Let a ∈x ∪# n. We show a ∈x ∪{en}. By continuity of application we
have U ⊆x and V ⊆n such that (U, V, a) ∈∪#. Let
C := (U, V, a)U ⊢a ∨∃k∈N({ek} ⊢a ∧V ⊢k).
C satisﬁes (2.10) and (2.11). Hence by the least-ﬁxed-point axiom for ∪# we have
(U, V, a) ∈C. If U ⊢a the claim is immediate, since U ⊆x. Otherwise we have
k ∈N such that {ek} ⊢a and V ⊢k. But V ⊆n implies k = n. Hence {en} ⊢a
and therefore a ∈{en}.
(2.13). Assume n ∈N. It sufﬁces to have U ⊆x and V ⊆n such that
(U, V, en) ∈∪#. Use (2.11) with en for a, ∅for U and {n} for V .
A continuous variant of consistency
We deﬁne ↑# of type ρ →N →B by the clauses
U ⊢En →V ⊢n →(U, V, tt) ∈↑#,
(2.14)
a ∈U →b ∈En →V ⊢n →a ̸↑b →(U, V, ff) ∈↑# .
(2.15)
Again we require the least-ﬁxed-point axiom; it is easy to see that ↑# is an ideal.
Lemma 2.11 (Properties of ↑#).
tt ∈x ↑# n ↔x ⊇En,
(2.16)
ff ∈x ↑# n ↔∃a∈x,b∈En(a ̸↑b).
(2.17)
Proof. (2.16). Let n ∈N. “→”. Assume tt ∈x ↑# n. We show x ⊇En. By
continuity of application we have U ⊆x and V ⊆n such that (U, V, tt) ∈↑#. Let
C be the predicate consisting of all (U, V, c) such that
(c = tt →∃k∈N(U ⊢Ek ∧V ⊢k)) ∧
(c = ff →∃a∈U,k∈N,b∈Ek(V ⊢k ∧a ̸↑b)).
C satisﬁes (2.14) and (2.15). Hence by the least-ﬁxed-point axiom for ↑# we have
(U, V, tt) ∈C, i.e., k ∈N such that U ⊢Ek and V ⊢k. Using V ⊆n we obtain
k = n. Now U ⊆x implies x ⊇En.

270
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
“←”. Assume x ⊇En. We show tt ∈x ↑# n. It sufﬁces to ﬁnd U ⊆x and
V ⊆n such that (U, V, tt) ∈↑#. Take En for U and {n} for V . Then (U, V, tt) ∈↑#
by (2.14).
(2.17) is proved similarly. For “→” we can use the same C, and for “←” use
(2.15) instead of (2.14).
Let ι have at most unary constructors, i.e., be one of N, B or P. A partial
continuous functional Φ of type ρ1 →· · · →ρp →ι is recursive in pcond, ∪#
and ↑# if it can be deﬁned explicitly by a term involving the constructors for ι and
N, the constants predecessor, the ﬁxed point operators Yρ, the parallel conditional
pcond and the continuous variants of union and of consistency.
Theorem 2.12 (Deﬁnability). A partial continuous functional is computable if and
only if it is recursive in pcond, ∪# and ↑#.
Proof. The fact that the constants are deﬁned by the rules above implies that the
ideals they denote are recursively enumerable. Hence every functional recursive
in pcond, ∪# and ↑# is computable. For the converse let Φ be computable of
type ρ1 →· · · →ρp →ι. Then Φ is a primitive recursively enumerated set of
tokens (Ef1n, . . . , Efpn, egn) where f1, . . . , fp and g are ﬁxed primitive recursive
functions on index numbers. Let f denote a continuous extension of f to ideals,
such that fn = fn. Such an f is obtained by reading f’s primitive recursion
equations as computation rules in the sense of 2.1.
Let ⃗ϕ = ϕ1, . . . , ϕp be arbitrary continuous functionals of types ρ1, . . . , ρp,
respectively. We show that Φ is deﬁnable by the equation Φ⃗ϕ = Y w⃗ϕ0 with w⃗ϕ of
type (N →ι) →N →ι given by
w⃗ϕψx := pcond(ϕ1 ↑# f1x ∧. . . ∧ϕp ↑# fpx, ψ(x + 1) ∪# gx, ψ(x + 1)).
Here ∧is the parallel and of type B →B →B, deﬁned by ∧(p, q) :=
pcond(p, q, {ff}). To simplify notation we assume p = 1 in the argument to follow,
and write w for wϕ. For later reference we split the rest of the argument into steps.
Step 1
We ﬁrst prove that
∀n(a ∈wk+1∅n →∃n≤l≤n+k(ϕ ⊇Efl ∧{egl} ⊢a)).
(2.18)
The proof is by induction on k. For the base case assume a ∈w∅n, i.e.,
a ∈pcond(ϕ ↑# fn, ∅∪# gn, ∅).
Then clearly ϕ ⊇Efn and {egn} ⊢a.

Towards a Formal Theory of Computability
271
Step 2
For the step k →k + 1 we have
a ∈wk+2∅n = w(wk+1∅)n = pcond(ϕ ↑# fn, v ∪# gn, v),
with v := wk+1∅(n + 1). Then either a ∈v (and we are done by the induction
hypothesis) or else ϕ ⊇Efn and {egn} ⊢a.
Step 3
Now Φϕ ⊇Y w0 follows easily. Assume a ∈Y w0. Then a ∈wk+1∅0 for some
k, by (2.2). Therefore there is an l with 0 ≤l ≤k such that ϕ ⊇Efl and {egl} ⊢a.
But this implies a ∈Φϕ.
Step 4
For the converse assume a ∈Φϕ. Then for some U ⊆ϕ we have (U, a) ∈Φ. By
our assumption on Φ this means that we have an n such that U = Efn and a = egn.
We show
a ∈wk+1∅(n −k)
for k ≤n.
The proof is by induction on k. For k = 0 because of ϕ ⊇Efn we have tt ∈ϕ ↑#
fn and hence wψn = ψ(n + 1) ∪# gn ∋egn = a, for any ψ.
Step 5
For the step k →k + 1 by deﬁnition of w (:= wϕ)
v′ := wk+2∅(n −k −1)
= w(wk+1∅)(n −k −1)
= pcond(ϕ ↑# f(n −k −1), v ∪# g(n −k −1), v)
with v := wk+1∅(n −k). By induction hypothesis a ∈v; we show a ∈v′. If a
and eg(n−k−1) are inconsistent, a ∈Φϕ and (Ef(n−k−1), eg(n−k−1)) ∈Φ imply
that ϕ ∪Ef(n−k−1) is inconsistent, hence ff ∈ϕ ↑# f(n −k −1) and therefore
v′ = v.
Step 6
If a and eg(n−k−1) are consistent, a and eg(n−k−1) are comparable, since our un-
derlying algebra ι has at most unary constructors.

272
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
Step 7
In case {eg(n−k−1)} ⊢a we have v ∪# g(n −k −1) ⊇{eg(n−k−1)} ⊢a, and
hence a ∈v′ because of a ∈v.
Step 8
In case {a} ⊢eg(n−k−1) we have eg(n−k−1) ∈v because of a ∈v, hence v ∪#
g(n −k −1) = v and therefore again a ∈v′.
Step 9
Now the converse inclusion Φϕ ⊆Y wϕ0 can be seen easily. Since a ∈Φϕ, the
claim just proved for k := n gives a ∈wn+1
ϕ
∅0, and this implies a ∈Y wϕ0.
3 The Theory TCF+
We sketch a formal system TCF+ intended to talk about computable function-
als plus their ﬁnite approximations, i.e., tokens and formal neighborhoods. Since
continuous functionals (i.e., ideals) are possibly inﬁnite sets of tokens, TCF+ con-
tains for every type ρ set variables xρ. The only existence axiom for sets will be
Σ-comprehension.
3.1 Types and token types
Recall that (object) types are built from base types ι (the algebras above) by ρ →σ.
Now in addition for every (object) type ρ we have token types Tok∗
ρ (extended
tokens of type ρ), Tokρ (tokens of type ρ), LTokρ (lists of tokens of type ρ), LTok∗
ρ
(lists of extended tokens of type ρ); let τ range over token types. The index ρ will
be omitted if it is inessential or clear from the context.
We inductively deﬁne the extended tokens of an algebra ι. As a generic algebra
we take the algebra D (of derivations), given by the constructors 0D (axiom) and
CD→D→D (rule); for other algebras the deﬁnitions are similar. The clauses are
Tok∗
D(∗),
Tok∗
D(0D),
Tok∗
D(a∗
1) →Tok∗
D(a∗
2) →Tok∗
D(CD→D→Da∗
1a∗
2).
(Proper) tokens are deﬁned similarly:
TokD(0D),
Tok∗
D(a∗
1) →Tok∗
D(a∗
2) →TokD(CD→D→Da∗
1a∗
2).
Clearly every token can be viewed as an extended token.

Towards a Formal Theory of Computability
273
It will be convenient to represent formal neighborhoods as lists of tokens. The
algebra of lists of tokens of type D is deﬁned by
LTokD(nilD),
TokD(a) →LTokD(U) →LTokD(a ::D U).
We use nilD to denote the empty list, and a ::D U (or consD(a, U)) to denote the
result of constructing a new list from a given one U by adding a in front. Similarly
the algebra of lists of extended tokens is deﬁned by
LTok∗
D(nilD),
Tok∗
D(a) →LTok∗
D(U) →LTok∗
D(a ::D U).
We allow functions of token-valued types ⃗τ →τ, deﬁned by primitive recur-
sion. An easy example is ˙∈D : Tok∗
D →LTok∗
D →TokB; it is a boolean-valued
function, i.e., with values in TokB. The recursion equations are
(a∗˙∈D nil) := ff,
(a∗˙∈D (b∗::D U)) := (a∗=D b∗) ∨B a∗˙∈U,
where equality =D : Tok∗
D →Tok∗
D →TokB is deﬁned by
(∗=D ∗) := (0 =D 0) := tt,
(∗=D 0) := (∗=D Ca∗
1a∗
2) := ff,
(0 =D ∗) := (0 =D Ca∗
1a∗
2) := ff,
(Ca∗
1a∗
2 =D ∗) := (Ca∗
1a∗
2 =D 0) := ff,
(Ca∗
1a∗
2 =D Cb∗
1b∗
2) := (a∗
1 =D b∗
1) ∧B (a∗
2 =D b∗
2),
and ∨B : TokB →TokB →TokB is the disjunction function on TokB, deﬁned
by tt ∨B b := tt and ff ∨B b := b.
From a list of extended tokens of D we obtain a list of (proper) tokens by remov-
ing the ∗’s. Deﬁne clean: LTok∗
D →LTokD by
clean(nil) := nil,
clean(∗:: U) := clean(U),
clean(0 :: U) := 0 :: clean(U),
clean(Ca∗
1a∗
2 :: U) := Ca∗
1a∗
2 :: clean(U).
We deﬁne argsC,i : LTokD →LTok∗
D (i = 1, 2), which from a list of tokens of
D constructs the list of the i-th arguments of C-tokens:
argsC,i(nil) := nil,
argsC,i(0 :: U) := argsC,i(U),
argsC,i(Ca∗
1a∗
2 :: U) := a∗
i :: argsC,i(U).

274
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
Now we can deﬁne entailment ⊢: LTokD →Tok∗
D →TokB:
U ⊢∗:= tt,
nil ⊢0 := ff,
nil ⊢Ca∗
1a∗
2 := ff,
0 :: U ⊢Cb∗
1b∗
2 := U ⊢Cb∗
1b∗
2,
Ca∗
1a∗
2 :: U ⊢0 := U ⊢0,
0 :: U ⊢0 := tt,
and
Ca∗
1a∗
2 :: U ⊢Cb∗
1b∗
2 := clean(a∗
1 :: argsC,1(U)) ⊢b∗
1 ∧B
clean(a∗
2 :: argsC,2(U)) ⊢b∗
2,
where ∧B : TokB →TokB →TokB is the conjunction function on TokB, de-
ﬁned by ff ∧B b := ff and tt ∧B b := b.
To deﬁne consistency for lists of tokens we need an auxiliary function checking
the outermost constructor only. Let PreCon: LTokD →TokB be deﬁned by
PreCon(nil) := PreCon(a :: nil) := tt,
PreCon(0 :: Ca∗
1a∗
2 :: U) := PreCon(Ca∗
1a∗
2 :: 0 :: U) := ff,
PreCon(0 :: 0 :: U) := PreCon(0 :: U),
PreCon(Ca∗
1a∗
2 :: Cb∗
1b∗
2 :: U) := PreCon(Cb∗
1b∗
2 :: U).
Using PreCon we can deﬁne consistency Con: LTokD →TokB by
Con(nil) := Con(a :: nil) := tt,
Con(0 :: Ca∗
1a∗
2 :: U) := Con(Ca∗
1a∗
2 :: 0 :: U) := ff,
Con(0 :: 0 :: U) := Con(0 :: U),
and
Con(Ca∗
1a∗
2 :: Cb∗
1b∗
2 :: U) := PreCon(Cb∗
1b∗
2 :: U) ∧B
Con(clean(a∗
1 :: b∗
1 :: argsC,1(U))) ∧B
Con(clean(a∗
2 :: b∗
2 :: argsC,2(U))).
We write a∗↑ρ b∗for Con(a∗::ρ b∗::ρ nil).
We deﬁne GD : Tok∗
D →TokB expressing totality for extended tokens:
GD(∗) := ff,
GD(0) := tt,
GD(Ca∗
1a∗
2) := GDa∗
1 ∧B GDa∗
2,
and also GLTokD : LTokD →TokB doing the same for lists of tokens
GLTokD(nilD) := ff,
GLTokD(a ::D U) := GDa ∨B GLTokDU.

Towards a Formal Theory of Computability
275
Recall that total tokens of N are iterated applications of the successor constructor
S to the zero constructor 0. They are called “index numbers”, and written n ∈
N. Since primitive recursion is available to deﬁne token-valued functions, we can
construct standard auxiliary functions, like sequence coding. Thus every (index)
number n can be written uniquely as n = ⟨a0, a1, . . . , ak−1⟩, and k = lh(n),
ai = (n)i for i < k.
Tokens of a function type ρ →σ are pairs (U, a) of lists of tokens of type ρ and
tokens of type σ. Both projections are given by functions π1, π2. Consistency of
lists of tokens, application WU and entailment U ⊢a can be deﬁned as described
in 1.2.
3.2 Enumerations
We assume ﬁxed enumerations (en)n∈N of tokens and (En)n∈N of lists of tokens,
for each type. It seems easiest to deﬁne them explicitly. Fix for every constructor
C of an algebra a unique “symbol number” SN(C). We also have a symbol num-
ber SN(Nhd) indicating the code of a formal neighborhood. We deﬁne a G¨odel
numbering ⌜·⌝: Tok∗
D →N by
⌜∗⌝:= 0,
⌜0⌝:= ⟨SN(0)⟩,
⌜Ca∗
1a∗
2⌝:= ⟨SN(C), ⌜a∗
1⌝, ⌜a∗
2⌝⟩.
Formal neighborhoods are g¨odelized by ⌜·⌝: LTokρ →N,
⌜a0 :: a1 :: . . . ak−1 :: nil⌝:= ⟨SN(Nhd), ⌜ρ⌝, ⌜a0⌝, ⌜a1⌝, . . . , ⌜ak−1⌝⟩,
where ⌜ι⌝:= ⟨SN(ι)⟩, ⌜ρ →σ⌝:= ⟨SN(→), ⌜ρ⌝, ⌜σ⌝⟩. It is clear that we can
primitive recursively deﬁne the converse, mapping the G¨odel number ⌜a∗⌝of an
extended token back to a∗, i.e., e⌜a∗⌝= a∗, and similarly for LTokρ.
3.3 Terms and formulas
We have variables a∗for Tok∗
ρ (extended tokens of type ρ), a for Tokρ (tokens
of type ρ) and U for LTokρ (lists of tokens of type ρ). From these, the symbols
for token-valued functions and constants for the constructors for tokens, extended
tokens and lists of these we can build terms of token types. We identify terms of
token type if they have the same normal form w.r.t. the deﬁning primitive recursion
equations for the token-valued functions involved.
Decidable (or Δ-) prime formulas are of the form atom(p), with p a term of
token type TokB. They are decidable in the sense that for each such term p we can

276
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
prove p = tt ∨p = ff; in fact, every closed term of type TokB can be evaluated
to either tt and ff. Examples are a ↑ρ b, a ˙∈ρ U, U ⊢ρ a (which are shorthand
for atom(a ↑ρ b), atom(a ˙∈ρ U), atom(U ⊢ρ a)). Δ-formulas are built from
decidable prime formulas by →, ∧, ∨and bounded quantiﬁers, i.e., ∀a ˙∈U, ∃a ˙∈U,
with a a variable for tokens and U a term for a list of tokens.
In TCF+ we also allow variables and constants of (object) type ρ, intended to
denote sets of tokens. The constants are [[λ⃗xM]] (with M a term as in 2.1) of type
⃗ρ →σ, and also pcond, ∪#, ↑# of types B →ρ →ρ →ρ, ρ →N →ρ and
ρ →N →B, respectively.
Prime Σ-formulas are either decidable prime formulas or else of the form r ∈ρ x,
with r a term of token type Tokρ and x a variable or constant of type ρ. Σ-formulas
are built as follows.
(a) Every prime Σ-formula is a Σ-formula.
(b) A0 →B is a Σ-formula if A0 is a Δ-formula and B a Σ-formula.
(c) Σ-formulas are closed under ∧, ∨, bounded quantiﬁers and existential quan-
tiﬁers over variables of a token type.
Prime formulas are either prime Σ-formulas or else of the form Gρx (expressing
totality of x) or x ≈ρ y (expressing equivalence of x and y); x, y are variables or
constants of type ρ. Formulas are built from prime formulas by →, ∧, ∨, ∀, ∃,
where the quantiﬁers are w.r.t all kinds of variables.
3.4 Axioms
TCF+ is based on intuitionistic logic. In fact, minimal logic sufﬁces, since falsity
can be deﬁned as atom(ff). Then atom(ff) →A (“ex-falso-quodlibet”) can be
proved provided one has it as an axiom for every prime formula (it can be proved
for decidable prime formulas).
Therefore the axioms of TCF+ are ex-falso-quodlibet for non-decidable prime
formulas A, plus the usual ones of Heyting arithmetic, adapted to token types. In
particular we have the ordinary induction schemes, for arbitrary formulas of the
language. Examples are
A(tt) →A(ff) →A(a),
A(∗) →A(0) →∀a∗,b∗(A(a∗) →A(b∗) →A(Ca∗b∗)) →A(a∗).
Moreover atom(tt) is an axiom. For object types we have Σ-comprehension:
∃x∀a(a ∈ρ x ↔A),
for every Σ-formula A.
A convenient notation for x is { a | A }. Further axioms are

Towards a Formal Theory of Computability
277
(a) For every constant [[λ⃗xM]] its deﬁning clauses corresponding to the rules (V ),
(A), (C), (D) from 2.1, together with their least-ﬁxed-point axioms.
(b) The deﬁning clauses and corresponding least-ﬁxed-point axioms, for pcond,
∪# and ↑#, as listed in 2.3.
(c) The clauses from 2.2 deﬁning the totality predicates Gρ and the equivalence
relations x1 ≈ρ x2, together with their least-ﬁxed-point axioms.
Notice that the latter imply x1 ≈ρ x2 →Gx1 →Gx2.
3.5 First steps in TCF+
We use the abbreviations
U ⊆V
for
∀a ˙∈U(a ˙∈V ),
U ⊢V
for
∀a ˙∈V (U ⊢a),
U ∼V
for
U ⊢V ∧V ⊢U,
a ∼b
for
{a} ⊢b ∧{b} ⊢a,
x ⊆y
for
∀a∈x(a ∈y),
x = y
for
x ⊆y ∧y ⊆x,
U ⊆x
for
∀a ˙∈U(a ∈x).
Terms of (object) type are built from variables and constants by application ts and
comprehension { a | A }. Then r ∈ρ t for t a term of type ρ and r a term of token
type Tokρ is deﬁned by
(r ∈ρ { a | A(a) }) := A(r),
(r ∈ρ ts) := ∃U⊆s((U, r) ∈t)
(continuity of application).
For a term M with free variables among ⃗x we write
a ∈σ [[M]]
for
∃⃗U⊆⃗x((⃗U, a) ∈⃗ρ→σ [[λ⃗xM]]).
We can prove Δ-comprehension for lists of tokens
∃U∀a(a ˙∈U ↔a ˙∈V ∧A),
for every Δ-formula A,
by induction on V . A convenient notation for U is [ a ˙∈V | A ].

278
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
We will need the extension f of a monotone token-valued function f to ideals. It
sufﬁces to do this for f : Tok∗
N →Tok∗
N. Suppose f is monotone, i.e., {a∗} ⊢b∗
implies {fa∗} ⊢fb∗. Deﬁne f[·]: LTok∗
N →LTok∗
N by
f[nil] := nil,
f[a∗::N U] := (fa∗) ::N f[U].
Then f : N →N is deﬁned by
f = { (U, a) | Con(U) ∧f[U] ⊢a }.
Clearly f is a decidable ideal. If f : TokN →TokN is deﬁned primitive recur-
sively, then by reading f’s primitive recursion equations as computation rules we
obtain a deﬁned constant f (in the sense of 2.1) such that fn = fn.
Notice that ∀i<nA with i a variable and n a term of token type TokN can be
viewed as bounded quantiﬁcation. Deﬁne h: Tok∗
N →LTok∗
N by
h(∗) := h(0) := nil,
h(S a∗) := h(a∗) ∗(a∗:: nil),
where ∗appends two lists from LTok∗
N. Then h(Sk 0) = [0, S 0, . . . , Sk−1 0] (i.e.,
0 :: S 0 :: . . . Sk−1 0 :: nil), and we can read ∀i<nA as ∀i ˙∈h(n)A.
Every W of token type LTokρ→σ can be written as { (Ui, ai) | i < n }. Here
Ui, ai are given as f(W, i), g(W, i) and n as the length lh(W) of W, with f, g and
lh(·) deﬁned primitive recursively. Deﬁne
(a ˙∈Wx) := ∃i<n(Ui ⊆x ∧a = ai).
Then a ˙∈Wx is a Δ-formula if x is given by { a | A } with A a Δ-formula.
Therefore by Δ-comprehension for list of tokens we obtain U consisting of all ai’s
such that ai ˙∈Wx. Hence Wx ⊢a can be seen as a Δ-formula as well.
4 Formalization
4.1 Density
The informal proof already was written in a form making its formalization in TCF+
easy. We only discuss the more interesting issues.
The density theorem is parametrized by the type ρ, and its proof (by induction
on ρ) is to be viewed as employing a “meta”-induction.
In the proof that ρ →σ is dense we ﬁxed W = { (Ui, ai) | i < n } ∈Conρ→σ.
Consider i < j < n with ai ̸↑aj, thus Ui ̸↑Uj. The induction hypothesis (b) for
ρ gives ⃗zij ∈G such that Ui⃗zij ̸↑ι Uj⃗zij. The deﬁnition of
VU := [ ak | k ∈IU ]

Towards a Formal Theory of Computability
279
can be seen as an application of Δ-comprehension for lists of tokens, since k ∈IU
is a Δ-formula. Now the induction hypothesis that σ is dense yields VU ⊆yVU :=
{ a | TExtσ(VU, a) } ∈Gσ. The deﬁnition (2.3) of
r := { (U, a) | (a ∈yVU ∧∀i,j<n(ai ̸↑aj →Gι(U⃗zij))) ∨VU ⊢a },
is by Σ-comprehension; in fact, the deﬁning formula is a Δ-formula. The rest of
the argument can be easily formalized.
The proof that ρ →σ is separating does not present any difﬁculties. We are given
W1, W2 ∈Conρ→σ with W1 ̸↑W2, and pick (Ui, ai) ∈Wi such that U1 ↑U2 and
a1 ̸↑a2. Notice that the Ui, ai can be deﬁned primitive recursively from W1, W2,
and hence are uniquely determined. By induction hypothesis (a) for ρ,
U1 ∪U2 ⊆zU1,U2 := { a | TExtρ(U1 ∪U2, a) } ∈Gρ.
Then ai ˙∈WizU1,U2. From the induction hypothesis (b) for σ we obtain ⃗za1,a2 ∈G
such that (writing {ai} for [ai])
{a1}⃗za1,a2 ̸↑ι {a2}⃗za1,a2,
where σ = σ1 →. . . →σp →ι and za1,a2,i := { a | Sepi
σ({a1}, {a2}, a) } for
i = 1, . . . , p. Hence W1zU1,U2⃗za1,a2 ̸↑ι W2zU1,U2⃗za1,a2.
4.2 Deﬁnability
We restrict ourselves to the more interesting direction and assume that Φ is given
as a primitive recursively enumerated set of tokens (Efn, egn) where f, g are ﬁxed
primitive recursive functions. We need to show that Φ is recursive in pcond, ∪#
and ↑#, i.e., that it can be deﬁned explicitly by a term involving the constructors
for ι and N, the constants predecessor, the ﬁxed point operators Yρ, the parallel
conditional pcond and the continuous variants of union and of consistency. In
doing so we follow the steps in the informal proof in 2.3. We show that Φ is
deﬁnable by the equation Φϕ = Y wϕ0, with wϕ of type (N →ι) →N →ι given
by
wϕψx := pcond(ϕ ↑# fx, ψ(x + 1) ∪# gx, ψ(x + 1)).
In Step 1 by continuity of application we obtain U ⊆ϕ ↑# fn and V ⊆∅∪#gn
such that (U, V, ∅, a) ∈pcond. For ϕ ⊇Efn it sufﬁces by (2.16) to prove tt ∈
ϕ ↑# fn, which because of U ⊆ϕ ↑# fn follows from U ⊢tt. This will follow
from the rules for pcond, because (since W is ∅) the token (U, V, ∅, a) must have
entered pcond by rule (2.4). Formally we make use of the least-ﬁxed-point axiom

280
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
for pcond, and apply it to C := { (U, V, W, a) | W ⊆∅→U ⊢tt }. We show
that C satisﬁes (2.4)–(2.6). For (2.5) we must show
U ⊢ff →W ⊢a →(U, V, W, a) ∈C,
i.e.,
U ⊢ff →W ⊢a →W ⊆∅→U ⊢tt.
But this follows from ex-falso-quodlibet, since W ⊢a and W ⊆∅are contra-
dictory. (2.6) is proved similarly, and (2.4) has the desired conclusion U ⊢tt
among its premises.
But now the least-ﬁxed-point axiom for pcond implies
(U, V, ∅, a) ∈C and hence U ⊢tt. For {egn} ⊢a we argue similarly, with
C := { (U, V, W, a) | W ⊆∅→V
⊢a }, and obtain V
⊢a and hence
a ∈∅∪# gn. By (2.12) we conclude that {egn} ⊢a.
The next part of the informal proof was Step 2. Again by continuity of ap-
plication we obtain U ⊆ϕ ↑# fn, V
⊆v ∪# gn and W ⊆v such that
(U, V, W, a) ∈pcond. We can prove W ⊢a ∨(U ⊢tt ∧V ⊢a) as above
from the rules for pcond. Hence either a ∈v (and we are done by the induc-
tion hypothesis), or else ϕ ⊇Efn (which follows as above from U ⊢tt) and
a ∈v ∪# gn. From the latter by continuity of application we obtain V ⊆v
and W ⊆gn such that (V, W, a) ∈∪#. By a least-ﬁxed-point argument (with
C := { (V, W, a) | ∃m(m ˙∈W
∧{em} ⊢a) ∨V ⊢a }) we obtain ei-
ther V ⊢a (hence a ∈v and again we are done by the induction hypothesis), or
else {em} ⊢a for an m ∈G such that m ˙∈W, hence m = gn, and therefore
{egn} ⊢a. Now the induction used in the informal proof can be applied and we
have proved (2.18) formally.
The informal proof proceeded by Step 3. Since corollary (2.2) referred to is
available in TCF+, we have proved the conclusion a ∈Φϕ formally.
Let us now formalize the proof of the reverse direction. Step 4. In the formal-
ization from ϕ ⊇Efn we obtain tt ∈ϕ ↑# fn by (2.16). We show a ∈wψn for
an arbitrary ψ, i.e., a ∈pcond(ϕ ↑# fn, ψ(n + 1) ∪# gn, ψ(n + 1)). Because
of tt ∈ϕ ↑# fn and (2.7) it is enough to show that a ∈ψ(n + 1) ∪# gn. But
egn ∈ψ(n + 1) ∪# gn by (2.13), and we have assumed a = egn.
Next we consider Step 5. Formally we can infer the existence of b ∈ϕ and
c ˙∈Ef(n−k−1) such that b ̸↑c. Hence ff ∈ϕ ↑# f(n −k −1) by (2.17),
and v′ = v by (2.8). Step 6 is immediate because of the Comparability Lemma.
For Step 7: Here we can infer a ∈v ∪# g(n −k −1) from (2.13). This and
the induction hypothesis a ∈v yields the claim a ∈v′ by (2.9). For Step 8:
v ∪# g(n −k −1) = v follows from eg(n−k−1) ∈v by (2.12). Again this and the
induction hypothesis a ∈v yields the claim a ∈v′ by (2.9). For Step 9: The ﬁnal
inference is justiﬁed by (2.2) (applied to ({0}, a)).

Towards a Formal Theory of Computability
281
5 Future work
In this paper we attempted to have a ﬁrst exploratory view on a constructive formal
theory of computability TCF+, where the functionals are studied together with
their ﬁnite approximations. The attempt was guided by the semantics of non-ﬂat
Scott information systems; in particular, it was based on two case studies, namely,
the density theorem and the deﬁnability theorem. Future work along these lines is
to explain TCF+ in a rigorous and systematic way, as well as test it against further
case studies, while an actual implementation on a theorem prover—which should
be specially designed to allow for handling functionals and ﬁnite approximations
alike—remains the ultimate goal of the whole enterprise.
References
[1] S. Abramsky and A. Jung.
Domain theory.
In S. Abramsky, D. Gabbay, and
T. Maibaum, editors, Handbook of Logic in Computer Science, volume 3, pages 1–
168. Clarendon Press, 1994.
[2] U. Berger. Total sets and objects in domain theory. Annals of Pure and Applied Logic,
60:91–117, 1993.
[3] Y. L. Ershov.
Maximal and everywhere deﬁned functionals.
Algebra i Logika,
13(4):374–397, 1974.
[4] A. Heyting, editor. Constructivity in Mathematics. North–Holland, Amsterdam, 1959.
[5] S. Huber. On the computional content of choice axioms. Master’s thesis, Mathemati-
sches Institut der Universit¨at M¨unchen, 2010.
[6] S. C. Kleene. Countable functionals. In Heyting [4], pages 81–100.
[7] G. Kreisel. Interpretation of analysis by means of constructive functionals of ﬁnite
types. In Heyting [4], pages 101–128.
[8] K. G. Larsen and G. Winskel. Using information systems to solve recursive domain
equations. Information and Computation, 91:232–258, 1991.
[9] G. Longo and E. Moggi. The hereditary partial effective functionals and recursion
theory in higher types. The Journal of Symbolic Logic, 49:1319–1332, 1984.
[10] G. D. Plotkin. LCF considered as a programming language. Theoretical Computer
Science, 5:223–255, 1977.
[11] G. D. Plotkin. Tω as a universal domain. Journal of Computer and System Sciences,
17:209–236, 1978.
[12] D. Scott. A type-theoretical alternative to ISWIM, CUCH, OWHY. Manuscript, Ox-
ford University. Published as [15], 1969.

282
Simon Huber, Basil A. Kar´adais, and Helmut Schwichtenberg
[13] D. Scott. Outline of a mathematical theory of computation. Technical Monograph
PRG–2, Oxford University Computing Laboratory, 1970.
[14] D. Scott. Domains for denotational semantics. In E. Nielsen and E. Schmidt, edi-
tors, Automata, Languages and Programming, volume 140 of LNCS, pages 577–613.
Springer Verlag, Berlin, Heidelberg, New York, 1982.
[15] D. Scott. A type-theoretical alternative to ISWIM, CHUCH, OWHY. Theoretical
Computer Science, 121:411–440, 1993.
[16] V. Stoltenberg-Hansen, E. Griffor, and I. Lindstr¨om.
Mathematical Theory of Do-
mains.
Cambridge Tracts in Theoretical Computer Science. Cambridge University
Press, 1994.

Σ1
1 Choice in a Theory of Sets and Classes
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl∗
Institut f¨ur Informatik und angewandte Mathematik
Universit¨at Bern
Neubr¨uckstrasse 10, CH-3012 Bern, Switzerland
{jaeger,kraehenb}@iam.unibe.ch
Abstract Several decades ago Friedman showed that the subsystem Σ1
1-AC
of second order arithmetic is proof-theoretically equivalent – and thus
equiconsistent – to (Π1
0-CA)<ε0. In this article we prove the analogous re-
sult for Σ1
1 choice in the context of the von Neumann-Bernays-G¨odel theory
NBG of sets and classes.
Keywords: Proof theory, theories of sets and classes.
1 Introduction
Several decades ago Friedman showed that the subsystem Σ1
1-AC of second or-
der arithmetic is proof-theoretically equivalent – and thus equiconsistent – to
(Π1
0-CA)<ε0 (cf. Friedman [7]). Later Feferman [2, 3], Tait [16], Feferman and
Sieg [6] and Cantini [1] reproved and extended this result, always making use of
different proof-theoretic techniques.
In this article we start off from the von Neumann-Bernays-G¨odel theory NBG
of sets and classes, extend it by the schema (L2-I∈) of ∈-induction for arbitrary
formulas of the language L2 of NBG and study the effect of adding Σ1
1 choice and
Σ1
1 collection,
∀x∃Y A[x, Y ] →∃Z∀xA[x, (Z)x],
(Σ1
1-AC)
∀x∃Y A[x, Y ] →∃Z∀x∃yA[x, (Z)y],
(Σ1
1-Col)
where A is an elementary formula of L2, i.e. an L2 formula which does not con-
tain bound class variables. We will show that the resulting theories are equicon-
sistent to the system NBG<E0 which is obtained from NBG + (L2-I∈) by adding
iterations of elementary comprehension along all initial segments of the notation
∗Research supported by the Swiss National Science Foundation

284
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
system (E0, ◁). E0 is an elementarily deﬁnable class and ◁an elementary binary
class relation on E0 which, provably in NBG, well-orders all initial segments of
E0. The notation system (E0, ◁) may be seen as the analogue of (ε0, <) with the
ordinal ω replaced by the collection of all ordinals. In this sense, our result is the
perfect analogue of Friedman’s result mentioned above with natural numbers and
sets of natural numbers replaced by sets and classes, respectively.
Our characterization of NBG + (L2-I∈) + (Σ1
1-AC) is also interesting in connec-
tion with Feferman’s operational set theory OST, introduced in Feferman [4,5]. As
shown in J¨ager [11], the extension OST(E, P) of OST with unbounded existential
quantiﬁcation and power set is equiconsistent to NBG<E0 and therefore, in view of
the results of this paper, also to the more familiar system NBG+(L2-I∈)+(Σ1
1-AC).
The results of this paper are discussed from a broader perspective in J¨ager [12].
The embedding of NBG<E0 into NBG + (L2-I∈) + (Σ1
1-AC) is straightforward.
The difﬁcult part of this paper is the reduction of NBG + (L2-I∈) + (Σ1
1-AC)
to NBG<E0, and here an asymmetric interpretation plays a major rˆole. Similar
forms of asymmetric interpretations have been used, for example, in Cantini [1] to
deal with subsystems of second order arithmetic and in J¨ager [9–11] and J¨ager and
Strahm [13] in the context of theories of admissible sets, explicit mathematics and
operational set theory.
First we observe that (Σ1
1-AC) can be replaced by (Σ1
1-Col). Then, in order to
get rid of (L2-I∈), we develop (within NBG<E0) an inﬁnitary sequent style refor-
mulation G∞of NBG + (Σ1
1-Col) in which constants for all sets are available. By
making use of an inﬁnitary rule for universal quantiﬁcation over sets, we show
NBG + (L2-I∈) + (Σ1
1-Col) ⊢A
=⇒
NBG<E0 ⊢“G∞proves A”.
A next step is to strengthen this assertion by a partial cut elimination argument for
G∞to
NBG + (L2-I∈) + (Σ1
1-Col) ⊢A
=⇒
NBG<E0 ⊢“G∞proves A with simple cuts”.
Now the technical part begins: we have to go back from provability in G∞to
provability in NBG<E0. This is achieved in two further steps:
(i) Introduction of a sort of constructible hierarchy of classes and a truth deﬁnition
based on this hierarchy which reﬂects all closed elementary formulas A,
NBG<E0 ⊢Tr[A] ↔A.

Σ1
1 Choice in a Theory of Sets and Classes
285
(ii) An asymmetric interpretation of a suitable fragment of G∞with respect to this
hierarchy such that, for all closed elementary formulas A of G∞,
NBG<E0 ⊢(“G∞proves A with simple cuts” →Tr[A]).
Altogether, we thus have
NBG + (L2-I∈) + (Σ1
1-Col) ⊢A
=⇒
NBG<E0 ⊢A
for all closed elementary formulas, and this is the required reduction. The deﬁni-
tions of our analogue of the constructible hierarchy and the associated notion of
truth – although conceptually clear – require some care since everything has to be
carried through within the restricted framework of NBG<E0.
2 Von Neuman-Bernays-G¨odel set theory
The von Neumann-Bernays-G¨odel set theory NBG is a theory of sets and classes
conservative over the system ZFC of Zermelo-Fraenkel set theory with the axiom
of choice. NBG is known to be ﬁnitely axiomatizable although the version we are
going to present below permits axiom schemas and as such is an inﬁnite axiomati-
zation.
Let L1 be a typical ﬁrst order language of set theory with countably many set
variables a, b, c, f, g, u, v, w, x, y, z, . . . and a single symbol for the element rela-
tion, but without function or individual constants.
L2, the language of NBG, augments L1 by a second sort of countably many vari-
ables U, V, W, X, Y, Z, . . . for classes; its formulas (A, B, C, . . .) are inductively
generated as follows:
1. If a, b are set variables and if U is a class variable, then all expressions of the
form (a ∈b) and (a ∈U) are (atomic) formulas of L2.
2. If A and B are formulas of L2, then so are are ¬A, (A ∨B) and (A ∧B).
3. If A is a formula of L2, then ∃xA, ∀xA, ∃XA and ∀XA are formulas of L2.
The denotations for set variables, class variables and L2 formulas may be used
with and without subscripts. Since we will be working within classical logic, the
remaining logical connectives can be deﬁned as usual.
We will often omit parentheses and brackets whenever there is no danger of con-
fusion. Moreover, we frequently make use of the vector notation ⃗a as shorthand for

286
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
a ﬁnite string a1, . . . , an of set variables whose length is not important or evident
from the context.
Equalities between sets/sets, sets/classes, classes/sets and classes/classes are not
atomic formulas of L2 but deﬁned as
(Var 1 = Var 2) := ∀x(x ∈Var1 ↔x ∈Var 2)
where Var 1 and Var 2 denote set or class variables. A formula of L2 is called ele-
mentary if it does not contain bound class variables; free class variables, however,
are permitted. The Σ1
1 formulas of L2 are those of the form ∃XA with elementary
A. Finally, an L2 formula A is called Σ1 if all positive occurrences of class quan-
tiﬁers are existential and all negative occurrences of class quantiﬁers are universal;
it is called Π1 if all positive occurrences of class quantiﬁers are universal and all
negative occurrences of class quantiﬁers are existential. By a closed formula we
mean one which does not contain free set or class variables.
The logic of NBG is classical two-sorted logic with equality for the ﬁrst sort.
The non-logical axioms of NBG are given in six groups. To increase readability,
we freely use standard set-theoretic terminology.
I. Elementary comprehension
For any elementary formula A[u] of L2 and
any class variable X not free in A[u]:
∃X∀y(y ∈X ↔A[y]).
(ECA)
Hence every elementary NBG formula A[u] deﬁnes a class, which is typically
written as {x : A[x]}. It may be (extensionally equal to) a set, but this is not
necessarily the case.
II. Basic set existence
∀x∀y∃z(z = {x, y}),
(Pair)
∀x∃y(y = ∪x),
(Union)
∀x∃y∀z(z ∈y ↔z ⊂x),
(Power set)
∃x(∅∈x ∧(∀y ∈x)(y ∪{y} ∈x)).
(Inﬁnity)
In the following we write ⟨a, b⟩for the ordered pair of the sets a and b `a la
Kuratowski. Class relations are classes which consist of ordered pairs only, and

Σ1
1 Choice in a Theory of Sets and Classes
287
class functions are class relations which are right unique; i.e. for all U we set:
Rel[U] := (∀x ∈U)∃y∃z(x = ⟨y, z⟩),
Dom[U] := {x : ∃y(⟨x, y⟩∈U)},
Fun[U] := Rel[U] ∧∀x∀y∀z(⟨x, y⟩∈U ∧⟨x, z⟩∈U →y = z).
If U is a function and x an element of Dom[U], we write U(x) for the unique y
such that ⟨x, y⟩∈U. Replacement states that the range of a set under a function is
a set.
III. Replacement
For any class variable U:
Fun[U] →∀x∃y(y = {U(z) : z ∈Dom[U] ∩x}).
(REP)
Global choice is a very uniform principle of choice which claims the existence
of a class function which picks an element of any non-empty set.
IV. Global choice
∃X(Fun[X] ∧Dom[X] = {y : y ̸= ∅} ∧∀y(y ̸= ∅→X(y) ∈y)).
(GC)
To complete the list of axioms of NBG, we add foundation. In NBG it is claimed
that the element relation is well-founded with respect to classes.
V. Class foundation
For any class variable U:
U ̸= ∅→(∃x ∈U)(∀y ∈x)(y /∈U).
(C-I∈)
A set a is called an ordinal if a itself and all its elements are transitive, On stands
for the class of all ordinals; i.e.
On := {x : Tran(x) ∧(∀y ∈x)Tran(y)}.
The axioms (Inﬁnity) and (C-I∈) imply that there exists a least inﬁnite ordinal,
which we denote by ω, as usual. The elements of ω are identiﬁed with the natural
numbers in the sense that 0 := ∅, 1 := {0}, 2 := 1 ∪{1} and so on. In the
following small Greek letters are supposed to range over On.
One important property of NBG is the subset property: the intersection of a set a
with a class is a subset of a. Its proof is standard.

288
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
There exist various alternative presentations of NBG. So it is an appealing fea-
ture of NBG that the schema of elementary comprehension can be replaced by
ﬁnitely many axioms and thus a ﬁnite axiomatization of NBG is possible. Further-
more, according to a well-known result, see, e.g., Levy [14], NBG is a conservative
extension of ZFC.
Theorem 2.1. A sentence of the language L1 is provable in NBG if and only if it is
provable in ZFC.
In the following we will be mainly concerned with extensions of NBG. The
ﬁrst of those consists in adding to NBG the schema of ∈-induction for arbitrary L2
formulas A[u],
∀x((∀y ∈x)A[y] →A[x]) →∀xA[x].
(L2-I∈)
Further interesting principles are the schemas of Σ1
1 choice and Σ1
1 collection which
consists of all formulas
∀x∃Y A[x, Y ] →∃Z∀xA[x, (Z)x],
(Σ1
1-AC)
∀x∃Y A[x, Y ] →∃Z∀x∃yA[x, (Z)y]
(Σ1
1-Col)
where A[u, V ] is an elementary L2 formula and (Z)a is the class given by
(Z)a := {x : ⟨a, x⟩∈Z}.
Clearly, every instance of (Σ1
1-Col) follows from (Σ1
1-AC). However, in NBG also
the converse is the case.
Theorem 2.2. If A[u, V ] is an elementary L2 formula, then we have
NBG + (Σ1
1-Col) ⊢∀x∃Y A[x, Y ] →∃Z∀xA[x, (Z)x].
Proof. We work within NBG + (Σ1
1-Col). Following the pattern of the usual proof
of the well-ordering theorem in ZFC and exploiting the fact that we have global
choice, it is easy to show that there exist a bijective class function W from On to
the collection of all sets. We write W −1 for the inverse of W.
Suppose ∀x∃Y A[x, Y ], where A[u, V ] is an elementary L2 formula. Then by
(Σ1
1-Col) there exists a class Z such that
∀x∃yA[x, (Z)y].
(⋆)

Σ1
1 Choice in a Theory of Sets and Classes
289
Now the function W −1 comes into play in order to associate to any x a unique y
for which A[x, (Z)y]. Namely, by elementary comprehension and (⋆)
Sel := {⟨x, y⟩: A[x, (Z)y] ∧∀z(A[x, (Z)z] →W −1(y) ≤W −1(z))}
is a class function whose domain is the collection of all sets. Finally, if we write S
for the class {⟨x, y⟩: y ∈(Z)Sel(x)}, which exists by elementary comprehension,
we have (S)x = (Z)Sel(x) for all sets x. Hence ∀xA[x, (S)x]. In other words, S is
the required witness for (Σ1
1-AC).
Corollary 2.3. The theories NBG+(Σ1
1-AC) and NBG+(Σ1
1-Col) prove the same
formulas.
In this paper we are interested in the consistency strength of the theories NBG +
(L2-I∈) + (Σ1
1-AC) and NBG + (L2-I∈) + (Σ1
1-Col). The much simpler analysis of
NBG + (Σ1
1-AC) and NBG + (Σ1
1-Col) will be presented elsewhere.
3 The notation system (E0, ◁)
In this section we work within NBG + (L2-I∈) and set up the notation system
(E0, ◁). The underlying idea is very simple: (E0, ◁) is designed to be the analogue
of (ε0, <) with the set of the natural numbers, i.e. the ordinal ω, replaced by the
class of all ordinals. All we have to do is to follow one of the standard introductions
of the ordinal notation system up to ε0 as, for example, in Sch¨utte [15], taking
care of the few additional complications arising by the fact that we now have all
elements of On as basic entities.
Deﬁnition 3.1. By ﬁnite sequences we mean those functions whose domain is a
ﬁnite ordinal; FS is deﬁned to be the class of all ﬁnite sequences,
FS := {f : Fun[f] ∧(∃n < ω)(Dom[f] = n)}.
If we are given n sets a0, . . . , an−1 for some natural number n, we often write
(a0, . . . , an−1) for that element f of FS which satisﬁes Dom[f] = n as well as
(∀i < n)(f(i) = ai).
By elementary comprehension it can be easily shown in NBG that there exists
a binary class relation ◁on FS satisfying the property (I) below. To simplify the
formulation of this property, we abbreviate:
a ◁b := ⟨a, b⟩∈◁
and
a ⊴b := a ◁b ∨a = b.

290
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
In addition, let ◁lex be the lexicographic extension of ◁; i.e. if a and b are ﬁnite
sequences of sets, then a ◁lex b is written for
(Dom[a] < Dom[b] ∧(∀i < Dom[a])(a(i) = b(i))) ∨
(∃i < Dom[a])(i < Dom[b] ∧a(i) ◁b(i) ∧(∀j < i)(a(j) = b(j))).
(I) The binary relation ◁on FS.
For all elements a and b of FS we have
a ◁b if and only if Dom[a] and Dom[b] are at least 2 and one of the following
cases holds:
(1) a(0) = b(0) = 0 ∧a(1) < b(1),
(2) a(0) = 0 ∧0 < b(0),
(3) a(0) = 1 ∧2 ≤b(0),
(4) a(0) = b(0) = 2 ∧a(1) ◁b(1),
(5) a(0) = 2 ∧b(0) = 3 ∧a ⊴b(1),
(6) a(0) = 3 ∧b(0) = 2 ∧a(1) ◁b,
(7) a(0) = b(0) = 3 ∧a ◁lex b.
For the time being, this is a rather weird binary relation on ﬁnite sequences. Its real
meaning will become transparent when restricted to the subclass E0 of FS which
is introduced in (III) and whose deﬁnition is based on ◁.
For every ordinal α we let α be the ﬁnite sequence (0, α). In addition, Ω is
deﬁned to be the ﬁnite sequence (1, 0).
(II) The ω-exponentiation of elements of FS.
There exists a class function ω
which is described by Dom[ω] = FS and, for all elements a of FS,
ω(a) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
ωα
if a = α for some ordinal α,
Ω
if a = Ω,
(2, a) otherwise.
In the following, the function ω will be interesting four us only when restricted
to those ﬁnite sequences which act as notations. They are collected in the class E0
which can be deﬁned be elementary comprehension and is characterized as follows.

Σ1
1 Choice in a Theory of Sets and Classes
291
(III) The class E0 of notations.
E0 is deﬁned to be the smallest subclass of
FS which satisﬁes the following closure properties:
(1) For all ordinals α we have α ∈E0.
(2) Ω ∈E0.
(3) If a ∈E0, then ω(a) ∈E0.
(4) If a0, . . . , an+1 ∈E0 and Ω ⊴an+1 ⊴. . . ⊴a1 ⊴a0, then
(3, ω(a0), ω(a1), . . . , ω(an+1)) ∈E0.
(5) If a0, . . . , an ∈E0 and Ω ⊴an ⊴. . . ⊴a1 ⊴a0 and α ̸= 0, then
(3, ω(a0), ω(a1), . . . , ω(an), α) ∈E0.
The elements of E0 of the form (0, a) code the ordinals, the element (1, 0) =
Ω is the least element greater than the codes of all ordinals, (2, a) codes the ω-
exponentiation of a and (3, a0, . . . , an−1) is for the sum of ω-powers and possibly
the code of an ordinal, given in decreasing order. The proof of the following lemma
is without any problems.
Lemma 3.2. NBG proves that the relation ◁is a strict linear ordering on the class
E0.
In the following we use the small Gothic type letters a, b, . . . (possibly with
subscripts) for elements of E0. Expressions like ∃a(. . .) and ∀a(. . .) are then to
be read as (∃a ∈E0)(. . .) and (∀a ∈E0)(. . .), respectively. For simplicity of
notation, we also write ωa instead of ω(a).
Deﬁnition 3.3. For all positive natural numbers n and all a0, . . . , an−1 ∈E0 we
set
[a0, . . . , an−1] :=
a0
if n = 1 ∧(a0 ⊴Ω ∨∃b(a0 = ωb)),
(3, a0, . . . , an−1) if (3, a0, . . . , an−1) ∈E0.
In all other cases [a0, . . . , an−1] may be taken to be undeﬁned or to have the value
∅.
So every element a of E0 can be uniquely written as [a0, . . . , an−1]. This repre-
sentation is useful for a compact description of the addition of ordinal terms. Once
more, it can be introduced as a binary class function by elementary comprehension
and is characterized by the following properties.

292
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
(IV) Addition of elements of E0.
For all a and b we have:
(1) If a = 0, then a + b = b, if b = 0, then a + b = a.
(2) If a = [a0, . . . , am−1, α] and b = β for some ordinals α and β greater than 0,
then
a + b = [a0, . . . , am−1, α + β].
(3) If a = [a0, . . . , am−1] such that Ω ⊴am−1 and b = β for some ordinal β
greater than 0, then
a + b = [a0, . . . , am−1, b].
(4) If a = [a0, . . . , am−1] and b = [b0, . . . , bn−1] such that Ω ⊴b0, then, if k is
the largest natural number i for which b0 ⊴ai,
a + b = [a0, . . . , ak, b0, . . . , bn−1].
Before turning to the well-ordering of initial parts of E0, a further class function,
describing the ﬁnite addition of ω-powers of elements of E0, has to be introduced.
(V) The function (ω on elements of E0 and ﬁnite numbers.
There exists a
class function (ω which is described by Dom[(ω] = E0 × ω and, for all a and all
n < ω,
(ω(a, n) =
0
if n = 0,
(ω(a, n −1) + ωa if 0 < n < ω.
We omit the proof of the following lemma since it is in complete analogy to the
case of the notation system for (ε0, <).
Lemma 3.4. The following assertions can be proved in NBG:
1. (a + b) + c = a + (b + c).
2. a ◁b + ωc ∧0 ◁c →(∃d ◁c)(∃n < ω)(a ◁b + (ω(d, n)).
Starting with Ω + 1 a sequence of terms which is coﬁnal in E0 is obtained by
simply iterating ω-exponentiation.
Deﬁnition 3.5. For all natural numbers n, the ordinal terms Ωn are inductively
deﬁned by
Ω0 := Ω + 1
and
Ωn+1 := ωΩn.

Σ1
1 Choice in a Theory of Sets and Classes
293
The purpose of the next paragraphs is to show that NBG + (L2-I∈) proves the
well-ordering of the relation ◁on E0 up to each term Ωk for k being any standard
natural number. To do so, we need the following notations.
Deﬁnition 3.6. Let A[u] be an arbitrary formula of the language L2 of NBG. Then
we set:
Prog◁[A] := ∀u((∀v ◁u)A[v] →A[u]),
TI ◁[u, A] := Prog◁[A] →(∀v ◁u)A[v].
A∗[u] := ∀v((∀w ◁v)A[w] →(∀w ◁v + ωu)A[w]).
The ﬁrst two of these formulas express, as usual, the progressiveness of A with
respect to ◁and transﬁnite induction for A along ◁up to u, respectively; A∗is the
jump of A. The core of the well-ordering proofs up to Ωk, for any standard natural
number k, is provided by the following two properties of the jump-operation.
Lemma 3.7. For any formula A[u] of the language L2, we can prove in NBG:
1. Prog◁[A] →Prog◁[A∗].
2. TI ◁[u, A∗] →TI ◁[ωu, A].
All our notations are chosen such that the proof of this lemma can be taken
literally from the proof of the corresponding lemma for notations less than ε0 in
Sch¨utte [15].
Theorem 3.8. For any standard natural number k and for any formula A[u] of the
language L2 we have
NBG + (L2-I∈) ⊢TI ◁[Ωk, A].
Proof. We work informally in NBG + (L2-I∈) and prove this theorem by metain-
duction on k. Assume that k = 0. Then Ωk = Ω + 1 and ∈-induction on the
ordinals yields, for arbitrary L2 formulas A[u],
Prog◁[A] →(∀u ◁Ω)A[u].
By the deﬁnition of progressiveness, this implies
Prog◁[A] →(∀u ◁Ω + 1)A[u],
i.e. TI ◁[Ω0, A]. For k > 0 we have in view of the induction hypothesis for any L2
formulas A[u] that TI ◁[Ωk−1, A∗]. Now we simply have to apply Lemma 3.7 in
order to obtain TI ◁[Ωk, A].

294
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
In connection with the notation system (E0, ◁) it only remains to introduce a
few further notations which will be taken up again towards the end of Section 5.
Deﬁnition 3.9. The classes of limit notations and strong limit notations are deﬁned
by
Lim := {x ∈E0 : x ̸= 0 ∧(∀y ∈E0)(x ̸= y + 1},
SLim := {x ∈Lim : (∀y ∈E0)(x ̸= y + ω}.
In addition, we deﬁne Lim0 := {0} ∪Lim and SLim0 := {0} ∪SLim and, for
any U ⊂E0 and a, b ∈E0,
a ∈U ∩b := a ∈U ∧a ◁b.
This means that the elements of Lim are the analogues of limit ordinals and the
elements of SLim correspond to those limit ordinals which cannot be obtained by
adding ω. Clearly, any Ωn belongs to SLim.
4 Elementary hierarchies
This section begins with introducing the theory NBG<E0 which permits the it-
eration of elementary comprehension up to any Ωk with k a standard natural
number. It is easily veriﬁed afterwards that NBG<E0 is contained in the system
NBG + (L2-I∈) + (Σ1
1-AC).
Deﬁnition 4.1. Let A[U, V, u, v] be an elementary L2 formula with at most the
variables U, V, u, v free. Then we write Hier A[a, U, V ] for the elementary L2 for-
mula
(∀b ◁a)((V )b = {x : A[U, Σ(V, b), x, b]}).
Here Σ(V, b) stands for the class {⟨x, c⟩∈V : c ◁b} representing the disjoint
union of the projections of V up to b.
NBG<E0 is the theory of sets and classes which extends NBG + (L2-I∈) by
claiming the existence of such hierarchies along each initial segment of E0. Hence
the axioms of NBG<E0 comprise the axioms of NBG, the schema (L2-I∈) plus
∀X∃Y HierA[Ωn, X, Y ]
(It-ECA)
for arbitrary elementary L2 formulas A[U, V, u, v] with at most the variables
U, V, u, v free and all standard natural numbers n.

Σ1
1 Choice in a Theory of Sets and Classes
295
Employing (Σ1
1-AC), the following lemma is proved by transﬁnite induction
along ◁up to Ωn, which is available in NBG + (L2-I∈) according to Theorem 3.8.
The argument is very similar to that of second order arithmetic, establishing that
Π0
1-CA<ε0 is a subsystem of Σ1
1-AC, and left to the reader.
Lemma 4.2. Let A[u, v, U, V ] be an elementary L2 formula with at most the vari-
ables u, v, U, V free. For all standard natural numbers n and all class variables
X, the theory NBG + (L2-I∈) + (Σ1
1-AC) then proves
(∀a ◁Ωn)∃Y Hier A[a, X, Y ].
From this lemma we conclude that all axioms (It-ECA) are provable in the
system NBG + (L2-I∈) + (Σ1
1-AC). Therefore, the embedding of NBG<E0 into
NBG + (L2-I∈) + (Σ1
1-AC) is an immediate consequence.
Theorem 4.3. The theory NBG<E0 is contained in NBG+(L2-I∈)+(Σ1
1-AC); i.e.
for all L2 formulas A we have
NBG<E0 ⊢A
=⇒
NBG + (L2-I∈) + (Σ1
1-AC) ⊢A.
For the reduction of NBG + (L2-I∈) + (Σ1
1-Col) to NBG<E0 it is convenient to
have a global well-ordering of the set-theoretic universe at our disposal. Therefore,
let LW be the extension of L2 by a fresh binary relation symbol W and include
formulas W(u, v) into the list of atomic formulas. Then the global well-ordering
axiom states
∀x∃!αW(x, α) ∧∀x∀y∀α(W(x, α) ∧W(y, α) →x = y).
(GWO)
We write NBGW for the theory NBG – now all schemas formulated for LW
formulas – in which the axiom of global choice (GC) has been replaced by
the axiom global well-ordering (GWO). Accordingly, NBGW<E0 is the theory
NBGW + (LW-I∈) extended by the iteration axiom (It-ECA), now formulated for
all elementary LW formulas.
It goes without saying that NBG and NBG<E0 are contained in NBGW and
NBGW<E0, respectively. Moreover, with little effort and by making use of stan-
dard techniques it can even be shown that we have the following theorem.
Theorem 4.4. NBGW is a conservative extension of NBG, and NBGW<E0 is a
conservative extension of NBG<E0, in both cases with respect to all L2 formulas.

296
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
5 Reducing NBG + (L2-I∈) + (Σ1
1-AC) to NBG<E0
The eventual aim of this section is to show that NBG + (L2-I∈) + (Σ1
1-AC) can
be reduced to NBG<E0. In order to achieve this it is sufﬁcient – in view of what
we have achieved so far – to reduce the theory NBGW + (LW-I∈) + (Σ1
1-Col) to
NBGW<E0, where in this context (Σ1
1-Col) is for LW formulas.
In the following we develop, within NBGW<E0, an inﬁnitary sequent calculus
G∞for NBGW + (LW-I∈) + (Σ1
1-Col). For this purpose we code the set variables
as pairs ⟨0, n⟩and the class variables as pairs ⟨1, n⟩, n always a natural number.
Moreover, to any set a we assign the set constant ⟨2, a⟩. For natural numbers n and
sets a we set
hn := ⟨0, n⟩,
Hn := ⟨1, n⟩,
pa := ⟨2, a⟩.
We also ﬁx several elementary class functions deﬁned, for arbitrary sets a, b, c, by
(some are written in inﬁx or another mnemonically suitable notation):
(a ˙∈b) := ⟨3, a, b⟩,
˙W(a, b) := ⟨4, a, b⟩,
˙¬ a := ⟨5, a⟩,
(a ˙∨b) := ⟨6, a, b⟩,
(a ˙∧b) := ⟨7, a, b⟩,
˙∃a b := ⟨8, a, b⟩,
˙∀a b := ⟨9, a, b⟩.
We proceed with our development of G∞within NBGW<E0 and present all formu-
las of G∞as sets, mimicking the build up of the formulas of LW.
Deﬁnition 5.1. The class For ∞is deﬁned to be the smallest class which satisﬁes
the following closure properties:
(1) For all natural numbers m, n and all sets a, b the class For ∞contains
(hm ˙∈hn),
(hm ˙∈pa),
(pa ˙∈hm),
(pa ˙∈pb).
(2) For all natural numbers m, n and all sets a, the class For ∞contains
(hm ˙∈Hn),
(pa ˙∈Hn).
(3) For all natural numbers m, n, all sets a, b, the class For ∞contains
˙W(hm, hn),
˙W(hm, pa),
˙W(pa, hm),
˙W(pa, pb).

Σ1
1 Choice in a Theory of Sets and Classes
297
(4) For all x, y ∈For ∞, the class For ∞also contains
˙¬ x,
(x ˙∨y),
(x ˙∧y).
(5) For all x ∈For ∞and all natural numbers n, the class For ∞also contains
˙∃hn x,
˙∀hn x,
˙∃Hn x,
˙∀Hn x.
This deﬁnition could be reformulated as an explicit elementary formula, for the
prize of being less perspicuous. We are not going to work out the details, only
formulate the corresponding assertion.
Lemma 5.2. For∞is an elementarily deﬁnable class of NBGW<E0.
Clearly, for any sets a and b, (a ˙→b) stands for ( ˙¬ a
˙∨b) and (a ˙↔b) for
((a ˙→b) ˙∧(b ˙→a)); other abbreviations of this sort are used as expected.
It is also elementarily decidable whether a set or class variable occurs freely (in
the usual sense) within an element of For∞. Moreover, there is an elementary
class function Sub taking care of all sorts of simultaneous substitutions of free
occurrences of set and class variables within an element of For∞by constants and
variables of the appropriate sort. For instance, given a ϕ ∈For ∞, a set a and
i1, i2, j, m, n < ω,
Sub(⟨pa, hm, Hn⟩, ⟨hi1, hi2, Hj⟩, ϕ)
is the element of For∞obtained from ϕ by simultaneously replacing all free
occurrences of hi1, hi2 and Hj by pa, hm and Hn, respectively. Also, if ϕ is
given in the form ψ[hi1, hi2, Hj], we often simply write ψ[pa, hm, Hn] instead
of Sub(⟨pa, hm, Hn⟩, ⟨hi1, hi2, Hj⟩, ϕ).
The previous deﬁnition is so that G¨odel numbers, all belonging to For ∞, can be
canonically assigned to the formulas of LW. For this purpose we begin with ﬁxing
an mapping ♮which assigns natural numbers to all set and class variables, making
sure that different variables are mapped onto different natural numbers.
If u, v are set variables and if U is a class variable of LW, we deﬁne
⌜(u ∈v)⌝:= (h♮(u) ˙∈h♮(v)),
⌜(u ∈U)⌝:= (h♮(u) ˙∈H♮(U)),
⌜W(u, v)⌝:=
˙W(h♮(u), h♮(v)).

298
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
The G¨odel numbers of the non-atomic formulas of LW are inductively calculated
in compliance with the equations
⌜¬A⌝:= ˙¬ ⌜A⌝,
⌜(A ∨B)⌝:= (⌜A⌝˙∨⌜B⌝),
⌜(A ∧B)⌝:= (⌜A⌝˙∧⌜B⌝),
⌜∃xA⌝:= ˙∃h♮(x) ⌜A⌝,
⌜∀xA⌝:= ˙∀h♮(x) ⌜A⌝,
⌜∃XA⌝:= ˙∃H♮(X) ⌜A⌝,
⌜∀XA⌝:= ˙∀H♮(X) ⌜A⌝.
The elements of For ∞are called L∞
W formulas and will be denoted by the small
Greek letters θ, ϕ, χ and ψ (possibly with subscripts). To increase the readabil-
ity we often omit the dots when it is clear from the context that we speak about
elements of For ∞.
The set-closed formulas are those L∞
W formulas which do not contain free set
variables (but they may contain free class variables and set constants); the closed
formulas of L∞
W are those L∞
W formulas which contain neither free set variables nor
free class variables. We collect the set-closed formulas in the class SC ∞and the
closed formulas of L∞
W in the class CFor ∞; both classes are elementarily deﬁnable.
The capital Greek letters Θ, Φ, Ψ, . . . (possibly with subscripts) denote ﬁnite
sequences of set-closed formulas.
If Φ is the sequence of set-closed formulas
ϕ1, . . . , ϕm and Ψ the sequence of set-closed formulas ψ1, . . . , ψn, then
⟨12, m, n, ϕ1, . . . , ϕm, ψ1, . . . , ψn⟩
is the sequent with antecedent Φ and succedent Ψ; typically, it will be written as
(Φ ⊃Ψ) or simply as Φ ⊃Ψ.
The elementary, Σ1
1, Σ1 and Π1 formulas of L∞
W are deﬁned analogously to the
corresponding classes of LW formulas; set constants are now, of course, permitted
as parameters.
Looking at the basic set existence and replacement axioms and at the global well-
ordering axiom (GWO) of NBGW, we can convince ourselves that the correspond-
ing axioms, formulated within the language L∞
W, are elementary L∞
W formulas. We
collect the resulting set-closed formulas in the class AX ∞.

Σ1
1 Choice in a Theory of Sets and Classes
299
Deﬁnition 5.3. The degree dg(ϕ) of a set-closed formula ϕ is inductively deﬁned
as follows:
1. If ϕ is a set-closed elementary or Σ1
1 formula of L∞
W, then dg(ϕ) := 0.
2. For all set-closed formulas which are neither elementary nor Σ1
1 we set
dg(¬ψ) := dg(ψ) + 1,
dg(ψ1 ∨ψ2) := max(dg(ψ1), dg(ψ2)) + 1,
dg(ψ1 ∧ψ2) := max(dg(ψ1), dg(ψ2)) + 1,
dg(∃hnψ[hn]) := dg(ψ[p∅]) + 1,
dg(∀hnψ[hn]) := dg(ψ[p∅]) + 1,
dg(∃Hnψ[Hn]) := dg(ψ[Hn]) + 1,
dg(∀Hnψ[Hn]) := dg(ψ[Hn]) + 1.
G∞is an extension of the classical Gentzen sequent calculus LK (cf., e.g., Girard
[8] or Takeuti [17]) by additional axioms and rules of inference which take care of
the non-logical axioms of NBGW. Universal set quantiﬁcation in the succedent
and the corresponding existential set quantiﬁcation in the antecedent are inﬁnitary
rules branching over the collection of all sets. The axioms and rules of G∞can be
grouped as follows.
I. Axioms. For all set-closed elementary formulas ϕ, all elements ψ of AX ∞,
all sets a, b, all set-closed elementary formulas θ[p∅] and all Hm, hn so that no
variable conﬂicts arise:
(A1) ϕ ⊃ϕ,
(A2) ⊃ψ,
(A3) ⊃(pa ∈pb)
if a ∈b,
(A4) ⊃(pa /∈pb)
if a /∈b,
(A5) ⊃∃Hm∀hn(hn ∈Hm ↔θ[hn]).
II. Structural rules. The structural rules of G∞consist of the usual weakening,
exchange and contraction rules.

300
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
III. Propositional rules. The propositional rules of G∞consist of the usual
rules for introducing the propositional connectives on the left and right hand sides
of sequents.
IV. Quantiﬁer rules for sets. Formulated only for succedents; there are also
corresponding rules for the antecedents. For all set variables hn, all set constants
pa and all set-closed formulas ϕ[p∅]:
Φ ⊃Ψ, ϕ[pa]
Φ ⊃Ψ, ∃hnϕ[hn]
,
Φ ⊃Ψ, ϕ[pb]
for all sets b
Φ ⊃Ψ, ∀hnϕ[hn]
.
V. Quantiﬁer rules for classes. Formulated only for succedents; there are also
corresponding rules for the antecedents. By (⋆) we mark those rules where the
designated free class variables are not to occur in the conclusion. For all set-closed
formulas ϕ[H0]and all class variables Hm, Hn so that no variable conﬂicts arise:
Φ ⊃Ψ, ϕ[Hm]
Φ ⊃Ψ, ∃Hnϕ[Hn]
,
Φ ⊃Ψ, ϕ[Hm]
Φ ⊃Ψ, ∀Hnϕ[Hn]
(⋆).
VI. Σ1
1 collection rules. For all set-closed elementary formulas ϕ[p∅, H0] and
all variables hm, Hn, Hk so that no variable conﬂicts arise:
Φ ⊃Ψ, ∀hm∃Hnϕ[hm, Hn]
Φ ⊃Ψ, ∃Hi∀hm∃hnϕ[hm, (Hi)hn]
.
VII. Cuts. For all set-closed formulas ϕ:
Φ ⊃Ψ, ϕ
Φ, ϕ ⊃Ψ
Φ ⊃Ψ
.
The formula ϕ is called the cut formula of this cut; the degree of a cut is the degree
of its cut formula.
Since G∞has inference rules which branch over all sets, namely the rules for in-
troducing universal quantiﬁcation over sets in the succedents and existential quan-
tiﬁcation over sets in the antecedents, inﬁnite proof trees may occur. We conﬁne
ourselves to those whose depths are bounded by initial segments of E0.
Deﬁnition 5.4. Let k be an arbitrary standard natural number. For any notation
a ◁Ωk, any n < ω and any sequent Φ ⊃Ψ, we deﬁne G∞
k
n
a Φ ⊃Ψ by induction
on a.

Σ1
1 Choice in a Theory of Sets and Classes
301
1. If Φ ⊃Ψ is an axiom of G∞, then we have G∞
k
n
a Φ ⊃Ψ for all n < ω.
2. If G∞
k
n
ax Φx ⊃Ψx and ax ◁a for every premise of a rule which is not a cut,
then we have G∞
k
n
a Φ ⊃Ψ for the conclusion Φ ⊃Ψ of this rule.
3. If G∞
k
n
ai Φi ⊃Ψi and ai ◁a for the two premises Φi ⊃Ψi of a cut
(i = 1, 2) whose degree is less than n, then we have G∞
k
n
a Φ ⊃Ψ for the
conclusion Φ ⊃Ψ of this cut.
To be precise, given a standard natural number k, we employ axiom (It-ECA) to
introduce a class U such that, for any a ◁Ωk, the projection (U)a consists of all
pairs (Φ ⊃Ψ, n) for which we have G∞
k
n
a Φ ⊃Ψ.
G∞
k
0
a Φ ⊃Ψ says that there exists a cut-free proof in G∞whose depth is
bounded by the notation a and a ◁Ωk. If we have G∞
k
1
a Φ ⊃Ψ, then only
set-closed formulas which are elementary or Σ1
1 are permitted as cut formulas.
Since the main formulas of all axioms and the main formulas of the conclusions
of all Σ1
1 collection rules are elementary or Σ1
1 formulas of L∞
W, partial cut elimi-
nation – eliminating all cuts whose cut formulas are neither elementary nor Σ1
1 for-
mulas – can be proved following standard patterns; see, for example, Sch¨utte [15].
Theorem 5.5 (Partial cut elimination). Let k be a standard natural number. Then
NBGW<E0 proves for all n < ω, all a ∈E0 such that ωa ◁Ωk and all sequents
Φ ⊃Ψ that
G∞
k
n+2
a
Φ ⊃Ψ
→
G∞
k
n+1
ωa
Φ ⊃Ψ.
The axioms and rules of G∞are so that apart from ∈-induction, all axioms of
NBGW + (Σ1
1-Col) are directly veriﬁed within G∞. For proving the instances of
(LW-I∈) inﬁnite derivations are required in general.
Lemma 5.6. Let k be a standard natural number. Then NBGW<E0 proves for all
set-closed formulas ϕ[p∅]:
1. For all ordinals α, all sets a of set-theoretic rank α and all ordinals β such
that β = ωα + ω + 2,
G∞
k
0
β ∀hm((∀hn ∈hm)ϕ[hn] →ϕ[hm]) ⊃ϕ[pa].
2. G∞
k
0
Ω ∀hm((∀hn ∈hm)ϕ[hn] →ϕ[hm]) ⊃∀hmϕ[hm].

302
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
Proof. We let ψ be the formula ∀hm((∀hn ∈hm)ϕ[hn] →ϕ[hm]) and show the
ﬁrst assertion by induction on α. Given a set a of rank α, the induction hypothesis
implies for all b ∈a
G∞
k
0
γ ψ ⊃ϕ[pb]
(5.1)
where γ := ωα. If b /∈a, then according to (A4) and weakening
G∞
k
0
1 ψ ⊃pb /∈pa.
(5.2)
From (5.1) and (5.2) we conclude, for any set b,
G∞
k
0
γ+1 ψ ⊃pb /∈pa ∨ϕ[pb].
By universal set quantiﬁcation we thus have
G∞
k
0
γ+2 ψ ⊃(∀hn ∈pa)ϕ[hn],
and from this, simple manipulations within G∞also lead to
G∞
k
0
γ+ω ψ, (∀hn ∈pa)ϕ[hn] →ϕ[pa] ⊃ϕ[pa].
Universal set quantiﬁcation and contraction within the antecedent therefore ﬁnish
the proof of our ﬁrst assertion. The second assertion follows from the ﬁrst by a
universal set quantiﬁcation in the succedent.
It is now routine to verify by induction on the lengths of the proofs in the system
NBGW+(LW-I∈)+(Σ1
1-Col) that every theorem of NBGW+(LW-I∈)+(Σ1
1-Col)
is derivable in G∞.
Theorem 5.7. Let k be a standard natural number greater 0 and A a formula of
LW without free set variables. If A is derivable in NBGW + (LW-I∈) + (Σ1
1-Col),
then there exist standard natural numbers m and n such that NBGW<E0 proves
G∞
k
n
Ω+m ⊃⌜A⌝.
Applying Theorem 5.5 ﬁnitely often we can strengthen this theorem to an inter-
pretation of NBGW + (LW-I∈) + (Σ1
1-Col) in G∞with proofs whose cut formulas
are either elementary or Σ1
1 formulas and whose depths are bounded by Ωk for
suitable standard natural numbers k.

Σ1
1 Choice in a Theory of Sets and Classes
303
Corollary 5.8. Let A be a formula of LW without free set variables. If A is
derivable in NBGW + (LW-I∈) + (Σ1
1-Col), then there exists a standard natural
number k such that NBGW<E0 proves that there is a notation a ◁Ωk such that
G∞
k
1
a ⊃⌜A⌝.
The next step is to introduce a truth deﬁnition for the set-closed formulas. This
truth deﬁnition will always depend on a class U such that the class parameters are
interpreted as projections (U)a (a any set) of U and the class quantiﬁers range over
all projections of U; the set quantiﬁers range over the universe of all sets.
In the following we let Lh be the elementary class function which assigns to any
element ϕ of For ∞the number Lh(ϕ) < ω of occurrences of logical connectives
in ϕ. Also, Fω is deﬁned to be the class of all functions with domain ω; i.e. we set
Fω := {f : Fun[f] ∧Dom[f] = ω}.
For an f ∈Fω, a set a and an n < ω, we write f(a|n) for the element of Fω which
maps n to a and otherwise agrees with f.
Deﬁnition 5.9.
1. Sat[U, V, u, v] is deﬁned to be the elementary LW formula
(∃ϕ ∈SC ∞)(∃f ∈Fω)(u = ⟨ϕ, f⟩∧Lh(ϕ) = v
∧A[U, V, f, ϕ]),
where A[U, V, f, ϕ] is the auxiliary formula taken to be the disjunction of the
following clauses:
(1)
∃x∃y(ϕ = (px ˙∈py) ∧x ∈y),
(2)
∃x(∃n < ω)(ϕ = (px ˙∈Hn) ∧x ∈(U)f(n)),
(3)
∃x∃y(ϕ = ˙W(px, py) ∧W(x, y)),
(4)
∃x(ϕ = ˙¬ x ∧⟨x, f⟩/∈V ),
(5)
∃x∃y(ϕ = (x ˙∨y) ∧(⟨x, f⟩∈V
∨⟨y, f⟩∈V )),
(6)
∃x∃y(ϕ = (x ˙∧y) ∧⟨x, f⟩∈V
∧⟨y, f⟩∈V ),
(7)
∃x(∃n < ω)(ϕ = ˙∃hn x ∧∃y(⟨Sub(py, hn, x), f⟩∈V )),
(8)
∃x(∃n < ω)(ϕ = ˙∀hn x ∧∀y(⟨Sub(py, hn, x), f⟩∈V )),
(9)
∃x(∃n < ω)(ϕ = ˙∃Hn x ∧∃y(⟨x, f(y|n)⟩∈V )),
(10) ∃x(∃n < ω)(ϕ = ˙∀Hn x ∧∀y(⟨x, f(y|n)⟩∈V )).

304
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
2. A class V is called a satisfaction hierarchy with respect to U if it satisﬁes
iterating this formula Sat along the natural numbers; i.e.
SH [U, V ] := (∀n < ω)((V )n = {x : Sat[U,

{(V )i : i < n}, x, n]}).
In this deﬁnition, the parameter U codes a universe of classes; the class V col-
lects those pairs ⟨ϕ, f⟩∈SC ∞×Fω such that ϕ is satisﬁed with respect to U if its
class parameters are interpreted according to f. This leads directly to the deﬁnition
of the truth of set-closed formulas with respect to a class U and an f ∈Fω.
Deﬁnition 5.10. For all classes U and sets f, ϕ we set
Tr[U, f, ϕ] := ϕ ∈SC ∞∧f ∈Fω ∧∃X(SH [U, X] ∧⟨ϕ, f⟩∈(X)Lh(ϕ)).
Note that the principle (It-ECA) makes sure that, provable in NBGW<E0, for
every class U there exists a satisfaction hierarchy with respect to U which is essen-
tially unique: if SH [U, V1] and SH [U, V2], then (V1)n = (V2)n for all n < ω. It is
now an easy exercise to verify that this deﬁnition of truth has the expected closure
properties
Lemma 5.11. The theory NBGW<E0 proves, for all classes U, all f ∈Fω, all
set-closed formulas ϕ, ψ, all sets x, y and all n < ω, that
Tr[U, f, (px ˙∈py)] ↔x ∈y,
Tr[U, f, (px ˙∈Hn)] ↔x ∈(U)f(n),
Tr[U, f, ˙W(px, py)] ↔W(x, y),
Tr[U, f, ˙¬ ϕ] ↔¬Tr[U, f, ϕ],
Tr[U, f, (ϕ ˙∨ψ)] ↔(Tr[U, f, ϕ] ∨Tr[U, f, ψ]),
Tr[U, f, (ϕ ˙∧ψ)] ↔(Tr[U, f, ϕ] ∧Tr[U, f, ψ]),
Tr[U, f, ˙∃hnϕ] ↔∃xTr[U, f, Sub(px, hn, ϕ)],
Tr[U, f, ˙∀hnϕ] ↔∀xTr[U, f, Sub(px, hn, ϕ)],
Tr[U, f, ˙∃Hnϕ] ↔∃xTr[U, f(x|n), ϕ],
Tr[U, f, ˙∀Hnϕ] ↔∀xTr[U, f(x|n), ϕ].

Σ1
1 Choice in a Theory of Sets and Classes
305
A further expected property of this truth deﬁnition is that the truth of an set-
closed elementary formula only depends on the interpretation of its class parame-
ters. The following is obvious from, for example, the previous lemma.
Lemma 5.12. In NBGW<E0 we have, for all classes U, V , all f, g ∈Fω and all
set-closed elementary formulas ϕ, that
(∀n < ω)((U)f(n) = (V )g(n)) →(Tr[U, f, ϕ] ↔Tr[V, g, ϕ]).
This deﬁnition of truth reﬂects LW formulas without bound class variables in
the appropriate way. To simplify the formulation of the following lemma, we state
it only for formulas without class parameters.
Lemma 5.13 (Truth reﬂection). Let A be a closed elementary formula of LW and
B a closed Π1 formula of LW. Then the theory NBGW<E0 proves, for any U and
f ∈Fω:
1. A ↔Tr[U, f, ⌜A⌝].
2. B →Tr[U, f, ⌜B⌝].
In the following Elm stands for the class of all elementary L∞
W formulas which
contain h0 as the only free set variable; additional free occurrences of class vari-
ables are permitted. Then we write
Def [U, V, u] := Def 1[U, u] ∨Def 2[U, V, u],
where
Def 1[U, u] := ∃v(u = ⟨0, v⟩∧v ∈U),
Def 2[U, V, u] :=

∃z(∃ϕ ∈Elm)(∃f ∈Fω)(u = ⟨⟨ϕ, f⟩, z⟩
∧Sat[U, V, ⟨Sub(pz, h0, ϕ), f⟩, Lh(ϕ)]).
For carrying through an asymmetric interpretation of the (quasi cut-free) deriva-
tions of the systems G∞
k in Theorem 5.21 below, we need hierarchies of classes
with sufﬁciently strong closure properties. One possible approach to provide such
hierarchies is to turn to an analogue of the constructible hierarchy.
Deﬁnition 5.14. Let k be a standard natural number. Then a class W is said to be
a k-constructible hierarchy if, for all a ∈SLim0 ∩Ωk, b ∈Lim0 ∩Ωk and n < ω,
we have:
(W)a = {⟨⟨x, y⟩, z⟩: x ∈Lim0 ∩a ∧⟨y, z⟩∈(W)x},

306
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
(W)b+(n+1) = {x : Sat[(W)b,

{(W)b+y : 0 < y < (n + 1)}, x, n]},
(W)b+ω = {x : Def [(W)b,

{(W)y : b ◁y ◁b + ω}, x]}.
The following lemma follows more or less directly, by coding two formulas into
one, from the hierarchy axiom of NBGW<E0; its proof can therefore be omitted.
Lemma 5.15. Let k be a standard natural number. Then NBGW<E0 proves the
existence of a k-constructible hierarchy.
Now assume that W is a k-constructible hierarchy. For any a ∈Lim0, the class
(W)a may be considered as a code of the collection of all classes ((W)a)u, where
u is an arbitrary set. The idea of this hierarchy then is as follows:
(i)
(W)0 codes the empty collection of classes.
(ii) For any b ∈Lim0, the successor stages b + (n + 1) are used to collect all
set-closed formulas of length n together with f ∈Fω which are true if their
class parameters are interpreted by projections of (W)b via f and their class
quantiﬁers range over the projections of (W)b.
(iii) At limit stages of the form b + ω the class (W)b+ω collects (W)b and all
classes which are deﬁnable by elementary formulas and interpretations of
class parameters as projections of (W)b.
(iv) At strong limits simply all projections of the previous limit stages are coded
together.
Lemma 5.16. Let k be a standard natural number. Then NBGW<E0 proves for all
k-constructible hierarchies W, all f ∈Fω, all a ∈Lim0 ∩Ωk and all set-closed
formulas ϕ with Lh(ϕ) = n and all ψ ∈Elm:
1. Tr[(W)a, f, ϕ] ↔⟨ϕ, f⟩∈(W)a+(n+1).
2. ((W)a+ω)⟨ψ,f⟩= {x : Tr[(W)a, f, Sub(px, h0, ψ)]}.
The proof of this lemma is by carefully carrying out the informal considerations
above; its details can be left out. Some further useful properties of hierarchies of
this sort are listed in the following lemma. For its formulation and for later use we
introduce the abbreviations
U ˙∈V := ∃x(U = (V )x),
U ˙⊂V := ∀x((U)x ˙∈V ),
U ˙⊂ω V := (∀n < ω)((U)n ˙∈V ).

Σ1
1 Choice in a Theory of Sets and Classes
307
Lemma 5.17. Let k be a standard natural number. Then NBGW<E0 proves for all
k-constructible hierarchies W, all a ∈Lim0 ∩Ωk and all b ∈Lim0 ∩a:
1. (W)a ˙∈(W)a+ω
and
(W)a ˙⊂(W)a+ω.
2. (W)b ˙⊂(W)a
and
(W)b ˙∈(W)a.
Proof. Assume that W, a and b satisfy the assumptions of this lemma.
Then
(W)a ˙∈(W)a+ω follows from (W)a = ((W)a+ω)0. In order to show (W)a ˙⊂
(W)a+ω, pick any set x and an f ∈Fω such that f(0) = x. If ϕ is the elementary
L∞
W formula (h0 ∈H0), then ((W)a)x = ((Wa+ω)⟨ϕ,f⟩. This establishes the ﬁrst
assertion.
If a is an element of SLim0 and b ∈Lim0 ∩a, then (W)b ˙⊂(W)a directly
follows from the deﬁnition of (W)a.
From a ∈SLim0 and b ∈Lim0 ∩a it also follows that b + ω ∈Lim0 ∩a,
hence (W)b+ω ˙⊂(W)a. In view of the ﬁrst assertion this implies (W)b ˙∈(W)a.
A simple transﬁnite induction on a, combined with the ﬁrst assertion, ﬁnishes the
proof of the second.
The formula Tr[U, f, ϕ] interprets the class parameters of ϕ by projections of U
which are provided by the element f of Fω. Sometimes it is more practical to have
them coded into a class V .
Deﬁnition 5.18. For classes U, V and set-closed formulas ϕ we set
TR[U, V, ϕ] := (∃f ∈Fω)((∀n < ω)((V )n = (U)f(n)) ∧Tr[U, f, ϕ]).
For classes V, X, Y and an n < ω we write Y = V (X|n) to express that (Y )n =
X and (Y )m = (V )m for any m < ω which is different from n. Then
TR[U, V, ϕ(X/Hn)] := X ˙∈U
∧∃Y (Y = V (X|n) ∧TR[U, Y, ϕ]).
Hence in TR[U, V, ϕ(X/Hn)] all free occurrences of the class variable Hn within
ϕ are interpreted by X and all others according to V . Naturally, the predicate
TR[U, V, ϕ] inherits the closure properties stated in Lemma 5.11 from Tr[U, f, ϕ].
We collect them for later reference.
Lemma 5.19. The theory NBGW<E0 proves, for all classes U, V , all set-closed
formulas ϕ, ψ, all sets x, y and all n < ω, that

308
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
TR[U, V, (px ˙∈py)] ↔x ∈y,
TR[U, V, (px ˙∈Hn)] ↔x ∈(V )n,
TR[U, V, ˙W(px, py)] ↔W(x, y),
TR[U, V, ˙¬ ϕ] ↔¬TR[U, V, ϕ],
TR[U, V, (ϕ ˙∨ψ)] ↔(TR[U, V, ϕ] ∨TR[U, V, ψ]),
TR[U, V, (ϕ ˙∧ψ)] ↔(TR[U, V, ϕ] ∧TR[U, V, ψ]),
TR[U, V, ˙∃hnϕ] ↔∃xTR[U, V, Sub(px, hn, ϕ)],
TR[U, V, ˙∀hnϕ] ↔∀xTR[U, V, Sub(px, hn, ϕ)],
TR[U, V, ˙∃Hnϕ] ↔(∃X ˙∈U)TR[U, V, ϕ(X/Hn)],
TR[U, V, ˙∀Hnϕ] ↔(∀X ˙∈U)TR[U, V, ϕ(X/Hn)].
Utilizing these properties, it is routine to show (by simultaneous induction on the
length of ϕ and ψ) that set-closed Σ1 formulas are upward persistent and set-closed
Π1 formulas downward persistent.
Lemma 5.20. Let k be a standard natural number. Then NBGW<E0 proves for
all k-constructible hierarchies W, all classes U, all set-closed Σ1 formulas ϕ, all
set-closed Π1 formulas ψ and all a, b ∈Lim0 ∩Ωk:
1. a ◁b ∧TR[(W)a, U, ϕ]
→
TR[(W)b, U, ϕ].
2. a ◁b ∧U ˙⊂ω (W)a
∧TR[(W)b, U, ψ]
→
TR[(W)a, U, ψ].
If Φ and Ψ are ﬁnite sequences of set-closed formulas, (Φ ⊃Ψ)• denotes (the
G¨odel number of) the disjunction whose disjuncts are the negated formulas of Φ
and the formulas of Ψ.
Theorem 5.21. Let k be a standard natural number. In NBGW<E0 we can prove
that, for all k-constructible hierarchies W, all classes U, all ﬁnite sequences Φ
of set-closed Π1 formulas, all ﬁnite sequences Ψ of set-closed Σ1 formulas, all
a ◁Ωk and all b, c ∈Lim0 ∩Ωk, we have the implication
G∞
k
1
a Φ ⊃Ψ ∧b + ωa+1 ⊴c ∧U ˙⊂ω (W)b
→
TR[(W)c, U, (Φ ⊃Ψ)•].
Proof. We show this theorem by induction on a, which is justiﬁed by Theorem 3.8,
and distinguish the following cases:

Σ1
1 Choice in a Theory of Sets and Classes
309
1. Φ ⊃Ψ is an axiom (A1)–(A4) or a conclusion of a structural rule, a proposi-
tional rule, a quantiﬁer rule for set or a quantiﬁer rule for classes. Then the assertion
is trivially satisﬁed, is a consequence of Lemma 5.13 and Lemma 5.19 or follows
from the induction hypothesis.
2. Φ ⊃Ψ is an axiom (A5). Then Φ is empty and Ψ consists of a single
formula ∃Hm∀hn(hn ∈Hm ↔ϕ[hn]), where ϕ[p∅] is a set-closed elementary
formula. In this case, the assertion is a consequence of Lemma 5.16, Lemma 5.19,
and Lemma 5.20.
3. Φ ⊃Ψ is a conclusion of a Σ1
1 collection rule. Then the sequence Ψ is of
the form Ψ0, ∃Hi∀hm∃hnθ[hm, (Hi)hn] for some set-closed elementary formula
θ[p∅, H0], and there exists an a0 ◁a such that
G∞
k
1
a0 Φ ⊃Ψ0, ∀hm∃Hnθ[hm, Hn].
For c0 := b + ωa0+1 the induction hypothesis gives us
TR[(W)c0, U, (Φ ⊃Ψ0, ∀hm∃Hnθ[hm, Hn])•].
Clearly, c0 ◁c, and therefore Lemma 5.17 implies
(W)c0 ˙⊂(W)c
and
(W)c0 ˙∈(W)c.
(5.3)
Now we set θ1[hm] := θ[hm, Hn] and θ2[hm, hn] := θ[hm, (Hi)hn]. Then by
Lemma 5.19
TR[(W)c0, U, (Φ ⊃Ψ0)•] ∨∀x∃yTR[(W)c0, U, θ1[px]((W)c0)y/Hn)],
and a simple persistency argument, see Lemma 5.20, together with (5.3) yields
TR[(W)c, U, (Φ ⊃Ψ0)•] ∨∀x∃yTR[(W)c, U, θ1[px]((W)c0)y/Hn)].
This can also be written as
TR[(W)c, U, (Φ ⊃Ψ0)•] ∨∀x∃yTR[(W)c, U, θ2[px, py]((W)c0/Hi)].
In view of (W)c0 ˙∈(W)c, see (5.3), we continue with
TR[(W)c, U, (Φ ⊃Ψ0)•] ∨(∃Z ˙∈(W)c)∀x∃yTR[(W)c, U, θ2[px, py](Z/Hi)].
By Lemma 5.19 this tells us
TR[(W)c, U, (Φ ⊃Ψ0, ∃Hi∀hm∃hnθ[hm, (Hi)hn])•],

310
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
completing the treatment of this case.
4. Φ ⊃Ψ is a conclusion of a cut. By assumption, its cut formula has to be a
set-closed elementary formula or a set-closed formula of the form ∃Hnθ, where θ
is set-closed elementary. In the remainder we concentrate on the second and more
complicated case. Then there exists a1, a2 ◁a such that
G∞
k
1
a1 Φ ⊃Ψ, ∃Hnθ,
(5.4)
G∞
k
1
a2 Φ, ∃Hnθ ⊃Ψ.
(5.5)
Set c1 := b + ωa1+1 and apply the induction hypothesis to (5.4). Then we obtain
TR[(W)c1, U, (Φ ⊃Ψ, ∃Hnθ)•]
and from that, because of Lemma 5.19,
TR[(W)c1, U, (Φ ⊃Ψ)•] ∨(∃X ˙∈(W)c1)TR[(W)c1, U, θ(X/Hn)].
(5.6)
Furthermore, by an inversion argument (we did not formulate it explicitly but it can
be proved in a straightforward way), assertion (5.5) gives
G∞
k
1
a2 Φ, Sub(⟨Hm⟩, ⟨Hn⟩, θ) ⊃Ψ,
(5.7)
where Hm is a fresh class variable which does not occur in Φ ⊃Ψ and ∃Hnθ. For
c2 := c1 + ωa2+1 and all V ˙⊂ω (W)c1 the induction hypothesis applied to (5.7) –
with a, b and c replaced by a2, c1 and c2, respectively – yields
TR[(W)c2, V, (Φ, Sub(⟨Hm⟩, ⟨Hn⟩, θ) ⊃Ψ)•].
In particular, this is the case for any V
˙⊂ω (W)c1 satisfying (V )m ˙∈(W)c1 as
well as (V )i = (U)i if i < ω and i ̸= m. Once more we apply Lemma 5.19 and
deduce
TR[(W)c2, U, (Φ ⊃Ψ)•] ∨
(∀X ˙∈(W)c1)¬TR[(W)c2, U, Sub(⟨Hm⟩, ⟨Hn⟩, θ)(X/Hm)].
In view of the persistency properties formulated in Lemma 5.20 and an obvious
exchange of variables, TR[(W)c2, U, Sub(⟨Hm⟩, ⟨Hn⟩, θ)(X/Hm)] is equivalent,
for X ˙∈(W)c1, to TR[(W)c1, U, θ(X/Hn)], and it follows that
TR[(W)c2, U, (Φ ⊃Ψ)•] ∨(∀X ˙∈(W)c1)¬TR[(W)c1, U, θ(X/Hn)].

Σ1
1 Choice in a Theory of Sets and Classes
311
Together with (5.6) this implies
TR[(W)c1, U, (Φ ⊃Ψ)•] ∨TR[(W)c2, U, (Φ ⊃Ψ)•].
Since c2 = c1 +ωa2+1 = b+ωa1+1 +ωa2+1 ◁b+ωa+1 ⊴c, Lemma 5.20 proves
TR[(W)c, U, (Φ ⊃Ψ)•], as desired.
Therefore all possible cases for deriving the sequent Φ ⊃Ψ within G∞
k have
been considered, proving our theorem.
Corollary 5.22. Let k be a standard natural number and A a closed elementary
LW formula. Then the theory NBGW<E0 proves, for all a ◁Ωk, that
G∞
k
1
a ⊃⌜A⌝
→
A.
Proof. First of all, Lemma 5.15 implies that there exists a k-constructible hier-
archy W. Then, assuming G∞
k
1
a ⊃⌜A⌝and setting c := ωa+1, the previous
theorem implies TR[(W)c, ∅, ⌜A⌝]. Because of truth reﬂection, c.f. Lemma 5.13,
we therefore also have A.
Theorem 5.23 (Reduction). The theory NBGW + (LW-I∈) + (Σ1
1-Col) can be re-
duced to the theory NBGW<E0 with respect to all closed elementary LW formulas;
i.e. for all closed elementary LW formulas A we have
NBGW + (LW-I∈) + (Σ1
1-Col) ⊢A
=⇒
NBGW<E0 ⊢A.
Proof. Let A be a closed elementary LW formula provable in the theory NBGW +
(LW-I∈) + (Σ1
1-Col). According to Corollary 5.8 we thus have
NBGW<E0 ⊢(∃a ◁Ωk)(G∞
k
1
a ⊃⌜A⌝)
for a suitable standard natural number k.
Hence the previous corollary yields
NBGW<E0 ⊢A.
Corollary 5.24 (Final result). The four theories NBG + (L2-I∈) + (Σ1
1-AC),
NBGW + (LW-I∈) + (Σ1
1-Col), NBGW<E0 and NBG<E0 are equiconsistent.
To prove this summary, we simply recall what we have shown before: In view of
Theorem 4.3, NBG<E0 is contained in NBG+(L2-I∈)+(Σ1
1-AC), which, according
to Corollary 2.3, is equivalent to NBG+(L2-I∈)+(Σ1
1-Col). However, this system
is obviously contained in NBGW + (LW-I∈) + (Σ1
1-Col). The above reduction
theorem provides the reduction of NBGW + (LW-I∈) + (Σ1
1-Col) to NBGW<E0, a
conservative extension of NBG<E0 by Theorem 4.4. Thus the circle is closed.

312
Gerhard J¨ager and J¨urg Kr¨ahenb¨uhl
References
[1] A. Cantini, On the relation between choice and comprehension principles in second
order arithmetic, Journal of Symbolic Logic 51 (1986), 360–373.
[2] S. Feferman, Ordinals and functionals in proof theory, Actes du Congr`es International
des Math´ematiciens (Nice), Gauthier-Villars, 1971, pp. 229–233.
[3]
, Theories of ﬁnite type related to mathematical practice, Handbook of Mathe-
matical Logic (J. Barwise, ed.), North-Holland, 1977, pp. 913–971.
[4]
, Notes on operational set theory, I. Generalization of “small” large car-
dinals in classical and admissible set theory, http://math.stanford.edu/
˜feferman/papers/OperationalST-I.pdf, 2001.
[5]
, Operational set theory and small large cardinals, http://math.
stanford.edu/˜feferman/papers/ostcards.pdf, 2006.
[6] S. Feferman and W. Sieg, Proof-theoretic equivalences between classical and con-
structive theories for analysis, Iterated Inductive Deﬁnitions and Subsystems of Anal-
ysis: Recent Proof-Theoretical Studies (W. Buchholz, S. Feferman, W. Pohlers, and
W. Sieg), Lecture Notes in Mathematics, vol. 897, Springer, 1981, pp. 78–142.
[7] H. Friedman, Iterated inductive deﬁnitions and Σ1
2-AC, Intuitionism and Proof Theory,
Proceedings of the Summer Conference at Buffalo, New York, 1968 (A. Kino, J. My-
hill, and R.E. Vesley, eds.), Studies in Logic and the Foundations of Mathematics,
North-Holland, 1970, pp. 435–442.
[8] J.-Y. Girard, Proof Theory and Logical Complexitiy, Studies in Proof Theory, Bibliopo-
lis, 1987.
[9] G. J¨ager, Beweistheorie von KPN, Archiv f¨ur mathematische Logik und Grundlagen-
forschung 20 (1980), 53–64.
[10]
, On Feferman’s operational set theory OST, Annals of Pure and Applied
Logic 150 (2007), 19–39.
[11]
, Full operational set theory with unbounded existential quantiﬁcation and
power set, Annals of Pure and Applied Logic 160 (2009), 33–52.
[12]
, Operations, sets and classes, Logic, Methodology, and Philosophy of Sci-
ence; Proceedings of the Thirteenth International Congress (C. Glymour, W. Wei, and
D. Westerst˚ahl, eds.), College Publications, King’s College London, 2009, pp. 74–96.
[13] G. J¨ager and T. Strahm, Upper bounds for metapredicative Mahlo in explicit mathe-
matics and admissible set theory, Journal of Symbolic Logic 66 (2001), 935–958.
[14] A. Levy, The role of classes in set theory, Sets and Classes. On the Work by Paul
Bernays (G.-H. M¨uller, ed.), Studies in Logic and the Foundations of Mathematics,
North-Holland, 1976, pp. 277–323.
[15] K. Sch¨utte, Proof Theory, Springer, 1977.

Σ1
1 Choice in a Theory of Sets and Classes
313
[16] W.W. Tait, Normal derivability in classical logic, The Syntax and Semantics of In-
ﬁnitary Languages (J. Barwise, ed.), Lecture Notes in Mathematics, vol. 72, Springer,
1968, pp. 204–236.
[17] G. Takeuti, Proof Theory, Studies in Logic and the Foundations of Mathematics, North-
Holland, 1987.


An Extended Predicative Deﬁnition of the Mahlo
Universe
Reinhard Kahle and Anton Setzer ∗
CENTRIA and Departamento de Matem´atica
Universidade Nova de Lisboa
P–2829-516 Caparica, Portugal
kahle@mat.uc.pt
Department of Computer Science
University of Wales
Singleton Park, Swansea SA2 8PP, UK
a.g.setzer@swan.ac.uk
Abstract In this article we develop a Mahlo universe in Explicit Mathe-
matics using extended predicative methods. Our approach differs from the
usual construction in type theory, where the Mahlo universe has a constructor
that refers to all total functions from families of sets in the Mahlo universe
into itself; such a construction is, in the absence of a further analysis, im-
predicative. By extended predicative methods we mean that universes are
constructed from below, even if they have impredicative characteristics.
1 Predicativity1
After the discovery of set theoretic paradoxes at the end of the 19th and beginning
of the 20th century, especially Burali-Forti’s [BF97] and Russell’s (1901, [Rus02]),
RUSSELL [Rus06] introduced in 1906 the notion of predicativity.
POINCAR´E
(1906, [Poi06]) made this notion more precise and proposed a foundation of math-
ematics, which is entirely based on predicative constructions. A concept is called
predicative, if its deﬁnition only refers to concepts introduced before and therefore
does not presuppose its own existence. Many mathematical notions are introduced
impredicatively. The most prominent example is the set of real numbers deﬁned as
Dedekind cuts.
∗Both authors were supported by the Volkswagen-Stiftung (RiP program at Oberwolfach). The ﬁrst
author was partially supported by the ESF research project Dialogical Foundations of Semantics
within the ESF Eurocores program LogICCC (funded by the Portuguese Science Foundation, FCT
LogICCC/0001/2007). The second author was supported by EPSRC grant EP/G033374/1, Theory
and applications of induction-recursion.
1This historic introduction is partially based on [Fef05].

316
Reinhard Kahle and Anton Setzer
HERMANN WEYL (1918, [Wey18]) was the ﬁrst to carry out a systematic devel-
opment of predicative mathematics. But it soon turned out that signiﬁcant parts
of established mathematics could not be developed using predicative methods.
KREISEL [Kre60] proposed in 1958 that ramiﬁed analysis RA∗, autonomously iter-
ated, should be considered as the limit of predicative analysis. Using proof theoretic
methods KURT SCH ¨UTTE [Sch65b, Sch65a] and SOLOMON FEFERMAN [Fef64]
determined (independently, in 1964-5) Γ0 as the autonomous ordinal of RA∗. (See
also SCH ¨UTTE’s book [Sch77, p. 220] for an excellent presentation and discussion
of this result.) Therefore, in proof theory Γ0 is usually considered as the limit of
predicativity. Because of this result, predicative analysis is rather weak compared
to other, more commonly used mathematical theories (e.g., Zermelo-Fraenkel set
theory or full analysis). Already the ﬁrst substantially impredicative theory ID1 has
a proof theoretic ordinal which is substantially stronger than Γ0.
Before moving beyond Γ0, one should note that the results of reverse mathe-
matics show that a substantial portion of ordinary “mathematical theorems” can
be proven in the theory ATR0, Arithmetical Transﬁnite Recursion, a theory of
strength Γ0, i.e., a theory which is predicative in the proof theoretic sense (see
e.g. [Sim99]).
However, some mathematical theorems require an extension of
ATR0, called (Π1
1-CA)0, which (from a proof theoretic perspective) is substantially
impredicative (it has the strength of ﬁnitely iterated inductive deﬁnitions ID<ω).
For theories whose proof theoretic ordinal is greater than Γ0, but which can
nonetheless be analysed using predicative methods (especially without the use of
collapsing functions), GERHARD J ¨AGER introduced the notion of metapredicativ-
ity. The ﬁrst metapredicative treatment is [J¨ag80], the ﬁrst published metapredica-
tive treatments are [JKSS99] and [Str99].
One should note that there are different understandings of what can be considered
as predicative. For instance, in Martin-L¨of type theory, inductive and inductive-
recursive deﬁnitions (the latter allows to deﬁne strictly positive universes) are in
general considered as predicative, referring to an intuitive understanding of what
is meant by a least set closed under certain monotone operators. With inductive-
recursive deﬁnitions one reaches the strength of KPM ( [DS03], Theorem 6.4.2
and Corollary 6.4.3). A Mahlo Universe has been proposed by the second author
in [Set00] as a predicatively justiﬁed extension of Martin-L¨of Type Theory that
goes beyond even KPM. In this article we explain how a Mahlo universe can in
fact be considered as a predicative construction.
The other extreme position regarding predicativity is the observation that the nat-
ural numbers as deﬁned in Peano Arithmetic can be considered as impredicative:
they are deﬁned as the least set closed under zero and successor, where “least” is
characterized by the induction principle, which refers to the totality of the natural
numbers. So the natural numbers are deﬁned by referring to the totality of natu-

An Extended Predicative Deﬁnition of the Mahlo Universe
317
ral numbers. See EDWARD NELSON [Nel86], DANIEL LEIVANT [Lei94, Lei95],
and CHARLES PARSONS [Par92], where PARSONS refers this to an observation by
MICHAEL DUMMETT (no citation given).
In this article we introduce an extended predicative version of the Mahlo universe
in the context of Explicit Mathematics. The corresponding theory is impredicative
using the proof theoretic understanding (i.e., it goes beyond Γ0; we expect it to
even exceed slightly the strength of KPM). A Mahlo universe M is usually deﬁned
as, roughly speaking, a collection of sets such that for every function f : M →M
there exist a subuniverse sub f of the Mahlo universe closed under f which is an
element of the Mahlo universe. Closure under f means that f : sub f →sub f.
This deﬁnition of M is impredicative, since it refers to the set of total functions
from M into itself, which refers to the totality of M.
Our goal is to introduce the Mahlo universe “from below” so that the deﬁnition
has an extended predicative character. For this we will refer to the collection of
arbitrary, (possibly) partial functions (which is unproblematic from a predicative
point of view). This collection is not directly available in Martin-L¨of Type Theory
but in Explicit Mathematics, a framework developed by SOLOMON FEFERMAN
and further explored by the group of GERHARD J ¨AGER. Therefore we develop the
extended predicative Mahlo universe within the framework of Explicit Mathemat-
ics.
2 Mahloness
Mahlo cardinals were introduced 1911 by PAUL MAHLO [Mah11,Mah12]. Mahlo
cardinals are the ﬁrst substantial step in the development of large cardinals beyond
inaccessible cardinals (weakly inaccessible cardinals were introduced 1908 by FE-
LIX HAUSDORFF [Hau08]). A (weakly) Mahlo cardinal is a cardinal κ which is
(weakly) inaccessible and such that the set of (weakly) inaccessible cardinals less
than κ is stationary in κ, i.e., every closed unbounded set in κ contains a (weakly)
inaccessible cardinal.
For the proof-theoretic analysis of subsystems of analysis, proof theory makes
extensive use of the recursive analogues of large cardinals ( [Poh96, Poh98]).
The recursive analogue of a regular cardinal is an admissible or recursively reg-
ular ordinal κ, which is an ordinal closed under all κ-partial recursive functions.
(See [Hin78], Def. VIII.2.1). Recursively inaccessible ordinals are recursively reg-
ular ordinals κ that are the κth recursively regular ordinal ( [Hin78], Def. VIII.6.1).
The recursive analogue of a Mahlo cardinal is a recursively Mahlo ordinal. An
admissible ordinal κ is a recursively Mahlo ordinal ( [Hin78], Def. VIII.6.7) if for
all f : M →M, which are M-recursive with parameters in M, there exists an

318
Reinhard Kahle and Anton Setzer
admissible κ < M such that ∀α < κ.f(α) < κ. (If one replaces “admissible” by
“recursively inaccessible” in this deﬁnition, one obtains an equivalent deﬁnition.)
Recursively Mahlo sets are sets of the form LM for recursively Mahlo ordinals M.
The theory of recursively regular ordinals is often developed in the context of
Kripke-Platek set theory KP. KP was introduced by RICHARD PLATEK 1966 in his
PhD thesis [Pla66] with a variant introduced independently 1964 by SAUL KRIPKE
[Kri64]. The book of JON BARWISE [Bar75] contains an excellent exposition of
KP, with the historical background described in Notes I.2.7. In the context of KP,
an admissible set ( [Bar75], Def. II.1.1) is a transitive set a which is a model of KP,
where, apart from closure under pair, union and Δ0-separation, the main property
is closure under Δ0-collection: If
b ∈a ∧∀x ∈b.∃y ∈a.ϕ(x, y)
then there exists c ∈a such that
∀x ∈b.∃y ∈c.ϕ(x, y)
for any Δ0-formula ϕ with parameters in a. Recursively inaccessible sets ( [Bar75],
Def. V.6.7) are admissible sets closed under the operation of stepping to the next
admissible set. Recursively Mahlo sets ( [Bar75], Exercise. V.7.25) are admissible
sets adMahlo such that for all Δ0 formulas ϕ(x, y,⃗z) and variables ⃗z such that
⃗z ∈adMahlo ∧∀x ∈adMahlo.∃y ∈adMahlo.ϕ(x, y,⃗z)
there exists an admissible b ∈adMahlo such that
⃗z ∈b ∧∀x ∈b.∃y ∈b.ϕ(x, y,⃗z)
holds. Admissible, recursively inaccessible and recursively Mahlo ordinals are the
supremum of the ordinals in an admissible, recursively inaccessible and recursively
Mahlo set, respectively. Alternatively they are the ordinals α such that Lα is ad-
missible, recursively inaccessible or recursively Mahlo, respectively.
The step towards an analysis of recursively Mahlo ordinals was an important
step in the development of impredicative proof theory. The ﬁrst step in impred-
icative proof theory was the analysis of one inductive deﬁnition by WILLIAM
ALVIN HOWARD ( [How72]) based on the Bachmann Ordinal (introduced by
HEINZ BACHMANN, [Bac50]). Today, this line of research is continued by two
schools in proof theory, one founded by KURT SCH ¨UTTE (see [Sch77]) and one
founded by GAISI TAKEUTI (see [Tak87]). The latter one is based on ordinal dia-
grams which are closer to Gentzen’s original paper [Gen36]. The most productive

An Extended Predicative Deﬁnition of the Mahlo Universe
319
researcher following this approach is TOSHIYASU ARAI who pushed it beyond
(Π1
2-CA) + (BI) [Ara96a,Ara96b,Ara97a,Ara97b,Ara00a,Ara00b,Ara03,Ara04].
In the other school, iterated inductive deﬁnitions were analysed, culminating in a
complete analysis in the seminal monograph [BFPS81] by BUCHHOLZ, POHLERS,
FEFERMAN and SIEG. With GERHARD J ¨AGER’s dissertation [J¨ag79] the focus
shifted from the analysis of subsystems of analysis to the analysis of extensions of
KPω which allowed a much more ﬁne grained development of intermediate the-
ories. Here KPω is KP plus the existence of the set of natural numbers. This
turned out to be very successful with the analysis by WOLFRAM POHLERS and
GERHARD J ¨AGER in 1982 of the equivalent theories KPI, (Δ1
2 −CA) + (BI),
and T0 in [JP82]. Here KPI is KPω plus axioms stating the inaccessibility of the
set theoretic universe, (Δ1
2 −CA) + (BI) is the subsystem of analysis with com-
prehension (CA) restricted to Δ1
2-formulas which is extended by bar induction BI,
and T0 is a system of explicit mathematics discussed in Sect. 3. The article [JP82]
concentrates on the upper bound; the lower bound is based on the embedding of T0
into (Δ1
2 −CA) + (BI) by FEFERMAN [Fef79] and a well-ordering proof for T0
by J ¨AGER [J¨ag83]. A more direct well-ordering proof can be found in [BS83]
and [BS88] by WILFRIED BUCHHOLZ and KURT SCH ¨UTTE. The state-of-the-art
technique for determining upper bounds is based on the simpliﬁed version of local
predicativity by BUCHHOLZ [Buc92]. A constructive underpinning was obtained
by the second author, by carrying out a proof theoretic analysis of Martin-L¨of type
theory [Set98], showing that it is slightly stronger than KPI (see as well indepen-
dent work by MICHAEL RATHJEN and E. GRIFFOR [GR94].)
The ﬁrst signiﬁcant step beyond inaccessibles which are in some sense two level
inductive deﬁnitions, was taken by MICHAEL RATHJEN ( [Rat90, Rat91, Rat94a])
with his analysis of KPM, i.e. KPω with the Mahloness of its universe, and a cor-
responding subsystem of analysis [Rat96]. The second author of this article intro-
duced in [Set00] a Mahlo universe in Martin-L¨of type theory and showed that its
strength goes slightly beyond that of KPM. This provided a ﬁrst constructive under-
pinning of this proof-theoretic development. Later GERHARD J ¨AGER (e.g. [J¨ag05])
introduced a Mahlo universe in Explicit Mathematics (T0(M)), which we will re-
visit in Sect. 4.
The analysis of KPM was the main stepping stone for RATHJEN to jump to an
analysis of KPω with Π3-reﬂection ( [Rat92,Rat94b]) and later of (Π1
2-CA) + (BI) (
[Rat95,Rat05a,Rat05b]).
We look now at the rules and axioms for formulating Mahlo in Explicit Mathe-
matics. There are two versions, internal Mahlo (T0(M)+), corresponding to having
a universe in Explicit Mathematics having the Mahlo property, and external Mahlo
(T0(M)), corresponding to the fact that the overall collection of sets has the Mahlo
property. We ﬁrst focus on the internal Mahlo universe, and then indicate how to

320
Reinhard Kahle and Anton Setzer
modify this in order to obtain the external Mahlo universe.
The ﬁrst part is that a recursively Mahlo set is a recursively inaccessible set (re-
member that we could replace admissibles by recursively inaccessible sets). Recur-
sively inaccessible sets correspond to universes closed under inductive generation,
so in T0(M)+ we demand for some constant M corresponding to the recursively
Mahlo set adMahlo that it is a universe which is closed under inductive generation
(which would correspond in type theory to closure under the W-type, in subsystems
of analysis to the formation of inductively deﬁned sets, and in KP to the formation
of the next admissible above a given set). We note here that the metapredicative
versions are obtained by omitting inductive generation—which is an impredica-
tive concept in the proof theoretic sense. Thus, for metapredicative Mahlo, closure
under inductive generation is omitted.
The assumption for the main closure property of adMahlo is ⃗z ∈adMahlo and
∀x ∈adMahlo.∃y ∈adMahlo.ϕ(x, y,⃗z). We can collect the elements ⃗z together
into one set a and replace the closure under ϕ by a function f ∈(M →M).
The reader with a background in Martin-L¨of Type Theory might wonder why
this is sufﬁcient, since in type theory this assumption is translated as having a func-
tion f ∈(Fam(M) →Fam(M)), where2
Fam(u) := {(a, b) | a ˙∈u ∧b ∈(a →u)} .
The reason why this can be avoided is that for any universe u we can write encoding
functions pair ∈(Fam(u) →u) and decoding functions proj0 ∈(u →u) and
proj1 ∈((x ˙∈u) →proj0 x →u) for families of sets such that for a ˙∈u and b ∈
(a →u) we have proj0 (pair (a, b)) ˙= a and proj1 (pair (a, b)) ˙= b. We use here
notations inherited from dependent type theory, proj1 ∈((x ˙∈u) →proj0 x →u)
means that proj1 is a deﬁned constant such that
∀x ˙∈u.∀y ˙∈proj0 x.proj1 x y ˙∈u .
For this one deﬁnes (using join and arithmetic comprehension)
pair (a, b) := {(0, x) | x ˙∈a} ∪{(1, (x, y)) | x ˙∈a ∧y ˙∈b x} ,
proj0 a := {x | (0, x) ˙∈a} ,
proj1 a x := {y | (1, (x, y)) ˙∈a} .
Now a function f ∈(Fam(u) →Fam(u)) can be encoded as a function g ∈
(u →u) s.t. g x = pair (f (proj0 x, proj1 x)), and a universe u is closed under
f if and only if it is closed under g (modulo ˙=). In the same way we can replace
2The notations ˙∈, ˙=, ˙⊂, ℜand related notions are introduced in Section 3, which introduces as well
the theory T0.

An Extended Predicative Deﬁnition of the Mahlo Universe
321
⃗z occurring above, which would be translated into an element of Fam(u), by one
single element of u.
Assuming the closure of adMahlo under ⃗z and ϕ the recursively Mahlo property
gave us the existence of a recursively inaccessible b containing ⃗z and closed under
ϕ. The existence of b translates into the existence of a subuniverse m (a, f). So
we have m (a, f) is a universe, m (a, f) ⊆M. (Note that in type theory an explicit
embedding from m (a, f) into M needs to be deﬁned, which we can avoid in Ex-
plicit Mathematics because there universes are `a la Russell rather than `a la Tarski).
⃗z ∈b translates into a ˙∈m (a, f) and that adMahlo is closed under ϕ is translated
into f ∈(m (a, f) →m (a, f)). (In type theory it was necessary to introduce
a constructor reﬂecting f in m (a, f), which is implicit in Explicit Mathematics.
Furthermore, in the formulation of the Mahlo universe in [Set00] the parameter a
doesn’t occur. This is because closure under a can be avoided by replacing closure
under f by closure under g such that g x is the union of f x and a.)
Universes in Explicit mathematics are usually not closed under inductive gen-
eration, and we follow this convention. We observe that M needs in addition to
being a universe to be closed under inductive generation. However, m (a, f) does
not need to be closed under inductive generation: We can use again the trick of
encoding of families of sets into sets and deﬁne for every f ∈(M →M) a function
g ∈(M →M) such that u is closed under g if u is closed under f and inductive
generation (modulo ˙=). So we obtain that, even if m (a, f) is not necessarily closed
under inductive generation, there still exists for every f ∈(M →M) a subuniverse
of M closed under f and inductive generation (modulo ˙=).
Up to now, the strength of the rules does not exceed possessing T0 plus the
existence of one universe, since we could easily model m (a, f) := M. What is still
missing is to model that the admissible is an element of M, which is modelled by
m (a, f) ˙∈M
Note that this means that M has a constructor that depends negatively on M, namely
m ∈((M, (M →M)) →M)
This completes the internal version of the Mahlo universe, which can be summa-
rized as follows (notations such as U(t) will be explained in the next section):
U(M) ∧i ∈(M2 →M)
a ˙∈M ∧f ∈(M →M) →m (a, f) ˙⊂M ∧U(m (a, f)) ∧a ˙∈m (a, f)
a ˙∈M ∧f ∈(M →M) →f ∈(m (a, f) →m (a, f)) ∧m (a, f) ˙∈M
An external Mahlo universe is obtained by giving the collection ℜof names for
sets in Explicit Mathematics the rˆole of M. So we obtain as conditions the axioms

322
Reinhard Kahle and Anton Setzer
developed by J ¨AGER (in addition to T0 which contains closure of ℜunder i):
ℜ(a) ∧f ∈(ℜ→ℜ) →U(m (a, f)) ∧a ˙∈m (a, f),
ℜ(a) ∧f ∈(ℜ→ℜ) →f ∈(m (a, f) →m (a, f)).
3 Explicit Mathematics
We work in the framework of Feferman’s Explicit Mathematics, [Fef75,Fef79]. It
was introduced in the 1970s to formalize BISHOP-style constructive mathematics.
Explicit Mathematics is based on a two-sorted language, comprising individuals
(combinatory logic plus additional constants) and types (i.e., collections of individ-
uals). As a general convention, individual constants are given as lower case letters
(or letter combinations) in sans serif font, individual variables as roman lower case
letters, such as x, y, individual terms as roman lower case letters such as r, s, t,
and type variables in roman upper case letters such as U, V, X, Y (we do not use
type constants). Types are named by individuals, which are formally expressed by
a naming relation ℜ(x, U), and one has an axiom expressing that every type has a
name:
∀U.∃x.ℜ(x, U).
Based on the primitive element relation t ∈X, it is convenient to introduce the
following abbreviations:
ℜ(s) := ∃X.ℜ(s, X),
s ˙∈t := ∃X.ℜ(t, X) ∧s ∈X,
∃x ˙∈s.ϕ(x) := ∃x.x ˙∈s ∧ϕ(x),
∀x ˙∈s.ϕ(x) := ∀x.x ˙∈s →ϕ(x),
s ˙⊂t := ∀x ˙∈s.x ˙∈t,
s ˙= t := s ˙⊂t ∧t ˙⊂s,
ℜℜ(s) := ℜ(s) ∧∀x ˙∈s.ℜ(x),
f ∈(ℜ→ℜ) := ∀x.ℜ(x) →ℜ(f x),
f ∈(s →s) := ∀x.x ˙∈s →f x ˙∈s,
f ∈(s2 →s) := ∀x, y.x ˙∈s ∧y ˙∈s →f (x, y) ˙∈s.
The usual starting point of Explicit Mathematics is the theory EETJ of explicit
elementary types with join, cf. [FJ96]. It is based on Beeson’s classical logic of
partial terms (see [Bee85] or [TvD88]) for individuals and classical logic for types.

An Extended Predicative Deﬁnition of the Mahlo Universe
323
The ﬁrst order part is given by applicative theories which formalize partial combi-
natory algebra, pairing and projection, and axiomatically introduced natural num-
bers, cf. [JKS99]. EETJ adds types on the second order level, and axiomatize
elementary comprehension and join as type construction operations. We dispense
here with a detailed description of EETJ which can be found in many papers on Ex-
plicit Mathematics (e.g., [JKS01], [JS02] or [Kah07]). Let us just brieﬂy address
the ﬁnite axiomatization of elementary comprehension and join. For these, we
have the following individual constants in the language: nat (natural numbers), id
(identity), co (complement), int (intersection), dom (domain), inv (inverse image),
and j (join). These constants together make up a set of generators, to which also
belong—depending on the particular theory under consideration—other constants
used to introduce names, such as i (inductive generation) in T0 or m in the ap-
proaches to Mahlo; for the extended predicative version we have also the additional
generators M, pre and sub. From the axiomatization we just give as an example the
one for intersections:
ℜ(a) ∧ℜ(b) →ℜ(int (a, b)) ∧∀x.x ˙∈int (a, b) ↔x ˙∈a ∧x ˙∈b.
The generators for elementary comprehension and join will appear again below
when we deﬁne the notion of universe in Explicit Mathematics as a type which is
closed under elementary comprehension and join.
3.1 Inductive Generation
Let us shortly address the most famous theory of Explicit Mathematics, T0 [Fef75],
which is obtained from EETJ by adding inductive generation and the standard
induction scheme on natural numbers for arbitrary formulae of the language. Using
the abbreviation
Closed(a, b, S) := ∀x ˙∈a.(∀y ˙∈a.(y, x) ˙∈b →y ∈S) →x ∈S
inductive generation is given by the following two axioms, expressing that i (a, b)
is the least ﬁxed point of the operator X →Closed(a, b, X), or the accessible part
of the relation b restricted to a:3
ℜ(a) ∧ℜ(b) →∃X.ℜ(i (a, b), X) ∧Closed(a, b, X),
(IG.1)
ℜ(a) ∧ℜ(b) ∧Closed(a, b, ϕ) →∀x ˙∈i (a, b).ϕ(x).
(IG.2)
3Formulas such as Closed(a, b, ϕ) are to be understood in the obvious way (replace in Closed(a, b, S)
formulas t ∈S by ϕ(t)). This convention will apply later even to formulas where a name for a set
a is replaced by ϕ – then s ˙∈a is to be replaced by ϕ(s).

324
Reinhard Kahle and Anton Setzer
As mentioned before, the theory T0 played an important role in the proof-
theoretic analysis of the proof theoretically equivalent theories (Δ1
2 −CA) + (BI)
and KPI (see [Fef79, J¨ag83]); since T0 has the same strength as KPI, one can say
that inductive generation is a way of formalizing inaccessibility in Explicit Mathe-
matics, and formalizing it “from below”.
3.2 Universes
We now turn to the notion of universes as discussed, for instance, in [JKS01].
In the context of Mahloness, universes are considered by J ¨AGER, STRAHM, and
STUDER [JS01,JS02,Str02,J¨ag05,JS05].
The concept of universes can be introduced as a deﬁned notion: A universe is a
type W such that:
1. all elements of W are names and
2. W is closed under elementary comprehension and join.
For the formal deﬁnition we introduce the auxiliary notation of the closure condi-
tion C(W, a) as the disjunction of the following formulas:
(1) a = nat ∨a = id,
(2) ∃x.a = co x ∧x ∈W,
(3) ∃x.∃y.a = int (x, y) ∧x ∈W ∧y ∈W,
(4) ∃x.a = dom x ∧x ∈W,
(5) ∃f.∃x.a = inv (f, x) ∧x ∈W,
(6) ∃x.∃f.a = j (x, f) ∧x ∈W ∧∀y ˙∈x.f y ∈W.
The formula ∀x.C(W, x) →x ∈W expresses that W is a type closed under
the type constructions of EETJ, i.e., elementary comprehension and join. Now, we
deﬁne a universe as a collection of names which satisﬁes this closure condition,
and we write U(W) to express that W is a universe:
U(W) := (∀x ∈W.ℜ(x)) ∧∀x.C(W, x) →x ∈W .
We write U(t) to express that t is a name of a universe:
U(t) := ∃X.ℜ(t, X) ∧U(X).

An Extended Predicative Deﬁnition of the Mahlo Universe
325
A detailed discussion of the concept of universes in Explicit Mathematics can be
found in [JKS01], including least universes and name induction. Universes can be
considered as a formalization of admissibility. However, since, if one adds induc-
tion axioms expressing least universes or name induction, one reaches inacessibilty,
they can serve as alternatives to inductive generation in T0.
4 Axiomatic Mahlo
The ﬁrst formulation of Mahlo in Explicit Mathematics was given in a metapred-
icative setting by J ¨AGER and STRAHM [JS01]. Its proof theoretic strength was
determined in [Str02] (with the upper bound given in [JS01]) as ϕ ε0 0 0 (with in-
duction restricted to types the strength is ϕ ω 0 0). The non-metapredicative ver-
sion, which is obtained by adding inductive generation, was studied by J ¨AGER and
STUDER [JS02]. The resulting theory T0(M) (Explicit Mathematics with Mahlo)
is deﬁned as the extension of T0 by the following two axioms:
ℜ(a) ∧f ∈(ℜ→ℜ) →U(m (a, f)) ∧a ˙∈m (a, f),
(M1)
ℜ(a) ∧f ∈(ℜ→ℜ) →f ∈(m (a, f) →m (a, f)).
(M2)
The axioms state that for every function from names to names there is a universe
which is closed under f. This universe is deﬁned uniformly in f by use of the
universe constructor m.
An overview over what is known about T0(M) can be found in J ¨AGER’s ar-
ticle [J¨ag05].
Together with THOMAS STUDER [JS02] he determined an up-
per bound for the proof theoretic strength of Explicit Mathematics with impred-
icative Mahlo, using speciﬁc nonmonotone inductive deﬁnitions introduced by
RICHTER [Ric71], see also [J¨ag01]. A lower bound can be combined according to
J ¨AGER [J¨ag05] by using the realization of CZF with Mahloness into Explicit Math-
ematics with the Mahlo universe (SERGEI TUPAILO [Tup03]) together with a not-
worked out adaption of the well-ordering proof by MICHAEL RATHJEN [Rat94a]
for KPM:4
Theorem 4.1. T0(M) ≡KPM and the proof-theoretic ordinal is ΨΩ(εM0+1).
The axiomatization of the universe m (a, f) for a given function f (and given
name a) is impredicative in the following sense: f is assumed to be a total function
from names to names but this totality has to hold, of course, also with respect to
4The second author regards the latter as a good hint why this theorem is true, but details in well-
ordering proofs can be quite tricky and more details need to be worked out before we can regard this
result as a full theorem.

326
Reinhard Kahle and Anton Setzer
the name of the “newly introduced” universe m (a, f). In other words, in order to
verify the premise f ∈(ℜ→ℜ) one already needs to “know” m (a, f).
We call this approach to Mahlo universes axiomatic.
J ¨AGER and STUDER, in [JS02], also consider a variant of T0(M) which is based
on partial functions, partial with respect to the deﬁnedness predicate of the under-
lying applicative theory. It is easy to see from the model construction that this does
not change the proof-theoretic strength. Note that, when we speak about partiality
of functions in the following, we have something else in mind, namely that there
are no “a priori” conditions given on the behaviour of a function outside of the
subuniverse under consideration.
In the given form, T0(M) axiomatizes an “external” Mahlo universe, in the sense
that the “universe” of all names—the extension of ℜ—has the Mahlo property.
However, the collection of all names is not a universe in the deﬁned sense of the
theory.
TUPAILO [Tup03, p. 172, IX] also considers an extension of T0, which he called
T0 +M+, which formalizes an “internal” Mahlo universe, i.e., there is a universe—
in the sense deﬁned within the theory—, named by M which has the Mahlo prop-
erty. We formalise a variant T0(M)+ which consists of the axioms of T0 plus the
following axioms:
U(M) ∧i ∈(M2 →M),
(M+1)
a ˙∈M ∧f ∈(M →M) →m (a, f) ˙⊂M,
(M+2)
a ˙∈M ∧f ∈(M →M) →U(m (a, f)) ∧a ˙∈m (a, f)
∧f ∈(m (a, f) →m (a, f)),
(M+3)
a ˙∈M ∧f ∈(M →M) →m (a, f) ˙∈M
(M+4)
We note some differences to the axioms of T0 + M+ given by TUPAILO:
• In T0 + M+, one has the limit operator u which gives (the name of) the next
universe above a given name (see [Kah97]). Now, M is also closed under this
operator: u : M →M. This is not necessary, since using m we can deﬁne easily
for every universe a universe on top of it m(a, λx.x) (see also [JS02, Sect. 6]).
• Also, ℜis closed under the limit operator u. Since universes are not closed
under inductive generation, adding u most likely doesn’t add any strength to
it. This is at least the case without the Mahlo universe: At the end of Sect. 4
in [JS02] as a consequence of a sophisticated model construction an outline of
the argument is given, why adding closure under u to T0 doesn’t increase its
proof-theoretic strength.

An Extended Predicative Deﬁnition of the Mahlo Universe
327
• T0 + M+ has no parameter a of m, so m only depends on f ˙∈(M →M).
This doesn’t make any difference, since we can deﬁne for every a ˙∈M and
f ∈(M →M) a g : M →M such that a universe is closed under g if and only
if it is closed under f and a. (In Sect. 2 we showed how to encode a family of
sets into a set such that a universe contains the code for the family if it contains
the index and the elements of the family. We can do the same trick and encode
two sets into one. Now let g x be the code for the two sets f x and a, and use
the fact that universes are non-empty.)
• T0 + M+ doesn’t demand m (a, f) ˙⊂M. In this respect, T0(M)+ seems to be
slightly stronger. However, any standard model used for determining an upper
bound will fulﬁl this condition, and the well-ordering proof shouldn’t make
use of it, therefore this condition should not add any proof theoretic strength to
the theory. However, we believe that having this axiom is more aesthetically
appealing, since m (a, f) should be a subuniverse of M.
For the extended predicative version of Mahlo, we formalize an internal Mahlo
universe corresponding to T0(M)+.
5 Extended Predicative Mahlo
We aim to introduce new universes “from below”: given a “potential Mahlo uni-
verse”, i.e., a universe which should have the Mahlo property, we will enlarge this
universe “carefully” by stages such that we get the desired property. The key differ-
ence between this approach compared to the axiomatic approach above is that we
will not assume that f is a total function from names to names, but we will assume
that it is total on the subuniverse which should be closed under f.
5.1 Relative f-Pre-Universe
For a given universe v—which is to be extended to a Mahlo universe—a name a
and a given (arbitrary, possibly partial) function f we ﬁrst deﬁne what it means
that u is (the name of) a pre-universe, containing a, closed under f relative to v.
RPU(a, f, u, v) := (∀x.C(u, x) ∧x ˙∈v →x ˙∈u) ∧
(5.1)
(a ˙∈v →a ˙∈u) ∧
(5.2)
(∀x ∈u.f x ∈v →f x ∈u)
(5.3)

328
Reinhard Kahle and Anton Setzer
fc
c
u
v
a
b
fb
Figure 1: A pre-universe
Thus, for given a, f, and v, a pre-universe u has the following properties:
• u is closed under the generators of EETJ, as long as the generated names are
in v (5.1);
• if a is an element of v, it is an element of u (5.2);
• if f maps an element x of u to an element of v, then f x is in u; i.e., f x cannot
be in v but outside u (5.3).
Figure 1 illustrates a pre-universe. We see that a and f b are included in u, since
they are in v. f c is not (yet) in v, so it is not included in u.
From a foundational point of view, this is a well-understood predicative inductive
deﬁnition and we can introduce a straightforward induction principle to obtain least
f-pre-universes. Using the new generator pre to name a pre-universe u, a least f-
pre-universe pre (a, f, v) is characterized by the following axioms:
I. Least f-pre-universes
(EPM.1)
ℜℜ(v) →RPU(a, f, pre (a, f, v), v).
(EPM.2)
ℜℜ(v) ∧RPU(a, f, ϕ, v) →∀x ˙∈pre (a, f, v).ϕ(x).
With (EPM.2) one gets immediately: ℜℜ(v) →pre (a, f, v) ˙⊂v.

An Extended Predicative Deﬁnition of the Mahlo Universe
329
b
fb
v
f
a
u := pre(a, f, v)
Indep(a, f, u, v)
Figure 2: Indep(a, f, u, v)
5.2 Independence
The f-pre-universes are deﬁned relative to v; what we want is, of course, universes
that no longer depend on v. Formally, we can express this independence by a for-
mula Indep(a, f, u, v) which expresses that the “relativization to v” in the closure
condition of RPU(a, f, u, v) is already fulﬁlled:
Indep(a, f, u, v) := (∀x.C(u, x) →x ∈v)
∧a ˙∈v
∧(∀x ˙∈u.f x ˙∈v)
Figure 2 illustrates what it means for u to be independent of v, in case u =
pre (a, f, v): a ˙∈v and therefore a ˙∈u; for a ˙∈u we have f a ˙∈v and therefore
f a ˙∈u, so u is closed under f. How f operates outside u does not really matter: it
is possible that for some b ˙∈v we have f b ˙̸∈v.
The following lemma follows now directly from the deﬁnitions:
Lemma 5.1.
ℜ(u) ∧ℜℜ(v) ∧RPU(a, f, u, v) ∧Indep(a, f, u, v)
→U(u) ∧a ˙∈u ∧f ∈(u →u).

330
Reinhard Kahle and Anton Setzer
Thus, under the condition Indep(a, f, pre (a, f, v), v), the least f-pre-universes
pre (a, f, v) are actually universes. But the main property is that they are now
independent of v in the sense that an enlargement of v will not change the extension
of pre (a, f, v). This gives them, in fact, their predicative character. Formally this
property is expressed in the following extended predicativity lemma.
Lemma 5.2 (Extended Predicativity). In EETJ + (EPM.1) + (EPM.2) we can
prove:
ℜ(v) ∧ℜℜ(w) ∧Indep(a, f, pre (a, f, v), v) ∧v ˙⊂w
→pre (a, f, v) ˙= pre (a, f, w).
As a corollary we get that an enlargement of v does not inﬂuence the indepen-
dence property considered with respect to the bigger universe.
Corollary 5.3. In EETJ + (EPM.1) + (EPM.2) we can prove:
ℜ(v) ∧ℜℜ(w) ∧Indep(a, f, pre (a, f, v), v) ∧v ˙⊂w
→Indep(a, f, pre (a, f, w), w).
5.3 The Mahlo Universe
Intuitively, the idea to build the Mahlo universe is now to enlarge a potential Mahlo
universe u and pre (a, f, u) in parallel up to the stage that pre (a, f, u) is indepen-
dent of u (and, of course, doing this for all a and f). When the preuniverse is
complete, it will not depend on any future additions to u.
Thus, axiomatically expressed, the Mahlo universe, named by M, has to be a
universe, it has to be closed under inductive generation, and it has to collect, for
every f, provided pre (a, f, M) is complete, an element representing pre (a, f, M)
to it. Since in this case pre (a, f, M) is independent of M, we introduce a new name
sub (a, f) which names the same type as pre (a, f, M), and add this element to M.
Figure 3 illustrates the construction of M: If pre (a, f, M) is independent of M, it
contains a and is closed under f; then the name sub (a, f) is added to M (and the
addition of sub (a, f) to M doesn’t affect the reason for originally adding it to M).
Note again, that how f operates outside pre (a, f, M) does not really matter: it is
possible that for some b ˙∈M we have f b ˙̸∈M, i.e., that M is not closed under f.

An Extended Predicative Deﬁnition of the Mahlo Universe
331
fb
b
M
sub(a, f)
f
a
pre(a, f, M)
Indep(a, f, pre(a, f, M), M)
Figure 3: The extended predicative Mahlo universe
II. Mahlo universe
(EPM.3)
U(M) ∧i ∈(M2 →M).
(EPM.4)
Indep(a, f, pre (a, f, M), M)
→
sub (a, f) ˙∈M
∧
sub (a, f)
˙= pre (a, f, M).
From (EPM.4) the theory will get its strength: Whenever we have a pre-universe
pre (a, f, M), which is independent of M, we will have a name sub (a, f) of this
universe in M. Note that by (EPM.1) pre (a, f, M) is already a pre-universe relative
to M. Therefore, by Lemma 5.1 the premise of (EPM.4) implies that pre (a, f, M)
is in fact a universe which is closed under a and f.
By Lemma 5.2 and Corollary 5.3 we know that independent universes do not
depend on the universe used in the last parameter. Using the additional gener-
ator sub we can get rid of this redundant dependence in the name of the sub-
universe which is actually added to M. More concretely, under the assumption
Indep(a, f, pre (a, f, M), M) the addition of sub (a, f) to M does not affect the uni-
verse named by pre (a, f, M) (or sub (a, f)). “Philosophically spoken”, it does not
affect the reason for its addition.
5.4 M is a Mahlo Universe
To show that M is indeed a Mahlo universe, we interpret T0(M)+ into T0 +
(EPM.1–4). This can be done translating m (a, f) by sub (a, f) and using the
following lemma and theorem.

332
Reinhard Kahle and Anton Setzer
Lemma 5.4.
ℜ(u) ∧U(v) ∧a ˙∈v ∧f ∈(v →v) ∧u ˙⊂v ∧RPU(a, f, u, v)
→Indep(a, f, u, v) ∧U(u) ∧a ˙∈u ∧f ∈(u →u)
Theorem 5.5.
a ˙∈M ∧f ∈(M →M)
→sub (a, f) ˙∈M ∧sub (a, f) ˙⊂M
∧U(sub (a, f)) ∧a ˙∈sub (a, f) ∧f ∈(sub (a, f) →sub (a, f))
It is a straightforward exercise to formalise variants of (EPM.1–4) to capture
an extended predicative external Mahlo universe corresponding to T0(M). These
axioms might seem no more convincing than the axioms of axiomatic Mahlo, which
just express that for every name a and function from names to names we can ﬁnd
a type closed under it. But these axioms are impredicative, since the collection
of names has to have those closure princples. An extended predicative version of
external Mahlo doesn’t have these problems, because the premise for introducing
sub (a, f) doesn’t require f ∈(ℜ→ℜ) which would refer to sub (a, f).
Dag Normann has in [Nor99] developed a domain theoretic construction of a
Mahlo universe and shown that the closure ordinal is the ﬁrst recursively Mahlo
ordinal. It can be regarded as a domain theoretic construction of an extended pred-
icative external Mahlo universe.
5.5 The Least Mahlo Universe
The addition of (EPM.1–4) to T0 yields already a theory of Mahloness with an
appropriate proof-theoretic strength. However, the speciﬁc feature of the given
approach is the possibility to axiomatize a least Mahlo universe.
For this we observe that, working in a set theoretical model of explicit mathe-
matics, the extended predicative Mahlo universe can be deﬁned as the least ﬁxed
point of the following operator
Γ(X) :={x | C(X, x)} ∪{i (a, b) | a, b ∈X}
∪{sub (a, f) | Indep(a, f, pre(a, f, X), X)}
where Corollary 5.3 (adapted to the set theoretical setting) shows that Γ is mono-
tone. The corresponding induction principle in set theory would be
Γ(A) ⊆A →M ⊆A

An Extended Predicative Deﬁnition of the Mahlo Universe
333
which means
(U(A) ∧i ∈(A2 →A)
∧(∀a, f.Indep(a, f, pre (a, f, A), A) →sub (a, f) ∈A))
→M ⊆A
It doesn’t make sense to deﬁne pre (a, f, ϕ) for arbitrary formulas ϕ in Explicit
Mathematics, and therefore we have to restrict the induction on M to “small sets”,
i.e., elements of ℜ. We obtain the following
III. Induction for M
(EPM.5)
U(u) ∧i ∈(u2 →u)
∧(∀f.∀a.Indep(a, f, pre (a, f, u), u) →sub (a, f) ˙∈u)
→M ˙⊂u
Now, the theory EPM of extended predicative Mahlo can be deﬁned as the ex-
tension of T0 by the axioms (EPM.1) – (EPM.5).
Note that such an induction principles as (EPM.5) cannot be formulated in the
axiomatic approach, as the quantiﬁer in the “induction step” has to range over ar-
bitrary functions, not only those which are total from names to names. For the ap-
proach to Mahlo in Martin-L¨of type theory, which is also based on total functions,
the addition of an induction principle leads to a contradiction (see [Pal98, Theorem
6.1]), and this is probably also the case for axiomatic Mahlo in Explicit Mathemat-
ics. As, so far, there is no account for partial functions in Martin-L¨of type theory
which allows to refer to the collection of all terms, there is yet no possibility to
deﬁne an extended predicative version of Mahlo. We note however that we don’t
expect that the induction principles expressing minimality of M strengthen the the-
ory. We expect the situation in this case to be similar to that in Martin-L¨of type
theory, where the second author has shown [Set97] that if one has a universe with
certain closure conditions, one can deﬁne a set corresponding to the least universe
having the same closure conditions—therefore having a least universe doesn’t add
any strength.
6 Remarks on the Analysis of EPM
A proof-theoretic analysis of EPM will be given by the authors elsewhere. As we
formalize an internal Mahlo universe, the strength of EPM is slightly above the
one of KPM. One needs one extra recursively inaccessible above KPM, i.e., a
model of EPM has to be given in KPMI, KPω plus the existence of one recursively
Mahlo ordinal M plus ∀x∃y.Ad(y) ∧x ∈y. For the lower bound one can use an

334
Reinhard Kahle and Anton Setzer
embedding of the theory T0(M)+ and then follow arguments of Tupailo [Tup03] to
get a realization of an appropriate extension of CZF into T0(M)+. It seems to be
feasible to get a lower bound by a well-ordering proof for that extension of CZF.
The argument above would show as well that the theory T0(M)+ has the same
strength as EPM and KPMI.
However, there are still a couple of questions concerning modiﬁcations of the
theory. For instance, in [JKS01], a concept of name strictness is introduced. It
expresses that generators only generate names for appropriate arguments (e.g.,
ℜ(co x) →ℜ(x)).5 In this context, also name induction is considered, which
serves as an alternative to inductive generation or least universes to get a theory
of the strength of T0. The addition of name strictness and/or name induction may
allow to simplify the deﬁnitions of relative f-pre-universe; however, there seems to
be a subtle problem with formulating name strictness for generators of subuniverses
of the Mahlo universe.
Also, one may investigate the potential of the induction axioms, for both the sub-
universes and the Mahlo universe itself, in concrete applications. As noted above,
it is the speciﬁc feature of the extended predicative approach that it allows to for-
mulate such induction axioms.
Finally, the formulation of an extended predicative Mahlo universe in a
metapredicative setting (both with an external and an internal Mahlo universe) is
still lacking. It should result, in principle, from the omission of inductive genera-
tion (and therefore (EPM.3)) and the induction axioms (EPM.2) and (EPM.5), and
one probably needs to add ℜℜ(v) →pre (a, f, v) ˙⊂v, which is no longer prov-
able without (EPM.2). These axioms allow an embedding of the metapredicative
axiomatic external Mahlo universe (Theorem 5.5 holds with this modiﬁcations),
which gives a lower bound for its proof theoretic strength. However one needs to
carefully check whether any other adaptations of the axioms are needed, in order
to avoid obtaining a theory which is stronger than the metapredicative axiomatic
external Mahlo universe.
References
[Ara96a]
Toshiyasu Arai. Proof theory of theories of ordinals I: Reﬂecting ordinals. Draft,
1996.
[Ara96b]
Toshiyasu Arai. Systems of ordinal diagrams. Draft, 1996.
[Ara97a]
Toshiyasu Arai. Proof theory of theories of ordinals II: Σ1 stability. Draft, 1997.
5This concept is analogous to—and motivated by—the usual strictness for deﬁnedness or strictness for
the predicate N for natural numbers in applicative theories, cf. [Kah00].

An Extended Predicative Deﬁnition of the Mahlo Universe
335
[Ara97b]
Toshiyasu Arai. Proof theory of theories of ordinals III: Π1 collection. Draft,
1997.
[Ara00a]
Toshiyasu Arai.
Ordinal diagrams for Π3-reﬂection.
J. Symbolic Logic,
65(3):1375 – 1394, 2000.
[Ara00b]
Toshiyasu Arai. Ordinal diagrams for recursively Mahlo universes. Arch. Math.
Logic, 39(5):353 – 391, 2000.
[Ara03]
Toshiyasu Arai. Proof theory for theories of ordinals. I. Recursively Mahlo ordi-
nals. Ann. Pure Appl. Logic, 122(1 – 3):1 – 85, 2003.
[Ara04]
Toshiyasu Arai. Proof theory for theories of ordinals. II. Π3-reﬂection. Ann.
Pure Appl. Logic, 129(1 – 3):39 – 92, 2004.
[Bac50]
Heinz Bachmann.
Die Normalfunktionen und das Problem der ausgezeich-
neten Folgen von Ordnungszahlen. Vierteljahresschrift der Naturforschenden
Gesellschaft in Z¨urich, XCV:5–37, 1950.
[Bar75]
Jon Barwise. Admissible Sets and Structures. An Approach to Deﬁnability The-
ory. Ω-series. Springer, 1975.
[Bee85]
Michael Beeson.
Foundations of Constructive Mathematics.
Ergebnisse der
Mathematik und ihrer Grenzgebiete; 3.Folge, Band 6. Springer, 1985.
[BF97]
C. Burali-Forti. Una questione sui numeri transﬁniti. Rendiconti del Circolo
Matematico di Palermo (1884 - 1940), 11(1):154 – 164, December 1897. Trans-
lation in [Hei67], pp. 104 – 112.
[BFPS81] Wilfried Buchholz, Solomon Feferman, Wolfram Pohlers, and Wilfried Sieg.
Iterated Inductive Deﬁnitions and Subsystems of Analysis:
Recent Proof-
Theoretical Studies, volume 897 of Lecture Notes in Mathematics.
Springer,
1981.
[BS83]
Wilfried Buchholz and Kurt Sch¨utte. Ein Ordinazahlbezeichnungssystem f¨ur die
beweistheoretische Abgrenzung der Π1
2-Separation und Bar-Induktion. Sitzungs-
berichte der Bayerischen Akademie der Wissenschaften, Math.-Nat. Klasse,
pages 99 – 132, 1983.
[BS88]
Wilfried Buchholz and Kurt Sch¨utte. Proof Theory of Impredicative Subsystems
of Analysis. Bibliopolis, Naples, 1988.
[Buc92]
Wilfried Buchholz.
A simpliﬁed version of local predicativity.
In P. Aczel,
H. Simmons, and S. S. Wainer, editors, Proof Theory. A selection of papers from
the Leeds Proof Theory Programme 1990, pages 115 – 147, Cambridge, 1992.
Cambridge.
[DS03]
Peter Dybjer and Anton Setzer. Induction-recursion and initial algebras. Annals
of Pure and Applied Logic, 124:1 – 47, 2003.
[Fef64]
Solomon Feferman. Systems of predicative analysis. Journal of Symbolic Logic,
29:1 – 30, 1964.

336
Reinhard Kahle and Anton Setzer
[Fef75]
Solomon Feferman. A language and axioms for explicit mathematics. In J. Cross-
ley, editor, Algebra and Logic, volume 450 of Lecture Notes in Mathematics,
pages 87–139. Springer, 1975.
[Fef79]
Solomon Feferman. Constructive theories of functions and classes. In M. Boffa,
D. van Dalen, and K. McAloon, editors, Logic Colloquium 78, pages 159–224.
North–Holland, Amsterdam, 1979.
[Fef05]
Solomon Feferman. Predicativity. In S. Shapiro, editor, The Oxford Handbook of
Philosophy of Mathematics and Logic, pages 590 – 624, Oxford, 2005. Oxford
University Press.
[FJ96]
Solomon Feferman and Gerhard J¨ager. Systems of explicit mathematics with
non-constructive μ-operator. Part II.
Annals of Pure and Applied Logic,
79(1):37–52, 1996.
[Gen36]
Gerhard Gentzen. Die Widerspruchsfreiheit der reinen Zahlentheorie. Mathema-
tische Annalen, 112:493 – 565, 1936.
[GR94]
Edward Griffor and Michael Rathjen. The strength of some Martin-L¨of type
theories. Archive for Mathematical Logic, 33(5):347, 1994.
[Hau08]
Feliz Hausdorff. Grundz¨uge einer Theorie der geordneten Mengen. Mathema-
tische Annalen, 65(4):435 – 505, 1908.
[Hei67]
Jean van Heijenoort. From Frege to G¨odel. Harward University Press, 1967.
[Hei86]
G. Heinzmann. Poincar´e, Russell, Zermelo et Peano. Textes de la discussion
(1906 – 1912) sur les fondements des math´ematiques: des antinomies ´a la
pre´edicativit´e. Albert Blanchard, Paris, 1986.
[Hin78]
P.G. Hinman. Recursion-Theoretic Hierarchies. Springer, 1978.
[How72]
W. A. Howard. A system of abstract constructive ordinals. J. Symbolic Logic,
37:355 – 374, 1972.
[J¨ag79]
Gerhard J¨ager.
Die konstruktible Hierarchie als Hilfsmittel zur beweistheo-
retischen Untersuchung von Teilsystemen der Analysis. PhD thesis, Universit¨at
M¨unchen, 1979. Dissertation.
[J¨ag80]
Gerhard J¨ager. Theories for iterated jumps. Handwritten Notes, 1980.
[J¨ag83]
Gerhard J¨ager. A well-ordering proof for Feferman’s theory T0. Archiv f. Math.
Logik und Grundlagenforschung, 23:65 – 77, 1983.
[J¨ag01]
Gerhard J¨ager. First order theories for nonmonotonic inductive deﬁnitions: Re-
cursively inaccessible and Mahlo. Journal of Symbolic Logic, 66(3):1073–1089,
September 2001.
[J¨ag05]
Gerhard J¨ager. Metapredicative and explicit Mahlo: a proof-theoretic perspec-
tive. In Ren´e Cori, Alexander Razborov, Stevo Todorˇcevi´c, and Carol Wood,
editors, Logic Colloquium 2000, Lecture Notes in Logic, pages 272 – 293. A K
Peters. Association for Symbolic Logic, 2005.

An Extended Predicative Deﬁnition of the Mahlo Universe
337
[JKS99]
Gerhard J¨ager, Reinhard Kahle, and Thomas Strahm. On applicative theories. In
A. Cantini, E. Casari, and P. Minari, editors, Logic and Foundation of Mathemat-
ics, pages 83–92. Kluwer, 1999.
[JKS01]
Gerhard J¨ager, Reinhard Kahle, and Thomas Studer. Universes in explicit math-
ematics. Annals of Pure and Applied Logic, 109(3):141–162, 2001.
[JKSS99] Gerhard J¨ager, Reinhard Kahle, Anton Setzer, and Thomas Strahm. The proof-
theoretic analysis of transﬁnitely iterated ﬁxed point theories. Journal of Sym-
bolic Logic, 64(1):53 – 67, 1999.
[JP82]
Gerhard J¨ager and Wolfram Pohlers. Eine beweistheoretische Untersuchung von
(Δ1
2 −CA) + BI und verwandter Systeme. Sitzungsberichte der Bayer. Akad.
d. Wiss., Math.-Nat. Kl., pages 1 – 28, 1982.
[JS01]
Gerhard J¨ager and Thomas Strahm. Upper bounds for metapredicative Mahlo
in explicit mathematics and admissible set theory. Journal of Symbolic Logic,
66(2):935–958, 2001.
[JS02]
Gerhard J¨ager and Thomas Studer. Extending the system T0 of explicit mathe-
matics: the limit and Mahlo axioms. Annals of Pure and Applied Logic, 114(1–
3):79–101, 2002.
[JS05]
Gerhard J¨ager and Thomas Strahm. Reﬂections on reﬂections in explicit mathe-
matics. Annals of Pure and Applied Logic, 136(1–2):116–133, 2005.
[Kah97]
Reinhard Kahle. Uniform limit in explicit mathematics with universes. Technical
Report IAM-97-002, IAM, Universit¨at Bern, 1997.
[Kah00]
Reinhard Kahle. N-strictness in applicative theories. Archive for Mathematical
Logic, 39(2):125 – 144, February 2000.
[Kah07]
Reinhard Kahle. The applicative realm, volume 40 of Textos de Matem´atica.
Departamento de Matem´atica, Universidade de Coimbra, 2007. Habilitationss-
chrift, Fakult¨at f¨ur Informations- und Kommunikationswissenschaften, Univer-
sit¨at T¨ubingen.
[Kre60]
Georg Kreisel. Ordinal logics and the characterization of informal concepts of
proof. In John A. Todd, editor, Proceedings of the International Congress of
Mathematicians, 14 – 21 Aug 1958, pages 289 – 299, Cambridge, 1960. Cam-
bridge University Press.
[Kri64]
S. Kripke. Transﬁnite recursion on admissible ordinals, I, II (abstracts). J. Sym-
bolic Logic, 29:161 – 162, 1964.
[Lei94]
Daniel Leivant. Ramiﬁed recurrence and computational complexity i: Word re-
currence and poly-time. In Peter Clote and Jeffrey Remmel, editors, Feasible
Mathematics II, pages 320 – 343, New York, 1994. Birkh¨auser-Boston.
[Lei95]
Daniel Leivant.
Intrinsic theories and computational complexity.
In Daniel
Leivant, editor, Logic and Computational Complexity, pages 177 – 194. Springer
Lecture Notes in Computer Science 960, 1995.

338
Reinhard Kahle and Anton Setzer
[Mah11]
Paul Mahlo.
¨Uber linear transﬁnite Mengen.
Berichte ¨uber die Verhand-
lungen der K¨oniglich S¨achsischen Gesellschaft der Wissenschaften zu Leipzig.
Mathematisch-Physische Klasse, 63:187 – 225, 1911.
[Mah12]
Paul Mahlo. Zur Theorie und Anwendung der ϱ0-Zahlen. Berichte ¨uber die
Verhandlungen der K¨oniglich S¨achsischen Gesellschaft der Wissenschaften zu
Leipzig. Mathematisch-Physische Klasse, 64:108 – 112, 1912.
[Nel86]
E. Nelson. Predicative Arithmetic. Princeton University Press, Princeton, 1986.
[Nor99]
Dag Normann. A Mahlo-universe of effective domains with totality. In S. Barry
Cooper and J. Truss, editors, Models and Computability, volume 259 of London
Mathematical Society Lecture Note Series, pages 293 – 312. Cambridge Univer-
sity Press, 1999
[Pal98]
E. Palmgren. On universes in type theory. In G. Sambin and J. Smith, editors,
Twenty ﬁve years of constructive type theory, pages 191 – 204, Oxford, 1998.
Oxford University Press.
[Par92]
Charles Parsons.
Impredicativity of induction.
In Michael Detlefsen, editor,
Proof, Logic and formalization, pages 139 – 161. Routledge, 1992.
[Pla66]
R. Platek. Foundations of recursion theory. PhD thesis, Stanford University,
Standford, California, 1966. Contains Supplement.
[Poh96]
Wolfram Pohlers. Pure proof theory. Bulletin of Symbolic Logic, 2(2):159–188,
1996.
[Poh98]
Wolfram Pohlers. Subsystems of set theory and second order number theory. In
S. Buss, editor, Handbook of Proof Theory, chapter IV, pages 209–335. North-
Holland, 1998.
[Poi06]
H. Poincar´e. Les math´ematiques et la logique. Revue de m´etaphysique et de
morale, 14:294 – 317, 1906. Reprinted in [Hei86], 11 – 53.
[Rat90]
Michael Rathjen. Ordinal notations based on a weakly Mahlo cardinal. Arch.
Math. Log., 29:249 – 263, 1990.
[Rat91]
Michael Rathjen. Proof-theoretical analysis of KPM. Arch. Math. Log., 30:377
– 403, 1991.
[Rat92]
Michael Rathjen. Eine Ordinalzahlanalyse der Π3–Reﬂexion. Habilitationss-
chrift, Westf¨alische Wilhelms–Universit¨at M¨unster, 1992.
[Rat94a]
Michael Rathjen. Collapsing functions based on recursively large cardinals: A
well-ordering proof for KPM. Archive for Mathematical Logic, 33:35–55, 1994.
[Rat94b]
Michael Rathjen. Proof theory of reﬂection. Ann. Pure Appl. Logic, 68:181 –
224, 1994.
[Rat95]
Michael Rathjen. Recent advances in ordinal analysis: Π1
2-CA and related sys-
tems. Bulletin of Symbolic Logic, 1:468 – 485, 1995.
[Rat96]
Michael Rathjen. The recursively Mahlo property in second order arithmetic.
Mathematical Logic Quarterly, 42:59–66, 1996.

An Extended Predicative Deﬁnition of the Mahlo Universe
339
[Rat05a]
Michael Rathjen.
An ordinal analysis of parameter free Π1
2-comprehension.
Arch. Math. Log., 44(3):263 – 362, April 2005.
[Rat05b]
Michael Rathjen. An ordinal analysis of stability. Arch. Math. Logic, 44(1):1 –
62, January 2005.
[Ric71]
Wayne Richter. Recursively Mahlo ordinals and inductive deﬁnitions. In R. O.
Gandy and C. E. M. Yates, editors, Logic Colloquium ’69, pages 273–288. North-
Holland, 1971.
[Rus02]
Bertrand Russell. Letter to Frege. Published in [Hei67], pp. 124 – 125, 1902.
[Rus06]
Bertrand Russell. On some difﬁculties in the theory of transﬁnite numbers and
order types. Proc. London Mathematical Society, 4:29 –53, 1906. Reprinted
in [Rus73], pp. 135 – 164.
[Rus73]
Bertrand Russell. Essays in Analysis. George Braziller, New York, 1973. Edited
by D. Lackey.
[Sch65a]
Kurt Sch¨utte. Einge Grenze f¨ur die Beweisbarkeit der Transﬁniten Induktion in
der verzweigten Typenlogik. Archiv f¨ur Mathematische Logik und Grundlagen-
forschung, 7:45 – 60, 1965.
[Sch65b]
Kurt Sch¨utte. Predicative well-orderings. In J. Crossley and M. Dummett, edi-
tors, Formal Systems and recursive functions. Proc. of the 8th Logic Colloquium
Oxford 1963, pages 280 – 303, Amsterdam, 1965. North Holland.
[Sch77]
Kurt Sch¨utte. Proof Theory. Springer, 1977.
[Set97]
Anton Setzer. Deﬁning the least universe in Martin-L¨of’s type theory. Bulletin
of Symbolic Logic, 3:276 – 277, 1997.
[Set98]
Anton Setzer. Well-ordering proofs for Martin-L¨of type theory. Annals of Pure
and Applied Logic, 92:113 – 159, 1998.
[Set00]
Anton Setzer. Extending Martin-L¨of type theory by one Mahlo-universe. Archive
for Mathematical Logic, 39:155–181, 2000.
[Sim99]
Stephen G. Simpson. Subsystems of second-order arithmetic. Springer, 1999.
[Str99]
Thomas Strahm. First steps into metapredicativity in explicit mathematics. In
S. B. Cooper and J. Truss, editors, Sets and Proofs, pages 383 – 402, Cambridge,
1999. Cambridge University Press.
[Str02]
Thomas Strahm. Wellordering proofs for metapredicative Mahlo. Journal of
Symbolic Logic, 67(1):260–278, 2002.
[Tak87]
G. Takeuti. Proof Theory. North–Holland Publishing Company, Amsterdam,
second edition, 1987.
[Tup03]
Sergei Tupailo. Realization of constructive set theory into explicit mathematics:
a lower bound for impredicative Mahlo universe. Annals of Pure and Applied
Logic, 120(1-3):165 – 196, 2003.

340
Reinhard Kahle and Anton Setzer
[TvD88]
Anne Troelstra and Dirk van Dalen. Constructivism in Mathematics, vol II. North
Holland, 1988.
[Wey18]
Hermann Weyl. Das Kontinuum. Kritische Untersuchungen ¨uber die Grundlagen
der Analysis. Veit, Leipzig, 1918.

ITTMs with Feedback
Robert S. Lubarsky
Dept. of Mathematical Sciences
Florida Atlantic University
777 Glades Rd., Boca Raton, FL 33431, USA
Robert.Lubarsky@alum.mit.edu
Abstract Inﬁnite time Turing machines are extended in several ways to al-
low for iterated oracle calls. The expressive power of these machines is
discussed and in some cases determined.
1 Introduction
Inﬁnite time Turing machines, or ITTMs, introduced in [2], are regular Turing ma-
chines that are allowed to run for transﬁnitely many steps. The only changes to the
standard deﬁnition of a Turing machine that need making are what to do at limit
stages: the head goes to the front of the tape(s), the state entered is a dedicated state
for limits, and the value of each cell is the lim sup of the previous values.
That introductory paper also discussed various kinds of oracles computations and
corresponding jump operators. One such jump operator encodes the information
“does the ITTM with index e on input r converge?” If e is allowed to call an oracle
A, this is called the strong jump A▼of A: {(e, x) | {e}A(x) ↓}. The jump can of
course be used as an oracle itself, and the process iterated: you can, for instance,
ask whether {e}(r) converges, where {e} can itself ask oracle questions of simple
(non-oracle) ITTMs.
We would like to investigate ultimate iterations of this jump, for several reasons.
Iterations of a procedure can lead to new phenomena. A well-known example of
that in a context similar to the current one is transﬁnite iterations of the regular
Turing jump. If you iterate the Turing jump along any well-order that appears along
the way, you get the least admissible set containing your starting set, admissible
computability theory being a quantum leap beyond ordinary computability theory
[1]. Arguably the next example right after this one would be iterations of inductive
deﬁnitions. Admissible set theory is exactly what you need to develop a theory of
positive inductive deﬁnitions, the least ﬁxed point of such being Σ1 deﬁnable over
any admissible set containing the deﬁnition in question (e.g. its parameters) [1].
If the language of least ﬁxed points of positive inductive deﬁnitions is closed in

342
Robert S. Lubarsky
a straightforward manner, you end up with the μ-calculus. Determining the sets
deﬁnable in the μ-calculus is however anything but a straightforward extension of
admissibility, needing a generalization of the notion of reﬂection, gap reﬂection
[3–5]. Something similar happens with ITTMs, as some of the extensions are quite
different from the base case, as we will see.
A potential application of this work is in proof theory. The strongest fragment of
second-order arithmetic for which an ordinal analysis has been done to date is Π1
2
Comprehension [6]. Regular (i.e. non-iterated) ITTMs are already more powerful
than that. Perhaps having descriptions of stronger subsystems of analysis other than
the straightforward hierarchy of Π1
n Comprehension principles will help the proof
theorists make progress.
The goal of this line of inquiry is to examine what kind of iterations of ITTMs
make sense, and to quantify how powerful those iterations are by characterizing the
reals, or what amounts to the same thing ordinals or sets, that can be so written.
This situation is different from that for regular Turing machines, because an ITTM
computation can halt after inﬁnitely many steps, and so ITTMs have the power to
write reals. Hamkins and Lewis insightfully classiﬁed the reals that come up in this
context as writable if they appear as the output of a halting computation, eventu-
ally writable if they are eventually the unchanging content of the output tape for a
divergent computation, and accidentally writable if they appear anywhere on any
tape during any ITTM computation, even if they are overwritten later. The same
concepts apply to ordinals, where an ordinal is writable (resp. eventually, acciden-
tally) if some real coding that order-type is writable (resp. eventually, accidentally).
This distinction among these kinds of reals and ordinals turned out to be crucial to
their characterization, as announced in [7] and detailed in [8], with improved proofs
and other results in [9]. Let λ, ζ, and Σ respectively be the suprema of the writable,
eventually writable, and accidentally writable ordinals.
Theorem 1.1. (Welch) ζ is the least ordinal α such that Lα has a Σ2 elementary
extension, Lλ is the smallest Σ1 substructure of Lζ, and LΣ is the unique Σ2 ex-
tension of Lζ.
The relativization of this theorem to a real parameter holds straightforwardly.
In the next section, we give some notions of the syntax and semantics of these
iterations fundamental to what follows. The three after that each gives a different
kind of extension of ITTMs, and about as much as is currently know about them.
Some are characterized pretty fully, others only to the point where it’s clear that
there’s something very different going on. The ﬁnal section offers a generalization
of the semantics.

ITTMs with Feedback
343
2 Feedback ITTMs and the Tree of Subcomputations
A feedback ITTM (FITTM) is an ITTM with two additional tapes, and an addi-
tional state, which is the oracle query “does the feedback ITTM with program the
content of the ﬁrst additional tape on input the content of the second converge?”
Clearly, the additional tapes are merely an expository convenience, as they could
be coded as dedicated parts of the original tape.
The semantics of feedback ITTMs is deﬁned via the tree of subcomputations.
The idea is that the tree keeps track of oracle calls by having each one be a child
of the calling computation. This tree is in general not itself ITTM computable.
Rather, it is deﬁned within ZF, even if a fragment of ZF would sufﬁce, inductively
on the ordinals. At every ordinal stage, each extant node is labeled with some
computation, and control is with one node.
At stage 0, control is with the root, which we think of as at the top of the down-
ward growing subcomputation tree. The root is labeled with the index (and input,
if any) of the main computation.
At a successor stage, if the node currently in control is in any state other than
the oracle call, action is as with a regular Turing machine. If taking that action
places that machine in a halting state, then, if there is a parent, the parent gets the
answer “convergent” to its oracle call, and control passes to the parent. If there
is no parent, then the current node is the root, and the computation halts. If the
additional step does not place the machine in a halting state, then control stays with
the current node. If the current node makes an oracle call, a new child is formed,
after (to the right of) all of its siblings, labeled with the calling index and parameter;
a new machine is established at that node, with program the given index and with
the parameter written on the input tape; and control passes to that node.
At a limit stage, there are three possibilities. One is that on some ﬁnal segment of
the stages there were no oracle calls, and so control was always at one node. Then
the rules for limit stages of regular ITTMs apply, and the snapshot of the compu-
tation at the node in question is determined (where the snapshot includes all of the
current information about the computation – the state, the tape contents, and so on).
If that snapshot repeats an earlier one, then that computation is divergent. (Here we
are using the standard convention, ﬁrst articulated in [2], that a snapshot qualiﬁes
as repeating only if it guarantees an inﬁnite loop. In point of fact, a snapshot might
be identical to an earlier one, which guarantees that it will recur ω-many times, but
it is possible that at the limit of those snapshots, we escape the loop. So by conven-
tion, a repeating snapshot is taken to be one that guarantees that you’re in a loop.)
At that point, if there is a parent, then the parent gets the answer “divergent” to its
oracle call, and control is passed to the parent. If there is no parent, then the node
in question is the root, and the entire computation is divergent.

344
Robert S. Lubarsky
A second possibility is that coﬁnally many oracle calls were made, and there is
a node ρ such that coﬁnally many of those calls were ρ’s children. Note that such
a node must be unique. Then ρ was active coﬁnally often, and again the rules for
regular ITTMs at limit stages apply. If ρ is seen at that stage to be repeating, then
control passes to ρ’s parent, if any, which also gets the answer that ρ is divergent; if
ρ is the root, then the main computation is divergent. If ρ is not seen to be repeating
at this stage, then ρ retains control and the computation continues.
The ﬁnal possibility is that, among the coﬁnally many oracle calls made, there is
an inﬁnite descending sequence, which is the right-most branch of the tree. This is
bad. It is troublesome, at best, to deﬁne what to do at the next step. Various ways
to avoid this last situation are the subject of the next sections.
3 Pre-Qualiﬁed Iterations
The problem cited above is that the subcomputation tree has an inﬁnite descending
sequence. The most obvious way around that is to ensure that that does not happen,
that the tree is well-founded. That can be enforced by attaching an ordinal to each
node of the tree and requiring that children of a node have smaller ordinals.
That is in essence what is done with the strong jump ∅▼of [2]. ∅▼is {(e, x) |
e(x) ↓}, which is the same thing as labeling the root of the subcomputation tree
with 1, so none of its children, the oracle calls, can themselves make oracle calls.
In unpublished work, Phil Welch has show that ζ∅▼is the smallest Σ2-extendible
limit of Σ2-extendibles, and that λ∅▼and Σ∅▼are such that Lλ∅▼is the least Σ1
substructure of Lζ∅▼, which is itself a Σ2 substructure of LΣ∅▼.
We would like to generalize this to ordinals as large as possible, certainly to
ordinals greater than 1. An ordinal oracle ITTM is an FITTM with not two but
three additional tapes. On the third tape is written a real coding an ordinal α. The
oracle calls allowed are about other ordinal oracle ITTMs, and on the third tape
must be written some ordinal β < α. Since one of the other tapes is for parameter
passing, it is unimportant just how the ordinals are written on the latest tape. With
this restriction, the third outcome above can never happen, and all computations are
well-deﬁned (as either convergent or divergent).
An iterated ITTM, or IITTM, is an FITTM that may make an oracle call about
any ordinal oracle ITTM writing on the third tape any ordinal at all. So an IITTM
is like an ordinal oracle ITTM only the length of the ordinal iteration is not ﬁxed in
advance. Rather, it is limited only by what the machine ﬁgures out to write down.
Deﬁnition 3.1. λit, ζit, and Σit are the respective suprema of the ordinals writable,
eventually writable, and accidentally writable by IITTMs.

ITTMs with Feedback
345
Deﬁnition 3.2. An ordinal α is
• 0-extendible if it is Σ2 extendible,
• β + 1-extendible if it is a Σ2 extendible limit of β-extendibles, and
• γ-extendible (γ a limit) if it is Σ2 extendible and a limit of β-extendibles for
each β < γ.
As pointed out by the referee, the limit clause actually works perfectly well for
all three clauses.
The deﬁnition above relativizes to any parameter x. The corresponding notation
is for α to be β[x]-extendible. Notice that, in the limit case, when γ < α, α is also
the limit of ordinals which are themselves limits of β-extendibles for each β < γ.
Theorem 3.3. For ordinal oracle ITTMs with ordinal α coded by the input real
xα and parameter y, the supremum ζ of the eventually writable ordinals is the
least α[xα, y]-extendible. Moreover, the supremum Σ of the accidentally writable
ordinals is such that LΣ[xα, y] is the (unique) Σ2 extension of Lζ[xα, y], and the
supremum λ of the writable ordinals is such that Lλ[xα, y] is the smallest Σ1 sub-
structure of Lζ[xα, y]. Finally, the writable (resp. eventually, accidentally) reals
are those in the corresponding segment of L[xα, y].
Proof. By induction on α.
α = 0: This is the relativized version of Welch’s theorem cited above.
α = β+1: Let γ be any ordinal less than ζ. Run some machine which eventually
writes γ. Dovetail that computation with the following. Simulate running all ordi-
nal oracle ITTMs with input β and as parameters the output of the ﬁrst machine,
which is eventually γ, and y. This is essentially running a universal machine: clear
inﬁnitely many cells on the scratch tape, split them up into countably many inﬁnite
sequences, and on the ith sequence run a copy of the ith machine. For each of
those simulations, keep asking whether the current output will ever change. (That
is, ask whether the computation that continues that simulation until the output tape
changes, at which point it halts, is convergent.) This is a legitimate question for
the oracle, as β < α. Whenever you get the answer “no,” indicate as much on a
dedicated part of the output tape. Eventually you will get all and only the indices of
the eventually stable computations. So the least β[xα, y]-extendible ordinal is less
than ζ, and so ζ is the limit of such.
Because of this closure under β-extendibility, Lζ[xα, y] can run correctly the
computation of the ordinal oracle ITTMs with input β. So the rest of the proof
– that the computations of eventually writable reals stabilize by ζ, and that the
eventually writable reals form a Σ2 substructure of the accidentally writables and

346
Robert S. Lubarsky
a Σ1 extension of the writables – follows by the same arguments pioneered in [8]
and improved upon in [9]. In order to keep this paper self-contained, and to verify
that the new context here really makes no difference, we present these arguments
here.
Suppose, toward a contradiction, that Lζ[xα, y] satisﬁes some Π2 sentence ϕ,
but LΣ[xα, y] does not. By the nature of Π2 sentences, the set of ordinals ξ ≤Σ
such that Lξ[xα, y] ⊨ϕ is closed, and so contains its maximum. By hypothesis,
that maximum is strictly less than Σ. Take some machine that accidentally writes
each of the ordinals less than Σ. A universal machine will do, for instance, so
we will call this machine u. We also need a machine, say p, which eventually
writes the ϕ’s parameter. It is safe to assume that there is only one parameter, as
ﬁnitely many can be combined into one set by pairing. If no parameter is necessary,
then ∅as a dummy parameter can be used. Our ﬁnal machine, call it e, runs p
and u simultaneously. It takes the output of u and uses it to generate the various
Lξ[xα, y]s. When it ﬁnds such a set modeling ϕ, with parameter the current output
of p, it compares ξ to the current content of the output tape. If the current content
is an ordinal greater than or equal to ξ, nothing is written and the computation
continues. Else ξ is written on the output. Eventually the output of p settles down.
Once that happens, when the largest such ξ ever appears, it will be so written, after
which point it will never be overwritten, making ξ eventually writable. This is a
contradiction.
Regarding λ, suppose Lζ[xα, y] satisﬁes some Σ1 formula ψ with parameters
from Lλ[xα, y]. Consider the computation which ﬁrst computes the parameters
using a halting computation, then runs a machine which eventually writes a witness
to ψ and halts when it ﬁnds one. This is a halting computation for such a witness.
By the foregoing, ζ is α[xα, y]-extendible. That it is the least such is ultimately
because the assertion that any particular cell in a computation stabilizes is Σ2. In
detail, let ζα be the least α[xα, y]-extendible ordinal and Σα its Σ2 extension. Since
stabilization is a Σ2 assertion, any computation has the same eventually stable cells
at ζα as at Σα. Moreover, if δ is a stage beyond which a certain cell is stable in
ζα, the assertion that that cell beyond δ is stable is Π1, so that same δ is also a
stabilization point in Σα. So the snapshot of a computation at ζα is that same at
Σα, and all looping has occurred by then.
α a limit: Since ordinal oracle ITTMs with input α subsume those with input
β < α, ζ is β[xα, y]-extendible for each β < α, and hence, considering successor
βs, a limit of β[xα, y]-extendibles. The rest follows as above.
Theorem 3.4. ζit is the least κ which is κ-extendible, λit its smallest Σ1 substruc-
ture, and Σit its (unique) Σ2 extension.

ITTMs with Feedback
347
Proof. For every α < ζit, the ordinal oracle ITTMs with input α are also IITTMs.
Hence the least α-extendible is ≤ζit, and ζit is a limit of α-extendibles. The rest,
again, follows as above.
4 Freezing Computations
Another way to deal with the possible ill-foundedness of the subcomputation tree
is not to worry about it. That is, while no steps are taken to rule out such compu-
tations, there will be some with perfectly well-founded subcomputation trees, even
if only by accident. We remain positive, and focus our attention on those, where
we have a well-deﬁned semantics, including whether a computation converges or
diverges. So we can deﬁne the reals writable, eventually writable, and accidentally
writable by FITTMs.
Proposition 4.1. Every feedback eventually writable real is feedback writable.
Proof. Let e be a computation which writes a feedback eventually writable real.
Consider an alternative computation which runs e on a dedicated part of the tapes.
Every time e’s output tape changes, the main computation asks the oracle: “Con-
sider the computation which begins at the current snapshot of e, and continues e’s
computation until the output tape changes once more, and then halts. Does that
converge or diverge?” Since e’s tree of subcomputations is well-founded, so is that
of the oracle call, and the oracle call will return a deﬁnite answer. If that answer
is “converge,” then the construction continues; if “diverge”, then the construction
halts. By hypothesis, this computation eventually halts, at which point e’s output is
written on the output tape.
Even worse:
Proposition 4.2. Every feedback accidentally writable real is feedback writable.
Proof. Suppose e is a divergent computation. As in [2], e then has to loop, and does
so already at some countable stage. The sledgehammer way to see that is that there
are only set-many possible snapshots, so if a computation never halts then it has to
repeat itself. As to why that would happen at some countable stage, that follows
from Levy absoluteness. More concretely, the argument in [2] for regular ITTMs
applies unchanged in the current setting. There are only countably many cells. So
only countably many stop changing beneath ℵ1. Moreover, there is some countable
bound α by which those have all stopped changing. List the remaining cells in
an ω-sequence c0, c1, .... Let α0 be the least stage beyond α at which c0 changes.
Inductively, let αn be the least stage beyond αn−1 by which all of c0, c1, ..., cn

348
Robert S. Lubarsky
have changed since stage αn−1. The conﬁguration at stage αω = limn αn repeats
unboundedly beneath ℵ1, and so is a looping stage.
Let α be such that e has already started to loop by α many steps. Suppose we
could write (a real coding) α via a halting computation. Then any real written at
any time during e’s computation would be writable, via the program “write α, then
compute e for the number of steps given by the integer n in the coding of α, then
output whatever’s on e’s tapes then” (with the desired choice of n, of course). So it
sufﬁces to write the looping time of a computation.
First we determine the ﬁrst looping snapshot of the machine. At every stage of
the computation in a simulation of e, the oracle is asked: “Consider the computation
that begins with the current snapshot of e, saves it on a dedicated part of the tape,
and continues with a simulation of e on a different part of the tape, halting whenever
the original snapshot is reached again; does this computation halt?” If the answer is
“no,” the simulation continues. Eventually the answer will be “yes.” That is the ﬁrst
looping snapshot. (Actually, as pointed out in [2], that’s not quite right. A snapshot
can repeat itself, which would then force it to repeat ω-many times, but the limit
could be unequal to that repeating snapshot, and so this loop could be escaped. The
constructions here could be modiﬁed easily enough to avoid this problem.)
The next thing to do would be to write the ordinal number of steps it took to get
to that looping snapshot, and the ordinal number of steps it would take to make one
loop, and then to add them. Since those ordinals are constructed the same way, we
will describe only how to do the second.
During the construction, we will assign integers to ordinals in such a way that
the <-relation will be immediate. The construction will take ω-many stages, during
each of which we will use up countably (or ﬁnitely) many integers, so beforehand
assign to each n ∈ω countably many integers disjointly to be available at stage n.
Furthermore, each integer has its own inﬁnite part of the tape for its scratchwork.
Let Ci (i ∈ω) be the (simulated) ith cell of the tape on which we’re running
(the simulation of) e. We will need to know which cells change value coﬁnally in
the stage of interest (the return of the looping stage) and which don’t. So simulate
the run of e from the looping stage until its reappearance. Every time Ci changes
value, toggle the ith cell on another dedicated tape from 0 to 1 to 0. At the end of
the computation, the ith cell on the dedicated tape will be 0 iff Ci changed value
boundedly often; so it will be 1 iff Ci changed value coﬁnally often.
Stage 0 starts in the looping snapshot, and is itself split into ω-many steps. Those
steps interleave consideration of the cells that changed boundedly often and those
that change coﬁnally. At step 2i continue the computation until the ith cell with
bounded change stops changing. That can be determined by asking the oracle
whether the cell in question changes before the looping snapshot reappears. While
this is not a converges-or-diverges question on the face of it, since the computation

ITTMs with Feedback
349
converges in any case (either when the cell changes or when the looping snapshot
is reached, whichever happens ﬁrst), one of those outcomes can be changed to a
trivial loop, so that the question is a standard oracle call. If the answer is “yes,”
then continue the computation until the answer becomes “no,” which is guaran-
teed to happen. At that point, use an available integer to mark that ordinal stage,
which integer is then larger in the ordinal ordering than all other integers used so
far. Also write the current snapshot in that integer’s scratchwork part of the tape.
Then proceed to the next step, 2i + 1.
At step 2i + 1, we will consider not just the ith coﬁnally changing cell, but also
the jth such for all j ≤i, for purposes of dovetailing. Sequentially for each j
from 0 to i, go to the next stage at which the jth coﬁnally changing cell changes
value again. After doing so for i, use an available integer to mark that ordinal stage,
which integer is then larger in the ordinal ordering than all other integers used so
far. Also write the current snapshot in that integer’s scratchwork part of the tape.
Then proceed to step 2(i + 1).
Because stage 0 consists of ω-many steps, each of which picks out only one
integer in an increasing sequence, it picks out a strictly increasing ω-sequence of
ordinals. The limit of that ordinal sequence is the ordinal in the computation at
which its looping snapshot reappears. That’s because by then we’re beyond the
ordinal at which any cell with boundedly many changes will change again, thanks
to the even steps, and those cells with coﬁnal changing change coﬁnally in that
ordinal, thanks to the dovetailing in the odd steps.
To summarize, we have produced an ω-sequence coﬁnal in the ordinal at which
the looping snapshot reappears. Inductively, suppose at stage i > 0 we have an in-
teger assignment, with <, to a subset of e’s ordinal stage, as well as a picture of the
snapshot of the computation each at such stage of the computation. Then for each
integer which is a successor in this partial assignment, replicate the construction
above with the starting snapshot being the snapshot of e at the predecessor and the
ending snapshot being the snapshot of e at the integer under consideration. By the
well-foundedness of the ordinals, this process ends after ω-many stages.
It is easy to see that the feedback writable reals are those contained in the initial
segment of L given by the feedback writable ordinals, which are also the FITTM
clockable ordinals. We call the set of these ordinals Λ.
This result removes the basis of the analysis used in weaker forms of ITTM com-
putation. It comes about because the divergence of a computation in this paradigm
can be determined convergently by a computation of the same type. Why doesn’t
this run afoul of some kind of diagonalization result? The answer is that there’s no
universal machine! That is, the computations and oracle calls used in the proofs

350
Robert S. Lubarsky
above were sometimes convergent and sometimes divergent, but conveniently they
were in any case all well-deﬁned: the tree of subcomputations was well-founded.
If it is not, we have no semantical notion of how the computation should continue
or what the outcome should be. This notion is captured in the following.
Deﬁnition 4.3. A computation is freezing if its tree of subcomputations is ill-
founded.
Proposition 4.4. There is no FITTM computation which decides on an input e
whether the eth FITTM is freezing.
Proof. If there were, you could diagonalize against the non-freezing computations,
for a contradiction.
We expect that as with most models of computation, the key to understanding
what’s computable will be an analysis of the uncomputable. While the freezing
computations do not have an output or even a divergent computation, they are per-
fectly well-deﬁned up until the point when an oracle call is made about a freezing
subcomputation. For that matter, on the tree of subcomputations, that freezing
subcomputation generates a good tree underneath it, until it calls its own freezing
subcomputation. More generally, even for a freezing computation, its subcomputa-
tion tree, albeit ill-founded, is well-deﬁned. Hence the following deﬁnition makes
sense.
Deﬁnition 4.5. A real is freezingly writable if it appears anywhere on a tape dur-
ing a freezing computation or any of its subcomputations.
We expect that the role that the eventually and accidentally writable reals played
in the understanding of the writable reals for basic ITTMs will be played here by
the freezingly writable reals. In any case, it should be of interest to understand
better the freezing computations. Centrally, what does the subcomputation tree of
a freezing computation look like? Since the computation cannot continue once an
inﬁnite path through the tree develops, that inﬁnite path is unique, and is the right-
most path. So each of the ω-many levels on the tree has width some successor
ordinal. For each freezing computation e, let λe
n be the width of level n of e’s
subcomputation tree. For a ﬁxed e, there are three possibilities for the λe
ns:
a) λe
n is bounded beneath Λ.
b) λe
n is coﬁnal in Λ.
c) Some λe
n is greater than Λ.
Option a) is simply unavoidable: it is a simple task to write a machine which
immediately makes an oracle call about itself, producing a subcomputation tree of
order-type ω∗(ω backwards).

ITTMs with Feedback
351
Options b) and c), as it turns out, are incompatible with each other. To see this,
ﬁrst note that if c) holds for some computation, then n can be chosen to be 1 (level
0 consisting of the root alone). After all, if this is not the case for some given e,
let e1 be some computation that halts at a stage larger than maxm<n λe
m. Use e1 to
write e1’s run-time (using methods like those in the main proposition above). Use
that ordinal to run e substituting for the oracle calls an explicit computation until
the right-most node on level n −1 (of e’s original subcomputation tree) becomes
active. That is the node which has more than Λ-many children, and which is now
the root node of the tree of this modiﬁed computation.
Now assume we have indices eb and ec of types b and c respectively (and λec
1 >
Λ). Simulate ec. Whenever an oracle call is made, write the new length of the
top level in the subcomputation tree (using techniques as above). Use that ordinal
to simulate the computation of eb substituting explicit computation for oracle calls
and building explicitly the subcomputation tree. Whenever the run of eb demands
an ordinal greater than that provided by ec yet, break off the former computation
and return to the latter. By hypothesis, at a certain point you will be able see that
eb’s subcomputation tree is ill-founded. Then write supn∈ω λeb
n , and halt. This
would then be a halting computation of Λ, contradiction.
Unfortunately, we do not know which of b) or c) is excluded. For that matter,
there could be no examples of either! Possibly all freezing computations are of type
a), where those bounds over all freezing es are coﬁnal in Λ.
5 Parallel Oracle Calls
With sequential computation, as deﬁned above, once an ill-founded oracle call is
made, the entire computation is freezing. Parallel computation provides an alter-
native. In its essence, this is the same as with ﬁnite computation. In that setting,
what should be the semantics of “A or B”? That both converge and one is true, or
that one is true regardless of whether the other even converges? Similarly here, a
machine could make a parametrized oracle call. This is perhaps most easily mod-
eled by having another tape as part of the oracle call. The called computation asks
for the convergence of a computation with index given on the ﬁrst tape and inputs
the second and third tapes. When making a call, the third tape is blank, but in gen-
erating the answer, the oracle substitutes all possible ﬁnite strings (equivalently:
all integers) on the blank tape. If any return a convergent computation, the oracle
answers “yes.” If none of them freeze and all return a divergent computation, the
oracle answers “no.” If at least one of the parallel calls freezes and all those that do
not diverge, then the oracle gives no answer and the current computation freezes.
Notice that the roles of convergence and divergence could be interchanged here,
as convergent and divergent computations can be interchanged with each other:

352
Robert S. Lubarsky
given e, ask the oracle whether e converges; if yes, diverge, if no, halt. Of course,
if e freezes, so does this.
Arguments similar to those above show that the parallel writable, parallel even-
tually writable, and parallel accidentally writable reals are all the same.
Although it seems likely, we do not have a proof that the parallel writable reals
include strictly more than the feedback writables do.
6 Extending Convergence and Divergence Consistently
For both (sequential) feedback and parallel computation above, the semantics was
given conservatively. That is, the convergence/divergence answers to oracle calls
were forced on us. Evidence for such was an explicit computation in which some
tree was well-founded, as so is absolute. Once well-foundedness is brought into the
picture, induction cannot be too far behind. In fact, the process can be described
via an inductive deﬁnition.
Let ↓and ↑be a disjoint pair of sets of computation calls, where a computation
call is a pair consisting of (an index for) a program and a parameter. Given (↓, ↑),
computations can be deﬁned as convergent or divergent relative to that pair. For the
sake of concreteness we will restrict attention to feedback computation; analogous
considerations apply to parallel computation. When making oracle calls, the given
pair (↓, ↑) is used as the oracle. This is deterministic, as ↓and ↑are disjoint. It
is also monotonic: any computation that asks only oracle calls already in ↓or ↑
will be unaffected by increasing either or both of those; all other computations
are freezing, and so can only thaw by increasing those. As a monotonic operator,
it has a least ﬁxed point. This is the semantics given for feedback computation,
that is the sense in which the semantics was conservative. This description of the
matter does allow for considering other ﬁxed points as possible semantics for these
computational languages.
References
[1] Jon Barwise, Admissible Sets and Structures, Perspectives in Mathematical Logic,
Springer, 1975
[2] Joel Hamkins and Andy Lewis, “Inﬁnite Time Turing Machines,” The Journal of
Symbolic Logic, v. 65 (2000), p. 567-604
[3] Robert Lubarsky, “Building Models of the μ-calculus,” unpublished
[4] Robert Lubarsky, “μ-deﬁnable Sets of Integers,” Journal of Symbolic Logic, v. 58
(1993), p. 291-313

ITTMs with Feedback
353
[5] Michael M¨ollerfeld, “Generalized Inductive Deﬁnitions,” Ph.D. thesis, Universit¨at zu
M¨unster, 2002
[6] Michael Rathjen, “Recent Advances in Ordinal Analysis,” The Bulletin of Symbolic
Logic, v. 1 (1995), p. 468-485
[7] Philip Welch, “The Length of Inﬁnite Time Turing Machine Computations,” The Bul-
letin of the London Mathematical Society, v. 32 (2000), p. 129-136
[8] Philip Welch, “Eventually Inﬁnite Time Turing Machine Degrees: Inﬁnite Time De-
cidable Reals,” The Journal of Symbolic Logic, v. 65 (2000), p. 1193-1203
[9] Philip Welch, “Characteristics of Discrete Transﬁnite Turing Machine Models: Halt-
ing Times, Stabilization Times, and Normal Form Theorems,” Theoretical Computer
Science, v. 410 (2009), p. 426-442


Logspace without Bounds
Isabel Oitavem∗
Dept. Matem´atica, Faculdade de Ciˆencias e Tecnologia
Universidade Nova de Lisboa
P-2829-516 Caparica, Portugal
oitavem@fct.unl.pt
Abstract This paper provides a recursion-theoretic characterization of the
functions computable in logarithmic space, without explicit bounds in the
recursion schemes. It can be seen as a variation of the Clote and Takeuti
characterization of logspace functions [7], which results from the implemen-
tation of an intrinsic growth-control within an input-sorted context.
Keywords. Implicit complexity, logarithmic space, normal/safe.
1 Introduction
A lot of work has been done in order to provide recursion-theoretic characteriza-
tions of relevant classes of computational complexity. Some of these machine in-
dependent characterizations address explicitly the resource constraints of the com-
plexity classes by imposing bounds in the recursion schemes. This is, for instance,
the case of the Cobham characterization of polytime functions [6], the Thompson
characterization of polyspace functions [18], and the Clote and Takeuti charac-
terization of NC and logspace functions [7]. Different techniques to implement
an intrinsic growth-control have been developed and with them characterizations
without explicit bounds in the recursion schemes have been achieved. Besides oth-
ers, we mention: for the class of polytime functions [3], [10], [14]; for the class of
polyspace functions [15], [17]; for NC [11], [5], [16], [4]. The aim of the present
paper is to provide such a characterization for the logspace functions. Working in
an input-sorted context, as in [3], and based on [7], we establish an implicit charac-
terization of the class of functions computable in logarithmic space — Logspace.
There exists an implicit characterization of the small-output logspace functions
due to Bellantoni, see [1]. By “small-output” we mean that the length of the output
is logarithmically dominated by the length of the input. The functions considered
∗This work was carried out at CMAF-UL, and was supported by FCT (project LogICCC/0001/2007
and PTDC/MAT/104716/2008).

356
Isabel Oitavem
by Bellantoni have numeric inputs and a sort of unary outputs. This non standard
aspect is avoided in the characterization given here. Moreover, we characterize all
logspace functions.
For other implicit characterizations of logspace (decidable sets) we refer to Jones
[9], Møller Neergaard [12] and [13], and work of Hofmann [8]. As Hofmann wrote,
separating logspace from P or NP seems more accessible than separating P from NP
or such like, but surprisingly little work exists concerning implicit characterizations
of logspace. In particular, little work exists concerning recursion-theoretic implicit
characterizations of this class.
1.1 Notation
We work over the set {0, 1}∗of all ﬁnite binary sequences (i.e., leading zeroes are
allowed), and we consider the standard notation related with it: |x| is the length of
the sequence x, ϵ is the sequence of length zero, xˆy is the concatenation of x with
the sequence y, the string product x × y = xˆ· · ·ˆx is the concatenation of x with
itself |y| times (similar in growth to Buss’ smash function). We consider {0, 1}∗
ordered according to length and, within the same length, lexicographically and we
denote this order by <. Thus, ϵ < 0 < 1 < 00 < 01 < 10 < 11 < 000 < · · · .
x′ denotes the successor sequence of x with respect to the order <, and min{x, y}
denotes x if x < y and y otherwise.
2 Inductive characterization of Logspace
Clote and Takeuti established, in [7], an inductive characterization of Logspace
with explicit bounds in one of the recursion schemes. The bounded inductive char-
acterization of Logspace we describe in this section results basically from rewriting
over {0, 1}∗the characterization of Clote and Takeuti, which was originally given
in numeric notation. Therefore, since there is no essential difference between them,
we consider Logspace as being the smallest class of functions which contains the
initial functions 1-12 and that is closed under the composition, bounded∗recur-
sion on notation1 and concatenation recursion on notation schemes. For further
reference, we denote this description of Logspace by LogspaceCT .
1)
En(x1, . . . , xn) = ϵ
(zeroes)
2)
Πn
j (x1, . . . , xn) = xj, 1 ≤j ≤n
(projections)
3)
Si(x) = xi, i ∈{0, 1}
(string successors)
1For technical reasons, this scheme will be replaced by another bounded scheme, therefore at this stage
we use the designation bounded ∗.

Logspace without Bounds
357
4)
P(ϵ) = ϵ P(xi) = x, i ∈{0, 1}
(string predecessor)
5)
IP(ϵ, x) = x IP(yi, x) = P(IP(y, x)),
(iterated string
i ∈{0, 1}
predecessor)
6)
s(x) = x′
(numeric successor)
7)
p(ϵ) = ϵ p(x′) = x
(numeric predecessor)
8)
Ip(ϵ, x) = x Ip(y′, x) = p(Ip(y, x))
(iterated numeric
predecessor)
9)
lh(ϵ) = ϵ lh(xi) = s(lh(x)), i ∈{0, 1}
(length)
10) U(ϵ) = 0 U(xi) = i, i ∈{0, 1}
(last digit)
11) c(ϵ, y, z) = y, c(x′, y, z) = z
(conditional)
12) ×(x, y) = x × y
(string product)
Composition:
f(¯x) = g(¯r(¯x))
Bounded∗recursion on notation:
f(ϵ, ¯x) = g(¯x)
f(yi, ¯x) = hi(y, ¯x, f(y, ¯x)), i ∈{0, 1}
provided that f(y, ¯x) < lh(b(y, ¯x)) holds for all y, ¯x, where b is a function
already in the class.
Concatenation recursion on notation2:
f(ϵ, ¯x) = g(¯x)
f(yi, ¯x) = SU(hi(y,¯x))(f(y, ¯x)), i ∈{0, 1}
In this context the bounded∗recursion on notation scheme can be reformulated as
follows, without affecting the deﬁned class.
Bounded recursion on notation:
f(ϵ, ¯x) = g(¯x)
f(yi, ¯x) = hi(y, ¯x, min{f(y, ¯x), lh(b(y, ¯x))}), i ∈{0, 1}
where, again, b is a function already in the class.
Let us denote by Logspacemin the class which results from replacing in
LogspaceCT the bounded∗recursion on notation scheme by the bounded recursion
on notation scheme above. It is obvious that the bounded recursion on notation
scheme is not more restrictive than the bounded∗recursion on notation scheme,
and so LogspaceCT ⊆Logspacemin. If one notices that min can be deﬁned in
LogspaceCT by min(x, y) = c(Ip(y, x), x, y), then the inclusion Logspacemin ⊆
LogspaceCT is also straightforward. Therefore, LogspaceCT = Logspacemin and
one may deﬁne Logspace as follows:
2In the following SU(z)(w) abbreviates the function c(p(U(z)), S0(w), S1(w)).

358
Isabel Oitavem
Deﬁnition 2.1. Logspace is the smallest class of functions containing the initial
functions 1-12 that is closed under the composition, bounded recursion on notation
and concatenation recursion on notation schemes.
Remark 2.2. Given symbols α, β (α ̸= β), the natural numbers are bijectively
encoded by strings in the alphabet {α, β}. This is particularly well-known for
the alphabet {1, 2}, where the natural number assigned to a string sl sl−1 · · · s1 is
l
i=1 si · 2i−1. In general, the bijection π : IN →{α, β}∗goes as follows:
0 1
2
3
4
5
6
7
· · ·
↓↓
↓
↓
↓
↓
↓
↓
ϵ α β
αα αβ
βα ββ
ααα
· · ·
The usual addition function over IN induces, by π, a 2-ary function over {α, β}∗
that we represent by “ +”. We mean that, for all m, n ∈IN, π(m) + π(n) =
π(m + n). It is routine to check that the function + can be computed bit-by-
bit (only an extra bit is required to carry information). Therefore, the function + is
computable in logarithmic space. In this paper, as in [10] and [15], we are interested
in the case α = 0 and β = 1. Therefore, the basic equations here are x + ϵ = x,
ϵ + x = x, 0 + 0 = 1, 0 + 1 = 1 + 0 = 00, and 1 + 1 = 01.
3 Implicit characterization of Logspace
Following ideas of Bellantoni and Cook, [3] or [2], we consider functions with two
sorts of input positions — normal and safe positions. They are written by this order
and they are separated by a semicolon as follows: f(¯x; y). Notice that here we
only consider functions that have at most one variable in safe position. However,
this restriction is not mandatory. As a matter of fact we could formalize everything
with an arbitrary number of variables in safe positions. The point is that for our
purposes it is enough to have one safe position.
Let us introduce the class of functions Logs.
Deﬁnition 3.1. Logs is the smallest class of functions containing the initial func-
tions 1-12, described below, that is closed under the normal composition, safe re-
cursion on notation, safe concatenation recursion on notation and safe log-transition
recursion on notation schemes.
1)
En(x1, . . . , xn; ) = ϵ
(zeroes)
2)
Πn
j (x1, . . . , xn; ) = xj, 1 ≤j ≤n
(projections)
3)
Si(x; ) = xi, i ∈{0, 1}
(string successors)
4)
P(ϵ; ) = ϵ P(xi; ) = x, i ∈{0, 1}
(string predecessor)
5)
IP(ϵ, x; ) = x IP(yi, x; ) = P(IP(y, x; ); ),
(iterated string

Logspace without Bounds
359
i ∈{0, 1}
predecessor)
6)
s(x; ) = x′
(successor)
7)
p(ϵ; ) = ϵ p(x′; ) = x
(numeric predecessor)
8)
Ip(ϵ, x; ) = x Ip(y′, x; ) = p(Ip(y, x; ); )
(iterated numeric
predecessor)
9)
lh(ϵ; ) = ϵ lh(xi; ) = s(lh(x; ); ), i ∈{0, 1}
(length)
10) U(ϵ; ) = 0 U(xi; ) = i, i ∈{0, 1}
(last digit)
11) c(ϵ, y, z; ) = y, c(x′, y, z; ) = z
(conditional)
12) ×(x, y; ) = x × y
(string product)
Normal composition:
f(¯x; y) = g(¯r(¯x; ); y)
Safe recursion on notation:
f(ϵ, ¯x; ) = g(¯x; )
f(yi, ¯x; ) = hi(y, ¯x; f(y, ¯x; )), i ∈{0, 1}
Safe concatenation recursion on notation3:
f(ϵ, ¯x; ) = g(¯x; )
f(yi, ¯x; ) = SU(hi(y,¯x;);)(f(y, ¯x; ); ), i ∈{0, 1}
Safe log-transition recursion on notation
f(xi, ¯y, z; ϵ) = f(x, ¯y, z; ϵ)
f(xi, ¯y, z; w′) = f(x, ¯y, z′; w), i ∈{0, 1}
f(ϵ, ¯y, z; w) = h(¯y, z; )
It is obvious that the strength of this characterization is concentrated on the nor-
mal positions: all initial functions involve only variables in normal positions, the
same happens with the safe concatenation recursion on notation scheme and we
only have normal composition. However, in the safe recursion on notation scheme
the recursive value f(¯x, y; ) is placed in the safe position of h. Thus, the unique
way to use the power of the safe recursion on notation scheme is via safe log-
transition recursion on notation which, for x in normal position and w in safe po-
sition such that w ≤lh(x), enables us to use w as if it was in a normal position.
Informally, if f is deﬁned by log-transition based on h, then f(x, ¯y, z; w) leads to
h(¯y, z + min{lh(x), w}; ).
In other words, the safe composition scheme imposes a complete separation be-
tween normal and safe input positions. This separation is respected by all recur-
sion schemes, except by the safe log-transition recursion scheme. The goal of this
scheme is to allow f(x, ¯y; w) = h(¯y, w; ) whenever w ≤lh(x). Therefore, we call
it “log-transition”.
3In the following SU(z;)(w; ) abbreviates the function c(p(U(z; ); ), S0(w; ), S1(w; ); ).

360
Isabel Oitavem
In fact, the safe log-transition recursion scheme can be replaced by the follow-
ing scheme: f(x, ¯y; w) = h(¯y, min(lh(x; ), w; ); ), where min(z, w; ) abbreviates
c(Ip(w, z; ), z, w; ). This, in particular, means that the log-transition is conceptu-
ally a composition scheme that we formulate recursively.
In order to prove that Logspace = Logs we establish two lemmas:
Lemma 3.2. For all F ∈Logspace there exists f ∈Logs such that
∀¯x F(¯x) = f(¯x; ).
Proof. The proof is by induction on the complexity of F. The only relevant case is
when F is deﬁned by bounded recursion on notation:
F(ϵ, ¯x) = G(¯x)
F(yi, ¯x) = Hi(y, ¯x, min{F(y, ¯x), lh(B(y, ¯x))}), i ∈{0, 1}.
By induction assumption, there exist g, h0, h1, b ∈Logs such that ∀¯x G(¯x) =
g(¯x; ), ∀y, ¯x, z Hi(y, ¯x, z) = hi(y, ¯x, z; ) and ∀y, ¯x B(y, ¯x) = b(y, ¯x; ). Therefore,
we just have to deﬁne f, by safe recursion on notation, as follows:
f(ϵ, ¯x; ) = g(¯x; )
f(yi, ¯x; ) = h∗
i (y, ¯x; f(y, ¯x; )), i ∈{0, 1},
where h∗
i for any i ∈{0, 1} is deﬁned, by normal composition, according to the ex-
pression h∗
i (y, ¯x; z) = h∗∗
i (b(y, ¯x; ), y, ¯x, ϵ; z) and h∗∗
i
is deﬁned by log-transition
based on hi, i.e.
h∗∗
i (wj, y, ¯x, u; ϵ) = h∗∗
i (w, y, ¯x, u; ϵ)
h∗∗
i (wj, y, ¯x, u; w′) = h∗∗
i (w, y, ¯x, u′; z), j ∈{0, 1}
h∗∗
i (ϵ, y, ¯x, u; z) = hi(y, ¯x, u; ).
Lemma 3.3. For all f ∈Logs there exist F, b ∈Logs such that ∀¯x, y f(¯x; y) =
F(¯x; min{y, lh(b(¯x; ))}). Moreover, the function f is not used in the deﬁnition of
b.
Proof. The proof is by induction on the complexity of f. The only non trivial case
is when f is deﬁned by log-transition. In this case we have
f(xi, ¯y, z; ϵ) = f(x, ¯y, z; ϵ)
f(xi, ¯y, z; w′) = f(x, ¯y, z′; w), i ∈{0, 1}
f(ϵ, ¯y, z; w) = h(¯y, z; ).
Setting b(x, ¯y, z; ) = x and considering F(x, ¯y, z; min{w, lh(x)}) deﬁned by log-
transition based on h we achieve the desired result.
Theorem 3.4. Logspace = Logs.

Logspace without Bounds
361
Proof. It is immediate, by lemma 3.2, that Logs contains Logspace. Let us check
the other inclusion. We have to show that for all f ∈Logs there exists F ∈
Logspace such that ∀¯x, y f(¯x; y) = F(¯x, y). Let us proceed by induction on the
complexity of f. For all initial functions of Logs, and for functions obtained by the
normal composition or safe concatenation recursion on notation schemes the result
is obvious. Lemma 3.3 turns the result into an obvious statement for functions
deﬁned by the safe recursion on notation scheme. Thus, we just have to prove
that any function in Logs deﬁned by the log-transition scheme is also deﬁnable in
Logspace. Let us consider f deﬁned by log-transition as follows:
f(xi, ¯y, z; ϵ) = f(x, ¯y, z; ϵ)
f(xi, ¯y, z; w′) = f(x, ¯y, z′; w)
f(ϵ, ¯y, z; w) = h(¯y, z; ).
By induction hypothesis, there exist H ∈Logspace such that ∀¯y, z h(¯y, z; ) =
H(¯y, z). Then, since + is a logspace function as claimed in remark 2.2,
we
achieve the desired result deﬁning F(x, ¯y, z, w) = H(¯y, z + min{w, lh(x)}),
where min{w, lh(x)} is c(Ip(lh(x), w), w, lh(x)).
References
[1] Bellantoni S.: Predicative Recursion and Computational Complexity. Ph. D.
Dissertation, University of Toronto (1993).
[2] Bellantoni S.: Predicative recursion and the polytime hierarchy. Feasible
Mathematics II, ed. P.Clote and J.B.Remmel, pp.15-29 (1995).
[3] Bellantoni S., Cook S.: A new recursion-theoretic characterization of poly-
time functions. Computational Complexity 2, pp.97-110 (1992).
[4] Bonfante G., Kahle R., Marion J.-Y.: Recursion schemeta for NCk. LNCS,
Springer-Verlag, pp.49-63 (2008).
[5] Bellantoni S., Oitavem I.: Separating NC along the δ axis. ICC Special issue
of Theoretical Computer Science 318, pp.57-78 (2004).
[6] Cobham A.: The intrinsic computational difﬁculty of functions. Proc. of the
1964 International Congress for Logic, Methodology, and the Philosophy of
Science, ed. Y. Bar-Hillel, North Holland, Amsterdam, pp.24-30 (1965).
[7] Clote P., Takeuti G.: First order bounded arithmetic and small boolean cir-
cuit complexity classes. Feasible Mathematics II, ed. P.Clote and J.B.Remmel,
pp.154-218 (1995).

362
Isabel Oitavem
[8] Hofmann
M.:
Programming
languages
for
logarithmic
space.
Talk
given
at
Geocal’06,
13th
Feb.2006,
http://www-lipn.univ-
paris13.fr/˜baillot/GEOCAL06/SLIDES/Hofmann1302.pdf
[9] Jones N.: Logspace and Ptime characterized by programming languages. The-
oretical Computer Science 228, pp.151-174 (1999).
[10] Leivant D.: Ramiﬁed recurrence and computational complexity I: word re-
currence and polytime. Feasible Mathematics II, ed. P.Clote and J.B.Remmel,
pp.320-343 (1995).
[11] Leivant D.: A characterization of NC by tree recurrence. Proceedings of the
39th Annual Symposium on Foundations of Computer Science, FOCS 1998,
IEEE Computer Society, pp.716-724 (1998).
[12] Møller Neergaard P.: A functional language for logarithmic space. Prog.
Lang. and Systems: 2nd Assian Symp. (APLAS 2004), LNCS 3302, pp.311-
326.
[13] Møller Neergaard P.:
BC−
ϵ :
A recursion-theoretic characterization of
Logspace. Technical report, Brandeis University, March 2004.
[14] Niggl K.-H.: The μ-Measure as a tool for classifying computational complex-
ity. Archive for Mathematical Logic 39(7), pp. 509-514 (2000).
[15] Oitavem I.: New recursive characterizations of the elementary functions and
the functions computable in polynomial space. Revista Matematica de la Uni-
versidad Complutense de Madrid 10(1), pp.109-125 (1997).
[16] Oitavem I.: Characterizing NC with tier 0 pointers. Mathematical Logic Quar-
terly 50(1), pp.9-17 (2004).
[17] Oitavem I.: Characterizing Pspace with pointers. Mathematical Logic Quar-
terly 54(3), pp.317-323 (2008).
[18] Thompson D.:
Subrecursiveness:
machine-independent notions of com-
putability in restricted time and storage. Mathematical Systems Theory 6(1),
pp.3-15 (1971).

Investigations of Subsystems of Second Order
Arithmetic and Set Theory in Strength between
Π1
1-CA and Δ1
2-CA + BI: Part I
Michael Rathjen
Department of Pure Mathematics
University of Leeds
Leeds LS2 9JT, UK
rathjen@maths.leeds.ac.uk
Abstract This paper is the ﬁrst of a series of two.
It contains proof–
theoretic investigations on subtheories of second order arithmetic and set
theory. Among the principles on which these theories are based one ﬁnds au-
tonomously iterated positive and monotone inductive deﬁnitions, Π1
1 trans-
ﬁnite recursion, Δ1
2 transﬁnite recursion, transﬁnitely iterated Π1
1 depen-
dent choices, extended Bar rules for provably deﬁnable well-orderings as
well as their set-theoretic counterparts which are based on extensions of
Kripke-Platek set theory. This ﬁrst part introduces all the principles and
theories. It provides lower bounds for their strength measured in terms of
the amount of transﬁnite induction they achieve to prove. In other words,
it determines lower bounds for their proof-theoretic ordinals which are ex-
pressed by means of ordinal representation systems. The second part of the
paper will be concerned with ordinal analysis. It will show that the lower
bounds established in the present paper are indeed sharp, thereby provid-
ing the proof-theoretic ordinals. All the results were obtained more then 20
years ago (in German) in the author’s PhD thesis [43] but have never been
published before, though the thesis received a review (MR 91m#03062). I
think it is high time it got published.
1 Introduction
To set the stage for the following, a very brief history of ordinal-theoretic proof
theory from the time after Gentzen’s death until the early 1980s reads as follows:
In the 1950’s proof theory ﬂourished in the hands of Sch¨utte. In [59] he introduced
an inﬁnitary system for ﬁrst order number theory with the so-called ω-rule, which
had already been proposed by Hilbert [23]. Ordinals were assigned as lengths to
derivations and via cut-elimination he re-obtained Gentzen’s ordinal analysis for

364
Michael Rathjen
number theory in a particularly transparent way. Further, Sch¨utte extended his
approach to systems of ramiﬁed analysis and brought this technique to perfection
in his monograph “Beweistheorie” [60]. Independently, in 1964 Feferman [13]
and Sch¨utte [61], [62] determined the ordinal bound Γ0 for theories of autonomous
ramiﬁed progressions.
A major breakthrough was made by Takeuti in 1967, who for the ﬁrst time ob-
tained an ordinal analysis of a strong fragment of second order arithmetic. In [69]
he gave an ordinal analysis of Π1
1 comprehension, extended in 1973 to Δ1
2 com-
prehension in [70]. For this Takeuti returned to Gentzen’s method of assigning
ordinals (ordinal diagrams, to be precise) to purported derivations of the empty
sequent (inconsistency).
The next wave of results, which concerned theories of iterated inductive deﬁni-
tions, were obtained by Buchholz, Pohlers, and Sieg in the late 1970’s (see [10]).
Takeuti’s methods of reducing derivations of the empty sequent (“the inconsis-
tency”) were extremely difﬁcult to follow, and therefore a more perspicuous treat-
ment was to be hoped for. Since the use of the inﬁnitary ω-rule had greatly fa-
cilitated the ordinal analysis of number theory, new inﬁnitary rules were sought.
In 1977 (see [5]) Buchholz introduced such rules, dubbed Ω-rules to stress the
analogy. They led to a proof-theoretic treatment of a wide variety of systems, as
exempliﬁed in the monograph [11] by Buchholz and Sch¨utte. Yet simpler inﬁni-
tary rules were put forward a few years later by Pohlers, leading to the method of
local predicativity, which proved to be a very versatile tool (see [40–42]). With
the work of J¨ager and Pohlers (see [28, 29, 33]) the forum of ordinal analysis then
switched from the realm of second-order arithmetic to set theory, shaping what is
now called admissible proof theory, after the models of Kripke-Platek set theory,
KP. Their work culminated in the analysis of the system with Δ1
2 comprehension
plus Bar induction, (BI), [33]. In essence, admissible proof theory is a gathering of
cut-elimination techniques for inﬁnitary calculi of ramiﬁed set theory with Σ and/or
Π2 reﬂection rules1 that lend itself to ordinal analyses of theories of the form KP+
“there are x many admissibles” or KP+ “there are many admissibles”. By way
of illustration, the subsystem of analysis with Δ1
2 comprehension and Bar induc-
tion can be couched in such terms, for it is naturally interpretable in the set theory
KPi := KP + ∀y∃z(y∈z ∧z is admissible) (cf. [33]).
The investigations of this paper focus, as far as subsystems of second order arith-
metic are concerned, on theories whose strength strictly lies in between that of
Δ1
2-CA and Δ1
2-CA + (BI). Δ1
2-CA is actually not much stronger than Π1
1-CA,
the difference being that the latter theory allows one to carry out iterated hyper-
1Recall that the salient feature of admissible sets is that they are models of Δ0 collection and that Δ0
collection is equivalent to Σ reﬂection on the basis of the other axioms of KP (see [3]). Further-
more, admissible sets of the form Lα also satisfy Π2 reﬂection.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
365
jumps of length < ω while the former allows one to carry out iterated hyperjumps
of length < ε0. The jump from Δ1
2-CA to Δ1
2-CA+(BI) is indeed enormous. By
comparison, even the ascent from Π1
1-CA to Δ1
2-CA + BR (with BR referring to
the Bar rule) is rather benign. To get an appreciation for the difference one might
also point out that all hitherto investigated subsystems of second order arithmetic
in the range from Π1
1-CA0 to Δ1
2-CA + BR can be reduced (as far as strength
is concerned) to ﬁrst order theories of iterated inductive deﬁnitions.2 The theories
investigated here are beyond that level. Among the principles on which these the-
ories are based one ﬁnds autonomously iterated positive and monotone inductive
deﬁnitions, Π1
1 transﬁnite recursion, Δ1
2 transﬁnite recursion, transﬁnitely iterated
Π1
1 dependent choices, extended Bar rules for provably deﬁnable well-orderings as
well as their set-theoretic counterparts which are based on extensions of Kripke-
Platek set theory. This ﬁrst part introduces all the principles and theories. It pro-
vides lower bounds for their strength measured by the amount of provable transﬁ-
nite induction. In other words, it determines lower bounds for their proof-theoretic
ordinals which are expressed by means of ordinal representation systems. The sec-
ond part of the paper will be concerned with ordinal analysis. It will show that the
lower bounds established in the present paper are indeed sharp, thereby providing
the proof-theoretic ordinals. All the results were obtained more then 20 years ago
(in German) in the author’s PhD thesis [43] but have never been published before,
though the thesis received a review (MR 91m#03062). I always thought that the
results in my thesis were worth publishing but in the past I never seemed to have
enough time to sit down for six weeks and type the entire PhD thesis again. The
thesis was produced by the now obsolete word processing system “Signum” and
it was also written in German. Over the past 20 years or so academic life has
changed in that time, e.g. for doing research, has become a luxury good. I would
like to thank Andreas Weiermann for nudging me again and again to publish it.
Zueignung
Den kreat¨urlichen Freunden Bobby, Honky Tonk, Schnufﬁund Marlene gewidmet.
Outline of the paper
In the following I give a brief outline of the contents of this paper. It is roughly
divided into two chapters. The ﬁrst chapter, entitled “THEORIES”, introduces the
2Since this thesis was written, though, ordinal-theoretic proof theory has progressed way beyond the
strength of such theories and can now analyze systems based on Π1
2 comprehension (cf. [53,54,56,
57]).

366
Michael Rathjen
background and presents all the principles and theories to be considered. It also es-
tablishes interrelationships between various theories. The second chapter, entitled
“WELL-ORDERING PROOFS”, introduces an ordinal representation system and
establishes lower bounds for the proof-theoretic ordinals of most of the theories
considered.
Section 2 carefully deﬁnes the basic theory of arithmetical comprehension,
ACA0, which forms the basis for all subsystems of second order arithmetic, and
also the basic set theory BT which forms the basis of all set theories. While such
attention to detail will not matter that much for the present paper it will certainly be
of importance to its sequel which features proof analyses of inﬁnitary calculi. Sec-
tion 3 introduces second order theories of iterated inductive deﬁnitions. Systems
investigated in the literature before used to be ﬁrst order theories with the induc-
tively deﬁned sets being captured via additional predicates and iterations restricted
to arithmetical well-orderings. Going to second order theories allows one to formal-
ize iterations along arbitrary well-orderings and also to address the more general
scenario of monotone inductive deﬁnitions. Section 4 compares the theories of the
foregoing section with theories of transﬁnite Π1
1 comprehension. In section 5 it is
shown that theories of iterated inductive deﬁnitions can be canonically translated
into set theories of iterated admissibility. This translation exploits the structure the-
ory of Σ+-inductive deﬁnitions on admissible sets originating in Gandy’s Theorem
(cf. [3, VI]). Section 6 features iterations based on stronger operations such as Δ1
2
comprehension and Σ1
2 dependent choices. Section 7 deals with their set-theoretic
counterparts which are to be found in certain forms of Σ recursion.
In order to approach the strength of Δ1
2-CA + (BI) it is natural to restrict the
schema (BI) to speciﬁc syntactic complexity classes of formulae, (F-BI). An
alternative consists in directing the attention to the well-ordering over which trans-
ﬁnite induction is allowed in that one requires them to be provably well-ordered or
parameter-free. This will be the topic of section 8. Particular rules and schemata
considered include the rule BR(impl-Σ1
2) and the schema BI(impl-Σ1
2):
(BR(impl-Σ1
2))
∃!X (WO(X) ∧G[X])
∀X (WO(X) ∧G[X] →TI(X, H))
where G[U] is a Σ1
2 formula (without additional parameters), H(a) is an arbitrary
L2 formula, WO(X) expresses that X is a well-ordering, and TI(X, H) expresses
the instance of transﬁnite induction along X with the formula H(a).
(BI(impl-Σ1
2))
∃!X (WO(X) ∧G[X]) →∀X (WO(X) ∧G[X] →TI(X, H))
where G[U] is a Σ1
2 formula (without additional parameters) and H(a) is an arbi-
trary L2 formula.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
367
The rule BR(impl-Σ1
2) is, on the basis of Δ1
2-CA, much stronger than the
rule BR whereas BR(impl-Σ1
2) is still much weaker than (BI). The difference
in strength between (BI) and BR(impl-Σ1
2) is of course owed to the fact that the
ﬁrst is a rule while the second is a schema. But one can say something more illu-
minative about it. As it turns out, BR(impl-Σ1
2) and BI(impl-Σ1
2) are of the same
strength (on the basis of Δ1
2-CA), in actuality the theories Δ1
2-CA+BR(impl-Σ1
2)
and Δ1
2-CA + BI(impl-Σ1
2) prove the same Π1
1 statements. Thus the main differ-
ence between BR(impl-Σ1
2) and (BI) is to be found in the premiss of BI(impl-Σ1
2)
requiring the well-ordering to be describable via a Σ1
2 formula without parameters.
Section
8
also
considers
set-theoretic
versions
of
(BR(impl-Σ1
2)
and
(BI(impl-Σ1
2)) which can be viewed as formal counterparts of the notion of a good
Σ1 deﬁnition of an ordinal/set known from the theory of admissible sets (cf. [3,
II.5.13]).
With the next section we enter the second chapter of this paper. Sections 9 and
10 develop an ordinal representation system OT(Φ) which will be sufﬁcient unto
the task of expressing the proof-theoretic ordinals of all the foregoing theories.
Section 11 introduces the technical basis for well-ordering proofs. By a well-
ordering proof in a given theory T we mean a proof formalizable in T which shows
that a certain ordinal representation system (or a subset of it) is well-ordered. The
notion of a distinguished set (of ordinals) (in German: ausgezeichnete Menge) will
be central to carrying out well ordering proofs in the various subtheories of sec-
ond order arithmetic introduced in earlier sections. A theory of distinguished sets
developed for this purpose emerged in the works of Buchholz and Pohlers [4,6,7].
The remaining sections 12-15 are concerned with well-ordering proofs for most
of the theories featuring in this paper. The lower bounds for the proof-theoretic
ordinals of theories established in this article turn out to be sharp. Proofs of upper
bounds, though, will be dealt with in the second part of this paper which will be
devoted to ordinal analysis. The ﬁnal section of this paper provides a list of all
theories and their proof-theoretic ordinals.
I. THEORIES
2 The formal set-up
This section introduces the languages of second order arithmetic and set theory with
the natural numbers as urelements. Moreover, a collection of theories, comprehen-
sion and induction principles formalized in these languages will be introduced. Our

368
Michael Rathjen
presentation of second order arithmetic is equivalent to those found in the standard
literature (e.g. [10, 65]). The same applies to set theory with urelements, where
we follow the standard reference [3]. Slight deviations are of a purely technical
nature, one peculiarity being that we deﬁne formulae in such a way that negations
occur only in front of prime formulae, another being that function symbols will
be avoided. Instead, we axiomatize number theory by means of relation symbols
representing their graphs.
2.1 The language L2
The vocabulary of L2 consists of free number variables a0, a1, a2, . . ., bound num-
ber variables x0, x1, x2, . . ., free set variables U0, U1, U2, . . ., bound set variables
X0, X1, X2, . . ., the logical constants ¬, ∧, ∨, ∀, ∃, the constants (numerals) ¯n for
each n ∈N, a 1-place relation symbol P, three 2-place relation symbols ∈, ≡, SUC
and two 3-place relation symbols ADD, MULT. In addition, L2 has auxiliary sym-
bols such as parentheses and commas. The intended interpretation of these symbols
is the following:
1. Number variables range over natural numbers while set variables range over
sets of natural numbers.
2. The constant ¯n denotes the nth natural number.
3. P stands for an arbitrary set of natural numbers.
4. ∈denotes the elementhood relation between natural numbers and sets of natu-
ral numbers.
5. ≡denotes the identity relation between natural numbers.
6. SUC, ADD, and MULT denote the graphs of the numerical functions n →
n + 1, (n, m) →n + m, and (n, m) →n · m, respectively.
The terms of L2 are the free number variables and the constants ¯n. As syntactical
we also use a, b, c, d, e for free number variables, R, S, U, V for free set variables,
u, v, w, x, y, z, i, j for bound number variables, W, X, Y, Z for bound set variables,
r, s, t for terms, and A, B, C, D, F, G, H for formulae of L2. If E is an expression,
τ1, . . . , τn are distinct primitive symbols and σ1, . . . , σn are arbitrary expressions,
then by E(τ1, . . . , τn | σ1, . . . , σn) we mean the expression obtained from A by
writing σi in place of τi at each occurrence of τi. If A is a formula of the form
B(τ1, . . . , τn | σ1, . . . , σn) then this fact will also be expressed (less accurately)
by writing B as B(τ1, . . . , τn) and A as B(σ1, . . . , σn).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
369
Deﬁnition 2.1. The atomic formulae of L2 are of the form (s ≡t), (s ∈U),
SUC(s, t), P(s), ADD(s, t, r), and MULT(s, t, r).
The L2-formulae are deﬁned inductively as follows: If A is an atomic formula
then A and ¬A are L2-formulae. If A and B are L2-formulae then so are (A ∧B)
and (A∨B). If F(a) is an L2-formula in which the bound number variable x does
not occur then ∀x F(x) and ∃x F(x) are L2-formulae. If G(U) is an L2-formula
in which the bound set variable X does not occur then ∀X G(X) and ∃X G(X)
are L2-formulae.
The negation, ¬A, of a non–atomic formula A is deﬁned to be the formula ob-
tained from A by
(i) putting ¬ in front any atomic subformula,
(ii) replacing ∧, ∨, ∀x, ∃x, ∀X, ∃X by ∨, ∧, ∃x, ∀x, ∃X, ∀X, respectively, and
(iii) dropping double negations.
As usual, (A →B) abbreviates (¬A ∨B) and (A ↔B) stands for the formula
((A →B) ∧(B →A)). Outer most parentheses will usually be dropped. We
write s ̸= t for ¬(s ≡t) and s /∈U for ¬(s ∈U). To avoid parenthesis we also
adopt the conventions that ¬ binds more strongly than the other connectives and
that ∧, ∨bind more strongly than →and ↔.
We also use the following abbreviations with Q ∈{∀, ∃}:
Qx1 . . . xn F(x1, . . . , xn) := Q x1 . . . Q xn F(x1, . . . , xn),
Q X1 . . . , Xn F(X1, . . . , Xn) := QX1 . . . QXn F(X1, . . . , Xn),
and ∀x∃!y H(x, y) := ∀x∃y H(x, y) ∧∀xyz (H(x, y) ∧H(x, z) →y ≡z).
Deﬁnition 2.2. The formula class Π1
0 (as well as Σ1
0) consists of all arithmetical
L2-formulae, i.e., all formulae which do not contain set quantiﬁers.
If F(U) is a Σ1
n-formula (Π1
n-formula) then ∀X F(X) (∃X F(X)) is a Π1
n+1
(Σ1
n+1) formula.
2.2 The theory ACA0
As a base for all theories in the language L2 we use the theory ACA0 which in
addition to the usual number-theoretic axioms has the axiom schema of arithmetical
comprehension and an induction axiom for sets. As we will subject these theories
to proof-theoretic treatment we shall present the axiomatization of ACA0 in more
detail than would otherwise be necessary.
Deﬁnition 2.3. The mathematical axioms of ACA0 are the following:
(i) Equality axioms
(G1) ∀x (x ≡x).

370
Michael Rathjen
(G2) ∀xy (x ≡y →[F(x) ↔F(y)]) for F(a) in Π1
0.
(G3) ¯n ≡¯n.
(G4) ¯n ̸≡¯m if n, m are different natural numbers.
(i) Axioms for SUC, ADD, MULT.
(SUC1) ∀x ∃!y SUC(x, y).
(SUC2) ∀y [y ≡¯0 ∨∃x SUC(x, y)].
(SUC3) ∀xyz (SUC(x, z) ∧SUC(y, z) →x ≡y).
(SUC4) SUC(¯n, n + 1).
(SUC5) ¬SUC(¯n, ¯m) if n + 1 ̸= m.
(ADD1) ∀xy ∃!z ADD(x, y, z).
(ADD2) ∀x ADD(x, ¯0, x).
(ADD3) ∀uvwxy [ADD(u, v, w) ∧SUC(v, x) ∧SUC(w, y) →ADD(u, x, y)].
(ADD4) ADD(¯n, ¯m, n + m).
(ADD5) ¬ADD(¯n, ¯m, ¯k) if n + m ̸= k.
(MULT1) ∀xy ∃!z MULT(x, y, z).
(MULT2) ∀x MULT(x, ¯0, ¯0).
(MULT3) ∀uvwxy [MULT(u, v, w)
∧
SUC(v, x)
∧
ADD(w, u, y)
→
MULT(u, x, y)].
(MULT4) MULT(¯n, ¯m, n · m).
(MULT5) ¬MULT(¯n, ¯m, ¯k) if n · m ̸= k.
(iii) Induction Axiom
(Ind)
∀X [¯0 ∈X ∧∀xy [SUC(y, x) ∧y ∈X →x ∈X] →∀x (x ∈X)].
(iv) Arithmetical Comprehension
(ACA)
∃X ∀y [y ∈X ↔F(y)]
where F(a) is Π1
0 and X does not occur in F(a).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
371
As logical rules and axioms for every theory formulated in the language of L2 we
choose the following:
(L1) All formulae of L2 that are valid in propositional logic.
(L2) The number quantiﬁer axioms ∀x F(x) →F(t) and F(t) →∃x F(x) for
every L2-formula F(a) in which x does not occur and every term t .
(L3) The set quantiﬁer axioms ∀X H(X) →H(U) and H(U) →∃X F(X) for
every L2-formula H(V ) in which X does not occur and set variable U.
(L4) Modus ponens: From A and A →B deduce B.
(L5) From A →F(a) deduce A →∀x F(x) and from F(a) →A deduce
∃x F(x) →A providing the free number variable a does not occur in the
conclusion and x does not occur in F(a).
(L6) From A →H(U) deduce A →∀X H(X) and from H(U) →A deduce
∃X F(X) →A providing the free set variable U does not occur in the con-
clusion and X does not occur in F(U).
We write T ⊢A when T is a theory in the language of L2 and A can be deduced
from T using the axioms of T and any combination of the preceding axioms and
rules of ACA0.
By ACA we denote the theory ACA0 augmented by the scheme of induction for
all L2-formulae:
(IND)
F(¯0) ∧∀xy [SUC(y, x) ∧F(y) →F(x)] →∀x F(x)
where F(a) is an arbitrary formula of L2.
The sublanguage of L2 without set variables will be denoted by L1.
2.3 The languages L∗and L∗(M)
L∗will be the language of set theory with the natural numbers as urelements. L∗
comprises L1 and in addition has a constant N for the set of natural numbers, a 1-
place predicate symbol Set for the class of sets, and a 1-place predicate symbol Ad
for the class of admissible sets. The intended interpretations of L1 and L∗diverge
with respect to the scopes of the quantiﬁers ∀x and ∃x which in the case of L∗are
viewed as ranging over all sets and urelements. Moreover, L∗has also bounded
quantiﬁers (∀x ∈t) and (∃x ∈t) which will be treated as quantiﬁers in their own
right.

372
Michael Rathjen
We will also have use for an extended language L∗(M) which has a constant M,
intended to denote the smallest admissible set.
The terms of L∗(L∗(M)) consist of the free variables and the constants ¯n and N
(and M).
The atomic formulae of L∗(L∗(M)) consists of all strings of symbols of the
forms (s ≡t), (s ∈t), P(t), SUC(s, t), ADD(s, t, r), MULT(s, t, r), Ad(s), and
Set(s), where s, t, r are arbitrary terms of L∗(L∗(M)).
Deﬁnition 2.4. L∗-formulae are inductively deﬁned as follows:
1. A and ¬A are L∗-formulae whenever A is an atomic L∗-formula.
2. If A and B are L∗-formulae so are (A ∧B) and (A ∨B).
3. If F(a) is an L∗-formula in which x does not appear and t is an L∗term then
∀x F(x), ∃x F(x), (∀x ∈t) F(x), and (∃x ∈t) F(x) are L∗-formulae.
L∗(M)-formulae are deﬁned in a similar vein. The negation, ¬A, of a formula A is
deﬁned as in Deﬁnition 2.1, but extended by the clauses ¬(∀x ∈t)F(x) := (∃x ∈
t)¬F(x) and ¬(∃x ∈t)F(x) := (∀x ∈t)¬F(x) for the bounded quantiﬁers.
Deﬁnition 2.5 (Translating L2 into L∗). Let U ∗
i := a2·i, X∗
i := x2·i+2, a∗
i :=
a2·i+1, x∗
i := x2·i+1, and ¯n∗:= ¯n.
To every L2-formula A we assign an L∗-formula A∗as follows: Replace every
free variable X in A by X ∗. Replace number quantiﬁers ∀x ...x... and ∃x ...x...
by (∀x∗∈N) ...x∗... and (∃x∗∈N) ...x∗..., respectively. Replace set quanti-
ﬁers ∀X ...X... and ∃X ...X... by ∀X∗[Set(X∗) ∧X∗⊆N →...X∗...] and
∃X∗[Set(X∗) ∧X∗⊆N ∧...X∗...], respectively, where X∗⊆N stands for
∀u [u ∈X∗→u ∈N]. The translation A →A∗provides an embedding of L2
into L∗, preserving the intended interpretations. In what follows we view L2 as
sublanguage of L∗, formally ﬁxed by the natural translation
∗.
2.4 Syntactic classiﬁcations
Deﬁnition 2.6. The Δ0 formulae are the smallest collection of L∗formulae con-
taining all quantiﬁer-free formulae closed under ¬, ∧, ∨and bounded quantiﬁca-
tion. Spelled out in detail the last closure clause means that if F(a) is Δ0, t is
a term and x is a bound variable not occurring in F(a) then (∃x ∈t)F(x) and
(∀x ∈t)F(x) are Δ0.
L∗formulae which are Δ0 or of the form ∃x F(x) with F(a) Δ0 are said to be Σ1.
Dually, a formula is Π1 if it is the negation of a Σ1 formula.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
373
A formula is a Σ formula (Π formula) if it belongs to the smallest collection of
formulae containing the Δ0 formulae which is closed under ∧, ∨, bounded quan-
tiﬁcation, and existential (universal) quantiﬁcation.
Deﬁnition 2.7. The collection of P-positive Δ0 formulae of L∗, Δ(P+), is induc-
tively generated from the Δ0 formulae in which P does not occur and all formulae
P(t) by closing off under ∨, ∧, (∀x ∈s), and (∃x ∈s).
The collection of P-positive arithmetical formulae, Π1
0(P+), is the collection of L2
formulae generated from the arithmetical formulae in which P does not occur and
the atomic formulae P(t) by closing off under ∧, ∨, and numerical quantiﬁcation.
Remark 2.8. If A is Π1
0(P+) then A∗is Δ0(P+).
Deﬁnition 2.9. For L∗formulae A and terms s the relativization of A to s, As,
arises from A by restricting all unbounded quantiﬁers ∀x . . . and ∃x . . . to s, i.e.,
by replacing them with (∀x ∈s) . . . and (∃x ∈s) . . ., respectively.
Note that As is always a Δ0 formula.
Many mathematical and set-theoretic predicates have Δ0 formalizations. For
those that occur most frequently we introduce abbreviations:
Tran(s) := (∀x ∈s)(∀y ∈x) (y ∈s).
Ord(s) := Tran(s) ∧(∀x ∈s)Tran(x).
Lim(s) := Ord(s) ∧(∃x ∈s)(x ∈s) ∧(∀x ∈s)(∃y ∈s)(x ∈y).
s ⊆t := (∀x ∈s)s ∈t.
(s = t) := (Set(s) ∧Set(t) ∧s ⊆t ∧t ⊆s) ∨(s ∈N ∧t ∈N ∧s ≡t).
(s = {t, r}) := t ∈s ∧r ∈s ∧(∀x ∈s)(x = t ∨x = r).
(s = ⟨t, r⟩) := s = {{t, r}, {r}}.
Fun(f) := f is a function.
(dom(f) = s) := f is a function with domain s.
(rng(f) = s) := f is a function with range s.
(f(r) = t) := Fun(f) ∧⟨r, t⟩∈f.
(s =  r) := (∀x ∈r)(x ⊆s) ∧(∀y ∈s)(∃x ∈r)y ∈x.
To save us from writing too many symbols we shall adopt the following conven-
tions. Frequently parentheses around bounded quantiﬁers will be dropped. In writ-
ing A[⃗a] we intend to convey that all free variables in the formula occur in the list
of variables ⃗a. Boldface versions of variables are meant to stand for tuples of vari-
ables. If ⃗x = (x1, . . . , xr) we write ∀⃗x, ∀⃗x ∈s, ∃⃗x, and ∃⃗x ∈s for ∀x1 . . . ∀xr,
(∀x1 ∈s) . . . (∀xr ∈s), ∃x1 . . . ∃xr, and (∃x1 ∈s) . . . (∃xr ∈s), respectively.
We also use class notations {x | F(x)} as abbreviations with the usual meaning:
s ∈{x | F(x)} := F(s), t = {x | F(x)} := ∀z[z ∈t ↔F(z)], {x ∈t | F(x)}
:= {x | x ∈t ∧F(x)}, etc.

374
Michael Rathjen
Lower case Greek variables α, β, γ, . . . range over ordinals. The letters f, g, h
will be reserved for functions, i.e., ∀f . . . and ∃f . . . stand for ∀f(Fun(f) →. . .)
and ∃f(Fun(f) ∧. . .), respectively. We write α < β instead of α ∈β.
2.5 A base system for set theory
We ﬁx a formal theory BT to serve as a base system for all our set theories. The
language of BT is L∗.
Deﬁnition 2.10. The axioms of BT come in four groups.
Logical Axioms
1. Every propositional tautology is an axiom.
2. ∀xF(x) →F(s).
3. F(s) →∃xF(x).
4. (∀x ∈t)F(x) →(s ∈t →F(s)).
5. (s ∈t ∧F(s)) →(∃x ∈t)F(x).
Ontological Axioms
(O1) s = t →[F(s) ↔F(t)]
for F(a) in Δ0.
(O2) Set(t) →t /∈N.
(O3) ¯n ∈N for all n ∈N.
(O4) s ∈t →Set(t).
(O5) R(s1, . . . , sk) →s1 ∈N ∧. . . ∧sk ∈N
for
R ∈{≡, SUC, ADD, MULT, P} and k being the arity of R.
(O6) Ad(s) →N ∈s ∧Tran(s).
(O7) Ad(s) ∧Ad(t) →s ∈t ∨s = t ∨t ∈s.
(O8) Ad(s) →∀x ∈s∀y ∈s∃z ∈s (x ∈z ∨y ∈z).
(O9) Ad(s) →∀x ∈s∃y ∈s (y =  x).
(O10) Ad(s) →∀⃗u ∈s∀x ∈s ∃y ∈s [Set(y) ∧
∀z ∈s(z ∈y ↔z ∈x ∧A[z, x, ⃗u])]
for all Δ0 formulae A[a, b,⃗c].

Investigations of Subsystems of Second Order Arithmetic and Set Theory
375
(O11) Ad(s) →∀⃗u ∈s∀x ∈s (∀y ∈x ∃z ∈s B[y, z, x, ⃗u] →
∃w ∈s ∀y ∈x ∃z ∈w B[y, z, x, ⃗u])
for all Δ0 formulae B[a, b, c, ⃗d].
The axioms (O8)–(O11) assert that every admissible set is a model of pairing,
union, Δ0 separation and Δ0 collection, respectively. (O7) asserts that admissible
sets are linearly ordered with respect to ∈.
Arithmetical Axioms.
All
∗-translations of the equality axioms and the axioms pertaining to SUC, ADD,
and MULT of Deﬁnition 2.3 (i) and (ii).
Set Existence Axioms.
(Pairing) ∃z s ∈z ∧t ∈z).
(Union) ∃z (z =  s).
(Δ0 Separation) ∃z[Set(z) ∧∀x ∈z(x ∈s ∧A(x)) ∧∀x ∈s(A(x) →x ∈z)]
for A(a) in Δ0.
Induction Axioms.
(Δ0-FOUND) Tran(s) ∧∀x ∈s(∀y ∈x A(y) →A(x)) →∀x ∈s A(x)
whenever A(a) is Δ0.
(Ind)∗¯0 ∈s ∧∀xy ∈N[SUC(y, x) ∧y ∈s →x ∈s] →∀x ∈N x ∈s.
As logical rules of BT we choose Modus Ponens and the following quantiﬁer
rules:
A →F(a) ⊢A →∀xF(x)
F(a) →A ⊢∃F(x) →A
A →(a ∈s →F(a)) ⊢A →∀x ∈sF(x)
(F(a) ∧a ∈s) →A ⊢∃x ∈sF(x) →A
with the proviso that a does not occur in the conclusion.
If T is a theory in the language L∗(M) which comprises BT then T ⊢A is meant
to convey that A is deducible from the axioms of T via the above rules of inference.
Remark 2.11. All non-logical axioms of BT are of the form G[⃗s] where G[⃗a] is a
Σ1 formula.
Also note that none of the axioms of BT asserts that any admissible sets exist.

376
Michael Rathjen
Lemma 2.12. ACA0 ⊆BT.
Proof. The ⊆symbol is meant to convey that every theorem of ACA0 is a
theorem of BT via the
∗-translation. This is proved by induction on the length
of derivations in ACA0. The only interesting cases to inspect are the arithmetical
comprehension axioms. The
∗-translation turns them into instances of Δ0 separa-
tion.
At this point, having introduced a great deal of the formal background for the
paper, we can rejoice. Perhaps a few words about BT are in order. We assume that
the reader is acquainted with the theory of admissible sets. The standard reference
for admissible sets and an excellent presentation at that is [3]. The axioms (O6),
(O8)–(O11) and Δ0-FOUND ensure that, provably in BT, every set A which sat-
isﬁes Ad(A) is a model of the theory KPU+ of [3] with the set of natural numbers
as urelements.
Deﬁnition 2.13. The theory KPu comprises BT and has the following additional
axioms.
(Δ0-Collection) ∀x ∈s ∃y A(x, y) →∃z∀x ∈s∃y ∈z A(x, y)
where A(a, b) ∈Δ0;
(IND∗) ∀xy ∈N (SUC(y, x) ∧F(y) →F(x)) →∀x ∈N F(x);
(FOUND) ∀x(∀y ∈xF(y) →F(x)) →∀xF(x),
where in the last two schemata F(a) may be any formula of L∗(M).
In naming this theory KPu we follow the usage of [27].
Remark 2.14. One cannot prove the existence of an admissible set in KPu. As a
result, the axioms (O6)–(O11) are immaterial as far as the proof strength of KPu
is concerned. In more detail, letting KPu−denote KPu restricted to the language
L∗without the predicate symbol Ad, we have
KPu ⊢A ⇒KPu−⊢A−
for every formula A of L∗, where A−results from A by replacing any occurrence
Ad(s) in A by ¯0 ̸= ¯0 and any occurrence of M by N. This shows that KPu is a
conservative extension of KPu−.
As regards the predicate Ad, it plays a role in extensions of BT which prove
∃xAd(x). Examples of such systems are the theories KPl and KPi introduced
in [27]. KPl axiomatizes a set universe which is a limit of admissible sets while
KPi also demands that the universe itself be an admissible set (or class).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
377
Deﬁnition 2.15. KPl is the theory BT + (IND∗) + (FOUND) + (Lim) + (M),
where (Lim) is the axiom schema ∃y(Ad(y) ∧s ∈y) and (M) is the axiom
Ad(M) ∧∀x ∈M ¬Ad(x).
KPi is the theory KPu + KPl.
In what follows, theories having only restricted versions of (FOUND) or
(IND∗) as axioms will be of great importance. Such theories are interesting be-
cause of the following observations. In mathematics one mostly uses only limited
amounts of induction. From proof theory we know that restricting the amount of
induction tends to give rise to theories of much weaker proof-theoretic strength.
Deﬁnition 2.16. If T is a theory whose axiom schemata comprise (IND∗) and
(FOUND) we denote by Tw the theory without (FOUND) and by Tr the theory
without (FOUND) and (IND∗).
Using this convention, KPlw is BT + (IND∗) + (Lim) + (M) and KPlr is
BT + (Lim) + (M).
Remark 2.17. The combination of (Lim), (O7) and (Δ0-FOUND) implies
∃!y(Ad(y) ∧∀z ∈y¬Ad(z)). Therefore KPlr is a deﬁnitional extension of
KPlr without (M).
2.6 Some derivable consequences
We show some basic principles that can be deduced in theories introduced so far.
For future reference some will be labeled with traditional names.
Lemma 2.18. KPu ⊢F[⃗a] ⇒KPlr ⊢Ad(s) →∀⃗x ∈s F s[⃗x].
Proof. Proceed by induction on the length of the derivation in KPu.
The main use we shall make of the foregoing lemma is that every statement that
can be proved in KPu about the universe of sets can be transferred to KPlr by
relativizing it to any admissible set.
Proofs for the following four results can be found in [3], I.4.2-4.4.5.
Lemma 2.19. (Σ Persistence) For every Σ formula A we have:
(i) BT ⊢As ∧s ⊆t →At;
(ii) BT ⊢AS →A.
Lemma 2.20. (Σ Reﬂection) For A ∈Σ we have KPur ⊢A →∃x Ax.

378
Michael Rathjen
Lemma 2.21. (Σ Collection ) For every Σ formula F(a, b),
KPur ⊢∀x ∈s ∃y F(x, y) →∃z[∀x ∈s ∃y ∈z F(x, y) ∧∀y ∈z ∃x ∈s F(x, y)].
Lemma 2.22. (Δ Separation ) If A(a) is in Σ and B(a) is in Π then
KPur ⊢∀x [A(x) ↔B(x)] →∃z(Set(z) ∧∀x[x ∈z ↔A(x)]).
Lemma 2.23. (Σ Replacement ) For every Σ formula F(a, b),
KPur ⊢∀x ∈s ∃!y F(x, y) →∃f[Fun(f) ∧dom(f) = s ∧∀x ∈s F(x, f(x))].
An powerful tool in set theory is deﬁnition by transﬁnite recursion. The most
important applications are deﬁnitions of functions by Σ recursion. The axioms
of KPu are sufﬁcient for this task. A closer inspection of the well known proof
(see [3], I.6.1)) reveals that a restricted form of foundation, dubbed (Σ-FOUND),
sufﬁces.
(Σ-FOUND) is the schema
∀x[∀y ∈x F(y) →F(x)] →∀x F(x)
for F(a) ∈Σ.
Lemma 2.24. (Σ Recursion ) KPur + (Σ-FOUND) proves all instances of Σ
recursion, (Σ-REC),
∀α∀x∃!y G(α, x, y) →∀α∃f[Fun(f) ∧dom(f) = α ∧(∀β < α)G(β, f↾β, f(β))]
where G(a, b, c) ∈Σ and f↾β = {⟨δ, z⟩| δ < β ∧⟨δ, z⟩∈f}.
Remark 2.25. The formalization of systems of set theory with a predicate ear-
marked for the class of admissible sets was introduced in [27] for proof-theoretic
purposes. Singling out KPl as a system worthy of attention owes much to the ob-
servation (see [3], V.6.12) that Lα is a model of axiom Beta (see [3, I.9.4]) if α is
a limit of admissible ordinals.
3 Theories of iterated inductive deﬁnitions
In this section we introduce second theories of iterated inductive deﬁnitions formal-
ized in the language of second order arithmetic. Till now such theories were formu-
lated as ﬁrst order theories with quantiﬁers just ranging over the natural numbers
but with the aid of predicate symbols to represent inductively deﬁned sets (see [10]).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
379
In this restricted language one can only talk about well orderings deﬁned by arith-
metical formulae. Moving to L2 enables one to reformulate these theories via set
existence axioms and to talk about iterated inductive deﬁnitions where the iteration
is carried out along arbitrary well orderings.
Instead of pursuing a proof-theoretic analysis of such theories directly via spe-
ciﬁc inﬁnitary proof systems taylored to accommodate iterated inductive deﬁnitions
(as e.g. in [10]), we analyze them by ﬁrst embedding them into germane set theo-
ries and subsequently use the general machinery for ordinal analysis of set theories.
In this way we obtain uniform and simultaneous ordinal analyses of almost all the-
ories of inductive deﬁnitions. An example which illustrates the uniformity of the
method is the theory ID≺∗introduced in [15]. An analysis of ID≺∗was carried
out in [5] by means of the Ων-rules. An sketch of an ordinal analysis of this theory
by Pohlers’ so-called method of local predicativity was adumbrated in [42]. But
a full analysis using this technique didn’t materialize before [73] (169 pages), and
turned out to be quite a formidable task. Therefore I consider it in order to add a
further proof, in particular as it is more or less a by-product of the investigation of
yet stronger theories of iterated inductive deﬁnitions.
As per usual, to begin with we need to set up some terminological conventions.
Deﬁnition 3.1. Let Q(a, b) be a formula of L2 (which may contain additional pa-
rameters, i.e. free variables). When we view Q as a binary relation we shall write
sQt for Q(s, t). Let F(a) be an arbitrary formula of L2. We will use the following
abbreviations:
Fld(s) := ∃x(sQx ∨xQs)
(s is in the ﬁeld of Q);
LO(Q) := ∀x¬(xQx) ∧∀xy[Fld(x) ∧Fld(y) →xQy ∨x ≡y ∨yQx]
∧∀xyz[xQy ∧yQz →xQz]
(Q is a linear order);
PROG(Q, F) := ∀x[∀y(yQx →F(y)] →F(x)]
(F is Q progressive);
TI(Q, F) := PROG(Q, F) →∀x F(x)
(Q induction for F);
WF(Q) := ∀X TI(Q, X)
(Q is well founded);
WO(Q) := LO(Q) ∧WF(Q)
(Q is a well-ordering).
We shall use the primitive recursive pairing function
⟨m, n⟩:= 1
2(m + n)(m + n + 1) + m.
If U is a set we denote by Us the set {x | ⟨s, x⟩∈U}.
We shall use the notation F(P+) to convey that F(P) ∈Π1
0(P+) (see Deﬁnition
2.7). Such formulae are said to be P-positive arithmetical formulae. If H(a) is

380
Michael Rathjen
any formula then F(H) denotes the formula obtained by replacing all occurrences
of the form P(t) and P(x) by H(t) and H(x), respectively, with the usual proviso
that we may have to rename some bound variables to avoid any unintended capture
of variables.
Deﬁnition 3.2 (ID≺∗). Let ≺be a linear ordering on N, deﬁnable via an arith-
metical formula Q[a, b] such that ACA0 ⊢LO(≺). The vocabulary of ID≺∗,
L(ID≺∗), comprises that of L1 but in addition has a unary predicate symbol Q∗
to denote the accessible part of ≺and moreover for every P-positive arithmetical
formula F[P+, U, a, b] it has a two-place predicate symbol IF .
The axioms of ID≺∗comprise those of Deﬁnition 2.3(i),(ii) and the induction
schema (IND) for all formulae of L(ID≺∗). Further axioms of ID≺∗are the
following:
(Q∗1) PROG(≺, Q∗)
(Q∗2) PROG(≺, H) →∀x [Q∗(x) →H(x)]
(IQ∗1) Q∗(t) →∀x ( F[IF
t , IF
≺t, t, x] →x ∈IF
t ]
(IQ∗2) Q∗(t) ∧∀x (F[H, IF
≺t, t, x] →H(x)) →∀x(x ∈IF
t →H(x))
for every arithmetical formula F[P+, U, a, b] and every L(ID≺∗) formula H(a),
where we used the notations s ∈IF
t
:= IF (t, s) and
IF
≺t := {z | ∃y(y ≺t ∧z ∈IF
y }.
All arithmetical well-orderings have an order-type less than the ﬁrst recursively
inaccessible ordinal ωCK
1
. Since the accessible part of a primitive recursive or-
dering can have order-type ωCK
1
(see [21]) it seems that ID≺∗may be able to
axiomatize iterated inductive deﬁnitions along non-arithmetical well orderings in
contrast to what we said at the beginning of this section about previous investiga-
tions of such theories in proof theory. This point will be clariﬁed later once we
have embedded ID≺∗into a second order system.
Deﬁnition 3.3. For formulae F(P, U, a, b) and Q(a, b) we use the abbreviations
ClF (V, U, s) := ∀x[F(V, U, s, x) →x ∈V ]
ITF (Q, U) := ∀i [ClF (Ui, UQi, i) ∧∀Y (ClF (Y, UQi, i) →Ui ⊆Y )],
where Ui := {x | ⟨i, x⟩∈U} and UQi := {x | ∃j(jQi ∧⟨j, x⟩∈U}.
Deﬁnition 3.4.
(i) Let ID∗be the theory ACA augmented by the schema
(IT∗1)
∀x[WO(≺x) →∃Z ITF (≺x, Z)]

Investigations of Subsystems of Second Order Arithmetic and Set Theory
381
for every formula F[P +, U, a, b] (having no further parameters) and every
family of relations (≺n)n∈N, which is deﬁnable by some arithmetical formula
Q[a, b, c] via s ≺r t := Q[s, t, r].
(ii) ID∗
2 arises from ID∗by adding the schema
(IT∗2)
∀x∀i∀Z[WO(≺x) ∧ITF (≺x, Z) ∧ClF (H, Z≺xi, i) →Zi ⊆H]
with the same conditions on F as above and every formula H(a).
ID∗
2 makes greater demands than ID∗in that if WO(≺s) holds and U satisﬁes
ITF (≺s, U), then every section Ui of U will also be contained in all L2-deﬁnable
classes closed under the operator X →{z | F[X, U≺si, z]}.
It is obvious that ID∗
2 merely axiomatizes iterations of length < ωCK
1
. However,
the strength of ID∗
2 is owed to the fact that the arithmetical well-orderings may
depend on numerical parameters which can be quantiﬁed over. E.g. if ≺e is deﬁned
by n ≺e m := ∃y T2(e, n, m, y) where T2 stands for the well-known primitive
recursive predicate from Kleene’s normal form theorem, then via the statement
∀x[WO(≺x) →∃Z ITF (≺x, Zx)] we quantify over all iterations below ωCK
1
.
On the other hand, in general it is not possible to deduce
∃Z∀x[WO(≺x) →ITF (≺x, Zx)]
within ID∗
2 which would amount to an iteration of length ωCK
1
.
If one lifts the restriction to arithmetical well-orderings and allows arbitrary pa-
rameters in the operator forms in the schemata (IT∗1) and (IT∗2) one arrives at
autonomous theories of arithmetical inductive deﬁnitions which provide the nat-
ural limit of all such theories. Furthermore, we also consider the wider class of
monotone inductive deﬁnitions.
Deﬁnition 3.5.
(i) AUT-IDpos is the theory ACA augmented by the schema
(ITpos1)
∀X[WO(X) →∃Z ITF (X, Z)]
for every arithmetical formula F(P +, U, a, b).
(ii) AUT-IDmon is the theory ACA augmented by the schema
(ITmon1)
MON(F) →∀X[WO(X) →∃Z ITF (X, Z)]
for every arithmetical formula F(P, U, a, b), where
MON(F) := ∀i∀x∀X∀Y ∀Z[X ⊆Y ∧F(X, Z, i, x) →F(Y, Z, i, x)].

382
Michael Rathjen
(iii) By AUT-IDpos
2
we denote the theory AUT-IDpos plus the scheme
(ITpos2)
WO(R) ∧ITF (R, U) ∧ClF (H, URs, s) →Us ⊆H
for every arithmetical formula F(P +, U, a, b) and arbitrary L2-formula H(b).
In the same vein one deﬁnes (ITmon2) and the theory AUT-IDmon
2
.
(iv) If T is an L2 theory deﬁned by adding axioms to ACA, then T0 denotes the
theory which is obtained by adding the same axioms to ACA0.
Remark 3.6. For P-positive formulae F(P+, U, a, b), MON(F) is provable in
pure logic. Thus axioms for monotone inductive deﬁnitions imply the corresponding
axioms for positive ones.
In Deﬁnition 3.1 we deﬁned well-foundedness of a relation in a somewhat un-
usual way. One can prove in ACA0 that our deﬁnition is equivalent to the usual
one.
Lemma 3.7. ACA0 ⊢WF(R) ↔∀Z[Z ̸= ∅→∃x ∈Z ∀y(yRx →y /∈Z)].
Proof. Exercise or see [17], 6.1.5.
Lemma 3.8. ACA0 ⊢WO(R) ∧ITF (R, U) ∧ITF (R, V ) →∀i (Ui = Vi).
Proof. Assume WO(R), ITF (R, U), ITF (R, V ) but Ui ̸= Vi for some i. By
Lemma 3.7 we can pick an R-minimal i0 with Ui0 ̸= Vi0. By minimality, URi0 =
VRi0, and thus Cl(Ui0, VRi0, i0) as well as Cl(Vi0, URi0, i0). As a result, Vi0 ⊆Ui0
and Ui0 ⊆Vi0, yielding the contradiction Ui0 = Vi0.
Deﬁnition 3.9. We deﬁne an interpretation ⋏: ID≺∗−→ID∗
2, where ≺is given
by a formula Q[a, b]. Let s ≺r t := s ≺t ∧(t ≡r ∨t ≺r),
Acc(≺, U) := PROG(≺, U) ∧∀Z[PROG(≺, Z) →U ⊆Z],
PF (r, s) := ∃Z[ITF (≺r, Z) ∧s ∈Zr]
for every arithmetical formula F[P+, U, a, b].
If A is a formula of ID≺∗then A⋏arises from A by replacing all subformulas
Q∗(s) and IF (r, s) in A by ∃X[s ∈X ∧Acc(≺, X)] and PF (r, s), respectively.
Theorem 3.10. If ID≺∗⊢A then ID∗
2 ⊢A⋏.
Proof. It sufﬁces to prove the translations of axioms arising from the schemata
(Q∗1), (Q∗2), (IQ∗1) and (IQ∗2) in ID∗
2. We reason in the target theory ID∗
2. Let
G[P+, U, a, b] := ∀y[y ≺b →P(y)].

Investigations of Subsystems of Second Order Arithmetic and Set Theory
383
There exists a set V such ITG(∅, V ). For S := V¯0 we have Acc(≺, S). As in
Lemma 3.8 one shows that thereby S is uniquely determined, i.e.
∀X[Acc(≺, X) →X = S].
Therefore we get ∀x[(Q∗(x))⋏↔x ∈S) and thus (PROG(≺, Q∗))⋏. As a result,
provability of the translation of (Q∗2) follows with the help of (IT∗2).
To prove the translations of (IQ∗1) and (IQ∗2) suppose that (Q∗(r))⋏holds, i.e.
r ∈S. If ¬WO(≺r) then by Lemma 3.7 there exists a set U such that r ∈U and
∀x ∈U ∃y ∈U (y ≺r x). Letting Uc := {i | i /∈U} we have PROG(≺, U c) and
thus S ⊆U c by choice of S. But this is incompatible with r ∈U. Hence ≺r must
be a well-ordering.
Now let F[P+, U, a, b] be an arithmetical P-positive formula. From (IT∗1) we
obtain the existence of a set V satisfying ITF (≺r, V ). By Lemma 3.8 we conclude
that
∀i[i ≺r ∨i ≡r →∀x((IF (i, x))⋏↔x ∈Vi)],
and hence (IF
≺r)⋏= V≺r and (IF
r )⋏= Vr. From the foregoing and (IT∗2) we
obtain the derivability of the ⋏-translations of (IQ∗1) and (IQ∗2).
Deﬁnition 3.11. Bar induction, abbreviated (BI), is the schema
∀X [WO(X) →TI(X, H)]
for every L2-formula H(a).
Lemma 3.12. (BI) is a consequence of AUT-IDpos
2
.
Proof. Assume WO(R) and PROG(R, H). We aim at showing ∀x H(x). Let
F(P+, U, a, b) := ∀z[zRb →P(z)]. Owing to (ITpos1) there exists a set V such
that ITF (∅, V ). Letting S := V¯0 and employing (ITpos2) we obtain
PROG(R, S)
and
PROG(R, H) →S ⊆H.
Hence ∀x (x ∈S) ∧S ⊆H, thus ∀x H(x).
Theorem 3.13.
(i) ID∗
2 ⊆ID∗+ (BI).
(ii) AUT-IDpos
2
= AUT-IDpos + (BI).
(iii) AUT-IDmon
2
= AUT-IDmon + (BI).

384
Michael Rathjen
Proof. (ii) In view of Lemma 3.12 it sufﬁces to show that the instances of
(ITpos2) can be derived in AUT-IDpos with the help of (BI). Assume WO(R),
ITF (R, V ) and ClF (H, VRs, s). Letting G(U) := ClF (U, VRs, s) →Vs ⊆U, we
have
∀Z G(Z).
(3.1)
Moreover,
ACA0 + (BI) ⊢∀Z A(Z) →A(H)
(3.2)
holds for every arithmetical formula A(U) and arbitrary L2-formula H(a) (see
[15], Lemma 1.6.3). As G(U) is arithmetical we get Vs ⊆H from (3.1) and (3.2).
This shows (ITpos2).
(i) and (iii) are proved similarly, crucially using (3.2) and also Lemma 3.12 for the
“⊇” entailments.
Remark 3.14. Up to the year 1981, the monograph [10] gives a comprehensive
account of the proof theory of iterated inductive deﬁnitions. The preface written by
Feferman provides a detailed history of the subject.
4 Theories of iterated Π1
1-comprehension
It is a classical result (see [34, 68]) that every Π1
1-set of the structure N =
(N, 0, +, ·) can be obtained as a section of a ﬁxed point of a positive arithmeti-
cal inductive deﬁnition. As an extension of this result there is a close connection
between iterated inductive deﬁnitions and iterated Π1
1-comprehensions. The next
deﬁnition provides a precise deﬁnition of the latter sort of theory.
Deﬁnition 4.1. For every Π1
1-formula B(U, a, b) let
HJB(R, U) := ∀x∀i[x ∈Ui ↔B(URi, i, x)],
where URi = {y | ∃j (jRi ∧y ∈Ui)}.
(i) (Π1
1-TR) is the schema
∀X [WO(X) →∃Y HJB(X, Y )]
where B(U, a, b) is Π1
1.
(ii) The theory of Π1
1 transﬁnite recursion, Π1
1-TR, is ACA augmented by the
schema (Π1
1-TR).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
385
Lemma 4.2 (ACA0). If WO(R), HJB(R, U) and HJB(R, V ), then Ui = Vi
holds for all i.
Proof. Analogous to Lemma 3.8.
Lemma 4.3. AUT-IDmon
0
⊆Π1
1-TR0.
Proof.
We have to show that (ITmon1) is deducible in Π1
1-TR0.
Let
F(P, U, a, b) be arithmetical and set B(U, a, b) := ∀Z[ClF (Z, U, a) →b ∈Z].
Now assume WO(R) and MON(F). Invoking (Π1
1-TR), there exists a set S such
that HJB(R, S). For all i we then have
Si = {x | ∀Z[ClF (Z, SRi, i) →x ∈Z]}
and hence
∀Z[ClF (Z, SRi, i) →Si ⊆Z].
Thus if F(Si, SRi, i, s) and ClF (U, SRi, i) hold, then from (4.1) we obtain Si ⊆U
and, since MON(F), we have F(U, SRi, i, s) and consequently s ∈U. So in
view of (4.1) the preceding argument shows that F(Si, SRi, i, s) →s ∈Si holds.
Thence
Cl(Si, SRi, i).
(4.1) and (4.1) yield ITF (R, S).
Corollary 4.4. For every Π1
1-formula F(P, U, a, b),
Π1
1-TR0 ⊢MON(F) →∀X[WO(X) →∃Z ITF (X, Z)].
Proof.
Since (Σ1
1-AC) is deducible in Π1
1-CA0 (cf.
5.11(i)), the formula
ClF (V, U, a, b) is provably equivalent to a Σ1
1-formula in Π1
1-TR0, thus B(U, a, b)
is equivalent to a Π1
1-formula.
To prove the inclusion Π1
1-TR0 ⊆AUT-IDpos
0
, we shall need the inductive
characterization of Π1
1 classes mentioned at the beginning of this section. Un-
fortunately, the usual proofs in the literature (cf. [3], VI.1.11 and [25], III.3.2)
cannot be directly carried out in AUT-IDpos
0
since they utilize ordinals or use
Π1
1-comprehension. Albeit Π1
1-comprehension is a consequence of AUT-IDpos
0
,
we cannot use it at this point since this is part of what we want to prove. ACA0
sufﬁces for the desired characterization of Π1
1 classes.

386
Michael Rathjen
Lemma 4.5. For every Π1
1-formula B(U, a, b) one can construct an arithmetical
formula
F(P+, U, a, b) such that
ACA0 ⊢∀X∀i∀z [B(Y, i, z) ↔∀Z [ClF (Z, Y, i) →⟨z, ¯1⟩∈Z]].
Proof. By the Π1
1 normal form theorem (cf. [25, IV.1.]) one ﬁnds an arithmetical
formula Q(U, a, b, c, d) such that with c ≺b d := Q(U, a, b, c, d) one has
ACA0 ⊢∀z [B(U, a, z) ↔WO(≺z)];
ACA0 ⊢∀z∀x [Fld(x, ≺z) →(x ≺z ¯1 ∨x ≡¯1)].
((4.1) follows from the fact that ≺s is a relation on codes of sequences of natural
numbers and ¯1 encodes the empty sequence.) Immediately from (4.1) we have
∀x [x ≺s ¯1 →x ∈V ) →TI(≺s, V ).
Deﬁne
F(Z+, U, a, ⟨b, c⟩) := ∀x (x ≺b c →y ∈V ),
A(V, b, c) := TI(≺b, V ) ∨∀y(y ≺b c →y ∈V ),
C(b, c) := ∀Z [ClF (Z, U, a) →⟨b, c⟩∈Z).
We aim at showing
∀Y A(Y, s, t) ↔C(s, t).
“⇒”: ClF (R, U, a) implies PROG(≺s, Rs), thus ∀y(y ∈Rs) ∨(t ∈Rs) since
A(Rs, s, t) holds. Thus ⟨s, t⟩∈R.
“⇐”:
Given a set V , let V ∗
:=
{⟨z, u⟩
|
A(V, z, u)}.
Suppose that
F(V ∗, U, a, ⟨b, c⟩). Then ∀x[x ≺b c →A(V, b, x)], thus
TI(≺b, V ) ∨∀xy [x ≺b c ∧y ≺b x →y ∈V ].
Consequently, we have
TI(≺b, V ) ∨¬PROG(≺b, V ) ∨∀x [x ≺b c →x ∈V ],
hence A(V, b, c), thus ⟨b, c⟩∈V ∗. As a result we have shown ClF (V ∗, U, a).
Thence the assumption C(s, t) yields ⟨s, t⟩∈V ∗, so that A(V, s, t) holds.
We have thus shown (4.1). From (4.1) we can conclude
A(V, s, ¯1) ↔TI(≺s, V ).
Combining (4.1), (4.1), and (4.1) we arrive at ∀z [B(U, a, z) ↔C(z, ¯1)], as de-
sired.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
387
Theorem 4.6.
(i) Π1
1-TR0 = AUT-IDpos
0
= AUT-IDmon
0
.
(ii) Π1
1-TR = AUT-IDpos = AUT-IDmon.
(iii) Π1
1-TR + (BI) = AUT-IDpos
2
= AUT-IDmon
2
.
Proof. (i) implies (ii) and by Theorem 3.13 also (iii). For (i), in view of Lemma
4.3, it sufﬁces to show Π1
1-TR0 ⊆AUT-IDpos
0
. Let B(U, a, b) be Π1
1 and choose
F(P+, U, a, b) as in Lemma 4.5. Let
G(P+, U, a, b) := F(P, {x | ⟨x, ¯1⟩∈U}, a, b).
On account of (ITpos1), for every well ordering R there exists a set V such that
ITG(R, V ).
(4.1) implies
∀Z [ClF (Z, {x | ⟨x, ¯1⟩∈VRa}, a) →Va ⊆Z]
and ClF (Va, {x | ⟨x, ¯1⟩∈VRa}, a), which by choice of F(P, U, a, b) entails
∀z [B({x | ⟨x, ¯1⟩∈VRa}, a, z) →⟨z, ¯1⟩∈Va].
With V ∗:= {⟨i, z⟩| ⟨i, ⟨z, ¯1⟩⟩∈V }, (4.1) implies ∀iz [B(V ∗
Ri, i, z) ↔z ∈V ∗
i ],
and hence HJB(R, V ∗).
Corollary 4.7. Owing to Corollary 4.4, the identities of Theorem 4.6 also hold for
iterated Π1
1 inductive deﬁnitions instead of iterated arithmetical inductive deﬁni-
tions.
Remark 4.8.
(i) The main purpose of this section was preparatory work for the
interpretation of Π1
1-TR0 into systems of set theory. The equivalences of Theo-
rem 4.6 lend itself to rather transparent interpretations into theories of iterated
admissibility.
(ii) Historically, reductions of subsystems of second order arithmetic played an
important role in proof theory (cf. [10,15,19]). Theorem 4.6 can be viewed as
a tribute to those times.
(iii) The idea of proof of Lemma 4.3 using the characterization of a ﬁxed point IΓ
of an operator Γ by means of IΓ = {X | Γ(X) ⊆X} is of course the
standard one.

388
Michael Rathjen
5 Set theories of iterated admissibility
Theories of iterated inductive deﬁnitions have a canonical interpretation in set the-
ories of iterated admissibility. The structure theory of Σ+-inductive deﬁnitions on
admissible sets (cf. [3, VI.2]) will be useful here.
Deﬁnition 5.1.
(i) Let D[α, f] denote the conjunction of the formulae Ord(α),
Fun(f), dom(f) = α, and
(∀β < α)[Ad(f(β)) ∧(∀η < β) (f(η) ∈f(β)) ∧
(∀x ∈f(β))[Ad(x) →(∃η < β) (x = f(β))]].
(ii) (AUT-Ad) := ∀α∃f D[α, f].
(iii) AUT-KPl := KPl + (AUT-Ad).
(iv) (Ad∗) := (∀α ∈M) ∃f D[α, f].
(v) KPl∗:= KPl + (Ad∗).
AUT-KPl axiomatizes a set universe that has as many admissible sets as or-
dinals and in which the admissible sets are linearly ordered, whereas KPl∗only
asserts that there are at least as many admissible sets as there are ordinals below
ωCK
1
, i.e. ordinals in the least admissible set above the urelement structure of the
natural numbers.
Lemma 5.2.
(i) KPlr ⊢D[α, f] ∧D[α, g] →f = g.
(ii) KPl∗⊢(∀α ∈M) ∃!f D[α, f].
Proof. (i): Suppose that D[α, f] and D[α, g]. We show ∀β < α (f(β) = g(β)
by induction on β, a principle justiﬁed by (Δ0-FOUND). Let β < α and assume
by induction hypothesis that f ↾β = g ↾β (where h ↾β is the restriction of the
function h to the domain β). Since Ad(f(β)) and Ad(g(β)) hold it follows from
axiom (O7) that f(β) ∈g(β) ∨f(β) = g(β) ∨g(β) ∈f(β). As Ad(f(β)) and
D[α, g] hold, f(β) ∈g(β) would entail the existence of an ordinal η < β such
that f(β) = g(η) = f(η), contradicting D[α, f]. Likewise one can rule out that
g(β) ∈f(β). Hence f(β) = g(β).
Finally, f ↾α = g ↾α yields f = g.
(ii) is an immediate consequence of (i).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
389
Lemma 5.3. Let D0[a, α, f] be the conjunction of the following formulas: Ord(α),
Fun(f), dom(f) = α ∪{0}, Ad(a), f(0) = a, and
(∀β < α)[Ad(f(β)) ∧(∀η < β) (f(η) ∈f(β)) ∧
(∀x ∈f(β))[Ad(x) ∧a ∈x →(∃η < β) x = f(β)]].
We then have AUT-KPlr ⊢Ad(a) →∀α ∃!f D0[a, α, f].
Proof. Uniqueness of f can be proved as in Lemma 5.2. To prove existence
suppose Ad(a). Invoking the axiom (Lim), there are admissible sets b and c such
that a, α ∈b and b ∈c. Δ0 separation relativized to c ensures the existence of
ρ := {η ∈b | Ord(η)} with ρ ∈c. We also have ρ /∈b. Moreover, by (AUT-Ad)
there exists a function g such that D[ρ+ρ, g]. The existence of the ordinal ρ+ρ ∈c
can be established in the usual way since c is admissible. Using (Δ0-FOUND) one
easily shows that (∀η < ρ + ρ) η ∈g(η + 1). Since ρ ∈g(ρ + 1) and ρ /∈a, the
axiom (O7) ensures that a ∈g(ρ + 1). Thus there exists δ < ρ + 1 such that
a = g(δ). Also α < ρ. The desired function f can be deﬁned by f(η) := g(δ + η)
for η < α. One easily veriﬁes that D0[a, α, f].
Deﬁnition 5.4.
Fld(s, r) := ∃x [⟨x, s⟩∈r ∨⟨s, x⟩∈r].
Lo(a, r) := r ⊆a × a ∧“r is a linear ordering” (cf. 3.1).
Wf(a, r) := r ⊆a × a ∧∀x[x ̸= ∅∧x ⊆a →(∃y ∈x) (∀z ∈x) ⟨z, y⟩/∈r].
Wo(a, r) := Lo(a, r) ∧Wf(a, r).
Deﬁnition 5.5. (Axiom Beta) If r is a well-founded relation on a, i.e. Wf(a, r), then
f is said to be a collapsing for r, abbreviated by Collab(a, r, f), if the following
holds:
Fun(f) ∧dom(f) = a ∧(∀x ∈a) (f(x) = {f(y) | ⟨y, x⟩∈r}).
Axiom Beta (cf. [3, I.9.4]) is the assertion ∀u∀v ∃f [Wf(u, v) →Collab(u, v, f)].
Theorem 5.6. KPlr proves axiom Beta. Inspection of the usual proof actually
shows that KPlr proves something stronger, namely that if Wf(a, r), ⟨a, r⟩∈b,
and Ad(b), then the function which is collapsing for r is also an element of b.
Proof. The proof is just a slight variation of the standard proof from KP +
(Σ1-separation) in [3, Theorem 9.6]: Just do the deﬁnition of the function F inside
an admissible set A which contains the well-founded relation r. Then Σ1 separation
can be replaced by Δ0 separation involving A as a parameter. For more details
see [32, Theorem 4.6].

390
Michael Rathjen
Theorem 5.7. Every instance of (BI) is a theorem of KPl (via the translation
∗
of Deﬁnition 2.5).
Proof. By means of axiom Beta every well-ordering ≺on N is order-isomorphic
to an ordinal α. As a result, the schema of transﬁnite on ≺is implied by (FOUND).
For more details see [32, Lemma 7.1].
Lemma 5.8 (Iterated inductive deﬁnitions in AUT-KPlr and KPl∗). For
A[P+, b, c, d,⃗t] in Δ0(P+) let
ClA
N(a, b, c,⃗t) := ∀j ∈N(A[a, b, c, j,⃗t ] →j ∈a)
and ITA
N(r, a,⃗t) be the conjunction of a ⊆N × N and
(∀i ∈N)[ClA
N((a)i, (a)ri, i,⃗t) ∧∀z ⊆N(ClA
N(z, (a)ri, i,⃗t) →(a)i ⊆z)],
where (a)i := {k ∈N | ⟨i, k⟩∈a} and
(a)ri := {k ∈N | (∃m ∈N)(⟨m, i⟩∈r ∧⟨m, k⟩∈a)}.
(i) AUT-KPlr ⊢Wo(N, r) →∃y ITA
N(r, y,⃗t ).
(ii) KPl∗⊢Wo(N, r) ∧r, t ∈M →∃y ITA
N(r, y,⃗t ).
Proof. (ii): Suppose Wo(N, r) and r,⃗t ∈M. Let S := {k ∈N | Fld(k, r)}.
Then S ∈M and Wo(S, r). By Theorem 5.6 there exists a function h ∈M such
that Collab(S, r, h). Then rng(h) is an ordinal α ∈M, h : S →α is bijective and,
moreover, (∀ij ∈S)(⟨i, j⟩∈r →h(i) < h(j)). By (Ad∗) there exists a function
f such that D[α, f]. In particular, f(0) ∈M. Using axiom (Lim) there exists an
admissible set K such that α, f, M ∈K. Let Kβ := f(β) for β < α. Within
the admissible K we simultaneously deﬁne a function g with dom(g) = α and a
sequence of functions (fβ)β<α by Σ recursion as follows:
fβ(ξ) := {k ∈N | A[

{fβ(γ) | γ < ξ},

{g(δ) | δ < β}, h−1(β), k,⃗t ]},
g(β) :=

rng(fβ).
For i ∈N \ S let fi be a function with dom(fi) = {ξ | ξ ∈M} deﬁned by Σ
recursion in K via
fi(ξ) := {k ∈N | A(

{fi(γ) | γ < ξ}, ∅, i, k,⃗t ]}.
Also let
a := {⟨i, k⟩| i ∈S ∧k ∈g(h(i))} ∪{⟨i, k⟩| i ∈N \ S ∧k ∈rng(fi)}.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
391
By construction, f, g, (fβ)β<α, and a are elements of K. To begin with we show
that for i ∈N \ S,
ClA
N((a)i, (a)ri, i,⃗t ),
∀z ⊆N [ClA
N(z, (a)ri, i,⃗t ) →(a)i ⊆z].
Proof of (5.1): We have (a)ri = ∅since i ∈N \ S. As M is admissible, fi is Σ
deﬁnable in M. If A[(a)i, ∅, i, k,⃗t ] holds for some k ∈N then
j ∈(a)i ↔∃ξ ∈M (j ∈fi(ξ)),
and therefore, since (a)i occurs positively, utilizing Σ reﬂection in M we arrive at
∃δ ∈M A[

{fi(ξ) | ξ < δ}, ∅, i, k,⃗t ],
thus ∃δ ∈M (k ∈fi(δ)), so k ∈(a)i. This veriﬁes (5.1).
Proof of (5.1): let z ⊆N and suppose ClA
N(z, ∅, i,⃗t ). By transﬁnite induction on
ξ ∈M we show that ∀ξ ∈M (fi(ξ) ⊆z), yielding (5.1). So suppose inductively
that {fi(γ) | γ < ξ} ⊆z. Then
fi(ξ) = {k ∈N | A[

{fi(γ) | γ < ξ}, ∅, i, k,⃗t ]} ⊆{k ∈N | A[z, ∅, i, k,⃗t ]}.
As ClA
N(z, ∅, i,⃗t ) holds, the latter implies fi(ξ) ⊆z.
Next we address the case when i ∈S and to this end show, by induction on
β < α, that
g ↾β ∈Kβ.
Suppose that g ↾δ ∈Kδ for all δ < β. Then also ∀δ < β(g ↾δ ∈Kβ),
and the sequence (g ↾δ)δ<β is thus Σ deﬁnable in the admissible Kβ. Note that
since α ∈M and β < α, we have β ∈Kβ. Using Σ replacement (cf. Theorem
2.23) inside Kβ, we then have (g ↾δ)δ<β ∈Kβ. If β is a limit ordinal we have
g ↾β = {g ↾δ | δ < β} ∈Kβ. Suppose β is a successor ρ + 1. Then g ↾ρ
and dom(fρ) are elements of Kβ. Thus, by Σ recursion in Kβ, fρ belongs to Kβ,
too. Therefore, g ↾β = g ↾ρ ∪{⟨ρ,  rng(fρ)⟩} ∈Kβ. As a result, transﬁnite
induction on β establishes (5.1).
Now assume i ∈S and i = h−1(β). We have to show (5.1) and (5.1) for i. From
(5.1) and the deﬁnition of a we get (a)ri ∈Kβ. Also (a)i = rng(fβ) and, for
ξ ∈Kβ,
fβ(ξ) = {k ∈N | A[

{fβ(γ) | γ < ξ}, (a)ri, i, k,⃗t ]}.

392
Michael Rathjen
So fβ is deﬁnable by Σ recursion in Kβ. From A[(a)i, (a)ri, i, k,⃗t ] it follows, by
Σ reﬂection in Kβ, that
∃ξ ∈Kβ A[

{fβ(γ) | γ < ξ}, (a)ri, i, k,⃗t ],
and hence k ∈(a)i, thereby showing (5.1) for i ∈S. (5.1) can be shown for i ∈S
in the same way as for i ∈N \ S.
(i) can be shown in the same way as (ii), except for a small change which consists
in choosing an admissible set b such that r,⃗t ∈b and invoking Lemma 5.3 to ensure
the existence of a function f with D0[b, α, f].
Theorem 5.9. Via the translation
∗of deﬁnition 2.5 we have
(i) Π1
1-TR0 ⊆AUT-KPlr.
(ii) Π1
1-TR ⊆AUT-KPlw.
(iii) Π1
1-TR + (BI) ⊆AUT-KPl.
(iv) ID≺∗
ˆ
−→ID∗+ (BI) ⊆KPl∗
where in (iv) the ﬁrst the translationˆstems from Deﬁnition 3.9.
Proof. (i) follows from Theorem 4.6(i) and Lemma 5.8(i). (ii) is an immediate
consequence of (i) as does (iii) if viewed in conjunction with Theorem 5.7. It
remains to show (iv). For Q[a, b, c] arithmetical, we have
ri := {⟨j, k⟩| j, k ∈N ∧Q[i, j, k]∗} ∈M
for i ∈N. Therefore Lemma 5.8(ii) and Theorem 5.7 imply that ID∗+ (BI) ⊆
KPl∗. The ﬁrst entailment viaˆis a consequence of Theorem 3.10 and Theorem
3.13(i).
Finally we would like to ﬁnd a set-theoretic pendant to Π1
1-TR + Σ1
2-AC. We
take this as an opportunity to introduce a few more traditional axiom schemata
considered in second order arithmetic (cf. [17]).
Deﬁnition 5.10. Let F be a collection of formulae in L2.
(F-CA) := {∃Z∀x [x ∈Z ↔F(x)] | F(a) ∈F}.
(F-AC) := {∀x∃Y H(x, Y ) →∃Z∀x H(x, Zx) | H(a, U) ∈F}.
(F-DC) := {∀X∃Y G(X, Y ) →∀W∃Z [W = Z¯0 ∧∀x G(Zx, Zx+1)]
| G(U, V ) ∈F}.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
393
(Δ1
2-CA) := {∀x [A(x) ↔B(x)] →∃Z∀x [x ∈Z ↔A(x)]
| A(a) ∈Π1
2, B(a) ∈Σ1
2}.
If (S) denotes any of the above schemata, then S stands for the theory ACA+(S).
The following well-known relationships can be found in [18, Theorem 2.3.1].
Theorem 5.11.
(i) Σ1
1-AC0 ⊆Π1
1-CA0.
(ii) Δ1
2-CA = Σ1
2-AC = Σ1
2-AC.
Theorem 5.12. Π1
1-TR + Σ1
2-AC ⊆KPiw + AUT-KPlw.
Proof. In view of Theorem 5.9(ii) it sufﬁces to show Σ1
2-AC ⊆KPiw. But
this inclusion is a consequence of Theorem 5.11 and Theorem 7.2, a result we shall
show later.
Remark 5.13. (i) Theorem 5.9 crucially uses Lemma 5.8 which is essentially a
generalization of Gandy’s Theorem (cf. [3, VI.2.6]) to the iterated scenario.
(ii) Theories of iterated admissibility were also considered by J¨ager in [30].
However, in the theories in [30] iterated admissibility is couched in terms of infer-
ence rules and they come also equipped with an extended Bar rule. As a result, they
are different from the theories considered here. There are several conjectures about
the proof-theoretic strength of such theories stated in [30]. These conjectures turn
out to be true as they are corollaries of results in this paper. Details will be spelled
out at the appropriate places.
6 Theories of iterated choices and Δ1
2 comprehension
Let N be the standard structure of the natural numbers with language L1. Every
level L(α)N of the constructible hierarchy above N (for a precise deﬁnition see [3,
II]) can be viewed as a structure of the language L∗wherein the predicate symbol
Ad is interpreted by the class {L(β)N | β < α and L(β)N is admissible}.
If T is a theory with language L∗, then the structures L(α)N satisfying and
L(α)N ⊨T are said to be the standard models of T.
The smallest standard model of the theories AUT-KPlr, AUT-KPlw and
AUT-KPl is L(g1(0))N where the mapping ξ →g0(ξ) enumerates the admis-
sible ordinals ≥ωCK
1
and their limits, and (recursively) for α > 0, ξ →gα(ξ)
enumerates the common ﬁxed points of all the functions gβ with β < α.
All further L2-theories to be introduced in this section and in section 8 will
comprise Δ1
2-CA0 and will turn out to be subtheories of Δ1
2-CA + (BI). On

394
Michael Rathjen
the set-theoretic side they correspond to theories in strength between KPir and
KPi. The difference in proof-theoretic strength between the latter two theories is
enormous, albeit both theories have the same minimal standard model L(ι0)N with
ι0 being the least recursively inaccessible ordinal. As a result, the minimal standard
model is hardly indicative of the proof-theoretic strength of these theories. A better
measure is provided by the minimal Π2-model.
Deﬁnition 6.1. L(α)N is a Π2-model of a set theory T, whenever
T ⊢F ⇒L(α)N ⊨F
holds for all set-theoretic Π2 sentences.
(The notion of a Π2-model appears to have been introduced in [32].)
As far as the theories AUT-KPlr, AUT-KPlw and AUT-KPl are con-
cerned, L(g1(0))N is also their minimal Π2-model. The theories T with KPir ⊆
T ⊆KPi we are going to study next, though, will have their minimal Π2-model
L(α)N at an ordinal α ≤Γg
0 := min{ρ | gρ(0) = ρ}. The main cause for the
widely diverging Π2-models of such theories is to be found in the amount of induc-
tion principles they incorporate. In conjunction with stronger induction principles,
the pivotal principle of Σ collection gives rise to recursion principles which allow
one to prove the existence of ever larger admissible sets.
To analyze the gap between Π1
1-TR and Δ1
2-CA + (BI) we consider iterations
of principles stronger than Π1
1-comprehension.
Deﬁnition 6.2.
(i) Δ1
2-TR is the theory ACA augmented by the schema of
transﬁnite Δ1
2 recursion, (Δ1
2-TR),
∀R[WO(R) ∧∀X∀iy [B(X, i, y) ↔A(X, i, y)] →
∃Z∀iy [y ∈Zi ↔B(ZRi, i, y)]]
with B(U, a, b) ∈Π1
2 and A(U, a, b) ∈Σ1
2.
(ii) Σ1
2-TRDC (Π1
1-TRDC, respectively) is the theory ACA augmented by
the schema of transﬁnitely iterated Σ1
2 (Π1
1) dependent choices, (Σ1
2-TRDC)
(Π1
1-TRDC, respectively),
∀R[WO(R) ∧∀i∀X∃Y C(X, Y, i) →∃Z∀i C(ZRi, Zi, i)]
where C(U, V, a) ∈Σ1
2 (C(U, V, a) ∈Π1
1, respectively).
As it turns out, Π1
1 dependent choices are as strong as Σ1
2 dependent choices.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
395
Lemma 6.3. Π1
1-TRDC0 = Σ1
2-TRDC0.
Proof. we have to show “⊇”. Let C(U, V, a) be a formula ∃W A(U, V, W, a)
with A(U, V, S, a) Π1
1. Suppose that WO(R) and ∀i∀X∃Y C(X, Y, i). Then also
∀i∀X∃Y A({z | ⟨z, ¯0⟩∈X}, {z | ⟨z, ¯0⟩∈Y }, {z | ⟨z, ¯1⟩∈Y }, i)
and by (Π1
1-TRDC) there exists V such that
∀i A({z | ⟨z, ¯0⟩∈VRi}, {z | ⟨z, ¯0⟩∈Vi}, {z | ⟨z, ¯1⟩∈Vi}, i),
and hence
∀i C({z | ⟨z, ¯0⟩∈VRi}, {z | ⟨z, ¯0⟩∈Vi}, i).
Letting V ∗: {⟨i, z⟩| ⟨i, ⟨z, ¯0⟩⟩∈V }, (6.1) implies ∀i C(V ∗
Ri, V ∗
i , i).
Lemma 6.4. Δ1
2-CA0 ⊆Σ1
2-TRDC0.
Let F(a), ¬G(a) ∈Σ1
2. Suppose that ∀x [G(x) ↔F(x)]. Then
∀x∀X∃Y [(F(x) ∧Y = {¯0}) ∨(¬G(x) ∧Y = {¯1})].
Applying (Σ1
2-TRDC) to (6.1) and the well ordering ∅, there exists a set V such
that
∀x [(F(x) ∧Vx = {¯0}) ∨(¬G(x) ∧Vx = {¯1})].
With V ′ := {x | Vx = {¯0}} we obtain the desired ∀x [x ∈V ′ ↔F(x)].
Lemma 6.5. Δ1
2-TR0 ⊆Σ1
2-TRDC0.
Proof. Let B(U, a, b), ¬A(U, a, b) ∈Σ1
2. Moreover, suppose that WO(R) and
∀X∀iy [B(X, i, y) ↔A(X, i, y)].
By Lemma 6.4, (6.1) implies
∀i∀X∃Y ∀y [B(X, i, y) ↔y ∈Y ].
The formula ∀y [B(X, i, y) ↔y ∈Y ], in view of (6.1) and the fact that
(Σ1
2-AC)
⊆
Σ1
2-TRDC0, is equivalent to a Σ1
2 formula.
Hence, with
(Σ1
2-TRDC), from (6.1) we obtain
∃Z∀iy [B(ZRi, i, y) ↔y ∈Zi].
To facilitate the interpretation of Σ1
2-TRDC0 into set theory without choice, we
ﬁrst reduce this theory to a theory Π1
1-TRK0.

396
Michael Rathjen
Deﬁnition 6.6. Π1
1-TRK is the theory Δ1
2-CA + (Π1
1-TRK) where
(Π1
1-TRK)
∀R [WO(R) ∧∀i∀X∃!Y D(X, Y, i) →∃Z∀i D(ZRi, Zi, i)]
with D(U, V, a) ∈Π1
1.
Lemma 6.7. Π1
1-TRK0 = Π1
1-TRDC0.
For the proof of Lemma 6.7 we need to show that a certain result from descriptive
set theory is provable in Δ1
2-CA0.
Lemma 6.8 (Π1
1 uniformization). For every Π1
1 formula A[⃗S , V,⃗a ] there exists a
Π1
1 formula H[⃗S , V,⃗a ] such that provably in Π1
1-CA0 we have
(i) ∀Y (H[⃗S , V,⃗a ] →A[⃗S , V,⃗a ]);
(ii) ∃Y A[⃗S , Y,⃗a ] →∃!Y H[⃗S , Y,⃗a ].
Proof. [67, Lemma VI.2.1]
Proof of Lemma 6.7: “⊆” follows from Lemma 6.3 and 6.4.
For “⊇” let
A[⃗S , U, V, b,⃗a ] ∈Π1
1 and assume
WO(R) ∧∀i∀X∃Y A[⃗S , X, Y, i,⃗a ].
By Lemma 6.8 there is a Π1
1 formula H[⃗S , U, V, b,⃗a ] such that
∀i∀X∀Y (H[⃗S , X, Y, i,⃗a ] →A[⃗S , X, Y, i,⃗a ])
∀i∀X∃!Y H[⃗S , X, Y, i,⃗a ].
With the aid of (Π1
1-TRK), (6.1) yields
∃Z∀i H[⃗S , ZRi, Zi, i,⃗a ].
(6.1) and (6.1) imply ∃Z∀i A[⃗S , ZRi, Zi, i,⃗a ].
Lemma 6.9. Π1
1-TRK0 ⊆Δ1
2-TR0.
Proof.
Assume WO(R) ∧∀i∀X∃!Y C(X, Y, i) for some Π1
1 formula
C(U, V, a).
Let B(U, a, b) := ∃Y [C(U, Y, a) ∧b ∈Y ] and A(U, a, b) :=
∀Y [C(U, Y, a) →b ∈Y ]. By assumption,
∀X∀i∀y [B(X, i, y) ↔A(X, i, y)].

Investigations of Subsystems of Second Order Arithmetic and Set Theory
397
Using (Δ1
2-TR), (6.1) yields the existence of a set S such that for all i,
Si = {y | ∃Y [C(SRi, Y, i) ∧y ∈Y ]}.
As ∀i∃!Y C(SRi, Y, i) it follows that ∀i C(SRi, Si, i).
By Lemmata 6.3, 6.5, 6.7, and 6.9 we have the following:
Theorem 6.10. Δ1
2-TR0 = Σ1
2-TRDC0 = Π1
1-TRDC0 = Π1
1-TRK0.
Lemma 6.8 also yields the following.
Theorem 6.11. Σ1
2-AC0 = Δ1
2-CA0.
Another natural route to approach Δ1
2-CA + (BI) from below is to consider
restrictions of the bar induction schema (BI).
Deﬁnition 6.12. If F is a collection of L2-formulas, we let
(F-BI) := {∀X [WO(X) →TI(X, F)] | F(a) ∈F}.
It worthwhile noting that (Π1
2-BI) is already deducible in Δ1
2-CA.
Theorem 6.13. (Π1
2-BI) ⊆Σ1
2-DC0 ⊆Δ1
2-CA.
Proof. The second inclusion follows from Theorem 5.11(ii). To show the ﬁrst
inclusion we argue in Σ1
2-DC0. Suppose we have a counter-example to (Π1
2-BI).
Then there is a formula H(a) = ∀X A(X, a) with A(X, a) ∈Σ1
1, and there exists
a well-ordering ≺and a number k such that
PROG(≺, H) ∧¬H(k).
Let variables f, g, h, . . . range over functions from NN, where we identify f with
the set {⟨n, f(n)⟩| n ∈N}.
Since ¬H(k) holds, there exists a set S such that ¬A(S, k). Let f ′ be deﬁned
by f ′(0) = k and
f ′(x + 1) =
 0 if x ∈S
1 if x /∈S .
Letting N(h) := {x | h(x + 1) = 0} for h ∈NN, we have
f ′(0) = k ∧¬A(N(f′), k).
Since PROG(≺, h) we get ∀i [∃X ¬A(X, i) →∃Y ∃j(j ≺i ∧¬A(Y, j))],
whence
∀f∃g [¬A(N(f), f(0)) →g(0) ≺f(0) ∧¬A(N(g), g(0))].

398
Michael Rathjen
Applying (Σ1
2-DC) to (6.1), we obtain a function h such that h0 = f′ and
∀i [¬A(N(hi), hi(0)) →hi+1(0) ≺hi(0) ∧¬A(N(hi+1), hi+1(0))],
where hi denotes the function x →h(⟨i, x⟩). Using induction (for a Π1
1 formula),
(6.1) and the latter imply
∀i [¬A(N(hi), hi(0)) ∧hi+1(0) ≺hi(i)],
violating the assumption that ≺is a well-ordering.
The dual formula class, though, provides a strengthening.
Theorem 6.14. Σ1
2-TRDC0 ⊆Δ1
2-CA0 + (Σ1
2-BI).
Proof. According to Theorem 6.10 it sufﬁces to show (Π1
1-TRK) ⊆Δ1
2-CA0 +
(Σ1
2-BI). So suppose we have a Π1
1 formula C(U, V, a) such that
WO(R) ∧∀i∀X∃!Y C(X, Y, i).
Let F(U, a) := ∀j [(jRa ∨j ≡a) →C(URj, Uj, j)]. As WO(R) we get
F(U, a) ∧F(V, a) →∀j [(jRa ∨j ≡a) →Uj = Vj].
We show
∀i∃Z F(Z, i)
by induction on R. From ∀x [xRi →∃Z F(Z, x)] it follows by (6.1) and with the
help of (Δ1
2-CA) that there exists a set S such that
S = {⟨x, y⟩| xRi ∧∃Z (F(Z, x) ∧y ∈Zx)}
= {⟨x, y⟩| xRi ∧∀Z [F(Z, x) →y ∈Zx)}.
Moreover, owing to (6.1), there exists a set V such that C(SRi, V, i).
Letting S∗:= S ∪{⟨i, y⟩| y ∈V } we have F(S∗, i). Thus (6.1) follows by
(Σ1
2-BI).
In view of (6.1) and (6.1), we can apply (Δ1
2-CA) to show that
U := {⟨i, y⟩| ∃Z [F(Z, i) ∧y ∈Zi)}
is set.
Moreover, by (6.1) and (6.1), we also have ∀i C(URi, Ui, i), showing
(Π1
1-TRK).
Corollary 6.15. (Π1
2-BI) ⊆Δ1
2-CA0 + (Σ1
2-BI).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
399
Proof. This follows from Theorems 6.13 and 6.14.
Remark 6.16. We shall later see that Σ1
2-TRDC0 and Δ1
2-CA0 + (Σ1
2-BI) have
the same proof-theoretic ordinal. Using standard arguments this implies that both
theories prove the same Π1
1 sentences. Indeed, this result can be improved. Both
theories prove the same Π1
3 sentences, but this stronger conservativity result cannot
be simply gleaned from the proof-theoretic ordinal. One has to scrutinize the whole
series of reductions to arrive at it.
7 Set theories with recursion schemata
As in the case of L2-theories of iterated Π1
1-comprehension, one can also single
out a set-theoretic counterpart to (Σ1
2-TRDC). Ignoring the latter’s choice as-
pects, Σ-recursion lends itself as a pendant to (Σ1
2-TRDC). In order to inter-
pret Σ1
2-TRDC0 in KPir + (Σ-REC), we need a “quantiﬁer theorem” which
reduces Σ1
2 formulae of L2 to set-theoretic Σ1 formulas, thereby reducing the num-
ber of unbounded set quantiﬁers by one. In the case of ZF this is a standard result.
(cf. [12, CH.5,7.14]).
Theorem 7.1. To any Σ1
2 L2-formula B[⃗a, ⃗U ] one can assign a Σ1 formula
Bσ[⃗a,⃗b ] of L∗such that
KPlr ⊢⃗a ∈N ∧b ⊆N →(B[⃗a,⃗b ]∗↔Bσ[⃗a,⃗b ]).
Proof. The crucial step in the well known proof (usually carried out in ZF)
consists in realizing that via the Π1
1 normal form (the equivalence (4.1) in the proof
of Lemma 4.5), every Π1
1 formula is equivalent to a Σ1 formula exploiting axiom
Beta, and consequently every Π1
1 formula is Δ1. Since axiom Beta is provable
in KPlr by Theorem 5.6, the desired result follows. For more details see [32,
Theorem 7.1].
Theorem 7.2. Δ1
2-CA0 ⊆KPir.
Immediate by the latter Theorem, using Δ separation (Theorem 2.22) in KPir.
Lemma 7.3 (Embedding Lemma for Π1
1-TRK0). Π1
1-TRK0
⊆
KPir +
(Σ-REC).
Proof. By Theorem 7.1 it sufﬁces to show (Π1
1-TRK) ⊆KPir + (Σ-REC).
Let A[a, U, V, ⃗d, ⃗S ] ∈Σ1
2. Let j1, . . . , jk ∈N, s1, . . . , sn ⊆N and, letting
B(a, b, c) := (A[a, b, c,⃗j,⃗s ])∗, assume that
Wo(r, N) ∧∀i ∈N ∀x ⊆N ∃!y [y ⊆N ∧B(i, x, y)].

400
Michael Rathjen
We have to show that
∃z ⊆N × N (∀i ∈N) B(i, (z)ri, (z)i)
(with (z)ri and (z)i being deﬁned as in Lemma 5.8). By Theorem 7.1 there exists
a Σ1 formula Bσ(a, b, c) such that
∀i ∈N ∀x ⊆N ∀y ⊆N [B(i, x, y) ↔Bσ(i, x, y)].
Letting S := {i ∈N | Fld(i, r)}, by Theorem 5.6 there exists a function h such
that h is collapsing for r, i.e. Collab(S, r, h). Whence h is a bijection from S onto
αh := rng(h) satisfying ∀ij [⟨i, j⟩∈r →h(i) < h(j)]. Let
F(β, a, b) := F0(β, a, b) ∨F1(β, a, b),
F0(β, a, b) := (αh ≤β ∨

rng(a) ̸⊆N) ∧b = ∅,
F1(β, a, b) := β < αh ∧

rng(a) ⊆N ∧b ⊆N ∧Bσ(h−1(β),

rng(a), b).
In KPlr, F(β, a, b) is equivalent to a Σ formula. In view of (7.1) and (7.1) we
have ∀β∀x∃!y F(β, x, y), whence, using (Σ-REC), there exists a function f, such
that
dom(f) = αh ∧(∀β < αh) F(β, f ↾β, f(β))).
From (7.1) we get (∀β < αh) [ rng(f
↾β) ⊆N ∧f(β) ⊆N by
(Δ0-FOUND). Whence from (7.1) we can conclude that for all i ∈S,

rng(f ↾h(i)) ⊆N ∧f(h(i)) ⊆N ∧Bσ(i,

rng(f ↾h(i)), f(h(i))).
With X := {⟨i, j⟩| i ∈S ∧j ∈f(h(i))}, the latter and (7.1) yield
(∀i ∈S) B(i, (X)ri, (X)i) ∧X ⊆N × N.
Moreover, (7.1) implies (∀i ∈N \ S) ∃!y [y ⊆N ∧B(i, ∅, y)], so that with the
help of Σ replacement there exists a function g satisfying
dom(g) = N \ S ∧(∀i ∈N \ S) [g(i) ⊆N ∧B(i, ∅, g(i))].
Letting Y := X ∪{⟨i, j⟩| i ∈N \ S ∧j ∈g(i)}, (7.1) and (7.1) entail that
Y ⊆N × N ∧(∀i ∈N) B(i, (Y )ri, (Y )i),
conﬁrming (7.1).
From Theorem 6.10 and Lemma 7.3 we get the following.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
401
Theorem 7.4. Σ1
2-TRDC0 = Δ1
2-TR0 ⊆KPir + (Σ-REC).
The theories Σ1
2-TRDC0 and Σ1
2-TRDC will later be interpreted in a semi-
formal system of ramiﬁed set theory. This, however, will only provide a partial
interpretation for Σ1 formulae with free variables. To bring about this interpretation
it is technically advisable to reduce (Σ-REC) to a simpler schema of Ad-valued
recursion on ordinals.
Deﬁnition 7.5. For F(a, b, c) a Δ0 formula, we denote by CF (α, f) the formula
Ord(α) ∧Fun(f) ∧dom(f) = α ∧
(∀β < α) [Ad(f(β)) ∧F(β, f ↾β, f(β)) ∧
(∀x ∈f(β))(Ad(x) →¬F(β, f ↾β, x))].
Note that CF (α, f) is also Δ0. By (Ad-REC) we denote the schema
∀β∀x∃y[Ad(y) ∧F(β, x, y)] →∀α∃f CF (α, f)
where F(a, b, c) is Δ0.
As in Lemma 5.2 one proves
Lemma 7.6. KPlr ⊢CF (α, g) ∧CF (α, g) →f = g.
The “trick” of replacing the premiss ∀β∀x∃!y F(β, x, y) by
∀β∀x∃y[Ad(y) ∧F(β, x, y)]
allows one to relinquish one’s hold on the uniqueness requirement for y since ad-
missible sets are well-ordered on the basis of KPlr.
Theorem 7.7. KPir + (Ad-REC) = KPir + (Σ-REC).
Proof. For a proof see [43, Satz 5.7]. A proof will also be supplied in the sequel
to this paper.
8 Systems with Bar rules and other induction principles
An alternative to restricting the schema (BI) to speciﬁc syntactic complexity
classes of formulae (as in (F-BI)) consists in directing the attention to the well-
ordering over which transﬁnite induction is allowed in that one requires them to be
provably well-ordered.

402
Michael Rathjen
Deﬁnition 8.1.
(i) The Bar rule, BR, is the rule of inference
WO(≺)
TI(≺, F)
with ≺being a primitive recursive relation and F(a) any formula of L2.
(ii) BR(impl-Σ1
2) is the rule
∃!X (WO(X) ∧G[X])
∀X (WO(X) ∧G[X] →TI(X, H))
where G[U] is a Σ1
2 formula (without additional parameters) and H(a) is an
arbitrary L2 formula.
(iii) BI(impl-Σ1
2) denotes the schema
∃!X (WO(X) ∧G[X]) →∀X (WO(X) ∧G[X] →TI(X, H))
where G[U] is a Σ1
2 formula (without additional parameters) and H(a) is an
arbitrary L2 formula.
The Quantiﬁer Theorem 7.1 and Axiom Beta suggest set-theoretic equivalences
to the foregoing induction principles.
Deﬁnition 8.2.
(i) FOUNDR(impl-Σ(M)) is the rule of inference
∃!x (x ∈M ∧F[x]M)
∀x[x ∈M ∧F[x]M ∧∀y(∀z ∈y H(z) →H(y)) →(∀y ∈x) H(y)]
with F[a] a Σ formula and H(a) any formula of L∗.
(ii) FOUNDR(impl-Σ) is the rule of inference
∃!x F[x]
∀x[F[x] ∧∀y(∀z ∈y H(z) →H(y)) →(∀y ∈x) H(y)]
with F[a] a Σ formula and H(a) any formula of L∗.
(iii) FOUND(impl-Σ) denotes the schema
∃!x F[x] →∀x[F[x] ∧∀y(∀z ∈y H(z) →H(y)) →(∀y ∈x) H(y)]
where F[a] is a Σ formula and H(a) is any formula of L∗.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
403
Remark 8.3. The rule BR(impl-Σ1
2) is, on the basis of Δ1
2-CA, much stronger
than the rule BR whereas BR(impl-Σ1
2) is still much weaker than (BI). The differ-
ence in strength between (BI) and BR(impl-Σ1
2) is of course owed to the fact that
the ﬁrst is a rule while the second is a schema. But one can say something more il-
luminative about it. As it turns out, BR(impl-Σ1
2) and BI(impl-Σ1
2) are of the same
strength (on the basis of Δ1
2-CA), in actuality the theories Δ1
2-CA+BR(impl-Σ1
2)
and Δ1
2-CA + BI(impl-Σ1
2) prove the same Π1
1 statements. Thus the main differ-
ence between BR(impl-Σ1
2) and (BI) is to be found in the premiss of BI(impl-Σ1
2)
requiring the well-ordering to be describable via a Σ1
2 formula without parameters.
Analogous remarks apply to the corresponding set-theoretic principles. The theme
is explored in more detail in [46].
The next lemma relates (in a weak sense) the L2 versions of Deﬁnition 8.1 to
their set-theoretic counterparts.
Lemma 8.4.
(i) Δ1
2-CA + BR(impl-Σ1
2) ⊆KPlw + FOUNDR(impl-Σ) =
KPir + FOUNDR(impl-Σ).
(ii) Σ1
2-TRDC + BR ⊆KPiw + (Σ-REC) + FOUNDR(impl-Σ(M)).
(iii) Σ1
2-TRDC + BR(impl-Σ1
2) ⊆KPiw + (Σ-REC) + FOUNDR(impl-Σ).
Proof. (i) The ﬁrst identity is obvious since FOUNDR(impl-Σ) implies all
instances of (IND)∗. Let T := Δ1
2-CA + BR(impl-Σ1
2) and T ′ := KPiw +
FOUNDR(impl-Σ). We want to show
T ⊢A ⇒T ′ ⊢A∗
by induction on the length of the derivation in T. Owing to Theorem 7.2 it sufﬁces
to assume that A is the consequence of an inference BR(impl-Σ1
2). Then A is of
the form
∀X[WO(X) ∧F[X] →TI(X, H)]
with F[U] ∈Σ1
2. Moreover, inductively we have
T ′ ⊢(∃!X(WO(X) ∧F[X]))∗.
We now argue in T ′. By Theorem 7.1 there exists a Σ formula F ′[a] such that
∀x ⊆N (F ′[x] ↔Wo(N, x) ∧F[x]∗).
Let r be the unique well-ordering on N which satisﬁes F ′[r]. Via Axiom Beta there
exist a unique ordinal α and order isomorphism between r and α. As a result, α

404
Michael Rathjen
has an implicit Σ deﬁnition, so that with the help of FOUNDR(impl-Σ) we have
transﬁnite induction on α for arbitrary formulae. Via the order isomorphism f we
then obtain A∗.
The proof of (iii) is analogous to (i), using Lemma 7.3.
(ii) is also proved similarly. The only extra consideration one has to employ is
the following. For a primitive recursive well-ordering ≺we have
r := {⟨i, j⟩| i ≺j} ∈M
and therefore the function f which is collapsing for r is an element of M, thus r is
order isomorphic to an ordinal in M, which possesses an implicit Σ(M) deﬁnition.
Below we shall list some results whose proofs are too long to be incorporated in
the ﬁrst part of this paper. They will be supplied in the second part.
Theorem 8.5.
(i) AUT-KPlr, KPiw + FOUND(impl-Σ), and KPiw +
FOUNDR(impl-Σ) prove the same Σ1 sentences.
(ii) KPiw + (Σ-REC) + FOUND(impl-Σ) and KPiw + (Σ-REC) +
FOUNDR(impl-Σ) prove the same Σ1 sentences.
Proof. See [43], Satz 6.5. The proof (which is long) will be in incorporated in
the second part of this paper.
The following two results show that the strength of (Σ-FOUND) is already en-
capsulated in (Σ-REC).
Theorem 8.6. KPir + (Σ-FOUND) and KPir + (Σ-REC) prove the same Π2
sentences.
Proof. See [43], Satz 7.1. The proof (which is long) will be in incorporated in
the second part of this paper.
Theorem 8.7. KPiw + (Σ-FOUND) and KPiw + (Σ-REC) prove the same Π2
sentences.
Proof. See [43], Satz 7.20. The proof will be in the second part of this paper.
The next result shows
Theorem 8.8. AUT-KPlr + KPir and AUT-KPlr prove the same Π2 sen-
tences.
Proof. See [43], Satz 7.20. The proof will be in the second part of this paper.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
405
Theorem 8.9. For every Π2 sentence F,
KPiw + FOUND(impl-Σ) ⊢F ⇒AUT-KPlr ⊢F.
Proof. See [43], Satz 7.22. The proof will be in the second part of this paper.
Theorem 8.10. For every Σ sentence G,
AUT-KPlr ⊢G ⇒KPiw + FOUND(impl-Σ) ⊢G.
Proof. See [43], Satz 7.23. The proof will be in the second part of this paper.

406
Michael Rathjen
II. WELL-ORDERING PROOFS
An ordinal α is said to be provable in a theory T (whose language encompasses
L2) if there exists a recursive well-ordering ≺whose order-type is α such that
T ⊢WO(≺). In this chapter we try to give lower bounds for the provable ordinals
of the various theories introduced in chapter I. That the results are indeed optimal
will be shown in chapter III which will form the main chunk of the sequel to the
present paper.
9 The functions ϕα and Φα
α, β, γ, δ, ξ, ζ, ρ will always denote ordinals. λ will be reserved for limit ordinals.
Let α →ωα be the ordinal function which enumerates the additive principal ordi-
nals, i.e. the ordinals α > 0 satisfying (∀η < α) η + α = α. This function is also
a normal function since it is strictly increasing α < β ⇒ωα < ωβ and satisﬁes
ωλ = sup{ωη | η < λ}.
Deﬁnition 9.1. Inductive deﬁnition of the classes Cr(α):
1. Cr(0 is the class of additive principal ordinals.
2. ϕα is the function that enumerates Cr(α), i.e. ϕα(ξ) is the ξth member of
Cr(α).
3. Cr(α + 1) = {ρ | ϕα(ρ) = ρ}.
4. Cr(λ) = {Cr(ξ) | ξ < α}.
Deﬁnition 9.2. Inductive deﬁnition of the classes Kr(α):
1. Kr(0) is the class of uncountable cardinals.
2. Φα is the function that enumerates Kr(α).
3. Kr(α + 1) = {ρ | Φα(ρ) = ρ}.
4. Kr(λ) = {Kr(ξ) | ξ < α}.
On account of their deﬁnitions, the classes Cr(α) and Kr(α) are unbounded and
closed in the ON (:=the class of ordinals) and thus every function ϕα and Φα is a
normal function f, i.e. strictly increasing and continuous:
f(λ) = sup{f(ξ) | ξ < λ}

Investigations of Subsystems of Second Order Arithmetic and Set Theory
407
for limits λ.
In what follows we write ϕαβ for ϕα(β) and Φαβ for Φα(β).
The following three lemmas are proved for ϕ in [63, section 13], but the same
proof works for Φ as well.
Lemma 9.3. Let f be one of the functions ϕ or Φ. Suppose that α = fγδ and
β = fξη.
(i) α = β holds if and only if one of the following three statements holds:
1. γ < ξ and δ = fξη.
2. γ = ξ and δ = η.
3. ξ < γ and fγδ = η.
(ii) α < β holds if and only if one of the following three statements holds:
1. γ < ξ and δ < fξη.
2. γ = ξ and δ < η.
3. ξ < γ and fγδ < η.
Lemma 9.4.
(i) ϕα0 < ϕβ0 ⇔Φα0 < Φβ0 ⇔α < β.
(ii) α, β ≤ϕαβ and α, β ≤Φαβ.
Lemma 9.5. For every ρ ∈Cr(0) (ρ ∈Kr(0)) there exist unique ordinals β, γ
such that γ < ρ and ρ = ϕβγ (ρ = Φβγ).
Deﬁnition 9.6.
(i) α =nf ϕβγ
:⇔
α = ϕβγ and β, γ < α.
(ii) α =nf Φβγ
:⇔
α = Φβγ and β, γ < α.
(iii) α =nf α1 + . . . + αn
:⇔
α = α1 + . . . + αn, α1, . . . , αn ∈Cr(0) and
α > α1 ≥. . . ≥αn.
The normal forms of Deﬁnition 9.6 are unique representations of ordinals owing
to Lemma 9.3.
Deﬁnition 9.7.
(i) SC := {α | ϕα0 = α}.
(ii) ΓΦ
0 := min{α | Φα0 = α}.
Lemma 9.8. ΓΦ
0 = sup{ρn | n < ω} where ρ0 = Φ00 and ρn+1 = Φρn0.

408
Michael Rathjen
Proof. As in [63, Theorem 14.16].
By R we shall denote the class of uncountable regular cardinals. α →Ωα is
the mapping which enumerates the class R0 := Kr(0) ∪{0}. In more traditional
notation we have Ωα = ℵα for all α > 0. The regular uncountable cardinals < ΓΦ
0
can be characterized as follows:
Theorem 9.9. If κ ∈R and κ < ΓΦ
0 then there exists a unique ξ such that κ =
Ωξ+1.
Proof. Let κ ∈R and κ < ΓΦ
0 . By Lemma 9.4, κ ≤Φκ0 < Φ(κ + 1)0. Hence
there is largest ordinal β such that κ ∈Kr(β). Thus κ = Φβδ for some δ < κ. If
δ were a limit we would have κ = sup{Φβξ | ξ < δ} and κ would be singular. As
a result, κ = Φβ(η + 1) for some η or κ = Φβ0.
If β = κ = Φβ0 one could show, by induction on n, utilizing Lemma 9.3(ii),
that ρn < κ, contradicting κ < ΓΦ
0 . Hence β < κ. Now one could show the
coﬁnality of κ to be the same as that of β if κ = Φβ0 and β were a limit, making κ
singular. Likewise, if β = ζ +1 and κ = Φβ0 one could show that the coﬁnality of
κ is ω, and similarly if κ = Φβ(η + 1) and β = ζ + 1 the coﬁnality of κ would be
ω, too. As a result, since κ is regular > ω we must have β = 0. Therefore κ = Ω1
or κ = Ωξ+1, where ξ = η + 1 + 1 if η < ω and ξ = η otherwise.
In what follows, the properties of the functions ϕ and Φ exhibited in this section
will be used frequently and mostly tacitly.
10 The set of ordinals, OT(Φ)
This section introduces an ordinal representation system sufﬁcient unto the task of
expressing the proof-theoretic ordinals of all the theories considered so far. There
will be no proofs in this section since they would be similar (with minor modiﬁca-
tions) to those in [9] or [53]. ZFC will sufﬁce as a background theory for showing
the existence of the various functions.
We use the following conventions: (α, β), (α, β], [α, β), and [α, β] denote the
intervals of ordinals between α and β in the obvious sense. For a set of ordinals A
we use the abbreviations
A < α := (∀η ∈A) η < α
A ≤α := (∀η ∈A) η ≤α.
Variables ν, μ, τ are understood to range over elements from R0.
Deﬁnition 10.1. By recursion on α we deﬁne the sets of ordinals ordinals Cν(α)
and the ordinals ψνα. The sets Cν(α) themselves are deﬁned inductively by the
following clauses:

Investigations of Subsystems of Second Order Arithmetic and Set Theory
409
(Cν1) [0, ν] ⊆Cν(α).
(Cν2) ξ, η ∈Cν(α) ⇒ξ + η ∈Cν(α).
(Cν3) ξ, η ∈Cν(α) ⇒ϕξη ∈Cν(α).
(Cν4) ξ, η ∈Cν(α) ⇒Φξη ∈Cν(α).
(Cν5) ξ < α and ξ, μ ∈Cν(α) ⇒ψμξ ∈Cν(α).
(Cν6) ψνα = min{η | η /∈Cν(α)}.
Deﬁnition 10.2.
(i) α+ := min{κ ∈R | α < κ}.
(ii) S(α) := min{μ ∈R0 | α < μ+}.
Proposition 10.3.
(i) α ≤β ⇒Cν(α) ⊆Cν(β).
(ii) ψνα ∈(ν, ν+).
(iii) ν < ΓΦ
0 ⇒Cν(α) ⊆ΓΦ
0 .
(iv) ψνα ∈SC.
(v) ψνα /∈R0.
(vi) ψνα = Cν(α) ∩ν+.
Proposition 10.4. Let α ∈Cν(α) and β ∈Cν(β).
(i) ψνα = ψμβ if and only if ν = μ and α = β.
(i) ψνα < ψμβ if and only if ν < μ or ν = μ ∧α < β.
Deﬁnition 10.5. α =nf ψνβ :⇔(α = ψνβ ∧β ∈Cν(β).
Deﬁnition 10.6. The set of ordinals OT(Φ) and the complexity Gα < ω for α ∈
OT(Φ) are deﬁned inductively by the following clauses:
(T1) 0 ∈OT(Φ) and G(0) = 0.
(T2) α =nf α1 + . . . + αn ∧α1, . . . , αn ∈OT(Φ) ⇒
α ∈OT(Φ) ∧Gα = max{Gα1, . . . , Gαn} + 1.
(T3) α =nf ϕβγ ∧β, γ ∈OT(Φ) ⇒α ∈OT(Φ) ∧Gα = max{Gβ, Gγ}+1.
(T4) α =nf Φβγ ∧β, γ ∈OT(Φ) ⇒α ∈OT(Φ) ∧Gα = max{Gβ, Gγ}+1.

410
Michael Rathjen
(T5) α =nf ψνγ ∧ν, γ ∈OT(Φ) ⇒α ∈OT(Φ) ∧Gα = max{Gν, Gγ}+1.
It follows from Lemma 9.5 and Proposition 10.3(iv),(v) that every ordinal α ∈
OT(Φ) enters OT(Φ) owing to exactly one of the rules (T1)-(T5). As a result the
inductive deﬁnition of OT(Φ) is deterministic, thus Gα is well-deﬁned.
Theorem 10.7. OT(Φ) = C0(ΓΦ
0 ).
Every element of OT(Φ) can be uniquely named via a term built up from the
“symbols” 0, +, ϕ, Φ, ψ. At this point we have not yet established that thereby
OT(Φ) with its ordering gives rise to a decidable well ordering.
This can be
achieved by showing that questions such as whether γ < Φβγ in (T4) and whether
β ∈Cν(β) in (T5) can be decided. To this end we exhibit several lemmata which
will entail the decidability of (OT(Φ), <).
Deﬁnition 10.8. The set of ordinals Kνα for α ∈OT(Φ) and ν ∈R0 are deﬁned
inductively by the following clauses:
(Kν1) Kν0 = ∅.
(Kν2) Kνα = {Kναj | j = 1, . . . , n} if α =nf α1 + . . . + αn.
(Kν3) Kνα = Kνβ ∪Kνγ if α =nf ϕβγ or α =nf Φβγ.
(Kν4) Let α =nf ψμβ.
Kνα =
∅
if
μ < ν
{β} ∪Kνβ ∪Kνμ
if
ν ≤μ.
Lemma 10.9. For α ∈OT(Φ) we have α ∈Cν(β) ⇔Kνα < β.
Deﬁnition 10.10. Sets e(α) and E(α) are deﬁned inductively as follows:
1. e(0) = E(0) = ∅.
2. e(0) = E(0) = ∅if α =nf α1 + . . . + αn.
3. e(α) = {β} and E(α) = ∅if α =nf ϕβγ.
4. e(α) = {α} and E(α) = {β} if α =nf Φβγ.
5. e(α) = {α} and E(α) = ∅if α =nf ψνβ.
Lemma 10.11. Let α, β, γ ∈OT(Φ).
(i) If α = ϕβγ then α =nf ϕβγ ⇔[e(γ) ≤β ∧(β /∈SC ∨γ > 0)].

Investigations of Subsystems of Second Order Arithmetic and Set Theory
411
(ii) If α = Φβγ then α =nf Φβγ ⇔E(γ) ≤β.
Proof. We only remark that it is essential for (ii) to hold that β < Φβ0 holds for
all β ∈OT(Φ) by Theorem 10.7.
Deﬁnition 10.12. A coding function
⌜⌝: OT(Φ) −→N
is deﬁned as follows: 1. ⌜0⌝= (0). 2. ⌜α⌝= (1, ⌜α1⌝, . . . , ⌜αn⌝) if α =nf
α1 + . . . + αn. 3. ⌜α⌝= (2, ⌜β⌝, ⌜γ⌝) if α =nf ϕβγ. 4. ⌜α⌝= (3, ⌜β⌝, ⌜γ⌝) if
α =nf Φβγ. 5. ⌜α⌝= (4, ⌜ν⌝, ⌜γ⌝) if α =nf ψνγ. Here (. . .) stands for some
ﬁxed primitive recursive coding of tuples of natural numbers.
Let
⌜OT(Φ)⌝:= {⌜α⌝| α ∈OT(Φ)}
and deﬁne an ordering ≺on N via
n ≺m :⇔∃α, β ∈OT(Φ) (α < β ∧n = ⌜α⌝∧m = ⌜β⌝).
If one now combines Lemma 9.3, Proposition 10.4, Lemma 10.9 and Lemma
10.11 one sees that ⌜OT(Φ)⌝is a primitive recursive set equipped with a primitive
recursive ordering ≺such that (OT(Φ), <) and ⌜OT(Φ)⌝, ≺) are isomorphic.
In what follows we shall no longer distinguish between (OT(Φ), <) and its arith-
metization ⌜OT(Φ)⌝, ≺). Via this identiﬁcation, SC becomes a primitive recursive
predicate and the functions S, K, G, e, E, ξ →ωξ, α →Ωα, ϕ, Φ, ψ can be viewed
as primitive recursive functions acting on ⌜OT(Φ)⌝. In particular, all these rela-
tions and functions are deﬁnable in the language of arithmetic, L1.
Convention 10.13. Lower case Greek letters α, β, γ, δ, ξ, η, σ, ζ, ϑ will range over
arbitrary elements of OT(Φ) for the remainder of this paper while ν, μ, τ will be
reserved for elements of OT(Φ) ∩R0. Quantiﬁers ∀α, ∃α, . . . will exclusively
range over elements of OT(Φ), too.
11 Distinguished sets
By a well-ordering proof in a given theory T we mean a proof formalizable in
T which shows that a certain ordinal representation system (or a subset of it) is
well-ordered. The notion of a distinguished set (of ordinals) (in German: ausge-
zeichnete Menge) will be central to carrying out well ordering proofs in the various
subtheories of second order arithmetic introduced in earlier sections. A theory of

412
Michael Rathjen
distinguished sets developed for this purpose emerged in the works of Buchholz
and Pohlers [4,6,7].
As a base theory in which all the results of this section can be proved one can
take Π1
1-CA0. It also worthwhile to point out that all the proofs work when the
underlying logic is changed to intuitionistic logic. The principle of excluded third
gets applied only to decidable properties (actually primitive recursive predicates).
Thus all the proofs can be formalized in Π1
1-CAi
0, the intuitionistic version of
Π1
1-CA0.
We introduce another operation on OT(Φ) which will play an important role in
the remainder of this paper.
Deﬁnition 11.1. The strongly critical subterms of level μ of α are deﬁned induc-
tively as follows:
1. SCμ(0) = ∅.
2. SCμ(α) = {α} if α ∈SC ∩μ+.
3. SCμ(α) = {SCμ(αi) | i = 1, . . . , n} if if α =nf α1 + . . . + αn.
4. SCμ(α) = SCμ(β) ∪SCμ(γ) if α =nf ϕβγ.
5. SCμ(α) = SCμ(β) ∪SCμ(γ) if α =nf Φβγ and μ+ ≤α.
6. SCμ(α) = SCμ(β) ∪SCμ(γ) if α =nf ψνγ and μ+ ≤α.
Deﬁnition 11.2. Let U ⊆OT(Φ) and F(a) be an L2-formula.
(i) U ∩α := {η ∈U | η < α}.
(ii) U ∩α ⊆F :⇔(∀η ∈U ∩α) F(η).
(iii) Prg(U, F) :⇔∀η ∈U [U ∩η ⊆F →F(η)].
(iv) W[U] := {η ∈U | ∀Y [Prg(U, Y ) →U ∩η ⊆Y ]}.
(v) MU
μ := {η < μ+ | (∀η ∈U ∩μ)SCν(η) ⊆U}.
(vi) WU
μ := W[MU
μ ].
Remark 11.3.
(i) If <U denotes the restriction of < to U and FU(a) is the for-
mula a ∈U →F(a) then Prg(U, F) ↔PROG(<U, FU) holds with PROG
as deﬁned in Deﬁnition 3.1.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
413
(ii) MU
μ is always a set by arithmetical comprehension. To show that W[U] and
WU
μ are sets one can use Π1
1 comprehension. W[U] and WU
μ can also be
shown to be sets in any theory which proves that the accessible part of an
ordering R on N (where R is assumed to be a set) is a set. A case in point
is constructive Zermelo-Fraenkel set theory with the regular extension axiom,
CZF+REA (see [1,2]). Actually the fragment CZFr+REA of CZF+REA
sufﬁces. Here CZFr denotes CZF with ∈-induction restricted to bounded
formulae. To place this theory into perspective, CZFr + REA and Π1
1-CA0
are of the same strength.
The next Lemma lists basic properties of W[U], MU
μ and WU
μ .
Lemma 11.4.
(i) Prg(U, S) →W[U] ⊆S.
(ii) Prg(U, W[U]).
(iii) U ⊆V ∧Prg(U, S) →Prg(V, {η | η ∈U →η ∈S}).
(iv) Prg(W[U], S) →W[U] ⊆S.
(v) W[W[U]] = W[U].
(vi) W[U ∩α] ⊆W[U].
(vii) W[U ∩α] ⊆W[U].
(viii) α ∈WU
μ ↔α ∈MU
μ ∧MU
μ ∩α ⊆WU
μ .
Proof. (i) and (vii) are immediate by going back to the deﬁnitions.
(ii) Let α ∈U and U ∩α ⊆W[U]. By (i) we have U ∩α ⊆S for every S
satisfying Prg(U, S). Thence α ∈W[U].
(iii) Assume that U ⊆V and Prg(U, S) hold and also that α ∈V and
V ∩α ⊆{η | η ∈U →η ∈S}.
Then U ∩α = U ∩V ∩α ⊆S, thus α ∈U →α ∈S, i.e.
α ∈{η | η ∈U →η ∈S}.
(iv) Suppose Prg(W[U], S). (iii) implies Prg(U, {η | η ∈W[U] →η ∈S}).
Therefore, by (i), we also have W[U] ⊆{η | η ∈W[U] →η ∈S}, and hence
W[U] ⊆S.
(v) W[W[U]]
⊆
W[U] holds by deﬁnition.
Using (ii) we have
Prg(W[U], W[W[U]]), hence, by (iv), W[U] ⊆W[W[U]].

414
Michael Rathjen
(vi) From
η ∈U ∩α ∧∀Y (Prg(U ∩α, Y ) →U ∩α ∩η ⊆Y )
we deduce that ∀Y (Prg(U, Y ) →U ∩η ⊆Y ), thence η ∈W[U].
(viii) By (ii) we have Prg(MU
μ , WU
μ ). WU
μ is also a set. Thus (viii) follows.
Deﬁnition 11.5.
(i) A set U ⊆OT(Φ) is said to be distinguished if (D1) and
(D2) are satisﬁed:
(D1) (∀α ∈U) Sα ∈U.
(D2) (∀μ ∈U) U ∩μ+ = WU
μ .
(ii) We shall use the abbreviation Ds(U) to convey that U is a distinguished set.
Variables P and Q will always refer to distinguished sets.
(iii) W := {η | ∃X [Ds(X) ∧η ∈X]}.
Note that W cannot be shown to be a set in our background theory Π1
1-CA0
(nor actually in any of the other theories we investigate in this paper).
Lemma 11.6. Recall that the letters Q and P are reserved for distinguished sets.
(i) Q ⊆W[Q] and hence Q = W[Q]
(ii) Prg(Q, V ) →Q ⊆V .
Proof. (i) Let α ∈Q. Then Sα ∈Q by (D1) and hence Q ∩α+ = WQ
Sα. So by
Lemma 11.4(v),(vi) we arrive at
α ∈Q ∩α+ = WQ
Sα = W[WQ
Sα] = W[Q ∩α+] ⊆W[Q].
(ii) is an immediate consequence of (i) and Lemma 11.4(i).
Owing to Lemma 11.6(ii) we have transﬁnite induction over <Q := < ∩(Q×Q)
for arbitrary sets. Thus if we want to show that Q ⊆V holds for a set V it sufﬁces
to prove that
∀β(β ∈Q ∧Q ∩β ⊆V →β ∈V ).
Speciﬁcally we have WO(<Q).
Lemma 11.7.
(i) ν ≤μ ∧β ∈SCμ(α) →SCν(β) ⊆SCν(α).
(ii) α ∈Q ∧μ ∈Q →SCμ(α) ⊆Q.
(iii) μ ∈MQ
μ →(∀ν ∈Q)SCμ(α) ⊆Q.
(iv) μ ∈MQ
μ ∧μ ≤Q →μ ∈Q.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
415
Proof. (i) follows by induction on Gα
(ii) 1. Suppose μ < Sα. Then (D1) and (D2) imply that α ∈Q ∩α+ = WQ
Sα ⊆
MQ
Sα. As μ ∈Q ∩Sα we see that SCμ(α) ⊆Q by deﬁnition of MQ
Sα.
2. Suppose μ ≥Sα. From (D2) it then follows that α ∈WQ
μ ⊆MQ
μ . For
ν ∈Q ∩μ we thus have SCν(α) ⊆Q, and from (i) we conclude that (∀β ∈
SCμ(α)) SCν(β) ⊆Q. Therefore SCμ(α) ⊆{α}∪MQ
μ ∩α. By Lemma 11.4(viii)
we get SCμ(α) ⊆WQ
μ ⊆Q as α ∈WQ
μ .
(iii) will be proved by transﬁnite induction on Q (i.e. <Q).
1. If ν ∈Q ∩μ+ then the desired assertion follows in the case ν < μ from the
deﬁnition of MQ
μ and in the case ν = μ from (ii).
2. If ν ∈Q and μ < ν then by induction hypothesis we have
(∀τ ∈Q ∩ν)SCτ(μ) ⊆Q
and consequently μ ∈MQ
ν . From ν ∈Q ∩ν+ = WQ
ν we obtain by Lemma
11.4(viii) that MQ
ν ∩ν ⊆WQ
ν , whence μ ∈WQ
ν . Since SCν(μ) ⊆{μ} we arrive
at the desired assertion.
(iv) follows directly from (iii).
Lemma 11.8. Q ∩μ+ ⊆WQ
μ .
Proof. Let α ∈Q∩μ+. Then α ∈WQ
Sα and so by Lemma 11.4(viii), MQ
Sα∩α ⊆
WQ
Sα. In view of Lemma 11.4(vi) it sufﬁces to show that α ∈W[MQ
μ ∩α+]. Lemma
11.7(ii) yields α ∈MQ
μ ∩α+. Using Lemma 11.4(iii), Prg(MQ
μ ∩α+, U) implies
Prg(MQ
Sα, {η | η ∈MQ
μ ∩α+ →η ∈U}),
and further, by Lemma 11.4(i),
MQ
μ ∩α ⊆MQ
Sα ∩α ⊆WQ
Sα ⊆{η | η ∈MQ
μ ∩α+ →η ∈U},
thence MQ
μ ∩α+ ∩α ⊆U. This shows α ∈W[MQ
μ ∩α+].
Proposition 11.9. μ ∈MQ
μ ∧MQ
μ ∩μ ⊆Q →μ ∈WQ
μ ∧Ds(WQ
μ ).
Proof. By Lemma 11.8, MQ
μ ∩μ ⊆Q implies MQ
μ ∩μ = WQ
μ ∩μ. Thus, by
Lemma 11.4(viii), μ ∈MQ
μ implies μ ∈WQ
μ .
Next we show that WQ
μ is a distinguished set.
Ad (D1): If α ∈WQ
μ ∩μ then Sα ∈Q ∩μ ⊆WQ
μ ∩μ. From α ∈WQ
μ and
μ ≤α we obtain Sα = μ ∈WQ
μ .

416
Michael Rathjen
Ad (D2): For τ ≤μ we have (∗) WQ
μ ∩τ = Q ∩τ since MQ
μ ∩μ ⊆Q yields
WQ
μ ∩τ ⊆Q, and so, by Lemma 11.8, Q ∩τ ⊆WQ
μ holds. Now let P := WQ
μ
and suppose ν ∈P. By (∗), we then have P ∩ν = Q ∩ν, and thus, by Lemma
11.4(viii), (∗∗) WP
ν = WQ
ν . For ν < μ, (∗) entails ν ∈Q and therefore
WP
ν = WQ
ν = Q ∩ν+ (∗)
= WQ
μ ∩ν+ = P ∩ν+.
If ν = μ, then (∗∗) yields WQ
μ = P = P ∩μ+.
Vacuously ∅is a distinguished set. Proposition 11.9 yields the existence of non-
trivial distinguished sets. For example, W∅
0 is a distinguished set.
Lemma 11.10. Prg(P ∪Q, U) →P ∪Q ⊆U.
Proof. Suppose Prg(P ∪Q, U). Then we have
P ∩α ⊆U →Prg(Q, {η | η < α →η ∈U}), and
P ∩α ⊆U ∧Q ∩α ⊆U ∧α ∈P →α ∈U.
Therefore, by Lemma 11.6(ii), we have
P ∩α ⊆U ∧α ∈P →α ∈U,
i.e. Prg(P, U) holds, and consequently P ⊆U by Lemma 11.6(ii). Similarly one
shows that Q ⊆U.
Lemma 11.11. μ ∈P ∪Q ∧μ ≤P ∧μ ≤Q →P ∩μ+ = Q ∩μ+.
Proof. We use induction on P ∪Q, i.e. Lemma 11.10. Let μ ∈P and suppose
μ ≤Q. The induction hypothesis yields P ∩μ = Q ∩μ and, by Lemma 11.4(vii),
we conclude that μ ∈P ∩μ+ = WP
μ = WQ
μ ⊆MQ
μ , and hence μ ∈Q by Lemma
11.7(iv). As a result, P ∩μ+ = WP
μ = WQ
μ = Q ∩μ+. The same arguments can
be used if μ ∈Q and μ ≤P.
Proposition 11.12. α ∈Q →Q ∩α+ = W ∩α+.
Proof. Let α ∈Q. Q ∩α+ ⊆W ∩α+ is obvious by deﬁnition of W. Let
η ∈W ∩α+. Then there exists a distinguished set P such that η ∈P ∩α+. Thus
Sη ∈P ∪Q, Sη ≤η ∈P and Sη ≤α ∈Q. Therefore η ∈P ∩η+ = Q ∩η+ ⊆
Q ∩α+ using Lemma 11.11.
Next we study closure properties shared by all distinguished sets.
Proposition 11.13.
(i) α, β ∈Q →α + β ∈Q.
(ii) α, β ∈W →α + β ∈W.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
417
Proof. (ii) is an immediate consequence of (i) in view of Proposition 11.12. In
the proof of (i) let X := MQ
Sα, Y := WQ
Sα and U := {ξ | α + ξ ∈Y }. Suppose
α, β ∈Q. If Sα < Sβ then α + β = β ∈Q. Now assume Sβ ≤Sα. Then we
have Q ∩α+ = Y and α, β ∈Y . Moreover we have
η ∈X ∧X ∩η ⊆U →α + η ∈X ∧X ∩(α + η) ⊆Y,
so that with Lemma 11.4(viii) we get η ∈X ∧X ∩η ⊆U →α + η ∈Y . As a
result, Prg(X, U) holds, and thus Y ⊆U by Lemma 11.4(i), hence α + β ∈Y ⊆
Q.
Lemma 11.14. Letting F(α, β) be the formula
α, β ∈Q ∧(∀ξ ∈Q ∩α)(∀η ∈Q)(ϕξη ∈Q) ∧(∀η ∈Q ∩β)(ϕαη ∈Q),
the following are true:
(i) F(α, β) ∧μ = max{Sα, Sβ} ∧γ ∈MQ
μ ∩ϕαβ →γ ∈Q.
(ii) F(α, β) →ϕαβ ∈Q.
Proof. We show (i) by induction on Gγ. F(α, β) implies α, β ∈Q∩μ+ = WQ
μ .
We distinguish cases according to the shape of γ. The assertion is trivially true if
γ = 0. Let γ =nf γ1 + . . . + γn. Then γ1, . . . , γn ∈MQ
μ ∩ϕαβ, and thus by the
induction hypothesis, γ1, . . . , γn ∈Q, so γ ∈Q by Proposition 11.13. If γ ∈SC
then γ ≤α ∨γ ≤β, and therefore, as α, β ∈WQ
μ and γ ∈MQ
μ , it follows from
Lemma 11.4(viii) that γ ∈WQ
μ ⊆Q.
The last case to consider is when γ =nf ϕξη for some ξ, η. Then ξ, η ∈MQ
μ ∩
ϕαβ and the induction hypothesis yields ξ, η ∈Q. If ξ ≤α then γ ∈Q follows
from F(α, β). If α < ξ then γ < β must hold, and with the aid of Lemma 11.4(viii)
we conclude that γ ∈Q.
(ii) By (i) we have
F(α, β) ∧μ = {Sα, Sβ} →MQ
μ ∩ϕαβ ⊆WQ
μ .
By Lemma 11.7(ii) we also have
F(α, β) ∧μ = max{Sα, Sβ} →ϕαβ ∈MQ
μ .
Thus, by Lemma 11.4(viii),
F(α, β) ∧μ = max{Sα, Sβ} →ϕαβ ∈WQ
μ ,
and hence F(α, β) →ϕαβ ∈Q.

418
Michael Rathjen
Proposition 11.15.
(i) α, β ∈Q →ϕαβ ∈Q.
(ii) α, β ∈W →ϕαβ ∈W.
Proof. Again, by Proposition 11.12, (ii) is an immediate consequence of (i). Let
α ∈Q, U := {ξ | (∀η ∈Q)(ϕξη ∈Q)} and V := {η | ϕαη ∈Q}. Lemma
11.14(ii) yields
(∀ξ ∈Q ∩α)(∀η ∈Q)(ϕξη ∈Q) →Prg(Q, V )
and hence, using Lemma 11.6(ii),
(∀ξ ∈Q ∩α)(∀η ∈Q)(ϕξη ∈Q) →Q ⊆V.
The latter implies Prg(Q, U), whence Q ⊆U.
Corollary 11.16.
(i) Sα ≤μ ∧μ ∈Q ∧SCμ(α) ⊆Q →α ∈Q.
(ii) Sα ≤μ ∧μ ∈W ∧SCμ(α) ⊆Q →α ∈W.
Proof. This follows from Propositions 11.13 and 11.15.
Lemma 11.17.
(i) β ∈Q ∧α ∈MQ
Sβ ∩β →α ∈Q.
(ii) β ∈W ∧α ∈MQ
Sβ ∩β →α ∈W.
(i) β ∈Q implies β ∈Q ∩β+ = WQ
Sβ. Therefore, by Lemma 11.4(viii),
α ∈WQ
Sβ ⊆Q. (ii) is an immediate consequence of (i).
Deﬁnition 11.18. BQ
μ := {α | (∀τ ∈Q ∩μ)[Kτα < α →ψτα ∈Q}.
Lemma 11.19. Assume α ∈MQ
μ , MQ
μ ∩α ⊆BQ
μ , ν ∈Q ∩μ, Kνα < α and
γ ∈MQ
ν ∩ψνα. Then γ ∈Q.
Proof. We proceed by induction on Gγ.
If γ ≤ν then γ ∈Q by Lemma 11.17(i). Now let ν < γ.
1. γ =nf γ1 + . . . + γn By the induction hypothesis we get γ1, . . . , γn ∈Q and
hence γ ∈Q by Lemma 11.13.
2. γ =nf ϕξη. By the induction hypothesis we get ξ, η ∈Q and hence γ ∈Q by
Lemma 11.15.
3. γ =nf Φξη. Then we would have γ ≤ν since γ < ν+, but this we ruled out.
So this case cannot occur.
4. γ =nf ψνη. Then η < α. By Lemma 11.7(i), γ ∈MQ
ν entails that
(∀τ ∈Q ∩ν)(∀β ∈SCν(η)) SCτ(β) ⊆SCτ(η) ⊆Q.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
419
Since SCν(η) < ψνη < ψνα, the latter entails that SCν(η) ⊆MQ
ν ∩ψνα, and
therefore, by the induction hypothesis, SCν(η) ⊆Q. As a result we have shown
that
(∀τ ≤ν)[τ ∈Q ∩μ →SCτ(η) ⊆Q].
Via a subsidiary induction on Q we shall show that
(∀τ ∈Q ∩μ) SCτ(η) ⊆Q.
Let τ ∈Q ∩μ. In view of (11.1) we may assume that ν < τ. The subsidiary
induction hypothesis yields (∀τ ′ ∈Q ∩τ) SCτ ′(η) ⊆Q, which implies SCτ(η) ⊆
MQ
τ . Since ν < τ, Kνη < η and Kνα < α hold, we conclude that Kτη < η,
Kτα < α and SCτ(η) < ψτη < ψτα. Therefore we have SCτ(η) ⊆MQ
τ ∩ψτα
and consequently, by applying the main induction hypothesis, SCτ(η) ⊆Q. This
completes the proof of (11.1).
Finally, from (11.1) we conclude that η ∈MQ
μ ∩α ⊆BQ
μ , yielding γ = ψνη ∈
Q.
Lemma 11.20. Prg(MQ
μ , BQ
μ ).
Proof. Let α ∈MQ
μ and MQ
μ ∩α ⊆BQ
μ . We have to show α ∈BQ
μ . So suppose
ν ∈Q ∩μ and Kνα < α. By Lemma 11.19 we have MQ
ν ∩ψνα ⊆WQ
ν . For
τ ∈Q ∩ν it holds SCτ(ψνα) = SCτ(ν) ∪SCτ(α) and therefore, using Lemma
11.7(ii), SCτ(ψνα) ⊆Q since ν ∈Q and α ∈MQ
μ . Thus ψνα ∈MQ
ν , so that by
Lemma 11.4(viii) we have ψνα ∈WQ
ν ⊆Q. This shows α ∈BQ
μ .
Lemma 11.21.
(i) α, ν ∈Q ∧Kνα < α →ψνα ∈Q.
(ii) α, ν ∈W ∧Kνα < α →ψνα ∈W.
Proof. (ii) is a consequence of (i). For (i), let τ := max{Sα, Sν} and μ := τ +.
By Lemmata 11.20 and 11.4(i), we have WQ
μ ⊆BQ
μ . Therefore, since τ ∈Q, we
have Q ∩μ ⊆BQ
μ , and hence ψνα ∈Q.
Lemma 11.22. (∀j ∈U)Ds(Qj) →Ds({Qj | j ∈U}).
Proof. Suppose Ds(Qj) holds for all j ∈U. Using arithmetical comprehension,
Z : =

{Qj | j ∈U}
is a set. If α ∈Z there exists j ∈U such that α ∈Qj, thus Sα ∈Qj ⊆Z,
showing that Z satisﬁes (D1). To verify (D2), suppose μ ∈Z. Then μ ∈Qi for
some i ∈U. Owing to Proposition 11.12 it follows that
W ∩μ+ = Qi ∩μ+ ⊆Z ∩μ+ ⊆W ∩μ+,

420
Michael Rathjen
and thus Qi ∩μ+ = Z ∩μ+. By applying Lemma 11.4(vii), we see that WZ
μ =
WQi
μ
= Qi ∩μ+ = Z ∩μ+.
12 Well-ordering proofs in Π1
1-TR0, Π1
1-TR + Δ1
2-CA and
Δ1
2-CA + BR(impl-Σ1
2).
Lemma 12.1. ν < Sα →SCν(Sα) ⊆SCν(α).
Proof. We use induction on Gα.
1. If α =nf α1 + . . . + αn or α =nf ϕξβ the assertion follows immediately from
the induction hypothesis.
2. α =nf ψμβ. Then Sα = μ and SCν(μ) ⊆SCν(α).
3. α =nf Φξβ. Then Sα = α.
Proposition 12.2. Π1
1-TR0 ⊢∀α(α ∈W →Ωα ∈W).
Proof. We argue informally in Π1
1-TR0. Let α ∈W. Then there exists a
distinguished set Q such that α ∈Q. By Lemma 11.6(ii), <↾Q is a well-ordering,
thus, using (Π1
1-TR), there exists a set X such that for all β ∈Q,
Xβ = W
XQβ
Ωβ
∪Q
where XQβ := {Xη | η ∈Q ∩β} and Xη := {z | ⟨η, z⟩∈X}.
We now show by induction on Q that for all β ∈Q,
Ωβ ∈Xβ ∧Ds(Xβ) ∧XQβ ⊆Xβ.
Let β ∈Q. The induction hypothesis, in conjunction with Lemma 11.22, yields
Ds(XQβ) ∧(∀ξ ∈Q ∩β) (Ωξ ∈XQβ).
As 0 ∈W∅
0 ⊆Q, we have Ω0 = 0 ∈X0 and hence (12.1) holds when β = 0.
Now let 0 < β. If ν ∈XQβ ∩Ωβ we can use Lemma 11.7(ii) to conclude that
SCν(Ωβ) = SCν(β) ⊆XQβ since β ∈Q ⊆XQβ. This shows
Ωβ ∈MXQβ
Ωβ .
Now let δ ∈MXQβ
Ωβ
∩Ωβ and Sδ = Ωσ. We want to show δ ∈XQβ. We may
assume that β < Ωβ since otherwise we have β = Ωβ and thus MXQβ
Ωβ
∩Ωβ =
MQ
β ∩β ⊆Q ⊆XQβ using Lemmata 11.11, 11.4(vii) and 11.17(i).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
421
Case 1: Sδ ≤Sβ or there exists ξ ∈Q ∩β such that Sδ ≤Ωξ. Then, by
Corollary 11.16, we obtain δ ∈XQβ.
Case 2: (∀ξ ∈Q ∩β)(Ωξ < Ωσ) and Sβ < Sδ = Ωσ. In this case we have
Sβ ∈XQβ ∩Ωβ, thus, using Lemma 12.1, we arrive at
SCSβ(σ) = SCSβ(Ωσ) ⊆SCSβ(δ) ⊆XQβ,
and hence SCSβ(σ) ⊆XQβ ∩(Sβ)+. An application of Lemma 11.11 yields
SCSβ(σ) ⊆Q, and since σ < β and Sσ ≤Sβ we conclude that σ ∈Q ∩β by
employing Lemma 11.16. However, this is an impossibility since we assumed that
(∀ξ ∈Q ∩β)(Ωξ < Ωσ). Thus Case 2 is ruled out.
In sum, we have shown that
MXQβ
Ωβ
⊆XQβ.
In view of the Lemmata 11.9 and 11.22 we can deduce Ωβ ∈Xβ ∧Ds(Xβ) from
(12.1 and (12.1). Moreover, by Lemma 11.22, we have XQβ ∩Ωβ ⊆WXQβ
Ωβ , and
hence
XQβ = (XQβ ∩Ωβ) ∪Q ⊆Xβ.
This completes the proof of (12.1). Letting Z := {Xβ | β ∈Q}, we can use
Lemma 11.22 and (12.1) to conclude that Ds(Z) and (∀β ∈Q) (Ωβ ∈Z), hence
Ωα ∈W.
Corollary 12.3. Let E[U, β, γ, Q] be the Π1
1 formula γ ∈Q ∨γ ∈WU
Ωβ. Put
Ξ0 := 1 and Ξn+1 := ΩΞn. Let T be the theory Π1
1-CA0 plus the additional rule
∃!Q (F[Q] ∧Ds(Q))
∀P (F[P] ∧Ds(P) →∃X(∀β ∈P)∀γ(γ ∈Xβ ↔E[XP β, γ, P]))
with the proviso that F[Q] is an arithmetical formula.
For all n we then have
T ⊢Ξn ∈W.
Proof. We proceed by meta-induction on n. For n = 0 this obvious. Let
n = m + 1. By the the induction hypothesis, we have T ⊢Ξm ∈W. Let
μ := Ξm. Arguing in T, there exists a distinguished set Q such that μ ∈Q
and Q = Q ∩μ+. Owing to Lemma 11.11, Q is uniquely determined via this
description. Thus ∃!P F[P], where F[P] := (μ ∈P ∧P ∩μ+ = P). Since
μ can be described via an arithmetical formula, too, we can use the above rule to
infer that there exists a set X such that (∀β ∈Q)∀γ(γ ∈Zβ ↔E[XQβ, γ, Q]).
Inspection of the proof of Proposition 12.2 shows that the existence of X is what is
needed to conclude that Ωμ ∈W, i.e. Ξn ∈W.

422
Michael Rathjen
Corollary 12.4. For all n, Δ1
2-CA + BR(impl-Σ1
2) ⊢Ξn ∈W.
Proof. As a corollary of the proof of Theorem 6.14 one has that the theorems
of Δ1
2-CA + BR(impl-Σ1
2) are closed under the inference rule (12.1). Thus, by
Corollary 12.3, the claim is true.
Lemma 12.5. Let T∗be the theory KPlr augmented by the rule
∃!α A[α]
∀β∀x (A[β] →∃f D0[x, β, f])
for every Σ formula A[β] and D0[x, β, f] be deﬁned as in Lemma 5.3.
With T being the theory of Corollary 12.3 we then have
T ⊆T∗.
(To avoid possible confusion I hasten to remark that quantiﬁers ∀β, ∃β, . . . in
theories with language L2 are still supposed to range over OT(Φ) while the same
quantiﬁers in the context of L∗-theories are supposed to range over set-theoretic
ordinals.)
Proof. It is easy to show that Π1
1-CA0 ⊆KPlr: By Lemma 2.5, more precisely
(4.1), Π1
1 formulae are equivalent to formulae saying that certain arithmetical rela-
tions (which may contain set parameters) are well-founded, and thus, by Theorem
5.6, they are Δ1 on any admissible set which houses the parameters of this formula.
Therefore in KPlr one has comprehension for Π1
1 formulas. (see Theorem 5.6).
So it sufﬁces to establish the closure of the T∗-provable formulae under the rule
(12.1) (modulo the ∗-translation). Suppose
T∗⊢(∃!Q(F[Q] ∧Ds(Q)))∗.
Since Π1
1 formulae are provably Δ1 in KPlr and the formula Ds(Q) is arithmetical
in Π1
1, Ds(Q) is provably Δ1 in KPlr. Moreover, by Theorem 5.6, Q is order-
isomorphic to an ordinal α which will then have a provable Σ1 deﬁnition in T∗.
By rule (12.1) there exist a function f with D0[Q, α, f]. Picking an admissible set
K with Q, α, f ∈K, we can now proceed as in the proof of Lemma 5.8 to arrive
at the conclusion of the rule (12.1).
Adding Δ1
2-CA to Π1
1-TR enables us to show that much bigger ordinals belong
to W.
Lemma 12.6. Π1
1-TR + Δ1
2-CA ⊢(∀δ < ψ00) [Φ1δ ∈W →Φ1(δ + 1) ∈W].

Investigations of Subsystems of Second Order Arithmetic and Set Theory
423
Proof. Let δ < ψ00 and suppose that Φ1δ ∈W. By employing arithmetical
comprehension there exists a function f : N −→OT(Φ) such that f(0) = Φ1δ
and f(k + 1) = Ωf(k). Using Proposition 12.2 and (IND) we obtain
(∀k ∈N)∃X [Ds(X) ∧f(k) ∈X ∧f(k) < Φ1(δ + 1)].
Since by Lemma 6.11 (Σ1
2-AC) is available in our background theory, we may infer
from (12.1) the existence of a set Y such that
(∀k ∈N)[Ds(Yk) ∧f(k) ∈Yk].
Letting Z := {Yk | k ∈N} (which is a set by arithmetical comprehension),
we conclude with the help of Lemma 11.22 that Z is a distinguished set. Using
induction on Gα one easily establishes that
(∀α < Φ1(δ + 1))(∃k ∈N) α < f(k).
Using (Π1
1-CA), U := WZ
Φ1(δ+1) is a set.
If ν ∈Z ∩Φ1(δ + 1) then SCν(Φ1(δ + 1)) = SCν(1) ∪SCν(δ + 1) = ∅, and
therefore Φ1(δ + 1) ∈MZ
Φ1(δ+1). If β ∈MZ
Φ1(δ+1) ∩Φ1(δ + 1) then, by (12.1),
there exists ν ∈Z ∩Φ1(δ + 1) with Sβ ≤ν, whence, by Corollary 11.16(i),
β ∈Z. Thus, in the light of Proposition 11.9, the foregoing observations show that
Φ1(δ + 1) ∈U and Ds(U), whence Φ1(δ + 1) ∈W.
Lemma 12.7. Let ω0 := ϕ00, ωn+1 := ϕ0ωn and
varepsilon0 := ϕ10. Then, for all n < ω,
Π1
1-TR + Δ1
2-CA ⊢(∀α < ωn) Φ1α ∈W.
Proof. For every (meta) n,
ACA ⊢(∀α < ωn)[(∀δ < α)F(δ) →F(α)] →(∀α < ωn) F(α)
for every L2 formula F(α).
Therefore it sufﬁces to infer Φ1α ∈W from the assumptions α < ωn and
(∀δ < α) Φ1δ ∈W.
If α = γ+1 for some γ then Φ1α ∈W is a consequence of 12.6. For α = 0 note
that Φ10 ∈W holds by employing a modiﬁcation of the proof of 12.6 whereby one
deﬁnes f : N −→OT(Φ) by f(0) = Ω1 and f(k + 1) = Ωf(k).
Now assume that α is a limit. By assumption we have
(∀δ < α)∃X (Φ1δ ∈X ∧Ds(X)).

424
Michael Rathjen
Applying (Σ1
2-AC) we ﬁnd a set Y such that
(∀δ < α)[Φ1δ ∈Yδ ∧Ds(Yδ)].
Letting Z := {Yδ | δ < α} and U := WZ
Φ1α, 11.22 tells us that Z is a distin-
guished set. For ν ∈Z ∩Φ1α we have SCν(Φ1α) = ∅as α < ψ00; and hence
Φ1α ∈MZ
Φ1α. For every β ∈MZ
Φ1α ∩Φ1α there exists γ < α with Sβ ≤Φ1γ,
and thus, using 11.16(i), it follows that β ∈Z. Thus, applying 11.9, the foregoing
yields that Φ1α ∈U ∧Ds(U), thereby verifying Φ1α ∈W.
Lemma 12.8. For α ∈OT(Φ) let <α be the restriction of < to ordinals < α, i.e.
β <α γ ⇔β < γ < α. We shall write WO(α) rather than WO(<α). Then:
Π1
1-CA0 ⊢α ∈W ∧α < Ω1 →WO(α).
Proof. Let α ∈W ∩Ω1. Then there exists a distinguished set Q such that
α ∈Q ∩Ω1. Since Sα = 0 ∈Q, it follows that α ∈Q ∩0+ = W[{η | η < Ω1}],
and hence WO(α).
Lemma 12.9. With Ξn being deﬁned as in 12.3, the following hold:
(i) Ξn < Ξn+1 and K0Ξn = ∅, hence ψ0Ξn ∈OT(Φ).
(ii) For every α < Φ10 there exists n such that Ξn > α.
(iii) For every β < ψ0(Φ10) there exists n such that β < ψ0Ξn.
Proof. (i) can be easily shown by induction on n. (ii) follows by induction on
Gα, while (iii) follows from (ii) using induction on Gβ.
Deﬁnition 12.10. Let T be a theory whose language is L2 or L∗. We say that an
ordinal α is provable in T if there exists a primitive recursive well-ordering whose
order-type is α such that T ⊢WO(≺).
The proof-theoretic ordinal of T is the least ordinal not provable in T, or, equiv-
alently, it is the supremum of the provable ordinals of T. We denote this ordinal by
|T|.
Theorem 12.11.
(i) ψ0(Φ10) ≤|Π1
1-TR0|.
(ii) ψ0(Φ10) ≤|Δ1
2-CA + BR(impl-Σ1
2)|.
(iii) Letting T be any of the theories of 12.3 or 12.5 it holds that ψ0(Φ10) ≤|T|.
(iv) ψ0(Φ1ε0) ≤|Π1
1-TR + Δ1
2-CA|.
Proof. (i) follows from 12.2, 12.9 and 12.8. (ii) is a consequence of 12.4, 12.9
and 12.8. (iii) follows from 12.3 and 12.5 using 12.9 and 12.8. (iv) is a consequence
of 12.7, 12.9 and 12.8.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
425
13 Well-ordering proofs in Π1
1-TR and Π1
1-TR + (BI)
Building on 12.2, we will prove lower bounds for the theories mentioned in this
section’s title. We will also use techniques which were developed in [6] and [7],
paragraph 13.
Using (BI) we can strengthen 11.6 as follows.
Lemma 13.1. For every L2 formula F(a),
Π1
1-CA + (BI) ⊢Prg(W, F) →W ⊆F.
Proof. By 11.6 we have ∀X(Prg((Q, X) →Q ⊆X), which in the presence
of (BI) yields Prg(Q, F) →Q ⊆F for every L2 formula F(a) (cf. [15, Lemma
1.6.3]). Assuming Prg(W, F) and α ∈W, we use 11.12 to infer the existence of
a distinguished set P with α ∈P and W ∩α+ = P ∩α+. Therefore we have
Prg(P, F), so P ⊆F, and thence F(α).
With the help of 13.1 we can strengthen some of the results of section 11. Using
(BI), the proof of 11.19 carries over to W, yielding the following strengthening of
11.20.
Lemma 13.2. Π1
1-CA + (BI) ⊢Prg(MW
μ , BW
μ ).
For the next Lemma the employment of (IND) is crucial.
Lemma 13.3. Π1
1-TR ⊢MW
Φ10 ∩Φ10 = W ∩Φ10.
Proof. Let f be the primitive recursive function f : ω −→OT(Φ) deﬁned by
f(0) = 1 and f(k + 1) = Ωf(k). With help of (IND), 12.2 and 12.9(ii) yield
(∀k < ω) f(k) ∈W ∧(∀α < Φ10)(∃k < ω) α < f(k).
Let ξ ∈MW
Φ10∩Φ10. Then, according to (13.1), there exists k < ω with Sξ ≤f(k).
By 11.16 we then get ξ ∈W ∩Φ10. Conversely, if ξ, μ ∈W ∩Φ10 we have
SCμ(ξ) ⊆W by 11.7(ii), whence ξ ∈MW
Φ10 ∩Φ10.
Deﬁnition 13.4. By I(U, α) we shall refer to the schema
Prg(U, F) →α ∈U ∧U ∩α ⊆F
where F(a) is an arbitrary formula of L2.
Lemma 13.5. Π1
1-TR + (BI) ⊢I(MW
Φ10, (Φ10) + 1).

426
Michael Rathjen
Proof. Let X := MW
Φ10 and τ := Φ10. According to 13.3 we have X∩τ = W∩τ
which implies
Prg(X, F) →Prg(W, {ξ | ξ < τ →F(ξ)}),
and which, with the help of 13.1, implies Prg(X, F) →W ∩τ ⊆F. The latter
yields
Prg(X, F) →X ∩τ ⊆F.
Since also τ, τ + 1 ∈X, the desired assertion follows.
Deﬁnition 13.6. For every formula F(a) we deﬁne the “Gentzen jump”
F j(γ) := ∀δ [MW
Φ10 ∩δ ⊆F →MW
Φ10 ∩(δ + ωγ) ⊆F].
Lemma 13.7. The following are deducible in Π1
1-TR:
(i) F j(γ) →MW
Φ10 ∩ωγ ⊆F.
(ii) Prg(MW
Φ10, F) →Prg(MW
Φ10, F j).
Proof. (i) is obvious. (ii) Let M := MW
Φ10. Then M ∩(δ + ωγ) ⊆F is to
proved under the assumptions (a) Prg(M, F), (b) γ ∈M ∧M ∩γ ⊆F j and (c)
M ∩δ ⊆F. So let η ∈M ∩(δ + ωγ).
1. η < δ: Then F(η) is a consequence of (c).
2. η = δ: Then F(η) follows from (c) and (a).
3. δ < η < δ + ωγ: Then there exist γ1, . . . , γk < γ such that
η = δ + ωγ1 + . . . + ωγk
and γ1 ≥. . . ≥γk. η ∈M implies γ1, . . . , γk ∈M ∩γ. Through applying
(b) and (c) we obtain M ∩(δ + ωγ1) ⊆F. By iterating this procedure we
eventually arrive at F(δ + ωγ1 + . . . + ωγk), so F(η) holds.
Lemma 13.8. Let δ0 := (Φ10) + 1, δn+1 := ωδn and M := MW
Φ10. Then:
Π1
1-TR + (BI) ⊢I(M, δn).
Proof. Proof by meta-induction on n. For n = 0 this follows from 13.5. Now let
n = m + 1. Inductively we have Prg(M, F j) →F j(δm) for every formula F(a).
An application of 13.7 yields Prg(M, F) →M ∩δn ⊆F. Since trivially δn ∈M,
we have shown I(M, δn).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
427
Theorem 13.9. ψ0ε(Φ10)+1 ≤|Π1
1-TR + (BI)|.
Proof. 13.2 and 13.8 yield δn ∈BW
Φ10, and consequently ψ0δn ∈W. Since
sup{ψ0δn | n < ω} = ψ0ε(Φ10)+1 the proof is completed.
We now come to the well-ordering proof for Π1
1-TR. Since (BI) is not available
in this theory, 13.1 cannot be exploited to prove that I(MW
Φ10, Φ10) holds. How-
ever, Π1
1-TR proves (∀α < Φ10)(∃k < ω)(α < f(k) ∧f(k) ∈W) (where f
was deﬁned in 13.3), establishing ψ0((Φ10) · ε0) as a lower bound for this theory.
Convention: For the remainder of this section we let f := Φ10.
Lemma 13.10. Multiplication α · β of ordinals from OT(Φ) can be easily deﬁned
via the normal forms of α and β. For α ≤ε0 we have:
(i) K0(f · α) = ∅.
(ii) ν < f →SCν(f · α) = ∅.
(iii) β < f · α →(∃ξ < α)(∃δ < f)(β = f · ξ + δ).
(iv) β < ψ0(f · ε0) →(∃ξ < ε0) β < ψ0(f · ξ).
Proof. The proofs consist of simple calculations and in (iii) and (iv) involve
inductions on Gβ.
Deﬁnition 13.11. Let H(δ) be the formula
δ ≤ε0 ∧
(∀μ ∈W ∩f)(∀η, ν ∈W ∩μ+)[Kνη < f · δ + η →ψν(f · δ + η) ∈W]
and let Aδ(α, μ, ν) be the formula
δ < ε0 ∧μ ∈W ∩f ∧α, ν ∈W ∩μ+ ∧Kνα < f · δ + α ∧
(∀η ∈W ∩α)(∀τ ′ ∈W ∩μ+)[Kτ ′η < f · δ + η →ψτ ′(f · δ + η) ∈W].
Lemma 13.12. Π1
1-TR proves that
(∀ξ < δ)H(ξ) ∧Aδ(α, μ, ν) →(∀γ ∈MW
ν ∩ψν(fδ + α))(γ ∈W).
Proof. Assume the antecedent of the implication we have to verify. Let γ ∈
MW
ν ∩ψν(fδ +α). We shall carry out an induction on Gγ in order to show γ ∈W,
by distinguishing between the different shapes γ might assume. We shall write fδ
for f · δ.
1. γ ≤ν: Then γ ∈W follows from 11.17(ii). Henceforth assume γ > ν.

428
Michael Rathjen
2. γ =nf γ1 + . . . + γn or γ =nf ϕγ1γ2. Then γj ∈MW
ν ∩ψν(fδ + α) and
therefore, by the inductive assumption, γj ∈W, thus γ ∈W by 11.13 and
11.15, respectively.
3. γ =nf ψν(fδ + α′) and α′ < α: Let γ′ := fδ + α′. Since γ ∈MW
ν , 11.7(i)
entails that
(∀τ ∈W ∩ν)(∀ξ ∈SCν(γ′)) SCτ(ξ) ⊆W.
The latter implies SCν(γ′) ⊆MW
ν ∩ψνγ′ ⊆MW
ν ∩ψν(fδ + α). Thus
SCν(γ′) ⊆W
by the induction hypothesis. Next we show via a subsidiary induction on Q
that for every distinguished set Q with μ ∈Q,
(∀τ ∈Q ∩μ+) SCτ(γ′) ⊆Q.
We shall frequently use the fact that W ∩μ+ = Q ∩μ+ holds (by 12.11). If
τ = ν then this follows from (13.1). If τ < ν then SCτ(γ′) ⊆SCτ(γ) ⊆
W ∩μ+ ⊆Q since γ ∈MW
ν .
Now assume that ν < τ ≤μ. Since SCτ(γ′) < ψτγ′ < ψτ(fδ + α), the sub-
sidiary induction hypothesis yields SCτ(γ′) ⊆MW
τ ∩ψτ(fδ + α). Moreover,
Kτα ⊆Kνα < fδ + α. Therefore Aδ(α, μ, ν) and consequently, by the main
induction hypothesis, SCτ(γ′) ⊆W ∩μ+ ⊆Q. This completes the proof of
(13.1). As a result, (∀τ ∈W ∩μ+) SCτ(γ′) ⊆W. In combination with 11.16
the latter entails α′ ∈W. Finally, Aδ(α, μ, ν) and α′ ∈W ∩α imply γ ∈W.
4. γ =nf ψν(fδ′ + α′), δ′ < δ and α′ < f : Let γ′ := fδ′ + α′. Let Q be a
distinguished set. Via a subsidiary induction on Q we shall show that
(∀τ ∈Q ∩f) SCτ(γ′) ⊆Q.
For τ ≤ν this follows as in the previous case. Let ν < τ < f. Since
SCτ(γ′) < ψτγ′ and ψτγ′ < ψτ(fδ) the subsidiary induction hypothesis
yields SCτ(γ′) ⊆MW
τ ∩ψτ(fδ), so that, owing to Aδ(0, τ, τ) and the main
induction hypothesis, we arrive at SCτ(γ′) ⊆W ∩τ + ⊆Q. This concludes
the proof of (13.1).
(13.1) implies (∀τ ∈W ∩f) SCτ(α′) ⊆W, thence α′ ∈MW
f ∩f. Via 13.3 we
thus infer α′ ∈W. Since δ′ < δ we also have H(δ′) and therefore γ ∈W.
Lemma 13.13. Π1
1-TR ⊢δ < ε0 ∧(∀ξ < δ)H(ξ) →H(δ).

Investigations of Subsystems of Second Order Arithmetic and Set Theory
429
Proof. Assume δ < ε0 and (∀ξ < δ)H(ξ). From Aδ(α, μ, ν) and α, ν ∈Q we
can infer ψν(fδ +α) ∈MQ
ν and with the help of 13.12 also MQ
ν ∩ψν(fδ +α) ⊆Q,
and hence ψν(fδ + α) ∈Q by 11.4(viii). This shows
Aδ(α, μ, ν) →ψν(fδ + α) ∈W.
Let μ ∈W ∩f. We want to show
(∀α, ν ∈W ∩μ+) [Kνα < fδ + α →ψν(fδ + α) ∈W].
So let Q be a distinguished set with μ ∈Q. Since W ∩μ+ = Q ∩μ+ it sufﬁces to
show that if α, ν ∈Q ∩μ+ and Kνα < fδ + α hold true then ψν(fδ + α) ∈Q. We
use induction on Q with α being the variable of induction. By induction hypothesis
we then have
(∀η ∈Q ∩α)(∀τ ∈Q ∩μ+)[Kτη < fδ + η →ψτ(fδ + η) ∈Q].
But then (13.1) implies ψν(fδ + α) ∈Q.
Theorem 13.14. ψ0((Φ10) · ε0) ≤|Π1
1-TR|.
Proof. Given β < ψ0((Φ10) · ε0) there exists (by 13.10(iv)) ωn such that β <
ψ0((Φ10) · ωn). Since in Π1
1-TR we have full transﬁnite induction on the initial
segment of ordinals ≤ωn, Lemma 13.13 yields Π1
1-TR ⊢H(ωn). Thus, using
11.21 and 12.8, we obtain
Π1
1-TR ⊢WO(ψ0((Φ10) · ωn)),
which implies ψ0((Φ10) · ε0) ≤|Π1
1-TR|.
14 Well-ordering proofs in Σ1
2-TRDC0 and Σ1
2-TRDC.
We start with the key lemma for all of the remaining well-ordering proofs.
Lemma 14.1. Σ1
2-TRDC0 proves that
η ∈W ∧(∀ξ ∈W ∩η)(∀α ∈W)(Φξα ∈W) →(∀β ∈W)(Φηβ ∈W).
Proof. We shall argue on the basis of Σ1
2-TRDC0. Suppose η ∈W and
(∀ξ ∈W ∩η)(∀α ∈W)(Φξα ∈W).

430
Michael Rathjen
Let β ∈W. Pick a distinguished set Q with η, β ∈Q. For every distinguished set
X we then have
(∀ξ ∈Q ∩η)(∀α ∈X)∃Y [Ds(Y ) ∧Φξα ∈Y ].
Thus, with the help of (Σ1
2-AC) we ﬁnd a set U such that
(∀ξ ∈Q ∩η)(∀α ∈X)[Ds(U⟨ξ,α⟩) ∧Φξα ∈U⟨ξ,α⟩].
Letting
U ∗:=

{U⟨ξ,α⟩| ξ ∈Q ∩η ∧α ∈X}
we have Ds(U ∗) (by 11.22) and also (∀ξ ∈Q ∩η)(∀α ∈X)(Φξα ∈U ∗). For an
arbitrary distinguished set P the foregoing considerations imply that
(∀i < ω)∀X∃Y [(i = 0 →Y = P) ∧
(i > 0 ∧Ds(X) →[Ds(Y ) ∧(∀ξ ∈Q ∩η)(∀α ∈X)(Φξα ∈Y )])].
By applying (Σ1
2-TRDC) (in actuality (Σ1
2-DC) sufﬁces) to (14.1) we can infer the
existence of a set Z satisfying Z0 = P and for all i > 0,
Ds(

{Zj | j < i}) →Ds(Zi) ∧(∀ξ ∈Q∩η)(∀α ∈

{Zj | j < i}) Φξα ∈Zi.
Induction on i in conjunction with 11.22 yields Ds(Zi) for all i. Note that this
induction is permissible in our background theory since {i < ω | Ds(Zi)} is a set
by (Δ1
2-CA). Letting P ∗:= {Zi | i < ω} we have
Ds(P ∗) ∧P ⊆P ∗∧(∀ξ ∈Q ∩η)(∀α ∈P ∗) Φξα ∈P ∗.
Thus we showed that for all γ ∈Q and for all X there exists Y such that Ds(X)
implies that
∃Z [Ds(Z) ∧Q ∪X ⊆Z ∧(∀ξ ∈Q ∩η)(∀α ∈Z)(Φξα ∈Z) ∧Y = WZ
Φηγ ].
The latter formula is equivalent to a Σ1
2 formula (using (Σ1
2-AC)), hence an via
an application of (Σ1
2-TRDC), with < ∩(Q × Q) being the well-ordering, there
exists a set R such that
(∀γ ∈Q)[Ds(RQγ) →∃Z[Ds(Z) ∧Q ∪RQγ ⊆Z ∧
(∀ξ ∈Q ∩η)(∀α ∈Z)(Φξα ∈Z) ∧Rγ = WZ
Φηγ]],

Investigations of Subsystems of Second Order Arithmetic and Set Theory
431
where RQγ := {Rδ | δ ∈Q ∩γ}. By induction on Q we shall show that
(∀γ ∈Q)[Ds(Rγ) ∧Φηγ ∈Rγ].
So assume inductively that (∀δ ∈Q ∩γ)[Ds(Rδ) ∧Φηγ ∈Rδ]. This implies
Ds(RQγ) and, in view of (14.1), there exists a set Z satisfying the following:
(a) Ds(Z);
(b) Q ∪RQγ ⊆Z;
(c) (∀ξ ∈Q ∩η)(∀α ∈Z)(Φξα ∈Z);
(d) (∀δ ∈Q ∩γ)Φηδ ∈Z;
(e) Rγ = WZ
Φηγ.
If γ = Φηγ we have Φηγ = γ ∈Z ∩γ+ = WZ
γ = Rγ, which implies Ds(Rγ)
and Φηγ ∈Rγ.
Next assume that γ < Φηγ. If ν ∈Z ∩Φηγ then
SCν(Φηγ) ⊆SCν(η) ∪SCν(γ) ⊆Z
by 11.7(ii) since η, γ ∈Q ⊆Z. Therefore we have
Φηγ ∈MZ
Φηγ.
We will also show that
MZ
Φηγ ∩Φηγ ⊆Z.
Let ρ ∈MZ
Φηγ ∩Φηγ. We shall employ induction on Gρ to show that ρ ∈Z. If
ρ /∈SC then ρ ∈Z follows from the inductive assumption by means of 11.13 and
11.15. Now suppose ρ ∈SC. If there exists ν ∈Z ∩Φηγ with Sρ ≤ν then
SCν(ρ) = {ρ} ⊆Z. Thus, in addition, we may assume that
ρ ∈SC ∧(∀ν ∈Z ∩Φηγ)(ν < Sρ).
We will distinguish several cases.
1. ρ =nf ψμζ: Then we have μ ∈MZ
Φηγ∩Φηγ by (14.1) since μ = Sρ. Applying
the induction hypothesis we obtain μ ∈Z which contradicts (14.1). Thus this
case is ruled out.

432
Michael Rathjen
2. ρ =nf Φζσ: Then (14.1) in conjunction with the induction hypothesis yields
ζ, σ ∈Z.
(i) ζ < η: Then we have ζ ∈W ∩η = Q ∩η by 11.12 since η ∈Q. Whence
ρ ∈Z holds owing to (c).
(ii) ζ = η and σ < γ: Then, using (d), from σ ∈W ∩γ = Q ∩γ we obtain
ρ ∈Z.
(iii) η < ζ: In this case ρ < γ must hold. Since γ < Φηγ holds by assump-
tion, ρ ∈Z follows with the aid of 11.16(i) since in this case we have
Sγ ∈Q ∩Φηγ ⊆Z ∩Φηγ.
This completes the proof of (14.1). Applying (14.1), (14.1) and (e) in conjunction
with 11.9, we conclude that Ds(Rγ) ∧Φηγ ∈Rγ, thereby ﬁnishing the proof of
(14.1). Finally, since β ∈Q, (14.1) enables us to conclude that Φηβ ∈W.
Corollary 14.2. For any (meta) n,
Σ1
2-TRDC0 ⊢(∀α ∈W) Φnα ∈W.
Proof. Use meta-induction on n. 12.2 yields the induction base while 14.1
provides the induction step.
Corollary 14.3. For any (meta) n, Σ1
2-TRDC ⊢(∀ξ ≤ωn)(∀α ∈W) Φξα ∈W.
Proof. In Σ1
2-TRDC one has full induction for arbitrary formulae over any
segment ωn. Thus the assertion follows from 14.1.
Theorem 14.4.
(i) ψ0(Φω0) ≤|Σ1
2-TRDC0|.
(ii) ψ0(Φε00) ≤|Σ1
2-TRDC|.
Proof. (i) and (ii) are consequences of 14.2 and 14.3, respectively, by also en-
listing the help of 11.21 and 12.8.
15 Well-ordering proofs in Σ1
2-TRDC + BR and
Σ1
2-TRDC + BR(impl-Σ1
2).
Deﬁnition 15.1. Let ϑ0 := Ω1, ζ0 := ψ0ϑ0, ϑn+1 := Φζn0, ζn+1 := ψ0ϑn+1.
Lemma 15.2.
(i) For all n: K0ϑn < ϑn, ϑn < ϑn+1 and ζn =nf ψ0ϑn.
(ii) For every α < ΦΩ10 there exists n such that α < ϑn.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
433
(iii) For every β < ψ0(ΦΩ10) there exists n such that β < ζn.
Proof. We show (i) by induction on n. This is obvious when n = 0. Let n = m+
1. By the induction hypothesis we have K0ϑn = K0ζm = {ϑm} ∪K0ϑm < ϑn,
and consequently ζn =nf ψ0ϑn, ζm < ζn and ϑn = Φζm0 < Φζn0 = ϑn+1.
(ii): We use induction on Gα. First suppose α =nf Φξη. Then, by induction
hypothesis, there exist n, n′ < ω such that ξ < ϑn and η < ϑn′. Letting k :=
max(n, n′) + 1 it follows by (i) that α < ϑk. In all other cases the assertion
follows directly from the induction hypothesis.
(iii) is easily shown by induction on Gβ making use of (ii).
Lemma 15.3. For all (meta) n,
Σ1
2-TRDC + BR ⊢ζ ∈W.
Proof. We use (meta) induction on n. For n = 0 this is a consequence of 12.2
and 11.21. If n = m + 1 then the induction hypothesis yields that ζm ∈W
is deducible in the theory and therefore, by 12.8, WO(ζm) holds. The segment
below ζm is then a primitive recursive provable well-ordering, thus an application
of BR yields Φζm0 = ϑn ∈W. Consequently, using 15.2 and 11.21, we have the
derivability of ψ0ϑn = ζn ∈W.
Lemma 15.4. For all (meta) n,
Σ1
2-TRDC + BR(impl-Σ1
2) ⊢ρn ∈W
where ρ0 := Φ00 and ρm+1 := Φρm0.
Proof. We use (meta) induction on n. Let’s denote the above theory by T. The
case n = 0 follows from 12.2. Let n = m + 1. The induction hypothesis yields
T ⊢ρm ∈W. Owing to 11.11, provably in T there exists a distinguished set Q
such that ρm ∈Q and Q = Q ∩ρ+
m. With the formula F[U] standing for
∃P [Ds(P) ∧ρm ∈P ∧U = {⟨α, β⟩| α, β ∈P ∧α < β ∧β < ρ+
m}]
it thus holds that
T ⊢∃!X(WO(X) ∧F[X]).
Let G(ξ) := (∀α ∈W) Φξα ∈W and τ := ρ+
m. Since F[U] is (provably in T)
equivalent to a Σ1
2 formula, via an application of BR(impl-Σ1
2) to (15.1), T proves
transﬁnite induction on W ∩τ. In particular T proves Ds(Q) ∧ρm ∈Q and
(∀η ∈Q ∩τ)[Q ∩η ⊆G →G(η)] →(∀η ∈Q ∩τ)G(η).
In conjunction with the induction hypothesis and 14.1, we infer from (15.1) that
T ⊢ρn ∈W.

434
Michael Rathjen
Theorem 15.5.
(i) ψ0(ΦΩ10) ≤|Σ1
2-TRDC + BR|.
(ii) ψ0ΓΦ
0 ≤|Σ1
2-TRDC + BR(impl-Σ1
2)|, where ψ0ΓΦ
0 := OT(Φ) ∩Ω1.
Proof. (i) follows from 15.3, 15.2(iii), and 12.8. (ii) follows from 15.4, 11.21,
12.8 and 9.8.
16 Prospectus
The lower bounds for the proof-theoretic ordinals of theories considered in this
article turn out to be sharp. Proofs of upper bounds, though, will only appear in the
second part of this paper which is devoted to ordinal analysis. We will ﬁnish this
paper by listing all theories and their proof-theoretic ordinals.
(i) |ID≺∗| ≤|ID∗+ (BI)| ≤|KPl∗| ≤ψ0ε(Φ0Ω1)+1.
(ii) |Π1
1-TR0| = |AUT-IDpos
0
| = |AUT-IDmon
0
| = |Π1
1-TR0 + Δ1
2-CA0| =
|AUT-KPlr| = |AUT-KPlr +KPir| = |KPiw +FOUNDR(impl-Σ)| =
|KPiw + FOUND(impl-Σ)| = |Δ1
2-CA + BI(impl-Σ1
2)| =
|Δ1
2-CA + BR(impl-Σ1
2)| = ψ0(Φ10).
(iii) |Π1
1-TR| = |AUT-IDpos| = |AUT-IDmon| = |AUT-KPlw| =
ψ0((Φ10) · ε0).
(iv) |Π1
1-TR + (BI)| = |AUT-IDpos
2
| = |AUT-IDmon
2
| =
|AUT-KPl| = ψ0ε(Φ10)+1.
(v) |Π1
1-TR + Δ1
2-CA| = |Π1
1-TR + Σ1
2-AC| = |AUT-KPlw + KPiw| =
ψ0(Φ1ε0).
(vi) |Δ1
2-TR0| = |Σ1
2-TRDC0| = |Δ1
2-CA0 + (Σ1
2-BI)| =
|KPir + (Σ-FOUND)| = |KPir + (Σ-REC)| = ψ0(Φω0).
(vii) |Δ1
2-TR| = |Σ1
2-TRDC| = |Δ1
2-CA + (Σ1
2-BI)| =
|KPiw + (Σ-FOUND)| = |KPiw + (Σ-REC)| = ψ0(Φε00).
(viii) |Δ1
2-TR + BR(impl-Σ1
2)| = |Δ1
2-TR + BI(impl-Σ1
2)| =
|Σ1
2-TRDC + BR(impl-Σ1
2)| = |Σ1
2-TRDC + BI(impl-Σ1
2)| =
|KPiw + (Σ-REC) + FOUNDR(impl-Σ)| =
|KPiw + (Σ-REC) + FOUND(impl-Σ)| = ψ0ΓΦ
0 .

Investigations of Subsystems of Second Order Arithmetic and Set Theory
435
(ix) |Δ1
2-TR + BR| = |Σ1
2-TRDC + BR| =
|KPiw + (Σ-REC) + FOUNDR(impl-Σ(M))| = ψ0(ΦΩ10).
(x) |Π1
1-TR + BR| = |AUT-KPlw + FOUNDR(impl-Σ(M))| =
ψ0((Φ10) · Ω1).
(xi) |Π1
1-TR + BR(impl-Σ1
2)| =
|AUT-KPlw + FOUNDR(impl-Σ)| = ψ0ω(Φ10)+(Φ10).
(xii) |Π1
1-TR + Δ1
2-CA + BR| =
|AUT-KPlw + KPiw + FOUNDR(impl-Σ(M))| = ψ0(Φ1Ω1).
(xiii) |Π1
1-TR + Δ1
2-CA + BR(impl-Σ1
2)| =
|AUT-KPlw + KPiw + FOUNDR(impl-Σ)| = ψ0(Φ20).
References
[1] P. Aczel: The Type Theoretic Interpretation of Constructive Set Theory: Inductive Def-
initions, in: Marcus, R. B. et al. (eds), Logic, Methodology, and Philosopy of Science
VII (North–Holland, Amsterdam, 1986).
[2] P. Aczel,
M. Rathjen:
Notes on constructive set theory,
Technical Report
40, Institut Mittag-Lefﬂer (The Royal Swedish Academy of Sciences, 2001).
http://www.ml.kva.se/preprints/archive2000-2001.php
[3] J. Barwise: Admissible Sets and Structures (Springer, Berlin 1975).
[4] W. Buchholz: Normalfunktionen und konstructive Systeme von Ordinalzahlen, in: Lec-
ture Notes in Mathematics 500 (Springer, Berlin, 1975).
[5] W. Buchholz: Eine Erweiterung der Schnitteliminationsmethode, Habilitationsschrift
(M¨unchen 1977).
[6] W. Buchholz, W. Pohlers: Provable wellorderings of formal theories for transﬁnitely
iterated inductive deﬁnitions, Journal of Symbolic Logic 43 (1978) 118–125.
[7] W. Buchholz: Ordinal analysis of IDν, in [10] (Springer, Berlin, 1981) 234–260.
[8] W. Buchholz: A new system of proof–theoretic ordinal functions, Ann. Pure Appl.
Logic 32 (1986) 195–207.
[9] W. Buchholz, K. Sch¨utte: Proof theory of impredicative subsystems of analysis (Bib-
liopolis, Naples, 1988).
[10] W. Buchholz, S. Feferman, W. Pohlers, W. Sieg: Iterated inductive deﬁnitions and
subsystems of analysis (Springer, Berlin, 1981).

436
Michael Rathjen
[11] W. Buchholz and K. Sch¨utte: Proof theory of impredicative subsystems of analysis
(Bibliopolis, Naples, 1988).
[12] F.R. Drake: How recent work in mathematical logic relates to the foundations of math-
ematics, The Mathematical Intelligencer vol. 7, no. 4 (1985) 27–35.
[13] S. Feferman: Systems of predicative analysis, Journal of Symbolic Logic 29 (1964)
1–30.
[14] S. Feferman: Systems of predicative analysis II. Representations of ordinals, Journal
of Symbolic Logic 33 (1968) 193–220.
[15] S. Feferman: Formal theories for transﬁnite iterations of generalized inductive deﬁni-
tions and some subsystems of analysis, in: J. Myhill, A. Kino, R.F. Vesley (eds.): Proof
theory and Intuitionism (North Holland, Amsterdam, 1970) 303–326.
[16] S. Feferman: A Language and Axioms for Explicit Mathematics, Lecture Notes in
Math. 450 (Springer, Berlin, 1975), 87–139.
[17] S. Feferman: Theories of ﬁnite type related to mathematical practice, in: J. Barwise
(ed.): Handbook of Mathematical Logic (North Holland, Amsterdam 1977) 913–971.
[18] S. Feferman, W. Sieg: Iterated inductive deﬁnitions and subsystems of analysis, in:
W. Buchholz, S. Feferman, W. Pohlers, W. Sieg: Iterated inductive deﬁnitions and
subsystems of analysis (Springer, Berlin, 1981) 16–77.
[19] H. Friedman: Iterated inductive deﬁnitions and Σ1
2-AC, in: J. Myhill, A. Kino, R.F.
Vesley (eds.): Proof theory and Intuitionism (North Holland, Amsterdam, 1970) 435–
442.
[20] H. Friedman, N. Robertson, P. Seymour: The metamathematics of the graph minor
theorem, Contemporary Mathematics 65 (1987) 229–261.
[21] R.O. Gandy: Proof of Mostowski’s conjecture, Bulletin of the Polish Academy of Sci-
ence 8 (1960) 265-299.
[22] G. Gentzen: Die Widerspruchsfreiheit der reinen Zahlentheorie. Mathematische An-
nalen 112 (1936) 493–565.
[23] D. Hilbert: Die Grundlegung der elementaren Zahlentheorie. Mathematische Annalen
104 (1931).
[24] D. Hilbert and P. Bernays: Grundlagen der Mathematik II. (Springer, Berlin, 1938).
[25] P.G. Hinman: Recursion-theoretic hierarchies. (Springer, Berlin, 1978).
[26] D. Isles: Regular ordinals and normal forms, in: A. Kino, J. Myhill, R.E. Vesley (eds.):
Intuitionism and proof theory (North-Holland, Amsterdam, 1968) 288–300.
[27] G. J¨ager: Die konstruktible Hierarchie als Hilfsmittel zur beweistheoretischen Unter-
suchung von Teilsystemen der Analysis. Dissertation, (Universit¨at M¨unchen, 1979).
[28] G. J¨ager: Beweistheorie von KPN, Archiv f. Math. Logik 2 (1980) 53–64.
[29] G. J¨ager: Zur Beweistheorie der Kripke–Platek Mengenlehre ¨uber den nat¨urlichen Zah-
len, Archiv f. Math. Logik 22 (1982) 121–139.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
437
[30] G. J¨ager: Iterating admissibility in proof theory, in: J. Stern (ed.): Proceedings of the
Herbrand Logic Colloquium ‘81, (North-Holland, Amsterdam, 1982) 137–146.
[31] G. J¨ager: A well-ordering proof for Feferman’s theory T0, Archiv f. Math. Logik 23
(1983) 65–77.
[32] J¨ager, G.: Theories for admissible sets: a unifying approach to proof theory (Bibliopo-
lis, Naples, 1986).
[33] G. J¨ager and W. Pohlers: Eine beweistheoretische Untersuchung von Δ1
2-CA+BI und
verwandter Systeme, Sitzungsberichte der Bayerischen Akademie der Wissenschaften,
Mathematisch–Naturwissenschaftliche Klasse (1982).
[34] S.C. Kleene: Arithmetical predicates and function quantiﬁers, Transactions of the
American Mathematical Society 79 (1955) 312–340.
[35] G. Kreisel: On the interpretation of non-ﬁnitist proofs II, Journal of Symbolic Logic
17 (1952) 43–58.
[36] G. Kreisel: Mathematical signiﬁcance of consistency proofs. Journal of Symbolic
Logic 23 (1958) 155–182.
[37] G. Kreisel: Generalized inductive deﬁnitions, in: Stanford Report on the Foundations
of Analysis (Mimeographed, Stanford, 1963) Section III.
[38] P. Martin-L¨of: Intuitionistic Type Theory, (Bibliopolis, Naples 1984).
[39] H. Pfeiffer: Ausgezeichnete Folgen f¨ur gewisse Abschnitte der zweiten und weiterer
Zahlklassen (Dissertation, Hannover, 1964).
[40] W. Pohlers: Cut elimination for impredicative inﬁnitary systems, part I: Ordinal anal-
ysis of ID1, Arch. f. Math. Logik 21 (1981) 69–87.
[41] W. Pohlers: Proof–theoretical analysis of IDν by the method of local predicativity,
in: W. Buchholz, S. Feferman, W. Pohlers, W. Sieg: Iterated inductive deﬁnitions and
subsystems of analysis (Springer, Berlin, 1981) 261–357.
[42] W. Pohlers: Cut elimination for impredicative inﬁnitary systems, part II: Ordinal anal-
ysis for iterated inductive deﬁnitions, Arch. f. Math. Logik 22 (1982) 113–129.
[43] M. Rathjen: Untersuchungen zu Teilsystemen der Zahlentheorie zweiter Stufe und der
Mengenlehre mit einer zwischen Δ1
2−CA und Δ1
2−CA+BI liegenden Beweisst¨arke,
PhD thesis, University of M¨unster, 1988.
[44] M. Rathjen: Ordinal notations based on a weakly Mahlo cardinal, Archive for Mathe-
matical Logic 29 (1990) 249–263.
[45] M. Rathjen: Proof-Theoretic Analysis of KPM, Arch. Math. Logic 30 (1991) 377–403.
[46] M. Rathjen: The role of parameters in bar rule and bar induction, Journal of Symbolic
Logic 56 (1991) 715–730.
[47] M. Rathjen: Fragments of Kripke-Platek set theory with inﬁnity, in: P. Aczel, H. Sim-
mons, S. Wainer (eds.): Proof Theory (Cambridge University Press, Cambridge, 1992)
251–273.

438
Michael Rathjen
[48] M. Rathjen: How to develop proof–theoretic ordinal functions on the basis of admissi-
ble sets. Mathematical Quarterly 39 (1993) 47–54.
[49] M. Rathjen and A. Weiermann: Proof–theoretic investigations on Kruskal’s theorem,
Annals of Pure and Applied Logic 60 (1993) 49–88.
[50] M. Rathjen: Admissible proof theory and beyond, in: Logic, Methodology and Philos-
ophy of Science IX (D. Prawitz, B. Skyrms and D. Westerstahl, eds.), Elsevier Science
B.V. (1994) 123–147.
[51] M. Rathjen: The strength of some Martin–L¨of type theories. Archive for Mathematical
Logic 33 (1994) 347–385.
[52] M. Rathjen: Collapsing functions based on recursively large ordinals: A well–ordering
proof for KPM. Archive for Mathematical Logic 33 (1994) 35–55.
[53] M. Rathjen: Proof theory of reﬂection. Annals of Pure and Applied Logic 68 (1994)
181–224.
[54] M. Rathjen: Recent advances in ordinal analysis: Π1
2-CA and related systems. Bulletin
of Symbolic Logic 1 (1995) 468–485.
[55] M. Rathjen: The higher inﬁnite in proof theory, in: J.A. Makowsky and E.V. Ravve
(eds.): Logic Colloquium ’95. Lecture Notes in Logic, vol. 11 (Springer, New York,
Berlin, 1998) 275–304.
[56] M. Rathjen: An ordinal analysis of stability. Archive for Mathematical Logic 44 (2005)
1 - 62.
[57] M. Rathjen: An ordinal analysis of parameter-free Π1
2 comprehension. Archive for
Mathematical Logic 44 (2005) 263 - 362.
[58] D. Schmidt: Well-partial orderings and their maximal order types, Habilitationsschrift
(Heidelberg, 1979) 77 pages.
[59] K. Sch¨utte: Beweistheoretische Erfassung der unendlichen Induktion in der Zahlenthe-
orie, Mathematische Annalen 122 (1951) 369–389.
[60] K. Sch¨utte: Beweistheorie (Springer, Berlin, 1960).
[61] K. Sch¨utte: Eine Grenze f¨ur die Beweisbarkeit der transﬁniten Induktion in der
verzweigten Typenlogik, Archiv f¨ur Mathematische Logik und Grundlagenforschung
67 (1964) 45–60.
[62] K. Sch¨utte: Predicative well-orderings, in: Crossley, Dummett (eds.), Formal systems
and recursive functions (North Holland, 1965) 176–184.
[63] K. Sch¨utte: Proof Theory (Springer, Berlin, 1977).
[64] H. Schwichtenberg: Proof theory: Some applications of cut-elimination. In: J. Barwise
(ed.): Handbook of Mathematical Logic (North Holland, Amsterdam, 1977) 867–895.
[65] J. Shoenﬁeld: Mathematical logic (Addison-Wesley, Reading Mass., 1967).
[66] S. Simpson:
Nichtbeweisbarkeit von gewissen kombinatorischen Eigenschaften
endlicher B¨aume, Archiv f. Math. Logik 25 (1985) 45–65.

Investigations of Subsystems of Second Order Arithmetic and Set Theory
439
[67] S.G. Simpson: Subsystems of Second Order Arithmetic (Springer-Verlag, Berlin, Hei-
delberg, 1999)
[68] G. Spector: Inductively deﬁned sets of numbers, in Inﬁnitistic methods, Proceedings
of the Warszaw Symposium (Pergamon Press, Oxford, 1961) 97–102.
[69] G. Takeuti: Consistency proofs of subsystems of classical analysis, Ann. Math. 86,
299–348.
[70] G. Takeuti, M. Yasugi: The ordinals of the systems of second order arithmetic with the
provably Δ1
2–comprehension and the Δ1
2–comprehension axiom respectively, Japan J.
Math. 41 (1973) 1–67.
[71] G. Takeuti: Proof theory, second edition (North Holland, Amsterdam, 1987).
[72] O. Veblen: Continuous increasing functions of ﬁnite and transﬁnite ordinals, Trans.
Amer. Math. Soc. 9 (1908) 280–292.
[73] A. Weiermann: Beweistheoretische Untersuchungen zur Theorie ID≺∗, (Diploma
Thesis, Universit¨at M¨unster, 1987).
[74] A. Weiermann: How to characterize provably total functions by local predicativity,
Journal of Symbolic Logic 61 (1996) 52–69.


Weak Theories of Operations and Types
Thomas Strahm
Institut f¨ur Informatik und angewandte Mathematik,
Universit¨at Bern,
Neubr¨uckstrasse 10, CH-3012 Bern, Switzerland
strahm@iam.unibe.ch
Abstract This is a survey paper on various weak systems of Feferman’s
explicit mathematics and their proof theory. The strength of the systems
considered in measured in terms of their provably terminating operations
typically belonging to some natural classes of computational time or space
complexity.
Keywords: Proof theory, Feferman’s explicit mathematics, applicative the-
ories, higher types, types and names, partial truth, feasible operations
1 Introduction
In this article we survey recent results about a proof-theoretic approach to compu-
tational complexity via theories of operations and types in the sense of Feferman’s
explicit mathematics. The latter framework was introduced by Feferman [19–21]
in the early 1970s. Beyond its original aim to provide a basis for Bishop-style con-
structivism, the explicit framework has gained considerable importance in proof
theory in connection with the proof-theoretic analysis of subsystems of second or-
der arithmetic and set theory as well as for studying the proof theory of abstract
computations.
It is this latter focus which is most important in the present article. The oper-
ational or applicative core of explicit mathematics includes forms of combinatory
logic and hence comprises a computationally complete functional language with
the full deﬁning power of the untyped lambda calculus. In this sense it is more
expressive than standard arithmetical systems.
Apart from operations or rules, the second basic entity in explicit mathematics
are types, which can be thought of as successively generated collections of opera-
tions. In addition, and this is essential in the explicit approach, extensional types

442
Thomas Strahm
are represented (or named) by intensional operations, uniformly in their parame-
ters. This interplay of operations and types on the level of representations makes
explicit mathematics extremely powerful.
As an alternative means of enhancing the ﬁrst order part of explicit mathematics,
we will also consider extensions of applicative theories by a partial truth predicate,
leading to an expressive language embodying naive set theory. In this connection,
we will review work done by Cantini.
Let us brieﬂy outline the content of the paper. We omit references and credits
and refer the reader to the corresponding sections of the paper.
We start off in Section 2 by introducing the ﬁrst order applicative framework
being based on the logic of partial terms. We deﬁne the basic theory of operations
and words B and introduce two bounded induction schemas on the binary words.
In Section 3 we provide a review of function algebra characterizations of com-
plexity classes and introduce four bounded applicative systems, PT, PTLS, PS, and
LS, whose provably total functions coincide with the functions computable in poly-
nomial time, simultaneously polynomial time and linear space, polynomial space,
and linear space. We brieﬂy address the lower and upper bound arguments for these
systems. In particular, we outline a speciﬁc combination of partial cut elimination
and a realizability interpretation.
Section 4 addresses higher type issues of the ﬁrst-order system PT. It is a dis-
tinguished advantage of applicative theories that they allow for a very intrinsic and
direct discussion of higher type aspects, since higher types arise naturally in the
untyped setting. It makes perfect sense to consider the class of higher type func-
tionals which are provably total in a given applicative system. We will discuss the
relationship between PT and the Melhorn-Cook-Urquhart basic feasible function-
als BFF.
In Section 5 we introduce a theory PET of polynomial time operations with ex-
plicit and variable types which is formulated in the full language of explicit math-
ematics and embodies a weak form of elementary type comprehension. The prov-
ably total operations of PET are still the polynomial time computable functions on
binary words. We will also consider various extensions of PET by choice, quan-
tiﬁcation, uniformity and join principles.
In Section 6 we review work by Cantini on extensions of weak applicative the-
ories by forms of self-referential truth with choice and uniformity, which has been
essential in obtaining results about corresponding extensions of the system PET.
Finally, in Section 7 we address self-applicative systems proposed by Cantini
and Calamai in the realm of so-called implicit computational complexity in the

Weak Theories of Operations and Types
443
sense of Bellantoni, Cook and Leivant. It turns out that forms of safe induction
formulated in a modal language provide very natural applicative characterizations
of the functions computable in polynomial time and polynomial space.
We conclude this article by some comments on the relationship between primi-
tive recursion and positive induction.
2 The axiomatic framework
In this section we ﬁrst describe the informal setting of applicative systems and
brieﬂy motivate their underlying logic of partial terms. Then we outline the ba-
sic applicative language and theory of operations and words and mention some of
its basic consequences and models. We conclude this section by specifying two
important induction principles.
2.1 The informal applicative setting
Let us assume that we are given an untyped universe of operations or rules, which
can be freely applied to each other. Self-application is meaningful, though not
necessarily total. The computational engine of these rules is given by a partial
combinatory algebra, featuring partial versions of Curry’s combinators k and s. In
addition, there is a ground “urelement” structure of the binary words or strings with
certain natural operations on them.
Let W denote the set of (ﬁnite) binary words. We will consider the following
operations on W:
• s0 and s1: binary successors on W with predecessor pW
• sℓ: (unary) lexicographic successor on W with predecessor pℓ
• ∗: word concatenation
• ×: word multiplication
Here sℓdenotes the successor in the ordering <ℓwhich orders words by length and
words of the same length lexicographically. Moreover, x×y signiﬁes the length of
y fold concatenation of x with itself.

444
Thomas Strahm
2.2 The logic of partial terms
All our theories considered in this survey are based on the classical logic of partial
terms (LPT) due to Beeson and Feferman. It is is a modiﬁcation of ﬁrst-order
predicate logic taking into account partial functions, cf. Beeson [1,2] and Troelstra
and van Dalen [52] for details. It is assumed that variables range over deﬁned
objects only. (Composed) terms do not necessarily denote and t↓signiﬁes that t has
a value or t denotes. The usual quantiﬁer axioms of predicate logic are modiﬁed,
e.g. we have
A(t) ∧t↓→(∃x)A(x)
Moreover, strictness axioms claim that subterms of a deﬁned term are deﬁned and
that terms occurring in true positive atoms are deﬁned.
For an excellent survey of logics of deﬁnedness the reader is referred to Feferman
[22]. Feferman distinguishes between logics of existence and logics of partial terms
in the above-explained sense, whereas the former were pioneered by Scott [41].
On the other hand, the pseudo-applicative terms used in Feferman [19,21] may be
considered as precursors to the logic of partial terms.
2.3 The basic applicative language
Our basic language L is a ﬁrst order language for the logic of partial terms which
includes:
• variables a, b, c, x, y, z, u, v, f, g, h, . . .
• constants k, s, p, p0, p1, dW, ϵ, s0, s1, pW, sℓ, pℓ, c⊆, lW, ...
• relation symbols = (equality), ↓(deﬁnedness), W (binary words)
• arbitrary term application ◦
The meaning of the constants will become clear in the next paragraph.
The terms (r, s, t, . . . ) and formulas (A, B, C, . . . ) of L are deﬁned in the ex-
pected manner. We assume the following standard abbreviations and syntactical
conventions:
t1t2 . . . tn := (. . . (t1 ◦t2) ◦· · · ◦tn)
t1 ≃t2 := t1↓∨t2↓→t1 = t2
t ∈W := W(t)
t : Wk →W := (∀x1 . . . xk ∈W)tx1 . . . xk ∈W

Weak Theories of Operations and Types
445
t : WW × W →W := (∀f ∈W →W)(∀x ∈W)tfx ∈W
Finally, let us write w for the canonical closed L term denoting the binary word
w ∈W.
2.4 The basic theory of operations and words B
The applicative base theory B has been introduced in Strahm [47, 48]. Its logic is
the classical logic of partial terms. The non-logical axioms of B include:
• partial combinatory algebra:
kxy = x,
sxy↓∧sxyz ≃xz(yz)
• pairing p with projections p0 and p1
• deﬁning axioms for the binary words W with ϵ, the successors s0, s1, sℓan the
predecessor pW and and pℓ
• deﬁnition by cases dW on W
• initial subword relation c⊆, tally length of words lW
These axioms are fully spelled out in [47, 48]. The term (t1, t2, . . . , tn) for n-
tupling is deﬁned as usual by iterating the pairing operation p.
Let us turn to the crucial consequences of the axioms about a partial combinatory
algebra. For proofs of these standard results, the reader is referred to Beeson [1] or
Feferman [19].
Lemma 2.1 (Explicit deﬁnitions and ﬁxed points).
1. For each L term t there exists an L term (λx.t) so that
B
(λx.t)↓∧(λx.t)x ≃t
2. There is a closed L term ﬁx so that
B
ﬁxg↓∧ﬁxgx ≃g(ﬁxg)x
Let us quickly remind the reader of two standard models of B, namely the
recursion-theoretic model PRO and the term model M(λη). For an extensive
discussion of many more models of the applicative basis, the reader is referred to
Beeson [1] and Troelstra and van Dalen [53].

446
Thomas Strahm
Example 2.2 (Recursion-theoretic model PRO).
Take the universe of binary
words and interpret application ◦as partial recursive function application in the
sense of ordinary recursion theory.
Example 2.3 (The open term model M(λη)). Take the universe of open λ terms
and consider the usual reduction of the extensional untyped lambda calculus λη,
augmented by suitable reduction rules for the constants other than k and s. Interpret
application as juxtaposition. Two terms are equal if they have a common reduct and
W denotes those terms that reduce to a “standard” word w.
2.5 Natural induction principles
We have not yet speciﬁed induction principles on the binary words W; these are
of course crucial for our proof-theoretic characterizations of complexity classes
below.
We call an L formula positive if it is built from the atomic formulas by means
of disjunction, conjunction as well as existential and universal quantiﬁcation over
individuals. We let Pos stand for the collection of positive formulas. Further, an L
formula is called W free, if the relation symbol W does not occur in it.
Most important in the sequel are the so-called bounded (with respect to W) ex-
istential formulas or Σb
W formulas of L. A formula A(f, x) belongs to the class
Σb
W if it has the form (∃y ≤fx)B(f, x, y) for B(f, x, y) a positive and W free
formula. It is important to note here that bounded quantiﬁers range over W, i.e.,
(∃y ≤fx)B(f, x, y) stands for
(∃y ∈W)[y ≤fx ∧B(f, x, y)].
Further observe that the matrix B of a Σb
W formula can have unrestricted existential
and universal individual quantiﬁers, not ranging over W, however.
Below we will distinguish usual notation induction on binary words and the cor-
responding “slow” induction principle with respect to the lexicographic successor
sℓ.
Σb
W notation induction on W:
For each Σb
W formula A(x) ≡(∃y ≤fx)B(f, x, y),
f : W →W ∧A(ϵ) ∧(∀x ∈W)(A(x) →A(s0x) ∧A(s1x))
→(∀x ∈W)A(x)
(Σb
W-IW)

Weak Theories of Operations and Types
447
Σb
W lexicographic induction on W:
For each Σb
W formula A(x) ≡(∃y ≤fx)B(f, x, y),
f : W →W ∧A(ϵ) ∧(∀x ∈W)(A(x) →A(sℓx))
→(∀x ∈W)A(x)
(Σb
W-Iℓ)
It is now easy, by making use of the ﬁxed point theorem and Σb
W notation induction
on W, to show the existence of a type two functional for bounded recursion on
notation, provably in B + (Σb
W-IW). This is the content of the following lemma
whose detailed proof can be found in Strahm [48].
Lemma 2.4 (Bounded recursion on notation). There exists a closed L
term rW so that B + (Σb
W-IW) proves
f : W →W ∧g : W3 →W ∧b : W2 →W
→
⎧
⎪
⎨
⎪
⎩
rWfgb : W2 →W ∧
x ∈W ∧y ∈W ∧y ̸= ϵ ∧h = rWfgb →
hxϵ = fx ∧hxy = gxy(hx(pWy)) | bxy
Here t | s is t if t ≤s and s otherwise.
Similarly, bounded lexicographic recursion is derivable in B + (Σb
W-Iℓ), see
Strahm [48] for details.
3 Characterizing complexity classes
We now turn to the characterization of complexity classes by means of our ap-
plicative systems. We start our discussion by reviewing some function algebra
characterizations of complexity classes and then propose four applicative systems,
PT, PTLS, PS, and LS, whose provably total functions coincide with the functions
computable in polynomial time, simultaneously polynomial time and linear space,
polynomial space, and linear space. We sketch lower and upper bounds for these
proof-theoretic characterizations.
3.1 Four function algebras
In this subsection we review know recursion-theoretic characterizations of various
classes of computational complexity. Our main interest in the sequel are the func-
tions on W which are computable on a Turing machine in polynomial time, simul-
taneously polynomial time and linear space, polynomial space, and linear space.

448
Thomas Strahm
In the following we let FPTIME, FPTIMELINSPACE, FPSPACE, and FLINSPACE
denote the respective classes of functions on binary words W. For an extensive dis-
cussion of recursion-theoretic or function algebra characterizations of complexity
classes the reader is referred to the survey article Clote [15].
In the following we use the notation of Clote [15] for a compact representation
of function algebras. Accordingly, we call (partial) mappings from functions on
W to functions on W operators. If X is a set of functions on W and OP is a
collection of operators, then [X; OP] is used to denote the smallest set of functions
containing X and closed under the operators in OP. We call [X; OP] a function
algebra. Our crucial examples of operators in the sequel are bounded recursion
on notation BRN and bounded lexicographic recursion BRL, cf. Strahm [48] for
details. A further operator is the composition operator COMP. Below we also use
I for the usual collection of projection functions and we simply write ϵ for the 0-ary
function being constant to the empty word ϵ.
We are now ready to state the function algebra characterizations of the four com-
plexity classes which are relevant in this paper. The characterization of FPTIME
is due to Cobham [16].
The delineations of FPTIMELINSPACE and FPSPACE
are due to Thompson [51]. Finally, the fourth assertion of our theorem is due to
Ritchie [38]. For a uniform presentation of all these results we urge the reader to
consult Clote [15].
Theorem 3.1. We have the following function algebra characterizations of the
complexity classes mentioned above:
1. [ϵ, I, s0, s1, ∗, ×; COMP, BRN] = FPTIME.
2. [ϵ, I, s0, s1, ∗; COMP, BRN] = FPTIMELINSPACE.
3. [ϵ, I, sℓ, ∗, ×; COMP, BRL] = FPSPACE.
4. [ϵ, I, sℓ, ∗; COMP, BRL] = FLINSPACE.
We now turn to the proof-theoretic characterization of the above four complexity
classes by means of suitable applicative theories.
3.2 Provably total functions
Let us ﬁrst start with a formal deﬁnition of the notion of provably total function of
a given L theory.
Deﬁnition 3.2. A function F : Wn →W is called provably total in an L theory T,
if there exists a closed L term tF such that

Weak Theories of Operations and Types
449
(i) T
tF : Wn →W and, in addition,
(ii) T
tF w1 · · · wn = F(w1, . . . , wn) for all w1, . . . , wn in W.
The notion of a provably total word function is divided into two conditions (i)
and (ii). The ﬁrst condition (i) expresses that tF is a total operation from Wn to W,
provably in the L theory T. Condition (ii), on the other hand, claims that tF indeed
represents the given function F : Wn →W, for each ﬁxed word w in W.
In the sequel, let τ(T) = {F : F provably total in T}.
3.3 Four applicative systems
In the following we write B(∗) for the extension of B by the obvious axioms about
word concatenation on W, namely the standard recursive deﬁning equations and
the totality of ∗on W. We assume that ∗is a new constant of our applicative
language L. Similarly, B(∗, ×) extends B(∗) by the standard axioms about word
multiplication. For details, see Strahm [48].
Depending on whether we include (Σb
W-IW) or (Σb
W-Iℓ), and whether we assume
as given only word concatenation or both word concatenation and word multipli-
cation, we can now distinguish the following four applicative theories PT, PTLS,
PS, and LS:
PT := B(∗, ×) + (Σb
W-IW)
PTLS := B(∗) + (Σb
W-IW)
PS := B(∗, ×) + (Σb
W-Iℓ)
LS := B(∗) + (Σb
W-Iℓ)
We note that a preliminary, more restrictive version of the system PT has previously
been studied in Strahm [46] and Cantini [12].
In the sequel let us brieﬂy sketch the lower and upper bound arguments for our
applicative systems, which are worked out in full detail in Strahm [48].
3.4 Lower bounds
The lower bounds for our four applicative systems directly follow from Theorem
3.1 and the crucial Lemma 2.4, respectively its variant for bounded lexicographic
recursion.
Theorem 3.3. We have the following lower bounds:
1. FPTIME ⊆τ(PT).

450
Thomas Strahm
2. FPTIMELINSPACE ⊆τ(PTLS).
3. FPSPACE ⊆τ(PS).
4. FLINSPACE ⊆τ(LS).
Let us close this paragraph with the following remarks:
Remarks 3.4.
1. Ferreira’s system PTCA+ ( [24], [25]) is directly contained in
PT, where PTCA+ corresponds to Buss’ S1
2 ( [5]).
2. The Melhorn-Cook-Urquhart basic feasible functionals resp. the system PVω
( [18]) are directly contained in PT (see Section 4).
3.5 Partial cut elimination
In order to extract computational content from proofs, we need a sequent-style
reformulation of our systems and a preparatory partial cut-elimination result. It is
employed in order to show that as far as the computational content of our systems
is concerned, we can restrict ourselves to positive derivations, i.e., sequent style
proofs using positive formulas only. Moreover, we will establish upper bounds
directly for an extension of our systems by the axioms of totality of application and
extensionality of operations:
Totality of application:
(∀x)(∀y)(xy↓)
(Tot)
Extensionality of operations:
(∀f)(∀g)[(∀x)(fx ≃gx) →f = g]
(Ext)
Observe that in the presence of the totality axiom, the logic of partial terms reduces
to ordinary classical predicate logic. Accordingly, if T denotes one of the systems
PT, PTLS, PS, or LS, then we write T+ for the system T based on ordinary classi-
cal logic with equality and augmented with the axiom of extensionality.
In the following we let Γ, Δ, Λ, . . . range over ﬁnite sequences of formulas; a
sequent is a formal expression of the form Γ ⇒Δ. As usual, the natural inter-
pretation of the sequent A1, . . . , An ⇒B1, . . . , Bm is (A1 ∧· · · ∧An) →
(B1 ∨· · · ∨Bm).
It is now a matter of routine to spell out a sequent-style version of our four ap-
plicative systems so that all the main formulas of axioms and rules are positive.
Hence, partial cut-elimination is applicable in order to show that cuts can be re-
stricted to positive formulas. In the following we write T+
⋆Γ ⇒Δ to express
that Γ ⇒Δ has a proof in T+ where all cut formulas are positive.

Weak Theories of Operations and Types
451
3.6 Realizability
In a second crucial step we use a notion of realizability for positive formulas in
the standard open term model of our systems: quasi cut-free positive sequent
derivations of PT, PTLS, PS, and LS are suitably realized by word functions
in FPTIME, FPTIMELINSPACE, FPSPACE, and FLINSPACE, respectively, thus
yielding the desired computational information concerning the provably total
functions of these systems.
The notion of realizability as well as the style and spirit of our realizability
theorems are related to the work of Leivant [31], Schl¨uter [40], and Cantini [13],
all three in the context of FPTIME. However, in contrast to these papers, we work
in a bounded unramiﬁed setting. Moreover, and this is similar to [13, 40], we are
able to realize directly quasi cut-free positive derivations in the classical sequent
calculus. Finally, in order to ﬁnd our realizing functions, we can make direct use of
the function algebra characterizations of FPTIME, FPTIMELINSPACE, FPSPACE,
and FLINSPACE given in Theorem 3.1; hence, direct reference to a machine model
is not needed.
In fact, the above mentioned literature on realizability in an applicative context,
especially in the classical setting, is clearly related to and inspired by older work
on witnessing that has been used in classical fragments of arithmetic. In particular,
Buss’ witnessing technique (cf. Buss [5–7]) has been employed with great success
in a variety of contexts.
We are now ready to turn to realizability. Our realizers ρ, σ, τ, . . . are simply
elements of the set W of binary words.
We presuppose a low-level pairing
operation ⟨·, ·⟩on W with associated projections (·)0 and (·)1; for deﬁniteness, we
assume that ⟨·, ·⟩, (·)0, and (·)1 are in FPTIMELINSPACE. Further, for each natural
number i let us write i2 for the binary notation of i.
Since we are only interested in realizing positive derivations, we need to deﬁne
realizability for positive formulas only.

452
Thomas Strahm
Deﬁnition 3.5. The notion ρ r A (“ρ realizes A”) for ρ ∈W and A a positive
formula, is given inductively in the following manner:
ρ r W(t)
if
M(λη) ⊨t = ρ,
ρ r (t1 = t2)
if
ρ = ϵ and M(λη) ⊨t1 = t2,
ρ r (A ∧B)
if
ρ = ⟨ρ0, ρ1⟩and ρ0 r A and ρ1 r B,
ρ r (A ∨B)
if
ρ = ⟨i, ρ0⟩and either i = 0 and ρ0 r A or
i = 1 and ρ0 r B,
ρ r (∀x)A(x)
if
ρ r A(u) for a fresh variable u,
ρ r (∃x)A(x)
if
ρ r A(t) for some term t.
If Δ denotes a sequence A1, . . . , An, then ρ r Δ iff ρ = ⟨i2, ρ0⟩for some 1 ≤i ≤n
and ρ0 r Ai.
The next main lemma about the realizability of quasi-normal PT+ derivations
immediately entails that the provably total functions of PT+ are computable in
polynomial time. The lemma is proved in all detail in Strahm [48].
In the formulation of the lemma, we need the following notation. For an L
formula A we write A[⃗u] in order to express that all the free variables occurring in
A are contained in the list ⃗u. The analogous convention is used for ﬁnite sequences
of L formulas.
Lemma 3.6 (Realizability for PT+). Let Γ ⇒Δ be a sequent of formulas in
Pos with Γ = A1, . . . , An and assume that PT+
⋆Γ[⃗u] ⇒Δ[⃗u]. Then there
exists a function F : Wn →W in FPTIME so that we have for all terms ⃗s and all
ρ1, . . . , ρn ∈W:
For all 1 ≤i ≤n : ρi r Ai[⃗s]
=⇒
F(ρ1, . . . , ρn) r Δ[⃗s].
Analogous realizability results hold for the systems PTLS, PS, and LS, cf. [48]
for details.
3.7 The main theorem concluded
We are now able to piece together the results of Sections 3.4, 3.5 and 3.6 and obtain
the following main theorem.
Theorem 3.7. We have the following characterizations:
1. τ(PT) = FPTIME.

Weak Theories of Operations and Types
453
2. τ(PTLS) = FPTIMELINSPACE.
3. τ(PS) = FPSPACE.
4. τ(LS) = FLINSPACE.
In the next section we turn to some higher types aspects of the system PT.
4 Higher type issues
In the last two decades intense research efforts have been made in the area of
so-called higher type complexity theory and, in particular, feasible functionals of
higher types. This research is still ongoing and it is not yet clear what the right
higher type analogue of the polynomial time computable functions is. Most promi-
nent in the previous research is the class of so-called basic feasible functionals
BFF, which has proved to be a very robust class with various kinds of interesting
characterizations.
The basic feasible functionals of type 2, BFF2, were ﬁrst studied in Melhorn [34].
More than ten years later in 1989, Cook and Urquhart [18] introduced the basic fea-
sible functionals at all ﬁnite types in order to provide functional interpretations of
feasibly constructive arithmetic; in particular, they deﬁned a typed formal system
PVω and used it to establish functional and realizability interpretations of an intu-
itionistic version of Buss’ theory S1
2. The basic feasible functionals BFF are exactly
those functionals which can be deﬁned by PVω terms. Subsequently, much work
has been devoted to BFF, cf. e.g. Cook and Kapron [17, 30], Irwin, Kapron and
Royer [27], Pezzoli [37], Royer [39], and Seth [42].
In the following let us brieﬂy discuss the relationship of PVω with our ﬁrst-order
applicative theory PT.
4.1 Higher types in the language L
The collection T of ﬁnite type symbols (α, β, γ, . . .) is inductively generated by the
usual clauses, (i) 0 ∈T , (ii) if α, β ∈T , then (α × β) ∈T , and (iii) if α, β ∈T ,
then (α →β) ∈T . Hence, we have product and function types as usual. Observe,
however, that in our setting the ground type 0 stands for the set of binary words
and not for the set of natural numbers. We use the usual convention and write
α1 →α2 →· · · →αk instead of (α1 →(α2 →· · · →(αk−1 →αk) · · · )).

454
Thomas Strahm
The abstract intensional type structure ⟨(ITα, =)⟩α∈T in the applicative lan-
guage L is now given by inductively deﬁning the formula ITα as follows:
x ∈IT0
:=
x ∈W,
x ∈ITα×β
:=
p0x ∈ITα ∧p1x ∈ITβ ∧p(p0x)(p1x) = x,
x ∈ITα→β
:=
(∀y ∈ITα)(xy ∈ITβ).
Equality in ITα is simply the restriction of equality in PT. Alternatively, one can
consider an extensional type structure, cf. [48,53].
4.2 The system PVω
PVω is a typed formal system whose terms denote exactly the basic feasible func-
tionals. PVω includes:
• the simply typed lambda calculus over the base type of binary words
• basic operations on words, essentially the base operations of PT
• a type two functional for bounded recursion on notation
• notation induction on binary words for Σb
1 or NP formulas
For an exact deﬁnition, cf. e.g. Strahm [48]. We observe that due to Lemma 2.4, we
indeed have a type two functional for bounded recursion on notation which has the
correct type, provably in PT. Using the intensional type structure ⟨(ITα, =)⟩α∈T
sketched above, it is then a matter of routine to check that PVω can be directly
interpreted in PT. This shows that the basic feasible functionals in all ﬁnite types
are provably total in PT.
The question arises whether indeed the BFFs are exactly the provably total func-
tionals of PT. This question has been answered in the positive for the type two
BFFs in Strahm [49] by using an extension of the realizability argument sketched
above. Moreover, it follows from the work in Cantini [14] that this result holds
with respect to arbitrary ﬁnite types if one considers an intuitionistic version of
PT. Therefore we can summarize:
Theorem 4.1.
1. The system PVω is contained in PT; i.e., the basic feasible
functionals in all ﬁnite types are provably total in PT.
2. The provably total type 2 functionals of PT coincide exactly with the basic
feasible functionals of type 2.

Weak Theories of Operations and Types
455
Let us conclude this section with the following conjecture.
Conjecture 4.2. The classical theory PT characterizes the basic feasible function-
als in all ﬁnite types.
5 Adding types and names
In this section, we will describe PET, a theory of polynomial time operations
with explicit types. The theory PET is an extension of the applicative base theory
B(∗, ×) by means of a natural restriction of elementary comprehension, which is
one of the crucial principles of explicit mathematics, see Feferman [19,21]. Below
we will use the language of explicit mathematics due to J¨ager [28] which is based
on a so-called naming relation ℜ. The type existence axioms are naturally pre-
sented by means of a ﬁnite axiomatisation in the spirit of Feferman and J¨ager [23].
The theory PET has been introduced in Spescha and Strahm [45].
5.1 The informal setting of types and names
Types in explicit mathematics are collections of operations and must be thought of
as being generated successively from preceding ones. In contrast to the restricted
character of operations, types can have quite complicated deﬁning properties. What
is essential in the whole explicit mathematics approach, however, is the fact that
types are again represented by operations or, as we will call them in this case,
names. Thus each type U is named or represented by a name u; in general, U may
have many different names or representations. It is exactly this interplay between
operations and types on the level of names which makes explicit mathematics ex-
tremely powerful and, in fact, witnesses its explicit character.
Types are extensional and have (explicit) names which are intensional. The
names are generated via uniform operations and the link to the types they are re-
ferring to is established by the naming relation ℜ. The element relation ∈is also a
relation between an individual and a type, expressing that the individual is a mem-
ber of the type. The formalization of explicit mathematics using a naming relation
ℜis due to J¨ager [28].
5.2 The language of types and names
The language L is a two-sorted language extending L by
• type variables U, V, W, X, Y, Z, . . .

456
Thomas Strahm
• binary relation symbols ℜ(naming) and ∈(elementhood)
• new (individual) constants w (initial segment of W), id (identity), dom (do-
main), un (union), int (intersection), and inv (inverse image)
The formulas (A, B, C, . . .) of L are built from the atomic formulas of L as well as
formulas of the form
(s ∈X),
ℜ(s, X),
(X = Y )
by closing under the boolean connectives and quantiﬁcation in both sorts. The
formula ℜ(s, X) reads as “the individual s is a name of (or represents) the type
X”.
We use the following abbreviations:
ℜ(s) := (∃X)ℜ(s, X),
s ˙∈t := (∃X)(ℜ(t, X) ∧s ∈X).
5.3 The theory PET
The following axioms state that each type has a name, that there are no homonyms
and that equality of types is extensional.
Ontological axioms:
(∃x)ℜ(x, X)
(O1)
ℜ(a, X) ∧ℜ(a, Y ) →X = Y
(O2)
(∀z)(z ∈X ↔z ∈Y ) →X = Y
(O3)
In the sequel we let Wa(x) stand for W(x) ∧x ≤a. The following axioms
provide a ﬁnite axiomatization of a restricted form of the schema of elementary
comprehension.
Type existence axioms:
a ∈W →ℜ(w(a)) ∧(∀x)(x ˙∈w(a) ↔Wa(x))
(wa)
ℜ(id) ∧(∀x)(x ˙∈id ↔(∃y)(x = (y, y)))
(id)
ℜ(a) →ℜ(inv(f, a)) ∧(∀x)(x ˙∈inv(f, a) ↔fx ˙∈a)
(inv)
ℜ(a) ∧ℜ(b) →ℜ(un(a, b)) ∧(∀x)(x ˙∈un(a, b) ↔(x ˙∈a ∨x ˙∈b))
(un)

Weak Theories of Operations and Types
457
ℜ(a) ∧ℜ(b) →ℜ(int(a, b)) ∧(∀x)(x ˙∈int(a, b) ↔(x ˙∈a ∧x ˙∈b)) (int)
ℜ(a) →ℜ(dom(a)) ∧(∀x)(x ˙∈dom(a) ↔(∃y)((x, y) ˙∈a))
(dm)
In contrast to the usual formulation of elementary comprehension in explicit math-
ematics (cf. e.g. Feferman and J¨ager [23]), we do not claim that the collection
of binary words forms a type, but merely that for each word a, the collection
{x ∈W : x ≤a} forms a type, uniformly in a. In addition, there are no comple-
ment types. The remaining type existence axioms are identical to the ones in [23].
Finally, the principle of type induction along W reads in the expected manner.
Type induction on W:
ϵ ∈X ∧(∀x ∈W)(x ∈X →s0x ∈X ∧s1x ∈X) →(∀x ∈W)(x ∈X)
The theory PET is deﬁned to be the extension of the ﬁrst-order applicative theory
B(∗, ×) by
• the ontological axioms
• the above type existence axioms
• type induction on W
In Spescha and Strahm [45] it is shown that the ﬁnite axiomatisation of type exis-
tence in PET gives rise to a natural restriction of the well-known schema of ele-
mentary comprehension in explicit mathematics.
5.4 The proof-theoretic strength of PET
Let PT−be PT without universal quantiﬁers in induction formulas. Clearly, PT−
proves the totality of the polynomial time computable functions, since it is strong
enough to represent bounded recursion on notation in the form of a type two func-
tional (cf. Lemma 2.4). Indeed, PET is a conservative extension of PT−as is
shown in Spescha and Strahm [45].
Theorem 5.1. We have the following proof-theoretic results:
1. PET is a conservative extension of PT−.
2. τ(PT−) = FPTIME.

458
Thomas Strahm
The lower bound uses a rather involved embedding of PT−into PET. The in-
terpretation uses a bootstrapping functional mapping each operation f on W to an
operation f∗such that f ∗x = max
y⊆x fy.
For the proof of the upper bound one starts off from a model of PT−and extends
it to a model of PET satisfying the same ﬁrst order sentences. The construction is
carried out in stages by deﬁning the set of names and their extensions successively.
Then one can show that the so-obtained model enjoys type induction.
For full details of these arguments, see Spescha and Strahm [45].
5.5 Extensions of PET
In addition to the principles (Tot) and (Ext) discussed above, Cantini [14] has
considered a form of positive choice in the context of PT with a partial truth
predicate (cf. Section 6) and shows that this principle does not increase the proof-
theoretic strength. Cantini’s result can be used to show that the following form of
the axiom of choice formulated in the language L does not increase the strength of
PET.
Positive axiom of choice:
(∀x ∈W)(∃y ∈W)A(x, y) →(∃f : W →W)(∀x ∈W)A(x, fx)
(AC)
where A(x, y) is a positive elementary formula.
Cantini has also shown in [14] that adding a uniformity principle for positive
formulas of L yields an extension of PT whose provably total functions are still the
functions computable in polynomial time. In our context, we can state Cantini’s
principle as follows.
Positive uniformity principle:
(∀x)(∃y ∈W)A(x, y) →(∃y ∈W)(∀x)A(x, y)
(UP)
where A(x, y) is positive elementary.
The principle (UP) leads to a very natural extension of PET by adding a type
existence axiom for universal quantiﬁcation; this axiom is the natural dual analogue
of the domain type present in PET.
Universal quantiﬁcation:
ℜ(a) →ℜ(all(a)) ∧(∀x)(x ˙∈all(a) ↔(∀y)((x, y) ˙∈a))
(all)

Weak Theories of Operations and Types
459
The presence of the axiom (all) makes the type existence axioms more symmetric,
i.e. the types are generated from base types (initial segments of W and the iden-
tity type) by closing under domains, unions, intersections, existential quantiﬁcation
(inverse image) and universal quantiﬁcation.
In order to see that (all) does not increase the proof-theoretic strength of PET,
one shows that any model of PT + (UP) can be extended to a a model of PET +
(all). The presence of (UP) is pivotal in the treatment of (all). For a complete
exposition of these results, see Spescha and Strahm [45].
Theorem 5.2. The provably total functions of PET augmented by any combination
of the principles (all), (UP), (AC), (Tot), and (Ext) coincide with the polyno-
mial time computable functions.
The next natural step is to add the so-called Join axiom, which constructs disjoint
unions of types named by an operation; it has been widely studied for many systems
of explicit mathematics. The Join axioms are given by the following assertions (J.1)
and (J.2) (j denotes a new constant).
Join axioms:
ℜ(a) ∧(∀x ˙∈a)ℜ(fx) →ℜ(j(a, f))
(J.1)
ℜ(a) ∧(∀x ˙∈a)ℜ(fx) →(∀x)(x ˙∈j(a, f) ↔Σ(f, a, x))
(J.2)
where Σ(f, a, x) is the formula
(∃y)(∃z)(x = (y, z) ∧y ˙∈a ∧z ˙∈fy)
In Spescha [43] and Spescha and Strahm [44] the realizability interpretation of
the ﬁrst order language L is extended to the language of types and names L. In
combination with a partial cut elimination argument, it is possible to show that the
intuitionistic version of PET plus the Join axioms can be realized using polyno-
mial time computable functions. Currently, work of Probst is underway in order to
extend this result to classical logic.
6 Partial truth
In this section we address some interesting extensions of PT+ which have been
proposed and studied by Cantini [14]. The idea is to augment PT+ by
• a (form of) self-referential truth (`a la Aczel, Feferman, Kripke, etc.), providing
a ﬁxed point theorem for predicates

460
Thomas Strahm
• an axiom of choice for operations and a uniformity principle, restricted to pos-
itive conditions
These extensions do not alter the proof-theoretic strength of PT, a fact that has been
heavily used in the previous section in studying extensions of our theory PET.
In the following let us brieﬂy report on some of the many results obtained in
Cantini [14]. For a thorough exposition of frameworks for truth and abstraction
based on combinatory logic, cf. Cantini [10] and Kahle [29].
6.1 The language LT
The (ﬁrst order) language LT is an extension of the language L by
• a new unary predicate symbol T for truth
• new individual constants ˙=, ˙W, ˙∧, ˙∨, ˙∀, ˙∃
For each positive formula A of LT we can inductively deﬁne a term [A] whose free
variables are exactly the free variables of A:
[t = s] := ( ˙=ts)
[T(t)] := t
[s ∈W] := ˙Ws
[A ∧B] := ˙∧[A][B]
[A ∨B] := ˙∨[A][B]
[(∀x)A] := ˙∀(λx.[A])
[(∃x)A] := ˙∃(λx.[A])
We have that λx.[A] can be interpreted as the propositional function deﬁned by the
formula A. We can now interpret the language of naive set theory by deﬁning x ∈a
as T(ax) and understand {x : A} as λx.[A].
6.2 The truth axioms
The truth axioms for the positive fragment of LT spell out the expected clauses
according to the reductionist semantics as follows:

Weak Theories of Operations and Types
461
Truth axioms:
T( ˙=xy) ↔x = y
T( ˙Wx) ↔W(x)
T(x ˙∧y) ↔T(x) ∧T(y)
T(x ˙∨y) ↔T(x) ∨T(y)
T(˙∀f) ↔(∀x)T(fx)
T(˙∃f) ↔(∃x)T(fx)
One of the many interesting consequences of these axioms is a second recursion
or ﬁxed point theorem for positive predicates, which can be obtained by lifting the
ﬁxed point theorem for combinatory logic (cf. Lemma 2.1) to the truth-theoretic
language, cf. Cantini [10,14].
6.3 Adding positive choice and uniformity
We can formulate positive choice and uniformity principles in the language LT as
follows:
Positive choice and uniformity in LT:
(∀x ∈W)(∃y ∈W)T(axy) →(∃f : W →W)(∀x ∈W)T(ax(fx))
(AC)
(∀x)(∃y ∈W)T(axy) →(∃y ∈W)(∀x)T(axy)
(UP)
One of the numerous results obtained in Cantini [14] is stated in the following
theorem. It has been used in Spescha and Strahm [44] in order to show the conser-
vativity of various extensions of PET.
Theorem 6.1. τ(PT+ + truth axioms + AC + UP) = FPTIME.
The proof methods used by Cantini include a subtle internal forcing semantics,
non-standard variants of realizability and partial cut elimination properties. The
forcing interpretation is very elegant and makes direct use of the truth predicate T.
7 Safe induction
Apart from the world of bounded recursion schemas, bounded arithmetic and
bounded applicative theories there is the realm of so-called tiered systems in the
sense of Cook and Bellantoni (cf. e.g. [3]) and Leivant (cf. e.g. [31, 32]). Cru-
cial for this approach to characterizing complexities is a strictly predicative regime

462
Thomas Strahm
which distinguishes between different uses of variables in induction and recursion
schemas, thus severely restricting the deﬁnable or provably total functions in vari-
ous unbounded formalisms.
Unarguably, the tiered approach to complexity has led to numerous highly inter-
esting and intrinsic recursion-theoretic and also proof-theoretic characterizations of
complexity classes, which might lead to new subrecursive programming paradigms.
Also, higher type issues have recently been a subject of interest in this area,
cf. e.g. Bellantoni, Niggl, Schwichtenberg [4], Hofmann [26], and Leivant [33],
Finally, the tiered approach has provided neat distinctions between slow growing
and fast growing proof theories, see e.g. Wainer [54] and Ostrin and Wainer [36].
Below let us brieﬂy address some recent work along the lines of implicit charac-
terizations in the context of untyped applicative theories based on classical logic.
7.1 Polynomial time
In our applicative setting the above-mentioned “predicativization” amounts to dis-
tinguishing between (at least) two sorts or types of binary words W0 and W1, say,
where induction over W1 is allowed for formulas which are positive and do not
contain W1, cf. Cantini [13] for such systems.
A more elegant viewpoint of the predicative regime is to consider a modal frame-
work. Extend the language L by a modal operator 2 and let 2 obey the laws of an
S4 modality. Let t ∈2W stand for 2(t ∈W). Then W and 2W play the role of
normal and safe strings in the Bellantoni-Cook sense, respectively. We call a for-
mula positive safe if it is positive and does not involve the 2 operator. Accordingly,
we can formulate the following natural induction principle.
Positive safe notation induction:
For each positive safe formula A(x),
A(ϵ) ∧(∀x ∈2W)(A(x) →A(s0x) ∧A(s1x)) →(∀x ∈2W)A(x)
Let PRμ denote the extension of the applicative theory B based on the classical
modal predicate logic S4 and the schema of positive safe notation induction. The
notion of a provably total word function can be suitably adapted for PRμ, taking
into account the two sorts W and 2W, cf. [13] for details.
We are ready to state the following theorem, which is proved in Cantini [13] by
making use of cut elimination and realizability by Cook-Bellantoni functions.
Theorem 7.1. τ(PRμ) = FPTIME.

Weak Theories of Operations and Types
463
7.2 Polynomial space
More recently, Calamai and Cantini [8, 9] have proposed an extension of PRμ,
termed PRμ
p, where induction is strengthened to so-called positive safe tree induc-
tion with pointers. The principle is inspired by Oitavem’s recent tiered characteri-
zation of FPSPACE in [35].
Positive safe tree induction with pointers:
For each positive safe formula A(x, y),
(∀p ∈2W)A(ϵ, p) ∧
(∀x ∈2W)(∀p ∈2W)(A(x, s0p) ∧A(x, s1p) →A(s0x, p) ∧A(s1x, p))
→(∀x ∈2W)(∀p ∈2W)A(x, p)
The proof of the theorem below of Calamai and Cantini makes use of cut elimina-
tion and realizability by functions in Oitavem’s function algebra with pointers and
tree recursion.
Theorem 7.2. τ(PRμ
p) = FPSPACE.
8 Conclusion
In this article we have considered a number of applicative theories (with and with-
out types or self-referential truth, with and without modality) whose induction prin-
ciples are formulated for a suitable subclass of positive formulas.
Regarding induction for arbitrary positive formulas, say in the ﬁrst order lan-
guage L, one captures exactly the primitive recursive functions. For deﬁniteness,
let (Pos-IW) denote induction on W for formulas in Pos. Then τ(B + (Pos-IW))
coincides with the primitive recursive functions. This result was ﬁrst established
by Cantini in [11] using asymmetric interpretation and formalized semantics in IΣ1
and can be considered as a generalization to the applicative context of the well-
known Parsons-Mints-Takeuti theorem. The characterization theorem can also be
established by the realizability techniques presented in this article (cf. Cantini [14],
Strahm [48]). However, it has to be mentioned that Cantini’s original result [11] is
even a bit stronger, since negated equations in induction formulas are allowed.
We conclude this article by mentioning that the realizability techniques of this
paper have recently been helpful in the context of abstract many sorted alge-
bras with non-computable equality in establishing a further generalization of the
Parsons-Mints-Takeuti theorem, cf. Strahm and Zucker [50].

464
Thomas Strahm
References
[1] BEESON, M. J. Foundations of Constructive Mathematics: Metamathematical Stud-
ies. Springer, Berlin, 1985.
[2] BEESON, M. J. Proving programs and programming proofs. In Logic, Methodology
and Philosophy of Science VII, Barcan Marcus et. al., Ed. North Holland, Amsterdam,
1986, pp. 51–82.
[3] BELLANTONI, S., AND COOK, S. A new recursion-theoretic characterization of the
poly-time functions. Computational Complexity 2 (1992), 97–110.
[4] BELLANTONI, S., NIGGL, K.-H., AND SCHWICHTENBERG, H. Higher type recur-
sion, ramiﬁcation and polynomial time. Annals of Pure and Applied Logic 104, 1–3
(2000), 17–30.
[5] BUSS, S. R. Bounded Arithmetic. Bibliopolis, Napoli, 1986.
[6] BUSS, S. R. The witness function method and fragments of Peano arithmetic. In
Proceedings of the Ninth International Congress on Logic, Methodology and Philos-
ophy of Science, Uppsala, Sweden, August 7–14, 1991, D. Prawitz, B. Skyrms, and
D. Westerst˚ahl, Eds. Elsevier, North Holland, Amsterdam, 1994, pp. 29–68.
[7] BUSS, S. R. First-order proof theory of arithmetic. In Handbook of Proof Theory,
S. R. Buss, Ed. Elsevier, 1998, pp. 79–147.
[8] CALAMAI, G. Proof-theoretic contributions to computational complexity. PhD thesis,
University of Siena, 2008.
[9] CANTINI, A. A footnote on the Parsons-Mints-Takeuti theorem. Talk at Recent Trends
in Proof Theory, Bern, July 2008.
[10] CANTINI, A. Logical Frameworks for Truth and Abstraction. North-Holland, Ams-
terdam, 1996.
[11] CANTINI, A. Proof-theoretic aspects of self-referential truth. In Tenth International
Congress of Logic, Methodology and Philosophy of Science, Florence, August 1995,
Maria Luisa Dalla Chiara et. al., Ed., vol. 1. Kluwer, September 1997, pp. 7–27.
[12] CANTINI, A. Feasible operations and applicative theories based on λη. Mathematical
Logic Quarterly 46, 3 (2000), 291–312.
[13] CANTINI, A. Polytime, combinatory logic and positive safe induction. Archive for
Mathematical Logic 41, 2 (2002), 169–189.
[14] CANTINI, A. Choice and uniformity in weak applicative theories. In Logic Colloquium
’01, M. Baaz, S. Friedman, and J. Kraj´ıˇcek, Eds., vol. 20 of Lecture Notes in Logic.
Association for Symbolic Logic, 2005.
[15] CLOTE, P. Computation models and function algebras. In Handbook of Computability
Theory, E. Griffor, Ed. Elsevier, 1999, pp. 589–681.
[16] COBHAM, A. The intrinsic computational difﬁculty of functions. In Logic, Methodol-
ogy and Philosophy of Science II. North Holland, Amsterdam, 1965, pp. 24–30.

Weak Theories of Operations and Types
465
[17] COOK, S. A., AND KAPRON, B. M. Characterizations of the basic feasible functionals
of ﬁnite type. In Feasible Mathematics, S. R. Buss and P. J. Scott, Eds. Birkh¨auser,
Basel, 1990, pp. 71–95.
[18] COOK, S. A., AND URQUHART, A. Functional interpretations of feasibly constructive
arithmetic. Annals of Pure and Applied Logic 63, 2 (1993), 103–200.
[19] FEFERMAN, S. A language and axioms for explicit mathematics. In Algebra and
Logic, J. Crossley, Ed., vol. 450 of Lecture Notes in Mathematics. Springer, Berlin,
1975, pp. 87–139.
[20] FEFERMAN, S. Recursion theory and set theory: a marriage of convenience. In Gen-
eralized recursion theory II, Oslo 1977, J. E. Fenstad, R. O. Gandy, and G. E. Sacks,
Eds., vol. 94 of Stud. Logic Found. Math. North Holland, Amsterdam, 1978, pp. 55–98.
[21] FEFERMAN, S. Constructive theories of functions and classes. In Logic Colloquium
’78, M. Boffa, D. van Dalen, and K. McAloon, Eds. North Holland, Amsterdam, 1979,
pp. 159–224.
[22] FEFERMAN, S. Deﬁnedness. Erkenntnis 43 (1995), 295–320.
[23] FEFERMAN, S.,
AND J ¨AGER, G.
Systems of explicit mathematics with non-
constructive μ-operator. Part II. Annals of Pure and Applied Logic 79, 1 (1996), 37–52.
[24] FERREIRA, F. Polynomial Time Computable Arithmetic and Conservative Extensions.
PhD thesis, Pennsylvania State University, 1988.
[25] FERREIRA, F. Polynomial time computable arithmetic. In Logic and Computation,
Proceedings of a Workshop held at Carnegie Mellon University, 1987, W. Sieg, Ed.,
vol. 106 of Contemporary Mathematics. American Mathematical Society, Providence,
Rhode Island, 1990, pp. 137–156.
[26] HOFMANN, M. Type systems for polynomial-time computation. Habilitation Thesis,
Darmstadt, 1999. Appeared as LFCS Technical Report ECS-LFCS-99-406.
[27] IRWIN, R., KAPRON, B., AND ROYER, J. On characterizations of the basic feasible
functionals, Part I. Journal of Functional Programming 11 (2001), 117–153.
[28] J ¨AGER, G.
Induction in the elementary theory of types and names. In Computer
Science Logic ’87, E. B¨orger, H. Kleine B¨uning, and M.M. Richter, Eds., vol. 329 of
Lecture Notes in Computer Science. Springer, Berlin, 1988, pp. 118–128.
[29] KAHLE, R. The Applicative Realm. Habilitation Thesis, T¨ubingen, 2007. Appeared in
Textos de Mathem´atica 40, Departamento de Mathem´atica da Universidade de Coim-
bra, Portugal, 2007.
[30] KAPRON, B., AND COOK, S. A new characterization of type 2 feasibility. SIAM
Journal on Computing 25 (1996), 117–132.
[31] LEIVANT, D. A foundational delineation of poly-time. Information and Computation
110 (1994), 391–420.

466
Thomas Strahm
[32] LEIVANT, D. Ramiﬁed recurrence and computational complexity I: Word recurrence
and poly-time. In Feasible Mathematics II, P. Clote and J. Remmel, Eds. Birkh¨auser,
1994, pp. 320–343.
[33] LEIVANT, D. Implicit computational complexity for higher type functionals (Extended
abstract). In CSL ’02, J. Bradﬁeld, Ed., vol. 2471 of Lecture Notes in Computer Sci-
ence. Springer, 2002, pp. 367–381.
[34] MELHORN, K. Polynomial and abstract subrecursive classes. Journal of Computer
and System Science 12 (1976), 147–178.
[35] OITAVEM, I. Characterizing PSPACE with pointers. Mathematical Logic Quarterly
54, 3 (2008), 323 – 329.
[36] OSTRIN, G., AND WAINER, S. S. Elementary arithmetic. Annals of Pure and Applied
Logic 133 (2005), 275–292.
[37] PEZZOLI, E. On the computational complexity of type 2 functionals. In Computer
Science Logic ’97, vol. 1414 of Lecture Notes in Computer Science. Springer, 1998,
pp. 373–388.
[38] RITCHIE, R. W. Classes of predictably computable functions. Transactions of the
American Mathematical Society 106 (1963), 139–173.
[39] ROYER, J.
Semantics vs. syntax vs. computations: Machine models for type-2
polynomial-time bounded functionals. Journal of Computer and System Science 54
(1997), 424–436.
[40] SCHL ¨UTER, A. An extension of Leivant’s characterization of poly-time by predicative
arithmetic. Preprint, Stanford Univeristy, 1995. 13 pages.
[41] SCOTT, D. S. Identity and existence in intuitionistic logic. In Applications of Sheaves,
M. P. Fourman, C. J. Mulvey, and D. S. Scott, Eds. Springer, Berlin, 1979. Lecture
Notes in Mathematics 753.
[42] SETH, A. Complexity Theory of Higher Type Functionals. PhD thesis, Tata Institute
of Fundamental Research, Bombay, 1994.
[43] SPESCHA, D. Weak systems of explicit mathematics. PhD thesis, Universit¨at Bern,
2009.
[44] SPESCHA, D., AND STRAHM, T. Realizability in weak systems of explicit mathemat-
ics. In preparation.
[45] SPESCHA, D., AND STRAHM, T.
Elementary explicit types and polynomial time
operations. Mathematical Logic Quarterly 55, 3 (2009), 245–258.
[46] STRAHM, T. Polynomial time operations in explicit mathematics. Journal of Symbolic
Logic 62, 2 (1997), 575–594.
[47] STRAHM, T. Proof-theoretic Contributions to Explicit Mathematics. Habilitationss-
chrift, University of Bern, 2001.
[48] STRAHM, T. Theories with self-application and computational complexity. Informa-
tion and Computation 185 (2003), 263–297.

Weak Theories of Operations and Types
467
[49] STRAHM, T. A proof-theoretic characterization of the basic feasible functionals. The-
oretical Computer Science 329 (2004), 159–176.
[50] STRAHM, T., AND ZUCKER, J. Primitive recursive selection functions for existential
assertions over abstract algebras. Journal of Logic and Algebraic Programming 76, 2
(2008), 175 – 197.
[51] THOMPSON, D. B. Subrecursiveness: machine independet notions of computability
in restricted time and storage. Mathematical Systems Theory 6 (1972), 3–15.
[52] TROELSTRA, A., AND VAN DALEN, D. Constructivism in Mathematics, vol. I. North-
Holland, Amsterdam, 1988.
[53] TROELSTRA, A., AND VAN DALEN, D. Constructivism in Mathematics, vol. II. North
Holland, Amsterdam, 1988.
[54] WAINER, S. S. Provable recursiveness and complexity. In Logic Colloquium ’01,
M. Baaz, S. Friedman, and J. Kraj´ıˇcek, Eds., vol. 20 of Lecture Notes in Logic. Asso-
ciation for Symbolic Logic, 2005.


Computing Bounds from Arithmetical Proofs
Stanley S. Wainer
School of Mathematics,
University of Leeds,
LS2 9JT, UK
S.S.Wainer@leeds.ac.uk
Abstract We explore the role of the function a + 2b, and its generalizations
to higher number classes, in providing complexity bounds for the provably
computable functions across a broad spectrum of theories, based on a “pred-
icative” induction scheme and ranging in strength between polynomial-time
arithmetic and Π1
1-CA0. The resulting “fast-growing” sub-recursive hier-
archy forges a direct link between proof theory and various combinatorial
independence results.
As illustration, the ﬁnal section treats Friedman’s
“miniaturized” Kruskal Theorem for labelled trees, by showing directly that
the appropriate bounding function for Π1
1-CA0 has a “bad” computation se-
quence.
1 The Fast Growing Hierarchy
If Bb(a) = a + 2b then B satisﬁes the recursion:
B0(a) = a + 1
Bb+1(a) = Bb(Bb(a)) .
This is the beginning of a version of the (so-called) Fast Growing Hierarchy:
Bα(a) =
⎧
⎨
⎩
a + 1
if α = 0
Bα′(Bα′(a)) if α = α′ + 1
Bαa(a)
if α is a limit.
Note the dependence on chosen fundamental sequences {αa} to limits α.
We could, more suggestively, write Bα(a) as a ⊕2α where, if λ0, λ1, λ2, . . . is a
given fundamental sequence to limit λ, then a⊕λ is deﬁned by the diagonalization
a ⊕λa. This is a quite natural way to extend number-theoretic hierarchies into
the transﬁnite, and in the case of the Bα functions there is a deep proof-theoretic
involvement which we attempt to bring out here.
Firstly, a basic arithmetical context serves to illustrates this connection. The
theory EA(I;O) is a stripped-down variant of the “ramiﬁed” theories of Leivant [8]

470
Stanley S. Wainer
who also highlights a + 2b as a crucial example; it imports to a formal theory the
normal/safe variable discipline of Bellantoni–Cook [2]. For a more detailed proof-
theoretic analysis see Ostrin–Wainer [9], [10].
2 Input-Output Arithmetic EA(I;O)
• EA(I;O) has the language of arithmetic, with (quantiﬁed, “output”) variables
a, b, c, . . ..
• In addition there are numerical constants (“inputs”) x, y, z, . . ..
• It has symbols for the zero, successor, predecessor, addition, subtraction and
multiplication functions, given by their usual deﬁning axioms. Also there is a
pairing function π(a, b) (:= 1/2(a+b)(a+b+1)+a+1) with inverses π0, π1
from which sequence numbers can be constructed using π(s, a) to append a
to s, and deconstructed by functions (s)i extracting the i-th component. All
of these initial functions are quadratically bounded. However, the stock of
basic symbols is enlarged further by the addition of the exponential function
Bb(a) = a + 2b with deﬁning equations as above. The given relations are =
and ≤.
• Only “basic” terms (those built out of variables and constants by application of
the unary term constructors alone: successor, predecessor, π0 and π1 – noth-
ing else) are allowed as witnessing or instantiating terms in the ∃, ∀quantiﬁer
rules.
• The induction axioms are:
A(0) ∧∀a(A(a) →A(a + 1)) →A(t)
where t = t(x) is a closed basic term controlling induction-length. Note that
if A(a) is progressive then so is ∀b ≤a.A(b) ≡∀b(b ≤a →A(b)), and so a
more revealing instance of induction is
A(0) ∧∀a(A(a) →A(a + 1)) →∀b ≤t.A(b) .
In other words, EA(I;O) is really a theory of bounded induction, the (implicit)
bounds being closed terms t(x) dependent on inputs x which (because they
are constants) cannot be universally quantiﬁed, and later re-instantiated, once
introduced. Call this “input” (or “predicative”) induction.
Deﬁnition 2.1. Write t ↓for ∃a(t = a).

Computing Bounds from Arithmetical Proofs
471
Note 2.2. If t is not basic one cannot pass directly from t = t to t ↓because only
basic terms are allowed as witnesses in the ∃rule. However, the usual equality
axioms allow one to derive immediately in EA(I;O):
t ↓∧A(t) →∃aA(a)
and the dual
t ↓∧∀aA(a) →A(t) .
Thus “deﬁned” terms may witness existential quantiﬁers or instantiate universal
ones.
Example 2.3. Some basic illustrations of induction complexity in EA(I;O):
• From b+c = d we immediately get b+(c+1) = d+1 and since the term d+1
is basic, then b+c = d →∃a(b+(c+1) = a). Hence b+c ↓→b+(c+1) ↓.
Therefore b + x ↓by Σ1-induction “up to” x.
Then ∀b(b + x ↓).
• One can then induct on the formula b + x · c ↓because b + x · c = d →
b+x·(c+1) = d+x and d+x ↓by the above. So b+x·c ↓→b+x·(c+1) ↓.
Clearly b+x·0 ↓because b is basic, and hence another application of Σ1 input
induction gives either b + x2 ↓or b + x · y ↓.
Then ∀b(b + x2 ↓), and similarly ∀b(b + x3 ↓), ∀b(b + x4 ↓) etc.
• Exponential requires a Π2 induction on ∀a(a + 2b ↓) since by two calls on the
premise, and making crucial use of the above note, ∀a(a + 2b ↓) →∀a(a +
2b + 2b ↓). Therefore ∀a(a + 2b ↓) is progressive in b and by input induction,
∀a(a + 2x ↓), i.e. Bx(a) ↓. In particular with a = x we obtain Bx(x) =
x + 2x ↓which could be written Bω(x) ↓, choosing the identity function as
the “standard” fundamental sequence to ω.
• To carry this a stage further we use Gentzen’s method for proving transﬁnite
induction below ε0, but now the context is simpler. Consider the Π3 formula:
∀b(∀a(a + 2b ↓) →b + 2c ↓∧∀a(a + 2b+2c ↓)) .
This is progressive in c, the base case c = 0 being the progressiveness of
∀a(a + 2b ↓) just shown. Therefore a Π3 input induction proves the formula
with c := t for any closed basic term t. By choosing t = x and instantiating
b := 0 one obtains ∀a(a+22x ↓). Instantiating b := x yields ∀a(a+2x+2x ↓),

472
Stanley S. Wainer
or alternatively ∀a(BBω(x)(a) ↓). Then since Bω(x) ↓one could instantiate
a := Bω(x) to obtain
x + 2x + 2x+2x = BBω(x)(Bω(x)) = Bω(Bω(x)) ↓.
Higher levels of induction would then prove higher exponential stack-heights
(hence higher iterates of Bω) to be deﬁned, provided they are applied to inputs.
These arguments can be generalized, as in Ostrin–Wainer [9], [10]. For any
formula A(a) of EA(I;O), let Prog A(a) express its progressiveness in the variable
a, i.e. A(0) ∧∀a(A(a) →A(a + 1)).
Lemma 2.4. For any closed term t on inputs ⃗x, and any formula A, one can prove
in EA(I;O) that t ↓and Prog A(a) →∀a ≤t.A(a).
Proof. If t is basic then the lemma merely restates input induction. For more
complex closed terms one proceeds by induction on their build–up.
For example, if t = t1+t2, ﬁrst consider the formula A(b) →b+a ↓∧A(b+a).
Then Prog A(a) implies that this too is progressive in a. Therefore by applying
the induction hypothesis for t2 to it, one concludes A(b) →∀a ≤t2.(b + a ↓
∧A(b+a)). But the induction hypothesis for t1 gives Prog A(a) →∀b ≤t1.A(b).
Hence
Prog A(a) →∀b ≤t1.∀a ≤t2.(b + a ↓∧A(b + a))
from which follows Prog A(a) →∀a ≤t1 + t2.A(a), and also t1 + t2 ↓by
applying it to any provably progressive formula.
A similar argument deals with the case t = t2 · t1 but here one uses the formula
Prog A(a) →∀b(A(b) →A(b+t2)) derived as above. From this one easily proves
Prog A(a) →Prog (t2 · a ↓∧A(t2 · a)) because if t2 · a = b then t2 · (a + 1) =
b + t2. Now one applies the induction hypothesis for t1 to conclude t2 · t1 ↓and
Prog A(a) →A(t2 · t1). If this is applied instead to A′(a) ≡∀b ≤a.A(b) then
Prog A(a) →Prog A′(a) and the desired result follows for t = t2 · t1.
For t = t1 + 2t2 consider the formula ∀a(A(a) →a + 2b ↓∧A(a + 2b)) and
note that its progressiveness in b is implied by the progressiveness of A in a. By
the induction hypothesis for t2 we then have
Prog A(a) →∀b ≤t2.∀a(A(a) →a + 2b ↓∧A(a + 2b)) .
By the induction hypothesis for t1 we can instantiate a := t1 and, since then obtain
Prog A(a) →t1+2t2 ↓∧A(t1+2t2). Hence, as before, EA(I;O) proves t1+2t2 ↓
and Prog A(a) →∀a ≤t1 + 2t2.A(a).
For other term constructs note that, just as addition depends on iterating the
successor, one could equally well iterate the predecessor to deal with subtraction

Computing Bounds from Arithmetical Proofs
473
of terms, or iterate π0 to decode initial segments of sequences and hence, by π1,
locate their components t = (t1)t2. Such terms (on inputs only) are then prov-
ably deﬁned, and also provably bounded by t1. Thus since Prog A(a) →∀a ≤
t1.A(a) by the induction hypothesis, one may instantiate a := (t1)t2 to obtain
Prog A(a) →A((t1)t2). Applying this instead to A′(a) ≡∀b ≤a.A(b) one then
gets Prog A(a) →∀a ≤(t1)t2.A(a) as required.
Using these results, Spoors [12] shows that IΔ0 + exp can be embedded in
EA(I;O). For each formula B(⃗c) of IΔ0 + exp let B[⃗t] be the formula of EA(I;O)
which results by ﬁrst forming its universal closure, and then bounding all previously
unbounded universal quantiﬁers by the closed terms ⃗t = t1, t2, . . . successively.
Theorem 2.5 (Spoors). If IΔ0 + exp ⊢B(⃗a) then for any (long enough) sequence
⃗t of closed terms, EA(I;O) ⊢B[⃗t].
Deﬁnition 2.6. A function f : Nk →N is provably recursive or provably com-
putable in EA(I;O) if its graph has a Σ1 deﬁning formula F(⃗c, a) such that on
inputs ⃗c = ⃗x, EA(I;O) proves ∃aF(⃗x, a).
Theorem 2.7. The provably recursive functions of EA(I;O) are exactly the elemen-
tary functions.
Proof. By Spoors’ result, any Σ1 theorem ∃aF(⃗c, a) of IΔ0 + exp gets embedded
into EA(I;O) as ∀⃗c ≤⃗t.∃aF(⃗c, a). By choosing ⃗t = ⃗x and instantiating at ⃗c := ⃗x
one immediately obtains EA(I;O) ⊢∃aF(⃗x, a). Thus every provably recursive
function of IΔ0 + exp becomes provably recursive in EA(I;O). But the provably
recursive functions of IΔ0 + exp are just the elementary functions.
Conversely we must show that only elementary functions are provably recursive
in EA(I;O). This is fairly easy to see, and illustrates the role of B in computing
bounds for existential witnesses. Brieﬂy, the procedure goes thus:
(i) Witnesses for Σ1 theorems ∃aF(n, a), proved by Σ1-inductions up to x := n,
are bounded by Bh where h = log n.
This is because for ﬁxed n, any input induction up to x := n can be unravelled,
inside EA(I;O), to a binary tree of cuts of height log n. If it’s a Σ1-induction on
∃aF(c, a) a typical cut at height h + 1 in this tree will have essentially the form:
∃aF(c, a) →∃aF(c′, a)
∃aF(c′, a) →∃aF(c′′, a)
∃aF(c, a) →∃aF(c′′, a)
where the premises are at height h. Now assume, inductively on h, that Bh bounds
witnesses for both premises, i.e. if F(c, a) holds (in the standard model) then
F(c′, a′) holds for some a′ computable in Bh(a)-many steps, and similarly for c′

474
Stanley S. Wainer
to c′′. Composing Bh will then yield a bound Bh+1 = Bh ◦Bh for the conclusion
at height h + 1.
(ii) Witnesses for Σ1 theorems ∃aF(n, a), proved by Π2-inductions up to x := n,
are bounded by B2h·d where h = log n. Higher levels of induction complexity
require iterated exponentials 22h·d etcetera.
To see this, suppose EA(I;O) ⊢∃aF(x, a). Partial cut-elimination yields a “free-
cut-free” proof, so only cuts on induction formulas remain. Let d be the height of
this proof. Then after unravelling all inductions in favour of iterated cuts, up to the
maximum input x := n, the height of the resulting (induction–free) proof-tree will
be of the order of log n · d. If all cuts are Σ1, part (i) above applies immediately
to give polynomial complexity bounds Blog n·d(a) = a + 2log n·d = a + nd. Note
that unary, rather than binary, representation of numerals here entails a polynomial
in n, not log n; hence “linear space” complexity rather than polytime. For Π2 in-
ductions one must ﬁrst reduce all cuts to Σ1 form before part (i) can be used. But
since all inductions have been eliminated, standard Gentzen cut-reduction applies,
and the price to be paid is a further exponential increase in proof–height. Thus the
complexity bounds will now be of order B2log n·d(a) = a+2nd. Higher levels of in-
duction would require further rounds of cut-reduction, yielding iterated exponential
bounds.
This completes the proof because functions computable within (ﬁnitely) iterated
exponential bounds are elementary.
3 Adding an Inductive Deﬁnition
Deﬁnition 3.1. ID1(I;O) is obtained from EA(I;O) by adding, for each uniterated
positive inductive form F(X, a), a new predicate P, and Closure and Least-Fixed-
Point axioms:
∀a(F(P, a) →P(a))
∀a(F(A, a) →A(a)) →∀a(P(a) →A(a))
for each formula A.
Example 3.2. Associate the predicate N with the inductive form:
F(X, a) :≡a = 0 ∨∃b(X(b) ∧a = b + 1).
In this way we immediately capture full Peano Arithmetic, as in Wainer–
Williams [15], for the Least-Fixed-Point axiom interprets the full induction scheme
of PA in ID1(I;O) as:
A(0) ∧∀a(A(a) →A(a + 1)) →∀a(N(a) →A(a)).

Computing Bounds from Arithmetical Proofs
475
Furthermore, by similar arguments to those already used, one easily proves the
progressiveness in b of the formulas ∀a(N(a) →a + b ↓∧N(a + b)) and
∀a(N(a) →a · b ↓∧N(a · b)), so by the Least-Fixed-Point axiom, ID1(I;O)
proves ∀a, b(N(a) ∧N(b) →a + b ↓∧N(a + b)) and ∀a, b(N(a) ∧N(b) →
a · b ↓∧N(a · b)). Hence, by relativising all quantiﬁers to N, one interprets PA in
ID1(I;O):
Theorem 3.3. If PA ⊢A(⃗a) then ID1(I;O) ⊢N(⃗a) →AN(⃗a).
Then, since N(x) is an immediate consequence of input induction, and since
ID1(I;O) proves, for a bounded formula A, that its interpretation AN entails A
itself,
Corollary 3.4. If PA ⊢A(⃗a) with A a Σ1-formula then, replacing ⃗a by inputs ⃗x,
ID1(I;O) ⊢A(⃗x).
The provably recursive functions of PA are therefore provably recursive (on in-
puts) in ID1(I;O). To show the converse we need an ordinal analysis of ID1(I;O),
and this can be done by following Buchholz’s Ω-rule treatment of classical ID the-
ories as in [3], [4]. However the uncountable ordinal bounds which necessarily
appear there are now replaced by countable ones.
3.1 Unravelling LFP-Ax by Buchholz’ Ω-Rule
We are still working in the I/O context, so can ﬁx ⃗x := ⃗n and unravel induc-
tions into iterated cuts as before. However the resulting ID1(I;O)-derivations will
be further complicated by the presence of Least-Fixed-Point axioms. These must
be “unravelled” as well, before we can read off bounds. To do this, ID1(I;O) is
embedded into an inﬁnitary system ID1(I;O)∞of Tait-style sequents
n : I; m : O ⊢α Γ
where n bounds the input values, m declares a bound on initial output parameters,
and the ordinal heights α can, for present purposes, be restricted below ε0, with
standard fundamental sequences. For shorthand we write simply n; m ⊢α Γ.
Most of the rules are unsurprising and we don’t list them, but the ∃-rule has two
premises:
n; m ⊢β m′
n; m ⊢β A(m′), Γ
n; m ⊢α ∃aA(a), Γ
Here the left-hand premise “computes” witness m′ from m according to the axiom
n; m ⊢α m′ if m′ ≤m + 1, and the computation rule:
n; m ⊢β m′′
n; m′′ ⊢β m′
n; m ⊢α m′

476
Stanley S. Wainer
which also applies with m′ replaced by any set of formulas Γ. The universal quan-
tiﬁer is introduced by the ω-rule and the Closure axiom of an inductive deﬁnition
is re-written as a rule.
In all of these the declared input n remains ﬁxed, and controls the ordinal assign-
ment in the following way: if n; m′ ⊢β Γ′ is a premise of a rule with conclusion
n; m ⊢α Γ then β ∈α[n] where α[n] = ∅if α = 0, or β[n] ∪{β} if α = β + 1,
or αn[n] if α is a limit. Thus, while input n is ﬁxed, derivations are in fact ﬁnite
because n; m ⊢α Γ is equivalent to n; m ⊢Gα(n) Γ where Gα(n) = |α[n]| is
the “slow growing” hierarchy. However the ﬁnal (crucial) rule to be added allows
inputs to change, and it is this that causes growth in the extracted bounds.
Buchholz’ Ω-Rule
n; m ⊢λ0 P(k), Γ0
m′ ⊢h
0 P(k), Δ ⇒max(n, h); max(m, m′) ⊢λh Γ1, Δ
n; m ⊢λ Γ0, Γ1
where Δ is any set of positive-in-P formulas, ⊢h
0 signiﬁes a cut-free derivation of
ﬁnite height h (therefore independent of input n), and λ is a limit. The map h →λh
is then a measure of the uniformity in the transformation ⇒.
Lemma 3.5. The Ω rule proves the Least-Fixed-Point axioms with height ω + 3.
Proof. The gist of it is this – following Buchholz [3], [4].
For the left-hand premise of the Ω-rule choose n; m ⊢0 P(k), ¬P(k).
For the right-hand premise, ﬁrst assume m′ ⊢h
0 P(k), Δ. Each step of this (di-
rect, cut-free) proof can be mimicked to derive max(m, m′) ⊢d+h ¬∀a(F(A, a) →
A(a)), A(k), Δ for some ﬁxed d depending only on the size of the given formula A.
This establishes the right-hand premise with λ = ω, choosing the almost–standard
fundamental sequence ωh = d + h instead of ωh = h .
Therefore the Ω-rule gives n; m ⊢ω ¬∀a(F(A, a) →A(a)), ¬P(k), A(k). This
is for arbitrary k and so by ∨and ∀rules one obtains the Least-Fixed-Point axiom
with proof-height ω + 3.
Theorem 3.6. ID1(I;O) is embeddable into ID1(I;O)∞with derivation heights <
ω · 2.
3.2 Cut Elimination and Collapsing in ID1(I;O)∞
As usual, Gentzen-style cut-reduction increases height exponentially, and so by
the embedding, every theorem of ID1(I;O) is cut–free derivable in ID1(I;O)∞with
ordinal height < ε0.

Computing Bounds from Arithmetical Proofs
477
Lemma 3.7 (Collapsing). Given a cut-free ID1(I;O)∞derivation n; m ⊢α
0 Γ where
Γ contains only positive occurrences of inductively deﬁned predicates P, then
m ⊢h
0 Γ where h < Bα+1(n) for n > 0.
Proof. By induction on α. Suppose n; m ⊢α
0 Γ comes about by an application of
the Ω-rule from premises
n; m ⊢α0
0
P(k), Γ0 and m′ ⊢h
0 P(k), Δ ⇒max(n, h); max(m, m′) ⊢αh
0
Γ1, Δ .
Then, applying the induction hypothesis to the left premise, m ⊢h
0 P(k), Γ0 where
h < Bα0+1(n). Applying the right premise, with this h and Δ = Γ0, m′ = m,
we obtain max(n, h); m ⊢αh
0
Γ. The induction hypothesis can now be applied to
this and yields m ⊢h′
0 Γ where h′ < Bαh+1(max(n, h)). Hence, replacing h by its
bound Bα0+1(n), and using basic monotonicity properties of the B hierarchy, we
get the required
h′ < Bαh+1(Bα0+1(n)) ≤Bαh+1(Bα1(n)) ≤BαBα(n) = Bα+1(n) .
All other cases are straightforward because if n; m ⊢α
0 Γ arises by any other
rule from premises n; m′ ⊢β
0 Γ′ then the induction hypothesis gives m′ ⊢h′
0
Γ′
with h′ < Bβ+1(n) and then the rule may be re-applied to give m ⊢h
0 Γ with
h = Bβ+1(n). But since β ∈α[n] we then have h ≤Bα(n) < Bα+1(n) and this
completes the proof.
Theorem 3.8. ID1(I;O) has the same provably recursive functions as PA.
Proof. We have already shown that every function provably recursive in PA is
provable also in ID1(I;O). Conversely, suppose f(⃗x) has a Σ1 graph ∃bF(⃗x, a, b)
such that ∃a, bF(⃗x, a, b) is provable in ID1(I;O). Then by the Embedding and Cut
Elimination, there is an α below ε0 such that for all ⃗n, there is a ID1(I;O)∞
derivation of max⃗n; 0 ⊢α
0 ∃a, bF(⃗n, a, b). By the Collapsing Lemma we then
have 0 ⊢h
0 ∃a, bF(⃗n, a, b) with h < Bα+1(max⃗n). Since this derivation is cut-
free and of ﬁnite height, our original bounding principle applies to give witnesses
a, b ≤Bh(max⃗n) satisfying F(⃗n, a, b). Therefore the value of f(⃗n) is computable
by bounded search and will be elementary in any such bound. Replacing h by
Bα+1(max⃗n), this bound becomes ≤Bh(h) = Bω(h) < Bω ◦Bα+1(max⃗n) ≤
Bα+2(max⃗n). Hence f, being elementary in a level of the fast-growing hierarchy
below ε0, is provably recursive in PA.
4 Generalizing to ID<ω
Williams’ thesis [16] generalizes the foregoing to theories of ﬁnitely iterated induc-
tive deﬁnitions IDi(I;O), still retaining the input/output discipline. As the inductive

478
Stanley S. Wainer
deﬁnitions are iterated, the higher levels of Ω-rules needed to unravel them are con-
trolled by “tree-ordinals” in successively higher number-classes Ω0 = N ⊂Ω1 =
Ω ⊂Ω2 ⊂. . . ⊂Ωi. These are generated inductively by:
α ∈Ωi+1 if α = 0 ∨∃β ∈Ωi+1(α = β + 1) ∨∃j ≤i(α : Ωj →Ωi+1) .
Each Ωi+1 is partially ordered by the “sub-tree” ordering ≺. Furthermore, all tree-
ordinals used here will be “structured” in the sense that all limit sub-trees λ : Ωj →
Ωi+1 are monotone with respect to ≺, when restricted to structured elements of Ωj.
For more on tree-ordinals and their uses in this context, see e.g. Fairtlough–Wainer
[5], Wainer [14].
The inﬁnitary system IDi+1(I;O)∞then has (Tait-style) sequents of the form
γi : Ωi, . . . , γ1 : Ω1, n : I; m : O ⊢α Γ
where α ∈Ωi+1, and this is abbreviated ⃗γ, n; m ⊢α Γ. The rules are generalized
versions of the rules for ID1(I;O)∞. The underlying ordinal assignment principle,
for all but the Ωj rules, is that if ⃗γ, n; m ⊢α Γ is the conclusion of a rule with
premises ⃗γ′, n′; m′ ⊢β Γ′ then β ∈α[⃗γ, n] where α[⃗γ, n] = ∅if α = 0, =
β[⃗γ, n] ∪{β} if α = β + 1, and = αγj[⃗γ, n] if α : Ωj →Ωi+1 is a “limit”. Note
that if α ∈Ωj for some j ≤i then α[⃗γ, n] = α[γj−1, . . . , n] and so the initial
declared parameters γi : Ωi, . . . , γj : Ωj become redundant.
There are Buchholz Ωj-rules for each j = 1, . . . , i + 1, with Pj being the pred-
icate deﬁned by a j-times iterated induction (allowing negative occurrences of Pj′
for j′ < j). The Ωi+1 rule takes two premises:
⃗γ, n; m ⊢λ0 Pi+1(k), Γ0
and, for all δ ∈Ωi and all sets Δ of positive-in-Pi+1 formulas,
⃗γ, n′; m′ ⊢δ
0 Pi+1(k), Δ ⇒⃗γ(γi := δ), max(n, n′); max(m, m′) ⊢λδ Γ1, Δ .
The conclusion is ⃗γ, n; m ⊢λ Γ0, Γ1.
Collapsing from one level i+1 down to the one below is then computed in terms
of higher-level extensions of the Bα hierarchy: ϕ(i)
α (β) for α ∈Ωi+1, β ∈Ωi
deﬁned by
ϕ(i)
α (β) =
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
β + 1
if α = 0
ϕ(i)
α′ ◦ϕ(i)
α′ (β) if α = α′ + 1
ϕ(i)
αβ(β)
if α : Ωi →Ωi+1
ξ →ϕ(i)
αξ(β) if α : Ωj →Ωi+1with j < i .

Computing Bounds from Arithmetical Proofs
479
Note that if α ∈Ωi then ϕ(i)
α (β) = β + 2α, so taking ωi ∈Ωi+1 to be the identity
function on Ωi one obtains ϕ(i)
ωi (β) = ϕ(i)
β (β) = β + 2β which serves as a bound
for each round of cut reduction.
Lemma 4.1 (Cut reduction). If ⃗γ, n; m ⊢α Γ in IDi+1(I;O)∞with cut rank r + 1
then ⃗γ, n; m ⊢α′ Γ with cut rank r where α′ = ϕ(i+1)
ωi+1 (α).
Lemma 4.2 (Collapsing). If ⃗γ, n; m ⊢α
0 Γ in IDi+1(I;O)∞where Γ is positive in
Pi+1 then ⃗γ, n; m ⊢δ
0 Γ where δ ≺ϕ(i)
α+1(γi) ∈Ωi. Note that since δ ∈Ωi no
Ωi+1 rules remain.
Proof. The proof goes as before for ID1(I;O)∞, all cases being straightforward
except for the Ωi+1 rule. In that case one may apply the induction hypothesis to the
ﬁrst premise, yielding
⃗γ, n; m ⊢δ
0 Pi+1(k), Γ0
where δ ≺ϕ(i)
λ0+1(γi). Next apply the second premise to transform this into a
derivation
⃗γ(γi := δ), n; m ⊢λδ
0 Γ
and note that the declared parameters ⃗γ(γi := δ), n; m can be “weakened” to
⃗γ(γi := δ′), n; m with δ′ = ϕ(i)
λ (γi) because δ ≺ϕ(i)
λγi (γi) = ϕ(i)
λ (γi) provided
1 ⪯γi. Now the induction hypothesis can again be applied to give ⃗γ, n; m ⊢δ′′
0
Γ
since the ﬁrst declared parameter γi is immaterial as the ordinal bound δ′′ ∈Ωi.
We then have
δ′′ ≺ϕ(i)
λδ+1(δ′) ⪯ϕ(i)
λδ′(δ′) = ϕ(i)
λ (δ′) = ϕ(i)
λ (ϕ(i)
λ (γi)) = ϕ(i)
λ+1(γi)
as required.
Deﬁnition 4.3. The countable tree-ordinals τi ∈Ω1 are
τ1 = ϕ(1)
ω (ω); τ2 = ϕ(1)
ϕ(2)
ω (ω1)(ω); τ3 = ϕ(1)
ϕ(2)
ϕ(3)
ω
(ω2)
(ω1)(ω) etc .
Then τ1 = ω + 2ω, τ2 is a version of ε0 and τ3 is a version of the Bachmann–
Howard ordinal. Bτi is in fact a functor on the category N with τi+1 its direct limit,
or conversely, Bτi is the “slow growing” collapse of τi+1 (see Wainer [13], [14]).
To see how these ordinals arise, suppose for example that ID2(I;O) ⊢A(x, a)
where A contains no inductive predicates. This embeds into ID2(I;O)∞as ω :
Ω1, n : I; m : O ⊢ω1+d A(n, m), for all n; m, say with cut rank r. The ω1 + d can

480
Stanley S. Wainer
be weakened to a d-times iterate of ϕ(2)
ω2 applied on ω1. A further r-times iterate
then yields a bound α for a cut-free derivation of A(n, m), namely
α = ϕ(2)
ω2 ◦. . . ◦ϕ(2)
ω2 (ω1) ≺ϕ(2)
ω2+2(d+r)(ω1) = ϕ(2)
ϕ(3)
(d+r)(ω2)(ω1) .
Collapsing provides a countable bound ϕ(1)
α+1(ω) ≺ϕ(1)
ϕ(2)
ϕ(3)
(d+r)(ω2)
(ω1)(ω) ≺τ3.
Theorem 4.4 (Williams). In summary:
• Classical IDi is interpretable in IDi+1(I;O).
• Its ordinal bound is τi+2 in the notation above.
• IDi+1(I;O) has the same provably recursive functions as IDi.
• The provably recursive functions are those computable within Bα-bounded
resource, for α < τi+2.
• ID<ω and ID<ω(I;O) are mutually interpretable.
Remark 4.5. Another way to view the relationship between IDi and IDi(I;O) is
in terms of the hierarchies which generate their provably recursive functions. For
IDi it’s the fast growing hierarchy below τi+2, whereas for IDi(I;O) it is the slow
growing hierarchy below that same ordinal. Arai [1] was the ﬁrst to analyse ID
theories in this light.
5 An Independence Result – Kruskal’s Theorem
Kruskal’s Theorem states that every inﬁnite sequence {Ti} of ﬁnite trees has an
i < j such that Ti is embeddable in Tj. By “ﬁnite tree” is meant a rooted (ﬁnite)
partial ordering in which the nodes below any given one are totally ordered. An
embedding of Ti into Tj is then just a one-to-one function from the nodes of Ti to
nodes of Tj preserving infs (greatest lower bounds).
Friedman showed this theorem to be independent of the theory ATR0 and went
on, in [6], [7], to develop a signiﬁcant extension of it which is independent of Π1
1-
CA0. The Extended Kruskal Theorem concerns ﬁnite trees in which the nodes
carry labels from a ﬁxed ﬁnite list {0, 1, 2, . . . , k}. By a more delicate argument,
he proved that for any k, every inﬁnite sequence {Ti} of ﬁnite ≤k-labelled trees
has an embedding Ti →Tj where i < j. However the notion of embedding is now
more complex. Ti →Tj means that there is an embedding f in the former sense,

Computing Bounds from Arithmetical Proofs
481
but which also preserves labels and satisﬁes the “gap condition” which states: if
node x comes immediately below node y in Ti, and if z is an intermediate node
strictly between f(x) and f(y) in Tj, then the label of z must be ≥the label of
f(y).
Both of these statements are Π1
1, but Friedman showed that they can be minia-
turized to an arithmetical Π0
2 form which still reﬂects the proof-theoretic strength
of the original results. See Simpson [11] for an excellent exposition.
The Miniaturized Kruskal Theorem for labelled trees runs as follows: For any
number c and ﬁxed k there is a number Kk(c) so large that for every sequence
{Ti} of ﬁnite ≤k-labelled trees of length Kk(c), and where each Ti is bounded
in size by ∥Ti∥≤c · (i + 1), there is an embedding Ti →Tj with i < j. In
fact we shall consider a slight variant of this - where the size restriction ∥Ti∥≤
c·(i+1) is weakened to ∥Ti∥≤c·2i. Friedman showed that, by slowing down the
sequence, 2i may be replaced by i + 1 without affecting the result’s proof theoretic
strength. An application of K¨onig’s Lemma proves that the miniaturized version is
a consequence of the full theorem.
In this section we give a proof that the Miniaturized Kruskal Theorem for la-
belled trees is independent of ID<ω. Since Π1
1-CA0 is conservative over ID<ω
for arithmetical sentences, both the miniaturized and the full Kruskal theorems are
therefore independent of Π1
1-CA0 . Our proof again serves to illustrate the fun-
damental role played by the B-hierarchy. It consists in showing directly that the
computation sequence for the “slow-growing” function Gτk(n) = |τk[n]| is bad
(i.e. has no embeddings). Since, by Wainer [13], Gτk(n) = Bτk−1(n) it follows
that for all k, n, Bτk−1(n) < Kk(ck(n)) for a suitably small ck(n). Therefore
from the last section one sees immediately that the function K cannot be provably
recursive in ID<ω.
5.1 ϕ-terms, trees and i-sequences
Henceforth we shall regard the ϕ-functions as function symbols and use them, to-
gether with the constants 0, ωj, to build terms. Each such term will of course denote
a (structured) tree ordinal, but it is important to lay stress, in this section, upon these
terms rather than the tree ordinals which they denote.
Deﬁnition 5.1. An i-term, for i > 0, is either ωi−1 or else of the form ϕ(i)
α (β)
(alternatively written ϕ(i)(α, β)) where β is an i-term and α is a j-term with j ≤
i + 1. (0-terms are just numerals ¯n built from 0 by repeated applications of the
successor ϕ(0) which has no subscript.) Note that each i-term may be viewed as
a ﬁnite labelled tree whose root has label i, whose left hand subtree is the tree α
and whose right hand subtree is the tree β. The tree ωi−1 consists of a single node

482
Stanley S. Wainer
labelled i, and the zero tree is the single node labelled 0. We often indicate the level
i of a term γ by writing γi. Thus as tree ordinals, ωi−1 ⪯γi ∈Ωi.
Deﬁnition 5.2. For each ≤i-term γ and i −1-term ξi−1 (assuming i > 1) we
denote the term ϕ(i−1)
γ
(ξ) by simply γ(ξ) (or ¯n + 1 if i = 1 and ξ = ¯n). With
association to the left, a typical i-term then would be written as
ν(ξir)(ξir−1) . . . (ξi1)(ξi)
where ν (the “indicator”) is either 0 or an ωj. In particular, the tree-ordinal τk may
be written
τk = ϕ(1)(ϕ(2)(. . . ϕ(k)(ω0, ωk−1) . . . , ω1), ω0)
and can then be denoted ω0(ωk−1)(ωk−2) . . . (ω0).
Deﬁnition 5.3. The computation sequence starting with τk and ﬁxed input n is the
sequence of 1-terms and numerals generated according to the computation rules for
the ϕ-functions, as follows:
γ = ν(ξir)(ξir−1) . . . (ξi1)(ξ1)
reduces (or rewrites) in one step to
δ =
⎧
⎨
⎩
ξir(ξir(ξir−1)) . . . (ξi1)(ξ1) if ν = 0,
ξij(ξir)(ξir−1) . . . (ξi1)(ξ1) if ν = ωij and ij < ij+1, . . . , ir,
¯n(ξir)(ξir−1) . . . (ξi1)(ξ1)
if ν = ω0.
If γ = ω0 it reduces to ¯n, then to n −1 etc. until it reaches 0 and stops. We
henceforth omit the overbar from numerals.
Deﬁnition 5.4. Let level i of the computation sequence be what remains af-
ter stripping away, from each term of the form γ(ξi−1) . . . (ξ1), the outermost
(ξi−1) . . . (ξ1), thus leaving γ alone. Now suppose γ occurs in level i of the com-
putation sequence from τk and n (thus γ is a j-term for some j ≤i). Then the
i-sequence from that occurrence of γ consists of all succeeding level i terms as far
as the ﬁrst zero. Write γ →i δ to indicate that γ precedes (or is) δ in the same
i-sequence. Note that there is just one 1-sequence – the computation sequence
itself.
Lemma 5.5. One can show, for each ﬁxed τk and n:
• The computation sequence starting with τk and n is ﬁnite.

Computing Bounds from Arithmetical Proofs
483
• The length of the computation sequence is greater than the number of succes-
sor ordinals encountered in the reduction process, i.e. greater than the cardi-
nality of the set of tree-ordinals τk[n], which by deﬁnition is exactly Gτk(n).
• The r-th member of the computation sequence from τk and n is bounded in
size by ck(n) · 2r where ck(n) is max(2k + 1, n).
• Each i-sequence is non-repeating and non-increasing with respect to the tree-
ordinals denoted.
5.2 The computation sequence is bad
Deﬁnition 5.6. γ →+ δ means that, as labelled trees, γ →δ (i.e. γ is embeddable
in δ, preserving labels, infs and satisfying the gap condition) and furthermore, if γ
is a j′-term, the embedding does not completely embed γ inside any j-subterm of
δ where j < j′.
Lemma 5.7. Fix τk and n. Then for each i with 1 ≤i ≤k + 1 and every term δ,
if γ →i δ and γ →+ δ then γ and δ are identical.
Proof. By induction on i from k + 1 down to 1, and within that an induction over
the term or tree δ, and within that a subinduction over γ.
For the basis i = k + 1, the k + 1-sequences are just descending sequences of
integers ≤n, so no term can be →+ embedded in any follower.
Now suppose 1 ≤i < k and assume the result for i+1. We proceed by induction
on the term δ. If δ = ωj or 0 and γ →+ δ the only possibility is γ is δ. Suppose
then, that δ is of the form ϕ(j)
α (β). Then γ cannot be ωj′ for any j′ ≥j because
γ →+ δ, and it cannot be ωj′ with j′ < j because none of its successors in the
i-sequence could then be j-terms. Thus γ is also of the form ϕ(j′)
α′ (β′). By γ →+ δ
we have j′ ≤j and by γ →i δ we have j′ ≥j, so j′ = j. Also, we cannot have
β′ →i δ for otherwise, by the gap condition, γ →+ δ implies β′ →+ δ, so by the
sub-induction hypothesis β′ and δ would be identical, and then γ would contain δ
as a proper sub-term, contradicting γ →δ.
The situation then, is this: γ = ϕ(j)
α′ (β′), δ = ϕ(j)
α (β), γ →i δ and γ →+ δ.
Furthermore β must be of the form ϕ(j)
αr . . . ϕ(j)
α2 ϕ(j)
α1 (β′) where, as tree ordinals,
α ≺αr ≺. . . ≺α2 ≺α1 ≺α′.
Now there are four possible ways in which γ can embed in δ, only two of which
actually happen.
Case 1. γ →+ β. Then γ →i δ →i β belong to the same i-sequence, so by the
induction hypothesis γ is then identical to β. Therefore the ordinal denoted by γ

484
Stanley S. Wainer
is strictly less than the ordinal of δ. But this is impossible because i-sequences are
non-increasing.
Case 2. γ →+ α. Then let η denote the smallest j-subterm of α such that
γ →+ η. This occurrence of η in the subscript α of δ must be created anew as
the i-sequence proceeds from γ to δ. The only way this can happen is that at some
intervening stage a ϕ(j)
α′′(β′′) occurs, where the indicator ν of α′′ is ωj. The next
stage replaces ν by β′′ and then β′′ reduces to a j-subterm of α which contains
η. Call this j-subterm η′. But this reduction from β′′ to η′, although it occurs at
the level of ϕ(j)-subscripts, must also occur in level i itself, and within the same
i-sequence. Hence γ →i ϕ(j)
α′′(β′′) →i β′′ and β′′ →i η′. Also γ →+ η′. Thus
by the induction hypothesis, η′ being a proper subterm of δ, we have γ identical to
η′, and since the i-sequence is ordinally non-increasing this means that the ordinal
of γ is not greater than the ordinal of β′′. This is impossible however, because
γ →i ϕ(i)
α′′(β′′) and so γ is ordinally greater than β′′.
Case 3. γ →+ δ where the embedding takes the root of γ to the root of δ
and α′ →β and β′ →α. By the gap condition, since β′ and β are j-terms, α
must be either a j-term or a j + 1-term and α′ a j′-term with j′ ≤j. But since
α′ comes before α in the reduction sequence, α′ cannot be a j′-term and α a j-
term where j′ < j. Therefore both α′ and α are j-terms. Now the only way in
which α′ could arise as a ϕ(j)-subscript is by means of an earlier diagonalization
at level i: ϕ(j)
ωj (ξ) →i ϕ(j)
ξ (ξ) followed by further reductions to ϕ(j)
α′ (β′) where
β′ = ϕ(j)
αr . . . ϕ(j)
α1 (ξ) and ξ reduces to α′. However this reduction between level-
j subscripts must occur also at level i and consequently β′ →i ξ →i α′ →i α.
Because of the gap condition, β′ →α implies β′ →+ α, and so by the induction
hypothesis, β′ and α are identical. But this means that α′ and α are identical, and
so γ and δ are identical at level i.
Case 4. γ →+ δ where the embedding takes the root of γ to the root of δ and
α′ →α and β′ →β. If j = i then α′ →i+1 α. Since, by the gap condition,
α′ →+ α, it follows from the induction hypothesis for i + 1 that α′ and α are
identical. If j < i then, as before, the reduction α′ →α takes place also in level i
so the sub-induction hypothesis implies again that α′ and α are identical. Therefore
γ and δ are identical too and this completes the proof.
Theorem 5.8. The computation sequence from τk and n is a bad sequence,
and therefore its length is bounded by the Kruskal function Kk(ck(n)). Hence
Gτk(n) < Kk(ck(n)).
Proof. Apply the lemma with i = 1, noting that if γ and δ are 1-terms then γ →δ
automatically implies γ →+ δ since 1-terms never get inserted inside numerals.

Computing Bounds from Arithmetical Proofs
485
Thus if γ came before δ in the computation sequence we could not have γ →δ
because then they would be identical, contradicting the previous lemma which says
there can be no repetitions.
Corollary 5.9. Neither Kruskal’s theorem for labelled trees, nor its miniaturized
version, is provable in Π1
1-CA0.
References
[1] T. Arai, A slow growing analogue of Buchholz’ proof, Annals of Pure and Applied
Logic 54 (1991), 101-120.
[2] S. Bellantoni, S. Cook, A new recursion theoretic characterization of the polytime
functions, Computational Complexity 2 (1992), 97-110.
[3] W. Buchholz, An independence result for (Π1
1-CA)+BI, Annals of Pure and Applied
Logic 33 (1987), 131-155.
[4] W. Buchholz, S. Feferman, W. Pohlers, W. Sieg, Iterated Inductive Deﬁnitions and
Subsystems of Analysis: Recent Proof Theoretical Studies, Springer Lecture Notes in
Mathematics 897, Springer-Verlag (1981).
[5] M.V. Fairtlough, S.S. Wainer, Hierarchies of provably recursive functions, in S. Buss
(Ed) Handbook of Proof Theory, Elsevier Science BV (1998), 149-207.
[6] H. Friedman, Beyond Kruskal’s theorem I - III, unpublished manuscripts, Ohio State
University (1982).
[7] H. Friedman, N. Robertson, P. Seymour, The metamathematics of the graph minor
theorem, in S.G. Simpson (Ed) Logic and Combinatorics, AMS Contemporary Mathe-
matics 65 (1987), 229-261.
[8] D. Leivant, Intrinsic theories and computational complexity, in D. Leivant (Ed) Logic
and Computational Complexity, Springer Lecture Notes in Computer Science 960,
Springer-Verlag (1995), 177-194.
[9] G.E. Ostrin, S.S. Wainer, Proof theoretic complexity, in H. Schwichtenberg, R.
Steinbr¨uggen (Eds) Proof and System Reliability, Kluwer Academic (2002), 369-397.
[10] G.E. Ostrin, S.S. Wainer, Elementary arithmetic, Annals of Pure and Applied Logic
133 (2005), 275-292.
[11] S.G. Simpson, Nonprovability of certain combinatorial properties of ﬁnite trees, in L.
Harrington, M. Morley, A. Scedrov, S.G. Simpson (Eds) Harvey Friedman’s Research
in the Foundations of Mathematics, North-Holland Studies in Logic (1985), 87-117.
[12] E. Spoors, Notes on EA(I;O), University of Leeds (2009).
[13] S.S. Wainer, Slow growing versus fast growing, Journal of Symbolic Logic 54 (1989),
608-614.

486
Stanley S. Wainer
[14] S.S. Wainer, Accessible recursive functions, Bulletin of Symbolic Logic 5 (1999), 367-
388.
[15] S.S. Wainer, R.S. Williams, Inductive deﬁnitions over a predicative arithmetic, Annals
of Pure and Applied Logic 136 (2005), 175-188.
[16] R.S. Williams, Finitely iterated inductive deﬁnitions over a predicative arithmetic,
Ph.D. dissertation, University of Leeds (2004).

 
 
 
 
ontosMathematicalLogic Volume 1 
 
 
Adam Olszewski, Jan Woleński, Robert Janusz (Eds.) 
 
Church’s Thesis After 70 Years 
 
 
 
Church's Thesis (CT) was first published by Alonzo Church in 1935. CT is a proposition that 
identifies two notions: an intuitive notion of a effectively computable function defined in natural 
numbers with the notion of a recursive function. Despite of the many efforts of prominent 
scientists, Church's Thesis has never been falsified. There exists a vast literature concerning 
the thesis. The aim of the book is to provide one volume summary of the state of research on 
Church's Thesis. These include the following:  different formulations of CT, CT and intuitionism, 
CT and intensional mathematics, CT and physics, the epistemic status of CT, CT and 
philosophy of mind, provability of CT and CT and functional programming. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
ontos verlag 
Frankfurt • Paris • Lancaster • New Brunswick 
 
2006. 551pp. 
Format 14,8 x 21 cm 
Hardcover EUR 129,00 
ISBN: 978-3-938793-09-0 
 
 
P.O. Box 1541 • D-63133 Heusenstamm bei Frankfurt 
www.ontosverlag.com • info@ontosverlag.com 
Tel. ++49-6104-66 57 33 • Fax ++49-6104-66 57 34 

