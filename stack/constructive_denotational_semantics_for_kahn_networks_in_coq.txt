17
A constructive denotational semantics for
Kahn networks in Coq
Christine Paulin-Mohring
INRIA Saclay - Ë†Ile-de-France and UniversitÂ´e Paris-Sud
Abstract
Semantics of programming languages and interactive environments for
the development of proofs and programs are two important aspects of
Gilles Kahnâ€™s scientiï¬c contributions. In his paper â€œThe semantics of a
simple language for parallel programmingâ€ [11], he proposed an interpre-
tation of (deterministic) parallel programs (now called Kahn networks)
as stream transformers based on the theory of complete partial orders
(cpos). A restriction of this language to synchronous programs is the
basis of the data-ï¬‚ow Lustre language which is used for the development
of critical embedded systems [14, 10].
We present a formalization of this seminal paper in the Coq proof
assistant [4, 15]. For that purpose, we developed a general library for
cpos. Our cpos are deï¬ned with an explicit function computing the least
upper bound (lub) of an increasing sequence of elements. This is diï¬€erent
from what Kahn developed for the standard Coq library where only
the existence of lubs (for arbitrary directed sets) is required, giving no
way to explicitly compute a ï¬xpoint. We deï¬ne a cpo structure for the
type of possibly inï¬nite streams. It is then possible to deï¬ne formally
what is a Kahn network and what is its semantics, achieving the goal of
having the concept closed under composition and recursion. The library
is illustrated with an example taken from the original paper as well as
the Sieve of Eratosthenes, an example of a dynamic network.
17.1 Introduction
Semantics of programming languages and interactive environments for
the development of proofs and programs are two important aspects of
From Semantics to Computer Science Essays in Honour of Gilles Kahn, eds Yves Bertot,
GÂ´erard Huet, Jean-Jacques LÂ´evy and Gordon Plotkin. Published by Cambridge University
Press. c
âƒCambridge University Press 2009.
383
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

384
C. Paulin-Mohring
Gilles Kahnâ€™s scientiï¬c contributions. In his paper â€œThe semantics of a
simple language for parallel programmingâ€ [11], he proposed an interpre-
tation of (deterministic) parallel programs (now called Kahn networks)
as stream transformers based on the theory of complete partial orders
(cpos). A restriction of this language to synchronous programs is the
basis of the data-ï¬‚ow Lustre language [14, 10], which is used now for the
development of critical embedded systems. Because of the elegance and
generality of the model, Kahn networks are also a source of inspiration
for extensions of the data-ï¬‚ow synchronous paradigm to higher-order
constructions [7] or to more permissive models of synchrony [8].
We present a formalization of this seminal paper in the Coq proof
assistant [4, 15]. For that purpose, we developed a general library for
cpos. Our cpos are deï¬ned with an explicit function computing the least
upper bound (lub) of a monotonic sequence of elements. This is diï¬€erent
from what Kahn developed for the standard Coq libraries where only
the existence of lubs is required, giving no way to explicitly compute a
ï¬xpoint. However, Kahnâ€™s library was intended as the background for a
computer formalisation of the paper â€œConcrete Domainsâ€ by Kahn and
Plotkin [13] and it covers general cpos with the existence of a lub for
arbitrary directed sets whereas our work only considers Ï‰-cpos with lubs
on monotonic sequences, which is a suï¬ƒcient framework for modeling
Kahn networks.
We deï¬ne a cpo structure for the type of possibly inï¬nite streams.
This is done using a coinductive type in Coq with two constructors,
one for adding an element in front of a stream, the second constructor
add a silent step Eps. From the structural point of view, our streams
are inï¬nite objects; this is consistent with the fact that these streams
are models for communication links which are continuously open even
if there is no traï¬ƒc on the line. However, we identify the empty stream
with an inï¬nite stream of Eps constructors, so our data type models both
ï¬nite and inï¬nite streams. We deï¬ne the preï¬x order on this data type
and the corresponding equality. We also develop useful basic functions:
the functions for head, tail and append used by Kahn [11], but also a
ï¬ltering and a map function.
It is then possible to deï¬ne formally what is a Kahn network and
what is its semantics, achieving the goal of having the concept closed
under composition and recursion. A Kahn network will be deï¬ned by
a concrete set of edges corresponding to links in the network, each one
associated with the type of the objects which are transmitted on that
link. With each noninput edge is associated a node which is a continuous
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
385
function producing a stream of outputs from streams given as inputs.
This type of Kahn networks has a natural cpo structure. The semantics
of a Kahn network is obtained in the following way: we provide streams
for the input edges of the system, then the system is interpreted as an
equation on the streams corresponding to the traï¬ƒc on all the edges, seen
as a continuous function. The semantics of the network is the ï¬xpoint
of this continuous function. We prove that this solution is a continuous
function both of the network and of the input streams. By selecting the
appropriate outputs, a system can be interpreted as a new node to be
used in another system. Furthermore, the continuity with respect to the
system itself gives the possibility of recursively deï¬ning a system.
Our library is illustrated with an example taken from the original
paper as well as the Sieve of Eratosthenes, an example of a dynamic
network, recursively deï¬ned.
Outline The remaining part of the introduction gives the main
notations used in this paper. Section 17.2 recalls Kahnâ€™s approach
in [11], which introduces cpos as a natural structure for the semantics
of a simple parallel language. Section 17.3 introduces our deï¬nition of
cpo structures in Coq. It is based on a structure of ordered types. We
deï¬ne the cpos of monotonic and continuous functions as well as several
constructions for product of cpos. Section 17.4 introduces the type of
possibly inï¬nite streams and deï¬nes a cpo structure on it (in particular
a lub function). We start with the simpler case of the ï¬‚at cpo. We deï¬ne
a general function on the cpo of streams computing the value depending
on the head and tail of the stream (and giving the empty stream in case
the input is empty). We derive from this operator the constructions for
head, tail and append as well as functionals for mapping a function on
all elements of the stream or ï¬ltering the elements of a stream with
respect to a boolean condition. We derive a cpo structure for natural
numbers as a particular case of streams. Section 17.5 deï¬nes a type for
Kahn networks and the associated semantics. Section 17.6 illustrates
our library with two examples, one taken from the original paper [11],
the other is the Sieve of Eratosthenes.
Notation In this paper, we use mathematical notations close to the
Coq notations.
The expression A â†’B represents both the type of functions from type
A to type B and the proposition: â€œA implies Bâ€. The arrow associates
to the right: A â†’B â†’C represents A â†’(B â†’C).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

386
C. Paulin-Mohring
The expression âˆ€x, P represents the proposition â€œfor all x, Pâ€ or the
type of dependent functions which associate with each x an object of
type P. We can annotate a variable with its type and put several binders
as in âˆ€(x y : A)(z : B), P which represents the property: â€œfor all x and
y of type A and z of type B, P holdsâ€.
The function which maps a variable x of type A to a term t is written
fun x â‡’t or fun x : A â‡’t. We can introduce several binders at the same
time.
We write c x1 . . . xn
def
= t to introduce c as an abbreviation for the term
fun x1 . . . xn â‡’t. We write x = y for (polymorphic) deï¬nitional equality
in Coq (i.e. terms that are structurally equal). We use the notation
x == y for a speciï¬c equivalence relation associated with the type of x
and y, deï¬ned as a setoid equality.1
We shall also use the Coq notation {x : A|P} for the type of pairs
(a, p) with a of type A and p a proof of P[a/x] and {x : A&{y : B|P}}
for the type of triples (a, b, p) with a of type A, b of type B and p a proof
of P[a/x, b/y].
17.2 From a simple parallel languages to cpos
In [11], Kahn proposes an algol-like language to describe parallel system.
Each process is deï¬ned as a procedure with input and output parameters
which are interpreted as channels. In the body of the procedure, there
is a possibility to wait for a value on an input parameter or to send
a value on an output parameter. Global channels can be declared, the
processus can be instantiated and executed in parallel. The idea is that
each channel correponds to a ï¬fo in which values can be stored or read.
There is no bound on the size of the ï¬fo and a process can be blocked
waiting a value on an empty channel.
More precisely a Kahn network is built from autonomous computing
stations linked together. The stations exchange information through
communication lines. The assumptions are that a computing station
receives data from input lines, computes using its own memory and
produces result on some of the output lines. The communication lines
1 In Type theory, there is a natural polymorphic equality called the Leibniz equality
which corresponds to convertibility and which allows rewriting in an arbitrary
context. This equality is sometimes too strong. It is also possible to associate with
a type a speciï¬c equivalence relation. The type together with the relation is called
a setoid. The relation can be used pretty-much like an equality for rewriting, but
only under a context built using operators which are proved to preserve the setoid
relation. Coq oï¬€ers facilities to manipulate the setoids.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
387
are the only medium of communication between stations and the
transmission of data on these lines is done in a ï¬nite amount of time.
With each communication line, we associate the type of data which
transit on that line. Each node can use the history of the inputs to
produce an output, so it can be seen as a function from the streams
of inputs to the streams of outputs. This function is continuous, which
means that an output can be delivered without waiting for an inï¬nite
amount of information on the inputs lines.
A Kahn network is represented as an oriented graph. The nodes are
the computing stations and the edges are the communication lines. We
distinguish the input lines which have no source node. The graphical
representation of the example in Kahnâ€™s paper is given in Figure 17.1.
h0
f
h1
g
Z
Y
T1
T2
X
Fig. 17.1. A simple example of Kahn network.
In Kahn semantics, we look at the sequence of values that will be sent
on each channel. This is a possibly inï¬nite sequence (a stream). Locally
each node is interpreted as a function taking as input a stream for each
input edge and computing a stream for each output edge.
The system itself will behave as the solution of a set of equations
deï¬ning the stream of values on the channels (one equation for each
node). In our example, the system of equations will be:
X = f(Y, Z)
Y = h0(T1)
Z = h1(T2)
T1 = g1(X)
T2 = g2(X)
This is a recursive deï¬nition. In order to ensure the existence of a
solution, we use a cpo structure on the set of streams (with the preï¬x
order) and we prove that each node corresponds to a monotonic and
continuous function.
Now if we have a system and we distinguish input and output edges,
the solution is itself a continuous function from inputs to outputs so
behaves like a node. This is an essential property for a modular design
of systems. It gives also the possibility to recursively deï¬ned a system,
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

388
C. Paulin-Mohring
like the Sieve of Eratosthenes which we describe in Section 17.6.2 and
which corresponds to the network in Figure 17.2.
fdiv
sift
app
X
Y
o
i
Fig. 17.2. A Kahn network for the Sieve of Eratosthenes.
The precise deï¬nition of nodes in the previous examples will be given
in Section 17.6.
17.3 Formalizing cpos constructively
The basic structure used for the interpretation of Kahn networks is the
Ï‰-complete partial order. We developed a Coq library of general results
on Ï‰-cpos.
17.3.1 Deï¬nition
An Ï‰-cpo is a type D with a partial order â‰¤, a least element (usually
written âŠ¥) and a least-upper bound (written lubh) for any monotonic
sequence h of elements in D (h : nat â†’D such that âˆ€nm, n â‰¤m â†’
h n â†’h m).
An Ï‰-cpo is actually a weaker structure than ordinary cpos where lubs
exist for any directed set of elements. However, Ï‰-cpos are suï¬ƒcient for
the construction of ï¬xpoints. In the following we refer to Ï‰-cpos simply
as cpos.
17.3.1.1 Ordered structure
We deï¬ne the type ord of ordered structures. An object in the type ord
is a dependent record with a type A, a binary relation â‰¤on A, and a
proof that this relation is reï¬‚exive and transitive.
An example of an ordered structure is the type nat of natural numbers
with the usual order. In the following, we shall abusively write nat for
the object of type ord corresponding to this structure.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
389
Notations When O is an ordered structure, we write x : O to mean
that x is an element of the carrier of O. The coercion mechanism in Coq
allows us to support this abuse of notation: whenever a type is expected
and an ordered structure O is provided, Coq automatically coerces the
term O to its carrier.
When O is an ordered structure and x, y : O, the Coq notation
mechanism allows us to write x â‰¤y to express that x and y are in the
relation associated with the ordered structure O. We shall write x â‰¤O y
when we want to make the ordered structure explicit.
Equality We deï¬ne an equality on an ordered structure by:
x == y
def
= x â‰¤y âˆ§y â‰¤x;
this is obviously an equivalence relation.
Order on functions Given an ordered structure O and a type A, there
is a natural order on the type A â†’O of functions from A to O, called
the pointwise order, which is deï¬ned by f â‰¤Aâ†’O g
def
= âˆ€x, f x â‰¤O g x.
We write A
oâ†’O for the corresponding ordered structure.
Monotonic functions Given two ordered structures O1 and O2, we
introduce the type of monotonic functions from O1 to O2. Elements of
this type are records with a function f of type O1 â†’O2 (formally from
the carrier of O1 to the carrier of O2) and a proof that this function
is monotonic. With the pointwise order on functions, this type is an
ordered structure written O1
m
â†’O2.
If an object f has type O1
m
â†’O2, it is formally a pair with a function
and a proof of monotonicity. In Coq, we introduce a coercion from
f to a function from O1 to O2, such that we can write (f x) in a
way consistent with mathematical practice. We consequently have the
following property:
âˆ€(f : O1
m
â†’O2)(x y : O1), x â‰¤y â†’f x â‰¤f y.
We also proved that any monotonic function preserves equality.
The composition of two monotonic functions is monotonic: when f :
O1
m
â†’O2 and g : O2
m
â†’O3, we deï¬ne g@f of type O1
m
â†’O3 the
monotonic function such that (g@f) x = g (f x)
Notation fun x
m
â‡’t. If t is an expression of type O2 depending on x of
type O1, we write fun x
m
â‡’t for the object f in Coq of type O1
m
â†’O2,
which is a monotonic function such that f x = t. In Coq, the object
f is formally a pair built from the function fun x â‡’t and a proof
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

390
C. Paulin-Mohring
of monotonicity. The (informal) notation fun x
m
â‡’t hides the proof of
monotonicity and helps us to insist on the functional behavior of f. In
our Coq development we try to systematically deï¬ne objects in O1
m
â†’O2
using combinators like the composition of monotonic functions in order
to get proof of monotonicity for free relying on the type system. After
the deï¬nition of such an object f, we systematically prove a (trivial)
lemma f x = t which captures the functional behavior of the monotonic
function. This lemma is useful for rewriting the expressions involving f.
17.3.1.2 Cpo structure
A cpo structure is deï¬ned as a record which contains:
â€¢ an ordered structure O;
â€¢ a least element âŠ¥of type O;
â€¢ a least upper-bound function lub for monotonic sequences;
the constant lub has type: (nat
m
â†’O) â†’O;
â€¢ proofs of the following properties:
â€“ âˆ€x : O, âŠ¥â‰¤x
â€“ âˆ€(f : nat
m
â†’O)(n : nat), fn â‰¤lub f
â€“ âˆ€(f : nat
m
â†’O)(x : O), (âˆ€n, fn â‰¤x) â†’lub f â‰¤x.
A cpo structure is implicitly identiï¬ed with the underlying ordered
structure. In particular, if D1 and D2 are two cpo structures, we can
write D1
m
â†’D2 for the ordered structure of monotonic functions from
D1 to D2.
Continuity It is easy to show from the properties of lub that given D1
and D2 two cpo structures, F : D1
m
â†’D2 a monotonic function from D1
to D2 and f a monotonic sequence on D1, we have
lub (F@f) â‰¤F (lub f)
We say that F is continuous whenever the other direction is true,
namely:
âˆ€f : nat
m
â†’D1, F (lub f) â‰¤lub (F@f).
We write D1
câ†’D2 for the ordered structure of continuous functions.
When g has type D2
câ†’D3 and f has type D1
câ†’D2, we write g@ f
the element of D1
câ†’D3 which corresponds to the composition of f and
g, ie such that (g@ f) x = g (f x).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
391
17.3.2 Cpo constructions
The structure of cpos is preserved by the usual constructions of functions
and products. In this part we show constructions for the cpos of
functions, monotonic functions and continuous functions as well as the
product of two cpos, of an arbitrary family of cpos and the k-times
product Dk of a cpo D.
17.3.2.1 Functional constructions
Given a cpo structure D and a type A, we can deï¬ne a cpo structure on
the set of functions from A to D using a pointwise construction for âŠ¥
and lub:
âŠ¥Aâ†’D
def
= fun x â†’âŠ¥D
lubAâ†’D h
def
= fun x â‡’lubD(fun n
m
â‡’h n x)
We write A
O
â†’D for the cpo of simple functions from A to D.
Given an ordered type O, it is easy to show that âŠ¥Oâ†’D is a monotonic
function and that lub preserves monotonicity. So we have a cpo structure
written O
M
â†’D on the type of monotonic functions.
If D1 and D2 are two cpo structures, then because âŠ¥D1
m
â†’D2 is a
continuous function and lub preserves continuity, we also have a cpo
structure on continuous functions from D1 to D2. We write D1
Câ†’D2
for this cpo structure.
17.3.2.2 Product constructions
We formalized other constructions on cpos corresponding to products.
Binary product The binary product D1 Ã— D2 of two cpo structures
has a cpo structure written D1 âŠ—D2.
âŠ¥D1âŠ—D2
def
= (âŠ¥D1, âŠ¥D2)
lubD1âŠ—D2 h
def
= (lubD1(fun n
m
â‡’fst (h n)), lubD2(fun n
m
â‡’snd(h n)))
The projection and pairing functions are continuous, we have deï¬ned
â€¢ FST : âˆ€D1D2, D1 âŠ—D2
Câ†’D1
SND : âˆ€D1D2, D1 âŠ—D2
Câ†’D2;
â€¢ PAIR : âˆ€D1D2, D1
Câ†’D2
Câ†’D1 âŠ—D2.
We also deï¬ned functions for currying and uncurrying
â€¢ CURRY : âˆ€D1D2D3, ((D1 âŠ—D2)
Câ†’D3)
Câ†’D1
Câ†’D2
Câ†’D3,
â€¢ UNCURRY : âˆ€D1D2D3, (D1
Câ†’D2
Câ†’D3)
Câ†’(D1 âŠ—D2)
Câ†’D3.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

392
C. Paulin-Mohring
Indexed product  D For modeling Kahn networks, it is useful to
have a generalized product over an arbitrary number of cpos.
We take a set I of indexes and a family D of cpos indexed by I, that
is, D : I â†’cpo. The cpo structure for the product written  D is
just a dependent generalization of the function type I
oâ†’D in which
the domain D may depend on the index. When D is a type expression
depending on a free variable i, we write 
i D for (fun i â‡’D)
â€¢ Carrier: âˆ€i : I, D i
â€¢ Order: x â‰¤Î D y
def
= âˆ€i, x i â‰¤D i y i
â€¢ Least element: âŠ¥Î D
def
= fun i â‡’âŠ¥D i
â€¢ Least upper bound: lubÎ D h
def
= fun i â‡’lubD i(fun n
m
â‡’h n i).
The interesting constructions on that structure are listed here.
â€¢ A projection function PROJ of type: âˆ€i : I, ( D)
Câ†’D i.
â€¢ Given two indexed families D and Dâ€² over the set I, the mapping
MAPi of a continuous function on the elements of an indexed product
has type (âˆ€i, Di
Câ†’Dâ€²i) â†’ D
Câ†’ Dâ€² and is deï¬ned such that
MAPif p i = f i (p i).
â€¢ An operation to lift the indexes. Assume that we have two sets of
indexes I and J, a family D of cpos indexed by I, and a function
f : J â†’I. We deï¬ne a continuous function LIFTi of type  D
Câ†’

j D (f j) such that LIFTi p j = p (f j). It allows to select, reorganize
or duplicate the elements in the product.
Finite product Dk
It is also useful to have a ï¬nite product on the
same cpo D. Given k : nat, one possibility is to take the function space
{i|i < k}
O
â†’D, but in that case we will have to deal with the subset
type in Coq which is not always convenient. Instead we take the type
nat â†’D but instead of the pointwise order for functions, we introduce
an order up-to k: f â‰¤g
def
= âˆ€n, n < k â†’f n â‰¤g n. We write k â†’D for
the cpo structure with this order. The least element is deï¬ned pointwise.
For the lub, there is a small diï¬ƒculty. The natural deï¬nition would be:
lubkâ†’D h n = lubD (fun p
m
â‡’h p n)
But (fun p â‡’h p n) is monotonic only when n < k. However, the value
of lubkâ†’D h n for k â‰¤n is meaningless so we can choose an arbitrary
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
393
one. Consequently we introduce hâ€² such that hâ€² p n = h p n when n < k
and âŠ¥otherwise. Then taking:
lubkâ†’D h n = lubD (fun p
m
â‡’hâ€² p n)
gives us the expected properties.
17.3.3 Fixpoints
Given a cpo structure D and a monotonic function F of type D
m
â†’D,
we can deï¬ne a monotonic function (iter F) of type nat
m
â†’D such that
iterF 0 = âŠ¥and iter F (n + 1) = F (iter F n).
We deï¬ne the ï¬xpoint of F as the least-upper bound of this sequence:
fixpF
def
= lub (iter F).
The constant fixp has type (D
m
â†’D) â†’D. It is itself a monotonic
function.
It is easy to show that fixpF â‰¤F (fixp F). The equality fixp F ==
F (fixp F) is provable under the assumption that F is a continuous
function.
We can also show that fixp is a continuous function from the cpo
(D
Câ†’D) of continuous functions on D to D. Consequently, we are able
to deï¬ne FIXP of type (D
Câ†’D)
Câ†’D, such that for all F of type D
Câ†’D:
FIXPF = fixp (fun x
m
â‡’F x)
FIXPF == F (FIXP F).
Scottâ€™s induction principle We proved Scottâ€™s induction principle. A
predicate is said to be admissible if it is true for the lub of a monotonic
sequence when it is true for all the elements of the sequence:
admissible P
def
= âˆ€f : nat
m
â†’D, (âˆ€n, P (f n)) â†’P(lub f).
Scottâ€™s induction principle states that when a predicate is admissible,
if it is true for âŠ¥and preserved by a monotonic function F : D
m
â†’D,
then it is true for the ï¬xpoint of F:
âˆ€P, admissibleP â†’P âŠ¥â†’(âˆ€x, P x â†’P (F x)) â†’P (fixpF)
Minimality It is easy to prove that the ï¬xpoint of a monotonic function
is the minimal solution for the equation. Namely:
âˆ€(F : D
m
â†’D)(x : D), F x â‰¤x â†’fixpF â‰¤x.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

394
C. Paulin-Mohring
17.4 The cpo of streams
We now want to deï¬ne a cpo structure for concrete data types. Before
developing the construction for streams, we show the simpler case of a
ï¬‚at cpo, which illustrates the main ideas.
17.4.1 The ï¬‚at cpo
The simplest nontrivial (i.e. not reduced to âŠ¥) cpo is the ï¬‚at domain.
Given a type A, we add an extra element âŠ¥and we have x â‰¤b if and
only if x = âŠ¥or x = b.
A natural solution could be to take as the carrier for this cpo the
option type on A with values either None or Some a with a : A.
Inductive option (A:Type) : Type :=
None :
option A | Some : A â†’option A
The constant None will be the least element. However we cannot deï¬ne
constructively a least upper bound. Indeed, given an increasing sequence
of elements in our domain, we would have to decide whether all the
elements are âŠ¥in which case the lub is âŠ¥or if there exists an element
in the sequence which is of the form Somea in which case the lub is
this element. Because we follow a constructive approach in Coq where
functions correspond to algorithms, we cannot deï¬ne a function which
takes such a decision.
The computation of lubs is possibly an inï¬nite process, a solution to
represent inï¬nite computations in Coq is to use coinductive types. This
is the approach taken by Capretta [6] for dealing with general recursive
functions in Coq. The solution is to introduce:
CoInductive flat (A:Type) : Type :=
Eps : flat A â†’flat A | Val : A â†’flat A
A value in type flat is either ï¬nite of the form
n



Eps (. . . (Eps(Val a)) . . .)
(written Epsn (Val a)) in which case it represents the value a (with extra
Eps steps corresponding to silent computations) or an inï¬nite object
Epsâˆcoinductively deï¬ned by Epsâˆ= EpsEpsâˆcorresponding to a
diverging computation.
Epsâˆwill be our least element and we need to identify all the represen-
tations of the value a ignoring the Eps constructors.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
395
In order to achieve that, we deï¬ne co-inductively the order on the ï¬‚at
domain with these three rules:
x â‰¤y
Eps x â‰¤Eps y
x â‰¤Val a
Epsx â‰¤Vala
y = Epsn(Val a)
Val a â‰¤y
From this deï¬nition we proved reï¬‚exivity, transitivity and properties like
Epsâˆâ‰¤x or Val a â‰¤x â†’x == Val a.
We can now look at the construction of lubs. We have a monotonic
sequence h of elements in flatA and we want (constructively) to build
the least upper bound which can be either âŠ¥or a value.
If x is an element of flatA, we write [x]n for the same element but
removing the n-th ï¬rst Eps constructors (or less if we ï¬nd a value before).
We have x == [x]n. Now in order to build the least upper bound, we
look at h 0. If we ï¬nd a value then we have our bound; if not, we produce
an Eps and we continue by looking at [h 0]1; [h 1]1 if we ï¬nd a value then
we are done, if the elements start with an Eps then we produce an Eps in
the least upper bound and we continue. At the n-th step we look at the
sequence [h 0]n; [h 1]n; . . . ; [h n]n, we try to ï¬nd a direct value, otherwise
we produce an Eps step and continue. This mechanism is illustrated in
Figure 17.3; the Coq formalization will be given in the more involved
case of streams. If one of the elements (h k) in the sequence is a value,
h 0
0
Eps
1
Eps
2
Eps
Epsâˆ
h1
Eps
Eps
Eps
Vala
h2
Eps
Vala
lubh
0
Eps
1
Eps
2
Vala
Fig. 17.3. Computation of lubs in a ï¬‚at domain.
then there exists n such that [h k]n = Val a so we will eventually ï¬nd
this value before the p-th step with k â‰¤p and n â‰¤p.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

396
C. Paulin-Mohring
17.4.2 Streams
We now look at the case of streams which is developed following the
same kind of reasoning.
17.4.2.1 Deï¬nition
The type of streams is co-inductively deï¬ned as:
CoInductive Str (A:Type):Type :=
Eps : Str A â†’Str A | cons : A â†’Str A â†’Str A
As before Epsâˆcan be coinductively deï¬ned by Epsâˆ= Eps Epsâˆ. It
represents the empty stream and is also our âŠ¥element. We deï¬ne a
function [ ]n removing Eps in front of the stream by induction on n and
case analysis on the stream.
[s]0 = s
[Eps x]n+1 = [x]n
[consa x]n+1 = consa x
17.4.2.2 Order
The order we consider on streams is the preï¬x order, we must also ignore
the Eps steps which correspond to silent computations.
x â‰¤y
Eps x â‰¤y
[y]n = consa z
x â‰¤z
consa x â‰¤y
The idea is that in order to show that x â‰¤y, there are two cases: if x is
Epsxâ€² then we try to show xâ€² â‰¤y, if x is (consa xâ€²) then after a ï¬nite
number of Eps, y should be of the form (cons a yâ€²) and we need to show
that xâ€² is less than yâ€². We do not know how many Eps steps we should
remove so we cannot decide whether x â‰¤y or not, and similarly we
cannot decide whether a stream is ï¬nite or not. This corresponds well
to the vision of the streams as a model of asynchronous communication
links: it is not possible to know if more information will arrive and when.
If we want to transmit a ï¬nite number of elements, we have to decide
on a special character to indicate the end of the data.
Decidability of the empty stream is not required for the development
we want to perform and it is the price to pay for having an explicit
computation of lubs and ï¬xpoints.
We can prove the expected properties of the order besides reï¬‚exivity
and transitivity :
â€¢ Epsâˆâ‰¤x
â€¢ Â¬(consa x â‰¤Epsâˆ)
â€¢ consa x â‰¤consb y â†”a = b âˆ§x â‰¤y
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
397
Equality As in other ordered structures, equality on streams x == y is
deï¬ned as x â‰¤yâˆ§y â‰¤x. It is important to distinguish this equality from
intensional equality in Coq: x = y means that x and y are structurally
equal. For instance we have x == Eps x for all x while x = Eps x is only
true for the Epsâˆstream.
Simulation properties Coinductive deï¬nitions in Coq correspond to
greatest ï¬xpoints. The primitive way to build a proof of x â‰¤y is to
use ï¬xpoint deï¬nitions in Coq, which should be guarded. This guarded
condition is very syntactic and not always convenient to use in tactics.
An alternative way is to deï¬ne a co-induction principle which in this
case corresponds to a simulation principle.
We introduce a principle which does not rely on the intensional
representation of streams. We have to ï¬nd a relation R on streams that
is compatible with equality on streams and such that when R x y holds
and x is equal to a stream consa xâ€² then y is also equal to consa yâ€² and
R xâ€² yâ€² also holds. If such an R exists then it is included in the relation
â‰¤on streams. This principle can be written as follows:
âˆ€x y z t, x == z â†’y == t â†’R x y â†’R z t
âˆ€a x y, R (cons a x) y â†’âˆƒz, y == consa z âˆ§R x z
âˆ€x y, R x y â†’x â‰¤y
From this we can derive a principle which says that in order to prove x â‰¤
y, it is enough to prove it in the particular case where x == consa xâ€².
This principle is in practice suï¬ƒcient in order to avoid reasoning on
whether x is the empty stream or not.
17.4.2.3 Least upper bounds
Destructuring
streams We
introduce
a
predicate
is cons
on
streams. It is deï¬ned as an inductive predicate with two constructors
is consx â†’is cons (Eps x) and is cons (consa x). We can prove
that is consx is equivalent to âˆƒa s, x == consa s.
In Coq is cons is a noninformative proposition: we know the existence
of a and s but we cannot use a and s to compute a value. However, if
we know that a stream contains a cons constructor, the algorithm that
removes Eps constructors will eventually stop on a cons constructor. In
Coq, we deï¬ned a function uncons of type:
âˆ€x, is cons x â†’{a : A&{s : Str A|x == consa s}}.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

398
C. Paulin-Mohring
From the computational point of view, this function takes a (nonempty)
stream as input and returns a pair (a, s) of its head and tail plus the
proof that x == consa s. Technically, the function uncons is deï¬ned in
Coq by a ï¬xpoint doing a structural induction on the proof of (is consx)
and a case analysis on the structure of x.
Building lubs The construction of lubs for monotonic sequences of
streams is a generalization of the idea used in the case of ï¬‚at domains.
Consider a monotonic sequence h of streams, and a natural number
n. We can look at the ï¬rst constructor of h 0 . . .h (n âˆ’1). Either we
only have Eps steps or there exists m < n such that h m = consa s.
In this last case, the lub will start by cons a and we know that for all
p â‰¥m, the stream h p is equal to consa sâ€² (because h m â‰¤h p) such that
we can extract a subsequence of h corresponding to the tails of h p and
recursively ï¬nd the lub of this sequence. Following this idea, we built a
function fCon which takes as argument a sequence of stream h and a
natural number n and either answers that all h m starts with Eps for
all m < n or ï¬nd an element a and another sequence hâ€² such that there
exists m < n such that each h (k + m) is equal to consa (hâ€² k). Formally
the Coq type of fCon is:
âˆ€(h : nat
m
â†’StrA)(n : nat),
{a : A & {hâ€² : nat
m
â†’Str A|
âˆƒm, m < n âˆ§âˆ€k, h (k + m) == cons a (hâ€² k)}}
+ {âˆ€m, m < n â†’h m = Eps( )}
This function is deï¬ned by structural recursion on n.
We write [h]
def
= fun n
m
â‡’[h n]1 for the sequence h where we have
removed the ï¬rst Eps step of each stream, our lub function is deï¬ned
with a coï¬xpoint:
CoFixpoint lubn (h:nat
m
â†’Str A) (n:nat) : Str A :=
match fCon h n with
(a,hâ€™,_) â‡’cons a (lubn hâ€™ 1)
|
â‡’Eps (lubn[h] (n+1))
end
This recursive function is accepted by Coq because it is a guarded
ï¬xpoint: any recursive call in the body appears under a constructor of
the type of streams.
The lub of a stream sequence h is just deï¬ned as (lubnh 1). We proved
that this is the lub of the sequence of streams.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
399
17.4.2.4 Useful functions on streams
In his paper, Gilles Kahn introduced several functions to manipulate
streams: taking the ï¬rst element, the stream without the ï¬rst element
or the concatenation of the ï¬rst element of a stream to another.
All these functions are proved to be continuous. In our development,
we derive them from the more general scheme of a function from streams
to streams deï¬ned by case analysis on the structure of the input stream.
If the input is equal to consa x then the result is computed from a and
x by a given function F, if it is Epsâˆthen the result is Epsâˆ.
Let a parameter function F have type A â†’StrA
m
â†’StrB. The
function that we named case is coinductively deï¬ned by:
caseF (Eps x) = Eps (caseF x)
caseF (consa x) = F a x
It is easy to check that caseF âŠ¥== âŠ¥and that x == consa y â†’
caseF x == F a y.
When F is a continuous function of type A â†’StrA
Câ†’StrB, then
case(fun a s
câ‡’F a s) is also a continuous function of type StrA
Câ†’
StrB. The case construction is also continuous with respect to the
argument F, such that we can build CASE of type (A
Oâ†’StrA
Câ†’
StrB)
Câ†’StrA
Câ†’StrB.
From this scheme, we derive the following functions:
â€¢ first has type Str A â†’Str A and is deï¬ned by:
first
def
= case(fun a s
m
â‡’consa âŠ¥)
â€¢ rem has type Str A â†’StrA and is deï¬ned by:
rem
def
= case(fun a s
m
â‡’s)
â€¢ app has type Str A â†’StrA â†’StrA and is deï¬ned by:
appx y
def
= case(fun a s
m
â‡’consa y) x.
We remark that app x y only takes the ï¬rst element of x, and adds
it in front of y. It corresponds to the â€œfollowed byâ€ operation in
synchronous data-ï¬‚ow languages and not to the usual append function
on lists which cannot be deï¬ned in that framework.
We also build their continuous versions: FIRST and REM of type StrA
Câ†’
StrA and APP of type Str A
Câ†’Str A
Câ†’Str A
We proved the properties which are given by Kahn [11]:
firstâŠ¥== rem âŠ¥= app âŠ¥x == âŠ¥
firstx == appx âŠ¥
x == app (firstx) (rem x)
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

400
C. Paulin-Mohring
Instead of x == âŠ¥âˆ¨rem (app x y) == y in Kahn [11], we proved that
is consx â†’rem(app x y) == y.
We also proved that app (firstx) y == app x y.
Bisimulation revisited Using the rem function, it is possible to
express a bisimulation principle. In order to prove that two streams are
equal, it is suï¬ƒcient to ï¬nd a relation R which is stable by equality,
which implies equality on ï¬rst elements and is preserved by remainders
for nonempty streams. Such a relation R is included in equality:
âˆ€D (R : Str A â†’Str A â†’Prop),
(âˆ€x1 x2 y1 y2, R x1 y1 â†’x1 == x2 â†’y1 == y2 â†’R x2 y2)
â†’(âˆ€x y, (is cons x âˆ¨is consy) â†’R x y â†’firstx == firsty)
â†’(âˆ€x y, (is cons x âˆ¨is consy) â†’R x y â†’R (rem x) (rem y))
â†’âˆ€x y, R x y â†’x == y.
17.4.2.5 Mapping and ï¬ltering
Mapping A useful functional on streams is to apply a function F :
A â†’B to any element of a stream of A in order to obtain a stream of
B.
We easily build this function using our ï¬xpoint construction and case
analysis.
We ï¬rst build a function Mapf of type (Str A
Câ†’Str B)
Câ†’A
Oâ†’
StrA
Câ†’StrB such that Mapff a s = cons(F a) (f s).
Then we introduce MAP
def
= FIXP(CASE@ Mapf) of type StrA
Câ†’
StrB and map the underlying function of type StrA â†’Str B. From
the properties of FIXP, CASE and Mapf, we obtain easily the expected
equalities:
map âŠ¥== âŠ¥
map (consa s) == cons(F a) (map s).
Of course, we could have deï¬ned map directly in Coq using a guarded
ï¬xpoint (a ï¬xpoint where recursive calls are directly under a constructor)
on the co-inductive type Str A which satisï¬es the following equations:
map (Eps x) = Eps (map x)
map (cons a x) = cons(F a) (map x)
Proving monotonicity and continuity of this function requires speciï¬c
co-recursive proofs. Our deï¬nition using FIXP and CASE gives us these
results directly without extra work.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
401
Our technique applies to recursive deï¬nitions of functions on streams
which do not directly correspond to guarded ï¬xpoints like the filter
function.
Filtering Filtering is an operation that selects elements of a stream that
satisfy a given (decidable) property P. This operator has been widely
studied because it is the typical example of a nonguarded deï¬nition on
co-inductively deï¬ned inï¬nite streams.
Using p of type A â†’bool to decide the property P, a deï¬nition in
an Haskell-like language would be:
filterp (consa s) = if p a then consa (filterp s) else filterp s
The problem is that if P only holds on a ï¬nite number of elements of
the stream then the output is ï¬nite and there is no way to decide that.
Bertot [3] proposes a solution where there is an inductive proof that
P holds inï¬nitely many times in the input and this is used to produce
an inï¬nite stream as output. An alternative solution is to produce as
output an inï¬nite stream of values which are either a real value or a
dummy constant.
With our representation of streams, we can simply deï¬ne the stream
in a similar way as for the map function using case analysis and ï¬xpoint.
We introduce Filterfp of type (Str A
Câ†’Str A)
Câ†’A
O
â†’Str A
Câ†’
StrA such that Filterfp f a s = if p a then consa (f s) else f s.
Then we introduce FILTERp
def
= FIXP(CASE@ (Filterfp)) of type
StrA
Câ†’Str A and (filter p) the corresponding function of type
StrA â†’StrA. We easily check the expected property:
filterp (cons a s) == if p a then consa (filterp s) else filterp s
17.4.2.6 Finiteness
We can deï¬ne what it means for a stream to be ï¬nite or inï¬nite. As
usual, inï¬nity is deï¬ned co-inductively and ï¬niteness is an inductive
predicate. We deï¬ned them the following way:
Inductive finite (s:StrA) : Prop :=
fin bot : s â‰¤âŠ¥â†’finites
| fin cons: finite(rem s) â†’finites.
CoInductive infinite (s:StrA) : Prop :=
inf intro : is cons s â†’infinite(rems) â†’infinites.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

402
C. Paulin-Mohring
We were able to prove
â€¢ s â‰¤t â†’infinites â†’infinitet
â€¢ s â‰¤t â†’finitet â†’finites.
This property is not provable if we take a diï¬€erent version of finite
with an extra hypothesis (is conss) in the constructor fin cons.
With such a deï¬nition of finite, a proof of finitet is isomorphic
to the number of cons in t. Assuming s â‰¤t, a proof of finites
should give us the exact number of elements in s, but there is no way
to explicitly compute this number. With our deï¬nition of finite, a
proof of finites just gives us an upper bound of the number of cons
in the stream and is consequentely compatible with the order on the
streams.
â€¢ finites â†’Â¬infinites
17.4.3 The particular case of natural numbers
We put an ordered structure on the type nat of natural numbers but
this is not a cpo because there is no lub for the sequence h n = n. If
we want a cpo structure, we need to add an inï¬nite element. One way
to deï¬ne a cpo for natural numbers reusing our previous library is to
take the type of streams on the trivial type unit with only one element
tt : unit. The 0 element will be Epsâˆas before, the successor function
will be S x
def
= constt x. We can deï¬ne the top element Sâˆwith the
coï¬xpoint Sâˆ= S Sâˆand prove âˆ€x, x â‰¤Sâˆ.
We write Nat for this cpo. There is an obvious monotonic function
from nat to Nat.
This domain is used in order to deï¬ne the length function from
StrA to Nat. It is just an application of the map construction with the
functional fun a â‡’tt. We were able to show the following properties:
â€¢ âˆ€s : StrA, infinite(lengths) â†”infinites
â€¢ âˆ€n : Nat, S n â‰¤n â†’infiniten
In the case of streams, we deï¬ned the append of streams x and y,
just taking the ï¬rst element of x (if it exists) and putting it in front
of y. There is no way to deï¬ne the usual append function on lists such
that the concatenation of the empty stream and y is y, because we never
know if x is empty by just looking at a ï¬nite preï¬x.
The situation is a bit diï¬€erent for the cpo of natural numbers where
the concatenation corresponds to addition. When trying to add x with
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
403
y we might look alternatively at the head part of x and y. Whenever we
ï¬nd a successor, we can produce a successor on the output. If one of x
or y is 0 then we will always ï¬nd Eps step on this input and the output
will be equal to the other argument with just extra Eps steps inserted.
Following this idea, we have been able to deï¬ne the addition as a
continuous function on Nat and prove that it is commutative and that
addn 0 == n.
17.5 Kahn networks
We shall now explain our representation of Kahn networks in Coq.
17.5.1 Representing nodes
We deï¬ne a shallow embedding of nodes. A node with inputs of type
A1, . . . , An and outputs in types B1, . . . , Bp is a continuous function of
type 
i Str Ai
Câ†’
j Str Bj.
In general we allow arbitrary sets of indexes I for inputs and J for
outputs. We associate with each index a type family A : I â†’Type and
B : J â†’Type, a node of signature A B is an element of 
i Str (A i)
Câ†’

j Str (B j).
We distinguish the particular case of a simple node with only one
output. Given a set of indexes I for inputs, a type family A : I â†’Type
and a type B, we deï¬ne a simple node of signature A B to be an element
of 
i Str (A i)
Câ†’Str B.
A node with several outputs can just be seen as a set of simple nodes,
each one corresponding to the projection on the corresponding output.
17.5.2 Representing systems
We start from a concrete set of edges and we distinguish input edges
(given by a type I) from the other ones (given by a type J). We consider
all the noninput edges to be output edges, it is not relevant for the
system which outputs we want to observe.
We associate with each edge a type, so we have a type family A :
I + J â†’Type. The type I + J is the disjoint union of I and J. We write
(l i) (resp. (r j)) for the element of I + J associated with i : I (resp.
j : J).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

404
C. Paulin-Mohring
We deï¬ne SA
def
= fun i â‡’Str (A i) the type family indexed by I + J
of streams of elements of type A i and SAI
def
= fun i â‡’SA (l i) the type
family indexed by I associated with the inputs.
Now each edge which is not an input edge has a source which is a
node. Actually each edge is associated with one particular output of the
source node. We already mentioned that a general node with n outputs
is equivalent to n simple nodes.
In our model, each noninput edge is associated to one simple node (its
source).
A simple node in general is a function f of type 
kâˆˆK StrAâ€²
k
Câ†’
StrB. We have to link the inputs of the node (indexed by K) with
the edges of the system. This corresponds to producing a function Ïƒ :
K â†’(I + J) which is compatible with the type system (i.e. Aâ€²
k is
convertible with A (Ïƒ k)). Given f and Ïƒ, we could use the DLIFTi
operation introduced in Section 17.3.2.2 in order to build a function f â€²
of type  SA
Câ†’Str B, which can also be seen as a simple node but
taking all the edges of the system as input.
Instead of introducing for each node the extra level of indirection with
the set K and the map Ïƒ : K â†’(I + J), we directly consider that an
output edge is associated with a (simple) node of the system which is a
continuous map taking all streams associated with an edge as input, i.e.
an element of  SA
Câ†’Str B. This gives us a very simple and uniform
deï¬nition of the type of systems that we describe now.
A system with input edges I and output edges J of type A : I + J â†’
Type is an object of type:
systemA
def
= âˆ€j : J, (

SA)
Câ†’Str (A (r j))
The set of systems has a cpo structure corresponding to an indexed
product 
j( SA
Câ†’Str (A (r j))).
Equation associated with a system A system deï¬nes an equation
on the streams associated with the edges, provided we give values for
the input edges.
Formally if we have a system s on a type family A : I + J â†’Type as
before and an input inp which is a product of streams on I such that inp
has type  SAI, then we can deï¬ne the set of equations as a continuous
function (EQN of systems inp) of type  SA
Câ†’ SA such that
EQN of systems inp X (l i) = inp i
EQN of systems inp X (r j) = s j X
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
405
Taking the ï¬xpoint of this function gives us the output observed on all
the edges.
This function EQN of system is monotonic and continuous with
respect to both the system and the input arguments. It has type:
systemA
Câ†’ SAI
Câ†’( SA
Câ†’ SA).
The solution of this equation for a system s and an input inp is
obtained by taking the ï¬xpoint of the functional (EQN of systems inp).
It is still a continuous function both of the system of the inputs, so we
obtain for each system s, a new node SOL of systems of type ( SAI)
Câ†’
( SA) such that:
SOL of systems inp == EQN of systems inp (SOL of systems inp).
Now if we are only interested by a subset O of the output nodes, we
use a mapping Ï€ : O â†’J and we use again the lift function in order to
restrict our solution to a node indexed by I for inputs and O for outputs
of type ( SA)
Câ†’(
o:O SA (r (Ï€ o))).
In the examples, we shall only be interested by one output o : J which
is simply obtained by applying SOL of systems inp to (r o).
17.5.3 Remarks
There are a few diï¬€erences between our formalization and Kahnâ€™s
original deï¬nition [11].
â€¢ Kahn deï¬ned a node as a continuous function, associated with edges
for its inputs and outputs. In our formalism, we have the association
between the edges and the output of a node but nothing on the link
between the input of the node and the edges. The nodes are implicitly
related to all edges. In practice, as we shall see in the examples, we
shall start with a node deï¬ned as a continuous function with the
appropriate number of arguments corresponding to the number of
input edges in the node. Then, when deï¬ning the system, we simply
project the relevant edges of the system on the corresponding inputs
of the node.
â€¢ A noninput edge in our systems has one source node but may have
several target nodes. This avoids the explicit use of duplication nodes
which is discussed as a possible harmless extension in Kahn [11].
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

406
C. Paulin-Mohring
17.6 Examples
17.6.1 A simple example
We illustrate our approach with the same running example as in
Kahn [11].
17.6.1.1 Deï¬nition
We ï¬rst draw in Figure 17.4 the graphical scheme corresponding to the
network.
h 0
f
h 1
g
Z
Y
T1
T2
X
Fig. 17.4. A simple example of Kahn network.
The edges are X, Y , Z, T1, and T2. There is no input edge so the
set I is deï¬ned as the empty type. The set J is an enumerated set with
elements X, Y , Z, T1, and T2. All the links contain values in type nat
such that the type family A : I + J â†’Type is deï¬ned by A k = nat and
we have SA k = Strnat.
The functions corresponding to the nodes are f, g and h. The node g
has two outputs corresponding to the functions g1 and g2. They satisfy
the equations:
â€¢ f U V = app U (app V (f (remU) (rem V )))
â€¢ g1 U = appU (g1 (rem (rem U)))
â€¢ g2 U = app(rem U) (g2 (rem (rem U)))
â€¢ h n U = consn U
In Kahn [11], the equations involve an extra first application in the ï¬rst
argument of app, but because we proved: app (firstx) y == app x y,
we can eliminate it.
In order to deï¬ne these nodes, we use the ï¬xpoint construction and
the composition of the (continuous) functions app, rem and cons on
streams.
The system itself (called sys) is translated from the scheme in the
Figure 17.4 which can also be seen as the set of equations:
X = f Y Z
Y = h 0 T1
Z = h 1 T2
T1 = g1 X
T2 = g2 X
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
407
In Coq, sys is a function from J to the continuous functions from
 SA
Câ†’Str nat. Given p of type  SA, we have:
â€¢ sysX p = f (p (r Y )) (p (r Z))
â€¢ sysY p = h 0 (p (r T1))
â€¢ sysZ p = h 1 (p (r T2))
â€¢ sysT1 p = g1 (p (r X))
â€¢ sysT2 p = g2 (p (r X))
Now the resulting stream (called result) of type (Str nat) is obtained
the following way:
(i) The solution sol of the system sys has type  SAI
Câ†’ SA.
(ii) Because I is empty, the type SAI containts a trivial element inp,
we apply sol to inp and get an object of type  SA.
(iii) The object solinp X that is the projection of the previous system
on the link X is the expected result.
17.6.1.2 Properties
Kahnâ€™s paper proves that the result is an inï¬nite stream containing
alternatively 0 and 1. For that he proves: result == cons0 (cons1 result).
This is done in two steps, ï¬rst he proves that result satisï¬es the
following ï¬xpoint equation:
result == cons0 (cons1 (f (g1 result) (g2 result)))
then proves that f (g1 s) (g2 s) == s.
The ï¬rst equation is a consequence of two general properties of
ï¬xpoints.
(i) A ï¬xpoint on a continuous function is stable by composition:
FIXPf == FIXP (f@ f) == FIXPf n+1.
This is a consequence of a general lemma about ï¬xpoint of
composition of continuous functions:
âˆ€(f g : D
Câ†’D),
g@ f â‰¤f@ g â†’f (FIXPg) â‰¤FIXP g â†’FIXP(f@ g) == FIXPg
(ii) Fixpoint on products can be simpliï¬ed when the output on an
index i depends only on the input on the same index i:
âˆ€(I : Type)(D : I â†’cpo)(F :  D
Câ†’ D)(i : I)(Fi : D i
Câ†’D i),
(âˆ€p :  D, F p i == Fi (p i)) â†’FIXPF i == FIXPFi.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

408
C. Paulin-Mohring
We take the equation EQN sys of type  SA
Câ†’ SA associated with
the system sys together with the empty input stream and we compose
it three times. We obtain the equation:
EQN sys3 p (r X) = f (h 0 (g1 (p (r X)))) (h 1 (g2 (p (r X)))).
Consequently the stream result which is the ï¬xpoint of EQN sys on the
output X is also the ï¬xpoint of EQN sys3 on the output X and is also the
ï¬xpoint of FX with FX s = f (h 0 (g1 s)) (h 1 (g2 s)). Using the deï¬nition
of f and h, it is easy to see that: FX s == cons 0 (cons1 (f (g1 s) ( g2 s)).
What remains to be proved is that âˆ€s, f (g1 s) (g2 s) == s. Kahnâ€™s
paper uses a structural induction which is not appropriate because the
stream s is possibly inï¬nite. Instead we use a bisimulation technique.
We use a variation of the bisimulation principle given in Section 17.4.2.4
which is:
âˆ€D (R : Str A â†’Str A â†’Prop),
(âˆ€x1 x2 y1 y2, R x1 y1 â†’x1 == x2 â†’y1 == y2 â†’R x2 y2)
â†’(âˆ€x y, (is cons x âˆ¨is consy) â†’R x y â†’firstx == firsty)
â†’(âˆ€x y, (is cons (rem x) âˆ¨is cons(rem y)) â†’
R x y â†’first(rem x) == first(rem y))
â†’(âˆ€x y, (is cons (rem x) âˆ¨is cons(rem y)) â†’
R x y â†’R (rem (rem x)) (rem (rem y)))
â†’âˆ€x y, R x y â†’x == y.
We instantiate this principle by the relation R s t
def
= t == f (g1 s) (g2 s).
The proof is based on algebraic properties of f, g1, g2, rem, and first.
We end up with the expected property result = cons 0 (cons1 result)
from which we deduce that result is an inï¬nite stream because its
length is inï¬nite.
17.6.2 Sieve of Eratosthenes
The scheme corresponding to the sieve of Eratosthenes is given in
Figure 17.2 in Section 17.2. What is interesting is that it is a recursive
scheme. The scheme deï¬nes a node sift which is used as an internal
node in the scheme itself. This is done using a ï¬xpoint construction
which is possible because the interpretation of a scheme is a continuous
function of the nodes themselves.
The node fdiv is easily built using case and filter such that:
fdiv (cons a s) = filter(diva) s
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
409
We introduce the input index type I which is just a type with one
element i and the output index type J which contains three elements
X, Y and o. All the links have type nat, so using the same notation as
before we introduce A : I + J â†’Type, SA : I + J â†’cpo, SAI : I â†’cpo
such that A k = nat, SA k = Strnat and SAI i = Strnat.
We deï¬ne the functional Fsift associated with the recursive system
which has type (Str nat
Câ†’Str nat)
Câ†’systemA and is deï¬ned by case
on the output link with p of type  SA:
Fsiftf X p = fdiv(p (l i))
Fsiftf Y p = f (p (r X))
Fsiftf o p = app (p (l i)) (p (r Y ))
The construction SOL of system introduced in Section 17.5.2 gives
us a continuous function from systems to functions of type  SAI
Câ†’
 SA from the streams corresponding to input edges to the streams
corresponding to all edges.
The composition of SOL of system with Fsift gives us a continuous
function from (Str nat
Câ†’Strnat) to  SAI
Câ†’ SA.
Now the recursive graphical construction of the system says that sift
is the functional corresponding to the input i and the output o.
Using pair1 (the continuous trivial function from D to 
iâˆˆI D when
I has only one element), it is easy to build a continuous function focus
of type ( SAI
Câ†’ SA)
Câ†’Str nat
Câ†’Str nat such that focush s =
h (pair1s) o.
The composition of focus, SOL of system and Fsift is now a
continuous function from (Str nat
Câ†’Str nat) to (Str nat
Câ†’Str nat).
We introduce sift as the ï¬xpoint of this operator.
We can prove, using the ï¬xpoint equation for sift, the following
equality:
sift == focus(SOL of systemA (Fsift sift)).
Using the ï¬xpoint equation for: SOL of systemA (Fsiftsift), it is easy
to derive successively the following equalities for all stream s:
â€¢ SOL of systemA (Fsiftsift) (pair1 s) (l i) == s.
â€¢ SOL of systemA (Fsiftsift) (pair1 s) (r X) == fdivs.
â€¢ SOL of systemA (Fsiftsift) (pair1 s) (r Y ) == sift(fdiv s).
â€¢ SOL of systemA (Fsiftsift) (pair1 s) (r o) == apps (sift(fdiv s)).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

410
C. Paulin-Mohring
From these equalities, the property of fdiv, and the ï¬xpoint equality
for sift we easily deduce the expected property of sift:
sift (consa s) == consa (sift (filter(div a) s))
siftâŠ¥== âŠ¥
17.7 Conclusion
17.7.1 Contributions
This paper describes three contributions.
The ï¬rst one is a general Coq library for Ï‰-cpos. This is a constructive
version of cpos where there is an explicit function to build the least-upper
bound of any monotonic sequence. It contains useful constructions such
as generalized products, cpos of monotonic and continuous functions
and combinators to manipulate them. It also introduces a ï¬xpoint
combinator. This library has also been used in a Coq library for modeling
randomized programs as distributions [1, 2].
The second contribution is the deï¬nition of the cpo of streams of
elements in a type A. This type, deï¬ned co-inductively, covers both the
case of ï¬nite and inï¬nite streams but without any explicit way to decide
if the stream is ï¬nite or not. The type itself is not very original, it
corresponds to an inï¬nite stream with values which can be present or
absent. What is interesting is the order deï¬ned on that data structure
and the derived equality. Modulo this equality, we are able to reason
on this data structure by only considering the interesting cases where
the streams are equal to (cons a s). The most diï¬ƒcult construction
on the type of streams was the least-upper bound. The ï¬xpoint given by
the cpo structure makes it possible to deï¬ne in a natural way a function
like filter that selects the elements of a stream satisfying a predicate
P. This function is problematic with most representations of streams
in Coq because the output can be ï¬nite or inï¬nite depending on the
number of elements in the input which satisï¬es P.
The last contribution is the modeling of Kahn networks as they are
described in the paper [11]. We chose a shallow embedding where a
system is represented using a set of links and for each noninput link a
continuous function corresponding to the node. Each node can possibly
take as input all the links of the system. This leads to a very simple and
uniform deï¬nition of systems which itself can be seen as a cpo.
A system together with streams for inputs deï¬nes a continuous
function on the streams associated with the links of the system (the
history of the system). The ï¬xpoint of this function deï¬nes the behavior
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
411
of the system as a continuous function both from the inputs and the
system.
Using this interpretation, we were able to formalize both the main
example given by Kahn [11] and the sieve of Eratosthenes, an example
of a recursive scheme which was presented by Kahn and MacQueen [12].
17.7.2 Remarks
Coq
development The Coq development runs with Coq version
8.1 [15]. It makes an intensive use of the new setoid rewriting tactic. It
is available from the authorâ€™s web page. It contains approximately 1700
lines of deï¬nitions and statements and 3000 lines of proofs. The Coq
notation mechanism as well as implicit arguments makes it possible to
keep notations in Coq quite similar to the ones used in this paper.
What is mainly missing is a syntactic facility in order to automatically
build complex continuous functions by composition of simpler functions
and functionals.
Synchronous case As we mentioned before, one important application
of Kahn networks is their restriction to synchronous languages where no
buï¬€er is needed to store the values on the links. The nodes receive the
inputs at a regular time given by a clock and instantaneously produce
an output. A denotational semantics of this calculus in Coq was given by
BoulmÂ´e and Hamon [5]. Their approach is to make the type of the stream
dependent on the clock (which is an inï¬nite stream of boolean values),
so there is a control on which data is available or not. They do that by
considering ordinary inï¬nite streams (only the cons constructor) with
values which can either be an ordinary value in the type A of elements,
or an absent value (when the clock is oï¬€) or a failure (no value when
the clock is on).
We could adapt our development to this particular case by extending
the deï¬nition of streams to make them dependent on the clock.
CoInductive Str A :clock â†’Type :=
Eps : âˆ€c, Str A c â†’Str A (false::c)
| cons : âˆ€c, A â†’Str A c â†’Str A (true::c)
Then in order to deï¬ne the bottom element of a stream on a clock c, it
is convenient to have a bottom element in the type A. So the natural
framework is to consider a cpo structure on A. Then the order on the
streams can be deï¬ned in the following way (the clock argument of
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

412
C. Paulin-Mohring
constructors Eps and cons can be derived from the type of the stream
so it is left implicit in the Coq notation).
x â‰¤y
Eps x â‰¤Epsy
a â‰¤b
x â‰¤y
consa x â‰¤consb y
It is simpler than in our case because we know exactly where the cons
constructors are. The construction of lubs is also simpliï¬ed, when the
clock is true, there is a cons constructor in each element of the sequence
of streams, we produce a cons constructor in the output with a value
corresponding to the lub of the heads. However, some extra properties
have to be proved on the sequence if we want to ensure that there is no
consâŠ¥left in the result.
Equations Kahnâ€™s paper refers to the paper of Courcelle, Kahn and
Vuillemin [9] which proves the decidability of equivalence in a language
of ï¬xpoints.2 We started to write a Coq version of this paper and in
particular we deï¬ned the notion of terms and built the cpo corresponding
to the canonical interpretation of equations built on sequences of terms.
But the full formalization of this part still remains to be done.
Bibliography
[1]
P. Audebaud and C. Paulin-Mohring. Proofs of randomized algorithms in
Coq. In T. Uustalu (ed.) Mathematics of Program Construction, MPC 2006,
volume 4014, Lecture Notes in Computer Science, Kuressaare, Estonia, July
2006. Springer-Verlag, 2006.
[2]
P. Audebaud and C. Paulin-Mohring. Proofs of randomized algorithms
in Coq. To appear in Science of Computer Programming. Extended version
of [1].
[3]
Y. Bertot. Filters on coinductive streams, an application to Eratos-
thenesâ€™sieve. In P. Urzyczyn (ed.) International Conference of Typed Lambda
Calculi and Applications, volume 3461, Lecture Notes in Computer Science,
pp. 102â€“115. Springer-Verlag, 2005.
[4]
Y. Bertot and P. CastÂ´eran. Interactive Theorem Proving and Program
Development. Springer-Verlag, 2004.
[5]
S. BoulmÂ´e and G. Hamon. Certifying synchrony for free. In International
Conference on Logic for Programming, Artiï¬cial Intelligence and Reasoning
(LPAR), volume 2250, Lecture Notes in Artiï¬cial Intelligence, La Havana,
Cuba, December 2001. Springer-Verlag, 2001. Short version of A clocked
denotational semantics for Lucid-Synchrone in Coq, available as a Technical
Report (LIP6), at www.lri.fr/âˆ¼pouzet.
2 Editorâ€™s note: this article is reproduced in this book.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
413
[6]
V. Capretta. General recursion via coinductive types. Logical Methods in
Computer Science, 1(2:1):1â€“28, 2005.
[7]
P. Caspi and M. Pouzet. Synchronous Kahn Networks. In ACM SIGPLAN
International
Conference
on
Functional
Programming,
Philadelphia,
Pensylvania, May 1996.
[8]
A. Cohen, M. Duranton, C. Eisenbeis, C. Pagetti, F. Plateau and
M. Pouzet. N-Synchronous Kahn networks: a relaxed model of synchrony
for real-time systems. In ACM International Conference on Principles of
Programming Languages (POPLâ€™06), Charleston, South Carolina, USA,
January 2006.
[9]
B. Courcelle, G. Kahn and J. Vuillemin. Algorithmes dâ€™Â´equivalence et de
rÂ´eduction `a des expressions minimales dans une classe dâ€™Â´equations rÂ´ecursives
simples. In J. Loeckx (ed.) Automata, Languages and Programming,
volume 14, Lecture Notes in Computer Science, pp. 200â€“213. Springer-
Verlag, 1974. Translation from French by T. Veldhuizen with original text,
a few comments and additional references.
[10]
N. Halbwachs, P. Caspi, P. Raymond and D. Pilaud. The synchronous
dataï¬‚ow
programming
language
lustre.
Proceedings
of
the
IEEE,
79(9):1305â€“1320, 1991.
[11]
G. Kahn. The semantics of a simple language for parallel programming.
In Information Processing 74. North-Holland, 1974.
[12]
G. Kahn and D. MacQueen. Coroutines and networks of parallel
processes. In B. Gilchrist (ed.) Information Processing 77. North-Holland,
1977.
[13]
G. Kahn and G. D. Plotkin. Concrete domains. Theoretical Computer
Science, 121(1& 2):187â€“277, 1993.
[14]
D. Pilaud, P. Caspi, N. Halbwachs and J. Plaice. Lustre: a declarative
language for programming synchronous systems. In 14th ACM Conference
on Principles of Programming Languages, pp. 178â€“188, Munich, January
1987.
[15]
The Coq Development Team. The Coq Proof Assistant Reference Manual
â€“ Version V8.1, July 2006. http://coq.inria.fr.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

