International Journal of Approximate Reasoning 125 (2020) 139–168
Contents lists available at ScienceDirect
International Journal of Approximate Reasoning
www.elsevier.com/locate/ijar
The Fuzzy Logic Programming language FASILL: Design and 
implementation ✩
Pascual Julián-Iranzo a, Ginés Moreno b, José Antonio Riaza b,∗
a Dept. of Technologies and Information Systems, UCLM, 13071 Ciudad Real, Spain
b Dept. of Computing Systems, UCLM, 02071 Albacete, Spain
a r t i c l e 
i n f o
a b s t r a c t
Article history:
Received 12 July 2019
Received in revised form 29 May 2020
Accepted 2 June 2020
Available online 25 July 2020
Keywords:
Fuzzy Logic Programming
Similarity relation
Operational semantics
High level implementation techniques
The FASILL programming language (acronym of “Fuzzy Aggregators and Similarity Into 
a Logic Language”) combines a weak uniﬁcation algorithm, based on similarity relations, 
along with a rich repertoire of fuzzy connectives and aggregators, whose truth functions 
can be deﬁned on a complete lattice. In this work, we want to provide a uniﬁed view 
of the fundamental concepts and ideas that inspired its construction, jointly with the 
implementation techniques that made it possible. We detail the implementation of the 
operational semantics and we describe the overall structure of the FASILL system. The
FASILL language is well-suited for a wide range of applications and, speciﬁcally, it can help 
the development of knowledge based systems where to deal with uncertainty is important. 
After ten years designing and implementing fuzzy logic systems, this work culminates and 
agglutinates the experience acquired in our research group on the development of this kind 
of modern programming languages.
© 2020 Elsevier Inc. All rights reserved.
1. Introduction
Fuzzy Logic Programming (FLP, for short) integrates Fuzzy Logic [75] and pure Logic Programming [70], in order to deal with 
the essential vagueness of some problems by using declarative techniques. FLP has a long ascendancy that began with the 
seminal work of [45] in the seventies of the last century. In spite of that, it is still not a well established area, which has 
motivated our research activity during the last decade.
FASILL [36] is a fuzzy logic programming language that integrates a similarity-based uniﬁcation algorithm and concepts 
coming from Bousi∼Prolog [63,40] into the core of the Fuzzy LOgic Programming Environment for Research, FLOPER in brief, 
that we have developed in the last years [50,57], in order to deal with a ﬂexible notion of equality sustained by similarity 
relations. This language aims to combine in a single expressive framework the advantages and applications of both types of 
programming languages.
Because FASILL has evolved from the FLOPER system, it also subsumes the MALP (Multi-Adjoint Logic Programming) 
syntax [49]. Before going into deeper details, let us introduce an easy to follow example motivating the evolution from
MALP to FASILL.
✩This work has been partially supported by the State Research Agency (AEI) of the Spanish Ministry of Science and Innovation under grant PID2019-
104735RB-C42 (SAFER) and UE FEDER and the AEI of the Spanish Ministry of Economy and Competition under grant TIN2016-76843-C4-2-R (MERINET).
* Corresponding author.
E-mail addresses: Pascual.Julian@uclm.es (P. Julián-Iranzo), Gines.Moreno@uclm.es (G. Moreno), JoseAntonio.Riaza@uclm.es (J.A. Riaza).
https://doi.org/10.1016/j.ijar.2020.06.002
0888-613X/© 2020 Elsevier Inc. All rights reserved.

140
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
Fig. 1. An on-line session for debugging/interpreting a FuzzyXPath query.
Example 1. Consider, for instance, the following MALP rule: “good(X) <-prod @aver(nice(X),cheap(X)) with 0.8”, 
where aggregator @aver is typically deﬁned as @aver(X1, X2) = (X1 + X2)/2. Therefore, the rule speciﬁes that X is 
good—with a truth degree of 0.8— whenever X be nice and cheap enough. Assuming that X is nice and cheap with, 
e.g., truth degrees n and c, respectively, then X is good with a truth degree of 0.8 ∗((n + c)/2). Moreover, we can add 
the similarity equation good ≈excellent = 0.9 and then, in the new FASILL program, it is possible to solve a goal 
like excellent(Y) obtaining the same answers as the ones for goal good(X) in the previous MALP program but slightly 
modulated by the similarity degree 0.9.
Certainly, a MALP program can be conceived as a FASILL program equipped with the identity fuzzy relation (where the 
elements of a signature are only similar to itself with the top similarity degree) and a multi-adjoint lattice (i.e., a complete 
lattice containing adjoint pairs). In order to subsume the syntactic conventions of MALP, in our programs we also admit 
weighted rules with shape “A ←i B with α”,1 which are internally treated as “A ←(α&iB)” (this transformation preserves 
the meaning of rules, as we proved in [54]).
As a motivation, we mention that we have used our fuzzy logic programming environment to code soft computing 
applications connecting with SAT/SMT techniques [18,5], cloud computing [72,71,69] and neural networks [55]. Anyway, our 
most important application ﬁelds have been the following ones:
• Semantic web. In this setting we have extended with powerful fuzzy commands the popular XPath/XQuery and SPARQL 
languages for respectively querying XML and RDF/OWL documents in a ﬂexible way. In the ﬁrst case, we have designed 
the FuzzyXPath language and both the interpreter and the debugger components of our tool can be tested on-line 
[6–9,11,10,12]. We have introduced “dynamic thresholding” techniques into our debugger of XPath queries which pro-
duces a set of correct XPath expressions with better chance degrees for retrieving answers from large XML ﬁles in a 
very eﬃcient way. In Fig. 1 we show an screen-shot of a working session using the DEBIN command intended to auto-
matically interpret all these correct queries for the retrieval of answers. The interest of the new command resides in the 
fact that users can retrieve now new information not necessarily reported by the execution of their initial queries, thus 
collecting useful novel answers (very often accompanied with a greater “retrieval status value” or satisfaction degree) 
associated to correct queries which slightly deviate from the original ones. The use of appropriate ﬁlters seems to be 
mandatory when managing queries with the DEBIN command, in order to keep eﬃciency while avoiding the generation 
of useless knowledge, since both the set of correct queries produced by the debugging process, as well as the set of 
answers obtained after interpreting them, can be enormous. For instance, consider a FuzzyXPath query like the one 
reported in [12], intended to ﬁlter tittles of books from a given XML ﬁle which verify a concrete condition (beyond 
a 0.5 truth degree) concerning their publication dates and prices: “[FILTER=0.5][DEBIN=0.7]//book[@year<1998 
avg @price<50]/tittle”. The use of the DEBIN command forces the system to report all the solutions associated, not 
only to the original query itself, but also to other debugged queries with slight variations on its initial formulation. For 
1 Note that FASILL can safely deal with explicitly weights on rules but without requiring the presence of adjoint pairs in the lattice of truth degrees, 
which are mandatory in the MALP framework. It is remarkable the fact that the set of complete lattices is obviously wider than the one of multi-adjoint 
lattices, which directly implies that the class of FASILL programs –even without considering similarity relations– includes the smaller class of MALP
programs. Moreover, in [21], authors provide a very general, suﬃcient condition to guarantee a well-behaved logic programming language with a least 
Herbrand model semantics where implication and conjunction may not form an adjoint-pair.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
141
Fig. 2. Web tool for querying social networks with FSA-SPARQL.
instance, tag “book” could be changed by “novel” (with a penalty of 0.7) in an alternative, internally generated query, 
if the exploration of the corresponding XML ﬁle evidences that new approximate answers can be eventually reached.
• Social networks. SPARQL has been adopted as a query language for the semantic web, while RDF and OWL have also 
been established as (crisp) vocabularies to describe ontologies in this setting. In [2] we have proposed a SPARQL 
extension, called FSA-SPARQL (Fuzzy Sets and Aggregators based SPARQL), in which queries can involve different fuzzy 
connectives and (aggregation) operators. The language has been implemented as an extension of the ARQ Jena SPARQL 
engine and it is available a web tool from which queries can be executed on-line, as shown in Fig. 2. Moreover, the
FASILL system has been equipped with tuning techniques for enabling the customization of queries from test cases, as 
we will see in Subsection 5.5. In [4], we provide a FSA-SPARQL translation to FASILL code in order to apply the tuning 
techniques implemented in our system to FSA-SPARQL queries for getting more precise formulation of queries from 
test cases. Besides that and as we describe in [3], FSA-SPARQL also works with social networks, which have become 
a source of data which are of interest in all areas, and their querying and analysis is a hot topic in computer science. 
FSA-SPARQL enables the transformation and fuzziﬁcation of social network API data. Fuzziﬁcation of social networks 
data is automatic and according users’ preferences enabling a wide range of mechanisms for ranking and categorization, 
including sentiment analysis and topic detection. As a case study, FSA-SPARQL has been used to query three well-known 
social networks: Foursquare TMDb and Twitter, as Fig. 2 illustrates.
The integration of similarity relations into FASILL provides a ﬂexible query answering mechanism and the ability to 
represent term ontologies. This allows FASILL to capture applications as the ones developed in the framework of the
Bousi∼Prolog system on abstract knowledge discovery [64] or text categorization [62] or other practical applications where 
ﬂexible search is mandatory (advanced pattern matching; ﬂexible deductive databases; knowledge-based systems; infor-
mation retrieval, where textual information is selected or analyzed using an ontology; text analysis or alternate ways of 
approximate reasoning) [63].
In this work we want to provide a uniﬁed view of the fundamental concepts and ideas that inspired the design of FASILL
and the implementation techniques that made it possible. The main goals achieved in this paper are:
• integration of the weak uniﬁcation algorithm into an annotated fuzzy logic language;
• implementation of a declarative algorithm for computing the reﬂexive-symmetric-transitive closure of a binary fuzzy 
relation;
• great embedding of the Prolog language into FASILL;
• development of high level declarative techniques that can be used for implementing further fuzzy logic systems;
• ﬁnally, this work summarizes our learning lessons about the development of this kind of languages along the last 
decade.

142
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
The outline of the paper is as follows:
In the ﬁrst part of this work we recall the formal concepts that constitute the basis of the FASILL programming language. 
In sections 2 and 3 we deﬁne the syntax and the operational semantics of the FASILL programming language.
The second part of this work is dedicated to describe the implementation of FASILL. The explanation is centered on the 
main facts and ideas that allow us to materialize this language: in Section 4 we describe the overall structure and design of 
the FASILL system and in Section 5 we focus on implementation issues. Speciﬁcally, we describe how lattices are modeled 
(Subsection 5.1) and then we detail the implementation of fuzzy relations (Subsection 5.2), the weak uniﬁcation algorithm 
(Subsection 5.3), how FASILL programs are internally represented and meta-interpreted (Subsection 5.4), the role of the 
tuning and unfolding techniques for respectively customizing and improving the eﬃciency of FASILL programs (Subsection 
5.5) and ﬁnally, we establish some interesting connections between FASILL and Prolog (Subsection 5.6).
Before concluding in Section 8, we evaluate our implementation with benchmarks and experimental results in Section 6
and we compare the FASILL language with other related works in Section 7.
2. The FASILL language
FASILL is a ﬁrst order language built upon a signature  (i.e., a disjoint union of a set of variables, V, and sets of function 
and predicate symbols with an associated arity) and a wide set of connectives: t-norms (&); t-conorms (|); aggregators (@); 
and implication symbols (←).
The language combines the elements of the algebraic part of  (i.e., variables and function symbols) to build terms in 
the usual form. An atomic formula (or atom) is a n-ary predicate symbol applied to n terms or a literal constant α ∈L, 
where L is a set of constants which are the syntactic representation2 of the elements of a complete lattice L with top (⊤) 
and bottom (⊥) elements. A rule is a formula that has the form A ←B, where A is an atomic formula called the head and 
B ≡ζ(B1, ..., Bn), called the body, is built from atomic formulas B1, ..., Bn (possibly literal constants) and a combination 
of connectives ζ (excluding implications). In particular, when the body of a rule is α ∈L, this rule is called a fact and can 
be written as A ←α (or simply A if α = ⊤). A goal is a body submitted as a query to the system. A FASILL program (or 
simply program) is a tuple ⟨, R, L⟩where  is a set of rules, R is a similarity relation between the elements of  and L
is a complete lattice.
In general, given a domain U and a lattice L with a ﬁxed t-norm △, a similarity relation R is a fuzzy binary relation 
on U, that is, a mapping R : U × U →L, such that it fulﬁlls the reﬂexive (R(x, x) = ⊤, for all x ∈U), symmetric (R(x, y) =
R(y, x), for all x, y ∈U) and transitive (R(x, z) ≥R(x, y) △R(y, z), for all x, y, z ∈U) properties.3 We will consider a certain 
λ ∈L as a cut value. Once a cut value λ is set, the entries of the relation R(x, y) < λ are not taken into account.
As mentioned, we primarily deﬁne similarities on the symbols of the signature, , of a ﬁrst order language. This makes 
possible to treat as indistinguishable two syntactic symbols which are related by a similarity relation R. Moreover, a sim-
ilarity relation R on the alphabet of a ﬁrst order language can be extended to terms by structural induction in the usual 
way [65]. We will denote by ˆR the extension of R which is deﬁned as:
1. let x be a variable, ˆR(x, x) = R(x, x) = 1,
2. let f and g be two n-ary function symbols and let t1, . . . , tn, s1, . . . , sn be terms, then ˆR( f (t1, ..., tn), g(s1, ..., sn)) =
R( f , g) ∧(n
i=1 ˆR(ti, si)),
3. otherwise, the approximation degree of two terms is zero.
Analogously for atomic formulas.
It is important to know that, for rules we use a different and more effective notion of similarity than the one deﬁned in 
[65]. In our case, given two rules R : A ←B and R′ : A′ ←B′, then ˆR(R, R′) = ˆR(A, A′) if B = B′; otherwise ˆR(R, R′) = ⊥. 
In other words, a conditional formula R is similar to another conditional formula R′ in the same degree that their heads, 
provided that they have exactly the same body.
Example 2. Assume a fragment of a deductive database that stores information about people and their preferences on 
teaching. Suppose also that we work with the lattice L = ⟨[0, 1], ≤⟩to deal with truth degrees. In FASILL is usual to specify 
a similarity relation partially. That is, only a subset of entries is provided and then a reﬂexive, symmetric, transitive closure 
process generates the rest of the relation. For this case, we specify a similarity R by means of the following proximity 
equations:
%% PROXIMITY EQUATIONS
physics ~ math = 0.8.
physics ~ chemistry = 0.8.
2 These literal constants are written using exactly the same values of the lattice (of truth degrees) L that they intend to represent.
3 Note that, from now on, we will use the symbol “ △” to exclusively denote the ﬁxed t-norm associated to the notion of transitivity employed by the 
similarity relation R.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
143
Fig. 3. A search tree generated by the FASILL system: successful steps use rules (according their apparition order in the program) deﬁning the predicates 
annotated in the blue rectangles, while “is” stands for the evaluation of a connective in interpretative steps. (For interpretation of the colors in the 
ﬁgure(s), the reader is referred to the web version of this article.)
On the other hand, a subset of rules in  is given below:
%% FACTS
likes_teaching(john, physics) <- 0.8.
likes_teaching(mary, chemistry) <- 0.7.
has_degree(john, physics).
has_degree(mary, chemistry).
%% RULES
can_teach(X,M) <- 0.9 & has_degree(X, M) & likes_teaching(X, M).
Hence, the set of rules , the similarity relation R and lattice L conform the program P = ⟨, R, L⟩.
Keep in mind that, unlike our system, in a standard Prolog platform if we ask about who can teach mathematics, (i.e., 
we launch the goal “can_teach(X,math)”) the system does not produce any answer because it uses a crisp uniﬁcation 
algorithm. In this case, when unifying the head of the clause deﬁning the predicate “can_teach” with the proposed goal, 
the parameter “M” is bound to the atom “math” and the subgoals “has_degree(X,math)” and “likes_teaching(X,math)” 
are launched. But there are not facts in the program deﬁning the predicate “has_degree” (or “likes_teaching”) that could 
unify with that subgoals. In plain words, nobody has a degree in mathematics and likes teaching mathematics. However, 
as we will detail later in Fig. 3, FASILL ﬁnds that john has a degree in physics and likes teaching physics too and, 
because physics is close to maths with degree 0.8, it returns {X/john} with degree 0.8. It also returns {X/mary}
with degree 0.7 by similar reasons.

144
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
3. Operational semantics of FASILL
3.1. The weak uniﬁcation algorithm
In FASILL the concepts of uniﬁer and most general uniﬁer (mgu) are extended to cope with similarities. Let R be a 
similarity relation, λ be a cut value and E1 and E2 be two expressions. The substitution θ is a weak uniﬁer of level λ
for E1 and E2 with respect to R (or λ-uniﬁer) if its uniﬁcation degree ˆR(E1θ, E2θ) ≥λ. The substitution θ is more general
than the substitution σ with level λ, denoted by θ ≤R,λ σ , if there exists a substitution δ such that, for any variable x in 
Dom(σ) ∪Dom(θ), ˆR(xσ, xθδ) ≥λ. A substitution θ is a weak most general uniﬁer (wmgu) of level λ (or λ-wmgu), w.r.t. R, 
for E1 and E2, if: (i) θ is a λ-uniﬁer of E1 and E2; and (ii) for any λ-uniﬁer σ of E1 and E2, the substitution θ ≤R,λ σ .
In the following, we provide a weak uniﬁcation algorithm to compute wmgu’s, which reformulates and extends the 
one appeared in [65] for dealing with arbitrary complete lattices and thresholds. We formalize it as a transition system 
supported by a similarity-based uniﬁcation relation ⇒λ, where λ ∈L is a cut value or threshold. Note that our algorithm 
uses a different notion of uniﬁcation state, where an extra component accumulates an approximation degree. The uniﬁcation 
of the expressions E1 and E2 is obtained by a state transition sequence starting from an initial state ⟨G ≡{E1 ≈E2}, id, α0⟩, 
where id is the identity substitution and α0 = ⊤is the supremum of (L, ≤): ⟨G, id, α0⟩⇒λ⟨G1, θ1, α1⟩⇒λ ···⇒λ⟨Gn, θn, αn⟩.
When the ﬁnal state ⟨Gn, θn, αn⟩, with Gn = ∅, is reached (i.e., the equations in the initial state have been solved), the 
expressions E1 and E2 are uniﬁable by similarity with wmgu θn and uniﬁcation degree αn ≥λ. Therefore, the ﬁnal state 
⟨∅, θn, αn⟩signals out the uniﬁcation success. On the other hand, when expressions E1 and E2 are not uniﬁable, the state 
transition sequence ends with failure (i.e., Gn = Fail).
The thresholded similarity-based uniﬁcation relation, “⇒λ”, is deﬁned as the smallest relation derived by the following set 
of transition rules (where Var(t) denotes the set of variables of a given term t):
⟨{ f (t1,...,tn) ≈g(s1,..., sn)} ∪E,θ, v1⟩, R( f , g) △v1 = v2 ≥λ, v2 > ⊥
⟨{t1 ≈s1,...,tn ≈sn} ∪E,θ, v2⟩
1
⟨{X ≈X} ∪E,θ, v1⟩
⟨E,θ, v1⟩
2
⟨{X ≈t} ∪E,θ, v1⟩,
X /∈Var(t)
⟨(E){X/t},θ{X/t}, v1⟩
3
⟨{t ≈X} ∪E,θ, v1⟩
⟨{X ≈t} ∪E,θ, v1⟩
4
⟨{X ≈t} ∪E,θ, v1⟩, X ∈Var(t)
⟨Fail,θ, v1⟩
5
⟨{ f (t1,...,tn) ≈g(s1,..., sn)} ∪E,θ, v1⟩, R( f , g) △v1 = v2 ≱λ or v2 = ⊥
⟨Fail,θ, v1⟩
6
In addition to a different notion of uniﬁcation state, which uses an extra component to accumulate the approximation 
degree obtained so far, our algorithm diverges from the classical algorithm of Martelli and Montanari [48] in what concerns 
the rules 1 (Term Decomposition) and 6 (Failure Rule). Rule 1 is triggered when the value v2, resulting from the compo-
sition of the approximation degree, R( f , g), of the symbols at the root in the terms to be uniﬁed and the accumulated 
approximation degree v1, is equal or greater than λ and, also, greater than ⊥(the last condition deals with the case where 
R( f , g) ≥λ and λ = ⊥). Otherwise, Rule 6 is triggered and the uniﬁcation process ends with failure.
Usually, given two expressions E1 and E2, if there is a successful transition sequence, ⟨{E1 ≈E2}, id, ⊤⟩⇒λ⋆⟨∅, θ, v⟩, then 
we write that wmguλ
R(E1, E2) = ⟨θ, v⟩, being θ the λ-wmgu of E1 and E2, and v ≥λ is their uniﬁcation degree.
As in [38], in what follows and for the sake of simplicity, we will sometimes use the notation wmgu to reference 
wmgu⊥
R.
Finally note that, in general, a λ-wmgu of two expressions E1 and E2 is not unique [65]. The weak uniﬁcation algorithm 
computes a λ-wmgu which is a “representative” among the set of possible λ-wmgus. However, observe that, the λ-wmgu 
representative computed by the thresholded weak uniﬁcation algorithm is one with approximation degree equal or greater 
than any other λ-wmgu.4 As in the case of the classical syntactic uniﬁcation algorithm, our algorithm always terminates 
returning success or failure.
3.2. FASILL computational steps
In order to describe the operational semantics of the FASILL language, in the following we denote by C[A] a formula 
where A is a sub-expression (usually an atom) which occurs in the –possibly empty– context C[] whereas C[A/A′] means 
4 Note that in the context of similarity relation, given a representative wmgu, we can generate the rest of wmgus for that uniﬁcation problem by replacing 
the non-variable symbols in the terms of the representative wmgu with their similar ones. Therefore, all the wmgus can be computed, but we work with 
the one with the best degree of approximation, ignoring the others.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
145
the replacement of A by A′ in the context C[]. Moreover, Var(s) denotes the set of distinct variables occurring in the 
syntactic object s and θ[Var(s)] refers to the substitution obtained from θ by restricting its domain to Var(s). In the next 
deﬁnition, where program rules are taken renamed apart (as usual), we always consider that A is the selected atom in 
a goal Q, L is the complete lattice associated to P and given an L-expression,5 E, then E = v ∈L refers to the value 
obtained after fully evaluating all the connectives in E.
Deﬁnition 3.1 (Thresholded operational semantics). Let Q be a goal and let σ be a substitution. The pair ⟨Q; σ⟩is a state. 
Given a program P = ⟨, R, L⟩, a t-norm △associated to R and a cut value λ ∈L, the thresholded operational semantics 
of FASILL is formalized as a state transition system, whose transition relation λ6 is the smallest relation satisfying these 
rules:
Successful step (denoted as
SS
 ):
⟨Q[A],σ⟩
∃(A′ ←B) ∈ : wmguλ
R(A, A′) = ⟨θ, v⟩
⟨Q[A/(v △B)]θ,σθ⟩
SS
Failure step (denoted as
FS
 ):
⟨Q[A],σ⟩
∄(A′ ←B) ∈ : wmguλ
R(A, A′) = ⟨θ, v⟩
⟨Q[A/⊥],σ⟩
FS
Interpretive step (denoted as
IS
 ):
⟨Q,σ⟩
⟨Q,σ⟩
IS
where Q is a L-expression.
An operational step of level λ is a state transition ⟨Q, σ⟩λ⟨Q′, σ ′⟩made by using one of the above transition rules 
and an appropriate program rule. A derivation of level λ (or λ-derivation) is an arbitrary sequence of operational steps 
⟨Q, id⟩∗
λ⟨Q′, σ⟩. The length of a derivation is its number of steps. When Q′ = v ∈L, the tuple ⟨v, θ⟩, where θ = σ[Var(s)], 
is called a λ-fuzzy computed answer (λ-f.c.a.) for that derivation. Moreover, when λ = ⊥the λ-f.c.a. ⟨v, θ⟩is simply called a 
fuzzy computed answer (f.c.a.).
Fig. 3 shows a search tree for the FASILL program of Example 2 and the query “can_teach(X,math)” which illustrates 
the operational mechanism just deﬁned.
In [36] we have deﬁned both a declarative and a ﬁx-point semantics for FASILL programs, which represent two equiv-
alent ways for adapting the classical notion of least Herbrand model to our fuzzy setting. This is not an easy task in the 
sense that it is mandatory to cope with three non trivial components: lattices of truth degrees, similarity relations and 
lambda cuts. Moreover, we have also connected these declarative and ﬁxed-point semantics with the operational success set 
semantics by proving its correctness (that is, both soundness and completeness properties) at the level of ground atoms. 
One step beyond, the soundness property has been reinforced in [37] by coping with non ground goals after introducing an 
appropriate, sophisticated notion of thresholded fuzzy correct answer.
In the following sections we turn our attention on the implementation details and speciﬁcally on the implementation of 
the FASILL operational semantics.
4. The architecture and design of the FASILL system
The FASILL system we are presenting is a high level implementation written on top of SWI-Prolog and is publicly 
available at https://dectau .uclm .es /fasill. Fig. 4 shows the interactive console of the FASILL system running goals. It is also 
possible to try the FASILL system through its online tool, as Figs. 5 and 6 illustrate. Below the box containing the set of
FASILL rules in Fig. 5, we can ﬁnd a second box modeling the lattice of truth degrees ([0, 1], ≤) loaded by default in our 
tool (see Subsection 5.1 for more information). The third box of the ﬁgure contains a set of similarity equations whose 
closure will produce the similarity relations associated to the FASILL program. Finally, Fig. 6 shows both the set of fuzzy 
computed answers as well as the textual representation of the derivation tree associated to the execution of a goal (note 
that such tree can be also displayed in a graphical way, as Fig. 3 illustrates).
The complete implementation consists of about 4000 lines of code distributed among 9 Prolog modules. Fig. 7 shows 
the structure of the FASILL system through a functional dependency graph, where an arrow from one node x to another 
5 An L-expression is a goal where all atoms have been reduced to values of L.
6 We will always omit the subscript λ in the transition relation λ when λ = ⊥or, also, when λ is clear from the context.

146
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
Fig. 4. Interactive console of the FASILL system.
Fig. 5. Screenshot of the online tool showing a loaded program.
node y indicates that module x imports the module y, and a bidirectional arrow portrays a circular reference. From an 
alternative point of view, Fig. 8 illustrates a layered structure of the different sub-systems composing the FASILL system. In 
the following, we describe that components.
The fasill module contains the main/0 predicate which implements an interactive console. Hence, providing the in-
terface for the user. The command interpreter reads the input until the ﬁrst break line, analyzes the FASILL term and runs 
it as a goal. After the ﬁrst fuzzy computed answer, the user can press the key “;” to ﬁnd the next answer, or any other key 
to end the search. In addition, it is also possible to execute certain commands:

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
147
Fig. 6. Screenshot of the online tool showing the run input area.
fasill
unfolding
tuning
environment
parser
semantics
builtin
directives
exceptions
Fig. 7. Functional dependency graph of the FASILL system.
• :exit exits FASILL;
• :help prints the list of available commands;
• :lattice(Path) loads the lattice from ﬁle Path;
• :license prints the license message.
The parser module contains predicates for parsing FASILL programs and goals. The parser phase of FASILL rules and 
similarity schemes has been implemented using deﬁnite clause grammars (DCGs), whereas lattices are loaded as Prolog

148
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
Fig. 8. Layer diagram of the FASILL system.
⟨Exprn⟩
→
op(fx,n) ⟨Exprn−1⟩| op(fy,n) ⟨Exprn⟩|
⟨Exprn−1⟩op(xf,n) | ⟨Exprn⟩op(yf,n) |
⟨Exprn−1⟩op(xfx,n) ⟨Exprn−1⟩|
⟨Exprn−1⟩op(xfy,n) ⟨Exprn⟩|
⟨Exprn⟩op(yfx,n) ⟨Exprn−1⟩|
⟨Exprn−1⟩
⟨Expr0⟩
→
number | variable | string | ⟨List⟩| ⟨T erm⟩|
lparen ⟨Expr1300⟩rparen | lbrace ⟨Expr1300⟩rbrace
⟨T erm⟩
→
atom ⟨T erm2⟩
⟨T erm2⟩
→
lparen ⟨Expr999⟩⟨T erm3⟩| ϵ
⟨T erm3⟩
→
comma ⟨Expr999⟩⟨T erm3⟩| rparen
⟨List⟩
→
lbracket ⟨List2⟩
⟨List2⟩
→
⟨Expr999⟩⟨List3⟩| rbracket
⟨List3⟩
→
comma ⟨Expr999⟩⟨List3⟩| bar ⟨Expr999⟩rbracket | rbracket
⟨Rule⟩
→
⟨Expr1300⟩dot
⟨Prog⟩
→
⟨Rule⟩⟨Prog⟩| ϵ
Fig. 9. Formal grammar of FASILL.
ﬁles. The FASILL parser is a completely new parser implemented in Prolog using DCGs, i.e., it is not just an appropriate 
parameterization of the SWI-Prolog parser since, although FASILL and Prolog syntax are very close, there are some signiﬁcant 
differences, such as FASILL operators can be tagged (&godel, @aver,...). Also, by controlling the parser process, it is possible 
a speciﬁc syntax error treatment or to cope with the symbolic syntax used for tuning purposes, as we will see later.
Fig. 9 shows the production rules used for deriving FASILL programs and goals,7 where a terminal symbol with the form 
op(specifier,priority) denotes an atom with a given speciﬁer8 (xf, yf, fx, fy, xfx, xfy or yfx) and priority between 0 
and 1300. Table 1 shows all the terminal symbols of the grammar next to their regular expressions (with PCRE syntax9), 
which are only used at a descriptive level, since the lexical components are also analyzed through DCGs. Note that the
whitespace symbol represents both white spaces and comments. Table 2 gives the initial operator table of FASILL, which 
can be modiﬁed using the op/3 built-in predicate.
7 For simplicity, the terminal symbols comma and dot in the grammar denote atom symbols whose values are ‘,’ and ‘.’, respectively.
8 The speciﬁer indicates the type of operator (inﬁx, preﬁx or suﬃx) and its associativity.
9 Perl Compatible Regular Expressions.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
149
Table 1
Terminal symbols of FASILL grammar.
Symbol
Regular expression
whitespace
/\s*(?:%.*|\/\*(?:\n|\r|.)*?\*\/|\s+)\s*/
variable
/[A-Z_][a-zA-Z0-9_]*/
atom
/!|,|;|[a-z][0-9a-zA-Z_]*
|[#\$\&\*\+\-\.\/\:\<\=\>\?@\^\~\\]+
|’(?:(?:’’)|(?:\\\\)|(?:\\’)|[^’])*’/
number
/0o[0-7]+|0x[0-9a-f]+|0b[01]+
|\d+(?:\.\d+(?:[eE][+-]?\d+)?)?/i
string
/"([^"]|""|\\")*"/
lbrace
/\[/
rbrace
/\]/
lbracket
/\{/
rbracket
/\}/
lparen
/\(/
rparen
/\)/
bar
/\|/
Table 2
Initial FASILL operators.
Priority
Speciﬁer
Tagged
Operators
1300
xfx
yes
#<- <-
1300
xfx
no
:- <- ->
1300
fx
no
:- <-
1200
xfx
no
with
1100
xfy
yes
| #|
1100
xfy
no
| ;
1000
xfy
yes
& #&
1000
xfy
no
& ,
700
xfx
no
= \= ∼\∼
700
xfx
no
== \== @< @=< @> @>=
700
xfx
no
=..
700
xfx
no
is =:= =\= < =< > >=
500
yfx
no
+ - /\ \/
400
yfx
no
* / // rem mod « »
200
xfx
no
**
200
xfy
no
ˆ
200
fy
no
- +
The file_program/2 predicate parses a FASILL input ﬁle and compiles it into a set of Prolog terms. For instance, the
FASILL rule
good_hotel(X) <- @aver(elegant(X), @very(close(X,metro)))
is translated into the Prolog term
fasill_rule(
head(term(good hotel, [var(’X’)])),
body(term(@(aver),[term(elegant,[var(’X’)]),
term(@(very),[term(close,[var(’X’),term(metro,[])])])])), [id(4),syntax(fasill)]).
Here, we use a ground representation to store and manipulate FASILL terms with Prolog, where:
• variables are tagged as var/1 terms, whose only argument is an atom representing its identiﬁer (e.g. a variable with 
identiﬁer X is represented as var(’X’));
• numbers are tagged as num/1 terms, whose only argument is a number representing its value (e.g. a number with value
1 is represented as num(1));
• and atoms and compound terms are tagged as term/2 terms, whose ﬁrst argument is a term representing its func-
tor and the second one is a list containing its tagged arguments (e.g. an atom p(a,X) is represented as term(p, 
[term(a,[]), var(’X’)])).

150
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
The environment module contains predicates for manipulating the program rules, the lattice and the similarity rela-
tion loaded in the current session. The predicates program_consult/1, lattice_consult/1 and similarity_consult/1
allow new FASILL rules, lattices and similarity equations to be loaded into the environment from a ﬁle, respectively.
The semantics module implements the weak uniﬁcation algorithm and the FASILL computational steps, which are 
the operational semantics of the language. This module uses the builtin module, which contains a relation of built-
in predicates for loading source ﬁles (rules and similarity equations), arithmetic comparison, arithmetic evaluation, atom 
processing, control constructs, term comparison, term uniﬁcation, type testing, list manipulation, etc. As Prolog, FASILL
provides with an exception handling mechanism based on the built-in control constructions catch/3 and throw/1. The
exceptions module contains a set of predicates to generate exceptions of certain kind, e.g., instantiation errors, type errors 
or evaluation errors.
The unfolding and tuning modules implement the latest transformation techniques designed by our research group 
for unfolding and tuning fuzzy logic programs [51–53,56].
In the following section we concentrate on the modules environment and semantics which as mentioned are respon-
sible for the implementation of the FASILL Operational Semantics.
5. Implementation of the FASILL language
5.1. Modeling lattices
Lattices are described in the FASILL system by means of a set of Prolog clauses where the deﬁnition of the following 
predicates is mandatory: member/1, that identiﬁes the elements of the lattice and it only succeeds when its input parameter 
is a valid truth degree; members/1, which returns a list highlighting a subset of truth degrees –or even all them, in the case 
that the carrier set of the lattice be ﬁnite– and distance/3, that reports the distance between a couple of truth degrees 
(both predicates are only used at tuning time, as described in Subsection 5.5); bot/1 and top/1 stand for the inﬁmum 
and supremum elements of the lattice; and ﬁnally leq/2, that implements the ordering relation. Connectives are deﬁned 
as predicates whose meaning is given by a set of clauses. The name of a predicate has the form and_label, or_label or 
agr_label depending on whether it implements a conjunction, a disjunction or an aggregator, where label is an identiﬁer of 
that particular connective. The arity of the predicate is n + 1, where n is the arity of the connective that it implements, so 
its last parameter is a variable to be uniﬁed with the truth value resulting of its evaluation.
Example 3. The following Prolog clauses model a lattice of four truth degrees with a partial ordering relation:
members([bottom,alpha,beta,top]).
member(alpha).
member(beta).
member(bottom).
member(top).
top(top).
bot(bottom).
leq(bottom,X).
leq(X,X). leq(X,top).
level(bottom, 0). level(alpha, 1). level(beta, 1). level(top, 2).
distance(X,Y,Z):-level(X,L1),level(Y,L2),Z is abs(L1-L2).
agr_down(top,top). 
agr_down(bottom,bottom).
agr_down(alpha,bottom).
agr_down(beta,bottom).
This code also appears in the bottom-left corner of Fig. 10. Just above it, we can also see the Hasse diagram of the 
lattice. The auxiliary LatSimMaker tool was born in our research group for aiding the graphical design of lattices of truth 
degrees and generating code in form of Prolog clauses which can be directly imported by the FASILL system (even when 
the tool can be used in an independent way). Recent capabilities focus on testing properties and automatic generation of 
fuzzy connectives, distance measures, and similarity relations [26–28]. In particular, the code associated to the distance/3
predicate for this partially ordered lattice has been automatically produced by the tool. Note also in the box at the bottom-
right corner of Fig. 10 that this operation, which always returns a real number for each couple of input truth degrees, 
successfully veriﬁes the four mathematical properties classically required for valid distance measures.
By default, FASILL loads the real interval lattice ([0, 1], ≤), which is modeled by the predicates:
% Elements
bot(0.0).
top(1.0).
member(X) :- number(X), 0 =< X, X =< 1.
% Ordering relation
leq(X, Y) :- X =< Y.
% Distance
distance(X, Y, Z) :- Z is abs(Y-X).

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
151
Fig. 10. Graphical design of lattices of truth degrees and similarity relations with LatSimMaker.
as shown in the lattice box (just below the box containing the set of FASILL rules) in Fig. 5. Note that this lattice refers to 
an inﬁnite, non countable set of numbers. Obviously and similarly to other programming languages, FASILL cannot give a 
representation in the language to all constant elements of a non-countable set like real numbers. The ability to model truth 
degrees (and connectives for manipulating them) strongly depends on the underlying Prolog system. This problem even 
appears with the integer numbers on mostly ISO Prolog systems, which deﬁne max_integer and min_integer ﬂags for 
specifying the greatest and smallest values for which arithmetic operations work correctly. However, these limitations could 
be overcome by implementing in the lattice of truth degrees an appropriate data type for arbitrary-precision arithmetic, 
where calculations are performed on numbers whose digits of precision are limited only by the available memory of the 
system.
5.2. Implementing similarity relations
As mentioned in Example 2, a similarity relation can be partially speciﬁed by stating a set of what we called similarity 
equations. A similarity equation is a program declaration with textual form x/n ∼y/n = α. It is internally stored as a
Prolog fact fasill_similarity(x/n,y/n,α), which represents entries R(xn, yn) = α of the fuzzy binary relation R, and 
its intuitive reading is that two n-ary symbols, x and y, are related with a certain degree α, where the arity speciﬁcation 
for constants (/0) can be omitted in the equation. The predicate similarity_between/4 takes two symbols x and y, their 
arity n and a truth degree r, and it succeeds when R(xn, yn) = r.
Note that if the user introduces two or more conﬂicting equations, the FASILL system keeps the similarity degree from 
the ﬁrst one of them and displays a warning message. For instance, assuming that the user inserts the following equations:
bus ∼taxi = 0.4, bus ∼taxi = 0.7 and taxi ∼bus = 0.8, then FASILL simply considers that the similarity de-
gree between bus and taxi is 0.4, but sending the following message to the user: “warning in similarities:
warning(conflicting_equations(’/’(bus, 0), ’/’(taxi, 0), [0.4,0.7,0.8]))”.
When a set of similarity equations is loaded into the environment, the predicate similarity_closure/0 is executed in 
order to calculate the closure of the similarity equations, with the aim of generating a valid similarity relation [30,43,59].
similarity_closure :-
setof(Atom/Arity, _Atom^_TD^(
similarity_between(Atom, _Atom, Arity, _TD);
similarity_between(_Atom, Atom, Arity, _TD)
), Dom),

152
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
findall(sim(Atom1,Atom2,Arity,TD), similarity_between(Atom1,Atom2,Arity,TD), Scheme),
similarity_tnorm(Tnorm),
lattice_call_bot(Bot),
lattice_call_top(Top),
similarity_retract,
(similarity_closure_reflexive(Dom, Scheme, Tnorm, Bot, Top), false ; true),
(similarity_closure_symmetric(Dom, Scheme, Tnorm, Bot, Top), false ; true),
(similarity_closure_transitive(Dom, Scheme, Tnorm, Bot, Top), false ; true),
assertz(fasill_similarity_tnorm(Tnorm)).
This predicate ﬁrst looks for the domain D of the similarity relation R, that is, the set of all symbols which appear 
in the similarity equations (avoiding duplicate elements), and ﬁnds all the similarity equations as terms sim(x,y,n,r).10
Then, the current similarity scheme is retracted and the reﬂexive, symmetric and transitive closures are invoked.
The similarity_closure_reflexive/5 predicate calculates the reﬂexive closure of a similarity scheme. For that, it 
takes a symbol x ∈D and states that the symbol x with itself has a similarity degree of ⊤. This guarantees the reﬂexive 
property of the similarity relation, R(x, x) = ⊤.
similarity_closure_reflexive(Dom, _, _, _, Top) :-
member(X/Arity, Dom),
assertz(fasill_similarity(X/Arity,X/Arity,Top)).
The similarity_closure_symmetric/5 predicate calculates the symmetric closure of a similarity scheme. For that, it 
takes two symbols x, y ∈D and ﬁnds if there is an equation x ∼y = α or y ∼x = α. If it exists, the predicate states that the 
similarity degree between symbols x and y is α, and viceversa. This guarantees the symmetric property of the similarity 
relation, R(x, y) = R(y, x).
similarity_closure_symmetric(Dom, Scheme, _, _, _) :-
member(X/Arity, Dom),
member(Y/Arity, Dom),
\+(fasill_similarity(X/Arity,Y/Arity,_)),
once(member(sim(X,Y,Arity,TD), Scheme) ; member(sim(Y,X,Arity,TD), Scheme)),
assertz(fasill_similarity(X/Arity,Y/Arity,TD)),
assertz(fasill_similarity(Y/Arity,X/Arity,TD)).
Finally, the similarity_closure_transitive/5 predicate calculates the transitive closure of a similarity scheme. For 
that, it takes three symbols x, y, z ∈D and states that the symbols x and z have a similarity degree (R(x, y) △R(y, z)) ∨
R(x, z). This guarantees the transitive property of the similarity relation, R(x, z) ≥R(x, y) △R(y, z).
similarity_closure_transitive(Dom, _, Tnorm, Bot, _) :-
member(Y/Arity, Dom),
member(X/Arity, Dom), X \= Y,
member(Z/Arity, Dom), Z \= Y, X \= Z,
once(fasill_similarity(X/Arity,Z/Arity,TDxz) ; TDxz = Bot),
once(fasill_similarity(X/Arity,Y/Arity,TDxy)),
once(fasill_similarity(Y/Arity,Z/Arity,TDyz)),
lattice_call_connective(’&’(Tnorm), [TDxy,TDyz], TDy),
lattice_call_connective(’|’(Tnorm), [TDxz,TDy], TD),
retractall(fasill_similarity(X/Arity,Z/Arity,_)),
assertz(fasill_similarity(X/Arity,Z/Arity,TD)).
Our algorithm for computing the transitive closure is a direct adaptation of the Warshall’s algorithm, which has com-
plexity O(n3), where n is the number of elements in the relation (vertices in the corresponding graph). However, note that 
the cost of computing the transitive closure does not produce overhead at execution time because it is computed at compile 
time. At execution time we only use the entries of the resulting similarity and the main overhead is due to the access to 
the entries of the similarity relation.
10 These terms are stored as an internal representation in the system. They appear in an auxiliary list when computing closures and hence, they never 
produce interferences with the set of facts deﬁning the fasill_similarity/3 predicate.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
153
5.3. Implementing weak uniﬁcation
Weak uniﬁcation applies both to terms and atoms. The speciﬁc λ-weak uniﬁcation algorithm is implemented following 
Robinson’s algorithm for syntactic uniﬁcation [61] which, in the context of a high level implementation, closely resembles 
and behaves as the Martelli-Montanari’s uniﬁcation algorithm [48].
The lambda_wmgu/5 predicate calculates the thresholded weak most general uniﬁer of two expressions.
lambda_wmgu(ExprA, ExprB, Lambda, OccursCheck, State) :-
lattice_call_top(Top),
empty_assoc(Subs),
lambda_wmgu(ExprA, ExprB, Lambda, OccursCheck, state(Top,Subs), State).
The call lambda_wmgu(ExprA, ExprB, Lambda, OccursCheck,state(TD,WMGU)) succeeds when WMGU is the λ-
wmgu of ExprA with ExprB and TD is their uniﬁcation degree, with TD ≥Lambda. Intuitively, the uniﬁcation degree will 
represent the truth degree associated with the (query) computed instance.
The auxiliary predicate lambda_wmgu/6 is used by lambda_wmgu/5 to go from one state to another during the uniﬁcation 
process, starting by the initial state ⟨⊤, id⟩. Here, the ﬁrst two arguments are the expressions to be uniﬁed (in ground 
representation), the third argument is the value of λ (also in ground representation), the fourth argument is an atom 
indicating whether the occurs check should be performed (true) or not (false), the ﬁfth argument is the current state 
of the uniﬁcation, and the sixth argument is the next state of the uniﬁcation. A state is represented in Prolog by a term 
of the form state(TD, Subs), where TD is the uniﬁcation degree and the substitution Subs is the λ-wmgu. The FASILL
system uses the assoc library from SWI-Prolog to manipulate substitutions as association lists (implemented as AVL trees). 
As Prolog, FASILL allows the use of anonymous variables “_” in order to unify an expression without linking its value to any 
variable.
%%% Anonymous variable
lambda_wmgu(var(’_’), _, _, _, State, State) :- !.
lambda_wmgu(_, var(’_’), _, _, State, State) :- !.
%%% Variable with expression
lambda_wmgu(var(X), Y, Lambda, OccursCheck, state(TD,Subs), State_) :-
get_assoc(X, Subs, Z), !,
lambda_wmgu(Z, Y, Lambda, OccursCheck, state(TD,Subs), State_).
lambda_wmgu(var(X), Y, _, OccursCheck, state(TD,Subs0), state(TD,Subs3)) :- !,
(OccursCheck == true -> occurs_check(X, Y) ; true),
list_to_assoc([X-Y], Subs1),
compose(Subs0, Subs1, Subs2),
put_assoc(X, Subs2, Y, Subs3).
%%% Expression with variable
lambda_wmgu(X, var(Y), Lambda, OccursCheck, State, State_) :- !,
lambda_wmgu(var(Y), X, Lambda, OccursCheck, State, State_).
%%% Number with number
lambda_wmgu(num(X), num(X), _, _, State, State) :- !.
%%% Term with term
lambda_wmgu(term(X,Xs), term(X,Ys), Lambda, OccursCheck, State, State_) :- !,
length(Xs, Arity),
length(Ys, Arity),
lambda_wmgu(Xs, Ys, Lambda, OccursCheck, State, State_).
lambda_wmgu(term(X,Xs), term(Y,Ys), Lambda, OccursCheck, state(TD, Subs), State) :- !,
length(Xs, Arity),
length(Ys, Arity),
similarity_between(X, Y, Arity, TDxy),
similarity_tnorm(Tnorm),
lattice_call_connective(’&’(Tnorm), [TD, TDxy], TD2),
lattice_call_leq(Lambda, TD2),
lattice_call_bot(Bot),
TD2 \== Bot,
lambda_wmgu(Xs, Ys, Lambda, OccursCheck, state(TD2, Subs), State).
%%% Arguments
lambda_wmgu([], [], _, _, State, State) :- !.
lambda_wmgu([X|Xs], [Y|Ys], Lambda, OccursCheck, State, State_) :- !,
lambda_wmgu(X, Y, Lambda, OccursCheck, State, StateXY),

154
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
StateXY = state(_, Subs),
apply(Subs, Xs, Xs_),
apply(Subs, Ys, Ys_),
lambda_wmgu(Xs_, Ys_, Lambda, OccursCheck, StateXY, State_).
The unify/3 predicate applies a substitution to an expression, returning the resulting expression.
apply(Subs, term(T,Args), term(T,Args_)) :- !, apply(Subs, Args, Args_).
apply(Subs, var(X), Y) :- !, (get_assoc(X, Subs, Y) -> true ; Y = var(X)).
apply(Subs, [X|Xs], [Y|Ys]) :- !, apply(Subs, X, Y), apply(Subs, Xs, Ys).
apply(_, X, X).
Predicates whose functor starts by lattice_call_ are deﬁned in the environment module, and they perform calls 
to predicates of the lattice currently loaded into the system. For instance, the lattice_call_member/1 predicate takes a 
term and checks if it is a member of the lattice (to_prolog/2 predicate transforms out internal representation of terms to 
standard Prolog terms in order to use the predicates of the lattice deﬁned in Prolog).
lattice_call_member(Member) :-
current_predicate(member/1), !,
to_prolog(Member, Prolog),
member(Prolog).
lattice_call_member(_) :-
existence_error(procedure, member/1, lattice/0, Error),
throw_exception(Error).
The value of the lambda cut, λ, can be set in a program by changing the value of the FASILL ﬂag lambda_unification
through the built-in predicate (or the directive) set_fasill_flag/2.11 Furthermore, the FASILL language also implements 
an standard uniﬁcation algorithm for calculating the most general uniﬁer of two expressions, mgu/3. Similarly, the user 
can disable the weak uniﬁcation in a program by changing the value of the FASILL ﬂag weak_unification to false, or 
enable the occurs check by setting the value of the FASILL ﬂag occurs_check to true. The unify/4 predicate chooses 
the appropriate uniﬁcation algorithm based on the value of these ﬂags and returns the λ-wmgu or the mgu of two FASILL
terms.
unify(Term1, Term2, OccursCheck, Subs) :-
current_fasill_flag(weak_unification, term(true,[])), !,
current_fasill_flag(lambda_unification, Lambda_),
(var(OccursCheck) -> current_fasill_flag(occurs_check, term(OccursCheck, [])) ; true),
(Lambda_ == bot ->
lattice_call_bot(Lambda) ;
(Lambda_ == top ->
lattice_call_top(Lambda) ;
Lambda = Lambda_
)
),
lambda_wmgu(Term1, Term2, Lambda, OccursCheck, Subs).
unify(Term1, Term2, OccursCheck, state(Top, Subs)) :-
(var(OccursCheck) -> current_fasill_flag(occurs_check, term(OccursCheck, [])) ; true),
mgu(Term1, Term2, OccursCheck, Subs),
lattice_call_top(Top).
FASILL also implements a weak uniﬁcation operator, denoted by ∼/2, which is the fuzzy counterpart of the syntactical 
uniﬁcation operator =/2 of standard Prolog. It can be used to weakly unify two terms in the context of a goal or in 
the body of a FASILL rule. For instance, it is possible to launch the goal Term1 ∼Term2 or, equivalently, ’∼’(Term1, 
Term2) as a query to the system. There are also versions of these predicates that force the uniﬁcation with occurs check:
unify_with_occurs_check/2 and weakly_unify_with_occurs_check/2.
11 For example, the user can set the lambda cut value to 0.5 by running the query set_fasill_flag(lambda_cut, 0.5).

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
155
5.4. Implementing inference steps
The operational semantics of FASILL is implemented as a state transition system. The query/2 predicate succeeds when 
the ﬁrst argument is a goal (in ground representation) and the second one is a fuzzy computed answer for that goal. A state 
is a term of the form state(Goal, Substitution), and a f.c.a. is a state where Goal is a truth degree of the lattice.
query(Goal, Answer) :-
get_variables(Goal, Vars),
State = state(Goal, Vars),
derivation(top_level/0, State, Answer, _).
The initial state of the derivation is formed by the Goal argument of query/2 and an initial substitution {x0/x0, ..., xi/xi}
that contains every variable of the goal linked to itself. For instance, the initial substitution for the goal elegant(X, Y)
would be encoded as the Prolog association list t(’X’, var(’X’), >, t, t(’Y’, var(’Y’), -, t, t)), denoting that 
the variable X has the value var(’X’) and the variable Y has the value var(’Y’).
The derivation/4 predicate goes from one state to the next until reaches an uncaught exception or a fuzzy computed 
answer. This predicate takes the indicator of the last selected atom and the initial state, and it returns the following state 
and a list containing information about the performed steps (for debugging purposes).
derivation(_, exception(Error), exception(Error), []) :- !.
derivation(_, state(Goal,Subs), State, []) :-
is_fuzzy_computed_answer(Goal), !,
lattice_call_bot(Bot),
(Bot == Goal -> current_fasill_flag(failure_steps, term(true, [])) ; true),
State = state(Goal, Subs).
derivation(From, State, State_, [X|Xs]) :-
catch(inference(From, State, State1, X), Error, (State1 = exception(Error), !)),
derivation(X, State1, State_, Xs).
The is_fuzzy_computed_answer/1 predicate invokes the member/1 predicate of the lattice to check if the goal of the 
corresponding state is a truth degree in order to return the f.c.a.. In each step, derivation/4 performs one inference 
through the inference/4 predicate.
inference(From, State, State_, Info) :-
operational_step(From, State, State_, Info).
inference(From, state(Goal,Subs), State_, Info) :-
interpretable(Goal),
interpretive_step(From, state(Goal,Subs), State_, Info).
The inference/4 predicate ﬁrst tries to perform an operational step. If it is not possible, then it tries to do an 
interpretive step. Thus, interpretive steps are only performed when all the atoms of the goal have been resolved. The
interpretable/1 predicate succeeds when a goal does not contain any atom.
Operational steps are divided into two kinds of steps: success steps and failure steps. A failure step is only performed 
when it is not possible to perform a success step. This is controlled by the assertion and retraction of the dynamic predicate
check_success/0, given that a cut after a success step could prune some f.c.a.’s of the derivation.
operational_step(From, State1, State2, Info) :-
assertz(check_success),
success_step(From, State1, State2, Info),
retractall(check_success).
operational_step(_, State1, State2, Info) :-
check_success,
retractall(check_success),
failure_step(State1, State2, Info).
The success_step/4 predicate works backwards, like a SLD resolution step in a Prolog interpreter. First, success_step/4
selects the left-most atom from the goal, and checks if it is a built-in predicate or a user-deﬁned predicate. If the atom is 
a built-in predicate, it is resolved by the eval_builtin_predicate/4 predicate of the builtin module. If it is a user-
deﬁned predicate, following the inference rules deﬁned in Section 3.2, it looks for the FASILL rules whose head uniﬁes with 
the atom, and replaces the selected atom in the goal by the body of the rule, composing the λ-wmgu with the substitution 
of the previous state. If the predicate does not exist, an existence_error exception is thrown.

156
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
success_step(From, state(Goal,Subs), state(Goal_,Subs_), Name2/Arity) :-
select_atom(Goal, ExprVar, Var, Expr),
Expr = term(Name, Args),
length(Args, Arity),
(Name = Name2 ;
(current_fasill_flag(weak_unification, term(true, [])) ->
lattice_call_bot(Bot),
similarity_between(Name, Name2, Arity, Sim),
Name \= Name2, Sim \== Bot)
),
% Builtin predicate
(is_builtin_predicate(Name2/Arity) -> (
eval_builtin_predicate(Name2/Arity, state(Goal,Subs),
selected(ExprVar, Var, Expr), state(Goal_,Subs_))
) ; (
% User-defined predicate
(program_has_predicate(Name2/Arity) -> (
lattice_tnorm(Tnorm),
lattice_call_top(Top),
program_clause(Name2/Arity, fasill_rule(head(Head), Body, _)),
rename([Head,Body], [HeadR,BodyR]),
unify(Expr, HeadR, _, state(TD, SubsExpr)),
(BodyR = empty -> Var = TD ; (
BodyR = body(Body_),
(TD == Top -> Var = Body_ ; Var = term(’&’(Tnorm), [TD,Body_]))
)),
apply(SubsExpr, ExprVar, Goal_),
compose(Subs, SubsExpr, Subs_)
) ; (
% Undefined predicate
existence_error(procedure, Name/Arity, From, Error),
retractall(check_success),
throw_exception(Error)
))
)).
The failure_step/4 predicate is invoked when an atom fails, replacing the selected atom by the bottom of the lattice.
failure_step(state(Goal,Subs), state(Goal_,Subs), ’FS’) :-
current_fasill_flag(failure_steps, term(true, [])),
lattice_call_bot(Bot),
select_atom(Goal, Goal_, Bot, _).
Finally, the interpretive_step/4 predicate is invoked when the goal does not contain any atom. This predicate selects 
the left-most connective whose arguments are all truth degrees, and evalutes it by calling the lattice_call_conective/3
predicate, which invokes the proper connective from the lattice and returns the result.
interpretive_step(From, state(Goal,Subs), state(Goal_,Subs), ’IS’) :-
( select_expression(Goal, Goal_, Var, Expr) -> interpret(Expr, Var) ; (
type_error(truth_degree, Goal, From, Error),
throw_exception(Error)
)).
Note that some predicates use the terms bot and top as a ground representation for the bottom and top elements of 
the lattice, respectively. These terms are also evaluated by the application of interpretive steps.
interpret(bot, Bot) :- !, lattice_call_bot(Bot).
interpret(top, Top) :- !, lattice_call_top(Top).
interpret(term(Op, Args), Result) :- lattice_call_connective(Op, Args, Result).

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
157
5.5. Implementing tuning and unfolding techniques
When specifying a fuzzy logic program, it might sometimes be diﬃcult to assign weights—truth degrees—to program 
rules, as well as to determine the right connectives. In order to overcome this drawback, in [53,56] we have introduced a 
symbolic extension of our framework where it is possible write rules containing symbolic weights and symbolic connectives, 
i.e., truth degrees and operators –denoted as “#label”– which are not deﬁned on its associated lattice. In order to evaluate 
these programs, we can apply the operational semantics seen so far by simply delaying the evaluation of symbolic expres-
sions. Therefore, a symbolic fuzzy computed answer –called sfca– could now include symbolic (unknown) truth values and 
connectives. The approach is correct in the sense that using the operational mechanism and then replacing the unknown 
values and connectives by concrete ones gives the same result as replacing these values and connectives in the original 
symbolic program and, then, applying the same operational semantics on the resulting FASILL program. Symbolic programs 
can be used to tune a program w.r.t. a given set of test cases, thus easing what is considered the most diﬃcult part of the 
process: the speciﬁcation of the right weights and connectives for each rule.
Example 4. In this section we will focus our attention on the following symbolic fuzzy logic program:
good_restaurant(X) <- @very(food(X)) #|s1 #@s2(price(X), service(X)).
food(attica) with 0.8.
price(attica) with 0.9.
service(attica) with #s3.
food(celler) with 0.9.
price(celler) with 0.7.
service(celler) with 0.7.
food(gaggan) with 0.7.
price(gaggan) with 0.8.
service(gaggan) with 1.0.
Here, we consider a travel guide that offers information about three restaurants, named attica, celler and gaggan, where 
each one of them is featured by three factors: the restaurant services, the quality of its food, and the price, denoted by 
predicates service, food and price, respectively. We assume that all weights can be easily obtained except for the weight of 
the fact service(attica), which is unknown, as expressed by the symbolic weight #s3. Since the programmer has also some 
doubts on the connectives to be used in the ﬁrst rule, she introduces the symbolic disjunction and aggregator symbols #|s1
and #@s2.
Typically, a programmer has a model in mind where some parameters have a clear value. For instance, the truth value of 
a rule might be statistically determined and, thus, its value is easy to obtain. In other cases, though, the most appropriate 
values and/or connectives depend on subjective notions and, thus, programmers do not know how to obtain these values. In 
a typical scenario, we have an extensive set of expected computed answers (i.e., test cases), so the programmer can follow a 
“try and test” strategy. Unfortunately, this is a tedious and time consuming operation. Actually, it might even be impractical 
when the program should correctly model a large number of test cases.
The ﬁrst action for initializing the tuning process consists in introducing a set of test cases with syntax: r − > Q, where 
r is the desired truth degree for the f.c.a. associated to query Q (which obviously does not contain symbolic constants). For 
instance, in our running example we can introduce the following three test cases: 0.75->good_restaurant(attica), 0.8-
>good_restaurant(celler) and 0.9->good_restaurant(gaggan). Then, users simply need to click on the Generate 
substitution button for proceeding with the tuning process. The precision of the technique depends on the set of symbolic 
substitutions considered at tuning time. So, for assigning values to the symbolic constants, our tool takes into account all 
the truth values deﬁned on a members/1 predicate (which in our case is declared as members([0, 0.1, 0.2, 0.3, 0.4, 
0.5, 0.6, 0.7, 0.8, 0.9, 1])) as well as the set of connectives deﬁned in the lattice associated to the program, which 
in our previous example coincides with the three conjunction and disjunction connectives based on the so-called Product, 
Gödel and Łukasiewicz logics. Obviously, the larger the domain of values and connectives is, the more precise the results are.
For tuning a symbolic program, we don’t follow an ineﬃcient, basic method based on applying each symbolic substitution 
to the original symbolic program and then fully executing the resulting instantiated FASILL programs. Instead of it, we have 
implemented a thresholded symbolic strategy where symbolic substitutions are directly applied to sfca’s (thus, only the 
interpretive stage is repeatedly executed) and many useless computations are prematurely disregarded by appropriately 
using dynamic thresholds.
The system also reports the processing time required by each method and offers an option for applying the best symbolic 
substitution to the original symbolic program in order to show the ﬁnal, tuned program. In our case, the best substitution 
is  = {#|s1/|godel, #@s2/@aver, #s3/0.6} with a deviation12 of 0.01. By clicking the Apply substitution button, we obtain a 
fuzzy program without symbolic substitutions, which can be executed w.r.t. a goal like good_restaurant(X) thus obtaining 
the following three f.c.a.’s: <0.75, X/attica>, <0.81, X/celler> and <0.9, X/gaggan>.
The tuning module contains predicates for tuning symbolic programs. The tuning_thresholded/2 predicate runs the 
tuning process with the program and the test cases currently loaded into the environment, and returns the best symbolic 
substitution and its deviation.
12 This measure is computed by the distance/3 predicate which is mandatorily deﬁned on each lattice of truth degrees, even for non-numeric lattices, 
as illustrated in Example 3.

158
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
tuning_thresholded(Best, Deviation) :-
testcases_disjoint_sets(Tests, Preconditions),
tuning_thresholded(Tests, Preconditions, Subs, Deviations),
append(Subs, Best),
sum_list(Deviations, Deviation).
The testcases_disjoint_sets/2 predicate splits the test cases and the preconditions into disjoint sets based on their 
symbolic constants, while predicate tuning_thresholded/4 performs the search of the best symbolic substitution for each 
subset. Then, the resulting substitutions are joined and the deviation of each substitution is added together to obtain the 
total deviation. Note that predicate testcases_disjoint_sets/2 partially executes the test cases replacing the goals by
sfca’s, given that the original goals are no longer necessary for the tuning process.
tuning_thresholded([], [], [], []).
tuning_thresholded([S-Tests|Ts], [S-Preconditions|Ps], [Best|Bs], [Deviation|Ds]) :-
retractall(tuning_best_substitution(_,_)),
( symbolic_substitution(S, Subs),
tuning_check_preconditions(Preconditions, Subs),
tuning_thresholded_do(Tests, Subs, 0.0),
fail ; true ),
tuning_best_substitution(Best, Deviation),
tuning_thresholded(Ts, Ps, Bs, Ds).
The symbolic_substitution/2 predicate takes a set of symbolic constants and generates all the possible symbolic sub-
stitutions on backtracking. The predicate tuning_check_preconditions/2 checks that all the preconditions are satisﬁed, 
and the tuning_thresholded_do/3 predicate takes a set of test cases as well as a symbolic substitution and computes the 
total deviation of the symbolic substitution (initially 0.0). The best symbolic substitution is stored as a dynamic Prolog fact
tuning_best_substitution/2, that is queried after trying all the symbolic substitutions.
tuning_thresholded_do([], Subs, Error) :- !,
(tuning_best_substitution(_, Best) -> Best > Error ; true),
retractall(tuning_best_substitution(_,_)),
asserta(tuning_best_substitution(Subs, Error)).
tuning_thresholded_do([testcase(TD,SFCA)|Tests], Subs, Error) :-
(tuning_best_substitution(_, Best) -> Best > Error ; true),
apply_symbolic_substitution(SFCA, Subs, FCA),
query(FCA, state(TD_, _)),
lattice_call_distance(TD, TD_, num(Distance)),
Error_ is Error + Distance,
tuning_thresholded_do(Tests, Subs, Error_).
The tuning_thresholded_do/3 predicate ﬁrst checks that the partial deviation of the current substitution is less than 
the deviation of the best symbolic substitution found at the moment. Then, the symbolic substitution is applied to the goal 
of a test case by the apply_symbolic_substitution/3 predicate and the ﬁnal truth degree is computed by query/2. The
lattice_call_distance/2 computes the distance between the f.c.a. and the expected truth degree.
On the other hand, unfolding is a well-known, widely used, semantics-preserving program transformation operation 
which is able to improve programs, generating more eﬃcient code. The unfolding transformation traditionally considered in 
pure logic programming consists in the replacement of a program clause C by the set of clauses obtained after applying a 
computation step in all its possible forms on the body of C [68,60]. In [34] we successfully adapted such operation to fuzzy 
logic programs dealing with lattices of truth degrees but not with similarity relations, while in [52] we formally introduced 
its symbolic extension for manipulating symbolic programs. Finally, in [51] we proposed an unfolding deﬁnition successfully 
coping with similarity relations as the ones attached to FASILL programs.
In essence, the fuzzy unfolding of a rule (without empty body) R : A ←B in a program P is a new program P′ where 
R is replaced by the set of unfolded rules {Aσ ←B′ | ⟨B; id⟩ →AS/I S ⟨B′; σ⟩}. Unfolding can be iterated several times, thus 
building a sequence of transformed programs where each one in the sequence produces the same set of f.c.a.’s for a given 
goal, but reducing the length of derivations.
Example 5. For instance, the repeated unfolding of the ﬁrst rule in Example 4 simply consists in replacing it by the following 
three ones:

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
159
good_restaurant(attica) <- (0.6400000000000001 #|s1 #@s2(0.9, #s3)).
good_restaurant(celler) <- (0.81 #|s1 #@s2(0.7, 0.7)).
good_restaurant(gaggan) <- (0.48999999999999994 #|s1 #@s2(0.8, 1.0)).
The unfolding module contains predicates for unfolding program rules. The most important predicate of this module is
unfold/2, that takes a FASILL rule and returns all the unfolded rules on backtracking. First, the variables of the rule to be 
unfolded are renamed by the rename/2 predicate, then a computational step is performed on the body of the rule by the
inference/4 predicate, and the substitution obtained after the inference is applied to the head of the rule by the apply/3
predicate. The unfolded rule is made up of the new head and the expression resulting from the inference.
unfold(R1, R2) :-
retractall(unfolding_id(_)),
assertz(unfolding_id(1)),
R1 = fasill_rule(head(Head), body(Body), [id(Id)|_]),
rename([Head,Body], [HeadR,BodyR]),
get_variables(BodyR, Vars),
inference(unfolding/0, state(BodyR, Vars), state(Expr, Subs), _),
apply(Subs, HeadR, Head_),
unfolding_id(R),
atom_number(Atom, R), atom_concat(Id, ’-’, Id_), atom_concat(Id_, Atom, Id2),
retractall(unfolding_id(_)), N is R+1, assertz(unfolding_id(N)),
R2 = fasill_rule(head(Head_), body(Expr), [id(Id2),syntax(fasill)]).
The predicate unfold/1 searches all the unfolded rules of a given rule, retracts the old rule and asserts the new ones. 
The sort_rules_by_id/0 predicate reorders the rules so that the unfolded rules occupy the position of the removed rule.
unfold(R1) :-
findall(R, unfold(R1, R), Rules),
Rules \= [],
once(retract(R1)),
( member(Rule, Rules), assertz(Rule), fail ; true ),
sort_rules_by_id.
5.6. FASILL and Prolog
Following our philosophy of attracting Prolog programmers, FASILL is not only implemented as a meta-interpreter on 
the top of SWI-Prolog, but it also incorporates many of the predeﬁned predicates of the standard Prolog library. In this 
section we describe how these predicates are incorporated into our language and we give a catalog of the most relevant 
ones. FASILL inherits many of the built-in predicates deﬁned by the ISO Prolog standard, such as:
• the control constructs ‘,’/2 (conjunction), ‘;’/2 (disjunction), call/[1..], catch/3 and throw/1;
• the term uniﬁcation operators ‘=’/2 (uniﬁcation) and ‘\=’/2 (not uniﬁcation);
• the term comparison operators ‘==’/2 (syntactic equality), ‘\==’/2 (syntactic inequality), ‘@<’/2 (less than), ‘@=<’/2
(less than or equal to), ‘@>’/2 (greater than) and ‘@>=’/2 (greater than or equal to);
• the arithmetic operators is/2 (arithmetic evaluation), ‘=:=’/2 (arithmetic equality), ‘=\=’/2 (arithmetic inequality),
‘<’/2 (arithmetic less than), ‘=<’/2 (arithmetic less than or equal to), ‘>’/2 (arithmetic greater than) and ‘>=’/2
(arithmetic greater than or equal to);
• the type testing predicates atom/1, compound/1, var/1, nonvar/1, number/1, integer/1 and float/1;
• the atom processing predicates atom_length/2 and atom_concat/3;
• and the all solutions predicate findall/3.
Moreover, FASILL extends this set of predicates in order to deal with the vagueness and the uncertainty of their pro-
grams:
• the control constructs truth_degree/2, top/0 and bot/0;
• and the term weak uniﬁcation operators ‘∼’/2 (weak uniﬁcation) and ‘\∼’/2 (not weak uniﬁcation).
The truth_degree/2 predicate allows the user to retrieve the truth degree of a given goal. The call truth_degree(Goal, 
TD) succeeds when TD is the truth degree for the goal Goal. Note that the lattice of truth degrees used by default by Prolog
programs only contains two elements, the top and bottom ones, represented by the keywords true and fail. So, a possible 
implementation of truth_degree/2, valid only for the Prolog case, could be represented by the following couple of clauses:

160
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
Table 3
Average runtime (in milliseconds) of an arbitrary FASILL program with n facts after 100 exe-
cutions, depending on the t-norm used in derivations.
n
Runtime
Boolean
Gödel
Łukasiewicz
Product
50
14
14
14
14
100
53
51
50
50
200
216
209
208
202
300
439
443
471
452
400
779
778
774
775
500
1209
1202
1200
1201
1000
4860
4763
4729
4887
truth_degree(Goal, true) :- call(Goal), !.
truth_degree(_, fail).
However, for the more general case of FASILL programs managing richer lattices of truth degrees, we need to implement 
this predicate in a more ﬂexible way, as we are going to explain. The eval_builtin_predicate/4 predicate from builtin
module takes a state and the selected atom from the goal of that state, and returns the next state of the derivation. For 
instance, the following clause of eval_builtin _predicate/4 implements the truth_degree/2 FASILL predicate:
eval_builtin_predicate(truth_degree/2,
state(_, Subs), selected(ExprVar, Var, Term), state(ExprVar, Subs_)) :-
Term = term(truth_degree, [Goal,TD]),
derivation(truth_degree/2, state(term(call,[Goal]),Subs), State, _),
(State = state(TD_,Subs_) ->
Var = term(’~’,[TD,TD_]) ;
State = exception(Error), throw_exception(Error)).
Here, the ﬁrst argument of the truth_degree/2 term is executed as a goal and, for each f.c.a., the truth degree of the 
answer is weakly uniﬁed with the second argument of truth_degree/2.
6. Benchmarking and assessment
In order to determine the overhead introduced by our implementation techniques to materialize fuzzy logic programming 
over the traditional logic programming paradigm, we have measured the execution time and the number of inferences of 
both, interpreted and compiled versions of some FASILL programs described in the following assessments.13 All tests have 
been executed in SWI-Prolog 8.0.6 (64 bits) using a desktop computer equipped with an AMD OpteronTM processor @ 1593 
MHz and 2.00 GB RAM.
In our ﬁrst experiment, we discuss the results of having a t-norm differently from the Boolean one in a FASILL program. 
We consider a general rule “p <- p_1 & p_2 & ... & p_n” together with a set of facts “p_i <- w_i” deﬁning each 
propositional symbol p_i with a random weight w_i arbitrarily produced in the real unit interval. Table 3 resumes the 
average runtime achieved when executing different instances of the proposed FASILL program by using the t-norms of 
the Gödel, Łukasiewicz and Product fuzzy logics (all of them based on arithmetic operations). The contrast made w.r.t. the 
Boolean case (where the main rule looks as the Prolog clause p :- p_1, p_2,...,p_n), reveals that the evaluation of 
different t-norms does not produce a signiﬁcant overload at execution time.
The FASILL system is able to compile fuzzy logic programs to standard Prolog code. The translation technique was 
initially conceived for dealing with MALP programs [35], which are also FASILL programs not dealing with similarities, and 
it suﬃces for being used in the next pair of the experiments we are going to describe in this section. The key point of this
Prolog code is to extend each atom of the program with an extra argument, called truth variable, of the form TVi, which 
is intended to contain the truth degree obtained after the subsequent evaluation of the atom. In the case of a fact, the 
extra argument obviously contains its weight. For instance, “p(a) <- 0.5” is simply translated into the Prolog fact “p(a, 
0.5)”. Fuzzy connectives are represented as predicates deﬁned in the lattice associated to the program. For instance, the 
role of &godel is played by the Prolog predicate and_godel/3. Since the fuzzy connective &godel is a binary operation, 
then its associated predicate has arity three: two parameters plus the result, returned in the third argument TV. So, the 
result of compiling a rule like “p(X) <- q(X,Y) &godel p(Y)” would be the Prolog clause “p(X,TV0) :- q(X,Y,TV1), 
p(Y,TV2), and_godel(TV1,TV2,TV0)”. Fig. 11 shows a FASILL program (adapted from [66]), which is also both a MALP
and a Prolog program, together with its compiled version to Prolog.
13 Programs used in our experiments can be executed in the online version of FASILL, whose source code is freely available at https://github .com /
jariazavalverde /fasill. Moreover, the tests performed in this article can be found at the folder /test/experiments/ in the same repository.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
161
:-set_fasill_flag(symbolic,false).
:-set_fasill_flag(failure_steps,false).
:-set_fasill_flag(weak_unification,false).
queens(N) :-
queens(N, _),
false ;
true.
queens(N, Qs) :-
gen_list(N, Qs),
place_queens(N, Qs, _, _).
gen_list(0, []).
gen_list(N, [_|L]) :-
N > 0,
N1 is N-1,
gen_list(N1, L).
place_queens(0, _, _, _).
place_queens(I, Qs, Ups, [_|Ds]) :-
I > 0,
I1 is I-1,
place_queens(I1, Qs, [_|Ups], Ds),
place_queen(I, Qs, Ups, Ds).
place_queen(Q, [Q|_], [Q|_], [Q|_]).
place_queen(Q, [_|Qs],[_|Ups],[_|Ds]) :-
place_queen(Q, Qs, Ups, Ds).
(a) Original code.
queens(N, TD) :-
queens(N, _, TD1),
TD1 \= false, TD2 = false,
and_bool(TD1, TD2, TD),
TD \= false ; TD = true.
queens(N, Qs, TD) :-
gen_list(N, Qs, TD1), TD1 \= false,
place_queens(N, Qs,_,_, TD2), TD2 \= false,
and_bool(TD1, TD2, TD), TD \= false.
gen_list(0, [], true).
gen_list(N, [_|L], TD) :-
N > 0, N1 is N-1,
gen_list(N1, L, TD), TD \= false.
place_queens(0, _, _, _, true).
place_queens(I, Qs, Ups, [_|Ds], TD) :-
I > 0, I1 is I-1,
place_queens(I1, Qs, [_|Ups], Ds, TD1),
TD1 \= false,
place_queen(I, Qs, Ups, Ds, TD2),
TD2 \= false,
and_bool(TD1, TD2, TD), TD \= false.
place_queen(Q, [Q|_], [Q|_], [Q|_], true).
place_queen(Q, [_|Qs], [_|Ups], [_|Ds], TD) :-
place_queen(Q, Qs, Ups, Ds, TD),
TD \= false.
(b) Compiled version.
Fig. 11. Problem of the n queens in FASILL and its compiled version to Prolog.
Table 4
Average runtime (in milliseconds) and inferences of the problem of the n queens executed in the FASILL interpreter and in SWI-Prolog (both the compiled 
version of the FASILL program and the original program in Prolog) after 50 executions.
n
FASILL (interpreted)
FASILL (compiled)
Prolog
Runtime
Inferences
Runtime
Inferences
Runtime
Inferences
7
1869
18100580
2
8789
1
4182
8
8359
81092264
4
35763
2
17826
9
43459
402929204
31
158124
11
80825
10
216478
1990401248
142
724980
63
383746
11
1159475
11009507950
718
3656347
268
1973693
12
6847892
66065674305
3728
20021101
1466
10960122
Table 5
Average runtime (in milliseconds) and inferences of a FSA-SPARQL query with n results ex-
ecuted by the FASILL interpreter and when the compiled version of the FASILL program is 
executed by SWI-Prolog after 50 executions.
n
FASILL (interpreted)
FASILL (compiled)
Runtime
Inferences
Runtime
Inferences
1
19
178121
0
48
10
248
2450972
0
606
50
4480
42726732
1
7006
100
24049
220263932
7
24006
500
1913152
18194261532
89
520006
1000
13802164
137621008532
365
2040006
Since FASILL syntax subsumes that of Prolog, a program written in pure Prolog can be executed by the FASILL system 
without any modiﬁcation. Table 4 shows the runtime and the number of inferences performed in SWI-Prolog to solve the 
problem of the n queens shown in Fig. 11 by executing: i) the original Prolog code in the FASILL interpreter; ii) the compiled 
version of the FASILL program in SWI-Prolog; and iii) the original Prolog code in SWI-Prolog. Note that weak uniﬁcation and 
failure steps have been disabled for this test. As shown in Fig. 12a, we observe an overhead of the interpreted version of 
the FASILL code, which is certainly quite common in this kind of Prolog-based implementations. However, such overhead is 
drastically reduced and not signiﬁcant when we directly compile FASILL programs (not dealing with similarities) into Prolog
code.
The previous program does not really have a fuzzy nature. For this reason, we present another test for measuring the 
performance of the FASILL system with a real application. In particular, we will focus on the FSA-SPARQL language described 
in the introduction section, which provides mechanisms to express fuzzy queries against RDF data and it also enables 

162
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
7
8
9
10
11
12
1
10
100
1,000
10,000
1 · 105
1 · 106
queens
runtime (ms)
interpreted
compiled+w. unif.
compiled
prolog
(a) Execution.
200
400
600
800
1,000
0
100
200
300
400
symbols
runtime (ms)
mgu
wmgu
(b) Uniﬁcation.
Fig. 12. Comparison of runtimes of the FASILL system when executing goals and unifying terms.
the transformation and fuzziﬁcation of social network API data [3]. Table 5 shows the average runtime and the number 
of inferences performed in SWI-Prolog to run a FSA-SPARQL query with n results. In this case, we cannot compare the 
performance with pure Prolog, since it cannot deal with truth degrees other than true and false, and FSA-SPARQL queries 
use the real lattice in the unit interval ([0, 1], ≤) with a wide set of fuzzy connectives. Note that the compiled version 
really works very eﬃciently, but it is important to note that the FASILL interpreter can not be ignored in our system since, 
in particular, tuning techniques (also applied to the FSA-SPARQL language as described in [3]) are only available when 
interpreting a FASILL program, but disabled on its compiled Prolog version.14
Ending this section we turn our attention to the weak uniﬁcation algorithm. We have used an adaptation of the Martelli 
and Montanari algorithm [48] as a description of the weak uniﬁcation algorithm because it is formally elegant and easy 
to understand. The Martelli and Montanari algorithm, we formally deﬁned by a transition system, can be implemented 
eﬃciently by means of an algorithm that uses substitutions represented in a triangular form and terms represented by 
directed acyclic graphs (DAGs). In that case it has (almost) linear complexity but it is diﬃcult to implement (these techniques 
are common in low level implementations, that is, implementations by means of virtual machines). Therefore, we choose to 
implement the uniﬁcation algorithm following the guidelines of the Robinson’s uniﬁcation algorithm because it is easy to 
implement.
The worst case complexity of the Robinson’s uniﬁcation algorithm is exponential in the size of the input terms, even if 
the output substitution is represented in a triangular form and structure sharing techniques are used to represent terms 
by DAGs [1]. However it behaves well in practice, except for some atypical cases (these reasons may explain why Robinson 
algorithm is still used in many implementations of theorem provers, Prolog compilers and interpreters, type checkers, etc.). 
In [29] a wide study comparing the performance of different uniﬁcation algorithms is presented. There, they showed that
the Martelli and Montanari algorithm, although with (almost) linear complexity in the worst case, in practice behaves worse 
than the Robinson algorithm.
On the other hand, note that, we are implementing the weak uniﬁcation algorithm (and the whole system) by means of
SWI-Prolog. That is we use high level implementation techniques and we delegate to SWI-Prolog all complex tasks of the 
weak uniﬁcation algorithm, such as the binding of variables to a term and the application and composition of substitutions. 
In this way, the implementation of both algorithms is very close and they behave similarly inside this framework. Certainly, 
the overhead of the fuzzy adaptations of these algorithms (when they rely on similarities) with regard to the classical 
versions of them comes from the unavoidable accesses to the entries of the similarity relation and the application of the 
t-norm used to propagate the similarity degrees between symbols.
Finally, we have carried out a series of two experiments to measure the overhead introduced by the weak uniﬁcation 
over the classical syntactic uniﬁcation, given that the previous programs used in the assessments do not use similarities.
The ﬁrst experiment shows the runtime and the number of inferences performed in SWI-Prolog to run the most general 
uniﬁer algorithm implemented by FASILL both when unifying arbitrary terms of n symbols randomly nested (Table 6) 
and when weakly unifying this kind of randomly generated arbitrary terms (Table 7). By comparing the average runtimes 
of Tables 6 and 7 we conclude that the weak uniﬁcation is slightly slower than the syntactic uniﬁcation. However, this 
difference is practically negligible, as shown in Fig. 12b.
The last experiment is designed to measure the overhead introduced by our weak most general uniﬁcation algorithm 
with respect to the SWI-Prolog syntactic uniﬁcation algorithm. This goal is achieved by producing a variant of the compiled 
code in Fig. 11b where explicit calls to the weak uniﬁcation algorithm are added (following similar techniques that the ones 
used for translating Bousi∼Prolog programs [42]):
14 Note that, in particular, symbolic constants are not permitted in standard Prolog clauses.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
163
Table 6
Runtime (in milliseconds) and inferences of the most general uniﬁer algorithm implemented by FASILL when unifying arbitrary terms of n symbols 
randomly nested after 1000 executions.
n
Runtime
Inferences
min
aver
max
min
aver
max
10
0
0
1
90
318
677
100
1
3
10
12997
41302
64948
250
10
30
90
102405
264125
404680
500
39
107
225
372728
1053805
1591275
750
76
240
493
756870
2376113
3497821
1000
101
437
778
1020895
4226163
6258932
Table 7
Runtime (in milliseconds) and inferences of the weak most general uniﬁer algorithm implemented by FASILL when weakly unifying arbitrary terms of n
similar symbols randomly nested after 1000 executions.
n
Runtime
Inferences
min
aver
max
min
aver
max
10
0
0
3
443
609
852
100
1
4
32
17132
44403
73484
250
12
32
144
107739
290396
438447
500
39
134
294
408423
1119831
1720331
750
91
259
616
829200
2531031
3698443
1000
139
461
1121
1377969
4449438
6540874
queens(XN,TD):-
unify(XN,N,TD1), (queens(N,_,TD2),false ; TD2=1,true), degree_composition([TD2,TD1],TD).
queens(XN,XQs,TD):-
unify(XN,N,TD1), unify(XQs,Qs,TD2),
gen_list(N,Qs,TD3), place_queens(N,Qs,_,_,TD4),
degree_composition([TD4,TD3,TD1,TD2],TD).
gen_list(X,L,TD):-
unify(X,0,TD1), unify(L,[],TD2),degree_composition([TD1,TD2],TD).
gen_list(XN,XL,TD):-
unify(XN,N,TD1), unify(XL,[_|L],TD2),
N>0,N1 is N-1, gen_list(N1,L,TD3),degree_composition([TD3,TD1,TD2],TD).
place_queens(X,Y,Z,L,TD):-
unify(X,0,TD1), unify(Y,_,TD2), unify(Z,_,TD3), unify(L,_,TD4),
degree_composition([TD1,TD2,TD3,TD4],TD).
place_queens(XI,XQs,XUps,L,TD):-
unify(XI,I,TD1), unify(XQs,Qs,TD2), unify(XUps,Ups,TD3), unify(L,[_|Ds],TD4),
I>0,I1 is I-1, place_queens(I1,Qs,[_|Ups],Ds,TD5), place_queen(I,Qs,Ups,Ds,TD6),
degree_composition([TD1,TD2,TD3,TD4,TD5,TD6],TD).
place_queen(X,Y,Z,L,TD):-
unify(X,Q,TD1), unify(Y,[Q|_],TD2), unify(Z,[Q|_],TD3), unify(L,[Q|_],TD4),
degree_composition([TD1,TD2,TD3,TD4],TD).
place_queen(X,Y,Z,L,TD):-
unify(X,Q,TD1), unify(Y,[_|Qs],TD2), unify(Z,[_|Ups],TD3), unify(L,[_|Ds],TD4),
place_queen(Q,Qs,Ups,Ds,TD5), degree_composition([TD1,TD2,TD3,TD4,TD5],TD).
As can be seen in Table 8 and it was expected, the weak uniﬁcation algorithm has a price to pay, but this price is 
affordable. In relation to all this, Fig. 12a is very revealing, because it graphically shows the increasing price that has to be 
paid to include various fuzzy features into a logic programming language.
7. Related work
Two research lines are recognized in FLP, the one that modiﬁes the classical resolution procedure, replacing it by a fuzzy 
resolution mechanism [25,46,58,49,74] and the one that extends the Selection-function driven Linear resolution for Deﬁnite 

164
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
Table 8
Average runtime (in milliseconds) and inferences of the problem of the n queens after 50 
executions. Both the compiled version of the FASILL program, with explicit calls to the weak 
uniﬁcation algorithm, and the original Prolog program are executed on top of SWI-Prolog.
n
FASILL (compiled + weak unif.)
Prolog
Runtime
Inferences
Runtime
Inferences
7
33
426957
1
4182
8
140
1845388
2
17826
9
636
8430242
11
80825
10
3113
40186261
63
383746
11
15837
207367767
268
1973696
12
87825
1153940993
1466
10960122
clauses (SLD resolution) principle [13,44] replacing its classical uniﬁcation algorithm by a fuzzy uniﬁcation algorithm. When 
the fuzzy uniﬁcation algorithm is weakened using a similarity relation this approach is usually named Similarity-based Logic 
Programming [14,15,47,65]. Bousi∼Prolog [40,39,41,63] goes a step further in this line integrating proximity relations in 
that generic scheme, obtaining a more expressive programming framework. Examples of hybrid approaches, where both the 
resolution principle and the classical uniﬁcation algorithm are modiﬁed, are [73] and [17].
FASILL is a fully integrated FLP language that aims at combining the best features of both aforementioned lines of work. 
Speciﬁcally, it combines concepts and techniques developed in works of the ﬁrst line, such as [49] and its predecessor [74], 
and in works that contributed to the area of similarity-based logic programming, specially, [65] and [40,63]:
1. The framework of multi-adjoint logic programming (MALP for short) [49] has been one of our major inﬂuences. We 
harvest from it much of its syntax, that allows the simultaneous use of rather general connectives in the bodies of 
program rules, and part of its operational semantics. As well as MALP does, FASILL operational semantics is not based 
on the resolution principle.
It is important to note that, also in [49], a formal model for similarity-based fuzzy uniﬁcation is deﬁned inside the 
framework of multi-adjoint logic programming. On this computational model, a similarity-based uniﬁcation approach 
is constructed by simply adding equality like axioms for fuzzy similarities and using classical uniﬁcation. This provides 
a semantic framework for logic programming with different notions of similarity. Although, from the theoretical point 
of view, this is a very elegant general framework, its treatment of similarity relations has not been implemented yet 
and we think it might produce ineﬃciencies due to the huge proliferation of rules associated with the addition of the 
necessary equality like axioms to the original program.15 This is the reason why we have chosen another solution to 
integrate the similarity in our language.
2. The second inﬂuence in the construction of our language relies on the pioneering works of [16,22–24] and [15], where 
the concept of uniﬁcation by similarity was originally developed. We have to remark that their approach differs from 
ours, since they use the cumbersome notions of clouds, systems of clouds and closures operators in its deﬁnition.16 How-
ever, from a theoretical point of view, the work presented in [65] by Maria Sessa is the more closely tied to our 
proposal, since we use almost the same concept of uniﬁcation by similarity. This uniﬁcation procedure is combined 
with the MALP operational semantics to give a more expressive and rich programming framework that supports both 
annotated rules and uniﬁcation by similarity.
Also note that there exist differences between Sessa’s proposal and ours. Following Bousi∼Prolog [39] our similarity-
based uniﬁcation algorithm is thresholded. A threshold constraints the uniﬁcation degree to values equal o greater than 
the so called lambda cut value.
Although it is not essential for the development of this work, it is worth mentioning that we, also following Bousi∼Pro-
log, use a notion of unifying substitution that differs from that of Sessa (see [40] for a more detailed explanation).
From a practical point of view, similarity-based approaches have produced two main practical realizations: the fuzzy logic 
language LIKELOG [14] (an interpreter implemented in Prolog using rather direct techniques and the cumbersome concepts 
just mentioned in the ﬁrst item above) and SiLog [47] (an interpreter written in Java). Neither LIKELOG nor SiLog are 
publicly available and therefore a practical comparison is impossible. However, we can enumerate some important features 
of the FASILL programming language that distinguish it from these other proposals:
• FASILL has well-deﬁned declarative semantics and for which good correction properties have been demonstrated [36]. 
Moreover, the formulas can be interpreted in the framework of any complete lattice and not simply in the real interval 
[0,1].
15 It is necessary to introduce one axiom for each constant, function and relation symbol existing in the program alphabet. For a more detailed discussion 
on this aspect, see [36].
16 From our point of view, these notions may endanger the eﬃciency of the operational semantics which uses them, because they are costly to compute.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
165
• FASILL allows annotated rules with truth degree annotations belonging to any complete lattice, what allows the devel-
opment of applications in which the truth of the rules is uncertain.
• Given its condition of a thresholded language, the derivations of FASILL can be cut immediately if they do not exceed 
the desired threshold, which provides greater eﬃciency to its operational mechanism.
• In order to obtain a similarity relation, the FASILL system gives automatic support to the user for the construction of 
a reﬂexive, symmetric and/or transitive closure, starting from an arbitrary fuzzy binary relation (which may not even 
be reﬂexive or symmetric). Inherited from Bousi∼Prolog, FASILL uses an adaptation of the Warshall’s algorithm for 
computing the transitive closure of a binary fuzzy relation [30,43,59]. SiLog provides support but it is not automatic 
and it requires human intervention.
• Finally, note that FASILL is not a simple interpreter able to execute a weak uniﬁcation procedure. It incorporates a big 
repertory of Prolog predeﬁned predicates that may help in the programming tasks. Certainly, it covers the main features 
of the Prolog language, such as, arithmetic, lists, exception handling or a wide range of built-in predicates. An important 
purpose of our work has been the design of a friendly tool for Prolog programmers.
We wish to end this section by relating our approach with tabling techniques, also called tabulation. Our implementation 
has been made with SWI-Prolog, whose inﬂuence is growing in the declarative community for academic, research and even 
industrial purposes. Although this system admits some forms of tabled execution, where the re-evaluation of a tabled pred-
icate is avoided by memorizing the answers, perhaps the most important reference on this topic is XSB-Prolog [67], which 
extends Prolog with tabled resolution and higher-order, among other capabilities. Tabulation-based mechanisms are useful 
for avoiding repeated evaluations of sub-goals when solving a single goal and, in general, they enjoy better termination 
results than standard SLD-like procedures. Although the computational complexity of the tabled operational semantics is 
higher, tabling can be turned on in a predicate by predicate basis and therefore the overhead may be in fact necessary to 
face non-termination due to inﬁnite positive loops (like in SLD). Additionally, in other situations, tabling can provide dra-
matic runtime improvements and avoid incompleteness problems in the case of non-linearly ordered complete lattices, as 
the following example illustrates.
Example 6. Consider the following FASILL program based on the lattice of Example 3 (where connective @down assigns
bottom to any truth degree different to top), together with the identity relation as similarity relation, and assume that the 
λ-cut is bot to simplify.
p 
<-
@down(q)
q 
<-
alpha
q 
<-
beta
Since FASILL subsumes the MALP framework (in essence, a FASILL program is a MALP program optionally extended 
with a similarity relation), note that this program also belongs to the Multi-Adjoint Logic Programming approach. Here, the 
execution of the query p using SLD-like proof procedures would produce the truth-value bottom. However, the ﬁx-point 
and model theoretic declarative semantics for FASILL established in [36] would assign the truth degree top to p. The same 
desired answer would be reached by an operational semantics using tabling, as revealed by different tabulation procedures 
designed for the MALP framework in the past [19,20,31–33].
Anyway, the correctness (both soundness and completeness) results of the operational mechanism for FASILL proved 
in [36] are strong enough for coding real world applications, such as the ones we have developed in the ﬁelds of cloud 
computing, semantic web, neural networks or analysis of social networks, as described in the introduction section.
Under a theoretical point of view, the incompleteness problem pointed out in this example, only appears when the 
following (necessary, but no suﬃcient) condition holds: the truth degrees collected on the lattice associated to a MALP or a
FASILL program are partially ordered. In other words, using fully ordered lattices of truth degrees (suﬃcient condition), as 
we have really done in our practical developments, avoids any risk of incompleteness, which is the common case in most 
software applications. Note also that even most scientiﬁc and professional implementations of the popular (not fuzzy) logic 
language Prolog, which have been used during decades for coding and solving real world problems, are also incomplete.
As mentioned in the previous example, in the fuzzy logic programming area and, more speciﬁcally, in the multi-adjoint 
logic programming approach, the ﬁrst tabulation procedures for propositional fuzzy logic programs were introduced in 
[19,20]. One step beyond, we also collaborated in the development of this framework by introducing thresholding techniques 
in [31]. Next, we improved such techniques for manipulating thresholds in a tabled way by also incorporating unfolding 
transformations like the ones we have previously described in this paper [32,33]. All these promising precedents for MALP
programs suggest that tabulation procedures could be also adapted and implemented in the FASILL system in the near 
future.
8. Conclusions and future work
FASILL is a fuzzy logic programming language that combines a weak uniﬁcation algorithm, based on similarity relations, 
and a rich set of connectives and aggregators, whose truth functions can be deﬁned on a complete lattice. FASILL programs 
can be executed by using the FASILL system developed in our research group, whose online version is freely available 

166
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
via https://dectau .uclm .es /fasill /sandbox. The FASILL system is a meta-interpreter built on the top of SWI-Prolog which 
incorporates many of the most useful Prolog built-in predicates.
The FASILL programming language can be used in a wide range of practical applications from the semantic web to 
knowledge discovery and text mining.
In this paper, after recalling the FASILL syntax and operational semantics, we describe in detail the design and implemen-
tation techniques needed to build the FASILL system. To this end, we have used well-known standard logic programming 
techniques (e.g., we use a ground representation and Deﬁnite Clause Grammars for parsing and meta-interpretation for 
executing the FASILL operational semantics) as well as we have introduced interesting declarative algorithms (e.g., for com-
puting the reﬂexive, symmetric, transitive closure of a binary fuzzy relation). All these techniques have been combined to 
give birth to this expressive language called FASILL.
In the near future, we plan to improve the FASILL system, increasing its eﬃciency by introducing: i) compilation tech-
niques for translating FASILL programs into standard Prolog code (as the ones developed for the Bousi∼Prolog system in 
[42]); ii) tabulation techniques (adapted from those developed for the MALP framework in [33]). Apart from coping with the 
development of these techniques, we want to reinforce the range of applications of this programming language in order to 
show its usefulness and practicability. Also, because we are aware of the importance of accurately establishing the approxi-
mation degree between the elements of a similarity relation, we want to implement a tool to facilitate users the automatic 
construction of similarity relations using different methods for their computation.
Declaration of competing interest
The authors declare that they have no known competing ﬁnancial interests or personal relationships that could have 
appeared to inﬂuence the work reported in this paper.
References
[1] L. Albert, R. Casas, F. Fages, Average-case analysis of uniﬁcation algorithms, Theor. Comput. Sci. 113 (1) (1993) 3–34.
[2] J.M. Almendros-Jiménez, A. Becerra-Terón, G. Moreno, A fuzzy extension of SPARQL based on fuzzy sets and aggregators, in: 2017 IEEE International 
Conference on Fuzzy Systems, FUZZ-IEEE 2017, Naples, Italy, July 9-12, 2017, IEEE, 2017, pp. 1–6.
[3] J.M. Almendros-Jiménez, A. Becerra-Terón, G. Moreno, Fuzzy queries of social networks with FSA-SPARQL, Expert Syst. Appl. 113 (2018) 128–146, 
https://doi .org /10 .1016 /j .eswa .2018 .06 .051.
[4] J.M. Almendros-Jiménez, A. Becerra-Terón, G. Moreno, Tuning fuzzy SPARQL queries in a fuzzy logic programming environment, in: 2019 IEEE Inter-
national Conference on Fuzzy Systems, FUZZ-IEEE 2019, New Orleans, USA, June 23-26, 2019, IEEE, 2019, pp. 1–7, https://doi .org /10 .1109 /FUZZ -IEEE .
2019 .8858958.
[5] J.M. Almendros-Jiménez, M. Boﬁll, A. Luna, G. Moreno, C. Vázquez, M. Villaret, Fuzzy xpath for the automatic search of fuzzy formulae models, in: 
C. Beierle, A. Dekhtyar (Eds.), Proc. of 9th Int. Conference on Scalable Uncertainty Management, SUM’15, Québec City, Canada, in: LNCS, vol. 9310, 
Springer, 2015, pp. 385–398.
[6] J.M. Almendros-Jiménez, A. Luna, G. Moreno, A ﬂexible XPath-based query language implemented with fuzzy logic programming, in: Proc. of 5th 
International Symposium on Rules: Research Based, Industry Focused, RuleML’11, Barcelona, Spain, July 19–21, in: LNCS, vol. 6826, Springer Verlag, 
2011, pp. 186–193.
[7] J.M. Almendros-Jiménez, A. Luna, G. Moreno, A xpath debugger based on fuzzy chance degrees, in: On the Move to Meaningful Internet Systems: 
Proceedings OTM’12 Workshops, Rome, Italy, in: LNCS, vol. 7567, Springer Verlag, 2012, pp. 669–672.
[8] J.M. Almendros-Jiménez, A. Luna, G. Moreno, Annotating “Fuzzy Chance Degrees” when debugging XPath queries, in: Advances in Computational 
Intelligence - Proc. of the 12th Int. Work-Conference on Artiﬁcial Neural Networks, IWANN’13, Tenerife, Spain, in: LNCS, vol. 7903, Springer, 2013, 
pp. 300–311, Part II.
[9] J.M. Almendros-Jiménez, A. Luna, G. Moreno, Fuzzy XPath queries in XQuery, in: On the Move to Meaningful Internet Systems: OTM 2014 Conferences 
- Confederated International Conferences: CoopIS, and ODBASE 2014, Amantea, Italy, October 27-31, 2014, Proceedings, in: Lecture Notes in Computer 
Science, vol. 8841, 2014, pp. 457–472.
[10] J.M. Almendros-Jiménez, A. Luna, G. Moreno, Fuzzy XPath through fuzzy logic programming, New Gener. Comput. 33 (2) (2015) 173–209, https://
doi .org /10 .1007 /s00354 -015 -0201 -y.
[11] J.M. Almendros-Jiménez, A. Luna, G. Moreno, Thresholded debugging of XPath queries, in: 2015 IEEE International Conference on Fuzzy Systems, 
FUZZ-IEEE 2015, Istanbul, Turkey, August 2-5, 2015, IEEE, 2015, pp. 1–9.
[12] J.M. Almendros-Jiménez, A. Luna, G. Moreno, Debugging while interpreting fuzzy XPath queries, in: Proc. of 2016 IEEE International Conference on 
Fuzzy Systems, FUZZ-IEEE’16, Vancouver, BC, Canada, IEEE, 2016, pp. 233–240.
[13] K.R. Apt, M.H. van Emden, Contributions to the theory of logic programming, J. ACM 29 (3) (1982) 841–862.
[14] F. Arcelli, F. Formato, Likelog: a logic programming language for ﬂexible data retrieval, in: Proc. of the 1999 ACM Symposium on Applied Computing, 
SAC’99, San Antonio, Texas, 1999, pp. 260–267.
[15] F. Arcelli, F. Formato, A similarity-based resolution rule, Int. J. Intell. Syst. 17 (9) (2002) 853–872.
[16] F. Arcelli, F. Formato, G. Gerla, Similitude-based uniﬁcation as a foundation of fuzzy logic programming, in: Proc. of Int. Workshop of Logic Programming 
and Soft Computing, Bonn, 1996.
[17] J.F. Baldwin, T.P. Martin, B.W. Pilsworth, Fril - Fuzzy and Evidential Reasoning in Artiﬁcial Intelligence, John Wiley & Sons, Inc., 1995.
[18] M. Boﬁll, G. Moreno, C. Vázquez, M. Villaret, Automatic proving of fuzzy formulae with fuzzy logic programming and SMT, in: Proc. of XIII Conference 
on Programming and Languages, PROLE’13, 2013, pp. 151–165, extended version published by ECEASST, available at https://doi .org /10 .14279 /tuj .eceasst .
64 .991.
[19] C.V. Damásio, J. Medina, M. Ojeda-Aciego, A tabulation proof procedure for residuated logic programming, in: R.L. de Mántaras, L. Saitta (Eds.), Proceed-
ings of the 16th Eureopean Conference on Artiﬁcial Intelligence, ECAI’2004, Including Prestigious Applicants of Intelligent Systems, PAIS 2004, Valencia, 
Spain, August 22-27, 2004, 2004, IOS Press, 2004, pp. 808–812.
[20] C.V. Damásio, J. Medina, M. Ojeda-Aciego, A tabulation proof procedure for ﬁrst-order residuated logic programs: soundness, completeness and opti-
mizations, in: IEEE International Conference on Fuzzy Systems, FUZZ-IEEE 2006, Vancouver, BC, Canada, July 16-21, 2006, IEEE, 2006, pp. 2004–2011.

P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
167
[21] C.V. Damásio, L. Moniz, Monotonic and residuated logic programs, in: Symbolic and Quantitative Approaches to Reasoning with Uncertainty: Proc. of 
6th European Conference, ECSQARU’01 Toulouse, France, Springer, 2001, pp. 748–759.
[22] F.A. Fontana, F. Formato, Using fuzzy grammars for the evaluation of SGML-based documents, in: SAC, 1997, pp. 202–203.
[23] F. Formato, G. Gerla, M.I. Sessa, Extension of logic programming by similarity, in: Proc. of 1999 Joint Conference on Declarative Programming, AGP’99, 
L’Aquila, Italy, 1999, pp. 397–410.
[24] F. Formato, G. Gerla, M.I. Sessa, Similarity-based uniﬁcation, Fundam. Inform. 41 (4) (2000) 393–414.
[25] S. Guadarrama, S. Muñoz, C. Vaucheret, Fuzzy Prolog: a new approach using soft constraints propagation, Fuzzy Sets Syst. 144 (1) (2004) 127–150.
[26] J.A. Guerrero, M.S. Martinez, G. Moreno, C. Vázquez, Designing lattices of truth degrees for fuzzy logic programming environments, in: IEEE Symposium 
Series on Computational Intelligence, SSCI 2015, Cape Town, South Africa, December 7-10, 2015, IEEE, 2015, pp. 995–1004.
[27] J.A. Guerrero, F. Mendieta, G. Moreno, J. Penabad, J.A. Riaza, Testing properties of fuzzy connectives and truth degrees with the latticemaker tool, in: 
2017 IEEE Symposium Series on Computational Intelligence, SSCI 2017, Honolulu, HI, USA, November 27 - Dec. 1, 2017, IEEE, 2017, pp. 1–8.
[28] J.A. Guerrero, G. Moreno, J.A. Riaza, J. Sanchez, Smart design of similarity relations for fuzzy logic programming environments, in: IEEE Symposium 
Series on Computational Intelligence, SSCI 2018, Bangalore, India, November 18-21, 2018, IEEE, 2018, pp. 220–227.
[29] K. Hoder, A. Voronkov, Comparing uniﬁcation algorithms in ﬁrst-order theorem proving, in: B. Mertsching, M. Hund, Z. Aziz (Eds.), KI 2009: Advances 
in Artiﬁcial Intelligence, Springer Berlin Heidelberg, Berlin, Heidelberg, 2009, pp. 435–443.
[30] P. Julián-Iranzo, A procedure for the construction of a similarity relation, in: L. Magdalena, M. Ojeda-Aciego, J. Verdegay (Eds.), Proc. of the 12th 
International Conference on Information Processing and Management of Uncertainty in Knowledge-based Systems, IPMU 2008, June 22-27, 2008, 
Torremolinos, Málaga, Spain, U. Málaga, ISBN 978-84-612-3061-7, 2008, pp. 489–496.
[31] P. Julián-Iranzo, J. Medina, G. Moreno, M. Ojeda, Thresholded tabulation in a fuzzy logic setting, Electron. Notes Theor. Comput. Sci. 248 (2009) 115–130.
[32] P. Julián-Iranzo, J. Medina-Moreno, P. Morcillo, G. Moreno, M. Ojeda-Aciego, A static preprocess for improving fuzzy thresholded tabulation, in: Advances 
in Computational Intelligence - Proc. of the 11th International Work-Conference on Artiﬁcial Neural Networks, IWANN 2011, Part II, in: LNCS, vol. 6692, 
Springer Verlag, 2011, pp. 429–436.
[33] P. Julián-Iranzo, J. Medina-Moreno, P. Morcillo, G. Moreno, M. Ojeda-Aciego, An unfolding-based preprocess for reinforcing thresholds in fuzzy tabula-
tion, in: Advances in Computational Intelligence - Proc of the 12th International Work-Conference on Artiﬁcial Neural Networks, IWANN 2013, Part I, 
in: LNCS, vol. 7902, Springer Verlag, 2013, pp. 647–655.
[34] P. Julián-Iranzo, G. Moreno, J. Penabad, On fuzzy unfolding. A multi-adjoint approach, Fuzzy Sets Syst. 154 (2005) 16–33.
[35] P. Julián-Iranzo, G. Moreno, J. Penabad, Operational/interpretive unfolding of multi-adjoint logic programs, J. Univers. Comput. Sci. 12 (11) (2006) 
1679–1699.
[36] P. Julián-Iranzo, G. Moreno, J. Penabad, Thresholded semantic framework for a fully integrated fuzzy logic language, J. Log. Algebraic Methods Program. 
93 (2017) 42–67.
[37] P. Julián-Iranzo, G. Moreno, J. Penabad, FASILL: fuzzy correct answers and soundness, in: 2018 IEEE International Conference on Fuzzy Systems, FUZZ-
IEEE 2018, Rio de Janeiro, Brazil, July 8-13, 2018, IEEE, 2018, pp. 1–8.
[38] P. Julián-Iranzo, G. Moreno, J. Penabad, C. Vázquez, A fuzzy logic programming environment for managing similarity and truth degrees, in: Proc. of XIV 
Jornadas sobre Programación y Lenguajes, PROLE’14, Cádiz, Spain, 2015, pp. 71–86.
[39] P. Julián-Iranzo, C. Rubio-Manzano, Proximity-based uniﬁcation theory, Fuzzy Sets Syst. 262 (2015) 21–43.
[40] P. Julián-Iranzo, C. Rubio-Manzano, A sound and complete semantics for a similarity-based logic programming language, Fuzzy Sets Syst. 317 (2017) 
1–26.
[41] P. Julián-Iranzo, F. Sáenz-Pérez, An eﬃcient proximity-based uniﬁcation algorithm, in: 2018 IEEE International Conference on Fuzzy Systems, FUZZ-IEEE 
2018, Rio de Janeiro, Brazil, July 9-12, 2018, 2018, pp. 1–8.
[42] P. Julián-Iranzo, F. Sáenz-Pérez, Proximity-based uniﬁcation: an eﬃcient implementation method, IEEE Trans. Fuzzy Syst. 14 (2020).
[43] A. Kandel, L. Yelowitz, Fuzzy chains, IEEE Trans. Syst. Man Cybern. Syst. SMC-4 (5) (1974) 472–475.
[44] R. Kowalski, Predicate Logic as a Programming Language, Information Processing, vol. 74, North-Holland, 1974, pp. 569–574.
[45] R. Lee, Fuzzy logic and the resolution principle, J. ACM 19 (1) (1972) 119–129.
[46] D. Li, D. Liu, A Fuzzy Prolog Database System, John Wiley & Sons, Inc., 1990.
[47] V. Loia, S. Senatore, M.I. Sessa, Similarity-based SLD resolution and its implementation in an extended Prolog system, in: Proc. of 10th IEEE Int. 
Conference on Fuzzy Systems, FUZZ-IEEE’01, Melbourne, Australia, 2001, pp. 650–653.
[48] A. Martelli, U. Montanari, An eﬃcient uniﬁcation algorithm, ACM Trans. Program. Lang. Syst. 4 (1982) 258–282.
[49] J. Medina, M. Ojeda-Aciego, P. Vojtáš, Similarity-based uniﬁcation: a multi-adjoint approach, Fuzzy Sets Syst. 146 (2004) 43–62.
[50] P.J. Morcillo, G. Moreno, J. Penabad, C. Vázquez, A practical management of fuzzy truth degrees using FLOPER, in: Proc. of 4th Int. Symposium on Rule 
Interchange and Applications, RuleML’10, in: LNCS, vol. 6403, Springer Verlag, 2010, pp. 20–34.
[51] G. Moreno, J. Penabad, J. Riaza, On similarity-based unfolding, in: International Conference on Scalable Uncertainty Management, SUM’17, in: LNCS, 
vol. 10564, Springer, 2017, pp. 420–426.
[52] G. Moreno, J. Penabad, J. Riaza, Symbolic unfolding of multi-adjoint logic programs, in: Trends in Mathematics and Computational Intelligence, in: 
Studies in Computational Intelligence, Springer International Publishing, 2019, pp. 43–51, extended version of a previous paper presented at ESCIM’17.
[53] G. Moreno, J. Penabad, J. Riaza, G. Vidal, Symbolic execution and thresholding for eﬃciently tuning fuzzy logic programs, in: International Symposium 
on Logic-Based Program Synthesis and Transformation, LOPSTR’16, in: LNCS, vol. 10184, Springer, 2016, pp. 131–147.
[54] G. Moreno, J. Penabad, C. Vázquez, Beyond multi-adjoint logic programming, Int. J. Comput. Math. 92 (9) (2014) 1956–1975.
[55] G. Moreno, J. Pérez, J.A. Riaza, Fuzzy logic programming for tuning neural networks, in: Rules and Reasoning - Third International Joint Conference, 
RuleML+RR 2019, Bolzano, Italy, September 16-19, 2019, Proceedings, in: Lecture Notes in Computer Science, vol. 11784, Springer, 2019, pp. 190–197.
[56] G. Moreno, J.A. Riaza, An online tool for tuning fuzzy logic programs, in: International Joint Conference on Rules and Reasoning, RuleML+RR’17, in: 
LNCS, vol. 10364, Springer, 2017, pp. 184–198.
[57] G. Moreno, C. Vázquez, Fuzzy logic programming in action with FLOPER, J. Softw. Eng. Appl. 7 (2014) 237–298.
[58] M. Mukaidono, Z. Shen, L. Ding, Fundamentals of fuzzy prolog, Int. J. Approx. Reason. 3 (1989) 1080–1989.
[59] H. Naessens, H.D. Meyer, B.D. Baets, Algorithms for the computation of t-transitive closures, IEEE Trans. Fuzzy Syst. 10 (4) (2002) 541–551.
[60] A. Pettorossi, M. Proietti, Rules and strategies for transforming functional and logic programs, ACM Comput. Surv. 28 (2) (1996) 360–414.
[61] J.A. Robinson, A machine-oriented logic based on the resolution principle, J. ACM 12 (1) (1965) 23–41.
[62] F.P. Romero, P. Julián-Iranzo, A. Soto, M. Ferreira, J. Gallardo-Casero, Classifying unlabeled short texts using a fuzzy declarative approach, Lang. Resour. 
Eval. 47 (1) (2013) 151–178, https://doi .org /10 .1007 /s10579 -012 -9203 -2.
[63] C. Rubio-Manzano, P. Julián-Iranzo, A fuzzy linguistic prolog and its applications, J. Intell. Fuzzy Syst. 26 (3) (2014) 1503–1516.
[64] C. Rubio-Manzano, P. Julián-Iranzo, Incorporation of abstraction capability in a logic-based framework by using proximity relations, J. Intell. Fuzzy Syst. 
29 (4) (2015) 1671–1683, https://doi .org /10 .3233 /IFS -151645.
[65] M.I. Sessa, Approximate reasoning by similarity-based SLD resolution, Theor. Comput. Sci. 275 (1–2) (2002) 389–426.
[66] L. Sterling, E.Y. Shapiro, The Art of Prolog: Advanced Programming Techniques, MIT Press, 1994.
[67] T. Swift, D.S. Warren, XSB: extending the power of Prolog using tabling, Theory Pract. Log. Program. 12 (1–2) (2012) 157–187.

168
P. Julián-Iranzo et al. / International Journal of Approximate Reasoning 125 (2020) 139–168
[68] H. Tamaki, T. Sato, Unfold/fold transformations of logic programs, in: S. Tärnlund (Ed.), Proc. of Second Int’l Conf. on Logic Programming, 1984, 
pp. 127–139.
[69] L. Tomás, C. Vázquez, J. Tordsson, G. Moreno, Reducing noisy-neighbor impact with a fuzzy aﬃnity-aware scheduler, in: 2015 International Conference 
on Cloud and Autonomic Computing, Boston, MA, USA, September 21-25, 2015, IEEE Computer Society, 2015, pp. 33–44.
[70] M.H. van Emden, R.A. Kowalski, The semantics of predicate logic as a programming language, J. ACM 23 (4) (1976) 733–742.
[71] C. Vázquez, G. Moreno, L. Tomás, J. Tordsson, A cloud scheduler assisted by a fuzzy aﬃnity-aware engine, in: Proc. of 2015 IEEE Int. Conference on 
Fuzzy Systems, FUZZ-IEEE’15, Istanbul, Turkey, IEEE, 2015, pp. 1–8.
[72] C. Vázquez, L. Tomás, G. Moreno, J. Tordsson, A fuzzy approach to cloud admission control for safe overbooking, in: Proc. of 10th Int. Workshop of 
Fuzzy Logic and Applications, WILF’13, Genoa, Italy, in: LNCS, vol. 8256, Springer, 2013, pp. 212–225.
[73] H. Virtanen, Linguistic logic programming, in: Logic Programming and Soft Computing, 1998, pp. 91–128.
[74] P. Vojtáš, Fuzzy logic programming, Fuzzy Sets Syst. 124 (1) (2001) 361–370.
[75] L. Zadeh, Fuzzy sets, Inf. Control 8 (1965) 338–353.

