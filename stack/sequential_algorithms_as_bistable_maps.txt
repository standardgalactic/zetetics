3
Sequential algorithms as bistable maps
Pierre-Louis Curien
CNRS â€“ UniversitÂ´e Paris 7
En guise de prologue
Gilles Kahn, pour moi, ce fut dâ€™abord un article, en franÂ¸cais sâ€™il vous
plait, texte qui fut le point de dÂ´epart de ma recherche:
G. Kahn et G. Plotkin, Domaines concrets, TR IRIA-Laboria 336
(1978), paru en version anglaise en 1993 â€“ signe de son inï¬‚uence dans le
temps â€“ dans le volume dâ€™hommage `a Corrado BÂ¨ohm [14].
On ne pouvait imaginer un meilleur appË†at pour le jeune homme que
jâ€™Â´etais, arrivÂ´e `a lâ€™informatique par le fruit dâ€™une hÂ´esitation entre mathÂ´e-
matiques (intimidantes) et langues (les vraies). Un autre coll`egue trop
tË†ot disparu, Maurice Gross, mâ€™avait aidÂ´e `a choisir une tierce voie et
mâ€™avait guidÂ´e vers le DEA dâ€™Informatique ThÂ´eorique de Paris 7. Les
cours de Luc Boasson et de Dominique Perrin mâ€™avaient dÂ´ej`a bien ferrÂ´e,
mais la rencontre des domaines concrets mâ€™a dÂ´eï¬nitivement â€œattrapÂ´eâ€, et
parce quâ€™il sâ€™agissait de structures ressemblant aux treillis â€“ rencontrÂ´es
assez tË†ot dans ma scolaritÂ´e grË†ace aux LeÂ¸cons dâ€™Alg`ebre Moderne de Paul
Dubreil et Marie-Louise Dubreil Jacotin que mâ€™avait conseillÂ´ees mon
professeur de mathÂ´ematiques â€“, et parce que GÂ´erard Berry qui mâ€™avait
mis ce travail entre les mains avait une riche idÂ´ee pour bË†atir sur cette
pierre.
Lâ€™idÂ´ee directrice de cet article Â´etait de donner une dÂ´eï¬niton
gÂ´enÂ´erale de structure de donnÂ´ees, comprenant les listes, les arbres, les
enregistrements, les enregistrements avec variantes, etc..., et, comme lâ€™on
fait dans toute bonne mathÂ´ematique, une bonne notion de morphisme
entre ces structures: Cette dÂ´eï¬nition Â´etait donnÂ´ee sous deux facettes
Â´equivalentes et reliÂ´ees par un thÂ´eor`eme de reprÂ´esentation: lâ€™une concr`ete,
en termes de cellules (nÅ“uds dâ€™arbres, champs dâ€™enrigistrements, . . . ) et
de valeurs, lâ€™autre abstraite, en termes dâ€™ordres partiels. Ce thÂ´eor`eme,
From Semantics to Computer Science Essays in Honour of Gilles Kahn,
eds Yves
Bertot, GÂ´erard Huet, Jean-Jacques LÂ´evy and Gordon Plotkin. Published by Cambridge
University Press.
c
âƒCambridge University Press 2009.
51
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

52
P.-L. Curien
le premier du genre, a servi de mod`ele `a des travaux ultÂ´erieurs (ceux de
Winskel sur les structures dâ€™Â´evÂ´enements en particulier).
Sâ€™agissant
des
morphismes,
la
contribution
nâ€™Â´etait
pas
moins
importante. Apr`es celles de Vuillemin et de Milner qui ne sâ€™apppliquaient
bien quâ€™au premier ordre, la dÂ´eï¬nition de fonction sÂ´equentielle de
Kahnâ€“Ploktin Â´etait â€œla bonneâ€. Cette notion, couplÂ´ee au thÂ´eor`eme de
sÂ´equentialitÂ´e de Berry obtenu `a la mË†eme Â´epoque, ouvrait la voie `a la
construction dâ€™un mod`ele sÂ´equentiel du Î»-calcul, et câ€™est ici quâ€™intervint
lâ€™idÂ´ee de Berry: passer des fonctions (sÂ´equentielles) `a une notion plus
concr`ete de morphisme.
Les algorithmes sÂ´equentiels [3], nÂ´es de cette intuition initiale, et que
nous revisitons ici, sont, je lâ€™esp`ere, restÂ´es ï¬d`eles `a lâ€™esprit des domaines
concrets, qui se voulaient formaliser des structures donnÂ´ees observables.
Dans un langage comme CAML, les types fonctionnels ne sont pas
observables, mais dans le langage CDS (concrete data structure) que
Berry a proposÂ´e et qui a Â´etÂ´e dÂ´eveloppÂ´e sur les fondements thÂ´eoriques
Â´etablis dans ma th`ese, ils le sont [4]. Last but not least, la premi`ere
sÂ´emantique opÂ´erationnelle du langage (dÂ´ecrite dans ma th`ese dâ€™Etat
[9]) bien que sÂ´equentielle, sâ€™inspire beaucoup du mod`ele des coroutines,
prÂ´esentÂ´e dans autre article fondateur de Gilles Kahn [13].
Sur un plan plus pratique, câ€™est sur la table traÂ¸cante du (mythique)
bË†atiment 8 de lâ€™INRIA Rocquencourt que jâ€™ai pu sortir les beaux
transparents (je ne crois pas en avoir rÂ´ealisÂ´e, sans eï¬€ort particulier, de
plus esthÂ´etiques depuis) de ma soutenance de Th`ese dâ€™Etat, Â´ecrits en
FLIP.
ElÂ´egance, profondeur, et sens pratique, cela ne rÂ´esume pas Gilles
Kahn, mais câ€™est ce dont je puis tÂ´emoigner ici. De sa voix aussi, joviale et
impÂ´erieuse, voire impÂ´eriale, qui mâ€™a sauvÂ´e la mise lors dâ€™une prÂ´esentation
de mes travaux dans un colloque franco-amÂ´ericain `a Fontainebleau. Je
mâ€™apprË†etais `a Â´ecrire au feutre, non sur le transparent, mais sur la table
du projecteur...
Abstract
We describe the Cartwrightâ€“Curienâ€“Felleisen model of observably
sequential algorithms as a full subcategory of Lairdâ€™s bistable biorders,
thereby reconciling two views of functions: functions-as-algorithms
(or programs), and functions-as-relations. We then characterize aï¬ƒne
sequential algorithms as aï¬ƒne bistable functions in the full subcategory
of locally boolean orders.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
53
3.1 Introduction
This paper reconciles two views of functions: functions-as-algorithms (or
programs), and functions-as-relations. Our functions-as-algorithms are
the observably sequential algorithms on sequential data structures of
Cartwright, Curien and Felleisen [5â€“7], and our functions-as-relations are
Lairdâ€™s bistable and pointwise monotonic functions on bistable biorders
[15]. We exhibit a full embedding from the former to the latter.
Since the moment when the ï¬rst version of these notes was circulated
privately (2002), Laird has further improved the understanding of the
connection by deï¬ning a full sub-category of bistable biorders, the
category of locally boolean domains, whose intensional behaviour may
be â€œsynthesizedâ€ through decomposition theorems. A consequence of
these theorems is that every locally boolean domain is isomorphic to a
sequential data structure. Hence the results presented here actually yield
an equivalence of categories (and another one between the respective
subcategories of aï¬ƒne morphisms).
In order to make the paper relatively self-contained, we provide the
necessary deï¬nitions in Sections 3.2 and 3.3. The main full embedding
result is proved in Section 3.4, and the aï¬ƒne case is addressed in
Section 3.5.
3.2 Sequential data structures
We deï¬ne sequential data structures, which are concrete descriptions
of partial orders whose elements are called strategies (there is indeed a
game semantical reading of these structures, see e.g. [7]).
Deï¬nition 3.1 A sequential data structure (sds) [1] is a triple S =
(C, V, P), where
â€¢ C is a set of cells,
â€¢ V is a set of values (C and V disjoint),
â€¢ P
is a preï¬x-closed set of non-empty alternating sequences
c1v1c2 . . . (with the ciâ€™s in C and the viâ€™s in V ), which are called
positions.
We denote by Q (resp. R) the subset of sequences of odd (resp. even)
length of P, which are called queries (resp. responses).
One moreover assumes two special values âŠ¥and âŠ¤, not in V (nor in
C) (in earlier work [6], âŠ¤was called error, and in ludics [12] it is called
demon). We let w range over V âˆª{âŠ¥, âŠ¤}.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

54
P.-L. Curien
Here are a few examples of sdsâ€™s (described by their forest of positions):
bool
bool Ã— bool
?
 tt
ï¬€
ï£±
ï£´
ï£´
ï£²
ï£´
ï£´
ï£³
?1
 tt
ï¬€
?2
 tt
ï¬€
Thus, bool has one cell ? and two values tt and ï¬€, while bool Ã— bool is
made of two copies of bool, tagged by 1 and 2, respectively.
Our last example is the sds of terms over a signature, say, Î£ =
{f 2, g1, a0}:
Ïµ
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
f
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
1
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
f
ï£±
ï£´
ï£´
ï£²
ï£´
ï£´
ï£³
11 Â· Â· Â·
12
ï£±
ï£²
ï£³
f Â· Â· Â·
g

121 Â· Â· Â·
a
g

11 Â· Â· Â·
a
2 Â· Â· Â·
g

1 Â· Â· Â·
a
Here, the cells are words over the alphabet {1, 2} (occurrences!) and the
values are the function symbols.
Deï¬nition 3.2 An observable strategy (or strategy for short) is a set
x âŠ†R âˆª{qâŠ¤| q âˆˆQ} âˆª{qâŠ¥| q âˆˆQ} which satisï¬es the following
properties:
â€¢ x is closed under (even length) preï¬xes,
â€¢ whenever qw1, qw2 âˆˆx, then w1 = w2,
â€¢ whenever r âˆˆx, then for all c such that rc âˆˆQ, there exists w
such that rcw âˆˆx.
The second condition is the crucial one: it tells us that queries are
answered uniquely in a strategy. The other conditions are there for
technical convenience.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
55
A typical strategy, represented as a forest, i.e. as a set of branches,
looks like this:
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
...
c0 v0
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
c1 v1
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
c3 âŠ¥
...
c4 âŠ¤
...
c5 {
c2 v2
 ...
...
Here are some concrete strategies (below each strategy, we give the
corresponding boolean, pair of booleans, or term):
bool
?âŠ¥
?tt
?ï¬€
?âŠ¤
âŠ¥
tt
ï¬€
âŠ¤
bool Ã— bool
 ?1âŠ¥
?2âŠ¥
 ?1âŠ¥
?2tt
 ?1ï¬€
?2âŠ¥
Â· Â· Â·
(âŠ¥, âŠ¥)
(âŠ¥, tt)
(ï¬€, âŠ¥)
Â· Â· Â·
Ïµ f
ï£±
ï£²
ï£³
1 f
 11 a
12 g

121 a
2 a
f(f(a, g(a)), a)
The above deï¬nition of strategy does not do justice to the arborescent
structure of strategies, as in the examples just given. We now give a
syntax of strategies-as-terms.
rc âˆˆQ
câŠ¥:strat(rc)
rc âˆˆQ
câŠ¤:strat(rc)
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

56
P.-L. Curien
rc0v0 âˆˆR
xc:strat(rc0v0c)
(rc0v0c âˆˆQ)
c0v0 Ë™{xc | rc0v0c âˆˆQ}:strat(rc0)
xc:strat(c)
(c âˆˆQ)
{xc | c âˆˆQ}:strat
A strategy is a set x = {xc | c âˆˆQ} : strat. The strategy-as-set-of-
responses associated to a strategy-as-term is deï¬ned as {r | r âˆˆx},
where r âˆˆx is deï¬ned by the following rules:
câŠ¥âˆˆcâŠ¥
câŠ¤âˆˆcâŠ¤
r1 âˆˆxc1
c0v0r1 âˆˆc0v0 Ë™{xc | rc0v0c âˆˆQ}
c0v0 âˆˆc0v0 Ë™{xc | rc0v0c âˆˆQ}
r âˆˆxc
r âˆˆ{xc | c âˆˆQ}
This deï¬nes an injection, whose image is easily seen to be the set of
strategies x that do not have any inï¬nite branch, in the sense that there
is no sequence
c1 v1 c2 v2 . . . cn vn . . .
whose even preï¬xes all belong to x. We shall call such strategies ï¬nitary.
Hence we have two alternative deï¬nitions of ï¬nitary strategies: one by
extension, and a â€œproceduralâ€ one.
We denote the set of strategies by DâŠ¤(S), and we use D(S) for the set
of strategies obtained by removing the rule introducing câŠ¤. We write:
â€¢ q âˆˆA(x) if qâŠ¥âˆˆx,
â€¢ q âˆˆF(x) if qv âˆˆx for some v âˆˆV or if qâŠ¤âˆˆx, and
â€¢ x <q y when q âˆˆA(x) and q âˆˆF(y).
If q1 = r1c1, . . . , qn = rncn âˆˆA(x), we denote by x[q1 â†x1, . . . , qn â†
xn] the strategy obtained by replacing ciâŠ¥by xi:strat(qi), for all i, in x.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
57
We shall abbreviate q = rc â†câŠ¥as q â†âŠ¥, and similarly with âŠ¤. We
shall use the convention that writing
x = x[q0 â†âŠ¥, . . . , qn â†âŠ¥]
means that A(x) = {q0, . . . , qn}.
Deï¬nition 3.3 We deï¬ne four orders â‰¤s (stable), â‰¤c (costable), â‰¤
(bistable), and âŠ‘(pointwise) as the congruence closures of, respectively:
for â‰¤s:
rc âˆˆQ
x âˆˆstrat(rc)
câŠ¥â‰¤s x
for â‰¤c:
x âˆˆstrat(rc)
x â‰¤c câŠ¤
for â‰¤:
rc âˆˆQ
câŠ¥â‰¤câŠ¤
for âŠ‘:
rc âˆˆQ
x âˆˆstrat(rc)
câŠ¥âŠ‘x
rc âˆˆQ
x âˆˆstrat(rc)
x âŠ‘câŠ¤
By congruence closure, we mean, say for âŠ‘, the following rules:
rc0v0 âˆˆR
xc âŠ‘yc
(rc0v0c âˆˆQ)
c0v0 Ë™{xc | rc0v0c âˆˆQ} âŠ‘c0v0 Ë™{yc | rc0v0c âˆˆQ}
xc âŠ‘yc
(c âˆˆQ)
{xc | c âˆˆQ} âŠ‘{yc | c âˆˆQ}
In words, replacing a âŠ¥by a (correctly typed) tree results in a stable
increase, while removing a subtree and replacing it by âŠ¤results in a
costable increase. The bistable order is the intersection of the stable and
the costable order: an increase in this order consists only in changing âŠ¥â€™s
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

58
P.-L. Curien
to âŠ¤â€™s. The bistable order turns out to play a crucial role in the axiomat-
ization (see Section 3.3). The pointwise order is the order generated by
the union of the stable and the costable orders.
Streicher has remarked that âŠ‘and â‰¤make an sds a bistable biorder.
This is an easy check left to the reader (after reading Section 3.3). Here,
we extend this to a full and faithful embedding of the category of sdsâ€™s
and sequential algorithms into the category of bistable and âŠ‘-monotonic
maps. Therefore, we now move on to deï¬ne the relevant categories [1, 15].
Deï¬nition 3.4 Given sets A, B âŠ†A, for any word w âˆˆAâˆ—, we deï¬ne
wâŒˆB as follows:
ÏµâŒˆB= Ïµ
(wm)âŒˆB=
 wâŒˆB
if m âˆˆA\B
(wâŒˆB)m
if m âˆˆB .
Deï¬nition 3.5 Given two sdsâ€™s S = (C, V, P) and Sâ€² = (Câ€², V â€², P â€²),
we deï¬ne S âŠ¸Sâ€² = (Câ€²â€², V â€²â€², P â€²â€²) as follows. The sets Câ€²â€² and V â€²â€² are
disjoint unions:
Câ€²â€²
=
Câ€² âˆªV
V â€²â€²
=
V â€² âˆªC .
P â€²â€² consists of the alternating positions s starting with a câ€², and which
are such that:
sâŒˆSâ€²âˆˆP â€², (sâŒˆS= Ïµ or sâŒˆSâˆˆP), and
shas no preï¬x of the form sccâ€².
The strategies of S âŠ¸Sâ€² are called observably aï¬ƒne sequential
algorithms from S to Sâ€².
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
59
A typical aï¬ƒne sequential algorithm looks like this:
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
...
câ€²
1 c1
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
...
v1 c2
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
...
v2 vâ€²
1
ï£±
ï£´
ï£´
ï£²
ï£´
ï£´
ï£³
...
câ€²
2 Â· Â· Â·
...
...
...
...
The initial query câ€²
1 of the output prompts a query c1 to the input. If the
answer to this query is v1, then the strategy wants to further explore the
input and asks the query c1v1c2, and so on, until enough of the input is
known to answer the query câ€²
1 with vâ€²
1, and then the output may launch
a new query câ€²
2, etc...
We next move on to deï¬ne observably sequential algorithms (not
necessarily aï¬ƒne). Our model follows linear logicâ€™s decomposition S â†’
Sâ€² = (!S) âŠ¸Sâ€² [11]. The decomposition for sequential algorithms on
sequential data structures was discovered by Lamarche [17, 7].
Deï¬nition 3.6 (exponential â€“ sds) Let S = (C, V, P) be a sds. The
following recursive clauses deï¬ne a set P! of alternating words over Q âˆª
R = P:
(r = Ïµ or r âˆˆP!)
q âˆˆA(state(r))
rq âˆˆP!
q âˆˆP! and state(qr) âˆˆD(S)
qr âˆˆP!
where state is the following function mapping responses (or Ïµ) of P! to
strategies of M:
state(Ïµ) = {câŠ¥| c initial}
q = r1c1
r = qv1
state(rqr) = state(r)[q â†c1v1{câŠ¥| rc âˆˆQ}]
The sds (Q, R, P!) is called !S.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

60
P.-L. Curien
The above deï¬nition looks technical, but it just amounts to saying
that the cells and values of !S are the queries and the responses of S,
and that the queries and responses of !S are sequences obtained from
some tree traversal of the strategies of S. This is in spirit similar to the
coherence space semantics of linear logic [11].
Deï¬nition 3.7 Given two sdsâ€™s S and Sâ€², the strategies of !S âŠ¸Sâ€² are
called observably sequential algorithms from S to Sâ€².
Despite their appearance, observably sequential algorithms are (in
bijection with) functions: this key insight did not wait for Lairdâ€™s work,
and was indeed one of the contributions of Cartwright and Felleisen
[5, 6, 1] to the older work of Berry and Curien on sequential algorithms
on concrete data structures [3].
Deï¬nition 3.8 Let f be an observably sequential algorithm from S to Sâ€²
and x a strategy of S. We deï¬ne f Â· x (also written f(x)) as the normal
form of âŸ¨f || x âŸ©for the following rewriting system, which is easily seen
to be conï¬‚uent (no critical pairs) and terminating on ï¬nitary strategies.
âŸ¨câ€²vâ€²{xâ€²â€²
i | i âˆˆI} || x âŸ©
â†’
câ€²vâ€²{âŸ¨xâ€²â€²
i || x âŸ©| i âˆˆI}
âŸ¨câ€²âŠ¥|| x âŸ©
â†’
câ€²âŠ¥
âŸ¨câ€²âŠ¤|| x âŸ©
â†’
câ€²âŠ¤
âŸ¨câ€²q{xâ€²â€²
r | râ€²â€²câ€²qr âˆˆQâ€²â€²} || x âŸ©
â†’
câ€²?(âŸ¨xâ€²â€²
r0 || x âŸ©) (r0 âˆˆx)
(in strat(râ€²â€²câ€²))
âŸ¨câ€²q || x âŸ©
â†’
câ€²âŠ¥
(qâŠ¥âˆˆx)
(in strat(râ€²â€²câ€²))
âŸ¨câ€²q || x âŸ©
â†’
câ€²âŠ¤
(qâŠ¤âˆˆx)
in strat(râ€²â€²câ€²))
âŸ¨r0q{xâ€²â€²
r | râ€²â€²r0qr âˆˆQâ€²â€²} || x âŸ©
â†’
âŸ¨xâ€²â€²
r1 || x âŸ©
(r1 âˆˆx)
(in strat(râ€²â€²r0))
?(âŸ¨r0q{xâ€²â€²
r | râ€²â€²r0qr âˆˆQâ€²â€²} || x âŸ©)
â†’
âŠ¥
(qâŠ¥âˆˆx)
(in strat(râ€²â€²r0))
?(âŸ¨r0q{xâ€²â€²
r | râ€²â€²r0qr âˆˆQâ€²â€²} || x âŸ©)
â†’
âŠ¤
(qâŠ¤âˆˆx)
(in strat(râ€²â€²r0))
?(âŸ¨rvâ€²{xâ€²â€²
i | i âˆˆI} || x âŸ©)
â†’
vâ€²{âŸ¨xâ€²â€²
i || x âŸ©| i âˆˆI}
?(âŸ¨râŠ¥|| x âŸ©)
â†’
âŠ¥
?(âŸ¨râŠ¤|| x âŸ©)
â†’
âŠ¤
For example, if câ€² c1 v1 . . . cn vn vâ€² câ€²
1 c v vâ€²
1 âˆˆf and c1 v1 . . . cn vn c v âˆˆ
x, then câ€² vâ€² câ€²
1 vâ€²
1 âˆˆf Â· x. (The reader should have in mind here that
potentially f (resp. x) branches after c1, . . . , cn, c (resp. after v1, . . . , vn),
and that the choice of strategies determine alternately which branch to
choose.)
Deï¬nition 3.9 Let S and Sâ€² be two sdsâ€™s. A â‰¤s-monotonic function
f:DâŠ¤(S) â†’DâŠ¤(Sâ€²) is called sequential at x if for any qâ€² âˆˆA(f(x))
one of the following properties hold:
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
61
(i) âˆ€y â‰¥s x qâ€² Ì¸âˆˆF(f(y)).
(ii) âˆƒq âˆˆA(x)
âˆ€y > x (f(x) <qâ€² f(y) â‡’x <q y).
A query q satisfying condition (2) is called a sequentiality index of f at
(x, qâ€²). The index is called strict if (1) does not hold. If (1) holds, then
any q in A(x) is a (vacuous) sequentiality index.
If q is a sequentiality index at (x, qâ€²) and if moreover qâ€²âŠ¤âˆˆf(x[q â†
âŠ¤]), then we say that f is observably sequential at x, qâ€², with index q (note
then that the index is strict and that there can be no other sequentiality
index).
The function f is called sequential (resp. observably sequential) from
S to Sâ€² if it is sequential (resp. observably sequential) at all points.
With the notation introduced above and using the â‰¤s monotonicity,
we can rephrase the deï¬nition of observably sequential function more
symmetrically as follows, at x = x[q1 â†âŠ¥, . . . , qn â†âŠ¥]:
âˆ€x1, . . . , xiâˆ’1, xi+1, . . . , xn
qâ€²âŠ¥âˆˆx[q1 â†x1, . . . qiâˆ’1 â†xiâˆ’1, qi â†âŠ¥, qi+1 â†xi+1, . . . , qn â†xn]
âˆ€x1, . . . , xiâˆ’1, xi+1, . . . , xn
qâ€²âŠ¤âˆˆx[q1 â†x1, . . . qiâˆ’1 â†xiâˆ’1, qi â†âŠ¤, qi+1 â†xi+1, . . . , qn â†xn]
Or, alternatively, using instead the âŠ‘-monotonicity (which is established
below), we get the following quantiï¬er-free deï¬nition:
qâ€²âŠ¥âˆˆx[q1 â†âŠ¤, . . . qiâˆ’1 â†âŠ¤, qi â†âŠ¥, qi+1 â†âŠ¤, . . . , qn â†âŠ¤]
qâ€²âŠ¤âˆˆx[q1 â†âŠ¥, . . . qiâˆ’1 â†âŠ¥, qi â†âŠ¤, qi+1 â†âŠ¥, . . . , qn â†âŠ¥]
Theorem
3.10
Observably
sequential
algorithms
and
observably
sequential functions are in one-to-one correspondence, and under the
bijection, the pointwise (resp. the stable) (resp. the bistable) ordering
deï¬ned above indeed becomes the pointwise ordering (resp. Berryâ€™s stable
ordering [2]) (resp. Lairdâ€™s bistable ordering [15]):
f âŠ‘g
â‡”
(âˆ€x f(x) âŠ‘g(x))
f â‰¤s g
â‡”
(f âŠ‘g and (âˆ€x, y (x â‰¤s y â‡’f(x) = f(y) âˆ§s g(x))))
f â‰¤g
â‡”
(f âŠ‘g and (âˆ€x, y (x â‰¤y â‡’f(x) = f(y) âˆ§g(x)) and
g(y) = f(y) âˆ¨g(x)))
The notation âˆ§s denotes the greatest lower bound with respect to the
stable ordering, while âˆ§and âˆ¨refer to the bistable ordering (all these
bounds exist, because f(y), g(x) âŠ‘g(y)).
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

62
P.-L. Curien
Proof Except for the last equivalence, the theorem is proved in [6]. We
check here only that if f, g are observably sequential, f â‰¤g, and x â‰¤y,
then g(y) = g(x)âˆ¨f(y). Suppose that g(y) > g(x)âˆ¨f(y). Let qâ€² be ï¬lled
in g(y) and accessible from g(x) âˆ¨f(y). It follows that qâ€² is accessible
from g(x) and from f(y). The only way for g to make the diï¬€erence
w.r.t. f on input y is to use one of its additional âŠ¤â€™s, say, qâ€²âŠ¤, in the
interaction with y. More precisely, one of the âŠ¤â€™s of g is responsible for
the ï¬lling of qâ€². But the interaction of g with y is the same as with x.
Hence qâ€² must be ï¬lled in g(x), contrary to our assumption.
As an illustration of what is going on, suppose that f1, f2:S â†’Sâ€² are
â‰¤s-minimal observably sequential algorithms such that
câ€² c1 (c1v1) c2 (c2v2) c âˆˆf1
câ€² c2 (c2v2) c1 (c1v1) c âˆˆf2
It looks like f1 and f2 deï¬ne the same function (and indeed they do
deï¬ne the same function from D(S) to D(Sâ€²)), but on x = {c1âŠ¥, c2âŠ¤}
we have:
f1 Â· x = {câ€²âŠ¥}
f2 Â· x = {câ€²âŠ¤}
Here, both âŠ¥and âŠ¤act very much like colours used in chemical
experiments: they track the presence of a proper value in c1 and c2,
respectively. The special values âŠ¥and âŠ¤play entirely symmetric roles
as long as no inï¬nite computations take place.
If we allow general, non-ï¬nitary strategies, the abstract machine of
Deï¬nition 3.8 may well diverge (i.e. not terminate). Following Scott-
Ershovâ€™s tradition, a non-terminating computation receives âŠ¥as value,
and then âŠ¥and âŠ¤cease to be symmetrical, since âŠ¥has become
overloaded: it is both a symbol for non-termination, and an explicit
symbol for a special error value that could be called â€œstop by lack of
informationâ€. The other error value âŠ¤could be called â€œdeliberate stopâ€
(see [10, 12, 8]).
3.3 Bistable biorders
So far, so good: we have a characterization of our notion of functions-
as-algorithms as functions-as-relations. But still, the deï¬nition of
sequential function (originally due to Kahn and Plotkin [14]) requires
a rather concrete, â€œalgorithmicâ€ deï¬nition of domain (here, sequential
data structures). We can get rid of this too, using Lairdâ€™s notion of
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
63
bistability, which can be deï¬ned more abstractly. In this section, we
recall Lairdâ€™s deï¬nitions [15].
Deï¬nition 3.11 A bistable biorder is a set (D, â‰¤, âŠ‘) equipped with two
partial orders, such that whenever x, y have a lower or an upper bound
for â‰¤then x âˆ¨y and x âˆ§y exist (for â‰¤), and then x âˆ¨y = x âŠ”y and
xâˆ§y = xâŠ“y, hence the two orders coincide for â‰¤-connected components.
Moreover âˆ§and âˆ¨distribute over each other in each component. One
writes x â†•y when x, y have a â‰¤-upper bound (or equivalently a â‰¤-lower
bound). A bistable function is a â‰¤-monotonic function such that for any
x â†•y:
f(x âˆ§y) = f(x) âˆ§f(y)
f(x âˆ¨y) = f(x) âˆ¨f(y)
(we refer to the two halves of this property as âˆ§-bistability and âˆ¨-
bistability, respectively).
We observe (for the reader with some linear logic culture) that the preser-
vation of âˆ¨in the above deï¬nition is not a requirement of linearity, as
it is taken with respect to â‰¤, not â‰¤s.
In [15], the following theorem is proved:
Proposition 3.12 The category of bistable biorders and bistable and
âŠ‘-monotonic functions is cartesian closed.
3.4 Full embedding
In this section, we show that the category of observably sequential
algorithms embeds fully in Lairdâ€™s category of bistable biorders and
bistable and âŠ‘-monotonic functions. This amounts to the following
proposition:
Theorem 3.13 Given two sdsâ€™s S and Sâ€², a function f:DâŠ¤(S) to DâŠ¤(Sâ€²)
is observably sequential if and only if it is bistable and âŠ‘-monotonic.
Proof The proof of (f âŠ‘-monotonic and bistable â‡’f sequential) follows
the steps of (and generalizes) Lairdâ€™s proof of this property at x = âŠ¥[15].
Suppose that qâ€² is accessible from f(x) (with x = x[q0 â†âŠ¥, . . . , qn â†
âŠ¥]), and suppose moreover that none of the qiâ€™s is a sequentiality index.
Then by âŠ‘monotonicity we have that qâ€² is ï¬lled in all of the f(x[q0 â†
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

64
P.-L. Curien
âŠ¤, . . . , qiâˆ’1 â†âŠ¤, qi â†âŠ¥, qi+1 â†âŠ¤, . . . , qn â†âŠ¤]). By â‰¤-monotonicity
it is also ï¬lled in f(x[q0 â†âŠ¤, . . . , qn â†âŠ¤]), and hence it is ï¬lled with
the same value in all of the f(x[q0 â†âŠ¤, . . . , qiâˆ’1 â†âŠ¤, qi â†âŠ¥, qi+1 â†
âŠ¤, . . . , qn â†âŠ¤]). Now, by âˆ§-bistability, it should also be ï¬lled in f(x)
since
x =

i=1...n
x[q0 â†âŠ¤, , . . . , qiâˆ’1 â†âŠ¤, qi â†âŠ¥, qi+1 â†âŠ¤, . . . , qn â†âŠ¤] .
We show that if f is âŠ‘-monotonic and bistable, then it is observably
sequential. That is, we have to show that if f has, say, q0 as sequentiality
index at (x, qâ€²), then qâ€²âŠ¤âˆˆf(x[q0 â†âŠ¤]). Suppose not. Then, if y is
such that x â‰¤s y and qâ€² is ï¬lled in f(y), we have y âŠ‘y[q0 â†âŠ¤] and
x[q0 â†âŠ¤] â‰¤y[q0 â†âŠ¤]. Since by pointwise monotonicity qâ€² is ï¬lled
in f(y[q0 â†âŠ¤]), there exists a sequentiality index q1 for f at (x[q0 â†
âŠ¤], qâ€²). Continuing in this way, we would exhaust all the âŠ¥â€™s of x. So we
get that qâ€² is ï¬lled in, say, f(x[q0 â†âŠ¤, q1 â†âŠ¤, . . . , qn â†âŠ¤]), and hence
by âˆ¨-bistability in one of the f(x[qi â†âŠ¤]). But it cannot be an i > 0
since q0 is a sequentiality index at x, hence it is i = 0, which contradicts
the assumption.1
Conversely, if f observably sequential, we ï¬rst show that f is âŠ‘-
monotonic. It is enough to check that if x â‰¤c y then f(x) â‰¤c f(y). To
show this â€“ actually, the natural thing to show is that more generally
if f â‰¤c g and x â‰¤c y then f(x) â‰¤c f(y) â€“, we extend the deï¬nition of
â‰¤c by congruence to all the terms involved in the rewriting system of
Deï¬nition 3.8. It is straightforward to show, for each of the rules of the
rewriting system, that if t â‰¤c tâ€² and tâ€² â†’tâ€²
1 then there exists t1 such
that t â†’t1. Informally, the only diï¬€erence of behaviour is that âŸ¨g || y âŸ©
might terminate before âŸ¨f || x âŸ©, because of a new âŠ¤in g or y. Notice that
1 Here, and also in the next section, we make the simplifying assumption that the
strategies are ï¬nite. We sketch here what adjustments have to be made to remove
the ï¬niteness restriction. This is rather standard domain theory: bistable biorders
have to be directed complete, and bistable functions have to be Scott-continuous.
We refer to [15] for the relevant deï¬nitions. With a little care, all our arguments
go through, making use of the continuity assumption. For example, to prove
observable sequentiality, we used the ï¬niteness assumption when writing x =
x[q0 â†âŠ¥, . . . , qn â†âŠ¥], with n ï¬nite. If instead we have
x = x[q0 â†âŠ¥, . . . , qn â†âŠ¥, . . . , ] ,
then the proof of sequentiality goes through because by continuity the âˆ§-bistability
extends to preservation of greatest lower bounds of arbitrary subsets of a â†•-
component. For the proof of observable sequentiality, the ï¬niteness of n was
essential. But continuity saves us again: by continuity, we can take x, y ï¬nite, and
we need only care about the qjâ€™s that are ï¬lled in y, which are ï¬nitely many.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
65
this argument is the same as the one used in the separation theorem of
ludics (and, by the way, Girardâ€™s designs also form a bistable biorder)
[12, 8].
Finally, we show that if f is observably sequential then it is bistable.
One proves that f is â‰¤-monotonic much in the same way as for âŠ‘-
monotonicity. The argument for âˆ§-bistability is standard. One proves
actually the preservation of all â‰¤s compatible binary â‰¤s greatest lower
bounds (glb). Suppose that x, y â‰¤s z and f(x âˆ§s y) <s f(x) âˆ§s f(y).
Let qâ€² be accessible from f(x âˆ§s y) and ï¬lled in f(x) and f(y). Let q
be a sequentiality index at x âˆ§s y, câ€². Then by sequentiality q is ï¬lled
in both x and y, and with the same value since x, y have a â‰¤s upper
bound. But then q is also ï¬lled in x âˆ§s y, contrary to the assumption.
This shows a fortiori âˆ§-bistability since x â†•y implies a fortiori that x, y
have a â‰¤s-upper bound, and that x âˆ§y = x âˆ§s y.
As for âˆ¨-bistability, suppose that f(x) âˆ¨f(y) < f(x âˆ¨y). Let qâ€² be
accessible from f(x)âˆ¨f(y) and ï¬lled in f(xâˆ¨y). Then qâ€² must be already
accessible from f(x âˆ§y), as the order â‰¤does not add new queries. Let
q be the sequentiality index for qâ€² at x âˆ§y. Then we have that q is ï¬lled
in x âˆ¨y by sequentiality, i.e. it is ï¬lled in either x or y, say, in x. By
deï¬nition of â‰¤, since q is accessible from x âˆ§y, q must be ï¬lled with âŠ¤
in x. But then qâ€² is ï¬lled with âŠ¤in f(x) (and a fortiori in f(x âˆ¨y)), by
observable sequentiality: contradiction.
Proposition 3.14 The category of sdsâ€™s and observably sequential
algorithms is cartesian closed.
Proof This is an easy corollary of Theorem 3.13, Proposition 3.12, and
Theorem 3.10. Indeed, all we have to check for a full subcategory of a
cartesian closed category to be itself cartesian-closed is that the (product
and) function space construction of the larger category, when applied to
objects of the smaller, yields an object of the smaller. Lairdâ€™s function
space DâŠ¤(S) â†’DâŠ¤(Sâ€²) is the set of bistable and âŠ‘-monotonic functions,
equipped with the pointwise and bistable orderings, which is isomorphic
to DâŠ¤(S â†’Sâ€²).
A direct proof of Proposition 3.14 is given in [6], but it is more
complicated than the proof of Proposition 3.12.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

66
P.-L. Curien
3.5 Aï¬ƒne decomposition
In this section, we prove that aï¬ƒne sequential algorithms can also be
deï¬ned as observably sequential functions that are aï¬ƒne with respect to
the stable order, and hence as aï¬ƒne bistable and âŠ‘-monotonic functions
(provided this makes sense, see below).
Deï¬nition 3.15 An aï¬ƒne function is a function that preserves stable
upper bounds of stably compatible elements.
(The diï¬€erence with linear functions, which may be more familiar to
the linear logic oriented reader, is that preservation of âŠ¥is not required.)
Proposition 3.16 Aï¬ƒne sequential algorithms are in order-isomorphic
correspondence with aï¬ƒne observably sequential functions.
Proof
Let f be a sequential algorithm which is not aï¬ƒne. It contains
at least a query of the form r câ€²q1 r1 q2, where r1 is not a preï¬x of q2.
Let x be the input strategy read oï¬€along the path from the root up
to q2. Formally, x = state(r), where r is the projection of r câ€² q1 r1 on
the input sds. Let y = (x \ {r1}) âˆª{q2âŠ¤}. Let qâ€² be the projection of
rcâ€² on the output sds. Then qâ€² is ï¬lled neither in f(x) nor in f(y), but
is ï¬lled (with âŠ¤) in f(x âˆ¨s y). Conversely, suppose that f is an aï¬ƒne
sequential algorithm, and let qâ€²wâ€² âˆˆf(x âˆ¨s y). Let s be the position
of f visited along the normalization against x âˆ¨s y towards qâ€²wâ€² (it is
obtained by travelling in f from the root starting with the initial move
of qâ€², and solving ambiguities using x âˆ¨s y and qâ€²wâ€² when going up after
a playerâ€™s move, cf. Deï¬nition 3.8). Consider the last input response r on
this position of f. Then r belongs to either x or y, say x. But all other
responses along the path are preï¬xes of r, by the constraint of aï¬ƒnity,
hence all belong to x. Therefore qâ€²wâ€² âˆˆf(x) (or qâ€²wâ€² âˆˆf(y)).
However, bistable biorders are too poor to express the stable ordering.
In further work, Laird [16] has deï¬ned the full subcategory of locally
boolean domains in which not only the pointwise and bistable orders can
be deï¬ned, but also the stable one [16] (we refer to this paper for the
deï¬nition, which takes as primitive an operation Â¬ of involution which in
terms of sdsâ€™s consists in exchanging âŠ¥â€²s with âŠ¤â€²s). In fact, Laird shows
a representation theorem, by means of elegant abstract decompositions:
every locally boolean domain is isomorphic to the set of strategies of
some sds (and every such set is a locally boolean domain). Summing up,
we end up with an equivalence (actually two equivalences) of categories.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
67
Proposition 3.17 The categories of sdsâ€™s and (observably) sequential
algorithms and of locally boolean domains and âŠ‘-monotonic and bistable
functions are equivalent. This equivalence cuts down to an equivalence
between the respective subcategories of aï¬ƒne morphisms (Deï¬nitions 3.5
and 3.15).
Proof
Propositions 3.13 and 3.16 have established full embeddings.
The equivalence of categories follows from the fullness on objects of the
functors co-restricted to locally boolean domains.
Since both in [17, 7] and [16] the comonads leading to models of
(aï¬ƒne, intuitionistic) linear logic are deï¬ned as adjoint to an inclusion
functor from the aï¬ƒne subcategory, the two decompositions are the
same up to isomorphism. In other words, Lairdâ€™s work provides a
completely traditional domain-theoretic account of Berryâ€“Cartwrightâ€“
Curienâ€“Felleisenâ€“Lamarcheâ€™s sequential algorithms model.
Finally, we mention two properties which add to the ambient
symmetry:
Proposition 3.18
(i) Observably sequential functions are costable, i.e.:
âˆ€x, y
(âˆƒz z â‰¤c z and z â‰¤c y) â‡’f(x âˆ¨c y) = f(x) âˆ¨c f(y)
(ii) Aï¬ƒne observably sequential functions are coaï¬ƒne, i.e.:
âˆ€x, y
(âˆƒz z â‰¤c z and z â‰¤c y) â‡’f(x âˆ§c y) = f(x) âˆ§c f(y)
The proofs are not diï¬ƒcult and are in the same vein as the ones given
above.
However, observably sequential functions fail to be cocontinuous, i.e.
they fail to preserve costable glbs of costable ï¬lters (see [18], Example
3.5.8,
for
a
counter-example):
this
demonstrates
the
operational
dissymmetry between âŠ¤and âŠ¥, since the latter is also used to denote
non-termination.
We end the section with a brief sketch of how the concrete structure
of sdsâ€™s can be â€œabstractedâ€ to that of a locally boolean domain. More
precisely, we exhibit Lairdâ€™s decomposition ï¬rst in concrete terms, and
then more abstractly, thus suggesting some of the ideas underlying
Lairdâ€™s representation theorem mentioned above.
First, we observe that the compact primes (i.e. the elements x such
that, for any Y , x â‰¤s  Y implies x â‰¤s y for some y âˆˆY ) of DâŠ¤(S)
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

68
P.-L. Curien
are in one-to-one correspondence with the queries and the responses
of S:
r
ï£±
ï£´
ï£²
ï£´
ï£³
c1 âŠ¥
...
cn âŠ¥
r
ï£±
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£³
c1 âŠ¥
...
c âŠ¤
...
cn âŠ¥
response
(x = x âˆ©Â¬x)
query
(x Ì¸= x âˆ©Â¬x)
Next, any sds S can be written as
DâŠ¤(S) â‰ˆ

i
Di
where
Di = {x | x â‰¤c {ciâŠ¤} âˆª{câŠ¥| c âˆˆQ and c Ì¸= ci}
Abstractly:
DâŠ¤(S) â‰ˆ

{p|p â‰¤câˆ’maximal compact prime}
{x | x â‰¤c p}
Each Di is represented by an sds Si (i.e., Di â‰ˆDâŠ¤(Si)) that has a
unique initial cell ci. This property can be captured abstractly as:
âŠ¤is prime (and Ì¸= âŠ¥)
The next step in the decomposition is to write
Di = Dâ€²
i âˆª{âŠ¥, âŠ¤} def
= (Dâ€²
i)â†‘
with Dâ€²
i = DâŠ¤(Sâ€²i), where Sâ€²i is obtained from Si by stripping oï¬€the
unique initial cell ci.
Finally, we decompose Dâ€²
i as follows:
Dâ€²
i â‰ˆÎ£jDij
where
Dij = {x âˆˆDi | x starts with vj} = {x | x â‰¥s {vjâŠ¥}}
or, abstractly:
Dâ€²
i â‰ˆ

{m|m â‰¤sâˆ’minimal}
{x | x â‰¥s m}
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

Sequential algorithms as bistable maps
69
Summing up, we have:
DâŠ¤(S)
â‰ˆ

i Di
(product of domains indexed
over â‰¤c âˆ’maximal prime elements)
Di
=
(Dâ€²
i)â†‘
(lifting of predomain)
Dâ€²
i
â‰ˆ

j Dij
(sum of domains indexed
over â‰¤s âˆ’minimal elements)
3.6 Conclusion
We should note that a (weaker) version of the full embedding was proved
indirectly in Lairdâ€™s paper [15]: he proves that the bistable model is fully
abstract for the language Î›âŠ¤
âŠ¥(the simply typed Î»-calculus with a single
base type, and two constants âŠ¥and âŠ¤of base type). This calculus is
essentially the same as Cartwrightâ€“Curienâ€“Felleisenâ€™s language SPCF
with respect to which the model of sequential algorithms is fully abstract
[6]. Hence, by uniqueness up to isomorphism of fully abstract models,
the two models are isomorphic on the simply typed hierarchy. Our result
is more general and does not refer to (the interpretation of) types.
As for every correspondence result, there are mutual beneï¬ts in the
equivalence that we have proved. The algorithmic side provides an
operational explanation of the various orders. The abstract domain-
theoretic side provides simpler proofs sometimes (for example, of
cartesian closedness,2 and opens the way to extend the coverage
of standard domain-theoretic tools for reasoning about sequential
languages. Lairdâ€™s current work goes in that direction.
Bibliography
[1]
R. Amadio and P.-L. Curien, Domains and Lambda-calculi, Cambridge
University Press (1998).
[2]
G. Berry, Stable models of typed lambda-calculi. In Proc. ICALP 1978,
Lecture Notes in Computer Science 62 Springer-Verlag (1978).
[3]
G. Berry and P.-L. Curien, Sequential algorithms on concrete data
structures, Theoretical Computer Science 20:265â€“321 (1982).
2 Note however that it is not known whether the subcategory of locally boolean
domains is cartesian closed. We have used here the cartesian closedness of the
larger category of bistable biorders.
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

70
P.-L. Curien
[4]
G. Berry and P.-L. Curien, Theory and practice of sequential algorithms:
the kernel of the applicative language CDS. In Algebraic Methods in
Semantics, M. Nivat, J. Reynolds (eds), Cambridge University Press, pp.
35â€“87 (1985).
[5]
R. Cartwright and M. Felleisen, Observable sequentiality and full
abstraction. In Proc. POPL 1992 (1992).
[6]
R. Cartwright, P.-L. Curien and M. Felleisen, Fully abstract semantics for
observably sequential languages, Information and Computation 111(2):297â€“
401 (1994).
[7]
P.-L. Curien, On the symmetry of sequentiality. In Proceedings of
Mathematical Foundations of Programming Semantics 1993, Lecture Notes
in Computer Science 802, Springer-Verlag, pp. 29â€“71 (1994).
[8]
P.-L. Curien, Introduction to Linerar logic and ludics, parts I and II,
Advances of Mathematics (China) 34(5):513â€“544 (2005) and 35(1):1â€“44
(2006).
[9]
P.-L. Curien, Combinateurs CatÂ´egoriques, Algorithmes SÂ´equentiels et
Programmation Fonctionnelle, Th`ese dâ€™Etat, UniversitÂ´e Paris 7 (1983);
English
version:
Categorical
Combinators,
Sequential
Algorithms
and
Functional Programming, Research Notes in Theoretical Computer Science,
Pitman (1986); second, revised edition, BirkhaÂ¨user (1993).
[10]
P.-L. Curien, Symmetry and interactivity in programming, Bulletin of
Symbolic Logic 9(2):169â€“180 (2003).
[11]
J.-Y. Girard, Linear logic, Theoretical Computer Sciences 50:1â€“102
(1987).
[12]
J.-Y. Girard, Locus Solum, Mathematical Structures in Computer
Science (2001).
[13]
G. Kahn and D. MacQueen, Coroutines and networks of parallel
processes. In Proc. IFIP 1977, B. Gilchrist (ed.), North-Holland, pp. 993â€“
998 (1977).
[14]
G. Kahn and G. Plotkin, Concrete domains, Theoretical Computer
Science 12:187â€“277 (1993).
[15]
J. Laird, Bistability: an extensional characterization of sequentiality. In
Proc. Computer Science and Logic 2003, Lecture Notes in Computer Science
2803, Springer-Verlag (2003).
[16]
J. Laird, Locally boolean domains, Theoretical Computer Science
342:132â€“248 (2005).
[17]
F. Lamarche, Sequentiality, games and linear logic. In Proc. CLICS
Workshop, Aarhus University, DAIMI-397-II (1992).
[18]
T. Loew, Locally Boolean Domains and Universal Models for Inï¬nitary
Sequential Languages, PhD Thesis, Technische UniversitÂ¨at Darmstadt
(2006).
[19]
T. Streicher, Laird domains, draft (2002).
https://doi.org/10.1017/CBO9780511770524.004 Published online by Cambridge University Press

