Information and Software Technology 143 (2022) 106789
Available online 26 November 2021
0950-5849/© 2021 Elsevier B.V. All rights reserved.
Programming language implementations for context-oriented 
self-adaptive systems 
Nicol´as Cardozo a,*, Kim Mens b 
a Systems and Computing Engineering Department, Universidad de los Andes, FLAG Laboratory, Bogot´a, Colombia 
b ICTEAM, Universit´e Catholique de Louvain, Louvain-la-Neuve, Belgium   
A R T I C L E  I N F O   
Keywords: 
Context-oriented programming 
Self-adaptive systems 
Language engineering 
Programming language abstractions 
A B S T R A C T   
Context: The context-oriented programming paradigm is designed to enable self-adaptation, or dynamic behavior 
modification of software systems, in response to changes in their surrounding environment. Contextoriented 
programming offers an adaptation model, from a programming language perspective, that maintains a clean 
modularisation between the application and adaptation logic, as well as between the components providing 
adaptations. 
Objective: We use three implementation techniques for context-oriented programming languages to assess their 
appropriateness to foster self-adaptive systems. These approaches take advantage of the capabilities offered by 
the host programming language to realize self-adaptation as proposed by context-oriented languages. 
Method: We evaluate each of these approaches by assessing their modularity and complexity when defining 
adaptations, and by comparing their run-time performance on a simple benchmark. 
Results: Our results show a higher modularity than that for common architecture based self-adaptive systems, 
while maintaining comparable performance. 
Conclusion: We conclude that context-oriented programming is an appropriate paradigm to realize self- 
adaptation.   
1. Introduction 
Modern software systems are no longer developed under the 
assumption that all system entities and boundaries are completely 
known and defined beforehand. Rather, the development of software 
systems is shifting towards systems highly aware of their surrounding 
environment, which is in continuous change. Such systems, called self- 
adaptive, context-aware, or context-oriented systems, are able to 
dynamically adapt their behavior with respect to internal (self) and 
external (context) conditions of the execution environment [1]. 
There are two main approaches to realize context-oriented or self- 
adaptive systems. Systems can be defined to use external or internal 
adaptation engines. The main difference resides in where the adaptation 
logic of the system is implemented [2]. External adaptation engines 
claim to provide a more modular structure of the system, where the 
adaptation logic resides in external modules independent from those of 
the application logic. Internal adaptation engines, in contrast, typically 
implement both the adaptation and application logic inside the system 
itself. 
Since external adaptation engines expose the adaptation modules 
used for a particular system, these modules can be customized and 
reused to manage adaptation of other related systems with ease. Such 
adaptation engines are thus regarded as highly modular and reusable. 
Nonetheless, to be able to reuse or customize these adaptations, external 
adaptation engines need to abstract their reusable components to ach­
ieve sufficient genericity, which raises their architectural footprint. 
Internal adaptation engines are mostly regarded by the self-adaptive 
community as a less flexible solution for adaptivity, because they are 
considered to be tightly coupled with the system’s implementation. If 
the adaptation and application logic are too interwoven, this indeed 
gives rise to maintainability, reusability, and evolution problems. 
Therefore, the use of external adaptation engines is often promoted over 
internal adaptation engines for the development of self-adaptive systems 
[1]. 
In this paper we argue that it is possible to design internal adaptation 
engines that cleanly separate the adaptation logic from the application 
logic. Such internal adaptation engines can provide a viable alternative 
for the implementation of selfadaptive systems, exhibiting even more 
* Corresponding author. 
E-mail addresses: n.cardozo@uniandes.edu.co (N. Cardozo), kim.mens@uclouvain.be (K. Mens).  
Contents lists available at ScienceDirect 
Information and Software Technology 
journal homepage: www.elsevier.com/locate/infsof 
https://doi.org/10.1016/j.infsof.2021.106789 
Received 31 March 2021; Received in revised form 5 November 2021; Accepted 15 November 2021   

Information and Software Technology 143 (2022) 106789
2
flexibility than their external counterparts, precisely because they do not 
suffer from added architectural complexity. 
One proposal for the development of internal adaptation engines for 
self-adaptive systems is that offered by Context-oriented Programming 
(COP) [3,4]. Such adaptation engines avoid architectural clutter by 
pushing it down to the programming language design, and provide 
appropriate language abstractions for dealing with both the adaptation 
and application logic independently. 
This paper showcases different implementation techniques for COP 
languages and illustrates how they achieve self- and context-adaptation1 
at the programming language level. Our claim is that COP provides a 
clear independence between adaptation and application logic, as well as 
a transparent adaptation logic and management interface to developers. 
We explore three different COP implementation techniques to enable 
dynamic adaptation of software systems with respect to their sur­
rounding execution environment. The techniques discussed are repre­
sentative of a range of techniques used in existing COP approaches to 
enable adaptation at the programming language level. In particular, the 
implementation techniques showcased hereinafter are inspired by our 
work in COP. Nonetheless, we note that the specific languages show­
cased cover the variability of the four key dimensions to achieve adap­
tivity in COP languages [5]: (1) the host language’s dynamic adaptation 
and composition capabilities, (2) the adaptation selection mechanisms, 
(3) the scope of adaptations, and (4) the separation of adaptation and 
application logic. 
COP languages provide a language-native approach to develop 
modular software systems that can adapt dynamically to a variety of 
contexts. The dedicated programming language abstractions provided 
by COP languages make it possible to develop highly flexible self- 
adaptive systems in which the adaptation and application logic are 
cleanly modularized [5]. 
We focus our analysis on the different implementation techniques to 
achieve dynamic adaptation for COP languages, making them suited to 
build self-adaptive software systems. The desired properties of self- 
adaptive systems we expect internal adaptation engines to satisfy are 
taken from the literature on taxonomies of self-adaptive systems [1,6], 
and existing properties and taxonomies of context-aware systems [4,7, 
8]. In summary, we want internal adaptation engines that are: (1) smart, 
by choosing the most appropriate system behavior with respect to the 
current execution context; (2) open to interact with and adapt to 
different (new) agents that operate in the system’s surrounding envi­
ronment; (3) resilient to changes, by offering the possibility to implement 
graceful degradations of the systems’ behavior to particular contexts; 
(4) extensible, since unforeseen adaptations can be added on-the-fly, 
simply by adding new behavioral variations together with a high-level 
specification of the contexts to which they apply; (5) highly available, 
as the system does not need to be stopped to introduce new behavior or 
bug fixes [9]; (6) customizable to many different variations made 
available for particular situations; (7) modular, as (groups of) adapta­
tions can be bundled separately from each other and the application 
logic; (8) fine-grained, allowing adaptations of existing behavior at the 
level of granularity of individual methods; (9) concise, as adaptations 
consist only of the fine-grained adapted behavior they define and their 
definition is decoupled from unrelated existing adaptations and appli­
cation logic; and (10) understandable, since the application logic is not 
cluttered by adaptation management concerns, given that this mecha­
nism is internalized in the language. 
This paper presents and analyses three implementation techniques to 
realize internal adaptation engines at a programming language level: 
context-dependent method dispatch, method replacement, and fine-grained 
composition. Each technique pertains to a specific point in the system’s 
execution to realize the adaptation. The first technique extends the 
language’s method dispatching mechanism to dynamically select the 
appropriate behavior to execute based on the context. The second 
technique uses method implementation exchange to dynamically 
change the pointer of method implementations as contexts change. The 
third technique enables the dynamic composition of fine-grained soft­
ware components (i.e., methods) to include or withdraw behavior from 
the system according to the context. The reason to explore these 
implementation techniques is twofold. First, we have explored these 
techniques in our previous research on COP since its inception. Second, 
across COP languages, we observe that the base of the techniques used in 
other implementations falls back to one of the three techniques we 
explore in the paper. However, other techniques are available, which we 
discuss further in Section 5. 
For each of the implementation techniques we analyze their appro­
priateness from three perspectives: expressiveness, modularity, and 
performance. Expressiveness is evaluated by comparing the differences 
between the implementations to express a common case study of a smart 
city guide application. Modularity is evaluated empirically by observing 
the independence of the implemented components. Performance is 
evaluated through dedicated mini benchmarks measuring the different 
adaptation techniques against de facto techniques to enable adaptations 
in software systems. Using our evaluation, we conclude that internal 
adaptation engines provided by COP languages successfully achieve 
maintainability, reusability, and high adaptivity, at an acceptable per­
formance cost, and are therefore a viable option to foster self-adaptive 
systems. 
The remainder of this paper is organized as follows. Section 2 pre­
sents an overview of COP implementations and the main language ab­
stractions used in COP to realize self-adaptation. That section also 
presents our running example of a smart city guide, as implemented in 
the Subjective-C COP language. Section 3 details the explored imple­
mentation techniques to enable adaptation at the programming lan­
guage level. Each of these implementations is associated to a particular 
COP language. Section 4 presents an evaluation of each technique with 
respect to its expressiveness, modularity, and performance. Section 5 
discusses related approaches existing in the COP community and related 
language-level techniques to enable dynamic software adaptation. 
Finally, Section 6 draws lessons from our experience in developing self- 
adaptive systems with internal adaptation engines, and offers perspec­
tives of future work. 
2. Context-oriented programming 
Over the last decade, there has been increasing interest of the pro­
gramming language community to provide language-level abstractions 
and support to realize and manage dynamic behavioral variations. The 
objective of this body of research is to provide dedicated programming 
facilities to foster software systems in the vision of Ubiquitous 
Computing [10] and Ambient Intelligence [11]. The COP paradigm is 
proposed to cater precisely to this necessity [3,4]. 
COP provides support for developing software systems with specific 
behavior variations according to particular situations occurring in the 
system’s surrounding environment. Such behavior is made available 
whenever the respective situations are sensed by the system, for 
example, through a sensor network. Situations for which the system can 
exhibit specialized behavior can be external (e.g., weather conditions, 
time of day), internal system events (e.g., system preferences, CPU load) 
or user preferences (e.g., language, age group). In COP, no explicit 
distinction between these kinds of situations is made and they are 
commonly referred to as contexts. Henceforth, we use context to mean 
both external or internal events, and user preferences. 
2.1. COP language abstractions 
Different programming languages (or extensions of existing pro­
gramming languages) have been developed to realize the COP paradigm 
1 From this point onwards, given our focus on contextoriented programming 
languages, we use adaptation, to mean both selfand context-adaptation. 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
3
[5,12]. COP languages allow developing applications that feature 
behavioral variations that are seamlessly composed with, or withdrawn 
from, the main systems’ application logic, responding to the current 
execution context. We now define the main COP concepts and termi­
nology used throughout the rest of this paper. This terminology covers 
the main building blocks to enable dynamic behavioral variations that 
all COP languages provide (in some form or another) regardless of their 
specific implementation. 
Context: Corresponds to a specific situation of the system’s sur­
rounding environment that is semantically meaningful for the system. 
Contexts2 are defined as independent (first-class) system entities. 
Behavioral variation: Defines a specialized behavior that the system 
should exhibit under a particular situation. This can be defined as an 
independent module or feature of the system or within the system 
modules (e.g., classes) it adapts. 
Adaptation: Refers to a specific context and all of its associated 
behavioral variations. 
Context activation/deactivation: Happens as a response to changes 
sensed in the system’s surrounding environment. Context activation and 
deactivation, make available or unavailable all behavioral variations 
associated with a context. This is done by allowing the dynamic 
composition or withdrawal of behavioral variations with or from the 
system’s application logic. 
The abstractions introduced by COP languages for the definition of 
contexts and behavioral variations, allow programmers to reduce the 
tangling and scattering of adaptation logic with the application logic, as 
opposed to claims about internal adaptation engines [2,1]. Moreover, 
the adaptation logic is transparently reusable because adaptation 
composition is not specific to a particular application or set of adapta­
tions, but rather all applications compose adaptations in the same 
fashion. Furthermore, the declaration of contexts and their associated 
behavioral variations could be reused for different systems, assuming 
they are in accordance with the purpose of those other systems [9]. 
Finally, we claim that using COP to build self-adaptive software systems 
can prove beneficial for system evolution (given that upgrades to the 
application logic can be introduced dynamically as new behavioral 
variations), and maintainability (as both adaptation and application 
logic are cleanly modularized) [13]. 
2.2. Case study 
As a case study of a dynamically adaptive application, we consider a 
smart city guide [14,15], a real-world mobile application that enables 
tourists visiting a city to navigate through its Points of Interest (POIs). 
The application provides the possibility to create and customize city 
tours and navigate through them based on a selection of POIs. These 
features can be enhanced further according to the surrounding envi­
ronment or user preferences. The smart city guide application consti­
tutes a large case study for context-aware self-adaptive systems. Fig. 1 
depicts the behavioral variations and the contexts used in the definition 
of such an application, represented in terms of feature diagrams, 
following a feature-based context-oriented model [16]. These features 
are elaborated upon in the following functional requirements: 
Tour Creation & Selection: Users can create and select city tours based 
on a list of available POIs. A tour can be followed in two modes: if the 
device has a GPSAntenna, the application offers a Guided– Tour mode 
which guides users throughout the city according to predefined Itiner­
aries of POIs. The TimeOfDay can affect the order in which these POIs 
are visited, to take into account their visiting hours, or to display 
different images depending on the time of day when the application is 
used. For example, during the Day only daytime images of buildings and 
statues are shown, so that they can be recognised easily by users. In 
FreeTour mode, users can walk freely around the city and receive di­
rections to nearby POIs. Similarly to the previous case, direction to, and 
information about POIs can be tailored to Day or Night time. 
City Navigation: Provides the possibility to navigate between POIs 
using either detailed Directions or by following a Map using a Compass. 
For example, in FreeTour mode, where no GPSAntenna is available, the 
Compass will be used. Upon arrival at a POI, a POIDescription con­
taining its information is displayed to the user. If a Wifi connection is 
available, the application can allow users to fetch additional multimedia 
information about the POI. 
POI Display & Information: A POI’s description can be customized 
according to various UserPreferences (e.g., UserLanguage or Age). The 
UserLanguage context enables the application to adapt its displayed 
information to a particular language, such as Engtish or French. The 
language to use is determined either by the geographical position of the 
user (e.g., UK or France), or is preselected by the user in the application 
preferences. We restrict the application to offer only one language at a 
time. 
The left-hand side of Fig. 1 shows the principal contexts declared for 
the application, based on the usage situations in which specialized 
behavior is required. There are 22 contexts specializing the behavior of 
the four main features. For example, the functionality for POIDisptay is 
specialized to use audiovisual descriptions for POIs, whenever there is 
Wifi connectivity; or to adapt the complexity of the displayed informa­
tion to the Age category of the user, e.g., Chitd or Adutt. 
3. Extending programming languages to support self-adaptation 
COP provides language abstractions that enable the development of 
self-adaptive systems, in which the adaptation engine is internal to the 
system. This means that the logic to adapt a program at run time is 
intertwined with the programming language, and is accessible to ap­
plications by means of a dedicated API. 
We have explored different programming language approaches to 
enable dynamic adaptation of software systems’ behavior with respect 
to the surrounding environment [17,18,19,20]. In the following, we 
present the underlying development techniques we have explored to 
build COP languages. 
3.1. Context definition 
To enable adaptations, we first need to define contexts. Contexts are 
first-class entities of the language, defined (through syntactic sugar) as 
objects in the underlying host language. For example, in Subjective-C (a 
COP language implemented on top of Objective-C), contexts are defined 
using the @context(Wifi) abstraction, yielding a new context object 
named Wifi, as shown in Snippet 1. 
Snippet 1: Definition of context objects in Subjective-C 
This definition is merely syntactic sugar for the context definition 
above, where SCContext is a regular Objective-C object. Each context 
object defines a set of all possible behavioratVariations associated with 
that context. Every time a (new) behavioral variation is associated with 
this context, it is added to this set. 
Dynamic behavioral variations can be characterised by their run- 
time composition, selection and scoping mechanisms. 
3.2. Dynamic behavior composition 
Dynamic behavior composition is the ability of COP languages to 
dynamically introduce or withdraw behavioral variations. That is, 
whenever a context is sensed in the surrounding environment, the sys­
tem must know which behavioral variations are associated to that 
context. Whenever a context becomes active, its associated behavioral 
2 In the COP literature, the technical term layer is also used to refer to 
contexts. 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
4
variations get added to the system; whenever the context is no longer 
present in the surrounding environment, its associated behavioral var­
iations are withdrawn from the system. 
We have explored three main techniques to enable the dynamic 
composition of behavioral variations in different COP languages: (1) 
context-dependent method dispatch, in Ambience [17], (2) method 
replacement, in Subjective-C [18], and (3) fine-grained composition, in 
Context Traits [20]. These techniques explore different implementation 
strategies, taking advantage of particular features provided by the host 
programming language. Further techniques to define adaptations at the 
language level are discussed in Section 5. 
3.2.1. Context-dependent method dispatch 
When adapting the system’s behavior to its surrounding execution 
environment, the system should choose the behavioral variation that is 
most appropriate to the current context. This choice can be made during 
method dispatch, by appending the context information to every method 
call. 
Multiple dispatch has been explored as a particular implementation 
technique to enable dynamic adaptation in COP languages (notably in 
ContextL [3] and Ambience [21]). Specifically, we focus on the imple­
mentation of Ambience, a Lisp-like COP language. With single dispatch, 
methods are looked up dynamically, based on the type of the receiver of 
a message. Multiple dispatch mechanisms can use multiple message ar­
guments to choose the concrete method implementation to call. 
Consider for example the implementation of our smart city guide using 
Common Lisp, as shown in Snippet 2, where calls to display–poi–info are 
dispatched to the most appropriate method definition depending on the 
actual types of its three arguments user, conn, and day–time. 
Snippet 2: Example of multiple dispatch 
From our experience in developing COP languages and the expected 
behavior of contextaware systems, we have observed three properties 
that ease building dynamic adaptations using a context-dependent 
method dispatch technique: (1) The behavior most appropriate to the 
current situation should be chosen based on the surrounding execution 
context [22]. (2) When looking up which method implementation to 
use, priority should be given to the context of execution over other ar­
guments (to ensure the system behavior is driven by the context). (3) 
Relations between context objects are needed to reduce the amount of 
arguments that need to be passed as arguments to a message. 
A natural way of using multiple dispatch to enable dynamic adap­
tation, is to introduce context objects as additional method arguments, 
and dispatch to the most appropriate method taking into account all 
arguments. Behavioral variations for a given context will be selected 
only when the context argument in the message call matches that 
particular context. This approach requires the implicit and dynamic 
modification of all message calls, to introduce contexts as additional 
hidden arguments. 
Messages are intercepted at the meta-level in Ambience’s amos::send 
method, shown in Snippet 3. This method modifies a message to include 
contexts as its first argument, by in-lining the new argument directly in 
the method object, using the prepend–stot function (Lines 4 and 8–11). 
Snippet 3: Metalevel insertion of contexts as message arguments for 
dynamic dispatch 
Different situations or contexts can be sensed simultaneously in the 
surrounding execution environment, all of which should be taken into 
account in messages’ context argument(s). To cater for all possible 
contexts, it would be necessary to define behavioral variations with 
different argument specifications for all possible combinations of con­
texts, which does not scale. 
Instead, Ambience introduces the notion of the current context as a 
structured graph containing the information of all known contexts. In 
particular, this structure provides a representation of all active contexts 
in the system. This current context graph is added as first argument to 
each method call (Line 10 in Snippet 3). 
Fig. 2 shows an example of the current context graph for the smart city 
guide application with three active contexts: @wifi, @night and @adutt. 
In the figure, all active contexts are represented in black. Other contexts 
defined in the system, but not currently active are shown in gray. To the 
right of the graph we have the contexts defined by users to represent 
Fig. 1. Excerpt of the context and feature model of the smart city guide application.  
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
5
situations in which specialized, i.e., adaptive, behavior should be pre­
sent. To the left we see context objects internally generated and 
managed by the system, for example, to represent the composition of 
active contexts. The current context graph is built using delegation as­
sociations (the edges between the nodes in Fig. 2) between the defined 
contexts in two ways: (1) composed contexts implicitly delegate to each 
of their constituents, and (2) explicit delegation links can be defined 
between context objects, according to the abstraction level in which they 
are defined. For example, a @connectivity context abstracts the @wifi 
context, so the latter context delegates to the former using the 
(add–detegation @wifi @connectivity) language construct. Following 
the context delegation graph from active user-defined contexts up the 
delegation associations, yields the current context (left-most node in 
Fig. 2), as the composition of all active contexts. The particular context 
graph in Fig. 2 is used to provide adaptations to the disptay–poi–info 
method. 
The method lookup mechanism finds the correct method imple­
mentation for a given method call according to its arguments. In Am­
bience’s multiple dispatch model, method lookup is based on rank 
vectors [23]. Let us use the display–poi–info method definitions from 
Snippet 2 to explain the way rank-vectors work. Suppose we have the 
following objects for each of the prototypes: nicolas an Adult, home–wifi 
a Wifi connection, and evening a Night time of day. The rank vectors are 
calculated according to the distance, in the delegation graph, between 
the concrete objects to the prototypes for the method definitions in 
Snippet 2. As such, for the first method definition in Snippet 2 we get a 
rank vector (1, 1, 1) given that the distance in the delegation graph from 
the concrete object nicolas to its prototype Adult is 1 (all delegate 
directly to their prototype); similarly the distances from home-wifi to 
Wifi, and from evening to Night are 1 too, as each of these concrete 
objects delegate directly to the defined prototypes. For the second and 
third method definitions, the rank vectors are (2, 1, 1), and (2, 2, 2), 
respectively. Here, the concrete objects do not delegate directly to the 
prototype used in the method definition, requiring to find the closest 
common prototype (i.e., the meet) instead. For example, nicolas is an 
Adult but the prototype mentioned in the method definition is a Child so 
there is no direct match. But both Adult and Child delegate to a common 
prototype User, so the distance for nicolas (to the closest meet User is 2). 
Using a similar reasoning we can find that the distance for home–wifi to 
Edge is 2 (distance to the closest meet Connectivity), and that the dis­
tance for evening to Day is 2 (closest meet is TimeOfDay). When looking 
for a method implementation, the selected method is the one with the 
smallest distance, in lexicographical order, to the message call. In our 
example, that would be the first implementation of disptay–poi– info, 
since (1, 1, 1) < (2, 1, 1) < (2, 2, 2). Given that the current context 
graph is the first (implicit) argument in all methods, this method lookup 
mechanism ensures that methods are always chosen according to the 
most appropriate context. 
Host languages providing capabilities to capture and dispatch 
method calls at run-time (e.g., Objective-C, Common Lisp, Java3) are 
appropriate to implement self-adaptation via context-dependent method 
dispatch techniques. Context-dependent method dispatch mechanisms 
have been used too for the implementation of other COP languages. 
ContextL [3] uses a multiple dispatch mechanism to enable dynamic 
adaptations, while predicate dispatch is used in Lambic [24] and Flute 
[25]. More recently, dynamic invocation of methods has been used to 
implement the Congolo language [26]. 
3.2.2. Method replacement 
An alternative technique to enable dynamic composition of behav­
ioral variations is that of method replacement. The method replacement 
technique reflectively identifies all behavioral variations for a particular 
method at run time, whenever a context change is detected, and then 
replaces the current method behavior by a more specialized one. 
In order to implement the method replacement technique, it is 
necessary to access and modify a software system’s information at run 
time. This can be done by taking advantage of the host language’s 
metaobject protocol (MOP). A full MOP [27,28,29] enables introspection 
to inspect the structure of the system and the internal state of its objects. 
It enables self-modification if it is possible to modify the structure of the 
system. It enables invocation if is possible to call base-level operations (e. 
g., method calls, or field assignment) reflectively. Host programming 
languages whose MOP offer at least introspection and self-modification 
(e.g., ObjectiveC, CLOS, Smalltalk) are amenable to implement a method 
replacement technique for self-adaptation. As an example of this tech­
nique, we use our COP extension to Objective-C, named Subjective-C 
[18]. Objective-C objects have a variable called isa of type Ctass 
providing access to the class that the object is an instance of. This class 
can then be manipulated reflectively, for example to know if a given 
object understands a specific method, we can invoke the metalevel 
method respondsToSetector: on the object’s class. Such reflective 
methods are provided by the metaclass Ctass, part of Objective-C’s MOP. 
Self-modification of Objective-C applications can also be achieved 
Fig. 2. Current context graph in Ambience.  
3 through InvokeDynamic or AOP method interception. 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
6
reflectively through method swizzling, a technique offered by Objecti­
ve-C’s run-time to exchange the implementation of a given selector, by 
changing how selectors are mapped to underlying functions in a class’ 
dispatch table.4 
In the case of Subjective-C, we use method swizzling as a technique 
to replace method implementations when contexts get activated or 
deactivated. Method replacement in Subjective-C consists of two stages, 
as shown by the updateDispatch method in Snippet 4 (Line 14). First, we 
identify all behavioral variations for a particular method of the appli­
cation. All methods in a SubjectiveC application are defined as 
Subjective-C methods, SCMethod. Each SCMethod consists of its signa­
ture (SEL), structure (Method), and a list of all applicable behavioral 
variations (contextMethods) of the method. Behavioral variations are 
created as instances of SCContextMethod, which are composed of their 
method signature, implementation, and a reference to the original 
method they refine. Searching for the applicable behavioral variations 
that can replace a method (getAppticabteMethods in Snippet 4) requires 
us to traverse the list of behavioral variations (SCContextMethods), and 
select those behavioral variations for which their associated context is 
currently active (Lines 3–10). As many different contexts may be active, 
several of which may provide a different specialization for that method, 
an applicability order must be provided (Line 5). The exact order in 
which behavioral variations are applied is defined by the system’s 
scoping rules (discussed later in Section 3.3.2). Once all applicable 
methods have been found, the second stage of the method replacement 
technique uses a reflective call to method_setImptementation (Line 20), 
changing the original method’s implementation with that of the most 
appropriate behavioral variation. Upon context deactivation, a similar 
process is used, swizzling the original method saved in the SCContext­
Method back to the behavioral variation currently stored in the 
SCMethod. 
Snippet 4: Objective-C implementation of method replacement for 
Subjective-C. 
The method replacement process is shown in Snippet 4. Each new 
behavioral variation, SCContextMethod keeps a reference to the 
currently executing method SCMethod it refines, and a copy of the 
method implementation Method that it refines. Before the context is 
activated, an SCContextMethod contains its own implementation to be 
swizzled with the one to be refined, as depicted in Fig. 3a. Whenever a 
context is activated, the original method implementation (Method) 
stored in the Subjective-C method (SCMethod) gets replaced by the new 
implementation of the context (SCContextMethod). The SCContextMe­
thod itself saves a copy of the original method implementation and 
keeps a reference to the SCMethod it refines in its refinedMethod attri­
bute, as shown in step 1 of Fig. 3b. When another context gets activated 
(the blue context) refining the same SCMethod, the method imple­
mentation stored in the SCMethod now becomes the Method imple­
mentation provided by the new context, and the refinedMethod of the 
new context is set to refer to the previous context activated, as shown in 
step in Fig. 3c. 
A similar method replacement technique is used in Phenomenal 
Gems [19] by exploiting the possibility of adapting Ruby’s method ta­
bles at run time to replace a method pointer by another one. RubyCOP, a 
feature-based context-oriented extension to Ruby [30], implements 
method replacement not by changing the method table but by explicitly 
changing a method instance to a more appropriate one. 
Fig. 3. Method replacement and propagation.  
4 A full description of method swizzling can be found in Objective-C’s run- 
time reference: https://devetoper.appte.com/tibrary/ios/documentation/Coc 
oa/Reference/ObjCRuntimeRef 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
7
3.2.3. Fine-grained composition 
Context-oriented self-adaptive systems have two types of modules, 
regular modules containing the main application logic, and adaptation 
modules containing the behavioral variations associated to particular 
contexts. As context-specific situations are sensed in the environment, a 
new variant of the application is generated, where behavioral variations 
associated with the new contexts are composed with the base objects or 
classes they adapt. Using such an incremental composition technique 
requires the host language to provide a way to modify objects or classes’ 
structure at run-time. Examples of such incremental modification 
mechanisms include open classes [31], mixins [32], and traits [33]. All 
of these mechanisms share two commonalities: (1) sparse definition of 
modules —that is, methods in a module can be defined at different times 
and locations in the system, and (2) a mechanism to resolve conflicts 
between matching behavior defined multiple times. These characteris­
tics are key to enable self-adaptivity of a software system through the 
run-time composition of different application modules. In this vision, 
program entities can be seen as aggregations of adaptations at run-time, 
whose behavior can be overwritten or refined via a conflict resolution 
mechanism. As an example implementation of such an fine-grained 
composition technique, we take the trait-based approach used in 
Context Traits [20], a COP extension of ECMAScript, composing 
methods and fields to form full fletched adaptations. 
Traits are the core abstraction used in Context Traits to enable run- 
time adaptations. Before going further, we present traits’ key charac­
teristics [33]. Trait objects can be defined sparsely, describing a set of 
methods they require (i.e., methods without a concrete implementation) 
and a set of methods they provide (i.e., methods with a concrete 
implementation). As traits are composed, required methods by one trait 
should be provided by another trait to complete an object. If two traits 
provide a same method, then a conflict resolution strategy (e.g., linear­
ization [33]) is used to specify which of the two methods will be used or 
applied first. Objects are said to be complete, if they have no required 
methods left after trait composition. 
Context Traits realizes behavioral variations as traits, that can be 
composed dynamically with ECMAScript objects (internally represented 
as traits) to yield adaptations. As a consequence, at any moment in time, 
every application object can be expressed as a composition of traits. 
Behavioral variations can override, extend, or reify behavior specified 
by any of the application’s objects, by introducing new trait method 
implementations. In Context Traits, behavioral variations are defined as 
methods in a Trait object,5 while contexts are defined as standalone 
first-class objects. Each context object is aware of its associated behav­
ioral variations, and each adaptation has a reference to its associated 
context, the object it adapts, and its behavioral variations, as shown in 
Fig. 4a. Such associations between contexts and adaptations is achieved 
through the Context. adapt(Object, Trait) construct, specifying that a 
Trait object adapts Object whenever Context is sensed active. 
The dynamic composition mechanism of behavioral variations and 
objects consists of two elements in Context Traits: a collection of traits (i. 
e., adaptation components), and a composition policy (i.e., conflict 
resolution mechanism between components). Whenever a context is 
activated or deactivated, the behavioral variations (traits) associated 
with such context are composed with the base object they adapt. Snippet 
5 shows the composition process after a context activation; the process 
in the case of context deactivation is similar. Context activation and 
management is arbitrated by a context manager (cop.Manager). The 
context manager keeps an up-to-date list of behavioral variations asso­
ciated with the currently active contexts (Line 3). To adapt base objects, 
we take into account only those behavioral variations adapting the same 
base object the new variation adapts (Lines 4–6). Finally, these behav­
ioral variations are ordered using the conflict resolution policy defined 
for the involved contexts (e.g., giving priority to the adaptations acti­
vated the latest), extending the original base object with the most 
relevant behavioral variation (Line 11). Fig. 4b  shows an example of 
multiple traits composed with a base POI object in the smart city guide 
application. Take two active contexts WiFi, and Time, which respec­
tively adapt the POI base object with the Trait_WiFi and Trait_Time 
behavioral variations. If we activate the Language context, adapting POI 
with Trait_Language, the resulting composition of POI will be POI =
POI_base d Trait_WiFi d Trait_Time d Trait_Language. 
Snippet 5: Adaptation composition implementation for Context 
Traits. 
Note that multiple behavioral variations may provide an imple­
mentation for the same behavior. This yields a composition conflict, 
where it is unknown which of the implementations should be used in the 
final composed object. In Fig. 4b, the description method is provided by 
two behavioral variations, creating a composition conflict. As with 
traits, a conflict resolution policy can be defined between behavioral 
variations to dictate which of the conflicting methods will be used at run 
time (Line 9 in Snippet 5). A composition policy can be seen as a function 
that, given a set of behavioral variations (traits), provides a linear 
ordering of them. In Context Traits, the default resolution strategy is to 
Fig. 
4. Dynamic 
adaptation 
through 
component 
composition 
with 
Context Traits. 
5 Context Traits uses traits.js, an implementation of traits for ECMAScript 
[34]. 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
8
use the activation age of contexts, which gives precedence to behavioral 
variations associated with the contexts activated most recently. This 
means that in a situation where two contexts offer a behavioral variation 
for a same method, the variation used will be that defined by the context 
activated last. Other composition policies can be defined as required 
using 
the 
cop.Manager.addObjectPolicy(Obj, 
Ctx, 
ordering) 
abstraction. 
ContextL is strongly based on the multiple dispatch mechanism of 
CommonLisp, as discussed before. However, this approach also in­
troduces concepts of mixins to compose adaptations at run time [35]. 
SCROLL [36] uses a similar composition technique to the one presented 
here, as a means to enable dynamic adaptation of application behavior. 
The implementation of SCROLL relies on traits (as a dynamic composi­
tion mechanism), and their own dispatching mechanism to direct 
method calls according to the active roles. 
3.3. Adaptation selection and scoping 
Up to this point we discussed how to dynamically adapt a software 
system’s behavior upon changes to its execution context. Two additional 
aspects important to achieve self-adaptation are: when to select the ad­
aptations to be applied and what is the scope of applicability of these 
adaptations. 
3.3.1. Selection 
Adaptation selection refers to when adaptations are available to the 
system. There are two key moments during self-adaptive systems’ 
execution to select adaptations: (1) whenever a call to the adapted 
behavior is made, or (2) whenever its context gets activated. 
Selection of adaptations during method dispatch (1), requires the 
system to select the most appropriate behavior from all available 
behavioral variations in the system, upon every method call. Given that 
this selection mechanism relies on method dispatch, it is most suitable 
for COP languages implementing a context-dependent method dispatch 
mechanism. Whenever a message is sent, the concrete method imple­
mentation to call is selected among the available behavioral variations 
(i.e., associated to active contexts). This resembles the multiple dispatch 
mechanism (Section 3.2.1). 
Fig. 5a shows the selection of the behavioral variation available 
when the contexts @user, @wifi, and @night are active. The other 
variations are not chosen, as not all of their contexts are active. If there 
are multiple behavioral variations to choose from, as shown in Fig. 5b, 
the behavioral variation selected corresponds to the one deemed most 
appropriate by the method lookup mechanism. Fig. 5b, represents a 
situation where the @child context is active, the selected adaptation is 
the one with the @child, @wifi and @night contexts as the @child 
context is more specific than @user, following the solid line arrow. 
Different policies can be defined to implement the lookup mecha­
nism, ordering behavioral variations according to their appropriateness. 
A common method used for lookup is the specificity of methods’ argu­
ments, as shown in our example. The selected method is the one whose 
arguments are most specific with respect to the parameters in the mes­
sage call. Other methods to select behavioral variations follow the 
delegation links for each of the method’s arguments. Other policies used 
in the implementation of COP languages to select behavioral variations 
include priorities defined in context objects (e.g., ContextL, Subjective- 
C), and context activation timestamps (e.g., Ambience, Context Traits). 
Selection of adaptations at context activation time (2), implies that all 
behavioral variations associated to a context are made available to the 
system as soon as there is a change in a context’s state (i.e., active 
↔inactive). COP languages implemented using a method replacement or 
fine grained composition mechanisms are more suited for selection at 
context activation time. This is because, to implement this selection 
mechanism, there should be an independent entity (a context manager 
[18,20,8]) that orchestrates context activation and deactivation re­
quests, that responds to such requests, assuring the system behavior gets 
adapted appropriately. 
The context activation time selection mechanism is implemented by 
connecting the context sensing component (which obtains sensor in­
formation signaling context activation or deactivation), and the adap­
tations in the system, through the context manager. The context 
manager contains a reference to all adaptations defined in the system (i. 
e., active and inactive contexts with their associated behavioral varia­
tions). Context activation requests are processed by making all behav­
ioral variations associated to that context available in the system. 
Context deactivations are treated similarly by making unavailable all 
behavioral variations associated with that context. For example, using a 
method replacement mechanism, like in Subjective-C, behavioral vari­
ations are made available by replacing method implementations for the 
behavioral variations associated to the context as shown in Snippet 6. 
Methods are selected using the function updateDispatchedMethod, 
which implements method swizzling as shown on Lines 14–21 in Snippet 
4. 
Snippet 6: Selection of adaptations at context activation time in 
Subjective-C. 
Using a context activation time selection technique, all behavioral 
variations associated to a context are installed as soon as the context gets 
activated, therefore, these will be the behavior of the system selected on 
subsequent method calls. 
Fig. 5. Adaptation selection during method dispatch.  
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
9
3.3.2. Scoping 
Scoping of adaptations is closely related to context activation, 
managing the parts of the system that are affected by a context activa­
tion, and the scope of applicability of their behavioral variations in the 
system. Adaptations can be scoped (1) globally to all entities of the 
system, or (2) locally, to a specific system entity (or process). 
So far, we have considered adaptations as taking place globally. 
Whenever contexts are activated, their associated behavioral variations 
become available to all system entities. Whenever contexts are deacti­
vated their associated behavioral variations are no longer available to 
any of the system entities. 
Nonetheless, adaptations can be scoped locally to specific system 
entities such as: execution threads, object instances, or the dynamic 
scope of execution blocks. Locally scoped techniques (regardless of the 
specific entity affected by adaptations) are implemented using the dy­
namic characteristic of the language for dispatching the system’s 
behavior. In this case, the system must maintain an oracle (e.g., context 
manager) managing the references to the local entities to be adapted. 
As an example implementation of locally scoped contexts we use 
Subjective-C, which allows adaptations to take effect on specific 
execution threads. To manage local activations to a thread, the context 
manager maintains a dictionary for each thread, containing all context 
activations and deactivations for each specific thread. Local adaptations 
are triggered by a special construct specifying a context to activate/ 
deactivate, and an execution thread to adapt, @activate(ctx in thread) 
and @deactivate(ctx in thread), respectively. This is processed by the 
context manager as shown in Snippet 7. Since different threads may 
request to modify a context’s state (i.e., active or inactive) concurrently, 
activations and deactivations are organized using a synchronous queue 
system for each thread, processing the requests one by one. The first step 
of the activation process is to generate the activation action for the 
context (Lines 3–5). The second step is to retrieve the activation queue in 
order to add the new activation to it (Lines 6–12). Finally, the activation 
action created in the first step is added to the queue (Line 15), and the 
behavior is updated with the new behavioral variations, using the 
context activation time selection technique, and the method swizzling 
replacement mechanism. 
Snippet 7: Thread specific adaptations in Objective-C. 
Similar to the local scoping of adaptations to execution threads, other 
COP languages scope adaptations to the lexical scope of the execution 
blocks in which contexts are activated (e.g., ContextL), or to particular 
object instances (e.g., EventCJ [37], ContextJS [38], and Context Traits). 
4. Evaluation 
Section 3.2 presents three different dynamic behavior composition 
mechanisms for the implementation of internal adaptation engines from 
a COP language perspective. Additionally, in Section 3.3 we discussed 
some trade-offs regarding the adaptation selection mechanism depend­
ing on the chosen composition mechanism. 
This section presents a thorough evaluation of the different imple­
mentation mechanisms to assess their applicability as a viable alterna­
tive to foster self-adaptive systems. The proposed evaluation analyses 
the expressiveness, modularity, and performance of COP approaches 
versus the use of more direct implementation techniques to realize ad­
aptations using internal adaptation engines in self-adaptive systems. 
Expressiveness is evaluated by comparing the implementations, pro­
vided by the authors, of the smart city guide case study using the three 
COP languages representatives of the techniques discussed in Section 3, 
and corresponding implementations using the strategy design pattern in 
each base language, as exemplars of internal adaptation engines. For 
each of these implementations we compare the overall system size 
measuring the Lines of Code (LOC), as well as the percentage of code 
corresponding to the application logic, adaptation logic, and adaptation 
management concerns as a measure of developer effort in developing 
each of the concerns. Additionally, we evaluate the modularity of the 
implementations (i.e., how independent or scattered is the adaptation 
logic from the application logic) to observe if COP implementations do 
indeed satisfy the desired characteristics of self-adaptive systems. Per­
formance is evaluated using a mini-benchmark to compare each of our 
COP and native implementations. First we evaluate the performance of 
each COP implementation against a more direct implementation of a 
selfadaptive system (using if-statements or the strategy design pattern). 
Second, we compare the performance of the different adaptation selec­
tion mechanisms offered by the COP language implementations. The 
purpose of this evaluation is to observe if COP approaches can scale to 
the size of real-world self-adaptive applications (e.g., smart city appli­
cations), and to evaluate the trade-offs for the applicability of the 
different techniques. 
All experiments were performed on a machine with a 2.8 GHz Intel 
Core i7 quad processor, 16GB RAM, running on OSX10. The COP lan­
guages used for the evaluation were taken from our prior experience in 
developing self-adaptive systems, and are representative of existing COP 
languages and techniques (cf., Section 5). Ambience [17] is used as a 
language featuring context-dependent method dispatch, Subjective-C 
[18] is representative for the method replacement mechanism, and 
Context Traits [20] exemplifies finegrained composition mechanisms. 
The host languages for each of these representative languages are, 
respectively: Common Lisp, Objective-C and ECMAScript. 
4.1. Expressiveness and modularity 
The purpose of evaluating the expressiveness of internal adaptation 
engines is to support our claim that, when appropriately designed and 
implemented, these approaches are modular, concise, fine-grained, and 
understandable. We can distinguish three main concerns in the devel­
opment of self-adaptive systems: application logic (■), adaptation logic 
(■), and adaptation management (■). Application logic refers to all code 
required to implement the system’s main functionality. Adaptation logic 
refers to the functionality to define adaptations in the system –that is, 
behavioral variations and their associated contexts. Finally, the adap­
tation management concern refers to the functionality needed to 
orchestrate adaptations as they are introduced to, or withdrawn from 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
10
the system. Our hypothesis is that COP languages limit the amount of 
adaptation management needed, and that they better separate the appli­
cation logic from the adaptation logic, reducing the effort required to 
introduce adaptations in a software system. 
In this section we compare the expressiveness of self-adaptive sys­
tems with internal adaptation engines implemented using the chosen 
COP languages, and those implemented natively in the host languages 
using a common OOP pattern like the strategy design pattern that en­
ables the modification of behavior at run time. In the evaluation we 
focus on the conciseness and granularity of adaptations measuring the 
effort required to implement the smart city guide case study as the LOC 
used for each concern. We compare the two versions of the case study, 
for each of the languages and their underlying implementation tech­
niques.6 Additionally, we measure the modularity and understandability 
of the case study taking into account how cleanly separated are the 
application, adaptation, and management concerns. 
For each of the chosen languages, code snippets 8–13 show each of 
the three concerns in the implementation of the Engtish context for the 
smart city guide, and the associated behavioral variation of the name 
functionality for POI objects. The dotted lines in each snippet corre­
spond to different modules in which the desired functionality is 
implemented. 
From these snippets we observe how the three concerns in the 
implementations based on the strategy design pattern (Snippets 8, 10, 
12) are more scattered across the different modules, than in the case for 
their corresponding COP counterparts (Snippets 9, 11, 13), which 
respect module boundaries more strictly. This gives a first indication 
that the COP implementations are more modular and maintainable.7 
Snippet 8: Strategy-pattern adaptation in Common Lisp 
Snippet 9: Language adaptation in Ambience 
Snippet 10: Strategy-pattern adaptation in ECMAScript 
Snippet 11: Language adaptation in Context Traits 
6 All implemented versions of this case study are available at: https://github. 
com/ncardozo/SmartCityGuide  
7 The term scattering stems from Aspect-oriented Programming [39], and 
refers to the implementation of concerns of which the code is spread out over 
multiple modules. Such concerns affect the implementation of multiple mod­
ules, which is bad for modularity. 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
11
Snippet 12: Strategy-pattern adaptation in Objective-C 
Snippet 13: Language adaptation in Subjective-C 
The COP implementations highlight three properties that evidence 
the expressiveness, understandability, evolvability and maintainability 
of COPbased adaptation engines: (1) The signatures of behavioral vari­
ations are the same as for the definitions of the base behavior (e.g., name 
()). That is, it is not required to introduce additional infrastructure for 
the definition of behavioral variations, which we remark as a particular 
advantage of expressing adaptations using COP; (2) The definition of the 
Engtish adaptation does not involve the direct modification of any 
application logic. Rather, it is implemented as an independent module. 
This opens up the system to dynamic behavior adaptation, as new or 
updated functionality can be introduced as independent context-specific 
adaptations/modules. This improves system maintainability, as main­
tenance tasks are local, not requiring modification of the adaptation or 
application logic across already existing modules. (3) The modular 
approach to define adaptations (i.e., declaring them in independent 
implementation modules from the application logic) induces a better 
separation of concerns between the base and adaptation logic. 
Additionally, comparing implementations we note that the COP- 
based implementations are often more concise (less LOC), more 
modular and finer-grained than those using pattern-based implementa­
tions. This can be explained by two phenomena. (1) First, the difference 
between the two implementation approaches comes from adaptations’ 
modularity. In the strategy pattern implementations, the variation 
associated to the English context is defined by a new system module, 
PoiEN, extending the original Poi object through a hierarchical relation 
(i.e., in Objective-C the inheritance relation to the BasePoi object). The 
definition of the contexts associated to behavioral variations are global 
and do not require the definition of any additional objects. All contexts 
are defined in the same module. As no additional base objects are 
required in the definition of adaptations using COP languages, the ad­
aptations themselves are introduced at a finer level of granularity (i.e., 
methods). (2) Second, using a pattern-based internal adaptation engine, 
the management of adaptations requires the definition of an additional 
module to relate all adaptations with the base object. Additionally, 
adapted objects’ application logic is polluted, adding properties and 
behavior not inherent to them. In contrast, COP languages manage ad­
aptations internally, hiding the intrinsic details of adaptation in­
teractions to developers. The system logic only requires to use the 
context activation and deactivation API offered by the language. Such 
characteristics make these approaches for internal adaptation more 
modular and understandable, as all (and only those) concerns related to 
an object’s behavior are encapsulated within the object itself, while all 
adaptation concerns are encapsulated in context objects, behavioral 
variations, and the adaptation manager (in different modules). 
Fig. 6 shows the percentage of LOC for the application logic, adap­
tation logic, and adaptation management concerns for each of the six 
implementations of the smart city guide. The figures exhibit the 
Fig. 6. LOC percentage dedicated to each concern in the smart city guide 
application. 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
12
development effort required to implement each of these three concerns 
of self-adaptive systems.8 
Fig. 6 (6a, 6b, 6c) shows a clear reduction in the percentage of code 
related to the adaptation management concerns across all languages. In 
the case of Subjective-C, in Fig. 6c, the improvement of the adaptation 
management logic is less pronounced as this language uses additional 
definitions for context dependency relations, not present in the other 
languages. This increases the amount of adaptation management 
required. Nonetheless, context dependency relations are defined 
through a DSL [18], and therefore the effort for developers is reduced. 
Note, however, that the code of the DSL is not taken into account in the 
LOC measurement, we only take into account the final Subjective-C 
code. The figure also indicates an increase in the percentage of appli­
cation logic and a decrease in the percentage of adaptation logic when 
using COPbased approaches. This is due to the increased modularity and 
reduced tangling of application and adaptation logic, the implementa­
tion of the adaptation logic gets much more concise, thus increasing the 
overall percentage of application logic correspondingly. This suggests 
that the use of well designed internal adaptation engines, improves the 
development of self-adaptive systems by reducing the size of the adap­
tation logic and delegating the complexity of managing adaptations to 
the adaptation engine. This helps developers to focus on the main 
application logic. For both Ambience and Context Traits, we observe and 
improvement between 8% and 17% in the code base dedicated to the 
application logic together with its related adaptations. In the case of 
Context Traits, we note a large reduction in the adaptation management 
code, with a slight increase in the percentage of adaptation logic. Such 
increase is due to the underlying infrastructure (i.e., traits) used to define 
behavioral variations. 
A final observation from Fig. 6 is that, apart from the case of 
Ambience (6% increase with respect to CLOS), the total LOC of the 
system decreases by more than 10% for the COP implementations, 
pointing to a more concise implementation that is easier to understand, 
maintain, and evolve (especially taking into account that the imple­
mentation becomes more modular and contains less adaptation man­
agement code). 
With the evaluation of the expressiveness of COP approaches, we can 
conclude these approaches are beneficial to realize self-adaptive sys­
tems, that are concise and maintainable, as opposed to common belief 
about these approaches. 
Fig. 7 shows our evaluation of the modularity between the different 
self-adaptive implementations of the smart city guide case-study. The 
figure indicates the amount of tangling in the definition of the appli­
cations between our pattern-based and COP based implementations. 
Here we show the number of classes in which each adaptation concern is 
tangled. The more adaptations a class is intertwined with, the less 
modular the code is. In the case of Objective-C, 5 classes implement a 
single adaptation, but there are also classes tangled with 5 or 6 different 
adaptations. Similar things happen for the amount of tangling that can 
be observed for both Common Lisp and ECMAScript where only a few 
adaptations are not tangled over multiple classes, but several are tangled 
over multiple classes. In all implementations, we identify 1 class tangled 
with 12 different adaptations. This class corresponds to the context 
manager, where all contexts and the conditions for their activation are 
defined. In general however, the corresponding COP implementations 
present less tangling. In the case of Subjective-C and Context Traits in 
particular, there is a significant increase in the number of modules with 
only one adaptation, showing that in these cases we achieve near-perfect 
modularity as nearly all of the adaptations are contained in an 
independent module. 
We can thus conclude that COP-based internal adaptation engines do 
improve the system modularity and reusability. 
4.2. Internal adaptation engines performance 
We now turn our attention to a performance evaluation of each of the 
language implementations, based on two criteria. First, we compare the 
overall performance of each of the COP-based internal adaptation en­
gine implementations against adaptations implemented directly within 
the host programming language. Our objective is to evaluate that COP- 
based implementations do not deteriorate performance at scale. Second, 
we compare the performance of the different selection mechanisms for 
behavioral variations. The objective of that evaluation is to present the 
performance overhead of the different approaches to select behavioral 
variations so that the most appropriate one can be chosen for a partic­
ular type of self-adaptive system. 
4.2.1. COP vs native adaptation implementations 
To compare the performance of COP approaches and internal 
adaptation engines we use a mini benchmark [18]. The purpose of the 
benchmark is to evaluate the impact of using behavior variations with 
the different adaptation strategies and selection mechanisms. The 
benchmark consists of calling a test method repeatedly within different 
contexts (all specializing the same test method), as specified in Snippet 
14. 
Snippet 14: behavioral variations mini-benchmark in Subjective-C. 
The benchmark measures the time it takes to activate one out of a set 
of possible contexts, call the test method 100 times for each context 
activation and then deactivate that context. The performance of these 
method calls is measured for context sets of ten different sizes (i.e., 10, 
50, 100, 500, 1000, 2500, 5000, 10,000, 25,000, and 50,000 contexts). 
Each instance of the benchmark (i.e., calling the test method for a 
number of contexts) is executed 10 times.9 
Fig. 8 shows the results for our three COP language implementations 
(i.e., Ambience, Context Traits, and Subjective-C). We compare the 
benchmark results for each of these COP implementations (▴) with a 
native implementation that specializes behavior directly by means of if- 
statements (■), and an implementation that makes use of the strategy 
design pattern (●). 
The results in Fig. 8 show the average time (in logarithmic scale) over 
10 benchmark runs. Note that each graph shows the largest context set 
size for which at least one implementation terminates successfully. The 
if-case implementation yields an error in Objective-C and Common Lisp 
when running 10,000 if-cases, while it took ECMAScript 5000 if-cases to 
8 The percentage of application logic is significantly higher for the Objective- 
C and Subjective-C implementations, as these implementations include the full 
user interface, to display the application on a mobile phone. This code was 
simplified in the other implementations by using a text-based interface to 
interact with users. 
9 All benchmarks results are available at: https://github.com/ncar 
dozo/CopPerformanceEvatuation 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
13
run into an exception. The strategy implementation throws an error in 
CLOS with 25,000 strategies. The COP implementation throws an error 
in Ambience with 5000 contexts. The Subjective-C implementation is 
the only implementation to finish all cases. 
Fig. 8 illustrates the performance cost of using (many) adaptations. 
This cost is due to the additional step for the introduction and with­
drawal of adaptations required in such approaches. In all cases, for a 
small number of adaptations, the ifcase implementation is the most 
performant. However, as the number of adaptations increases if-cases 
get outperformed by the strategy and COP implementations (except 
for the case of Ambience), as the number of required conditional checks 
increases. We also observe that the strategy-based implementation 
eventually performs best for all three implementations. This occurs 
because of the unique combination between fixed dependencies and 
dynamic method forwarding used in this pattern. At the beginning of a 
run using the strategy design pattern all dependencies between objects 
are known and available to the system (similar to the dependencies 
generated with if-cases). At run time, only one of these dependencies is 
used, changing the strategy globally in the application, which gives 
direct access to the behavioral variations implemented in such a strategy 
(similar to the global selection mechanism in COP). In contrast, if-cases 
need to be re-checked for all possibilities for every method call which 
explains why these implementations have a higher run-time perfor­
mance overhead. 
From all COP implementations, Context Traits offers the best per­
formance, albeit a factor 10 slower than its corresponding strategy 
pattern-based implementation, while still providing the added value of 
being more flexible and modular regarding the definition and intro­
duction of adaptations. Moreover, we note from our implementations 
that both the Context Traits and Subjective-C implementations are able 
to finish the benchmark, while the other internal adaptation engine 
implementations are not always able to complete the benchmark. There 
is a significant performance impact of COP approaches. While this ap­
proaches are still able to work properly in scenarios that excede the 
number of adaptations in real-world self-adaptive, more research in 
improving their performance is required. 
4.2.2. Selection mechanisms’ performance 
From our simple benchmark we can observe that the type and 
domain of self-adaptive systems may influence the decision of what 
implementation technique or language best to use. In particular, this 
benchmark evaluates a scenario where method calls occur more 
frequently than context changes. As such, it favors COP approaches 
implementing a context activation time selection mechanism, like the one 
in Context Traits or Subjective-C. With such a mechanism, all behavioral 
variations are enacted as soon as there is a context change that triggers 
them, making these behavioral variations readily available as soon as 
they are called, with no additional dispatching. Domains in which the 
context changes are more frequent than the operations within, benefit of 
a method call selection mechanism, like the one in Ambience, in which 
the behavioral variation is chosen only when they are needed. 
4.3. Discussion of the results 
We now discuss the results of the different COP approaches and their 
underlying techniques, as explored in this paper. This section puts into 
perspective the analysis of the appropriateness of these approaches as a 
means to implement effective internal adaptation engines for self- 
adaptive systems discussed in Section 4.4. 
With respect to the modularity evaluation, we observe that the ap­
proaches with a better separation of concerns are those of Ambience 
(context-dependent method dispatch) and Context Traits (fine-grained 
composition), while SubjectiveC (method replacement) still presents 
some crosscutting concerns. When evaluating the expressiveness of 
these two approaches, we observe, that there is no conclusive winner, 
and both approaches present a similar improvement with respect to the 
non-COP-based implementations. The context dependent method 
dispatch mechanism requires more attention to context activation and 
deactivation, as well as the focus on the adaptation logic, while the 
impact of these aspects for the finegrained composition method is a bit 
lower. 
Adaptations can be realized by coupling the adaptation logic with 
the main application logic, for example, through if-cases or the use of 
software design patterns. Nonetheless, the performance evaluation in 
Section 4.2.1, shows how the design pattern-based implementations 
outperformed the other two implementations. The if-case implementa­
tions were the most problematic in most cases, as their performance 
decreases rapidly across all languages, not being able to complete the 
benchmark execution due to memory overflows. The performance of 
COP languages also decreases rapidly in the case of Ambience (context- 
dependent method dispatch) and Subjective-C (method replacement). 
Such poor performance may be due to the underlying structures and 
algorithms used for each language. Ambience relies in the C3 algorithm 
to resolve the method called taking into account the contexts. As the 
amount of contexts increases, the time to execute the context change 
does as well. As similar phenomenon occurs in Subjective-C, as the 
number contexts increases, the time to activate and deactivate the 
context does so as well, as it is necessary to go through all contexts to 
detect the method to execute. The case of Context Traits (fine-grained 
composition), however, does not exhibit a significant performance 
decline as the composition of the adapted method is executed directly on 
the activated traits, therefore the number of contexts in the system is not 
relevant. When managing a small set of contexts, is better to opt for a 
method replacement or context-dependent method dispatch approach. If 
Fig. 7. Density of tangled adaptation concerns per class.  
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
14
the number of contexts in the system increases, a fine-grained compo­
sition method should be preferred. 
In addition to the aforementioned characteristics, we can also 
consider the type of system to implement in order to choose the most 
appropriate approach. As mentioned in Section 4.2.1, if adaptations are 
expected to take place more frequently than method calls, then a method 
dispatch selection mechanism may be preferable. If the opposite is the 
case, an adaptation time selection mechanism should be preferred. The 
advantage of internal adaptation engines, as conceived by COP lan­
guages, is that both methods could be combined into a single adaptation 
engine [38,40,41]. 
4.4. COP as an implementation of self-adaptive systems 
We now analyze the self-adaptive properties that COP-based internal 
adaptation engines exhibit, and discuss how these properties are sup­
ported by the results from our evaluation. 
Adaptation engines render software systems smart, open, and cus­
tomizable by enabling dynamic introduction and withdrawal of behav­
ioral variations in response to changes in a system’s internal state or 
surrounding environment. This paper advocates internal adaptation 
engines by presenting COP approaches implemented using different 
techniques that offer better software engineering characteristics (e.g., 
modularity, granularity, conciseness, and understandability) in the 
design and implementation of adaptive systems, over other traditional 
internal adaptation engine implementations. The appropriateness COP- 
powered internal adaptation engines is illustrated through the multiple 
implementations of our smart city guide case study. 
From the expressiveness evaluation in Section 4.1, we observed that 
COP-based language implementations provide better modularity than 
the implementation based on design patterns, as they reduce the scat­
tering and tangling of adaptations across modules, without the addi­
tional architectural footprint. 
COP also renders self-adaptive systems more concise and under­
standable by hiding the complexity of defining and managing adaptions 
inside the internals of the adaptation engine (i.e., the programming 
language). The decoupled definition of adaptations (in contexts and 
behavioral variations) also enables the definition of very finegrained 
adaptations (up to the level of individual methods), as opposed to the 
component-level adaptation normally used in self-adaptive systems. 
Three properties of self-adaptive systems are not explicit in our 
evaluation as they do not pertain the implementation of COP languages, 
but are intrinsic properties COP languages provide. The extensibility 
provided by internal adaptation engines can be considered an extension 
of the basic adaptation process. COP-based adaptation engines have 
been used to extend systems’ functionality through adaptations, which 
render them (1) highly-available, as the system does not need to be stoped 
to incorporate new features or bug-fixes, and (2) resilient, as COP lan­
guages, independent from their implementation, can manage the 
interaction between adaptations to avoid undesired behavior [9]. 
As a consequence, COP-based language implementation techniques 
for internal adaptation engines are proven flexible, modular, and reusable 
for developing a wide range of self-adaptive systems. 
4.5. Threats to validity 
In this section we discuss the threats to the validity of our evaluation. 
Threats to external validity refer to the generalization of the results 
from our evaluation. We explore the expressiveness, modularity, and 
performance aspects for the studied implementation techniques to 
realize COP languages. The evaluation of these aspects offers a clear 
view about the differences and similarities of the different imple­
mentation techniques. Such evaluation can be used to assess the 
appropriateness of the implementation techniques for a given base 
language or application domain. Note, however, that the evaluated as­
pects focus on the implementation issues of representative COP lan­
guages. Other characteristics of the languages could be used to assess the 
appropriateness of a COP language for a given domain [42]. Such 
characteristics could be used to complement our evaluation and offer 
more informed decisions on the implementation of COP languages. 
Threats to construct validity refer to the cases in which the evaluation 
is not exhaustive or selective enough. In our case, we evaluate the 
expressiveness and modularity of the system using the implementation 
of a large case study. The system implementations were performed by 
the paper authors, who have experience in building context-aware sys­
tems with the languages presented in the paper. A broader empirical 
study with different types of developers implementing case studies from 
different application domains, could confirm our results or make the 
difference between the language implementations more clear. 
Additionally, our benchmark evaluation for both the scale of COP 
performance with its internal adaptation engine counterparts, and the 
COP selection mechanisms lets us observe the behavior of COP as an 
internal adaptation engine at a large scale. Even though the presented 
Fig. 8. Performance comparison between all COP-based implementations.  
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
15
benchmarks are simple, they scale the amount of available adaptations 
and behavioral variations well over known selfadaptive systems exem­
plars.10 While more complex benchmarks could be executed, our initial 
evaluation, does support our hypothesis about the usefulness of internal 
adaptation engines. Moreover, it posits COP approaches as a viable 
candidate to realize self-adaptive systems. 
5. Related work 
Aside from the techniques to implement internal adaptation engines 
presented in this paper, there are other implementation mechanisms 
using dedicated languages or compiler extensions, to enable dynamic 
adaptation. Nonetheless, the implementation of these internal engines 
follow similar patterns as the ones described in Section 3. Below, we 
provide a comprehensive list of different techniques used to implement 
COP languages, giving pointers to their specific implementations for 
interested readers. This section follows the structure of Table 1, where 
we discuss first techniques most related to COP languages that fit 
completely (marked as in the table) within the categories given in Sec­
tion 3, or use a combination of the techniques described in Section 3 
with other techniques outside the ones explained in this paper (marked 
as 
in the table), and other possible approaches (named 
in the last 
column of the table) The second section of Table 1, and of this discus­
sion, presents other approaches that can be used to realize internal 
adaptation engines using programming language approaches other than 
COP. 
Aspect-oriented Programming (AOP) introduces a dynamic code 
augmentation technique that can be used to achieve run-time adapta­
tions to the surrounding environment [53]. AOP enables the augmen­
tation of an application’s base code by associating new behavior (i.e., 
advices) with specific program points (i.e., join points). AOP can be used 
to dynamically introduce new behavior into a system, similar to the way 
the method replacement mechanism works. That is, at run time, the 
behavior to execute depends on which advices can be applied to join 
points in the base code. Advices typically get woven into the system at 
aspect-weaving time (before execution), but some AOP compilers can 
enable the introduction of advices at run time, hence affecting the sys­
tem’s behavior dynamically [54,55]. 
To implement a COP-based internal adaptation engine with AOP two 
things are required: a translation of COP concepts to an aspect language 
(to augment the code), and a manager to dispatch the behavior to the 
correct implementation. In this process, specialized adaptation ab­
stractions, context declarations, and transition rules are translated to 
advices, pointcuts, classes, and methods in the aspect language. 
behavior variations can be made available to the system by introducing 
advices dynamically, using dynamic aspect languages such as CaesarJ 
[56]; or by implementing alternative method dispatch mechanisms as a 
technique to drive adaptations [57] (similar to the one presented in 
Section 3.2.1). The most prominent implementations of COP languages 
using AOP as an underlying thechnique are: JCop (an extension of 
ContextJ) [44,58], and ServalCJ (formerly known as EventCJ) [45,37, 
59]. Both of these implementations extend the abc compiler [60] with 
their own dispatch mechanism. Other implementations, like the one in 
ContextS [43], extends Squeak/Smalltalk based on the use of meta­
classes in AspectS. In particular this last approach offers a mixture of the 
context-dependent method dispatching and the method replacement 
techniques. 
Predicate dispatch is an alternative to the context-dependent dispatch 
mechanism presented in Section 3.2.1. Predicate dispatch relies on the 
idea that behavioral variations are associated with a predicate 
expressing conditions about the internals of the system or its sur­
rounding environment (similar to their association with contexts, as 
explained before). Whenever a method is called, all predicates of all 
behavioral variations matching the method signature are evaluated, and 
the behavior selected is that corresponding to valid predicates. If mul­
tiple predicates are valid at the same time, they are executed in some 
order, for example by specificity of the method arguments. Predicate 
dispatch mechanisms have been explored in COP languages for the 
adaptation of group behavior in distributed systems in Lambic [24], and 
the adaptation of reactive systems in Flute [25]. 
Structure modification Adaptation of a system’s behavior can also be 
achieved by modifying the internal structure of the system itself. In 
programming languages like Erlang, an application’s behavior is struc­
tured as a supervision tree consisting of workers (the tree leaves) 
monitored by a set of supervisors (internal nodes). Adaptations are 
realized by dynamically binding new behavior to the supervision tree (as 
new tree leaves; the structure of supervisors does not change at run 
time). This dynamic binding process is supported by an additional 
context ADT structure managing interactions between adaptations. 
Specifically, when two adaptations for a same behavior are bound to the 
system, these are ordered hierarchically in the context ADT. The 
behavior observed in the application is given by the selection of the 
adaptation most specific in the context ADT. This approach has been 
used for concurrent systems, supported by the ContextErlang language 
[46,61]. 
Other approaches have been suggested for the implementation of 
dynamic adaptations from a programming language perspective. Similar 
to Flute, other approaches to enable reactive adaptation to the context 
have been proposed [62,63,64]. behavior modifications in these models 
follow those described in this paper (the current implementations are 
based on AOP solutions), with the additional feature of reacting 
promptly to context activation, through the use of signals. 
The role-object model [65] introduces a new modularization strategy 
for developing software systems. In this model, objects are defined and 
augmented according to the different roles they play during the system’s 
lifespan. At run time, objects change roles dynamically, adapting their 
state and behavior with respect to their new role. Adaptation of objects 
via roles can be achieved through internal adaptation engines integrated 
within a programming language. Similarly to the approaches described 
in Section 3, the specific mechanisms to realize Role-oriented Pro­
gramming (ROP) depend on the characteristics provided by the under­
lying language, ranging from dynamic binding of new behavior as in 
LyRT [49], run-time composition of objects as in Object Teams [48], or 
method dispatch techniques as in SCROLL [36]. 
Advances in Feature-oriented Programming (FOP) also enable the 
implementation of internal adaptation engines to dynamically introduce 
features. In this paradigm, adaptations are defined as features that can 
be loaded and unloaded at run time. The inclusion/exclusion of a feature 
in the system is achieved through method replacement mechanisms as 
described in Section 3.2.2. Such mechanisms are implemented as part of 
rbFeatures in Ruby [47], Phenomenal Gems [19], and RubyCOP, fea­
turebased context-oriented extensions to Ruby [30]. 
Congolo [26] presents an approach very similar to method swizzling, 
exploiting the invokedynamic feature of Java. In Congolo, adaptive 
behavior is incorporated into the running system by dynamic loading 
modules into the JVM. 
Finally, the domain of hot software upgrades also enables the 
adaptation of system behavior at run time by changing objects’ or 
components’ definition in the virtual machine. Usually, these ap­
proaches imply the complete replacement of an object or component by 
an equivalent one with an adapted behavior. Many different mecha­
nisms exist for dynamically upgrading components according to the 
implementation language or technique used. Examples include compiler 
extensions of the JVM as in Java Adaptor [50], using contexts in 
SmallTalk [51], or using Software Transactional Memory (STM) in Java 
[52]. 
The first COP approaches discussed in this section are directly related 
to those presented in Section 3, as AOP can be considered as a 
10 https://www.hpi.uni–potsdam.de/giese/pubtic/setfadapt/exemptars/ 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
16
(reflective) method replacement mechanism, and predicate dispatch is a 
context-dependent method dispatch mechanism. Other approaches use 
different mechanisms, but can also be regarded as a kind of method 
replacement mechanism. Several of the properties highlighted in our 
approaches may also be applicable to these alternative mechanisms. A 
more detailed comparative evaluation (e.g., Cardozo et al. [66] or 
Elyasaf and Sturm [42]) of these approaches would be required to fully 
assess the subset of self-adaptive systems properties they satisfy. 
6. Conclusion 
This paper advocates the use of internal adaptation engines as a viable 
option for the development of context-oriented self-adaptive systems. 
More specifically, we analyze the use of COP languages as a means of 
implementing software systems that can adapt their behavior at run 
time; yielding adaptive software systems that are: smart, open, resilient, 
extensible, highly available, customizable, modular, fine-grained, 
concise, and understandable. COP languages abstract away the adap­
tation logic and management from developers by keeping it internal to 
the programming language, with the advantage, contrary to common 
belief, that adaptation and application logic remain cleanly separated. 
To achieve this, COP languages provide language-level abstractions for 
the definition of adaptations, in the form of contexts and their associated 
behavioral variations, that can be dynamically composed with, or 
withdrawn from, the running system in response to input from the 
surrounding environment. We demonstrate how to attain the afore­
mentioned properties in internal adaptation engines by showcasing their 
implementation in COP languages, through different programming 
language-level mechanisms. The presented implementations are repre­
sentative of a wide range of available implementation possibilities to 
enable run-time adaptation according to the facilities offered by the host 
language: contextdependent method dispatch, method replacement, or 
fine-grained composition. We evaluate the properties of these COP- 
based internal adaptation engines in two ways. (1) First, we conduct­
ed an empirical evaluation of the feasibility and applicability of internal 
adaptation engines at the programming language level by showcasing 
their use in the development of a real-world self-adaptive system, a 
smart city guide. We posit the expressiveness and modularity of COP- 
based adaptation engines, in contrast to a more straightforward imple­
mentation in terms of the strategy design pattern. This evaluation 
highlights the benefits of COP with respect to increasing the 
expressiveness and readability of adaptations and their management, 
and reducing the dependencies between adaptations, as well as their 
scattering across and tangling with the application logic. (2) Second, we 
present a quantitative evaluation using a mini-benchmark to show the 
effectiveness of various COP-based adaptation engine implementations 
by comparing their run-time execution performance with that of more 
straightforward implementations in the host language. Our evaluation 
shows that, while managing to keep the adaptation and application logic 
cleanly separated, COP-based internal adaptation engines still perform 
quite well in highly dynamic environments, putting them in a favorable 
position to realize selfadaptive systems. 
Declaration of Competing Interest 
None. 
References 
[1] M. Salehie, L. Tahvildari, Self-adaptive software: landscape and research 
challenges, ACM Trans. Auton. Adapt. Syst. 4 (2) (2009) 14, https://doi.org/ 
10.1145/1516533.1516538, 1–14:42MayISSN 1556-4665. 
[2] J. Floch, S. Hallsteinsen, E. Stav, F. Eliassen, K. Lund, E. Gjorven, Using 
architecture models for runtime adaptability, IEEE Software 23 (2) (2006) 62–70, 
https://doi.org/10.1109/MS.2006.61. MarchISSN 07407459, http://doi.ieeec 
omputersociety.org/. 
[3] P. Costanza, R. Hirschfeld, Language constructs for context-oriented programming: 
an overview of ContextL, in: Proceedings of the Dynamic Languages Symposium, 
ACM Press, 2005, pp. 1–10, https://doi.org/10.1145/1146841.1146842. October. 
[4] R. Hirschfeld, P. Costanza, O. Nierstrasz, Context-oriented programming, J. Object 
Technol. 7 (3) (2008) 125–151. March–AprilURL, http://www.jot.fm/issues/iss 
ue_2θθ8_θ3/articte4/. 
[5] G. Salvaneschi, C. Ghezzi, M. Pradella, Context-oriented programming: a software 
engineering perspective, J. Syst. Softw. 85 (8) (2012) 1801–1817, https://doi.org/ 
10.1016/j.jss.2012.03.024. AugustISSN 0164-1212. 
[6] IBM, An Architectural Blueprint For Autonomic Computing, IBM Research, 2005. 
Technical Report 3June. 
[7] F. Schreiber, E. Panigati, Context-aware software approaches: a comparison and an 
integration proposal, in: Proceedings of the Italian Symposium on Advance 
Database Systems, SEBD’14, 2014, pp. 175–184. 
[8] K. Mens, N. Cardozo, B. Duhoux, A context-oriented software architecture, in: 
Proceedings of the International Workshop on Context-Oriented Programming, 
COP’16, ACM, 2016, pp. 7–12. 
[9] N. Cardozo, S. Clarke, Context slices: lightweight discovery of behavioral 
adaptations, in: Proceedings of the Context-Oriented Programming Workshop, 
COP’15, ACM, 2015, p. 2, https://doi.org/10.1145/2786545.2786554, 1–2:6July. 
[10] M. Weiser, R. Gold, J.S. Brown, The origins of ubiquitous computing research at 
PARC in the late 1980s, IBM Syst. J. 38 (4) (1999) 693–696. ISSN 0018-8670. 
[11] N. Shadbolt, Ambient intelligence, IEEE Intell. Syst. 18 (4) (2003) 2–3. 
Table 1 
Summary of COP approaches and how they fit into the described techniques.  
Approach 
Contextdependent method dispatch 
Method replacement 
Fine-grained composition 
Other 
ContextL [3]  
Lambic [24] 
Flute [25] 
Congolo [26] 
Phenomenal Gems [19] 
RubyCOP [30] 
FOP 
ContextS [43] 
AOP 
JCop [44] 
AOP 
ServalCJ [45] 
AOP 
ContextErlang [46] 
Structure modification 
rbFeatures [47] 
FOP 
SCROLL [36] 
ROP 
Object Teams [48] 
ROP 
LyRT [49] 
ROP 
Java Adaptor [50] 
Software updates 
SmallTalk [51] 
Software updates 
DuST’M [52] 
Software updates  
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
17
[12] M. Appeltauer, R. Hirschfeld, M. Haupt, J. Lincke, M. Perscheid, A comparison of 
context-oriented programming languages, in: Proceedings of the International 
Workshop on Context-Oriented Programming, COP’09, ACM Press, New York, NY, 
USA, 2009, pp. 1–6, https://doi.org/10.1145/1562112.1562118. ISBN 978-1- 
60558-538-3. 
[13] V. Nallur, N. Cardozo, S. Clarke, Clonal plasticity: a method for decentralized 
adaptation in multi-agent systems, in: Proceedings of the International Symposium 
on Software Engineering for Adaptive and Self-Managing Systems, SEAMS’16, New 
York, NY, USA, ACM, 2016, pp. 122–128. ISBN 978-1-4503-4187-5. 
[14] G. Kasin, Engineering Context-Oriented applications. Master’s thesis, Universit´e 
catholique de Louvain, 2012. June. 
[15] N. Cardozo, S. Gonz´alez, K. Mens, R.V.D. Straeten, T. D’Hondt, Modeling and 
analyzing self-adaptive systems with context petri nets, in: Proceedings of the 
Symposium on Theoretical Aspects of Software Engineering, TASE’13, IEEE 
Computer Society, 2013, pp. 191–198. July. 
[16] B. Duhoux, B. Dumas, H.S. Leung, K. Mens, Dynamic visualisation of features and 
contexts for context-oriented programmers, in: Proceedings of the ACM SIGCHI 
Symposium on Engineering Interactive Computing Systems, EICS’19, New York, 
NY, USA, Association for Computing Machinery, 2019. ISBN 9781450367455. 
[17] S. Gonz´alez, K. Mens, P. Heymans, Highly dynamic behaviour adaptability through 
prototypes with subjective multimethods, in: Proceedings of the Dynamic 
Languages Symposium, ACM Press, 2007, pp. 77–88, https://doi.org/10.1145/ 
1297081.1297094. OctoberISBN 978-1-59593-868-8. 
[18] S. Gonz´alez, N. Cardozo, K. Mens, A. C´adiz, J.C. Libbrecht, J. Goffaux, Subjective- 
C: bringing context to mobile platform programming, in: B. Malloy, S. Staab, 
M. van den Brand (Eds.), Proceedings of the International Conference on Software 
Language Engineering 6563, 2011, pp. 246–265, https://doi.org/10.1007/978-3- 
642-19440-5_15. ISBN 978-3642-19439-9. 
[19] T. Poncelet, L. Vigneron, The Phenomenal Gem: Putting Features As a Service On 
Rails, Universit´e catholique de Louvain, Louvainla-Neuve, Belgium, June 2012. 
Master’s thesis. 
[20] S. Gonz´alez, K. Mens, M. Colacioiu, W. Cazzola, Context traits: dynamic behaviour 
adaptation through run-time trait recomposition, in: Proceedings of International 
Conference on AspectOriented Software Development, AOSD’13, New York, NY, 
USA, ACM Press, 2013, pp. 209–220, https://doi.org/10.1145/2451436.2451461. 
ISBN 9781-4503-1766-5URL, http://doi.acm.org/1θ.1145/2451436.2451461. 
[21] S. Gonz´alez, K. Mens, A. C´adiz, Context-oriented programming with the ambient 
object system, J. Univers. Comput. Sci. 14 (20) (2008) 3307–3332, https://doi. 
org/10.3217/jucs-014-20-3307. ISSN 0948-6968. 
[22] AK. Dey, Understanding and using context, Pers. Ubiquitous Comput. 5 (1) (2001) 
4–7. January. 
[23] L. Salzman and J. Aldrich. Prototypes with multiple dispatch: an expressive and 
dynamic object model. vol.3586, pp. 312–336, 2005. ISBN 9783-540-27992-1. doi: 
10.1007/11531142_14. 
[24] J. Vallejos, S. Gonz´alez, P. Costanza, WDe Meuter, T. D’Hondt, K. Mens, Predicated 
generic functions: enabling contextdependent method dispatch, in: B Baudry, 
E Wohlstadter (Eds.) 6144, 2010, pp. 66–81, https://doi.org/10.1007/978-3-642- 
14046-4_5. 
[25] E. Bainomugisha, J. Vallejos, C. De Roover, A. Lombide Carreton, W. De Meuter, 
Interruptible context-dependent executions: a fresh look at programming 
contextaware applications, in: Proceedings of the International Symposium on New 
Ideas, New Paradigms, and Reflections on Programming and Software Proceedings, 
OnWard’12, Tucson, Arizona USA, ACM, 2012. October. 
[26] B. Maingret, F. Le Mou¨el, J. Ponge, N. Stouls, J. Cao, Y. Loiseau, Towards a 
decoupled context-oriented programming language for the internet of things, in: 
Proceedings of the 7th International Workshop on Context-Oriented Programming, 
New York, NY, USA, ACM, 2015, p. 7. COP’151–7:6ISBN 978-1-4503-3654-3. 
[27] B.C. Smith, Reflection and semantics in Lisp, in: Proceedings of the ACM 
Symposium on Principles of Programming Languages, ACM Press, 1984, pp. 23–35, 
https://doi.org/10.1145/800017.800513. ISBN 0-89791-125-3. 
[28] P. Maes, Concepts and experiments in computational reflection, ACM SIGPLAN 
Not. 22 (12) (1987) 147–155, https://doi.org/10.1145/38807.38821. 
DecemberISSN 0362-1340. 
[29] G. Kiczales, J. des Rivi`eres, DG. Bobrow, The Art of the Metaobject Protocol, MIT 
Press, 1991. ISBN 0-262-11158-6 (hardcover), 0-262-61074-4 (paperback). 
[30] B. Duhoux, K. Mens, B. Dumas, Implementation of a feature-based context-oriented 
programming language, in: Proceedings of the Workshop on Context-oriented 
Programming, COP’19, ACM, 2019, pp. 9–16. 
[31] A. Goldberg and D. Robson. Smalltalk-80: the Language and its Implementation. 
1983. ISBN 0-20111371-6. 
[32] Y. Smaragdakis, D. Batory, Mixin layers: an object-oriented implementation 
technique for refinements and collaboration-based designs, ACM Trans. Softw. Eng. 
Methodol. 11 (2) (2002) 215–255. 
[33] S. Ducasse, O. Nierstrasz, N. Sch¨arli, R. Wuyts, AP. Black, Traits: a mechanism for 
fine-grained reuse, ACM Trans. Program. Lang. Syst. 28 (2) (2006) 331–388, 
https://doi.org/10.1145/1119479.1119483. ISSN 0164-0925. 
[34] T. Van Cutsem, MS. Miller, traits.js: robust object composition and high-integrity 
objects for ECMAScript 5, in: Proceedings of the ACM International Workshop on 
Programming Language and Systems Technologies for Internet Clients, 
PLASTIC’11, ACM Press, 2011, pp. 1–8, https://doi.org/10.1145/ 
2093328.2093330. ISBN 978-1-4503-1171-7. 
[35] B. Desmet, J. Vallejos, P. Costanza, Introducing mixin layers to support the 
development of context-aware systems, in: Proceedings of the European Workshop 
on Aspects in Software, EWAS’06, 2006. August. 
[36] M. Leuth¨auser, U. Aßmann, Enabling viewbased programming with scroll: using 
roles and dynamic dispatch for establishing view-based programming, in: 
Proceedings of the Joint Workshop on ModelDriven Robot Software Engineering 
and View-based Software-Engineering, MORSE/VAO ’15, New York, NY, USA, 
ACM, 2015, pp. 25–33. ISBN 978-1-45033614-7. 
[37] T. Kamina, T. Aotani, H. Masuhara, EventCJ: a context-oriented programming 
language with declarative event-based context transition, in: Proceedings of 
International Conference on AspectOriented Software Development, AOSD’11, 
ACM Press, 2011, pp. 253–264. March. 
[38] J. Lincke, M. Appeltauer, B. Steinert, R. Hirschfeld, An open implementation for 
context-oriented layer composition in ContextJS, Sci. Comput. Program. 76 (12) 
(2011) 1194–1209, https://doi.org/10.1016/j.scico. 2010.11.013. DecemberISSN 
0167-6423. 
[39] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, C. Lopes, J.M. Loingtier, and J. 
Irwin. Aspect-oriented programming. vol.1241, pp. 220–242. 1997. ISBN 978-3- 
540-63089-0. doi: 10.1007/BFb0053381. 
[40] N. Cardozo, S. Gonz´alez, K. Mens, Uniting global and local context behavior with 
context petri nets, in: Proceedings of the International Workshop on Context- 
Oriented Programming, number 3 in COP’12, ACM Press, 2012, pp. 1–3, https:// 
doi.org/10.1145/2307436.2307439, 11 June 2012. Co-located with ECOOP. 
[41] T. Kamina, T. Aotani, H. Masuhara, A unified context activation mechanism, in: 
Proceedings of the 5th International Workshop on ContextOriented Programming, 
COP’13, New York, NY, USA, ACM, 2013, p. 2, 1–2:6ISBN 978-1-4503-20405. 
[42] A. Elyasaf, A. Sturm, Towards a framework for analyzing context-oriented 
programming languages, in: Proceedings of the 13th ACM International Workshop 
on Context-Oriented Programming and Advanced Modularity, COP’21, New York, 
NY, USA, ACM, 2021, pp. 16–23, https://doi.org/10.1145/3464970.3468414. 
ISBN 9781450385428. 
[43] R. Hirschfeld, P. Costanza, M. Haupt, An introduction to context-oriented 
programming with contexts. Generative and Transformational Techniques 
Generative and Transformational Techniques in Software Engineering, 2007, 
pp. 396–407. GTTSE’07. 
[44] M. Appeltauer, R. Hirschfeld, M. Haupt, H. Masuhara, Contextj: context-oriented 
programming with java, J. Jpn. Soc. Softw. Sci. Technol. 28 (1) (2011) 272–292 
(JSSST) on Computer Software. 
[45] T. Kamina, T. Aotani, H. Masuhara, Generalized layer activation mechanism 
through contexts and subscribers, in: Proceedings of the International Conference 
on Modularity, MODULARITY’15, ACM, 2015. March. 
[46] C. Ghezzi, M. Pradella, G. Salvaneschi, Programming language support to context- 
aware adaptation: a case-study with Erlang, in: Proceedings of the International 
Symposium on Software Engineering for Adaptive and Self-Managing Systems, 
SEAMS’10, New York, NY, USA, ACM Press, 2010, pp. 59–68, https://doi.org/ 
10.1145/1808984.1808991. ISBN 978-1-60558-971-8. 
[47] S. Günther, S. Sunkle, rbFeatures: feature-oriented programming with Ruby, Sci. 
Comput. Program. 77 (3) (2012) 152–173, https://doi.org/10.1016/j. 
scico.2010.12.007. MarchISSN 0167-6423. 
[48] S. Herrmann, A precise model for contextual roles: the programming language 
objectteams/java, Appl. Ontol. 2 (2) (2007) 181–207. April. 
[49] N. Taing, T. Springer, N. Cardozo, A. Schill, A dynamic instance binding 
mechanism supporting run-time variability of role-based software systems, in: 
Proceedings of the International Workshop on Live Adaptation of Software 
Systems, LASSY’16, ACM, 2016. March. 
[50] M. Pukall, C. K¨astner, W. Cazzola, S. G¨otz, A. Grebhahn, R. Schr¨oter, and G. Saake. 
JavAdaptor —flexible runtime updates of Java applications. Software: practice and 
Experience, 2012. ISSN 1097-024X. doi: 10.1002/spe.2107. 
[51] E. Wernli, D. Gurtner, O. Nierstrasz, Using first-class contexts to realize dynamic 
software updates, in: Proceedings of the European Smalltalk User Group 
(ESUG’11), 2011, pp. 21–31. 
[52] L. Pina, JP. Cachopo, Atomic dynamic upgrades using software transactional 
memory, in: Proceedings of the International Workshop on Hot Topics in Software 
Upgrades, HotSWUp’12, IEEE, Zurich, Switzerland, 2012, pp. 21–25. June. 
[53] A. Popovici, T. Gross, G. Alonso, Dynamic weaving for aspect-oriented 
programming, in: Proceedings of the International Conference on AspectOriented 
Software Development, ACM Press, 2002, pp. 141–147, https://doi.org/10.1145/ 
508386.508404. ISBN 1-58113-469-X. 
[54] Y. Sato, S. Chiba, M. Tatsubori, Generative programming and component 
engineering, in: Proceedings of the Second International Conference, GPCE 2003, 
Erfurt, Germany, Springer Berlin Heidelberg, 2003. September 22-25, 2003. 
Proceedings, chapter A Selective, Just-in-Time Aspect Weaver, pp. 189–208Berlin, 
Heidelberg. 
[55] A. Villaz´on, W. Binder, D. Ansaloni, P. Moret, Hotwave: creating adaptive tools 
with dynamic aspect-oriented programming in java, in: Proceedings of the Eighth 
International Conference on Generative Programming and Component 
Engineering, GPCE’09, New York, NY, USA, ACM, 2009, pp. 95–98. ISBN 978-1- 
60558-494-2. 
[56] I. Aracic, V. Gasiunas, M. Mezini, K. Ostermann, Transactions On Aspect-Oriented 
Software Development I. Chapter An overview of Caesarj, Springer-Verlag, Berlin, 
Heidelberg, 2006, pp. 135–173. 
[57] P. Costanza, Dynamically scoped functions as the essence of AOP, ACM SIGPLAN 
Not. 38 (8) (2003) 29–36, https://doi.org/10.1145/944579.944587. ISSN 0362- 
1340. 
[58] M. Appeltauer, R. Hirschfeld, J. Lincke, Deaclarative layer composition with the 
jcop programming language, J. Object Technol. 12 (4) (2013) 1–37. 
[59] T. Kamina, T. Aotani, H. Masuhara, T. Tamai, Context-oriented software 
development with generalized layer activation mechanism, Trans. Modul. Compos. 
1 (2016) 3–40. 
[60] C. Allan, P. Avgustinov, A.S. Christensen, L. Hendren, S. Kuzins, J. Lhot´ak, 
O. Lhot´ak, O. Moor, D. Sereni, G. Sittampalam, J. Tibble, abc: the AspectBench 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

Information and Software Technology 143 (2022) 106789
18
compiler for AspectJ, in: R. Glück, M. Lowry (Eds.), Generative Programming and 
Component Engineering, Springer Berlin Heidelberg, Berlin, Heidelberg, 2005, 
pp. 10–16, https://doi.org/10.1007/11561347_2. ISBN 978-3540-31977-1. 
[61] G. Salvaneschi, C. Ghezzi, M. Pradella, ContextErlang: introducing context- 
oriented programming in the actor model, in: Proceedings of International 
Conference on Aspect-Oriented Software Development, AOSD’12, ACM Press, 
2012, pp. 191–202, https://doi.org/10.1145/2162049.2162072. ISBN 9781-4503- 
1092-5. 
[62] T. Kamina, T. Aotani, H. Masuhara, Push-based reactive layer activation in 
contextoriented programming, in: Proceedings of the 9th International Workshop 
on Context-Oriented Programming, COP’17, 2017, pp. 17–21. July. 
[63] H. Inoue, A. Igarashi, A library-based approach to context-dependent computation 
with reactive values: suppressing reactions of contextdependent functions using 
dynamic binding, in: Proceedings of the International Conference on Modularity, 
MODULARITY Companion’16, New York, NY, USA, Association for Computing 
Machinery, 2016, pp. 50–54. ISBN 9781450340335. 
[64] P. Leger, H. Masuhara, I. Figueroa, Interfaces for modular reasoning in context- 
oriented programming, in: Proceedings of the International Workshop on Context 
Oriented Programming and Advanced Modularity, COP’20, 2020, pp. 1–7. July. 
[65] D. B¨aumer, D. Riehle, W. Siberski, M. Wulf, Role Object, Chapter 2,, Addison- 
Wesley, Massachusets, USA, 2000, pp. 15–32. PLoPD4. 
[66] N. Cardozo, S. Günther, T. D’Hondt, K. Mens, Feature-oriented programming and 
context-oriented programming: comparing paradigm characteristics by example 
implementations, in: Proceedings of the International Conference on Software 
Engineering Advances, ICSEA’11, IARIA, 2011, pp. 130–135. October. 
N. Cardozo and K. Mens                                                                                                                                                                                                                      

