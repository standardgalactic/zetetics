Truly Visual Polymorphic Algebraic Data
Structures through Maramaﬁcation
Chide Groenouwe, Jesse Nortier & John-Jules Meyer
Universiteit Utrecht
Information and Computing Sciences
Utrecht, the Netherlands
{c.n.groenouwe|j.j.c.meyer}@uu.nl jessenortier@gmail.com
December 18, 2018
Abstract
This paper presents a so-called maramaﬁcation of an essential part
of functional programming languages such as Haskell or Clean: the con-
struction of fully polymorphic well-typed algebraic data structures based
on type deﬁnitions with at most one type parameter. As such, this work
extends our previous work, in which only a very limited form of polymor-
phism was present [2]. Maramaﬁcation means the design of visual ‘twins’
of existing programming constructs using spatial metaphors rooted in
common sense or inborn spatial intuition, to achieve self-explanatoriness.
This is, among others, useful to considerably reduce the gap between pro-
grammers and non-programmers in the creation of programs, for educa-
tional purposes, for inclusion of non-typical programmers and for invoking
enthusiasm among non-programmers.
1
Introduction
It would be highly beneﬁcial if non-programmers could co-program software
applications.
The Marama-paradigm, as introduced in previous work, is a
paradigm that is intended to considerably reduce the gap between programmers
and non-programmers. The basis of the Marama-paradigm consists of designing
‘twins’ of programming constructs using metaphors rooted in common sense or
inborn intuition, making the constructs almost entirely self-explanatory. This
work has coined the term internal semantics for this purpose: the semantics
of constructs is evident without an external deﬁnition.
This may lower the
threshold for non-programmer participation. Other application areas of mara-
maﬁcation include education and fostering an inclusive society. For example,
some dyslexics may have a latent talent for programming that never surfaces in
a world dominated by textual programming languages. Some authors have ar-
gued that these people would be a great asset to the programmer’s community,
1
arXiv:1812.06197v1  [cs.PL]  14 Dec 2018

because they believe there is a correlation between dyslexia and the capability
to think more creatively than the average.
This work coins the term maramaﬁcation for this design process. In other
words, if such a twin has been designed for a language construct from for example
Clean [1] or Haskell [3], it has been ‘maramaﬁed’.
In the remainder of this
article, the preﬁx ‘M-’ indicates ‘maramaﬁed’, for example, an M-constructor,
is a maramaﬁed constructor.
Related work, among others in the ﬁeld of visual general purpose program-
ming languages, to the best of our knowledge, does not truly and fully employ
this principle of internal semantics. Note that visualisation itself is not equal
to having an internal semantics. Many ‘visual’ constructs occurring in visual
programming languages are not self-explanatory. What is more, most of such
languages do not even visualise most of the programming constructs.
They
are still ‘contaminated’ with many constructs of a textual nature. Typically,
in such programming languages the truly ‘visual’ part consists of boxes con-
nected with arrows, while the content of the boxes contains much textually
expressed programming code, such as textually deﬁned typing information and
data-structures. Hence, these languages require the user to still largely move
within the original not-so-accessible textual programming paradigm. The hard-
est parts to truly capture with internal semantics are, possibly unconsciously,
left in a textual form. In this article, however, we cover such a hard and non-
trivial part.
This paper focusses on a fragment of the ‘maramaﬁcation-challenge’: it
presents a new way to (truly) visually represent fully polymorphic algebraic
data structures (ADSs) as they occur in modern functional programming lan-
guages, and does so in line with the aforementioned paradigm. The design is
modular: it can be adopted straightforwardly into any visual functional pro-
gramming language.
ADSs are designed in such a way that type consistency is entirely forced by
the form of the M-constructs (maramaﬁed constructs). In other words, a user
of these constructs cannot create ill-typed values, simply because the ‘pieces
will not ﬁt’. In this sense, the approach in this paper is genuinely visual: the
semantics of the visual blocks is embodied by their visual structure and spatial
manipulation options, and does not require a deﬁnition by textual or spoken
means. Hence, a beginner using the M-constructs can ﬁnd out how to program
with them, without any prior textual or spoken explanation about how these
constructs work.
Another way to phrase it, is that the semantics of the visualisation of poly-
morphy and datastructures proposed in this paper solely relies on shared human
intuition for manipulation of 3D objects.
In this article, the term spatial necessity is coined for the aforementioned
property of the visual designs, the property that given the laws of mechanics
(as far as they are intuitively understood by the majority of humans) it is only
possible to construct something that is correct. An example of such a widely
shared intuition on which the spatial necessity design paradigm can rely, is that
most people from an already very young age will predict that a ball that is held
2

in the air, and then let lose, will move downward.
The design covers ADSs based on algebraic data type deﬁnitions with at
most one type-parameter (but is easily extensible with any number of type-
parameters), can cope with polymorphic constructors, and can classify a given
ADS polymorphically (through ‘typing statements’).
Section 2 presents the textual languages used to show the textual equiva-
lences of the M-constructs. Section 5 introduces a predecessor to this work:
Madawipol-α: a maramaﬁcation of M-constructors that is already suﬃciently
expressive to deal adequately with recursively deﬁned types [2].
However,
Madawipol-α does not yet support full parametric polymorphism. Section 5
introduces Madawipol-β, an adaptation of Madawipol-α that adds parametric
polymorphism. Section 6 provides deﬁnitions of essential aspects of Madawipol-
α.
It is important to note that this paper explains the constructs primarily
from the perspective of a programming language designer, the targeted readers
of this article. The reader has to keep in mind that the targeted users of the
language, however, will learn how the constructs work by a playful and wordless
exposure to maramaﬁed ADSs or parts thereof only. No textual explanations
will be provided. Moreover, the users of the language will use an interactive
3D-editor. The
static representation in this article, therefore, required some
alternative ways to represent aspects of the design. It is important that the
reader does not confuse these with the actual, and more ‘intuitive’, way the
language will occur to the user.
2
Textual languages
This section presents the textual languages that are used in this article to show
the textual equivalences of the M-constructs presented in this paper. Because
the M-constructs covered in this paper only deal with a fragment of a modern
functional programming language (FPL) such as Clean or Haskell, this article
also deﬁnes a textual language that is (isomorphic to) the relevant fragment of
such an FPL. The language is called Algepoly1. We suﬃce with introducing the
textual languages by example, their semantics as identical to the corresponding
parts of Clean.
2.1
Algepoly1
Example 1 (Algebraic Data Type Deﬁnitions). The following Algebraic Data
Type Deﬁnitions deﬁne a number of algebraic data types:
1 ::WeekendDay = Sat
| Sun
2 ::Bool
= True | False
3 ::Colour
= Red | Blue | Green
4 ::List a
= Cons a (List a) | Nil
3

Note that this paper does not cover a visual counterpart to algebraic data
type deﬁnitions. However, it is important to include them in the textual lan-
guage for explanatory and deﬁnitory purposes.
Example 2 (ADSs). The following is a comma-separated list of ADSs:
1 True, Blue, Cons True Nil, Red,
2 Cons True (Cons True Nil).
In this paper it is important to be able to talk about algebraic data struc-
tures that are still under construction. For this purpose, we add the following
construction.
Example 3 (unﬁnished ADSs). In unﬁnished ADSs not all argument positions
of constructors have been supplied with arguments, for example:
1 Cons _ (Cons True Nil), Cons Red (Cons Green _)
The ‘ ’ stands for an ‘empty spot’. Such an ‘ ’ may only occur at the argument-
position of a constructor application.
This paper also deals with polymorphic constructors. These normally do
not occur in languages such as Clean as ‘stand-alone’ constructors. To be able
to talk about them in isolation, Algepoly1 contains the following constructs.
Example 4. The following statement:
1 Cons:[List Bool]
is in a spoken phrase expressed as “the ‘Cons’ of ‘List Bool’.”. Such a state-
ment only makes sense in the context of an algebraic data type deﬁnition, in
which the constructor has been deﬁned. Lets assume that this algebraic data
type deﬁnition is the one in example 1. Then this statement expresses that
‘Cons’ is the constructor that one would get by substituting ‘Bool’ for the type-
parameter in the given algebraic data type deﬁnition. In this case that would be
the ‘Cons’ with the following type: ‘Bool (List Bool) -> List Bool’. An-
other way to phrase it, is that it is the instance of ‘Cons’ with result-type ‘List
Bool’.
Another instance of ‘Cons’ is
1 Cons:[List (List a)]
“the ‘Cons’ of ‘List (List a)’.” This instance of ‘Cons’ is, clearly, polymor-
phic.
4

2.2
Algepoly1+
For didactic purposes, it turned out to be useful to introduce a slight extension
of the language Algepoly1: Algepoly1+ (the ‘+’ stands for ‘too ﬂexible’). It
allows constructors to have any type, including the most general polymorphic
result-type ‘a’ and non-polymorphic argument-types, or no results or arguments
at all. (Hence, they are reminiscent of generalised algebraic data types [7].)
Note that the language itself is not intended for use in a real language. It is
‘too ﬂexible’ and would lead to type-technical and semantical diﬃculties. It
serves as a way to create ‘minimal examples’ to demonstrate certain behaviours
of M-constructors. Note that the notation of the type is written down in the
opposite order of what is commonly used, which one can witness by the reversed
direction of the arrow. The result type is written down ﬁrst, then the arrow
follows, and ﬁnally the argument types are provided. This has been done for
convenience: the result and the arguments are now in the same order as they
appear when the constructor is applied, both in the textual version as in the
maramaﬁed version.
The following deﬁnes Algepoly1+ by means of examples.
Example 5. The following deﬁnition:
1 Red: Colour <-
deﬁnes a constructor ‘Red’ that has no arguments and result type ‘Colour’.
1 SimpleFemCons: <- Colour
deﬁnes a constructor ‘SimpleFemCons’ that has one argument with type ‘Colour’,
and that does not produce a result.
1 FlexiCons: a <- a
deﬁnes a constructor with one argument with the most general polymorphic
type ‘a’ and a result with the same type. More examples:
1 PolyCons: SimpleType a <- a
2 SimplePairCons: <- a a
3
Madawipol-α by example
Madawipol-α, created in our previous work, is a maramaﬁcation that covers
ADSs based on algebraic data type deﬁnitions with at most one type parameter,
and can cope with a limited form of polymorphic constructors: those without
5

arguments [2].
This section suﬃces with deﬁning Madawipol-α by example,
among other due to space limitations, but also because the successor Madawipol-
β is the focus of this paper. For an elaborate formal deﬁnition of Madawipol-α,
see [2]. Throughout the online version of this document, clicking any image
shows an online high resolution version of it, which can be zoomed into. The
reader is strongly recommended to follow these links to investigate the ﬁgures
in much more detail. The same holds for many textual descriptions. For oﬀ-line
readers there is an additional ‘appendix’-document that contains an enlarged
version of each ﬁgure, either to print or to store locally. It is available from the
same location as this article.
Figure 1 shows examples of the simplest possible ADSs: atomic ADSs. In
particular, note the form of the joints. The values of type ‘Bool’ have the same
joint-form, while ‘Sat’ has another. Every type-constructor has a unique form
associated with it, its type-constructor form. In this case, ‘Bool’ corresponds
with the triangle in the ﬁgure, and ‘WeekendDay’ with the pentagon in the ﬁgure.
(The type-constructor forms have to comply with some additional conditions,
these are covered in [2].) The square form around them is not explicitly part
of the type. It is the alignment square, needed to align joints correctly when
ﬁtting them together.
‘True’
‘False’
‘Sat’
Figure 1: Atomic algebraic data structures. Important: all images are clickable
and lead to zoomable high resolution versions.
To provide examples of molecular ADSs (ADSs with constructors that take
arguments), ﬁg. 2 introduces all M-constructors that belong to the type ‘List
Bool’ and ‘List (List Bool)’. Note that Madawipol-α does not yet support
polymorphism for constructors with arguments.
Therefore, it can only pro-
vide non-polymorphic instantiations of ‘Cons’. M-Nil, however, is polymorphic.
(Note that “M-Nil” is an example of the notation of speciﬁc M-constructors.)
Hence, it can be shared among the diﬀerent instantiations of ‘Cons’. This ex-
plains why there is only one M-Nil in ﬁg. 2.
Note the forms of the three joints of M-Cons:[List Bool]. It has one male
joint, that corresponds with the result-type ‘List Bool’, and two female joints,
one corresponding to the type ‘Bool’, and the other to ‘List Bool’. The circle
corresponds with the type-constructor ‘List’. It is an essential aspect of the
6

design that joint-forms that correspond with a complex type, such as ‘List
Bool’, are compositionally related to their textual form. The 2D projection of
the joint-form along a line perpendicular to the bottom of the joint, is called
the type-form. I.e. it is the 2D form one sees when viewing a joint along a line
of sight that is perpendicular to the bottom of the joint. This is an adequate
abstraction. After all, if one assumes that male and female joints have matching
heights and depths, the only aspect that determines whether they ﬁt is the type-
form. The textual type can be read from the type-form by starting with the
outermost form (skipping the alignment square) and then walking one’s way to
the adjacent one, all the way down to the center form, while reading out loud
the type-constructor that is associated with each form. The reader is invited
to verify that all joints of M-Cons:[List (List Bool)] also comply with this
structure. A polymorphic type, such as ‘List a’, is created by leaving the space
within the innermost type-constructor form empty. The joint of M-Nil is an
example.
Also note the form of the three joints of M-Cons:[List (List Bool)].
‘Cons:[List Bool]’ (2 perspectives)
‘Nil:[List a]’
‘Cons:[List (List Bool)]’ (2 perspectives)
Figure 2: Several M-constructors.
Figure 3 shows a number of molecular ADSs built with the M-constructors
introduced so far. The reader can try to verify that all M-constructors indeed
7

ﬁt together, and lead to a well-typed result.
Madawipol-α is type-safe. Figure 4 gives a simple example. The power of
Madawipol-α however, lies in how it enforces type-safety of more complex types,
such as types that consist of more than one type-constructor, polymorphic types,
and recursively deﬁned types. This is the non-trivial part of the design. With
the compositional translation of textual types into type-forms, as illustrated in
the aforementioned, every type can be translated into a type-form that behaves
type-safely, and that reﬂects the relation between both. We challenge the reader
to create a type-incorrect value with the M-constructors provided so far. For
example, (s)he can try to: join the male joint of M-Cons:[List (List Bool)]
with a female joint of M-Cons:[List Bool] (fails); M-True into M-Cons:[List
(List Bool)] (fails).
The reader can also add the M-constructors of other
instantiations of ‘List a’, such as ‘List (List WeekendDay)’, and then try:
male M-Cons:[List (List Bool)] into the side female joint of M-Cons:[List
(List Sat))] (fails).
Polymorphic types are also type-safe: try ﬁtting M-Nil into the side female
joint of any instantiation of M-Cons (always succeeds); M-Nil into the top
female joint of M-Cons:[List Bool] (fails).
8

A maramaﬁed value of type ‘List Bool’ (3 perspectives)
A value of type ‘List (List Bool)’ (3 perspectives)
Figure 3: Several values with a ‘List’-type.
9

Figure 4: Type-safety: ‘Weekendday’ does not ﬁt into a list of booleans.
[2] contains more examples of Madawipol-α.
4
Polymorphic surfaces
A part of Madawipol-β consists of so called polymorphic surfaces. These surfaces
do not exist as independent objects within Madawipol-β, but are, among other
things, integrated into polymorphic M-constructors. However, for clarity this
section explains the polymorphic surfaces in isolation. The most central part of
the explanations focus on the laws that govern the behaviour of the polymorphic
surfaces. The reader is recommended to ﬁrst try to guess what happens in the
ﬁgures, and after that read the accompanying explanation.
Figure 5 shows a gray surface in the center of which a polymorphic surface
polSurf is attached. (Note that the ﬁgure has to be read as a comic strip.)
polSurf has a side with a red colour (in the ﬁgure at the top-side) and a side with
a blue colour (in the ﬁgure at the bottom-side). To demonstrate the behaviour
of polSurf , a gray cylinder C is moved into it. As can be seen in the ﬁgure,
the part of C that touches polSurf moves downwards with the cylinder. The
part that is not touched by C, however, moves in the opposite direction over
the same distance. polSurf does not tear in the process, and remains attached
to the gray surface. In that sense it behaves as an elastic surface.
10

Figure 5: A comic strip showing a polymorphic surface interacting with a
cylinder, seen from three perspectives
Figure 6 demonstrates mimicking. A gray surface contains two polymor-
phic surfaces: polSurf 1 (left) and polSurf 2 (right). A cylinder C is moved into
polSurf 1. polSurf 2 mimics the behaviour of polSurf 1.
11

Figure 6: Mimicking polymorphic surfaces interacting with a cylinder, seen
from three perspectives
Figure 7 demonstrates that mimicking is conﬁned to polymorphic surfaces
attached to the same object. Each gray surface contains two polymorphic sur-
faces. However, only the polymorphic surface that is on the same gray surface,
mimics the behaviour of the polymorphic surface that receives a cylinder.
12

Figure 7: Two pairs of polymorphic surfaces, interacting with a cylinder, seen
from three perspectives. Each pair is connected to one, separate object.
Figure 8 shows two polymorphic surfaces.
polSurf 1 (left) and polSurf 2
(right).
polSurf 1’s orientation is the opposite of polSurf 2.
One can derive
this from the orientation of the colours: in polSurf 1, red is on top, in polSurf 2
it is on the bottom. polSurf 2 mimics the behaviour of polSurf 1, and because of
its orientation, the movement is also reversed with respect to the gray surface.
Note that this ﬁgure is a natural consequence of the laws already exposed in
previous ﬁgures. It does not introduce any new laws, but is included for clarity.
13

Figure 8: Mimicking polymorphic surfaces interacting with a cylinder, seen
from three perspectives. The polymorphic surfaces are oriented reversed with
respect to each other.
4.1
Diﬀerentiation of polymorphic surfaces
Some terminology is needed for explanations in the rest of this article. If a
polymorphic surface is fully deformed it is diﬀerentiated. The opposite notion
is ‘undiﬀerentiated’. A polymorphic surface always starts in a fully undiﬀer-
entiated state: a perfectly ﬂat surface as indicated in the examples before. A
polymorphic surface can also be partially diﬀerentiated, as will be shown in later
examples. The parts of a polymorphic surface that are diﬀerentiated are called
diﬀerentiated regions. The opposite notion is ‘diﬀerentiated region’. A part
of a polymorphic surface that is diﬀerentiated as a consequence of mimicking
another surface, is called a mimicking region.
If a region of a polymorphic surface is not mimicking another surface, nor
being deformed by an object that is pushed into it then that region is called a
free region. In the examples provided so far, each polymorphic surface started
out as a completely free region, while no free regions were left once insertion of
an object started. Note that the region of the polymorphic surface that moves
in the opposite direction of the regions being touched by the inserted object,
is not a free region either: although it does not touch the inserted object it is
clearly being deformed.
14

4.2
Law: mimicking regions are rigid
A law that is not demonstrated in this article is that mimicking regions of a
polymorphic surface behave like rigid (non-deformable) forms with respect to
the objects onto which it exerts a force. As a consequence, if such a mimicking
region exerts a force onto an undiﬀerentiated region of another polymorphic sur-
face, the latter will start to deform as well and become diﬀerentiated. Another
consequence is that if the other surface is already diﬀerentiated, and does not
have a matching form, the forms will not ﬁt into each other and movement will
halt.
4.3
Law: free regions return to an undiﬀerentiated state
All examples provided thus far, also work in the reverse direction. When objects
are taken out again, the polymorphic surfaces move back to their original posi-
tion. These examples can simply be obtained by reading the comic strips in the
reverse order. The underlying law is formulated as follows: free regions return
to their undiﬀerentiated state. In other words: any region of a polymorphic
surface that is not being pushed by a shape, nor mimicking another surface,
returns to its undiﬀerentiated state.
4.4
Experimentation
Note that a quite extensive experimental study has been carried out to test the
understandability of the laws mentioned in this section among secondary school
students with promising results.
5
Madawipol-β by example
As said, Madawipol-β extends Madawipol-α with complete parametric poly-
morphism, i.e. it also covers polymorphic M-constructors with arguments, such
as ‘Cons:[List a]’.
For clarity, in some of the following examples the correspondence between
parts of the visual and the textual representation is shown. It is essential to note
that these are not put there for deﬁnitory purposes: for a user of Madawipol-β
the semantics is contained in the construction possibilities of the building blocks.
The correspondence is merely put here to provide the reader of this paper, who
is probably well-versed in textual functional languages, a quick insight into the
fact that these visualisations indeed exhibit the same relevant behaviours as
their textual counterparts.
The essential building block of the extension is formed by polymorphic sur-
faces, covered in section 4.
In Madawipol-β, polymorphic surfaces are part of polymorphic M-constructors.
For didactic purposes it easier to ﬁrst illustrate important aspects of how they
15

function within M-constructors in maramaﬁcations of the ‘ﬂexible textual lan-
guage’ Algepoly1+. It allows ‘minimal examples’1 to be more minimal.
For the sake of simplicity and the purpose of this article, the type-constructor
forms in this section have been chosen such that 2D cross-sections provide all
information needed. This simpliﬁes the creation of examples in static 2D media,
such as this article. These cross-sections, however, are not intended as viable
alternatives for the 3D models. Among other things, it is harder to discern
the diﬀerent type-constructor forms in them. For example, the human visual
apparatus will immediately recognise a circle that contains a triangle, as two
separate objects with a distinct form, while the ‘ridges and edges’ in the 2D
cross-sections give it much less to hold on. The users, however, will work with
the 3D models.
To achieve the situation that 2D cross-sections contain all information needed,
ﬁg. 9 redeﬁnes the forms of several type-constructors that have been deﬁned ear-
lier. The latter can be interpreted as viewing a male joint along a line of sight
that is perpendicular to the bottom of the joint. We remind the reader that in
the electronic version of this document, each image contains clickable links that
lead to much higher resolution versions of the image.
‘Colour’
‘Bool’
‘List’
Figure 9: Several type-constructor forms.
Figure 10 provides a cross-sectional view on several M-constructors with
these types. The cross-section is made such that it cuts halfway through each
joint. Note the red and the blue lines indicating the orientation of each poly-
morphic surface. These lines, in reality have no thickness as they are part of
the same surface. As a compromise, these parallel lines are drawn such that
the center of the combined lines aligns with the real line. Speciﬁcally in later
ﬁgures, where M-constructors are joined, and up to four lines stack up, this is
a workable compromise.
In the remainder of this article, the preﬁx ‘M-’ indicates ‘maramaﬁed’. For
1https://en.wikipedia.org/wiki/Minimal_Working_Example
16

example, the M-constructor (maramaﬁed constructor) of ‘FlexiCons’ from ex-
ample 5 is indicated with M-‘FlexiCons’.
Before starting with the elucidating examples, ﬁg. 10 provides an overview
of all M-constructors used in the examples, for later reference.
M-Red
M-SimpleFemCons
M-FlexiCons
M-PolyCons
‘Colour <-’
‘<- Colour’
‘a <- a’
‘SimpleType a <- a’
M-True
M-Cons
M-SimplePairCons
‘Bool <-’
‘List a <- a (List a)’
‘<- a a’
Figure 10: Overview of M-constructors.
Their name and type are written
beneath them.
The rest of this section introduces the behaviours of these M-constructors
by providing examples. It will indicate for each example whether it “introduces
a new law”, or whether it merely “illustrates existing laws”. The latter type of
examples should be perfectly predictable and are, among other things, added
to allow the reader to verify his or her understanding.
17

5.1
Reverse reading of examples
Let the reader be reminded that all examples provided in the following sections
also work in the reverse direction, following the law that has been explained in
section 4.3.
5.2
Law: mimicking polymorphic surfaces (intra-M-constructor
type-propagation)
(Implications of existing laws.) Figure 11 demonstrates type propagation within
a M-constructor, i.e. intra M-constructor type-propagation. Simply by following
the laws of polymorphic surfaces from section 4, and the chosen forms of the
joints, the type propagation takes place as expected in these examples. It ﬁrst
shows an M-FlexiCons (left) and an M-Red (right). The corresponding textual
versions have been deﬁned in example 5. The ﬁxed male joint of M-Red moves
into the (polymorphic) female joint of M-FlexiCons. As expected, the polymor-
phic surface in the male joint of M-FlexiCons mimics the polymorphic surface
that is being manipulated: the one in the female joint. As a consequence of the
inverted orientation of the polymorphic surface of the female joint with respect
to the male joint, the form of the male joint will become the exact inverse of the
female joint when it mimics the latter. The male joint of M-FlexiCons has now
taken the exact shape of the male joint of M-Red. This is perfectly consistent
with the typing information expressed in the textual versions of the construc-
tors, and is a ﬁrst step in illustrating how type-information propagates through
M-constructors. Note that this also partially explains why an undiﬀerentiated
polymorphic surfaces is positioned halfway the joint, and why the polymorphic
surface moves in two directions at the same time.
18

M-FlexiCons:[a<-a] receives M-Red:[Colour<-].
M-SimpleFemCons:[<-Colour] receives M-FlexiCons:[a<-a])
M-SimplePairCons:[<-a a] receives M-Red:[Colour<-]
Figure 11: Comic-strips demonstrating intra-M-constructor type-propagation.
The rest of ﬁg. 11 illustrates that the intra-M-constructor propagation takes
19

place as expected, whether it is propagation from a male joint to a female joint,
from a female joint to a male joint, or from a female joint to a female joint.
5.3
Inter-M-constructor type propagation
(Illustrates existing laws.) Figure 12 shows how type-information propagates
through several M-constructors: i.e. inter-M-constructor type propagation. M-
Red moves into the right M-FlexiCons MFC 1. The polymorphic surface at the
left of MFC 1, mimics the other one of MFC 1. The right polymorphic surface
of MFC 2 (the right MFC 2) touches the changing polymorphic surface, and
responds by following the laws that were introduced in section 4. Therefore,
it gets exactly the same shape as the changing polymorphic surface. The left
polymorphic surface of MFC 2 mimics the right polymorphic surface of MFC 2.
This results in a ﬁnal situation that is, type-wise, in perfect agreement with
the textual counterparts of the M-constructors. The ﬁgure also demonstrates
that mimicking regions of a polymorphic surface act as rigid objects (also see
section 4.2).
20

Figure 12: Two already joined M-FlexiConses receive an M-Red. The result’s
textual equivalent is ‘FlexiCons (FlexiCons Red)’.
5.4
Law: scaling of polymorphic surfaces
(Introduces a new law.) Figure 13 demonstrates scaling of polymorphic sur-
faces. The polymorphic surface at the left (polSurf 2) is smaller than the one
at the right (polSurf 1). As expected, polSurf 2 mimics polSurf 1, however its
vertical size is scaled down. The scaling factor is, in this case, equal to the
ratio between the sizes of both polymorphic surfaces. This scaling process, a
linear transformation to be precise, plays the central role in the maramaﬁca-
tion of the application of type constructors (i.e. creating joints of types such
as ‘(SimpleType a)’ or ‘(SimpleType (List (SimpleType a)))’. For exam-
ple, the joint that corresponds with ‘(SimpleType a)’ consists of an alignment
square (the two outer ‘pins’), the type-constructor ‘SimpleType’ (the inner two
‘pins’), and the type parameter ‘a’ (the scaled down polymorphic surface). This
21

will be explained in more detail in sections 6.2 and 6.3.
Figure 13: ‘PolyCons Red’.
22

5.5
Joining ‘super’- and ‘sub’types
(Introduces a new law.) Figure 14 shows an example of joining polymorphic
surfaces where the female joint is a strict super-type of the male joint.
In
other words, the types are diﬀerent, yet uniﬁable. In the ﬁgure, a female joint
with type ‘a’ is connected with a male joint with type ‘SimpleType a’.
As
one can see, the undiﬀerentiated region of a polymorphic surface that meets an
undiﬀerentiated region of the polymorphic surface of the opposing joint, remains
in an undiﬀerentiated state. The rest of the polymorphic surface takes the shape
of the opposing joint.
(Implications of existing laws.) It also demonstrates that the M-constructors
can fully deal with recursively deﬁned types. (These are types in which a type-
constructor occurs both in the left-hand side and the right-hand side of the alge-
braic data type deﬁnition, such as in the deﬁnition of ‘PolyCons’.) The left-most
joint takes the shape that corresponds with the type ‘SimpleType (SimpleType
a)’. The reader is invited to verify that if yet another M-PolyCons would be
inserted in the right M-PolyCons, it would lead to the left-most joint taking the
form M-‘SimpleType (SimpleType (SimpleType a))’. The notation M-‘Type’
means the type-form of the given type.
Figure 14 introduces an additional law.
‘PolyCons (PolyCons
)’
Figure 14: ‘PolyCons (PolyCons
)’
(Illustrates existing laws.) Figure 15 shows a more complex example of scal-
ing during type-propagation. By inserting M-Red into the righter M-PolyCons
of ﬁg. 15, scaling takes place two times. This results in the left-most joint to take
on the shape that corresponds to the type ‘SimpleType (SimpleType Red)’.
23

‘PolyCons (PolyCons Red)’
Figure 15: ‘PolyCons (PolyCons Red)’
(Illustrates existing laws.)
Figure 16 shows a complex example of type-
propagation. It shows that a “list of lists” is type-safe regarding its construction
possibilities. Assume that the last M-constructor that was joined, is the M-
constructor labelled with ‘1’, an M-Red. It is joined with M-constructor 2, an
M-Cons. The male joint of 2 mimics the female joint that receives the M-Red.
By simply obeying the laws of scaling en mimicking, it takes the form M-‘List
Colour’. The female joint of 3 attached to the latter now takes the same shape.
The other female joint of 3, by means of scaling and mimicking, now takes
form M-‘List (List Colour)’. This propagates further to the female joints
of 5 through 4.
Note that in this process, by simply obeying the laws, the
form scales up again, to take the form M-‘Colour’ in the left female joint of
5.
The reader is invited to verify the following statements by visualisation:
(1) An M-True (see ﬁg. 10) will not ﬁt into the left female joint of 5.
The
same holds for a male joint with form M-‘List a’, M-‘List Bool’ and M-‘List
24

(List Bool)’, or any other form that is not M-‘Bool’. (2) One can remove
M-Red, and replace it with an M-True. (3) If the latter point has been carried
out, an M-True will ﬁt into the left female joint of 5. An M-Red will not ﬁt
anymore. (4) The M-Red can be replaced with an M-Cons. (5) If point (4) has
been carried out, the male joints of 3 and 4 will take the form M-‘List (List
(List a)))’. (6) If point (4) has been carried out, a female joint with form
M-‘List (List (List (List Colour)))’ will ﬁt into the male joint of 3. (7) If
the latter point has been carried out, the female joint of 2 will take the form
M-‘List (List Colour)’.
Figure 16: ‘Cons (Cons Red
) (Cons (Cons
)
)’
The ﬁnal example, ﬁg. 17 shows a cross-section of a full 3D example. It uses
the original type-constructor forms (section 3).
25

Figure 17: M-True into M-‘a’.
6
Deﬁnition and correctness of Madawipol-β
This section deﬁnes essential aspects of Madawipol-β.
It does so in a semi-
formal way, both to save space, and to be more legible for a wider audience.
[2] contains a more formal deﬁnition of Madawipol-α. There is a great degree
of overlap between Madawipol-α and Madawipol-β. A reader that appreciates
additional precision, may therefore be considerably served by the latter article.
The syntax and semantics of Madawipol-β is deﬁned by means of a transla-
tion between Madawipol-β and the textual language (Algepoly1). This way, the
already existing semantics of the textual language is transferred to Madawipol-β.
Note, however, that a mere deﬁnition is not suﬃcient. Madawipol-β should also
exhibit the same relevant behaviours as its textual counterparts: type-safety.
This article suﬃces to support this with the intuitive examples that have been
26

provided so far.
[2] provides a mathematical proof of, among other things,
type-safety of Madawipol-α. This proof could serve as an inspiration for a proof
for Madawipol-β. However, this is beyond this article’s scope. Nevertheless,
section 7 brieﬂy reﬂects on a proof strategy.
6.1
The translation conﬁguration
The translation from Algepoly1 and Madawipol-β is deﬁned recursively on the
structure of Algepoly1. For this purpose, predeﬁned ‘atomic’ translation infor-
mation from Algepoly1 has to be supplied to this translation. This information
is provided in the translation conﬁguration.
The translation conﬁguration consists of the following elements:
1. A set of algebraic data type deﬁnitions ADTDset.
2. The type-constructor mapping: A mapping from each type-constructor
occurring in ADTDset to a type-constructor form.
3. The constructor block mapping: A mapping that maps a given constructor
occurs in ADTDset with a solid 3D object that is the M-constructor in
its rough form: it does not yet contain the joints.
4. The constructor argument-location mapping: A mapping from each con-
structor ADTDset and an argument position, to the location and orien-
tation of the joint that corresponds with the textual argument position.
(For example, it would map the ﬁrst argument-position of ‘Cons’ to the
location and orientation of the joint on the top in ﬁg. 10.)
5. The constructor’s result-type location mapping: A mapping from each con-
structor in ADTDset to the location and orientation of the male joint,
hence the result type of the constructor.
The translation conﬁguration should comply with a number of conditions to be
valid. Some of these are covered in the rest of this section.
The rest of this section explains some core concepts of the translation con-
ﬁguration more precisely. One of these is the way types expressed in Algepoly1
are mapped to type-forms.
6.2
Type-constructor forms
A more precise deﬁnition of type-constructor forms follows now. We revisit ﬁg. 9:
it provides a list of examples, when reinterpreting them as 2D projections of the
joints perpendicularly to the bottom of the joint. The outer squares in this
ﬁgure, the alignment square is not part of the type-constructor form.
Let T be a type-constructor. The type-constructor form Tf of T is a pair
consisting of a rigid part TR and, if applicable, a polymorphic subspace TS:
Tf = (TR, TS). TR is a surface in 2D space. In ﬁg. 9 all gray forms with exclusion
27

of the alignment squares are examples. For referencing purposes, assume that
the origin of this plane is in the center of the alignment square.
If T has a type-parameter, then Tf has a polymorphic subspace. This is a
pair that consists of a polymorphic surface TP and a type-constructor argument
transformation TA. Hence, TS = Optional[(TP , TA)]2. TP is a surface in 2D
space, too. In ﬁg. 9 these are indicated with a red colour. The ﬁgure contains
an example that contains a polymorphic subspace: ‘List a’.
The type-constructor argument transformation TA is a linear transformation.
This transformation is, loosely speaking, used to scale down the argument of
a maramaﬁed type-constructor, so that it ﬁts within its polymorphic subspace.
In ﬁg. 9 this type-constructor argument transformation is simply indicated with
a green square. In the case of ‘List a’, the green square coincides with the
edge of the polymorphic subspace. A precise explanation of type-constructor
argument transformations follows in .
If T does not have a type-parameter, then it does not have a polymorphic
subspace (hence, TS is None).
6.3
Type-forms
Each algebraic data type has a corresponding type-form in Madawipol-α. In
fact, we have already seen some of these in ﬁg. 9: these are all examples of
type-forms of types that contain exactly one type-constructor.
A type-form
also consists of a pair, that contains a rigid part and, possibly, a polymorphic
subspace.
Examples of type-forms of more complex types, such as M-‘List (List
Bool)’, are provided in ﬁg. 18.
2Optional is as ‘Maybe’ in Haskell
28

M-‘List Colour’
M-‘List (List Colour)’
M-‘List (List Bool)’
M-‘List (List a)’
Figure 18: Several type-forms.
Such complex type-forms can be obtained by means of an inductively deﬁned
procedure applied to the type-constructors and type-parameters that occur in
the type. For the procedure, ﬁrst two deﬁnitions are needed that deﬁne how to
scale down an argument of a maramaﬁed type-constructor.
Deﬁnition 1 (type-constructor argument transformation application). Let S
be a subset of the 2D plane, and L a 2D linear transformation. Then L · S is
the transformation of S with L, i.e. the set of all points in S, interpreted as
a set of 2D vectors, transformed by means of L. Moreover, let L′ be another
2D linear transformation. Then L · L′ is the transformation that is obtained by
composing L and L′, hence by ﬁrst applying L′ and then applying L. This is
all ‘just’ standard linear algebra [5].
Deﬁnition 2 (type-constructor argument transformation application to a type-
-constructor). Let L be a linear transformation and Tf a type-form.
Then
L applied to Tf is deﬁned as applying L to all elements of Tf.
More pre-
cisely, let Tf = (TR, (TP , TA)), where TR is the rigid part of Tf, TP its poly-
morphic surface, and TA its type-constructor argument transformation. Then
L · Tf = (L · TP , (L · TR, L · TA)).
These deﬁnitions allows the deﬁnition of typeFormProcedure:
29

Deﬁnition 3 (typeFormProcedure). The procedure typeFormProcedure deter-
mines the type-form for a given algebraic data type. In words, it is deﬁned as
follows. The deﬁnition uses ‘List (List a)’ as a running example.
• Let T be the outermost type-constructor, and Tf = (TR, (TP , TA)) its
type-constructor form. (Example: recursive pass 1: T is ‘List’, recursive
pass 2: T = ‘List’.)
• If T does not have an argument, or if it has an argument that is a type-
parameter, then return Tf. (Example: the condition only holds for pass
2: T has argument ‘a’.)
• Otherwise, let T ′ be the argument of T. Note that T ′ contains at least
one type-constructor. Now apply recursion: apply typeFormProcedure to
T ′, and let T ′
f be the resulting type-form. (Example: the condition only
holds for pass 1: T ′ = ‘List a’ and T ′
f is M-‘List’ (See ﬁg. 9)).)
• Now apply the type-constructor argument transformation of Tf to T ′
f.
Then, add the rigid part of Tf to the rigid part of the latter application.
Return the result. An alternative precise formulation: return (TR ∪(TA ·
T ′
R), (TA · T ′
P , TA · T ′
A)). (Example: only applies to pass 1: the result is
the form in ﬁg. 18 with M-‘List (List a))’ underneath.)
The reader is invited to verify that the type-forms in ﬁg. 18 are indeed
constructed in accordance with typeFormProcedure, by applying the procedure
to the types underneath each form.
Note that the original type can be immediately recognised in the type-form
by starting with the outermost type-constructor form and then walking your
way to the adjacent one, all the way down to the center form, while reading out
loud the associated type-constructors. The reader is invited to verify that, in
the examples in ﬁg. 18, that indeed leads to reading out loud the types written
underneath each form.
Also, it may be clear that due to its recursive nature, this procedure deﬁnes
a transformation of any type into a type-form.
6.4
Male joint-form
In precise terms, the 3D male joint-form for a type-form is obtained as follows.
The rigid part of the male joint-form is obtained as follows. First add an align-
ment square to the type-form’s rigid part. Then add a third spatial axis to the
type-form’s space, turning it into a 3D space, and extrude the rigid part of the
type-form vertically upwards over a distance of vJntSz (the vertical joint size).
The front side of the joint is deﬁned as the part before extruding began, so the
part in the plane z = 0. In other words, if the joint is joined, it is this part that
enters the opposing joint ﬁrst. Hence, note that when facing the joint from the
front, it will be a mirror image of the type-form. Complete the rigid part by
adding a bottom to the joint by adding a square surface that covers the joint’s
complete bottom (so, at height z = vJntSz).
30

The polymorphic surface of the joint is obtained, by ﬁrst painting the bot-
tom side of polymorphic surface red, and the top side blue, and then moving
(not extruding) the polymorphic surface of the form upwards over a distance of
1
2vJntSz.
6.5
Female joint-form
The 3D female joint-form for a type-form Tf is obtained as follows. The rigid
part is obtained as follows. First take the union U of an alignment square, Tf’s
rigid part and Tf’s polymorphic surface. (Tf’s polymorphic surface is included,
because this creates space for the placement of the joint’s polymorphic surface in
the next step.) Then take the complement of U enclosed within the outer edge
of the alignment square, leading to U. Then extrude U vertically downwards
over a distance of vJntSz. Then add a bottom to the joint by adding a square
surface that covers the joint’s complete bottom (so, at height z = −vJntSz).
The front side of the joint is, again, deﬁned as the part before the extruding
began. Note that the female joint-form aligns exactly with the type-constructor
form. It is not a mirror image.
The joint’s polymorphic surface is obtained by ﬁrst painting its top blue and
its bottom red. Move (so, not extrude) Tf’s polymorphic surface downwards
over a distance of 1
2vJntSz. Then, extrude only the edge of this polymorphic
surface further downwards over the rest of the distance of the joint, so another
1
2vJntSz. The latter is needed to attach the polymorphic surface to the joint’s
bottom, otherwise it would be free-ﬂoating. The material created by extruding
this edge is rigid: it is not part of the joint’s polymorphic surface.
6.6
Condition type-constructor forms
A condition that type-constructor forms have to meet is that each pair of distinct
type-constructor forms, should be such that their corresponding male joint-form
and female joint-form do not ﬁt into each other. The following expresses this
condition in a precise and operational form.
Let Tf be a type-form or type-constructor form . The female bottom region
of Tf is the region of Tf that in the corresponding female joint-form is at the
height of the bottom of the joint, or can go down to that level. In precise terms,
it is equal to the union of Tf’s rigid part and its polymorphic surface, with
exception of the edge of this polymorphic surface. For example, in M-‘List a’’s
form in ﬁg. 9 it is equal to the inner thick square plus the inner square region,
minus the edge of the inner square region.
Let Tf and T ′
f be two type-constructor forms.
One can prove that the
following holds: a male joint with form Tf will not ﬁt into a female joint of T ′
f
if, and only if, the rigid part of Tf contains points that are not in female bottom
region of T ′
f.
The condition can now be formulated as that for any pair of type-constructor
forms present in the translation conﬁguration, the rigid part of the ﬁrst contains
points that are not in the female bottom region of the second, and vice versa:
31

the rigid part of the second contains points that are not in the female bottom
region of the ﬁrst.
6.7
Translation
Madawipol-β’s expressivity is limited to ADSs. Therefore, the translation trans
from textual language (Algepoly1) to Madawipol-β consists of a translation be-
tween ADSs. These ADSs may be unﬁnished (see example 3). It can be deﬁned
recursively on the structure of ADSs. trans takes two arguments, an ADS ads
from Algepoly1 and a translation conﬁguration tConf , hence an application can
be written as trans(ads, tConf ). It is, sketch-wise, deﬁned as follows. If ads is
atomic, then use the information expressed in tConf to build the corresponding
M-constructor. Otherwise, translate the top-level arguments of ads, and join
these with the corresponding joints of the translation of the outermost construc-
tor of ads. If at any moment in this process, some joints cannot be joined, then
the translation results in unjoinable. The technical description of the translation
is beyond the scope of this article.
7
Proof of semantical equivalence of Madawipol-
β and Algepoly1
Just as Algepoly1, Madawipol-β, should be type-safe. This may now be intu-
itively clear, based on the examples developed so far.
A proof is beyond the scope of this article, however, some reﬂections on it
follow now. Type-safety is equivalent to stating that trans never maps a well-
typed ADS to unjoinable, and conversely, that the inverse translation trans−1
of any M-ADS from Madawipol-β is well-typed in Algepoly1. Such a proof has
been provided for Madawipol-α [2]. In Madawipol-β there is an extra challenge
because of type-propagation. A proof strategy is to interpret each M-algebraic
data structure as a typing statement. Joining of M-constructors, then, can be
regarded as a form of typing derivation, and, hence, as part of a type-system
[6, Sec. 8]. After all, by reading the types that occur in the joints after M-
constructors are joined, one has derived the type. This means that the proof of
type-safety can be realised by showing that the latter type system is isomorphic
to the type system of Algepoly1. In other words, for each typing derivation rule
of the type system of Algepoly1 one has to deﬁne a counterpart based on joining
M-constructors from Madawipol-β, and then one has to prove that these behave
congruently.
7.1
Uniﬁable = joinable
An important part of the type-safety of Madawipol-β leans on the fact that any
pair of types is uniﬁable if, and only if the corresponding male and female joint-
forms ﬁt into each other, assuming that both forms were undiﬀerentiated before
the ﬁtting started. In other words: “uniﬁable = joinable”. This is a central
32

lemma in a proof of type-safety. To build some intuition that this lemma is
true, the reader could try to verify this for the following statements, by using
ﬁg. 18.
Hence, investigate for each of the following statements whether the
male joint with the ﬁrst type-form, joins with the female joint with the second
type-form, and whether the male joint with the second type-form, joins with
the female joint with the ﬁrst type-form if, and only if the types are uniﬁable.
Whether they are is indicated with =u (types are uniﬁable) or ̸=u (they are not).
M-‘List a’ =u M-‘a’; M-‘List (List a)’ ̸=u M-‘List Bool’; M-‘List (List
Bool)’ ̸=u M-‘List (List Colour)’; M-‘List a’ =u M-‘List (List a)’.
[2, Lemma 2, p. 11] is a proof of this lemma for Madawipol-α.
A proof
for Madawipol-β is beyond this article’s scope. However, it is very similar. A
proof-sketch follows now. If T and T ′ are uniﬁable, then either T = T ′, and then
the joints trivially ﬁt, or T and T ′ consist of a sequence of type-constructor-
applications that have an identical beginning sequence, starting from the out-
ermost type-constructor. After this beginning sequence, either T or T ′ ends
in a type-parameter. Assume it is T that does so. Example: T=‘List (Pair
(List a))’ and T ′=‘List (Pair (List (List Bool)))’. Here, the identical
beginning sequence is ‘List (Pair (List ...’, after which T ends in the type-
parameter ‘a’, while T ′ contains additional type-constructors. The part of the
joint-forms that are a result of the translation of this beginning sequence will
always ﬁt.
One can easily see this by investigating how typeFormProcedure
works: each type-constructor form is only inﬂuenced by the translation of the
preceding type-constructors, never the later. The rest of the joints also ﬁt. The
type-parameter of T is translated into a polymorphic surface. Due to the linear
transformation it went through, it will completely cover the translation of the
remaining sequence of type-constructors of T ′ (in the example: ‘List Bool’).
Hence, these parts of the joints will also ﬁt. It is easy to see that this works
both for a male version of T into the female version of T ′, and the male version
of T ′ into the female version of T.
If T and T ′ are not uniﬁable, then there must be a minimal position n where
the type-constructor of T is diﬀerent from that of T ′. For example, with T=M-
‘List (Pair (Pair a))’ and T ′=‘List (Pair (List (List Bool)))’ this is
the case at the 3rd position, so n = 3.
The corresponding type-constructor
forms at position n of both joints is linearly transformed in exactly the same
way by typeFormProcedure, because the sequence of type-constructors that pre-
cedes them is identical. Joints with diﬀerent type-constructor forms do not ﬁt
into each other. This is a requirement of the translation conﬁguration (see sec-
tion 6.6). Obviously, they also do not ﬁt after going through the same linear
transformation. Consequently, the joints do not ﬁt.
A formal proof of the previous sketch can easily be obtained by induction.
8
Related work
The scientiﬁc literature on designs related to capturing polymorphic data struc-
tures, in particular algebraic data structure with type-parameters is to the best
33

of our knowledge conﬁned to [4]. They created a design based on a similar idea
of which we became aware retrospectively: polymorphic blocks (PB). Although
the ideas are similar, the designs of Madawipol-β has the following advantages
over PB:
1. Madawipol-β is more expressive (except for its current limitation to one
type-parameter, however, see section 9). It essentially covers polymorphic
algebraic data types fully: unlimited type complexity (i.e. types with any
number of type-constructors) and recursive type deﬁnitions in a well-typed
way. It does so by applying an eﬀective scheme of linear transformations.
PB also allows for some degree of type complexity, however, not fully.
What is more, from the perspective of algebraic data types, it is not type-
safe. An example is the creation of a List of Lists: compare the visual
‘Cons’ in [4, Fig. 3, 3rd block] and ﬁg. 16: the ‘Cons’ of the ﬁrst will not
be able to transfer its type information, leading to ill-typed constructions.
This can be clearly seen in [4, Fig. 4, 3rd block]. The second argument
of the ‘Cons’ is fully diﬀerentiated to a ‘Bool’ form. However, it is also
compatible with a ‘List’ of ‘Boolean’s. One could argue that this is a
general form of type-unsafety, not only from the perspective of algebraic
data types.
2. Madawipol-β uses a 3D design, in which each visualised type-constructor
encloses the visualised arguments. This may be more intuitive than the
juxtaposition of visual type-constructors in PB. Moreover, this 3D design
supports the linear transformations of visual type-constructor-arguments
needed for creating complex types more intuitively.
3. Madawipol-β introduces laws that explain why polymorphic surfaces (called
‘polymorphic ports’ in PB) behave as they do within constructors, while
PB does not. (See section 4). In particular, that female and male joints
create ‘inverse’ joint forms, is a consequence of simpler laws in Madawipol-
β. This may support intuitive understanding.
An advantage of PB over Madawipol-β is that it supports multiple type-
parameters, Madawipol-β currently only one. Madawipol-β, however, can easily
and naturally be extended for this purpose.
9
Conclusion and future work
This article presented the design of truly visual polymorphic and type-safe alge-
braic data structures as they occur in advanced languages such as Haskell and
Clean. The design supports recursively deﬁned types, and unlimited complex
types consisting of more than one type-constructor. The type-safety is enforced
solely mechanically, without requiring any text.
Future work on the design could include the following.
34

1. Extend to multiple type-parameters. This is straightforward: allow more
than one polymorphic surfaceto be present in a type-form, and give them
distinct colours.
2. M-constructor s may physically get ‘into each other’s way’ depending on
the shape of the M-constructors and the structure that one is trying to
build (e.g. try to build a ‘List (List (List (List Bool)))’). Solve this
problem.
3. Empirically validate the understandability of the design.
Acknowledgments
We express our gratitude towards Douwe Schulte for his assistance in editing
the paper.
This work is part of the STW research programme with project number
13855, which is (partly) ﬁnanced by the Netherlands Organisation for Scientiﬁc
Research (NWO).
References
[1] T. H. Brus, Marko C. J. D. van Eekelen, M. O. van Leer & Marinus J. Plas-
meijer (1987): CLEAN: A language for functional graph writing. In Gilles
Kahn, editor: FPCA, Lecture Notes in Computer Science 274, Springer, pp.
364–384. Available at http://dx.doi.org/10.1007/3-540-18317-5_20.
[2] Chide Groenouwe & John-Jules Meyer (2017): Visually Embodying Well-
Typedness of Algebraic Data Structures through Maramaﬁcation.
Techni-
cal Report, Utrecht University, the Netherlands. http://www.cs.uu.nl/
research/techreps/repo/CS-2017/2017-014.pdf.
[3] P. Hudak, S. Peyton Jones & P. Wadler (editors) (1992): Report on the
Programming Language Haskell, A Non-strict Purely Functional Language
(Version 1.2). ACM SIGPLAN Notices 27(5). http://www.haskell.org/
definition/haskell-report-1.2.ps.gz.
[4] Sorin Lerner, Stephen R. Foster & William G. Griswold (2015): Polymor-
phic Blocks: Formalism-Inspired UI for Structured Connectors.
In: Pro-
ceedings of the 33rd Annual ACM Conference on Human Factors in Com-
puting Systems, CHI ’15, ACM, New York, NY, USA, pp. 3063–3072,
doi:10.1145/2702123.2702302. Available at http://doi.acm.org/10.1145/
2702123.2702302.
[5] Leonid Mirsky (2012): An introduction to linear algebra. Courier Corpora-
tion.
[6] Benjamin C Pierce (2002): Types and programming languages. MIT press.
35

[7] Dimitrios Vytiniotis, Stephanie Weirich & Simon Peyton Jones (2006):
Simple
uniﬁcation-based
type
inference
for
GADTs.
ACM
Press,
pp. 50–61. https://www.microsoft.com/en-us/research/publication/
simple-unification-based-type-inference-for-gadts/.
36

