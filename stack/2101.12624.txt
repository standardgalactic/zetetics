arXiv:2101.12624v2  [physics.med-ph]  19 Mar 2021
ORIGINAL ARTICLE
Journal Section
MRIReco.jl: An MRI Reconstruction Framework
written in Julia
Tobias Knopp1,2*
|
Mirco Grosser1,2*
1Institute for Biomedical Imaging, Hamburg
University of Technology, Hamburg,
Germany
2Section for Biomedical Imaging, University
Medical Center Hamburg-Eppendorf,
Hamburg, Germany
Correspondence
Tobias Knopp, Lottestrasse 55, 22529
Hamburg, Germany
Email: tobias.knopp@tuhh.de
Funding information
-
Word count
5996
Purpose: The aim of this work is to develop a high-perfor-
mance, ﬂexible and easy-to-use MRI reconstruction frame-
work using the scientiﬁc programming language Julia.
Methods:
Julia is a modern, general purpose programming language
with strong features in the area of signal / image process-
ing and numerical computing. It has a high-level syntax but
still generates eﬃcient machine code that is usually as fast
as comparable C/C++ applications. In addition to the lan-
guage features itself, Julia has a sophisticated package man-
agement system that makes proper modularization of func-
tionality across diﬀerent packages feasible. Our developed
MRI reconstruction framework MRIReco.jl can therefore reuse
existing functionality from other Julia packages and concen-
trate on the MRI-related parts. This includes common imag-
ing operators and support for MRI raw data formats.
Results:
MRIReco.jl is a simple to use framework with a high degree
of accessibility. While providing a simple-to-use interface,
many of its components can easily be extended and customized.
The performance of MRIReco.jl is compared to the Berkeley
Advanced Reconstruction Toolbox (BART) and we show that
the Juliaframework achieves comparable reconstruction speed
as the popular C/C++ library.
Conclusion:
Modern programming languages can bridge the gap between
1

2
T. Knopp et al.
high performance and accessible implementations. MRIReco.jl
leverages this fact and contributes a promising environment
for future algorithmic development in MRI reconstruction.
KEYWORDS
magnetic resonance imaging, image reconstruction, open source,
Julia, numerical computing
1
|
INTRODUCTION
Magnetic resonance imaging (MRI) is a radiation-free tomographic imaging modality allowing for both
high spatial resolution and high soft-tissue contrast. This, in combination with the large number of avail-
able contrasts, makes it an indispensable tool for many clinical imaging applications. In recent times,
acquisition times and spatial resolution have been pushed further through the introduction of new, ad-
vanced signal processing techniques such as compressed sensing (CS) [1, 2] or structured matrix com-
pletion [3, 4, 5]. In a similar way, algorithmic developments have stimulated the development of new
techniques for the quantitative imaging of tissue parameters, such as relaxation times, magnetic suscep-
tibility or apparent diﬀusion coeﬃcients [6, 7, 8, 9]. An important catalyst for this development is the
availability of open source software. The latter facilitates the development of new methods while taking
away the need of a full, self-implemented MRI signal processing pipeline.
An important aspect to keep in mind is that improvements in image quality and / or reduction in scan
time are often only possible by computationally intensive algorithms shifting the bottleneck in latency
from acquisition to reconstruction. To reduce the reconstruction time to a manageable level massive par-
allelization including the usage of GPGPU (General Purpose Graphical Purpose Units) [10, 11] hardware
acceleration are often necessary. While this allows for acceleration of MRI reconstruction by a factor of
10-1000, it at the time increases the complexity of the software system.
Researchers developing new image reconstruction algorithms usually face two conﬂicting goals. On
the one hand, one seeks a programming environment allowing for an easy translation of mathematical
notation into programming code. On the other hand, the program should run as fast as possible. The
ﬁrst goal can be accomplished by using a high-level (HL) programming environment, albeit at the cost
of performance. On the other hand, computation speed can be ensured by working in a low-level (LL)
programming environment, which results in an increased system complexity. For this reason, one can
observe that HL languages, such as Matlab and Python/Numpy [12], are popularly used by mathemati-
cal/theoretical researchers. In contrast, the LL approach is often used by the vendor of an imaging system,
since the product needs to runs in a suﬃciently short reconstruction time. In that case, the increase in
system complexity is addressed by increasing the development resources.
A popular approach to reconcile both goals is to implement only hot loops in a LL language, while
using a HL language for the remaining part. Popular examples for this hybrid approach are Matlab with its
Mex interface, i.e. a combination of Matlab and C/C++ and Python with its diﬀerent ways to call C code
(e.g. ctypes). Note that the hybrid approach is not restricted to user code but that entire frameworks
are built in this way. Examples include Numpy [12], which is mainly written in C, and machine learning
frameworks such as TensorFlow [13] and PyTorch [14], which are implemented in C/C++ with Python
language bindings.
The hybrid approach has many advantages but it also has issues, which the authors in [15] summarize
in the two language problem:
•
The LL implementation is capsuled away from the HL user interface. This is ﬁne in most situations

T. Knopp et al.
3
but becomes problematic if custom algorithms need to be implemented.
•
Bridging from one language to the other often has a high computational cost and only amortizes
for large problem sizes. Thus, code is often vectorized to minimize the number of calls into the LL
language.
Beyond that it should be noted that two-language solutions are more complex to set up since multiple
compilers and a proper management of dependencies are needed. In consequence, using an existing
framework is easy whereas developing new methods/algorithms can be challenging as this often requires
programming skills in the LL language used.
In the realm of MRI, the hybrid approach is very popular. Prominent examples are the packages
Gadgetron [16] and BART [17], which both have many features and follow the two-language principle
with a core written in C/C++ and bindings to diﬀerent HL languages. In contrast, SigPy [18] is a HL
package entirely written in Python and allows for rapid prototyping of MRI reconstruction algorithms.
In this paper, we present an MRI reconstruction framework, which yields high performance while al-
lowing for easy prototyping of new algorithms. The framework is implemented in a single programming
language, thus avoiding the two-language problem. To achieve this, our framework uses the program-
ming language Julia, which was invented by researchers at the MIT in 2012 with the aim of solving
aforementioned two-language problem [15]. The aim of this paper is two-fold. First, we describe our
framework with its main components and we outline how it can be used for the development of new
algorithms. Second, we perform comparisons in order to illustrate that the computation speed of our
framework indeed matches that of popular frameworks such as BART.
2
|
METHODS
When developing an MRI reconstruction framework, it is beneﬁcial to formulate design goals to guide
the design. For instance, the developers of Gadgetron formulated the following list of properties, which
an MRI reconstruction framework should fulﬁll:
1.
Free / open
2.
Modular
3.
Flexible
4.
Cross platform
5.
High performance
6.
Facilitate prototyping
7.
Facilitate deployment
For a proper deﬁnition of each of the design goals we refer the reader to [16]. MRIReco.jl has the same
design goals although the deployment aspect is currently not yet addressed. Instead MRIReco.jl has the
following additional design goals:
8.
Reuse of components: The goal is to use as many existing software components as possible if and only
if they are suitable for the task and appropriately maintained. This includes interdisciplinary standard
tools such as the FFT and the conjugated gradients method (CG). This design goal not only implies
reusing existing software components but also to put non-MRI speciﬁc functionality into dedicated
packages if such a package does not yet exist.
9.
Hackability: It should be possible for software developers to access low-level parts of the software
and develop extensions or even make modiﬁcations to the source code easily. Hackability only slightly
overlaps with prototyping mentioned in [16]. In particular, it means that the gap between being a user

4
T. Knopp et al.
and being a developer of a software framework is small.
10. Accessibility: The software components should be easy to install with only few instructions. It should
be simple to access and modify the existing code.
11. Testing: The code should be properly tested using continuous integration services.
The last two design goals are certainly also followed by Gadgetron and BART. We note, however, that
the two-language principle imposes limits on how well the ﬁrst two of the additional design goals can be
met. For instance, hackability is diﬃcult to address in a two language solution, since code modiﬁcations
often require knowledge of both the HL and the LL language used.
To make design goal 8 more concrete we note that image reconstruction frameworks often share a
large number of generic building blocks. These components include common transformations such as
the FFT, standard linear algebra tools, and optimization algorithms to solve the reconstruction problem
at hand. In order to share these building blocks it is advantageous to put them into dedicated software
packages. This allows developers to reuse building blocks implemented by experts of the given ﬁeld at
hand and it reduces potential errors that could arise when self-implementing them. Finally, we note that
the reuse of standard libraries also leads to a higher level of scrutiny for the latter. In turn, this decreases
the likelihood of persistent bugs.
2.1
|
Julia
To meet the design goals outlined in the previous section, we focus on a new programming language /
environment called Julia. Julia was invented by researchers at the MIT in 2012 [15] and has the aim of
solving the two-language problem. Its most important features include:
•
Julia uses a just-in-time (JIT) compiler based on the LLVM compiler infrastructure [19] and is therefore
capable of generating eﬃcient machine code.
•
Julia has a sophisticated type system including type inference [20], which allows the compiler to
identify statically typed code fragments and in turn emit eﬃcient machine code.
•
Julia code can be both HL and LL. While hot code paths should be kept type stable for maximizing
performance, dynamic programming can be used where convenient code is more important than high
performance.
•
The syntax of Julia is very similar to Matlab and thus familiar to a wide range of researchers.
•
Julia can call C/C++ code with no overhead.
For more details on Julia we refer the reader to Ref. [15].
Julia was designed from the ground up to be capable of generating eﬃcient machine code. In com-
bination with the HL features of the language, this allows us to develop a hackable framework (design
goal 9) while retaining a high performance. In contrast, many dynamically typed languages like Python
are challenging to JIT compile since they contain language features preventing emitting eﬃcient machine
code. Therefore, one of the most successful Python JIT compilers Numba [21] requires the user to man-
ually annotate the code to be compiled, and only a subset of the language can be used. Here, again,
performance is achieved by enabling the system to determine the types of all variables in a function
body. A more general JIT compiler for Python not requiring code annotations is PyPy [22].
Another feature of Julia is its built-in package manager. The latter can take care of all the dependen-
cies of a code package. As a consequence, Julia packages are considered to be cheap and it is possible to
achieve a ﬁne grained modularization across packages. This modularization is pushed by a large commu-
nity of package developers, which enrich the power of the Julia programming environment substantially.
By exploiting this aspect of the Julia programming environment, MRIReco.jl manages to fulﬁll design goal

T. Knopp et al.
5
8 (reuse of components). Beyond that the clear versioning performed by the julia package manager can
greatly simplify reproducible research. This stands in contrast to other approaches, where it is in the
hand of the user to download the correct versions of the dependencies at hand.
2.2
|
Functionality
MRIReco.jl oﬀers a wide range of functionality while concentrating on basic building blocks that have
proven useful for MRI image reconstruction. In particular MRIReco.jl currently oﬀers:
•
Simulation: Methods for simulating MRI data based on software phantoms. This includes support
for modelling B0 inhomogeneity, R∗
2 relaxation and multiple receive coils. Moreover, basic support
for simulating multi-echo sequences is implemented. Simulation can be performed using a direct
evaluation of the imaging equation or using common approximations such as the NFFT.
•
Imaging Operators: Basic Cartesian and non-Cartesian imaging operators based on FFT and NFFT. Oﬀ-
resonance and relaxation term aware imaging operators are available as well. These can be evaluated
using both data-driven [23] and analytical [24, 25] approximations. All operators can be combined to
form encoding operators for more extended acquisitions such as parallel imaging [26] and multi-echo
data acquisition.
•
Coil Estimation: MRIReco.jl implements methods for determining sensitivity maps including the sum-
of-squares method and ESPIRiT [27].
•
Iterative Reconstruction: Iterative reconstruction algorithms using solvers such as CGNR [28], FISTA
[29], ADMM [30], and the split Bregman method [31] are available. For regularization, MRIReco.jl
oﬀers TV, ℓ1, ℓ2 priors including wavelet sparsiﬁcation. Density compensation weighting is available
as a method for speeding up convergence of iterative solvers [32, 33]. Sampling density weights can
be computed for arbitrary trajectories based on the method described in [34].
MRIReco.jl is implemented in a Julia idiomatic way and uses multiple dispatch to execute diﬀerent code
paths depending on the type of function arguments. We note that this is a similar form of polymorphism
known in classical object-orientated languages but that the dispatch is more generic. Since julia allows for
dynamic programming, it was not necessary to introduce a further abstraction mechanism like a pipeline
architecture [16].
An overview of the internal architecture and a typical data ﬂow within MRIReco.jl is given in Fig. 1. In
the following sections we sketch individual parts of the framework using small code snippets to illustrate
some of the design principles. For more detailed information we refer to the documentation and the
source code of the package.
2.3
|
Datatypes
In order to eﬃciently work with MRI data MRIReco.jl introduces two distinct datatypes for its represen-
tion. RawAcquisitionData describes the data as it is stored in a data ﬁle. Since this data is typically
not stored in a form suitable for reconstruction, it is ﬁrst converted into the type AcquisitionData, de-
scribing the pre-processed data. The latter can then be passed to the reconstruction method in order
to obtain an image. Trajectory is another important datatype, which is used for describing the MRI
sampling trajectory. We outline each datatype in more detail next.

6
T. Knopp et al.
Raw Data
Simulation
Acquisition Data
Reconstruction
Image Data
BrukerFile
ISMRMRD
RawAcquisitionData
Parameters
simulation
AcquisitionData
Trajectory
reconstruction
Parameters
AxisArray
(Image)
DICOM
NIfTI
FIGURE 1
Overview of the internal architecture and the typical data ﬂow in MRIReco.jl. An AcquisitionData
object can be constructed either from a ﬁle through a RawAcquisitionData object or using simulation. The
AcquisitionData object and additional reconstruction parameters are passed to the reconstruction method that
yields an AxisArray object that can be stored in DICOM or NIfTI ﬁles.

T. Knopp et al.
7
unprocessed data
preprocessed data
mutable struct RawAcquisitionData
params::Dict{String,Any}
profiles::Vector{Profile}
end
mutable struct Profile
head::AcquisitionHeader
traj::Matrix{Float32,2}
data::Matrix{ComplexF32,2}
end
mutable struct AcquisitionData
sequenceInfo::Dict{Symbol,Any}
traj::Vector{Trajectory}
kdata::Array{Matrix{ComplexF64},3}
subsampleIndices::Vector{Int64}
encodingSize::Vector{Int64}
fov::Vector{Float64}
end
mutable struct Trajectory
name::String
nodes::Matrix{Float64}
times::Vector{Float64}
TE::Float64
AQ::Float64
numProfiles::Int64
numSamplingPerProfile::Int64
numSlices::Int64
cartesian::Bool
circular::Bool
end
FIGURE 2
Datatypes used to represent MRI data. The left-hand side contains the julia deﬁnition of the datatype
RawAcquisitionData used for storing unprocessed MRI data. The right-hand side contains the corresponding
deﬁnition of the type AcquisitionData used for describing the pre-processed MRI data.

8
T. Knopp et al.
2.3.1
|
Raw Data
RawAcquisitionData is a datatype closely resembling the ISMRMRD data format [35]. Its julia deﬁnition
is contained in the left-hand side of Fig. 2. The syntax profiles::Vector{Profile} means that the ﬁeld
profiles has the type Vector{Profile}. The philosophy of the ISMRMRD format is to store all global
metadata in an XML header. This header has a static structure which can be extended by custom ﬁelds.
RawAcquisitionData uses the Dict params (i.e. an associative array) to store all data that are present
in the XML header of an ISMRMRD ﬁle. If possible the content of each parameter is converted to an
appropriate Julia datatype. For convenience, the structure of the ISMRMRD header is ﬂattened, since
this makes all parameters directly accessible. For instance the parameter
<reconSpace>
<matrixSize>
<x>128</x>
<y>128</y>
<z>128</z>
</matrixSize>
</reconSpace>
is available in the length-3 vector head["reconSize"].
Each measurement proﬁle is stored in the type Profile. It describes the data measured after a single
excitation during an MRI experiment. It has members head, traj, and data, which exactly correspond
to the structures speciﬁed by the ISMRMRD ﬁle format. The members of the Profile datatype are also
bit-compatible with corresponding HDF5 structs in an ISMRMRD ﬁle.
2.3.2
|
Pre-Processed Data
The goal of the RawAcquisitionData datatype is to have a very ﬂexible representation for storing a
great variety of measurements. As a matter of fact, this generic representation can be inconvenient
when used for reconstruction. For instance, the proﬁles can be stored in a diﬀerent order than required
for image reconstruction. For this reason, MRIReco.jl uses an additional datatype AcquisitionData to
store the data in a way convenient for reconstruction. The deﬁnition of AcquisitionData can be found
on the right hand side of Fig. 2. It contains the sequence information stored in a dictionary, the k-space
trajectory, the k-space data, several parameters describing the dimensionality of the data, and some
additional index vectors. The k-space data kdata has three dimensions encoding
1.
contrasts/echoes
2.
slices
3.
repetitions
Each element is a matrix whose dimensions encode
1.
k-space nodes
2.
channels/coils
For undersampled data, the indices of the measured samples are stored in the ﬁeld subsampleIndices.
We note that both the traj and the subsampleIndices ﬁelds are deﬁned as vectors with one entry for
each contrast/echo.

T. Knopp et al.
9
Spiral
Cartesian
Radial
FIGURE 3
Exemplary trajectories available in MRIReco.jl.
The encoded space is stored in the ﬁeld encodingSize. It is especially relevant for non-Cartesian
trajectories where it is not clear upfront, how large the grid size for reconstruction should be chosen.
Finally, the parameter fov describes the physical size of the encoding grid.
2.3.3
|
Trajectory
The type Trajectory describes the sampling trajectory of the imaging sequence. Its deﬁnition is also con-
tained on the right-hand side of Fig. 2. Most importantly, the ﬁeld nodes contains the sampling points
as a matrix where the ﬁrst dimension encodes the k-space dimensionality and the second dimension en-
codes the number of sampling points. This structure allows implementing arbitrary sampling trajectories.
Moreover, MRIReco.jl provides constructors for the most common types of trajectories. These include
Cartesian, radial, spiral, dual density spiral, variable density spiral, and perturbed spiral trajectories. Be-
side 2D trajectories, the framework also implements 3D trajectories like the kooshball or the stack of
stars trajectory. A selection of exemplary trajectories is illustrated in Fig. 3.
2.3.4
|
Image Data
MRIReco.jl returns image reconstruction results in the form of an AxisArray, which is special datatype
allowing to encode dimensions of an array. For image processing of reconstructed data one can use the
package Images.jl. Storage of this data is possible using NIfTi.jl, DICOM.jl or HDF5.jl.
2.4
|
Raw Data File Handling
The ﬁle handling in MRIReco.jl is build around the ISMRMRD ﬁle format for which full read and write sup-
port is implemented. In addition, a ﬁle reader for proprietary ﬁles from the vendor Bruker is implemented.
The following code example shows how to convert a Bruker MRI ﬁle into an ISMRMRD ﬁle:
f = BrukerFile(filenameBruker) # create file handle
raw = RawAcquisitionData(f)
# load the data
fout = ISMRMRDFile("outputfile.h5") # create file handle
save(fout, raw) # store the data in the ISMRMRD file

10
T. Knopp et al.
We note that the raw data object raw can also be created by simulation. It is thus possible to cache
simulated data, which is useful to save computation time associated with more complex simulations.
2.5
|
Reconstruction Building Blocks
In general, MRI image reconstruction aims to recover a discrete image of the transverse magnetization
m ∈ÃN from a given set of measurements s ∈ÃM and a signal encoding model described by a linear
operator H ∈ÃM ×N . Thus, one seeks a solution to an inverse problem
argmin
m
∥s −H m ∥2
2 +R(m),
(1)
where R denotes a regularization function expressing prior knowledge about the solution. As a conse-
quence most image reconstruction schemes can be formulated using a set of basic building blocks
•
Linear Operators: These are used to describe the signal encoding operator H . Moreover, they describe
transformations applied to m within the regularization term R(m) (e.g. sparsifying transforms used
in CS).
•
Solvers: Optimization algorithms used to solve problem (1).
•
Proximal Maps: These are associated with the given regularization functions.
The interface in MRIReco.jl is designed so that all relevant parameters can be passed to the reconstruction
method via a dictionary. The reconstruction method uses these parameters to form the main building
blocks and solves the corresponding image reconstruction problem. In the following sections, we provide
more information on the use and implementation of aforementioned building blocks.
2.5.1
|
Linear Operators
Linear operators are used in multiple places of a reconstruction pipeline. Most importantly, the signal
encoding operator H is a discrete approximation of the underlying signal model
sp (t) =
∫
Òd cp (r )m(r )e−z (r)t e−2πik (t)·r dr .
(2)
Here sp (t) denotes the demodulated signal received in the p-th of P receive coils at time t. Moreover,
m(r ) is the transverse magnetization of the object at position r and cp (r ) are the receive coil sensitivities.
Finally, the term z (r ) ∈Ã contains the R∗
2 and B0 maps in its respective real and imaginary parts. As a
second application, linear operators can be applied to m in the regularizer R. This commonly happens
in compressed-sensing-type reconstructions, where the image needs to be transformed into a sparse
representation.
All operators are implemented in a matrix-free manner. This means that they are characterized solely
by their action when applied to a vector. This allows to evaluate operators using eﬃcient algorithms, such
as the FFT and NFFT, while avoiding storage of the underlying matrix representation. Other common
matrix operations are implemented in complete analogy. For instance, one can apply a linear operator
using the *-operator or form its adjoint using the postﬁx ’. Similarly, linear operators can be composed
using either of the operators * and ◦, and their size can be determined using the size-function.1
1We note that the term operator is used here for both the binary mathematical operation and the linear mapping.

T. Knopp et al.
11
MRIReco.jl provides implementations of the operators commonly used for MRI image reconstruction.
These include
•
FFTOp: A multidimensional FFT operator.
•
NFFTOp: A multidimensional NFFT operator.
•
FieldmapNFFTOp: An extension of the NFFT operator taking into account complex ﬁeldmaps.
•
SensitivityOp: An operator, which multiples an image by a set of coil-sensitivities as used in SENSE-
type reconstructions.
•
SamplingOp: An operator for (sub)sampling (k-space) data.
•
WeightingOp: A weighting operator used for tasks such as sampling density compensation.
Additional operators, such as the Wavelet transform and ﬁnite diﬀerences operators, are reexported from
the Julia package SparsityOperators.jl.
In addition to theses methods, MRIReco.jl provides high-level constructors that compose aforemen-
tioned operators and return signal encoding operators for the diﬀerent reconstruction schemes. These
are automatically called by the reconstruction methods implemented. Alternatively, each operator can
be built manually by calling the corresponding constructor. In this way the preimplemented operators
can be used as building blocks when developing new algorithms.
Finally, we note that iterative solvers often require repeated application of the normal operator N =
H H H of the encoding operator. Thus, algorithms can sometimes be accelerated by optimizing the normal
operator instead of optimizing the encoding operator itself. For instance, one can exploit the Toeplitz
structure of H H H when H is an NFFT. To allow for this kind of optimization, MRIReco.jl reexports the
type normalOperator from the packages SparsityOperators.jl and RegularizedLeastSquares.jl. When an
optimized implementation of the normal operator exists, the latter can be used by simply overloading
the constructor function normalOperator.
2.5.2
|
Solvers
In order to solve the reconstruction problem at hand, MRIReco.jl uses the infrastructure provided by
the package RegularizedLeastSquares.jl. The latter implements popular iterative optimization methods,
such as the CGNR, FISTA and ADMM. For all the reconstruction methods implemented in MRIReco.jl the
solver can be determined by assigning its name to the parameter :solver in the dictionary containing
the reconstruction parameters.
2.5.3
|
Regularization
To describe regularization functions, MRIReco.jl uses the type Regularization from the package Regular-
izedLeastSquares.jl. Most notably, this type contains a function to compute the associated proximal map.
This approach is very generic in the sense that most common solvers incorporate regularization in the
form of a proximal map.
For convenience, RegularizedLeastSquares.jlimplements several common regularization functions such
as TV, ℓ1, ℓ2 and low rank regularization. Analogously to the solver to be used, these regularization
functions can be speciﬁed by assigning their respective names to the parameter :regularization (e.g.
params[:regularization] = "L1" ). Alternatively, one can assign one (or more) Regularization ob-
jects to aforementioned parameter. This allows the incorporation of custom regularization functions. In
this case, the main work to be done is the implementing the corresponding proximal map. Finally, the
preimplemented regularization objects can serve as building blocks when developing new optimization
algorithms.

12
T. Knopp et al.
# create image
N = 128
x = shepp_logan(N)
Phantom
# create coil sensitivities
smaps = birdcageSensitivity(N,8,3.0)
# simulation parameters
params = Dict{Symbol, Any}()
params[:simulation] = "fast"
params[:trajName] = "SpiralVarDens"
params[:numProfiles] = 1
params[:windings] = 16
params[:numSamplingPerProfile] = 2048
params[:senseMaps] = smaps
# do simulation
acqData = simulation(x, params)
Simulation
# reconstruction parameters
params[:reco] = "multiCoil"
params[:reconSize] = (N,N)
params[:regularization] = "TV"
params[:λ] = 2.0e-3
params[:solver] = "admm"
params[:iterationsInner] = 10
params[:iterations] = 30
params[:ρ] = 1.0e-1
params[:absTol] = 1.0e-5
params[:relTol] = 1.0e-4
# do reconstruction
y = reconstruction(acqData, params)
Reconstruction
FIGURE 4
Example of a high-level simulation and reconstruction script using the software package MRIReco.jl. In
the lower part of the ﬁgure the generating code snippets are shown while the resulting data is shown in the top part.
The example starts by generating a 128 × 128 Shepp–Logan phantom (left column), which is used for simulating
8-fold undersampled k -space data (middle column). Finally, a simple TV -regularized iterative parallel imaging
reconstruction is performed (right column).
2.6
|
High-Level Reconstruction
Next we sketch a high-level simulation and reconstruction with MRIReco.jl. As outlined before, the inter-
face is designed in such a way that all parameters are passed to the routine simulation and reconstruction
via a parameter dictionary. This approach is very generic and allows specifying a large set of parameters
without using long argument lists. The dictionary can also be stored in an XML or TOML ﬁle.
The example simulation uses a 128 × 128 pixel sized Shepp-Logan phantom, 8 birdcage coil sensitivities,
and a variable density spiral trajectory with 1 interleave and 2048 samples. This corresponds to an 8-
fold undersampling. Afterwards, reconstruction is performed using a SENSE-type compressed sensing
reconstruction with TV-regularization. The reconstruction problem is then solved using ADMM with 10
inner CG-iterations and 30 outer iterations. The resulting image is shown on the right-hand side of Fig.
4.
2.7
|
Low-Level Reconstruction
The high-level reconstruction outlined in the previous section allows performing image reconstruction
for a wide range of MRI imaging scenarios. Alternatively, the building blocks in MRIReco.jl can be used
in a more low-level way to implement custom reconstruction methods. In the next example we illus-
trate this using the example of a simple gridding reconstruction. With an AcquisitionData object at
hand, a gridding reconstruction could be implemented using the following code snippet. First, density

T. Knopp et al.
13
compensation weights (samplingDensity) are computed and the trajectory to be used is extracted. After
forming the gridding operator (NFFTOp), the reconstructed image is obtained by applying its adjoint to the
weighted k-space data. This illustrates that the notation within MRIReco.jl is very close to the underlying
mathematical description.
using MRIReco
# load or simulate acqData
# custom low-level reconstruction
reconSize = acqData.encodingSize[1:2]
weights = samplingDensity(acqData, reconSize)[1]
tr = trajectory(acqData)
F = NFFTOp(reconSize, tr)
kdata = kData(acqData,1,1,1) .* (weights.^2)
reco = adjoint(F) * kdata
2.8
|
Parallelization
One important way to speed up reconstruction is to make use of parallel code execution. MRIReco.jl
supports multi-threading (i.e. shared memory parallelism) as the primary form of parallelism and has also
preliminary support for GPU acceleration, which has been recently added to the package NFFT.jl (since
version 0.6). To achieve decent speed-ups irrespective of the reconstruction setting, multi-threading is im-
plemented in diﬀerent parts of MRIReco.jl. On a low level, several imaging operators, such as the multi-coil
imaging operator and the ﬁeldmap-aware imaging operator, require the computation of multiple NFFTs,
which can be done in parallel. On a higher level, one often wants to perform multiple independent recon-
structions. This includes the reconstruction of multiple slices of a 2d acquisition or the reconstruction of
multiple independent coil images. Therefore, all loops over independent reconstructions are parallelized
as well. Parallelization on diﬀerent levels is possible without risking oversubscription of CPU cores with
too many threads since Julia uses a thread pool that allows for nested parallelism similar to OpenMP [38],
Cilk [39], and Intel TBB [40].
2.9
|
Availability and Platform Support
MRIReco.jl is developed within a public Git repository hosted at Github.2 The project contains online
documentation that can be accessed from the project homepage. Bug reports, feature requests and
comments can be made using an issue tracker. Any commit made to MRIReco.jl is tested using continuous
integration services. MRIReco.jl is supposed to run on any operating system and platform that Julia itself
supports. Currently, the test suite runs successfully on Linux, OS X, and Windows.
The software package is licensed under the MIT license3, as are most parts of Julia and its package
ecosystem. The MIT license is a permissive license and allows to use the code even in a closed-source
application. MRIReco.jl has only one GPL dependency (FFTW [41]), which would need to be replaced
prior inclusion into a closed source application4.
2https://github.com/MagneticResonanceImaging/MRIReco.jl
3https://opensource.org/licenses/MIT
4Massachusetts Institute of Technology (MIT) and Intel (MKL, Math Kernel Library) provide binary compatible FFTW implementations that can be used in
closed-source applications.

14
T. Knopp et al.
2.10
|
Experimental Evaluation
After giving an overview of the functionality and implementation of MRIReco.jl we next apply MRIReco.jl
to openly available MRI data and perform a comparison with an existing MRI reconstruction framework.
The ﬁrst test aims at testing/demonstrating the full reconstruction pipeline from loading MRI data in
the commonly used ISMRMRD format to performing image reconstruction. For this purpose, we down-
loaded a publicly available MRI dataset from the database http://mridata.org [42]. The dataset con-
tains data of a human knee acquired using a 3d FSE sequence and an 8-channel receive coil on a GE
scanner. The data was acquired with a FOV of 160 mm x 160 mm x 124.8 mm, a matrix size of 320 x 274
x 208 and a TR/TE of 1400 ms / 20 ms. The data was measured using variable density Poisson disk sam-
pling with a fully sampled calibration area of size 35x35 and an overall undersampling factor of 7.13. After
loading it, the data was converted to 2d data by applying a Fourier transform along the readout direc-
tion. Next, coil sensitivy maps were obtained using the ESPIRiT implementation contained in MRIReco.jl.
Finally, image slices were reconstructed using a SENSE-type reconstruction with ℓ1-regularization in the
Wavelet domain and a regularization parameter of 0.2. The reconstruction problem was solved using the
ADMM with 30 iterations and 10 iterations of the inner CG method.
Secondly, we perfomed a comparison of MRIReco.jl with the popular C/C++ reconstruction frame-
work BART [17]. As a model problem we chose an iterative SENSE reconstruction using the radial dataset
published as part of the ISMRM reproducibility challenge 1 [43]. It consists of a brain dataset acquired
with 12 coils using a radial trajectory with 96 proﬁles and 512 samples per proﬁle. The coil sensitivities
are estimated from the data itself using the ESPIRiT implementation that is part of each framework. As
proposed in the reproducibility challenge, the fully sampled dataset was retrospectively undersampled
by reduction factors between R = 1 and R = 4. For both frameworks, images were recovered using an it-
erative ℓ2-regularized SENSE reconstruction based on the CG method. In all cases we used 20 iterations
and a regularization parameter of 0.01. It is run on a workstation equipped with two AMD EPYC 7702
CPUs running at 2.0 GHz (256 cores in total) and a main memory of 1024 GB.
The data/software that support the ﬁndings of this study are openly available in MRIReco.jl at 10.
5281/zenodo.4464857, SHA-1 hash 72fbbd0, and MRIRecoBenchmarksat 10.5281/zenodo.4467979, SHA-
1 hash b24b60c. To be precise, the reconstruction of the knee dataset is contained in the examples folder
in MRIReco.jl, while the code for the comparison with BART is contained in MRIRecoBenchmarks.
3
|
RESULTS
3.1
|
Reconstruction Results of the Knee Data Set
Fig. 5 shows images of the reconstructed knee dataset for some exemplary slices. These results illustrate
a typical application for researchers, who wish to test their reconstruction methods not only using sim-
ulation data but also data from MRI scanners. As illustrated in the example code accessible in the Git
repository, this can by achieved quite easily with MRIReco.jl in conjunction with the ISMRMRD format.
Thus, all that is needed to work with raw data is to convert the latter from its vendor speciﬁc format
into the ISMRMRD format. Afterwards, the data can be reconstructed using either one of the preim-
plemented reconstruction methods or by a custom reconstruction method making use of the low-level
building blocks provided by MRIReco.jl.
3.2
|
Runtime Performance
Designing a proper performance benchmark for independent software frameworks can be a challeng-
ing task since frameworks often diﬀer not only in the implementation but also in the choice of imple-
mented algorithms/optimizations and in the choice of default reconstruction parameters. Since both

T. Knopp et al.
15
slice 50
slice 100
slice 150
slice 200
FIGURE 5
Results of the ℓ1-Wavelet reconstruction of the knee data set. The reconstructed images are shown for
the slices 50, 100, 150 and 200 (along readout direction).
BART and MRIReco.jl implement multi-threading we performed benchmarks for diﬀerent numbers of
threads (1,4,8,12). For each framework, the reconstruction is performed multiple times and the mini-
mum time is used for comparison. In this way, both frameworks are benchmarked under idealized but
comparable conditions. In particular this procedure considers hot CPU caches.
BART by default uses the Toeplitz optimization for eﬃcient multiplication with the normal matrix.
During the development of the benchmark we implemented this feature as well to match the implemen-
tation in BART. In addition to the Toeplitz optimization, which implies using FFTs with an oversampling
of factor σ = 2.0, MRIReco.jl also allows running the code without the Toeplitz optimization but with a
smaller oversampling factor such as σ = 1.25 (see [44] for investigation of oversampling factor sizes).
Although this may slightly reduce the accuracy of the NFFT approximation, we observe that in practice
the approximation error is so small that it is not visually perceptible in the reconstructed images.
The results of the performance comparison are summarized in Fig. 6 for the reduction factors R = 1
and R = 4. One can see that both reconstruction frameworks achieve very similar reconstruction times.
MRIReco.jl is slightly faster for 1 and 4 threads while BART is faster for 12 threads. When comparing the
result with and without Toeplitz optimization one can see that for R = 1 both approaches achieve similar
performance while for R = 4 the non-Toeplitz reconstruction with oversampling factor σ = 1.25 is clearly
faster. This can be explained by the smaller size of the FFT and the fact that for R = 4 signiﬁcantly fewer
points need to be gridded compared to the case where R = 1.
3.3
|
Reconstruction Accuracy
Reconstruction results are summarized in Fig. 7. They are shown for reduction factors R = 1, 2, 3, 4 using
the same reconstruction parameters. For MRIReco.jl the images obtained using the Toeplitz optimization
are shown. For both frameworks only a minor decrease of image quality can be observed with increasing
reduction factor. When looking at diﬀerence maps between reduction factor R = 1 and higher reduction
factors (row two and four) one observes that R = 3 shows a smaller deviation in outer image regions of
the head than reduction factors R = 2 and R = 4.
When comparing the reconstruction results of the two frameworks one can hardly see a diﬀerence.
Only the outer regions beyond the head look slightly diﬀerent, which is likely caused by diﬀerences in
the coil estimation algorithm. Even the diﬀerence maps compared to the R = 1 reconstruction look very
similar, which indicates that both frameworks implement the iterative SENSE reconstruction in a similar
way. This is further supported by the diﬀerence maps between the two reconstruction frameworks
shown in the ﬁfth row. These show mostly noise in the head region.

16
T. Knopp et al.
1
4
8
12
0
1
2
3
# Threads
Time [s]
R = 1
BART
MRIReco.jl
MRIReco.jl*
1
4
8
12
0
1
2
3
# Threads
Time [s]
R = 4
FIGURE 6
Performance comparison between BART and MRIReco.jl shown are the minimum reconstruction times
of an iterative SENSE reconstruction for diﬀerent numbers of threads ranging from 1 to 12. On the right, the results
for reduction factor R = 4 are shown while on the left, the results without data reduction can be seen. Orange
shows the reconstruction times for BART while dark blue shows the reconstruction times for MRIReco.jl both using
the Toeplitz optimization. Light blue shows reconstruction time for MRIReco.jl without the Toeplitz approach using
an oversampling factor σ = 1.25.
3.4
|
Syntactic Comparison
In order to provide a rough estimate for the complexity of the user interface, Table 1 summarizes the
number of code lines required to perform the central tasks associated with the reconstruction of the
brain dataset. This count excludes code lines speciﬁc to the benchmarking, such as setting up the bench-
mark or running multiple trials of the reconstruction. The results show that both frameworks require a
similar number of code lines to perform reconstruction. The main diﬀerence arises from the fact that the
MRIReco.jl-implementation uses a dictionary to store reconstruction parameters, which is not required
for BART. We note however that passing the parameters as a dictionary is done solely for the purpose of
keeping the code readable. Alternatively, the parameters could be passed directly as keyword arguments
as done by BART. We conclude that both frameworks perform image reconstruction with a comparably
complex interface and we acknowledge that the complexity of the ﬁnal code depends on the preferences
of the user at hand.
task
BART
MRIReco.jl
data loading & conversion
5
7
gridding & ESPIRiT
4
2
undersampling data
3
1
reconstruction parameters
0
10
reconstruction
1
1
sum
13
21
TABLE 1
Number of code lines needed to perform the central tasks associated with the reconstruction of the brain
dataset.

T. Knopp et al.
17
R = 1
R = 2
R = 3
R = 4
BART
DiﬀBART
MRIReco.jl
DiﬀMRIReco.jl
MRIReco.jl-BART
0
1
0
1
-0.1
0.1
-0.1
0.1
-0.1
0.1
FIGURE 7
Comparison of SENSE reconstructions of a public brain imaging dataset using BART and MRIReco.jl. The
reconstruction results are shown in rows one and three, while rows two and four show diﬀerence maps to the
reference reconstruction (R = 1). Row ﬁve shows diﬀerence maps between the images reconstructed using both
frameworks for the same reduction factor.

18
T. Knopp et al.
4
|
DISCUSSION
MRIReco.jl started as an experiment of the authors to check the suitability of Julia for developing an
MRI reconstruction framework. Initial success was measured in a rapid development experience while
still generating programs that can compete in terms of runtime speed with equivalent C/C++ programs.
From this point the framework was developed to make it not only usable for the authors themselves but
also for other users. We characterize the status of the project as usable but not yet ﬁnished. This implies
that interfaces of upcoming versions might slightly change and that parts of the documentation are still
incomplete.
In a performance benchmark it was shown that MRIReco.jl achieves similar and sometimes even better
performance than the state-of-the-art C/C++ MRI reconstruction framework BART. We note that the
benchmark was performed for a very speciﬁc reconstruction algorithm (iterative SENSE) and its results
are not directly applicable to other aspects of each of the frameworks.
One key philosophy of MRIReco.jl is to reuse existing code and keep the code base small. This makes
the package more maintainable as it avoids code duplication and keeps the responsibility for code in the
original software repositories. Despite its advantages, this approach requires a package management
system capable of handling complex version dependencies. Julia readily addresses this aspect with its
integrated package manager. An important responsibility in a package with many dependencies is to
maintain compatibility with the depending packages. This can increase the complexity if the packages
are not managed by oneself. Fortunately, the Julia dependency system allows to pin packages to certain
versions such that breaking API changes in depending packages can be avoided.
One weak point of MRIReco.jl is that no functionality for deployment on an MRI scanner is imple-
mented yet. There are basically three diﬀerent implementations thinkable. The ﬁrst is to write a server
in Julia and communicate with the host server via TCP/IP, as was done in [45]. The second possibility is to
embed MRIReco.jl into an existing C/C++ program. In this way it would be possible to integrate MRIReco.jl
into for instance Gadgetron and implement a JuliaGadget similar to the existing PythonGadget. Since Ju-
lia arrays have a C-compatible binary format, it is possible to pass data from C to Julia by only passing
the pointer to the data. Finally, deployment can be achieved using automated oﬄine reconstruction
techniques such as Yarra [46] and Autorec [47].
Julia itself as a language has evolved since its introduction in 2012 into a stable, featureful language
that can compete with more widely developed languages such as Python and C/C++. One of the remain-
ing issues of Julia compared to other programming languages is its latency. Code compilation in Julia is
currently done right before code execution and thus can add a certain amount of latency. The latency
of packages is reduced to some extent by so-called pre-compilation but the current Julia version (1.5.3)
stores only an intermediate representation and not the native machine code. The remaining latency is-
sue can be mitigated by the package Revise.jl, which allows to cache compiled code during a julia session.
An alternative for deployment usage is the package PackageCompiler.jl, which allows to either compile
packages into the system image of Julia or to generate standalone executables.
5
|
CONCLUSIONS
In conclusion we have introduced a new image reconstruction framework for MRI, which is both perfor-
mant and accessible. Two key aspects of MRIReco.jl are its modularity and its open interface. These make
it a useful tool not only for performing image reconstruction but also for the development and testing
of new reconstruction methods. The framework is implemented purely in the programming language
Julia and reaches similar performance and similar image quality as other popular image reconstruction
frameworks that are implemented in a low-level programming language.

T. Knopp et al.
19
Acknowledgements
We acknowledge many fruitful discussions with Martin Uecker on the usage of BART and the design of
the benchmarks.
references
[1] Lustig M, Donoho D, Pauly JM.
Sparse MRI: The application of compressed sensing for rapid MR imaging.
Mag-
netic Resonance in Medicine: An Oﬃcial Journal of the International Society for Magnetic Resonance in Medicine
2007;58(6):1182–1195.
[2] Lustig M, Pauly JM. SPIRiT: iterative self-consistent parallel imaging reconstruction from arbitrary k-space. Magnetic
resonance in medicine 2010;64(2):457–471.
[3] Jin KH, Lee D, Ye JC. A general framework for compressed sensing and parallel MRI using annihilating ﬁlter based
low-rank Hankel matrix. IEEE Transactions on Computational Imaging 2016;2(4):480–495.
[4] Haldar JP. Low-rank modeling of local k-space neighborhoods (LORAKS) for constrained MRI. IEEE transactions on
medical imaging 2013;33(3):668–681.
[5] Shin PJ, Larson PE, Ohliger MA, Elad M, Pauly JM, Vigneron DB, et al. Calibrationless parallel imaging reconstruction
based on structured low-rank matrix completion. Magnetic resonance in medicine 2014;72(4):959–970.
[6] Doneva M, Börnert P, Eggers H, Stehning C, Sénégas J, Mertins A. Compressed sensing reconstruction for magnetic
resonance parameter mapping. Magnetic Resonance in Medicine 2010;64(4):1114–1120.
[7] Zhang T, Pauly JM, Levesque IR. Accelerating parameter mapping with a locally low rank constraint. Magnetic resonance
in medicine 2015;73(2):655–661.
[8] Schweser F, Sommer K, Deistung A, Reichenbach JR. Quantitative susceptibility mapping for investigating subtle sus-
ceptibility variations in the human brain. Neuroimage 2012;62(3):2083–2100.
[9] Mani M, Jacob M, Kelley D, Magnotta V. Multi-shot sensitivity-encoded diﬀusion data recovery using structured low-
rank matrix completion (MUSSELS). Magnetic resonance in medicine 2017;78(2):494–507.
[10] Stone SS, Haldar JP, Tsao SC, Sutton B, Liang ZP, et al. Accelerating advanced MRI reconstructions on GPUs. Journal of
parallel and distributed computing 2008;68(10):1307–1318.
[11] Sorensen TS, Atkinson D, Schaeﬀter T, Hansen MS. Real-time reconstruction of sensitivity encoded radial magnetic
resonance imaging using a graphics processing unit. IEEE transactions on medical imaging 2009;28(12):1974–1985.
[12] Van Der Walt S, Colbert SC, Varoquaux G. The NumPy array: a structure for eﬃcient numerical computation. Computing
in Science & Engineering 2011;13(2):22.
[13] Abadi M, Barham P, Chen J, Chen Z, Davis A, Dean J, et al. Tensorﬂow: A system for large-scale machine learning. In:
12th {USENIX} symposium on operating systems design and implementation ({OSDI} 16); 2016. p. 265–283.
[14] Paszke A, Gross S, Massa F, Lerer A, Bradbury J, Chanan G, et al. Pytorch: An imperative style, high-performance deep
learning library. In: Advances in neural information processing systems; 2019. p. 8026–8037.
[15] Bezanson J, Edelman A, Karpinski S, Shah VB.
Julia: A fresh approach to numerical computing.
SIAM review
2017;59(1):65–98.
[16] Hansen MS, Sørensen TS. Gadgetron: an open source framework for medical image reconstruction. Magnetic resonance
in medicine 2013;69(6):1768–1776.

20
T. Knopp et al.
[17] Uecker M, Ong F, Tamir JI, Bahri D, Virtue P, Cheng JY, et al. Berkeley advanced reconstruction toolbox. In: Proc. Intl.
Soc. Mag. Reson. Med, vol. 23; 2015. p. 2486.
[18] Ong F, Lustig M. SigPy: A Python Package for High Performance Iterative Reconstruction. In: Proc. Intl. Soc. Mag. Reson.
Med, vol. 27; 2019. p. 4819.
[19] Lattner C, Adve V. LLVM: A compilation framework for lifelong program analysis & transformation. In: Proceedings of
the international symposium on Code generation and optimization: feedback-directed and runtime optimization IEEE
Computer Society; 2004. p. 75.
[20] Milner R. A theory of type polymorphism in programming. Journal of computer and system sciences 1978;17(3):348–
375.
[21] Lam SK, Pitrou A, Seibert S. Numba: A llvm-based python jit compiler. In: Proceedings of the Second Workshop on the
LLVM Compiler Infrastructure in HPC ACM; 2015. p. 7.
[22] Bolz CF, Cuni A, Fijalkowski M, Rigo A. Tracing the meta-level: PyPy’s tracing JIT compiler. In: Proceedings of the 4th
workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages and Programming Systems
ACM; 2009. p. 18–25.
[23] Fessler JA, Nol DC. Model-based MR image reconstruction with compensation for through-plane ﬁeld inhomogeneity.
In: 2007 4th IEEE International Symposium on Biomedical Imaging: From Nano to Macro IEEE; 2007. p. 920–923.
[24] Eggers H, Knopp T, Potts D. Field inhomogeneity correction based on gridding reconstruction for magnetic resonance
imaging. IEEE Transactions on Medical Imaging 2007;26(3):374–384.
[25] Knopp T, Eggers H, Dahnke H, Prestin J, Sénégas J. Iterative oﬀ-resonance and signal decay correction for improved
multi-echo imaging in MRI. IEEE Trans Med Imaging 2009;28(3):394–404.
[26] Pruessmann KP, Weiger M, Scheidegger MB, Boesiger P. SENSE: sensitivity encoding for fast MRI. Magnetic resonance
in medicine 1999;42(5):952–962.
[27] Uecker M, Lai P, Murphy MJ, Virtue P, Elad M, Pauly JM, et al. ESPIRiT—an eigenvalue approach to autocalibrating
parallel MRI: where SENSE meets GRAPPA. Magnetic resonance in medicine 2014;71(3):990–1001.
[28] Hestenes MR, Stiefel E. Methods of conjugate gradients for solving linear systems. Journal of Research of the National
Bureau of Standards 1952;49(1).
[29] Beck A, Teboulle M. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM journal on
imaging sciences 2009;2(1):183–202.
[30] Parikh N, Boyd S, et al. Proximal algorithms. Foundations and Trends® in Optimization 2014;1(3):127–239.
[31] Goldstein T, Osher S.
The split Bregman method for L1-regularized problems.
SIAM journal on imaging sciences
2009;2(2):323–343.
[32] Pruessmann KP, Weiger M, Börnert P, Boesiger P. Advances in sensitivity encoding with arbitrary k-space trajectories.
Magnetic Resonance in Medicine: An Oﬃcial Journal of the International Society for Magnetic Resonance in Medicine
2001;46(4):638–651.
[33] Knopp T, Kunis S, Potts D. A note on the iterative MRI reconstruction from nonuniform k-space data. International
journal of biomedical imaging 2007;2007.
[34] Pipe JG, Menon P. Sampling density compensation in MRI: rationale and an iterative numerical solution. Magnetic Reso-
nance in Medicine: An Oﬃcial Journal of the International Society for Magnetic Resonance in Medicine 1999;41(1):179–
186.

T. Knopp et al.
21
[35] Inati SJ, Naegele JD, Zwart NR, Roopchansingh V, Lizak MJ, Hansen DC, et al. ISMRM Raw data format: A proposed
standard for MRI raw datasets. Magnetic resonance in medicine 2017;77(1):411–421.
[36] Fessler JA, Sutton BP. Nonuniform fast Fourier transforms using min-max interpolation. IEEE transactions on signal
processing 2003;51(2):560–574.
[37] Knopp T. Experimental multi-threading support for the Julia programming language. In: Proceedings of the 1st First
Workshop for High Performance Technical Computing in Dynamic Languages IEEE Press; 2014. p. 1–5.
[38] Dagum L, Menon R. OpenMP: an industry standard API for shared-memory programming. IEEE computational science
and engineering 1998;5(1):46–55.
[39] Blumofe RD, Joerg CF, Kuszmaul BC, Leiserson CE, Randall KH, Zhou Y. Cilk: An eﬃcient multithreaded runtime system.
Journal of parallel and distributed computing 1996;37(1):55–69.
[40] Kukanov A, Voss MJ. The Foundations for Scalable Multi-core Software in Intel Threading Building Blocks. Intel Tech-
nology Journal 2007;11(4).
[41] Frigo M, Johnson SG. FFTW: An adaptive software architecture for the FFT. In: Proceedings of the 1998 IEEE Interna-
tional Conference on Acoustics, Speech and Signal Processing, ICASSP’98 (Cat. No. 98CH36181), vol. 3 IEEE; 1998. p.
1381–1384.
[42] Ong F, Amin S, Vasanawala S, Lustig M. Mridata. org: An open archive for sharing MRI raw data. In: Proc. Intl. Soc. Mag.
Reson. Med, vol. 26; 2018. p. 1.
[43] Maier O, Baete SH, Fyrdahl A, Hammernik K, Harrevelt S, Kasper L, et al. CG-SENSE revisited: Results from the ﬁrst
ISMRM reproducibility challenge. Magnetic Resonance in Medicine 2020;.
[44] Eggers H, Boernert P, Boesiger P. Comparison of gridding-and convolution-based iterative reconstruction algorithms
for sensitivity-encoded non-Cartesian acquisitions. In: Proceedings of the 10th Annual Meeting of ISMRM, Honolulu;
2002. p. 743.
[45] Gräser M, Thieben F, Szwargulski P, Werner F, Gdaniec N, Boberg M, et al. Human-sized magnetic particle imaging for
brain applications. Nature communications 2019;10:1–9.
[46] Block KT, Wiggins R, Yarra - A Toolbox for Clinical MRI Research;.
Accessed:
2020-01-20.
http://http://
yarraframework.com.
[47] Borisch EA, Grimm RC, Riederer SJ. Automated Reconstruction Processing. In: Proc. Intl. Soc. Mag. Reson. Med, vol. 27;
2019. p. 1.

