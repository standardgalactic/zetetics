
FPGA PROTOTYPING 
BY VHDL EXAMPLES 
Xilinx SpartanTM-3 Version 
Pong P. Chu 
Cleveland State University 
WILEY- 
INTERSCIENCE 
A JOHN WILEY & SONS, INC., PUBLICATION 

This Page Intentionally Left Blank

FPGA PROTOTYPING 
BY VHDL EXAMPLES 

This Page Intentionally Left Blank

FPGA PROTOTYPING 
BY VHDL EXAMPLES 
Xilinx SpartanTM-3 Version 
Pong P. Chu 
Cleveland State University 
WILEY- 
INTERSCIENCE 
A JOHN WILEY & SONS, INC., PUBLICATION 

Copyright 0 
2008 by John Wiley & Sons, Inc. All rights reserved. 
Published by John Wiley & Sons, Inc., Hoboken, New Jersey. 
Published simultaneously in Canada. 
No part of this publication may be reproduced, stored in a retrieval system, or transmitted in any form or by 
any means, electronic, mechanical, photocopying, recording, scanning, or otherwise, except as permitted under 
Section 107 or 108 ofthe 1976 United States Copyright Act, without either the prior written permission ofthe 
Publisher, or authorization through payment of the appropriate per-copy fee to the Copyright Clearance Center, 
Inc., 222 Rosewood Drive, Danvers, MA 01923, (978) 750-8400, fax (978) 750-4470, or on the web at 
www.copyright.com. Requests to the Publisher for permission should be addressed to the Permissions 
Department, John Wiley & Sons, Inc., 11 1 River Street, Hoboken, NJ 07030, (201) 748-601 1, fax (201) 748- 
6008, or online at http://www.wiley.com/go/permission. 
Limit of Liability/Disclaimer of Warranty: While the publisher and author have used their best efforts in 
preparing this book, they make no representations or warranties with respect to the accuracy or completeness of 
the contents of this book and specifically disclaim any implied warranties of merchantability or fitness for a 
particular purpose. No warranty may be created or extended by sales representatives or written sales materials. 
The advice and strategies contained herein may not be suitable for your situation. You should consult with a 
professional where appropriate. Neither the publisher nor author shall be liable for any loss of profit or any 
other commercial damages, including but not limited to special, incidental, consequential, or other damages. 
For general information on our other products and services or for technical support, please contact our 
Customer Care Department within the United States at (800) 762-2974, outside the United States at (3 17) 572- 
3993 or fax (317) 572-4002. 
Wiley also publishes its books in a variety of electronic formats. Some content that appears in print may not be 
available in electronic format. For information about Wiley products, visit our web site at www.wiley.com. 
Library of Congress Cataloging-in-Publication Data: 
Chu, Pong P., 1959- 
p. cm. 
FPGA prototyping by VHDL examples / Pong P. Chu. 
Includes bibliographical references and index. 
ISBN 978-0-470-18531-5 (cloth : alk. paper) 
1, Field programmable gate arrays-Design 
and construction. 2. Prototypes, 
Engineering. 3.VHDL (Computer hardware description language) I. Title. 
TK7895.G36C485 2008 
621.39'54~22 
2007029063 
Printed in the United States of America. 
1 0 9 8 7 6 5 4 3 2 1  

To myparents, Chia-Chi and Chi-Te, my wqe, Lee, and my daughtel; Patricia 

This Page Intentionally Left Blank

CONTENTS 
Preface 
Acknowledgments 
PART I 
BASIC DIGITAL CIRCUITS 
1 Gate-level combinational circuit 
1.1 
1.2 
1.3 
1.4 
1.5 
1.6 
Introduction 
General description 
1.2.1 
Basic lexical rules 
1.2.2 Library and package 
1.2.3 Entity declaration 
1.2.4 Data type and operators 
1.2.5 
Architecture body 
1.2.6 
Structural description 
Testbench 
Bibliographic notes 
Suggested experiments 
1.6.1 
1.6.2 
Code of a 2-bit comparator 
Code for gate-level greater-than circuit 
Code for gate-level binary decoder 
2 Overview of FPGA and EDA software 
xix 
xxv 
1 
1 
2 
2 
3 
3 
3 
4 
5 
6 
8 
9 
10 
10 
10 
11 
vii 

viii 
CONTENTS 
2.1 
2.2 
2.3 
2.4 
2.5 
2.6 
2.7 
2.8 
2.9 
Introduction 
FPGA 
2.2.1 
2.2.2 
Overview of the Digilent S3 board 
Development flow 
Overview of the Xilinx ISE project navigator 
Short tutorial on ISE project navigator 
2.6.1 
2.6.2 
2.6.3 
2.6.4 
Short tutorial on the ModelSim HDL simulator 
Bibliographic notes 
Suggested experiments 
2.9.1 
Gate-level greater-than circuit 
2.9.2 
Gate-level binary decoder 
Overview of a general FPGA device 
Overview of the Xilinx Spartan-3 devices 
Create the design project and HDL codes 
Create a testbench and perform the RTL simulation 
Add a constraint file and synthesize and implement the code 
Generate and download the configuration file to an FPGA device 
3 RT-level combinational circuit 
3.1 
Introduction 
3.2 
RT-level components 
3.2.1 
Relational operators 
3.2.2 
Arithmetic operators 
3.2.3 
Other synthesis-related VHDL constructs 
3.2.4 Summary 
Routing circuit with concurrent assignment statements 
3.3.1 
Conditional signal assignment statement 
3.3.2 
Selected signal assignment statement 
3.4.1 
Process 
3.4.2 
Sequential signal assignment statement 
Routing circuit with if and case statements 
3.5.1 
If statement 
3.5.2 
Case statement 
3.5.3 
Comparison to concurrent statements 
3.5.4 
Unintended memory 
3.6 
Constants and generics 
3.6.1 
Constants 
3.6.2 
Generics 
3.7 
Design examples 
3.7.1 
3.7.2 
Sign-magnitude adder 
3.3 
3.4 
Modeling with a process 
3.5 
Hexadecimal digit to seven-segment LED decoder 
11 
11 
11 
13 
13 
15 
17 
19 
21 
22 
22 
24 
27 
32 
33 
33 
33 
35 
35 
35 
37 
37 
38 
40 
41 
41 
44 
46 
46 
46 
47 
47 
49 
50 
52 
53 
53 
54 
56 
56 
59 

CONTENTS 
ix 
3.7.3 
Barrel shifter 
3.7.4 
Simplified floating-point adder 
3.8 
Bibliographic notes 
3.9 
Suggested experiments 
3.9.1 
Multi-function barrel shifter 
3.9.2 
Dual-priority encoder 
3.9.3 
BCD incrementor 
3.9.4 
Floating-point greater-than circuit 
3.9.5 
3.9.6 
Enhanced floating-point adder 
Floating-point and signed integer conversion circuit 
4 Regular Sequential Circuit 
4.1 
4.2 
4.3 
4.4 
4.5 
4.6 
4.7 
Introduction 
4.1.1 
D FF and register 
4.1.2 
Synchronous system 
4.1.3 
Code development 
HDL code of the FF and register 
4.2.1 
DFF 
4.2.2 
Register 
4.2.3 
Register file 
4.2.4 
Simple design examples 
4.3.1 
Shift register 
4.3.2 
Binary counter and variant 
Testbench for sequential circuits 
Case study 
4.5.1 
LED time-multiplexing circuit 
4.5.2 
Stopwatch 
4.5.3 
FIFO buffer 
Bibliographic notes 
Suggested experiments 
4.7.1 
Programmable square wave generator 
4.7.2 
PWM and LED dimmer 
4.7.3 
Rotating square circuit 
4.7.4 
Heartbeat circuit 
4.7.5 
Rotating LED banner circuit 
4.7.6 
Enhanced stopwatch 
4.7.7 
Stack 
Storage components in a Spartan-3 deviceXiLinx 
specific 
62 
63 
69 
69 
69 
69 
69 
70 
70 
70 
71 
71 
71 
72 
73 
74 
74 
77 
78 
79 
79 
79 
81 
84 
88 
88 
96 
100 
104 
105 
105 
105 
105 
106 
106 
106 
106 
5 FSM 
5.1 
Introduction 
107 
107 

X 
CONTENTS 
5.1.1 
Mealy and Moore outputs 
5.1.2 
FSM representation 
5.2 
FSM code development 
5.3 
Design examples 
5.3.1 
Rising-edge detector 
5.3.2 
Debouncing circuit 
5.3.3 
Testing circuit 
5.4 
Bibliographic notes 
5.5 
Suggested experiments 
5.5.1 
Dual-edge detector 
5.5.2 
Alternative debouncing circuit 
5.5.3 
Parking lot occupancy counter 
6 FSMD 
6.1 
Introduction 
6.1.1 
Single RT operation 
6.1.2 
ASMD chart 
6.1.3 
Code development of an FSMD 
6.2.1 
6.2.2 
6.2.3 
6.2.4 
Comparison 
6.2.5 
Testing circuit 
6.3.1 Fibonacci number circuit 
6.3.2 
Division circuit 
6.3.3 
Binary-to-BCD conversion circuit 
6.3.4 
Period counter 
6.3.5 
Accurate low-frequency counter 
Decision box with a register 
Debouncing circuit based on RT methodology 
Code with explicit data path components 
Code with implicit data path components 
6.2 
6.3 
Design examples 
6.4 
Bibliographic notes 
6.5 
Suggested experiments 
6.5.1 
Alternative debouncing circuit 
6.5.2 
BCD-to-binary conversion circuit 
6.5.3 
6.5.4 
6.5.5 
Auto-scaled low -frequency counter 
6.5.6 
Reaction timer 
6.5.7 
Fibonacci circuit with BCD IIO: design approach 1 
Fibonacci circuit with BCD I/O: design approach 2 
Babbage difference engine emulation circuit 
PART II 
I/OMODULES 
107 
108 
111 
114 
114 
118 
122 
124 
124 
124 
124 
125 
127 
127 
127 
128 
129 
131 
132 
134 
136 
137 
138 
140 
1 40 
143 
147 
150 
153 
156 
157 
157 
157 
157 
157 
158 
158 
159 

CONTENTS 
xi 
7 UART 
163 
163 
164 
164 
165 
165 
168 
17 1 
174 
174 
176 
178 
180 
180 
180 
181 
181 
181 
182 
7.1 
Introduction 
7.2 
UART receiving subsystem 
7.2.1 
Oversampling procedure 
7.2.2 
Baud rate generator 
7.2.3 
UART receiver 
7.2.4 
Interface circuit 
7.3 
UART transmitting subsystem 
7.4 
Overall UART system 
7.4.1 
Complete UART core 
7.4.2 
UART verification configuration 
7.5 
Customizing a UART 
7.6 
Bibliographic notes 
7.7 
Suggested experiments 
7.7.1 
Full-featured UART 
7.7.2 
7.7.3 
7.7.4 
UART-controlled stopwatch 
7.7.5 
UART-controlled rotating LED banner 
UART with an automatic baud rate detection circuit 
UART with an automatic baud rate and parity detection circuit 
8 PS2 Keyboard 
8.1 
Introduction 
8.2 
PS2 receiving subsystem 
8.2.1 
Physical interface of a PS2 port 
8.2.2 
Device-to-host communication protocol 
8.2.3 
Design and code 
8.3 
PS2 keyboard scan code 
8.3.1 
Overview of the scan code 
8.3.2 
Scan code monitor circuit 
8.4.1 
8.4.2 
Verification circuit 
8.4 
PS2 keyboard interface circuit 
Basic design and HDL code 
8.5 
Bibliographic notes 
8.6 
Suggested experiments 
8.6.1 
Alternative keyboard interface I 
8.6.2 
Alternative keyboard interface I1 
8.6.3 
8.6.4 
Keyboard-controlled stopwatch 
8.6.5 
Keyboard-controlled rotating LED banner 
PS2 receiving subsystem with watchdog timer 
183 
183 
184 
184 
184 
184 
188 
188 
189 
191 
192 
194 
196 
196 
196 
196 
197 
197 
197 
9 PS2Mouse 
199 

xii 
CONTENTS 
9.1 
Introduction 
9.2 
PS2 mouse protocol 
9.2.1 
Basic operation 
9.2.2 
Basic initialization procedure 
9.3 
PS2 transmitting subsystem 
9.3.1 
Host-to-PS2-device communication protocol 
9.3.2 
Design and code 
9.4 
Bidirectional PS2 interface 
9.4.1 
Basic design and code 
9.4.2 
Verification circuit 
9.5 
PS2 mouse interface 
9.5.1 
Basic design 
9.5.2 
Testing circuit 
9.6 
Bibliographic notes 
9.7 
Suggested experiments 
9.7.1 
Keyboard control circuit 
9.7.2 
Enhanced mouse interface 
9.7.3 
Mouse-controlled seven-segment LED display 
10 External SRAM 
10.1 Introduction 
10.2 Specification of the IS61LV25616AL SRAM 
10.2.1 Block diagram and 110 signals 
10.2.2 Timing parameters 
10.3.1 Block diagram 
10.3.2 Timing requirement 
10.3.3 Register file versus SRAM 
10.4.1 ASMD chart 
10.4.2 Timing analysis 
10.4.3 HDL implementation 
10.4.4 Basic testing circuit 
10.4.5 Comprehensive SRAM testing circuit 
10.5.1 Timing issues 
10.5.2 Alternative design I 
10.5.3 Alternative design I1 
10.5.4 Alternative design I11 
10.5.5 Advanced FPGA featuresxizinx specific 
10.3 Basic memory controller 
10.4 A safe design 
10.5 More aggressive design 
10.6 Bibliographic notes 
10.7 Suggested experiments 
199 
200 
200 
200 
20 1 
20 1 
202 
206 
206 
208 
210 
210 
212 
214 
214 
214 
214 
214 
21 5 
215 
216 
216 
216 
220 
220 
22 1 
222 
222 
222 
223 
224 
226 
228 
233 
233 
234 
236 
237 
237 
240 
240 

CONTENTS 
xiii 
10.7.1 Memory with a 512K-by-16 configuration 
10.7.2 Memory with a 1M-by-8 configuration 
10.7.3 Memory with an 8M-by-1 configuration 
10.7.4 Expanded memory testing circuit 
10.7.5 Memory controller and testing circuit for alternative design I 
10.7.6 Memory controller and testing circuit for alternative design I1 
10.7.7 Memory controller and testing circuit for alternative design III 
10.7.8 Memory controller with DCM 
10.7.9 High-performance memory controller 
11 Xilinx Spartan-3 Specific Memory 
1 1.1 Introduction 
1 1.2 Embedded memory of Spartan-3 device 
1 1.2.1 Overview 
11.2.2 Comparison 
11.3 Method to incorporate memory modules 
11.3.1 Memory module via HDL component instantiation 
11.3.2 Memory module via Core Generator 
1 1.3.3 Memory module via HDL inference 
1 I .4 HDL templates for memory inference 
1 1.4.1 Single-port RAM 
1 1.4.2 Dual-port RAM 
11.4.3 ROM 
11.5 Bibliographic notes 
11.6 Suggested experiments 
1 1.6.1 Block-RAM-based FIFO 
11.6.2 Block-RAM-based stack 
11.6.3 ROM-based sign-magnitude adder 
11.6.4 ROM based sin(%) function 
11.6.5 ROM-based sin(%) and cos(5) functions 
12 VGA controller I: graphic 
12.1 Introduction 
12.1.1 Basic operation of a CRT 
12.1.2 VGA port of the S3 board 
12.1.3 Video controller 
12.2 VGA synchronization 
12.2.1 Horizontal synchronization 
12.2.2 Vertical synchronization 
12.2.3 Timing calculation of VGA synchronization signals 
12.2.4 HDL implementation 
240 
240 
240 
24 1 
24 1 
24 1 
24 1 
24 1 
24 1 
243 
243 
243 
243 
244 
244 
245 
245 
246 
246 
246 
249 
25 1 
254 
254 
254 
254 
255 
255 
255 
257 
257 
257 
259 
259 
260 
260 
262 
263 
263 

XiV 
CONTENTS 
12.2.5 Testing circuit 
12.3 Overview of the pixel generation circuit 
12.4 Graphic generation with an object-mapped scheme 
12.4.1 Rectangular objects 
12.4.2 Non-rectangular object 
12.4.3 Animated object 
12.5 Graphic generation with a bit-mapped scheme 
12.5.1 Dual-port RAM implementation 
12.5.2 Single-port RAM implementation 
12.6 Bibliographic notes 
12.7 Suggested experiments 
12.7.1 VGA test pattern generator 
12.7.2 SVGA mode synchronization circuit 
12.7.3 Visible screen adjustment circuit 
12.7.4 Ball-in-a-box circuit 
12.7.5 Two-balls-in-a-box circuit 
12.7.6 Two-player pong game 
12.7.7 Breakout game 
12.7.8 Full-screen dot trace 
12.7.9 Mouse pointer circuit 
12.7.10 Small-screen mouse scribble circuit 
12.7.11 Full-screen mouse scribble circuit 
13 VGA controller II: text 
13.1 Introduction 
13.2 Text generation 
13.2.1 Character as a tile 
13.2.2 Font ROM 
13.2.3 Basic text generation circuit 
13.2.4 Font display circuit 
13.2.5 Font scaling 
13.3 Full-screen text display 
13.4 The complete pong game 
13.4.1 Text subsystem 
13.4.2 Modified graphic subsystem 
13.4.3 Auxiliary counters 
13.4.4 Top-level system 
13.5 Bibliographic notes 
13.6 Suggested experiments 
13.6.1 Rotating banner 
13.6.2 Underline for the cursor 
13.6.3 Dual-mode text display 
266 
267 
268 
269 
273 
275 
282 
282 
287 
287 
287 
287 
288 
288 
288 
289 
289 
289 
289 
290 
290 
290 
291 
29 1 
29 1 
29 1 
292 
294 
295 
297 
298 
302 
302 
309 
310 
312 
317 
317 
317 
317 
317 

CONTENTS 
XV 
13.6.4 Keyboard text entry 
13.6.5 UART terminal 
13.6.6 Square wave display 
13.6.7 Simple four-trace logic analyzer 
13.6.8 Complete two-player pong game 
13.6.9 Complete breakout game 
PART 111 
PICOBLAZE MICRO CONTROLLER^^^^^^ 
14 PicoBlaze Overview 
14.1 Introduction 
14.2 Customized hardware and customized software 
14.2.1 From special-purpose FSMD to general-purpose microcontroller 
14.2.2 Application of microcontroller 
14.3.1 Basic organization 
14.3.2 Top-level HDL modules 
14.3 Overview of PicoBlaze 
14.4 Development flow 
14.5 Instruction set 
14.5.1 Programming model 
14.5.2 Instruction format 
14.5.3 Logical instructions 
14.5.4 Arithmetic instructions 
14.5.5 Compare and test instructions 
14.5.6 Shift and rotate instructions 
14.5.7 Data movement instructions 
14.5.8 Program flow control instructions 
14.5.9 Interrupt related instructions 
14.6.1 The KCPSM3 directives 
14.6.2 The PBlazeIDE directives 
14.6 Assembler directives 
14.7 Bibliographic notes 
15 PicoBlaze Assembly Code Development 
15.1 Introduction 
15.2 Useful code segments 
15.2.1 KCPSM3 conventions 
15.2.2 Bit manipulation 
15.2.3 Multiple-byte manipulation 
15.2.4 Control structure 
15.3 Subroutine development 
15.4 Program development 
317 
3 17 
318 
318 
3 19 
319 
323 
323 
324 
324 
326 
326 
326 
328 
329 
329 
33 1 
332 
332 
333 
334 
335 
336 
338 
341 
342 
342 
342 
343 
345 
345 
345 
345 
346 
347 
348 
350 
35 1 

XVi 
CONTENTS 
15.4.1 Demonstration example 
15.4.2 Program documentation 
15.5 Processing of the assembly code 
15.5.1 Compiling with KCSPM3 
15.5.2 Simulation by PBlazeIDE 
15.5.3 Reloading code via the JTAG port 
15.5.4 Compiling by PBlazeIDE 
15.6 Syntheses with PicoBlaze 
15.7 Bibliographic notes 
15.8 Suggested experiments 
15.8.1 Signed multiplication 
15.8.2 Multi-byte multiplication 
15.8.3 Barrel shift function 
15.8.4 Reverse function 
15.8.5 Binary -to-BCD conversion 
15.8.6 BCD-to-binary conversion 
15.8.7 Heartbeat circuit 
15.8.8 Rotating LED circuit 
15.8.9 Discrete LED dimmer 
16 PicoBlaze 110 Interface 
16.1 Introduction 
16.2 Output port 
16.2.1 Output instruction and timing 
16.2.2 Output interface 
16.3.1 Input instruction and timing 
16.3.2 Input interface 
16.4 Square program with a switch and seven-segment LED display interface 
16.4.1 Output interface 
16.4.2 Input interface 
16.4.3 Assembly code development 
16.4.4 VHDL code development 
16.5 Square program with a combinational multiplier and UART console 
16.5.1 Multiplier interface 
16.5.2 UART interface 
16.5.3 Assembly code development 
16.5.4 VHDL code development 
16.3 Input port 
16.6 Bibliographic notes 
16.7 Suggested experiments 
16.7.1 Low-frequency counter I 
16.7.2 Low-frequency counter 11 
352 
356 
358 
358 
359 
362 
362 
363 
3 64 
365 
365 
365 
365 
365 
365 
365 
365 
366 
366 
367 
367 
368 
368 
3 69 
37 1 
37 1 
37 1 
373 
374 
375 
376 
384 
386 
387 
387 
389 
398 
402 
402 
402 
402 

CONTENTS 
xvii 
16.7.3 Auto-scaled low-frequency counter 
16.7.4 Basic reaction timer with a software timer 
16.7.5 Basic reaction timer with a hardware timer 
16.7.6 Enhanced reaction timer 
16.7.7 Small-screen mouse scribble circuit 
16.7.8 Full-screen mouse scribble circuit 
16.7.9 Enhanced rotating banner 
16.7.10 Pong game 
16.7.1 1 Text editor 
17 PicoBlaze Interrupt Interface 
17.1 Introduction 
17.2 Interrupt handling in PicoBlaze 
17.2.1 Software processing 
17.2.2 Timing 
17.3.1 Single interrupt request 
17.3.2 Multiple interrupt requests 
17.4 Software development considerations 
17.4.1 Interrupt as an alternative scheduling scheme 
17.4.2 Development of an interrupt service routine 
17.5.1 Interrupt interface 
17.5.2 Interrupt service routine development 
17.5.3 Assembly code development 
17.5.4 VHDL code development 
17.3 External interface 
17.5 Design example 
17.6 Bibliographic notes 
17.7 Suggested experiments 
17.7.1 Alternative timer interrupt service routine 
17.7.2 Programmable timer 
17.7.3 Set-button interrupt service routine 
17.7.4 Interrupt interface with two requests 
17.7.5 Four-request interrupt controller 
Appendix A: Sample VHDL templates 
A. 1 General VHDL constructs 
A. 1.1 Overall code structure 
A. 1.2 Component instantiation 
A.2.1 Arithmetic operations 
A.2.2 Fixed-amount shift operations 
A.2 Combinational circuits 
402 
403 
403 
403 
403 
403 
403 
404 
404 
405 
405 
405 
406 
407 
408 
408 
408 
409 
409 
410 
410 
410 
41 1 
41 1 
413 
417 
417 
417 
417 
417 
417 
418 
41 9 
419 
419 
420 
42 1 
42 1 
422 

XViii 
CONTENTS 
A.2.3 Routing with concurrent statements 
A.2.4 
Routing with if and case statements 
A.2.5 Combinational circuit using process 
A.3.1 Register template 
A.3.2 
Register file 
A.4 
Regular sequential circuits 
A S  FSM 
A.6 FSMD 
A.7 
A.3 
Memory Components 
S3 board constraint file (s3. ucf) 
References 
422 
423 
424 
425 
425 
426 
427 
428 
430 
433 
437 
Topic Index 
439 

PREFACE 
HDL (hardware description language) and FPGA (field-programmable gate array) devices 
allow designers to quickly develop and simulate a sophisticated digital circuit, realize it 
on a prototyping device, and verify operation of the physical implementation. As these 
technologies mature, they have become mainstream practice. We can now use a PC and 
an inexpensive FPGA prototyping board to construct a complex and sophisticated digital 
system. This book uses a “learning by doing” approach and illustrates the FPGA and HDL 
development and design process by a series of examples. A wide range of examples is 
included, from a simple gate-level circuit to an embedded system with an 8-bit soft-core 
microcontroller and customized I/O peripherals. All examples can be synthesized and 
physically tested on a prototyping board. 
Focus and audience 
FOCUS The main focus of this book is on the effective derivation of hardware, not the 
syntax of HDL. Instead of explaining every language construct, the book is limited to a 
small synthesizable subset and uses about a dozen code templates to provide the skeletons 
of various types of circuits. These templates are general and can easily be integrated to 
construct a large, complex system. Although this approach limits the “freedom” of syntactic 
expression, it will not prevent us from developing innovative hardware architecture. Because 
of the generality and flexibility of HDL, the same circuit can usually be described by a 
wide variety of language constructs and coding styles. Many of these codes are intended 
for modeling. They may lead to unnecessarily complex hardware implementation and 
sometimes cannot be synthesized at all. The template approach actually forces us to think 
more about hardware and develop a good coding practice for synthesis. Since we are 
xix 

XX 
PREFACE 
more interested in hardware, it is more beneficial to spend time on developing 10 different 
hardware architectures with the same code template rather than describing the same circuit 
with 10 different versions of codes. 
There are two popular HDLs, VHDL and Verilog. Both languages are used widely and 
are IEEE standards. This book uses VHDL, and a separate book with a similar title uses 
Verilog. Despite the drastic syntactic differences in the two languages, their capabilities are 
very similar, particularly for our purposes. After we comprehend the design practice and 
coding methodology in one language, learning the other language is rather straightforward. 
Although the book is intended for beginning designers, the examples follow strict design 
guidelines and prepare readers for future endeavors. The coding and design practice is 
“forward compatible,” which means that: 
0 The same practice can be applied to large design in the future. 
0 The same practice can aid other system development tasks, including simulation, 
0 The same practice can be applied to ASIC technology and different types of FPGA 
0 The code can be accepted by synthesis software from different vendors. 
In summary, the book is a hands-on, hardware-centric text that involves minimal HDL 
overhead and follows good design and coding practice to achieve maximal forward com- 
parability. 
timing analysis, verification, and testing. 
devices. 
Audience and perquisites The book contains three major parts: basic digital circuits, 
peripheral modules, and embedded microcontroller. The intended audience is students in 
an introductory or advanced digital system design course as well as practicing engineers 
who wish to learn FPGA- and HDL-based development. For the materials in the first two 
parts, readers need to have a basic knowledge of digital systems, usually a required course 
in electrical engineering and computer engineering curricula. For the materials in the third 
part, prior exposure to assembly language programming will be helpful. 
Logistics 
Although a major goal of this book is to teach readers to develop software-independent 
and device-neutral HDL codes, we have to choose a software package and a prototyping 
board to synthesize and implement the design examples. The synthesis software and FPGA 
devices from Xilinx, a leading manufacture in this area, are used in the book. 
Software The synthesis software used in the book is the Web version of the Xilinx 
ZSE package. The functionality is of this version is similar to that of the full version but 
supports only a limited number of devices. Most introductory development boards use 
FPGA devices from the inexpensive Spartan-3 family. Since the Web version supports 
the Spartan-3 device, it fits our need. The simulation software used in the book is the 
starter version of Mentor Graphics’ ModelSim XE III package. It is a customized edition 
of ModelSim. Both software packages are free and can be downloaded from Xilinx’s Web 
site. 
FPGA prototyping board This book is prepared to be used with several entry-level 
FPGA prototyping boards manufactured by Digilent Inc., including the Spartan-3 Starter, 
Nexys-2, and Basys boards, all of which contain a Spartan-3/3E FPGA device and have 

PREFACE 
xxi 
similar I/O peripherals. The design examples in the book are based on the Spartan-3 Starter 
board (or simply the S3 board), but most of them can be used directly in other boards as 
well. The applicability of the HDL codes is summarized below. 
0 Spartan-3 Starter 3 (S3) board. The S3 board contains all the peripherals and 
no additional accessory module is needed. All HDL codes and discussions can be 
applied to this board directly. 
0 Nexys-2 board. The Nexys-2 board is a newer board, which contains a larger FPGA 
device and a larger memory chip. Its peripherals are similar to those in the S3 
board. There are two differences. First, the “color depth” of its VGA interface is 
expanded from 3 bits to 8 bits. The the output of the VGA interface circuits discussed 
in Chapters 12 and 13 needs to be modified accordingly. Second, it contains a 
more sophisticated external memory device. Although the device can be configured 
as an asynchronous SRAM, the timing characteristics is different from that of the 
S3 board’s memory device, and thus the HDL codes for the memory controller in 
Chapter 10 cannot be used directly. However, the same design principle can be 
applied to construct a new controller. 
0 Basys board. The Basys board is a simpler board. It lacks the RS-232 connector. 
To implement the UART module and the serial interface discussed in Chapter 7, we 
need Digilent’s RS-232 converterperipheral module. The Basys board has no external 
memory devices, and thus the discussion of the memory controller in Chapter 10 is 
not applicable. 
0 Other FPGA boards. Most peripherals discussed in this book are de facto industrial 
standards, and the corresponding HDL codes can be used as long as a board provides 
proper analog interface circuits and connectors. Except for the Xilinx-specific por- 
tions, the codes can be applied to the boards based on the FPGA devices from other 
manufacturers as well. 
PC Accessories The design examples include interfaces to several PC peripheral de- 
vices. A keyboard, a mouse, and a VGA monitor are required for the respective modules, 
and a “straight-through’’ serial cable (the most commonly used type) is required for the 
UART module. These accessories are widely available and can probably be obtained from 
an old PC. 
Book organization 
The book is divided into three major parts. Part I introduces the elementary HDL constructs 
and their hardware counterparts, and demonstrates the construction of a basic digital circuit 
with these constructs. It consists of six chapters: 
0 Chapter 1 describes the skeleton of an HDL program, basic language syntax, and 
logical operators. Gate-level combinational circuits are derived with these language 
constructs. 
0 Chapter 2 provides an overview of an FPGA device, prototyping board, and devel- 
opment flow. The development process is demonstrated by a tutorial on Xilinx ISE 
synthesis software and a tutorial on Mentor Graphics ModelSim simulation software. 
0 Chapter 3 introduces HDL‘s relational and arithmetic operators and routing constructs. 
These correspond to medium-sized components, such as comparators, adders, and 
multiplexers. Module-level combinational circuits are derived with these language 
constructs. 

xxii 
PREFACE 
0 Chapter 4 covers the codes for memory elements and the construction of “regular” 
sequential circuits, such as counters and shift registers, in which the state transitions 
exhibit a regular pattern. 
0 Chapter 5 discusses the construction of a finite state machine (FSM), which is a 
sequential circuit whose state transitions do not exhibit a simple, regular pattern. 
0 Chapter 6 presents the construction of an FSM with data path (FSMD). The FSMD is 
used to implement register transfer (RT) methodology, in which the system operation 
is described by data transfers and manipulations among registers. 
Part I1 applies the techniques from Part I to design an array of peripheral modules for the 
prototyping board. Each chapter covers the development, implementation, and verification 
of an individual peripheral. These modules can be incorporated to a larger project. Part I1 
consists of seven chapters: 
0 Chapter 7 discusses the design of a universal asynchronous receiver and transmitter 
(UART), which provides a serial link to receive and transmit data via the prototyping 
0 Chapter 8 covers the design of a keyboard interface, which reads scan code from a 
keyboard. The keyboard is connected via the prototyping board’s PS2 port. 
0 Chapter 9 covers the design of a mouse interface, which obtains the button and move- 
ment information from a mouse. The mouse is also connected via the prototyping 
board’s PS2 port. 
0 Chapter 10 discusses the implementation and timing issues of a memory controller. 
The controller is used to read data from and write data to the two static random access 
memory (SRAM) devices on the S3 board. 
0 Chapter 11 discusses the inference and application of Spartan-3 device-specific com- 
ponents. The focus is on the FF’GA’s internal memory blocks and the digital clock 
management (DCM) circuit. 
0 Chapter 12 presents the design and implementation of a video controller. The discus- 
sion covers the generation of video synchronization signals and shows the construc- 
tion of simple bit- and object-mapped graphical interface. The monitor is connected 
to the prototyping board’s VGA port. 
0 Chapter 13 continues development of the video controller. The discussion illustrates 
the construction of text interface and general tile-mapped scheme. 
Part I11 introduces an FPGA-based soft-core microcontroller, known as PicoBlaze, and 
demonstrates the integration of a general-purpose processor and customized circuit. It 
includes four chapters: 
0 Chapter 14 provides an overview of the organization and instruction set of PicoBlaze. 
0 Chapter 15 introduces the basic assembly programming and provides an overview of 
0 Chapter 16 discusses PicoBlaze’s I/O feature and illustrates the procedure to derive 
0 Chapter 17 discusses PicoBlaze’s interrupt capability and demonstrates the construc- 
In addition to regular chapters, the appendix summarizes and lists all code templates. 
board’s RS-232 port. 
the development process. 
customized circuits to interface other I/O peripherals. 
tion of a customized interrupt-handling circuit. 
Special mark#i1inx 8pecif ic While the examples of this book are implemented on a 
Xilinx-based prototyping board and the codes are synthesized by Xilinx ISE software, we 
try to make the HDL codes device-independent and software-neutral as much as possible. 
Most discussions and codes can be applied to different target devices and different synthesis 

PREFACE 
xxiii 
software as well. However, certain codes or device features are unique to Xilinx ISE 
software or Spartan-3 FPGA devices. We use the Xilinx spec@c superscript, as in the 
heading of this section, to indicate that the discussion in the corresponding section or 
chapter is unique to Xilinx. 
Similarly, we use marginal notes, such as the one shown on the outer edge, to indicate 
that the discussion in the paragraph is unique to Xilinx. This note indicates that the code Xilinx 
or design is no longer portable and needs to be revised when a different software package specific 
or target device is used. 
Instructional use 
The book can be a good companion text for an introductory digital systems course or 
an advanced project-oriented course. In an introductory digital systems course, the book 
supplies the lab portion of the curriculum. The chapters in Part I basically follow the 
sequence of a typical curriculum and can be presented along with regular lectures. One or 
two peripheral modules can be selected as case studies, and corresponding experiments can 
be used as term projects. 
In an advanced project-oriented course, the book provides a base for independent projects. 
The materials in Part I should be treated as an overview or refresher, which provides a general 
background on HDL, synthesis, and FPGA boards. Some modules in Part I1 can be used to 
demonstrate the design of more complex circuits. These modules can also be considered as 
building blocks (i.e., IPS) or subsystems to be integrated into final projects. The PicoBlaze 
microcontroller in Part I11 can be used as general-purpose processor if an embedded-system 
type of project is desired. 
Companion Web site 
An accompanying Web site (http : //academic. csuohio . edu/chu-p/rtl) provides addi- 
tional information, including the following materials: 
0 Errata 
0 Code templates 
0 HDL code listing and relevant files 
0 Links to synthesis and simulation software 
0 Links to referenced materials 
0 Additional project ideas 
Errata The book is self-prepared, which means that the author has produced all aspects 
of the text, including illustrations, tables, code listings, indexing, and formatting. As errors 
are always bound to happen, the accompanying Web site provides an updated errata sheet 
and a place to report errors. 
Cleveland, Ohio 
October 2007 

This Page Intentionally Left Blank

ACKNOWLEDGMENTS 
The author would like to express his gratitude to Professor George L. Kramerich for his 
encouragement and help. 
The author also thanks John Wiley & Sons, Inc. for giving permission to use Figures 3.1, 
3.2, 4.2, 4.10, 4.11, and 6.5 from my text RTL Hardware Design Using VHDL: Coding 
for EfJiciency, Portability, and Scalability, and Xilinx, Inc. for giving permission to use 
Figures 2.3 and 8.3 from the Spartan-3 Starter Kit Board User Guide. 
All trademarks used or referred to in this book are the property of their respective owners. 
P. P. Chu 
xxv 

This Page Intentionally Left Blank

PART I 
BASIC DIGITAL CIRCUITS 

This Page Intentionally Left Blank

CHAPTER 1 
GATE-LEVEL COMBINATIONAL CIRCUIT 
1.1 INTRODUCTION 
VHDL stands for “VHSIC (very high-speed integrated circuit) hardware description lan- 
guage.” It was originally sponsored by the U.S. Department of Defense and later transferred 
to the IEEE (Institute of Electrical and Electronics Engineers). The language is formally de- 
fined by IEEE Standard 1076. The standard was ratified in 1987 (referred to as VHDL 87), 
and revised several times. This book mainly follows the revision in 1993 (referred to as 
VHDL 93). 
VHDL is intended for describing and modeling a digital system at various levels and 
is an extremely complex language. The focus of this book is on hardware design rather 
than the language. Instead of covering every aspect of VHDL, we introduce the key VHDL 
synthesis constructs by examining a collection of examples. Detailed VHDL coverage may 
be explored through the sources listed in the Bibliography. 
In this chapter, we use a simple comparator to illustrate the skeleton of a VHDL pro- 
gram. The description uses only logical operators and represents a gate-level combinational 
circuit, which is composed of simple logic gates. In Chapter 3, we cover the more sophis- 
ticated VHDL operators and constructs and examine module-level combinational circuits, 
which are composed of intermediate-sized components, such as adders, comparators, and 
multiplexers. 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
1 

2 
GATE-LEVEL COMBINATIONAL CIRCUIT 
Table 1.1 Truth table of a 1-bit equality comparator 
input 
output 
iOil 
eq 
0 0  
1 
0 1  
0 
1 0  
0 
1 1  
1 
1.2 GENERAL DESCRIPTION 
Consider a 1-bit equality comparator with two inputs, i 0  and ii, and an output, eq. The 
eq signal is asserted when i0 and il are equal. The truth table of this circuit is shown in 
Table 1.1. 
Assume that we want to use basic logic gates, which include not, and, or, and xor cells, 
to implement the circuit. One way to describe the circuit is to use a sum-of-products format. 
The logic expression is 
eq = iO . il + iO’ . il’ 
One possible corresponding VHDL code is shown in Listing 1.1. We examine the language 
constructs and statements of this code in the following subsections. 
Listing 1.1 Gate-level implementation of a 1-bit comparator 
l i b r a r y  ieee; 
use i e e e . s t d - l o g i c - l l 6 4 . a l l ;  
e n t i t y  eql is 
port ( 
5 
i 0 ,  i l :  in std-logic; 
eq: out std-logic 
1 ;  
end eql; 
10 a r c h i t e c t u r e  sop-arch of eql i s  
s i g n a l  P O ,  p i :  std-logic; 
-- sum of t w o  p r o d u c t  t e r m s  
eq <= PO or p l ;  
1s 
-- p r o d u c t  t e r m s  
p 0  <= ( n o t  i0) and ( n o t  il); 
p l  <= i 0  and il; 
begin 
end sop-arch ; 
1.2.1 Basic lexical rules 
VHDL is case insensitive, which means that upper- and lowercase letters can be used 
interchangeably, and free formatting, which means that spaces and blank lines can be 
inserted freely. It is good practice to add proper spaces to make the code clear and to associate 
special meaning with cases. In this book, we reserve uppercase letters for constants. 

GENERAL DESCRIPTION 
3 
An identiJier is the name of an object and is composed of 26 letters, digits, and the 
underscore (-), as in i0, i l ,  and data-busl-enable. The identifier must start with a letter. 
The comments start with -- and the text after it is ignored. In this book, the VHDL 
keywords are shown in boldface type, as in entity, and the comments are shown in italics 
type, as in 
__ t h i s  is a comment 
1.2.2 Library and package 
The first two lines, 
l i b r a r y  ieee; 
use ieee. std-logic-1164, a l l  ; 
invoke the std-logic-1164 package from the ieee library. The package and library allow 
us to add additional types, operators, functions, etc. to VHDL. The two statements are 
needed because a special data type is used in the code. 
1.2.3 Entity declaration 
The entity declaration 
e n t i t y  eql is 
port ( 
i0, i l :  in std-logic; 
e q :  out std-logic 
) ;  
end e q l ;  
essentially outlines the I/O signals of the circuit. The first line indicates that the name of 
the circuit is eql, and the port section specifies the I/O signals. The basic format for an I/O 
port declaration is 
signal-namel, signal-name2, . . .  : mode data-type; 
The mode term can be in or out, which indicates that the corresponding signals flow “into” 
or “out of” of the circuit. It can also be inout, for bidirectional signals. 
1.2.4 Data type and operators 
VHDL is a strongly typed language, which means that an object must have a data type and 
only the defined values and operations can be applied to the object. Although VHDL is rich 
in data types, our discussion is limited to a small set of predefined types that are suitable 
for synthesis, mainly the std-logic type and its variants. 
std-logic type The std-logic type is defined in the std-logic-I164 package and 
consists of nine values. Three of the values, ’ 0 ’ , ’ I ’ , and ’ Z ’ , which stand for logical 0, 
logical 1, and high impedance, can be synthesized. Two values, ’U’ and ’X’ , which stand 
for “uninitialized” and “unknown” (e.g., when signals with ’ 0’ and ’ 1 ’ values are tied 
together), may be encountered in simulation. The other four values, ’ - ’ , ’ H’ , ’ L ’ , and 
’ W ’, are not used in this book. 

4 
GATE-LEVEL COMBINATIONAL CIRCUIT 
A signal in a digital circuit frequently contains multiple bits. The std-logic-vector 
data type, which is defined as an array with elements of std-logic, can be used for this 
purpose. For example, let a be an 8-bit input port. It can be declared as 
a :  in std-logic-vector ( 7  downto 0 )  ; 
We can use term like a (7 downto 4) to specify a desired range and term like a ( 1) to access 
a single element of the array. The array can also be declared in ascending order: 
a :  in std-logic-vector(0 to 7 ) ;  
We generally avoid this format since it is more natural to associate the MSB with the leftmost 
position. 
Logical operators Several logical operators, including not, and, or, and xor, are de- 
fined over the std-logic-vector and std-logic data type. Bit-wise operation is used 
when an operator is applied to an object with the std-logic-vector data type. Note that 
the and, or, and xor operators have the same precedence and we need to use parentheses 
to specify the desired order of evaluation, as in 
( a  and b) or (c and d) 
1.2.5 Architecture body 
The architecture body, 
a r c h i t e c t u r e  sop-arch of eql i s  
s i g n a l  PO, p l :  std-logic; 
begin 
-- sum of two p r o d u c t  terms 
eq <= PO or p l ;  
-- p r o d u c t  terms 
PO <= ( n o t  i0) and ( n o t  il); 
p l  <= i0 and il; 
end sop-arch ; 
describes operation of the circuit. VHDL allows multiple bodies associated with an entity, 
and thus the body is identified by the name sop-arch (“sum-of-products architecture”). 
The architecture body may include an optional declaration section, which specifies con- 
stants, internal signals, and so on. Two internal signals are declared in this program: 
s i g n a l  PO, p l :  std-logic; 
The main description, encompassed between begin and end, contains three concurrent 
statements. Unlike a program in C language, in which the statements are executed sequen- 
tially, concurrent statements are like circuit parts that operate in parallel. The signal on the 
left-hand side of a statement can be considered as the output of that part, and the expression 
specifies the circuit function and corresponding input signals. For example, consider the 
statement 
eq <= PO or p l ;  
It is a circuit that performs the or operation. When PO or p i  changes its value, this statement 
is activated and the expression is evaluated. The new value is assigned to eq after the default 
propagation delay. 

GENERAL DESCRIPTION 
5 
(not i0) and (not il) 
PO or p l  
Figure 1.1 Graphical representation of a comparator program. 
The graphical representation of this program is shown in Figure 1.1. The three circuit 
parts represent the three concurrent statements. The connections among these parts are 
implicitly specified by the signal and port names. The order of the concurrent statements 
is clearly irrelevant and the statements can be rearranged arbitrarily. 
1.2.6 Code of a 2-bit comparator 
We can expand the comparator to 2-bit inputs. Let the input be a and b and the output be 
aeqb. The aeqb signal is asserted when both bits of a and b are equal. The code is shown 
in Listing 1.2. 
Listing 1.2 Gate-level implementation of a 2-bit comparator 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
e n t i t y  eq2 i s  
port ( 
a ,  b :  in s t d - l o g i c - v e c t o r ( 1  downto 0 ) ;  
a e q b :  out s t d - l o g i c  
) ;  
end e q 2 ;  
1 0  a r c h i t e c t u r e  s o p - a r c h  of eq2 i s  
s i g n a l  p O , p l , p 2 , p 3 :  s t d - l o g i c ;  
-- sum of p r o d u c t  t e r m s  
a e q b  <= PO or p l  or p2 or p 3 ;  
PO 
<= ( ( n o t  a ( 1 ) )  and ( n o t  b ( 1 ) ) )  and 
p l  <= ( ( n o t  a ( 1 ) )  and ( n o t  b ( 1 ) ) )  and ( a ( 0 )  and b ( 0 ) ) ;  
p2 <= ( a ( 1 )  and b ( 1 ) )  and ( ( n o t  a ( 0 ) )  and ( n o t  b ( 0 ) ) ) ;  
begin 
I5 
-- p r o d u c t  t e r m s  
( ( n o t  a ( 0 ) )  and ( n o t  b ( 0 ) ) ) ;  
x 
p3 <= ( a ( 1 )  and b ( 1 ) )  and ( a ( 0 )  and b ( 0 ) ) ;  
end s o p - a r c h ;  
The a and b ports are now declared as a two-element std-logic-vector. Derivation 
of the architecture body is similar to that of a 1-bit comparator. The PO, p i ,  p2, and p3 
signals represent the results of the four product terms, and the final result, aeqb, is the logic 
expression in sum-of-products format. 

6 
GATE-LEVEL COMBINATIONAL CIRCUIT 
Figure 1.2 Construction of a 2-bit comparator from 1-bit comparators. 
1.3 STRUCTURAL DESCRIPTION 
A digital system is frequently composed of several smaller subsystems. This allows us to 
build a large system from simpler or predesigned components. VHDL provides a mecha- 
nism, known as component instantiation, to perform this task. This type of code is called 
structural description. 
An alternative to the design of the 2-bit comparator of Section 1.2.6 is to utilize the 
previously constructed 1-bit comparators as the building blocks. The diagram is shown in 
Figure 1.2, in which two 1-bit comparators are used to check the two individual bits and 
their results are fed to an and cell. The aeqb signal is asserted only when the two bits are 
equal. 
The corresponding code is shown in Listing 1.3. Note that the entity declaration is the 
same and thus is not included. 
Listing 1.3 Structural description of a 2-bit comparator 
a r c h i t e c t u r e  struc-arch of eq2 i s  
begin 
s i g n a l  e O ,  e l :  std-logic; 
_- 
i n s t a n t i a t e  two 1 - b i t  
c o m p a r a t o r s  
5 
eq-bit0-unit : e n t i t y  w o r k .  eql (sop-arch) 
eq-bitl-unit : e n t i t y  w o r k .  eql (sop-arch) 
-- a and b a r e  e q u a l  i f  i n d i v i d u a l  b i t s  a r e  e q u a l  
port map(iO=>a(O), il=>b(O), eq=>eO); 
port m a p ( i O = > a ( l ) ,  il=>b(i), eq=>el); 
KI 
aeqb <= eO and e l ;  
end struc-arch; 
The code includes two component instantiation statements, whose syntax is: 
unit-label : e n t i t y  lib-name. entity-name (arch-name) 
port map( 
formal-signal=>actual-signal, 
f ormal-s ignal=> actual-s ignal , 
) ;  
The first portion of the statement specifies which component is used. The unit-label term 
gives a unique id for an instance, the libname term indicates where (i.e., which library) the 
component resides, and the entityname and archname terms indicate the names of the 

STRUCTURAL DESCRIPTION 
7 
entity and architecture. The archname term is optional. If it is omitted, the last compiled 
architecture body will be used. The second portion is port mapping, which indicates the 
connection between formal signals, which are I/O ports declared in a component’s entity 
declaration, and actual signals, which are the signals used in the architecture body. 
The first component instantiation statement is 
e q - b i t 0 - u n i t  : e n t i t y  work. e q l  ( s o p - a r c h )  
p o r t  m a p ( i O = > a ( O ) ,  i l = > b ( O ) ,  eq=>eO) ; 
The work library is the default library in which the compiled entity and architecture units 
are stored, and eql and sop-arch are the names of the entity and architecture defined in 
Listing 1.1. The port mapping reflects the connections shown in Figure 1.2. The compo- 
nent instantiation statement is also a concurrent statement and represents a circuit that is 
encompassed in a “black box” whose function is defined in another module. 
This example demonstrates the close relationship between a block diagram and code. 
The code is essentially a textual description of a schematic. Although it is a clumsy way for 
humans to comprehend a diagram, it puts all representations into a single HDL framework. 
The Xilinx ISE package includes a simple schematic editor utility that can perform schematic Xilinx 
capture in graphic format and then convert the diagram into an HDL structural description. specific 
The component instantiation statement is added in VHDL 93. Older codes may use the 
mechanism in VHDL 87, in which a component must first be declared (i.e., made known) 
and then used. The code in this format is shown in Listing 1.4. 
Listing 1.4 Structural description with VHDL-87 
a r c h i t e c t u r e  vhd-87-arch 
of eq2 i s  
_- 
c o m p o n e n t  d e c 1 a r a t i  o n 
component e q l  
p o r t  ( 
i 0 ,  i l :  in s t d - l o g i c ;  
e q :  o u t  s t d - l o g i c  
) ;  
end component ; 
s i g n a l  e O ,  e l :  s t d - l o g i c ;  
__ i n s t a n t i a t e  two 1 - b i t  
c o m p a r a t o r s  
e q - b i t 0 - u n i t  : e q l  
-- u s e  t h e  d e c l a r e d  n a m e ,  e q l  
e q - b i t l - u n i t  : e q l  
-- u s e  t h e  d e c l a r e d  n a m e ,  e q l  
-- a and b a r e  e q u a l  
if 
i n d i v i d u a l  b i t s  a r e  e q u a l  
aeqb <= eO and e l ;  
10 begin 
p o r t  m a p ( i O = > a ( O ) ,  i l = > b ( O ) ,  e q = > e O ) ;  
I 5  
p o r t  m a p ( i O = > a ( l ) ,  i l = > b ( l ) ,  e q = > e l ) ;  
end vhd-87-arch; 
Note that the original clause, 
e q - b i t 0 - u n i t  : e n t i t y  work. e q l  ( s o p - a r c h )  
is replaced by a clause with the declared component name 
e q - b i t 0 - u n i t :  e q l  

8 
GATE-LEVEL COMBINATIONAL CIRCUIT 
test vector generator 
test-out 
- 
test-in-0 
aeqb 
a 
b 
test-in-l 
eq2 
monitor 
- 
Figure 1.3 Testbench for a 2-bit comparator. 
1.4 TESTBENCH 
After code is developed, it can be simulated in a host computer to verify the correctness 
of the circuit operation and can be synthesized to a physical device. Simulation is usually 
performed within the same HDL framework. We create a special program, known as a 
testbench, to mimic a physical lab bench. The sketch of a 2-bit comparator testbench 
program is shown in Figure 1.3. The uut block is the unit under test, the t e s t  vector 
generator block generates testing input patterns, and the monitor block examines the 
output responses. 
A simple testbench for the 2-bit comparator is shown in Listing 1.5. 
Listing 1.5 Testbench for a 2-bit comparator 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
e n t i t y  e q 2 - t e s t b e n c h  
i s  
end e q 2 - t e s t b e n c h ;  
a r c h  i t  e c t u r e t b- a r  c h of eq2- t e s t bench i s  
5 
s i g n a l  t e s t - i n 0  , t e s t - i n 1  : s t d - l o g i c - v e c t o r  (1 downto 0) ; 
s i g n a l  t e s t - o u t  : s t d - l o g i c ;  
begin 
10 
-- i n s t a n t i a t e  t h e  c i r c u i t  u n d e r  t e s t  
u u t :  e n t i t y  w o r k .  e q 2 ( s t r u c _ a r c h )  
__ t e s t  v e c t o r  g e n e r a t o r  
p r o c e s s  
p o r t  r n a p ( a = > t e s t - i n O ,  b = > t e s t - i n 1  , a e q b = > t e s t - o u t )  ; 
15 
begin 
t e s t  v e c t o r  I 
__ 
t e s t - i n 0  <= " 0 0 " ;  
20 
t e s t - i n 1  <= " 0 0 "  
w a i t  f o r  200 n s ;  
__ t e s t  v e c t o r  2 
t e s t - i n 0  <= " 0 1 "  
t e s t - i n 1  <= " 0 0 "  
w a i t  f o r  200 n s ;  
t e s t  v e c t o r  3 
t e s t - i n 0  <= " 0 1 " ;  
t e s t - i n 1  <= "11"; 
w a i t  f o r  200 n s ;  
__ t e s t  v e c t o r  4 
__ 
25 

BIBLIOGRAPHIC NOTES 
9 
30 
35 
10 
test-in0 <= "10" 
test-in1 <= " 1 0 "  
w a i t  for 200 ns; 
t e s t  v e c t o r  5 
test-in0 <= " 1 0 "  
test-in1 <= "00" 
w a i t  for 200 n s ;  
__ t e s t  v e c t o r  6 
test-in0 <= " 1 1 "  
test-in1 <= "11" 
w a i t  for 200 ns; 
__ t e s t  v e c t o r  7 
test-in0 <= " 1 1 "  
__ 
test-in1 <= "01"; 
w a i t  for 200 ns; 
end p r o c e s s ;  
4s end tb-arch; 
The code consists of a component instantiation statement, which creates an instance of a 
2-bit comparator, and a process statement, which generates a sequence of test patterns. 
The process statement is a special VHDL construct in which the operations are performed 
sequentially. Each test pattern is generated by three statements. For example, 
t e s t  v e c t o r  2 
__ 
test-in0 <= "01"; 
test-in1 <= "00"; 
w a i t  for 200 ns; 
The first two statements specify the values for the test-in0 and test-in1 signals, and 
the third indicates that the two values will last for 200 ns. 
The code has no monitor. We can observe the input and output waveforms on a simulator's 
display, which can be treated as a "virtual logic analyzer." The simulated timing diagram 
of this testbench is shown in Figure 2.16. 
Writing code for a comprehensive test vector generator and a monitor requires detailed 
knowledge of VHDL and is beyond the scope of this book. This listing can serve as a 
testbench template for other combinational circuits. We can substitute the uut instance and 
modify the test patterns according to the new circuit. 
1.5 BIBLIOGRAPHIC NOTES 
A short bibliographic section appears at the end of each chapter to provide some of the most 
relevant references for further exploration. A comprehensive bibliography is included at 
the end of the book. 
VHDL is a complex language. The Designer's Guide to VHDL by P. J. Ashenden 
provides detailed coverage of the language's syntax and constructs. The author's RTL 
Hardware Design Using VHDL: Coding for EfJiciency, Portability, and Scalability provides 
a comprehensive discussion on developing effective, synthesizable codes. The derivation of 
the testbench for a large digital system is a difficult task. Writing Testbenches: Functional 
VeriJication of HDL Models, 2nd edition, by J. Bergeron focuses on this topic. 

10 
GATE-LEVEL COMBINATIONAL CIRCUIl 
1.6 SUGGESTED EXPERIMENTS 
At the end of each chapter, some experiments are suggested as exercises. The experiments 
help us to better understand the concepts and provide a hands-on opportunity to design and 
debug actual circuits. 
1.6.1 
Develop the HDL codes in Experiment 2.9.1. The code can be simulated and synthesized 
after we complete Chapter 2. 
Code for gate-level greater-than circuit 
1.6.2 Code for gate-level binary decoder 
Develop the HDL codes in Experiment 2.9.2. The code can be simulated and synthesized 
after we complete Chapter 2. 

CHAPTER 2 
OVERVIEW OF FPGA AND EDA 
SOFTWARE 
2.1 INTRODUCTION 
Developing a large FPGA-based system is an involved process that consists of many com- 
plex transformations and optimization algorithms. Software tools are needed to automate 
some of the tasks. We use the Web version of the Xilinx ISE package for synthesis and 
implementation, and use the starter version of Mentor Graphics ModelSim XE III package 
for simulation. In this chapter, we give a brief overview of the FPGA device and the S3 
prototyping board, and provide short tutorials for the two software packages to “jump-start” 
the learning process. 
2.2 FPGA 
2.2.1 Overview of a general FPGA device 
AJield programmable gate array (FPGA) is a logic device that contains a two-dimensional 
array of generic logic cells and programmable switches. The conceptual structure of an 
FPGA device is shown in Figure 2.1. A logic cell can be configured (i.e., programmed) 
to perform a simple function, and a programmable switch can be customized to provide 
interconnections among the logic cells. A custom design can be implemented by specifying 
the function of each logic cell and selectively setting the connection of each programmable 
switch. Once the design and synthesis is completed, we can use a simple adaptor cable to 
download the desired logic cell and switch configuration to the FPGA device and obtain the 
FPGA ProtoQping bj VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
11 

12 
OVERVIEW OF FPGA AND EDA SOFTWARE 
S 
programmable switch 
Figure 2.1 Conceptual structure of an FPGA device. 
a b c  y 
0 0 0  0 
0 0 1  
1 
0 1 0  
1 
0 1 1  0 
1 0 0  1 
1 0 1  0 
1 1 0  0 
1 1 1  1 
(a) Conceptual diagram 
(b) Example table 
Figure 2.2 Three-input LUT-based logic cell 
custom circuit. Since this process can be done "in the field" rather than "in a fabrication 
facility (fab)," the device is known asjeldprograrnrnable. 
LUT-based logic cell A logic cell usually contains a small configurable combinational 
circuit with a D-type flip-flop (D FF). The most common method to implement a configurable 
combinational circuit is a look-up table (LUT). An n-input LUT can be considered as a 
small 2"-by-1 memory. By properly writing the memory content, we can use the LUT 
to implement any n-input combinational function. The conceptual diagram of a three- 
input LUT-based logic cell is shown in Figure 2.2(a). An example of three-input LUT 
implementation of a @ b 
c is shown in Figure 2.2(b). Note that the output of the LUT 

OVERVIEW OF THE DIGILENT s3 BOARD 
13 
can be used directly or stored to the D FF. The latter can be used to implement sequential 
circuits. 
Macro cell Most FPGA devices also embed certain macro cells or macro blocks. These 
are designed and fabricated at the transistor level, and their functionalities complement the 
general logic cells. Commonly used macro cells include memory blocks, combinational 
multipliers, clock management circuits, and I/O interface circuits. Advanced FPGA devices 
may even contain one or more prefabricated processor cores. 
2.2.2 Overview of the Xilinx Spartan-3 devices 
This book uses Xilinx Spartan-3 family FPGA devices. Based on the ratio between the num- 
ber of logic cells and the I/O counts, the family is further divided into several subfamilies. 
Our discussion applies to all the subfamilies. 
Logic cell, slice, and CL5 The most basic element of the Spartan-3 device is a logic 
cell (LC), which contains a four-input LUT and a D FF, similar to that in Figure 2.2. 
In addition, a logic cell contains a carry circuit, which is used to implement arithmetic 
functions, and a multiplexing circuit, which is used to implement wide multiplexers. The 
LUT can also be configured as a 16-by-1 static random access memory (SRAM) or a 16-bit 
shift register. 
To increase flexibility and improve performance, eight logic cells are combined together 
with a special internal routing structure. In Xilinx terms, two logic cells are grouped to 
form a slice, and four slices are grouped to form a conjgurable logic block (CLB). 
Macro cell The Spartan-3 device contains four types of macro blocks: combinational 
multiplier, block RAM, digital clock manager (DCM), and input/output block (IOB). The 
combinational multiplier accepts two 18-bit numbers as inputs and calculates the product. 
The block RAM is an 18K-bit synchronous SRAM that can be arranged in various types 
of configurations. A DCM uses a digital-delayed loop to reduce clock skew and to control 
the frequency and phase shift of a clock signal. An IOB controls the flow of data between 
the device’s I/O pins and the internal logic. It can be configured to support a wide variety 
of IiO signaling standards. 
Devices in the Spartan-3 subfamily Althopugh Spartan-3 FPGA devices have sim- 
ilar types of logic cells and macro cells, their densities differ. Each subfamily contains an 
array of devices of various densities. The numbers of LCs, block RAMS, multipliers, and 
DCMs of the devices from the Spartan-3 subfamily are summarized in Table 2.1. 
2.3 OVERVIEW OF THE DlGlLENT S3 BOARD 
The Digilent S3 board is based on a Spartan-3 device (usually an XC3S200) and has an 
array of built-in peripherals. The simplified layouts of the board are shown in Figure 2.3(a) 
and (b). The main components and connectors are as follows: 
1. Xilinx Spartan-3 XC3S200 FPGA device (XC3S2OOFT256) 
2. 2M-bit Xilinx XCF02S platform flash configuration PROM 
3. Jumper to select the configuration source 
4. Two 256K-by-16 asynchronous SRAM devices (ISSI IS61LV25616AL-lOT). 

14 
OVERVIEW OF FPGA AND EDA SOFTWARE 
(a) Top view 
(b) Bottom view 
Figure 2.3 
reserved.) 
Layout of an S3 board. (Courtesy of Xilinx, Inc. 0 
Xilinx, Inc. 1994-2007. All rights 

DEVELOPMENT FLOW 
15 
Table 2.1 Devices in the Spartan-3 family 
Device 
Number of 
Number of 
LCS 
block RAMS 
xc3s50 
x c 3  s 200 
xc3s400 
xc3s1000 
xc3s1500 
xc3s2000 
xc3s4000 
xc3s5000 
1,728 
4,320 
8,064 
17,280 
29,952 
46,080 
62,208 
74,880 
4 
12 
16 
24 
32 
40 
96 
104 
Block 
RAM bits 
72K 
216K 
288K 
432K 
576K 
720K 
1,728K 
1,872K 
Number of 
multipliers 
Number of 
DCMs 
4 
12 
16 
24 
32 
40 
96 
104 
5. VGA display port 
6. RS-232 serial port 
7. RS-232 transceiver/voltage-level convertor 
8. Second RS-232 transmit and receive channel 
9. PSI2 mouselkeyboard port 
10. Four-digit seven-segment LED display 
11. Eight slide switches 
12. Eight discrete LED outputs 
13. Four momentary-contact pushbutton switches 
14. 50-MHz crystal oscillator clock source 
15. Socket for an auxiliary crystal oscillator clock source 
16. Jumper to select an FPGA configuration mode 
17. Pushbutton switch to force FPGA reconfiguration 
18. LED to indicate whether the FPGA is successfully configured 
19. 40-pin expansion connector 1 (labeled B1) 
20. 40-pin expansion connector 2 (labeled A2) 
21. 40-pin expansion connector 3 (labeled Al) 
22. JTAG connector for Digilent download cable. 
23. Digilent low-cost download cable (included in the S3 kit but not shown in Figure 2.3) 
24. JTAG port (to be used with the Xilinx Parallel Cable IV and MultiPRO Desktop Tool, 
25. Power connector for an unregulated 5-V power supply (included in the S3 kit) 
26. Power-on LED indicator 
27. 3.3-V voltage regulator 
28. 2.5-V voltage regulator 
29. 1.2-V voltage regulator 
30. Selector for PS2 port voltage supply (3.3 or 5 V) 
which are not included in the S3 kit) 
2.4 DEVELOPMENT FLOW 
The simplified development flow of an FPGA-based system is shown in Figure 2.4. To 
facilitate further reading, we follow the terms used in the Xilinx documentation. The 
left portion of the flow is the refinement and programming process, in which a system is 
transformed from an abstract textual HDL description to a device cell-level configuration 

16 
OVERVIEW OF FPGA AND EDA SOFTWARE 
/-/ input file 
pLq 
constraint goa 
0 
testbench 
/7 
I 
I 
synthesis 
0 
simulation 
r - - - - -  
+
+
 
I 
I 
I functional 
1 
I simulation I 
programming 
L - - - - l  
Q 
FPGA 
chip 
Figure 2.4 Development flow. 
and then downloaded to the FPGA device. The right portion is the validation process, which 
checks whether the system meets the functional specification and performance goals. The 
major steps in the flow are: 
1. Design the system and derive the HDL file(s). We may need to add a separate 
constraint file to specify certain implementation constraints. 
2. Develop the testbench in HDL and perform RTL simulation. The RTL term reflects 
the fact that the HDL code is done at the register transfer level. 
3. Perform synthesis and implementation. The synthesis process is generally known as 
logic s.ynthesis, in which the software transforms the HDL constructs to generic gate- 
level components, such as simple logic gates and FFs. The implementation process 
consists of three smaller processes: translate, map, and place and route. The translate 
process merges multiple design files to a single netlist. The map process, which 
is generally known as technology mapping, maps the generic gates in the netlist to 
FPGAs logic cells and IOBs. The place and route process, which is generally known 
as placement and routing, derives the physical layout inside the FPGA chip. It places 
the cells in physical locations and determines the routes to connect various signals. In 
the Xilinx flow, static timing analysis, which determines various timing parameters, 
such as maximal propagation delay and maximal clock frequency, is performed at 
the end of the implementation process. 
4. Generate and download the programming file. In this process, a configuration file is 
generated according to the final netlist. This file is downloaded to an FPGA device 
serially to configure the logic cells and switches. The physical circuit can be verified 
accordingly. 

OVERVIEW OF THE XILINX ISE PROJECT NAVIGATOR 
17 
The optional functional simulation can be performed after synthesis, and the optional 
timing sirnulation can be performed after implementation. Functional simulation uses a 
synthesized netlist to replace the RTL description and checks the correctness of the synthesis 
process. Timing simulation uses the final netlist, along with detailed timing data, to perform 
simulation. Because of the complexity of the netlist, functional and timing simulation may 
require a significant amount of time. If we follow good design and coding practices, the HDL 
code will be synthesized and implemented correctly. We only need to use RTL simulation 
to check the correctness of the HDL code and use static timing analysis to examine the 
relevant timing information. Both functional and timing simulations can be omitted from 
the development flow. 
2.5 OVERVIEW OF THE XlLlNX ISE PROJECT NAVIGATOR 
Xilinx ISE (integrated software environment) controls all aspects of the development flow. 
Project Navigator is a graphical interface for users to access software tools and relevant files 
associated with the project. We use it to launch all development tasks except ModelSim 
simulation. The discussion in this section and the tutorial in the next section are based on 
ISE WebPack version 8.2. 
The default ISE window is shown in Figure 2.5. It is divided into four subwindows: 
0 Sources window (top left): hierarchically displays the files included in the project 
0 Processes window (middle left): displays available processes for the source file cur- 
0 Transcript window (bottom): displays status messages, errors, and warnings 
0 Workplace window (top right): contains multiple document windows (such as HDL 
Each subwindow may be resized, moved, docked, or undocked. The default layout can be 
restored by selecting View + Restore. Note that a subwindow may contain multiple pages. 
The tabs at the bottom are used to select the desired page. 
rently selected 
code, report, schematic, and so on) for viewing and editing 
Sources window The sources window is used mainly to display files associated with the 
current project. A typical source window, which corresponds to the design of Listing 2.2, 
is shown in Figure 2.6. The top drop-down list, labeled Sources for:, specifies the current 
design view. The synthesis/implementation view should be selected since we use ISE 
only for synthesis and implementation, 
There are three tabs at the bottom, labeled Sources, Snapshots, and Libraries. The 
Sources tab displays the project name, the FPGA device specified, and user documents 
and design files. The modules are displayed according to the internal design hierarchy. In 
Figure 2.6, the eq2 and eql entities reflect the hierarchy of Listing 2.2. The eq2 module 
also includes the eq-s3. ucf file, which specifies the constraints of the design. We can open 
a file in the workplace window by double-clicking the corresponding module. A top-level 
module icon can be placed next to a module, as in the eq2 module, to invoke synthesis and 
implementation for this particular module. 
The Snapshots tab displays project’s “snapshots,” which are copies of previously stored 
project files. The Libraries tab shows all libraries associated with the project. 
Processes window The processes window displays the processes available. The dis- 
play is context sensitive and the available processes are based on source type selected in 
the sources window. For example, the eq2 module, which is set as the top-level module, 

18 
OVERVIEW OF FPGA AND EDA SOFTWARE 
Figure 2.5 Typical ISE window. 

SHORT TUTORIAL ON ISE PROJECT NAVIGATOR 
19 
Figure 2.6 Typical source window. 
is selected in Figure 2.6. The available processes are displayed in the processes window, 
as shown in Figure 2.7, Some processes may also contain several subprocesses. We can 
initiate a process by clicking on the corresponding icon. ISE incorporates the “auto make” 
technology, which automatically runs the processes necessary to get to the desired step. 
For example, when we initiate the Generate Programming File process, ISE automatically 
invokes the Synthesize and Implement Design processes since file generation is dependent 
on the implementation result, which, in turn, is dependent on the synthesis result. 
Transcript window The transcript window is used to display the progress of a process 
and relevant messages. The Console page displays errors, warnings, and information mes- 
sages. An error is signified by a red X mark next to the message and a warning is signified by 
a yellow ! mark. The Warnings and Errors pages display only warning and error messages. 
Workplace window The workplace window is for users to view and edit various types 
of files. We use it to perform two main tasks. The first task is to view and edit the HDL 
and constraint files. The default editor is the ZSE Text Editor, which is a simple text editor 
with features to assist creation of the HDL code. The second task is to check the design 
summary and various reports. 
2.6 SHORT TUTORIAL ON ISE PROJECT NAVIGATOR 
Xilinx ISE consists of an array of software tools, but detailed discussion of their use is 
beyond the scope of this book. We present a short tutorial in this section to illustrate the 
basic development process. There are four major steps: 
1. Create the design project and HDL codes. 
2. Create a testbench and perform RTL simulation. 
3. Add a constraint file and synthesize and implement the code. 
4. Generate and download the configuration file to an FPGA device. 
These steps follow the general development flow discussed in Section 2.4. 
We use the 2-bit comparator discussed in Chapter 1 in the tutorial. The codes are repeated 
in Listings 2.1 and 2.2. 

20 
OVERVIEW OF FPGA AND EDA SOFTWARE 
Figure 2.7 Typical processes window. 
Listing 2.1 Gate-level implementation of a 1 -bit comparator 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
e n t i t y  e q l  i s  
port ( 
5 
i 0 ,  i l :  in s t d - l o g i c ;  
e q :  out s t d - l o g i c  
1 ;  
end e q l ;  
1 0  a r c h i t e c t u r e  s o p - a r c h  of e q l  i s  
s i g n a l  PO, p l :  s t d - l o g i c ;  
__ sum of t"o 
p r o d u c t  t e r m s  
eq <= PO or p l ;  
i s  
-- p r o d u c t  t e r m s  
p0 <= ( n o t  i 0 )  and ( n o t  i l ) ;  
p l  <= i0 and i l ;  
begin 
end s o p - a r c h ;  
Listing 2.2 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
e n t i t y  eq2 i s  
Structural description of a 2-bit comparator 

SHORT TUTORIAL ON ISE PROJECT NAVIGATOR 
21 
p o r t  ( 
5 
a ,  b :  i n  s t d - l o g i c - v e c t o r ( 1  downto 0 ) ;  
a e q b :  o u t  s t d - l o g i c  
) ;  
end e q 2 ;  
10 a r c h i t e c t u r e  s t r u c - a r c h  of eq2 i s  
s i g n a l  eO, e l :  s t d - l o g i c ;  
-- i n s t a n t i a t e  two I -  b i t  c o m p a r a t o r s  
e q - b i t 0 - u n i t  : e n t i t y  w o r k . e q l ( s o p - a r c h )  
e q - b i t l - u n i t  : e n t i t y  work. e q l  ( s o p - a r c h )  
-- a and b a r e  e q u a l  
if 
i n d i v i d u a l  b i t s  a r e  e q u a l  
aeqb <= eO and e l ;  
begin 
I S  
p o r t  map(iO=>a(O) , i l = > b ( O ) ,  e q = > e O ) ;  
p o r t  m a p ( i O = > a ( l ) ,  i l = > b ( l ) ,  e q = > e l ) ;  
20 end s t r u c - a r c h ;  
2.6.1 Create the design project and HDL codes 
There are three tasks in this step: 
0 Create a project. 
0 Add or create HDL files. 
0 Check the HDL syntax. 
Create a project An ISE project contains basic information of a design, which includes 
the source files and a target device. A new project can be created as follows: 
1. Select Start + All Programs + Xilinx ISE + Project Navigator (or wherever ISE resides) 
to launch the ISE project navigator. 
2. In Project Navigator, select File + New Project. The New Project Wizard - Create 
New project dialog appears. Enter the project name as eq2 and the location, and 
verify that HDL is selected in the Top-level Source Type field. Click Next. 
3. The New Project Wizard - Device Properties dialog appears. We need to enter the 
desired target device in this dialog. This information can be found in FPGA board 
manual or by checking the marking on the top of the FPGA chip. For a typical S3 
board, select the following: 
0 Product Category: All 
0 Family: Spartan3 
0 Device: XC3S200 
0 Package: FT256 
0 Speed: -4 
0 Synthesis Tool: XST (VHDL/Verilog) 
We also need to verify that the Xilinx XST software is selected for synthesis: 
4. Click Next a few times to go through the remaining dialogs and then click Finish to 
After a project is created, we can create or add the relevant HDL files and a constraint file. 
Create a new HDL file If a file does not exist, we must create a new source file. The 
procedure to create a new HDL file is: 
complete the creation. 

22 
OVERVIEW OF FPGA AND EDA SOFTWARE 
1. Select Project + New Source. The New Source Wizard - Select Source Type dialog 
appears. Select VHDL Module and type the file name, eq2. Click Next. 
2. The next dialog appears. This dialog allows us to enter port names. These names are 
then later embedded in the HDL code. Enter the 1/0 port information according to 
Listing 2.2. Click Next. 
3. Click Finish and a new HDL text editor window appears in the workplace window. 
The software automatically generates the HDL skeleton, which includes a comment 
header, library clauses, an entity declaration, and an empty architecture body. 
4. By default, ISE version 8.2 generates the following library clauses: 
use 1EEE.STD-LOGIC-ARITH.ALL; 
use IEEE. STD-LOGIC-UNSIGNED .ALL 
The two libraries are not IEEE standard and should be replaced with 
use i e e e .  numeric-std. a l l  ; 
This issue is explained in Section 3.2.2. 
5. Use the editor to enter the HDL code in Listing 2.2 and save the file. 
6. Repeat the process to create another file for the code in Listing 2.1. 
Add existing files If a file already exists, it can be added to the project as follows: 
1. Select Project t Add Source. A dialog window appears. 
2. Go to the desired directory and select the desired files. Click Open and a new dialog 
3. Click OK to complete the addition. These files now appear in the sources window of 
appears. 
the project navigator. 
Check the code syntax After completing a new HDL file, we need to check the syntax 
of the code: 
1. Select the desired file in the source window. 
2. In the processes window, click the + icon next to Synthesize to expand the process 
hierarchy. 
3. Double-click the Check Syntax process. 
The bottom transcript displays the progress of the process and reports errors and warnings, 
which are started with a red X and yellow ! marks. Double-clicking the message leads 
to the offending line in the file. We can correct the problem, save the file, and repeat the 
syntax checking process until all syntax errors are eliminated. 
2.6.2 Create a testbench and perform the RTL simulation 
The testbench functions as a virtual lab bench. It consists of the HDL module to be tested 
and a code segment to generate the stimulus. The RTL simulation verifies operation of the 
HDL module in the host computer. ISE contains a built-in ISE simulator and can launch 
the ModelSim simulator manufactured by Mentor Graphics Corporation. Since the latter 
is more robust and versatile, we use it in the book. Although ModelSim can be invoked 
from ISE Project Navigator, we treat it as an individual software tool and illustrate its use 
in Section 2.1. 
2.6.3 Add a constraint file and synthesize and implement the code 
There are three tasks in this step: 

SHORT TUTORIAL ON ISE PROJECT NAVIGATOR 
23 
0 Add a constraint file. 
0 Perform synthesis and implementation. 
0 Check the design summary. 
Add a constraint file Constraints are certain conditions imposed on the synthesis 
and implementation processes. For our purposes, the main type of constraint is the pin 
assignment of a top-level I/O port and the minimal clock rate. During the implementation 
process, an IiO signal of the top-level module must be mapped to a physical pin of the 
FPGA device. Since the peripherals' I/O signals are already permanently connected to 
the designated FPGA's pins on the prototyping board, we must ensure that the signals are 
mapped to the corresponding pins. The other type of constraint is about timing, which 
specifies the minimal clock frequency to facilitate the oscillator of the board. 
The constraint information is stored in a text file with an extension of .ucf (for the user 
constraint file). In the eq2 circuit, we can connect the a and b ports to four switches and 
the aeqb port to an LED to verify the physical operation of the circuit. For the S3 board, 
the corresponding pins are F12, G12, H14, H13, and K12. The constraint file becomes 
# 4 s l i d e  s w i t c h e s  
NET "a<O>" LOC = "F12" ; 
# s w i t c h  0 
NET " a < l > "  LOC = " G 1 2 "  
; 
# s w i t c h  1 
NET " b < O > "  
LOC = "H14" ; 
# s w i t c h  2 
NET " b < l > "  LOC = "H13" ; 
# s w i t c h  3 
# l e d  
NET " a e q b "  
LOC = " K 1 2 "  
; 
# l e d  0 
Note that the # sign is used for a comment and the text after it is ignored. This file must be 
added to the design in the sources window. 
There are several ISE tools to specify and generate the constraint file. Since all of our 
experiments are done in the same prototyping board, the constraints (i.e., pin assignment 
and clock frequency) remain the same. A constraint template file that includes all connected 
I/O peripheral signals of the S3 board is provided in the Appendix. One easy method to 
create a constraint file is simply to copy and edit the template file according to the I/O port 
names of the current design. The procedure to create the .ucf file for the eq2 circuit is: 
1. Copy the template constraint file and rename it eq2~3.ucf. 
2. Follow the procedure in Section 2.6.1 to add the new constraint file to the eq2 module 
in the sources window. 
3. Select the constraint file. 
4. In the processes window, click the + icon next to User Constraints to expand the 
5. Double-click the Edit Constraints (Text) process to launch the ISE text editor. 
6. Rename the I/O names as needed and then delete the unused pin assignments. 
7. Save the file. 
The default option of ISE version 8.2 only allows the pin assignments of the existing 
top-level I/O ports. If unused pin assignments are not deleted from the ucf template, error 
messages will be generated. We can override the default option as follows: 
process hierarchy. 
1. Select the top-level HDL file. 
2. Right-click the implement Design process in the processes window and then select 
3. In the dialog window, check the Allow Unmatched LOC Constraints option and then 
Properties ... from the menu. A dialog window appears. 
click OK. 

24 
OVERVIEW OF FPGA AND EDA SOFTWARE 
After this option is turned on, we can use the same ucf template for all designs as long as 
the same IiO port names are kept in the top-level module, and we don’t need to edit the ucf 
file each time. 
Perform synthesis and implementation Invoking the synthesis and implementation 
procedure is very simple: 
1. Select the module to be synthesized and make sure that it is designated as the top-level 
2. Double-click the Implement Design process in the processes window. 
3. Although the syntax is checked earlier, the code may contain constructs that cannot 
be synthesized or may lead to poor implementation (such as a combinational loop). 
The error and warning messages are displayed in the console tab of the transcript 
window. 
module (with a green square next to the module icon). 
4. Correct the problems and repeat the simulation and synthesis processes if needed. 
Check the design summary As the project progresses, a report is generated in each 
process. These reports and key statistics are summarized in a design summary window. We 
can check the size of the resulting circuit (in terms of the numbers of slices, FFs, and LUTs) 
and, for a sequential circuit, check whether the clock rate meets the timing constraints. 
The summary can be invoked by double-clicking the View Design Summary process in the 
processes window. The summary for the eq2 circuit is shown in Figure 2.8. We can check 
the use of slices, LUTs, and so on, in the Device Utilization Summary portion. A more 
detailed report can be invoked by clicking the corresponding link. 
2.6.4 Generate and download the configuration file to an FPGA device 
The last step is to generate the configuration file and download the file to the FPGA device. 
There are three tasks in this step: 
0 Connect the download cable. 
0 Generate the configuration file. 
0 Download the configuration file. 
The S3 kit comes with a parallel-port JTAG download cable, and the following discussion 
is based on this cable. The procedures for other cables are similar and detailed instructions 
can be found in their manuals. 
Connect the download cable The procedure to prepare the board is as follows: 
1. Make sure that the PROM and the Mode jumpers (labeled 3 and 16 in Figure 2.3) are 
2. Connect the power cable. 
3. Connect one end of the download cable to the parallel port of a PC and connect the 
in their default setting (as the board is shipped). 
other end to the JTAG port (labeled 22 in Figure 2.3) on the S3 board. 
Generate the configuration file Generating a configuration file is very straightfor- 
ward: 
1. Make sure that the top-level module is selected in the source window. 
2. Click Generate Programming File in the processes window. 
After this process is completed, a configuration file, eq2.bit, is generated. 

SHORT TUTORIAL ON ISE PROJECT NAVIGATOR 
25 
Figure 2.8 Design summary. 

26 
OVERVIEW OF FPGA AND EDA SOFTWARE 
Figure 2.9 iMPACT welcome dialog. 
Download the configuration file Downloading the configuration file to an FPGA 
device is done by a software tool known as iMPACT, which can be invoked from ISE 
Project Navigator. The procedure is 
1. In the processes window, click the + sign to expand the Generate Programming File 
hierarchy. 
2. Double-click the Configure Device (IMPACT) process. The Welcome to iMPACT dia- 
log appears, as shown in Figure 2.9. Check Configure devices using Boundary-Scan 
(JTAG) and verify that Automatically connect to a cable and identify Boundary-Scan 
chain is selected in the drop-down list. Click Finish. 
3. If a message indicating that two devices are found is displayed, click OK to continue. 
4. The main iMPACT window, along with the Assign New Configuration File dialog, 
appears, as shown in Figure 2.10. The devices connected to the JTAG chain on the 
board should be detected and displayed. 
5. Select the eq2.bit file and click Open to assign this configuration file to the xc3s200 
device in the JTAG chain. 
6. If a warning message appears, ignore it and click OK. 
7. Select Bypass to skip the other device. 
8. Right-click on the xc3s200 device image, and select Program .... The Programming 
9. The Program Succeeded message appears when the downloading process is com- 
Now the FPGA device is configured and we can test the circuit with the switches and observe 
the output LED. 
Properties dialog opens. Click OK to program the device. 
pleted. 

SHORT TUTORIAL ON THE MODELSIM HDL SIMULATOR 
27 
Figure 2.10 iMPACT main window. 
An alternative way to configure the FPGA is to download the configuration file to a 
PROM and load the configuration file from the PROM. More information may be found in 
the sources cited in the Bibliographic section. 
2.7 SHORT TUTORIAL ON THE MODELSIM HDL SIMULATOR 
The ModelSim software is an HDL simulator manufactured by Mentor Graphics Corpo- 
ration and can run independently without ISE. The discussion in this section is based on 
ModelSim XE I11 Starter version 6.0d. 
The default ModelSim window is shown in Figure 2.1 1. It is divided into three subwin- 
dows: Transcript window (bottom), Workspace window, and multiple document interface 
(MDI) window. The Workspace window displays information on the current process. The 
bottom tab is used to select the desired process page, which can be Project, Library, Sim, 
and so on. The Transcript window keeps track of command history and messages. It can 
also be used as a command-line interface to enter ModelSim commands. The MDI window 
is an area to display HDL text, waveform, and so on. The bottom tab selects the desired 
pages. 
Each subwindow may be resized, moved, docked, or undocked. Additional windows 
may appear for some operations. The default layout can be restored by selecting Window 
+ initial Layout. 
We present a short tutorial in this section to illustrate the basic simulation process. There 
are three steps: 
1. Prepare a simulation project. 
2. Compile the HDL codes. 
3. Perform a simulation and examine the waveform. 

28 
OVERVIEW OF FPGA AND EDA SOFTWARE 
Figure 2.11 Typical ModelSim window. 
We use the 2-bit comparator testbench discussed in Chapter 1 for the tutorial, and the code 
is repeated in Listing 2.3. An additional assertion statement, 
a s s e r t  false 
report ” S imu 1 at ion C omp 1 e t e d I’ 
s e v e r i t y  failure; 
is added to the end of the process. It generates an “artificial failure” and stops the simulation. 
Listing 2.3 Testbench of a 2-bit comparator 
l i b r a r y  ieee; use ieee. std-logic-1164. a l l  ; 
e n t i t y  eq2-testbench i s  
end eq2-testbench; 
5 a r c h i t e c t u r e  tb-arch of eq2-testbench i s  
s i g n a l  test-ino, test-in1 : std-logic-vector (1 downto 0) ; 
s i g n a l  test-out : std-logic ; 
-_ 
i n s t a n t i a t e  t h e  c i r c u i t  u n d e r  t e s t  
begin 
10 
uut: e n t i t y  work.eq2(struc-arch) 
port map(a=>test-inO, b=>test-in1 , aeqb=>test-out) ; 
-_ 
t e s t  v e c t o r  g e n e r a t o r  
process 

SHORT TUTORIAL ON THE MODELSIM HOL SIMULATOR 
29 
20 
2s 
begin 
15 
t e s t  v e c t o r  1 
__ 
test-in0 <= "00"; 
test-in1 <= "00"; 
wait f o r  200 n s ;  
_- 
t e s t  v e c t o r  2 
test-in0 <= " 0 1 " ;  
test-in1 <= " 0 0 " ;  
wait f o r  200 n s ;  
t e s t  v e c t o r  3 
test-in0 <= " 0 1 " ;  
__ 
30 
3s 
40 
test-in1 <= "11" 
wait f o r  200 ns; 
t e s t  v e c t o r  4 
test-in0 <= "10" 
test-in1 <= "10" 
wait f o r  200 n s ;  
__ t e s t  v e c t o r  5 
test-in0 <= " 1 0 "  
test-in1 <= "00" 
wait f o r  200 ns; 
t e s t  v e c t o r  6 
test-in0 <= "11" 
test-in1 <= "11" 
wait f o r  200 n s ;  
t e s t  v e c t o r  7 
__ 
__ 
__ 
test-in0 <= "11"; 
test-in1 <= "01"; 
wait for 200 n s ;  
__ t e r m i n a t e  s i m u l a t i o n  
a s s e r t  false 
r e p  or t 
" S i mu 1 at i on C o m p  1 e t e d '' 
s e v e r i t y  failure; 
end p r o c e s s ;  
end tb-arch; 
Prepare a simulation project A ModelSim simulation project consists of the library 
definition and a collection of HDL files. A testbench is an HDL program and can be created 
by using the ISE text editor, as discussed in Section 2.6.1. Alternatively, ModelSim also 
has a built-in editor. We assume that all HDL files are already constructed. The procedure 
to create a project is as follows: 
1. Select Start + All Programs + ModelSim XE ill 6.0d + ModelSim (or wherever Mod- 
elSim resides) to launch the ModelSim program. 
2. Select File + New + Project and the Create Project dialog appears, as shown in 
Figure 2.12(a). Enter the project name as eq-testbench, select the project location, 
and set Default Library Name to work. Click OK. A blank Project page appears 
in the main window and the Add items to the project dialog appears, as shown in 
Figure 2.12(b). 
3. In the Add items to the project dialog, click Add Existing File and add the necessary 
HDL files. Click OK. The project tab appears in the workplace subwindow and 
displays the selected files, as shown in Figure 2.13. 

30 
OVERVIEW OF FPGA AND EDA SOFTWARE 
(a) Create Project dialog 
(b) Add items dialog 
Figure 2.12 New project dialogs. 
Figure 2.13 Project tab of the workplace panel. 

SHORT TUTORIAL ON THE MODELSIM HDL SIMULATOR 
31 
Figure 2.14 Simulate dialog. 
Compile the HDL code The compile term here means to convert the HDL code into 
ModelSim internal format. In VHDL, the compiling is done on the design unit basis. Each 
entity and architecture is considered as one design unit. The procedure is: 
1. Highlight the eql file and right-click the mouse. Select Compile + Compile Selected. 
Note that the compiling should be started from the modules at the bottom of the design 
hierarchy. The progress and messages are displayed in the transcript window. 
2. If the file contains no syntactical error, a check mark shows up. Otherwise, an X 
mark shows up. Click the red error line in the transcript window to locate the errors. 
Correct the problems, save the file, and recompile the file. 
3. Repeat the preceding steps to compile the eq2 file and then the eq-tb file. 
Perform a simulation and examine the waveform After compiling the testbench 
and corresponding files, we can perform the simulation and examine the resulting waveform. 
This corresponds to running the circuit in a virtual lab bench and checking the waveform 
in a virtual logic analyzer. The procedure is: 
1. Select Simulate + Simulate and the Simulate dialog appears. 
2. In the Design tab, find and expand the work library, which is the one defined when 
we create the project. All compiled units are displayed, as shown in Figure 2.14. 
3. Load eq2-testbench by double-clicking the corresponding icon. The sim tab ap- 
pears in the workplace window and the corresponding page displays the structure of 
the eq2-testbench module, as shown in Figure 2.15. An object window, which 
contains the signals in the selected module, may also appear. 
4. Highlight the uut unit and right-click the mouse. Select Add + Add to Wave. This 
adds all the signals of the uut unit to the waveform page. The waveform page appears 
in the MDI window. 
5. If necessary, rearrange the signals order and set them to proper format (decimal, hex, 
and so on.). 

32 
OVERVIEW OF FPGA AND EDA SOFTWARE 
Figure 2.15 Sim panel of the workplace panel. 
Figure 2.16 Waveform window, 
6. Select Simulate t Run. There are several commands to control the simulation: 
Restart (restart the simulation), Run (run the simulation one step), Continue run 
(resume the run from the interrupt), Run All (run the simulation forever), and Break 
(break the simulation). These commands are also shown as icons at the top of the 
window. 
7 .  The waveform window displays the simulated result, shown in Figure 2.16. We can 
scroll the window, zoom in, or zoom out to check the correctness of the design. 
2.8 BIBLIOGRAPHIC NOTES 
Both Xilinx ISE and Mentor Graphics ModelSim are complex software packages, and their 
documentation exceeds several thousand pages. Most documentation can be accessed via 
the Help menu. ISE has a short 30-page tutorial, ZSE 8.1i Quick Start Tutorial, and a more 
comprehensive 170-page tutorial, ZSE In-Depth Tutorial. ModelSim also has a similar 
tutorial, ModelSim Tutorial. These tutorials provide an overview on all features of the 
software package. Relevant information for the Spartan-3 device can be found in its data 
sheets, DS099 Spartan-3 FPGA Family: Complete Data Sheet, which includes the detailed 

SUGGESTED EXPERIMENTS 
33 
Table 2.2 Truth table of a 2-to-4 decoder with enable 
input 
output 
en 
a(1) a(0) 
bcode 
0
-
 - 
0000 
1
0
 0 
0001 
1
0
 1 
0010 
1
1
 0 
0100 
1
1
 1 
1000 
explanation on the logic cells and macro cells. The Design Warrior’s Guide to FPGAs 
by Clive Maxfield provides a comprehensive review of FPGA-related issues. The detailed 
layout and I/O connectors of the S3 board can be found in Spartan-3 Starter Kit Board User 
Guide. Information on other prototyping boards can be found in their manuals. 
2.9 SUGGESTED EXPERIMENTS 
2.9.1 Gate-level greater-than circuit 
The greater-than circuit compares two inputs, a and b, and asserts an output when a is 
greater than b. We want to create a 4-bit greater-than circuit from the bottom up and use 
only gate-level logical operators. Design the circuit as follows: 
1. 
2. 
3. 
4. 
5 .  
6. 
Derive the truth table for a 2-bit greater-than circuit and obtain the logic expression 
in the sum-of-products format. Based on the expression, derive the HDL code using 
only logical operators. 
Derive a testbench for the 2-bit greater-than circuit. Perform a simulation and verify 
the correctness of the design. 
Use four switches as the inputs and one LED as the output. Synthesize the circuit 
and download the configuration file to the prototyping board. Verify its operation. 
Use the 2-bit greater-than circuits and 2-bit equality comparators and a minimal 
number of “glue gates” to construct a 4-bit greater-than circuit. First draw a block 
diagram and then derive the structural HDL code according to the diagram. 
Derive a testbench for the 4-bit greater-than circuit. Perform a simulation and verify 
the correctness of the design. 
Use eight switches as the inputs and one LED as the output. Synthesize the circuit 
and download the configuration file to the prototyping board. Verify its operation. 
2.9.2 Gate-level binary decoder 
An n-t0-2~ binary decoder asserts one of 2n bits according to the input combination. The 
functional table of a 2-to-4 decoder with an enable signal is shown in Table 2.2. We want to 
create several decoders using only gate-level logical operators. The procedure is as follows: 
1. Determine the logic expressions for the 2-to-4 decoder with enable and derive the 
2. Derive a testbench for the decoder. Perform a simulation and verify the correctness 
HDL code using only logical operators. 
of the design. 

34 
OVERVIEW OF FPGA AND EDA SOFTWARE 
3. Use two switches as the inputs and four LEDs as the outputs. Synthesize the circuit 
and download the configuration file to the prototyping board. Verify its operation. 
4. Use the 2-to-4 decoders to derive a 3-to-8 decoder. First draw a block diagram and 
then derive the structural HDL code according to the diagram. 
5. Derive a testbench for the 3-to-8 decoder. Perform a simulation and verify the cor- 
rectness of the design. 
6. Use three switches as the inputs and eight LEDs as the outputs. Synthesize the circuit 
and download the configuration file to the prototyping board. Verify its operation. 
7. Use the 2-to-4 decoders to derive a 4-to-16 decoder. First draw a block diagram and 
then derive the structural HDL code according to the diagram. 
8. Derive a testbench for the 4-to-16 decoder. Perform a simulation and verify the 
correctness of the design. 

CHAPTER 3 
RT-LEVEL COMBINATIONAL CIRCUIT 
3.1 INTRODUCTION 
The gate-level circuits discussed in Chapter 1 utilize simple logical operators to describe 
gate-level design, which is composed of simple logic cells. In this chapter, we examine 
the HDL description of module-level circuits, which are composed of intermediate-sized 
components, such as adders, comparators, and multiplexers. Since these components are 
the basic building blocks used in register transfer methodology, it is sometimes referred 
to as RT-level design. We first discuss more sophisticated VHDL operators and routing 
constructs and then demonstrate the RT-level combinational circuit design through a series 
of examples. 
3.2 RT-LEVEL COMPONENTS 
In addition to the logical operators, relational operators and several arithmetic operators 
can also be synthesized automatically. These operators correspond to intermediate-sized 
module-level components, such as comparators and adders. We examine these operators in 
this section and also cover miscellaneous synthesis-related VHDL constructs. Tables 3.1 
and 3.2 summarize the operators and their applicable data types used in this book. 
FPGA Protowping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
35 

36 
RT-LEVEL COMBINATIONAL CIRCUIT 
Table 3.1 Operators and data types of VHDL-93 and IEEE std-logic-I164 package 
Operator 
Description 
Data type 
Data type 
of operands 
of result 
a ** b 
exponentiation 
integer 
integer 
a * b 
multiplication 
a / b 
division 
integer type for constants and 
a + b  
addition 
array boundaries, not synthesis 
a - b  
subtraction 
a & b  
concatenation 
1-D array, 
element 
1-D array 
a = b 
equalto 
any 
boolean 
a /= b 
notequal to 
a < b  
less than 
scalar or 1 -D array 
boolean 
a <= b 
a > b 
greater than 
a >= b 
less than or equal to 
greater than or equal to 
not a 
negation 
a and b 
and 
a or b 
or 
a xor b 
xor 
boolean, std-logic, 
same as operand 
std-logic-vector 
Table 3.2 Overloaded operators and data types in the IEEE numeric-std package 
Overloaded 
Description 
Data type 
Data type 
operator 
of operands 
of result 
a * b  
arithmetic 
unsigned, natural unsigned 
a + b  
operation 
signed, integer 
signed 
a - b  
a = b  
a /= b 
a < b  
relational 
unsigned, natural boolean 
a <= b 
operation 
signed, integer 
boolean 
a > b  
a >= b 
Table 3.3 Type conversions between std-logic-vector and numeric data types 
Data type of a 
To data type 
Conversion functiodtype casting 
unsigned, signed 
std-logic-vector std-logic-vector(a) 
signed, std-logic-vector 
unsigned 
unsigned( a) 
unsigned, std-logic-vector signed 
signed(a) 
unsigned, signed 
integer 
to-integer (a) 
natural 
unsigned 
to-unsigned(a, size) 
integer 
signed 
to-signed(a, size) 

RT-LEVEL COMPONENTS 
37 
3.2.1 Relational operators 
Six relational operators are defined in the VHDL standard: = (equal to), /= (not equal to), 
< (less than), <= (less than or equal to), > (greater than), and >= (greater than or equal to). 
These operators compare operands of the same data type and return a value of the boolean 
data type. In this book, we don’t use the boolean data type directly, but embed it in routing 
constructs. This is discussed in Sections 3.3 and 3.5. During synthesis, comparators are 
inferred for these operators. 
3.2.2 Arithmetic operators 
In the VHDL standard, arithmetic operations are defined for the integer data type and 
for the natural data type, which is a subtype of integer containing zero and positive 
integers. We usually prefer to have more control in synthesis and define the exact number 
of bits and format (i.e., signed or unsigned). The IEEE numeric-std package is developed 
for this purpose. In this book, we use the integer and natural data types for constants 
and array boundaries but not for synthesis. 
IEEE numeric-std package The IEEE numeric-std package adds two new data 
types, unsigned and signed, and defines the relational and arithmetic operators over the 
new data types (known as operator overloading). The unsigned and signed data types 
are defined as an array with elements of the std-logic data type. The array is interpreted 
as the binary representation of unsigned or signed integers. We have to add an additional 
use statement to invoke the package: 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numric-std. a l l  ; 
-- i n v o k e  n u m e r i c - s t d  p a c k a g e  
The synthesizable overloaded operators are summarized in Table 3.2. 
Multiplication is a complicated operation, and synthesis of the multiplication operator * 
depends on synthesis software and target device technology. Xilinx Spartan-3 FPGA family Xilinx 
contains prefabricated combinational multiplier blocks. The Xilinx XST software can infer specific 
these blocks during synthesis, and thus the multiplication operator can be used in HDL 
code. The XCS200 device of the S3 board consists of twelve 18-by-18 multiplier blocks. 
While the synthesis of the multiplication operator is supported, we need to be aware of the 
limitation on the number and input width of these blocks and use them with care. 
Type conversion Because VHDL is a strongly typed language, std-logic-vector, 
unsigned, and signed are treated as different data types even when all of them are defined 
as an array with elements of the std-logic data type. A conversionfunction or type 
casting is needed to convert signals of different data types. The conversion is summarized 
in Table 3.3. Note that the std-logic-vector data type is not interpreted as a number and 
thus cannot be converted directly to an integer, and vice versa. 
The following examples illustrate the common mistakes and remedies for type conver- 
sion. Assume that some signals are declared as follows: 
l i b r a r y  i e e e ;  
use ieee . std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
s i g n a l  sl, s 2 ,  s3, s 4 ,  s 5 ,  s 6 :  std-logic-vector(3 downto 0 ) ;  
. . .  

38 
RT-LEVEL COMBINATIONAL CIRCUIT 
s i g n a l  u l ,  u 2 ,  u 3 ,  u 4 ,  u5, u 6 ,  u 7 :  unsigned(3 downto 0 ) ;  
. . .  
Let us first consider the following assignment statements: 
u l  <= s l ;  -- not o k ,  t y p e  m i s m a t c h  
u 2  <= 5 ;  -- n o t  o k ,  t y p e  m i s m a t c h  
s 2  <= u 3 ;  -- n o t  o k ,  t y p e  m i s m a t c h  
s3 <= 5 ;  
-- n o t  o k ,  t y p e  m i s m a t c h  
They are all invalid because of type mismatch. The right-hand-side expression must be 
converted to the data type of the left-hand-side signal: 
u l  <= unsigned(s1); 
-- o k ,  t y p e  c a s t i n g  
u 2  <= to-unsigned ( 5 , 4 )  ; -- o k ,  c o n v e r s i o n  f u n c t i o n  
s 2  <= std-logic-vector(u3); -- o k ,  t y p e  c a s t i n g  
s 3  <= std-logic-vector (to-unsigned ( 5 , 4 ) )  ; -- ok 
Note that two type conversions are needed for the last statement. 
Let us consider statements that involve arithmetic operations. The following statements 
are valid since the -+ operator is defined with the unsigned and natural types in the IEEE 
numer ic-std package. 
u 4  <= u 2  + u l ;  -- o k ,  b o t h  o p e r a n d s  u n s i g n e d  
u5 <= u 2  + 1 ;  -- o k ,  o p e r a n d s  u n s i g n e d  and n a t u r a l  
On the other hand, the following statements are invalid since no overloaded arithmetic 
operation is defined for the std-logic-vector data type: 
s5 <= s 2  + s l ;  -- n o t  o k ,  + u n d e f i n e d  o v e r  t h e  t y p e s  
~6 <= ~2 + 1; -- n o t  o k ,  + u n d e f i n e d  o v e r  t h e  t y p e s  
To fix the problem, we must convert the operands to the unsigned (or signed) data type, 
perform addition, and then convert the result back to the std-logic-vector data type. 
The revised code becomes 
s5 <= std-logic-vector(unsigned(s2) + unsigned(s1)); -- ok 
s 6  <= std-logic-vector (unsigned(s2) + 1) ; 
-- ok 
Nonstandard arithmetic packages There are several non-IEEE arithmetic pack- 
ages, which are std-logic-arith, std-logic-unsigned, and std-logic-signed. The 
std-logic-arith package is similar to the numeric-std package. The other two pack- 
ages do not introduce any new data type but define overloaded arithmetic operators over 
the std-logic-vector data type. This approach eliminates the need for data conversion. 
Although using these packages seems to be less cumbersome initially, it is not good practice 
since these packages are not a part of IEEE standards and may introduce a compatibility 
problem in the long run. We do not use these packages in this book. 
3.2.3 Other synthesis-related VHDL constructs 
Concatenation operator The concatenation operator, &, combines segments of ele- 
ments and small arrays to form a large array. The following example illustrates its use: 
s i g n a l  a1 : std-logic ; 
s i g n a l  a4: std-logic-vector ( 3  downto 0) ; 
s i g n a l  b 8 ,  c 8 ,  d 8 :  std-logic-vector (7 downto 0 )  ; 

RT-LEVEL COMPONENTS 
39 
oe 
Y 
0 
Z 
1 
a-in 
Figure 3.1 Symbol and functional table of a tri-state buffer. 
. . .  
b8 <= a4 & a 4 ;  
c8 <= a1 & a1 & a4 & ” 0 0 ” ;  
d8 <= b 8 ( 3  downto 0) & c 8 ( 3  downto 0 ) ;  
Implementation of the concatenation operator involves reconnection of the input and output 
signals and only requires “wiring.” 
One major application of the & operator is to perform shifting operations. Although both 
VHDL standard and numeric-std package define shift functions, they sometimes cannot 
be synthesized automatically. The & operator can be used for shifting a signal for a fixed 
amount, as shown in the following example: 
s i g n a l  a :  s t d - l o g i c - v e c t o r  ( 7  downto 0 )  ; 
s i g n a l  r o t ,  s h l ,  s h a :  s t d - l o g i c - v e c t o r  ( 7  downto 0 )  ; 
__ r o t a t e  a to r i g h t  3 b i t s  
r o t  <= a ( 2  downto 0 )  & a ( 8  downto 3 ) ;  
_- 
s h i f t  a t o  r i g h t  3 b i t s  and i n s e r t  0 ( l o g i c  s h i f t )  
s h l  <= “ 0 0 0 “  & a ( 8  downto 3 ) ;  
_- 
s h i f t  a t o  r i g h t  3 b i t s  and i n s e r t  MSB 
-- ( a r i t h m e t i c  s h i f t )  
sha <= a ( 8 )  & a ( 8 )  & a ( 8 )  & a ( 8  downto 3 )  ; 
An additional routing circuit is needed if the amount of shifting is not fixed. The design of 
a barrel shifter is discussed in Section 3.7.3. 
’Z’ value of sfd-logk The std-logic data type has a value of ’ Z ’ , which implies high 
impedance or an open circuit. It is not a normal logic value and can only be synthesized by a 
tri-state buffer. The symbol and function table of a tri-state buffer are shown in Figure 3.1. 
Operation of the buffer is controlled by an enable signal, oe (“output enable”). When it is 
’ 1 ’ , the input is passed to output. On the other hand, when it is ’ 0 ’, the y output appears 
to be an open circuit. The code of the tri-state buffer is 
y <= a - i n  when o e = ’ 1 ’  e l s e  ’ Z ’ ;  
The most common application for a tri-state buffer is to implement a bidirectional port 
to better utilize a physical I/O pin. A simple example is shown in Figure 3.2. The d i r  
signal controls the direction of signal flow of the b i  pin. When it is ’O’, the tri-state buffer 
is in the high-impedance state and the sig-out signal is blocked. The pin is used as an 
input port and the input signal is routed to the sig-in signal. When the d i r  signal is ’l’, 
the pin is used as an output port and the sig-out signal is routed to an external circuit. The 
HDL code can be derived according to the diagram: 
e n t i t y  bi-demo i s  
port ( 

40 
RT-LEVEL COMBINATIONAL CIRCUIT 
Xilinx 
specific 
sig-out 
bi 
Figure 3.2 Single-buffer bidirectional I/O port. 
bi : inout std-logic ; 
. . .  
) 
sig-out <= output-expression; 
some-signal <= expression-with-sig-in; 
begin 
. . .  
bi <= sig-out when d i r = ’ l ’  e l s e  ’ Z ’ ;  
sig-in <= b i ;  
. . .  
Note that the mode of the bi port must be declared as inout for bidirectional operation. 
For a Xilinx Spartan-3 device, a tri-state buffer exists only in the I/O block (IOB) of a 
physical pin. Thus, the tri-state buffer can only be used for I/O ports that are mapped to the 
physical pins of an FPGA device. 
3.2.4 Summary 
Because of the nature of a strongly typed language, the data type frequently confuses a new 
VHDL user. Since this book is focused on synthesis, only a small set of data types and 
operators are needed. Their uses can be summarized as follows: 
0 Use the std-logic and std-logic-vector data types in entity port declaration and 
Use the ’Z’ value only to infer a tri-state buffer. 
0 Use the IEEE numeric-std package and its unsigned or signed data types for the 
internal signals that involve arithmetic operation. 
0 Use the data type casting or conversion functions in Table 3.3 to convert signals and 
expressions among the std-logic-vector and various numerical data types. 
0 Use VHDL‘s built-in integer data type and arithmetic operators for constant and 
array boundary expressions, but not for synthesis (i.e., not used as a data type for a 
signal). 
0 Embed the result of a relational operation, which is in the boolean data type, in 
routing constructs (discussed in Section 3.3). 
0 Use a user-defined two-dimensional data type for two-dimensional storage array 
(discussed in Section 4.2.3). 
for the internal signals that involve no arithmetic operations. 

ROUTING CIRCUIT WITH CONCURRENT ASSIGNMENT STATEMENTS 
41 
Use a user-defined enumerate data type for the symbolic states of a finite state machine 
(discussed in Chapter 5). 
3.3 ROUTING CIRCUIT WITH CONCURRENT ASSIGNMENT STATEMENTS 
The conditional signal assignment and selected signal assignment statements are concur- 
rent statements. Their behaviors are somewhat like the if and case statements of a conven- 
tional programming language. Instead of being executed sequentially, these statements are 
mapped to a routing network during synthesis. 
3.3.1 
Conditional signal assignment statement 
Syntax and conceptual implementation The simplified syntax of a conditional 
signal assignment statement is 
signal-name <= value-expr-1 when boolean-expr-1 e l s e  
value-expr-2 when boolean-expr-2 e l s e  
value-expr-n ; 
. . .  
The Boolean expressions are evaluated successively in turn until one is found to be t r u e  
and the corresponding value expression is assigned to the signal. The value-exprn is 
assigned if all Boolean expressions are evaluated to be false. 
The conditional signal assignment statement implies a cascading priority routing net- 
work. Consider the following statement: 
r <= a + b + c when m = n e l s e  
a
-
b
 
when m > n e l s e  
c + 1 ;  
The routing is done by a sequence of 2-to-1 multiplexers. The diagram and truth table of a 
2-to-1 multiplexer are shown in Figure 3.3(a), and the conceptual diagram of the statement 
is shown in Figure 3.3(b). It the first Boolean condition (i.e., m=n) is true, the result of 
a+b+c is routed to r. Otherwise, the data connected to the 0 port is passed to r. We need to 
trace the path along the 0 port and check the next Boolean condition (i.e., m>n) to determine 
whether the result of a-b or c+l is routed to the output. 
Note that all the Boolean expressions and value expressions are evaluated concurrently. 
The values from the Boolean circuits set the selection signals of the multiplexers to route 
the desired value to the output. The number of cascading stages increases proportionally to 
the number of when-else clauses. A large number of when-else clauses will lead to a long 
cascading chain and introduce a large propagation delay. 
Examples We use two simple examples to demonstrate use of the conditional signal 
assignment statement. The first example is a priority encoder. The priority encoder has 
four requests, r (4), r (3), r (2), and r (I), which are grouped as a single 4-bit r input, and 
r (4) has the highest priority. The output is the binary code of the highest-order request. 
The function table is shown in Table 3.4. The HDL code is shown in Listing 3.1. 
Priority encoder using a conditional signal assignment statement 
Listing 3.1 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 

42 
RT-LEVEL COMBINATIONAL CIRCUIT 
L 
(a) Diagram of a 2-to-1 multiplexer 
Circuits for 
"value expressions" 
(b) Diagram of a conditional signal assignment statement 
Figure 3.3 Implementation of a conditional signal assignment statement. 
Table 3.4 Function table of a four-request priority encoder 
input 
output 
r 
pcode 
I--- 100 
01-- 
011 
0 0 1 -  
010 
0 0 0 1  
001 
0 0 0 0  
000 

ROUTING CIRCUIT WITH CONCURRENT ASSIGNMENT STATEMENTS 
43 
Table 3.5 Truth table of a 2-to-4 decoder with enable 
input 
output 
en a(1) 
a(O) 
Y 
0
-
 - 
0000 
1
0
 0 
0001 
1
0
 1 
0010 
1 
1 
0 
0100 
1 
1 
1 
1000 
e n t i t y  prio-encoder i s  
port ( 
r :  in std-logic-vector (4 downto 1) ; 
pcode : out std-logic-vector ( 2  downto 0) 
) ;  
end prio-encoder ; 
10 a r c h i t e c t u r e  cond-arch of prio-encoder i s  
begin 
pcode <= 1110011 
when (r(4)='1') 
e l s e  
" 0 1 1 "  when (r(3)='1') 
e l s e  
1'0101' when (r(2)='1') 
e l s e  
IS 
" 0 0 1 "  when (r(l)='l ' )  e l s e  
" 000 " ; 
end cond-arch; 
The code first checks the r(4) request and assigns "100" to pcode if it is asserted. It 
continues to check the r (3) request if r (4) is not asserted and repeats the process until all 
requests are examined. 
The second example is a binary decoder. An n t 0 - 2 ~  
binary decoder asserts 1 bit of the 
2n-bit output according to the input combination. The functional table of a 2-to-4 decoder 
is shown in Table 3.5. The circuit also has a control signal, en, which enables the decoding 
function when asserted. The HDL code is shown in Listing 3.2. 
Listing 3.2 Binary decoder using a conditional signal assignment statement 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 
e n t i t y  decoder-2-4 is 
port ( 
5 
a :  in std-logic-vector (1 downto 0 )  ; 
e n :  in std-logic; 
y : out std-logic-vector (3 downto 0 )  
) ;  
end decoder-2-4; 
a r c h i t e c t u r e  cond-arch of decoder-2-4 i s  
begin 
I0 
y <= " 0 0 0 0 "  when (en='O') e l s e  
"0001" when ( a = " O O " )  e l s e  
15 
"0010" when ( a = " O l " )  e l s e  

44 
RT-LEVEL COMBINATIONAL CIRCUIT 
" 0 1 0 0 "  when (a=I'lO'l) e l s e  
" 1 0 0 0 " ;  
-- a = " ] ] "  
end c o n d - a r c h ;  
The code first checks whether en is not asserted. If the condition is false (i.e., en is ' 1 '), 
it tests the four binary combinations in sequence. 
3.3.2 Selected signal assignment statement 
Syntax and conceptual implementation The simplified syntax of a selected signal 
assignment statement is 
with sel s e l e c t  
sig <= value-expr-1 when c h o i c e - 1 ,  
value-expr-2 when c h o i c e - 2 ,  
value-expr-3 when c h o i c e - 3 ,  
value-expr-n when o t h e r s  ; 
.
.
.
 
The selected signal assignment statement is somewhat like a case statement in a traditional 
programming language. It assigns an expression to a signal according to the value of the 
s e l  signal. A choice (i.e., choice-i) must be a valid value or a set of valid values of sel. 
The choices have to be mutually exclusive (i.e., no value can be used more than once) and 
all inclusive (i.e., all values must be used). In other words, all possible values of s e l  must 
be covered by one and only one choice. The reserved word, others, is used in the end to 
cover unused values. Since the s e l  signal usually has the std-logic-vector data type, 
the others term is always needed to cover the unsynthesizable values ( 'XI, 'U' , etc.). 
The selected signal assignment statement implies a multiplexing structure. Consider the 
following statement: 
s i g n a l  sel : std-logic-vector (1 downto 0 )  ; 
with s e l  s e l e c t  
. . .  
r <= a + b + c 
when 
" O O " ,  
a - b  
when 
I' 10 I' , 
c
+
l
 
when o t h e r s ;  
For synthesis purposes, the sel signal can assume four possible values: "OO", "01". "lo", 
and "1 1". It implies a 22-to-1 multiplexer with s e l  as the selection signal. The diagram and 
functional table of the 2'-to-1 multiplexer are shown in Figure 3.4(a), and the conceptual 
diagram of the statement is shown in Figure 3.4(b). The evaluated result of a+b+c is routed 
to r when s e l  is "OO", the result of a-b is routed when s e l  is "10", and the result of c+l 
is routed when s e l  is "01" or "1 1". 
Again, note that all value expressions are evaluated concurrently. The s e l  signal is used 
as the selection signal to route the desired value to the output. The width (i.e., number of 
input ports) of the multiplexer increases geometrically with the number of bits of the s e l  
signal. 
Example We use the same encoder and decoder circuits to illustrate use of the selected 
signal assignment statement. The code for the priority encoder is shown in Listing 3.3. The 
entity declaration is identical to that in Listing 3.1 and is omitted. 

ROUTING CIRCUIT WITH CONCURRENT ASSIGNMENT STATEMENTS 
45 
i2 
Y 
i3 
sel 
y 
- 
00 
i0 
01 
i l  
10 
i2 
sel 2 
11 
i3 
(a) Diagram and functional table of a 4-to-1 multiplexer 
Circuits for 
"value expressions'' 
a 
b 
C 
r 
sel 
I 
(b) Diagram of a selected signal assignment statement 
Figure 3.4 Implementation of a selected signal assignment statement. 
Listing 3.3 Priority encoder using a selected signal assignment statement 
a r c h i t e c t u r e  sel-arch of prio-encoder i s  
begin 
with r s e l e c t  
pcode <= " 1 0 0 "  when " 1 0 0 0 " l " 1 0 0 1 " 1 " 1 0 1 0 " 1 " 1 0 1 1 " 1  
" 0 1 1 "  when " 0 1 0 0 "  I"01Ol1' 
I " O 1 1 0 "  I " O 1 1 1 " ,  
" 0 1 0 "  when " 0 0 1 0 "  I " O O 1 1 " ,  
'I 0 0 1 I' when 
I' 0 0 0 1 'I , 
" 0 0 0 "  when o t h e r s  ; 
-- r="0000" 
5 
'1 1100 " I " 1101 '1 I " 11 10 1' I " 11 11 , 
10 end sel-arch; 
The code exhaustively lists all possible combinations of the r signal and the corresponding 
output values. Note that the I symbol is used if the choice is more than one value. 
The code for the 2-to-4 decoder is shown in Listing 3.4. 
Listing 3.4 Binary decoder using a selected signal assignment statement 
a r c h i t e c t u r e  sel-arch of decoder-2-4 i s  
begin 
s i g n a l  s :  std-logic-vector (2 downto 0) ; 
s <= en & a ;  
5 
with s s e l e c t  
y <= 1 ~ 0 0 0 0 "  when " 0 0 0 "  I " O O 1 "  I " 0 1 0 "  I t l O 1 l " ,  
l t O O O 1 t '  when " 1 0 0 1 1 ,  

46 
RT-LEVEL COMBINATIONAL 
CIRCUIT 
" 0 0 1 0 "  when " 1 0 1 " ,  
110100" when " l l O " ,  
10 
" 1 0 0 0 "  when o t h e r s ;  
-- s = " I l l "  
end sel-arch ; 
We concatenate en and a to form a 3-bit signal, s, and use it as the selection signal. The 
remaining code again exhaustively lists all possible combinations and the corresponding 
output values. 
3.4 MODELING WITH A PROCESS 
3.4.1 Process 
To facilitate system modeling, VHDL contains a number of sequential statements, which 
are executed in sequence. Since their behavior is different from that of a normal concurrent 
circuit model, these statements are encapsulated inside a process. A process itself is a 
concurrent statement. It can be thought of as a black box whose behavior is described by 
sequential statements. 
Sequential statements include a rich variety of constructs, but many of them don't have 
clear hardware counterparts. A poorly coded process frequently leads to unnecessarily 
complex implementation or cannot be synthesized at all. Detailed discussion of sequential 
statements and processes is beyond the scope of this book. For synthesis, we restrict the 
use of the process to two purposes: 
0 Describe routing structures with if and case statements. 
0 Construct templates for memory elements (discussed in Chapter 4). 
The simplified syntax of a process with a sensitivity list is 
process(sensitivity-list) 
begin 
sequential statement; 
sequential statement; 
. . .  
end p r o c e s s ;  
The sensitivity-list is a list of signals to which the process responds (Le., is "sensitive 
to"). For a combinational circuit, all the input signals should be included in this list. The 
body of a process is composed of any number of sequential statements. 
3.4.2 Sequential signal assignment statement 
The simplest sequential statement is a sequential signal assignment statement. The simpli- 
fied syntax is 
sig <= value-expression; 
The statement must be encapsulated inside a process. 
Although its syntax is similar to that of a simple concurrent signal assignment statement, 
the semantics are different. When a signal is assigned multiple times inside a process, only 
the last assignment takes effect. For example, the code segment 
process (a, b) 
begin 

ROUTING CIRCUIT WITH IF AND CASE STATEMENTS 
47 
c <= a and b ;  
c <= a or b ;  
end p r o c e s s ;  
is the same as 
process (a, b) 
begin 
end p r o c e s s ;  
c <= a or b ;  
On the other hand, if they are concurrent signal assignment statements, as in 
-- not within a process 
c <= a and b ;  
c <= a or b ;  
the code infers an and cell and an or cell, whose outputs are tied together. It is not allowed 
in most device technology and thus is a design error. 
The semantics of assigning a signal multiple times inside a process is subtle and can 
sometimes be error-prone. Detailed explanations can be found in the references cited in the 
Bibliographic section. We use multiple assignments only to avoid unintended memory, as 
discussed in Section 3.5.4. 
3.5 ROUTING CIRCUIT WITH IF AND CASE STATEMENTS 
If and case statements are two other commonly used sequential statements. In synthesis, 
they can be used to describe routing structures. 
3.5.1 If statement 
Syntax and conceptual implementation The simplified syntax of an if statement is 
i f  boolean-expr- 1 then 
s e q u e n t i a l - s t a t e m e n t s ;  
e l s i f  boolean-expr-2 then 
s e q u e n t i a l - s t a t e m e n t s ;  
e l s i f  boolean-expr-3 then 
sequent ial-statement s ; 
. . .  
e l s e  
end i f  ; 
s e q u e n t i a l - s t a t e m e n t s ;  
It has one then branch, one or more optional elsij" branches, and one optional else branch. 
The Boolean expressions are evaluated sequentially until an expression is evaluated as 
t r u e  or the else branch is reached, and the statements in the corresponding branch will be 
executed. 
An if statement and a concurrent conditional signal assignment statement are somewhat 
similar. The two statements are equivalent if each branch of the if statement contains only 
a single sequential signal assignment statement. For example, the previous statement 
r <= a + b + c when m = n e l s e  
a
-
b
 
when m > 0 e l s e  
c + 1 ;  

48 
RT-LEVEL COMBINATIONAL CIRCUIT 
can be rewritten as 
p r o c e s s ( a , b , c , m , n )  
begin 
if m = n t h e n  
r <= a + b + c ;  
e l s i f  m > 0 t h e n  
r <= a - b ;  
e l s e  
end i f  ; 
r <= c + 1; 
end ; 
As in a conditional signal assignment statement, the if statement infers a similar priority 
routing structure during synthesis. 
Example The codes of the same priority encoder and written with an if statement are 
shown in Listings 3.5 and 3.6. They are similar to those in Listings 3.1 and 3.2. Note that 
the if statement must be encapsulated inside a process. 
Listing 3.5 Priority encoder using an if statement 
a r c h i t e c t u r e  i f - a r c h  of p r i o - e n c o d e r  
i s  
begin 
p r o c e s s  (r) 
begin 
5 
if ( r ( 4 ) = ' 1 ' )  t h e n  
pcode <= " 1 0 0 " ;  
e l s i f  ( r ( 3 ) = ' l ' ) t h e n  
pcode <= " 0 1 1 " ;  
e l s i f  ( r ( 2 ) = ' l ' ) t h e n  
pcode <= " 0 1 0 " ;  
e l s i f  ( r ( l ) = ' l J )  
t h e n  
pcode <= " 0 0 1 " ;  
e l s e  
pcode <= " 0 0 0 " ;  
1s 
end i f ;  
end p r o c e s s ;  
end i f - a r c h ;  
10 
5 
10 
Listing 3.6 Binary decoder using an if statement 
a r c h i t e c t u r e  i f - a r c h  of decoder-2-4 
is begin 
p r o c e s s  ( e n ,  a )  
begin 
i f  (en='O') t h e n  
y <= " 0 0 0 0 " ;  
e I s i f ( a = "  00 'I ) t h e n  
y <= " 0 0 0 1  ! I ;  
e 1 s i f  ( a = " 0 1  I' ) t h e n  
y <= " 0 0 1 0 " ;  
e l s i f  ( a = "  1 0 " )  t h e n  
y <= " 0 1 0 0 " ;  
e l s e  
y <= " 1 0 0 0 " ;  

ROUTING CIRCUIT WITH IF AND CASE STATEMENTS 
49 
end i f ;  
1 5  
end p r o c e s s ;  
end i f - a r c h ;  
3.5.2 Case statement 
Syntax and conceptual implementation The simplified syntax of a case statement 
is 
case s e l  is 
when c h o i c e - 1  => 
when c h o i c e - 2  => 
s e q u e n t i a l  s t a t e m e n t s ;  
s e q u e n t i a l  s t a t e m e n t s ;  
when o t h e r s  => 
s e q u e n t i a l  s t a t e m e n t s  ; 
end c a s e ;  
A case statement uses the s e l  signal to select a set of sequential statements for execution. 
As in a selected signal assignment statement, a choice (i.e., choice-i) must be a valid 
value or a set of valid values of s e l ,  and the choices have to be mutually exclusive and all 
inclusive. Note that the others term at the end covers the unused values. 
A case statement and a concurrent selected signal assignment statement are somewhat 
similar. The two statements are equivalent if each branch of the case statement contains 
only a single sequential signal assignment statement. For example, the previous statement 
with s e l  s e l e c t  
r <= a + b f c 
when " O O " ,  
a - b  
when 
l t l O " ,  
c
+
l
 
when o t h e r s ;  
can be rewritten as 
p r o c e s s ( a , b , c , s e l )  
begin 
case s e l  is 
when 'loot1 => 
r <= a f b f c ;  
when " 1 0 "  = >  
r <= a - b ;  
when o t h e r s  => 
r <= c + 1 ;  
end c a s e ;  
end ; 
As in a selected signal assignment statement, the case statement infers a similar multiplexing 
structure during synthesis. 
Example The codes of the same priority encoder and decoder written with a case state- 
ment are shown in Listings 3.7 and 3.8. As in Listings 3.3 and 3.4, the codes exhaustively 
lists all possible input combinations and the corresponding output values. 

50 
RT-LEVEL COMBINATIONAL CIRCUIT 
Listing 3.7 Priority encoder using a case statement 
a r c h i t e c t u r e  c a s e - a r c h  of p r i o - e n c o d e r  
i s  
begin 
process ( r )  
begin 
5 
case r i s  
in 
3 
when '11000" 
1'1001'1 
I " 1 0 1 0 "  
"1100" " 1 1 0 1 " 1 " 1 1 1 0 "  
pcode <= " 1 0 0 " ;  
when " 0 1 0 0 "  " 0 1 0 1 "  I " 0 1 1 0 "  
pcode <= " 0 1 1 " ;  
when " 0 0 1 0 "  l " 0 0 1 1 "  => 
pcode <= " 0 1 0 " ;  
when 
'I 00 0 1 I' = > 
pcode <= " 0 0 1 " ;  
when oth ers  => 
pcode <= " 0 0 0 " ;  
end c a s e ;  
end p r o c e s s ;  
end c a s e - a r c h ;  
1' 101 1 " I 
"1111" => 
Listing 3.8 Binary decoder using a case statement 
a r c h i t e c t u r e  c a s e - a r c h  of d e c o d e r - 2 - 4  
i s  
begin 
s i g n a l  s :  s t d - l o g i c - v e c t o r  ( 2  downto 0) ; 
s <= e n  & a ;  
5 
p r o c e s s ( s )  
begin 
case s i s  
when " 0 0 0 "  l " O O 1 "  I " O 1 0 "  I " 0 1 1 "  => 
y <= " 0 0 0 1 "  
when " 1 0 0 "  => 
y <= " 0 0 0 1 "  
when " 1 0 1 "  => 
y <= " 0 0 1 0 "  
when 
" l l O r t  => 
y <= " 0 1 0 0 "  
when oth ers  => 
y <= " 1 0 0 0 " ;  
end c a s e ;  
end p r o c e s s ;  
20 end c a s e - a r c h  ; 
3.5.3 Comparison to concurrent statements 
The preceding subsections show that the simple if and case statements are equivalent to the 
conditional and selected signal assignment statements. However, an if or case statement 
allows any number and any type of sequential statements in their branches and thus is more 
flexible and versatile. Disciplined use can make the code more descriptive and even make 
a circuit more efficient. 

ROUTING CIRCUIT WITH IF AND CASE STATEMENTS 
51 
This can be illustrated by two code segments. First, consider a circuit that sorts the 
values of two input signals and routes them to the large and small outputs. This can be 
done by using two conditional signal assignment statements: 
l a r g e  <= a when a > b e l s e  
s m a l l  <= b when a > b e l s e  
b ;  
a ;  
Since there are two relation operators (ie., two >) in code, synthesis software may infer 
two greater-than comparators. The same function can be coded by a single if statement: 
process ( a ,  b )  
begin 
if a > b then 
l a r g e  <= a ;  
s m a l l  <= b ;  
l a r g e  <= b ;  
small <= a ;  
e l s e  
end i f  ; 
end ; 
The code consists of only a single relational operator. 
the output. This can be clearly described by nested two-level if statements: 
Second, let us consider a circuit that routes the maximal value of three input signals to 
process ( a , b , c )  
begin 
if  ( a  > b )  then 
if  ( a  > c )  then 
max <= a ;  
e l s e  
max <= c ;  
end i f  ; 
i f  ( b  > c )  then 
max <= b ;  
e l s e  
max <= c ;  
end i f  ; 
e l s e  
end i f  ; 
end p r o c e s s ;  
We can translate the if statement to a “single-level” conditional signal assignment statement: 
max <= a when ( ( a  > b )  and ( a  > c ) )  e l s e  
c when ( a  > b )  e l s e  
b when ( b  > c )  e l s e  
c ;  
Since no nesting is allowed, the code is less intuitive. If concurrent statements must be 
used, a better alternative is to describe the circuit with three conditional signal assignment 
statements: 
s i g n a l  ac-max , bc-max: 
s t d - l o g i c ;  

52 
RT-LEVEL COMBINATIONAL CIRCUIT 
ac-max 
<= a when ( a  > c )  e l s e  
bc-max <= b when ( b  > c )  e l s e  
max <= ac-max when ( a  > b )  e l s e  
c ;  
c ;  
bc-max ; 
3.5.4 Unintended memory 
Although a process is flexible, a subtle error in code may infer incorrect implementation. 
One common problem is the inclusion of intended memory in a combinational circuit. The 
VHDL standard specifies that a signal will keep its previous value if it is not assigned in 
a process. During synthesis, this infers an internal state (via a closed feedback loop) or a 
memory element (such as a latch). 
To prevent unintended memory, we should observe the following rules while developing 
code for a combinational circuit: 
0 Include all input signals in the sensitivity list. 
0 Include the else branch in an if statement. 
0 Assign a value to every signal in every branch. 
For example, the following code segment tries to generate a greater-than (i.e., gt) and 
an equal-to (ie., eq) output signal: 
process ( a )  
-- b m i s s i n g  f r o m  s e n s i t i v i t y  
l i s t  
begin 
if  ( a  > b )  then 
-- e q  n o t  a s s i g n e d  i n  t h i s  b r a n c h  
e l s i f  ( a  = b )  then -- g t  n o t  a s s i g n e d  in t h i s  b r a n c h  
end i f  ; 
-- e l s e  b r a n c h  
is o m i t t e d  
gt <= )l'; 
eq <= '1); 
end p r o c e s s ;  
Although the syntax is correct, it violates all three rules. For example, gt will keep its 
previous value when the a>b expression is false and a latch will be inferred accordingly. 
The correct code should be 
process ( a ,  b) 
begin 
i f  ( a  > b )  then 
eq <= ) O ' ;  
gt <= ' 1 ' ;  
e l s i f  ( a  = b )  then 
gt <= '0'; 
eq <= ' 1 ' ;  
e l s e  
gt <= ' 0 ' ;  
eq <= 'Q'; 
end i f  ; 
end p r o c e s s ;  
Since multiple sequential signal assignment statements are allowed inside a process, we 
can correct the problem by assigning a default value in the beginning: 

CONSTANTS AND GENERICS 
53 
process (a, b) 
begin 
gt <= ’ 0 ’ ;  
eq <= ’ 0 ’ ;  
i f  ( a  > b) then 
gt <= ’ 1 ’ ;  
e l s i f  (a = b) then 
end i f  ; 
end p r o c e s s ;  
eq <= ’ 1 ’ ;  
__ a s s i g n  d e f a u l t  v a l u e  
The g t  and eq signals assume ’ 0 ) if they are not assigned a value later. As discussed 
earlier, assigning a signal multiple times inside a process can be error-prone. For synthesis, 
this should not be used in other context and should be considered as shorthand to satisfy 
the “assigning all signals in all branches” rule. 
3.6 CONSTANTS AND GENERICS 
3.6.1 Constants 
HDL code frequently uses constant values in expressions and array boundaries. One good 
design practice is to replace the “hard literals” with symbolic constants. It makes code clear 
and helps future maintenance and revision. The constant declaration can be included in the 
architecture’s declaration section, and it syntax is 
constant const-name : data-type : = value-expression; 
For example, we can declare two constants as 
constant DATA-BIT: integer : =  8 ;  
constant DATA-RANGE: integer : =  2 * * D A T A _ B I T  - 1 ;  
The constant expression is evaluated during preprocessing and thus requires no physical 
circuit. In this book, we use capital letters for constants. 
The use of a constant can best be explained by an example. Assume that we want to 
design an adder with the carry-out bit. One way to do it is to extend the input by 1 bit and 
then perform regular addition. The MSB of the summation becomes the carry-out bit. The 
code is shown in Listing 3.9. 
Listing 3.9 Adder using a hard literal 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use 
e n t i t y  add-w-carry i s  
ieee . numeric-std. a l l  ; 
5 
p o r t (  
a ,  b :  in std-logic-vector(3 downto 0); 
cout : out std-logic ; 
sum: out std-logic-vector (3 downto 0 )  
) ;  
in end add-w-carry ; 
a r c h i t e c t u r e  hard-arch of add-w-carry i s  
s i g n a l  a-ext , b-ext , sum-ext : unsigned(4 downto 0) ; 

54 
RT-LEVEL COMBINATIONAL CIRCUIT 
begin 
1 5  
a-ext <= u n s i g n e d ( ’ 0 ’  & a); 
b-ext <= unsigned( ’ 0 ’  & b) ; 
sum-ext <= a-ext + b-ext; 
sum <= std-logic-vector (sum-ext (3 downto 0 ) )  ; 
cout <= sum-ext(4); 
20 end hard-arch; 
The code is for a 4-bit adder. Hard literals, such as 3 and 4, are used for the ranges, as in 
unsigned(4 downto 0) and sum-ext (3 downto O ) ,  and the MSB, as in sum-ext (4). If 
we want to revise the code for an 8-bit adder, these literals have to be modified manually. 
This will be a tedious and error-prone process if the code is complex and the literals are 
referred to in many places. 
To improve the readability, we can use a symbolic constant, N, to represent the number 
of bits of the adder. The revised architecture body is shown in Listing 3.10. 
Listing 3.10 Adder using a constant 
a r c h i t e c t u r e  const-arch of add-w-carry is 
constant N :  integer : =  4; 
s i g n a l  a-ext , b-ext , sum-ext : unsigned(N downto 0 )  ; 
begin 
5 
a-ext <= unsigned(’0’ & a); 
b-ext <= unsigned(’0’ & b); 
sum-ext <= a-ext + b-ext; 
sum <= std-logic-vector (sum-ext ( N - l  
downto 0 ) )  ; 
cout <= sum-ext(N); 
in end const-arch; 
The constant makes the code easier to understand and maintain. 
3.6.2 Generics 
VHDL provides a construct, known as a generic, to pass information into an entity and 
component. Since a generic cannot be modified inside the architecture, it functions some- 
what like a constant. A generic is declared inside an entity declaration, just before the port 
declaration: 
e n t i t y  entity-name i s  
g e n e r i c  ( 
generic-name : data-type : = def ault-values ; 
generic-name : data-type : = def ault-values ; 
generic-name : data-type : = def ault-values 
I 
port ( 
port-name : mode data-type ; 
1 ;  
end entity-name; 
For example, the previous adder code can be modified to use the adder width as a generic, 
as shown in Listing 3.1 1. 

CONSTANTS AND GENERICS 
55 
Listing 3.11 Adder using a generic 
libr ar y ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a i l  ; 
e n t i t y  gen-add-w-carry i s  
j 
ge ne ri c (N: integer :=4); 
port ( 
a ,  b: in std-logic-vector(N-1 downto 0 ) ;  
cout : out std-logic ; 
sum: out std-logic-vector (N-1 downto 0) 
10 
1 ; 
end gen-add-w-carry ; 
a r c h i t e c t u r e  arch of gen-add-w-carry i s  
s i g n a l  a-ext , b-ext , sum-ext : unsigned(N downto 0 )  ; 
a-ext <= unsigned(’0’ & a); 
b-ext <= unsigned(’0’ & b); 
sum-ext <= a-ext + b-ext; 
sum <= std-logic-vector (sum-ext (N-1 downto 0 ) )  ; 
i j  begin 
20 
cout <= sum-ext(N); 
end arch; 
The N generic is declared in line 5 with a default value of 4. After N is declared, it can be 
used in the port declaration and architecture body, just like a constant. 
If the adder is later used as a component in other code, we can assign the desired value to 
the generic in component instantiation. This is known as generic mapping. The default value 
will be used if generic mapping is omitted. Use of the generic in component instantiation 
is shown below. 
s i g n a l  a4, b4, sum4: unsigned(3 downto 0); 
s i g n a l  a8, b8, sum8: unsigned(7 downto 0 ) ;  
s i g n a l  a16, b16, suml6: unsigned(l5 downto 0 ) ;  
s i g n a l  c4, c8, c16: std-logic; 
__ i n s t a n t i a t e  8 -  b i t  a d d e r  
adder-8-unit: work.gen-add-w-carry(arch) 
gen eri c map ( N = >8) 
port map(a=>a8, b=>b8, cout=>c8, sum=>sum8)) ; 
__ i n s t a n t i a t e  16- b i t  a d d e r  
adder-16-unit: work.gen-add-w-carry arch) 
gen eri c map (N = > 16) 
port map(a=>al6, b=>b16, cout=>c 6 ,  sum=>suml6)) ; 
__ i n s t a n t i a t e  4 -  b i t  a d d e r  
-- ( g e n e r i c  mapping o m i t t e d ,  d e f a u l t  v a l u e  4 u s e d )  
adder-4-unit: work.gen-add-w-carry(arch) 
port map(a=>a4, b=>b4, cout=>c4, sum=>sum4)) ; 
A generic provides a mechanism to create scalable code, in which the “width” of a circuit 
can be adjusted to meet a specific need. This makes code more portable and encourages 
design reuse. 

56 
FIT-LEVEL COMBINATIONAL CIRCUIT 
a 
d 
(a) Diagram of a seven-segment LED display 
(b) Hexadecimal digit patterns 
Figure 3.5 Seven-segment LED display and hexadecimal patterns. 
3.7 DESIGN EXAMPLES 
3.7.1 
The sketch of a seven-segment LED display is shown in Figure 3.5(a). It consists of seven 
LED bars and a single round LED decimal point. On the prototyping board, the seven- 
segment LED is configured as active low, which means that an LED segment is lit if the 
corresponding control signal is '0'. 
A hexadecimal digit to seven-segment LED decoder treats a 4-bit input as a hexadecimal 
digit and generates appropriate LED patterns, as shown in Figure 3.5(b). For completeness, 
we assume that there is also a 1-bit input, dp, which is connected directly to the decimal 
point LED. The LED control signals. dp, a, b, c, d. e, f ,  and g, are grouped together as a 
single 8-bit signal, sseg. The code is shown in Listing 3.12. It uses one selected signal 
assignment statement to list all the desired patterns for the seven LSBs of the sseg signal. 
The MSB is connected to dp. 
Hexadecimal digit to seven-segment LED decoder 
Listing 3.12 Hexadecimal digit to seven-segment LED decoder 
l i b r a r y  ieee; 
use i e e e .  std-logic-1164. a l l  ; 
e n t i t y  hex-to-sseg i s  
port ( 
hex: in std-logic-vector (3 downto 0) ; 
d p :  in s t d - l o g i c ;  
s s e g :  out std-logic-vector (7 downto 0 )  
1 ;  
end hex-to-sseg; 
a r c h i t e c t u r e  arch of hex-to-sseg i s  
begin 
I {I 
with hex s e l e c t  
sseg(6 downto 0 )  <= 
15 
'I 0000001 I' when 
'I 0000 I' , 
I' 1 0 0 1 1 1 1 I' when 
" 0 0 0 1 'I , 

DESIGN EXAMPLES 
57 
25 
'I 0 0  100 10 'I when 
I' 00 10 I' , 
'I 0 0 0 0 1 10 'I when 
'I 0 0 1 1 , 
'I 1 0 0 1 1 0 0 when 
I' 0 1 0 0 'I , 
' I  0 100 100 'I when 
'I 0 10 1 'I , 
'I 0 10 0 0 0 0 I' when 
' I  0 1 10 I' , 
'I 0 0 0 1  I 1  1 'I when 
It 0 1  I 1  'I , 
" 0 0 0 0 0 0 0 ~ ~  
when " 1 0 0 0 " ,  
'I 0 0 0 0 1 0 0 I '  
when 
'I 1 0 0 1 I' , 
" 0 0 0 1 0 0 0 "  when " 1 0 1 0 " ,  ---a 
" 1 1 0 0 0 0 0 "  when "1011", -4 
"0110001" when " I l O O " ,  --c 
" 1 0 0 0 0 1 0 "  when " 1 1 0 1 " ,  --d 
" 0 1 1 0 0 0 0 "  when " I l l O " ,  ---e 
in 
" 0 1 1 1 0 0 0 "  when o t h e r s  ; --f 
sseg(7) <= d p ;  
end a r c h ;  
There are four seven-segment LED displays on the prototyping board. To save the 
number of FPGA chip's I/O pins, a time-multiplexing scheme is used. The block diagram 
of the time-multiplexing module, disp-mux, is shown in Figure 3.6(a). The inputs are inO, 
inl, in2, and in3, which correspond to four 8-bit seven-segment LED patterns, and the 
outputs are an, which is a 4-bit signal that enables the four displays individually, and sseg, 
which is the shared 8-bit signal that controls the eight LED segments. The circuit generates 
a properly timed enable signal and routes the four input patterns to the output alternatively. 
The design of this module is discussed in Chapter 4. For now, we just treat it as a black box 
that takes four seven-segment LED patterns, and instantiate it in the code. 
Testing circuit We use a simple 8-bit increment circuit to verify operation of the decoder. 
The sketch is shown in Figure 3.6(b). The s w  input is the 8-bit switch of the prototyping 
board. It is fed to an incrementor to obtain sw+l. The original and incremented s w  signals 
are then passed to four decoders to display the four hexadecimal digits on seven-segment 
LED displays. The code is shown in Listing 3.13. 
Listing 3.13 Hex-to-LED decoder testing circuit 
l i b r a r y  i e e e ;  
use i e e e . s t d - l o g i c - l l 6 4 . a l l ;  
use 
e n t i t y  hex-to-sseg-test i s  
ieee . numeric-std. a l l  ; 
5 
p o r t (  
c l k :  in std-logic; 
s w :  in std-logic-vector ( 7  downto 0) ; 
a n :  out std-logic-vector (3 downto 0) ; 
sseg : out std-logic-vector (7 downto 0 )  
lo 
) ;  
end hex-to-sseg-test; 
a r c h i t e c t u r e  arch of hex-to-sseg-test i s  
s i g n a l  inc : std-logic-vector (7 downto 0) ; 
I( 
s i g n a l  l e d 3 ,  l e d 2 ,  led1 , l e d O :  std-logic-vector (7 downto 0) ; 
begin 
-_ 
i n c r e m e n t  i n p u t  
inc <= std-logic-vector(unsigned(sw) + 1); 

58 
RT-LEVEL COMBINATIONAL CIRCUIT 
+hex 
4 
-41 + 
4 
in0 
sseg 
in1 
an 
in2 
in3 
> 
disp-mux 
reset 
sseg - 
dp 
hexto-sseg 
in2 
in3 
disp-mux 
hex 
sseg - -> 
dp 
reset 
hex-to-sseg 
(a) Block diagram of an LED time-multiplexing module 
- 
hex-to-sseg ssegt- 
u 
/ 
hex 
sseg 
, 
4 
+I 
Idp 
I 
hex-to-sseg I 
ssegk 
an 
sseg 
an 
clk I
0 
(b) Block diagram of a decoder testing circuit 
Figure 3.6 LED time-multiplexing module and decoder testing circuit. 

DESIGN EXAMPLES 
59 
20 
-- i n s t a n t i a t e  f o u r  i n s t a n c e s  of h e x  d e c o d e r s  
__ i n s t a n c e  f o r  4 LSBs of i n p u t  
s s e g - u n i t - 0 :  
e n t i t y  work. h e x - t o - s s e g  
-_ 
i n s t a n c e  f o r  4 MSBs of i n p u t  
2 5  
s s e g - u n i t - 1  : e n t i t y  work. h e x - t o - s s e g  
p o r t  map(hex=>sw(3 downto 0) , dp = > ' O ' ,  
s s e g = > l e d O ) ;  
p o r t  map(hex=>sw(7 downto 4 ) ,  dp = > ' O ' ,  
s s e g = > l e d l ) ;  
-- i n s t a n c e  f o r  4 LSBs of i n c r e m e n t e d  v a l u e  
s s e g - u n i t - 2 :  
e n t i t y  work. h e x - t o - s s e g  
p o r t  m a p ( h e x = > i n c ( 3  downto O ) ,  dp =>'1', s s e g = > l e d 2 ) ;  
20 
-- i n s t a n c e  for 4 MSBs of i n c r e m e n t e d  v a l u e  
s s e g - u n i t - 3 :  
e n t i t y  work. h e x - t o - s s e g  
p o r t  m a p ( h e x = > i n c ( 7  downto 4 ) ,  dp = > ' 1 ' ,  s s e g = > l e d 3 ) ;  
__ i n s t a n t i a t e  7 - s e g  LED d i s p l a y  t i m e - m u l t i p l e x i n g  
module 
15 
d i s p - u n i t :  e n t i t y  work.disp-mux 
port map( 
c l k = > c l k ,  r e s e t = > ' O '  , 
inO=>ledO, i n l = > l e d l ,  i n 2 = > l e d 2 ,  i n 3 = > l e d 3 ,  
a n = > a n ,  s s e g = > s s e g )  ; 
10 end a r c h ;  
We can follow the procedure in Chapter 2 to synthesize and implement the circuit on 
the prototyping board. Note that the disp-rnux.vhd file, which contains the code for the 
time-multiplexing module, and the ucf constraint file must be included in the Xilinx ISE 
project during synthesis. 
3.7.2 Sign-magnitude adder 
An integer can be represented in sign-magnitude format, in which the MSB is the sign and 
the remaining bits form the magnitude. For example, 3 and -3 become "001 1" and "101 1" 
in 4-bit sign-magnitude format. 
A sign-magnitude adder performs an addition operation in this format. The operation 
can be summarized as follows: 
0 If the two operands have the same sign, add the magnitudes and keep the sign. 
0 If the two operands have different signs, subtract the smaller magnitude from the 
One possible implementation is to divide the circuit into two stages. The first stage sorts 
the two input numbers according to their magnitudes and routes them to the max and min 
signals. The second stage examines the signs and performs addition or subtraction on the 
magnitude accordingly. Note that since the two numbers have been sorted, the magnitude 
of max is always larger than that of min and the final sign is the sign of max. 
The code is shown in Listing 3.14, which realizes the two-stage implementation scheme. 
For clarity, we split the input number internally and use separate sign and magnitude signals. 
A generic, N, is used to represent the width of the adder. Note that the relevant magnitude 
signals are declared as unsigned to facilitate the arithmetic operation, and type conversions 
are performed at the beginning and end of the code. 
larger one and keep the sign of the number that has the larger magnitude. 

60 
RT-LEVEL COMBINATIONAL CIRCUIT 
Listing 3.14 Sign-magnitude adder 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  sign-mag-add i s  
5 
generic (N: integer :=4) ; -- d e f a u l t  4 b i t s  
port ( 
a ,  b: in std-logic-vector(N-1 downto 0 ) ;  
sum: out std-logic-vector (N-1 downto 0) 
1 ;  
lo end sign-mag-add ; 
a r c h i t e c t u r e  arch of sign-mag-add i s  
s i g n a l  mag-a , mag-b : unsigned (N-2 downto 0 )  ; 
s i g n a l  mag-sum , max , min: unsigned (N-2 downto 0) ; 
15 
s i g n a l  sign-a , sign-b , sign-sum: std-logic; 
begin 
mag-a <= unsigned (a(N-2 downto 0 )  ; 
mag-b <= unsigned(b(N-2 
downto 0 ) )  ; 
sign-a <= a(N-1); 
20 
sign-b <= b(N-1); 
-_ 
s o r t  a c c o r d i n g  t o  m a g n i t u d e  
process (mag-a ,mag-b , sign-a, sign-b) 
begin 
i f  mag-a > mag-b then 
25 
max <= mag-a; 
min <= mag-b; 
sign-sum <= sign-a; 
max <= mag-b; 
min <= mag-a; 
sign-sum <= sign-b; 
e l s e  
end i f  ; 
end p r o c e s s ;  
-- a d d / s u b  m a g n i t u d e  
ii 
mag-sum <= max + min when sign.-a=sign-b e l s e  
max - min; 
--form 
o u t p u t  
sum <= std-logic-vector(sign-sum 
& mag-sum); 
end arch; 
Testing circuit We use a 4-bit sign-magnitude adder to verify the circuit operation. The 
sketch of the testing circuit is shown in Figure 3.7. The two input numbers are connected to 
the 8-bit switch, and the sign and magnitude are shown on two seven-segment LED displays. 
Two pushbuttons are used as the selection signal of a multiplexer to route an operand or the 
sum to the display circuit. The rightmost even-segment LED shows the 3-bit magnitude, 
which is appended with a '0' in front and fed to the hexadecimal to seven-segment LED 
decoder. The next LED displays the sign bit, which is blank for the plus sign and is lit 
with a middle LED segment for the minus sign. The two LED patterns are then fed to the 
time-multiplexing module, dispmux, as explained in Section 3.7.1. The code is shown in 
Listing 3.15. 

DESIGN EXAMPLES 
61 
mOut(2-0) 
hex 
sseg - 
dP 
hex-to-sseg 
Figure 3.7 
Sign-magnitude adder testing circuit. 
sseg 
an 
disp-mux 
reset 
Listing 3.15 
Sign-magnitude adder testing circuit 
- 
sseg 
- 
an 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  sm-add-test i s  
5 
p o r t (  
clk: in std-logic; 
btn: in std-logic-vector (1 downto 0) ; 
sw: in std-logic-vector ( 7  downto 0) ; 
an: out std-logic-vector (3 downto 0) ; 
in 
sseg : out std-logic-vector ( 7  downto 0) 
) ;  
end sm-add-test; 
a r c h i t e c t u r e  arch of sm-add-test i s  
1 5  
s i g n a l  sum, mout , oct : std-logic-vector (3 downto 
s i g n a l  led3, led2, led1 , led0 : std-logic-vector ( 
__ i n s t a n t i a t e  a d d e r  
sm-adder-unit : e n t i t y  work. sign-mag-add 
20 
g e n e r i c  map ( N = >4) 
begin 
port map(a=>sw(3 
downto 0) , b=>sw(7 downto 4) 
sum=>sum); 
--3-to 
- I  mux t o  s e l e c t  a n u m b e r  t o  d i s p l a y  
2: 
with btn s e l e c t  
mout <= sw(3 downto 0) when " 0 0 " ,  -- a 
sw(7 downto 4) when " O l " ,  -- b 
sum 
sum when o t h e r s ;  
_- 
0) ; 
downto 0); 
30 
-- m a g n i t u d e  d i s p l a y e d  on r i g h t m o s t  7 - s e g  LED 
act <= '0' & mout (2 downto 0) ; 
sseg-unit : e n t i t y  work. hex-to-sseg 
_- 
s i g n  d i s p l a y e d  on 2 n d  7 - s e g  LED 
port map(hex=>oct , dp=> ' 0 '  , sseg=>ledO) ; 

62 
FIT-LEVEL COMBINATIONAL CIRCUIT 
led1 <= "11111110" when mout(3)='l' 
e l s e  -- m i d d l e  b a r  
-- o t h e r  two 7 - s e g  
LEDs b l a n k  
led2 <= " 1 1 1 1 1 1 1 1 " ;  
led3 <= "11111111"; 
" 11 1 1  1 1  11 " ; 
_- 
b l a n k  
40 
-- in s t a n t i a t e 
disp-unit : e n t i t y  work. disp-mux 
port map( 
d i s p l a y  m u  1 t i p  1 e x e  r 
c l k = > c l k ,  reset=>'O', 
a n = > a n ,  sseg=>sseg) ; 
4% 
i n O = > l e d O ,  i n l = > l e d l ,  i n 2 = > l e d 2 ,  in3=>led3, 
end arch; 
3.7.3 Barrel shifter 
Although VHDL has built-in shift functions, they sometimes cannot be synthesized auto- 
matically. In this subsection, we examine an 8-bit barrel shifter that rotates an arbitrary 
number of bits to right. The circuit has an 8-bit data input, a, and a 3-bit control signal, amt, 
which specifies the amount to be rotated. The first design uses a selected signal assignment 
statement to exhaustively list all combinations of the amt signal and the corresponding 
rotated results. The code is shown in Listing 3.16. 
Listing 3.16 Barrel shifter using a selected signal assignment statement 
l i b r a r y  ieee; 
use ieee . std-logic-1164. a l l  ; 
e n t i t y  barrel-shifter i s  
port ( 
a: in std-logic-vector (7 downto 0) ; 
a m t :  in std-logic-vector (2 downto 0) ; 
y :  out std-logic-vector (7 downto 0) 
) ;  
end barrel-shifter ; 
a r c h i t e c t u r e  sel-arch of barrel-shifter i s  
begin 
10 
with amt s e l e c t  
y < =  a 
when "000" , 
a(l downto 0) & a(7 downto 2) when " O l O " ,  
a(2 downto 0) & a(7 downto 3) when "Oil", 
a(3 downto 0) & a(7 downto 4) when " l O O " ,  
a(4 downto 0) & a(7 downto 5) when "101", 
20 
a(5 downto 0) & a(7 downto 6 )  when " 1 1 0 " ,  
a(6 downto 0) & a(7) when o t h e r s ;  -- 1 1 1  
i s  
a(0) & a(7 downto 1) 
when " O O l " ,  
end sel-arch; 
While the code is straightforward, it will become cumbersome when the number of input 
bits increases. Furthermore, a large number of choices implies a wide multiplexer, which 
makes synthesis difficult and leads to a large propagation delay. Alternatively, we can 
construct the circuit by stages. In the nth stage, the input signal is either passed directly to 

DESIGN EXAMPLES 
63 
output or rotated right by 2n positions. The nth stage is controlled by the nth bit of the amt 
signal. Assume that the 3 bits of amt are mzmlmo. The total rotated amount after three 
stages is r 1 z z 2 ~  + m121 + mo2’, which is the desired rotating amount. The code for this 
scheme is shown in Listing 3.17. 
Listing 3.17 Barrel shifter using multi-stage shifts 
a r c h i t e c t u r e  multi-stage-arch of barrel-shifter is 
s i g n a l  S O ,  sl: std-logic-vector ( 7  downto 0) ; 
begin 
__ s t a g e  0 ,  s h i f t  0, or I 
b i t  
T 
S O  <= a(0) & a(7 downto 1) when amt(O)=’l’ e l s e  
a ;  
__ s t a g e  1 ,  s h i f t  0 o r  2 b i t s  
sl <= s O ( 1  downto 0) & s O ( 7  downto 2) when arnt(l)=’l’ e l s e  
so ; 
10 
-- s t a g e  2 ,  s h i f t  0 or 4 b i t s  
y <= s i ( 3  downto 0) & s O ( 7  downto 4) when amt(2)=’l’ e l s e  
s l ;  
end multi-stage-arch ; 
Testing circuit To test the circuit, we can use the 8-bit switch for the a signal, three 
pushbutton switches for the a t  signal, and the eight discrete LEDs for output. Instead of 
deriving a new constraint file for pin assignment, we create a new HDL file that wraps the 
barrel shifter circuit and maps its signals to the prototyping board’s signals. The code is 
shown in Listing 3.18. 
Listing 3.18 Barrel shifter testing circuit 
l i b r a r y  ieee ; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  shifter-test is 
.F 
p o r t (  
sw: in std-logic-vector (7 downto 0) ; 
b t n :  in std-logic-vector (2 downto 0) ; 
l e d :  out std-logic-vector ( 7  downto 0) 
1 ;  
10 end shifter-test; 
a r c h i t e c t u r e  arch of shifter-test i s  
begin 
shift-unit : e n t i t y  work.barrel-shifter(multi-stage-arch) 
li 
port map(a=>sw, amt=>btn, y = > l e d ) ;  
end arch; 
3.7.4 Simplified floating-point adder 
Floating point is another format to represent a number. With the same number of bits, 
the range in floating-point format is much larger than that in signed integer format. Al- 
though VHDL has a built-in floating-point data type, it is too complex to be synthesized 
automatically. 

64 
RT-LEVEL COMBINATIONAL CIRCUIT 
sort 
align 
addsub 
normalize 
eg. 1 
+ 0 . 5 4 E 3  
-0.87E4 
-0.87E4 
-0.87E4 
-0.87E4 
+ 0 . 5 4 E 3  
+0.05E4 
+0.05E4 
-0.82E4 
~~~~ 
eg. 2 
+O. 54E3 
-0.55E3 
-0.55E3 
-0.55E3 
-0.55E3 
+0.54E3 
+ 0 . 5 4 E 3  
+0.54E3 
-0.01E3 
~~~~ 
eg. 3 
+O. 54E0 
-0.55EO 
-0.55EO 
-0.55EO 
-0.55EO 
+0.54EO 
+0.54EO 
+0.54EO 
-0. OlEO 
~
~
_
_
_
-0.87E4 
+O .05E4 
-0.82E4 
-0.55E3 
+ O .  54E3 
-0.10E2 
-0.55EO 
+ O .  54E0 
-0. OOEO 
+ O .  56E3 
+O .52E3 
+O. 10E4 
Figure 3.8 Floating-point addition examples. 
Detailed discussion of floating-point representation is beyond the scope of this book. 
We use a simplified 13-bit format in this example and ignore the round-off error. The 
representation consists of a sign bit, s, which indicates the sign of the number (1 for 
negative); a 4-bit exponent field, e, which represents the exponent; and an 8-bit significand 
field, f ,  which represents the significand or the fraction. In this format. the value of a 
floating-point number is (-1)‘ * . f  * 2“. The . f  * 2“ is the magnitude of the number and 
(-1)‘ is just a formal way to state that ‘‘s equal to 1 implies a negative number.” Since 
the sign bit is separated from the rest of the number, floating-point representation can be 
considered as a variation of the sign-magnitude format. 
We also make the following assumptions: 
Both exponent and significand fields are in unsigned format. 
The representation has to be either normalized or zero. Normalized representa- 
tion means that the MSB of the significand field must be ’1’. If the magnitude of 
the computation result is smaller than the smallest normalized nonzero magnitude, 
0.10000000 * 2Oooo, it must be converted to zero. 
Under these assumptions, the largest and smallest nonzero magnitudes are 0.11 11 11 11 * 
2l1I1 and 0.10000000 * 20°00, and the range is about 216 (i.e., 
Our floating-point adder design follows the process of adding numbers manually in 
scientific notation. This process can best be explained by examples. We assume that the 
widths of the exponent and significand are 2 and 1 digits, respectively. Decimal format 
is used for clarity. The computations of several representative examples are shown in 
Figure 3.8. The computation is done in four major steps: 
1. Sorting: puts the number with the larger magnitude on the top and the number with 
the smaller magnitude on the bottom (we call the sorted numbers “big number” and 
“small number”). 
2. Alignment: aligns the two numbers so they have the same exponent. This can be 
done by adjusting the exponent of the small number to match the exponent of the big 
~AAAA~A~~$i~~). 

DESIGN EXAMPLES 
65 
number. The significand of the small number has to shift to the right according to the 
difference in exponents. 
3. Additionhubtraction: adds or subtracts the significands of two aligned numbers. 
4. Normalization: adjusts the result to normalized format. Three types of normalization 
0 After a subtraction, the result may contain leading zeros in front, as in example 2. 
0 After a subtraction, the result may be too small to be normalized and thus needs 
0 After an addition, the result may generate a carry-out bit, as in example 4. 
procedures may be needed: 
to be converted to zero, as in example 3. 
Our binary floating-point adder design uses a similar algorithm. To simplify the imple- 
mentation, we ignore the rounding. During alignment and normalization, the lower bits of 
the significand will be discarded when shifted out. The design is divided into four stages, 
each corresponding to a step in the foregoing algorithm. The suffixes, ‘b’, ‘s’, ‘a’, ‘r’, and 
‘n’, used in signal names are for “big number,” “small number,” “aligned number,” “result 
of additionisubtraction,” and “normalized number,” respectively. The code is developed 
according to these stages, as shown in Listing 3.19. 
Listing 3.19 Simplified floating-point adder 
libr ar y ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  fp-adder i s  
5 
port ( 
signl , sign2 : in 
std-logic ; 
expl , exp2 : in 
std-logic-vector (3 downto 0 )  ; 
fracl , f r a c 2 :  in 
std-logic-vector (7 downto 0) ; 
sign-out: out std-logic; 
frac-out : out std-logic-vector ( 7  downto 0 )  
10 
exp-out : out std-logic-vector (3 downto 0) ; 
1 ;  
end fp-adder ; 
15 a r c h i t e c t u r e  arch of fp-adder i s  
_- 
s u f f i x  b ,  s ,  a ,  n f o r  
_- 
b i g ,  s m a l l ,  a l i g n e d ,  n o r m a l i z e d  number 
s i g n a l  signb , signs : std-logic; 
s i g n a l  expb, exps , expn: unsigned (3 downto 0) ; 
s i g n a l  sum-norm: unsigned ( 7  downto 0 )  ; 
s i g n a l  exp-diff : unsigned (3 downto 0) ; 
s i g n a l  s u m :  unsigned(8 downto 0); --one 
e x t r a  f o r  c a r r y  
s i g n a l  leadO: unsigned (2 downto 0) ; 
-- 1 s t  s t a g e :  s o r t  t o  find t h e  l a r g e r  number 
process (signl , sign:!, 
e x p l ,  exp2, fracl , frac2) 
begin 
:C 
s i g n a l  fracb, fracs, fraca, fracn: unsigned(7 downto 0 ) ;  
25 begin 
if (expl & fracl) > (exp2 & frac2) then 
10 
signb <= s i g n l ;  
signs <= s i g n 2 ;  
expb <= unsigned (expl) ; 
exps <= unsigned (exp2) ; 

66 
RT-LEVEL COMBINATIONAL CIRCUIT 
40 
so 
fracb <= unsigned(frac1); 
5 
fracs <= unsigned(frac2); 
e l s e  
signb <= s i g n 2 ;  
signs <= signl; 
expb <= unsigned (exp2 ) ; 
exps <= unsigned (expl) ; 
fracb <= unsigned(frac2); 
fracs <= unsigned(frac1); 
end i f  ; 
end p r o c e s s ;  
__ 
2nd s t a g e :  a l i g n  s m a l l e r  number 
exp-diff <= expb - exps; 
w ith  exp-diff s e l e c t  
45 
fraca <= 
fracs 
" 0 " 
& fracs(7 downto 1) 
'I 0 0 I' 
& fracs(7 downto 2 )  
I' 000 " 
& fracs(7 downto 3 )  
" 0000 " 
& fracs(7 downto 4) 
''00000" 
& fracs ( 7  downto 5 )  
" 0 0 0 0 0 0 "  
& fracs (7 downto 6) 
"0000000'' & fracs (7) 
" 00000000" 
when 
when 
when 
when 
when 
when 
when 
when 
when 
" 0 0 0 0 "  , 
" O O O l " ,  
" 0 0 1 0 "  , 
" 0 0 1 1 "  , 
" 0 1 0 0 "  , 
"OlOI", 
" 0 1 10 " , 
" O l l l " ,  
o t h e r s  ; 
60 
-- 3 r d  s t a g e  : a d d / s u b t r a c t  
sum <= ( ' 0 '  & fracb) + ( ' 0 '  & fraca) when signb=signs e l s e  
( ' 0 '  & fracb) - ( ' 0 '  & fraca); 
70 
XI1 
-- 4 t h  s t a g e  : n o r m a l i z e  
lead0 <= " 0 0 0 "  when (sum(7)='l') 
e l s e  
" 0 0 1 "  when (sum(6)='1') 
e l s e  
" 0 1 0 "  when (sum(5)='1') 
e l s e  
'loll" when (sum(4)='1') 
e l s e  
11100" when (sum(3)='1') 
e l s e  
" 1 0 1 "  when (sum(2)='1') 
e l s e  
" 1 1 0 "  when (sum(l)='l') 
e l s e  
'I 11 1 " ; 
a5 
-- c o u n t  l e a d i n g  0 s  
_- 
s h i f r  s i g n i f i c a n d  a c c o r d i n g  t o  l e a d i n g  0 
-5 
with lead0 s e l e c t  
sum-norm <= 
sum(7 downto 0) 
when " 0 0 0 "  , 
sum(6 downto 0) & 
' 0 '  
when " O O l " ,  
sum(5 downto 0 )  & " 0 0 "  
when "OIO", 
sum(4 downto 0 )  & " 0 0 0 "  
when "Oil", 
sum(3 downto 0 )  & " 0 0 0 0 "  
when " l O O " ,  
sum(2 downto 0 )  & " 0 0 0 0 0 "  
when "101", 
s u m ( 1  downto 0 )  & " 0 0 0 0 0 0 "  
when " 1 1 0 " ,  
sum(0) & 
~ t O O O O O O O 1 ~  
when o t h e r s  ; 
*, 
__ n o r m a l i z e  with s p e c i a l  c o n d i t i o n s  

DESIGN EXAMPLES 
67 
90 
95 
p rocess (sum, sum-norm, expb, leado) 
begin 
i f  s u r n ( S ) = ’ l ’  then -- w /  c a r r y  o u t ;  s h i f t  f r a c  t o  r i g h t  
expn <= expb + 1 ;  
fracn <= sum(8 downto 1); 
expn <= ( o t h e r s = > ’ O ’ ) ;  -- s e t  t o  0 
fracn <= ( o t h e r s = > ’ O ’ ) ;  
expn <= expb - l e a d 0 ;  
fracn <= sum-norm; 
e l s i f  (lead0 > expb) then -- t o o  s m a l l  t o  n o r m a l i z e ;  
e l s e  
end i f ;  
end p r o c e s s ;  
-- f o r m  o u t p u t  
sign-out <= s i g n b ;  
exp-out <= std-logic-vector(expn); 
frac-out <= std-logic-vector(fracn); 
I00 
105 end a r c h ;  
The circuit in the first stage compares the magnitudes and routes the big number to the 
signb, expb, and fracb signals and the smaller number to the signs, exps, and fracs 
signals. The comparison is done between expl&f r a c l  and exp2&f rac2. It implies that 
the exponents are compared first, and if they are the same, the significands are compared. 
The circuit in the second stage performs alignment. It first calculates the difference 
between the two exponents, which is expb-exps, and then shifts the significand, fracs, 
to the right by this amount. The aligned significand is labeled f raca. The circuit in the 
third stage performs sign-magnitude addition, similar to that in Section 3.7.2. Note that the 
operands are extended by 1 bit to accommodate the carry-out bit. 
The circuit in the fourth stage performs normalization, which adjusts the result to make 
the final output conform to the normalized format. The normalization circuit is constructed 
in three segments. The first segment counts the number of leading zeros. It is somewhat 
like a priority encoder. The second segment shifts the significands to the left by the amount 
specified by the leading-zero counting circuit. The last segment checks the carry-out and 
zero conditions and generates the final normalized number. 
Testing circuit The floating-point adder has two 13-bit input operands. Since the proto- 
typing board has only one 8-bit switch and four 1-bit pushbuttons, it cannot provide enough 
number of physical inputs to test the circuit. To accommodate the 26 bits of the floating- 
point adder, we must create a testing circuit and assign constants or duplicated switch signals 
to the adder’s input operands. An example is shown in Listing 3.20. It assigns one operand 
as constant and uses duplicated switch signals for the other operand. The addition result is 
passed to the hexadecimal decoders and the sign circuit and is shown on the seven-segment 
LED display. 
Listing 3.20 Floating-point adder testing circuit 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  fp-adder-test i s  
5 
p o r t (  

68 
RT-LEVEL COMBINATIONAL CIRCUIT 
clk: in std-logic; 
sw: in std-logic-vector (7 downto 0) ; 
btn: in std-logic-vector (3 downto 0) ; 
an: out std-logic-vector (3 downto 0) ; 
10 
sseg: out std-logic-vector (7 downto 0) 
) ;  
end fp-adder-test; 
architecture arch of fp-adder-test is 
15 
signal signl , sign2 : std-logic; 
signal expl , exp2: std-logic-vector (3 downto 0) ; 
signal fracl , frac2 : std-logic-vector (7 downto 0) ; 
signal sign-out : std-logic; 
signal exp-out : std-logic-vector (3 downto 0) ; 
signal led3, led2, ledl, ledO: 
20 
signal frac-out : std-logic-vector (7 downto 0) ; 
std-logic-vector (7 downto 0) ; 
begin 
__ s e t  u p  t h e  f p  a d d e r  i n p u t  s i g n a l s  
expl <= "1000"; 
frac1<= '1' & 
sw(1) & sw(0) & " 1 0 1 0 1 " ;  
sign2 <= sw(7); 
exp2 <= btn; 
25 
signl <= ' 0 ' ;  
10 
frac2 <= '1' & sw(6 downto 0); 
__ i n s t a n t i a t e  fp a d d e r  
fp-add-unit : entity work. fp-adder 
port map( 
3' 
signl=>signl, sign2=>sign2, expl=>expl, exp2=>exp2, 
fracl=>fracl, fracZ=>frac2, 
sign-out=>sign-out , exp-out=>exp-out , 
frac-out=>frac-out 
1 ;  
40 
__ i n s t a n t i a t e  t h r e e  i n s t a n c e s  of h e x  d e c o d e r s  
sseg-unit-0 : entity work. hex-to-sseg 
e x p  o n  e n  t 
port map(hex=>exp-out , dp=>'O' , sseg=>ledO); 
__ 
45 
-- 4 LSBs of f r a c t i o n  
sseg-unit-1 : entity work. hex-to-sseg 
port map(hex=>frac-out (3 downto 0) , 
dp=>' 1 ' , 
50 
sseg-unit-2: entity work. hex-to-sseg 
sseg=>ledl) ; 
-- 4 MSBs of f r a c t i o n  
port map(hex=>frac-out ( 7  downto 4 ) ,  
dp=>'O', sseg=>led2); 
__ s i g n  
led3 <= " 1 1 1 1 1 1 1 0 "  when sign-out='l' else -- m i d d l e  b a r  
55 
" 11 11 11 11 " ; 
__ b l a n k  
-_ 
i 11 s t a n  t i a  t e  7 -  s e g  LED d i s p  l a j  t i m e  - m u  1 t i p 1  e x i n g  m o d u l e  
disp-unit : entity work.disp-mux 

BIBLIOGRAPHIC NOTES 
69 
port map( 
60 
c l k = > c l k ,  r e s e t = > ' O '  , 
inO=>ledO, i n l = > l e d l ,  i n 2 = > l e d 2 ,  i n 3 = > l e d 3 ,  
a n = > a n ,  s s e g = > s s e g  
1 ;  
end a r c h ;  
3.8 BIBLIOGRAPHIC NOTES 
The Designer's Guide to VHDL by P. J. Ashenden provides detailed coverage on the VHDL 
constructs discussed in this chapter, and the author's RTL Hardware Design Using VHDL: 
Coding for Eficiency, Portability, and Scalability discusses the coding and optimization 
schemes and gives additional design examples. 
3.9 SUGGESTED EXPERIMENTS 
3.9.1 Multi-function barrel shifter 
Consider an %bit shifting circuit that can perform rotating right or rotating left. An addi- 
tional l-bit control signal, lr, specifies the desired direction. 
1. 
2. 
3. 
4. 
5. 
6. 
7. 
Design the circuit using one rotate-right circuit, one rotate-left circuit, and one 2-to- 1 
multiplexer to select the desired result. Derive the code. 
Derive a testbench and use simulation to verify operation of the code. 
Synthesize the circuit, program the FPGA, and verify its operation. 
This circuit can also be implemented by one rotate-right shifter with pre- and post- 
reversing circuits. The reversing circuit either passes the original input or reverses 
the input bitwise (for example, if an %bit input is a7a6a5a4a3a2a1ao3 the reversed 
result becomes aOa1a2a3f&5a5a6a7). Repeat steps 2 and 3. 
Check the report files and compare the number of logic cells and propagation delays 
of the two designs. 
Expand the code for a 16-bit circuit and synthesize the code. Repeat steps 1 to 5. 
Expand the code for a 32-bit circuit and synthesize the code. Repeat steps 1 to 5. 
3.9.2 Dual-priority encoder 
A dual-priority encoder returns the codes of the highest or second-highest priority requests. 
The input is a 12-bit req signal and the outputs are first and second, which are the 4-bit 
binary codes of the highest and second-highest priority requests, respectively. 
1. Design the circuit and derive the code. 
2. Derive a testbench and use simulation to verify operation of the code. 
3. Design a testing circuit that displays the two output codes on the seven-segment LED 
4. Synthesize the circuit, program the FPGA, and verify its operation. 
display of the prototyping board, and derive the code. 
3.9.3 BCD incrementor 
The binary-coded-decimal (BCD) format uses 4 bits to represent 10 decimal digits. For 
example, 25910 is represented as "0010 0101 1001" in BCD format. A BCD incrementor 

70 
RT-LEVEL COMBINATIONAL CIRCUIT 
adds 1 to a number in BCD format. For example, after incrementing, "0010 0101 1001" 
(i.e., 25910) becomes "0010 01 10 0000" (i.e., 26OlO). 
1. Design a three-digit 12-bit incrementor and derive the code. 
2. Derive a testbench and use simulation to verify operation of the code. 
3. Design a testing circuit that displays three digits on the seven-segment LED display 
4. Synthesize the circuit, program the FPGA, and verify its operation. 
and derive the code. 
3.9.4 Floating-point greater-than circuit 
A floating-point greater-than circuit compares two floating-point numbers and asserts out- 
put, gt, when the first number is larger than the second number. Assume that the two 
numbers are represented in the format discussed in Section 3.7.4. 
1. Design the circuit and derive the code. 
2. Derive a testbench and use simulation to verify operation of the code. 
3. Design a testing circuit and derive the code. 
4. Synthesize the circuit, program the FPGA, and verify its operation. 
3.9.5 Floating-point and signed integer conversion circuit 
A number may need to be converted to different formats in a large system. Assume that 
we use the 13-bit format in Section 3.7.4 for the floating-point representation and the 
8-bit signed data type for the integer representation. An integer-to-floating-point conver- 
sion circuit converts an 8-bit integer input to a normalized, 13-bit floating-point output. 
A floating-point-to-integer conversion circuit reverses the operation. Since the range of 
a floating-point number is much larger, conversion may lead to the underflow condition 
(i.e., the magnitude of the converted number is smaller than "00000001") or the overflow 
condition (i.e., the magnitude of the converted number is larger than "01 11 11 11 "). 
1. Design an integer-to-floating-point conversion circuit and derive the code. 
2. Derive a testbench and use simulation to verify operation of the code. 
3. Design a testing circuit and derive the code. 
4. Synthesize the circuit, program the FPGA, and verify its operation. 
5. Design a floating-point-to-integer conversion circuit. In addition to the &bit integer 
output, the design should include two status signals, uf and of, for the underflow 
and overflow conditions. Derive the code and repeat steps 2 to 4. 
3.9.6 Enhanced floating-point adder 
The floating-point adder in Section 3.7.4 discards the lower bits when they are shifted out 
(it is known as round to zero). A more accurate method is to round to the nearest even, 
as defined in the IEEE Standard for Binary Floating-point Arithmetic (IEEE Std 754). 
Three extra bits, known as the guard, round, and sticky bits, are required to implement this 
method. If you learned floating-point arithmetic before, modify the floating-point adder in 
Section 3.7.4 to accommodate the round-to-the-nearest-even method. 

CHAPTER 4 
REGULAR SEQUENTIAL CIRCUIT 
4.1 INTRODUCTION 
A sequential circuit is a circuit with memory, which forms the internal state of the circuit. 
Unlike a combinational circuit, in which the output is a function of input only, the output 
of a sequential circuit is a function of the input and the internal state. The synchronous 
design methodology is the most commonly used practice in designing a sequential circuit. In 
this methodology, all storage elements are controlled (i.e., synchronized) by a global clock 
signal and the data is sampled and stored at the rising or falling edge of the clock signal. It 
allows designers to separate the storage components from the circuit and greatly simplifies 
the development process. This methodology is the most important principle in developing 
a large, complex digital system and is the foundation of most synthesis, verification, and 
testing algorithms. All of the designs in the book follow this methodology. 
4.1.1 D FF and register 
The most basic storage component in a sequential circuit is a D-type flip-flop (D FF). The 
symbol and function table of a positive edge-triggered D FF are shown in Figure 4.l(a). 
The value of the d signal is sampled at the rising edge of the clk signal and stored to FF. 
A D FF may contain an asynchronous reset signal to clear the FF to '0'. Its symbol and 
function table are shown in Figure 4.l(b). Note that the reset operation is independent of 
the clock signal. 
FPGA Protowping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
71 

72 
REGULAR SEQUENTIAL CIRCUIT 
output 
logic 
~ 
d 
- 
next-state 
* 
external 
input 
cI k 
- 
logic 
clk 
q* 
4 
4 
f
d
 
state-next 
> 
(a) D FF 
reset 
clk 
q* 
-
0
 
~~ 
(b) D FF with asynchronous reset 
reset 
clk 
en 
q* 
1 
0 
4 
0
1
 
4 
reset 
o
f
0
 4 
(c) D FF with synchronous enable 
Figure 4.1 Block diagram and functional table of a D FF. 
n 
OUtDUt 
Figure 4.2 Block diagram of a synchronous system. 
The three main timing parameters of a D FF are Tcq (clock-to-q delay), Tsetup (setup 
time), and Thold (hold time). Tcq is the time required to propagate the value of d to q at 
the rising edge of the clock signal. The d signal must be stable around the sampling edge 
to prevent the FF from entering the metastable state. Tsetup 
and Thold specify the time 
intervals before or after the sampling edge. 
A D FF provides 1-bit storage. A collection of D FFs can be grouped together to store 
multiple bits and is known as a register. 
4.1.2 
Synchronous system 
Block diagram 
consists of the following parts: 
The block diagram of a synchronous system is shown in Figure 4.2. It 
0 State register: a collection of D FFs controlled by the same clock signal 

INTRODUCTION 
73 
Next-state logic: combinational logic that uses the external input and internal state 
(i.e., the output of register) to determine the new value of the register 
Output logic: combinational logic that generates the output signal 
Max..nal operating frequency One of the most difficult design aspects of a sequential 
circuit is to ensure that the system timing does not violate the setup and hold time constraints. 
In a synchronous system, the storage components are grouped together and treated as a single 
register, as shown in Figure 4.2. We need to perfom timing analysis on only one memory 
component. 
The timing of a sequential circuit is characterized by f m a z ,  the maximal clock frequency, 
which specifies how fast the circuit can operate. The reciprocal of f m a z  specifies Tclock, 
the minimal clock period, which can be interpreted as the interval between two sampling 
edges of the clock. To ensure correct operation, the next value must be generated and 
stabilized within this interval. Assume that the maximal propagation delay of next-state 
logic is Tcomb. The minimal clock period can be obtained by adding the propagation delays 
and setup time constraint of the closed loop in Figure 4.2: 
Tclock = Tcq + T c o m b  + Tsetup 
and the maximal clock rate is the reciprocal: 
1 
- 
1 
-- 
f m a x  = 
Tclock 
Tcq + T c o m b  + Tsetup 
Timing constraint in Xilinx lSEXilinX wecif ic 
During synthesis, Xilinx software 
will analyze the synthesized circuit and show fmaz in a report. We can also specify the 
desired operating frequency as a synthesis constraint, and the synthesis software will try to 
obtain a circuit to satisfy this requirement (i.e., a circuit whose fmax is equal to or greater 
than the desired operating frequency). For example, if we use the 50-MHz (i.e., 20-ns 
period) oscillator on the prototyping board as the clock source, fmaz of a sequential circuit 
must exceed this frequency (i.e., the period must be smaller than 20 ns). The following 
lines can be added to the constraint file: 
NET "clk" TNM-NET = "clk"; 
TIMESPEC "TS-clk" = PERIOD "clk" 20 ns HIGH 50 % ;  
This indicates that the clk signal has a maximal period of 20 ns (i.e., 50 MHz) and a duty 
cycle of 50%. 
After synthesis, we can check the relevant timing information by invoking the View 
Design Summary process from the ISE's Processes window. The Timing Constraints sec- 
tion shows whether the imposed constraints are met, and the Static Timing Report section 
provides more detailed timing information. 
4.1.3 Code development 
Our code development follows the basic block diagram in Figure 4.2. The key is to separate 
the memory component (i.e., the register) from the system. Once the register is isolated, 
the remaining portion is a pure combinational circuit, and the coding and analysis schemes 
discussed in previous chapters can be applied accordingly. While this approach may make 
the code a little bit more cumbersome at times, it helps us to better visualize the circuit 
architecture and avoid unintended memory and subtle mistakes. 

74 
REGULAR SEQUENTIAL CIRCUIT 
Based on the characteristics of the next-state logic, we divide sequential circuits into 
0 Regular sequential circuit. The state transitions in the circuit exhibit a “regular” 
pattern, as in a counter or shift register. The next-state logic is constructed primarily 
by a predesigned, “regular” component, such as an incrementor or shifter. 
0 FSM. The state transitions in the circuit do not exhibit a simple, repetitive pattern. 
The next-state logic is constructed by “random logic” and synthesized from scratch. 
It should be called a random sequential circuit, but is commonly known as an FSM 
(finite state machine). 
0 FSMD. The circuit consists of a regular sequential circuit and an FSM. The two parts 
are known as a data path and a control path, and the complete circuit is known as an 
FSMD (FSM with data path). This type of circuit is used to implement an algorithm 
represented by register-transfer (RT) methodology, which describes system operation 
by a sequence of data transfers and manipulations among registers. 
three categories: 
The three types of circuits are discussed in this and two subsequent chapters. 
4.2 HDL CODE OF THE FF AND REGISTER 
Describing storage components in HDL is a subtle procedure, and there are many ways to 
do it. In fact, one common problem encountered by a new HDL user is the inference of 
unintended latches and buffers. Instead of covering all possible forms of syntactic descrip- 
tions, we introduce the code segments for several commonly used memory components. 
Since our development process separates the register and the combinational circuit, these 
components are sufficient for all designs in this book. The components are: 
0 D F F  
0 Register 
0 Register file 
4.2.1 D FF 
We consider three types of D FFs: 
0 D FF without asynchronous reset 
0 D FF with asynchronous reset 
0 D FF with synchronous enable 
The first two are the most basic memory components and can be found in the library of 
any device technology. The third can be constructed from a simple D FF. We include the 
code since it is a frequently used memory component and can be mapped to the FF of the 
Spartan-3 device’s logic cell. 
D FF without asynchronous reset The function table of a D FF is shown in Fig- 
ure 4.l(a) and the code is shown in Listing 4.1. 
Listing 4.1 D FF without asynchronous reset 
l i b r a r y  i e e e ;  
use i e e e .  std-logic-1164. a l l  ; 
e n t i t y  d - f f  
i s  
port ( 
clk: in std-logic; 

HDL CODE OF THE FF AND REGISTER 
75 
d :  in std-logic; 
q :  out std-logic 
1 ;  
end d-ff ; 
a r c h i t e c t u r e  arch of d-ff i s  
begin 
10 
process (clk) 
begin 
15 
i f  (clk’event and clk=’l’) then 
q <= d ;  
end i f  ; 
end p r o c e s s ;  
end a r c h ;  
The rising edge is checked by the clk event and elk=' 1 expression, which represents 
that there is a change in the clk signal (i.e., an “event”) and the new value is ’1’. If this 
condition is true, the value of d is stored to q, and if this condition is false, q keeps its 
previous value (i.e.. memorizes the value sampled earlier). Note that only the clk signal is 
included in the sensitive list. This is consistent with the fact that the d signal is sampled only 
at the rising edge of the clk signal, and change in its value does not trigger any immediate 
response. 
D FF with asynchronous reset A D FF may contain an asynchronous reset signal, as 
shown in the function table of Figure 4.l(b). The signal clears the D FF to ’0’ any time and is 
not controlled by the clock signal. It actually has a higher priority than the regularly sampled 
input. Using an asynchronous reset signal violates the synchronous design methodology 
and thus should be avoided in normal operation. Its major application is to perform system 
initialization. For example, we can generate a short reset pulse to force a system to an initial 
state after turning on the power. The code for a D FF with asynchronous reset is shown in 
Listing 4.2. 
Listing 4.2 D FF with asvnchronous reset 
l i b r a r y  i e e e ;  
use i e e e .  std-logic-1164. a l l  ; 
e n t i t y  d-ff-reset i s  
port ( 
5 
clk, r e s e t :  in std-logic; 
d :  in std-logic; 
q :  out std-logic 
1 ;  
end d-f f -reset ; 
a r c h i t e c t u r e  arch of d-ff-reset i s  
begin 
10 
process (clk, reset 1 
begin 
I5 
i f  ( r e s e t = ’ l ’ )  then 
q < = ’ O ’ ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end i f  ; 
q <= d ;  

76 
REGULAR SEQUENTIAL CIRCUIT 
XI 
end p r o c e s s ;  
end a r c h ;  
Note that the reset signal is included in the sensitivity list, and its condition is checked 
before the rising-edge condition. 
D FF with synchronous enable A D FF may include an additional control signal, 
en, to enable the FF to sample the input value. Its symbol and functional table are shown 
in Figure 4.l(c). Note that the en signal is examined only at the rising edge of the clock 
and thus is synchronous. If it is not asserted, the FF keeps its previous value. The code is 
shown in Listing 4.3. 
Listing 4.3 One-process coding style for a D FF with synchronous enable 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 
e n t i t y  d-ff-en i s  
port ( 
3 
c l k ,  r e s e t :  in std-logic; 
e n :  in std-logic; 
d :  in std-logic; 
q :  out std-logic 
) ;  
10 end d-f f -en ; 
a r c h i t e c t u r e  arch of d-ff-en i s  
begin 
process (clk, reset) 
15 
begin 
i f  ( r e s e t = ’ l ’ )  then 
e l s i f  (clk’event and clk=’l’) then 
q < = ’ O ’ ;  
i f  ( e n = ’ l ’ )  then 
end i f  ; 
20 
q <= d ;  
end i f  ; 
end p r o c e s s ;  
end a r c h ;  
The enabling feature of this D FF is useful in maintaining synchronism between a fast 
subsystem and a slow subsystem. For example, assume that the operation rates of a fast and 
a slow subsystem are 50 MHz and 1 MHz. Instead of using a derived 1-MHz clock to drive 
the slow subsystem, we can generate a periodic enable tick that is asserted one clock cycle 
every 50 clock cycles. The slow subsystem is disabled (i.e., keep the previous state) for the 
remaining 49 clock cycles. The same scheme can also be applied to eliminate a gated clock 
signal. 
Since the enable signal is synchronous, this circuit can be constructed by a regular D FF 
and simple next-state logic. The code is shown in Listing 4.4, and its block diagram is 
shown in Figure 4.3. 
Listing 4.4 Two-segment coding style for a D FF with synchronous enable 
a r c h i t e c t u r e  two-seg-arch of d-ff-en i s  
s i g n a l  r-reg , r-next : std-logic; 

HDL CODE OF THE FF AND REGISTER 
77 
clk 
en 
clk 
reset 
Figure 4.3 D FF with synchronous enable. 
begin 
-- D FF 
5 
process (clk, reset) 
begin 
i f  (reset=’l’) then 
e l s i f  (clk’event and c l k = ’ l ’ )  then 
end i f  ; 
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  
r-next <= d when en = ’ l ’  e l s e  
I <  
r-reg ; 
__ o u t p u t  l o g i c  
q <= r-reg; 
end two-seg-arch ; 
r-reg < = ’ O ’ ;  
10 
r-reg <= r-next; 
For clarity, we use suffixes n e x t  and -reg to emphasize the next input value and the 
registered output of an FF. They are connected to the d and q signals of a D FF. The earlier 
one-process code can be considered as shorthand for this more explicit description. 
4.2.2 Register 
A register is a collection of D FFs that are controlled by the same clock and reset signals. 
Like a D FF, a register can have an optional asynchronous reset signal and a synchronous 
enable signal. The code is identical to that of a D FF except that the array data type, 
s t d - l o g i c v e c t o r ,  is needed for the relevant input and output signals. For example, an 
8-bit register with asynchronous reset is shown in Listing 4.5. 
Listing 4.5 Register 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  reg-reset i s  
port ( 
c l k ,  r e s e t :  in std-logic; 
d :  in std-logic-vector (7 downto 0 ) ;  
q :  out std-logic-vector ( 7  downto 0) 
) ;  
end reg-reset ; 
10 

78 
REGULAR SEQUENTIAL CIRCUIT 
a r c h i t e c t u r e  arch of reg-reset i s  
begin 
Ii 
process (clk , reset) 
begin 
i f  (reset=’l’) then 
e l s i f  (clk’event and clk=’l’) then 
end i f  ; 
q < = ( o t h e r s = > ’ O ’ ) ;  
q <= d ;  
?O 
end p r o c e s s ;  
end arch; 
Note that the expression (others=>’O’) means that all elements are assigned to ’0’ and is 
equivalent to ttOOOOOOOOrt in this case. 
4.2.3 Register file 
A register file is a collection of registers with one input port and one or more output ports. 
The write address signal, w-addr, specifies where to store data, and the read address signal, 
r-addr, specifies where to retrieve data. The register file is generally used as fast, temporary 
storage. The code for a parameterized 2W-by-B register file is shown in Listing 4.6. Two 
generics are defined in this design. The W generic specifies the number of address bits, 
which implies that there are 2W words in the file, and the B generic specifies the number of 
bits in a word. 
Listing 4.6 Parameterized register file 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  reg-file i s  
5 
g e n e r i c (  
B :  integer:=8; -- number of b i t s  
W :  integer:=2 -- number of a d d r e s s  b i t s  
) ;  
port ( 
10 
c l k ,  reset: in std-logic; 
wr-en: in std-logic; 
w-addr , r-addr : in std-logic-vector (W-1 downto 0) ; 
w-data: in std-logic-vector ( B - 1  downto 0) ; 
r-data: out std-logic-vector ( B - 1  downto 0) 
1’ 
) ; 
end reg-f i l e ;  
a r c h i t e c t u r e  arch of reg-file i s  
type reg-file-type i s  array (2**W-1 downto 0) of 
10 
std-logic-vector ( B - 1  downto 0) ; 
s i g n a l  array-reg : reg-f ile-type; 
process (clk , reset) 
begin 
25 
i f  ( r e s e t = ’ l ’ )  then 
begin 
array-reg <= ( o t h e r s = > ( o t h e r s = > ’ O ’ ) )  
; 

SIMPLE DESIGN EXAMPLES 
79 
e l s i f  (clk’event and clk=’l’) then 
i f  w r - e n = ’ l ’  then 
array-reg(to-integer(unsigned(w-addr))) 
<= w-data; 
?O 
end i f  ; 
end i f ; 
end p r o c e s s ;  
__ r e a d  p o r t  
r-data <= array-reg(to-integer(unsigned(r-addr))); 
2 5  end a r c h ;  
The code includes several new features. First, since no built-in two-dimensional ar- 
ray is defined in the std-logic-I164 package a user-defined array-of-array data type, 
reg-f ile-type, is introduced. It is first defined by a type statement and is then used by the 
array-reg signal. Second, a signal is used as an index to access an element in the array, as 
in array-reg( . . w-addr . . 1. Although the description is very abstract, Xilinx software 
recognizes this language construct and can derive the correct implementation accordingly. 
The array-reg(. . .) <= . . . and . . . <= array-reg(. . .) statements infer decoding and 
multiplexing logic, respectively. 
Some applications may need to retrieve multiple data words at the same time. This can 
be done by adding an additional read port: 
r-data2 <= array-reg(to-integer(unsigned(r-addr-2))); 
4.2.4 Storage components in a Spartan-3 devicexiiinx 
specific 
In a Spartan-3 device, each logic cell contains a D FF with asynchronous reset and syn- 
chronous enable. These D FFs basically constitute the register of Figure 4.2. Since a logic 
cell also contains a four-input LUT, it will be wasteful if the cell is just used simply as 
1 bit of a massive storage. The Spartan-3 device also has distributed RAM (random access 
memory) and block RAM modules, and they can be used for larger storage requirements. 
These modules can be configured for synchronous operation, and their characteristics are 
somewhat like a restricted version of the register file. The configuration and inference of 
these modules are discussed in Chapter 11. 
4.3 SIMPLE DESIGN EXAMPLES 
We illustrate the construction of several simple, representative sequential circuits in this 
section. 
4.3.1 Shift register 
Free-running shift register A free-running shift register shifts its content to the left 
or right by one position in each clock cycle. There is no other control signal. The code for 
an N-bit free-running shift-right register is shown in Listing 4.7. 
Listing 4.7 Free-running shift register 
libr ar y i e e e ;  
use ieee. std-logic-1164. a l l  ; 
e n t i t y  free-run-shift-reg i s  

80 
REGULAR SEQUENTIAL CIRCUIT 
generic (N: integer : =  8) ; 
5 
p o r t (  
clk, reset: in std-logic; 
s-in: in std-logic; 
s-out : out std-logic 
) ;  
to end f ree-run-shif t-reg ; 
a r c h i t e c t u r e  arch of free-run-shift-reg i s  
s i g n a l  r-reg : std-logic-vector (N-1 downto 0 )  ; 
s i g n a l  r-next : std-logic-vector (N-1 downto 0) ; 
__ r e g i s t e r  
process (clk , reset 
begin 
15 begin 
if (reset=’l’) then 
20 
r-reg <= ( o t h e r s = > ’ O ’ ) ;  
e l s i f  (clk’event and c l k = ’ l ’ )  then 
end i f ;  
end p r o c e s s ;  
r-next <= s-in & r-reg(N-1 downto 1); 
__ o u t p u t  
s-out <= r-reg(0); 
r-reg <= r-next; 
25 
-- n e x t - s t a t e  
l o g i c  ( s h i f t  r i g h t  I 
b i t )  
end arch; 
The next-state logic is a 1-bit shifter, which shifts r-reg right one position and inserts 
the serial input, s-in, to the MSB. Since the 1-bit shifter involves only reconnection of 
the input and output signals, no real logic is needed. Its propagation delay represents the 
smallest possible Tcomb, and the corresponding fmaz represents the highest clock rate that 
can be achieved for a given device technology. 
Universal shift register A universal shift register can load parallel data, shift its content 
left or right, or remain in the same state. It can perform parallel-to-serial operation (first 
loading parallel input and then shifting) or serial-to-parallel operation (first shifting and 
then retrieving parallel output). The desired operation is specified by a 2-bit control signal, 
ctrl. The code is shown in Listing 4.8. 
Listing 4.8 Universal shift register 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  univ-shift-reg i s  
generic ( N :  
integer : =  8) ; 
s 
p o r t (  
c l k ,  reset: in std-logic; 
ctrl: in std-logic-vector (1 downto 0 )  ; 
d :  in std-logic-vector ( N - 1  downto 0 )  ; 
q :  out std-logic-vector ( N - 1  downto 0) 
in 
) ; 
end univ-shift-reg; 
a r c h i t e c t u r e  arch of univ-shift-reg i s  

SIMPLE DESIGN EXAMPLES 
81 
s i g n a l  r-reg : std-logic-vector (N-1 downto 0) ; 
15 
s i g n a l  r-next : std-logic-vector ( N - 1  downto 0) ; 
begin 
__ r e g i s t e r  
process (clk, reset) 
begin 
20 
i f  (reset='l') then 
r-reg <= ( o t h e r s = > ' O ' ) ;  
r-reg <= r-next; 
e I s i f  (clk ' event and clk= ' 1 ' ) then 
end i f  ; 
:C 
end p r o c e s s ;  
_- 
n e x t - s t a t e  
l o g i c  
with ctrl s e l e c t  
r-next <= 
when " 0 0 "  -- 
r-reg 
, 
no OP 
30 
r-reg"-2 
downto 0 )  & d(0) 
when " 0 1 "  , - - s h i f t  
l e f t :  
d(N-1) & r-reg(N-1 downto 1) when " l o " ,  - - s h i f t  
r i g h t ;  
d 
when o t h e r s ;  -- l o a d  
__ o u t p u t  
q <= r - r e g ;  
35 end arch; 
The next-state logic uses a 4-to-1 multiplexer to select the desired next value of the 
register. Note that the LSB and MSB of d (i.e., d(0) and d(N-I)) are used as serial input 
for the shift-left and shift-right operations. 
In a Xilinx Spartan-3 device, a logic cell's 4-input LUT is implemented by a 16-by-1 
SRAM. The same SRAM can also be configured as a cascading chain of sixteen 1-bit SRAM Xilinx 
cells, which resembles a 16-bit shift register. This can be used to construct certain forms specific 
of shift register and leads to very efficient implementation. 
4.3.2 Binary counter and variant 
Free-running binary counter A free-running binary counter circulates through a bi- 
nary sequence repeatedly. For example, a 4-bit binary counter counts from "OOOO", "0001 'I, 
. . , , to 'I 1 1 1 1 'I and wraps around. The code for a parameterized N-bit free-running binary 
counter is shown in Listing 4.9. 
Listing 4.9 Free-running binary counter 
l i b r a r y  ieee; 
use i e e e . s t d - l o g i c - l l 6 4 . a l l ;  
use ieee. numeric-std. a l l  ; 
e n t i t y  free-run-bin-counter i s  
j 
g e n e r i c ( N :  integer : =  8 ) ;  
port ( 
clk, reset: in std-logic; 
max-tick: out std-logic; 
q :  out std-logic-vector (N-1 downto 0) 
in 
) ; 
end free-run-bin-counter ; 
a r c h i t e c t u r e  arch of free-run-bin-counter i s  

82 
REGULAR SEQUENTIAL CIRCUIT 
Table 4.1 Function table of a universal binary counter 
syn-clr 
load 
en 
up 
q* 
Operation 
1 
- 
- 
- 
00 ‘ . .OO 
synchronous clear 
0 
1 
-
-
 d 
parallel load 
0 
0 
1 
1 
q+1 
count up 
0 
0 
1 
0 
q-I 
count down 
0 
0 
0
-
 
9 
pause 
s i g n a l  r-reg: unsigned(N-1 downto 0 )  ; 
is 
s i g n a l  r-next : unsigned ( N - 1  
downto 0) ; 
begin 
__ r e g i s t e r  
process (clk, reset) 
begin 
20 
i f  (reset=’l’) then 
r-reg <= ( o t h e r s = > ’ O ’ ) ;  
r-reg <= r-next; 
e l s i f  (clk’event and clk=’l’) then 
end i f ;  
2s 
end p r o c e s s ;  
_- 
n e x t - s t a t e  
l o g i c  
r-next <= r-reg + 1; 
_- 
o u t p u t  l o g i c  
q <= std-logic-vector(r-reg); 
30 
max-tick <= ’ 1 ’  when r-reg=(2**N-l) e l s e  
J O J ;  
end arch; 
~ 
~~~ 
The next-state logic is an incrementor, which adds 1 to the register’s current value. By 
definition of the + operator in the IEEE numeric-std package, the operation implicitly 
wraps around after the r-reg reaches ’’ 1. . .1”. The circuit also consists of an output status 
signal, max-t ick, which is asserted when the counter reaches the maximal value, ” 1. . . 1 
(which is equal to 2N - 1). 
The max-t ick signal represents a special type of signal that is asserted for a single clock 
cycle. In this book, we call this type of signal a tick and use the suffix -tick to indicate a 
signal with this property. It is commonly used to interface with the enable signal of other 
sequential circuits. 
Universal binary counter A universal binary counter is more versatile. It can count up 
or down, pause, be loaded with a specific value, or be synchronously cleared. Its functions 
are summarized in Table 4.1. Note the difference between the r e s e t  and syn-clr signals. 
The former is asynchronous and should only be used for system initialization. The latter is 
sampled at the rising edge of the clock and can be used in normal synchronous design. The 
code for this counter is shown in Listing 4.10. 
Listing 4.10 Universal binary counter 
l i b r a r y  ieee; 
use i e e e . s t d - l o g i c - l l 6 4 . a l l ;  
use ieee . numeric-std. a l l  ; 
e n t i t y  univ-bin-counter i s  

SIMPLE DESIGN EXAMPLES 
83 
i 
g e n e r i c ( N :  integer : =  8 ) ;  
p o r t  ( 
clk, reset: i n  std-logic; 
syn-clr , load, en, up: i n  std-logic; 
d :  i n  std-logic-vector ( N - 1  
downto 0) ; 
q :  o u t  std-logic-vector ( N - 1  downto 0 )  
I (1 
max-tick, min-tick: o u t  std-logic; 
) ;  
end univ-bin-counter; 
15 a r c h i t e c t u r e  arch of univ-bin-counter i s  
s i g n a l  r-reg : unsigned ( N - 1  
downto 0) ; 
s i g n a l  r-next : unsigned ( N - 1  downto 0) ; 
__ r e g i s t e r  
begin 
begin 
20 
p r o c e s s  (clk, reset) 
i f  (reset=’l’) then 
e l s i f  (clk’event and clk=’l’) then 
end if ; 
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  
r-next <= ( o t h e r s = > ’ O ’ )  when syn-clr=’l’ e l s e  
r-reg <= ( o t h e r s = > ’ O ’ ) ;  
15 
r-reg <= r-next; 
30 
unsigned (d) 
when load= 1 ’ e l s e  
r-reg f 1 
when en = J l ’  
and up=’l’ e l s e  
r-reg - 1 
when en = ’ i ’  and up=’O’ e l s e  
r-reg ; 
__ o u t p u t  l o g i c  
max-tick <= ’ 1 ’  when r-reg=(2**N-l) 
e l s e  ’ O J ;  
min-tick <= ’ 1 ’  when r-reg=O e l s e  ’ 0 ’ ;  
35 
q <= std-logic-vector (r-reg) ; 
end arch; 
The next-state logic follows the function table and uses a conditional signal assignment to 
prioritize the desired operations. 
Mod- 
counter A mod-m counter counts from 0 to m - 1 and wraps around. A 
parameterized mod-m counter is shown in Listing 4.11. It has two generics. One is M, 
which specifies the limit, m, and the other is N, which specifies the number of bits needed 
and should be equal to /log, M I .  The code is shown in Listing 4.11, and the default value 
is for a mod- 10 counter. 
Listing 4.11 Mod-m counter 
l i b r a r y  ieee; 
use i e e e . s t d - l o g i c - l l 6 4 , a l l ;  
use ieee . numeric-std. a l l  ; 
e n t i t y  mod-m-counter i s  
5 
g e n e r i c (  
N :  integer : =  4; 
-- number of b i t s  
M :  integer : =  10 
-- m o d 4  
) ;  

84 
REGULAR SEQUENTIAL CIRCUIT 
port ( 
10 
clk, reset: in std-logic; 
max-tick: out std-logic; 
q :  out std-logic-vector ( N - 1  downto 0) 
) ;  
end mod-m-counter ; 
a r c h i t e c t u r e  arch of mod-m-counter i s  
15 
s i g n a l  r-reg : unsigned ( N - 1  downto 0) ; 
s i g n a l  r-next : unsigned ( N - 1  downto 0) ; 
begin 
20 
-- r e g i s t e r  
25 
process (clk, reset) 
begin 
if 
( r e s e t = ’ l ’ )  then 
e l s i f  (clk’event and clk=’l’) then 
end if ; 
r-reg <= ( o t h e r s = > ’ O ’ ) ;  
r-reg <= r-next; 
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  
30 
r-next <= ( o t h e r s = > ’ O ’ )  when r-reg=(M-l) e l s e  
r-reg + 1 ;  
__ o u t p u t  l o g i c  
q <= std-logic-vector(r-reg); 
max-tick <= ’ 1 ’  when r-reg=(M-l) e l s e  ’ 0 ’ ;  
is end a r c h ;  
The next-state logic is constructed by a conditional signal assignment statement. If the 
counter reaches M-1, the new value is cleared to 0. Otherwise, it is incremented by 1. 
Inclusion of the N parameter in the code is somewhat redundant since its value depends 
on M. A more elegant way is to define a function that calculates N from M automatically. In 
VHDL, this can be done by creating a user-definedfuncrion in a package and invoking the 
package before the entity declaration. This is beyond the scope of this book and the details 
may be found in the references cited in the Bibliographic section. 
4.4 
TESTBENCH FOR SEQUENTIAL CIRCUITS 
A testbench is a program that mimics a physical lab bench, as discussed in Section 1.4. 
Developing a comprehensive testbench is beyond the scope of this book. We discuss a 
simple testbench for the previous universal binary counter in this section. It can serve as a 
template for other sequential circuits. The code for the testbench is shown in Listing 4.12. 
Listing 4.12 Testbench for a universal binarv counter 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  bin-counter-tb i s  
5 end bin-counter-tb; 
a r c h i t e c t u r e  arch of bin-counter-tb i s  

TESTBENCH FOR SEQUENTIAL CIRCUITS 
85 
c ons tan t THREE: 
integer : =  3 ;  
c onstan t T :  time : =  20 n s ;  -- c l k  p e r i o d  
10 
s i g n a l  clk, reset: std-logic; 
s i g n a l  syn-clr , load, en, u p :  std-logic; 
s i g n a l  d :  std-logic-vector (THREE-1 downto 0 )  ; 
s i g n a l  max-tick , min-tick: std-logic ; 
s i g n a l  q :  std-logic-vector (THREE-1 downto 0) ; 
I S  begin 
50 
S 5  
60 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ i n s t a n t i a t i o n  
counter-unit : e n t i t y  work. univ-bin-counter (arch) 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
gen eri c map ( N =  > THREE ) 
port map(clk=>clk, reset=>reset , syn-clr=>syn-clr , 
load=>load, e n = > e n ,  up=>up, d = > d ,  
max-tick=>max-tick, min-tick=>min-tick, q = > q ) ;  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ c l o c k  
-- 2 0  ns c l o c k  r u n n i n g  f o r e v e r  
process 
begin 
_- . . . . . . . . . . . . . . . . . . . . . . . . . .  
clk <= ’ 0 ’ ;  
wait for T / 2 ;  
clk <= ’ 1 ’ ;  
wait for T / 2 ;  
end p r o c e s s ;  
r e s e t  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ r e s e t  a s s e r t e d  f o r  T / 2  
reset <= ’ l ’ ,  ’ 0 ’  a f t e r  T / 2 ;  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ o t h e r  s t i m u l u s  
p r o c e s s 
begin 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
-_ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ i n  i t i a  1 
i n p u t  
syn-clr <= ’ 0 ’ ;  
load <= ’ 0 ’ ;  
up <= > I > ;  -- c o u n t  up 
d <= ( o t h e r s = > ’ O ’ ) ;  
wait u n t i l  falling-edge (clk) ; 
wait u n t i l  falling-edge (clk) ; 
__ t e s t  l o a d  
load <= ’1’: 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
en <= ’ 0 ’ ;  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  

86 
REGULAR SEQUENTIAL CIRCUIT 
65 
70 
75 
80 
85 
90 
95 
I00 
105 
I to 
d <= "011"; 
wait u n t i l  falling-edge (clk) ; 
load <= '0'; 
-- p a u s e  2 c l o c k s  
wait u n t i l  falling-edge(clk); 
wait u n t i l  falling-edgecclk) ; 
_- 
t e s t  s y n - c l e a r  
syn-clr <= '1'; -- c l e a r  
wait u n t i l  falling-edge (clk); 
syn-clr <= ' 0 ' ;  
_- 
t e s t  up c o u n t e r  and p a u s e  
en <= '1'; -- c o u n t  
up <= '1'; 
for i in 1 to 1 0  loop -- c o u n t  1 0  c l o c k s  
end l o o p ;  
en < = ' O ' ;  
wait u n t i l  f alling-edge (clk) ; 
wait u n t i l  f alling-edge (clk) ; 
en <='I>; 
wait u n t i l  falling-edge(clk); 
wait u n t i l  falling-edge (clk); 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
_- . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
wait u n t i l  falling-edge (clk) ; 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
t e s t  down c o u n t e r  
__ 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
up <= ' 0 ' ;  
for i in 1 to 10 loop -- run 1 0  c l o c k s  
end l o o p ;  
__ o t h e r  w a i t  c o n d i t i o n s  
__ c o n t i n u e  until q=2 
wait u n t i l  q="010"; 
wait u n t i l  falling-edge (clk); 
up <= '1'; 
__ c o n t i n u e  u n t i l  m i n - t i c k  c h a n g e s  v a l u e  
wait on min-tick; 
wait u n t i l  falling-edge (clk) ; 
up <= '0'; 
wait f o r  4*T; -- w a i t  f o r  8 0  12s 
en <= ' 0 ' ;  
wait f o r  4*T; 
__ t e r m i n a t e  s i m u l a t i o n  
a s s e r t  false 
r e p  o r t 
'I S i mu 1 at i on C o mp 1 e t e d " 
wait u n t i l  falling-edge (clk) ; 
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
_- . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ . . . . . . . . . . . . . . . . . . . . . . . . . .  
s e v e r i t y  failure; 

TESTBENCH FOR SEQUENTIAL CIRCUITS 
87 
end process ; 
115 end arch; 
The code consists of a component instantiation statement, which creates an instance of 
a 3-bit counter, and three segments, which generate a stimulus for clock, reset, and regular 
inputs. Since operation of a synchronous system is synchronized by a clock signal, we 
define a constant with the built-in data type time for the clock period: 
constant T :  time : =  2 0  n s ;  -- c l k  p e r i o d  
The clock generation is specified by a process: 
process 
begin 
clk <= ’ 0 ’ ;  
wait for T / 2 ;  
clk <= ’1’; 
wait for T / 2 ;  
end p r o c e s s ;  
The clk signal is assigned between ’0’ and ’ 1 ’ alternatively, and each value lasts for half a 
period. Note that the process has no sensitivity list and repeats itself forever. 
The reset stimulus involves one statement, 
reset <= ’ I > ,  ’ 0 ’  a f t e r  T / 2 ;  
It indicates that the r e s e t  signal is set to ’ 1’ initially and changed to ’0’ after half a period. 
The statement represents the “power-on” condition, in which the reset signal is asserted 
momentarily to clear the system to the initial state. Note that, by default, the ’U’ value (for 
uninitialized), not ’ 0 ’, is assigned to a signal with the std-logic type. Using a short reset 
pulse is a good mechanism to perform system initialization. 
The last process statement generates a stimulus for other input signals. We first test 
the load and clear operations and then exercise counting in both directions. The final 
assert false statement forces the simulator to terminate simulation, as discussed in Sec- 
tion 2.7. 
For a synchronous system with positive edge-triggered FFs, an input signal must be stable 
around the rising edge of the clock signal to satisfy the setup and hold time constraints. One 
easy way to achieve this is to change an input signal’s value during the ’1’-to-’0’ transition 
of the c l k  signal. The f alling-edge function of the std-logic-1164 package checks 
this condition, and we can use it in a wait statement: 
wait u n t i l  falling-edge (clk) ; 
Note that each statement represents a new falling edge, which corresponds to the advance- 
ment of one clock cycle. In our template, we generally use this statement to specify the 
progress of time. For multiple clock cycles, we can use a loop statement: 
for i in 1 to 10 loop -- c o u n t  1 0  c l o c k s  
end l o o p ;  
wait u n t i l  falling-edge (clk) ; 
There are other useful forms of wait statements, as shown at the end of the process. We 
can wait until a special condition, such as “when q is equal to 2”, 
wait u n t i l  q = ” O l O ” ;  
or wait until a signal changes, such as 

88 
REGULAR SEQUENTIAL CIRCUIT 
reset 
I 
t 
Figure 4.4 
Testbench waveform. 
wait on m i n - t i c k ;  
or wait for an absolute time, such as 
wait for 4*T; -- w a i t  f o r  4 c l o c k  p e r i o d s  
If an input signal is modified after these statements, we need to make sure that the input 
change does not occur at the rising edge of the clock. An additional 
wait u n t i l  falling-edge(clk); 
statement should be added when needed. 
shown in Figure 4.4. 
We can compile the code and perform simulation. Part of the simulated waveform is 
4.5 CASE STUDY 
After examining several simple circuits, we discuss the design of more sophisticated exam- 
ples in this section. 
4.5.1 
LED time-multiplexing circuit 
The S3 board has four seven-segment LED displays, each containing seven bars and one 
small round dot. To reduce the use of FPGA's I/O pins, the S3 board uses a time-multiplexing 
sharing scheme. In this scheme, the four displays have their individual enable signals but 
share eight common signals to light the segments. All signals are active-low (i.e., enabled 
when a signal is '0'). The schematic of displaying '3' on the rightmost LED is shown in 
Figure 4.5. Note that the enable signal (i.e., an) is "1 110". This configuration clearly can 
enable only one display at a time. We can time-multiplex the four LED patterns by enabling 
the four displays in turn, as shown in the simplified timing diagram in Figure 4.6. If the 
refreshing rate of the enable signal is fast enough, the human eye cannot distinguish the 
on and off intervals of the LEDs and perceives that all four displays are lit simultaneously. 
This scheme reduces the number of I/O pins from 32 to 12 (i.e., eight LED segments plus 
four enable signals) but requires a time-multiplexing circuit. Two variations of the circuit 
are discussed in the following subsections. 

CASESTUDY 
89 
an0 
an1 
a ,.-,. 
I 
an3 
an2 
an1 
an0 
1 
1 
1 
0 
Figure 4.5 
Time-multiplexed seven-segment LED display. 
Figure 4.6 
Timing diagram of a time-multiplexed seven-segment LED display. 

90 
REGULAR SEQUENTIAL CIRCUIT 
/ 
18 
disp-mux 
q-reg (17.,16) 
q-next 
q-reg 
+I 
d 
9 
, ’ -  2 , ’  
18 
18 
2 
>clk 
(a) Symbol 
sseg 
in2 
in3 
/ 
I 
I 
clk 
reset 
(b) Block diagram 
Figure 4.7 Symbol and block diagram of a time-multiplexing circuit. 
Time multiplexing with LED patterns The symbol and block diagram of the time- 
multiplexing circuit are shown in Figure 4.7. It takes four seven-segment LED patterns, 
in3, in2, ini, and inO, and passes them to the output, sseg, in accordance with the enable 
signal. 
The refresh rate of the enable signal has to be fast enough to fool our eyes but should 
be slow enough so that the LEDs can be turned on and off completely. The rate around the 
range 1000 Hz should work properly. In our design, we use an 18-bit binary counter for 
this purpose. The two MSBs are decoded to generate the enable signal and are used as the 
selection signal for multiplexing. The refreshing rate of an individual bit, such as an (0) , 
becomes W H z ,  which is about 800 Hz. The code is shown in Listing 4.13. 
Listing 4.13 LED time-multiplexing circuit with LED patterns 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  disp-mux i s  
5 
p o r t (  
clk, reset: in std-logic; 
i n 3 ,  i n 2 ,  inl, inO: in std-logic-vsctor(7 downto 0 ) ;  
a n :  out std-logic-vector (3 downto 0) ; 
sseg : out std-logic-vector ( 7  downto 0 )  
10 
1 ; 
end disp-mux ; 

CASESTUDY 
91 
a r c h i t e c t u r e  arch of disp-mux i s  
_- 
r e f r e s h i n g  r a t e  around 800 Hz ( 5 0 M H z / 2 ^ 1 6 )  
s i g n a l  q-reg , q-next : unsigned ( N - 1  downto 0) ; 
s i g n a l  s e l :  std-logic-vector (1 downto 0 )  ; 
__ r e g i s t e r  
begin 
15 
constant N :  integer :=18; 
begin 
20 
process (clk, reset) 
if reset='l' then 
e l s i f  (clk'event and clk='l') then 
end i f  ; 
end p r o c e s s ;  
q-reg <= ( o t h e r s = > ' O ' ) ;  
q-reg <= q-next; 
-_ 
n e x t - s t a t e  
l o g i c  f o r  t h e  c o u n t e r  
30 
q-next <= q-reg + 1 ;  
-- 2 MSBs o f  c o u n t e r  t o  c o n t r o l  4 - t o - I  
m u l t i p l e x i n g  
__ and t o  g e n e r a t e  a c t i v e - l o w  
e n a b l e  s i g n a l  
sel <= std-logic-vector(q-reg(N-1 
downto N-2)) ; 
process (sel , inO, in1 , in2, in3) 
begin 
3~ 
case sel i s  
when " 0 0 "  => 
an <= " 1 1 1 0 " ;  
40 
sseg <= i n O ;  
when " 0 1 "  => 
an <= "1101"; 
sseg <= i n l ;  
when "10" => 
44 
an <= "1011"; 
sseg <= i n 2 ;  
an <= "0111"; 
sseg <= i n 3 ;  
when others = >  
5 0  
end c a s e ;  
end p r o c e s s ;  
end arch; 
We use the testing circuit in Figure 4.8 to verify operation of the LED time-multiplexing 
circuit. It uses four 8-bit registers to store the LED patterns. The registers use the same 
8-bit switch as input but are controlled by individual enable signal. When we press a button, 
the corresponding register is enabled and the switch pattern is loaded to that register. The 
code is shown in Listing 4.14. 
Listing 4.14 Testing circuit for time multiplexing with LED patterns 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  disp-mux-test i s  
5 
p o r t (  

92 
REGULAR SEQUENTIAL CIRCUIT 
sw 
- 
btn(0) 
4-d 
btn(1) 
~ 
4
-
 
btn(2) 
-d 
btn(3) 
d
q
 
en 
> 
q 
en 
in0 
sseg 
sseg 
> 
in1 
an 
an 
in2 
- 
in3 
d
q
 
disp-mux 
en 
> 
reset 
4 
en 
> 
Figure 4.8 LED time-multiplexing testing circuit. 
clk: in std-logic; 
btn: in std-logic-vector (3 downto 0) ; 
sw: in std-logic-vector (7 downto 0) ; 
an: out std-logic-vector (3 downto 0) ; 
10 
sseg : out std-logic-vector (7 downto 0 )  
1 ;  
end disp-mux-test ; 
a r c  hi te c t u r e  arch 
15 
s i g n a l  d 3 _ r e g ,  
s i g n a l  dl-reg , 
disp-unit : e n t  
port map( 
clk=>clk 
begin 
20 
30 
of disp-mux-test i s  
d2-reg: std-logic-vector (7 downto 0 )  ; 
do-reg : std-logic-vector (7 downto 0 )  ; 
ty work. disp-mux 
reset => ’ 0  ’ , 
i n 3 = > d 3 _ r e g ,  i n 2 = > d 2 _ r e g ,  inl=>dl-reg, 
inO=>dO-reg, a n = > a n ,  sseg=>sseg) ; 
__ r e g i s t e r s  f o r  4 l e d  p a t t e r n s  
process (clk) 
25 
begin 
if (clk’event and clk=’l’) then 
i f  (btn(3)=’1’) then 
end i f ;  
i f (btn(2)=’l’) then 
end i f ;  
i f  (btn(l)=’l’) then 
d3-reg <= s w ;  
d2-reg <= s w ;  
dl-reg <= s w ;  

CASESTUDY 
93 
/ 
+I 
18 
, 
/ 4  
hexO 
hexl 
hex2 
/ 
/ 4  
q-next 
q-reg 
q-reg (17,.16) 
d 
q 
1 ’ -  
= / ’  
18 
18 
2 
>clk 
elk 
reset 
2-to-4 
1 
- 
decoder 
/ 
Figure 4.9 Block diagram of a hexadecimal time-multiplexing circuit. 
35 
end i f  ; 
i f  (btn(O)=’l’) then 
end i f  ; 
do-reg <= s w ;  
end i f  ; 
40 
end p r o c e s s ;  
end a r c h ;  
an 
Time multiplexing with hexadecimal digits The most common application of a 
seven-segment LED is to display a hexadecimal digit. The decoding circuit is discussed 
in Section 3.7.1. To display four hexadecimal digits with the previous time-multiplexing 
circuit, four decoding circuits are needed. A better alternative is first to multiplex the 
hexadecimal digits and then decode the result, as shown in Figure 4.9. 
This scheme requires only one decoding circuit and reduces the width of the 4-to-1 
multiplexer from 8 bits to 5 bits (i.e., 4 bits for the hexadecimal digit and 1 bit for the 
decimal point). The code is shown in Listing 4.15. In addition to clock and reset, the input 
consists of four 4-bit hexadecimal digits, hex3, hex2, hexl, and hex0, and four decimal 
points, which are grouped as one signal, dp-in. 
Listing 4.15 LED time-multiplexing circuit with hexadecimal digits 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  disp-hex-mux i s  
5 
p o r t (  
c l k ,  r e s e t :  in std-logic; 
h e x 3 ,  h e x 2 ,  hexl , h e x O :  in std-logic-vector (3 downto 0 )  ; 
dp-in : in std-logic-vector (3 downto 0) ; 
a n :  out std-logic-vector (3 downto 0) ; 
10 
sseg : out std-logic-vector ( 7  downto 0) 
) ;  
end disp-hex-mux ; 

94 
REGULAR SEQUENTIAL CIRCUIT 
a r c h i t e c t u r e  arch of disp-hex-mux i s  
i s  
-- each 7 - seg  
led enabled ( 2 ^ 1 8 / 4 ) * 2 . 5  ns ( 4 0  m s )  
constant N: integer :=18; 
s i g n a l  q-reg , q-next : unsigned (N-1 downto 0) ; 
s i g n a l  sel : std-logic-vector (1 downto 0) ; 
s i g n a l  hex: std-logic-vector (3 downto 0) ; 
20 
s i g n a l  dp: std-logic; 
begin 
-- r e g i s t e r  
process (clk , reset) 
begin 
25 
i f  reset='l' then 
q-reg <= ( o t h e r s = >  ' 0 ' )  ; 
q-reg <= q-next; 
e l s i f  (clk'event and clk='l') then 
end if ; 
30 
end p r o c e s s ;  
-- n e x t - s t a t e  
l o g i c  for t h e  c o u n t e r  
q-next <= q-reg + 1 ;  
45 
50 
60 
65 
35 
-- 2 MSBs of c o u n t e r  t o  c o n t r o l  4 - t o - l  
m u l t i p l e x i n g  
sel <= std-logic-vector (q-reg"-1 
downto N-2)) ; 
process (sel , hex0 , hexl , hex2, hex3, dp-in) 
begin 
case sel i s  
40 
when "00" => 
an <= " 1 1 1 0 " ;  
hex <= hex0; 
dp <= dp-in(0); 
an <= " 1 1 0 1 " ;  
hex <= hexl; 
dp <= dp-in(l); 
an <= ' ~ 1 0 1 1 " ;  
hex <= hex2; 
dp <= dp-in(2); 
an <= " 0 1 1 1 " ;  
hex <= hex3; 
when " 0 1 "  => 
when " 1 0 "  => 
when others => 
5s 
dp <= dp-in(3); 
end c a s e ;  
end p r o c e s s ;  
-_ 
hex - to - 7- s e g in e IZ t 
I e d decoding 
with hex s e l e c t  
sseg(6 downto 0) <= 
t ' O O O O O O 1  I' when " 0 0 0 0 "  , 
I' 1 0 0 1 1 1 1 (' when " 0 0 0 1 
I' , 
" 0 0 1 0 0 1 0 "  when " 0 0 1 0 " ,  
~ ~ 0 0 0 0 ~ 1 0 "  
when " 0 0 1 1 " ,  
t ~ l O O ~ ~ O O "  
when " O I O O " ,  

CASESTUDY 
95 
7u 
75 
'I 0 100 100 It when 
I' 0 10 1 'I , 
'' 0 100000 I' when 
'I 0 1 10 'I , 
'I 0 0 0 1 1 1 1 'I when 
It 0 1 1 1 I' , 
r l O O O O O O O 1 t  when t l l O O O 1 t ,  
" 0 0 0 0 1 0 0 "  when " 1 0 0 1 " ,  
" 0 0 0 1 0 0 0 "  when " 1 0 1 0 " ,  --a 
" 1 1 0 0 0 0 0 "  when " 1 0 1 1 " ,  -4 
t t O 1 l O O O 1 l t  when " 1 1 0 0 " ,  --c 
" 1 0 0 0 0 1 0 "  when " 1 1 0 1 " ,  --d 
" 0 1 1 0 0 0 0 "  when "1110", --e 
" 0 1 1 1 0 0 0 "  when o t h e r s ;  --f 
-_ 
d e c i m a l  p o i n t  
sseg(7) <= dp; 
end arch; 
To verify operation of this circuit, we define the 8-bit switch as two 4-bit unsigned 
numbers, add the two numbers, and show the two numbers and their sum on the four-digit 
seven-segment LED display. The code is shown in Listing 4.16. 
Listing 4.16 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  hex-mux-test i s  
Testing circuit for time multiplexing with hexadecimal digits 
5 
p o r t (  
clk: in std-logic; 
sw: in std-logic-vector ( 7  downto 0) ; 
an: out std-logic-vector (3 downto 0 )  ; 
sseg : out std-logic-vector (7 downto 0 )  
10 
) ; 
end hex-mux-test; 
a r c h i t e c t u r e  arch of hex-mux-test i s  
s i g n a l  a ,  b :  unsigned(7 downto 0 ) ;  
15 
s i g n a l  sum: std-logic-vector (7 downto 0) ; 
begin 
disp-unit : e n t i t y  work. disp-hex-mux 
port map( 
clk=>clk, reset=>'O', 
20 
hex3=>sum(7 downto 4), hex2=>sum(3 downto 0) , 
hexl=>sw(7 downto 4), hexO=>sw(3 downto 0 1 ,  
dp-in=>"lOll" , an=>an, sseg=>sseg) ; 
a <= " 0 0 0 0 "  & unsigned(sw(3 downto 0 ) ) ;  
b <= "0000" & unsigned(sw(7 
downto 4)); 
25 
sum <= std-logic-vector(a + b); 
end arch; 
Simulation consideration Many sequential circuit examples in the book operate at a 
relatively slow rate, as does the enable pulse of the LED time-multiplexing circuit. This 
can be done by generating a single-clock enable tick from a counter. An 18-bit counter is 
used in this circuit: 
c o n s t a n t  N :  integer : =18; 

96 
REGULAR SEQUENTIAL CIRCUIT 
s i g n a l  q-reg , q-next : unsigned ( N - 1  downto 0) ; 
q-next (= g-reg + 1 ;  
. . .  
Because of the counter's size, simulating this type of circuit consumes a significant amount 
of computation time (i.e., 218 clock cycles for one iteration). Since our main interest is in 
the multiplexing part of the code, most simulation time is wasted. It is more efficient to use 
a smaller counter in simulation. We can do this by modifying the constant statement 
constant N :  integer : = 4 ;  
when constructing the testbench. This requires only 2* clock cycles for one iteration and 
allows us to better exercise and observe the key operations. 
Instead of using a constant statement and modifying code between simulation and syn- 
thesis, an alternative is to define a generic for the relevant parameter. During instantiation, 
we can assign different values for simulation and synthesis. 
4.5.2 Stopwatch 
We consider the design of a stopwatch in this subsection. The watch displays the time in 
three decimal digits, and counts from 00.0 to 99.9 seconds and wraps around. It contains 
a synchronous clear signal, clr, which returns the count to 00.0, and an enable signal, 
go, which enables and suspends the counting. This design is basically a BCD (binary- 
coded decimal) counter, which counts in BCD format. In this format, a decimal number is 
represented by a sequence of 4-bit BCD digits. For example, 13910 is represented as "0001 
001 1 1001" and the next number in sequence is 14O1o, 
which is represented as "0001 0100 
0000". 
Since the S3 board has a 50-MHz clock, we first need a mod-5,000,000 counter that 
generates a one-clock-cycle tick every 0.1 second. The tick is then used to enable counting 
of the three-digit BCD counter. 
Design I Our first design of the BCD counter uses a cascading structure of three decade 
(i.e., mod-10) counters, representing counts of 0.1, 1, and 10 seconds, respectively. The 
decade counter has an enable signal and generates a one-clock-cycle tick when it reaches 9. 
We can use these signals to "hook" the three counters. For example, the 10-second counter 
is enabled only when the enable tick of the mod-5,000,000 counter is asserted and both the 
0.1- and I-second counters are 9. The code is shown in Listing 4.17. 
Cascading description for a stopwatch 
Listing 4.17 
l i b r a r y  i e e e ;  
use ieee . std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  stop-watch i s  
z 
p o r t (  
c l k :  in std-logic; 
g o ,  c l r :  in s t d - l o g i c ;  
d2, d l ,  d o :  out std-logic-vector (3 downto 0) 
) ;  
10 end stop-watch; 
a r c h i t e c t u r e  cascade-arch of stop-watch i s  
constant DVSR: integer : =5000000; 

CASESTUDY 
97 
s i g n a l  ms-reg , ms-next : unsigned (22 downto 0 )  ; 
s i g n a l  d2-next , dl-next , do-next : unsigned (3 downto 0) ; 
s i g n a l  dl-en , d2_en, dO-en: std-logic; 
s i g n a l  ms-tick , do-tick, dl-tick: std-logic ; 
15 
s i g n a l  d2_reg, dl-reg , do-reg : unsigned (3 downto 0) ; 
begin 
20 
40 
60 
__ r e g i s t e r  
p r o c e s s  (clk) 
begin 
i f  (clk ’ event and clk= ’ 1 ’ ) t h e n  
ms-reg <= ms-next; 
d2-reg <= d2-next; 
dl-reg <= dl-next; 
do-reg <= do-next; 
end i f ;  
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  
__ 0 . 1  s e e  t i c k  g e n e r a t o r  : mod-5000000 
ms-next <= 
( o t h e r s = > ’ O ’ )  when clr=’l’ or 
ms-reg + 1 when go=’l’ e l s e  
ms-reg ; 
(ms-reg=DVSR and go=’l’) e l s e  
ms-tick <= ’ 1 ’  when ms-reg=DVSR e l s e  ’ 0 ’ ;  
__ 0 . 1  s e e  c o u n t e r  
d0-en <= ’1’ when ms-tick=’l’ e l s e  ’ 0 ’ ;  
do-next <= 
“ 0 0 0 0 ”  when (clr=’l ’ )  o r  (dO-en=’l’ and dO_reg=9) e l s e  
do-reg + 1 when dO-en=’l’ e l s e  
do-reg ; 
do-tick <= ’1’ when dO_reg=9 e l s e  ’ 0 ’ ;  
__ I s e e  c o u n t e r  
dl-en <= ’ 1 ’  when ms-tick=’l’ and dO-tick=’l’ e l s e  
dl-next <= 
“ 0 0 0 0 ”  when (clr=’l’) o r  (dl-en=’l’ and dl_reg=9 
dl-reg + 1 when dl-en=’l’ e l s e  
dl-reg ; 
dl-tick <= ’1’ when dl_reg=9 e l s e  ’ 0 ’ ;  
_- I 0  s e e  c o u n t e r  
d2-en <= 
0 ’ ;  
e l s e  
’ 1 ’  when ms-tick=’l’ and dO-tick=’l’ and dl-tick=’l’ e l s e  
’ 0 ’ ;  
“ 0 0 0 0 ”  when (clr=’l’) o r  (d2_en=’l’ and d2_reg=9) e l s e  
d2-reg + 1 when d2_en=’l’ e l s e  
d2-reg ; 
d2-next <= 
__ o u t p u t  l o g i c  
dO <= std-logic-vector (dO-reg) ; 
dl <= std-logic-vector(dl-reg); 
d2 <= std-logic-vector(d2-reg); 
end cascade-arch; 

98 
REGULAR SEQUENTIAL CIRCUIT 
Note that all registers are controlled by the same clock signal. This example illustrates 
how to use a one-clock-cycle enable tick to maintain synchronicity. An inferior approach 
is to use the output of the lower counter as the clock signal for the next stage. Although it 
may appear to be simpler, it violates the synchronous design principle and is a very poor 
practice. 
Design /I An alternative for the three-digit BCD counter is to describe the entire structure 
in a nested if statement. The nested conditions indicate that the counter reaches .9,9.9, and 
99.9 seconds. The code is shown in Listing 4.18. 
Listing 4.18 Nested if-statement description for a stopwatch 
a r c h i t e c t u r e  if-arch of stop-watch i s  
constant DVSR: integer : = 5 0 0 0 0 0 0 ;  
s i g n a l  ms-reg , ms-next : unsigned (22 downto 0) ; 
s i g n a l  d2_reg, dl-reg , dO-reg: unsigned (3 downto 0 )  ; 
s i g n a l  ms-tick: std-logic; 
-_ 
r e g i s t e r  
process (clk) 
5 
s i g n a l  dz-next, dl-next , do-next : unsigned(3 downto 0) ; 
begin 
10 
begin 
i f  (clk event and clk= ’ 1 ’ 
then 
ms-reg <= ms-next; 
d2-reg <= d2-next; 
dl-reg <= dl-next; 
do-reg <= do-next; 
end i f  ; 
end p r o c e s s ;  
I5 
25 
30 
40 
_- 
n e x t  - s t a  t e  l o g i c  
ms-next <= 
20 
-- 0 . 1  s e c  t i c k  g e n e r a t o r :  mod-5000000 
( o t h e r s = >  ’0 ’ )  when clr=’l’ or 
ms-reg + 1 when go=’l’ e l s e  
ms-reg ; 
(ms-reg=DVSR and go= ’ 1 ’) e l s e  
ms-tick <= ’ 1 ’  when ms-reg=DVSR e l s e  ’ 0 ’ ;  
-- 3 -  d i g i t  i n c r e m e n t o r  
process (do-reg , dl-reg ,d2_reg ,ms-tick, clr) 
begin 
-- d e f a u l t  
do-next <= do-reg; 
dl-next <= dl-reg; 
d2-next <= d2-reg; 
i f  clr= ’ 1 ’ then 
do-next <= ”0000”; 
dl-next <= ”0000”; 
d2-next <= ”0000”; 
e l s i f  ms-tick=’l ’ then 
if (dO_reg/=9) then 
do-next <= do-reg + 1 ;  
e l s e  
-- r e a c h  X X 9  
do-next <= “0000“; 

CASESTUDY 
99 
if (dl_reg/=9) then 
dl-next <= dl-reg + 1; 
dl-next <= "0000"; 
if (d2_reg/=9) then 
e l s e  -- reach 9 9 9  
end if ; 
15 
e l s e  
-- r e a c h  X99 
d2-next <= d2-reg + 1 ;  
50 
d2-next <= "0000"; 
end if ; 
end i f ;  
end i f  ; 
5s 
end p r o c e s s ;  
__ o u t p u t  l o g i c  
dO <= std-logic-vector(d0-reg); 
dl <= std-logic-vector(dl-reg); 
d2 <= std-logic-vector (d2-reg) ; 
M) end if -arch; 
Verification circuit To verify operation of the stopwatch, we can combine it with the 
previous hexadecimal LED time-multiplexing circuit to display the output of the watch. 
The code is shown in Listing 4.19. Note that the first digit of the LED is assigned to 0 and 
the go and c l r  signals are mapped to two buttons of the S3 board. 
Listing 4.19 Testing circuit for a stopwatch 
library ieee; 
use ieee . std-logic-1164. a l l  ; 
e n t i t y  stop-watch-test i s  
port ( 
5 
clk: in std-logic; 
btn: in std-logic-vector (3 downto 0) ; 
an: out std-logic-vector (3 downto 0) ; 
sseg : out std-logic-vector ( 7  downto 0) 
) ;  
10 end stop-watch-test; 
a r c h i t e c t u r e  arch of stop-watch-test is 
begin 
s i g n a l  d2, dl , dO : std-logic-vector (3 downto 0) ; 
1 5  
disp-unit : e n t i t y  work. disp-hex-mux 
port map( 
clk=>clk, reset=>'O', 
hex3=>"0000" , hex2=>d2, 
hexl=>dl , hexO=>dO, 
dp-in=>" 1 1 0 1 " ,  an=>an, sseg=>sseg) ; 
20 
watch-unit : e n t i t y  work. stop-watch(cascade-arch) 
port map( 
clk=>clk, go=>btn(l) , clr=>btn(O), 
2 s  
d2 =>d2, dl=>dl, dO=>dO ) ;  
end arch; 

100 
REGULAR SEQUENTIAL CIRCUIT 
FIFO buffer 
from FIFO 
data written 
into FIFO 
data read 
Figure 4.10 Conceptual diagram of a FIFO buffer. 
4.5.3 FIFO buffer 
A FIFO (first-in-first-out) buffer is an “elastic” storage between two subsystems, as shown 
in the conceptual diagram of Figure 4.10. It has two control signals, w r  and rd, for write 
and read operations. When w r  is asserted, the input data is written into the buffer. The 
read operation is somewhat misleading. The head of the FIFO buffer is normally always 
available and thus can be read at any time. The rd signal actually acts like a “remove” 
signal. When it is asserted, the first item (i.e., head) of the FIFO buffer is removed and the 
next item becomes available. 
FIFO buffer is a critical component in many applications and the optimized implemen- 
tation can be quite complex. In this subsection, we introduce a simple, genuine circular- 
queue-based design. More efficient, device-specific implementation can be found in the 
Xilinx literature. 
Circular-queue-based implementation One way to implement a FIFO buffer is to 
add a control circuit to a register file. The registers in the register file are arranged as a 
circular queue with two pointers. The write pointer points to the head of the queue, and the 
readpointer points to the tail of the queue. The pointer advances one position for each write 
or read operation. The operation of an eight-word circular queue is shown in Figure 4.11. 
A FIFO buffer usually contains two status signals, full and empty, to indicate that the 
FIFO is full (i.e., cannot be written) and empty (i.e., cannot be read), respectively. One of 
the two conditions occurs when the read pointer is equal to the write pointer, as shown in 
Figure 4.11(a), (f), and (i). The most difficult design task of the controller is to derive a 
mechanism to distinguish the two conditions. One scheme is to use two FFs to keep track 
of the empty and full statuses. The FFs are set to ’ 1 ’ and ’0’ during system initialization 
and then modified in each clock cycle according to the values of the wr and rd signals. The 
code is shown in Listing 4.20. 
Listing 4.20 FIFO buffer 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  fifo i s  
s 
g e n e r i c (  
B :  n a t u r a l : = 8 ;  -- number of b i t s  
W :  natural:=4 -- number of a d d r e s s  b i t s  
) ;  
port ( 
10 
clk, r e s e t :  in std-logic; 
r d ,  w r :  in std-logic; 

CASE STUDY 
101 
Figure 4.11 FIFO buffer based on a circular queue. 

102 
REGULAR SEQUENTIAL CIRCUIT 
w-data: in std-logic-vector ( B - 1  downto 0) ; 
empty, full : o u t  std-logic; 
r-data: o u t  std-logic-vector ( B - 1  downto 0) 
I5 
; 
end fifo: 
a r c h i t e c t u r e  arch of fifo i s  
t y p e  reg-file-type i s  a r r a y  (2**W-1 
downto 0) of 
20 
std-logic-vector ( B - 1  downto 0) ; 
s i g n a l  array-reg : reg-f ile-type ; 
s i g n a l  w-ptr-reg , w-ptr-next , w-ptr-succ : 
s i g n a l  r-ptr-reg , r-ptr-next , r-ptr-succ: 
s i g n a l  full-reg , empty-reg , full-next , empty-next : 
std-logic; 
s i g n a l  wr-op: std-logic-vector (1 downto 0 )  ; 
s i g n a l  wr-en : std-logic ; 
std-logic-vector (W-1 downto 0 )  ; 
25 
std-logic-vector ( W - 1  
downto 0) ; 
30 begin 
__ 
__ r e g i s t e r  f i l e  
__ 
40 
p r o c e s s  (clk, reset) 
3s 
begin 
if (reset=’l ’ )  t h e n  
e l s i f  (clk’event and clk=’l’) t h e n  
array-reg <= ( o t h e r s = > (  o t h e r s = >  ’ 0 ’ ) )  ; 
i f  wr-en=’l’ t h e n  
array_reg(to-integer(unsigned(w-ptr-reg))) 
<= w-data; 
end if ; 
end i f  ; 
end p r o c e s s ;  
4s 
-- read p o r t  
r-data <= array_reg(to-integer(unsigned(r-ptr-reg))); 
__ w r i t e  e n a b l e d  o n l y  when FIFO i s  n o t  f u l l  
wr-en <= wr and ( n o t  full-reg); 
50 
-- 
-- f i f o  c o n t r o l  l o g i c  
__ r e g i s t e r  f o r  read and w r i t e  p o i n t e r s  
p r o c e s s  (clk , reset) 
__ 
55 
begin 
i f  (reset=’l’) t h e n  
w-ptr-reg <= ( o t h e r s = > ’ O ’ ) ;  
r-ptr-reg <= ( o t h e r s = > ’ O ’ ) ;  
full-reg <= ’ 0  ’ ; 
empty-reg <= ’ 1 ’ ;  
w-ptr-reg <= w-ptr-next ; 
r-ptr-reg <= r-ptr-next ; 
full-reg <= full-next; 
e l s i f  (clk’event and clk=’l’) t h e n  
60 

CASE STUDY 
103 
65 
empty-reg <= empty-next ; 
end i f  ; 
end p r o c e s s ;  
-- s u c c e s s i v e  p o i n t e r  v a l u e s  
70 
w-ptr-succ <= std-logic-vector (unsigned(w_ptr-reg)+l) ; 
r-ptr-succ <= std-logic-vector(unsigned(r-ptr-reg)+l); 
80 
85 
90 
95 
IW 
-- n e x t - s t a t e  
logic f o r  read and w r i t e  p o i n t e r s  
wr-op <= wr k r d ;  
process (w-ptr-reg, w-ptr-succ ,r-ptr-reg ,r-ptr-succ ,wr-op, 
begin 
75 
empty-reg , full-reg) 
w-ptr-next <= w-ptr-reg; 
r-ptr-next <= r-ptr-reg; 
full-next <= full-reg; 
empty-next <= empty-reg ; 
case wr-op is 
when " 0 0 "  => -- no op 
when "01" = >  -- read 
i f  (empty-reg /= '1') then -- n o t  e m p t y  
r-ptr-next <= r-ptr-succ; 
full-next <= ' 0 ' ;  
i f  (r-ptr-succ=w-ptr-reg) then 
end i f  ; 
empty-next <='l'; 
end i f  ; 
i f  (full-reg /= '1') then -- n o t  f u l l  
when "10" = >  -- w r i t e  
w-ptr-next <= w-ptr-succ; 
empty-next <= ' 0 ' ;  
i f  (w-ptr-succ=r-ptr-reg) then 
end i f  ; 
full-next <='1'; 
end i f  ; 
w-ptr-next <= w-ptr-succ ; 
r-ptr-next <= r-ptr-succ ; 
when others => -- w r i t e / r e a d ;  
end c a s e ;  
end p r o c e s s ;  
full <= full-reg; 
empty <= empty-reg; 
105 
-- o u t p u t  
end a r c h ;  
The code is divided into a register file and a FIFO controller. The controller consists of 
two pointers and two status FFs. Its next-state logic examines the wr and rd signals and takes 
actions accordingly. For example, let us consider the 'I 10" case, which implies that only a 
write operation occurs. The status FF is checked first to ensure that the buffer is not full. 
If this condition is met, we advance the write pointer by one position and clear the empty 
status FF Storing one extra word to the buffer may make it full. This happens if the new 
write pointer "catches" the read pointer, which is expressed by the w-ptr-succ=r-ptr-reg 
expression. 

104 
REGULAR SEQUENTIAL CIRCUIT 
Verification circuit The verification circuit examines the operation of a 24-by-3 FIFO 
buffer. We use three switches to generate the input data and use two buttons for the w r  
and rd signals. The 3-bit readout and the f u l l  and empty status signals are displayed 
in five discrete LEDs. Because of bounces of the mechanical contact, a debouncing cir- 
cuit is needed to generate a clean, one-clock-cycle tick. The debouncing module, named 
debounce, is discussed in Section 5.9 but for now can be treated as a predesigned mod- 
ule. The original button inputs are btn(0) and btn (I), and the debounced signals are 
db-btn(0) and db-btn(l). The code is shown in Listing 4.21. 
Listing 4.21 Testing circuit for a FIFO buffer 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
e n t i t y  f i f o - t e s t  i s  
p o r t  ( 
c l k ,  r e s e t :  in s t d - l o g i c ;  
b t n :  s t d - l o g i c - v e c t o r  (1 downto 0 )  ; 
sw: s t d - l o g i c - v e c t o r  ( 2  downto 0 )  ; 
l e d :  out s t d - l o g i c - v e c t o r  ( 7  downto 0) 
1 ;  
10 end f i f  o - t e s t  ; 
a r c h i t e c t u r e  a r c h  of f i f o - t e s t  i s  
begin 
s i g n a l  d b - b t n :  s t d - l o g i c - v e c t o r  (1 downto 0) ; 
15 
-- debouncing c i r c u i t  f o r  b t n ( 0 )  
b t n - d b - u n i t 0  : e n t i t y  work. debounce (fsrnd-arch) 
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , s w = > b t n ( O ) ,  
d b - l e v e l = > o p e n  , d b - t i c k = > d b - b t n  ( 0 ) )  ; 
-- debouncing c i r c u i t  f o r  b t n ( l )  
zo 
b t n - d b - u n i t 1  : e n t i t y  work.debounce(fsrnd-arch) 
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , s w = > b t n ( l ) ,  
d b - l e v e l = > o p e n  , d b - t i c k = > d b - b t n  (1)) ; 
-_ 
i n s t a n t i a t e  a 2 ^ 2 - b y - 3  f i f o  
f i f o - u n i t :  e n t i t y  w o r k . f i f o ( a r c h )  
25 
g e n e r i c  map(B=>3, W=>2) 
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , 
r d = > d b - b t n  (0) , wr=>db-btn (1) , 
w-data=>sw , r - d a t a = > l e d  ( 2  downto 0) , 
f u l l = > l e d ( 7 ) ,  ernpty=>led ( 6 ) )  ; 
30 
-- d i s a b l e  unused l e d s  
l e d ( 5  downto 3 ) < = ( o t h e r s = > ’ O ’ ) ;  
end a r c h ;  
4.6 BIBLIOGRAPHIC NOTES 
The bibliographic information for this chapter is similar to that for Chapter 3. 

SUGGESTED EXPERIMENTS 
105 
Figure 4.12 Pattern for Experiment 4.7.3. 
4.7 SUGGESTED EXPERIMENTS 
4.7.1 Programmable square wave generator 
A programmable square wave generator is a circuit that can generate a square wave with 
variable on (i.e,, logic ’ 1 ’) and off (i.e,, logic ’0’) intervals. The durations of the intervals are 
specified by two 4-bit control signals, m and n, which are interpreted as unsigned integers. 
The on and off intervals are m*100 ns and n*100 ns, respectively (recall that the period of 
the S 3  onboard oscillator is 20 ns). Design a programmable square wave generator circuit. 
The circuit should be completely synchronous. We need a logic analyzer or oscilloscope 
to verify its operation. 
4.7.2 PWM and LED dimmer 
The duty cycle of a square wave is defined as the percentage of the on interval (i.e., logic 
’ 1 ’) in a period. A PWM (pulse width modulation) circuit can generate an output with 
variable duty cycles. For a PWM with 4-bit resolution, a 4-bit control signal, w, specifies 
the duty cycle. The w signal is interpreted as an unsigned integer and the duty cycle is 5. 
1. Design a PWM circuit with 4-bit resolution and verify its operation using a logic 
analyzer or oscilloscope. 
2. Modify the LED time-multiplexing circuit to include the PWM circuit for the an 
signal. The PWM circuit specifies the percentage of time that the LED display is 
on. We can control the perceived brightness by changing the duty cycle. Verify the 
circuit’s operation by observing 1 bit of an on a logic analyzer or oscilloscope. 
3. Replace the LED time-multiplexing circuit of Listing 4.19 with the new design and 
use the lower 4 bits of the 8-bit switch to control the duty cycle. Verify operation of 
the circuit. It may be necessary to go to a dark area to see the effect of dimming. 
4.7.3 Rotating square circuit 
In a seven-segment LED display, a square pattern can be created by enabling the a, b, f, 
and g segments or the c, d, e, and g segments. We want to design a circuit that circulates 
the square patterns in the four-digit seven-segment LED display. The clockwise circulating 
pattern is shown in Figure 4.12. The circuit should have an input, en, which enables or 
pauses the circulation, and an input, cw, which specifies the direction (i.e., clockwise or 
counterclockwise) of the circulation. 
Design the circuit and verify its operation on the prototyping board. Make sure that the 
circulation rate is slow enough for visual inspection. 

106 
REGULAR SEQUENTIAL CIRCUIT 
Figure 4.13 Pattern for Experiment 4.7.4. 
4.7.4 Heartbeat circuit 
We want to create a “heartbeat” for the prototyping board. It repeats the simple pattern in 
the four-digit seven-segment display, as shown in Figure 4.13, at a rate of 72 Hz. Design 
the circuit and verify its operation on the prototyping board. 
4.7.5 
Rotating LED banner circuit 
The prototyping board has a four-digit seven-segment LED display, and thus only four 
symbols can be displayed at a time. We can show more information if the data is ro- 
tated and moved continuously. For example, assume that the message is 10 digits (i.e., 
“0123456789”). The display can show the message as “0123”, “1234”, “2345”, . . ., “6789”, 
“7890”, . . ., “0123”. The circuit should have an input, en, which enables or pauses the 
rotation, and an input, dir, which specifies the direction (i.e., rotate left or right). 
Design the circuit and verify its operation on the prototyping board. Make sure that the 
rotation rate is slow enough for visual inspection. 
4.7.6 Enhanced stopwatch 
Modify the stopwatch with the following extensions: 
0 Add an additional signal, up, to control the direction of counting. The stopwatch 
counts up when the up signal is asserted and counts down otherwise. 
0 Add a minute digit to the display. The LED display format should be like M . SS . D, 
where D represents 0.1 second and its range is between 0 and 9, SS represents seconds 
and its range is between 00 and 59, and M represents minutes and its range is between 0 
and 9. 
Design the new stopwatch and verify its operation with a testing circuit. 
4.7.7 Stack 
A stack is a last-in-first-out buffer in which the last stored data is retrieved first. Storing a 
data word to a stack is known as a push operation, and retrieving a data word from a stack 
is known as apop operation. The I/O signals of a stack are similar to those of a FIFO buffer 
except that we generally use the push and pop signals in place of the w r  and rd signals. 
Design a stack using a register file and verify its operation with a testing circuit similar to 
the one in Listing 4.21. 

CHAPTER 5 
FSM 
5.1 INTRODUCTION 
An FSM (finite state machine) is used to model a system that transits among a finite number 
of internal states. The transitions depend on the current state and external input. Unlike a 
regular sequential circuit, the state transitions of an FSM do not exhibit a simple, repetitive 
pattern. Its next-state logic is usually constructed from scratch and is sometimes known as 
“random” logic. This is different from the next-state logic of a regular sequential circuit, 
which is composed mostly of “structured” components, such as incrementors and shifters. 
In this chapter, we provide an overview of the basic characteristics and representation of 
FSMs and discuss the derivation of HDL codes. In practice, the main application of an FSM 
is to act as the controller of a large digital system, which examines the external commands 
and status and activates proper control signals to control operation of a data path, which 
is usually composed of regular sequential components. This is known as an FSMD (finite 
state machine with data path) and is discussed in Chapter 6. 
5.1.1 Mealy and Moore outputs 
The basic block diagram of an FSM is the same as that of a regular sequential circuit and is 
repeated in Figure 5.1. It consists of a state register, next-state logic, and output logic. An 
FSM is known as a Moore machine if the output is only a function of state, and is known as 
a Mealy machine if the output is a function of state and external input. Both types of output 
may exist in a complex FSM, and we simply refer to it as containing a Moore output and 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
107 

108 
FSM 
- 
Mealy 
output 
logic 
input 
clk 
d 
- 
next-state 
' state:eg 
" 
i 
Mealy 
output 
- 
logic 
state-next 
> state 
register 
Moore 
output 
Moore 
Figure 5.1 Block diagram of a synchronous FSM. 
- 
Mealy output. The Moore and Mealy outputs are similar but not identical. Understanding 
their subtle differences is the key for a controller design. The example in Section 5.3.1 
illustrates the behaviors and constructions of the two types of outputs. 
output 
logic 
5.1.2 FSM representation 
An FSM is usually specified by an abstract state diagram or ASM chart (algorithmic state 
machine chart), both capturing the FSM's input, output, states, and transitions in a graphical 
representation. The two representations provide the same information. The FSM represen- 
tation is more compact and better for simple applications. The ASM chart representation is 
somewhat like a flowchart and is more descriptive for applications with complex transition 
conditions and actions. 
State diagram A state diagram is composed of nodes, which represent states and are 
drawn as circles, and annotated transitional arcs. A single node and its transition arcs are 
shown in Figure 5.2(a). A logic expression expressed in terms of input signals is associated 
with each transition arc and represents a specific condition. The arc is taken when the 
corresponding expression is evaluated true. 
The Moore output values are placed inside the circle since they depend only on the 
current state. The Mealy output values are associated with the conditions of transition arcs 
since they depend on the current state and external input. To reduce clutter in the diagram, 
only asserted output values are listed. The output signal takes the default (Le., unasserted) 
value otherwise. 
A representative state diagram is shown in Figure 5.3(a). The FSM has four states, two 
external input signals (i.e., a and b), one Moore output signal (i.e., yl), and one Mealy 
output signal (i.e., yo). The yl signal is asserted when the FSM is in the s2 or s3 state. 
The yo signal is asserted when the FSM is in the SO state and the a and b signals are "1 1". 
ASM chart An ASM chart is composed of a network of ASM blocks. An ASM block 
consists of one state box and an optional network of decision boxes and conditional output 
boxes. A representative ASM block is shown in Figure 5.2(b). 
A state box represents a state in an FSM, and the asserted Moore output values are 
listed inside the box. Note that it has only one exit path. A decision box tests the input 
condition and determines which exit path to take. It has two exit paths, labeled T and F, 
which correspond to the t r u e  and f a l s e  values of the condition. A conditional output box 
lists asserted Mealy output values and is usually placed after a decision box. It indicates 
that the listed output signal can be activated only when the corresponding condition in the 
decision box is met. 

INTRODUCTION 
109 
mo: Moore output 
me: Mealy output 
state-name 
mo <= value 
logic expression I me <= value 
logic expression I me <= value 
to other state 
to other state 
(a) Node 
mo: Moore output 
me: Mealy output 
state entry 
r 
................. ........................... 
state box 
state 
mo <= value 
- decision box 
I 7- 
Boolean 
conditional 
output box 
.................................. 
t----- 
- 
exit to other ASM 
'L 
exit to other ASM 
block 
block 
(b) ASM block 
Figure 5.2 Symbol of a state. 

(a) State diagram 
A 
Y 
.............................. 
& 
~ 1 
( = = ) I  
.......................................... 
I- 
.................... & 
y l < = l  
F 
I----- 
L.. ............. 
(b) ASM chart 
,......... 
.......... 
1
%
~
 
................... 
Figure 5.3 Example of an FSM. 

FSM CODE DEVELOPMENT 
11 1 
A state diagram can easily be converted to an ASM chart, and vice versa. The corre- 
sponding ASM chart of the previous FSM state diagram is shown in Figure 5.3(b). 
5.2 FSM CODE DEVELOPMENT 
The procedure of developing code for an FSM is similar to that of a regular sequential 
circuit. We first separate the state register and then derive the code for the combinational 
next-state logic and output logic. The main difference is the next-state logic. For an FSM, 
the code for the next-state logic follows the flow of a state diagram or ASM chart. 
For clarity and flexibility, we use the VHDL‘s enumerated data type to represent the 
FSM’s states. The enumerated data type can best be explained by an example. Consider 
the FSM of Section 5.1.2, which has three states: SO, sl, and s2. We can introduce a 
user-defined enumerated data type as follows: 
type e g - s t a t e - t y p e  
i s  ( s o ,  sl, s 2 ) ;  
The data type simply lists (i.e., enumerates) all symbolic values. Once the data type is 
defined, it can be used for the signals, as in 
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : e g - s t a t e - t y p e ;  
During synthesis, software automatically maps the values in an enumerated data type to 
binary representations, a process known as state assignment. Although there is a mechanism 
to perform this manually, it is rarely needed. 
The complete code of the FSM is shown in Listing 5.1. It consists of segments for the 
state register, next-state logic, Moore output logic, and Mealy output logic. 
Listing 5.1 FSM example 
libr ar y i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 ,  a l l  ; 
e n t i t y  fsm-eg i s  
port ( 
5 
c l k ,  r e s e t :  in s t d - l o g i c ;  
a ,  b :  in s t d - l o g i c ;  
y o ,  y l :  out s t d - l o g i c  
) ;  
end fsm-eg; 
a r c h i t e c t u r e  m u l t - s e g - a r c h  
of fsm-eg i s  
10 
type e g - s t a t e - t y p e  
i s  ( s o ,  s l ,  s 2 ) ;  
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : e g - s t a t e - t y p e  ; 
begin 
I5 
-- s t a t e  r e g i s t e r  
process ( c l k  , r e s e t )  
begin 
i f  ( r e s e t = ’ l ’ )  then 
s t a t e - r e g  <= S O ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
20 
e 1 s i f  ( c l k  ’ e v e n t  and c l k =  ’ 1 ’ ) then 
end i f ; 
end p r o c e s s ;  
-_ 
n e x t - s t a t e  
l o g i c  
25 
process ( s t a t e - r e g  , a ,  b )  

112 
FSM 
30 
40 
45 
55 
65 
begin 
case s t a t e - r e g  i s  
when SO => 
i f  a = ’ 1 ’  then 
i f  b=’l) then 
e l s e  
end i f  ; 
s t a t e - n e x t  <= S O ;  
s t a t e - n e x t  <= s 2 ;  
s t a t e - n e x t  <= s l ;  
e l s e  
end i f ;  
when sl => 
i f  ( a = ’ 1 ’ )  then 
e l s e  
end i f  ; 
when s2 => 
s t a t e - n e x t  <= S O ;  
s t a t e - n e x t  <= S O ;  
s t a t e - n e x t  <= s l ;  
end c a s e ;  
end p r o c e s s ;  
-- Moore o u t p u t  l o g i c  
process ( s t a t e - r e g )  
50 
begin 
case s t a t e - r e g  i s  
when s o l s 2  => 
y l  <= ’ 0 ’ ;  
when sl => 
y l  <= ’ 1 ’ ;  
end c a s e ;  
end p r o c e s s ;  
-- M e a l y  o u t p u t  l o g i c  
process ( s t a t e - r e g  , a ,  b) 
case s t a t e - r e g  i s  
when SO => 
M 
begin 
i f  ( a = ’ l ’ )  and (b=)l’) then 
e l s e  
end i f  ; 
yo <= > 1 ’ ;  
yo <= 
) O ’ ;  
when sl I s2 => 
yo <= ’ 0 ’ ;  
70 
end c a s e ;  
end p r o c e s s ;  
end mult-seg-arch; 
The key part is the next-state logic. It uses a case statement with the state-reg signal 
as the selection expression. The next state (i.e., s t a t e x e x t  signal) is determined by the 
current state (i.e., state-reg) and external input. The code for each state basically follows 
the activities inside each ASM block of Figure 5.3(b). 

FSM CODE DEVELOPMENT 
11 3 
An alternative code is to merge next-state logic and output logic into a single combina- 
tional block, as shown in Listing 5.2. 
Listing 5.2 FSM with merged combinational logic 
a r c h i t e c t u r e  two-seg-arch 
of fsm-eg i s  
type e g - s t a t e - t y p e  is ( s o ,  s l ,  s2); 
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : e g - s t a t e - t y p e ;  
begin 
5 
-- s t a t e  r e g i s t e r  
process ( c l k ,  r e s e t )  
10 
begin 
i f  ( r e s e t = ’ l ’ )  then 
s t a t e - r e g  <= S O ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
s t a t e - r e g  <= s t a t e - n e x t ;  
end i f ;  
end p r o c e s s ;  
-_ 
n e x t - s t a t e  / o u t p u t  l o g i c  
15 
process ( s t a t e - r e g  , a , b )  
begin 
30 
35 
s t a t e - n e x t  <= s t a t e - r e g  ; -- d e f a u l t  back t o  same s t a t e  
yo <= ’ 0 ’ ;  
_- 
d e f a u l t  0 
d e f a u l t  0 
y l  <= j 0 ’ ;  
__ 
case s t a t e - r e g  i s  
when SO => 
if a = ’ 1 ’  then 
i f  b = ’ l ’  then 
s t a t e - n e x t  <= s 2 ;  
yo <= ’1’; 
e l s e  
end if ; 
s t a t e - n e x t  <= sl; 
-- no e l s e  b r a n c h  
end if ; 
when sl => 
y l  <= ’ l > ;  
if ( a = ’ l ’ )  then 
-- no e l s e  b r a n c h  
end i f  ; 
when s2 => 
s t a t e - n e x t  <= S O ;  
s t a t e - n e x t  <= S O ;  
end c a s e ;  
40 
end p r o c e s s ;  
end two-seg-arch; 
Note that the default output values are listed at the beginning of the code. 
The code for the next-state logic and output logic follows the ASM chart closely. Once a 
detailed state diagram or ASM chart is derived, converting an FSM to HDL code is almost 
a mechanical procedure. Listings 5.1 and 5.2 can serve as templates for this purpose. 

114 
FSM 
Xilinx 
specific 
Xilinx ISE includes a utility program called StateCAD, which allows a user to draw a 
state diagram in graphical format. The program then converts the state diagram to HDL 
code. It is a good idea to try it first with a few simple examples to see whether the generated 
code and its style are satisfactory, particularly for the output signals. 
5.3 DESIGN EXAMPLES 
5.3.1 Rising-edge detector 
The rising-edge detector is a circuit that generates a short, one-clock-cycle pulse (we call it 
a tick) when the input signal changes from ’0’ to ’ 1 ’. It is usually used to indicate the onset 
of a slow time-varying input signal. We design the circuit using both Moore and Mealy 
machines, and compare their differences. 
Moore-based design The state diagram and ASM chart of a Moore machine-based 
edge detector are shown in Figure 5.4. The zero and one states indicate that the input 
signal has been ’0’ and ’ 1’ for awhile. The rising edge occurs when the input changes to ’ 1 ’ 
in the zero state. The FSM moves to the edge state and the output, t i c k ,  is asserted in 
this state. A representative timing diagram is shown at the middle of Figure 5.5. The code 
is shown in Listing 5.3. 
Listing 5.3 Moore machine-based edge detector 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
e n t i t y  e d g e - d e t e c t  
i s  
port ( 
5 
c l k ,  r e s e t :  in s t d - l o g i c ;  
l e v e l  : in s t d - l o g i c  ; 
t i c k :  out s t d - l o g i c  
) ;  
end e d g e - d e t e c t ;  
a r c h i t e c t u r e  moore-arch of e d g e - d e t e c t  i s  
10 
type s t a t e - t y p e  i s  ( z e r o ,  e d g e ,  o n e ) ;  
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : s t a t e - t y p e ;  
begin 
15 
-- s t a t e  r e g i s t e r  
process ( c l k  , r e s e t  1 
begin 
i f  ( r e s e t = ’ l ’ )  then 
s t a t e - r e g  <= z e r o ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
20 
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end if ; 
end p r o c e s s ;  
-- n e x t - s t a t e  / o u t p u t  logic 
begin 
25 
process ( s t a t e - r e g ,  l e v e l )  
s t a t e - n e x t  <= s t a t e - r e g ;  
t i c k  <= ’ 0 ’ ;  
case s t a t e - r e g  is 

DESIGN EXAMPLES 
11 5 
- 
(a) State diagram 
(b) ASM chart 
Figure 5.4 
Edge detector based on a Moore machine. 
tl 
t 
level 
I 
state 
zero 
edge 
one 
zero 
r 
X 
X 
X 
X 
X 
Moore 
machine 1 
tick 
7
1
 
i 
r state ( 
zero 
one 
zero 
Mealy 
machine 
‘I c tick 
Figure 5.5 
Timing diagram of two edge detectors. 

116 
FSM 
30 
35 
40 
(a) State diagram 
(b) ASM chart 
Figure 5.6 Edge detector based on a Mealy machine. 
when z e r o = >  
i f  l e v e l =  'I' then 
end i f  ; 
when edge => 
t i c k  <= ' 1 ' ;  
i f  l e v e l =  ' 1 '  then 
e l s e  
end i f ;  
i f  l e v e l =  ' 0 '  then 
end i f  ; 
s t a t e - n e x t  <= e d g e ;  
s t a t e - n e x t  <= o n e ;  
s t a t e - n e x t  <= z e r o ;  
when one => 
s t a t e - n e x t  <= z e r o ;  
45 
end c a s e ;  
end p r o c e s s ;  
end rnoore-arch; 
Mealy-based design The state diagram and ASM chart of a Mealy machine-based 
edge detector are shown in Figure 5.6. The zero and one states have similar meaning. 
When the FSM is in the zero state and the input changes to 'l', the output is asserted 

DESIGN EXAMPLES 
11 7 
tick 
level 
clk 
Figure 5.7 Gate-level implementation of an edge detector. 
immediately. The FSM moves to the one state at the rising edge of the next clock and the 
output is deasserted. A representative timing diagram is shown at the bottom of Figure 5.5. 
Note that due to the propagation delay, the output signal is still asserted at the rising edge 
of the next clock (i.e., at tl). The code is shown in Listing 5.4. 
10 
20 
25 
Listing 5.4 Mealy machine-based edge detector 
a r c h i t e c t u r e  m e a l y - a r c h  of e d g e - d e t e c t  
i s  
type s t a t e - t y p e  i s  ( z e r o ,  o n e ) ;  
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : s t a t e - t y p e ;  
begin 
5 
-- s t a t e  r e g i s t e r  
process ( c l k ,  r e s e t )  
begin 
i f  ( r e s e t = ’ l ’ )  then 
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end i f  ; 
end p r o c e s s ;  
_- 
n e x t - s t a t e  / o u t p u t  logic 
begin 
s t a t e - r e g  <= z e r o ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
15 
process ( s t a t e - r e g  , l e v e l )  
s t a t e - n e x t  <= s t a t e - r e g ;  
t i c k  <= ’ 0 ’ ;  
case s t a t e - r e g  i s  
when z e r o = >  
i f  l e v e l =  ’ 1 ’  then 
s t a t e - n e x t  <= o n e ;  
t i c k  <= ’ 1 ’ ;  
end i f ;  
i f  l e v e l =  ’ 0 ’  then 
end if ; 
when one = >  
s t a t e - n e x t  <= z e r o ;  
end c a s e ;  
?O 
end p r o c e s s ;  
end m e a l y - a r c h ;  
Direct implementation Since the transitions of the edge detector circuit are very sim- 
ple, it can be implemented without using an FSM. We include this implementation for 
comparison purposes. The circuit diagram is shown in Figure 5.7. It can be interpreted that 
the output is asserted only when the current input is ’1’ and the previous input, which is 
stored in the register, is ’0’. The corresponding code is shown in Listing 5.5. 

118 
FSM 
Listing 5.5 Gate-level implementation of an edge detector 
a r c h i t e c t u r e  gate-level-arch of edge-detect i s  
begin 
s i g n a l  delay-reg : std-logic ; 
_- 
d e l a y  r e g i s t e r  
5 
process (clk, reset 1 
lo 
begin 
i f  (reset=’l’) then 
e l s i f  (clk’event and clk=’l’) then 
end i f  ; 
end p r o c e s s ;  
-- d e c o d i n g  l o g i c  
tick <= ( n o t  delay-reg) and level; 
delay-reg <= ’ 0 ’ ;  
delay-reg <= level; 
15 end gate-level-arch; 
Although the descriptions in Listings 5.4 and 5.5 appear to be very different, they describe 
the same circuit. The circuit diagram can be derived from the FSM if we assign ’0’ and ’1’ 
to the zero and one states. 
Comparison Whereas both Moore machine- and Mealy machine-based designs can 
generate a short tick at the rising edge of the input signal, there are several subtle differences. 
The Mealy machine-based design requires fewer states and responds faster, but the width 
of its output may vary and input glitches may be passed to the output. 
The choice between the two designs depends on the subsystem that uses the output 
signal. Most of the time the subsystem is a synchronous system that shares the same clock 
signal. Since the FSM’s output is sampled only at the rising edge of the clock, the width 
and glitches do not matter as long as the output signal is stable around the edge. Note that 
the Mealy output signal is available for sampling at tl, which is one clock cycle faster than 
the Moore output, which is available at t 2 .  Therefore, the Mealy machine-based circuit is 
preferred for this type of application. 
5.3.2 Debouncing circuit 
The slide and pushbutton switches on the prototyping board are mechanical devices. When 
pressed, the switch may bounce back and forth a few times before settling down. The 
bounces lead to glitches in the signal, as shown at the top of Figure 5.8. The bounces 
usually settle within 20 ms. The purpose of a debouncing circuit is to filter out the glitches 
associated with switch transitions. The debounced output signals from two FSM-based 
design schemes are shown in the two bottom parts of Figure 5.8. The first design scheme is 
discussed in this subsection and the second scheme is left as an exercise in Experiment 5.5.2. 
A better alternative FSMD-based scheme is discussed in Section 6.2.1. 
An FSM-based design uses a free-running 10-ms timer and an FSM. The timer generates 
a one-clock-cycle enable tick (the m-tick signal) every 10 ms and the FSM uses this 
information to keep track of whether the input value is stabilized. In the first design scheme, 
the FSM ignores the short bounces and changes the value of the debounced output only 
after the input is stabilized for 20 ms. The output timing diagram is shown at the middle 
of Figure 5.8. The state diagram of this FSM is shown in Figure 5.9. The zero and one 
states indicate that the switch input signal, sw, has been stabilized with ’0’ and ’ 1 ’ values. 

DESIGN EXAMPLES 
11 9 
original 
switch output 
bounces 
bounces 
(last less than 20 ms) 
(last less than 20 ms) 
- -  
- 
-- 
L 
20 ms- 
debounced output 
(scheme 1) 
*Oms 
I 
I 
, 
20ms 
debounced output 
(scheme 2) 
20 ms 
-
;
 
Figure 5.8 Original and debounced waveforms. 
Figure 5.9 State diagram of a debouncing circuit. 

Assume that the FSM is initially in the zero state. It moves to the w a i t  1-1 state when s w  
changes to ’1’. At the w a i t l - l  state, the FSM waits for the assertion of m - t i c k .  If s w  
becomes ’0’ in this state, it implies that the width of the ’1’ value does not last long enough 
and the FSM returns to the zero state. This action repeats two more times for the w a i t  1-2 
and w a i t  1-3 states. The operation from the one state is similar except that the s w  signal 
must be ’0’. 
Since the 10-ms timer is free-running and the m - t i c k  tick can be asserted at any time, 
the FSM checks the assertion three times to ensure that the s w  signal is stabilized for at least 
20 ms (it is actually between 20 and 30 ms). The code is shown in Listing 5.6. It includes 
a 10-ms timer and the FSM. 
Listing 5.6 FSM implementation of a debouncing circuit 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
use i e e e  . n u m e r i c - s t d .  a l l  ; 
e n t i t y  db-fsm i s  
5 
p o r t (  
c l k ,  r e s e t :  in s t d - l o g i c ;  
sw: in s t d - l o g i c ;  
d b :  out s t d - l o g i c  
) ;  
1 0  end db-f s m  ; 
a r c h i t e c t u r e  a r c h  of db-fsm i s  
constant N: i n t e g e r : = 1 9 ;  -- 2 * N  * 2 0 n s  = l O m s  
s i g n a l  q - r e g ,  q - n e x t  : u n s i g n e d ( N - 1  downto 0) ; 
type e g - s t a t e - t y p e  
i s  ( z e r o  , w a i t l - l ,  w a i t l - 2  , w a i t l - 3 ,  
o n e ,  w a i t 0 - 1 ,  w a i t 0 - 2 ,  w a i t 0 - 3 )  ; 
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : e g - s t a t e - t y p e ;  
15 
s i g n a l  m - t i c k :  s t d - l o g i c ;  
begin 
20 
-- c o u n t e r  t o  g e n e r a t e  lOms t i c k  
-- ( 2 ^ 1 9  * 2 0 n s )  
process ( c l k ,  r e s e t )  
25 
begin 
i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end i f ;  
end p r o c e s s ;  
q - n e x t  
<= q - r e g  + 1; 
- - o u t p u t  
t i c k  
rn-tick 
<= ’ 1 ’  when q-reg=O e l s e  
q - r e g  <= q - n e x t ;  
30 
-- n e x t - s t a t e  
l o g i c  
’ 0 ’ .  
35 
-- d e b o u n c i n g  FSM 
__ s t a t e  r e g i s t e r  
process ( c l k ,  r e s e t  1 
40 
begin 

DESIGN EXAMPLES 
121 
i f  ( r e s e t = ’ l ’ )  then 
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
s t a t e - r e g  <= z e r o ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
45 
end i f  ; 
end p r o c e s s ;  
-- n e x t - s t a t e / o u t p u t  
l o g i c  
process ( s t a t e - r e g  , sw , m - t i c k )  
begin 
50 
s t a t e - n e x t  <= s t a t e - r e g ;  - - d e f a u l t :  
back t o  same s t a t e  
db <= ’ 0 ’ ;  
-- d e f a u l t  0 
case s t a t e - r e g  is 
when z e r o  => 
i f  s w = ’ l ’  then 
55 
65 
7 5  
80 
85 
s t a t e - n e x t  <= w a i t l - 1 ;  
end i f  ; 
i f  s w = ’ O ’  then 
e l s e  
when w a i t l - 1  => 
s t a t e - n e x t  <= z e r o ;  
i f  m - t i c k = ’ l ’  then 
end i f ;  
s t a t e - n e x t  <= w a i t l - 2 ;  
end i f  ; 
i f  s w = ’ O ’  
then 
e l s e  
when w a i t l - 2  => 
s t a t e - n e x t  <= z e r o ;  
i f  m - t i c k = ’ l ’  then 
end i f  ; 
s t a t e - n e x t  <= w a i t l - 3 ;  
end i f  ; 
i f  s w = ’ O ’  then 
e l s e  
when waitl-3 => 
s t a t e - n e x t  <= z e r o ;  
i f  m - t i c k = ’ l ’  then 
end i f  ; 
s t a t e - n e x t  <= o n e ;  
end i f  ; 
when one => 
db < = ’ l ’ ;  
i f  s w = ’ O ’  
then 
end i f  ; 
s t a t e - n e x t  <= w a i t 0 - 1 ;  
when w a i t 0 - 1  => 
db < = ’ I J ;  
i f  s w = ’ 1 ’  then 
e l s e  
s t a t e - n e x t  <= o n e ;  
i f  m - t i c k = ’ l ’  then 
end i f  ; 
s t a t e - n e x t  
<= w a i t 0 - 2  ; 

122 
FSM 
- - 
btn(1) 
level 
tick - 
en 
q - 
> detector 
edge 
counter 
> 
4- 
hex0 
sseg 
sseg 
- 
hex1 
an - 
an 
95 
sw 
db - 
level 
tick - 
> 
debouncing 
edge 
clk - 
> detector 
105 
en 
9 
disp-mux-hex 
counter 
> 
reset 
I10 
Figure 5.10 Debouncing testing circuit. 
end i f  ; 
when w a i t 0 - 2  => 
db < = ’ I > ;  
i f  s w = ’ 1 ’  then 
e l s e  
s t a t e - n e x t  <= o n e ;  
i f  m - t i c k = ’ l J  then 
end i f  ; 
s t a t e - n e x t  <= w a i t 0 - 3 ;  
end i f  ; 
when w a i t 0 - 3  = >  
db < = ’ I > ;  
i f  s w = ’ 1 ’  then 
e l s e  
s t a t e - n e x t  <= o n e ;  
i f  m - t i c k = ’ l ’  then 
end i f  ; 
s t a t e - n e x t  <= z e r o ;  
end i f  ; 
end c a s e ;  
end p r o c e s s ;  
11s end a r c h ;  
5.3.3 Testing circuit 
We use a bounce counting circuit to verify operation of the rising-edge detector and the 
debouncing circuit. The block diagram is shown in Figure 5.10. The input of the verification 
circuit is from a pushbutton switch. In the lower part, the signal is first fed to the debouncing 
circuit and then to the rising-edge detector. Therefore, a one-clock-cycle tick is generated 
each time the button is pressed and released. The tick in turn controls the enable input of 
an 8-bit counter, whose content is passed to the LED time-multiplexing circuit and shown 
on the left two digits of the prototyping board’s seven-segment LED display. In the upper 
part, the input signal is fed directly to the edge detector without the debouncing circuit, 
and the number is shown on the right two digits of the prototyping board’s seven-segment 
LED display. The bottom counter thus counts one desired 0-to- 1 transition as well as the 
bounces. 

DESIGN EXAMPLES 
123 
The code is shown in Listing 5.7. It basically uses component instantiation to realize 
the block diagram. 
Listing 5.7 Verification circuit for a debouncing circuit and rising-edge detector 
l i b r a r y  ieee; 
use ieee. std-logic-1164 
~ a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  debounce-test i s  
s 
p o r t (  
clk: in std-logic; 
btn: in std-logic-vector ( 3  downto 0) ; 
a n :  out std-logic-vector (3 downto 0) ; 
sseg: out std-logic-vector (7 downto 0) 
10 
) ; 
end debounce-test ; 
a r c h i t e c t u r e  arch of debounce-test i s  
s i g n a l  ql-reg , ql-next : unsigned ( 7  downto 0) ; 
I S  
s i g n a l  qO-reg, q0-next : unsigned(7 downto 0) ; 
s i g n a l  b-count , d-count: std-logic-vector (7 downto 0) ; 
s i g n a l  btn-reg , db-reg : std-logic ; 
s i g n a l  db-level , db-tick, btn-tick , clr: std-logic; 
begin 
2o 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
__ component i n s  t a n  t i a  t i  o n  
__ i n  s t a n t i  a t e hex d i s p l a y  t i m e  - m u  1 t i p  1 e x i n  g 
disp-unit : e n t i t y  work. disp-hex-mux 
____________________----------------------------- 
__ ____________________----------------------------- 
c i r c u i I 
5 
p o r t  map( 
clk=>clk, reset=>'O', 
hex3=>b_count (7 downto 4) , hex2=>b_count (3 downto 0) , 
hexl=>d-count (7 downto 4 ) ,  hexO=>d-count ( 3  downto 0 1 ,  
dp-in=>"lOll", an=>an, sseg=>sseg); 
30 
-- i n s t a n t i a t e  d e b o u n c i n g  c i r c u i t  
db-unit: e n t i t y  work.db-fsm(arch1 
clk=>clk, reset=>'O', 
sw=>btn (1) , db=>db-level) ; 
port map( 
__ edge d e t e c t i o n  c i r c u i t s  
process (clk) 
40 
begin 
if (clk'event and clk='l') then 
btn-reg <= btn(1) ; 
db-reg <= db-level; 
end if ; 
JS 
end p r o c e s s ;  
btn-tick <= ( n o t  btn-reg) and btn(l); 
db-tick <= ( n o t  db-reg) and db-level; 

FSM 
124 
50 
55 
60 
65 
__ two c o u n t e r s  
clr <= btn(0) ; 
process (clk) 
begin 
____________________------------------------------- 
________----------------------------------------- 
i f  (clk event and clk= ’ 1 ’ 
then 
ql-reg <= ql-next; 
q0-reg <= q0-next; 
end i f  ; 
end p r o c e s s ;  
_- 
n e x t - s t a t e  
l o g i c  for t h e  c o u n t e r  
ql-next <= ( o t h e r s = > ’ O ’ )  when clr=’l’ e l s e  
ql-reg + 1 when btn-tick=’l’ e l s e  
ql-reg ; 
q0-reg + 1 when db-tick=’l’ e l s e  
qO-reg; 
q0-next <= ( o t h e r s = > ’ O ’ )  when c l r = ’ l ’  e l s e  
-- 0 u t p  u t 
b-count <= std-logic-vector(q1-reg); 
d-count <= std-logic-vector (qO-reg) ; 
70 end arch; 
The seven-segment display shows the accumulated numbers of 0-to-1 edges of bounced 
and debounced switch input. After pressing and releasing the pushbutton switch several 
times, we can determine the average number of bounces for each transition. 
5.4 BIBLIOGRAPHIC NOTES 
The bibliographic information for this chapter is similar to that for Chapter 3. 
5.5 SUGGESTED EXPERIMENTS 
5.5.1 
Dual-edge detector 
A dual-edge detector is similar to a rising-edge detector except that the output is asserted 
for one clock cycle when the input changes from 0 to 1 (i.e., rising edge) and 1 to 0 (i.e., 
falling edge). 
1. Design the circuit based on the Moore machine and draw the state diagram and ASM 
2. Derive the HDL code based on the state diagram of the ASM chart. 
3. Derive a testbench and use simulation to verify operation of the code. 
4. Replace the rising detectors in Section 5.3.3 with dual-edge detectors and verify their 
5. Repeat steps 1 to 4 for a Mealy machine-based design. 
chart. 
operations. 
5.5.2 Alternative debouncing circuit 
One problem with the debouncing design in Section 5.3.2 is the delayed response of the 
onset of a switch transition. An alternative is to react to the first edge in the transition and 

SUGGESTED EXPERIMENTS 
125 
4= 
tl 
1 
entering lot 
Figure 5.11 Conceptual diagram of gate sensors. 
then wait for a small amount of time (at least 20 ms) to have the input signal settled. The 
output timing diagram is shown at the bottom of Figure 5.8. When the input changes from 
'0' to 'l', the FSM responds immediately. The FSM then ignores the input for about 20 ms 
to avoid glitches. After this amount of time, the FSM starts to check the input for the falling 
edge. Follow the design procedure in Section 5.3.2 to design the alternative circuit. 
1. Derive the state diagram and ASM chart for the circuit. 
2. Derive the HDL code. 
3. Derive the HDL code based on the state diagram and ASM chart. 
4. Derive a testbench and use simulation to verify operation of the code. 
5. Replace the debouncing circuit in Section 5.3.3 with the alternative design and verify 
its operation. 
5.5.3 Parking lot occupancy counter 
Consider a parking lot with a single entry and exit gate. Two pairs of photo sensors are used 
to monitor the activity of cars, as shown in Figure 5.11. When an object is between the 
photo transmitter and the photo receiver, the light is blocked and the corresponding output 
is asserted to '1'. By monitoring the events of two sensors, we can determine whether a 
car is entering or exiting or a pedestrian is passing through. For example, the following 
sequence indicates that a car enters the lot: 
0 Initially, both sensors are unblocked (i.e., the a and b signals are ''00''). 
0 Sensor a is blocked (i.e., the a and b signals are "lo"). 
0 Both sensors are blocked (i.e., the a and b signals are 'I 1 1 "). 
0 Sensor a is unblocked (i.e., the a and b signals are ''01''). 
0 Both sensors becomes unblocked (i.e., the a and b signals are llOO1l). 
1. Design an FSM with two input signals, a and b, and two output signals, enter and 
exit. The enter and e x i t  signals assert one clock cycle when a car enters and one 
clock cycle when a car exits the lot, respectively. 
2. Derive the HDL code for the FSM. 
Design a parking lot occupancy counter as follows: 

126 
FSM 
3. Design a counter with two control signals, inc and dec, which increment and decre- 
ment the counter when asserted. Derive the HDL code. 
4. Combine the counter and the FSM and LED multiplexing circuit. Use two debounced 
pushbuttons to mimic operation of the two sensor outputs. Verify operation of the 
occupancy counter. 

CHAPTER 6 
FSMD 
6.1 INTRODUCTION 
An FSMD (finite state machine with data path) combines an FSM and regular sequential 
circuits. The FSM, which is sometimes known as a control path, examines the external 
commands and status and generates control signals to specify operation of the regular 
sequential circuits, which are known collectively as a data path. The FSMD is used to 
implement systems described by RT(register transfer) methodology, in which the operations 
are specified as data manipulation and transfer among a collection of registers. 
6.1.1 Single RT operation 
An RT operation specifies data manipulation and transfer for a single destination register. 
It is represented by the notation 
rdest + f(rsrcl, rsrc2, . . . , rsrcn) 
where rdest is the destination register, rsrCl, rSrc2, and r,,,, are the source registers, and f (  .) 
specifies the operation to be performed. The notation indicates that the contents of the source 
registers are fed to the f ( . )  function, which is realized by a combinational circuit, and the 
result is passed to the input of the destination register and stored in the destination register 
at the next rising edge of the clock. Following are several representative RT operations: 
0 ri + 0. A constant 0 is stored in the rl register. 
0 rl +- ri. The content of the rl register is written back to itself. 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
127 

128 
FSMD 
a
m
 
I D- 
b-reg 
clk 
(a) Block diagram 
clk A-1 
7 
x 
5 
a-reg 
9 
(b) Timing diagram 
Figure 6.1 Block and timing diagrams of an RT operation. 
0 r2 +- r2 >> 3. The r2 register is shifted right three positions and then written back 
0 r2 c rl. The content of the rl register is transferred to the r2 register. 
0 i c i + 1. The content of the i register is incremented by 1 and the result is written 
0 d c sl + s2 + s3. The summation of the sl, s2, and s3 registers is written to the d 
0 y + a*a. The a squared is written to the y register. 
to itself. 
back to itself. 
register. 
A single RT operation can be implemented by constructing a combinational circuit for 
the f (.) function and connecting the input and output of the registers. For example, consider 
the a + a-b+l operation. The f(.) function involves a subtractor and an incrementor. The 
block diagram is shown in Figure 6.l(a). For clarity, we use the -reg and n e x t  suffixes to 
represent the input and output of a register. Note that an RT operation is synchronized by an 
embedded clock. The result from the f (.) function is not stored to the destination register 
until the next rising edge of the clock. The timing diagram of the previous RT operation is 
shown in Figure 6.l(b). 
6.1.2 ASMD chart 
A circuit based on the RT methodology specifies which RT operations should be executed 
in each step. Since an RT operation is done in a clock-by-clock basis, its timing is similar 
to a state transition of an FSM. Thus, an FSM is a natural choice to specify the sequencing 

INTRODUCTION 
129 
r l  t 
r l  + r2 u 
r l  t 
r l  << 2 
r l  t 
r l  
state-reg 
clk 
(a) ASMD segment 
(b) Block diagram 
Figure 6.2 Realization of an ASMD segment. 
of an RT algorithm. We extend the ASM chart to incorporate RT operations and call it 
an ASMD (ASM with data path) chart. The RT operations are treated as another type of 
activity and can be placed where the output signals are used. 
A segment of an ASMD chart is shown in Figure 6.2(a). It contains one destination 
register, r l ,  which is initialized with 8, added with content of the r 2  register, and then 
shifted left two positions. Note that the rl register must be specified in each state. When 
rl is not changed, the rl +- rl operation should be used to maintain its current content, as 
in the s3 state. In future discussion, we assume that r t r is the default RT operation for the 
r register and do not include it in the ASMD chart. Implementing the RT operations of an 
ASMD chart involves a multiplexing circuit to route the desired next value to the destination 
register. For example, the previous segment can be implemented by a 4-to-1 multiplexer, as 
shown in Figure 6.2(b). The current state (i.e., the output of the state register) of the FSM 
controls the selection signal of the multiplexer and thus chooses the result of the desired 
RT operation. 
An RT operation can also be specified in a conditional output box, as the r 2  register shown 
in Figure 6.3(a). Depending on the a>b condition, the FSMD performs either r 2  +- r2+a or 
r 2  +- 
r2+b. Note that all operations are done in parallel inside an ASMD block. We need 
to realize the a>b, r2+a, and r2+b operations and use a multiplexer to route the desired 
value to r2. The block diagram is shown in Figure 6.3(b). 
6.1.3 Decision box with a register 
The appearance of an ASMD chart is similar to that of a normal flowchart. The main 
difference is that the RT operation in an ASMD chart is controlled by an embedded clock 
signal and the destination register is updated when the FSMD exits the current ASMD block, 
but not within the block. The r + r-1 operation actually means that: 
0 r n e x t  <= r-reg - I; 
0 r-reg <= r n e x t  at the rising edge of the clock (i.e., when the FSMD exits the 
current block). 

130 
FSMD 
-1 
j
d
 
4 
- 
: u -  
I 
state-reg 
(b) Block diagram 
rl-reg 
> 
Figure 6.3 Realization of an RT operation in a conditional output box. 

CODE DEVELOPMENT OF AN FSMD 
131 
.................... 
r t r - I  $ 
T 
F- 
................... 
1 
(a) Use old value of r 
(y 
r-next=O 
F+ 
T 
................... 
1 
(b) Use new value of r 
Figure 6.4 ASM block affected by a delayed store. 
This “delayed store” may introduce subtle errors when a register is used in a decision box. 
Consider the FSMD segment in Figure 6.4(a). The r register is decremented in the state 
box and used in the decision box. Since the r register is not updated until the FSMD exits 
the block, the old content of r is used for comparison in the decision box. If the new value 
of r is desired, we should use the output of the combinational logic (i.e., r n e x t )  in the 
decision box (i.e., replace the r = O  expression with rnext=O), as shown in Figure 6.4(b). 
Note that we use the : = notation, as in r n e x t  : =r-i, to indicate the immediate assignment 
of r n e x t .  
Block diagram of an FSMD The conceptual block diagram of an FSMD is divided 
into a data path and a control path, as shown in Figure 6.5. The data path performs the 
required RT operations. It consists of 
0 Data registers: store the intermediate computation results 
0 Functional units: perform the functions specified by the RT operations 
Routing network: routes data between the storage registers and the functional units 
The data path follows the control signal to perform the desiredRT operations and generates 
the internal s t a t u s  signal. 
The control path is an FSM. As a regular FSM, it contains a state register, next-state 
logic, and output logic. It uses the external command signal and the data path’s s t a t u s  
signal as the input and generates the control signal to control the data path operation. 
The FSM also generates the external s t a t u s  signal to indicate the status of the FSMD 
operation. 
Note that although an FSMD consists of two types of sequential circuits, both circuits 
are controlled by the same clock, and thus the FSMD is still a synchronous system. 
6.2 CODE DEVELOPMENT OF AN FSMD 
We use an improved debouncing circuit to demonstrate derivation of the FSMD code. 
Although the debouncing circuit in Section 5.3.2 uses an FSM and a timer (which is a 
regular sequential circuit), it is not based on the RT methodology because the two units are 
running independently and the FSM has no control over the timer. Since the 10-ms enable 

132 
FSMD 
* 
data 
input 
- 
routing 
network 
- 
functional units - 
routing 
network 
- 
d
q
 
data 
> registers 
command 
internal status I 
I 
t 
control signal 
. . . . . . . . . . . . . .  
, 
, . . . . . . . .  , . . . .  . . . . . . . . . . . . . . . . .  
(I-.-- 
, 
-
,
 
data 
output 
next-state 
+ logic 
- 
external 
status 
output 
> register 
logic 
state 
control path 
Figure 6.5 
Block diagram of an FSMD. 
tick can be asserted at any time, the FSM does not know how much time has elapsed when 
the first tick is detected in the w a i t i - 1  or w a i t 0 - I  state. Thus, the waiting period in this 
design is between 20 and 30 ms but is not an exact interval. This deficiency can be overcome 
by applying the RT methodology. In this section, we use this improved debouncing circuit 
to illustrate the FSMD code development. 
6.2.1 
With the RT methodology, we can use an FSM to control the initiation of the timer to obtain 
the exact interval. The ASMD chart is shown in Figure 6.6. The circuit is expanded to 
include two output signals: db-level, which is the debounced output, and db-tick, which 
is a one-clock-cycle enable pulse asserted at the zero-to-one transition. The zero and one 
states mean that the s w  input has been stabilized for '0' and 'l', respectively. The w a i t l  
and w a i t 0  states are used to filter out short glitches. The s w  signal must be stable for a 
certain amount of time or the transition will be treated as a glitch. The data path contains 
one register, q, which is 21 bits wide. Assume that the FSMD is originally in the zero state. 
When the s w  input signal becomes ' 1 ', the FSMD moves to the w a i t  I state and initializes 
q to "1 . . . 1". In the w a i t l  state, the q decrements in each clock cycle. If s w  remains 
as ' 1 ', the FSMD returns to this state repeatedly until q reaches "0 . . .0" and then moves to 
the one state. 
Debouncing circuit based on RT methodology 

CODE DEVELOPMENT OF AN FSMD 
133 
........................................ 
... - 
q-next := q- 3 
q tq-next 
T 
db-tick <= 1 0 
d b-level<= 1 
T 
q -1 ... 1 0 
I- 
.... 
wait0 
d b-level<= 1 
T 
Figure 6.6 ASMD chart of a debouncing circuit. 

134 
FSMD 
Recall that the 50-MHz (i.e., 20-11s period) system clock is used on the prototyping 
board. Since the FSMD stays in the waitl state for 2’l clock cycles, it is about 40 ms 
(i.e., 221*20 ns). We can modify the initial value of the q register to obtain the desired wait 
interval. 
There are two ways to derive the HDL code, one with explicit description of the data 
path components and the other with implicit description of the data path components. 
6.2.2 Code with explicit data path components 
The first approach to FSMD code development is to separate the control FSM and the 
key data path components. From an ASMD chart, we first identify the key components 
in the data path and the associated control signals and then describe these components in 
individual code segments. 
The key data path component of the debouncing circuit ASMD chart is a custom 21-bit 
decrement counter that can: 
0 Be initialized with a specific value 
Count downward or pause 
Assert a status signal when the counter reaches 0 
We can create a binary counter with a q-load signal to load the initial value and a q-dec 
signal to enable the counting. The counter also generates a q-zero status signal, which 
is asserted when the counter reaches zero. The complete data path is composed of the q 
register and the next-state logic of the custom decrement counter. A comparison circuit is 
included to generate the q-zero status signal. The control path consists of an FSM, which 
takes the s w  input and the q-zero status and asserts the control signals, q-load and q-dec, 
according to the desired action in the ASMD chart. The HDL code follows the data path 
specification and the ASMD chart, and is shown in Listing 6.1. 
Listing 6.1 Debouncing circuit with an explicit data path component 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  debounce i s  
s 
p o r t (  
c l k ,  r e s e t :  in std-logic; 
s w :  in s t d - l o g i c ;  
db-level , db-tick: out std-logic 
) ;  
mend debounce ; 
a r c h i t e c t u r e  exp-fsmd-arch of debounce i s  
constant N: integer:=21; -- f i l t e r  of 
2 ^ N  * 2 0 n s  = 40ms 
type state-type i s  (zero, wait0, one, waitl); 
s i g n a l  q-reg , q-next : unsigned(N-1 downto 0) ; 
s i g n a l  q-load , q-dec , q-zero : std-logic ; 
-- FSMD s t a t e  
C? 
d a t a  r e g i s t e r s  
begin 
IS 
s i g n a l  state-reg , state-next : state-type; 
begin 
zo 
process (clk , r e s e t )  
if r e s e t = ’ l ’  then 
state-reg <= z e r o ;  

CODE DEVELOPMENT OF AN FSMD 
135 
q - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
q - r e g  <= q - n e x t ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end i f  ; 
end p r o c e s s ;  
30 
-- FSMD d a t a  p a t h  ( c o u n t e r )  n e x t - s t a t e  
l o g i c  
q - n e x t  
<= ( o t h e r s = >  ’ 1 ’ )  when q - l o a d =  1 ’ e l s e  
q - r e g  - 1 when q - d e c = ’ l J  e l s e  
q - r e g  ; 
35 
q - z e r o  <= ’ 1 ’  when q - n e x t = o  e l s e  j 0 ’ ;  
-- FSMD c o n t r o l  p a t h  n e x t - s t a t e  
l o g i c  
process ( s t a t e - r e g  , s w , q - z e r o )  
begin 
40 
q - l o a d  <= ’ 0 ’ ;  
q-dec <= ’ 0 ’ ;  
d b - t i c k  <= ’ 0 ’ ;  
s t a t e - n e x t  <= s t a t e - r e g ;  
case s t a t e - r e g  i s  
55 
i 0  
5 
when z e r o  => 
d b - l e v e l  <= > O J ;  
if ( s w = ’ l  ’) then 
s t a t e - n e x t  <= w a i t l ;  
q - l o a d  <= ’ 1 ’ ;  
end if ; 
when w a i t l = >  
d b - l e v e l  <= ’ 0 ’ ;  
if ( s w = ’ l ’ )  then 
q-dec <= ’ 1 ’ ;  
i f  ( q - z e r o = ’ l ’ )  then 
s t a t e - n e x t  
(= o n e ;  
d b - t i c k  <= ’1’; 
end if ; 
s t a t e - n e x t  <= z e r o ;  
e l s e  -- s w = ’ O ’  
end i f  ; 
d b - l e v e l  <= ’ 1 ’ ;  
i f  ( s w = ’ O J )  then 
when one => 
s t a t e - n e x t  <= w a i t 0 ;  
q - l o a d  <= ’1’; 
end i f ;  
when w a i t O = >  
d b - l e v e l  <= ’ 1 ’ ;  
i f  ( s w = ’ O ’ )  
then 
q-dec <= ’ 1 ’ ;  
if (q-zero=’l’) then 
end i f ;  
s t a t e - n e x t  
<= o n e ;  
s t a t e - n e x t  <= z e r o ;  
e l s e  -- sw= ’1 ’ 

136 
FSMD 
end i f  ; 
end c a s e ;  
end p r o c e s s ;  
80 end exp-f smd-arch ; 
6.2.3 Code with implicit data path components 
An alternative coding style is to embed the RT operations within the FSM control path. 
Instead of explicitly defining the data path components, we just list RT operations with the 
corresponding FSM state. The code of the debouncing circuit is shown in Listing 6.2. 
15 
21 
30 
35 
Listing 6.2 Debouncing circuit with an implicit data path component 
a r c h i t e c t u r e  imp-f smd-arch of debounce i s  
constant N: i n t e g e r : = 2 1 ;  -- f i l t e r  of 2 ^ N  * 2 0 n s  = 40ms 
type s t a t e - t y p e  i s  ( z e r o ,  w a i t 0 ,  o n e ,  w a i t l ) ;  
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : s t a t e - t y p e ;  
s 
s i g n a l  q - r e g ,  q - n e x t :  u n s i g n e d ( N - 1  downto 0 ) ;  
begin 
-- FSMD s t a t e  C? 
data r e g i s t e r s  
process ( c l k ,  r e s e t )  
begin 
10 
i f  r e s e t  = 1 ’ then 
s t a t e - r e g  <= z e r o ;  
q - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
q - r e g  <= q - n e x t ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end i f  ; 
end p r o c e s s ;  
-- n e x t - s t a t e  
l o g i c  & data p a t h  f u n c t i o n a l  u n i t s / r o u t i n g  
process ( s t a t e - r e g  , q - r e g  , s w  , q - n e x t )  
20 
begin 
s t a t e - n e x t  <= s t a t e - r e g ;  
q - n e x t  <= q - r e g ;  
d b - t i c k  <= ’ 0 ’  ; 
case s t a t e - r e g  i s  
when z e r o  => 
d b - l e v e l  <= ’ 0 ’ ;  
i f  ( s w = ’ l ’ )  then 
s t a t e - n e x t  <= w a i t l ;  
q - n e x t  
<= ( o t h e r s = > ’ l ’ ) ;  
end i f ;  
when w a i t l = >  
d b - l e v e l  <= ’ 0 ’ ;  
if 
( s w = ’ l ’ )  
then 
q - n e x t  
<= q - r e g  - 1; 
if ( q - n e x t = O )  then 
s t a t e - n e x t  <= o n e ;  
d b - t i c k  <= ’ 1 ’ ;  
end if ; 
s t a t e - n e x t  <= z e r o ;  
e l s e  -- sw=’O’ 

CODE DEVELOPMENT OF AN FSMD 
137 
55 
end i f  ; 
db-level <= ’1 ’ ; 
i f  (sw=’O’) then 
when one => 
state-next <= wait0; 
q-next <= ( o t h e r s = > ’ l ’ ) ;  
end i f ;  
when waitO=> 
db-level <= ’ 1 ’ ; 
i f  (sw=’O’) then 
q-next <= q-reg - 1; 
i f  (q-next=O) then 
end i f ;  
state-next <= one; 
state-next <= zero; 
e l s e  -- s w = ’ l ’  
end i f  ; 
end c a s e ;  
end p r o c e s s ;  
60 end imp-f smd-arch ; 
The code consists of a memory segment and a combinational logic segment. The former 
contains the state register of the FSM and the data register of the data path. The latter 
basically specifies the next-state logic of the control path FSM. Instead of generating control 
signals, the next data register values are specified in individual states. The next-state logic of 
the data path, which consists of functional units and routing network, is created accordingly. 
6.2.4 Comparison 
Code with implicit data path components essentially follows the ASMD chart. We just 
convert the chart to an HDL description. Although this approach is simpler and more 
descriptive, we rely on synthesis software for data path construction and have less control. 
This can best be explained by an example. Consider the ASMD segment in Figure 6.7. The 
implicit description becomes 
case 
when sl 
dl-next <= a * b ;  
. . .  
when s2 
d2-next <= b * c ;  
. . .  
when s3 
d3-next <= a * c ;  
. . .  
end c a s e ;  
The synthesis software may infer three multipliers. Since a combinational multiplier is a 
complex circuit, it is more efficient to share the circuit. We can use explicit description to 
isolate the multiplier: 
case 
when sl 

138 
FSMD 
Figure 6.7 ASMD segment with sharing opportunity. 
in1 <= a ;  
in2 <= b ;  
dl-next <= m-out; 
when s 2  
in1 <= b ;  
i n 2  <= c ;  
d2-next <= m-out; 
when s3 
in1 <= a ;  
in2 <= c ;  
d3-next <= m-out; 
end c a s e ;  
__ e x p l i c i t  d e s c r i p t i o n  of a s i n g l e  m u l t i p l i e r  
m-out <= in1 * in2; 
The code ensures that only one multiplier is inferred during synthesis. The implicit and 
explicit descriptions can be mixed for a complex FSMD design. We frequently isolate and 
extract complex data path components for code clarity and efficiency. 
6.2.5 
Testing circuit 
The debouncing testing circuit discussed in Section 5.3.3 can be used to verify operation of 
the new design. Since the revised debouncing circuit's outputs include a one-clock-cycle 
tick signal, no edge detector is needed after the debouncing circuit. The revised block 

CODE DEVELOPMENT OF AN FSMD 
139 
- 
btn(1) 
- 
level 
tick - 
en 
q - 
edge 
> detector 
>counter 
4- 
hex0 
sseg 
sseg 
- 
hex1 
an - 
an 
Figure 6.8 Debouncing testing circuit. 
diagram is shown in Figure 6.8, and the corresponding code is shown in Listing 6.3. 
Listing 6.3 
l i b r a r y  ieee; 
use ieee, std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  debounce-test i s  
Verification circuit for a debouncing circuit 
5 
p o r t (  
clk: in std-logic; 
btn: in std-logic-vector (3 downto 0) ; 
an: out std-logic-vector ( 3  downto 0) ; 
sseg: out std-logic-vector (7 downto 0) 
lo 
) ;  
end debounce-test ; 
sw 
db-tick 
> 
clk - debouncing 
30 
 en 
q 
disp-mux-hex 
> counter 
reset 
a r c h i t e c t u r e  arch of debounce-test i s  
s i g n a l  ql-reg , ql-next : unsigned ( 7  downto 0) ; 
I S  
s i g n a l  qO-reg, q0-next : unsigned ( 7  downto 0) ; 
s i g n a l  b-count , d-count : std-logic-vector (7 downto 0 )  ; 
s i g n a l  btn-reg : std-logic; 
s i g n a l  db-tick , btn-tick , clr : std-logic; 
begin 
20 
-- i n s t a n t i a t e  d e b o u n c i n g  c i r c u i t  
db-unit : e n t i t y  work. debounce (f smd-arch) 
port map( 
clk=>clk, reset=>'O', sw=>btn(l) , 
db-level=> open, db-tick=>db-tick 
1 ;  
_- 
i n s t a n t i a t e  h e x  d i s p l a y  t i m e  -mu1 t i p l x i n g  c i r c u i t  
disp-unit : e n t i t y  work. disp-hex-mux 
port map( 
clk=>clk , reset=> ' 0 '  , 
hex3=>b_count (7 downto 4), hex2=>b_count (3 downto 0 1 ,  
hexl=>d-count ( 7  downto 41, hexO=>d-count ( 3  downto 0 1 ,  
dp-in=>"lOll", an=>an, sseg=>sseg 
) ;  
-- e d g e  d e t e c t i o n  c i r c u i t  f o r  un-debounced 
i n p u t  

140 
FSMD 
____________________----------------------------- 
-- 
____________________--_--------------------- 
process (clk) 
begin 
40 
i f  (clk event and clk= ’ 1 ’ ) then 
btn-reg <= btn(1); 
end i f  ; 
end p r o c e s s ;  
btn-tick <= (not btn-reg) and btn(1); 
45 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
-_ 
two c o u n t e r s  
clr <= btn(0); 
begin 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
jn 
process (clk) 
i f  (clk ’ event and clk= ’ 1 ’ ) then 
ql-reg <= ql-next; 
q0-reg <= q0-next; 
55 
end i f  ; 
end p r o c e s s ;  
__ n e x t - s t a t e  
logic f o r  t h e  c o u n t e r  
ql-next <= ( o t h e r s = > ’ O ’ )  when c l r = ’ l ’  e l s e  
ql-reg f 1 when btn-tick=’l’ e l s e  
60 
ql-reg ; 
q0-next <= ( o t h e r s = > ’ O ’ )  when c l r = ’ i ’  e l s e  
q0-reg + 1 when db-tick=’l’ e l s e  
qO-reg; 
-_ 
c o u n t e r  o u t p u t  
65 
b-count <= std-logic-vector(ql-reg); 
d-count <= s t d - l o g i c - v e c t o r ( q 0 - r e g ) ;  
end arch; 
6.3 DESIGN EXAMPLES 
6.3.1 Fibonacci number circuit 
The Fibonacci numbers constitute a sequence defined as 
i f i = O  
i f i  = 1 
if i > 1 
f i b ( i  - 1) + f i b ( i  - 2) 
One way to calculate f i b ( i )  is to construct the function iteratively, from 0 to the desired i. 
This approach requires two temporary registers to store the two most recently calculated 
values (i.e., f i b ( i  - 1) and fib(i - 2)) and one index register to keep track of the number 
of iterations. The ASMD chart is shown in Figure 6.9, in which tl and t O  are temporary 
storage registers and n is the index register. In addition to the regular data input and output 
signals, i and f ,  we include a command signal, start, which signals the beginning of 
operation, and two status signals: ready, which indicates that the circuit is idle and ready 
to take new input, and done-tick, which is asserted for one clock cycle when the operation 

DESIGN EXAMPLES 
141 
ready <='I' 
-F 
............................................................. 
Figure 6.9 ASMD chart of a Fibonacci circuit. 

142 
FSMD 
is completed. Since this circuit, like many other FSMD designs, is probably a part of a 
larger system, these signals are needed to interface with other subsystems. 
The ASMD chart has three states. The i d l e  state indicates that the circuit is currently 
idle. When start is asserted, the FSMD moves to the op state and loads initial values to 
three registers. The t O  and tl registers are loaded with 0 and 1, which represent f i b ( 0 )  
and f i b (  l), respectively. The n register is loaded with i, the desired number of iterations. 
The main computation is iterated through the op state by three RT operations: 
0 t i t t i  + t o  
0 t o +  ti 
0 n t n  - 1 
The first two RT operations obtain a new value and store the two most recently calculated 
values in ti and to. The third RT operation decrements the iteration index. The iteration 
ended when n reaches 1 or its initial value is 0 (i.e., fib(0)). Unlike a regular flowchart, the 
operations in an ASMD block can be performed concurrently in the same clock cycle. We 
put all comparison and RT operations in the op state to reduce the computation time. Note 
that the new values of the t 1 and t O  registers are loaded at the same time when the FSMD 
exits the op state (i.e., at the next rising edge of the clock). Thus, the original value of t l ,  
not t l+tO, is stored to to. The purpose of the done state is to generate the one-clock-cycle 
done-tick signal to indicate completion of the computation. This state can be omitted if 
this status signal is not needed. 
The code follows the ASMD chart and is shown in Listing 6.4. Note that the Fibonacci 
function grows rapidly and the output signal should be wide enough to accommodate the 
desired result. 
Listing 6.4 Fibonacci number circuit 
libr ar y ieee; 
use ieee. std-logic-1164, a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  fib i s  
5 
port ( 
clk, reset: in std-logic; 
start : in std-logic; 
i : in std-logic-vector (4 downto 0) ; 
ready, done-tick: out std-logic; 
10 
f :  out std-logic-vector ( 1 9  downto 0 )  
) ;  
end f i b ;  
a r c h i t e c t u r e  arch of fib i s  
15 
type state-type i s  (idle,op,done); 
s i g n a l  state-reg , state-next : state-type; 
s i g n a l  to-reg , to-next : unsigned (19 downto 0 )  ; 
s i g n a l  tl-reg, tl-next : unsigned(l9 downto 0 )  ; 
s i g n a l  n-reg , n-next : unsigned (4 downto 0) ; 
-- f s m d  s t a t e  and d a t a  r e g i s t e r s  
process (clk, reset) 
begin 
20 begin 
i f r e s e t = ’ l ’  then 
25 
state-reg <= idle; 
to-reg <= ( o t h e r s = > ’ O ’ ) ;  

DESIGN EXAMPLES 
143 
30 
t i - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
n - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
t 0 - r e g  <= t o - n e x t ;  
t l - r e g  <= t l - n e x t ;  
n - r e g  <= n - n e x t ;  
e I s i f ( c l k  ’ e v e n t  and c l k =  ’ 1 ’ ) then 
end i f  ; 
35 
end p r o c e s s ;  
-- f s m d  n e x t - s t a t e  
l o g i c  
process ( s t a t e - r e g  , n - r e g  , t o - r e g  , t l - r e g ,  s t a r t  , i n - n e x t )  
40 
45 
begin 
r e a d y  < = ’ O ’ ;  
d o n e - t i c k  
<= ’ 0 ’ ;  
s t a t e - n e x t  
<= s t a  
t o - n e x t  
<= t o - r e g  
t l - n e x t  <= t l - r e g  
n-next 
<= n - r e g ;  
case s t a t e - r e g  i s  
when i d l e  => 
e - r e g  ; 
50 
55 
M1 
65 
r e a d y  <= ’ 1 ’ ;  
if s t a r t = ’ l ’  then 
t o - n e x t  
<= ( o t h e r s = > ’ O ’ ) ;  
t i - n e x t  <= ( 0 = > ’ 1 ’ ,  o t h e r s = > ’ O ’ ) ;  
n - n e x t  <= u n s i g n e d ( i ) ;  
s t a t e - n e x t  <= o p ;  
end if ; 
when op => 
i f  n-reg=O then 
t i - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - n e x t  <= d o n e ;  
s t a t e - n e x t  
<= d o n e ;  
t l - n e x t  <= t l - r e g  + t o - r e g ;  
t o - n e x t  
<= t l - r e g ;  
n-next 
<= n - r e g  - 1; 
e l s i f  n - r e g = l  then 
e l s e  
end if ; 
when done => 
d o n e - t i c k  
<= ’ 1 ’ ;  
s t a t e - n e x t  <= i d l e ;  
end c a s e ;  
end p r o c e s s ;  
f 
<= std-logic-vector(tl-reg); 
70 
-- o u t p u t  
end a r c h ;  
6.3.2 Division circuit 
Because of complexity, the division operator cannot be synthesized automatically. We use 
an FSMD to implement the long-division algorithm in this subsection. The algorithm is 
illustrated by the division of two 4-bit unsigned integers in Figure 6.10. The algorithm can 

144 
FSMD 
rh 
divisor 
0 0 11 0 - 
quotient 
0 0 1 0 1 0 0 0 0 1 10 1 - 
dividend 
0000 
0001 
0000 
0011 
rI 
Figure 6.10 Long division of two 4-bit unsigned integers. 
Figure 6.11 Sketch of division circuit’s data path. 
be summarized as follows: 
1. Double the dividend width by appending 0’s in front and align the divisor to the 
leftmost bit of the extended dividend. 
2. If the corresponding dividend bits are greater than or equal to the divisor, subtract the 
divisor from the dividend bits and make the corresponding quotient bit 1. Otherwise, 
keep the original dividend bits and make the quotient bit 0. 
3. Append one additional dividend bit to the previous result and shift the divisor to the 
right one position. 
4. Repeat steps 2 and 3 until all dividend bits are used. 
The sketch of the data path is shown in Figure 6.11. Initially, the divisor is stored in the 
d register and the extended dividend is stored in the rh and rl registers. In each iteration, 
the rh and rl registers are shifted to the left one position. This corresponds to shifting the 
divisor to the right of the previous algorithm. We can then compare rh and d and perform 
subtraction if r h  is greater than or equal to d. When r h  and rl are shifted to the left, the 
rightmost bit of rl becomes available. It can be used to store the current quotient bit. After 

DESIGN EXAMPLES 
145 
we iterate through all dividend bits, the result of the last subtraction is stored in r h  and 
becomes the remainder of the division, and all quotients are shifted into rl. 
The ASMD chart of the division circuit is somewhat similar to that of the previous 
Fibonacci circuit. The FSMD consists of four states, idle, op, l a s t ,  and done. To make 
the code clear, we extract the compare and subtract circuit to separate code segments. The 
main computation is performed in the op state, in which the dividend bits and divisor are 
compared and subtracted and then shifted left 1 bit. Note that the remainder should not be 
shifted in the last iteration. We create a separate state, last, to accommodate this special 
requirement. As in the preceding example, the purpose of the done state is to generate a 
one-clock-cycle done-t ick signal to indicate completion of the computation. The code is 
shown in Listing 6.5. 
Listing 6.5 Division circuit 
library i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
use i e e e .  n u m e r i c - s t d .  a l l  ; 
e n t i t y  d i v  i s  
5 
generic ( 
W : 
C B I T :  i n t e g e r  : = 4  
-- CBIT=logZ (W)+l 
i n t e g e r  : = 8  ; 
1 ;  
port ( 
10 
c l k ,  r e s e t :  in s t d - l o g i c ;  
s t a r t  : in s t d - l o g i c ;  
d v s r  , d v n d :  in s t d - l o g i c - v e c t o r  (W-1 downto 0 )  ; 
r e a d y ,  d o n e - t i c k :  out s t d - l o g i c  ; 
q u o ,  rmd: out s t d - l o g i c - v e c t o r  (W-1 downto 0) 
15 
) ;  
end d i v ;  
a r c h i t e c t u r e  a r c h  of d i v  i s  
type s t a t e - t y p e  i s  ( i d l e , o p , l a s t  , d o n e ) ;  
s i g n a l  r h - r e g  , r h - n e x t  : unsigned(W-1 downto 0) ; 
s i g n a l  r l - r e g  , r l - n e x t  : s t d - l o g i c - v e c t o r  (W-1 downto 0) ; 
s i g n a l  r h - t m p :  unsigned(W-1 downto 0) ; 
s i g n a l  d - r e g  , d - n e x t  : unsigned(W-1 downto 0 )  ; 
s i g n a l  q - b i t  : s t d - l o g i c ;  
-- f s m d  s t a t e  and d a t a  r e g i s t e r s  
process ( c l k ,  r e s e t )  
x 
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : s t a t e - t y p e ;  
25 
s i g n a l  n - r e g  , n - n e x t  : unsigned(CB1T-1 downto 0) ; 
begin 
30 
begin 
i f  r e s e t = ’ l ’  then 
s t a t e - r e g  <= i d l e ;  
r h - r e g  <= ( o t h e r s = >  ’ 0  ’ ) ;  
r l - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
d - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
n - r e g  <= ( o t h e r s = >  ’ 0  ’ )  ; 
s t a t e - r e g  <= s t a t e - n e x t ;  
r h - r e g  <= r h - n e x t ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 

146 
FSMD 
40 
r l - r e g  <= r l - n e x t ;  
d - r e g  <= d - n e x t ;  
n - r e g  <= n - n e x t ;  
end i f  ; 
end p r o c e s s ;  
-- f s m d  n e x t - s t a t e  
l o g i c  and d a t a  p a t h  l o g i c  
process ( s t a t e - r e g  , n - r e g  , r h - r e g  , r l - r e g  , d - r e g ,  
s t a r t ,  d v s r  , dvnd , q - b i t  , rh-tmp , n - n e x t )  
begin 
45 
50 
r e a d y  < = ’ O ’ ;  
d o n e - t i c k  <= ’ 0 ’ ;  
s t a t e - n e x t  <= s t a t e - r e g ;  
r h - n e x t  
<= r h - r e g ;  
r l - n e x t  <= r l - r e g ;  
55 
60 
65 
70 
75 
80 
85 
90 
d-next <= d - r e g ;  
n-next <= n - r e g ;  
case s t a t e - r e g  i s  
when i d l e  => 
r e a d y  <= ’1’; 
i f  s t a r t = ’ l ’  then 
r h - n e x t  
<= ( o t h e r s = > ’ O ’ ) ;  
r l - n e x t  <= d v n d ;  
__ d i v i d e n d  
d-next <= u n s i g n e d ( d v s r 1  ; 
__ d i v i s o r  
n - n e x t  <= t o - u n s i g n e d ( W + l ,  CBIT); -- i n d e x  
s t a t e - n e x t  <= o p ;  
end i f  ; 
when op => 
__ s h i f t  rh and r l  l e f l  
r l - n e x t  <= r l - r e g ( W - 2  downto 0 )  & q - b i t ;  
r h - n e x t  
<= rh-tmp(W-2 downto 0 )  & r l - r e g ( W - 1 ) ;  
--decrease 
i n d e x  
n-next <= n - r e g  - 1; 
i f  ( n - n e x t = l )  then 
end if ; 
r l - n e x t  
<= r l - r e g ( W - 2  downto 0 )  & q - b i t ;  
r h - n e x t  
<= r h - t m p ;  
s t a t e - n e x t  <= d o n e ;  
s t a t e - n e x t  <= i d l e ;  
d o n e - t i c k  <= ’ 1 ’ ;  
s t a t e - n e x t  <= l a s t ;  
when l a s t  => -- l a s t  i t e r a t i o n  
when done => 
end c a s e ;  
end p r o c e s s ;  
__ compare and s u b t r a c t  
process ( r h - r e g  , d - r e g )  
begin 
i f  r h - r e g  
>= d - r e g  then 
rh-tmp <= r h - r e g  - d - r e g ;  
q - b i t  <= ’ 1 ’ ;  
e l s e  

DESIGN EXAMPLES 
147 
rh-tmp <= rh-reg; 
q-bit <= ' 0 ' ;  
9 F  
end i f  ; 
end p r o c e s s ;  
__ o u t p u t  
quo <= rl-reg; 
100 
rmd <= std-logic-vector (rh-reg) ; 
end arch; 
6.3.3 Binary-to-BCD conversion circuit 
We discussed the BCD format in Section 4.5.2. In this format, a decimal number is rep- 
resented as a sequence of 4-bit BCD digits. A binary-to-BCD conversion circuit converts 
a binary number to the BCD format. For example, the binary number "0010 0000 0000" 
becomes "0101 0001 0010" (i.e., 51210) after conversion. 
The binary-to-BCD conversion can be processed by a special BCD shift register, which 
is divided into 4-bit groups internally, each representing a BCD digit. Shifting a BCD 
sequence to the left requires adjustment if a BCD digit is greater than 910 after shifting. 
For example, if a BCD sequence is "0001 01 11" (i.e., 1710), it should become "001 1 0100" 
(i.e., 3410) rather than "0010 11 10". The adjustment requires subtracting 1010 (i.e., IllOlO") 
from the right BCD digit and adding 1 (which can be considered as a carry-out) to the next 
BCD digit. Note that subtracting 1010 is equivalent to adding 610 for a4-bit binary number. 
Thus, the foregoing adjustment can also be achieved by adding 610 to the right BCD digit. 
The carry-out bit is generated automatically in this process. 
In the actual implementation, it is more efficient to first perform the necessary adjustment 
on a BCD digit and then shift. We can check whether a BCD digit is greater than 410 and, 
if this is the case, add 310 to the digit. After all the BCD digits are corrected, we can then 
shift the entire register to the left one position. A binary-to-BCD conversion circuit can 
be constructed by shifting the binary input to a BCD shift register bit by bit, from MSB to 
LSB . 
1. 
2. 
3. 
[ts operation can be summarized as follows: 
For each 4-bit BCD digit in a BCD shift register, check whether the digit is greater 
than 4. If this is the case, add 310 to the digit. 
Shift the entire BCD register left one position and shift in the MSB of the input binary 
sequence to the LSB of the BCD register. 
Repeat steps 1 and 2 until all input bits are used. 
The conversion process of a 7-bit binary input, "1 11 11 11" (i.e., 12710), is demonstrated in 
Table 6.1. 
The code of a 13-bit conversion circuit is shown in Listing 6.6. It uses a simple FSMD to 
control the overall operation. When the start signal is asserted, the binary input is stored 
into the p2s register. The FSM then iterates through the 13 bits, similar to the process 
described in previous examples. Four adjustment circuits are used to correct the four BCD 
digits. For clarity, they are isolated from the next-state logic and described in a separate 
code segment. 
Listing 6.6 
Binary-to-BCD conversion circuit 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 

148 
FSMD 
Table 6.1 Binary-to-BCD conversion example 
Special BCD shift register 
Operation 
Binary 
BCD 
BCD 
BCU 
input 
digit 2 
digit 1 
digit 0 
Initial 
Bit 6 
no adjustment 
111 1111 
shift left 1 bit 
1 11 1111 
(1 10) 
(310) 
Bit 5 
no adjustment 
shift left 1 bit 
11 1 1111 
Bit 4 
no adjustment 
shift left 1 bit 
111 1111 
(710) 
Bit 3 
BCD digit 0 adjustment 
1 0 1 0  
Bit 2 
BCD digit 0 adjustment 
1 
1 0 0 0  
shift left 1 bit 
1 
0 1 0 1  111 
(110) 
(510) 
(310) 
(110) 
shift left 1 bit 
11 
0 0 0 1  11 
Bit 1 
no adjustment 
shift left 1 bit 
1 1 0  
0 0 1 1  1 
(610) 
(310) 
Bit 0 
BCD digit 1 adjustment 
1 0 0 1  
0 0 1 1  
shift left 1 bit 
1 
0010 
0 1 1 1  
(110) 
(210) 
(710) 
e n t i t y  bin2bcd i s  
5 
p o r t (  
clk: in std-logic; 
reset : in std-logic; 
start : in std-logic ; 
bin: in std-logic-vector (12 downto 0) ; 
bcd3,bcd2,bcdl,bcdO: out std-logic-vect 
10 
ready, done-tick: out std-logic ; 
) ;  
end bin2bcd : 
r(3 d wnto 0) 
15 a r c h i t e c t u r e  arch of bin2bcd i s  
type state-type i s  (idle, op, done); 
s i g n a l  state-reg , state-next : state-type; 
s i g n a l  p2s_reg, p2s-next: std-logic-vector (12 downto 0 )  ; 
s i g n a l  n-reg , n-next : unsigned (3 downto 0) ; 
zo 
s i g n a l  bcd3_reg, bcd2_reg, bcdl-reg, bcd0-reg: 
unsigned (3 downto 0 )  ; 
unsigned (3 downto 0) ; 
s i g n a l  bcd3-nextt bcd2_next, bcdl-next , bcd0-next : 
s i g n a l  bcd3-tmpI bcd2_trnp, bcdl-tmp, bcd0-tmp: 

DESIGN EXAMPLES 
149 
25 
unsigned (3 downto 0) ; 
begin 
__ s t a t e  and d a t a  r e g i s t e r s  
process (clk , reset) 
begin 
30 
if reset=’l’ then 
35 
45 
state-reg <= idle; 
p2s-reg <= ( o t h e r s = > ’ O ’ ) ;  
n-reg <= ( o t h e r s = > ’ O ’ ) ;  
bcd3-reg <= ( o t h e r s = > ’ O ’ ) ;  
bcd2-reg <= ( o t h e r s = > ’ O ’ ) ;  
bcdl-reg <= ( o t h e r s = > ’ O ’ ) ;  
bcd0-reg <= ( o t h e r s = > ’ O ’ ) ;  
state-reg <= state-next; 
p2s-reg <= p2s-next ; 
n-reg <= n-next; 
bcd3-reg <= bcd3-next ; 
bcd2-reg <= bcd2-next ; 
bcdl-reg <= bcdl-next; 
bcd0-reg <= bcd0-next ; 
e 1 s i f 
(clk ’ event and clk= ’ 1 ’ 
then 
end i f  ; 
end p r o c e s s ;  
-- f s m d  n e x t - s t a t e  
l o g i c  / d a t a  p a t h  o p e r a t i o n s  
process (state-reg ,start ,p2s_reg ,n-reg ,n-next, bin, 
50 
b c d O _ r e g , b c d l - r e g , b c d 2 - r e g , b c d 3 - r e g ,  
b c d O - t m p , b c d l - t m p , b c d 2 ~ t m p , b c d 3 _ t m p )  
begin 
state-next <= state-reg; 
55 
M) 
65 
70 
75 
ready <= ’ 0 ’  ; 
done-tick <= ’ 0 ’ ;  
p2s-next <= p2s-reg; 
bcd0-next <= bcd0-reg; 
bcdl-next <= bcdl-reg; 
bcd2-next <= bcd2-reg; 
bcd3-next <= bcd3-reg; 
n-next <= n-reg; 
case state-reg i s  
when idle => 
ready <= ’ 1 ’ ;  
if start=’l’ then 
state-next <= op; 
bcd3-next <= ( o t h e r s = > ’ O ’ ) ;  
bcd2-next <= ( o t h e r s = > ’ O ’ ) ;  
bcdl-next <= ( o t h e r s = > ’ O ’ ) ;  
bcd0-next <= ( o t h e r s = > ’ O ’ ) ;  
n-next < = “ 1 1 0 1 “ ;  -- i n d e x  
p2s-next <= bin; -- i n p u t  s h i f t  r e g i s t e r  
state-next <= op; 
end if ; 
when op => 
-_ 
s h i f t  i n  b i n a r y  b i i  

150 
FSMD 
p2s-next <= p 2 s _ r e g ( l l  downto 0 )  & ' 0 ' ;  
__ s h i f t  4 BCD d i g i t s  
bcd0-next <= bcd0-tmp (2 downto 0) & p2s-reg (12) ; 
bcdl-next <= bcdl-tmp (2 downto 0) & bcd0-tmp (3) ; 
bcd2-next <= bcd2-tmp (2 downto 0) & bcdl-tmp (3) ; 
bcd3-next <= bcd3-tmp (2 downto 0) & bcd2-tmp (3) ; 
n-next <= n-reg - 1 ;  
i f  (n-next=O) then 
end i f  ; 
when done => 
state-next <= i d l e ;  
done-tick <= '1'; 
state-next <= d o n e ;  
end c a s e ;  
end p r o c e s s ;  
-- d a t a  p a t h  f u n c t i o n  u n i t s  
95 
-- f o u r  BCD a d j u s t m e n t  c i r c u i t s  
bcd0-tmp <= bcd0-reg + 3 when bcd0-reg > 4 e l s e  
bcdl-tmp <= bcdl-reg + 3 when bcdl-reg > 4 e l s e  
100 
bcd2-tmp <= bcd2-reg + 3 when bcd2-reg > 4 e l s e  
bcd3-tmp <= bcd3-reg + 3 when bcd3-reg > 4 e l s e  
bcd0-reg ; 
bcdl-reg ; 
b c d 2 - r e g ;  
b c d 3 - r e g ;  
105 
-- o u t p u t  
bcdO <= std-logic-vector(bcdO-reg); 
bcdl <= std-logic-vector(bcdl-reg); 
b c d 2  <= s t d - l o g i c - v e c t o r ( b c d 2 - r e g ) ;  
b c d 3  <= std-logic-vector(bcd3-reg); 
110 end a r c h ;  
6.3.4 Period counter 
A period counter measures the period of a periodic input waveform. One way to construct 
the circuit is to count the number of clock cycles between two rising edges of the input 
signal. Since the frequency of the system clock is known, the period of the input signal 
can be derived accordingly. For example, if the frequency of the system clock is f and the 
number of clock cycles between two rising edges is N ,  the period of the input signal is 
N *  1. 
-
f
 
The design in this subsection measures the period in milliseconds. Its ASMD chart is 
shown in Figure 6.12. The period counter takes a measurement when the start signal is 
asserted. We use a rising-edge detection circuit to generate a one-clock-cycle tick, edge, to 
indicate the rising edge of the input waveform. After start is asserted, the FSMD moves to 
the waite state to wait for the first rising edge of the input. It then moves to the count state 
when the next rising edge of the input is detected. In the count state, we use two registers 
to keep track of the time. The t register counts for 50,000 clock cycles, from 0 to 49,999, 
and then wraps around. Since the period of the system clock is 20 ns, the t register takes 
1 ms to circulate through 50,000 cycles. The p register counts in terms of milliseconds. It 

DESIGN EXAMPLES 
151 
ready <='I' 
edger1 
t=49,999 (-pT) 
P + P + l  
t t 
ttl 
T 4-h 
t=49,999 
(-3-6:) 
................................. 1 ..................... 
donetick<=l 
Figure 6.12 ASMD chart of a period counter. 

152 
FSMD 
is incremented once when the t register reaches 49,999. When the FSMD exits the count 
state, the period of the input waveform is stored in the p register and its unit is milliseconds. 
The FSMD asserts the done-tick signal in the done state, as in previous examples. 
The code follows the ASMD chart and is shown in Listing 6.7. We use a constant, 
CLKMSXOUNT, for the boundary of the millisecond counter. It can be replaced if a different 
measurement unit is desired. 
Listing 6.7 Period counter 
libr ar y i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
use i e e e  . n u m e r i c - s t d .  a l l  ; 
e n t i t y  p e r i o d - c o u n t e r  i s  
s 
p o r t (  
c l k ,  r e s e t :  in s t d - l o g i c ;  
s t a r t ,  s i :  in s t d - l o g i c ;  
r e a d y ,  d o n e - t i c k :  out s t d - l o g i c ;  
p r d :  out s t d - l o g i c - v e c t o r  ( 9  downto 0) 
10 
1 ; 
end p e r i o d - c o u n t e r ;  
a r c h i t e c t u r e  a r c h  of p e r i o d - c o u n t e r  i s  
c ons tan t CLK-MS-COUNT: i n t e g e r  : =  50000; -- 1 ms t i c k  
I S  
type s t a t e - t y p e  i s  ( i d l e ,  w a i t e ,  c o u n t ,  d o n e ) ;  
s i g n a l  s t a t e - r e g ,  s t a t e - n e x t  : s t a t e - t y p e ;  
s i g n a l  t - r e g  , t - n e x t  : u n s i g n e d  (15 downto 0 )  ; 
s i g n a l  p - r e g  , p - n e x t  : u n s i g n e d  ( 9  downto 0) ; 
s i g n a l  d e l a y - r e g  : s t d - l o g i c  ; 
20 
s i g n a l  e d g e :  s t d - l o g i c ;  
begin 
__ s t a t e  and d a t a  r e g i s t e r  
process ( c l k ,  r e s e t )  
begin 
25 
i f  r e s e t = ’ l ’  then 
s t a t e - r e g  <= i d l e ;  
t - r e g  <= ( o t h e r s = > ) O ’ ) ;  
p - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
d e l a y - r e g  <= ’ 0 ’  ; 
s t a t e - r e g  <= s t a t e - n e x t ;  
t - r e g  <= t - n e x t  ; 
p - r e g  <= p - n e x t ;  
d e l a y - r e g  <= s i ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
35 
end i f ; 
end p r o c e s s ;  
30 
__ e d g e  d e t e c t i o n  c i r c u i t  
edge <= (n ot d e l a y - r e g )  and s i ;  
-- f s m d  n e x t - s t a t e  
l o g i c  / d a t a  p a t h  o p e r a t i o n s  
process ( s t a r t ,  e d g e ,  s t a t e - r e g  , t - r e g  , t - n e x t  , p - r e g )  
begin 
40 
r e a d y  <= ’ 0 ’ ;  
45 
d o n e - t i c k  <= ’ 0 ) ;  

DESIGN EXAMPLES 
153 
s t a t e - n e x t  <= s t a t e - r e g ;  
p-next 
<= p - r e g ;  
t - n e x t  <= t - r e g ;  
case s t a t e - r e g  i s  
when i d l e  => 
r e a d y  <= ’ 1  ’ ; 
i f  ( s t a r t = ’ l ’ )  then 
end i f  ; 
i f  ( e d g e = ’ l ’ )  then 
s t a t e - n e x t  
<= w a i t e ;  
when w a i t e  => -- w a i t  for t h e  f i r s t  e d g e  
s t a t e - n e x t  <= c o u n t ;  
t - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
p-next 
<= ( o t h e r s = > ’ O ’ ) ;  
end i f  ; 
when c o u n t  => 
i f  ( e d g e = ’ l ’ )  then 
-- 2 n d  e d g e  a r r i v e d  
e l s e  -- o t h e r w i s e  c o u n t  
s t a t e - n e x t  <= d o n e ;  
i f  t - r e g  = CLK-MS-COUNT-1 then -- l m s  t i c k  
t - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
p-next 
<= p - r e g  + 1; 
t - n e x t  <= t - r e g  + 1; 
e l s e  
end i f  ; 
end i f  ; 
when done => 
d o n e - t i c k  <= ’ 1 ’ ;  
50 
60 
65 
70 
s t a t e - n e x t  <= i d l e ;  
7 5  
end c a s e ;  
end p r o c e s s ;  
p r d  <= std-logic-vector(p-reg); 
end a r c h ;  
6.3.5 Accurate low-frequency counter 
A frequency counter measures the frequency of a periodic input waveform. The common 
way to construct a frequency counter is to count the number of input pulses in a fixed amount 
of time, say, 1 second. Although this approach is fine for high-frequency input, it cannot 
measure a low-frequency signal accurately. For example, if the input is around 2 Hz, the 
measurement cannot tell whether it is 2.123 Hz or 2.567 Hz. Recall that the frequency 
is the reciprocal of the period (i.e., frequency = A). 
An alternative approach is to 
measure the period of the signal and then take the reciprocal to find the frequency. We use 
this approach to implement a low-frequency counter in this subsection. 
This design example demonstrates how to use the previously designed parts to construct 
a large system. For simplicity, we assume that the frequency of the input is between 1 and 
10 Hz (i.e., the period is between 100 and 1000 ms). The operation of this circuit includes 
three tasks: 
1. Measure the period. 
2. Find the frequency by performing a division operation. 
3. Convert the binary number to BCD format. 

154 
FSMD 
We can use the period counter, division circuit, and binary-to-BCD converter to perform 
the three tasks and create another FSM as the master control to sequence and coordinate 
the operation of the three circuits. The block diagram is shown in Figure 6.13(a), and the 
ASM chart of the master control is shown in Figure 6.13(b). The FSM uses the start and 
done-tick signals of these circuits to initialize each task and to detect completion of the 
task. The code is shown in Listing 6.8. 
Listing 6.8 Low-frequency counter 
library ieee; 
use ieee. std-logic-1164. all ; 
use ieee . numeric-std. all ; 
entity low-freq-counter is 
5 
port ( 
clk, reset: in std-logic; 
start : in std-logic; 
si: in std-logic; 
bcd3, bcd2, bcdl , bcdO : out std-logic-vector (3 downto 0 )  
10 
) ;  
end low-freq-counter; 
architecture arch of low-freq-counter is 
type state-type is (idle, count, frq, b2b); 
15 
signal state-reg, state-next : state-type; 
signal prd: std-logic-vector (9 downto 0 )  ; 
signal dvsr , dvnd, quo : std-logic-vector (19 downto 0) ; 
signal prd-start , div-start , b2b-start : std-logic; 
signal prd-done-t ick , div-done-t i ck , b2b-done-t i ck : 
20 
std-logic; 
begin ............................................... 
--______________________________________--------- 
__ component i n s t a n t i a t i o n  
-_--_-_-_--_---_-_----------------------------- 
............................................... 
__ 
25 
-- i n s t a n t i a t e  p e r i o d  c o u n t e r  
prd-count-unit: entity work.period-counter 
port map(clk=>clk, reset=>reset , start=>prd-start , si=>si, 
ready=>open, done-tick=>prd-done-tick , prd=>prd); 
__ i n s t a n t i a t e  d i v i s i o n  c i r c u i t  
generic map(W=>20, C B I T = > 5 )  
port map(clk=>clk, reset=>reset , start=>div-start , 
30 
div-unit : entity work. div 
dvsr=>dvsr , dvnd=>dvnd, quo=>quo, rmd=>open, 
ready=>open, done-tick=>div-done-tick); 
35 
-- i n s t a n t i a t e 
bin2bcd-unit : entity work. bin2bcd 
port map 
b i n a r y - to -BCD 
c o n v e r t o r 
(clk=>clk, reset=>reset , start=>b2b_start, 
bin=>quo (12 downto 0) , ready=>open, 
bcd3=>bcd3, bcd2=>bcd2, bcdl=>bcdl, bcdO=>bcdO); 
40 
d o n e _ t i c k = > b 2 b _ d o n e _ t i c k ,  
__ s i g n a l  w i d t h  e x t e n s i o n  
dvnd <= s t d ~ l o g i c ~ v e c t o r ( t o ~ u n s i g n e d ( l O O O O O 0 ,  
20)); 
dvsr <= "0000000000" & prd; 
45 

DESIGN EXAMPLES 
155 
si 
I 
start - 
main control 
FSM 
period-counter 
I 
quo 
rmd 
I 
b2b-start 1-1 
donetick 
b2b-donetick 
bcd3 bcd2 
bcdl bcdO 
(a) Top-level block diagram 
17 
prd-start <= 1 (5 
- ................................... 
div-start <= 1 
................................... 
8 
T 
b2b-start <= 1 a 
T 
................................... 
8 
t 
(b) ASM chart of main control 
Figure 6.13 Accurate low-frequency counter. 

156 
FSMD 
-- 
-- m a s t e r  FSM 
process ( c l k ,  r e s e t )  
50 
begin 
i f  r e s e t = ’ l ’  then 
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
s t a t e - r e g  <= i d l e ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
S i  
end i f ;  
end p r o c e s s ;  
65 
15 
no 
process ( s t a t e - r e g  , s t a r t ,  
prd_done-tick,div-done-tick,b2b-done-tick) 
60 
begin 
s t a t e - n e x t  <= s t a t e - r e g  ; 
p r d - s t a r t  
< = ’ O ’ ;  
d i v - s t a r t  
< = ’ O ’  ; 
b 2 b - s t a r t  
< = ’ O ’ ;  
case s t a t e - r e g  i s  
when i d l e  => 
i f  s t a r t = ’ l ’  then 
s t a t e - n e x t  <= c o u n t  ; 
p r d - s t a r t  < = ’ 1 ’ ;  
end i f  ; 
when c o u n t  => 
i f  ( p r d - d o n e - t i c k = ’ l ’ )  then 
d i v - s t a r t  < = ’ l ’ ;  
s t a t e - n e x t  <= f r q ;  
end i f  ; 
i f  ( d i v - d o n e - t i c k = ’ l ’ )  
then 
when f r q  => 
b 2 b - s t a r t  < = ’ l ’ ;  
s t a t e - n e x t  <= b 2 b ;  
end i f ;  
i f  ( b 2 b _ d o n e _ t i c k =  ’1 ’1 then 
end i f  ; 
when b2b => 
s t a t e - n e x t  <= i d l e ;  
RS 
end c a s e ;  
end p r o c e s s ;  
end a r c h ;  
6.4 
BIBLIOGRAPHIC NOTES 
The bibliographic information for this chapter is similar to that for Chapter 3. 

SUGGESTED EXPERIMENTS 
157 
6.5 SUGGESTED EXPERIMENTS 
6.5.1 Alternative debouncing circuit 
Consider the alternative debouncing circuit in Experiment 5.5.2. Redesign the circuit using 
the RT methodology: 
1. Derive the ASMD chart for the circuit. 
2. Derive the HDL code based on the ASMD chart. 
3. Replace the debouncing circuit in Section 6.2.5 with the alternative design and verify 
its operation. 
6.5.2 BCD-to-binary conversion circuit 
A BCD-to-binary conversion converts a BCD number to the equivalent binary representa- 
tion. Assume that the input is an %bit signal in BCD format (i.e., two BCD digits) and the 
output is a 7-bit signal in binary representation. Follow the procedure in Section 6.3.3 to 
design a BCD-to-binary conversion circuit: 
1. Derive the conversion algorithm and ASMD chart. 
2. Derive the HDL code based on the ASMD chart. 
3. Derive a testbench and use simulation to verify operation of the code. 
4. Synthesize the circuit, program the FPGA, and verify its operation. 
6.5.3 Fibonacci circuit with BCD I/O: design approach 1 
To make the Fibonacci circuit more user friendly, we can modify the circuit to use the BCD 
format for the input and output. Assume that the input is an &bit signal in BCD format 
(i.e., two BCD digits) and the output is displayed as four BCD digits on the seven-segment 
LED display. Furthermore, the LED will display “9999“ if the resulting Fibonacci number 
is larger than 9999 (i.e., overflow). The operation can be done in three steps: convert input 
to the binary format, compute the Fibonacci number, and convert the result back to the BCD 
format. 
The first design approach is to follow the procedure in Section 6.3.5. We first construct 
three smaller subsystems, which are the BCD-to-binary conversion circuit, Fibonacci cir- 
cuit, and binary-to-BCD conversion circuit, and then use a master FSM to control the overall 
operation. Design the circuit as follows: 
1. Implement the BCD-to-binary conversion circuit in Experiment 6.5.2. 
2. Modify the Fibonacci number circuit in Section 6.3.1 to include an output signal to 
3. Derive the top-level block diagram and the master control FSM state diagram. 
4. Derive the HDL code. 
5. Derive a testbench and use simulation to verify operation of the code. 
6. Synthesize the circuit, program the FPGA, and verify its operation. 
indicate the overflow condition. 
6.5.4 Fibonacci circuit with BCD I/O: design approach 2 
An alternative to the previous “subsystem approach” in Experiment 6.5.3 is to integrate 
the three subsystems into a single system and derive a customized FSMD for this partic- 
ular application. The approach eliminates the overhead of the control FSM and provides 
opportunities to share registers among the three tasks. Design the circuit as follows: 

158 
FSMD 
1. Redesign the circuit of Experiment 6.5.3 using one FSMD. The design should elimi- 
nate all unnecessary circuits and states, such as the various done-tick signals and the 
done states, and exploit the opportunity to share and reuse the registers in different 
steps. 
2. Derive the ASMD chart. 
3. Derive the HDL code based on the ASMD chart. 
4. Derive a testbench and use simulation to verify operation of the code. 
5. Synthesize the circuit, program the FPGA and verify its operation. 
6. Check the synthesis report and compare the number of LEs used in the two approaches. 
7. Calculate the number of clock cycles required to complete the operation in the two 
approaches. 
6.5.5 Au to-scaled low-f requency counter 
The operation of the low-frequency counter in Section 6.3.5 is very restricted. The frequency 
range of the input signal is limited between 1 and 10 Hz. It loses accuracy when the 
frequency is beyond this range. Recall that the accuracy of this frequency counter depends 
on the accuracy of the period counter of Section 6.3.5, which counts in terms of millisecond 
ticks. We can modify the t counter to generate a microsecond tick (i.e., counting from 0 
to 49) and increase the accuracy 1000-fold. This allows the range of the frequency counter 
to increase to 9999 Hz and still maintain at least four-digit accuracy. 
Using a microsecond tick introduces more than four accuracy digits for low-frequency 
input, and the number must be shifted and truncated to be displayed on the seven-segment 
LED. An auto-scaled low-frequency counter performs the adjustment automatically, dis- 
plays the four most significant digits, and places a decimal point in the proper place. For 
example, according to their range, the frequency measurements will be shown as 1.234", 
"12.34", "123.4", or "1234". 
The auto-scaled low-frequency counter needs an additional BCD adjustment circuit. It 
first checks whether the most significant BCD digit (i.e., the four MSBs) of a BCD sequence 
is zero. If this is the case, the circuit shifts the BCD sequence to the left four positions and 
increments the decimal point counter. The operation is repeated until the most significant 
BCD digit is not "0000". 
The complete auto-scaled low-frequency counter can be implemented as follows: 
1. Modify the period counter to use the microsecond tick. 
2. Extend the size of the binary-to-BCD conversion circuit. 
3. Derive the ASMD chart for the BCD adjustment circuit and the HDL code. 
4. Modify the control FSM to include the BCD adjustment in the last step. 
5. Design a simple decoding circuit that uses the decimal point counter's output to 
activate the desired decimal point of the seven-segment LED display. 
6. Derive a testbench and use simulation to verify operation of the code. 
7. Synthesize the circuit, program the FPGA, and verify its operation. 
6.5.6 Reaction timer 
Eye-hand coordination is the ability of the eyes and hands to work together to perform a 
task. A reaction timer circuit measures how fast a human hand can respond after a person 
sees a visual stimulus. This circuit operates as follows: 

SUGGESTED EXPERIMENTS 
159 
1. 
2. 
3. 
4. 
5. 
6. 
7. 
The circuit has three input pushbuttons, corresponding to the clear, s t a r t ,  and stop 
signals. It uses a single discrete LED as the visual stimulus and displays relevant 
information on the seven-segment LED display. 
A user pushes the c l e a r  button to force the circuit returning to the initial state, in 
which the seven-segment LED shows a welcome message, "HI," and the stimulus 
LED is off. 
When ready, the user pushes the start button to initiate the test. The seven-segment 
LED goes off. 
After a random interval between 2 and 15 seconds, the stimulus LED goes on and 
the timer starts to count upward. The timer increases every millisecond and its value 
is displayed in the format of "0.000" second on the seven-segment LED. 
After the stimulus LED goes on, the user should try to push the stop button as soon 
as possible. The timer pauses counting once the s t o p  button is asserted. The seven- 
segment LED shows the reaction time. It should be around 0.15 to 0.30 second for 
most people. 
If the stop button is not pushed, the timer stops after 1 second and displays "1.000". 
If the s t o p  button is pushed before the stimulus LED goes on, the circuit displays 
"9.999" on the seven-segment LED and stops. 
Design the circuit as follows: 
1. Derive the ASMD chart. 
2. Derive the HDL code based on the ASMD chart. 
3. Synthesize the circuit, program the FPGA, and verify its operation. 
6.5.7 Babbage difference engine emulation circuit 
The Babbage difference engine is a mechanical digital computation device designed to 
tabulate a polynomial function. It was proposed by Charles Babbage, an English mathe- 
matician, in the nineteenth century. The engine is based on Newton's method of differences 
and avoids the need of multiplication. For example, consider a second-order polynomial 
f(n) 
= 2n2 + 372 + 5. We can find the difference between f ( n )  and f(n - 1): 
f ( n )  - f ( n  - 1) = 4n + 1 
Assume that n is an integer and n 2 0. The f ( n )  can be defined recursively as 
This process can be repeated for the 4n + 1 expression. Let g ( n )  = 4n + 1. We can find 
the difference between g(n) and g(n - 1): 
g(n) - g(n - 1) = 4 
The g(n) can be defined recursively as 
and f ( n )  can be rewritten as 

160 
FSMD 
Note that only additions are involved in the recursive definitions of f ( n )  and g ( n ) .  
Based on the definition of the last two recursive equations, we can derive an algorithm 
to compute f(n). Two temporary registers are needed to keep track of the most recently 
calculated f (n) and g (n) , and two additions are needed to update f (n) 
and g (n) 
. Assume 
that n is a 6-bit input and interpreted as an unsigned integer. Design this circuit using the 
RT methodology: 
1. Derive the ASMD chart. 
2. Derive the HDL code based on the ASMD chart. 
3. Derive a testbench and use simulation to verify operation of the code. 
4. Synthesize the circuit, program the FPGA, and verify its operation. 
5. Let h(n) = n3 + 2n2 + 2n + 1. Use the method above to find the recursive rep- 
resentation of h(n) (note that three levels of recursive equations are needed for a 
three-order polynomial). Repeat steps 1 to 4. 

PART II 
I/O MODULES 

This Page Intentionally Left Blank

CHAPTER 7 
UART 
7.1 INTRODUCTION 
Universal asynchronous receiver and transmitter (UART) is a circuit that sends parallel data 
through a serial line. UARTs are frequently used in conjunction with the EIA (Electronic 
Industries Alliance) RS-232 standard, which specifies the electrical, mechanical, functional, 
and procedural characteristics of two data communication equipment. Because the voltage 
level defined in RS-232 is different from that of FPGA I/O, a voltage converter chip is 
needed between a serial port and an FF’GA’s IiO pins. 
The S3 board has a RS-232 port with the standard nine-pin connector. The board contains 
the necessary voltage converter chip and configures the various RS-232’s control signals 
to automatically generate acknowledgment for the PC’s serial port. A standard straight- 
through serial cable can be used to connect the S3 board and PC’s serial port. The S3 board 
basically handles the RS-232 standard and we only need to concentrate on the design of the 
UART circuit. 
A UART includes a transmitter and a receiver. The transmitter is essentially a special 
shift register that loads data in parallel and then shifts it out bit by bit at a specific rate. The 
receiver, on the other hand, shifts in data bit by bit and then reassembles the data. The serial 
line is ’ 1 ’ when it is idle. The transmission starts with a start bit, which is ’O’, followed by 
data bits and an optional parity bit, and ends with stop bits, which are ’1’. The number of 
data bits can be 6,7, or 8. The optional parity bit is used for error detection. For odd parity, 
it is set to ’0’ when the data bits have an odd number of 1’s. For even parity, it is set to ’0’ 
when the data bits have an even number of 1’s. The number of stop bits can be 1, 1.5, or 2. 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
163 

164 
UART 
idle 
stop bit 
4 G:i*:x 
d2 x d3 x d4 
d5 
d6 1 d7 y 
Figure 7.1 Transmission of a byte. 
The transmission with 8 data bits, no parity, and 1 stop bit is shown in Figure 7.1. Note that 
the LSB of the data word is transmitted first. 
No clock information is conveyed through the serial line. Before the transmission starts, 
the transmitter and receiver must agree on a set of parameters in advance, which include the 
baud rate (i.e., number of bits per second), the number of data bits and stop bits, and use of 
the parity bit. The commonly used baud rates are 2400,4800,9600, and 19,200 bauds. 
We illustrate the design of the receiving and transmitting subsystems in the following 
sections. The design is customized for a UART with a 19,200 baud rate, 8 data bits, 1 stop 
bit, and no parity bit. 
7.2 UART RECEIVING SUBSYSTEM 
Since no clock information is conveyed from the transmitted signal, the receiver can retrieve 
the data bits only by using the predetermined parameters. We use an oversampling scheme 
to estimate the middle points of transmitted bits and then retrieve them at these points 
accordingly. 
7.2.1 Oversampling procedure 
The most commonly used sampling rate is 16 times the baud rate, which means that each 
serial bit is sampled 16 times. Assume that the communication uses N data bits and M 
stop bits. The oversampling scheme works as follows: 
1. Wait until the incoming signal becomes 'O', the beginning of the start bit, and then 
start the sampling tick counter. 
2. When the counter reaches 7, the incoming signal reaches the middle point of the start 
bit. Clear the counter to 0 and restart. 
3. When the counter reaches 15, the incoming signal progresses for one bit and reaches 
the middle of the first data bit. Retrieve its value, shift it into a register, and restart 
the counter. 
4. Repeat step 3 N-1 more times to retrieve the remaining data bits. 
5. If the optional parity bit is used, repeat step 3 one time to obtain the parity bit. 
6. Repeat step 3 M more times to obtain the stop bits. 
The oversampling scheme basically performs the function of a clock signal. Instead of 
using the rising edge to indicate when the input signal is valid, it utilizes sampling ticks to 
estimate the middle point of each bit. While the receiver has no information about the exact 
onset time of the start bit, the estimation can be off by at most &. The subsequent data bit 
retrievals are off by at most 
from the middle point as well. Because of the oversampling, 
the baud rate can only be a small fraction of the system clock rate, and thus this scheme is 
not appropriate for a high data rate. 

UART RECEIVING SUBSYSTEM 
165 
Figure 7.2 Conceptual block diagram of a UART receiving subsystem. 
The conceptual block diagram of a UART receiving subsystem is shown in Figure 7.2. 
UART receiver: the circuit to obtain the data word via oversampling 
0 Baud rate generator: the circuit to generate the sampling ticks 
0 Znterjiace circuit: the circuit that provides buffer and status between the UART re- 
It consists of three major components: 
ceiver and the system that uses the UART 
7.2.2 Baud rate generator 
The baud rate generator generates a sampling signal whose frequency is exactly 16 times 
the UART’s designated baud rate. To avoid creating a new clock domain and violating the 
synchronous design principle, the sampling signal should function as enable ticks rather 
than the clock signal to the UART receiver, as discussed in Section 4.3.2. 
For the 19,200 baud rate, the sampling rate has to be 307,200 (i.e., 19,200*16) ticks per 
second. Since the system clock rate is 50 MHz, the baud rate generator needs a mod-I63 
(i.e., - 
::;a$,) 
counter, in which the one-clock-cycle tick is asserted once every 163 clock 
cycles. The parameterized mod-m counter discussed in Section 4.3.2 can be used for this 
purpose by setting the M generic to 163. 
7.2.3 UART receiver 
With an understanding of the oversampling procedure, we can derive the ASMD chart 
accordingly, as shown in Figure 7.3. To accommodate future modification, two constants 
are used in the description. The D-BIT constant indicates the number of data bits, and the 
SB-TICK constant indicates the number of ticks needed for the stop bits, which is 16, 24, 
and 32 for 1, 1.5, and 2 stop bits, respectively. D B I T  and SB-TICK are assigned to 8 and 
16 in this design. 
The chart follows the steps discussed in Section 7.2.1 and includes three major states, 
start, data, and stop, which represent the processing of the start bit, data bits, and stop 
bit. The s - t i c k  signal is the enable tick from the baud rate generator and there are 16 ticks 
in a bit interval. Note that the FSMD stays in the same state unless the s-tick signal is 
asserted. There are two counters, represented by the s and n registers. The s register keeps 
track of the number of sampling ticks and counts to 7 in the start state, to 15 in the data 
state, and to SB-TICK in the s t o p  state. The n register keeps track of the number of data 
bits received in the data state. The retrieved bits are shifted into and reassembled in the b 

166 
UART 
....................... rg 
T 
........................ 
-- 
9 
....................................... 
L F 9  
rF-<-> 
(-I(-) 
......................................... 
I 
I 
I 
T 
................................ 
LFg 
i 
(-)(-) rx-donefick <=I 
........... 
.................... 
t......... 
1 
I 
Figure 7.3 ASMD chart of a UART receiver. 

UART RECEIVING SUBSYSTEM 
167 
register. A status signal, rx-done-tick, is included. It is asserted for one clock cycle after 
the receiving process is completed. The corresponding code is shown in Listing 7.1. 
Listing 7.1 UART receiver 
library i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
use i e e e .  n u m e r i c - s t d .  a l l  ; 
e n t i t y  u a r t - r x  i s  
s 
g e n e r i c (  
DBIT : i n t e g e r  : = 8 ;  
-- # d a t a  b i t s  
SB-TICK: i n t e g e r : = 1 6  -- # t i c k s  f o r  s t o p  b i t s  
) ;  
port ( 
10 
c l k ,  r e s e t :  in s t d - l o g i c ;  
r x :  in s t d - l o g i c ;  
s - t i c k :  in s t d - l o g i c ;  
r x - d o n e - t i c k :  
out s t d - l o g i c  ; 
d o u t :  out s t d - l o g i c - v e c t o r  ( 7  downto 0) 
15 
) ; 
end u a r t - r x  ; 
10 
15 
45 
a r c h i t e c t u r e  a r c h  of u a r t - r x  i s  
type s t a t e - t y p e  i s  ( i d l e ,  s t a r t ,  d a t a ,  s t o p ) ;  
s i g n a l  s - r e g  , s - n e x t  : u n s i g n e d  ( 3  downto 0) ; 
s i g n a l  n-reg , n-next : u n s i g n e d  ( 2  downto 0) ; 
s i g n a l  b-reg , b-next : s t d - l o g i c - v e c t o r  ( 7  downto 0) ; 
x 
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : s t a t e - t y p e ;  
begin 
zs 
-- FSMD s t a t e  & d a t a  r e g i s t e r s  
process ( c l k  , r e s e t )  
begin 
i f  r e s e t = ’ l ’  then 
s t a t e - r e g  <= i d l e ;  
s - r e g  <= ( o t h e r s = >  ’ 0  J, 
; 
n - r e g  <= ( o t h e r s = >  J O ’ ) ;  
b - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
s - r e g  <= s - n e x t ;  
n - r e g  <= n - n e x t ;  
b - r e g  <= b - n e x t ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end if ; 
end p r o c e s s ;  
process ( s t a t e - r e g  , s - r e g  , n - r e g  , b - r e g ,  ~ - t i c k  
, r x )  
begin 
40 
-- n e x t - s t a t e  
l o g i c  & d a t a  p a t h  f u n c t i o n a l  u n i t s / r o u t i n g  
s t a t e - n e x t  <= s t a t e - r e g ;  
s - n e x t  <= s - r e g ;  
n-next <= n - r e g ;  
b-next <= b - r e g ;  
r x - d o n e - t i c k  
< = ’ O ’ ;  
case s t a t e - r e g  i s  
when i d l e  => 

168 
UART 
50 
55 
65 
70 
75 
i f  r x = ’ O ’  then 
s t a t e - n e x t  <= s t a r t ;  
s - n e x t  <= ( o t h e r s = >  ’ 0  ’ 1  ; 
end i f ;  
when s t a r t  => 
i f  ( s - t i c k  = ’1’) then 
i f  s _ r e g = 7  then 
s t a t e - n e x t  <= d a t a ;  
s - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
n-next 
<= ( o t h e r s = > ’ O ’ ) ;  
s - n e x t  <= s - r e g  + 1 ;  
e l s e  
end i f  ; 
end i f  ; 
when d a t a  => 
i f  ( s - t i c k  = ’1’) then 
i f  s _ r e g = 1 5  then 
s - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
b - n e x t  
<= r x  & b - r e g ( 7  downto 1) ; 
i f  n - r e g =  (DBIT -1) then 
e l s e  
end i f ;  
s - n e x t  <= s - r e g  + 1; 
s t a t e - n e x t  <= s t o p  ; 
n - n e x t  
<= n - r e g  + 1; 
e l s e  
end i f  ; 
end i f  ; 
when s t o p  => 
i f  ( s - t i c k  = ’1’) then 
i f  s-reg=(SB-TICK-l) 
s t a t e - n e x t  
<= i d l e  
r x - d o n e - t i c k  
<= ’ 1 ’ 
e l s e  
s - n e x t  <= s - r e g  + 1; 
85 
end i f ;  
end c a s e ;  
end p r o c e s s ;  
d o u t  <= b - r e g ;  
end i f  ; 
90 end a r c h ;  
hen 
7.2.4 Interface circuit 
In a large system, a UART is usually a peripheral circuit for serial data transfer. The 
main system checks its status periodically to retrieve and process the received word. The 
receiver’s interface circuit has two functions. First, it provides a mechanism to signal the 
availability of a new word and to prevent the received word from being retrieved multiple 
times. Second, it can provide buffer space between the receiver and the main system. There 
are three commonly used schemes: 
AflagFF 

UART RECEIVING SUBSYSTEM 
169 
A flag FF and a one-word buffer 
0 A FIFO buffer 
Note that the UART receiver asserts the rx-ready-tick signal one clock cycle after a data 
word is received. 
The first scheme uses a j a g  FF to keep track of whether a new data word is available. 
The FF has two input signals. One is set-f lag, which sets the flag FF to ’l’, and the other 
is clr-f lag, which clears the flag FF to ’0’. The rx-ready-tick signal is connected to 
the set-flag signal and sets the flag when a new data word arrives. The main system 
checks the output of the flag FF to see whether a new data word is available. It asserts the 
clr-f lag signal one clock cycle after retrieving the word. The top-level block diagram is 
shown in Figure 7.4(a). To be consistent with other schemes, the flag FF’s output is inverted 
to generate the final rx-empty signal, which indicates that no new word is available. In 
this scheme, the main system retrieves the data word directly from the shift register of the 
UART receiver and does not provide any additional buffer space. If the remote system 
initiates a new transmission before the main system consumes the old data word (i.e., the 
flag FF is still asserted), the old word will be overwritten, an error known as data overrun. 
To provide some cushion, a one-word buffer can be added, as shown in Figure 7.4(b). 
When the rx-ready-tick signal is asserted, the received word is loaded to the buffer 
and the flag FF is set as well. The receiver can continue the operation without destroying 
the content of the last received word. Data overrun will not occur as long as the main 
system retrieves the word before a new word arrives. The code for this scheme is shown in 
Listing 7.2. 
Listing 7.2 Interface with a flag FF and buffer 
libr ar y ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  flag-buf i s  
ge ne ri c (W: integer : = 8 )  ; 
5 
p o r t (  
clk, reset: in std-logic; 
clr-f l a g ,  set-flag : in std-logic ; 
din: in std-logic-vector (W-1 downto 0) ; 
dout : out std-logic-vector ( W - I  
downto 0 )  ; 
10 
f l a g :  out std-logic 
1 ;  
end f lag-buf ; 
a r c h i t e c t u r e  arch of flag-buf i s  
1s 
s i g n a l  buf-reg, buf-next: std-logic-vector (W-1 downto 0 )  ; 
s i g n a l  f lag-reg , f lag-next : std-logic ; 
-- FF & r e g i s t e r  
process (clk, reset) 
begin 
ZD 
begin 
i f  r e s e t = ’ l ’  then 
buf-reg <= ( o t h e r s = > ’ O ’ ) ;  
flag-reg <= ’ 0 ’ ;  
buf -reg <= buf -next ; 
flag-reg <= flag-next; 
e l s i f  (clk’event and clk=’l’) then 
end i f ; 
25 

170 
UART 
Figure 7.4 
Interface circuit of a UART receiving subsystem. 

UART TRANSMITTING SUBSYSTEM 
171 
35 
end p r o c e s s ;  
__ n e x t  --s t a t  e 
1 o g  i c  
process ( b u f - r e g  , f l a g - r e g  , s e t - f l a g  , c l r - f l a g  , d i n )  
begin 
30 
b u f - n e x t  
<= b u f - r e g ;  
f l a g - n e x t  <= f l a g - r e g ;  
i f  ( s e t - f l a g = ’ l ’ )  then 
b u f - n e x t  
<= d i n ;  
f l a g - n e x t  <= ’1’; 
f l a g - n e x t  <= ’ 0 ’ ;  
e l s  i f  ( c l r - f  l a g =  ’ 1 ’ )  then 
end i f  ; 
40 
end p r o c e s s ;  
__ o u t p u t  l o g i c  
dout <= b u f - r e g ;  
f l a g  <= f l a g - r e g ;  
end a r c h ;  
The third scheme uses a FIFO buffer discussed in Section 4.5.3. The FIFO buffer provides 
more buffering space and further reduces the chance of data overrun. We can adjust the 
desired number of words in FIFO to accommodate the processing need of the main system. 
The detailed block diagram is shown in Figure 7.4(c). 
The rx-ready-tick signal is connected to the w r  signal of the FIFO. When a new data 
word is received, the w r  signal is asserted one clock cycle and the corresponding data is 
written to the FIFO. The main system obtains the data from FIFO’s read port. After retrieving 
a word, it asserts the r d  signal of the FIFO one clock cycle to remove the corresponding 
item. The empty signal of the FIFO can be used to indicate whether any received data word 
is available. A data-overrun error occurs when a new data word arrives and the FIFO is full. 
7.3 UART TRANSMITTING SUBSYSTEM 
The organization of a UART transmitting subsystem is similar to that of the receiving 
subsystem. It consists of a UART transmitter, baud rate generator, and interface circuit. 
The interface circuit is similar to that of the receiving subsystem except that the main system 
sets the flag FF or writes the FIFO buffer, and the UART transmitter clears the flag FF or 
reads the FIFO buffer. 
The UART transmitter is essentially a shift register that shifts out data bits at a specific 
rate. The rate can be controlled by one-clock-cycle enable ticks generated by the baud 
rate generator. Because no oversampling is involved, the frequency of the ticks is 16 times 
slower than that of the UART receiver. Instead of introducing a new counter, the UART 
transmitter usually shares the baud rate generator of the UART receiver and uses an internal 
counter to keep track of the number of enable ticks. A bit is shifted out every 16 enable 
ticks. 
The ASMD chart of the UART transmitter is similar to that of the UART receiver. 
After assertion of the tx-start signal, the FSMD loads the data word and then gradually 
progresses through the start, data, and stop states to shift out the corresponding bits. 
It signals completion by asserting the tx-done-tick signal for one clock cycle. A 1-bit 
buffer, tx-reg, is used to filter out any potential glitch. The corresponding code is shown 
in Listing 1.3. 

172 
UART 
Listing 7.3 UART transmitter 
lib rary ieee; 
use i e e e . s t d - l o g i c - l l 6 4 . a l l ;  
use ieee . numeric-std. a l l  ; 
e n t i t y  uart-tx i s  
5 
g e n e r i c (  
DBIT : integer : =8 ; 
-- # d a t a  b i t s  
SB-TICK: integer:=16 -- # t i c k s  f o r  s t o p  b i t s  
1 ;  
port ( 
10 
clk, reset: in std-logic; 
tx-start : in std-logic; 
s-tick: in std-logic ; 
din: in std-logic-vector ( 7  downto 0) ; 
tx-done-tick: out std-logic; 
15 
tx: out std-logic 
) ;  
end uart-tx ; 
35 
40 
50 
a r c h i t e c t u r e  arch of uart-tx i s  
20 
type state-type i s  (idle, start, data, stop); 
s i g n a l  state-reg, state-next : state-type; 
s i g n a l  s-reg , s-next : unsigned (3 downto 0) ; 
s i g n a l  n-reg , n-next : unsigned (2 downto 0) ; 
s i g n a l  b-reg , b-next : std-logic-vector (7 downto 0 )  ; 
25 
s i g n a l  tx-reg , tx-next : std-logic ; 
-- FSMD s t a t e  
C? 
d a t a  r e g i s t e r s  
process (clk, reset) 
begin 
begin 
30 
i f  reset=’l’ then 
state-reg <= idle; 
s-reg <= ( o t h e r s = > ) O ) ) ;  
n-reg <= ( o t h e r s = > ) O ’ ) ;  
b-reg <= ( o t h e r s = > ) O ’ ) ;  
tx-reg <= )l); 
state-reg <= state-next; 
s-reg <= s-next; 
n-reg <= n-next; 
b-reg <= b-next; 
tx-reg <= tx-next; 
e 1 s i f 
( clk ) event and clk= ) 1 ’ ) then 
end i f  ; 
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  & d a t a  p a t h  f u n c t i o n a l  u n i t s  / r o u t i n g  
process (state-reg , s-reg ,n-reg ,b-reg, s-tick, 
begin 
45 
tx-reg,tx-start,din) 
state-next <= state-reg; 
s-next <= s-reg; 
n-next <= n-reg; 
b-next <= b-reg; 
tx-next <= tx-reg ; 

UART TRANSMITTING SUBSYSTEM 
173 
t x - d o n e - t i c k  
<= ’ 0 ’ ;  
case s t a t e - r e g  i s  
when i d l e  => 
t x - n e x t  
<= 
1 ; 
i f  t x - s t a r t = ’ l ’  then 
s t a t e - n e x t  <= s t a r t ;  
s - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
b-next 
<= d i n ;  
end i f  ; 
when s t a r t  => 
t x - n e x t  
<= ’ 0 ’ ;  
i f  ( s - t i c k  = ’ 1 ’ )  then 
i f  s _ r e g = 1 5  then 
s t a t e - n e x t  <= d a t a ;  
s - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
n-next 
<= ( o t h e r s = > ’ O ’ ) ;  
s - n e x t  <= s - r e g  + 1; 
e l s e  
end i f  ; 
end i f ;  
when d a t a  => 
t x - n e x t  
<= b-reg (0) ; 
i f  ( s - t i c k  = Jl’) 
then 
i f  s _ r e g = 1 5  then 
s - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
b-next 
<= ‘ 0 ’  8z b - r e g ( 7  downto 1) ; 
i f  n - r e g =  ( D B I T  -1) then 
e l s e  
end i f  ; 
s - n e x t  <= s - r e g  + 1; 
s t a t e - n e x t  <= s t o p  ; 
n-next <= n - r e g  + 1; 
e l s e  
end i f ;  
end i f  ; 
when s t o p  = >  
t x - n e x t  
<= ’ 1 ’ ;  
i f  ( s - t i c k  = ’1’) then 
i f  s - r e g =  (SB-TICK -1) then 
s t a t e - n e x t  <= i d l e ;  
t x - d o n e - t i c k  
<= J l ’ ;  
s - n e x t  <= s-reg + 1 ;  
e l s e  
end i f  ; 
end i f  ; 
55 
60 
65 
70 
75 
80 
ns 
w 
95 
end c a s e ;  
end p r o c e s s ;  
100 
t x  <= t x - r e g ;  
end a r c h ;  

174 
UART 
Figure 7.5 Block diagram of a complete UART. 
7.4 OVERALL UART SYSTEM 
7.4.1 Complete UART core 
By combining the receiving and transmitting subsystems, we can construct the complete 
UART core. The top-level diagram is shown in Figure 7.5. The block diagram can be 
described by component instantiation, and the corresponding code is shown in Listing 7.4. 
10 
20 
Listing 7.4 UART top-level description 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  uart i s  
5 
g e n e r i c (  
__ D e f a u l t  s e t t i n g  : 
-- 1 9 2 0 0  b a u d ,  8 d a t a  b i t s  , 1 s t o p  b i t ,  2 ^ 2  FIFO 
DBIT : integer : =8; 
-- # d a t a  b i t s  
SB-TICK: integer:=16; -- # t i c k s  f o r  s t o p  b i t s ,  1 6 / 2 4 / 3 2  
DVSR: integer:= 163; -- baud r a t e  d i v i s o r  
DVSR-BIT: i n t e g e r : = 8 ;  -- # b i t s  of DVSR 
FIFO-W: integer:=2 
-- # a d d r  b i t s  of FIFO 
-- 
for 1 / 1 . 5 / 2  s t o p  b i t s  
-- DVSR = 5 0 M / ( 1 6 * b a u d  r a t e )  
I5 
-- # words in FIFO=2^FIFO-W 
) ;  
port ( 
clk, r e s e t :  in std-logic; 
rd-uart , wr-uart : in std-logic ; 
r x :  in std-logic; 
w-data: in std-logic-vector ( 7  downto 0 )  ; 
tx-full, rx-empty: out std-logic; 

OVERALL UART SYSTEM 
175 
r-data: out std-logic-vector ( 7  downto 0) ; 
tx: out std-logic 
25 
) ; 
end uart; 
architecture str-arch of uart is 
10 
signal rx-done-tick: std-logic; 
signal tick: std-logic ; 
signal tx-f if o-out : std-logic-vector ( 7  downto 0) ; 
signal rx-data-out : std-logic-vector ( 7  downto 0) ; 
signal tx-empty , tx-f if o-not-empty : std-logic ; 
signal tx-done-tick : std-logic ; 
baud-gen-unit: entity work.mod-m-counter(arch) 
v begin 
generic map(M=>DVSR , N=>DVSR-BIT) 
port map(clk=>clk, reset=>reset , 
q=>open , max-tick=>tick) ; 
40 
uart-rx-unit: entity work.uart-rx(arch) 
generic map(DBIT=>DBIT, SB-TICK=>SB-TICK) 
port map(clk=>clk, reset=>reset , rx=>rx, 
s-tick=>tick, rx-done_tick=>rx-done-tick, 
dout=>rx-data-out ; 
45 
fifo-rx-unit: entity work.fifo(arch) 
generic map(B=>DBIT , W=>FIFO-W) 
port map(clk=>clk, reset=>reset , rd=>rd-uart , 
wr=>rx-done-t ick , w-data=>rx-data-out , 
empty=>rx-empty, full=>open, r-data=>r-data); 
50 
fifo-tx-unit: entity work.fifo(arch) 
generic map(B=>DBIT , W=>FIFO-W) 
port map(clk=>clk, reset=>reset, rd=>tx-done-tick, 
wr=>wr-uart, w-data=>w-data, empty=>tx-empty, 
full=>tx-full, r-data=>tx-fifo-out); 
5 5  
uart-tx-unit : entity work. uart-txcarch) 
g e n e r i c map ( DB I T = > DB I T , SB - T I CK = > SB - T I CK ) 
port map(clk=>clk, reset=>reset , 
tx-start=>tx-fifo-not-empty, 
s-tick=>tick, din=>tx-fifo-out, 
60 
tx-done-tick=> tx-done-tick, tx=>tx); 
tx-fifo-not-empty <= not tx-empty; 
end str-arch; 
In the picoBlaze source file (discussed in Chapter 14), Xilinx supplies a customized 
UART module with similar functionality. Unlike our implementation, the module is de- Xilinx 
scribed using low-level Xilinx primitives. It can be considered as a gate-level description specific 
that utilizes Xilinx-specific components. Since the designer has the expert knowledge of 
Xilinx devices and takes advantage of its architecture, its implementation is more efficient 
than the generic RT-level device-independent description of this chapter. It is instructive to 
compare the code complexity and the circuit size of the two descriptions. 

176 
UART 
Figure 7.6 Block diagram of a UART verification circuit. 
7.4.2 UART verification configuration 
Verificafion circuif We use a loop-back circuit and a PC to verify the UART’s operation. 
The block diagram is shown in Figure 7.6. In the circuit, the serial port of the S3 board is 
connected to the serial port of a PC. When we send a character from the PC, the received 
data word is stored in the UART receiver’s four-word FIFO buffer. When retrieved (via the 
r-data port), the data word is incremented by 1 and then sent back to the transmitter (via 
the w-data port). The debounced pushbutton switch produces a single one-clock-cycle tick 
when pressed and it is connected to the rd-uart and wr-uart signals. When the tick is 
generated, it removes one word from the receiver’s FIFO and writes the incremented word 
to the transmitter’s FIFO for transmission. For example, we can first type HAL in the PC 
and the three data words are stored in the FIFO buffer of the UART receiver. We then can 
push the button on the S3 board three times. The three successive characters, IBM, will be 
transmitted back and displayed. The UART’s r-data port is also connected to the eight 
LEDs of the S3 board, and its tx-full and rx-empty signals are connected to the two 
horizontal bars of the rightmost digit of the seven-segment display. The code is shown in 
Listing 7.5. 
Listing 7.5 UART verification circuit 
~~ 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  uart-test i s  
5 
p o r t (  
clk, r e s e t :  in std-logic; 
b t n :  std-logic-vector ( 2  downto 0 )  ; 
r x :  in std-logic; 
t x :  out std-logic; 
sseg : out std-logic-vector ( 7  downto 0) ; 
a n :  out std-logic-vector (3 downto 0) 
10 
led: out std-logic-vector ( 7  downto 0 )  ; 
) ;  
end uart-test; 
a r c h i t e c t u r e  arch of uart-test i s  
15 
s i g n a l  tx-full , rx-empty : std-logic; 
s i g n a l  rec-data ,rec-data1 : std-logic-vector ( 7  downto 0 )  ; 

OVERALL UART SYSTEM 
177 
signal btn-tick: std-logic; 
__ i n s t a n t i a t e  u a r t  
uart-unit : entity work.uart (str-arch) 
20 begin 
port map(clk=>clk, reset=>reset , rd-uart=>btn-tick, 
wr-uart=>btn-tick, r x = > r x ,  w-data=>rec-datal, 
r-data=>rec-data, tx=>tx); 
15 
tx-full=>tx-full, rx-empty=>rx-empty, 
__ i n s  t a n  t i a t e  d e b o u n c e  c i r c u i t  
btn-db-unit : entity w o r k .  debounce (fsmd-arch) 
port map(clk=>clk, reset=>reset , sw=>btn(O), 
30 
d b - l e v e l = > o p e n ,  db-tick=>btn-tick); 
-- i n c r e m e n t e d  d a t a  l o o p  back 
rec-data1 <= std-logic_vector(unsigned(rec-data)+l); 
__ l e d  d i s p l a y  
led <= rec-data; 
sseg <= '1' & (not tx-full) & "11" & (not rx-empty) & "111"; 
35 
an <= "1110"; 
end a r c h ;  
HyperTerminal of Windows On PC's side, Windows' HyperTerminal program can 
be used as a virtual terminal to interact with the S3 board. To be compatible with our 
customized UART, it has to be configured as 19,200 baud, 8 data bits, 1 stop bit, and no 
parity bit. The basic procedure is: 
1. 
2. 
3. 
4. 
5. 
Select Start t Programs t Accessories t Communications + HyperTerminal. The 
HyperTerminal dialog appears. 
Type a name for this connection, say fpga-192. Click OK. This connection can be 
saved and invoked later. 
A Connect-to dialog appears. Press the Connecting Using field and select the desired 
serial port (e.g., COM1). Click OK. 
The Port Setting dialog appears. Configure the port as follows: 
0 Bits per second: 19200 
0 Data bits: 8 
0 Parity: None 
0 Stop bits: 1 
0 Flow control: None 
Click OK. 
Select File t Properties + Setting. Click ASCII Setup and check the Echo typed 
characters locally box. Click OK twice. This will allow the typed characters to be 
shown on the screen. 
The HyperTerminal program is set up now and ready to communicate with the S3 board. 
We can type a few keys and observe the LEDs of the S3 board. Note that the received 
words are stored in the FIFO buffer and only the first received data word is displayed. 
After we press the pushbutton, the first data word will be removed from the FIFO and 
the incremented word will be looped back to the PC's serial port and displayed in the 
HyperTerminal window. The full and empty status of the respective FIFO buffers can be 
tested by consecutively receiving and transmitting more than four data words. 
ASCII code In HyperTerminal, characters are sent in ASCII code, which is 7 bits and 
consists of 128 code words, including regular alphabets, digits, punctuation symbols, and 

178 
UART 
nonprintable control characters. The characters and their code words (in hexadecimal for- 
mat) are shown in Table 7.1. The nonprintable characters are shown enclosed in parentheses, 
such as (del). Several nonprintable characters may introduce special action when received: 
0 (nul): null byte, which is the all-zero pattern 
0 (bel): generate a bell sound, if supported 
0 (bs): backspace 
0 (ht): horizontal tab 
0 (nl): new line 
0 (vt): vertical tab 
0 (np): newpage 
0 (cr): carriage return 
0 (esc): escape 
0 (sp): space 
0 (del): delete, which is also the all-one pattern 
Since we use the PC’s serial port to communicate with the S3 board in many experiments 
and projects, the following observations help us to manipulate and process the ASCII code: 
0 When the first hex digit in a code word is 016 or 116, the corresponding character is 
0 When the first hex digit in a code word is Z16 or 316, the corresponding character is 
0 When the first hex digit in a code word is 416 or 516, the corresponding character is 
0 When the first hex digit in a code word is 616 or 716, the corresponding character is 
0 If the first hex digit in a code word is 316, the lower hex digit represents the corre- 
0 The upper- and lowercase letters differ in a single bit and can be converted to each 
Note that the ASCII code uses only 7 bits, but a data word is normally composed of 
8 bits (i.e., a byte). The PC uses an extended set in which the MSB is 1 and the characters 
are special graphics symbols. This code, however, is not part of the ASCII standard. 
a control character. 
a digit or punctuation. 
generally an uppercase letter. 
generally a lowercase letter. 
sponding decimal digit. 
other by adding or subtracting 2016 or inverting the sixth bit. 
7.5 
CUSTOMIZING A UART 
The UART discussed in previous sections is customized for a particular configuration. The 
design and code can easily be modified to accommodate other required features: 
0 Baud rate. The baud rate is controlled by the frequency of the sampling ticks of the 
baud rate generator. The frequency can be changed by revising the M generic of the 
mod-m counter, which is represented as the DVSR constant in code. 
0 Number of data bits. The number of data bits can be changed by modifying the upper 
limit of the n-reg register, which is specified as the DBIT constant in code. 
0 Parity bit. A parity bit can be included by introducing a new state between the data 
and stop states in the ASMD chart in Figure 7.3. 
0 Number of stop bits. The number of stop bits can be changed by modifying the 
upper limit of the s-reg register in the stop state of the ASMD chart. The SB-TICK 
constant is used for this purpose. It can be 16,24, or 32, which is for 1, 1.5, or 2 stop 
bits, respectively. 

CUSTOMIZING A UART 
179 
Table 7.1 
ASCII codes 
Char 
Code 
(SP) 
40 
! 
41 
42 
# 
43 
$ 
44 
% 
45 
& 
46 
47 
( 
48 
1 
49 
* 
4a 
+ 
4b 
4c 
4d 
4e 
I 
4f 
0 
50 
1 
51 
2 
52 
3 
53 
4 
54 
5 
55 
6 
56 
7 
57 
8 
58 
9 
59 
5a 
5b 
< 
5c 
5d 
> 
5e 
? 
5f 
I1 
5 
- 
- 
Code 
00 
01 
02 
03 
04 
05 
06 
07 
08 
09 
Oa 
Ob 
oc 
Od 
Oe 
Of 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
la 
lb 
I C  
Id 
le 
If 
Code 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
2a 
2b 
2c 
2d 
2e 
2f 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
3a 
3b 
3c 
3d 
3e 
3f 
Char 
@ 
A 
B 
C 
D 
E 
F 
G 
H 
I 
J 
K 
L 
M 
N 
0 
P 
Q 
R 
S 
T 
U 
V 
W 
X 
Y 
Z 
[ 
\ 
1 
Code 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
6a 
6b 
6c 
6d 
6e 
6f 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
7a 
7b 
7c 
7d 
7e 
7f 
Char 
a 
b 
d 
e 
f 
g 
h 
i 
k 
1 
m 
n 
P 
9 
r 
C 
j 
0 
S 
t 
u 
V 
W 
X 
Y 
Z 
{ 
1 
(dell 
I 
x 

180 
UART 
0 Error checking. Three types of errors can be detected in the UART receiving subsys- 
- Parity error. If the parity bit is included, the receiver can check the correctness 
of the received parity bit. 
- Frame error. The receiver can check the received value in the stop state. If 
the value is not ’l’, the frame error occurs. 
- BufSer overrun error. This happens when the main system does not retrieve the 
received words in a timely manner. The UART receiver can check the value 
of the buffer’s f lag-reg signal or FIFO’s f u l l  signal when the received word 
is ready to be stored (i.e., when the rx-done-tick signal is generated). Data 
overrun occurs if the f lag-reg or f u l l  signal is still asserted. 
tem: 
7.6 BIBLIOGRAPHIC NOTES 
Although the RS-232 standard is very old, it still provides a simple and reliable low-speed 
communication link between two devices. The Wikipedia Web site has a good overview 
article and several useful links on the subject (search with the keyword RS232). Serial Port 
Complete by Jan Axelson provides information on interfacing hardware devices to PC’s 
serial port. 
7.7 SUGGESTED EXPERIMENTS 
7.7.1 Full-featured UART 
The alternative to the customized UART is to include all features in design and to dynam- 
ically configure the UART as needed. Consider a full-featured UART that uses additional 
input signals to specify the baud rate, type of parity bit, and the numbers of data bits and 
stop bits. The UART also includes an error signal. In addition to the I/O signals of the 
uart-top design in Listing 7.4, the following signals are required: 
0 bd-rate: 2-bit input signal specifying the baud rate, which can be 1200,2400,4800, 
0 dnum: 1-bit input signal specifying the number of data bits, which can be 7 or 8 
0 snum: 1-bit input signal specifying the number of stop bits, which can be 1 or 2 
0 par: 2-bit input signal specifying the desired parity scheme, which can be no parity, 
0 err: 3-bit output signal in which the bits indicate the existence of the parity error, 
or 9600 baud 
even parity, or odd parity 
frame error, and data overrun error 
Derive this circuit as follows: 
1. Modify the ASMD chart in Figure 7.3 to accommodate the required extensions. 
2. Revise the UART receiver code according to the ASMD chart. 
3. Revise the UART transmitter code to accommodate the required extensions. 
4. Revise the top-level UART code and the verification circuit. Use the onboard switches 
for the additional input signals and three LEDs for the error signals. Synthesize the 
verification circuit. 
5. Create different configurations in HyperTerminal and verify operation of the UART 
circuit. 

SUGGESTED EXPERIMENTS 
181 
7.7.2 UART with an automatic baud rate detection circuit 
The most commonly used number of data bits of a serial connection is eight, which cor- 
responds to a byte. When a regular ASCII code is used in communication (as we type in 
the HyperTerminal window), only seven LSBs are used and the MSB is ’0’. If the UART 
is configured as 8 data bits, 1 stop bit, and no parity, the received word is in the form of 
0-dddd-dddO-I, 
in which d is a data bit and can be ’0’ or ’ 1 ’. Assume that there is sufficient 
time between the first word and subsequent transmissions. We can determine the baud rate 
by measuring the time interval between the first ’0’ and last ’0’. Based on this observation, 
we can derive a UART with an automatic baud rate detection circuit. In this scheme, the 
transmitting system first sends an ASCII code for rate detection and then resumes normal 
operation afterward. The receiving subsystem uses the first word to determine a baud rate 
and then uses this rate for the baud rate generator for the remaining transmission. 
Assume that UART configuration is 8 data bits, 1 stop bit, and no parity bit, and the 
baud rate can be 4800,9600, or 19,200 baud. The revised UART receiver should have two 
operation modes. It is initially in the “detection mode” and waits for the first word. After 
the word is received and the baud rate is determined, the receiver enters “normal mode” 
and the UART operates in a regular fashion. Derive the UART as follows: 
1. Draw the ASMD chart for the automatic baud rate detector circuit. 
2. Derive the VHDL code for the ASMD chart. Use three LEDs on the S3 board to 
indicate the baud rate of the incoming signal. 
3. Modify the UART to include three different baud rates: 4800, 9600, and 19,200. 
This can be achieved by using a register for the divisor of the baud rate generator and 
loading the value according to the desired baud rate. 
4. Create a top-level FSMD to keep track of the mode and to control and coordinate 
operation of the baud rate detection circuit and the regular UART receiver. Use a 
pushbutton switch on the S3 board to force the UART into the detection mode. 
5. Revise the top-level UART code and the verification circuit. Synthesize the verifica- 
tion circuit. 
6. Create different configurations in HyperTerminal and verify operation of the UART. 
7.7.3 UART with an automatic baud rate and parity detection circuit 
In addition to the baud rate, we assume that the parity scheme also needs to be determined 
automatically, which can be no parity, even parity, or odd parity. Expand the previous 
automatic baud rate detection circuit to detect the parity configuration and repeat Experi- 
ment 7.7.2. 
7.7.4 UART-controlled stopwatch 
Consider the enhanced stopwatch in Experiment 4.7.6. Operation of the stopwatch is con- 
trolled by three switches on the S3 board. With the UART, we can use PC’s HyperTerminal 
to send commands to and retrieve time from the stopwatch: 
0 When a c or C (for “clear”) ASCII code is received, the stopwatch aborts current 
counting, is cleared to zero, and sets the counting direction to “up.” 
0 When a g or G (for “go”) ASCII code is received, the stopwatch starts to count. 
0 When a p or P (for “pause”) ASCII code is received, counting pauses. 
0 When a u or U (for “up-down”) ASCII code is received, the stopwatch reverses the 
direction of counting. 

182 
UART 
0 When a r or R (for “receive”) ASCII code is received, the stopwatch transmits the 
current time to the PC. The time should be displayed as ‘I DD . D It, where D is a decimal 
digit. 
0 All other codes will be ignored. 
Design the new stopwatch, synthesize the circuit, connect it to a PC, and use HyperTerminal 
to verify its operation. 
7.7.5 UART-controlled rotating LED banner 
Consider the rotating LED banner circuit in Experiment 4.7.5. With the UART, we can 
use PC’s HyperTerminal to control its operation and dynamically modify the digits in the 
banner: 
0 When a g or G (for “go”) ASCII code is received, the LED banner rotates. 
0 When a p or P (for “pause”) ASCII code is received, the LED banner pauses. 
0 When a d or D (for “direction”) ASCII code is received, the LED banner reverses the 
direction of rotation. 
0 When a decimal-digit (i.e., 0, 1, . . ., 9) ASCII code is received, the banner will be 
modified. The banner can be treated as a 10-word FIFO buffer. The new digit will 
be inserted at beginning (i.e., the leftmost position) of the banner and the rightmost 
digit will be shifted out and discarded. 
0 All other codes will be ignored. 
Design the new rotating LED banner, synthesize the circuit, connect it to a PC, and use 
HyperTerminal to verify its operation. 

CHAPTER 8 
PS2 KEYBOARD 
8.1 INTRODUCTION 
PS2 port was introduced in IBM’s Personal Systed2 personnel computers. It is a widely 
supported interface for a keyboard and mouse to communicate with the host. The PS2 port 
contains two wires for communication purposes. One wire is for data, which is transmitted 
in a serial stream. The other wire is for the clock information, which specifies when the 
data is valid and can be retrieved. The information is transmitted as an 1 1-bit “packet” that 
contains a start bit, 8 data bits, an odd parity bit, and a stop bit. Whereas the basic format 
of the packet is identical for a keyboard and a mouse, the interpretation for the data bits is 
different. The FPGA prototyping board has a PS2 port and acts as a host. We discuss the 
keyboard interface in this chapter and cover the mouse interface in Chapter 9. 
The communication of the PS2 port is bidirectional and the host can send a command 
to the keyboard or mouse to set certain parameters. For our purposes, the bidirectional 
communication is hardly required for the PS2 keyboard, and thus our discussion is limited 
to one direction, from the keyboard to the prototyping board. Bidirectional design will be 
examined in the mouse interface in Chapter 9. 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
183 

184 
ps2 KEYBOARD 
data (ps2d) 
clock (ps2c) 
~ 
idle 
start bit 
Figure 8.1 Timing diagram of a PS2 port. 
8.2 PS2 RECEIVING SUBSYSTEM 
8.2.1 
In addition to data and clock lines, the PS2 port includes connections for power (i.e., Vcc) 
and ground. The power is supplied by the host. In the original PS2 port, V,, is 5 V and the 
outputs of the data and clock lines are open-collector. However, most current keyboards 
and mice can work well with 3.3 V. For an older keyboard and mouse, the 5-V supply can 
be obtained by switching the 52 jumper on the S3 board. The FPGA should still function 
properly since its I/O pins can tolerate 5-V input. 
Physical interface of a PS2 port 
8.2.2 Device-to-host communication protocol 
A PS2 device and its host communicate via packets. The basic timing diagram of trans- 
mitting a packet from a PS2 device to a host is shown in Figure 8.1, in which the data and 
clock signals are labeled ps2d and ps2c, respectively. 
The data is transmitted in a serial stream, and its format is similar to that of a UART. 
Transmission begins with a start bit, followed by 8 data bits and an odd parity bit, and ends 
with a stop bit. Unlike a UART, the clock information is carried in a separate clock signal, 
ps2c. The falling edge of the ps2c signal indicates that the corresponding bit in the ps2d 
line is valid and can be retrieved. The clock period of the ps2c signal is between 60 and 
100 ps (i.e., 10 kHz to 16.7 kHz), and the ps2d signal is stable at least 5 ps before and after 
the falling edge of the ps2c signal. 
8.2.3 
Design and code 
The design of the PS2 port receiving subsystem is somewhat similar to that of a UART 
receiver. Instead of using the oversampling scheme, the falling-edge of the ps2c signal is 
used as the reference point to retrieve data. The subsystem includes a falling edge detection 
circuit, which generates a one-clock-cycle tick at the falling edge of the ps2c signal, and 
the receiver, which shifts in and assembles the serial bits. 
The edge detection circuit discussed in Section 5.3.1 can be used to detect the falling edge 
and generate an enable tick. However, because of the potential noise and slow transition, a 
simple filtering circuit is added to eliminate glitches. Its code is 
__ r e g i s t e r  
process (clk , reset) 
. . .  
f ilter-reg <= f ilter-next ; 

ps2 RECEIVING SUBSYSTEM 
185 
. . .  
end p r o c e s s ;  
-- 1- b i t  s h i f t e r  
filter-next <= ps2c & filter-reg(7 downto 1); 
_- 
" f i l t e r  " 
f-ps2c-next <= '1' when filter-reg="llllllll" e l s e  
' 0 '  when f i l t e r ~ r e g = " 0 0 0 0 0 0 0 0 "  e l s e  
f-ps2c-reg; 
The circuit is composed of an 8-bit shift register and returns a '1' or '0' when eight consec- 
utive 1's or 0's are received. Any glitches shorter than eight clock cycles will be ignored 
(i.e., filtered out). The filtered output signal is then fed to the regular falling-edge detection 
circuit. 
The ASMD chart of the receiver is shown in Figure 8.2. The receiver is initially in 
the idle state. It includes an additional control signal, rx-en, which is used to enable or 
disable the receiving operation. The purpose of the signal is to coordinate the bidirectional 
operation. It can be set to ' 1 ' for the keyboard interface. 
After the first falling-edge tick and the rx-en signal are asserted, the FSMD shifts in the 
start bit and moves to the dps state. Since the received data is in fixed format, we shift in 
the remaining 10 bits in a single state rather than using separate data, parity, and stop 
states. The FSMD then moves to the load state, in which one extra clock cycle is provided 
to complete the shifting of the stop bit, and the psrx-done-tick signal is asserted for one 
clock cycle. The HDL code consists of the filtering circuit and an FSMD, which follows 
the ASMD chart. It is shown in Listing 8.1. 
Listing 8.1 PS2 port receiver 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  ps2-rx i s  
5 
port ( 
clk, reset: in 
std-logic; 
ps2d, ps2c: in 
std-logic; -- key d a t a ,  key c l o c k  
rx-en : in std-logic ; 
rx-done-tick: out 
std-logic; 
10 
dout: out std-logic-vector (7 downto 0) 
) ;  
end ps2-rx; 
a r c h i t e c t u r e  arch of ps2-rx i s  
15 
type statetype i s  (idle, d p s ,  load); 
s i g n a l  state-reg , state-next : statetype; 
s i g n a l  f ilter-reg , f ilter-next : 
s i g n a l  f - p s 2 c _ r e g ,  f -ps2c_next : std-logic ; 
s i g n a l  n-reg , n-next : unsigned (3 downto 0) ; 
s i g n a l  f all-edge : std-logic ; 
std-logic-vector (7 downto 0 )  ; 
zo 
s i g n a l  b-reg , b-next : std-logic-vector (10 downto 0 )  ; 
begin 
___________________________________________________ 
__________________________________________------- 
2s 
-- f i l t e r  and f a l l i n g  e d g e  t i c k  g e n e r a t i o n  f o r  p s 2 c  

186 
ps2 KEYBOARD 
- 
............ 
............ 
i.............. 
........ 
t----- 
................................ rg 
fall-edge= 
T 
1 
b c 
ps2d & ( b W )  
c', 
n t 
n-I 
, .............,........... 
Figure 8.2 ASMD chart of the PS2 port receiver. 

ps2 RECEIVING SUBSYSTEM 
187 
____________________----------------------------- 
-_ ________________________________________--------- 
process ( c l k  , r e s e t )  
begin 
i f  r e s e t = ' l '  then 
30 
f i l t e r - r e g  <= ( o t b e r s = > ' O ' ) ;  
f - p s 2 c - r e g  
<= ' 0 ' ;  
f i l t e r - r e g  <= f i l t e r - n e x t ;  
f - p s 2 c - r e g  
<= f - p s 2 c - n e x t ;  
e l s i f  ( c l k ' e v e n t  and c l k = ' l ' )  then 
15 
end i f  ; 
end p r o c e s s ;  
f i l t e r - n e x t  <= ps2c & f i l t e r - r e g ( 7  downto 1); 
f - p s 2 c - n e x t  
<= '1' when f i l t e r ~ r e g = " l l l l l l l l "  e l s e  
40 
' 0 '  when f i l t e r ~ r e g = ' ' 0 0 0 0 0 0 0 0 "  e l s e  
f a l l - e d g e  <= f - p s z c - r e g  
and ( n o t  f - p s 2 c - n e x t ) ;  
f - p s 2 c - r e g ;  
ss 
65 
70 
75 
________________________________________-_-_---_-_- 
_-___--__-_--__-__------------------------------- 
45 
-- f s m d  t o  e x t r a c t  t h e  8 - b i t  
d a t a  
_-____--________--__-_------------------_-_------ 
______-_________________________________--------- 
__ 
-_ 
r e g i s t e r s  
process ( c l k  , r e s e t )  
begin 
so 
i f  r e s e t = ' l '  then 
s t a t e - r e g  <= i d l e ;  
n - r e g  
<= ( o t h e r s = > ' O ' ) ;  
b - r e g  <= ( o t h e r s = > ' O ' ) ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
n - r e g  <= n - n e x t ;  
b - r e g  <= b - n e x t ;  
e l s i f  ( c l k ' e v e n t  and c l k = ' l ' )  then 
end i f  ; 
end p r o c e s s ;  
process ( s t a t e - r e g  , ~ ~ - r e g ,  
b-reg , f a l l - e d g e  , r x - e n  , p s 2 d )  
begin 
w 
-- n e x t - s t a t e  
l o g i c  
r x - d o n e - t i c k  
< = l o 7  ; 
s t a t e - n e x t  <= s t a t e - r e g ;  
n-next <= n - r e g ;  
b - n e x t  <= b - r e g ;  
case s t a t e - r e g  i s  
when i d l e  => 
i f  f a l l - e d g e =  ' 1 ' and r x - e n =  ' 1 ' then 
__ s h i f t  i n  s t a r t  b i t  
b-next <= ps2d & b - r e g ( l 0  downto 1); 
n-next <= " 1 0 0 1 " ;  
s t a t e - n e x t  <= d p s ;  
end i f ;  
when dps => -- 8 d a t a  + I p a r i t y  + 1 s t o p  
i f  f a l l - e d g e  = ' 1 
then 
b-next <= ps2d & b - r e g ( l 0  downto 1 ) ;  
i f  n - r e g  = 0 then 

188 
ps2 KEYBOARD 
Figure 8.3 
All rights reserved.) 
Scan code of the PS2 keyboard. (Courtesy of Xilinx, Inc. 0 
Xilinx, Inc. 1994-2007. 
85 
s t a t e - n e x t  < = l o a d ;  
n-next 
<= n - r e g  - 1; 
no 
e l s e  
end i f  ; 
end i f  ; 
when l o a d  => 
-- I 
e x t r a  c l o c k  to  c o m p le te  f h e  l a s t  s h i f t  
s t a t e - n e x t  <= i d l e ;  
r x - d o n e - t i c k  
<='1'; 
end c a s e ;  
end p r o c e s s ;  
d o u t  <= b - r e g ( 8  downto 1); -- data b i t s  
90 
-- o u t p u t  
end a r c h ;  
There is no error detection circuit in the description. A more robust design should check 
the correctness of the start, parity, and stop bits and include a watchdog timer to prevent the 
keyboard from being locked in an incorrect state. This is left as an experiment at the end 
of the chapter. 
8.3 PS2 KEYBOARD SCAN CODE 
8.3.1 Overview of the scan code 
A keyboard consists of a matrix of keys and an embedded microcontroller that monitors 
(i.e., scans) the activities of the keys and sends scan code accordingly. Three types of key 
activities are observed: 
0 When a key is pressed, the make code of the key is transmitted. 
0 When a key is held down continuously, a condition known as typematic, the make 
code is transmitted repeatedly at a specific rate. By default, a PS2 keyboard transmits 
the make code about every 100 ms after a key has been held down for 0.5 second. 
The make code of the main part of a PS2 keyboard is shown in Figure 8.3. It is normally 
1 byte wide and represented by two hexadecimal numbers. For example, the make code 
0 When a key is released, the break code of the key is transmitted. 

PSZ KEYBOARD SCAN CODE 
189 
of the A key is IC. This code can be conveyed by one packet when transmitted. The make 
codes of a handful of special-purpose keys, which are known as the extended keys, can have 
2 to 4 bytes. A few of these keys are shown in Figure 8.3. For example, the make code of 
the upper arrow on the right is EO 75. Multiple packets are needed for the transmission. 
The break codes of the regular keys consist of FO followed by the make code of the key. 
For example, the break code of the A key is FO 1C. 
The PS2 keyboard transmits a sequence of codes according to the key activities. For 
example, when we press and release the A key, the keyboard first transmits its make code 
and then the break code: 
1C FO 1C 
If we hold the key down for awhile before releasing it, the make code will be transmitted 
multiple times: 
1C 1C 1 C  . . .  1C F O  1 C  
Multiple keys can be pressed at the same time. For example, we can first press the s h i f t  
key (whose make code is 12) and then the A key, and release the A key and then release the 
s h i f t  key. The transmitted code sequence follows the make and break codes of the two 
keys: 
12 1 C  FO 1 C  FO 12 
The previous sequence is how we normally obtain an uppercase A. Note that there is no 
special code to distinguish the lower- and uppercase keys. It is the responsibility of the 
host device to keep track of whether the shift key is pressed and to determine the case 
accordingly. 
8.3.2 Scan code monitor circuit 
The scan code monitor circuit monitors the arrival of the received packets and displays the 
scan codes on a PC's HyperTerminal window. The basic design approach is to first split the 
received scan code into two 4-bit parts and treat them as two hexadecimal digits, and then 
convert the two digits to ASCII code words and send the words to a PC via the UART. The 
received scan codes should be displayed similar to the previous example sequences. The 
program is shown in Listing 8.2. 
Listing 8.2 PS2 keyboard scan code monitor circuit 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  kb-monitor i s  
5 
port ( 
c l k ,  r e s e t :  in 
std-logic; 
ps2d, ps2c: in 
std-logic; 
t x :  out 
std-logic 
) ;  
10 end kb-monitor; 
a r c h i t e c t u r e  arch of kb-monitor i s  
constant SP: std-logic-vector ( 7  downto 0) : = " 0 0 1 0 0 0 0 0 " ;  
__ b l a n k  s p a c e  i n  A S C I I  

190 
PS2 KEYBOARD 
s i g n a l  
s i g n a l  
s i g n a l  
s i g n a l  
20 
s i g n a l  
begin 
_- 
i n s  
25 
-- i n s  
__ 
__ 
15 
t y p e  s t a t e t y p e  i s  ( i d l e ,  s e n d l ,  s e n d 0 ,  s e n d b ) ;  
s t a t e - r e g  , s t a t e - n e x t  : s t a t e t y p e ;  
s c a n - d a t a  , w-data: 
s t d - l o g i c - v e c t o r  (7 downto. 0) ; 
s c a n - d o n e - t i c k ,  w r - u a r t :  s t d - l o g i c ;  
a s c i i - c o d e  : s t d - l o g i c - v e c t o r  ( 7  downto 0) ; 
h e x - i n :  s t d - l o g i c - v e c t o r  (3 downto 0) ; 
30 
35 
45 
KI 
65 
a n t i a t i o n  
a n t i a t e  PS2 r e c e i v e r  
p s 2 - r x - u n i t  : e n t i t y  work. p s 2 - r x  ( a r c h )  
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , r x - e n = > ’  1 I
,
 
p s 2 d = > p s 2 d ,  p s 2 c = > p s 2 c ,  
rx-done-tick=>scan-done-tick, 
d o u t  = > s c a n - d a t  a )  ; 
__ i n s t a n t i a t e  UART 
u a r t - u n i t :  e n t i t y  w o r k . u a r t  ( s t r - a r c h )  
p o r t  m a p ( c l k = > c l k  , r e s e t = > r e s e t  , r d - u a r t = > ’ O ’ ,  
w r - u a r t = > w r - u a r t  , r x = >  ’1’ , w-data=>w-data, 
t x - f u l l = > o p e n ,  rx-empty=>open , r - d a t a = > o p e n ,  
t x = > t x )  ; 
__ 
40 
-- FSM t o  send 3 A S C I I  c h a r a c t e r s  
__ 
-- s t a t e  r e g i s t e r s  
p r o c e s s  ( c l k  , r e s e t )  
begin 
i f  r e s e t = ’ l ’  t h e n  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  t h e n  
end i f  ; 
s t a t e - r e g  <= i d l e ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
50 
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  
p r o c e s s  ( s t a t e - r e g  , s c a n - d o n e - t i c k  , a s c i i - c o d e )  
begin 
w r - u a r t  
<= ’ 0 ’ ;  
s t a t e - n e x t  
<= s t a t e - r e g ;  
c a s e  s t a t e - r e g  i s  
55 
w-data <= S P ;  
when i d l e  => -- s t a r t  when a s c a n  code r e c e i v e d  
i f  s c a n - d o n e - t i c k = ’ l ’  t h e n  
s t a t e - n e x t  <= s e n d l  ; 
end i f  ; 
w-data <= a s c i i - c o d e ;  
w r - u a r t  
<= ’ 1 ’ ;  
s t a t e - n e x t  <= s e n d o ;  
w-data <= a s c i i - c o d e ;  
when s e n d l  = >  -- send h i g h e r  h e x  c h a r  
when send0 => -- send l o w e r  h e x  c h a r  

PS2 KEYBOARD INTERFACE CIRCUIT 
191 
w r - u a r t  <= J I J ;  
s t a t e - n e x t  <= s e n d b ;  
w-data <= S P ;  
wr-uart 
<= ' 1 ' ;  
s t a t e - n e x t  <= i d l e ;  
70 
when sendb => -- send b l a n k  s p a c e  c h a r  
end c a s e ;  
75 
end p r o c e s s ;  
-- s c a n  code t o  ASCII d i s p l a y  
-- 
so 
-- s p l i t  t h e  scan code i n t o  two 4 - b i t  
hex 
h e x - i n  <= s c a n - d a t a  ( 7  
s c a n - d a t a  (3 
-- h e x  d i g i t  t o  A S C I I  
with h e x - i n  s e l e c t  
85 
a s c i i - c o d e  <= 
0 0  1 10000 It when 
I' 0 0 1 1 0 0 0 1 when 
It 00 1 100 10 
when 
I' 00 11 00 1 1 I' when 
90 
I' 0 0  1 10 100 If when 
I' 0 0 1 1 0 1 0 1 'I when 
'I 00 1 10 1 10 when 
'I 00 1 1  0 1 1 1 when 
'I 00 1 1 1000 It when 
95 
'I 00 11 100 1 
when 
'I 0 1 0 0 0 0 0 1 'I when 
I' 0 10000 10 when 
"01000011 
when 
'I 0 1 0 0 0 1 0 0 
when 
0 1 0 0 0 1 0 1 'I when 
I' 0 1000 11 0 
when 
IW 
end a r c h ;  
downto 4 )  when s t a t e - r e g = s e n d l  e l s e  
downto 0 ) ;  
code 
' ~ 0 0 0 0 "  , -- 0 
" O O O l " ,  
-- 1 
" O O l O " ,  -- 2 
" 0 0 1 1 " ,  -- 3 
" O l O O " ,  
-- 4 
" O l O l " ,  -- 5 
" O l l O " ,  -- 6 
" O l l l " ,  -- 7 
" l O O O " ,  -- 8 
" l O O l " ,  -- 9 
"1010", -- A 
" l o l l " ,  -- B 
" 1 1 0 0 " ,  -- c 
" 1 1 0 1 " ,  -- D 
" 1 1 1 0 " ,  -- E 
o t h e r s ;  -- F 
An FSM is used to control the overall operation. The UART operation is initiated when 
a new scan code is received (as indicated by the assertion of scan-done-tick). The FSM 
circulates through the sendl, send0, and sendb states, in which the ASCII codes of the 
upper hexadecimal digit, lower hexadecimal digit, and blank space are written to the UART. 
Recall that the UART has a FIFO of four words, and thus no overflow will occur. Note that 
the UART receiver is not used and the corresponding ports are mapped to constants or open. 
8.4 PS2 KEYBOARD INTERFACE CIRCUIT 
As discussed in Section 8.3.1, a sequence of packets is transmitted even for simple keyboard 
activities. It will be quite involved if we want to cover all possible combinations. In this 
section, we assume that only one regular key is pressed and released at a time and design a 
circuit that returns the make code of this key. This design provides a simple way to send a 
character or digit to the prototyping board and should be satisfactory for our purposes. 

192 
PS2 KEYBOARD 
Figure 8.4 Block diagram of a last-released key circuit. 
8.4.1 Basic design and HDL code 
The keyboard circuit, as a UART, is a peripheral circuit of a large system and needs a 
mechanism to communicate with the main system. The flagging and buffering schemes 
discussed in Section 7.2.4 can be applied for the keyboard circuit as well. We use a four- 
word FIFO buffer as the interface in this design. 
The top-level conceptual diagram is shown in Figure 8.4. It consists of the PS2 receiver, 
a FIFO buffer, and a control FSM. The basic idea is to use the FSM to keep track of the FO 
packet of the break code. After it is received, the next packet should be the make code of 
this key and is written into the FIFO buffer. Note that this scheme cannot be applied to the 
extended keys since their make codes involve multiple packets. The corresponding HDL 
code is shown in Listing 8.3. 
Listing 8.3 PS2 keyboard last-released key circuit 
libr ar y i e e e ;  
use i e e e .  std-logic-1164. a l l  ; 
use i e e e .  numeric-std. a l l  ; 
e n t i t y  kb-code i s  
5 
ge ne ri c (W-SIZE : integer : =2) ; -- 2 A W-SIZE words in FIFO 
port ( 
clk, r e s e t :  in 
std-logic; 
p s 2 d ,  p s 2 c :  in 
std-logic; 
rd-key-code : in std-logic ; 
kb-buf-empty: out std-logic 
10 
key-code : out std-logic-vector (7 downto 0 )  ; 
) ;  
end kb-code; 
I5 a r c h i t e c t u r e  arch of kb-code i s  
c ons tan t B R K :  std-logic-vector ( 7  downto 0 )  :="11110000"; 
-- FO ( b r e a k  c o d e )  
type statetype i s  (wait-brk, get-code) ; 
s i g n a l  state-reg , state-next : statetype; 
s i g n a l  scan-done-tick , got-code-tick: std-logic; 
20 
s i g n a l  scan-out , w-data: std-logic-vector (7 downto 0 )  ; 
begin 
-_ 
2s 
-- i n s t a n t i a t i o n  

PSZ KEYBOARD INTERFACE CIRCUIT 
193 
30 
p s 2 - r x - u n i t  : e n t i t y  work. p s 2 - r x  ( a r c h )  
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , r x - e n = > ’ l ’ ,  
p s 2 d = > p s 2 d ,  p s 2 c = > p s 2 c ,  
rx-done-tick=>scan-done-tick, 
d o u t = > s c a n - o u t )  ; 
f i f o - k e y - u n i t :  
e n t i t y  w o r k . f i f o ( a r c h )  
g e n e r i c  map(B=>8, W=>W-SIZE) 
p o r t  map( c l k = > c l k  , r e s e t = > r e s e t  , rd=>rd-key-code , 
w r = > g o t - c o d e - t i c k ,  
w - d a t a = > s c a n - o u t ,  
empty=>kb-buf-empty, 
f u l l = > o p e n ,  
r - d a t a = > k e y - c o d e ) ;  
40 
-- 
-- FSM t o  g e t  t h e  s c a n  code a f t e r  FO r e c e i v e d  
45 
p r o c e s s  ( c l k  , r e s e t )  
begin 
if r e s e t = ’ l ’  t h e n  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  t h e n  
s t a t e - r e g  <= w a i t - b r k ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
end i f  ; 
50 
end p r o c e s s ;  
p r o c e s s  ( s t a t e - r e g  , s c a n - d o n e - t i c k  , 
begin 
g o t - c o d e - t i c k  
< = ’ O ’ ;  
55 
s t a t e - n e x t  <= s t a t e - r e g ;  
case s t a t e - r e g  is 
when w a i t - b r k  => -- w a i t  f o r  
i f  s c a n - d o n e - t i c k = ’ l ’  and 
s t a t e - n e x t  <= g e t - c o d e  
end if ; 
when g e t - c o d e  = >  -- g e t  t h e  
s c a n - o u t )  
FO of 
b r e a k  code 
scan-out=BRK t h e n  
60 
o l l o w i n g  s c a n  code 
i f  s c a n - d o n e - t i c k = ’ l ’  t h e n  
g o t - c o d e - t i c k  <= 1 ’ ; 
s t a t e - n e x t  <= w a i t - b r k ;  
h l  
end i f  ; 
end c a s e ;  
end p r o c e s s ;  
end a r c h ;  
The main part of the code is the FSM, which screens for the break code and coordi- 
nates the operation of two other modules. It checks the received packets in the wait-brk 
state continuously. When the FO packet is detected, it moves to the get-code state and 
waits for the next packet, which is the make code of the key. The FSM then asserts the 
code-done-tick signal for one clock cycle and returns to the wait-brk state. 

194 
PS2 KEYBOARD 
Figure 8.5 Block diagram of a keyboard verification circuit. 
8.4.2 Verification circuit 
We design a simple serial interface and decoding circuit to verify operation of the PS2 
keyboard interface. The top-level block diagram is shown in Figure 8.5. The circuit 
converts a key's make code to the corresponding ASCII code and then sends the ASCII code 
to the UART. The corresponding character or digits can be displayed in the HyperTerminal 
window. The HDL code for the conversion circuit is shown in Listing 8.4. 
Listing 8.4 Keyboard make code to ASCII code 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use i e e e .  numeric-std. a l l  ; 
e n t i t y  key2ascii i s  
5 
port ( 
key-code : in std-logic-vector ( 7  downto 0) ; 
ascii-code : out std-logic-vector ( 7  downto 0) 
) ;  
end key2ascii ; 
a r c h i t e c t u r e  arch of key2ascii i s  
begin 
10 
with key-code s e l e c t  
ascii-code <= 
15 
'I 0 0 1 1 0 0 0 0 I' when 
'I 0 1 0 0 0 1 0 1 'I , -- 0 
'1001100011' when " 0 0 0 1 0 1 1 0 " ,  -- 1 
" 0 0 1 1 0 0 1 0 "  when " 0 0 0 1 1 1 1 0 " ,  -- 2 
" 0 0 1 1 0 0 1 1 "  when " 0 0 1 0 0 1 1 0 " ,  
-- 3 
" 0 0 1 1 0 1 0 0 ~ '  when " 0 0 1 0 0 1 0 1 " ,  
-- 4 
" 0 0 1 1 0 1 0 1 "  when " 0 0 1 0 1 1 1 0 " ,  
-- 5 
" 0 0 1 1 0 1 1 0 "  when " 0 0 1 1 0 1 1 0 " ,  -- 6 
I' 00 11 0 11 1 I' when 
I' 00 1 1  1 1  0 1 It , -- 7 
" 0 0 1 1 1 0 0 0 ' ~  when " 0 0 1 1 1 1 1 0 " ,  
-- 8 
"00111001" when " 0 1 0 0 0 1 1 0 " ,  -- 9 
20 
" 0 1 0 0 0 0 0 1 "  when " 0 0 0 1 1 1 0 0 " ,  
-- A 
"01000010" when " 0 0 1 1 0 0 1 0 ' ~ ,  -- B 
" O I O O O O 1 l t ~  when " 0 0 1 0 0 0 0 1 " ,  -- C 
" 0 1 0 0 0 1 0 0 ' ~  when " 0 0 1 0 0 0 1 1 " ,  -- D 
"01000101" when " 0 0 1 0 0 1 0 0 " ,  
-- E 

PS2 KEYBOARD INTERFACE CIRCUIT 
195 
" 0 1 0 0 0 1 1 0 "  when 
t ' O O I O I O 1 l " ,  
-- F 
" 0 1 0 0 0 1 1 1 "  when ~ ' 0 0 1 1 0 1 0 0 " ,  -- G 
" 0 1 0 0 1 0 0 0 "  when " 0 0 1 1 0 0 1 1 " ,  -- H 
" O I O O I O O 1 t ~  when 
" O I O O O O 1 l ' t ,  
-- I 
" 0 1 0 0 1 0 1 0 "  when ' t O O 1 l l O 1 l " ,  -- J 
" 0 1 0 0 1 0 1 1 "  when " 0 1 0 0 0 0 1 0 " ,  -- K 
"01001100" when " 0 1 0 0 1 0 1 1 " ,  
-- L 
" 0 1 0 0 1 1 0 1 "  when 
t l O O 1 l l O I O " ,  
-- M 
"010011101' when " 0 0 1 1 0 0 0 1 " ,  -- N 
" 0 1 0 0 1 1 1 1 "  when " 0 1 0 0 0 1 0 0 " ,  
-- 0 
" 0 1 0 1 0 0 0 0 "  when '101001101'1, -- P 
" 0 1 0 1 0 0 0 1 ~ '  when " 0 0 0 1 0 1 0 1 " ,  -- Q 
" 0 1 0 1 0 0 1 0 ~ 1  when " 0 0 1 0 1 1 0 1 " ,  
-- R 
" 0 1 0 1 0 0 1 1 "  when t ' O O O 1 l O 1 l ~ ~ ,  -- S 
" 0 1 0 1 0 1 0 0 "  when '100101100", -- T 
" 0 1 0 1 0 1 0 1 "  when " 0 0 1 1 1 1 0 0 " ,  -- U 
" 0 1 0 1 0 1 1 0 "  when ' ~ 0 0 1 0 1 0 1 0 " ,  -- V 
" O 1 0 1 O 1 1 l t ~  
when " 0 0 0 1 1 1 0 1 ~ ' ,  -- W 
"O1O110OOt' when " 0 0 1 0 0 0 1 0 ~ ' ,  -- X 
"O1O110Olt~ 
when " O O 1 l O I O 1 l f ,  
-- Y 
" O 1 0 1 1 O 1 O r 1  when " O O O 1 l O I O t t ,  -- 2 
'101100000" 
when " 0 0 0 0 1 1 1 0 " ,  -- ' 
" 0 0 1 0 1 1 0 1 "  when " 0 1 0 0 1 1 1 0 " ,  -- - 
" 0 0 1 1 1 1 0 1 "  when 1 ' 0 1 0 1 0 1 0 1 " ,  -- - 
"01011011" when 
~ t O I O I O I O O " ,  -- [ 
"01011101" when '101011011", -- ] 
" 0 1 0 1 1 1 0 0 "  when " 0 1 0 1 1 1 0 1 " ,  
-- \ 
"00111011" when 
" O I O O 1 l O O t l ,  -- ; 
t l O O I O O 1 l l "  when " 0 1 0 1 0 0 1 0 " ,  
-- ' 
l ' O O I O 1 l O O 1 t  when " O I O O O O O 1 l t ,  
-- , 
~ ' 0 0 1 0 1 1 1 0 "  when " 0 1 0 0 1 0 0 1 " ,  
-- . 
" 0 0 1 0 1 1 1 1 "  when " 0 1 0 0 1 0 1 0 " ,  
-- / 
- 
65 
" 0 0 1 0 0 0 0 0 "  when " 0 0 1 0 1 0 0 1 " ,  
-- ( s p a c e )  
" 0 0 0 0 1 1 0 1 "  when " 0 1 0 1 1 0 1 0 " ,  
-- ( e n t e r ,  c r )  
" 0 0 0 0 1 0 0 0 ' ~  when " 0 1 1 0 0 1 1 0 " ,  
-- ( b a c k s p a c e )  
" 0 0 1 0 1 0 1 0 "  when o t h e r s  ; 
-- 
end a r c h ;  
The complete code for the verification circuit follows the block diagram and is shown 
in Listing 8.5. 
Listing 8.5 
Keyboard verification circuit 
l i b r a r y  i e e e ;  
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  kb-test i s  
I 
port ( 
c l k ,  r e s e t :  in 
std-logic; 
p s 2 d ,  p s 2 c :  in 
std-logic; 
tx : out 
std-logic 
) ;  

196 
ps2 KEYBOARD 
10 end kb-test; 
architecture arch of kb-test is 
signal scan-data, w-data: std-logic-vector ( 7  downto 0) ; 
signal kb-not-empty , kb-buf -empty : std-logic; 
I S  
signal key-code , ascii-code : std-logic-vector (7 downto 0 )  ; 
begin 
kb-code-unit : entity work. kb-code(arch) 
port map(clk=>clk, reset=>reset , ps2d=>ps2d, ps2c=>ps2c, 
rd-key-code=>kb-not-empty, key-code=>key-code, 
20 
kb-buf-empty=>kb_buf-empty); 
uart-unit : entity work.uart (str-arch) 
port map(clk=>clk, reset=>reset , rd-uart=>’O’, 
wr-uart=>kb-not-empty, rx=>’l’, 
w-dat a= > as c i i- c ode , t x-f ull =>open , 
25 
rx-empty=>open, r-data=>open, tx=>tx); 
key2a-unit : entity work. key2ascii(arch) 
port map(key-code=>key-code, ascii-code=>ascii-code); 
kb-not-empty <= not kb-buf-empty; 
30 end arch; 
8.5 BIBLIOGRAPHIC NOTES 
Three articles, ‘‘PSI2 MouselKeyboard Protocol,” ‘‘PSI2 Keyboard Interface,” and ‘‘PSI2 
Mouse Interface,” by Adam Chapweske, provide detailed information on the PS2 keyboard 
and mouse interface. They can be found at the http://www.computer-engineering.org site. 
Rapid Prototyping of Digital Systems: Quartus@ II Edition by James 0. Hamblen et al. 
also contains a chapter on the PS2 port and the keyboard and mouse protocols. 
8.6 SUGGESTED EXPERIMENTS 
8.6.1 Alternative keyboard interface I 
The interface circuit in Section 8.4 returns the make code of the last released key and 
thus ignores the typematic condition. An alternative approach is to consider the typematic 
condition. The keyboard interface circuit should return a key’s make code repeatedly when 
it is held down and ignore the final break code. For simplicity, we assume that the extended 
keys are not used. Design the new interface circuit, resynthesize the verification circuit, 
and verify operation of the new interface circuit. 
8.6.2 Alternative keyboard interface II 
We can expand the interface circuit to distinguish whether the shift key is pressed so that 
both lower- and uppercase characters can be entered. The expanded circuit can be modified 
as follows: 
0 The keycode output should be extended from 8 bits to 9 bits. The extra bit indicates 
whether the shift key is held down. 

SUGGESTED EXPERIMENTS 
197 
0 The FSM should add a special branch to process the make and break codes of the 
shift key and set the value of the corresponding bit accordingly. 
0 The width of the FIFO buffer should be extended to 9 bits. 
Design the expanded interface circuit, modify the key2ascii circuit to handle both lower- 
and uppercase characters, resynthesize the verification circuit, and verify operation of the 
expanded interface circuit. 
8.6.3 PS2 receiving subsystem with watchdog timer 
There is no error-handling capability in the PS2 receiving subsystem in Section 8.2. The 
potential noise and glitches in the ps2c signal may cause the FSMD to be stuck in an 
incorrect state. One way to deal with this problem is to add a watchdog timer. The timer 
is initiated every time the f all-edge-tick signal is asserted in the get-bit state. The 
time-out signal is asserted if no subsequently falling edge arrives in the next 20 ps, and 
the FSMD returns to the idle state. Design the modified receiving subsystem, derive a 
testbench, and use simulation to verify its operation. 
8.6.4 Keyboard-controlled stopwatch 
Consider the enhanced stopwatch in Experiment 4.7.6. Operation of the stopwatch is 
controlled by three switches on the prototyping board. We can use the keyboard to send 
commands to the stopwatch: 
0 When the C (for “clear”) key is pressed, the stopwatch aborts the current counting, is 
0 When the G (for “go”) key is pressed, the stopwatch starts to count. 
0 When the P (for “pause”) key is pressed, the counting pauses. 
0 When the U (for “up-down”) key is pressed, the stopwatch reverses the direction of 
0 All other keys will be ignored. 
cleared to zero, and sets the counting direction to ‘‘up.’’ 
counting. 
Design the new stopwatch, synthesize the circuit, and verify its operation. 
8.6.5 Keyboard-controlled rotating LED banner 
Consider the rotating LED banner circuit in Experiment 4.7.5. We can use a keyboard to 
control its operation and dynamically modify the digits in the banner: 
0 When the G (for “go”) key is pressed, the LED banner rotates. 
0 When the P (for “pause”) key is pressed, the LED banner pauses. 
0 When the D (for “direction”) key is pressed, the LED banner reverses the direction 
of rotation. 
0 When a decimal digit (i.e., 0, 1, . . ., 9) key is pressed, the banner will be modified. 
The banner can be treated as a 10-word FIFO buffer. The new digit will be inserted at 
the beginning (i.e., the leftmost position) of the banner, and the rightmost digit will 
be shifted out and discarded. 
0 All other keys will be ignored. 
Design the new rotating LED banner, synthesize the circuit, and verify its operation. 

This Page Intentionally Left Blank

CHAPTER 9 
PS2 MOUSE 
9.1 INTRODUCTION 
A computer mouse is designed mainly to detect two-dimensional motion on a surface. Its 
internal circuit measures the relative distance of movement and checks the status of the 
buttons. For a mouse with a PS2 interface, this information is packed in three packets and 
sent to the host through the PS2 port. In the stream mode, a PS2 mouse sends the packets 
continuously in a predesignated sampling rate. 
Communication of the PS2 port is bidirectional and the host can send a command to 
the keyboard or mouse to set certain parameters. For our purposes, this functionality is 
hardly required for a keyboard, and thus the keyboard interface in Chapter 8 is limited to 
one direction, from the keyboard to the FPGA host. However, unlike the keyboard, a mouse 
is set to be in the non-steaming mode after power-up and does not send any data. The host 
must first send a command to the mouse to initialize the mouse and enable the stream mode. 
Thus, bidirectional communication of the PS2 port is needed for the PS2 mouse interface, 
and we must design a transmitting subsystem (i.e., from FPGA board to mouse) for the PS2 
interface. 
In this chapter, we provide a short overview of the PS2 mouse protocol, design a bidi- 
rectional PS interface, and derive a simple mouse interface. 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
199 

200 
PSZMOUSE 
Table 9.1 Mouse data packet format 
9.2 PS2 MOUSE PROTOCOL 
9.2.1 Basic operation 
A standard PS2 mouse reports the x-axis (right/left) and y-axis (up/down) movement and 
the status of the left button, middle button, and right button. The amount of each movement 
is recorded in a mouse’s internal counter. When the data is transmitted to the host, the 
counter is cleared to zero and restarts the counting. The content of the counter represents a 
9-bit signed integer in which a positive number indicates the right or up movement, and a 
negative number indicates the left or down movement. 
The relationship between the physical distances is defined by the mouse’s resolution 
parameter. The default value of resolution is four counts per millimeter. When a mouse 
moves continuously, the data is transmitted in a regular rate. The rate is defined by the 
mouse’s sampling rate parameter. The default value of the sampling rate is 100 samples per 
second. If a mouse moves too fast, the amount of the movement during the sampling period 
may exceed the maximal range of the counter. The counter is set to the maximum magnitude 
in the appropriate direction. Two overflow bits are used to indicate the conditions. 
The mouse reports the movement and button activities in 3 bytes, which are embedded in 
three PS2 packets. The detailed format of the 3-byte data is shown in Table 9.1. It contains 
the following information: 
0 2 8 ,  . . ., 20: x-axis movement in 2’s-complement format 
0 2,: x-axis movement overflow 
0 y8, . . ., yo: y-axis movement in 2’s-complement format 
0 yu: y-axis movement overflow 
0 1: left button status, which is ’1’ when the left button is pressed 
0 T :  right button status, which is ’ 1’ when the right button is pressed 
0 m: optional middle button status, which is ’ 1 ’ when the middle button is pressed 
During transmission, the byte 1 packet is sent first and the byte 3 packet is sent last. 
9.2.2 Basic initialization procedure 
The operation of a mouse is more complex than that of a keyboard. It has different operation 
modes. The most commonly used one is the stream mode, in which a mouse sends the 
movement data when it detects movement or button activity. If the movement is continuous, 
the data is generated at the designated sample rate. 
During the operation, a host can send commands to a mouse to modify the default values 
of various parameters and set the operation mode, and a mouse may generate the status and 
send an acknowledgment. For our purposes, the default values are adequate, and the only 
task is to set the mouse to the stream mode. 
The basic interaction sequence between a PS2 mouse and the FPGA host consists of the 
following: 

PS2 TRANSMITTING SUBSYSTEM 
201 
Figure 9.1 Host-to-device timing diagram of a PS2 port. 
1. At power-on, a mouse performs a power-on test internally. The mouse sends l-byte 
data AA, which indicates that the test is passed, and then l-byte data 00, which is the 
id of a standard PS2 mouse. 
2. The FPGA host sends the command, F4, to enable the stream mode. The mouse will 
respond with FE to acknowledge acceptance of the command. 
3. The mouse now enters the stream mode and sends normal data packets. 
If a mouse is plugged into the FPGA prototyping board in advance, it performs the power- 
on test when the power of the board is turned on and sends the AA 00 data immediately. 
The FPGA chip is not configured at this point and will not receive this data. Thus, we can 
usually ignore the power-on message in step 1. A minimal mouse interface circuit only 
needs to send the F4 command, check the FE acknowledge, and enter the normal operation 
mode to process the mouse’s regular data packet. 
We can force the mouse to return to the initial state by sending the reset command: 
1. The FPGA host sends the command, FF, to reset the mouse. The mouse will respond 
2. The mouse performs a power-on test internally and then sends AA 00. The stream 
Newer mouses add more functionality, such as a scrolling wheel and additional buttons, 
and thus send more information. Additional bytes are appended to the original 3-byte data 
to accommodate these new features. 
with FE to acknowledge acceptance of the command. 
mode will be disabled during the process. 
9.3 PS2 TRANSMITTING SUBSYSTEM 
9.3.1 Host-to-PS2-device communication protocol 
Host-to-PS2-device communication protocol involves bidirectional data exchange. The 
mouse’s data and clock lines actually are open-collector circuits. For our design purposes, 
we treat them as tri-state lines. The basic timing diagram of transmitting a packet from a 
host to a PS2 device is shown in Figure 9.1, in which the data and clock signals are labeled 
ps2d and ps2c. For clarity, the diagram is split into two parts to show which activities are 
generated by the host (i.e., the FPGA chip) and which activities are generated by the device 
(i.e., mouse). The basic operation sequence is as follows: 

202 
PSZMOUSE 
PS2 
transmitting 
circuit 
tri-d 
Figure 9.2 Tri-state buffers of the PS2 transmission subsystem. 
1. The host forces the ps2c line to be ’0’ for at least 100 ps to inhibit any mouse activity. 
It can be considered that the host requests to send a packet. 
2. The host forces the ps2d line to be ’0’ and disables the ps2c line (i.e., makes it high 
impedance). This step can be interpreted as the host sending a start bit. 
3. The PS2 device now takes over the ps2c line and is responsible for future PS2 clock 
signal generation. After sensing the starting bit, the PS2 device generates a ’ 1 ’-to-’0’ 
transition. 
4. Once detecting the transition, the host shifts out the least significant data bit over the 
ps2d line. It holds this value until the PS2 device generates a ’1’-to-’0’ transition in 
the ps2c line, which essentially acknowledges retrieval of the data bit. 
5. Repeat step 4 for the remaining 7 data bits and 1 parity bit. 
6. After sending the parity bit, the host disables the ps2d line (Lee, makes it high 
impedance). The PS2 device now takes over the ps2d line and acknowledges com- 
pletion of the transmission by asserting the ps2d line to ’0’. If desired, the host can 
check this value at the last ’1’-to-’0’ transition in the ps2c line to verify that the 
packet is transmitted successfully. 
9.3.2 Design and code 
Unlike the receiving subsystem, the ps2c and ps2d signals communicate in both directions. 
A tri-state buffer is needed for each signal. The tri-state interface is shown in Figure 9.2. 
The t r i - c  and t r i - d  signals are enable signals that control the tri-state buffers. When 
they are asserted, the corresponding ps2c-out and ps2d-out signals will be routed to the 
output ports. 
To design the transmitting subsystem, we can follow the sequence of the preceding 
protocol to create an ASMD chart, as shown in Figure 9.3. The FSMD is initially in the 
i d l e  state. To start the transmission, the host asserts the wr-ps2 signal and places the data 
on the din bus. The FSMD loads din, along with the parity bit, par to the shift-reg 
register, loads the “1. . - 1” to c-reg, and moves to the rts (for “request to send”) state. In 
this state, the ps2c-out is set to ’0’ and the corresponding t r i - c  is asserted to enable the 
corresponding tri-state buffer. The c-reg is used as a 13-bit counter to generate a 164-ps 
delay. The FSMD then moves to the s t a r t  state, in which the PS2 clock line is disabled 
and the data line is set to ’1’. The PS2 device (i.e., mouse) now takes over and generates 

PSZ TRANSMITTING SUBSYSTEM 
203 
default: ps2c-out 
1 
ps2d-out 
1 
tri-c = 0 
tri-d 
0 
............... 
....... 
i 
b t 
par & din 
(-) - 
.......................... 
~ <Ti 
c t 
c-I 
F - 
T 
. ........................... 
ps2d-out <= 0 
T 
.......................... 
...., 
Figure 9.3 ASMD chart of the PS2 transmitting subsystem. 

204 
PS2MOUSE 
clock signal over the ps2c line. After detecting the falling edge of the ps2c signal through 
the f all-edge signal, the FSMD goes to the data state and shifts 8 data bits and 1 parity 
bit. The n register is used to keep track of the number of bits shifted. The FSMD then 
moves to the s t o p  state, in which the data line is disabled, It returns to the idle state after 
sensing the last falling edge. 
The FSMD also includes a tx-idle signal to indicate whether a transmission is in 
progress. This signal can be used to coordinate operation between the receiving and trans- 
mitting subsystems. The code follows the ASMD chart and is shown in Listing 9.1. A 
filtering circuit similar to that of Section 8.2 is used to generate the f all-edge signal. 
Listing 9.1 PS2 port transmitter 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  ps2-tx i s  
5 
port ( 
clk, reset: in 
std-logic; 
din: in std-logic-vector (7 downto 0) ; 
wr-ps2: std-logic; 
ps2d, ps2c : inout std-logic ; 
tx-done-tick: out std-logic 
10 
tx-idle: out std-logic; 
) ;  
end ps2-tx; 
15 a r c h i t e c t u r e  arch of ps2-tx i s  
type statetype i s  (idle, rts, start, data, stop); 
s i g n a l  state-reg , state-next: statetype; 
s i g n a l  f ilter-reg , f ilter-next : std-logic-vector ( 7  downto 0 )  ; 
s i g n a l  f_ps2c_reg, 
f _ps2c_next : std-logic; 
s i g n a l  b-reg , b-next : std-logic-vector (8 downto 0) ; 
s i g n a l  c-reg , c-next : unsigned (12 downto 0) ; 
s i g n a l  n-reg ,n-next : unsigned (3 downto 0) ; 
s i g n a l  par: std-logic; 
s i g n a l  tri-c , tri-d: std-logic ; 
20 
s i g n a l  f all-edge : std-logic ; 
25 
s i g n a l  ps2c-out , ps2d-out : std-logic; 
begin 
_____________---________________________--------- 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ~ ~ ~ ~ ~ _ ~ ~ ~  
-- 
-- f i l t e r  a n d  f a l l i n g - e d g e  
t i c k  g e n e r a t i o n  f o r  p s 2 c  
process (clk , reset) 
begin 
if reset=’l’ then 
30 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
f ilter-reg <= ( o t h e r s = >  ’ 0 ’ )  ; 
e 1 s i f 
(clk ’ event and clk= ’ 1 ’ ) then 
35 
f -ps2c_reg <= ’ 0  ’ ; 
filter-reg <= filter-next; 
f-ps2c-reg <= f-ps2c-next; 
end i f ;  
40 
end p r o c e s s ;  

ps2 TRANSMITING 
SUBSYSTEM 
205 
45 
f i l t e r - n e x t  <= ps2c & f i l t e r - r e g ( 7  downto 1); 
f - p s 2 c - n e x t  
<= ’1’ when f i l t e r ~ r e g = ” l l l l l l l l ”  
e l s e  
’ 0 ’  when f i l t e r ~ r e g = “ 0 0 0 0 0 0 0 0 “  e l s e  
f - p s 2 c - r e g ;  
f a l l - e d g e  <= f - p s a c - r e g  
and ( n o t  f - p s 2 c - n e x t ) ;  
-- f s m d  
50 
-- 
55 
60 
_- 
r e g i s t e r s  
process ( c l k  , r e s e t  
begin 
if r e s e t = ’ l ’  then 
s t a t e - r e g  <= i d l e ;  
c - r e g  <= ( o t h e r s = >  ’ 0  ’ 1 ; 
n - r e g  
<= ( o t h e r s = > ’ O ’ ) ;  
b - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
c - r e g  <= c - n e x t ;  
n - r e g  <= n - n e x t ;  
b - r e g  <= b - n e x t ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end i f  ; 
65 
end p r o c e s s ;  
-- odd p a r i t y  b i t  
p a r  <= not ( d i n ( 7 )  xor d i n ( 6 )  xor d i n ( 5 )  xor d i n ( 4 )  xor 
-- f s m d  n e x t - s t a t e  
l o g i c  and d a t a  p a t h  l o g i c  
process ( s t a t e - r e g  , n - r e g  , b - r e g  , c-reg , w r _ p s 2 ,  
begin 
d i n ( 3 )  xor d i n ( 2 )  xor d i n ( 1 )  xor d i n ( 0 ) ) ;  
70 
d i n ,  p a r ,  f a l l - e d g e )  
s t a t e - n e x t  <= s t a t e - r e g ;  
c - n e x t  <= c - r e g ;  
75 
80 
85 
90 
n-next 
<= n - r e g ;  
b-next <= b - r e g ;  
t x - d o n e - t i c k  
< = ’ O ’ ;  
ps2d-out 
<= ’ 1 ’ ;  
t r i - c  <= 
> O ’ ;  
t r i - d  <= ’ 0 ’ ;  
t x - i d l e  
< = ’ O ’ ;  
case s t a t e - r e g  i s  
when i d l e  => 
p s 2 c - o u t  
(= ’ 1 ’ ;  
t x - i d l e  <= ’1’; 
i f  w r _ p s 2 = ’ 1 ’  then 
b-next <= p a r  & d i n ;  
c - n e x t  <= ( o t h e r s = > ’ l ’ ) ;  -- 2 * 1 3 - 1  
s t a t e - n e x t  <= r t s ;  
when r t s  => -- r e q u e s t  t o  send 
end i f  ; 
p s 2 c - o u t  <= ’ 0 ’ ;  
t r i - c  <= ’1’; 
c-next 
<= c - r e g  - 1; 

206 
PS2MOUSE 
95 
I15 
i f  ( c - r e g = O )  then 
end i f  ; 
p s 2 d - o u t  
<= ) O ) ;  
t r i - d  <= ’ 1 ’ ;  
i f  f a l l - e d g e = ’  1 ’ then 
s t a t e - n e x t  <= s t a r t ;  
when s t a r t  = >  -- a s s e r t  s t a r t  bit 
n - n e x t  <= “ 1 0 0 0 ” ;  
s t a t e - n e x t  <= d a t a ;  
end i f  ; 
when d a t a  => -- 8 d a t a  + I 
p a r i t y  
p s 2 d - o u t  
<= b - r e g  ( 0 )  ; 
t r i - d  <= ) l ’ ;  
i f  f a l l - e d g e = ’ l ’  then 
b - n e x t  
<= ’ 0 )  & b - r e g ( 8  downto 1); 
i f  n - r e g  = 0 then 
e l s e  
end i f  ; 
s t a t e - n e x t  <= s t o p ;  
n - n e x t  
<= n - r e g  - 1; 
end i f  ; 
i f  f a l l - e d g e = ’ l ’  then 
when s t o p  = >  -- assume f l o a t i n g  h i g h  f o r  p s 2 d  
s t a t e - n e x t  <= i d l e ;  
t x - d o n e - t i c k  
<=’1); 
I20 
end i f  ; 
end c a s e ;  
end p r o c e s s ;  
t r i  - s t a t e  
b u f f e r s  
p s 2 c  <= p s 2 c - o u t  when t r i - c  = ’ I ’  e l s e  ) Z  ; 
125 
p s 2 d  <= p s 2 d - o u t  when t r i - d  = ) l ’  e l s e  )Z’; 
-- 
end a r c h ;  
There is no error detection circuit in this code. A more robust design should check the 
correctness of the parity and acknowledgment bits and include a watchdog timer to prevent 
the mouse from being locked in an incorrect state. 
9.4 BIDIRECTIONAL PS2 INTERFACE 
9.4.1 
Basic design and code 
We can combine the receiving and transmitting subsystems to form a bidirectional PS2 
interface. The top-level diagram is shown in Figure 9.4. We use the tx-idle and rx-en 
signals to coordinate the transmitting and receiving operations. Priority is given to the 
transmitting operation. When the transmitting subsystem is in operation, the tx-idle signal 
is deasserted, which, in turn, disables the receiving subsystem. The receiving subsystem 
can process input only when the transmitting subsystem is idle. The corresponding HDL 
code is shown in Listing 9.2. 

BIDIRECTIONAL ps2 INTERFACE 
207 
Figure 9.4 
Top-level block diagram of a bidirectional PS2 interface. 
Listing 9.2 Bidirectional PS2 interface 
library ieee; 
use ieee. std-logic-1164, all ; 
entity ps2-rxtx is 
port ( 
5 
clk, reset: in std-logic; 
wr-ps2 : std-logic; 
din: in std-logic-vector ( 7  downto 0) ; 
dout : out std-logic-vector (7 downto 0 )  ; 
rx-done-tick : out 
std-logic ; 
ps2d, ps2c : inout std-logic 
10 
tx-done-tick: out std-logic; 
) ;  
end ps2-rxtx; 
15 architecture arch of ps2-rxtx i s  
signal tx-idle : std-logic; 
ps2-tx-unit : entity work. ps2_tx(arch) 
begin 
port map(clk=>clk, reset=>reset , wr_ps2=>wr_ps2, 
20 
din=>din, ps2d=>ps2d, ps2c=>ps2c, 
tx-idle=>tx-idle, tx-done-tick=>tx-done-tick); 
ps2-rx-unit : entity work. ps2-rx (arch) 
port map(clk=>clk , reset=>reset , rx-en=>tx-idle, 
ps2d=>ps2d, ps2c=>ps2c, 
25 
rx-done-tick=>rx-done-tick, dout=>dout); 
end arch; 

208 
PS2MOUSE 
Figure 9.5 
Block diagram of a mouse monitor circuit. 
9.4.2 Verification circuit 
We create a testing circuit to verify and monitor operation of the bidirectional interface. 
The block diagram is shown in Figure 9.5. A command is transmitted manually. We use 
the 8-bit switch to specify the data (i.e., the command from the host) and use a pushbutton 
to generate a one-clock-cycle tick to transmit the packet. The received packet data is first 
passed to the byte-to-ascii circuit, which converts the data into two ASCII characters 
plus a blank space. The characters are then transmitted via the UART and displayed in 
Windows HyperTerrninal. The HDL code is shown in Listing 9.3. 
Listing 9.3 Bidirectional PS2 interface monitor circuit 
library ieee; 
use ieee. std-logic-1164. all ; 
use ieee. numeric-std. all ; 
entity ps2-monitor i s  
5 
port ( 
clk, reset: in 
std-logic; 
sw: in std-logic-vector ( 7  downto 0 )  ; 
btn: in std-logic-vector (2 downto 0) ; 
ps2d, ps2c : inout 
std-logic ; 
10 
tx : out 
std-logic 
) ;  
end ps2-monitor; 
architecture arch of ps2-monitor is 
15 
constant SP: std-logic-vector (7 downto 0) : = " 0 0 1 0 0 0 0 0 " ;  
-- blank s p a c e  i n  ASCII 
type state-type is (idle, sendh, sendl, sendb); 
signal state-reg , state-next : state-type; 
signal rx-data , w-data: std-logic-vector ( 7  downto 0 )  ; 
signal wr-ps2, wr-uart : std-logic; 
signal ascii-code : std-logic-vector (7 downto 0) ; 
signal hex-in: std-logic-vector (3 downto 0) ; 
20 
signal psrx-done-tick: std-logic ; 
begin __-_____________--__----------------------- 
________________________________________--- 
25 
-- 
-- i n s t a n t i a t i o n  
btn-db-unit: entity work. debounce(fsmd-arch) 
___________________-____________________--- 
--______________________________________----- 
port map(clk=>clk, reset=>reset , sw=>btn(O), 
30 
db-level=>open, dbdtick=>wr-ps2); 

BIDIRECTIONAL PSZ INTERFACE 
209 
p s 2 - r x t x - u n i t  : e n t i t y  work. p s 2 _ r x t x ( a r c h )  
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , w r _ p s 2 = > w r _ p s 2 ,  
d i n = > s w ,  d o u t = > r x - d a t a  , p s 2 d = > p s 2 d ,  
p s 2 c = > p s 2 c t  rx-done-tick=>psrx-done-tick, 
3s 
t x - d o n e - t i c k = > o p e n ) ;  
__ o n l y  use t h e  UART t r a n s m i t t e r  
u a r t - u n i t :  e n t i t y  w o r k . u a r t  ( s t r - a r c h )  
g e n e r i c  map (FIFO-W= >4) 
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , r d - u a r t = > ’ O ’ ,  
10 
w r - u a r t = > w r - u a r t ,  r x = > ’ l ’ ,  w-data= > w-data, 
t x - f u l l = > o p e n  , rx-empty=>open , r - d a t a = > o p e n  , 
t x = > t x ) ;  
-- FSM t o  send 3 ASCII c h a r a c t e r s  
--____-------_____------------------------- 
--__________________------------------_------ 
_________________-__------_---------------- 
_____-_________-____----------------------- 
4s 
-- 
Mi 
65 
70 
7 5  
-- s t a t e  r e g i s t e r s  
p r o c e s s  ( c l k  , r e s e t )  
begin  
i f  r e s e t = ’ l ’  t h e n  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  t h e n  
end i f  ; 
end p r o c e s s ;  
p r o c e s s  ( s t a t e - r e g  , p s r x - d o n e - t i c k  , a s c i i - c o d e )  
begin  
s t a t e - r e g  <= i d l e ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
ss 
-- n e x t - s t a t e  
l o g i c  
w r - u a r t  <= ’ 0 ’ ;  
w-data <= S P ;  
s t a t e - n e x t  <= s t a t e - r e g ;  
c a s e  s t a t e - r e g  i s  
when i d l e  => 
i f  p s r x - d o n e - t i c k = ’  1 ’ t h e n  
s t a t e - n e x t  <= s e n d h ;  
end i f  ; 
w-data <= a s c i i - c o d e ;  
w r - u a r t  <= ’1’; 
s t a t e - n e x t  <= s e n d l ;  
w-data <= a s c i i - c o d e ;  
w r - u a r t  <= ’ 1 ) ;  
s t a t e - n e x t  <= s e n d b ;  
w-data <= S P ;  
w r - u a r t  <= ’ I ) ;  
s t a t e - n e x t  <= i d l e ;  
when s e n d h  => -- send h i g h e r  hex char 
when s e n d l  => -- send lower hex char 
when s e n d b  => -- send blank space c h a r  
end c a s e ;  
end p r o c e s s ;  
-- scan code t o  A S C I I  d i s p l a y  
-- s p l i t  t h e  scan code i n t o  two 4 - b i t  
hex 
80 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
____________________----------------------- 
____________________-------------------_--- 
-- 

210 
PSZMOUSE 
90 
YS 
hex-in <= rx-data (7 downto 4) when state-reg=sendh e l s e  
85 
rx-data (3 downto 0) ; 
-- h e x  d i g i t  t o  ASCII code 
with hex-in s e l e c t  
ascii-code <= 
" 0 0 1 1 0 0 0 0 "  when " O O O O " ,  -- 0 
" 0 0 1 1 0 0 0 1 "  when "OOOl", -- I 
"00110010" when "OOlO", -- 2 
'100110011" when " O O l l " ,  -- 3 
"0011010011 when 1 ' 0 1 0 0 " ,  -- 4 
" 0 0 1 1 0 1 0 1 "  when 1 ' 0 1 0 1 " ,  -- 5 
" 0 0 1 1 0 1 1 0 "  when 
" O 1 l O t ' ,  
-- 6 
1'00110111'1 
when " O l l l " ,  -- 7 
" 0 0 1 1 1 0 0 0 1 ~  when 1 1 1 0 0 0 " ,  -- 8 
110011100111 
when 
t l l O O 1 " ,  
-- 9 
~ t O I O O O O O 1 l ~  when " 1 0 1 O 1 l ,  -- A 
" 0 1 0 0 0 0 1 1 "  when ' 1 1 1 0 0 " ,  -- C 
" 0 1 0 0 0 1 0 0 "  when " 1 1 0 1 " ,  -- D 
"O1OO01Ol1' when " 1 1 1 0 " ,  
-- E 
" 0 1 0 0 0 1 1 0 "  when o t h e r s ;  -- F 
IW 
" 0 1 0 0 0 0 1 0 "  when " 1 0 1 1 " ,  -- B 
I05 end a r c h ;  
If a mouse is connected to the PS2 circuit, we can first issue the FF command to reset the 
mouse and then issue the F4 command to enable the stream mode. Windows HyperTerminal 
will show the mouse's acknowledge packets and subsequent mouse movement packets. 
9.5 
PS2 MOUSE INTERFACE 
9.5.1 Basic design 
The basic PS2 mouse interface creates another layer over the bidirectional PS2 circuit. Its 
two basic functions are to enable the stream mode and to reassemble the 3 data bytes. The 
output of the circuit are xm and ym, which are two 9-bit x- and y-axis movement signals; 
btm, which is the 3-bit button status signal; and m-done-tick, which is a one-clock-cycle 
status signal and is asserted when the assembled data is available. 
The HDL code is shown in Listing 9.4. It is implemented by an FSMD with seven states. 
The i n i t l ,  i n i t 2 ,  and i n i t 3  states are executed once after the r e s e t  signal is asserted. 
In these states, the FSMD issues the F4 command, waits for completion of the transmission, 
and then waits for the acknowledgment packet. The mouse is in the stream mode now. The 
FSMD then obtains and assembles the next three packets in the packl, pack2, and pack3 
states, and activates the m-done-tick signal in the done state. The FSMD circulates these 
four states afterward. 
Listing 9.4 Basic mouse interface circuit 
l i b r a r y  i e e e ;  
use i e e e .  std-logic-1164. a l l  ; 
use i e e e .  numeric-std. a l l  ; 
e n t i t y  mouse i s  
5 
port ( 
c l k ,  r e s e t :  in 
std-logic; 

PS2 MOUSE INTERFACE 
21 1 
ps2d, ps2c : inout std-logic ; 
xm, ym: out std-logic-vector ( 8  downto 0 )  ; 
btnm: out std-logic-vector (2 downto 0 )  ; 
10 
m-done-tick : out std-logic 
1 ;  
end mouse; 
30 
40 
45 
55 
a r c h i t e c t u r e  arch of mouse i s  
15 
constant STRM: std-logic-vector (7 downto 0 )  : = “ 1 1 1 1 0 1 0 0 ”  ; 
-- stream command F4 
type state-type i s  (initl, init2, init3, 
s i g n a l  state-reg , state-next : state-type; 
zo 
s i g n a l  rx-data: std-logic-vector (7 downto 0 )  ; 
s i g n a l  rx-done-tick , tx-done-tick: std-logic; 
s i g n a l  wr-ps2 : std-logic; 
s i g n a l  x-reg , y-reg : std-logic-vector ( 8  downto 0) ; 
s i g n a l  x-next , y-next : std-logic-vector (8 downto 0 )  ; 
25 
s i g n a l  btn-reg , btn-next : std-logic-vector ( 2  downto 0 )  ; 
pack1 , pack2, pack3, done) ; 
begin 
__ i n s t a n t i a t i o n  
ps2-rxtx-unit : e n t i t y  work. ps2-rxtx (arch) 
port map(clk=>clk , reset=>reset , wr-ps2=>wr-ps2, 
din=>STRM , dout=>rx-data , 
ps2d=>ps2d, ps2c=>ps2c, 
rx-done_tick=>rx-done-tick, 
tx-done-tick=>tx-done-tick); 
-_ 
s t a t e  and data r e g i s t e r s  
begin 
35 
process (clk, reset) 
i f  reset = 1 
then 
state-reg <= initl; 
x-reg <= ( o t h e r s = >  ’ 0  J ) ;  
y-reg <= ( o t h e r s = > ’ O ’ ) ;  
btn-reg <= ( o t h e r s = > ’ O ’ ) ;  
state-reg <= state-next ; 
x-reg <= x-next; 
y-reg <= y-next; 
btn-reg <= btn-next ; 
e l s i f  (clk’event and clk=’lJ) then 
end i f  ; 
end p r o c e s s ;  
next - s t a  t e  
1 o g  i c  
-_ 
50 
process (state-reg ,rx-done-tick, tx-done-tick, 
x-reg ,y-reg, 
btn-reg, rx-data) 
begin 
wr-ps2 <= ’ 0 ’ ;  
m-done-tick <= ’ 0 ’ ;  
x-next <= x-reg; 
y-next <= y-reg; 
btn-next <= btn-reg ; 
state-next <= state-reg; 
case state-reg i s  

212 
PS2MOUSE 
65 
70 
75 
KO 
85 
90 
60 
when i n i t l = >  
wr-ps2 <= ’1’; 
s t a t e - n e x t  <= i n i t 2 ;  
i f  t x - d o n e - t i c k = ’ l ’  then 
end i f  ; 
i f  r x - d o n e - t i c k = ’ l ’  then 
end i f  ; 
i f  r x - d o n e - t i c k = ’ l ’  then 
when i n i t 2 = >  -- w a i t  f o r  send t o  c o m p l e t e  
s t a t e - n e x t  <= i n i t 3 ;  
when i n i t 3 = >  -- w a i t  f o r  a c k n o w l e d g e  p a c k e t  
s t a t e - n e x t  <= p a c k l  ; 
when p a c k l = >  -- w a i t  f o r  1 s t  d a t a  p a c k e t  
s t a t e - n e x t  <= p a c k 2 ;  
y - n e x t  (8) <= r x - d a t a  (5) ; 
x - n e x t  (8) <= r x - d a t a  ( 4 )  ; 
b t n - n e x t  <= 
r x - d a t a ( 2  downto 0 ) ;  
end i f  ; 
i f  r x - d o n e - t i c k = ’ l ’  then 
when p a c k 2 = >  -- w a i t  f o r  2 n d  d a t a  p a c k e t  
s t a t e - n e x t  <= p a c k 3 ;  
x - n e x t ( 7  downto 0) <= r x - d a t a ;  
end i f  ; 
i f  r x - d o n e - t i c k = ’ l ’  then 
s t a t e - n e x t  <= d o n e ;  
y - n e x t ( 7  downto 0 )  <= r x - d a t a ;  
when p a c k 3 = >  -- w a i t  f o r  3 r d  d a t a  p a c k e t  
end i f  ; 
when done => 
m-done-tick 
<= ’ 1 ’ ;  
s t a t e - n e x t  <= p a c k l ;  
end c a s e ;  
end p r o c e s s ;  
xm 
<= x - r e g ;  
ym 
<= y - r e g ;  
9s 
btnm <= b t n - r e g ;  
end a r c h ;  
This design provides only minimal functionalities. A more sophisticated circuit should 
have a robust method to initiate the stream mode and add additional buffer, similar to that 
in Section 7.2.4, to interact better with the external system. 
9.5.2 Testing circuit 
We use a simple testing circuit to demonstrate the use of the PS2 interface. The circuit uses 
a mouse to control the eight discrete LEDs of the prototyping board. Only one of the eight 
LEDs is lit and the position of that LED follows the x-axis movement of the mouse. The 
pressing of the left or right button places the lit LED to the leftmost or rightmost position. 
The HDL code is shown in Listing 9.5. It uses a 10-bit counter to keep track of the 
current x-axis position. The counter is updated when a new data item is available (ie., 
when the m-done-tick signal is asserted). The counter is set to 0 or maximum when the 
left or right mouse button is pressed. Otherwise, it adds the amount of the signed-extended 

PSZ MOUSE INTERFACE 
213 
x-axis movement. A decoding circuit uses the three MSBs of the counter to activate one of 
the LEDs. 
Listing 9.5 
Mouse-controlled LED circuit 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  mouse-led i s  
s 
p o r t  ( 
clk, reset: i n  
std-logic; 
ps2dt ps2c : i n o u t  std-logic; 
led: o u t  std-logic-vector ( 7  downto 0) 
1 ;  
10 end mouse-led; 
a r c h i t e c t u r e  arch of mouse-led i s  
s i g n a l  p-reg , p-next : unsigned (9 downto 0 )  ; 
s i g n a l  xm: std-logic-vector (8 downto 0 )  ; 
s i g n a l  m-done-tick: std-logic; 
15 
s i g n a l  btnm: std-logic-vector (2 downto 0) ; 
begin 
__ i n s t a n t i a t i o n  
20 
mouse-unit: e n t i t y  work.mouse(arch) 
p o r t  map(clk=>clk, reset=>reset , 
ps2d=>ps2d, ps2c=>ps2c, 
xm=>xm, ym=>open , btnm=>btnm , 
m-done-tick=>m-done-tick); 
25 
-- r e g i s t e r  
p r o c e s s  (clk , reset) 
begin 
if reset='l' t h e n  
p-reg <= ( o t h e r s = >  ' 0  '1 ; 
p-reg <= p-next; 
?n 
e l s i f  (clk'event and clk='l') t h e n  
end if ; 
end p r o c e s s ;  
c o u n t e r  
-- 
35 
p-next <= p-reg when m-done-tick='O' e l s e  
110000000000" when btnm(O)='l ' e l s e  - - l e f t  
b u t t o n  
'tllllllllll" 
when btnm(l)= '1 ' e l s e  --right 
b u t t o n  
p-reg + unsigned(xm(8) 
& xm); 
40 
with p-reg(9 downto 7 )  s e l e c t  
led <= "10000000" when 
" O O O " ,  
'I 0 1 0  00 0 00 I' when 
It 00 1 It , 
"00100000" when " 0 1 0 "  , 
'I 000 1000 0 I' when 
I' 0 11 '' , 
"00001000" when 
t ' l O O " ,  
I' 00000 100 I' when 
It 10 1 It , 
'I 0 0 0 0 0 0 1 0 I' when 
It 1 1 0 I' , 
" 0 0 0 0 0 0 0 1 ' ~  when o t h e r s ;  
end arch; 
45 

214 
PS~MOUSE 
9.6 BIBLIOGRAPHIC NOTES 
The bibliographic information for this Chapter is similar to that for Chapter 8. 
9.7 SUGGESTED EXPERIMENTS 
The mouse is used mainly with a graphic video interface, which is discussed in Chapters 12 
and 13. Many additional mouse-related experiments can be found in these chapters. 
9.7.1 
Keyboard control circuit 
A host can issue a command to set certain parameters for a PS2 keyboard as well. For 
example, we can control the three LEDs of the keyboard by sending ED OX. The X is a 
hexadecimal number with a format of “Osnc”, where s, n, and c are l-bit values that control 
the Scroll, Num, and Caps Lock LEDs, respectively. We can incorporate this feature into 
the keyboard interface circuit of Section 8.4.1 and use a 3-bit switch to control the three 
keyboard LEDs. Design the expanded interface circuit, resynthesize the circuit, and verify 
its operation. 
9.7.2 Enhanced mouse interface 
For the mouse interface discussed in Section 9.5, we can alter the design to manually 
enable or disable the steam mode. This can be done by using two pushbuttons of the FPGA 
prototyping board. One button issues the reset command, FF, which disables the stream 
mode during operation, and the other button issues the F4 command to enable the steam 
mode. Modify the original interface to incorporate this feature, and resynthesize the LED 
testing circuit to verify its operation. 
9.7.3 Mouse-controlled seven-segment LED display 
We can use the mouse to enter four decimal digits on the four-digit seven-segment LED 
display. The circuit functions as follows: 
0 Only one of the four decimal points of the LED display is lit. The lit decimal point 
0 The location of the selected digit follows the x-axis movement of the mouse. 
0 The content of the select seven-segment LED display is a decimal digit (i.e., 0, . . ., 9) 
indicates the location of the selected digit. 
and changes with the y-axis movement of the mouse. 
Design and synthesize this circuit and verify its operation. 

CHAPTER 10 
EXTERNAL SRAM 
10.1 INTRODUCTION 
Random access memory (RAM) is used for massive storage in a digital system since a RAM 
cell is much simpler than an FF cell. A commonly used type of RAM is the asynchronous 
static RAM (SRAM). Unlike a register, in which the data is sampled and stored at an edge 
of a clock signal, accessing data from an asynchronous SRAM is more complicated. A 
read or write operation requires that the data, address, and control signals be asserted in 
a specific order, and these signals must be stable for a certain amount of time during the 
operation. 
It is difficult for a synchronous system to access an SRAM directly. We usually use 
a memory controller as the interface, which takes commands from the main system syn- 
chronously and then generates properly timed signals to access the SRAM. The controller 
shields the main system from the detailed timing and makes the memory access appears 
like a synchronous operation. The performance of a memory controller is measured by the 
number of memory accesses that can be completed in a given period. While designing a 
simple memory controller is straightforward, achieving optimal performance involves many 
timing issues and is quite difficult. 
The S3 board has two 256K-by-16 asynchronous SRAM devices, which total 1M bytes. 
In this chapter, we demonstrate the construction of a memory controller for these devices. 
Since the timing characteristics of each RAM device are different, the controller is applicable 
only to this particular device. However, the same design principle can be used for similar 
FPGA Prototjping bj. VHDL Examples. By Pang F? Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
21 5 

216 
EXTERNAL SRAM 
SRAM devices. The Xilinx Spartan-3 device also contains smaller embedded memory 
blocks. The use of this memory is discussed in Chapter 11. 
10.2 SPECIFICATION OF THE IS61 LV25616AL SRAM 
10.2.1 Block diagram and I/O signals 
The S3 board has two IS61LV25616AL devices, which are 256K-by-16 SRAM manufac- 
tured by Integrated Silicon Solution, Inc. (ISSI). A simplified block diagram is shown in 
Figure lO.l(a). This device has an 18-bit address bus, ad, a bidirectional 16-bit data bus, 
dio, and five control signals. The data bus is divided into upper and lower bytes, which 
can be accessed individually. The five control signals are: 
0 c e n  (chip enable): disables or enables the chip 
0 wen (write enable): disables or enables the write operation 
0 o e n  (output enable): disables or enables the output 
0 l b n  (lower byte enable): disables or enables the lower byte of the data bus 
0 u b n  (upper byte enable): disables or enables the upper byte of the data bus 
All these signals are active low and the n suffix is used to emphasize this property. The 
functional table is shown in Figure lO.l(b). The c e n  signal can be used to accommodate 
memory expansion, and the wen and o e n  signals are used for write and read operations. 
The l b n  and u b n  signals are used to facilitate the byte-oriented configuration. 
In the remainder of the chapter, we illustrate the design and timing issues of a memory 
controller. For clarity, we use one SRAM device and access the SRAM in 16-bit word 
format. This means that the c e n ,  l b n ,  and u b n  signals should always be activated (i.e., 
tied to '0'). The simplified functional table is shown in Figure lO.l(c). 
10.2.2 Timing parameters 
The timing characteristics of an asynchronous SRAM are quite complex and involve more 
than two dozen parameters. We concentrate only on a few key parameters that are relevant 
to our design. 
The simplified timing diagrams for two types of read operations are shown in Fig- 
ure 10.2(a) and (b). The relevant timing parameters are: 
0 ~ R C :  
read cycle time, the minimal elapsed time between two read operations. It is 
about the same as t A A  for SRAM. 
0 ~ A A :  address access time, the time required to obtain stable output data after an 
address change. 
0 t o H A :  output hold time, the time that the output data remains valid after the address 
changes. This should not be confused with the hold time of an edge-triggered FF, 
which is a constraint for the d input. 
t D O E :  output enable access time, the time required to obtain valid data after o e n  is 
activated. 
0 t H Z O E :  output enable to high-Z time, the time for the tri-state buffer to enter the 
high-impedance state after o e n  is deactivated. 
0 t L Z O E :  output enable to low-Z time, the time for the tri-state buffer to leave the 
high-impedance state after o e n  is activated. Note that even when the output is no 
longer in the high-impedance state, the data is still invalid. 
Values of these parameters for the IS61LV25616AL device are shown in Figure 10.2(c). 

SPECIFICATION OF THE 1561LV25616AL SRAM 
217 
, 
ad 
/ 
t 
18 
256K-by-16 
cell array 
decoder/ 
multiplexer 
+ 
Operation 
c e n  wen 
o e n  
l b n  u b n  
dio(1ower) 
dio(upper) 
ce-n 
b 
we-n 
oe-n 
: 
Ib-n 
b 
ub-n - 
disabled 
1 
0 
1 
1 
0 
1 
1 
control circuit 
Z 
Z 
Z 
Z 
Z 
Z 
read 
0 
1 
0 
0 
1 
data out 
Z 
0 
1 
0 
1 
0 
Z 
data out 
0 
1 
0 
0 
0 
data out 
data out 
write 
0 
0 
0 
1 
data in 
0 
0 
1 
0 
Z 
0 
0 
0 
0 
data in 
Z 
data in 
data in 
(b) Functional table 
Operation 
wen 
o e n  d i o  (16 bits) 
output disabled 
1 
1 
Z 
read 16-bit word 
1 
0 
data out 
write 16-bit word 
0 
data in 
(c) Simplified functional table 
Figure 10.1 Block diagram and functional table of the ISSI 256K-by-16 SRAM. 

218 
EXTERNAL SRAM 
(b) Timing diagram of an oen-controlled read cycle 
parameter 
min 
max 
tRC 
read cycle time 
10 
- 
~ A A  
address access time 
- 
10 
~ O H A  
output hold time 
2
-
 
  DOE 
output enable access time 
-
4
 
~ H Z O E  
output enable to high-Z time 
- 
4 
~ L Z O E  
output enable to low-Z time 
0 
- 
(c) Timing parameters (in ns) 
Figure 10.2 Timing diagrams and parameters of a read operation. 

SPECIFICATION OF THE IS61LV25616AL SRAM 
219 
(a) Timing diagram of a write cycle 
parameter 
min 
max 
twc 
write cycle time 
10 
- 
t S A  
address setup time 
0 
- 
 HA 
address hold time 
0 
- 
t P W E l  
wen pulse width 
8 
- 
t S D  
data setup time 
6
-
 
~ H D  
data hold time 
0
-
 
(b) Timing parameter (in ns) 
Figure 10.3 Timing diagram and parameters of a write operation. 
The simplified timing diagram for a wen-controlled write operation is shown in Fig- 
ure 10.3(a). The relevant timing parameters are: 
twc: write cycle time, the minimal elapsed time between two write operations. 
t S A :  address setup time, the minimal time that the address must be stable before w e n  
is activated. 
t H A :  address hold time, the minimal time that the address must be stable after wen 
is deactivated. 
tpWE1: wen pulse width, the minimal time that wen must be asserted. 
t s ~ :  
data setup time, the minimal time that data must be stable before the latching 
edge (the edge in which wen moves from '0' to '1'). 
t H D :  data hold time, the minimal time that data must be stable after the latching 
edge. 
The values of these parameters for the IS61LV25616AL device are shown in Figure 10.3(b). 
The complete timing information can be found in the data sheet of the IS61LV25616AL 
device. 

220 
EXTERNAL SRAM 
Figure 10.4 Role of an SRAM memory controller. 
10.3 BASIC MEMORY CONTROLLER 
10.3.1 Block diagram 
The role of a memory controller and its I/O signals are shown in Figure 10.4. The signals 
to the SRAM side are discussed in Section 10.2.1. The signals to the main system side are: 
mem: is asserted to ’ 1 ’ to initiate a memory operation. 
0 rw: specifies whether the operation is a read (’1’) or write (’0’) operation. 
addr: is the 18-bit address. 
0 data-f 2s: is the 16-bit data to be written to the SRAM (the -f 2s suffix stands for 
FPGA to SRAM). 
0 data-s2f -r: is the 16-bit registered data retrieved from the SRAM (the s 2 f  suffix 
stands for SRAM to FPGA). 
0 d a t a s 2 f  -ur: is the 16-bit unregistered data retrieved from SRAM. 
0 ready: is a status signal indicating whether the controller is ready to accept a new 
command. This signal is needed since a memory operation may take more than one 
clock cycle. 
The memory controller basically provides a “synchronous wrap” around the SRAM. 
When the main system wants to access the memory, it places the address and data (for a 
write operation) on the bus and activates the command (i.e., the mem and rw signals). At the 
rising edge of the clock, all signals are sampled by the memory controller and the desired 
operation is performed accordingly. For a read operation, the data becomes available after 
one or two clock cycles. 
The block diagram of a memory controller is shown in Figure 10.5. Its data path contains 
one address register, which stores the address, and two data registers, which store the data 
from each direction. Since the data bus, dio, is a bidirectional signal, a tri-state buffer is 
needed. The control path is an FSM, which follows the timing diagrams and specifications 
in Figures 10.2 and 10.3 to generate a proper control sequence. 

BASIC MEMORY CONTROLLER 
221 
raddr 
addr 
ad 
4 
data-f2s 
+ 
data-s2f-ur 
+ 
data-s2f-r 
m e m q J l  
wr 
T-' 
+ 
+ 
ri-n 
we-n 
I I
Oe-" 
ready 
I 
Figure 10.5 Block diagram of a memory controller. 
10.3.2 Timing requirement 
Although the timing diagrams appear to be complicated at first glance, the control sequences 
are fairly simple. Let us first consider a read cycle. The wen should be deactivated during 
the entire operation. Its basic operation sequence is: 
1. Place the address on the ad bus and activate the o e n  signal. These two signals must 
2. Wait for at least t A A .  The data from the SRAM becomes available after this interval. 
3. Retrieve the data from dio and deactivate the o e n  signal. 
We use the wen-controlled write cycle in our design, as shown in Figure 10.3(a). The 
1. Place the address on the ad bus and data on the dio bus and activate the wen signal. 
2. Wait for at least ~ P W E I .  
3. Deactivate the wen signal, The data is latched to the SRAM at the '0'-to-' 1 ' transition 
edge. 
4. Remove the data from the dio bus. 
Note that t H D  (data hold time after write ends) is 0 ns for this SRAM, which implies that 
it is theoretically possible to remove the data and deactivate wen simultaneously. However, 
because of the variations in propagation delays, this condition cannot be guaranteed in a 
be stable for the entire operation. 
basic operation sequence is: 
These signals must be stable for the entire operation. 

222 
EXTERNAL SRAM 
real circuit. To achieve proper latching, we need to ensure that the wen signal is always 
deactivated first. 
10.3.3 Register file versus SRAM 
We discuss the design of a register file in Section 4.2.3. Its basic storage elements are D FFs 
and thus it is completely synchronous. Although a memory controller wraps the SRAM in 
a synchronous interface, there are several differences: 
0 A register file usually has one write port and multiple read ports. 
0 The read and write ports of a register file can be accessed at the same time (i.e., the 
0 Writing to a register takes only one clock cycle. 
0 Data from a register’s read ports is always available and the read operation involves 
In summary, a register file is faster and more flexible. However, due to the circuit size of 
an FF, a register file is feasible only for small storage. 
read and write operations can be done at the same time). 
no clock or additional control signals. 
10.4 A SAFE DESIGN 
With the block diagram of Figure 10.5, the remaining task is to derive the controller. Our 
first scheme uses a “safe” design, which means that the design provides large timing margins 
and does not impose any stringent timing constraints. The control signals are generated 
directly from the FSM. The controller uses two clock cycles (i.e., 40 ns) to complete memory 
access and requires three clock cycles (i.e., 60 ns) for back-to-back operations. 
10.4.1 ASMD chart 
The ASMD chart for this controller is shown in Figure 10.6. The FSM has five states and is 
initially in the i d l e  state. It starts the memory operation when the mem signal is activated. 
The r w  signal determines whether it is a read or write operation. 
For a read operation, the FSM moves to the r d l  state. The memory address, addr, is 
sampled and stored in the addr-reg register at the transition. The o e n  signal is activated 
in the r d l  and rd2 states. At the end of the read cycle, the FSM returns to the i d l e  state. 
The retrieved data is stored in the data-s2f -reg register at the transition, and the o e n  
signal is deactivated afterward. Note that the block diagram of Figure 10.5 has two read 
ports. The d a t a s 2 f  -r signal is a registered output and becomes available after the FSM 
exits the r 2  state. The data remains unchanged until the end of the next read cycle. The 
data-s2f -ur signal is connected directly to the SRAM’s dio bus. Its data should become 
valid at the end of the rd2 state but will be removed after the FSM enters the i d l e  state. 
In some applications, the main system samples and stores the memory readout in its own 
register, and the unregistered output allows this action to be completed one clock cycle 
earlier. 
For a write operation, the FSM moves to the w r l  state. The memory address, addr, and 
data, data-f 2s, are sampled and stored in the addr-reg and data-f 2s-reg registers at 
the transition. The wen and trin signals are both activated in the w r i  state. The latter 
enables the tri-state buffer to put the data over the SRAM’s dio bus. When the FSM moves 
to the wr2 state, wen is deactivated but trin remains asserted. This ensures that the data 
is properly latched to the SRAM when wen changes from’0’ to ’1’. At the end of the write 

A SAFE DESIGN 
223 
Default: oe-n <= 1; we-n <= 1; tri-n <= 1; ready <= 0 
-
I
4
 
raddr t 
addr a 
............................................................ 
1 
1 
trig <= 0 
. ......................... 
. ...........t............ 
Figure 10.6 ASMD chart of a safe SRAM controller. 
cycle, the FSM returns to the i d l e  state and trin is deactivated to remove data from the 
d i o  bus. 
10.4.2 Timing analysis 
To ensure correct operation of a memory controller, we must verify that the design meets 
various timing requirements. Recall that the FSM is controlled by a 50-MHz clock signal 
and thus stays in each state for 20 ns. 
During the read cycle, o e n  is asserted for two states, totaling 40 ns, which provides 
a 30-ns margin over the 10-ns tAA. Although it appears that o e n  can be deasserted in 
the rd2 state, this imposes a more stringent timing constraint. This issue is explained in 
Section 10.5.3. The data is stored in the data-s2f register when the FSM moves from the 
rd2 state to the i d l e  state. Although o e n  is deasserted at the transition, the data remains 
valid for a small interval because of the FPGA’s pad delay and the t H Z o E  delay of the 
SRAM chip. It can be sampled properly by the clock edge. 
During the write cycle, wen is asserted in the w r l  state, and the 20-11s interval exceeds 
the 8-ns t p W E l  requirement. The trin signal remains asserted in the wr2 state and thus 
ensures that the data is still stable during the ’0’-to-’1’ transition edge of the wen signal. 

224 
EXTERNAL SRAM 
In terms of performance, both read and write operations take two clock cycles to com- 
plete. During the read operation, the unregistered data (i.e., data-s2f -ur) is available 
at the end of the second clock cycle (i.e., just before the rising edge of the second clock 
cycle) and the registered data (i.e., data-s2f -r) is available right after the rising edge of 
the second clock cycle. Although a memory operation can be done in two clocks, the main 
system cannot access memory at this rate. Both read and write operations must return to the 
i d l e  state after completion. The main system must wait for another clock cycle to issue a 
new memory operation, and thus the back-to-back memory access takes three clock cycles. 
10.4.3 HDL implementation 
The HDL code can be derived by following the block diagram in Figure 10.5 and the 
ASMD chart in Figure 10.6. The memory controller must generate fast, glitch-free control 
signals. One method is to modify the output logic to include look-ahead output buffers for 
the Moore output signals. This scheme adds a buffer (i.e., D FF) for each output signal to 
remove glitches and reduce clock-to-output delay. To compensate the one clock cycle delay 
introduced by the buffer, we “look ahead” at the state’s future value (i.e., the s t a t e n e x t  
signal) and use it to replace the state’s current value (i.e., the state-reg signal) in the 
FSM’s output logic. 
The complete HDL code is shown in Listing 10.1. To facilitate future expansion, we 
label the S3 board’s two SRAM chips as a and b and add an -a suffix to the SRAM’s I/O 
signals in port declaration. Note that tri-state buffers are required for the bidirectional data 
signal dio-a. 
10 
15 
Listing 10.1 SRAM controller with three-cycle back-to-back operation 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  sram-ctrl i s  
port ( 
5 
clk, reset: in std-logic; 
__ t o / f r o m  main s y s t e m  
mem: in std-logic; 
r w :  in std-logic; 
addr : in std-logic-vector (17 downto 0) ; 
data-f2s : in std-logic-vector (15 downto 0) ; 
ready : out std-logic ; 
data-s2f -r , data-s2f -ur : 
__ t o / f r o m  c h i p  
a d :  out std-logic-vector (17 downto 0) ; 
we-n, oe-n: out std-logic; 
-- SRAM c h i p  a 
dio-a: inout std-logic-vector (15 downto 0 )  ; 
ce-a-n, ub-a-n, lb-a-n: out std-logic 
out std-logic-vector (15 downto 0 )  ; 
20 
) ; 
end sram-ctrl; 
a r c h i t e c t u r e  arch of sram-ctrl i s  
type state-type i s  (idle, rdl, rd2, wrl, wr2); 
s i g n a l  data-f2s_reg, data-f2s_next : 
25 
s i g n a l  state-reg , state-next : state-type; 

A SAFE DESIGN 
225 
40 
45 
50 
60 
65 
70 
75 
s t d - l o g i c - v e c t o r  ( 1 5  downto 0 )  ; 
s t d - l o g i c - v e c t o r  (15 downto 0 )  ; 
s i g n a l  d a t a - s 2 f _ r e g ,  d a t a - s 2 f _ n e x t  : 
30 
s i g n a l  a d d r - r e g  , a d d r - n e x t  : s t d - l o g i c - v e c t o r  (17 downto 0 )  ; 
s i g n a l  we-buf , oe-buf , t r i - b u f  : s t d - l o g i c ;  
s i g n a l  we-reg , oe-reg , t r i - r e g  : s t d - l o g i c ;  
__ s t a t e  & d a t a  r e g i s t e r s  
begin 
begin 
35 
process ( c l k ,  r e s e t )  
if ( r e s e t = ’ l ’ )  then 
s t a t e - r e g  <= i d l e ;  
a d d r - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
d a t a - f 2 s _ r e g  <= ( o t h e r s = > ’ O ’ ) ;  
d a t a - s 2 f _ r e g  <= ( o t h e r s = > ’ O ’ ) ;  
t r i - r e g  <= ’1’; 
we-reg <= ’1’ ; 
o e - r e g  <= ’ 1 ’ ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
a d d r - r e g  <= a d d r - n e x t  ; 
d a t a - f 2 s _ r e g  <= d a t a - f 2 s _ n e x t ;  
d a t a - s 2 f _ r e g  <= d a t a - s 2 f _ n e x t ;  
t r i - r e g  <= t r i - b u f ;  
we-reg <= we-buf; 
o e - r e g  <= o e - b u f ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
end i f  ; 
end p r o c e s s ;  
process ( s t a t e - r e g  ,mem ,rw , d i o - a  , a d d r  , d a t a - f 2 s ,  
begin 
55 
-- n e x t - s t a t e  
l o g i c  
d a t a - f  2 s _ r e g ,  d a t a - s 2 f  - r e g ,  a d d r - r e g )  
a d d r - n e x t  
<= a d d r - r e g  ; 
d a t a - f  2 s - n e x t  
<= d a t a - f  2 s - r e g ;  
d a t a _ s 2 f _ n e x t  <= d a t a - s 2 f _ r e g ;  
r e a d y  <= ’ 0 ’ ;  
case s t a t e - r e g  i s  
when i d l e  => 
i f  m e m = ’ O ’  
then 
e l s e  
s t a t e - n e x t  <= i d l e ;  
a d d r - n e x t  
<= a d d r ;  
i f  r w = ’ O ’  then - - w r i t e  
s t a t e - n e x t  <= w r l ;  
d a t a _ f 2 s _ n e x t  <= d a t a - f 2 s ;  
s t a t e - n e x t  <= r d l ;  
e l s e  -- r e a d  
end i f  ; 
end i f  ; 
r e a d y  <= ’ 1 ’ ;  
s t a t e - n e x t  <= wr2; 
when w r l  => 
when wr2 => 

EXTERNAL SRAM 
226 
80 
85 
90 
95 
IW 
state-next <= i d l e ;  
state-next <= r d 2 ;  
data-s2f_next <= dio-a; 
state-next <= i d l e ;  
when rdl => 
when r d 2 = >  
end c a s e ;  
end p r o c e s s ;  
_- 
‘I look-ahead 
I‘ o u t p u t  l o g i c  
process (state-next 1 
begin 
tri-buf <= ’ 1 ’ ;  -- d e  f a  u 1 t 
we-buf <= ’ 1 ’ ;  
oe-buf <= ’ 1 ) ;  
case state-next is 
when idle => 
when wrl => 
tri-buf <= ’ 0 ’  ; 
we-buf <= ’ 0 ) ;  
tri-buf <= ’ 0 ’ ; 
oe-buf <= ’ 0 ) ;  
oe-buf <= ) O ) ;  
when wr2 => 
when rdl => 
when r d 2 = >  
end c a s e ;  
end p r o c e s s ;  
__ t o  main s y s t e m  
data-s2f -r <= data-s2f - r e g ;  
data-s2f -ur <= dio-a ; 
-_ 
t o  SRAM 
we-n <= we-reg; 
oe-n <= oe-reg; 
ad <= addr-reg; 
--i/o f o r  SRAM c h i p  a 
ce-a-n < = ) O ’ ;  
ub-a-n < = ’ O ’  ; 
lb-a-n <= 0 ’ ; 
dio-a <= data-f2s_reg when t r i - r e g = ’ O ’  e l s e  ( o t h e r s = > ’ Z ’ ) ;  
end a r c h ;  
To minimize the off-chip pad delay (discussed in Section 10.5.1), the corresponding 
FPGA’s I/O pins should be configured properly. This can be done by adding additional 
information in the constraint file. A typical line is 
NET “ a d < l 7 > “  LOC = “ L 3 “  I IOSTANDARD = LVCMOS33 I SLEW=FAST ; 
10.4.4 Basic testing circuit 
We use two circuits to verify operation of the SRAM controller. The first one is a basic 
testing circuit that allows us manually to perform a single read or write operation. In 
addition to the SRAM chip I/O signals, the circuit has the following signals: 
sw. It is 8 bits wide and used as data or address input. 

A SAFE DESIGN 
227 
0 led. It is 8 bits wide and used to display the retrieved data. 
0 btn (0). When it is asserted, the current value of sw is loaded to a data register. The 
0 btn (1 1. When it is asserted, the controller uses the value of sw as a memory address 
0 btn (2). When it is asserted, the controller uses the value of s w  as a memory address 
During a write operation, we first specify the data value and load it to the internal register 
and then specify the address and initiate the write operation. During a read operation, we 
specify the address and initiate the read operation. The retrieved data is displayed in eight 
discrete LEDs. The complete HDL code is shown in Listing 10.2. 
output of the register is used as the data input for the write operation. 
and performs a write operation. 
and performs a read operation. The readout is routed to the led signal. 
Listing 10.2 Basic SRAM testing circuit 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  ram-ctrl-test i s  
5 
p o r t (  
clk, reset: in std-logic; 
sw: in std-logic-vector (7 downto 0) ; 
btn: in std-logic-vector (2 downto 0 )  ; 
led: out std-logic-vector ( 7  downto 0) ; 
we-n, oe-n: out std-logic; 
dio-a: inout std-logic-vector (15 downto 0 )  ; 
ce-a-n, ub-a-n, lb-a-n: out std-logic 
10 
ad: out std-logic-vector (17 downto 0) ; 
1 ;  
I S  end ram-ctrl-test; 
a r c h i t e c t u r e  arch of ram-ctrl-test i s  
constant ADDR-W: integer :=18; 
constant DATA-W: integer :=16; 
s i g n a l  data-f2sI data-s2f: 
s i g n a l  mem, rw: std-logic; 
s i g n a l  data-reg : std-logic-vector ( 7  downto 0) ; 
20 
s i g n a l  addr : std-logic-vector (ADDR-W -1 downto 0) ; 
std-logic-vector (DATA-W -1 downto 0) ; 
25 
s i g n a l  db-btn: std-logic-vector (2 downto 0) ; 
begin 
ctrl-unit : e n t i t y  work. sram-ctrl 
port map( 
30 
clk=>clk, reset=>reset , 
mem=>mem, rw =>rw, addr=>addr , data-f2s=>data-f2s, 
ready=>open , data-s2f -r=>data-s2f , 
data-s2f -ur=>open, ad=>ad, 
we-n=>we-n, oe-n=>oe-n, dio-a=>dio-a, 
3s 
ce-a-n=>ce-a-n, ub-a-n=>ub-a-n, lb-a-n=>lb-a-n); 
debounce-unit0 : e n t i t y  work. debounce 
port map( 
clk=>clk, reset=>reset , sw=>btn(O) , 

228 
EXTERNAL SRAM 
40 
d b - l e v e l = > o p e n  , d b - t i c k = > d b - b t n  ( 0 ) )  ; 
d e b o u n c e - u n i t l :  e n t i t y  work.debounce 
p o r t  map( 
c l k = > c l k ,  r e s e t = > r e s e t  , s w = > b t n ( l )  , 
d b - l e v e l = > o p e n  , d b - t i c k = > d b - b t n ( l ) )  ; 
45 
d e b o u n c e - u n i t 2  : e n t i t y  work. debounce 
p o r t  map( 
c l k = > c l k ,  r e s e t = > r e s e t  , s w = > b t n ( 2 )  , 
d b - l e v e l = > o p e n  , d b - t i c k = > d b - b t n  ( 2 ) )  ; 
55 
7Cl 
75 
50 
--data 
r e g i s t e r s  
p r o c e s s  ( c l k )  
begin 
i f  ( c l k  ’ e v e n t  and c l k =  ’ 1 ’ 
t h e n  
if ( d b - b t n  ( O ) =  ’ 1)) t h e n  
end if ; 
d a t a - r e g  <= s w ;  
end i f  ; 
end p r o c e s s ;  
-- a d d r e s s  
-- command 
p r o c e s s  ( d b - b t n ,  d a t a - r e g )  
begin 
60 
a d d r  <= “0000000000’‘ & s w ;  
d a t a - f 2 s  <= ( o t h e r s = > ) O ) ) ;  
65 
if d b - b t n ( l ) = ’ l ’  t h e n  -- w r i t e  
m e m  <= ’ 1 ’ ;  
r w  <= ’ 0 ’ ;  
d a t a - f z s  <= “00000000’’ & d a t a - r e g ;  
mem <= ’ 1 ’ ;  
r w  <= ’1); 
m e m  <= ) O ) ;  
r w  <= ’ 1 ) ;  
e l s i f  d b _ b t n ( 2 ) = ’ 1 )  t h e n  -- r e a d  
e l s e  
end i f  ; 
end p r o c e s s ;  
-_ 
o u t p u t  
l e d  <= d a t a - s 2 f  ( 7  downto 0 ) ;  
end a r c h ;  
10.4.5 
Comprehensive SRAM testing circuit 
The second circuit performs comprehensive testing. It verifies operation of the SRAM con- 
troller and checks the integrity of the SRAM chip as well. This circuit has three functions: 
0 Write testing data patterns to the entire SRAM at the maximal rate. 
0 Read the entire SRAM at the maximal rate, check the retrieved data against the 
original patterns, and record the number of erroneous readouts. 
0 Inject erroneous data. 
These functions can be initiated by three debounced pushbuttons. 
The ASMD chart is shown in Figure 10.7. It contains three branches, corresponding to 

A SAFE DESIGN 
229 
ready <=I 
...............I 
............. 
I.... .......... 
I 
rd-clk2 
L .......................... 
............. 1 .............. 
c t 
c+l 
T 
T 
...........I....... 
......... ! 
- 
, ............. 1 .............. 
............................ 
1 
,wr-dk2: 
, 
~ 
........................... 
,.............I... 
......... 
, 
r - c l k 3  
, 
~ 
c t c + l  
j <-> 
c-next.0 
F. 
T 
.............. 
t------------ 
addr t O..O & sw 
Figure 10.7 ASMD chart of a comprehensive SRAM testing circuit. 

230 
EXTERNAL SRAM 
three functions. The middle branch writes the test patterns to the SRAM. The wr-clkl, 
wr-clk2, and wr-clk3 states correspond to the idle, wrl, and wr2 states of the SRAM 
controller. The FSMD uses the 18-bit c register as a counter to loop through this branch 
2lS times. The content of the c register is used as an address and the reversed 16 LSBs 
are used as data during a write operation. The FSMD writes all memory locations while 
looping through this branch. The left branch reads data from the SRAM. The three states 
correspond to the idle, rdi, and rd2 states of the SRAM controller. The FSMD again 
loops through the branch 2lS times. The retrieved data is compared with the original test 
patterns, and the e r r  register is used to keep track of the number of mismatches. The right 
branch performs a single write operation. It uses the 8-bit switch to form a memory address 
and writes an erroneous pattern to that address. The i n j  counter is used to keep track of 
the number of injected errors. The complete HDL code is shown in Listing 10.3. 
Listing 10.3 Comprehensive SRAM testing circuit 
lib rary  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  sram-test i s  
5 
p o r t (  
clk, reset: in std-logic; 
sw: in std-logic-vector ( 7  downto 0) ; 
btn: in std-logic-vector ( 2  downto 0 )  ; 
led: out std-logic-vector (7 downto 0) ; 
a n :  out std-logic-vector (3 downto 0) ; 
sseg : out std-logic-vector ( 7  downto 0) ; 
ad: out std-logic-vector (17 downto 0) ; 
we-n, oe-n: out std-logic; 
dio-a: inout std-logic-vector (15 downto 0) ; 
10 
15 
ce-a-n, ub-a-n, lb-a-n: out std-logic 
) ;  
end sram-test; 
a r c h i t e c t u r e  arch of sram-test i s  
20 
constant ADDR-W: 
integer : =18; 
constant D A T A - W :  
integer : = 1 6 ;  
s i g n a l  addr : std-logic-vector (ADDR-W -1 downto 
s i g n a l  data-f 2s , data-s2f : 
25 
s i g n a l  mem, r w :  std-logic; 
std-logic-vector (DATA-W -1 downto 0 )  ; 
type state-type i s  (test-init , rd-clkl , rd-clk2, rd-clk3, 
s i g n a l  state-reg , state-next : state-type; 
s i g n a l  c-next , c-reg : unsigned (ADDR-W -1 downto 0 )  ; 
30 
s i g n a l  c-std: std-logic-vector (ADDR-W -1 downto 0) ; 
s i g n a l  inj-next , inj-reg: unsigned(7 downto 0 ) ;  
s i g n a l  err-next , err-reg : unsigned (15 downto 0) ; 
s i g n a l  db-btn: std-logic-vector ( 2  downto 0) ; 
wr-err , wr-clkl , wr-clk2 , wr-clk3) ; 
35 begin 
__ component i n s  t a n  t i a  t i  o n  
__ 

A SAFE DESIGN 
231 
c t r l - u n i t  : e n t i t y  work. s r a m - c t r l  
40 
p o r t  map( 
c l k = > c l k ,  r e s e t = > r e s e t  , 
mem=>mem, r w  = > r w  , a d d r = > a d d r  , 
d a t a - f 2 s = > d a t a - f 2 s ,  ready=>open , 
d a t  a-s2f -r =>open , d a t a -  s2f - u r  => d a t  a-s2f , 
ad=>ad , 
d i o - a = > d i o - a ,  
we-n=>we-n, oe-n=>oe-n, 
ce-a-n=> ce-a-n , ub-a-n=>ub-a-n , l b - a - n = >  l b - a - n )  ; 
15 
55 
h5 
d e b o u n c e - u n i t 0  : e n t i t y  work, debounce 
50 
p o r t  map( 
c l k = > c l k ,  r e s e t = > r e s e t  , sw=>btn(O) , 
d b - l e v e l = > o p e n ,  d b - t i c k = > d b _ b t n ( O ) ) ;  
d e b o u n c e - u n i t 1  : e n t i t y  work. debounce 
p o r t  map( 
c l k = > c l k ,  r e s e t = > r e s e t  , s w = > b t n ( l ) ,  
d b - l e v e l = > o p e n  , d b - t i c k = > d b - b t n  (1)) ; 
d e b o u n c e - u n i t 2  : e n t i t y  work, debounce 
p o r t  map( 
c l k = > c l k ,  r e s e t = > r e s e t  , s w = > b t n ( 2 ) ,  
60 
d b - l e v e l = > o p e n ,  d b - t i c k = > d b m b t n ( 2 ) ) ;  
d i s p - u n i t  : e n t i t y  work. disp-hex-mux 
p o r t  map( 
c l k = > c l k ,  r e s e t = > ’ O ’  , d p - i n = > ” l l l l ” ,  
h e x 3 = > s t d _ l o g i c _ v e c t o r  ( e r r - r e g  (15 downto 12)) , 
h e x 2 = > s t d _ l o g i c _ v e c t o r  ( e r r - r e g  (11 downto 8)) , 
h e x l = > s t d - l o g i c - v e c t o r  ( e r r - r e g  ( 7  downto 4 ) )  , 
h e x O = > s t d - l o g i c - v e c t o r  ( e r r - r e g ( 3  downto 0 ) )  , 
a n = > a n ,  s s e g = > s s e g )  ; 
80 
85 
70 
-- 
-- FSMD 
-_ 
__ s t a t e  & d a t a  r e g i s t e r s  
p r o c e s s  ( c l k ,  r e s e t )  
75 
begin 
i f  ( r e s e t = ’ l ’ )  then 
s t a t e - r e g  <= t e s t - i n i t ;  
c - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
i n j - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
e r r - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - r e g  <= s t a t e - n e x t ;  
c - r e g  <= c - n e x t ;  
i n j - r e g  <= i n j - n e x t ;  
e r r - r e g  <= e r r - n e x t  ; 
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  t h e n  
end i f  ; 
end p r o c e s s ;  
c - s t d  <= std-logic-vector(c-reg); 
-- f s m d  n e x t - s t a t e  
l o g i c  / d a t a  p a t h  o p e r a t i o n s  
p r o c e s s  ( s t a t e - r e g  ,sw , d b - b t n ,  c - r e g ,  c - s t d ,  
c-next , i n j - r e g ,  e r r - r e g  , d a t a - s 2 f )  
9u 

232 
EXTERNAL SRAM 
begin 
c - n e x t  <= c - r e g ;  
i n  j - n e x t  <= i n  j - r e g  ; 
e r r - n e x t  <= e r r - r e g  ; 
a d d r  <= ( o t h e r s = > ’ O ’ ) ;  
r w  <= ’ 1 ’ ;  
mem 
<= ’ 0 ’ ;  
d a t a - f 2 s  <= ( o t h e r s = > ’ O ’ ) ;  
c a s e  s t a t e - r e g  i s  
when t e s t - i n i t  => 
i f  d b - b t n ( O ) = ’ l ’  then 
s t a t e - n e x t  <= r d - c l k l  ; 
c-next < = ( o t h e r s = > ’ O ’ ) ;  
e r r - n e x t  < = ( o t h e r s = > ’ O ’ ) ;  
s t a t e - n e x t  <= w r - c l k l ;  
c-next < = ( o t h e r s = > ’ O ’ ) ;  
i n j - n e x t  < = ( o t h e r s = > ’ O ’ ) ;  -- c l e a r  i n j e c t e d  e r r  
e l  s i f  db-btn (2) = ’ 1 ’ then 
s t a t e - n e x t  <= w r - e r r ;  
i n j - n e x t  <= i n j - r e g  + 1; 
s t a t e - n e x t  <= t e s t - i n i t ;  
e I s i f  db-btn (1) = ’ 1 ’ then 
e l s e  
end i f  ; 
s t a t e - n e x t  <= t e s t - i n i t  ; 
m e m  <= ’1’; 
r w  <= ’ 0 ’ ;  
a d d r  <= “0000000000“ & s w ;  
d a t a - f  2 s  <= ( o t h e r s = >  ’1 ’) ; 
s t a t e - n e x t  <= w r - c l k 2 ;  
mern <= ’ 1 ’ ;  
r w  <= ’ 0 ’ ;  
a d d r  <= c - s t d ;  
d a t a - f 2 s  <= not c-std(DATA-W -1 downto 0 )  ; 
when wr-clk2 => -- i n  w r l  s t a t e  of s r a r n - c t r l  
s t a t e - n e x t  <= w r - c l k 3 ;  
when wr-clk3 = >  -- i n  wr2 s t a t e  of s r a r n - c t r l  
c-next 
<= c - r e g  + 1; 
i f  c-next =O then 
e l s e  
end i f  ; 
s t a t e - n e x t  
<= r d - c l k 2 ;  
m e m  <= 
j l ’ ;  
r w  <= ’ 1 ’ ;  
a d d r  <= c - s t d ;  
s t a t e - n e x t  <= r d - c l k 3 ;  
when wr-err => -- w r i t e  1 e r r ;  done i n  n e x t  2 c l o c k s  
when w r - c l k l  => -- i n  i d l e  s t a t e  of s r a m - c t r l  
s t a t e - n e x t  <= t e s t - i n i t ;  
s t a t e - n e x t  <= w r - c l k l  ; 
when r d - c l k l  => -- i n  i d l e  s t a t e  of s r a m - c t r l  
when r d - c l k 2  => -- in r d l  s t a t e  of s r a r n - c t r l  
when r d - c l k 3  => -- i n  rd2 s t a t e  of s r a r n - c t r l  
95 
IW 
105 
I10 
I20 
125 
I30 
115 
I40 

MORE AGGRESSIVE DESIGN 
233 
14s 
150 
__ compare r e a d o u t ;  m u s t  u s e  u n r e g i s t e r e d  o u t p u t  
i f  (not c-std(DATA-W-1 
downto O ) ) / = d a t a - s 2 f  then 
end i f  ; 
c - n e x t  <= c - r e g  + 1; 
i f  c-next=O then 
e l s e  
end i f  ; 
e r r - n e x t  <= e r r - r e g  + 1; 
s t a t e - n e x t  <= t e s t - i n i t ;  
s t a t e - n e x t  
<= r d - c l k l  ; 
I55 
end c a s e ;  
end p r o c e s s ;  
l e d  <= std-logic-vector(inj-reg); 
end a r c h ;  
Note that the number of write-read mismatches is connected to the seven-segment LED 
display and shown as a four-digit hexadecimal number, and the number of injected errors 
is connected to the eight discrete LEDs. 
We can use this circuit as follows: 
0 Perform the read function. Since the SRAM is not written yet, it is in the initial 
“power-on” state. The seven-segment LED display should show a large number of 
mismatches. 
0 Perform the write function. 
0 Perform the read function. The number of mismatches should be zero if both the 
0 Inject error data a few times (to different memory locations). 
0 Perform the read function again. The number of mismatches should be the same as 
SRAM controller and the SRAM device work properly. 
the number of injected errors. 
10.5 MORE AGGRESSIVE DESIGN 
Although the previous memory controller functions properly, it does not have optimal 
performance. While both the read and write cycles are 10 ns of the SRAM device, the 
back-to-back memory access of this controller takes 60 ns (i.e., three clock cycles). In 
this section, we study the timing issue in more detail, examine several more aggressive 
designs and their potential problems, and discuss some FPGA features that help to remedy 
the problems. 
10.5.1 Timing issues 
Timing issues on asynchronous SRAM There are two subtle timing issues in de- 
signing a high-performance asynchronous SRAM controller. The first issue is deactivation 
of the w e n  signal. The ’0’-to-’1’ transition of w e n  functions somewhat like a clock edge 
of an FF, in which the data is latched and stored to the internal memory element. Note 
that the data hold time ( ~ H D )  
is zero for this SRAM. Although it appears that it is fine to 
deactivate w e n  and remove data at the same time, this approach is not reliable because of 
the variations in propagation delays. We must ensure that w e n  is deactivated before data 
is removed from the bus. 
The second issue is the potential conflict on the data bus, dio. Recall that the data bus is 
a bidirectional bus. The controller places data on the bus during a write operation, and the 

234 
EXTERNAL SRAM 
SRAM places data on the bus during a read operation. A condition known as fighting 
occurs if the controller and SRAM place data on the bus at the same time. This condition 
should be avoided to ensure reliable operation. 
Estimation of propagation delay Designing a good memory controller requires hav- 
ing a good understanding about the propagation delays of various signals. However, it is a 
difficult task. First, during synthesis, an RT-level description is optimized and mapped to 
logic cells and wire interconnects. The final implementation may not resemble the block 
diagram depicted by the initial description, and thus it is difficult to estimate the propagation 
delay from the initial description. 
Second, a memory operation involves off-chip data access. Additional propagation delay 
is introduced when a signal propagates through the FPGA’s I/O pads. The delay, sometimes 
known as pad delay, is usually much larger than the internal wiring delay and its exact value 
depends on a variety of factors, including the type of FPGA device, the location of the output 
register (in LE or IOB), the I/O standards, the slew rate, the driver strength, and external 
loading. 
It requires intimate knowledge of the FPGA device and the synthesis software to perform 
a good timing analysis and to estimate the propagation delays of various signals. 
10.5.2 Alternative design I 
The first alternative design is targeted to reduce the back-to-back operation overhead. In- 
stead of always returning to the i d l e  state, the memory controller can check the mem signal 
at the end of current memory operation (i.e., in the rd2 or wr2 state) and determine what 
to do next. It initiates a new memory operation immediately if there is a pending request. 
The revised ASMD chart for this controller is shown in Figure 10.8. In the rd2 and wr2 
states, the mem and r w  signals are examined and the FSMD may move directly to the r d i  
or w r l  state if another memory operation is required. 
Timing analysis Most of the original timing analysis in Section 10.4.2 can still be ap- 
plied to this design. However, skipping the i d l e  state introduces subtle new complications 
when different types of back-to-back memory operations are performed. The issue is the 
potential fighting on the data bus. 
Let us consider a write operation performed immediately after a read operation. During 
the read operation, the signal flows from the SRAM to the FPGA. To facilitate this operation, 
the tri-state buffer of the SRAM should be “turned on” (i.e., passing signal) and the tri- 
state buffer of the FPGA should be “turned off” (i.e., high impedance). During the write 
operation, the signal flows from the FPGA to the SRAM, and the roles of the two tri-state 
buffers are reversed. Note that a small delay is required to turn on or off a tri-state buffer. 
In the SRAM chip, these delays are specified by t H Z o E  ( o e n  to high-impedance time) 
and t L Z o E  (oen to low-impedance time) in Figure 10.2. 
In the original SRAM controller, both tri-state buffers are turned off in the i d l e  state. 
The state provides enough time for the data bus to settle to the high-impedance condition. 
The new design requires the two tristate buffers to reverse directions simultaneously during 
back-to-back operations. For example, when moving from the rd2 state to the w r i  state, the 
FSMD generates signals to turn off the SRAM’s tri-state buffer and to turn on the FPGA’s 
tri-state buffer. A problem may occur in this transition if the SRAM’s tri-state buffer is 
turned off too slowly or the FPGA’s tri-state buffer is turned on too quickly. In a small 
interval, both buffers may allow data to be placed on the bus and fighting occurs. Similarly, 
fighting may occur when a read operation is performed immediately after a write operation. 

MORE AGGRESSIVE DESIGN 
235 
Default: oe-n <= 1; we-n <= 1; tri-n <= 1; ready <= 0 
,.......... 
........ 
raddr +- addr 
..... ......I 
....................................... 
......... 
, ........................ 
; 
r l  
oe-n <= 0 
oe-n <= 0 
rs2t + dio 
4 
F 
mem=l 
................................................ 
I I 
-4 
... 
-l 
trig <= 0 OF- 
mem=l 
T 
rT<*>F, 
raddr + addr 
' ...........i...........................i............. 
I I 
Figure 10.8 ASMD chart of SRAM controller design I. 

236 
EXTERNAL SRAM 
Default: oe-n <= 1 ; we-n <= 1; tri-n <= 1; ready <= 0 
L........ 
-.. ....................................... 
.......... 
1 
I 
tri-n <= 0 
Figure 10.9 ASMD chart of SRAM controller design 11. 
Since the interval tends to be very small, the fighting should not cause severe damage to 
the devices but may introduce a large transient current which makes the design less reliable. 
We must do a detailed timing analysis to examine whether fighting occurs, and may even 
need to fine-tune the timing to fix the problem. As discussed in Section 10.5.1, it is a 
difficult task. 
10.5.3 Alternative design II 
Timing analysis in Section 10.4.2 shows that the initial design provides a large safety margin. 
In this controller, a memory operation takes two clock cycles, which amount to 40 ns. Since 
the read and write cycles of the SRAM are each 10 ns, we naturally wonder whether it is 
possible to reduce the operation time to a single 20-11s clock cycle. This can be done by 
eliminating the rd2 and wr2 states in the ASMD chart. The second alternative design uses 
this approach. The revised ASMD chart is shown in Figure 10.9. It takes one clock cycle 
to complete the memory access and requires two clock cycles to complete the back-to-back 
operations. 
Timing analysis Reducing a state from the original controller imposes much tighter 
timing constraints for both read and write operations. Let us first consider the read operation. 
During operation, the address signal first propagates through the FPGAs I/O pads to the 
SRAM's address bus, and the retrieved data then propagates back through the I/O pads 
to FPGA's internal logic. All of this must be completed within a 20-11s clock cycle. In 
addition to the 10-ns SRAM address access time (i.e., ~ A A ) ,  
the cycle must accommodate 

MORE AGGRESSIVE DESIGN 
237 
two pad delays. The pad delay of a Spartan-3 device can range from 4 ns to more than 
10 ns. Therefore, we need to “fine-tune” the synthesis to achieve this margin. 
Unlike the read operation, a write operation is “one-way” and only needs to propagate 
the address, data, and control signals to the SRAM chip. If we assume that the signals 
experience similar pad delays, the absolute value of the delay is a lesser issue. Instead, the 
key is the order of signals being activated and deactivated. As discussed in Section 10.5.1, 
w e n  must be deactivated before data to latch the data properly to the SRAM. In the original 
design, this is achieved by including the second state in the write operation, w r 2 ,  in which 
w e n  is deactivated but the data is still available (i.e., trin is still active). In the revised 
controller, the w e n  and t r i n  signals are deactivated simultaneously at the end of the w r l  
state. Due to the variations in the internal logic and pad delays, normal synthesis cannot 
guarantee that w e n  is deactivated before the data is removed from the external data bus. 
Again, for a reliable design, we need to fine-tune the synthesis to satisfy this goal. 
10.5.4 Alternative design 111 
We can combine the features from the two preceding revisions to derive the third alternative 
design. This new controller eliminates the second clock cycle in the read and write oper- 
ations and allows back-to-back operation without first returning to the i d l e  state. This is 
the most aggressive design. The revised ASMD chart is shown in Figure 10.10. It com- 
bines the modifications from the previous two ASMD charts. The revised design takes one 
clock cycle to complete the memory access and one clock cycle to complete back-to-back 
operations. 
Note that the w e n  signal must be asserted for a fraction of the clock period and cannot 
be shown in the ASMD chart. We use the w e - t m p  in the w r l  state and later derive w e n  
from this signal. 
Timing analysis Since the new design combines the features of the two previous de- 
signs, all the timing issues discussed in the two preceding subsections must be considered 
for this design as well. One additional issue is generation of the w e n  signal. During back- 
to-back write operations, the ASMD stays on the w r l  state. In the original design, the w e n  
signal is a Moore output. It will be asserted to ’0’ continuously in this case. The controller 
does not function properly since the data is latched to the SRAM at the ’0’-to-’ 1’ transition 
of the w e n  signal. To solve the problem, the w e n  signal must be asserted in only a fraction 
of the clock period. 
One possible way to solve the problem is to assert the signal only at the first half of the 
clock, which is 10 ns and can satisfy the t
~
p
~
l
 
requirement in theory. Intuitively, we are 
tempted to do this by gating the w e - t m p  signal with the clock signal, clk: 
we-n <= we-tmp or ( n o t  c l k ) ;  
However, this is not a reliable solution because of the potential glitches and delay variation. 
A better alternative is discussed in the next subsection. 
10.5.5 Advanced FPGA featuresxizinx 
‘peeif ic 
The memory controller examples in this section illustrate the limitations of the FSM-based 
controller and synchronous design methodology. Basically, an FSM cannot generate a 
control sequence that is “finer” than the period of its clock signal. The operation of these 
alternative designs relies on factors that cannot be specified by an RT-level HDL description. 

238 
EXTERNAL SRAM 
Default: oe-n <= 1; we-n <= 1; tri-n <= 1; ready <= 0 
, ............................................................... 
idle 
ready <=I 
T 
rT-<;"'>F7 
I 
'@; 
~ 
raddr +- addr 0 
raddr t 
addr 
, 
c-), 
- 
rr2f t 
dio 
ladr t 
addr 
............................................ 
-?-- 
we-tmp <= 0 
mem=l 
F- 
T 
r.<;'>.1 
Figure 10.10 ASMD chart of SRAM controller design 111. 

MORE AGGRESSIVE DESIGN 
239 
Due to the variations in propagation delays, the synthesized circuits are not reliable and 
may or may not work. 
There are some ad hoc features to obtain better control. These features are usually 
device and software dependent. For example, the digital clock manager (DCM) circuit and 
input/output block (IOB) of the Spartan-3 device can help to remedy some of the previously 
discussed problems. Detailed discussion of DCM and IOB is beyond the scope of this book. 
In this subsection, we sketch a few ideas and illustrate how to apply these features to obtain 
a more reliable controller. 
DCM A Spartan-3 FPGA device contains up to eight digital clock managers (DCMs). 
As its name indicates, a DCM is a circuit that manipulates the system clock signal. It can 
multiply or divide the frequency or shift the phase of the incoming clock signal to generate 
new clock signals. 
One way to obtain a “finer” control sequence is to use a faster clock. Since implemen- 
tation of a memory controller is fairly simple, the circuit itself can operate at a faster clock 
rate. For example, we can isolate the memory controller and drive it with a DCM-generated 
200-MHz clock signal, whose period is only 5 ns. Consider the write operation of the 
ASMD chart in Figure 10.6. In the new controller, each state lasts only 5 ns. To satisfy the 
10-ns w e n  requirement, we need to expand the w r l  state to two states and assert the w e n  
signal in these states. The complete write operation now requires four states. However, 
because of the faster clock rate, the four clock cycles amount to only 20 ns, which is much 
better than the original 60-11s design. 
A simple application of clock phase shift is discussed in the next subsection. 
IOB An input/output block (IOB) of a Spartan-3 FPGA device provides a programmable 
interface between an I/O pin and the device’s internal logic. It contains several storage 
registers and tri-state buffers as well as analog driver circuits that can be configured to 
provide different slew rates and driver strength and to support a variety of I/O standards. 
To minimize the off-chip pad delay discussed in Section 10.5.3, we can put the output 
registers of the memory controller to the FFs inside the IOBs and configure the driver with 
the proper slew rate and strength. This can be done by specifying the desired condition and 
configuration in the constraint file. 
An IOB also contains a double data rate (DDR) register, which has two clocks and two 
inputs. Conceptually, we can think that the two inputs are sampled independently by the two 
clocks and the sampled values are stored in the same register. The DDR register and DCM 
can be combined to generate a control signal whose width is a fraction of a clock signal, as 
the w e n  signal discussed in Section 10.5.4. The block diagram is shown in Figure 10.1 l(a). 
The regular output register is replaced with a DDR register. The top portion of the DDR 
consists of the we-tmp signal and the original clock signals, clk. The bottom input of the 
DDR is tied to ’1’ and the clock is connected to the out-of-phase clock signal, clk180, 
which is generated by a DCM. The ’1’ is always loaded at the rising edge of the clk180 
signal, which corresponds to the falling edge of the clk signal. It essentially deactivates 
the second half of the w e n  signal. The timing diagram is shown in Figure 10.1 l(b). This 
approach generates a clean half-cycle signal and is far more reliable than the clock gating 
scheme discussed in Section 10.5.4. 

240 
EXTERNAL SRAM 
dk rn 
clk180 
Figure 10.11 Generating a half-cycle signal with DDR. 
10.6 BIBLIOGRAPHIC NOTES 
The data sheet published by ISSI provides detailed information for the IS61LV25616AL 
SRAM device. The Xilinx application note, XAPP462 Using Digital Clock Managers 
(DCMs) in Spartan-3 FPGAs, discusses the use of DCM, and the data sheet, DS099 Spartan- 
3 FPGA Family: Complete Data Sheet, explains the architecture and configuration of the 
IOB and the DDR register. 
10.7 SUGGESTED EXPERIMENTS 
10.7.1 Memory with a 512K-by16 configuration 
There are two 256K-by-16 SRAM chips, and their I/O connections are shown in the manual 
of the S3 board. We can expand them to form a 512K-by-16 SRAM. 
1. Derive a scheme to combine the two chips. 
2. Follow the procedure in Section 10.4 to design a memory controller for the 512K- 
by- 16 SRAM. Derive the HDL description. 
3. Modify the testing circuit in Section 10.4.5 for the new controller and derive the HDL 
description. 
4. Synthesize the testing circuit and verify operation of the controller and SRAM chips. 
10.7.2 Memory with a 1M-by8 configuration 
Repeat Experiment 10.7.1 but configure the two chips as a 1M-by-8 SRAM. The l b n  and 
u b n  signals can be used for this purpose. 
10.7.3 Memory with an 8M-by1 configuration 
A single bit of the 256K-by-16 SRAM can be written as follows: 
Read a 16-bit word. 
Modify the designated bit in the word. 
Write the 16-bit word back. 
Repeat Experiment 10.7.1 but configure the two chips as an 8M-by-1 SRAM. 

SUGGESTED EXPERIMENTS 
241 
10.7.4 Expanded memory testing circuit 
The memory testing circuit in Section 10.4.5 conducts exhaustive back-to-back read and 
back-to-back write tests. We can expand the circuit to include an exhaustive “read-after- 
write” test, in which the testing circuit issues write and read operations alternately for the 
entire memory space. To make the test more effective, the writing and reading addresses 
should be different. For example, we can make the read operation retrieve the data written 
16 positions earlier (i.e., if the current writing address is c, the reading address will be 
c-16). Create a modified ASMD chart, derive an HDL description, synthesize the circuit, 
and verify its operation. 
10.7.5 Memory controller and testing circuit for alternative design I 
Derive the HDL code for alternative design I in Section 10.5.2 and create an expanded 
testing circuit similar to the one in Experiment 10.7.4. Synthesize the testing circuit and 
examine whether any error occurs during operation. 
10.7.6 Memory controller and testing circuit for alternative design II 
Repeat the process in Experiment 10.7.5 for alternative design I1 discussedin Section 10.5.3. 
10.7.7 Memory controller and testing circuit for alternative design 111 
Repeat the process in Experiment 10.7.5 for alternative design I11 discussed in Section 10.5.4. 
10.7.8 Memory controller with DCM 
Study the application note on DCM and follow the discussion in Section 10.5.5 to drive 
the safe memory controller discussed in Section 10.4 with a higher clock rate (150 MH or 
even 200 MHz). Derive an ASMD chart and HDL code, and create a new testing circuit. 
Synthesize the circuit and verify operation of the memory controller and the SRAM. 
10.7.9 High-performance memory controller 
Study the documentation of the DCM and the IOB, and apply these features to reconstruct 
alternative design I11 discussed in Section 10.5.4. Create a new testing circuit. Synthesize 
the circuit and verify operation of the memory controller and the SRAM. 

This Page Intentionally Left Blank

CHAPTER 11 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
11.1 INTRODUCTION 
A digital system frequently requires memory for storage. To facilitate this need, most FPGA 
devices contain dedicated embedded memory modules. While these modules cannot replace 
the massive external memory devices, they are useful for applications that require small or 
intermediate-sized memory. 
Although the basic internal structure of memory modules is similar, there are many subtle 
differences in their I/O interfaces. It is usually difficult for synthesis software to extract the 
desired features from the code and to infer a matching memory module from the underlying 
device library. In Xilinx ISE, we can use HDL instantiation, the Core Generator program, 
or the behavioral HDL inference template to incorporate an embedded memory module into 
a design. The third one is semi-device independent and we use this method in this book. In 
this chapter, we briefly examine Spartan-3 memory modules and the first two methods and 
provide detailed descriptions of several key behavioral HDL templates. 
11.2 EMBEDDED MEMORY OF SPARTAN-3 DEVICE 
11.2.1 Overview 
There are two types of embedded memory in a Spartan-3 device: distributed RAM and 
block RAM. A distributed RAM is constructed from the logic cell’s look-up table (LUT). 
The LUT can be configured as a 16-by-1 synchronous RAM, and multiple LUTs can be 
FPGA Prototyping by VHDL Examples. B y  Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
243 

244 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
cascaded to form a wider and deeper memory module. The Spartan-3 XC3S200 device of 
the S3 board can provide up to 30K bits of distributed memory, which is small compared 
to a block RAM or external memory. Furthermore, since the distributed RAM uses the 
logic cells, it competes for resources with the normal logic. Thus, it is feasible only for 
applications that require relatively small storage. 
A block RAM is a special memory module embedded in an FPGA device and is separated 
from the regular logic cells. It can be thought of as a fast SRAM wrapped by a synchronous, 
configurable interface. Each block RAM consists of 16K (214) data bits plus optional 
2K parity bits. It can be organized in different widths, from 16K by 1 (i.e., 214 by 2’) to 
512 by 32 (i.e., 2’ by 25). The Spartan-3 XC3S200 device has 12 block RAMs, totaling 
172K data bits. These block RAMs can be used for intermediate-sized applications, such 
as a FIFO, a large look-up table, or an intermediate-sized local memory. In comparison, 
the external SRAM chips of the S3 board have a capacity of 8M bits. 
Both the distributed RAM and block RAM are already “wrapped” with a synchronous 
interface, and thus no additional memory controller circuit is needed. They are very flexible 
and can be configured to perform single- and dual-port access and to support various types of 
buffering and clocking schemes. Detailed discussion is beyond the scope of this book. We 
only examine several commonly used configurations, including a synchronous single-port 
RAM, a synchronous dual-port RAM, and a ROM in Section 11.4. 
11.2.2 Comparison 
The Spartan-3 device and the S3 board provide several options for storage elements. It is a 
good idea to keep in mind the relative capacities of these options: 
0 XC3S2OO’s FFs (for registers): about 4.5K bits, embedded in logic cells and IiO 
0 XC3S2OO’s distributed RAM: 30K bits, constructed from the logic cells 
0 XC3S2OO’s block RAM: 172K bits, configured as twelve 16K-bit modules 
0 External SRAM: 8M bits, configured as two 256K-by-16 SRAM chips 
This helps us to decide which option is most suitable for an application at hand. 
buffers 
11.3 METHOD TO INCORPORATE MEMORY MODULES 
Although memory modules have similar internal structure, there are many subtle differences 
in their interfaces, such as the numbers of read and write ports, clocking scheme, data and 
address buffering, enable and reset signals, and initial values. Although it is possible to 
describe the desired module behaviors in HDL code, the synthesis software may or may not 
recognize the designer’s intention. Therefore, the HDL code cannot always infer the proper 
memory module and is normally not portable. In Xilinx ISE, there are three methods to 
incorporate an embedded memory module into a design: 
0 HDL instantiation 
0 The Core Generator program 
0 The behavioral HDL inference template 
The first two are specific for Xilinx devices and the third is a semi-device-independent 
behavioral description. Because of the clarity of the behavioral description, we use the 
third method in this book. We provide a brief overview of the three methods in this section. 

METHOD TO INCORPORATE MEMORY MODULES 
245 
11.3.1 
We have used HDL component instantiation in many earlier design examples to include 
predesigned modules or to create a hierarchy, Instantiating a Xilinx memory module is 
similar except that there is no HDL description for the architecture body. We must check 
the manual to find the exact entity name and the associated generics and I/O port definitions. 
This is a tedious process and is particularly error-prone for memory modules because of 
the large number of configurations and options. 
The instantiation code for many Xilinx components can be obtained directly from ISE by 
selecting Edit + Language Templates. The following are segments of a 16K-by-1 dual-port 
RAM: 
Memory module via HDL component instantiation 
-- R A M B 1 6 - S L S I :  V i r t e x - I I / I I - P r o ,  
-- S p a r t a n  -3/3E 1 6 k  x 1 Dual-Port RAM 
__ X i l i n x  
HDL Language T e m p l a t e  v e r s i o n  8 . 1  i 
RAMB16-S1-Sl-inst : RAMBlG-Sl-Sl 
g e n e r i c  map( 
init-a => "0" , 
init-b => "0" , 
srval-a => "0" , 
srval-b => "0" , 
write-mode-a = >  "WRITE-FIRST", 
write-mode-b => "WRITE-FIRST" , 
s im- c o 11 i s i on- c he c k = > 
" ALL 
'I , 
init-00 => x"0 . . . 0", 
init-3f => x"0 . . . 0" 
. . .  
I
,
 
port map( 
doa => doa, 
dob => dob, 
addra => addra, 
addrb = >  addrb , 
clka => c l k a ,  
clkb => c l k b ,  
dia => dia, 
dib => dib, 
ena => ena, 
enb => enb , 
ssra => s s r a ,  
ssrb => s s r b ,  
wea = >  wea, 
web = >  web 
) ;  
__ p o r t  
__ p o r t  
__ p o r t  
__ p o r t  
__ p o r t  
p o r t  
__ p o r t  
__ p o r t  
_- 
p o r t  
__ p o r t  
-_ p o r t  
__ p o r t  
__ p o r t  
__ p o r t  
__ 
a I - b i t  
d a t a  o u t p u t  
b 1 - b i t  
d a t a  o u t p u t  
a 1 4 -  b i t  a d d r e s s  i n p u t  
b 1 4 -  b i t  a d d r e s s  i n p u t  
a c l o c k  
b c l o c k  
a 1 - b i t  
d a t a  i n p u t  
b 1 - b i t  
d a t a  i n p u t  
a ram e n a b l e  i n p u t  
b ram e n a b l e  i n p u t  
a s y n c h r o n o u s  s e t / r e s e t  i n p u t  
b s y n c h r o n o u s  s e t / r e s e t  i n p u t  
a w r i t e  e n a b l e  i n p u t  
b w r i t e  e n a b l e  i n p u t  
Although the code is readily available, we must study the manual carefully to find the right 
component and proper configuration parameters. 
11.3.2 Memory module via Core Generator 
To simplify the instantiation process, Xilinx provides a utility program, known as Core 
Generator (Coregen), to generate Xilinx-specific components. This utility can be invoked 
from the ISE environment by selecting Project + New Source. After the New Source 

246 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
Wizard dialog appears, we select IP (Coregen & Architecture Wizard) to invoke the Coregen 
program. The program guides the users through a series of questions and then generates 
several files. The file with the .xco extension is a text file that contains the information 
necessary to construct the desired memory component. The file with the .vhd extension 
contains the “wrapper” code for simulation purpose. This file cannot be used to instantiate 
the desired component and is ignored during the synthesis process. 
Although using the Coregen program is more convenient than direct HDL instantiation, 
it is not within the HDL framework and can lead to a compatibility problem when a design 
is not done in the Xilinx ISE environment. 
11.3.3 Memory module via HDL inference 
Although it is not possible to develop a device-independent HDL description, the synthe- 
sis program of ISE, known as XST, provides a collection of behavioral HDL templates to 
infer memory modules from Xilinx FPGA devices. These templates are done by behav- 
ioral descriptions and contain no device-specific component instantiation. They are easy to 
understand and can be simulated without an additional HDL library. However, while the de- 
scription does not explicitly refer to any Xilinx component, the code may not be recognized 
by other third-party synthesis software, and the desired memory module cannot always be 
inferred. Thus, these templates can best be described as “semi-portable” and “semi-device- 
independent” behavioral descriptions. Templates for commonly used memory modules are 
discussed in Section 1 1.4. 
On the downside, the template approach is based on the ability of the XST software to 
recognize the template and infer the proper memory module accordingly. The software 
may change during upgrade or misinterpret some code. It is a good idea to check the XST 
synthesis report to ensure that the desired memory module is inferred correctly. 
11.4 HDL TEMPLATES FOR MEMORY INFERENCE 
To use behavioral HDL description to infer the Xilinx memory module, the XST’s templates 
should be followed closely. To avoid misinterpretation, we should refrain from creating our 
own “innovative” code. The codes in the following subsections are all based on templates of 
the XST v8.1 i Manual. They are the same as the original templates except that generics are 
used for the width of address bits and the width of data bits, and the numeric-std package 
is used to replace the proprietary std-logic-unsigned package. It is a good practice to 
confine the memory description in a separate HDL module so that the module can easily 
be identified and replaced when needed. In this section, we discuss the behavioral HDL 
templates for six configurations, including two for single-port RAMs, two for dual-port 
RAMs, and two for ROMs. 
11.4.1 Single-port RAM 
The embedded memory of a Spartan-3 device is already wrapped with a synchronous 
interface similar to that in Section 10.3. Its write operation is always synchronous. At 
the rising edge of the clock, the address, input data, and relevant control signals, such as we 
(i.e., write enable), are sampled. If we is asserted, a write operation is performed (i.e., the 
input data is stored into the memory location designated by the address signal). 

HDL TEMPLATES FOR MEMORY INFERENCE 
247 
The read operation can be asynchronous or synchronous. For asynchronous read, the 
address signal is used directly to access the RAM array. After the address signal changes, 
the data becomes available after a short delay. For synchronous read, the address signal is 
sampled at the rising edge of the clock and stored in a register. The registered address is then 
used to access the RAM array. Because of the register, the availability of data is delayed 
and is synchronized by the clock signal. Due to the internal structure, asynchronous read 
operation can only be realized by the distributed RAM. 
Single-port RAM with asynchronous read The template for the single-port RAM 
with asynchronous read is shown in Listing 11.1. It is modified after the rams-04 entity of 
the XST Manual. 
Listing 11.1 Template for a single-port RAM with asynchronous read 
__ single -port RAM with asynchronous read 
__ modified f r o m  XST 8 . 1  i rams-04 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  xilinx-one-port-ram-async i s  
5 use ieee. numeric-std. a l l  ; 
generic ( 
ADDR-WIDTH : 
DATA-WIDTH : integer : =1 
integer : =8 ; 
10 
) ; 
port ( 
c l k :  in std-logic; 
w e :  in std-logic; 
addr : in std-logic-vector (ADDR-WIDTH-1 downto 0) ; 
dout : out std-logic-vector (DATA-WIDTH-1 downto 0) 
I5 
d i n :  in std-logic-vector (DATA-WIDTH -1 downto 0 )  ; 
) ;  
end xilinx-one-port-ram-async; 
i0 
20 a r c h i t e c t u r e be h - ar c h of x i 1 i nx - one - p or t - r am - as y n c 
i s 
type ram-type i s  array (2**ADDR_WIDTH -1 downto 0 )  
of std-logic-vector (DATA-WIDTH-1 downto 0 )  ; 
s i g n a l  ram: ram-type; 
begin 
z i  
process (clk) 
begin 
i f  (clk’event and clk = ’1’) then 
i f  (we=’l’) then 
end i f  ; 
ram(to-integer (unsigned(addr1)) <= d i n ;  
end i f  ; 
end p r o c e s s ;  
dout <= ram(to-integer(unsigned(addr))); 
end beh-arch ; 
The code is very similar to the register file discussed in Section 4.2.3 except that the 
read and write operations use the same address. It contains a user-defined two-dimensional 
array data type for storage and uses dynamic indexing to access the element in the array. 
The code shows that the write operation is controlled by the clock signal and the read 

248 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
operation depends only on the address. Since asynchronous read can be realized only by 
the distributed RAM, this configuration is only recommended for applications that require 
small storage. 
Single-port RAM with synchronous read The template for the single-port RAM 
with synchronous read is shown in Listing 11.2. It is modified after the rams-07 entity of 
the XST Manual. 
Listing 11.2 Template for a single-port RAM with synchronous read 
__ s i n g l e  - p o r t  RAM w i t h  s y n c h r o n o u s  read 
__ m o d i f i e d  f r o m  XST 8 . 1  i r a m s - 0 7  
library ieee; 
use i e e e .  std-logic-1164. a l l  ; 
s use ieee. numeric-std. a l l  ; 
e n t i t y  xilinx-one-port -ram-sync i s  
generic ( 
ADDR-WIDTH : 
DATA-WIDTH : integer : =8 
integer : =12 ; 
10 
) ; 
port ( 
clk: in std-logic; 
w e :  in std-logic; 
addr: in std-logic-vector (ADDR-WIDTH-1 downto 0 )  ; 
dout : out std-logic-vector (DATA-WIDTH -1 downto 0 )  
IS 
d i n :  in std-logic-vector (DATA-WIDTH-1 downto 0) ; 
1 ;  
end xilinx-one-port-ram-sync; 
20 a r c h i t e c t u r e be h - ar c h of x i 1 i n x  - one -port - r am - s y n c i s 
type ram-type i s  array (2**ADDR_WIDTH -1 downto 0 )  
of std-logic-vector (DATA-WIDTH-1 downto 0 )  ; 
s i g n a l  r a m :  ram-type; 
s i g n a l  addr-reg: std-logic-vector (ADDR-WIDTH-1 downto 0 )  ; 
process (clk) 
begin 
25 begin 
if ( c l k ’ e v e n t  and clk = ’ 1 ’ )  then 
i f  ( w e = ’ l ’ )  then 
30 
ram(to-integer(unsigned(addr))) 
<= d i n ;  
end i f  ; 
addr-reg <= a d d r ;  
end if ; 
end p r o c e s s ;  
35 
dout <= ram(to-integer (unsigned(addr-reg))) ; 
end beh-arch ; 
Note that the addr signal is now sampled and stored to the addr-reg register at the rising 
edge of the clock, and the memory array (the ram signal) is accessed via the addr-reg signal. 
The data is available only after the addr-reg is updated and thus implicitly synchronized 
to the clk signal. 
Synthesis report During synthesis, a proper RAM module should be inferred from the 
code template. We can check the synthesis report to confirm the inference of the RAM 

HDL TEMPLATES FOR MEMORY INFERENCE 
249 
module. For example, consider the instantiation of a 4K-by-8 RAM (212-by-23) with 
synchronous read: 
g e n e r i c  m a p  ( ADDR-W IDTH= > 12 , DATA-W IDTH = >8) 
port map(clk=>clk, w e = > w e  , a d d r = > a d d r  , 
d i n = > d i n ,  d o u t = > d o u t )  ; 
u n i t - 4 K - b y _ % :  e n t i t y  work.xilinx-one-port~sram-sync 
The inference of RAM should be indicated in the HDL Synthesis section of the synthesis 
report: 
* 
HDL Synthesis 
* 
Found 4096x8-bit single-port block RAM for signal <ram> 
mode 
I 
aspect ratio 
I 
clock 
I 
write enable 
I 
address 
I 
data in 
I 
data out 
I 
ram-style 
I 
write-first 
4096-word x 8-bit 
connected to signal <elk> 
connected to signal <we> 
connected to signal <addr> 
connected to signal <din> 
connected to signal <dout> 
Auto 
I 
I 
I 
I 
I rise I 
I high I 
I 
I 
I 
I 
I 
I 
I 
I 
Summary : 
inferred 
1 RAM(s). 
The number of block RAMS used should be reported in the Final Report section of the 
synthesis report: 
Device utilization summary: 
Selected Device : 3s200ft256-5 
* . .  
Number of BRAMs: 
2 out of 
12 
16% 
* . .  
As we expected, a 4K-by-8 single-port block RAM is inferred and two block RAMS are 
used to realize the circuit. 
11.4.2 
Dual-port RAM 
A dual-port RAM includes a second port for memory access. Ideally, the second port 
should be able to conduct read or write operation independently and have its own set of 
address, data input and output, and control signals. To be compatible with older versions 
of XST, we consider a configuration with the second port that can conduct a read operation 
only. In this book, the main application of the dual-port configuration is for video memory, 
which requires one write port and one read port. Thus, this configuration does not impose 
a serious limitation for our purposes. As in a single-port RAM, the read operation of a 
dual-port RAM can be asynchronous or synchronous. 

250 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
Dual-port RAM with asynchronous read The template for the dual-port RAM with 
asynchronous read is shown in Listing 11.3. It is modified after the rams-09 entity of the 
XST Manual. 
Listing 11.3 Template for a dual-port RAM with asynchronous read 
-- dual-port 
RAM w i t h  asynchronous read 
__ m o d i f i e d  f r o m  X S T  8 . 1  i rams-09 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
5 use ieee . numeric-std. a l l  ; 
e n t i t y  xilinx-dual-port -ram-async i s  
generic ( 
ADDR-WIDTH: integer :=6; 
DATA_WIDTH:integer:=8 
10 
) ; 
port ( 
clk: in std-logic; 
w e :  in std-logic; 
addr-a: in std-logic-vector (ADDR-WIDTH-1 downto 0 )  ; 
addr-b : in std-logic-vector (ADDR-WIDTH -1 downto 0 )  ; 
din-a: in std-logic-vector (DATA-WIDTH -1 downto 0 )  ; 
dout-a: out std-logic-vector (DATA-WIDTH -1 downto 0) ; 
dout-b : out std-logic-vector (DATA-WIDTH -1 downto 0 )  
1 ;  
20 end xilinx-dual-port-ram-async; 
15 
a r c h i t e c t u r e  beh-arch of xilinx-dual-port-ram-async i s  
type ram-type i s  array ( 0  to 2**ADDR-WIDTH-l) 
of std-logic-vector (DATA-WIDTH -1 downto 0) ; 
25 
s i g n a l  r a m :  ram-type; 
begin 
process (clk) 
begin 
i f  (clk’event and clk = ’1’) then 
30 
if (we = ’1’) then 
ram(to-integer(unsigned(addr-a))) 
<= din-a; 
end i f  ; 
end i f  ; 
end p r o c e s s ;  
35 
dout-a <= ram(to-integer (unsigned(addr-a))); 
dout-b <= ram(to_integer(unsigned(addr-b)); 
end beh-arch ; 
The write operation is similar to that of the single-port RAM, but the code includes a 
second output port, dout-b, which retrieves data from the second address, addr-b. As in 
a single-port RAM with asynchronous read, the dual-port version can be realized only by 
distributed RAM, and thus its size is limited. Note that if we ignore the dout-a port, it is 
the same as the single-read-port register file of Listing 4.6. 
Dual-port RAM with synchronous read The template for the dual-port RAM with 
synchronous read is shown in Listing 11.4. It is modified after the rams-11 entity of the 
XST Manual. 

HDL TEMPLATES FOR MEMORY INFERENCE 
251 
Listing 11.4 Template for a dual-port RAM with synchronous read 
-- d u a l - p o r t  RAM w i t h  s y n c h r o n o u s  read 
-- m o d i f i e d  f r o m  XST 8 . 1  i rams-11 
library i e e e ;  
use ieee. std-logic-1164. a l l  ; 
s use ieee. numeric-std. a l l  ; 
e n t i t y  xilinx-dual-port-ram-sync i s  
generic ( 
ADDR-WIDTH : 
D A T A _ W I D T H : i n t e g e r : = 8  
integer : =6 ; 
10 
1 ; 
port ( 
c l k :  in std-logic; 
w e :  in std-logic; 
addr-a: in std-logic-vector (ADDR-WIDTH -1 downto 0) ; 
addr-b: in std-logic-vector (ADDR-WIDTH-1 downto 0) ; 
din-a: in std-logic-vector (DATA-WIDTH-1 downto 0 )  ; 
dout-a: out std-logic-vector (DATA-WIDTH-1 downto 0 )  ; 
dout-b : out std-logic-vector (DATA-WIDTH -1 downto 0 )  
) ;  
20 end xilinx-dual-port-ram-sync; 
I S  
a r c h i t e c t u r e  beh-arch of xilinx-dual-port-ram-sync i s  
type ram-type i s  array ( 0  to 2**ADDR-WIDTH-l) 
of std-logic-vector (DATA-WIDTH-1 downto 0) ; 
25 
s i g n a l  r a m :  ram-type; 
s i g n a l  addr-a-reg , addr-b-reg : 
std-logic-vector (ADDR-WIDTH -1 downto 0 )  ; 
begin 
process (clk) 
30 
begin 
if ( c l k ’ e v e n t  and clk = ’ 1 ’ )  then 
i f  (we = 
’ 1 ’ )  then 
end if ; 
addr-a-reg <= addr-a; 
addr-b-reg <= addr-b ; 
ram(to-integer(unsigned(addr-a))) 
<= din-a; 
end i f  ; 
end p r o c e s s ;  
dout-a <= rarn(to-integer(unsigned(addr-a-reg)); 
40 
dout-b <= ram(to_integer(unsigned(addr-b-reg)); 
end beh-arch; 
The code is similar to Listing 11.3 except that the two addresses are first stored in two 
registers and the registered outputs are used to access memory. 
11.4.3 ROM 
Despite its name, a ROM (read-only memory) is a combinational circuit and has no internal 
state. Its output depends only on its input (i.e., address). There is no real embedded ROM in 
a Spartan-3 device, but it can be emulated by a combinational circuit or a single-port RAM 
with the write operation disabled. The content of the ROM can be expressed as a constant 

252 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
in the HDL code and the values are loaded to the RAM when the device is programmed. 
Since the ROM is based in a RAM, the read operation can be asynchronous or synchronous. 
ROM with asynchronous read A real ROM is a combinational circuit and thus should 
not have a buffer or a clock signal. To be consistent with the terms used in this section, we 
call it a ROM with asynchronous read. The template of this type of ROM is shown by an 
example in Listing 11.5. The code is to implement the hex-to-seven segment LED encoder, 
similar to that in Listing 3.12. The address of the ROM functions as the 4-bit hexadecimal 
input and its content is the corresponding LED patterns. The content of the ROM is defined 
by the HEX2LEDAOM constant and is essentially the truth table of this circuit. 
Listing 11.5 Template for a ROM with asynchronous read 
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
use i e e e .  n u m e r i c - s t d .  a l l  ; 
e n t i t y  r o m - t e m p l a t e  i s  
5 
p o r t (  
a d d r :  in s t d - l o g i c - v e c t o r  ( 3  downto 0) ; 
d a t a :  out std-logic-vector (6 downto 0 )  
1 ;  
end r o m - t e m p l a t e ;  
10 
a r c h i t e c t u r e  a r c h  of r o m - t e m p l a t e  i s  
constant ADDR-WIDTH: integer : = 4 ;  
constant DATA-WIDTH: i n t e g e r  : = 7 ;  
type rom-type i s  array (0 to 2**ADDR_WIDTH-l) 
-- ROM d e f i n i t i o n  
constant HEXZLED-ROM: rom-type : = (  -- 2 ^ 4 - b y - 7  
I 5  
of std-logic-vector (DATA-WIDTH-1 downto 0 )  ; 
"0000001", -- a d d r  00 
"1001111", -- a d d r  0 1  
10 
"OOlOOlO", -- a d d r  0 2  
"0000110", -- a d d r  03 
" 1 0 0 1 1 0 0 " ,  
-- a d d r  0 4  
"0100100", -- a d d r  0 5  
" 0 1 0 0 0 0 0 " ,  -- a d d r  0 6  
" 0 0 0 1 1 1 1 " ,  -- a d d r  07 
" 0000000 " , -- a d d r  0 8  
" 0 0 0 0 1 0 0 " ,  -- a d d r  0 9  
"OOOlOOO", -- a d d r  1 0  
" 1 1 0 0 0 0 0 " ,  -- a d d r  I 1  
70 
"0110001", -- a d d r  1 2  
" 1 0 0 0 0 1 0 " ,  
-- a d d r  13 
" 0 1 1 0 0 0 0 " ,  
-- a d d r  1 4  
"0111000" 
-- a d d r  1 5  
1 ;  
35 begin 
d a t a  <= HEX2LED_ROM(to_integer(unsigned(addr))); 
end a r c h ;  
Note that the memory row is defined in ascending order: 
. . .  array (0 to Z**ADDR-WIDTH-I) of . . .  

HDL TEMPLATES FOR MEMORY INFERENCE 
253 
and the first row of the HEX2LEDBOM constant corresponds to the address 00 of the ROM. 
The rows defined in the HEX2LEDBOM table must be reversed if the rom-type data type is 
defined in descending order: 
. . array (2**ADDR-WIDTH-l downto 0) o f  . . . 
Since there is no address or data buffer in this circuit, the ROM cannot be realized by a 
block RAM. It is actually synthesized as a combinational circuit with the logic cells. The 
code can be considered as another form of a selected signal assignment or case statement. 
This type of ROM is feasible only for a small table. This code template is very general and 
is not specific to Xilinx devices. 
ROM with synchronous read For a large table, it is better to utilize a block RAM to 
realize the ROM. Since the read operation of a block RAM is controlled and synchronized 
by a clock signal, the ROM requires a clock signal as well. The template for the ROM with 
synchronous read is shown in Listing 11.6. It is modified after the rams-2lc entity of the 
XST Manual, and the hex-to-seven segment LED encoder is used for demonstration. 
Listing 11.6 Template for a ROM with synchronous read 
-- ROM with s y n c h r o n o u s  read 
-_ 
m o d i f i e d  f r o m  XST 8 . 1  i r a m s - 2 l c  
l i b r a r y  i e e e ;  
use ieee . std-logic-1164. a l l  ; 
j use i e e e .  numeric-std. a l l  ; 
e n t i t y  xilinx-rom-sync-template i s  
port ( 
c l k :  in std-logic; 
addr : in std-logic-vector (3 downto 0 )  ; 
10 
d a t a :  out std-logic-vector (6 downto 0 )  
) ;  
end xilinx-rom-sync-template; 
a r c  h i t  e c  t u r e  arch of xilinx-rom- sync- t emplate i s  
15 
constant ADDR-WIDTH : integer :=4; 
constant DATA-WIDTH: integer : = 7 ;  
type rom-type i s  array ( 0  to 2**ADDR_WIDTH-l) 
-- ROM d e f i n i t i o n  
of std-logic-vector (DATA-WIDTH-1 downto 0 )  ; 
20 
constant HEX2LED-ROM: rom-type : = (  -- 2*4-by-7 
" 0 0 0 0 0 0 1 ~ '  , -- a d d r  00 
"1001111", -- a d d r  01 
"OOlOOlO", -- a d d r  02 
" 0 0 0 0 1 1 0 " ,  -- a d d r  03 
23 
" 1 0 0 1 1 0 0 " ,  
-- a d d r  0 4  
" 0 1 0 0 1 0 0 " ,  -- a d d r  05 
" 0 1 0 0 0 0 0 " ,  -- a d d r  06 
" 0 0 0 1 1 1 1 " ,  -- a d d r  07 
" 0 0 0 0 0 0 0  " , -- a d d r  0 8  
"OOOOlOO", -- a d d r  0 9  
" 0 0 0 1 0 0 0 " ,  -- a d d r  10 
" l l O O O O O " ,  -- a d d r  1 1  
" O l l O O O l " ,  -- a d d r  1 2  
" l O O O O l O ~ ' ,  -- a d d r  1 3  
30 

254 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
35 
" 0 1 1 0 0 0 0 " ,  -- a d d r  14 
" 0 11 1000 " 
-- a d d r  1 5  
) ;  
begin 
s i g n a l  addr-reg : std-logic-vector (ADDR-WIDTH -1 downto 0 )  ; 
40 
-- a d d r  r e g i s t e r  t o  i n f e r  block RAM 
process (clk) 
begin 
i f  (clk'event and clk = '1') then 
addr-reg (= a d d r ;  
45 
end i f ;  
end p r o c e s s ;  
data <= HEX2LED-ROM (to-integer (unsigned (addr-reg))) ; 
end a r c h ;  
The code is similar to that of the single-port RAM with synchronous read but with a 
predefined constant. Note that operation of this ROM depends on the clock signal, and 
its timing is different from that of a normal ROM. Artificial inclusion of the clock signal 
is necessary to infer a block RAM for the ROM implementation. During synthesis, the 
software automatically determines whether to use regular logic cells or block RAMS to 
realize this circuit. 
11.5 BIBLIOGRAPHIC NOTES 
Two Xilinx application notes, XAPP464 Using Look-Up Tables as Distributed RAM in 
Spartan-3 Generation FPGAs and XAPP463 Using Block RAM in Spartan-3 Generation 
FPGAs, provide detailed information on the distributed RAM and block RAM. Chapter 2 of 
the XST User Guide v8.li, titled HDL Coding Techniques, includes about two dozen HDL 
code templates to infer various memory configurations. 
The comprehensive ISE tutorial, ISE In-Depth Tutorial, includes a section on the Core 
Generator program. Although the program is simple, we need to know the module's basic 
functionalities and its relevant parameters to create a proper instance. 
11.6 SUGGESTED EXPERIMENTS 
11.6.1 Block-RAM-based FIFO 
In Section 4.5.3, we design a FIFO buffer that uses a register file for storage. To increase its 
capacity, we can replace the register file with a block RAM-based dual-port RAM module. 
Derive the HDL code for the new design. Synthesize the verification circuit discussed 
in Section 4.5.3 with the new FIFO buffer and verify its operation. Note that due to the 
synchronous read, the behavior of the new FIFO is not completely identical to that of the 
original FIFO. 
11.6.2 Block-RAM-based stack 
We discuss the function of a stack in Experiment 4.7.7. To increase its capacity, we can 
replace the register file with a block RAM-based dual-port RAM module. Repeat the 
experiment. 

SUGGESTED EXPERIMENTS 
255 
11.6.3 ROM-based sign-magnitude adder 
We can implement any n-input, rn-output function with a 2"-by-m ROM. Consider the 
sign-magnitude adder discussed in Section 3.7.2 and assume that a and b are 4-bit input 
signals. Design this circuit as follows: 
1. Write a program in a conventional programing language, such as C or Java, to 
2. Follow the ROM template in Listing 11.5 to derive the HDL code. Cut and paste the 
3. Synthesize the circuit and verify its operation. 
4. Check the synthesis report and compare the sizes (in terms of the number of logic 
5. Expand a and b to 8-bit input signals and repeat steps 1 to 4. 
generate a 28-by-4 truth table for this circuit. 
table to the code. 
cells) of the original implementation and the ROM-based implementation. 
11.6.4 ROM based sin(z) function 
One way to implement a sinusoidal function, sin(z), is to use a look-up table. Assume 
that the desired implementation requires 10-bit input resolution [i.e., there are 1024 (21°) 
points between the input range of 0 and 2.1 
and 8-bit output resolution [i.e., there are 256 
(2') points between the output range of -1 and +1]. Let the input and output be the 10-bit 
z signal and the 8-bit y signal. The relationship between IC and y is 
Y - = sin 27r- 
27 
( 
;o) 
Because of the symmetry of the sin function, we only need to construct a 28-by-7 table 
for the first quadrant (i.e., between 0 and 4) and use simple pre- and postprocessing circuits 
to obtain the values in other quadrants. Design this circuit as follows: 
1. Write a program in a conventional programming language to generate the 28-by-7 
2. Follow the ROM template in Listing 11.6 to derive the HDL code for the look-up 
3. Derive the complete HDL code. 
4. Derive a testbench to generate the sinusoidal output for three complete periods. This 
can be done by using a 10-bit counter to generate the 10-bit ROM address for 3 * 21° 
clock cycles. In ModelSim, we can display the y signal in Analog format to emulate 
the effect of a digital-to-analog converter. 
table for the first quadrant. 
table. Cut and paste the table to the code. 
11.6.5 ROM-based sin(z) and cos(z) functions 
In many communication modulation schemes, the sin(z) and C O S ( I C )  functions are needed 
at the same time. Assume that the format of the input and output is similar to that in 
Experiment 11.6.4. The new circuit has two outputs, ys and yc: 
= sin (2.G) 
27 
27 - 
yc = cos (2.5) 
Although we can follow the previous procedure and create a new ROM for the COS(IC) 
function, a better alternative is to share the same ROM for both sin(z) and cos(z) functions. 

256 
XlLlNX SPARTAN-3 SPECIFIC MEMORY 
This is based on the observations that cos(z) is only a phase shift of sin(z) and that the 
FPGA’s block RAM can provide dual-port access. 
Note that this circuit requires essentially a “dual-port ROM.” No HDL behaviorial tem- 
plate is given for this type of memory. We need to experiment with HDL codes and to check 
the synthesis report to ensure that only one block RAM is inferred. It may be necessary 
to use the Core Generator program or direct HDL component instantiation to achieve this 
goal. 
Construct this special ROM and derive the HDL code for the pre- and postprocessing 
circuits. Use a testbench similar to that in Experiment 1 1.6.4 to verify the circuit’s operation. 

CHAPTER 12 
VGA CONTROLLER I: GRAPHIC 
12.1 INTRODUCTION 
VGA (video graphics array) is a video display standard introduced in the late 1980s in 
IBM PCs and is widely supported by PC graphics hardware and monitors. We discuss the 
design of a basic eight-color 640-by-480 resolution interface for CRT (cathode ray tube) 
monitors in this book. CRT synchronization and basic graphic processing are examined in 
this chapter, and text generation is discussed in Chapter 13. 
12.1.1 Basic operation of a CRT 
The conceptual sketch of a monochrome CRT monitor is shown in Figure 12.1. The 
electron gun (cathode) generates a focused electron beam, which traverses a vacuum tube 
and eventually hits the phosphorescent screen, Light is emitted at the instant that electrons 
hit a phosphor dot on the screen. The intensity of the electron beam and the brightness of 
the dot are determined by the voltage level of the external video input signal, labeled mono 
in Figure 12.1. The mono signal is an analog signal whose voltage level is between 0 and 
0.7 V. 
A vertical deflection coil and a horizontal deflection coil outside the tube produce mag- 
netic fields to control how the electron beam travels and to determine where on the screen 
the electrons hit. In today’s monitors, the electron beam traverses (i.e., scans) the screen 
systematically in a fixed pattern, from left to right and from top to bottom, as shown in 
Figure 12.2. 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
257 

258 
VGA CONTROLLER I: GRAPHIC 
Figure 12.1 Conceptual diagram of a CRT monitor. 
horizontal retrace - 
\ 
horizontal scan 
f 
\
\
 
- 
\
\
 
v. 
4> .-.................. ............... 1 
................................................... ’ 
--.. 
....... -.,- ................................................................................ 
............... ’:*. ....................................................................... 
b 
... 
-.. 
-.. 
-.. 
-*. 
% 
*-. 
% 
*a. 
i’.... 
*.. 
vertical retrace 
**. .... 
**.. 
%. 
1.. 
% 
..... 
-*. , 
c’ 
-*. 
................................................ 
................................ 
+... 
----:-,: 
L 
/ 
Figure 12.2 CRT scanning pattern. 

INTRODUCTION 
259 
Table 12.1 Three-bit VGA color combinations 
Red (R) 
Green (G) 
Blue (B) 
Resulting color 
0 
0 
0 
1 
1 
0 
1 
1 
0 
0 
0 
1 
1 
0 
1 
1 
black 
blue 
green 
cyan 
red 
magenta 
yellow 
white 
The monitor's internal oscillators and amplifiers generate sawtooth waveforms to control 
the two deflection coils. For example, the electron beam moves from the left edge to the 
right edge as the voltage applied to the horizontal deflection coil gradually increases. After 
reaching the right edge, the beam returns rapidly to the left edge (i.e., retraces) when the 
voltage changes to 0. The relationship between the sawtooth waveform and the scan is 
shown in Figure 12.4. Two external synchronization signals, hsync and vsync, control 
generation of the sawtooth waveforms. These signals are digital signals. The relationship 
between the hsync signal and the horizontal sawtooth is also shown in Figure 12.4. Note 
that the I' 1 and "0" periods of the hsync signal correspond to the rising and falling ramps 
of the sawtooth waveform. 
The basic operation of a color CRT is similar except that it has three electron beams, 
which are projected to the red, green, and blue phosphor dots on the screen. The three dots 
are combined to form a pixel. We can adjust the voltage levels of the three video input 
signals to obtain the desired pixel color. 
12.1.2 VGA port of the S3 board 
The VGA port has five active signals, including the horizontal and vertical synchronization 
signals, hsync and vsync, and three video signals for the red, green, and blue beams. It 
is physically connected to a 15-pin D-subminiature connector. A video signal is an analog 
signal and the video controller uses a digital-to-analog converter to convert the digital output 
to the desired analog level. If a video signal is represented by an N-bit word, it can be 
converted to 2N analog levels. The three video signals can generate 23N different colors. 
This is also known as 3N-bit color since a color is defined by 3N bits. In the S3 board, 1-bit 
word is used for each video signal, and this leads to only eight (i.e., 23) possible colors. 
The possible color combinations are shown in Table 12.1. If we use the same 1-bit signal 
to drive the video signals, they become either "000" or "1 11" and the monitor functions as 
a black-and-white monochrome monitor. 
12.1.3 Video controller 
A video controller generates the synchronization signals and outputs data pixels serially. 
A simplified block diagram of a VGA controller is shown in Figure 12.3. It contains a 
synchronization circuit, labeled vga-sync, and a pixel generation circuit. 

260 
VGA CONTROLLER I: GRAPHIC 
external 
dataicontrol 
~ 
- 
- 
pixel-x - 
pixel-y - 
video-on - 
rgb - 
pixel generation 
circuit 
> 
~ 
Figure 12.3 Simplified block diagram of a VGA controller. 
clk - 
~ 
The vga-sync circuit generates the timing and synchronization signals. The hsync and 
vsync signals are connected to the VGA port to control the horizontal and vertical scans 
of the monitor. The two signals are decoded from the internal counters, whose outputs 
are the pixel-x and pixel-y signals. The p i x e l x  and pixel-y signals indicate the 
relative positions of the scans and essentially specify the location of the current pixel. The 
vga-sync circuit also generates the video-on signal to indicate whether to enable or disable 
the display. The design of this circuit is discussed in Section 12.2. 
The pixel generation circuit generates the three video signals, which are collectively 
referred to as the rgb signal. A color value is obtained according to the current coordinates of 
the pixel (the pixel-x and pixel-y signals) and the external control and data signals. This 
circuit is more involved and is discussed in the second half of this chapter and Chapter 13. 
VGA 
monitor 
hsync 
vsync 
vga-sync 
> 
12.2 VGA SYNCHRONIZATION 
The video synchronization circuit generates the hsync signal, which specifies the required 
time to traverse (scan) a row, and the vsync signal, which specifies the required time to 
traverse (scan) the entire screen. Subsequent discussions are based on a 640-by-480 VGA 
screen with a 25-MHz pixel rate, which means that 25M pixels are processed in a second. 
Note that this resolution is also know as the VGA mode. 
The screen of a CRT monitor usually includes a small black border, as shown at the top 
of Figure 12.4. The middle rectangle is the visible portion. Note that the coordinate of the 
vertical axis increases downward. The coordinates of the top-left and bottom-right corners 
are (0,O) and (639,479), respectively. 
12.2.1 Horizontal synchronization 
A detailed timing diagram of one horizontal scan is shown in Figure 12.4. A period of the 
hsync signal contains 800 pixels and can be divided into four regions: 

VGA SYNCHRONIZATION 
261 
Figure 12.4 Timing diagram of a horizontal scan. 

262 
VGA CONTROLLER I: GRAPHIC 
480 horizontal scan lines 
,#, 
Figure 12.5 Timing diagram of a vertical scan. 
0 Display: region where the pixels are actually displayed on the screen. The length of 
this region is 640 pixels. 
Retrace: region in which the electron beams return to the left edge. The video signal 
should be disabled (i.e., black), and the length of this region is 96 pixels. 
0 Right border: region that forms the right border of the display region. It is also know 
as the front porch (i.e., porch before retrace). The video signal should be disabled, 
and the length of this region is 16 pixels. 
0 Left border: region that forms the left border of the display region. It is also know 
as the backporch (i.e., porch after retrace). The video signal should be disabled, and 
the length of this region is 48 pixels. 
Note that the lengths of the right and left borders may vary for different brands of monitors. 
The hsync signal can be obtained by a special mod-800 counter and a decoding circuit. 
The counts are marked on the top of the hsync signal in Figure 12.4. We intentionally start 
the counting from the beginning of the display region. This allows us to use the counter 
output as the horizontal (x-axis) coordinate. This output constitutes the pixel-x signal. 
The hsync signal goes low when the counter’s output is between 656 and 75 1. 
Note that the CRT monitor should be black in the right and left borders and during retrace. 
We use the h-video-on signal to indicate whether the current horizontal coordinate is in 
the displayable region. It is asserted only when the pixel count is smaller than 640. 
12.2.2 Vertical synchronization 
During the vertical scan, the electron beams move gradually from top to bottom and then 
return to the top. This corresponds to the time required to refresh the entire screen. The 
format of the vsync signal is similar to that of the hsync signal, as shown in Figure 12.5. 
The time unit of the movement is represented in terms of horizontal scan lines. A period 
of the vsync signal is 525 lines and can be divided into four regions: 
0 Display: region where the horizontal lines are actually displayed on the screen. The 
length of this region is 480 lines. 

VGA SYNCHRONIZATION 
263 
0 Retrace: region that the electron beams return to the top of the screen. The video 
signal should be disabled, and the length of this region is 2 lines. 
0 Bottom border: region that forms the bottom border of the display region. It is 
also know as thefrontporch (i.e., porch before retrace). The video signal should be 
disabled, and the length of this region is 10 lines. 
0 Top border: region that forms the top border of the display region. It is also know 
as the backporch (i,e,, porch after retrace). The video signal should be disabled, and 
the length of this region is 33 lines. 
As in the horizontal scan, the lengths of the top and bottom borders may vary for different 
brands of monitors. 
The vsync signal can be obtained by a special mod-525 counter and a decoding circuit. 
Again, we intentionally start counting from the beginning of the display region. This allows 
us to use the counter output as the vertical (y-axis) coordinate. This output constitutes the 
pixel-y signal. The vsync signal goes low when the line count is 490 or 491. 
As in the horizontal scan, we use the v-video-on signal to indicate whether the current 
vertical coordinate is in the displayable region. It is asserted only when the line count is 
smaller than 480. 
12.2.3 Timing calculation of VGA synchronization signals 
As mentioned earlier, we assume that the pixel rate is 25 MHz. It is determined by three 
parameters: 
0 p :  the number of pixels in a horizontal scan line. For 640-by-480 resolution, it is 
pixels 
line 
p = 800 ~ 
0 1: the number of lines in a screen (i.e., a vertical scan). For 640-by-480 resolution, it 
is 
lines 
1 = 525 - 
screen 
0 s: the number of screens per second. For flickering-free operation, we can set it to 
screens 
second 
~ ~ 6 0 -  
The s parameter specifies how fast the screen should be refreshed. For a human eye, 
the refresh rate must be at least 30 screens per second to make the motion appear to be 
continuous. To reduce flickering, the monitor usually has a much higher rate , such as the 
60 screens per second specification above. The pixel rate can be calculated by the three 
parameters : 
pixels 
pixel rate = p * 1 * s zz 2512.1 - 
second 
The pixel rate for other resolutions and refresh rates can be calculated in a similar fashion. 
Clearly, the rate increases as the resolution and refresh rate grow. 
12.2.4 HDL implementation 
The function of the vga-sync circuit is discussed in Section 12.1.3. If the frequency of 
the system clock is 25 MHz, the circuit can be implemented by two special counters: a 

264 
VGA CONTROLLER I: GRAPHIC 
mod-800 counter to keep track of the horizontal scan and a mod-525 counter to keep track 
of the vertical scan. 
Since our designs generally use the 50-MHz oscillator of the prototyping board, the 
system clock rate is twice the pixel rate. Instead of creating a separate 25-MHz clock 
domain and violating the synchronous design methodology, we can generate a 25-MHz 
enable tick to enable or pause the counting. The tick is also routed to the p-tick port as 
an output signal to coordinate operation of the pixel generation circuit. 
The HDL code is shown in Listing 12.1. It consists of a mod-2 counter to generate the 
25-MHz enable tick and two counters for the horizontal and vertical scans. We use two 
status signals, h-end and v-end, to indicate completion of the horizontal and vertical scans. 
The values of various regions of the horizontal and vertical scans are defined as constants. 
They can be easily modified if a different resolution or refresh rate is used. To remove 
potential glitches, output buffers are inserted for the hsync and vsync signals. This leads 
to a one-clock-cycle delay. We should add a similar buffer for the rgb signal in the pixel 
generation circuit to compensate for the delay. 
Listing 12.1 VGA synchronization circuit 
libr ar y ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  vga-sync i s  
c 
p o r t (  
clk, reset: in std-logic; 
hsync , vsync : out std-logic ; 
video-on, p-tick: out std-logic; 
pixel-x , pixel-y : out std-logic-vector (9 downto 0) 
10 
1 ;  
end vga- s ync ; 
a r c h i t e c t u r e  arch of vga-sync i s  
-- VGA 6 4 0 - b y  -480 s y n c  p a r a m e t e r s  
c ons tan t HF: integer:=16 ; --h. 
f r o n t  p o r c h  
c ons tan t HB: i n t e g e r : = 4 8  ; --h. 
back p o r c h  
c ons tan t HR: integer:=96 ; --h. 
r e t r a c e  
c ons tan t V D :  integer :=480; - - v e r t i c a l  
d i s p l a y  a r e a  
20 
constant V F :  i n t e g e r : = l O ;  -- v .  f r o n t  p o r c h  
c ons tan t V B :  integer :=33; -- v .  back p o r c h  
c ons tan t V R :  integer : = 2 ;  -- v .  r e t r a c e  
-- mod-2 c o u n t e r  
s i g n a l  m o d 2 _ r e g ,  mod2-next : std-logic; 
25 
-- s y n c  c o u n t e r s  
s i g n a l  v-count-reg , v-count-next : unsigned(9 downto 0) ; 
s i g n a l  h-count-reg , h-count-next : unsigned (9 downto 0 )  ; 
_- 
o u t p u t  b u f f e r  
s i g n a l  v-sync-reg , h-sync-reg : std-logic ; 
30 
s i g n a l  v-sync-next , h-sync-next : std-logic; 
__ s t a t u s  s i g n a l  
s i g n a l  h-end , v-end , pixel-tick: std-logic; 
-- r e g i s t e r s  
I S  
c ons tan t HD: integer :=640; - - h o r i z o n t a l  
d i s p l a y  a r e a  
begin 
35 
process (clk , reset) 

VGA SYNCHRONIZATION 
265 
40 
45 
begin 
if r e s e t = ’ l ’  then 
mod2-reg <= ’ 0 ’ ;  
v-count-reg <= ( o t h e r s = > ’ O ’ ) ;  
h-count-reg <= ( o t h e r s = > ’ O ’ ) ;  
v-sync-reg <= ’ 0 ’ ;  
h-sync-reg <= ’ 0 ’ ;  
e l s i f  (clk’event and clk=’l’) then 
mod2-reg <= mod2-next ; 
v-count-reg <= v-count-next; 
h-count-reg <= h-count-next; 
v-sync-reg <= v-sync-next ; 
h-sync-reg <= h-sync-next ; 
end if ; 
so 
end p r o c e s s ;  
-- mod-2 
c i r c u i t  t o  g e n e r a t e  2 5  MHz e n a b l e  t i c k  
mod2-next <= not mod2-reg; 
-- 2 5  MHz p i x e l  t i c k  
pixel-tick <= ’1’ when m o d 2 _ r e g = ’ l ’  e l s e  ’ 0 ’ ;  
h-end <= -- end of h o r i z o n t a l  c o u n t e r  
5s 
-- s t a t u s  
’ 1 ’  when h-count-reg=(HD+HF+HB+HR-l) e l s e  --799 
’ 0 ’ ;  
v-end <= -- end of v e r t i c a l  c o u n t e r  
tQ 
’1’ when v-count-reg=(VD+VF+VB+VR-l) e l s e  --524 
’ 0 ’ ;  
-- mod-800 h o r i z o n t a l  s y n c  c o u n t e r  
p r o c e s s  (h_count-reg,h-end,pixel-tick) 
begin 
65 
i f  pixel-tick=’l’ then -- 2 5  MHz t i c k  
if h - e n d = ’ l ’  then 
70 
h-count-next <= ( o t h e r s = > ’ O ’ ) ;  
h-count-next <= h-count-reg + 1 ;  
e l s e  
end if ; 
h-count-next <= h-count-reg; 
e l s e  
end if ; 
end p r o c e s s ;  
p r o c e s s  (v-count-reg,h-end,v-end,pixel-tick) 
begin 
7s 
-- mod-525 
v e r t i c a l  s y n c  c o u n t e r  
80 
if pixel-tick=’l’ and h - e n d = ’ l ’  then 
v-count-next <= ( o t h e r s = > ’ O ’ ) ;  
v-count-next <= v-count-reg + 1 ;  
if ( v - e n d = ’ l ’ )  then 
e l s e  
end if ; 
v-count-next <= v-count-reg; 
e l s e  
end if ; 
end p r o c e s s ;  
-- h o r i z o n t a l  and v e r t i c a l  s y n c ,  b u f f e r e d  t o  a v o i d  g l i t c h  

266 
VGA CONTROLLER I: GRAPHIC 
h-sync-next <= 
YO 
’ 1 ’ when (h-count-reg >=(HD+HF)) 
--656 
and (h-count_reg<=(HD+HF+HR-l)) else --751 
’ 0 ’ .  
’ 1 ’ when ( v- count -reg >= ( VD+VF ) ) 
--490 
’ 0 ’ ;  
-- v i d e o  o n / o f f  
video-on <= 
v-sync-next <= 
95 
and (v-count-reg<=(VD+VF+VR-l)) else --491 
’1’ when (h-count-reg<HD) and (v-count-reg<VD) else 
I00 
’ 0 ’ ;  
_- 
o u t p u t  s i g n a l  
hsync <= h-sync-reg ; 
vsync <= v-sync-reg ; 
pixel-x <= std-logic-vector(h-count-reg); 
Ioj 
pixel-y <= s t d - l o g i c - v e c t o r ( v - c o u n t _ r e g ) ;  
p-tick <= pixel-tick; 
end arch; 
12.2.5 Testing circuit 
To verify operation of the synchronization circuit, we can connect the rgb signal to three 
switches. The entire visible region should be turned on with a single color. We can go 
through the eight possible combinations and check the colors defined in Table 12.1. The 
HDL code is shown in Listing 12.2. As mentioned in Section 12.2.4, an output buffer is 
added for the rgb signal. 
Listing 12.2 VGA synchronization testing circuit 
library ieee; 
use ieee. std-logic-1164. all ; 
entity vga-test is 
port ( 
5 
clk, reset: in std-logic; 
sw: in std-logic-vector ( 2  downto 0 )  ; 
hsync , vsync : out 
std-logic; 
rgb : out std-logic-vector ( 2  downto 0 )  
) ;  
10 end vga-test ; 
architecture arch of vga-test is 
signal rgb-reg: std-logic-vector ( 2  downto 0) ; 
signal video-on: std-logic ; 
-- i n s t a n t i a t e  VGA s y n c  c i r c u i t  
vga-sync-unit : entity work. vga-sync 
I5 begin 
port map(clk=>clk, reset=>reset , hsync=>hsync , 
20 
p-tick=>open, pixel-x=>open, pixel-y=>open); 
vsync=>vsync, video-on=>video-on, 
-- r g b  b u f f e r  
process (clk , reset) 
begin 

OVERVIEW OF THE PIXEL GENERATION CIRCUIT 
267 
5 
i f  r e s e t = ’ l J  then 
e l s i f  (clk’event and clk=’l’) then 
end 
i f ;  
end p roces s  ; 
rgb-reg <= ( o t h e r s = > ’ O ’ ) ;  
rgb-reg <= s w ;  
10 
rgb <= rgb-reg when video-on=’l’ e l s e  “000”; 
end arch; 
12.3 OVERVIEW OF THE PIXEL GENERATION CIRCUIT 
The pixel generation circuit generates the 3-bit rgb signal for the VGA port. The external 
control and data signals specify the content of the screen, and the pixel-x and pixel-y 
signals from the vga-sync circuit provide the current coordinates of the pixel. For our 
discussion purposes, we divided this circuit into three broad categories: 
0 Bit-mapped scheme 
0 Tile-mapped scheme 
0 Object-mapped scheme 
In a bit-mapped scheme, a video memory is used to store the data to be displayed on the 
screen. Each pixel of the screen is mapped directly to a memory word, and the pixel-x 
and pixel-y signals form the address. A graphics processing circuit continuously updates 
the screen and writes relevant data to the video memory. A retrieval circuit continuously 
reads the video memory and routes the data to the rgb signal. This is the scheme used in 
today’s high-performance video controller. For 640-by-480 resolution, there are about 3 10k 
(i.e., 640*480) pixels on a screen. This translates to 310k memory bits for a monochrome 
display and 930k memory bits (i.e., 3 bits per pixel) for a 3-bit color display. A bit-mapped 
example is discussed in Section 12.5. 
To reduce the memory requirement, one alternative is to use a tile-mapped scheme. In 
this scheme, we group a collection of bits to form a tile and treat each tile as a display 
unit. For example. we can define an 8-by-8 square of pixels (i.e., 64 pixels) as a tile. 
The 640-by-480 pixel-oriented screen becomes an 80-by-60 tile-oriented screen. Only 
4800 (i.e., 8060) words are needed for the tile memory. The number of bits in a word 
depends on the number of tile patterns. For example, if there are 32 tile patterns, each word 
should contain 5 bits, and the size of the tile memory is about 24k bits (i.e., 5*4800). The 
tile-mapped scheme usually requires a ROM to store the tile patterns. We call it pattern 
memory. Assume that monochrome patterns are used in the previous example. Each 8-by- 
8 tile pattern requires 64 bits, and the entire 32 patterns need 2K (i.e., 8*8*32) bits. The 
overall memory requirement is about 26k bits, which is much smaller than the 310k bits of 
the bit-mapped scheme. The text display discussed in Chapter 13 is based on this scheme. 
For some applications, the video display can be very simple and contains only a few 
objects. Instead of wasting memory to store a mostly blank screen, we can generate these 
objects using simple object generation circuits. We call this approach an object-mapped 
scheme. An object-mapped example is discussed in Section 12.4. 
The three schemes can be mixed together to generate a full screen. For example, we can 
use a bit-mapped scheme to generate the background and use an object-mapped scheme to 
produce the main objects. We can also use a bit-mapped scheme for one portion of a screen 
and tile-mapped text for another part of the screen. 

268 
VGA CONTROLLER I: GRAPHIC 
dataicontrol 
video-on 
pixel-x 
pixel-y 
generation circuit I
Figure 12.6 Conceptual diagram of object-mapped pixel generation. 
12.4 GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
The conceptual diagram of an object-mapped pixel generation circuit that contains three 
objects is shown in Figure 12.6. The diagram consists of three object generation circuits 
and a special selecting and routing circuit, labeled rgb mux. An object generation circuit 
performs the following tasks: 
0 It keeps the coordinates of the current object and compares it with the current scan 
location provided by the pixel-x and pixel-y signals. 
0 If the current scan location falls within the region, it asserts the obj-i-on signal to 
indicate that the current scan location is within the region of the ith object and the 
object should be “turned on.” 
0 It specifies the desired color in the ob j -i-rgb signal. 
The rgb mux circuit performs multiplexing according to an internal prioritizing scheme. 
It examines various obj-Lon signals and determines which obj-i-rgb signal is to be 
routed to the rgb output. The prioritizing scheme prioritizes the order of the displays when 
multiple ob j i - o n  signals are asserted at the same time. It corresponds to selecting an 
object for the foreground. 
We use a simplified ping-pong-like game to illustrate the various graphic generation 
schemes. The design is constructed as follows: 
1. Create a simple still screen with rectangular objects. 
2. Add a round object. 
3. Introduce animation. 
4. Add text for scores and information. 
5. Create a top-level control circuit. 
The first three steps are discussed in this section, and the last two steps are discussed in 
Chapter 13. 

GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
269 
Figure 12.7 Still screen of the pong game. 
12.4.1 Rectangular objects 
A rectangular object can be described by its boundary coordinates on the screen. The still 
screen of the game is shown in Figure 12.7. It has three objects: a wall, which is shown as 
a narrow stripe on the left; a paddle, which is shown as a short vertical bar on the right; and 
a square ball. The coordinates of the displayable area of the screen is also shown. Note 
that the y-axis increases downward. 
Let us first examine generation of the wall stripe. For clarity, we define constants for the 
relevant boundaries and sizes in code. The code segment for the wall is 
constant WALL-X-L : i n t e g e r  : = 3 2 ;  
constant WALL-X-R: 
i n t e g e r  : = 3 5 ;  
__ p i x e l  w i t h i n  w a l l  
wall-on <= 
'1 ' when (WALL-X-L < = p i x - x )  and (pix-x<=WALL-X-R) 
e l s e  
' 0 ' ;  
__ w a l l  rgb o u t p u t  
w a l l - r g b  <= " 0 0 1 " ;  -- b l u e  
The wall is a four-pixel-wide vertical stripe between columns 32 and 35, which as 
defined as WALL-X-L and WALL-X-R, representing the left and right x-coordinates of the 
wall, respectively. The object has two output signals, wall-on and wall-rgb. The wall-on 
signal, which indicates that the wall object should be turned on, is asserted when the current 
horizontal scan is within its region. Since the stripe covers the entire vertical column, there 
is no need for the y-axis boundaries. The wall-rgb signal indicates that the color of the 
wall is "001" (blue). 
The code segment for the bar (paddle) is 
-- b a r  left , r i g h t  b o u n d a r y  
constant BAR-X-L: 
i n t e g e r  : = 6 0 0 ;  
constant B A R - X - R :  
i n t e g e r  : = 6 0 3 ;  

270 
VGA CONTROLLER I: GRAPHIC 
-- b a r  t o p ,  b o t t o m  b o u n d a r y  
constant B A R - Y - S I Z E :  
i n t e g e r : = 7 2 ;  
constant BAR-Y-T : integer : = M A X - Y / 2 - B A R - Y - S I Z E / 2 ;  
--204 
constant BAR-Y-B: 
integer:=BAR-Y-T+BAR-Y-SIZE-l; 
-- p i x e l  w i t h i n  b a r  
bar-on <= 
’ 1 ’  when (BAR-X-L <=pix-x) and (pix-x < = B A R - X - R )  
and 
’ 0 ’ ;  
(BAR-Y-T<=pix-y) and (pix-y<=BAR-Y-B) 
e l s e  
-- b a r  rgb o u t p u t  
bar-rgb <= ”010”; - - g r e e n  
The code is similar to that of the wall segment except that it includes the y-axis boundaries. 
The desired vertical length of the bar is 72 pixels, which is defined by BAR-Y-SIZE. Since 
we wish to place the bar in the middle, the top boundary of the bar, which is BAR-Y-T, is 
one half of the maximal y-value (i.e., 480/2) minus one half of the bar length. The bottom 
boundary of the bar is the top boundary plus the bar length. Generation of the bar-on signal 
is similar to that of the wall-on signal except that the vertical scan must be within the bar’s 
y-axis boundaries as well. 
The code for the ball can be constructed in a similar fashion. The final code segment is 
the selection and multiplexing circuit, which examines the on signals of three objects and 
routes the corresponding rgb signal to output. The code is 
process (video-on, wall-on, bar-on, sq-ball-on, 
wall-rgb,bar-rgb,ball-rgb) 
begin 
if v i d e o - o n = ’ O ’  then 
e l s e  
graph-rgb <= ” 0 0 0 ”  ; --blank 
i f  w a l l - o n = ’ l ’  then 
graph-rgb <= wall-rgb; 
e 1 s i f bar-on= ’ 1 ’ then 
graph-rgb <= bar-rgb; 
e l s i f  sq-ball-on=’l’ then 
graph-rgb <= ball-rgb ; 
e l s e  
graph-rgb <= ”110”; -- y e l l o w  b a c k g r o u n d  
end i f  ; 
end if ; 
end p r o c e s s ;  
The circuit first checks whether the video-on is asserted, and if this is the case, examines 
the three on signals in turn. When an on signal is asserted, it indicates that the scan is within 
its region, and the corresponding rgb signal is passed to the output. If no signal is asserted, 
the scan is in the “background” and the output is assigned to be “1 10” (yellow). 
The complete HDL code is shown in Listing 12.3. 
Listing 12.3 Pixel-generation circuit for the pong game screen 
library i e e e ;  
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  pong-graph-st i s  

GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
271 
5 
p o r t (  
v i d e o - o n :  
in s t d - l o g i c ;  
p i x e l - x  , p i x e l - y  : in s t d - l o g i c - v e c t o r  (9 downto 0) ; 
g r a p h - r g b  : out s t d - l o g i c - v e c t o r  ( 2  downto 0) 
1 ;  
10 end p o n g - g r a p h - s t  ; 
a r c h i t e c t u r e  s q - b a l l - a r c h  
of pong-graph-st 
i s  
-- x ,  y c o o r d i n a t e s  ( 0 , O )  t o  ( 6 3 9 , 4 7 9 )  
s i g n a l  pix-x , pix-y : u n s i g n e d  ( 9  downto 0) ; 
15 
constant MAX-X: 
i n t e g e r  :=640; 
constant MAX-Y: 
i n t e g e r  : =480; 
__ v e r t i c a l  s t r i p e  a s  a w a l l  
20 
-- w a l l  l e f t  , r i g h t  b o u n d a r y  
constant WALL-X-L: 
i n t e g e r  : =32; 
constant WALL-X-R: 
i n t e g e r  : =35; 
_- 
r i g h t  v e r t i c a l  b a r  
-- b u r  l e f t ,  r i g h t  b o u n d a r y  
constant BAR-X-L: 
i n t e g e r  :=600; 
constant BAR-X-R: 
i n t e g e r  :=603; 
-- b a r  t o p ,  b o t t o m  b o u n d a r y  
constant BAR-Y-T : i n t e g e r  :=MAX-Y/2-BAR-Y-SIZE/2; 
--204 
constant BAR-Y-B : i n t e g e r  :=BAR-Y_T+BAR-Y-SIZE-l; 
25 
- 
30 
constant BAR-Y-SIZE: 
i n t e g e r  : = 7 2 ;  
__ s q u a r e  b a l l  
constant BALL-SIZE: 
i n t e g e r  :=8; 
-_ 
b u l l  l e f t  , r i g h t  b o u n d a r y  
constant BALL-X-L: 
i n t e g e r  :=580; 
constant BALL-X-R : i n t e g e r  : =BALL-X-L+BALL-SIZE -1; 
constant BALL-Y-T: 
i n t e g e r  :=238; 
constant BALL-Y-B : i n t e g e r  :=BALL-Y-T+BALL-SIZE-l; 
35 
- 
40 
-- b a l l  t o p ,  b o t t o m  b o u n d a r y  
-_ 
o b j e c t  o u t p u t  s i g n a l s  
s i g n a l  w a l l - o n ,  b a r - o n ,  
s q - b a l l - o n :  
s t d - l o g i c ;  
s i g n a l  w a l l - r g b  , b a r - r g b  , b a l l - r g b :  
45 
- 
s t d - l o g i c - v e c t o r  ( 2  downto 0 )  ; 
-- ( w a l l )  l e f t  v e r t i c a l  s t r i p e  
-- p i x e l  w i t h i n  w a l l  
w a l l - o n  <= 
S5 
- 
50 begin 
pix-x <= unsigned(pixe1-x); 
pix-y <= unsigned(pixe1-y); 

272 
M) 
65 
70 
75 
80 
85 
90 
9s 
IW 
VGA CONTROLLER I: GRAPHIC 
’ 1 ’  when (WALL-X-L<=pix-x) and (pix-x<=WALL-X-R) e l s e  
’ 0 ’ ;  
_- 
w a l l  rgb o u t p u t  
wall-rgb <= “ 0 0 1 ” ;  -- b l u e  
_- 
r i g h t  v e r t i c a l  bar 
-- p i x e l  w i t h i n  b a r  
bar-on <= 
’1’ when (BAR-X-L<=pix-x) and (pix-x<=BAR-X-R) and 
’ 0 ’ ;  
(BAR-Y-T<=pix-y) and (pix-y<=BAR-Y-B) e l s e  
-- b a r  r g b  o u t p u t  
bar-rgb <= “ 0 1 0 ”  ; --green 
s q u a r e  b a l l  
-- 
-- p i x e l  w i t h i n  s q u a r e d  b a l l  
sq-ball-on <= 
’ 1 ’ when (BALL-X-L <=pix-x) and (pix-x <=BALL-X-R) and 
’ 0 ’ ;  
(BALL-Y-T <=pix-y) and (pix-y<=BALL-Y-B) e l s e  
ball-rgb <= “100”; -- red 
-- rgb m u l t i p l e x i n g  c i r c u i t  
- 
process(video-on,wall-on,bar-on,sq-ball-on, 
wall-rgb, bar-rgb, ball-rgb) 
begin 
if video-on=’O’ then 
e l s e  
graph-rgb <= “ 0 0 0 ”  ; --blank 
if w a l l - o n = ’ l ’  then 
graph-rgb <= wall-rgb; 
e l s i f  bar-on=’l’ then 
graph-rgb <= bar-rgb ; 
e l s i f  sq-ball-on=’l’ then 
graph-rgb <= ball-rgb; 
e l s e  
graph-rgb <= ”110” ; -- y e l l o w  b a c k g r o u n d  
end i f ;  
end i f  ; 
end p r o c e s s ;  
end sq-ball-arch ; 
After deriving the pixel generation circuit, we can combine it with the VGA synchro- 
nization circuit to construct the complete video interface. The top-level HDL code is shown 
in Listing 12.4. Note that the graph-rgb signal is routed to output through an output buffer. 
It is loaded when the pixel-tick signal is asserted. This synchronizes the rgb output with 
the buffered hsync and vsync signals. 
Listing 12.4 Complete circuit for a still pong game screen 
library i e e e ;  

GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
273 
20 
25 
use ieee. std-logic-1164, a l l  ; 
e n t i t y  pong-top-st is 
port ( 
5 
clk ,reset : in std-logic ; 
hsync , vsync : out 
std-logic; 
rgb: out std-logic-vector (2 downto 0) 
1 ;  
end pong-top-st ; 
a r c h i t e c t u r e  arch of pong-top-st i s  
10 
s i g n a l  pixel-x , pixel-y : std-logic-vector (9 downto 0 )  ; 
s i g n a l  video-on , pixel-tick: std-logic; 
s i g n a l  rgb-reg , rgb-next : std-logic-vector ( 2  downto 0) ; 
__ i n s t a n t i a t e  VGA s y n c  
vga-sync-unit : e n t i t y  work. vga-sync 
port map(clk=>clk, reset=>reset , 
I S  begin 
video-on=>video-on, p-tick=>pixel-tick, 
hsync=>hsync, vsync=>vsync, 
pixel-x=>pixel-x, pixel-y=>pixel-y); 
__ i n  s t a n t i a t e g r a p h i c  g e n e r a  t o r  
pong-grf-st-unit: e n t i t y  work.pong-graph-st(sq-ball-arch) 
port map (video-on=>video-on, 
pixel-x=>pixel-x, pixel-y=>pixel-y, 
graph-rgb=>rgb-next); 
__ rgb b u f f e r  
process (clk) 
begin 
30 
i f  (clk event and clk= ’ 1 ’ ) then 
i f  (pixel-tick=’l’) then 
end i f ;  
rgb-reg <= rgb-next ; 
end i f  ; 
35 
end p r o c e s s ;  
rgb <= rgb-reg; 
end arch; 
12.4.2 Non-rectangular object 
Direct checking of the boundaries of a non-rectangular object is very difficult. An alternative 
is to specify the object pattern in a bit map and generate the rgb and on signals according 
to the map. This can best be explained by an example. Assume that we want to have a 
round ball in the pong game screen. The bit map of a circle within an 8-by-8 pixel square 
is shown in Figure 12.8. The circle object can be generated as follows: 
0 Check whether the scan coordinates are within the 8-by-8 pixel square. 
0 If this is the case, obtain the corresponding pixel from the bit map. 
0 Use the retrieved bit to generate the rgb and on signals for the circle object. 
To implement this scheme, we need to include a pattern ROM to store the bit map and an 
address mapping circuit to convert the scan coordinates to the ROM’s row and column. 
To accommodate the change, the ball portion from Listing 12.3 must be modified. First, 
we define a pattern ROM for the circle. It can be done by declaring a two-dimensional 

274 
VGA CONTROLLER I: GRAPHIC 
Figure 12.8 Bit map of a circle. 
constant, as in the ROM template of Listing 11.5. To facilitate future animation, we also 
use signals to replace constants for the square ball boundaries. The revised architecture 
declaration portion becomes 
constant BALL-SIZE: 
i n t e g e r  : = 8 ;  
-- b a l l  l e f t ,  r i g h t  boundary 
s i g n a l  ball-x-l , b a l l - x - r  : u n s i g n e d  ( 9  downto 0) ; 
-_ 
b a l l  top , bottom boundary 
s i g n a l  b a l l - y - t  , b a l l - y - b  : u n s i g n e d  ( 9  downto 0 )  ; 
-- round b a l l  image ROM 
type rom-type i s  array ( 0  to 7 )  of s t d - l o g i c - v e c t o r ( 0  to 7 ) ;  
-- ROM d e f i n i t i o n  
constant BALL-ROM: 
rom-type 
:= 
----___--------_____------------------------- 
........................................... 
__------------------------------------------- 
I 
"00111100", -- 
**** 
" 0 1 1 1 1 1 1 0 " ,  -- ****** 
"11111111", -- * * * * * * * *  
" 1 1 1 1 1 1 1 1 " ,  -- * * * * * * * * 
"11111111", -- * * * * * * * *  
"11111111", -- * * * * * * * *  
" 0 1 1 1 1 1 1 0 " ,  -- ****** 
I' 00 11 1 1  00 " 
-- 
**** 
) ;  
s i g n a l  rom-addr , rom-col : u n s i g n e d  ( 2  downto 0) ; 
s i g n a l  r o m - d a t a :  
s t d - l o g i c - v e c t o r  ( 7  downto 0) ; 
s i g n a l  r o m - b i t  : s t d - l o g i c  ; 
-- new s i g n a l  t o  i n d i c a t e  whether t h e  scan c o o r d i n a t e s  
-- are w i t h i n  the round b a l l  r e g i o n  
s i g n a l  r d - b a l l - o n  : s t d - l o g i c ;  
Second, we expand the ball generation segment to include the mapping of the circle bit 
map: 
-- p i x e l  w i t h i n  square b a l l  
s q - b a l l - o n  
<= 
'1' when ( b a l l - x - l < = p i x - x )  and ( p i x - x < = b a l l - x - r )  and 
' 0 ' ;  
( b a l l - y - t  < = p i x - y )  and ( p i x - y < = b a l l - y - b )  
e l s e  
_- map c u r r e n t  p i x e l  l o c a t i o n  t o  ROM a d d r / c o l  
rom-addr <= p i x - y ( 2  downto 0) - b a l l - y - t ( 2  downto 0 ) ;  
rom-col <= p i x - x ( 2  downto 0) - b a l l - x - l ( 2  downto 0 ) ;  

GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
275 
rom-data <= BALL-ROM(to-integer(rom-addr)); 
rom-bit <= rom-data(to-integer(rom-co1)); 
rd-ball-on <= 
’1’ when (sq-ball-on=’l’) and (rom-bit=’l’) e l s e  
’ 0 ’ ;  
_- 
b a l l  rgb o u t p u t  
ball-rgb <= “100“; -- red 
The first statement checks whether the current scan coordinates are within the square ball 
region and asserts the sq-ball-on signal accordingly. This part is the same as Listing 12.3 
except that signals are used for boundaries. The second part obtains the corresponding ROM 
bit according to the current scan coordinates. If the scan coordinates are within the square 
ball region, subtracting the three LSBs from the top boundary (i.e., ball-y-t) provides 
the corresponding ROM row (i.e., rom-addr), and subtracting the three LSBs from the left 
boundary (i.e., ballx-1) provides the corresponding ROM column (i.e., rom-col). The bit 
can then be retrieved by two indexing operations. It is then combined with the sq-ball-on 
signal to generate the rd-ball-on signal. This design just assigns a monochrome color 
(i.e., “100” red) for the round ball region. We can duplicate the pattern ROM three times to 
store the rgb value for each pixel and generate a multiple-color ball. 
Finally, we need to make a minor modification in the multiplexing circuit to substitute 
the sq-ball-on signal with the rd-ball-on signal: 
process . . . 
. . .  
e l s i f  rd-ball-on=’l’ then 
graph-rgb <= ball-rgb; 
. . .  
end p r o c e s s ;  
These modifications are incorporated into the animated graph in the next subsection. 
12.4.3 Animated object 
When an object changes its location gradually in each scan, it creates the illusion of motion 
and becomes animated. To achieve this, we can use registers to store the boundaries of an 
object and update its value in each scan. In the pong game, the paddle is controlled by two 
pushbuttons and can move up and down, and the ball can move and bounce in all directions. 
We illustrate how to create animation for these two objects in this subsection. 
While the VGA controller is driven by a 25-MHz pixel rate, the screen of the VGA 
monitor is refreshed only 60 times per second. The boundary registers only need to be 
updated at this rate. We create a 60-Hz enable tick, ref r-tick, which is asserted one clock 
cycle every & second. 
Let us first examine the design of the paddle. To accommodate the changing y-axis 
coordinates, we replace the constants with two signals, bar-y-t and bar-y-b, to represent 
the top and bottom boundaries, and create a register, bar-y-reg, to store the current y- 
axis location of the top boundary. If one of the pushbuttons is pressed, bar-y-reg either 
increases or decreases a fixed amount when the ref r-tick signal is asserted. The amount 
is defined by a constant, BAR-V, which stands for the bar velocity. We assume that assertion 
of the btn(1) and btn(0) signals causes the paddle to move up and down, respectively, 
and that the paddle stops moving when it reaches the top or the bottom of the screen. The 
code segment for updating bar-y-reg is 

276 
VGA CONTROLLER I: GRAPHIC 
-- new bar y - p o s i t i o n  
process ( b a r - y - r e g ,  b a r - y - b ,  b a r - y - t  , r e f r - t i c k ,  b t n )  
begin 
b a r - y - n e x t  
<= b a r - y - r e g ;  -- d e f a u l t ,  no move 
i f  r e f r - t i c k = ’ l J  then 
i f  b t n ( l ) = ’ l ’  and bar-y-b<(MAX-Y-l-BAR-V) 
then 
-- b u t t o n  1 a s s e r t e d  and bar not reach bottom y e t  
e l s i f  b t n ( 0 ) = ’ 1 ’  and b a r - y - t  
> BAR-V 
then 
-- b u t t o n  0 a s s e r t e d  and bar not reach to p  y e t  
b a r - y - n e x t  
<= b a r - y - r e g  - BAR-V; -- move up 
end i f ;  
b a r - y - n e x t  
<= b a r - y - r e g  
+ BAR-V; -- move down 
end i f  ; 
end p r o c e s s ;  
The design of the ball is more involved. We have to replace the four boundary constants 
with four signals and create two registers, ball-x-reg and ball-y-reg, to store the current 
x- and y-axis coordinates of the left and top boundaries. The ball usually moves at a constant 
velocity (i.e., at a constant speed and in the same direction). It may change direction when 
hitting the wall, the paddle, or the bottom or top of the screen. We decompose the velocity 
into an x-component and a y-component, whose values can be either a positive constant 
value, BALL-V-P, or a negative constant value, BALL-V-N. The current values of the two 
components are stored in the x-delta-reg and y-delta-reg registers. The code segment 
for updating ball-x-reg and ball-y-reg is 
-- new b a l l  p o s i t i o n  
b a l l - x - n e x t  
<= 
b a l l - x - r e g  
+ x - d e l t a - r e g  when r e f r - t i c k = ’ l  ’ e l s e  
b a l l - x - r e g  ; 
b a l l - y - r e g  + y - d e l t a - r e g  when r e f r - t i c k = ’ l ’  e l s e  
b a l l - y - r e g  
; 
b a l l - y - n e x t  
<= 
and the code segment for updating x-delta-reg and y-delta-reg is 
-- new b a l l  v e l o c i t y  
process ( x - d e l t a - r e g  , y - d e l t a - r e g  , b a l l - y - t  , b a l l - x - 1  , b a l l - x - r  , 
begin 
ball-y-t,ball-y-b,bar-y-t,bar-y-b) 
x - d e l t a - n e x t  
<= x - d e l t a - r e g ;  --default 
, no change 
y - d e l t a - n e x t  
<= y - d e l t a - r e g ;  --default 
, no change 
if b a l l - y - t  
< 1 then -- reach to p  
y - d e l t a - n e x t  
<= BALL-V-P ; --down 
e l s i f  b a l l - y - b  
> (MAX-Y -1) then --reach 
bottom 
y - d e l t a - n e x t  
<= BALL-V-N; --up 
e l s i f  b a l l - x - 1  
<= WALL-X-R 
then --reach 
wall 
x - d e l t a - n e x t  
<= BALL-V-P; 
--bounce 
back ( t o  r i g h t )  
e l s i f  (BAR-X-L < = b a l l - x - r )  and ( b a l l - x - r  <=BAR-X-R) 
then 
-- reach x- co o rd i n a t e 
of bar 
i f  ( b a r - y - t  < = b a l l - y - b )  and ( b a l l - y - t  < = b a r - y - b )  then 
-- w i t h i n  y-range 
of b a r ,  h i t  
x - d e l t a - n e x t  
<= BALL-V-N; 
--bounce 
back ( to  l e f t  ) 
end i f  ; 
end i f  ; 
end p r o c e s s ;  

GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
277 
Note that if the paddle bar misses the ball, the ball continues moving to right and eventually 
wraps around. 
The complete code is shown in Listing 12.5. 
Listing 12.5 Pixel-generation circuit for the animated pong game 
lib rary ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  pong-graph-animat e i s  
5 
p o r t (  
clk, reset : std-logic ; 
btn: std-logic-vector (1 downto 0) ; 
video-on: in std-logic; 
pixel-x , pixel-y : in std-logic-vector ( 9 downto 0) ; 
10 
graph-rgb : out std-logic-vector (2 downto 0) 
) ;  
end pong-graph-animate ; 
a r c h i t e c t u r e  arch of pong-graph-animate i s  
I5 
s i g n a l  refr-tick : std-logic; 
-_ x ,  y 
c o o r d i n a t e s  (0,O) t o  ( 6 3 9 , 4 7 9 )  
s i g n a l  pix-x , pix-y : unsigned ( 9  downto 0) ; 
constant MAX-X: integer :=640; 
constant MAX-Y: integer:=480; 
-- v e r t i c a l  s t r i p e  a s  a w a l l  
20 
- 
_- 
w a l l  l e f t  , r i g h t  b o u n d a r y  
constant WALL-X-L : integer : =32 ; 
25 
constant WALL-X-R: integer :=35; 
__ r i g h t  p a d d l e  b a r  
-- b a r  l e f t  , r i g h t  b o u n d a r y  
30 
constant BAR-X-L: integer :=600; 
constant BAR-X-R: integer :=603; 
__ b a r  t o p ,  b o t t o m  b o u n d a r y  
s i g n a l  bar-y-t , bar-y-b : unsigned ( 9  downto 0) ; 
constant BAR-Y-SIZE: integer :=72; 
35 
-- reg t o  t r a c k  t o p  b o u n d a r y  
( x  p o s i t i o n  is f i x e d )  
s i g n a l  bar-y-reg , bar-y-next : unsigned ( 9  downto 0) ; 
-- b a r  moving v e l o c i t y  when a b u t t o n  i s  p r e s s e d  
constant BAR-V: integer:=4; 
40 
-- s q u a r e  b a l l  
constant BALL-SIZE: integer:=8; -- 8 
-- b a l l  l e f t ,  r i g h t  b o u n d a r y  
s i g n a l  ball-x-1 , ball-x-r : unsigned ( 9  downto 0) ; 
15 
-- b a l l  t o p  , b o t t o m  b o u n d a r y  
s i g n a l  ball-y-t , ball-y-b : unsigned (9 downto 0) ; 
_- 
reg t o  t r a c k  l e f t  , t o p  b o u n d a r y  
s i g n a l  ball-x-reg , ball-x-next : unsigned ( 9  downto 0) ; 

VGA CONTROLLER I: GRAPHIC 
278 
50 
55 
60 
65 
70 
s i g n a l  b a l l - y - r e g  , b a l l - y - n e x t  : u n s i g n e d  ( 9  downto 0) ; 
-_ 
reg t o  t r a c k  b a l l  s p e e d  
s i g n a l  x - d e l t a - r e g  , x-delta-next : u n s i g n e d ( 9  downto 0 )  ; 
s i g n a l  y - d e l t a - r e g  , y - d e l t a - n e x t  : u n s i g n e d ( 9  downto 0 )  ; 
-- b a l l  v e l o c i t y  can be p o s  o r  neg 
constant BALL-V-P : u n s i g n e d  ( 9  downto 0 )  
: = t o - u n s i g n e d  ( 2 , 1 0 1  ; 
constant BALL-V-N : u n s i g n e d  ( 9  downto 0) 
: = u n s i g n e d  ( t o - s i g n e d  (-2,lO) ; 
~~ 
-- round b a l l  image ROM 
type rom-type 
i s  array (0 t o  7) 
-- ROM d e f i n i t i o n  
constant BALL-RUM: 
rom-type 
: = 
( 
of s t d - l o g i c - v e c t o r ( 0  
to 7 ) ;  
" 0 0 1 1 1 1 0 0 " ,  -- 
**** 
" 0 1 1 1 1 1 1 0 " ,  -- ****** 
"11111111", -- * * * * * * * * 
"11111111", -- * * * * * * * *  
"11111111", -- * * * * * * * *  
"11111111", -- * * * * * * * *  
" 0 1 1 1 1 1 1 0 " ,  -- ****** 
" 0 0 1 1 1 100 '1 
-- 
**** 
) ;  
s i g n a l  rom-addr , rom-col : u n s i g n e d  ( 2  downto 0) ; 
s i g n a l  r o m - d a t a :  s t d - l o g i c - v e c t o r  ( 7  downto 0) ; 
s i g n a l  rom-bit : s t d - l o g i c ;  
-- o b j e c t  o u t p u t  s i g n a l s  
s i g n a l  w a l l - o n ,  b a r - o n ,  
s q - b a l l - o n ,  
r d - b a l l - o n :  
s t d - l o g i c ;  
s i g n a l  w a l l - r g b  , b a r - r g b  , b a l l - r g b  : 
s t d - l o g i c - v e c t o r  ( 2  downto 0) ; 
begin 
85 
-- r e g i s t e r s  
90 
9s 
process ( c l k  , r e s e t  1 
begin 
if r e s e t = ' l '  then 
b a r - y - r e g  
<= ( o t h e r s = > ' O ' ) ;  
b a l l - x - r e g  
<= C o t h e r s = > ' O ' ) ;  
b a l l - y - r e g  
<= ( o t h e r s = > ' O ' ) ;  
x - d e l t a - r e g  
<= ( " 0 0 0 0 0 0 0 1 0 0 ' ' )  ; 
y - d e l t a - r e g  
<= ( " 0 0 0 0 0 0 0 1 0 0 ' ' )  ; 
b a r - y - r e g  
<= b a r - y - n e x t  ; 
b a l l - x - r e g  
<= b a l l - x - n e x t  ; 
b a l l - y - r e g  
<= b a l l - y - n e x t  ; 
x - d e l t a - r e g  
<= x - d e l t a - n e x t  ; 
e 1 s i f  ( c l k  ' e v e n t  and c l k =  ' 1 ' ) then 
y - d e l t a - r e g  
<= y - d e l t a - n e x t  ; 
IW 
end i f  ; 
end p r o c e s s ;  

GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
279 
ins 
I10 
115 
i 20 
I25 
I30 
I35 
p i x - x  <= u n s i g n e d ( p i x e 1 - x ) ;  
p i x - y  <= u n s i g n e d ( p i x e 1 - y ) ;  
__ r e f r - t i c k :  1 - c l o c k  
t i c k  a s s e r t e d  a t  s t a r t  o f  v-sync 
__ 
i . e . ,  when t h e  s c r e e n  i s  r e f r e s h e d  ( 6 0  H z )  
r e f r - t i c k  <= ’ 1 ’  when ( p i x - y = 4 8 1 )  and (pix-x=O) 
e l s e  
’ 0 ’ .  
-- ( w a l l )  l e f t  v e r t i c a l  s t r i p e  
-- p i x e l  w i t h i n  w a l l  
w a l l - o n  <= 
’1 ’ when (WALL-X-L < = p i x - x )  and (pix-x<=WALL-X-R) 
e l s e  
’ 0 ’ ;  
_- 
w a l l  r g b  o u t p u t  
w a l l - r g b  <= “ 0 0 1 “ ;  -- b l u e  
-_ 
r i g h t  v e r t i c a l  bar 
-- b o u n d a r y  
b a r - y - t  
<= b a r - y - r e g ;  
bar-y-b 
<= b a r - y - t  
+ BAR-Y-SIZE 
- 1; 
-- p i x e l  w i t h i n  b a r  
bar-on <= 
’1 ’ when (BAR-X-L<=pix-x) 
and (pix-x<=BAR-X-R) 
and 
’ 0 ’ ;  
( b a r - y - t  < = p i x - y )  and ( p i x - y < = b a r - y - b )  
e l s e  
-- b a r  rgb o u t p u t  
b a r - r g b  <= “ 0 1 0 ”  ; --green 
-- new b a r  y - p o s i t i o n  
process ( b a r - y - r e g  , b a r - y - b ,  b a r - y - t  , r e f r - t i c k  , b t n )  
begin 
b a r - y - n e x t  
<= b a r - y - r e g  ; -- no move 
if r e f r - t i c k = ’ l ’  then 
if b t n ( l ) = ’ l ’  and bar-y-b<(MAX-Y-l-BAR-V) 
then 
e l s i f  b t n ( O ) = ’ l ’  and b a r - y - t  
> BAR-V 
then 
end i f ;  
b a r - y - n e x t  
<= b a r - y - r e g  
+ B A R - V ;  -- move down 
b a r - y - n e x t  
<= b a r - y - r e g  - B A R - V ;  -- move up 
end if ; 
end p r o c e s s ;  
-- s q u a r e  b a l l  
-- b o u n d a  ry 
b a l l - x - 1  
<= b a l l - x - r e g ;  
b a l l - y - t  
<= b a l l - y - r e g ;  
b a l l - x - r  
<= b a l l - x - 1  + BALL-SIZE - 1; 
b a l l - y - b  
<= b a l l - y - t  
+ BALL-SIZE - 1; 
-- p i x e l  w i t h i n  b a l l  
s q - b a l l - o n  
<= 
’ 1 ’ when ( b a l l - x - 1  < = p i x - x )  and ( p i x - x < = b a l l - x - r )  
and 
( b a l l - y - t  < = p i x - y )  and ( p i x - y < = b a l l - y - b )  e l s e  

VGA CONTROLLER I: GRAPHIC 
280 
I55 
IMI 
I65 
I70 
175 
I80 
185 
190 
195 
ZW 
205 
’ 0 ’ ;  
-- map c u r r e n t  p i x e l  l o c a t i o n  to  ROM a d d r / c o l  
rom-addr <= pix-y(2 downto 0) - ball-y-t(2 d o w n t o ’ 0 ) ;  
rom-col <= pix-x(2 downto 0 )  - ball-x-l(2 downto 0 ) ;  
rom-data <= BALL-ROM(to_integer(rom-addr)); 
rom-bit <= rom-data(to-integer(rom-co1)); 
-- p i x e l  w i t h i n  b a l l  
rd-ball-on <= 
’ 1 ’ when 
J O ’ ;  
__ b a l l  rgb 
ball-rgb <= 
-- new b a l l  
ball-x-next 
ball-y-next 
-- new b a l l  
(sq-ball-on=’l’) and (rom-bit=’l’) e l s e  
o u t p u t  
” 1 0 0 ” ;  
-- red 
p o s i t i o n  
<= ball-x-reg + x-delta-reg 
when refr-tick=’l’ e l s e  
ball-x-reg ; 
<= ball-y-reg + y-delta-reg 
when refr-tick=’l’ e l s e  
ball-y-reg ; 
v e l o c i t y  
process (x-delta-reg , y-delta-reg , ball-y-t , ball-x-1 , ball-x-r , 
begin 
ball-y-t,ball-y-b,bar-y-t,bar-y-b) 
x-delta-next <= x-delta-reg; 
y-delta-next <= y-delta-reg ; 
i f  ball-y-t < 1 then -- reach top 
y-delta-next <= BALL-V-P ; 
e l s i f  ball-y-b > (MAX-Y-1) then 
-- reach bottom 
y-delta-next <= BALL-V-N; 
e l s i f  ball-x-1 <= WALL-X-R 
then -- reach wall 
x-delta-next <= BALL-V-P ; 
-- bounce back 
e l s i f  (BAR-X-L<=ball-x-r) and (ball-x-r <=BAR-X-R) then 
__ reach x of r i g h t  bar 
i f  (bar-y-t <=ball-y-b) and (ball-y-t <=bar-y-b) then 
end if ; 
x-delta-next <= BALL-V-N ; --hit 
, bounce back 
end i f  ; 
end p r o c e s s ;  
__ rgb m u l t i p l e x i n g  c i r c u i t  
process(vide0-on,wall-on,bar-on,rd-ball-on, 
wall-rgb, bar-rgb, ball-rgb) 
begin 
if video-on=’O’ then 
e l s e  
graph-rgb <= “000“ 
; --blank 
i f  wall-on=’l’ then 
graph-rgb <= wall-rgb; 
e 1 s i f bar-on= ’ 1 
then 
graph-rgb <= bar-rgb ; 
e l s i f  rd-ball-on=’l’ then 
graph-rgb <= ball-rgb; 

GRAPHIC GENERATION WITH AN OBJECT-MAPPED SCHEME 
281 
e l s e  
graph-rgb <= “110”; -- y e llo w  background 
110 
end if ; 
end if ; 
end p r o c e s s ;  
end arch; 
As in the still screen, we can combine the synchronization circuit and create the top-level 
description. The HDL code is shown in Listing 12.6. 
Listing 12.6 Complete circuit for the animated pong game screen 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  pong-top-an i s  
p o r t  ( 
5 
clk, reset : in std-logic ; 
btn: in std-logic-vector (1 downto 0); 
hsync , vsync : o u t  
std-logic ; 
rgb: o u t  std-logic-vector ( 2  downto 0) 
) ;  
10 end pong-top-an; 
a r c h i t e c t u r e  arch of pong-top-an i s  
s i g n a l  pixel-x , pixel-y : std-logic-vector (9 downto 0) ; 
s i g n a l  video-on , pixel-tick: std-logic; 
I S  
s i g n a l  rgb-reg , rgb-next : std-logic-vector ( 2  downto 0 )  ; 
begin 
-_ 
i n s t a n t i a t e  VGA sync 
vga-sync-unit : e n t i t y  work. vga-sync 
p o r t  map(clk=>clk, reset=>reset , 
video-on=>video-on, p-tick=>pixel-tick, 
hsync=>hsync, vsync=>vsync, 
pixel-x=>pixel-x, pixel-y=>pixel-y); 
10 
__ i n s t a n t i a t e  g ra p h i c g e n e r a t o r  
pong-graph-an-unit : e n t i t y  work. pong-graph-animate 
25 
p o r t  map (clk=>clk, reset=>reset , 
btn=>btn , video-on=>video-on , 
pixel-x=>pixel-x, pixel-y=>pixel-y, 
graph-rgb=>rgb-next); 
-- rgb b u f f e r  
30 
p r o c e s s  (clk) 
begin 
if (clk’event and clk=’l’) then 
if (pixel-tick=’l’) then 
15 
rgb-reg <= rgb-next ; 
end if ; 
end if ; 
end p r o c e s s ;  
rgb <= rgb-reg; 
end arch; 
Note that there is no other control mechanism is this code. The ball simply moves and 
bounces continuously. A top-level control circuit is discussed in Chapter 13. 

282 
VGA CONTROLLER I: GRAPHIC 
Figure 12.9 Dot trace shown in a 128-by-128 bit map. 
12.5 GRAPHIC GENERATION WITH A BIT-MAPPED SCHEME 
The bit-mapped scheme maps each pixel to a word in video memory. There are about 
3 10k pixels in a 640-by-480 screen. This translates to 3 10k and 930k bits for monochrome 
and color displays, respectively. The actual size of the video memory can be much larger 
since the memory address must be properly aligned for fast access. For example, to map 
the pixel’s current coordinates to a memory location, we can concatenate the pixel’s x- 
coordinate, which is 10 bits (i.e., rlog,(640)1), and the pixel’s y-coordinate, which is 9 bits 
(Le., [log, (48O)l). This approach requires no additional circuit to translating the pixel’s 
coordinates to a memory address but introduces some unused “holes” in memory. The 
memory size is increased from 310k words to 512K (i.e., 21°+’) words. 
For the S3 board, memory is available from the external SRAM chips and FPGAs 
embedded block RAMs, as discussed in Chapters 10 and 11. Recall that the total capacity 
of the Spartan 3S200 device’s block RAM is only about 192K bits. It is not large enough 
for a full-screen bit-mapped display. We must use the external SRAM, which is 8M bits, 
for this purpose. 
In this section, we use a small 128-by-128 (27-by-27) area of the screen to illustrate the 
design of the bit-mapped scheme. The screen has 16K 
pixels in this area and requires 
a 16K-by-3 video memory for color display. This can be implemented by three embedded 
block RAMs. The small area is at the top-left comer of the screen and displays the trace 
of a bouncing one-pixel dot, as shown in Figure 12.9. The circuit uses a 3-bit switch to 
specify the color of the trace and a pushbutton switch to randomly select the origin of the 
trace. When the pushbutton switch is pressed, the dot starts to move, like the bouncing ball 
in Section 12.4.3. The trace forms a rectangle after the dot hits the four sides of the small 
area. A new trace is generated each time the pushbutton switch is pressed. 
12.5.1 Dual-port RAM implementation 
A conceptual block diagram of this circuit is shown in Figure 12.10. The video memory is a 

GRAPHIC GENERATION WITH A BIT-MAPPED SCHEME 
283 
- 
7 
pixel-x 
= 
14 ’ 
addr-w 
addr-r - 
- 
3 
3 
Figure 12.10 Conceptual block diagram of a dot trace circuit. 
+- din 
dout 
- 
7 
synchronous 16K-by-3 (i.e., 214-by-3) dual-port RAM. The dual-port module discussed in 
Listing 1 1.4 can be used for this purpose. The seven LSBs of the pixel’s y-coordinate form 
the seven MSBs of the memory address, and the seven LSBs of the pixel’s x-coordinate 
form the seven LSBs of the memory address. The d o t x y  circuit keeps track of the current 
location of the dot and generates its current y- and x-coordinates, which are concatenated as 
the write address. The 3-bit external switch input, sw, is the rgb value, which is connected 
to the memory’s din-a port. The seven LSBs of pixel-y and the seven LSBs of pixel-x 
form the read address. The data is retrieved continuously and the corresponding readout is 
routed to the rgb multiplexing circuit. 
The complete code of the dot trace pixel generation circuit is shown in Listing 12.7. 
We use two registers, dotx-reg and dot-y-reg, to keep track of the dot’s current x- and 
y-coordinates and use two registers, v-x-reg and v-y-reg, to keep track of the current 
horizontal and vertical velocities. Computation of the dot’s coordinates and velocities is 
similar to that of the bouncing ball in Section 12.4.3. In addition to regular updates, the 
dot-xnext and dot-ynext signals obtain the values of the seven LSBs of pix-x and 
pix-y when the pushbutton switch is pressed. Since these signals change much faster than 
a human’s perception, the new origin appears to be random. 
Listing 12.7 Pixel-generation circuit for a 128-by-128 bit map 
l i b r a r y  i e e e ;  
use ieee.std-logic-ll64.all; 
use i e e e .  n u m e r i c - s t d .  a l l  ; 
e n t i t y  bitmap-gen is 
5 
p o r t (  
c l k  , r e s e t  : s t d - l o g i c ;  
b t n :  s t d - l o g i c - v e c t o r  ( I  downto 0 )  ; 
s w :  std-logic-vector ( 2  downto 0 )  ; 
v i d e o - o n :  in s t d - l o g i c ;  
b i t - r g b :  out std-logic-vector ( 2  downto 0 )  
10 
pixel-x , pixel-y : in std-logic-vector ( 9  downto 0 )  ; 
) ;  
end bitmap-gen; 
btn 
we 
dot-xy 
> 
bitmap-on - 
sw 
rg b 
rgb - 
mux 
we 
dual-port 
video memory 
> 

284 
VGA CONTROLLER I: GRAPHIC 
i j  a r c h i t e c t u r e  dual-port-ram-arch of bitmap-gen i s  
s i g n a l  pix-x , pix-y : unsigned ( 9  downto 0) ; 
s i g n a l  refr-tick: std-logic; 
s i g n a l  load-tick: std-logic ; 
20 
25 
30 
35 
40 
45 
-- v i d e o  sram 
s i g n a l  we: std-logic; 
s i g n a l  addr-r , addr-w: std-logic-vector (13 downto 0 )  ; 
s i g n a l  din, dout : std-logic-vector ( 2  downto 0) ; 
- 
-- d o t  l o c a t i o n  and v e l o c i t y  
c ons tan t MAX-X: integer : = 1 2 8 ;  
c ons tan t MAX-Y: integer : = 1 2 8 ;  
__ d o t  v e l o c i t y  can be p o s  or neg 
c ons tan t DOT-V-P : unsigned (6 downto 0) 
:=to_unsigned(l,7); 
c ons tan t DOT-V-N : unsigned ( 6  downto 0) 
:=unsigned(to-signed(-l ,711; 
__ reg t o  k e e p  t r a c k  of d o t  l o c a t i o n  
s i g n a l  dot-x-reg , dot-x-next : unsigned (6 downto 0) ; 
s i g n a l  dot-y-reg , dot-y-next : unsigned (6 downto 0) ; 
__ reg t o  k e e p  t r a c k  of 
d o t  v e l o c i t y  
s i g n a l  v-x-reg , v-x-next : unsigned ( 6  downto 0 )  ; 
s i g n a l  v-y-reg , v-y-next : unsigned ( 6  downto 0 )  ; 
__ o b j e c t  o u t p u t  s i g n a l s  
s i g n a l  bitmap-on: std-logic ; 
s i g n a l  bitmap-rgb: std-logic-vector ( 2  downto 0 )  ; 
begin 
__ i n s t a n t i a t e  d e b o u n c e  c i r c u i t  for a b u t t o n  
debounce-unit : e n t i t y  work. debounce 
so 
port map(clk=>clk, reset=>reset , sw=>btn(O), 
db-level=>open, db-tick=>load-tick); 
__ i n s t a n t i a t e  d u a l - p o r t  
v i d e o  RAM ( 2 ^ 1 2  - b y - 7 )  
video-ram: e n t i t y  work.xilinx-dual-port-ram-sync 
g e n e r i c map ( ADDR- W I DTH = > 14 , DATA - W I DTH = > 3 )  
port map(clk=>clk, we=>we, 
( 5  
addr-a=>addr-w, addr-b=>addr-r, 
din-a=>din , dout-a=>open , dout-b=>dout) ; 
-- v i d e o  ram i n t e r f a c e  
addr-w <= std-logic-vector(dot-y-reg 
& dot-x-reg); 
addr-r <= 
we <= ’1’; 
din <= sw; 
bitmap-rgb <= dout; 
__ r e g i s t e r s  
begin 
60 
std-logic-vector (pix-y (6 downto 0) & pix-x ( 6  downto 0 ) )  ; 
65 
process (clk, reset 
i f  reset=’l’ then 

GRAPHIC GENERATION WITH A BIT-MAPPED SCHEME 
285 
70 
75 
dot-x-reg <= ( o t h e r s = > ’ O ’ ) ;  
dot-y-reg <= ( o t h e r s = > ’ O ’ ) ;  
v-x-reg <= DOT-V-P; 
v-y-reg <= DOT-V-P; 
dot-x-reg <= dot-x-next ; 
dot-y-reg <= dot-y-next ; 
v-x-reg <= v-x-next ; 
v-y-reg <= v-y-next ; 
e l s i f  (clk’event and clk=’lJ) then 
end i f ;  
end p r o c e s s ;  
__ m i s c .  s i g n a l s  
so 
pix-x <= unsigned(pixe1-x) ; 
pix-y <= unsigned(pixe1-y); 
refr-tick <= ’ 1 ’  when (pix-y=481) and (pix-x=O) e l s e  
__ p i x e l  w i t h i n  b i t  map area 
’ O J ;  
85 
bitmap-on <= 
’1 when (pix-x <=127) and (pix-y <=127) e l s e  
J O  J . , 
-- d o t  p o s i t i o n  
-- ”randomly ‘I 
load dot l o c a t i o n  when btn ( 0 )  p r e s s e d  
90 
dot-x-next <= 
pix-x ( 6  downto 0) when load-tick= 1 
e l s e  
dot-x-reg + v-x-reg when refr-tick=’l ’ e l s e  
dot-x-reg ; 
dot-y-next <= 
95 
pix-y ( 6  downto 0) when load-tick= ’1 e l s e  
dot-y-reg + v-y-reg when refr-tick= 1 
e l s e  
dot-y-reg ; 
-- dot x v e l o c i t y  
process (v-x-reg , dot-x-reg) 
v-x-next <= v-x-reg ; 
IW 
begin 
I05 
if dot-x-reg =1 then 
-- reach l e f t  
v-x-next <= DOT-V-P ; 
-- bounce back 
e l s i f  dot-x-reg=(MAX-X-2) then -- reach r i g h t  
v-x-next <= DOT-V-N ; 
-- bounce back 
end i f  ; 
end p r o c e s s ;  
-- dot y 
v e l o c i t y  
process (v-y-reg , dot-y-reg) 
v-y-next <= v-y-reg; 
110 
begin 
I I 5  
i f  dot-y-reg =l then 
-- reach top 
e l s i f  dot-y-reg = (MAX-Y-2) then -- reach bottom 
end i f  ; 
end p r o c e s s ;  
v-y-next <= DOT-V-P ; 
v-y-next <= DOT-V-N ; 
-- rgb m u l t i p l e x i n g  c i r c u i t  
process (video-on , bitmap-on , bitmap-rgb) 
120 
begin 

286 
VGA CONTROLLER I: GRAPHIC 
I25 
if video-on=’O’ then 
e l s e  
bit-rgb <= “ 0 0 0 “ ;  --blank 
if bitmap-on=’l’ then 
e l s e  
end if ; 
bit-rgb <= bitmap-rgb ; 
bit-rgb <= ” 1 1 0 ” ;  -- y e l l o w  b a c k g r o u n d  
end if ; 
130 
end p r o c e s s ;  
end dual-port-ram-arch; 
The HDL code for the top-level system is shown in Listing 12.8. 
Listing 12.8 Complete circuit for a bit-mapped screen 
l i b r a r y  ieee; 
use ieee.std-logic-1164.all; 
e n t i t y  dot-top i s  
p o r t  ( 
5 
clk, reset : in std-logic ; 
btn: in std-logic-vector (1 downto 0 ) ;  
sw: in std-logic-vector ( 2  downto 0 ) ;  
hsync , vsync : o u t 
std-logic; 
rgb : o u t std-logic-vector ( 2  downto 0) 
10 
) ; 
end dot-top; 
a r c h i t e c t u r e  arch of dot-top i s  
s i g n a l  pixel-x , pixel-y : std-logic-vector ( 9  downto 0 )  ; 
s i g n a l  rgb-reg , rgb-next : std-logic-vector ( 2  downto 0) ; 
-_ 
i n s t a n t i a t e  VGA s y n c  c i r c u i t  
vga-sync-unit : e n t i t y  work. vga-sync 
20 
p o r t  map(clk=>clk, reset=>reset , 
15 
s i g n a l  video-on , pixel-tick: std-logic; 
begin 
hsync=>hsync, vsync=>vsync, 
video-on=>video-on, p-tick=>pixel-tick, 
pixel-x=>pixel-x, pixel-y=>pixel-y); 
__ i n s t a n t i a t e 
bit -mapped 
p i x  e 1 
g e n e r a  t o  r 
p o r t  map(clk=>clk , reset=>reset , btn=>btn, sw=>sw, 
25 
bitmap-unit : e n t i t y  work. bitmap-gen 
video-on=>video-on, pixel-x=>pixel-x, 
pixel-y=>pixel-y , bit-rgb=>rgb-next 1 ; 
-- rgb b u f f e r  
30 
p ro c e s s  (clk) 
begin 
if  (clk ’ event and clk= ’ 1 ’ ) then 
if (pixel-tick=’ 1’) then 
rgb-reg <= rgb-next ; 
35 
end if ; 
end if ; 
end p r o c e s s ;  
rgb <= rgb-reg; 

BIBLIOGRAPHIC NOTES 
287 
end a r c h ;  
12.5.2 Single-port RAM implementation 
Although a dual-port memory is ideal, it is not always available. Using regular single-port 
memory, such as the S3 board’s external SRAM, for the video memory requires careful 
coordination between the write and read operations to avoid interruption on data retrieval. 
For demonstration purposes, we configure the embedded block RAM as a single-port syn- 
chronous SRAM and redesign the previous dot trace circuit. 
In the dot trace circuit, the dot’s coordinates are updated once every screen scan. Thus, 
the video memory can be written at this rate as well. We can do this during the vertical 
retrace since the video is off in this period and writing video memory does not interfere 
with the screen data retrieval. Note that the refr-tick signal is asserted when pixel-y 
is 48 1. The video is off in this location, and writing video memory will not interfere with 
the screen data retrieval. We use this signal as the write enable signal, we, for the single-port 
RAM. The single-port RAM module discussed in Listing 11.2 can be used for this purpose. 
The memory portion of Listing 12.7 now becomes 
__ i n s t a n t i a t e  vi d eo  sram 
v i d e o - r a m :  e n t i t y  work.xilinx-one-port-ram-sync 
g e n e r i c  map ( ADDR-W IDTH = > 14, DATA-W IDTH = >3) 
p o r t  m a p ( c l k = > c l k ,  we=>we, addr=>addr , 
d i n = > d i n  , d o u t = > d o u t )  ; 
__ vi d eo  ram i n t e r f a c e  
addr-w <=std-logic_vector(dot-y-reg & d o t - x - r e g ) ;  
a d d r - r  <= 
addr <= addr-w when r e f r - t i c k = ’ l ’  e l s e  a d d r - r ;  
we <= r e f r - t i c k ;  
d i n  <= s w ;  
b i t m a p - r g b  <= d o u t ;  
s t d - l o g i c - v e c t o r  ( p i x - y  ( 6  downto 0 )  & pix-x ( 6  downto 0 )  ; 
The dot trace circuit updates one pixel in a screen scan. The required memory bandwidth 
for writing is 60*3 bits per second, which is rather low. Thus, the previous design is fairly 
straightforward. The design of memory interface becomes much more difficult when a 
large memory bandwidth is required (i.e., when a large portion of the screen is updated at 
a rapid rate). 
12.6 BIBLIOGRAPHIC NOTES 
Rapid Prototyping of Digital Systems by James 0. Hamblen et al. contains timing informa- 
tion for monitors with different resolutions and refresh rates. 
12.7 SUGGESTED EXPERIMENTS 
12.7.1 VGA test pattern generator 
A VGA test pattern generator produces two simple patterns to verify operation of a VGA 
monitor. The first pattern divides the screen evenly into eight vertical stripes, each displaying 

288 
VGA CONTROLLER I: GRAPHIC 
a unique color. The second pattern is similar but the screen is divided into eight horizontal 
stripes. A 1-bit switch is used to select the pattern. 
Design a pixel generating circuit for this pattern generator and then combine it with the 
synchronization circuit in a top-level module. Synthesize and verify operation of the circuit. 
12.7.2 SVGA mode synchronization circuit 
The specification for the super VGA (SVGA) mode with 72-Hz refresh rate is 
resolution: 800-by-600 pixels 
pixel rate: 50 MHz 
horizontal display region: 800 pixels 
horizontal right border: 64 pixels 
horizontal left border: 56 pixels 
horizontal retrace: 120 pixels 
vertical display region: 600 lines 
vertical bottom border: 23 lines 
vertical top border: 37 lines 
a vertical retrace: 6 lines 
We wish to create a dual-mode synchronization circuit that can support both VGA and 
1. Modify the horizontal and vertical synchronization counters of Listing 12.1 to ac- 
commodate both modes. 
2. Design a pixel-generating circuit that draws a 100-pixel grid on the screen (i.e., draw 
a vertical line every 100 pixels and draw a horizontal line every 100 pixels). 
3. Derive a top-level module. Synthesize and verify operation of the two modes. 
SVGA modes. The mode can be selected by a switch. Construct the circuit as follows: 
12.7.3 Visible screen adjustment circuit 
Due to the internal timing error of a monitor, the visible portion of the screen may not 
always be centered. We can adjust the location of the visible portion by slightly modifying 
the widths surrounding black border areas. In a horizontal scan line, there are 64 pixels 
for the right and left border regions. To move the visible portion horizontally, we can add 
a certain number of pixels to one border region and subtract the same number from the 
opposite border region. We can adjust the visible portion vertically in a similar fashion. 
Design a screen adjustment circuit as follows: 
1. Expand the VGA synchronization circuit to include this feature. Use a switch to 
select the vertical or horizontal mode, and use two pushbuttons to move the visible 
screen to leftlup and nghtldown. 
2. Modify the testing circuit in Section 12.2.5 to incorporate the new synchronization 
circuit. 
3. Synthesize and verify operation of the circuit. 
12.7.4 
Ball-in-a-box circuit 
The ball-in-a-box circuit displays a bouncing ball inside a square box. The square box 
is centered on the screen and its size is 256-by-256 pixels. The ball is an 8-by-8 round 
ball. When the ball hits the wall, the ball bounces back and the wall flashes (i.e., changes 
color briefly). The ball can travel at four different speeds, which are selected by two slide 

SUGGESTED EXPERIMENTS 
289 
Figure 12.11 Screen of the breakout game. 
switches, and its direction changes randomly when a pushbutton switch is pressed. Derive 
the HDL code and then synthesize and verify operation of the circuit. 
12.7.5 Two-balls-in-a-box circuit 
We can expand the circuit in Experiment 12.7.4 to include two balls inside the box. When 
two balls collide, the new directions of the two balls should follow the laws of physics. 
Derive the HDL code and then synthesize and verify operation of the circuit. 
12.7.6 Two-player pong game 
The two-player pong game replaces the left wall with another paddle, which is controlled by 
the second player. To better accommodate two players, we can use the keyboard interface 
of Section 8.4 as the input device. Four keys can be defined to control vertical movements 
of the two paddles. Derive the HDL code and then synthesize and verify operation of the 
circuit. 
12.7.7 Breakout game 
The breakout game is a somewhat like the pong game. In this game, the left wall is replaced 
by several layers of “bricks.” When the ball hits a brick, the ball bounces back and the brick 
disappears. The basic screen is shown in Figure 12.11. As in the code of Listing 12.5, we 
assume that the game runs continuously. Derive the HDL code and then synthesize and 
verify operation of the circuit. 
12.7.8 
Full-screen dot trace 
We can implement the full-screen dot trace circuit of Section 12.5 using the external SRAM 
chip as follows: 
1. Modify the SRAM controller in Chapter 10 to configure the SRAM chip as a 2I9-by-8 
memory. 

290 
VGA CONTROLLER I: GRAPHIC 
2. Follow the discussion in Section 12.5.2 to incorporate the new memory module in 
3. Synthesize and verify operation of the circuit. 
the circuit. Note that accessing the external memory requires two clock cycles. 
12.7.9 Mouse pointer circuit 
The mouse interface is discussed in Section 9.5. The mouse pointer circuit uses a mouse 
to control the movement of a small 16-by-16 square on the screen. It functions as follows: 
0 The square moves according to the movement of the mouse. 
0 The pointer wraps around when it reaches a border. 
0 The pointer changes color when the left button of the mouse is pressed. It circulates 
through the eight colors defined in Table 12.1. 
Synthesize and verify operation of the circuit. 
12.7.1 0 Small-screen mouse scribble circuit 
Mouse scribble circuit keeps track of the trace of the mouse movement in a 128-by-128 
screen, somewhat similar to the dot trace circuit discussed in Section 12.5. Its specification 
is as follows: 
0 The 3-bit switch determines the color of the trace. 
0 Clicking the left button of the mouse turns on and off the trace alternately. 
0 Clicking the right button of the mouse clears the screen. 
Synthesize and verify operation of the circuit. 
12.7.1 1 
Repeat Experiment 12.7.10, but use the full screen. An external SRAM module similar to 
that in Experiment 12.7.8 is needed for this circuit. 
Full-screen mouse scribble circuit 

CHAPTER 13 
VGA CONTROLLER II: TEXT 
13.1 INTRODUCTION 
A tile-mapped pixel generation scheme is discussed in Section 12.3. A tile can be considered 
as a “super pixel.” Whereas a pixel is defined by a 3-bit word in a bit-mapped scheme, a tile 
is mapped to a predesigned pattern. One method of constructing a text display is to treat the 
characters as tiles and design the pixel generation circuit with the tile-mapped scheme. We 
discuss this method in this chapter and apply it to add scores and rules to the pong game. 
13.2 TEXT GENERATION 
13.2.1 Character as a tile 
When applying a tile-mapped scheme, we treat each character as a tile. In a bit-mapped 
scheme, the value of a pixel represents a 3-bit color. On the other hand, the value of a tile 
represents the code of a specific pattern. For the text display, we use the 7-bit ASCII code 
for the character tiles. 
The patterns of the tiles constitute thefint of the character set. A variety of fonts are 
available. We choose an 8-by-16 (i.e., 8-column-by-16-row) font similar to the one used in 
early IBM PC. In this font, each character is represented as an 8-by-16 pixel pattern. The 
pattern for the letter “A” is shown in Figure 13.1(a). 
The character patterns are stored in a ROM and each pattern requires 24 * 8 bits. The 
pattern memory is known as font ROM. The original font set consists of 256 patterns, 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
291 

292 
VGA CONTROLLER 11: TEXT 
character 
address row 
1000001 0000 
1000001 0001 
*?- 
. 
1000001 1110 
1000001 1111 
. 
0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 
0001 0000 
001 1 1000 
01 101 100 
1 10001 10 
11000110 
11111110 
1 10001 10 
1 10001 10 
1 10001 10 
1 10001 10 
00000000 
0 0 0 0 0 0 0 0 
00000000 
0 0 0 0 0 0 0 0 . . . 
2"-by-8 ROM 
(a) Pixel pattern 
(b) ROM content 
Figure 13.1 Font pattern for the letter A. 
including digits, upper- and lowercase letters, punctuation symbols, and many special- 
purpose graphic symbols. We implement only the first half [i.e., 128 Q7)] of the patterns 
and exclude most graphic symbols. To accommodate this set, 27 * 24 * 8 ROM bits are 
needed. It is usually configured as a 211-by-8 ROM. 
When we use these 8-by-16 characters (i.e., tiles) in a 640-by-480 resolution screen, 80 
(i.e., 7 )  
tiles can be fitted into a horizontal line and 30 (i.e., %) tiles can be fitted into a 
vertical line. In other words, the screen can be treated as an 80-by-25 tile screen. We can 
put characters on the screen using these scaled coordinates. 
13.2.2 Font ROM 
Our font set implements the 128 characters of the ASCII code, listed in Table 7.1. The 128 
(27) character patterns can be accommodated by a 211-by-8 font ROM. In this ROM, the 
seven MSBs of the 1 1-bit address are used to identify the character, and the four LSBs of 
the address are used to identify the row within a character pattern. The address and ROM 
content for the letter "A" are shown in Figure 13.1(b). 
In the ASCII table, the first column (ASCII codes 0016 to lF16) are nonprintable control 
characters. The font ROM uses these codes to implement special graphic symbols. For 
example, the 0616 code will generate a spade pattern, 6, on the screen. Note that the 0016 
code is reserved for a blank tile. 
The 211-by-8 font ROM can fit neatly into a single block RAM of the Spartan-3 device. 
We use the ROM template of Listing 11.6 to ensure that a block RAM will be inferred 
during synthesis. Part of the HDL code is shown in Listing 13.1. The complete code has 
211 rows in constant definition and the file can be downloaded from the companion Web 
site. 

TEXT GENERATION 
293 
Listing 13.1 Partial code of the font ROM 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  font-rom i s  
5 
p o r t (  
clk: in std-logic; 
addr : in std-logic-vector (10 downto 0) ; 
data: out std-logic-vector ( 7  downto 0) 
) ;  
10 end f ont-rom ; 
a r c h i t e c t u r e  arch of font-rom i s  
15 
20 
25 
30 
35 
40 
45 
50 
constant ADDR-WIDTH: integer :=ll; 
constant DATA-WIDTH: integer:=8; 
s i g n a l  addr-reg : std-logic-vector (ADDR-WIDTH -1 downto 0) ; 
type rom-type i s  array ( 0  to 2**ADDR-WIDTH-l) 
-- ROM d e f i n i t i o n  
constant R U M :  rom-type : = (  
-- 2*11 - b y 4  
-- code x00 ( b l a n k  s p a c e )  
" 0 0 0 0 0 0 0 0 " ,  -- 0 
" 0 0 0 0 0 0 0 0 " ,  -- 1 
" 0 0 0 0 0 0 0 0 " ,  -- 2 
" 0 0 0 0 0 0 0 0 " ,  -- 3 
" 0 0 0 0 0 0 0 0 " ,  -- 4 
" 0 0 0 0 0 0 0 0 " ,  -- 5 
"00000000" , -- 6 
" 0 0 0 0 0 0 0 0 " ,  -- 7 
"00000000" , -- 8 
"00000000" , -- 9 
"00000000" , -- a 
" O O O O O O O O "  , -- b 
" 0 0 0 0 0 0 0 0 " ,  -- c 
" 0 0 0 0 0 0 0 0 "  , -- d 
'1 00000000 , -- e 
" 0 0 0 0 0 0 0 0 " ,  -- f 
-- code x O l  ( s m i l e y  f a c e )  
" 0 0 0 0 0 0 0 0 " ,  -- 0 
"00000000", -- 1 
"01111110", -- 2 
****** 
" 1 0 0 0 0 0 0 1 " ,  -- 3 * 
* 
" 1 0 1 0 0 1 0 1 " ,  -- 4 * * 
* * 
" 1 0 0 0 0 0 0 1 " ,  -- 5 * 
* 
"1OOOOOO1", -- 6 * 
* 
"10111101'~, 
-- 7 * * * * *  * 
"10011001", -- 8 * 
* *  * 
~ ' 1 0 0 0 0 0 0 1 " ,  -- 9 * 
* 
I' 10000001 " , -- a *  
* 
"01111110", -- b 
****** 
I' 00000000 " , -- C 
''00000000" , -- d 
" 0 0 0 0 0 0 0 0 " ,  -- e 
of std-logic-vector (DATA-WIDTH-1 downto 0 )  ; 

294 
VGA CONTROLLER 11: TEXT 
Figure 13.2 Two-stage text generation circuit. 
" 0 0 0 0 0 0 0 0 " ,  -- f 
__ code x 0 2  
1 ;  
begin 
-- a d d r  r e g i s t e r  t o  i n f e r  b l o c k  RAM 
process (clk) 
S C  
.
.
.
 
M) 
begin 
i f  (clk'event and clk = '1') 
then 
end i f  ; 
end p r o c e s s ;  
addr-reg <= a d d r ;  
65 
data <= ROM(to-integer(unsigned(addr-reg))) 
; 
end a r c h ;  
Note that the block RAM-based ROM implementation introduces one-clock-cycle delay, 
as discussed in Section 11.4.3. 
13.2.3 Basic text generation circuit 
The pixel generation circuit generates the pixel values according to the current pixel coor- 
dinates (provided by the pixel-x and pixel-y signals) and the external data and control 
signals. Pixel generation based on a tile-mapped scheme involves two stages. The first 
stage uses the upper bits of the pixel-x and pixel-y signals to generate a tile's code, and 
the second stage uses this code and lower bits to generate the pixel's value. 
The text generation circuit follows this method, and the basic diagram is shown in 
Figure 13.2. The screen is treated as a grid of 80-by-30 tiles, each containing an 8-by- 
16 font pattern. In the first stage, the pixel-x(9 downto 3) and pixeLy(8 downto 
4) signals provides the x- and y-coordinates of the current tile location. The character 
generation circuit uses these coordinates, combined with other external data, to generate 
the value of this tile (labeled char-addr), which corresponds to a character's ASCII code. 
In the second stage, the ASCII code becomes the seven MSBs of the address of the font 
ROM and specifies the location of the current pattern. It is concatenated with the four 
LSBs of the screen's y-coordinate [i.e., pixel-y(3 downto O), labeled row-addr] to 
form the complete address (labeled rom-addr) of the font ROM. The output of the font 
ROM (labeled font-word) corresponds to an 8-bit row in the pattern. The three LSBs 

TEXT GENERATION 
295 
of the screen’s x-coordinate [i.e., p i x e l x ( 2  downto 01, labeled bit-addr] specify the 
desired pixel location, and an 8-to-1 multiplexer routes the pixel to the output. 
13.2.4 Font display circuit 
We use a simple font display circuit to verify operation of the font ROM and display all 
font patterns on the screen. The 128 patterns are arranged in four rows, which correspond 
to the four columns of the ASCII table in Table 7.1. We can obtain each pattern by using 
the proper x- and y-coordinates to generate the desired ASCII code, which is labeled the 
char-addr signal. The code segment is 
char-addr <= pixel-y(5 downto 4) & pixel-x(7 downto 3); 
The pixeLx(7 downto 3) signal forms the five LSBs of the ASCII code, and thus 32 ( 2 5 )  
consecutive font patterns will be displayed in a row. The pixeLy(5 downto 4) signal 
forms the two MSBs of the ASCII code, and thus four consecutive rows will be displayed. 
Since the upper bits of the p i x e l x  and pixel-y signals are left unspecified, the 32-by-4 
region will be displayed repetitively on the screen. An additional code segment is included 
to turn on the display for the top-left portion of the screen only. The complete code is shown 
in Listing 13.2. 
Listing 13.2 Pixel generation of a font display circuit 
lib rary ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  font-test-gen i s  
j 
p o r t (  
clk: in std-logic; 
video-on: in std-logic; 
pixel-x , pixel-y : std-logic-vector (9 downto 0) ; 
rgb-text : out std-logic-vector ( 2  downto 0) 
10 
) ; 
end font-test-gen; 
a r c h i t e c t u r e  arch of font-test-gen i s  
s i g n a l  rom-addr : std-logic-vector (10 downto 0) ; 
15 
s i g n a l  char-addr : std-logic-vector (6 downto 0) ; 
s i g n a l  row-addr: std-logic-vector (3 downto 0) ; 
s i g n a l  bit-addr : std-logic-vector ( 2  downto 0) ; 
s i g n a l  f ont-word: std-logic-vector ( 7  downto 0) ; 
s i g n a l  f ont-bit , text-bit-on : std-logic; 
-_ 
i n s t a n t i a t e  f o n t  ROM 
font-unit: e n t i t y  work.font-rom 
-- f o n t  ROM i n t e r f a c e  
row-addr <=pixel-y (3 downto 0) ; 
rom-addr <= char-addr & row-addr; 
bit-addr <=pixel-x ( 2  downto 0) ; 
font-bit <= font-word(to-integer(unsigned(n0t 
bit-addr))); 
text-bit-on <= 
20 begin 
port map(clk=>clk, addr=>rom-addr , data=>font-word) ; 
25 
char-addr <=pixel-y (5 downto 4) & pixel-x (7 downto 3) ; 
30 
-- ” o n ”  r e g i o n  l i m i t e d  t o  t o p - l e f t  
c o r n e r  

296 
VGA CONTROLLER 11: TEXT 
font-bit when pixel-x (9 downto 8 ) = " 0 0 "  and 
' 0 ' .  
pixel-y (9 downto 6) =8'0000'8 e l s e  
35 
-- rgb m u l t i p l e x i n g  
c i r c u i t  
process(video-on,font-bit,text-bit-on) 
begin 
if video-on='O' then 
rgb-text <= " 0 0 0 " ;  --blank 
40 
e l s e  
i f  text-bit-on='l' then 
e l s e  
rgb-text <= " 0 1 0 " ;  -- green 
rgb-text <= " 0 0 0 " ;  -- black 
45 
end i f  ; 
end i f  ; 
end p r o c e s s ;  
end arch; 
The key part of the code is the font ROM interface. For clarity, we define the following 
0 char-addr: 7 bits, the ASCII code of the character 
0 row-addr: 4 bits, the row number in a particular font pattern 
0 rom-addr: 11 bits, the address of the font ROM; the concatenation of char-addr 
0 bit-addr: 3 bits, the column number in a particular font pattern 
0 f ont-word: 8 bits, a row of pixels of the font pattern specified by rom-addr 
0 font-bit: 1 bit, one pixel of font-word specified by bit-addr 
signals for the font ROM, as shown in Figure 13.2: 
and row-addr 
The connection of these signals follows the diagram in Figure 13.2. The routing of the 
font-bit <= font-word(to-integer(unsigned(n0t 
bit-addr))); 
Note that a row (i.e., a word) in the font ROM is defined with a descending order [i.e., (7 
downto O)]. Since the screen's x-coordinate is defined in an ascending fashion, in which 
the numbers increases from left to right, the order of the retrieved bits must be reversed. 
This is achieved by the not operator in the expression. 
We need to combine the synchronization circuit and create the top-level description. The 
HDL code is shown in Listing 13.3. 
f ont-bit signal is done by a multiplexer, coded as an array with dynamic index: 
Listing 13.3 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  font-test-top i s  
Top-level description of a font display circuit 
5 
p o r t (  
clk, reset: in std-logic; 
h s y n c ,  vsync: out 
std-logic; 
r g b :  out std-logic-vector ( 2  downto 0) 
) ;  
10 end font-test-top; 
a r c h i t e c t u r e  arch of font-test-top i s  
s i g n a l  pixel-x , pixel-y : std-logic-vector ( 9  downto 0) ; 

TEXT GENERATION 
297 
signal video-on , pixel-tick: std-logic ; 
15 
signal rgb-reg , rgb-next : std-logic-vector ( 2  downto 0) ; 
begin 
__ i n s t a n t i a t e  VGA s y n c  c i r c u i t  
20 
vga-sync-unit : entity work. vga-sync 
port map(clk=>clk , reset=>reset , hsync=>hsync , 
vsync=>vsync, video-on=>video-on, 
pixel-x=>pixel-x, pixel-y=>pixel-y, 
p-tick=>pixel-tick); 
__ i n s t a n t i a t e  f o n t  ROM 
font-gen-unit: entity work.font-test-gen 
25 
port map( clk=>clk , video-on=>video-on , 
pixel-x=>pixel-x, pixel-y=>pixel-y, 
rgb-text=>rgb-next) ; 
-- rgb b u f f e r  
process (clk) 
30 
begin 
if (clk’event and clk=’l’) then 
if (pixel-tick=’l’) then 
rgb-reg <= rgb-next ; 
end if ; 
35 
end i f  ; 
end process; 
rgb <= rgb-reg; 
end arch; 
~~ 
There is subtle timing issue in this circuit. Because of the block RAM implementation, 
the font ROM’s output suffers a one-clock-cycle delay. However, since the pixel-tick 
signal is asserted every two clock cycles, the pixelx signal is remained unchanged within 
this interval and the corresponding bit (i.e., f ont-bit) can be retrieved properly. The rgb 
multiplexing circuit can use this data, and the desired value is stored to the rgb-reg register 
in a timely manner. 
13.2.5 Font scaling 
In the tile-mapped scheme, we can scale a tile pattern to larger sizes by “enlarging” the 
screen pixels. For example, we can scale the 8-by-16 font to the 16-by-32 font by enlarging 
the original pixel four times (i.e., expanding one pixel to four pixels). To perform the 
scaling, we just need to shift pixel coordinates to the right 1 bit and discard the LSBs of the 
pixelx and pixel-y signals. This can best be explained by an example. Let us repeat 
the previous font displaying circuit with enlarged 16-by-32 fonts. The screen can now be 
treated as a grid of 40-by-15 tiles. The new font addresses become 
row-addr <=pixel-y ( 4  downto 1) ; 
bit-addr <=pixel-x ( 3  downto 1) ; 
char-addr <=pixel-y (6 downto 5) & pixel-x (8 downto 4) ; 
The first two statements imply that the same font-bit value will be obtained when 
pixeLx(0) and pixel-y(O) are “OO”, “Ol”, “lo”, and “ l l ” ,  and this effectively enlarges 
the original pixel to four pixels. The text-bit-on condition also needs to be modified to 
accommodate a larger region: 

298 
VGA CONTROLLER I): TEXT 
Figure 13.3 Text generation circuit with tile memory. 
text-bit-on <= 
font-bit when pixel-x ( 9 ) = " 0 "  and 
' 0 ' ;  
pixel-y (9 downto 7 ) = " 0 0 0 "  e l s e  
We can apply this scheme to scale up the font even further. Note that the enlarged fonts 
may appear jagged because they simply magnify the original pattern and introduce no new 
detail. 
13.3 FULL-SCREEN TEXT DISPLAY 
A full-screen text display, as the name indicates, uses the entire screen to display text 
characters. The character generation circuit now contains a tile memory that stores the 
ASCII code of each tile. The design of the tile memory is similar to the video memory of 
the bit-mapped circuit in Section 12.5. For easy memory access, we can concatenate the x- 
and y-coordinates of a tile to form the address. This translates to 12 bits for the 80-by-30 
(i.e., ~ ? ~ - b y - 2 ~ )  
tile screen. Since each tile contains a 7-bit ASCII code, a 212-by-7 memory 
module is required. A synchronous dual-port RAM can be used for this purpose. A circuit 
with tile memory is shown in Figure 13.3. 
Because accessing tile memory requires another clock cycle, retrieving a font pattern 
is now increased to two clock cycles. This prolonged delay introduces a subtle timing 
problem. Because the pixel-x signal is updated every two clock cycles, its value has 
incremented when the f ont-word value becomes available. Thus, when the bit is retrieved 
by the statements 
bit-addr <=pixel-x (2 downto 0 )  ; 
font-bit <= font-word(to-integer(unsigned(n0t bit-addr))); 
the incremented bit-addr is used and an incorrect font bit will be selected and routed to 
the output. One way to overcome the problem is to pass the pixel-x signal through two 
buffers and use this delayed signal in place of the pixel-x signal. 
We use a simple circuit to demonstrate the design of the full-screen tile-mapped scheme. 
The circuit reads an ASCII code from a 7-bit switch and places it in the marked location 

FULL-SCREEN TEXT DISPLAY 
299 
of the 80-by-30 tile screen. The conceptual diagram is shown in Figure 13.3. A cursor is 
included to mark the current location of entry, where the color is reversed. The cursor 
block keeps track of the current location of the cursor. The circuit uses three pushbutton 
switches for control. Two buttons move the cursor right and down, respectively. The third 
button is for the write operation. When it is pressed, the current value of the 7-bit switch is 
written to the tile memory. The HDL code is shown in Listing 13.4. 
Listing 13.4 Pixel generation of a full-screen text display 
library ieee; 
use ieee. std-logic-1164, a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  text-screen-gen i s  
5 
p o r t (  
clk, reset : std-logic ; 
btn: std-logic-vector ( 2  downto 0) ; 
sw: std-logic-vector (6 downto 0) ; 
video-on : in std-logic ; 
in 
pixel-x , pixel-y : in std-logic-vector ( 9  downto 0 )  ; 
text-rgb : out std-logic-vector ( 2  downto 0) 
) ;  
end text-screen-gen ; 
15 a r c h i t e c t u r e  arch of text-screen-gen i s  
-- f o n t  ROM 
s i g n a l  char-addr : std-logic-vector (6 downto 0) ; 
s i g n a l  rom-addr: std-logic-vector (10 downto 0) ; 
s i g n a l  row-addr : std-logic-vector (3 downto 0) ; 
s i g n a l  f ont-word: std-logic-vector (7 downto 0) ; 
s i g n a l  font-bit : std-logic; 
__ t i l e  RAM 
s i g n a l  we : std-logic; 
s i g n a l  din, dout : std-logic-vector (6 downto 0) ; 
--80-by-30 
t i l e  map 
constant MAX-X: integer :=80; 
constant MAX-Y: integer :=30; 
s i g n a l  cur-x-reg , cur-x-next : unsigned (6 downto 0) ; 
s i g n a l  cur-y-reg , cur-y-next : unsigned (4 downto 0) ; 
s i g n a l  move-x-tick , move-y-tick: std-logic; 
s i g n a l  cursor-on: std-logic ; 
s i g n a l  pix-xl-reg , pix-yl-reg : unsigned ( 9  downto 0) ; 
s i g n a l  pix-x2_reg, pix-y2_reg : unsigned ( 9  downto 0 )  ; 
-- o b j e c t  o u t p u t  s i g n a l s  
s i g n a l  font-rgb , font-rev-rgb: 
20 
s i g n a l  bit-addr : unsigned ( 2  downto 0) ; 
25 
s i g n a l  addr-r , addr-w: std-logic-vector ( 1 1  downto 0) ; 
30 
-- c u r s o r  
35 
-- delayed p i x e l  count 
40 
std-logic-vector ( 2  downto 0) ; 
begin 
_- 
i n s t a n t i a t e  debounce c i r c u i t  for two b u t t o n s  
debounce-unit0: e n t i t y  work. debounce 
port map(clk=>clk, reset=>reset , sw=>btn(O), 
45 
db-level=>open, db-tick=>move-x-tick); 

300 
VGA CONTROLLER 11: TEXT 
65 
debounce-unit1 : entity work. debounce 
port map(clk=>clk, reset=>reset , sw=>btn(l), 
db-level=>open, db-tick=>move-y-tick); 
__ i n s t a n t i a t e  f o n t  ROM 
50 
font-unit : entity work. f ont-rom 
port map(clk=>clk, addr=>rom-addr , data=>font-word) ; 
-- i n s t a n t i a t e  d u a l - p o r t  
t i l e  RAM ( 2 * 1 2 - b y - 7 )  
video-ram: entity w o r k . x i l i n x - d u a l - p o r t _ r a m _ s y n c  
generic map ( ADDR-W IDTH=>12 , DATA-W IDTH=>7) 
port map(clk=>clk, we=>we, 
addr-a=>addr-w , addr-b=>addr-r, 
din-a=>din, dout-a=>open, dout-b=>dout); 
__ r e g i s t e r s  
process (clk) 
~i 
begin 
if (clk’event and clk=’l’) then 
cur-x-reg <= cur-x-next ; 
cur-y-reg <= cur-y-next ; 
pix-xi-reg <= unsigned(pixe1-x) ; -- 2 - c l o c k  
d e l a y  
pix-x2_reg <= pix-xl-reg; 
pix-yl-reg <= unsigned(pixe1-y); 
pix-y2_reg <= pix-yl-reg; 
end if ; 
end process; 
70 
-- t i l e  RAM w r i t e  
addr-w <=std-logic-vector(cur-y-reg & cur-~-reg); 
we <= btn(2); 
din <= sw; 
__ t i l e  RAM read 
addr-r <=pixel-y(8 downto 4) & pixel-x(9 downto 3); 
char-addr <= dout; 
-- f o n t  ROM 
row-addr <=pixel-y (3 downto 0 )  ; 
xo 
rom-addr <= char-addr & row-addr; 
-- u s e  d e l a y e d  c o o r d i n a t e  t o  s e l e c t  a b i t  
bit-addr <=pix-x2_reg (2 downto 0) ; 
font-bit <= font-word(to-integer(not bit-addr)); 
__ new c u r s o r  p o s i t i o n  
75 
-- u s e  u n d e l a y e d  c o o r d i n a t e s  t o  f o r m  t i l e  RAM a d d r e s s  
8s 
cur-x-next <= 
(others=>’O’) when move-x-tick=’l’ and -- wrap around 
cur-x-reg + 1 when move-x-tick=’l’ else 
cur-x-reg ; 
(others=>’O’) when move-y-tick=’l’ and -- wrap around 
cur-y-reg + 1 when move-y-tick=’l’ else 
cur-y-reg; 
cur-x-reg=MAX-X -1 else 
90 
cur-y-next <= 
cur-y-reg=MAX-Y -1 else 
95 
-- o b j e c t  s i g n a l s  
_- 
g r e e n  o v e r  b l a c k  and r e v e r s e d  v i d e o  f o r  c u r s e r  
font-rgb < = “ 0 1 0 ”  when font-bit=’l’ else “ 0 0 0 “ ;  
font -rev-rgb <= “ 000 “ when font -b it = ’ 1 ’ else I‘ 010 “ ; 

FULL-SCREEN TEXT DISPLAY 
301 
110 
115 
use d e  
cur sor-on 
_- 
-- rgb m )  
a y e d  c o o r d  
< = ’ l ’  when 
J O J ;  
1 t i p  1 e x i n g  
n a t e s  f o r  c o m p a r i s o n  
pixwy2-reg ( 8  downto 4)=cur-y-reg and 
pix-x2_reg ( 9  downto 3)=cur_x_reg e l s e  
i r c u i t  
process(video-on,cursor-on,font-rgb,font-rev-rgb) 
begin 
i f  v i d e o - o n = ’ O ’  then 
e l s e  
text-rgb <= “000“; --blank 
if cursor-on=’l’ then 
e l s e  
end i f  ; 
text-rgb <= font-rev-rgb; 
text-rgb <= font-rgb; 
end i f  ; 
end p r o c e s s ;  
end arch; 
The font ROM interface signals are similar to those in Listing 13.2 except that the 
char-addr is obtained from the read port of the tile memory. To facilitate the font ROM 
access delay, we creat two delayed signals, pixx2-reg and pix-y2_reg, from the current 
x- and y-coordinates, p i x e l x  and pixel-y. Note that the undelayed signals, pixel-x 
and pixel-y, are used to form the address to access the font ROM, but the delayed signal, 
pix-x2_reg, is used to obtain the font bit. The instantiation and interface of the dual-port 
tile RAM is similar to those of the video RAM in Listing 12.7. 
The cursor-on signal is used to identify the current cursor location. The colors of the 
font pattern are reversed in this location. Because the font bits are delayed by two clocks, 
we use the delayed coordinates, pixx2-reg and pix-y2-reg, for comparison. 
The delayed font bits also introduce one pixel delay for the final rgb signal. This implies 
the overall visible portion of the VGA monitor is shifted to right by one pixel. To correct 
the problem, we should revise the vga-sync circuit and use the delayed pixx2-reg and 
pix-y2_reg signals to generate the hsync and vsync signals. Since the shift has little 
effect on the overall video quality, we do not make this modification. 
The top-level code combines the text pixel generation circuit and the synchronization 
circuit and is shown in Listing 13.5. 
Listing 13.5 Top-level system of a full-screen text display 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  text-screen-top is 
port ( 
5 
clk ,reset : in std-logic; 
btn: in std-logic-vector (2 downto 0 ) ;  
s w :  in std-logic-vector (6 downto 0 ) ;  
hsync , vsync : out 
std-logic; 
rgb: out std-logic-vector (2 downto 0 )  
10 
) ; 
end text-screen-top; 
a r c h i t e c t u r e  arch of text-screen-top is 
s i g n a l  pixel-x , pixel-y : std-logic-vector ( 9  downto 0) ; 

302 
VGA CONTROLLER 11: TEXT 
15 
signal video-on , pixel-tick : std-logic; 
signal rgb-reg , rgb-next : std-logic-vector ( 2  downto 0 )  ; 
__ i n s t a n t i a t e  VGA s y n c  c i r c u i t  
vga-sync-unit : entity work. vga-sync 
20 
port map(clk=>clk, reset=>reset , 
begin 
h s y n c = > h s y n c ,  vsync=>vsync, 
video-on=>video-on, p-tick=>pixel-tick, 
pixel-x=>pixel-x, pixel-y=>pixel-y); 
__ i n s t a n t i a t e  f u l l  - s c r e e n  
t e x t  g e n e r a t o r  
25 
text-gen-unit : entity work. text-screen-gen 
port map(clk=>clk, reset=>reset , btn=>btn, s w = > s w ,  
video-on=>video-on, pixel-x=>pixel-x, 
pixel-y=>pixel-y , text-rgb=>rgb-next) ; 
-- rgb b u f f e r  
30 
process (clk) 
begin 
if (clk ' event and clk= ' 1 ' 
then 
if (pixel-tick='l') 
then 
rgb-reg <= rgb-next; 
35 
end if ; 
end if; 
end process; 
rgb <= rgb-reg; 
end arch; 
13.4 THE COMPLETE PONG GAME 
We create a free-running graphic circuit for the pong game in Section 12.4.3. In this section, 
we add a text interface to display scores and messages, and design a top-level control FSM 
that integrates the graphic and text subsystems and coordinates the overall circuit operation. 
The rules and operations of the complete game are: 
0 When the game starts, it displays the text of the rule. 
0 After a player presses a button, the game starts. 
0 The player scores a point each time hitting the ball with the paddle. 
0 When the player misses the ball, the game pauses and a new ball is provided. Three 
0 The score and the number of remaining balls are displayed on the top of the screen. 
0 After three misses, the game is ended and displays the end-of-game message. 
In the following subsections, we first discuss the text subsystem, graphic subsystem, and 
auxiliary counters, and then derive a top-level FSM to coordinate and control the overall 
operation. The conceptual diagram is shown in Figure 13.4. 
balls are provided in each session. 
13.4.1 Text subsystem 
The text subsystem of the pong game consists of four text messages: 
0 Display the score as "Scores : DD" and the number of remaining balls as"Bal1: D" 
in 16-by-32 font on top of the screen. 

THE COMPLETE PONG GAME 
303 
hsync 
vsync 
video-on 
pixel-x - 
pixel-y - 
I C -  
rgb - 
> vgasync 
IC 
pixel-x 
hit + - 
pixel-y 
miss -b 
mux 
- 
7 
- 
btn 
graph-still 
-b hit 
state-reg 
I 
btn 
- 
btn 
graph-still 
, 
graph-rgb - 
graph-on 
PongLTaPh 
hsync 
vsync 
rg !J 
-b 
- 
Figure 13.4 Top-level block diagram of the complete pong game. 
miss 
d-inc - 
d-clr - 
m100- - 
dig0 
dig1 
>counter - 
FSM 
ball 
control 
text-rgb 
texton 
pongtext 
ball 
timer-start 1 
timer-up 
7 
> timer 
0 Display the rule message "Rules: Use two buttons t o  move paddle up o r  
0 Display the "PONG" logo in 64-by-128 font on the background. 
0 Display the end-of-game message "Game Over" in 32-by-64 font at the end of the 
A sketch of the first three messages is shown in Figure 13.5. The end-of-game message is 
overlapped with the rule message and not included. 
Since these messages use different font sizes and are displayed at different occasions, 
they cannot be treated as a single screen. We treat each text message as an individual object 
and generate the on status signal and the font ROM address. For example, the logo message 
segment is 
down. " in regular font at the beginning of the game. 
game. 
logo-on <= 
'1' when pix-y(9 downto 7 ) = 2  and 
(3<= pix-x(9 downto 6) and pix-x(9 downto 6 ) < = 6 )  e l s e  
J O J .  
row-addr-1 <= std-logic-vector (pix-y ( 6  downto 3)) ; 
bit-addr-1 <= std-logic-vector (pix-x ( 5  downto 3)) ; 
with pix-x(8 downto 6 )  s e l e c t  
char-addr-1 <= 
"1010000" when " O i l " ,  -- P x 5 0  
r l l O O i l l l "  when "100", -- 0 x4f 
"1001110" when "101", -- N x 4 e  

304 
VGA CONTROLLER 11: TEXT 
Figure 13.5 Text of the pong game. 
“1000111“ when o t h e r s ;  -4 x47 
The logo-on signal indicates that the current scan is in the logo region and the corresponding 
text should be “turned on.” The other statements specify the message content and the font 
ROM connections to generate the scaled 32-by-64 characters. The other three segments are 
similar. A separate multiplexing circuit examines various on signals and routes one set of 
addresses to the font ROM. 
The text subsystem receives the score and the number of remaining balls via the ball, 
dig0, and digl ports. It outputs the rgb information via the rgb-text port and outputs 
the on status information via the 4-bit text-on port, which is the concatenation of four 
individual on signals. The complete code is shown in Listing 13.6. 
Listing 13.6 Text subsystem for the pong game 
library i e e e ;  
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  pong-text i s  
5 
p o r t (  
c l k ,  r e s e t :  in std-logic; 
pixel-x , pixel-y : in std-logic-vector ( 9  downto 0) ; 
dig0 , digl : in std-logic-vector (3 downto 0 )  ; 
b a l l :  in std-logic-vector (1 downto 0) ; 
t e x t - o n :  out std-logic-vector (3 downto 0) ; 
t e x t - r g b :  out std-logic-vector (2 downto 0 )  
1 ;  
end pong-text ; 
10 
15 a r c h i t e c t u r e  arch of pong-text i s  
s i g n a l  pix-x , pix-y : unsigned (9 downto 0) ; 
s i g n a l  rom-addr: std-logic-vector (10 downto 0 )  ; 
s i g n a l  char-addr , char-addr-s , char-addr-1 , char-addr-r , 
char-addr-o : std-logic-vector (6 downto 0) ; 
row-addr-o : std-logic-vector (3 downto 0) ; 
bit-addr-o : std-logic-vector (2 downto 0) ; 
20 
s i g n a l  row-addr , row-addr-s , row-addr-1 ,row-addr-r, 
s i g n a l  bit-addr , bit-addr-s , bit-addr-1, bit-addr-r , 

THE COMPLETE PONG GAME 
305 
35 
55 
70 
75 
signal f ont-word: std-logic-vector ( 7  downto 0) ; 
signal score-on, logo-on, rule-on, over-on: std-logic; 
signal rule-rom-addr : unsigned(5 downto 0) ; 
type rule-rom-type i s  array ( 0  to 63) of 
25 
signal f ont-bit : std-logic ; 
std-logic-vector (6 downto 0) ; 
30 
-- r u l e  t e x t  ROM d e f i n i t i o n  
constant RULE-ROM: rule-rom-type := 
( -- row 1 
'I 1 0 1 0 0 1 0 " ,  -- R 
" 1 0 1 0 1 0 1 " ,  -- u 
" 1 0 0 1 1 0 0 " ,  -- L 
1 ' 1 0 0 0 1 0 1 " ,  -- E 
" 0 1 1 1 0 1 0 " ,  -- : 
" 0000000 'I , -- 
I' 0000000 " , -- 
" o o o o o o o l ~ ,  -- 
(I 0000000 " , -- 
" 0000000 (I , -- 
"0000000", -- 
" 0000000 It , -- 
(I 0000000 " , -- 
I) 0000000 " , -- 
" 0 0 0 0 0 0 0 " ,  -- 
" 0 0 0 0 0 0 0 ~ ' ,  -- 
" 1 0 1 0 1 0 1 " ,  -- u 
"1110011'1, -- S 
"11001011', -- e 
" 0000000 " , -- 
" 1 1 1 0 1 0 0 " ,  -- t 
" l l l o l l l l ' ,  -- W 
" 1 1 0 1 1 1 1 " ,  -- 0 
" 0 0 0 0 0 0 0 " ,  -- 
"11OOO1O", -- b 
" 1 1 1 0 1 0 1 " ,  -- U 
"1110100", -- t 
"1110100", -- t 
"1101111", -- 0 
" 1 1 0 1 1 1 0 " ,  -- n 
" 1 1 1 0 0 1 1 " ,  -- S 
I1 0000000 'I , -- 
-- row 3 
" 1 1 1 0 1 0 0 " ,  -- t 
" 1 1 0 1 1 1 1 " ,  -- 0 
" 0000000 " , -- 
"1101101", -- m 
" 1 1 0 1 1 1 1 " ,  -- 0 
"1110110", -- v 
" 1 1 0 0 1 0 1 " ,  -- e 
" 0000000 " , -- 
"1110000", -- p 
50 
-- row 2 

306 
VGA CONTROLLER II: TEXT 
80 
" 1 1 0 0 0 0 1 " ,  -- a 
" 1 1 0 0 1 0 0 " ,  -- d 
"11001OO", -- d 
" 1 1 0 1 1 0 0 " ,  -- 1 
1' 0000000 I' , -- 
" 0000000 'I , -- 
" 1 1 1 0 1 0 1 " ,  -- u 
" 1 1 1 0 0 0 0 " ,  -- p 
"oooooool', -- 
"llooooll', -- a 
" 1 1 0 1 1 1 0 " ,  -- n 
"11001001', -- d 
" 0 0 0 0 0 0 0 " ,  -- 
" 1 1 0 0 1 0 0 " ,  -- d 
"1101111", -- 0 
"lllollll', -- W 
"1101110", -- n 
" 0 1 0 1 1 1 0 " ,  -- . 
" 0000000 I' , -- 
" 0 0 0 0 0 0 0 " ,  -- 
" 0000000 
I t  , -- 
I00 
I 1  0000000 
I' 
-- 
" 1 1 0 0 1 0 1 " ,  -- e 
row 4 
-- 
1 ;  
begin 
pix-x <= unsigned(pixe1-x); 
pix-y <= unsigned(pixe1-y); 
font-unit: e n t i t y  work.font-rom 
10s 
-- i n s t a n t i a t e  f o n t  ROM 
port map(clk=>clk, a d d r = > r o m - a d d r ,  data=>font-word); 
I10 
-- s c o r e  r e g i o n  
-- - d i s p l a y  s c o r e  and b a l l  a t  t o p  l e f t  
-- - t e x t  : " S c o r e  :DD B a l l  :D" 
-- - s c a l e  t o  1 6 - b y - 3 2  
f o n t  
11s 
score-on <= 
'1' when pix-y(9 downto 5 ) = 0  and 
' 0 ' ;  
pix-x(9 downto 4 ) < 1 6  e l s e  
row-addr-s <= std-logic-vector (pix-y ( 4  downto 1)) ; 
120 
bit-addr-s <= std-logic-vector (pix-x (3 downto 1)) ; 
with pix-x(7 downto 4) s e l e c t  
char-addr-s <= 
"1010011" when "OOOO't, -- S x 5 3  
ltllOOO1l" 
when " O O O l " ,  -- c x 6 3  
12s 
"1101111" when "OOlO", -- o x 6 f  
'111100101' 
when "OOll", -- r x72 
"1100101" when ttOIOO", -- e x 6 5  
"011101011 when ltOIOl" 
, -- : x3a 
tlOll" 
& dig1 when "OllOI', -- d i g i t  10 

THE COMPLETE PONG GAME 
307 
I30 
I35 
155 
IM) 
I65 
I70 
115 
I80 
1 1 0 1 1 "  & dig0 when "Olll", -- d i g i t  1 
~ ~ O O O O O O O ~ f  
when f l l O O O " ,  
0000000 If when 
1001 I) , 
~ l l O O O O I O ~ f  
when f l l O I O " ,  -- B x42 
' 1 1 1 0 0 0 0 1 "  when " l O 1 l l t ,  -- a x61 
111101100" when " 1 1 0 0 " ,  -- 1 x6c 
" 1 1 0 1 1 0 0 "  when "110lfr, 
-- 1 x6c 
"0111010" when " l l l O t l ,  -- : 
" 0 1 1 0 0 ~ '  & ball when o t h e r s ;  
~ 
-_ 
logo r e g i o n :  
__ 
- d i s p l a y  l o g o  "PONG" a t  t o p  c e n t e r  
__ 
- used as background 
__ 
- s c a l e  t o  6 4 - b y - 1 2 8  
f o n t  
logo-on <= 
'1' when pix-y(9 downto 7 ) = 2  and 
' 0 ' .  
(3<= pix-x(9 downto 6) and pix-x(9 downto 6)<=6) e l s e  
row-addr-1 <= std-logic-vector (pix-y ( 6  downto 3)) ; 
bit-addr-1 <= std-logic-vector (pix-x (5 downto 3)) ; 
with pix-x(8 downto 6) s e l e c t  
char-addr-1 <= 
" 1 0 1 0 0 0 0 "  when 1'01111, -- P x50 
"1001111" when " 1 0 0 " ,  -- 0 x 4 f  
~ ' 1 0 0 1 1 1 0 "  when " 1 0 1 " ,  -- N x4e 
" 1 0 0 0 1 1 1 "  when o t h e r s ;  -4 x47 
- 
__ r u l e  r e g i o n  
__ 
- d i s p l a y  r u l e  a t  c e n t e r  
__ 
- 4 l i n e s  , 1 6  c h a r a c t e r s  each l i n e  
__ 
R u l e :  
__ 
Use two b u t t o n s  
__ 
t o  move p a d d l e  
__ 
up and down 
- r u l e  t e x t :  
__ 
rule-on <= '1' when pix-x(9 downto 7 )  = " 0 1 0 "  and 
pix-y(9 downto 6 ) =  
"0010" e l s e  
' 0 ' ;  
row-addr-r <= std-logic-vector (pix-y (3 downto 0 ) )  ; 
bit-addr-r <= std-logic-vector (pix-x ( 2  downto 0 ) )  ; 
rule-rom-addr <= pix-y(5 downto 4) & pix-x(6 downto 3); 
char-addr-r <= RULE-ROM(to-integer(rule-rom-addr)); 
-_ game o v e r  r e g i o n  
__ - d i s p l a y  "Game O v e r "  a t  c e n t e r  
__ - s c a l e  t o  3 2 - b y - 6 4  
f o n t s  
over-on <= 
- 
'1' when pix-y(9 downto 6)=3 and 
5 < =  pix-x(9 downto 5) and pix-x(9 downto 5)<=13 e l s e  

308 
VGA CONTROLLER 11: TEXT 
190 
' 0 ' ;  
row-addr-o <= std-logic-vector (pix-y ( 5  downto 2 ) )  ; 
185 
bit-addr-o <= std-logic-vector (pix-x ( 4  downto 2 ) )  ; 
with pix-x(8 downto 5) s e l e c t  
char-addr-o <= 
"1000111" when "OlOl", -- G x 4 7  
" 1 1 0 0 0 0 1 "  when " O l l O " ,  -- a x61 
"1101101" when " O l l l " ,  -- m x6d 
"1100101'1 when " l O O O " ,  -- e x65 
" 0 0 0 0 0 0 0 "  when " 1 0 0 1 " ,  -- 
" 1 0 0 1 1 1 1 "  when " 1 0 1 0 " ,  -- 0 x 4 f  
t ~ l l l O 1 l O 1 t  when "IOll", -- v x76 
195 
"1100101" when " 1 1 0 0 " ,  -- e x65 
" 1 1 1 0 0 1 0 "  when o t h e r s ;  -- r x72 
- 
-- mux f o r  f o n t  ROM a d d r e s s e s  and r g b  
process (score-on, logo-on ,rule-on ,pix-x ,pix-y ,font-bit , 
- 
200 
char-addr-s,char-addr-l,char-addr-r,char-addr-o, 
r o w ~ a d d r ~ s , r o w ~ a d d r ~ l , r o w ~ a d d r ~ r , r o w ~ a d d r ~ o ,  
b i t - a d d r - s , b i t - a d d r - l , b i t - a d d r - r , b i t _ a d d r - o )  
begin 
205 
text-rgb <= " 1 1 0 " ;  -- y e l l o w  background 
char-addr <= char-addr-s; 
i f  score-on='I 
then 
210 
215 
220 
row-addr <= row-addr-s 
bit-addr <= bit-addr-s 
i f  font-bit='l' then 
end i f  ; 
char-addr <= char-addr 
row-addr <= row-addr-r 
bit-addr <= bit-addr-r 
i f  f ont-bit = ' 1 ' then 
end i f  ; 
char-addr <= char-addr 
text-rgb <= "001"; 
e l s i f  rule-on=Jl' then 
text-rgb <= "001"; 
e l s i f  logo_on='l' then 
225 
230 
row-addr <= row-addr-1; 
bit-addr <= bit-addr-1; 
i f  font-bit='l ' then 
text-rgb <= " 0 1 1 " ;  
end i f ;  
char-addr <= char-addr-o ; 
row-addr <= row-addr-o ; 
bit-addr <= bit-addr-o; 
i f  font-bit='l 
then 
end i f  ; 
e l s e  -- game o v e r  
text-rgb <= "001"; 
end i f  ; 
235 
end p r o c e s s ;  

THE COMPLETE PONG GAME 
309 
text-on <= score-on & logo-on & rule-on & over-on; 
-- f o n t  ROM i n t e r f a c e  
240 
rom-addr <= char-addr & row-addr; 
font-bit <= font-word(to-integer(unsigned(n0t 
bit-addr))); 
end arch; 
The structure of each segment is similar. Because the messages are short, they are 
coded with the regular ROM template. Since no clock signal is used, a distributed RAM 
or combinational logic should be inferred. Generation of the two-digit score depends on 
the two 4-bit external signals, digO and digl. Note that the ASCII codes for the digits 
0, 1, . . ., 9, are 3016, 3116, . . ., 3916. We can generate the char-addr signal simply by 
concatenating “Oil” in front of digO and digl. 
13.4.2 Modified graphic subsystem 
To accommodate the new top-level controller, the graphic circuit in Section 12.4.3 requires 
several modifications: 
0 Add a gra-still (for “still graphics”) control signal. When it is asserted, the vertical 
bar is placed in the middle and the ball is placed at the center of the screen without 
movement. 
0 Add the h i t  and miss status signals. The h i t  signal is asserted for one clock cycle 
when the paddle hits the ball. The miss signal is asserted when the paddle misses 
the ball and the ball reaches the right border. 
The modified portion of the code is shown in Listing 13.7. 
Add a graph-on signal to indicate the on status of.the graph subsystem. 
Listing 13.7 Modified portion of a graph subsystem for the pong game 
-- new b a l l  p o s i t i o n  
ball-x-next <= 
to_unsigned((MAX-X)/2,10) when gra-still=’l’ e l s e  
ball-x-reg ; 
to_unsigned((MAX-Y)/2,10) when gra-still=’l’ e l s e  
ball-y-reg + ball-vy-reg when refr-tick=’l’ e l s e  
5 
ball-x-reg + ball-vx-reg when refr-tick=’l’ e l s e  
ball-y-next <= 
in 
ball-y-reg ; 
-- new b a l l  v e l o c i t y  
p r o c e s s ( b a l l ~ v x ~ r e g , b a l l ~ v y ~ r e g , b a l l ~ y ~ t , b a l l ~ x ~ l , b a l l ~ x ~ r ,
ball-y-t,ball-y-b,bar-y-t,bar-y-b,gra-still) 
begin 
15 
hit < = ’ O ’ ;  
miss < = ’ O ’ ;  
ball-vx-next <= ball-vx-reg; 
ball-vy-next <= ball-vy-reg; 
i f  gra-still=’l> then 
-- i n i t i a 1 
v e 1 o c i t y 
ball-vx-next <= BALL-V-N; 
ball-vy-next <= BALL-V-P; 
e l s i f  ball-y-t < 1 then 
__ reach top 
20 

310 
VGA CONTROLLER it: TEXT 
75 
30 
ball-vy-next <= BALL-V-P; 
ball-vy-next <= BALL-V-N; 
ball-vx-next <= BALL-V-P; 
-- b o u n c e  back 
e l s i f  ball-y-b > (MAX-Y-1) then 
-- r e a c h  b o t t o m  
e l s i f  ball-x-1 <= WALL-X-R 
then -- r e a c h  w a l l  
e l s i f  (BAR-X-L <=ball-x-r) and (ball-x-r <=BAR-X-R) and 
(bar-y-t<=ball-y-b) and (ball-y-t<=bar-y-b) then 
-- r e a c h  x of r i g h t  b a r ,  a h i t  
ball-vx-next <= BALL-V-N; -- b o u n c e  back 
hit <= >1’; 
e l s i f  (ball-x-r >MAX-X) then 
__ r e a c h  r i g h t  b o r d e r  
a miss 
miss <= ’1’; 
-- 
35 
end if ; 
end p r o c e s s ;  
graph-on <= wall-on or bar-on or rd-ball-on; 
13.4.3 Auxiliary counters 
The top-level design requires two small utility modules, m100-counter and timer, to 
facilitate the counting. The ml00-counter module is a two-digit decade counter that 
counts from 00 to 99 and is used to keep track of the scores of the game. Two control 
signals, d-inc and d-clr, increment and clear the counter, respectively. The code is shown 
in Listing 13.8. 
Listing 13.8 Two-digit decade counter 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  m100-counter i s  
s 
p o r t (  
clk, reset: in std-logic; 
d-inc , d-clr : in std-logic; 
dig0 , dig1 : out std-logic-vector (3 downto 0) 
) ;  
10 end m100-counter; 
20 
25 
a r c h i t e c t u r e  arch of m100-counter i s  
s i g n a l  dig0-reg , digl-reg : unsigned (3 downto 0 )  ; 
s i g n a l  dig0-next , digl-next : unsigned (3 downto 0) ; 
__ r e g i s t e r s  
process (clk , reset) 
begin 
15 begin 
if reset=’l’ then 
digl-reg <= ( o t h e r s = > ’ O ’ ) ;  
dig0-reg <= ( o t h e r s = > ’ O ’ ) ;  
digl-reg <= digl-next ; 
dig0-reg <= dig0-next ; 
e l s i f  (clk’event and clk=’l’) then 
end i f ;  

THE COMPLETE PONG GAME 
31 1 
30 
35 
40 
45 
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  for the decimal c o u n t e r  
process (d-clr , d-inc , digl-reg , dig0-reg) 
begin 
dig0-next <= dig0-reg; 
digl-next <= digl-reg ; 
if (d-clr=’l’) then 
dig0-next <= ( o t h e r s = > ’ O ’ ) ;  
digl-next <= ( o t h e r s = > ’ O ’ ) ;  
if digO_reg=9 then 
e l s  if (d-inc= ’ 1 ’ ) then 
dig0-next <= ( o t h e r s = >  ’0 ’ 1  ; 
if digl-reg=g then -- 1 0 t h  d i g i t  
digl-next <= ( o t h e r s = > ’ O ’ ) ;  
e l s e  
digl-next <= digl-reg + 1; 
end if ; 
dig0-next <= dig0-reg + 1 ;  
e l s e  -- dig0 not 9 
end if ; 
end if ; 
end p r o c e s s ;  
dig0 <= std-logic-vector(digO-reg); 
dig1 <= std_logic-vector(digl-reg); 
50 end arch; 
The timer module uses the 60-Hz tick, t imer-tick, to generate a 2-second interval. 
Its purpose is to pause the video for a small interval between transitions of the screens. It 
starts counting when the timer-start signal is asserted and activates the timer-up signal 
when the 2-second interval is up. The code is shown in Listing 13.9. 
Listing 13.9 Two-second timer 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  timer i s  
5 
p o r t (  
clk, reset: in std-logic; 
timer-start, timer-tick: in std-logic; 
timer-up: out std-logic 
1 ;  
10 end timer : 
a r c h i t e c t u r e  arch of timer i s  
begin 
s i g n a l  timer-reg , timer-next : unsigned(6 downto 0) ; 
15 
-- r e g i s t e r s  
process (clk , reset) 
begin 
if reset=’l’ then 
e l s i f  (clk’event and clk=’l ’1 then 
timer-reg <= ( o t h e r s = > ’ l ’ ) ;  
timer-reg <= timer-next; 
20 

31 2 
VGA CONTROLLER II: TEXT 
end i f  ; 
end p r o c e s s ;  
-- n e x t - s t a t e  
l o g i c  
process (timer-start , timer-reg , timer-tick) 
begin 
25 
i f  (timer-start = ’ 1 ’ 
then 
e l s i f  timer-tick=’i’ and timer-reg/=O then 
e l s e  
end i f  ; 
end p r o c e s s ;  
timer-up < = ’ l ’  when timer-reg=O e l s e  ’ 0 ’ ;  
timer-next <= ( o t h e r s = > ’ l ’ ) ;  
30 
timer-next <= timer-reg - 1 ;  
timer-next <= timer-reg; 
35 
-- o u t p u t  l o g i c  
end arch; 
13.4.4 Top-level system 
The top-level system of the pong game consists of the previously designed modules, includ- 
ing video synchronization circuit, graphic subsystem, text subsystem, and utility counters, 
as well as a control FSM and an rgb multiplexing circuit. The block diagram is shown in 
Figure 13.4. 
The control FSM monitors overall system operation and coordinates the activities of the 
text and graphic subsystems. Its ASMD chart is shown in Figure 13.6. The FSM has four 
states and operates as follows: 
0 Initially, the FSM is in the newgame state. The game starts when a button is pressed 
and the FSM moves to the play state. 
0 In the play state, the FSM checks the h i t  and m i s s  signals continuously. When the 
h i t  signal is activated, the d-inc signal is asserted for one clock cycle to increment 
the score counter. When the m i s s  signal is asserted, the FSM activates the 2-second 
timer, decrements the number of the balls by 1, and examines the number of remaining 
balls. If it is zero, the game is ended and the FSM moves to the over state. Otherwise, 
the FSM moves to the newball state. 
0 The FSM waits in the newball state until the 2-second interval is up (i.e., when the 
timer-up signal is asserted) and a button is pressed. It then moves to the play state 
to continue the game. 
0 The FSM stays in the over state until the 2-second interval is up. It then moves to 
the newgame state for a new game. 
The rgb multiplexing circuit routes the t e x t  -rgb or graph-rgb signals to output ac- 
cording to the text-on and graphic-on signals. The key segment is 
i f  (text-on (3)= ’1 ’ )  or 
(state-reg=newgame and text-on(l)=’l’) or 
(state-reg=over and text_on(O)=’l’) then 
rgb-next <= text-rgb ; 
rgb-next <= graph-rgb ; 
rgb-next <= text-rgb; 
e l s i f  g r a p h - o n = ’ l ’  then -- d i s p l a y  g r a p h  
e l s i f  text_on(2)=’1’ then -- d i s p l a y  l o g o  

THE COMPLETE PONG GAME 
313 
default : gra-still <= 1 I 
....................................... 
d-clr <= 1 
ball +- ball - 1 0 
gra-still <= 0 
L ............................... 
............................... 
Figure 13.6 ASMD chart of the pong controller. 

314 
VGA CONTROLLER II: TEXT 
e l s e  
end i f ;  
rgb-next <= ”110”; -- y e l l o w  background 
The t e x t  -on (3) = ’ I ’ expression is the condition for the scores, which is always displayed. 
The text-on ( 1) = ’ 1 expression is the condition for the rule, which is displayed only 
when the FSM is in the newgame state. Similarly, the end-of-game message, whose status 
is indicated by the text-on(0) signal, is displayed only when the FSM is in the over 
state. The logo, whose status is indicated by the text-on(2) signal, is used as part of the 
background and is displayed only when no other on signal is asserted. 
The complete code is shown in Listing 13.10. 
Listing 13.10 Top-level system for the pong game 
lib rary  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  pong-top i s  
5 
p o r t (  
clk, reset: in std-logic; 
btn: in std-logic-vector (1 downto 0 ) ;  
hsync , vsync : out std-logic; 
rgb : out 
std-logic-vector ( 2  downto 0 )  
10 
) ; 
end pong-top; 
30 
40 
a r c h i t e c t u r e  arch of pong-top i s  
type state-type i s  (newgame, play, newball, over) ; 
s i g n a l  pixel-x , pixel-y : std-logic-vector ( 9  downto 0 )  ; 
s i g n a l  graph-on , gra-still , hit, miss : std-logic ; 
s i g n a l  text-on: std-logic-vector (3 downto 0 )  ; 
s i g n a l  graph-rgb , text-rgb: std-logic-vector (2 downto 0 )  ; 
s i g n a l  state-reg , state-next : state-type; 
s i g n a l  dig0 , dig1 : std-logic-vector (3 downto 0 )  ; 
s i g n a l  d-inc , d-clr : std-logic; 
s i g n a l  timer-tick, timer-start , timer-up: std-logic; 
s i g n a l  ball : std-logic-vector ( I  downto 0 )  ; 
-- i n s t a n t i a t e  v i d e o  s y n c h r o n i z a t i o n  u n i t  
vga-sync-unit : e n t i t y  work. vga-sync 
port map(clk=>clk, reset=>reset , 
15 
s i g n a l  video-on , pixel-tick: std-logic; 
20 
s i g n a l  rgb-reg , rgb-next : std-logic-vector (2 downto 0 )  ; 
25 
s i g n a l  ball-reg , ball-next : unsigned ( 1  downto 0) ; 
begin 
hsync=>hsync, vsync=>vsync, 
pixel-x=>pixel-x, pixel-y=>pixel-y, 
video-on=>video-on, p-tick=>pixel-tick); 
__ i n s t a n t i a t e  t e x t  module 
text-unit : e n t i t y  work. pong-text 
35 
ball <= std-logic-vector (ball-reg) ; 
- - t y p e  
c o n v e r s i o n  
port map(clk=>clk, reset=>reset , 
pixel-x=>pixel-x, pixel-y=>pixel-y , 
digO=>digO, digl=>digl , ball=>ball, 
text-on=>text-on, text-rgb=>text-rgb); 

THE COMPLETE PONG GAME 
31 5 
45 
50 
55 
__ i n s t a n t i a t e  g r a p h  module 
g r a p h - u n i t  : e n t i t y  work. pong-graph 
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , b t n = > b t n ,  
p i x e l - x = > p i x e l - x ,  p i x e l _ y = > p i x e l - y ,  
g r a - s t i l l = > g r a - s t i l l ,  h i t = > h i t  , m i s s = > m i s s ,  
graph-on=>graph-on,rgb=>graph-rgb); 
__ i n s t a n t i a t e  2 - s e c  
t i m e r  
t i m e r - t i c k  <= 
--6O-Hz 
t i c k  
'1 ' when p i x e l ~ x = " 0 0 0 0 0 0 0 0 0 0 ~ ~  
and 
' 0 ' ;  
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , 
t i m e r - t i c k = > t i m e r - t i c k ,  
timer-start=>timer-start, 
t i m e r - u p = > t i m e r - u p ) ;  
__ i n s t a n t i a t e  2- d i g i t  d e c a d e  c o u n t e r  
c o u n t e r - u n i t  : e n t i t y  work. m100-counter 
p o r t  m a p ( c l k = > c l k ,  r e s e t = > r e s e t  , 
p i x e 1 - y = '' 0 0 0 0 0 0 0 0 0 0 I' e I s e 
t i m e r - u n i t :  e n t i t y  work. t i m e r  
d - i n c = > d - i n c ,  d - c l r = > d - c l r ,  
digO=>digO, d i g l = > d i g l ) ;  
__ r e g i s t e r s  
p r o c e s s  ( c l k  , r e s e t )  
begin 
65 
i f  r e s e t = ' l '  t h e n  
s t a t e - r e g  <= newgame; 
b a l l - r e g  <= ( o t h e r s = > ' O ' ) ;  
r g b - r e g  <= ( o t h e r s = > ' O  '1; 
e l s i f  ( c l k ' e v e n t  and c l k = ' l ' )  t h e n  
70 
s t a t e - r e g  <= s t a t e - n e x t ;  
b a l l - r e g  <= b a l l - n e x t ;  
i f  ( p i x e l - t i c k =  ' 1') then 
r g b - r e g  <= r g b - n e x t  ; 
end i f  ; 
75 
end i f  ; 
end p r o c e s s ;  
-- f s m d  n e x t - s t a t e  
l o g i c  
p r o c e s s  ( b t n  , h i t  , m i s s ,  timer-up , s t a t e - r e g  , 
b a l l - r e g , b a l l - n e x t )  
80 
begin 
g r a - s t i l l  <= '1'; 
t i m e r - s t a r t  
< = ' O  ' ; 
85 
w 
d-inc <= ' 0 ' ;  
d - c l r  <= ' 0 ' ;  
s t a t e - n e x t  <I 
s t a t e - r e g ;  
b a l l - n e x t  <= b a l l - r e g  ; 
c a s e  s t a t e - r e g  i s  
when newgame => 
b a l l - n e x t  <= "11"; 
__ t h r e e  b a l l s  
d - c l r  <= >l'; 
__ c l e a r  s c o r e  
i f  ( b t n  /= I ' O O l ' )  
t h e n  -- b u t t o n  p r e s s e d  
s t a t e - n e x t  <= p l a y ;  
b a l l - n e x t  <= b a l l - r e g  - 1; 

316 
VGA CONTROLLER 11: TEXT 
IW 
105 
I10 
I15 
I30 
end i f  ; 
g r a - s t i l l  <= ’ 0  ’ ;  
-- a n i m a t e d  s c r e e n  
i f  h i t = ’ l ’  then 
d - i n c  <= ’1’; 
-_ 
i n c r e m e n t  s c o r e  
e l s i f  m i s s = ’ l ’  then 
i f  ( b a l l - r e g = O )  then 
e l s e  
end i f ;  
t i m e r - s t a r t  <= ’1’; - - 2 - s e c  
t i m e r  
b a l l - n e x t  <= b a l l - r e g  - 1; 
95 
when p l a y  => 
s t a t e - n e x t  <= o v e r ;  
s t a t e - n e x t  <= n e w b a l l ;  
end i f  ; 
-- w a i t  f o r  2 s e c  and u n t i l  b u t t o n  p r e s s e d  
i f  
t i m e r - u p = ’ l ’  and ( b t n  /= “ 0 0 “ )  then 
end i f ;  
when over => 
__ w a i t  f o r  2 s e c  t o  d i s p l a y  game o v e r  
i f  t i m e r - u p =  ’1 ’ then 
end i f  ; 
when n e w b a l l  = >  
s t a t e - n e x t  <= p l a y ;  
s t a t e - n e x t  <= newgame; 
end c a s e ;  
end p r o c e s s ;  
process ( s t a t e - r e g  , v i d e o - o n ,  g r a p h - o n ,  graph-rgb , 
begin 
120 
-- rgb m u l t i p l e x i n g  c i r c u i t  
t e x t - o n ,  t e x t - r g b )  
i f  video-on=’O’ then 
e l s e  
125 
r g b - n e x t  <= ” 0 0 0 ” ;  -- b l a n k  t h e  e d g e / r e t r a c e  
__ d i s p l a y  s c o r e ,  r u l e  o r  game o v e r  
if ( t e x t _ o n ( 3 ) = ’ 1 ’ )  or 
( s t a t e - r e g = n e w g a m e  and t e x t - o n ( l ) = ’ l  ’1 or -- r u l e  
( s t a t e - r e g = o v e r  and t e x t - o n ( O ) =  ’1 ’1 then 
rgb-next 
<= t e x t - r g b  ; 
r g b - n e x t  <= g r a p h - r g b  ; 
r g b - n e x t  <= t e x t - r g b ;  
r g b - n e x t  <= ” 1 1 0 ” ;  -- y e l l o w  b a c k g r o u n d  
e l s i f  g r a p h - o n = ’ l ’  
then -- d i s p l a y  g r a p h  
e l s i f  t e x t - o n ( 2 ) = ’ l J  
then -- d i s p l a y  l o g o  
e l s e  
end i f ;  
end i f  ; 
140 
end p r o c e s s ;  
r g b  <= r g b - r e g ;  
end a r c h ;  

BIBLIOGRAPHIC NOTES 
317 
13.5 BIBLIOGRAPHIC NOTES 
Several other character fonts are available. Rapid Prototyping of Digital Systems by James 
0. Hamblen et al. uses a compact 64-character 8-by-8 font set. The tile-mapped scheme 
is not limited to the text display. It is widely used in the early video game. The article 
“Computer Graphics During the 8-bit Computer Game Era” by Steven Collins (ACM SZG- 
GRAPH, May 1998) provides a comprehensive review of the history and design techniques 
of the tile-based game. 
13.6 SUGGESTED EXPERIMENTS 
13.6.1 Rotating banner 
A rotating banner on the monitor screen moves a line from right to left and then wraps 
around. It is similar to the Window’s Marquee screen saver. Let the text on the banner 
be “Hello, FPGA World.” The banner should be displayed in four different font sizes and 
can travel at four different speeds. The font size and speed are controlled by four switches. 
Derive the HDL description and then synthesize and verify operation of the circuit. 
13.6.2 Underline for the cursor 
The full-screen text display circuit in Section 13.3 uses reversed color to indicate the current 
cursor location. Modify the design to use an underline to indicate the cursor location. Derive 
the HDL description and then synthesize and verify operation of the circuit. 
13.6.3 Dual-mode text display 
It is sometimes better for text to be displayed on a “vertical” screen. This can be done by 
turning the monitor 90 degrees and resting it on its side. Design this circuit as follows: 
1. Modify the full-screen text display circuit in Section 13.3 for a vertical screen. 
2. Merge the normal and vertical designs to create a “dual-mode” text display. Use a 
3. Derive the HDL description and then synthesize and verify operation of the circuit. 
switch to select the desired mode. 
13.6.4 Keyboard text entry 
Instead of switches and buttons, it is more natural to use a keyboard to enter text. We can 
use the four arrow keys to move the cursor and use the regular keys to enter the characters. 
Use the keyboard interface discussed in Section 8.4 to design the new circuit. Derive the 
HDL description and then synthesize and verify operation of the circuit. 
13.6.5 UART terminal 
The UART terminal receives input from the UART port and displays the received characters 
on a monitor. When connected to the PC’s serial port, it should echo the text on Window’s 
HypterTerminal. The detailed specifications are: 
0 A cursor is used to indicate the current location. 
0 The screen starts a new line when a “carriage return” code (Od16) is received. 

318 
VGA CONTROLLER 11: TEXT 
pattern code 
00 
01 
11 
10 
(a) Tile patterns 
sarnpledvalues 
0 0 0 1 1 1 1 0 0 0 0 
-=LA 
(b) Encoding of sampled values 
Figure 13.7 Tile patterns and encoding of square wave. 
0 A line wraps around (i.e., starts a new line) after 80 characters. 
0 When the cursor reaches the bottom of the screen (i.e., the last line), the first line will 
be discarded and all other lines move up (i.e., scroll up) one position. 
Derive the HDL description and then synthesize and verify operation of the circuit. 
13.6.6 Square wave display 
We can draw a square wave by using four simple tile patterns shown in Figure 13.7(a). 
Follow the procedure of a full-screen text display in Section 13.3 to design a full-screen 
wave editor: 
1. Let the tile size be 8 columns by 64 rows. Create a pattern ROM for the four patterns. 
2. Calculate the number of tiles on a 640-by-480 resolution screen and derive the proper 
3. Use three pushbuttons for control and a 2-bit switch to enter the pattern. 
4. Derive the HDL description and then synthesize and verify operation of the circuit. 
configuration for the tile memory. 
13.6.7 Simple four-trace logic analyzer 
A logic analyzer displays the waveforms of a collection of digital signals. We want to 
design a simple logic analyzer that captures the waveforms of four input signals in "free- 
running" mode. Instead of using a trigger pattern, data capture is initiated with activation of 
a pushbutton switch. For simplicity, we assume that the frequencies of the input waveform 
are between 10 kHz and 100 kHz. The circuit can be designed as follows: 
Use a sampling tick to sample the four input signals. Make sure to select a proper rate 
so that the desired input frequency range can be displayed properly on the screen. 
For a point in the sampled signal, its value can be encoded as a tile pattern by including 
the value of the previous point. For example, if the sampled sequence of one signal is 
"00001 11 lOOO", the tile patterns become "00 00 00 01 11 11 11 10 00 00", as shown 
in Figure 13.7(b). 
Follow the procedure of the preceding square wave experiment to design the tile 
memory and video interface to display the four waveforms being stored . 
Derive the HDL description and then synthesize the circuit. 

SUGGESTED EXPERIMENTS 
31 9 
To verify operation of the circuit, we can connect four external signals via headers around 
the prototyping board. Alternatively, we can create a top-level test module that includes a 
4-bit counter (say, a mod-10 counter around 50 kHz) and the logic analyzer, resynthesize 
the circuit, and verify its operation. 
13.6.8 Complete two-player pong game 
The free-running two-player pong game is described in Experiment 12.7.6. Follow the 
procedure of the pong game in Section 13.4 to derive the complete system. This should 
include the design of a new text display subsystem and the design of a top-level FSM 
controller. Derive the HDL description and then synthesize and verify operation of the 
circuit. 
13.6.9 Complete breakout game 
The free-running breakout game is described in Experiment 12.7.7. Follow the procedure 
of the pong game in Section 13.4 to derive the complete system. This should include the 
design of a new text display subsystem and the design of a top-level FSM controller. Derive 
the HDL description and then synthesize and verify operation of the circuit. 

This Page Intentionally Left Blank

PART 111 
P ICOBLAZE 
M I C RO C 0 N T RO L L E RXILINX 
S P E C I ~ I ~  

This Page Intentionally Left Blank

CHAPTER 14 
PICOBLAZE OVERVIEW 
14.1 INTRODUCTION 
The PicoBlaze processor is a compact 8-bit microcontroller core for Xilinx FPGA devices. 
It is provided as a cell-level HDL description (which is known as soft core) and can be 
synthesized along with other logic. PicoBlaze is optimized for efficiency and occupies only 
about 200 logic cells, which amount to less than 5% resource of a 3.3200 device. While not 
intended as a high-performance processor, it is compact and flexible and can be used for 
simple data processing and control, particularly for non-time-critical “house-keeping’’ and 
I/O operations. The PicoBlaze processor can be easily integrated into a larger system and 
adds another dimension of flexibility in an FPGA-based design. 
Although the detailed coverage of assembly language programming and microcontrollers 
is beyond the scope of this book, this part provides acomprehensive overview of PicoBlaze’s 
organization and instruction set, and illustrates the general assembly program development 
and I/O interface through a set of examples. We review PicoBlaze’s organization and 
instruction set in this chapter, introduce assembly language programming in Chapter 15, 
and discuss the general 1/0 interface and interrupt interface in Chapters 16 and 17. 
FPGA Protovping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
323 

324 
PICOBLAZE OVERVIEW 
14.2 CUSTOMIZED HARDWARE AND CUSTOMIZED SOFTWARE 
14.2.1 From special-purpose FSMD to general-purpose microcontroller 
The RT-level design and FSMD discussed in Chapter 6 provide a general methodology to 
convert a sequential algorithm to customized hardware. The rearranged block diagram is 
shown in Figure 14.1(a). In an FSMD, all components, including the number of registers, 
the routing of registers’ input and output, the number and types of functional units, and 
the control FSM, are tailored to the target application. The data path may contain multiple 
function units and multiple routing paths, as shown in the diagram. 
An alternative is to keep the same hardware but use customized software for different 
applications. The transformation can be done as follows. First, we can replace the cus- 
tomized data path with a fixed configuration, as shown in the top of Figure 14.l(b). The data 
registers and customized routing networks are replaced by a register file, which has a fixed 
number of registers and contains only two read ports and one write port. The customized 
function units are replaced with an ALU (arithmetic and logic unit), which can only perform 
a set of predefined functions. The data path now can perform RT operations in the following 
format only: 
r d c r l  op r2 
where rl, r2, and r d  are the addresses of two source registers and one destination register, 
and op is one of the available ALU functions. 
Second, we can replace the customized FSM with a programmable state machine, as 
shown in the bottom of Figure 14.l(b). Recall that operation of an FSM consists of three 
parts: 
0 The state register keeps track of the current state. 
0 The output logic activates certain output signals according to the current state. 
0 The next-state logic determines the new state. 
0 It replaces the state register with the program counter. The content of the program 
counter represents the current state of the control path. 
0 In an FSM, each state activates certain output signals to control operation of the data 
path. The programmable state machine encodes these output patterns into instructions 
and stores them in a memory module, known asprogram memory or instruction mem- 
ory. A memory address corresponds to a state (i.e., a value) of the program counter. 
During execution, the instruction pointed by the program counter is retrieved from 
the memory and decoded to generate the control signals. The instruction memory 
and decoding logic function as a sophisticated output logic circuit. 
0 In an FSM, there is no limitation on where to go next. From a given state, the FSM 
can check the input condition and move to one of many possible next states. In a 
programmable state machine, the next state is usually the value of the current state 
plus 1 (i.e., the program counter is incremented by l), which reflects the nature of the 
sequential execution. The sequential execution may be altered only by several special 
instructions, such as a jump instruction, in which the program counter is loaded with 
a different value. The incrementor and the associated multiplexing logic function as 
a simple next-state logic circuit. 
After we replace the data path with a register file and an ALU and replace the dedicated 
FSM with a programmable state machine, customizing the system corresponds to developing 
a new sequence of instructions (i.e., develop a software program) and loads the instructions 
The programmable state machine modifies these operations as follows: 

CUSTOMIZED HARDWARE AND CUSTOMIZED SOFTWARE 
325 
rout 
-ing 
* 
-* 
-* 
-+ registers -* -ing 
units 
.......... 
- 
4 
data 
rout + 
functional 
ctrl 
ctrl 
ctrl 
status 
ctrl 
(a) Block diagram of an FSMD 
~ ~ ~ ~ ~ g i s t e r s  
and routing 
replace 
functional units 
I 
/ 
/
I
 
7 
ctrl 
ctrl 
flag 
ctri 
..... 
ctrl 
replace \ 
replace 
output logic 
replace 
next-state logic 
state register 
(b) Simplified block diagram of a microcontroller 
Figure 14.1 Diagrams of an FSMD and a microcontroller. 

326 
PICOBLAZE OVERVIEW 
to the instruction memory. The organization of the FSMD is now the same for different 
applications and becomes a general-purpose hardware platform. The platform constitutes 
the basic skeleton of the PicoBlaze microcontroller. 
14.2.2 Application of microcontroller 
In a customized FSMD, the data path can be created to accommodate an individual applica- 
tion’s needs. It may contain multiple customized functional units and parallel routing paths, 
and can complete complex computation in a single state (i.e., one clock cycle). On the other 
hand, the PicoBlaze microcontroller can only perform one predefined RT operation (i.e., 
an instruction) at a time. It may need many instructions to perform the same task and thus 
require much more time. 
Many tasks can be done by either a customized FSMD or a microcontroller. The trade- 
off is between the hardware complexity, performance and ease of development. There is 
no exact rule on which one to choose. Because developing software is usually easier than 
creating customized hardware, the microcontroller option is generally preferable for non- 
time-critical applications. We can determine the feasibility of this option by examining the 
computation complexity. PicoBlaze requires two clock cycles to complete an instruction. 
If the system clock is 50 MHz, 25 million instructions can be perform in one second. For 
a task (or a collection of tasks), we can examine how frequent a request is issued and how 
fast the task must be completed, and then estimate the number of available instructions. 
For example, assume that a keyboard interface generates a new input data every 1 ms 
and the data must be processed within this interval. Within the 1-ms period, PicoBlaze 
can complete 25,000 instructions. The PicoBlaze controller will be a viable option if the 
required processing can be done by using less than 25,000 instructions. In general, the 
microcontroller is suitable for many non-time-critical I/O-interface or “house-keeping’’ 
tasks. 
14.3 OVERVIEW OF PICOBLAZE 
14.3.1 Basic organization 
PicoBlaze is a compact 8-bit microcontroller with the following characteristics: 
0 8-bit data width 
0 8-bit ALU with the carry and zero flags 
0 16 8-bit general-purpose registers 
0 64-byte data memory 
0 18-bit instruction width 
0 10-bit instruction address, which supports a program up to 1024 instructions 
0 31-word callheturn stack 
0 256 input ports and 256 output ports 
0 2 clock cycles per instruction 
0 5 clock cycles for interrupt handling 
PicoBlaze is based on the skeleton described in Figure 14.l(b) and adds several enhance- 
ments to make it more versatile. The expanded diagram is shown in Figure 14.2. To reduce 
clutter, only the main data flow is shown. The sizes of main storage components are listed 
in round brackets. The processor makes several enhancements over the original skeleton: 

OVERVIEW OF PICOBLAZE 
327 
I 
-b 
register 
+ 
file 
data memory 
address -1 
in-port 
b 
memory 
(64-by-8) 
out-port 
port-id 
(1 &by-8) 
M n s t a n t 
.................... 
logic 
stack 
(31-by.10) 
L.... 
............. 
I 
instruction 
instruction memory 
1 
address 
outside 
processor module 
.......... ctrl 
Figure 14.2 Block diagram of PicoBlaze. 

328 
PICOBLAZE OVERVIEW 
Figure 14.3 Top-level diagram of PicoBlaze. 
0 Add a 44-word data memory. It is known as scratch RAM in Xilinx literature but we 
call it data RAM. 
The data RAM can be considered as a reservoir to store additional 
data. Note that there is no direct path between the data RAM and ALU. Data must 
be fetched to a register for processing and then stored back to the data RAM. 
Add an immediate constantfield in some instructions. This allows a constant, rather 
than the content of a register, to be used in ALU and other operations. The two-to-one 
multiplexer before the ALU’s bottom input is used to select the register output or the 
constant field. 
Add a 31-word stack to support the callheturn functions. We discuss the call and 
return procedure in more detail in Section 14.5.8. 
0 Add paths to input and output external data. An 8-bit port-id signal is used to 
identify a port and thus up to 256 input ports and 256 output ports can be supported. 
The I/O interface is discussed in detail in Chapter 16. 
0 Add an interrupt handling circuit (not shown in the diagram). The interrupt mecha- 
nism is discussed in detail in Chapter 17. 
14.3.2 Top-level HDL modules 
During synthesis, a PicoBlaze system is organized as two top-level HDL modules, as shown 
in Figure 14.3. The KCPSM3 module is the PicoBlaze processor. KCPSM3, which stands for 
constant (K) codedprogrammable state machine, reflects the original name of the PicoBlaze 
processor. It has following input and output signals: 
0 c l k  (input, 1 bit): system clock signal 
0 r e s e t  (input, 1 bit): reset signal 
0 address (output, 10 bits): address of the instruction memory, which specifies the 
0 instruction (input, 18 bits): fetched instruction 
0 port-id (output, 8 bits): address of the input or output port 
0 in-port (input, 8 bits): input data from I/O peripherals 
0 read-storbe (output, 1 bit): strobe associated with the input operation 
0 out-port (output, 8 bits): output data to I/O peripherals 
0 write-storbe (output, 1 bit): strobe associated with the output operation 
0 i n t e r r u p t  (input, 1 bit): interrupt request from I/O peripherals 
0 interrupt-ack (output, 1 bit): interrupt acknowledgement to 110 peripherals 
location of the instruction to be retrieved 

DEVELOPMENT FLOW 
329 
The second module is for the instruction memory. During the development, we usually 
store the compiled assembly code to memory in advance and configure it as a ROM in HDL 
code. It is thus known as an instruction ROM. 
14.4 DEVELOPMENT FLOW 
While developing a system based on a conventional microcontroller, we examine the re- 
quired functionalities and select a processor with the proper computation capability and 
adequate IiO interface. Additional chips are frequently needed to perform special functions. 
One advantage of using a soft-core microcontroller is that we can have both a customized 
circuit and a microcontroller developed and implemented in the same FPGA device. A 
large application usually includes many different tasks. In an FPGA platform, we can im- 
plement the time-critical tasks in a customized circuit (i.e., “hardware”) for performance 
and realize the remaining house-keeping and low-speed I/O functions in a microcontroller 
(i.e., “software”). 
The basic PicoBlaze-based development flow is shown in Figure 14.4. It consists of the 
following steps: 
1. Determine the software-hardware partition. 
2. Develop the assembly program for the software portion. 
3. Compile the assembly program to generate an instruction ROM. The ROM is an HDL 
4. Perform instruction-set-level simulation. 
5. Derive HDL code for the hardware portion. The hardware includes customized 
circuits to perform special I/O and time-critical functions and customized circuits to 
interface with PicoBlaze. 
6. Create the top-level HDL code that combines the codes for the PicoBlaze core, the 
instruction ROM, and customized hardware. 
7. Develop a testbench and perform HDL simulation for the entire system. 
8. Synthesize and implement the HDL code and program the FPGA chip on the proto- 
file. 
typing board. 
The subsequent chapters explain these steps in detail. 
The step 9 shown in the dotted line is not a part of the normal development flow. It 
reloads the instruction memory after the entire system is synthesized. This step is discussed 
in Section 15.5.3. 
14.5 INSTRUCTION SET 
PicoBlaze has 57 instructions. The instructions have five general formats. We organize 
the instructions according to the nature of their operations and divide them into following 
categories: 
0 Logical instructions 
0 Arithmetic instructions 
0 Compare and test instructions 
0 Shift and rotate instructions 
0 Data movement instructions 
0 Program flow control instructions 
0 Interrupt related instructions 

330 
PICOBLAZE OVERVIEW 
hardware 
development 
r-p.7 
PicoBlaze /-/ 
/-/ assembly 
simulation 
e 
/ testbench / / $
:
:
:
e
 
/ 
I -  
om 
synthesis 
device 
programming 
0 
F-" 
dowloading 
Figure 14.4 
Development flow of a system with PicoBlaze. 

INSTRUCTION SET 
331 
s3 
sc 
Sd 
se E 
sf 
register 
file 
3c 
3D 
3E 
3F 
data 
RAM 
1.9 
:: t-j 
3FF 
Instruction 
callheturn 
memory 
stack 
El 
El 
flags 
Figure 14.5 PicoBlaze programming model. 
In this section, we first examine the program model and instruction format, and then list 
and explain each instruction. 
14.5.1 Programming model 
From an assembly programming point of view, PicoBlaze contains 16 8-bit registers, a 
64-byte data RAM, three flags (for zero, carry and interrupt), the program counter and the 
top-of-stack pointer. The model, sometimes known as the instruction set architecture, is 
shown in Figure 14.5. After an instruction is executed, the contents of these components 
are modified explicitly or implicitly. The operations associated with each instruction are 
discussed in Section 14.5.3. 
We use the following notations for these memory components and some constant defi- 
nitions: 
sX, sY: each representing one of the 16 general-purpose registers, where X and Y take 
on hexadecimal values from 0 to f 
pc: program counter 
t 0s: top-of-stack pointer of the callheturn stack 
c, z, i: carry, zero, and interrupt flags 
KK: 8-bit constant value or port id, which is usually expressed as two hexadecimal 
digits 
SS: 6-bit constant data memory address, which is usually expressed as two hexadec- 
imal digits 
AAA: 10-bit constant instruction memory address, which is usually expressed as three 
hexadecimal digits 

332 
PICOBLAZE OVERVIEW 
14.5.2 Instruction format 
In an assembly program, we generally follow the conventions used in our HDL code, in 
which a keyword (an instruction mnemonic) is in a boldface font and a constant is in capital 
letters. PicoBalze’s instructions have five formats: 
op sX, sY: register-register format. The op term specifies the operation. The SX 
and SY terms are the two operands and SX also serves as the destination register. It 
performs the SX + SX op SY operation. 
op sX, KK: register-constant format. This format is similar to the register-register 
format except that the second operand is replaced by an immediate constant. It 
performs the SX + SX op KK operation. 
op sX: single-register format. This format is used in shift and rotate instructions, 
which involve only one operand. It performs the SX t op SX operation. 
op AAA: single-address format. This format is used in jump and call instructions. 
The AAA term is an address of the instruction memory. If the specified condition is 
met, AAA is loaded into the program counter. 
0 op: zero-operand format. This format is used in some miscellaneous instructions 
that do not involve any operand. 
There are two assembler programs for PicoBlaze: KCPSM3 from Xilinx and PBlazeZDE 
from Mediatronix. The two programs use different mnemonics for several instructions. 
In the following subsections, the alternative mnemonics used in PBlazeIDE are shown in 
round brackets. 
14.5.3 Logical instructions 
There are six logical instructions, which support the and, or, and xor operations. An 
instruction performs bitwise logical operation between two registers or one register and a 
constant. The carry flag, c, is always cleared. The zero flag, z, reflects the result of the 
operation. The mnemonics, brief descriptions, and pseudo operations of these instructions 
are: 
and sX, SY 
- bitwise and operation 
- pseudo operation: 
S X  +- 
sX and sY; 
c +- 
0 ;  
and sX, KK 
- bitwise and operation 
- pseudo operation: 
SX + sX and KK; 
c + 0; 
0 or sx, SY 
- bitwise or operation 
- pseudo operation: 
S X  c sX o r  sY; 
c + 0; 
or sX, KK 
- bitwise or operation 

INSTRUCTION SET 
333 
- pseudo operation: 
sX t sX or KK; 
c t 0; 
0 xor s X ,  SY 
- bitwise xor operation 
- pseudo operation: 
sX t sX xor sY; 
c + 0; 
0 xor s X ,  KK 
- bitwise xor operation 
- pseudo operation: 
SX t sX xor KK; 
c 4- 
0; 
14.5.4 Arithmetic instructions 
There are eight arithmetic instructions, n ..ich support addition and subtraction with or 
without the carry flag. The carry flag, c, and the zero flag, z, reflect the result of operation. 
The mnemonics, brief descriptions, and pseudo operations of these instructions are: 
0 add s X ,  SY 
- add without the carry flag 
- pseudo operation: 
sx + sx + sY; 
0 add s X ,  KK 
- add without the carry flag 
- pseudo operation: 
sX t sX + KK; 
0 addcy s X ,  SY (addc s X ,  s Y )  
- add with the carry flag 
- pseudo operation: 
0 addcy s X ,  KK (addc s X ,  KK) 
- add with the carry flag 
- pseudo operation: 
sx + sx + SY + c ;  
sX t sX + KK + c; 
0 s u b s X , s Y  
- subtract without the carry flag 
- pseudo operation: 
sx t sx - sY; 
0 s u b s X , K K  
- subtract without the carry flag 
- pseudo operation: 
S X  t SX - KK; 

334 
PICOBLAZE OVERVIEW 
subcy sX, sY (subc sX, sY) 
- subtract with the carry flag (flag functioning as a borrow bit) 
- pseudo operation: 
0 subcy sX, KK (subc sX, KK) 
- subtract with the carry flag (flag functioning as a borrow bit) 
- pseudo operation: 
sx +- s x  - S Y  - c ;  
SX t SX - KK - C ;  
14.5.5 Compare and test instructions 
The compare and test instructions examine two registers or one register and constant, and 
set the carry and zero flags accordingly. The contents of the registers remain intact. These 
instructions are usually used in conjunction with a conditional jump or call instruction, 
whose operation is based on the values of the flags. 
A compare instruction performs subtraction operation. The result is used to set the carry 
and zero flags and not stored to any register. The mnemonics, brief descriptions, and pseudo 
operations of the two instructions are: 
0 compare sX, SY (comp sX, sY) 
- compare two registers and set the flags 
- pseudo operation: 
if s X = s Y  t h e n  z t 1 e l s e  z t 0 ;  
if s Y > s X  t h e n  c t 1 e l s e  c t 0 ;  
0 compare sX, KK (comp sX, KK) 
- compare a register and a constant and set the flags 
- pseudo operation: 
if s X = K K  t h e n  z t 1 e l s e  z t 0 ;  
if K K > s X  t h e n  c t 1 e l s e  c t 0 ;  
A test instruction performs an and operation. The result is used to set the flags and not 
stored in any register. If the result is 0, the zero flag is set to 1. The result is also fed to an 
eight-input xor circuit to obtain the odd panty. If there are odd number of 1’s in the result, 
the carry flag is set to 1. The mnemonics, brief descriptions, and pseudo operations of the 
two instructions are shown below. The t is the 8-bit temporary result and will be discarded. 
0 test sX, SY 
- test two registers and set the flags 
- pseudo operation: 
t t s X  and s Y ;  
if t = O  t h e n  z c 1 e l s e  z +- 0 ;  
c t t ( 7 )  x o r  t ( 6 )  xor . . .  xor t ( 0 ) ;  
0 test sX, KK 
- test a register and a constant and set the flags 
- pseudo operation: 
t t sX and K K ;  
if t = O  t h e n  z t 1 e l s e  z t 0 ;  
c c t ( 7 )  xor t ( 6 )  x o r  ... x o r  t ( 0 ) ;  

INSTRUCTION SET 
335 
7 
6 
5 
4 1 3 1 2  1 1 0  
7
6
5
4
3
2
1
0
 
slx 
1
6
5
4
3
2
1
0
 
sla 
rr 
7
6
5
4
3
2
1
0
 
srx 
sra 
1
6
5
4
3
2
1
0
 
Figure 14.6 Illustration of shift and rotate instructions. 
14.5.6 Shift and rotate instructions 
There are four shift-left instructions, four shift-right instructions, and two rotate instructions. 
These instructions use the single-register format and have only one operand. The graphical 
representations of these instructions are shown in Figure 14.6. The mnemonics, brief 
descriptions, and pseudo operations of these instructions are shown below. The & symbol 
means to concatenate two operands. 
0 s10 sx 
- shift a register left 1 bit and shift 0 into the LSB 
- pseudo operation: 
SX 
+- 
s X ( 6 . . 0 )  
& 0 ;  
c + s X ( 7 ) ;  
0 sll sx 
- shift a register left 1 bit and shift 1 into the LSB 
- pseudo operation: 
s X  t s X ( 6 . . 0 )  
& 1; 
c + s X ( 7 ) ;  
0 SIX sx 
- shift a register left 1 bit and shift SX (0) into the LSB 
- pseudo operation: 
SX + s X ( 6 .  . O )  & s X ( 0 )  ; 
c + s X ( 7 ) ;  
sla sx 
- shift a register left 1 bit and shift c into the LSB 
- pseudo operation: 
S X  t s X ( 6 .  . O )  & c ;  
c t s X ( 7 ) ;  

336 
PICOBLAZE OVERVIEW 
0 srOsX 
- shift a register right 1 bit and shift 0 into the MSB 
- pseudo operation: 
s x  +- 0 & sX(7..1); 
c t sX(0); 
0 srl s X  
- shift a register right 1 bit and shift 1 into the MSB 
- pseudo operation: 
s x  c 1 & sX(7..1); 
c c sX(0); 
0 srx s X  
- shift a register right 1 bit and shift sX(7) into the MSB 
- pseudo operation: 
sx + sX(7) & SX(7.. 1) ; 
c c sX(0); 
a sra SX 
- shift a register right 1 bit and shift c into the MSB 
- pseudo operation: 
sx t c & sX(7..1); 
c i-- sX(0); 
0 rlsX 
- rotate a register left 1 bit 
- pseudo operation: 
SX + sX(6..0) & sX(7); 
c t sX(7); 
0 rr sX 
- rotate a register right 1 bit 
- pseudo operation: 
sx +- sX(0) & sX(7..1); 
c +- sX(0); 
14.5.7 Data movement instructions 
In PicoBlaze, the computation is done via the registers and ALU. The data RAM supplies 
additional storage and the I/O ports provide paths to peripherals. There are several instruc- 
tions to move data between the registers, data RAM, and I/O ports. The instructions can be 
divided into three categories: 
0 Between registers: the load instruction 
0 Between a register and data RAM: the fetch and store instructions 
0 Between a register and an I/O port: the input and output instructions 
The mnemonics, brief descriptions, and pseudo operations of the data movement instruc- 
tions are shown below. The RAM [ ] notation represents the content of the data RAM. Note 
that in some instructions, the indirect address notation, as in (sY), is used in mnemonic to 
emphasize that the content of the sY register is used. 

INSTRUCTION SET 
337 
0 l o a d s X , s Y  
- move data between two registers 
- pseudo operation: 
sx + sY; 
0 load s X ,  KK 
- move a constant to a register 
- pseudo operation: 
sX + K K ;  
0 fetch sX, ( s Y >  (fetch sX, sY) 
- move data from the data RAM to a register 
- pseudo operation: 
sX + R A M [ ( s Y ) I ;  
0 fetch s X ,  SS 
- move data from the data RAM to a register 
- pseudo operation: 
a store s X ,  (sY> (store s X ,  s Y )  
- move data from a register to the data RAM 
- pseudo operation: 
sX + R A M C S S I ;  
R A M C ( s Y ) l  t sX; 
0 store sX, SS 
- move data from a register to the data RAM 
- pseudo operation: 
0 input sX, ( s Y >  (in sX, sY) 
- move data from the input port to a register 
- pseudo operation: 
R A M C S S ]  t sX; 
p o r t - i d  + s Y ;  
sX + i n - p o r t ;  
0 input sX, KK (in sX, KK) 
- move data from the input port to a register 
- pseudo operation: 
p o r t - i d  t K K ;  
sX t i n - p o r t ;  
0 output sx, (SY) (out sx, SY) 
- move data from a register to the output port 
- pseudo operation: 
p o r t - i d  
+- 
s Y ;  
o u t - p o r t  t sX; 
0 output s X ,  KK (out sX, KK) 
- move data from a register to the output port 
- pseudo operation: 
p o r t - i d  t K K ;  
o u t - p o r t  +- 
sX; 

338 
PICOBLAZE OVERVIEW 
There is no explicit instruction to move data to or from the instruction memory. However, 
many instructions include a field for an immediate constant. Since the constant is part of 
the instruction and stored in the instruction memory, it can be considered as data that is 
implicitly moved from the instruction memory to a register. 
14.5.8 Program flow control instructions 
In PicoBlaze, the program counter indicates where to fetch the instruction. By default, the 
execution proceeds to the next address in the instruction memory and the program counter 
is implicitly incremented (i.e,, pc t pc + I). The jump, call and return instructions 
can explicitly load a value to the program counter and modify the program flow. These 
instructions can be executed unconditionally or conditionally based on the values of the 
carry and zero flags. 
A jump instruction loads new value to the program counter if the corresponding condition 
is met. The program execution changes the regular flow and branches to the new address. 
The program flow continues normally after this point. The mnemonics, brief descriptions, 
and pseudo operations of these instructions are shown below. Recall that AAA is for the 
10-bit instruction memory address and pc is for the program counter. 
0 jump AAA 
- unconditionally jump 
- pseudo operation: 
pc + A A A ;  
0 jump c, AAA 
- jump if the carry flag is set 
- pseudo operation: 
if c = l  then pc t A A A  else pc +- pc + 1; 
0 jump nc, AAA 
- jump if the carry flag is not set 
- pseudo operation: 
if c=O then pc + A A A  else pc t pc + 1; 
0 jumpz,AAA 
- jump if the zero flag is set 
- pseudo operation: 
if z=1 then pc + A A A  else pc + pc + 1; 
0 jump nz, AAA 
- jump if the zero flag is not set 
- pseudo operation: 
if z=O then pc t A A A  else pc + pc + 1; 
The call and return instructions are used to implement a software function. When 
a function is called, the processor suspends the current execution and branches to the 
corresponding routine. When the routine computation is completed, the processor returns to 
the suspended point and continues the execution. Like a jump instruction, a call instruction 
loads a new value to the program counter if the corresponding condition is met. In addition, 
it also saves the current value of the program counter in a special buffer, known as the stack. 
The new address represents the starting point of a routine. The routine should include a 
return instruction in the end. The return instruction obtains the saved value from the 

INSTRUCTION SET 
339 
Figure 14.7 Representative flow of a subroutine call. 
stack, increments the value by 1, and loads it to the program counter. This allows the 
execution to return to the instruction that immediately follows the original call instruction. 
A representative program flow is shown in Figure 14.7. 
PicoBlaze allows nested function calls, which means that a function can be called within 
another function. To support this feature, a stack, which is a last-in-first-out buffer, is used 
to store the program counter’s values. In this buffer, the address of the newest call is pushed 
to the top of the stack (i.e., the “last-in”). Assume that this routine does not contain other 
function call inside. It will be completed first and the saved returned address is on the top 
of the stack. It should be popped from the stack (i.e., “first-out”) to resume the previous 
execution. PicoBlaze provides a 31-word stack for the nested call and return operations. 
The mnemonics, brief descriptions, and pseudo operations of the call and return instruc- 
tions are shown below. Recall that and t o s  is for the top-of-stack pointer. The STACK [ 1 
notation represents the content of the stack. 
- unconditionally call subroutine 
- pseudo operation: 
0 call AAA 
t o s  + t o s  + I; 
STACK[tos] +- 
p c ;  
pc + A A A ;  
0 call c, AAA 
- call subroutine if the carry flag is set 
- pseudo operation: 
i f  c = l  t h e n  
t o s  t t o s  + 1; 
STACK[tosl + p c ;  
pc 
+- 
A A A ;  
e l s e  

340 
PICOBLAZE OVERVIEW 
pc + pc + 1; 
0 call nc, AAA 
- call subroutine if the carry flag is not set 
- pseudo operation: 
i f  c=O t h e n  
t o s  t t o s  + 1; 
STACK"Cos1 t p c ;  
pc +- A A A ;  
e l s e  
pc +- pc + 1; 
0 call z, AAA 
- call subroutine if the zero flag is set 
- pseudo operation: 
if z = 1  t h e n  
t o s  t t o s  + 1; 
STACK[tos] 
+- 
p c ;  
p c  t A A A ;  
e l s e  
0 call nz, AAA 
p c  t pc + 1; 
- call subroutine if the zero flag is not set 
- pseudo operation: 
i f  z=O t h e n  
t o s  +- t o s  + 1; 
STACKCtosI + p c ;  
pc c A A A ;  
e l s e  
0 return (ret) 
pc + pc + 1; 
- unconditionally return 
- pseudo operation: 
pc t STACK[tos] + 1; 
t o s  +- 
t o s  - 1; 
0 return c (ret c) 
- return if the carry flag is set 
- pseudo operation: 
if c = l  t h e n  
pc +- 
STACK[tos] + 1; 
t o s  t t o s  - 1; 
pc t pc + 1; 
- return if the cany flag is not set 
- pseudo operation: 
e l s e  
0 return nc (ret nc) 
if c=O t h e n  
p c  t STACK[tos] + 1; 
t o s  t t o s  - 1; 

INSTRUCTION SET 
341 
else 
pc + pc + 1 
0 return z (ret z) 
- return if the zero flag is set 
- pseudo operation: 
if z=1 t h e n  
pc +- 
STACKCtos] + 1; 
t o s  + tos - 1; 
pc +- 
pc + 1; 
- return if the zero flag is not set 
- pseudo operation: 
else 
0 return nz (ret nz) 
if z=O t h e n  
pc + STACKCtos] + 1; 
t o s  + t o s  - 1; 
pc +- 
pc + 1; 
else 
14.5.9 Interrupt related instructions 
Interrupt is another mechanism to alter program execution and its detail is discussed in 
Chapter 17. Unlike the jump and call instructions, it is initiated from an external request. 
When the interrupt flag is enabled and the interrupt request is asserted, PicoBlaze completes 
execution of the current instruction, saves the address of the next instruction in the call/return 
stack, preserves the carry and zero flags, disables the interrupt flag, and loads the program 
counter with 3FF, which is the starting address of the interrupt service routine. PicoBlaze 
has two return-from-interrupt instructions, which resume the operation from the interrupted 
location. It also has two instructions that enable and disable the interrupt request by setting 
or clearing the interrupt flag, i. The mnemonics, brief descriptions and pseudo operations 
of these instructions are: 
0 returni disable (reti disable) 
- return from interrupt service routine and keep the interrupt flag disabled 
- pseudo operation: 
pc + STACKCtosl; 
t o s  +-- 
t o s  - 1; 
i +- 0; 
c t preserved c ;  
z +- preserved z ;  
0 returni enable (reti enable) 
- return from interrupt service routine and keep the interrupt flag enabled 
- pseudo operation: 
pc + STACKCtosI; 
t o s  + tos - 1; 
i t 1; 
c +-- 
preserved c; 
z + preserved z ;  

342 
PICOBLAZE OVERVIEW 
0 enable interrupt (eint) 
- enable interrupt request 
- pseudo operation: 
i +- 
1; 
0 disable interrupt (dint) 
- disable interrupt request 
- pseudo operation: 
i + 0 ;  
Note that the interrupt mechanism saves the address of the next instruction. When a returni 
instruction is executed, the address saved on the top of the stack (i.e., STACK [tos] ) is 
restored. This is different from a regular return instruction, in which the incremented 
address (i.e., STACK [tos] +1) is restored. 
14.6 ASSEMBLER DIRECTIVES 
An assembler directive looks like an instruction in an assembly program. However, it is 
not part of the microcontroller’s instruction set but is used to help program development. 
As its name suggests, a directive “directs” the assembler to perform a specific task, such 
as defining a constant or reserving data space. The KCPSM3 and PBlazeIDE assemblers 
have somewhat different directives and they are discussed in the following subsections. 
14.6.1 The KCPSM3 directives 
The mnemonics, descriptions, and examples of key directives used in the KCPSM3 assem- 
bler are: 
address 
- The directive specifies the subsequent code to be put to a specific address in the 
- Example: 
instruction ROM. 
address 
3FF 
0 namereg 
tive. 
- The directive gives a symbolic name for a register. It makes code more descrip- 
- Example: 
namereg 
s 5 ,  index 
0 constant 
- The directive gives a symbolic name for a constant. It makes code more de- 
scriptive. 
- Example: 
con s tan t 
max, FO 
14.6.2 The PBlazelDE directives 
The mnemonics, descriptions, and examples of key directives used in the PBlazeIDE as- 
sembler are shown below. Note that a $ sign is needed for a number in hexadecimal format. 

BIBLIOGRAPHIC NOTES 
343 
org 
- The directive specifies the subsequent code to be put to a specific address in the 
- Example: 
instruction ROM (i.e., “originate” from this address). 
org 
$3FF 
equ 
- The directive “equates” a symbol to a value or register. It gives a symbolic 
- Example: 
name for a constant or a register. 
max 
equ 
128/8 
i n d e x  
equ 
s5 
0 dsin, dsout, dsio 
- These directives equate a symbolic name for an I/O port id. The corresponding 
port can be defined as input, output, or both input and output. The difference 
between these directives and equ is that PBlazeIDE generates “port indicators” 
for these directives on the simulation screen. The I/O activities can be displayed 
and simulated via these indicators. 
- Example: 
k e y b o a r d  
dsin 
$OE 
s w i t c h  
dsin 
$OF 
l e d  
dsout $15 
vhdl 
- This directive generates instruction ROM in VHDL format. The detail is dis- 
- Example: 
cussed in Chapter 15. 
vhdl ” t e m p l a t e  . v h d ”  , “ t a r g e t  . v h d ” ,  “ R O M ”  
14.7 BIBLIOGRAPHIC NOTES 
The PicoBlaze’s manual from Xilinx, PicoBlaze 8-bit Embedded Microcontroller User 
Guide, provides detailed information about this microcontroller, including the hardware 
organization, instruction set, development process, and the KCPSM3 and PBlazeIDE as- 
semblers. Ken Chapman, the designer of PicoBlaze, describes the derivation of this mi- 
crocontroller in article “Creating Embedded Microcontrollers,” which is available in the 
TechXclusives section of Xilinx Web site. 
The KCPSM3 assembler, PicoBlaze HDL code, and instruction ROM HDL template 
can be downloaded from the Xilinx Web site. Searching with the “PicoBlaze” keyword 
will lead to the downloading page. The PBlazeIDE assembler can be downloaded from 
the Mediatronix Web site, h t t p  : //www . mediatronix. com. The site also provides more 
detailed information about the software. 

This Page Intentionally Left Blank

CHAPTER 15 
PICOBLAZE ASSEMBLY CODE 
DEVELOPMENT 
15.1 INTRODUCTION 
Because of its simplicity, PicoBlaze cannot effectively support high-level programming 
languages and the code is generally developed in assembly language. In this chapter, we 
provide an overview of code development, which is illustrated in a bottom-up fashion. We 
first introduce the segments of frequently used data and control operations and then examine 
the use of a subroutine and finally outline the derivation of overall program structure. 
15.2 USEFUL CODE SEGMENTS 
The PicoBlaze microcontroller contains instructions for byte-oriented data manipulation 
and simple conditional branch. In this section, we illustrate how to construct code to 
perform bit and multiple-byte operations and to realize frequently used high-level language 
control constructs. 
15.2.1 KCPSM3 conventions 
The KCPSM3 assembler uses the following conventions in an assembly program: 
0 Use a “ : ” sign after a symbolic address in code, as in “done : ”. 
0 Use a “; ” sign before a comment. 
0 Use HH for a constant, in which H is a hexadecimal digit. 
FPGA Protovpiping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
345 

346 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
An example of a code segment follows: 
; t h i s  is a demo segment 
t e s t  S O ,  82 
; compare S O  with 1000 -001 0 
jump z ,  clr-sl 
; i f  MSB of 
S O  is 0 ,  go t o  c l r - s l  
load s l ,  FF 
; n o ,  load l I l I _ l I I l  t o  s l  
load s l ,  0 1  
; load 0000 -0001 t o  s l  
clr-sl: 
15.2.2 Bit manipulation 
PicoBlaze’s instruction set is primarily for byte-oriented operations. Bit-oriented operations 
are frequently needed to control low-level I/O activities, such as testing, setting, and clearing 
a 1-bit flag signal. 
To manipulate a single bit, we first define a musk to isolate and preserve (i.e., mask) the 
unrelated bits and then apply the designated operation on the desired bits (i.e., unmasked 
bits). We can set, clear, and toggle (i.e., invert) some bits of a data byte by performing or, 
and, and xor instructions with a proper mask. The following code segment shows how to 
set, clear, and toggle the second LSB of the SO register: 
constant SET-MASK , 02 
; m a s k = 0 0 0 0 ~ 0 0 1 0  
c ons tan t CLR-MASK , FD 
; m a s k = I l I l - l l O l  
constant TOG-MASK , 02 
;mask=OOOO-OOIO 
or 
S O ,  SET-MASK 
; s e t  2nd LSB t o  1 
and S O ,  CLR-MASK 
; c l e a r  2nd LSB t o  0 
xor S O ,  TOG-MASK 
; t o g g l e  2nd LSB 
The toggle operation is based on the observation that for any Boolean variable z, z C? 0 = z 
and z E? 1 = z’. The same principle can be applied to multiple bits. For example, we can 
clear the upper nibble (i.e., four MSBs) by using 
and S O ,  OF 
; mask =OOOO -1 1 I 1 
We can also apply the concept of the and mask to the test instruction to check a single 
bit. For example, the following code segment tests the MSB of the SO register and branches 
to a proper routine accordingly: 
t e s t  S O ,  80 
; m a s k = 1 0 0 0 ~ 0 0 0 0  
jump n z ,  msb-set 
;MSB i s  1 ,  branch to m s b - s e t  
; c o d e  f o r  MSB not s e t  
jump 
done 
; c o d e  f o r  MSB s e t  
msb-set : 
. . .  
done : 
. . .  
A single bit can be extracted by applying the previous code. For example, the following 
code segment extracts the MSB of the SO register and stores it in the si register: 
load s l ,  00 
t e s t  S O ,  80 
; m a s k = 1 0 0 0 ~ 0 0 0 0 ,  e x t r a c t  MSB 
jump z ,  done 
; y e s ,  MSB i s  0 
load s l ,  0 1  
; n o ,  load 1 t o  s l  

USEFUL CODE SEGMENTS 
347 
done : 
15.2.3 Multiple-byte manipulation 
A microcontroller sometimes needs to handle wide, multiple-byte data, such as a large 
counter. Since the data width of PicoBlaze is 8 bits, processing this type of data requires a 
mechanism to propagate information between two successive instructions. PicoBlaze uses 
the carry flag for this purpose. For the arithmetic instructions, there are two versions for 
addition and subtraction, one with carry and one without carry, as in the add and addcy 
instructions. For the shift and rotate instructions, carry can be shifted into the MSB or LSB 
of a register, and vice versa. 
Assume that x and y are 24-bit data and each occupies three registers. The following 
code segment illustrates the use of carry in multiple-byte addition: 
namereg S O ,  x0 
; l e a s t  s i g n i f i c a n t  b y te  of 
x 
namereg s l ,  xl 
; m i d d l e  b yt e  of 
x 
namereg s2, x2 
; m o s t  s i g n i f i c a n t  b y te  of x 
namereg s 3 ,  yo 
; l e a s t  s i g n i f i c a n t  b y t e  of 
y 
namereg s 4 ,  yl 
; m i d d l e  b yte  of 
y 
namereg s5, y2 
; m o s t  s i g n i f i c a n t  b y te  of y 
; a d d :  { x 2 , x l , x O }  + { y 2 , y l , y O }  
add x 0 ,  yo 
; add 
1 e a s t  s i g n i f i c a n t  b y t e s  
addcy xl, yl 
;add middle b y t e s  w ith  c a r r y  
addcy x2, y2 
;add most s i g n i f i c a n t  b y t e s  with c a r r y  
The first instruction performs normal addition of the least significant bytes and stores the 
carry-out bit into the carry flag. The second instruction then includes the carry flag when 
adding the middle bytes. Similarly, the third instruction uses the carry flag from the previous 
addition to obtain the result for the most significant bytes. 
The incrementing and subtraction of multiple bytes can be achieved in a similar fashion: 
; i n c r e m e n t  : { x 2 ,  X I ,  XO } + I 
add x 0 ,  0 1  
; i n c l e a s t  s i g n i f i c a n t  b y te  
addcy x i ,  00 
;add ca rry t o  middle b y t e  
addcy x 2 ,  00 
;add ca rry to  most s i g n i f i c a n t  b y te  
; s u b t r a c t :  ( x 2 , x l  , x O }  - ( y 2 , y l  , y o }  
sub x 0 ,  yo 
; s u b  l e a s t  s i g n i f i c a n t  b y t e  
subcy xl, yl 
; s u b  middle b y te  w ith  borrow 
subcy x2, y2 
; s u b  most s i g n i f i c a n t  b y te  w ith  borrow' 
Multiple-byte data can be shifted by including the carry flag in the individual shift 
instruction. For example, the sla instruction shifts data left one position and shifts the carry 
flag into LSB. The code for shifting a 3-byte data left can be written as 
; s h i f t  { x 2 ,  x l  , x0 } via ca rry  
,510 xo 
; O  t o  LSB of x 0 ,  MSB of 
x0 to  c a r r y  
s l a  xi 
; c a r r y  t o  LSB of x l ,  MSB of 
x l  to  carry 
s l a  x2 
; c a r r y  t o  LSB of x 2 ,  MSB of 
x2 to  carry 

348 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
15.2.4 Control structure 
A high-level programming language usually contains various control constructs to alter 
the execution sequence. These include the if-then-else, case, and for-loop statements. On 
the other hand, PicoBlaze provides only simple conditional and unconditional jump in- 
structions. Despite its simplicity, we can use them with a test or compare instruction to 
implement the high-level control constructs. The following examples illustrate the con- 
struction of the if-then-else, case, and for-loop statements. 
Let us first consider the if-then-else statement: 
i f  (sO==sl) { 
/ *  t h e n - b r a n c h  s t a t e m e n t s  * /  
e l s e  { 
3 
/ *  e l s e - b r a n c h  s t a t e m e n t s  */ 
The corresponding assembly code segment is 
compare S O ,  sl 
jump n z ,  e l s e - b r a n c h  
; c o d e  f o r  t h e n  branch 
jump i f - d o n e  
; c o d e  f o r  e l s e  branch 
. . .  
e l s e - b r a n c h  : 
i f  -done : 
; c o d e  f o l l o w i n g  i f  s t a t e m e n t  
. . .  
The code uses the compare instruction to check the sO==sl condition and to set the zero 
flag. The following jump instruction examines the flag and jumps to the else branch if the 
flag is not set. 
The case statement can be considered as a multiway jump, in which the execution is 
transferred according to the value of the selection expression. The following statement uses 
the SO variable as the selection expression and jumps to the corresponding branch: 
s w i t c h  ( S O )  { 
c a s e  v a l u e l :  
/ *  c a s e  v a l u e l  s t a t e m e n t s  * /  
b r e a k  ; 
c a s e  v a l u e 2 :  
/ *  c a s e  v a l u e 2  s t a t e m e n t s  * /  
b r e a k  ; 
c a s e  v a l u e 3 :  
/ *  c a s e  v a l u e 3  s t a t e m e n t s  */ 
b r e a k :  
/ *  d e f a u l t  s t a t e m e n t s  * /  
d e f a u l t  : 
The multiway jump can be implemented by a hardware feature known as “index address 
mode” in some processors. However, since PicoBlaze does not support this feature, the case 
statement has to be constructed as a sequence of if-then-else statements. In other words, 
the previous case statement is treated as: 

USEFUL CODE SEGMENTS 
349 
i f  ( s O = = v a l u e l )  { 
> 
e l s e  i f  ( s O = = v a l u e Z )  { 
/ *  c a s e  v a l u e l  s t a t e m e n t s  * /  
/ *  c a s e  v a l u e 2  s t a t e m e n t s  * /  
e l s e  i f  ( s O = = v a l u e 3 )  { 
/ *  c a s e  v a l u e 3  s t a t e m e n t s  * /  
Jt 
e l s e €  
/ *  d e f a u l t  s t a t e m e n t s  * /  
J 
The corresponding assembly code segment becomes 
c ons tan t v a l u e l  , . . . 
c ons tan t v a l u e 2 ,  . . . 
c ons tan t v a l u e 3 ,  . . . 
compare S O ,  v a l u e l  
; t e s t  v a l u e l  
jump n z ,  c a s e - 2  
; n o t  e q u a l  t o  v a l u e l  , j u m p  
; c o d e  f o r  c a s e  1 
jump c a s e - d o n e  
compare S O ,  value:! 
; t e s t  v a l u e 2  
jump n z ,  c a s e - 3  
; n o t  e q u a l  t o  v a l u e 2 ,  j u m p  
; c o d e  f o r  c a s e  2 
jump c a s e - d o n e  
compare S O ,  v a l u e 3  
; t e s t  v a l u e 3  
jump d e f a u l t  
; n o t  e q u a l  t o  v a l u e 3 ,  j u m p  
; c o d e  f o r  c a s e  3 
. . .  
c a s e - 2  : 
. . .  
c a s e - 3  : 
jump c a s e - d o n e  
: c o d e  f o r  d e f a u l t  c a s e  
d e f a u l t  : 
. . .  
c a s e - d o n e  : 
; c o d e  f o l l o w i n g  c a s e  s t a t e m e n t  
The for-loop statement executes a segment of the code repetitively. The loop statement 
can be implemented by using a counter to keep track of the iteration number. For example, 
consider the following: 
for(i=MAX, i = O ,  i-1) C 
> 
/ *  l o o p  body s t a t e m e n t s  * /  
The assembly code segment is 
namereg S O ,  i 
; l o o p  i n d e x  
c ons tan t MAX, . . . 
; l o o p  b o u n d a r y  

350 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
load i ,  M A X  
; l o a d  l o o p  i n d e x  
; c o d e  f o r  l o o p  body 
loop-body : 
sub i ,  01 
; d e c  l o o p  i n d e x ?  
jump nz , loop-body 
; d o n e ?  
; c o d e  f o l l o w i n g  f o r  l o o p  
15.3 SUBROUTINE DEVELOPMENT 
A subroutine, such as a function in C, implements a section of a larger program. It is coded 
to perform a specific task and can be used repetitively. Using subroutines allows us to 
divide a program into small, manageable parts and thus greatly improve the reliability and 
readability of a program. It is the base of modem programming practice and is supported 
by all high-level programming languages. 
PicoBlaze uses the call and return instructions to implement the subroutine. The call 
instruction saves the current content of the program counter and transfers the program exe- 
cution to the starting address of a subroutine. A subroutine ends with a return instruction, 
which restores the saved program counter and resumes the previous execution. A represen- 
tative flow is shown in Figure 14.7. Note that PicoBlaze only saves and restores the content 
of the program counter during a function call and return. We have to manage the register 
and data RAM use manually to ensure that the original system state is not altered after a 
subroutine call. 
The following multiplication example illustrates the development of subroutines. We 
assume that the inputs are two 8-bit numbers in unsigned integer format and the output is 
a 16-bit product. The algorithm is based on a simple shift-and-add method. This method 
iterates through 8 bits of multiplier. In each iteration, the multiplicand is shifted left one 
position. If the corresponding multiplier bit is 'l', the shifted multiplicand is added to 
the partial product. The assembly code is shown in Listing 15.1. The multiplicand and 
multiplier are stored in the s3 and s4 registers. The individual bit of multiplier is obtained 
by repetitively shifting s4 to the right, which moves the LSB to the carry flag. Note that 
instead of actually shifting the multiplicand to the left, we shift the partial product, which 
consists of 2 bytes and is stored in s5 and s6, to the right. 
Listing 15.1 Software integer multiplication 
,___________________------------------------_------------- 
; r o u t i n e  : m u l t - s o f t  
; f u n c t i o n :  8 -  b i t  u n s i g n e d  m u l t i p l i e r  u s i n g  
s h i f t  -and-add 
a l g o r i t h m  
5 ; i n p u t  r e g i s t e r :  
s3: m u l t i p l i c a n d  
s 4 :  m u l t i p l i e r  
s5: u p p e r  b y t e  of 
p r o d u c t  
10 ; 
s 6 :  l o w e r  b y t e  of 
p r o d u c t  
: 
o u t p u t  r e g i s t e r :  
; temp r e g i s t e r :  i 
m u l t - s o f t :  
.______________-_--_-------------------------------------- 
,_______________________________________------_----------- 
load s 5 ,  00 
; c l e a r  s5 

PROGRAM DEVELOPMENT 
351 
15 
load i ,  08 
; i n i t i a l i z e  l o o p  i n d e x  
mult-loop: 
srO s4 
; s h i f t  LSB t o  c a r r p  
jump n c ,  shift-prod 
;LSB i s  0 
add s5, s3 
;LSB i s  1 
20 shif t-prod : 
sra s5 
sra s6 
; s h i f t  u p p e r  b y t e  r i g h t ,  
; c a r r y  t o  MSB, LSB t o  c a r r y  
; s h i f t  l o w e r  b y t e  r i g h t ,  
;LSB of s 5  t o  MSB of s 6  
25 
sub i ,  0 1  
; d e c  l o o p  i n d e x  
jump n z ,  mult-loop 
; r e p e a t  u n t i l  i=O 
return 
Because of the primitive nature of the assembly language, thorough documentation is 
instrumental. A subroutine should include a descriptive header and detailed comments. A 
representative header is shown in Listing 15.1. It consists of a short function description 
and the use of registers. The latter shows how the registers are allocated and is crucial to 
preventing conflict in a large program. 
15.4 PROGRAM DEVELOPMENT 
Developing a complete assembly program consists of the following steps: 
1. Derive the pseudo code of the main program. 
2. Identify tasks in the main program and define them as subroutines. If needed, continue 
3. Determine the register and data RAM use. 
4. Derive assembly code for the subroutines. 
refining the complex subroutines and divide them into smaller routines. 
Steps 1, 2, and 4 basically follow a divide-and-conquer approach and are applicable for 
any software development. A microcontroller-based application is normally for a simple 
embedded system, in which the processor monitors the I/O activities continuously and 
responds accordingly. Its main program usually has the following structure: 
c a l l  initilaization-routine 
c a l l  taskl-routine 
c a l l  task2-rout ine 
c a l l  taskn-rout ine 
jump forever 
forever : 
. . .  
Step 3 is unique for assembly code development. Unlike a high-level language program, 
in which the compiler automatically allocates storage to variables, we must manually man- 
age the data storage in assembly code. PicoBlaze has 16 registers and 64 bytes of data 
RAM to store data. The registers can be considered as fast storage, in which the data can 
be manipulated directly. The data RAM, on the other hand, is “auxiliary” storage. Its data 
needs to be transferred to a register for processing. For example, if we want to increment a 
data item located in the RAM, it must first be loaded into a register, incremented there, and 
then stored back to the RAM. 
Because of the limited space for data storage, its use has to be planned carefully in 
advance, particularly when the code is complex and involves nested subroutines. To assist 

352 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
09 
OA 
00 I lowerbvteof a 
upper byte of a' + b' 
carrv of a' + b' 
01 I unused 
02 1 lowerbvteof b 
03 I unused 
I 
04 
05 
06 
lower byte of b 
Figure 15.1 Data RAM memory allocation. 
coding, we can first identify the needed global storage or local storage. The former keeps 
data that is needed in the entire program. The latter provides space to store intermediate 
results, and the data will be discarded after the required computation is completed. 
15.4.1 Demonstration example 
The development process can best be explained by an example. Let us consider a program 
that uses the previous multiplication subroutine. It reads two inputs, a and b, from the 
switch, calculates a2 + b2, and displays the result on eight discrete LEDs. Since the I/O 
interface is to be discussed in Chapter 16, we limit the I/O to a single input port, the 8-bit 
switch, and a single output port, the 8-bit LEDs. We assume that a and b are obtained 
from the upper nibble (i,e., the four MSBs) and the lower nibble (i.e., the four LSBs) of the 
switch. The main program is 
c a l l  c l e a r -  d a t  a- r am 
c a l l  r e a d - s w i t c h  
c a l l  s q u a r e  
c a l l  w r i t e - l e d  
jump f o r e v e r  
f o r e v e r  : 
The subroutines are defined as follows: 
0 clr-dataaem: clears data memory at system initialization 
0 readswitch: obtains the two nibbles from the switch and stores their values to the 
data RAM 
0 square: uses the multiplication subroutine to calculate a2 + b2 
0 write-led: writes the eight LSBs of the calculated result to the LED port 
For demonstration purposes, we create two smaller routines, get -uppernibble and 
get-lowernibble, within the read-switch routine to obtain the upper nibble and lower 
nibble from a register. 
The next step in development is to plan the register and data RAM use. For global storage, 
we introduce a global register, sw-in, to store the input value of switch and allocate 1 1 bytes 
of data RAM to store the inputs and result of the square routine. Allocation of the data 
RAM is shown in Figure 15.1. Note that the addresses 01 and 03 are not actually used. 
They are reserved to simplify the seven-segment LED display code, which is discussed 
in Chapter 16. All remaining registers are used as local storage. For program clarity, we 

PROGRAM DEVELOPMENT 
353 
define three symbolic names, data, addr, and i, as temporary registers for data, port and 
memory address, and loop index. 
The last step is to derive the assembly code for the subroutines. The complete code is 
shown in Listing 15.2. The clr-dataaem uses a loop to clear data memory. The i register 
is the loop index and initialized with 64 (i.e., 4016). The index is decremented in each loop 
and 0 is loaded to the corresponding data RAM address. The write-led routine fetches 
the eight LSBs of the calculated result from the data RAM and outputs them to the LED 
port. 
The read-switch routine includes two smaller routines. The get-uppernibble rou- 
tine shifts the data register right four times to move the upper nibble to the four LSBs. 
The get-lowenibble routine clears the four MSBs of the data register to 0’s and thus 
removes the upper nibble. The “glue instructions” of read-switch input the switch values, 
set up the input for the two nibble routines, and store the result in the data RAM. 
The square routine fetches data from the data RAM, utilizes the mult-sof t routine to 
calculate u2 and b2, performs addition, and stores the result back to the data RAM. 
Listing 15.2 Square program with simple nibble input 
10 
15 
20 
2s 
30 
35 
; s q u a r e  c i r c u i t  w i t h  s i m p l e  1 / 0  i n t e r f a c e  
; p r o g r a m  o p e r a t i o n  : 
; - read s w i t c h  t o  a ( 4  MSBs) and b ( 4  L S B s )  
; - c a l c u l a t e  a*a + b * b  
; - d i s p l a y  d a t a  on 8 l e d s  
; d a t a  c o n s t a n t  
constant UP-NIBBLE-MASK , OF ; 00001 11 1 
; d a t a  ram a d d r e s s  a l i a s  
constant a - l s b ,  00 
constant b - l s b ,  02 
constant a a - l s b ,  04 
constant aa-msb, 05 
constant b b - l s b ,  06 
constant bb-msb, 07 
constant aabb-lsb , 08 
constant aabb-msb , 09 
constant aabb-cout , OA 
; r e g i s t e r  a l i a s  
; c o m m o n l y  used l o c a l  v a r i a b l e s  
namereg S O ,  d a t a  
; r e g  f o r  t e m p o r a r y  d a t a  
namereg s l ,  addr 
; r e g  f o r  t e m p o r a r y  mem & i / o  p o r t  a d d r  
namereg s 2 ,  i 
; g e n e r a l  - p u r p o s e  
l o o p  i n d e x  
; g l o b a l  v a r i a b l e s  
namereg s f ,  sw-in 

354 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
; p o r t  a l i a s  
40 ,’ 
i n p u t  p o r t  d e f i n i t i o n s  
constant sw-port, 01 ; & b i t  
s w i t c h e s  
o u t p u t  p o r t  d e f i n i t i o n s  
constant led-port , 05 
45 ; 
; main p r o g r a m  
; c a l l i n g  h i e r a r c h y :  
50 ; m a i n  
; - c l r - d a t a - m e m  
- r e a d - s w i t c h  
- g e t  - u p p e r - n  i b b l  e 
- g e t - l o  w e r - n  i b bl e 
- m u l t - s o f t  
5s ; - s q u a r e  
; - w r i t e - l e d  
60 
c a l l  clr-data-mem 
forever : 
c a1 1 
c a l l  square 
c a l l  write-led 
read- sw i t ch 
65 
jump forever 
; r o u t i n e  : c l r - d a t a - m e m  
; f u n c t i o n  : c l e a r  d a t a  ram 
7 0 ;  
temp r e g i s t e r :  d a t a ,  i 
; u n i t i z e  l o o p  i n d e x  t o  64 
clr-data-mem : 
load i ,  40 
load d a t a ,  00 
75 clr-mem-loop: 
s t o r e  d a t a ,  (i) 
sub i ,  0 1  
; d e c  l o o p  i n d e x  
jump n z ,  clr-mem-loop 
; r e p e a t  u n t i l  i=O 
return 
80 
; r o u t i n e  : read s w i t c h  
; f u n c t i o n :  o b t a i n  two n i b b l e s  f r o m  i n p u t  
; i n p u t  r e g i s t e r :  s w - i n  
85 ; temp r e g i s t e r :  d a t a  
read-switch : 
input sw-in, sw-port 
; r e a d  s w i t c h  i n p u t  

PROGRAM DEVELOPMENT 
355 
load d a t a ,  sw-in 
90 
c a l l  get-lower-nibble 
s t o r e  d a t a ,  a-lsb 
; s t o r e  a t o  d a t a  ram 
load d a t a ,  sw-in 
c a l l  get-upper-nibble 
s t o r e  d a t a ,  b-lsb 
; s t o r e  b t o  d a t a  ram 
YS 
; r o u t i n e  : g e t - l o w e r - n i b b l e  
; f u n c t i o n :  g e t  l o w e r  4 b i t s  of 
d a t a  
; i n p u t  r e g i s t e r :  d a t a  
IW ; oiitpur r e g i s t e r  : d a t a  
get-lower-nibble: 
and d a t a ,  UP-NIBBLE-MASK ; c l e a r  u p p e r  n i b b l e  
return 
10s 
; r o u t i n e  : g e t - u p p e r - n i b l e  
; f u n c t i o n :  g e t  u p p e r  4 b i t s  of d a t a  
; i n p u t  r e g i s t e r :  d a t a  
1 1 0  ; o u t p u t  r e g i s t e r :  d a t a  
get-upper-nibble: 
sro data 
sro data 
115 
srO data 
sro data 
return 
; r i g h t  s h i f t  4 t i m e s  
IZO ; r o u t i n e  : w r i t e - l e d  
; f u n c t i o n :  o u t p u t  8 LSBs of 
r e s u l t  t o  8 I e d s  
; 
temp r e g i s t e r :  d a t a  
write-led: 
125 
fetch d a t a ,  aabb-lsb 
output d a t a ,  led-port 
return 
130 ; r o u t i n e  : s q u a r e  
; f u n c t i o n :  c a l c u l a t e  a * a  + b*b 
; temp r e g i s t e r :  s 3 ,  s 4 ,  s 5 ,  s 6 ,  d a t a  
d a t a l r e s u l t  s t o r e d  i n  ram s t a r t e d  w /  SQ-BASEADDR 
1?5 square : 
; c a l c u l a t e  a * a  
fetch s3, a-lsb 
f e t c h  94, a-lsb 
c a l l  mult-soft 
140 
s t o r e  s 6 ,  aa-lsb 
s t o r e  s 5 ,  aa-msb 
; l o a d  a 
; l o a d  a 
; c a l c u l a t e  a*a 
; s t o r e  l o w e r  b y t e  of a*a 
; s t o r e  u p p e r  b y t e  of a*a 

356 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
; c a l c u l a t e  b*b 
fetch  s3, b - l s b  
fetch s 4 ,  b - l s b  
s tore  s 6 ,  b b - l s b  
s tore  s 5 ,  07 
; c a l c u l a t e  a*a+b*b 
fetch d a t a ,  a a - l s b  
s tore  d a t a ,  a a b b - l s b  
fetch  d a t a ,  aa-msb 
addcy d a t a ,  s5 
s tore  d a t a ,  aabb-msb 
addcy d a t a ,  00 
s tore  d a t a ,  a a b b - c o u t  
return 
145 
c a l l  m u l t - s o f t  
150 
add d a t a ,  s6 
155 
load d a t a ,  00 
; l o a d  b 
; l o a d  b 
; c a l c u l a t e  b * b  
; s t o r e  l o w e r  b y t e  of 
b*b 
; s t o r e  u p p e r  b y t e  of 
b * b  
; g e t  l o w e r  b y t e  of a*a 
; a d d  l o w e r  b y t e  of 
a*a+b*b 
; s t o r e  l o w e r  b y t e  of 
a*a+b*b 
; g e t  u p p e r  b y t e  of 
a*a 
; a d d  u p p e r  b y t e  of 
a*a+b*b 
; s t o r e  u p p e r  b y t e  of 
a*a+b*b 
; c l e a r  d a t a ,  b u t  k e e p  c a r r y  
; g e t  c u r r y - o u t  f r o m  p r e v i o u s  + 
; s t o r e  c a r r y - o u t  
of a*a+b*b 
,M) ,.--------------------------------------------------------- 
......................................................... 
; r o u t i n e  : m u l t - s o f t  
: f u n c t i o n :  8 -  b i t  u n s i g n e d  m u l t i p l i e r  u s i n g  
; i n p u t  r e g i s t e r :  
s h i f t  -and-add 
a 1 g o  r i  t h  m 
165 ,' 
s3: m u l t i p l i c a n d  
s 4 :  m u l d i p l i e r  
s5: u p p e r  b y t e  of 
p r o d u c t  
s 6 :  l o w e r  b y t e  of 
p r o d u c t  
; 
o u t p u t  r e g i s t e r :  
170 ; temp r e g i s t e r :  i 
,____-_-_____--_____-------------------------------------- 
m u l t - s o f t :  
load s 5 ,  00 
; c l e a r  s5 
load i ,  08 
; i n i t i a l i z e  l o o p  i n d e x  
srO 
s4 
; s h i f t  l s b  t o  c a r r y  
jump n c ,  s h i f t - p r o d  
; l s b  i s  0 
add s 5 ,  s3 
; l s b  i s  1 
175 m u l t - l o o p :  
s h i f t - p r o d :  
180 
s r a s 5  
sra s6 
; s h i f t  u p p e r  b y t e  r i g h t ,  
; c a r r y  t o  MSB, LSB t o  c a r r y  
; s h i f t  l o w e r  b y t e  r i g h t ,  
; l s b  of 
s 5  t o  MSB of 
s6 
sub i ,  01 
; d e c  l o o p  i n d e x  
return 
185 
jump n z ,  m u l t - l o o p  
; r e p e a t  u n t i l  i=O 
15.4.2 Program documentation 
Developing an assembly program is a tedious process. The use of symbolic names and good 
documentation can make the code clear and reduce many unnecessary errors. It also helps 
future revision and maintenance. For the KCPSM3 assembler. we can use the constant 

PROGRAM DEVELOPMENT 
357 
directive to assign a symbolic name (alias) to a data constant, a memory address, or a port 
id, and use the namereg directive to assign a symbolic name to a register. 
A representative main program header is shown in Listing 15.2. It contains the following 
segments : 
General program description: provides a general description for the purpose, oper- 
0 Data constants: declares symbolic names for constants 
0 Data RAM address alias: declares symbolic names for data RAM addresses 
0 Register alias: declares symbolic names for registers 
0 Port alias: declares symbolic names for I/O ports 
0 Program calling hierarchy: illustrates the calling structure and subroutines 
ation, and I/O of the program 
The aliases and directives have no effect on the final machine code. When the assembly 
code is processed, they are replaced with the actual constant values. However, using aliases 
can greatly enhance the readability of the assembly code and reduce unnecessary errors. 
The following code segment further illustrates the impact of the alias and documentation. 
The purpose of this segment is to obtain values for variables a, b, and c, and store them 
in proper data RAM locations. The location is specified by the UART input, which is the 
ASCII code of character a, b, or c. The segment with aliases and proper comments is 
; c o n s t a n t  a l i a s  
constant ASCII-a, 61 
constant ASCII-b, 6 2  
constant ASCII-c , 6 3  
; d a t a  ram a d d r e s s  a l i a s  
constant a-addr, 0 2  
constant b-addr, 04 
constant c-addr, 06 
namereg S O ,  data 
namereg sl , addr 
namereg s F ,  sw-in 
constant sw-port , 01 
constant uart-rx-port , 02 
; r e g i s t e r  a l i a s  
; p o r t  a l i a s  
; a s s e m b l y  code w i t h  a l i a s  
; g e t  i n p u t  
input sw-in, sw-port 
input data, uart-rx-port 
; c h e c k  r e c e i v e d  c h a r  
compare data, ASCII-a 
jump n z ,  chk-ascii-b 
store 
sw-in, a-addr 
jump done 
chk-ascii-b : 
compare data, ASCII-b 
jump n z ,  chk-ascii-c 
s t o r e  sw-in, b-addr 
jump done 
chk-ascii-c: 
compare data, ASCII-c 
jump n z ,  ascii-err 
; A S C I I  code f o r  a 
; A S C I I  code f o r  b 
; A S C I I  code f o r  c 
; r e g  f o r  t e m p o r a r y  d a t a  
; r e g  f o r  t e m p o r a r y  addr 
; s w i t c h  i n p u t  
; s w i t c h  i n p u t  
; 
UART i n p  u t 
; g e t  s w i t c h  
; g e t  c h a r  
; c h e c k  ASCII a 
; n o ,  c h e c k  n e x t  
; y e s ,  s t o r e  a t o  d a t a  ram 
; c h e c k  ASCII b 
,'no, c h e c k  n e x t  
: y e s ,  s t o r e  b t o  d a t a  ram 
; c h e c k  A S C I I  c 
; n o ,  e r r o r  

358 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
Store sw-in, c-addr 
jump done 
ascii-err: 
; y e s ,  s t o r e  b to data ram 
done : 
. . .  
If we use hard literals and strip the comments, the code becomes 
; a s s e m b l y  code with no a l i a s  or comments 
input s f ,  0 1  
input s o ,  02 
compare S O ,  61 
jump nz , addrl 
store sf, 0 2  
jump addr4 
compare S O ,  6 2  
jump n z ,  addr2 
s t o r e  sf, 04 
jump addr4 
compare S O ,  6 3  
jump n z ,  addr3 
s t o r e  s f ,  06 
jump addr4 
addrl : 
addr2 : 
addr3 : 
addr4 : 
. . .  
. . .  
While the functionality of this code segment is the same, it is very difficult to comprehend, 
debug, or modify. 
15.5 PROCESSING OF THE ASSEMBLY CODE 
PicoBlaze-based development flow is reviewed in Section 14.4. After the assembly code is 
developed, it is then compiled (translated) to machine instruction in step 3. The instruction- 
set-level simulation can also be performed to verify the correctness of the code, as in step 4. 
The two steps and the direct downloading process (step 9) are discussed in detail in this 
section. 
Xilinx provides an assembler known as KCPSM3 for compiling in step 3 and download- 
ing utility programs in step 9. The programs, HDL codes for the PicoBlaze processor, and 
relevant template files can be downloaded from the Xilinx’s web site. A program known as 
PBlazeZDE from Mediatronix can perform the instruction-set-level simulation in step 4. It 
can also be used as an assembler. PBlazeIDE can be downloaded from Mediatronix’s Web 
site. 
15.5.1 Compiling with KCSPMB 
Assembler is the software that translates the instruction mnemonics to machine instructions, 
which are represented as 0’s and l’s, and substitutes the aliases and symbolic branch ad- 
dresses with actual values. The machine instructions are then downloaded to the instruction 

PROCESSING OF THE ASSEMBLY CODE 
359 
memory of a microcontroller. Since PicoBlaze is embedded inside FPGA, the instruction 
ROM becomes an HDL ROM module with the compiled assembly code. The ROM will be 
instantiated later in the top-level HDL code and synthesized along with PicoBlaze and the 
I/O interface circuit. 
Xilinx provides the KCPSM3 assembler for this task. It is a command-line, DOS-based 
program. KCPSM3 basically takes an assembly program, along with the necessary template 
files, and generates the HDL code for the instruction ROM. The procedure of compiling an 
assembly program is as follows: 
1. Create a directory for the project and copy kcpsm3.exe, R O M 4  orm.vhd, R O M 4  orm.v, 
and ROM-form.coe to the directory. The latter three are code templates used by 
KCPSM3. 
2. Create the assembly program and save it as plain text file with an extension of .psm. 
Any PC-based editor, such as Notepad, can be used for this purpose. 
3. Invoke a DOS window by selecting Start + Programs + Accessories + Command 
Prompt. In the DOS window, navigate to the project directory. 
4. Type kcpsm3 myf ile.psm to run the program. 
5. Correct syntax errors if necessary and recompile. 
6. After successful compiling, the file containing the instruction ROM, myf ile.vhd, is 
In addition to the HDL file, KCPSM3 also generates files that are suitable for block RAM 
initialization and other utilities. The file with the .hex extension can be used for JTAG 
downloading, which is discussed in Section 15.5.3, and the file with the .fmt extension is 
a reformatted .psm file for “pretty printing.” 
generated. 
15.5.2 Simulation by PBlazelDE 
As the name indicates, instruction-set-level simulation simulates the operation of a Pi- 
coBlaze system instruction by instruction. The PBlazeZDE program can be used for this 
purpose. PBlazeIDE is a Windows-based program with an integrated development envi- 
ronment, which includes a text editor, an assembler, and an instruction-set-level simulator. 
PBlazeIDE uses slightly different instruction mnemonics and directives, as discussed in 
Section 14.5. Thus, the code written for by KCPSM3 cannot be used directly by PBlazeIDE, 
and vice versa. The mnemonic differences are summarized in Table 15.1, and the directive 
examples are shown in Table 15.2. Note that the PBlazeIDE assembler uses both decimal 
and hexadecimal format for constants. A hexadecimal number is started with a $ sign, as 
in $1A. 
The procedure of using PBlazeIDE for KCPSM3 code is as follows: 
1. Compile the assembly code with KCPSM3. 
2. Launch PBlazeIDE. 
3. Select Settings + PicoBlaze 3. This specifies the version 3 of PicoBlaze, which is 
used in the Spartan-3 device. 
4. Select File + Import and a dialog window appears. Select the corresponding . f m t  
file. The “import” function converts the KCPSM3 code to the PBlazeIDE code. The 
formatted program is easier for conversion. The converted file may sometimes need 
minor manual editing. 
5. Manually specify the dsin, dsout, and dsio directives for I/O ports. When one of 
these directives is used, a port indicator will be added to the simulation screen to 
show the activities of the port. 

360 
6. 
7. 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
Table 15.1 Mnemonic differences between KCPSM3 and PBlazeIDE 
KCPSM3 
PBlazeIDE 
addcy 
subcy 
compare 
store sX, (sY) 
fetch s X ,  (sY) 
input sX, (sY> 
input s X ,  KK 
output sX, KK 
return 
returni 
enable interrupt 
disable interrupt 
output sx, (SY) 
addc 
subc 
comp 
store sX, sY 
fetch sX, sY 
in sX, SY 
in sX, $KK 
out sx, SY 
out sX, $KK 
ret 
reti 
eint 
dint 
Table 15.2 Directive examples of KCPSM3 and PBlazeIDE 
Function 
KCPSM3 
PBlazeIDE 
code location 
address 3FF 
org $3FF 
constant 
constant MAX, 3F 
MAX equ $3F 
register alias 
namereg addr, s2 
addr equ s2 
port alias 
constant in-port, 00 
in-port dsin $00 
out-port dsout $10 
bi-port dsio $OF 
constant out-port, I0 
constant bi-port, OF 
Enter the simulation mode by selecting Simulate + Simulate. Perform simulation. 
If the assembly code needs to be revised, it must be done outside PBlazeIDE. Simply 
close the current file, invoke an external editor to edit the original .psm file, save 
the file, and restart from step 1. If the file is edited within PBlazeIDE, it cannot be 
converted back to KCPSM3 code. 
A representative simulation screenshot is shown in Figure 15.2. The simulator displays 
the assembly code in the central window and highlights the next instruction to be executed. 
The instruction address, instruction code, and breakpoints are shown next to the code. The 
current state of PicoBlaze is shown at the left, which includes the status of the flags, the 
content of the registers, and the content of the data RAM. The values of the program counter 
and stack pointer as well as some execution statistics are shown in the bottom row. 
The emulated I/O ports created by the dsin, dsout, and dsio directives are shown at the 
right. There are an input port, switch, and an output port, led, on this particular screen. 
Since PBlazeIDE has no information about I/O behavior, the input port data must be entered 
and modified manually during simulation. 
During simulation, the assembly program can be executed continuously, by one step, by 
one instruction, or to pause at a specific breakpoint. The simulation action is controlled by 
the commands of the Simulate menu or the icons on the top: 

PROCESSING OF THE ASSEMBLY CODE 
361 
Figure 15.2 Screenshot of pBlazeIDE in simulation mode. 

362 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
0 Reset: clears the program counter and stack pointer 
0 Run: runs the program continuously until a breakpoint 
0 Single step: executes one instruction 
0 Step over: executes the entire subroutine for a call instruction and executes one 
0 Run to cursor: runs the program to the current cursor position 
0 Pause: pauses the simulation 
0 Toggle breakpoint: sets or clears a breakpoint at the current cursor position 
Remove all breakpoints: clears all breakpoints 
instruction for other instructions 
15.5.3 Reloading code via the JTAG port 
After the instruction ROM HDL is generated, we can continue steps 6 and 8 in Figure 14.4 
to synthesize the entire code and download the configuration file to the FPGA chips. Note 
that the synthesis flow must be repeated each time the assembly code is modified. 
Since synthesis is a complex process, it requires a significant amount of computation time. 
When the I/O configuration is fixed, resynthesizing the entire circuit after each assembly 
program modification is not really needed. It is possible to reload the machine code to the 
ROM, which is implemented by a block RAM, by using the FPGA's JTAG interface. This 
corresponds to the dotted line of step 9 in Figure 14.4. The basic procedure is as follows: 
1. Replace the original ROM template with one that contains the JTAG interface circuit. 
2. Use KCPSM3 to compile the assembly code as usual. 
3. Synthesize the top-level HDL code and program the FPGA chip. 
4. In subsequent assembly program modifications, compile the program as usual. Recall 
5. Use the Xilinx utility to embed the . hex file to a JTAG programming file and download 
The detailed procedure and the relevant programs and templates can be found in the 
JTAG-loader directory of the downloaded KCPSM file. 
that a file in hex format (ended with the .hex extension) is generated. 
the file to the FPGA's block RAM via the JTAG interface. 
15.5.4 Compiling by PBlazelDE 
As discussed earlier, PBlazeIDE is an integrated program that contains an assembler and 
editor. If the program is developed with PBlazeIDE mnemonics, PBlazeIDE can replace 
the KCPSM3 assembler. The instruction ROM VHDL file is generated by a directive. If 
the HDL file is needed, simply include the vhdl directive in the assembly code. Its syntax 
is 
vhdl "ROM-form.vhd", " r o m - t a r g e t  . vhd" , "rom-entity-name" 
The "ROM-f orm. vhd" term specifies a VHDL template file, which is the same file as 
that discussed in Section 15.5.1. It should be copied to the directory where the assembly 
program file resides. The "rom-target.vhd" term specifies the name of the generated 
ROM VHDL file, and the "rom-entityname" term indicates the desired entity name 
of the previously generated VHDL file. The VHDL file is generated automatically when 
PBlazeIDE is switched from the edit mode to the simulation mode. 
Note that since PBlazeIDE does not generate a hex file, the reloading scheme discussed 
in Section 15.5.3 cannot be applied directly. 

SYNTHESES WITH PICOBLAZE 
363 
Figure 15.3 PicoBlaze with a simple IiO interface. 
15.6 SYNTHESES WITH PICOBLAZE 
After generating the HDL file for the instruction ROM, we can combine it with PicoBlaze to 
synthesize the entire system in an FPGA chip. Unlike a normal microcontroller, PicoBlaze 
has no built-in I/O peripherals. The I/O interface is created and customized as needed. 
The circuit is described in HDL code. Since the focus in this chapter is assembly program 
development, we use a simple 1/0 configuration, which contains only one switch input port 
and one led output port, for synthesis. The development of more sophisticated I/O interface 
is discussed in detail in Chapters 16 and 17. 
The top-level block diagram of this design is shown in Figure 15.3. It contains the 
PicoBlaze processor, which is labeled kcpsm3, the instruction ROM, and a register. The 
register functions as a buffer for the eight LEDs. When PicoBlaze executes the output 
instruction, it places the data on out-port and asserts the write-strobe signal, which 
enables the register and stores the data in the register. The sw signal is connected to in-port. 
When PicoBlaze executes the input instruction, it retrieves the value of the sw signal and 
stores it in an internal register. The corresponding HDL code is shown in Listing 15.3. It 
consists of instantiations of the PicoBlaze processor and instruction ROM, and a segment 
for the output buffer. The kcpsm3 entity is the name of the PicoBlaze processor, and its 
code is stored in an HDL file of the same name. The sio-rom entity is from the previously 
generated instruction ROM file. 
Listing 15.3 PicoBlaze with a simple I/O configuration 
lib rary  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  pico-sio i s  
5 
p o r t (  
clk, reset: in std-logic; 
s w :  in std-logic-vector ( 7  downto 0) ; 
led: out std-logic-vector (7 downto 0) 
) ;  
10 end pico-sio ; 
a r c h i t e c t u r e  a r c h  of pico-sio is 
-- KCPSM3/ROM s i g n a Is 
s i g n a l  address : std-logic-vector (9 downto 0 )  ; 
15 
s i g n a l  instruction: std-logic-vector (17 downto 0) ; 
s i g n a l  port-id: std-logic-vector (7 downto 0) ; 

364 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
signal in-port , out-port : std-logic-vector ( 7  downto 0 )  ; 
signal write-strobe : std-logic; 
__ r e g i s t e r  s i g n a l s  
20 
signal led-reg : std-logic-vector (7 downto 0) ; 
30 
begin 
_- 
__ 
KCFSM and ROM i n s t a n t i a t i o n  
proc-unit : entity work. kcpsm3 
clk=>clk, reset=>reset , 
address=>address , instruction=>instruction, 
port-id=>open, write-strobe=>write-strobe, 
out-port=>out-port , read-strobe=>open, 
in-port=>in-port , interrupt=>’O’, 
interrupt-ack=>open); 
25 
-- 
port map( 
rom-unit : entity work. sio-rom 
35 
port map( 
clk => clk, address=>address , 
instruction=>instruction); 
__ 
__ 
o u t p u t  i n t e r f a c e  
-- o u t p  u t 
process (clk) 
begin 
40 
-- 
r e g i s t e r 
if (clk ’ event and clk= ’ 1 ’ 
then 
led-reg <= out-port ; 
45 
if write-strobe=’l’ then 
end if ; 
end if ; 
end process; 
50 
led <= led-reg; 
__ 
i n p u t  i n t e r f a c e  
in-port <= sw; 
__ 
55 end arch; 
15.7 BIBLIOGRAPHIC NOTES 
The bibliographic information for this chapter is similar to that for Chapter 14. The pro- 
cedure of reloading compiled code via JTAG port is explained in the article, “PicoBlaze 
JTAG Loader Quick User Guide,” by Kris Chaplin and Ken Chapman, which appears in the 
JTAG-loader directory of the downloaded KCPSM file. 

SUGGESTED EXPERIMENTS 
365 
15.8 SUGGESTED EXPERIMENTS 
15.8.1 Signed multiplication 
The subroutine in Listing 15.1 assumes that the inputs are in unsigned integer format. 
Modify the subroutine to perform the signed multiplication, in which the two inputs and 
output are interpreted as signed integers, and use simulation to verify its operation. 
15.8.2 Multi-byte multiplication 
The subroutine in Listing 15.1 assumes that the inputs are 8 bits wide. Some application 
may need more precision and we want to extend the subroutine to take 16-bit unsigned 
inputs. An operand now requires two registers and the result needs four registers. Develop 
the subroutine and use simulation to verify its operation. 
15.8.3 Barrel shift function 
PicoBlaze can only shift or rotate a single bit. A “barrel” shifting function can perform 
the shift and rotate operation for multiple bits. This function has three input registers. The 
first register contains data to be shifted or rotated; the second register specifies the amount, 
which is between 0 and 7; and the third register indicates the types of operation, which can 
be shift left, shift right, rotate left, or rotate right. We assume that 0 will be shifted in for 
the two shift operations. Develop the subroutine and use simulation to verify its operation. 
15.8.4 Reverse function 
A reverse function reverses the bit order of an input. For example, if the input is ”0101001 l ” ,  
the output becomes “1 1001010”. We can use the 8-bit switch as input and the 8-bit discrete 
LEDs as output. Derive and simulate the assembly code, obtain the instruction ROM and 
create the top-level HDL code, synthesize the system, and verify its operation. 
15.8.5 Binary-to-BCD conversion 
Binary-to-BCD conversion is discussed in Section 6.3.3. This function can be implemented 
by using assembly code as well. Assume that the input is an 8-bit binary number and the 
output is a two-digit 8-bit BCD number. If the input exceeds 99, the output generates a 
special overflow pattern, “1 11 11 11 1”. We can use the 8-bit switch as input and the 8-bit 
discrete LEDs as output. Derive and simulate the assembly code, obtain the instruction 
ROM and create the top-level HDL code, synthesize the system, and verify its operation. 
15.8.6 BCD-to-binary conversion 
Repeat Experiment 15.8.5, but develop the assembly code and circuit for BCD-to-binary 
conversion. 
15.8.7 Heartbeat circuit 
A “heartbeat circuit” is discussed in Experiment 4.7.4. We can create a similar pattern 
using the eight discrete LEDs as well. Derive and simulate the assembly code, obtain the 

366 
PICOBLAZE ASSEMBLY CODE DEVELOPMENT 
instruction ROM and create the top-level HDL code, synthesize the system, and verify its 
operation. 
15.8.8 Rotating LED circuit 
We want to design a circuit that rotates a simple LED pattern to the left or right at four differ- 
ent speeds. The four patterns are "00000001", "00000011", "00001111", and "00001101". 
The pattern, direction, and rotation speed can be selected from the 8-bit switch (only 5 bits 
are used). The speed should be properly chosen so that all four patterns are visually ob- 
servable. Derive and simulate the assembly code, obtain the instruction ROM and create 
the top-level HDL code, synthesize the system, and verify its operation. 
15.8.9 Discrete LED dimmer 
The concept of PWM and LED dimmer are discussed in Experiment 4.7.2. In this exper- 
iment, we want to use eight discrete LEDS to show the various degrees of the brightness. 
This can be done by changing the "on" fraction of an LED. The "on" fraction of the eight 
LEDS will be :, g, :, . . . i. 
Derive and simulate the assembly code, obtain the instruction 
ROM and create the top-level HDL code, synthesize the system, and verify its operation. 

CHAPTER 16 
PICOBLAZE I/O INTERFACE 
16.1 INTRODUCTION 
To interact with the external environment, a regular microcontroller chip consists of a 
variety of built-in I/O peripherals, such as a UART, SPI (serial peripheral interface), timer, 
etc. When starting a new development, we select a microcontroller chip according to the 
I/O requirements of the application and may sometimes need to use additional chips to 
realize less commonly used functions. 
Unlike a regular microcontroller, PicoBlaze has no built-in I/O peripherals. It just pro- 
vides a simple generic input and output structure for an I/O interface. I/O peripherals are 
constructed as needed and thus are customized to each application. PicoBlaze uses the 
input and output instructions to transfer data between its internal registers and I/O ports, 
and its interface consists of the following signals: 
0 port-id: an 8-bit signal that specifies the port id (i.e., port address) of an input or 
0 in-port: an 8-bit signal where PicoBlaze obtains input data during operation of an 
0 out-port: an 8-bit signal where PicoBlaze places output data during operation of 
0 readstrobe: a 1-bit signal that is asserted in the second clock cycle of an input 
0 writestrobe: a 1-bit signal that is asserted in the second clock cycle of an output 
output instruction 
input instruction 
an output instruction 
instruction 
instruction 
FPGA Protogping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
367 

368 
PICOBLAZE 110 INTERFACE 
Figure 16.1 Timing diagram of an output instruction. 
Although there are only two 8-bit ports to input and output data, the 8-bit port-id signal 
can be used to distinguish different peripherals, and thus it is said that PicoBlaze can support 
up to 2.56 (i.e., 28) input ports and 256 output ports. 
In the remaining chapter, we examine the detailed IiO timing of PicoBlaze and illustrate 
the I/O interface development by adding a series of peripherals for the square circuit of 
Chapter 15. 
16.2 OUTPUT PORT 
16.2.1 Output instruction and timing 
The output instruction writes data to the output port. It has two forms: 
output sx, (SY) 
output s X ,  port-name 
In the first form, the port id is stored in the SY register. In the second form, the port id is 
specified explicitly by port name, which is a two-digit hexadecimal number or a previously 
defined symbolic constant. The output data is always stored in the sX register. 
The timing diagram of an output instruction, 
output s o ,  0 2  
is shown in the top five traces of Figure 16.1. Recall that each PicoBlaze instruction takes 
two clock cycles. When the instruction is executed, the content of SO is placed on out-port 
and 02 is placed on port-id for two clock cycles. The write-strobe signal is asserted 
in the second clock cycle. It can be used as an enable tick to store data in an output register 
or to initiate the designated peripheral operation. 

OUTPUT PORT 
369 
Figure 16.2 Output decoding of four output registers. 
Truth table of a decoding circuit 
Table 16.1 
input 
output 
write-strobe 
port -id (1) port-id( 0) 
en-d 
- 
- 
0000 
0 
0 
000 1 
0 
1 
0010 
1 
0 
0100 
1 
1 
1000 
16.2.2 Output interface 
The output interface between PicoBlaze and an output peripheral usually consists of a 
decoding circuit and necessary output buffers, which are normally an array of registers. 
The decoding circuit decodes the port id and generates an enable tick accordingly. After 
the output instruction, the data will be stored in the designated buffer. 
To illustrate the construction, let us consider a PicoBlaze interface with four output 
buffers. We assign 0016, OIl6, 0216, and 0316 as their port ids. Note that the six MSBs of 
the port addresses are identical and only two LSBs are needed to distinguish a port. The 
block diagram is shown in Figure 16.2. The key is the decoding circuit, whose function 
table is shown in Table 16.1. It is a 2-t0-2~ decoder. In the second clock cycle of an 
output instruction, write-strobe is asserted and 1 bit of the 4-bit en-d signal is asserted 
accordingly. The one-clock-cycle enable tick activates the corresponding output register to 
retrieve data from the out-port signal. The decoding timing diagram of the instruction 
output s o ,  02 

370 
PICOBLAZE 110 INTERFACE 
is shown at the bottom of Figure 16.1. During the second clock cycle of the output 
instruction, the en-d(2) signal is asserted and the data value on out-port is stored in the 
corresponding buffer at the rising edge of the next clock. 
Once understanding the basic operation, we can derive the HDL code accordingly. The 
code segment is 
process (write-strobe , port-id) 
begin 
i f  write-strobe= ' 0 '  then 
e l s e  
en-d <= "0000"; 
case port-id(1 downto 0 )  i s  
en-d <= " 0 0 0 1 " ;  
en-d <= " 0 0 1 0 " ;  
en-d <= " 0 1 0 0 " ;  
en-d <= " 1 0 0 0 " ;  
when " 0 0 "  => 
when " 0 1 "  => 
when 1'1011 
=> 
when others = >  
end c a s e ;  
end i f ;  
end p r o c e s s ;  
This scheme is very general and can be applied to any number of output ports. 
The choice of the port address is somewhat arbitrary. We use the binary code in the 
previous example. If the number of the output port is smaller than eight, one-hot code can 
be used to simplify the decoding circuit. For example, we can define the four previous port 
ids as Oi16 (i.e., 000000012), 0216 (i.e., 000000102), 0416 (i.e., 000001002), and ( 1 8 ~ 6  (i.e., 
000010002). The decoding logic can be simplified to 
process (write-strobe , port-id) 
begin 
i f  write_strobe='O' then 
e l s e  
end i f ;  
end p r o c e s s ;  
en-d <= "0000"; 
en-d <= port-id(3 downto 0); 
Note that no decoding logic is needed if there is only a single output port. The write-strobe 
signal can be connected to the register's enable signal, as shown in Figure 15.3. 
As discussed in Section 15.4.2, it is good practice to use symbolic aliases for I/O ports 
and declare its binary address in the header. For example, the initial output port address 
assignment can be declared as 
o u t p u t  p o r t  d e f i n i t i o n s  
constant out-port-a , 00 
constant out-port-b , 0 1  
constant out-port-c , 02 
constant out-port-d, 04 
If the assignment is changed, we need to modify the header but keep the remaining assembly 
code intact. Using a clear header also allows us easily to identify the port ids when the 
companion HDL code is developed. 

INPUT PORT 
371 
Figure 16.3 Timing diagram of an input instruction. 
16.3 INPUT PORT 
16.3.1 Input instruction and timing 
The input instruction reads data from the input port. Similar to the output instruction, it 
has two forms: 
input s X ,  (sY) 
input s X ,  port-name 
The SY register or portname specifies the read port id. The retrieved data is stored in the 
SX register. 
The timing diagram of an input instruction, 
input S O ,  0 2  
is shown in Figure 16.3. When the instruction is executed, 02 is placed on port-id. After 
two clock cycles, in-port will be sampled at the rising edge of the clock and its value is 
stored in the SO register. The external circuit must ensure that the input data is stable during 
the sampling edge to avoid timing violation. 
As in the output instruction, the read-strobe signal is asserted in the second clock 
cycle. The function of the r e a d s t r o b e  signal is less obvious and is discussed in the next 
subsection. 
16.3.2 Input interface 
The input interface between PicoBlaze and input peripherals usually consists of a multi- 
plexing circuit, which uses port-id as the selection signal to route the desired value to 
in-port. Sometimes, a decoding circuit similar to the one in the output interface is also 
necessary to signal the completion of the data access. 
For the purpose of input interface design, an input port can be classified as a continuous- 
access or single-access port. For a continuous-access port, the data is presented continu- 
ously, such as the switch input of Section 15.4.1. On the other hand, the availability of data 
of a single-access port is triggered by a single discrete event, such as receiving a character 
in an UART buffer. The flag FF and buffers discussed in Section 7.2.4 are in this category. 
After the data is retrieved, we must remove it from the buffer to prevent the same data from 

372 
PICOBLAZE 110 INTERFACE 
Figure 16.4 Block diagram of four continuous-access ports. 
Figure 16.5 Block diagram of four single-access ports. 
being processed again. This is usually done by utilizing a one-clock-cycle tick to clear the 
flag FF or remove a word from a FIFO buffer. 
The interface for continuous-access ports involves only a multiplexing circuit. Consider 
an interface with four such ports. The block diagram is shown in Figure 16.4. 
The interface for single-access ports needs a mechanism to remove the retrieved data from 
the buffer in the end of an input instruction. This can be done by using a decoding circuit 
that decodes the port-id and read-strobe signals. The circuit is identical to the decoding 
circuit of the output interface except that write-strobe is replaced by readstrobe. The 
decoded output can be considered as a “removal” signal, which is asserted for one clock 
cycle and removes the previously retrieved data. Consider an interface with four FIFOs. 
The diagram of the complete decoding and multiplexing circuit is shown in Figure 16.5. 
The rv signal is the decoded removal signal. In the end of an input instruction, 1 bit of this 
4-bit signal is asserted and the corresponding FIFO performs a read operation, in which the 

SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED DISPLAY INTERFACE 
373 
first word is removed from the buffer. Assume that 0016, Oi16, 0216, and 0316 are assigned 
as the port ids. The HDL code segment for the interface is 
__ rn u l t i p l e x i n g  c i r c u i t  
with port-id(l downto 0) s e l e c t  
data <= in-data0 when " O O " ,  
in-data1 when " 0 1 "  , 
in-data2 when " l o " ,  
in-data3 when others ; 
__ d e c o d i n g  c i r c u i t  
process(reade-strobe,port-id) 
begin 
i f  read-strobe='O' then 
e l s e  
rv <= " 0 0 0 0 " ;  
case port-id(1 downto 0 )  i s  
when 
If 00 'I = > 
when "01" => 
when " 1 0 "  => 
when others => 
rv <= " 0 0 0 1 " ;  
rv <= "0010"; 
rv <= "0100"; 
rv <= "1000"; 
end c a s e ;  
end i f  ; 
end p r o c e s s ;  
In a real application, it is likely that the input interface contains both continuous- and 
single-access ports. A decoding circuit is only needed for single-access ports. 
16.4 SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED 
DISPLAY INTERFACE 
To demonstrate the construction of the PicoBlaze I/O interface, we add more versatile input 
and output peripherals to the square routine of Chapter 15. Recall that the square routine 
calculates a2 + b2, where a and b are 8-bit unsigned integers. 
We use the 8-bit switch and a pushbutton to enter the values of a and b. The pushbutton 
generates a one-clock-cycle tick when pressed. The tick indicates that the current value 
of the switch should be loaded. The values of a and b are loaded alternately; i.e., the first 
pressing loads a, the second pressing loads b, the third pushing loads a, and so on. A second 
pushbutton is also included to clear the PicoBlaze's data RAM and relevant registers. 
We use four seven-segment LEDs to display the inputs and computed results. The LEDs 
are arranged as four hexadecimal numbers. Since the range of a2 + b2 is up to 17 bits, the 
decimal point of the leftmost LED is used for the MSB. The three lower bits of the switch 
select what to display, which can be a, b, a', b2, or a2 + b2. 
In summary, the interface consists of the following: 
Switch: provides the values of a and b and selects the content of the LED display 
Pushbutton 0: loads the a and b alternatively when pressed 
Pushbutton I :  clears data RAM and relevant registers when pressed 
Seven-segment LED: displays the selected 17-bit value in four hexadecimal digits 

374 
PICOBLAZE 110 INTERFACE 
Figure 16.6 Output interface of a square circuit. 
16.4.1 
Output interface 
Recall that the four seven-segment LEDs on the prototyping board share the same input pins, 
and a time-multiplexing circuit is required. For a PicoBlaze-based design, the multiplexing 
can be done by either an external circuit or a software routine. We use the external-circuit 
approach, which is simpler for assembly code development, in this section and discuss 
the software approach in Chapter 17. The LED time-multiplexing circuit designed in 
Section 4.5.1 can be used for this purpose. This circuit shields the timing and appears 
as four independent seven-segment LEDs for external system. The block diagram of the 
PicoBlaze output interface is shown in Figure 16.6. The interface consists of four 8-bit 
output ports, each port representing a seven-segment LED pattern. 
In the assembly code, the four LED patterns are stored in PicoBlaze’s data RAM with 
symbolic addresses of ledO, ledl, led2, and led3. The corresponding code segment is 
. . .  
; d a t a  RAM a d d r e s s  a l i a s  
constant l e d O ,  10 
constant l e d l ,  11 
constant l e d 2 ,  12 
constant l e d 3 ,  13 
; o u t p u t  p o r t  d e f i n i t i o n s  
constant sseg0-port , 00 
; 7 - s e g  
l e d  0 
constant ssegl-port , 01 
; 7 - s e g  
l e d  1 
constant sseg2-port , 02 
;7-seg 
l e d  2 
constant s s e g 3 _ p o r t ,  0 3  
; 7 - s e g  
l e d  3 
disp-led: 
. . .  
. . .  
f e t c h  d a t a ,  led0 
output data, sseg0-port 

SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED DISPLAY INTERFACE 
375 
Figure 16.7 Input interface of a square circuit. 
f e t c h  d a t a ,  l e d 1  
output d a t a ,  s s e g l - p o r t  
f e t c h  d a t a ,  l e d 2  
output d a t a ,  s s e g 2 - p o r t  
f e t c h  d a t a ,  l e d 3  
output d a t a ,  s s e g 3 - p o r t  
return 
16.4.2 Input interface 
The input interface consists of an 8-bit switch and two 1-bit pushbuttons. The former is a 
continuous-access port since the value is always present. The latter is a single-access port 
since pressing a button leads to only a single event (e.g., loading a to the register once rather 
than continuously). Because of the mechanical glitches, a debouncing circuit is needed to 
generate a clean one-clock-cycle tick. Since PicoBlaze’s port can take up 8-bit data, inputs 
from the two pushbuttons can be grouped together as a single input port. The block diagram 
of the input interface is shown in Figure 16.7. The interface consists of two debouncing 
circuits, a two-to-one multiplexer, a decoding circuit, and two flag FFs. The function of 
the two flag FFs is discussed in Section 7.2.4. They provide a mechanism to set and clear 
the “button-pressing event.” When a button is pressed, the debouncing circuit’s output sets 
the flag. It remains asserted until it is retrieved by the PicoBlaze’s input instruction, which 
sets the selection signal of the multiplexer to route the desired value to PicoBlaze’s input 
port, and activates the clear signal. For clarity, we name the pushbutton 1 as the s button 
(for setting the value) and pushbutton 0 as the c button (for clearing the data RAM). 
The pseudo code to process the input is 
; i n p u t  t h e  b u t t o n  f l a g s  
; i f  c = l  t h e n  

376 
PICOBLAZE 110 INTERFACE 
; c a l l  t h e  c l e a r i n g - r a m  
r o u t i n e  
; i f  s = l  t h e n  
; i n p u t  s w i t c h  v a l u e  
; s t o r e  i t  t o  d a t a  ram 
; t o g g l e  a / b  a d d r e s s  o f f s e t  
Since the s button inputs the values of a and b alternately, we use a global register, 
switch-a-b, to keep track of which one is being read currently. The register serves as 
the data RAM address offset, which can be 0 or 2, and its value toggles when the s button 
is pressed. The corresponding assembly code subroutine is 
; i n p u t  p o r t  d e f i n i t i o n s  
constant rd-flag-port , 00 ; 2  f l a g s  ( x x x x x x s c ) :  
constant sw-port , 01 
; 8 - b i t  
s w i t c h  
proc-btn : 
. . .  
input s 3 ,  rd-flag-port 
; g e t  f l a g  
; c h e c k  and p r o c e s s  c b u t t o n  
t e s t  s 3 ,  01 
; c h e c k  c b u t t o n  f l a g  
jump z ,  chk-btns 
; f l a g  n o t  s e t  
c a l l  init 
; f l a g  s e t ,  c l e a r  
jump pr o c - b t n- done 
chk-btns : 
; c h e c k  and p r o c e s s  s b u t t o n  
t e s t  s 3 ,  0 2  
; c h e c k  s b u t t o n  f l a g  
jump z ,  proc-btn-done 
; f l a g  n o t  s e t  
input data, sw-port 
; g e t  s w i t c h  
load addr, a-lsb 
; g e t  a d d r  of a 
add addr, switch-a-b 
; add o f f s e t  
store data, (addr) 
; w r i t e  d a t a  t o  ram 
; u p d a t e  c u r r e n t  d i s p  p o s i t i o n  
xor switch-a-b, 0 2  
; t o g g l e  b e t w e e n  0 0 ,  0 2  
return 
proc-btn-done : 
16.4.3 Assembly code development 
After designing the I/O interface, we can derive the assembly program. The development 
follows the divide-and-conquer approach discussed in Chapter 15 and partitions the main 
program into several subroutines. The main program is 
c a l l  init 
; m a i n  l o o p  body 
c a l l  proc-btn 
; c h e c k  C? 
p r o c e s s  b u t t o n s  
c a l l  square 
; c a l c u l a t e  s q u a r e  
c a l l  load-led-pttn 
; s t o r e  l e d  p a t t e r n s  t o  ram 
c a l l  disp-led 
; o u t p u t  l e d  p a t t e r n  
jump forever 
; in i t  i a 1 i z a  t i  o n 
forever : 
The complete code is shown in Listing 16.1. 
The square subroutine is fromchapter 15, and the proc-btn and disp-led subroutines 
are discussed in the previous two subsections. The i n i t  subroutine performs system initial- 
ization. It uses a loop to load 0’s to data RAM (i.e., clear the RAM) and sets the s w i t  ch-a-b 

SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED DISPLAY INTERFACE 
377 
register to 0 (i.e., read a). The load-led-pttn subroutine reads the switch input, retrieves 
the desired values from the data RAM, converts the values to seven-segment LED pat- 
terns, and stores them to the corresponding locations in the data RAM. These patterns are 
then written to the output ports in the subsequent disp-led routine. The load-led-pttn 
routine consists of the get-uppernibble and get-lowernibble routines to extract the 
two hexadecimal digits and the hex-to-led routine to convert a hexadecimal digit to the 
corresponding seven-segment LED pattern. 
The program requires more storage. In addition to the data RAM and registers required 
for the square subroutine, this program utilizes a new global register switch-a-b to keep 
track of whether a or b is being read, and 4 bytes in data RAM, whose addresses are labeled 
ledO, ledl, led2, and led3, to store four seven-segment LED patterns. 
Listing 16.1 Square program with a switch and seven-segment LED interface 
,_______________________________________------------------ 
; s q u a r e  c i r c u i t  w i t h  7 - s e g  LED i n t e r f a c e  
; p r o g r a m  o p e r a t i o n  : 
; - c a l c u l a t e  a * a  + b * b  
; - d i s p l a y  d a t a  on 7 - s e g  
l e d  
._______________________________________------------------ 
,-----__-________________________________----------------- 
c ; - read a and b f r o m  s w i t c h  
,_______________________________________-----_-_---------- 
10 ; d a t a  RAM a d d r e s s  a l i a s  
._______________________________________-_-_-------_------ 
,_______________________________________------------------ 
c onstan t a - l s b ,  00 
constant b - l s b ,  02 
constant a a - l s b ,  04 
I S  constant a a - m s b ,  05 
constant b b - l s b ,  06 
c onst ant b b - m s b ,  07 
c onst ant aabb-lsb , 08 
c onst ant aabb-msb , 09 
20 c onst ant aabb-cout , O A  
c onst ant l e d O ,  1 0  
c onst ant l e d l ,  11 
c onst ant l e d 2 ,  1 2  
c onst ant l e d 3 ,  1 3  
5 
,_______________________________________------------------ 
; r e g i s t e r  a l i a s  
; c o m m o n l y  used l o c a l  v a r i a b l e s  
namereg s l ,  addr 
; r e g  f o r  t e m p o r a r y  mem & i / o  p o r t  a d d r  
namereg s 2 ,  i 
; g e n e r a l  - p u r p o s e  
l o o p  i n d e x  
; g l o b a l  v a r i a b l e s  
namereg s f ,  switch-a-b ; r a m  o f f s e t  f o r  c u r r e n t  s w i t c h  i n p u t  
,_______________________________________------------------ 
30 namereg S O ,  d a t a  
; r e g  f o r  t e m p o r a r y  d a t a  
35 
._______________________________________------------------ 
,___________________-------------------------------------- 
; p o r t  a l i a s  
. 
i n p u t  p o r t  d e f i n i t i o n s  
,_______________________________________------------------ 

378 
PICOBLAZE 110 INTERFACE 
40 constant rd-flag-port , 00 
; 2 f l a g s  ( x x x x x x s c  ): 
constant sw-port , 01 
; & b i t  
s w i t c h  
constant sseg0-port , 00 
;7-seg 
l e d  0 
constant ssegl-port , 01 
;7-seg 
l e d  I 
45 constant sseg2-port , 02 
;7-seg 
l e d  2 
constant s s e g 3 _ p o r t ,  0 3  
;7-seg 
l e d  3 
o u t p u t  p o r t  d e f i n i t i o n s  
; main program 
; c a 1 1  i n  g 
50 ; 
h i e r a  r c h y 
; main 
; - i n i t  
55 ; - p r o c - b t n  
- i n i t  
; - s q u a r e  
- m u l t - s o f t  
; - l o a d - l e d - p t t n  
- g e  t-1 o w e  r - n  i b b l  e 
- g e t - u p p e  r - n  i b b l e  
- h e x - t o - l e d  
60 
3. 
; - d i s p - l e d  
65 ,' 
c a l l  init 
; m a i n  l o o p  body 
c a l l  square 
; c a l c u l a t e  s q u a r e  
c a l l  load-led-pttn 
; s t o r e  l e d  p a t t e r n s  t o  ram 
c a l l  disp-led 
; o u t p u t  l e d  p a t t e r n  
jump forever 
; i n  i t i a 1 i z a  t i o n 
forever : 
70 
c a l l  proc-btn 
; c h e c k  & p r o c e s s  b u t t o n s  
75 
; r o u t i n e  : i n i t  
; f u n c t i o n  : p e r f o r m  i n i t i a l i z a t i o n  , c l e a r  r e g i s t e r / r a m  
; o u t p u t  r e g i s t e r :  
; temp r e g i s t e r :  d a t a ,  i 
80 ; 
s w i t c h - a - b  : c l e a r e d  t o  0 
; u n i t i z e  l o o p  i n d e x  t o  6 4  
init : 
; c 1 e a r  memory 
load d a t a ,  00 
s t o r e  d a t a ,  (i) 
sub i ,  0 1  
; d e c  l o o p  i n d e x  
; c l e a r  r e g i s t e r  
load switch-a-b, 00 
85 
load i ,  40 
clr-mem-loop : 
90 
jump n z ,  clr-mem-loop 
; r e p e a t  u n t i l  i=O 

SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED DISPLAY INTERFACE 
379 
return 
95 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
; r o u t i n e  : p r o c - b t n  
; f u n c t i o n :  c h e c k  t w o  b u t t o n s  and p r o c e s s  t h e  d i s p l a y  
; 
i n p u t  r e g :  
s w i t c h - a - b :  ram o f f s e t  ( 0  f o r  a and 2 f o r  b )  
s3: s t o r e  i n p u t  p o r t  f l a g  
s w i t c h - a - b :  may be t o g g l e d  
IW ; 
o u t p u t  r e g i s t e r :  
; temp r e g i s t e r  u s e d :  d a t a ,  a d d r  
,____________-__________________________------------------ 
105 proc-btn: 
input s3, rd-flag-port 
; g e t  f l a g  
; c h e c k  and p r o c e s s  c b u t t o n  
t e s t  s3, 0 1  
; c h e c k  c b u t t o n  f l a g  
jump z ,  chk-btns 
; f l a g  n o t  s e t  
110 
c a l l  init 
; f l a g  s e t ,  c l e a r  
jump proc-btn-done 
; c h e c k  and p r o c e s s  s b u t t o n  
t e s t  s3, 0 2  
; c h e c k  s b u t  
I I S  
jump z ,  proc-btn-done 
; f l a g  n o t  s e  
input data, sw-port 
; g e t  s w i t c h  
load addr, a-lsb 
; g e t  a d d r  of 
add addr, switch-a-b 
; a d d  o f f s e t  
chk-btns : 
o n  f l a g  
a 
s tor e  d a t a ,  (addr) 
; w r i t e  d a t a  t o  ram 
xor switch-a-b, 02 
; t o g g l e  b e t w e e n  0 0 ,  0 2  
return 
120 
; u p d a t e  c u r r e n t  d i s p  p o s i t i o n  
proc-btn-done : 
125 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
; r o u t i n e  : l o a d - l e d - p t t n  
; f u n c t i o n :  read 3 LSBs o f  s w i t c h  i n p u t  and c o n v e r t  t h e  
d e s i r e d  v a l u e s  t o  f o u r  l e d  p a t t e r n s  and 
l o a d  t h e m  t o  ram 
130 ,' 
s w i t c h :  0 0 0 : a ;  0 0 1 : b ;  O I O : a A 2 ;  O l l : b A 2 ;  
o t h e r s  : a ^2 i 
b A 2  
; 
temp r e g i s t e r  u s e d :  d a t a ,  a d d r  
; 
s6: d a t a  f r o m  sw i n p u t  p o r t  
135 ;--------------------------------------------------------- 
......................................................... 
load-led-pttn: 
input s 6 ,  sw-port 
; g e t  s w i t c h  
s10 s6 
; * 2  t o  o b t a i n  a d d r  o f f s e t  
compare s 6 ,  0 8  
; sw >loo? 
140 
jump c ,  sw-ok 
; no 
load s 6 ,  0 8  
; y e s ,  sw e r r o r ,  make d e f a u l t  
; p r o c e s s  b y t e  0 ,  l o w e r  n i b b l e  
load addr, a-lsb 
sw-ok : 
145 
add addr, s6 
; g e t  l o w e r  a d d r  

PICOBLAZE 110 INTERFACE 
380 
I50 
I55 
IMi 
I65 
I70 
f e t c h  data, ( s 6 )  
; g e t  l o w e r  b y t e  
c a l l  get-lower-nibble 
: g e t  l o w e r  n i b b l e  
c a l l  hex-to-led 
; c o n v e r t  t o  l e d  p a t t e r n  
store data, ledO 
; p r o c e s s  b y t e  0 ,  u p p e r  n i b b l e  
f e t c h  data, (addr) 
c a I I 
get -upper-nibble 
c a l l  hex-to-led 
s t o r e  data, ledl 
; p r o c e s s  b y t e  1 ,  l o w e r  n i b b l e  
add addr , 01 
; g e t  u p p e r  a d d r  
fetch data, (addr) 
c a l l  get-lower-nibble 
c a l l  hex-to-led 
store data, led2 
; p r o c e s s  b y t e  1 ,  u p p e r  n i b b l e  
f e t c h  data, (addr) 
c a1 1 get - upp er- n i bbl e 
c a l l  hex-to-led 
; c h e c k  f o r  sw=100 t o  p r o c e s s  c a r r y  a s  l e d  dp 
compare s 6 ,  0 8  
; d i s p l a y  f i n a l  r e s u l t ?  
jump n z ,  led-done 
; no 
add addr , 01 
; g e t  c a r r y  a d d r  
fetch s 6 ,  (addr) 
; s 6  t o  s t o r e  c a r r y  
t e s t  s 6 ,  01 
; c a r r y  = I ?  
jump z ,  led-done 
; no 
and data, 7F 
; y e s ,  a s s e r t  msb ( d p )  t o  0 
led-done : 
175 
return 
s t o r e  data, led3 
,_______________________________________------------------ 
; r o u t i n e  : d i s p - l e d  
; f u n c t i o n :  o u t p u t  f o u r  l e d  p a t t e r n s  
180 ; 
temp r e g i s t e r  u s e d :  d a t a  
,_______________________________________------------------ 
disp-led: 
fetch data, ledO 
output data, sseg0-port 
185 
f e t c h  data, ledl 
output data, ssegl-port 
f e t c h  data, led2 
output data, sseg2-port 
fetch data, led3 
190 
output data, sseg3-port 
return 
; r o u t i n e  : h e x - t o - l e d  
; i n p u t  r e g i s t e r :  d a t a  
; o u t p u t  r e g i s t e r :  d a t a  
195 ; f u n c t i o n :  c o n v e r t  a h e x  d i g i t  t o  7 - s e g  
l e d  p a t t e r n  

SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED DISPLAY INTERFACE 
381 
hex-to-led: 
zw 
compare data, 00 
jump n z ,  comp-hex-1 
load data, 81 
jump hex-done 
205 
compare 
data, 01 
jump n z ,  comp-hex-2 
load data, CF 
jump hex-done 
comp-hex-1: 
comp-hex-2 : 
210 
compare data, 02 
jump n z ,  comp-hex-3 
load data, 92 
jump hex-done 
comp-hex-3 : 
218 
compare data, 03 
jump n z ,  comp-hex-4 
load data, 86 
jump hex-done 
comp-hex-4: 
220 
compare data, 04 
jump n z ,  comp-hex-5 
load data, CC 
jump hex-done 
comp-hex-5 : 
22s 
compare data, 05 
jump n z ,  comp-hex-6 
load data, A 4  
jump he x - d one 
comp-hex-6: 
230 
compare data, 06 
jump n z ,  comp-hex-7 
load data, A0 
jump hex-done 
comp-hex-7 : 
228 
compare data, 07 
jump n z ,  comp-hex-8 
load data, 8 F  
jump hex-done 
comp-hex-8 : 
240 
compare data, 08 
jump n z ,  comp-hex-9 
load data, 80 
jump hex - done 
comp-hex-9 : 
24s 
compare data, 09 
jump n z ,  comp-hex-a 
load data, 84 
jump hex-done 
comp-hex-a: 
250 
compare data, OA 
jump n z ,  comp-hex-b 
; 7 - s e g  
p a t t e r n  0 
; 7 - s e g  
p a t t e r n  1 
; 7 - s e g  
p a t t e r n  2 
; 7 - s e g  
p a t t e r n  3 
; 7 - s e g  
p a t t e r n  4 
; 7 - s e g  
p a t t e r n  5 
; 7 - s e g  
p a  
; 7 - s e g  
p a  
t e r n  6 
t e r n  7 
; 7 - s e g  
p a t t e r n  8 
;7--seg p a t t e r n  9 

382 
PICOBLAZE 110 INTERFACE 
;7-seg 
p a t t e r n  a 
load data, 88 
jump hex -done 
comp-hex-b: 
255 
compare data, O B  
jump n z ,  comp-hex-c 
load data, EO 
;7-seg 
p a  
jump hex-done 
comp-hex-c: 
260 
compare data, OC 
jump n z ,  comp-hex-d 
load data, B1 
;7-seg 
p a  
jump hex-done 
comp-hex-d: 
265 
compare data, O D  
jump n z ,  comp-hex-e 
load data, C2 
jump hex - do ne 
comp-hex-e: 
270 
compare data, O E  
jump n z ,  comp-hex-f 
t e r n  b 
t e r n  C 
;7-seg 
p a t t e r n  d 
load data, BO 
jump hex - do ne 
275 
load data, B8 
comp-hex-f : 
hex-done : 
return 
;7-seg 
p a t t e r n  E 
;7-seg 
p a t t e r n  F 
280 ; r o u t i n e  : g e t - l o w e r - n i b b l e  
; f u n c t i o n :  g e t  l o w e r  4 b i t s  of d a t a  
; i n p u t  r e g i s t e r :  d a t a  
; o u t p u t  r e g i s t e r :  d a t a  
285 get-lower-nibble : 
and data, O F  
return 
; c l e a r  u p p e r  n i b b l e  
290 ; r o u t i n e  : g e t - u p p e r - n i b b l e  
; f u n c t i o n :  g e t  u p p e r  4 b i t s  of i n - d a t a  
; i n p u t  r e g i s t e r  : d a t a  
; o u t p u t  r e g i s t e r :  d a t a  
295 get-upper-nibble : 
srO data 
srO data 
srO data 
srO data 
300 
return 
; r i g h t  s h i f t  4 t i m e s  
; r o u t i n e  : s q u a r e  
; f u n c t i o n :  c a l c u l a t e  a * a  + b * b  

SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED DISPLAY INTERFACE 
383 
?OS ; 
d a t a / r e s u l t  s t o r e d  i n  ram s t a r t e d  w /  SQ-BASEADDR 
,' 
temp r e g i s t e r :  s 3 ,  s 4 ,  sS, s 6 ,  d a t a  
____________________--_-_--_---------_------_--__-------- 
square : 
; c a l c u l a t e  a * a  
f e t c h  s 3 ,  a-lsb 
f e t c h  s 4 ,  a-lsb 
c a l l  mult-soft 
s t o r e  s 6 ,  aa-lsb 
s t o r e  s 5 ,  aa-msb 
; c a l c u l a t e  b * b  
f e t c h  s 3 ,  b-lsb 
f e t c h  s 4 ,  b-lsb 
c a l l  mult-soft 
s t o r e  s 6 ,  bb-lsb 
s t o r e  s 5 ,  bb-msb 
; c a l c u l a t e  a*a+b*b 
f e t c h  d a t a ,  aa-lsb 
add d a t a ,  s 6  
s t o r e  d a t a ,  aabb-lsb 
f e t c h  d a t a ,  aa-msb 
addcy d a t a ,  s5 
s t o r e  d a t a ,  aabb-msb 
load d a t a ,  00 
addcy d a t a ,  00 
s t o r e  d a t a ,  aabb-cout 
return 
; l o a d  a 
; l o a d  a 
; c a l c u l a t e  a * a  
; s t o r e  l o w e r  b y t e  o f  a * a  
; s t o r e  u p p e r  b y t e  o f  a*a 
l o a d  b 
l o a d  b 
c a l c u l a t e  b * b  
s t o r e  l o w e r  b y t e  o f  b * b  
s t o r e  u p p e r  b y t e  o f  b * b  
g e t  l o w e r  b y t e  o f  a*a 
; a d d  l o w e r  b y t e  o f  a*a+b*b 
; s t o r e  l o w e r  b y t e  o f  a*a+b*b 
; g e t  u p p e r  b y t e  o f  a * a  
; a d d  u p p e r  b y t e  o f  a*a+b*b 
; s t o r e  u p p e r  b y t e  o f  a*a+b*b 
; c l e a r  d a t a ,  b u t  k e e p  c a r r y  
; g e t  c a r r y  f r o m  p r e v i o u s  + 
; s t o r e  c a r r y  o f  a*a+b*b 
,_______---____-------------------------__----------_----- 
; r o u t i n e  : m u l t - s o f t  
i ? ~  
; f u n c t i o n :  8 -  b i t  u n s i g n e d  m u l t i p l i e r  u s i n g  
s h i f  t -and-add 
a l g o r i t h m  
; 
i n p u t  r e g i s t e r :  
s3 : m u l t i p l i c a n d  
s 4 :  m u l t i p l i e r  
sS: u p p e r  b y t e  o f  p r o d u c t  
s 6 :  l o w e r  b y t e  of p r o d u c t  
340 ; 
o u t p u t  r e g i s t e r :  
; 
temp r e g i s t e r :  i 
,_______________________________________---_------_------- 
3.15 m u l t - s o f t :  
load s 5 ,  00 
; c l e a r  sS 
load i ,  08 
; i n i t i a l i z e  l o o p  i n d e x  
srO 
s 4  
; s h i f t  l s b  t o  c a r r y  
?SO 
jump n c ,  shift-prod 
; l s b  i s  0 
add s 5 ,  s 3  
; l s b  i s  1 
sra s5 
; s h i f t  u p p e r  b y t e  r i g h t ,  
~ S S  
s r a s 6  
; s h i f t  l o w e r  b y t e  r i g h t ,  
mult-loop : 
shift-prod: 
; c a r r y  t o  MSB, LSB t o  c a r r j  
; l s b  of sS t o  MSB o f  s 6  
sub i ,  0 1  
; d e c  l o o p  i n d e x  

384 
PICOBLAZE 110 INTERFACE 
jump n z ,  mult-loop 
; r e p e a t  u n t i l  i=O 
return 
16.4.4 VHDL code development 
The complete HDL code simply combines the PicoBlaze processor, instruction ROM, the 
input interface and peripherals shown in Figure 16.7, and the output interface and peripherals 
shown in Figure 16.6. It is shown in Listing 16.2. 
Listing 16.2 PicoBlaze with a switch and seven-segment LED interface 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  pico-btn i s  
5 
p o r t (  
clk, reset: in std-logic; 
sw: in std-logic-vector ( 7  downto 0 )  ; 
btn: in std-logic-vector (1 downto 0 )  ; 
an: out std-logic-vector (3 downto 0 )  ; 
10 
sseg : out std-logic-vector (7 downto 0 )  
1 ;  
end pico-btn ; 
a r c h i t e c t u r e  arch of pico-btn i s  
15 
-- KCPSM3/ROM s i g n a l s  
s i g n a l  address : std-logic-vector (9 downto 0 )  ; 
s i g n a l  instruction: std-logic-vector ( 1 7  downto 0 )  ; 
s i g n a l  port-id: std-logic-vector ( 7  downto 0 )  ; 
s i g n a l  in-port , out-port : std-logic-vector (7 downto 0 )  ; 
s i g n a l  interrupt , interrupt-ack: std-logic; 
s i g n a l  kcpsm-reset : std-logic ; 
-- 1 / 0  p o r t  s i g n a l s  
__ o u t p u t  e n a b l e  
-- f o u r - d i g i t  
s e v e n - s e g m e n t  
l e d  d i s p l a y  
s i g n a l  ds3_reg, ds2-reg: std-logic-vector ( 7  downto 0 )  ; 
s i g n a l  dsl-reg , ds0-reg : std-logic-vector ( 7  downto 0 )  ; 
-- two p u s h b u t t o n s  
30 
s i g n a l  btnc-f lag-reg , btnc-f lag-next : std-logic ; 
s i g n a l  btns-f lag-reg , btns-f lag-next : std-logic ; 
s i g n a l  set-btnc-f lag, set-btns-f lag : std-logic ; 
s i g n a l  clr-btn-f lag: std-logic ; 
20 
s i g n a l  write-strobe , read-strobe : std-logic ; 
25 
s i g n a l  en-d: std-logic-vector (3 downto 0 )  ; 
begin ________________________________________------------- 
________________________________________------------- 
35 
-- 
-- 1 / 0  m o d u l e s  
disp-unit : e n t i t y  work. disp-mux 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
port map( 
40 
clk=>clk, reset=>’O’, 
in3=>ds3_reg, in2=>ds2_reg, inl=>dsl-reg, 
inO=>dsO-reg, an=>an, sseg=>sseg); 

SQUARE PROGRAM WITH A SWITCH AND SEVEN-SEGMENT LED DISPLAY INTERFACE 
385 
45 
50 
60 
65 
btnc-db-unit : entity work. debounce 
port map( 
clk=>clk, reset=>reset , sw=>btn(O), 
db-level=>open, db-tick=>set-btnc-flag); 
btns-db-unit : entity work. debounce 
port map( 
clk=>clk, reset=>reset , sw=>btn(l), 
db-level=>open, db-tick=>set-btns-flag); 
_--___-_-_-__-___-_---_------------------------------ 
--____________________-_-__--_-_-------------------
__ 
KCPSM and ROM i n s t a n t i a t i o n  
proc-unit : entity work. kcpsm3 
_--___-_-____-___-_--___----------------------------- 
__-___-______-______-____-_-------------------------- 
-- 
55 
port map( 
clk=>clk, reset =>kcpsm-reset, 
address=>address , instruction=>instruction, 
port-id=>port-id, write-strobe=>write-strobe, 
out-port=>out-port , read-strobe=>read-strobe, 
in-port=>in-port , interrupt=>interrupt , 
interrupt-ack=>interrupt-ack); 
rom-unit : entity work. btn-rom 
port map( 
clk => clk, address=>address , 
instruction=>instruction); 
_- 
u n u s e d  i n p u t s  on p r o c e s s o r  
kcpsm-reset <= ’ 0 ) ;  
interrupt <= 
) O ) ;  
_---_________-___-_--___----------------------------- 
--__________________-__---__------------------------
70 
-- 
o u t p u t  i n t e r f a c e  
____-_-__---___--_-_____________________------------- 
--______________________________________--------------- 
__ 
o u t p o r t  p o r t  i d :  
-_ 
0 x 0 0 :  dsO 
__ 
0 x 0 1 :  d s l  
75 
-- 
0 x 0 2 :  d s 2  
__ 
0 x 0 3 :  d s 3  
---------------------------------=-----================ 
_- 
r e g i s t e r s  
process (clk) 
SO 
begin 
if (clk ’ event and clk= ’ 1 ’ ) then 
if en-d(O)=’l’ then ds0-reg <= out-port; end if; 
if en-d(l)=’l’ then dsl-reg <= out-port; end if; 
if en-d(2)=’1’ then ds2-reg <= out-port; end if; 
85 
if en-d(3)=’1’ then ds3-reg <= out-port; end if; 
end if ; 
end process; 
process (port-id , write-strobe) 
__ d e c o d i n g  c i r c u i t  f o r  e n a b l e  s i g n a l s  
YO 
begin 
en-d <= (others=>’O’); 
if write-strobe=’l’ then 
case port-id(l downto 0 )  is 
when ” 0 0 ”  => en-d < = ” 0 0 0 1 ” ;  
when ” 0 1 “  => en-d < = “ 0 0 1 0 “ ;  
95 

386 
IW 
105 
I10 
115 
I20 
I25 
130 
135 
PICOBLAZE 110 INTERFACE 
when “ 1 0 “  => en-d < = “ 0 1 0 0 ” ;  
when others => en-d < = “ 1 0 0 0 “ ;  
end c a s e ;  
end i f ;  
end p r o c e s s ;  
__ 
i n p u t  i n t e r f a c e  
__ 
i n p u t  p o r t  i d  
__ 
0x01: s w i t c h  
__ 
__ 
__ 
0x00: f l a g  
__ i n p u t  r e g i s t e r  ( f o r  f l a g s )  
process (clk) 
begin 
if (clk’event and c l k = ’ l ’ )  then 
btnc-flag-reg <= btnc-flag-next; 
btns-flag-reg <= btns-flag-next; 
end i f  ; 
end p r o c e s s ;  
btnc-f lag-next <= ’ 1 ’ when set-btnc-f l a g = ’ l ’  e l s e  
’ 0  ’ when clr-btn-f l a g =  ’ 1 ’ e l s e  
btnc-flag-reg; 
btns-f lag-next <= ’ 1 ’ when set-btns-f l a g = ’  1 ’ e l s e  
’ 0 ’  when clr-btn-flag=’l’ e l s e  
btns-flag-reg; 
-- d e c o d i n g  c i r c u i t  f o r  c l e a r  s i g n a l s  
clr-btn-f lag <= ’ 1 ’ when read-strobe=’ 1 ’ and 
port-id ( O ) = ’ O ’  
e l s e  
’ 0 ’ ;  
__ i n p u t  m u l t i p l e x i n g  
process(port-id,btns-flag-reg,btnc-flag-reg,sw) 
begin 
case port-id(0) i s  
when ’ 0 ’  => 
in-port <= ”000000” & 
btns-flag-reg & btnc-flag-reg; 
when others => 
in-port <= sw; 
end c a s e ;  
end p r o c e s s ;  
end arch; 
16.5 SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND 
UART CONSOLE 
In this section, we add two more IiO peripherals to the previous design. One is a combi- 
national multiplier, which accelerates the multiplication, and the other is an UART, which 
provides a communication link to a PC. 

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
387 
16.5.1 Multiplier interface 
Since PicoBlaze does not contain a hardware multiplier, the multiplication is done by a 
software routine, mult-soft. It uses a shift-and-add algorithm to iterate through the 8-bit 
multiplier and requires about 60 instructions in the worst-case scenario. An alternative is 
to utilize the Spartan-3 device’s built-in combinational multiplier. 
Since PicoBlaze provides no mechanism to use a coprocessor, the multiplier must be 
configured as an I/O peripheral. We can create an 8-bit combinational multiplier that 
takes two 8-bit operands and returns a 16-bit product. To facilitate this peripheral, the 
PicoBlaze’s interface requires two additional output ports and buffers for the two operands 
and two additional input ports for the 16-bit product. The assembly routine now only needs 
to pass the operands to the output ports and then retrieve the results from the input ports. 
The code becomes 
; i n p u t  p o r t  d e f i n i t i o n s  
constant mult-prodo-port , 03 : m u l t i p l i c a t i o n  p r o d u c t  8 LSBs 
constant mult-prodl-port , 04 ; m u l t i p l i c a t i o n  p r o d u c t  8 MSBs 
; o u t p u t  p o r t  d e f i n i t i o n s  
constant mult-src0-port , 05 ; m u l t i p l i e r  o p e r a n d  0 
constant mult-srcl-port , 06 ; m u l t i p l i e r  o p e r a n d  I 
mult-hard : 
. . .  
output s3, mult-src0-port 
output s 4 ,  mult-srcl-port 
input s 5 ,  mult-prodl-port 
input s 6 ,  mult-prodo-port 
return 
Note that the combinational multiplier can complete the computation with one instruction 
(i.e., two clock cycles), and thus no additional timing mechanism is needed in the code. 
This routine can be used in place of the previous mult-soft routine. 
16.5.2 UART interface 
With the UART interface, information can be entered and displayed in Windows HyperTer- 
minal, which is more flexible and versatile than switches and LEDs. We use it as a simple 
control console for the square routine. A representative screen is shown in Figure 16.8. 
The console generates an SQ> prompt and a user can respond with a lowercase a, b, c, or 
d character. The a and b characters are used to input values for a and b of the square 
routine. When the key is pressed, the value of the 8-bit switch is read and stored into the 
corresponding data RAM location. The c character is used to clear the data RAM and 
reinitialize the program. Its function is identical to that of the c button. The d character 
leads to a “data RAM dump,” in which the 64 bytes of the data RAM are displayed on 
screen. This allows us to observe the various values of the square routine and the four 
seven-segment LED patterns. An Error message is returned for all other characters. 
The UART module designed in Section 7.4 can be used for this purpose. Since the 
transmission and receiving FIFO buffers provide a storage and flagging mechanism, no 
additional circuit is needed. We need only expand the decoding and multiplexing circuits 
to accommodate the additional I/O ports. The UART interface block diagram is sketched 
in Figure 16.9, in which the other I/O peripherals are omitted to reduce clutter. PicoBlaze’s 
output port, out-port, is connected to w-data of UART. The decoded enable signal is 
connected to wr-uart, and the data is written to UART transmitting FIFO when it is 

388 
PICOBLAZE 110 INTERFACE 
Figure 16.8 Representative console screen. 
Figure 16.9 UART IiO interface. 

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
389 
asserted. Similarly, r-data of UART is routed to PicoBlaze’s input multiplexing circuit, 
and the decoded clear signal is connected to rd-uart. When the UART receiving FIFO 
port is specified in an input instruction, the receiving FIFO’s output is routed to PicoBlaze’s 
input port, in-port, and the decoded remove signal is asserted one clock cycle to remove 
one word from the receiving FIFO. The UART interface also needs to route the two status 
signals, rx-empty and tx-f ull, to PicoBlaze’s input multiplexing circuit. The assembly 
program needs to check the status before reading or writing the UART’s FIFOs. Since the 
signals are only 2 bits wide, they can be grouped with the previous s and c buttons in the 
same input port. 
16.5.3 Assembly code development 
Since the previous assembly code is developed in a modular fashion, we can expand the 
program by adding a routine, proc-uart, to process UART transactions. The main program 
becomes 
c a l l  i n i t  
: i n i t i a l i z a t i o n  
; m a i n  loop body 
c a l l  p r o c - b t n  
; c h e c k  & p r o c e s s  b u t t o n s  
c a l l  p r o c - u a r t  
; c h e c k  & p r o c e s s  u a r t  r x  
c a l l  s q u a r e  
; c a l c u l a t e  s q u a r e  
c a 11 l o a d -  l e d - p t  t n  
; s t o r e  l e d  p a t t e r n s  t o  ram 
c a l l  d i s p - l e d  
; o u t p u t  l e d  p a t t e r n  
jump f o r e v e r  
f o r e v e r  : 
Because of the complexity of the required console operation, the proc-uart is quite 
involved. The pseudo code of this routine is 
; 
i f  ( n o  c h a r a c t e r  i n  UART r e c e i v i n g  F I F O )  t h e n  
; 
i n p u t  c h a r a c t e r s  f r o m  FIFO 
; 
i f  ( c h a r a c t e r s  i s  a )  t h e n  
r e t u r n  
i n p u t  s w i t c h  v a l u e  
s t o r e  i t  t o  d a t a  ram 
d i s p l a y  p r o m p t  
r e t u r n  
; 
i f  ( c h a r a c t e r s  i s  b )  t h e n  
i n p u t  s w i t c h  v a l u e  
s t o r e  i t  t o  d a t a  ram 
d i s p l a y  p r o m p t  
r e t u r n  
; 
i f  ( c h a r a c t e r s  i s  c )  t h e n  
p e r f o r m  i n  i t i  a 1 iz a t i o  n 
r e t u r n  
; 
i f  ( c h a r a c t e r s  i s  d )  t h e n  
dump d a t a  ram 
r e t u r n  
: 
d i s p l a y  e r r o r  m e s s a g e  
; 
r e t u r n  
We follow the modular development approach and further divide this routine into simpler 
routines. A key low-level routine is tx-one-byte, which transmits 1 byte via the UART 
port. Its code is 

390 
PICOBLAZE 110 INTERFACE 
; i n p u t  p o r t  d e f i n i t i o n s  
c onstan t rd-flag-port , 00 
; 4 f l a g s  ( x x x x t r s c ) :  
; 
t :  u a r t  t x  f u l l  , 
r :  u a r t  rx n o t  empty 
; 
s: s b u t t o n  f l a g  , c :  c b u t t o n  f l a g  
; o u t p u t  p o r t  d e f i n i t i o n s  
c onstan t uart-tx-port , 04 
; u a r t  r e c e i v e r  p o r t  
; r e g i s t e r  a l i a s  
namereg sd , tx-data 
; d a t a  t o  be t x  by u a r t  
tx-one-byte: 
. . .  
input s 6 ,  rd-f lag-port 
t e s t  s 6 ,  08 
; c h e c k  u a r t - t x - f u l l  
jump n z ,  tx-one-byte 
; y e s ,  k e e p  on w a i t i n g  
output tx-data, uart-tx-port ; n o ,  w r i t e  t o  u a r t  t x  f i f o  
return 
Since PicoBlaze’s processing speed is much higher than the UART’s transmission speed, we 
must prevent buffer overflow. The routine keeps on checking the status of the transmitting 
FIFO buffer, and writes data only when the buffer is not full. 
The task of dumping data RAM requires the most work. It displays the data RAM address 
and contents as an 8-by-8 table, which lists the byte address first and then the 8 bytes of 
data in hexadecimal format, as in 
001000 00 OF 00 09 00 04 00 0 3  
010000 00 00 FF 1D 00 0 0  00 19 
111000 00 0 0  00 00 0 0  FF FF FF 
.
.
.
 
The routine consists of three major routines: disp-ram-addr, which sends ASCII codes to 
display the 5-bit base address in binary format; dispxam-data, which sends ASCII codes 
to display 8 bytes of data; and hex-to-ascii, which converts a hexadecimal digit to the 
corresponding ASCII code. 
The complete code is shown in Listing 16.3. It includes detailed comments to explain 
operation of the subroutines. The unmodified subroutines of Listing 16.1 are omitted. 
Listing 16.3 Square program with a UART console 
._________________________________________--______-----___ 
______________________----_-______--______---________---_ 
; s q u a r e  c i r c u i t  w i t h  UART and m u l t i p l i e r  i n t e r f a c e  
; p r o g r a m  o p e r a t i o n  : 
; - c a l c u l a t e  a*a + b * b  
; - d i s p l a y  d a t a  on H y p e r T e r m i n a l  and 7 - s e g  
l e d  
,________________________-_--______----____-----_____----_ 
s ; - read a and b f r o m  s w i t c h  
,___________________----____-_----____------__-----____--- 
10 ; d a t a  c o n s t a n t s  
,___________________-________---_____---___-_----_____---- 
; s e l e c t e d  A S C I I  c o d e s  
constant ASCII-0, 
30 
constant ASCII-1, 
31 
I5 c onst an t ASCII-2, 
32 
constant ASCII-3, 
33 
constant ASCII-a, 
61 

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
391 
constant ASCII-b, 
6 2  
c onstan t ASCII-c, 
6 3  
20 c onstan t ASCII-d, 
6 4  
c onstan t ASCII-o, 
6 F  
c onstan t ASCII-r, 
7 2  
constant ASCII-E, 
4 5  
c onstan t ASCII-S, 
53 
25 c onstan t ASCII-Q, 
51 
c onstan t ASCII-D-U , 4 4  
; u p p e r c a s e  D 
c onstan t ASCII-GT, 3 E  
; > 
constant ASCII-SP, 2 0  
; s p a c e  
constant ASCII-CR, OD 
; c a r r i a g e  r e t u r n  
30 constant ASCII-LF, O A  
; l i n e  f e e d  
; d a t a  RAM a d d r e s s  a l i a s  
35 c onstan t 
c onstan t 
c onstan t 
constant 
c onstan t 
SO c onstan t 
constant 
c onstan t 
c onstan t 
c onstan t 
45 c onstan t 
c onstan t 
c onstan t 
a-lsb, 00 
b-lsb, 0 2  
aa-lsb, 04 
aa-msb, 0 5  
bb-lsb, 0 6  
bb-msb, 0 7  
aabb-lsb, 08 
aabb-msb, 09 
aabb-cout , OA 
l e d O ,  10 
led1 , 1 1  
l e d 2 ,  12 
l e d 3 ,  13 
5 0 ;  r e g i s t e r  a l i a s  
;commonly used l o c a l  v a r i a b l e s  
namereg S O ,  data 
; r e g  f o r  t e m p o r a r y  d a t a  
namereg s l ,  addr 
; r e g  f o r  t e m p o r a r y  mem & i / o  p o r t  a d d r  
; g l o b a l  v a r i a b l e s  
namereg s c ,  switch-a-b ; r a m  o f f s e t  f o r  c u r r e n t  s w i t c h  i n p u t  
namereg sd, tx-data 
; d a t a  t o  be t x  by u a r t  
55 namereg s 2 ,  i 
; g e n e r a l  - p u r p o s e  
l o o p  i n d e x  
ho ,’ 
; p o r t  a l i a s  
i n p u t  p o r t  d e f i n i t i o n s  
c onstan t rd-flag-port , 00 
65 ; 4 f l a g s  ( x x x x t r s c ) :  
; 
t :  u a r t  t x  f u l l  
; 
r :  u a r t  r x  not e m p t y  
; 
s: s b u t t o n  f l a g  
; 
c :  c b u t t o n  f l a g  
70 c onstan t sw-port , 
0 1  
; & b i t  
s w i t c h e s  

392 
PICOBLAZE 110 INTERFACE 
constant 
constant 
constant 
75 constant 
constant 
constant 
constant 
con s tan t  
80 constant 
constant 
uart-rx-port , 
02 
; u a r t  r e c e i v e r  p o r t  
mult-prodo-port , 0 3  
; m u l t i p l i c a t i o n  p r o d u c t  8 LSBs 
mult-prodl-port , 04 
; m u l t i p l i c a t i o n  p r o d u c t  8 MSBs 
sseg0-port , 
00 
;7-seg 
l e d  0 
ssegl-port , 
01 
;7-seg 
l e d  1 
s s e g 2 _ p o r t ,  
0 2  
;7-seg 
l e d  2 
s s e g 3 _ p o r t ,  
03 
;7-seg 
l e d  3 
uart-tx-port , 
04 
; u a r t  r e c e i v e r  p o r t  
mult-src0-port , 0 5  
; m u l t i p l i e r  o p e r a n d  0 
mult-srcl-port , 06 
; m u l t i p l i e r  o p e r a n d  1 
o u t p u t  p o r t  d e f i n i t i o n s  
main p r o g r a m  
85 
c a l l i n g  h i e r a r c h y :  
90 
IM 
105 
main 
- i n i t  
- t x - p r o m p t  
- t x - o n e - b y t e  
- p r o c - b t n  
- i n i t  
- p r o c - u a r t  
95 
- t x - p r o m p t  
- i n i t  
- p r o c - u a r t - e r r  
- dump-mem 
- t x - o n e - b y t e  
- t x - p r o m p t  
- d i s p - r a m - a d d r  
- d i s p - r a m - d a t a  
- t x - o n e - b y t e  
- t x - o n e - b y t e  
- g e  t - u p p e  r - n  i b b l  e 
- g e t-1 o w  e r n  i b bl e 
- h e x - t o - a s c i i  
- s q u a r e  
- m u l t - h a r d  
110 
- l o a d - l e d - p t t n  
- g e t - l o w e r - n i b b l e  
- g e t  - u p p e  r - n  i b b l e  
- h e x - t o - l e d  
- d i s p - l e d  
11s 
c a l l  init 
: m a i n  l o o p  b o d y  
c a l l  proc-uart 
c a l l  square 
c a l l  load-led-pttn 
forever : 
IZO 
c a l l  proc-btn 
; i n i t i a l i z a t i o n  
; c h e c k  & p r o c e s s  b u t t o n s  
; c h e c k  & p r o c e s s  u a r t  r x  
; c a l c u l a t e  s q u a r e  
; s t o r e  l e d  p a t t e r n s  to ram 

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
393 
c a l l  disp-led 
125 
jump forever 
; o u t p u t  l e d  p a t t e r n  
,_______________________________________------------------ 
; r o u t i n e  : i n i t  
; f u n c t i o n  : p e r f o r m  i n i t i a l i z a t i o n  , c l e a r  r e g i s t e r / r a m  
130 : 
o u t p u t  r e g i s t e r :  
s w i t c h - a - b  : c l e a r e d  t o  0 
; temp r e g i s t e r :  d a t a ,  i 
init : 
,--------------_---_____________________------------------ 
135 
; c l e a r  memory 
load i, 40 
; u n i t i z e  l o o p  i n d e x  t o  64 
load data, 00 
s t o r e  data, (i) 
jump n z ,  clr-mem-loop 
; r e p e a t  u n t i l  i=O 
; c l e a r  r e g i s t e r  
load switch-a-b, 00 
c a 1 1  tx-pr ompt 
clr-mem-loop : 
140 
sub i, 01 
; d e c  l o o p  i n d e x  
145 
return 
.---______--------______________________------------------ 
,_________--____________________________------------------ 
; r o u t i n e  : p r o c - u a r t  
; f u n c t i o n :  read u a r t  i n p u t  c h a r :  
I50 ; 
a o r  6 :  read a o r  b f r o m  s w i t c h ;  
; i n p u t  r e g :  s3 ( i n p u t  p o r t  f l a g )  
; temp r e g i s t e r  u s e d :  d a t a  
; 
s 4 :  s t o r e  r e c e i v e d  u a r t  c h a r  o r  0 0  ( n o  u a r t  i n p u t )  
proc-uart : 
c :  c l e a r ;  
d :  d u m p / d i s p l a y  d a t a  ram 
o t h e r :  e r r o r  
, 5 5  , 
_______----_-____---____________________--------------- 
t e s t  s 3 ,  04 
; c h e c k  u a r t  r x  s t a t u s  
jump z ,  uart-rx-done 
; g o  t o  done i f  r x  e m p t y  
; p r o c e s s  r e c e i v e d  c h a r  
160 
input s 4 ,  uart-rx-port 
; g e t  c h a r  
; c h e c k  i f  r e c e i v e d  c h a r  i s  a 
compare s 4 ,  ASCII-a 
; c h e c k  A S C I I  a 
jump n z ,  chk-ascii-b 
; n o ,  c h e c k  n e x t  
input data, sw-port 
; g e t  s w i t c h  
165 
s t o r e  data, a-lsb 
; w r i t e  a t o  d a t a  ram 
c a  I I 
tx-pr ompt 
;new p r o m p t  l i n e  
jump uart-rx-done 
; c h e c k  i f  r e c e i v e d  c h a r  i s  b 
jump n z ,  chk-ascii-c 
; n o ,  c h e c k  n e x t  
input data, sw-port 
; g e t  s w i t c h  
s t o r e  data, b-lsb 
; w r i t e  b t o  d a t a  ram 
c a1 1 
tx-pr ompt 
; n e w  p r o m p t  l i n e  
chk-ascii-b : 
170 
compare s 4 ,  ASCII-b 
; c h e c k  ASCII b 
175 
jump uart-rx-done 
chk-ascii-c: 

394 
PICOBLAZE I/O INTERFACE 
; c h e c k  i f  r e c e i v e d  c h a r  i s  c 
compare s4, ASCII-c 
; c h e c k  A S C I I  c 
jump n z ,  chk-ascii-d 
; n o  c h e c k  n e x t  
jump uart-rx-done 
; c h e c k  i f  r e c e i v e d  c h a r  i s  d 
compare s 4 ,  ASCII-d 
; c h e c k  ASCII d 
c a l l  dump-mem 
; dump/ d i s p  1 a y  ram 
jump uart-rx-done 
; u n d e f i n e d  c h a r  
190 
c a l l  proc-uart-error 
180 
c a l l  init 
; c l e a r  
chk-ascii-d: 
185 
jump nz , ascii-undef ined 
ascii-undefined: 
uart-rx-done: 
return 
proc-uart-error: 
load tx-data, ASCII-LF 
200 
c a l l  tx-one-byte 
load tx-data, ASCII-CR 
c a l l  tx-one-byte 
load tx-data, ASCII-SP 
c a l l  tx-one-byte 
205 
c a l l  tx-one-byte 
load t x - d a t a ,  ASCII-E 
c a l l  tx-one-byte 
load tx-data, ASCII-r 
c a 1 1  t x-one- byt e 
210 
load tx-data, ASCII-r 
c a l l  tx-one-byte 
load t x - d a t a ,  ASCII-o 
c a l l  tx-one-byte 
load t x - d a t a ,  ASCII-r 
215 
c a l l  tx-one-byte 
c a l l  tx-prompt 
return 
; t r a n s m i t  LF 
; t r a n s m i t  CR 
; t r a n s m i t  SP 
; t r a n s m i t  SP 
; t r a n s m i t  E 
; t r a n s m i t  r 
; t r a n s m i t  r 
; t r a n s m i t  o 
; t r a n s m i t  r 
._______________________________________------------------ 
,_______________________________________------------------ 
220 ; r o u t i n e  : dump-mem 
; f u n c t i o n :  
when d r e c e i v e d ,  dump 6 4  b y t e s  o f  ram a s  
001000 xx xx xx xx xx xx xx xx 
010000 xx xx xx xx xx xx xx xx 
225 ,' 
111000 xx xx xx xx xx xx xx xx 
.
.
.
 
; temp r e g i s t e r  u s e d :  
; 
s3: as o u t e r  l o o p  i n d e x  
s 4 :  ram b a s e  a d d r e s s  
,-______________________________________------------------ 
19s ; r o u t i n e  : p r o c - u a r t - e r r o r  
; f u n c t i o n  : d i s p l a y  " E r r o r "  f o r  unknown u a r t  c h a r  

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
395 
; g e t  ram base addr ( x x x 0 0 0 )  
230 dump-mem : 
load s 3 ,  00 
; a d d r  used as l o o p  in d e x  
; loop body 
load s 4 ,  s3 
S I O  s4 
s10 s4 
c a l l  disp-ram-addr 
c a 1 1  di sp-ram-dat a 
compare s3, 08 
jump n z ,  dump-loop 
; l o o p  not reach 8 y e t  
c a  I I 
tx-prompt 
;new prompt 
return 
dump-loop : 
235 
s 10 S4 
240 
add s3, 01 
; i n c  loop in d e x  
245 
,_______________________________________------------------ 
; r o u t i n e  : t x - p r o m p t  
; f u n c t i o n  : g e n e r a t e  prompt "SQ>" 
; temp r e g i s t e r :  t x - d a t a  
tx-prompt : 
250 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
load tx-data, ASCII-LF 
c a l l  tx-one-byte 
; t r a n s m i t  LF 
load tx-data, ASCII-CR 
255 
c a l l  tx-one-byte 
; t r a n s m i t  CR 
load tx-data, ASCII-S 
c a l l  tx- one-byt e 
; t r a n s m i t  S 
load tx-data, ASCII-Q 
c a l l  tx-one-byte 
; t r a n s m i t  Q 
2 ~ )  
load tx-data, ASCII-GT 
c a l l  tx- one-byt e 
; t r a n s m i t  > 
load tx-data, ASCII-SP 
c a l l  tx-one-byte 
; t r a n s m i t  SP 
return 
265 
,___________________---------------------_-_-_------------ 
; r o u t i n e  : d i sp - ra m - a d d r 
; f u n c t i o n  : d i s p l a y  6 -  b i t  ram addr 
bbbOOO 
s 4 :  base a d d ress 
i ,  s7: 1 -  b i t  mask 
270 ; i n p u t  r e g i s t e r :  
; temp r e g i s t e r :  
,___________________-------------------------------------- 
275 disp-ram-addr : 
;new l i n e  
load tx-data, ASCII-LF 
c a l l  tx-one-byte 
; t r a n s m  
load tx-data, ASCII-CR 
280 
c a l l  tx-one-byte 
; t r a n s m  
load tx-data, ASCII-SP 
c a I I 
tx-one-byte 
; t r a n s m  
t LF 
t CR 
t SP 

396 
PICOBLAZE 110 INTERFACE 
c a l l  tx-one-byte 
; t r a n s m i t  SP 
; i n i t i a l i z e  t h e  l o o p  i n d e x  and mask 
load s 7 ,  20 
; s e t  mask t o  0 0 1 0 ~ 0 0 0 0  
; l o o p  body 
load t x - d a t a ,  ASCII-1 
; l o a d  d e f a u l t  A S C I I  1 
jump n z ,  tx-01 
; t h e  b i t  i s  1 
load t x - d a t a ,  ASCII-0; 
; t h e  b i t  i s  0 ,  l o a d  A S C I I  0 
c a l l  tx-one-byte 
; t r a n s m i t  t h e  A S C I I  1 o r  0 
srO s7 
; s h i f t  mask b i t  
sub 
i ,  01 
; d e c  l o o p  i n d e x  
jump n z ,  tx-loop 
; l o o p  n o t  r e a c h  0 y e t  
; d o n e  w i t h  l o o p ,  send A S C I I  s p a c e  
3w 
load tx-data, ASCII-SP 
; l o a d  A S C I I  SP 
c a l l  tx-one-byte 
; t r a n s m i t  SP 
return 
28s 
load i ,  06 
; a d d r  used a s  l o o p  i n d e x  
tx-loop : 
290 
t e s t  s 7 ,  s4 
; c h e c k  t h e  b i t  
tx-01: 
295 
; u p d a t e  l o o p  i n d e x  and mask 
.___________________--------_--------_-------------------- 
,_______________________________________----------_------- 
30s ; r o u t i n e  : d i s p - r a m - d a t a  
; f u n c t i o n :  8 - b y t e  
d a t a  i n  f o r m  of 
; i n p u t  r e g i s t e r :  
0 0  11 2 2  3 3  4 4  5 5  6 6  77 8 8  
s 4 :  ram b a s e  a d d r e s s  ( x x x 0 0 0 )  
110 ; temp r e g i s t e r  : i , addr , d a t a  
.___________________-------------------------------------- 
,___________________--------_----------------------------- 
disp-ram-data: 
; i n i t i a l i z e  t h e  l o o p  i n d e x  and mask 
load i ,  0 8  
; a d d r  used a s  l o o p  i n d e x  
; l o o p  body 
load addr, s 4  
add a d d r ,  i 
sub a d d r ,  01 
; c a l c u l a t e  a d d r  o f f s e t  
320 
; s e n d  u p p e r  n i b b l e  
fetch d a t a ,  (addr) 
c a l l  get-upper-nibble 
c a l l  hex-to-ascii 
; c o n v e r t  t o  a s c i i  
load t x - d a t a ,  data 
; s e n d  l o w e r  n i b b l e  
f e t c h  d a t a ,  (addr) 
c a l l  get-lower-nibble 
c a l l  hex-to-ascii 
; c o n v e r t  t o  a s c i i  
330 
load tx-data, data 
c a l l  tx-one-byte 
; s e n d  a s p a c e  
load t x - d a t a ,  ASCII-SP; 
c a l l  tx-one-byte 
; t r a n s m i t  SP 
3 1 5  d-ram-loop : 
'2s 
c a l l  tx-one-byte 
33s 
sub i ,  01 
; d e c  l o o p  i n d e x  

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
397 
jump n z ,  d-ram-loop 
; l o o p  n o t  r e a c h  0 y e t  
return 
._______________________________________------------------ 
,_______________________________________--------------
; r o u t i n e  : t x - o n e - b y t e  
755 ; f u n c t i o n :  w a i t  u n t i l  u a r t  t x  f i f o  n o t  f u l l ;  
t h e n  w r i t e  a b y t e  t o  f i f o  
; i n p u t  r e g i s t e r :  t x - d a t a  
; temp r e g i s t e r :  
s 6 :  read p o r t  f l a g  
260 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
t x - o n e - b y t e  : 
input s 6 ,  r d - f  l a g - p o r t  
t e s t  s 6 ,  08 
; c h e c k  u a r t - t x - f u l l  
jump n z ,  t x - o n e - b y t e  
; y e s  , k e e p  o n  w a i t i n g  
365 
output t x - d a t a ,  u a r t - t x - p o r t  
; n o ,  w r i t e  t o  u a r t  t x  f i f o  
return 
.---------__________----------------------------------_--- 
,---------__________-------------------------------------- 
; r o u t i n e  : s q u a r e  
370 ; f u n c t i o n :  c a l c u l a t e  a + a  -+ b*b 
d a t a / r e s u l t  s t o r e d  in ram s t a r t e d  w /  SQ-BASEADDR 
; temp r e g i s t e r :  s 3 ,  s 4 ,  s5, s 6 ,  d a t a  
s q u a r e  ; 
,_--___--_______________________________------------------ 
375 
; c a l c u l a t e  a*a 
fe tc h  s3, a - l s b  
; l o a d  a 
f e t c h  s 4 ,  a - l s b  
; l o a d  a 
c a l l  m u l t - h a r d  
; c a l c u l a t e  a*a 
s t o r e  s 6 ,  a a - l s b  
; s t o r e  l o w e r  b y t e  o f  a*a 
180 
st or e s5, aa-msb 
; s t o r e  u p p e r  b y t e  o f  a*a 
; c a l c u l a t e  b * b  
fe tc h  s3, b - l s b  
; l o a d  b 
f e t c h  s 4 ,  b - l s b  
; l o a d  b 
c a l l  m u l t - h a r d  
; c a l c u l a t e  b * b  
38s 
st or e 9 6 ,  b b - l s b  
; s t o r e  l o w e r  b y t e  o f  b * b  
st or e s 5 ,  bb-msb 
; s t o r e  u p p e r  b y t e  o f  b*b 
; c a l c u l a t e  a*a+b*b 
f e t c h  d a t a ,  a a - l s b  
; g e t  l o w e r  b y t e  o f  a*a 
340 ; r o u t i n e  : h e x - t o - a s c i i  
; f u n c t i o n :  c o n v e r t  a hex number t o  a s c i i  code 
; i n p u t  r e g i s t e r :  data 
add 3 0  f o r  0 - 9 ,  add 3 7  f o r  A-F 
34s h e x - t o - a s c i i  : 
compare d a t a ,  Oa 
jump c ,  add-30 
add d a t a ,  07 
is0 
add d a t a ,  30 
return 
add-30 : 
; O  t o  9 ,  o f f s e t  30 
; a  to f ,  e x t r a  o f f s e t  0 7  

398 
PICOBLAZE 110 INTERFACE 
add d a t a ,  s6 
390 
store d a t a ,  aabb-lsb 
fetch data, aa-msb 
addcy data, s5 
s t o r e  data, aabb-msb 
load d a t a ,  00 
s t o r e  d a t a ,  aabb-cout 
return 
395 
addcy d a t a ,  00 
; a d d  l o w e r  b y t e  of a*a+b*b 
; s t o r e  l o w e r  b y t e  of a*a+b*b 
; g e t  u p p e r  b y t e  of a*a 
; a d d  u p p e r  b y t e  o f  a*a+b*b 
; s t o r e  u p p e r  b y t e  of a*a+b*b 
; c l e a r  d a t a ,  b u t  k e e p  c a r r y  
; g e t  c a r r y  f r o m  p r e v i o u s  + 
; s t o r e  c a r r y  o f  a*a+b*b 
,___________________---------------------_-_-------------- 
4w ; r o u t i n e  : m u l t - h a r d  
; f u n c t i o n :  8 -  b i t  u n s i g n e d  m u l t i p l i c a t i o n  u s i n g  
; i n p u t  r e g i s t e r :  
405 ,' 
s 4 :  m u l t i p l i e r  
e x t e r n a l  c o m b i n a t i o n a l  m u l t i p l i e r ;  
s3 : m u l t i p l i c a n d  
; o u t p u t  r e g i s t e r :  
sS: u p p e r  b y t e  of p r o d u c t  
s 6 :  l o w e r  b y t e  of p r o d u c t  
; temp r e g i s t e r :  
mult-hard: 
J,o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
output s3, mult-src0-port 
output s4, mult-srcl-port 
input s 5 ,  mult-prodl-port 
415 
input s 6 ,  mult-prodo-port 
return 
____________________---------------_--------------------
; T h e  f o l l o w i n g  a r e  t h e  same a s  t h e  p r e v i o u s  L i s t i n g :  
; 
420 ; p r o c - b t n  , l o a d - l e d - p t t n  , d i s p - l e d  
h e x - t o  -1 e d  , g e t  -1 o w e  r - n  i b b l e  , g e t  - u p p  e r - n  i b b 1 e 
16.5.4 VHDL code development 
The new square circuit adds a UART and a combinational multiplier to an I/O interface. 
The former is the module discussed in Section 7.4, and the latter can be inferred from the 
HDL's * operator. The decoding and multiplexing parts of HDL code in Listing 16.2 can be 
expanded to accommodate the two new peripherals. The complete VHDL code is shown in 
Listing 16.4. The detailed I/O port address assignment can be found in the header section 
of Listing 16.3. 
Listing 16.4 PicoBlaze with UART console and multiplier interface 
l i b r a r y  i e e e ;  
use i e e e .  std-logic-1164. a l l  ; 
use ieee . numeric-std. a l l  ; 
e n t i t y  pico-uart is 
5 
p o r t (  
clk, r e s e t :  in std-logic; 

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
399 
sw: in std-logic-vector ( 7  downto 0 )  ; 
btn: in std-logic-vector (3 downto 0) ; 
rx: in std-logic; 
sseg : out std-logic-vector ( 7  downto 0) ; 
tx: out 
std-logic 
10 
an: out std-logic-vector (3 downto 0) ; 
1 ;  
end pico-uart ; 
a r c h i t e c t u r e  arch of pico-uart i s  
15 
20 
25 
30 
35 
40 
-- KCPSM3/ROM s i g n a l s  
s i g n a l  address : std-logic-vector ( 9  downto 0 )  ; 
s i g n a l  instruction: std-logic-vector (17 downto 0) ; 
s i g n a l  port-id: std-logic-vector ( 7  downto 0) ; 
s i g n a l  in-port , out-port : std-logic-vector ( 7  downto 0 )  ; 
s i g n a l  write-strobe , read-strob’e : std-logic ; 
s i g n a l  interrupt , interrupt-ack: std-logic ; 
s i g n a l  kcpsm-reset : std-logic ; 
-- 1 / 0  p o r t  s i g n a l s  
__ o u t p u t  e n a b l e  
s i g n a l  en-d: std-logic-vector (6 downto 0) ; 
-- f o u r - d i g i t  
s e v e n - s e g m e n t  
l e d  d i s p l a y  
s i g n a l  ds3_reg, ds2-reg : std-logic-vector (7 downto 0) ; 
s i g n a l  dsl-reg , ds0-reg : std-logic-vector ( 7  downto 0) ; 
__ two p u s h b u t t o n s  
s i g n a l  btnc-f lag-reg , btnc-f lag-next : std-logic; 
s i g n a l  btns-flag-reg, btns-flag-next: std-logic; 
s i g n a l  set-btnc-f lag, set-btns-f lag: std-logic ; 
s i g n a l  clr-btn-f lag: std-logic; 
s i g n a l  w-data: std-logic-vector ( 7  downto 0) ; 
s i g n a l  rd-uart , rx-not-empty , rx-empty : std-logic ; 
s i g n a l  wr-uart , tx-full : std-logic; 
s i g n a l  rx-char : std-logic-vector ( 7  downto 0) ; 
__ m u 1 t i p  1 i e  r 
s i g n a l  m-srcO-reg, m-srcl-reg: std-logic-vector ( 7  downto 0) ; 
s i g n a l  prod: std-logic-vector (15 downto 0) ; 
u a r t  
__ 
50 
55 
begin _____________--__--_--------------------------------- 
______________-____-____________________------------- 
45 
-- 
__ 
1 / 0  m o d u l e s  
disp-unit : e n t i t y  work. disp-mux 
________________________________________------------- 
__ ___________------------------------------------------ 
p o r t  map( 
clk=>clk, reset=>’O’ , 
in3=>ds3_reg, in2=>ds2_reg, inl=>dsl-reg, 
inO=>dsO-reg, an=>an, sseg=>sseg) ; 
uart-unit : e n t i t y  work. uart (str-arch) 
p o r t  map( 
clk=>clk, reset=>reset , rd-uart=>rd-uart, 
wr-uart=>wr-uart , rx=>rx, 
w-data=>out-port , tx-full=>tx-full, 
rx-empty=>rx-empty, r-data=>rx-char, tx=>tx); 
btnc-db-unit : e n t i t y  work. debounce 

400 
60 
65 
70 
75 
80 
105 
I10 
PICOBLAZE I/O INTERFACE 
port map( 
clk=>clk, reset=>reset , sw=>btn (0) , 
db-level=>open , db-tick=>set-btnc-f lag) ; 
btns-db-unit : entity work. debounce 
port map( 
clk=>clk, reset=>reset , sw=>btn(l), 
db-level=>open, db-tick=>set-btns-flag); 
-- c o m b i n a t i o n a l  m u 1  t i p 1  i e  r 
prod <= std-logic-vector 
(unsigned(m-srcO-reg) * unsigned(m-srcl-reg)); 
________________________________________--------------- 
..................................................... 
__ 
KCPSM and ROM i n s t a n t i a t i o n  
proc-unit : entity work. kcpsm3 
___________-_____-__-----_--_------------------------ 
--______________________________________--_-_--_---_--_ 
port map( 
clk=>clk, reset =>kcpsm-reset , 
address=>address , instruction=>instruction , 
port-id=>port-id, w r i t e - s t r o b e = > w r i t e - s t r o b e ,  
out-port=>out-port , read-strobe=>read-strobe , 
in-port=>in-port , interrupt=>interrupt , 
interrupt-ack=>interrupt-ack); 
rom-unit : entity work. uart-rom 
port map( 
clk = >  clk, address=>address , 
instruction=>instruction); 
-- u n u s e d  i n p u t s  on p r o c e s s o r  
kcpsm-reset <= ’ 0 ’ ;  
interrupt <= ’ 0 ’ ;  
__ 
o u t p u t  i n t e r f a c e  
__ 
o u t p o r t  p o r t  i d :  
__ 
0 x 0 0 :  dsO 
__ 
0 x 0 1 :  d s l  
__ 
0 x 0 2 :  d s 2  
__ 
0 x 0 3 :  d s 3  
__ 
0 x 0 4 :  u a r t - t x - f i f o  
__ 
0 x 0 5 :  m - s r c 0  
-_ 
0 x 0 6 :  m - s r c l  
-_ 
r e g i s t e r s  
process (clk) 
begin 
____________________-------------------------------
__ ____________________--------------------------------- 
____________________--------_-----------------------
--______________________________________--------------- 
____________________--------------------------------- 
--______________________________________--------------- 
if (clk ’ event and clk= ’ 1 ’ ) then 
if en_d(0)=’lJ then ds0-reg <= out-port; end if; 
if en-d(l)= ’1 
then dsl-reg <= out-port; end if; 
if en-d(2)= ’1 then ds2-reg <= out-port; end if; 
if en-d(3)=’lJ then ds3-reg <= out-port; end if; 
if en-d(5)= ’1’ then m-src0-reg <= out-port ; end if; 
if en-d(6)=’lJ then m-srcl-reg <= out-port; end if; 
end if ; 
end process; 
__ d e c o d i n g  c i r c u i t  f o r  e n a b l e  s i g n a l s  

SQUARE PROGRAM WITH A COMBINATIONAL MULTIPLIER AND UART CONSOLE 
401 
I15 
I20 
I25 
I30 
I35 
140 
145 
I50 
I55 
160 
I65 
process (port-id, write-strobe) 
begin 
en-d <= ( o t h e r s = > ' O ' ) ;  
if write-strobe= 1 
then 
case port-id(2 downto 0) i s  
when " 0 0 0 "  => en-d < = " 0 0 0 0 0 0 1 " ;  
when " 0 0 1 "  => en-d <="OOOOOlO"; 
when " 0 1 0 "  => en-d < = " O O O O I O O ' l ;  
when " 0 1 1 "  => en-d < = " 0 0 0 1 0 0 0 " ;  
when " 1 0 0 "  => en-d < = " 0 0 1 0 0 0 0 " ;  
when " 1 0 1 "  = >  en-d <="OlOOOOO"; 
when o t h e r s  => en-d < = " 1 0 0 0 0 0 0 " ;  
end c a s e ;  
end if ; 
end p r o c e s s ;  
wr-uart <= en-d(4) ; 
__ 
i n p u t  i n t e r f a c e  
__ 
i n p u t  p o r t  i d  
-_ 
0 x 0 0 :  f l a g  
__ 
0 x 0 1 :  s w i t c h  
__ 
0 x 0 2 :  u a r t - r x - f i f o  
__ 
0 x 0 3 :  p r o d  l o w e r  b y t e  
__ 
0 x 0 4  : p r o d  u p p e r  b y t e  
__ i n p u t  r e g i s t e r  ( f o r  f l a g s )  
process (clk) 
begin 
____________________--------------------------------- 
--__________________----------------------------------- 
____________________-------------------------------
________________________________________------------- 
__ 
____________________----------------------------------- 
____________________--------------------------------- 
if (clk'event and clk='l') 
then 
btnc-flag-reg <= btnc-flag-next; 
btns-flag-reg <= btns-flag-next; 
end if ; 
end p r o c e s s ;  
btnc-f lag-next <= 
1 
when set-btnc-f l a g =  1 
else 
' 0 '  when clr_btn-flag='l' e l s e  
btnc-flag-reg; 
btns-f lag-next <= '1 ' when set-btns-f l a g = '  1 
e l s e  
' 0 '  when clr-btn-flag='l' else 
btns-flag-reg; 
__ d e c o d i n g  c i r c u i t  f o r  c l e a r  s i g n a l s  
clr-btn-f lag < = '  1 
when read-strobe= 1 
and 
port-id(2 downto O ) = " O O O "  
else 
' O J ;  
rd-uart <= '1' when read-strobe='l' and 
port-id(2 downto O ) = " O l O "  
else 
' 0 ' ;  
__ i n p u t  mu1 t i p 1  e x i n g  
rx-not-empty <= not rx-empty; 
process (port-id , tx-full , rx-not-empty , 
begin 
btns-flag-reg , btnc-flag-reg , sw, rx-char ,prod) 

402 
PICOBLAZE 110 INTERFACE 
I70 
I75 
case port-id(2 downto 0 )  is 
when “ 0 0 0 ”  => 
in-port <= “ 0 0 0 0 ”  & tx-full & rx-not-empty & 
btns-flag-reg & btnc-flag-reg; 
when 
‘I 0 0 1 
= > 
when “01O1’ => 
when “ 0 1 1 “  => 
when others => 
in-port <= s w ;  
in-port <= rx-char; 
in-port <=prod ( 7  downto 0 )  ; 
in-port <= prod(l5 downto 8); 
end c a s e ;  
end p r o c e s s ;  
180 end arch; 
16.6 BIBLIOGRAPHIC NOTES 
The basic bibliographic information for this chapter is similar to that for Chapter 14. The 
downloaded kcpsm file contains a comprehensive UART and timer design example. The 
Xilinx Web site has pages for “PicoBlaze Forum” and “PicoBlaze User Resources,” where 
additional PicoBlaze examples are available. 
16.7 SUGGESTED EXPERIMENTS 
16.7.1 Low-frequency counter I 
An accurate low-frequency counter is discussed in Section 6.3.5. We can treat the period 
counter, division circuit, and binary-to-BCD conversion circuit as three YO modules, and 
replace the top-level FSM with PicoBlaze. Design the I/O interface, derive the assembly 
and HDL codes, compile and synthesize the circuit, and verify its operation. 
16.7.2 Low-frequency counter II 
We can reduce the hardware of the frequency counter of Experiment 16.7.1 by replacing the 
division circuit and binary-to-BCD conversion circuit with software subroutines. Redesign 
the IiO interface, derive the assembly and HDL codes, compile and synthesize the circuit, 
and verify its operation. 
16.7.3 Auto-scaled low-frequency counter 
An auto-scaled low-frequency counter is discussed in Experiment 6.5.5. We can use Pi- 
coBlaze to perform all non-time-critical functions. Redesign the circuit with PicoBlaze and 
minimal external hardware. Derive the assembly and HDL codes, compile and synthesize 
the circuit, and verify its operation. 

SUGGESTED EXPERIMENTS 
403 
16.7.4 Basic reaction timer with a software timer 
The reaction timer is discussed in Experiment 6.5.6. We can redesign the circuit using 
PicoBlaze. One task of the design is to keep track of the elapsed time interval. This can be 
done by a software counting routine. Recall that a 50-MHz clock is used on the prototyping 
board and each instruction takes two clock cycles. We can create a counting loop to record 
the number of instructions executed and derive the time interval accordingly. Since the 
interval is at least in the millisecond range, multiple registers are needed for this purpose. 
Design the I/O interface, derive the assembly and HDL codes, compile and synthesize the 
circuit, and verify its operation. 
16.7.5 Basic reaction timer with a hardware timer 
We can repeat Experiment 16.7.4 with a customized hardware timer. The timer should be 
treated as an I/O peripheral. PicoBlaze can output a command to clear, start, or pause the 
timer, and can input the counter’s content. Design the I/O interface, derive the assembly 
and HDL codes, compile and synthesize the circuit, and verify its operation. 
16.7.6 Enhanced reaction timer 
An enhanced reaction timer keeps track of the last four response times and the fastest 
response time, and displays the data on Windows HyperTerrninal. We can design a console 
similar to that of Section 16.5. There should be three commands: 
0 c: clears all data 
0 f :  displays the fastest response 
0 r: displays the time of the last four responses 
0 All other characters: displays “error” 
Expand the design in Experiment 16.7.4 or 16.7.5 to include this feature. Derive the 
assembly and HDL codes, compile and synthesize the circuit, and verify its operation. 
16.7.7 Small-screen mouse scribble circuit 
A small-screen mouse scribble circuit is discussed in Experiment 12.7.10. We can use 
PicoBlaze to monitor the activities of the mouse and update the video memory accordingly. 
Design the I/O interface, derive the assembly and HDL codes, compile and synthesize the 
circuit, and verify its operation. 
16.7.8 Full-screen mouse scribble circuit 
A full-screen mouse scribble circuit is discussed in Experiment 12.7.11. We can use Pi- 
coBlaze to monitor the activities of the mouse and update the video memory accordingly. 
Design the I/O interface, derive the assembly and HDL codes, compile and synthesize the 
circuit, and verify its operation. 
16.7.9 Enhanced rotating banner 
A VGA rotating banner circuit is discussed in Experiment 13.6.1. Instead of a fixed message, 
we can enhance this circuit by using a keyboard to enter the message dynamically. Assume 

404 
PICOBLAZE 110 INTERFACE 
that the message buffer is 20 characters long and its characters are updated in a first-in- 
first-out fashion. Redesign the circuit with PicoBlaze. Design the I/O interface, derive the 
assembly and HDL codes, compile and synthesize the circuit, and verify its operation. 
16.7.1 0 Pong game 
The complete pong game is discussed in Section 13.4. Some functions of the design can 
be implemented by PicoBlaze: 
0 Top-level control FSM 
0 Top-level two-second timer and two-digit decade counter 
0 The circuit that updates the paddle position, ball position, and ball velocities in 
Modify the original circuit, design the I/O interface, derive the assembly and HDL codes, 
compile and synthesize the circuit, and verify its operation. 
Listing 12.5 
16.7.1 1 Text editor 
A UART terminal is discussed in Experiment 13.6.5. We can use PicoBlaze to obtain data 
and commands from the UART and update the tile memory accordingly. Design the I/O 
interface, derive the assembly and HDL codes, compile and synthesize the circuit, and 
verify its operation. 

CHAPTER 17 
PICOBLAZE INTERRUPT INTERFACE 
17.1 INTRODUCTION 
During normal program execution, a microcontroller polls the I/O peripherals (i.e., checks 
the status signals) and determines the course of action accordingly. An I/O peripheral 
is passive and waits for its turn. The interrupt is a mechanism that allows an external 
I/O peripheral to initiate the operation. It, as the name shows, interrupts normal program 
execution and starts a service routine for the I/O peripheral. For a microcontroller, the 
interrupt is usually reserved for a time-critical peripheral operation, which must be processed 
immediately. The PicoBlaze microcontroller provides support for simple interrupt-handling 
capability. In this chapter, we examine the PicoBlaze’s interrupt mechanism and use an 
example to illustrate software and interface development. 
17.2 INTERRUPT HANDLING IN PICOBLAZE 
Interrupt handling is a coordinated effort between hardware and software. When an external 
peripheral needs service through interrupt, it asserts the interrupt signal of PicoBlaze. If 
the interrupt service is enabled, PicoBlaze completes execution of the current instruction, 
activates the interrupt-ack signal to acknowledge the acceptance of the interrupt request, 
and then implicitly executes the call 3FF instruction. When the instruction is executed, the 
current content of the program counter is saved in stack and the 3FF address is loaded to 
the programmer counter. Note that the 3FF address is the last location in the instruction 
FPGA Prototyping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
405 

406 
PICOBLAZE INTERRUPT INTERFACE 
Figure 17.1 Interrupted flow. 
memory and serves as the starting point of the interrupt service routine. It usually contains 
a jump instruction, which leads to the body of the service routine. The service should be 
ended with a returni instruction to return to the interrupted point and resume the previous 
execution. 
17.2.1 Software processing 
Four instructions are associated with interrupt, as discussed in Section 14.5.9. The en- 
able interrupt and disable interrupt instructions enable and disable the interrupt request, 
and the two return-from-interrupt instructions, returni enable and returni disable, return 
execution to the interrupted point. 
A typical program segment with interrupt service routine is shown in Figure 17.1. It 
generally consists of the following segments: 
0 An initial enable interrupt instruction: used to enable the interrupt service. This is 
needed since the interrupt request is disabled by default. 

INTERRUPT HANDLING IN PICOBLAZE 
407 
Figure 17.2 Timing diagram of an interrupt event. 
0 A jump instruction in the end of the instruction memory (i.e., 3FF): leads to the 
Interrupt service routine: the code that actually performs the requested service. The 
A representative flow of an interrupt event is shown in Figure 17.1. We assume that 
the external I/O assert the interrupt signal in the middle of the add SO, s3 instruction. 
PicoBlaze performs the following steps in sequence: 
1. Completes execution of the current execution. 
2. Saves the content of the program counter, clears the interrupt flag, i, to zero, preserves 
3. Executes the jump isr instruction in the 3FF address. 
4. Performs the service routine. 
5. Executes the returni instruction, in which the saved program counter and flags are 
6. Resumes the interrupted program and executes the sub s5,OI instruction. 
interrupt service routine. 
routine should be ended with a returni instruction. 
the zero and carry flags, and loads the program counter with 3FF. 
restored. 
17.2.2 Timing 
The detailed timing diagram of the previous interrupt event is shown in Figure 17.2. The 
basic sequence is: 
0 At tl: The external interrupt interface asserts the interrupt signal. PicoBlaze 
continues the normal operation to complete execution of the current add sO,s3 
instruction. 
0 At t2: PicoBlaze recognizes the interrupt and aborts the next instruction (sub s5,OI) 
and implicitly executes the call 3FF instruction. 
0 At t3: PicoBlaze asserts the interrupt-ack signal. It also saves the address of the 
sub s5,OI instruction, preserves the zero and carry flags, and clears the interrupt flag 
to 0. 
0 At t4: PicoBlaze loads and executes the instruction in address 3FF, jump isr. 
The external interrupt interface circuit acknowledges the interrupt -ack signal and 
deasserts the interrupt signal. 

408 
PICOBLAZE INTERRUPT INTERFACE 
int request - 
set 
flag - 
+ clr 
'flag 
FF 
in-port 
out-port 
reset 
port-id 
readstrobe 
write-strobe 
instruction 
interrupt 
interrupt-ack 
address 
KCPSM3 
> 
Figure 17.3 Interrupt interface with a single request 
0 At t5: PicoBlaze starts the interrupt service routine. 
Note that it requires up to five clock cycles from the time that the interrupt signal is 
asserted to the time that the first instruction of interrupt service routine is executed. 
17.3 EXTERNAL INTERFACE 
The nature of the interrupt request is similar to that of a single-access port discussed in 
Section 16.3.2. After the request is accepted, it must be cleared so that the same request 
will not be processed multiple times. The flag FF discussed in Section 7.2.4 can be used 
for this purpose. 
17.3.1 Single interrupt request 
If there is only one I/O peripheral in a PicoBlaze system that can generate an interrupt 
request, we just need a single flag FF in the interrupt interface circuit, as shown in Fig- 
ure 17.3. When the service is required, the external I/O circuit asserted the int request 
signal for one clock cycle, which sets the flag IT to '1' and activates the interrupt input 
of PicoBlaze. If the interrupt is enabled in PicoBlaze, it acknowledges acceptance of the 
request by asserting the interrupt-ack signal for one clock cycle, which clears the flag FF 
to '0'. 
17.3.2 Multiple interrupt requests 
Processing a PicoBlaze system with two or more interrupt requests is more involved. The 
PicoBlaze microcontroller must determine which peripheral issues the request and clear 
the corresponding flag FF after the request is accepted. This needs the coordination of the 
hardware interface and the interrupt service routine. 
The interrupt interface with two requests is shown in Figure 17.4. The two individual 
requests, int request0 and int requestl, are connected to two flag FFs, and the output 
signals of the FFs are passed to an or gate to generate the final interrupt request signal. In 
addition, the two signals are also routed to the input multiplexer. If at least one request 
is asserted, the interrupt signal of PicoBlaze is asserted. When PicoBlaze senses the 
request, it does not know which peripheral or whether both peripherals issue the request. 
The interrupt service routine must first input the two request signals and check their values 
according to the assigned priority, and then perform the corresponding service. 

SOFTWARE DEVELOPMENT CONSIDERATIONS 
409 
Figure 17.4 Interrupt interface with two requests. 
In addition, PicoBlaze also needs to clear the corresponding flag FF. The interrupt-ack 
signal cannot be used for this purpose because it is not known which peripheral’s request 
is accepted when the interrupt-ack signal asserted. Instead, we need to use a special 
output decoding circuit to generate a clear tick. The clr signal of each flag FF is assigned 
to a unique port id. In the interrupt service routine, we add an output instruction after 
determining which interrupt request is accepted. The instruction does not actually output 
any data. It is used to generate a single-clock-cycle tick to clear the corresponding flag FE 
To reduce the software overhead and increase response speed, we can design an interrupt 
controller to facilitate the process. This approach is discussed in Experiment 17.7.5. 
17.4 SOFTWARE DEVELOPMENT CONSIDERATIONS 
17.4.1 Interrupt as an alternative scheduling scheme 
Recall that a microcontroller-based application usually follows a simple polling program 
structure: 
c a l l  initialization-routine 
c a l l  taskl-routine; 
c a l l  task2-routine; 
c a  I I 
taskn-rout ine ; 
jump forever ; 
forever : 
. . .  
Some tasks may involve IiO operations. During execution, the microcontroller checks 
the IiO status in turn and takes actions accordingly. The program structure implicitly 
implements a round-robin schedule, in which each task waits in turn to be executed. This 
scheme can work properly if the loop interval is short enough so that each I/O request can 
be checked and processed in a timely manner. In some applications, there may exist one or 
two time-critical IiO requests that require immediate attention. The interrupt mechanism 
provides a way to alter the original schedule and gives certain tasks higher priorities. 
Since an interrupt can occur at any time, the original loop must consider the frequency 
of interrupt and the required service time of each interrupt request. This can be complicated 
if there are multiple interrupt requests and the service routine is involved. 

410 
PICOBLAZE INTERRUPT INTERFACE 
Figure 17.5 Interrupt interface with a timer. 
17.4.2 Development of an interrupt service routine 
The interrupt service routine is somewhat like a subroutine. It suspends normal program 
execution, performs an independent task, and then resumes the previous execution. How- 
ever, unlike a subroutine call, an interrupt can occur any time. To resume execution later, 
the service routine must save the current state (also known as the context) of the PicoBlaze 
processor. In other words, the service routine must save all registers used in service routine 
computation and then restore them before returning to normal execution. This process is 
known as context switching. 
Since PicoBlaze is a compact 8-bit microcontroller, the hardware support for context 
switching and scheduling is very limited. We should use the polling scheme in general and 
keep the interrupt structure simple and straightforward. Instead of worrying about context 
switching, we can allocate several dedicated registers to be used exclusively in the interrupt 
service routine. 
17.5 DESIGN EXAMPLE 
The square circuit of Chapter 16 uses a seven-segment LED display to show the values of 
input operands and result. We use the predesigned LED multiplexing module, dispmux, 
for this purpose. The design of this module is discussed in Section 4.5.1. It consists of a 
large counter to generate slow enable pulses and a multiplexing circuit to route the input 
patterns. 
To save hardware, we can implement this functionality in software and let PicoBlaze 
control the 4-bit enable signal, an, and the 8-bit LED signal, sseg, of the four-digit LED 
display directly. To generate a visually continuous pattern, the enable pulse and LED 
patterns must be refreshed at a constant rate, as shown in Figure 4.6. While using pure 
software to keep track of time is possible, the code is tedious and error-prone. We use 
a dedicated hardware timer and PicoBlaze’s interrupt facility to perform the task. The 
required hardware and software modifications are illustrated in the following subsections. 
17.5.1 Interrupt interface 
The block diagram of the timer and interrupt interface, as well as the new output buffers, is 
shown in Figure 17.5. The timer is a mod-500 counter and generates a single-clock-cycle 
tick every 500 clock cycles. Since the 50-MHz clock is used for the timer, the period of 
the tick is 0.01 ms. Because there is only one interrupt request, we use the flag FF scheme 

DESIGN EXAMPLE 
41 1 
discussed in Section 17.3.1 for the interrupt interface. The tick sets the flag FF and activates 
the interrupt signal of PicoBlaze. 
17.5.2 Interrupt service routine development 
To keep track of the elapsed time, PicoBlaze counts the number of timer ticks. As discussed 
in Section 17.4.2, we want to keep the interrupt service routine simple and use two dedicated 
registers, countlnsb and count-lsb, for this task. The two registers are cascaded as a 
16-bit register and are incremented each time the interrupt service routine is called. They 
can count to 0.6 second (i.e., 216 * 0.01 ms). The interrupt-related code segment is 
namereg se, count-msb 
; t i m e r  t i c k  c o u n t  8 MSBs 
namereg s f ,  count-lsb 
; t i m e r  t i c k  c o u n t  8 LSBs 
; i n t e r r u p t  s e r v i c e  r o u t i n e  
int-service-routine: 
add count-lsb, 01 
; i n c  1 6 - b i t  
c o u n t e r  
addcy count-msb, 00 
returni enable 
; i n t e r r u p t  v e c t o r  
address 3FF 
jump int - s erv i c e -I out ine 
17.5.3 Assembly code development 
With the timing information available, we can derive a new subroutine, displayrmux-out, 
for the LED display. This routine replaces the disp-led routine used in Chapter 16. Two 
new output buffers are needed to store the an and sseg signals, as shown in Figure 17.5. The 
main task of the subroutine is to store the an pattern, which can be "1 1 lo", "1 101", "101 l", 
or "01 1 l", and the corresponding seven-segment LED pattern to the registers periodically. 
As discussed in Section 4.5.1, the refreshing rate should be around from a few hundred to 
a few thousand hertz. In our code we update these registers every 21° ticks, which is about 
10 ms. We also use a register, led-pos, to keep track of the current display position (i.e., 
one of the four LED displays). 
To incorporate the new interrupt feature into Listing 16.3, the code is modified as follows: 
0 Add new port and register definitions. 
Replace the original disp-led routine with the displaylnux-out routine. 
Add the enable interrupt instruction in the i n i t  routine to enable interrupt handling. 
Initialize the led-pos, countlnsb, and count-lsb registers in the i n i t  routine. 
Add the interrupt service routine. 
The modified portion of the assembly code is shown in Listing 17.1. 
Listing 17.1 
Square program with interrupt interface 
; r e g i s t e r  a l i a s  
namereg sb, led-pos 
; l e d  d i s p  p o s i t i o n  ( 0 ,  I ,  2 o r  3 )  
namereg se, count-msb 
; t i m e r  t i c k  c o u n t  8 MSBs 
5 namereg s f ,  count-lsb 
; t i m e r  t i c k  c o u n t  8 LSBs 
. . .  

41 2 
PICOBLAZE INTERRUPT INTERFACE 
; o u t p u t  p o r t  d e f i n i t i o n s  
constant an-port , 00 
constant sseg-port , 01 
; main p r o g r a m  
c a l l  init 
forever : 
; m a i n  l o o p  body 
c a l l  square 
; c a l c u l a t e  s q u a r e  
c a l l  load-led-pttn 
; s t o r e  l e d  p a t t e r n s  t o  ram 
c a l l  display-mux-out 
; m u l t i p l e x  l e d  p a t t e r n s  
jump forever 
10 . . .  
; i n  i t i a 1 i z a  t i o n 
15 
c a l l  proc-btn 
; c h e c k  & p r o c e s s  b u t t o n s  
20 
,-______________________________________--_---_----------- 
; r o u t i n e  : i n i t  
init : 
,_______________________________________------------------ 
25 
enable interrupt 
load led-pos, 00 
load count-msb, 00 
load count-lsb, 00 
30 
return 
.-------_-______________________________------------------ 
,___-___________________________________------------------ 
; r o u t i n e  : d i s p l a y - m u x - o u t  
; f u n c t i o n :  g e n e r a t e  e n a b l e  p u l s e  & l e d  p a t t e r n  
; i n p u t  r e g i s t e r :  
35 ; 
f o r  4 -  d i g i t  7 - s e g m e n t  
l e d  d i s p l a y  
c o u n t - m s b  , c o u n t - l s b  : t i m e r  c o u n t  
l e d - p o s  : c u r r e n t  l e d  p o s i t i o n  
40 ; 
l e d - p o s  : u p d a t e d  l e d  p o s i t i o n  
; o u t p u t  r e g i s t e r :  
; tmp r e g i s t e r :  d a t a ,  a d d r  
display-mux-out : 
.-------________________________________------------------ 
,------__--_____________________________------------------ 
compare count-msb , 0 2  
; c o u n t  =00000100~00000000 
; c l e a r  t i m e  c o u n t e r  ( c o u n t  > 2 0 )  
load count-lsb, 00 
load count-msb, 00 
; u p d a t e  7 -  s e g m e n t  l e d  p o s i t i o n  
compare led-pos, 04 
jump n z ,  gen-an-signal 
load led-post 00 
; l e d - p o s  wraps around 
45 
jump c ,  mux-out-done 
50 
add led-pos, 01 
gen-an-signal : 
55 
; g e n e r a t e  4 - b i t  
anode e n a b l e  s i g n a l  
load data, OE 
; x x x x - 1 1  I 0  
compare led-pos, 00 
jump z ,  shift-an-0 
compare led-pos, 0 1  

DESIGN EXAMPLE 
41 3 
h~ 
jump z ,  shift-an-1 
compare l e d - p o s ,  02 
jump z ,  shift-an-2 
s l l  data 
; s h i f t  1 1 1 0  3 t i m e s  
65 
s l l  data 
; s h i f t  1 1 1 0  2 t i m e s  
s l l  d a t a  
; s h i f t  1 1 1 0  1 t i m e s  
output data, an-port 
70 
; o u t p u t  7 - s e g  
l e d  p a t t e r n  
load a d d r ,  led0 
add a d d r ,  led-pos 
f e t c h  d a t a ,  (addr) 
output d a t a ,  sseg-port 
75 mux-out-done : 
return 
shift-an-2: 
shift-an-1: 
shift-an-0 : 
3' r o u t i n e  : i n t e r r u p t  s e r v i c e  r o u t i n e  
SO ; f u n c t i o n  : i n c r e m e n t  1 6 -  b i t  c o u n t e r  
; 
i n p u t  r e g i s t e r :  
; 
o u t p u t  r e g i s t e r :  
count-msb , c o u n t - l s b  : t i m e r  c o u n t  
count-msb , c o u n t - l s b  : i n c r e m e n t e d  
85 ,' 
int-service-routine: 
add count-lsb, 01 
; i n c  16- b i t  c o u n t e r  
addcy count-msb I 
00 
returni enable 
90 
; i n t e r r u p t  
address 
95 
jump in 
v e c  
3FF 
-se 
o r  
vice-routine 
; T h e  f o l l o w i n g  are t h e  same a s  t h e  p r e v i o u s  L i s t i n g :  
; p r o c - b t n  , l o a d - l e d - p t t n  , 
k e x  - t o  -1 e d  , 
; s q u a r e ,  m u l t - s o f t  
I~ ; 
g e t  -10 w e  r - n  i b  b l e  , g e t  - u p p  e r - n  i b b 1 e 
, 
. . .  
~~~~ 
~~~~ 
~~~~ 
~~~~ 
~~~~~ 
~~~~ 
~ 
17.5.4 VHDL code development 
The I/O interface of the interrupt-based square circuit includes three parts. The input 
interface is similar to that in Section 16.4. The output interface consists of a decoding 
circuit and two output registers for the an and sseg signals, as shown on the right of 
Figure 17.5. The interrupt interface consists of a timer and a flag FF, as shown on the 

414 
PICOBLAZE INTERRUPT INTERFACE 
left of Figure 17.5. The HDL code basically follows the block diagram and is shown in 
Listing 17.2. 
Listing 17.2 
library ieee; 
use ieee. std-logic-1164. all ; 
use ieee. numeric-std. all ; 
entity pico-int is 
PicoBlaze-based square circuit with interrupt 
5 
port( 
clk, reset: in std-logic; 
sw: in std-logic-vector (7 downto 0) ; 
btn: in std-logic-vector (1 downto 0) ; 
an: out std-logic-vector (3 downto 0) ; 
10 
sseg : out std-logic-vector ( 7  downto 0) 
1 ;  
end pico-int ; 
architecture arch of pico-int is 
15 
-- KCPSM3/ROM s i g n a l s  
signal address : std-logic-vector (9 downto 0) ; 
signal instruction: std-logic-vector (17 downto 0) ; 
signal port-id: std-logic-vector (7 downto 0) ; 
signal in-port , out-port : std-logic-vector (7 downto 0) ; 
signal interrupt , interrupt-ack: std-logic ; 
-- 1 / 0  p o r t  s i g n a l s  
__ o u t p u t  e n a b l e  
signal en-d: std-logic-vector (1 downto 0) ; 
signal sseg-reg : std-logic-vector (7 downto 0) ; 
signal an-reg : std-logic-vector (3 downto 0) ; 
-- t w o  p u s h b u t t o n s  
signal btnc-f lag-reg , btnc-f lag-next : std-logic ; 
30 
signal btns-f lag-reg , btns-f lag-next : std-logic; 
signal set-btnc-f lag, set-btns-f lag: std-logic; 
signal clr-btn-f lag: std-logic; 
__ i n t e r r u p t  - r  e 1 a t e d  
signal timer-reg , timer-next : unsigned(8 downto 0) ; 
signal timer-flag-reg , timer-flag-next : std-logic; 
20 
signal write-strobe , read-strobe : std-logic; 
25 
-- f o u r - d i g i t  
s e v e n - s e g m e n t  
l e d  d i s p l a y  
s i g  n a  1 s 
35 
signal ten-us-tick: std-logic; 
begin 
__ 
__ 
1 / 0  m o d u l e s  
btnc-db-unit: entity work.debounce 
40 
-- 
port map( 
clk=>clk , reset=>reset , sw=>btn (0) , 
db-level=>open, db-tick=>set-btnc-flag); 
45 
btns-db-unit : entity work. debounce 
port map( 
clk=>clk, reset=>reset , sw=>btn(l) , 
db-level=>open, db-tick=>set-btns-flag); 
_- 

DESIGN EXAMPLE 
415 
55 
75 
90 
50 
-- KCPSM and ROM i n s t a n t i a t i o n  
--==--------==-----------=-----------===--------======= 
proc-unit : e n t i t y  work. kcpsm3 
port map( 
clk=>clk, reset = > r e s e t ,  
address=>address , instruction=>instruction , 
port-id=>port-id, write-strobe=>write-strobe, 
out-port=>out-port , read-strobe=>read-strobe, 
in-port =>in-port , 
interrupt-ack=>interrupt-ack); 
interrupt => interrupt , 
60 
rom-unit : e n t i t y  work. int-rom 
port map( 
clk => clk, address=>address , 
instruction=>instruction); 
___------__---_____---------------------------------- 
--______________________________________--------------- 
6s 
-- o u t p u t  i n  t e r f a  c e 
__----------------------------------------------------- 
-- 
o u t p o r t  p o r t  i d :  
0x00: an 
__ 
__ 
0 x 0 1 :  ssg 
___------___--_____---------------------------------- 
7” 
--______________________________________--------------- 
__ r e g i s t e r s  
process (clk) 
begin 
i f  (clk ’ event and clk= ’ 1 ’ ) then 
i f  en-d(O)=’l’ then 
end i f  ; 
i f  en-d(l)=’l’ then sseg-reg <= out-port; end i f ;  
an-reg <= out-port(3 downto 0 ) ;  
end i f  ; 
an <= an-reg; 
sseg <= sseg-reg; 
-- decoding c i r c u i t  f o r  enable s i g n a l s  
process (port-id, write-strobe) 
80 
end p r o c e s s ;  
85 
begin 
en-d <= ( o t h e r s = > ’ O ’ ) ;  
i f  write-strobe=’l’ then 
case port-id(0) i s  
when 
’ 0 ’  = >  en-d < = “ 0 1 ” ;  
when others = >  en-d < = “ 1 0 “ ;  
end c a s e ;  
end i f  ; 
end p r o c e s s ;  
___--_---__________---------------------------------- 
--______________________________________--------------- 
95 
-- i n p u t  i n t e r f a c e  
-- 
i n p u t  p o r t  id 
-- 
0x00: f l a g  
_- 
0 x 0 1 :  s w i t c h  
_- 
i n p u t  r e g i s t e r  ( f o r  f l a g s )  
process (clk) 
___------____----__---------------------------------- 
--__________________----------------------------------- 
,w 
____________________----------------------------------- 
____________________--------------------------------

41 6 
PICOBLAZE INTERRUPT INTERFACE 
begin 
if (clk ’ event and clk= ’ 1 ’ 
then 
btnc-flag-reg <= btnc-flag-next; 
btns-flag-reg <= btns-flag-next; 
end if ; 
end p r o c e s s ;  
105 
125 
I30 
135 
I40 
145 
150 
15s 
btnc-flag-next <= ’ 1 ’  when set-btnc-flag=’l’ e l s e  
’ 0 ’  when clr-btn-f l a g =  ’ 1 ’ e l s e  
btnc-flag-reg; 
btns-flag-next <= ’ 1 ’  when set-btns-flag=’l’ e l s e  
’ 0 ’  when clr-btn-flag=’l’ e l s e  
btns-flag-reg; 
__ d e c o d i n g  c i r c u i t  f o r  c l e a r  s i g n a l s  
clr-btn-flag < = ’ l ’  when read-strobe=’l’ and 
port-id(O)=’O’ e l s e  
’ 0 ’ ;  
__ i n p u t  m u l t i p l e x i n g  
p r o c e s s  (port-id,btns-flag-reg,btnc-flag-reg,sw) 
begin 
case port-id(0) i s  
when 
’ 0 ’  => 
in-port <= “000000” & 
btns-flag-reg & btnc-flag-reg; 
when o t h e r s  => 
in-port <= sw; 
end c a s e ;  
end p r o c e s s ;  
-_ 
i n t e r r u p t  i n  t e  r f a  c e  
-- 1 0  us c o u n t e r  
p r o c e s s  (clk) 
begin 
-_________________________________________------------- 
_-______________________________________------------_ 
----------------__-_____________________-------------
---------_-__-__________________________---------
-_ 
if (clk ’ event and clk= ’ 1 ’ ) then 
end i f ;  
end p r o c e s s ;  
timer-next <= ( o t h e r s = > ’ O ’ )  when t i m e r _ r e g = 4 9 9  e l s e  
timer-reg <= timer-next; 
timer-reg+l; 
ten-us-tick <= ’ 1 ’  when tirner_reg=499 e 
-- 1 0  us t i c k  f l a g  
p r o c e s s  (clk) 
begin 
if (clk’event and clk=’l’) then 
end if ; 
end p r o c e s s ;  
timer-flag-reg <= timer-flag-next 
s e  ’ 0 ’ ;  
timer-flag-next <= ’1’ when ten-us-tick=’l’ e l s e  
’ 0 ’  when interrupt-ack= ’ 1 ’  e l s e  
timer-flag-reg; 
__ i n t e r r u p t  r e q u e s t  
interrupt <= timer-flag-reg; 

BIBLIOGRAPHIC NOTES 
41 7 
end arch; 
17.6 BIBLIOGRAPHIC NOTES 
The bibliographic information for this chapter is similar to that for Chapters 14 to 16. 
17.7 SUGGESTED EXPERIMENTS 
17.7.1 Alternative timer interrupt service routine 
The interrupt service routine in Listing 17.1 uses two dedicated registers to record the 
number of timer ticks. The two registers thus cannot be used for other computation. An 
alternative is to use 2 bytes of the data RAM for this purpose and use the registers only 
temporarily in the service routine. Since interrupt can occur anytime, we must save and 
restore the corresponding registers. For example, if the SO and sl registers are used in the 
service routine for computation, their contents must be saved when the service routine is 
invoked and then restored later when the computation is completed. Derive the assembly 
and HDL codes, compile and synthesize the circuit, and verify its operation. 
17.7.2 Programmable timer 
We can replace the mod-500 counter of Section 17.5 with a general mod-rn counter and 
thus make the timer “programmable.” The new timer operates as follows: 
0 m is a 12-bit unsigned number. 
0 ThefourLSBsofrnis”1111”. 
0 The timer has an 8-bit register to store the eight MSBs of rn. The register is treated 
as a new output port of PicoBlaze. 
0 A new pushbutton controls the loading of the register. When it is pressed, PicoBlaze 
inputs the value from the 8-bit switch and outputs the value to the timer’s register. 
Design the new IiO interface, derive the assembly and HDL codes, and compile and syn- 
thesize the circuit. Load different values in the timer and observe what happens to the LED 
display. 
17.7.3 Set-button interrupt service routine 
In the square circuit discussed in Section 16.4, the s button is used to load the a and b 
operands from the 8-bit switch. Its status is polled continuously in the main loop. We can 
revise this portion of the code and use an interrupt mechanism to perform this task. The 
interrupt service routine involves several temporary registers, and they must be saved and 
restored properly, as discussed in Experiment 17.7.1. Design the new I/O interface, derive 
the assembly and HDL codes, compile and synthesize the circuit, and verify its operation. 
17.7.4 Interrupt interface with two requests 
Assume that we want to implement both the timer interrupt request of Listing 17.1 and 
the set-button interrupt request of Experiment 17.7.3 in a PicoBlaze system. Follow the 

418 
PICOBLAZE INTERRUPT INTERFACE 
Figure 17.6 Interrupt interface with a four-request interrupt handler. 
discussion in Section 17.3.2 to design the new interrupt interface and interrupt service 
routine. Derive the assembly and HDL codes, compile and synthesize the circuit, and 
verify its operation. 
17.7.5 Four-request interrupt controller 
An interrupt controller helps the processor to process multiple interrupt requests. The 
block diagram of a four-request interrupt controller is shown in Figure 17.6. The interrupt 
controller should contain four flag FFs and a special priority encoding circuit. If one 
or more interrupt requests are activated, the controller determines which request has the 
highest priority, places its 2-bit code on the req-id port, and asserts the i n t  signal. When 
PicoBlaze asserts the interrupt-ack signal, the controller clears the corresponding flag. 
For simplicity, we assume that int request -3 has the highest priority and intrequest -0 
has the lowest priority. 
Derive HDL code for the interrupt controller and repeat Experiment 17.7.4 using the 
new controller (the two unused interrupt requests can be tied to '0'). 

APPENDIX A 
SAMPLE VHDL TEMPLATES 
A.l 
GENERAL VHDL CONSTRUCTS 
A.1.1 
Overall code structure 
Listing A.l 
Overall code structure 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
5-- 
e n t i t y  d e c l a r a t i o n  
e n t i t y  bin-counter i s  
-- o p t i o n a l  g e n e r i c  d e c l a r a t i o n  
g e n e r i c  ( N :  integer : =  8) ; 
-- p o r t  d e c l a r a t i o n  
10 
p o r t (  
clk, reset: in std-logic; 
-- c l o c k  & r e s e t  
load, en, syn-clr: in std-logic; 
__ i n p u t  c o n t r o l  
d: in std-logic-vector"-1 
downto 0 ) ;  -- i n p u t  data 
max-tick; out std-logic; 
-_ 
o u t p u t  s t a t u s  
15 
q :  out std-logic-vector(N-1 downto 0) -- o u t p u t  data 
) ;  
end bin-counter; 
FPGA Protovping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
41 9 

420 
SAMPLE VHDL TEMPLATES 
__ a r c h  i t  e c t u  re body 
20 a r c h i t e c t u r e  demo-arch of bin-counter i s  
-- c o n s t a n t  d e c l a r a t i o n  
constant M A X :  
integer : =  ( 2 **N -1);  
_- 
i n t e r n a l  s i g n a l  d e c l a r a t i o n  
s i g n a l  r-reg : unsigned (N-1 downto 0) ; 
25 
s i g n a l  r-next : unsigned(N-1 downto 0) ; 
begin 
__ 
_- 
component i n s t a n t i a t i o n  
__ 
30 
-- no i n s t a n t i a t i o n  in t h i s  code 
-- 
-- memory e l e m e n t s  
__ 
35 
-- r e g i s t e r  
process (clk, reset) 
begin 
i f  ( r e s e t = ’ l ’ )  then 
r-reg <= ( o t h e r s = > ’ O ’ ) ;  
r-reg <= r-next; 
40 
e l s i f  (clk’event and clk=’l’) then 
end i f  ; 
end p r o c e s s ;  
45 
-- 
__ c o m b i n a t i o n a l  c i r c u i t s  
-- n e x t - s t a t e  
l o g i c  
r-next <= ( o t h e r s = > ’ O ’ )  when syn-clr=’l’ e l s e  
__ 
so 
unsigned(d) 
when load= ’1 
e l s e  
r-reg + 1 
when en = ’ 1  ’ 
e l s e  
r-reg ; 
_- 
o u t p u t  l o g i c  
q <= std-logic-vector(r-reg); 
55 
max-tick <= ’ 1 ’  when r-reg=MAX e l s e  
> O ’ ;  
end demo-arch ; 
A.1.2 Component instantiation 
Listing A.2 Component instantiation template 
library ieee; 
use i e e e . s t d - l o g i c - l l 6 4 . a l l ;  
e n t i t y  counter-inst i s  
port ( 
5 
clk, reset: in 
std-logic; 
load16, en16, syn-clrl6 : in std-logic; 
d :  in std-logic-vector (15 downto 0) ; 
max-tick8, max-tickl6: out std-logic; 

COMBINATIONAL CIRCUITS 
421 
q :  out std-logic-vector (15 downto 0 )  
10 
1 ; 
end counter-inst; 
architecture st ructur e-ar ch of counter - inst is 
begin 
I 5  
-- i n s t a n t i a t i o n  of 16- b i t  c o u n t e r ,  a l l  p o r t s  used 
counter-16-unit: entity work.bin-counter(demo-arch) 
generic map ( N =  > 16 ) 
port map(clk=>clk, reset=>reset , 
load=>loadl6, en=>enl6, syn-clr=>syn-clrl6, 
20 
d=>d, max_tick=>max_tick16, q=>q); 
__ i n s t a n t i a t i o n  o f  f r e e - r u n n i n g  8 -  b i t  c o u n t e r  
__ w i t h  o n l y  t h e  m a x - t i c k  s i g n a l  
counter-8-unit : entity work. bin-counter 
port map(clk=>clk, reset=>reset , 
25 
load=>’O’, en=>’l’, syn-clr=>’O’, 
d=>“00000000“, max_tick=>max_tick8, q=>open); 
end structure-arch; 
A.2 COMBINATIONAL CIRCUITS 
A.2.1 
Arithmetic operations 
Listing A.3 Arithmetic operations 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. all ; 
entity arith-demo is 
5 
port( 
a ,  b: in std-logic-vector(7 downto 0 ) ;  
diff , inc: out std-logic-vector ( 7  downto 0 )  
) ;  
end arith-demo ; 
architecture arch of arith-demo is 
begin 
10 
signal au, bu, diffu: unsigned(7 downto 0); 
---------___------------------------------- 
____________________----------------------- 
__ 
15 
-- c o n v e r t  i n p u t s  t o  u n s i g n e d / s i g n e d  i n t e r n a l l y  
-- and t h e n  c o n v e r t  t h e  r e s u l t  back 
au <= unsigned(a1; 
bu <= unsigned(b); 
_________---____________________________--- 
____-----_______--------------------------- 
__ 
20 
diffu <= au - bu when (au > bu) else 
diff <= std-logic-vector(diffu); 
bu - au; 
25 
-- c o n v e r t  m u l t i p l e  t i m e s  i n  a s t a t e m e n t  

422 
SAMPLE VHDL TEMPLATES 
A.2.2 
Fixed-amount shift operations 
Listing A.4 Fixed-amount shift operations 
library ieee; 
use ieee. std-logic-1164, a l l  ; 
e n t i t y  fixed-shift-demo i s  
port ( 
5 
a: in std-logic-vector (7 downto 0) ; 
shl, sh2, sh3, rot, swap: out 
std-logic-vector (7 downto 0) 
) ;  
end fixed-shift-demo; 
a r c h i t e c t u r e  arch of f ixed-shift-demo i s  
begin 
10 
-_ 
s h i f t  l e f t  3 p o s i t i o n s  
shl <= a(4 downto 0) & " 0 0 0 "  ; 
sh2 <= " 0 0 0 "  & a(7 downto 3); 
-- s h i f t  r i g h t  3 p o s i t i o n s  and s h i f t i n g  in  s ig n  b i t  
__ ( a r i t h m e t i c  s h i f t )  
sh3 <= a(7) & a(7) & a(7)& 
a(7 downto 3); 
rot <= a(2 downto 0) & a(7 downto 3); 
-- swap two n i b b l e s  
swap <= a(3 downto 0) & a(7 downto 4); 
15 
-- s h i f t  r i g h t  3 p o s i t i o n s  ( l o g i c a l  s h i f t )  
20 
-- r o t a t e  r i g h t  3 p o s i t i o n s  
end arch; 
A.2.3 
Routing with concurrent statements 
Listing A S  Routing with concurrent statements 
library ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  decoderl i s  
port ( 
5 
a: in std-logic-vector (1 downto 0) ; 
en: in std-logic; 
y l ,  y2: out std-logic-vector(3 downto 0) 
) ;  
end decoderl ; 
a r c h i t e c t u r e  concurrent-arch of decoderl i s  
begin 
10 
s i g n a l  s : std-logic-vector ( 2  downto 0) ; 
___________-_____________________________-_-_ 
_________________________________________-_ 
inc <= std-logic-vector(unsigned(a) + 1); 
end arch; 

COMBINATIONAL CIRCUITS 
423 
A.2.4 
Routing with if and case statements 
Listing A.6 
If and case statement templates 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
e n t i t y  decoder2 i s  
port ( 
5 
a: in std-logic-vector (1 downto 0) ; 
e n :  in std-logic; 
y l ,  y2: out std-logic-vector (3 downto 0) 
1 ;  
end decoder2 ; 
a r c h i t e c t u r e  seq-arch of decoder2 i s  
begin 
10 
s i g n a l  s :  std-logic-vector (2 downto 0) ; 
____________________---------_--------------- 
____________________--------_----_--------- 
15 
-- i f  s t a t e m e n t  
____________________----------------------- 
--__________________-__---------------------- 
process (en, a) 
begin 
i f  (en='O') 
then 
yl <= "0000"; 
e l s i f  (a='lOOll) then 
yl <= "0001"; 
e I s i f  (a=" 0 1  'I ) then 
yl <= "0010"; 
e l  s i f  (a=!! 
10 ) then 
yl <= "0100"; 
e l s e  
yl <= "1000"; 
I S  
-- c o n d i t i o n a l  s i g n a l  a ssi gn m e n t s t a t e m e n t  
-- 
y l  <= "0000" when (en='O') e l s e  
" 0 0 0 1 "  when ( a = " 0 0 " )  e l s e  
" 0 0 1 0 "  when ( a = " 0 1 " )  e l s e  
20 
" 0 1 0 0 "  when (a=t'lO1l) e l s e  
'1 1000 1' ; 
-_ a = "1 1 I' 
-- s e 1 e c t e d 
s <= en & a; 
with s s e l e c t  
s ig n a 1 a ssi g n m ent 
s ta  t e m e n t 
25 
-- 
YZ <= l t O O O O t l  when " 0 0 0 "  I 11001" I t l O I O "  I " O 1 1 " ,  
0 0 0 1 when 
'I 1 0 0 'I , 
30 
"001011 when "101", 
0 1 00 
when 
It 1 10 I' , 
" 1 0 0 0 ' 1  when o t h e r s ;  
-- s = "1 1 I 'I 
end concurrent-arch; 

424 
SAMPLE VHDL TEMPLATES 
A.2.5 
Combinational circuit using process 
Listing A.7 
Combinational circuit using process 
library i e e e ;  
use ieee. std-logic-1164. a l l  ; 
e n t i t y  comb-proc i s  
port ( 
5 
a ,  b :  in std-logic-vector(1 downto 0 ) ;  
data-in: std-logic-vector ( 7  downto 0) ; 
xa-out , xb-out : out std-logic-vector ( 7  downto 0) ; 
ya-out , yb-out : out std-logic-vector (7 downto 0 )  
) ;  
10 end comb-proc ; 
a r c h i t e c t u r e  arch of comb-proc i s  
begin 
_-------------------------------------------- 
15 
-- w i t h o u t  d e f a u l t  o u t p u t  s i g n a l  a s s i g n m e n t  
__------------------------------------------- 
-- must i n c l u d e  e l s e  branch 
__ o u t p u t  s i g n a l  must be a s s i g n e d  i n  a l l  b r a n c h e s  
process (a,b,data-in) 
i f  a > b then 
20 
begin 
xa-out <= data-in; 
xb-out <= ( o t h e r s = > ' O ' ) ;  
e l s i f  a < b then 
end i f ;  
30 
end p r o c e s s ;  
40 
45 
__ 
c a s e  s t a t e m e n t  
__ 
__ 
35 
s <= en !L 
a; 
process ( s )  
begin 
case s i s  
when l l O O O 1 t  I l t O O 1 l t  I l t O l o l l  I "o111t 
=> 
when " 1 0 0 "  => 
when ltl~llp 
=> 
when l l l l O t '  => 
when others => 
y2 <= " 0 0 0 1 " ;  
y2 <= " 0 0 0 1 " ;  
y2 <= " 0 0 1 0 " ;  
y2 <= " 0 1 0 0 " ;  
y2 <= " 1 0 0 0 " ;  
end c a s e ;  
j n  
end p r o c e s s ;  
end seq-arch ; 

MEMORY COMPONENTS 
425 
15 
30 
xa-out <= ( o t h e r s = > ’ O ’ ) ;  
xb-out <= data-in; 
xa-out <= ( o t h e r s = > ’ O ’ ) ;  
xb-out <= ( o t h e r s = > ’ O ’ ) ;  
e l s e  -- a=b 
end i f ;  
end p r o c e s s ;  
-- w i t h  d e f a u l t  o u t p u t  s i g n a l  a s s i g n m e n t  
__ 
3s 
process (a, b, data-in) 
begin 
ya-out <= ( o t h e r s = > ’ O ’ ) ;  
yb-out <= ( o t h e r s = > ’ O ’ ) ;  
if a > b then 
10 
ya-out <= data-in; 
yb-out <= data-in; 
e l s i f  a < b then 
end if ; 
end p r o c e s s ;  
IS end arch; 
A.3 
MEMORY COMPONENTS 
A.3.1 
Register template 
Listing A.8 Register template 
library ieee; 
use i e e e . s t d - l o g i c - l l 6 4 . a l l ;  
e n t i t y  reg-template is 
port ( 
5 
clk, r e s e t :  in std-logic; 
e n :  in std-logic; 
qi-next , qz-next, q3-next : in 
ql-reg , q 2 _ r e g ,  q3-reg: out 
std-logic-vector ( 7  downto 0 )  ; 
10 
std-logic-vector ( 7  downto 0) 
) ;  
end reg-template; 
a r c h i t e c t u r e  arch of reg-template i s  
15 begin 
__ 
__ r e g i s t e r  w i t h o u t  r e s e t  
process (clk) 
__ 
20 
begin 
if (clk’event and c l k = ’ l ’ )  then 
end i f  ; 
ql-reg <= ql-next; 

SAMPLE VHDL TEMPLATES 
426 
25 
30 
35 
40 
45 
50 
end p r o c e s s ;  
__------------------------------------------- 
__ r e g i s t e r  w i t h  a s y n c h r o n o u s  r e s e t  
process (clk , reset) 
begin 
__------------------------------------------- 
if (reset=’l’) then 
e l s i f  (clk’event and clk=’l’) then 
end if ; 
end p r o c e s s ;  
q2-reg < = ( o t h e r s = >  ’ 0 ’ )  ; 
q2-reg <= q2-next; 
__------------------------------------------- 
__ r e g i s t e r  w i t h  e n a b l e  and a s y n c h r o n o u s  r e s e t  
process (clk, reset) 
begin 
........................................... 
--______________________________________----- 
if (reset=’l ’ )  then 
e l s i f  (clk’event and clk=’l’) then 
q3-reg < = ( o t h e r s = > ’ O ’ ) ;  
if (en=’l’) then 
end if ; 
q3-reg <= q3-next; 
end if ; 
end p r o c e s s ;  
end a r c h ;  
A.3.2 Register file 
Listing A.9 
Register file 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  reg-file is 
5 
g e n e r i c (  
B :  integer:=8; -- number of b i t s  
W :  integer:=2 -- number of a d d r e s s  b i t s  
) ;  
p o r t  ( 
10 
clk, reset: in std-logic; 
wr-en: in std-logic; 
w-addr , r-addr : in std-logic-vector (W-1 downto 0) ; 
w-data: in std-logic-vector ( B - 1  downto 0) ; 
r-data: out std-logic-vector ( B - 1  downto 0 )  
15 
; 
end reg-f ile ; 
a r c h i t e c t u r e  arch of reg-file i s  
type reg-file-type is a r r a y  (2**W-1 downto 0) of 

20 
std-logic-vector ( B - 1  downto 
s i g n a l  array-reg : reg-f ile-type ; 
p r o c e s s  (clk, reset) 
begin 
25 
i f  (reset=’l’) then 
begin 
REGULAR SEQUENTIAL CIRCUITS 
427 
0) ; 
array-reg <= (others=>(others=>’O’)); 
if wr-en=’l ’ then 
e l s i f  (clk’event and clk=’l’) then 
array-reg(to-integer(unsigned(w-addr))) 
<= w-data; 
30 
end i f  ; 
end if ; 
end p r o c e s s ;  
__ r e a d  p o r t  
r-data <= array-reg(to-integer(unsigned(r-addr))); 
35end arch; 
A.4 REGULAR SEQUENTIAL CIRCUITS 
Listing A.10 
Sequential circuit template 
l i b r a r y  ieee; 
use ieee. std-logic-1164. a l l  ; 
use ieee. numeric-std. a l l  ; 
e n t i t y  bin-counter i s  
5 
g e n e r i c ( N :  integer : =  8 ) ;  
p o r t  ( 
clk, reset: in std-logic; 
load, en, syn-clr: i n  std-logic; 
d: in std-logic-vector (N-1 downto 0 )  ; 
q: o u t  std-logic-vector (N-1 downto 0 )  
10 
max-tick: o u t  std-logic; 
) ;  
end bin-counter; 
IS a r c h i t e c t u r e  demo-arch of bin-counter i s  
c o n s t a n t  MAX: integer : =  (2**N-1) ; 
s i g n a l  r-reg: unsigned(N-1 downto 0 )  ; 
s i g n a l  r-next : unsigned (N-1 downto 0 )  ; 
20 begin 
__ 
__ r e g i s t e r  
p r o c e s s  (clk, reset) 
__ 
25 
begin 
if (reset=’l’) then 
e l s i f  (clk’event and clk=’l’) then 
end i f ;  
r-reg <= ( o t h e r s = > ’ O ’ ) ;  
r-reg <= r-next; 
30 

428 
SAMPLE VHDL TEMPLATES 
end p r o c e s s ;  
__ n e x t - s t a t e  
l o g i c  
35 
r - n e x t  
<= ( o t h e r s = > ’ O ’ )  when s y n - c l r = ’ l ’  e l s e  
u n s i g n e d ( d )  
when l o a d = ’ l ’  e l s e  
r - r e g  + 1 
when e n  = ’ i >  e l s e  
r-reg ; 
40 
-- o u t p u t  l o g i c  
q <= std-logic-vector(r-reg); 
max- t i c k  
<= ’1’ when r-reg=MAX e l s e  ’ 0 ’ ;  
end demo-arch; 
A.5 
FSM 
Listing A.ll FSM template 
-- code f o r  t h e  FSM i n  Figure A . l  
library i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  ; 
e n t i t y  fsm-eg i s  
5 
p o r t (  
c l k ,  r e s e t :  in s t d - l o g i c ;  
a ,  b :  in s t d - l o g i c ;  
y o ,  y l :  out s t d - l o g i c  
1 ;  
ID end f sm-eg ; 
a r c h i t e c t u r e  t w o - s e g - a r c h  
of fsm-eg i s  
type e g - s t a t e - t y p e  
i s  ( S O ,  s l ,  s 2 ) ;  
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : e g - s t a t e - t y p e ;  
15 begin 
__ s t a t e  r e g i s t e r  
process ( c l k  , r e s e t  
20 
begin 
i f  ( r e s e t = ’ l ’ )  then 
s t a t e - r e g  <= S O ;  
e l s i f  ( c l k ’ e v e n t  and c l k = ’ l ’ )  then 
s t a t e - r e g  <= s t a t e - n e x t ;  
25 
end i f  ; 
end p r o c e s s ;  
__ n e x t - s t a t e  / o u t p u t  l o g i c  
__ 
__ 
30 
process ( s t a t e - r e g  , a , b )  
begin 
s t a t e - n e x t  <= s t a t e - r e g , ;  -- d e f a u l t  back t o  same s t a t e  

FSM 
429 
(a) State diagram 
, .......................................... 
l b  
y l  c= 1 
I- 
................... 
ylc-I 
r 6 
F 
.........,.......... 
I 
, ................... + 
.......... 
.........I 
(b) ASM chart 
Figure A.l 
State diagram and ASM chart of an FSM template. 

430 
SAMPLE VHDL TEMPLATES 
35 
40 
45 
50 
yo <= ’ 0 ’ ;  
-- d e f a u l t  0 
y l  <= ’ 0 ’ ;  
-- d e f a u l t  0 
case s t a t e - r e g  i s  
when SO => 
if a = ’ l J  then 
if b = ’ l ’  then 
s t a t e - n e x t  
<= s 2 ;  
yo <= ’ 1 ’ ;  
e l s e  
end if ; 
s t a t e - n e x t  <= s l ;  
-- no e l s e  b r a n c h ,  use d e f a u l t  
end if ; 
when sl = >  
y1 <= ’ 1 ’ ;  
if ( a = ’ l ’ )  then 
-- no e l s e  b r a n c h ,  use d e f a u l t  
end if ; 
when s2 => 
s t a t e - n e x t  <= S O ;  
s t a t e - n e x t  <= S O ;  
end c a s e ;  
55 
end p r o c e s s ;  
end t w o - s e g - a r c h ;  
A.6 
FSMD 
Listing A.12 
FSMD template 
-- code f o r  t h e  FSMD shown in F i g u r e  A . 2  
l i b r a r y  i e e e ;  
use i e e e .  s t d - l o g i c - 1 1 6 4 .  a l l  
use i e e e  . n u m e r i c - s t d .  a l l  ; 
p o r t  ( 
5 e n t i t y  f i b  i s  
c l k ,  r e s e t :  in s t d -  
s t a r t :  in s t d - l o g i c  
o g i c  ; 
10 
i : in s t d - l o g i c - v e c t o r  ( 4  downto 0) ; 
r e a d y ,  d o n e - t i c k :  out s t d - l o g i c ;  
f : out s t d - l o g i c - v e c t o r  (19 downto 0 )  
1; 
end f i b ;  
15 a r c h i t e c t u r e  a r c h  of f i b  i s  
type s t a t e - t y p e  i s  ( i d l e  , o p , d o n e ) ;  
s i g n a l  s t a t e - r e g  , s t a t e - n e x t  : s t a t e - t y p e  ; 
s i g n a l  t o - r e g  , t o - n e x t  , t l - r e g  , t l - n e x t  : 
u n s i g n e d  (19 downto 0 )  ; 
20 
s i g n a l  n-reg , n - n e x t  : u n s i g n e d ( 4  downto 0) ; 
begin 
-------------------------===========-----==== 

FSMD 
431 
start=l 
T (7) 
t l t  I 
........................................ 
................................................................ 
T 2 
Figure A.2 ASMD chart of an FSMD template. 

432 
SAMPLE VHDL TEMPLATES 
30 
15 
45 
50 
55 
60 
65 
70 
-_ 
s t a t e  and d a t a  r e g i s t e r s  
-___-______-_____-__----------------------- 
--____________________-__-__-__--__----_----- 
25 
process ( c l k ,  r e s e t )  
begin 
i f  r e s e t = ’ l  ’ then 
s t a t e - r e g  <= i d l e ;  
t o - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
t i - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
n - r e g  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - r e g  <= s t a t e - n e x t  ; 
t o - r e g  <= t o - n e x t ;  
t l - r e g  <= t l - n e x t ;  
n - r e g  <= n - n e x t ;  
e I s i f  ( c l k  ) e v e n t  and c l k =  1 ’ ) then 
end i f ;  
end p r o c e s s ;  
________________________________________--- 
--_______________________--______-__---__---- 
40 
-- n e x t - s t a t e  
l o g i c  and d a t a  p a t h  f u n c t i o n a l  u n i t s  
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
process ( s t a t e - r e g  , n - r e g ,  t o - r e g  , t l - r e g ,  s t a r t  , i  , n - n e x t )  
begin 
r e a d y  < = ’ O ’ ;  
d o n e - t i c k  
<= ’ 0 ’ ;  
s t a t e - n e x t  <= s t a t e - r e g ;  -- d e f a u l t  b a c k  to s a m e  s t a t e  
t o - n e x t  
<= t o - r e g ;  
-- d e f a u l t  k e e p  p r e v i o u s  v a l u e  
t l - n e x t  <= t l - r e g ;  
__ d e f a u l t  k e e p  p r e v i o u s  v a l u e  
n-next <= n - r e g ;  
__ d e f a u l t  k e e p  p r e v i o u s  v a l u e  
case s t a t e - r e g  i s  
when i d l e  => 
r e a d y  <= ’1); 
i f  s t a r t = ’ l ’  then 
t o - n e x t  
<= ( o t h e r s = > ’ O ’ ) ;  
t i - n e x t  <= ( 0 = > ’ 1 ’ ,  
o t h e r s = > ’ O ’ ) ;  
n-next 
<= u n s i g n e d  (i) ; 
s t a t e - n e x t  
<= o p ;  
end i f  ; 
when op => 
i f  n-reg=O then 
t i - n e x t  <= ( o t h e r s = > ’ O ’ ) ;  
s t a t e - n e x t  <= d o n e ;  
s t a t e - n e x t  <= d o n e ;  
t l - n e x t  <= t l - r e g  + t o - r e g ;  
t o - n e x t  
<= t l - r e g ;  
n-next <= n - r e g  - 1; 
e l s i f  n - r e g = l  then 
e l s e  
end i f  ; 
when done => 
d o n e - t i c k  
<= ’1’; 
s t a t e - n e x t  <= i d l e ;  
end c a s e ;  
end p r o c e s s ;  
75 
-- o u t p u t  

53 BOARD CONSTRAINT FILE (S3 .UCF) 
433 
f 
<= std-logic-vector(tl-reg); 
end a r c h ;  
A.7 S3 BOARD CONSTRAINT FILE (S3. 
UCF) 
# 
# 
P i n  a s s i g n m e n t  f o r  X i l i n x  
# 
S p a r t a n - 3  S t a r t e r  b o a r d  
# 
# 
# c l o c k  and r e s e t  
# :  
NET " c l k "  
LOC = "T9" ; 
NET " r e s e t "  
LOC = " L 1 4 " ;  
# 
# b u t t o n s  & s w i t c h e s  
# 
# 4 p u s h  b u t t o n s  
NET " b t n < O > "  
LOC = "M13"; 
NET " b t n < l > "  
LOC = "M14"; 
NET " b t n < 2 > "  
LOC = " L 1 3 " ;  
#NET " b t n < 3 > "  
LOC = " L 1 4 " ;  
# b t n < 3 >  a l s o  used a s  r e s e t  
# 8  
NET 
NET 
NET 
NET 
NET 
NET 
NET 
NET 
s l i d e  s w i t c h e s  
" s w < O > "  
LOC = " F 1 2 " ;  
" s w < l > "  
LOC = "G12"; 
" s w < 2 > "  LOC = "H14"; 
" s w < 3 > "  
LOC = " H 1 3 " ;  
" s w < 4 > "  LOC = " 5 1 4 " ;  
" s w < 5 > "  
LOC = " 5 1 3 " ;  
" s w < 6 > "  
LOC = "K14"; 
" s w < 7 > "  
LOC = " K 1 3 " ;  
# 
# RS232 
# 
NET " r x "  
LOC = " T 1 3 "  I D R I V E = 8  I SLEW=SLOW; 
NET " t x "  
LOC = " R 1 3 "  I D R I V E = 8  
1 
SLEW=SLOW; 
# 
# 4 - d i g i t  t i m e - m u l t i p l e x e d  7-segment 
LED d i s p l a y  
# 
# d i g i t  e n a b l e  
NET " a n < O > "  
LOC = "D14"; 
NET " a n < l > "  LOC = "G14"; 
NET " a n < 2 > "  LOC = " F 1 4 " ;  
NET " a n < 3 > "  LOC = " E 1 3 " :  
# 7-segment l e d  s e g m e n t s  

434 
SAMPLE VHDL TEMPLATES 
NET 
NET 
NET 
NET 
NET 
NET 
NET 
NET 
# 
# 8  
# 
NET 
NET 
NET 
NET 
NET 
NET 
NET 
NET 
s s e g < 7 >  
s s e g < 6 >  
s s e g < 5 >  
s s e g < 4 >  
sseg < 3 >  
s s e g < 2 >  
s s e g < l >  
sseg <O > 
LOC = 
LOC = 
LOC = 
LOC = 
LOC = 
LOC = 
LOC = 
LOC = 
" P 1 6 " ;  # d e c i m a l  p o i n t  
" E 1 4 " ;  # s e g m e n t  a 
" G 1 3 " ;  
# s e g m e n t  b 
" N 1 5 " ;  # s e g m e n t  c 
" P 1 5 " ;  # s e g m e n t  d 
" R 1 6 " ;  # s e g m e n t  e 
" F 1 3 " ;  # s e g m e n t  f 
"N16"; # s e g m e n t  g 
d i s c r e t e  LEDs 
" l e d < O > "  
LOC = " K 1 2 " ;  
" l e d < l > "  
LOC = " P 1 4 " ;  
" l e d < 2 > "  LOC = " L 1 2 " ;  
" l e d < 3 > "  LOC = "N14"; 
" l e d < 4 > "  LOC = " P 1 3 " ;  
" l e d < 5 > "  LOC = "N12"; 
" l e d < 6 > "  
LOC = " P 1 2 " ;  
" l e d < 7 > "  
LOC = " P 1 1 " ;  
# 
# VGA o u t p u t s  
# 
NET " r g b < 2 > "  LOC = "R12" I DRIVE=8 I SLEW=FAST; 
NET " r g b < l > "  LOC = " T 1 2 "  I DRIVE=8 I SLEW=FAST; 
NET "rgb<O>" LOC = " R l 1 "  I 
DRIVE=8 I SLEW=FAST; 
NET " v s y n c "  
LOC = " T 1 0 "  I DRIVE=8 
1 
SLEW=FAST; 
NET " h s y n c "  
LOC = " R 9 "  
I DRIVE=8 I SLEW=FAST; 
# 
# PS2 p o r t  
# 
NET " p s 2 c "  LOC="M16" 
I DRIVE=8 I SLEW=SLOW; 
NET " p s 2 d "  LOC="M15" 
I DRIVE=8 
1 SLEW=SLOW; 
# 
# t w o  SRAM c h i p s  
#: 
# shared 1 8 - b i t  memory address 
NET "ad<17>" L O C = " L 3 "  I 
IOSTANDARD = LVCMOS33 
NET " a d < 1 6 > "  
LOC="K5" 
1 
IOSTANDARD = LVCMOS33 
NET " a d < 1 5 > "  LOC="K3" I 
IOSTANDARD = LVCMOS33 
NET "ad<14>" LOC=" 53" I 
IOSTANDARD = LVCMOS33 
NET "ad<13>" LOC=I'J4" 
1 
IOSTANDARD = LVCMOS33 
NET "ad<12>" LOC="H4" 
1 
IOSTANDARD = LVCMOS33 
NET " a d < l l > "  
LOC="H3" 
I 
IOSTANDARD = LVCMOS33 
NET " a d < l O > "  
LOC="G5" 
1 
IOSTANDARD = LVCMOS33 
NET " a d < 9 > "  
L O C = " E 4 "  I 
IOSTANDARD = LVCMOS33 
NET " a d < 8 > "  
L O C = " E 3 "  I 
IOSTANDARD = LVCMOS33 
NET " a d < 7 > "  
L O C = " F 4 "  
I 
IOSTANDARD = LVCMOS33 
NET " a d < 6 > "  
L O C = " F 3 "  
I IOSTANDARD = LVCMOS33 
NET " a d < 5 > "  
LOC="G4" I 
IOSTANDARD = LVCMOS33 
I SLEW=FAST; 
I SLEW=FAST; 
1 
SLEW=FAST; 
I SLEW=FAST; 
I SLEW=FAST; 
1 
SLEW=FAST; 
I SLEW=FAST; 
I 
SLEW=FAST; 
I SLEW=FAST; 
I SLEW=FAST; 
I SLEW=FAST; 
I 
SLEW=FAST; 
I SLEW=FAST; 

53 BOARD CONSTRAINT FILE (S3.UCF) 
435 
IW NET "ad<4>" LOC="L4" I IOSTANDARD = LVCMOS33 I SLEW=FAST; 
NET "ad<3>" 
LOC="M3" I IOSTANDARD = LVCMOS33 I SLEW=FAST; 
NET "ad<2>" 
LOC="M4" I IOSTANDARD = LVCMOS33 I SLEW=FAST; 
NET "ad<l>" 
LOC="N3" I IOSTANDARD = LVCMOS33 I SLEW=FAST; 
NET "ad<O>" 
LOC="L5" I IOSTANDARD = LVCMOS33 I SLEW=FAST; 
# shared oe, we 
NET "oe-n" 
LOC="K4" I IOSTANDARD = LVCMOS33 I SLEW=FAST; 
NET "we-n" 
LOC="G3" I IOSTANDARD = LVCMOS33 I SLEW=FAST; 
# sram chip 1 data, ce, ub, lb 
NET "dio_a<l5>" LOC="Rl" I IOSTANDARD=LVCMOS33 I 
NET "dio_a<l4>" LOC="Pl" I IOSTANDARD=LVCMOS33 I 
NET "dio_a<l3>" LOC="L2" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<12>" LOC=" 52" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<ll>" LOC="Hl" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<lO>" LOC="F2" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<9>" LOC="P8" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<8>" LOC="D3" 1 
IOSTANDARD=LVCMOS33 I 
NET "dio-a<7>" LOC="Bl" I 
IOSTANDARD=LVCMOS33 1 
NET "dio-a<6>" LOC="Cl" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<5>" LOC="C2" I IOSTANDARD=LVCMOS33 1 
NET "dio-a<4>" LOC="R5" I IOSTANDARD=LVCMOS33 I 
NET I' d i o - a < 3 > " 
I 
NET "dio-a<2>" LOC="RG" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<l>" LOC="T8" I IOSTANDARD=LVCMOS33 I 
NET "dio-a<O>" LOC="N7" I IOSTANDARD=LVCMOS33 I 
NET 'I ce-a-n" 
LOC="P7" I IOSTANDARD=LVCMOS33 I 
NET "ub-a-n" 
LOC="T4" I 
IOSTANDARD=LVCMOS33 I 
NET "lb-a-n" 
LOC="P6" I IOSTANDARD=LVCMOS33 I 
L 0 C = " T 5 " 
1 
I 0 STANDARD = LV CM 0 S 3 3 
# sram chip 2 data, ce, ub, lb 
NET "dio_b<l5>" LOC="Nl" I 
IOSTANDARD=LVCMOS33 
NET "dio_b<l4>" LOC="Ml" I IOSTANDARD=LVCMOS33 
NET "dio_b<l3>" LOC="K2" I IOSTANDARD=LVCMOS33 
NET "dio-b <12>" LOC="C3" I IOSTANDARD=LVCMOS33 
NET "dio-b<ll>" LOC="F5" 1 
IOSTANDARD=LVCMOS33 
NET "dio-b <lo>" LOC="Gl" I IOSTANDARD=LVCMOS33 
NET "dio-b <9>" LOC="E2" I IOSTANDARD=LVCMOS33 
NET "dio-b <8>" LOC="D2" I IOSTANDARD=LVCMOS33 
NET "dio-b <7>" LOC="Dl I IOSTANDARD=LVCMOS33 
NET "dio-b <6>" LOC="El 
'I I IOSTANDARD=LVCMOS33 
NET "dio-b < 5 > "  
LOC="G2" I IOSTANDARD=LVCMOS33 
NET "dio-b <4>" LOC=" J1 
I' 
I IOSTANDARD=LVCMOS33 
NET "dio-b < 3 > "  LOC="Kl" I 
IOSTANDARD=LVCMOS33 
NET "dio-b <2>" LOC="M2" 1 
IOSTANDARD=LVCMOS33 
NET "dio-b <1>" LOC="N2" I IOSTANDARD=LVCMOS33 
NET "dio-b < O > "  LOC="P2" I IOSTANDARD=LVCMOS33 
NET 'I ce-b-n" 
LOC="N5" I 
IOSTANDARD=LVCMOS33 
NET "ub-b-n" 
LOC="R4" I IOSTANDARD=LVCMOS33 
NET "lb-b-n" 
LOC="P5" I IOSTANDARD=LVCMOS33 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST ; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST ; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 
SLEW=FAST; 

436 
SAMPLE VHDL TEMPLATES 
# Timing constraint of S3 50-MHz onboard oscillator 
# name of the clock signal is clk 
# 
NET "clk" TNM-NET = "clk"; 
TIMESPEC 1'TS-clk9t 
= PERIOD "clk" 40 ns HIGH 50 %; 

REFERENCES 
1. P. J. Ashenden, The Designer’s Guide to VHDL, 2nd ed., Morgan Kaufmann, 2001. 
2. J. Axelson, Serial Port Complete, 2nd ed., Lakeview Research, 2007. 
3. L. Bening and H. D. Foster, Principles of Verz$able RTL Design, 2nd ed., Springer-Verlag, 2001. 
4. J. Bergeron, Writing Testbenches: Functional Veri&ation of HDL Models, Springer-Verlag, 
5. K. Chapman, “Creating Embedded Microcontrollers,” TechXclusives at www.xilinx.com. 
6. A. Chapweske, “PSI2 MouseIKeyboard Protocol,” http://www.computer-engineering.org. 
7. A. Chapweske, ‘‘PSI2 Keyboard Interface,” http://www.computer-engineering.org. 
8. A. Chapweske, “PSI2 Mouse Interface,” http:/lwww.computer-engineering.org. 
9. P. P. Chu, RTL Hardware Design Using VHDL: Coding for Eficiency, Portability, and Scalability, 
2003. 
Wiley-IEEE Press, 2006. 
10. M. D. Ciletti, Advanced Digital Design with the Verilog HDL, Prentice Hall, 2003. 
11. M. D. Ciletti, Starter’s Guide to Verilog 2001, Prentice Hall, 2003. 
12. C. E. Cummings, “Coding and Scripting Techniques for FSM Designs with Synthesis-Optimized, 
13. D. D. Gajski, Principles of Digital Design, Prentice Hall, 1997. 
14. J. 0. Hamblen et al., Rapid Prototyping of Digital Systems: Quartus@ II Edition, Springer, 2005. 
15. IEEE, IEEE Standard for Verilog Hardware Description Language (IEEE Std 1364-2001), In- 
16. IEEE, IEEE Standard VHDL Language Reference Manual (IEEE Srd 1076-2001), Institute of 
Glitch-Free Outputs,” SNUG (Synopsys Users Group Conference), Boston, 2000. 
stitute of Electrical and Electronics Engineers, 2001. 
Electrical and Electronics Engineers, 2001. 
FPGA Protofjping by VHDL Examples. By Pong P. Chu 
Copyright @ 2008 John Wiley & Sons, Inc. 
437 

438 
REFERENCES 
17. IEEE, IEEE Standardfor VHDL Register Transfer Level (RTL) Synthesis (IEEE Std 107661999), 
18. IEEE, IEEE Standard VHDL Synthesis Packages (IEEE Std 1076.3-1997), Institute of Electrical 
19. IEEE, IEEE Standard Multivalue Logic System for VHDL Model Interoperability (IEEE Std 
20. Integrated Silicon Solution, “Data Sheet of IS61LV25616AL SRAM,” Integrated Silicon Solu- 
21. R. H. Katz and G. Borriello, Contemporary Logic Design, 2nd ed., Prentice Hall, 2004. 
22. M. Keating andP. Bricaud, Methodology Manualfor System-on-a-Chip Designs, 3rded., Springer- 
23. C. M. Maxfield, The Design Warrior’s Guide to FPGAs, Newnes, 2004. 
24. Mentor Graphics, ModelSim Tutorial, Mentor Graphics Corporation. 
25. S. Palnitkar, Verilog HDL, 2nd ed., Prentice Hall, 2003. 
26. D. A. Patterson and J. L. Hennessy, Computer Organization and Design: The Hardware/Software 
27. J. M. Rabaey, Digital Integrated Circuits, 2nd ed., Prentice Hall, 2002. 
28. J. F. Wakerly, Digital Design: Principles and Practices, Prentice Hall, 2002. 
29. W. Wolf, FPGA-Based System Design, Prentice Hall, 2004. 
30. Xilinx, DS099 Spartan-3 FPGA Family: Complete Data Sheet, Xilinx, Inc. 
3 1. Xilinx, ISE 8.1 i Quick Start Tutorial, Xilinx, Inc. 
32. Xilinx, ISE In-Depth Tutorial, Xilinx, Inc. 
33. Xilinx, PicoBlaze 8-bit Embedded Microcontroller User Guide, Xilinx, Inc. 
34. Xilinx, Spartan-3 Starter Kit Board User Guide, Xilinx, Inc. 
35. Xilinx, XAPP462 Using Digital Clock Managers (DCMs) in Spartan-3 FPGAs, Xilinx, Inc. 
36. Xilinx, XAPP463 Using Block RAM in Spartan-3 Generation FPGAs, Xilinx, Inc. 
37. Xilinx, XAPP464 Using Look-Up Tables as Distributed RAM in Spartan-3 Generation FPGAs, 
38. Xilinx, XST User Guide vS.Ii, Xilinx, Inc. 
Institute of Electrical and Electronics Engineers, 2000. 
and Electronics Engineers, 1997. 
1164-1993), Institute of Electrical and Electronics Engineers, 1993. 
tion, Inc. 
Verlag, 2002. 
Interface, 3rd ed., Morgan Kaufmann, 2004. 
Xilinx, Inc. 

INDEX 
architecture body, 4 
ASCII code, 177, 194 
ASM chart, 108 
ASMD chart, 128 
barrel shifter, 62 
BCD, 147 
binary decoder, 43,45,4849 
case statement, 49 
CLB, 13 
component instantiation, 6 
conditional signal assignment, 41 
constant, 53 
constraint file, 23 
Core Generator, 245 
counter, 8 1,96 
DFF,71 
data type, 3 
enumerated, 11 1 
signed, 37 
std-logic, 3, 39 
stdlogic-vector, 4 
two-dimensional array, 79 
unsigned, 37 
DCM, 239 
DDR register, 239 
debouncing circuit, 118, 132 
development flow, 15 
division circuit, 143 
edge detector, 114 
entity declaration, 3 
FIFO buffer, 100, 171 
flag FF, 169 
floating-point adder, 63 
FSM, 74, 107 
FSMD, 74, 127,324 
generic mapping, 55 
generics, 54 
hold time, 72 
HyperTerrninal, 177, 194,208 
identifier, 3 
if statement, 47 
instruction memory, 324 
instruction ROM, 329, 363 
instruction set, 329 
interrupt, 341,405 
IOB, 239 
KCPSM3,328,332,342,345,359 
logic cell, 11 
logic synthesis, 16 
LUT, 12,243 
macro cells, 13 
maximal operating frequency, 73 
Mealy output, 108 
memory controller, 215, 220, 244 
mode 
in, 3 
inout, 40 
out, 3 
Moore output, 107 
multiplexer, 41, 44 
439 

440 
INDEX 
operator 
arithmetic, 37 
concatenation, 38 
logical, 4 
relational, 37 
numeric-std, 37 
stdlogic_l164,3,79 
stdJogic-arith, 38 
stdlogic-signed, 38 
stdlogic-unsigned, 38 
pad delay, 234 
PBlazeIDE, 332,342,359 
placement and routing, 16 
priority encoder, 41,44,48-49 
process, 46 
program counter, 324 
PS2 
keyboard, 188 
mouse, 200 
receiver, 184 
transmitter, 20 1 
block, 244,282,292 
distributed, 243 
dual-port, 249, 283, 298 
single-port, 246 
static, 215-216 
package 
RAM 
register, 72, 77 
register file, 78, 100, 222 
register transfer methodology, 35 
register transfer operation, 127 
regular sequential circuit, 74 
ROM, 25 1,274 
font, 292 
RS-232,163 
selected signal assignment, 44 
sensitivity list, 46 
sequential statement, 46 
setup time, 72 
shift register, 79 
sign-magnitude adder, 59 
slice, 13 
state diagram, 108 
static timing analysis, 16 
structural description, 6 
synchronous design methodology, 7 1 
technology mapping, 16 
testbench, 8, 28, 84 
tri-state buffer, 39, 220 
type conversion, 37 
UART, 163,386 
ucf file, 23 
VGA mode, 260 
video memory, 282 
video synchronization, 260 

