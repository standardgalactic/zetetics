
Lech Polkowski
Approximate Reasoning by Parts

Intelligent Systems Reference Library,Volume 20
Editors-in-Chief
Prof. Janusz Kacprzyk
Systems Research Institute
Polish Academy of Sciences
ul. Newelska 6
01-447 Warsaw
Poland
E-mail: kacprzyk@ibspan.waw.pl
Prof. Lakhmi C. Jain
University of South Australia
Adelaide
Mawson Lakes Campus
South Australia 5095
Australia
E-mail: Lakhmi.jain@unisa.edu.au
Further volumes of this series can be found on our
homepage: springer.com
Vol. 1. Christine L. Mumford and Lakhmi C. Jain (Eds.)
Computational Intelligence: Collaboration, Fusion
and Emergence, 2009
ISBN 978-3-642-01798-8
Vol. 2.Yuehui Chen and Ajith Abraham
Tree-Structure Based Hybrid
Computational Intelligence, 2009
ISBN 978-3-642-04738-1
Vol. 3.Anthony Finn and Steve Scheding
Developments and Challenges for
Autonomous Unmanned Vehicles, 2010
ISBN 978-3-642-10703-0
Vol. 4. Lakhmi C. Jain and Chee Peng Lim (Eds.)
Handbook on Decision Making: Techniques
and Applications, 2010
ISBN 978-3-642-13638-2
Vol. 5. George A.Anastassiou
Intelligent Mathematics: Computational Analysis, 2010
ISBN 978-3-642-17097-3
Vol. 6. Ludmila Dymowa
Soft Computing in Economics and Finance, 2011
ISBN 978-3-642-17718-7
Vol. 7. Gerasimos G. Rigatos
Modelling and Control for Intelligent Industrial Systems,
2011
ISBN 978-3-642-17874-0
Vol. 8. Edward H.Y. Lim, James N.K. Liu, and
Raymond S.T. Lee
Knowledge Seeker – Ontology Modelling for Information
Search and Management, 2011
ISBN 978-3-642-17915-0
Vol. 9. Menahem Friedman and Abraham Kandel
Calculus Light, 2011
ISBN 978-3-642-17847-4
Vol. 10.Andreas Tolk and Lakhmi C. Jain
Intelligence-Based Systems Engineering, 2011
ISBN 978-3-642-17930-3
Vol. 11. Samuli Niiranen and Andre Ribeiro (Eds.)
Information Processing and Biological Systems, 2011
ISBN 978-3-642-19620-1
Vol. 12. Florin Gorunescu
Data Mining, 2011
ISBN 978-3-642-19720-8
Vol. 13.Witold Pedrycz and Shyi-Ming Chen (Eds.)
Granular Computing and Intelligent Systems, 2011
ISBN 978-3-642-19819-9
Vol. 14. George A.Anastassiou and Oktay Duman
Towards Intelligent Modeling: Statistical Approximation
Theory, 2011
ISBN 978-3-642-19825-0
Vol. 15.Antonino Freno and Edmondo Trentin
Hybrid Random Fields, 2011
ISBN 978-3-642-20307-7
Vol. 16.Alexiei Dingli
Knowledge Annotation: Making Implicit Knowledge
Explicit, 2011
ISBN 978-3-642-20322-0
Vol. 17. Crina Grosan and Ajith Abraham
Intelligent Systems, 2011
ISBN 978-3-642-21003-7
Vol. 18.Achim Zielesny
From Curve Fitting to Machine Learning, 2011
ISBN 978-3-642-21279-6
Vol. 19. George A.Anastassiou
Intelligent Systems: Approximation by Artiﬁcial Neural
Networks, 2011
ISBN 978-3-642-21430-1
Vol. 20. Lech Polkowski
Approximate Reasoning by Parts, 2011
ISBN 978-3-642-22278-8

Lech Polkowski
ApproximateReasoningbyParts
An Introduction to Rough Mereology
123

Prof. dr. Lech Polkowski
Polish-Japanese Institute of Information Technology
and
University of Warmia and Mazury
Koszykowa 86 02–008 Warszawa, Poland
E-mail: polkow@pjwstk.edu.pl
ISBN 978-3-642-22278-8
e-ISBN 978-3-642-22279-5
DOI 10.1007/978-3-642-22279-5
Intelligent Systems Reference Library
ISSN 1868-4394
Library of Congress Control Number: 2011931790
c⃝2011 Springer-Verlag Berlin Heidelberg
This work is subject to copyright. All rights are reserved, whether the whole or
part of the material is concerned, speciﬁcally the rights of translation, reprinting,
reuse of illustrations, recitation, broadcasting, reproduction on microﬁlm or in
any other way, and storage in data banks. Duplication of this publication or
parts thereof is permitted only under the provisions of the German Copyright
Law of September 9, 1965, in its current version, and permission for use must
always be obtained from Springer. Violations are liable to prosecution under the
German Copyright Law.
The use of general descriptive names, registered names, trademarks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such
names are exempt from the relevant protective laws and regulations and therefore
free for general use.
Typeset & Cover Design: Scientiﬁc Publishing Services Pvt. Ltd., Chennai, India.
Printed on acid-free paper
9 8 7 6 5 4 3 2 1
springer.com

To Maria and Marcin


Preface
And in this way from the old soil–as men say–a new harvest sprouts
(Chaucer, a paraphrase (C.S. Lewis in The Discarded Image))
μ´ερoς λ´εγεται ενα μ`εν τρ´oπoν εiς o δiαiϱεθε`ιν αν τ `o π`oσoν oπoσo˜υν (`αεi γ `αϱ τo
`αφαiϱo´υμενoν τo˜υ πoσo˜υ η π`oσoν μ´ερoς λ´εγεται `εκε´ινoυ o˜ιoν τ ˜ων τρi˜ων τ `α δυo
μ´εϱoσ λ´εγεται πως), `αλλoν δ`ε τϱ´oπoν τ `α καταμετϱo˜υντα τ ˜ων τoιo`υτoν μ`oνoν:
δι`o τ `α δ´υo τ ˜ων τϱι˜ων `εστι μ`εν ´ως λ´εγεται μ´ερoς `εστι δ′ως ω`υ. `ετι εiς ´α τ `o ε´ιδoς
δiαiϱεθε´ιν `αν ´ανευ τo˜υ πoςo˜υ και τα˜υτα μ´oϱια λ´εγεται τo´υτoυ : δι`o τ `α ε´ιδη
τo˜υ γ´ενoυς φασιν ε´ιναι μ´oρια. ´ετι ´εiς `α διαιϱε˜ιται `η `εξ ´ων σ´υγκειται τ `o ´oλoν,
`η τ ´o ε´ιδoς `η τ `o ´εχoν τ `o ε´ιδoς, o˜ιoν τ ˜ης σφα´ιϱας τ ˜ης χαλκ˜ης `η τo˜υ κ´υβoυ τo˜υ
χαλκo˜υ και ´o χαλκ`oς μ´εϱoς (τo˜υτo δ′ `εστιν ´η ´υλη `εν ´η τ `o ´ειδoς) και ´η γoν´ια
μ´εϱoς. ´ετι τ `α `εν τ ˜ω λ´oγω τ ˜ω δηλo˜υντι ´εκαστoν και τα˜υτα μ´oϱια τo˜υ ´oλoυ: δι`o
τ `o γ´ενoς τo˜υ ε´ιδoυς και μ´ερoς λ´εγεται, ´αλλoς δ`ε τ `o ε´ιδoς τo˜υ γ´ενoυς μ´εϱoς.
(Aristotle. Metaphysics. Book Delta, 1203 b)
Aristotle in the passage quoted, gives, inter alia, a deﬁnition of part as an
entity which may be taken from some other entity, also, as a division of an
entity from which some entities may be taken. This intuitive meaning of parts
was taken as a foundation for the theory of Mereology by Stanislaw Le´sniewski
(1916). At the same time, Alfred North Whitehead discussed the dual notion
of extending over.
Over the years, Mereology version due to Le´sniewski was set in the frame
of a logical calculus of Protothetics and the theory of Ontology whereas the
ideas of Whitehead, stimulated by the work of Th. de Laguna, were later
rendered in the form of Leonard and Goodman’s Calculus of Individuals and
Clarke’s Connection Calculus.
Rough Mereology extends Mereology by discussing the notion of a part
to a degree. Mereology is preserved in it by the requirement that a part to
degree of 1 be an ingredient, hence, the theory of part to degree of 1 is the
theory of Mereology.

VIII
Preface
The notion of a part to a degree carries an analogy to the notion of an
element to a degree, which, as proposed by Professor LotﬁA. Zadeh, is the
primitive notion of the fuzzy set theory. Rough Mereology replaces this no-
tion with the notion of a part to a degree as Mereology replaces the set–
theoretical notion of an element with the notion of a part. One can, hence,
say that Rough Mereology in a sense ‘fuzziﬁes’ Mereology and is a counter-
part of Fuzzy Set Theory within Mereology. The term ‘Rough Mereology’
comes from the author’s work on rough set theory as it had begun from our
attempts to characterize in abstract terms partial containment between exact
concepts. By considering objects as parts one to another, Mereology is par-
ticularly suited to discussion of spatial relations among spatial objects like
solids, ﬁgures etc., witness the Tarski axiomatization of geometry of solids
in terms of Mereology. Rough Mereology extends the scope of this discussion
by considering numerical values of containment among spatial objects and
allowing for a more precise description of spatial relationships. Hence, Rough
Mereology can be also regarded as an extension of Fuzzy Set Theory useful
in spatial reasoning.
It is the aim of this book, to give a presentation of main ideas and appli-
cations of Rough Mereology, in a simpliﬁed language of set theory.
The book consists of nine chapters; in accordance with principles adopted
when writing our earlier book Rough Sets. Mathematical Foundations, we in-
clude preliminary chapters devoted to fundamentals. Chapter 1 brings some
basic facts on Set Theory and Aristotelian Theory of Concepts. We put par-
ticular emphasis on relations, with relations of tolerance and equivalence
highlighted as playing important role in analysis by fuzzy and rough set the-
ories. In Chapter 2 we give an introduction to Topology of Concepts, and
we emphasize topics important for fuzzy and rough set theories like topolo-
gies on sets and ˇCech topologies. These chapters provide the reader with
the basic facts of set theory and topology, which are useful in later chapters
when we discuss some set–theoretical and topological structures induced in
the mereological universe.
As Rough Mereology has been conceived as a tool in Approximate Rea-
soning, we include Chapter 3 on patterns of Deductive Reasoning in which
we present basic deductive calculi: calculus of propositions as a model for
deductive reasoning, many–valued calculi so important for fuzzy sets–based
reasoning, modal calculi immanent in rough sets–based analysis of ambiguity,
and predicate calculus. In Chapter 4, we address reductive/inductive reason-
ing by presenting rough and fuzzy set theories as environments in which to
induce decision rules. We discuss rough set methods for induction of decision
rules, topology of rough sets with applications to fractal calculus, and rough
sets–based reasoning schemes describing modalities induced by indiscernibil-
ity relations. In the second part of this chapter, we study in detail t–norms
and residual implications which are cornerstone of many–valued fuzzy logics
and supply essential tools for Rough Mereology; we conclude with an outline
of basic ideas on fuzzy decision rules.

Preface
IX
Mereology enters in Chapter 5 in which we present the Le´sniewski formula-
tion of Mereology along with the theory of classes so important for our theory
of granulation of knowledge; we recapitulate the Tarski–Woodger version of
timed mereology and the Woodger theory of cells as important applications
of Mereology which are far from being exploited. Passing to the initiated by
Whitehead Mereology of Connections, we recall the Clarke Connection Calcu-
lus, a modern rendering of Whitehead–de Laguna ideas, and its adaptations
suitable for applications like RCC. We stress also topics already known from
introductory chapters: topological and algebraic structures hidden in mereo-
logical spaces.
Rough Mereology is discussed in Chapter 6. We discuss its primitive no-
tion of a rough inclusion which is a ternary predicate/relation asserting that
one object is a part of another object to a speciﬁed degree and we present
known to us methods of inducing rough inclusions. These methods depend
on the context of usage and vary from general, e.g., employing a metric, to
speciﬁc, e.g., employing properties of indiscernibility in decision systems. As
with Mereology, we study mereotopology and we induce from rough inclu-
sions predicates of mereogeometry essential in applications in spatial reason-
ing. Finally, we construct within Rough Mereology predicates of Connection
Calculus.
Applications of Rough Mereology in approximate reasoning are presented
in Chapter 7. We discuss methods for granulation of knowledge and the theory
of rough mereological granules based on mereological theory of classes; this
approach allows for ˇCech granular topologies. We introduce intensional logics
in which extensions are evaluated at worlds which are granules; as an appli-
cation, we propose a rough mereological rendition of the perception calculus
introduced by L. A. Zadeh. We introduce reasoning schemes for distributed
and many–agent systems. Finally, we discuss the idea of rough mereological
perceptrons and their networks.
Applications of rough mereology are also presented in Chapters 8 and 9.
In Chapter 8, we give an outline of applications of rough mereology in spatial
reasoning taking as an exemplary ﬁeld the behavioral robotics. We use rough
mereogeometry introduced in Chapter 6 in order to deﬁne rigorously the no-
tion of a formation of robots and to propose a new method of path planning
– rough mereological potential ﬁelds. The applicability of these methods is il-
lustrated with experiments with formations of Roomba (intellectual property
of iRobot.Inc.) robots.
Chapter 9 is devoted to another essential application of rough mereology,
viz., in classiﬁer synthesis. Our approach to granulation of knowledge allows
for a data ﬁltration by means of a factorization of data through a granular
structure which reduces noise in data and allows for better classiﬁers of higher
accuracy and with strikingly less number of rules. We present the theory un-
derlying this approach as well as a selection of exemplary granular classiﬁers
illuminating beneﬁts of this approach.

X
Preface
We do hope that this book will be used as a source of information and an
inspiration to further study of rough mereology and that it will serve as a
basis for a course in approximate reasoning. Introductory chapters may serve
as a course in basic set theory and topology essential for computer scientists.
We do hope it turns out as useful to the research community as our book on
rough sets has turned out to be.
We owe a debt of gratitude to many who have helped us by means of
encouragement, support, and cooperation.
We would like to express our gratitude to Professor LotﬁA. Zadeh for kind
words of encouragement and support.
To Professor Janusz Kacprzyk and Professor Lakhmi C. Jain, Series Ed-
itors, we are indebted for kind acceptance of this text into this prestigious
series of monographs.
We remember with feeling of deep gratitude the late Professors Helena
Rasiowa and Zdzislaw Pawlak; without their direct and indirect inﬂuence
rough mereology would most probably not emerge.
We would like to remember our late Colleagues Professors Cecilia Rauszer
and Jan Zytkow whose work is reﬂected in this book.
Our thanks go to Professor Solomon Marcus, Professor Gheorghe Paun,
and Professor Andrzej Skowron for their helpful advice, inspiration, and joint
work; Dr Pawel O´smialowski and Dr Piotr Artiemjew contributed to the
development of applications of rough mereology in behavioral robotics and
knowledge discovery, respectively, and we would like to thank them for this
cooperation.
We would like to thank Dr Thomas Ditzinger, Dr Dieter Merkle, Mr Hol-
ger Sch¨ape, Ms Jessica Wengrzik and the staﬀof Engineering Editorial of
Springer Verlag for their kind help in all stages of preparation of this book.
The book is dedicated to two people whose help and support have been
invaluable.
Lech Polkowski
Warszawa, Poland

Contents
1
On Concepts. Aristotelian and Set–Theoretic
Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
An Aristotelian View on Concepts . . . . . . . . . . . . . . . . . . . . .
1
1.2
From Local to Global: Set Theory . . . . . . . . . . . . . . . . . . . . . .
6
1.2.1
Na¨ıve Set Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.2.2
Algebra of Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.2.3
A Formal Approach . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.3
Relations and Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
1.3.1
Algebra of Relations. . . . . . . . . . . . . . . . . . . . . . . . . . .
16
1.4
Ordering Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.5
Lattices and Boolean Algebras . . . . . . . . . . . . . . . . . . . . . . . . .
21
1.6
Inﬁnite Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
1.7
Well–Ordered Sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
1.8
Finite versus Inﬁnite Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
1.9
Equipotency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
1.10
Countable Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
1.11
Filters and Ideals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.12
Equivalence Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
1.13
Tolerance Relations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
1.14
A Deeper Insight into Lattices and Algebras . . . . . . . . . . . . .
37
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
2
Topology of Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
2.1
Metric Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
2.2
Products of Metric Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
2.3
Compact Metric Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.4
Complete Metric Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
2.5
General Topological Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
2.6
Regular Open and Regular Closed Sets. . . . . . . . . . . . . . . . . .
58

XII
Contents
2.7
Compactness in General Spaces . . . . . . . . . . . . . . . . . . . . . . . .
61
2.8
Continuity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
64
2.9
Topologies on Subsets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
2.10
Quotient Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
2.11
Hyperspaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
2.11.1
Topologies on Closed Sets . . . . . . . . . . . . . . . . . . . . . .
68
2.12
ˇCech Topologies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
3
Reasoning Patterns of Deductive Reasoning . . . . . . . . . . . . .
79
3.1
The Nature of Exact Reasoning . . . . . . . . . . . . . . . . . . . . . . . .
79
3.2
Propositional Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
3.3
Many–Valued Calculi: 3–Valued Logic of Lukasiewicz . . . . .
88
3.4
Many–Valued Calculi: n–Valued Logic . . . . . . . . . . . . . . . . . .
96
3.5
Many–Valued Calculi: [0,1]–Valued Logics . . . . . . . . . . . . . . .
99
3.5.1
MV–Algebras. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
3.6
Many–Valued Calculi: Logics of Residual Implications . . . .
116
3.7
Automated Reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
119
3.8
Predicate Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
121
3.9
Modal Logics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
133
3.9.1
Modal Logic K . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
133
3.9.2
Modal Logic T . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
3.9.3
Modal Logic S4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
138
3.9.4
Modal Logic S5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
138
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
141
4
Reductive Reasoning Rough and Fuzzy Sets as
Frameworks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
145
4.1
Rough Set Approach Main Lines . . . . . . . . . . . . . . . . . . . . . . .
145
4.2
Decision Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
148
4.3
Decision Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
150
4.4
Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
152
4.5
Topology of Rough Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
4.6
A Rough Set Reasoning Scheme: The Approximate
Collage Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
4.7
A Rough Set Scheme for Reasoning about Knowledge . . . . .
158
4.8
Fuzzy Set Approach: Main Lines . . . . . . . . . . . . . . . . . . . . . . .
161
4.9
Residual Implications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
168
4.10
Topological Properties of Residual Implications . . . . . . . . . .
169
4.11
Equivalence and Similarity in Fuzzy Universe . . . . . . . . . . . .
175
4.12
Inductive Reasoning: Fuzzy Decision Rules . . . . . . . . . . . . . .
181
4.13
On the Nature of Reductive Reasoning . . . . . . . . . . . . . . . . . .
183
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
187

Contents
XIII
5
Mereology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
191
5.1
Mereology: The Theory of Le´sniewski . . . . . . . . . . . . . . . . . . .
191
5.2
A Modern Structural Analysis of Mereology . . . . . . . . . . . . .
199
5.3
Mereotopology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
201
5.4
Timed Mereology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
203
5.5
Spatio–temporal Reasoning: Cells . . . . . . . . . . . . . . . . . . . . . .
207
5.6
Mereology Based on Connection. . . . . . . . . . . . . . . . . . . . . . . .
209
5.7
Classes in Connection Mereology . . . . . . . . . . . . . . . . . . . . . . .
215
5.8
C–Quasi–Boolean Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
216
5.9
C–Mereotopology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
219
5.10
Spatial Reasoning: Mereological Calculi . . . . . . . . . . . . . . . . .
220
5.10.1
On Region Connection Calculus . . . . . . . . . . . . . . . .
223
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
225
6
Rough Mereology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
229
6.1
Rough Inclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
6.2
Rough Inclusions: Residual Models . . . . . . . . . . . . . . . . . . . . .
231
6.3
Rough Inclusions: Archimedean Models . . . . . . . . . . . . . . . . .
234
6.4
Rough Inclusions: Set Models . . . . . . . . . . . . . . . . . . . . . . . . . .
236
6.5
Rough Inclusions: Geometric Models . . . . . . . . . . . . . . . . . . . .
236
6.6
Rough Inclusions: Information Models . . . . . . . . . . . . . . . . . .
237
6.7
Rough Inclusions: Metric Models . . . . . . . . . . . . . . . . . . . . . . .
240
6.8
Rough Inclusions: A 3–Valued Rough Inclusion on Finite
Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
240
6.9
Symmetrization of Rough Inclusions . . . . . . . . . . . . . . . . . . . .
241
6.10
Mereogeometry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
241
6.11
Rough Mereotopology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
246
6.11.1
The Case of Transitive and Symmetric Rough
Inclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
246
6.11.2
The Case of Transitive Non–symmetric Rough
Inclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
250
6.12
Connections from Rough Inclusions . . . . . . . . . . . . . . . . . . . . .
252
6.12.1
The Case of Transitive and Symmetric Rough
Inclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
252
6.12.2
The Case of Symmetric Non–transitive Rough
Inclusions and the General Case . . . . . . . . . . . . . . . .
252
6.13
Rough Inclusions as Many–Valued Fuzzy Equivalences . . . .
254
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
256
7
Reasoning with Rough Inclusions . . . . . . . . . . . . . . . . . . . . . . . .
259
7.1
On Granular Reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
259
7.2
On Methods for Granulation of Knowledge . . . . . . . . . . . . . .
261
7.2.1
Granules from Binary Relations. . . . . . . . . . . . . . . . .
261
7.2.2
Granules in Information Systems from
Indiscernibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
262

XIV
Contents
7.2.3
Granules from Generalized Descriptors. . . . . . . . . . .
263
7.3
Granules from Rough Inclusions . . . . . . . . . . . . . . . . . . . . . . . .
263
7.4
Rough Inclusions on Granules. . . . . . . . . . . . . . . . . . . . . . . . . .
264
7.5
General Properties of Rough Mereological Granules . . . . . . .
265
7.6
Reasoning by Granular Rough Mereological Logics . . . . . . .
266
7.7
A Logic for Information Systems . . . . . . . . . . . . . . . . . . . . . . .
269
7.7.1
Relations to Many–Valued Logics . . . . . . . . . . . . . . .
271
7.8
A Graded Notion of Truth. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
272
7.9
Dependencies and Decision Rules . . . . . . . . . . . . . . . . . . . . . . .
277
7.10
An Application to Calculus of Perceptions . . . . . . . . . . . . . . .
278
7.11
Modal Aspects of Rough Mereological Logics . . . . . . . . . . . .
280
7.11.1
A Modal Logic with Ingredient Accessibility . . . . . .
281
7.11.2
Modal Logic of Rough Set Approximations . . . . . . .
282
7.12
Reasoning in Multi–agent and Distributed Systems . . . . . . .
283
7.13
Reasoning in Cognitive Schemes. . . . . . . . . . . . . . . . . . . . . . . .
288
7.13.1
Rough Mereological Perceptron . . . . . . . . . . . . . . . . .
290
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
292
8
Reasoning by Rough Mereology in Problems of
Behavioral Robotics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
297
8.1
Planning of Robot Motion . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
297
8.2
Potential Fields from Rough Inclusions . . . . . . . . . . . . . . . . . .
300
8.3
Planning for Teams of Robots . . . . . . . . . . . . . . . . . . . . . . . . .
303
8.4
Rough Mereological Approach to Robot Formations . . . . . .
308
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
315
9
Rough Mereological Calculus of Granules . . . . . . . . . . . . . . . .
319
9.1
On Decision Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
319
9.2
The Idea of Granular Rough Mereological Classiﬁers . . . . . .
322
9.3
Classiﬁcation by Granules of Training Objects . . . . . . . . . . .
324
9.4
A Treatment of Missing Values. . . . . . . . . . . . . . . . . . . . . . . . .
326
9.5
Granular Rough Mereological Classiﬁers Using Residuals . .
329
9.6
Granular Rough Mereological Classiﬁers with Modiﬁed
Voting Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
331
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
333
Author Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
335
Term Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
341

Chapter 1
On Concepts. Aristotelian and
Set–Theoretic Approaches
In this chapter the reader is introduced to the idea of a concept. Historically,
two main approaches can be discerned toward formalization of this idea.
First, a holistic approach by Aristotle, in which a concept is construed as a
term (category) by which any object can be either styled or not. This fact of
calling an object a by a name term A is denoted by the formula a is A. With
those formulas, Aristotle built a complete theory of concepts, the Calculus of
Syllogisms, brieﬂy exposed in section 1.1, below.
The alternative approach emerged with Georg Cantor’s set theory in mid–
19th century and its essence was a representation of a concept by its elements;
the relation of being an element was expressed as with Aristotle by the pred-
icate is written down as ϵ (the ’esti’ symbol): the formula aϵA reads an object
a is an element of the concept (set) A. We oﬀer in section 1.2 and following,
an outline of modern set theory, aimed at establishing a terminology and
basic facts of set theory, which seem to be indispensable to any researcher in
computer science.
1.1
An Aristotelian View on Concepts
It is a property of human mind that it classiﬁes its perceptions and, in a sense,
granulates them into concepts denoted with names. To this peculiar property,
each theory of reality is by necessity bound to relate, see Boche´nski [4] for a
discussion. Assuming that reality consists of objects (entities), those objects
fall unto concepts and the basic logical construct is the copula ‘is’: an expres-
sion a is A means that an object denoted a conforms to the concept denoted
A, like in the classical exemplary phrase ‘Socrates is man’, where ‘Socrates’ is
an object and ‘man’ a concept denoting the generality of mankind. In terms of
concepts and statements of belonging into concepts, relations among objects,
concepts and objects, and among concepts are described, and true statements
about these relations constitute knowledge, see Boche´nski, op. cit.
The ﬁrst logical system ever conceived was constructed on these lines, due
to Aristotle [1], see Lukasiewicz [15], [14], Slupecki [24]. Aristotle’s Syllogistic
has as primitive terms expressions of the form Xa is Y b which ramify into
the following four specialized cases
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 1–43.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

2
1 On Concepts. Aristotelian and Set–Theoretic Approaches
1. All a is b;
2. Some a is b;
3. Some a is not b;
4. No a is b,
where ‘All’ and ‘Some’ have the intuitive meaning of nowadays’ ‘every’ and
‘exists’, respectively.
Aristotle’s syllogisms, i.e., meaningful expressions of Syllogistic, are of the
form of an implication
If p and q then r
(1.1)
where p, q, r are of one of four possible forms, written down in traditionally
slightly modiﬁed shape.
In case 1: Aab stands for all a is b (universal aﬃrmative qualiﬁcation).
In case 2: Iab stands for some a is b (existential aﬃrmative qualiﬁca-
tion).
In case 3: Oab stands for some a is not b (existential negative qualiﬁcation).
In case 4: Eab stands for no a is b (universal negative qualiﬁcation).
In syllogisms of the form (1.1), either of four types of statements may appear
for any of p, q, r. This uniformity had been one of reasons which prompted
Aristotle to exclude singular, individual terms from his Syllogistic (in spite
of some examples in which individual terms do appear), see Lukasiewicz [15].
Also, we have to presume that all terms we consider are non–empty, cf., loc.
cit. Looked at from contemporary point of view, syllogistic may be regarded
as an attempt at deriving in a systematic way all rules of arguing with non–
empty non–singleton sets (i.e., collective properties) based on containment
(i.e., being a subset) and on non–empty intersection.
Aristotle himself had been giving proofs of his syllogisms by means of
na¨ıve (i.e., not formalized) propositional calculus and its self–evident rules,
by falsifying not accepted syllogisms by means of substitutions of speciﬁc
terms in place of general variables and by using some auxiliary rules (e.g.,
laws of conversion, see below). A historic merit of Aristotle’s system is also
ﬁrst usage of variables.
The Aristotle Syllogistic had been given a formal axiomatic form in
Lukasiewicz [14]; see also Lukasiewicz [15]. In this axiomatization, Lukasiewicz
had exploited propositional logic, including its axioms T1–T3, see Ch. 3, to
form a part of the axiomatic system of Syllogistic. In addition to axioms of
propositional logic, the following statements form this axiomatic system

1.1 An Aristotelian View on Concepts
3
S1 Aaa
S2 Iaa
S3 If Amb and Aam, then Aab
S4 If Amb and Ima, then Iab
Axioms S1, S2 are clearly not genuine syllogisms but their inclusion is moti-
vated by historic reasons as well as by technical reasons (see a discussion in
Lukasiewicz [15]). Axioms S3, S4 are genuine syllogisms, which may be re-
garded as self–evident and not requiring any proof. Traditionally, syllogisms
are known by their names in which functors appearing in them are listed.
Thus S3 has been called Barbara and S4 has been called Datisi.
Rules of derivation are the following
Detachment (Modus Ponens) Once α, If α then β are derived (or, ac-
cepted), then β is derived (resp., accepted).
Substitution In theses of syllogistic, we may substitute for equiform proposi-
tional variables meaningful expressions containing constants of propositional
logic as well as of syllogistic.
Replacement by equivalents We may replace expressions on right–hand
sides of the following deﬁnitions with their left–hand sides equivalents
D1 Oab = NAab
D2 Eab = NIab
The proof of completeness (see Ch. 3 for the completeness property) of Syl-
logistic can be found in Lukasiewicz [15].
Lukasiewicz (op.cit.) derives formally all the moods:
Barbara, Celarent, Darii, Ferioque prioris,
Cesare, Camestres, Festino, Baroco secundae,
Tertia Darapti, Disamis, Datisi, Felapton, Bocardo, Ferison, habet
Quarta insuper addit Bramantip, Camenes, Dimaris, Fesapo, Fresision

4
1 On Concepts. Aristotelian and Set–Theoretic Approaches
These are the names of 19 moods, as the medieval verse has them, apart from
ﬁve that are sub–alternates (see below) of above
Barbari, Celaront, Cesaro, Camestrop, Camenop
Altogether there are 24 valid moods, collected in four Figures (prima, se-
cunda, tertia, quarta). The terminology related to syllogisms is as fol-
lows. In the statement Xab, a is the subject and b is the predicate, where
X = A, I, O, E. For a syllogistic ﬁgure of the form (1.1), statements p, q are
premises of which p is the major, q is the minor, and r is the conclusion. The
predicate in the conclusion is the major term, the subject in the conclusion
is the minor term, and the remaining term is the middle term.
All valid syllogisms are traditionally divided in four Figures depending on
the position of the middle term m in premises. We list Figures in their sym-
bolic representation.
Figure 1: m is the subject in the major premise and the predicate in the
minor premise; the symbolic representation is mb,am
ab
.
Figure 2: m is the predicate in both premises; the symbolic representa-
tion: bm,am
ab
.
Figure 3: m is the subject in both premises; symbolically, mb,ma
ab
.
Figure 4: m is the predicate in the major premise and the subject in the
minor premise; symbolically, bm,ma
ab
.
An easy count shows that each Figure may consist of at most 43 distinct
syllogisms, one for each of 43 ways to select three out of the four functors
A, I, O, E. Thus the total number of syllogisms does not exceed 4×43 = 256.
It turns out that only 24 of them are valid, as the remaining ones may be
falsiﬁed by examples.
It is worthwhile to look at these moods; they reveal quite ingenious mech-
anism of logical inference due to medieval followers of Aristotle, a mechanism
comparable to our present-day designs of inference engines.
The Square of Opposition pairs expressions Aab, Iab, Eab, Oab as follows
Contraries: Aab, Eab: may be simultaneously false, but never simultane-
ously true;
Sub–contraries: Iab, Oab: may be simultaneously true, but never simul-
taneously false;

1.1 An Aristotelian View on Concepts
5
Sub–alternates: Aab, Iab; Eab, Oab. If Aab is true, then Iab is true; if Eab
is true, then Oab is true;
Contradictories: Aab, Oab; Eab, Iab. In each pair, exactly one is true and
exactly one false
Hence, we have: Barbara Amb,Aam
Aab
, Celarent Emb,Aam
Eab
, Darii Amb,Iam
Iab
, Fe-
rio Emb,Iam
Oab
, Barbari Amb,Aam
Iab
, Celaront Emb,Aam
Oab
in First Figure.
Cesare Ebm,Aam
Eab
, Camestres Abm,Eam
Eab
, Festino Ebm,Iam
Oab
, Baroco Abm,Oam
Oab
,
Cesaro Ebm,Aam
Oab
, Camestrop Abm,Eam
Oab
belong in Second Figure.
Darapti Amb,Ama
Iab
, Disamis Imb,Ama
Iab
, Datisi Amb,Ima
Iab
, Felapton Emb,Ama
Oab
,
Bocardo Omb,Ama
Oab
, Ferison Emb,Ima
Oab
in Third Figure.
Finally, Bramantip Abm,Ama
Iab
, Camenes
Abm,Ema
Eab
, Dimaris
Ibm,Ama
Iab
, Fe-
sapo Ebm,Ama
Oab
, Fresison Ebm,Ima
Oab
, Camenop Abm,Ema
Oab
in Fourth Figure.
What do these names mean? Let us look at them at a close range. At
the ﬁrst glance, we notice that the sequence of vowels in the name corre-
sponds to the sequence of operators in the mood, like aaa in Barbara. But
what about consonants?
For the ﬁrst letters: The initial capital letter in the name of any mood of
Figures 2-4 points to a unique mood in First Figure to which the former can
be ”reduced”. What ”reduction” means?
Well, it goes back to Aristotle (loc.cit.): in premises beginning with E or I,
terms may be permuted without aﬀecting the truth (the ”simpliciter”, or s,
conversion). As for premises starting with A, the conversion goes in two steps:
ﬁrst, change A to I, by force of sub–alternation, and then reduce simpliciter.
This two–stage reduction is ”per accidens”.
Now, given a mood, its name suggests a way of reduction: the initial capital
letter points to the mood in First Figure. The letter ‘s’ after a premise capital
letter suggests simpliciter conversion of the premise; the letter ‘p’ suggests
the ”per accidens” conversion. When ‘s’ or ‘p’ occur as last letters in the
name, this suggests the conversion of the concluding premise. The letter ‘m’
suggests that one has to change the order of premises (mutare), and the
letter ‘c’ not in the ﬁrst position suggests a complex way of reducing by
means of contradiction (reductio ad absurdum): only Baroco and Bocardo
are experiencing this.
So here is an automated (mechanical) system of deduction allowing for
reducing moods to moods of First Figure in case they are valid. This system
was proved to be a complete logical description of relations among concepts
based on intersection and containment, cf., Slupecki [24].

6
1 On Concepts. Aristotelian and Set–Theoretic Approaches
Syllogistic oﬀers, in a sense, a ‘holistic’ view on concepts. It is a complete
theory of concepts, treated with respect to containment and intersection.
But, no possibility of having an insight into inner structure of concepts is
oﬀered here; and, it is diﬃcult to bear, for a human, not to be able to see
inner workings of any mechanism. Thus, another approach prevailed in the
long run, and sets emerged as built from elements. This approach has caused
serious logical problems, not fully resolved and probably not to be resolved
in future, but sets have provided language for mathematics.
1.2
From Local to Global: Set Theory
The problem of theory of classes was taken up by modern logic and mathe-
matics and the result was the emergence of modern Set Theory. Its principal
feature seems to be the fact that global properties of sets are obtained from
local properties of set elements by augmenting the sentential calculus with
new expressions formed by means of quantiﬁers, i.e., by means of the predicate
calculus, see Ch. 3. We will be now interested in this new language exploiting
calculus of predicates which will allow us to discuss individuals and general
terms in their mutual relations. This is the language of Set Theory. This
language will be based on the predicate calculus and on some new notions,
notably that of a set.
We will apply new operators: ∀x.. (read: for every x ......) and ∃x... (read:
there exists x such that ...). The intuitive meaning of these expressions will
be: ∀xα(x) will mean that α(c) is true for each substitution x/c where c
belongs in a speciﬁed domain (the scope of the quantiﬁer ∀) and ∃xα(x) will
mean that for some substitution x/c the formula α(c) is true. We will often
use restricted quantiﬁcation of the form ∀x ∈U..., ∃x ∈U... meaning that
substitutions described above are restricted to elements c ∈U, U a speciﬁed
domain (set).
In development of Set Theory ﬁrst the so–called Na¨ıve Set Theory pre-
vailed, see Cantor [6]; a set was conceived intuitively as a collection of objects
bound by a property. In a later approach, it was based on the conviction that
sets and properties are equivalent notions, i.e., to each property there corre-
sponds a set of objects having this property and vice versa, see Frege [9]. This
approach led to some contradictions (antinomies) and had to be replaced by
a formal approach based on axiom schemes and derivations rules. Neverthe-
less, Na¨ıve Set Theory retains its usefulness as in practical considerations and
applications one faces a very slight chance to come at an antinomy.
We will ﬁrst present a na¨ıve exposition of set theory concentrating above
all on set operations and various related notions and then we will give a more
advanced treatment in which some formal issues will be discussed.

1.2 From Local to Global: Set Theory
7
1.2.1
Na¨ıve Set Theory
Language of elementary set theory uses two primitive expressions: set and to
be an element and it makes usage of constants and variables which may be
divided into the following types (see Ch.3 for a formal rendering of proposi-
tional as well as predicate calculi).
1. Variable symbols for sets: X, Y, Z, ..., x, y, z...;
2. Predicate constant = (identity);
3. Predicate constant ∈( esti symbol: to be an element);
4. Symbols for propositional connectives: ⇒, ¬, ∨, ∧, ⇔;
5. Symbols for quantiﬁers: ∀, ∃;
6. Auxiliary symbols (parentheses, commas, dots etc.)
We recall that the symbol ∀x reads for all x ... and the symbol ∃x reads there
exists x such that ... . Meaningful expressions of set theory are derived from
elementary meaningful expressions: x ∈Y (the set x is an element of the set
Y ), X = Y (the set X is identical to the set Y ) by the following inductive
rules.
If α, β are meaningful expressions then
1. α ⇒β, ¬α, α ∨β, α ∧β are meaningful expressions;
2. ∀xα, ∃xα are meaningful expressions.
1.2.2
Algebra of Sets
First of all, we state when two sets are identical to each other. This will
happen when those sets have the same elements (extensionality property).
Formally
X = Y ⇔∀x(x ∈X ⇔x ∈Y )
(1.2)
It follows from this equivalence that if a set is speciﬁed by a condition im-
posed on its elements, then this condition determines the set uniquely. We
will apply this in practice constantly. An important application is the Alge-
bra of sets concerned with some operations on sets leading to possibly new
sets. Having some sets, we may construct from them new sets by means of
logical operations. Assume we are given two sets X, Y . Then we may form
the following sets.
1. X ∪Y (the union of sets X and Y ) deﬁned as follows by virtue of set
identity condition
x ∈X ∪Y ⇔∀x(x ∈X ∨x ∈Y )
(1.3)
X ∪Y consists of those sets which are elements either in X or in Y .

8
1 On Concepts. Aristotelian and Set–Theoretic Approaches
2. X ∩Y (the intersection of sets X and Y ) deﬁned as follows
x ∈X ∩Y ⇔∀x(x ∈X ∧x ∈Y )
(1.4)
X ∩Y consists of those sets which are elements in X and in Y . Sometimes
the intersection X ∩Y is referred to as the common part of X and Y .
3. X \ Y (the diﬀerence of X and Y ) is deﬁned via
x ∈X \ Y ⇔∀x(x ∈X ∧¬(x ∈Y ))
(1.5)
X \ Y consists of those sets which are elements in X but they are not
elements in Y . The diﬀerence X \ Y is sometimes referred to as the com-
plement to Y in X.
4. The union X \Y ∪Y \X is referred to as the symmetric diﬀerence denoted
X△Y .
The operations of union, intersection and diﬀerence allow for a rich structure
which may be created on the basis of given sets. We may apply known to us
laws of propositional and predicate calculi in order to establish general laws
governing operations on sets. Let us list those general laws of algebra of sets.
We will rely on theses of propositional calculus applied to statements of the
form x ∈X for a given x.
We have
X ∪Y = Y ∪X
(1.6)
which follows from the thesis (i) p ∨q ⇔q ∨p of propositional calculus as
x ∈X ∪Y is equivalent to x ∈X ∨x ∈Y and x ∈Y ∨X is equivalent to
x ∈Y ∨x ∈X so we get (1.6) by substituting in (i) p/x ∈X, q/x ∈Y .
In what follows we will only point to the respective thesis of propositional
calculus leaving the veriﬁcation to the reader.
X ∪(Y ∪Z) = (X ∪Y ) ∪Z
(1.7)
follows from the thesis (ii) p ∨(q ∨r) ⇔(p ∨q) ∨r.
X ∪X = X
(1.8)
follows from the thesis (iii) p ∨p ⇔p. (1.6) is the commutativity law for the
union, (1.7) is the associativity law for the union and (1.8) is the idempotency
law for the union.
Similarly, we have the corresponding laws for the intersection based on
dual theses of propositional calculus in which we replace ∨with ∧.
X ∩Y = Y ∩X
(1.9)
which follows from the thesis (iv) p ∧q ⇔q ∧p of propositional calculus.
X ∩(Y ∩Z) = (X ∩Y ) ∩Z
(1.10)

1.2 From Local to Global: Set Theory
9
follows from the thesis (v) p ∧(q ∧r) ⇔(p ∧q) ∧r of propositional calculus.
X ∩X = X
(1.11)
follows from the thesis (vi) p ∧p ⇔p.
Properties (1.9), (1.10), (1.11) are called, respectively, the commutativity,
associativity, idempotency laws for the intersection of sets.
Relations between the two operations are expressed by the distributivity
laws which are
X ∩(Y ∪Z) = (X ∩Y ) ∪(X ∩Z)
(1.12)
which follows by the thesis (vii) p ∧(q ∨r) ⇔(p ∧q) ∨(p ∧r) of propositional
calculus and
X ∪(Y ∩Z) = (X ∪Y ) ∩(X ∪Z)
(1.13)
which follows by the thesis (viii) p∨(q ∧r) ⇔(p∨q)∧(p∨r) of propositional
calculus dual to (vii).
These operations may be performed on arbitrary given sets; up to now we
did not mention any speciﬁc set. So now we introduce an example of a set.
The set denoted by the symbol ∅does satisfy the following condition
x ∈∅⇔¬(x = x)
(1.14)
Thus, the empty set has no element, it is void. Clearly, it plays the role of
the zero element by the union and intersection of sets
X ∪∅= X
(1.15)
which follows by the thesis (ix) p ∨(q ∧¬q) ⇔p, and
X ∩∅= ∅
(1.16)
which follows by the thesis (x) p ∧(q ∧¬q) ⇔q ∧¬q.
We say that sets X, Y are disjoint when X ∩Y = ∅.
We may yet bring the diﬀerence operator into play and observe its properties.
X ∩(Y \ Z) = X ∩Y \ Z
(1.17)
follows from the thesis (xi) p ∧(q ∧r) ⇔(p ∧q) ∧r,
X \ (Y ∪Z) = (X \ Y ) ∩(X \ Z)
(1.18)
follows from the thesis (xii) ¬(q ∧r) ⇔¬q ∨¬r,
X \ (Y ∩Z) = (X \ Y ) ∪(X \ Z)
(1.19)
follows from the thesis (xiii) ¬(q ∨r) ⇔¬q ∧¬r.

10
1 On Concepts. Aristotelian and Set–Theoretic Approaches
Property (1.17) is the distributivity law of intersection with respect to
diﬀerence and (1.18), (1.19) are De Morgan laws.
Properties of the symmetric diﬀerence follow easily in a similar manner.
We list some of them.
X△Y = Y △X
(1.20)
follows by the commutativity of the union,
X△(Y △Z) = (X△Y )△Z
(1.21)
follows by checking on the basis of already established laws that
X△(Y △Z) = [X \ (Y \ Z)] ∩[X \ (Z \ Y ]) ∪[(Y \ Z) \ X] ∪[(Z \ Y ) \ X] =
[X \ (Y ∪Z)] ∪[Y \ (X ∪Z)] ∪[Z \ (X ∪Y )] ∪(X ∩Y ∩Z).
As by (1.20) we have (X△Y )△Z = Z△(X△Y ) it suﬃces to replace in
the last derived formula symbols of set variables to get that (X△Y )△Z =
[X \ (Y ∪Z)] ∪[Y \ (X ∪Z)] ∪[Z \ (X ∪Y )] ∪(X ∩Y ∩Z) and thus (1.21)
follows.
Property (1.21) is the associativity law for the symmetric diﬀerence. A
particular case is
X△(X△Y ) = Y
(1.22)
Similarly,
X ∩(Y △Z) = [(X ∩Y )△(X ∩Z)]
(1.23)
follows by checking that each of sides is identical to the set [(X ∩Y ) \ ((X ∩
Z)] ∪[(X ∩Z) \ (X ∩Y )].
Property (1.23) is the distributivity law for intersection with respect to the
symmetric diﬀerence.
We may also note two simple properties that follow immediately from the
deﬁnition of the symmetric diﬀerence, viz.,

X△X = ∅
X△∅= X
(1.24)
Restoring the union and the diﬀerence from the intersection and the sym-
metric diﬀerence may be done on the basis of the following identities

X ∪Y = X△(Y △(X ∩Y ))
X \ Y = X△(X ∩Y )
(1.25)
Yet another method of expressing ways in which sets are related one to an-
other is to compare them with respect to inclusion.
We say that a set X is a subset of a set Y which is denoted X ⊆Y when
the following condition is fulﬁlled

1.2 From Local to Global: Set Theory
11
∀x(x ∈X ⇒x ∈Y )
(1.26)
Thus being a subset of a set means consisting of possibly not all elements of
this set.
Being a subset does satisfy also certain laws of which we may mention the
following easy to establish ones
X ⊆Y ∧Y ⊆Z ⇒X ⊆Z
(1.27)
X ⊆X
(1.28)
∅⊆X
(1.29)
X ⊆Y ∧Y ⊆X ⇒X = Y
(1.30)
where (1.27) does express transitivity of inclusion, (1.30) states the weak
symmetry of it; (1.28) says that any set is included in itself and (1.29) states
that the empty set is included in any set (by the fact that implication from
false to true has the truth value 1).
In many considerations involving sets, we restrict ourselves to sets which
are subsets of a given ﬁxed set U called in such a case the universe. In this
case we may have some shortcut notation notably the diﬀerence U \ X for
X ⊆U is denoted Xc and it is called the complement of X.
The reader will undoubtedly establish many more properties of operations
on sets in case of need; we will meet some in the sequel. We introduce a new
notion of a ﬁeld of sets.
By a ﬁeld of sets, we will understand a non–empty set B of subsets of a
certain universe U, which is such that results of operations △, ∩performed
on its elements are again its elements and U is its element. More formally, B
does satisfy the following requirements
1. ∀x(x ∈B ⇒x ⊆U);
2. U ∈B;
3. ∀x, y(x, y ∈B ⇒x△y ∈B);
4. ∀x, y(x, y ∈B ⇒x ∩y ∈B).
Let us observe that as B contains at least one element, e.g., U, it does contain
U△U = ∅. Also the identity
x ∪y = (x△y)△x ∩y
shows that
5. ∀x, y(x, y ∈B ⇒x ∪y ∈B).

12
1 On Concepts. Aristotelian and Set–Theoretic Approaches
It states that any ﬁeld of sets is closed with respect to the union of its
elements. Similarly, by the identity
xc = U△x
we have
6. ∀x(x ∈B ⇒xc ∈B).
This means that any ﬁeld of sets is closed with respect to complements of its
elements. We get a characteristics of ﬁeld of sets. Clearly, any set of sets closed
on union, intersection, and complement is closed on symmetric diﬀerence.
Proposition 1.1. A set B of subsets of a set U is a ﬁeld of sets if and only
if it is non–empty and it is closed with respect to operations of the union, the
intersection and the complement.
A simple example of a ﬁeld of sets is the power set of U denoted 2U consisting
of all subsets of U, i.e.,
x ∈2U ⇔x ⊆U
1.2.3
A Formal Approach
As already observed, we may perform some operations on sets once we are
given them, but it has turned out in the historic process of development of
set theory that na¨ıve, intuitive approach led to some serious problems and
contradictions. This motivated attempts at laying strict foundations for set
theory. Studies in this respect led to some axiomatic systems of set theory,
e.g., the Zermelo–Fraenkel system, introduced in Zermelo [30], [31], and mod-
iﬁed, among others (Mirimanoﬀ, Skolem, G¨odel, Bernays, von Neumann), in
Fraenkel [8]. We will not need the full power of this system, so we ﬁrst re-
strict ourselves to a subsystem which guarantees us the existence of some
basic means for new set construction.
We review below some axiomatic statements about sets which guarantee
the existence of some sets as well as the possibility of performing some oper-
ations on them.
A1 (There exists the empty set): ∃X(∀x(x ∈X ⇒x ̸= x))
This axiom guarantees that there exists at least one set.
A2 (The extensionality axiom) ∀x(x ∈X ⇔x ∈Y ) ⇒X = Y
This axiom does express our intuition that sets consisting of the same el-
ements should be identical to each other. A fortiori, it does guarantee the
uniqueness of other sets implied by the axioms.

1.2 From Local to Global: Set Theory
13
A3 (The unordered pair axiom) Given any two objects a, b, the following
holds:
∃X(∀x(x ∈X ⇔x = a ∨x = b))
This axiom guarantees that for any two objects a, b there exists a set whose
only elements are a and b. We denote this set by the symbol {a, b} and we
call it the unordered pair of elements a, b. In case a = b, we call this set a
singleton and we denote it by the symbol {a}.
From this axiom, the existence of the set {{a}, {a, b}} follows immediately.
We denote this set by the symbol < a, b > and call it the ordered pair of
elements a, b.
The reader will check the following basic property of the ordered pair
Proposition 1.2. Given elements a, b, c, d we have < a, b >=< c, d > if and
only if a = c, b = d.
For the proof, we hint that < a, b >=< c, d > i.e. {{a}, {a, b}} = {{c}, {c, d}}
implies {a}={c} or {a, b} = {c} so a = c. Similarly, {c, d}={b} or {c, d} =
{a, b} hence b = c = d or b = d. So either a = b = c = d or a = b, c = d and
the thesis follows.
The procedure of generating ordered pairs may be repeated: given objects
a1, ..., ak, we may deﬁne inductively the ordered k–tuple
< a1, ..., ak >
by letting
< a1, ..., ak >=<< a1, ..., ak−1 >, ak >
Clearly, inducting on k, we get the following extension of the last proposition:
< a1, ..., ak >=< b1, ..., bk > if and only if ai = bi for i = 1, 2, ..., k.
A4 (The union of sets axiom)
∀X(∃Z∀x(x ∈Z ⇔∃Y (x ∈y ∧Y ∈Z)))
This axiom guarantees that for any set X there exists a set (uniquely deﬁned
by extensionality) Z whose elements are those sets which are elements in
some element of X. The set Z is denoted  X and it is called the union of
X. This setting may imply that X is a set whose elements are sets; for this
reason, to avoid a phrase like a set of sets, X is said to be a family of sets,
so Z is the union of this family.
We may consider the case when X is looked on as a family of subsets of
the universe  X, hence, the set

X =

X \

{

X \ A : A ∈X)}
(1.31)
is well–deﬁned; we call it the intersection of the family X of sets. Clearly,

14
1 On Concepts. Aristotelian and Set–Theoretic Approaches
x ∈

X ⇔∀A(A ∈X ⇒x ∈A)
(1.32)
Particular applications for this axiom are found in case of the two sets X, Y :
clearly, in this case we have {X, Y } = X ∪Y . Another application is in
the formation of ﬁnite unordered tuples: given objects a1, a2, ..., ak, we may
form the union of singletons {ai} for i = 1, 2, ..., k, by induction as follows:
{a1, ..., ak} = {a1, ..., ak−1}∪{ak}. The set {a1, ..., ak} is called the unordered
k–tuple of elements a1, a2, ..., ak.
To get more specialized sets, we need new axioms. In particular, given a
set X and a predicate Ψ(x) expressing a certain property of objects, we may
want to consider the new set whose elements are those elements of X which
after being substituted for x satisfy Ψ(x). We need an axiom which would
guarantee the existence of such a set.
A5 (The axiom schema of separation) Given a set X and a predicate Ψ(x),
the following holds
∃Y ∀x(x ∈Y ⇔Ψ(x) ∧x ∈X)
The (unique) set Y is denoted often by the symbol {x ∈X : Ψ(x)}. Let us
observe for example, that given in addition a set Z, the diﬀerence X \ Z may
be obtained via A5 as the set {x ∈X : ¬(x ∈Z)}. Similarly, the intersection
X ∩Z, is the set {x ∈X : x ∈Z}.
We may also want for any set X to form a new set whose elements are all
subsets of X, i.e., the familiar to us ﬁeld of sets 2X. For this also we need a
new axiom which however may be regarded from foundational point of view
as too strong.
A6 (The axiom of the power set) Given a set X, the following holds
∀X(∃Y ∀x(x ∈Y ⇔x ⊆X))
The set Y is denoted with the symbol 2X (the exponential set of X, the power
set of X). It is unique by extensionality.
Finally, we may want to form a new set from a given one by a transfor-
mation via a predicate of functional character (in a sense, we want to map a
given set onto a new one). For this, we also need a new axiom.
A7 (The axiom schema of replacement) Consider a binary predicate Ψ(x, y)
with the following property
(i) ∀x, y, z(Ψ(x, y) ∧Ψ(x, z) ⇒y = z)
Then, if Ψ(x, y) does satisfy (i), then
∀X∃Y (y ∈Y ⇔∃x(x ∈X ∧Ψ(x, y)))

1.3 Relations and Functions
15
The set Y may be called the image of the set X by Ψ and we may denote it
by the symbol Ψ(X).
The axiom A7 is stronger than A5: given Ψ(x) as in the formulation of
A7, we may deﬁne a binary predicate Φ as follows: Φ(x, y) is x = y when
Ψ(x) is satisﬁed and Φ(x, y) is x = a where a is a ﬁxed element not in the
set X when Ψ(x) is not satisﬁed. Then, the set Φ(X) is identical to the set
{x ∈X : Ψ(x)}.
1.3
Relations and Functions
The notion of an ordered pair allows for a formalization of the important
notions of a relation as well as of a function.
Informally, a (binary) relation is a constraint on ordered pairs < x, y >
where x ∈X, y ∈Y ; thus, a formalization of a relation is done via a choice
of a set of pairs which satisfy this constraint.
First, given sets X, Y , we form the set X × Y of all ordered pairs of the
form < x, y > where x ∈X, y ∈Y . We thus let
X × Y = {< x, y >: x ∈X, y ∈Y }
(1.33)
The existence of this set may be justiﬁed on the basis of axioms: we ﬁrst may
form the set 2X∪Y of all subsets of the set X ∪Y and then the set 22X∪Y ,
both by axiom A6. Letting Ψ(A) to be satisﬁed by A if and only if
∃x∃y(x ∈X ∧y ∈Y ∧A = {{x}, {x, y}})
we obtain X × Y as the set {A ∈22X∪Y : Ψ(A)} by axiom A7.
The set X × Y is called the Cartesian product of the set X and the set Y .
A binary relation R on X × Y is a subset R of the set X × Y . For x, y such
that < x, y >∈R we say that x, y are in the relation R and we also write
xRy to denote this fact. We let
domR = {x ∈X : ∃y(< x, y >∈R)}
(1.34)
and we call domX the domain of R; similarly, we let
codomR = {y ∈Y : ∃x(< x, y >∈R)}
(1.35)
and we call codomR the codomain of R.
As relations are sets, usual set operations may be performed on relations:
for relations R, S on the Cartesian product X × Y , the union R ∪S, the
intersection R ∩S, and the diﬀerence R \ S are deﬁned in the usual way.
There is however more to relations: due to the structure of their elements as
ordered pairs, we may have more operations on relations than on ordinary
sets and these operations constitute what is called the Algebra of relations.

16
1 On Concepts. Aristotelian and Set–Theoretic Approaches
1.3.1
Algebra of Relations
First, for any relation R ⊆X × Y , we may introduce the inverse to R which
is the relation R−1 ⊆Y × X deﬁned as
yR−1x ⇔xRy
(1.36)
Properties of this operation are collected in
Proposition 1.3. The following are properties of inverse relations
1. (R ∪S)−1 = R−1 ∪S−1;
2. (R ∩S)−1 = R−1 ∩S−1;
3. (R \ S)−1 = R−1 \ S−1.
Indeed, for instance in case of Property 1,
< y, x >∈(R ∪S)−1 ⇔< x, y > ∈R ∪S ⇔
which in turn is equivalent to
< x, y > ∈R ∨< x, y > ∈S ⇔< y, x > ∈R−1 ∨< y, x > ∈S−1
i.e.,
< y, x > ∈R−1 ∪S−1
The proof in remaining cases goes along similar lines.
Relations may also be composed; for relations R ⊆X × Y , S ⊆Y × Z, the
composition (or, superposition) R ◦S ⊆X × Z is deﬁned as follows
< x, z >∈R ◦S ⇔∃y(y ∈Y ∧< x, y > ∈R∧< y, z > ∈S)
(1.37)
The operation of relation composition does satisfy easy to be checked
properties.
Proposition 1.4. Basic properties of the operation of relation composition
are
1. (R ∪S) ◦T = (R ◦T ) ∪(S ◦T );
2. (R ∩S) ◦T = (R ◦T ) ∩(S ◦T );
3. (R ◦S)−1 = S−1 ◦R−1;
4. (R ◦S) ◦T = R ◦(S ◦T ).

1.3 Relations and Functions
17
These properties are proved similarly to those of the preceding proposition.
For a set X, the relation idX = {< x, x >: x ∈X} is called the identity
relation on X. Given a relation R on X × Y , we have
Proposition 1.5. The identity relation satisﬁes the following
1. iddomR ⊆R ◦R−1;
2. idco−domR ⊆R−1 ◦R;
3. iddomR ◦R = R;
4. R ◦idco−domR = R.
Indeed, in case of Property 1, for x ∈domR, there is y ∈Y with < x, y >∈R
hence < y, x >∈R−1 so < x, x >∈R ◦R−1. The proof for Property 2 is on
the same lines. Properties 3 and 4 are obvious.
One more operation one may perform on relations is restriction. Given a
relation R ⊆X × Y , and a subset A ⊆X, the restriction R|A is R ∩A × Y .
Functions are a special class of relations singled out by the uniqueness
property: a relation R ⊆X × Y is a function if and only if the following
property is observed
∀x∀y∀z(xRy ∧xRz ⇒y = z)
(1.38)
In this case R is said to be a function from the set X into the set Y and
the notation R : X →Y is in use. To denote functions, usually small letters
f, g, h, k, ... are used and in place of the formula xfy we write y = f(x) calling
y the value of f at the argument x.
A function f : X →Y is said to be injective in case the following is satisﬁed
∀x∀x′(f(x) = f(x′) ⇒x = x′)
(1.39)
For a subset A ⊆X, the image fA of A by a function f : X →Y is the set
{y ∈Y : ∃x ∈A(y = f(x))}
(1.40)
Similarly, for B ⊆Y , the inverse image f −1B is the set
{x ∈X : ∃y ∈B(y = f(x))}
(1.41)
Proposition 1.6. Operations of image and inverse image do satisfy the fol-
lowing rules
1. f(A ∪B) = fA ∪fB;
2. f(A ∩B) ⊆fA ∩fB;

18
1 On Concepts. Aristotelian and Set–Theoretic Approaches
3. f −1(A ∪B) = f −1A ∪f−1B;
4. f −1(A ∩B) = f −1A ∩f−1B;
5. f −1(A \ B) = f −1A \ f −1B.
These facts are easily established; let us note the diﬀerence between Proper-
ties 2 and 4: in case of Property 2 we have only inclusion as for some f even
disjoint sets may be mapped onto the same image, whereas in Property 4 we
have identity by the uniqueness of the value of a function.
A function f : X →Y maps X onto Y (f is a surjection) if and only if
fX = Y . A function f which is injective and onto is said to be a bijection
between X and Y . For a bijection f, the relation f−1 is again a function
f −1 : Y →X called the inverse of f. Let us observe that the function f −1 is
a bijection between Y and X. Clearly, for a bijection f, it may not happen
that disjoint sets map to the same value so in 2 above we have the identity:
f(A ∩B) = fA ∩fB.
1.4
Ordering Relations
Relations on a Cartesian product X ×X with X = domR are called relations
on the set X; they are classiﬁed according to some properties,viz.,
1. (Reﬂexivity) ∀x(xRx);
2. (Symmetry) ∀x∀y(xRy ⇒yRx);
3. (Weak anti–symmetry) ∀x∀y(xRy ∧yRx ⇒x = y);
4. (Linearity) ∀x∀y(xRy ∨x = y ∨yRx);
5. (Transitivity) ∀x∀y∀z(xRy ∧yRz ⇒xRz).
A relation R on a set X is an ordering on X if and only if R is reﬂexive, weak
anti–symmetric and transitive. In this case we write x ≤R y in place of xRy.
An ordering ≤R on the set X is linear in case R is linear; we say also that
X is linearly ordered by R. More generally, we say that a subset Y ⊆X of a
set X ordered by an ordering R is a chain in X when the restriction R|Y ×Y
is linear.
An ordering does stratify elements of its domain; x, y ∈X are comparable
if x ≤R y ∨y ≤R x. In case x ≤R y we say that x is less or equal to y.
An element x is an upper bound (respectively a lower bound) of a set A ⊆X
in case a ≤R x for each a in A (respectively, x ≤R a for each a ∈A); an
upper bound x of A is the least upper bound (the supremum of A) in case
x ≤R y for each upper bound y of A and we denote x by the symbol supA.

1.4 Ordering Relations
19
Similarly, we call a lower bound x of A the greatest lower bound (the inﬁ-
mum of A) when y ≤R x for each lower bound y of A. We denote an inﬁmum
of A with the symbol infA. In case inﬁmum respectively supremum are ad-
mitted i.e. infA ∈A respectively supA ∈A we call infA the least element
in A respectively we call supA the greatest element in A.
We denote also by A+ the set of all upper bounds of the set A and by
A−the set of all lower bounds of the set A. Thus, supA = infA+ and
infA = supA−whenever supA, respectively infA exists.
A set Y ⊆X is bounded from above (respectively, bounded from below)
when there exists an upper bound for Y (respectively, a lower bound for Y ).
In search of archetypical orderings, we may turn to inclusion ⊆on the
power set of a given set X. It is clearly an ordering on any family of subsets
of the set X. It is however not linear. To ﬁnd suprema of families of sets with
respect to inclusion, we have to turn to the sum axiom: given a family F of
subsets of X we have supF =  F. Similarly, infF =  F. A family F is
closed with respect to unions when supF ′ ∈F for any F ′ ⊆F; by analogy, F
is closed with respect to intersections when infF ′ ∈F for any F ′ ⊆F.
A set X is completely ordered by an ordering R on X when for any subset
A ⊆X there exist supA and infA. The ordering R is said to be complete in
this case. An example of a complete ordering is inclusion on the power set 2X
for any set X and for any family of sets F ⊆2X its supremum is supF =  F
and its inﬁmum is infF =  F.
Relations on various sets may be compared to each other by means of
functions satisfying adequate conditions. In the general case of a relation R
on the product X × X and a relation S ⊆Y × Y , we say that a function
f : X →Y agrees with R, S when
∀x∀y(xRy ⇒f(x)Sf(y))
(1.42)
In case f is an injection, we say that f is an embedding of R into S and when
f is a bijection, then we say that f is an isomorphism between R and S.
In the particular case when R, S are orderings on respectively sets X, Y ,
we call a function f : X →Y which agrees with R, S an isotone function.
Thus we have for the isotone function f
x ≤R y ⇒f(x) ≤S f(y)
(1.43)
In general there is little one may say about isotone functions; however in
the case when R = S is a complete ordering, isotone functions between R
and S have an important property of having a ﬁxed point which means that
f(x) = x for some x ∈X called a ﬁxed point of f.
Proposition 1.7. (Knaster [11]–Tarski) If f : X →X is an isotone function
on a completely ordered set X then f has a ﬁxed point.
Proof. Clearly, the set A = {x ∈X : x ≤R f(x)} has a supremum supA = a.
As for x ∈A we have x ≤R a, also x ≤R f(x) ≤R f(a) hence a ≤R f(a).

20
1 On Concepts. Aristotelian and Set–Theoretic Approaches
It follows that f(a) ≤R f(f(a)) so f(a) ∈A and hence f(a) ≤a implying
ﬁnally that a = f(a) so a is a ﬁxed point of f
⊓⊔
Given an ordered set X with an ordering ≤one may construct a canonical
isotone embedding of X into a completely ordered by inclusion family of sets.
To this end, we make use of sets A−, A+ deﬁned above for any set A ⊆X.
We state important properties of operations (.)+,−.
Proposition 1.8. The following properties are observed by operations A−, A+
1. A ⊆B ⇒B−⊆A−, B+ ⊆A+;
2. A ⊆(A+)−;
3. B = (A+)−satisﬁes B = (B+)−.
Proof. Property 1 is obvious: anything less (greater) than all elements of B
is also less (greater) than all elements of A. Property 2 is also evident: for
x ∈A we have x ≤a for any a ∈A+ hence x ∈(A+)−. For Property 3,
we ﬁrst notice that as A ⊆B by Property 2, we have by Property 1 that
B+ ⊆A+. But also A+ ⊆B+ by transitivity of ≤. Since A+ = B+, we have
B = (A+)−= (B+)−
⊓⊔
Consider now for x ∈X the set {x}−denoted also (←, x] and called the left
interval of x. We have ((←, x]+)−= (←, x].
We may consider now the function f which assigns to x ∈X its left interval
(←, x]. We may consider f as a function from X into the set I(X) = {A ⊆
X : A = (A+)−} ordered by inclusion. We have
Proposition 1.9. (Dedekind [7], MacNeille [17]) The function f is an iso-
tone function from X into completely ordered by inclusion set I(X). More-
over, f preserves suprema and inﬁma.
Proof. Clearly, x ≤y implies (←, x] ⊆(←, y]. For any A ⊆I(X), we have
infA = ( A+)−, supA = ( A+)−so I(X) is completely ordered. Finally,
given A ⊆X, with a = supA, we have easily that
(←, a] = (

{(←, x] : x ∈A}+)−
i.e., f(supA) = supf(A), and in case of inﬁma we have for b = infA that (←
, b] = {f(x) : x ∈A}, i.e., f(infA) = inff(A)
⊓⊔
We may by this result embed any ordered set into a completely ordered by
inclusion family of sets. Let us observe that the Dedekind–MacNeille embed-
ding is the least one: it embeds X into any completely ordered set into which
X may be embedded isotonically.
A relation between two ordered sets, X ordered by ≤X and Y ordered by
≤Y , can be established by a pair of isotone mappings, f : X →Y, g : Y →X,
which satisfy the postulate

1.5 Lattices and Boolean Algebras
21
f(x) ≤Y y ⇔x ≤X g(y)
(1.44)
which does establish a Galois connection between (X, ≤X) and (Y, ≤Y ).
In the pair (f, g), f is the lower adjoint, g is the upper adjoint. From the
deﬁnition (1.44), the following properties stem.
Proposition 1.10. Essential properties of Galois connections are
1. x ≤X g(f(x)); f(g(y) ≤Y y;
2. g(f(x)) = g(f(g(f(x)))); f(g(y)) = f(g(f(g(y))));
3. x ≤X z ⇒g(f(x)) ≤X g(f)z)); y ≤Y w ⇒f(g(y)) ≤Y f(g(w)).
The mapping g ◦f : X ⇒X, is according to Proposition 1.10, extensive
(Property 1), idempotent (Property 2), isotone (Property 3), i.e., it is a closure
mapping on X. Dually, the mapping f ◦g : Y →Y is co–extensive, idempotent
and isotone, i.e., it is an interior mapping on Y .
1.5
Lattices and Boolean Algebras
An ordered set (X, ≤) in which for each pair x, y there exist the least upper
bound (l.u.b.) sup{x, y} as well as the greatest lower bound (g.l.b.) inf{x, y}
is called a lattice. Usually, sup{x, y} is denoted x ∪y and it is called the join
of x, y while inf{x, y} is denoted x ∩y and it is called the meet of x, y.
When additionally X is endowed with a unary operation −of complemen-
tation and the join and the meet satisfy the following conditions
1. x ∪y = y ∪x, x ∩y = y ∩x;
2. x ∪(y ∪z) = (x ∪y) ∪z, x ∩(y ∩z) = (x ∩y) ∩z;
3. (x ∩y) ∪y = y, (x ∪y) ∩y = y;
4. x ∩(y ∪z) = (x ∩y) ∪(x ∩z), x ∪(y ∩z) = (x ∪y) ∩(x ∪z);
5. (x ∩−x) ∪y = y, (x ∪−x) ∩y = y.
then the lattice X is called a Boolean algebra. We may observe duality here:
replacing ∪/∩, ∩/∪we obtain a dual condition; we may also not confuse
the symbols for the join and the meet used in general with the particular
symbols of set union and intersection. The latter clearly satisfy 1–4. Let us
observe that any ﬁeld of sets is a Boolean algebra with operations of set
union, intersection and complementation. The reader may consult Rasiowa
[21] for a review of lattices, also from the point of view of their roles as models
for logics.

22
1 On Concepts. Aristotelian and Set–Theoretic Approaches
1.6
Inﬁnite Sets
We have witnessed a good deal of standard set theory having basically only
ﬁnite sets (in an informal sense of the word) at our disposal. To introduce
inﬁnite sets, we need a new axiom.
A9 (The inﬁnity axiom) There exists a set X such that (i) ∅∈X (ii)
if A ∈X then A ∪{A} ∈X
Taking the intersection of the family of all sets satisfying axiom A9, we ob-
tain the set N which contains elements 0 = ∅, 1 = ∅∪{∅}, 2 = 1 ∪{1},...,
n + 1 = n ∪{n},... and only those elements. N is the set of natural num-
bers. Having N we may attempt at deﬁning precisely ﬁnite and inﬁnite sets.
A standard way of arguing with natural numbers employs the principle of
mathematical induction.
Proposition 1.11. Assume A ⊆N is such that (i) 0 ∈A (ii) ∀n(n ∈A ⇒
n + 1 ∈A). Then A = N.
Indeed, by (i), (ii), A does satisfy requirements of axiom A9, hence, N ⊆A
and ﬁnally A = N.
The principle of mathematical induction will serve us as a tool in proving
basic facts about natural numbers.
Proposition 1.12. For all natural numbers n, m the following statements
are true
1. n ∈m ⇔n ⊆m ∧n ̸= m;
2. n ∈m ∨n = m ∨m ∈n;
3. n ⊆N ∧n ̸= N;
4. n /∈n.
Proof. For Property 1: we consider A = {m ∈N : ∀n(n ∈m ⇒n ⊆m)}.
Clearly, 0 ∈A by default. Assuming m ∈A, consider m + 1 along with
n ∈m + 1. Then either n ∈m or n = m; in the former case n ⊆m hence
n ⊆m + 1 and in the latter case again n ⊆m whence n ⊆m + 1. Thus
m + 1 ∈A. By the principle of mathematical induction, A = N. This proves
the part (i) n ∈m ⇒n ⊆m.
We now prove Property 4; clearly, 0 /∈0. Assume n /∈n and n + 1 ∈n + 1.
Then either n + 1 ∈n or n + 1 = n. In the former case by (i) n + 1 ⊆n hence
n ∈n, a contradiction. So only n + 1 = n may hold but then again n ∈n, a
contradiction. It follows that we have n + 1 /∈n + 1 and by the principle of
mathematical induction Property 4 holds.
Returning to Property 1, we infer from Property 4 that (ii) n ∈m ⇒n ⊆
m ∧n ̸= m. It remains to prove the converse. Again we apply induction. We

1.7 Well–Ordered Sets
23
use ⊂instead of ⊆∧̸=. So we are going to check that n ⊂m implies n ∈m.
For m = 0 this is true. Assume this is true with m and consider n ⊂m + 1.
Was m ∈n then m ⊂n and m + 1 ⊆n, a contradiction with n ⊂m + 1.
Hence m /∈n and thus n ⊆m. We have either n ⊂m in which case by
assumption n ∈m and a fortiori n ∈m+1 or n = m in which case n ∈m+1
so Property 1 is proved.
Property 3 follows easily: by Property 4, we have n ̸= N, and by induction
n ⊂N follows.
It remains to prove trichotomy 2. We apply induction proving that for
each n ∈N the set An = {m ∈N : n ∈m ∨n = m ∨m ∈n} is N.
Clearly, A0 = N as 0 ∈m for each m. For An, it is clear that 0 ∈An.
Assume that m ∈An and consider m + 1. By assumption either m ∈n or
m = n or n ∈m. In the ﬁrst case m ⊂n by 1 hence either m + 1 ⊂n
and thus m + 1 ∈n or m + 1 = n. In both cases m + 1 ∈An. In the
second case when m = n clearly n ∈m + 1 and again m + 1 ∈An. Fi-
nally, when n ∈m a fortiori n ∈m + 1 so m + 1 ∈An. It follows by
the induction principle that An = N for each n ∈N so Property 2 is
proved
⊓⊔
It follows that N is ordered linearly by the membership relation ∈; using the
symbol < in place of ∈, we have 0 < 1 < 2 < 3 < ...... < n < n + 1 < ... .
We have used here the symbol < of a strict ordering related to the ordering
≤by the identity ≤=< ∪= i.e. n ≤m if and only if n < m or n = m. The
relation < has one more important property.
Proposition 1.13. In any non–empty subset A ⊆N, there exists the least
element with respect to <.
Indeed, there is n ∈A and clearly it suﬃces to consider the set A|n = A∩(←
, n]. If 0 ∈A|n then 0 is the least element in A; otherwise we may check
whether 1 ∈A|n etc. Proceeding in this way, after at most n −1 steps, we
ﬁnd k such that {0, 1, ..., k−1}∩A = ∅and k ∈A, Thus k is the least element
in A.
A relation R of linear ordering on a set X with the property expressed in
the last proposition is said to well–order the set X and it is called a well–
ordering of X. Thus ∈well–orders N.
A question may arise at this point whether a well–ordering may exist for
an arbitrary set X. We do not have by now any tool which would enable us
to prove such a result. We need a new axiom which would guarantee us the
existence of a well–ordering on any set.
1.7
Well–Ordered Sets
The axiomatic statement which would guarantee the existence of a well-
ordering on each set is

24
1 On Concepts. Aristotelian and Set–Theoretic Approaches
A10 (the Axiom of well–ordering) For each set X there exists a relation
R on X which well–orders X
We may be aware of the fact that this axiom is non–eﬀective and it does
not give us any procedure for constructing a well–ordering on a given set; its
value is ontological, allowing us to explore consequences of its content. We
ﬁrst state one of these consequences known as the axiom of choice of Zermelo.
Proposition 1.14. Axiom A10 implies the following: for any family F of
non–empty sets, there exists a function f : F → F with the property that
f(X) ∈X for each X ∈F.
Indeed, by A10, the set  F may be well–ordered by a relation <. To con-
struct f with the desired property, it is suﬃcient to deﬁne f(X) to be the
least element in X with respect to <.
A function f with the property stated in the last proposition is called a
choice function for the family F (or, a selector for F). From the axiom of
choice (hence from the axiom of well–ordering) one may derive some very
important consequences. We now present some of them. Recall that a subset
A of an ordered by ≤set X is a chain if it is linearly ordered by the restriction
≤|A =≤∩A × A. An element c of X is maximal (respectively minimal) in
X in case there is in X no element d ̸= c with c ≤d (respectively d ≤c).
We may give a formulation of the maximum principle known also as the
Zorn lemma due independently to Hausdorﬀ[10], Kuratowski [12] and Zorn
[32].
Proposition 1.15. (the Maximum Principle) Assume that a set X ordered
by a relation ≤has the property that any chain in X is bounded from above.
Then in X there exists a maximal element.
Proof. (Balcar–ˇStˇep´anek [2]) Let f be a selector on the set 2X \ {∅} of all
non–empty subsets of X. Assume, to the contrary, that in X there is no
maximal element i.e. for any x ∈X the set M(x) = {y ∈X : x < y} is
non–empty and thus s(x) = f(M(x)) exists.
We will start with an element a in X and the set S(a) = [a, →), and we
observe properties of Y ⊆S(a)
⎧
⎪
⎪
⎨
⎪
⎪
⎩
(i) a ∈Y
(ii) y ∈Y →s(y) ∈Y
(iii) if L is a chain in Y, then supL ∈Y
(1.45)
For the family F(a) of all Y ⊆S(a) which satisfy (1.45), we form the inter-
section  F(a) = L. Clearly, L satisﬁes (1.45) being a minimal set with this
property. We would like to show that L is a chain.

1.7 Well–Ordered Sets
25
To this end, ﬁrst, we exploit minimality of L by looking at the set
K = {y ∈L : ∀x(x ∈L ∧x < y ⇒s(x) ≤y)}
Claim 1. For x ∈K, y ∈L: x ≤y ∨y ≤x.
To check this claim, we take x ∈K and we consider the set
Kx = {y ∈L : x ≤y ∨y ≤x}
We check that Kx does satisfy (1.45). Clearly, a ∈Kx so (i) holds. Assume
y ∈Kx. In case x ≤y we have x < s(y); in case x > y, by deﬁnition of K,
we have s(y) ≤x. In either case, s(y) ∈Kx so (ii) is satisﬁed. For a chain C
in Kx, either x < c for some c ∈C hence x < supC or c ≤x for every c ∈C
hence supC ≤x. In either case supC ∈Kx witnessing (iii). By minimality of
L we must have Kx = L so Claim 1 is veriﬁed.
Claim 2. For x ∈K, y ∈L: x < y ⇒s(x) ≤y.
We apply the same technique: given x ∈K, we look at the set
Kx = {y ∈L : x < y ⇒s(x) ≤y}.
Again (i) holds obviously, for (ii) we look at y ∈Kx. By Claim 1, either
x ≤y or y ≤x. The latter case impossible, we are left with x ≤y so either
x = y hence s(x) = s(y) or x < y hence s(x) ≤s(y) as y ∈Kx. Thus in all
cases s(y) ∈Kx proving (ii). In case (iii), for a chain C in Kx, if x < supC,
then x < c for some c ∈C hence s(x) ≤c and thus s(x) ≤supC. It follows
that supC ∈Kx and (iii) holds. By minimality of L, we have Kx = L which
proves Claim 2.
Claim 3. K = L.
We check that K satisﬁes (1.45) so Claim 3 would follow by minimality of
L. Clearly, a ∈K so (i) holds. For x ∈K, let y < s(x). We have by Claim
1 that x ≤y or y ≤x. But x ≤y cannot hold by Claim 2 so only y < x
remains. Then s(y) ≤x hence s(y) < s(x) witnessing s(y) ∈K so (ii) holds.
Finally, consider a chain C in K with y < supC for some y ∈L. Then y < c
for some c ∈C hence s(y) ≤c and s(y) ≤supC implying that supC ∈K
so (iii) holds. By minimality of L, K = L and it follows that L is a chain.
By (iii), supL ∈L and by (ii) s(supL) ∈L which is a contradiction with
supL < s(supL). Thus in X there exists a maximal element
⊓⊔
It is much easier to show that the axiom of well–ordering follows from the
maximum principle.

26
1 On Concepts. Aristotelian and Set–Theoretic Approaches
Proposition 1.16. Themaximumprincipleimpliestheaxiomofwell–ordering.
Proof. Consider a set X assuming the maximum principle. Now, consider the
set F of all pairs of the form (a subset Y of X, a relation R well–ordering
Y ), i.e.,
(Y, R) ∈F ⇔Y ⊆X ∧R well −orders Y
We introduce an ordering ⊑on F by letting (Y, R) ⊑(Z, S) if and only if
Y ⊆Z and S|Y = R. Let us observe that any chain C in F with respect to
⊑has a supremum, viz., ( F, {R : (Y, R) ∈C}).
By the maximum principle (Proposition 1.15) there exists a maximal ele-
ment (Y0, R0) in F. If it was Y0 ̸= X, we could pick an element a ∈X \Y0 and
extend Y0 to Y1 = Y0∪{a}, extending also R0 to a new ordering R1 by declar-
ing a greater than all elements in Y0, i.e., R1 = R0∪{(y, a) : y ∈Y0}. Then R1
well–orders Y1 and (Y0, R0) ⊆(Y1, R1), a contradiction. Hence Y0 = X and
R0 well–orders X
⊓⊔
It follows that the axiom of choice, the axiom of well–ordering and the maxi-
mum principle are equivalent. There are a number of other statements which
turn out to be equivalent to those three. For instance the following are often
used in various branches of mathematics.
1. (Birkhoﬀ[3]) In any ordered set X, any chain is contained in a chain
maximal with respect to inclusion;
2. (Vaught [27]) Any family F of sets contains a maximal with respect to
inclusion sub–family consisting of pair–wise disjoint sets.
Indeed, the Birkhoﬀprinciple follows from the maximum principle by the
fact that the union of a chain L of chains is a chain being the supremum
of L hence in a set of all chains over X ordered by inclusion there exists a
maximal chain. By analogy, the Vaught principle follows from the maximum
principle by the fact that the union of a linearly ordered by inclusion family L
of sub–families of F consisting of pair–wise disjoint sets consists of pair–wise
sets and constitutes the supremum of L.
1.8
Finite versus Inﬁnite Sets
We now are in position to deﬁne formally the notion of ﬁniteness and to
contrast it with the notion of being inﬁnite.
For a set X, we say that X is a ﬁnite set (in the Dedekind sense) in case
there exist: a natural number n ∈N and a bijection f : X →n. In this case
we say that the cardinality of X is n, in symbols |X| = n. Let us observe that
given a singleton k, we have |X| = |X × {k}|. From this observation we may
derive

1.8 Finite versus Inﬁnite Sets
27
Proposition 1.17. Finite sets have properties
1. Any subset of a ﬁnite set is ﬁnite;
2. The union m
i Xi of ﬁnite sets X1, X2, ..., Xm is a ﬁnite set.
Proof. Indeed, if f : X →n witnesses |X| = n and Y ⊆X then f(Y ) ⊆n
hence either f(Y ) = n and thus |Y | = n or f(Y ) ⊂n hence |Y | = m < n by
Proposition 1.12. This proves Property 1.
Given X1, X2, ..., Xm with |Xi| = mi for i = 1, 2, ..., m we may observe
that (a) m
i Xi embeds as a subset into ⊕iXi = 
i Xi ×{i} and as the latter
is the union of pair–wise disjoint sets we have | ⊕i Xi| = 
i mi hence it is a
ﬁnite set. By Property 1, m
i Xi is ﬁnite
⊓⊔
Apparently distinct is the ﬁniteness in the Tarski sense, viz., a set X is ﬁ-
nite in the sense of Tarski [25], when the following Tarski property is observed
TF In any non–empty subset A ⊆2X there exists a set maximal in A
with respect to inclusion
One may try to relate the two notions of ﬁniteness; it turns out that they are
equivalent under the axiom of choice (or, for that matter under anyone of its
equivalent statements). To this end we prove ﬁrst that
Proposition 1.18. Every natural number n is ﬁnite in the Tarski sense TF,
hence, each set ﬁnite in the Dedekind sense is ﬁnite in the Tarski sense.
Proof. We introduce a predicate Tﬁn(k) read k is ﬁnite in the Tarski sense.
We check that the set A = {n ∈N : T fin(n)} satisﬁes premises of the
principle of mathematical induction.
Clearly, 0 ∈A. Assuming that n ∈A, we prove that n + 1 ∈A. We have
2n+1 =2n∪{X ∪{n+1} : X ∈2n}. Now, for a set Y ⊆2n+1, either Y ⊆2n in
which case in Y there exists a maximal element or it is not true that Y ⊆2n
in which case in the set Y1 = {B ∈2n : B ∪{n + 1} ∈Y } there exists a
maximal set B0. Then B0 ∪{n + 1} is a maximal set in Y . It follows that
n+1 ∈A and A = N by the principle of mathematical induction (Proposition
1.11) so each natural number is ﬁnite in the Tarski sense.
Now, if X is ﬁnite in the Dedekind sense, |X| = n being witnessed by
f : X →n, the sets 2X, 2n are in bijective correspondence via F : Y →f(Y ),
hence 2X has the Tarski property
⊓⊔
The converse fact that any set ﬁnite in the Tarski sense is ﬁnite in the
Dedekind sense requires the use of axiom of choice. First, we have to say
what an inﬁnite set is. We say that X is an inﬁnite set in either sense, when
it is not ﬁnite in this sense. We begin with
Proposition 1.19. Under axiom of choice: if a set X is not ﬁnite in the
sense of Dedekind, then X contains a copy of the set N of natural numbers.

28
1 On Concepts. Aristotelian and Set–Theoretic Approaches
Proof. Assume that X is not Dedekind–ﬁnite so no function f : n →X can
be onto (otherwise, we could pick, by the axiom of choice, a point cx from
any non–empty set f −1(x) and then the function g : X →n deﬁned via the
formula g(x) = cx would be an embedding of X into n so |X| = m < n by
Proposition 1.12 , a contradiction to inﬁnity of X. Let s be a selector on the
set 2X \ {∅} of all non–empty subsets of X. We deﬁne a function h : N →X
deﬁning the value h(n) by induction on n. We assign h(0) = x0 where x0
is an arbitrarily chosen element in X. Assume that we have deﬁned values
h(0), h(1), ..., h(n) in such a way that h(i) ̸= h(j) whenever i ̸= j. Then
we let h(n + 1) = s(X \ {h(0), ..., h(n)}) so h(n + 1) is distinct from any of
h(0), .., h(n). By the principle of mathematical induction (Proposition 1.11),
a function h : N →X is deﬁned with h(i) ̸= h(j) when i ̸= j i.e. h embeds N
into X and h(N) is a copy of the set N of natural numbers
⊓⊔
The proposition follows stating that each Tarski–ﬁnite set is Dedekind–ﬁnite.
Proposition 1.20. Under axiom of choice, each set ﬁnite in the Tarski sense
is ﬁnite in the Dedekind sense.
Proof. We prove this fact by showing that any set which is Dedekind–
inﬁnite is also Tarski–inﬁnite. Assume thus that X is Dedekind inﬁnite. By
Proposition 1.19, X contains a copy Y of the set N of natural numbers so
Y = {x1, x2, ..., xn, ....}. Consider the family Yn = {{x1, x2, ..., xn} : n ∈N}
of subsets of X. Clearly, this family has no maximal element hence X is no
Tarski–ﬁnite set
⊓⊔
Proposition 1.21. Under axiom of choice both kinds of ﬁniteness coincide.
We will from now on simply discuss ﬁnite sets without referring to the kind
of ﬁniteness. It also follows from our discussion that any inﬁnite set has to
contain a copy of the set of natural numbers. As a particular case, the set N
itself is inﬁnite.
1.9
Equipotency
We have deﬁned ﬁnite sets as sets that map bijectively onto a natural number.
This notion may be extended, viz., for two sets X, Y we say that X and Y
are equipotent whenever there exists a bijection f : X →Y . We are justiﬁed
in such statement as clearly the relation of equipotency is symmetric: if f :
X →Y is a bijection of X onto Y then f −1 : Y →X is a bijection of
Y onto X. It is also evident that any set X is equipotent with itself, and
that the relation of equipotency is transitive: if X, Y are equipotent and Y, Z
are equipotent then X, Z are equipotent because of the evident fact that if
f : X →Y , g : Y →Z are bijections then the composition g ◦f : X →Z is

1.9 Equipotency
29
also a bijection. In case X, Y are equipotent, we say that their cardinalities
coincide, in symbols |X| = |Y |.
We may attempt at ordering a given set of cardinalities: we may say that
|X| ≤|Y | if there exists an injection f : X →Y . Then clearly, |X| ≤|X|,
and from |X| ≤|Y |, |Y | ≤|Z| it follows that |X| ≤|Z|. So, the only question
that remains, if we would like to claim that the relation ≤is an ordering
on any family of cardinalities of sets, is that whether this relation is weakly
symmetrical. It turns out to be such and this fact is by no means trivial and
requires a proof.
Proposition 1.22. (the Cantor [6]–Bernstein quoted in Borel [5] theorem)
If |X| ≤|Y | and |Y | ≤|X|, then |X| = |Y |.
Proof. We apply in the proof the Knaster–Tarski ﬁxed point theorem (Propo-
sition 1.7). Assume that |X| ≤|Y | and |Y | ≤|X| so injections f : X →Y
and g : Y →X exist.
Consider the function h : 2X →2X deﬁned as follows: for A ⊆X
h(A) = g[Y \ f(X \ A)]
(1.46)
It is easy to check that h is isotone: if A ⊆B then X \ B ⊆X \ A hence
f(X \ B) ⊆f(X \ A) so
Y \ f(X \ A) ⊆Y \ f(X \ B)
and hence
g[Y \ f(X \ A)] ⊆g[Y \ f(X \ B)]
As the power set 2X is completely ordered by inclusion, by the Knaster–Tarski
theorem it follows that for some C ⊆X we have h(C) = C, i.e.,
g[Y \ f(X \ C)] = C
This means that f maps X \ C onto the set B such that g(Y \ B) = C.
We may deﬁne then a function k : X →Y by the recipe
k(x) =

f(x) when x ∈X \ C
g−1(x) when x ∈C
(1.47)
where the inverse g−1 is deﬁned for the restriction g|B of the function g to
the set B. As both f, g are injections, it is clear that k is a bijection of X
onto Y so X, Y are equipotent, i.e., |X| = |Y |
⊓⊔
We now have proved that the relation ≤is an ordering on any set of car-
dinalities. We denote in particular the cardinality |N| of the set of natural
numbers N by the symbol ω. One may ask whether there exist sets whose
cardinalities exceed that of ω i.e. about degrees of inﬁnity. The classical result
which has told us that there are more potent sets that N and at the same

30
1 On Concepts. Aristotelian and Set–Theoretic Approaches
time has posed very diﬃcult questions about cardinal numbers is the Cantor
diagonal theorem.
Proposition 1.23. (Cantor) For no set X there exists a function f : X →
2X from X onto 2X.
Indeed, it is suﬃcient to consider the subset Y = {x ∈X : x /∈f(x)}. Assume
that Y = f(y) for some y ∈X. Then: if y ∈Y then y /∈f(y) i.e. y /∈Y and
vice versa, if y /∈Y then y ∈f(y) i.e. y ∈Y . Finally we get: y ∈Y if and only
if y /∈Y , a contradiction. Thus, Y cannot be the value of f and f cannot
map X onto 2X.
The upshot of this result is that no set X can be equipotent with its power
set 2X. In particular we have |2N| > ω as clearly N embeds into 2N via the
function f(n) = {n}. We may form higher and higher cardinalities by looking
at sets 2N, 22N, .... For our purposes, it will be enough to stay with ﬁnite sets
or sets equipotent with ω which all together are called countable sets.
1.10
Countable Sets
To make the realm of countable sets more familiar to us, we should give some
examples of countable sets besides already known to us ﬁnite sets and N
itself. In particular, a question may arise about the cardinality of Cartesian
products N ×N, N ×N ×N , and in general, about the cardinality of powers
N k = N1 × N2 × ... × Nk where Ni = N for i = 1, 2, .., k. It turns out that
all these sets are countable being equipotent with N.
To demonstrate this one should exhibit some bijections among these sets
and N. We begin with the square N 2.
Proposition 1.24. The function f(m, n) = (m+n)·(m+n+1)
2
+m when (m, n)
̸= (0, 0) and f(0, 0) = 0 is a bijection from N 2 onto N.
Proof. The function f is injective: consider points of the form (p, q) where
p, q ∈N in the Euclidean plane: each (p, q) lies in the line x + y = p + q and
each line x+y = c contains c+1 such integer points, viz., from (c, 0) to (0, c).
It follows that (p+ q)·(p+q +1)/2 +p is the number of segments connecting
neighboring integer points on lines of the form x + y = c where c = 0, 1, 2, ...
necessary to reach the point (p, q) from (0, 0). So if f(m, n) = f(p, q) then
necessarily m = p, n = q.
The function f is onto: by the above interpretation, for any k, going k
segments the way as described above brings us to some (p, q). One may give
an explicit formula for the inverse of f: for a natural number r, we have
f −1(r) = (p, q) where p, q follow uniquely from the two equations

p + q = ⌊(⌊(8r + 1)
1
2 ⌋+ 1)/2⌋−1
3p + q = 2r −(⌊(⌊(8r + 1)
1
2 ⌋+ 1)/2⌋−1)2
(1.48)

1.11 Filters and Ideals
31
To get these equations, it suﬃces to let r = (p+q)·(p+q+1)
2
and observe that
8r+1 = (2p+2q+1)2+8p from which it follows that 2p+2q+1 ≤(8r+1)
1
2 ≤
2p + 2q + 3 implying (1.48).
It follows that f does establish the equipotency of N 2 with N. We may
write down f −1(r) = (k(r), l(r)) where k, l are functions which satisfy k(r) =
p, l(r) = q in the above equations.
We may iterate the above bijection: given the set N k of ordered k–tuples
of natural numbers we may deﬁne inductively a bijection fk from N k onto
N, viz., assuming f1, ..., fk deﬁned, we deﬁne
fk+1(n1, n2, .., nk+1) = f(fk(n1, n2, .., nk), nk+1)
where f is the bijection of Proposition 1.24. One may prove by induction that
all fk are bijections. Thus, for any k ∈N, the set N k of all k–tuples of natural
numbers is countable
⊓⊔
This result may be carried yet further: we may consider the set
N ∗=

{N k : k ∈N}
of all ﬁnite tuples of natural numbers (sometimes called from the grammatical
point of view strings, or words). As for each k the function fk : N k →N is
a bijection, and sets N k are pair–wise disjoint, we may construct a bijection
h of N ∗onto N by ﬁrst deﬁning a function g : N ∗→N × N, by letting
g(n1, ..., nk) = (fk(n1, ..., nk), k) for each k ∈N and each string (n1, ..., nk) ∈
N k and then deﬁning h(n1, ..., nk) = f(g(n1, ..., nk)).
Thus, the set of all ﬁnite tuples (strings) of natural numbers is countable.
A step further in this direction would be the ultimate result that a union
of countably many countable sets is countable. It is indeed so, but the proof
will require the axiom of choice.
Proposition 1.25. Under axiom of choice, the union of a countable set X
whose elements are countable sets is countable.
As X is countable, we may enumerate its elements as {Xn : n ∈N} (where
in case X be ﬁnite, Xn = Xn+1 = Xn+2 = ... for some n). For each n, the
set Bn of all injections from Xn onto N is non–empty so by the axiom of
choice we may select a function kn ∈Bn for each n. For S =  X, we look
for each x ∈S at the least n(x) such that x ∈Xn(x). We deﬁne a function
h : S →N 2 by letting h(x) = (kn(x)(x), n(x)); clearly, h is an injection so
the composition f ◦h embeds S into N.
1.11
Filters and Ideals
In ordered sets, one may single out certain subsets regular with respect to
the ordering relation. Among them of primary interest are ideals and ﬁlters.

32
1 On Concepts. Aristotelian and Set–Theoretic Approaches
Here we restrict ourselves to ideals and ﬁlters in ﬁelds of sets ordered by
inclusion. Our primary ﬁeld of sets will be that of 2X for a non–empty set
X. The notions of a ﬁlter and of an ideal are dual to each other in the sense
that if a family F is a ﬁlter then the family IF = {X \ A : A ∈F} is an ideal
(and vice versa). Hence, we restrict ourselves to ﬁlters as the exposition of
ideals follows by duality.
We consider a ﬁeld of sets B ⊆2X. A non–empty family F ⊆B is a ﬁlter
when
F1 A, B ∈F ⇒A ∩B ∈F
F2 A ⊆B ∧A ∈F ⇒B ∈F
F3 ∅/∈F
A ﬁlter is then a family which is closed with respect to the intersection and
taking a superset and is distinct from B as it cannot have ∅as an element.
In particular, X ∈F by F2. Thus, by duality, an ideal is a family of sets in
B closed with respect to unions and taking subsets so any ideal contains ∅as
an element and does not contain X.
As an example of a ﬁlter, we may take (in case B = 2X) for any x ∈X
the set Fx = {A ∈2X : x ∈A} which clearly satisﬁes F1, F2, and F3 called
the principal ﬁlter induced by x. By duality, the principal ideal induced by x
is the ideal Ix = {A ∈B : x /∈A}.
We may notice an important property of a principal ﬁlter (respective of
a principal ideal): given any ﬁlter F with Fx ⊆F (respectively any ideal I
with Ix ⊆I), we have Fx = F (respectively Ix = I).
Indeed, assuming that Fx ⊂F we may pick a set A ∈F \ Fx hence x /∈A
but then {x} ∩A = ∅contrary to F3. Thus, Fx is a maximal with respect to
inclusion ﬁlter; maximal ﬁlters are called also ultraﬁlters. Similarly, the ideal
Ix is a maximal ideal. Principal ﬁlters and ideals are the only examples of
maximal ﬁlters respectively ideals which we may construct eﬀectively. In all
other cases, to justify the existence of an ultraﬁlter or a maximal ideal we
have to resort to the maximum principle.
Proposition 1.26. By the maximum principle, any ﬁlter F may be extended
to an ultraﬁlter F∗⊇F.
Proof. Consider the set F, of all ﬁlters on a ﬁeld of sets B containing the ﬁlter
F as a subset, ordered by inclusion. It remains to check that the union S =
 L of any chain L of ﬁlters in F is again a ﬁlter. To this end, consider A, B ∈
S: there are ﬁlters F, G ∈L such that A ∈F, B ∈G. By linearity of ordering
on L, either F ⊆G or G ⊆F. In the former case A, B ∈F, in the latter case
A, B ∈G so either A ∩B ∈F or A ∩B ∈G and in either case A ∩B ∈S
proving the condition (i). Similarly (ii, (iii) may be proved so we conclude that
S is a ﬁlter. Clearly, S = supL. Thus, any chain in F has a supremum and the

1.12 Equivalence Relations
33
maximum principle implies the existence of a maximal element in F which is
clearly an ultraﬁlter extending F
⊓⊔
The dual result on the existence of a maximal ideal extending a given ideal
follows by duality.
As one more important example of a ﬁlter, we may consider the set N of
natural numbers and the family cofN = {A ⊆N : N \ A is finite} i.e. the
family of all co–ﬁnite subsets in N. That cofN is a ﬁlter follows easily as the
union of any two ﬁnite sets is ﬁnite and any subset of a ﬁnite set is ﬁnite. The
ﬁlter cofN is called the Fr´echet ﬁlter. By the last proposition, there exists
on N an ultraﬁlter cofN ∗extending the Fr´echet ﬁlter.
We give now a characterization of ultraﬁlters in terms of set operations.
Proposition 1.27. For a ﬁlter F, the following are equivalent
1. F is an ultraﬁlter;
2. If a subset Y ⊆X is such that Y ∩A ̸= ∅for each A ∈F, then Y ∈F;
3. For any A, B, if A ∪B ∈F, then either A ∈F or B ∈F;
4. For any A either A ∈F or X \ A ∈F.
Proof. Property 1 implies Property 2: assume F an ultraﬁlter and Y ∩A ̸= ∅
for each A ∈F. Was Y /∈F, we could deﬁne F ∗by adding to F all sets
containing as a subset an intersection of the form Y ∩A where A ∈F. Then
clearly, F∗does satisfy F1, F2 and F3, so F∗is a ﬁlter. Also F ⊂F∗as
Y ∈F∗\ F but this is a contradiction as F is an ultraﬁlter.
Property 2 implies Property 3: assume A ∪B ∈F but neither A ∈F nor
B ∈F. By Property 2 there exist C, D ∈F with C ∩A = ∅= D ∩B. But
then (A ∪B) ∩(C ∩D) = ∅and C ∩D ∈F, a contradiction with F1.
Property 3 implies Property 4: as A ∪X \ A = X ∈F either A ∈F or
X \ A ∈F by Property 3.
Property 4 implies Property 1: assume to the contrary that F is not an ultra-
ﬁlter so F ⊂G for some ﬁlter G hence there is A ∈G \ F i.e. A /∈F. But also
X \A /∈F: otherwise, we would have X \A ∈G and A∩X \A = ∅∈G, a con-
tradiction with F3
⊓⊔
1.12
Equivalence Relations
Tasks of classiﬁcation require that elements in a universe be clustered into
aggregates within which the elements are identical or similar with respect to
some properties whereas elements in distinct aggregates are clearly discernible
with respect to some of those properties.
A simplest class of classifying relations are equivalence relations; we call
a relation R on a set X an equivalence relation if and only if R is reﬂexive,
symmetric and transitive.

34
1 On Concepts. Aristotelian and Set–Theoretic Approaches
We recall the basic property of equivalence relations concerned with clus-
tering of elements of X into classes of indiscernible objects. For an element
x ∈X, we let
[x]R = {y ∈X : xRy}
(1.49)
and we call [x]R the equivalence class of x with respect to R. Then we have
Proposition 1.28. For each pair x, y ∈X, classes [x]R, [y]R are either dis-
joint or equal.
We include a proof of this well–known fact. If z ∈[x]R ∩[y]R, then by symme-
try xRz, yRz, hence, xRz, zRy and by transitivity xRy; for w ∈[x]R, we have
wRx, hence, wRy and it follows that [x]R ⊆[y]R. By symmetry, [y]R ⊆[x]R
and ﬁnally [x]R = [y]R.
We will denote the set {[x]R : x ∈X} by the symbol X/R and we will
call it the quotient set of the set X by the relation R. There is a function
qR : X →X/R deﬁned by letting qR(x) = [x]R, and called the quotient
function which maps X onto the quotient set X/R.
A dual way of introducing equivalence relations is by means of partitions.
A partition on a set X is a family P of its subsets such that
P1 P is non–empty
P2  P = X
P3 If A, B ∈P, then A ∩B = ∅
By the last Proposition and the fact implied by reﬂexivity of R that x ∈[x]R,
it follows that equivalence classes of the relation R form a partition PR of
the set X.
On the other hand, any partition P of X induces an equivalence relation
RP , viz., we let xRP y if and only if there exists a set A ∈P such that
x, y ∈A. The correspondence between equivalence relations and partitions is
canonical, i.e.,
PRP = P, RPR = R
(1.50)
We may also compare equivalence relations on the set X: for equivalence
relations R, S on X, we say that R is ﬁner than S in symbols R ≺S if and
only if xRy implies xSy for any pair x, y of elements of X. We have obvious
Proposition 1.29. R ≺S if and only if [x]R ⊆[x]S for each x ∈X.
We say in case R ≺S that the partition PR = {[x]R : x ∈X} is a reﬁnement
of the partition PS = {[x]S : x ∈X}.
The relation ≺is a complete ordering of the set Eq(X) of all equivalence
relations on X.
Proposition 1.30. For any family R of equivalence relations on a set X,
there exist equivalence relations infR, supR with respect to ≺, i.e., the family
Eq(X) of all equivalence relations on the set X is completely ordered by ≺.

1.13 Tolerance Relations
35
Clearly, the intersection  R of all relations in R is an equivalence relation
hence it is infR. For supremum, let us consider the relation S = {R ∈
Eq(X) : ∀A : (A ∈R ⇒A ⊆R)}. By the part already proven, S is an
equivalence relation and for any relation R ∈Eq(X) with A ⊆R for each
A ∈R we have S ⊆R so S = supR.
Assuming that R ≺S, we may deﬁne on the quotient set X/R a new
relation S/R by letting [x]RS/R[x′]R if and only if xSx′. It is evident that
this deﬁnition does not depend on the choice of elements in [x]R, [x′]R. It
is also easy to see that [[xR]]S/R]=[x]S. We may write down this fact in a
concise form as
(X/R)/(S/R) = X/S
(1.51)
Given equivalence relations R ⊆X×X and S ⊆Y ×Y , a function f : X →Y
is an R, S–morphism if the condition xRy ⇒f(x)Sf(y) holds. Then we have
a function f : X/R →Y/S with f([x]R) = [f(x)]S; indeed, if zRx then
f(z)Sf(x) hence f([x]R) ⊆[f(x)]S and f is deﬁned uniquely. Let us observe
that qS ◦f = f ◦qR.
1.13
Tolerance Relations
The idea of similarity is a weakening of the idea of equivalence; a similarity
may be rendered in many ways leading to various formal notions. One of
these ways is related to problems of visual perception in which a similarity
of objects may be interpreted as inability to distinguish between them, e.g.,
the distance between the objects may be smaller then a given discernibility
threshold: if points x, y in the real line are regarded as similar when their
distance is less than δ then we may have x, y, and y, z similar while x, z need
not be similar, see Poincar´e [19].
It follows that such a relation of similarity lacks the transitivity property.
The idea of a tolerance relation was introduced formally in Zeeman [29] to
capture this intuitive understanding of similarity, cf., also, Menger [16], cf.,
Nieminen [18], Polkowski et al. [20]. Following Zeeman, we call a relation R
on a set X a tolerance relation when R is (i) reﬂexive (ii) symmetric. Thus a
tolerance relation lacks the transitivity property of equivalence relations. This
makes the analysis of tolerance relations more diﬃcult and their structure
more intricate.
If we have tried to mimic the case of equivalence relations, then we would
look at the sets R(x)={y ∈X : xRy}. However, due to the lack of transitivity,
we cannot say for instance whether two elements y, z ∈R(x) are in the
relation R and a fortiori there is nothing essential we may say about the
structure of R(x). So, we should with equivalence classes in mind, consider
sets with the property that any two of its elements are in the relation R. Such
sets are called tolerance pre–classes.

36
1 On Concepts. Aristotelian and Set–Theoretic Approaches
Formally , a set A ⊆X is a tolerance pre–class when xRy for any pair
x, y ∈A. In particular, any singleton {x} is a tolerance pre–class, and if xRy
then {x, y} is a tolerance pre–class.
We may easily see that any union of a linearly ordered by inclusion family of
tolerance pre—classes is a tolerance pre–class. From the maximum principle
it follows that
Proposition 1.31. Any tolerance pre–class A is a subset of a maximal with
respect to inclusion tolerance pre–class.
Maximal tolerance pre–classes are called tolerance classes. Within a tolerance
class C, any two elements are in the relation R, and, for each element y /∈C,
there is x ∈C such that ¬yRx.
An example of a tolerance relation is the following: given a family of non–
empty sets F, deﬁne a relation τ∩on F as
Aτ∩B if and only if A ∩B ̸= ∅
(1.52)
τ∩is clearly a tolerance relation. Its classes are maximal 2–centered sub–
families of F, where a sub–family F ′ ⊆F is centered if for any ﬁnite G ⊆F ′
the intersection  G ̸= ∅and being k−centered means the specialization of
the preceding deﬁnition to G consisting of at most k elements.
The relation τ∩is archetypical for tolerance relations: it turns out that any
tolerance relation can be represented in that form. To see this, for a tolerance
relation R on X, we denote by the symbol C the family of all tolerance classes
of R and we let
Cx = {C ∈C : x ∈C}
We have, see Shreider [23]
Proposition 1.32. For x, y ∈X, we have xRy if and only if Cx ∩Cy ̸= ∅.
Proof. Indeed, in case xRy, the pre–class {x, y} extends to a tolerance class
C ∈C and C ∈Cx ∩Cy. Conversely, in case Cx ∩Cy ̸= ∅, there exists a
tolerance class C with x, y ∈C and thus xRy by the deﬁnition of a tolerance
class
⊓⊔
We may now consider a way to embed a tolerance relation into an equivalence
relation. To this end, given a relation R on a set X, we deﬁne the n–th power
Rn of R as the composition R ◦R ◦R ◦.... ◦R of n copies of R. Clearly,
xRny holds if and only if there exist x = x0, x1, ..., xn = y with xiRxi+1 for
i = 0, .., n −1. Then, we deﬁne the transitive closure R+ of the relation R
as the union {Rn : n ∈N}. Clearly, R ⊆R+ and R+ is transitive: given
xR+y, yR+z, we have xRny, yRmz for some n, m ∈N and then xRn+mz.
It follows from the construction of R+ that it is the least transitive relation
extending R.
We may notice that

1.14 A Deeper Insight into Lattices and Algebras
37
Proposition 1.33. For a tolerance relation R, the transitive closure R+ is
an equivalence relation. For any x ∈X, the union of tolerance classes of R
containing x is a subset of the equivalence class of x by R+:  Cx ⊆[x]R+.
Proof. As R+ is reﬂexive since R ⊆R+ and symmetric by the symmetry of
R, R+ is an equivalence relation because we have checked its transitivity. For
any tolerance class C ∋x, C × C ⊆R so C × C ⊆R+ i.e. C ⊆[x]R+. It
follows that  Cx ⊆[x]R+
⊓⊔
The relation R+ is constructed by inﬂating tolerance classes until they be-
come disjoint or identical; we may think also of a way of constructing an
equivalence by restricting tolerance classes. To this end, we ﬁrst introduce a
new notion: given a family F of subsets of a set X, we consider a new family
of sets constructed in the following way. For any sub–family G ⊆F, we let
AG =  G \ (F \ G). We let C(F) = {AG : G ⊆F}. Sets of the form AG are
called components of F. Let us observe that
Proposition 1.34. For G, G′ ⊆F, if G ̸= G′ then AG ∩AG′ = ∅. Thus the
family C(F) of components of F is a partition of Y =  F.
Indeed, for G ̸= G′, let e.g. A ∈G \ G′. Then AG ⊆A and AG′ ∩A = ∅. Hence
AG ∩AG′ = ∅.
We now apply the idea of components to the family CR of tolerance classes
of a tolerance relation R on a set X.
Proposition 1.35. Components in the family C(CR) are equivalence classes
of the equivalence relation E deﬁned by the condition xEy if and only if
zRx ⇔zRy for each z.
Proof. The relation E is clearly an equivalence (we have xEy if and only if
R(x) = R(y)). Assume xEy. Then for any tolerance class C ∋x, y ∈C as
yRz for any z ∈C. Obviously the converse holds by symmetry of R: for any
tolerance class C ∋y, we have x ∈C. Hence for G = {C ∈CR : x ∈C}
we have G = {C ∈CR : y ∈C}. It follows that x, y belong to the same
component AG. Conversely, if x, y belong to the same component AG, then
given xRz we have a tolerance class C with x, z ∈C; but y ∈C hence yRz.
By symmetry, if yRz then xRz. It follows that xEy
⊓⊔
1.14
A Deeper Insight into Lattices and Algebras
We know from section 1.5 that a lattice is a set X with two operations, of
the meet, x ∩y, and the join, x ∪y, which satisfy the postulates
L1 x ∪y = y ∪x
L2 x ∪(y ∪z) = (x ∪y) ∪z

38
1 On Concepts. Aristotelian and Set–Theoretic Approaches
L3 x ∩y = y ∩z
L4 x ∩(y ∩z) = (x ∩y) ∩z
L5 x ∩(y ∪z) = x = x ∪(x ∩y)
We know from section 1.5 that such structures arise in ordered sets (X, ≤)
with the property that g.l.b.(x, y) and l.u.b.(x, y) exist for each pair x, y.
Conversely, in each lattice (X, ∪, ∩), an ordering ≤L can be introduced by
means of
x ≤L ⇔x ∪y = y ⇔x ∩y = x
(1.53)
and, moreover, in the canonical way, i.e., the meet ∩L and the join ∪L intro-
duced by ≤L coincide with ∩and ∪, respectively.
The unit element, 1, is deﬁned by the property that
x ∪1 = 1 for each x ∈X
(1.54)
i.e, x ≤L 1 for each x ∈X.
Dually, the zero element 0 is introduced by means of the postulate that
x ∩0 = 0 for each x ∈X
(1.55)
i.e., 0 ≤L x for each x ∈X.
A lattice with 0 and 1 will be called a 0,1–lattice.
The notions of a ﬁlter and an ideal, known for ﬁelds of sets, can be deﬁned
in the more general realm of lattices.
A ﬁlter on a lattice (X, ∪, ∩) is a subset F ⊆X, satisfying postulates
F1 x, y ∈F ⇒x ∩y ∈F
F2 x ∈F, x ≤L y ⇒y ∈F
In each 0,1–lattice, 1 ∈F. If 0 ∈F, then F = X, and F is improper.
The corresponding dual postulates with replacement of ∩by ∪and ≤l by ≥L
deﬁne an ideal. The theory of ideals is then dual to theory of ﬁlters: every
statement about ﬁlters becomes a statement about ideals after replacement
of ∩by ∪, ∪by ∩, ≤L by ≥L, and 1 by 0.
The notion of a maximal ﬁlter is deﬁned as in sect. 1.5.
A ﬁlter F is prime if and only if it satisﬁes the postulate
x ∪y ∈F ⇒x ∈F ∨y ∈F
(1.56)

1.14 A Deeper Insight into Lattices and Algebras
39
A lattice (X, ∪, ∩) is distributive if and only if it satisﬁes the postulate
x ∩(y ∪z) = (x ∩y) ∪(x ∩z)
(1.57)
and then obviously its dual: x ∪(y ∩z) = (x ∪y) ∩(x ∪z).
In distributive lattices
Proposition 1.36. Every maximal ﬁlter is prime.
Proof. Assume a maximal ﬁlter F is not prime. There are x, y with x∪y ∈F
and x /∈F, and y /∈F. For each z ∈x ∩z, (x ∪y) ∩z = (x ∩z) ∪(y ∩z) ∈F,
hence, x ∩z ∈F or y ∩z ∈F.
Consider G = {w ∈X : x∩z ≤l w∨y ∩z ≤L w}. G is a ﬁlter, x, y ∈G, and
F ⊆G, contrary to maximality of F
⊓⊔
A subclass of distributive lattices are relatively pseudo–complemented lat-
tices; a lattice X is relatively pseudo–complemented if for each pair x, y ∈X,
there exists an element x ⇒y called the pseudo–complement of x relative to
y which satisﬁes the postulate
x ⇒y ≥L z ⇔x ∩z ≤L y
(1.58)
for each z ∈X. Let us observe that (1.58) deﬁnes a Galois connection (x ∩
z, x ⇒y), see sect. 1.4.
The existence of pseudo–complement implies some important features of
a lattice
Proposition 1.37. Assume
that
a
lattice
X
is
relatively
pseudo–
complemented. Then
1. X has a unit element 1;
2. X is distributive.
Proof. By (1.58), z ≤L x ⇒x for each z, hence, x ⇒x = 1. Distributivity
follows by (1.58): x ∩y, x ∩z ≤L x ∩(y ∪z) imply x ∩y ∪x ∩z ≤L x ∩(y ∪z).
To prove the converse, observe that x ∩y, x ∩z ≤L x ∩y ∪x ∩z, hence, by
(1.58), y, z ≤L x ⇒x∩y ∪x∩z, which implies that y ∪z ≤L x ⇒x∩y ∪x∩z
and again (1.58) implies that x ∩(y ∪z) ≤L x ∩y ∪x ∩z
⊓⊔
A complement to x ∈X is an element −x ∈X such that
(x ∪(−x)) ∩y = y; (x ∩(−x)) ∪y = y
(1.59)
for every y ∈X.
Thus, x ∪(−x) = 1 and x ∩(−x) = 0.
A lattice is complemented if and only if each element has a complement.
A Boolean algebra is a complemented 0, 1–distributive lattice. The com-
plement acts in Boolean algebras as dualizer: it turns every true statement
into its dual by replacements: ∪/∩, ∩/∪, x/ −x, 0/1.

40
1 On Concepts. Aristotelian and Set–Theoretic Approaches
In Boolean algebras, ﬁlters have the same properties as in ﬁelds of sets of
sect. 1.5.
Proposition 1.38. In every Boolean algebra, each prime ﬁlter F is maximal.
Indeed, as 1 = x ∪(−x) ∈F, either x or −x belongs in F for each x ∈X;
but this characterizes maximal ﬁlters.
We let x ⇒y to stand for −x ∪y. Let us observe a far analogy of this
deﬁnition with the tautology p ⇒q ⇔¬p ∨q of the propositional calculus.
We deﬁne the relation ∼F for a maximal ﬁlter F by letting,
x ∼F y ⇔x ⇒y ∈F ∧y ⇒x ∈F
(1.60)
The relation ∼F is an equivalence: the condition on the right–hand side of
(1.60) is equivalent to the condition
C either x, y ∈F or −x, −y ∈F
Hence, x ∼F x holds for every x ∈X and ∼F is symmetric. Transitivity
follows easily by C.
Clearly, x ∈F if and only if x ∼F 1 and x /∈F if and only if x ∼F 0.
Thus, the quotient set X/ ∼F contains only classes [1]∼F and [0]∼F .
An atom in a Boolean algebra X is an element a ̸= 0 with the property
y ≤L a ⇒y = 0 ∨y = a
(1.61)
A Boolean algebra X is atomic if for every y ∈X there exists an atom a
with a ≤y, see Tarski [26].
By At(X), we denote the set of all atoms in a Boolean algebra X. It is obvious
that if a, b ∈At(X), then a ∩b = 0.
For x, y ∈X, if x ̸= y, then, e.g., x ∩−y ̸= 0; if X is atomic, then there
is an atom a with a ≤L x ∩−y, hence a ≤x and a ∩y = 0. It follows that
distinct elements in an atomic Boolean algebra can be separated by an atom.
Moreover, for each element x, x = sup{a ∈At(X) : a ≤L x}.
Hence, the mapping A : X →2At(X) embeds the atomic Boolean algebra
X into the ﬁeld of sets 2At(X).
A subset D ⊆X \ {0} is dense in X if and only if for each element x ∈X
there exists d ∈D such that d ≤L x. Clearly, At(X) ⊆D for each dense D.
Proposition 1.39. (Rasiowa and Sikorski [22]) If Dn : n = 1, 2, ... is a
countable sequence of dense sets in a Boolean algebra X, and x ̸= 0 is an
element of X, then there exists an ultraﬁlter F such that x ∈F and F ∩Dn ̸=
∅for each n.
Proof. By deﬁnition of a dense set, by induction, one can ﬁnd a sequence
(xn : n = 1, 2, ...) such that x1 = x and xn+1 ≤L xn for n = 1, 2, .....
Y
= {xn : n = 1, 2, ...} extends to an ultraﬁlter F which is what is
needed
⊓⊔

1.14 A Deeper Insight into Lattices and Algebras
41
The reader will ﬁnd a deeper discussion of classical aspects of set theory
in a monograph by Kuratowski and Mostowski [13]. Modern aspects are
treated in Balcar and ˇStˇep´anek [2]. For a lattice–based theory of concepts, see
Wille [28].

References
1. Aristotle.: Prior Analytics. Hackett Publ. Co., Indianapolis (1989)
2. Balcar, B., ˇStˇep´anek, P.: Teorie Mnoˇzin. Academia, Praha (1986)
3. Birkhoﬀ, G.: Lattice Theory, 3rd edn. AMS, Providence (1967)
4. Boche´nski, I.M.: Die Zeitg¨onossischen Denkmethoden. A. Francke AG, Bern
(1954)
5. Borel, E.: Le¸cons sur la Th´eorie des Fonctions. Paris (1898)
6. Cantor, G.: Gesammelte Abhandlungen. Julius Springer, Berlin (1932)
7. Dedekind, R.: Was sind und was sollen die Zahlen. Braunschweig (1881)
8. Fraenkel, A.: Zu den Grundlagen der Cantor–Zermeloschen Mengenlehre. Math.
Annalen 86, 230–237 (1922)
9. Frege, G.: Grundgesetze der Arithmetik II. Verlag Hermann Pohle, Jena (1903)
10. Hausdorﬀ, F.: Grundz¨uge der Mengenlehre (1914); von Veit, Leipzig, Hausdorﬀ,
F.: Set Theory. Chelsea, New York (1962)
11. Knaster, B.: Un th´eor´eme sur les fonctions d’ensembles. Ann. Soc. Polon.
Math. 6, 133–134 (1928)
12. Kuratowski, C.: Une m´ethode d’´elimination des nombres transﬁnis des raison-
nement mathematiques. Fundamenta Mathematicae 3, 89 (1922)
13. Kuratowski, C., Mostowski, A.: Set Theory. North Holland, Amsterdam (1968)
14. Lukasiewicz, J.: On Aristotle’s Syllogistic (in Polish). Compt. Rend. Acad.
Polon. Lettr. Cracovie 44 (1939)
15. Lukasiewicz, J.: Aristotle’s Syllogistic from the Standpoint of Modern Formal
Logic, 2nd edn. Oxford University Press, Oxford (1957)
16. Menger, K.: Statistical metrics. Proc. Natl. Acad. Sci. USA 28, 535–537 (1942)
17. Mac Neille, H.M.: Partially ordered sets. Trans. Amer. Math. Soc. 42, 416–460
(1937)
18. Nieminen, J.: Rough tolerance equality and tolerance black boxes. Fundamenta
Informaticae 11, 289–296 (1988)
19. Poincar´e, H.: La Science et l’Hypoth´ese. Flammarion, Paris (1902)
20. Polkowski, L., Skowron, A., ˙Zytkow, J.: Tolerance based rough sets. In: Lin,
T.Y., Wildberger, M. (eds.) Soft Computing: Rough Sets, Fuzzy Logic, Neural
Networks, Uncertainty Management, Knowledge Discovery, pp. 55–58. Simula-
tion Councils Inc., San Diego (1994)
21. Rasiowa, H.: Algebraic Models of Logic. Warsaw University Press, Warszawa
(2001)
22. Rasiowa, H., Sikorski, R.: A proof of the completeness theorem of G¨odel. Fun-
damenta Mathematicae 37, 193–200 (1950)
23. Shreider, Y.: Equality, Resemblance, Order. Mir Publishers, Moscow (1960)
24. Slupecki, J.: On Aristotle’s Syllogistic. Studia Philosophica (Pozna´n) 4, 275–
300 (1949–1950)

References
43
25. Tarski, A.: Sur les ensembles ﬁnis. Fundamenta Mathematicae 6, 45–95 (1924)
26. Tarski, A.: Zur Grundlegung der Booleschen Algebra. I. Fundamenta Mathe-
maticae 24, 177–198 (1935)
27. Vaught, R.L.: On the equivalence of the axiom of choice and the maximal
principle. Bull. Amer. Math. Soc. 58, 66 (1952)
28. Wille, R.: Restructuring lattice theory: An approach based on hierarchies of
concepts. In: Rival, I. (ed.) Ordered Sets, pp. 445–470. Reidel, Dordrecht (1982)
29. Zeeman, E.C.: The topology of the brain and the visual perception. In: Fort,
K.M. (ed.) Topology of 3-manifolds and Selected Topics, pp. 240–256. Prentice
Hall, Englewood Cliﬀs (1965)
30. Zermelo, E.: Beweiss das jede Menge wohlgeordnet werden kann. Math. An-
nalen 59, 514–516 (1904)
31. Zermelo, E.: Untersuchungen¨uber die Grundlagen der Mengenlehre I. Math.
Annalen 65, 261–281 (1908)
32. Zorn, M.: A remark on method in transﬁnite algebra. Bull. Amer. Math. Soc. 41,
667–670 (1935)


Chapter 2
Topology of Concepts
Topology is a theory of certain set structures which have been motivated by
attempts to generalize geometric reasoning based on Euclidean distance in-
variants and replace it by more ﬂexible schemes. As the notion of closeness, or,
distance, permeates a plethora of reasoning schemes, topological structures
are often in focus of a reasoner. In many schemes of reasoning one resorts to
the idea of a neighbor with the assumption that reasonably selected neigh-
bors of a given object preserve its properties to a satisfactory degree (look at
methods based on the notion of the nearest neighbor, for instance). The no-
tion of a neighbor as well as a collective notion of a neighborhood are studied
by topology.
Basic topological notions were originally deﬁned by means of a notion of
distance which bridges geometry to more general topological structures. The
analysis of properties of distance falls into theory of metric spaces, see Haus-
dorﬀ[12] and Fr´echet [9], with which we begin our exposition of fundamentals
of topology.
Generalizations to abstract structures are discussed in following sections,
with emphasis on basic properties of compactness, completeness, continuity,
relations to algebraic structures, quotient structures, and hyperspaces.
As the last topic, an important notion of a ˇCech topology is discussed,
which arises often in applications, where the underlying structure cannot
satisfy all requirements for a topology; such is , e.g., the case of mereological
structures in general.
2.1
Metric Spaces
Consider a copy R1 of the set of real numbers. The distance between real
numbers is deﬁned usually by means of the natural metric |x −y|. Denoting
|x −y| by ρ(x, y), we may write down the essential properties of the natural
metric well–known from elementary mathematics:
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 45–78.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

46
2 Topology of Concepts
1. ρ(x, y) ≥0 and ρ(x, y) = 0 if and only if x = y;
2. ρ(x, y) = ρ(y, x);
3. ρ(x, z) ≤ρ(x, y) + ρ(y, z) (the triangle inequality).
Properties 1–3 are taken as characterizing any distance function (called also
a metric). Thus, a metric ρ on a set X is a function ρ : X2 →R1 which
satisﬁes the conditions 1–3. A set X endowed with a metric ρ is called a
metric space. Elements of a metric space are usually called points.
The natural metric is an example of a metric. Other examples are
1. The function ρ =
k
i=1(x2
i −y2
i ) on the vector space Rk(the Euclidean
metric);
2. The function ρ(x, y) = maxi|xi −yi| on Rk (the Manhattan metric);
3. The function ρ(x, y) = 
i |xi −yi| on Rk.
An example of a metric on an arbitrary set X may be the the discrete metric
ρ(x, y) deﬁned as ρ(x, y) = 1 when x ̸= y and ρ(x, y) = 0 when x = y.
In general, in order to construct a non–trivial metric we would need a more
reﬁned set–theoretic context.
Now, we will examine set structures induced by a metric. So assume ρ is
a metric on a set X. The elementary notion of topology is the notion of a
neighborhood, due to Hausdorﬀ[12]. To derive this notion, we ﬁrst introduce
the notion of an open ball. For x ∈X and a positive r ∈R1, the open ball of
radius r about x is the set B(x, r) = {y ∈X : ρ(x, y) < r}.
Let us record the basic property of open balls
Proposition 2.1. Assume that y ∈B(x, r) ∩B(z, s). Then, there exists t ∈
R1 with the property that B(y, t) ⊆B(x, r) ∩B(z, s).
Proof. Let t = min{r −ρ(x, y), s −ρ(z, y)} and assume that w ∈B(y, t). By
the triangle inequality, ρ(w, x) ≤ρ(w, y) + ρ(y, x) < r −ρ(x, y) + ρ(x, y) = r
and similarly ρ(w, z) ≤ρ(w, y) + ρ(y, z) < s −ρ(z, y) + ρ(z, y) = s. It fol-
lows that w ∈B(x, r)∩B(z, s) and it follows further that B(y, t) ⊆B(x, r)∩
B(z, s)
⊓⊔
An open set in the metric space (X, ρ) is a union of a family of open balls;
formally U ⊆X is open when U =  B, where B is a family of open balls.
We have
Proposition 2.2. In any metric space (X, ρ),

2.1 Metric Spaces
47
1. The intersection of any two open balls is an open set;
2. The intersection of any ﬁnite family of open sets is an open set;
3. The union of any family of open sets is an open set.
Proof. Property 1 follows from Proposition 2.1 as for any point in the in-
tersection of two balls there exists an open ball about that point contained
in the intersection so the intersection is a union of open balls. For Prop-
erty 2, consider open sets U, W with U =  B, W =  C where B, C are
families of open balls. Then U ∩W =  B ∩ C = {B ∩C : B ∈B,
C ∈C} and as any intersection B ∩C of open balls is a union of open
balls by Property 1, it follows that U ∩W is a union of a family of open
balls hence it is an open set. By induction on n one can then prove that
any intersection U1 ∩U2 ∩... ∩Un of open sets is an open set. For Prop-
erty 3, if T =  U where U is a family of open sets so each U ∈U is a
union of a family of open balls, U =  B U, then T = {B : ∃U ∈U
(B ∈B U)} i.e. T is the union of a family of open balls and so T is an open
set
⊓⊔
We denote by the symbol O (X) the family of all open sets in a metric space
(X, ρ). By the last proposition this family is closed with respect to ﬁnite
intersections and all unions. Clearly, ∅and X are open sets, the former as
the union of the empty family of open balls, the latter as, e.g., the intersection
of the empty family of open balls.
A dual notion of a closed set, due to Cantor [6], is also of principal interest.
A set K ⊆X is closed in case its complement X\K is open. Thus the family C
(X) of all closed sets in X is closed with respect to ﬁnite unions and arbitrary
intersections.
As not any subset of X is open or closed, one may try to characterize the
position of sets in X with respect to open or closed sets. To this end, we
introduce the operation of interior of a set as follows.
For a set A ⊆X, we let
IntA =

{B(x, r) : B(x, r) ⊆A}
(2.1)
i.e., IntA is the union of all open balls contained in A; clearly, IntA is an
open set, moreover by its deﬁnition it is the largest open subset of A. The
operator Int is the interior operator and its value IntA is the interior of the
set A. This operation has the following properties
Proposition 2.3. In any metric space (X, ρ),
1. Int∅= ∅;
2. IntA ⊆A;

48
2 Topology of Concepts
3. Int(A ∩B) = IntA ∩IntB;
4. Int(IntA) = IntA.
Proof. As ∅is the only open subset of itself, so Property 1 holds. Clearly
intA ⊆A by deﬁnition i.e. Property 2 is fulﬁlled. For Property 3, x ∈IntA∩
IntB if and only if B(x, r) ⊆A and B(x, s) ⊆B for some r, s > 0 if and only
if B(x, t) ⊆A ∩B where t = min{r, s} if and only if x ∈Int(A ∩B). Finally,
Property 4 follows as IntA is an open set and thus Int(IntA) = IntA
⊓⊔
The dual operator Cl of closure, introduced in Riesz [22], cf., Kuratowski
[13], is deﬁned via the formula
ClA = X \ Int(X \ A)
(2.2)
Hence, by duality, ClA is a closed set containing A and it is the smallest
among such sets. From the previous proposition, the following properties of
Cl follow
Proposition 2.4. For any metric space (X, ρ),
1. ClX = X;
2. A ⊆ClA;
3. Cl(A ∪B) = ClA ∪ClB;
4. Cl(ClA) = ClA.
Proof. For Property 1 we have ClX = X\Int(X\X) = X\Int∅= X\∅= X.
In case of Property 2, as Int(X \A) ⊆X \A, we have A = X \(X \A) ⊆X \
Int(X \A) = ClA. Similarly Property 3 follows: Cl(A∪B) = X \Int(X \(A∪
B)) = X\Int((X\A)∩(X\B)) = X\(Int(X\A)∩Int(X\B)) = X\(Int(X\
A)) ∪X \ (Int(X \ B)) = ClA ∪ClB. Finally, ClA is a closed set hence it is
identical to its closure: Cl(ClA) = ClA
⊓⊔
The diﬀerence ClA \ IntA =BdA is a closed set called the boundary of A. In
case BdA = ∅, we say that A is closed–open (or, clopen for short).
For any x ∈X, a set A ⊆X is called a neighborhood of x if and only if
x ∈IntA. It is easy to see that the intersection of two neighborhoods of x is
a neighborhood of x and that any set containing a neighborhood of x is itself
a neighborhood of x, i.e., the family N(x) of all neighborhoods of x is a ﬁlter,
see Ch. 1, sect. 11. Usually one does not need to look at all neighborhoods
of x. It is suﬃcient to look at a co–ﬁnal sub–family of N(x) viz. we call a
sub–family B(x) of N(x) a neighborhood basis if and only if for any A ∈N(x)
there exists B ∈B(x) with the property that B ⊆A. Thus, B(x) contains
arbitrarily small neighborhoods of x.

2.1 Metric Spaces
49
Proposition 2.5. In any metric space (X, ρ), any point x has a countable
neighborhood basis.
Proof. It suﬃces to select for each n ∈N the open ball B(x, 1/n) and let
B(x) = {B(x, 1/n) : n ∈N}. Indeed, given any A ∈N(x), as x ∈IntA, there
exists an open ball B(x, r) with r > 0 and B(x, r) ⊆A. For 0 < 1/n < r, we
have B(x, 1/n) ⊆B(x, r)
⊓⊔
The fact that neighborhood bases of all points in a metric space may be
chosen countable, makes it possible to describe metric topology by means of
sequences. A sequence in a set X is the image f(N) of the set N of natural
numbers under a function f : N →X. Usually, we write down a sequence
as the set {f(n) : n ∈N} or in a concise form as (xn)n disregarding the
function f (which after all may be fully restored from the latter notation as
f(n) = xn, each n ∈N).
A sequence (xn)n is converging to a limit x ∈X if and only if each neigh-
borhood A of x contains almost all (meaning: all but a ﬁnite number) mem-
bers xn of the sequence. In this case we write x = limxn. More formally,
x = limxn if and only if for each r > 0 there exists n(r) ∈N such that
xm ∈A for each m ≥n(r). A canonical example of a sequence converging to
x may be obtained via axiom of choice by selecting a point xn ∈B(x, 1/n)
for each n ∈N.
We may now characterize interiors and closures in a metric space by means
of neighborhoods as well as by means of sequences.
Proposition 2.6. In any metric space (X, ρ)
1. x ∈IntA if and only if there exists a neighborhood P ∈N(x) such that
P ⊆A;
2. x ∈IntA if and only if for any sequence (xn)n with x = limxn there exists
n0 ∈N such that xm ∈A for each m ≥n0;
3. x ∈ClA if and only if for every P ∈N(x) we have P ∩A ̸= ∅;
4. x ∈ClA if and only if there exists a sequence (xn)n ⊆A with x = limxn.
Proof. Property 1 follows by deﬁnition of IntA. Property 2 follows by def-
inition of a limit of a sequence: if x ∈IntA and x = limxn then almost
every xn ∈IntA a fortiori almost every xn ∈A. Assume conversely that
x /∈IntA; then for any n ∈N, we have that it is not true that B(x, 1/n) ⊆A
so we may choose xn ∈B(x, 1/n) \ A for n ∈N. Obviously, x = limxn and
{xn : n ∈N} ∩A = ∅proving Property 2.
Property 3 follows from Property 1 by duality : x ∈ClA if and only if
x /∈Int(X \ A). As for Property 4, if x ∈ClA then B(x, 1/n) ∩A ̸= ∅so
selecting xn ∈B(x, 1/n) ∩A for each n, we produce a sequence (xn)n ⊆A
with x = limxn.

50
2 Topology of Concepts
Conversely if x = limxn for a sequence (xn)n ⊆A, then for any neighbor-
hood P ∈N(x) we have P ∩{xn : n ∈N} ̸= ∅a fortiori P ∩A ̸= ∅so x ∈ClA
in virtue of Property 3
⊓⊔
Now we show some methods for constructing new spaces.
2.2
Products of Metric Spaces
It may be desirable at this point to introduce some techniques for constructing
more intricate metric spaces of general importance. We now begin with a
discussion of topologies on Cartesian products. For a family F = {Fi : i ∈I}
of sets, the Cartesian product ΠiFi is the set of all functions f : I → F with
the property that f(i) ∈Fi for each i ∈I. We refer to a function f ∈ΠiFi
as to a thread and we usually write down this thread in the form (fi)i, i.e.,
as a generalized sequence.
Assume now that each Fi is a metric space with a metric ρi; we consider a
question: is there a way to introduce a metric on the Cartesian product ΠiFi
so it be compatible in a sense with metrics ρi? It turns out that in order
to answer this question positively we should restrict ourselves to countable
products in which case the set I is countable.
In case we have a Cartesian product ΠnFn of a countable family F = {Fn :
n ∈N} of metric spaces (Fn, ρn), we ﬁrst normalize metrics ρn by letting
ηn(x, y) = min{1, ρn(x, y)} for x, y ∈Fn, each n. Then
Proposition 2.7. For each n, metrics ρn, ηn induce the same topology in
the sense that families of open sets are identical in both metrics. Hence,
convergence of sequences is identical with respect to both metrics.
Indeed, for any set A ⊆Fn, if A is open with respect to ρn i.e. Bρ(x, r(x)) ⊆A
for each x ∈A then Bη(x, min{1, r(x)}) ⊆A for each x ∈A i.e. A is open
with respect to η. The converse follows on same lines.
We say that metrics ρ, η are equivalent. We may assume that ρn is already
bounded by 1 for each n. Then, for f = (fi)i, g = (gi)i ∈ΠiFi, we let
ρ(f, g) =
∞

n=0
1
2n · ρn(fn, gn)
(2.3)
and we declare ρ to be a product metric on the Cartesian product ΠnFn. It
is evident that ρ is a metric.
A classical example of a metric Cartesian product is the Cantor cube C
= Πn{0, 1}n where {0, 1}n = {0, 1} for each n. Using the symbol 2 for the
set {0, 1}, we may use for the Cantor cube the symbol 2N as any thread
f ∈C may be regarded as the characteristic function of a set A ⊆N, i.e.,
A = {n ∈N : f(n) = 1} and thus C is the set of function codes for subsets
of the set of natural numbers.

2.3 Compact Metric Spaces
51
Regarding the set 2 = {0, 1} as a metric space with the discrete metric,
we have the product metric
ρ(f, g) =
∞

n=0
1
2n · |fn −gn|
(2.4)
on 2N.
We may be interested in basic neighborhoods in this metric space. Let us
observe that any set of the form
B(i1, i2, ..., in) = {f ∈2N : fk = ik, k = 1, 2, .., n}
(2.5)
where i1, i2, ..., in ∈2 is open: given f ∈B(i1, i2, ..., in) we have B(f,
1
2n+1 ) ⊆
B(i1, i2, ..., in); indeed, g ∈B(f,
1
2n+1 ) implies gi = fi for i = 1, 2, ..., n.
Conversely, any open ball B(f, r) contains a neighborhood of f of the
form B(i1, i2, .. ., in): it suﬃces to take the least n with the property that
∞
j=n+1
1
2j < r and then B(f1, ..., fn) ⊆B(f, r). We have veriﬁed
Proposition 2.8. Open sets of the form B(i1, i2, ..., in) form a basis for the
product metric topology of the Cantor cube: each open set is the union of a
family of sets of the form B(i1, i2, ..., in).
In particular, for any f ∈2N, we have N(f) = {B(f1, f2, ..., fn) : n ∈N}.
Using the Cantor cube as an example, we may exhibit two important
properties of topological, in particular metric, spaces, viz., completeness and
compactness.
To begin with, let us look at an arbitrary sequence (xn)n in the Cantor
cube. As each xn may take at each coordinate i only one of two values 0, 1,
there exists y ∈2N with the property that for each j ∈N the set Aj =
{xn : xni = yi, i = 1, 2, ..., j} is inﬁnite. Let nj be the ﬁrst natural number n
such that xn ∈Aj. Then the sub–sequence (xnj)j converges to y: for any basic
neighborhood B(y1, y2, .., yj) of y we have xn ∈B(y1, y2, .., yj) for n ≥nj.
We have proved that
Proposition 2.9. Any sequence in the Cantor cube contains a convergent
subsequence.
Of a metric space with this property we say that it is compact. Let us establish
other characterizations of compactness, more convenient in case of general
topological spaces.
2.3
Compact Metric Spaces
We say that a family U of open sets in a metric space X is an open covering
of X if and only if X =  U. A family U′ ⊆U is a sub–covering in case
X =  U′.

52
2 Topology of Concepts
A family of sets F is centered if and only if for any ﬁnite sub–family
F′ ⊆F, the intersection  F′ is non–empty.
Let us observe that in a compact metric space X there exists a countable
base for open sets: to this end we observe that compact metric spaces have
the property of having ﬁnite nets.
Proposition 2.10. In each compact metric space (X, ρ), for each r > 0,
there exists a ﬁnite subset Xr = {x1, ..., xkr} with the property that for each
y ∈X there exists j ≤kr with ρ(y, xj) < r.
Proof. Assume to the contrary that for some r > 0 no ﬁnite subset Y ⊆
X satisﬁes the condition in the proposition. Let us select x0 ∈X. There
exists x1 ∈X with ρ(x0, x1) ≥r and in general once we ﬁnd x0, x1, .., xm
with ρ(xi, xj) ≥r for i ̸= j, i, j ≤m then we can ﬁnd xm+1 ∈X with
ρ(xm+1, xj) ≥r for j = 1, 2, ..., m. By the principle of mathematical induction
we deﬁne thus a sequence (xn)n in X with ρ(xi, xj) ≥r for i ̸= j which clearly
cannot have any convergent subsequence
⊓⊔
A set Xr is called an r–net; thus, in compact metric spaces there exist r-
nets for each r > 0. Now, let us select for each n ∈N a 1/n–net Xn. Let
Y = {Xn : n ∈N}. Then for each x ∈X and any r > 0, there exists y ∈Y
with ρ(x, y) < r.
It follows that the family {B(y, 1/m) : y ∈Y, m ∈N} is a countable
basis for open sets: given an open ball B(x, r) and z ∈B(x, r), we may ﬁnd
y ∈Y and m ∈N such that 2/m < r −ρ(x, z) and ρ(z, y) < 1/m and then
z ∈B(y, 1/m) ⊆B(x, r). We have proved
Proposition 2.11. In each compact metric space (X, ρ) there exists a count-
able basis for open sets.
It follows that in case of any compact metric space X we may restrict our-
selves to countable coverings: any open covering contains a countable sub–
covering; indeed, given an open covering U of X and a countable base B for
open sets, the sub–family U′, deﬁned by selecting for each B ∈B a U ∈U
such that B ⊆U, is a countable covering of X. Now we may turn to promised
characterizations.
Proposition 2.12. For a metric space (X, ρ), the following statements are
equivalent
1. X is compact;
2. Each countable centered family of closed sets in X has a non–empty inter-
section;
3. Each countable open covering of X has a ﬁnite sub–covering.

2.4 Complete Metric Spaces
53
Proof. Assume Property 1. Let F = {Fn : n ∈N} be a centered family of
closed sets. Hence each intersection F1 ∩... ∩Fn is non–empty and we may
select a point xn ∈F1 ∩... ∩Fn for each n. There exists a convergent sub–
sequence (xnk)k with x = limxnk. Then x ∈Fn for each n and thus x ∈ F.
This proves Property 2.
Now, Property 3 follows from Property 2 by duality: given a countable
open covering {Un : n ∈N} without any ﬁnite sub–covering, the family F
= {Fn = X \ Un : n ∈N} is a centered family of closed sets so by 2 there
exists x0 ∈ F. But then x0 /∈ U, a contradiction.
Finally, Property 3 implies Property 1, as if we had a sequence (xn)n
without any convergent sub–sequence then we would have for each x ∈X an
open neighborhood Ux with the property that xn ∈Ux for ﬁnitely many n
only. Then the open covering {Ux : x ∈X} contains a ﬁnite sub–covering Ux1
∪...∪Uxk = X which misses inﬁnitely many elements of the sequence (xn)n, a
contradiction
⊓⊔
The last proposition indicates that compactness may be deﬁned in purely
topological terms of open, respectively closed, sets regardless of a speciﬁc met-
ric from the class of equivalent metrics inducing the given topology. Compact-
ness allows for existential arguments based on the convergent sub–sequences.
We have begun with an example of the Cantor cube as a compact metric
space. To give more examples, let us observe that the unit interval I = [0,1]
is a compact metric space in natural metric topology induced by the metric
ρ(x, y) = |x −y|; indeed, assume that U is an open covering of I (we may
also assume that elements of U are open intervals of the form (a, b), [0, a),
or (a, 1]). Was I not compact, we could consider a subset C ⊆I deﬁned as
follows: x ∈C if and only if the interval [0, x] may be covered by a ﬁnite
number of elements of U.
As, under our assumption, 1 /∈C, there exists s = supC < 1. We may pick
an element s ∈(a, b) ∈U along with some a < t < s. Then the interval [0, t]
may be covered by ﬁnitely many elements U1, .., Uk of U hence U1, .., Uk, (a, b)
cover any interval of the form [0, w] for s < w < b, contrary to the deﬁnition
of s. It follows that supC = 1 and a fortiori [0,1] is compact. Same argument
will show that each interval [a, b] in the real line is compact.
2.4
Complete Metric Spaces
A weakening of compactness is the condition of completeness. This notion
depends on the notion of a fundamental sequence. A sequence (xn)n is fun-
damental if and only if for each r > 0 there exists nr ∈N such that
ρ(xnr+k, xnr) < r for each k. Let us observe that each convergent sequence
is fundamental.
A metric space (X, ρ) is complete if and only if each fundamental sequence
converges in X.

54
2 Topology of Concepts
Proposition 2.13. If a fundamental sequence (xn)n contains a convergent
sub–sequence, then the sequence (xn)n converges. Hence any compact metric
space is complete.
Indeed, assuming a sub–sequence (xnk)k to be convergent to a point x, we
have ρ(x, xn) ≤ρ(x, xnk) + ρ(xnk, xn) and it is suﬃcient to observe that
ρ(x, xnk), ρ(xnk, xn) tend to 0 as n, nk tend to ∞. Hence ρ(x, xn) approaches
0 as n tends to ∞and this implies x = limxn. Thus, in a compact metric
space any fundamental sequence converges implying completeness.
As any fundamental sequence in the real line R1 is bounded, i.e., it is
contained in a closed interval of the form [a, b] which is compact, it contains
a convergent subsequence and it does converge itself by Proposition 2.13.
Thus the real line in natural metric is a complete metric space. One may
prove that the set of irrational real numbers is also a complete metric space
under the natural metric.
As with compactness, we may attempt at characterizing completeness in
topological terms. Contrary to the case of compactness, we will not get rid
of the metric.
For a subset A ⊆X of a metric space (X, ρ), we deﬁne the diameter of A,
diamA as follows: diamA = sup{ρ(x, y) : x, y ∈A}. We say that a family A
of subsets of X contains arbitrarily small sets if and only if for each r > 0
there exists A ∈A with diamA ≤r.
Proposition 2.14. (Cantor [5]) A metric space (X, ρ) is complete if and
only if each centered countable family F of closed non–empty sets containing
arbitrarily small sets has a non–empty intersection.
Proof. Assume (X, ρ) is complete. We may also assume that F = {Fn : n ∈
N} satisﬁes the condition Fn+1 ⊆Fn for each n. Indeed, otherwise we could
consider the family G = {F1 ∩... ∩Fn : Fi ∈F} as  G =  F. Selecting
xn ∈Fn for each n, we produce a sequence (xn)n which is fundamental:
ρ(xn+k, xn) ≤diamFn and limdiamFn = 0. Hence there exists a convergent
sub–sequence (xnk)k with the limit x ∈X. Clearly, x ∈ClFn = Fn for each
n so x ∈ F.
Now, we assume that the condition on F is satisﬁed and we prove com-
pleteness. Given a fundamental sequence (xn)n in X, we consider Fn =
Cl{xk : k ≥n} and F = {Fn : n ∈N}. Clearly, Fn+1 ⊆Fn for each n
and limdiamFn = 0. Thus, there exists x ∈ F, a fortiori, x = limxn: for
each ball B(x, r) we have Fn ⊆B(x, r) for almost every n hence xn ∈B(x, r)
for almost every n
⊓⊔
Complete metric spaces proved to be very important due to their properties
of which we recall here the two most fundamental and very often recalled
in applications, viz., the Baire category theorem and the Banach ﬁxed point
theorem.
The Baire category theorem basically states that a complete metric space
cannot be covered by countably many ”small” subsets. We should deﬁne the
meaning of ‘small’.

2.4 Complete Metric Spaces
55
We say that a subset A ⊆X is meager when IntA = ∅and A is nowhere
dense in case IntClA = ∅. When B = {An : n ∈N} and each An is
nowhere dense then we call B a set of 1st category. An archetypical example
of a meager set is ClA\A for any A; indeed, was Int(ClA\A) ̸= ∅we would
have G ⊆ClA \ A for some open non–empty G implying G ∩A = ∅on one
hand and G ∩A ̸= ∅on the other.
Proposition 2.15. (the Baire category theorem, Baire [3]) In any complete
metric space (X, ρ), any set of the 1st category is meager.
Proof. Consider a set Y = {Yn : n ∈N} of the 1st category. For an
arbitrary x0 ∈X, we deﬁne inductively closed sets Fn for n ∈N such that
x0 ∈IntFn and
Fn+1 ⊆IntFn
for each n and F = {Fn : n ∈N} contains arbitrarily small sets.
To begin with, as IntClY0 = ∅, taking an arbitrary open ball B(x0, s0) we
ﬁnd
B(y0, r0) ⊆ClB(y0, r0) ⊆B(x0, s0) \ ClY0
(2.6)
with r0 < 1/2. Assuming that open balls B(y0, r0), ..., B(yk, rk) with
⎧
⎪
⎪
⎨
⎪
⎪
⎩
(i) ClB(yi+1, ri+1) ⊆B(yi, ri) for i = 1, 2, .., k −1
(ii) ClB(yi, ri) ∩ClYi = ∅for i ≤k
(iii) ri <
1
2i+1 for i ≤k
(2.7)
have been deﬁned, we repeat our argument with Yk+1 in place of Y0 and
B(yk, rk) in place of B(x0, s0) to produce
B(yk+1, rk+1) ⊆ClB(yk+1, rk+1) ⊆B(yk, rk) \ ClYk+1
with rk+1 <
1
2k+2 .
By induction, we arrive at the sequence (Fk = ClB(yk, rk))k satisfying
(2.7) and thus Fk+1 ⊆Fk, Fk ⊆X \ ClYk, each k, and limdiamFk = 0. It
follows by completeness that there exists x ∈{Fk : k ∈N} and clearly
x /∈Y . As x ∈B(x0, s0), we have proved that {Yk : k ∈N} contains no
non–empty open set, i.e., it is meager
⊓⊔
It follows from the proof that the diﬀerence X \ Y is dense in X: any open
non–empty ball contains a point from X \ Y . In other form: Cl(X \ Y ) = X.
The Baire category theorem is an important tool in proving the existence
(although non–eﬀectively) of certain objects and moreover in proving that
these objects form a large (not of the 1st category) set (like, e.g., continuous
nowhere diﬀerentiable real functions).
The Banach ﬁxed point theorem also allows for proving existential facts.
It has to do with contracting functions. A function f : X →X on a metric
space (X, ρ) is a contracting function with a contraction factor 0 < λ < 1 if

56
2 Topology of Concepts
and only if ρ(f(x), f(y)) ≤λ · ρ(x, y). Then we claim that f has a ﬁxed point
c, i.e., f(c) = c.
Proposition 2.16. (the Banach ﬁxed point theorem, Banach [4]) Each con-
tracting function on a complete metric space (X, ρ) has a (unique) ﬁxed point.
Proof. Let us begin with an arbitrary x0 ∈X. We deﬁne inductively a
sequence (xn)n by letting xn+1 = f(xn) for each n. This sequence is
fundamental: letting K = ρ(x0, x1) = ρ(x0, f(x0)), we have ρ(x1, x2) =
ρ(f(x0), f(x1)) ≤λρ(x0, x1) = λ · K. Analogously, ρ(x2, x3) ≤λ2 · K, and in
general ρ(xn, xn+1) ≤λn · K. Thus, we have
ρ(xn+k, xn) ≤K ·
i=n+k−1

i=n
λi = K · λn 1 −λk
1 −λ
(2.8)
and hence ρ(xn+k, xn) tends to 0 as n, n+k tend to ∞. By completeness, there
exists c = limxn. As ρ(f(c), f(xn)) ≤λ · ρ(c, xn) we have f(c) = limf(xn) =
limxn+1 = c so c is a ﬁxed point of f. Observe that f has a unique ﬁxed point:
was d a ﬁxed point other than c, we would have ρ(c, d) = ρ(f(c), f(d)) ≤
λ · ρ(c, d), a contradiction
⊓⊔
Passing with k to ∞in the formula (2.8) and noticing that c = limxn+k, we
have
ρ(c, xn) ≤K · λn
1
1 −λ
(2.9)
which allows for an estimate of the depth of procedure necessary to approxi-
mate c with xn with a given accuracy. In order to have ρ(c, xn) ≤δ it suﬃces
by (2.9) to have
K · λn
1
1 −λ ≤δ
(2.10)
hence it suﬃces that
n = ⌊logK−1 · (δ · (1 −λ))
logλ
⌋
(2.11)
We now pass to general topological spaces.
2.5
General Topological Spaces
By a topological space, we mean a set X along with a topology τ deﬁned
usually as a family τ ⊆2X of sets in X which satisﬁes the conditions for
open sets familiar to us from Proposition 2.2, viz.,
1. For any ﬁnite sub–family τ ′ ⊆τ, we have  τ ′ ∈τ;
2. For any sub–family τ ′ ⊆τ, we have  τ ′ ∈τ.

2.5 General Topological Spaces
57
Hence, τ is closed with respect to operations of ﬁnite unions and arbitrary
intersections; let us notice that ∅∈τ as the union of the empty family and
X ∈τ as the intersection of the empty family.
Elements of τ are open sets, Alexandroﬀ[1], Fr´echet [10]. As with metric
spaces, we introduce the operator Int of interior deﬁned as follows,
IntA =

{U ∈τ : U ⊆A}
(2.12)
IntA is the union of all open subsets of A and a fortiori it is the greatest open
subset of A. By closeness of τ on ﬁnite intersections and unions, we obtain
basic properties of Int.
Proposition 2.17. The following are properties of the operation of interior
I1 Int∅= ∅
I2 IntA ⊆A
I3 Int(A ∩B) = IntA ∩IntB
I4 Int(IntA) = IntA
Indeed, Properties I1, I2 follow by remarks following the deﬁnition of Int,
Property I3 follows by the ﬁnite intersection property of τ and Property I4
does express obvious fact that any open set is its interior. Let us observe that
by Property I4, we have also,
I5 A ⊆B implies IntA ⊆IntB
Conversely, open sets may be introduced via the interior operator Int satis-
fying Properties I1–I4.
Proposition 2.18. If an operator I : 2X →2X does satisfy Properties I1–I4,
then τ = {A ⊆X : A = IA} is a topology on X and I is the interior operator
Int with respect to τ.
Proof. We call A such that A = IA open. As I(A∩B) = IA∩IB by Property
I3, the intersection of two open sets is open and by induction it follows that
τ is closed with respect to ﬁnite intersections. For a family {Ai : i ∈I} where
IAi = Ai, we have by Property I5, that Ai = IAi ⊆I 
i Ai for each i hence

i Ai ⊆I 
i Ai and ﬁnally by Property I2, 
i Ai = I 
i Ai, i.e., 
i Ai ∈τ
⊓⊔
By duality, we may deﬁne the closure operator Cl via
ClA = X \ Int(X \ A)
(2.13)

58
2 Topology of Concepts
The closure operator does satisfy dual conditions
C1 ClX = X
C2 A ⊆ClA
C3 Cl(A ∪B) = ClA ∪ClB
C4 Cl(ClA) = ClA
and we may deﬁne the family C(X) of closed sets in X by letting C(X) =
{A ⊆X : ClA = A}. By duality, this family is closed with respect to ﬁnite
unions and arbitrary intersections. The family τ = {X \ A : A ∈C(X)}
is clearly the family of open sets with respect to topology induced by the
operator Cl.
Operators Int and Cl give rise to a topological calculus on sets. Let
us observe that both these operators are monotone: for A ⊆B, we have
IntA ⊆IntB by Property I5, and
C5 ClA ⊆ClB
by the dual to Property I5. We begin with a useful lemma of this calculus.
Proposition 2.19. For an open set P and a set A we have: P ∩ClA ⊆
Cl(P ∩A).
Indeed, for x ∈P ∩ClA and any open set Q ∋x, we have (Q ∩P) ∩A ̸= ∅
as Q ∩P is a neighborhood of x and x ∈ClA, hence Q ∩(P ∩A) ̸= ∅, i.e.,
x ∈Cl(P ∩A).
Various algebras of sets may be deﬁned with help of these operations. We
begin with the two most important.
2.6
Regular Open and Regular Closed Sets
We say that a set A ⊆X is regular open if and only if A = Int(ClA), i.e., A
is the interior of its closure.
Similarly, we say that a set A ⊆X is regular closed if and only if A =
Cl(IntA), i.e., A is the closure of its interior.
Both types of sets are related to each other by duality: A is regular open
if and only if X \ A is regular closed. Indeed, if A = IntClA then X \ A=X \
IntClA = X \ Int(X \ (X \ ClA)) = Cl(X \ ClA) = Cl(Int(X \ A)).
We now prove a basic fact that regular open sets form a Boolean algebra,
denoted RO(X). In order to prove this fact, we introduce a new auxiliary
symbol, and we let

2.6 Regular Open and Regular Closed Sets
59
A⊥= X \ ClA
The set A is regular open if and only if A = A⊥⊥. Indeed, A⊥⊥= X \Cl(X \
ClA) = IntClA. We sum up properties of the operation A⊥
Proposition 2.20. The following are properties of the operation A⊥
1. If A ⊆B, then B⊥⊆A⊥;
2. If A is an open set, then A ⊆A⊥⊥;
3. If A is an open set, then A⊥= A⊥⊥⊥, hence, A⊥⊥= A⊥⊥⊥⊥;
4. If A, B are open sets, then (A ∩B)⊥⊥= A⊥⊥∩B⊥⊥;
5. (A ∪B)⊥= A⊥∩B⊥;
6. If A is an open set, then (A ∪A⊥)⊥⊥= X.
Proof. Property 1 follows immediately: A ⊆B implies ClA ⊆ClB implies
X \ ClB ⊆X \ ClA. For Property 2, A open implies A ⊆IntClA = A⊥⊥
as A ⊆ClA. In case of Property 3, we get A⊥⊆A⊥⊥⊥from Property 2 by
substituting A⊥for A; also from Property 2 we get by applying Property 1:
A⊥⊥⊥⊆A⊥, hence, Property 3 follows.
For Property 4, we have by applying Property 1 twice to the inclusion
A ∩B ⊆A that (A ∩B)⊥⊥⊆A⊥⊥and similarly (A ∩B)⊥⊥⊆B⊥⊥hence
(A ∩B)⊥⊥⊆A⊥⊥∩B⊥⊥.
For the converse, we apply Proposition 2.19 and we observe that its state-
ment A ∩ClB ⊆Cl(A ∩B) may be paraphrased as
A⊥⊥∩B ⊆(A ∩B)⊥⊥
(2.14)
Hence, for A, B open, we have A ∩ClB ⊆Cl(A ∩B), i.e.,
(A ∩B)⊥= X \ Cl(A ∩B) ⊆X \ (A ∩ClB) = (X \ A) ∪B⊥
(2.15)
From (A ∩B)⊥⊆(X \ A) ∪B⊥, we get
A ∩B⊥⊥= ((X \ A) ∪B⊥)⊥⊆(A ∩B)⊥⊥
(2.16)
Substituting in
A ∩B⊥⊥⊆(A ∩B)⊥⊥
(2.17)
A⊥⊥for A, and applying the second statement in Property 3, we come at
A⊥⊥∩B⊥⊥⊆(A⊥⊥∩B)⊥⊥⊆(A ∩B)⊥⊥⊥⊥= (A ∩B)⊥⊥
(2.18)
which proves Property 4.

60
2 Topology of Concepts
Property 5 follows immediately by duality. To check Property 6, let us
observe that in case A open we have A ∪A⊥= ClA \ A hence
(A ∪A⊥)⊥= IntCl(ClA \ A) = Int(ClA \ A) = ∅
(2.19)
as ClA \ A is meager. Thus (A ∪A⊥)⊥⊥= X
⊓⊔
Let us observe that from the second part of Property 3 above: A⊥⊥= A⊥⊥⊥⊥
it follows that IntClIntClA = IntClA and ClIntClIntA = ClIntA for any
A. A consequence of this is that one may obtain from a given set A by
applying Int, Cl, \ only at most 14 distinct sets. The reader will easily write
them down. From this property also follows immediately that any set of the
form A⊥⊥is regular open, i.e., any set of the form IntClA is regular open.
By duality, any set of the form ClIntB is regular closed.
Now, we pass to the family RO(X) of regular open sets.
Proposition 2.21. RO(X) is a Boolean algebra under operations ∧, ∨, ′, de-
ﬁned as follows
1. A ∨B = (A ∪B)⊥⊥= IntCl(A ∪B);
2. A ∧B = A ∩B;
3. A′ = A⊥= X \ ClA.
and with constants 0 = ∅, 1 = X.
Proof. All Boolean operations listed above give regular open sets by proper-
ties of (.)⊥listed above in Proposition 2.20. It remains to check that axioms of
a Boolean algebra are satisﬁed. Commutativity laws A∨B = B ∨A, A∧B =
B ∧A are satisﬁed evidently. The laws A ∨0 = A, A ∧1 = A are also man-
ifest. We have A ∧A′ = A ∩A⊥= A \ ClA = ∅= 0 as well as A ∨A′ =
(A∪A⊥⊥)⊥⊥) = X = 1. The distributive laws A∨(B∧C) = (A∨B)∧(A∨C)
as well as A ∨(B ∧C) = (A ∨C) ∧(A ∨C) hold by Property 5 and
dualization
⊓⊔
A particular sub–algebra of RO(X) is the algebra CO(X) of clopen sets in X.
In case of CO(X) boolean operations ∨, ∧, ′ specialize to usual set–theoretic
operations ∪, ∩, \ i.e. CO(X) is a ﬁeld of sets.
The basic distinction between RO(X) and CO(X) is the fact that RO(X)
is a complete Boolean algebra for any X whereas CO(X) is not always such.
We prove this important fact.
Proposition 2.22. The boolean algebra RO(X) is complete for any topolog-
ical space X.
Proof. Let us observe that the boolean ordering relation ≤is in this case
the inclusion ⊆. Consider A ⊆RO(X). Let s(A) = ( A)⊥⊥; we check that
s(A) is the supremum of A. Indeed, for A ∈A, we have A ∈ A hence

2.7 Compactness in General Spaces
61
A = A⊥⊥⊆( A)⊥⊥i.e. A ≤s(A). It follows that s(A) is an upper bound
for A. Now, assume that B ∈RO(X) is an upper bound for A i.e. A ⊆B for
each A ∈A. Hence (A) ⊆B and thus ( A)⊥⊥⊆B⊥⊥= B i.e. s(A) ≤B
proving that s(A) is the supremum of A. Finally, by duality it follows that
i(A) = ( A)⊥⊥is the inﬁmum of A
⊓⊔
By duality applied to the family RC(X) of regular closed sets in X, we obtain
a dual proposal
Proposition 2.23. RC(X) is a boolean algebra under operations ∧, ∨, ′ de-
ﬁned as follows
1. A ∨B = A ∪B.
2. A ∧B = ClInt(A ∩B).
3. A′ = X \ IntA.
and with constants 0 = ∅, 1 = X. The algebra RC(X) is complete.
We now pass to a study of compactness in general spaces.
2.7
Compactness in General Spaces
Now it is time for exploring notions we have met with in the metric case in
the general topological context. We begin with the notion of compactness as
the most important by far and yielding most easily to generalizations.
As a deﬁnition of compactness in general spaces, we adopt the open cover-
ing condition proved for metric spaces in Proposition 12(3). Thus, we say that
a topological space (X, τ) is compact, after Alexandroﬀ–Urysohn [2], if and
only if any open covering U of X contains a ﬁnite sub–covering {U1, .., Uk}.
The following characterizations follow easily.
For a ﬁlter F, we say that x ∈X is a cluster point of F if P ∩F ̸= ∅for
any F ∈F and any neighborhood P of x. Let us observe that in case F is an
ultraﬁlter, and x its cluster point, we have N(x) ⊆F, i.e., F has as elements
all neighborhoods of x. In this case we say that x is a limit of F, in symbols
x = limF.
Proposition 2.24. For a topological space (X, τ) the following are equivalent
1. X is compact;
2. Each centered family of closed subsets of X has a non–empty intersection;
3. Each ﬁlter on X has a cluster point;
4. Each ultraﬁlter on X has a limit point.

62
2 Topology of Concepts
Proof. Properties 1 and 2 are equivalent as they are dual statements with
respect to duality open – closed. Consider a ﬁlter F. As any ﬁnite intersection
of elements of F is non–empty, it follows that
F = {ClF : F ∈F}
(2.20)
is a centered family of closed sets hence

F ̸= ∅
(2.21)
Any x ∈ F is a cluster point of F proving Property 3. Property 4 follows
from Property 3 as for any ultraﬁlter its any cluster point is a limit point.
Now assume Property 4 and consider a centered family F of closed sets.
Letting
F∗= {A ⊆X : ∃F ∈F(F ⊆A)}
(2.22)
we deﬁne a ﬁlter F∗which extends to an ultraﬁlter G. By Property 4, there
exists x = limG; hence, any neighborhood of x does intersect any set in G
and moreover any set in F thus x ∈ClF = F for any F ∈F, hence, x ∈ F
proving Property 2 which as we know is equivalent to Property 1
⊓⊔
Compact spaces have the Baire property: any countable union of nowhere–
dense sets is meager. The proof of this fact mimics the proof of the corre-
sponding result for complete metric spaces.
When discussing compactness, in general context, two important ﬁndings
come to the fore. The ﬁrst is the Tikhonov theorem, due to Tikhonov [25],
stating that any Cartesian product of compact spaces is a compact space and
the second is the Stone duality theorem of Stone [24] allowing to represent
any Boolean algebra B as the ﬁeld CO(X) of clopen sets in a compact space
X. We give the proofs of these both facts of fundamental importance.
First, we have to deﬁne topology of a Cartesian product ΠiXi of a family
{Xi : i ∈I} of topological spaces (Xi, τi). To this end, we call a box deﬁned
by coordinates i1, .., ik and open sets Ui ∈τi, i = 1, 2, .., k, the set
O(i1, .., ik, U1, .., Uk) = {f ∈ΠiXi : fi ∈Ui, i = 1, 2, .., k}
(2.23)
We deﬁne a topology τΠ on ΠiXi by accepting the family of all boxes as an
open basis for τΠ, i.e., U ∈τΠ if and only if there exists a family {Bi : i ∈I}
of boxes with U = {Bi : i ∈I}.
Proposition 2.25. (the Tikhonov theorem) A Cartesian product X = ΠiXi
of a family {Xi : i ∈I} of compact spaces with the topology τΠ is a compact
space.
Proof. Consider projections pi : X →Xi deﬁned as follows: pi(f) = fi for
f ∈X, i ∈I. For an ultraﬁlter F on X, consider ﬁlters Fi induced by pi(F)
in each Xi.

2.7 Compactness in General Spaces
63
By compactness, there exists a cluster point xi of F i in Xi and we may
deﬁne x = (xi)i in X. Now for any neighborhood G of x in X there exists a
box x ∈O(i1, .., ik, U1, .., Uk) ⊆G hence xi in Ui for i = i1, .., ik. It follows
that Ui ∩F ̸= ∅for each F ∈F i and thus G ∩F ̸= ∅for any F ∈F. Thus x
is a cluster point hence a limit point for F
⊓⊔
By the Tikhonov theorem, e.g., cubes [0, 1]n in Euclidean n–spaces (n =
2, 3, ...) as well as the Hilbert cube [0, 1]N are compact metric spaces.
Now we will consider a Boolean algebra B and we deﬁne a set S(B) as
follows. Elements of S(B) are ultraﬁlters on B. We deﬁne a topology σ on
S(B) by letting the sets of the form
Fa = {f ∈S(B) : a ∈f}
(2.24)
for a ∈B to make a basis for open sets. Thus,
σ = {

{Fa : a ∈A} : A ⊆B}
(2.25)
We observe that Fa∧b = Fa ∩Fb hence indeed σ is a topology.
We consider an ultraﬁlter Φ on S(B) and along with it we look at the set
AΦ = {a ∈S(B) : Fa ∈Φ}
(2.26)
Then AΦ is a ﬁlter as Fa ⊆Fb when a ≤b and Fa∧b = Fa ∩Fb. Actually,
AΦ is an ultraﬁlter as, dually, for a ﬁlter G on B the family {Fa : a ∈G} is a
ﬁlter on S(B). We have duality
AΦ ∈Fa ↔a ∈AΦ ↔Fa ∈Φ
(2.27)
i.e., AΦ = limΦ. Thus any ultraﬁlter on S(B) converges proving this space
to be compact.
The compact space S(B) is called the Stone space, after Stone [24], of the
Boolean algebra B.
Let us observe that we have Fa = S(B) \Fa′ for each a thus proving that
each base set Fa is closed so ﬁnally it is clopen. It follows that the function
h : B →S(B) which satisﬁes already established conditions,
⎧
⎪
⎪
⎨
⎪
⎪
⎩
h(a ∧b) = h(a) ∩h(b)
h(a ∨b) = h(a) ∪h(b)
h(a′) = S(B) \ h(a)
(2.28)
does establish an isomorphism between B and CO(S(B)).Hence, each Boolean
algebra may be represented as a ﬁeld of clopen sets in a compact space with
a clopen base for open sets (such a space is called 0–dimensional).
One may ask about the Stone space in case of a complete Boolean alge-
bra, e.g., RO(X): does it have some additional properties? It turns out that

64
2 Topology of Concepts
completeness of the Boolean algebra B is rendered in Stone spaces by the
property of extremal disconnectedness: this means that closure of any open
set is open, in symbols, IntClIntA = ClIntA for each A ⊆S(B).
Proposition 2.26. For any complete Boolean algebra B, the Stone space
S(B) is extremally disconnected.
Proof. Consider U = {Ua : a ∈A}. For A ⊆B, there exists c = supA. Then
Ua ⊆Uc for each a ∈A so U ⊆Uc and thus ClU ⊆Uc. Assume f ∈Uc \ ClU
for some ultraﬁlter f. Then there exists Ub with f ∈Ub, Ub∩Ua = ∅for a ∈A.
It follows that a ∧b = 0 for a ∈A hence a ≤b′ for a ∈A implying that
supA = c ≤b′. But then f ∈Ub′, contradicting f ∈Ub. It follows that ClU =
Uc i.e. ClU is clopen
⊓⊔
This fact allows for a completion of a Boolean algebra via topological ar-
guments: given a Boolean algebra B, we have an isomorphism h : B →
CO(S(B)). Now, we embed CO(S(B)) into complete Boolean algebra
RO(S(B)) of regular open sets in the Stone space via identity embedding
i : A →A. The composition i ◦h embeds the algebra B into RO(S(B)).
Thus any Boolean algebra B has a completion B∗i.e. a complete Boolean
algebra into which it can be embedded as a dense set (it is so as any open
set contains a basic clopen set).
As the Stone space of a Boolean algebra is compact it does satisfy the Baire
theorem. A counterpart of this theorem was formulated in the language of
Boolean algebras as the Rasiowa–Sikorski theorem, Rasiowa and Sikorski [21],
cf., Ch.1, sect. 14
RS In any Boolean algebra B, given a countable sequence (An)n of dense
sets and 0 ̸= a ∈B, there exists an ultraﬁlter f with the properties that a ∈f
and f ∩An ̸= ∅for each n.
We translate the assumptions of RS into the language of topological spaces.
For each An, the set Wn = {Ua : a ∈An} is open dense in the Stone space
S(B). Hence the intersection W = {Wn : n ∈N} is a dense set by the
Baire theorem (Proposition 2.15) hence there exists f ∈W ∩Ua. This f is
as desired.
2.8
Continuity
To this point, we have been interested in the inner properties of topological
spaces, without any attempt to relate spaces one to another. In order to
compare or relate topological structures, we have to deﬁne an appropriate
type of functions or morphisms among topological spaces. Of such a morphism
we would require that it represents the topological structure of one space in
the other. It has turned out that proper morphisms in topological case are

2.8 Continuity
65
continuous functions. A function f : X →Y of a topological space (X, τ) into
a topological space (Y, σ) is said to be continuous if and only if the condition
f(ClA) ⊆Cl(f(A)) holds for every A ⊆X.
It does mean that f maps closures of subsets in X into closures of their
images in Y . It may be convenient to have some characterizations of conti-
nuity in terms of open or closed sets; to this end we have to look at inverse
images in X of sets in Y .
Proposition 2.27. For f : X →Y , the following are equivalent
1. f is continuous;
2. Clf −1(B) ⊆f −1(ClB) for every B ⊆Y ;
3. f −1(IntA) ⊆Intf −1(A) for every A ⊆Y ;
4. The set f −1(A) is open for each open set A ⊆Y ;
5. The set f −1(A) is closed for each closed set A ⊆Y .
Proof. Property 1 implies Property 2. In the condition f(ClA) ⊆Cl(f(A)),
we substitute f −1(B) for A so we get f(Clf −1(B)) ⊆Cl(B)) so Clf −1(B) ⊆
f −1(ClB), i.e., Property 2 holds. Assuming Property 2, we have f −1(IntA)
= f−1(Y \ Cl(Y \ A)) = X \ f −1(Cl(Y \ A)) ⊆X \ Clf −1(Y \ A) = X \
Cl(X \ f −1(A) = Intf −1(A), i.e., Property 3 follows from Property 2.
Now, Property 4 follows from Property 3 as in case A is an open set in Y
we have f −1(A) = f −1(IntA) ⊆Intf −1(A) hence f −1(A) ⊆Intf −1(A) so
f −1(A) = Intf −1(A), i.e., f −1(A) is open. Property 5 follows from Property
4 by duality.
Finally, assume property 5. We have for A ⊆X that A ⊆f −1(f(A)) hence
A ⊆f −1(Clf(A)). As the set f −1(Clf(A)) is closed by Property 5, we have
ClA ⊆f −1(Clf(A)) hence f(ClA) ⊆Clf(A), i.e., f is continuous
⊓⊔
In case f : X →Y is a bijection and f as well as f −1 are continuous, we say
that f is a homeomorphism of X onto Y .
A homeomorphism establishes a 1−1 correspondence between open sets in
X and open sets in Y via A →f(A) as well as between closed sets in either
space via the same assignment. Thus homeomorphic spaces are identical from
general topological point of view.
Let us ﬁnally observe that the characterization of continuity in case of
metric spaces X, Y may be given in terms of converging sequences. As x ∈
ClA if and only if x = limxn for a sequence (xn)n ⊆A, we may conjecture
that the condition f(limxn) = limf(xn) for any convergent sequence (xn)n ⊆
X is equivalent to continuity as it does guarantee that f(ClA) ⊆Cl(f(A))
for any A ⊆X.

66
2 Topology of Concepts
Proposition 2.28. For metric spaces X, Y , a function f : X →Y is con-
tinuous if and only if the condition
f(limxn) = limf(xn)
(2.29)
holds for any convergent sequence (xn)n ⊆X.
Proof. As already observed, the condition (2.29) implies continuity. If f is
continuous then for any convergent sequence (xn)n with x = limxn and
any open G ⊆Y with f(x) ∈G we have x ∈f −1(G) and as f −1(G) is
open, we have xn ∈f −1(G) hence f(xn) ∈G for almost every n i.e. f(x) =
limf(xn)
⊓⊔
In particular, any contracting map on a metric space X is continuous. An
equivalent characterization of continuity may be given in the ε −δ language
viz. f : (X, ρ) →(Y, η) is continuous at x ∈X if and only if
CONT for each ε > 0 there exists δ > 0 with the property that ρ(x, y) < δ
implies η(f(x), f(y)) < ε
and f is continuous if and only if CONT holds with every x ∈X.
2.9
Topologies on Subsets
Assume that (X, τ) is a topological space and A ⊆X. One may introduce a
topology on A in a natural way by declaring the natural injection i : A →
X a continuous function. This implies that for any open set G ⊆X, the
intersection A ∩G is open in A. Thus the family τA = {A ∩G : G ∈τ} is a
topology on A. Operators ClA of closure and IntA of interior with respect to
the topology τA are related to operators Cl, Int with respect to the topology
τ as described below
Proposition 2.29. For any subset Y ⊆A,
1. ClAY = A ∩ClY .
2. A ∩IntY ⊆IntAY .
Proof. For 1., clearly ClAY ⊆A ∩ClY as the latter set is closed in A.
Conversely, for x ∈A ∩ClY , we have that A ∩(G ∩Y ) = (A ∩G) ∩Y ̸= ∅
hence x ∈ClAY as A ∩G runs over open neighborhoods of x in A. In case of
2., as A ∩IntY is open in A we have A ∩IntY ⊆IntAY
⊓⊔
The converse to Property 2 does not need hold.

2.10 Quotient Spaces
67
2.10
Quotient Spaces
We now examine how a topology may be induced on a quotient set X/R for an
equivalence relation R on X. Let us assume that (X, τ) is a topological space
and R an equivalence relation on X. We deﬁne a topology on the quotient
set X/R of equivalence classes by requiring that the quotient function qR :
X →X/R be continuous. This means that for each open set G ⊆X/R
the inverse image q−1
R (G) =  G should be open in X. Thus we deﬁne the
quotient topology τR on X/R by letting
τR = {G ⊆X/R :

G ∈τ}
Then we have
Proposition 2.30. The following are true for each quotient topology
1. If f : X →Y is a continuous function deﬁned on a space X with an
equivalence relation R into a space Y with an equivalence relation S and
xRy implies f(x)Sf(y) then f : X/R →Y/S deﬁned as f[x]R = [f(x)]S
is continuous;
2. If R, S are equivalence relations on X with S ⊆R then the quotient spaces
(X/S)/(R/S) and X/R are homeomorphic.
Proof. In case of Property 1, for an open in Y/S set P of equivalence classes
of S we have q−1
R (f
−1(P)) = f −1(q−1
S (P) and as the latter set is open it
follows that q−1
R (f
−1(P)) is an open set in X hence f
−1(P) is open in X/R
witnessing that f is continuous.
For Property 2, we consider the function q : (X/S)/(R/S) →X/R deﬁned
by letting q([[x]S]R/S) = [x]R. Then q is a bijection and q is continuous: for
any open P ⊆X/R we have
q−1
S (q−1
R/S(q−1(P))) = q−1
R (P)
(2.30)
and the latter set is open in X hence q−1
S (q−1
R/S(q−1(P))) is open and ﬁnally
q−1(P) is open witnessing continuity of q. We have to prove that q−1 is
continuous which amounts to showing that q is an open function i.e. the
image q(Q) is open in X/R for each open in (X/S)/(R/S) set Q. As we have
q−1
R (q(Q)) = q−1
S (q−1
R/S(Q)
(2.31)
and the latter set is open, it follows that q−1
R (q(Q)) is open i.e. q(Q) is open
in X/R. Thus q is a homeomorphism
⊓⊔

68
2 Topology of Concepts
2.11
Hyperspaces
In many applications, e.g., in morphology, control theory, mathematical econ-
omy and game theory we have to consider spaces whose points are subsets
in some underlying space, see Michael [15]. Then we say of hyperspaces. The
problem of inducing topologies on such new spaces will be our subject in this
section. Consider a topological space (X, τ) and a family F of subsets of X.
It is our aim to deﬁne a topology on F related to the topology τ.
In order to do this, we consider subsets of F of the form C(P, V) where
C(P, V) = {A ∈F : A ⊆P ∧∀V ∈V(A ∩V ̸= ∅)}
(2.32)
Let us observe that
C(P, V) ∩C(Q, W) = C(P ∩Q, V ∪W)
(2.33)
hence, if P, Q come from a family of subsets of X having the ﬁnite intersection
property and V, W are sub–families of a family of sets in X closed on arbitrary
unions then sets of the form C(P, V) have the ﬁnite intersection property and
may be taken as a basis for open sets for a topology on F. Clearly, the family
O (X) of open sets in X poses itself as a candidate from whom sets P as well
as elements of V could be taken.
Accepting that candidate we arrive at the Vietoris topology, after Vietoris
[26], known in applications also as the hit–or–miss topology on F induced by
an open base consisting of sets of the form C(P, V) where P is an open set
in X and V is a ﬁnite collection of open sets in X. Although the collection
F may in principle consist of arbitrary sets in X yet the most important
cases are when F is the family of all closed sets in X or it is the family of all
compact sets in X.
We will look at topologies on closed subsets of X.
2.11.1
Topologies on Closed Sets
The hit–or–miss topology, see Polkowski [19] for a brief survey, on the family
κ(X) of closed sets in X is generated by the collection of sets of the form
C(P, V), where P is open and V is a ﬁnite collection of open sets, taken
as an open basis hence each open set is of the form 
i∈I C(Pi, V i). It is
most important for applications to determine the case when this topology is
metrizable, i.e., when it is identical to a metric topology induced by some
metric.
We consider a metric space (X, ρ). We assume that ρ is bounded by 1,
i.e., ρ(x, y) = min{1, ρ(x, y)}; as we already know this has no impact on the
induced metric topology. Now, we deﬁne a metric δρ on closed sets, called the
Hausdorﬀ–Pomp´e¨ıu metric, see Hausdorﬀ[12], Pomp´e¨ıu [20]. For two closed
sets M, N in X, we calculate subsequently the following

2.11 Hyperspaces
69
1. For each x ∈M, we compute distρ(x, N) = inf{ρ(x, y) : y ∈N} called
the distance from x to N;
2. We compute sup{ρ(x, N) : x ∈M};
3. For each y ∈N, we compute distρ(y, M) = inf{ρ(x, y) : x ∈M} (the
distance from y to M);
4. We compute sup{ρ(y, M) : y ∈N};
5. We let δρ(M, N) = max{sup{ρ(x, N) : x ∈M}, sup{ρ(y, M) : y ∈N}}.
The function δρ is deﬁned for all pairs M, N of closed sets due to our as-
sumption that the metric ρ is bounded. We should check that δρ is a metric.
It is manifest that

δρ(M, N) = 0 ⇔M = N
δρ(M, N) = δρ(N, M)
(2.34)
so it remains to prove only that the triangle inequality holds for δρ.
Consider closed sets M, R, N; we are going to prove that
δρ(M, N) ≤δρ(M, R) + δρ(R, N)
(2.35)
For x ∈M, y ∈N, we have by the triangle inequality that
ρ(x, y) ≤ρ(x, r) + ρ(r, y)
(2.36)
for any r ∈R. Taking inﬁma with respect to r gives us
ρ(x, y) ≤dist(x, R) + dist(y, R) ≤δρ(M, R) + δρ(R, N)
(2.37)
whence
sup{ρ(x, N) : x ∈M} ≤δρ(M, R) + δρ(R, N)
(2.38)
follows. By symmetry, we get
sup{ρ(y, M) : y ∈N} ≤δρ(M, R) + δρ(R, N)
(2.39)
and from the last two inequalities (2.35) follows. Thus δρ is a metric, indeed.
It turns out that in case of a compact metric space the two topologies:
the hit–or–miss topology and the metric topology induced by the Hausdorﬀ–
Pomp´e¨ıu metric, coincide. We prove this important fact.
Proposition 2.31. For each compact metric space (X, ρ), the hit–or–miss
topology coincides with the metric topology induced by the Hausdorﬀ–Pomp´e¨ıu
metric.
Proof. Consider a basic open set C(P, V) in the hit–or–miss topology where
V = {V1, .., Vk} along with M ∈C(P, V), M a closed set. As M ⊆P, the

70
2 Topology of Concepts
closed sets M, X \ P are disjoint. Hence, by compactness of X, there exists
ε > 0 such that
ρ(x, y) > ε
(2.40)
for any x ∈X, y ∈Y . Letting
B(M, ε) = {x ∈X : dist(x, M) < ε}
(2.41)
we have that B(M, ε) ⊆P. Similarly, as M ∩Vi ̸= ∅for i = 1, 2.., k there
exist x1, .., xk with xi ∈M ∩Vi each i ≤k and for each xi we may ﬁnd εi > 0
with
B(xi, εi) ⊆Vi
(2.42)
for each i ≤k.
Let ε0 = min{ε, ε1, ..., εk} and consider a closed set N with
δρ(M, N) < ε0
(2.43)
Then N ⊆B(M, ε) hence N ⊆P; also, for each i ≤k, we ﬁnd yi ∈N with
ρ(xi, yi) < εi implying N ∩Vi ̸= ∅. It follows that N ∈C(P, V) hence
Bδρ(M, ε0) ⊆C(P, V)
(2.44)
which does imply that C(P, V) is open in the metric topology of δρ.
For the converse, consider an open ball Bδρ(M, ε) along with the set P =
B(M, ε) which is open in the topology of X. For any closed N ⊆P we have
clearly dist(y, M) < ε for each y ∈N which settles one half of the condition
for δρ < ε. To settle the other half, i.e. to assure that dist(x, N) < ε for
x ∈X, let us take in M an ε/2–net i.e. a set x1, ..., xm with the property
that for any x ∈M we ﬁnd xi such that ρ(x, xi) < ε/2.
Letting Vi = B(xi, ε/2) for i ≤k we observe that if N ∩Vi ̸= ∅
for each i ≤k then dist(x, N) < ε for each x ∈M. Thus for every
N ∈C(P, {V1, V2, .., Vk}) we have,
δρ(M, N) < ε
(2.45)
i.e.,
C(P, {V1, V2, .., Vk}) ⊆Bδρ(M, ε)
(2.46)
proving that basic sets in the metric topology are open in the hit–or–miss
topology thus showing both topologies to be identical and concluding the
proof
⊓⊔
This result tells us that the topology induced by the Hausdorﬀ–Pomp´e¨ıu
metric is in fact independent of the metric on X in case X is metric compact.
As we know, a weaker but very important and useful substitute of com-
pactness is completeness. It turns out that in case (X, ρ) is a complete metric
space, the space of closed sets in X with the Hausdorﬀ–Pomp´e¨ıu metric is

2.11 Hyperspaces
71
complete as well. To discuss this fact, we need some new notions related to
sequences of sets.
For a sequence (An)n of sets in X, we deﬁne the lower limit LiAn of this
sequence by letting,
LiAn = {x ∈X : limdist(x, An) = 0}
i.e., x ∈LiAn if and only if for each ball B(x, ε) we have
B(x, ε) ∩An ̸= ∅
(2.47)
for all but ﬁnitely many An, i.e., if and only if every neighborhood of x does
intersect almost all sets An. Let us observe that LiAn is a closed set: indeed,
if y /∈LiAn then some neighborhood P ∋y misses inﬁnitely many An’s and
then clearly P ∩LiAn = ∅.
Similarly, we deﬁne the upper limit LsAn of the sequence (An)n as
LsAn = {x ∈X : liminfdist(x, An) = 0}
i.e., x ∈LsAn if and only if limdist(x, Ank) = 0 for a subsequence (Ank)k,
i.e., if and only if every neighborhood of x does intersect inﬁnitely many An’s.
As with LiAn, the upper limit LsAn is a closed set which may be shown by
the same argument. It follows immediately that LiAn ⊆LsAn.
In case LiAn = LsAn, we say that the sequence (An)n converges to the
limit LimAn = LiAn = LsAn. Now, we turn to the completeness property.
Let us ﬁrst observe that in case a sequence (An)n converges in the metric
δρ, i.e.,
limδρ(An, B) = 0
(2.48)
for some closed set B, we have B = LimAn.
Indeed, given ε > 0, there is nε ∈N with An ⊆B(B, ε) for n ≥nε.
Hence, for each x ∈B we have B(x, ε) ∩An ̸= ∅for n ≥nε. It follows that
B ⊆LiAn. On the other hand, given x ∈LsAn, we may deﬁne inductively
a sequence (ank)k with ank ∈Ank and x = limank. Passing eventually to a
subsequence, in virtue of (2.48), we have ρ(ank, bk) < 1/k with some bk ∈B
for each k. Thus x = limbk hence x ∈B and ﬁnally LsAn ⊆B. Therefore
B = LimAn.
Proposition 2.32. (Hahn [11]) For a complete metric space (X, ρ), the space
C(X) of closed sets in X with the Hausdorﬀ–Pomp´e¨ıu metric δρ is complete.
Proof. Assume (An)n is a fundamental sequence with respect to δρ. Once
we exhibit B with (2.48) we have B = LimAn. It is the easiest to consider
B = LsAn. Given ε > 0, we have n(ε) such that,
δρ(An(ε), An) < ε
(2.49)

72
2 Topology of Concepts
for n ≥n(ε). We consider x ∈LsAn. Then B(x, ε) intersects inﬁnitely many
An’s hence for some n > n(ε) and some y ∈An we have ρ(x, y) < ε and thus
dist(x, An) < ε. By (2.48), we have,
dist(x, An(ε)) ≤2 · ε
(2.50)
hence,
supxdist(x, An(ε)) ≤2 · ε
(2.51)
On the other hand, for z ∈An(ε), we may ﬁnd a sequence (znk)k with
⎧
⎪
⎪
⎨
⎪
⎪
⎩
(i) znk ∈Ank
(ii) nk > n(ε)
(iii) ρ(znk, znk+1) < 1/2k · ε
(2.52)
This sequence may be deﬁned by induction as (An)n is a fundamental se-
quence. As the sequence (znk)k is fundamental with respect to ρ, there exists
w = limznk. Clearly, w ∈LsAn and ρ(z, w) ≤2 · ε, hence,

(iv) dist(z, LsAn) ≤2 · ε
(v) supz{dist(z, LsAn)} ≤2 · ε
(2.53)
Hence,
δρ(An(ε), LsAn) ≤2 · ε
(2.54)
and, by the triangle inequality, we have
δρ(An, LsAn) ≤3 · ε for n > n(ε)
(2.55)
This proves that limδρ(An, LsAn) = 0. Hence (An)n converges to LsAn =
LimAn. Completeness of the space (C(X), δρ) has been established
⊓⊔
We comment also on the status of continuous mappings of the form f : X →
2Y from a topological space X into the space of closed subsets of the space
Y endowed with the Vietoris topology. Clearly, the continuity condition of f
is
Proposition 2.33. A mapping f : X →2Y is continuous if and only if the
set {x ∈X : f(x) ⊆P, f(x) ∩Vi ̸= ∅}, for i = 1, 2, ..., k, is open in X for
each open basic set C(P, V1, ..., Vk) in the space 2Y .
The continuity notion ramiﬁes for multi–valued mappings into two weaker
semi–continuity notions, viz., a mapping f : X →2Y is upper–semicontinuous
if and only if the set {x ∈X : f(x) ⊆P} is open in X for each open set P in
Y .
A mapping f : X →2Y is lower–semicontinuous if and only if the set
{x ∈X : f(x) ∩V ̸= ∅} is open in X for each open set V in Y .

2.12 ˇCech Topologies
73
2.12
ˇCech Topologies
In many cases that arise in real problems, we have to deal with a weaker
form of topology. Such situation, for instance, takes place when we try to
deﬁne closure operator with respect not to the full family of open sets but
with respect to a certain sub–family, e.g., a covering of a space. Assume that
we are given a covering U of a set X and for each A ⊆X, we let
ClcA = {x ∈X : ∀G ∈U(x ∈G ⇒G ∩A ̸= ∅)}
We state properties of the operator Clc
Proposition 2.34. The operator Clc does satisfy the following properties
1. Clc∅= ∅;
2. A ⊆ClcA for each A ⊆X;
3. A ⊆B ⇒ClcA ⊆ClcB for each pair A, B of subsets of X.
All these properties follow immediately from the deﬁnition of Clc. Let
us observe that the operator Clc does not need to observe the proper-
ties of topological closure operator, notably, in general the properties that
Clc(A ∪B) = ClcA ∪ClcB and ClcClcA = ClcA do not hold and are re-
placed by weaker consequences of 1-3, viz.,
4. Clc(A ∩B) ⊆ClcA ∩ClcB;
5. ClcA ∪ClcB ⊆Clc(A ∪B);
6. ClcA ⊆ClcClcA.
We will call the operator Clc satisfying 1-3, a fortiori also 4–6, the ˇCech
closure operator, see ˇCech [7]. A most important case when a ˇCech closure
operator does arise is that of a tolerance relation when we consider, e.g., a
covering formed by tolerance sets of the form τ(x) = {y ∈X : xτy}. We
denote by T (τ) the set of all tolerance sets of τ. Then for any A ⊆X, we
have,
ClcA = {x ∈X : ∀T ∈T (τ)(x ∈T ⇒T ∩A ̸= ∅)}
(2.56)
The ˇCech topology generated by the ˇCech closure operator is the family of all
open sets with respect to Clc, viz., we declare a set A ⊆X to be closed in case
ClcA = A and we declare a set A ⊆X to be open in case the complement
X \ A is a closed set. Then we have

74
2 Topology of Concepts
Proposition 2.35. In any ˇCech topological space
1. Each intersection of a family of closed sets is a closed set;
2. Each union of a family of open sets is an open set.
Proof. Assume that F is a family of closed sets in a ˇCech topological space X.
Let K =  F. As K ⊆F for any F ∈F, we have ClcK ⊆ClcF = F for any
F ∈F hence ClcK ⊆K and ﬁnally ClcK = K i.e. K is closed. Property 2.
follows immediately by duality
⊓⊔
We now conﬁne ourselves to ˇCech topologies generated from coverings by
tolerance sets in the way described above. We may observe that
⎧
⎪
⎪
⎨
⎪
⎪
⎩
(i) ClcA need not be a closed set
(ii) Clc(A ∩B) ⊆ClcA ∩ClcB
(iii) ClcA ∪ClcB ⊆Clc(A ∪B)
(2.57)
hold but converse statements to (ii), (iii) need not hold.
We may characterize ClcA via open sets as in case of topological spaces.
For a point x ∈X, we say that a set Q ⊆X is a neighborhood of x if and
only if x /∈Clc(X \ Q). Clearly, x ∈Q. Then, we have
Proposition 2.36. For x ∈X, x ∈ClcA if and only if Q ∩A ̸= ∅for each
neighborhood Q of x.
Proof. If for some neighborhood Q of x we have Q ∩A = ∅, then A ⊆X \ Q
and we have ClcA ⊆Clc(X \ Q) hence x /∈ClcA. Thus, x ∈ClcA implies
Q∩A ̸= ∅for any neighborhood Q of x. On the other hand, x /∈ClcA implies
x /∈Clc(X \ (X \ A) hence X \ A is a neighborhood of x disjoint to A
⊓⊔
Let us consider a sequence of closure operators (Cln
c )n deﬁned recurrently for
any A ⊆X by

Cl0
cA = A
Cln+1
c
A = Clc(Cln
c A) for n ≥1
(2.58)
For any A ⊆X, we have
Cl0
cA = A ⊆ClcA ⊆... ⊆Cln
c A ⊆Cln+1
c
A ⊆....
(2.59)
In our setting of a tolerance relation, subsequent values Cln
c A correspond
to saturation of A with tolerance sets: S0A = A, Sn+1A = S(SnA) where
SA = {τ(x) : τ(x) ∩A ̸= ∅}, i.e., we have Cln
c A = SnA, any n.
Let us deﬁne the closure operator Cl∗by letting
Cl∗A =

{Cln
c A : n ∈N}
Then, we have

2.12 ˇCech Topologies
75
Proposition 2.37. For any tolerance relation τ on a set X, Cl∗A is a topo-
logical closure operator. Moreover, Cl∗is identical to the ˇCech closure opera-
tor induced by the equivalence relation τ, the transitive closure of the relation
τ.
Proof. Clearly, Cl∗∅= ∅, A ⊆Cl∗A hold by deﬁnition of Cl∗. To proceed
further we observe that,
(i) x ∈Cl∗A if and only if there is a ﬁnite sequence x0 ∈A, x1, ..., xk = x
with
xiτxi+1 for i = 0, 1, ..., k −1
(2.60)
and we assume that x ∈Cl∗Cl∗A. Then there is a ﬁnite sequence y0 ∈Cl∗A,
y1, ..., ym = x for some m ∈N with yiτyi+1 for i = 0, .., m −1 and thus
we have a sequence z0 ∈A, z1, ..., zp = y0 for some p ∈N with ziτzi+1
for i = 0, ..., p −1. It follows that x ∈Clm+p
c
A hence x ∈Cl∗A. Thus,
Cl∗Cl∗A ⊆Cl∗A and ﬁnally Cl∗Cl∗A = Cl∗A.
It remains to prove that Cl∗A∪Cl∗B = Cl∗(A∪B). Clearly, Cl∗A∪Cl∗B ⊆
Cl∗(A ∪B). Assume that x ∈Cl∗(A ∪B) hence there is a sequence
x0 ∈A ∪B, x1, ..., xk = x with xiτxi+1 for i = 0, 1, ..., k −1. Then ei-
ther x0 ∈A or x0 ∈B; in the former case, x ∈Cl∗A and in the latter case
x ∈Cl∗B. Thus Cl∗(A ∪B) ⊆Cl∗A ∪Cl∗B and ﬁnally the equality of both
sides follows
⊓⊔
We have proved that Cl∗is a topological closure operator. For the second
part of the proposition, indeed, we have x ∈Cl∗A if and only if A ∩τ(x) ̸= ∅
i.e. the closure operator Cl∗and the ˇCech closure operator Clτ coincide.
Remaining for a while with the case of an equivalence relation, we may
observe that in that case the tolerance sets are equivalence classes, and the
resulting ˇCech topology is a topology induced by taking the set of equivalence
classes as an open basis for this topology. Thus, any open set is a union of a
family of equivalence classes a fortiori any closed set is a union of a family of
equivalence classes. Hence, in this topology, any open set is closed as well (we
call such topology a clopen topology). Moreover, any intersection of a family
of open sets is an open set.Let us observe that, conversely, given any clopen
topology with the property that the intersection of any family of open sets
is an open set, we may introduce an equivalence relation which induces this
topology: it is suﬃcient to let xRy if and only if x and y belong in the same
open sets, i.e.,
xRy ↔∀Q = IntQ(x ∈Q ↔y ∈Q)
It follows that each equivalence class [x]R is the intersection of all open sets
containing x hence it is clopen. Clearly, any open set Q is the union of the
equivalence classes [x]R for x ∈Q.

76
2 Topology of Concepts
Proposition 2.38. The ˇCech topology is generated by the set of equivalence
classes of an equivalence relation if and only if
(ii) any open set is closed
(iii) the intersection of each family of open sets is an open set
An analysis of clopen topologies induced by indiscernibility relations in in-
formation systems, see Ch. 4, is given in Skowron [23]; in Wiweger [27],
topological calculus is applied to characterize sets which are not clopen in
this context. Analysis of topological properties of rough sets can be found
in Polkowski [16]–[18], cf., Ch. 4. Readers wishing to extend for themselves
the outline of topology of concepts given here may be advised to consult
Engelking [8] or Kuratowski [14].

References
1. Alexandrov, P.S.: Zur Begr¨undung der n–dimensionalen mengentheoretischen
Topologie. Math. Ann. 94, 296–308 (1925)
2. Alexandrov, P.S., Urysohn, P.S.: M´emoire sur les espaces topologiques com-
pacts. Verh. Konink. Akad. Amsterdam 14 (1929)
3. Baire, R.: Ann. di Math. 3 (1899)
4. Banach, S.: Sur les op´erations dans les ensembles abstraits et leur application
aux ´equations int´egrales. Fundamenta Mathematicae 3, 133–181 (1922)
5. Cantor, G.: Math. Ann. 17 (1880)
6. Cantor, G.: Math. Ann. 21 (1883)
7. ˇCech, E.: Topologick´e prostory. In: ˇCech, E., Frolik, Z. (eds.) Topological
Spaces. Academia, Praha (1966)
8. Engelking, R.: An Outline of General Topology. North–Holland, PWN–Polish
Scientiﬁc Publishers, Amsterdam–Warszawa (1965)
9. Fr´echet, M.: Sur quelques points du Calcul fonctionnel. Rend. Circ. Matem. di
Palermo 22 (1906)
10. Fr´echet, M.: Les espaces abstraits, Paris (1928)
11. Hahn, H.: Reelle Funktionen I. Leipzig (1932)
12. Hausdorﬀ, F.: Grundz¨uge der Mengenlehre (1914); von Veit, Leipzig, Hausdorﬀ
F.: Set Theory. Chelsea, New York (1965)
13. Kuratowski, C.: Sur l’operation ¯A de l’Analysis Situs. Fundamenta Mathemat-
icae 3, 182–199 (1922)
14. Kuratowski, C.: Topology I, II. Academic Press – Polish Scientiﬁc Publishers
(PWN), New York – Warszawa (1966)
15. Michael, E.: Topologies on spaces of subsets. Trans. Amer. Math. Soc. 71, 152–
182 (1951)
16. Polkowski, L.T.: On convergence of rough sets. In: Slowi´nski, R. (ed.) Intelli-
gent Decision Support. Handbook of Applications and Advances of Rough Sets
Theory. Kluwer, Dordrecht (1992)
17. Polkowski, L.T.: Mathematical morphology of rough sets. Bull. Pol. Ac.:
Math. 41(3), 241–273 (1993)
18. Polkowski, L.T.: Metric spaces of topological rough sets from countable knowl-
edge bases. Foundations of Computing and Decision Sciences 18, 293–306 (1993)
19. Polkowski, L.T.: Hit–or–miss topology. In: Hazewinkel, M. (ed.) Encyclopaedia
of Mathematics. Supplement 1, p. 293. Kluwer, Dordrecht (1998)
20. Pomp´e¨ıu, D.: Ann. de Toulouse 7 (1905)
21. Rasiowa, H., Sikorski, R.: A proof of the completeness theorem of G¨odel. Fun-
damenta Mathematicae 37, 193–200 (1950)

78
References
22. Riesz, F.: Stetigskeitbegriﬀund abstrakte Mengenlehre. Atti IV Congr. Int.
Mat., Rome (1909)
23. Skowron, A.: On topology in information systems. Bull. Pol. Ac.: Math. 36,
477–479 (1988)
24. Stone, M.H.: The theory of representations for Boolean algebras. Trans. Amer.
Math. Soc. 40, 37–111 (1936)
25. Tikhonov, A.N.: ¨Uber einen Funktionenraum. Math. Ann. 111 (1935)
26. Vietoris, L.: Monat. Math. Ph. 31, 173–204 (1921)
27. Wiweger, A.: On topological rough sets. Bull. Pol. Ac.: Math. 37, 89–93 (1988)

Chapter 3
Reasoning Patterns of Deductive
Reasoning
Processes of reasoning are divided into two main types: deductive and reduc-
tive. Deductive reasoning begins with a set of premises and concludes with a
set of inferences obtained by speciﬁed rules of deduction, whereas reductive
reasoning tries to obtain a set of premises/causes for an observed set of facts.
In this chapter, we present the reader with some basic schemes of deductive
reasoning. We begin with sentential calculus (propositional logic) which sets
the pattern of deductive reasoning and then we discuss many–valued propo-
sitional calculi, predicate calculus, and modal calculi. Analysis of these types
of reasoning results in notions which are relevant also for reductive types of
reasoning, in particular, for rough and fuzzy types of reasoning discussed in
the next chapter as examples of reductive reasoning.
3.1
The Nature of Exact Reasoning
Reasoning processes (logics) are divided into two classes: deductive and re-
ductive reasoning, see Boche´nski [9], Lukasiewicz [30]. Logics implementing
deductive reasoning, proceed with inference from premises to a conclusion
according to a scheme: if premises p, p ⇒q, then the conclusion q. The other
type of reasoning, the reductive reasoning, carries inference from conclusions
to a set of plausible premises, according to a scheme: if p ⇒q and q, then p.
As pointed to by Lukasiewicz, reductive reasoning does encompass inductive
reasoning, i.e., inference about the general property of a class from behav-
ior of a sample from the class, a generalization of evidence to a hypothesis
about a population. Clearly, whereas deductive reasoning is exact, reductive
reasoning is more intuitive.
Deductive reasoning in its formalized version, is a process by which a
certain deﬁnite set of conclusions is reached from a set of certain premises in a
formalized manner, by means of a priori speciﬁed reasoning rules. All patterns
of deductive reasoning are modeled after, or are modiﬁcations of, the classical
reasoning with sentences, initiated with the Stoic school of Athens, ca. III–th
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 79–143.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

80
3 Reasoning Patterns of Deductive Reasoning
century B.C., cf., Boche´nski [3] and initially developed in the modern form
in works of Frege [9] and Post [39].
Calculus of sentences had been extended to the 1st–order calculus, initiated
by Frege [9], many–valued calculi, see Lukasiewicz [30]–[28], including fuzzy
calculi, see, e.g., H´ajek [17].
In what follows, we give a nutshell account of these calculi in order to bring
together pieces of knowledge scattered through various sources and to give
the reader a perspective on this classical subject.
3.2
Propositional Calculus
We begin with a discussion of the basic tool of mathematical reasoning: propo-
sitional calculus. By a proposition, sentence we mean any statement about
reality of interest to us whose truth value can be established with certainty.
By a truth value of a proposition, we understand either of two possible values:
truth (T or 1), falsity (F or 0). A proposition p may be therefore either true or
false and exactly one of the two possibilities actually holds for p. For instance,
the statement ”if today is Monday then tomorrow is Tuesday” is according
to our best knowledge true while the statement of ordinary arithmetic ” 2+2
= 3” is false.
Sentential calculus deals with propositions considered in their symbolic
form: there is no reason to consider all possible propositions (apart from
the real possibility of listing all of them); instead, the aim of the theory
of sentential calculus is to reveal all properties of this system which hold
regardless of the nature of statements considered, i.e., which depend only on
truth values of these statements (one says also that such properties are truth
functional). Thus, we consider, instead of actual propositions, propositional
variables p, q, r, s, t, ... ranging over propositions and we aim at establishing
general properties of the sentential calculus which are preserved when we
substitute for any of variables p, q, r, ... a speciﬁc proposition.
As with any language, in propositional calculus we may construct complex
expressions from simpler ones. Passing from simpler to more complex propo-
sitions is eﬀected by means of proposition–forming functors (or, functors,
shortly). In propositional calculus we have four basic functors with which to
form more complex expressions. Let us look at them now.
The functor of negation denoted N or ¬ is a unary functor acting on single
propositions: for a proposition p, the expression Np (or, ¬p) is a proposition.
To describe fully the action of N on propositions, we must describe its se-
mantic impact, thus we have to give truth values of Np for respective values
of p. So, we let Np = 0 when p = 1 and Np = 1 when p = 0.Thus, Np is
true if and only if p is false. The proposition Np is read: ”it is not true that
p” or, shortly, ”not p”. To give a concise description of the semantic content
of the functor N, we use the following conditions

3.2 Propositional Calculus
81

N0 = 1
N1 = 0
(3.1)
The binary functor of alternation,disjunction denoted OR (or, ∨) acts on
pairs of propositions p, q to produce the proposition ORpq (denoted also
pORq, p ∨q; the proposition p ∨q is read: either p or q. Truth functional
description of ∨is given by the following conditions
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
0 ∨0 = 0
0 ∨1 = 1
1 ∨0 = 1
1 ∨1 = 1
(3.2)
It follows that p∨q is true if and only if at least one of p, q is a true proposition.
The binary functor AND of conjunction (denoted also ∧) acts on pairs
p, q to produce the expression ANDpq (denoted also p ∧q). The following
conditions determine the semantics of ∧.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
0 ∧0 = 0
0 ∧1 = 0
1 ∧0 = 0
1 ∧1 = 1
(3.3)
Hence, the proposition p ∧q is true if and only if each of propositions p, q is
true.
The binary functor of implication C (denoted also ⇒) acts on pairs p, q of
propositions to form the proposition p ⇒q deﬁned as follows
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
0 ⇒0 = 1
0 ⇒1 = 1
1 ⇒0 = 0
1 ⇒1 = 1
(3.4)
We may now introduce the notion of a meaningful expression(a formula) of
propositional calculus by stating that
1. Each propositional variable is a meaningful expression;
2. Nα is a meaningful expression whenever α is a meaningful expression;

82
3 Reasoning Patterns of Deductive Reasoning
3. Expressions α ∨β, α ∧β, α ⇒βare meaningful when α, β are meaningful
expressions;
4. No expression other than obtained from 1–3 is a meaningful expression.
Hence, the meaningful expressions are the least set containing all proposi-
tional variables and closed under propositional functors ¬, ⇒, ∨, ∧.
We will be interested from now on in meaningful expressions formed in
accordance with the rules given in this paragraph. For a meaningful expres-
sion α, we will sometimes write down α in the form α(p1, p2, ..., pk) to denote
the fact that propositional variables occurring in α are exactly p1, p2, ..., pk.
Clearly, any meaningful expression α(p1, p2, ..., pk) takes a truth value either
0 or 1 on assuming that each of pi (i = 1, 2, ..., k) takes a truth value 0 or 1 (a
simple proof may be done by induction on number of connectives in α). Thus
α(p1, p2, ..., pk) induces a mapping (a Boolean function) fα : 2k →{0, 1}.
For instance, the meaningful expression ¬p ⇒q takes the value 0 for
p = 0 = q, the value 1 for p = 0, q = 1, the value 1 for p = 1, q = 0 and the
value 1 for p = 1, q = 1.
We will say that two meaningful expressions α, β are equivalent when they
take the same truth value for each substitution of the same truth values for
equiform propositional variables occurring in them. To give an important
example, we observe that
Proposition 3.1. The following expressions are equivalent
1. Meaningful expressions p ∨q, ¬p ⇒q are equivalent;
2. Meaningful expressions p ∧q, ¬(p ⇒¬q) are equivalent.
Proof. To verify this proposition, it is suﬃcient to compare truth values of
both expressions for each substitution of truth values for p, q.
We will call a tautology of the sentential calculus any meaningful expres-
sion α(p1, ..., pk) with the property that the truth value of α is 1 for every
substitution of truth values for p1, ..., pk.
We will write α ⇔β in case α, β are equivalent meaningful expressions
⊓⊔
Let us derive two important observations from the above proof.
1. For any meaningful expression α, the truth value of α for any substitution
of truth values of propositional variables in α may be checked in a ﬁnite
number of steps. In particular, it may be checked in a ﬁnite number of steps
whether α is a tautology of propositional calculus, i.e., the truth value of α
is 1 for any substitution of truth values for propositional variables in α;

3.2 Propositional Calculus
83
2. Connectives ∨and ∧may be deﬁned by means of connectives ⇒, ¬: in any
meaningful expression, p ∨q may be replaced with ¬p ⇒q and
p ∧q
may be replaced with ¬(p ⇒¬q) without any eﬀect on the truth value
of that expression. It follows that in forming meaningful expressions of
propositional calculus, we may apply connectives ⇒, ¬ only.
When discussing meaningful expressions of propositional calculus, we are in-
terested above all in tautologies of this calculus, i.e., as deﬁned above, in
expressions which are true regardless of truth values of propositional vari-
ables that occur in these expressions. The reason for this lies primarily in
the fact that tautologies of propositional calculus may be regarded as laws
of thought leading always to valid (true) conclusions regardless of truth val-
ues of premises (i.e., propositional variables or propositions substituted for
them). The notion of a tautology is a semantic one, relying on our checking
of truth values. On the other hand, we have deﬁned a syntactic mechanism
for generating meaningful expressions. The importance of relations between
the syntactic and semantic aspects of propositional calculus had been fully
recognized in Frege [9].
It had been his idea to distinguish between meaningful expressions and
derivation rules, i.e., rules for forming new meaningful expressions from given
ones. The Frege program assumed the existence of certain apriorical expres-
sions called axioms and the existence of certain rules by means of which
meaningful expressions may be derived from axioms. Accepted axioms and
derivation rules constitute a deduction system for propositional calculus and
deﬁne the consequence relation for this system, see Rasiowa and Sikorski,
see [42], p. 151. Meaningful expressions derived from axioms by means of
speciﬁed rules are called theorems of the system.
Clearly, in our choice of axioms and derivation rules, we are guided by
certain constraints. Above all, we would like to invent axioms and rules of
derivation which would give as theorems of the system all tautologies of
propositional calculus; also, we would like to have the situation when all
tautologies of propositional calculus are theorems of our system. When both
constraints are met, we have the case when syntactic and semantic aspects
of propositional calculus are mutually expressible: theorems of the deductive
system = tautologies of propositional calculus.
Many axiom systems for sentential calculus were proposed by various
authors.
The axioms proposed by Jan Lukasiewicz, see [30], are the following
T1 (p ⇒q) ⇒[(q ⇒r) ⇒(p ⇒r)]
T2 (¬p ⇒p) ⇒p
T3 p ⇒(¬p ⇒q)

84
3 Reasoning Patterns of Deductive Reasoning
As the derivation rule, the detachment (or, modus ponens, MP) is applied,
which consists in the following
Detachment, MP For any pair of meaningful expressions α, β, if α and
α ⇒β are theorems of the system, then β is a theorem of the system.
We also allow substitution, i.e., in a meaningful formula, in place of each
occurrence of a variable, a meaningful expression α can be substituted.
Thus, axiom formulas given here are in fact, axiom schemes, as in each of
them, a substitution can be eﬀected leading to an axiom instance.
Given axioms and the derivation rule, one may derive from axioms new
theorems of the system. We will give a formal deﬁnition of a derivation (a
proof) of a theorem.
For a meaningful expression α, a derivation of α from axioms is a sequence
α0, α1, .., αn
of meaningful expressions such that
1. α0 is an axiom;
2. αn is equiform with α;
3. Each αi for i = 1, 2, ..., n either is obtained from some αj, αk with j, k < i
by means of detachment or αi is an axiom, or αi is obtained by substitution
from some αj with j < i.
A meaningful expression having a derivation from axioms is called a theorem
of the axiomatic system. To denote the fact that α is a theorem, we use the
acceptance symbol ⊢so ⊢α reads ”α is a theorem”.
We denote with the symbol (L) the deductive system consisting of axioms
T1–T3 and the rules of detachment as well as of substitution as derivation
rules.
Checking whether a given meaningful expression is a theorem requires a
trial–and–error procedure. It is customary to apply the deductive mechanism
of propositional calculus to derive a number of theorems on basis of which
one may establish fundamental properties of this system.
In particular, one can derive the following theorems of propositional cal-
culus, see, e.g., Lukasiewicz [30]
T4 p ⇒p
T5 p ⇒(p ∨q)
T6 q ⇒(p ∨q)

3.2 Propositional Calculus
85
T7 (p ⇒q) ⇒[(r ⇒q) ⇒(p ∨r ⇒q)]
T8 (p ∧q) ⇒p
T9 (p ∧q) ⇒q
T10 (p ⇒q) ⇒[(p ⇒r) ⇒(p ⇒q ∧r)]
T11 p ⇒(q ⇒r) ⇒(p ∧q ⇒r)
T12 (p ∧q ⇒r) ⇒[p ⇒(q ⇒r)]
T13 (p ∧¬p) ⇒q
T14 [p ⇒(p ∧¬p)] ⇒¬p
T15 p ∨¬p
This list can be continued at will; the question is: to what purpose can it
serve? To answer this question, we introduce an algebraic component in anal-
ysis of propositional calculus, known as the Lindenbaum–Tarski algebra, see
Rasiowa and Sikorski [42], p. 245, footnote 1.
For meaningful expressions (formulas) α, β, we say that α, β are equivalent,
in symbols α ≈β, when α ⇒β and β ⇒α are theorems of propositional
calculus.
The relation ≈is an equivalence relation, and one denotes with the symbol
[[α]]≈the equivalence class of ≈containing α. On equivalence classes of ≈,
one does introduce the following operations
1. [[α]]≈∪[[β]]≈= [[α ∨β]]≈;
2. [[α]]≈∩[[β]]≈= [[α ∧β]]≈;
3. −[[α]]≈= [[¬α]]≈.
One introduces the following constants
4. 1 = [[T 1[]≈;
5. 0 = [[¬T 1]]≈.
The ordering ≤L in the Lindenbaum–Tarski algebra is given by, see Rasiowa
and Sikorski [42], p. 246, 10.2,

86
3 Reasoning Patterns of Deductive Reasoning
Proposition 3.2. [[α]]≈≤L [[β]]≈⇔α ⇒β is a theorem.
A principal result, see Rasiowa and Sikorski [42], 10.6., is
Proposition 3.3. If T4–T15 are theorems of propositional calculus, then the
Lindenbaum–Tarski algebra LT(Prop) of propositional calculus with opera-
tions ∪, ∩, −, and constants 0, 1 is a Boolean algebra.
As T1–T15 are theorems of propositional calculus, LT(Prop) is a Boolean
algebra.
By means of truth matrices of functors of propositional calculus, one makes
it certain that formulas T1–T15 are tautologies. Moreover, every formula
derivable from T1–T15 is a tautology: the detachment preserves tautologies,
and substitution does not change the logical value of a formula.
One says that propositional calculus is sound: every theorem is a tautol-
ogy. The converse also holds but the proof is more diﬃcult. The property
in question is the completeness: every tautology is a theorem. There are a
few proofs of completeness, begun with Lukasiewicz [30]; we follow the lines
of Rasiowa and Sikorski [42] and their proof of completeness using algebraic
structures.
The observation that a formula with k propositional variables induces a
Boolean function from 2k into {0, 1} can be generalized: for a given Boolean
algebra B, and a formula α, a mapping fα : Bk →B is induced by replacing
propositional functors ∨, ∧, ¬ with, respectively, boolean algebra operations
∪, ∩, −−. A particular case is the canonical mapping into LT(Prop), at which
each variable pi in α is mapped onto its class [[pi]]≈. Then, see Rasiowa and
Sikorski [42], 1.2, p. 258,
Proposition 3.4. Under the canonical mapping, each formula α is mapped
onto its class [[α]]≈.
It is important to establish the value of a class of theorem in the Lindenbaum–
Tarski algebra LT (Prop), cf., Rasiowa and Sikorski [42], p. 247, 10.4,
Proposition 3.5. In the Lindenbaum–Tarski algebra LT(Prop), [[α]]≈= 1
if and only if α is a theorem.
Proof. Clearly, if α is a theorem, then [[α]]≈= 1. If [[α]]≈= 1, then [[β]]≈≤L
[[α]]≈for each formula β, in particular [[α ⇒α]]≈≤L [[α]]≈, i.e., (α ⇒α) ⇒
α is a theorem. As α ⇒α is a theorem (an instance of T4), by detachment it
follows that α is a theorem.
⊓⊔
This result opens up a way for a proof of completeness of propositional
calculus.
Proposition 3.6. Propositional calculus is complete, i.e, every tautology is
a theorem.

3.2 Propositional Calculus
87
Proof. The proof rests on the property of Boolean algebras of separating el-
ements by maximal ideals, see Ch.1, sect. 11. Assume, to the contrary, that
a formula α is not any theorem. Then, in the Lindenbaum–Tarski algebra,
[[α]]≉= 1, hence, there exists a maximal ideal I such that [[α]]≈∈I. The
quotient algebra LT (Prop)/I ={0, 1}, see Ch. 1, sect. 11, and, as 1 /∈I, [[α]]≈
maps to 0, i.e., in the algebra LT(Prop)/I, α is valued as 0, hence, α is not any
tautology
⊓⊔
The completeness theorem allows now for checking in an algorithmic man-
ner whether a given meaningful expression is a theorem of our system: it is
suﬃcient to this end to determine the truth value of this expression for each
possible selection of literals and to check whether in each case the truth value
of the expression is 1. If so, the expression, being a tautology, is a theorem;
otherwise, the answer is in the negative. As the checking requires only at
most 2k steps for the number k of propositional variables in the expression,
this procedure is ﬁnite. One says that propositional calculus is decidable.
We ﬁnally include in our discussion – in order to give a fairly complete pic-
ture of propositional calculus – a classical deduction theorem due to Herbrand
[19], to be applied later on in a discussion of modal logics.
In few coming paragraphs, we use the Polish notation Cpq for implication,
for conciseness’ sake
Proposition 3.7. (Herbrand [19]) If γ ⊢β, then ⊢Cγβ.
Proof. Let us observe that this proposition extends easily to a more general
one viz. if γ1, .., γk ⊢β then γ1, ..., γk−1 ⊢Cγkβ. Simply please check that the
proof below holds with minor changes in this more general case. Our proof
below rests on some theses of the system (L).
Consider a derivation α1, ..., αk of β from γ. The proof is by induction on
i of the statement ⊢Cγαi. For i = 1, either α1 is an axiom or α1 is γ.
In the former case as CqCpq is a theorem, we have after an adequate
substitution ⊢Cα1Cγα1 and from this we infer by means of detachment
that ⊢Cγα1.
In the latter case, by the theorem Cpp after the substitution p/γ we have
⊢Cγγ, i.e., ⊢Cγα1. Assuming that ⊢Cγαi is proved for i < n ≤k, we
consider αn in the three cases.
1. αn is an axiom;
2. αn is equiform with γ;
3. αn follows by means of detachment from some αr, αs with r, s < n, i.e.,
αr is equiform with Cαsαn.
Clearly, only Case 3 is new, since Cases 1 and 2 may be done with similarly
to the case when i = 1. For Case 3, we have

88
3 Reasoning Patterns of Deductive Reasoning
4. ⊢Cγαs;
5. ⊢CγCαsαn.
As
CCpCqrCCpqCpr
is a theorem, substituting in it p/γ, q/αs, r/αn gives
⊢CCγCαsαnCCγαsCγαn
from which by applying twice detachment with 4 and 5, we arrive at
⊢Cγαn
The inductive step is completed and the deduction theorem follows
⊓⊔
We now consider logical calculi with more than two states of truth.
3.3
Many–Valued Calculi: 3–Valued Logic of
Lukasiewicz
It had been assumed by schools and individuals developing logical systems
up to the beginning of the 20th century that propositions of logic should be
restricted to be either true or false and the twain should exclude themselves
(cf., in this respect, Lukasiewicz [31]. Those systems are therefore called two–
valued. On the other hand, from the very beginning of logic, as witnessed
by the legacy of Aristotle, there was conviction that there are statements
which cannot be true or false, e.g., statements about future and that such
statements may be interpreted as true to a degree.
Lukasiewicz was the ﬁrst to consider a many–valued logic (actually, a 3–
valued one) in Lukasiewicz [25], cf. also, Lukasiewicz [30], [28], in which, in
addition to already familiar truth values 1 (true) and 0 (false), other truth
values, representing various partial degrees of truth were present (in particu-
lar, the value 1
2 in 3–valued logic). The idea of such a logic was based on the
truth matrix of propositional calculus, cf., Fig. 3.1, in which functors C, N,
of, respectively, implication and negation, are represented.
Looking at the part referring to C, i.e., at the sub–matrix composed of
columns 1 and 2, we may observe that the logical value v(Cpq) depends on
logical values v(p), v(q), e.g., according to the formula
C
0
1
N
0
1
1
1
1
0
1
0
Fig. 3.1 Truth table of propositional calculus

3.3 Many–Valued Calculi: 3–Valued Logic of Lukasiewicz
89
C
0
1
2
N
0
1
1
1
1
1
0
1
2
0
2
2
1
1
2
Fig. 3.2 Truth table of the 3–valued calculus
v(Cpq) = min{1, 1 −v(p) + v(q)}
(3.5)
If we admit an intermediate logical value 1
2 then in the case when v(p), v(q)
take values 0, 1, 1
2, also v(Cpq) does take one of this values. Taking into
account a formula deﬁning negation in propositional calculus,
v(Np) = 1 −v(p)
(3.6)
we may construct the matrix for this new 3–valued logic as the following one
(in which for typing convenience the value of 1
2 has been replaced by the
value of 2), cf., Fig. 3.2.
We denote this 3–valued logic with the symbol L3. Let us remark here that
formulas for C, N presented above allow for n–valued logics (with truth val-
ues 0, 1, ...,
k
n−1 where k = 1, 2, ..., n −2) as well as for countably valued logic
(with values as rational numbers in the interval [0, 1]), or real valued logic
with values in the interval [0, 1], all of which were proposed by Lukasiewicz
and investigated in the 20’s and 30’s, cf., Lukasiewicz and Tarski [32]. Inde-
pendently, n–valued logics were proposed in Post [39] and G¨odel [15].
As with propositional logic, we will call a tautology of the 3–valued logic
any meaningful expression whose truth value is 1 for any choice of truth
values of propositional variables that occur in it.
An axiomatization of the logic L3 was proposed in Wajsberg [62] by means
of the following axioms
W1 q ⇒(p ⇒q)
W2 (p ⇒q) ⇒[(q ⇒r) ⇒(p ⇒r)
W3 [(p ⇒Np) ⇒p] ⇒p
W4 (¬q ⇒¬p) ⇒(p ⇒q)
Derivation rules are already familiar rules of substitution and detachment.
We denote this deductive system with the symbol W.
As proved by Wajsberg (op. cit.), the system W is complete, i.e., a mean-
ingful expression of this system is a theorem of this system if and only if it
is a tautology of the 3–valued logic L3.

90
3 Reasoning Patterns of Deductive Reasoning
Let us observe that – as one should expect – some axioms of propositional
calculus are no longer tautologies of the 3–valued logic of Lukasiewicz, witness
for this is, e.g., (¬p ⇒p) ⇒p, its truth value in case v(p) = 2 is 2.
The original proof by Wajsberg of the completeness of his system may
be found in Wajsberg [62]. We include here for the sake of completeness of
exposition a proof proposed by Goldberg, Leblanc and Weaver [13]. The proof
exploits basic properties of syntactic consequence and in its ideology is close
to the proof of completeness of propositional calculus in sect. 3.2.
We use the symbol Γ ⊢α to denote the fact that a formula α has a proof
from a set Γ of formulas. This means that in addition to a deﬁnition of a
proof in sect. 3.2, one can assume that an intermediate αi is in Γ, and the
starting α0 can either be in Γ or be an axiom instance.
In case γ1, ..., γk ⊢β, it follows by applying the deduction theorem consec-
utively k number of times that ⊢Cγ1Cγ2...Cγkβ.
We say that a set Γ is syntactically consistent if and only if there exists no
α with Γ ⊢α and Γ ⊢Nα. A set Γ is a maximal syntactically consistent set if
and only if Γ is syntactically consistent and for each meaningful expression α,
if Γ ∪{α} is syntactically consistent then Γ ⊢α. When Γ is not syntactically
consistent, we will say that it is syntactically inconsistent.
As with propositional logic, we need a good deal of information about syn-
tactic properties of W in order to attempt a proof of completeness. We list
here the basic facts needed in the proof of completeness.
W5 p ⊢q ⇒p
W6 ⊢¬p ⇒(p ⇒q)
W7 Cpq ⊢CCqrCpr
W8 p ⇒q, q ⇒r ⊢p ⇒r
W9 ⊢¬¬p ⇒(q ⇒p)
W10 ⊢CCC[(p ⇒q) ⇒q] ⇒(¬p ⇒q)
W11 ⊢¬¬p ⇒p
W12 ⊢p ⇒¬¬p
W13 ⊢p ⇒p
W14 ⊢(p ⇒q) ⇒(¬q ⇒¬p)
W15 ⊢CC(p ⇒q) ⇒(¬¬p ⇒q)

3.3 Many–Valued Calculi: 3–Valued Logic of Lukasiewicz
91
W16 ⊢(¬¬p ⇒q) ⇒(¬¬p ⇒¬¬q)
W17 ⊢(p ⇒q) ⇒(¬¬p ⇒¬¬q)
W18 ⊢[p ⇒(p ⇒¬p)] ⇒(p ⇒¬p)
W19 ⊢CCCpNpNCpNpp
W20 ⊢¬(p ⇒q) ⇒p
W21 ⊢¬(p ⇒q) ⇒¬q
W22 ⊢[p ⇒(¬q ⇒¬p)] ⇒q)
W23 ⊢(p ⇒¬p) ⇒[(¬q ⇒¬negq) ⇒(p ⇒q)]
W24 ⊢[(p ⇒(p ⇒(q ⇒r)] ⇒[(p ⇒(p ⇒q) ⇒(p ⇒(p ⇒r)]
W25 ¬(p ⇒p) is false for each substitution of truth values for p
The proof begins with the following list of basic properties of consistent sets
Proposition 3.8. The following are basic properties of consistent sets of
formulas
1. Γ ⊢α, Γ ⊆Γ ′ imply Γ ′ ⊢α;
2. Γ ⊢α implies the existence of a ﬁnite Γ ′ ⊆Γ with the property that Γ ′ ⊢α;
3. Γ ⊢α, Γ ⊢Cαβ imply Γ ⊢β;
4. Γ ∪{α} ⊢β implies Γ ⊢CαCαβ;
5. Γ is not syntactically consistent if and only if Γ ⊢f where f denotes any
proposition such that Nf is a theorem;
6. If Γ ∪{α} is syntactically inconsistent then Γ ⊢CαNα;
7. If Γ ∪{CαNα} is syntactically inconsistent then Γ ⊢α.
Indeed, Properties 1, 2, 3 follow by deﬁnition of the relation ⊢; to prove Prop-
erty 4, assume that Γ ∪{α} ⊢β and choose a proof α1, α2, ..., αn of β from
Γ ∪{α}. By induction on j, we prove the following claim
(cj) Γ ⊢CαCααj

92
3 Reasoning Patterns of Deductive Reasoning
We assume (cj) is valid for j < i. There are some cases to be considered.
Case 1. αi is α. In this case (ci) follows by W1 with p, q/α.
Case 2. αi is an instance of an axiom or αi ∈Γ. As Γ ⊢αi, applying
W5 twice yields Γ ⊢CαCααi.
Case 3. αi follows by detachment from αk and Cαkαi with k < i. In this
case we have by the inductive assumption
(i) Γ ⊢CαCααk
(ii) Γ ⊢CαCαCαkαi
It now suﬃces to apply W24 along with the Property 3 and (i), (ii). This
concludes the proof of Property 4.
To begin with the proof of Property 5, assume that Γ is not syntactically
consistent, i.e., Γ ⊢α and Γ ⊢Nα for some meaningful expression α. Then
we have ⊢CNαCαf by W5 and detachment applied twice yields Γ ⊢f.
Conversely, assuming that Γ ⊢f for any false f, we have in particular
Γ ⊢NCpp by W25; as it follows from W13 that Γ ⊢Cpp, we conclude that
Γ is syntactically inconsistent.
Concerning Property 6, assume that Γ ∪{α} is not syntactically consistent.
From W5, as in the proof of Property 5, we infer that Γ ∪{α} ⊢β for any
meaningful expression β in particular Γ ∪{α} ⊢Nα hence Γ ⊢CαCαNα by
Property 4 and it follows from W18 by detachment that Γ ⊢CαNα.
The converse Property 7 follows from W19 and Property 6. By Property 6,
from the assumption that Γ ∪{CαNα} is syntactically inconsistent it follows
that Γ ⊢CCαNαNcαNα so W19 along with Property 3 implies Γ ⊢α.
The proof of basic properties of the relation ⊢concluded, we may pass
to the proof of the completeness theorem. We recall our setting: we have a
(countable) set of propositional variables p0, p1, ..., pn, ... from which mean-
ingful expressions (formulas) are formed in same way as in propositional
calculus.
A valuation is an assignment of truth values to propositional variables;
clearly, any valuation v induces a valuation on meaningful expressions accord-
ing to the semantic rules governing functors C, N. We denote by the symbol
v∗the induced valuation on meaningful expressions. A set Γ of meaningful
expressions is said to be semantically consistent if there exists a valuation v
with the property that v∗(α) = 1 for each α ∈Γ; we will use the shortcut
v∗(Γ) = 1 in this case.
The notion of semantic consequence follows: a meaningful expression α is
a semantic consequence of a set Γ of meaningful expressions if and only if for
each valuation v with v ∗(Γ) = 1 we have v ∗(α) = 1. The fact that α is a
semantic consequence of Γ is denoted with the symbol Γ |= α.

3.3 Many–Valued Calculi: 3–Valued Logic of Lukasiewicz
93
Following Goldberg–Leblanc–Weaver [13], we state
Proposition 3.9. (Strong Completeness Theorem for L3) For each mean-
ingful expression α and each set Γ of meaningful expressions, Γ ⊢α if and
only if Γ |= α.
Proof. One way the proof goes simply: if Γ ⊢α then we may choose a proof
α1, ..., αn of α from Γ and a valuation v with v∗(Γ) = 1 and check directly
by induction that v∗(αi) = 1 for i = 1, 2, ..., n.
The proof in the reverse direction requires some work. It follows from the
following Claim.
Claim. If Γ is syntactically consistent that Γ is semantically consistent.
The proof of Claim relies on the notion of a maximal consistent set. In
this proof we use some results of Set Theory, consult Ch. 1. First, we enu-
merate all propositional variables into a countable set V = {p0, p1, ...} and
then we form the set M of meaningful expressions, enumerating its elements:
M = {α0, α1, ....}; this is possible as the set M is countable since each mean-
ingful expression uses only a ﬁnite number of propositional variables.
This done, we look at Γ and we construct a sequence Γ0 = Γ, Γ1, .... of
sets as follows. Given Γi we let
Γi+1 = Γi ∪{αi+1}
in case Γi ∪{αi+1} is syntactically consistent and
Γi+1 = Γi
otherwise. Having the sequence (Γi)i, we let
Γ ∗=

i
Γi
Properties of Γ ∗of importance to us are collected in the following sub–Claims.
Sub–Claim 1. Γ ∗is syntactically consistent.
Indeed, assume to the contrary that Γ ∗⊢α and Γ ∗⊢¬α for some α.
Then by property 2, there exists a ﬁnite Δ ⊆Γ ∗with the property that
Δ ⊢α, Δ ⊢¬α. By construction of Γ ∗, there exists Γi with Δ ⊆Γi and thus
property 1 implies that Γi ⊢α, Γi ⊢¬α, a contradiction. It follows that Γ ∗
is syntactically consistent.
Sub–Claim 2. Γ ∗is a maximal syntactically consistent set.

94
3 Reasoning Patterns of Deductive Reasoning
Assume that it is not true that Γ ∗⊢α for some meaningful expression α;
as α is αi for some i, we have that Γi−1 ∪{α} is not syntactically consistent
hence by Property 5, Γi−1∪{α} ⊢f and Property 1 implies that Γ ∗∪{α} ⊢f
so by Property 5 applied in the reverse direction we have that Γ ∗∪{α} is
not syntactically consistent. It thus follows that if Γ ∗∪{α} is syntactically
consistent then Γ ∗⊢α which means that Γ ∗is a maximal consistent set.
We now exploit Γ ∗to introduce a certain canonical valuation on the set
V of propositional variables. To this end, we deﬁne a valuation v0 as follows
v0(p) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
1 in case Γ ∗⊢p
0 in case Γ ∗⊢¬p
1
2 otherwise
(3.7)
Now, we establish the vital property of the induced valuation v∗
0 on the set
M expressed in
Sub–Claim 3.
v∗
0(α) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
1 in case Γ ∗⊢α
0 in case Γ ∗⊢¬α
1
2 otherwise
(3.8)
The proof of Sub–claim 3 goes by structural induction.
Case 1. α is of the form ¬β and Sub–Claim 3 holds for β.
When Γ ∗⊢¬β we have v∗
0(β) = 0 hence v∗
0(¬β) = 1 so the claim holds
for α.
When Γ ∗⊢¬¬β we have v∗
0(¬β) = 0 so the claim again holds with α.
When ﬁnally neither of two previous cases hold we conclude by W11 that it
is not true that Γ ∗⊢β so v∗
0(β) = 1
2 hence v∗
0(α) = 1
2. The claim holds with α.
Case 2. α is of the form β ⇒γ and Sub–Claim 3 holds for β, γ.
We have to examine the three possible cases again.
When Γ ∗⊢β ⇒γ, we need to check that
v∗
0(β ⇒γ) = 1
which depends on valuations of β, γ and we have some sub–cases to consider.
When v∗
0(γ) = 1 which happens when Γ ∗⊢γ, we have v∗
0(α) = 1; when
v∗
0(β) = 0 we have again v∗
0(α) = 1.
The sub–case v∗
0(γ) = 0, i.e., Γ ∗⊢¬γ remains but then, by W14, we have
Γ ∗⊢¬β already settled in the positive.

3.3 Many–Valued Calculi: 3–Valued Logic of Lukasiewicz
95
So, ﬁnally, we have the sub–case, when neither of β, ¬β, γ, ¬γ is derivable
from Γ ∗and then v∗
0(β) = 1
2 = v∗
0(γ) a fortiori v∗
0(α) = 1.
The next case is when
Γ ∗⊢¬β ⇒γ
By W20 and W21, we obtain Γ ∗⊢β and Γ ∗⊢¬γ so v∗
0(β) = 1, v∗
0(γ) = 0
and it follows that v∗
0(α) = 0.
Finally, we are left with the case when neither Γ ∗⊢β ⇒γ nor Γ ∗⊢
¬β ⇒γ. It follows from W6 that it is not true that Γ ∗⊢¬β and similarly
W1 implies that it is not true that Γ ∗⊢γ. Thus v∗(β) ̸= 0 and v∗(γ) ̸= 1.
We are left with the following sub–cases.
We have v∗(β) = 1, i.e., Γ ∗⊢β and then by W22, we have that it is not
true that Γ ∗⊢¬γ so v∗(γ) ̸= 0 and hence v∗(γ) = 1
2 and in consequence
v∗(α) = 1
2.
We have v∗(β) = 1
2, i.e., it is not true that Γ ∗⊢β. It is ﬁnally here that
we exploit maximality of Γ ∗.
It follows by maximality of Γ ∗that Γ ∗∪{β} is not syntactically consistent
so by Property 6, we have Γ ∗⊢β ⇒¬β; was v∗(γ) = 1
2, we would have by
the same argument that
Γ ∗⊢¬γ ⇒¬¬γ
and then we would have by W23 that Γ ∗⊢β ⇒γ, a contradiction.
Thus v∗(γ) = 0 and v∗(α) = 1
2. It follows that Sub–Claim 3 holds for α
which completes the inductive step and concludes the proof of Sub–Claim 3.
As Γ ⊆Γ ∗, we have v∗(α) = 1 whenever α ∈Γ, i.e., Γ is semantically
consistent. This concludes the proof of Claim.
Now, we return to the Strong Completeness Theorem; we assume that
Γ |= α. Thus v∗(Γ) = 1 implies v∗(α) = 1 and hence v∗(α ⇒¬α) = 0, i.e.,
Γ ∪{α ⇒¬α}
is semantically inconsistent, hence, by Claim this set is syntactically inconsis-
tent and by Property 7, we have Γ ⊢α. This concludes the proof of the Strong
Completeness Theorem
⊓⊔
A specialization of the Strong Completeness Theorem (Proposition 3.9) to
the case when Γ is the set of axioms W1–W4 yields,
Proposition 3.10. (Completeness theorem for the system (W), Wajsberg
[62], Goldberg–Leblanc–Weaver [13]) A meaningful expression α is a theo-
rem of the system W if and only if it is a tautology of the logic L3.
Now, we proceed from 3- to n–valued logics.

96
3 Reasoning Patterns of Deductive Reasoning
3.4
Many–Valued Calculi: n–Valued Logic
We have seen above the proposition of Lukasiewicz for n–valued logic. In
his logic, functors ⇒, ¬ are deﬁned via functions on truth values. In gen-
eral, we may observe that statements of many–valued logic are of the form
Fi(p1, ..., pk) where Fi is a functor (e.g., ⇒, ¬) and p1, .., pk are proposi-
tional variables. Assuming that any of pi may be assigned any of truth values
1, 2, ..., n, the functor Fi may be described by a matrix of values fi(v1, ..., vk)
where each vi runs over truth values 1, 2, .., n which may be assigned to pi.
Any meaningful expression α(p1, .., pm) is then assigned a matrix of truth val-
ues g(v1, .., vm) where v1, .., vm run over truth values 1, .., n of propositional
variables p1, ..., pm occurring in α and g is the truth function of α composed
of truth functions fj of functors Fj occurring in α.
The idea of a true or false expression has to be generalized to the idea of
acceptance or rejection of a meaningful expression which can be realized in
an n–valued logic by a selection of a threshold value 1 ≤s < n and declaring
a meaningful expression α(p1, .., pm) accepted when g(v1, ..., vm) ≤s for any
choice of truth values 1, 2, ..., m for v1, .., vm where g is the truth function of
α. Otherwise, α is rejected. We may observe that formulas with truth function
taking the value 1 only are accepted regardless of choice of s (we may say
that they are accepted with certainty) while formulas whose truth function
takes on solely the value n are rejected regardless of choice of s (we may say
that they are rejected with certainty). Other formulas may be accepted or
rejected depending on the chosen value of s so their status is less precise and
they may be termed to be accepted to a degree.
We have seen in case of 3–valued logic of Lukasiewicz that truth matri-
ces have been described in a compressed form by functions: f1(v1, v2) =
min{1, v2 −v1 + 1} for the functor ⇒and f2(v) = 1 −v for ¬. In the setting
of an n–valued logic as proposed above, these formulas should be dualized to
ensure that the greater truth value does correspond to a lesser acceptance de-
gree. Thus the Lukasiewicz formulas in the case of n–valued logic are modiﬁed
to the form,
f1(v1, v2) = max{1, v2 −v1 + 1}, f2(v) = 1 −v + n
(3.9)
as proposed in Rosser and Turquette [45].
We now follow the scheme proposed by Rosser and Turquette (op. cit.). The
functors in this scheme are ⇒, ¬ as well as unary functors Jk for k = 1, 2, ..., n
construed as to satisfy the condition that the truth function jk does satisfy
the requirement that jk(v) = 1 in case v = k and jk(v) = n otherwise, for
k = 1, 2, ..., n. Let us outline construction of J′
ks. First, we let

H1(p) is ¬(p)
Hi+1 is p ⇒Hi(p)
(3.10)
We denote by the symbol hi the truth function of Hi. Then we have

3.4 Many–Valued Calculi: n–Valued Logic
97
Proposition 3.11. hi(v) = max{1, n −(v −1) · i} for each i.
Proof. Indeed, inducting on i, we have h1(v) = f2(v) = n −v + 1 =
n −(v −1) = max{1, n −(v −1)} and hi+1(v) = f1(v, hi(v)) = max{1,
max{1, n −(v −1) · i −(v −1)}} = max{1, max{1, n −(v −1) · (i + 1)}} =
max{1, n−(v −1)·(i+1)
⊓⊔
Now, it is possible to introduce functors J1, ..., Jn; we resort to recursion. To
begin with, we let
J1(p) is N(Hn−1(p))
(3.11)
Then, the truth function j1(v) has the required property, viz., j1(1) =
1, j1(v > 1) = n. Indeed, as hn−1(1) = n and hn−1(v) = 1 for v > 1, it
follows that j1(1) = n −n + 1 = 1 and j1(v) = n −1 + 1 = n for v > 1.
To deﬁne remaining functors Jk, one has to introduce auxiliary parameter
κ; given 1 < k ≤m, we let κ = ⌈m−k
k−1 ⌉. Clearly, κ is a decreasing function of
k. Other properties of κ necessary in what follows are summed up below; the
proofs are elementary and hence omitted:
κ < m −1
k −1
(3.12)
hκ(k) = n −(k −1) · κ
(3.13)
1 < hκ(k) ≤k
(3.14)
By property (3.14), either k = hκ(k) or k > hκ(k). Deﬁnition of Jk splits
into two distinct formulas depending on which is the case.
For 1 < k < n −1, one deﬁnes Jk via
Jk(p) is J1(C(Hκ(p) ∨p)(Hκ(p) ∧p))
(3.15)
in case k = hκ(k), and
Jk(p) is Jκ(k)(Hκ(k)(p)
(3.16)
in case k > hκ(k).
Then, the truth function jk of Jk does satisfy the requirement that
jk(k) = 1 and jk(v ̸= k) = n.
In case k = hκ(k), we have
jk(k) = j1(max{1, max{hκ(k), k} −min{hκ(k), k} + 1}) = j1(1) = 1 (3.17)
For v < k, we have,
hκ(v) > hκ(k) = k > v
(3.18)

98
3 Reasoning Patterns of Deductive Reasoning
hence,
jk(v) = j1(hκ(v) −v + 1) = n
(3.19)
In case v > k, we have hκ(v) < k < v, hence,
jk(v) = j1(v −hκ(v) + 1) = n
(3.20)
In case k > hκ(k), we have

jk(k) = jhκ(k)(hκ(k)) = 1
jk(v ̸= k) = n when hκ(v) ̸= hκ(k)
(3.21)
The remaining functor Jn will be deﬁned via the formula
Jn(p) is J1(Np)
We have jn(n) = j1(n −n + 1) = 1 and for v < n it follows that jn(v) =
j1(n −v + 1) = n.
In this way, functors J1, ..., Jn are deﬁned and their truth functions j1, ..., jn
satisfy the requirement that jk(k) = 1 and jk(v) = n whenever v ̸= k.
Helped by these functors, one may deﬁne new functors which would play
some of the roles played by two–valued functors ⇒, ¬ in two–valued calculus
of propositions. Notably, if one would like to preserve in an n–valued logic
the property of two–valued negation that it does convert accepted statements
into rejected ones and conversely, then one should modify the functor ¬: as
deﬁned in the Lukasiewicz n–valued calculus by means of the truth function
f2(v) = n −v + 1, it does convert statements accepted with certainty into
statements rejected with certainty while statements accepted or rejected in
a degree are not necessarily converted into the opposite kind.
To restore this property, one may deﬁne a functor −−via
−−(p) is Js+1(p) ∨... ∨Jn(p)
where ∨(denoted also A) is the functor of alternation. Then α is accepted if
and only if −−α is rejected and conversely. Let us mention that the truth
function n(v) of this negation is given by the formula
n(v) = max{js+1(v), ..., jn(v)}
as here the truth functions of alternation A and conjunction K are adopted
from the Lukasiewicz logic.
Similarly, we may observe that the functor ⇒deﬁned above does not en-
sure the validity of detachment in the form:
if statements α and Cαβ are accepted, then the statement β is accepted

3.5 Many–Valued Calculi: [0,1]–Valued Logics
99
To remedy this, we may invoke theses (p ⇒q) ⇒(¬p ∨q) and (¬p ∨q) ⇒
(p ⇒q) of two–valued propositional logic and we may deﬁne a new functor
⊑via
⊑pq is −−p ∨q
Then detachment rule is valid in the form:
if statements α and ⊑αβ are accepted then the statement β is accepted
n–valued logics described above are completely axiomatizable; axiom schemes
and a proof of completeness will be found in Rosser and Turquette [45].
3.5
Many–Valued Calculi: [0,1]–Valued Logics
The Lukasiewicz semantics does allow for inﬁnite sets of truth values, as
indicated in Lukasiewicz. In this case, one may admit as a set of truth values
any inﬁnite set T ⊆[0, 1] which is closed under functions
c : min(1, 1 −x + y), n : 1 −x
in the sense that c(x, y), n(x) ∈T whenever x, y ∈T ; we recall that the
function c is the meaning of implication ⇒and the function n is the meaning
of negation ¬ in the Lukasiewicz semantics. As shown in McNaughton [37],
any such T needs to be dense in [0, 1]; it is manifest that 0, 1 ∈T for each
admissible T . Thus, sets Q0 = Q∩[0, 1] of rational numbers in [0,1] as well as
the whole unit interval [0, 1] may be taken as sets of truth values leading to
respective inﬁnite valued logical calculi. The additional merit of these two sets
of truth values is that both Q, R1 are from algebraic point of view, algebraic
ﬁelds so they may be regarded as vector spaces over themselves, and this fact
was exploited in completeness proofs, cf., Rose and Rosser [44].
It is well–known that [0,1]–valued logics are fundamentally important to
fuzzy calculi, see sect. 3.6, below. With this in mind, we discuss in this Chap-
ter inﬁnite valued in particular [0,1]–valued logics with the Lukasiewicz se-
mantics. Their completeness in the Lukasiewicz axiomatics, Lukasiewicz and
Tarski [32] was conjectured by Lukasiewicz, loc.cit., under an additional ax-
iom L5, cf., H´ajek [17] for the prelinearity axiom, which was shown redundant,
i.e., following from the four remaining axioms L1–L4, below, in Meredith [33]
and Chang [5]
L1 p ⇒(q ⇒p)
L2 (p ⇒q) ⇒((q ⇒r) ⇒(p ⇒r))

100
3 Reasoning Patterns of Deductive Reasoning
L3 (¬p ⇒¬q) ⇒(q ⇒p)
L4 ((p ⇒q) ⇒q) ⇒((q ⇒p) ⇒p)
L5 [(p ⇒q) ⇒(q ⇒p)] ⇒(q ⇒p)
had been proved in Rose and Rosser [44] by a syntactic argument.
It is convenient, cf., Rose and Rosser , op. cit., , to introduce auxiliary
functors, kind of shortcuts
1. Apq is (p ⇒q) ⇒q;
2. Kpq is ¬[(¬p ⇒¬q) ⇒¬q];
3. Bpq is ¬p ⇒q;
4. Lpq is ¬(p ⇒¬q);
5. Epq is LCpqCqp.
In Lukasiewicz and Tarski [32], a conjecture by Lukasiewicz is stated that the
set L1–L5 of axioms gives a complete axiomatization of inﬁnite valued logical
calculus with the Lukasiewicz semantics in case when the only designated
value is 1.
Completeness of this axiomatization was announced in Wajsberg [49] with-
out proof; the completeness proof was given in Rose and Rosser [44] and here
we follow their development.
According to Lukasiewicz’s semantics, truth functions c of ⇒and n of ¬ are
given by the formulae quoted above, i.e., c(x, y) = min{1, 1 −x + y}, n(x) =
1 −x. Then truth functions a, k, b, l, e of derived functors, respectively,
A, K, B, L, E are given by the following formulas
6. a(x, y) = max{x, y}.
7. k(x, y) = min{x, y}.
8. b(x, y) = min{1, x + y}.
9. l(x, y) = max{0, x + y −1}.
10. e(x, y) = min{1 −x + y, 1 −y + x}.
We may check easily that

3.5 Many–Valued Calculi: [0,1]–Valued Logics
101
Proposition 3.12. The following statements hold
1. a(x, y) = 1 if and only if either x = 1 or y = 1;
z
2. k(x, y) = 1 if and only if x = 1 = y;
3. b(x, y) = 1 if and only if x + y ≥1;
4. l(x, y) = 1 if and only if x = 1 = y;
5. e(x, y) = 1 if and only if x = y.
It follows that A, B are many–valued counterparts to classical disjunction,
K, L are many–valued counterparts to classical conjunction, and E is a many–
valued counterpart to classical equivalence.
As with any logical calculus, also in case of inﬁnite valued logical calculus,
its syntax, its semantics, and their interplay are subject of study. We will
present results of this study here. We will simply assume that the set of
truth values T is either Q ∩[0, 1] or [0, 1] and 1 is the only designated value.
The resulting calculus is denoted L∞.
Inference rules are detachment and substitution. We will use as usual the
acceptance (”yields”) symbol ⊢and for a formula α as in earlier Chapters,
the symbol ⊢α will mean that α is a theorem of the calculus, i.e., there exists
a proof of α from axioms via detachment and substitution in the usual sense
of sect. 2 ﬀ. Similarly, the symbol Γ ⊢α will mean that α is provable from a
set Γ of formulas.
We follow closely Rose and Rosser [44], and we give now a number of the-
orems and syntactic features of L∞.
R1 Γ ⊢p ⇒q, Γ ⊢q ⇒r imply Γ ⊢p ⇒r
Indeed, this is a direct consequence of L2 and detachment. We let p ⇔q
to denote that p ⇒q and q ⇒p hold.
R2 Γ ⊢p ⇔q and Γ ⊢q ⇔r imply Γ ⊢p ⇔r
R2 follows by R1 and deﬁnition of ⇔.
R3 p ⇒q, q ⇒r ⊢p ⇒r
R3 follows by R1.
R4 ⊢Apq ⇔Aqp
R4 follows by L3.
R5 From Γ ⊢p ⇔q it follows that Γ ⊢p ⇒r ⇔q ⇒r
Indeed, by L2 and detachment, we have p ⇒q ⊢(q ⇒r) ⇒(p ⇒r) and
q ⇒p ⊢(p ⇒r) ⇒(q ⇒r).

102
3 Reasoning Patterns of Deductive Reasoning
R6 ⊢p ⇒Aqp
R6 is obtained by substitution q/q ⇒p in L1.
R7 ⊢p ⇒Apq
R7 follows from R6 and L3.
R8 ⊢[p ⇒(q ⇒r)] ⇒[q ⇒(p ⇒r)]
Indeed, ⊢CqAqr by R7 and L2 implies
(i) ⊢[Aqr ⇒(p ⇒r)] ⇒[q ⇒(p ⇒r)]
hence, substitution q/q ⇒r along with L2 yields
(ii) ⊢[p ⇒(q ⇒r)] ⇒[(Aqr) ⇒(p ⇒r)]
From (i), (ii) one gets R8 via R1.
R9 (q ⇒r) ⇒[(p ⇒q) ⇒(p ⇒r)]
R9 follows from R8 and L2.
R10 Γ ⊢p ⇔q implies Γ ⊢(r ⇒p) ⇔(r ⇒q).
R10 follows by substituting p/q, q/p in R8 which yields
(i) ⊢(p ⇒(q ⇒))r ⇔(q ⇒(p ⇒r)),
and using L2 in which substitutions p/q, q/r, r/p have been made.
R11 ⊢(p ⇒p) Indeed, substituting q/p in R8 and applying L1 one obtains
(i) ⊢q ⇒(p ⇒p). Letting q to be any already proved theorem and applying
detachment yields R11.
R12 ⊢p ⇔p
Immediate from R11.
R13 p ⊢q ⇔(p ⇒q)
This follows from L1 where substitution p/q, q/p has been made and from R7
in which A has been replaced by the right–hand side of 1.
R14 ⊢q ⇔Aqq
Indeed, substitute p/q ⇒q in R13 and apply R11.
R15 p ⇒r, q ⇒r ⊢Apq ⇒r
R16 From p1, .., pk, p ⊢r and q1, ..., qn, q ⊢r it follows that p1, ..., pk, q1, ...,
qn, Apq ⊢r

3.5 Many–Valued Calculi: [0,1]–Valued Logics
103
R17 ¬¬p ⇒p
R18 ⊢p ⇒¬¬p
R19 ⊢p ⇔¬¬p
R19 follows by R17 and R18.
R20 ⊢(p ⇒q) ⇔¬q ⇒¬p
R21 Γ ⊢p ⇔q implies Γ ⊢¬p ⇔¬q
R21 follows from R20.
R19 and R20 imply
R22 ⊢Lpq ⇔Lqp
R23 ⊢Bpq ⇔Bqp
R24 ⊢p ⇒Bpq
Indeed, substituting q/Nq in L1 obtains (i) ⊢p ⇒Bqp whence R24 follows
by R23.
R25 ⊢Lqp ⇒p
R25 follows from R22.
R26 ⊢Lpq ⇒p
R27 ⊢(p ⇒(q ⇒r) ⇔Lpq ⇒r
From R20 it follows that (i) ⊢(p ⇒(q ⇒r)) ⇔(p ⇒(¬r ⇒¬q)) and R8
implies (ii) ⊢(p ⇒(q ⇒r)) ⇔(¬r ⇒(p ⇒¬q)) so R27 follows by R23.
R28 ⊢(p ⇒(q ⇒Lpq))
It is enough to substitute in R27 r/Lpq and invoke the theorem ⊢Lpq ⇒Lpq.
R29 p ⊢q ⇔Lpq
R29 follows from R25 and R28.
R30 Γ ⊢p ⇔q is equivalent to Γ ⊢Epq
From R28 one infers (i) p ⇒q, q ⇒p ⊢Epq, and R25 with R26 imply (ii)
Epq ⊢p ⇔q.
R31 ⊢Epp
It suﬃces to substitute q/p in R30.

104
3 Reasoning Patterns of Deductive Reasoning
R32 Epq, Eqr ⊢Epr
R32 follows from 30.
R31 Epq ⊢E¬p¬q
R31 follows from R30 and R21.
R32 Epq, Ert ⊢E(p ⇒r)(q ⇒t)
It follows by R5 and R10.
R33 p, q ⊢p ⇔q
By R11 and L4, we obtain
(i) ⊢p ⇒(r ⇒r)
so by R28 we have
(ii) ⊢[(r ⇒r) ⇒p] ⇒Ep(r ⇒r)
and it follows from L1 that
(iii) p ⇒[(r ⇒r) ⇒p]
(substitute q/r ⇒r) so by R30,
(iv) p ⊢p ⇔(r ⇒r)
follows. Substitution p/q in (iv)) yields
(v) q ⊢q ⇔(r ⇒r)
whence R33 follows by R32.
R34 ¬p, ¬q ⊢p ⇔q
By p ⊢p ⇔(r ⇒r) ((iv) in R33), R19 and R21, it follows that
(i) ¬p ⊢p ⇔¬(r ⇒r)
and from it R34 follows.
R35 A¬pq ⇒(p ⇒q)
By R24 and L2,
(i) (Bpq ⇒q) ⇒(p ⇒q)
follows which may be also written in the form of R35.
R36 ⊢¬p ⇒(p ⇒q)
Indeed, L1 implies

3.5 Many–Valued Calculi: [0,1]–Valued Logics
105
(i) ⊢¬p ⇒(¬q ⇒¬p)
whence R36 follows by R20.
We now close our discussion of syntax of L∞with a proof of the Deduction
Theorem for this calculus.
We need some preliminary facts. To state them, we introduce a symbol
Γ m
i=1ris, cf., Rosser and Turquette [45], Rose and Rosser [44]. The deﬁnition
is inductive on m and goes as follows,
Γ m
i=1ris =

s in case m < 1
CrmΓ m−1
i=1 ris otherwise
(3.22)
In case all ri are a formula r, we write (Cr)ms instead of Γ m
i=1ris.
Proposition 3.13. (Rosser and Turquette [45]) If r1, ..., rm are formulas and
q1, .., qk with k ≤m are among r1, ..., rm, then
⊢Γ k
i=1qis ⇒Γ m
i=1ris
Proof. By induction on m. In case m = 0 also k = 0 and the thesis reduces
to ⊢s ⇒s, i.e., to R11.
Assuming the thesis for m, we consider m + 1.
First, let k = 0; then by inductive assumption,
(i) ⊢s ⇒Γ m
i=1ris
and L1 gives us
(ii) ⊢Γ m
i=1ris ⇒Γ m+1
i=1 ris
The thesis follows by L2.
Now, let k > 0; then qk is ru. By the inductive assumption,
(iii) ⊢Γ k−1
i=1 qis ⇒Γ m+1
i=u+1riΓ u−1
i=1 ris
so R9 implies
(iv) ⊢Γ k
i=1qisCqu ⇒Γ m+1
i=u+1riΓ u−1
i=1 ris
There are two cases. For economy of space, we return to the symbol C for
implication.
Case 1. u = k + 1. The thesis follows from (iv).
Case 2. u < k + 1. By R8,
(v) ⊢C(CquΓ m+1
i=u+1riΓ u−1
i=1 risCrm+1CruΓ m+1
i=u+1ri)Γ u−1
i=1 ris

106
3 Reasoning Patterns of Deductive Reasoning
The inductive assumption implies
(vi) ⊢C(CruΓ m
i=u+1riΓ u−1
i=1 ris)Γ m
i=1ris
whence R9 yields
(vii) ⊢C(Crm+1CruΓ m
i=u+1ris)Γ u−1
i=1 ris
Now, L2 applied to (iv), (v), (vii), gives the thesis
⊓⊔
In a similar way the following proposition may be proved.
Proposition 3.14. (Rosser and Turquette [45]) ⊢CCqrCΓ m
i=1piqΓ m
i=1pir.
Proof. Again, we induct on m. In case m = 0 the theorem becomes ⊢r ⇒r,
i.e., R11.
The inductive step from m to m + 1 involves R9, which yields
(i) ⊢C(CΓ m
i=1piqΓ m
i=1pir)(C(Γ m+1
i=1 piq)Γ m+1
i=1 pir)
It suﬃces now to apply the inductive assumption and L2
⊓⊔
Proposition 3.15. (Rose and Rosser [44])
Γ m
i=1piq, Γ n
i=1si(q ⇒r) ⊢Γ m
i=1piΓ n
i=1sir.
Proof. Assume (i) Γ n
i=1siCqr and apply to it R8 to obtain (ii) q ⇒Γ n
i=1sir.
Proposition 3.14 yields
(iii) CΓ m
i=1piqΓ m
i=1piΓ n
i=1sir
⊓⊔
Letting pi, qi to be p we get a corollary, cf., Nov´ak [38], H´ajek [17].
Proposition 3.16. ⊢C(C((Cp)mq)((Cp)nCqr))((Cp)n+mr.
We now are in position to prove the Deduction theorem for L∞.
Proposition 3.17. (Deduction Theorem, Rose and Rosser [44], Nov´ak [38],
H´ajek [16]) If Γ, p ⊢q, then Γ ⊢(Cp)nq for a natural number n ≥0.
Proof. We refer to the proof of Deduction Theorem in the case of classi-
cal propositional calculi, sect. 3.2. We carry out that proof; observe, that
the proof goes through in our new case here except in the case when αn is
gotten by detachment from αr ⇒αn with some r < n, in which case we apply
Proposition 3.16
⊓⊔
Here the survey ends of basic syntactic properties of the inﬁnite valued calcu-
lus L∞. In the part concerned with semantics, some further syntactic prop-
erties emerge when necessary. Now, we pass to semantics of L∞with the

3.5 Many–Valued Calculi: [0,1]–Valued Logics
107
intention of giving an outline of the completeness proof by Rose and Rosser
[44].
The Rose and Rosser idea of the completeness proof rests on the separa-
tion properties in ﬁnite–dimensional vector spaces. We simplify the arguments
there by replacing matrix dichotomies used by Rose and Rosser with Propo-
sitions 18–20 below. Our ﬁrst lemma is a well–known statement of Linear
Algebra. We include a proof.
Proposition 3.18. Consider an algebraic inﬁnite ﬁeld F ⊆R1. We are con-
cerned with either F = Q, the ﬁeld of rational numbers or F = R1. Consider
linear functionals f1, ..., fk, g on F n with values in F. If
(i) f1(x) = 0, ..., fk(x) = 0 imply g(x) = 0 for every x ∈F n
then there exist λ1, .., λk ∈F with the property that g = k
i=1 λifi.
Proof. Consider W = {(f1(x), ..., fk(x)) : x ∈F n}. Then W ⊆F k is a vector
subspace of F k. We deﬁne a functional h on W by letting h((f1(x), ..., fk(x)))
to be g(x). Clearly, h is well–deﬁned by our assumption (i) and then h extends
to a functional H : F k →F. There exists the matrix of H say [λ1, ..., λk],
i.e.,
H(x) = [λ1, ..., λk]xT =
k

i=1
λixi
By restricting H to W, we obtain a particular result that g = k
i=1 λifi
⊓⊔
A simple corollary follows.
Proposition 3.19. In the notation of Proposition 3.18, if
(ii) fi(x) ≥0 for i = 1, 2, ..., k imply g(x) ≥0 for each x ∈F n
then g = k
i=1 λifi for some λ1 ≥0, .., λk ≥0 ∈F.
Indeed, the assumption (i) follows easily from (ii). That λ’s be non–negative
is also forced by (ii ).
We now consider a more general case when our functionals are aﬃne func-
tions, i.e.,
fi(x) = ci +
n

i=1
aijxj
and
g(x) = d +
n

i=1
bixi
where ci, aij, d, bj ∈F. As clearly, fi−ci, g−d are linear functionals, it follows
from already proved cases that,

108
3 Reasoning Patterns of Deductive Reasoning
Proposition 3.20. If aﬃne functions f1, .., fk, g satisfy the condition that
f1(x) ≥0, .., fk(x) ≥0 imply g(x) ≥0 for every x ∈F n
then g = μ + k
i=1 λifi with μ ≥0, λ1 ≥0, ..., λk ≥0 ∈F.
The crux of the completeness proof is in approximating general formulas with
formulas of a special type, called polynomial formulas.
Here, by a polynomial a function of the form c + k
i=1 bixi is meant with
integral coeﬃcients a, bi. For each such polynomial f, a set PF(f) of formulas
will be deﬁned. To this end, we deﬁne the norm |f| of f by letting |f| =
k
i=1 |bi|. The deﬁnition of PF(f) splits into few cases.
PF1 In case |f| = 0, we let: when c ≥1, then PF(f) = {Cxixj}, where
xi, xj are variables, and when c ≤0, then PF(f) = {NCxixj}, where xi, xj
are variables.
In case |f| > 0, we assume that PF(g) has been already deﬁned for every
g with |g| < |f|. Again, there are some subcases.
PF2 When there is bi > 0, we let PF(f) = {LBqxjr}, where q ∈
PF(f −xj), r ∈PF(f + 1 −xj).
PF3 When there is bi < 0, we let PF(f) = {LBqNxjr}, where q ∈
PF(f + xj −1), r ∈PF(f + xj).
For a polynomial formula p, we denote by v(p) the truth value of p stemming
from truth values of variables xi. Actually then, v(p) is a truth function. Let
also sgn be the sign function deﬁned via sgn(x) = 1 in case x > 1, sgn(x) = 0
in case x < 0 and sgn(x) = x, otherwise. Then we have
Proposition 3.21. For each polynomial formula p ∈PF(f) and every set
xi ∈[0, 1] of variable values, we have v(p) = sgn(f).
Proof. Proof is by inducting on |f|. In case |f| = 0, both sides are 1. Assuming
truth of Proposition in case of all g with |g| < |f|, we consider p ∈PF(f).
Again, there are some cases to consider, according to deﬁnitions of poly-
nomial formulas given above.
1. Some bi > 0 so p is LBqxir with some q ∈PF(f −xi), r ∈PF(f +1−xi).
Then we have four sub–cases.
(a) f > 1 + xi in which sub–case sgn(f −xi), sgn(f + 1 −xi) = 1 hence
v(q) = v(r) = 1 by the inductive assumption and thus by semantics of
B, L it follows that v(p) = 1. Clearly, sgn(f) = 1.
Other sub–cases (b) xi ≤f < 1 + xi (c) −1 + xi ≤f < xi (d) f < −1 + xi
are discussed in analogous way,
2. Some bi < 0 so p is LBqNxir with q ∈PF(f + xi −1), r ∈PF(f + xi).
We have four sub–cases, viz., (a) f + xi > 2 (b) 1 ≤f + xi ≤2 (c)
0 ≤f + xi < 1 (d) f + xi < 0 in which we argue as in Case 1.
⊓⊔

3.5 Many–Valued Calculi: [0,1]–Valued Logics
109
This ends the basic introduction to polynomial formulas. Now, we list, fol-
lowing Rose and Rosser [44], some deeper properties of polynomial formulas
necessary in the proof of completeness. We would omit the tedious technical
lemmas intervening in these proofs which otherwise would obscure the main
ideas of the proof and we refer the interested reader to Rose and Rosser, op.
cit., Thms. 10.1–10.7, 13.1 – 13.18, for proofs of these properties.
Proposition 3.22. (Rose and Rosser [44]) The following are among proper-
ties of polynomial formulas
1. ⊢p ⇔q whenever p, q ∈PF(f);
2. ⊢ANpq whenever p ∈PF(f), q ∈PF(f + 1);
3. ⊢p ⇔Nq whenever p ∈PF(f), q ∈PF(1 −f);
4. ⊢Apq whenever p ∈PF(f), q ∈PF(2 −f);
5. t ⊢CpCCqrs whenever q ∈PF(f), r ∈PF(g), s ∈PF(1 −f + g), t ∈
PF(2 −f), p ∈PF(g + 1);
6. ⊢CpCqr whenever q ∈PF(f), r ∈PF(g), p ∈PF(1 −f + g);
7. p1, .., pk ⊢q whenever pi ∈PF(1 + fi), q ∈PF(1 + k
i=1 fi)
for some k > 0;
8. ⊢p whenever p ∈PF(1 + xi);
9. ⊢p whenever p ∈PF(2 −xi);
10. p1, ..., pm ⊢q whenever pi ∈PF(1 + fi), q ∈PF(1 + g), f1, ..., fm,
g have integral coeﬃcients, and f1(x) ≥0, ..., fm(x) ≥0 imply g(x) ≥0
for every x ∈[0, 1]n whose each coordinate is rational.
Assuming truth of statements in Proposition 3.22, we now may proceed with
concluding steps in completeness proof.
For a formula p and a polynomial f, a new formula α(p, f) is deﬁned as
follows.
For an arbitrarily chosen q ∈PF(f), r ∈PF(2−f), t ∈PF(1+f),
we let α(p, f) to be LLEpqrs. Let us observe that any other choice of q, r, s
subject to conditions yields an equivalent formula α(p, f) due to Proposition
3.22(1).
With help of this new class of formulas, one may prove the following prin-
cipal statement.
Proposition 3.23. (Rose and Rosser [44]) For each formula p, there exist
m ≥0, polynomial formulas q1, ..., qm, r1, ..., rm and polynomials f1, ..., f2m
with the properties

110
3 Reasoning Patterns of Deductive Reasoning
1. ⊢Aqiri for i = 1, 2, ..., m.
2. for each subset {j1, .., jk} ⊆{1, 2, ..., m} with the complementing subset
{i1, .., im−k} there exists 1 ≤k ≤2m with the property that
qj1, ..., qjk, ri1, ..., rim−k ⊢α(p, f).
Proof. We induct on complexity of p.
In case p consists of a single symbol, it is of the form xi; consider m = 0
so only f1 needs to be deﬁned and choose f1(x) = xi. Then (i) ⊢r (ii) ⊢t by
Proposition 3.22 (8, 9). By Proposition 3.22 (1), we have
⊢q ⇔LB¬ssxi ⇒Css
which is
⊢q ⇔LBNCsspCss
By R11 and R33, we get that
⊢q ⇔BNCssp
whence
⊢q ⇔p
follows by R11, R19, and R13. Then ⊢Epq follows by R3 and (i), (ii), R28,
and Proposition 3.22 (6), imply ⊢α(p, f).
To get through the inductive step, assume that the proposition is true for
all t with complexity less than l, and consider p with l symbols. There are
two cases in need of consideration: 1. p is Nt 2. p is Ctr.
Case 1. There exist an integer n, polynomial formulas q1, ..., qn, r1, ..., rn
and polynomials g1, ..., g2n satisfying 1,2, in Proposition 3.23 with t. Keeping
m = n, we let fi = 1 −gi for 1 ≤i ≤2n.
Assuming q∗, r∗, s∗were chosen from, respectively, PF(gi), PF(2 −gi),
PF(1+gi) and choosing q, r, s from respectively PF(fi), PF(2−fi), PF(1+
fi) we have by Proposition 3.22 (1, 3), that
(i) ⊢r ⇔s∗
(ii) ⊢s ⇔r∗
(iii) ⊢q ⇔Nq∗
Now, we have Etq∗⊢ENtNq∗by R31, i.e.,
(iv) Etq∗⊢Epq

3.5 Many–Valued Calculi: [0,1]–Valued Logics
111
We now consider a subset {j1, ..., jk}; we have by inductive assumption that
qj1, ..., qjk, ri1, ..., rim−k ⊢α(t, gi)
for some i. It follows from (i), (ii), (iii), (iv), R25, R26, and R28 that
α(t, g) ⊢α(p, f)
which concludes the proof in this case.
Case 2. As p is t ⇒r, the inductive assumption yields us m, q1,. . . , qm,
r1,. . . , rm, g1, . . . , g2m satisfying conditions 1,2 of Proposition 3.23 with t
and n, q∗
1, ..., q∗
n, r∗
1, ..., r∗
n, h1, ..., h2n satisfying those conditions with r.
It remains to glue these constructs together to produce the respective set
for p.
We let k = m + n + 2m+n. We make use of qi’s, q∗
i ’s, ri’s, and r∗
i ’s whose
number is m + n so we need 2m+n new polynomial formulae. To construct
them, for 1 ≤u ≤2m and 1 ≤v ≤2n we select suv ∈PF(1 −gu + hv), s∗
uv ∈
PF(1 + gu −hv). As ⊢Asuvs∗
uv by Proposition 3.22 (4), sets
{q1, ..., qm, r1, ..., rn, s11, ..., s2m2n}
and
{q∗
1, ..., q∗
m, r∗
1, ..., r∗
n, s∗
11, ..., s∗
2m2n}
satisfy condition 1 of Proposition 3.23. We denote elements of the ﬁrst set
with symbols ai and elements of the second set with symbols a∗
i .
Now, we need polynomials satisfying condition 2 with new sets of formulas.
We select a subset {j1, ..., jw} of the set {1, ..., k}, and we consider the set
M = {aj1, ..., ajw, a∗
i1, ..., a∗
ik−w}.
Let Γ be the subset of M consisting of formulas of the form qi, q∗
i and Δ
be the subset of ri, r∗
i of M. By inductive assumption, we have u ≤m, v ≤n
such that
(i) Γ ⊢α(t, gu)
(ii) Δ ⊢α(r, hv)
Applying Proposition 3.22 (6), R25, and R26, we infer from (i), (ii) that
(iii) Γ, Δ ⊢Ett1, t2, t3, Err1,r, r2,r, r3,r
where α(t, gu) is LLEtt1t2t3 and α(r, hv) is LLErr1,rr2,rr3,r.

112
3 Reasoning Patterns of Deductive Reasoning
By (iii) and R32, it follows that
(iv) Γ, Δ ⊢EpCt1r1,r
By Proposition 3.22 (6), one obtains
(v) ⊢CsuvCt1r1,r
and Proposition 3.22 (5), implies via (v) that
(vi) t2 ⊢Cr3,rCCt1r1,rsuv
Now, it follows from (iii), (iv) that
(vii) Γ, Δ ⊢Epsuv
It is time now to show the existence of the appropriate polynomial fM for
this case. There are two cases to discuss: either suv ∈M (Case 1) or suv /∈M
(Case 2).
Case 1. Let fM be identically 1. By R11 and R33, we have,
(viii) suv ⊢EsuvCzz for an arbitrarily chosen formula z
whence by (vii) and R32,
(ix) Γ, Δ, suv ⊢EpCzz
By Proposition 3.22 (1), and the deﬁnition of fM, we have for p1 ∈
PF(fM), p2 ∈PF(2 −fM), p3 ∈PF(1 + fM) that p1 ⊢Czz, p2 ⊢Czz,
and p3 ⊢Czz, and thus by R11 and R28 one arrives at,
Γ, Δ, suv ⊢α(p, fM)
concluding the proof in this case.
Case 2. We have s∗
uv ∈M. Let fM = 1 −gu + hv and select p1, p2, p3
appropriately in respective PF’s. By Proposition 3.22 (1), ⊢p1 ⇔suv and
⊢p2 ⇔s∗
uv which imply via (vii) and R28 that
(x) Γ, Δ, s∗
uv ⊢LEpp1p2
By Proposition 3.22 (7), it follows that
(xi) t2, r3,r ⊢p3

3.5 Many–Valued Calculi: [0,1]–Valued Logics
113
Finally, by (iii) and (x), one infers that
Γ, Δ, s∗
uv ⊢α(p, fM)
concluding the proof in Case 2 and hence the proof of the proposition
⊓⊔
We only need one more auxiliary statement
Proposition 3.24. For each formula p and each polynomial f the following
hold
1. Γ ⊢α(p, f) implies Γ, p ⊢p1.
2. Γ ⊢α(p, f) implies Γ ⊢Cp1p.
Proof. Concerning Property 1, we begin with Γ ⊢LLEpp1p2p3 whence by
R22 ﬁrst Γ ⊢Lp3LEpp1p2 and next Γ ⊢Lp3Lp2Epp1 follow. Assuming p,
we have Γ, p ⊢Lp3Lp2p1 and applying twice R25, one obtains Γ, p ⊢p1.
For Property 2, we begin as in case of Property 1, until Γ ⊢Lp3Lp2Epp1
and at this point one applies R25 twice getting Γ ⊢Epp1 from which Γ ⊢
Cp1p follows
⊓⊔
We now may state the completeness theorem. Clearly, L∞is sound: whenever
a formula p is a theorem, it is a tautology as well, i.e., v(p) is identically 1.
The converse is also true.
Proposition 3.25. (The Completeness Theorem, announced in Wajsberg
[49], Rose and Rosser [44]) For each formula p, if p is a tautology, i.e.,
the value v(p) is identically 1, then p is a theorem.
Proof. Assume that v(p) is identically 1 for a formula p. By Proposition 3.23
there exist m ≥0, polynomial formulas q1, ..., qm, r1, ..., rm and polynomials
g1, ..., gm, h1, ..., hm as well as f1, ..., f2m with the properties following from
Proposition 3.24
(i) ⊢Aqiri for i = 1, 2, ..., m
(ii) For each subset {j1, .., jk} ⊆{1, 2, ..., m} with the complementing sub-
set {i1, ..., im−k}, we have a polynomial fk such that
(a) qj1, ..., qjk, ri1, ..., rim−k, p ⊢p1
(b) qj1, ..., qjk, ri1, ..., rim−k ⊢Cp1p
with some p1 ∈PF(fk) and qi ∈PF(gi), ri ∈PF(hi) for i = 1, 2, ..., m
From (a), by Proposition 3.21 it follows that whenever gi(x), hi(x) ≥1, then
fk(x) ≥1 for each truth value vector x with coordinates in [0, 1]. Then by
Proposition 3.22 (10), we have

114
3 Reasoning Patterns of Deductive Reasoning
(iii) qj1, ..., qjk, ri1, ..., rim−k ⊢p1
whence by (b) and detachment
(iv) qj1, ..., qjk, ri1, ..., rim−k ⊢p
Now, we have eliminated p1, hence fk, a fortiori, no more do we need formu-
las α(p, fi) and we are left only with the fact that (iv) holds for each choice
of {j1, ..., jk} ⊆{1, 2, ..., m}.
Using R16 along with Property 1 an appropriate number of times yields
(v) ⊢p
which concludes the proof
⊓⊔
Hence, the calculus L∞is complete. Please observe that the proof above
covers cases when the set of truth values is an inﬁnite subset of [0, 1] (with
additional above mentioned requirements), e.g., the set of rational values, or
simply the segment [0, 1].
3.5.1
MV–Algebras
Another approach, along the lines of algebraic proofs of completeness, was
proposed in Chang [5]. The idea pursued by Chang was to give a counterpart
of the algebraic proof of completeness of propositional calculus due to Rasiowa
and Sikorski, see sect. 3.2, by constructing an algebra in which formulas of
inﬁnite–valued calculus could be interpreted and the maximal ideal property
would hold. The result was an MV–algebra (i.e., many–valued algebra).
An MV–algebra is a structure (X, +, ·, −, 0, 1), in which +, · are binary
operations which are symmetric and associative, −is a unary operation of
complement, 0, 1 are constants, and moreover the properties hold
1. x + (−−x) = 1, x · (−x) = 0;
2. x + 1 = 1, x · 1 = x;
3. x + 0 = x, x · 0 = 0;
4. x = −−x, −0 = 1;
5. −(x + y) = (−x) · (−y); −(x · y) = (−x) + (−y).

3.5 Many–Valued Calculi: [0,1]–Valued Logics
115
The connectives ∨, ∧are introduced by means of the formulas
6. x ∨y = x · (−y) + y.
7. x ∧y = [x + (−y)] · y.
Then, ∨, ∧are symmetric and associative, and the lattice (X, ∨, ∧) is
distributive.
Moreover
8. x ∨1 = 1, x ∧1 = x.
9. x ∨0 = x; x ∧0 = 0.
10. x ∨x = x = x ∧x.
11. x ∧(x ∨y) = x = x ∨(x ∧y).
Let us observe that ∨conforms semantically to A and ∧conforms semanti-
cally to K in the Rose and Rosser’s scheme.
The ordering relation ≤L is deﬁned by means of
x ≤L⇔x ∨y = y ⇔x ∧y = x
(3.23)
Then, Chang [5], par. 1.3–1.17, proves
Proposition 3.26. The ordering ≤L is a congruence, i.e.,
1. x ≤L y and t ≤L z imply x ∨t ≤L y ∨z;
2. x ≤L y and t ≤L z imply x ∧t ≤L y ∧z;
3. x ≤L y and t ≤L z imply x + t ≤L y + z;
4. x ≤L y and t ≤L z imply x · t ≤L y · z.
It follows that ∨, ∧are,. respectively, the join and the meet operations. More-
over, the algebra B(X) = {x ∈X : x + x = x} is a Boolean algebra in which
x + y = x ∨y and x ∧y = x · y.
The Lindenbaum–Tarski algebra LT(∞) of the calculus L∞is deﬁned as in
case of propositional calculus, by considering the equivalence classes [[α]]≈of
formulas, where α ≈β holds if and only if α ⇒β and β ⇒α are theorems
of L∞, with induced operations,

116
3 Reasoning Patterns of Deductive Reasoning
1. [[α]]≈+ [[β]]≈= [[Bαβ]]≈;
2. [[α]]≈· [[β]]≈= [[Lαβ]]≈;
3. [[α]]≈∨[[β]]≈= [[Aαβ]]≈;
4. [[α]]≈∧[[β]]≈= [[Kαβ]]≈;
5. [[α]]≈= 1 ⇔⊢α;
6. [[α]]≈= 0 ⇔⊢¬α.
Hence, see Chang [5], sect. 2, LT(∞) is an MV–algebra.
Other example, see Chang [5], sect. 2, is submitted by the interval [0, 1]
with operations
1. x + y = min{1, x + y};
2. x · y = max{0, x + y −1};
3. −x = 1 −x;
4. x ∨y = max{x, y};
5. x ∧y = min{x, y};
6. x ≤L y ⇔x ≤y,
which represent the semantics of the Lukasiewicz logic.
For the completeness proof on these lines, see Chang [5], cf., also an expo-
sition in H´ajek [17].
3.6
Many–Valued Calculi: Logics of Residual
Implications
These logics are also termed ‘fuzzy logics’ because of their association with
fuzzy theory of approximate reasoning due to Zadeh [24], for which they serve
as a theoretical foundation. Classical propositional logics are related to the
classical notion of a set/collection/class/concept, understood as an object in
which some other objects may or not belong, in either case with certainty;
as with many–valued departure from the true/false dichotomy, the classical
notion of a set did undergo a relaxation to the notion of a fuzzy set/concept
in Zadeh [24]. The relaxation had made usage of the manner of representing

3.6 Many–Valued Calculi: Logics of Residual Implications
117
a set by means of a characteristic function: given a set X ⊆U, U being a
universe of considered objects, the characteristic function χX of the set X is
deﬁned by means of the formula,
χX(u) =

1 u ∈X
0 u /∈X
(3.24)
The fuzzy set X is deﬁned by means of a fuzzy membership function μX :
U →[0, 1]; a subjective choice of μX determines the understanding of the
nature of objects with respect to the concept X.
In sect. 3.5, above, we have witnessed functors A, B, K, L, whose semantic
interpretations have come in pairs: l(x, y) = max{0, x + y −1}, b(x, y) =
min{1, x + y}, and, k(x, y) = min{x, y}, a(x, y) = max{x, y}. Denoting l, k
with T and b, a with S, we observe the duality
S(x, y) = 1 −T (1 −x, 1 −y); T (x, y) = 1 −S(1 −x, 1 −y)
(3.25)
A more general setting is provided by the framework of t −norms (triangu-
lar norms) due originally to Menger [33], cf., Schweitzer–Sklar [62]. A t–norm
T : [0, 1]2 →[0, 1] does satisfy the requirements
T1 (Symmetry): T (x, y) = T (y, x)
T2 (Associativity): T (x, T(y, z)) = T (T (x, y), z)
T3 (Monotonicity): if x > x′ then T (x, y) ≥T (x′, y)
T4 (Boundary conditions): T (x, 0) = 0; T (x, 1) = x
It is a simple task to verify that l, k are t–norms; we may reveal their names,
L(x, y) = max{0, x + y −1} (the Lukasiewicz t–norm)
M(x, y) = min{x, y} (the t–norm minimum)
We add one more classical t–norm,
P(x, y) = x · y (the Product t–norm, or, the Menger t–norm)
The Lukasiewicz formula for interpreting implication ⇒, i.e., c(x, y) =
min{1, 1 −x + y)}, can be recovered from the t–norm L(x, y); the tool is
the residual implication ⇒T deﬁned by means of the equivalence
x ⇒T y ≥z ⇔T (x, z) ≤y
(3.26)

118
3 Reasoning Patterns of Deductive Reasoning
Equivalently,
x ⇒T y = sup{z : T(x, z) ≤y}
(3.27)
In case the t–norm T(x, y) is continuous, the operator sup becomes the op-
erator max. Helped by (3.27), one can easily ﬁnd the explicit formulas for
residual implications induced, respectively, by L, P, M:
1. x ⇒L y = min{1, x −y + 1};
2. x ⇒P y = 1 ⇔x ≤y and y
x otherwise;
3. x ⇒M y = 1 ⇔x ≤y and y otherwise.
Residual implications ⇒L, ⇒P , ⇒M are known as, respectively, the Lukasie-
wicz implication, the Goguen implication, the G¨odel implication.
For a given continuous t–norm T(x, y), the T–many–valued logic, for initial
logical ideas in the realm of fuzziness see Goguen [12] and Zadeh [52], see in
this respect H´ajek [17], is built of a countable set of propositional variables
{pi : i = 1, 2, ....} along with connectives (functors) & (strong conjunction), ∧
(conjunction), ∨(disjunction), ⇒(implication), ¬ (negation) and a constant
Z.
Formulas of the T–logic are built from propositional variables by means
of connectives. Semantics is deﬁned by interpreting & as T(x, y), ⇒as ⇒T ,
the constant Z as 0 and negation ¬ as ⇒T 0.
The Lukasiewicz logic has been already introduced and described in sect.
3.5: it is the logic of the Lukasiewicz t–norm and its residual implication.
Other logics, among others, are the product logic in which the implication
is evaluated as the residual implication ⇒P , the strong conjunction as the
product t–norm P(x, y), and negation ¬ as ¬G, and the G¨odel logic with,
respectively, ⇒M, Min(x, y), ¬G, representing semantically, respectively, the
implication, the strong conjunction, and negation. The reader may consult
H´ajek [17] for details concerning axiomatization and semantic models for
those logics.
For the purpose of future reference, we quote the axiomatic system of the
basic logic of H´ajek [17], i.e., the fuzzy logic whose theorems are valid under
any continuous t–norm induced semantics. The axioms are, see loc.cit.
1. (p ⇒q) ⇒((q ⇒r) ⇒(p ⇒r));
2. p&q ⇒p;
3. p&q ⇒q&p;
4. [p&(p ⇒q)] ⇒[q&(q ⇒p)];

3.7 Automated Reasoning
119
5. [(p&q) ⇒r] ⇔[p ⇒(q ⇒r)];
6. [(p ⇒q) ⇒r] ⇒[((p ⇒q) ⇒r) ⇒r];
7. Z ⇒p.
An important tool for automated reasoning, the resolution technique is dis-
cussed next.
3.7
Automated Reasoning
The old idea of Leibniz, of a symbolic reasoning performed in an automatic
way by a machine, realizes in the ﬁeld of, e.g., propositional calculus (a cor-
responding scheme holds for predicate calculus, among others). Deductive
reasoning employs devices known collectively as an inference engine which
allow to deduce a consequence from a set of premises. The set of premises
is often called a knowledge base, KB in symbols. A proof of a statement α
from KB is a sequence of statements (αi : i = 1, 2, ..., k) such that α1 ∈KB,
αk = α, and each αi is obtained from α1, ..., αi−1 by means of an applica-
tion of MP or αi ∈KB; a statement α provable from KB is KB–deductible,
KB ⊢α, in symbols. A model for KB is a valuation on sentential variables
under which all statements in KB are true. As MP preserves truth, it follows
that KB ⊢α entails that α is true in each model for KB; this fact is known
as semantic entailment, KB |= α, in symbols.
The inference problem consists in verifying whether a statement α follows
semantically (is entailed by) from a knowledge base KB. Propositional cal-
culus got to this end an automatic tool: the resolution technique of Robinson
[43]. Resolution is applied to formulas in the clausal conjunctive normal form
(CNF); to represent a formula α in CNF, one lists sentential variables in α
as p1, ..., pk and one considers all valuations on those k variables i.e., the set
2k = {0, 1}k. For each v ∈2k, one ﬁnds the truth value [α]v of α under v
and deﬁnes the set T(α) = {v ∈2k : [α]v = 1}. For each t ∈T ([α]), one lets
pt
i = pi in case t(pi) = 1 and pt
i = ¬pi in case t(pi) = 0. Then the formula

t∈T ([α])

i pt
i is disjunctive normal form (DNF) of α.
Well–known de Morgan formulas ¬(p ∨q) ⇔(¬p) ∧(¬q) and ¬(p ∧q) ⇔
(¬p) ∨(¬q) allow to produce CNF of α: ﬁrst, produce DNF of ¬α and then
convert it by the de Morgan laws to CNF of ¬¬α, i.e., to CNF of α. It follows
that CNF of α is a conjunction 
m Cm of clauses Cm : lm
1 ∨... ∨lm
jm, where
each lm
i
is a literal, i.e., it is of the form of a variable or its negation.
The technique of resolution rests on the resolution rule applied to pairs of
clauses l1 ∨... ∨lj, p1 ∨.... ∨pm which contain a pair li, pj of contradictory
literals, i.e., li is ¬pj,

120
3 Reasoning Patterns of Deductive Reasoning
Resolution rule :
l1 ∨... ∨li ∨... ∨lj, p1 ∨... ∨pj ∨... ∨pm
l1 ∨. ∨

li ∨.. ∨lj ∨p1 ∨... 
pj ∨... ∨pm
,
(3.28)
where the symbol

li
denotes the fact that the literal li is omitted in the
disjunction. In plain wording, the resolution rule allows for cancelation of
contradictory literals in two clauses, leading to one clause rid of the comple-
mentary pair. Successive application of the resolution rule to a set of clauses,
can result in one of the two ﬁnal outcomes: (1) the set of clauses does stabilize
without producing the empty clause ⊓⊔(2) the empty clause ⊓⊔is produced
at some step.
The empty clause ⊓⊔is unsatisﬁable, i.e., it is true under no valuation. As
the resolution rule yield true clauses from true clauses, the appearance of the
empty clause ⊓⊔does witness that the original set of clauses was unsatisﬁable.
It remains to observe that
Proposition 3.27. KB |= α if and only if the formula ( KB) ∧¬α is
unsatisﬁable,
in order to conclude that for veriﬁcation whether KB |= α it suﬃces to apply
the resolution rule recurrently to the set of clauses of the formula ( KB)∧¬α
until the result (1) or (2) is obtained. In case (2), KB |= α is conﬁrmed.
The satisﬁability problem SAT is known to be NP–complete since Cook
[6], hence the entailment problem is co–NP–complete. It is computationally
feasible, however, in a most important case of deﬁnite clauses. A Horn clause
is a clause l1 ∨... ∨lj in which at most one literal is positive, i.e., non–
negated, and a deﬁnite clause is a Horn clause with exactly one positive
literal. A tautology (p ⇒q) ⇔¬p ∨q allows to write down a deﬁnite clause
l1 ∨... ∨lj where lj is positive, as the implication j−1
i=1 ¬li ⇒lj, i.e., as
a decision rule or a fact in case when j = 1, i.e, the premise of the rule is
empty. Resolution with deﬁnite clauses and facts is linear in size of the clause
set, hence of practically low complexity, and in most cases of applications,
knowledge bases consist of Horn clauses.
These results transfer partially to T–logics. Let us denote with, respec-
tively, SAT(2), SAT(L), SAT(M), SAT(P), the sets of satisﬁable formulas of
propositional calculus, the Lukasiewicz logic, the G¨odel logic, and the product
logic, i.e., for each X = 2, L, M, P and α ∈SAT (X), there exists a valuation v
such that v(α) = 1. Clearly, each valuation for a proposition is a valuation for
fuzzy logics as well hence SAT (2) ⊆SAT (Y ) for Y = L, M, P. The converse
inclusions SAT (P), SAT(M) ⊆SAT(2) hold as well, see H´ajek [17], sect. 6.2,
hence SAT (P) = SAT (M) = SAT (2) and in consequence SAT (P), SAT(M)
are NP–complete. For the Lukasiewicz logic, one has SAT (2) ⊆SAT (L),
H´ajek loc. cit.; actually, SAT (L) is NP–complete, see Mundici [36].

3.8 Predicate Logic
121
3.8
Predicate Logic
Expressions that state a certain property of objects are called predicates. A
symbol P(x1, ..., xk) denotes a k–ary predicate which does express that a
k–tuple (x1, ..., xk) of objects has a property P. In addition to expressing
predicates, this calculus allows for saying that all objects have the given
property or some of them have it. To this end, quantiﬁers ∀(meaning: for
all) and ∃(meaning: there exists) are used: the formula ∀x.P(x) is read ‘all
objects substituted for x have the property P’ and the formula ∃x.P(x) reads
‘there is an object substituted for x which has the property P’.
As with propositional calculus, we discern in the structure of predicate
calculus various sets of symbols used to denote various types of variables,
and various types of objects we reason about and then we have some rules
to form meaningful expressions of the language of this calculus. Next, we
have some axioms, i.e., expressions we accept as true on the basis of their
syntax only and derivation rules used to produce in a systematic, as it were
mechanical way, theses of the system.
We are also taking into account the semantic aspect by deﬁning meanings
of expressions in order to select true expressions of the system. Finally, we
may compare semantic and syntactic aspects via, e.g., completeness prop-
erty. The predicate calculus is also called the ﬁrst order theory, ﬁrst order
functional calculus, and the term (pure) predicate calculus is reserved for a
theory in which no functional symbols intervene. In the coming presentation
of basic ideas and results about predicate calculus, we follow the exposition
in Rasiowa and Sikorski [42].
We will make use of the following sets of symbols
1. A countable set V of individual variables;
2. A countable set F of function symbols;
3. A countable set Pr of predicate symbols;
4. The set of propositional connectives ⇒, ¬, ∨, ∧;
5. The set of quantiﬁer symbols Q = {∀, ∃};
6. A set of auxiliary symbols {(, ), [, ], {, }, }.
From symbols, more complex expressions are constructed. We represent the
set F of function symbols as the union {Fn :∈N} and we call elements
of the set Fn n–ary function symbols for each n ∈N. From function sym-
bols, parentheses and individual variable symbols expressions called terms
are constructed; formally, a term is an expression of the form φ(τ1, ..., τm)
where φ ∈Fm and τ1, ..., τm have already been declared terms.

122
3 Reasoning Patterns of Deductive Reasoning
In order to make this idea into a formal deﬁnition, we resort to induction
on complexity of formulas involved, and we deﬁne the set T erm of terms as
the intersection of all sets X such that
1. All individual variable symbols are in X;
2. All 0-ary function symbols are in X;
3. For each n ≥1, if τ1, ..., τn are in X and φ is an n–ary function symbol,
then φ(τ1, ..., τn) is in X.
The set T erm is the least set satisfying requirements 1–3. Having terms
deﬁned, we proceed on to form more complex expressions, formulas, and
again we will perform this task in a few steps. So we deﬁne the set Form of
formulas as the intersection of all sets Y such that
1. For each m ≥1, if τ1, ..., τn are terms and ρ is an n–ary predicate symbol,
then ρ(τ1, ..., τn) is in Y ;
2. If α, β ∈Y , then ¬α, α ⇒β ∈Y ;
3. If α ∈Y , then ∀xα, ∃xα ∈Y .
Now, as with propositional calculus, we have to assign meanings to formulas
(meaningful expressions) of predicate calculus. Unlike in the former case, we
cannot assume the existence of two states for variables, i.e., truth and falsity.
To account for individual variables, we have to interpret them in a set. Thus,
we introduce the notion of an interpretation frame as a non–empty set I.
Given I, we deﬁne an interpretation in I as a function MI with properties,
1. For each n ∈N, MI maps each n–ary function symbol φ onto a function
fφ : In →I (in case n = 0, fφ is a constant, i.e., a ﬁxed element in I);
2. For each n ∈N, MI maps each n–ary predicate symbol ρ onto a relation
Rρ ⊆In.
Let us observe that under the function MI, formulas of predicate calculus
become propositional functions when in addition individual variable symbols
are interpreted as variables ranging over the set I. This means that to ev-
ery term of the form φ(x1, ..., xn), where x1, ..., xn are individual variable
symbols, the function MI assigns the function
fφ(x1, ..., xn) : In →I
where x1, ..., xn are variables ranging over I.

3.8 Predicate Logic
123
Clearly, in case of a term of the form φ(τ1, ..., τn), where τ1, ..., τn have
been assigned functions g1, ..., gn, with gj : Inj →I, the term φ(τ1, ..., τn) is
assigned the composition
fφ(g1(x1
1, ..., x1
n1), ..., gn(xn
1 , ..., xn
nn))
Then, to each formula of the form ρ(τ1, ..., τn), the function MI assigns the
propositional function
Rρ(g1(x1
1, ..., x1
n1), ..., gn(xn
1 , ..., xn
nn))
which becomes a proposition after substituting the speciﬁc elements of I for
variables xj
i. We will call such assignments elementary.
Now, in order to check the truth of formulas, we have to interpret in the
set I variables. To this end, we introduce the notion of a valuation being a
function v : V →I; thus, v assigns to each individual variable xi an element
v(xi) ∈I.
Under v, each elementary assignment becomes a proposition
Rρ(g1(v(x1
1), ..., v(x1
n1)), ..., gn(v(xn
1 ), ..., v(xn
nn)))
for an elementary assignment α, we denote by the symbol [[α]]v
M the logical
value (true/false) of α under the valuation v. In the sequel, when no confusion
is possible, we will denote this value with the symbol [[α]]v.
Having deﬁned elementary assignments, we deﬁne truth values of more
complex formulas under any valuation v, see Tarski [47]. To this end, we let
1. [[¬α]]v = 1 if and only if [[α]]v = 0;
2. [[α ⇒β]]v = 1 if and only if either [[α]]v = 0 or [[β]]v = 1;
3. [[∀xα]]v = 1 if and only if [[α]]v(x/c) = 1 for every choice of c ∈I, where
v(x/c) is the valuation v in which the value v(x) is changed to c;
4. [[∃xα]]v = 1 if and only if [[α]]v(x/c) = 1 for some choice of c ∈I.
Let us observe that valuation of a formula obtained by means of proposi-
tional connectives corresponds to the case of propositions and interpretation
of quantiﬁers in symbolic formulae is done by a common–sense interpretation
of phrases ”every choice”, ”some choice”.
We call a formula α true under MI in I when [[α]]v = 1 for every valuation
v. The formula α is said to be true in I when it is true under every function
MI. Finally, α is true if and only if it is true in every interpretation frame I.
We now apply this notion of truth towards the exhibition of basic deriva-
tion rules in formal syntax of predicate calculus.

124
3 Reasoning Patterns of Deductive Reasoning
We formulate the detachment rule as usual, i.e., if α, α ⇒β are theorems,
then β is accepted as a theorem. The substitution rule (S) will be modiﬁed
adequately to the predicate calculus case as follows.
For a formula ∀xα as well as for a formula ∃xα, if x occurs in α then we
say that x is bound in α; any variable y not bound by a quantiﬁer is free in α.
To denote free variables in α we will write α(x1, .., xk) in place of α and all
other variables not listed in α(x1, .., xk) are either bound or do not occur in α.
(S) (Substitution for free individual variables) If α(x1, ..., xk) is a the-
orem and τ1, ..., τk are terms then the formula α(τ1, ..., τk) obtained from
α(x1, ..., xk) by the substitution x1/τ1, ..., xk/τk is accepted as a theorem.
We observe that
Proposition 3.28. The detachment rule and the substitution rule give true
formulas when applied to true formulas.
Proof. For the case of detachment, if α, α ⇒β are true then for every I, MI
and every valuation v we have [[α]]v = 1 hence as [[α ⇒β]]v = 1 we have
[[β]]v = 1, i.e., β is true.
For substitution, if [[α(x1, ..., xk)]]v = 1 for every v then clearly [[α(τ1, ...,
τk)]]v = 1 for every v as in the latter formula values taken by τ1, ..., τk form
a subset of Ik which is the set of values taken by (x1, ..., xk) in the former
formula
⊓⊔
We turn to rules governing use of quantiﬁers; these rules describe, respec-
tively, admissible cases in which we introduce, respectively, omit, quantiﬁer
symbols.
IE (Introduction of existential quantiﬁer ) For formulas α(x), β with y
not bound in α(x) if α(x) ⇒β is true then ∃yα(y) ⇒β is true
IU (Introduction of universal quantiﬁer) For formulas α, β(x) with no oc-
currence of x in α and y not bound in α if α ⇒β(x) is true, then α ⇒∀xβ(x)
is true
EE (Elimination of existential quantiﬁer ) For formulas α(x), β with no oc-
currence of bound variable y in α(x) if ∃yα(y) ⇒β is true, then α(x)β is true
EU (Elimination of universal quantiﬁer ) For formulas α, β(x) with no
occurrence of bound variable y in β(x) if α ⇒∀yβ(y) is true then α ⇒β(x)
is true
We will deﬁne formally syntax of predicate calculus. We will take as ax-
ioms the following schemes

3.8 Predicate Logic
125
T1 (α ⇒β) ⇒[(α ⇒γ) ⇒(β ⇒γ)]
T2 (¬αα) ⇒α
T3 α ⇒(¬α ⇒β)
and we use detachment MP, substitution for free variables S, IE, IU, EE,
and EU as derivation rules.
The symbol 2 denotes the Boolean algebra consisting of truth values 0, 1
with Boolean operations x ∪y = max{x, y}, x ∩y = min{x, y}, −x = 1 −x,
x ⇒y = −x ∪y and distinguished elements 0 < 1.
As with propositional calculus, we construct the Lindenbaum–Tarski alge-
bra of predicate calculus LT(Pred), by considering the equivalence relation
≈deﬁned as before by the condition that α ≈β if and only if α ⇒β and
β ⇒α are theorems of predicate calculus.
We denote by the symbol [[α]]≈the equivalence class of α with respect to
≈. The Lindenbaum–Tarski algebra of predicate calculus is a Boolean algebra
(cf., a historic note in Rasiowa and Sikorski [42], pp 209, 245–6). The ordering
≤L is deﬁned as before by [[α]]≈≤L [[β]]≈if and only if α ⇒β is a theorem.
Proposition 3.29. (Rasiowa and Sikorski [42]) The algebra Form/ ≈is a
Boolean algebra with operations
1. [[α]]≈∪[[β]]≈= [[α ∨β]]≈;
2. [[α]]≈∩[[β]]≈= [[α ∧β]]≈;
3. [[α]]≈⇒[[β]]≈= [[α ⇒β]]≈;
4. −[[α]]≈= [[¬α]]≈.
Moreover, for each formula of the form α(x), we have
5. [[∃yα(y)]]≈= sup{[[α(τ)]]≈: τ ∈T erm}, where α(τ) comes from α(x)
as a result of substitution of a term τ for the free variable x.
6. [[∀yα(y)]]≈= inf{[[α(τ)]]≈: τ ∈T erm}.
Proof. We ﬁrst show that [[α ∨β]]≈is the join of classes [[α]]≈, [[β]]≈; the
theorem
α ⇒(α ∨β)
implies that
[[α]]≈≤L [[α ∨β]]≈
(3.29)
and, similarly,
[[β]]≈≤L [[α ∨β]]≈
(3.30)

126
3 Reasoning Patterns of Deductive Reasoning
hence,
[[α]]≈∪[[β]]≈≤L [[α ∨β]]≈
(3.31)
On the other hand, if [[α]]≈≤L [[γ]]≈and [[β]]≈≤L [[γ]]≈, i.e., α ⇒γ and
β ⇒γ are theorems, then applying detachment twice to the theorem
(α ⇒γ) ⇒[(β ⇒γ) ⇒(α ∨β) ⇒γ]
we get (α ∨β) ⇒γ, i.e.,
[[α ∨β]]≈≤L [[γ]]≈
(3.32)
It follows that
[[α]]≈∪[[β]]≈= [[α ∨β]]≈
(3.33)
A similar proof shows that
[[α]]≈∩[[β]]≈= [[α ∧β]]≈
(3.34)
To show distributivity, it suﬃces to prove the existence of a relative pseudo–
complementation, cf., Ch. 1, sect. 14.
For classes [[α]]≈, [[β]]≈, we prove that
[[α]]≈⇒[[β]]≈= [[α ⇒β]]≈
(3.35)
To this end, consider any [[γ]]≈with the property that
[[α]]≈∩[[γ]]≈≤L [[β]]≈
i.e., (α ∧γ) ⇒β is a theorem. It follows from a theorem
[(α ∧γ) ⇒β] ⇒(γ ⇒(α ⇒β)
via detachment that γ ⇒(α ⇒β) is a theorem, i.e., [[γ]]≈≤L [[α ⇒β]]≈.
To conclude this part of the proof it suﬃces to consider the theorem [α ⇒
(β ∧α)] ⇒β, which implies that
[[α ⇒(β ∧α)]]≈= [[α ⇒β]]≈∩[[α]]≈≤L [[β]]≈
(3.36)
It follows that [[α ⇒β]]≈is the relative pseudo–complement [[α]]≈⇒[[β]]≈.
In consequence of the last proved fact, there exists the unit element in this
lattice, 1 and
1 = [[α ⇒α]]≈= [[α]]≈⇒[[α]]≈
(3.37)
for each α. As (α ∧¬α) ⇒β is a theorem, we have,
[[α ∧¬α]]≈= [[α]]≈∩[[¬α]]≈≤L [[β]]≈

3.8 Predicate Logic
127
for any formula β, i.e., [[α ∧¬α]]≈is the null element 0. Thus
[[α]]≈∩[[¬α]]≈= 0
(3.38)
i.e., [[¬α]]≈≤L −[[α]]≈. The theorem [α ⇒(α ∧¬α)] ⇒¬α implies,
[[α ⇒(α ∧¬α)]]≈= [[α]]≈⇒0 = −[[α ≤L [[¬α]]≈
(3.39)
hence, [[¬α]]≈= −[[α]]≈. Finally, the theorem α ∨¬α renders the equality
[[α]]≈∪−[[α]]≈= 1
(3.40)
for each formula α, i.e., −[[α]]≈is the complement of [[α]]≈and Form/ ≈is
a Boolean algebra.
There remain statements 5 and 6 to verify. Let us look at statement 5,
and consider a formula α(x). As the set of individual variable symbols is
inﬁnite, there exists a variable symbol y which does not occur in α(x) and
no quantiﬁer in α(x) binds y; as γ ⇒γ is a theorem of predicate calculus
for every formula γ, also the formula ∃yα(y) ⇒∃yα(y) is a theorem and the
derivation rule EE (of elimination of existential quantiﬁer) yields the theorem
α(x) ⇒∃yα(y).
Substitution of a term τ for the free variable x in the last theorem via the
substitution rule gives us the theorem α(τ) ⇒∃yα(y). Thus [[α(τ)]]≈≤L
[[∃yα(y)]]≈for every term τ ∈T erm.
It follows that
sup{[[α(τ)]]≈: τ ∈T erm} ≤L [[∃yα(y)]]≈
(3.41)
For the converse, let us assume that for some formula γ
[[α(τ)]]≈≤L [[γ]]≈
(3.42)
for every term τ ∈T erm. We may ﬁnd a variable z which does not occur in γ;
as [[α(z)]]≈≤L [[γ]]≈, i.e., α(y) ⇒γ, it follows by the rule IE (of introduction
of existential quantiﬁer) that ∃yα(y) ⇒γ is a theorem, i.e.,
[[∃yα(y)]]≈≤L [[γ]]≈
(3.43)
Hence,
[[∃yα(y)]]≈= sup{[[α(τ)]]≈: τ ∈T erm}
(3.44)
The statement 6 may be proved on similar lines, with rules EU, IU in place
of rules EE, IE (these results are due to Rasiowa [41], [40] and Henkin [18],
cf., Rasiowa and Sikorski [42], p. 251)
⊓⊔

128
3 Reasoning Patterns of Deductive Reasoning
The equalities
1. [[∃yα(y)]]≈= sup{[[α(τ)]]≈: τ ∈T erm}.
2. [[∀yα(y)]]≈= inf{[[α(τ)]]≈: τ ∈T erm},
are called (Q)–joins and meets, respectively, see Rasiowa and Sikorski. [42]
We now may produce a proof of the main result bridging syntax and se-
mantics of predicate calculus.
Proposition 3.30. A formula α of predicate calculus is a theorem if and
only if [[α]]≈= 1.
Proof. (after Rasiowa and Sikorski [42]) Assume that α is a theorem. By the
theorem α ⇒CCααα of predicate calculus, it follows via detachment that
(α ⇒α) ⇒α is a theorem, hence, [[α ⇒α]]≈≤L [[α]]≈, i.e., 1 ≤L [[α]]≈and
thus 1 = [[α]]≈.
Conversely, in case [[α]]≈= 1 we have [[β]]≈≤L [[α]]≈for each β, hence, in
particular, [[α ⇒α]]≈≤L [[β]]≈, i.e., (α ⇒α) ⇒α is a theorem and detach-
ment yields that α is a theorem
⊓⊔
We should now extend the last result to any interpretation. Consider an
interpretation frame I along with an interpretation MI and a valuation v.
Then we have the following result.
Proposition 3.31. For any formulas α, β of predicate calculus, if [[α]]≈=
[[β]]≈, then [[α]]v
M = [[β]]v
M.
Proof. Assume that [[α]]≈| = [[β]]≈i.e. the formulas α ⇒β and β ⇒α are
theorems of predicate calculus. Then the conditions hold,
1. Either [[α]]v
M = 0 or [[β]]v
M = 1.
2. Either [[β]]v
M = 0 or [[α]]v
M = 1.
The conjunction of conditions 1 and 2 results in the condition,
[[α]]v
M = 0 = [[β]]v
M ∨[[α]]v
M = 1 = [[β]]v
M
i.e., [[α]]v
M = [[β]]v
M
⊓⊔
This result shows that the function [[·]]v
M deﬁned by the valuation v from the
set Form of formulas of predicate calculus into the Boolean algebra 2 can be
factored through the Boolean algebra Form/ ≈:
[[·]]v
M = h ◦q(·)
where q : Form →Form/ ≈is the quotient function and h : Form/ ≈→2
is deﬁned by the formula
h([[α]]≈) = [[α]]v
M
Actually, more is true,

3.8 Predicate Logic
129
Proposition 3.32. (Rasiowa and Sikorski, op.cit.) The function h : Form/
≈→2 is a homomorphism preserving (Q) –joins and (Q)–meets.
Proof. Given formulas α, β of predicate calculus, we have
h([[α]]≈∪[[β]]≈) = h([[α ∨β]]≈) = [[α ∨β]]v
M = [[α]]v
M ∪[[β]]v
M =
h([[α]]≈∪h([[β]]≈)
Similarly,
h([[α]]≈∩[[β]]≈) = h([[α]]≈) ∩h([[β]]≈)
and
h(−[[α]]≈) = −h([[α]]≈)
Moreover,
h(1) = h([[α ∨¬α]]≈) = [[α]]v
M ∪[[¬α]]v
M = 1
For (Q)–joins, we have
h([[∃yα(y)]]≈) = [[∃yα(y)]]v
M = supx[[α(y)]]v(y/x)
M
= supτ[[α(τ)]]v
M =
supτh([[α(τ)]]≈)
Similarly, the result for meets follows
⊓⊔
We may now sum up latest developments in a version of completeness theo-
rem. Completeness of predicate calculus was ﬁrst demonstrated in G¨odel [14].
Proposition 3.33. (after Rasiowa and Sikorski [42]) (A completeness theo-
rem for predicate calculus) The following statements are equivalent for each
formula α of predicate calculus.
1. α is a theorem of predicate calculus;
2. h([[α]]≈) = 1B where 1B is the unit element in the algebra B for every
interpretation frame I, h, B which preserves (Q)–meets and (Q)–joins;
3. [[α]]≈= 1.
Proof. Property 1 implies Property 2 by Propositions 3.30, 3.31 and Property
2 implies Property 3 obviously. That Property 3 implies Property 1 is one
part of Proposition 3.30
⊓⊔
As with propositional calculus, completeness allows us for verifying whether
a formula is a theorem on semantic grounds. For instance the following list
consists of ‘standard’ often in use theorems of predicate calculus.
Proposition 3.34. The following are theorems of predicate calculus

130
3 Reasoning Patterns of Deductive Reasoning
1. ∀xα(x) ∨β ⇒∀x(α(x) ∨β);
2. ∀x(α(x) ∨β) ⇒∀xα(x) ∨β;
3. ∃xα(x) ∨β ⇒∃x(α(x) ∨β));
4. ∃x(α(x) ∨β) ⇒∃xα(x) ∨β;
5. ∀xα(x) ∧β ⇒∀x(α(x) ∧β);
6. ∀x(α(x) ∧β) ⇒∀xα(x) ∧β;
7. ∃xα(x) ∧β ⇒∃x(α(x) ∧β);
8. ∃x(α(x) ∧β) ⇒∃xα(x) ∧β;
9. ∀xα(x) ⇒∃xα(x);
10. ∀x(α(x) ⇒β) ⇒(∃α(x) ⇒β);
11. (∃α(x) ⇒β) ⇒∀x(α(x) ⇒β);
12. ∀x(α(x) ⇒β) ⇒(∃xα(x) ⇒β);
13. (∃xα(x) ⇒β) ⇒∀x(α(x) ⇒β);
14. ∀x(α ⇒β(x)) ⇒(α ⇒∀xβ(x));
15. ∀x(α(x) ⇒β(x)) ⇒(∀xα(x) ⇒∀xβ(x));
16. ∀x(α(x) ⇒β(x)) ⇒(∃xα(x) ⇒∃xβ(x));
17. ∀xα(x) ∧β(x) ⇒∀xα(x) ∧∀xβ(x);
18. ∀xα(x) ∧∀xβ(x) ⇒∀xα(x) ∧β(x);
19. (∃xα(x) ∨β(x)) ⇒∃xα(x) ∨∃xβ(x);
20. ∃xα(x) ∨∃xβ(x) ⇒∃x(α(x) ∨β(x));
21. ∀xα(x) ∨∀xβ(x) ⇒∀x(α(x) ∨β(x));
22. ∃xα(x) ∧β(x) ⇒∃xα(x) ∧∃xβ(x).

3.8 Predicate Logic
131
From the completeness theorem some consequences follow of which we would
like to remark on the following.
1. Predicate calculus is consistent (meaning that there is no formula α such
that both α and ¬α are theorems); indeed as [[α]]≈= 1 it implies that
[[¬α]]≈= 0;
2. For a formula
α(x1, .., xk) with free variable symbols x1, ..., xk, we call
syntactic closure of α(x1, .., xk) the formula
∀y1∀y2...∀ykα(x1/y1, .., xk/xk)
It follows from the semantic interpretation that α(x1, .., xk) is a tautology
of predicate calculus if and only if the syntactic closure
∀y1∀y2...∀ykα(x1/y1, .., xk/yk)
is a tautology of predicate calculus;
3. A formula α is prenex if all quantiﬁer operations in α precede predicate
operations, i.e., α is of the form
Qx1...Qxmβ(x1, .., xm),
where β(x1, ..., xm) is quantiﬁer–free and the symbol Q stands for ∀, ∃.
A prenex formula α which is equivalent to a formula γ, i.e., both γ ⇒α
and α ⇒γ are theorems is said to be the prenex form of the formula γ.
We have
Proposition 3.35. For every formula γ there exists a prenex form α of γ.
Proof. We can construct a prenex form of α by structural induction. Elemen-
tary formulas of the form ρ(τ1, ..., τm) are already prenex. If formulas α, β are
in prenex forms, respectively,
Qx1...Qxmγ(x1, ..., xm), Qy1...Qykδ(y1, ..., yk)
where variables xi do not occur in δ and variables y1, .., yk do not occur in
γ, then α ∨β, i.e.,
Qx1...Qxmγ(x1, ..., xm) ∨Qy1...Qykδ(y1, ..., yk)
(3.45)
may be represented equivalently by virtue of Proposition 3.34 1–4 as
Qx1[Qx2...Qxmγ(x1, ..., xm) ∨Qy1...Qykδ(y1, ..., yk)]
(3.46)

132
3 Reasoning Patterns of Deductive Reasoning
and by successive repeating of 1–4 we arrive ﬁnally at
Qx1...QxmQy1...Qyk[γ(x1, ..., xm) ∨δ(y1, ..., yk)]
(3.47)
which is a prenex form of α ∨β.
A similar argument using theses 5–8 of Proposition 3.34 in place of the-
ses 1–4 will give a prenex form of α ∧β. Letting Q∗= ∀in case Q = ∃and
Q∗= ∃in case Q = ∀, we may write down the formula ¬α in the prenex form
Q∗x1...Q∗xm¬γ(x1, .., xm). Finally, if α∗is a prenex form of α then Qxα∗is a
prenex form of Qxα
⊓⊔
A formula is open, when there are no occurrences of quantiﬁer symbols in
it. Denoting by the symbol Form0 the set of all open formulas of predicate
calculus, we may deﬁne a theorems of this calculus as an expression which may
be derived from axioms by means of detachment and substitution rules only.
Thus, a theorem of the calculus of open expressions is a theorem of predicate
calculus as well. Denoting by [[α]]0
≈the element of the Lindenbaum–Tarski
algebra of the open formulas calculus, we have the following
Proposition 3.36. (Rasiowa and Sikorski [42], Thm. 15.6) The function h
assigning
to
the
class
[[α]]0
≈
the
class
[[α]]≈
is
an
isomorphism
of the Lindenbaum–Tarski algebra of calculus of open expressions with the
Lindenbaum–Tarski algebra of predicate calculus.
We now consider a particular case when all predicates are unary, i.e., they
require a single argument, so they are of the form P(x). It turns out that
in this case when verifying truth of formulas, we may restrict ourselves to
interpretation frames of small cardinality,
Proposition 3.37. (Rasiowa and Sikorski [42]) For a formula α(P1, ..., Pk;
x1, . .., xn) where P1, ..., Pk are all (unary) predicate symbols occurring in α
and x1, ..., xn are all variable symbols in α, if α(P1, ..., Pk; x1, ..., xn) is true
in an interpretation frame M, then it is also true in an interpretation frame
M ∗⊆M such that cardinality |M ∗| is at most 2k.
Proof. We may assume that α is in prenex form
Qx1...Qxmβ(P1, ..., Pk; x1, ..., xn),
and for each sequence I = i1, ..., ik of 0′s and 1′s, we may form the set
M(I) = {x ∈M : [[Pm(x)]] = im; m = 1, ..., k}. Then the family P =
{M(I) : I ∈{0, 1}k} is a partition of the set M.
We may select then for each x ∈M the partition element P (x) containing
x and for each non–empty set P (x) we may select an element s(x) ∈P (x).
Then the set M ∗= {s(x) : x ∈M} has cardinality at most that of the set
{0, 1}k, i.e., 2k
⊓⊔

3.9 Modal Logics
133
Let us observe that formulas

(i) β(P1, ..., Pk; x1, ..., xn)
(ii) β(P1, ..., Pk; s(x1), ..., s(xn))
(3.48)
are equivalent, hence,
[[(Qx1...Qxmβ(P1, ..., Pk; x1, ..., xn]]v
M =
[[Qx1...Qxmβ(P1, ..., Pk; s(x1), ..., s(xn)]]s(v)
M
=
[[Qx1...Qxmβ(P1, ..., Pk; x1, ..., xn)]]s(v)
M∗
It follows that α is true in M if and only if α is true in M ∗.
In consequence of the above result, in order to verify the truth of α, it is
suﬃcient to check its truth on a set M with |M| ≤2k. In this case α reduces
to the proposition, e.g., in case α is ∀xP(x) the corresponding proposition is
P(x1) ∧... ∧P(x2k).
Thus to verify the truth of this proposition, we may employ the method
of truth tables known in propositional calculus. This method requires a ﬁnite
number of steps, in our exemplary case at most 22k. It follows that calculus
of unary predicates is decidable. Let us mention that in general predicate
calculus is undecidable.
3.9
Modal Logics
Somewhat at crossroads between deductive and inductive reasoning, modal
logics are endowed with a formal deductive mechanisms, yet they qualify
their statements as necessarily true or possibly true, giving in this way a
subjective touch to their formulas. Modal expressions appear in Aristotle, see
Lukasiewicz [31], e.g., a statement ‘tomorrow there is a sea–battle’. Also in
Aristotle there appear basic postulates about the semantic nature of necessity
L and possibility M, i.e., the duality postulate
Lα ⇔¬M¬α
(3.49)
and the postulate (K), viz.,
(K) L(α ⇒β) ⇒(Lα ⇒Lβ)
(3.50)
3.9.1
Modal Logic K
Syntax of K in addition to propositional variables and propositional con-
nectives is endowed with the necessity functor L, and the set of formulas is
enlarged by addition of the rule that if α is a formula, then Lα is a formula.

134
3 Reasoning Patterns of Deductive Reasoning
Axiom schemes for K are are axiom schemes T1–T3 for propositional calcu-
lus, and the axiom scheme (K). Derivation rules are substitution, detachment
and a new necessitation rule
α
Lα
(3.51)
Semantics for modal logics grew from analysis of intensional utterances going
back to Frege’s ‘Sinn und Bedeutung’ [10], in which sense (Sinn) and reference
(Bedeutung) are two facets of a statement, the ﬁrst responsible for the modus
of utterance and the second for the object referred by the utterance to.
A classical example is provided by the utterances ‘The morning star’ and
‘The evening star’ which both refer to the planet Venus by means of distinct
senses. This idea got a happy form in Carnap [4] who introduced the notion
of a state and interpreted intensional statements semantically as functions on
the set of states into logical values. A ﬁnal form modal semantics acquired in
Kripke [21] where possible world semantics was introduced. Montague [35],
Gallin [11], Van Benthem [1] introduce into intensional logic, and Hughes and
Creswell [20] is a tract on modal logic.
Kripke semantics uses a set W of possible worlds along with an accessibility
relation R ⊆W × W. The pair (W, R) is a frame. A valuation v assigns to
each propositional variable p and each world w in the frame (W, R) a value
v(p, w) ∈{T, F} in the set of truth (T) and falsity (F). By standard truth
tables, this assignment determines the value v(α, w) of each propositional
formula α at each w, i.e.,
1. v(¬α, w) = T ⇔v(α, w) = F;
2. v(α ∨β, w) = T ⇔v(α, w) = T or v(β, w) = T;
3. v(α ∧β, w) = T ⇔v(α, w) = T and v(β, w) = T;
4. v(α ⇒β, w) = F ⇔v(α, w) = T and v(β, w) = F.
The value v(Lα, w) is determined by means of the accessibility relation R;
v(Lα, w) = T if and only if v(α, w1) = T for each world w1 ∈W such that
(w, w1) ∈R, i.e., w1 is accessible from w.
A modal formula α is true in the frame (W, R) when v(α, w) = T for each
valuation v and each world w ∈W. A formula α is a tautology of the modal
logic K if and only if α is true in each frame (W, R).
One can for instance check the validity of (K); for an arbitrary frame (W, R)
and a valuation v, for an arbitrary world w ∈W, assume that v(L(α ⇒
β), w) = T and v(Lα, w) = T. Consider an arbitrary world w1 accessible
from w, i.e., (w, w1) ∈R. By assumptions, v(α ⇒β, w1) = T, v(α, w1) = T,
hence, v(β, w1) = T by 4 above. It follows that v(Lβ, w) = T proving that
(K) is a tautology.

3.9 Modal Logics
135
This argument proves as well that detachment preserves tautologies and that
axiom schemes T1–T3 have as their instances tautologies. Obviously, neces-
sitation leads from tautologies to tautologies. Hence,
Proposition 3.38. Each formula which has a proof from axioms in modal
logic K is a tautology of this logic.
Modal logic K is complete. The proof employs the technique due to Lemmon
and Scott [22] of canonical models, cf., Hughes and Creswell [20]. Informally
speaking, these are frames in which worlds are construed as maximal consis-
tent sets of formulas.
Let us recall that a set Γ of formulas is consistent if and only if there is
no formula α with Γ ⊢α and Γ ⊢Nα. In this case we use a meta–predicate
Con and Con(Γ) would mean that Γ is consistent.
We will say that Γ is maximal consistent if and only if Con(Γ) and for
every consistent set Δ if Γ ⊆Δ then Γ = Δ. We use a meta–predicate
Conmax to denote this fact so Conmax(Γ) would mean that Γ is maximal
consistent. We list some basic properties of maximal consistent sets.
Proposition 3.39. For Γ with Conmax(Γ), the following hold
1. for every α: α ∈Γ if and only if Nα /∈Γ;
2. α ∨β ∈Γ if and only if α ∈Γ or β ∈Γ;
3. α ∧β ∈Γ if and only if α ∈Γ and β ∈Γ;
4. if ⊢α then α ∈Γ;
5. if α ∈Γ and α ⇒β ∈Γ then β ∈Γ.
Proof. In case of Property 1, assume that α /∈Γ for a meaningful expression
α. This means that Γ ∪{α} is not consistent, a fortiori for a ﬁnite subset
Λ ⊆Γ we have Λ, α ⊢δ and Λ, α ⊢Nδ.
By the deduction theorem, we have Λ ⊢α ⇒δ, Λ ⊢α ⇒¬δ. By the
theorem (p ⇒q) ⇒(p ⇒¬q) ⇒p in which we substitute p/α, q/δ we have
applying detachment twice that Λ ⊢¬α.
It follows that Γ ∪¬α is consistent hence ¬α ∈Γ.
For Property 2, assume to the contrary α∨β ∈Γ, α /∈Γ and β /∈Γ. Then,
by already proven Property 1, ¬α, ¬β ∈Γ and by the theorem p ⇒(q ⇒
(p∧q))) with substitutions p/¬α, q/¬β we obtain applying detachment twice
that Γ ⊢¬α∧¬β i.e. Γ ⊢¬(α∨β) hence Γ is not consistent, a contradiction.
The proof of Property 3 is on the same lines. For Property 4, it is manifest
that ⊢α implies Γ ∪{α} consistent hence by maximality α ∈Γ. Property 5
follows from Property 1 as α ⇒β is equivalent to ¬α ∨β so α ∈Γ implies
β ∈Γ
⊓⊔

136
3 Reasoning Patterns of Deductive Reasoning
Let us also observe that a set Γ of meaningful expressions is consistent if and
only if for no ﬁnite subset Λ ⊆Γ we have ⊢¬  Λ. Indeed, to see necessity
of this condition, assume Γ consistent and ⊢¬  Λ for some ﬁnite subset
Λ ⊆Γ. By the theorem p ⇒(q ⇒(p ∧q)) applied |Λ| −1 times, we get
Γ ⊢ Λ hence Γ ⊢ Λ, ¬  Λ contradicting the consistency of Γ.
To see suﬃciency, assume that Γ is not consistent, i.e., Γ ⊢β, ¬β for some
meaningful expression β. By compactness, Λ ⊢β, ¬β for some ﬁnite Λ ⊆Γ.
Let Λ = {γ1, ..., γk}; by the theorem p1 ∧... ∧pk ⇒pi for i = 1, 2, ..., k,
it follows that  Λ ⊢β, ¬β and then the theorem (p ⇒q) ∧(p ⇒¬q) ⇒¬p
implies that ⊢¬  Λ. Thus Γ is not consistent.
We now deﬁne a canonical interpretation frame M c = (W c, Rc, vc) by
letting
1. W c = {Γ : Conmax(Γ)}, i.e., worlds are maximal consistent sets of mean-
ingful expressions;
2. ΓRcΓ ′ if and only if Lα ∈Γ implies α ∈Γ ′ for every meaningful expres-
sion α;
3. vc(Γ, p) = 1 if and only if p ∈Γ.
We then have,
Proposition 3.40. For each meaningful expression α of the system K, we
have vc(Γ, α) = 1 if and only if α ∈Γ.
Proof. By induction on structural complexity of α. We will assume that α, β
already satisfy our claim. For ¬α, we have vc(Γ, ¬α) = 1 if and only if
vc(Γ, α) = 0, i.e., α /∈Γ which by Proposition 3.39 (1) is equivalent to
¬α ∈Γ.
For α ⇒β, we have vc(Γ, α ⇒β) = 1 if and only if vc(Γ, α) = 0 or
vc(Γ, β) = 1, i.e., α /∈Γ or β ∈Γ, i.e., ¬α ∨β ∈Γ by Proposition 3.39 (3),
i.e., α ⇒β ∈Γ.
Finally, we consider Lα; there are two cases
(i) Lα ∈Γ (ii) Lα /∈Γ
In case (i), for every Γ ′ with ΓRcΓ ′ we have α ∈Γ ′, i.e., vc(Γ ′, α) = 1 from
which vc(Γ, Lα) = 1 follows. In case (ii), when Lα /∈Γ, we have ¬Lα ∈Γ.
We check that the following holds.
Claim Con({δ : Lδ ∈Γ} ∪{¬α})
Indeed, was the contrary true, we would have a ﬁnite set {γ1, ..., γk} with
{Lγ1, .., Lγk} ⊆Γ such that ⊢¬(γ1 ∧... ∧γk ∧¬α), i.e., ⊢Cγ1 ∧... ∧γkα
hence ⊢LCγ1∧...∧γkα by necessitation and thus it follows by the axiom (K)
that ⊢CLγ1 ∧... ∧LγkLα implying that ⊢¬(Lγ1 ∧... ∧Lγk ∧¬Lα) contrary
to the facts that Con(Γ) and {Lγ1, ..., Lγk, ¬Lα} ⊆Γ. Our claim is proved.

3.9 Modal Logics
137
Now, as {δ : Lδ ∈Γ} ∪{¬α} is consistent it extends to a maximal con-
sistent set Γ ′; clearly, ΓRcΓ ′; as Nα ∈Γ ′ we have vc(Γ ′, α) = 0 and ﬁnally
vc(Γ, Lα) = 0
⊓⊔
We may now state the main result of this discussion.
Proposition 3.41. (The Completeness Theorem) |= α implies ⊢α for every
formula α.
Proof. Implication: if |= α, then ⊢α is equivalent to the implication (i) if non
⊢α, then non |= α or, equivalently, if non ⊢α then there exists M = (W, R, v)
with v(α, w) = 0 for some w ∈W.
As the condition non ⊢¬α is equivalent to the condition Con({α}) one
may formulate a condition equivalent to (i), viz., (ii) if Con(α), then there
exists M = (W, R, v) with v(α, w) = 1 for some w ∈W.
But, Con({α}) implies the existence of Γ with Conmax(Γ) and α ∈Γ
hence in the canonical interpretation frame M c we have vc(Γ, α) = 1 proving
(ii) hence (i) and the completeness theorem as well
⊓⊔
We apply the completeness theorem to verify that the formula Lp ⇒p is not
a tautology of the system K.
It is suﬃcient to consider an interpretation frame M = (W, R, v) in which
there are worlds w ̸= w∗∈W with W = {w, w∗}, wRw∗, non wRw, v(p, w) =
0, and v(p, w∗) = 1. Then |=M Lp and non |=M p thus non |=M Lp ⇒p.
3.9.2
Modal Logic T
Adding to the axiom schemes of the system K a new axiom scheme, Feys [7]
(T ) Lα ⇒α
(3.52)
would lead to a new system denoted T . The collapse method shows that T
is consistent.
Let us observe that the axiom (T) is true in every interpretation frame
M = (W, R, v) in which the relation R is reﬂexive, i.e., wRw for each w ∈W.
If v(Lα, w) = 1 for a w ∈W, then v(α, w1) = 1 for each w1 with (w, w1) ∈R,
hence, v(α, w) = 1 and v(Lα ⇒α, w) = 1 for each w ∈W. The converse is
also true: if (T) is true in an interpretation frame M = (W, R, v) then R is
reﬂexive.
We may state a completeness theorem for the system T . We denote by the
symbol Mr the set of all interpretation frames with the relation R reﬂexive.
Proposition 3.42. (The Completeness Theorem for T ) For each formula α,
α is derivable in T if and only if α is true in every frame in Mr.

138
3 Reasoning Patterns of Deductive Reasoning
3.9.3
Modal Logic S4
We may look at the formula
(S4) Lα ⇒LLα
(3.53)
see, Lewis and Langford [23]
It is easy to see that (S4) is true in an interpretation frame M = (W, R, v)
if and only if R is transitive, i.e., (w, w1) ∈R and (w1, w2) ∈R imply
(w, w2) ∈R for each triple w, w1, w2 ∈W.
Adding (S4) to T gives a new consistent system S4. Let us observe that
we may introduce graded modalities: for n ∈N, we deﬁne the modality
Ln as follows: L0p = p, Ln+1p = LLnp. Then (S4) yields by subsequent
substitutions ⊢Lnα ⇒Ln+1α for each n ∈N. As T allows for the converse,
⊢Ln+1α ⇒Lnα for each n ∈N, we ﬁnally get in S4 equivalences Lα ⇔Lnα
for n = 2, 3, ....
As truth of (T) forces R to be reﬂexive and truth of (S4) forces R to be
transitive, we get a completeness theorem for the system S4 by considering
the set Mrt of frames in which the relation R is reﬂexive and transitive.
Proposition 3.43. (The Completeness Theorem for S4) For each formula
α, α is derivable in S4 if and only if α is true in every frame in Mrt.
3.9.4
Modal Logic S5
Let us now consider the formula
(S5) Mα ⇒LMα
(3.54)
see Lewis and Langford [23]. It is distinct from the previously considered in
that it does express a certain interplay between the two modalities L and M.
We observe,
Proposition 3.44. In the system obtained by adding (S5) to the system T
we obtain (S4).
Proof. First, the axiom (T): Lα ⇒α may be dualized to
Nα ⇒NLα
and by the tautology
α ⇒NNα
it may be restated as
Nα ⇒NLNNα
i.e.,
Nα ⇒MNα

3.9 Modal Logics
139
hence, substituting α/Nα and using the equivalence
NNα ⇔α
we get
(T ∗) α ⇒Mα
(3.55)
as an equivalent formulation of (T). Substitution α/Lα in (T ∗) yields Lα ⇒
MLα.
An analogical dualization of (S5) yields the expression
MLα ⇒Lα
hence, by (T ∗) we have
(i) MLα ⇔Lα
or, dually,
(ii) Mα ⇔LMα
Now, it follows from (i) that
Lα ⇒MLα
and by (ii), we have
Lα ⇒LMLα
which again by (i), yields
Lα ⇒LLα
i.e., (S4)
⊓⊔
The consequence of this result is that the system S4 is contained in the system
S5. We also demonstrate that in the system S5, the following meaningful
expression
(B) Nα ⇒LNLα
is derivable. Indeed,
⊢S5 MLα ⇒Lα
as the dual form of (S5), thus, by (T),
⊢S5 MLα ⇒α
follows, which is the dual form of (B). Let us observe that (B) is true in any
model M = (W, R, v) in which the relation R is symmetric, i.e., (w, w1) ∈R
implies (w1, w) ∈R. Indeed, for a model M = (W, R, v), and for a w ∈W,
assume that v(MLα, w) = 1, hence, there is w1 ∈W with (w, w1) ∈R and
v(Lα, w1) = 1, so v(α, w2) = 1 for every w2 ∈W with (w1, w2) ∈R, hence, in
particular, v(α, w) = 1, as by symmetry of R we have (w1, w) ∈R. It follows
that v(MLα ⇒α, w) = 1. Hence, formulas derivable in the system S5 are

140
3 Reasoning Patterns of Deductive Reasoning
true in any interpretation frame M = (W, R) in which the relation R is an
equivalence relation. The completeness theorem for S5 acquires the following
form. We denote by Meq the set of all interpretation frames in which the
relation R is an equivalence relation.
Proposition 3.45. For any formula α, α is derivable in the system S5 if
and only if α is true in every frame in Meq.
We actually pointed above in Proposition 3.42, Proposition 3.43, Proposition
3.45 to suﬃciency of the condition on interpretation frames in each case.
To show the necessity of these conditions in respective cases, we check that
relations in each of canonical interpretation frames for respective systems are
such as indicated in completeness theorems.
Proposition 3.46. The relation R in canonical interpretation frames for T ,
S4, S5 is, respectively, reﬂexive, reﬂexive and transitive, and an equivalence.
Proof. In case of the system T , by (T ) Lα ⇒α, for every Γ with Conmax(Γ)
we have that Lα ∈Γ does imply α ∈Γ hence ΓRcΓ, i.e., the relation Rc is
reﬂexive. In case of the system S4, Rc is reﬂexive as (T) is a theorem of this
system. Assume ΓRcΓ ∗and Γ ∗RcΓ ∗∗; from Lα ∈Γ it follows by the axiom
(S4) Lα ⇒LLα that LLα ∈Γ hence Lα ∈Γ ∗and α ∈Γ ∗∗. Thus Lα ∈Γ
implies α ∈Γ ∗∗i.e. ΓRcΓ ∗∗proving that Rc is transitive. It remains to prove
for the system S5 that Rc is symmetric, as reﬂexivity and transitivity in this
case follow by the fact that the system S5 contains (T) and (S4). We recall
the theorem (B) Nα ⇒LNLα of this system. Assume that ΓRcΓ ∗, i.e.,
Lα ∈Γ implies α ∈Γ ∗.
If it was not the case that Γ ∗RcΓ, we would have an expression β with
Lβ ∈Γ ∗and it would not be true that β ∈Γ. Thus Nβ ∈Γ and by
(B) we have that LNLβ ∈Γ so NLβ ∈Γ ∗. It follows that Γ ∗has both
Lβ, NLβ as elements, contradicting consistency of Γ ∗. Thus, Γ ∗RcΓ and Rc
is symmetric
⊓⊔
We add that systems T, S4, S5 were independently introduced under nota-
tion, respectively, M, M ′, M” in Von Wright [50]. An exposition of ﬁrst–order
intensional logic can be found in Fitting [8].

References
1. Van Benthem, J.: A Manual of Intensional Logic. CSLI Stanford University,
Stanford (1988)
2. Boche´nski, I.M.: Die Zeitg¨onossischen Denkmethoden. A. Francke AG, Bern
(1954)
3. Boche´nski, I.M.: A History of Formal Logic. Notre Dame University Press,
Notre Dame (1971)
4. Carnap, R.: Necessity and Meaning. Chicago University Press, Chicago (1947)
5. Chang, C.C.: A new proof of the completeness of the Lukasiewicz’s axioms.
Trans. Amer. Math. Soc. 93, 74–80 (1959)
6. Cook, S.A.: The complexity of theorem–proving procedures. In: Proceedings of
the 3rd Annual ACM Symposium on Theory of Computing, pp. 151–158. ACM
Press, New York (1971)
7. Feys, R.: Les logiques nouvelles des modalit´es. Revue N´eoscholastique de
Philosophie 40, 41, 217–252, 517–553 (1937)
8. Fitting, M.C.: First–order intensional logic. Annals of Pure and Applied
Logic 127, 171–193 (2004)
9. Frege, G.: Begriﬀsschritt. Eine der Arithmetischen Nachgebildete Formel-
sprache des Reinen Denkens. Verlag von Louis Nebert, Halle a/S (1879)
10. Frege,
G.:
¨Uber Sinn
und Bedeutung. Zeitschrift
f¨ur
Philosophie
und
Philosophische Kritik NF 100, 25–50 (1892)
11. Gallin, D.: Intensional and higher–order modal logic. North Holland, Amster-
dam (1975)
12. Goguen, J.: –9) The logic of inexact concepts. Synthese 19, 325–373 (1968)
13. Goldberg, H., Leblanc, H., Weaver, G.: A strong completeness theorem for
3–valued logic. Notre Dame J. Formal Logic 15, 325–332 (1974)
14. G¨odel, K.: Die Vollstandigkeit der Axiome des Logischen Funktionenkalk¨uls.
Monats. Math. Phys. 37, 349–360 (1930)
15. G¨odel, K.: Zum intuitionistichen Aussagenkalk¨uls. Anzeiger Akademie der Wis-
senschaften Wien. Math-naturwisschen. Klasse 69, 65–66 (1932)
16. H´ajek, P.: Fuzzy logic and arithmetical hierarchy II. Studia Logica 58, 129–141
(1997)
17. H´ajek, P.: Metamathematics of Fuzzy Logic. Kluwer, Dordrecht (1998)
18. Henkin, L.: The completeness of the ﬁrst–order functional calculus. J. Symb.
Logic 14, 159–166 (1949)
19. Herbrand, J.: Recherches sur la th´eorie de la d´eemonstration. Travaux de la
Soc. Sci. Lettr. de Varsovie Cl. III 33, 33–160 (1930)

142
References
20. Hughes, G.E., Creswell, M.J.: An Introduction to Modal Logic. Methuen, Lon-
don (1972)
21. Kripke, S.: Semantical considerations on modal logics. Acta Philosophica Fen-
nica. Modal and Many–Valued Logics, pp. 83–94 (1963)
22. Lemmon, E.J., Scott, D.S., Segerberg, K. (eds.): The ‘Lemmon Notes’: An
Introduction to Modal Logic. Blackwell, Oxford (1963)
23. Lewis, C.I., Langford, C.H.: Symbolic Logic, 2nd edn. Dover, New York (1959)
24. Lukasiewicz, J.: W sprawie odwracalno´sci stosunku racji i nast¸epstwa (Con-
cerning the invertibility of the relation between the premise and the conclusion
(in Polish)). Przegl¸ad Filozoﬁczny 16 (1913)
25. Lukasiewicz, J.: Farewell lecture at Warsaw University (1918); Borkowski L.
(ed.) Jan Lukasiewicz. Selected Works. North Holland, Amsterdam (1970)
26. Lukasiewicz, J.: O logice tr´ojwarto´sciowej (On three–valued logic, in Polish).
Ruch Filozoﬁczny 5, 170–171 (1920)
27. Lukasiewicz, J.: Zagadnienia prawdy (On problems of truth, in Polish). Ksi¸ega
Pami¸atkowa XI Zjazdu Lekarzy i Przyrodnik´ow Polskich (Commemorating
Book of the XI–th Meeting of the Polish Medics and Naturalists), pp. 84 ﬀ
(1922)
28. Lukasiewicz, J.: Philosophische bemerkungen zu mehrwertige Systemen des
Aussagenkalkuls. C. R. Soc. Sci. Lettr. Varsovie 23, 51–77 (1930)
29. Lukasiewicz, J.: Aristotle’s Syllogistic from the Standpoint of Modern Formal
Logic, 2nd edn. Oxford University Press, Oxford (1957)
30. Lukasiewicz, J.: Elements of Mathematical Logic, 1st edn. Pergamon Press –
Polish Scientiﬁc Publishers, Oxford – Warsaw (1963)
31. Lukasiewicz, J.: On the history of the logic of propositions (1970); Borkowski
L. (ed.) Jan Lukasiewicz. Selected Works. North Holland, Amsterdam (1970)
32. Lukasiewicz, J., Tarski, A.: Untersuchungen ¨uber den Aussagenkalkuls. C. R.
Soc. Sci. Lettr. Varsovie 23, 39–50 (1930)
33. Menger, K.: Statistical metrics. Proc. Nat. Acad. Sci. USA 8, 535–537 (1942)
34. Meredith, C.A.: The dependence of an axiom of Lukasiewicz. Trans. Amer.
Math. Soc. 87, 54 (1958)
35. Montague, R.: Pragmatics and intensional logic. Synthese 22, 68–94 (1970)
36. Mundici, D.: Satisﬁability in many–valued sentential logic is NP–complete. The-
oretical Computer Science 52, 145–153 (1987)
37. McNaughton, R.: A theorem about inﬁnite–valued sentential logic. J. Symbolic
Logic 16, 1–13 (1951)
38. Nov´ak, V.: On the syntactico–semantical completeness of ﬁrst–order fuzzy logic.
Kybernetika 2, 47–62, 134–152 (1990)
39. Post, E.L.: Introduction to a general theory of elementary propositions. Amer.
J. Math. 43, 163–185 (1921)
40. Rasiowa, H.: A proof of the Skoiem-L¨owenheim theorem. Fundamenta Mathe-
matics 38, 230–232 (1951)
41. Rasiowa, H.: On satisﬁability and deducibility in non–classical functional cal-
culi. Bull. Pol. Ac.: Math (Cl.III) 1, 229–231 (1953)
42. Rasiowa, H., Sikorski, R.: The Mathematics of Metamathematics. PWN-Polish
Scientiﬁc Publishers, Warszawa (1963)
43. Robinson, J.A.: A machine–oriented logic based on the resolution principle.
Journal ACM 12, 23–41 (1965)
44. Rose, A., Rosser, J.B.: Fragments of many–valued statement calculi. Trans.
Amer. Math. Soc. 87, 1–53 (1958)

References
143
45. Rosser, J.B., Turquette, A.R.: Many–valued Logics. North Holland, Amsterdam
(1958)
46. Schweizer, B., Sklar, A.: Probabilistic Metric Spaces. North Holland, Amster-
dam (1983)
47. Tarski, A.: Poj¸ecie prawdy w j¸ezykach nauk dedukcyjnych (On the notion of
truth in languages of deductive sciences, in Polish). Travaux de la Soc. des Sci.
et des Lettres de Varsovie Cl. III 34, VII+116 (1933)
48. Wajsberg, M.: Axiomatization of the 3–valued sentential calculus (in Polish, a
summary in German). C. R. Soc. Sci. Lettr. Varsovie 24, 126–148 (1931)
49. Wajsberg, M.: Beitr¨age zum Metaaussagenkalk¨ul I. Monat. Math. Phys. 42,
221–242 (1935)
50. Von Wright, G.H.: An Essay in Modal Logic. North Holland, Amsterdam (1951)
51. Zadeh, L.A.: Fuzzy sets. Information and Control 8, 338–353 (1965)
52. Zadeh, L.A.: Fuzzy logic and approximate reasoning. Synthese 30, 407–428
(1975)


Chapter 4
Reductive Reasoning Rough and
Fuzzy Sets as Frameworks for
Reductive Reasoning
Reductive reasoning, in particular inductive reasoning, Boche´nski [9], Lukasie-
wicz [30], is concerned with ﬁnding a proper p satisfying a premise p ⇒q for
a given conclusion q. With some imprecision of language, one can say that its
concern lies in ﬁnding a right cause for a given consequence. As such, induc-
tive reasoning does encompass many areas of research like Machine Learning,
see Mitchell [37], Pattern Recognition and Classiﬁcation, see Duda et al. [16],
Data Mining and Knowledge Discovery, see Kloesgen and Zytkow [26], all
of which are concerned with a right interpretation of data and a general-
ization of ﬁndings from them. The matter of induction opens up an abyss
of speculative theories, concerned with hypotheses making, veriﬁcation and
conﬁrmation of them, means for establishing optimality criteria, consequence
relations, non–monotonic reasoning etc. etc., see, e.g., Carnap [12], Popper
[55], Hempel [22], Bochman [10].
Our purpose in this chapter is humble; we wish to give an insight into
two paradigms intended for inductive reasoning and producing decision rules
from data: rough set theory and fuzzy set theory.
We pay attention to structure and basic tools of these paradigms; rough
sets are interesting for us, as forthcoming exposition of rough mereology bor-
ders on rough sets and uses knowledge representation in the form of informa-
tion and decision systems as studied in rough set theory. Fuzzy set theory, as
already observed in Introduction, is to rough mereology as set theory is to
mereology, a guiding motive; in addition, main tools of fuzzy set theory: t–
norms and residual implications are also of fundamental importance to rough
mereology, as demonstrated in following chapters.
4.1
Rough Set Approach Main Lines
Introduced in Pawlak [44], [45] rough set theory is based on ideas that go
back to Gottlob Frege, Gottfried Wilhelm Leibniz, Jan Lukasiewicz, Stanislaw
Le´sniewski, to mention a few names of importance. Its characteristics is that
they divide notions (concepts) into two classes: exact as well as inexact.
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 145–190.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

146
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
The idea for a dividing line between the two comes from Frege [19]: an in-
exact concept should possess a boundary region into which objects fall which
can be classiﬁed with certainty neither to the concept nor to its complement.
This boundary to a concept is constructed in the rough set theory from in-
discernibility relations induced by attributes (features) of objects.
Knowledge is assumed in rough set theory to be a classiﬁcation of objects
into categories (decision classes). As a frame for representation of knowledge
we adopt following Pawlak [44], information systems.
One of languages for knowledge representation is the attribute–value lan-
guage in which notions representing things are described by means of at-
tributes
(features) and their values; information systems are pairs of the
form (U, A) where U is a set of objects – representing things – and A is a set
of attributes; each attribute a is modeled as a mapping a : U →Va from the
set of objects into the value set Va. For an attribute a and its value v, the
descriptor, see Pawlak [45], Baader et al. [2], (a = v) is a formula interpreted
in the set of objects U as [[(a = v)]] = {u ∈U : a(u) = v}.
Descriptor formulas are the smallest set containing all descriptors and
closed under sentential connectives ∨, ∧, ¬, ⇒. Meanings of complex formulas
are deﬁned recursively
1. [[α ∨β]] = [[α]] ∪[[β]];
2. [[α ∧β]] = [[α]] ∩[[β]];
3. [[¬α]] = U \ [[α]];
4. [[α ⇒β]] = [[¬α ∨β]].
In descriptor language each object u ∈U can be encoded over a set B of at-
tributes as its information vector InfB(u) = {(a = a(u)) : a ∈B}. A formula
α is true (is a tautology) if and only if its meaning [[α]] equals the set U.
The Leibniz Law (the Principle of Identity of Indiscernibles and Indiscerni-
bility of Identicals), Leibniz [28], aﬃrms that two things are identical if and
only if they are indiscernible, i.e., no available operator acting on both of
them yields distinct values
∀F.F(x) = F(y) ⇔x = y
(4.1)
In the context of information systems, indiscernibility relations are introduced
and interpreted in accordance with the Leibniz Law from sets of attributes:
given a set B ⊆A, the indiscernibility relation relative to B is deﬁned as
Ind(B) = {(u, u′) : a(u) = a(u′) for each a ∈B}
(4.2)

4.1 Rough Set Approach Main Lines
147
Objects u, u′ in relation Ind(B) are said to be B–indiscernible and are re-
garded as identical with respect to knowledge represented by the information
system (U, B). The class [u]B = {u′ : (u, u′) ∈Ind(B)} collects all objects
identical to u with respect to B.
Each class [u]B is B–deﬁnable, i.e., the decision problem whether v ∈[u]B
is decidable: one says that [u]B is exact. More generally, an exact concept is
a set of objects in the considered universe which can be represented as the
union of a collection of indiscernibility classes; otherwise, the set is inexact
or rough. In this case, there exist a boundary about the notion consisting of
objects which can be with certainty classiﬁed neither into the notion nor into
its complement. To express the B–boundary of a concept X, induced by the
set B of attributes, approximations over B, see Pawlak, op. cit., op. cit., are
introduced, i.e., the B–lower approximation
BX =

{[u]B : [u]B ⊆X}
(4.3)
and the B–upper approximation
BX =

{[u]B : [u]B ∩X ̸= ∅}
(4.4)
The diﬀerence
BdBX = BX \ BX
(4.5)
is the B–boundary
of X; when non-empty, it does witness that X is B–
inexact. The reader has certainly noticed the topological character of the
approximations as, respectively, the closure and the interior of a concept in
the topology generated by indiscernibility relations, cf., Ch. 2, sect. 12.
The inductive character of rough set analysis of uncertainty stems from the
fact that the information system (U, A) neither exhausts the world of objects
W nor the set A∗of possible attribute of objects. On the basis of induced
classiﬁcation Δ : U →Categories, one attempts to classify each possible
unknown object x ∈W \ U; this classiﬁcation is subject to uncertainty.
In order to reduce the complexity of classiﬁcation task, a notion of a reduct
was introduced, see Pawlak [45]; a reduct B of the set A of attributes is a
minimal subset of A with the property that Ind(B) = Ind(A). An algorithm
for ﬁnding reducts based on Boolean reasoning, see Brown [11], was proposed
in Skowron and Rauszer [66]; given input (U, A) with U = {u1, ..., un} it starts
with the discernibility matrix
MU,A = [ci,j = {a ∈A : a(ui) ̸= a(uj)}]1≥i,j≤n
(4.6)
and the Boolean function
fU,A =

ci,j̸=∅,i<j

a∈ci,j
a,
(4.7)
where a is the Boolean variable associated with the attribute a ∈A.

148
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
The function fU,A is converted to its DNF form
f ∗
U,A :

j∈J

k∈Kj
aj,k
(4.8)
Then, sets of the form Rj = {aj,k : k ∈Kj} for j ∈J, corresponding to
prime implicants 
k∈Kj aj,k of f ∗
U,A are all reducts of A.
To verify this thesis, it suﬃces to consider for a subset B ⊆A, the valuation
vB: vB(a) = 1 if and only if a ∈B, and observe that vB(fU,A) = 1 if
and only if Ind(B) = Ind(A). On the other hand, as fU,A and f ∗
U,A are
semantically equivalent, we have vB(f ∗
U,A) = 1 and this happens if and only
if {aj,k : k ∈Kj} ⊆B for some prime implicant 
k∈Kj aj,k, so minimal B
with Ind(B) = Ind(A) are of the form B = {aj,k : k ∈Kj} for some prime
implicant 
k∈Kj aj,k.
For a reduct B, the reduced information system (U, B), secures the same
classiﬁcation as the full system (U, A), hence, it does preserve knowledge.
Moreover, as Ind(B) ⊆Ind(C) for any subset C ⊆A, one can establish a
functional dependence of C on B: as for each object u ∈U, [u]B ⊆[u]C, the
assignment fB,C : InfB(u) →InfC(u) is functional, i.e., values of attributes
in B determine functionally values of attributes in C on U, object-wise. Thus,
any reduct determines functionally the whole system.
4.2
Decision Systems
A decision system is a triple (U, A, d) in which d is the decision attribute,
decision, the attribute not in A, that does express the evaluation of objects
by an external oracle, an expert. Attributes in A are called in this case con-
ditional, in order to discern them from the decision d. Values vd of decision
d can be regarded as codes for categories into which the decision classiﬁes
objects.
Inductive reasoning by means of rough sets aims at ﬁnding as faithful as
possible description of the concept d in terms of conditional attributes in A in
the language of descriptors. This description is eﬀected by means of decision
rules, i.e., formulas of descriptor logic of the form of an implication

a∈B
(a = va) ⇒(d = v)
(4.9)
The formula (4.9) is true in case
[[

a∈B
(a = va)]] =

a∈B
[[(a = va)]] ⊆[[(d = v)]]

4.2 Decision Systems
149
Otherwise, the formula is partially true. An object o which is matching the
rule, i.e., a(o) = va for a ∈B can be classiﬁed to the class [[(d = v)]]; often
a partial match based on a chosen distance measure has to be performed.
The simplest case is when the decision system is deterministic, i.e., when
Ind(A) ⊆Ind(d). In this case, the relation between A and d is functional,
given by the unique assignment fA,d or in the decision rule form (4.9) as the
set of rules: 
a∈A(a = a(u)) ⇒(d = fA,d(u)) for u ∈U. In place of A any
reduct R of A can be substituted leading to shorter rules.
In the contrary case of a non–deterministic system, some classes [u]A are
split into more than one decision classes [v]d leading to ambiguity in classi-
ﬁcation. In that case, decision rules are divided into true (or, exact, certain)
and possible; to induce the certain rule set, the notion of a δ–reduct was
proposed in Skowron and Rauszer [66].
To deﬁne δ–reducts, the generalized decision δB is deﬁned: for u ∈U,
δB(u) = {v ∈Vd : ∃u′.d(u′) = v ∧(u, u′) ∈Ind(B)}
(4.10)
A subset B of A is a δ–reduct, when it is a minimal subset od A with respect
to the property that δB = δA. δ–reducts can be obtained from the modiﬁed
Skowron and Rauszer algorithm as pointed in there; it suﬃces to modify the
entries ci,j of the discernibility matrix to new entries c′
i,j, by letting
cd
i,j = {a ∈A ∪{d} : a(ui) ̸= a(uj)}
(4.11)
and
c′
i,j =

cd
i,j \ {d} in case d(ui) ̸= d(uj)
∅in case d(ui) = d(uj)
(4.12)
The algorithm described above input with entries c′
i,j forming the matrix
M δ
U,A outputs all δ–reducts to d encoded as prime implicants of the associated
Boolean function f δ
U,A.
The problem of ﬁnding a reduct of minimal length is NP-hard [66], there-
fore, one may foresee that no polynomial algorithm is available for computing
reducts. Thus, the algorithm based on discernibility matrix has been proposed
with stop rules that permit to stop the algorithm and obtain a partial set of
reducts, see Bazan [4]. In ﬁnding approximations to reducts methods of arti-
ﬁcial intelligence like swarm algorithms are applied, see Hong Yu et al. [23];
in Moshkov et al. [38], an idea of a descriptive set of attributes, computed by
a polynomial algorithm is discussed.
In order to precisely discriminate between certain and possible rules, the
notion of a positive region along with the notion of a relative reduct, see
Pawlak [45], was studied in Skowron and Rauszer [66].
Positive region PosB(d) is the set
{u ∈U : [u]B ⊆[u]d}
(4.13)

150
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
which is equivalent to

v∈Vd
B[[(d = v)]]
(4.14)
PosB(d) is the greatest subset X of U such that (X, B, d) is deterministic; it
generates certain rules.
Objects in U \ PosB(d) are subjected to ambiguity; given such u, and
the collection v1, .., vk of decision values on the class [u]B, the decision rule
describing u can be written down as

a∈B
(a = a(u)) ⇒

i=1,...,k
(d = vi)
(4.15)
Each of the rules 
a∈B(a = a(u)) ⇒(d = vi) is possible but not certain, as
only for a fraction of objects in the class [u]B the decision takes the value vi
on.
Relative reducts are minimal sets B of attributes with the property that
PosB(d) = PosA(d); they can also be found by means of discernibility matrix
M ∗
U,A in as pointed to in [66] with entries
c∗
i,j =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
cd
i,j \ {d} in case either d(ui) ̸= d(uj) and ui, uj ∈PosA(d)
or pos(ui) ̸= pos(uj)
∅otherwise
(4.16)
For a relative reduct B, certain rules are induced from the deterministic
system (PosB(d), A, d), possible rules are induced from the non-deterministic
system (U \ PosB(d), A, d). In the last case, one can ﬁnd δ–reducts and turn
the system into a deterministic one (U \PosB(d), A, δ) inducing certain rules
of the form 
a∈B(a = a(u)) ⇒
v∈δ(u)(d = v).
4.3
Decision Rules
Forming a decision rule consists in searching in the pool of available seman-
tically non–vacuous descriptors for their combination that describes closely
a chosen decision class. The very basic idea of inducing rules consists in con-
sidering a set B of attributes: the lower approximation PosB(d) allows for
rules which are certain, the upper approximation 
v∈Vd B[(d = v)] adds rules
which are possible.
We write down concisely a decision rule in the form φ/B, u ⇒(d = v)
where φ/B, u is a descriptor formula 
a∈B(a = a(u)) over B, see Pawlak
and Skowron [47]. A method for inducing decision rules in a systematic way
of Pawlak and Skowron [47] and Skowron [65]consists in ﬁnding the set of all
δ–reducts R={R1, ..., Rm}, and deﬁning for each reduct Rj and each object
u ∈U, the rule φ/Rj, u ⇒(d = d(u)). Rules obtained by this method

4.3 Decision Rules
151
are not minimal usually in the sense of the number of descriptors in the
premise φ.
A method for obtaining decision rules with minimal number of descriptors,
in Pawlak and Skowron [47] and Skowron [65], consists in reducing a given
rule r : φ/B, u ⇒(d = v) by ﬁnding a set Rr ⊆B consisting of irreducible
attributes in B only, in the sense that removing any a ∈Rr causes the
inequality
[φ/Rr, u ⇒(d = v)] ̸= [φ/Rr \ {a}, u ⇒(d = v)]
(4.17)
to hold. In case B = A, reduced rules φ/Rr, u ⇒(d = v) are called optimal
basic rules (with minimal number of descriptors). The method for ﬁnding of
all irreducible subsets of the set A in Skowron [65], consists in considering
another modiﬁcation of discernibility matrix: for each object uk ∈U, the
entry c′
i,j into the matrix M δ
U,A for δ–reducts is modiﬁed into
ck
i,j =

c′
i,j in case d(ui) ̸= d(uj) and i = k ∨j = k
∅otherwise
(4.18)
Matrices M k
U,A and associated Boolean functions f k
U,A for all uk ∈U allow
for ﬁnding all irreducible subsets of the set A and in consequence all basic
optimal rules (with minimal number of descriptors).
Decision rules can also be found in an exhaustive way by selecting a maxi-
mal consistent set of decision rules, incrementally adding descriptors object–
wise and eliminating contradicting cases, see RSES system [59]. A method for
inducting a minimal set of rules is proposed in LERS system of Grzymala–
Busse [20]
Sequential covering idea of inducing decision rules, see Mitchell [37], lead-
ing to a minimal in a sense set of rules covering all objects, has been realized
as covering algorithms in RSES system [59].
Association rules in the sense of Agrawal et al. [1], induced by means
of Apriori algorithm, loc.cit., i.e., rules with high conﬁdence coeﬃcient can
also be induced in information system context by regarding descriptors as
boolean features in order to induce certain and possible rules, Kryszkiewicz
and Rybi´nski [27].
Decision rules are judged by their quality on the basis of the training
set, and by quality in classifying new unseen as yet objects, i.e., by their
performance on the test set. Quality evaluation is done on the basis of some
measures; for a rule r : φ ⇒(d = v), and an object u ∈U, one says that u
matches r in case u ∈[[φ]]. match(r) is the number of objects matching r.
Support, supp(r), of r is the number of objects in [[φ]] ∩[[(d = v)]]; the
fraction cons(r)= supp(r)
match(r) is the consistency degree of r: cons(r) = 1 means
that the rule is certain.

152
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
Strength, strength(r), of the rule r is deﬁned, Michalski et al. [36], Bazan
[5], Grzymala–Busse and Ming Hu [21], as the number of objects correctly
classiﬁed by the rule in the training phase; relative strength is deﬁned as the
fraction,
rel −strength(r) =
supp(r)
|[[(d = v)]]|
(4.19)
Speciﬁcity of the rule r, spec(r), is the number of descriptors in the premise
φ of the rule r, cf., op. cit., op. cit.
In the testing phase, rules vie among themselves for object classiﬁcation
when they point to distinct decision classes; in such case, negotiations among
rules or their sets are necessary. In these negotiations rules with better char-
acteristics are privileged.
For a given decision class c : d = v, and an object u in the test set, the
set Rule(c, u) of all rules matched by u and pointing to the decision v, is
characterized globally by,
Support(Rule(c, u)) =

r∈Rule(c,u)
strength(r) · spec(r)
(4.20)
The class c for which Support(Rule(c, u)) is the largest wins the competition
and the object u is classiﬁed into the class c : d = v.
It may happen that no rule in the available set of rules is matched by
the test object u and partial matching is necessary, i.e., for a rule r, the
matching factor match−fact(r, u) is deﬁned as the fraction of descriptors in
the premise φ of r matched by u to the number spec(r) of descriptors in φ.
The rule for which the partial support, Part-Support(Rule(c,u)), given as

r∈Rule(c,u)
match −fact(r, u) · strength(r) · spec(r)
(4.21)
is the largest, wins the competition and it does assign the value of decision
to u.
In a similar way, notions based on relative strength can be deﬁned for sets
of rules and applied in negotiations among them [21].
4.4
Dependencies
Decision rules are particular cases of dependencies among attributes or their
sets; certain rules of the form φ/B ⇒(d = v) establish functional dependency
of decision d on the set B of conditional attributes. Functional dependence
of the set B of attributes on the set C, C '→B, in an information system
(U, A) means that Ind(C) ⊆Ind(B).
Minimal sets D ⊆C of attributes such that D '→B can be found from a
modiﬁed discernibility matrix MU,A, see Skowron and Rauszer [66]: letting

4.5 Topology of Rough Sets
153
⟨B⟩to denote the global attribute representing B: ⟨B⟩(u) = ⟨b1(u), ..., bm(u)⟩
where B = {b1, ..., bm}, for objects ui, uj, one sets ci,j = {a ∈C ∪{⟨B⟩} :
a(ui) ̸= a(uj)} and then cB
i,j = ci,j \ {⟨B⟩} in case ⟨B⟩is in ci,j; otherwise
cB
i,j is empty.
The associated Boolean function f B
U,A gives all minimal subsets of C on
which B depends functionally; in particular, when B = {b}, one obtains in
this way all subsets of the attribute set A on which b depends functionally,
see Skowron and Rauszer [66]. A number of contributions are devoted to this
topic in an abstract setting of semi–lattices, see Pawlak [45] and Novotny and
Pawlak [41].
Partial dependence of the set B on the set C of attributes takes place when
there is no functional dependence C '→B; in that case, some measures of
a degree to which B depends on C were proposed in Novotny and Pawlak
[41]: the degree can be deﬁned, e.g., as the fraction γB,C= |P osCB|
|U|
, where
the C-positive region of B is deﬁned in analogy to already discussed positive
region for decision, i.e.,
PosC(B) = {u ∈U : [u]C ⊆[u]B}
In this case, B depends on C partially to the degree γB,C: C '→γB,C B.
The relation C '→r B of partial dependency is transitive in the sense: if
C '→r B and D '→s C, then D '→max{0,r+s−1} B, where t(r, s) = max{0, r +
s −1} is the Lukasiewicz t-norm, see, e.g., Polkowski [54], sect. 10. 4.
4.5
Topology of Rough Sets
We spend some time on topological issues in rough sets; consult Ch. 2 for
notions of topology. Clearly, in a ﬁnite context of an information system
(U, A), any topology can only be ﬁnite. The simplest case is that when we
consider indiscernibility relation Ind(B) for some attribute set B. As it does
induce a partition on the set U, it induces also the partition topology πB on
U; as we know, cf., Ch. 2, sect. 10, each indiscernibility class is clopen, and
any intersection of clopen sets is again clopen. Therefore the quotient space
U/Ind(B) is discrete. In order to obtain an interesting topology, one is bound
to enter the realm of inﬁnity and consider at least the case when the attribute
set and the object set are countably inﬁnite. We can assume that attributes
form a descending sequence {an : n = 1, 2, ...}, i.e., Ind(an+1) ⊆Ind(an),
each n, and let πn be the partition topology induced by Ind(an) for each n.
We denote by π0 the topology on the set U, whose open basis is the
union {πn : n = 1, 2, ...}. We deﬁne π0–exact sets and π0–rough sets as fol-
lows, where Clπ0, Intπ0 is closure, respectively, interior operator with respect
to π0.
1. A set Z ⊆U is π0–exact if and only if Intπ0Z = Clπ0Z.
2. Otherwise, Z is π0–rough, i.e., in this case, Intπ0Z ̸= Clπ0Z.

154
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
A proposition follows, Polkowski [48], [49], [50], [52], on representation of
π0–rough sets
Proposition 4.1. A pair (Q, T) of π0–closed subsets in U satisﬁes conditions
Q = Clπ0X, T = U \ Intπ0X with a rough subset X ⊆U if and only if Q, T
satisfy the following conditions
1. U = Q ∪T;
2. Q ∩T ̸= ∅;
3. Q∩T does not contain any point x such that the singleton {x} is Π0–open.
This proposition allows for a representation of each π0–rough set as a pair
(Q, T ) of π0–closed sets satisfying 1–4.
It turns out that the space of π0–rough sets is metrizable, see Polkowski
[49]–[52].
Proposition 4.2. The topology π0 is metrizable by means of a metric
d(x, y) = 
n 10−n · dn(x, y), where the metric dn is deﬁned by means of
dn(x, y) =

1 in case [x]n ̸= [y]n
0 otherwise
(4.22)
Now, we introduce a new metric dH, modeled on the Hausdorﬀ–Pomp´e¨ıu
metric, see Ch. 2, sect. 11, into the family C(U) of closed subsets of U in the
topology π0.
For closed subsets K, H of U, we let
dH(K, H) = max{maxx∈Kdist(x, H), maxy∈Hdist(y, K)}
(recall that dist(x, H) = min{d(x, z) : z ∈H} is the distance of x to the set
H). The standard proof shows that dH is a metric on C.
We may propose an algorithm for computing dH(K, H) based on the com-
parison of closures ClnK, ClnH for n = 1, 2, ... where Cln is the closure
operator in the topology πn.
When ClnK ̸= ClnH, there exists, e.g., x ∈ClnK \ ClnH, and thus,
[x]n ⊆ClnK, [x]n ∩ClnH = ∅from which it follows that,
d(x, z) ≥1
9 · 10−n+1
(4.23)
for every z ∈ClnH implying that
dH(K, H) ≥1
9 · 10−n+1
(4.24)

4.5 Topology of Rough Sets
155
We have the following,
Proposition 4.3. For any pair K, H of closed sets, we have
1. If ClnK = ClnH for every n, thendH(K, H) = 0;
2. If n is the ﬁrst among indices j such that CljK
̸=
CljH, then
dH(K, H) = 1
9 · 10−n+1.
For any pair (Q1, T1), (Q2, T2) of rough sets, we let
D((Q1, T1), (Q2, T2)) = max{dH(Q1, Q2), dH(T1, T2)}
(4.25)
and
D∗((Q1, T1), (Q2, T2)) = max{D((Q1, T1), (Q2, T2)), dH(Q1 ∩Q2, T1 ∩T2)}
(4.26)
As dH is a metric on closed sets, D, D∗are metrics on rough sets. From
Properties 1, 2, above, we infer that
Proposition 4.4. For any pair (Q1, T1), (Q2, T2) of rough sets
1. If n is the ﬁrst among indices j with the property that either CljQ1 ̸=
CljQ2 or CljT1 ̸= CljT2, then D((Q1, T1), (Q2, T2)) = 1
9 · 10−n+1, other-
wise, D((Q1, T1), (Q2, T2)) = 0;
2. If n is the ﬁrst among indices j with the property that either CljQ1 ̸=
CljQ2 or CljT1 ̸= CljT2, or Clj(Q1∩T1)̸=Clj(Q2∩T2), then D∗((Q1, T1),
(Q2, T2)) = 1
9 · 10−n+1, otherwise, D∗((Q1, T1), (Q2, T2)) = 0.
We assume that
C For each descending sequence ([xn]n)n of equivalence classes, we have

n
[xn]n ̸= ∅
(4.27)
Condition C does express our positive assumption that the universe of our
information system has no ”holes”; on the other hand, C does imply that in
the case where inﬁnitely many of relations Rn are non–trivial, the universe U
would be uncountable, so information systems satisfying C should be searched
for among those constructed on sets of real numbers or real vectors.
Condition C allows us to demonstrate the basic completeness property of
metric spaces of rough sets, see Polkowski op. cit., op. cit. The completeness
property here is more complex, then in the general case of a metric space as
it requires that both metrics D, D∗cooperate in the following sense
Proposition 4.5. Under (C), each D∗–fundamental sequence ((Qn, Tn))n of
rough sets converges in the metric D to a rough set.

156
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
We can also consider a ﬁniteness condition
F Each relation Rn induces a ﬁnite number of equivalence classes
It turns out that, see [49]
Proposition 4.6. Under C+F, the space of π0–rough sets is compact in met-
ric D, i.e., any sequence ((Qj, Tj))j of rough sets contains a sub–sequence
((Qjk, Tjk))k convergent in the metric D to a limit rough set (Q∗, T ∗).
An interesting application rough set topology ﬁnds in fractal geometry.
4.6
A Rough Set Reasoning Scheme: The Approximate
Collage Theorem
We give an example of approximate reasoning with rough sets in topological
context, see Polkowski [54].
The Collage Theorem has been proposed to be applied in fractal compres-
sion; from technical point of view it is a version of the Banach ﬁxed–point
theorem adopted to the case of compact sets (fractals) endowed with the
Hausdorﬀ-Pomp´e¨ıu metric induced by the Euclidean metric in a Euclidean
space, cf., Barnsley [3]. We know that those spaces are complete, cf., Ch. 2,
sect. 11.
Here, we consider the following case, see Polkowski [54], [54]. We assume
that a sequence (Fn)n of compact sets (fractals) is given in a Euclidean space
E (say 2– or 3–dimensional). We denote by the symbol DE the Hausdorﬀ
–Pomp´e¨ıu metric on the space of compact sets in E induced by a standard
metric ρ on E (e.g., to ﬁx our attention, we may adopt the metric
ρ(x, y) =

i
((xi −yi)2)
1
2
We consider a natural information system (Rk, A), where A is a countable
set of attributes such that the n–th attribute an does induce the partition of
Rk into squares of side length 1/2n.
We already know that every fractal in our sense (i.e., having a fractional
dimension) is a π0–rough set with respect to the information system A on E.
We may thus consider the sequence (Fn)n as a sequence in the complete space
of π0–rough sets and thus we may apply the Banach ﬁxed – point theorem
(or, a rough set counterpart of it).
We denote by the symbol a+
mF the upper approximation of the compact
F with respect to the attribute am of the information system A; we may
formulate our question related to the sequence (Fn)n. We assume that the
sequence (Fn)n does converge in the metric d to the limit set F. Then a
question does arise

4.6 A Rough Set Reasoning Scheme: The Approximate Collage Theorem
157
Q Estimate the least natural number n with the property that a+
mFn = a+
mF
for a given natural number m
Let us comment on the meaning of this problem. Given Fn, F, we replace
those sets with their upper approximations a+
mFn, a+
mF. Let us observe that
description of a+
mF requires only a ﬁnite number of names of m–cubes in the
partition Pm into indiscernibility classes of the relation Indam, so this de-
scription is a compression of knowledge about F similar to that which results
in the case of fractals generated as iterated function systems. In this case, the
description of the fractal is encoded in the starting compact set C and in the
coeﬃcients of aﬃne maps whose iterates applied to C generate the fractal in
question. Our case here is more general as the compression in terms of upper
approximations may be applied to any fractal regardless of the method of its
generation.
As with the Collage Theorem, we ask for the ﬁrst integer n such that
sets Fn and F have the same upper approximation with respect to am. It
follows from our discussion of the metric D′ that we have a+
j Fn = a+
j F for
every j ≥n. It is a matter of a simple calculation to check that in case
a+
mFn = a+
mF we also have DE(Fn, F) ≤2−m+ 1
2 hence (Fn)n does converge
to F in the metric DE as well.
It follows that a+
mFn = a+
mF for a suﬃciently large m does assure that
sets Fn and F are suﬃciently close to each other with respect to metrics d as
well as DE. The ”roughiﬁcation” a+
mFn may be thus taken as a satisfactory
approximation to F.
Let us now refer to the case of fractals generated via iterated function
systems. In this case in its simplest form we are given compact fractals
C0, C1, ..., Ck and an (usually) aﬃne function f : E →E with the con-
traction coeﬃcient c ∈(0, 1). The resulting fractal F is obtained as the limit
of the sequence (Fn)n of sets deﬁned inductively as follows

F0 = k
i=1 Ci
Fk+1 = f(Fk)
(4.28)
It is easy to check that the resulting mapping on sets has also the contraction
coeﬃcient c. As we know, in the context of the Banach ﬁxed–point theorem,
the distance between the limit F and the set Fn may be evaluated as
DE(Fn, F) ≤cn · (1 −c)−1 · DE(F0, F1)
(4.29)
This general result implies,
Proposition 4.7. (Polkowski [54]) Assume that K = DE(F0, F1). Then in
order to satisfy the requirement
DE(Fn, F) ≤ε

158
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
it is suﬃcient to satisfy the requirement
a+
mFn = a+
mF
with
m = ⌈1
2 −log2ε⌉
and
n ≥⌈log[2−m+ 1
2 · K−1 · (1 −c)]
logc
⌉
In addition to their role in inductive reasoning, rough sets allow also for
deductive schemes of reasoning about knowledge.
4.7
A Rough Set Scheme for Reasoning about
Knowledge
The setting of rough sets can be used in reasoning along classical lines about
knowledge and in building logical systems reﬂecting the speciﬁc features of
rough set context.
Consider an approximation space (U, E), where u is a set of objects, and
E an equivalence relation on U; clearly, this notion is abstracted from the
content of the notion of an information system, where E is the indiscernibility
relation. In this context, the Rasiowa and Skowron [57] Rough Concept Logic
(RCL) is constructed.
The relation E can be extended to powers U n, n = 1, 2, ..., by letting
((u1, ..., un), (u′
1, ..., u′
n)) ∈E if and only if (ui, u′
i) ∈E for i = 1, 2, ..., n. By
means of relations En, each relation R ⊆U n, n = 1, 2, ..., can be approxi-
mated in the rough set way as
(u1, ..., un) ∈E(R) ⇔(ui, u′
i) ∈E
(4.30)
for a (u′
1, ..., u′
n) ∈R.
Similarly,
(u1, ..., un) ∈E(R) ⇔(ui, u′
i) ∈E
(4.31)
for each (u′
1, ..., u′
n) ∈R.
E(R) is the upper approximation to R, and E(R) is the lower approxima-
tion to R; either of these sets is exact in U n.
RCL is built of a variable set V , a predicate set P = {e, r1, ..., rm}, where
e is interpreted as an equivalence relation, and each ri is a predicate of arity
ki, propositional connectives {∨, ∧, ¬, ⇒}, a unary connective A, quantiﬁers
∀, ∃and auxiliary symbols like parentheses, commas, etc. etc.
Elementary formulas are of the form e(x, y), ri(x1, ..., xki), and formulas
are built as in predicate calculus, cf., Ch.3, sect. 8.

4.7 A Rough Set Scheme for Reasoning about Knowledge
159
Duality of lower and upper approximations is expressed by introducing a
connective A = ¬A¬.
An interpretation frame for RCL is a set X along with an equivalence
relation E and relations R1, ..., Rm, where arity of Ri is ki for i = 1, 2, ..., m.
A valuation v in the frame M=(X, E, R1, ..., Rm) satisﬁes a formula α, in
symbols v |=M α when the following recursive conditions are satisﬁed
1. v |=M e(x, y) if and only if (v(x), v(y)) ∈E;
2. v |=M ri(x1, ..., xki) if and only if (v(x1), ..., v(xki) ∈Ri;
3. v |=M α ∨β if and only if v |=M α or v |=M β;
4. v |=M α ∧β if and only if v |=M α and v |=M β;
5. v |=M α ⇒β if and only if v |=M α implies v |=M β;
6. v |=M ¬α if and only if it is not true that v |=M α;
7. v |=M ∃xα(x) f and only if v(x/c) |=M α for some c ∈X, where v(x/c)(y)
is v(y) for x ̸= y and c for y = x;
8. v |=M ∀xα(x) if and only if v |=M α(x/c) for each c ∈X;
9. v |=M Aα(x1, ..., xn) if and only if v |=M α(x1/c1, ..., xn/cn)) for each
tuple (c1, ..., cn) ∈Xn such that (v(xi), ci) ∈E for i = 1, 2, ..., n.
A formula α is true in a frame M if and only if v |=M α for each valuation v
in M. The formula α is a tautology if and only if α is true in every frame M.
For a formula α(x1, ..., xn), and a frame M, one deﬁnes
[[α]]M = {(c1, ..., cn) ∈Xn : ∃v = v(x1/c1, ..., xn/cn).v |=M α}
(4.32)
Then, Rasiowa and Skowron, op. cit., prove that α is true in M if and only
if [[α]] = Xn, as then α is satisﬁed by each valuation.
RCL is axiomatized by means of the following set of axioms

160
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
RCL1-3 Axioms T1–T3 of propositional calculus
RCL4 A(α ⇒β) ⇒(Aα ⇒Aβ
RCL5 Aα ⇒α
RCL6 e(x, x)
RCL7 e(x, y) ⇒[e(y, z) ⇒e(x, z)]
RCL8 e(x, y) ⇒e(y, x)
RCL9 e(x, y) ⇒[Aα(x) ⇒Aα(y)]
RCL10 e(x1, y1) ∧... ∧e(xn, yn) ⇒[α(x1, .., xn) ⇒Aα(y1, ..., yn)
RCL11 If α has no free variables, then α ⇒Aα
Axioms RCL6–8 express the fact that e is interpreted as equivalence, RCL5,
RCL9–11 do express the nature of the lower approximation A.
Derivation rules are detachment (MP), substitution for free variables, rules
for quantiﬁer introduction and elimination IE, IU, EE,EU, see Ch. 3, sect. 8,
and the rule of necessitation: if α, then Aα.
Among formulas derived from axioms are the following, see Rasiowa and
Skowron [57], Lemma 1.
Proposition 4.8. The following are among theorems of RCL
1. (α ⇒β) ⇒(Aα ⇒Aβ);
2. e(x1, y1) ⇒... ⇒[(e(xn, yn) ⇒(α(x1, ..., xn) ⇔α(y1, ..., yn)];
3. Aα(x1, ..., xn) ⇒∀y1, ..., yn[e(x1, y1) ∧... ∧e(xn, yn) ⇒α(y1, ..., yn)];
4. Aα ⇒AAα;
5. α ⇒AAα.
Let us observe that formulas 1, 4, 5 express the fact that when A is interpreted
as the modality of necessity and dually A is interpreted as the modality of
possibility, then RCL realizes the S5 system of modal logic, see Ch. 3, sect.
9. Completeness theorem follows from the main theorem in Rasiowa and
Skowron, op. cit.

4.8 Fuzzy Set Approach: Main Lines
161
Proposition 4.9. If a formula α is not derivable from a set of formulas Γ,
non(Γ ⊢α), then there exists a frame M such that M|= Γ and α is not true
in M.
The proof of this proposition goes on lines of the Rasiowa and Sikorski tech-
nique, cf. Ch. 3, sect. 8.
Modal character of rough set approximations was also revealed in Orlowska
[42] and Vakarelov [67]. Epistemic logic for reasoning about knowledge was
constructed in Orlowska [43].
4.8
Fuzzy Set Approach: Main Lines
We have witnessed the development of logical T–calculi, see Ch. 3, sect.
6, with truth values ranging continuously from 0 to 1 in the framework of
residuated lattices, where an essential usage has been made of the adjoint
pair (T, →T) of a continuous t–norm and its residuum. For the ﬁrst ideas of
‘fuzziness before fuzzy’, cf., Seising [64], see Fleck [18], Black [8], Menger [34];
Zadeh [70] introduced the subject of fuzzy set theory. t –norms and dual to
them, t–conorms can be applied in the development of algebra of fuzzy sets,
viz., t–norms determine intersections of fuzzy sets according to the formula,
χA∩B(x) = T (χA(x), χB(x))
(4.33)
where T is a t–norm and χA is the fuzzy characteristic (membership) function
of the fuzzy set A; whereas t–conorms may be used in determining unions of
fuzzy sets, by means of
χA∪B(x) = S(χA(x), χB(x))
(4.34)
where S is a t–conorm.
We focus in this chapter on deeper properties of t–norms (a fortiori, of
co–norms) which were bypassed when discussing T–logics in Ch. 3, and are
of interest for rough mereology, which is discussed in coming Ch. 6. We recall
that a t–norm T is a function T : [0, 1]2 →[0, 1], which satisﬁes the following
postulates
1. T is associative: T (T (x, y), z) = T (x, T(y, z));
2. T is commutative: T (x, y) = T (y, x);
3. T is non–decreasing in each coordinate: T (z, y) ≥T (x, y) whenever z ≥x;

162
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
4. T(1, x) = x;
5. T(x, 0) = 0.
Moreover, T may satisfy additional postulate,
6. T is continuous.
Known to us t–norms: the Lukasiewicz t–norm L(x, y) = max{0, x + y −1},
the Product t–norm P(x, y) = x · y, the minimum t–norm M(x, y) =
min{x, y} satisfy 1–6.
Let us observe that L and P do satisfy
7. T(x, x) < x for each x ∈(0, 1).
Indeed, this property is obviously satisﬁed when L(x, x) = 0 and if L(x, x) =
2x −1, then x ≥1
2 and 2x −1 ≥x implies x = 1. For P, P(x, x) = x2 < x
unless x = 0, 1.
A t – norm T(x, y) which satisﬁes postulates 6, 7 is said to be an
Archimedean t–norm.
Much eﬀort was put into the task of recognizing the structure of t – norms.
Given a function f : [a, b] →[0, ∞] of which we assume it is continuous
and increasing, we deﬁne its pseudo – inverse g : [0, ∞] →[a, b] by letting
g(x) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
a in case x ∈[0, f(a)]
f −1(x) in case x ∈[f(a), f(b)]
b in case x ∈[f(b), ∞]
(4.35)
In the dual case when f is decreasing, the deﬁnition is similar, with the
obvious changes, viz., b takes the place of a and vice versa.
The correctness of this deﬁnition follows from the fact that f is injective on
[a, b] and that by continuity of f, the image f([a, b]) is the interval [f(a), f(b)]
(or, [f(b), f(a)]).
We assume now that a function T : [0, 1]2 →[0, 1], not necessarily a t –
norm, satisﬁes postulates 1, 3, 4, 6, and 7.
We will say in this case that T is an Archimedean function. We recall a
structure theorem about T due to Ling [29]. To this end, we establish ﬁrst
some properties of T. We introduce the symbol T n(x) deﬁned inductively as
follows

T 0(x) = 1
T n+1(x) = T (T n(x), x)
(4.36)

4.8 Fuzzy Set Approach: Main Lines
163
Proposition 4.10. (The auxiliary structure theorem, Ling [29]) Every
archimedean function T has the following properties
A1 The sequence (T n(x))n is non–increasing for every x ∈[0, 1]
A2 Given 0 < y < x < 1, we have T n(x) < y for some n; a fortiori,
limnT n(x) = 0
A3 0 is the two–sided null element, i.e., T(0, x) = 0 = T(x, 0) for ev-
ery x ∈[0, 1]
A4 T (x, 1) = x for every x ∈[0, 1]
A5 y < x, 0 < T n(x) imply T n(y) < T n(x)
A6 0 < x < 1, 0 < T n(x) imply T n+1(x) < T n(x)
A7 The set Tn(x) = {y ∈[0, 1] : T n(y) = x} is non–empty
We let rn(x) = infTn(x).
A8 rn(x) ∈T n(x), i.e., T n(rn(x)) = x
A9 rn(x) is a continuous, decreasing function of x
A10 rn(x) < rn+1(x) for every 0 < x < 1
A11 limnrn(x) = 1 for every 0 < x < 1
A12 The superposition T m◦rn depends on m
n only, i.e., T m◦rn = T km◦rkn
for k = 1, 2, ...
Proof. For A1, given x ∈[0, 1], one has T n+1(x) = T(T n(x), x) ≤T (T n(x), 1)
= T n(x).
For A2, assume to the contrary that there are x, y with y < x, T n(x) ≥y
for each n; consider z = infT n(x) ≥y. By postulates 6, 1,
T(z, z) = limnT(T n(x), T n(x)) = limnT 2n(x) = z
contradicting postulate 7.
In case of A3, indeed,
T (0, x) = T(limnT n(x), x) = limnT(T n(x), x) = limnT n+1(x) = 0
by A2; in case of T(x, 0) the argument is analogous.

164
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
For A4, consider the function x →T (x, 1); by continuity, it takes all values
from 0 = T (0, 1) to 1 = T (1, 1) so for a given x there is y with x = T (y, 1)
and T (x, 1) = T (T (y, 1), 1) = T (y, T (1, 1)) = T (y, 1) = x.
Concerning A5, ﬁrst, observe T (x, y) ≤T (1, y) = y; if it was T (x, y) = y,
we would have by induction that T (T n(x), y) = y. But for some n0 we have
T n0(x) < y by A2 and thus y = T (T n0(x), y) ≤T (y, y) < y, a contradiction.
We have proved
(i) T (x, y) < y, T (x, y) < x for 0 < x, y < 1
We consider now the function z →T (x, z) for a given x and let y < x;
as this function is continuous and maps [0, 1] onto the interval [0, x] so for
some z1 we have T (x, z1) = y. Similarly, we prove that T (z2, x) = y for some
z2. We have veriﬁed
(ii) x < y implies the existence of z1, z2 such that T (x, z1) = y, T (z2, x) = y
We return to the proof of A5; assume to the contrary that for some x, y, n
we have y < x, 0 < T n(x), T n(x) = T n(y). Then by (i), (ii), postulate 1, we
have
0 < T n(x) = T n(y) = T (T n−1(y), y)
=
T (T n−1(y), T (x, z)) = T (T (T n−1(y), x), z)
≤T (T (T n−1(x), x), z)
=
T (T n(x), y) < T n(x)
by (i), a contradiction.
A6 follows from A5(i). A8 follows as Tn(x) is a closed set, hence, it con-
tains its the least and the greatest bounds.
Concerning A7, as T n is continuous and T n(0) = 0, T n(1) = 1, we have
T n(y) = x with some y.
For A9, as, by A8, rn is the right inverse to T n which is continuous and
decreasing by A5, rn is also continuous and decreasing.
In case of A10 assume to the contrary that 0 < rn+1(x) ≤rn(x) < 1
for some x, n, hence,
0 < T n(rn+1(x)) ≤T n(rn(x)) = x < 1
(4.37)

4.8 Fuzzy Set Approach: Main Lines
165
and, by A5, one obtains
0 < x = T n+1(rn+1(x)) = T(T n(rn+1(x)), rn+1(x)) ≤
T(x, rn+1(x)) < x
a contradiction.
For A11, by A10, (rn(x))n is increasing hence it has a limit s = limnrn(x);
thus, s > rn(x) for each n. On the other hand, x = T n(rn(x)) < T n(s) for
each n. Was s < 1, we would have T n(s) < 1 for each n and we would ﬁnd
by A2 some m with T mn(s) = T m(T n(s)) < x, a contradiction.
In case of A12, assume to the contrary that T m ◦rn(x) ̸= T km ◦rkn(x) for
some x, m, n, k; then for y = rn(x) and z = rkn(x) we have T k(z) ≥y by def-
inition of rn(x) and ﬁnally T k(z) > y by our assumption. By continuity of T k
we have y = T k(w) with some w < z so T kn(w) = T n(y) = x, i.e., w ∈Tkn(x)
contrary to w < z and z = rkn(x)
⊓⊔
We now are able to state and verify the principal structure theorem for
archimedean functions.
Proposition 4.11. (the principal structure theorem, Ling [29]) If a function
T : [0, 1]2 →[0, 1] is Archimedean, then there exists a continuous decreasing
function f on [0, 1] with the property that
(∗) T(x, y) = g(f(x) + f(y))
for each pair x, y where g is the pseudo – inverse to f. Moreover, every func-
tion T(x, y) for which a representation of the form (*) exists is archimedean.
Proof. Selecting and ﬁxing a ∈(0, 1), we deﬁne by A12 a function h( m
n ) =
T m(rn(a)) on the set Q0 of rational positive numbers. As both T m, rn are
continuous decreasing, h is continuous and decreasing. Moreover, h does sat-
isfy the functional equation
(∗∗) T(h(p), h(q)) = h(p + q)
on the set Q0.
To verify (**), we consider p = m
n , q = k
l ; ﬁnding a common denominator
d we write down x = c
d, y = f
d and compute
T(h(p), h(q)) = T(T c(rd(a)), T f(rd(a))) = T c+f(rd(a)) = h(c + f
d
) = h(p+q)
Having (**) veriﬁed, we now extend h in a unique way by continuity and
density of the set Q0 in the interval [0, 1] to the continuous and decreasing
function g. Clearly
(∗∗∗) T(g(x), g(y)) = g(x + y)
is satisﬁed on [0, 1].

166
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
Letting A to be the ﬁrst argument with g(A) = 0, we have that g is a
continuous decreasing function from [0, A] onto [0, 1] so it has the inverse f.
Returning to the identity (***) and letting g(x) = u, g(y) = v, we have (***)
in the form of
T (u, v) = g(f(u) + f(v))
for every pair u, v ∈[0, 1].
The second part, viz., that (*) implies that T is archimedean, may be veri-
ﬁed by a straightforward veriﬁcation that Postulates 1, 3, 4, 6, and 8 hold, cf.,
Schweizer and Sklar [62]
⊓⊔
We may note as a direct consequence of the last theorem that, as shown by
Proposition 4.11,
Proposition 4.12. Each Archimedean function T is commutative.
It follows that any continuous t – norm admits a representation of the form
(*). The function f occurring in the representation (*) is called a generator
of T . Let us return to the well – known to us the Lukasiewicz t–norm L and
ﬁnd its generator.
Example 4.1. We search for f with the property that L(x, y) = g(f(x)+f(y)).
Assuming that f(1) = a, we have g(x) = 1 for x ∈[0, a] and thus
1 = L(1, 1) = g(f(1) + f(1)) = g(2a), hence, 2a ∈[0, a] so a = 0.
As f(1) = 0, the candidate is f(x) = 1 −x; in this case the pseudo–inverse
is g(y) = 1 −y in case y ≤1 and g(y) = 0 in case y > 1. Combining f, g into
(*), we have
g(f(x) + f(y)) =

1 −(1 −x) −(1 −y) = x + y −1 in case x + y ≥1
0 in case x + y < 1
(4.38)
i.e., L(x, y) = g(f(x)+f(y)) holds with the indicated f, g. Thus the generator
for L is f(x) = 1 −x, i.e., the negation in the logic of Lukasiewicz.
It turns out that postulates 1, 3, 4, 6, 7 are essential; the example for that is
provided by the t–norm min which does not satisfy Property 7. Actually,
Proposition 4.13. (Ling [29]) In any representation
(∗) min(x, y) = g(f(x) + f(y))
the function f can neither be continuous nor decreasing.
Proof. Assuming (∗), as g◦f is an identity, f is injective. For f(0) = a, f(1) =
b, we may, e.g., assume a > b. As 0 = min(0, x) = g(f(0) + f(x)) for every
x, in case f is continuous, the value of g on [a + b, 2a] is constantly 0. For

4.8 Fuzzy Set Approach: Main Lines
167
x close enough to 0 we have a + b < f(x) + f(x) ≤2a so x = min(x, x) =
g(f(x)+f(x)) = 0, a contradiction when x ̸= 0. So f may not be continuous.
For the second part, assuming f decreasing, we may apply a well-known
theorem of Riemann stating that any monotone real function on an inter-
val has at most countably many points of discontinuity (these points may
happen only where f experiences jumps and as each jump determines an
open interval, the family of jumps may be at most countable). Thus there
is a continuity point a ∈(0, 1) for f. Let (an)n be an increasing sequence
with the limit a. It follows that (f(an)n is a decreasing sequence with
the limit f(a). As f(a) > 0, we have an with f(a) < f(an) < 2 · f(a)
and applying g which is decreasing as the pseudo – inverse to f, we get
a > an > g(f(a) + f(a)) = min(a, a) = a, a contradiction. So there is no de-
creasing generator for min
⊓⊔
It will be useful to mention here the dual notion of a t – co–norm. Given a t
– norm T , the associated t – co–norm ST is produced via
ST(x, y) = 1 −T (1 −x, 1 −y)
(4.39)
Clearly, associativity, commutativity, and continuity are retained by this op-
eration. A closer inspection tells us that null elements for T (i.e., elements a
such that T (a, x) = a for every x) are changed into null elements 1−a for ST
and the unit elements b for T (i.e., elements such that T (b, x) = x for every
x) are turned into unit elements 1 −b for ST . Also ST is non–decreasing as
T is, and the inequality T (x, x) < x is changed into inequality ST(x, x) > x.
Modifying accordingly postulates 1–7, we obtain dual properties for t–co–
norms.
As an example we may calculate the t–co–norm SL. We have
SL(x, y) = 1 −L((1 −x), (1 −y)) = 1 −max{0, 1 −x −y} = min(x + y, 1)
The corresponding duality takes place also for representations of t – norms
and t – co–norms. Letting
T (x, y) = gT(fT (x) + fT (y))
as a representation for a t–norm T , we may produce the respective represen-
tation for the t–conorm ST as
ST (x, y) = 1 −T (1 −x, 1 −y) = 1 −gT (fT (1 −x) + fT (1 −y))
and letting
fS(x) = fT(1 −x), gS(x) = 1 −gT(x)
we obtain the representation
ST(x, y) = gS(fS(x) + fS(y))

168
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
For instance, in case of SL we have fS(x) = 1 −(1 −x) = x and gS(x) =
1 −gT(x) = min(x, 1). Clearly, in the general case, fS is increasing, and gS
is the pseudo–inverse to fS. Having established basic properties of t–norms,
we turn to residual implications, so essential for T–logics.
4.9
Residual Implications
Given a t–norm T , the residual implication ⇒T , cf., Ch. 3, sect. 6, is deﬁned
via the condition
RI x ⇒T y ≥z ⇔T (x, z) ≤y
(4.40)
Let us collect in the following proposition the elementary properties of resid-
ual implications following from deﬁnition.
Proposition 4.14. For every t – norm T , the residual implication ⇒T sat-
isﬁes the following conditions
RI1 T (x, y) ≤z ⇒T u if and only if x ≤T (y, z) ⇒T u
RI2 y ⇒T (z ⇒T u) = T (y, z) ⇒T u
RI3 y ⇒T z = 1 if and only if y ≤z
RI4 x ≤y ⇒T u if and only if y ≤x ⇒T u
Proof. Associativity of T implies
x ≤y ⇒T (z ⇒T u) ⇔T (x, y) ≤z ⇒T u ⇔
T (T (x, y), z) ≤u ⇔T (x, T(y, z)) ≤u ⇔x ≤T (y, z) ⇒T u
whence RI1, RI2 follow.
RI3 follows from deﬁnition of ⇒T and the fact that T (x, y) ≤min(x, y)
following from t(x, 1) = x and commutativity and monotonicity of T .
Finally, commutativity of T implies
x ≤y ⇒T u ⇔T (x, y) ≤u ⇔T (y, x) ≤u ⇔y ≤x ⇒T u
which ends the proof
⊓⊔
Passing to deeper properties of T and →T, let us observe that
RI5 For a ﬁxed a, the function T (x, a) does preserve suprema
To verify RI5, consider a set C with c0 = supC; then
T (c0, a) = T (supC, a) ≥T (c, a)
(4.41)

4.10 Topological Properties of Residual Implications
169
for every c ∈C, hence, T (supC, a) ≥supCT (c, a). On the other hand
T (supC, a) ≤u ⇔supC ≤a ⇒T u ⇔∀c ∈C.c ≤a ⇒T u
(4.42)
which is equivalent to ∀c ∈C.t(c, a) ≤u, hence, the equality T (supC, a) =
supCT (c, a) follows.
Clearly, the function T (a, x) preserves suprema by commutativity of T .
Returning to ⇒T , let us observe that
Proposition 4.15. The residual implication ⇒T satisﬁes
RI6 ⇒T is non–increasing in the ﬁrst coordinate and non–decreasing in
the second coordinate
RI7 a ⇒T x for a ﬁxed a preserves inﬁma; consequently, x ⇒T a changes
suprema into inﬁma.
Proof. RI6 follows by monotonicity of T and deﬁnition of ⇒T , e.g., for u ≤v
from x ≤y ⇒T u, i.e., T (x, y) ≤u, it follows that T (x, y) ≤v, i.e., x ≤y ⇒T
v for every x, hence, y ⇒T u ≤y ⇒T v. The proof for the ﬁrst coordinate
follows on the same lines.
The argument for RI7 parallels that for RI5; given a set C, we have for
every x
x ≤infC(a ⇒T c) ⇔∀c ∈C.x ≤a ⇒T c
which is equivalent to
∀c ∈C.T(x, a) ≤c ⇔T (x, a) ≤infC ⇔x ≤a ⇒T infC
whence a ⇒T infC = infC(a ⇒T c) follows
⊓⊔
4.10
Topological Properties of Residual Implications
It turns out that properties mentioned in the preceding section may be
equivalently stated in topological terms. We recall that a function f be-
tween metric spaces is continuous (cf., Ch. 2) if it satisﬁes the condition
f(limnxn) = limnf(xn) for every sequence (xn)n. This condition may be
too strong for some nevertheless important functions and therefore it has
been ramiﬁed into two semi – continuity conditions.
We introduce here two operations on sequences. Given a sequence (xn)n,
we deﬁne its lower limit as
lim infxn = inf{limxnk}
(4.43)
where the inﬁmum is taken over all convergent sub–sequences (xnk)k of the
sequence (xn)n, and, the upper limit as

170
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
lim supxn = sup{limxnk},
(4.44)
where the supremum is taken over all convergent sub–sequences (xnk)k of the
sequence (xn)n.
Two types of semi–continuity follow.
A function f is lower–semicontinuous at x0 if and only if for every sequence
(xn)n with x0 = limxn the inequality f(x0) ≤lim inff(xn) holds. The
function f is lower–semicontinuous if and only if it is lower–semicontinuous
at every point.
A function f is upper–semicontinuous at x0 if and only if for every sequence
(xn)n with x0 = limxn the inequality f(x0) ≥lim supf(xn) holds. The
function f is upper–semicontinuous if and only if it is upper–semicontinuous
at every point.
An important and not diﬃcult to get characterization is the following
Proposition 4.16. A function f
is upper–semicontinuous (respectively,
lower–semi–continuous) if and only if for every r, the set {x : f(x) ≥r}
is closed (respectively, for every r, the set {x : f(x) ≤r} is closed).
We may now characterize in topological terms t – norms and residual
implications.
Proposition 4.17. 1. Any t – norm T is lower–semicontinuous; moreover,
any associative and commutative function T with T (0, x) = 0, T (1, x) = x
which is lower–semicontinuos is a t–norm. In this case the residual impli-
cation ⇒T is given by the condition y ⇒T z = max{x : T (x, y) ≤z};
2. Any residual implication ⇒T is upper–semicontinuos and any function non–
increasing in the ﬁrst coordinate, non–decreasing in the second coordinate
which is upper–continuous is of the form ⇒T for some t–norm T .
Proof. We consider as a matter for an exemplary argument, a t–norm T about
which we would like to prove upper–semicontinuity.
Let us ﬁx a real number r and consider the set
M = {(x, y) : T (x, y) ≤r}
(4.45)
We want to show that M is closed. Assume, to the contrary, that (x0, y0) ∈
[0, 1]2 and a sequence (xn)n in M exist such that
(i) T (x0, y0) > r
(ii) T (xn, yn) ≤r for each n
(iii) (x0, y0) = limn(xn, yn)

4.10 Topological Properties of Residual Implications
171
Then, by monotonicity of T, we have for each n that either xn < x or yn < y;
we may assume that the set {n : xn < x0} is inﬁnite and in consequence we
may assume that xn < x0 for each n.
Letting xn =max{x1, .., xn} and yn = min{y1, ..., yn} we have T (xn, yn) ≤
r, so we may assume that the sequence (xn)n is increasing to x0 and the
sequence (yn)n is decreasing to 0.
As supnT (xn, yn) = T(x0, y1) ≤r it follows by monotonicity of T that
T(x0, y0) ≤r, a contradiction. Thus M is closed and a fortiori T is lower–
semicontinuous. In all remaining cases we may argue similarly.
The converse may be proved along the same lines. As a corollary to the
lower–semicontinuity of a t – norm T , we have that the set M = {(x, y) :
T(x, y) ≤z} is closed hence the set {x : x ≤y ⇒T z} is closed hence it
contains its greatest element and thus y ⇒T z = max{x : T(x, y) ≤z}.
The proof of the second part follows along similar lines
⊓⊔
The question which t–norms may have continuous residuals was settled in
Menu and Pavelka [35], whose solution was based on results in Mostert and
Shields [39] and Faucett [17], i.e., on the result that any continuous t–norm
with 0, 1 as the only solutions to the equation T(x, x) = x and at least one
nilpotent element x (i.e., ∃n.T n(x) = 0, x ̸= 0) is equivalent to L (Mostert and
Shields [39]) and on the related result in (Faucett [17]) that any continuous
t–norm with 0, 1 as the only solutions to the equation T(x, x) = x and no
nilpotent element is equivalent to P.
We outline a proof of these results as consequences of the principal struc-
ture theorem in Ling [29], we produce an argument for the Mostert and
Shields theorem in its dual form for the respective t–co–norm SL(x, y) =
min{x + y, 1}. The proof for L may be directly recovered from the given one
via dualization, or it may be carried directly on parallel lines.
Let us comment brieﬂy on nilpotent elements. We recall once more that
an element x ̸= 0 is nilpotent with respect to T if T n(x) = 0 for some n
(respectively x ̸= 1 is nilpotent with respect to ST in case Sn
T(x) = 1 for
some n). For instance, with S = SL, and fS(x) = x, gS(x) = min{x, 1}, we
have by an easy calculation involving the identity f(g(y)) = y (as g is the
pseudo – inverse to f) that Sn(x) = min{n(x), 1} hence Sn(x) = 1 for every
x ≥1
n.
The diﬀerence between the existence and the non – existence of nilpotent
elements may be captured in terms of the generator f and its pseudo–inverse
g.
We may observe that regardless of the precise and speciﬁc formula for the
t–co–norm S (or t – norm T), we have the inductively proved identity
N Sn(x, x) = g(f(2x) + (n −2)f(x))
due to the identity f(g(x)) = x which bounds the generator f and its pseudo
– inverse g.

172
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
Hence, two possibilities arise
(i) f is bounded, a fortiori g(x) returns to 1 suﬃciently large values of
x, i.e., from N it follows that S has nilpotent elements
(ii) f is unbounded so g is the inverse to f and there are no nilpotents
We return to the problem of classiﬁcation of t – norms and t – co–norms.
We sketch a solution. First we need the notion of equivalent t – norms. It is
manifest that given a t – norm T and an increasing function φ : [0, 1] →[0, 1]
the function
(E) T ′(x, y) = φ−1(T (φ(x), φ(y)))
is a t – norm. We will say that T, T ′ are equivalent. The relation (E) bears
also on residual implications:
(ER) y ⇒T ′ z = φ−1(φ(y) ⇒T φ(z))
We state the result due to Ling [29].
Proposition 4.18. (Ling [29]) The theorem of Mostert and Shields:
‘ If S(x, y) is associative and continuous on [a, b]2 with values in [a, b], with
S(a, x) = x, and S(b, x) = b for every x, and with at least one nilpotent
element in the open interval (a, b), then S is equivalent to the t–co–norm SL’
is a consequence of the principal structure theorem for t–co–norms. The dual
result follows for t–norms.
Proof. (after Ling [29]) We have to verify ﬁrst that S satisﬁes the conditions
of the dual principal structure theorem, i.e., that
1. S is non – decreasing;
2. S(x, x) > x for every x ∈(a, b).
To this end, we may observe that if S(x, z1) = S(x, z2) then by associativity
we have
z1 = S(a, z1) = S(S(a, x), z1) = S(a, S(x, z1)) = S(a, S(x, z2)) =
S(S(a, x), z2) = S(a, z2) = z2
hence, S(x, .) is an injective function for every x. As S(x, .) is continuous
with S(x, a) = x, S(x, b) = b it is increasing. Similar proof shows that S(., x)
is increasing also. Property 1 holds.
By Property 1, we have S(x, x) > S(a, x) = x proving Property 2. Hence,
S satisﬁes assumptions of the principal structure theorem and there exist

4.10 Topological Properties of Residual Implications
173
functions f, g with S(x, y) = g(f(x)+f(y)). As S has nilpotent elements, f is
bounded, say, f : [a, b] →[0, M]; then the pseudo – inverse g : [0, ∞] →[a, b].
We deﬁne a new function h : [a, b] →[0, 1] via h(x) = f(x)
M
and we observe
that x = h(f −1(Mx).
We denote by the symbol gL(x) = min{x, 1} the pseudo–inverse to the
generator of SL(x, y) = min{x + y, 1}. Then we have to verify
Claim. gL(x) = h(g(Mx)) for every x ∈[0, ∞]
But,
gL(x) = h(f −1(MgL(x))) = h(f −1(Mmin(x, 1)))
(4.46)
hence,
gL(x) =

h(g(Mx)) in case x ≤1
h(f −1(M)) = h(b) = 1 in case x ≥1
(4.47)
whence it follows that gL(x) = h(g(Mx)) for every x ∈[0, ∞].
By Claim,
h(S(x, y)) = h(g(f(x) + f(y)) = h(g(M · (f(x)
M
+ f(y)
M )))
which in turn equals
gL(f(x)
M
+ f(y)
M ) = gL(h(x) + h(y))
which equals
min{h(x) + h(y), 1} = SL(h(x), h(y))
and this means that S is equivalent to SL
⊓⊔
Now, we pass to the problem of characterizing t–norms, which have con-
tinuous residual implications. We will need some additional properties of
residuation.
Proposition 4.19. The following properties hold for every t – norm T
RI8 y ≤(y ⇒T z) ⇒T z
RI9 T(x, y) ⇒T 0 = x ⇒T (y ⇒T 0)
Proof. As y ⇒T
z ≤y ⇒T
z we have T(y ⇒T
z, y) ≤z, hence,
by commutativity of T it follows that T (y, y ⇒T z) ≤z which implies
y ≤(y ⇒T z) ⇒T z, i.e., RI8 follows.
Associativity of T implies that z ≤T (x, y) ⇒T 0 if and only if T(z, T(x, y))
≤0, i.e., T(T(z, x), y) ≤0 so equivalently T(z, x) ≤y ⇒T 0 which is
equivalent to z ≤x ⇒T (y ⇒T 0). From the equivalence of the ﬁrst and the
last statements RI9 follows
⊓⊔

174
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
It turns out that continuity of ⇒T implies continuity of T . This fact has
remarkable consequences: if ⇒T is continuous, then t–norm T is equivalent
to L.
Proposition 4.20. (Menu and Pavelka [35]) For every t – norm T , conti-
nuity of ⇒T implies continuity of T . In this case, T is equivalent to L.
Proof. We assume that ⇒T is continuous; we ﬁrst verify the following
Claim. Consider the function x ⇒T a with 0 ≤a < 1. Then
y = (y ⇒T a) ⇒T a
for each y ∈[a, 1]
To verify Claim, we recall that
(i) y ≤(y ⇒T a) ⇒T a
by RI8; it remains to show that in case y ≥a, we have
(ii) y ≥(y ⇒T a) ⇒T a
As the function q(x) = x ⇒T a is continuous decreasing with q(a) = 1,
q(1) = a, there is z ≥a with y = z ⇒T a. Then

y = z ⇒T a ≥(((z ⇒T a) →T a) ⇒T a) =
(y ⇒T a) ⇒T a
(4.48)
by the fact that the superposition (x ⇒T a) ⇒T a is increasing so (ii) follows,
and (i) and (ii) together yield Claim.
From Claim it follows with a = 0 that
(iii) T (x, y) = (T (x, y) ⇒T 0) ⇒T 0 = ((x ⇒T (y ⇒T 0) ⇒T 0
where the last equality holds by RI9. Property (iii) shows that T is deﬁnable
in terms of superpositions of ⇒T and thus T is continuous.
We now solve the equation
(iv) T (x, x) = x
Assume that (iv) holds with x ̸= 0, 1. Take c ≤x ≤d, so there is u with
c = T (x, u). Then
T (x, c) = T (x, T(x, u)) = T (T (x, x), u) = T (x, u) = c

4.11 Equivalence and Similarity in Fuzzy Universe
175
and we have
c = T (x, c) ≤T (d, c) ≤T (1, c) = c
i.e., T (d, c) = c, hence, d →T c = c for each pair d, c with c ≤x ≤d.
This means that for c < x, the function ⇒T c is not any injection, contrary
to Claim. We infer that the equation T (x, x) = x has only 0, 1 as solutions.
To conclude the proof one has to refer to the mentioned above results of
Mostert and Shields [39] and Faucett [17]. By these results, T is equivalent
either to L or to P; however, P has to be excluded as its residual implication
(the Goguen implication), cf., Chapter 3, sect. 7, is discontinuous
⊓⊔
We now recall the notions of similarity and equivalence in the fuzzy universe.
4.11
Equivalence and Similarity in Fuzzy Universe
A fuzzy counterpart to set–theoretical notion of an equivalence relation is the
T – fuzzy similarity relation, Zadeh [71] which in the most general formula-
tion may be deﬁned as a fuzzy set ET on the square X × X satisfying the
following requirements
FS1 χET (x, x) = 1
FS2 χET (x, y) = χET (y, x)
FS3 χET (x, z) ≥T (χET (x, y), χET (y, z))
FS1 models reﬂexivity of equivalence relations, FS2 models their symmetry
whereas FS3 renders transitivity with respect to a t–norm T . Let us observe
that for each idempotent a of the t–norm T (i.e., for a with T (a, a) = a), the
relation Ra,E deﬁned via
(x, y) ∈Ra,E ⇔χET (x, y) ≥a
(4.49)
is an equivalence in the classical sense.
For instance, for similarity relations, Zadeh [71], deﬁned with T (x, y) =
min(x, y) the relation Ra,E is deﬁned for every a ∈[0, 1] and relations Ra,E
form the descending chain of equivalence relations:
R1,E ⊆... ⊆Ra,E ⊆.. ⊆R0,E
(4.50)
On the other hand, for probabilistic similarity relations deﬁned with T (x, y) =
P(x, y), Menger [33] , the only relations Ra,E are R1,E ⊆R0,E = X × X.
The same happens to likeness relations, in Ruspini [60] deﬁned with
T (x, y) = L(x, y).

176
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
In the classical case, an equivalence relation R does induce a pseudo–
metric dR on the underlying set X by dR(x, y) = 0 in case (x, y) ∈R and
dR(x, y) = 1, otherwise. One could expect from a fuzzy similarity relation
ET a similar service; letting for E = ET
χdE(x, y) = 1 −χET (x, y)
(4.51)
deﬁnes a fuzzy set dE which we may call the fuzzy metric associated with ET .
That dE retains properties of a metric follows from the following
Proposition 4.21. (de Mantaras and Valverde [32])
The fuzzy set dE induced by a fuzzy similarity relation E = ET has the
following properties
FM1 χdE(x, y) = 0 if and only if (x, y) ∈R1,E
FM2 χdE(x, y) = χdE(y, x)
FM3 χdE(x, z) ≤χdE(x, y) + χdE(y, z) in case T = M, P, L
Proof. FM1, FM2 follow from the deﬁnition of dE, and concerning the trian-
gle inequality FM3, we may paraphrase it to the equivalent inequality
FM4 1 + χET (x, z) ≥χET (x, y) + χET (y, z)
which by FS3 follows from the inequality
1 + T (α, β) ≥α + β
satisﬁed by T = M, P, L and veriﬁed directly
⊓⊔
An interesting relation between fuzzy metrics and fuzzy similarities was dis-
covered in de Mantaras and Valverde , op. cit., by dualization of the notion
of fuzzy distance. Given a t–conorm S(x, y), we may introduce the notion of
the residual dual implication x ←S y via,
DRI x ⇐S y ≤z ⇔S(z, x) ≥y
(4.52)
Then we deﬁne a fuzzy set dS via
χdS(x, y) = f(max{x, y}) ⇐S f(min{x, y})
(4.53)
where f is an arbitrarily chosen decreasing continuous function from the
interval [0, 1] onto itself. It turns out that
Proposition 4.22. (de Mantaras and Valverde [32]) For each t–co–norm S,
the fuzzy set dS satisﬁes the following conditions

4.11 Equivalence and Similarity in Fuzzy Universe
177
SM1 χdS(x, x) = 0
SM2 χdS(x, y) = χdS(y, x)
SM3 χdS(x, z) ≤S(χdS(x, z), χdS(y, z))
Let us remark for the proof that SM1, SM2 follow by deﬁnition of dS and
properties of S and SM3 follows by direct calculations involving the deﬁnition
of ⇐S.
Hence, dS is a pseudo–metric induced by the t–co–norm S. Involving once
more a continuous decreasing f : [0, 1] →[0, 1], we may convert dS into a
fuzzy similarity relation E = ET with T (x, y) = f −1(S(f(x), f(y)) by letting
χET (x, y) = f(χdS(x, y))
(4.54)
In this way we obtain the correspondence between fuzzy similarity relations
and pseudo–metrics on X.
Now, we may address similarity (equivalence) classes for a fuzzy similarity
relation E = ET . In Zadeh [71], it is proposed to deﬁne the similarity class
[x]E for x ∈X by letting
χ[x]E(y) = χE(x, y)
(4.55)
Then, the following properties are observed, see H¨ohle [25]
Proposition 4.23. The similarity class [x]E satisﬁes the following condi-
tions
SC1 χ[x]E(x) = 1
SC2 T (χ[x]E(y), χE(y, z)) ≤χ[x]E(z)
SC3 T (χ[x]E(y), χ[x]E(z)) ≤χE(y, z)
Proof. SC1 follows by FS1; SC2 is a direct paraphrase of FS3 and SC3 para-
phrases FS3 via FS2
⊓⊔
Properties SC1–SC3 reﬂect properties of classical equivalence relations, viz.,
SC1 corresponds to the property that x ∈[x]R, SC2 paraphrases the property
that xRy implies y ∈[x]R, and SC3 paraphrases the property that y, z ∈[x]R
imply (y, z) ∈R.
We may call a fuzzy equivalence class of a fuzzy similarity relation E any
fuzzy set A satisfying SC1–SC3 in place of [x]E. However, it turns out that
we have already found all fuzzy equivalence classes. We denote with the
symbol A ×T B the T – Cartesian product of fuzzy sets A, B deﬁned via
χA×T B(x, y) = T (χA(x), χB(y))
(4.56)

178
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
Proposition 4.24. (H¨ohle [25]) If A is a fuzzy equivalence class of a fuzzy
similarity relation ET then A is of the form [x]ET with some x ∈X. More-
over,
1. 
x∈X[x]ET ×T [x]ET = ET;
2. In case X is ﬁnite, supy{min{χ[x]ET (y), χ[z]E,T (y)} < 1 whenever [x]ET ̸=
[z]E,T.
Proof. Assuming A a fuzzy equivalence class, we have
(i) χA(x) = 1
with some x by SC1, and thus by RI5
χA(y) = T (χA(y), supzT (χ[x]ET (z), χ[x]ET (z)))
which in turn is equal to
supzT (χA(y), T (χ[x]ET (z), χ[x]ET (z)))
As, by (i) and associativity and monotonicity of T , and our assumption
about A
supzT (χA(y), T (χ[x]ET (z), χ[x]ET (z)))
is less or equal to
supzT (T (χA(y), χA(z)), χ[x]ET (z)))
and moreover, by SC2
supzT (T (χA(y), χA(z)), χ[x]ET (z)))
is less or equal to
supzT (χET (y, z), χ[x]ET (z))
it follows ﬁnally that, by SC3
supzT (χET (y, z), χ[x]ET (z)) ≤χ[x]ET (y)
Hence, A ≤[x]ET and, replacing roles of A and [x]ET , one obtains by sym-
metry that [x]ET ≤A so ﬁnally A = [x]ET .
To settle Property 1, we observe that, by FS3
χ
[x][x]ET ×T [x]ET (y, z) = sup[x]T (χ[x]ET (y), χ[x]ET (z))

4.11 Equivalence and Similarity in Fuzzy Universe
179
is equal to
supxT (χET (x, y), χET (x, z)) = χET (y, z)
which veriﬁes Property 1.
To verify Property 2, we may observe that by the already proved part, if
[x]ET ̸= [z]E,T then miny{χ[x]ET (y), χ[z]ET (y)} < 1
⊓⊔
Properties 1 and 2 are counterparts to properties of classical equivalence
relations: covering the universe by equivalence classes (1) and disjointness of
equivalence classes (2).
It is justiﬁed to call collections F of fuzzy sets satisfying Properties 1 and
2, and additional property
3. ∃x.χA(x) = 1 for every A ∈F.
by the name of fuzzy partitions.
Given a fuzzy partition F = {Ai : i ∈I}, we can ask about the exis-
tence of a fuzzy similarity relation ET which could approximate fuzzy sets
Ai with its equivalence classes and at the best give sets Ai as its equivalence
classes.
In order to address this problem, we consider a t – norm T and we deﬁne
a relation RT on the universe X by the formula
χRT (x, y) = infi{max{χAi(x), χAi(y)} ⇒T min{χAi(x), χAi(y)}}
(4.57)
We have
Proposition 4.25. (Valverde [68]) The relation RT satisﬁes FS1–FS3 and
thus RT is a fuzzy similarity relation.
Proof. Indeed, FS1 is satisﬁed as x →T x = 1 for every x hence χRT (x, x) = 1
for every x. Symmetry FS2 follows immediately from deﬁnition of RT . Fi-
nally, transitivity property FS3 comes down after a suitable paraphrase to
the property
RI10 y ⇒T x ≤(z ⇒T y) ⇒T (z ⇒T x)
of residual implications. To prove RI10, we begin with a string of equiva-
lent inequalities following from the deﬁnition of residual implications starting
with RI10.
(i) T (y ⇒T x, z ⇒T y) ≤z ⇒T x
(ii) T (T (y ⇒T x, z ⇒T y), z) ≤x
(iii) T (y ⇒T x, T(z ⇒T y, z)) ≤x

180
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
(iv) T (y ⇒T x, y) ≤x
(v) T (z ⇒T y, z) ≤y
and we obtain from (iv) and (v) the inequality
(vi) T (y ⇒T x, T(z ⇒T y, z)) ≤T (y ⇒T x, y)) ≤x
i.e., Property 3 is proved, verifying RI10 and a fortiori FS3.
As F was supposed to be a fuzzy partition, we have
χAi(x) = 1
with some x for every Ai. So SC1 is satisﬁed with F.
We now verify that each Ai satisﬁes SC2. We need to verify that
(vii) T (χA(x), χRT (x, y)) ≤χA(y) with A = Ai
Replacing χRT (x, y) with its deﬁnition and using the generic symbol B for
an element of F, we have
T (χA(x), infB{max{χB(x), χB(y)} ⇒T min{χB(x), χB(y)}})
is less or equal to
T (χA(x), {max{χA(x), χA(y)} ⇒T min{χA(x), χA(y)}})
which in turn is less or equal to
T (max{χA(x), χA(y)}, {max{χA(x), χA(y)} ⇒T min{χA(x), χA(y)})
which is less or equal to
≤min{χA(x), χA(y)} ≤χA(y)
proving SC2.
Now, for SC3, we should verify, again using generic symbols A, B that
(viii) T (χA(x), χA(y)) ≥χRT (x, y)
Let us look at
(ix) χRT (x, y) = infB{max{χB(x), χB(y)} →T min{χB(x), χB(y)}

4.12 Inductive Reasoning: Fuzzy Decision Rules
181
As far as we have no other information about F, then that it is merely a
fuzzy partition, we are not able to prove or disprove SC3
⊓⊔
However, in case our fuzzy partition F is of the form {[x]ET }, i.e., it is
generated by a fuzzy similarity relation ET , we may say more, viz.,
Proposition 4.26. (Valverde [68]) For the fuzzy partition F = {[x]ET : x ∈
X} induced by a fuzzy similarity relation R = ET with a t– norm T , the fuzzy
similarity relation ER induced by F according to the recipe of Proposition 4.25
coincides with ET ; a fortiori, F is a fuzzy partition with respect to ER.
Proof. Let us observe that by FS3
χET (x, z) ≥T (χET (x, y), χET (y, z))
and we obtain
(i) χET (x, y) ≤χET (y, z) ⇒T χET (x, z)
Going now to ER, we consider the term
(ii) max{χB(x), χB(y)} ⇒T min{χB(x), χB(y)}
with B = [b]E,T, for some b. By (i), we have
(iii) max{χB(x), χB(y)} ⇒T min{χB(x), χB(y)} ≥χET (x, y)
and letting b = x, we have that
(iv) infB{max{χB(x), χB(y)} ⇒T min{χB(x), χB(y)}} = χET (x, y)
which concludes our proof
⊓⊔
It follows that the construction presented above is canonical: starting with a
fuzzy similarity R it induces a fuzzy partition which in turn returns the initial
fuzzy similarity R. We have here a counterpart to the classical correspondence
between equivalence relations and partitions.
4.12
Inductive Reasoning: Fuzzy Decision Rules
Inductive reasoning by fuzzy sets is applied in inference about systems on
basis of partial knowledge extracted from observing performance of a human
operator or identifying essential parameters of a system and their mutual de-
pendencies, see Zadeh [72]. In order to present basic features of this reasoning,
we begin with predicated variant of fuzzy logic.

182
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
We introduce a set TYPE of types by conditions
(i) there are ﬁnitely many elementary types X1, ..., Xn
(ii) any ﬁnite sequence (Xij) of elementary types is a type
(iii) nothing else is a type
For each elementary type X, there is given the type domain DX. Vari-
ables of fuzzy predicate calculus are divided also: for each elementary type
X, variables of type X form a subset V arX of the variable set V ar, and
V arX ∩V arY = ∅for elementary types X ̸= Y . Predicates are typed also
and to each predicate P(x1, ..., xn) there is type assigned (X1, ..., Xn) where
each variable xi is of elementary type Xi.
Open formulas are of the form P(x1, ..., xn) where P is a predicate, and of
the form α ∨β, α ∧β, α ⇒β where α, β are formulas.
The meaning of formulas is deﬁned as follows; the meaning of the formula
P(x1, ..., xn) is the fuzzy membership function χP : 
i Xi →[0, 1] of a fuzzy
relation RP in the Cartesian product 
i Xi, where each variable xi is of
elementary type Xi, the meaning of the formula α ∨β is max{χα, χβ}, the
meaning of the formula α∧β is min{χα, χβ}, and the meaning of the formula
α ⇒β is χα ⇒T χβ, where χα, χβ are meanings of formulas α and β. To
reconcile the usage of possibly distinct t–norms in the last formula, one can
stay with the basic fuzzy logic, see Chapter 3, sect. 3.6.
Quantiﬁers ∀, ∃are added in usual form: given a formula α(x), expressions
∀x.α(x), ∃x.α(x) are formulas, where quantiﬁcation occurs over variables of
same type as the variable in the formula.
Meaning of quantiﬁed formulas is deﬁned in accordance with the rule for
classical predicate calculus, see Chapter 3, sect. 8, i.e., the meaning of the
formula ∀x.α(x) is given as infχα(a) : a ∈DX where X is the elementary
type of the variable x. Dually, the meaning of the formula ∃x.α(x) is given
as supχα(a) : a ∈DX.
In applications, elementary types come as linguistic variables, attributes,
e.g., in the system of steam engine, attributes could be temperature in the
boiler, steam pressure, gauge angle, in the system of the inverted pendulum
attributes are angle between pendulum and the vertical line, angular velocity,
force applied to the car. Each attribute X deﬁnes its domain DX and predi-
cates P X
i . In applications, the notation ‘P is X′ is in use to denote the fact
that input value from the domain DX is characterized by the predicate P,
e.g, in the phrase ‘ force is small ′.
Rules induced from data are in the implicative form 
j P Xj
j
⇒QY which
in applications is written down as
If P1 is X1 AND ... AND Pk is Xk then Q is Y

4.13 On the Nature of Reductive Reasoning
183
with the meaning min{χPj(aj)} ⇒T χQ(b), where aj, b are input or output
values from respective domains.
It should be noted that in practice many authors have applied solu-
tions which have not obeyed any logical mechanism. For instance, often ap-
plied device is to regard the premise as a relation; we consider a simple
case of two terms in premise: P is X ∧S is Z. The operation of cylin-
drical extension extends P to the predicate P e of type (X, Y ) by letting
χP e(a, b) = χP (a) for a ∈DX, b ∈DY . Similarly, S is extended to Se. The
resulting relation P × Q is deﬁned then as the intersection P e ∩Se with
χP×Q(a, b) = min{χP(a), χQ(b)}.
The operation of projection produces from a predicate T of type (X, Y ) a
predicate of type X and a predicate of type Y ; for instance, the predicate TY
of type Y is produced with χTY (b) = sup{χT(a, b) : a ∈DX}. This formula
can be reconciled with logic by observing that projection onto a coordinate
space can be deﬁned as b ∈projY T ⇔∃a ∈DX.(a, b) ∈DT and applying
the operator sup in the meaning of existential quantiﬁcation.
4.13
On the Nature of Reductive Reasoning
We already have stated that reductive reasoning, including inductive reason-
ing, is performed along the Lukasiewicz [30] scheme,
q, p ⇒q
p
(4.58)
Searching for an appropriate statement p in (4.58) can be termed a search
for an explanation, or in case of inductive reasoning, for a generalizing hy-
pothesis, cf., Mitchell [37]. It is instructive to measure this scheme against
the contemporary framework of non–monotonic reasoning in order to give,
taking rough sets as example, a brief recall of notions related to this area.We
use the vehicle of Scott consequence relations, see Scott [63].
A Scott consequence relation with respect to a logic L, is deﬁned as a
binary relation Cs(X, Y ) between ﬁnite sets of statements in L, subject to
requirements,
CS1 Cs({α}, {α})
CS2 Cs(X, Y ), X ⊆X′, Y ⊆Y ′ imply Cs(X′, Y ′)
CS3 Cs(X ∪{α}, Y ), Cs(X, Y ∪{α}) imply Cs(X, Y )
CS1 is the reﬂexivity property, CS2 is the monotonicity property, and CS3
is the cut property.

184
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
The usual interpretation of Cs is, see, e.g., Bochman [10], if all statements
in X are accepted, then at least one statement in Y is accepted.
We depart from this standard semantic interpretation, in order to merge
the Scott consequence relation with the Lukasiewicz scheme (4.58) for reduc-
tive (inductive, in particular) reasoning. Our proposed interpretation is
I If all statements q ∈X are accepted, then at least one p ∈Y satis-
ﬁes the scheme of Lukasiewicz (4.58), i.e., p ⇒q is true
We need a proof that this interpretation does satisfy requirements CS1–CS3.
Proposition 4.27. If the logic L does support theorems α ⇒α and (α ⇒
β) ⇒[(β ⇒γ) ⇒(α ⇒γ)] as well as MP modus of deduction, then the
interpretation I does satisfy CS1–CS3.
Proof. CS1 holds in virtue of the assumption that α ⇒α is a theorem of L.
For CS2, assume that Cs(X, Y ), X ⊆X′, Y ⊆Y ′; if all q ∈X′ are accepted,
then all q ∈X are accepted, hence, by the assumption that Cs(X, Y ), at
least one p ∈Y yields a true statement p ⇒q, and of course, p ∈Y ′.
In case of CS3, the assumption that Cs(X ∪{α}, Y ) implies that all q ∈X
and α are accepted and at least one p ∈Y satisﬁes either (i) p ⇒q or (ii)
p ⇒α. The assumption Cs(X, Y ∪{α}) implies moreover that there exists
p ∈Y such that (i) or (iii) α ⇒q for some q ∈X. To prove Cs(X, Y ), let us
assume that there is no p ∈Y with p ⇒q true. Thus, by (iii) α ⇒q and by
(ii) p ⇒α for some p. By theorem (α ⇒β) ⇒[(β ⇒γ) ⇒(α ⇒γ)], and
double application of MP, p ⇒q follows, a contradiction. Hence, Cs(X, Y )
holds
⊓⊔
We will call statements q ∈X reductive queries, p ∈Y reductive hypotheses,
and, statements of the form p ⇒q reductive explanations. The adjective
reductive will be often omitted for conciseness’ sake.
Example 4.2. In the context of rough sets, as a query we can consider a de-
scriptor formula (d = v), where d is a decision and v its value. A hypothesis is
then a formula, see sects. 3, 4, φB : 
a∈B(a = va) such that the implication
(decision rule) φB ⇒(d = v) is true (exact) and it is an explanation for the
query.
We know that important decision rules are often partially true; this is a
speciﬁc property of logical schemes in all kinds of approximate reasoning. To
account for them, we modify the consequence relations to partial consequence
relations. First, we introduce a modiﬁed Lukasiewicz scheme
q, p ⇒q
p, r
(4.59)
where r ∈[0, 1] is the truth state (degree) of the explanation p ⇒q.

4.13 On the Nature of Reductive Reasoning
185
A partial Scott consequence relation, accordingly, is a relation Csπ(X, Y )
subject to CS1–CS3 but with a new interpretation
Iπ If all statements q ∈X are accepted, then at least one p ∈Y satisﬁes
the scheme of Lukasiewicz (4.59), i.e., p ⇒q is true to a degree r for some
r ∈[0, 1]
Proposition 4.27 extends to the partial case with a caveat, viz., as we know,
composition of dependencies of the form α : p ⇒q, β : q ⇒r is true to
degree ≥L(r, s), where L is the Lukasiewicz t–norm, r, s are truth degrees of
α, β, respectively. Thus, in order for the tautology (α ⇒β) ⇒[(β ⇒γ) ⇒
(α ⇒γ)] to have a positive degree of truth, the particular implications should
have high degrees of truth: denoting with r, s, t respective degrees of truth in
order these implications appear in the tautology, we come at the condition
r + s + t > 2; in case of rough sets, it is, hence, safe to restrict oneself to
association rules. A theory for a reasoning scheme L is a set of statements X
such that,
Cs(X, F \ X) is not true
(4.60)
where F is the set of all well–formed statements in the language L. A theory
then is a set of formulas in which each query is fully explained within the
theory; one may say that X is self–explainable.
Example 4.3. For the case of rough sets, a theory will be a set of descriptor
formulas X which with each descriptor query (d = v) contains all exact
decision rules φB ⇒(d = v) in case of Cs, and all partially true decision
rules φB ⇒r (d = v) in case of Csπ.
It follows that in case of rough sets, a union of theories is again a theory, hence
each theory extends to a maximal theory. A characterization of maximal
theories for rough set decision rules poses itself.
Proposition 4.28. Each maximal theory for the scheme L of descriptor logic
of decision rules in the context of rough sets contains all non–void descriptors
of the form (d = v) and for each of these descriptors (d = v), it contains all
exact decision rules of the form φB ⇒(d = v) in case of Cs and all partially
true decision rules of the form φB ⇒r (d = v) in case of Csπ.
The notions of belief and of knowledge are formally introduced as follows.
Belief is a set B of statements which is contained in each maximal theory.
Knowledge is a set K of statements with the property that
Cs(∅, K)
(4.61)
Example 4.4. In case of rough sets, by Proposition 4.28, the belief set consists
of all non–void descriptors along with all possible explanations and explaining
hypotheses, true or partially true, depending on the case. Knowledge is the set
K of all true or partially true decision rules, depending on the case considered.

186
4 Reductive Reasoning Rough and Fuzzy Sets as Frameworks
Contrary to the case of classical deductive reasoning, reductive reasoning has
a non–monotonic character, meaning that when the evidence, i.e., available
information increases, belief and knowledge can diminish. Non–monotonicity
of reductive reasoning is usually exhibited by means of the notion of inference,
see Van Benthem [6], Makinson [31]. We introduce the inference relation ≫
by letting,
β ≫α ⇔Cs(α, β)
(4.62)
Thus, α infers β if and only if βis an explaining hypothesis for α. From
our assumptions about the logic L and from properties of the consequence
relation Cn, the following properties of inference follow,
1. β ≫α and γ ⇒β imply γ ≫α;
2. In case of rough set decision systems, β ≫α, γ ≫α imply
β ∨γ ≫α
and β ∧α ≫α.
Clearly, inference relation is relative to evidence available. We restrict our-
selves to the case of decision systems; for a decision system D, we denote
with the symbol ≫D the inference relation induced on basis of evidence D.
A given decision system D is a subsystem of the universal decision system
D0 encompassing all possible objects and attributes. In case of Open World
Assumption, we are provided input of new objects, and in some cases also
of attributes, hence we can introduce a containment relation ⊑on decision
systems by means of
D = (U, A, d) ⊑D′ = (U ′, A′, d) ⇔U ⊆U ′, A ⊆A′
(4.63)
Non–monotonicity of inference can be expressed as follows: NM For decision
systems D ⊑D′, if Δ ≫D Θ, then Δ ≫D′ Θ need not hold
where Δ ≫D Θ is a synthetic notation for the fact that for each α ∈Θ there
is β ∈Δ with β ≫D α.
Inductive reasoning in the framework of fuzzy sets is discussed in Dubois
and Prade [13] and Dubois, Lang and Prade [14]. The reader will ﬁnd more
information on various paradigms and methods of inductive reasoning in ad-
ditional bibliography items listed below. Decision trees learning is covered in
Quinlan [56]; evolutionary methods are introduced in Holland [24]. In Bishop
[7] cognitive methods are described and Vapnik [69] discusses statistical learn-
ing. Dubois and Prade [15] give a survey on belief update, and Rissanen [58]
introduces the minimal description length (MDL) principle. Muggleton [40]
is a reference on inductive logic programming. Russell and Norvig [61] is a
textbook covering many aspects of inductive learning.

References
1. Agrawal, R., Imieli´nski, T., Swami, A.: Mining association rules between sets
of items in large databases. In: Proceedings ACM Sigmod Conf., Washington,
DC, pp. 207–216 (1993)
2. Baader, F., Calvanese, D., McGuiness, D.L., Nardi, D., Patel–Schneider, P.F.
(eds.): The Description Logic Handbook: Theory, Implementation and Appli-
cations. Cambridge University Press, Cambridge (2004)
3. Barnsley, M.F.: Fractals Everywhere. Academic Press, New York (1988)
4. Bazan, J.G.: A comparison of dynamic and non–dynamic rough set meth-
ods for extracting laws from decision tables. In: Polkowski, L., Skowron, A.
(eds.) Rough Sets in Knowledge Discovery, vol. 1, pp. 321–365. Physica Verlag,
Heidelberg (1998)
5. Bazan, J.G., Nguyen, H.S., Nguyen, S.H., Synak, P., Wr´oblewski, J.: Rough set
algorithms in classiﬁcation problems. In: Polkowski, L., Tsumoto, S., Lin, T.Y.
(eds.) Rough Set Methods and Applications. New Developments in Knowledge
Discovery in Information Systems, pp. 49–88. Physica Verlag, Heidelberg (2000)
6. Van Benthem, J.: Essays in Logical Semantics. D. Reidel, Dordrecht (1988)
7. Bishop, C.M.: Neural Networks for Pattern Recognition. Oxford University
Press, Oxford (1995)
8. Black, M.: Vagueness: An exercise in logical analysis. Philosophy of Science 4,
427–455 (1937)
9. Boche´nski, I.M.: Die Zeitg¨onossischen Denkmethoden. A. Francke AG, Bern
(1954)
10. Bochman, A.: A Logical Theory of Nonmonotonic Inference and Belief Change.
Springer, Berlin (2001)
11. Brown, F.M.: Boolean Reasoning: The Logic of Boolean Equations. Dover, New
York (2003)
12. Carnap, R.: Logical Foundations of Probability. University of Chicago Press,
Chicago (1950)
13. Dubois, D., Prade, H.: Fuzzy sets in approximate reasoning. Part 1: Inference
with possibility distributions. Fuzzy Sets and Systems 40, 143–202 (1990)
14. Dubois, D., Lang, J., Prade, H.: Fuzzy sets in approximate reasoning. Part 2:
Logical approaches. Fuzzy Sets and Systems 40, 203–244 (1991)
15. Dubois, D., Prade, H.: A survey of belief revision and updating rules in various
uncertainty models. International Journal of Intelligent Systems 9(1), 61–100
(1994)
16. Duda, R.O., Hart, P.E., Stork, D.G.: Pattern Classiﬁcation. John Wiley and
Sons, New York (2001)

188
References
17. Faucett, W.M.: Compact semigroups irreducibly connected between two idem-
potents. Proc. Amer. Math.Soc. 6, 741–747 (1955)
18. Fleck, L.: O niekt´orych swoistych cechach my´slenia lekarskiego (On some spe-
ciﬁc patterns of medical reasoning, in Polish). Archiwum Historji i Filozofji
Medycyny oraz Historji Nauk Przyrodniczych 6, 55–64 (1927); Cohen R. S.,
Schnelle T.: Cognition and Fakt. Materials on Ludwik Fleck. D. Reidel, Dor-
drecht (1986)
19. Frege, G.: Grundgsetzte der Arithmetik II. Verlag Hermann Pohle, Jena (1903)
20. Grzymala–Busse, J.W.: LERS – a system for learning from examples based
on rough sets. In: Slowi´nski, R. (ed.) Intelligent Decision Support: Handbook
of Advances and Applications of the Rough Sets Theory, pp. 3–18. Kluwer,
Dordrecht (1992)
21. Grzymala-Busse, J.W., Hu, M.: A comparison of several approaches to missing
attribute values in data mining. In: Ziarko, W.P., Yao, Y. (eds.) RSCTC 2000.
LNCS (LNAI), vol. 2005, pp. 378–385. Springer, Heidelberg (2001)
22. Hempel, C.G.: Aspects of Scientiﬁc Explanation. The Free Press, New York
(1965)
23. Yu, H., Wang, G., Lan, F.: Solving the Attribute Reduction Problem with Ant
Colony Optimization. In: Peters, J.F., Skowron, A., Chan, C.-C., Grzymala-
Busse, J.W., Ziarko, W.P. (eds.) Transactions on Rough Sets XIII. LNCS,
vol. 6499, pp. 240–259. Springer, Heidelberg (2011)
24. Holland, J.H.: Adaptation in Natural and Artiﬁcial Systems. University of
Michigan Press, Ann Arbor (1975)
25. H¨ohle, U.: Quotients with respect to similarity relations. Fuzzy Sets and Sys-
tems 27, 31–44 (1988)
26. Kloesgen, W., Zytkow, J. (eds.): Handbook of Data Mining and Knowledge
Discovery. Oxford University Press, Oxford (2002)
27. Kryszkiewicz, M., Rybi´nski, H.: Data mining in incomplete information sys-
tems from rough set perspective. In: Polkowski, L., Tsumoto, S., Lin, T.Y.
(eds.) Rough Set methods and Applications. New Developments in Knowledge
Discovery in Information Systems, pp. 567–580. Physica Verlag, Heidelberg
(2000)
28. Leibniz, G.W.: Discourse on Metaphysics. In: Loemker, L. (ed.) Philo-
sophical
Papers
and
Letters,
2nd
edn.,
D.
Reidel,
Dordrecht
(1969);
The Identity of Indiscernibles. In: Stanford Encyclopedia of Philosophy,
http://plato.stanford.edu/entries/identity-indiscernible/
(last
en-
tered 01.04.2011)
29. Ling, C.–H.: Representation of associative functions. Publ. Math. Debrecen 12,
189–212 (1965)
30. Lukasiewicz, J.: W sprawie odwracalno´sci stosunku racji i nast¸epstwa (Con-
cerning the invertibility of the relation between the premise and the conclusion
(in Polish)). Przegl¸ad Filozoﬁczny 16 (1913)
31. Makinson, D.: General patterns in non–monotonic reasoning. In: Gabbay, D.M.,
Hogger, C.J., Robinson, J.A. (eds.) Handbook of Logic in Artiﬁcial Intelligence
and Logic Programming 3. Non–monotonic and Uncertain Reasoning, vol. 2,
pp. 35–110. Oxford University Press, Oxford (1994)
32. de M´antaras, L., Valverde, L.: New results in fuzzy clustering based on the
concept of indistinguishability relation. IEEE Trans. on Pattern Analysis and
Machine Intelligence 10, 754–757 (1988)
33. Menger, K.: Statistical metrics. Proc. Nat. Acad. Sci. USA 28, 535–537 (1942)

References
189
34. Menger, K.: Ensembles ﬂous et fonctions al´etoires. C. R. Acad´emie des Sci-
ences 37, 2001–2003 (1951)
35. Menu, J., Pavelka, J.: A note on tensor products on the unit interval. Comm.
Univ. Carolinae 17, 71–83 (1976)
36. Michalski, R.S., Mozetic, I., Hong, J., Lavrac, N.: The multi–purpose incremen-
tal learning system AQ15 and its testing to three medical domains. In: Pro-
ceedings of AAAI 1986, pp. 1041–1045. Morgan Kaufmann, San Mateo (1986)
37. Mitchell, T.: Machine Learning. McGraw-Hill, Englewood Cliﬀs (1997)
38. Moshkov, M., Skowron, A., Suraj, Z.: Irreducible descriptive sets of attributes
for information systems. In: Peters, J.F., Skowron, A. (eds.) Transactions on
Rough Sets XI. LNCS, vol. 5946, pp. 92–105. Springer, Heidelberg (2010)
39. Mostert, P.S., Shields, A.L.: On the structure of semigroups on a compact
manifold with boundary. Ann. Math. 65, 117–143 (1957)
40. Muggleton, S.H.: Inductive Logic Programming. Academic Press, New York
(1992)
41. Novotny, M., Pawlak, Z.: Partial dependency of attributes. Bull. Pol. Ac.:
Math. 36, 453–458 (1988)
42. Orlowska, E.: Modal logics in the theory of information systems. Z. Math. Logik
u. Grund. d. Math. 30, 213–222 (1984)
43. Orlowska, E.: Logic for reasoning about knowledge. Z. Math. Logik u. Grund.
d. Math. 35, 559–572 (1989)
44. Pawlak, Z.: Rough sets. International Journal of Computer and Information
Sciences 11, 341–356 (1982)
45. Pawlak, Z.: On rough dependency of attributes in information systems. Bull.
Pol. Ac.: Tech. 33, 551–559 (1985)
46. Pawlak, Z.: Rough Sets: Theoretical Aspects of Reasoning about Data. Kluwer,
Dordrecht (1991)
47. Pawlak, Z., Skowron, A.: A rough set approach for decision rules generation. In:
Proceedings of IJCAI 1993 Workshop W12, Warsaw University of Technology,
Institute of Computer Science (1993)
48. Polkowski, L.: On convergence of rough sets. In: Slowinski, R. (ed.) Intelli-
gent Decision Support. Handbook of Applications and Advances of Rough Sets
Theory, pp. 305–311. Kluwer, Dordrecht (1992)
49. Polkowski, L.: Mathematical morphology of rough sets. Bull. Pol. Ac.: Math. 41,
241–273 (1993)
50. Polkowski, L.: Metric spaces of topological rough sets from countable knowledge
bases. Foundations of Computing and Decision Sciences 18, 293–306 (1993)
51. Polkowski, L.: Concerning mathematical morphology of almost rough sets. Bull.
Pol. Ac.: Tech. 42, 141–152 (1994)
52. Polkowski, L.: Hit–or–Miss topology. In: Hazewinkel, M. (ed.) Encyclopedia of
Mathematics. Supplement 1, p. 293. Kluwer, Dordrecht (1998)
53. Polkowski,
L.: Approximation
mathematical
morphology.
In: Pal,
S.K.,
Skowron, A. (eds.) Rough Fuzzy Hybridization. A New Trend in Decision Mak-
ing, pp. 151–162. Springer, Singapore (1999)
54. Polkowski, L.: Rough Sets. Mathematical Foundations. Physica Verlag, Heidel-
berg (2002)
55. Popper, K.: The Logic of Scientiﬁc Discovery. Hutchinson, London (1959)
56. Quinlan, J.R.: C4.5: Programs for Machine Learning. Morgan Kauﬀmann, San
Mateo (1993)

190
References
57. Rasiowa, H., Skowron, A.: Rough concept logic. In: Skowron, A. (ed.) SCT
1984. LNCS, vol. 208, pp. 288–297. Springer, Heidelberg (1985)
58. Rissanen, J.: Universal coding, information, prediction and estimation. IEEE
Transactions on Information Theory IT-30(4), 629–636 (1984)
59. RSES. A system for data analysis, http://logic.mimuw.edu.pl/~rses/ (last
entered 01. 04. 2011)
60. Ruspini, E.H.: On the semantics of fuzzy logic. Int. J. Approx. Reasoning 5,
45–88 (1991)
61. Russell, S., Norvig, P.: Artiﬁcial Intelligence. A Modern Approach, 3rd edn.
Prentice Hall, Upper Saddle River (2009)
62. Schweizer, B., Sklar, A.: Probabilistic Metric Spaces. North – Holland, Ams-
terdam (1983)
63. Scott, D.: Completeness and axiomatizability in many–valued logics. Proc.
Symp. in Pure Math. 25, 431–435 (1974)
64. Seising, R.: Fuzziness before fuzzy sets: Two 20th century philosophical ap-
proaches to vagueness – Ludwik Fleck and Karl Menger. In: Proceedings IFSA
2005, Beijing, pp. 1499–1504 (2005)
65. Skowron, A.: Boolean reasoning for decision rules generation. In: Komorowski,
J., Ra´s, Z.W. (eds.) ISMIS 1993. LNCS, vol. 689, pp. 295–305. Springer,
Heidelberg (1993)
66. Skowron, A., Rauszer, C.: The discernibility matrices and functions in deci-
sion systems. In: Slowi´nski, R. (ed.) Intelligent Decision Support. Handbook
of Applications and Advances of the Rough Sets Theory, pp. 311–362. Kluwer,
Dordrecht (1992)
67. Vakarelov, D.: Modal logics for knowledge representation systems. In: Meyer,
A.R., Taitslin, M.A. (eds.) Logic at Botik 1989. LNCS, vol. 363, pp. 257–277.
Springer, Heidelberg (1989)
68. Valverde, L.: On the structure of F – indistinguishability operators. Fuzzy Sets
and Systems 17, 313–328 (1985)
69. Vapnik, V.N.: Statistical Learning Theory. John Wiley and Sons, New York
(1998)
70. Zadeh, L.A.: Fuzzy sets. Information and Control 8, 338–353 (1965)
71. Zadeh, L.A.: Similarity relations and fuzzy orderings. Information Sciences 3,
177–200 (1971)
72. Zadeh, L.A.: Outline of a new approach to the analysis of complex systems and
decision processes. IEEE Trans. Syst. Man and Cybern. 1, 28–44 (1973)

Chapter 5
Mereology
Mereology emerged in the beginning of XXth century due to independent
eﬀorts of S. Le´sniewski and A. N. Whitehead. In the scheme of Le´sniewski,
the predicate of being a part was taken as the primitive notion whereas
in the development of Whitehead’s ideas the primitive notion was adopted as
the predicate of being connected. Mereology presents an alternative, holistic,
approach to concepts which is especially suited to reasoning about extensional
objects, e.g., spacial ones as witnessed, e.g., by the Tarski axiomatization of
geometry of solids, or recent applications to geometric information systems or
analysis of statements about spatial objects and relations in natural language.
5.1
Mereology: The Theory of Le´sniewski
Mereology due to Le´sniewski arose from attempts at reconciling antinomies
of na¨ıve set theory, see Le´sniewski [42], Soboci´nski [58]. Le´sniewski [41] was
the ﬁrst presentation of foundations of this theory, see also Le´sniewski [44],
[45]; cf., Lejewski [38] and Soboci´nski [59].
The primitive notion of mereology due to Le´sniewski is a notion of a part.
Given some objects, a relation of a part is a binary relation π which is re-
quired to be
M1 Irreﬂexive: For each x ∈U it is not true that π(x, x)
M2 Transitive: For each triple x, y, z of objects in U, if π(x, y) and π(y, z),
then π(x, z)
Remark. In the original scheme of Le´sniewski, the relation of parts is applied
to individual objects as deﬁned in Ontology of Le´sniewski, see Le´sniewski
[43], Iwanu´s [30], Slupecki [54]. Ontology is founded on the predicate ϵ to
be read ”is” (in Greek, ei ”you are”, cf., Plutarch [48]) which is required to
satisfy the Ontology Axiom AO, formulated by Le´sniewski as early as 1920,
see Slupecki [54], Lejewski [39].
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 191–228.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

192
5 Mereology
AO xϵ y ⇔∃z.(zϵ x) ∧∀z.(zϵ x ⇒zϵ y) ∧∀z, w.(zϵ x ∧wϵ x ⇒zϵ w)
This axiom determines the meaning of the copula ϵ in the way adopted by
Le´sniewski: in spite of the copula occurring on either side of the equivalence,
its meaning can be revealed by requiring the equivalence to be true. The three
terms occurring on the right–hand side of the equivalence mean, respectively,
A ∃z.(zϵ x) means that the name x is not empty and that some object
responds to that name
B ∀z, w.(zϵ x ∧wϵ x ⇒zϵ w): letting z = w if and only if zϵ w ∧wϵ z,
we infer that the term B means that z = w for each pair z, w of objects re-
sponding to the name of x. Thus, x is a singular name
C The term ∀z.(zϵ x ⇒
zϵ y) means that each object responding to
the name of x responds as well to the name of y: in a sense x is contained
in y
From axiom AO, the following properties of the copula ϵ follow, cf., Slupecki
[54]
1. xϵ y ∧zϵx ⇒zϵ y;
2. xϵy ∧zϵx ⇒xϵ z;
3. xϵ y ⇒xϵ x.
The phrase ‘x is an object’ is rendered as xϵ V equivalent to ∃y.xϵ y. Then,
the equivalence
4. xϵ V ⇔xϵ x
does express the fact that x is an object.
In Mereology, the predicate part is applied to objects, called by singular
names.
The relation of part induces the relation of an ingredient, ingr, deﬁned as
ingr(x, y) ⇔π(x, y) ∨x = y
(5.1)
Clearly,
Proposition 5.1. The relation of ingredient is a partial order on objects,
i.e.,

5.1 Mereology: The Theory of Le´sniewski
193
1. ingr(x, x);
2. ingr(x, y) ∧ingr(y, x) ⇒(x = y);
3. ingr(x, y) ∧ingr(y, z) ⇒ingr(x, z).
We formulate the third axiom with a help from the notion of an ingredient.
M3 (Inference) For objects x, y, the property
I(x, y): For each object t, if ingr(t, x), then there exist objects w, z such
that ingr(w, t), ingr(w, z), ingr(z, y)
implies ingr(x, y).
The predicate of overlap, Ov in symbols, is deﬁned by means of
Ov(x, y) ⇔∃z.ingr(z, x) ∧ingr(z, y)
(5.2)
Using the overlap predicate, one can write I(x, y) down in the form
IOv(x, y) : For each t with ingr(t, x), there exists z such that ingr(z, y)
and Ov(t, z)
The notion of a mereological class follows; for a non–vacuous property Φ
of objects, the class of Φ, denoted ClsΦ is deﬁned by the conditions
C1 If Φ(x), then ingr(x, ClsΦ)
C2 If ingr(x, ClsΦ), then there exists z such that Φ(z) and IOv(x, z)
In plain language, the class of Φ collects in an individual object all objects
satisfying the property Φ.
The existence of classes is guaranteed by an axiom.
M4 For each non–vacuous property Φ there exists a class ClsΦ
The uniqueness of the class follows.
Proposition 5.2. For each non–vacuous property Φ, the class ClsΦ is
unique.
Proof. Assuming that for some Φ there exist two distinct classes Y1, Y2, con-
sider ingr(t, Y1). Then, by C2, and (5.2), there exists z such that Ov(t, z) and
ingr(z, Y2). It follows by M3 that ingr(Y1, Y2). By symmetry, ingr(Y2, Y1)
holds and Proposition 5.1(2) implies that Y1 = Y2
⊓⊔

194
5 Mereology
Proposition 5.3. For the non–vacuous property Φ, if for each object z such
that Φ(z) it holds that ingr(z, x), then ingr(ClsΦ, x).
Proof. It follows directly from M3
⊓⊔
The notion of an overlap allows for a succinct characterization of a class.
Proposition 5.4. For each non–vacuous property Φ and each object x, it
happens that ingr(x, ClsΦ) if and only if for each ingredient w of x, there
exists an object z such that Ov(w, z) and Φ(z).
Remark. Proposition 5.2 along with existence of a class is an axiom in the
Le´sniewski [42] scheme, from which M3 is derived. Similarly, it is an axiom
in the Tarski [60], [62] scheme.
Example 5.1. 1. The strict inclusion ⊂on sets is a part relation. The cor-
responding ingredient relation is the inclusion ⊆. The overlap relation is
the non–empty intersection. For a non–vacuous family F of sets, the class
ClsF is the union  F;
2. For reals in the interval [0, 1], the strict order < is a part relation and
the corresponding ingredient relation is the weak order ≤. Any two reals
overlap; for a set F ⊆[0, 1], the class of F is supF.
The notion of an element, Le´sniewski [42], par. 6, Def. IV, el(x, y) in symbols,
is deﬁned as follows
el(x, y) ⇔∃Φ.y = ClsΦ ∧Φ(x)
(5.3)
In plain words, el(x, y) means that y is a class of some property and x re-
sponds to that property.To establish some properties of the notion of an
element, we begin with
Proposition 5.5. For each object x, and the property INGR(x) = {y :
ingr(y, x)}, the identity x = ClsINGR(x) holds.
Proof. By Proposition 5.1(1), INGR(x) is non–vacuous and
ingr(x, ClsINGR(x))
That ingr(ClsINGR(x), x) follows by M3
⊓⊔
Proposition 5.6. For each pair x, y of objects, el(x, y) holds if and only if
ingr(x, y) holds. Hence, el = ingr.
Proof. By (5.3) and Proposition 5.5, if ingr(x, y) then el(x, y). The converse
follows from the deﬁnition of an element (5.3) and class requirement C1
⊓⊔

5.1 Mereology: The Theory of Le´sniewski
195
Corollary 1 If π(x, y), then el(x, y).
Corollary 2 el(x, x) holds for each object x.
By Corollary 2, every object considered in mereology is non–empty in the
sense of the element relation.
Corollary 3 The property of objects of not being its own element is vacuous.
Corollary 3 is one of means of expressing the impossibility of the Russell
paradox within the mereology, cf., Le´sniewski [42], Thms. XXVI, XXVII, see
also Soboci´nski [58].
Extensionality of the overlap relation can be inferred from Proposition 5.5.
Proposition 5.7. For each pair x, y of objects, x = y if and only if for each
object z, the equivalence Ov(z, x) ⇔Ov(z, y) holds.
Proof. Assume the equivalence Ov(z, x) ⇔Ov(z, y) to hold for each z. By
Proposition 5.5, if ingr(t, x) then Ov(t, x) and Ov(t, y) hence by axiom M3
ingr(t, y) and with t = x we get ingr(x, y). By symmetry, ingr(y, x) and by
Proposition 5.1(2), x = y
⊓⊔
Concerning the class properties, we mention
Proposition 5.8. For each pair of non–vacuous properties Φ, Ψ, from Φ ⇒Ψ
it follows that ingr(ClsΦ, ClsΨ).
Proof. The proposition is a direct consequence of the class deﬁnition C1, C2
and of M3
⊓⊔
A corollary follows.
Proposition 5.9. For each pair of non–vacuous properties Φ, Ψ, from Φ ⇔Ψ
it follows that ClsΦ = ClsΨ.
The notion of a subset, sub(x, y) is introduced in mereology, cf., Le´sniewski
[42], par. 10, Def. V, via the requirement
sub(x, y) ⇔∀z.[ingr(z, x) ⇒ingr(z, y)]
(5.4)
It follows immediately that
Proposition 5.10. For each pair x, y of objects, sub(x, y) holds if and only
if el(x, y) holds if and only if ingr(x, y) holds.
For the property Ind(x) ⇔xϵ x, one calls the class ClsInd, the universe, in
symbols V , Le´sniewski [42], par. 12, Def. VII.
It follows that
Proposition 5.11. The following are properties of the universe V

196
5 Mereology
1. The universe is unique;
2. ingr(x, V ) holds for each object x;
3. For each non–vacuous property Φ, it holds true that ingr(ClsΦ, V ).
The notion of an exterior object x to the object y, extr(x, y) in symbols,
Le´sniewski [42], par. 13, Def. VIII, is the following
extr(x, y) ⇔it is not true that Ov(x, y)
(5.5)
In plain words, x is exterior to y when no object is an ingredient both to x
and y.
Clearly,
Proposition 5.12. The operator of being exterior has properties
1. No object is exterior to itself;
2. extr(x, y) implies extr(y, x);
3. If for a non–vacuous property Φ, an object x is exterior to every object z
such that Φ(z) holds, then extr(x, ClsΦ).
The notion of a complement to an object, with respect to another object, is
rendered as a ternary predicate comp(x, y, z), Le´sniewski [42], par. 14, Def.
IX, to be read:‘x is the complement to y with respect to z’, and it is deﬁned
by means of the following requirements
1. x = ClsEXT R(y, z);
2. ingr(y, z),
where EXT R(y, z) is the property which holds for an object t if and only if
ingr(t, z) and extr(t, y) hold.
This deﬁnition implies that the notion of a complement is valid only when
there exists an ingredient of z exterior to y.
Proposition 5.13. For each triple x, y, z such that comp(x, y, z),
1. extr(x, y);
2. π(x, z);
3. comp(x, y, z) implies comp(y, x, z).

5.1 Mereology: The Theory of Le´sniewski
197
Proof. Property 1 follows from Proposition 5.12, 3. Property 2 follows from
Proposition 5.3 which implies ingr(x, z) and by Property 1, x is exterior
to y hence distinct from z. To prove Property 3, we need to verify that y =
ClsEXT R(x, z). Consider t such that ingr(t, z) and extr(t, x); was extr(t, y),
it would be that ingr(t, x), a contradiction. Hence, Ov(t, y) and it follows by
arbitrariness of t that y = ClsEXT R(x, z)
⊓⊔
We let for an object x, −x = ClsEXT R(x, V ). It follows from Proposition
5.13 that
Proposition 5.14. The operation −x has properties
1. −(−x) = x for each object x;
2. −V does not exist.
The operator −x can be a candidate for the boolean complement in a struc-
ture of a Boolean algebra within mereology, constructed in Tarski [61], and
anticipated in Tarski [60]; cf., in this respect Clay [13].
This algebra will be obviously rid of the null element, as the empty object
is not allowed in mereology of Le´sniewski, and the meet of two objects will be
possible only when these objects overlap. Under this caveat, the construction
of Boolean operators of join and meet proceeds on the following lines.
We let Booladd(x, y) to denote a property of objects deﬁned by
Booladd(x, y)(t) ⇔ingr(t, x) ∨ingr(t, y)
(5.6)
We denote the class ClsBooladd(x, y) with the symbol x + y. As properties
ingr(t, x) ∨ingr(t, y) and ingr(t, y) ∨ingr(t, x) are equivalent, we have by
Proposition 5.9 that
Proposition 5.15. x + y = y + x.
Similarly, properties (ingr(t, x) ∨ingr(t, y)) ∨ingr(t, z) and ingr(t, x) ∨
(ingr(t, y)) ∨ingr(t, z)) are equivalent, hence
Proposition 5.16. (x + y) + z = x + (y + z).
Consider now x+(−x): the deﬁning property is Φ(t) : ingr(t, x)∨ingr(t, −x).
For an arbitrary object z, either exists w such that Ov(z, w) ∧ingr(w, x)
or exists v such that Ov(z, v) ∧ingr(v, −x), otherwise an easily perceived
contradiction takes place, hence, ingr(z, x+(−x)) and a fortiori x+(−x) = V .
We arrive at
Proposition 5.17. x + (−x) = V .
The object x + y has the property
Proposition 5.18. For each object z, the equivalence holds: Ov(z, x + y) ⇔
Ov(z, x) ∨Ov(z, y).

198
5 Mereology
Proof. Ov(z, x + y) means the existence of w such that ingr(w, z) and
ingr(w, x + y) hence for some t such that Ov(w, t) one has ingr(t, x) ∨
ingr(t, y) and thus for some u with ingr(u, t), ingr(u, w) it follows that
ingr(u, z) and ingr(u, x) ∨ingr(u, y) so ﬁnally Ov(z, x) ∨Ov(z, y). The con-
verse implication follows easily
⊓⊔
For each pair x, y of overlapping objects, we introduce a property Boolprod(x,
y) deﬁned as
Boolprod(x, y)(t) ⇔ingr(t, x) ∧ingr(t, y)
(5.7)
We denote the class ClsBoolprod(x, y) with x · y.
As with + operation, one can prove properties of ·.
Proposition 5.19. Under the assumption that Ov(x, y), Ov(y, z), Ov(x·y, z)
the following properties hold
1. x · y = y · x;
2. (x · y) · z = x · (y · z);
3. x · (−x) is not deﬁned.
The property counterparting 5.18 reads as follows
Proposition 5.20. Assume the existence of non–empty complement. Then,
for each object z it holds that ingr(z, x · y) ⇔ingr(z, x) ∧ingr(z, y).
Proof. Assume ingr(z, x·y) so for each v with ingr(v, z), there is w such that
Ov(v, w) and ingr(w, x), ingr(w, y); hence there is u such that ingr(u, v),
ingr(u, w), ingr(u, x), ingr(u, y) and ingr(u, x · y). However, was, e.g., ¬
ingr(z, x) we would have t such that ingr(t, x) and extr(t, x), contradict-
ing the case v = t considered in the preceding sentence. Thus, ingr(z, x),
ingr(z, y) must hold and the proposition is proved as the converse implication
follows directly by the class deﬁnition
⊓⊔
Boolean relations hold between x + y and x · y, viz.,
Proposition 5.21. The following relations between + and · are valid
1. −(x + y) = (−x) · (−y);
2. −(x · y) = (−x) + (−y).
Proof. Deﬁning properties, respectively, for −(x + y) and (−x) · (−y) are
¬[(ingr(t, x) ∨ingr(t, y)] and (¬ingr(t, x)) ∧(¬ingr(t, y)), respectively, and
are equivalent, hence, classes of them are identical. Similarly, the second iden-
tity follows
⊓⊔

5.2 A Modern Structural Analysis of Mereology
199
For each object x, we construct a set σ(x) by letting
σ(x) = {y : ingr(y, x)}
(5.8)
The meaning of σ(x) is that this set consists of objects which are ingredients
of x and it does correspond to class of ingredients of x.
Proposition 5.22. Assume the existence of non–vacuous complement for all
pairs a, b with π(a, b). Objects satisfying Booladd(x, y) make the set σ(x) ∪
σ(y). Then, x + y corresponds to σ(x) ∪σ(y).
Proof. Assume ingr(t, x + y); then, for each w, if ingr(w, t), then Ov(w, z),
ingr(z, x)∨ingr(z, y) for some z. Assume that neither ingr(t, x) nor ingr(t, y).
By complement assumption, there exist u, v such that ingr(u, t), ingr(v, t),
extr(u, x), extr(v, y). The exteriority of u to x and v to y contradicts the
preceding sentence
⊓⊔
Objects satisfying Boolprod(x, y) constitute the set σ(x)∩σ(y) by Proposition
5.20. The class x · y corresponds to the set σ(x) ∩σ(y).
Finally, we consider the set V \σ(x) corresponding to the class Cls¬Ov(x)
of the property ¬Ov(x) which we denote −x. Then
Proposition 5.23. The correspondence ι : x →σ(x) is an isomorphism
satisfying ingr(u, v) ⇔σ(u) ⊆σ(v). At this correspondence, x+y maps onto
σ(x)∪σ(y), x·y maps onto σ(x)∩σ(y), and −x maps onto U \σ(x). The Cls
operator acts as the least upper bound operator, mapping a class of a property
Φ onto the union {σ(x) : Φ(x)}.
5.2
A Modern Structural Analysis of Mereology
An ex post analysis of the structure of Le´sniewski’s mereological theory has
resulted in some stratiﬁcation of the theory into more or less stronger sub–
theories, e.g., in the way proposed in Casati–Varzi [10].
The basic notion is that of ingredient, subject to postulates
P1 ingr(x, x)
P2 ingr(x, y) ∧ingr(y, x) ⇒(x = y)
P3 ingr(x, y) ∧ingr(y, z) ⇒ingr(x, z)
The theory supporting P1–P3 is called Ground Mereology and denoted M. It
does encompass a theory of ingredients and parts as partial and strict orders
on a universe of objects. Clearly, parts are deﬁned by means of
π(x, y) ⇔ingr(x, y) ∧¬ingr(y, x)
(5.9)

200
5 Mereology
The relation Overlap is deﬁned as above and the dual predicate of underlap
is deﬁned by means of
U(x, y) ⇔∃z.ingr(x, z) ∧ingr(y, z)
(5.10)
Combinations of these predicates for expressing various possible positions of
each object relative to the other are possible, like proper over–crossing PO
PO(x, y) ⇔Ov(x, y) ∧¬ingr(x, y) ∧¬ingr(y, x)
(5.11)
Further extensions are proposed by means of postulates which would secure
the existence of complementary parts within objects , cf., the notion of a
complement above; complementation is expressed by means of two postu-
lates, see Casati–Varzi, op. cit., and Simons [52], a throughout discussion in
Simons [53], viz., the Postulate of Weak Supplementation
P4 π(x, y) ⇒∃z.ingr(z, y) ∧¬Ov(x, z)
and the Postulate of Strong Supplementation
P5 ¬ingr(y, x) ⇒∃z.ingr(z, y) ∧¬Ov(x, z)
As from π(x, y) it follows that ¬ingr(y, x), P4 follows from P5. Since
¬ingr(y, x) does not imply π(x, y), the converse does not hold. The theory
M+P5 denoted EM and called the extensional mereology is stronger than
the theory M+P4 denoted MM and called the minimal mereology. In the
latter, extensionality with respect to parts holds: If objects x, y have parts,
then ∀z.π(z, x) ⇔π(z, y) ⇒(x = y), see Casati–Varzi [10], p. 40.
Further postulates bring closer to fusion properties – the existence of sums
(classes in the sense of Le´sniewski) and intersections (called also products);
a ﬁnitary version requires that objects in underlap relation should be encom-
passed in the smallest object which contains them
P6 U(x, y) ⇒∃z.∀w.[Ov(w, z) ⇔Ov(w, x) ∨Ov(w, y)]
and, dually, overlapping objects contain the greatest object contained in ei-
ther of them
P7 Ov(x, y) ⇒∃z.∀w.[ingr(w, z) ⇔ingr(w, x) ∧ingr(w, y)]
The theory M + P6, P7 is called the closure mereology denoted CM, MM+
P6,P7 is called the closure minimal mereology denoted CMM, and EM +P6,
P7 is the closure extensional mereology denoted CEM. As M ⊆MM ⊆
EM, it follows that M ⊆CM, MM ⊆CMM, EM ⊆CEM, CMM ⊆
CEM. Actually, as pointed to in Casati–Varzi [10], p. 44, P4 ⇒(P7 ⇒P5),
hence CEM=CMM. Finally, GEM, the general extensional mereology is the

5.3 Mereotopology
201
mereology exposed above in sect. 5.1., i.e., the mereology as envisioned by
Le´sniewski, with full power of fusion, secured by the general notion of a class.
5.3
Mereotopology
Topological structures which arise in mereology due to Le´sniewski, can be
induced from overlap relations. As the ﬁrst approximation to topology, let us
deﬁne for each object x, its closure c(x) by means of
c(x) = ClsOv(x)
(5.12)
where the property Ov(x) is deﬁned by Ov(x)(y) ⇔Ov(x, y), i.e., we build
the closure c(x) as the class of objects which overlap with x.
We have
Proposition 5.24. The closure operator c(.) has the following properties
Cl1 ingr(x, c(x)
Cl2 If ingr(x, y), then ingr(c(x), c(y))
Cl3 ingr(c(x · y), c(x) · c(y))
Cl4 c(x + y) = c(x) + c(y)
Proof. Cl1 and Cl2 follow from deﬁnition of the overlap relation and the class
deﬁnition. For Cl3, if ingr(t, c(x · y)), then there is z such that Ov(t, z) and
Ov(z, x·y) thus for some w one has Ov(z, w) and ingr(w, x), ingr(w, y) which
imply that ingr(t, c(x)), ingr(t, c(y)) and ﬁnally ingr(t, c(x) · c(y)). By M3,
ingr(c(x · y), c(x) · c(y)).
For Cl4, it suﬃces to observe that Ov(z, x + y) ⇔Ov(z, x) ∨Ov(z, y)
⊓⊔
Another possibility for a topology is in iteration of the operator c, viz, we let
Ovn+1(x, y) ⇔∃z.Ov(x, z) ∧Ovn(z, y); Ov1(x, y) ⇔Ov(x, y)
(5.13)
and we deﬁne
OV LP(x)(y) ⇔∃n.Ovn(x, y)
(5.14)
The closure Cl(x) is deﬁned as the class of the property OV LP(x), i.e.,
Cl(x) = ClsOV LP(x)
(5.15)
The operator Cl(x) has the following properties

202
5 Mereology
Proposition 5.25. Properties of Cl(x) are
CL1 Cl(Cl(x)) = Cl(x)
CL2 ingr(x, Cl(x))
CL3 ingr(x, y) implies ingr(Cl(x), Cl(y))
CL4 Cl(x + y) = Cl(x) + Cl(y)
Proof. CL2, CL3 follow straightforwardly from deﬁnitions. For CL1, ob-
serve that ingr(t, Cl(x)) if and only if OV LP(x)(t). Thus, ingr(t, Cl(Cl(x)))
if and only if OV LP(Cl(x))(t) if and only if OV LP(x)(t) if and only if
ingr(t, Cl(x)).
For CL4, assume ﬁrst that ingr(t, Cl(x + y)) hence OV LP(t, x + y)
and thus OV LP(t, x) ∨OV LP(t, y), i.e., ingr(t, Cl(x)) ∨ingr(t, Cl(y)) and
thus ingr(t, Cl(x) + Cl(y)). Assume now that ingr(t, Cl(x) + Cl(y)), i.e.,
OV LP(t, x)∨OV LP(t, y), so there exists m such that Ovm(t, x)∨Ovm(t, y),
i.e., Ovm(t, x+y), hence, ingr(t, Cl(x+y))
⊓⊔
It follows that the operator Cl is a genuine closure operator; its properties are
weak, as it in fact delineates components of objects with respect to the overlap
property: it is not even a T0–closure operator (a Kolmogoroﬀoperator) which
would mean that distinct objects should have distinct closures, as distinct
objects in the same component have the same closure.
A deﬁnition of a boundary can be attempted on the lines of topological
boundary concept. For an object x, let a property Υ(x) be deﬁned as follows
Υ(x)(t) ⇔ingr(t, x) ∧∀z.[Ov(z, x) ∧Ov(z, −x) ⇒Ov(z, t)]
(5.16)
We may deﬁne the boundary of x, Fr(x), by letting
Fr(x) = ClsΥ(x)
(5.17)
Proposition 5.26. Properties of Fr(x) following directly from deﬁnitions
above are
1. ingr(Fr(x), x);
2. ∀z.Ov(z, x) ∧Ov(z, −x) ⇒Ov(z, Fr(x)).
The above notion of a boundary has a topological ﬂavor; however, the no-
tion of a boundary has a much wider scope. It can also support the idea of
a separator between two objects within a third, which does encompass ei-
ther, like a river ﬂowing through a town separates parts on opposite banks.
To implement this idea, for objects x, y, such that extr(x, y), we deﬁne the
property

5.4 Timed Mereology
203
Ω(x, y)(t) ⇔extr(t, x) ∧extr(t, y)
(5.18)
and we let
Bd(x, y) = ClsΩ(x, y)
(5.19)
Then
Proposition 5.27. The boundary operation Bd has properties
1. Bd(x, y) = Bd(y, x).
2. Bd(x + y, z) = Bd(x, z) · Bd(y, z).
Proof. Property 1 is obvious. Property 2 follows from the equivalence extr(x+
y, z) ⇔extr(x, z)∧extr(y, z)
⊓⊔
A relative variant can be deﬁned; assuming that ingr(x, z), ingr(y, z) and
extr(x, y), a boundary relative to z between x and y, Bdz(x, y), is the class
of objects t such that ingr(t, z), extr(t, x), extr(t, y) provided this property
is non–vacuous.
5.4
Timed Mereology
Timed component of mereology was introduced in Tarski [62], and presented
in a systematic way in Woodger [68], [69]. The time component is introduced
into the framework of mereology with a set of notions and postulates (axioms)
concerning aspects of time like momentariness, coincidence in time, time
slices.
Objects are considered as spatial only and their relevance to time is ex-
pressed as momentary or as spatial and extended in time and then the pred-
icate of part is understood as a global descriptor covering spatio–temporal
extent of objects whereas the temporal extension is described by the predi-
cate Temp (T) with the intended meaning that T (u, v) means that the object
u precedes in time the object v (in terminology of Le´sniewski, Tarski and
Woodger: u wholly precedes v) meaning that, e.g., when u and v have some
temporal extent, then u ends before or at the precise moment when v begins.
We follow in our exposition the presentation in Woodger [69], to whom
all results belong. Proofs are mostly supplied by this author to make the
exposition more accessible.
The property (predicate) Mom meaning momentary being is introduced to
denote objects having only spatial aspect. This predicate is introduced by
means of the following postulate
MOM Mom(x) ⇔T (x, x)
(5.20)
Thus, x begins and ends at the same time, so its time aspect is like a spike
in time; it renders the phrase ‘to exist in a moment of time’.

204
5 Mereology
The predicate T is required to satisfy postulates
TM1 T (x, y) ∧T (y, z) ⇒T (x, z)
TM2 Mom(x) ∧Mom(y) ⇒T (x, y) ∨T (y, x)
TM3 T (x, y) ⇔∀u, v.ingr(u, x) ∧ingr(v, y) ⇒T (u, v)
Postulate TM1 states that T is transitive, Postulate TM2 does state that
of two momentary things, one precedes the other and Postulate TM3 relates
T to the class operator, i.e., x precedes y if and only if each ingredient of
x precedes each ingredient of y. Postulate TM3 provides a link between the
part based mereology and the timed mereology, bonding spatial and temporal
properties of objects.
As a consequence to postulates TM1–TM3, one obtains
Proposition 5.28. The following properties result from postulates TM1–
TM3
1. Mom(x) ⇔∃y.T (x, y) ∧T (y, x);
2. ingr(u, x) ∧T (x, y) ⇒T (u, y);
3. T (ClsΦ, x) ⇔∀y.Φ(y) ⇒T (y, x);
4. T (x, ClsΦ) ⇔∀y.Φ(y) ⇒T (x, y);
5. Mom(ClsΦ) ⇔∀x, y.Φ(x) ∧Φ(y) ⇒T (x, y).
Proof. Property 1 follows by Postulate (5.20) and Postulate TM2: T (x, y) ∧
T (y, x) implies T (x, x) by Postulate TM2, hence, Mom(x) by (5.20). Property
2 follows by Postulate TM3 as ingr(u, x), ingr(y, y), T (x, y) imply T (u, y).
Property 3 follows from Postulate TM3: from ingr(x, x), ingr(u, x) it follows
that for some z, it happens that Ov(u, z) ∧Φ(z), hence ingr(z, ClsΦ), hence,
by Postulate TM3, T (z, x) and by the class deﬁnition, T (u, x).
Property 4 is dual to Property 3. Property 5 follows by (5.20) and either
Property 3, or Property 4 applied to the pair ClsΦ, ClsΦ
⊓⊔
Remark. Concisely, one can write down Property 2 in the form: ingr◦T = T ,
hence, T = T ◦ingr−1, where ingr denotes the ingredient relation.
The notion of a coincidence in time, CT in symbols, needs a deﬁning
postulate
CT (x, y) ⇔T (x, y) ∧T (y, x)
(5.21)
Hence, the relation of coincidence in time is symmetric and transitive.
Properties of coincidence in time can be summed up as follows

5.4 Timed Mereology
205
Proposition 5.29. Operation CT has properties
1. Mom(x) ⇔∀y.ingr(y, x) ⇒CT (y, x);
2. Mom(x) ∧Mom(y) ∧Ov(x, y) ⇒CT (x, y);
3. Mom(ClsΦ) ⇔∃x.[Φ(x) ∧∀y.Φ(y) ⇒CT (y, x)].
Proof. Property 1 follows by (5.20) implying T (x, x) from which by Postulate
TM3 it follows that if ingr(y, x) then T (y, x) and by Proposition 5.28(1) by
which T (x, y), hence, CT (x, y). This proves the implication from left to right.
The converse implication follows by deﬁnition (5.21). Property 2 follows by
Property 1 and transitivity of CT . Property 3 follows from Property 1 with
ClsΦ in place of x and transitivity of CT
⊓⊔
The notion of being wholly before in time is rendered as a predicate Z deﬁned
as follows
Z(x, y) ⇔Mom(x) ∧Mom(y) ∧¬T (y, x)
(5.22)
Hence, Z(x, y) means that the momentary object x is wholly before the mo-
mentary object y in time.
By Postulate TM2, Z(x, y) implies T (x, y). Hence,
Proposition 5.30. For each pair of momentary objects x, y the equivalence
T (x, y) ⇔CT (x, y) ∨Z(x, y)
holds. Meaning that in case T (x, y) holds, either x, y coincide in time or x is
wholly before y in time.
Proof. By deﬁnitions of CT and Z, if T (x, y) then either T (y, x) and hence
CT or ¬T (y, x) , hence, Z(x, y)
⊓⊔
Proposition 5.31. If x, y are momentary objects and Z(x, y), then neither
ingr(x, y) nor ingr(y, x).
Proof. By Proposition 5.29, if either ingr(x, y) or ingr(y, x), then CT (x, y)
which excludes Z(x, y) by virtue of respective deﬁnitions
⊓⊔
Proposition 5.31 sets another important link between spatial and temporal
aspects of objects. Actually in this proposition the condition that neither of
objects is an ingredient of the other can be replaced by demanding that the
objects do not overlap.
Finally, the notion of a time–slice is introduced, as a predicate Slc(x, y)
by means of
Slc(x, y) ⇔Mom(x) ∧ingr(x, y) ∧∀z.[ingr(z, y) ∧C(z, x) ⇒ingr(z, x)]
(5.23)

206
5 Mereology
and thus a time–slice of an object y is an ingredient of y which is spatially
so arranged that any ingredient of y coinciding with it in time is also its
ingredient.Time slices are unique up to coincidence in time.
Proposition 5.32. If x, y are time–slices of z, then x, y coincide in time if
and only if x = y.
Proof. By deﬁnition (5.23), one has ingr(x, y), ingr(y, x), hence, x = y
⊓⊔
Each object is the class of its time slices. To prove this statement, ﬁrst we
note that
Proposition 5.33. Given a momentary ingredient x of an object y, the class
CT (y, x) of all ingredients of y which coincide in time with x is a time–slice
of y coincident in time with x.
Proof. Clearly, CT (y, x) is an ingredient of y. By Postulate TM3, the class
CT (y, x) coincides in time with x. By transitivity of T , any ingredient of y
which coincides in time with CT (y, x) also coincides in time with x, hence,
is an ingredient of CT (y, x). It follows that C(y, x) is a time–slice of y
⊓⊔
Proposition 5.33 suggests the way of embedding any ingredient of an object
into a time–slice of that object. As any object is the class of its ingredients,
it follows that
Proposition 5.34. Each object x is the class of its ingredients which are its
time–slices.
Among time–slices of an object, one can distinguish the ﬁrst (beginning) and
the last (ending) time–slices.
A time–slice x of an object y is a ﬁrst time–slice of y if and only if each
time–slice z of y such that T (z, x) is identical with x; similarly, a time–slice
w of y is an ending time–slice of y if each time–slice z of y such that T (w, z)
is identical with w.
Proposition 5.35. The important properties of ﬁrst and last time–slices are
1. Each ﬁrst time–slice x of an object y satisﬁes T (x, y);
2. Each last time–slice w of an object y satisﬁes T (y, w).
Proof. As Statement 2 is dual to Statement 1, it suﬃces to verify the latter.
Consider thus the ﬁrst time–slice x of y. For any other time–slice z ̸= x of y,
we have by Proposition 5.32 and by Postulate TM2 that T (x, z), hence, by
Proposition 5.34 and Postulate TM3 it follows that T (x, y)
⊓⊔
One can deﬁne a temporal interior of an object y as the separator Fr(x, w, y)
between a ﬁrst time–slice x and the last time–slice w of y relative to y.

5.5 Spatio–temporal Reasoning: Cells
207
5.5
Spatio–temporal Reasoning: Cells
A theory of cells, motivated by phenomenology of cell biology, but in fact an
abstract timed mereology of time–evolving spatial structures, was developed
in detail in Woodger [69], Ch. 2, see also Tarski [62].
By a cell an object y is understood for which an ingredient x exists with
T (x, y) and an ingredient w exists such that T (y, w). Hence, a cell is time–
bounded by some time–preceding object and some time–following object.
We denote the fact that y is a cell with the symbol cell(y). Formally
TM4 cell(y) ⇔∃x, w.[ingr(x, y) ∧ingr(w, y) ∧T (x, y) ∧T (y, w)]
The next postulate asserts that no cell is a momentary object,
TM5 cell(y) ⇒¬Mom(y)
We recall that the part relation is denoted with the symbol π. A ﬁrst time–
slice x of a cell y, respectively, a last time–slice w of y, will be denoted by
Beg(y), respectively End(y). The last postulate about cells follows
TM6 cell(y1) ∧cell(y2) ∧y1 ̸= y2 ∧Ov(y1, y2) ⇒π(Beg(y1), End(y2)) ∨
π(End(y1), Beg(y2))
Properties of cells are collected in
Proposition 5.36. The following are properties of cells
1. If cell(y), then the class C of ingredients x of y for which T (x, y) holds is
a momentary ingredient of y such that T (C, y) holds;
2. The class C of Statement 1 is a ﬁrst time–slice of y;
3. If cell(y), then the class D of ingredients w of y for which T (y, w) holds
is a momentary ingredient of y such that T (y, D) holds;
4. The class D of Statement 2 is a last time–slice of y.
Proof. As Statements 3 and 4 are dual to, respectively, Statements 1 and 2, it
suﬃces to verify the latter. Concerning Statement 1, by Remark 1, for ingre-
dients z, y of x such that T (z, x), T (y, x) it follows (in view of T ◦ingr−1 = T )
that T (z, y) which by Postulate TM3 implies that T (y, z) hence by Proposi-
tion 5.28, T (x, x), hence, Mom(x) follows by Postulate TM1. Clearly, T (C, x)
by Proposition 5.28, again. Concerning Statement 2, clearly, C is a ﬁrst time–
slice by its deﬁnition
⊓⊔

208
5 Mereology
Proposition 5.37. Properties of ﬁrst and last time–slices are
1. For any cell x, the ﬁrst time–slice Beg(x) is not the last time–slice End(x);
2. For any cell x, T (Beg(x), End(x));
3. For any cell x, Z(Beg(x), End(x)).
Proof. By transitivity of T , in case 1, was it otherwise, we would have T (x, x)
contradicting Postulate TM5 in view of Postulate TM1. For Statement 2, it
follows by transitivity of T from Proposition 5.36 1, 3. Statement 3 follows
by deﬁnition (5.22) of the predicate Z and by Postulate TM4 about cells, and
transitivity of T
⊓⊔
Postulate TM6 implies that
Proposition 5.38. For two distinct cells x, y, if
C(Beg(x), Beg(y)) or C(End(x), End(y))
then neither ingr(Beg(x), End(y)) nor ingr(End(x), Beg(y)).
Proof. Was, e.g., C(Beg(x), Beg(y)) and ingr(Beg(x), End(y)), one would
have Z(Beg(y), Beg(x)) contradicting C(Beg(x), Beg(y)). Similarly for other
combinations of terms in the premise and in the conclusion
⊓⊔
The following is true in consequence
Proposition 5.39. For cells x, y with the property that C(Beg(x), Beg(y))
or C(End(x), End(y)), if Ov(x, y), then x = y.
Proof. Premises imply by Proposition 5.38 that neither ingr(Beg(x), End(y))
nor ingr(End(x), Beg(y)) contradicting Postulate TM6 in case x ̸= y
⊓⊔
A corollary specializes Proposition 5.39
Corollary 1. For cells x, y, the following are equivalent
1. Beg(x) = Beg(y);
2. End(x) = End(y);
3. x = y.
Proof. Assumptions of Proposition 5.39 are satisﬁed
⊓⊔
Operations on cells include division and fusion.
A cell x arises by division from a cell y if and only if π(Beg(x), End(y)).
We write the fact down as Div(x, y).
Then, by already proven statements,

5.6 Mereology Based on Connection
209
Proposition 5.40. If Div(x, y), then Z(Beg(x), Beg(y), T (y, x), and x ̸= y.
A dual operation of fusion is deﬁned as follows.
A cell x arises by fusion of a cell y with some other cell if and only if
π(End(y), Beg(x)). We write down the fact as Fus(x, y).
A dual proposition to 5.40 is stated as follows
Proposition 5.41. If Fus(x, y),
then Z(Beg(y), Beg(x)), T (y, x), and
x ̸= y.
It follows from deﬁnitions of division and fusion that
Proposition 5.42. There exists no cell x which can divide and fuse with the
same other cell y. There can be no cell which could arise by division and
fusion from the same other cell.
5.6
Mereology Based on Connection
A dual approach to parts, was initiated in Whitehead [64], [65], [66] in a
form of propositions of axioms for the notion of ‘x extends over y’, dual to
that of a part, and of vague proposals of desired properties of the notion.
Th. de Laguna [37] published a variant of the Whitehead scheme, which led
Whitehead [67] to another version of his approach, based on the notion of
‘x is extensionally connected to y’. Connection Calculus based on the notion
of a ‘connection’ was proposed in Clarke [12], and this version is presented
here, see also Calculus of Individuals of Leonard and Goodman [40].
The relation/predicate of connection C is subject to basic requirements,
see Clarke [12], A0.1, A0.2
CN1 C(x, x) for each object x
CN2 If C(x, y), then C(y, x) for each pair x, y of objects
It follows that connection is reﬂexive and symmetric. This theory is sometimes
called Ground Topology T, cf., Casati–Varzi [10]. Adding the extensionality
requirement
CN3 If ∀z.[C(z, x) ⇔C(z, y)], then x = y
produces the Extensional Ground Topology ET., loc. cit.
Let us observe that within the mereology M, the predicate C can be real-
ized by taking C = Ov; clearly, CN1–CN3 are all satisﬁed with Ov. We call
this model of connection mereology, the Overlap model, denoted OV M.
In the universe endowed with C, satisfying CN1, CN2, one can deﬁne the
notion of an ingredient ingrC by letting
IC ingrC(x, y) ⇔∀z.[C(z, x) ⇒C(z, y)]
(5.24)

210
5 Mereology
Then,
Proposition 5.43. (Clarke [12]) The following properties of ingrC hold
1. ingrC(x, x);
2. ingrC(x, y) ∧ingrC(y, z) ⇒ingrC(x, z);
3. In presence of CN3, ingrC(x, y) ∧ingrC(y, x) ⇒x = y;
4. ingrC(x, y) ⇔∀z.[ingr(z, x) ⇒ingr(z, y)];
5. ingrC(x, y) ∧C(z, x) ⇒C(z, y);
6. ingrC(x, y) ⇒C(x, y).
The notion of a part πC can be introduced as
PC πC(x, y) ⇔ingrC(x, y) ∧x ̸= y
(5.25)
By deﬁnition (5.25), πC satisﬁes requirements of mereology for the notion of
a part
Proposition 5.44. (Clarke [12]) Properties of part are
1. ¬πC(x, x);
2. πC(x, y) ∧πC(y, z) ⇒πC(x, z);
3. πC(x, y) ⇒ingrC(x, y);
4. πC(x, y) ⇒¬πC(y, x).
The predicate of overlapping, OvC(x, y) is deﬁned by means of
OC OvC(x, y) ⇔∃z.[ingrC(z, x) ∧ingrC(z, y)]
(5.26)
Basic properties of overlapping follow.
Proposition 5.45. (Clarke [12]) Properties of overlapping are
1. OvC(x, x);
2. OvC(x, y) ⇔OvC(y, x);
3. OvC(x, y) ⇒C(x, y);

5.6 Mereology Based on Connection
211
4. ingrC(x, y) ∧OvC(z, x) ⇒OvC(z, y);
5. ingrC(x, y) ⇒OvC(x, y).
The counterpart of the notion of an exterior object, extrC is deﬁned by means
of
EC extrC(x, y) ⇔¬OvC(x, y)
(5.27)
Proposition 5.46. (Clarke [12]) The property
[ingrC(x, y) ∧extrC(z, y)] ⇒extrC(z, x).
holds by Property 4 in Proposition 5.45.
A new notion due to connectedness is the notion of external connectedness,
EC in symbols, deﬁned as follows
EC EC(x, y) ⇔C(x, y) ∧extr(x, y)
(5.28)
It is easy to see that in the model OV M, EC is a vacuous notion. Clearly,
by deﬁnition (5.28),
Proposition 5.47. (Clarke [12]) The following properties of external con-
nectedness hold
1. ¬EC(x, x);
2. EC(x, y) ⇔EC(y, x);
3. C(x, y) ⇔EC(x, y) ∨OvC(x, y);
4. OvC(x, y) ⇔C(x, y) ∧¬EC(x, y);
5. ¬EC(x, y) ⇔[OvC(x, y) ⇔C(x, y)]: This is a logical rendering of our
remark that in OV M, no pair of objects is in EC, hence, ¬EC(x, y) =
T RUE for each pair of objects;
6. ¬∃z.EC(z, x) ⇒{ingrC(x, y) ⇔[∀w.OvC(w, x) ⇒OvC(w, y)]}.
Proof. A comment in the way of proof. The implication
ingrC(x, y) ⇒[∀w.OvC(w, x) ⇒OvC(w, y)]
is always true. Thus, it remains to assume that
(i) ¬∃z.EC(z, x)

212
5 Mereology
and to prove that
(∗) [∀w.OvC(w, x) ⇒OvC(w, y)] ⇒ingrC(x, y)
Assumption (i), can be written down as
(ii) ∀z.¬C(z, x) ∨OvC(z, x)
To prove that ingrC(x, y) it should be veriﬁed that
(iii) ∀z.(C(z, x) ⇒C(z, y)).
Consider an arbitrary object z′; either ¬C(z′, x) in which case implication
in (iii) is satisﬁed with z′, or, OvC(z′, x), hence, OvC(z′, y) by the assumed
premise in (*), which implies that C(z′, y). The implication (iii) is proved and
this concludes the proof
⊓⊔
The richer structure of connection based calculus allows for some notions
of a topological nature; the ﬁrst is the notion of a tangential ingredient, in
symbols: T ingrC(x, y) deﬁned by means of
T I T ingrC(x, y) ⇔ingrC(x, y) ∧∃z.EC(z, x) ∧EC(z, y)
(5.29)
Basic properties of tangential parts follow by deﬁnition TI
Proposition 5.48. The following are basic properties of the predicate T ingrC
1. ∃z.EC(z, x) ⇒T ingrC(x, x);
2. ¬∃z.EC(z, y) ⇒¬existsx.T ingrC(x, y);
3. T ingrC(z, x) ∧ingrC(z, y) ∧ingrC(y, x) ⇒T ingrC(y, x).
Proof. For Property 3, some argument may be in order; consider w such that
EC(w, x), EC(w, z) existing by T ingrC(z, x). hence, C(w, y). As ¬OvC(w, x),
it follows that ¬OvC(w, y), hence, EC(w, y), and T ingrC(y, x)
⊓⊔
These properties witness the fact that if there is something externally con-
nected to x, then x is its tangential ingredient. This fact shows that the
notion of a tangential ingredient falls short of the idea of a boundary. Dually,
in absence of objects externally connected to y, no ingredient of y can be a
tangential ingredient.
An object y is a non–tangential ingredient of an object x, NT ingrC(y, x)
in symbols, in case, it is an ingredient but not any tangential ingredient of x
NT I NT ingrC(y, x) ⇔¬T ingrC(y, x) ∧ingrC(y, x)
(5.30)

5.6 Mereology Based on Connection
213
Proposition 5.49. Basic properties of the operator NTI are
1. NT ingrC(y, x) ⇒∀z.¬EC(z, y) ∨¬EC(z, x);
2. ¬∃z.EC(z, x) ⇒NT ingrC(x, x).
In absence of externally connected objects, each object is a non–tangential
ingredient of itself.
Hence, in the model OV M, each object is its non–tangential ingredient
and it has no tangential ingredients.
To produce models in which EC, NT ingrC, T ingrC will be exhibited, we
may resort to topology; we recall, see Ch.2, sect. 6, that a regular open set
in a topological space X, is a set A ⊆X such that A = IntClB for some set
B ⊆X.
We deﬁne in the space RO(X) of regular open sets in a regular space X
(recall that a topological space is regular if for each element x, each neigh-
borhood of x contains closure of another neighborhood of x, see Ch. 2, sect.
6) the connection C by demanding that C(A, B) ⇔ClA ∩ClB ̸= ∅. For
simplicity sake, we assume that the regular space X is connected, so no set
in it is clopen, equivalently, the boundary of each set is non–empty.
When investigating properties of a model ROM, we refer to Ch. 2,
sect. 6.
First, we investigate what ingrC means in ROM. By deﬁnition IC in (5.24),
for A, B ∈RO(X),
ingrC(A, B) ⇔∀Z ∈RO(X).ClZ ∩ClA ̸= ∅⇒ClZ ∩ClB ̸= ∅
This excludes the case when A \ ClB ̸= ∅as then we could ﬁnd a Z ∈RO(X)
with
Z ∩A ̸= ∅= ClZ ∩ClB
(as our space X is regular). It remains that A ⊆ClB, hence, A ⊆IntClB = B.
It follows ﬁnally that
Proposition 5.50. In model ROM, ingrC(A, B) ⇔A ⊆B.
It follows that in ROM ingredient means containment with connection C as
intersection of closures.
Now, we can interpret overlapping in ROM. For A, B ∈RO(X), OvC(A, B)
means that there exists Z ∈RO(X) such that Z ⊆A and Z ⊆B
henceZ ⊆A ∩B, hence
A ∩B ̸= ∅
This condition is also suﬃcient by regularity of X. We obtain
Proposition 5.51. In ROM, OvC(A, B) ⇔A ∩B ̸= ∅.

214
5 Mereology
The status of EC in ROM is then
Proposition 5.52. In ROM,
EC(A, B) ⇔ClA ∩ClB ̸= ∅∧A ∩B = ∅
This means that closed sets ClA, ClB do intersect only at their boundary
points.
We can address the notion of a tangential ingredient: T ingrC(A, B) means
the existence of Z ∈RO(X) such that
ClZ ∩ClA ̸= ∅̸= ClZ ∩ClB
and
Z ∩A = ∅= Z ∩B
along with A ⊆B.
In case
ClA ∩(ClB \ B) ̸= ∅
letting Z = X \ ClB we have
ClZ = Cl(X \ ClB)
and
BdZ = ClZ \ Z = Cl(X \ ClB) \ (X \ ClB)
which in turn is equal to
Cl(X \ ClB) ∩ClB = Cl(X \ B) ∩ClB = BdB
Hence, ClB \ B ⊆ClZ, and ClZ ∩ClA ̸= ∅; a fortiori, ClB ∩ClZ ̸= ∅. As
Z ∩B = ∅, a fortiori Z ∩A = ∅follows.
We know, then, that if
ClA ∩(ClB \ B) ̸= ∅⇒T ingrC(A, B)
Was to the contrary, ClA ⊆B, from Z ∩ClA ̸= ∅it would follow that
Z ∩B ̸= ∅, negating EC(A, B).
It follows ﬁnally that
Proposition 5.53. In the model ROM, T ingrC(A, B) if and only if A ⊆
B and ClA ∩(ClB \ B) ̸= ∅. From this analysis we obtain also that
NT ingrC(A, B) if and only if ClA ⊆B.
Further properties of the predicate NT ingrC are collected in
Proposition 5.54. (Clarke [12]) Properties of NT ingrC are

5.7 Classes in Connection Mereology
215
1. NT ingrC(y, x) ∧C(z, y) ⇒C(z, x);
2. NT ingrC(y, x) ∧OvC(z, y) ⇒OvC(z, x);
3. NT ingrC(y, x) ∧C(z, y) ⇒OvC(z, x);
4. ingrC(y, x) ∧NT ingrC(x, z) ⇒NT ingrC(y, z);
5. ingrC(y, z) ∧NT ingrC(x, y) ⇒NT ingrC(x, z);
6. NT ingrC(y, z) ∧NT ingrC(z, x) ⇒NT ingrC(y, x).
Proof. For Property 3, from already known ∀z.¬EC(z, y) ∨¬EC(z, x), it
follows
(i) ∀w.¬C(w, x) ∨OvC(w, x) ∨¬C(w, y) ∨OvC(w, y)
As C(z, y), one obtains C(z, x). Thus, by (i), OvC(z, y) ∨OvC(z, x) and
OvC(z, x).
ForProperty4,assumingthatingrC(y, x), ingrC(x, z)andhence,ingrC(y, z)
(else, there is nothing to prove), consider ¬NT ingrC(y, z), i.e., for some w:
EC(w, z), EC(w, y). Thus, C(w, z), ¬OvC(w, z), C(w, y), ¬OvC(w, y).
Then, C(w, x) and ¬OvC(w, x), hence, EC(w, x) and ¬NT ingrC(x, z), a
contradiction. Similarly, one justiﬁes Properties P5 and P6
⊓⊔
5.7
Classes in Connection Mereology
Deﬁnition of a class ClsΦ of a non–vacuous property Φ, is given in Clarke’s
version of connection mereology in terms of the primitive notion of the pred-
icate C to satisfy the desired property
C(z, ClsCΦ) ⇔∃x.Φ(x) ∧C(z, x)
(5.31)
The existence of a class is secured by an axiom
CN4 For each non–vacuous property Φ of objects, there exists an object
ClsCΦ (a C–class of
Φ) which satisﬁes (5.31)
Proposition 5.55. (Clarke [12])
1. By CN3 and CN4, there is a unique object ClsCΦ for each non–vacuous
property Φ;
2. If Φ(z), then ingrC(z, ClsCΦ);

216
5 Mereology
3. ingrC(z, ClsCΦ) ⇒∃w.Φ(w) ∧C(z, w);
4. C(z, ClsΦ) ∧¬∃w.EC(z, w) ⇒∃w.Φ(w) ∧OvC(z, w);
Properties 3, 4 witness that
5. In the model OV M, the class deﬁned in connection mereology by ClsC
satisﬁes Le’sniewski’s postulates for a class;
6. OvC(z, ClsCΦ) ⇒∃w.Φ(w) ∧C(z, w);
Indeed, OvC(z, ClsCΦ) implies ∃t.[ingrC(t, z) ∧ingrC(t, ClsCΦ)], hence,
∃w.[Φ(w) ∧C(t, w)]. Thus, C(z, w).
7. ¬existsw.EC(z, w) ⇒[OvC(z, ClsCΦ) ⇒∃t.Φ(t) ∧OvC(z, t)];
8. ∃w.Φ(w) ∧C(z, w) ⇒OvC(z, ClsCΦ).
As with the Le´sniewski notion of a class, connection based classes have
properties
9. If Φ ⇒Ψ, then ingrC(ClsCΦ, ClsCΨ);
10. If Φ ⇔Ψ, then ClsCΦ = ClsCΨ;
11. x=ClsC INGR(x).
5.8
C–Quasi–Boolean Algebra
By Tarski [62], [61], as with the Le´sniewski mereology, in connection mereol-
ogy a quasi–Boolean algebra arises. By Postulate CN4, there exists for each
pair x, y of objects, an object denoted x+y deﬁned as the class of the property
+(x, y),
+ (x, y)(t) ⇔ingrC(t, x) ∨ingrC(t, y)
(5.32)
Then,
Cls + x + y = Cls + (x, y)
(5.33)
Proposition 5.56. (Clarke [12]) The operation + has properties
1. ingrC(x, x + y) by 9, Proposition 5.55;
2. C(z, x + y) ⇔∃w.[(ingrC(w, x) ∨ingrC(w, y)] ∧C(z, w) by ClsC;

5.8 C–Quasi–Boolean Algebra
217
3. C(z, x + y) ⇔C(z, x) ∨C(z, y) by Property 2;
From Property 10 of Proposition 5.55, we obtain
4. x + y = y + x;
5. x + (y + z) = (x + y) + z;
6. x + x = x.
The dual property is deﬁned as
× (x, y)(t) ⇔ingrC(t, x) ∧ingrC(t, y)
(5.34)
Clearly, the deﬁnition (5.34) makes sense only if OvC(x, y); in the sequel, we
will tacitly assume this condition any time the following operation x · y is
mentioned.
The Boolean product x · y is deﬁned as
Cls × x · y = Cls × (x, y)
(5.35)
It follows immediately by (5.35)
Proposition 5.57. (Clarke [12]) The following are properties of the Boolean
product
1. C(z, x · y) ⇔∃w.[(ingrC(w, x) ∧ingrC(w, y)] ∧C(z, w);
2. C(z, x · y) ⇒C(z, x) ∧C(z, y) by Property 1;
3. ingrC(x · y, x); ingrC(x · y, y) by Property 2;
4. ingrC(z, x · y) ⇔ingrC(z, x) ∧ingrC(z, y) by Property 2 and Proposition
5.55;
By Property 10 of Proposition 5.55, the following are true
5. x · y = y · x;
6. x · (y · z) = (x · y) · z;
7. x · (y + z) = x · y + x · z.
The universe V is deﬁned as the class of the property Con
Con(x) ⇔C(x, x)
(5.36)

218
5 Mereology
V = ClsCon
(5.37)
By (5.37)
Proposition 5.58. For each object z, one has ingrC(z, V ).
The complement −x is deﬁned as the class of property
N(x)(t) ⇔¬C(t, x)
(5.38)
by means of
−x = ClsN(x)
(5.39)
Then, by Property 10 of Proposition 5.55
Proposition 5.59. (Clarke [12]) The properties of complement are
1. −(−x) = x;
2. C(z, −x) ⇔∃w.¬C(x, w) ∧C(z, w);
3. C(z, −x) ⇔¬ingrC(z, x) by Property 2;
4. ingrC(x, y) ⇔ingrC(−y, −x);
Complement
operator
−
ﬂip–ﬂops
between
boolean
addition
and
multiplication
5. −(x · y) = (−x) + (−y);
6. (−x) · (−y) = −(x + y)
7. ¬EC(x, −y) ⇒[−x + y = V ⇔ingrC(x, y)].
Proof. As Property 5 obtains from Property 4 by means of Property 1, it
suﬃces to prove Property 4. We have C(t, −x · y) ⇔¬ingrC(t, x · y) by 3,
and by Property 3 of Proposition 5.57,
¬ingrC(t, x · y) ⇔¬ingrC(t, x) ∨¬ingrC(t, y)
which by the Property 3 is equivalent to C(t, −x) ∨C(t, −y) and it is by
Property 3 of Proposition 5.56, equivalent to C(t, (−x) + (−y)). By CN3,
−(x · y) = (−x) + (−y).
For Property 6, premise ¬EC(x, −y) is equivalent to ¬C(x, −y) ∨OvC(x,
−y) and in turn, by Property 3, to ingrC(x, y)∨OvC(x, −y). The implication
ingrC(x, y) ⇒−x + y = V being obvious, we may observe that conditions
−x+y = V and OvC(x, −y) are contradictory: hence, the premise −x+y = V
implies ingrC(x, y)
⊓⊔
In particular, in any model OV M, −x + y = V ⇔ingrC(x, y).

5.9 C–Mereotopology
219
5.9
C–Mereotopology
Topological operators are constructed in connection mereology under same
caveat as quasi–Boolean operators: absence of the null object causes to make
reservations concerning existence of some objects necessary for topological
constructions. We will make this reservations not trying to add new axioms
which would guarantee existence of some auxiliary objects.
The C–interior IntC(x) of an object x is deﬁned as the class of non–
tangential ingredients of x.
We deﬁne the property NT P(x)
NT P(x)(z) ⇔NT P(z, x)
(5.40)
The interior IntC(x) is deﬁned by means of
INTC IntC(x) = ClsNT P(x)
(5.41)
hence, properties follow
Proposition 5.60. (Clarke [12]) properties of the operator IntC are
1. C(z, IntC(x)) ⇔∃w.NT ingrC(w, x) ∧C(z, w) by the class deﬁnition;
2. ¬∃z.EC(z, x) ⇒(IntC(x) = x). In particular, in the model OV M,
IntC(x) = x for each object x;
3. ingrC(IntC(x), x) as C(z, IntC(x)) ⇒C(z, x);
4. C(z, IntC(x)) ⇒OvC(z, x);
5. EC(z, x) ⇒¬C(z, IntC(x));
6. ingrC(z, IntC(x)) ⇔NT ingrC(z, x);
7. ingrC(z, x) ⇒ingrC(IntC(z), IntC(x));
8. IntC(x) = x ⇔C(z, x) ⇒OvC(z, x);
9. IntC(x) = x ⇔NT ingrC(x, x).
An open object is x such that IntC(x) = x.
Under additional axiomatic postulate that the boolean product of any two
open sets is open, see Clarke [12], A2.1, one can prove that IntC(x · y) =
IntC(x) · IntC(y).
The notion of a topological closure ClC(x) of x, can be introduced by
means of the standard duality

220
5 Mereology
ClC ClC(x) = −int(−x)
(5.42)
By properties of the interior and by duality (5.42), one obtains dual properties
of closure
Proposition 5.61. (Clarke [12]) Properties of the operator ClC are
1. ingrC(x, ClC(x));
2. ClC(ClC(x)) = ClC(x);
3. ingrC(x, y) ⇒ingrC(ClC(x), ClC(y));
4. IntC(x · y) = IntC(x) · IntC(y) ⇔ClC(x + y) = ClC(x) + ClC(y);
5. C(z, ClC(x)) ⇔∃w.NT ingrC(w, −x) ∧C(z, w).
The notion of a boundary can be introduced along standard topological lines
BdC BdC(x) = −(int(x) + int(−x))
(5.43)
We collect basic properties of the boundary in
Proposition 5.62. The operator BdC has properties
1. Under Property 4 of Proposition 5.61, BdC(x) = ClC(x) · −IntC(x), i.e.,
it can be expressed as the diﬀerence between the closure and the interior
of the object;
2. Bd(x) = Bd(−x) by Property 1 of Proposition 5.59;
3. ingrC(BdC(x), ClC(x)).
We now include a section on applications of reasoning schemes based on
mereology in spatial reasoning.
5.10
Spatial Reasoning: Mereological Calculi
Spatial reasoning belongs to the oldest known to humankind forms of reason-
ing: the space around man and orientation in it were doubtless the earliest
experiences they had had. The strict relations among various objects, e.g.,
segments of various length, especially those forming ﬁgures in the plane were
among the ﬁrst scientiﬁc observations of man: for many historians of civi-
lization, see Bronowski [9], the Pythagorean Theorem is the most important
mathematical fact known to man and one can argue plausibly the same about

5.10 Spatial Reasoning: Mereological Calculi
221
the Tales Theorem most probably known to Imhotep, and other pyramid
builders, see Shaw [51].
It comes thus as no surprise that axiomatic system of geometry due to
Euclid, see Joyce [31], is one of the two earliest formal systems besides the
Syllogistic of Aristotle, see Ch. 1. Formal questions posed by the Euclidean
system, like the famous Vth Postulate have led to many fundamental dis-
coveries like non–Euclidean geometries. In XX century, axiomatization of
geometry was pursued among others by Tarski [63].
With Riemann, geometry entered the realm of abstract spaces and work
of Cantor alongside early anticipations by Riemann brought forth topology –
a theory of invariants of continuous mappings, cf., Ch. 2. Topology created a
more ﬂexible and adaptable to various contexts reasoning framework which
have grown to a many–faceted theory permeating the whole of mathemati-
cal insight into reality, mostly due to the universal and simple notion of a
neighborhood.
Formal discussion of topology have been carried out within the framework
of set theory, initiated by Cantor, whose elementary notion is the relation of
being an element, in symbols, ∈.
The philosophical assumption concerning the nature of a set was therefore
that sets are built of elements and identical sets possess of the same ele-
ments. This assumption brought forth some paradoxes like the well–known
Russell paradox whether there exists a set of all sets. The emergence of para-
doxes demonstrated the diﬃculty with the notion of a set; mathematicians
and philosophers of the turn of XX century found seemingly the way out of
diﬃculty by imposing on the notion of a set some strict requirements which
allowed the existence of some sets and prohibited the construction of some
too abstract sets, see Kanamori [32]. Yet, some questions have turned out
to be very diﬃcult to answer and even undecidable, so currently there exist
many models of set theory to choose from, cf., Kanamori, op. cit.
Qualitative Spatial Reasoning developed from the above mentioned ideas
of Le´sniewski and Whitehead and it has become a basic ingredient in a variety
of problems, e.g., in mobile robotics, see, e.g., Kuipers [34], Kuipers and Byun
[35], Kuipers and Levitt [36]. Spatial reasoning which deals with objects like
solids, regions etc., by necessity refers to and relies on mereological theories
of concepts based on the opposition part–whole, see Gotts et al. [27].
For expressing relations among entities, mathematics proposes two basic
languages: the language of set theory, based on the opposition element–set,
where distributive classes of entities are considered as sets consisting of (dis-
crete) atomic entities, and languages of mereology, for discussing entities
continuous in their nature, based on the opposition part–whole. Due to con-
tinuous nature of spatial real objects, Spatial Reasoning relies to great extent
on mereological theories of part, cf., Asher and Vieu [5], Asher et al. [4], Au-
rnague and Vieu [6], Cohn and Gotts [15], Gotts and Cohn [26], Cohn et al.
[16], Galton [24], Smith [57], [56], Masolo and Vieu [47].

222
5 Mereology
Qualitative Reasoning aims at studying concepts and calculi on them that
arise often at early stages of problem analysis when one is refraining from
qualitative or metric details, cf., Cohn [14]; as such it has close relations with
design, cf., Booch [8] as well as planning stages, cf., Glasgow [25] of the model
synthesis process.
Classical formal approaches to spatial reasoning, i.e., to representing spa-
tial entities (points, surfaces, solids) and their features (dimensionality, shape,
connectedness degree) rely on Geometry or Topology, i.e., on formal theories
whose models are spaces (universes) constructed as sets of points; contrary
to this approach, qualitative reasoning about space often exploits pieces of
space (regions, boundaries, walls, membranes) and argues in terms of re-
lations abstracted from a commonsense perception (like connected, discrete
from, adjacent, intersecting). In this approach, points appear as ideal objects,
e.g., ultraﬁlters of regions/solids as in Tarski [60].
Qualitative Spatial Reasoning has a wide variety of applications, among
them, to mention only a few, representation of knowledge, cognitive maps
and navigation tasks in robotics, see Kuipers, Kuipers and Byun, Kuipers
and Levitt op. cit., op. cit., op. cit., as well as AISB97 [1], Arkin [3], Dorigo
and Colombetti [18], Kortenkamp [33], Freksa [23], Geographical Information
Systems and spatial databases including Naive Geography, see Frank and
Campari [21], Frank and Kuhn [22], Hirtle and Frank [29], Egenhofer and
Golledge [20], Mark [46], and in studies in semantics of orientational lexemes
and in semantics of movement in Asher et al. [4] and Aurnague and Vieu [6].
Spatial Reasoning establishes a link between Computer Science and Cog-
nitive Sciences, cf., Freksa [23] and it has close and deep relationships with
philosophical and logical theories of space and time, cf., Reichenbach [50] ,
vanBenthem [7], Allen [2].
Any formal approach to Spatial Reasoning requires Ontology, which dif-
fers from the above exposed Ontology due to Le´sniewski, and is based on
established hierarchies of concepts, cf., Guarino [28], Smith [55], Casati et al.
[11]. In reasoning with spatial objects, of primary importance is to develop an
ontology of spatial objects, taking into account complexity of these objects.
The scheme for Connection calculus, presented above, sect. 5, has inspired
many authors toward creation of a calculus on speciﬁed geometric objects
which would implement connection predicate, although in a modiﬁed ac-
cording to a given context form. A good example of such approach is the
calculus of regions RCC (Region Connection Calculus), see Randell et al.
[49]. Primitive geometric objects considered here are regions; this standpoint
distinguishes RCC from the original setting by Clarke in [12] where points
were primitives and connection C was interpreted as having a point in com-
mon. In RCC authors tend to interpret connection as the property of having
a common point in closures of regions. Thus, RCC is essentially a calculus
of regularly open regions, i.e., regions R such that R = IntClR: each region
is the interior of its closure, see sect. 5. Hence, the framework adopted by
authors of RCC is that of the model ROM.

5.10 Spatial Reasoning: Mereological Calculi
223
5.10.1
On Region Connection Calculus
RCC adopts requirements CN1–CN3 of Connection calculus in Clarke [12],
and deﬁnes other predicates in a similar way; we recall them here preserving
the notation of RCC.
DISCONNECTED FROM(x)(y): DC(x, y) if and only if not C(x, y)
IMPROPER PART OF(x)(y): P(x, y) if and only if for each z, C(z, y) →
C(z, x) (y is an improper part of x)
PROPER PART OF(x)(y): PP(x, y) if and only if P(x, y) and not P(y, x)
(y is a proper part of x)
EQUAL(x)(y): EQ(x, y) if and only if P(x, y) andP(y, x) (y is identi-
cal to x)
OVERLAP(x)(y): Ov(x, y) if and only if there exists z such that P(x, z)
and P(y, z) (y overlaps x)
DISCRETE FROM(x)(y): DR(x, y) if and only if not Ov(x, y) (y is dis-
crete from x)
PARTIAL OVERLAP(x)(y): POv(x, y) if and only if Ov(x, y) and not
P(x, y), and not P(y, x) (y partially overlaps x)
EXTERNAL CONNECTED(x)(y): EC(x, y) if and only if C(x, y) and
not Ov(x, y) (y is externally connected to x)
TANGENTIAL PART OF(x)(y): T PP(x, y) if and only if PP(x, y) and
there exists z such that EC(x, z) and EC(y, z) (y is a tangential proper part
of x)
NON–TANGENTIAL PART OF(x)(y): NT PP(x, y) if and only if
PP(x, y) and not T PP(x, y) (y is a non–tangential proper part of x)
Each non–symmetric predicate X among the above is also accompanied by
its inverse Xi (e.g., T PP(x, y) by T PPi(y, x)).
Of these predicates, the eight: DC, EC, PO, EQ, TPP, NTPP, TPPi,
NTPPi are shown to have the JEPD property (Jointly Exclusive and Pairwise
Disjoint) and they form the fragment of RCC called the RCC8 calculus.
Due to topological assumptions, RCC has some stronger properties than
Clarke’s calculus of C. Witness, the two properties, not mentioned by us when
discussing the model ROM.

224
5 Mereology
The ﬁrst is the extensionality of the Overlap predicate
If for each z Ov(x, z) ↔Ov(y, z), then x = y
Indeed, for regular open sets A, B, the condition that Ov(x, z) ⇔Ov(y, z)
means that ClA = ClB, hence, A = IntClA = IntClB = B.
The second property concerns complementarity
If PP(A, B), then there exists C such that P(C, B) and DR(C, A)
Indeed, was B ⊆ClA, we would have ClB = ClA, a fortiori, B = A, contrary
to the assumptions. Hence, B \ ClA ̸= ∅, and there exists, by regularity of
X, a C ∈RO(X) such that ClC ⊆B \ ClA ̸= ∅.
One more consequence of topological assumptions is that the region and its
complement are externally connected, as their closures do intersect,
EC(x, −x) for each region x
For practical reasons, RCC8 is presented in the form of the transition table:
a table in which for entries R1(x, y) and R2(y, z) a result R3(x, z) is given,
see Egenhofer [19]. The transition table for RCC8 is shown in the table of
Fig. 5.1.
-
DC
EC
PO
TPP
NTPP
TPPi
NTPPi
DC
-
DR,PO,PP
DR,PO,PP DR,PO,PP
DC
DC
EC
DR,PO,PPi DR,PO,TPP,TPi DR,PO,P
EC,PO,PP PO,PP
DR
DC
PO
DR,PO,PPi
DR,PO,PPi
-
PO,PP
PO,P DR,PO,PPi DR,PO,PPi
TPP
DC
DR
DR,PO,PP
PP
NTPP DR,PO,PP
-
NTPP
DC
DC
DR,O,PP
NTPP
NTPP DR,PO,PP
-
TPPi DR,PO,PPi
EC,PO,PPi
PO,PPi
PO,TPP,TPi PO,PP
PPi
NTPPi
NTPPi DR,PO,PPi
PO,PPi
PO,PPi
PO, PPi
0
NTPPi
NTPPi
Fig. 5.1 Transition table for RCC8 calculus
RCC8 allows for additional predicates characterizing shape, connectivity,
see Gotts et al. [27] and regions with vague boundaries (”the egg–yolk” ap-
proach), see Cohn and Gotts [15].

References
1. AISB–1997: Spatial Reasoning in Mobile Robots and Animals. In: Proceedings
AISB 1997 Workshop. Manchester Univ., Manchester, UK (1997)
2. Allen, J.: Towards a general theory of action and time. Artiﬁcial Intelli-
gence 23(20), 123–154 (1984)
3. Arkin, R.C.: Behavior-Based Robotics. MIT Press, Cambridge (1998)
4. Asher, N., Aurnague, M., Bras, M., Sablayrolles, P., Vieu, L.: De l’espace-
temps dans l’analyse du discours. Rapport interne IRIT/95-08-R. Institut de
Recherche en Informatique, Univ. Paul Sabatier, Toulouse (1995)
5. Asher, N., Vieu, L.: Toward a geometry of commonsense: a semantics and
a complete axiomatization of mereotopology. In: Proceedings IJCAI 1995,
pp. 846–852. Morgan Kauﬀman, San Mateo (1995)
6. Aurnague, M., Vieu, L.: A theory of space-time for natural language semantics.
In: Korta, K., Larraz´abal, J.M. (eds.) Semantics and Pragmatics of Natural
Language: Logical and Computational Aspects. ILCLI Series I, pp. 69–126.
Univ. Pais Vasco, San Sebastian (1995)
7. Van Benthem, J.: The Logic of Time. D. Reidel, Dordrecht (1983)
8. Booch, G.: Object–Oriented Analysis and Design with Applications. Addison–
Wesley Publ., Menlo Park (1994)
9. Bronowski, J.: The Ascent of Man. BBC Paperbacks, BBC (1976)
10. Casati, R., Varzi, A.C.: Parts and Places. The Structures of Spatial Represen-
tations. MIT Press, Cambridge (1999)
11. Casati, R., Smith, B., Varzi, A.C.: Ontological tools for geographic representa-
tion. In: Guarino, N. (ed.) Formal Ontology in Information Systems, pp. 77–85.
IOS Press, Amsterdam (1998)
12. Clarke, B.L.: A calculus of individuals based on connection. Notre Dame Jour-
nal of Formal Logic 22(2), 204–218 (1981)
13. Clay, R.: Relation of Le´sniewski’s Mereology to Boolean Algebra. The Journal
of Symbolic Logic 39, 638–648 (1974)
14. Cohn, A.G.: Calculi for qualitative spatial reasoning. In: Pfalzgraf, J., Calmet,
J., Campbell, J. (eds.) AISMC 1996. LNCS, vol. 1138, pp. 124–143. Springer,
Heidelberg (1996)
15. Cohn, A.G., Gotts, N.M.: Representing spatial vagueness: a mereological
approach. In: Proceedings of the 5th International Conference KR 1996,
pp. 230–241. Morgan Kaufmann, San Francisco (1996)
16. Cohn, A.G., Randell, D., Cui, Z., Bennett, B.: Qualitative spatial reasoning
and representation. In: Carrete, N., Singh, M. (eds.) Qualitative Reasoning
and Decision Technologies, Barcelona, pp. 513–522 (1993)

226
References
17. Cohn, A.G., Varzi, A.C.: Connections relations in mereotopology. In: Prade, H.
(ed.) Proceedings of 13th European Conference on Artiﬁcial Intelligence, ECAI
1998, pp. 150–154. Wiley and Sons, Chichester (1998)
18. Dorigo, M., Colombetti, M.: Robot Shaping. An Experiment in Behavior En-
gineering. MIT Press, Cambridge (1998)
19. Egenhofer, M.J.: Reasoning about binary topological relations. In: G¨unther, O.,
Schek, H.-J. (eds.) SSD 1991. LNCS, vol. 525, pp. 143–160. Springer, Heidelberg
(1991)
20. Egenhofer, M.J., Golledge, R.G. (eds.): Spatial and Temporal Reasoning in
Geographic Information Systems. Oxford University Press, Oxford (1997)
21. Campari, I., Frank, A.U. (eds.):Spatial Information Theory: A Theoretical Ba-
sis for GIS. LNCS, vol. 716. Springer, Heidelberg (1993)
22. Kuhn, W., Frank, A.U. (eds.): Spatial Information Theory: A Theoretical Basis
for GIS. LNCS, vol. 988. Springer, Heidelberg (1995)
23. Freksa, C., Habel, C.: Repraesentation und Verarbeitung raeumlichen Wissens.
Informatik-Fachberichte. Springer, Berlin (1990)
24. Galton, A.: The mereotopology of discrete space. In: Freksa, C., Mark, D.M.
(eds.) COSIT 1999. LNCS, vol. 1661, pp. 251–266. Springer, Heidelberg (1999)
25. Glasgow, J.: A formalism for model–based spatial planning. In: Kuhn, W.,
Frank, A.U. (eds.) COSIT 1995. LNCS, vol. 988, Springer, Heidelberg (1995)
26. Gotts, N.M., Cohn, A.G.: A mereological approach to representing spatial
vagueness. In: Working papers. The Ninth International Workshop on Qual-
itative Reasoning, QR 1995 (1995)
27. Gotts, N.M., Gooday, J.M., Cohn, A.G.: A connection based approach to
commonsense topological description and reasoning. The Monist 79(1), 51–75
(1996)
28. Guarino, N.: The ontological level. In: Casati, R., Smith, B., White, G.
(eds.) Philosophy and the Cognitive Sciences. Hoelder–Pichler–Tempsky, Vi-
enna (1994)
29. Frank, A.U. (ed.): Spatial Information Theory A Theoretical Basis for GIS.
LNCS, vol. 1329. Springer, Heidelberg (1997)
30. Iwanu´s, B.: On Le´sniewski’s elementary Ontology. Studia Logica XXXI,
pp. 73–119 (1973)
31. Joyce D.: Euclid: Elements (1998),
http://aleph0.clarku.edu/~djoyce/java/elements/elements.html
(last entered 01. 04. 2011)
32. Kanamori, A.: The Mathematical Development of Set Theory from Cantor to
Cohen. The Bulletin of Symbolic Logic 2(1), 1–71 (1996)
33. Kortenkamp, D., Bonasso, R.P., Murphy, R. (eds.): Artiﬁcial Intelligence and
Mobile Robots. AAAI Press/MIT Press, Menlo Park, CA (1998)
34. Kuipers, B.J.: Qualitative Reasoning: Modeling and Simulation with Incom-
plete Knowledge. MIT Press, Cambridge (1994)
35. Kuipers, B.J., Byun, Y.T.: A qualitative approach to robot exploration and
map learning. In: Proceedings of the IEEE Workshop on Spatial Reasoning
and Multi-Sensor Fusion, pp. 390–404. Morgan Kaufmann, San Mateo (1987)
36. Kuipers, B.J., Levitt, T.: Navigation and mapping in large-scale space. AI
Magazine 9(20), 25–43 (1988)
37. de Laguna, T.: Point, line and surface as sets of solids. The Journal of Philos-
ophy 19, 449–461 (1922)

References
227
38. Lejewski, C.: A contribution to Le´sniewski’s mereology. Yearbook for 1954–1955
of the Polish Society of Arts and Sciences Abroad V, pp. 43–50 (1954–1955)
39. Lejewski, C.: On Le´sniewski’s Ontology. Ratio I (2), 150–176 (1958)
40. Leonard, H., Goodman, N.: The calculus of individuals and its uses. The Jour-
nal of Symbolic Logic 5, 45–55 (1940)
41. Le´sniewski, S.: Podstawy Og´olnej Teoryi Mnogo´sci, I (Foundations of General
Set Theory, I, in Polish). Prace Polskiego Kola Naukowego w Moskwie, Sekcya
Matematyczno–przyrodnicza, No. 2, Moscow (1916)
42. Le´sniewski, S.: O podstawach matematyki (On foundations of mathematics,
in Polish). (1927) Przegl¸ad Filozoﬁczny XXX, pp 164–206; (1928) Przegl¸ad
Filozoﬁczny XXXI, pp 261–291; (1929) Przegl¸ad Filozoﬁczny XXXII, pp 60–
101; (1930) Przegl¸ad Filozoﬁczny XXXIII, pp 77–105 (1930); (1931) Przegl¸ad
Filozoﬁczny XXXIV, pp 142–170 (1927–1931)
43. Le´sniewski, S.: ¨Uber die Grundlagen der Ontologie. C.R. Soc. Sci. Lettr. Varso-
vie Cl. III, 23 Anne´e, pp. 111–132 (1930)
44. Le´sniewski, S.: On the foundations of mathematics. Topoi 2, 7–52 (1982)
45. Le´sniewski, S., Srzednicki, J., Surma, S.J., Barnett, D., Rickey, V.F. (eds.):
Collected Works of Stanisl aw Le´sniewski. Kluwer, Dordrecht (1992)
46. Mark, D.M. (ed.): Spatial Information Theory. In: Freksa, C., Mark, D.M. (eds.)
COSIT 1999. LNCS, vol. 1661, pp. 205–220. Springer, Heidelberg (1999)
47. Masolo, C., Vieu, L.: Atomicity vs. Inﬁnite divisibility of space. In: Freksa,
C., Mark, D.M. (eds.) COSIT 1999. LNCS, vol. 1661, pp. 235–250. Springer,
Heidelberg (1999)
48. Plutarch: The E at Delphi. In: Moralia (ed.), vol. 5, Harvard University Press,
Cambridge (1936)
49. Randell, D., Cui, Z., Cohn, A.G.: A spatial logic based on regions and con-
nection. In: Proceedings of the 3rd International Conference on Principles of
Knowledge Representation and Reasoning KR 1992, pp. 165–176. Morgan Kauf-
mann, San Mateo (1992)
50. Reichenbach, H.: The Philosophy of Space and Time repr. Dover, New York
(1957)
51. Shaw, I.: The Oxford History of Ancient Egypt. Oxford U. Press, Oxford (2000)
52. Simons, P.: Free part–whole theory. In: Lambert, K. (ed.) Philosophical Appli-
cations of Free Logic, pp. 285–306. Oxford University Press, Oxford (1991)
53. Simons, P.: Parts. A Study in Ontology. Clarendon Press, Oxford (2003)
54. Slupecki J, S. Le´sniewski’s calculus of names. Studia Logica III, pp. 7–72 (1955)
55. Smith, B.: Logic and formal ontology. In: Mohanty, J.N., McKenna, W. (eds.)
Husserl’s Phenomenology: A Textbook, pp. 29–67. University Press of America,
Lanham (1989)
56. Smith, B.: Boundaries: an essay in mereotopology. In: Hahn, L. (ed.) The Phi-
losophy of Roderick Chisholm, pp. 534–561. Library of Living Philosophers. La
Salle: Open Court (1997)
57. Smith, B.: Agglomerations. In: Freksa, C., Mark, D.M. (eds.) COSIT 1999.
LNCS, vol. 1661, pp. 267–282. Springer, Heidelberg (1999)
58. Soboci´nski, B.: L’analyse de l’antinomie Russellienne par Le´sniewski. Methodos
I, II, 94–107, 220–228, 308–316,237–257 (1949–1950)
59. Soboci´nski, B.: Studies in Le´sniewski’s Mereology. Yearbook for 1954-1955 of
the Polish Society of Art and Sciences Abroad V, pp. 34–43 (1954–1955)
60. Tarski, A.: Les fondements de la g´eom´etrie des corps. Supplement to Annales
de la Soci´et´e Polonaise de Math´ematique 7, 29–33 (1929)

228
References
61. Tarski, A.: Zur Grundlegung der Booleschen Algebra. I. Fundamenta Mathe-
maticae 24, 177–198 (1935)
62. Tarski, A.: Appendix E. In: Woodger, J.H. (ed.) The Axiomatic Method in
Biology, p. 160. Cambridge University Press, Cambridge (1937)
63. Tarski, A.: What is elementary geometry? In: Henkin, L., Suppes, P., Tarski, A.
(eds.) The Axiomatic Method with Special Reference to Geometry and Physics.
Studies in Logic and Foundations of Mathematics, pp. 16–29. North-Holland,
Amsterdam (1959)
64. Whitehead, A.N.: La th´eorie relationniste de l’espace. Revue de M´etaphysique
et de Morale 23, 423–454 (1916)
65. Whitehead, A.N.: An Enquiry Concerning the Principles of Human Knowledge.
Cambridge University Press, Cambridge (1919)
66. Whitehead, A.N.: The Concept of Nature. Cambridge University Press,
Cambridge (1920)
67. Whitehead, A.N.: Process and Reality: An Essay in Cosmology. Macmillan,
New York (1929)
68. Woodger, J.H.: The Axiomatic Method in Biology. Cambridge University Press,
Cambridge (1937)
69. Woodger, J.H.: The Technique of Theory Construction. In: International En-
cyclopedia of Uniﬁed Science, vol. II, 5, pp III+81. Chicago University Press,
Chicago (1939)

Chapter 6
Rough Mereology
A scheme of mereology, introduced into a collection of objects, see Ch. 5, sets
an exact hierarchy of objects of which some are (exact) parts of others; to as-
certain whether an object is an exact part of some other object is in practical
cases often diﬃcult if possible at all, e.g., a robot sensing the environment by
means of a camera or a laser range sensor, cannot exactly perceive obstacles
or navigation beacons. Such evaluation can be done approximately only and
one can discuss such situations up to a degree of certainty only. Thus, one
departs from the exact reasoning scheme given by decomposition into parts
to a scheme which approximates the exact scheme but does not observe it
exactly.
Such a scheme, albeit its conclusions are expressed in an approximate lan-
guage, can be more reliable, as its users are aware of uncertainty of its state-
ments and can take appropriate measures to fend oﬀpossible consequences.
Imagine two robots using the language of connection mereology for describ-
ing mutual relations; when endowed with touch sensors, they can ascertain
the moment when they are connected; when a robot has as a goal to enter
a certain area, it can ascertain that it connected to the area or overlapped
with it, or it is a part of the area, and it has no means to describe its position
more precisely.
Introducing some measures of overlapping, in other words, the extent to
which one object is a part to the other, would allow for a more precise de-
scription of relative position, and would add an expressional power to the
language of mereology. Rough mereology answers these demands by intro-
ducing the notion of a part to a degree with the degree expressed as a real
number in the interval [0, 1]. Any notion of a part by necessity relates to
the general idea of containment, and thus the notion of a part to a degree is
related to the idea of partial containment and it should preserve the essential
intuitive postulates about the latter.
The predicate of a part to a degree stems ideologically from and has as one
of motivations the predicate of an element to a degree introduced by L. A.
Zadeh as a basis for fuzzy set theory [24]; in this sense, rough mereology is to
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 229–257.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

230
6 Rough Mereology
mereology as the fuzzy set theory is to the naive set theory. To the rough set
theory, owes rough mereology the interest in concepts as objects of analysis.
The primitive notion of rough mereology is the notion of a rough inclusion
which is a ternary predicate μ(x, y, r) where x, y are objects and r ∈[0, 1],
read ‘the object x is a part to degree at least of r to the object y’. Any rough
inclusion is associated with a mereological scheme based on the notion of a
part by postulating that μ(x, y, 1) is equivalent to ingr(x, y), where the in-
gredient relation is deﬁned by the adopted mereological scheme, see Ch. 5,
sect. 1. Other postulates about rough inclusions stem from intuitions about
the nature of partial containment; these intuitions can be manifold, a for-
tiori, postulates about rough inclusions may vary. In our scheme for rough
mereology, we begin with some basic postulates which would provide a most
general framework. When needed, other postulates, narrowing the variety of
possible models, can be introduced.
6.1
Rough Inclusions
We have already stated that a rough inclusion is a ternary predicate μ(x, y, r).
We assume that a collection of objects is given, on which a part relation
π is introduced with the associated ingredient relation ingr. We thus ap-
ply inference schemes of mereology due to Le´sniewski, presented in Ch. 5,
sect. 1.
Predicates μ(x, y, r) were introduced in Polkowski and Skowron [18], [19];
they satisfy the following postulates, relative to a given part relation π and
the induced by π relation ingr of an ingredient, on a set U of entities
RINC1 μ(x, y, 1) ⇔ingr(x, y)
This postulate asserts that parts to degree of 1 are ingredients.
RINC2 μ(x, y, 1) ⇒∀z[μ(z, x, r) ⇒μ(z, y, r)]
This postulate does express a feature of partial containment that a ‘big-
ger’ object contains a given object ‘more’ than a ‘smaller’ object. It can be
called a monotonicity condition for rough inclusions.
RINC3 μ(x, y, r) ∧s < r ⇒μ(x, y, s)
This postulate speciﬁes the meaning of the phrase ‘a part to a degree at
least of r’.
From postulates RINC1–RINC3, and known properties of the ingredient
predicate, see Ch. 5, sect. 1, some consequences follow.

6.2 Rough Inclusions: Residual Models
231
Proposition 6.1. The immediate consequences of postulates RINC1–RINC3
are
1. μ(x, x, 1);
2. μ(x, y, 1) ∧μ(y, z, 1) ⇒μ(x, z, 1);
3. μ(x, y, 1) ∧μ(y, x, 1) ⇔x = y;
4. x ̸= y ⇒¬μ(x, y, 1) ∨¬μ(y, x, 1);
5. ∀z∀r[μ(z, x, r) ⇔μ(z, y, r)] ⇒x = y.
Proof. Property 1 follows by by RINC1 and Property 1 of Proposition 1, Ch.
5, Property 2 is implied by transitivity of ingredient, Property 2 of Proposi-
tion 1, Ch. 5, and RINC1. Property 3 follows by RINC1 and Property 3 of
Proposition 1, Ch. 5, Property 4 holds by Property 3 of Proposition 1, Ch.
5. Lastly, Property 5 is true by Property 3 of Proposition 1, Ch. 5
⊓⊔
Property 5 above may be regarded as an extensionality postulate in rough
mereology.
By a model for rough mereology, we mean a quadruple
M = (VM, πM, ingrM, μM)
where VM is a set with a part relation πM ⊆VM × VM, the associated
ingredient relation ingrM ⊆VM × VM, and a relation μM ⊆VM × VM × [0, 1]
which satisﬁes RINC1–RINC3.
We now describe some models for rough mereology which at the same
time give us methods by which we can deﬁne rough inclusions, see Polkowski
[10]–[15].
6.2
Rough Inclusions: Residual Models
We begin with continuous t–norms on the unit interval [0,1], see Ch. 4,
sect. 7.
We recall that it follows from results in Mostert and Shields [7] and Faucett
[2], see Ch. 4, sect. 9, cf., H´ajek [3], that the structure of a continuous t–
norm T depends on the set F(T ) of idempotents of T , i.e, values x such
that T (x, x) = x; we denote with OT the countable family of open intervals
Ai ⊆[0, 1] with the property that 
i Ai = [0, 1] \ F(T ).
Then, see Ch. 4, Proposition 18,
Proposition 6.2. T (x, y) is an isomorph to either L(x, y) or P(x, y) when
x, y ∈Ai for some i, and T (x, y) = min{x, y}, otherwise.

232
6 Rough Mereology
We recall, see Ch. 4, sect. 10, that, for a continuous t–norm T(x, y), the
residual implication, residuum, x ⇒T y is deﬁned by the condition
x ⇒T y ≥z ⇔T(x, z) ≤y
(6.1)
It follows that x ⇒T y = 1 if and only if x ≤y, as T(x, x) ≤x for each
continuous t–norm T.
For a continuous t–norm T, we deﬁne a relation μT ⊆[0, 1]3 by means of
RIT μT (x, y, r) ⇔x ⇒T y ≥r
(6.2)
Proposition 6.3. The quadruple M(T) = ([0, 1], <, ≤, μT) is a model for
rough mereology induced by the residuum of the t–norm T.
Proof. First, let us make positive that μT satisﬁes RINC1–RINC3. For
RINC1, μT (x, y, 1) means that x ⇒T y = 1, hence, x ≤y, i.e., ingrM(x, y).
For RINC2, assume that μT (x, y, 1) and μT(z, x, r), hence (i) x ≤y (ii) z ⇒T
x ≥r, i.e., by (1), (iii) T(z, r) ≤x. By (i), (iii), T(z, r) ≤y, hence, by (1),
z ⇒T y ≥r. RINC3 follows by (6.2)
⊓⊔
Clearly, the underlying part relation in the above proposition is the strict
ordering < and the ingredient relation is ≤.
In particular important cases, of t–norms L, P, M, one obtains the speciﬁc
models ML, MP, MM. In each model M(T ), μ(x, y, 1) ⇔x ≤y, hence, we
recall below only the case when x > y, see Ch. 4. sect. 10.
In case of the Lukasiewicz t–norm L, we have, x ⇒L y = min{1, 1−x+y};
accordingly,
μL(x, y, r) ⇔min{1, 1 −x + y} ≥r
(6.3)
equivalently for x > y
μL(x, y, r) ⇔x −y ≤1 −r
(6.4)
From (6.4), we can extract a transitivity rule
Proposition 6.4. From μL(x, y, r), μL(y, z, s) it follows that μL(x, z, L(r, s)).
Proof. It suﬃces to consider the case when x > y and y > z, by (6.4), we
have x −y ≤1 −r and y −z ≤1 −s, hence, x −z ≤1 −(r + s −1), i.e.,
μL(x, y, L(r, s))
⊓⊔
The proposition does encompass as well cases when x ≤y or y ≤z.
For the product t–norm P, if x > y then we have x ⇒P y = y
x; hence
μP (x, y, r) ⇔y
x ≥r
(6.5)
The transitivity rule follows.

6.2 Rough Inclusions: Residual Models
233
Proposition 6.5. μP (x, y, r), μP (y, z, s) imply μP (x, zP(r, s).
Proof. The conclusion follows by (6.5) from
y
x ≥r,
z
y ≥s, which imply
z
x ≥r · s. Cases when either x ≤y or y ≤z, or x ≤z are discussed
analogously
⊓⊔
Finally, we consider the minimum t–norm M with x ⇒P y = y, hence
μM(x, y, r) ⇔y ≥r
(6.6)
Proposition 6.6. If μM(x, y, r), μM(y, z, s), then μM(x, z, min{r, s}).
Proof. From μM(x, y, r), μM(y, z, s) it follows that min{x, r} ≤y, min{y, s}
≤z, hence, min{x, min{r, s}} ≤z, i.e., μM(x, z, M(r, s))
⊓⊔
The partial results in Propositions 6.3, 6.5, 6.6, can be generalized to,
Proposition 6.7. For each continuous t–norm T, the transitivity rule is
obeyed by the rough inclusion μT : if μT(x, y, r), μT (y, z, s), then μT (x, z,
T(r, s)).
Proof. μT(x, y, r) is equivalent to T(x, r) ≤y, and, μT (y, z, s) is equiva-
lent to T(y, s) ≤z. By coordinate–wise monotonicity of T, it follows that
T(T (x, r), s) ≤z, and, by associativity of T, one obtains T (x, T(r, s)) ≤z,
hence, μT (x, z) ≥T(r, s)
⊓⊔
Let us also put for the record the observation
Proposition 6.8. For each r, and every continuous t–norm T , the set
DT(r) = {(x, y) : μT(x, y, r)} is a closed subset of the unit square [0, 1]2;
sets DL(r),
DM(r) are moreover convex.
Proof. μ(x, y, r) is equivalent to T (x, r) ≤y and the result follows by
continuity of T
⊓⊔
To carry further a topological analysis of rough inclusions of the form μT ,
we consider for a given r ∈[0, 1], the set DT(r). It is equal, by RINC3, to
the set DT (r+) ={(x, y) : ∃s ≥rμ(x, y, s)}. The structure of DT (r+) can be
revealed by RINC2.
Proposition 6.9. If (x, y) ∈DT(r+), then the segment {x} × [0, y] ⊆
DT(r+).
Proof. By RINC2, if y′ ≤y, and μ(x, y′, r) then μ(x, y, r)
⊓⊔
We know, by Proposition 7, that each μT is transitive. As such it satisﬁes

234
6 Rough Mereology
Proposition 6.10. If μT(x, y, r) and ingrM(z, x), then μT(z, y, r).
Proof. As ingrM(z, x), it follows that μT (z, x, 1) by RINC1, hence, by transi-
tivity, μT (z, y, T (1, r)), i.e., μT (z, y, r)
⊓⊔
The structure theorem for μT can be strengthened,
Proposition 6.11. If (x, y) ∈DT (r+), then the Cartesian product of seg-
ments [0, x] × [0, y] ⊆DT(r+).
As for each r, the set DT(r+) is closed, the topological characterization of
μT follows,
Proposition 6.12. μT is upper–semicontinuous, in the sense that the set
{(x, y) : μ(x, y, r) is closed for each r ∈[0, 1].
We may observe that μT is in fact a ternary relation, hence, the continuity
property of μT can be expressed – more accurately even – when μT is regarded
as a many–valued mapping, i.e., given (x, y), the value of μT (x, y, r), by
RINC3, is an interval [0, rmax(x, y)]. Given s ∈[0, 1], the following holds
Proposition 6.13. The set ET (s) = {(x, y) ∈[0, 1]2 : rmax(x, y) < s} is
open for each s, i.e., μT is upper–semicontinuous as a many–valued mapping.
Proof. ET (s) is open as the complement to the closed set DT(s+)
⊓⊔
Proposition 17 in Ch. 4, implies the converse to the above Proposition 13, see
Ch. 2, sect. 12, for the notion of semi–continuity for multi–valued mappings,
Proposition 6.14. Each rough inclusion μ(x, y, r), with x, y, r ∈[0, 1], which
is non–increasing in the ﬁrst coordinate, non–decreasing in the second coor-
dinate and upper semi–continuous as a multi–valued mapping is of the form
μT(x, y, r) for some t–norm T .
Proof. It follows from assumptions that the function fμ(x, y) = rmax satisﬁes
assumptions of Proposition 17 in Ch. 4, hence, fμ(x, y) = x ⇒T y for some t–
norm T , and our thesis follows
⊓⊔
We now turn to Archimedean t–norms of Ch. 4 in search for new rough
inclusions.
6.3
Rough Inclusions: Archimedean Models
We recall that a continuous t–norm T is Archimedean, see Ch. 4, sect. 8,
when T (x, x) < x for each x ∈(0, 1). Thus, the only idempotents of T are
0, 1.
We also recall, see Ch. 4, sect. 9, that Archimedean t–norms admit a
functional characterization, a very special case of the general Kolmogorov

6.3 Rough Inclusions: Archimedean Models
235
[5] theorem, viz., for any Archimedean t–norm T , the following functional
equation holds
T (x, y) = gT(fT (x) + fT (y))
(6.7)
where the function fT : [0, 1] →R is continuous decreasing with fT (1) = 0,
and gT : R →[0, 1] is the pseudo–inverse to fT, i.e., g ◦f = id, see Ling [6].
We consider two Archimedean t–norms: L and P. Their representations
are
fL(x) = 1 −x; gL(y) = 1 −y
(6.8)
and
fP (x) = exp(−x); gP (y) = −ln y
(6.9)
For an Archimedean t–norm T , we deﬁne the rough inclusion μT on the
interval [0, 1] by means of
ARI μT (x, y, r) ⇔gT (|x −y|) ≥r
(6.10)
equivalently,
μT (x, y, r) ⇔|x −y| ≤fT(r)
(6.11)
It follows from (6.11), that
Proposition 6.15. The relation μT satisﬁes conditions RINC1–RINC3 with
ingr as identity =.
Proof. For RINC1: μT(x, y, 1) if and only if |x−y| ≤fT (1) = 0, hence, if and
only if x = y. This implies RINC2. In case s < r, and |x −y| ≤fT(r), one
has fT (r) ≤fT(s) and |x −y| ≤fT (s)
⊓⊔
Speciﬁc recipes are: for μL
μL(x, y, r) ⇔|x −y| ≤1 −r
(6.12)
and for μP ,
μP (x, y, r) ⇔|x −y| ≤−ln r
(6.13)
The counterpart of Proposition 6.7 obeys for Archimedean rough inclusions,
Proposition 6.16. For each Archimedean t–norm T , if μT (x, y, r) and
μT(y, z, s), then μT(x, z, T(r, s)).
Proof. Assume μT (x, y, r) and μT(y, z, s), i.e., |x −y| ≤fT(r) and |y −z| ≤
fT(s). Hence, |x −z| ≤|x −y| + |y −z| ≤fT(r) + fT (s), hence, gT (|x −z|) ≥
gT(fT(r) + fT (s)) = T (r, s), i.e., μT (x, z, T(r, s))
⊓⊔
It may be worth–while to relate the residual and archimedean approaches to
rough inclusions. For an Archimedean t–norm T (x, y) = g(f(x) + f(y), one
can easily calculate that in case x > y, the residual implication x ⇒T y can

236
6 Rough Mereology
be expressed as g(f(y) −f(x)), which, e.g., for the t–norm L comes down to
g(y −x), i.e., a formula (6.10), albeit with diﬀerent mereological context.
From Proposition 6.2, a general result on structure of μT can be inferred
Proposition 6.17. For a continuous t–norm T, in notation of Proposition
6.2, a rough inclusion μT can be deﬁned as follows,
μT (x, y, r) if and only if

μT (x, y, r) for x, y ∈Ai, T = L or T = P
μM(x, y, r) otherwise
(6.14)
For future applications, we need rough inclusions on sets.
6.4
Rough Inclusions: Set Models
Consider now a ﬁnite set X along with the family 2X of its subsets. We deﬁne
a rough inclusion μS ⊆2X × 2X × [0, 1], by letting
μS(A, B, r) ⇔|A ∩B|
|A|
≥r
(6.15)
where |X| denotes the cardinality of X.
Then, we observe
Proposition 6.18. The relation μS is a rough inclusion with the associated
ingredient relation of containment ⊆and the part relation being the strict
containment ⊂.
Proof. Clearly, μS(A, B, 1) if and only if A ⊆B; in that case, for every Z ⊆
X, Z∩A ⊆Z∩B, hence, μS(Z, A, r) implies μS(Z, B, R) for every r. RINC3 is
obviously satisﬁed
⊓⊔
For containment on sets, there is no transitivity rule.
6.5
Rough Inclusions: Geometric Models
The set model can be modiﬁed in a geometric context; consider, e.g., a Eu-
clidean space of a ﬁnite dimension E with objects as compact convex regions;
this environment is usually applied, e.g., in modeling problems of intelli-
gent mobile robotics, where compact convex regions model robots as well as
obstacles.
For regions A, B, we deﬁne a rough inclusion μG by means of
μG(A, B, r) ⇔||A ∩B||
||A||
≥r
(6.16)
where ||A|| denotes the area (the Lebesgue measure) of the region A.

6.6 Rough Inclusions: Information Models
237
We have
Proposition 6.19. μG is a rough inclusion with the containment ⊆as the
associated ingredient relation.
Proof. Clearly, if ||A ∩B|| = ||A||, then A ⊆B, as A \ B ̸= ∅im-
plies ||A \ B|| ̸= 0 for compact convex regions A, B. The rest is already
standard
⊓⊔
Again, as with μS, no transitivity rule can be given here.
6.6
Rough Inclusions: Information Models
An important domain where rough inclusions will play a dominant role in our
analysis of reasoning by means of parts is the realm of information systems,
see Ch. 4., sect. 2. We will deﬁne information rough inclusions denoted with
a generic symbol μI. We assume that indiscernibility = identity, i.e., each
indiscernibility class, see Ch. 4., sect. 2, is represented by a unique object.
In order to deﬁne μI, for each pair u, v ∈U, we deﬁne the set
DIS(u, v) = {a ∈A : a(u) ̸= a(v)}
(6.17)
We begin with an Archimedean rough inclusion T, and we deﬁne a rough
inclusion μI
T by means of
μI
T (u, v, r) ⇔gT(|DIS(u, v)|
|A|
) ≥r
(6.18)
Then, it is true that
Proposition 6.20. μI
T is a rough inclusion with the associated ingredient
relation of identity and the part relation empty.
Proof. We have gL(y) = 1−y and gP (y) = exp(−y), i.e, g−1(1) = 0 in either
case, so μI
T (u, v, 1) implies DIS(u, v) = ∅, hence,INDA(u, v) which, by our
assumption, is the identity =. This veriﬁes the condition RINC1, the rest fol-
lows along standard lines
⊓⊔
Rough inclusions deﬁned by means of (6.18) will be called archimedean in-
formation rough inclusions (shortened to airi’s).
In speciﬁc cases, for the Lukasiewicz t–norm, L, the airi μI
L is given by
means of the formula
μI
L(u, v, r) ⇔1 −|DIS(u, v)|
|A|
≥r
(6.19)
We introduce the set IND(u, v) = A \ DIS(u, v). With its help, we obtain a
new form of (6.19)

238
6 Rough Mereology
μI
L(u, v, r) ⇔|IND(u, v)|
|A|
≥r
(6.20)
The formula (6.20) witnesses that the reasoning based on the rough inclu-
sion μI
L is the probabilistic one. At the same time, we have given a logical
proof for formulas like (6.20) that are very frequently applied in Data Min-
ing and Knowledge Discovery, also in rough set methods in those areas, see,
e.g., Kloesgen and Zytkow [4]. It also witness that μI
L is a generalization of
indiscernibility relation to the relation of partial indiscernibility.
In case of the product t–norm P, the formula (6.18) speciﬁes to
μI
P (u, v, r) ⇔exp(−|DIS(u, v)|
|A|
) ≥r
(6.21)
We can prove, for any airi μI
T, the transitivity property in the form, see
Polkowski [12]
If μI
T(u, v, r) and μI
T (v, w, s), then μI
T (u, w, T (r, s))
(6.22)
Proof. We begin with the observation that
DIS(u, w) ⊆DIS(u, v) ∪DIS(v, w)
(6.23)
hence
|DIS(u, w)|
|A|
≤|DIS(u, v)|
|A|
+ |DIS(v, w)|
|A|
(6.24)
We let
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
gT( |DIS(u,v)|
|A|
) = r
gT( |DIS(v,w)|
|A|
) = s
gT( |DIS(u,w)|
|A|
) = t
(6.25)
Then
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
|DIS(u,v)|
|A|
= fT(r)
|DIS(v,w)|
|A|
= fT (s)
|DIS(u,w)|
|A|
= fT(t)
(6.26)
Finally, by (6.24)
fT(t) ≤fT(r) + fT (s)
(6.27)
hence
t = gT(fT(t)) ≥gT(fT (r) + fT(s)) = T (r, s)
(6.28)
witnessing μT(u, w, T (r, s)). This concludes the proof
⊓⊔

6.6 Rough Inclusions: Information Models
239
We would like as well to exploit, in the context of information systems, resid-
ual implications that served us well in case of the unit interval. The formalism
of descriptor logic, see Ch. 4, sect. 2, however, gives us not many possibilities
for characterization of objects, save sets DIS and IND. To come as close
as possible to requirements for a rough inclusion, we select an object s ∈U
referred to as a standard object, or, a pattern. From application point of view,
s may be, e.g., the best classiﬁed case, or, the pattern set as ideal.
For any object x ∈U, we let
IND(x, s) = {a ∈A : a(x) = a(s)}
(6.29)
For a continuous t–norm T , we deﬁne a rough inclusion μIND,s
T
, under generic
name of indri, by letting
INDRI μIND,s
T
(u, v, r) ⇔|IND(u, s)|
|A|
⇒T
|IND(v, s)|
|A|
≥r
(6.30)
We obtain a rough inclusion, indeed
Proposition 6.21. The indri μIND,s
T
satisﬁes conditions RINC1–RINC3
with ingredient relation ingrIND(u, v) ⇔|IND(u, s)| ≤|IND(v, s)| and
identity deﬁned as u =IND v ⇔|IND(u, s)| = |IND(v, s)|.
Proof. μIND,s
T
(u, v, 1) is equivalent to |IND(u, s)| ≤|IND(v, s)|, i.e., to
ingrIND(u, v). That is for RINC1. For RINC2, assume that |IND(u, s)| ≤
|IND(v, s)|, and |IND(w,s)|
|A|
⇒T
|IND(u,s)|
|A|
≥r. Then, by monotonicity of T,
|IND(w,s)|
|A|
⇒|IND(v,s)|
|A|
≥r follows. RINC3 is obviously satisﬁed
⊓⊔
The rough inclusion μIND,s
T
speciﬁes to distinct formulas for three basic t–
norms, L, P, M. The speciﬁc formulas are, for r < 1,
μIND,s
L
(u, v, r) ⇔1 −|IND(u, s)| + |IND(v, s)| ≥r · |A|
(6.31)
μIND,s
P
(u, v, r) ⇔|IND(v, s)| ≥r · |IND(u, s)|
(6.32)
and,
μIND,s
M
(u, v, r) ⇔|IND(v, s)| ≥r · |A|
(6.33)
We may observe that the quotient
|IND(u,s)|
|A|
is the value of the (reduced
modulo A) Hamming distance between u and s, and ingrIND(u, v) means in
this context that v is ‘closer’ to the standard s than u.
This, as well as property (6.4), suggests usage of metrics in deﬁnitions of
rough inclusions; actually, metrics were used in Poincar´e [9] to give an example
of a tolerance relation, see Ch. 1, sect. 13. We will build on this idea.

240
6 Rough Mereology
6.7
Rough Inclusions: Metric Models
We consider a metric space (X, ρ) and we let
μρ(x, y, r) ⇔ρ(x, y) ≤1 −r
(6.34)
We check that μρ is a rough inclusion.
Proposition 6.22. The relation μρ satisﬁes conditions RINC1–RINC3 with
the ingredient relation of identity = and the part relation empty.
Proof. μρ(x, y, 1) means that ρ(x, y) ≤0, i.e., x = y. This proves RINC1 and
RINC2, RINC3 follow
⊓⊔
The rough inclusion μρ obeys a transitivity law
Proposition 6.23. If μρ(x, y, r) and μρ(y, z, s), then μρ(x, z, L(r, s)).
Proof. From ρ(x, y) ≤1−r and ρ(y, z) ≤1−s, by the triangle inequality for ρ,
it follows that ρ(x, z) ≤(1−r)+(1−s), i.e., ρ(x, z) ≤1−(1−r+s) = 1−L(r, s),
hence, μρ(x, z, L(r, s))
⊓⊔
In particular, we may consider the discrete metric D(x, y) deﬁned as
D(x, y) =

1 in case x ̸= y
0 in case x = y
(6.35)
The rough inclusion μD satisﬁes the following
Proposition 6.24. 1. μD(x, y, 1) ⇔x = y.
2. For r < 1, μD(x, y, r) ⇔μD(x, y, 0) ⇔x ̸= y.
We have produced a two–valued rough inclusion, which we may justly call
the discrete rough inclusion.
We conclude our review of known to us types of rough inclusions with a
3–valued rough inclusion.
6.8
Rough Inclusions: A 3–Valued Rough Inclusion on
Finite Sets
We deﬁne a 3–valued rough inclusion μ3 by formulas
μ3(A, B, 1) ⇔A ⊆B
(6.36)
μ3(A, B, 1/2) ⇔A△B ̸= ∅,
(6.37)

6.10 Mereogeometry
241
and
μ3(A, B, 0) ⇔A ∩B = ∅
(6.38)
Symmetric rough inclusions oﬀer technical advantage over non–symmetric
ones; the possibility of inverting roles of objects allows for better control
of mutual relationships between pairs of objects and from technical point
of view oﬀers a considerable advantage. Symmetric by deﬁnitions are rough
inclusions of sects. 4, 6, 8.
6.9
Symmetrization of Rough Inclusions
Assume μ a transitive non–symmetric rough inclusion; by μsym, we denote
the symmetrized version of μ deﬁned by letting
μsym(x, y, r) ⇔μ(x, y, r) ∧μ(y, x, r)
(6.39)
Proposition 6.25. Properties of μsym are summed in
1. μsym is a rough inclusion with the ingredient relation of identity =;
2. μsym is a transitive symmetric rough inclusion.
Proof. μsym(x, y, 1) means μ(x, y, 1) and μ(y, x, 1), hence, ingr(x, y) and
ingr(y, x) thus x = y. RINC2, RINC3 follow easily. Symmetry is obvious by
deﬁnition and transitivity follows easily
⊓⊔
Here our discussion of basics of rough inclusions ends and we proceed to the
analysis of structures which can be deﬁned in rough mereological universes.
6.10
Mereogeometry
Elementary geometry was deﬁned by Alfred Tarski in His Warsaw University
lectures in the years 1926–27 as a part of Euclidean geometry which can be
described by means of 1st order logic. Alfred Tarski proposed an axiomati-
zation of elementary geometry, and many others including David Hilbert,
Moritz Pasch, Eugenio Beltrami proposed also some axiomatizations of
geometry.
There are two main aspects in formalization of geometry: one is met-
ric aspect dealing with the distance underlying the space of points which
carries geometry and the other is aﬃne aspect taking into account linear
relations.

242
6 Rough Mereology
In Tarski axiomatization, Tarski [23], the metric aspect is expressed as a
relation of equidistance (congruence) and the aﬃne aspect is expressed by
means of the betweenness relation. The only logical predicate required is the
identity =.
We recall here the Tarski formalism, although it is not our goal to discuss
elementary geometry; we include this for completeness’ sake as well as to be
used in the sequel.
Equidistance relation denoted Eq(x, y, u, z) (or, as a congruence: xy ≡uz)
means that the distance from x to y is equal to the distance from u to z
(pairs x, y and u, z are equidistant) is subject to requirements
1. Eq–reﬂexivity: Eq(x, y, y, x);
2. Eq–identity: If Eq(x, y, z, z), then x = y;
3. Eq–transitivity: If Eq(x, y, u, z) and Eq(x, y, v, w), then Eq(u, z, v, w).
Betweenness relation, denoted B(x, y, z), (y is between x and z) is required
to satisfy the requirements
1. B–identity: If B(x, y, x), then x = y;
2. B–Pasch axiom: If B(x, u, z) and B(y, v, z), then there is some a such that
B(u, a, y) and B(v, a, x);
3. B–continuity: Let φ(x) and ψ(y) be ﬁrst–order formulas in which objects
a, b do not occur as free, and, x is not free in ψ(y) and y is not free in φ(x).
If there is a such that for each pair x, y [from
φ(x) and ψ(y) it follows
that B(a, x, y)], then there is b such that for each pair x, y [from φ(x) and
ψ(y) it follows that B(b, x, y)];
4. B–lower dimension: For some triple a, b, c [not B(a, b, c) or not B(b, c, a)
or not B(c, a, b)].
Requirements concerning mutual relations between the two predicates are
following
1. B, Eq–upper dimension: If Eq(x, u, x, v) and Eq(y, u, y, v) and Eq(z, u, z, v)
and u ̸= v, then B(x, y, z) or B(y, z, x), or B(z, x, y);
2. B, Eq–parallel postulate: If B(x, y, w) and Eq(x, y, y, w), B(x, u, v), Eq(x, u,
u, v), B(y, u, z) and Eq(y, u, z, u), then Eq(y, z, v, w);

6.10 Mereogeometry
243
3. B, Eq–ﬁve segment postulate: If
(x ̸= y) and B(x, y, z), B(x′, y′, z′),
Eq(x, y, x′, y′), Eq(y, z, y′, z′), Eq(x, u, x′, u′), Eq(y, u, y′, u′), then Eq(z, u,
z′, u′);
4. B, Eq–segment extension postulate: There exists a, such that B(w, x, a)
and Eq(x, a, y, z).
Van Benthem [1] took up the subject proposing a version of betweenness
predicate based on the nearness predicate which was a departing point for
rough mereological geometry, see Polkowski and Skowron [20], and has served
us in our deﬁnition of robot formations, see Ch. 8.
We are interested in introducing into the mereological world deﬁned by μ
of a geometry in whose terms it will be possible to express spatial relations
among objects; a usage for this geometry has been found in navigation and
control tasks of mobile robotics, see Polkowski and Osmialowski [16], [17],
Osmialowski [8], Polkowski and Szmigielski [21], Szmigielski [22].
We ﬁrst introduce a notion of a distance κ, induced by a rough inclusion
μ, see Polkowski and Skowron [20], and applications in Polkowski and Osmi-
alowski [16], [17], Osmialowski [8], Polkowski and Szmigielski [21], Szmigielski
[22]
κ(X, Y ) = min{max r, max s : μ(X, Y, r), μ(Y, X, s)}
(6.40)
Observe that the mereological distance diﬀers essentially from the standard
distance: the closer are objects, the greater is the value of κ: κ(X, Y ) = 1
means X = Y whereas κ(X, Y ) = 0 means that X, Y are either externally
connected or disjoint, no matter what is the Euclidean distance between
them.
The notion of betweenness in the Tarski sense T (Z, X, Y ) (read: Z is be-
tween X and Y), due to Tarski [23], is
T (Z, X, Y ) ⇔for each region W, κ(Z, W) ∈[κ(X, W), κ(Y, W)]
(6.41)
Here, [a, b] means the non–oriented interval with endpoints a, b.
Proposition 6.26. The relation T satisﬁes the basic properties resulting from
axioms of elementary geometry of Tarski [23] for the notion of betweenness
1. TB1 T (Z, X, X) if and only if Z = X (identity);
2. TB2 T (V, U, W) and T (Z, V, W) imply T (V, U, Z) (transitivity);
3. TB3 T (V, U, Z), T (V, U, W) and U ̸= V imply T (Z, U, W) or T (W, U, Z)
(connectivity).

244
6 Rough Mereology
Proof. Indeed, by means of κ, the properties of betweenness in our context
are translated into properties of betweenness in the real line which hold by the
Tarski theorem, Tarski [23], Thm. 1
⊓⊔
We apply κ to deﬁne in our context the relation N of nearness proposed in
Van Benthem [1]
N(X, U, V ) ⇔κ(X, U) > κ(V, U)
(6.42)
Here, N(X, U, V ) means that X is closer to U than V is to U.
Then, N does satisfy all axioms for nearness in Van Benthem [1]
Proposition 6.27. The relation N does satisfy the following postulates
NB1 N(Z, U, V ) and N(V, U, W) imply N(Z, U, W) (transitivity)
NB2 N(Z, U, V ) and N(U, V, Z) imply N(U, Z, V ) (triangle inequality)
NB3 N(Z, U, Z) is false (irreﬂexivity)
NB4 Z = U or N(Z, Z, U) (selﬁshness)
NB5 N(Z, U, V ) implies N(Z, U, W) or N(W, U, V ) (connectedness)
Proof. For NB1, assumptions are κ(Z, U) > κ(V, U) and κ(V, U) > κ(W, U);
it follows that κ(Z, U) > κ(W, U) i.e. the conclusion N(Z, U, W) follows.
For NB2, assumptions κ(Z, U) > κ(V, U), κ(V, U) > κ(Z, V ) imply
κ(Z, U) > κ(Z, V ), i.e., N(U, Z, V ).
For NB3, it cannot be true that κ(Z, U) > κ(Z, U).
For NB4, Z ̸= U implies in our world that κ(Z, Z) = 1 > κ(Z, U) ̸= 1.
For NB5, assuming that neither N(Z, U, W) nor N(W, U, V ), we have
κ(Z, U) ≤κ(W, U) and κ(W, U) ≤κ(V, U) hence κ(Z, U) ≤κ(V, U), i.e.,
N(Z, U, V ) does not hold
⊓⊔
In addition to betweenness T , we make use of a betweenness relation in the
sense of Van Benthem TB introduced in Van Benthem [1]
TB(Z, U, V ) ⇔[for each W (Z = W) or N(Z, U, W) or N(Z, V, W)] (6.43)
The principal example bearing, e.g., on our approach to robot control deals
with rectangles in 2D space regularly positioned, i.e., having edges parallel
to coordinate axes. We model robots (which are represented in the plane as
discs of the same radii in 2D space) by means of their safety regions about
robots; those regions are modeled as rectangles circumscribed on robots. One
of advantages of this representation is that safety regions can be always im-
plemented as regularly positioned rectangles.
Given two robots a, b as discs of the same radii, and their safety regions
as circumscribed regularly positioned rectangles A, B, we search for a proper

6.10 Mereogeometry
245
choice of a region X containing A, and B with the property that a robot C
contained in X can be said to be between A and B. In this search we avail
ourselves with the notion of betweenness relation TB.
Taking the rough inclusion μG deﬁned in (6.16), sect. 6, for two disjoint
rectangles A, B, we deﬁne the extent, ext(A, B) of A and B as the smallest
rectangle containing the union A∪B. Then we have the claim, obviously true
by deﬁnition of TB.
Proposition 6.28. We consider a context in which objects are rectangles
positioned regularly, i.e., having edges parallel to axes in R2. The measure
μ is μG. In this setting, given two disjoint rectangles C, D, the only object
between C and D in the sense of the predicate TB is the extent ext(C, D) of
C, D, , i.e., the minimal rectangle containing the union C ∪D.
Proof. As linear stretching or contracting along an axis does not change the
area relations, it is suﬃcient to consider two unit squares A, B of which A
has (0,0) as one of vertices whereas B has (a,b) with a, b > 1 as the lower left
vertex (both squares are regularly positioned). Then the distance κ between
the extent ext(A, B) and either of A, B is
1
(a+)(b+1).
For a rectangle R : [0, x] × [0, y] with x ∈(a, a + 1), y ∈(b, b + 1), we have
that
κ(R, A) = (x −a)(y −b)
xy
= κ(R, B)
(6.44)
For φ(x, y) = (x−a)(y−b)
xy
, we ﬁnd that
∂φ
∂x = a
x2 · (1 −b
y ) > 0
(6.45)
and, similarly, ∂φ
∂y > 0, i.e., φ is increasing in x, y reaching the maximum
when R becomes the extent of A, B.
An analogous reasoning takes care of the case when R has some (c,d) with
c, d > 0 as the lower left vertex
⊓⊔
Further usage of the betweenness predicate is suggested by the Tarski axiom
of B,Eq–upper dimension, which implies collinearity of x, y, z. Thus,a line
segment may be deﬁned via the auxiliary notion of a pattern; we introduce
this notion as a relation Pt.
We let Pt(u, v, z) if and only if TB(z, u, v) or TB(u, z, v) or TB(v, u, z).
We will say that a ﬁnite sequence u1, u2, ..., un of objects belong in a line
segment whenever Pt(ui, ui+1, ui+2) for i = 1, ..., n−2; formally, we introduce
the functor Line of ﬁnite arity deﬁned by means of
Line(u1, u2, ..., un) if and only if Pt(ui, ui+1, ui+2) for i < n −1
For instance, any two disjoint rectangles A, B and their extent ext(A, B) form
a line segment.

246
6 Rough Mereology
Proposition 6.29. The relation TB does satisfy the Tarski properties TB1–
TB2, in the case of regular rectangles. The condition TB3 is easily falsiﬁed
with very simple examples.
Proof. For the case of rectangles, TB1 follows by the fact that ext(X, X) = X
(we interpret Z ⊆X as Z = X). As for TB2, assume that TB(V, U, W),
TB(Z, V, W) hold, i.e., V = ext(U, W), and Z = ext(V, W) hence Z = V and
V = ext(U, Z), i.e. TB(V, U, Z) holds.
In the case of robots, assume robots are modeled as squares of side length
1. Then TB1 follows as for rectangles, and for TB2, assume that TB(a, b, c),
TB(d, a, c) hold. We describe this situation by assuming that in the extent
ext(b, c), b is at the left upper vertex of ext(b, c), and c is in the right lower
corner of ext(b, c).
We will say: a is down and right to b and a is up and left to c. Similarly
for TB(d, a, c): d is down and right to a and d is up and left to c. Hence, a
is down and right to b, and a is up and left to d, meaning that TB(a, b, d)
holds
⊓⊔
We now return to the theme of mereotopology discussed in Ch. 5 for
mereology.
6.11
Rough Mereotopology
We analyze now topological structures in rough mereological framework. We
consider separately some cases depending on types of rough inclusions.
6.11.1
The Case of Transitive and Symmetric Rough
Inclusions
Here we have rough inclusions of the form μT induced by Archimedean t–
norms in sect. 6.3, rough inclusions of the form of airi’s, see sect. 6.6 (18),
and rough inclusions of the form μρinduced by a metric ρ, see sect. 6.7 . We
will use the general notation of μs,t to denote either of these forms. We thus
assume that a rough inclusion μs,t is given, on a collection of objects, which
obeys the transitivity law
μs,t(x, y, r), μs,t(y, z, s) ⇒μs,t(x, z, T(r, s))
(6.46)
and is symmetric, i.e.
μs,t(x, y, r) ⇔μs,t(y, x, r)
(6.47)
For each object x, we deﬁne an object Or(x) as the class of property M(x, r),
where

6.11 Rough Mereotopology
247
M(r, x)(y) ⇔μs,t(y, x, r),
(6.48)
and,
Or(x) = ClsM(x, r)
(6.49)
Hence,
Proposition 6.30. ingr(z, Or(x)) if and only if μs,t(z, x, r).
Proof. By Ch. 5, Proposition 4, ingr(z, Or(x)) if and only if there exists t
such that Ov(z, t) and μs,t(t, x, r), hence, there exists w such that ingr(w, z),
ingr(w, t), hence w = z = t, and ﬁnally μs,t(z, x, r)
⊓⊔
We regard the object Or(x) as an analogue of the notion of the ‘closed ball
about x of the radius r’.
To deﬁne the analogue of an open ball, we consider the property
M +
r (x)(y) ⇔∃q > r.μs,t(y, x, q)
(6.50)
The class of the property M +
r (x) will serve as the open ball analogue
Int(Or(x)) = ClsM +
r (x)
(6.51)
The counterpart of Proposition 6.30 for the new property is
Proposition 6.31. ingr(z, Int(Or(x))) if and only if ∃q > r.μs,t(z, x, q).
Proof. We follow the lines of the preceding proof. It is true that
ingr(z, Int(Or(x)))
if and only if there exists t such that Ov(z, t) and there exists q > r for which
μT(t, x, q) holds, hence, there exists w such that ingr(w, z), ingr(w, t), which
implies that w = z = t, and ﬁnally μT (z, x, q)
⊓⊔
From Propositions 6.30 and 6.31, we infer that
Proposition 6.32. ingr(Int(Or(x)), Or(x).
Proposition 6.33. If s < r, then ingr(Or(x), Os(x)), ingr(Int(Or(x)),
Int(Os(x))).
Consider z with ingr(z, Int(Or(x))). By Proposition 6.31, μT (z, x, s) holds
with some s > r. We can choose α ∈[0, 1] with the property that T (α, s) > r.
For any object w with ingr(w, Oα(z)), we can ﬁnd an object u such that
μT(u, z, α) and Ov(w, u).
For an object t such that ingr(t, u) and ingr(t, w), we have μT (t, w, 1),
μT(t, u, 1), hence, μT (t, x, T (α, s)), i.e, ingr(t, Int(Or(x))). As t = w, we ﬁnd
that ingr(w, Int(Or(x))). We have veriﬁed

248
6 Rough Mereology
Proposition 6.34. For each object z with ingr(z, Int(Or(x))), there exists
α ∈[0, 1] such that ingr(Oα(z), Int(Or(x))).
For any object z, what happens when ingr(z, Int(Or(x)) and ingr(z, Os(y))?
We would like to ﬁnd some Oq(z) which would be an ingredient in either of
Or(x), Os(y)).
Proposition 6.34 answers this question positively: we can ﬁnd α, β ∈
[0, 1] such that ingr(Oα(z), Int(Or(x))) and ingr(Obeta(z), Int(Os(y))). By
Proposition 6.33, ingr(Oq(z), Int(Or(x))), ingr(Oq(z), Int(Os(y))), for q =
max{α, β}.
We can sum up the last few facts
Proposition 6.35. The collection {Int(Or(x)) : x an object, r ∈[0, 1]} is
an open basis for a topology on the collection of objects.
We will call an object x open, Open(x) in symbols, in case it is a class of
some property of objects of the form Int(Or(x)).
Open(x) ⇔∃Ψ, a non −−vacuous property of basic open sets. x = ClsΨ}
(6.52)
Hence,
Proposition 6.36. In consequence of (6.52)
1. If Φ is any non–vacuous property of objects of the form Open(x), then
Open(ClsΦ);
2. If Ov(Open(x), Open(y)), then Open(Open(x) · Open(y)).
We deﬁne closures of objects, and to this end, we introduce a property Φ(x)
for each object x
Φ(x)(y) ⇔∀s < 1.Ov(Os(y), x)
(6.53)
Closures of objects are deﬁned by means of
Cl(x) = ClsΦ(x)
(6.54)
We ﬁnd what it does mean to be an ingredient of the object Cl(x).
Proposition 6.37. ingr(z, Cl(x)) if and only if Ov(Or(z), x) for every
r < 1.
Proof. By deﬁnition, there exists w such that Ov(w, z) and Φ(w). For t which
is an ingredient of z, w, hence, z = t = w, we have Φ(z), i.e., Ov(Or(z), x) for
all r < 1
⊓⊔
In particular
Proposition 6.38. ingr(z, Cl(Ow(x))) if and only if Ov(Or(z), Ow(x)) for
every r < 1.

6.11 Rough Mereotopology
249
We follow this line of analysis. Ov(Or(z), Ow(x)) means that we ﬁnd q such
that ingr(q, Or(z)), ingr(q, Ow(x)), hence, by Proposition 6.30, μs,t(q, z, r)
and μs,t(q, x, w), hence, by symmetry of μs,t, we have μs,t(z, x, T(r, w)), and,
by continuity of T, with r →1, we obtain μs,t(z, x, w), i.e., by Proposition
6.30, ingr(z, Ow(x)). We have proved
Proposition 6.39. ingr(z, Cl(Ow(x))) if and only if ingr(z, Ow(x)).
A corollary follows
Proposition 6.40. Cl(Ow(x)) = Ow(x).
We can also address the notion of the interior of an object. We deﬁne Int(x),
the interior of x as
ingr(z, Int(x)) ⇔∃w.[Ov(z, w) ∧∃r < 1.ingr(Or(w), x)]
(6.55)
A standard by now reasoning shows
Proposition 6.41. ingr(z, Int(x)) if and only if there exists r < 1 such that
ingr(Or(z), x).
This implies that the notion of an interior is valid for objects of the form
Or(x), where r < 1 and x is an object.
We can now address the problem of a boundary of any object of the form
Or(x). We deﬁne the boundary Bd(Or(x)) as
Bd(Or(x)) = Or(x) · −Int(Or(x))
(6.56)
We have a characterization of boundary ingredients
Proposition 6.42. ingr(z, Bd(Or(x))) if and only if
μs,t(z, x, r) ∧¬∃q > r.μs,t(z, x, q)
Proof. ingr(z, Bd(Or(x))) if and only if
ingr(z, Or(x)), ¬ingr(z, Int(Or(x)))
hence, μs,t(z, x, r) and μs,t(z, x, q) for no q > r
⊓⊔
We introduce a symbol μs,t(z, x, r) = sup{q : μT s, t(z, x, q)}. With its help,
we write the last result down as
ingr(z, Bd(Or(x))) ⇔μT (z, x, r) ∧μ(z, x) = r
(6.57)
Summing up our discussion, we may state that in case of transitive symmetric
rough inclusions, objects to whom notions of closure as well as interior can
be assigned are ‘collective’ objects of the form Or(x) but not object of the
form x; in one sense we obtain a ‘pointless’ topology, on the other hand, this
topology is like the orthodox topology as open objects are ‘neighborhoods’
of the form Or(x).

250
6 Rough Mereology
6.11.2
The Case of Transitive Non–symmetric Rough
Inclusions
This case is more diﬃcult as lack of symmetry of μ prohibits some inferences;
on the other hand, it is more interesting, as, e.g., no longer ingr(x, y) implies
x = y.We use a symbol μ to denote a rough inclusion induced by a continuous
t–norm T ; this time, μ is transitive but not symmetric, e.g., it is a residual
rough inclusion of the form x ⇒T y ≥r, see sect. 6.2.
We preserve deﬁnitions of objects Or(x), Int(Or(x)) and we analyze these
notions for a transitive, non–symmetric rough inclusion μ. When transitivity
issue comes into play, we assume that it is due to a continuous t–norm T .
We begin with Or(x), and we prove
Proposition 6.43. ingr(z, Or(x)) if and only if there exists t such that
ingr(t, z) and μ(t, x, r).
Proof. ingr(z, Or(x)) means that Ov(z, w) and μ(w, x, r). For t with
ingr(t, w) and ingr(t, z), we have μ(t, w, 1) and μ(t, z, 1), hence μ(t, x, T (r, 1),
i.e., μ(t, x, r)
⊓⊔
We will call t in the conclusion of Proposition 6.43, an ‘O–witness’ for the
property ingr(z, Or(x)) of z.
Similarly, we characterize interiors of O–objects
Proposition 6.44. ingr(z, Int(Or(x))) if and only if there is t such that
ingr(t, z) and μ(t, x, s) for some s > r.
By analogy, we call t in the conclusion of Proposition 6.44, an ‘O+–witness’
for the property ingr(z, Int(Or(x))) of z.
The witness has good neighborhood properties.
Proposition 6.45. For an O+–witness t for ingr(z, Int(Or(x))), there exists
s < 1 such that ingr(Os(t), Int(Or(x))) holds.
Proof.
We have μ(t, x, s) with s > r, and, ingr(t, z). We choose q < 1 such
that T (q, s) > r. Consider y with ingr(y, Oq(t)), so there is w with properties
ingr(w, y), μ(w, t, q).
Hence, μ(w, x, T(s, q) and ingr(w, Int(Or(x))). By mereology axiom M3,
Ch. 5, sect. 1, ingr(Oq(t), Int(Or(x)))
⊓⊔
As an upshot to Proposition 6.45, we will call an object x open, Open(x) in
symbols, when the condition is satisﬁed
Open(x) ⇔[ingr(z, x) ⇔∃t, 0 < r < 1.ingr(Or(t), x) ∧ingr(t, z)]
(6.58)
A corollary follows
Open(Int(Or(x))
(6.59)
for each object x and each r < 1.

6.11 Rough Mereotopology
251
Following this line of reasoning, we deﬁne the interior of an object x,
Int(x) in symbols, letting
ingr(z, Int(x)) ⇔∃t.[ingr(t, z) ∧∃r < 1.ingr(Or(t), x)]
(6.60)
Clearly
Proposition 6.46. Properties of the operator Int are
1. ingr(Int(x), x);
2. ingr(Int(Int(x)), Int(x));
3. ingr(x, y) ⇒ingr(Int(x), Int(y)).
Dually, we deﬁne the closure of x, Cl(x) in symbols, by means of
ingr(z, Cl(x)) ⇔∃t.[Ov(t, z) ∧∀r < 1.Ov(Or(t), x)]
(6.61)
This condition can be disentangled; there exists w with ingr(w, t), ingr(w, z)
and there exists ur such that ingr(qr, x), μ(qr, z, r) for each r < 1.
This intricate requirement can be simpliﬁed in discrete
case when the
number of objects is ﬁnite. Then, for r suﬃciently close to 1, the only qr
satisfying the condition μ(qr, z, r) is z itself, hence, ingr(z, x) and ﬁnally,
Ov(z, x). We obtain
Proposition 6.47. In discrete case, ingr(z, Cl(x)) if and only if Ov(z, x).
Hence
Proposition 6.48. In discrete case,
1. ingr(x, Cl(x));
2. ingr(Cl(x), Cl(Cl(x)));
3. ingr(x, y) ⇒ingr(Cl(x), Cl(y)).
We obtain a quasi– ˇCech closure operation. Finally, we take up the boundary
question. Again, we deﬁne the boundary of x, Bd(x) as Cl(x) · −Int(x). The
speciﬁc condition can be revealed as
Proposition 6.49. In discrete case, for each object x, the boundary Bd(x)
satisﬁes ingr(z, Bd(x)) if and only if Ov(z, x) and ∃t.[ingr(t, z) ∧∀r <
1.¬ingr(Or(t), x)].

252
6 Rough Mereology
6.12
Connections from Rough Inclusions
We will explore now the possibility of inducing a connection in an environ-
ment endowed with a rough inclusion μ. As before, we consider cases when
μ is symmetric or not. We still retain the symbol μ as generic for rough
inclusions.
6.12.1
The Case of Transitive and Symmetric Rough
Inclusions
For a transitive and symmetric rough inclusion μ, we deﬁne a connection Cμ
by letting
Cμ(x, y) ⇔∀r < 1.Ov(Or(x), Or(y))
(6.62)
We need to make sure that Cμ is a connection, see Ch. 5, 5
Proposition 6.50. Cμ does satisfy conditions CN1–CN3 for connections.
Proof. CN1, CN2 are satisﬁed obviously. For CN3, observe that when x ̸= y
then, e.g., ¬ingr(x, y), i.e., μ(x, y, r) implies r < 1, hence, there is s < 1 that
μ(x, y, s) does not hold,i.e., it is not true that Ov(Oq(x), Oq(y)) holds for q
large enough to satisfy T (q, q) > s
⊓⊔
We can explore the form of other predicates induced from Cμ. We know that
Ov(x, y) means x = y, hence, external connectedness is expressed by means
of
ECμ(x, y) ⇔(x ̸= y) ∧Cμ(x, y).
(6.63)
This implies the form of T ingrCμ and NT ingrCμ.
In discrete case, for r suﬃciently close to 1, Or(x) = x for each x, hence,
Cμ(x, y) means simply x = y, ECμ(x, y) is not deﬁned, hence, T ingrCμ is not
deﬁned and NT ingrCμ(x) = x for each x. In continuous case, the situation
depends on additional properties of μ: if μ is continuous in the sense
limr→sOr(x) = Os(x)
(6.64)
then, again, Cμ(x, y) ⇔(x = y), with ECmu, T ingrCμ, NT ingrCμ as above.
An example of continuous μ is μρ: as μρ(x, y, r) ⇔ρ(x, y) ≤1 −r, where
ρ a metric, (6.64) is satisﬁed with μρ.
6.12.2
The Case of Symmetric Non–transitive Rough
Inclusions and the General Case
The general case is represented by rough inclusions of the type indri, see sect.
6.6 (30), and, as we know, ingr(x, y) means in this case that |IND(x, s)| ≤

6.12 Connections from Rough Inclusions
253
|IND(y, s)|. Thus, if there exists an object z with IND(z, s) = ∅, then
z is an ingredient of each object, hence, any two objects overlap, and the
deﬁnition (6.62) is not plausible. The only deﬁnition that remains is to accept
C(x, y) if and only of x = y, i.e., when |IND(X, s)| = |IND(y, s)|. The case
of symmetric non–transitive rough inclusions is represented, e.g., by set–
theoretic rough inclusions μS(x, y, r) ⇔|x∩y|
|x|
≥r, see sect. 6.4, and geometric
rough inclusions μG(x, y, r) ⇔||x∩y||
||x||
≥r, see sect. 6.5. We consider a family
F of ﬁnite subsets of a certain universe U and a family C of convex compact
regions in a certain space Rk which share the following properties
RINC4 extr(x, y) ⇒∃r < 1.extr(Or(x), Or(y))
(6.65)
RINC5 ¬ingr(x, y) ⇒∃z.ingr(z, x) ∧extr(z, y)
(6.66)
With respect to the property RINC4, one may say that objects in F, respec-
tively, in C are well–separated. We adopt the deﬁnition of a connection C in
terms of overlapping
C(x, y) ⇔∀r < 1.Ov(Or(x), Or(y))
(6.67)
Proposition 6.51. Under RINC4,RINC5, C is a connection.
Proof. Again, CN1, CN2, are obviously satisﬁed, and only CN3 needs to be
veriﬁed. In case x ̸= y, assume, e.g., that ̸= ingr(x, y). Under complementa-
tion RINC5, there exists z with ingr(z, x) and extr(z, y). By RNC4, there
is r < 1 such that extr(Or(z), Or(y)), whereas, Ov(Or(z), Or(x)) for each
r < 1
⊓⊔
Under this deﬁnition, external connectedness can be deﬁned as
Proposition 6.52. EC(x, y) if and only if Ov(Or(x), Or(y)) for each r < 1
but not Ov(x, y).
The notion of non–tangential part comes down to
Proposition 6.53. NT ingrC(x, y) ⇔C(z, x) ⇒Ov(z, y) for each z.
We deﬁne the interior IntC(x) for each object x, as usual as the class of the
property of being a non–tangential part
NT P(x)(y) ⇔NT ingrC(y, x),
(6.68)
and
IntC(x) = ClsNT P(x)
(6.69)

254
6 Rough Mereology
Hence,
ingr(z, IntC(x)) ⇔∃w.Ov(z, w) ∧NT ingrC(w, x)
(6.70)
Our claim is that
Proposition 6.54. ingr(z, IntC(x)) implies that ingr(Or(z), x) for some
r < 1.
Proof. Assuming to the contrary, that it is not true that ingr(Or(z), x) for
r < 1, we obtain that the complement −x is externally connected to x and z, a
contradiction
⊓⊔
A corollary follows
Proposition 6.55. ingr(IntC(x), Int(x)), where Int(x) is the interior of x
deﬁned in terms of μ.
The converse also holds
Proposition 6.56. ingr(Int(x), IntC(x)) holds for each object x.
Proof. For z with ingr(z, Int(x), we have that ingr(Or(z), x) for some r; if
C(z, w) for any w, then Ov(Or(z), Or(w), but this means that Ov(x, w) by
RINC4
⊓⊔
A corollary is
Proposition 6.57. IntC(x) = Int(x) for every x.
Relations of rough mereology to the fuzzy set theory are highlighted by the
fact that rough inclusions are higher–order fuzzy equivalences in the sense of
Zadeh [25].
6.13
Rough Inclusions as Many–Valued Fuzzy
Equivalences
Rough inclusions are deﬁned as relations of a part to a degree and this makes
them aﬃne to fuzzy constructs, though they stem form diﬀerent inspirations
and have a diﬀerent logical structure. Nevertheless, one may try to relate both
worlds. We have a result that states, see, e.g., Polkowski [10], [12] that any
rough inclusion μ(x, y, r) does induce on its universe a fuzzy similarity rela-
tion in the sense of Zadeh [25], see Ch. 4, sect. 12. First, writing μy(x) = r in-
stead of μ(x, y, r), we convert the relational notation into the fuzzy–style one.
We observe that fuzzy sets of the form μy are higher–level sets: values of fuzzy
membership degrees here are convex sub–intervals of the unit interval [0, 1] of
the form [0, r], i.e., with the left–end point 0, hence the formula μy(x) = t is
understood as the statement that the sub–interval μy(x) contains t. Under this
proviso, the fuzzy tolerance relation τμ
y (x) is deﬁned by means of

τ μ
y (x) = r ⇔μy(x) = r and μx(y) = r
(6.71)
and it does satisfy, clearly,
1. τ μ
x (x) = 1;
2. τμ
x (y) = τ μ
y (x).
We will use now the notation τr(x, y) for τx(y) = r, disregarding the rough
inclusion μ. Following Zadeh [25], we deﬁne similarity classes [x]τ as fuzzy
sets satisfying the condition,
χ[x]τ(y) = r ⇔τr(x, y)
(6.72)
and in this interpretation, τ becomes a fuzzy equivalence in the sense of
Zadeh [25], see Polkowski [43], i.e., the family {[x]τ : x ⊆U} does satisfy the
requirements for a T –fuzzy partition in the sense of Zadeh [25], cf., Ch. 4,
sect. 12
∀x∃y.χ[x]τ (y) = 1
(6.73)
and
[x]τ ̸= [z]τ ⇒maxy{min{χ[x]τ(y), χ[z]τ (y)}} < 1,
(6.74)
and,

x
[x]τ ×T [x]τ = τ
(6.75)
where A ×T B denotes the fuzzy set deﬁned via,
χA×T B(u, v) = T (χA(u), χB(v))
(6.76)
and  denotes the supremum operator.
We include an argument, cf., Polkowski [43], see Ch. 4, sect. 12, for prop-
erties FS1–FS3. For (6.73), it is satisﬁed with x = y. To justify (6.74),
observe that the existence of y with τ(x, y) = 1 = τ(z, y) would imply
τ(x, z) = 1 = τ(z, x), hence, x = z. For (6.75), we have for given x, y, z
by FS3 that
T (τ(x, y), τ(x, z)) = T (τ(y, x), τ(x, z)) ≤τ(y, z)
But, for x = y, we have by FS1 that
[x]τ ×T [x]τ(y, z) = [y]τ ×T [y]τ(y, z) = T (τ(y, y), τ(y, z)) = T (1, τ(y, z)) =
τ(y, z)
so (6.75) follows.

256
References
References
1. Van Benthem, J.: The Logic of Time. Reidel, Dordrecht (1983)
2. Faucett, W.M.: Compact semigroups irreducibly connected between two idem-
potents. Proc. Amer. Math.Soc. 6, 741–747 (1955)
3. H´ajek, P.: Metamathematics of Fuzzy Logic. Kluwer, Dordrecht (1998)
4. Kl¨osgen, W., Zytkow, J. (eds.): Handbook of Data Mining and Knowledge
Discovery. Oxford University Press, Oxford (2002)
5. Kolmogorov, A.N.: On the representation of continuous functions of many vari-
ables by superposition of continuous functions of one variable and addition.
Amer. Math.Soc. Transl. 28, 55–59 (1963)
6. Ling, C.–H.: Representation of associative functions. Publ. Math. Debrecen 12,
189–212 (1965)
7. Mostert, P.S., Shields, A.L.: On the structure of semigroups on a compact
manifold with a boundary. Ann. Math. 65, 117–143 (1957)
8. O´smialowski, P.: On path planning for mobile robots: Introducing the mereo-
logical potential ﬁeld method in the framework of mereological spatial reason-
ing. Journal of Automation, Mobile Robotics and Intelligent Systems (JAM-
RIS) 3(2), 1–10 (2009)
9. Poincar´e, H.: La Science et l’Hypoth´ese. Flammarion, Paris (1902)
10. Polkowski, L.: Rough Sets. Mathematical
Foundations. Physica Verlag,
Heidelberg (2002)
11. Polkowski, L.: A rough set paradigm for unifying rough set theory and fuzzy
set theory. In: Wang, G., Liu, Q., Yao, Y., Skowron, A. (eds.) RSFDGrC 2003.
LNCS (LNAI), vol. 2639, pp. 70–78. Springer, Heidelberg (2003)
12. Polkowski, L.: Toward rough set foundations. Mereological approach. In:
Tsumoto, S., Slowi´nski, R., Komorowski, J., Grzymala-Busse, J.W. (eds.)
RSCTC 2004. LNCS (LNAI), vol. 3066, pp. 8–25. Springer, Heidelberg (2004)
13. Polkowski, L.: Formal granular calculi based on rough inclusions. In: Proceed-
ings of IEEE 2005 Conference on Granular Computing GrC 2005, pp. 57–62.
IEEE Press, Beijing (2005)
14. Polkowski, L.: Rough–fuzzy–neurocomputing based on rough mereological cal-
culus of granules. International Journal of Hybrid Intelligent Systems 2, 91–108
(2005)
15. Polkowski, L.: A model of granular computing with applications. In: Proceed-
ings of IEEE 2006 Conference on Granular Computing GrC 2006, pp. 9–16.
IEEE Computer Society Press, Atlanta (2006)
16. Polkowski, L.: O´smialowski P. Spatial reasoning with applications to mobile
robotics. In: Xing–Jian, J. (ed.) Motion Planning for Mobile Robots: New Ad-
vances, InTech, Vienna, pp. 433–453 (2008)

References
257
17. Polkowski, L., O´smialowski, P.: Navigation for mobile autonomous robots and
their formations: An application of spatial reasoning induced from rough mere-
ological geometry. In: Barrera, A. (ed.) Mobile Robots Navigation. I–Tech,
Zagreb, pp. 329–354 (2010)
18. Polkowski, L., Skowron, A.: Rough mereology. In: Ra´s, Z.W., Zemankova, M.
(eds.) ISMIS 1994. LNCS, vol. 869, pp. 85–94. Springer, Heidelberg (1994)
19. Polkowski, L., Skowron, A.: Rough mereology: a new paradigm for ap-
proximate reasoning. International Journal of Approximate Reasoning 15(4),
333–365 (1997)
20. Polkowski, L., Skowron, A.: Rough mereology in information systems with
applications to qualitative spatial reasoning. Fundamenta Informaticae 43,
291–320 (2000)
21. Polkowski, L., Szmigielski, A.: Computing with words via rough mereology
in mobile robot navigation. In: Proceedings 2003 IEEE/RSJ Int. Conf. Intell.
Robots and Systems IROS 2003, pp. 3498–3503. IEEE Press, Los Alamitos
(2003)
22. Szmigielski, A.: A description based on rough mereology of the workspace of
a mobile robot by means of a system of ultrasound sensors (in Polish). L.
Polkowski (supervisor). PhD Dissertation. Dept. Electronics and Computer
Techniques, Warsaw University of Technology (2003)
23. Tarski, A.: What is elementary geometry? In: Henkin, L., Suppes, P., Tarski, A.
(eds.) The Axiomatic Method with Special Reference to Geometry and Physics,
pp. 16–29. North-Holland, Amsterdam (1959)
24. Zadeh, L.A.: Fuzzy sets. Information and Control 8, 338–353 (1965)
25. Zadeh, L.A.: Similarity relations and fuzzy orderings. Information Sciences 3,
177–200 (1971)


Chapter 7
Reasoning with Rough Inclusions:
Granular Computing, Granular Logics,
Perception Calculus, Cognitive and
MAS Reasoning
Rough mereology allows for a plethora of applications in various reasoning
schemes due to universality of its primitive predicate of a part to a degree.
We have already stressed that by its nature, rough mereology is especially
suited to reasoning with collective concepts like geometric ﬁgures or solids, or,
concepts learned by machine learning methods, i.e., with collective concepts.
Those applications are presented in Ch. 8 and Ch. 9. In this chapter, we
begin this discussion with a formal approach to the problem of granulation of
knowledge and then we examine rough mereological logics: from our results
in Ch. 6 it follows that representing implication with a rough inclusion μ
leads to logics which extend and generalize fuzzy logics. As an application,
we propose a formal rendering of the idea of perception calculus, due to
Zadeh [67]. We apply rough mereological schemes to reasoning by multi–
agent (MAS) systems, and ﬁnally we present a rough mereological variant of
cognitive reasoning in neural–like systems.
7.1
On Granular Reasoning
The creator of Fuzzy Set Theory LotﬁA. Zadeh proposed to compute with
granules in Zadeh [66]. The idea was natural, as fuzzy reasonings are carried
out in terms of fuzzy membership functions. A fuzzy membership function
μX maps a universe U of objects into the interval [0, 1] and it represents the
membership in a set X as a membership to a degree. The value μX(x) = r
is interpreted as the statement that the object x is an element of the set X
to the degree of r. The mapping U →U/μX which sends each object x to its
ﬁbre μ−1
X (μX(x)) identiﬁes into the granule gμ(r) all objects that belong in
X to the degree r.
All fuzzy constructs are then expressed in terms of those granules. In this
sense, fuzzy reasoning is in a natural way reasoning with granules. Granules in
this reasoning are constructed in a uniform way, i.e., all objects in a granule
share the same property of external character: they belong to an ”oracle”
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 259–295.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

260
7 Reasoning with Rough Inclusions
X to the same degree; changing X produces a variety of granules to reason
with. The relation forming any granule is an equivalence RX: the universe is
decomposed into ﬁbres of a fuzzy membership function μX in question, and
the knowledge base is composed of all relations RX for subsets X ⊆U of the
universe of objects.
The same conclusion concerns rough set reasoning: elementary objects in
reasoning are indiscernibility classes – elementary granules which are elements
of a partition of the universe of objects by an indiscernibility relation IND(B)
for some set B of attributes, see Ch. 4. These granules are the smallest objects
which can be described in terms of attributes and their values, i.e., in terms of
descriptors and they are used in forming descriptions of objects, in building
decision rules and classiﬁers as well as control algorithms.
Reasoning by means of aggregating objects, situations, cases, etc., into
granules of similar entities is common to all forms of human reasoning. It is
therefore important to capture this form of reasoning in its essential and typi-
cal facets and render it in mereological environment with help of mereological
notions.
In Lin [21], [22], topological character of granules was recognized and the
basic notion of a neighborhood system as the meaning of the collection of
granules on the universe of objects was brought forth, Lin [22] recognized
the import of tolerance relations, see Nieminen [37], cf., Ch. 1, sect. 13, by
discussing tolerance induced neighborhoods.
In all hybrid approaches involving fuzzy or rough sets along with neural
networks, genetic algorithms, etc., etc., one is therefore bound to compute
with granules; this fact testiﬁes to the importance of granular structures.
In search of adequate similarity relations, various forms of granules were
proposed and considered as well as experimentally veriﬁed as to their ef-
fectiveness. In information systems, indiscernibility classes were proposed as
granules, or, more generally, templates have served that purpose, i.e., mean-
ings of generalized descriptors of the form (a ∈Wa) where Wa ⊆Va with the
meaning [[(a ∈Wa)]] = {u ∈U : a(u) ∈Wa}, see Nguyen S. H. [36]; clearly,
templates are aggregates, in ontological sense, of descriptors, i.e., they form
”big” granules. Their usage is motivated by their potentially greater descrip-
tive force than that of descriptors; a judicious choice of sets Wa should allow
for constructing of a similarity relation that would reﬂect satisfactorily well
the dependence of decision on conditional attributes.
As means for granule construction, rough inclusions have been considered
and applied, in Polkowski [41] – [52]. The idea of granule formation and
analysis rests on usage of the mereological class operator in the framework
of mereological reasoning.
Granules formed by rough inclusions are used in models of fusion of knowl-
edge, rough–neural computing and in building many–valued logics reﬂecting
the rough set ideology in reasoning, and these forms of reasoning are discussed
in further parts of this chapter.
Granulation of knowledge can be considered from a few angles

7.2 On Methods for Granulation of Knowledge
261
1. General purpose of granulation;
2. Granules from binary relations;
3. Granules in information systems from indiscernibility;
4. Granules from generalized descriptors;
5. Granules from rough inclusions – mereological approach.
We brieﬂy examine those facets of granulation.
7.2
On Methods for Granulation of Knowledge
Granulation of knowledge comes into existence for a few reasons; the princi-
pal one is founded on the underlying assumption of basically all paradigms,
viz., that reality exhibits a fundamental continuity, i.e., objects with iden-
tical descriptions in the given paradigm should exhibit the same properties
with respect to classiﬁcation or decision making, in general, in their behavior
towards the external world.
For instance, fuzzy set theory assumes that objects with identical mem-
bership descriptions should behave identically and rough set theory assumes
that objects indiscernible with respect to a group of attributes should behave
identically, in particular they should fall into the same decision class.
Hence, granulation is forced by assumptions of the respective paradigm
and it is unavoidable once the paradigm is accepted and applied. Granules
induced in the given paradigm form the ﬁrst level of granulation.
In the search for similarities better with respect to applications like clas-
siﬁcation or decision making, more complex granules are constructed, e.g.,
as unions of granules of the ﬁrst level, or more complex functions of them,
resulting, e.g., in fusion of various granules from distinct sources.
Among granules of the ﬁrst two levels, some kinds of them can be exhibited
by means of various operators, e.g., the class operator associated with a rough
inclusion.
7.2.1
Granules from Binary Relations
Granulation on the basis of binary general relations as well as their special-
izations to, e.g., tolerance relations, has been studied by Lin [23] – [28], in
particular as an important notion of a neighborhood system; see also Yao
[64], [65]. This approach extends the special case of the approach based on
indiscernibility. A general form of this approach according to Yao [64], [65],

262
7 Reasoning with Rough Inclusions
exploits the classical notion of Galois connection, cf., Ch. 1 sect. 4: two map-
pings f : X →Y, g : Y →X form a Galois connection between ordered sets
(X, <) and (Y, ≺) if and only if the equivalence x < g(y) ⇔f(x) ≺y holds.
In an information system (U, A), for a binary relation R on U, one considers
the sets xR = {y ∈U : xRy} and Rx = {y ∈U : yRx}, called, respectively,
the successor neighborhood and the predecessor neighborhood of x. These sets
are considered as granules formed by a speciﬁc relation of being aﬃne to x
in the sense of the relation R. Other forms of granulation can be obtained by
comparing objects with identical neighborhoods, e.g., x ≡y ⇔xR = yR.
Saturation of sets of objects X, Y with respect to the relation R leads
to sets X∗, Y ∗such that X ∗R = Y ∗⇔RY ∗= X∗, forming a Galois
connection. This approach is closely related to the Formal Concept Analysis
of Wille [63].
7.2.2
Granules in Information Systems from
Indiscernibility
Granules based on indiscernibility in information/decision systems, see Ch. 4,
sect. 2, are constructed as indiscernibility classes: given an information system
(U, A) and the collection IND = {IND(B) : B ⊆A} of indiscernibility
relations, each elementary granule is of the form of an indiscernibility relation
[u]B = {v ∈U : (u, v) ∈IND(B)} for some B. Among those granules, there
are minimal ones: granules of the form [u]A induced from the set A of all
attributes.
Granules [u]A form the ﬁnest partition of the universe U which can be
obtained by means of indiscernibility; given the class [u]B and the class
[u]A\B, we have [u]A=[u]B ∩[u]A\B hence [u]B = 
v∈[u]B∩DISA\B(u)[v]A,
where v ∈DISA\B(u) if and only if there exists an attribute a ∈A \ B such
that a(u) ̸= a(v). It is manifest that granules [u]B can be arranged into a
tree with the root [u]∅= U and leaves of the form [u]A.
Granules based on indiscernibility form a complete Boolean algebra gen-
erated by atoms of the form [u]A: unions of these atomic granules are closed
on intersections and complements and these operations induce into granules
the structure of a ﬁeld of sets.
Atomic granules are made into some important unions by approximation
operators, see Ch. 4, sect. 2: given a concept X ⊆U, the lower approximation
BX to X over the set B of attributes is deﬁned as the union {[u]B : [u]B ⊆
X}; the operator LB : Concepts →Granules sending X to BX is monotone
increasing and idempotent: X ⊆Y implies LX ⊆LY and L ◦L = L.
Similarly, the upper approximation BX = {[u]B : [u]B ∩X ̸= ∅} to X
over B, makes some elementary granules into the union; the operator U B
sending concepts into upper approximations is also monotone increasing and
idempotent.

7.3 Granules from Rough Inclusions
263
7.2.3
Granules from Generalized Descriptors
Some authors have made use of generalized descriptors called templates, see
Nguyen S. H. [36]; a template is a formula T : (a ∈Wa), where Wa ⊆Va,
with the meaning g(T ) : {u ∈U : a(u) ∈Wa}. The granule g(T ) can be
represented as the union 
u∈Wa[u]a; granules of the form [u]a are also called
blocks, see Grzymala–Busse [15], Grzymala–Busse and Ming Hu [16].
7.3
Granules from Rough Inclusions: The Mereological
Approach to Granulation of Knowledge
Assume that a rough inclusion μ is given along with the associated ingredient
relation ingr, as in postulate RINC1, in Ch. 6, sect 1.
The granule gμ(u, r) of the radius r about the center u is deﬁned as the
class of property Φμ
u,r
Φμ
u,r(v) ⇔μ(v, u, r)
(7.1)
The granule gμ(u, r) is deﬁned by means of
gμ(u, r) = ClsΦμ
u,r
(7.2)
Properties of granules depend, obviously, on the type of rough inclusion used
in their deﬁnitions. We consider separate cases, as some features revealed
by granules diﬀer from a rough inclusion to a rough inclusion. The reader
is asked to refer to Ch. 5 for description of mereological reasoning, which is
going to be used in what follows.
In case of Archimedean t–norm–induced rough inclusions, see Ch. 6, sect.
3, or metric–induced rough inclusions, see Ch. 6, sect. 7, by their transitivity,
and symmetry, the important property holds, see Polkowski [52].
Proposition 7.1. In case of a symmetric and transitive rough inclusion μ,
for each pair u, v of objects , and r ∈[0, 1], ingr(v, gμ(u, r)) if and only if
μ(v, u, r) holds. In eﬀect, the granule gμ(u, r) can be represented as the set
{v : μ(v, u, r)}.
Proof. Assume that ingr(v, gμ(u, r)) holds. Thus, there exists z such that
Ov(z, v) and μ(z, u, r). There is x with ingr(x, v), ingr(x, z), hence, by transi-
tivity of μ, also μ(x, u, r) holds. By symmetry of μ, ingr(v, x), hence, μ(v, x, r)
holds also
⊓⊔
In case of rough inclusions in information systems, induced by residual im-
plications generated by continuous t–norms, see Ch. 6, sect. 2, L, P, or M,
we have a positive case, for the minimum t–norm M
Proposition 7.2. For the rough inclusion μ induced by the residual im-
plication ⇒M, due to the minimum t–norm M, and r < 1, the relation
ingr(v, gμ(u, r)) holds if and only if μ(v, u, r) holds.

264
7 Reasoning with Rough Inclusions
Proof. The rough inclusion μ has the form μ(v, u, r) if and only if |IND(v,s)|
|A|
⇒M
|IND(u,s)|
|A|
≥r. Assume that ingr(v, gμ(u, r)) holds, so by the class deﬁ-
nition, there exists z such that Ov(v, z) and μ(z, u, r) hold. Thus, we have w
with ingr(w, v) and μ(w, u, r) by transitivity of μ and the fact that ingr(w, z).
By deﬁnition of μ, ingr(w, v) means that |IND(w, s)| ≤|IND(v, s)|. As
μ(w, u, r) with r < 1 means that |IND(u, s)| ≥r because of |IND(w, s)| ≥
|IND(u, s)|, the condition |IND(w, s)| ≤|IND(v, s)| implies that μ(v, u, r)
holds as well
⊓⊔
The case of the rough inclusion μ induced either by the product t–norm
P(x, y) = x · y, or by the Lukasiewicz t–norm L, is a bit more intricate. To
obtain in this case some positive result, we exploit the averaged t–norm ϑ(μ)
deﬁned for the rough inclusion μ, induced by a t–norm T, by means of the
formula
ϑ(μ)(v, u, r) ⇔∀z.∃a, b.μ(z, v, a), μ(z, u, b), a ⇒T b ≥r
(7.3)
Our proposition for the case of the t–norm P is
Proposition 7.3. For r < 1, ingr(v, gϑ(μ)(u, r)) holds if and only if μ(v, u, a·
r), where μ(v, t, a) holds for t which obeys conditions ingr(t, v) and ϑ(μ)
(t, u, r).
Proof. ingr(v, gϑ(μ)(u, r)) implies that there is w such that Ov(v, w) and
ϑ(μ)(w, u, r), so we can ﬁnd t with properties, ingr(t, w), ingr(t, v), hence,
by transitivity of ϑ(μ) also ϑ(μ)(t, u, r).
By deﬁnition of ϑ(μ), there are a, b such that μ(v, t, a), μ(v, u, b), and
a ⇒P b ≥r, i.e., b
a ≥r. Thus, μ(v, u, b) implies μ(v, u, a·r)
⊓⊔
An analogous reasoning brings forth in case of the rough inclusion μ induced
by residual implication due to the Lukasiewicz implication L, the result that
Proposition 7.4. For r < 1, ingr(v, gϑ(μ)(u, r)) holds if and only if μ(v, u, r
+a−1) holds, where μ(v, t, a) holds for t such that ingr(t, v) and ϑ(μ)(t, u, r).
The two last propositions can be recorded jointly in the form
Proposition 7.5. For r < 1, and μ induced by residual implications either
⇒P or ⇒L, ingr(v, gϑ(μ)(u, r)) holds if and only if μ(v, u, T(r, a)) holds,
where μ(v, t, a) holds for t such that ingr(t, v) and ϑ(μ)(t, u, r).
Granules as collective concepts can be objects for rough mereological calculi.
7.4
Rough Inclusions on Granules
Due to the feature of mereology that it operates (due to the class operator)
only on level of individuals, one can extend rough inclusions from objects to

7.5 General Properties of Rough Mereological Granules
265
granules; the formula for extending a rough inclusion μ to a rough inclusion
μ on granules is a modiﬁcation of mereological axiom M3 of Ch. 5
μ(g, h, r) ⇔∀z.ingr(z, g) ⇒∃w.ingr(w, h), μ(z, w, r).
(7.4)
Proposition 7.6. The predicate μ(g, h, r) is a rough inclusion on granules.
Proof. μ(g, h, 1) means that for each object z with ingr(z, g) there exists an
object w with ingr(w, h) such that μ(z, w, 1), i.e., ingr(z, w), which, by the in-
ference rule implies that ingr(g, h). This proves RINC1. For RINC2, assume
that μ(g, h, 1) and μ(k, g, r) so for each ingr(x, k) there is ingr(y, g) with
μ(x, y, r). For y there is z such that ingr(z, h) and μ(y, z, 1), hence, μ(x, z, r)
by property RINC2 of μ. Thus, μ(k, h, r). RINC2 follows and RINC3 is obvi-
ously satisﬁed
⊓⊔
We now examine rough mereological granules with respect to their properties.
7.5
General Properties of Rough Mereological
Granules
They are collected below in
Proposition 7.7. The following constitute a set of basic properties of rough
mereological granules
1. If ingr(y, x) then ingr(y, gμ(x, r));
2. If ingr(y, gμ(x, r)) and ingr(z, y) then ingr(z, gμ(x, r));
3. If μ(y, x, r) then ingr(y, gμ(x, r));
4. If s < r then ingr(gμ(x, r), gμ(x, s)),
which follow straightforwardly from properties RINC1–RINC3 of rough in-
clusions and the fact that ingr is a partial order, in particular it is transitive,
regardless of the type of the rough inclusion μ.
For T –transitive rough inclusions, we can be more speciﬁc, and prove
Proposition 7.8. For each T–transitive rough inclusion μ,
1. If ingr(y, gμ(x, r) then ingr(gμ(y, s), gμ(x, T(r, s));
2. If μ(y, x, s) with 1 > s > r, then there exists α < 1 with the property that
ingr(gμ(y, α), gμ(x, r).

266
7 Reasoning with Rough Inclusions
Proof. Property 1 follows by transitivity of μ with the t–norm T. Property 2
results from the fact that the inequality T (s, α) ≥r has a solution in α, e.g.,
for T = P, α ≥r
s, and, for T = L, α ≥1 −s + r
⊓⊔
It is natural to regard granule system {gμt
r (x) : x ∈U; r ∈(0, 1)} as a
neighborhood system for a topology on U that may be called the granular
topology.
In order to make this idea explicit, we deﬁne classes of the form
N T (x, r) = Cls(ψμT
r,x)
(7.5)
where
ψμT
r,x(y) ⇔∃s > r.μT(y, x, s)
(7.6)
We declare the system {N T(x, r) : x ∈U; r ∈(0, 1)} to be a neighborhood
basis for a topology θμ. This is justiﬁed by the following
Proposition 7.9. Properties of the system {N T(x, r) : x ∈U; r ∈(0, 1)} are
as follows
1. y ingr N T (x, r) ⇒∃δ > 0.N T (y, δ) ingr N T(x, r);
2. s > r ⇒N T(x, s) ingr N T(x, r);
3. z ingr N T(x, r) ∧z ingr N T (y, s) ⇒∃δ > 0 N T(z, δ) ingr N T(x, r) ∧
N T(z, δ) ingr N T (y, s).
Proof. For Property 1, y ingr N t(x, r) implies that there exists an s > r such
that μt(y, x, s). Let δ < 1 be such that t(u, s) > r whenever u > δ; δ exists
by continuity of t and the identity t(1, s) = s. Thus, if z ingr N t(y, δ), then
μt(z, y, η) with η > δ and μt(z, x, t(η, s)) hence z ingr Nt(x, r).
Property 2 follows by RINC3 and Property 3 is a corollary to properties
1 and 2. This concludes the argument
⊓⊔
Granule systems deﬁned above form a basis for applications, where approxi-
mate reasoning is a crucial ingredient.
We begin with a basic application in which approximate reasoning itself is
codiﬁed as a many–world (intensional) logic, where granules serve as possible
worlds.
7.6
Reasoning by Granular Rough Mereological Logics
The idea of a granular rough mereological logic, see Polkowski [42], Polkowski
and Semeniuk–Polkowska [53], consists in measuring the meaning of a unary
predicate in the model which is a universe of an information system against

7.6 Reasoning by Granular Rough Mereological Logics
267
a granule deﬁned by means of a rough inclusion. The result can be regarded
as the degree of truth (the logical value) of the predicate with respect to the
given granule. The obtained logics are intensional as they can be regarded as
mappings from the set of granules (possible worlds) to the set of logical values
in the interval [0, 1], the value at a given granule regarded as the extension
at that granule of the generally deﬁned intension.
The problem of meaning in intensional contexts, pointed to by usage of,
e.g., linguistic contexts like ‘he believes that ...’, ‘he knows that...’, ‘he thinks
that....’ for long has attracted the attention of philosophers and logicians, it
suﬃces to mention Immanuel Kant and John Stuart Mill.
Problems that arise here are distinctly illustrated with the well–known ex-
ample of two phrases: ‘the morning star’ and ‘the evening star’. Both describe
the planet Venus in two distinct appearances; once, as the star appearing in
the sky at the sunrise, and secondly, as the star that appears in the sky at
the sunset. One says that both phrases have the same denotation, i.e., the
planet Venus, but distinct meanings. Terms ‘denotation’, ‘meaning’, call for
a precise deﬁnition and a formal mechanism of inference with them.
The problem was addressed by Gottlob Frege [12] in ‘ ¨Uber Sinn und Be-
deutung’, terms usually rendered as sense (Sinn) and reference (Bedeutung).
Thus, phrases ‘the morning star’ and ‘the evening star’ have diﬀerent senses
but the common reference – the planet Venus.
Among later approaches to the problem, we would like to point to that
proposed by Rudolph Carnap [6]. Carnap introduces an important notion
of a state description understood as a logical status of a state and deter-
mined by assignment of truth or falsity to each atomic object of logic. Carnap
calls senses intensions and formalizes them as functions on state descriptions
whereas references, or, denotations, are deﬁned as values of intensions at
particular state descriptions and are called extensions.
In this way, intensions are given a functional character, e.g., ‘the morning
star’ and ‘the evening star’ as intensions describe some various astronomic
objects at various solar systems, but at the Sun solar system, at the planet
Earth, their extension is the same: the planet Venus.
Functional character of intensions was exploited ingeniously in Montague
[34], [35] most notably culminating in His formal model of natural language
grammar, the Montague Grammar, in which hierarchies of functional inten-
sions model the structure of a sentence.
The idea of functionality of intensions has been exploited most famously
in Kripke [19] who produced a semantics for modal logics, cf., Ch. 3, sect.
9: state descriptions have been replaced with possible worlds collected in the
set of possible worlds W and intensions are valuations at possible worlds on
logical variables, the extension at a possible world being the value of a given
variable at that world. Imposing on possible worlds an accessibility relation
R allows for formal deﬁnitions of modal notions of necessity and possibility
in the frame (W, R).

268
7 Reasoning with Rough Inclusions
For a given world w, and a formula φ, one declares φ necessarily true at
w if and only if φ is true at each world w′ accessible from w, i.e., such that
(w, w′) ∈R; similarly, φ is possibly true at w if and only if there exists w′
such that φ is true at w′ and (w, w′) ∈R.
Gallin [13] proposed an axiomatics for intensional logic along with com-
pleteness proof; expositions of intensional and modal logics can be found in
Van Benthem [3], Hughes and Creswell [18] and Fitting [11].
Our approach to rough mereological logics has an intentional tint, as we as-
sume that possible worlds are granules obtained by means of a rough inclusion
μ, and, against these worlds, unary predicates interpreted in the collection of
objects, on which μ is deﬁned, are evaluated as to their degree of truth. Thus,
intensions are functions on granule collection, and extensions are values of
truth at particular granules for particular predicates.
Any attempt at assigning various degrees of truth to logical statements
places one in the realm of many–valued logic. These logics describe formally
logical functors as mappings on the set of truth values/states into itself hence
they operate a fortiori with values of statements typically as fractions or
reals in the unit interval [0, 1], see in this respect, e.g., Lukasiewicz [29], [30],
Lukasiewicz and Tarski [32], and H´ajek [17], see also Ch. 3.
In logics based on implication given by residua of t–norms, negation is
deﬁned usually as ¬x = x ⇒T 0. Thus, the Lukasiewicz negation is ¬Lx =
1−x whereas Goguen’s as well as G¨odel’s negation is ¬Gx = 1 for x=0 and is
0 for x > 0, see Ch. 3. Other connectives are deﬁned with usage of the t–norm
itself as semantics for the strong conjunction and ordinary conjunction and
disjunction are interpreted semantically as, respectively, min, max.
In this approach a rule α ⇒β is evaluated by evaluating the truth state
[[α]] as well as the truth state [[β]] and then computing the values of [[α]] ⇒T
[[β]] for a chosen t–norm T. Similarly other connectives are evaluated.
In the rough set context, this approach would pose the problem of evaluat-
ing the truth state of a conjunct α of descriptors; to this end, one can invoke
the idea of Lukasiewicz [29] and assign to α a value [[α]]L = |{u∈U:u|=α}|
|U|
.
Clearly, this approach does not take into account the logical containment
or its lack between α and β, and this fact makes the many–valued approach
of a small use when data mining tasks are involved.
For this reason, we propose an approach to logic of decision rules which
is based on the idea of measuring the state of truth of a formula against a
concept constructed as a granule of knowledge; concepts can be regarded as
”worlds” and our logic becomes intensional: logical evaluations at a given
world are extensions of the intension which is the mapping on worlds valued
in the set of logical values of truth.
For our purpose it is essential to extend rough inclusions to sets, cf., Ch. 6
sect. 5; we use the t–norm L along with the representation L(r, s) = g(f(r)+
f(s)) already introduced in Ch. 4, sect. 9. We denote rough inclusions on sets
with the generic symbol ν.

7.7 A Logic for Information Systems
269
For ﬁnite sets X, Y , we let,
νL(X, Y, r) ⇔g(|X \ Y |
|X|
) ≥r
(7.7)
As g(x) = 1 −x, we have that νL(X, Y, r) holds if and only if |X∩Y |
|X|
≥r.
Let us observe that νL is regular, i.e., νL(X, Y, 1) if and only if X ⊆Y and
νL(X, Y, r) only with r = 0 if and only if X ∩Y = ∅.
Thus, the ingredient relation associated with a regular rough inclusion is
the improper containment ⊆whereas the underlying part relation is the strict
containment ⊂.
Other rough inclusion on sets which we will use is the 3–valued rough
inclusion ν3 deﬁned via the formula,
ν3(X, Y, r) ⇔
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
X ⊆Y and r = 1
X ∩Y = ∅and r = 0
r = 1
2 otherwise
(7.8)
We now proceed with a construction of the rough mereological logic.
7.7
A Logic for Information Systems
We assume that an information/decision system (U, A, d) is given, along with
a rough inclusion ν on the subsets of the universe U; for a collection of unary
predicates Pr, interpreted in the universe U (meaning that for each predicate
φ ∈Pr the meaning [[φ]] is a subset of U), we deﬁne the intensional logic
GRMν by assigning to each predicate φ in Pr its intension Iν(φ) deﬁned by
its extension I∨
ν (g) at each particular granule g, as
I∨
ν (g)(φ) ≥r ⇔ν(g, [[φ]], r)
(7.9)
With respect to the rough inclusion νL, the formula (7.9) becomes
I∨
νL(g)(φ) ≥r ⇔|g ∩[[φ]]|
|g|
≥r
(7.10)
The counterpart for ν3 is speciﬁed by deﬁnition (7.8), and it comes down to
the following
I∨
ν3(g)(φ) ≥r ⇔
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
g ⊆[[φ]] and r = 1
g ∩[[φ]] ̸= ∅and r ≥1
2
g ∩[[φ]] = ∅and r = 0
(7.11)

270
7 Reasoning with Rough Inclusions
We say that a formula φ interpreted in the universe U of an information
system (U, A) is true at a granule g with respect to a rough inclusion ν if and
only if I∨
ν (g)(φ) = 1.
Hence, for every regular rough inclusion ν, a formula φ interpreted in the
universe U, with the meaning [[φ]] = {u ∈U : u |= φ}, is true at a granule g
with respect to ν if and only if g ⊆[[φ]].
In particular, for a decision rule r : p ⇒q in the descriptor logic, see Ch.
4, the rule r is true at a granule g with respect to a regular rough inclusion
ν if and only if g ∩[[p]] ⊆[[q]]. We state these facts in the following
Proposition 7.10. For every regular rough inclusion ν, a formula φ inter-
preted in the universe U, with the meaning [[φ]], is true at a granule g with
respect to ν if and only if g ⊆[[φ]]. In particular, for a decision rule r : p ⇒q
in the descriptor logic, the rule r is true at a granule g with respect to a regular
rough inclusion ν if and only if g ∩[[p]] ⊆[[q]].
Proof. Indeed, truth of φ at g means that ν(g, [[φ]], 1) which in turn, by
regularity of ν is equivalent to the inclusion g ⊆[[φ]]
⊓⊔
We will say that a formula φ is a tautology of our intensional logic if and only
if φ is true at every world g.
The preceding proposition implies that,
Proposition 7.11. For every regular rough inclusion ν, a formula φ is a
tautology if and only if Cls(G)
⊆[φ], where G is the property of being
a granule; in the case when granules considered cover the universe U this
condition simpliﬁes to [[φ]] = U. This means for a decision rule p ⇒q that
it is a tautology if and only if [[p]] ⊆[[q]].
Hence, the condition for truth of decision rules in the logic GRMν is the same
as the truth of an implication in descriptor logic, see Ch. 4, under caveat that
granules considered cover the universe U of objects.
Our rough mereological intensional logic depends obviously on the chosen
rough inclusion μ on sets – concepts in the universe of objects. We are going
to examine relationships of this logic, in case of two rough inclusions, viz.,
the Lukasiewicz t–norm induced νL and the 3–valued rough inclusion ν3, to
many–valued logics based on the Lukasiewicz residual implication, studied in
Ch. 3. It turns out that in a sense, rough mereological intensional logics are
embedded in, respectively, [0,1]–valued and 3–valued Lukasiewicz logics.
We apply to this end the idea of collapse. Collapse in this case consists in
omitting the variable symbols while preserving connectives and in this way
transforming open formulas of unary predicate calculus into propositional
formulas.We show that theorems of rough mereological intensional logic are
after collapsing them theorems of the respective Lukasiewicz many valued
logic. We also apply a kind of inverse collapse by regarding in the coming
sections formulas of many valued propositional calculus as formulas of unary
predicate calculus with variables omitted.

7.7 A Logic for Information Systems
271
7.7.1
Relations to Many–Valued Logics
We examine some axiomatic schemes for many–valued logics with respect
to their meanings under the stated in introductory section assumption that
[[p ⇒q]] = (U \ [[p]]) ∪[[q]], [[¬p]] = U \ [[p]].
We examine ﬁrst axiom schemes for 3–valued Lukasiewicz logic; we recall,
see Ch. 3, axiom schemes given in Wajsberg [62].
W1 q ⇒(p ⇒q)
W2 (p ⇒q) ⇒((q ⇒r) ⇒(p ⇒r))
W3 ((p ⇒¬p) ⇒p) ⇒p
W4 (¬q ⇒¬p) ⇒(p ⇒q)
We have as meanings of those formulas
[[W1]] = (U \ [[q]]) ∪(U \ [[p]]) ∪[[q]] = U
(7.12)
[[W2]] = ([[p]] \ [[q]]) ∪([[q]] \ [[r]]) ∪(U \ [[p]]) ∪[[r]] = U
(7.13)
[[W3]] = (U \ [[p]]) ∪[[p]] = U
(7.14)
[[W4]] = ([[p]] \ [[q]]) ∪[[q]] = U
(7.15)
It follows that
Proposition 7.12. All instances of Wajsberg axiom schemes for 3–valued
Lukasiewicz logic are tautologies of our intensional logic in case of regular
rough inclusions on sets.
The deduction rule in 3–valued Lukasiewicz logic is Modus Ponens: p,p⇒q
q
.
In our setting this is a valid deduction rule: if p, p ⇒q are tautologies than
q is a tautology. Indeed, if [[p]] = U = [[p ⇒q]], then [[q]] = U.
We have obtained
Proposition 7.13. Each tautology of 3–valued Lukasiewicz logic is a tautol-
ogy of rough mereological granular logic in case of a regular rough inclusion
on sets.
In an analogous manner, we examine axiom schemes for inﬁnite valued
Lukasiewicz logic, proposed by Lukasiewicz, see Lukasiewicz and Tarski [32]
in a form modiﬁed due to Meredith [33] and Chang [7], see Ch. 3, sect. 4
L1 q ⇒(p ⇒q)
L2 (p ⇒q) ⇒((q ⇒r) ⇒(p ⇒r))

272
7 Reasoning with Rough Inclusions
L3 ((q ⇒p) ⇒p) ⇒((p ⇒q) ⇒q)
L4 (¬q ⇒¬p) ⇒(p ⇒q)
As L1 is W1, L2 is W2 and L4 is W4, it remains to examine L3.
In this case, we have
[[(q ⇒p) ⇒p]] = (U \ [[q ⇒p]]) ∪[[p]]) =
(U \ ((U \ [[q]]) ∪[[p]])) ∪[[p]] = ([[q]] \ [[p]]) ∪[[p]] =
[[q]] ∪[[p]]
Similarly,
[[(p ⇒q) ⇒q]]
is
[[p]] ∪[[q]]
by symmetry, and ﬁnally, the meaning [[L3]] is
(U \ ([[q]] ∪[[p]])) ∪[[p]] ∪[[q]] = U
It follows that
Proposition 7.14. All instances of axiom schemes for inﬁnite–valued
Lukasiewicz logic are tautologies of rough mereological granular logic.
As Modus Ponens remains a valid deduction rule in inﬁnite–valued case, we
obtain, analogous to Prop. 7.13,
Proposition 7.15. Each tautology of inﬁnite–valued Lukasiewicz logic is a
tautology of rough mereological granular logic in case of a regular rough in-
clusion on sets.
It follows from Prop.7.15 that all tautologies of Basic logic, see H´ajek [17], cf.,
Ch. 3, sect. 6, i.e., logic which is intersection of all many–valued logics with
implications evaluated semantically by residual implications of continuous t–
norms are tautologies of rough mereological granular logic for each regular
rough inclusion ν.
The assumption of regularity of a rough inclusion ν is essential: considering
the drastic rough inclusion ν1, we ﬁnd that an implication p ⇒q is true only
at the world (U \ [[p]]) ∪[[q]], so it is not any tautology; this concerns all
schemes systems W and L above as they are true only at the global world U.
7.8
A Graded Notion of Truth
As already stated, the usual interpretation of functors ∨, ∧in many–valued
logics is [[p ∨q]] = max{[[p]], [[q]]} and [[p ∧q]] = min{[[p]], [[q]]}, where

7.8 A Graded Notion of Truth
273
[[p]] is the state of truth of p. In case of concept–valued meanings, we admit
the interpretation which conforms to accepted in many valued logics (espe-
cially in the context of fuzzy set theory) interpretation of min as ∩and max
as ∪.
The formula ν(g, [φ], 1) stating the truth of φ at g, ν with ν regular
can be regarded as a condition of orthogonality type, with the usual
consequences.
1. If φ is true at granules g, h, then it is true at g ∪h;
2. If φ is true at granules g, h then it is true at g ∩h;
3. If φ, ψ are true at a granule g, then φ ∨ψ is true at g;
4. If φ, ψ are true at a granule g, then φ ∧ψ is true at g;
5. If ψ is true at a granule g, then φ ⇒ψ is true at g for every formula φ;
6. If φ is true at a granule g then φ ⇒ψ is true at g if and only if ψ is true
at g.
The graded relaxation of truth is given obviously by the condition that a
formula φ is true to a degree at least r at g, ν if and only if
I∨
ν (g)(φ) ≥r
(7.16)
i.e., ν(g, [[φ]], r) holds.
In particular, φ is false at g, ν if and only if I∨
ν (g)(φ) ≥r implies r = 0,
i.e., ν(g, [φ], r) implies r = 0.
Proposition 7.16. The following properties hold with the Lukasiewicz resid-
ual implication ⇒L
1. For each regular ν, a formula α is true at g, ν if and only if ¬α is false at
g, ν;
2. For ν = νL, ν3, I∨
ν (g)(¬α) ≥r if and only if I∨
ν (g)(α) ≥s implies s ≤1−r;
3. For ν = νL, ν3, the implication
α ⇒L β
is true at g if and only if
g ∩[α] ⊆[β]

274
7 Reasoning with Rough Inclusions
and α ⇒L β is false at g if and only if
g ⊆[α] \ [β];
4. For ν = νL, if
I∨
ν (g)(α ⇒L β) ≥r
then ⇒L (t, s) ≥r, where I∨
ν (g)(α) ≥t and I∨
ν (g)(β) ≥s.
Further analysis should be split into the case of νL and the case of ν3 as the
two diﬀer essentially with respect to the form of reasoning they imply.
Property 4 in Proposition 7.16 shows in principle that the value of
I∨
ν (g)(α ⇒β) is bounded from above by the value of I∨
ν (g)(α) ⇒tL I∨
ν (g)(β)).
This suggests that the idea of collapse attributed to Le´sniewski can be
applied to formulas of rough mereological logic in the following form: for
a formula q(x) we denote by the symbol q∗the formula q regarded as a
sentential formula (i.e., with variable symbols removed) subject to relations
1. (¬q(x))∗is ¬(q(x)∗);
2. (p(x) ⇒q(x))∗is p(x)∗⇒q(x)∗.
As the value [[q∗]]g of the formula q(x)∗at a granule g, we take the value
of |g∩[[q(x)]]|
|g|
, i.e, argmaxr{νL(g, [[q∗]]g, r)}. Thus, Property 4 in Proposition
7.16 can be rewritten in the form
I∨
ν (g)(α ⇒β) ≤[α∗]g ⇒L [β∗]g
(7.17)
The statement follows
Proposition 7.17. If α ⇒β is true at g, then the collapsed formula has the
value 1 of truth at the granule g in the Lukasiewicz logic.
This gives a necessity condition for veriﬁcation of implications of rough mere-
ological logics
Proposition 7.18. If [α∗]g ⇒L [β∗]g < 1, then the implication α ⇒β is not
true at g.
This concerns in particular decision rules
Proposition 7.19. A decision rule p(v) ⇒q(v), is true on a granule g if
and only if [[p∗]]g ≤[[q∗]]g.
In case of ν3, one can check on the basis of deﬁnitions that I∨
ν (g)(¬α) ≥r
if and only if I∨
ν (g)(α) ≤1 −r; thus the negation functor in rough mere-
ological logic based on ν3 is the same as the negation functor in the 3–
valued Lukasiewicz logic. For implication, the relations between granular

7.8 A Graded Notion of Truth
275
⇒0 1 1
2
0 1 1 1
1 0 1 1
2
1
2
1
2 1 1
Fig. 7.1 Truth values for implication in L3
⇒
I∨
ν3(g)(q) = 0 I∨
ν3(g)(q) = 1
I∨
ν3(g)(q) = 1
2
I∨
ν3(g)(p) = 0
1
1
1
I∨
ν3(g)(p) = 1
0
1
1
2
I∨
ν3(g)(p) = 1
2
1
2
1
1 when g ∩[α] ⊆[β];
1
2 otherwise
Fig. 7.2 Truth values for implication p ⇒q in logic based on ν3
rough mereological logic and 3–valued logic of Lukasiewicz follow from truth
tables for respective functors of negation and implication.
Table 7.1 shows truth values for implication in 3–valued logic of Lukasiewicz.
We recall that these values obey the implication x ⇒L y = min{1, 1 −x + y}.
Values of x correspond to rows and values of y correspond to columns in the
table of Fig. 7.1.
The table of Fig. 7.2 shows values of implication for rough mereological
logic based on ν3. Values are shown for the extension I∨
ν (g)(p ⇒q) of the
implication p ⇒q. Rows correspond to p, columns correspond to q.
We verify values shown in Fig. 7.2.
First, we consider the case when I∨
ν3(g)(p) = 0, i.e., the case when g∩[[p]] =
∅. As
g ⊆(U \ [[p]]) ∪[[q]]
for every value of [[q]], we have only values of 1 in the ﬁrst row of Table 2.
Assume now that I∨
ν3(g)(p) = 1, i.e., g ⊆[[p]]. As
g ∩(U \ [[p]]) = ∅
the value of I∨
ν (g)(p ⇒q) depends only on a relation between g and [[q]]. In
case
g ∩[[q]] = ∅
the value in Table 2 is 0, in case g ⊆[[q]] the value in Table 2 is 1, and in
case
I∨
ν3(g)(q) = 1
2
the value in Table 2 is 1
2.
Finally, we consider the case when
I∨
ν3(g)(p) = 1
2

276
7 Reasoning with Rough Inclusions
i.e.,
g ∩[[p]] ̸= ∅̸= g \ [[p]]
In case g ∩[[q]] = ∅, we have
g ∩((U \ [[p]]) ∪[[q]]) ̸= ∅
and it is not true that
g ⊆((U \ [[p]]) ∪[[q]])
so the value in table is 1
2.
In case g ⊆[[q]], the value in Table is clearly 1. The case when
I∨
ν3(g)(q) = 1
2
remains. Clearly, when g ∩[[p]] ⊆[[q]], we have
g ⊆(U \ [[p]]) ∪[[q]]
so the value in Table is 1; otherwise, the value is 1
2.
Thus, negation in both logic is semantically treated in the same way,
whereas treatment of implication diﬀers only in case of implication p ⇒q
from the value 1
2 to 1
2, when g ∩[[p]] is not any subset of [[q]].
It follows from these facts that given a formula α and its collapse α∗, we
have,
I∨
ν3(g)(¬α) = [[(¬α)∗]]L3, I∨
ν3(g)(α ⇒β) ≤[[(α ⇒β)∗]]L3
(7.18)
A more exact description of implication in both logics is as follows.
Proposition 7.20. The following statements are true
1. If I∨
nu3(g)(α ⇒β) = 1 then [(α ⇒β)∗]L3 = 1;
2. If I∨
nu3(g)(α ⇒β) = 0 then [(α ⇒β)∗]L3 = 0;
3. If I∨
nu3(g)(α ⇒β) = 1
2 then [(α ⇒β)∗]L3 ≥1
2 and this last value may be
1.
Proof. We oﬀer a simple check–up on Proposition 7.20. In Case 1, we have
g ⊆((U \ [[α]]) ∪[[β]])
For the value of [(α ⇒β)∗], consider some subcases.

7.9 Dependencies and Decision Rules
277
Subcase 1.1 g ⊆U \ [[α]]. Then [[α∗]] = 0 and
[[(α ⇒β)∗]] = [[α∗]] ⇒[[β∗]]
is always 1 regardless of a value of [β∗].
Subcase 1.2 g ∩[[α]] ̸= ∅̸= g \ [[α]] so [α∗] =
1
2. Then g ∩[β] = ∅is
impossible, i.e., [β∗]is at least 1
2 and [(α ⇒β)∗]=1.
Subcase 1.3 g ⊆[[α]] so [[α∗]] = 1; then g ⊆[[β]] must hold, i.e., [[β∗]] = 1
which means that [[(α ⇒β)∗]]=1.
For case 2, we have
g ∩((U \ [[α]]) ∪[[β]]) = ∅
hence, g ∩[[β]] = ∅and g ⊆[[α]], i.e., [α∗] = 1, [β∗] = 0 so [α∗] ⇒[β∗]=0.
In case 3, we have
g ∩((U \ [[α]]) ∪[[β]]) ̸= ∅
and
g ∩[[α]] \ [[β]] ̸= ∅
Can [α∗] ⇒[β∗] be necessarily 0? This would mean that [α∗] = 1 and [β∗] = 0,
i.e., g ⊆[[α]] and g ∩[[β]] = ∅but then
g ∩((U \ [[α]]) ∪[[β]]) = ∅
a contradiction. Thus the value [[α∗]] ⇒[[β∗]] is at least 1
2. In the subcase:
g ⊆[[α]], g∩[[β]] ̸= ∅̸= g\[[β]], the value of [[α∗]] ⇒[[β∗]] is 0 ⇒L 1
2 = 1, and
the subcase is consistent with case 3
⊓⊔
Let us mention that a 3–valued intensional variant of Montague Grammar is
considered in Alves and Guerzoni[1].
7.9
Dependencies and Decision Rules
It is an important feature of rough set theory that it allows for an elegant
formulation of the problem of dependency between two sets of attributes, see
Ch. 4, sect. 4, cf., Pawlak [39], [40], in terms of indiscernibility relations.
We recall, see Ch. 4, sect. 4, that for two sets C, D ⊆A of attributes, one
says that D depends functionally on C when IND(C) ⊆IND(D), symboli-
cally denoted C '→D. Functional dependence can be represented locally by
means of functional dependency rules of the form
φC({va : a ∈C}) ⇒φD({wa : a ∈D})
(7.19)
where φC({va : a ∈C}) is the formula 
a∈C(a = va), and [φC] ⊆[φD].

278
7 Reasoning with Rough Inclusions
A proposition holds
Proposition 7.21. If α : φC ⇒φD is a functional dependency rule, then α
is a tautology of logic induced by ν3.
Proof. For each granule g, we have g∩[[φC]] ⊆[[φD]]
⊓⊔
Let us observe that the converse statement is also true, i.e., if a formula
α : φC ⇒φD is a tautology of logic induced by ν3, then this formula is a
functional dependency rule in the sense of (7.19). Indeed, assume that α is not
any functional dependency rule, i.e., [[φC]] \ [[φD]] ̸= ∅. Taking [[φC]] as the
witness granule g, we have that g is not any subset of [[α]], i.e, I∨
ν3(g)(α) ≤1
2,
so α is not true at g, a fortiori it is not any tautology.
Let us observe that these characterizations are valid for each regular rough
inclusion on sets ν.
A more general and also important notion is that of a local proper
dependency: a formula φC ⇒φD where φC({va : a ∈C}) is the for-
mula 
a∈C(a = va), similarly for φD, is a local proper dependency when
[φC] ∩[φD] ̸= ∅.
We will say that a formula α is acceptable with respect to a collection M
of worlds when
I∨
ν3(g)(α) ≥1
2
(7.20)
for each world g ∈M, i.e, when α is false at no world g ∈M. Then,
Proposition 7.22. If a formula α : φC ⇒φD is a local proper dependency
rule, then it is acceptable with respect to all C–exact worlds.
Proof. Indeed, for a C–exact granule g, the case that I∨
ν3(g)(α) = 0 means
that g ⊆[[φC]] and g ∩[[φD]] = ∅.
As g is C–exact and [[φC]] is a C–indiscernibility class, either [[φC]] ⊆g or
[[φC]] ∩g = ∅. When [[φC]] ⊆g, then [[φC]] = g which makes g ∩[[φD]] = ∅
impossible.
When [[φC]] ∩g = ∅, then g ∩[[φD]] = ∅is impossible. In either case,
I∨
ν3(g)(α) = 0 cannot be satisﬁed with any C–exact granule g
⊓⊔
Again, the converse is true: when α is not local proper, i.e., [[φC]]∩[[φD]] = ∅,
then g = [[φC]] does satisfy I∨
ν3(g)(α) = 0.
A corollary of the same forms follows for decision rules in a given decision
system (U, A, d), i.e., dependencies of the form φC ⇒(d = w).
7.10
An Application to Calculus of Perceptions
Calculus of perceptions, posed as an idea by Zadeh [67], should render for-
mally vague statements and queries, and answer vague questions by giving a
semantic interpretation to vague statements . Here, we apply granular mere-
ological logics toward this problem. To this end, we would like to borrow a

7.10 An Application to Calculus of Perceptions
279
Fig. 7.3 Decision system Age
object n age1 age2 age3 Age
1
3
15
22
30
58
2
3
10
12
16
42
3
2
6
10
−−
30
4
2
24
33
−−
56
5
2
28
35
−−
62
6
3
22
33
40
67
7
2
18
25
−−
60
8
2
26
35
−−
63
9
2
22
38
−−
70
10
3
8
12
16
38
11
2
22
32
−−
58
12
3
24
36
40
63
13
2
28
34
−−
60
14
3
26
30
35
65
15
3
18
25
35
60
16
3
6
12
16
40
17
3
22
30
35
65
18
2
24
34
−−
60
19
3
22
30
34
58
20
2
24
35
−−
62
part of a complex percept in Zadeh [67] and interpret it in terms of granular
logic.
The percept is: (i) Carol has two children: Robert who is in mid–twenties
and Helen who is in mid–thirties with a query (ii) how old is Carol. To
interpret it, we begin with Table 7.3 in which a decision system Age is given
with attributes n – the number of children, ai – the age of the i–th child for
i ≤3, and with the decision age – the age of the mother.
We deﬁne for a fuzzy concept X represented by the fuzzy membership
function μX on the domain DX, the c–cut where c ∈[0, 1] as the concept
XC = {x ∈DX : μX(x) ≥c}. Concepts in mid–twenties, in mid–thirties are
represented by fuzzy membership functions, μ20, μ30, respectively
μ20(x) =
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
0.25(x −20), x ∈[20, 24]
1, x ∈[24, 26]
1 −0.25(x −26), x ∈[26, 30]
(7.21)
and
μ30(x) =
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
0.25(x −30), x ∈[30, 24]
1, x ∈[34, 36]
1 −0.25(x −36), x ∈[36, 40]
(7.22)

280
7 Reasoning with Rough Inclusions
The concept old is interpreted as
μold(x) =
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
0.02(x −30), x ∈[30, 60]
0.04(x −60) + 0.6, x ∈[60, 70]
0, else
(7.23)
We interpret our query by a function q : [0, 1]3 →[0, 1], where f(u, v, w) = t
would mean that for cut levels u, v, t, respectively for old, in mid–twenties,
in mid thirties, the truth value of the statement Carol is at least suppu old
to the degree of t with respect to v, w.
In our example, letting u = 0.6, we obtain old0.6 = [60, 70]; letting
v = 0.5 = w, we obtain in mid twenties0.5 = [23, 27] and in mid thirties0.5 =
[33, 37]. In order to evaluate the truth degree t, we refer to the world
knowledge of Table 7.3 and we ﬁnd the set of objects Λv,w with two
children of ages respectively in the intervals [23, 27], [33, 37] correspond-
ing to values of v, w as well as the set of objects Γu having the value of
Age in oldu. In our case we have Λ0.5,0.5 = {4, 8, 12, 18, 20} and Γ0.6 =
{5, 6, 7, 8, 9, 12, 13, 14, 15, 17, 18, 20}.
Finally, we evaluate the truth degree of the predicate in old0.6(x) repre-
sented in the universe of Table 7.3 by the set Γ0.6 with respect to the granule
Λ0.5,0.5. We obtain by applying the Lukasiewicz rough inclusion μL,
(IμL
Λ0.5,0.5)∨(old0.6(x)) = |Λ0.5,0.5 ∩Γ0.6|
|Λ0.5,0.5|
= 0.8
(7.24)
The result is the statement: Carol is over 60 years old to degree of 0.8 under
the assumed interpretation of
in mid twenties0.5, in mid thirties0.5 with
respect to knowledge in Table 7.3.
7.11
Modal Aspects of Rough Mereological Logics
Modal logics are concerned with formal rendering of modalities of necessity
and possibility. Possible world semantics (Kripke semantics) is set in terms
of a set W of possible worlds endowed with an accessibility relation R: in
case (w, w′) ∈R, one says that the world w′ is accessible from the world w.
In case of propositional calculus, intensions are valuations on propositional
variables: for each world w and a variable p, a valuation val assigns the truth
value val(p, g) (True or False). This assignment extends by standard logical
calculations to formulas, giving for each formula φ and a world w, the value
val(φ, w), see Ch. 3, sect. 9.
Necessity is introduced by the requirement that a formula φ is necessarily
trueat a world w if and only if φ is true at every world w′ accessible from w
via R. Possibility is deﬁned as the requirement that φ is possibly true at w if
and only if there is w′ accessible from w via R with φ true at w′. A formula

7.11 Modal Aspects of Rough Mereological Logics
281
φ is true at the frame (W, R) if and only if it is true at each world w ∈W,
and φ is true if and only if it is true at each frame.
A hierarchy of modal logics is built by demanding that they satisfy some
postulates about the nature of necessity and possibility, see Hughes and
Creswell [18], or, Lemmon and Scott [20].
Necessity is denoted with L and Lφ reads necessarily φ, possibility is de-
noted with M and Mφ reads possibly φ.
A basic postulate going back to Aristotle, cf., Lukasiewicz [31] is that
necessity of an implication along with the necessity of the premise implies
necessity of the conclusion, expressed by means of a formula (K),
(K) L(φ ⇒ψ) ⇒(Lφ ⇒Lψ)
(7.25)
It is well–known, see Ch. 3, sect. 9, that (K) is true at every frame regardless
of the relation R.
The system in which (K) is satisﬁed is denoted as the system K.
The next postulate concerns the nature of necessity L and is expressed
with a formula (T)
(T ) Lφ ⇒φ
(7.26)
The formula (T) is satisﬁed in every frame in which the relation R is reﬂexive;
the system K with (T) added is denoted T .
As a next step usually the formula (S4) is added to the system T
(S4) Lφ ⇒LLφ
(7.27)
(S4) is true in every frame in which the relation R is transitive; the system S4
in which K, T, S4 hold is satisﬁed in every frame with the relation R reﬂexive
and transitive.
The postulate (S5) establishes a relation between L and M
(S5) Mφ ⇒LMφ
(7.28)
The system S5 resulting from adding (S5) to the system S4 is valid in all
frames in which the relation R is an equivalence.
7.11.1
A Modal Logic with Ingredient Accessibility
In an attempt at expressing modalities aﬀorded by the rough mereological
context, we reach to the relation of an ingredient as an accessibility relation.
Thus, we adopt the collection of granules induced by a rough inclusion μ as
the set W of possible worlds, and the relation R(g, h) ⇔ingr(h, g), i.e., a
world (granule) h is accessible via R from a world (granule) g if and only
if h is an ingredient of g, where the relation of an ingredient on granules is
induced from the relation of ingredient on objects by means of (7.4).

282
7 Reasoning with Rough Inclusions
For a predicate α, and a granule g, it follows that α is necessarily true at
g if and only if α is true at every ingredient h of g, which means that, for a
regular rough inclusion ν on sets, that [[h]] ⊆[[α]] for each ingredient h of g.
Possibility of α at g means that there exists a granule h with ingr(h, g) such
that α is true at h, i.e., [[h]] ⊆[[g]].
As ingredient relation is reﬂexive and transitive, we have
Proposition 7.23. The modal logic obtained by taking the ingredient relation
on granules as accessibility relation r and granules of knowledge as possible
worlds W satisﬁes requirements for the system S4 in the frame (W, R).
7.11.2
Modal Logic of Rough Set Approximations
Possibility and necessity are introduced in rough set theory by means of
approximations: the upper and the lower, respectively. A logical rendering
of these modalities in rough mereological logics exploits the approximations.
We deﬁne two modal operators: M (possibility) and L (necessity).
To this end, we let

I∨
ν (g)(Mα) ≥r ⇔νL(g, [α], r)
I∨
ν (g)(Lα) ≥r ⇔νL(g, [α], r)
(7.29)
Then we have the following criteria for necessarily or possibly true formulas.
A formula α is necessarily true at a granule g if and only if g ⊆[α]; α is
possibly true at g if and only if g ⊆[[α]].
This semantics of modal operators M, L can be applied to show that rough set
structures carry the semantics of S5 modal logics, i.e., the following relations
hold at each granule g.
1. L(α ⇒β) ⇒[(Lα) ⇒L(β)];
2. Lα ⇒α;
3. Lα ⇒LLα;
4. Mα ⇒LMα.
We need to show that the meaning of each of formulas 1–4 is U.
Concerning formula 1 (modal formula (K)), we have [[L(α ⇒β) ⇒(Lα) ⇒
L(β)]]=(U \ (U \ [[α]]) ∪[[β]]) ∪(U \ [[α]]) ∪[[β]].
Assume that u /∈(U \[[α]])∪[[β]]; thus, (i) [u]A ⊆[[α]] and (ii) [u]A∩[[β]] =
∅. If it were u ∈(U \ [[α]]) ∪[[β]] then we would have [u]A ⊆(U \[[α]])∪[[β]],
a contradiction with (i), (ii). Thus, the meaning of (K) is U.

7.12 Reasoning in Multi–agent and Distributed Systems
283
For formula 2, modal formula (T), we have [[Lα ⇒α]]=((U \ [[α]])∪[[α]]);
as [[α]] ⊆[[α]], it follows that the meaning of (T) is U.
In case of formula 3, modal formula (S4), the meaning is (U \ [[α]]) ∪
[[α]]=(U \ [[α]]) ∪[[α]]= U.
The meaning of formula 4, modal formula (S5), is (U \ [[α]]) ∪[[α]]=(U \
[[α]]) ∪[[α]]=U.
It follows that the logic S5 is satisﬁed within logic induced by νL and
more generally in logic induced by any regular rough inclusion ν.
7.12
Reasoning in Multi–agent and Distributed
Systems
Approximate reasoning is often concerned with ‘complex cases’ like, e.g.,
robotic soccer, in which performing successfully tasks requires participation
of a number of ‘agents’ bound to cooperate, and in which a task is performed
with a number of steps, see, e.g., Stone [60]; other areas where such approach
seems necessary concern assembling and design, see Amarel [2], fusion of
knowledge, e.g., in robotics, fusion of information from sensors, see, e.g.,
Canny [5], Choset et al. [8], or, Stone [60], as well as in machine learning and
fusion of classiﬁers, see, e.g., Dietterich [10].
Rough mereological approach to these problems was initiated with Polkow-
ski and Skowron [54] – [57] and here we give these topics a logical touch.
Rough inclusions and granular intensional logics based on them can be
applied in describing workings of a collection of intelligent agents which are
called here granular agents.
A granular agent a will be represented as a tuple
(Ua, μa, La, propa, synta, aggra)
where
1. Ua is a collection of objects available to the agent a;
2. μa is a rough inclusion on objects in Ua;
3. La is a set of unary predicates in ﬁrst–order open calculus, interpretable
in Ua;
4. propa is the propagation function that describes how uncertainty expressed
by rough inclusions at agents connected to a propagates to a;

284
7 Reasoning with Rough Inclusions
5. synta is the logic propagation functor which expresses how formulas of log-
ics at agents connected to the agent a are made into a formula at a;
6. aggra is the synthesis function which describes how objects at agents con-
nected to a are made into an object at a.
We assume for simplicity that agents are arranged into a rooted tree; for
each agent a distinct from any leaf agent, we denote by Ba the children of
a, understood as agents connected to a and directly sending to a objects,
logical formulas describing them, and uncertainty coeﬃcients like values of
rough inclusions.
For b ∈Ba, the symbol xb will denote an object in Ub; similarly, φb will
denote a formula of Lb, and μb will be a rough inclusion at b with values rb.
The same convention will be obeyed by objects at a.
Our scheme should obey some natural postulates stemming from an assump-
tion of regularity of reasoning.
MA1 If ingrb(x′
b, xb) for each b ∈Ba, then ingra(aggr({x′
b}), aggr({xb})
This postulate does assure that ingredient relations are in agreement with
aggregate operator of forming complex objects: ingredients of composed ob-
jects form an ingredient of a complex object. We can say that aggr ◦ingr =
ingr ◦aggr, i.e, the resulting diagram commutes.
MA2 If xb |= φb, then aggr({xb}) |= synt({φb})
This postulate is about agreement between aggregation of objects and their
logical descriptions: descriptions of composed objects merge into a descrip-
tion of the resulting complex object.
MA3 If μb(xb, yb, rb) for b ∈Ba, then μa(aggr({xb}), aggr({yb}), prop{rb})
This postulate introduces the propagation function, which does express how
uncertainty at connected agents is propagated to the agent a. One may ob-
serve the uniformity of prop, which in the setting of MA3 depends only on
values of rb’s; this is undoubtedly a simplifying assumption, but we want to
avoid unnecessary and obscuring the general view complications, which of
course can be multiplied at will.
For Archimedean or metric induced rough inclusions μ, in whose cases
gμ(u, r) = {v : μ(v, u, r)}, see Proposition 7.1, in this chapter, MA3 induces
an aggregation operator on granules
MA4 For b ∈Ba, ingrb(xb, gmur(ub, rb)) implies
ingra(aggr({xb}), gμa(aggr({ub}), prop({rb}))

7.12 Reasoning in Multi–agent and Distributed Systems
285
Admitting MA4, we may also postulate that in case agents have at their
disposal variants of rough mereological granular logics, intensions propagate
according to the prop functor
MA5 If I∨
νb(gb)(φb) ≥rb for each b ∈Ba, then
I∨
νa(aggr({gb}))(synt({φb})) ≥prop({rb}))
Here, we abuse language a bit, as we write prop in the same form as in MA3,
again, it is done for simplicity of exposition.
We examine, for example’s sake, a simple case of knowledge fusion, cf.,
Polkowski [52].
Proposition 7.24. We consider an agent a ∈Ag and – for simplicity rea-
sons – we assume that a has two incoming connections from agents b, c; the
number of outgoing connections is of no importance as a sends along each of
them the same information. Thus, Ba = {b, c}.
We assume that each agent is applying the rough inclusion μ = μL induced by
the Lukasiewicz t–norm L in the frame of the respective information system
(Ua, Aa), (Ub, Ab), (Uc, Ac). Each agent is also applying the rough inclusion
on sets of the form (7.7) in evaluations related to extensions of formulae in-
tensions.
We consider a simple fusion scheme in which information systems at b, c are
combined object–wise to make the information system at a; thus, aggra(x, y) =
(x, y). Such case may happen, e.g., when an object is described with help of a
camera image by some features and at the same time it is perceived and recog-
nized with range sensors like infrared or laser sensors and some localization
means like GPS.
Then: uncertainty propagation and granule propagation are described by
the Lukasiewicz t–norm L and extensions of logical intensions propagate ac-
cording to the product t–norm P.
Proof. The set Aa of attributes at a equals then Ab × Ac, i.e., attributes in
Aa are pairs (a1, a2) with a1 ∈Ab and a2 ∈Ac, and a fortiori, the value of
this attribute is deﬁned as
(a1, a2)(x, y) = (a1(x), a2(y))
It follows that the condition holds
INDa(aggra(x, y), aggra(x′, y′)) ⇔INDb(x, x′) and INDc(y, y′)
(7.30)
Concerning the function propa, we consider objects x, x′, y, y′; clearly,
DISa(aggra(x, y), aggra(x′, y′))
(7.31)

286
7 Reasoning with Rough Inclusions
is contained (as a subset) in
DISb(x, x′) × Ac ∪Ab × DISc(y, y′)
(7.32)
It follows by (7.31), (7.32) that
|DISa(aggra(x, y), aggra(x′, y′))|
(7.33)
is less or at most equal to
|DISb(x, x′)| · |Ac| + |Ab| · |DISc(y, y′)|
(7.34)
As we know
μa(aggra(x, y), aggra(x′, y′), t)
(7.35)
is satisﬁed with the maximal value of t equal to
1 −|DISa(aggra(x, y), aggra(x′, y′))|
|Ab| · |Ac|
(7.36)
As the value of
|DISa(aggra(x, y), aggra(x′, y′))|
|Ab| · |Ac|
(7.37)
in the left–side of (7.36) is not less than
|DISb(x, x′)| · |Ac| + |Ab| · |DISc(y, y′)|
|Ab| · |Ac|
(7.38)
which in turn is not less than
(|DISb(x, x′)|
|Ab|
+ |DISc(y, y′)|
|Ac|
+ 1 −1
(7.39)
it follows that
1 −|DISa(aggra(x, y), aggra(x′, y′))|
|Ab| · |Ac|
(7.40)
is greater or equal to
(1 −|DISb(x, x′)|
|Ab|
) + (1 −|DISc(y, y′)|
|Ac|
) −1
(7.41)
which is equivalent to
L(max{r : μb(x, x′, r}, max{s : μc(y, y′, s})
(7.42)
We have
Claim
If μb(x, x′, r) and μc(y, y′, s), then

7.12 Reasoning in Multi–agent and Distributed Systems
287
μa(aggra(x, y), aggra(x′, y′), L(r, s))
It follows that the propagation function prop is deﬁned by the Lukasiewicz
t–norm: prop(r, s) = L(r, s) = max{0, r + s −1}.
In consequence, the granule propagation functor propg
a can be deﬁned in
our example as indicated by the following equation
propa(gμb(xb, rb), gμc(yc, sc)) = (gμa(aggra(xb, yc), L(rb, sc))
(7.43)
The logic synthesizer synta is deﬁned by our assumptions as
synta(φb, φc) = φb ∧φc
(7.44)
Finally, we consider extensions of our logical operators of intensional logic.
We have for the extension
I(μa)∨
propg
a(gb,gc)(synta(φb, φc))
(7.45)
that it is equal to
I(μb)∨
gb(φb) · I(μc)∨
gc(φc)
(7.46)
i.e., it is the deﬁned by the product t–norm P
⊓⊔
In such schemes one can discuss synthesis processes: when agents are arranged
in a tree T , synthesis over T consists in outputting at the root agent root(T )
an object xT . A characterization of xT can be given by a postulate that it
falls into a granule about a speciﬁed standard sT within a radius of rT .
Aggregation operators of agents aggra for non–leaf agents a,compose into
a global aggregate operator aggrT , which sends objects chosen at leaf agents,
at most one for each agent, into an object at the root of T . In a similar vein,
propagation operators propa compose into the global propagation operator
propT .
The synthesis procedure could be presented as
Input: gμT (st, rT)
1. Find recursively going down the tree to leaf agents: in each leaf agent bl,
an object sl such that
aggrT({sl}) = sT
(7.47)
2. Find recursively radii rl at leaf agents which satisfy the condition that,
propT ({rl}) ≥rT
(7.48)

288
7 Reasoning with Rough Inclusions
3. For each leaf agent bl, ﬁnd an object xl with the property that,
μl(xl, sl, rl) for each leaf agent bl
(7.49)
4. Output the object aggrT({xl}).
This reasoning scheme seems fairly universal also for networking schemes
of reasoning like in neural networks. However, as learning in neural networks
is usually based on the idea of gradient search, and in consequence it re-
quires diﬀerentiable rough inclusions, we devote to neural network reasoning
a separate paragraph.
7.13
Reasoning in Cognitive Schemes
Neural networks are motivated by the functioning of neural system. Their
inception was possible due to achievements of neurophysiology, notably, dis-
covery of the structure of the biological neuron by Ram´on y Cajal [58].
On this discovery, McCulloch and Pitts [9] built their model of a computing
machine called now McCulloch–Pitts neuron. In its simplest form, it consisted
of a cell endowed with a threshold Θ, and inputs x1, x2, ..., xn through which
binary signals of 0 or 1 could be sent. The one output y could issue a binary
signal of either 0 or 1. Inputs are counterparts to the biological synapses, and
the output models the biological axon.
Computation by the neuron is governed by the rule
y =

1 in case 
i xi ≥Θ
0 otherwise
(7.50)
Thus, the neuron ﬁres when the summary input exceeds the threshold, oth-
erwise the neuron remains inactive.
The neuron of McCulloch–Pitts can produce a binary linear classiﬁer: the
separating hyper–plane, which is to divide the training set into positive and
negative examples, is of the form

i
xi = Θ
(7.51)
The idea of networks of neurons was advocated by Alan Turing [61] who
proposed a learning scheme for networks of neurons connected through mod-
iﬁers.
Increasing classiﬁcation possibilities were given a neuron with the idea
of a perceptron due to Rosenblatt [59]. A simpliﬁed perceptron adds to
McCulloch–Pitts neuron weights on inputs, and an additional input with
constant value of 1 and a weight b, called bias. Thus, the classifying hyper–
plane has the form

7.13 Reasoning in Cognitive Schemes
289

i
wi · xi + b = Θ
(7.52)
Parameters wi, b, Θ which can be varied, allow for learning. As proved by
Novikoﬀ[38], if a binary concept can at all be classiﬁed with the hyperplane
of the form (7.52), then it is possible to ﬁnd in a ﬁnite number of steps of the
learning procedure a proper set of parameters starting from, e.g., a randomly
chosen set.
The idea of a network of perceptrons returned with Grossberg [14]; it was
shown that a network of perceptrons can classify, hence learn, any Boolean
function.
A further step in improving eﬃciency of computation and learning of
perceptron networks was due to Bryson and Ho [4]: replacement of the
Heaviside–type threshold function with a sigmoid–type diﬀerentiable func-
tion allowed for supervised learning by means of the gradient search, called
the backpropagation, based on computing the gradient of the error function
E(w) = 
xj(yj −tj)2, where w is the vector of weights on all connections
in the network, xj are consecutive input examples, yj are corresponding re-
sponses of the network, and tj are desired outputs to inputs xj.
We would like to endow neurons with intelligence based on rough mere-
ological reasoning, see Polkowski [44]. In neural models of computation, an
essential feature of neurons is diﬀerentiability of transfer functions; hence, we
introduced a special type of rough inclusions, called gaussian in Polkowski
[44] because of their form, by letting,
μG(x, y, r) iﬀe−| 
a∈DIS(x,y) wa|2 ≥r
(7.53)
where wa ∈(0, +∞) is a weight associated with the attribute a for each
attribute a ∈A.
Let us observe in passing that μG can be factored through the indiscerni-
bility relation IND(A), and thus its arguments can be objects as well as
indiscernibility classes; we will freely use this fact.
Properties of gaussian rough inclusions are, see Polkowski [44]
Proposition 7.25. The following hold for each gaussian rough inclusion μG,
where ingr is the ingredient relation associated with μG by postulate RINC1,
Ch. 5, sect. 2,
1. ingr(x, y) if and only if DIS(x, y) = ∅;
2. There exists a function η(r, s) such that μG(x, y, r), μG(y, z, s) imply μG(x,
z, t) with t ≤η(r, s));
3. If ingr(x, gμG(y, r) and ingr(x, gμG(z, s), then ingr(gμG(x, t), gμG(y, r)),
ingr(gμG(x, t), gμG(z, s)) for t ≥max{r4, s4}.

290
7 Reasoning with Rough Inclusions
Proof. Property 1 follows by deﬁnition 7.25.
To verify Property 2, we observe that by deﬁnition (7.25), we have

a∈DIS(x,y)
wa ≤(−logr)
1
2
(7.54)
and

a∈DIS(y,z)
wa ≤(−logs)
1
2
(7.55)
As DIS(x, z) ⊆DIS(x, y) ∪DIS(y, z), we denote by t the maximum value
of q such that μG(x, z, q), and we obtain that
(−logt)
1
2 ≤(−logr)
1
2 + (−logs)
1
2
(7.56)
from which by taking squares of both sides, we get at
logt ≤log(r · s) −2(logr · logs)
1
2
(7.57)
so ﬁnally
t ≤r · s · e−2(logr·logs)
1
2
(7.58)
Thus, it suﬃces to take η(r, s) = r · s · e−2(logr·logs)
1
2 .
In case of Property 3, we observe that as μG is symmetric by deﬁnition and
transitive by Property 2, we have ingr(x, gmuG(y, r)) ⇔μG(x, y, r). Hence, in
order to verify Property 3, we have to ﬁnd t such that η(r, t) ≥r, η(s, t) ≥s.
As η(r, t) ≥r implies t ≥r4, it suﬃces to have t ≥max{r4, s4} to satisfy
both conditions
⊓⊔
7.13.1
Rough Mereological Perceptron
The rough mereological perceptron is modeled on the perceptron, and it
consists of an intelligent agent a, endowed with a gaussian rough inclusion
μa on the information system Ia = (Ua, Aa) of the agent a.
The input to a is in the form of a ﬁnite tuple x = (x1, ..., xk) of objects,
and the input x is converted at a into an object x = aggra(x) ∈Ua by means
of an operator aggra.
The rough mereological perceptron is endowed with a set of target concepts
Ta ⊆Ua/IND(Aa), each target concept a class of the indiscernibility INDa.
Formally, a rough mereological perceptron is thus a tuple
RMP = (a, Ia, μa, aggra, Ta)
Computing by a network of RMP’s, is directed by the gradient of the error
function, which in this case has the form of the gradient of the function

7.13 Reasoning in Cognitive Schemes
291
f(x, y) = e−| 
a∈DIS(x,y) wa|2
(7.59)
which is
∂f
∂w = f · (−2 ·

wa)
(7.60)
It follows from the last equation that gradient search would go in direction
of minimizing the value of 
a wa.
The result of computation with a target gμG(t, r) for a a sample x1, ..., xk
is a granule g = gμG(aggra(x1, .., xk), r(res)) such that ingr(g, gμG(t, r)).
During computation, weights are incremented according to the ideology of
backpropagation, by the recipe,
wa ←wa + Δ · ∂E
∂wa
(7.61)
where Δ is the learning rate.
At a stage current of computing, where γ = rcurrent −r, for a natural
number k, the value of Δcurrent which should be taken at the step current
in order to achieve the target in at most k steps should be taken as, see
Polkowski [44]
Δcurrent ≃
γ
2 · k · f 2 · (
a wa)2
(7.62)

References
1. Alves, E.H., Guerzoni, J.A.D.: Extending Montague’s system: A three–valued
intensional logic. Studia Logica 49, 127–132 (1990)
2. Amarel, S.: Panel on AI and Design. In: Proceedings of 12th Intern. Conf. on
AI, Sydney, pp. 563–565 (1991)
3. Van Benthem, J.: A Manual of Intensional Logic. CSLI Stanford University,
Stanford (1988)
4. Bryson, A.E., Yu–Chi, H.: Applied Optimal Control: Optimization, Estimation
and Control. Blaisdell Publishing Company, Waltham (1969)
5. Canny, J.F.: The Complexity of Robot Motion Planning. MIT Press, Cambridge
(1988)
6. Carnap, R.: Necessity and Meaning. Chicago University Press, Chicago (1947)
7. Chang, C.C.: Proof of an axiom of Lukasiewicz. Trans. Amer. Math. Soc. 87,
55–56 (1958)
8. Choset, H., Lynch, K.M., Hutchinson, S., Kantor, G., Burgard, W., Kavraki,
L.E., Thrun, S.: Principles of Robot Motion. Theory, Algorithms, and Imple-
mentations. MIT Press, Cambridge (2005)
9. McCulloch, W., Pitts, W.: A logical calculus of the ideas immanent in nervous
activity. Bulletin of Mathematical Biophysics 7, 115–133 (1943)
10. Dietterich, T.G.: Ensemble Methods in Machine Learning. In: Kittler, J., Roli,
F. (eds.) MCS 2000. LNCS, vol. 1857, pp. 1–15. Springer, Heidelberg (2000)
11. Fitting, M.C.: First–order intensional logic. Annals of Pure and Applied
Logic 127, 171–193 (2004)
12. Frege,
G.:
¨Uber Sinn
und Bedeutung. Zeitschrift
f¨ur
Philosophie
und
Philosophische Kritik NF 100, 25–50 (1892)
13. Gallin, D.: Intensional and higher–order modal logic. North Holland, Amster-
dam (1975)
14. Grossberg, S.: Contour enhancement, short–term memory, and constancies in
reverberating neural networks. Studies in Applied Mathematics 52, 213–257
(1973)
15. Grzymala-Busse, J.W.: Data with missing attribute values: Generalization
of indiscernibility relation and rule induction. In: Peters, J.F., Skowron,
A., Grzymala-Busse, J.W., Kostek, B.z., ´Swiniarski, R.W., Szczuka, M.S.
(eds.) Transactions on Rough Sets I. LNCS, vol. 3100, pp. 78–95. Springer,
Heidelberg (2004)
16. Grzymala-Busse, J.W., Hu, M.: A Comparison of Several Approaches to Miss-
ing Attribute Values in Data Mining. In: Ziarko, W.P., Yao, Y. (eds.) RSCTC
2000. LNCS (LNAI), vol. 2005, pp. 378–385. Springer, Heidelberg (2001)

References
293
17. H´ajek, P.: Metamathematics of Fuzzy Logic. Kluwer, Dordrecht (2001)
18. Hughes, G.E., Creswell, M.J.: A New Introduction to Modal Logic. Routledge,
London (1996)
19. Kripke, S.: Semantical considerations on modal logics. Acta Philosophica Fen-
nica. Modal and Many–Valued Logics, pp. 83–94 (1963)
20. Lemmon, E.J., Scott, D.S., Sederberg, K. (eds.): The Lemmon Notes. An In-
troduction to Modal Logic. Basil Blackwell, Oxford (1963)
21. Lin, T.Y.: Neighborhood systems and relational database. Abstract. In: Pro-
ceedings of CSC 1988, p. 725 (1988)
22. Lin, T.Y.: Neighborhood systems and approximation in Database and Knowl-
edge Based Systems. In: Proceedings of the 4th International Symposium on
Methodologies for Intelligent Systems (ISMIS), pp. 75–86 (1989)
23. Lin, T.Y.: Topological and fuzzy rough sets. In: Slowi´nski, R. (ed.) Intelligent
Decision Support. Handbook of Applications and Advances of the Rough Sets
Theory, pp. 287–304. Kluwer, Dordrecht (1992)
24. Lin, T.Y.: From rough sets and neighborhood systems to information granula-
tion and computing with words. In: Proceedings of the European Congress on
Intelligent Techniques and Soft Computing, pp. 1602–1606 (1994)
25. Lin, T.Y.: Granular Computing: Fuzzy logic and rough sets. In: Zadeh, L.A.,
Kacprzyk, J. (eds.) Computing with Words in Information/Intelligent Systems,
vol. 1, pp. 183–200. Physica Verlag, Heidelberg (1999)
26. Lin, T.Y.: Granular computing. In: Wang, G., Liu, Q., Yao, Y., Skowron, A.
(eds.) RSFDGrC 2003. LNCS (LNAI), vol. 2639, pp. 16–24. Springer, Heidel-
berg (2003)
27. Lin, T.Y.: Granular computing: Examples, intuitions, and modeling. In:
Proceedings of IEEE 2005 Conference on Granular Computing GrC 2005,
pp. 40–44. IEEE Press, Beijing (2005)
28. Lin, T.Y.: A roadmap from rough set theory to granular computing. In: Wang,
G.-Y., Peters, J.F., Skowron, A., Yao, Y. (eds.) RSKT 2006. LNCS (LNAI),
vol. 4062, pp. 33–41. Springer, Heidelberg (2006)
29. Lukasiewicz, J.: Die Logischen grundlagen der Wahrscheinlichtkeitsrechnung.
Cracow (1913)
30. Lukasiewicz, J.: O logice tr´ojwarto´sciowej (On three–valued logic, in Polish).
Ruch Filozoﬁczny 5, 170–171 (1920)
31. Lukasiewicz, J.: Aristotle’s Syllogistic from the Standpoint of Modern Formal
Logic, 2nd edn. Oxford University Press, Oxford (1957)
32. Lukasiewicz, J., Tarski, A.: Untersuchungen ueber den Aussagenkalkuels. C.R.
Soc. Sci. Lettr. Varsovie 23, 39–50 (1930)
33. Meredith, C.A.: The dependence of an axiom of Lukasiewicz. Trans. Amer.
Math. Soc. 87, 54 (1958)
34. Montague, R.: Pragmatics and intensional logic. Synthese 22, 68–94 (1970)
35. Montague, R., Thomason, R. (eds.): Formal Philosophy. Yale University Press,
New Haven (1974)
36. Nguyen, S.H.: Regularity analysis and its applications in Data Mining. In:
Polkowski, L., Tsumoto, S., Lin, T.Y. (eds.) Rough Set Methods and Applica-
tions. New Developments in Knowledge Discovery in Information Systems, pp.
289–378. Physica Verlag, Heidelberg (2000)
37. Nieminen, J.: Rough tolerance equality and tolerance black boxes. Fundamenta
Informaticae 11, 289–296 (1988)

294
References
38. Novikoﬀ, A.B.: On convergence proofs on perceptrons. In: Symposium on the
Mathematical Theory of Automata, vol. 12, pp. 615–622. Brooklyn Polytechnic
Institute, New York (1962)
39. Pawlak, Z.: Rough sets. Intern. J. Comp. Inform. Sci. 11, 341–366 (1982)
40. Pawlak, Z.: Rough Sets: Theoretical Aspects of Reasoning about Data. Kluwer,
Dordrecht (1991)
41. Polkowski, L.: A rough set paradigm for unifying rough set theory and fuzzy
set theory. In: Wang, G., Liu, Q., Yao, Y., Skowron, A. (eds.) RSFDGrC 2003.
LNCS (LNAI), vol. 2639, pp. 70–78. Springer, Heidelberg (2003)
42. Polkowski, L.: A note on 3–valued rough logic accepting decision rules. Funda-
menta Informaticae 61, 37–45 (2004)
43. Polkowski, L.: Toward rough set foundations. Mereological approach. In:
Tsumoto, S., Slowi´nski, R., Komorowski, J., Grzymala-Busse, J.W. (eds.)
RSCTC 2004. LNCS (LNAI), vol. 3066, pp. 8–25. Springer, Heidelberg (2004)
44. Polkowski, L.: A rough–neural computation model based on rough mereology.
In: Pal, S.K., Polkowski, L., Skowron, A. (eds.) Rough–Neural Computing.
Techniques for Computing with Words, pp. 85–108. Springer, Heidelberg (2004)
45. Polkowski, L.: Formal granular calculi based on rough inclusions. In: Proceed-
ings of IEEE 2005 Conference on Granular Computing GrC 2005, pp. 57–62.
IEEE Computer Society Press, Beijing (2005)
46. Polkowski, L.: Rough–fuzzy–neurocomputing based on rough mereological cal-
culus of granules. International Journal of Hybrid Intelligent Systems 2, 91–108
(2005)
47. Polkowski, L.: A model of granular computing with applications. In: Proceed-
ings of IEEE 2006 Conference on Granular Computing GrC 2006, pp. 9–16.
IEEE Computer Society Press, Atlanta (2006)
48. Polkowski, L.: Granulation of knowledge in decision systems: The approach
based on rough inclusions. The method and its applications. In: Kryszkiewicz,
M., Peters, J.F., Rybi´nski, H., Skowron, A. (eds.) RSEISP 2007. LNCS (LNAI),
vol. 4585, pp. 69–79. Springer, Heidelberg (2007)
49. Polkowski, L.: The paradigm of granular rough computing. In: Proceedings
of 6th IEEE Intern. Conf. on Cognitive Informatics, ICCI 2007, pp. 145–163.
IEEE Computer Society, Los Alamitos (2007)
50. Polkowski, L.: Rough mereology in analysis of vagueness. In: Wang, G., Li,
T., Grzymala-Busse, J.W., Miao, D., Skowron, A., Yao, Y. (eds.) RSKT 2008.
LNCS (LNAI), vol. 5009, pp. 197–204. Springer, Heidelberg (2008)
51. Polkowski, L.: A uniﬁed approach to granulation of knowledge and granular
computing based on rough mereology: A survey. In: Pedrycz, W., Skowron, A.,
Kreinovich, V. (eds.) Handbook of Granular Computing, pp. 375–400. John
Wiley and Sons Ltd., Chichester (2008)
52. Polkowski, L.: Granulation of Knowledge: Similarity Based Approach in Infor-
mation and Decision Systems. In: Meyers, R.A. (ed.) Springer Encyclopedia of
Complexity and System Sciences, Springer, Berlin (2009) article 00 788
53. Polkowski, L., Semeniuk–Polkowska, M.: On rough set logics based on similarity
relations. Fundamenta Informaticae 64, 379–390 (2005)
54. Polkowski, L., Skowron, A.: Rough mereological foundations for design, anal-
ysis, synthesis and control in distributed systems. Information Sciences. An
International Journal 104(1-2), 129–156 (1998)

References
295
55. Polkowski, L., Skowron, A.: Grammar systems for distributed synthesis of of
approximate solutions extracted from experience. In: Paun, G., Salomaa, A.
(eds.) Grammatical models of Multi-Agent Systems, pp. 316–333. Gordon and
Breach, Amsterdam (1999)
56. Polkowski, L., Skowron, A.: Towards adaptive calculus of granules. In: Zadeh,
L.A., Kacprzyk, J. (eds.) Computing with Words in Information/Intelligent
Systems 1. Foundations, Physica Verlag, Heidelberg (1999)
57. Polkowski, L., Skowron, A.: Rough mereological calculi of granules: A rough
set approach to computation. Computational Intelligence. An Intern. Jour-
nal 17(3), 472–492 (2001)
58. Ram´ony Cajal, S.: Sur la morphologie et les connexions des elements de la
retine des oiseaux. Anatomisches Anzeiger 4, 111–121 (1889)
59. Rosenblatt, F.: The perceptron: A probabilistic model for information storage
and organization in the brain. Psychological Review 65(6), 386–408 (1958)
60. Stone, P.: Layered Learning in Multiagent Systems: A Winning Approach to
Robotic Soccer. MIT Press, Cambridge (2000)
61. Turing, A.M.: Intelligent Machinery. A report. National Physical Laboratory.
Mathematical Division (1948)
62. Wajsberg, M.: Axiomatization of the 3–valued sentential calculus (in Polish, a
summary in German). C. R. Soc. Sci. Lettr. Varsovie 24, 126–148 (1931)
63. Wille, R.: Restructuring lattice theory: An approach based on hierarchies of
concepts. In: Rival, I. (ed.) Ordered Sets, pp. 445–470. D. Reidel, Dordrecht
(1982)
64. Yao, Y.Y.: Granular computing: Basic issues and possible solutions. In: Pro-
ceedings of the 5th Joint Conference on Information Sciences I. Assoc. Intell.
Machinery, pp. 186–189. Assoc. Intell. Machinery, Atlantic (2000)
65. Yao, Y.Y.: Perspectives of granular computing. In: Proceedings of IEEE 2005
Conference on Granular Computing GrC 2005, pp. 85–90. IEEE Press, Beijing
(2005)
66. Zadeh, L.A.: Fuzzy sets and information granularity. In: Gupta, M., Ragade,
R., Yager, R.R. (eds.) Advances in Fuzzy Set Theory and Applications, pp.
3–18. North–Holland, Amsterdam (1979)
67. Zadeh, L.A.: Toward a uniﬁed theory of uncertainty. In: Proceedings of IPMU
2004, Perugia, Italy, vol. 1, pp. 3–4 (2004)


Chapter 8
Reasoning by Rough Mereology in
Problems of Behavioral Robotics
In Ch. 6, we have developed basic notions and propositions of rough mere-
ogeometry and rough mereotopology. We have stressed that by its nature,
rough mereology does address collective concepts, relations among which are
expressed by partial containment rendered as the predicate of a part to a
degree. Behavioral robotics falls into this province, as usually robots as well
as obstacles and other environmental objects are modeled as ﬁgures or solids.
In this chapter, we discuss planning and navigation problems for mobile au-
tonomous robots and their formations. In particular, we give a formal deﬁni-
tion of a robot formation based on the betweenness relation, cf., Ch. 6., sect.
10. First, we introduce the subject of planning in robotics.
8.1
Planning of Robot Motion
Planning is concerned with setting a trajectory for a robot endowed with
some sensing devices which allow it to perceive the environment in order to
reach by the robot a goal in the environment at the same time bypassing
obstacles.
Planning methods, cf., e.g., Choset et al. [17], vary depending on the robot
abilities, features of the environment and chosen methodology. Among them
are simple geometric methods designed for a robot endowed with sensors
detecting obstacles, e.g., touch sensors or range sensors and able to detect
distance between any pair of points. These methods are called ‘contour fol-
lowing’, as for such a robot, the idea can be implemented of moving to goal in
a straight line segment and in case of meeting with an obstacle to bypass it by
circumnavigating its boundary until the straight line to goal is encountered
anew.
In this class belong so called ‘bug algorithms’ like BUG 1 algorithm due
to Lumelsky and Stepanov [35], and its modiﬁcation, the ‘tangent bug’ plan-
ner, Kamon et al. [27], cf., Choset et al. [17], in which the robot performs a
heuristic search of A∗type, see, e.g., Russell and Norvig [52] or Choset et al.
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 297–318.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

298
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
[17] with the heuristic function h(x) = ρ(x, O) + ρ(O, goal) where x is the
current position of the robot, and the point O is selected as an end–point of
the continuity interval of ρ – the distance function, whose values are bound
by a constant R.When the distance measured by range sensors exceeds R
the value of ρ is set to inﬁnity. The graph of ρ against the position x ex-
hibits then discontinuities and continuity intervals clearly outline boundaries
of obstacles, hence, the idea of selecting O as a boundary continuity point.
Minimization of h leads to optimization of the chosen safe trajectory.
To stay with geometric methods, we proceed with Vorono¨ı diagrams. Most
often, obstacles are modeled as two–dimensional polygons, and then the
Vorono¨ı diagram V is a 1–dimensional set consisting of points which are
at equal distance from two closest to them obstacles, i.e., x ∈V if and only
if ρ(x, Wi) = ρ(x, Wj) ≤ρ(x, Wk) for k ̸= i, j. Clearly, navigating the robot
along V keeps it at safe distance from obstacles, hence, the planner based on
the idea of the Vorono¨ı diagram transports the robot from the starting point
to the nearest point on V and then along V to the point in V nearest to the
goal, see Choset et al. [17].
Another geometric idea is implemented in visibility graphs, see Latombe
[32] and Li and Canny [34]. Vertices of obstacles, again, modeled as 2–
dimensional polygons, constitute nodes of the graph. Two distinct nodes are
joined by an edge if and only if two corresponding vertices can be connected
by a straight line segment avoiding any contact with any of obstacles except
for these two points. For particular start and goal points start, goal, these
points are added to the graph as nodes and also connected by edges with
other nodes when the straight line visibility condition is satisﬁed.
A further development is provided by silhouette methods, see Canny [15].
It exploits the sweeping algorithm which consists in moving the sweeping line
of the form, e.g., {x1} × R by increasing x1; at each position, the end points
of segments in the line obtained by intersection with obstacles constitute the
silhouette, or, the Canny roadmap.
In some cases, not only the aim is to transport the robot from start to
goal, but to cover all free space, e.g., when one wants the robot to paint
the ﬂoor. One says in such cases of the coverage problem. Then, a method
exploited is the cell decomposition. One represents the free space as a union
of cells and builds on cells as nodes of a graph, the adjacency graph joining
two nodes–cells with an edge if and only if the cells share a boundary.
There are various implementations of the idea, e.g., trapezoidal decomposi-
tion, see de Berg et al. [10]. This implementation looks at each vertex v of an
obstacle for half–lines going ‘up’ and ‘down’ and registering points on them
of intersection with obstacles or boundaries of working space. This deﬁnes a
decomposition into cells.
As ‘exact’ planning algorithms are infeasible in some environments, see
Schwartz and Sharir [54], Kavraki [28], or Canny [15] approximate planners
based on probabilistic sampling were developed, see, e.g., Barraquand et al.
[6], Kavraki et al. [29].

8.1 Planning of Robot Motion
299
When many queries about paths are intended, then it is useful to build a
probabilistic roadmap planner, see Kavraki et al. [29]. It is built on a standard
planner, say P, which explores the possibility of a path between points in the
working space and builds a metric on it. Nodes of the graph are conﬁgurations
sampled from possible ones and roadmaps are built incrementally; any time
a conﬁguration, say c, is sampled, k nearest neighbors already sampled are
selected and the planner P checks whether there is a safe path between c and
any neighbor, adding an edge to the graph for each pair with a safe path.
Planning is necessarily coupled with localization, in order to plan one
should know the robot position. To this eﬀect, bayesian ﬁltering, in particular
Kalman ﬁltering is applied, see Kalman [26], cf. Choset et al. [17].
A method referring to physical inspiration is the potential ﬁeld method,
see Khatib [30]. A potential ﬁeld is composed of attractive potentials for goals
and repulsive potentials for obstacles.
An example may be taken as the quadratic potential function
Uattractive(x) = 1
2 · ||x −xgoal||2
(8.1)
which induces the gradient
∇Uattractive(x) = x −xgoal
(8.2)
which assures that the force (the gradient) exerted on the robot is greater
when the robot is far from the goal and diminishes to zero as the robot is
approaching the goal.
A repulsive potential should have opposite properties: it should exert a
force tending to ∞with the distance to the obstacle reaching 0. Denoting
the distance from a point x to the closest obstacle with s(x), the repulsive
potential can be deﬁned as in
Urepulsive(x) = 1
2 · [ 1
s(x)]
(8.3)
with the gradient
∇Urepulsive(x) = −
1
s(x)2 · ∇s(x)
(8.4)
The global potential function U is the sum of the attractive and repulsive
parts:
U(x) = Uattractive(x) + Urepulsive(x)
Given U, the robot performs a well–known gradient descent : it does follow
the direction of the gradient in small steps : the (i + 1)–th position is given
from the i-th position and the gradient therein as
xi+1 = xi + ξi · ∇U(xi)
(8.5)

300
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
Potential ﬁelds method suﬀers from the local minima problem immanent
to gradient descent method: though the absolute minimum of 0 is achieved
by the potential function at the goal, yet superposition of many ﬁelds from
obstacles and goals induces local minima and saddle points typical to many–
dimensional landscape. A way out of local minima can be found by means of
small random perturbations, see Barraquand et al. [6].
This closes our very brief glimpse at planning methods showing their vari-
ety. For a discussion of an underlying architecture, see Brooks [12]. One can
ask, what rough mereology can add to this repertoire? We have proposed a
new variant of potential ﬁeld method, based on rough inclusion technique,
see O´ssmialowski [41] and Polkowski and O´smialowski [48], [49].
8.2
Potential Fields from Rough Inclusions
Classical methodology of potential ﬁelds works with integrable force ﬁeld
given by formulas of Coulomb or Newton which prescribe force at a given
point as inversely proportional to the squared distance from the target; in
consequence, the potential is inversely proportional to the distance from the
target. The basic property of the potential is that its density (=force) in-
creases in the direction toward the target. We observe this property in our
construction.
We refer to mereogeometry of Ch. 6, sect. 10, and we recall the rough
inclusion
μ(x, y, r) ⇔||x ∩y||
||x||
(8.6)
where ||x|| is the area of the region x. In our construction of the potential
ﬁeld, region will be squares: this corresponds with the robots used which are
disc–shaped Roomba (a trademark of iRobot, Inc.) robots, so they can be
represented by squares circumscribed on them.
Geometry induced by means of a rough inclusion can be used to deﬁne a
generalized potential ﬁeld: the force ﬁeld in this construction can be inter-
preted as the density of squares that ﬁll the workspace and the potential is
the integral of the density. We present now the details of this construction,
see O´smialowski [41], Polkowski and O´smialowski [49].
We construct the potential ﬁeld by a discrete construction. The idea is to
ﬁll the free workspace of a robot with squares of ﬁxed size in such a way
that the density of the square ﬁeld (measured, e.g., as the number of squares
intersecting the disc of a given radius r centered at the target) increases
toward the target.
To ensure this property, we ﬁx a real number – the field growth step
in the interval (0, square edge length); in our exemplary case the parameter
field growth step is set to 0.01.
The collection of squares grows recursively with the distance from the
target by adding to a given square in the (k + 1) −−th step all squares

8.2 Potential Fields from Rough Inclusions
301
obtained from it by translating it by k × field growth step (with respect
to Euclidean distance) in basic eight directions: N, S, W, E, NE, NW, SE,
SW (in the implementation of this idea, the ﬂoodﬁll algorithm with a queue
has been used, see O´smialowski [41]. Once the square ﬁeld is constructed, the
path for a robot from a given starting point toward the target is searched for.
The idea of this search consists in ﬁnding a sequence of way–points which
delineate the path to the target. Way–points are found recursively as cen-
troids of unions of squares mereologically closest to the square of the recently
found way–point. We recall, see Ch. 6, that the mereological distance between
squares x, y is deﬁned by means of
k(x, y) = min{max{r, s} : μ(x, y, r), μ(y, x, s)}
(8.7)
We also remind that the mereological distance k(x, y) takes on the value 1
when x = y and the minimal value of 0 means that x∩y ⊆Bd(x)∩Bd(y). In
order do deﬁne a ”potential” of the rough mereological ﬁeld, let us consider
how many generations of squares will be centered within the distance r from
the target. Clearly, we have
d + 2d + ... + kd ≤r
(8.8)
where d is the ﬁeld growth step, k is the number of generations. Hence,
k2d ≤k(k + 1)
2
d ≤r
(8.9)
and thus
k ≤(r
d)
1
2
(8.10)
The potential V (r) can be taken as ∼r
1
2 . The force ﬁeld F(r) is the negative
gradient of V (r),
F(r) = −d
drV (r) ∼−1
r
1
2
(8.11)
Hence, the force decreases with the distance r from the target slower than
traditional Coulomb force. It has advantages of slowing the robot down when
it is closing on the target. Parameters of this procedure are: the field growth
step set to 0.01, and the size of squares which in our case is 1.5 times the
diameter of the Roomba robot.
The path planner designed in this way, accepts target point coordinates
and provides list of way–points from given robot position to the goal. To do
its job, it needs a map of static obstacles that a robot should avoid while
approaching target point. A robot and a target should both lay within the
area delimited by surrounding static obstacles that form borders of robot
workspace. There can be other static obstacles within the area, all marked
on the provided map. After the path is proposed a robot is lead through
the path until it reaches given target. If a robot cannot move towards goal

302
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
position for some longer time (e.g., it keeps on hitting other robot reaching
its target or any other unknown non–static obstacle), new path is proposed.
We tested our planner device running simulations in which we have had a
model of Roomba robot traveling inside artiﬁcial workspace. Real Roomba
robots are round and therefore easy to model, however they do not provide
many useful sensor devices (except bumpers which we were using to imple-
ment lower–level reaction for hitting unexpected obstacles). Also odometry
of Roomba robots is unreliable, Tribelhorn and Dodds [59], hence, we as-
sume that simulated robots are equipped with a global positioning system.
A map of an environment as used in simulations along with a potential ﬁeld
generated for a given goal is is shown in Fig. 8.1.
Fig. 8.1 Obstacles and potential ﬁeld layer
A robot should follow the path proposed by planner by going from one area
centroid to another until the goal is reached. The proposed path is marked
on the map, see Fig. 8.2, Fig. 8.3.
Fig. 8.2 Stage simulator: iRobot Roomba robots starting to a goal

8.3 Planning for Teams of Robots
303
Fig. 8.3 Planned paths of Roomba robots to their targets
To perform re–planning of the path, usually the planner should repeat the
planning routine. Using our method, only second stage of planning routine is
done during replanning as potential ﬁeld is computed only once (unless the
database is updated with new obstacles). Searching for a path within already
computed potential ﬁeld is computationally cheap as it is limited to database
lookup operations (therefore speed of database communication is critical if
this method is intended to be working fast).
8.3
Planning for Teams of Robots
Both theoretical interests, see Walter [61], [62] as well as practical motiva-
tions, have driven the attention of researchers in robotics toward problems
related to teams of robots. From purely intellectual point of view, this opens a
new venue for solving problems of cooperation, communication, task–sharing
and division, and planning non–collision paths for robots.
According to Cao et al. [16], robot teams can provide a useful playground
for studies of cognitive theories, biology, ethology, organization and manage-
ment. They can also lead to new solutions to problems of artiﬁcial intelli-
gence. Passing from a single robot to teams of robots can be motivated also
by pragmatic reasons, Cao et al. [16], as tasks for robots can be too complex
for a single robot, or many robots can do the task easier at a lesser cost, or
many robots can perform the task more reliably. Practical studies along these
lines were concerned with moving large objects of irregular shapes by groups
of robots, see Kube and Zhang [31], search and rescue, see Jennings et al.
[25], formations of planetary outposts of mobile robots, see Huntsberger et
al. [23]. Simulations of systems a few robots were studied, e.g., in CEBOT,
see Fukuda and Nakagawa [21], ACTRESS, see Asama et al. [3], GOFER,
see Caloud et al. [14], cf., the ALLIANCE architecture in Parker [46].
In Cao et al. [16], main research directions in this area were systematized,
among them, Geometric Problems, involving multiple–robot path planning,

304
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
formation maintaining, moving to formations, marching, pattern generation.
To be more speciﬁc, path planning involves many specialized strategies; some
of them propose initial individual paths for each robot, often straight lines
to the goal, with strategies for obstacle negotiating and conﬂict resolution
by either negotiations between robots or by a supervising agent. The choice
here is between prioritized planning which takes one robot at a time accord-
ing to some priority scheme, see Erdmann and Lozano–Perez [19] and path
coordination method which plans paths by scheduling conﬁguration space
resources. Problems of cooperation and negotiations are discussed in Naﬃn
and Suthname [39] and Parker [45].
The Formation Problem as well as Marching Problem require of robots
to move into a prescribed formation and march to the goal maintaining the
formation. Various have been solutions adopted for these problems. A study
of the concept of a robot team was initially based on a perception of animal
behavior like herding, swarming, ﬂocking or schooling. Work by Reynolds
[51] brought forth an approach to ﬂocking in groups of birds called ‘boids’
based on simple behaviors like: collision–avoidance, velocity matching, ﬂock
centering, where each bird senses its neighbors only, and geometric positions
of birds are not speciﬁed. A similar position was adopted in Mataric [36],
[37] who studied ﬂocking in wheeled robots induced by simple behaviors:
wandering, homing, following, avoidance, aggregation, dispersion, cf., [20],
[38]. See Wilson [63] for a deep study in sociobiology and Agah [1], Agah and
Bekey [2], and Bekey [8] for robotic counterparts.
These observations brought forth some basic principles of behavioral ap-
proach, see, e.g., Balch and Arkin [5]: it is vital to keep all robots within a
certain distance from one another (e.g., to ensure mutual visibility), to move
away when the distance becomes too close (to avoid congestion, collision, or
resource conﬂict), to adapt own movement to movement of neighbors (e.g.,
by adjusting velocity of motion), to orient oneself on a leader, or a speciﬁc
location, e.g., the gravity center of the group.
Balch and Arkin, op.cit., implement these principles by imposing geo-
metric constraints on individual robots: each of them is to keep a precisely
speciﬁed geometric position. They investigate four types of formations: line
where robots move line–abreast, column where robots travel in an Indian ﬁle,
diamond, wedge. Each robot in a formation is given its ID number. Maintain-
ing position in a formation is provided by two processes: detect–formation–
position detects the current position of a robot on basis of sensory data,
maintain–formation produces motor commands to move robot to the proper
position. They evaluate three referencing techniques for computing a proper
position of a robot in the formation: unit–center–reference, leader–reference,
neighbor–reference.
In unit–center–reference each robot computes the coordinates of the center
of the formation and keeps position with respect to it.

8.3 Planning for Teams of Robots
305
In leader–referencing, one robot is designated as the leader whose position is
irrelevant and other robots are keeping the formation.
In neighbor–reference each robot keeps position with respect to one speci-
ﬁed neighbor. The local coordinate system in which positions are computed
is at each step given by the unit center and the line from it through the
next navigation way–point. The parameter spacing of the procedure detect–
formation–position is used to keep distances between robots.
This scheme sets demands on sensory and motor capabilities of robots. Au-
thors propose using dead reckoning, or GPS, or direct perception of neighbors
as means of sensory determination of a position in the formation. One can
say that Balch and Arkin, op. cit., are proponents of the geometric approach
to formations: it uses referencing techniques; reference is made either to the
team center or to the team leader, or to a speciﬁed neighbor in a coordinate
system given by the position of the team center or the leader along with the
orientation given by the nearest navigation point; positions are determined,
e.g., with the help of GPS or dead reckoning. Spacing between robots is im-
posed and robots keep their geometric positions. In this approach, complex
behaviors of a team of robots result from an interaction of primitive behav-
iors organized by sensory and motor components of robots. Dorigo et al. [18]
situate themselves with their approach in the realm of self–organization and
swarm intelligence, see Bonabeau et al. [11], Payton et al. [47], and evolution-
ary computing, see Baeck et al. [4]. Authors study s–bots: robots of limited
capabilities, with respect to their coordinated behaviors. S–bots have ability
to connect one to another by physical links therefore making rigid formations
and the objective of the authors is to study coordinated movement of robots
in a formation. The method of evaluating performance of the complex con-
troller is by a genetic process. Coordinated behavior of a team results as a
complex product of individual behaviors.The important issue raised in this
work is stressing the importance of ability of a formation to change shape or
to adapt to changing environment and pointing to the problem of dependence
of complex behaviors of a team on the set of individual behaviors of robots in
that team. Current status of the ﬁeld of self–conﬁgurable robots, a variation
on the theme of coupled formations can be found in Stoy et al. [57].
The potential ﬁeld methodology has also been extended to teams of robots.
A good example of this approach is provided in Leonard and Fiorelli [33]
which combines potential ﬁeld approach with the virtual leader–reference
approach. Potentials deﬁne interaction forces among robots forcing them to
keep at desired distance one from another. Virtual leaders are moving refer-
ence points for robots to control the group movement and maintain group
geometry. In this approach, the already mentioned by us biological behaviors
of swarms like avoidance of close neighbors, keeping distance to the group,
velocity matching are encoded by means of artiﬁcial local potentials deﬁned
as functions of relative distances between pairs of neighbors; control forces are
then deﬁned as negative gradients of the sum of potentials aﬀecting a given
robot. By their action, robots are driven to the absolute minimum of the

306
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
global potential function; local potentials can be designed as to correspond
to a given geometry of the group.
In addition to local neighbor–pair potentials, virtual leaders, i.e., moving
reference beacons are added, each of them generating its own potential ﬁeld
with the aim of manipulating the group, directing it or herding robots into
a group. Authors discuss motions like schooling and ﬂocking. Schooling is a
maneuver in which a steady group translation occurs, and ﬂocking takes place
when robots circle a stationary point. For instance, authors demonstrate a
stationary movement of a group of 6 robots forming vertices of a hexagonal
lattice.
An approach to controlling of a group of robots using the leader idea is
presented in Shao et al. [55]. The leader–follower paradigm means that each
robot in a group has a neighbor assigned as its leader whom it follows with
prescribed distance and eventual other parameter values. For a group on N
robots, authors propose to express the group structure in the form of a tree
in which pairs of the form parent–child are pairs the leader, the follower,
encoded in the usual form of an adjacency matrix; another matrix is the
parameter matrix: authors discuss four parameters for each robot: distance,
orientation error, angle and the Boolean attribute Presence meaning visibility
of the leader. Authors show some patterns: a hexagon, a diamond of twelve
robots, a column (line), a wedge. An interesting fact is that authors raise the
problem of changing patterns.
Another method for forming a geometric formation relies on a direct usage
of a metric, see, e.g., Sugihara and Suzuki [58]: given a threshold δ, and a
parameter D – the circle diameter, for each robot M in a team, its farthest
neighbor M1 and the nearest neighbor M2
1. If ρ(M, M1) > D, then M moves toward M1;
2. If ρ(M, M1) < D −δ, then M moves away from M1.
These two steps assure that the diameter of the set of robots in each
cross-section is about D. Finally
3. If D −δ < ρ(M, M1) < D, then M moves away from M2.
By this method, robots are arranged on an approximation to a circle of
diameter D. This procedure is performed iteratively and in each iteration
robots move sequentially.
In Schneider et al. [53] authors attempt a systematic discussion of metrics
for formation navigation. They use the term ‘metric’ in order to denote some
criterion of performance evaluation for a group of robots. Authors assume a
group of identical robots, communicating among themselves, with ability to
sense the environment and one another. Among some metrics of that type
authors mention

8.3 Planning for Teams of Robots
307
1. Path length ratio: the ratio of the average path length by robots in a group
to the straight–line distance to the goal;
2. Average position error: average displacement from the correct position in
the group during the run;
3. Percentage of time out of formation;
4. As an additional measure, time to convergence, i.e., time needed for the
group to assume a given pattern is added.
Authors deﬁne a formation of robots in strict geometric terms, characterizing
a formation by means of a ﬁnite set of segments and angles between them,
such that
1. Uniform dispersion is secured: all neighboring robots keep the same dis-
tance d with maximum error ε;
2. Shape is proper: each robot keeps its position within an error ε;
3. Orientation: the angles are kept within the error εa.
In order to keep a formation, potential ﬁelds are used. In addition to the goal
potential and the attractive potentials of obstacles, each robot in a group
exerts attractive and repulsive forces on other robots. All these potentials
sum up for each robot inducing the directing forces.
Planning paths for multiple robots adapts and modiﬁes planing methodol-
ogy for a single robot, see Hwang and Ahuja [24] or Latombe [32] for surveys.
The centralized approach, ﬁnding a path in a complex conﬁguration space de-
scribing the system, provides complete planners which always ﬁnd a path for
the system if it exists; however, this comes at the cost of exponential com-
plexity: the problem of planning for rectangular robots in the rectangular
workspace is P–space complete, see Hopcroft et al. [22]. Schwartz and Sharir
[54] describe planners of polynomial complexity based on cell decomposition
for disc shaped robots in polygonal obstacle world. Variants of the method of
potential ﬁeld, were applied as well in centralized planning, see Barraquand
and Latombe [7]; they proposed a randomized path planner based on a a
potential ﬁeld induced by goals with random ﬂuctuations for escaping local
minima. In the area of decoupled planning, the problem is to merge plans for
individual robots into one general plan for the whole system; here, the idea
of prioritization was put forth in Erdmann and Lozano–Perez [19].

308
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
High complexity of centralized planning and incompleteness of decoupled
planning prompted research in the area between the two and the idea of sep-
arate roadmaps for robots emerged in which separate roadmaps are combined
into a global roadmap, see La Valle and Hutchinson [60]. A general problem
of mission planning for multiple vehicles and concurrent goals is addressed in
Brumitt et al. [13] where a distributed planner is introduced in the context
of a dynamic allocation of goals to autonomous vehicles. Planning is eﬀected
in the environment of a mission grammar MG:
1. m →M(r, g)—m ∧m—m ∨m—m ⇒m—(m);
2. r →Ri—r ∧r—r ∨r—(r);
3. g →Gj—g ∧g—g ∨g—g ⇒g—(g),
where a ⇒b means ”a followed by b”, a ∧b means ”a and b”, a ∨b means ”a
or b”, Ri means ”robot i”, Gi means ”goal i”, M(r, g) means ”move robot r
to goal g”. For instance, the expression M((R1 ∧R2), G1 ⇒G2) means that
robots 1 and 2 are to go to goal 1 and then to goal 2. These simple grammar
expressions are examined by the mission planner and parsed into sequences
of executable commands and planning of paths for them uses the D∗search
algorithm, see Choset et al. [17].
So now again the recurrent question: what rough mereology can do for
robot teams in terms of planning and navigation? We may observe that one
can hardly ﬁnd in literature a formal deﬁnition of what a robot formation
is, independent of the context, e.g., a metric. Rather, formations are de-
ﬁned by setting constraints on individual robot either absolute or relative
to a leader, or a neighbor. A deﬁnition absolute in a sense, abstracted from
metric context, can be useful. Also, rigidity of constraints, e.g., necessity of
keeping distances and angles, rids the team of ﬂexibility, necessary when,
e.g., obstacles force the team to change the formation in order to pass, e.g.,
a bottleneck. Thus, we strive for a deﬁnition and conditions for a formations
which on one hand would secure its maintenance through manoeuvering to
goal, and, on the other hand would permit a ﬂexible behavior, e.g., bypassing
an obstacle whereas keeping the formation. We propose a solution based on
mereogeometry of Ch. 6.
8.4
Rough Mereological Approach to Robot
Formations
We again resort to mereogeometry, see Ch. 6, sect. 10, O´ssmialowski [41],
and Polkowski and O´ssmialowski [48], [49]. We recall that on the basis of the
rough inclusion μ, and mereological distance κ deﬁned as

8.4 Rough Mereological Approach to Robot Formations
309
κ(X, Y ) = min{max r, max s : μ(X, Y, r), μ(Y, X, s)}
(8.12)
geometric predicates of nearness and betweenness, see Ch. 6, sect. 10, are
redeﬁned in the mereological frame.
The relation N of nearness proposed by Van Benthem [9] is deﬁned in
mereological context as
N(X, U, V ) if and only if κ(X, U) > κ(V, U)
(8.13)
Here, N(X, U, V ) means that X is closer to U than V is to U.
The betweenness relation TB, see Van Benthem [9], is deﬁned as
TB(Z, U, V ) if and only if [for each W (Z = W) or N(Z, U, W) or N(Z, V, W)]
(8.14)
The principal example bearing on our approach to robot control deals with
rectangles in 2D space regularly positioned, i.e., having edges parallel to
coordinate axes. We model robots (which are represented in the plane as
discs of the same radius in 2D space) by means of their safety regions about
robots; those regions are modeled as rectangles circumscribed on robots. One
of advantages of this representation is that safety regions can be always imple-
mented as regularly positioned rectangles circumscribed on discs representing
robots.
Given two robots a, b as discs of same radii, and their safety regions as
circumscribed regularly positioned rectangles A, B, we search for a proper
choice of a region X containing A, and B with the property that a robot C
contained in X can be said to be between A and B. For two (possibly but
not necessarily) disjoint rectangles A, B, we deﬁne the extent, ext(A, B) of A
and B as the smallest rectangle containing the union A ∪B. Then we have
the claim, obviously true by deﬁnition of TB, see Ch. 6, sect. 10
Proposition 8.1. We consider a context in which objects are rectangles po-
sitioned regularly, i.e., having edges parallel to axes in R2. The measure μ is
μG, see Ch. 6, sect. 6. In this setting, given two disjoint rectangles C, D, the
only object between C and D in the sense of the predicate TB is the extent
ext(C, D) of C, D, , i.e., the minimal rectangle containing the union C ∪D.
For details of the exposition which we give now, please consult O´smialowski
[42], [43], Polkowski and O´smialowski [49], O´smialowski and Polkowski [44].
The notion of betweenness along with Proposition 8.1 permits to deﬁne the
notion of betweenness for robots. Recall that we represent the disc–shaped
Roomba robots by means of safety squares around them, regularly placed,
i.e., with sides parallel to coordinate axes.
For robots a, b, c, we say that a robot b is between robots a and c, in symbols
(between b a c)
(8.15)

310
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
in case the rectangle ext(b) is contained in the extent of rectangles ext(a),
ext(c), i.e.
μ0(ext(b), ext(ext(a), ext(c)), 1)
(8.16)
i.e., see Ch. 6, sect. 10, ext(b) ⊆ext(ext(a), ext(b)).
This allows as well for a generalization of the notion of betweenness to the
notion of partial betweenness which models in a more realistic manner spatial
relations among a, b, c; we say in this case that robot b is between robots a
and c to a degree of at least r, in symbols,
(between–degr b a c )
(8.17)
if and only if
μ0(ext(b), ext[ext(a), ext(c)], r)
(8.18)
i.e., ||ext(b)∩ext(ext(a),ext(c))||
||ext(b)||
≥r.
For a team of robots, T(r1, r2, ..., rn) = {r1, r2, ..., rn}, an ideal forma-
tion IF on T(r1, r2, ..., rn) is a betweenness relation (between...) on the set
T(r1, r2, ..., rn) of robots.
In implementations, ideal formations are represented as lists of expressions
of the form
(between r0 r1 r2)
(8.19)
indicating that the object r0 is between r1, r2, for all such triples, along with
a list of expressions of the form
(not–between r0 r1 r2)
(8.20)
indicating triples which are not in the given betweenness relation.
To account for dynamic nature of the real world, in which due to sensory
perception inadequacies, dynamic nature of the environment etc., we allow
for some deviations from ideal formations by allowing that the robot which
is between two neighbors can be between them to a degree in the sense of
(8.17). This leads to the notion of a real formation.
For a team of robots, T(r1, r2, ..., rn) = {r1, r2, ..., rn}, a real formation
RF on T(r1, r2, ..., rn) is a betweenness to degree relation (between–deg ....)
on the set T (r1, r2, ..., rn) of robots.
In practice, real formations will be given as a list of expressions of the
form,
(between–deg δ r0 r1 r2),
(8.21)
indicating that the object r0 is to degree of δ in the extent of r1, r2, for all
triples in the relation (between–deg ....), along with a list of expressions of
the form,
(not–between r0 r1 r2),
(8.22)
indicating triples which are not in the given betweenness relation.

8.4 Rough Mereological Approach to Robot Formations
311
Description of formations, as proposed above, can be a list of relation in-
stances of large cardinality, cf., examples below. The problem can be posed
of ﬁnding a minimal set of instances suﬃcient for describing a given forma-
tion, i.e., implying the full list of instances of the relation (between...). This
problem turns out to be NP–hard, see O´smialowski and Polkowski [44].
Proposition 8.2. The problem of ﬁnding a minimal description of a forma-
tion is NP–hard.
Proof. (O´smialowski and Polkowski [44]) We construct an information sys-
tem, see Ch. 4, Formations as a triple (U, A, f) where U is a set of objects, A is
a set of attributes and f is a value assignment, i.e., a mapping f : A×U →V ,
where V is a set of possible values of attributes in A on objects in U. For a
formation F, with robots r1, ..., rn we let U = T (r1, ..., rn), a team of robots;
A = {[rk, rl, rm] : rk, rl, rm pairwise distinct robots}. For a given formation
F of robots r1, ..., rn, the value assignment f is deﬁned as follows,
f([rk, rl, rm], ri) =
⎧
⎨
⎩
1 in case ri = rl and (between rl rk rl)
1
2 in case ri = rl or ri = rm and (between rl rk rm)
0 in case ri ̸= rl rk rm
(8.23)
The system Formations describes the formation F.
Clearly, reducts of the system Formations provide a complete description
of the formation F and correspond to minimal descriptions of the formation.
As shown by Skowron and Rauszer [56] the problem of ﬁnding a minimum
size reduct of a given information system is NP–hard
⊓⊔
To describe formations we have proposed a language derived from LISP–like
s–expressions: a formation is a list in LISP meaning with some restrictions
that formulates our language. We will call elements of the list the objects.
Typically, LISP lists are hierarchical structures that can be traversed using
recursive algorithms. We restrict that top–level list (a root of whole structure)
contains only two elements where the ﬁrst element is always a formation
identiﬁer (a name). For instance
Example 8.1. (formation1 (some predicate param1 ... paramN))
For each object on a list (and for a formation as a whole) an extent can be
derived and in facts, in most cases only extents of those objects are considered.
We have deﬁned two possible types of objects
1. Identiﬁer: robot or formation name (where formation name can only occur
at top–level list as the ﬁrst element);
2. Predicate: a list in LISP meaning where ﬁrst element is the name of given
predicate and other elements are parameters; number and types of param-
eters depend on given predicate.

312
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
Minimal formation should contain at least one robot. For example
Example 8.2. (formation2 roomba0)
To help understand how predicates are evaluated, we need to explain how
extents are used for computing relations between objects. Suppose we have
three robots (roomba0, roomba1, roomba2) with roomba0 between roomba1
and roomba2 (so the between predicate is fulﬁlled). We can draw an extent
of this situation as the smallest rectangle containing the union roomba1 ∪
roomba2 oriented as a regular rectangle, i.e., with edges parallel to coordinate
axes. This extent can be embedded into bigger structure: it can be treated
as an object that can be given as a parameter to predicate of higher level in
the list hierarchy. For example:
Example 8.3. (formation3 (between (between roomba0 roomba1 roomba2)
roomba3 roomba4))
We can easily ﬁnd more than one situation of robots that fulﬁll this example
description. That is one of the features of our approach: one s–expression can
describe many situations. This however makes very hard to ﬁnd minimal s–
expression that would describe already given arrangement of robots formation
(as stated earlier in this chapter , the problem is NP–hard). An exemplary
s–description is shown in Fig. 8.4.
Fig. 8.4 Formation described by an s–expression: (formation3 (between (between
roomba0 roomba1 roomba2) roomba3 roomba4))
Typical formation description may look like below, see O´smialowski [42],
[43], Polkowski and O´smialowski [49], [50]
Example 8.4. (cross
(set
(max–dist 0.25 roomba0 (between roomba0 roomba1 roomba2))

8.4 Rough Mereological Approach to Robot Formations
313
(max–dist 0.25 roomba0 (between roomba0 roomba3 roomba4))
(not–between roomba1 roomba3 roomba4)
(not–between roomba2 roomba3 roomba4)
(not–between roomba3 roomba1 roomba2)
(not–between roomba4 roomba1 roomba2)
)
)
This is a description of a formation of ﬁve Roomba robots arranged in a cross
shape. The max–dist relation is used to bound formation in space by keeping
all robots close one to another.
The ﬁnal stage of planning is in checking its soundness by navigating robots
in an environment with obstacles. We show results of navigating with a team
of robots in the initial formation of cross–shape in a crowded environment,
see Fig. 8.5. In order to bypass a narrow avenue between an obstacle and the
border of the environment, the formation changes to a line, see Fig. 8.6, see
O´smialowski [40], [43].
Fig. 8.5 Trails of robots arranged in cross formation following the leader
Fig. 8.6 Trails of robots moving to their positions in the line formation

314
8 Reasoning by Rough Mereology in Problems of Behavioral Robotics
After the line was formed and robots passed through the passage, the line
formation
can
be
restored
to
the
initial
cross–shaped
formation,
see Figs. 8.7, 8.8. These behaviors witness the ﬂexibility of our deﬁnition
of a robot formation: ﬁrst, robots can change formation, next, as the deﬁ-
nition of a formation is relational, without metric constraints on robots,the
formation can manage an obstacle without losing the prescribed formation
(though, this feature is not illustrated in ﬁgures in this chapter).
Fig. 8.7 Trails of robots moving in the line formation through the passage
Fig. 8.8 Trails of robots in the restored cross formation in the free workspace after
passing through the passage

References
1. Agah, A.: Robot teams, human workgroups and animal sociobiology. A re-
view of research on natural and artiﬁcial multi–agent autonomous systems.
Advanced Robotics 10, 523–545 (1996)
2. Agah, A., Bekey, G.A.: Tropism based cognition: A novel software architec-
ture for agents in colonies. Journal of Experimental and Theoretical Artiﬁcial
Intelligence 9(2-3), 393–404 (1997)
3. Asama, H., Matsumoto, A., Ishida, Y.: Design of an autonomous and
distributed robot system: ACTRESS. In: Proceedings IEEE/RSJ IROS,
pp. 283–290 (1989)
4. Baeck, T., Fogel, D., Michalewicz, Z.: Evolutionary Computation 1: Basic al-
gorithms and operators. Taylor and Francis, New York (1997)
5. Balch, T., Arkin, R.C.: Behavior–based formation control for multiagent robot
teams. IEEE Transactions on Robotics and Automation 14(12) (1998)
6. Barraquand, J., Kavraki, L.E., Latombe, J.–C., Li, T.–Y., Motvani, R., Ragha-
van, P.: A random sampling scheme for robot path planning. Intern. J. Robotic
Research 16(6), 759–774 (1997)
7. Barraquand, J., Latombe, J.C.: A Monte–Carlo algorithm for path planning
with many degrees of freedom. In: Proceedings of the IEEE International Con-
ference on Robotics and Automation, pp. 1712–1717 (1990)
8. Bekey, G.A.: Autonomous Robots. From Biological Inspiration to Implementa-
tion and Control. MIT Press, Cambridge (2005)
9. Van Benthem, J.: The Logic of Time. D. Reidel, Dordrecht (1983)
10. de Berg, M., van Kreveld, M., Overmars, M.: Computational Geometry: Algo-
rithms and Applications. Springer, Berlin (1997)
11. Bonabeau, E., Dorigo, M., Theraulaz, G.: Swarm Intelligence. From Natural to
Artiﬁcial Systems. Oxford University Press, Oxford (1999)
12. Brooks, R.: Cambrian Intelligence: The Early History of the New AI. MIT
Press, Cambridge (1999)
13. Brumitt, B., Stentz, A., Hebert, M.: The CMU UGV Group. Autonomous driv-
ing with concurrent goals and multiple vehicles: Mission planning and archi-
tecture. Autonomous Robots 11(2), 103–115 (2001)
14. Caloud, P., Choi, W., Latombe, J.-C., Pape Le, C., Yin, M.: Indoor automation
with many mobile robots. In: Proceedings IEEE/RSJ IROS, pp. 67–72 (1990)
15. Canny, J.F.: The Complexity of Robot Motion Planning. MIT Press, Cambridge
(1988)
16. Uny, C.Y., Fukunaga, A.S., Kahng, A.B.: Cooperative mobile robotics: An-
tecedents and directions. Autonomous Robots 4, 7–27 (1997)

316
References
17. Choset, H., Lynch, K.M., Hutchinson, S., Kantor, G., Burgard, W., Kavraki,
L.E., Thrun, S.: Principles of Robot Motion. Theory, Algorithms, and Imple-
mentations. MIT Press, Cambridge (2005)
18. Dorigo, M., Trianni, V., Sahin, E., Gross, R., Labella, T., Baldassare, G., Nolﬁ,
S., Deneubourg, J.–L., Mondada, F., Floreano, D., Gambardella, L.: Evolving
self–organizing behaviors for a Swarm–Bot. Autonomous Robots 17, 223–245
(2004)
19. Erdmann, M., Lozano–Perez, T.: On multiple moving objects. In: Proceedings
IEEE ICRA, pp. 1419–1424 (1986)
20. Fredslund, J., Matari´c, M.: A general algorithm for robot formation using lo-
cal sensing and minimal communication. IEEE Transactions on Robotics and
Automation 18(5), 837–846 (2002)
21. Fukuda, T., Nakagawa, S.: A dynamically reconﬁgurable robotic system (con-
cept of a system and optimal conﬁgurations). In: International Conference on
Industrial Electronics, Control, and Instrumentation, pp. 588–595 (1987)
22. Hopcroft, J., Schwartz, J.T., Sharir, M.: On the complexity of motion plan-
ning for multiple independent objects: P–space hardness of the warehouseman’s
problem. International Journal of Robotic Research 3(4), 76–88 (1984)
23. Huntsberger, T., Stroupe, A., Aghazarian, H., Garrett, M., Younse, P., Powell,
M.: TRESSA: Teamed robots for exploration and science of steep areas. Journal
of Field Robotics 24(11/12), 1015–1031 (2007)
24. Hwang, Y., Ahuja, N.: Gross motion planning - A survey. ACM Computing
Surv. 24(3), 219–291 (1992)
25. Jennings, J.S., Whelan, G., Evans, W.F.: Cooperative search and rescue with
a team of mobile robots. In: SPIE, Aerosense, Orlando, FL, vol. 4364 (2001)
26. Kalman, R.: A new approach to linear ﬁltering and prediction problem. Trans-
actions of the ASME. Journal of Basic Engineering 82, 35–45 (1960)
27. Kamon, I., Rimon, E., Rivlin, E.: A range–sensor based navigation algorithm.
Intern. J. Robotic Research 17(9), 934–953 (1998)
28. Kavraki, L.E.: Random Networks in Conﬁguration Space for Fast Planning.
PhD Thesis. Stanford University (1995)
29. Kavraki, L.E., ˇSvestka, P., Latombe, J.–C., Overmars, M.: Probabilistic
roadmaps for path planning in high–dimensional conﬁguration spaces. IEEE
Transactions on Robotics and Automation 12(4), 566–580 (1996)
30. Khatib, O.: Real–time obstacle avoidance for manipulators and mobile robots.
Intern. J. Robotic Research 5, 90–98 (1986)
31. Kube, C.R., Zhang, H.: The use of perceptual cues in multi–robot box–pushing.
In: Proceedings IEEE Intern. Conference on Robotics and Automation,
pp. 2085–2090 (1996)
32. Latombe, J.C.: Robot Motion Planning. Kluwer Academic Publishers, Boston
(1991)
33. Leonard, N.E., Fiorelli, E.: Virtual leaders, artiﬁcial potentials and coordinated
control of groups. In: Proceedings of the 40th IEEE Conference on Decision and
Control, pp. 2968–2973 (2001)
34. Li, Z., Canny, J.F.: Nonholonomic Motion Planning. Kluwer Academic Pub-
lishers, Boston (1993)
35. Lumelsky, V., Stepanov, A.: Path planning strategies for point mobile au-
tomaton moving amidst unknown obstacles of arbitrary shape. Algorithmica 2,
403–430 (1987)

References
317
36. Matari´c, M.: Kin recognition, similarity and group behavior. In: Proceedings
of 15th Annual Cognitive Society Conference, pp. 705–710. Lawrence Erlbaum,
Mahwah (1993)
37. Matari´c, M.: Interaction and Intelligent Behavior. PhD Dissertation. MIT
EECS Dept (1994)
38. Matari´c, M.: Behavior–based control: Examples from navigation, learning, and
group behavior. Journal of Experimental and Theoretical Artiﬁcial Intelli-
gence 9(2,3), 323–336 (1997)
39. Naﬃn, D., Sukhatme, G.: Negotiated formations. In: Proceedings of the Intern.
Conference on Intelligent Autonomous Systems, pp. 181–190 (2004)
40. O´smialowski, P.: Player and Stage at PJIIT Robotics Laboratory. Journal
of Automation, Mobile Robotics and Intelligent Systems (JAMRIS) 2, 21–28
(2007)
41. O´smialowski, P.: On path planning for mobile robots: Introducing the mereo-
logical potential ﬁeld method in the framework of mereological spatial reason-
ing. Journal of Automation, Mobile Robotics and Intelligent Systems (JAM-
RIS) 3(2), 24–33 (2009)
42. O´smialowski, P.: A Case of Planning and Programming of a Concurrent Be-
havior: Planning and Navigating with Formations of Robots. In: Proceedings of
CSP 2009. Concurrency, Speciﬁcation, Programming. Warsaw University Press,
Krak´ow (2009)
43. O´smialowski, P., Polkowski, L.: (supervisor). Spatial reasoning based on rough
mereology in planning and navigation problems of autonomous mobile robots.
PhD dissertation. Polish–Japanese Institute of IT, Warszawa
44. O’smiaıowski, P., Polkowski, L.: Spatial reasoning based on rough mereology: A
notion of a robot formation and path planning problem for formations of mobile
autonomous robots. In: Peters, J.F., Skowron, A., Slowi´nski, R., Lingras, P.,
Miao, D., Tsumoto, S. (eds.) Transactions on Rough Sets XII. LNCS, vol. 6190,
pp. 143–169. Springer, Heidelberg (2010)
45. Parker, L.E.: Cooperative motion control for multi–target observations. In:
IEEE/RSJ International Conference on Intelligent Robots and Systems, pp.
1591–1598 (1997)
46. Parker, L.E.: ALLIANCE: An architecture for fault tolerant multirobot coop-
eration. IEEE Transactions on Robotics and Automation 14(2), 220–240 (1998)
47. Payton, D., Estkowski, R., Howard, M.: Progress in pheromone robotics. In:
Proceedings of the 7th Intern. Conference on Intelligent Autonomous Systems,
Marina del Rey, CA (2002)
48. Polkowski, L.: O´smialowski P. Spatial reasoning with applications to mobile
robotics. In: Xing–Jian, J. (ed.) Mobile Robots Motion Planning. New Chal-
lenges. I-Tech, Vienna, pp. 433–453 (2008)
49. Polkowski, L., O´smialowski, P.: A framework for multiagent mobile robotics:
Spatial reasoning based on rough mereology in player/Stage system. In: Chan,
C.-C., Grzymala-Busse, J.W., Ziarko, W.P. (eds.) RSCTC 2008. LNCS (LNAI),
vol. 5306, pp. 142–149. Springer, Heidelberg (2008)
50. Polkowski, L., O´smialowski, P.: Navigation for mobile autonomous robots and
their formations: An application of spatial reasoning induced from rough mere-
ological geometry. In: Barrera, A. (ed.) Mobile Robots Navigation. InTech,
Zagreb, pp. 329–354 (2010)
51. Reynolds, C.: Flocks, herds and schools. A distributed behavioral model. Com-
put. Graph. 21(4), 25–34 (1987)

318
References
52. Russell, S.J., Norvig, P.: Artiﬁcial Intelligence: Modern Approach, 3rd edn.
Prentice Hall, Upper Saddle River (2009)
53. Schneider, F., Wildermuth, D., Kr¨ausling, A.: Discussion of exemplary met-
rics for multi–robot systems for formation navigation. In: Advanced Robotic
Systems, pp. 345–353 (2005)
54. Schwartz, J.T., Sharir, M.: On the piano movers’ problem II. General techniques
for computing topological properties of real algebraic manifolds. Advances in
Applied Mathematics 4, 298–351 (1983)
55. Shao, J., Xie, G., Yu, J., Wang, L.: Leader–following formation control of mul-
tiple mobile robots. In: Proceedings of the 2005 IEEE Intern. Symposium on
Intelligent Control, pp. 808–813 (2005)
56. Skowron, A., Rauszer, C.: The discernibility matrices and functions in deci-
sion systems. In: Slowi´nski, R. (ed.) Intelligent Decision Support. Handbook
of Applications and Advances of the Rough Sets Theory, pp. 311–362. Kluwer,
Dordrecht (1992)
57. Stoy, K., Brandt, D., Christensen, D.J.: Self–Reconﬁgurable Robots. The MIT
Press, Cambridge (2010)
58. Sugihara, K., Suzuki, I.: Distributed motion coordination of multiple mobile
robots. In: Proceedings 5th IEEE Intern. Symposium on Intelligent Control,
pp. 138–143 (1990)
59. Tribelhorn, B., Dodds, Z.: Evaluating the Roomba: A low-cost, ubiquitous plat-
form for robotics research and education. In: IEEE International Conference
on Robotics and Automation ICRA 2007, Roma, Italy, pp. 1393–1399 (2007)
60. La Valle, S.M., Hutchinson, S.A.: Optimal motion planning for multiple robots
having independent goals. In: Proceedings IEEE International Conference on
Robotics and Automation, pp. 2847–2852 (1996)
61. Walter, W.G.: An imitation of life. Scientiﬁc American 182, 42–45 (1950)
62. Walter, W.G.: The Living Brain. Norton, New York (1953)
63. Wilson, E.O.: Sociobiology: The New Synthesis, 25th Anniversary edn. Belknap
Press of Harvard University Press, Cambridge (2000)

Chapter 9
Rough Mereological Calculus of
Granules in Decision and
Classiﬁcation Problems
The idea of mereological granulation of knowledge, proposed and presented in
detail in Ch. 7, sect. 3, ﬁnds an eﬀective application in problems of synthesis
of classiﬁers from data tables. This application consists in granulation of
data at preprocessing stage in the process of synthesis: after granulation, a
new data set is constructed, called a granular reﬂection, to which various
strategies for rule synthesis can be applied. This application can be regarded
as a process of ﬁltration of data, aimed at reducing noise immanent to data.
This chapter presents this application.
9.1
On Decision Rules
In Ch. 4, we have given an introduction to the problem of decision rule
synthesis from decision systems, so basic notions and results are known to
the reader. Now, we comment on a more speciﬁc problem of quality of decision
rules and classiﬁers. We recall that decision rules are formed in the frame of
a decision system (U, A, d), as implications of the form

i
(ai = vi) ⇒(d = v)
(9.1)
where ai are conditional attributes, vi are their values, and, v is a value of
the decision.
A decision algorithm, classiﬁer is a judiciously chosen set of decision rules,
approximating possibly most closely the real decision function, which, by
necessity, is not known to us. This comes down to a search in the space of
possible descriptors in order to ﬁnd their successful combinations. In order to
judge the quality, or, degree of approximation, decision rules are learned on a
part of the decision system, the training set and then the decision algorithm
is tested on the remaining part of the decision system, called the test set.
Degree of approximation is measured by some coeﬃcients of varied character.
Simple measures of statistical character are found from the contingency table,
L. Polkowski: Approximate Reasoning by Parts, ISRL 20, pp. 319–334.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

320
9 Rough Mereological Calculus of Granules
see Arkin and Colton [5]. This table is built for each decision rule r and a
decision value v, by counting the number nt of training objects, the number
nr of objects satisfying the premise of the rule r (caught by the rule), nr(v)
is the number of objects counted in nr and with the decision v, and nr(¬v)
is the number of objects counted in nr but with decision value distinct from
v. To these factors, we add nv, the number of training objects with decision
v and n¬v, the number of remaining objects, i.e, n¬v = nt −nv.
For these values, accuracy of the rule r relative to v is the quotient
acc(r, v) = nr(v)
nr
(9.2)
and coverage of the rule r relative to v is
cov(r, v) = nr(v)
nv
(9.3)
These values are useful as indicators of a rule strength which is taken into
account when classiﬁcation of a test object is under way: to assign the value
of decision, a rule pointing to a decision with a maximal value of accuracy,
or coverage, or combination of both can be taken; methods for combining
accuracy and coverage into a single criterion are discussed, e.g., in Michalski
[10]. Accuracy and coverage can, however, be deﬁned in other ways; for a
decision algorithm D, trained on a training set T r, and a test set T st, the
accuracy of D is measured by its eﬃciency on the test set and it is deﬁned
as the quotient
accuracy(D) =
ncorr
ncaught
(9.4)
where ncorr is the number of test objects correctly classiﬁed by D and ncaught
is the number of test objects classiﬁed.
Similarly, coverage of D is deﬁned as
coverage(D) = ncaught
ntest
(9.5)
where ntest is the number of test objects. Thus, the product accuracy(D) ·
coverage(D) gives the measure of the fraction of test objects correctly clas-
siﬁed by D.
We have already mentioned that accuracy and coverage are often advised
to be combined in order to better express the trade–oﬀbetween the two: one
may have a high accuracy on a relatively small set of caught objects, or a
lesser accuracy on a larger set of caught by the classiﬁer objects. Michalski
[10] proposes a combination rule of the form
MI = 1
2 · A + 1
4 · A2 + 1
2 · C −1
4 · A · C
(9.6)

9.1 On Decision Rules
321
where A stands for accuracy and C for coverage. With the symbol MI, we
denote the Michalski index as deﬁned in (9.6).
Statistical measures of correlation between the rule r and a decision class
v are expressed, e.g., by χ2 statistic
χ2 = nt · (nr(v) · n¬r(¬v) −nr(¬v) · n¬r(v))2
n(v) · n(¬v) · nr · n¬r
(9.7)
where n¬r is the number of objects not caught by the rule r, see Bruning and
Kintz [8].
We now restrict ourselves to rough set framework of decision systems and
we denote a rule r by a convenient shortcut
r : φ ⇒(d = v)
(9.8)
where φ is a conjunct of descriptors, see Ch. 4, sect. 2. We recall that [[φ]]
denotes the meaning of a rule φ, i. e., the set of objects satisfying φ. An
object u ∈U, is caught by r (or, matches r) in case u ∈φ; match(r) is the
number of objects matching r.
Support, supp(r), of r is the number of objects in [[φ]] ∩[[(d = v)]]; the
fraction
cons(r) = supp(r)
match(r)
(9.9)
is the consistency degree of r; cons(r) = 1 means that the rule is certain, or
true.
Strength, strength(r), of the rule r is deﬁned, see, e. g., Bazan [6], and
Grzymala–Busse and Ming Hu [9], as the number of objects correctly clas-
siﬁed by the rule in the training phase; relative strength is deﬁned as the
fraction
rel −strength(r) =
supp(r)
|[[(d = v)]]|
(9.10)
Speciﬁcity of the rule r, spec(r), is the number of descriptors in the premise
φ of the rule r, Grzymala–Busse and Ming Hu [9].
In the testing phase, rules vie among themselves for object classiﬁcation
when they point to distinct decision classes; in such case, negotiations among
rules or their sets are necessary. In these negotiations rules with better char-
acteristics are privileged.
For a given decision class c : d = v, and an object u in the test set, the
set Rule(c, u) of all rules matched by u and pointing to the decision v, is
characterized globally by
Support(Rule(c, u)) =

r∈Rule(c,u)
strength(r) · spec(r)
(9.11)

322
9 Rough Mereological Calculus of Granules
The class c for which Support(Rule(c, u)) is the largest wins the competition
and the object u is classiﬁed into the class c : d = v, see, e.g., Grzymala–Busse
and Ming Hu [9].
It may happen that no rule in the available set of rules is matched by
the test object u and partial matching is necessary, i.e., for a rule r, the
matching factor match −fact(r, u) is deﬁned as the fraction of descriptors
in the premise φ of r matched by u to the number spec(r) of descriptors in
φ. The rule for which the partial support
Part −Support(Rule(c, u)) =

r∈Rule(c,u)
match −fact(r, u) · strength(r) · spec(r)
(9.12)
is the largest wins the competition and it does assign the value of decision to
u, see Grzymala–Busse and Ming Hu [9].
In a similar way, notions based on relative strength can be deﬁned for sets
of rules and applied in negotiations among them, see Bazan et al. [7].
A combination of rough set methods with k-nearest neighbor idea, is a
further reﬁnement of the classiﬁcation based on similarity or analogy, cf., an
implementation in RSES [21]. In this approach, training set objects are en-
dowed with a metric, and the test objects are classiﬁed by voting by k nearest
training objects for some k that is subject to optimization, cf., Polkowski [18].
Our idea of augmenting existing strategies for rule induction consists in
using granules of knowledge. The principal assumption we can make is that
the nature acts in a continuous way: if objects are similar with respect to
judiciously and correctly chosen attributes, then decisions on them should
also be similar. A granule collecting similar objects should then expose the
most typical decision value for objects in it while suppressing outlying values
of decision, reducing noise in data, hence, leading to a better classiﬁer.
These ideas were developed and proposed in Polkowski [12] – [15] see also
surveys Polkowski [16] – [18]. In Polkowski and Artiemjew [19], [20] and in
Artiemjew [1] – [4] the theoretical analysis was conﬁrmed as to its applica-
tion merits. We proceed with a summary of methods and results of these
veriﬁcation.
9.2
The Idea of Granular Rough Mereological
Classiﬁers
We assume that we are given a decision system (U, A, d) from which a classiﬁer
is to be constructed; on the universe U, a rough inclusion μ is given, and a
radius r ∈[0, 1] is chosen, see Polkowski [12] – [15].
We can ﬁnd granules gμ(u, r) deﬁned as in Ch. 7, sect. 6, for all u ∈U,
and make them into the set G(μ, r).

9.2 The Idea of Granular Rough Mereological Classiﬁers
323
From this set, a covering Cov(μ, r) of the universe U can be selected by
means of a chosen strategy G, i.e.,
Cov(μ, r) = G(G(μ, r))
(9.13)
We intend that Cov(μ, r) becomes a new universe of the decision system
whose name will be the granular reﬂection of the original decision system. It
remains to deﬁne new attributes for this decision system.
Each granule g in Cov(μ, r) is a collection of objects; attributes in the set
A ∪{d} can be factored through the granule g by means of a chosen strategy
S, i.e., for each attribute q ∈A ∪{d}, the new factored attribute q is deﬁned
by means of the formula
q(g) = S({a(v) : ingr(v, gμ(u, r))})
(9.14)
In eﬀect, a new decision system (Cov(μ, r), {a : a ∈A}, d) is deﬁned. The
object v with
Inf(v) = {(a = a(g)) : a ∈A}
(9.15)
is called the granular reﬂection of g. Granular reﬂections of granules need not
be objects found in data set; yet, the results show that they mediate very
well between the training and test sets.
source
method
accuracy
coverage MI
Bazan [6])
SNAPM(0.9)
error = 0.130
−−
−−
Nguyen SH [11]
simple.templates
0.929
0.623
0.847
Nguyen SH [11]
general.templates
0.886
0.905
0.891
Nguyen SH [11] tolerance.gen.templ.
0.875
1.0
0.891
Wroblewski [25] adaptive.classifier
0.863
−
−−
Fig. 9.1 Best results for Australian credit by some rough set based algorithms
paradigm
system/method
Austr.credit
Stat.Methods
Logdisc
0.141
Stat.Methods
SMART
0.158
Neural Nets
Backpropagation2
0.154
Neural Networks
RBF
0.145
Decision Trees
CART
0.145
Decision Trees
C4.5
0.155
Decision Trees
ITrule
0.137
Decision Rules
CN2
0.204
Fig. 9.2 A comparison of errors in classiﬁcation by rough set and other paradigms

324
9 Rough Mereological Calculus of Granules
algorytm
accuracy coverage rule number MI
covering(p = 0.1)
0.670
0.783
589
0.707
covering(p = 0.5)
0.670
0.783
589
0.707
covering(p = 1.0)
0.670
0.783
589
0.707
LEM2(p = 0.1)
0.810
0.061
6
0.587
LEM2(p = 0.5)
0.906
0.368
39
0.759
LEM2(p = 1.0)
0.869
0.643
126
0.804
Fig. 9.3 Train and Test (trn=345 objects, tst=345 objects) ; Australian Credit;
Comparison of RSES implemented algorithms exhaustive, covering and LEM
The procedure just described for forming a granular reﬂection of a deci-
sion system can be modiﬁed as proposed in Artiemjew [1] with help of the
procedure of concept dependent granulation. In this procedure, the granule
gmu(u, r) is modiﬁed to the granule
gc
μ(u, r) = gμ(u, r) ∩[u]d
i.e., it is computed relative to the decision class of u.
We collect best results for an exemplary data set, the Australian credit
data set, see [23], by various rough set based methods in the table of
Fig. 9.1. For a comparison we include in the table of Fig. 9.2 results obtained
by some other methods, as given in Statlog. In the table of Fig. 9.3, we give a
comparison of performance of rough set classiﬁers, exhaustive, covering and
LEM implemented in RSES [21] system. We begin in the next section with
granular classiﬁers in which granules are induced from the training set.
9.3
Classiﬁcation by Granules of Training Objects
We begin with a classiﬁer in which granules computed by means of the rough
inclusion μL form a granular reﬂection of the data set and then to this new
data set the exhaustive classiﬁer, see [21], is applied.
Procedure of the test
1. The data set (U, A, d) is input;
2. The training set is chosen at random. On the training set, decision rules
are induced by means of exhaustive, covering and LEM algorithms imple-
mented in the RSES system;
3. Classiﬁcation is performed on the test set by means of classiﬁers of pt. 2;
4. For consecutive granulation radii r, granule sets G(μ, r) are found;
5. Coverings Cov(μ, r) are found by a random irreducible choice;
6. For granules in Cov(μ, r), for each r, we determine the granular reﬂec-
tion by factoring attributes on granules by means of majority voting with
random resolution of ties;

9.3 Classiﬁcation by Granules of Training Objects
325
7. For found granular reﬂections, classiﬁers are induced by means of algo-
rithms in pt. 2;
8. Classiﬁers found in pt. 7, are applied to the test set;
9. Quality measures: accuracy and coverage for classiﬁers are applied in order
to compare results obtained, respectively, in pts. 3 and 8.
In the table of Fig. 9.4, the results are collected of results obtained after the
procedure described above is applied. The classiﬁer applied was exhaustive
one; the method was train–and–test. The rough inclusion applied was the
Lukasiewicz t–norm induced μL of Ch. 6, sect. 4.
r
tst trn rulex aex
cex
MI
nil
345 345 5597 0.872 0.994 0.907
0.0
345
1
0
0.0
0.0
0.0
0.0714286 345
1
0
0.0
0.0
0.0
0.142857 345
2
0
0.0
0.0
0.0
0.214286 345
3
7
0.641
1.0
0.762
0.285714 345
4
10
0.812
1.0
0.867
0.357143 345
8
23
0.786
1.0
0.849
0.428571 345 20
96
0.791
1.0
0.850
0.5
345 51
293 0.838
1.0
0.915
0.571429 345 105 933 0.855
1.0
0.896
0.642857 345 205 3157 0.867
1.0
0.904
0.714286 345 309 5271 0.875
1.0
0.891
0.785714 345 340 5563 0.870
1.0
0.890
0.857143 345 340 5574 0.864
1.0
0.902
0.928571 345 342 5595 0.867
1.0
0.904
Fig. 9.4 Train–and–test; Australian Credit; Granulation for radii r; RSES exhaus-
tive classiﬁer; r=granule radius, tst=test set size, trn=train set size, rulex=rule
number, aex=accuracy, cex=coverage
We can compare results expressed in terms of the Michalski index MI
as a measure of the trade–oﬀbetween accuracy and coverage; for template
based methods, the best MI is 0.891, for covering or LEM algorithms the
best value of MI is 0.804, for exhaustive classiﬁer (r=nil) MI is equal to
0.907 and for granular reﬂections, the best MI value is 0.915 with few other
values exceeding 0.900.
What seems worthy of a moment’s reﬂection is the number of rules in the
classiﬁer. Whereas for the exhaustive classiﬁer (r=nil) in non–granular case,
the number of rules is equal to 5597, in granular case the number of rules can
be surprisingly small with a good MI value, e.g., at r = 0.5, the number of
rules is 293, i.e., 5 percent of the exhaustive classiﬁer size, with the best MI
at all of 0.915. This compression of classiﬁer seems to be the most impressive
feature of granular classiﬁers.

326
9 Rough Mereological Calculus of Granules
It is an obvious idea that this procedure can be repeated until a stable
system is obtained to which further granulation causes no change; it is the
procedure of layered granulation, see Artiemjew [1]. The table of Fig. 9.5
shows some best results of this procedure for selected granulation radii. As
coverage in all reported cases is equal to 1.0, the Michalski index MI is equal
to accuracy.
r
acc
cov
0.500000 0.436 1.000
0.571429 0.783 1.000
0.642857 0.894 1.000
0.714286 0.957 1.000
Fig. 9.5 Train–and–test; Australian Credit;(layered–granulation)
This initial, simple granulation, suggests further ramiﬁcations. For in-
stance, one can consider, for a chosen value of ε ∈[0, 1], granules of the
form
gμ(u, r, ε) = {v ∈U : ∀a ∈A.|a(u) −a(v)| ≤ε}
(9.16)
and repeat with these granules the procedure of creating a granular reﬂection
and building from it a classiﬁer.
Another yet variation consists in mimicking the performance of the Lukasie-
wicz based rough inclusion and introducing a counterpart of the granulation
radius in the form of the catch radius, rcatch. The granule is then dependent
on two parameters: ε and rcatch, and its form is
gμ(u, ε, rcatch) = {v ∈U : |{a ∈A : |a(u) −a(v)| ≤ε
|A|
≥rcatch}
(9.17)
Results of classiﬁcation by granular classiﬁer induced from the granular re-
ﬂection obtained by means of granules (9.17) are shown in the table of
Fig. 9.6.
9.4
A Treatment of Missing Values
A particular but important problem in data analysis is the treatment of
missing values. In many data, some values of some attributes are not recorded
due to many factors, like omissions, inability to take them, loss due to some
events etc.
Analysis of systems with missing values requires a decision on how to
treat missing values; Grzymala–Busse and Ming Hu [9] analyze nine such
methods, among them, 1. most common attribute value, 2. concept restricted
most common attribute value, 3. assigning all possible values to the missing

9.4 A Treatment of Missing Values
327
r catch optimal eps
acc
cov
nil
nil
0.845
1.0
0
0
0.555073 1.0
0.071428
0
0.83913 1.0
0.142857
0.35
0.868116 1.0
0.214286
0.5
0.863768 1.0
0.285714
0.52
0.831884 1.0
0.357143
0.93
0.801449 1.0
0.428571
1.0
0.514493 1.0
0.500000
1.0
0.465217 1.0
0.571429
1.0
0.115942 1.0
Fig. 9.6 εopt=optimal value of ε, acc=accuracy, cov=coverage. Best rcatch =
0.1428, εopt = 0.35: accuracy= 0.8681, coverage=1.0
location, 4. treating the unknown value as a new valid value, etc. etc. Their
results indicate that methods 3,4 perform very well and in a sense stand out
among all nine methods.
We adopt and consider two methods, i.e., 3, 4 from the above mentioned.
As usual, the question on how to use granular structures in analysis of in-
complete systems, should be answered ﬁrst.
The idea is to embed the missing value into a granule: by averaging the
attribute value over the granule in the way already explained, it is hoped
the the average value would ﬁt in a satisfactory way into the position of the
missing value.
We will use the symbol ∗, commonly used for denoting the missing value;
we will use two methods 3, 4 for treating ∗, i.e, either ∗is a don’t care symbol
meaning that any value of the respective attribute can be substituted for ∗,
hence, ∗= v for each value v of the attribute, or ∗is a new value on its own,
i.e., if ∗= v then v can only be ∗.
Our procedure for treating missing values is based on the granular struc-
ture (G(μ, r), G, S, {a∗: a ∈A}); the strategy S is the majority voting,
i.e., for each attribute a, the value a∗(g) is the most frequent of values in
{a(u) : u ∈g}. The strategy G consists in random selection of granules for a
covering.
For an object u with the value of ∗at an attribute a,, and a granule
g = g(v, r) ∈G(μ, r), the question whether u is included in g is resolved
according to the adopted strategy of treating ∗: in case ∗= don′t care, the
value of ∗is regarded as identical with any value of a hence |IND(u, v)| is
automatically increased by 1, which increases the granule; in case ∗= ∗, the
granule size is decreased. Assuming that ∗is sparse in data, majority voting
on g would produce values of a∗distinct from ∗in most cases; nevertheless
the value of ∗may appear in new objects g∗, and then in the process of

328
9 Rough Mereological Calculus of Granules
classiﬁcation, such value is repaired by means of the granule closest to g∗with
respect to the rough inclusion μL, in accordance with the chosen method for
treating ∗.
In plain words, objects with missing values are in a sense absorbed by close
to them granules and missing values are replaced with most frequent values
in objects collected in the granule; in this way the method 3 or 4 in [9] is
combined with the idea of a frequent value, in a novel way.
We have thus four possible strategies:
1. Strategy A: in building granules ∗=don’t care, in repairing values of
∗,
∗=don’t care;
2. Strategy B: in building granules ∗=don’t care, in repairing values of ∗,
∗= ∗;
3. Strategy C: in building granules ∗= ∗, in repairing values of ∗, ∗=don’t
care;
4. Strategy D: in building granules ∗= ∗, in repairing values of ∗, ∗= ∗.
We show how eﬀective are these strategies, see Polkowski and Artiemjew
[20] by perturbing the data set Pima Indians Diabetes, from UCI Repository
[23]. First, in the table of Fig. 9.7 we show results of granular classiﬁer on
the non–perturbed (i.e., without missing values) Pima Indians Diabetes data
set.
r
macc mcov
0.0
0.0
0.0
0.125
0.0
0.0
0.250 0.6835 0.9956
0.375 0.7953 0.9997
0.500 0.9265
1.0
0.625 0.9940
1.0
0.750
1.0
1.0
0.875
1.0
1.0
Fig. 9.7 10-fold CV; Pima; exhaustive algorithm, r=radius,macc=mean accu-
racy,mcov=mean coverage
We now perturb this data set by randomly replacing 10 percent of attribute
values in the data set with missing ∗values. Results of granular treatment
in case of Strategies A,B,C,D in terms of accuracy are reported in the table
of Fig. 9.8. As algorithm for rule induction, the exhaustive algorithm of the
RSES system has been selected. 10–fold cross validation (CV–10) has been
applied.
Strategy A reaches the accuracy value for data with missing values within
94 percent of the value of accuracy without missing values (0.9407 to 1.0) at
the radius of .875. With Strategy B, accuracy is within 94 percent from the
radius of .875 on. Strategy C is much better: accuracy with missing values

9.5 Granular Rough Mereological Classiﬁers Using Residuals
329
r
maccA maccB maccC maccD
0.250
0.0
0.0
0.0
0.645
0.375
0.0
0.0
0.0
0.7779
0.500
0.0
0.0
0.0
0.9215
0.625 0.5211 0.5831 0.5211 0.9444
0.750 0.7705 0.7769 0.7705 0.9994
0.875 0.9407 0.9407 0.9407 0.9987
Fig. 9.8 Accuracies of strategies A, B, C, D. 10-fold CV; Pima Indians; exhaus-
tive algorithm; r=radius,maccA=mean accuracy of A,maccB=mean accuracy of B,
maccC=mean accuracy of C, maccD=mean accuracy of D
reaches 99 percent of accuracy in no missing values case from the radius of
.625 on. Strategy D gives results slightly better than C with the same radii.
We conclude that the essential for results of classiﬁcation is the strategy
of treating the missing value of ∗as ∗= ∗in both strategies C and D; the
repairing strategy has almost no eﬀect: C and D diﬀer very slightly with
respect to this strategy.
9.5
Granular Rough Mereological Classiﬁers Using
Residuals
Rough inclusions used in sects. 9.2 – 9.4 in order to build classiﬁers do take, to
a certain degree, into account the distribution of values of attributes among
objects, by means of the parameters ε and the catch radius rcatch.
The idea that metrics used in classiﬁer construction should depend lo-
cally on the training set is, e.g., present in classiﬁers based on the idea
of nearest neighbor, see, e.g., a survey in Polkowski [18]: for nominal val-
ues, the metric V DM (Value Diﬀerence Metric) in Stanﬁll and Waltz [22]
takes into account conditional probabilities P(d = v|ai = vi) of decision
value given the attribute value, estimated over the training set T rn, and
on this basis constructs in the value set Vi of the attribute ai a metric
ρi(vi, v′
i) = 
v∈Vd |P(d = v|ai = vi) −P(d = v|ai = v′
i)|. The global metric
is obtained by combining metrics ρi for all attributes ai ∈A according to one
of many-dimensional metrics, e.g., Minkowski metrics, see Ch. 2.
This idea was also applied to numerical attributes in Wilson and Martinez
[24] in metrics IV DM (Interpolated VDM) and WV DM (Windowed VDM).
A modiﬁcation of the WV DM metric based again on the idea of using prob-
ability densities in determining the window size was proposed as DBV DM
metric.
In order to construct a measure of similarity based on distribution of at-
tribute values among objects, we resort to residual implications, see Ch.4,

330
9 Rough Mereological Calculus of Granules
sect. 3. As shown in Polkowski [14], ⇒T does induce a rough inclusion on the
interval [0, 1]
μ→T (u, v, r) if and only if x ⇒T y ≥r
(9.18)
This rough inclusion can be transferred to the universe U of an information
system; to this end, ﬁrst, for given objects u, v, and ε ∈[0, 1], factors
disε(u, v) = |{a ∈A : |a(u) −a(v)| ≥ε}|
|A|
(9.19)
and
indε(u, v) = |{a ∈A : |a(u) −a(v)| < ε}|
|A|
(9.20)
are introduced.
The weak variant of rough inclusion μ→T is deﬁned, see Polkowski [14], as
μ∗
T(u, v, r) if and only if disε(u, v) →T indε(u, v) ≥r
(9.21)
Particular cases of this similarity measure induced by, respectively, t–norm
min, t–norm P(x, y), and t–norm L are, see Ch. 6, sect. 7
1. For T = M(x, y) = min(x, y), x ⇒min y is y in case x > y and 1 otherwise,
hence, μ∗
min(u, v, r) if and only if disε(u, v) > indε(u, v) ≥r with r < 1
and 1 otherwise;
2. For t = P, where P(x, y) = x · y, x ⇒P y = y
x when x ̸= 0 and 1 when
x = 0, hence, μ∗
P (u, v, r) if and only if
indε(u,v)
disε(u,v) ≥r with r < 1 and 1
otherwise;
3. For t = L, x ⇒L y = min{1, 1 −x + y}, hence, μ∗
L(u, v, r) if and only if
1 −disε(u, v) + indε(u, v) ≥r with r < 1 and 1 otherwise.
These similarity measures will be applied in building granules and then in
data classiﬁcation. Tests are done with the Australian credit data set; the
results are validated by means of the 5–fold cross validation (CV–5). For
each of t–norms: M, P, L, three cases of granulation are considered, viz.,
1.
Granules of training objects (GT);
2.
Granules of rules induced from the training set (GRT);
3.
Granules of granular objects induced from the training set (GGT).
In this approach, training objects are made into granules for a given ε. Objects
in each granule g about a test object u, vote for decision value at u as follows:
for each decision class c, the value
p(c) =

training object v in g falling in c w(u, v)
size of c in training set
(9.22)
is computed where the weight w(u, v) is computed for a given t–norm T as

9.6 Granular Rough Mereological Classiﬁers with Modiﬁed Voting Parameters331
w(u, v) = disε(u, v) →T indε(u, v)
(9.23)
The class c* assigned to u is the one with the largest value of p.
Weighted voting of rules in a given granule g for decision at test object u
goes according to the formula d(u) = argmaxp(c), where
p(c) =

rule in g pointing to c w(u, r) · support(r)
size of c in training set
(9.24)
where weight w(u, r) is computed as
disε(u, r) →T indε(u, r)
(9.25)
The optimal (best) results in terms of accuracy of classiﬁcation are collected
in the table of Fig. 9.9.
met T εopt macc mcov
GT
M 0.04 0.848
1.0
GT
P 0.06 0.848
1.0
GT
L 0.05 0.846
1.0
GRT M 0.02 0.861
1.0
GRT P 0.01 0.851
1.0
GGT M 0.05 0.855
1.0
GRT P 0.01 0.852
1.0
Fig. 9.9 5-fold CV; Australian; residual metrics. met=method of granulation,
T=t–norm, εopt=optimal ε, macc=mean accuracy,mcov=mean coverage
9.6
Granular Rough Mereological Classiﬁers with
Modiﬁed Voting Parameters
An interesting modiﬁcation of voting schemes of above sections was proposed
and tested in Artiemjew [4]. It consists in weighted voting with modiﬁed
weight computing scheme, viz., the procedure is now as follows. It is consid-
ered in [4] in ﬁve cases, of which we include here two with best results, i.
e., cases 4 and 5. For each attribute a, each training object v, and each test
object u, we denote with the symbol ρtrn(u, v) the quotient
||a(u) −a(v)||
|maxtraining seta −mintraining seta|
(9.26)
where maxtraining seta, mintraining seta are, respectively, the maximal and
the minimal values of the attribute a over the training set; the symbol ||.||
stands for the Euclidean distance in attribute value spaces. Augmented values
of weights are computed in cases 4, 5 in two variants: (a) when ρtrn(u, v) ≥ε
and (b) when ρtrn(u, v) ≤ε.

332
9 Rough Mereological Calculus of Granules
We have in Case 4
w(u, v) =

(a) w(u, v) + ρtrn(u, v) · ε + ||a(u) −a(v)||
(b) w(u, v) + rhotrn(u, v) · ε
(9.27)
and in Case 5
w(u, v) =

(a) w(u, v) + ρtrn(u, v)
(b) w(u, v) + ρtrn(u,v) · ε
(9.28)
Voting procedure consists in computing values of parameters
p1 =

v in positive class w(u, v)
cardinality of positive class
(9.29)
and respectively, p2 by means of (9.29) with ‘positive’ replaced by ‘negative’;
when p1 < p2, the test object u is classiﬁed into the positive class, otherwise
it is classiﬁed into the negative class. Optimal results are shown in the table
of Fig. 9.10. As coverage is 1.0 in each case, we do not show it in the table.
For comparison, we insert also results by RSES exhaustive algorithm and by
RSES implemented k–NN method.
Case
εopt
maxacc minacc
Case4
0.62
0.905
0.861
Case5
0.35 −0.37
0.906
0.880
RSESexh
−
0.862
0.819
RSESk −NN
−
0.884
0.841
Fig. 9.10 Parameterized voting. CV–5. εopt=optimal ε for maxacc, maxacc=max
max fold accuracy, minacc=min max fold accuracy

References
1. Artiemjew, P.: Classiﬁers from granulated data sets: Concept dependent and
layered granulation. In: Proceedings RSKD 2007. Workshop at ECML/ PKDD
2007, pp. 1–9. Warsaw University Press, Warsaw (2007)
2. Artiemjew, P.: On classiﬁcation of data by means of rough mereological
granules of objects and rules. In: Wang, G., Li, T., Grzymala-Busse, J.W.,
Miao, D., Skowron, A., Yao, Y. (eds.) RSKT 2008. LNCS (LNAI), vol. 5009,
pp. 221–228. Springer, Heidelberg (2008)
3. Artiemjew, P.: Rough mereological classiﬁers obtained from weak variants
of rough inclusions. In: Wang, G., Li, T., Grzymala-Busse, J.W., Miao,
D., Skowron, A., Yao, Y. (eds.) RSKT 2008. LNCS (LNAI), vol. 5009,
pp. 229–236. Springer, Heidelberg (2008)
4. Artiemjew, P.: On Strategies of Knowledge Granulation with Applications
to Decision Systems. L.Polkowski (supervisor). PhD Dissertation. Polish–
Japanese Institute of Information Technology, Warszawa (2009)
5. Arkin, H., Colton, R.R.: Statistical Methods. Barnes and Noble, New York
(1970)
6. Bazan, J.G.: A comparison of dynamic and non–dynamic rough set meth-
ods for extracting laws from decision tables. In: Polkowski, L., Skowron, A.
(eds.) Rough Sets in Knowledge Discovery, vol. 1, pp. 321–365. Physica Verlag,
Heidelberg (1998)
7. Bazan, J.G., Nguyen, H.S., Nguyen, S.H., Synak, P., Wr´oblewski, J.: Rough set
algorithms in classiﬁcation problems. In: Polkowski, L., Tsumoto, S., Lin, T.Y.
(eds.) Rough Set Methods and Applications. New Developments in Knowledge
Discovery in Information Systems, pp. 49–88. Physica Verlag, Heidelberg (2000)
8. Bruning, J.L., Kintz, B.L.: Computational Handbook of Statistics, 4th edn.
Allyn and Bacon, Columbus (1997)
9. Grzymala-Busse, J.W., Hu, M.: A Comparison of Several Approaches to Miss-
ing Attribute Values in Data Mining. In: Ziarko, W.P., Yao, Y. (eds.) RSCTC
2000. LNCS (LNAI), vol. 2005, pp. 378–385. Springer, Heidelberg (2001)
10. Michalski, R.: Pattern recognition as rule–guided inductive inference. IEEE
Transactions on Pattern Analysis and Machine Intelligence PAMI 2(4),
349–361 (1990)
11. Nguyen, S.H.: Regularity analysis and its applications in Data Mining. In:
Polkowski, L., Tsumoto, S., Lin, T.Y. (eds.) Rough Set Methods and Applica-
tions. New Developments in Knowledge Discovery in Information Systems, pp.
289–378. Physica Verlag, Heidelberg (2000)

334
References
12. Polkowski, L.: Formal granular calculi based on rough inclusions (a feature
talk). In: Proceedings of IEEE 2005 Conference on Granular Computing, GrC
2005, pp. 57–62. IEEE Press, Beijing (2005)
13. Polkowski, L.: A model of granular computing with applications (a feature
talk). In: Proceedings of IEEE 2006 Conference on Granular Computing, GrC
2006, pp. 9–16. IEEE Press, Atlanta (2006)
14. Polkowski, L.: Granulation of knowledge in decision systems: The approach
based on rough inclusions. The method and its applications. In: Kryszkiewicz,
M., Peters, J.F., Rybi´nski, H., Skowron, A. (eds.) RSEISP 2007. LNCS (LNAI),
vol. 4585, pp. 69–79. Springer, Heidelberg (2007)
15. Polkowski, L.: On the idea of using granular rough mereological structures in
classiﬁcation of data. In: Wang, G., Li, T., Grzymala-Busse, J.W., Miao, D.,
Skowron, A., Yao, Y. (eds.) RSKT 2008. LNCS (LNAI), vol. 5009, pp. 213–220.
Springer, Heidelberg (2008)
16. Polkowski, L.: A Uniﬁed approach to granulation of knowledge and granular
computing based on rough mereology: A Survey. In: Pedrycz, W., Skowron, A.,
Kreinovich, V. (eds.) Handbook of Granular Computing, ch. 16, John Wiley
and Sons Ltd, Chichester (2008)
17. Polkowski, L.: Granulation of Knowledge: Similarity Based Approach in Infor-
mation and Decision Systems. In: Meyers, R.A. (ed.) Encyclopedia of Com-
plexity and System Sciences. Springer, Berlin (2009) Article 00 788
18. Polkowski, L.: Data-mining and Knowledge Discovery: Case Based Reasoning,
Nearest Neighbor and Rough Sets. In: Meyers, R.A. (ed.) Encyclopedia of Com-
plexity and System Sciences. Springer, Berlin (2009) Article 00 391
19. Polkowski, L., Artiemjew, P.: On granular rough computing: Factoring classi-
ﬁers through granulated decision systems. In: Kryszkiewicz, M., Peters, J.F.,
Rybi´nski, H., Skowron, A. (eds.) RSEISP 2007. LNCS (LNAI), vol. 4585,
pp. 280–289. Springer, Heidelberg (2007)
20. Polkowski, L., Artiemjew, P.: On granular rough computing with missing
values. In: Kryszkiewicz, M., Peters, J.F., Rybi´nski, H., Skowron, A. (eds.)
RSEISP 2007. LNCS (LNAI), vol. 4585, pp. 271–279. Springer, Heidelberg
(2007)
21. RSES, http://mimuw.edu.pl/logic/~rses/ (last entered 01. 04. 2011)
22. Stanﬁll, C., Waltz, D.: Toward memory–based reasoning. Communications of
the ACM 29, 1213–1228 (1986)
23. UCI (University of California at Irvine) Repository,
http://archive.ics.uci.edu.ml/ (last entered 01. 04. 2011)
24. Wilson, D.R., Martinez, T.R.: Improved heterogeneous distance functions.
Journal of Artiﬁcial Intelligence Research 6, 1–34 (1997)
25. Wr´oblewski, J.: Adaptive aspects of combining approximation spaces. In:
Pal, S.K., Polkowski, L., Skowron, A. (eds.) Rough Neural Computing. Tech-
niques for Computing with Words, pp. 139–156. Springer, Berlin (2004)

Author Index
Agah, A.
304, 315
Aghazarian, H.
316
Agrawal, R.
151, 187
Ahuja, N.
307, 316
Alexandroﬀ, P.
57, 61
Allen, J.
222, 225
Alves, E.H.
277, 293
Amarel, S.
283, 293
Aristotle
1, 2, 2, 43, 221
Arkin, H.
320, 333
Arkin, R.C.
222, 225, 304, 316
Artiemjew, P.
322, 324, 326, 328, 331,
333, 334
Asama, H.
303, 315
Asher, N.
221, 222
Aurnague, M.
221, 225
Baader, F.
146, 187
Baeck, T.
305, 315
Baire, R.
54, 77
Balcar, B.
24, 41, 43
Balch, T.
304, 315
Baldassare, G.
316
Banach, S.
55, 75
Barnsley, M.F.
156, 187
Barnett, D.
227
Barraquand, J.
298, 300, 307, 317
Barrera, A.
258, 317
Bazan, J.
152, 187, 321, 322, 323, 333
Bekey, G.A.
304, 315
Beltrami, E.
241
Bennett, B.
226
Van Benthem, J.
134, 141, 186, 187,
222, 225, 243, 244, 257, 268, 293,
309, 315
de Berg, M.
298, 315
Bernays, P.
12
Bernstein
29
Birkhoﬀ, G.
26, 43
Bishop, C.M.
186, 187
Black, M.
161, 187
Boche´nski, I.M.
1, 79, 141, 145, 187
Bochman, A.
145, 184, 187
Bonabeau, E.
305, 315
Bonasso, R.P.
227
Booch, G.
222, 225
Borel, E.
29, 43
Borkowski, L.
142
Brandt, D.
318
Bras, M.
225
Bronowski, J.
220, 225
Brooks, R.A.
300, 315
Brown, F.M.
147, 187
Brumitt, B.
308, 315
Bruning, J.L.
321, 334
Bryson, A.E.
289, 292
Burgard, W.
292, 316
Byun, Y.T.
221, 222, 226
Calmet, J.
225
Caloud, P.
303, 315
Calvanese, D.
187
Campari, I.
222, 226
Campbell, J.A.
Canny, J.F.
283, 292, 298, 315, 316

336
Author Index
Cantor, G.
1, 6, 29, 30, 42, 47, 54, 77,
221
Cao, Y.
303, 315
Carnap, R.
134, 141, 145, 187, 267,
292
Casati, R.
199, 200, 209, 222, 225, 226
Chang, C.C.
99, 114, 116, 141, 271,
292
Choi, W.
315
Choset, H.
283, 292, 297, 298, 299,
308, 316
Christensen, D.J.
318
Clarke, B.L.
209, 210, 211, 214, 216,
217, 218, 219, 219, 222, 223, 225
Clay, R.
197, 225
Cohen, R.S.
188
Cohn, A.G.
221, 224, 225, 226, 227
Colombetti, M.
222, 226
Colton, R.R.
320, 333
Cook, S.A.
120, 141
Creswell, M.J.
134, 135, 142, 268,
281, 293
Cui, Z.
225, 227
McCulloch, W.
288, 292
ˇCech, E.
74, 77
Dedekind, R.
20, 27, 28, 42
Deneubourg, J.-L.
316
Dietterich, T. G.
283, 292
Dodds, Z.
302, 318
Dorigo, M.
222, 226, 305, 315, 316
Dubois, D.
186, 187
Duda, R.
145, 187
Egenhofer, M.
222, 224, 226
Engelking, R.
76, 77
Erdmann, M.
304, 307, 316
Estkowski, R.
317
Evans, W.F.
316
Faucett, W.M.
171, 175, 188, 231, 256
Feys, R.
137, 141
Fiorelli, E.
305, 316
Fitting, M.
140, 141, 268, 292
Fleck, L.
161, 188
Floreano, D.
316
Fogel, D.
315
Fort, K.M.
43
Fraenkel, A.
12, 42
Frank, A.U.
222, 226
Frech´et, M.
45, 57, 77
Fredslund, J.
316
Frege, G.
6, 42, 80, 83, 134, 141, 145,
188, 267, 292
Freksa, C.
222, 226, 227
Fukuda, T.
303, 316
Fukunaga, A.S.
315
Gabbay, D.M.
188
Gallin, D.
134, 141, 268, 292
Galton, A.
221, 226
Gambardella, L.
316
Garrett, M.
316
Glasgow, J.
222, 226
G¨odel, K.
12, 89, 141
Goguen, J.A.
118, 141
Goldberg, H.
90, 93, 95, 141
Golledge, R.G.
222, 226
Gooday, J.M.
226
Goodman, N.
209, 227
Gotts, N.M.
221, 224, 225, 226
Gross, R.
316
Grossberg, S.
289, 292
Grzymala–Busse, J.W.
151, 152, 188,
263, 294, 317, 321, 322, 326, 333
Guarino, N.
222, 225
Guerzoni, J.A.D.
277, 292
McGuiness, D.L.
187
Gunther, O.
226
Habel, C.
226
Hahn, H.
71, 77
Hahn, L.
227
H´ajek, P.
80, 106, 116, 118, 120, 141,
231, 256, 268, 272, 293
Hart, P.E.
187
Hausdorﬀ, F.
24, 42, 45, 46, 68
Hazewinkel, M.
77, 189
Hebert, M.
315
Hempel, C.G.
145, 188
Henkin, L.
127, 141, 228, 257
Herbrand, J.
87, 141
Hilbert, D.
241
Hirtle, S.C.
222
Ho, Y.-C.
289, 292
Hogger, C.J.
188
Holland, J.C.
186, 188
Hong, J.
189
Hong, Yu
149

Author Index
337
Hopcroft, J.
307, 316
H´ohle, U.
177, 178, 188
Howard, M.
317
Hughes, G.E.
134, 135, 142, 268, 281,
293
Huntsberger, T.
303, 316
Hutchinson, S.A.
292, 308, 316, 318
Hwang, Y.
307, 316
Imieli´nski, T.
187
Ishida, Y.
315
Iwanu´s, B.
191, 226
Jennings, J.S.
303, 316
Jing, Xing-Jian
256, 317
Joyce, D.
221, 226
Kacprzyk, J.
295
Kahng, A.B.
315
Kanamori, A.
221, 226
Kant, Immanuel
267
Kalman, R.
299, 316
Kamon, I.
297, 316
Kantor, G.
292, 316
Kavraki, L.E.
292, 298, 315, 316
McKenna, W.
227
Khatib, O.
299, 316
Kintz, B.L.
321, 333
Kloesgen, W.
145, 188, 238, 256
Knaster, B.
20, 43
Kolmogorov, A.N.
236, 259
Komorowski, J.
190
Korta, K.
225
Kortenkamp, D.
222, 226
Kr¨ausling, A.
318
Kreinovich, V.
294, 334
van Kreveld, M.
315
Kripke, S.
134, 267, 293
Kryszkiewicz, M.
151, 188
Kube, C.R.
303, 316
Kuhn, W.
222, 226
Kuipers, B.J.
221, 222, 226
Kuratowski, C.
24, 41, 42, 48, 76, 77
Labella, Th.
316
de Laguna, T.
209, 226
Lambert, K.
227
Lan, Fakuan
188
Lang, J.
186, 187
Langford, C.H.
138, 142
Larraz´abal, J.M.
225
Latombe, J.C.
298, 307, 315, 316
Lavrac, N.
189
Leblanc, H.
90, 93, 95
Leibniz, G.W.
119, 145, 146, 188
Lejewski, C.
191, 227
Lemmon, E.J.
135, 142, 281, 293
Leonard, H.
209, 227
Leonard, N.E.
305, 316
Le´sniewski, S.
145, 191, 194, 195, 196,
197, 199, 200, 201, 203, 216, 221,
222, 227
Lewis, C.I.
138, 142
Levitt, T.
221, 222, 226
Li, T.Y.
315
Li, Z.
298, 316
Lin, T.Y.
42, 187, 260, 261, 293, 333
Ling, C.-H.
162, 163, 165, 171, 172,
188, 236, 256
Loemker, L.
188
Lozano-Perez, T.
304, 307, 316
Lumelsky, V.
297, 316
Lynch, K.M.
292, 316
Lukasiewicz, J.
1, 2, 3, 42, 79, 80, 83,
84, 86, 88, 89, 96, 98, 99, 133, 142,
145, 183, 184, 185, 188, 270, 274,
284, 293
Makinson, D.
186, 188
de M`antaras, L.
176, 177, 188
Mark, D.M.
222, 226, 227
Martinez, T.R.
329, 334
Masolo, C.
221, 227
Matari´c, M.
304, 316
Matsumoto, A.
315
Menger, K.
35, 43, 117, 142, 161, 188
Menu, J.
171, 174, 189
Meredith, C.A.
99, 142, 271, 293
Meyers, R.A.
334
Michael, E.
68, 77
Michalewicz, Z.
315
Michalski, R.
152, 189, 320, 333
Mill, J.S.
267
Ming, Hu
152, 188, 263, 292, 321,
322, 326, 334
Mirimanoﬀ, D.
12
Mitchell, T.
145, 151, 183

338
Author Index
Mohanty, J.N.
227
Mondada, F.
316
Montague, R.
134, 142, 267, 293
Moshkov, M.
149, 189
Mostert, P.S.
171, 172, 175, 189, 231,
256
Mostowski, A.
41
Motvani, R.
315
Mozetic, I.
189
Muggleton, S.H.
186, 189
Mundici, D.
120, 142
Murphy, R.
226
Naﬃn, D.
304, 317
Nakagawa, S.
303, 316
Nardi, D.
187
MacNaughton, R.
99, 142
MacNeille, H.M.
20
Von Neumann, J.
12
Nguyen, H.S.
187, 333
Nguyen, S.H.
187, 260, 263, 293, 323,
333
Nieminen, J.
35, 43, 260, 293
Nolﬁ, S.
316
Norvig, P.
186, 190, 297, 318
Nov´ak, V.
106, 142
Novikoﬀ, A.B.
289, 294
Novotny, M.
153, 189
Orlowska, E.
161, 189
O´smialowski, P.
243, 256, 257, 300,
301, 308, 313, 315, 317
Overmars, M.
316, 316
Pal, S.K.
189, 294, 334
Le Pape, C.
315
Parker, L.E.
303, 304, 317
Pasch, M.
241, 242
Patel-Schneider, P.F.
187
Paun, G. 295, 305
Pawlak, Z.
145, 146, 147, 149, 150,
153, 189, 277, 294
Pavelka, J.
171, 189,
Payton, D.
305
Pedrycz, W.
294, 334
Pfalzgraf, J.
225
Pitts, W.
288, 293
Plutarch
191, 227
Poincar´e, H.
35, 42, 239, 257
Polkowski, L.
35, 42, 68, 76, 77, 153,
154, 155, 156, 157, 187, 189, 230,
231, 243, 254, 255, 257, 260, 263,
266, 283, 285, 289, 291, 293, 294,
300, 308, 309, 311, 312, 317, 322,
328, 329, 330, 333, 334
Pompe¨ıu, D.
68, 77
Popper, K.
145, 189
Post, E.
80, 89, 142
Prade, H.
186, 187
Powell, M.
316
Quinlan, J.R.
186, 189
Raghavan, P.
315
Ram´on y Cajal, S.
288, 295
Randell, D.
222, 225, 227
Rasiowa, H.
21, 40, 43, 64, 77, 83, 85,
86, 114, 121, 125, 127, 129, 132,
142, 158, 160, 161
Rauszer, C.M.
147, 149, 190, 311, 318
Reichenbach, H.
222, 227
Reynolds, C.
304, 317
Rickey, V.F.
227
Riemann, B.
167, 221
Riesz, F.
48, 78
Rimon, E.
316
Rissanen, J.
186, 190
Rival, I.
43
Rivlin, E.
316
Robinson, J.A.
119, 142
Rose, A.
99, 100, 101, 105, 106, 109,
110, 113, 142
Rosenblatt, F.
288, 295
Rosser, B.J.
96, 99, 100, 101, 105,
106, 109, 113, 142
Ruspini, E.H.
175, 190
Russell, B.
195
Russell, S.J.
186, 190, 297, 318
Rybi´nski, H.
151, 188
Sablayrolles, P.
225
Sahin, E.
316
Salomaa, A.
295
Scheck, H.
226
Schneider, F.
306, 318
Schnelle, T.
188
Schwartz, J.T.
298, 307, 316, 318

Author Index
339
Schweitzer, B.
18, 143, 145, 166, 174,
190, 201, 228
Scott, D.S.
135, 142, 183, 184, 185,
190, 284, 295
Segerberg, K.
142
Seising, R.
161, 190
Semeniuk-Polkowska, M.
266, 294
Shao, J.
306, 318
Sharir, M.
298, 307, 316, 318
Shaw, I.
221, 227
Shields, A.L.
171, 172, 175, 189, 231,
256
Shreider, Yu.
36
Sikorski, R.
40, 42, 64, 77, 83, 85, 86,
114, 121, 125, 127, 129, 132, 161
Simons, P.
200, 227
Sklar, A.
117, 143, 145, 166, 174, 190,
201, 228
Skolem, T.
12
Skowron, A.
42, 76, 78, 147, 149, 150,
151, 158, 160, 187, 189, 190, 230,
243, 257, 283, 294, 311, 318, 333,
334
Slowi´nski, R.
77, 188, 189, 318
Slupecki, J.
1, 5, 42, 191, 192, 227
Smith, B.
221, 222, 225, 226, 227
Soboci´nski, B.
191, 195, 227
Srzednicki, J.
227
Stanﬁll, C.
329, 334
Stefanowski, J.
389, 400
Stentz, A.
315
Stepanov, A. 297, 316
Stone, M.H.
62, 78
Stone, P.
283, 295
Stork, D.G.
187
Stoy, K.
305, 318
Stroupe, A.
316
Sugihara, K.
306, 318
Suppes, P.
228, 257
Suraj, Z.
189
Surma, S.J.
227
Suthname, G.
304, 318
Suzuki, I.
306, 318
Swami, A.
187
Synak, P.
187, 333
Szmigielski, A.
243, 257
ˇSvestka, P.
316
ˇStˇep´anek, P.
24, 41
Tarski, A.
19, 27, 28, 40, 43, 89, 99,
123, 142, 191, 194, 197, 203, 207,
216, 221, 227, 241, 242, 243, 244,
245, 257, 268, 271, 293
Theraulaz, G.
315
Thrun, S.
292, 316
Tikhonov, A.N.
62, 78
Trianni, V.
316
Tribelhorn, B.
302, 318
Tsoukias, A.
389, 400
Tsumoto, S.
187, 293, 333
Turing, A.M.
288, 295
Turquette, A.R.
96, 105, 106, 143
Urysohn, P.
61
La Valle, S.M.
308, 318
Vapnik, V.N.
186, 190
Varzi, A.C.
199, 200, 209, 225, 226
Vakarelov, D.
161, 190
Valverde, L.
176, 179, 181, 188, 190
Vaught, R.L.
26, 43
Vietoris, L.
68, 78
Vieu, L.
221, 222, 225, 227
Wajsberg, M.
89, 95, 100, 113, 143,
271, 295
Walter, W.G.
303, 318
Waltz, D.
329, 334
Wang, G.
188
Wang, L.
318
Weaver, G.
89, 93, 95
Whelan, G.
316
White, G.
226
Whitehead, A.N.
191, 209, 221, 228
Wildberger, M.
42
Wildermuth, D.
318
Wille, R.
41, 43, 262, 295
Wilson, E.O.
304, 318
Wilson, D.R.
329, 334
Wiweger, A.
76, 78
Woodger, J.H.
203, 207, 228, 228
Von Wright, G.H.
140, 143
Wr´oblewski, J.
187, 323, 333, 334
Xie, G.
318
Yao, Y.Y.
261, 295
Yin, M.
315
Younse, P.
316
Yu, J.
318

340
Author Index
Zadeh, L.A.
116, 118, 143, 161, 175,
177, 181, 190, 229, 254, 255, 257,
259, 278, 279, 293
Zeeman, E.C.
35, 43
Zermelo, E.
12, 24, 42
Zhang, H.
303, 316
Zorn, M.
24, 43
Zytkow, J.
42, 145, 188, 238, 256

Term Index
airi
237
algorithm
bug
297
decision
151, 319
Apriori
151
covering
151
exhaustive
151
LERS
151
sweeping
298
alternation
81
approximation
147
B–lower
147
B–upper
147
space
158
atom
40
attribute
146
conditional
148
decision
148
value
146
language
146
axiom
B–continuity
242
B–Eq–ﬁve segment
243
B–Eq–parallel
243
B–Eq–segment extension
243
B–Eq–upper dimension
242
B–identity
242
B–lower dimension
242
B–Pasch
242
of choice
24
empty set
12
extensionality
13
inﬁnity
22
ontology
191
power set
14
prelinearity
99
schema of replacement
14
schema of separation
14
union of sets
13
unordered pair
13
well–ordering
24
belief
185
Boolean algebra
21
atomic
40
complete
60
completion of
64
C–quasi
216
mereological
197
boundary
48
B–
147
C–
222
mereotopological
203
calculus
80
perceptions
278
predicates
121
propositional
80
RCC
222
sentential
80
Cantor cube
50
Cartesian product
15, 50
topological spaces
68
cell
207
division
208
fusion
208
chain
18

342
Term Index
maximal
26
class
deﬁnable
147
equivalence
34
fuzzy
176
mereological
193
connection
215
similarity
177
tolerance
36
classiﬁcation
146
classiﬁer
319
clause
119
Horn
120
closure
48, 58
C–
219
mapping
21
mereotopological
201
operator
58
ˇCech
74
complementation
200
component
37
conjunction
81
connection
209
Galois
21
lower adjoint
21
upper adjoint
21
concept
1
co–norm
162
contraction factor
55
contradictories
5
contraries
4
covering
52
decision
181
fuzzy
182
generalized
149
rule
148
fuzzy
182
association
151
accuracy
321
consistency degree
151
coverage
321
matching factor
322
optimal
151
speciﬁcity
152, 321
strength
152, 322
support
151, 322
true, certain
149
system
148
deterministic
149
deductive system
83
dependence
152
functional
152
partial
152
derivation
83
derivation rule
83
detachment
106, 125
EE
127
EU
127
IE
125
IU
125
modus ponens
necessitation
135
substitution
104, 125
descriptor
146
detachment
106, 125
discernibility matrix
147
disjunction
81
element
7
greatest
19
in mereology
195
least
19
maximal
25
minimal
25
unit
39
zero
38
embedding
19
equipotency
28
explanation
183
extent
245
extension
269
family of sets
13
ﬁeld of sets
11
ﬁlter
33
cluster point
62
Frech´et
33
in a lattice
39
limit point
62
prime
40
principal
32
ﬁxed point
20
formation of robots
307
ideal
310
real
310
fractal
157
function
17

Term Index
343
archimedean
162
bijective
18
characteristic
50
continuous
66
lower semi–
170
upper semi–
170
contracting
56
distance
46
fuzzy membership
117
image
18
inverse
18
injective
18
inverse
18
isotone
20
iterated system of
157
logic propagation
284
pseudo–inverse
162
semi–continuous lower
72
upper
72
surjective
18
uncertainty propagation
285
synthesis
284
Galois connection
21
gradient descent
300
granule of knowledge
268
indiscernibility
262
rough inclusion
265
granular
agent
285
classiﬁer
324
reﬂection
325
granulation of knowledge
263
concept dependent
324
layered
326
granule
263
Hamming distance
239
Hilbert cube
63
homeomorphism
65
hyperspace
68
ideal
33
maximal
33
principal
32
image
17
inverse
17
implication
81
Goguen
118
G¨odel
118
Lukasiewicz
118
residual
118
dual
176
indri
239
inference
4, 193
information system
146
ingredient
192
connection
209
tangential
213
non–tangential
213
intension
269
interior
47
C–
219
mapping
21
operator
57
interpretation
122
–frame
122, 149
isomorphism
19
JEPD
223
join
21
knowledge
1, 185
base
119
lattice
22
complemented
39
distributive
38
relatively pseudo–complemented
39
law
associativity
8
commutativity
8
distributivity
9, 10
idempotency
8
Leibniz
146
de Morgan,
10
Lindenbaum–Tarski algebra
85, 86,
125
logic
79
deductive
79
modal
133
K
133
S4
138
S5
138
T
137
n–valued
95
predicate
121
propositional
80
reductive
79
residual implication
116

344
Term Index
rough concepts
158
rough mereological
266
3–valued
88
[0,1]–valued
99
lower bound
18
greatest
19
mapping
21
closure
21
interior
21
maximum principle
24
meaningful expression
81
meet
21
mereology
191
closure
200
extensional
200
minimal
200
extensional
200
general
200
ground
199
minimal
200
metric
46
Euclidean
46
space
46
compact
51
complete
53
Hausdorﬀ–Pompe´ıu
68
on rough sets
154
Manhattan
46
natural
45
Michalski index
321
missing value
326
model
canonical
135
overlap OVM
209
regular open ROM
213
rough inclusion
231
archimedean
234
geometric
236
information
237
metric
287
residual
231
set
236
3–valued
240
momentary object
205
monotonicity condition
230
MV–algebra
114
necessity M
133
neighbor
45
nearest
45
neighborhood
46
basis
48
negation
80
neuron
288
McCulloch–Pitts
288
non–monotonic reasoning
183
open ball
46
open formula
132
open set
46, 58
ordered pair
13
k–tuple
13
ordering relation
18
complete
19
linear
19
well
24
overlap model
209
part
191
improper
223
proper
223
–to a degree
273
partition
34
fuzzy
179
reﬁnement
34
perceptron
288
rough mereological
290
possibility L
133
possible world
134
semantics
134
potential ﬁeld
299
from rough inclusion
300
predicate
121
prenex form
131
prime implicant
148
property
cut
183
JEPD
223
linearity
32
momentary in time
204
monotonicity
183
reﬂexivity
33
symmetry
34
transitivity
34
weak anti–symmetry
18
proposition
80
accepted
96
to a degree
96

Term Index
345
approximate collage
156
Baire category
54
Banach ﬁxed point
55
Birkhoﬀ
26
Cantor diagonal
30
Cantor–Bernstein
29
completeness for predicate logic
129
propositional logic
86
modal system K
137
modal system T
137
modal system S4
138
modal system S5
138
system W
95
completeness for [0,1]–valued logic
Dedekind–MacNeille
20
deduction for [0,1]–valued logic
106
Hahn
71
Herbrand on deduction
87
Knaster–Tarski
19
Ling structure
165
Mostert–Shields
172
Rasiowa–Sikorski
40, 64
strong completeness for system L
92
Tikhonov
63
variable
80
Vaught
26
pseudo–complement
39
radius
catch
326
granule
263
reasoning
79
deductive
79
inductive
147
non–monotonic
183
reductive
79
reduct
147
δ–
149
relative
149
reference
134
referencing technique
304
leader
304
neighbor
304
unit–center
304
region
224
positive
149
regular open model (ROM)
213
relation
15
accessibility
134
ingredient
282
betweenness
242
in Tarski sense
243
in VanBenthem sense
244
rough mereological
309
binary
15
codomain
15
coincidence in time
204
complement
196
composition
16
connectedness, being connected
external
211
consequence
83
Scott
183
disconnected from
223
discrete from
223
domain
15
equidistance
242
equivalence
33
–fuzzy
175
exteriority
199
fuzzy similarity
175
identity
17
indiscernibility
146
inverse
16
likeness
175
nearness
244
rough mereological
308
overlap
193
probabilistic similarity
175
restriction
17
superposition
16
tolerance
35
wholly before in time
205
residual implication
145, 232, 273
resolution
119
rule
119
rough inclusion
230
discrete
240
gaussian
289
symmetric
241
3–valued
240
rough mereology
231
RSES
151
selector
24
sense
134
sequence
49

346
Term Index
converging
49
fundamental
53
limit
49
set
clopen
48
closed
47, 57
regular
58
countable
30
diameter of
54
empty
12
equipotent
28
exact
147
π0–
154
family
13
centered
52
ﬁnite
26
in Dedekind sense
26
in Tarski sense
27
1st category
55
fuzzy
116
image of
15
inﬁnite
22
linearly ordered
18
well–ordered
23
meager
55
nowhere dense
55
open
46, 57
regular
58
power
12
quotient
34
rough
147
π0–
153
indent test
319
training
319
union of
27
silhouette
298
method
298
space
45
metric
45
compact
51
complete
53
quotient
67
Stone
63
topological
56
compact
61
extremally disconnected
64
sub–alternates
5
sub–contraries
4
subset
11
dense
40
in mereology
195
substitution
3
supplementation postulate
200
strong
200
weak
200
syllogism
2
middle term of
4
predicate of
4
premise
4
major
4
minor
4
subject
4
theorem
83
time–slice
206
ﬁrst, beginning
206
last, ending
206
t–norm
117
Archimedean
162
Lukasiewicz
118
minimum
117
product
117
topological space
56
compact
61
extremally disconnected
64
quotient
67
0–dimensional
63
topology
56
ˇCech
73
ground
hit–or–miss
68
π0–
153
Vietoris
68
upper bound
18
least
19
ultraﬁlter
32
unit element
38
unordered pair
13
k–tuple
14
valuation
92, 123
visibility graph
298
Vorono¨ı diagram
298
Zermelo–Fraenkel system
12
zero element
38

