CODE LISTINGS AND FIGURES

CHAPTER 1
1 document.querySelector('#msg').innerHTML = '<h1>Hello World</h1>';
1
2
3
4
5
6
function printMessage(elementId, format, message) { 
     document.querySelector(`#${elementId}`).innerHTML = 
         `<${format}>${message}</${format}>`; 
} 
 
printMessage('msg', 'h1','Hello World');
Listing 1.1. Functional printMessage
1
2
3
var printMessage = run(addToDom('msg'), h1, echo); 
 
printMessage('Hello World');
Listing 1.2. Extending printMessage
1
2
3
var printMessage = run(console.log, repeat(3), h2, echo); 
 
printMessage('Get Functional');
1
2
3
4
5
var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
for(let i = 0; i < array.length; i++) { 
   array[i] = Math.pow(array[i], 2); 
} 
array; //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

TRANSLATING LAMBDA NOTATION TO REGULAR FUNCTION
NOTATION
Lambda expressions provide an enormous syntactical advantage over
regular function notations because they reduce the structure of a
function call down to the most important pieces. This ES6 lambda
expression
is equivalent to the following function:
1
2
3
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num, 2)); 
 
//-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
1 num => Math.pow(num, 2)
1
2
3
function(num) { 
  return Math.pow(num, 2); 
}
1
2
3
4
var counter = 0; 
function increment() { 
   return ++counter; 
}

Figure 1.1. Function increment()  causes side effects by reading/modifying an
external variable, counter . Its result is unpredictable because counter  can
change at any time between calls.
Listing 1.3. Imperative showStudent  function with side effects
1
2
3
4
5
6
7
8
9
10
11
12
13
function showStudent(ssn) { 
    var student = db.get(ssn); 
    if(student !== null) { 
        document.querySelector(`#${elementId}`).innerHTML = 
          `${student.ssn},    
           ${student.firstname}, 
           ${student.lastname}`;   
    } 
    else { 
        throw new Error('Student not found!'); 
    } 
} 
 showStudent('444-44-4444');
1
2
3
4
Listing 1.4. Decomposing the showStudent  program
1
2
3
4
5
6
7
8
9
10
11
12
13
var find = curry(function (db, id) { 
    var obj =  db.get(id);            
    if(obj === null) { 
       throw new Error('Object not found!'); 
    } 
    return obj; 
}); 
var csv = (student) { 
   return `${student.ssn}, ${student.firstname}, ${student.lastname}`; 
}; 
var append = curry(function (elementId, info) { 
   document.querySelector(elementId).innerHTML = info; 
});
1
2
3

Figure 1.2. Comparison of working with imperative and functional versions of
increment . The result of the imperative version is unpredictable and can be
inconsistent because the external counter  variable may change at any time,
compromising the result of successive invocations of the function. The referentially
transparent functional version is always equationally correct and leaves no room for
errors.
1
2
3
4
5
var counter = 0; 
 
function increment() { 
    return ++counter; 
}
1 var increment = counter => counter + 1;
1 Program = [Input] + [func1, func2, func3, ...] -> Output

Figure 1.3. The process of decomposing breaks showStudent  into smaller parts.
These subtasks are independent and simpler to understand, so that when combined,
they help solve the bigger picture.
1
2
3
var input = [80, 90, 100]; 
var average = (arr) => divide(sum(arr), size(arr)); 
average (input); //-> 90
1 var average = divide(270, 3); //-> 90
1
2
3
4
5
var sortDesc = function (arr) { 
  return arr.sort(function (a, b) { 
     return b - a; 
  }); 
}
1
2
var arr = [1,2,3,4,5,6,7,8,9]; 
sortDesc(arr); //-> [9,8,7,6,5,4,3,2,1]

Figure 1.4. The Øow of data when composing two functions. The return value from
find  must be compatible in type and arity with the arguments to csv , which in turn
returns information that append  can use. Note that in order to make the Øow of data
clear, I Øipped the order of the function calls.
1 f • g = f(g(x))
1
2
3
var showStudent = compose(append('#student-info'), csv, find(db)); 
 
showStudent('444-44-4444');
1
2
3
4
5
let enrollment = [ 
  {enrolled: 2, grade: 100}, 
  {enrolled: 2, grade: 80}, 
  {enrolled: 1, grade: 89} 
];
1
2
3
4
var totalGrades = 0; 
var totalStudentsFound = 0; 
for(let i = 0; i < enrollment.length; i++) { 
    let student = enrollment [i]; 

5
6
7
8
9
10
11
12
    if(student !== null) { 
       if(student.enrolled > 1) { 
          totalGrades+= student.grade; 
          totalStudentsFound++; 
       } 
    } 
 } 
 var average = totalGrades / totalStudentsFound; //-> 90
Listing 1.5. Programming with function chains
1
2
3
4
5
_.chain(enrollment) 
  .filter(student => student.enrolled > 1) 
  .pluck('grade') 
  .average() 
  .value(); //-> 90
1
Listing 1.6. Imperative program that reads and validates a student’s SSN
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
var valid = false; 
var elem = document.querySelector('#student-ssn'); 
elem.onkeyup = function(event) { 
   var val = elem.value; 
   if(val !== null && val.length !== 0) {  
      val = val.replace(/^\s*|\s*$|\-s/g, ''); 
      if(val.length === 9) { 
         console.log(`Valid SSN: ${val}!`); 
         valid = true; 
       }            
   } 
   else { 
      console.log(`Invalid SSN: ${val}!`);       
   } 
};
1
1
2
3
Listing 1.7. Functional program that reads and validates a student’s SSN
1
2
3
4
5
6
7
8
Rx.Observable.fromEvent(document.querySelector('#student-ssn'), 'keyup') 
   .map(input => input.srcElement.value) 
   .filter(ssn => ssn !== null && ssn.length !== 0) 
   .map(ssn => ssn.replace(/^\s*|\s*$|\-/g, '')) 
   .skipWhile(ssn => ssn.length !== 9) 
   .subscribe( 
      validSsn => console.log(`Valid SSN ${validSsn}`) 
    );


CHAPTER 2
Figure 2.1. Object-oriented programming promotes logically connecting many data
types with specialized behavior, whereas functional programming focuses on
connecting operations on those data types via composition. There’s a sweet spot
where both paradigms can be used productively. Hybrid languages like Scala, F#, and
JavaScript allow you to work with both.
Figure 2.2. The focus of OOP is to create inheritance hierarchies (such as Student
from Parent ) with methods and data tightly bound together. Functional
programming, on the other hand, favors general polymorphic functions that crosscut
different data types and avoid the use of this .

Listing 2.1. De×ning the Person  and Student  classes
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
class Person { 
   constructor(firstname, lastname, ssn) { 
      this._firstname = firstname; 
      this._lastname = lastname; 
      this._ssn = ssn; 
      this._address = null; 
      this._birthYear = null; 
   } 
   get ssn() { 
       return this._ssn; 
   } 
   get firstname() { 
       return this._firstname; 
   } 
   get lastname() { 
      return this._lastname; 
   } 
   get address() { 
      return this._address; 
   } 
   get birthYear() { 
      return this._birthYear; 
   } 
   set birthYear(year) { 
      this._birthYear = year;  
   } 
   set address(addr){ 
      this._address = addr; 
   } 
   toString() { 
      return `Person(${this._firstname}, ${this._lastname})`; 
   }     
} 
class Student extends Person { 
   constructor(firstname, lastname, ssn, school) { 
      super(firstname, lastname, ssn); 
      this._school = school; 
   } 
   get school() { 
1

40
41
42
      return this._school; 
   } 
 }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
var curry = new Student('Haskell', 'Curry', 
     '111-11-1111', 'Penn State'); 
curry.address = new Address('US'); 
 
var turing = new Student('Alan', 'Turing', 
     '222-22-2222', 'Princeton'); 
turing.address = new Address('England'); 
 
var church = new Student('Alonzo', 'Church', 
   '333-33-3333', 'Princeton'); 
church.address = new Address('US'); 
 
var kleene = new Student('Stephen', 'Kleene', 
    '444-44-4444', 'Princeton'); 
kleene.address = new Address('US');
1
2
church.studentsInSameCountryAndSchool([curry, turing, kleene]); 
//-> [kleene]

Table 2.1. Comparing some important qualities of object-oriented and functional
programming. These qualities are themes that are discussed throughout this book.
 
Functional
Object-oriented
Unit of
composition
Functions
Objects (classes)
Programming
style
Declarative
Imperative
Data and behavior
Loosely coupled into pure,
standalone functions
Tightly coupled in classes
with methods
State management
Treats objects as immutable
values
Favors mutation of objects
via instance methods
Control ow
Functions and recursion
Loops and conditionals
Thread safety
Enables concurrent programming
Di}cult to achieve
Encapsulation
Not needed because everything is
immutable
Needed to protect data
integrity
1
2
3
4
function zipCode(code, location) { 
   let _code = code; 
   let _location = location || ''; 
 

5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
   return { 
      code: function () { 
         return _code; 
      }, 
      location: function () { 
         return _location; 
      }, 
      fromString: function (str) { 
         let parts = str.split('-'); 
         return zipCode(parts[0], parts[1]); 
      }, 
      toString: function () { 
         return _code + '-' + _location; 
      } 
   }; 
} 
 
const princetonZip = zipCode('08544', '3345'); 
princetonZip.toString(); //-> '08544-3345'
1 greenwich.translate(10, 10).toString(); //-> '(61.4778, 10.0015)'
1 TypeError: Cannot assign to read only property '_firstname' of #<Person>

Figure 2.3. Although the Person  type has been frozen, its internal object properties
(like _address ) haven’t. So person.address.country  is eligible to be changed
at any time. Because only the top-level variables are frozen, this is a shallow freeze.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
class Address { 
   constructor(country, state, city, zip, street) { 
     this._country = country; 
     this._state = state; 
     this._city = city; 
     this._zip = zip; 
     this._street = street; 
   } 
 
   get street() { 
      return this._street; 
   } 
 
   get city() { 
      return this._city; 
   } 
 
   get state() { 
      return this._state; 
   } 
 
   get zip() { 
      return this._zip; 
   } 
 
   get country() { 
      return this._country; 
   } 
}

1
2
3
4
5
6
7
8
9
var person = new Person('Haskell', 'Curry', '444-44-4444'); 
person.address = new Address( 
    'US', 'NJ', 'Princeton', 
     zipCode('08544','1234'), 'Alexander St.'); 
 
   person = Object.freeze(person); 
 
person.address._country = 'France'; //-> allowed! 
person.address.country; //-> 'France'
Listing 2.2. Recursive function to deep-freeze an object
1
2
3
4
5
6
7
8
9
10
var isObject = (val) => val && typeof val === 'object'; 
   function deepFreeze(obj) { 
    if(isObject(obj) 
      && !Object.isFrozen(obj)) { 
        Object.keys(obj). 
            forEach(name => deepFreeze(obj[name])); 
        Object.freeze(obj); 
    } 
    return obj; 
   }
1
2
3
4
5
1
2
var person = new Person('Alonzo', 'Church', '444-44-4444'); 
var lastnameLens = R.lenseProp('lastName');
1 R.view(lastnameLens, person); //-> 'Church'
1
2
var newPerson = R.set(lastnameLens, 'Mourning', person); 
newPerson.lastname; //-> 'Mourning' 

Assigned to object properties as methods:
3 person.lastname; //-> 'Church'
1
2
3
person.address = new Address( 
   'US', 'NJ', 'Princeton', zipCode('08544','1234'), 
   'Alexander St.');
1
2
3
4
5
var newPerson = R.set(zipLens, person, zipCode('90210', '5678')); 
 
R.view(zipLens, newPerson); //-> zipCode('90210', '5678') 
R.view(zipLens, person);    //-> zipCode('08544', '1234') 
newPerson !== person; //-> true
1
2
3
function multiplier(a,b) { 
   return a * b; 
}
1
2
3
var obj = { 
   method: function (x) { return x * x; } 
};
1
2
3
4
square; 
// function (x) { 
//    return x * x; 
// }

1
2
3
var multiplier = new Function('a', 'b', 'return a * b'); 
 
multiplier(2, 3); //-> 6
1 people.sort((p1, p2) => p1.getAge() p2.getAge());

LOOKING AHEAD
I want to briey pause my discussion of core JavaScript material to
elaborate further on the program in this section and combine some
concepts I’ve briey touched on. This is a bit advanced for now, but
soon you’ll learn how to build programs this way using FP techniques.
You can create supporting functions using lenses that you can use to
access an object’s properties:
This is much more functional than before:
1
2
3
4
5
6
7
8
9
10
11
12
13
function printPeople(people, action) { 
   for (let i = 0; i < people.length; i++) { 
      action (people[i]); 
   } 
} 
 
var action = function (person) { 
   if(person.address.country === 'US') { 
      console.log(person); 
   } 
} 
 
printPeople(people,action);
1
2
3
4
var countryPath = ['address', 'country']; 
var countryL = R.lens(R.path(countryPath), R.assocPath(countryPath
var inCountry = R.curry((country, person) => 
       R.equals(R.view(countryL, person), country));
1 people.filter(inCountry('US')).map(console.log);

As you can see, the country name becomes another parameter that can
be changed to anything you want. This is something to look forward to
in the following chapters.
1
2
3
Function.prototype.apply(thisArg, [argsArray]) 
 
Function.prototype.call(thisArg, arg1,arg2,...)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
function zipCode(code, location) { 
    let _code = code; 
    let _location = location || ''; 
 
    return { 
       code: function () { 
         return _code; 
       }, 
       location: function () { 
          return _location; 
       }, 
     ... 
   }; 
}
1
2
const princetonZip = zipCode('08544', '3345'); 
princetonZip.code(); //-> '08544'

Figure 2.4. A closure contains variables that appear in the outer (global) scope, the
parent function’s inner scope, and the parent function’s parameters and additional
variables declared after the function declaration. The code de×ned in the function’s
body can access variables and objects de×ned in each of these scopes. All functions
share the global scope.
Listing 2.3. Closures at work
1
2
3
4
5
6
7
8
9
var outerVar = 'Outer'; 
function makeInner(params) { 
   var innerVar = 'Inner'; 
   function inner() { 
      console.log( 
        `I can see: ${outerVar}, ${innerVar}, and ${params}`); 
   } 
   return inner; 
} 
1
2
3

Figure 2.5. JavaScript’s name-resolution order, which ×rst looks into the closest scope
level surrounding a variable lookup and moves outward. It ×rst checks the function’s
scope (local), then moves into its parent’s scope (if there is one), and ×nally moves into
the global scope. If the variable x  isn’t found, the function returns undefined .
10
11
var inner = makeInner('Params'); 
inner();
45
1 'I can see: Outer, Inner, and Params'
1
2
3
4
5
function doWork() { 
   let student = new Student(...); 
   let address = new Address(...); 
   // do more work 
};
1
2
3
4
5
6
7
8
9
var x = 'Some value'; 
function parentFunction() { 
   function innerFunction() { 
      console.log(x); 
   } 
   return innerFunction; 
} 
var inner = parentFunction(); 
inner();
1
2
3
if (someCondition) { 
   var myVar = 10; 
}

1
2
3
4
5
6
7
function doWork() { 
   if (!myVar) { 
     var myVar = 10; 
   } 
   console.log(myVar); //-> 10 
} 
doWork();
Listing 2.4. Ambiguous loop-counter problem
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
var arr = [1, 2, 3, 4]; 
function processArr() { 
 
   function multipleBy10(val) { 
        i = 10; 
        return val * i; 
   } 
 
   for(var i = 0; i < arr.length; i++) { 
      arr[i] = multipleBy10(arr[i]); 
   } 
 
   return arr; 
} 
processArr(); //-> [10, 2, 3, 4]

1
2
3
arr.forEach(function(elem, i) { 
   ... 
});

CHAPTER 3
Figure 3.1. An imperative program made up of a series of operations (or statements)
controlled by branches and loops
Figure 3.2. Functional control among connected black-box operations. Information
Øows independently from one operation to the next (the operations are individual,
pure functions). Branches and iterations are effectively reduced or even eliminated in
favor of high-level abstractions.
1
2
3
4
5
6
7
8
9
10
11
12
var loop = optC(); 
while(loop) { 
   var condition = optA(); 
   if(condition) { 
     optB1(); 
   } 
   else { 
     optB2(); 
   } 
   loop = optC(); 
} 
optD();

Figure 3.3. Dissecting the structure of arrow functions. The right side of a lambda
function is either a single expression or an enclosed set of multiple statements.
1 'Functional Programming'.substring(0, 10).toLowerCase() + ' is fun';
1 concat(toLowerCase(substring('Functional Programming', 1, 10))),' is fun');
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
const p1 = new Person('Haskell', 'Curry', '111-11-1111'); 
p1.address = new Address('US'); 
p1.birthYear = 1900; 
 
const p2 = new Person('Barkley', 'Rosser', '222-22-2222'); 
p2.address = new Address('Greece'); 
p2.birthYear = 1907; 
 
const p3 = new Person('John', 'von Neumann', '333-33-3333'); 
p3.address = new Address('Hungary'); 
p3.birthYear = 1903; 
 
const p4 = new Person('Alonzo', 'Church', '444-44-4444'); 
p4.address = new Address('US'); 
p4.birthYear = 1903;
1
2
const name = p => p.fullname; 
console.log(name(p1)); //-> 'Haskell Curry'

Figure 3.4. The map  operation applies an iterator function f  to each element in an
array and returns an array of equal length.
1 map(f, [e0, e1, e2...]) -> [r0, r1, r2...];  where, f(dn) = rn

Figure 3.5. Reducing an array into a single value. Each iteration returns an accumulated
value based on the previous result; this accumulated value is kept until you reach the
end of the array. The ×nal outcome of reduce  is always a single value.
1 ['Haskell Curry', 'Barkley Rosser', 'John von Neumann', 'Alonzo Church']
Listing 3.1. Map implementation
1
2
3
4
5
6
7
8
9
function map(arr, fn) { 
   let idx    = 0, 
       len    = arr.length,   
       result = new Array(len); 
   while (++idx < len) { 
       result[index] = fn(array[idx], idx, arr); 
   }       
   return result; 
}
1
2
3
1
2
3
_(persons).reverse().map( 
    p => (p !== null && p !== undefined) ? p.fullname : '' 
);
1 reduce(f,[e0, e1, e2, e3],accum) -> f(f(f(f(acc, e0), e1, e2, e3)))) -> R

Listing 3.2. Implementing reduce
1
2
3
4
5
6
7
8
9
10
11
12
function reduce(arr, fn,[accumulator]) { 
   let idx = -1, 
       len = arr.length; 
   if (!accumulator && len > 0) { 
      accumulator = arr[++idx]; 
   } 
   while (++idx < len) { 
      accumulator = fn(accumulator, 
      arr[idx], idx, arr); 
   } 
   return accumulator; 
}
1
2
3
Listing 3.3. Computing country counts
1
2
3
4
5
6
_(persons).reduce(function (stat, person) { 
    const country = person.address.country; 
    stat[country] = _.isUndefined(stat[country]) ? 1 : 
         stat[country] + 1; 
    return stat; 
}, {});
1
2
3
4
1
2
3
4
5
{ 
   'US'     : 2, 
   'Greece' : 1, 
   'Hungary': 1 
}
1 _(persons).map(func1).reduce(func2);
Listing 3.4. Combining map  and reduce  to compute statistics
1
2
3
4
5
6
7
8
9
const getCountry = person => person.address.country; 
const gatherStats = function (stat, criteria) { 
  stat[criteria] = _.isUndefined(stat[criteria]) ? 1 : 
      stat[criteria] + 1; 
  return stat; 
}; 

10
_(persons).map(getCountry).reduce(gatherStats, {});
1
2
const cityPath = ['address','city']; 
const cityLens = R.lens(R.path(cityPath), R.assocPath(cityPath));
1 _(persons).map(R.view(cityLens)).reduce(gatherStats, {});
1 _.groupBy(persons, R.view(cityLens));
1 _([0,1,3,4,5]).reduce(_.add);  //-> 13
1 reduceRight(f, [e0, e1, e2],accum) -> f(e0, f(e1, f(e2, f(e3,accum)))) -> R
1 ([1,3,4,5]).reduce(_.divide) !== ([1,3,4,5]).reduceRight(_.divide);

Figure 3.6. The filter  operation takes an array as input and applies a selection
criteria p  that potentially yields a much smaller subset of the original array. The
criteria p  is also known as a function predicate.
1
2
3
4
5
const isValid = val => !_.isUndefined(val) && !_.isNull(val); 
const allValid = args => _(args).every(isValid); 
 
allValid(['string', 0, null]); //-> false 
allValid(['string', 0, {}]);   //-> true
1 filter(p, [d0, d1, d2, d3...dn]) -> [d0,d1,...dn] (subset of original input)
Listing 3.5. filter  implementation
1
2
3
4
5
6
7
8
9
10
11
12
function filter(arr, predicate) { 
   let idx = -1, 
       len = arr.length, 
       result = []; 
   while (++idx < len) { 
     let value = arr[idx]; 
     if (predicate(value, idx, this)) { 
       result.push(value); 
     } 
   } 
   return result; 
}
1
2
1 _(persons).filter(isValid).map(fullname);

ARRAY COMPREHENSION
map  and filter  are higher-order functions that return new arrays
from existing ones. They exist in many functional programming
languages like Haskell, Clojure, and others. An alternative to
combining map  and filter  is to use a concept called array
comprehension, also known as list comprehension. It’s a functional
feature that encapsulates the functionality of map  and filter  into a
concise syntax using the for...of  and if  keywords, respectively:
At the time of this writing, there’s a proposal in ECMAScript 7 to
include array comprehensions. They’ll let you create concise
expressions to assemble new arrays (which is why the entire
expression is wrapped in [] ). For example, you can refactor the
previous code in the following manner:
1
2
3
4
5
const bornIn1903 = person => person.birthYear === 1903; 
 
_(persons).filter(bornIn1903).map(fullname).join(' and '); 
 
//-> 'Alonzo Church and Haskell Curry'
1 [for (x of iterable) if (condition) x]
1
2
[for (p of people) if (p.birthYear ===  1903) p.fullname] 
  .join(' and ');
1
2
var names = ['alonzo church', 'Haskell curry', 'stephen_kleene', 
             'John Von Neumann', 'stephen_kleene'];
Listing 3.6. Performing sequential operations on arrays (imperative approach)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
var result = []; 
for (let i = 0; i < names.length; i++) { 
   var n = names[i]; 
   if (n !== undefined && n !== null) { 
      var ns = n.replace(/_/, ' ').split(' '); 
      for(let j = 0; j < ns.length; j++) { 
         var p = ns[j]; 
         p = p.charAt(0).toUpperCase() + p.slice(1); 
         ns[j] = p; 
      } 
      if (result.indexOf(ns.join(' ')) < 0) { 
         result.push(ns.join(' ')); 
      } 
   } 
} 
result.sort();
1
2
3
4
5
1 ['Alonzo Church', 'Haskell Curry', 'Jon Von Neumann', 'Stephen Kleene']
Listing 3.7. Performing sequential operations on arrays (functional approach)
1
2
3
4
5
6
7
8
_.chain(names) 
    .filter(isValid) 
    .map(s => s.replace(/_/, ' ')) 
    .uniq() 
    .map(_.startCase) 
    .sort() 
    .value();  
//-> ['Alonzo Church', 'Haskell Curry', 'Jon Von Neumann', 'Stephen Kleene']
1
2
3
4
5
1
2
3
4
5
6
7
const gatherStats = function (stat, country) { 
   if(!isValid(stat[country])) { 
      stat[country] = {'name': country, 'count': 0}; 
   } 
   stat[country].count++; 
   return stat; 
};
1
2
3
4
5
{ 
   'US'     : {'name': 'US', count: 2}, 
   'Greece' : {'name': 'Greece', count: 1}, 
   'Hungary': {'name': 'Hungary', count: 1} 
}

Figure 3.7. Control of a program built using Lodash function chains. The array of person
objects is processed through a series of operations. Along the way, the data Øows and is
×nally transformed into a single value.
1
2
3
4
5
6
7
8
9
10
11
const p5 = new Person('David', 'Hilbert', '555-55-5555'); 
p5.address = new Address('Germany'); 
p5.birthYear = 1903; 
 
const p6 = new Person('Alan', 'Turing', '666-66-6666'); 
p6.address = new Address('England'); 
p6.birthYear = 1912; 
 
const p7 = new Person('Stephen', 'Kleene', '777-77-7777'); 
p7.address = new Address('US'); 
p7.birthYear = 1909;
Listing 3.8. Demonstrating lazy function chains with Lodash
1
2
3
4
5
6
7
8
9
10
_.chain(persons) 
    .filter(isValid) 
    .map(_.property('address.country')) 
    .reduce(gatherStats, {}) 
    .values() 
    .sortBy('count') 
    .reverse() 
    .first() 
    .value() 
    .name;  //-> 'US'
1
2
3

Table 3.1. Representing the data in the person list as a table
id
rstname
lastname
country
birthYear
0
Haskell
Curry
US
1900
1
Barkley
Rosser
Greece
1907
2
John
Von Neumann
Hungary
1903
3
Alonzo
Church
US
1903
4
David
Hilbert
Germany
1862
5
Alan
Turing
England
1912
6
Stephen
Kleene
US
1909
1
2
3
SELECT p.firstname, p.birthYear FROM Person p 
WHERE p.birthYear > 1903 and p.country IS NOT 'US' 
GROUP BY p.firstname, p.birthYear
1
2
3
4
_.mixin({'select':  _.pluck, 
         'from':    _.chain, 
         'where':   _.filter, 
         'groupBy': _.sortByOrder});
Listing 3.9. Writing SQL-like JavaScript

1
2
3
4
5
6
7
_.from(persons) 
  .where(p => p.birthYear > 1900 && p.address.country !== 'US') 
  .groupBy(['firstname', 'birthYear']) 
  .select('firstname', 'birthYear') 
  .value(); 
 
//-> ['Alan', 'Barkley', 'John']
1
2
3
4
var acc = 0; 
for(let i = 0; i < nums.length; i++) { 
    acc += nums[i]; 
}
1 _(nums).reduce((acc, current) => acc + current, 0);
1
2
3
sum[1,2,3,4,5,6,7,8,9] = 1 + sum[2,3,4,5,6,7,8,9] 
                       = 1 + 2 + sum[3,4,5,6,7,8,9] 
                       = 1 + 2 + 3 + sum[4,5,6,7,8,9]
Listing 3.10. Performing recursive addition
1
2
3
4
5
6
7
8
function sum(arr) { 
   if(_.isEmpty(arr)) { 
      return 0; 
   } 
   return _.first(arr) + sum(_.rest(arr)); 
} 
sum([]); //-> 0 
sum([1,2,3,4,5,6,7,8,9]); //->45
1
2
1
2
3
4
5
6
7
8
1 + sum[2,3,4,5,6,7,8,9] 
1 + 2 + sum[3,4,5,6,7,8,9] 
1 + 2 + 3 + sum[4,5,6,7,8,9] 
1 + 2 + 3 + 4 + sum[5,6,7,8,9] 
1 + 2 + 3 + 4 + 5 + sum[6,7,8,9] 
1 + 2 + 3 + 4 + 5 + 6 + sum[7,8,9] 
1 + 2 + 3 + 4 + 5 + 6 + 7 + sum[8,9] 
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + sum[9] 

Figure 3.8. InØuential mathematicians who contributed to the development of
functional programming. The connected lines from parent to child nodes in the tree
structure represent a “student of” relationship.
9
10
11
12
13
14
15
16
17
18
19
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + sum[] 
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 0     -> halts, stack unwinds 
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 
1 + 2 + 3 + 4 + 5 + 6 + 7 + 17 
1 + 2 + 3 + 4 + 5 + 6 + 24 
1 + 2 + 3 + 4 + 5 + 30 
1 + 2 + 3 + 4 + 35 
1 + 2 + 3 + 39 
1 + 2 + 42 
1 + 44 
45
Listing 3.11. Node  object
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
class Node { 
     constructor(val) { 
       this._val = val; 
       this._parent = null; 
       this._children = []; 
     } 
     isRoot() { 
        return isValid(this._parent); 
     } 
     get children() { 
       return this._children; 
     } 
     hasChildren() { 
        return this._children.length > 0; 
     } 
1

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
     get value() { 
       return this._val; 
     } 
     set value(val) { 
       this._val = val; 
     } 
     append(child) { 
        child._parent = this; 
           this._children.push(child); 
        return this; 
     } 
      toString() { 
        return `Node (val: ${this._val}, children:  
           ${this._children.length})`; 
     } 
}
2
3
4
1
2
3
4
church.append(rosser).append(turing).append(kleene); 
kleene.append(nelson).append(constable); 
rosser.append(mendelson).append(sacks); 
turing.append(gandy);

Figure 3.9. Recursive preorder traversal, starting with the root and descending all the
way to the left before going to the right
1 Tree.map(church, p => p.fullname);
1
2
'Alonzo Church', 'Barkley Rosser', 'Elliot Mendelson', 'Gerald Sacks', 'Alan 
Turing', 'Robin Gandy', 'Stephen Kleene', 'Nels Nelson', 'Robert Constable'

CHAPTER 4
Figure 4.1. Haskell notation for de×ning a function. This notation describes the function
name, followed by an operator that sets the types of the function’s inputs and outputs.
Figure 4.2. The function isEmpty  is a referentially transparent map between the set
of all string values and the set of all Boolean values.
1 tr 'A-Z' 'a-z' <words.in | uniq | sort
1 isEmpty :: String -> Boolean

Figure 4.3. A chain of arrays is made up of methods invoked sequentially via the owning
object. Internally, each method returns a new array containing the result of each
function call.
Figure 4.4. A Function pipeline that starts with a function f  and input of type A  and
generates an object of type B , subsequently passed into g , which outputs an object
of type C  as the ×nal result. Functions f  and g  can belong to any library or can be
your own functions.
1
2
// isEmpty :: String -> Boolean 
const isEmpty = s => !s || !s.trim();
Listing 4.1. Building a manual function pipeline with trim  and normalize
1
2
3
4
// trim :: String -> String 
 const trim = (str) => str.replace(/^\s*|\s*$/g, ''); 
 // normalize :: String -> String 

5  const normalize = (str) => str.replace(/\-/g, ''); 
 normalize(trim(' 444-44-4444 ')); //-> '444444444'
1
1
2
3
4
return { 
   status : false,                or  return [false, 'Input is too long!']; 
   message: 'Input is too long!' 
};
1 var t = (30, 60, 90)
1 var sumAnglesTriangle = t._1 + t._2 + t._3 = 180
Listing 4.2. Typed Tuple  data type
1
2
3
4
5
6
7
8
9
const Tuple = function( /* types */ ) { 
   const typeInfo = Array.prototype.slice.call(arguments, 0); 
   const _T =  function( /* values */ ) { 
      const values = Array.prototype.slice.call(arguments, 0); 
      if(values.some((val) => 
         val === null || val === undefined)) { 
         throw new ReferenceError('Tuples may not have  
            any null values'); 
      } 
1
2
3
4

10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
      if(values.length !== typeInfo.length) { 
         throw new TypeError('Tuple arity does not  
            match its prototype'); 
      } 
      values.map(function(val, index) { 
            this['_' + (index + 1)] = checkType(typeInfo[index])(val);  
           }, this); 
      Object.freeze(this); 
  }; 
  _T.prototype.values = function() { 
        return Object.keys(this).map(function(k) { 
             return this[k]; 
        }, this); 
  }; 
  return _T; 
};
5
6
7
8
1 const Status = Tuple(Boolean, String);
Listing 4.3. Using tuples for the isValid  function
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
// trim :: String  -> String 
const trim = (str) => str.replace(/^\s*|\s*$/g, ''); 
// normalize :: String  -> String 
const normalize = (str) => str.replace(/\-/g, ''); 
// isValid :: String -> Status 
const isValid = function (str) { 
    if(str.length === 0){ 
       return new Status(false, 
            'Invald input. Expected non-empty value!'); 
    } 
    else { 
       return new Status(true, 'Success!'); 
    } 
} 
isValid(normalize(strim('444-44-4444'))); //-> (true, 'Success!')
1
Listing 4.4. StringPair  type
1
2
3
4
5
6
const StringPair = Tuple(String, String); 
const name = new StringPair('Barkley', 'Rosser'); 
[first, last] = name.values(); 
first; //-> 'Barkley' 
last;  //-> 'Rosser' 
const fullname = new StringPair('J', 'Barkley', 'Rosser');
1

Figure 4.5. Calling a non-curried function with missing arguments causes the function
to eagerly evaluate missing parameters and ×ll them with undefined .
Figure 4.6. Evaluating a curried function f . The function produces a concrete result
only when all arguments have been provided; otherwise, it returns another function
that waits for these parameters to be passed in.
1 curry(f) :: (a,b,c) -> f(a) -> f(b)-> f(c)
Listing 4.5. Manual currying with two arguments
1
2
3
4
5
6
7
function curry2(fn) { 
     return function(firstArg) { 
          return function(secondArg) { 
              return fn(firstArg, secondArg); 
          }; 
     }; 
}
1
2
3

1
2
3
4
// fullname :: (String, String) -> String 
const fullname = function (first, last) { 
    ... 
}
1
2
3
4
5
6
7
// fullname :: String -> String -> String 
const fullname = 
   function (first) { 
       return function (last)  { 
           ... 
   } 
}
1
2
3
4
5
6
7
8
public interface StudentStore { 
    Student findStudent(String ssn); 
} 
 
public class DbStudentStore implements StudentStore { 
    public Student findStudent(String ssn) { 
        // ... 
        ResultSet rs = jdbcStmt.executeQuery(sql); 

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
        while(rs.next()){ 
            String ssn  = rs.getString("ssn"); 
            String name  = rs.getString("firstname") + 
               rs.getString("lastanme"); 
            return new Student(ssn, name); 
        } 
    } 
} 
 
public class CacheStudentStore implements StudentStore { 
    public Student findStudent(String ssn) { 
        // ... 
        return cache.get(ssn); 
    } 
}
1
2
StudentStore store = getStudentStore(); 
store.findStudent("444-44-4444");
1
2
3
4
const findStudent = useDb ? fetchStudentFromDb(db) 
                        : fetchStudentFromArray(arr); 
 
findStudent('444-44-4444');
1
2
const logger = new Log4js.getLogger('StudentEvents'); 
logger.info('Student added successfully!');
1 logger.addAppender(new Log4js.JSAlertAppender());

1 appender.setLayout(new Log4js.JSONLayout());
Listing 4.6. Creating a logger function template
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
const logger = function(appender, layout, name, level, message) { 
    const appenders = { 
        'alert': new Log4js.JSAlertAppender(), 
        'console': new Log4js.BrowserConsoleAppender() 
    };    
    const layouts = { 
        'basic': new Log4js.BasicLayout(), 
        'json': new Log4js.JSONLayout(), 
        'xml' : new Log4js.XMLLayout() 
    }; 
    const appender = appenders[appender];                  
    appender.setLayout(layouts[layout]); 
    const logger = new Log4js.getLogger(name); 
    logger.addAppender(appender);  
    logger.log(level, message, null); 
};
1
2
3
1
2
3
const logError = R.curry(logger)('console', 'basic', 'FJS', 'ERROR'); 
logError('Error code 404 detected!!'); 
logError('Error code 402 detected!!');
Listing 4.7. Implementation of partial
1
2
3
4
5
6
7
8
9
10
11
function partial() { 
   let fn = this, boundArgs = Array.prototype.slice.call(arguments); 
   let placeholder = <<partialPlaceholderObj>>; 
   let bound = function() { 
      let position = 0, length = args.length; 
      let args = Array(length); 
      for (let i = 0; i < length; i++) { 
         args[i] = boundArgs[i] === placeholder 
             ? arguments[position++] : boundArgs[i]; 
      } 
      while (position < arguments.length) { 
1
2
3

12
13
14
15
16
17
         args.push(arguments[position++]); 
      } 
      return fn.apply(this, args); 
   }; 
   return bound; 
});
4
1 const consoleLog = _.partial(logger, 'console', 'json', 'FJS Partial');
1
2
const consoleInfoLog = _.partial(consoleLog, 'INFO'); 
consoleInfoLog('INFO logger configured with partial');
1
2
const log =_.bind(logger, undefined, 'console', 'json', 'FJS Binding'); 
log('WARN', 'FP is too awesome!');

Figure 4.7. Combining three simple input text widgets with a container widget to create
a bio form component
Figure 4.8. Student console widget built from smaller widgets including an address
form, a bio form, a button, and a container
1
2
3
if(!String.prototype.explode) { 
    String.prototype.explode = _.partial(String.prototype.match, /[\w]/gi); 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
const Scheduler = (function () { 
    const delayedFn = _.bind(setTimeout, undefined, _, _); 
 
    return { 
      delay5:  _.partial(delayedFn, _, 5000), 
      delay10: _.partial(delayedFn, _, 10000), 
      delay:   _.partial(delayedFn, _, _) 
    }; 
})(); 
 
Scheduler.delay5(function () { 
   consoleLog('Executing After 5 seconds!') 
});
1 const Node = Tuple(Object, Tuple);

Figure 4.9. Highlighting the head and tail sections forming a list of numbers. The head
and tail are readily available as functions for array processing in functional languages.
Figure 4.10. Showing the set of input and output types for functions f  and g .
Function g  maps A  values to B  values, and function f  maps B  values to C  values.
Composition happens because f  and g  are compatible.
1
2
3
const element = R.curry(function(val, tuple) { 
   return new Node(val, tuple); 
});
1 f • g = f(g) = compose :: (B -> C) -> (A -> B) -> (A -> C)

Figure 4.11. The composition of two functions is a new function directly mapping the
inputs of the ×rst function to the output of the second. The composition is also a
referentially transparent mapping between inputs and outputs.
Listing 4.8. Implementation of compose
1
2
3
4
5
6
7
8
9
10
11
function compose(/* fns */) { 
   let args = arguments; 
   let start = args.length - 1; 
   return function() { 
      let i = start; 
      let result = args[start].apply(this, arguments); 
      while (i--) 
          result = args[i].call(this, result); 
      return result; 
   }; 
}
1
2
3

Figure 4.12. Complex functions can be built by composing simple functions. Just as
functions combine, entire programs made from different modules (containing more
functions) that can also combine in this fashion.
1
2
const students = ['Rosser', 'Turing', 'Kleene', 'Church']; 
const grades   = [80, 100, 90, 99];
Listing 4.9. Computing the smartest student
1
2
3
4
5
6
7
const smartestStudent = R.compose( 
    R.head,  
    R.pluck(0),  
    R.reverse,  
    R.sortBy(R.prop(1)),  
    R.zip); 
smartestStudent(students, grades); //-> 'Turing'
1
2
Listing 4.10. Using descriptive function aliases
1
2
3
const first = R.head; 
const getName = R.pluck(0); 
const reverse = R.reverse; 

Figure 4.13. A simple Unix shell program, piping together a sequence of functions or
programs
4
5
6
7
const sortByGrade = R.sortBy(R.prop(1)); 
const combine = R.zip; 
 
R.compose(first, getName, reverse, sortByGrade, combine);
1 const showStudent = compose(append, csv, findStudent);
Listing 4.11. showStudent  program using currying and composition
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
// findObject :: DB -> String -> Object              
const findObject = R.curry(function (db, id) { 
   const obj = find(db, id);            
   if(obj === null) { 
     throw new Error('Object with ID [' + id + '] not found'); 
   } 
   return obj; 
}); 
// findStudent :: String -> Student 
const findStudent = findObject(DB('students')); 
const csv = (student) =>  
  `${student.ssn}, ${student.firstname}, ${student.lastname}`; 
// append :: String -> String -> String 
const append = curry(function (elementId, info) {  
   document.querySelector(elementId).innerHTML = info; 
   return info; 
}); 
// showStudent :: String -> Integer 
const showStudent = R.compose( 
   append('#student-info'), 
   csv,    
   findStudent, 
   normalize,  
   trim)); 
showStudent('44444-4444');  //-> 444-44-4444, Alonzo, Church
1
2
3
1
2
R.pipe( 
   trim, 

3
4
5
6
   normalize, 
   findStudent, 
   csv, 
   append('#student-info'));
1 R.compose(first, getName, reverse, sortByGrade, combine);
Listing 4.12. Point-free version of a Unix program using Ramda functions
1
2
3
4
5
6
7
const runProgram = R.pipe( 
   R.map(R.toLower),  
   R.uniq,  
   R.sortBy(R.identity)); 
runProgram(['Functional', 'Programming', 'Curry',  
    'Memoization', 'Partial', 'Curry', 'Programming']);   
//-> [curry, functional, memoization, partial, programming]
1
1 identity :: (a) -> a
1 tap :: (a -> *) -> a -> a
1
2
const debugLog = _.partial(logger, 'console', 'basic', 'MyLogger', 
   'DEBUG');
1
2
3
const debug = R.tap(debugLog); 
const cleanInput = R.compose(normalize, debug, trim); 
const isValidSsn = R.compose(debug, checkLengthSsn, debug, cleanInput);

1
2
3
4
5
6
isValidSsn('444-44-4444'); 
 
// output 
MyLogger [DEBUG] 444-44-4444  // clean input 
MyLogger [DEBUG] 444444444    // check length 
MyLogger [DEBUG] true         // final result
1
2
3
4
5
const alt = function (func1, func2) { 
    return function (val) { 
       return func1(val) || func2(val); 
    } 
};
1 const alt = R.curry((func1, func2, val) => func1(val) || func2(val));
1
2
3
4
5
6
const showStudent = R.compose( 
   append('#student-info'), 
   csv, 
   alt(findStudent, createNewStudent)); 
 
showStudent('444-44-4444');
1
2
3
4
5
6
7
8
9
10
var student = findStudent('444-44-4444'); 
if(student !== null) { 
  let info = csv(student); 
  append('#student-info', info); 
} 
else { 
  let newStudent = createNewStudent('444-44-4444'); 
  let info = csv(newStudent); 
  append('#student-info', info); 
}
1
2
3
4
const seq = function(/*funcs*/) { 
    const funcs = Array.prototype.slice.call(arguments); 
    return function (val) { 
       funcs.forEach(function (fn) { 

Figure 4.14. The fork  combinator receives three functions: a join  and two fork
functions. The fork  functions are executed against the supplied input, and then the
×nal result is combined via join .
5
6
7
8
          fn(val); 
       }); 
    }; 
};
1
2
3
4
5
6
const showStudent = R.compose( 
  seq( 
    append('#student-info'), 
    consoleLog), 
  csv, 
  findStudent));
1
2
3
4
5
const fork = function(join, func1, func2){ 
   return function(val) { 
      return join(func1(val), func2(val)); 
   }; 
};
1
2
3
4
const computeAverageGrade = 
    R.compose(getLetterGrade, fork(R.divide, R.sum, R.length)); 
 
computeAverageGrade([99, 80, 89]); //-> 'B'

1
2
3
const eqMedianAverage = fork(R.equals, R.median, R.mean); 
eqMedianAverage([80, 90, 100])); //-> True 
eqMedianAverage([81, 90, 100])); //-> False

CHAPTER 5
Violate the principle of non-locality because the code used to
recover from the error is distanced from the originating function
call. When an error is thrown, a function leaves the local stack
and environment:
1
2
3
4
5
6
7
try { 
   // code that might throw an exception in here 
} 
catch (e) { 
   // statements to handle any exceptions 
   console.log('ERROR' + e.message); 
}
1
2
3
4
5
6
7
8
9
10
11
// findObject :: DB, String -> Object 
const findObject = R.curry(function (db, id) { 
  const result = find(db, id) 
  if(!result) { 
     throw new Error('Object with ID [' + id + '] not found'); 
  } 
  return result; 
}); 
 
// findStudent :: String -> Student 
const findStudent = findObject(DB('students'));
1
2
3
4
5
6
try { 
    var student = findStudent('444-44-4444'); 
} 
catch (e) { 
    console.log('ERROR' + e.message); 
}
1
2
3
4
5
6
7
try { 
     var student = findStudent('444-44-4444'); 
 
     ... more lines of code in between 
} 
catch (e) { 
     console.log('ERROR: not found'); 

Are hard to use when multiple error conditions create nested
levels of exception-handling blocks:
Figure 5.1. The try-catch  structure invisibly creates a safety box around functions
that can throw exceptions. This safety box is materialized into a container.
8
9
10
 
     // Handle error here 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
var student = null; 
try { 
   student = findStudent('444-44-44444'); 
} 
catch (e) { 
   console.log('ERROR: Cannot locate students by SSN'); 
 
   try { 
      student = findStudentByAddress(new Address(...)); 
   } 
   catch (e) { 
      console.log('ERROR: Student is no where to be found
   } 
}
1
2
3
4
5
6
7
8
9
10
11
12
function getCountry(student) { 
   let school = student.getSchool(); 
   if(school !== null) { 
     let addr = school.getAddress(); 
        if(addr !== null) { 
       var country = addr.getCountry(); 
       return country; 
     } 
     return null; 
   } 
   throw new Error('Error extracting country info'); 
}

Figure 5.2. The Wrapper  type uses map  to safely access and manipulate values. In
this case, you’re mapping the identity function over the container to extract the value
as is from the container.
Listing 5.1. Functional data type to wrap values
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Wrapper {   
    constructor(value) { 
        this._value = value;  
    } 
    // map :: (A -> B) -> A -> B  
    map(f) { 
 
      return f(this.val); 
    }; 
    toString() {   
      return 'Wrapper (' + this.value + ')'; 
    } 
} 
// wrap :: A -> Wrapper(A) 
const wrap = (val) => new Wrapper(val);
1
2
3

Figure 5.3. A value of 1 is contained within Wrapper . The functor is called with the
wrapper and the increment  function, which transforms the value internally and
closes it back into a container.
1
2
const plus = R.curry((a, b) => a + b); 
const plus3 = plus(3);
1 const two = wrap(2);

You can map the function to obtain the same value over a
context. This proves functors are side e|ect–free and preserves
the structure of the wrapped value:
Figure 5.4. The value 2 has been added to a Wrapper  container. The functor is used to
manipulate this value by unwrapping it from the context, applying the given function to
it, and rewrapping the value back into a new context.
1 two.fmap(plus3).fmap(plus10); //-> Wrapper(15)
Listing 5.2. Chaining functors to apply additional behavior to a given context
1
2
const two = wrap(2); 
two.fmap(plus3).fmap(R.tap(infoLogger)); //-> Wrapper(5)
1 InfoLogger [INFO] 5
1
2
map    :: (A -> B)       -> Array(A) -> Array(B) 
filter :: (A -> Boolean) -> Array(A) -> Array(A)
1 compose :: (B -> C) -> (A -> B) -> (A -> C)

This property indicates that the composition of a function
applied to should be exactly the same as chaining functions
together. As a result, the following expression is exactly
equivalent to the program in :
1 wrap('Get Functional').fmap(R.identity); //-> Wrapper('Get 
1 two.fmap(R.compose(plus3, R.tap(infoLogger))).map(R.identit
1 $('#student-info').fadeIn(3000).text(student.fullname());
1
2
3
4
const studentAddress = R.compose( 
    getAddress, 
    findStudent(DB('student')) 
);
1 studentAddress('444-44-4444'); //-> Wrapper(Wrapper(address))

Figure 5.5. Functors apply a function to a wrapped value. In this case, the wrapped value
2 is halved, returning a wrapped value of 1.
Figure 5.6. Function half  can return either a wrapped value or an empty container,
depending on the nature of the input.
1
2
Wrapper(2).fmap(half); //-> Wrapper(1) 
Wrapper(3).fmap(half); //-> Wrapper(1.5)

Listing 5.3. Wrapper  monad
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
class Wrapper { 
    constructor(value) { 
        this._value = value; 
    } 
    static of(a) { 
       return new Wrapper(a); 
    } 
    map(f) { 
 
      return Wrapper.of(f(this.value)); 
    } 
    join() { 
 
      if(!(this.value instanceof Wrapper)) { 
         return this; 
      } 
      return this.value.join(); 
    } 
    toString() { 
      return `Wrapper (${this.value})`; 
    } 
 }
1
2
3
4
5
1
2
3
Wrapper.of('Hello Monads!') 
   .map(R.toUpper) 
   .map(R.identity); //-> Wrapper('HELLO MONADS!')
Listing 5.4. Flattening a monadic structure
1
2
3
4
5
6
7
8
9
10
11
12
13
// findObject :: DB -> String -> Wrapper 
const findObject = R.curry(function(db, id) { 
   return Wrapper.of(find(db, id)); 
}); 
 
// getAddress :: Student -> Wrapper 
const getAddress = function(student) { 
   return Wrapper.of(student.map(R.prop('address'))); 
} 
 
const studentAddress = R.compose(getAddress, findObject(DB('student'))); 
 
studentAddress('444-44-4444').join().get(); // Address

Figure 5.7. Using the join  operation to recursively Øatten a nested monad structure,
like peeling an onion
1
2
3
Wrapper.of(Wrapper.of(Wrapper.of('Get Functional'))).join(); 
 
//-> Wrapper('Get Functional')
1
2
3
R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]); 
 
//=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
Listing 5.5. Maybe  monad with subclasses Just  and Nothing
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
class Maybe { 
  static just(a) { 
     return new Just(a); 
  } 
  static nothing() { 
     return new Nothing(); 
  } 
  static fromNullable(a) {  
     return a !== null ? just(a) : nothing(); 
  } 
  static of(a) { 
     return just(a); 
  } 
  get isNothing() { 
     return false; 
  }   
  get isJust() { 
     return false; 
  } 
} 
class Just extends Maybe { 
   constructor(value) { 
      super(); 
      this._value = value; 
   } 
   get value() { 
      return this._value; 
   }    
   map(f) {  
1
2
3

Figure 5.8. A Maybe  structure has two subtypes: Just  and Nothing . Calling
findStudent  returns its value wrapped in Just  or the absence of a value in
Nothing .
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
      return of(f(this.value)); 
   } 
   getOrElse() { 
      return this.value; 
   } 
   filter(f) { 
      Maybe.fromNullable(f(this.value) ? this.value : null); 
   }  
   get isJust() { 
     return true; 
   } 
   toString () { 
     return `Maybe.Just(${this.value})`; 
   }    
} 
class Nothing extends Maybe { 
   map(f) { 
    return this;  
   } 
   get value()  { 
     throw new TypeError('Can't extract the value  
        of a Nothing.'); 
   } 
   getOrElse(other) { 
     return other; 
   }   
   filter() { 
     return this.value; 
   } 
   get isNothing() { 
      return true; 
   } 
   toString() {  
    return 'Maybe.Nothing'; 
  } 
}
4
5
6
7
8
9
10
11
1
2
// findStudent :: String -> Maybe(Student) 
function findStudent(ssn)

1
2
3
4
5
6
7
8
9
10
// safeFindObject :: DB -> String -> Maybe 
const safeFindObject = R.curry(function(db, id) { 
   return Maybe.fromNullable(find(db, id)); 
}); 
 
// safeFindStudent :: String -> Maybe(Student) 
const safeFindStudent = safeFindObject(DB('student')); 
 
const address = safeFindStudent('444-44-4444').map(R.prop('address')); 
address; //-> Just(Address(...)) or Nothing
1 TypeError: Can't extract the value of a Nothing.
1
2
3
4
const userName = findStudent('444-44-4444').map(R.prop('firstname')); 
 
document.querySelector('#student-firstname').value = 
    username.getOrElse('Enter first name');
1
2
3
4
5
6
7
8
9
10
11
function getCountry(student) { 
   let school = student.school(); 
   if(school !== null) { 
      let addr = school.address(); 
      if(addr !== null) { 
         return addr.country(); 
      } 
   } 
 
   return 'Country does not exist!'; 
}

FUNCTION LIFTING
Look closely at this function:
Notice that its name is prexed with safe  and it uses a monad
directly to wrap its return value. This is a good practice because you
make it clear to the caller that the function is housing a potentially
dangerous value. Does this mean you need to instrument every
function in your program with monads? Not necessarily. A technique
called function lifting can transform any ordinary function into a
function that works on a container, making it “safe.” It can be a handy
utility so that you aren’t obligated to change your existing
implementations:
Instead of directly using the monad in the body of the function, you
can keep it as is
1 const country = R.compose(getCountry, safeFindStudent);
1
2
3
const safeFindObject = R.curry(function(db, id) { 
   return Maybe.fromNullable(find(db, id)); 
});
1
2
3
const lift = R.curry(function (f, value) { 
   return Maybe.fromNullable(value).map(f); 
});
1
2
3
const findObject = R.curry(function(db, id) { 
    return find(db, id); 
});

and use lift  to bring this function into the container:
Lifting can work with any function on any monad!
1
2
const safeFindObject = R.compose(lift, findObject); 
safeFindObject(DB('student'), '444-44-4444');
Listing 5.6. Either  monad with Left  and Right  subclasses
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
class Either {  
  constructor(value) { 
     this._value = value; 
  } 
  get value() { 
     return this._value; 
  } 
  static left(a) { 
    return new Left(a);  
  } 
  static right(a) { 
    return new Right(a); 
  } 
  static fromNullable(val) { 
     return val !== null ? right(val): left(val); 
  } 
  static of(a){ 
     return right(a); 
  } 
} 
class Left extends Either { 
   map(_) { 
    return this; // noop 
   } 
   get value() { 
      throw new TypeError('Can't extract the  
         value of a Left(a).'); 
   } 
   getOrElse(other) {  
      return other; 
   } 
   orElse(f) { 
      return f(this.value); 
   } 
   chain(f) { 
      return this;  
   } 
   getOrElseThrow(a) { 
      throw new Error(a); 
   }  
   filter(f) { 
      return this;  
   } 
1
2
3
4
5
6
7
8
9
10

Figure 5.9. An Either  structure can store an object (on the right) or an Error  (on
the left) with proper stack trace information. This is useful to provide a single return
value that can also contain an error message in case of failure.
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
   toString() {   
     return `Either.Left(${this.value})`; 
   } 
 } 
class Right extends Either { 
    map(f) { 
       return Either.of(f(this.value));  
    } 
    getOrElse(other) {  
       return this.value; 
    } 
    orElse() { 
       return this;  
    }     
    chain(f) { 
       return f(this.value); 
    } 
    getOrElseThrow(_) { 
       return this.value; 
    } 
    filter(f) { 
        return Either.fromNullable(f(this.value) ? this.value : null); 
    } 
    toString() {   
        return `Either.Right(${this.value})`; 
    } 
 }
11
12
13
14
15
16

1
2
const findStudent = safeFindObject(DB('student')); 
findStudent('444-44-4444').getOrElse(new Student()); //->Right(Student)
1
2
3
const errorLogger = _.partial(logger, 'console', 'basic', 'MyErrorLogger', 
    'ERROR'); 
findStudent('444-44-4444').orElse(errorLogger);
1 MyErrorLogger [ERROR] Student not found with ID: 444-44-4444
1
2
3
4
5
... 
 
catch (uriError) { 
   return Either.Left(uriError); 
}
1 IO.of('An unsafe operation').map(alert);

Listing 5.7. IO  monad
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
class IO { 
   constructor(effect) { 
      if (!_.isFunction(effect)) { 
         throw 'IO Usage: function required'; 
      } 
      this.effect = effect; 
   } 
   static of(a) { 
      return new IO( () => a );  
   } 
   static from(fn) { 
      return new IO(fn);    
   }  
   map(fn) { 
      var self = this; 
      return new IO(function () { 
        return fn(self.effect()); 
      }); 
   } 
   chain(fn) {  
        return fn(this.effect()); 
   } 
   run() {  
        return this.effect(); 
   } 
}
1
2
3
4
1
2
3
4
5
6
7
8
9
10
11
const read = function (document, id) { 
    return function () { 
       return document.querySelector(`\#${id}`).innerHTML; 
    }; 
}; 
 
const write = function(document, id) { 
   return function(val) { 
     return document.querySelector(`\#${id}`).innerHTML = val; 
   }; 
};
1
2
const readDom = _.partial(read, document); 
const writeDom = _.partial(write, document);

Figure 5.10. Functions findStudent  and append  are being composed. Without the
proper checks, if the former produces a null  return value, the latter will fail with a
TypeError  exception.
Figure 5.11. Same two functions as in ×gure 5.10; but this time the null  value travels
in a monad ( Either  or Maybe ), which causes the rest of the functions in the pipeline
to gracefully fail.
1 changeToStartCase.run();
1 <div id="student-name">Alonzo Church</div>
Listing 5.8. Refactoring functions to use Either
1
2
// validLength :: Number, String -> Boolean 
const validLength = (len, str) => str.length === len;      

3
4
5
6
7
8
9
10
11
12
13
14
15
16
// checkLengthSsn :: String -> Either(String) 
const checkLengthSsn = function (ssn) { 
    return Either.of(ssn).filter(_.bind(validLength, undefined, 9)) 
       .getOrElseThrow(`Input: ${ssn} is not a valid SSN number`); 
}; 
// safeFindObject :: Store, string -> Either(Object) 
const safeFindObject = R.curry(function (db, id) { 
    return Either.fromNullable(find(db, id)) 
       .getOrElseThrow(`Object not found with ID: ${id}`); 
}); 
// finStudent :: String -> Either(Student) 
const findStudent = safeFindObject(DB('students')); 
// csv :: Array => String 
const csv = arr => arr.join(',');
1
2
1
2
3
4
5
6
7
const debugLog = _.partial(logger, 'console', 'basic', 
     'Monad Example', 'TRACE'); 
 
const errorLog = _.partial(logger, 'console', 'basic', 
     'Monad Example', 'ERROR'); 
 
const trace = R.curry((msg, val)=> debugLog(msg + ':' + val));
Listing 5.9. showStudent  using monads for automatic error handling
1
2
3
4
5
6
7
8
const showStudent = (ssn) => 
   Maybe.fromNullable(ssn) 
      .map  (cleanInput) 
      .chain(checkLengthSsn) 
      .chain(findStudent) 
 
      .map  (R.props(['ssn', 'firstname', 'lastname']))  
      .map  (csv) 
      .map  (append('#student-info'));
1
1 showStudent('444-44-4444').orElse(errorLog);
1 Monad Example [INFO] Either.Right('444-44-4444, Alonzo,Church')

Figure 5.12. Step-by-step Øow of the showStudent  function in the case where
findStudent  successfully ×nds a student object by the provided SSN
1 Monad Example [ERROR] Student not found with ID: 444444444
Listing 5.10. General map  and chain  functions that work on any container
1
2
3
4
5
6
7
8
9
// map :: (ObjectA -> ObjectB), Monad -> Monad[ObjectB] 
const map = R.curry(function (f, container) { 
    return container.map(f); 
}); 
 
// chain :: (ObjectA -> ObjectB), M -> ObjectB 
const chain = R.curry(function (f, container) { 
    return container.chain(f); 
});
Listing 5.11. Monads as programmable commas
1
2
3
4
5
6
7
8
9
10
11
const showStudent = R.compose( 
     R.tap(trace('Student added to HTML page')) 
     map(append('#student-info')), 
     R.tap(trace('Student info converted to CSV')), 
     map(csv), 
     map(R.props(['ssn', 'firstname', 'lastname'])), 
     R.tap(trace('Record fetched successfully!')), 
     chain(findStudent), 
     R.tap(trace('Input was valid')), 
     chain(checkLengthSsn), 
     lift(cleanInput));
1
2
3
4
5
6
7
8
9
Monad Example [TRACE] Input was valid:Either.Right(444444444) 
 
Monad Example [TRACE] Record fetched successfully!: Either.Right(Person 
[firstname: Alonzo| lastname: Church]) 
 
Monad Example [TRACE] Student converted to row: Either.Right(444-44-4444, 
Alonzo, Church) 
 
Monad Example [TRACE] Student added to roster: Either.Right(1)

Figure 5.13. The case of an unsuccessful findStudent  as it affects the rest of the
composition. Regardless of the failure of any of the components in the pipeline, the
program remains fault-tolerant and gracefully skips any procedures that depended on
the data.
1 map(append('#student-info')),
1
2
3
const liftIO = function (val) { 
   return IO.of(val); 
};
Listing 5.12. Complete showStudent  program
1
2
3
4
5
6
7
8
const showStudent = R.compose( 
   map(append('#student-info')), 
   liftIO, 
   map(csv), 
   map(R.props(['ssn', 'firstname', 'lastname'])), 
   chain(findStudent), 
   chain(checkLengthSsn), 
   lift(cleanInput));

1 showStudent(studentId).run(); //-> 444-44-4444, Alonzo, Church
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
function showStudent(ssn) { 
    if(ssn != null) { 
        ssn = ssn.replace(/^\s*|\-|\s*$/g, ''); 
        if(ssn.length !== 9) { 
            throw new Error('Invalid Input'); 
        } 
 
        let student = db.get(ssn); 
        if (student) { 
            document.querySelector(`#${elementId}`).innerHTML = 
              `${student.ssn}, 
               ${student.firstname}, 
               ${student.lastname}`; 
        } 
        else { 
            throw new Error('Student not found!'); 
        } 
    } 
    else { 
        throw new Error('Invalid SSN!'); 
    } 
}

CHAPTER 6
Figure 6.1. Because functional programming is a software paradigm with focus on code,
its inØuence mostly impacts the design of unit tests, with little effect on integration
tests. It’s completely agnostic to acceptance testing.
Figure 6.2. The functional sections of the monolithic function showStudent . To
simplify writing tests, these sections should be split into separate functions that deal
with validation, IO, and error handling.
1
2
3
4
5
QUnit.test('Test Find Person', function(assert) { 
  const ssn = '444-44-4444'; 
  const p = findPerson(ssn); 
  assert.equal(p.ssn, ssn); 
});

Figure 6.3. Repeating a unit test for the imperative increment  function is impossible
due to the function’s dependency on the external counter variable.
Figure 6.4. Falsely making assumptions about the global state of the system causes
simple tests to fail. The left side shows that all tests executed perfectly, because each
test correctly prepared its surrounding state before executing. But shufØing the tests
(right) invalidates all assumptions about the state.
1
2
3
4
5
var counter = 0;  // (global) 
 
function increment() { 
    return ++counter; 
}

Figure 6.5. Tests against the functional increment  function, which can be repeated
or run in a different order without altering their outcome
Listing 6.1. Testing the computeAverageGrade  program
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
const fork = function(join, func1, func2){ 
   return function(val) { 
      return join(func1(val), func2(val)); 
   }; 
}; 
 
const toLetterGrade = function (grade) { 
   if (grade >= 90) return 'A'; 
   if (grade >= 80) return 'B'; 
   if (grade >= 70) return 'C'; 
   if (grade >= 60) return 'D'; 
   return 'F'; 
}; 
 
const computeAverageGrade = 
    R.compose(toLetterGrade, fork (R.divide, R.sum, R.length)); 
 
QUnit.test('Compute Average Grade', function(assert) { 
 
   assert.equal(computeAverageGrade([80, 90, 100]), 'A'); 
});
1
2
3
4
QUnit.test('Compute Average Grade: toLetterGrade', function (assert) { 
 
    assert.equal(toLetterGrade(90), 'A'); 
    assert.equal(toLetterGrade(200),'A'); 

Figure 6.6. Identifying the testable areas of the showStudent  program. The
components that perform IO are impure and can’t be tested reliably because they
contain side effects. Other than having impure parts, the scope of the entire program
remains highly testable.
5
6
7
8
9
10
11
    assert.equal(toLetterGrade(80), 'B'); 
    assert.equal(toLetterGrade(89), 'B'); 
    assert.equal(toLetterGrade(70), 'C'); 
    assert.equal(toLetterGrade(60), 'D'); 
    assert.equal(toLetterGrade(59), 'F'); 
    assert.equal(toLetterGrade(-10),'F'); 
});
1
2
3
4
5
6
QUnit.test('Functional Combinator: fork', function (assert) { 
 
    const timesTwo = fork((x) => x + x, R.identity, R.identity); 
    assert.equal(timesTwo(1), 2); 
    assert.equal(timesTwo(2), 4); 
});
1
2
3
4
5
6
7
8
const showStudent = R.compose( 
   map(append('#student-info')), 
   liftIO, 
   map(csv), 
   map(R.props(['ssn', 'firstname', 'lastname'])), 
   chain(findStudent), 
   chain(checkLengthSsn), 
   lift(cleanInput));
Listing 6.2. Unit testing pure components of showStudent
1
2
3
QUnit.test('showStudent: cleanInput', function (assert) { 
    const input = ['', '-44-44-', '44444', '    4    ', '   4-4  ']; 
    const assertions = ['', '4444', '44444', '4', '44']; 
1

4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
    assert.expect(input.length); 
    input.forEach(function (val, key) { 
        assert.equal(cleanInput(val), assertions[key]); 
    }); 
}); 
QUnit.test('showStudent: checkLengthSsn', function (assert) { 
    assert.ok(checkLengthSsn('444444444').isRight); 
    assert.ok(checkLengthSsn('').isLeft); 
    assert.ok(checkLengthSsn('44444444').isLeft); 
    assert.equal(checkLengthSsn('444444444').chain(R.length), 9); 
}); 
QUnit.test('showStudent: csv', function (assert) { 
    assert.equal(csv(['']), ''); 
    assert.equal(csv(['Alonzo']), 'Alonzo'); 
    assert.equal(csv(['Alonzo', 'Church']), 'Alonzo,Church'); 
    assert.equal(csv(['Alonzo', '', 'Church']), 'Alonzo,,Church,'); 
});
2
1
2
const studentDb = DB('students'); 
const mockContext = sinon.mock(studentDb);
Listing 6.3. Mocking the external dependency of findStudent
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
var studentStore, mockContext; 
QUnit.module('CH06',  
{ 
  beforeEach: function() { 
    studentDb = DB('students'); 
    mockContext = sinon.mock(studentDb); 
  }, 
  afterEach: function() { 
    mockContext.verify(); 
    mockContext.restore(); 
  } 
}); 
QUnit.test(showStudent: findStudent returning null',  
  function (assert) { 
    mockContext.expects('get').once().returns(null); 
    const findStudent = safefetchRecord(studentStore); 
    assert.ok(findStudent('xxx-xx-xxxx').isLeft); 
}); 
QUnit.test('showStudent: findStudent returning valid object',  
  function (assert) { 
    mockContext.expects('get').once().returns( 
        new Student('Alonzo', 'Church', 'Princeton'). 
            setSsn('444-44-4444')); 
    const findStudent = safefetchRecord(studentStore); 
    assert.ok(findStudent('444-44-4444').isRight); 
});
1
2
3
4
5
6
7

Figure 6.7. Execution of all unit tests for the showStudent  program. Tests 3 and 4 use
QUnit with Sinon.JS because they require mocked dependencies to simulate the
functionality of fetching a student record.
1 assert.equal(computeAverageGrade([80, 90, 100]), 'A');
1
2
3
4
5
6
7
8
QUnit.test('Compute Average Grade', function (assert) { 
    assert.equal(computeAverageGrade([80, 90, 100]),'A'); 
    assert.equal(computeAverageGrade([80, 85, 89]), 'B'); 
    assert.equal(computeAverageGrade([70, 75, 79]), 'C'); 
    assert.equal(computeAverageGrade([60, 65, 69]), 'D'); 
    assert.equal(computeAverageGrade([50, 55, 59]), 'F'); 
    assert.equal(computeAverageGrade([-10]),        'F'); 
});
1 JSC.claim(name, predicate, specifiers, classifier)
Listing 6.4. Property-based test for computeAverageGrade
1
2
3
4
5
JSC.clear(); 
JSC.on_report((str) => console.log(str)); 
JSC.test( 
   'Compute Average Grade', 
   function (verdict, grades, grade) { 
1
2
3

Figure 6.8. The integration of the main components: JSCheck and QUnit. A QUnit test
encapsulates a JSCheck test speci×cation. The speci×cation and the function being
tested are supplied to the verdict  function, which is run through the JSCheck
engine to invoke the pass/fail callbacks. These callbacks can be used to trigger QUnit
assertions.
6
7
8
9
10
11
12
13
14
15
      return verdict(computeAverageGrade(grades) === grade); 
   }, 
   [ 
     JSC.array(JSC.integer(20), JSC.number(90,100)), 
     'A' 
   ], 
   function (grades, grade) { 
     return 'Testing for an ' + grade + ' on grades: ' + grades; 
   }          
);
4
5
1
2
3
4
5
6
7
8
9
10
Compute Average Grade: 100 classifications, 100 cases tested, 100 pass 
 
Testing for an A on grades: 
   90.042,98.828,99.359,90.309,99.175,95.569,97.101,92.24 pass 1 
Testing for an A on grades: 
   90.084,93.199, pass 1 
 
// and so on 98 more times 
 
Total pass 100, fail 0

Listing 6.5. JSCheck test for checkLengthSsn
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
QUnit.test('JSCheck Custom Specifier for SSN', function (assert) {     
   JSC.clear(); 
   JSC.on_report((report) trace('Report'+ str)); 
      JSC.on_pass((object) => assert.ok(object.pass)); 
   JSC.on_fail((object) => 
      assert.ok(object.pass || object.args.length === 9,  
            'Test failed for: ' + object.args)); 
      JSC.test( 
       'Check Length SSN', 
       function (verdict, ssn) { 
          return verdict(checkLengthSsn(ssn)); 
       }, 
       [ 
          JSC.SSN(JSC.integer(100, 999), JSC.integer(10, 99),   
             JSC.integer(1000,9999)) 
       ], 
       function (ssn) { 
          return 'Testing Custom SSN:  ' + ssn; 
       } 
    ); 
)};
1
2
3
1 JSC.SSN(JSC.integer(100, 999), JSC.integer(10, 99), JSC.integer(1000,9999))
1
2
3
4
5
6
7
8
9
10
11
12
13
Check Length SSN: 
100 classifications, 100 cases tested, 100 pass 
 
Testing Custom SSN:  121-76-4808 pass 1 
Testing Custom SSN:  122-87-7833 pass 1 
Testing Custom SSN:  134-44-6044 pass 1 
Testing Custom SSN:  139-47-6224 pass 1 
... 
Testing Custom SSN:  992-52-3288 pass 1 
Testing Custom SSN:  995-12-1487 pass 1 
Testing Custom SSN:  998-46-2523 pass 1 
 
Total pass 100
1 JSC.SSN(JSC.integer(100, 999),JSC.integer(10, 999),JSC.integer(1000,9999))

Figure 6.9. A failure detected as a result of an invalid property check with QUnit. When
you randomize the input to include invalid inputs, the JSCheck algorithm has enough
entropy that 89 of 90 tests fail.
Figure 6.10. QUnit/Blanket output running the imperative showStudent  with valid
input. The highlighted lines represent statements that never ran. Because 12 of 15
Listing 6.6. Custom JSC.SSN speci×er
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
/** 
  * Produces a valid social security string (with dashes) 
  * @param param1 Area Number   -> JSC.integer(100, 999) 
  * @param param2 Group Number  -> JSC.integer(10, 99) 
  * @param param3 Serial Number -> JSC.integer(1000,9999) 
  * @returns {Function} Specifier function 
*/ 
JSC.SSN = function (param1, param2, param3) { 
   return function generator() { 
      const part1 = typeof param1 === 'function' 
         ? param1(): param1; 
      const part2 = typeof param2 === 'function' 
         ? param2(): param2; 
      const part3 = typeof param3 === 'function' 
         ? param3(): param3; 
      return [part1 , part2, part3].join('-'); 
   }; 
};
1
2
3
1 <script src="imperative-show-student-program.js" data-cover></script>
1
2
3
4
QUnit.test('Imperative showStudent with valid user', function (assert) { 
    const result = showStudent('444-44-4444'); 
    assert.equal(result, '444-44-4444, Alonzo, Church'); 
});

lines ran, this registers only 80% of total coverage information on this function.
Figure 6.11. A positive unit test against the functional showStudent  generates a
100% line-percentage coverage. Every line of the testable business logic is executed!
Figure 6.12. The imperative version of showStudent  skips the positive path of
execution, which translates to only a few lines being executed and a low 40% coverage.
1 <script src="functional-show-student-program.js" data-cover></script>
1
2
3
4
QUnit.test('Imperative Show Student with null', function (assert) { 
    const result = showStudent(null); 
    assert.equal(result, null); 
});

Figure 6.13. The functional version of showStudent  skips lines related only to
manipulating the data that would have originated from an otherwise valid input.
1
2
3
4
QUnit.test('Functional Show Student with null', function (assert) { 
    const result = showStudent(null).run(); 
    assert.ok(result.isNothing); 
});

Figure 6.14. The functional showStudent  continues to yield great coverage results
even against invalid inputs.
Figure 6.15. Imperative if-else  blocks and for  loops in imperative code are
translated into the use of map , filter , and reduce  in functional programs.
Figure 6.16. Potential nodes in the imperative version of showStudent . These labels
have been converted into a Øowchart of nodes and edges, which illustrates the number
of different linearly independent paths through the code caused by the presence of
conditional statements.
Table 6.1. Other important static code metrics comparing the imperative to the
functional solutions
Imperative
Functional

Imperative
Functional
Cyclomatic complexity: 4
Cyclomatic complexity density: 29%
Maintainability index: 100
Cyclomatic complexity: 1
Cyclomatic complexity density: 3%
Maintainability index: 148

CHAPTER 7
Figure 7.1. JavaScript’s execution context stack on initialization. Depending on how
many scripts are loaded on the page, the global context can keep track of lots of
variables and functions.
1 const logger = function (appender, layout, name, level, message)
1
2
3
4
5
6
7
const logger = 
   function (appender) { 
      return function (layout)  { 
         return function (name)   { 
            return function (level) { 
               return function (message) { 
           ...

Figure 7.2. When invoking any function, like logger  in this case, the single-threaded
JavaScript runtime pauses the current global context and activates the context for the
new function to run. At this point, a link is created between the global context and the
function context, traversable via the scopeChain . Once logger  returns, its
execution context is popped off the stack, and the global context resumes.
Figure 7.3. How the function context grows when running nested functions. Because
each function produces a new stack frame, the stack grows in proportion to the level of
nesting in functions. Both currying and recursion rely on nested function calls.
Figure 7.4. With currying, each parameter of the curried function is internally
transformed to a nested call. This Øexibility of being able to supply parameters
sequentially has the downside of occupying additional stack frames.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
const add = function (a, b) { 
   return a + b; 
}; 
 
const c_add = curry2(add); 
 
const input = _.range(80000); 
 
addAll(input, add);   //->511993600000000 
addAll(input, c_add); //-> browser halts 
 
function addAll(arr, fn) { 
   let result= 0; 
   for(let i = 0; i < arr.length; i++) { 
     for(let j = 0; j < arr.length; j++) { 
       result += fn(arr[i], arr[j]); 
 
     } 
   } 
   return result; 
}
1
2
3
4
5
function increment(i) { 
   console.log(i); 
   increment(++i); 
} 
increment(1);

Figure 7.5. The longest  function, in order to ×nd the longest string in an array of size
n, grows proportionally to the size of the input, inserting n frames into the context
stack.
Figure 7.6. The composition of the function range  (returns a list of numbers from
beginning to end) with take  (reads the ×rst n elements). In eager evaluation, the
range  function executes completely, feeding its result to take . With lazy
evaluation, the result of range  never executes until the dependent operation,
take , is called.
1
2
3
4
5
6
7
8
9
function longest(str, arr) { 
    if(R.isEmpty(arr)) { 
      return str; 
    else { 
       let currentStr = R.head(arr).length >= str.length 
             ? R.head(arr): str; 
       return longest(currentStr, R.tail(arr)); 
    } 
}

1 Maybe.of(student).getOrElse(createNewStudent());
1
2
3
4
5
6
if(!student) { 
   return createNewStudent(); 
} 
else { 
   return student; 
}
1
2
3
4
5
6
7
var student = findStudent('444-44-4444'); 
if(student !== null) { 
    append('#student-info', student); 
} 
else { 
   append('#student-info', createNewStudent('444-44-4444')); 
}
1
2
3
_.chain([p1, p2, p3, p4, p5, p6, p7]) 
   .filter(isValid) 
   .map(_.property('address.country'))   .reduce(gatherStats, {}) 

4
5
6
7
8
   .values() 
   .sortBy('count') 
   .reverse() 
   .first() 
   .value()
Listing 7.1. Lodash’s lazy evaluation and shortcut fusion
1
2
3
4
5
6
7
8
9
10
const square = (x) => Math.pow(x, 2); 
const isEven = (x) => x % 2 === 0; 
const numbers = _.range(200); 
const result =  
   _.chain(numbers)     
    .map(square) 
    .filter(isEven) 
    .take(3) 
    .value();  //-> [0,4,16] 
result.length; //-> 5
1
2
1
2
square = R.compose(R.tap(() => trace('Mapping')), square); 
isEven= R.compose(R.tap(() => trace('then filtering')), isEven);
1
2
Mapping 
then filtering

By invoking a method on a function object:
By wrapping the function denition shown earlier:
1
2
3
var discountCode = 'functional_js_50_off'; 
 
rot13(discountCode); //-> shapgvbany_wf_50_bss
1
2
3
4
5
6
7
var rot13 = s => 
   s.replace(/[a-zA-Z]/g, c => 
      String.fromCharCode((c <= 'Z' ? 90 : 122) 
         >= (c = c.charCodeAt(0) + 13) ? c : c - 26)); 
         (c = c.charCodeAt(0) + 13) ? c : c - 26); 
    }); 
};
1 var rot13 = rot13.memoize();
1
2
3
4
var rot13 = (s => 
   s.replace(/[a-zA-Z]/g, c => 
      String.fromCharCode((c <= 'Z' ? 90 : 122) 
         >= (c = c.charCodeAt(0) + 13) ? c : c - 26))).memo
Listing 7.2. Using tap  to add performance timing calls
1
2
3
4
5
6
7
const start = () => performance.now(); 
const end = function (start) { 
    let end = performance.now(); 
    return (end - start).toFixed(3); 
}; 
const test = function (fn, input) {  
    return () => fn(input); 
1
2

Figure 7.7. A detailed view of two calls to the rot13  function with the message
“functional_js_50_off.” The ×rst time around, with an empty cache, the ROT13 code of
the provided discount code is computed. This result is stored in the internal cache with
a key generated from this input. The second call results in a cache hit: the value is
directly returned without the hash being computed again.
8
9
10
11
12
13
14
15
16
17
18
}; 
const testRot13 =  
     IO.of(start) 
       .map(R.tap(start('rot13'))) 
       .map(R.tap(test( 
            rot13, 
             'functional_js_50_off' 
       ))) 
       .map(end); 
testRot13.run(); // 0.733 ms 
testRot13.run(); // second time: 0.021 ms
3
Listing 7.3. Adding memoization to function calls
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
Function.prototype.memoized = function () { 
  let key = JSON.stringify(arguments); 
  this._cache = this._cache || {}; 
  this._cache[key] = this._cache[key] ||  
           this.apply(this, arguments); 
  return this._cache[key]; 
}; 
Function.prototype.memoize = function () { 
   let fn = this; 
   if (fn.length === 0 || fn.length > 1) { 
      return fn; 
   } 
   return function () {  
     return fn.memoized.apply(fn, arguments); 
   }; 
};
1
2
3
4
5
6
7

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
const m_cleanInput = cleanInput.memoize(); 
const m_checkLengthSsn = checkLengthSsn.memoize(); 
const m_findStudent = findStudent.memoize(); 
 
const showStudent = R.compose( 
    map(append('#student-info')), 
    liftIO, 
    chain(csv), 
    map(R.props(['ssn', 'firstname', 'lastname'])), 
    map(m_findStudent), 
    map(m_checkLengthSsn), 
    lift(m_cleanInput)); 
 
showStudent('444-44-4444').run(); //-> 9.2 ms on average (no memoization) 
 
showStudent('444-44-4444').run(); //-> 2.5 ms on average (with memoization)

Figure 7.8. Running the memoized factorial(100)  the ×rst time creates 100 stack
frames because it needs to compute 100! by multiplying every single number. On the
second call to factorial  with 101, via memoization it’s able to reuse the result of
factorial(100)  and create only 2 stack frames.
1
2
3
4
5
6
7
var factorial = function (n) { 
  let result = 1; 
  for(let x = n; x > 1; x--) { 
    result *= x; 
  } 
  return result; 
}
1
2
3
factorial(4) 
  4 * factorial(3) 
    4 * 3 * factorial(2) 

Figure 7.9. A detailed view of tail-recursive factorial(4)  evaluation. As you can
see, the function uses a single frame. TCO is in charge of throwing the current function
frame to give way for a new one, as if factorial  was being evaluated in a loop.
Figure 7.10. The similarities between a standard loop (left) and its equivalent tail-
recursive function. In both code samples, you can easily see the base case, the
afterthought or accumulated parameter, and the result.
4
5
6
7
8
9
10
      4 * 3 * 2 * factorial(1) 
        4 * 3 * 2 * 1 * factorial(0) 
           4 * 3 * 2 * 1 * 1 
      4 * 3 * 2 * 1 
    4 * 3 * 2 
  4 * 6 
return 24
1
2
3
4
5
6
7
factorial(4) 
  factorial(3, 4) 
  factorial(2, 12) 
  factorial(1, 24) 
  factorial(0, 24) 
  return 24 
return 24
1
2
3
const factorial = (n) => 
   (n === 1) ? 1 
    : (n * factorial(n - 1));

1
2
3
4
5
6
function sum(arr) { 
   if(_.isEmpty(arr)) { 
      return 0; 
   } 
   return _.first(arr) + sum(_.rest(arr)); 
}
1
2
3
4
5
6
function sum(arr, acc = 0) { 
   if(_.isEmpty(arr)) { 
      return 0; 
   } 
   return sum(_.rest(arr), acc + _.first(arr)); 
}

CHAPTER 8
Figure 8.1. This code has a big problem. Can you spot it? Because you need to fetch data
asynchronously, the students  object will never be populated in time to be added to
the roster table.
Listing 8.1. Function getJSON  using the native XMLHttpRequest
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
const getJSON = function (url, success, error) { 
   let req = new XMLHttpRequest(); 
   req.responseType = 'json'; 
   req.open('GET', url); 
   req.onload = function() { 
      if(req.status == 200) { 
         let data = JSON.parse(req.responseText); 
         success(data); 
      } 
      else { 
         req.onerror(); 
      } 
   } 
   req.onerror = function () { 
      if(error) { 
         error(new Error(req.statusText)); 
      } 
   }; 
   req.send(); 
};
1
2
3
4
5
6
7
8
9
var students = null; 
getJSON('/students', 
  function(students) { 
     showStudents(students); 
  }, 
  function (error) { 
     console.log(error.message); 
  } 
);

Listing 8.2. Nested JSON calls, each with its own success and error callbacks
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
getJSON('/students',  
    function (students) { 
      students.sort(function(a, b){ 
            if(a.ssn < b.ssn) return -1; 
            if(a.ssn > b.ssn) return 1; 
            return 0; 
      }); 
      for (let i = 0; i < students.length; i++) { 
         let student = students[i]; 
         if (student.address.country === 'US') { 
            getJSON(`/students/${student.ssn}/grades`,  
              function (grades) { 
                showStudents(student, average(grades)); 
              },  
              function (error) { 
                 console.log(error.message); 
              }); 
         } 
       } 
     },  
     function (error) { 
        console.log(error.message); 
    } 
);
1
2
2
3
4
Listing 8.3. Retrieving student records from the server by SSN
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
var _selector = document.querySelector; 
_selector('#search-button').addEventListener('click', 
  function (event) { 
   event.preventDefault(); 
   let ssn = _selector('#student-ssn').value; 
   if(!ssn) { 
      console.log('WARN: Valid SSN needed!'); 
      return; 
   } 
   else { 
      getJSON(`/students/${ssn}`, function (info) { 
          _selector('#student-info').innerHTML = info; 
          _selector('#student-info').addEventListener('mouseover', 
             function() { 
                 getJSON(`/students/${info.ssn}/grades`, 
                     function (grades) { 
                         // ... process list of grades for this 
                         //     student... 
                     }); 
             }); 
      }) 
      .fail(function() { 
           console.log('Error occurred!'); 
      }); 

Figure 8.2. A program’s simple linear control Øow breaks down on a remote call and
degenerates into a waterfall of nested function calls—a pyramid that grows
horizontally like a “Christmas tree of doom.”
28
29
   } 
});
Listing 8.4. Refactoring student retrieval using continuation-passing style
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
var _selector = document.querySelector; 
_selector('#search-button').addEventListener('click', handleMouseMovement); 
var processGrades = function (grades) { 
   // ... process list of grades for this student... 
}; 
var handleMouseMovement = () => 
   getJSON(`/students/${info.ssn}/grades`, processGrades); 
var showStudent = function (info) { 
  _selector('#student-info').innerHTML = info; 
  _selector('#student-info').addEventListener( 
     'mouseover', handleMouseMovement); 
}; 
var handleError = error => 
   console.log('Error occurred' + error.message); 
var handleClickEvent = function (event) { 
   event.preventDefault(); 
   let ssn = _selector('#student-ssn').value; 
   if(!ssn) { 
      alert('Valid SSN needed!'); 
      return; 
   } 
   else { 
      getJSON(`/students/${ssn}`, showStudent).fail(handleError); 

Figure 8.3. Results from running the buggy imperative code that mixes asynchronous
functions with a synchronous loop. While fetching the remote data, the function call
will always refer to the last iterated student record (in its closure) and print it several
times.
32
   } 
};
1
2
3
4
5
6
7
8
9
10
11
12
13
for (let i = 0; i < students.length; i++) { 
   let student = students[i]; 
   if (student.address.country === 'US') { 
      getJSON(`/students/${student.ssn}/grades`, 
         function (grades) { 
            showStudents(student, average(grades)); 
         }, 
         function (error) { 
           console.log(error.message); 
         } 
      ); 
   } 
}

Figure 8.4. Passing the current student  object as a parameter properly sets the
function’s closure and solves the ambiguity resulting from executing remote calls in a
loop.
Figure 8.5. How an async operation is wrapped in a Promise  and provided with two
callbacks: one for resolve  and another for reject . The promise begins with a
status of pending and then is either ful×lled or rejected, invoking the function
resolve  or reject , respectively, before moving into the settled state.
1 Promise.of(<long computation>).map(fun1).map(fun2);//-> Promise(result)
1
2
3
4
5
6
7
8
9
10
11
var fetchData = new Promise(function (resolve, reject) { 
 
  // fetch data async or run long-running computation 
 
  if (<success>) { 
     resolve(result); 
  } 
  else { 
     reject(new Error('Error performing this operation!')); 
  } 
});

Figure 8.6. A sequence of chained promises joined via the then  method. Each then
clause is executed serially with one promise value after the next as soon as each is
ful×lled.
Listing 8.5. Promisifying getJSON
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
var getJSON = function (url) { 
    return new Promise(function(resolve, reject) { 
        let req = new XMLHttpRequest(); 
        req.responseType = 'json'; 
        req.open('GET', url); 
        req.onload = function() { 
            if(req.status == 200) { 
               let data = JSON.parse(req.responseText); 
               resolve(data); 
            } 
            else { 
               reject(new Error(req.statusText)); 
            } 
        }; 
        req.onerror = function () { 
           if(reject) { 
              reject(new Error('IO Error')); 
           } 
        }; 
        req.send(); 
    });      
 };
1
2
3
4

PROMISES WITH JQUERY
If you’re a jQuery user, you’ve probably interacted with promises
already. jQuery’s $.getJSON  operation (and any variation of the
JQuery $.ajax  calls) returns its own Deferred  object (a
nonstandard version of a Promise ), which implements the Promise
interface and has a then  method. Hence, you can use
Promise.resolve()  to treat the Deferred  object as a Promise :
This object is now a thenable and used just like any promisied object. I
chose to implement my own getJSON  in listing 8.5 to illustrate the
process of refactoring an API call to use promises.
1 Promise.resolve($.getJSON('/students')).then(function () ...);
1
2
3
4
5
6
7
8
getJSON('/students').then( 
    function(students) { 
        console.log(R.map(student => student.name, students)); 
    }, 
    function (error) { 
        console.log(error.message); 
    } 
);
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
getJSON('/students', 
    function (students) { 
      students.sort(function(a, b){ 
            if(a.ssn < b.ssn) return -1; 
            if(a.ssn > b.ssn) return 1; 
            return 0; 
      }); 
      for (let i = 0; i < students.length; i++) { 
         let student = students[i]; 
         if (student.address.country === 'US') { 
            getJSON(`/students/${student.ssn}/grades`, 
              function (grades) { 
                showStudents(student, average(grades)); 
              }, 
              function (error) { 
                 console.log(error.message); 
              }); 
         } 
       } 
     }, 

Figure 8.7. The Øow of behavior through the chained use of promises. Each thenable
block contains a function that transforms the data passed through it. Although this
program is bug-free and has all the desired functional qualities, it’s inef×cient because
it uses a waterfall sequence of getJSON  requests to fetch each student’s grades.
21
22
23
24
     function (error) { 
        console.log(error.message); 
    } 
);
Listing 8.6. Fetching student and grade data with asynchronous calls
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
getJSON('/students') 
    .then(hide('spinner')) 
    .then(R.filter(s => s.address.country == 'US')) 
    .then(R.sortBy(R.prop('ssn'))) 
    .then(R.map(student => { 
        return getJSON('/grades?ssn=' + student.ssn) 
            .then(R.compose(Math.ceil, 
                forkJoin(R.divide, R.sum, R.length))) 
                .then(grade => 
                  IO.of(R.merge(student,  
                    {'grade': grade})) 
                    .map(R.props(['ssn', 'firstname', 
                        'lastname', 'grade'])) 
                    .map(csv) 
                    .map(append('#student-info')).run()) 
            ); 
    })) 
    .catch(function(error) { 
        console.log('Error occurred: ' + error.message); 
    });
1
2
3
4
5
6
Listing 8.7. Fetching multiple items at once with Promise.all()

Figure 8.8. The Øow of behavior through the chained use of linear as well as concurrent
promises with Promise.all() . Each thenable block contains a function that
transforms the data passed through it. This program is ef×cient because it can spawn
several parallel connections to fetch all the data at once.
1
2
3
4
5
6
7
8
9
10
11
const average = R.compose(Math.ceil,  
    forkJoin(R.divide, R.sum, R.length)); 
getJSON('/students') 
    .then(hide('spinner')) 
    .then(R.map(student => '/grades?ssn=' + student.ssn)) 
    .then(gradeUrls => 
      Promise.all(R.map(getJSON, gradeUrls))) 
    .then(R.map(average)) 
    .then(average) 
    .then(grade => IO.of(grade).map(console.log).run()) 
    .catch(error => console.log('Error occurred: ' + error.message));
1
2
3
4
5
Listing 8.8. find  function using the browser’s local store
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
// find :: DB, String -> Promise(Student) 
const find = function (db, ssn) { 
    let trans = db.transaction(['students'], 'readonly'); 
    const store = trans.objectStore('students'); 
    return new Promise(function(resolve, reject) { 
        let request = store.get(ssn); 
        request.onerror = function() { 
            if(reject) { 
               reject(new Error('Student not found!')); 
            } 
        }; 
        request.onsuccess = function() { 
            resolve(request.result); 
        }; 
    }); 
};
1
2
3

Figure 8.9. When composing synchronous code with asynchronous behavior, there’s a
point of inØexion in the program where the code shifts into a time-bound adjacent
sequence of events that happen within the con×nes of the promise type.
Listing 8.9. Asynchronous version of showStudent
1
2
3
4
5
6
7
8
const showStudentAsync = R.compose( 
     catchP(errorLog), 
     then(append('#student-info')), 
     then(csv), 
     then(R.props(['ssn', 'firstname', 'lastname'])), 
     chain(findStudentAsync), 
     map(checkLengthSsn), 
     lift(cleanInput));
1
2
3
1 [ERROR] Error: Student not found!

Figure 8.10. Executing the range  generator in a for..of  loop. Every iteration of
the loop prompts the generator to pause and yield new data. Hence, generators have
semantics similar to those of an iterator.
1
2
R.range(1, Infinity).take(1); //-> [1] 
R.range(1, Infinity).take(3); //-> [1,2,3]
1
2
3
4
5
function take(amount, generator) { 
  let result = []; 
  for (let n of generator) { 
    result.push(n); 
    if(n === amount) { 

Figure 8.11. Revisiting the apprentice graph from chapter 3, where each node
represents a student  object and each line represents a “student-of” relationship
6
7
8
9
10
11
       break; 
    } 
  } 
  return result; 
} 
take(3, range(1, Infinity)); //-> [1, 2, 3]


1
2
3
4
5
6
7
8
9
10
11
function squares() { 
  let n = 1; 
  return { 
    [Symbol.iterator]() { 
      return this; 
    }, 
    next() { 
      return { value: n * n++ }; 
    } 
  }; 
}
1
2
3
var iter = ['S', 't', 'r', 'e', 'a', 'm'][Symbol.iterator](); 
iter.next().value; // S 
iter.next().value; // t
1
2
3
var iter = 'Stream'[Symbol.iterator](); 
iter.next().value// -> S 
iter.next().value// -> t
1
2
Next: 1 
Next: 2 

Figure 8.12. The process of applying functions filter  and map  from an observable
sequence of numbers
3
4
Next: 3 
Completed
1
2
3
4
5
6
7
8
9
10
11
const squares = Rx.Observable.wrap(function* (n) { 
  for(let i = 1; i <= n; i++) { 
     return yield Observable.just(i * i); 
  } 
}); 
 
squares(3).subscribe(x => console.log(`Next: ${x}`)); 
 
Next: 1 
Next: 4 
Next: 9
1
2
3
4
5
6
7
8
9
document.querySelector('#student-ssn') 
    .addEventListener('change', function (event) { 
        let value = event.target.value; 
 
        value = value.replace(/^\s*|\-|\s*$/g, ''); 
        console.log(value.length !== 9 ? 'Invalid' : 'Valid')); 
}); 
//-> 444          Invalid 
//-> 444-44-4444  Valid

Figure 8.13. Shows the event values for SSN treated as an observable stream created
from subscribing to the change  event of the student SSN input ×eld
1 Error: IO Error

