arXiv preprint
Bluefish: A Relational Grammar of Graphics
Josh Pollock, Catherine Mei, Grace Huang, Daniel Jackson, Arvind Satyanarayan
Fig. 1: Data-driven graphic representations built with Bluefish. These graphics run the gamut from statistical charts to diagrams, and
are constructed with user-extensible, domain-specific elements and a consistent, universal set of perceptual grouping primitives.
From left to right: an UpSet plot [37], U.S. Polio incidence rates from the Charticulator gallery [53], ChartAccent [52], Python
Tutor [23], an annotated diagram of an Aspirin molecule, and the Euclidean geometric proof of the Pythagorean Theorem.
Abstract—The Grammar of Graphics (GoG) has become a popular format for specifying visualizations because it unifies different chart
types into a consistent, modular, and customizable framework. But its benefits have not yet reached the broader class of data-driven
graphic representations—from annotated charts and hierarchical visualizations to molecular structure diagrams, Euclidean geometry,
and mathematical formulae. These graphics are still developed using rigid typologies, monolithic tools, or specialized grammars that
lack the customizability and generality of the GoG. In response, we present Bluefish, a relational grammar of graphics that extends the
benefits of the GoG to this larger domain. Bluefish provides two key abstractions: user-extensible, domain-specific elements (e.g.,
mathematical expressions, chemical atoms, or program state stack frames); and perceptual groupings (also known as Gestalt relations)
like proximity, nesting, and linking. Users compose these primitives within a Bluefish specification, which the language runtime compiles
to a relational scenegraph: a formal representation of a graphic that, compared to traditional tree-based scenegraphs, better preserves
semantic relationships between visual elements. To illustrate its flexibility, we show that Bluefish can represent data-driven graphic
representations across a diverse range of domains while closely aligning with domain-specific vocabulary. Moreover, to demonstrate
the affordances of Bluefish’s relational scenegraph, we develop a prototype screen reader tool that allows blind and low-vision users to
traverse a diagram without significant additional scaffolding.
Index Terms—Data Visualization, Grammar of Graphics, Perceptual Groupings.
1
INTRODUCTION
When designing the Grammar of Graphics (GoG), Leland Wilkinson set
out “to produce a package that could draw every statistical graphic [he]
had ever seen” [77]. In contrast to prior approaches at the time—which
provided chart typologies that offered only a fixed collection of charts
with limited customization—Wilkinson constructed a compositional
language with six primitives: data, transforms, marks, scales, guides,
and coordinate systems. As a result, the GoG affords visualization
authors a large expressive gamut without imposing a heavy specification
burden, and its design has influenced modern visualization languages
like Tableau’s VizQL [24,65], ggplot2 [76], and Vega-Lite [62].
However, Wilkinson’s GoG and its descendants are largely focused
on statistical graphics (i.e., graphic representations that compare quan-
tities [73]). To author a broader class of data-driven graphic repre-
sentations—from annotated charts and hierarchical visualizations to
molecular structure diagrams, Euclidean geometry, and mathematical
formulae—users must either invoke layout algorithms as data trans-
formations (a mechanism that violates the clean separation between
data values and visual variables) or fallback to more brittle approaches
including rigid typologies and monolithic tools. For example, Mer-
• Josh Pollock is with the Massachusetts Institute of Technology. E-mail:
jopo@mit.edu
• Catherine Mei is with the Massachusetts Institute of Technology. E-mail:
meic1212@mit.edu
• Grace Huang is with the Massachusetts Institute of Technology. E-mail:
gracefh@mit.edu
• Daniel Jackson is with the Massachusetts Institute of Technology. E-mail:
dnj@csail.mit.edu
• Arvind Satyanarayan is with the Massachusetts Institute of Technology.
E-mail: arvindsatya@mit.edu
maid [68] is a popular JavaScript library for Markdown-based diagram-
ming but offers a fixed palette of diagram types including flowcharts,
class and state diagrams, and Gantt charts each with only a handful of
customization options (e.g., only some diagram types allow customiz-
ing the curve style of arrows). While a new class of domain-specific
languages has emerged to fill this gap [44], these languages further
fragment the landscape of tools. For instance, SmilesDrawer [51],
GoTree [38], and Gosling [41] offer different abstractions for the shared
concept of annotation. This fragmentation creates a burden for both
language developers, who must reimplement similar primitives, as well
as diagram authors, who must learn multiple often inconsistent and
incompatible methods of accomplishing the same goal. Moreover, this
fragmentation often causes authors to shepherd a diagram back-and-
forth between separate tools [6,7]—a tedious, manual operation that
is difficult to automate, must be repeated every time the diagram is
updated, and can lead to visual inconsistencies that ultimately impact
the reader. A unified language for data-driven graphic representations
can empower both end-users and grammar designers to author complex
graphics using consistent, compositional abstractions.
In this paper, we introduce Bluefish, a grammar that extends the
benefits of compositional specification to data-driven graphic repre-
sentations beyond statistical charts. Bluefish diagrams are authored
with two classes of primitives (Sect. 3). The first are user-extensible
elements: the unique vocabulary for a particular visual domain (e.g.,
marks in visualization, atoms and bonds in a molecular structure, stack
frames in a visualization of program state, etc.). The second set of
primitives are perceptual groupings: a choice of visual arrangement
of elements that conveys information about the relationships between
them (a concept also known as Gestalt relations [74]). For example,
in an annotated chart, the proximity of a text label to a dot mark as-
sociates the two together; in a chemical diagram, a line connects two
atoms together as part of their bond; and, in a piece of augmented math
1
arXiv:2307.00146v1  [cs.GR]  30 Jun 2023

static
perceptual group
example
GoG [77]
(statistical graphics)
SetCoLa [26]
(node-link diagrams)
GoTree [38]
(tree visualizations)
Cross-View [67]
(coordinated
multi-views)
Bluefish
(graphic
representations)
spatial proximity
ordinal scale
facet
offset channel
position
cluster
circle
juxtapose, flatten
-
Distribute
similar attribute
implicit in encoding implicit in encoding
implicit in encoding
Highlight
AlignProps
alignment
(similar position)
implicit in encoding
alignment
align
-
Align
element
connectedness
line mark
links
Link
Link, Bundle
Link
common region
rect mark
hull
within, include
Enclosure
Enrichment
Contain
Background
other
-
custom transforms
order
-
Cluster
user-extensible
Fig. 2: The static perceptual groupings we scope to, how they manifest in various visualization systems, and how we implement them in Bluefish.
notation [25], similar colors relate a symbol to its definition.
Bluefish is embedded in JavaScript, and diagrams are authored in
JSX, a syntax extension to JavaScript popularized by the React library.
Bluefish specifications are compiled into a relational scenegraph: a run-
time data structure used for layout and rendering (Sect. 4). In contrast to
traditional tree-based scenegraphs, Bluefish’s relational scenegraph re-
tains more semantic information about the relationships between visual
elements (e.g., containment and connection). To layout the scenegraph,
Bluefish adopts local propagation rather than global constraint solvers
for a more modular and extensible runtime architecture.
To evaluate Bluefish’s expressivity, we construct a gallery of ex-
amples spanning the gamut from statistical charts through to broader
data-driven graphic representations such as the Python Tutor [23] pro-
gram state visualization and the Euclidean geometric proof of the
Pythagorean theorem. These examples demonstrate that Bluefish en-
ables a highly compositional authoring workflow, where new custom
graphical elements or perceptual groups can be constructed as com-
binations of existing primitives. Moreover, our examples show how
Bluefish can serve as the foundation of higher-level and domain-specific
grammars — for instance, we implement a GoG called Bluefish Plot
(modeled off Observable Plot [14] and Victory Charts [15]), and detail
how a series of abstraction steps can transform a specification of a tree
diagram into the GoTree visualization grammar [38].
We further develop a prototype screen reader tool to demonstrate how
Bluefish’s relational scenegraph can enable more accessible data-driven
graphic representations. In particular, as the scenegraph reflects the
relational structure of the diagram, novel screen reader structures can
be constructed that enable navigation that is more fluid and aligned with
the semantics of the graphic domain. We illustrate these affordances
by making two examples from our gallery (ChartAccent [52] and an
annotated Aspirin molecule) accessible. In doing so, we find that as
compared to existing state-of-the-art approaches [9,83], users can more
easily move between annotations and data values, and traverse the
bonds and rings of the chemical molecule.
2
RELATED WORK
2.1
Graphic Representations & Perceptual Groups
In visualization, when we refer to “graphics” we often mean statistical
graphics [77] Famed psychologist, Barbara Tversky offers a broad
definition: a graphic is as a visual artifact consisting of “elements that
are systematically arranged in space” [69]. Yuri Engelhardt defines
a scope in-between the two called graphic representations [73] with
ten primary types (including charts, tables, maps, pictures, and written
text among others). These definitions inspire the scope and design
of Bluefish: we focus on a set of data-driven graphic representations
(i.e., those amenable to programmatic generation) via two classes of
primitives, elements and perceptual groupings. Perceptual groupings,
also known as Gestalt relations [74], can not only spatially arrange
elements but also denote other relationships including containment and
connection. Perceptual groups can cover a broad range of phenomena
including temporal grouping (such as when several elements move
in the same direction) or deal with complex emergent phenomena
like continuity or closures. Bluefish focuses on a class of groupings
commonly found in static data-driven graphical representations [54,69,
73,74]. We illustrate these groupings in Fig. 2.
2.2
Visualization, Diagramming, and UI Toolkits
Visualization Grammars. Fig. 2 summarizes how different visualiza-
tion grammars surface perceptual groupings. GoG-based systems like
VizQL [24], ggplot2 [76], and Vega-Lite [62] do not explicitly encode
perceptual groupings. Rather, perceptual groupings occur as a result of
other primitives the grammars offer — for instance, spatial proximity
via ordinal scales or facets, similar attributes and alignment via the
visual encoding mapping, etc. As a result, and as we show in Fig. 3, it
can be difficult to rapidly explore alternate perceptual groupings. To
address this limitation, researchers have developed domain-specific
visualization grammars such as SetCoLa [26] and GoTree [38] with
explicit grouping operators. While useful, these operators model per-
ceptual groups as a system of constraints. As a result, these operators
can only be composed in limited ways. In contrast, Bluefish offers
explicit perceptual grouping operators modeled as components — an
approach that facilitates accretive design, where new components can
be rapidly created as combinations of existing ones. We elaborate on
these differences and their implications in Sect. 3.3.2.
UI Toolkits and Embedded Grammars. Modern user interface
toolkits like React, SwiftUI, and Jetpack Compose have converged on
the concept of a component to author UIs in a modular way. A UI
component colocates related pieces of structure, content, and styling.
Crucially, components can be nested, which produces new components
that work the same way as primitive components (such as HTML el-
ements) supplied by the system. This allows UI authors to build and
share libraries of reusable functionality tailored to their specific prob-
lems, and to seamlessly compose many different libraries together. This
approach stands in contrast to visualization systems which, with rare
exceptions [45], offer a fixed palette of mark types. As a result, many
developers have sought to embed the GoG in UI frameworks. Two
prominent examples include Swift Charts [1] (embedded in SwiftUI)
and Victory Charts [15] (embedded in React). These libraries take ad-
vantage of the UI component model to provide additional extensibility
for custom marks and axes, and high-level components for common
chart types. These frameworks often also provide operators for some
perceptual grouping — typically spatial layout and alignment. How-
ever, as with the SetCoLa [26] and GoTree [38], these operators are
modeled as constraints which limit their expressivity. Moreover, this
relational information is not preserved in the resultant interface (e.g.,
as annotations on the Document Object Model nodes). As a result,
downstream tools (such as assistive technologies) are unable to provide
semantically-aligned representations of visual content.
Diagramming Languages. The idea of composing primitive ele-
ments to create new ones has also been embraced by diagramming lan-
guages and toolkits including Haskell Diagrams [80], Diagrammar [21],
Manim [55], and Penrose [81]. These libraries provide primitives for
many perceptual groups, but their APIs lack consistency and often
expose perceptual groups as constraints. For example, Manim pro-
2

arXiv preprint
vides a next_to method for shapes that is similar to Row and Col
components in Bluefish. However, next_to does not produce a new
component; rather, it returns the modified object for method chaining.
Penrose programs are split into Substance and Style files, analogous
to HTML and CSS, respectively. As a result, Penrose does not have a
concept of a component. We provide a closer comparison to Penrose in
Sect. 5.2. Additionally, some developers have created high-level dia-
gram typologies, such as Mermaid [68]. While these tools provide for
low viscosity authoring, they tradeoff customization and expressivity.
Layout Strategies. In addition to differences in user-facing APIs,
these systems make different implementation decisions to lay out a
user’s specification. Diagramming systems and domain-specific visual-
ization grammars often select global solvers like linear programming or
gradient descent for their expressivity. However UI toolkits and some
diagramming languages opt for simpler, dataflow-based techniques
like local propagation [64]. In fact, SwiftUI replace their Auto Layout
engine (based on the global linear programming solver Cassowary [2])
with a dataflow technique. Bluefish uses local propagation for layout,
because it affords low viscosity and integration with external layout
algorithms. We detail this design decision in Sect. 4.2.
3
THE BLUEFISH LANGUAGE DESIGN
We scope Bluefish to support static, data-driven graphic representations
via two classes of primitives: elements, which determine the graphical
entities that comprise the diagram; and perceptual groupings, that
define relationships between the elements. Bluefish surfaces these
primitives through JSX, an extension to JavaScript popularized by the
React library that emulates XML and HTML syntax. JSX provides two
types of tags: self-closing tags (e.g., <Rect />) which are well-suited
for instantiating simple elements, and block or container tags (e.g.,
<Group>...</Group>) for composition and perceptual grouping.
3.1
Design Goals
Bluefish’s abstraction design is motivated by the following goals:
Vocabulary Correspondence. A user should be able to specify a
graphic with primitive elements that map closely to their domain. We
adapt this goal from Ma’ayan & Ni et al. [42] as well as the Cognitive
Dimensions of Notations [8]. While marks like text, rectangles, circles,
and lines provide the foundations for graphic elements, they present
a greater articulatory distance [28] than primitives tailored to the au-
thor’s domain (e.g., atoms, bonds, and rings for diagrams of chemical
molecules). However, we recognize that it is impossible for language
designers to anticipate every possible primitive for every possible do-
main. And even if one could produce such a collection, doing so would
impose a large maintenance burden on language developers. Thus,
when authoring graphic representations, users must be able to both use
and create domain-specific elements.
Creation By Composition. Domain-specific elements are often
created by composing simpler elements. For example, a piece of
math notation is often a deeply nested collection of basic symbols
that are composed using lines, superscript and subscript positioning,
and horizontal spacing These kinds of elements are typically called
glyphs in the visualization literature [46,60]. But, with the exception of
Atlas [39] and GoG libraries embedded in UI frameworks, visualization
grammars do not provide abstraction mechanisms for creating glyphs
that work like built-in marks [44,78,79]. Instead, to compose complex
graphics, users of visualization grammars typically concatenate many
specifications together. Bluefish provides a set of design patterns,
and leverages JSX notation, to allow users to create new elements by
composing together existing ones.
Universal Composition. Counterbalancing the focus of the previous
goals, the mechanisms for composition should afford authors the ability
to cut across and cohere visual elements from disparate domains as part
of a single diagram. Just as basic graphical marks are shared across
domains, we aim to design a set of universal patterns for composition.
This goal is motivated by a call from Park et al. who argue for the
need to “unify many of these existing grammars, while retaining both
the simplicity and power of the original ones” [49]. In Bluefish, we
achieve universal composition through a standard library of perceptual
groupings — a set of operators drawn from the broader class of Gestalt
relations to indicate some visual elements as “going together more
strongly than others” [74]. Moreover, to ensure consistent composi-
tion [8], invoking a perceptual grouping produces a new element that
can participate in further compositions with other perceptual groupings.
Low Viscosity. Users should be able to make atomic edits to the
specification in order to rapidly explore alternate designs [8]. In Blue-
fish, low viscosity manifests in two ways. First, the semantics of the
perceptual grouping operators are consistent with one another: users
should be able to trivially replace one perceptual grouping with another,
and produce a valid graphic without having to refactor the specification.
Second, the behavior of perceptual grouping operators are determined
entirely by their input properties and children. As a result, a user is
able to locally reason about the behavior of a perceptual grouping as an
isolated component.
3.2
User-Extensible Visual Elements
Bluefish provides a base set of elements that reflect native SVG:
Circle, Line, Rect, and Text. Users can also define new ele-
ments by composing existing ones via the affordances of JSX notation.
For example, the original version of Python Tutor uses a combination
of divs and a table to represent a stack frame (Fig. 1). As this
combination of elements is a meaningful semantic unit of a runtime
program state visualization, an author might choose to encapsulate this
code in a reusable JSX component like so:
StackFrame = ({ header, vars }) => (<div>
<div>{header}</div>
<table>{vars.map(({name, value}) => (
<tr><td>{name}</td><td>{value}</td><tr>
))}</table>
</div>)
This component may then be used like a native element:
<StackFrame header="Global Frame"
vars={[{name: 'x', value: 5}, {name: 'y', value: 6}]} />
Occasionally, a user may need to define a new base element that is
not a composition of others (for example, an Image). For such cases,
Bluefish provide a lower-level element definition API. Once registered,
these custom elements are indistinguishable from those built-in (in fact,
all of Bluefish’s base elements are written with this API).
3.3
Perceptual Grouping Operators
Perceptual groupings (also known as Gestalt relations [74]) are ways
of visually arranging elements to convey relationships between them.
These groupings can cover a broad range of phenomena. For instance,
some groupings unfold temporally, such as common fate when sev-
eral elements move in the same direction or towards the same place.
Other groupings deal with complex emergent visual phenomena, such
as closure where an incomplete element is nevertheless perceived as
whole. At present, and as shown in Fig. 2, Bluefish focuses on per-
ceptual groupings commonly found in static graphics including spatial
proximity, similar attribute, alignment (i.e., similar position), element
connectedness, and common region. These groupings are exposed as
block or container tags in the JSX notation (i.e., a component with
children). Thus, to express a grouping in Bluefish, we write
<PerceptualGroup><Child1 />...<ChildN /></PerceptualGroup>
where each Child instantiates a particular visual element (e.g., text,
shapes, or domain-specific glyphs and primitives).
3.3.1
Perceptual Grouping Definitions
Spatial Proximity (<Distribute>). Spatial proximity manifests
groups in one of two ways. First, among pairs or small collections of
elements, spatial proximity can take the form of relative spacing. For
instance, elements A and B may be grouped together if no element C
is closer to A or B than they are to each other. On the other hand, by
chaining together many elements with roughly equal spacing, we can
create a region of uniform spacing to collectively group the elements.
We represent spatial proximity using a Distribute component
that evenly spaces its children. The component takes a direction
3

Fig. 3: Perceptual group viscosity in Vega-Lite and Bluefish: We first define a basic chart in both languages. To add an annotation in Vega-Lite
we first filter the data and use an xOffset encoding to place a text mark. In Bluefish we also filter the data, but place the label using Align and
Distribute groupings. To move this annotation outside the plot in Vega-Lite, we have to introduce a new param, switch the xOffset to an
x encoding, and add a rule mark that implicitly connects to the data and label. In Bluefish, we simply name the plot, use that name to change the
target of the Distribute, and add a Link grouping. Finally, to highlight this annotation in Vega-Lite, we need to manually compute padding
to define the encoding of a rect mark. In Bluefish, we use a Contain grouping.
(horizontal or vertical), a spacing attribute to dictate the size of the
gaps between children, and a total attribute to specify the sum of
gaps and children sizes. If both attributes are specified, Distribute
computes the space available for each child element and sizes it ac-
cordingly. Bluefish does not provide a relative spacing component as
enforcing it requires reasoning about all elements in a graph to ensure
there is no closer element. This component would violate our design
goal of low viscosity, since its behavior is not defined exclusively by
its input properties and children.
Similar Attribute (<AlignProps>).
Elements may appear
grouped if they share common traits like color, size or angle. Sim-
ilar attribute grouping is invoked via the AlignProps component,
which takes two parameters: props and values. The component
inspects its children to identify whether the given props are specified
on any child element; if so, their values are propagated to all other chil-
dren. If none of the children define the given props, the corresponding
values are propagated to the children instead.
Spatial Alignment (<Align>). Elements may also be grouped
together if they are spatially aligned. We implement this using an
Align component. In the typical case, a user specifies an align-
ment prop on the Align component. This alignment can be in just
one direction, such as left, or in both the x and y directions, such
as topCenter. To override this alignment for a specific component,
a user can provide the guidePrimary prop to that component with
a different alignment. Although spatial alignment can be conceived
of as applying a similar attribute to positions, doing so would require
exposing granular coordinate properties like left and topCenter
on individual elements. We instead follow D3’s principle of ecosystem
compatibility [13], opting for elements to be positioned and sized via
an API more native to vector graphics (i.e., x, y, width, height,
etc.). As a result, AlignProps is more difficult to reuse and Bluefish
provides Align for spatial alignment.
Element Connectedness (<Link>). When elements are connected
by a line, they can be perceived as being related. Some researchers
argue this relationship emerges from two alignments that group the con-
nector’s endpoints with the elements. Others argue that the connection
itself creates a perceptual group [74]. The former can be expressed
using a pair of Align components, and the latter is implemented with
Link. The advantage of creating a custom component for this grouping
is that a user needs to write a single component, and we can infer which
sides to align the endpoints to based on the positions of the elements.
Bluefish’s Link component follows the line element interface in
Scalable Vector Graphics (SVG). However, whereas the position of an
SVG line is determined by an explicit set of start and end coordinates,
Bluefish’s Link determines its positions via its children. The current
implementation of this component only supports two child elements,
and it only renders an SVG line.
Common Region (<Contain> & <Background>). Elements
lying within a contour or nested inside one another are often perceived
as being grouped together. Thus, common region can be interpreted
in one of two ways. First, if element A contains (i.e., its visual bound-
ary entirely wraps around) element B, we perceive A and B as being
grouped. On the other hand, if A contains B, C, and D, we perceive B, C,
and D as grouped, and that A is instead the reification of that grouping.
Bluefish provides two components to support these two forms of
common region grouping. The Contain component takes exactly two
children, with the first designated as the container and the second as
the contained element — whichever child does not have a specified size
is resized to fit or fit within the other. An optional padding attribute
may be specified to providing spacing between the two elements. In
contrast, the Background component takes an arbitrary number of
children, and a required element attribute specifies an additional
element that is used as the background.
3.3.2
Design Considerations and Rationale
The design of Bluefish’s perceptual grouping operators follows directly
from the design goals described above in Sect. 3.1. In particular, as
research has shown [54,69,73], perceptual groups are a fundamental
feature of graphic representations regardless of the underlying domain
or context. We see further evidence of this in the fact that, as shown in
4

arXiv preprint
Fig. 2, many of the primitives found in domain-specific and domain-
agnostic toolkits reflect perceptual groupings. However, there are two
key differences between how perceptual groups are realized in prior
toolkits, and how they are reified in Bluefish.
First, for several of these prior approaches, perceptual groupings
occur implicitly through the use of their primitives. For example, with
the GoG [77], spatial proximity is conveyed through ordinal scales,
facets, or offset encoding channels; attribute similarity is similarly
implicit in the visual encoding adopted across not only the GoG but
domain-specific approaches like SetCoLa [26] and GoTree [38] as
well. In contrast, Bluefish makes perceptual groupings an explicit set
of operators. And, in doing so, Bluefish is able to facilitate a less
viscous [8] authoring process. For instance, consider the sequence
of changes shown in Fig. 3 which iteratively redesign the perceptual
groupings used to associate a textual label with its target point mark —
starting with spatial proximity and alignment, changing the definition
of proximity and adding element connectedness, and finally aligning
attributes as well. As perceptual grouping is an implicit result of primi-
tives offered by the GoG (and its descendants including Vega-Lite as
shown in the figure), each of these steps requires making edits across
the entire specification rather than atomic edits to a localized portion.
Moreover, in the case of Vega-Lite specifically, although values for
horizontal alignment and similar colors can be hardcoded into the spec-
ification, doing so risks introducing inconsistencies when iteratively
exploring alternate designs. Ensuring consistency, however, requires
extracting the shared value as a param — a step that introduces a level
of indirection. In contrast, by providing explicit perceptual grouping
operators, Bluefish allows users to explore alternate designs by making
only targeted changes to the specification. Shared values required for a
perceptual group are defined in situ, reducing the need for indirection.
Second, where prior toolkits offer explicit grouping mechanisms
(e.g., SetCoLa’s and GoTree’s primitives for spatial proximity, align-
ment, connectedness, and common region), they model them as con-
straints — i.e., functions to be solved by a constraint engine. As a result,
users are limited to only declarative statements about perceptual groups
and are not able to operate on them further — for instance, composing
them into reusable glyphs, or referencing a perceptual grouping as part
of a downstream operation. Moreover, because element connectedness
and common region are expressed with elements, a constraint-based
API cannot express grapperceptual groups consistently. In contrast,
Bluefish exposes perceptual groupings as components, a design de-
cision that has syntactic and semantic consequences. Syntactically,
modeling perceptual groupings as components allows for a closeness
of mapping [8]: a perceptual group is defined by wrapping a container
tag around participating elements, akin to how groupings are defined
in other languages likely to be familiar to diagram authors including
HTML (e.g., <div> tags) and SVG (i.e., <g> tags). Semantically,
as perceptual groups are components, diagram authors can treat them
as higher-order elements, using them wherever they might have other
elements. For instance, the final step in Fig. 3 wraps a common region
grouping around the connectedness grouping of the label and dot mark.
3.3.3
Limitations and Custom Groups
Bluefish’s standard library of perceptual groupings is not intended to be
exhaustive. Rather, it captures common groupings for static data-driven
graphics [54,69,73,74], informed by our design goals. For instance,
Bluefish does not support grouping by element symmetry, because it
is typically a global property of the placement and attributes of all ele-
ments in a region, rather than a local, composable grouping [74]. Other
emergent visual phenomena such as continuity and closure also emerge
from global interactions between elements. Finally, Bluefish’s current
implementation (detailed in Sect. 4) relies primarily on reasoning about
rectangular bounding boxes; this makes it difficult to support groupings
like parallelism which would require reasoning about more complex
shape representations such as parallel lines or curves.
To account for these limitations, Bluefish allows users to author their
own perceptual grouping operators via custom components. For in-
stance, a user could combine existing perceptual groups to create a new,
compound group (such as combining Align and Distribute into
a Row or Col component). Alternatively, for even more customization,
users can write components that invoke custom layout algorithms. We
provide examples in Sect. 5.3. If these components are written using
Bluefish’s component and layout interfaces, they compose just as well
as Bluefish’s standard collection of groupings. In fact, our standard
perceptual groupings are implemented with the same API.
3.4
Overlapping Groups with Declarative References
Fig. 3 also illustrates an additional consequence of offering percep-
tual groupings as first-class primitives: overlapping perceptual groups.
In particular, the label participates in three perceptual groups: a
proximity group with the overall plot, a connectedness group with the
maxDot, and finally, a common region. These groups overlap not only
as adjacent siblings (as with proximity and connectedness) but also
nested within one another (as with common region).
To express these overlaps, Bluefish offers a Ref component that
works like a declarative query selector. Users can reference elements
by their name — a property that must be unique to the local scope an
element is instantiated in, rather than globally across an entire figure
akin to a DOM node ID — or by specifying a path of names. In the
latter case, Bluefish resolves the reference by traversing the path one-
by-one, entering an element each time, and searching its local scope
for the next named element. Since each element maintains a local
coordinate frame, once a reference has been resolved to an element,
that element’s size and position must be converted to the Ref’s local
frame. Moreover, if a Ref is a child of a perceptual group, then any
changes the perceptual group makes to the Ref (e.g., to its position,
size, or other attributes) are propagated back to the referenced element.
We considered using JavaScript’s own variable bindings instead of a
separate Ref component for specifying overlaps. However, we found
that this interpretation of bindings competed with users’ existing men-
tal model of JSX: using a component bound to a variable in multiple
places creates different copies of a component rather than referencing
it, as is needed with Bluefish. Moreover, using explicit Refs simplifies
the implementation of the system, because it allows us to construct
a relational scenegraph within the confines of a tree-structured hier-
archy. Sect. 4 explains this in more detail. We leave to future work
opportunities to incorporate variable bindings as syntactic sugar and to
expand the expressivity of how elements may be referenced (e.g., via
XML query languages such as XPath [3,17] and XQuery [10], or by
generalizing Cicero’s specifiers [29] and Atlas’s find function [39]).
4
THE BLUEFISH RELATIONAL SCENEGRAPH
Bluefish is implemented in React, a widely used library for developing
interactive user interfaces. We chose React in order to leverage its
existing component ecosystem, and to allow us to focus our efforts on
implementing our abstractions for perceptual grouping, rather than on
reactivity, state, and rendering. When an end user composes Bluefish
elements and perceptual groups, the language runtime compiles this
specification into a relational scenegraph: a data structure used to
resolve references between elements, propagate shared attributes, and
compute layout. Critically, in contrast to tree-based scenegraphs that
are standard in UI and visualization toolkits, Bluefish’s relational scene-
graph is an instance of a compound graph — a data structure that allows
us to maintain the hierarchical information of traditional scenegraphs
while allowing individual nodes to have multiple parents in order to
support overlapping perceptual groups (Sect. 3.4).
4.1
Adapting a Compound Graph Structure
Compound graphs have been explored in research on graph draw-
ing [66] and hierarchical edge bundling [27]. They encode not only
hierarchical relationships between nodes (i.e., parent-child) but also
allow for non-hierarchical relationships called adjacencies. In Bluefish,
we instantiate a compound graph as follows:
Nodes. Each node in the scenegraph corresponds to an element
instantiated in JSX. Nodes hold information necessary for rendering
the corresponding element (e.g., visual styles) as well as computing
layout. Layout information includes a partially defined bounding box,
5

Group
Plot
Dot
ScaledDot
ScaledDot
ScaledDot
XAxis
YAxis
Grid
Text
Align
maxDot
lbl
Distribute
plot
lbl
Link
maxDot
lbl
Contain
link
lbl
plot
maxDot
link
…
…
Fig. 4: The relational scenegraph corresponding to Fig. 3. Hierarchical
relationships are expressed via containment, and adjacencies using
visual links following Sugiyama [66].
a boundary curve for line-like elements, and any transformations to
position and size this node based on higher-level nodes.
Hierarchy and Adjacencies. Nodes are assembled into a hierarchy
following the nesting structured established by the JSX specification.
An adjacency relation is established for every Ref element (Sect. 3.4):
a node is instantiated in the hierarchy for the Ref, and it links to
the referenced node as an adjacency. As a result, and unlike general
compound graphs where adjacencies can connect any pair of nodes,
adjacencies in Bluefish always originate at leaf nodes (i.e., Refs are
self-closing components rather than block or container components).
Currently, Bluefish does not maintain backwards references (i.e., from
nodes to the Refs pointing to them) as this information is not required
for resolving references or laying out nodes; however, as shown in
Sect. 6, this information can be recovered at runtime. Fig. 4 depicts the
relational scenegraph for the final Bluefish specification in Fig. 3.
4.2
Computing Layout via Local Propagation
Bluefish uses local propagation [64] to layout the relational scenegraph.
Local propagation has a storied history in UI toolkits [11,47,57,58,72]
and is straightforward to implement in reactive dataflow runtimes. Each
node in the scenegraph has an associated layout algorithm, and lay-
out commences at the root of the scenegraph. When a node’s layout
algorithm is evaluated, it invokes the algorithms of its children by spec-
ifying a preferred width and height for each child. Once the children
are laid out, they return their actual measured sizes and positions to the
parent — which may be undefined. After this step, the parent can then
set any undefined attributes based on information it has received from
all children. For example, consider a parent Align node set to align
children by their left coordinate. This node would request its children
measure themselves with respect to a given size; once the children
return, Align checks for a defined x-coordinate from any child, and
propagates this value to other children with undefined x-positions.
Our approach is a generalization of how user interface toolkits like
SwiftUI and Jetpack Compose compute layout. In particular, we lift
their restriction on tree-based scenegraphs: as a particular Bluefish
scenegraph node might participate in several perceptual groupings, we
allow a child node to return only partially defined layout information to
its parent such that other perceptual groups can later specify undefined
properties. However, a node may only set properties that are undefined
on its children — that is, a parent node is not allowed to mutate the
properties of its children. This restriction preserves declarative specifi-
cation of layout: once a perceptual group’s layout has been computed,
its relationships cannot be destroyed by another group.
Our choice of local propagation stands in contrast to the global
solvers favored by other visualization systems. For instance, Set-
CoLa [26] compiles to WebCoLa, a constraint-based layout engine that
uses a mixture of global techniques like quadratic programming and
force-directed layout; Charticulator [53] and GoTree [38] use sparse lin-
Fig. 5: Bluefish code to position the monarch rectangles at the top of the
Playfair Wheat & Wages chart. We set the x coordinates inside the plot,
and use perceptual groups for their vertical positions. Visualizations
grammars require calculating these coordinates manually.
ear programming solvers; and, diagramming tools like Penrose [81] use
L-BFGS. These tools employ global solvers to support very complex
layout problems, and to solve sets of constraints simultaneously, that
cannot be solved by local propagation. Indeed, we implemented an early
version of Bluefish using the Cassowary linear programming solver [2].
However, in doing so, we identified a series of tradeoffs at odds with
our design goals (Sect. 3.1). First, a global solver increases viscosity for
diagram authors: it can be difficult to localize layout bugs because the
solver reasons about all constraints at once and a node’s layout can, by
design, be a function of a highly non-local set of inputs. Second, global
solvers limit vocabulary correspondence: domain-specific algorithms
(e.g., SmilesDrawer for chemical molecules) rely on custom imperative
code that cannot be easily translated to or integrated with a solver’s
constraint language. In contrast, with Bluefish, layout problems can be
debugged more easily as layout information only flows locally. More-
over, Bluefish is able to integrate any external layout algorithm simply
by instantiating it as a node in the scenegraph.
5
EXAMPLE STATISTICAL & DIAGRAMMATIC GRAPHICS
To evaluate Bluefish’s expressivity, we create a gallery of diverse ex-
amples that span the gamut from statistical charts expressible with the
Grammar of Graphics (GoG) [77], through to diagrammatic graphic
representations. Our example span a range of domains, and several
also showcase Bluefish’s ability to integrate external layout algorithms.
Moreover, in several instances, we show how Bluefish can serve as the
foundation for domain-specific grammars. The supplementary material
contains specifications and rendered graphics for all examples.
5.1
Statistical Graphics
To evaluate Bluefish’s ability to express statistical charts, we recreate
plots that feature mixtures of traditional chart elements (e.g., marks,
scales, axes) and relational information (e.g., annotations, links, etc.).
We begin by implementing a prototype GoG library, called Bluefish
Plot, on top of the core Bluefish primitive elements and perceptual
groups.
Its syntax is based on Observable Plot [14] and Victory
Charts [15] (a React-based charting library). Notably, we replace
the need for an ordinal scale with Row and Col to position discrete
data (e.g., for bar marks
Polio (Fig. 1) We recreate a variant of the visualization used to
critically reflect [61] on the design of Charticulator [53], Data Illustra-
tor [40], and Lyra [59]. In Bluefish, we write a custom GroupBy
perceptual grouping that takes a field to facet the data, and a
position matrix of values to place each group in 2D space. This
operator is noteworthy for two reasons. First, it follows our principle of
creation by composition (Sect. 3.1) by using nested Rows and Cols to
perform layout. Second, it achieves vocabulary correspondence with-
out any special casing — i.e., we achieve the common visualization task
of faceting, and GroupBy produces an element like any other operator.
As a result, GroupBys can be arbitrarily nested akin to Visception [35]
Playfair’s Wheat & Wages (Fig. 5) is largely a standard statistical
graphic, but it contains one unusual feature: an array of labeled
6

arXiv preprint
rectangles lists monarchs, sized by the duration of their reign,
and alternately offset vertically for legibility (Oliver Cromwell
being the sole exception as he ruled as Lord Protector rather than
monarch). Positioning these elements in a GoG-based library (e.g.,
Protovis1 [12] or Vega-Lite2 [62]) requires hardcoding coordinates
and manually calculating offsets. For instance, in Vega-Lite, four
data transformations are used, with two formula calculations:
((!datum.commonwealth && datum.index % 2) ? -
1: 1) * 2 + 95
to
vertically
offset
the
rectangles,
and
+datum.start + (+datum.end - +datum.start)/2
to
horizontally position the labels. In contrast, with Bluefish, we leave the
rectangles’ y-coordinates undefined and, outside the plot, use Aligns
and Cols to set the y-coordinate of the bars and place the labels,
respectively — no hardcoding or coordinate calculations required.
ChartAccent (Fig. 5) We recreate a key explanatory figure from Ren
et al.’s ChartAccent system [52]. In particular, the authors identify a
two-dimensional design space for annotations: the form the annotation
takes (text, shape, highlight, etc.) and its target (data item, coordinate
space, chart element). Bluefish’s perceptual grouping primitives cover
each point along these axes. As Bluefish affords consistent, universal
composition, changing the form of an annotation requires only trivial
modifications to the specification. Moreover, as all part of the chart
are elements, any of them may serve as the target of an annotation —
including other annotations or perceptual groups.
Limitations. Bluefish does not currently represent scales in its
relational scenegraph. As a result, we had to create new scale-aware
marks like ScaledRect and ScaledDot that use scale information
during layout. Future versions of Bluefish may need to make scales a
core primitives but, as with other visualization systems [61], it is an
open question whether this should happen explicitly or implicitly (i.e.,
to what degree should authors be able to specify properties of scales).
5.2
Data-Driven Diagrams
In addition to statistical charts, we demonstrate that Bluefish can be
used to construct data-driven diagrams in a variety of domains.
Python Tutor (Fig. 1) is a visualization of program state that has
been used by tens of millions of people across the world, and has seeded
55 research publications [22,23]. It takes as input a program execution
trace produced by a debugger (e.g., BDB in Python) serialized as JSON,
and constructs the visualization using a mix of jQuery and D3 [13]
The resultant visualizations are deeply nested hierarchies: the stack
is composed of stack frames which are, in turn, composed of lists
of variable-value pairs. Moreover, the visualizations feature many
visual links that cross hierarchy boundaries — for instance, from a
stack frame to an object on the heap, or between consecutive items in
a linked list. To depict these relationships, the original visualization
uses HTML tables to lay out the hierarchy and an additional JavaScript
library, jsPlumb, to draw connections. In contrast, we are able to
express all of these relationships more straightforwardly with Bluefish’s
perceptual grouping operators. As these operators can be consistently
composed, each level of the hierarchy (and relationships between them)
are specified in a similar manner. Moreover, due our principle of
creation by composition, it can be a natural part of the authoring process
to abstract these deeply nested, domain-specific groups as custom tags
(e.g., StackFrame as described in Sect. 3.2). In doing so, these new
domain-specific components can be reused or repurposed for new use
cases — for instance, to create pedagogical diagrams for classroom
use [75].
Pythagorean Theorem (Fig. 1) Bluefish’s primitives help us main-
tain the semantics of the step-by-step construction of Euclidean ge-
ometry proof diagrams favored by both paper sketches and software
packages like GeoGebra [34,56]. For instance, consider Byrne’s col-
orization of Euclid’s proof of the Pythaagorean Theorem. The proof
begins by drawing a right-angled triangle: in Bluefish, we express this
as three Point elements, connected by Link groupings and posi-
1https://mbostock.github.io/protovis/ex/wheat.html
2https://vega.github.io/vega-lite/examples/wheat_
wages.html
tioned via a custom RightAngle grouping. Next, the three sides are
squared: here, one could specify these squares as Rect elements but
it is more semantically-aligned to instead express a custom perceptual
grouping that Squares four points. The rest of the proof follows these
steps with custom Bluefish perceptual groupings to depict Angle,
Intersection, and PerpendicularBisector.
This example also provides a helpful point of comparison between
Bluefish and the Penrose diagramming tool [81]. The Penrose speci-
fication uses a Disjoint operator to disambiguate which square is
drawn (i.e., the square to the “left” or “right” of the line connecting
two points). Such an operation is not expressible in Bluefish for two
reasons: it separates arguments rather than grouping them together, and
it requires a global solver as any one Disjoint requires accounting
for all other instances to compute the ultimate position. Instead, in
Bluefish, we capture this ambiguity via a flip parameter: by default,
the grouping yields a square on the “right”; setting this property to
true yields a square on the “left.” More importantly, however, is the
separation Penrose enforces between specfying the data or semantics of
the diagram, and its visual appearance — a distinction found in HTML
and CSS as well as TeX. In contrast, Bluefish is inspired by modern user
interface toolkits, which opt to colocate structure, content (data), and
styling within individual components. As a result, while Penrose makes
it easy to replace the global style of a diagram (akin to replacing the
stylesheet of a web page), Bluefish enables a more modular approach
where individual components can be reused in new contexts.
5.3
Integrations with External Layout Algorithms
Here, we evaluate how Bluefish’s choice of local propagation layout
facilitates integration with external layout algorithms.
Vega-Label [33] is an efficient algorithm for labeling points that
first rasterizes the mark to be annotated, and then searches for available
nearby space to place labels. As it already uses a bounding box abstrac-
tion to perform this calculation, we are able to adapt this algorithm in
a straightforward manner: we simply changed the outer logic to read
and write to Bluefish scenegraph nodes instead of Vega’s. This change
also allows us to expand the expressive gamut of the layout algorithm:
whereas Vega-Label is limited to only using text marks as labels, our
Bluefish version allows any element to serve as either the label or target
mark. We use this adapted Vega-Label in our ChartAccent example to
automatically position textual labels on dot marks.
SmilesDrawer [51] produces molecule diagrams from textual strings
in the Simplified Molecular-Input Line-Entry System (SMILES) format.
SmilesDrawer creates an internal, semantically-meaningful represen-
tation of the molecule (i.e., identifying which elements correspond
to atoms, bonds, and carbon rings). However, this representation is
not preserved in the output SVG. To construct the Bluefish adapter,
we repurpose this information to create perceptual groups. Moreover,
although rings are not technically required to lay out the final diagram
(atoms and bonds are sufficient), we preserve this grouping information
to facilitate downstream tools (Sect. 6). Fig. 7 illustrates specifying a
chemical diagram in Bluefish via SmilesDrawer.
5.4
Transforming a Single Specification to a Grammar
In Sect. 5.1, we illustrate how Bluefish can serve as the foundation
for a higher-level grammar, Bluefish Plot. However, we instantiated
that grammar in a top-down fashion by following the design of Observ-
able Plot [14] and Victory Charts [15]. Here, we instead show how
a grammar can emerge from repeatedly abstracting the elements and
groupings used in a diagram. Our eventual target will be the GoTree
domain-specific grammar for tree-layout visualizations [38], which is
currently implemented as a standalone grammar and tool.
We begin with a traditional graphic representation of a tree: Circle
elements to depict nodes, and Link perceptual groupings to indicate
parent-child relationships. The specification follows four steps: instan-
tiate a Circle as the root node; recurse through the tree structure
within a Row grouping, to instantiate the various subtrees and compute
the horizontal aspect of layout; construct a Col grouping for each
subtree to perform the vertical aspect of layout; and finally Link each
subtree to the root Circle (these latter two groupings operate over
7

Fig. 6: Starting with a single tree visualization, we can gradually transform it into a small tree grammar, similar to GoTree [38]. Because Bluefish
perceptual groupings are components, we can abstract them into encoding channels with very low viscosity.
Refs). To make this a reusable diagram, we abstract the specification
as a Tree component that takes hierarchical data as an attribute.
Next, we might wish to explore alternate elements for depicting
nodes. We could begin by replacing all instances of Circle with
Rect or Text. However, repeatedly executing this task suggests an
opportunity for abstraction: we could lift the element type to be an
attribute, called node, of the Tree component. In doing so, we have
expanded the expressivity of our Tree component: rather than every
Tree being required to display nodes with the same element, each
Tree can use a different element type. We could similarly abstract out
the remaining parts of the Tree specification: rather than requiring a
vertical layout, we might instead abstract it out as a rootSubTree
attribute; a subTreeSubTree attribute for the horizontal portion of
the layout; and, finally, a link for depicting parent-child relationships.
These attributes map to GoTree’s four encoding channels [38], and
our process of repeated abstraction follows the design of Wongsupha-
sawat’s Encodable [78] which suggests that components should be
parameterized not only by data (as our initial Tree component) but
also by an encoding specification. For clarity, we align the signature
of our Tree component more closely to Encodable by nesting the four
abstracted attributes inside encoding attributes.
5.5
Limitations
Bluefish is not able to express two categories of graphic representations:
infographics and scientific illustrations. Infographics typically rely on
bespoke manual layouts; as Bluefish’s perceptual groupings and local
propagation instantiate an automatic layout strategy, the system is a
foot fit for such graphics. Scientific illustrations, on the other hand,
make heavy use of drawings. Although drawings do take advantage of
perceptual grouping, they often aim to be naturalistic. Thus, perceptual
groups are often an emergent property of scientific illustration, rather
than being imposed explicitly and economically.
6
SEMANTICALLY ACCESSIBLE SCREEN READER GRAPHICS
Surfacing relational information is a central challenge to making graph-
ics accessible to assistive technology such as screen readers [82]. This
relational structure conveys the semantics of the graphic domain, such
as part-to-whole relationships and connections between elements but
is rarely reflected in the Document Object Model (DOM) — an issue
exacerbated by the fact that these relational structures are often only
implicitly encoded in the underlying specifications (e.g., those written
in GoG-based libraries) as we discuss in Sect. 3.3.2. In contrast, Blue-
fish’s perceptual groupings and Ref components explicitly express
relations, and these structures are preserved in the relational scenegraph
and output rendering. In this section, we build a prototype screen reader
tool to demonstrate how the relational scenegraph can be traversed in
manner aligned with the graphic domain’s semantics. Our prototype,
called Bolli, is inspired by Olli [9], an open source library that converts
statistical visualizations into hierarchical keyboard-navigable structures
following the design space proposed by Zong, Lee, Lundgard et al. [83].
Bolli begins by traversing the SVG output produced by Bluefish to
recover the relational scenegraph. All elements are rendered within a
containing <g> tag to reflect hierarchy. To express adjacency, Blue-
fish attaches a unique ID to every element, and Ref components are
rendered as empty <g> tags with data-to metadata pointing to an-
other ID; for example, <g id=":r3h9:" class="ref" data-
to=":r2v:"></g>. Unlike Bluefish’s compound graph, where
Refs are unidirectional, Bolli constructs bidirectional links to allow
users to jump back-and-forth along adjacencies.
Once the relational scenegraph has been recovered, Bolli constructs
the screen reader navigable structure by traversing the scenegraph’s
hierarchy relation. <a> (anchor) are used to hyperlink pairs of nodes
that have an adjacency relationship, and textual descriptions are drawn
from aria-labels defined in the backing Bluefish specification. A
user interacts with a Bolli structure like an Olli structure: pressing the
up and down arrow keys moves up and down the hierarchy, while left
and right arrow keys move between siblings at the same level. When a
user encounters a hyperlink, they can press the Enter key to follow
the link and jump to another part of the structure.
Bolli and ChartAccent. We first apply Bolli to our recreated Char-
tAccent example, because is it a heavily annotated statistical graphic.
In the original Olli, each annotation is surfaced as an individual branch
off the root node of the structure, siloed off from other annotations as
well as the visual encodings [83]. As a result, users have no way to
move between annotations or visual encodings without first ascending
to a common ancestor — a potentially cumbersome operation if users
are deep within a particular branch. Moreover, ChartAccent features an-
notations of annotations, and such higher-order annotations do not have
a clear location in either the Olli tree or the backing design space [83].
In contrast, Bolli allows for more nimble navigation of this richly rela-
tional graphic: users can move between annotations and data values by
following hyperlinks, in addition to traditional vertical and horizontal
navigation of the hierarchy. Moreover, as Bolli constructs the screen
reader structure simply by traversing the relational scenegraph, it is
able to account for higher-order annotations without any special casing.
This approach, however, does limit Bolli from building domain-specific
traversal structures (e.g., special branches for the x-axis, y-axis, or grid
like Olli) — we imagine future iterations of the Bluefish Plot gram-
mar might model these as perceptual groupings as well, which would
provide Bolli the necessary relational structure.
Bolli and Chemical Diagrams. Fig. 7 presents an abbreviated
Bluefish specification, relational scenegraph, and Bolli traversal out-
put for an annotated Aspirin molecule.
This structure contains a
group of atoms, a group of bonds, and a group of rings. With the
default output produced by SmilesDrawer, a screen reader can only
focus and narrate the textual SVG elements — an issue for molecules
that do not produce any textual output such as a standalone benzene
ring. Although SmilesDrawer embeds the SMILES notation (e.g.,
CC(OC1=C(C(=O)O)C=CC=C1)=O for Aspirin) as a data attribute
in the SVG output, this attribute is not ARIA (Accessible Rich Internet
Applications) compatible. As a result, screen readers ignore it alto-
gether. However, even if this notation were to be surfaced correctly,
it would only allow for a single start-to-end narration of the chemi-
cal structure, rather than the richer traversals a sighted reader could
perform over the graphical representation.
By contrast, Bolli preserves the hierarchy of rings, bonds, and atoms
in the original diagram. Additionally, the Bolli structure affords multi-
ple traversal orders. For example, the user can choose to traverse all
8

arXiv preprint
Fig. 7: Left-to-right: An annotated Asprin molecule produced with Bluefish and its screen-reader accessible traversal structure, the Bluefish spec
used to generate the diagram, and the compiled relational scenegraph. Our prototype provides a keyboard-navigable representation of the Bluefish
scenegraph that allows users to move up and down the hierarchy, left and right to siblings, and back and forth along adjacency hyperlinks.
bonds by entering the bond group, or they may enter a particular bond
and follow adjacency links to traverse neighboring atoms and rings,
walking incrementally through the entire molecular structure. The Bolli
structure is similar to the one proposed by Sorge et al. for accessible
chemical diagrams [63] — a reflection of how the Bluefish relational
scenegraph preserves domain semantics. Sorge et al. compute blocks,
like carbon rings and functional groups of atoms, and arrange these
groups in a tree-like structure that is navigable similar to Olli [9]. Their
labels for atoms include information about relationships — for example,
“Carbon atom shared with Benzene ring, single bonded to oxygen.” This
information is reflected similarly in the Bolli output of children links
of atoms (see Fig. 7). As Bolli is a generic tool and only relies on
the information provided by SmilesDrawer, it cannot express the same
level of fidelity as Sorge et al.’s work. However, as with ChartAccent,
this gap can be addressed via a special adapter for chemical diagrams
or by improving the output of the molecule perceptual grouping.
7
DISCUSSION AND FUTURE WORK
Interactive and Animated Graphic Representations. In this paper,
we have explored formalisms of perceptual groups in static graphics,
and an immediate next step might consider how our perceptual groups
relate to or inform interaction and animation grammars.
First, there are temporal analogs to perceptual groups. For example,
manifesting similar attribute temporally is akin to the principle of com-
mon fate [74]. Similarly, we could think of Bluefish’s Distribute
as distributing elements along a time axis to stagger movements in
time, and a temporal Align as unifying the start or end of multiple
animations. In fact, these temporal analogs are quite similar to Gem-
ini’s concat and sync operations, respectively [31]. Animations
may also be staged or nested, conveying information similar to common
region, as in Canis/CAST [19,20]. Or an animation may follow a path
between two elements to represent a temporal link between them.
There are analogs in interaction as well. Perceptual groups appear
to manifest in interactions as on-demand groupings. For example,
brushing can be thought of as on-demand common region. Just as
common regions can be nested, so too can brushes [16]. Selections that
drive changes in color signify the group of deselected elements using
similar attribute (although one could also argue this is an example of
figure-ground separation). Moreover, projected selections [62] may
be signified by a user’s intent to select data by similar attribute —
reflecting the underlying relationship between the data points.
Inspired by Animated Vega-Lite [84], which proposed a unifying
framework for animation and interaction abstractions, we believe a
productive line of future work could similarly examine whether percep-
tual groupings across these two modalities and the static groupings we
covered in this paper could be unified.
Empirical Studies of Effectiveness. Visualization grammars that
encode perceptual groupings suggest new avenues for visualization
effectiveness research. This body of work has primarily focused on the
role of retinal variables in understanding graphics — a focus shaped
by the work of Bertin [4] and Cleveland & McGill’s perceptual stud-
ies [18]. While recent effectiveness research has expanded the set of
visualization tasks explored [30], the focus remains on retinal variables.
Recently, researchers have begun to question the completeness of reti-
nal variables for characterizing chart effectiveness. For instance, as
Bertini, Correll, and Fraconeri write, if we take Cleveland & McGill’s
studies seriously, “[o]ne natural conclusion is that any chart that is
not a dot plot or scatterplot is deficient and should be avoided”. They
conclude that their examples “demonstrate that there is something more
than ranking of visual channels and that reasoning about visualiza-
tion at the level of individual channels can be limited and potentially
misleading” [5].
We suggest that one of the missing pieces is reasoning about the
effectiveness of perceptual groupings. As we have argued in this
paper, perceptual groupings convey important semantic information
about graphics, and therefore play a significant role in how people
interpret them. Moreover, some groupings like common region and
element connectedness are stronger than positional encodings [74] —
a signal that analyses of effectiveness might be incomplete without
studying these grouping principles. This role of perceptual groupings
has been explored by various prominent cognitive scientists, some of
whom develop relational structures similar to Bluefish’s own relational
scenegraph [36, 48, 50]. Bluefish’s formalism of perceptual groups
suggests a way to transfer these insights to analyses of data-driven
graphic representations, with an opportunity to inform the automatic
generation of effective graphics.
Formalizing Visual Structure and Domain Semantics.
While our standard library of perceptual groupings covers a large
number of use cases, different domains make different choices about
the perceptual groupings they use to convey domain-specific semantic
intent. For example, when developing our Pythagorean Theorem dia-
gram (Fig. 1 and Sect. 5.2), we found ourselves making new perceptual
groupings specific to Euclidean geometry such as line-line intersections
and perpendicular bisectors. These relations are salient encodings for
the specific kinds of data found in Euclidean geometry. Similarly, in
hand-drawn maps for routing directions, specific features of a line con-
vey semantic intent [71] — for instance, a straight line means “go down,”
a curved line means “follow around,” and a line with a sharp corner
can signify a “turn.” The core idea underlying Bluefish is that formal-
izing visual structure in addition to visual variables lowers authoring
viscosity while simultaneously preserving semantic information about
a visualization for later analysis and processing. In light of domains
like Euclidean geometry and maps, and in the spirit of Mackinlay’s
expressiveness principle [43], Tversky’s correspondence principle [70],
9

and Kindlmann and Scheidegger’s algebraic design process [32], we
believe that in order to speak systematically about the mapping between
data and visualization, we ought to formalize salient visual structures.
ACKNOWLEDGMENTS
Thanks to Josh Horowitz for pointing us to modern UI local propaga-
tion layouts. Thanks to Jonathan Zong for invaluable help with the
accessibility case study. Thanks to Tom George for his help on a previ-
ous iteration of the project. This material is based upon work supported
by the National Science Foundation under Grant No. 1745302.
REFERENCES
[1] Swift charts, 2022.
[2] G. J. Badros, A. Borning, and P. J. Stuckey. The cassowary linear arith-
metic constraint solving algorithm. ACM Transactions on Computer-
Human Interaction (TOCHI), 8(4):267–306, 2001.
[3] M. Benedikt and C. Koch. Xpath leashed. ACM Computing Surveys
(CSUR), 41(1):1–54, 2009.
[4] J. Bertin. Semiology of graphics. University of Wisconsin press, 1983.
[5] E. Bertini, M. Correll, and S. Franconeri. Why shouldn’t all charts be
scatter plots? beyond precision-driven visualizations, 2021.
[6] A. Bigelow, S. Drucker, D. Fisher, and M. Meyer. Reflections on how
designers design with data. In Proceedings of the 2014 International
Working Conference on Advanced Visual Interfaces, pp. 17–24, 2014.
[7] A. Bigelow, S. Drucker, D. Fisher, and M. Meyer. Iterating between tools
to create and edit visualizations. IEEE Transactions on Visualization and
Computer Graphics, 23(1):481–490, 2016.
[8] A. F. Blackwell, C. Britton, A. Cox, T. R. Green, C. Gurr, G. Kadoda, M. S.
Kutar, M. Loomes, C. L. Nehaniv, M. Petre, et al. Cognitive dimensions of
notations: Design tools for cognitive technology. In Cognitive Technology:
Instruments of Mind: 4th International Conference, CT 2001 Coventry, UK,
August 6–9, 2001 Proceedings, pp. 325–341. Springer Berlin Heidelberg,
2001.
[9] M. Blanco, J. Zong, and A. Satyanarayan. Olli: An extensible visualization
library for screen reader accessibility.
[10] S. Boag, D. Chamberlin, M. F. Fern´andez, D. Florescu, J. Robie, J. Sim´eon,
and M. Stefanescu. Xquery 1.0: An xml query language. 2002.
[11] A. Borning, R. Anderson, and B. Freeman-Benson. Indigo: A local
propagation algorithm for inequality constraints. In Proceedings of the
9th annual ACM symposium on User interface software and technology,
pp. 129–136, 1996.
[12] M. Bostock and J. Heer. Protovis: A graphical toolkit for visualization.
IEEE transactions on visualization and computer graphics, 15(6):1121–
1128, 2009.
[13] M. Bostock, V. Ogievetsky, and J. Heer. D3 data-driven documents. IEEE
transactions on visualization and computer graphics, 17(12):2301–2309,
2011.
[14] M. Bostock and P. Rivi`ere. Observable plot. https://github.com/
observablehq/plot, 2020.
[15] boygirl.
Victory.
https://github.com/FormidableLabs/
victory, 2015.
[16] H. Chen. Compound brushing [dynamic data visualization]. In IEEE
Symposium on Information Visualization 2003 (IEEE Cat. No.03TH8714),
pp. 181–188, 2003. doi: 10.1109/INFVIS.2003.1249024
[17] J. Clark, S. DeRose, et al. Xml path language (xpath), 1999.
[18] W. S. Cleveland and R. McGill. Graphical perception: Theory, experimen-
tation, and application to the development of graphical methods. Journal
of the American statistical association, 79(387):531–554, 1984.
[19] T. Ge, B. Lee, and Y. Wang. Cast: Authoring data-driven chart anima-
tions. In Proceedings of the 2021 CHI Conference on Human Factors in
Computing Systems, pp. 1–15, 2021.
[20] T. Ge, Y. Zhao, B. Lee, D. Ren, B. Chen, and Y. Wang. Canis: A high-level
language for data-driven chart animations. In Computer Graphics Forum,
vol. 39, pp. 607–617. Wiley Online Library, 2020.
[21] P. Granstr¨om. Diagrammar: Simply make interactive diagrams.
[22] P. Guo. Ten million users and ten years later: Python tutor’s design guide-
lines for building scalable and sustainable research software in academia.
In The 34th Annual ACM Symposium on User Interface Software and
Technology, pp. 1235–1251, 2021.
[23] P. J. Guo. Online python tutor: embeddable web-based program visualiza-
tion for cs education. In Proceeding of the 44th ACM technical symposium
on Computer science education, pp. 579–584, 2013.
[24] P. Hanrahan. Vizql: a language for query, analysis and visualization.
In Proceedings of the 2006 ACM SIGMOD international conference on
Management of data, pp. 721–721, 2006.
[25] A. Head, A. Xie, and M. A. Hearst. Math augmentation: How authors
enhance the readability of formulas using novel visual design practices. In
Proceedings of the 2022 CHI Conference on Human Factors in Computing
Systems, pp. 1–18, 2022.
[26] J. Hoffswell, A. Borning, and J. Heer. Setcola: High-level constraints for
graph layout. In Computer Graphics Forum, vol. 37, pp. 537–548. Wiley
Online Library, 2018.
[27] D. Holten. Hierarchical edge bundles: Visualization of adjacency relations
in hierarchical data. IEEE Transactions on visualization and computer
graphics, 12(5):741–748, 2006.
[28] E. L. Hutchins, J. D. Hollan, and D. A. Norman. Direct manipulation
interfaces. Human–computer interaction, 1(4):311–338, 1985.
[29] H. Kim, R. Rossi, F. Du, E. Koh, S. Guo, J. Hullman, and J. Hoffswell. Ci-
cero: A declarative grammar for responsive visualization. In Proceedings
of the 2022 CHI Conference on Human Factors in Computing Systems, pp.
1–15, 2022.
[30] Y. Kim and J. Heer. Assessing effects of task and data distribution on
the effectiveness of visual encodings. Computer Graphics Forum (Proc.
EuroVis), 2018.
[31] Y. Kim and J. Heer. Gemini: A grammar and recommender system
for animated transitions in statistical graphics. IEEE Transactions on
Visualization and Computer Graphics, 27(2):485–494, 2020.
[32] G. Kindlmann and C. Scheidegger. An algebraic process for visualiza-
tion design. IEEE transactions on visualization and computer graphics,
20(12):2181–2190, 2014.
[33] C. Kittivorawong, D. Moritz, K. Wongsuphasawat, and J. Heer. Fast and
flexible overlap detection for chart labeling with occupancy bitmap. In
2020 IEEE Visualization Conference (VIS), pp. 101–105. IEEE, 2020.
[34] U. H. Kortenkamp. Foundations of dynamic geometry. PhD thesis, ETH
Zurich, 1999.
[35] Y. S. Kristiansen and S. Bruckner. Visception: An interactive visual
framework for nested visualization design. Computers & Graphics, 92:13–
27, 2020.
[36] J. H. Larkin and H. A. Simon. Why a diagram is (sometimes) worth ten
thousand words. Cognitive science, 11(1):65–100, 1987.
[37] A. Lex, N. Gehlenborg, H. Strobelt, R. Vuillemot, and H. Pfister. Upset:
Visualization of intersecting sets. IEEE Transactions on Visualization and
Computer Graphics (InfoVis), 20(12):1983–1992, 2014. doi: 10.1109/
TVCG.2014.2346248
[38] G. Li, M. Tian, Q. Xu, M. J. McGuffin, and X. Yuan. Gotree: A grammar
of tree visualizations. In Proceedings of the 2020 CHI Conference on
Human Factors in Computing Systems, pp. 1–13, 2020.
[39] Z. Liu, C. Chen, F. Morales, and Y. Zhao. Atlas: Grammar-based pro-
cedural generation of data visualizations. In 2021 IEEE Visualization
Conference (VIS), pp. 171–175. IEEE, 2021.
[40] Z. Liu, J. Thompson, A. Wilson, M. Dontcheva, J. Delorey, S. Grigg,
B. Kerr, and J. Stasko. Data illustrator: Augmenting vector design tools
with lazy data binding for expressive visualization authoring. In Pro-
ceedings of the 2018 CHI Conference on Human Factors in Computing
Systems, pp. 1–13, 2018.
[41] S. LYi, Q. Wang, F. Lekschas, and N. Gehlenborg. Gosling: A grammar-
based toolkit for scalable and interactive genomics data visualization. IEEE
Transactions on Visualization and Computer Graphics, 28(1):140–150,
2021.
[42] D. Ma’ayan, W. Ni, K. Ye, C. Kulkarni, and J. Sunshine. How domain
experts create conceptual diagrams and implications for tool design. In
Proceedings of the 2020 CHI Conference on Human Factors in Computing
Systems, pp. 1–14, 2020.
[43] J. Mackinlay. Automating the design of graphical presentations of rela-
tional information. Acm Transactions On Graphics (Tog), 5(2):110–141,
1986.
[44] A. M. McNutt. No grammar to rule them all: A survey of json-style
dsls for visualization. IEEE Transactions on Visualization and Computer
Graphics, 1912.
[45] A. M. McNutt and R. Chugh. Integrated visualization editing via parame-
terized declarative templates. In Proceedings of the 2021 CHI Conference
on Human Factors in Computing Systems, pp. 1–14, 2021.
[46] T. Munzner. Visualization analysis and design. CRC press, 2014.
[47] B. A. Myers. Graphical techniques in a spreadsheet for specifying user
interfaces. In Proceedings of the SIGCHI Conference on Human Factors
10

arXiv preprint
in Computing Systems, pp. 243–249, 1991.
[48] D. Norman. Things that make us smart: Defending human attributes in
the age of the machine. Diversion Books, 2014.
[49] D. Park, S. M. Drucker, R. Fernandez, and N. Elmqvist. Atom: A grammar
for unit visualizations. IEEE transactions on visualization and computer
graphics, 24(12):3032–3043, 2017.
[50] S. Pinker. A theory of graph comprehension. Artificial intelligence and
the future of testing, 73:126, 1990.
[51] D. Probst and J.-L. Reymond. Smilesdrawer: parsing and drawing smiles-
encoded molecular structures using client-side javascript. Journal of
chemical information and modeling, 58(1):1–7, 2018.
[52] D. Ren, M. Brehmer, B. Lee, T. H¨ollerer, and E. K. Choe. Chartaccent:
Annotation for data-driven storytelling. In 2017 IEEE Pacific Visualization
Symposium (PacificVis), pp. 230–239. Ieee, 2017.
[53] D. Ren, B. Lee, and M. Brehmer. Charticulator: Interactive construction of
bespoke chart layouts. IEEE transactions on visualization and computer
graphics, 25(1):789–799, 2018.
[54] C. Richards. The fundamental design variables of diagramming. Diagram-
matic representation and reasoning, pp. 85–102, 2002.
[55] G.
Sanderson.
Manim.
https://github.com/
ManimCommunity/manim, 2018.
[56] C. Sangwin. A brief review of geogebra: dynamic mathematics. MSor
Connections, 7(2):36, 2007.
[57] M. Sannella. Skyblue: A multi-way local propagation constraint solver
for user interface construction. In Proceedings of the 7th annual ACM
symposium on User interface software and technology, pp. 137–146, 1994.
[58] M. Sannella, J. Maloney, B. Freeman-Benson, and A. Borning. Multi-
way versus one-way constraints in user interfaces: Experience with the
deltablue algorithm. Software: Practice and Experience, 23(5):529–566,
1993.
[59] A. Satyanarayan and J. Heer. Lyra: An interactive visualization design
environment. In Computer graphics forum, vol. 33, pp. 351–360. Wiley
Online Library, 2014.
[60] A. Satyanarayan, B. Lee, D. Ren, J. Heer, J. Stasko, J. Thompson,
M. Brehmer, and Z. Liu. Critical reflections on visualization author-
ing systems. IEEE transactions on visualization and computer graphics,
26(1):461–471, 2019.
[61] A. Satyanarayan, B. Lee, D. Ren, J. Heer, J. Stasko, J. Thompson,
M. Brehmer, and Z. Liu. Critical reflections on visualization author-
ing systems. IEEE transactions on visualization and computer graphics,
26(1):461–471, 2019.
[62] A. Satyanarayan, D. Moritz, K. Wongsuphasawat, and J. Heer. Vega-lite:
A grammar of interactive graphics. IEEE transactions on visualization
and computer graphics, 23(1):341–350, 2016.
[63] V. Sorge, M. Lee, and S. Wilkinson. End-to-end solution for accessible
chemical diagrams. In Proceedings of the 12th International Web for All
Conference, pp. 1–10, 2015.
[64] G. L. Steele Jr.
The definition and implementation of a computer
programming language based on constraints. Technical report, MAS-
SACHUSETTS INST OF TECH CAMBRIDGE ARTIFICIAL INTELLI-
GENCE LAB, 1980.
[65] C. Stolte, D. Tang, and P. Hanrahan. Polaris: a system for query, analysis,
and visualization of multidimensional databases. Communications of the
ACM, 51(11):75–84, 2008.
[66] K. Sugiyama. Graph drawing and applications for software and knowledge
engineers, vol. 11. World Scientific, 2002.
[67] M. Sun, A. Namburi, D. Koop, J. Zhao, T. Li, and H. Chung. Towards sys-
tematic design considerations for visualizing cross-view data relationships.
IEEE Transactions on Visualization and Computer Graphics, 28(12):4741–
4756, 2021.
[68] K. Sveidqvist and S. Vinod.
Mermaid.
https://github.com/
mermaid-js/mermaid, 2014.
[69] B. Tversky. Spatial schemas in depictions. In Spatial schemas and abstract
thought, vol. 79, p. 111, 2001.
[70] B. Tversky. Mind in motion: How action shapes thought. Hachette UK,
2019.
[71] B. Tversky, J. Zacks, P. Lee, and J. Heiser. Lines, blobs, crosses and
arrows: Diagrammatic communication with schematic figures. In Theory
and Application of Diagrams: First International Conference, Diagrams
2000 Edinburgh, Scotland, UK, September 1–3, 2000 Proceedings 1, pp.
221–230. Springer, 2000.
[72] B. T. Vander Zanden, R. Halterman, B. A. Myers, R. McDaniel, R. Miller,
P. Szekely, D. A. Giuse, and D. Kosbie. Lessons learned about one-
way, dataflow constraints in the garnet and amulet graphical toolkits.
ACM Transactions on Programming Languages and Systems (TOPLAS),
23(6):776–796, 2001.
[73] J. von Engelhardt. The language of graphics: A framework for the analysis
of syntax and meaning in maps, charts and diagrams. Yuri Engelhardt,
2002.
[74] J. Wagemans, J. H. Elder, M. Kubovy, S. E. Palmer, M. A. Peterson,
M. Singh, and R. von der Heydt. A century of Gestalt psychology in
visual perception: I. Perceptual grouping and figure-ground organization.
Psychol Bull, 138(6):1172–1217, Nov 2012.
[75] D. Whatley, M. Goldman, and R. C. Miller. Snapdown: A text-based snap-
shot diagram language for programming education. In 2021 IEEE Sympo-
sium on Visual Languages and Human-Centric Computing (VL/HCC), pp.
1–9. IEEE, 2021.
[76] H. Wickham. A layered grammar of graphics. Journal of Computational
and Graphical Statistics, 19(1):3–28, 2010.
[77] L. Wilkinson. The grammar of graphics. In Handbook of computational
statistics, pp. 375–414. Springer, 2012.
[78] K. Wongsuphasawat. Encodable: Configurable grammar for visualization
components. In 2020 IEEE Visualization Conference (VIS), pp. 131–135.
IEEE, 2020.
[79] K. Wongsuphasawat. Navigating the wide world of data visualization
libraries, September 2020.
[80] R. Yates and B. A. Yorgey. Diagrams: a functional edsl for vector graphics.
In Proceedings of the 3rd ACM SIGPLAN International Workshop on
Functional Art, Music, Modelling and Design, pp. 4–5, 2015.
[81] K. Ye, W. Ni, M. Krieger, D. Ma’ayan, J. Wise, J. Aldrich, J. Sunshine,
and K. Crane. Penrose: from mathematical notation to beautiful diagrams.
ACM Transactions on Graphics (TOG), 39(4):144–1, 2020.
[82] B. Young. Aria data visualisation module · issue #991 · w3c/aria, Aug
2020.
[83] J. Zong, C. Lee, A. Lundgard, J. Jang, D. Hajas, and A. Satyanarayan. Rich
Screen Reader Experiences for Accessible Data Visualization. Computer
Graphics Forum (Proc. EuroVis), 2022.
[84] J. Zong, J. Pollock, D. Wootton, and A. Satyanarayan. Animated vega-
lite: Unifying animation with a grammar of interactive graphics. IEEE
Transactions on Visualization and Computer Graphics, 29(1):149–159,
2022.
11

