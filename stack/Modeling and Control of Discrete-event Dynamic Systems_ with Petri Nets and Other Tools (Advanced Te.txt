
Advanced Textbooks in Control and Signal Processing 

 
Series Editor 
 
Professor Michael J. Grimble, Professor of Industrial Systems and Director 
Professor Michael A. Johnson, Professor Emeritus of Control Systems and Deputy Director 
 
Industrial Control Centre, Department of Electronic and Electrical Engineering, 
University of Strathclyde, Graham Hills Building, 50 George Street, Glasgow G1 1QE, UK 
 
Other titles published in this series: 
 
Genetic Algorithms 
K.F. Man, K.S. Tang and S. Kwong 
 
Neural Networks for Modelling and Control of Dynamic Systems 
M. Nørgaard, O. Ravn, L.K. Hansen and N.K. Poulsen 
 
Fault Detection and Diagnosis in Industrial Systems 
L.H. Chiang, E.L. Russell and R.D. Braatz 
 
Soft Computing  
L. Fortuna, G. Rizzotto, M. Lavorgna, G. Nunnari, M.G. Xibilia and R. Caponetto 
 
Statistical Signal Processing  
T. Chonavel 
 
Discrete-time Stochastic Processes (2nd Edition) 
T. Söderström 
 
Parallel Computing for Real-time Signal Processing and Control 
M.O. Tokhi, M.A. Hossain and M.H. Shaheed 
 
Multivariable Control Systems 
P. Albertos and A. Sala 
 
Control Systems with Input and Output Constraints 
A.H. Glattfelder and W. Schaufelberger 
 
Analysis and Control of Non-linear Process Systems 
K. Hangos, J. Bokor and G. Szederkényi 
 
Model Predictive Control (2nd Edition) 
E.F. Camacho and C. Bordons 
 
Digital Self-tuning Controllers 
V. Bobál, J. Böhm, J. Fessl and J. Macháček 
 
Principles of Adaptive Filters and Self-learning Systems 
A. Zaknich 
 
Control of Robot Manipulators in Joint Space 
R. Kelly, V. Santibáñez and A. Loría 
 
Robust Control Design with MATLAB® 
D.-W. Gu, P.H. Petkov and M.M. Konstantinov 
 
Control of Dead-time Processes 
J.E. Normey-Rico and E.F. Camacho 
 
Robotics 
B. Siciliano and L. Sciavicco 
Publication due October 2007 

B. Hrúz and M.C. Zhou 
Modeling and Control 
of Discrete-event 
Dynamic Systems 
with Petri Nets and Other Tool 
123

Branislav Hrúz, PhD 
Department of Automatic Control Systems 
Faculty of Electrical Engineering  
and Information Technology 
Slovak University of Technology 
812 19 Bratislava 1 
Slovak Republic 
MengChu Zhou, PhD 
Department of Electrical 
and Computer Engineering 
New Jersey Institute of Technology 
Newark, NJ 07102 
USA 
 
British Library Cataloguing in Publication Data 
Hruz, B. (Branislav)                                            
   Modeling and control of discrete-event dynamical systems :    
   with Petri nets and other tools. - (Advanced textbooks in     
   control and signal processing)                                
   1. Discrete-time systems - Mathematical models 2. Automatic   
   control - Mathematical models 3. Petri nets                   
   I. Title II. Zhou, MengChu                                    
   003.8                                                         
ISBN-13: 9781846288722    
 
Library of Congress Control Number: 2007929991 
 
Advanced Textbooks in Control and Signal Processing ISSN 1439-2232 
 
ISBN-13: 978-1-84628-872-2  e-ISBN-13: 978-1-84628-877-7 
 
Printed on acid-free paper 
 
© Springer-Verlag London Limited 2007 
MATLAB® is a registered trademark of The MathWorks, Inc., 3 Apple Hill Drive, Natick, MA 01760-
2098, USA. http://www.mathworks.com 
Apart from any fair dealing for the purposes of research or private study, or criticism or review, as
permitted under the Copyright, Designs and Patents Act 1988, this publication may only be reprodu-
ced, stored or transmitted, in any form or by any means, with the prior permission in writing of the
publishers, or in the case of reprographic reproduction in accordance with the terms of licences issued
by the Copyright Licensing Agency.  Enquiries concerning reproduction outside those terms should be
sent to the publishers. 
The use of registered names, trademarks, etc. in this publication does not imply, even in the absence of
a specific statement, that such names are exempt from the relevant laws and regulations and therefore
free for general use. 
The publisher makes no representation, express or implied, with regard to the accuracy of the infor-
mation contained in this book and cannot accept any legal responsibility or liability for any errors or 
omissions that may be made. 
 
9 8 7 6 5 4 3 2 1  
 
Springer Science+Business Media 
springer.com 

 
 
To our wives Mira and Fang Chen 
 
 

 
Series Editors’ Foreword 
The topics of control engineering and signal processing continue to flourish and 
develop. In common with general scientific investigation, new ideas, concepts and 
interpretations emerge quite spontaneously and these are then discussed, used, 
discarded or subsumed into the prevailing subject paradigm. Sometimes these 
innovative concepts coalesce into a new sub-discipline within the broad subject 
tapestry of control and signal processing. This preliminary battle between old and 
new usually takes place at conferences, through the Internet and in the journals of 
the discipline. After a little more maturity has been acquired by the new concepts 
then archival publication as a scientific or engineering monograph may occur. 
A new concept in control and signal processing is known to have arrived when 
sufficient material has evolved for the topic to be taught as a specialised tutorial 
workshop or as a course to undergraduate, graduate or industrial engineers. 
Advanced Textbooks in Control and Signal Processing are designed as a vehicle 
for the systematic presentation of course material for both popular and innovative 
topics in the discipline. It is hoped that prospective authors will welcome the 
opportunity to publish a structured and systematic presentation of some of the 
newer emerging control and signal processing technologies in the textbook series. 
In society today, much of the modern technological infrastructure is event 
driven where the system outcome is often dependent on a benign sequence of 
desirable actions taking place. In industry, the action sequence may be highly 
structured and deterministic but, elsewhere in the community, the action sequence 
may be fuzzy or even stochastic, making the constraint of a safe system control 
sequence a much more difficult task. Many of the sequential event-driven systems 
found today, may be modelled as discrete-event dynamic systems (DEDS). The 
characterising features of DEDS are discrete states that capture the status to change 
value at discrete time points. In DEDS, the (logical) conditions that lead to 
individual or sets of events being activated to generate a sequence of changing 
system states is an important part of the system and its mathematical model. This 
viewpoint contrasts with much of the standard control literature which is often 
dominated by the exhaustive treatment of systems described by linear or nonlinear 
ordinary differential equations systems or even, occasionally, spatially-dependent 
partial differential equation systems. 
As the references in this book show, the tools to describe DEDS, analyse their 
performance and generate control algorithms have been under development since 

viii 
Series Editors’ Foreword 
the late 1970s. However, it appears that around 1990 there was a flurry of 
publications as Petri nets and other techniques began to receive serious 
consideration. Now, in 2007, sufficient development has taken place for this course 
textbook on the Modeling and Control of Discrete-event Dynamic Systems to enter 
the Advanced Textbooks in Control and Signal Processing series. Professors 
Branislav Hrúz and MengChu Zhou have had many years of experience of teaching 
courses in the methods of DEDS and we are pleased to welcome their new volume 
into the series. 
This textbook is comprised of three groups of chapters. The first group, 
Chapters 1–5, is concerned with establishing the basis mathematical tools for the 
modelling and control of DEDS. This includes chapters on the application of 
mathematical graph theory, the ideas of formal language concepts and finite 
automata. The concepts and structure of control for DEDS appears in Chapter 5. 
Graphical techniques for DEDS then dominate the second group of chapters, 6–
11. These techniques start with flow diagram methods in Chapter 6. This short 
chapter is followed by four key chapters, 7–10, on Petri nets. These chapters detail 
the basics (Chapter 7), and the properties (Chapter 8) of Petri nets, and then move 
on to Grafcet in Chapter 9 and the timed, colored, fuzzy and adaptive varieties of 
Petri nets in Chapter 10. A brief look at statecharts and their link to Petri nets in 
Chapter 11 closes this second group of chapters. 
The final grouping of three chapters looks at what might be termed DEDS 
tasks. Chapter 12 has a strong implementation focus with a useful section on ladder 
logic diagrams and comments on how Petri nets might contribute to this 
widespread programmable-logic-controller programming paradigm. The problems 
of supervisory control and job scheduling are considered in the last two chapters of 
this final group. 
The practitioner will be interested to see the applicability of the DEDS 
techniques illustrated by the wide range of systems used as examples in the 
textbook. There is a large group of examples based on the problems of flexible 
manufacturing systems (FMS). These are based on different cell structures using 
components like ‘pick and place’ robots, milling units, conveyor belt systems, 
storage units or bins, and workpiece sorting units. Fortunately, all these 
components are easily understood by the non-manufacturing specialist and so 
provide good accessible introductory examples. Manufacturing industry 
transportation systems based on automatic guided vehicles (AGVs) are also used in 
examples. Real system complexity is soon experienced by the reader when FMS 
and AGV systems are interlinked. 
Other examples used in the textbook include crane-based loading systems, 
tank-filling systems, distributed computer systems, motor- and motion-control 
systems. The discussion of a two-tank-filling system (given in Chapter 8) provides 
an alternative view of a control problem often treated in classical control 
engineering textbooks. The problem of modelling the operation of a pedestrian 
crossing and the human resources problem of when three participants will make it 
to a meeting give a fascinating illustration of the potential of DEDS techniques to 
model and analyse problems in fields far removed from manufacturing. 
Industrial Control Centre 
M.J. Grimble 
Glasgow, Scotland, U.K. 
M.A. Johnson 
December 2006 
 

 
Preface 
For whatsoever doth make manifest is light 
Ephesians 5.13 
This book presents results of research achieved in friendly collaboration across 
borders and moreover between continents and emphasizes a belief in engineering 
science being for the benefit of mankind the world over. This aspect of the book’s 
ethos is epitomized by the authors’ profiles, one being from Central Europe and 
one from the USA.  
Motivation 
A number of years ago research work on a woodworking process control raised our 
interest in discrete event dynamic systems (DEDS). We remembered that the 
process was an automatic production of laminar parquetry precasts. Work-piece 
preparation and composition included many discrete events and concurrent 
processes. Since then, we have started a systematic study of DEDS. Each school 
year since 1993, we have given lecture courses on DEDS within the Master 
program at the Department of Automatic Control Systems, Faculty of Electrical 
Engineering and Information Technology of the Slovak University of Technology 
in Bratislava, and undergraduate and graduate programs in the Department of 
Electrical and Computer Engineering, New Jersey Institute of Technology, Newark, 
NJ 07102, USA, respectively.  
The presented textbook contains most of the lecture material gradually 
elaborated in the courses of the past ten years. Our teaching activities have been 
accompanied by significant research and student projects in the field of DEDS, 
mainly on various topics concerning Petri nets used for modeling, analysis, 
performance evaluation, discrete-event control, supervisory control, and job 
scheduling of manufacturing processes, automatic guided vehicles in flexible 
manufacturing, assembly/disassembly processes, computer networking, and 
workflow management. Other discrete event models and their applications under 
our study include statecharts, ladder logic diagrams, finite state machines, digraphs, 
and Grafcet. 
While performing the teaching and research activities, we have felt a strong 
need for a textbook that systematically and comprehensively introduces the 

x 
Preface 
mathematical background and various modeling tools for the purpose of DEDS 
analysis, performance evaluation, control, and scheduling. Thus students and 
researchers of various background can easily learn and grasp the essence of DEDS 
that is of growing importance. Their demand and the needs arising from our 
teaching, research and development activities motivate us to write this present 
book. 
Contents  
The mentioned lectures and this book particularly concentrate on Petri nets and 
their use in the modelling and control design for DEDS. They serve as a basis for 
extending to other tools and approaches such as Grafcet, statecharts, supervisory 
control theory and job scheduling. The textbook contains the necessary 
mathematics and computer science material. It includes discrete mathematics, 
formal languages, and finite automata. They are essential for non-computer 
science/engineering students to master the subjects of DEDS. Such material helps 
one describe and understand the nature of DEDS as well as the methods to describe 
and govern them. Standard and reactive flow diagrams are then introduced. The 
substance and properties of Petri nets and other tools useful for the modeling of 
DEDS have been built up systematically. Advanced Petri net tools include timed, 
stochastic, colored, fuzzy, and adaptive Petri nets. Petri net-related tools include 
Grafcet (also terms Sequential Function Charts), and statecharts. Various aspects 
concerning control design methods are followed consistently throughout the 
textbook. Theoretical aspects are illustrated and explained using numerous 
problem-solving examples dealing with various computer-integrated systems. We 
summarize the contents of all fourteen chapters as follows.  
Chapter 1 introduces the concept of systems and states, continuous, discrete-
time, and discrete-event systems, the definition and properties of DEDS, and some 
system examples. Basic transition systems are described in detail as the most 
fundamental representation of DEDS.  
Chapter 2 presents directed graphs, subgraphs, and directed paths and circuits 
in them. Examples are given to illustrate these concepts. 
Chapter 3 introduces the concept of formal languages and their classification. 
They form the basis for many theoretical developments in both computer science 
and supervisory control theory of DEDS.   
Chapter 4 discusses DEDS control system including specifications and control 
functions.  
Chapter 5 introduces the concept of finite automata or state machines. It 
discusses through examples how they can be used to describe a real system and 
how control specification can be described with their help. Non-deterministic finite 
automata are also presented.  
Chapter 6 discusses the standard flow diagrams used in software development 
and reactive flow diagrams for DEDS.  
Chapter 7 introduces the idea of Petri nets, their basic definition, matrix 
representation, and various classes. It also discusses how they can be interpreted 
for control purposes.  

 
Preface 
xi 
Chapter 8 presents the important properties of Petri nets and their implications 
in modelled systems. Analysis methods based on reachability trees are elaborated. 
Examples are given. The structural properties of Petri nets are also discussed.  
Chapter 9 presents Grafcet (also named sequential function chart) – its presence 
in industry is significant, especially among automatic control and automation 
equipment companies. Its comparison with Petri nets is given.  
Chapter 10 introduces the advanced concepts resulting from the study of Petri 
nets and industrial needs in exploring their utility. They include deterministic and 
stochastic timed Petri nets for performance evaluation purposes. Colored Petri nets 
are used to specify complex systems with many similar subsystems, components or 
specifications. Fuzzy Petri nets combine fuzzy set theory and Petri nets to describe 
uncertainty embedded in many practical applications. Adaptive Petri nets further 
embed learning capability into Fuzzy Petri nets.  
Chapter 11 presents the idea of statecharts and their applications to complex 
system design.  
Chapter 12 introduces modeling methodology, conflict resolution, ladder logic 
diagrams, and control program design for DEDS.  
Chapter 13 presents the essential concepts of supervisory control theory based 
on automata and Petri nets. Several fundamental approaches are presented.  
Chapter 14 discusses the job scheduling problems and the use of Petri nets for 
such purposes. The solution method based on max-plus algebra is also introduced. 
Aim and Use of this Textbook  
This book aims to introduce to students, engineers and researchers the 
fundamentals of various discrete event modelling tools, as well as applications. 
The discrete mathematics and related background material are included. It is 
suitable for class use and can be easily tailored to meet the different needs from 
senior undergraduate and graduate students. In an introductory course to DEDS for 
engineering students, the following contents are suggested:  
Chapters 1–8, and 11  
For a more advanced course in DEDS and for students with required 
mathematics and entry-level knowledge of DEDS, the following contents should 
be offered:  
Chapters 1, 2, 4, 7–14.  
For computer science and engineering students, such materials as discrete 
mathematics, formal language, and automata can be skipped or only their brief 
review is needed. 
Acknowledgements  
We would like to express our deep gratitude to all who helped us and supported 
our effort in writing this book, especially our wives, children and parents. We 
would acknowledge the professionalism demonstrated by the staff members of 

xii 
Preface 
Springer. We especially thank Mr. Oliver Jackson and Prof. Michael Johnson for 
their great help.  We are grateful to Ms. Angela Böhl and Mr. Torsten Hartmann, 
LE-TeX Jelonek, Schmidt & Voeckler GbR for her careful proofreading and his 
nice cover design of this book, respectively. 
The first author thanks, in particular, Prof. Štefan Kozák, Ph.D., head of the 
Department of Automatic Control Systems, Institute of Robotics and Industrial 
Informatics at Slovak University of Technology and other colleagues from the 
Institute, especially Leo Mrafko, his Ph.D. student and assistant, to Alena 
Kozáková, Ph.D., for her careful reading and correcting the manuscript, Jana 
Flochová, Ph.D., Milan Struhar, Ph.D., as well as colleagues from other 
departments of his faculty Prof. Norbert Frištacký, Ph.D. (in memoriam), and Prof. 
Mikuláš Huba, Ph.D. He would like to thank his friends from abroad, Prof. Dr. 
Antti Niemi from the Control Engineering Laboratory of the Helsinki University of 
Technology, Prof. Dr. Hanns Peter Jörgl from the Institute of the Process and 
Machine Automation of the Vienna University of Technology, and Prof. Zdeněk 
Hanzálek, Ph.D. from the Faculty of Electrical Engineering of the Czech Technical 
University in Prague for their valuable advice, support and numerous inspiring 
scientific discussions.   
The second author thanks his doctoral thesis advisor Dr. Frank DiCesare, Prof.-
Emeritus, and committee members (now friends), Prof. Alan Desrochers, and Prof. 
Arthur Sanderson, Rensselaer Polytechnic Institute, Troy, NY, USA. It is they who 
introduced him to this exciting field and helped advance his professional career. He 
would also like to thank many pioneers in the area of Petri nets including Prof. N. 
Viswanadham, National Singapore University, Prof. T. Murata, University of 
Illinois at Chicago, Prof. K. Lautenbach, University of Koblenz, and Prof. Y. 
Narahari, Indian Institute of Science. He is also grateful for the great professional 
help and friendship of Prof. P.B. Luh, University of Connecticut, Prof. F. Lewis, 
University of Texas at Arlington, Prof. J. Tien, Rensselaer Polytechnic Institute, 
Prof. W. Gruver, Simon Fraser University, and Prof. T.T. Lee, National Chiao-
Tung University. During the past many years, he has enjoyed the happy 
collaboration and friendship with Prof. MuDer Jeng, National Taiwan Ocean 
University, M.P. Fanti, Polytechnic di Baris, Prof. Jiacun Wang, University of 
Monmouth, Prof. Naiqi Wu, Guangdong University of Technology, Prof. Zhiwu Li, 
Xidian University, and Prof. Yushun Fan, Tsinghua University. I owe a great deal 
to many graduate advisees, especially, Dr. K. Venkatesh of AIG, Dr. H. Xiong of 
Alcatel-Lucent, Prof. Ying Tang of Rowan University, Prof. Meimei Gao of Seton 
Hall University, and Dr. Jianqiang Li of NEC. The second author’s close friend 
and colleague, Prof. Fei-Yue Wang, University of Arizona, has been very 
instrumental and helpful in this project and many others. The work is partially 
supported by the China National Science Foundation under Grant 60574066, 
Chinese Academy of Sciences under Grant No. 2F05NO1, New Jersey 
Commission of Science and Technology, and Chang Jiang Scholar Program, 
Ministry of Education, PRC.  
Bratislava, Slovak Republic 
Branislav Hrúz 
Newark, NJ, USA 
MengChu Zhou 
June 2007 

 
Contents 
Notation...............................................................................................................xvii 
1  Basic Description of Discrete-event Dynamic Systems..................................1 
 
1.1 Introduction................................................................................................1 
 
1.2 Discrete Variables and Relations...............................................................4 
 
1.3 Discrete Processes......................................................................................6 
 
1.4 Basic Properties of DEDS and their Specification...................................10 
 
1.5 Basic Transition System ..........................................................................11 
 
1.6 Problems and Exercises ...........................................................................20 
2 Graphs in Modeling DEDS ............................................................................23 
 
2.1 Simple Non-labeled Directed Mathematical Graphs ...............................23 
 
2.2 Labeled Mathematical Graphs.................................................................24 
 
2.3 Subgraphs and Components.....................................................................25  
 
2.4 Directed Paths..........................................................................................27 
 
2.5 Problems and Exercises ...........................................................................29 
3 Formal Languages ..........................................................................................33 
 
3.1 Notion of the Formal Language...............................................................33  
 
3.2 Formal Grammars and Classification of Formal Languages ...................34 
 
3.3 Regular Expressions ................................................................................38 
 
3.4 Problems and Exercises ...........................................................................40 
4 Control of DEDS.............................................................................................41 
 
4.1 State and Control Variables .....................................................................41 
 
4.2 Control System and Control Function .....................................................42 
 
4.3 Problems and Exercises ...........................................................................46 
5 Finite Automata ..............................................................................................49 
 
5.1 Basic Definitions .....................................................................................49 
 
5.2 Description of the System Behavior Using Finite Automata...................52 
 
5.3 Control Specification Using Finite Automata..........................................55 

xiv 
Contents 
 
5.4 Non-deterministic Finite Automata .........................................................60 
 
5.5 Problems and Exercises ...........................................................................60 
6 Reactive Flow Diagrams.................................................................................63 
 
6.1 Standard Flow Diagrams .........................................................................63 
 
6.2 Reactive Flow Diagrams..........................................................................64 
 
6.3 Problems and Exercises ...........................................................................67 
7 Petri Net Models of DEDS..............................................................................69 
 
7.1 Notion of Petri Nets.................................................................................69 
 
7.2 Basic Definitions .....................................................................................76 
 
7.3 Vector and Matrix Representation of Petri Nets......................................80 
 
7.4 Petri Net Classes......................................................................................91 
 
7.5 Petri Nets Interpreted for Control ............................................................95 
 
7.6 Petri Nets with Capacities........................................................................99 
 
7.7 Problems and Exercises .........................................................................102 
8 Properties of Petri Nets ................................................................................107 
 
8.1 Marking Reachability ............................................................................107 
 
8.2 Reachability Graph ................................................................................109 
 
8.3 Boundedness..........................................................................................115 
 
8.4 Coverability ...........................................................................................116 
 
8.5 Coverability Graph ................................................................................118 
 
8.6 Liveness.................................................................................................124 
 
8.7 Reversibility...........................................................................................127 
 
8.8 Persistence and Fairness ........................................................................128 
 
8.9 Conservativeness ...................................................................................129 
 
8.10 P-invariants and T-invariants.................................................................134 
 
8.11 Concurrency and Conflict......................................................................149 
 
8.12 Analysis of Petri Net Properties.............................................................152 
 
8.13 Structural Properties ..............................................................................155 
 
8.14 Problems and Exercises .........................................................................157 
9 Grafcet ...........................................................................................................161 
 
9.1 Basic Grafcet Components ....................................................................161 
 
9.2 Dynamics Modeling with Grafcet..........................................................164 
 
9.3 Comparison of Petri Nets and Grafcet...................................................169 
 
9.4 Problems and Exercises .........................................................................173 
10 Timed and High-level Petri Nets .................................................................177 
 
10.1 From Standard to Higher-level Petri Nets..............................................177 
 
10.2 Deterministic Timed Petri Nets .............................................................178 
 
10.3 Stochastic Timed Petri Nets...................................................................180 
 
10.4 Colored Petri Nets..................................................................................185 
 
10.5 Fuzzy Petri Nets.....................................................................................192 
 
10.6 Adaptive Petri Nets................................................................................196 

 
Contents 
xv 
 
10.8 Problems and Exercises .........................................................................205 
11 Statecharts.....................................................................................................209 
 
11.1 Introduction............................................................................................209 
 
11.2 Basic Statechart Components ................................................................209 
 
11.3 Statechart Application............................................................................213 
 
11.4 Problems and Exercises .........................................................................214 
12 DEDS Modeling, Control and Programming.............................................217 
 
12.1 Modeling Methodology .........................................................................217 
 
12.2 Resolution of Conflicts ..........................................................................225 
 
12.3 Control Programs in DEDS ...................................................................234 
 
12.4 Ladder Logic Diagrams .........................................................................246 
 
12.5 Problems and Exercises .........................................................................256 
13 Supervisory Control .....................................................................................261 
 
13.1 Basic Notion ..........................................................................................261 
 
13.2 System Controllability ...........................................................................262 
 
13.3 Supervisory Control Solution Based on Finite Automata......................269 
 
13.4 Supervisory Control Solution with P-invariants....................................282 
 
13.5 Supervisory Control Solution with Reachability Graph ........................295 
 
13.6 Problems and Exercises .........................................................................301 
14 Job Scheduling ..............................................................................................305 
 
14.1 Problem Formulation.............................................................................305 
 
14.2 Job Scheduling and Petri Nets ...............................................................309 
 
14.3 Job Scheduling Based on the Max-plus Algebra ...................................313 
 
14.4 Problems and Exercises .........................................................................321 
References ...........................................................................................................325 
Index....................................................................................................................333 
 
10.7 Petri Net-based Design Tools ................................................................204 

 
Notation 
iff 
abbreviation for “if and only if” 
⇒
∨
∧
,
,
,
x
 
logical 
operators: 
conjunction, 
disjunction, 
negation, and implication, respectively 
⇔ 
logical implication in both directions 
(
)
n
o
o
o
,...,
,
2
1
 or (
)
n
o −
1
 
ordered n-tuple of n objects 
n
o
o
o
,...,
,
2
1
 
{
}
n
a
a
a
A
,...,
,
2
1
=
 
set of n elements 
n
a
a
a
,...,
,
2
1
 
∅ 
empty set 
A  
the number of elements (cardinality) in set A 
,
,∪
∩
\ 
set intersection, union, and difference 
B
A ⊂
 
set A is a proper subset of B and 
B
A =
 is 
excluded 
B
A ⊆
 
A is a subset of B 
B
A×
 
Cartesian product of sets A and B 
B
A
R
×
⊆
 
binary relation from set A to set B 
B
A
f
→
:
 
function f , which maps elements of set A into set 
B 

xviii Notation 
A
x ∈
 
x belongs to set A 
A
x ∉
 
x is not an element of set A 
N 
set of natural numbers 
{
}
,...
2,1,0
=
N
 
+
N
 
set of positive integers, i.e., 
{ }
0
\
N
N
=
+
 
I 
set of integers 
R 
set of real numbers 
+
R  
set of positive real numbers 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
n
u
u
u
M
2
1
u
 
vector u with entries 
n
u
u
u
,...,
,
2
1
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
≤
n
n
v
v
v
u
u
u
M
M
2
1
2
1
,
,
v
u
v
u
 
iff 
n
k
v
u
k
k
,...,
2,1
 
all
for 
=
≤
 
v
u <
 
iff 
(
) (
)
k
v
u
n
k
v
u
k
k
k
k
 
one
for 
least 
at 
,..,
1
 
all
for 
<
∧
=
≤
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
+
=
nz
z
z
M
2
1
, z
v
u
z
 
sum of vectors 
n
k
v
u
z
k
k
k
,...,
2,1
 
all
for 
,
=
+
=
 
( )
( )
( )
( )⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
t
u
t
u
t
u
t
n
M
2
1
u
 
vector time variable  
P
N
 
set of P
-tuples consisting of P
 natural 
numbers 

 
Notation 
xix 
T
P
N
 
set of transposed P -tuples consisting of P  
integer numbers, i.e., the set of integer number 
P -vectors 
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
nm
n
m
a
a
a
a
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
1
11
A
 
n×m matrix with n rows and m columns 
ni
i
i
a
a
a
a
...
~
2
1
=
 
a sequence (string, formal word) of elements 
ni
i
i
a
a
a
,...,
,
2
1
in this order 
Σ  
the set of events 
*
Σ  
the set of all sequences (strings, formal words) 
created from elements of set Σ and the empty 
sequence ε~  
+
Σ  
set 
*
Σ  without the empty sequence ε~ , i.e., 
ε~
\
*
Σ
=
Σ +
 
α~  
length of the sequence (or state path or event 
path ) α~  given as  the number of elements in 
sequence (or state path or event path) α~  
ε~  
empty string, i.e., the string for which 
0
~ =
ε
 
t
•  ( )
•t
  
set of pre-places (post-places) of the Petri net 
transition t 
p
•
 (
)
•
p
 
set of input (output) transitions of the Petri net 
place p 
[
'
m
m
>
t
 
transition t of a given Petri net is enabled or 
fireable at marking m represented in the vector 
form and its firing results in marking 
'
m  

xx 
Notation 
(
)
0
m
PN
R
 
reachability set of Petri net PN given initial 
marking m0 
⊗
⊕,
 
operations of the max-plus algebra 

1 
Basic Description of Discrete-event Dynamic Systems 
1.1 Introduction 
People observe various phenomena of nature and endeavor to comprehend them. 
The first step in that is a reflection of the phenomena by imagination and 
description. The reflexive process is a process of abstraction. In this process, the 
notion of “system” is of basic importance. 
A system is defined to be a group of objects separated from the universe and 
having mutual relations.  
Different physical entities can constitute system objects. If time is included 
among the system objects, their temporal properties or the system dynamics can be 
considered. The system dynamics is given by the time behavior of the system 
objects. The behavior is called the process. 
A real physical system is represented by an ideal system created by human 
thinking and understanding. Mathematical representations of real systems are the 
most abstract and precise descriptions. Since the very beginning of its existence, 
mankind strives not only to know and to describe natural systems but also to 
govern and control them.  
Control of a system is based on knowledge about the particular system. This 
knowledge is developed via abstraction based on observation of the system. The 
observation is realized by measurements and if possible, by experimentation with 
the system. Two main abstractions are to be distinguished, namely: 
1. The notion of a continuous system and 
2. The notion of a discrete system. 
A natural question arises about the substance of these abstractions. A 
continuous system is specified by a set of continuous variables, a set of continuous 
functions over the respective domains of these variables, and by derivatives of the 
variables and functions. Such a system is called a continuous-variable dynamic 
system (CVDS). One can find a good systematic survey of the CVDS control 
theory in the book by Jörgl (1993). A discrete system is specified by a set of 

2 
Modeling and Control of Discrete-event Dynamic Systems 
discrete variables and relations defined on them. A hybrid system is a combination 
of both.  
Sometimes the relations of system variables are not treated with respect to time. 
Then they describe the static behavior of the studied systems. However, time is 
mostly involved in the analysis and synthesis of systems and dynamic system 
behavior is considered. 
Figure 1.1 illustrates the classification of continuous and discrete systems 
considering dynamic behavior. In order to simplify the illustration, a system with 
one variable is depicted. Figure 1.1.a shows the case when the continuous variable 
( )t
x
 is a continuous function over a continuous time interval. The function domain 
and co-domain are real numbers. A system is continuous if it is defined by 
continuous variables and continuous functions such as the function depicted in 
Figure 1.1.a. A discrete system is given by discrete variables and discrete functions 
or relations as illustrated by Figure 1.1.b. The system in Figure 1.1.b consists of 
one object in the form of one variable that takes on values from the set of real 
numbers in discrete time points.  
 
Figure 1.1. Properties of one-variable system 
Figures 1.1.c and 1.1.d show the mixed/hybrid cases when the system is semi-
continuous.  Usually, a system has more than one object or variable. Then a set of 
variables can be aggregated into one or more vector variables. Note that the case 

 
Basic Description of Discrete-event Dynamic Systems 
3 
depicted in Figure 1.1.b can be understood either as a discrete representation of a 
continuous system or as a representation of the system that is discrete by its nature. 
The role of the semantics or interpretation is obvious. Therefore, the discrete or 
digital representation of continuous systems has to be distinguished from the 
representation of systems that are discrete in their nature and substance. The 
discrete representation of a continuous system is obtained by sampling continuous 
variables at discrete time points.  
Continuity and discreteness of a system is one aspect of the view on system 
properties. Another aspect is that CVDS are time-driven systems. The reason for 
the dynamic development of system states is time. On the other hand, discrete 
systems can be time-driven or event-driven. 
e1 
e3
e1 e2
e2
q1 
q2 
q3 
q4 
t 
States 
 
Figure 1.2. An event-driven system 
Let us compare Figures 1.1 and 1.2. The discrete variable q describes the state 
of the system. There are four states q1, q2, q3, and q4, q1-4 for short, and three events 
e1, e2, and e3, e1-3 for short. Figure 1.2 shows that the state change is event-driven. 
The events occur at discrete time points and the state changes depend on the events 
only. Such systems are called discrete event dynamic systems or DEDS for short 
(Ho 1991; Ho and Cassandras 1983). They are also called discrete event systems 
(Ramadge and Wonham 1987; Zhou and DiCesare 1993; Jafari 1995; Bogdan et al. 
2006). As mentioned earlier, Figure 1.1.b has a double meaning. It can represent 
either time-driven CVDS or event-driven DEDS when the events occur at discrete 
time points and cause the change of system states as depicted in Figure 1.1.b. 
The applied system analysis and synthesis methods depend on the system 
nature. In this textbook we will study systems that are fully discrete in their nature 
and event-driven, i.e., discrete event dynamic systems. Their name expresses their 
specific character. DEDS are characterized by a set of states which the system can 
take, and by the set of events that cause the state changes at discrete time points. 
The events may take place asynchronously as opposed to the synchronous nature in 
a discrete time system. The change of states and occurrence of events are the 
essence of the DEDS dynamic behavior. 
A primary task of the DEDS theory is creating a DEDS model. Without such a 
model it would be impossible to analyze and control DEDS just as it is true in 
classic CDVS control theory. Obviously we are interested in a model that is 

4 
Modeling and Control of Discrete-event Dynamic Systems 
sufficiently general and includes the DEDS dynamics. There are two ways to 
consider the dynamics: 
1. To specify values of the system variables and system relations in defined 
discrete time points; and 
2. To specify time order of the states or events. 
The latter case means that time is not explicitly expressed and only the precedence 
relations for DEDS states and events are given. The order of events can be 
determined by means of their indexing. In other words, it is given which event 
happens before some other events. Such an approach is more abstract and avoids 
problems related to the time relativity. 
The control of DEDS can be designed if there is a DEDS model available. 
Control engineering design methods perform the following tasks: 
• 
Formulation and specification of the given system control tasks; 
• 
Determination of control algorithms; 
• 
Design of technical means necessary for the control implementation; 
• 
Creation and verification of control programs; and 
• 
Implementation, testing and maintenance of the control system function. 
Control engineering is an applied interdisciplinary technical science. To a 
considerable extent, the solution methods are independent of the technological 
substance of controlled systems. For a control it is important to achieve such an 
influence of various agents on the system that parameters and behavior of the 
system are as required (Kozák 2002; Jörgl 1993). The system behavior and various 
influences on it are given by physical, chemical, biological or other quantity values. 
What is important from the viewpoint of control is the information the quantities 
carry, but not their physical substance.  
Automatic control is based on the information manifestations of the system. In 
other words, a system is described by means of information about the spatial 
location of objects, time, system parameters, properties, characteristics, etc. Time 
is substantial for the dynamics of events. As mentioned earlier, the time evolution 
of system variables is called the process and in the context of DEDS, it is called the 
discrete process. 
1.2 Discrete Variables and Relations 
The notion of DEDS has been specified in the previous section. It is based on the 
discrete character of the individual variables and relations. It is useful to study the 
property of discreteness in some detail. 
Definition 1.1. Let D  be a finite set of n elements, i.e., 
 
{
}
n
d
d
d
D
,...,
,
2
1
=
   
(1.1) 

 
Basic Description of Discrete-event Dynamic Systems 
5 
Let v  be a variable taking on values only from set D , i.e.,  
 
D
d
v
i ∈
=
 
       (1.2) 
then v  is a discrete variable. 
Definition 1.2. Let two non-empty finite sets D and E be given: 
 
{
}
n
d
d
d
D
,...,
,
2
1
=
 
 (1.3) 
 
{
}
m
e
e
e
E
,...,
,
2
1
=
  
  (1.4) 
A binary relation R  from D  into E is defined by 
 
E
D
R
×
⊆
  
  (1.5) 
where symbol × denotes the Cartesian product. 
If a relation is defined on the sets for which 
A
E
D
=
=
 then 
A
A
R
×
⊆
 and we 
say that R  is a binary relation on A . The relation R  can be empty. If, e.g., 
(
)
R
e
d
∈
3
2,
 we write 
3
2
e
R
d
. Functions or mappings are subsets of relations. 
They are special relation cases as formally given next. 
Definition 1.3. Let a binary relation R
 from 
{
}
n
d
d
d
D
,...
,
2
1
=
 into 
{
}
m
e
e
e
E
,...,
,
2
1
=
 be given. Let for any two elements of 
E
D ×
 
 
 (
)
(
)
{
}
{
}
{
}
{
}
m
l
n
k
m
j
n
i
E
D
e
d
E
D
e
d
l
k
j
i
,...,
2,1
,
,...,
2,1
,
,...,
2,1
,
,...,
2,1
,
,
,
,
∈
∈
∈
∈
×
∈
×
∈
 
(1.6) 
If the following implication holds true 
 
(
)
(
)
(
)
(
)
R
e
d
and
R
e
d
e
e
and
d
d
l
k
j
i
l
j
k
i
∉
∉
⇒
≠
=
,
,
 
(1.7) 
then the relation R  is a discrete function or a discrete mapping notated f defined 
on the domain 
 
}
,...,
,
{
2
1
si
i
i
d
d
d
DOM =
 
(1.8) 
where DOM  is the set of all first elements of the pairs (
)
j
i e
d ,
 belonging to the 
relation R . A co-domain of the function is set CDOM  that consists of all the 
second elements of the pairs (
)
j
i e
d ,
 belonging to the relation R   
 
}
,...,
,
{
2
1
ui
i
i
e
e
e
CDOM =
 
(1.9) 

6 
Modeling and Control of Discrete-event Dynamic Systems 
We write 
 
(
)
CDOM
e
DOM
d
d
f
e
j
i
i
j
∈
∈
=
,
,
 
       (1.10) 
The right-hand side of Equation (1.7) is an AND conjunction of two 
propositions. If the premise is true, they both are true. It means that both ordered 
pairs (
)
j
i e
d ,
 and (
)
l
k e
d ,
 cannot belong to the relation R. However, one of them 
can be in R. Another formulation of this can be as follows. A function is a binary 
relation from set 
{
}
n
d
d
d
D
,...,
,
2
1
=
 into set 
{
}
m
e
e
e
E
,...,
,
2
1
=
 if there are no two 
ordered pairs (
) (
)
v
p
r
p
e
d
e
d
,
,
,
 in R such that 
v
r
e
e ≠
. 
1.3 Discrete Processes 
Let a finite set Σ  be given as 
 
{
}
ne
e
e
,...,
,
2
1
=
Σ
 
(1.11) 
The set Σ  is called the event set. We assume that an event 
Σ
∈
kie
 occurs at the 
time point 
kiτ . Let a sequence of events be given as 
 
N
k
i
i
i
i
e
e
e
e
,...,
,...,
,
~
2
1
=
σ
 
(1.12) 
where 
Σ
∈
1ie
 occurs in the discrete time point 
1iτ , 
Σ
∈
2ie
 in time point 
2iτ , etc., 
kie in time point 
kiτ
, etc., and 
N
ie
in time point 
Niτ
, 
N
k
i
i
i
i
τ
τ
τ
τ
〈
〈
〈
〈
〈
.....
.....
2
1
. The 
sequence σ~  is called a discrete process. In this particular case when elements of a 
sequence are events we speak about the event string. 
Figure 1.3 shows layout of a manufacturing system including a milling machine 
M, a grinding machine G and three belt conveyors C1–C3. The parts to be 
processed in the manufacturing system come into the system irregularly with 
various gaps as a sequence one by one part. Maximum three parts can be fed up on 
the conveyor C1. Input of a part is detected by a photo-sensor P11. The part is 
stopped by a stopper at the end of C1. Presence of the part at the end of the 
conveyor is signalized by a photo-sensor P12. If the milling machine M is free and 
a part is available at the end of C1, the part is transferred by the transportation 
means T1 into the milling machine. After milling the part is transferred by T2 onto 
the conveyor C2. The photo-sensor P21 detects input of the part on the conveyor 
C2. In the conveyor section between the sensors P21 and P22 there can be 
maximum two parts. The same mechanism holds for loading of the grinding 
machine G. Maximum four parts can be loaded on the conveyor section P31–P32. 

 
Basic Description of Discrete-event Dynamic Systems 
7 
C1 
C1 
C2
C3
P11 
P12
M
G
P21
P22
P31
P32 
T1 
T2
T3
T4
 
Figure 1.3. Manufacturing system layout 
In a manufacturing system, typical events are the input of a part into a conveyor 
section, arrival of a part in some position on the conveyor, start of an operation, 
e.g., start of milling, end of an operation, e.g., end of milling.  
As an example, consider the following event set: 
 
{
}
3
3
3
2
2
2
3
2
1
1
1
,
,
,
,
,
,
,
,
,
,
,
,
,
,
C
C
G
G
C
C
C
C
M
M
C
C
C
C
C
e
s
e
s
g
g
e
s
e
s
m
m
m
e
s
=
Σ
 (1.13) 
where 
1
C
s
  stands for input of a part on conveyor C1, 
1
C
e
 means arrival of a part at 
the end of the conveyor C1, 
1
C
m
 means the transfer of a part from the conveyor C1 
into the milling machine, 
M
s
 is the start and 
M
e
 the end of milling, 
2
C
m
 is the 
transfer of a part from M on C2. Similarly, 
2
C
g
 and 
3
C
g
 denote transfers from C2 
in G and from G on C3, respectively. The other events are denoted similarly. 
Suppose that the manufacturing system is empty in its initial state. Both 
machines and conveyors are free. A possible sequence of events starting from the 
initial state is  
 
G
C
C
M
C
C
C
C
M
C
M
C
C
C
s
g
e
s
m
e
s
m
e
s
s
m
e
s
2
2
1
1
2
2
1
1
1
1
1
~ =
σ
 
(1.14) 
Event 
1
C
s
 occurs at the time point
1τ , event 
1
C
e
 at
2
τ … whereas
.....
2
1
〈
〈τ
τ
.  
Let us consider another event sequence example: 
 
1
2
2
1
2
2
1
1
1
1
1
1
2
~
C
M
C
C
M
C
C
C
M
C
M
C
C
C
C
C
s
e
g
e
s
m
s
m
e
e
s
m
s
s
e
s
=
σ
 
       (1.15) 
Consider the following sequence starting from the initial state when the system is 
without parts (empty system): 
 
1
1
1
3
~
C
C
C
e
e
s
=
σ
 
(1.16) 
It represents an example of a technologically unfeasible event sequence in the 
given system. Consider a sequence from the beginning: 
 
                               
1
1
1
1
1
1
4
~
C
C
C
M
C
C
C
m
e
s
s
m
e
s
=
σ
 
(1.17) 

8 
Modeling and Control of Discrete-event Dynamic Systems 
This is an example of a feasible event string, but not an admissible one due to the 
requirement that only one part can be present in the milling machine. 
As mentioned before, an event is associated with a change of state. For example, 
the empty state when all conveyors are empty and both machines are free is 
denoted
0
q . Arrival of a part on conveyor C1 is an event. State 
0
q  turns into state 
1q  characterized by the presence of a part on C1 moving toward the stopper, while 
other conveyors and machines are still free. 
The manufacturing system in Figure 1.3 is a serially arranged production line. 
A serial-parallel production cell example is shown in Figure 1.4. Suppose that four 
kinds of semi-products are produced from one kind of parts coming in via 
conveyor C1 and transported through the cell via conveyors C2–C4. Table 1.1 
describes the options how to produce them. 
 
C1
M1
C2
C3
C4
M3
M4
R1
R3
R2
INPUT 
OUTPUT
M2
 
Figure 1.4. Manufacturing system arranged in a serial-parallel structure 
Table 1.1. Job options in the manufacturing system 
Operation 
A 
B 
C 
D 
1 
M1 
M3 
M2 
M1 
2 
M2 or M3 
M2 or M4 
M4 
M3 
3 
M4 
M3 or M4 
M3 or M4 
M3 or M4 
4 
 
M4 
 
M2 
The system is flexible in that there are several ways to finish the production 
tasks having the job alternatives given in Table 1.1. The optimal route of the 
processed parts is to be found. A related problem to this is the job scheduling. Both 
problems can be solved with respect to the given optimality criterion, e.g., to 
minimize the overall production work-span (work-time), also called makespan and 
completion time. The operation times have to be available for that task. A joblist 
breakdown with respect to operation time specifications is given in Table 1.2. Time 

 
Basic Description of Discrete-event Dynamic Systems 
9 
durations for the semi-products A, B, C, and D are denoted by a, b, c, and d, 
respectively. The scheduling problem will be treated in detail later. 
Individual events of the system depicted in Figure 1.4 can be specified as 
before: 
⎪
⎪
⎪
⎪
⎪
⎪
⎭
⎪⎪
⎪
⎪
⎪
⎪
⎬
⎫
⎪
⎪
⎪
⎪
⎪
⎪
⎩
⎪⎪
⎪
⎪
⎪
⎪
⎨
⎧
=
Σ
4
4
3
4
4
3
4
4
3
4
4
3
3
4
3
3
4
3
4
3
3
4
3
3
4
3
3
4
3
3
2
4
3
2
4
3
4
2
3
4
2
3
2
4
3
2
4
3
4
2
3
4
2
3
2
3
3
2
3
3
3
2
3
3
2
3
3
2
2
3
2
2
3
4
2
3
4
2
2
4
2
2
4
2
4
2
2
4
2
2
4
1
2
4
1
2
2
1
2
2
1
2
2
2
1
2
2
1
2
1
1
2
1
1
2
1
1
2
1
1
4
1
1
4
1
1
2
1
1
2
1
1
2
1
1
2
1
1
1
1
1
1
1
1
4
4
1
1
4
4
3
3
2
2
1
1
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,...,
,
,
,
,
,
,
,
,
,
M
C
R
M
C
R
C
M
R
C
M
R
M
C
R
M
C
R
C
M
R
C
M
R
M
M
R
M
M
R
C
C
R
C
C
R
C
C
R
C
C
R
C
M
R
C
M
R
M
C
R
M
C
R
C
M
R
C
M
R
M
C
R
M
C
R
C
M
R
C
M
R
C
C
R
C
C
R
M
C
R
M
C
R
C
M
R
C
M
R
C
C
R
C
C
R
M
C
R
M
C
R
C
M
R
C
M
R
M
M
R
M
M
R
C
M
R
C
M
R
C
C
R
C
C
R
M
C
R
M
C
R
C
C
R
C
C
R
M
C
R
M
C
R
M
M
M
M
C
C
C
C
C
C
C
C
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
e
s
b
a
b
a
b
a
b
a
 
  
 
(1.18) 
Table 1.2. Job duration times specifications 
Products 
 
A 
B 
C 
D 
Machines 
Machines 
Machines 
Machines 
Oper
ation 
M1
M2 M3 M4 M2
M3
M4
M2
M3
M4
M1
M2
M3 M4 
1 
a11 
 
 
 
 
b13
 
c12
 
 
d11
 
 
 
2 
 
a22 
a23 
 
b22
 
b24
 
 
c24
 
 
d23 
 
3 
 
 
 
a34 
 
b33
b34
 
c33
c34
 
 
d33 
d34 
4 
 
 
 
 
 
 
b44
 
 
 
 
d42
 
 
Occurrence of a part at one side of the conveyor is denoted as event a , on the 
other side as b . 
1
1
1
M
C
R
s
 is the start of the part transfer via Robot R1 from conveyor 
C1 to the machine M1, 
1
1
1
M
C
R
e
 is the end of the transfer. The system control 
depends on the conveyor capacities. 
It is assumed that the transfer times consumed by the robots and conveyors are 
negligible because they are much smaller than operation times. If such an 
assumption is not acceptable times of transfer operations can be considered 
separately.  In the latter case Table 1.2 would be extended by further time 
specifications. Sometimes the transportation times can be included in the operation 
times of the processing machines. 

10 
Modeling and Control of Discrete-event Dynamic Systems 
1.4 Basic Properties of DEDS and their Specification 
Characteristic properties of DEDS can be best illustrated on examples. DEDS 
include flexible manufacturing systems, digital computers, local or global 
computer networks, operation centers, and transportation systems on surface or in 
air. Various properties of DEDS events are to be studied: 
• 
Event synchronization 
• 
Concurrency 
• 
Parallelism 
• 
Conflict 
• 
Mutual exclusion 
• 
Deadlock 
• 
System liveness 
• 
Reversibility 
• 
State reachability 
• 
Event scheduling 
Mankind strives not only to observe the natural phenomena but also to govern, 
to control and to benefit from them. Many various tools for the specification and 
analysis of DEDS are used nowadays. In addition, there is a need for tools that are 
suitable for the design of DEDS control. They should be able to specify the 
required properties of DEDS and to ensure the real-time reactivity of the controlled 
DEDS.  
Basically the tools can be divided in three groups: 
• 
Graphical tools 
• 
Algebraic tools 
• 
Formal language-based tools  
The graphical tools are frequently used due to their transparency and ability to 
provide rich visual information. The main graphical tools include: 
• 
State-transition diagrams or finite-automata 
• 
Reactive (real-time) flow diagrams 
• 
Statecharts 
• 
Petri nets 
• 
Grafcet 
• 
Ladder logic diagrams 
The algebraic tools are the following: 
• 
Boolean algebra 
• 
Algebraic expressions based on the respective state space 
• 
Temporal logic 
• 
Max-plus algebra 
The tools based on formal languages are as follows: 
• 
Formal language models  

 
Basic Description of Discrete-event Dynamic Systems 
11 
• 
Standard programming languages combined with real-time operating 
systems 
• 
Real-time programming languages 
The different tools listed above are not equivalent with respect to the 
application field. For example, max-plus algebra is effective especially for the 
analysis and control of job scheduling, while Grafcet is useful for the specification 
of the sequence control (Frištacký et al. 1981, 1990; Zhou and Venkatesh 1998; 
Zhou 1995). 
The first two basic groups can serve as intermediate means between the 
requirements imposed on the system and the control that ensures them. A final 
specification and implementation of control requires the third group, namely a 
programming language. The specified control will then be implemented on 
appropriate hardware components, e.g., personal computer, process computer, 
programmable logic controller, etc. From a graphical or algebraic specification a 
control program can be generated automatically. Also the transformations among 
the different specification tools are useful.  
On the other hand, sometimes and for someone there is no need to use any 
intermediate means and it is possible to write a control program directly. However, 
for most people the opposite is true. A program formulated in any procedural 
language is a string of instructions to be performed separately and to force the 
system to behave as required. Intermediate means help to avoid the programming 
incorrectness.  
Each specification tool listed above is based on the concept of the system state 
and state transitions described earlier as events. This fact can be illustrated by the 
following generally valid system behavior scheme: 
...
→ STATE→TRANSITION→STATE→TRANSITION→
... 
Because of the generality of this scheme, the "state and transition" concept is dealt 
with in more detail in the following section. 
1.5 Basic Transition System 
Various DEDS can be described uniquely by means of the so-called basic 
transition model proposed by Manna and Pnueli (1991), which serves us as a 
general description framework. It is defined by the quadruple 
 
(
)
Θ
Σ
Π
=
,
,
,Q
SYST
 
(1.19) 
where  
{
}
n
u
u
u
,...,
,
2
1
=
Π
 is the finite set of state variables; 
Q  is the set of states where each state is given by the particular values of 
the variables from set Π . This value assignment is called the interpretation 
of variables belonging to the set Π ; 

12 
Modeling and Control of Discrete-event Dynamic Systems 
Σ  is the set of transitions whereby a transition 
Σ
∈
e
 is a partial function 
Q
Ce
Q
e
2
:
⎯→
⎯
. Note that 
Q
2  is the power set defined as a set of all subsets 
created from set Q including the empty set ∅, 
e
C  is a condition imposed 
on a transition e  so that e  can occur only if 
e
C  is fulfilled, and 
e
C  can be 
empty (meaning no condition); and 
Θ  is the set of initial conditions of the system. It includes states in which 
the execution of potential events can start. 
The modeling power of the Manna and Pnueli model is that any correct 
specification by means of any tool described earlier can be transformed into a basic 
transition system. In other words, suitable transformations can be established 
between different system specifications. We can see that transitions in this model 
correspond to events introduced before. The time is not explicitly expressed in a 
basic transition. Rather, a possible sequence of events or an event precedence 
relation is used.  
The function 
Q
Ce
Q
2
⎯→
⎯
 defining an event e is quite abstract. A standard 
particular case by excluding system control (if only controlled system is 
represented) is when one state is mapped into one another state due to the condition 
e
C  or because there is only one-to-one mapping. The case when a state is mapped 
into state subsets presents indeterminism and its significance is purely theoretical. 
An example of that is the indeterministic finite automaton (see Section 5.4). In 
practical system control the indeterminism should be removed. If control is 
included the function 
Q
Ce
Q
2
⎯→
⎯
 can map a state to more states. See Chapter 4 
for more details. 
A general form of the specification of an event e  is a transition relation given 
as an assertion for each transition e : 
 
(
)
'
,Π
Π
e
ρ
 
 (1.20) 
which relates the interpretation of state variables given as a state s with the 
interpretation of state variables given as a succeeding state 's . Under assertions we 
understand Boolean expressions extended by quantificators 
∀
∃,
, etc. In other 
words, in each state the relation 
(
)
'
,Π
Π
e
ρ
 determines the next state or states after 
transition e takes place. The following form describing the transition relation e  
can be used: 
 
(
)
(
)
(
) (
)
(
)
n
n
e
e
ex
u
ex
u
ex
u
C
=
∧
∧
=
∧
=
∧
Π
=
Π
Π
'
...
'
'
,
2
2
1
1
'
ρ
  
(1.21) 
where 
( )
Π
e
C
 is an assertion stating a condition for state s under which transition 
e  is enabled and the system comes over into state 's ; 
n
ex −
1
 are logic expressions. 
Assertion 
( )
Π
e
C
 is constructed over state variables such that if the variable values 
lead to a true Boolean value from 
( )
Π
e
C
, e  is enabled and state variables 
n
u −
1'
 

 
Basic Description of Discrete-event Dynamic Systems 
13 
are given the values according to expressions 
n
ex −
1
. These expressions are built up 
of state variables 
n
u −
1
.  Notation 
i
ex  is shortened in Equation (1.21). It has the 
following meaning: 
 
true
is
lex
if
only
and
if
lex
u
i
i
i
2
1
' =
 
(1.22) 
State variables in DEDS are discrete ones. If they are logical variables or 
expressions built up of logical variables, then Equation (1.21) can be put together 
directly based on them. Other than logic variables can be represented by means of 
a set of the auxiliary logic variables further used in Equation (1.21).  
Figure 1.5 shows an example of a simple discrete event dynamic system. The 
system is an input portion of a flexible manufacturing system. The parts to be 
processed are transported into the system by belt conveyor C1. They arrive as an 
irregular stream. There are different gaps between individual parts. A video system 
VS scans each part when the latter enters the VS range (detected by sensor P0).  It 
evaluates the parameters of shape and quality of an incoming part and sorts it in 
two groups. These two groups are routed via turntable TT1. Intervals between 
individual parts are so that a new part comes in the range of sensor P0 when the 
preceding part is already on conveyor C2 or C3. The parts of the first group are 
placed on conveyor C2 while those of the second group on conveyor C3. 
z
z
z
z
z
z
VIDEO
SYSTEM
VS
C1
TURNTABLE
TT1
C2
C3
P0
P1
P2
 
Figure 1.5. A manufacturing system 
Now, let us model the system described in the example in a form given by 
Equation (1.19). We have  
 

14 
Modeling and Control of Discrete-event Dynamic Systems 
 
(
)
Θ
Σ
Π
=
,
,
,Q
SYST
 
(1.23) 
 
⎭
⎬
⎫
⎩
⎨
⎧
=
Π
V
TT
H
TT
V
ETT
H
ETT
T
P
P
P
1
,
1
;
1
,
1
;1
;
,
;
,
,
02
01
2
1
0
γ
γ
 
(1.24) 
where P0-P2 are logic variables corresponding to sensors P0-P2, respectively. If a 
part is under sensor P0 then
1
0 =
P
, etc. Note that the variables are written in italic 
in order to distinguish them from the corresponding sources of the variables. γ01 
and γ02 serve for the group distinction: γ01=1 and γ02=0 for the first group and γ01=0 
and γ02=1 for the second one. 1
T  is a state variable signaling the presence of a part 
in turntable TT1 when 
1
1 =
T
; otherwise 
0
1 =
T
. ETT1H and ETT1V indicate the 
turntable horizontal and vertical positions, respectively. TT1H, and TT1V are 
commands to set the turntable horizontally or vertically. Before the start of the 
system operation, conveyors C1–C3 are switched on and remain in this state during 
the operation. Let there be the logic C1–C3 corresponding to the conveyor state; 
1
1 =
C
 if conveyor C1 is switched on and similarly for C2 and C3. 
The set of states is as follows: 
 
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
),
1,0
;0,1
;1
;1,0
;1,0,0
,
0,1
;0,1
;1
;1,0
;0,0,0
,
0,1
;0,1
;0
;1,0
;0,1,0
,
0,1
;0,1
;0
;1,0
;0,0,0
,
0,1
;0,1
;0
;1,0
;0,0,1
,
0,1
;0,1
;1
;0,1
;1,0,0
,
0,1
;0,1
;1
;0,1
;0,0,0
,
0,1
;0,1
;0
;0,1
;0,1,0
,
0,1
;0,1
;0
;0,1
;0,0,0
,
0,1
;0,1
;0
;0,1
;0,0,1
,
0,1
;0,1
;0
;0,0
;0,0,1
,
0,1
;0,1
;0
;0,0
;0,0,0
{
11
10
9
8
7
6
5
4
3
2
1
0
=
=
=
=
=
=
=
=
=
=
=
=
=
q
q
q
q
q
q
q
q
q
q
q
q
Q
 
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)}
0,1
;0,1
;1
;1,0
;1,0,0
,
1,0
;1,0
;1
;0,1
;0,0,0
,
1,0
;1,0
;0
;0,1
;0,1,0
,
1,0
;1,0
;0
;0,1
;0,0,0
,
1,0
;1,0
;0
;0,1
;0,0,1
,
1,0
;1,0
;1
;1,0
;1,0,0
,
1,0
;1,0
;0
;1,0
;0,1,0
,
1,0
;1,0
;0
;1,0
;0,0,0
,
1,0
;1,0
;0
;1,0
;0,0,1
,
1,0
;1,0
;0
;0,0
;0,0,1
,
1,0
;1,0
;0
;0,0
;0,0,0
,
1,0
;1,0
;1
;1,0
;1,0,0
23
22
21
20
19
18
17
16
15
14
13
12
=
=
=
=
=
=
=
=
=
=
=
=
q
q
q
q
q
q
q
q
q
q
q
q
 
(1.25) 
The set of transitions Σ  is given by the set of the following partial functions: 
 
(
)
(
)
(
)
(
)
.
,...
:
,
:
,
:
,
:
4
3
4
4
3
2
3
3
2
1
2
2
1
0
1
1
etc
q
q
e
e
q
q
e
e
q
q
e
e
q
q
e
e
=
=
=
=
 
 
 
(1.26) 
All functions can be given via Tables 1.3 and 1.4. Function values are in the 
table cells. Let the initial conditions Θ  for the occurrence of the events from set Σ  
are these: the system is in state q0 and 
1
3
2
1
=
=
=
C
C
C
. Establishing the system 
in q0 is indicated by the logic variable INIT. 

 
Basic Description of Discrete-event Dynamic Systems 
15 
Table 1.3. The first part of the transition set functions 
Function argument 
 
q0 
q1 
q2 
q3
q4
q5
q6
q7
q8
q9
q10
q11 
e1 
q1 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e2 
- 
q2 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e3 
- 
- 
q3 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e4 
- 
- 
- 
q4
- 
- 
- 
- 
- 
- 
- 
- 
e5 
- 
- 
- 
- 
q5
- 
- 
- 
- 
- 
- 
- 
e6 
- 
- 
- 
- 
- 
q6
- 
- 
- 
- 
- 
- 
e7 
- 
- 
- 
- 
- 
- 
q0
- 
- 
- 
- 
- 
e8 
- 
q7 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e9 
- 
- 
- 
- 
- 
- 
- 
q8
- 
- 
- 
- 
e10 
- 
- 
- 
- 
- 
- 
- 
- 
q9
- 
- 
- 
e11 
- 
- 
- 
- 
- 
- 
- 
- 
- 
q10
- 
- 
e12 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
q11
- 
e13 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
q12 
e14 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e15 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e16 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e17 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e18 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e19 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e20 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e21 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e22 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e23 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e24 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e25 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
e26 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

16 
Modeling and Control of Discrete-event Dynamic Systems 
Table 1.4. The second part of the transition set functions 
Function argument 
 
q12 
q13 
q14 
q15
q16
q17
q18
q19
q20
q21
q22
q23 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
q13 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
q14 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
q15 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
q16
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
q17
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
q18
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
q13
- 
- 
- 
- 
- 
 
- 
- 
q19 
- 
- 
- 
- 
- 
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
q20
- 
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
q21
- 
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
q22
- 
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
q23
- 
 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
q6 
All possible event sequences in the analyzed manufacturing system are built up 
from the sequences 

 
Basic Description of Discrete-event Dynamic Systems 
17 
 
7
26
25
24
23
22
21
6
14
20
19
18
17
16
5
15
4
14
13
12
11
10
9
8
3
7
6
5
4
3
2
2
1
1
~
~
~
~
~
~
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
=
=
=
=
=
=
σ
σ
σ
σ
σ
σ
   
 
 
(1.27) 
The buildup or concatenations of the event sequences at Equation (1.27) 
follows the scheme as shown in Figure 1.6. Activities of the system can start when 
the condition Θ  is fulfilled and it means that the first event sequence can be only 
1
~σ . Equation (1.21) for the investigated system are 
 
(
)
(
)
(
)
(
) (
)
(
)1
1
1
1
1
1
1
1
1
1
1
1
1
1
3
2
1
,
2
1
2
1
2
1
2
1
2
1
1
2
1
02
2
1
01
2
1
2
2
1
1
2
1
0
1
=
=
′
∧
=
=
′
∧
=
=
′
∧
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
∧
∧
∧
=
Π′
Π
lex
if
only
and
if
lex
V
TT
lex
if
only
and
if
lex
H
TT
lex
if
only
and
if
lex
V
ETT
lex
if
only
and
if
lex
H
ETT
lex
if
only
and
if
lex
T
lex
if
only
and
if
lex
lex
if
only
and
if
lex
lex
if
only
and
if
lex
P
lex
if
only
and
if
lex
P
lex
if
only
and
if
lex
P
INIT
C
C
C
e
γ
γ
ρ
                       
 
 
(1.28) 
where 
 
V
TT
H
TT
V
ETT
H
ETT
T
P
P
P
lex
lex
lex
1
1
1
1
1
,
02
01
2
1
0
2
2
1
∧
∧
∧
∧
∧
∧
∧
∧
∧
=
=
γ
γ
 
(1.29) 
True logic value is 1 and false 0 in Equation (1.29). For event 
2e  we have 
 
 
1
~σ
2
~σ
3
~σ
4
~σ
5
~σ
6
~σ
 
Figure 1.6. Event sequence patterns 

18 
Modeling and Control of Discrete-event Dynamic Systems 
 
(
)
(
)
(
)
(
) (
)
(
)1
1
1
1
1
1
1
1
1
1
1
1
1
1
3
2
1
,
2
1
2
1
2
1
2
1
2
1
1
2
1
02
2
1
01
2
1
2
2
1
1
2
1
0
2
=
=
′
∧
=
=
′
∧
=
=
′
∧
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
⎟⎠
⎞
⎜⎝
⎛
=
=
′
∧
∧
∧
∧
=
Π′
Π
lex
if
only
and
if
lex
V
TT
lex
if
only
and
if
lex
H
TT
lex
if
only
and
if
lex
V
ETT
lex
if
only
and
if
lex
H
ETT
lex
if
only
and
if
lex
T
lex
if
only
and
if
lex
lex
if
only
and
if
lex
lex
if
only
and
if
lex
P
lex
if
only
and
if
lex
P
lex
if
only
and
if
lex
P
INIT
C
C
C
e
γ
γ
ρ
 
 
 
 (1.30) 
where  
 
V
TT
H
TT
V
ETT
H
ETT
T
P
P
P
lex
lex
lex
1
1
1
1
1
,
02
01
2
1
0
2
2
1
∧
∧
∧
∧
∧
∧
∧
∧
∧
=
=
γ
γ
(1.31) 
Other events would be expressed in a similar way. 
Now consider an extension to the above system so that the parts of the first 
group are processed in a batch of three by RA1 or RA2. Both robots perform the 
similar operations.  The parts of the second group to a cell are routed via turntable 
TT2. They are processed in two by RB robotic cell. The number of parts is checked 
by means of photo-sensors PA1–PA3 and PB1–PB2, respectively.  Gate G1 (G2) goes 
up when three (two) parts are prepared for the next processing. Transport conveyor 
capacities are three transported parts for C2–C5, C8–C9 and two for C6–C7, 
respectively. Only one part can be allowed between sensors 
0
P  and 
1P . 
When a triple is prepared under sensor PA5, robot RA1 performs the required 
processing operations and then transfers the triple onto conveyor O1.  RA2 and RB 
operate similarly. The aim of the control is to coordinate and control operations 
and movement of parts within the system. The co-ordination control level is 
superior to the process control one. The process control examples are the vision 
system’s detection of parts, robots’ movement control, and conveyor speed control. 
The vision system start is an event commanded from the coordination control level. 
Other facts concerning the FMS function are evident from the layout in Figure 1.7. 
Now, let us outline the model of the system depicted in Figure 1.7 in a form 
given by Equation (1.19). We have 
 
 
⎪⎪
⎪
⎪
⎭
⎪⎪
⎪
⎪
⎬
⎫
⎪⎪
⎪
⎪
⎩
⎪⎪
⎪
⎪
⎨
⎧
=
Π
92
91
82
81
72
71
62
61
52
51
31
42
41
32
31
22
21
22
21
12
11
02
01
3
2
1
6
5
4
3
2
1
2
1
0
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
;
,2
,1
,
2
,
2
,
1
,
1
,2
,1
,9
,9
,8
,8
,7
,7
,5
,5
,4
,4
,2
,2
,1
,1
;
,2
,1
,
2
,
2
,
1
,
1
,
,
,
,
,
,
,
,
,
,
,
,
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
LC
RB
RA
RA
V
TT
H
TT
V
TT
H
TT
G
G
EC
SC
EC
SC
EC
SC
EC
SC
EC
SC
EC
SC
EC
SC
ERB
ERA
ERA
V
ETT
H
ETT
V
ETT
H
ETT
P
P
P
P
P
P
P
P
P
P
P
P
B
B
B
A
A
A
A
A
A
γ
γ
γ
γ
γ
γ
  
 
  
(1.32) 

 
Basic Description of Discrete-event Dynamic Systems 
19 
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
z
VIDEO
SYSTEM
VS
C1
TURN
TABLE
TT1
C2
C4
TT2
C5
C3
C6
C7
C8
C9
O1
O2
RA1
RA2
RB
O3
P0
P1
P2
PA1 PA2 PA3
G1
G2
PA4
PA5
PB1
PB2
PB3
TURN
TABLE
 
Figure 1.7. Example of a basic transition system: FMS with three robots 
where the first part (the first two rows of Equation (1.28)) is inputs fed from the 
controlled system to the control system, the second part (the third and fourth rows) 
is outputs from the latter fed into the former and the third part is internal state 
variables. The variables Π  are determined at the higher coordination control level. 
The model is built for the coordination control purpose. As in the preceding 
example, variable ETT1H indicates the straight position of turntable TT1, ETT1V 
its transversal position, etc. We assume that initially conveyors C3 and C6 and 
conveyors in both turntables are switched on and moving during the FMS 
operation. Conveyor C1 is started by command variable SC1 and stopped by EC1. 
Other conveyor variables listed in Equation (1.32) have analogous meanings. The 
gates are operated by variables G1 and G2. Variables TT1H, TT1V, etc., are used to 
control the turntables, while RA1, RA2, and RB start robot operations. ERA1, ERA2, 
and ERB signals the end of the part processing by robots RA1, RA2, and RB, 
respectively. Information about routing a part is transferred from γ01 and γ02 to γ11 
and γ22 when the part moves from sensors P0 to P1 (γ01 and γ02 should be free for the 
next part), and analogously for γ11 and γ22 and sensor P2. LC21 and LC22 stand for 
storing the number of parts loaded on C2 so that no part gives 
0
,0
22
21
=
=
LC
LC
; 
one part gives 
1
,0
22
21
=
=
LC
LC
; two parts 
1
,1
22
21
=
=
LC
LC
; and three parts 

20 
Modeling and Control of Discrete-event Dynamic Systems 
1
,1
22
21
=
=
LC
LC
. Analogously, this holds true for 
ij
LC
, but in terms of 
conveyors C6 and C7, which have the capacity equal 2. 
All variables in Equation (1.32) are the Boolean ones taking values of 0 and 1. 
The states in set Q are given by pertinent variable values. For example, if 
1
2 =
A
P
 
and 
1
3 =
A
P
 and all other variables are zero, the system is in a state when two parts 
are located before gate G1 and otherwise it is empty. Then the arrival of a new part 
in C1, signaled by 
1
0 =
P
, is an event given by mapping the previously described 
state into one with 
1
,1
,1
3
2
0
=
=
=
A
A
P
P
P
 and all remaining variables being zero. 
For example, an event 
3
WP
e =
 - the arrival of a next part – in P0=0, P1=0, …, 
PA1=0, PA2=1, PA3=1, PA4=0, ..., is 
 
(
)
(
)
(
)
(
)
⎟⎠
⎞
⎜⎝
⎛
∧
∧
∧
∧
∧
∧
∧
∧
=
′
∧
∧
⎟⎠
⎞
⎜⎝
⎛
∧
∧
∧
∧
∧
∧
∧
∧
=
∧
∧
∧
∧
∧
∧
∧
∧
∧
=
∧
∧
∧
∧
∧
∧
∧
∧
∧
=
∧
⎟⎠
⎞
⎜⎝
⎛
∧
∧
∧
∧
∧
∧
∧
∧
=
∧
∧
⎟⎠
⎞
⎜⎝
⎛
∧
∧
∧
∧
∧
∧
∧
∧
=
∧
∧
∧
∧
∧
∧
∧
∧
∧
=
∧
=
Π
Π
92
4
3
2
1
1
0
92
92
4
3
2
1
1
0
'
4
92
4
3
2
1
1
0
'
3
92
4
3
2
1
1
0
'
2
92
4
3
2
1
1
0
'
1
92
4
3
2
1
1
0
'
1
92
4
3
2
1
1
0
'
0
3
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
1
'
,
LC
P
P
P
P
P
P
LC
LC
P
P
P
P
P
P
P
LC
P
P
P
P
P
P
P
LC
P
P
P
P
P
P
P
LC
P
P
P
P
P
P
P
LC
P
P
P
P
P
P
P
LC
P
P
P
P
P
P
P
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
WP
ρ
               
 
 
(1.33) 
where Θ represents the condition that the system has to be initialized and empty 
before the first event can be accepted.  
The example illustrates that in a little more complex case the modeling using a 
basic transition system is complicated, not transparent and very difficult for 
analysis and control design. In the following chapters of this book, we try to 
develop systematically theory and a way for practical use of other tools aiming to 
model, analyze, evaluate, simulate and control DEDS. 
1.6 Problems and Exercises 
1.1. Cite some CDVS and DEDS examples from your daily life. 
1.2. Derive the basic transition system models for Figures 1.3 and 1.4. 
1.3. In the system in Figure 1.5, change the assumption that only one part is 
processed in it so that a part can come in when another part is between sensors P0 
and P1. Consider capacities of the conveyors. 

 
Basic Description of Discrete-event Dynamic Systems 
21 
1.4. Write the expression for the event next to that given by Equation (1.33) when a 
part moves from sensors P0 to P1. 
1.5. A robotic cell is depicted in Figure 1.8. A-Parts are loaded into it via input 
conveyor I1. The input has capacity of 1 part. The same holds for input I2 and 
output O. Robot R2 picks up an A-workpiece from I2 and transfers it onto table T.  
R1 picks up a B-work-piece from I1 and puts it into the free milling machine M1 
or M2. If both are free, M1 is preferred. After the machining, R1 transfers it onto 
palette P. If there is an A-workpiece on T, R2 transfers it from the palette to T and 
an assembly starts. After it, R2 transfers the product onto O. a) Analyze the system 
as DEDS; and b) Create an event set and event strings corresponding to the 
required behavior of the system, a realizable but not admissible event string and a 
non-realizable event string. 
 
Figure 1.8. A robotic cell with two milling machines 
1.6. For the system depicted in Figure 1.4 write a realizable event string 
corresponding to the technological process A in Table 1.1, a realizable but not 
admissible event string and a non-realizable event string. 
Input I1
Input I2
Output O 
Milling machine 
M1 
Milling machine 
M2 
Robot R1 
Robot R2 
Palette P 
Assembling
table T

2 
Graphs in Modeling DEDS 
2.1 Simple Non-labeled Directed Mathematical Graphs 
The basic transition model and its derivatives can be very easily and transparently 
represented graphically. A platform for this representation is a mathematical graph. 
Definition 2.1. A simple non-labeled directed mathematical graph is given by an 
ordered pair 
 
(
)
R
A
G
,
=
 
               (2.1) 
where 
A  is a finite non-empty set of elements called nodes or vertices of the 
graph 
R  is a binary relation on A, which can be empty. 
As explained in Section 1.2, binary relation R determines a set of ordered pairs 
chosen from nodes in set A. Definition 2.1 allows for isolated nodes in a graph. 
The representation of a mathematical graph based on a set-theoretic way 
according to Definition 2.1 can be equivalently substituted or transformed into a 
true graphical form. Let us call it the drawn graphical form. In this form to each 
node corresponds a circle drawn in a plane and to each element of the relation 
corresponds an arrow or directed arc. For example, a graph given by 
 
{
}
(
) (
) (
) (
) (
)
{
}
(
)
4
4
2
4
2
3
4
1
3
1
4
3
2
1
,
,
,
,
,
,
,
,
,
,
,
,
,
A
A
A
A
A
A
A
A
A
A
A
A
A
A
G =
 (2.2) 
is equivalently represented in a drawn graphical form as shown in Figure 2.1.  
Each circle has its individuality and corresponds to one node. Even if the 
circles are not denoted with symbols, the drawn graphical form is fully isomorphic 
with that of Equation (2.2). Of course, it is cumbersome to refer to the left-upper or 
right-lower circle, etc. Therefore, it is convenient and usual to denote the node-
circle correspondence as in Figure 2.2. For short we call a simple non-labeled 
directed graph a non-labeled digraph. Obviously a non-labeled digraph G has a 

24 
Modeling and Control of Discrete-event Dynamic Systems 
close connection with relation R. It can be said that a non-labeled digraph 
represents the corresponding binary relation. The bipartite simple non-labeled 
directed mathematical graphs constitute a special subset of the non-labeled 
digraphs. They are characterized by a set of nodes consisting of two disjunctive 
node subsets and directed arcs connecting only nodes from the different node sets. 
To distinguish the two node subsets graphically, circles and bars or boxes are 
usually used to represent them, respectively (see Petri nets in Chapter 7). 
 
 
Figure 2.1. Graphical form of a mathematical graph 
 
1
A
3A
2
A
4
A
 
Figure 2.2. Specification of the correspondence node-circle 
Many graph properties of digraphs can be analyzed by analogy with non-directed 
graphs. Non-directed graphs are defined as 
(
)
M
A
G
,
=
 where M is a set of non-
ordered pairs of graph nodes. In the drawn-graphical form the non-directed edges 
are used instead of directed arcs. 
2.2 Labeled Mathematical Graphs 
Definition 2.1 can be further developed as follows. 
Definition 2.2. A simple labeled directed mathematical graph is a 6-tuple 
 
(
)
2
1
2
1
,
,
,
,
,
S
S
f
f
R
A
G =
  
   (2.3) 
where 
A is a finite set of the nodes; 
R is a relation on A, which can be empty; 

 
Graphs in Modeling DEDS 
25 
1f  is a function 
1
S
A →
defined if S1 is defined;  
2f  is a function 
2
S
R →
 defined if S2 is defined; and 
S1 and S2 are sets that can be empty. 
If both sets S1 and S2 are empty, the graph in Definition 2.2 becomes a simple non-
labeled digraph. 
The labels can denote, e.g., the arc weights given as integers. In Figure 2.3 
there is an example when 
∅
=
1
S
 (the empty set) and 
+
= N
S 2
(the set of positive 
integers). 
 
1
A
3
A
2
A
4
A
2 
3 
1 
1 
2 
 
Figure 2.3. A labeled digraph 
Commonly, the non-labeled and labeled digraphs are called digraphs. In this 
context, bipartite simple labeled directed mathematical graphs are also defined. We 
will see later that Petri nets belong to that kind of mathematical graphs. 
There are several ways to represent mathematical graphs equivalently. One 
frequently used is the incidence matrix. For instance the graph in Figure 2.2 can be 
equivalently represented by the following incidence matrix: 
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
1
0
1
0
0
0
1
0
0
0
0
0
1
1
0
0
G
              
 (2.4) 
In matrix G, its rows and columns correspond to the nodes such that the first row 
and first column correspond to node 
1A , the second row and second column to 
2
A , 
etc. In the matrix form, directions of arcs are considered from rows to columns. If a 
directed arc is present in the graph, the corresponding matrix element equals one, 
otherwise zero. 
2.3 Subgraphs and Components 
Subgraphs and graph components defined below play an important role in our next 
considerations.  

26 
Modeling and Control of Discrete-event Dynamic Systems 
Definition 2.3. Consider a digraph 
(
)
2
1
2
1
,
,
,
,
,
S
S
f
f
R
A
G =
. Then: 
1. A digraph 
(
)
2
1
2
1
,
,'
,'
,'
,'
'
S
S
f
f
R
A
G =
 is a subdigraph of G if 
a. 
A
A ⊆
'
 
b. 
(
)'
'
'
A
A
R
R
×
∩
=
 
c. 
( )
( )
'
for 
'
such that 
,
'
:'
1
1
1
1
A
a
a
f
a
f
S
A
f
∈
=
→
 
d. 
( )
( )
'
for 
'
such that 
,
'
:'
2
2
2
2
R
r
r
f
r
f
S
R
f
∈
=
→
 
The graph G is also a subdigraph of itself, i.e., 
G
G =
'
. 
2. If 
'
G  is a subdigraph of G and 
G
G ≠
'
, then 
'
G  is a proper subdigraph of 
G. 
3. A digraph 
(
)
2
1
2
1
,
,'
,'
,'
,'
'
S
S
f
f
R
A
G =
 is a partial subdigraph of G if 
a. Item c. and d. are the same as item 1a, c and d.  
b. 
(
)'
'
'
A
A
R
R
×
∩
⊂
 but 
(
)'
'
'
A
A
R
R
×
∩
≠
 
A subdigraph can be non-labeled or labeled, depending on the digraph for which it 
has been constructed. Figure 2.4 illustrates the subdigraph idea. 
 
1
A
2
A
4
A
 
Figure 2.4. A proper subdigraph of the digraph in Figure 2.2 
The digraph in Figure 2.4 is a proper subdigraph of the digraph in Figure 2.2. The 
set of nodes of the proper subdigraph is a proper subset 
 
{
}
{
}
4
3
2
1
4
2
1
,
,
,
,
,
A
A
A
A
A
A
A
⊂
 
and all arcs not connecting the nodes of 
'A  are canceled. 
 
1
A
2
A
4
A
 
Figure 2.5. A partial subdigraph of the graph in Figure 2.2 

 
Graphs in Modeling DEDS 
27 
On the other hand the digraph in Figure 2.5 is a partial subdigraph of that in Figure 
2.2 because arc (
)
4
4, A
A
 has been omitted. 
2.4 Directed Paths 
The notion of a directed path is useful later in this book. We deal with it in the 
sequel. 
Definition 2.4. Consider a digraph 
(
)
2
1
2
1
,
,
,
,
,
S
S
f
f
R
A
G =
. A sequence of nodes 
 
ni
i
i
a
a
a
a
...
~
2
1
=
 
 (2.5) 
is called a path from 
1ia  to 
nia  in G if 
1. 
A
a
ki ∈
 for all 
n
k
,...,
2,1
=
 
2. (
)
1
+
k
k
i
i
a
R
a
 or (
)
k
k
i
i
a
R
a
1
+
 holds for all 
1
,...,
2,1
−
=
n
k
, i.e., 
kia
 is in 
relation R with 
1
+
kia
. In other words, there is an arc either from 
kia  to 
1
+
kia
 
or from 
1
+
kia
 to 
kia . We say that path a~  goes from 
1ia  to 
nia . 
A path can be non-labeled or labeled, depending on the respective digraph 
property. 
Definition 2.5. If there is a path of the form of Equation (2.5) in a given digraph 
(
)
2
1
2
1
,
,
,
,
,
S
S
f
f
R
A
G =
 and 
1. If for all 
1
,...,
2,1
−
=
n
k
 either (
)
1
+
k
k
i
i
a
R
a
 or (
)
k
k
i
i
a
R
a
1
+
 holds, a~  is called 
a directed path 
2. If  
ni
i
a
a =
1
, then a~  is called a cycle 
3. If  a~  is a directed path and 
ni
i
a
a =
1
 the path is called a directed cycle 
(cycle for short when no confusion arises) 
4. If  all nodes in a~  are distinct except for 
1ia and 
nia , then a~  is called a 
simple path. In other words, no node repeats in the path. The idea of 
simplicity can be applied to directed paths and directed cycles to obtain 
directed simple paths and directed simple cycles, respectively. 
Definition 2.6. A digraph 
(
)
R
A
G
,
=
 is called connected if for every two nodes 
A
a
a
j
i
∈
,
 there is a path from 
ia  to 
j
a . G is strongly connected if there are 
directed paths from 
ia  to 
j
a and from 
j
a  to 
ia . 

28 
Modeling and Control of Discrete-event Dynamic Systems 
Connected digraphs have neither isolated nodes nor isolated groups of nodes. 
The notion of a digraph component is based on the graph connectivity dealt with in 
the following definition. 
 
Definition 2.7. A strong component of a digraph G is a strongly connected 
subdigraph of G, which is not a proper subdigraph of any strongly connected 
subdigraph of G. 
The meaning of the last definition is illustrated using the example in Figure 
2.6.a. There are two strong components of the digraph depicted in Figures 2.6.b 
and 2.6.c. A strong component is a maximum strongly connected subdigraph, i.e., 
not contained in any other strongly connected digraph. Hence, the subdigraph 
depicted in Figure 2.6.d is not a strong component. In particular, it is a proper 
subdigraph of the connected subdigraph in Figure 2.6.b and this fact is 
contradictory to the assumption of Definition 2.7. 
Sometimes it is useful to express the multiplicity of arcs in a digraph. This can 
be done by introducing a weight function over relation R as shown below. Another 
method is to use the multiset concept. A multiset allows multiple same members. 
For example X={(A1, A2), (A1, A2), (A1, A2), (A2, A3), (A3, A3), (A3, A1), (A3, A1)} is a 
multiset example in which (A1, A2) appears three times and (A3, A1) twice in the 
multiset X. 
1
A
2
A
3
A
4
A
5
A
a. 
5
A
b. 
c. 
d. 
4
A
3
A
1
A
2
A
 
2
A
1
A
 
Figure 2.6a-d. A digraph (a) and its strong components: (b, c) while its subdigraph (d) is 
not its strong component 
Definition 2.8. A directed multigraph is a triple: 
 
(
)
f
R
A
G
,
,
=
 
     (2.6) 
where A and R are the same as in Definition 2.1 and f is a function 
+
→N
R
f :
.  

 
Graphs in Modeling DEDS 
29 
A multigraph in the drawn-graphical form can be equivalently represented as 
those in Figures 2.7 and 2.8. Note that label 1 on an arc can be omitted. Function f 
is given as follows: 
(
)
(
)
(
)
(
)
2
,
,1
,
,1
,
,3
,
1
3
3
3
3
2
2
1
=
=
=
=
A
A
f
A
A
f
A
A
f
A
A
f
 
Figure 2.7. A multigraph 
Figure 2.8. Labeling of arcs in a digraph 
An important group of connected digraphs are trees. A tree is a non-labeled 
digraph with the following properties: it has exactly one node (root) with no in-
going arcs and all other nodes have exactly one in-going arc. Obviously, a tree 
does not contain cycles. 
2.5 Problems and Exercises 
2.1. Let x1-4 be your last four digits in your identification number, respectively. Let 
gi=sign(xi), i=1, 2, 3 and 4. For example, sign(0)=0 and sign(7)=1. Let fi=1-gi. 
Present the graphical representation of the following digraph given the below 
matrix; and identify its strong component(s) if any:  
 A1
A2
A3
e1
e2
e3
e4
e6
e7
e5
A1
A2
A3
3
1
1
2

30 
Modeling and Control of Discrete-event Dynamic Systems 
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
4
3
2
1
4
3
2
1
4
3
2
1
4
3
2
1
f
f
f
f
g
g
g
g
f
f
f
f
g
g
g
g
G
 
2.2. Prove that the rank of the incidence matrix of any connected tree cannot be full. 
2.3. A part of a town street map is given in Figure 2.9. 
 
Figure 2.9. A part of the street system in a town 
Represent the street system in Figure 2.9 with a directed graph. Find a subdigraph 
representing possible connections between Main Street and Main Railway Station. 
Find a strong component of the digraph. Find all simple paths connecting Main 
Street and Highway. Give some labels to the digraph corresponding to distances 
and find a shortest path from Main Railway Station to Main Street.  
2.4. Given five instructors A1–A5, and five courses C1–C5 to be taught, use a 
circle to represent an instructor and a box a course. Connect a solid line from an 
instructor to a course if the instructor is assigned to teach it and a dotted line 
meaning that the instructor can teach it if needed. Suppose that each instructor is 
familiar with two and only two course materials (hence can teach at most two 
courses). Given Figure 2.10a, b, please derive which one can better cover 
instruction if an emergency happens such that one instructor cannot come. If an 
instructor is assigned to teach a course and can teach at most two courses, how 
many courses must s/he be able to teach if any one instructor has an emergency? 
How about if any two instructors have an emergency? Assume that these five 
courses are offered Monday through Friday, respectively. 
Main Street 
Main Railway 
Station 
Highway 

 
Graphs in Modeling DEDS 
31 
Figure 2.10a, b. Graph showing who are teaching courses and capable of teaching 
additional courses 
A1
A2
A3
A4
A5
C1
C2
C3
C4
C5
a.
A1
A2
A3
A4
A5
C1
C2
C3
C4
C5
b.
 

3 
Formal Languages 
3.1 Notion of the Formal Language 
We will follow the way of reasoning developed in the preceding chapters. Consider 
an event set 
{
}
ne
e
e
,...,
,
2
1
=
Σ
 given for a DEDS. Further consider it to be in an 
initial state 
0
q . The system behavior can be defined by all possible sequences 
(strings or words) of events that can occur in it starting from 
0
q . It is assumed that 
an event occurs in a discrete point of time. Further it is assumed that just one event 
occurs in one discrete time point. The set of all finite and infinite sequences, which 
can be created from the elements of Σ  including the empty sequence ε~ , is 
denoted as 
*
Σ . The set that does not include ε~  is denoted as 
+
Σ , i.e., 
ε~
\
*
Σ
=
Σ +
 
where symbol “ \ ”  stands for the set subtraction.  
Usually only a part L of all possible sequences 
*
Σ  can occur in a given DEDS. 
Such a particular behavior of the DEDS is due to a subset L  of sequences from 
*
Σ , 
i.e., 
*
Σ
⊆
L
. L  is supposed always to include the empty sequence (string, word) 
and is called a formal language. The formal language L  defines the behavior of a 
DEDS. Our attention is aimed at formal languages with respect to the above-
introduced interpretation related to DEDS. A formal definition is useful in order to 
exactly communicate the idea of a formal language. 
Definition 3.1. Let a finite non-empty set of events 
{
}
ne
e
e
,...,
,
2
1
=
Σ
 be given. The 
formal language L  over Σ  is a set of sequences formed from the events including 
the empty sequence ε~ . Σ  is called the alphabet of the formal language. A 
sequence of L  is also called a string or word. 
From Definition 3.1 it follows that the empty string ε~  always belongs to a 
formal language.  

34 
Modeling and Control of Discrete-event Dynamic Systems 
Definition 3.2. The length of a word (string) α  denoted  α  is the number of 
events in the word. The length of the empty string is 0. 
Example 3.1. Consider an alphabet 
{
}
β
α,
=
Σ
. A formal language 
1L  is given by 
 
{
}
βα
ββ
αβ
αα
β
α
ε
,
,
,
,
,
,
~
1 =
L
 
(3.1) 
Language 
1L  can verbally be determined as a set of all strings over Σ  whose 
lengths do not exceed 2, including the empty string. It is finite.  
Example 3.2. Consider the same alphabet as in Example 3.1. Let a language 
2
L  
consist of all strings beginning with some event β . It is expressed as 
 
{
}
,...
,
,
...
,
,
,
,
~
2
ββαα
ββα
α
βαα
βαα
βα
β
ε
=
L
   
(3.2) 
This set obviously has an infinite number of members. 
We will focus on how a formal language can be utilized for the description, 
analysis and synthesis of DEDS. An important assumption is that only one event 
can occur at one discrete time point. Time is not explicitly given for a formal 
language string. However, the order of events is specified. The connection of a 
formal language string with a discrete process as described in Section 1.3 can 
easily be recognized. 
Example 3.2 shows that even in very simple cases it is impossible to put down 
all strings of a formal language. The example also illustrates that the language 
specification is some rule or rules for the creation of strings. Such kinds of rules 
are called formal grammars. 
3.2 Formal Grammars and Classification of Formal Languages 
Any formal language can be defined by a generation rule of its words. The rules for 
generating them, called formal grammar, are described below.  
Definition 3.3. A formal grammar is formally defined by the quadruple  
 
(
)s
P
V
V
G
T
N
,
,
,
=
 
(3.3) 
where 
N
V  is a finite set of non-terminal elements  
T
V  is a finite set of terminal elements whereby 
∅
=
∩
T
N
V
V
; the union 
T
N
V
V
V
∪
=
 is called the alphabet and its elements are called symbols 

 
Formal Languages 
35 
P  is a finite set of rules 
{
}
kP
P
P
P
,...,
,
2
1
=
 for generating words. The 
generating rule has the form 
*
~
,
~
,
~
~
V
V
G
∈
∈
+
β
α
β
α a
, 
ε~
\
*
V
V
=
+
, 
where the symbol 
Ga  indicates that a word transformation is accomplished 
using the generating rule belonging to grammar G  
s  is a special non-terminal one in 
N
V  called initial element or symbol. 
The fact that the left hand side word of a generating rule is 
+
∈V
α~
 means that 
α~  cannot be an empty word (string). On the other hand, a word 
*
~
V
∈
β
 can be an 
empty one. In other words, an empty string ε~ cannot be mapped into a string but 
there can exist a production rule mapping a non-empty word into an empty one. 
The word generating rules are used for formal language generation. A formal 
language L  generated by a formal grammar G  is a set of all words, which consists 
of the words containing only terminal elements of the given grammar and are 
generated by the repeated application of one or more rules, always beginning at the 
initial element s . Next words are generated from already created words. Rules can 
be applied also on a word part. Their application is formally described by the 
scheme 
 
ν
β
μ
ν
α
μ
~
~
~
~
~
~
Ga
 
(3.4) 
where
,
~
,
~
*
*
V
V
∈
∈
ν
μ
 and as stated before 
*
~
,
~
V
V
∈
∈
+ β
α
 and 
β
α
~
~
G→
. The 
process starts with s , i.e., 
ε
ν
ε
μ
~
~
 
and
~
~
=
=
. It continues with the new generated 
words according to Equation (3.4). As already mentioned, a part of word can be 
transformed into another. If 
ε
ν
μ
~
~
~
=
=
, the whole word is being transformed into 
another one. The word generation can be considered as a replacement rule. The 
generation sequence formally proceeds as 
 
  
~
~
~
~
~
~
,....
~
~
~
~
~
~
    
where
~
~
~
~
~
~
,...,
~
~
~
~
~
~
,
~
~
~
~
~
~
~
~
~
~
~
,...,
~
~
~
~
~
~
    
where
~
~
~
~
~
~
...,
,
~
~
~
~
~
~
,
~
~
~
~
~
2
2
2
1
,2
,1
,2
1
,2
22
22
22
21
21
21
2
2
2
2
2
2
22
22
22
22
22
22
21
21
21
21
21
1
1
1
12
,1
,1
1
,1
12
12
12
11
11
11
1
1
1
1
1
1
12
12
12
12
12
12
11
11
11
11
11
n
na
n
n
b
n
n
a
b
n
nb
n
G
n
na
n
b
G
a
b
G
m
ma
m
b
m
m
a
b
m
mb
m
G
m
ma
m
b
G
a
b
G
s
s
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
φ
μ
ν
μ
=
=
=
=
−
−
−
−
−
a
a
a
a
a
a
 
 
 
(3.5) 
In Equation (3.5) 
ε
ν
μ
ν
μ
~
.......
~
~
~
~
21
21
11
11
=
=
=
=
=
 because each generation process 
starts with symbol s.  Consider the first row in Equation (3.5). The final word in 
the row, which closes the particular generation process, is a word for which there is 
no continuation of the generation process. The second generation process starts 
again in s. If the sequences starting in s are exhausted, the next possible generation 
processes start with the words generated in the previous generation ones. If 
2
~α  is 

36 
Modeling and Control of Discrete-event Dynamic Systems 
generated from 
1~α  by the repetitive application of grammar G, a generation 
sequence can be briefly written as 
 
2
1
~
~
α
α
∗
Ga
 
(3.6) 
where symbol * denotes the repeated word generation, and G denotes the used 
formal grammar. For the first sequence in Equation (3.5) we have 
 
m
mb
m
G
s
1
1
1
~
~
~
ν
φ
μ
∗
a
 
 (3.7) 
A language L  consists of words that are generated by a given formal grammar 
in a described way and contains only terminal elements of the given alphabet Σ . If, 
e.g., 
m
mb
m
1
1
1
~
~
~
ν
φ
μ
 consists only of terminal elements (of 
T
V ), then 
L
m
mb
m
∈
1
1
1
~
~
~
ν
φ
μ
. 
Example 3.3. Let a language L  be generated by the following formal grammar: 
(
)s
P
V
V
G
T
N
,
,
,
=
, 
{
}
B
A
s
VN
,
,
=
, 
{ }
1,0
=
T
V
,  
 
{
}
1
,
0
,
1
,
0
a
a
a
a
A
A
B
B
A
A
s
P =
 
(3.8) 
s  is the initial symbol. 
The only rule containing s  is 
A
s
G 0
a
 and thus the first generation step (the 
first word generation) should be 
A
s
G 0
a
. The word 
A
0
 does not belong to 
language L  generated by grammar G  because in the word there is a non-terminal 
symbol A . Thus two rules can be applied to word A
0
: 
 
01
0
G
Aa
       
(3.9) 
where rule 
1
G
Aa  has been used or 
 
B
A
G 01
0
a
       
(3.10) 
where rule 
B
A
G 1
a
 has been used. 
Because the word from Equation (3.9) consists only of terminal symbols, the 
generation Equation (3.9) yields a word belonging to language L , while the 
generation Equation (3.10) does not. In the next step we have 
 
A
B
G 010
01 a
 
 (3.11) 

 
Formal Languages 
37 
which is a similar situation to before, i.e., either 
 
0101
010
G
Aa
 
(3.12) 
or 
 
B
A
G 0101
010
a
      
 (3.13) 
We can write 
0101
∗
G
s a
. Continuing in this way we obtain the infinite set of 
words belonging to language L : 
 
{
}
......
,
01010101
,
010101
,
0101
,
01
=
L
   
(3.14) 
The formal grammar as defined in Equation (3.4) is the most general one. It is 
called a type 0 grammar and the corresponding generated language is called a type 
0 language. If the generation rules in the type 0 grammar are restricted, various 
grammars are obtained. They can be classified as type 0 or unrestricted grammar, 
type 1 or context grammar, type 2 or context-free grammar, and type 3 or regular 
grammar. Correspondingly, there are type 0 or unrestricted, type 1 or context, type 
2 or context-free, and type 3 or regular languages. The regular grammar is of the 
first-rate interest in DEDS.  
The regular grammar has the generation rules in the form 
 
aB
A
Ga
  or   
a
A
Ga
 
  (3.15) 
where  
N
V
B
A
∈
,
 and 
T
V
a∈
. 
The grammar given in Example 3.3 is regular and thus generates a regular 
language. According to the type definition, the set of languages with a lower type 
number contains all languages of a higher one. Hence, their set inclusion property 
is given: 
Type 3 language ⊂ Type 2 language  ⊂ Type 1 language  ⊂ Type 0 language 
i.e., 
Regular language ⊂ Context-free language  ⊂ Context language  ⊂ 
Unrestricted language 
A formal grammar determines the corresponding language in a generative way. 
A different approach to specifying a formal language is the recognition way. The 
idea underlying this approach consists in finding an abstract model that can 
recognize whether a string over an alphabet belongs to a given language or not. For 
each language type a model can be constructed capable of recognizing the 
language. A finite automaton is such a model for the set of regular languages (type 
3). The next larger set of formal languages, the context-free languages, can be 
recognized by push-down automata, etc. In this sense, a recognizing model is a 
specification tool for a formal language being recognized. Recognizing models are 

38 
Modeling and Control of Discrete-event Dynamic Systems 
built up as the finite-state machines. In a recognizing model, the symbols of a 
processed string are fed into the model being in some state. The model passes a 
sequence of states and finishes in a state that determines whether the string belongs 
to the formal language specified by the model. 
Moreover, a recognizing model can generate the represented language in a 
different way to that of a formal grammar. The generation in this case is based 
upon the basic transition model described in Section 1.5. The states and allowed 
transitions among the states are used for the generation of the language words.  
In this book we focus on the topics related to regular languages, as they are the 
most important for modeling and control of DEDS. For this type of the languages it 
is necessary to know the finite automata, which serve as recognizing models for 
regular languages. 
3.3 Regular Expressions 
Regular languages can be well specified using regular expressions. The adjective 
“regular” stresses a provable fact that for each regular language there is a regular 
expression that specifies it and vice versa.  
Definition 3.4. Regular expressions over a finite set Σ  are recursively defined as: 
a. The symbol for the empty set ∅ is a regular expression; 
b. The symbol for the empty element of the set Σ (if included in Σ ) is a 
regular expression; 
c. The symbol of any element of Σ  is a regular expression, i.e., if 
Σ
∈
a
, then 
a is a regular expression; 
d. If r and s are regular expressions, so are 
,
,
rs
s
r ∪
 and 
∗r  where ∪ 
means the set union, rs  is the concatenation of strings or the sets of strings, 
and 
∗r  is the iteration of a string or a set.  
Three operations in Definition 3.4(d), i.e., union, concatenation and iteration 
can be applied on strings or sets. Consider the strings 
 
m
n
r
r
r
r
s
s
s
s
...
~
,
...
~
2
1
2
1
=
=
      
       (3.16)  
The concatenation of strings r~  and s~  is string 
n
m
s
s
s
r
r
r
s
r
c
...
...
~
~
~
2
1
2
1
=
=
. If  S 
and R are the sets of strings (denote them for better clarity as R and S) the 
concatenation 
{
}
S
s
R
r
s
r
RS
∈
∈
=
~
,
~
~
~
 is the set of concatenated strings from the 
sets R and S. The iteration or Kleene closure is  
 
U
∞
=
∗=
0
~
~
i
i
r
r
 
(3.17) 
where r~  is a string and 

 
Formal Languages 
39 
 
ε~
~ 0 =
r
  is the empty string    
 
r
r
~
~1 =
 
 
r
r
r
~
~
~ 2 =
 
 
… 
 
 times)
(
~.
..........
~
~
~
k
r
r
r
r
k =
   
(3.18) 
In Definition 3.4.d, r is supposed to be a regular expression. From the definition 
it follows that it can be a string or a set of strings created in the iterative expansion 
of regular expressions. Consider the case when r is a set of strings. Denote the set 
by R. The Kleene closure is analogously defined as 
 
i
i
R
R
∞
==
=
0
*
U
 
(3.19) 
where 
 
{ }
{
}
...
~
,
~
~
~
:
strings
 
of
 
sets
 
 two
of
ion 
concatanat
 
 the
is
it 
,
2
1
0
R
v
R
u
v
u
RR
RR
R
R
R
R
∈
∈
=
=
=
= ε
 
(3.20) 
Example 3.4. Let a formal language over 
{
}
β
α,
=
Σ
 be given by the regular 
expression 
 
β
αβ ∪
=
∗
L
 
The language consists of the strings 
 
{
}
.....
,
,
,
,
,
,
,
~
αββββ
αβββ
αββ
αβ
α
β
ε
=
L
 
i.e., it contains 
α
β
ε
,
,
~
, and an infinite number of strings beginning withα  and 
including k times symbol β , where 
K
,3,2,1
=
k
 grows to infinity. 

40 
Modeling and Control of Discrete-event Dynamic Systems 
3.4 Problems and Exercises 
3.1. Consider for the manufacturing system depicted in Figure 1.3 the capacities of 
all conveyors to be 1. Specify a formal language representing the behavior of the 
system. 
3.2. Let two languages be given by regular expressions 
∗
= αβ
1
L
 and 
(
)
∗
∪
=
β
α
2
L
.  Determine a language given by the concatenation
2
1L
L
. 
3.3. Let transits between street crossings in Exercise 2.3 define events (the drive 
from the station to the closest crossing and contrariwise are events, too). Specify a 
language, which is given by possible transits of one car starting from Main Street. 
3.4. A robotic cell contains two machines and two robots as shown in Figure 3.2. 
Parts are loaded irregularly and sequentially in the cell by two inputs: the first kind 
by I1 and the second one by I2. Transfer of parts is done by the robots. Machine 
and conveyor capacities are one. The robot R2 transfers the processed parts on the 
conveyor C3 whenever is part ready, order is not important. 
Explain what is a state and an event in the described system. Explain what it is 
a formal language and how it can be represented with regular expressions. Define 
the event set for the system and write several strings of the formal language 
describing the system. 
 
Figure 3.2. Robotic cell with two machines 

4 
Control of DEDS 
4.1 State and Control Variables 
Consider the basic transition system Equation (1.19) by Manna and Pnueli 
described in Section 1.5 as a general model of a DEDS. As pointed out earlier, time 
is not explicitly considered in the model. The DEDS dynamics depends on events 
that appear in discrete time points. The events provoke changes of the system states. 
The relations and mutual influence of events and states with respect to control are 
studied in this chapter. According to that, let a DEDS be given by the event set 
 
{
}
ne
e
e
,...,
,
2
1
=
Σ
 
  (4.1) 
A sample event path of the system is 
 
vi
i
i
e
e
e
e
...
~
2
1
=
 
  (4.2) 
where 
1ie occurs at time point 
1iτ ,
2ie at time point 
2iτ , …, 
vie at 
viτ , 
vi
i
i
τ
τ
τ
〈
〈
〈
...
2
1
. 
We emphasize that just one event can occur in a discrete time point. The path at 
Equation (4.2) starts in the system initial state. Let another sequence of time points 
be determined as  
 
,
2
1
2
1
1
i
i
i
a
τ
τ
τ
τ
−
+
=
 
2
2
3
2
2
i
i
i
a
τ
τ
τ
τ
−
+
=
, …,
2
1
1
1
−
−
−
−
+
=
v
v
v
v
i
i
i
a
τ
τ
τ
τ
 (4.3) 
i.e., time points at Equation (4.3) are in the middle between the time intervals of 
two consecutive events. 
Let the set of state variables be represented by a time-dependent vector variable 

42 
Modeling and Control of Discrete-event Dynamic Systems 
 
( )
( )
( )
( )⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
t
u
t
u
t
u
t
b
M
2
1
u
 
(4.4) 
Assume the vector component 
( )
,
,...,
2,1
,
b
i
t
ui
=
having a value from a finite set 
i
U  of real numbers. The system state dynamics can be expressed by a sequence u~ , 
which is a discrete process 
 
(
) (
)
(
)
1
2
1
1
2
1
...
...
~
−
−
=
=
v
v
a
a
a
a
a
a
u
u
u
u
u
u
u
τ
τ
τ
 
  (4.5) 
where the discrete time points are 
1
2
1
...
−
〈
〈
〈
v
a
a
a
τ
τ
τ
. Changes of variable ( )t
u
 at 
discrete time points are changes of the system states, which correspond to events. 
The state changes occur as responses to events. In real systems the responses are 
delayed some time after points 
vi
i
i
τ
τ
τ
,...,
,
2
1
. Just to come to a conceivable model, 
assume that all responses finish before points 
1
2
1
,...,
,
−
v
a
a
a
τ
τ
τ
 so that new states are 
fully observable in these points.  
We have not yet dealt with the question of how a certain required behavior of 
the system can be achieved. Various system descriptions and models represent the 
given system from the observer point of view. The required and for some purpose 
useful properties and behavior of the system are achieved by the system control 
performed fully automatically or with human participation. In this book we are 
interested in both modeling and control. It is necessary to distinguish between the 
approach aiming at the description of a system as a whole and the approach aiming 
at the control specification. This difference will always be taken into account in the 
next chapters. The control function can be extracted from the required behavior of 
the whole system. 
The system control is enabled through purposeful intervening into the system. 
The interventions are represented by control variables. Assume that they can be 
represented by a vector variable 
( )t
w
. The control variables are time-dependent 
and react to the actual situation in the system with respect to a required system 
behavior. In other words, this is the control. The interventions through the control 
variables correspond to requirements imposed on the system behavior. The degree 
of agreement of the required system behavior with the actual one is judged by a 
relevant criterion specifying the control performance. 
4.2 Control System and Control Function 
From the observer point of view, a system SYST can be represented as one 
including the controlled and control parts as shown in Figure 4.1. The system 
described by the basic transition system at Equation (1.19) can be decomposed  

 
Control of DEDS 
43 
into two subsystems with the feedback structure typical for control: the subsystem 
S to be controlled and the control system C. Figure 4.1 shows the decomposition 
where w~  is a sequence of control variable values given at discrete time points as 
follows: 
 
(
)
(
)
(
)
1
1
2
2
1
1
...
~
−
−
Δ
+
Δ
+
Δ
+
=
v
v
a
a
a
a
a
a
τ
τ
τ
τ
τ
τ
w
w
w
w
 
  (4.6) 
and 
                  
( )
( )
( )
( )⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
t
w
t
w
t
w
t
c
.
.
.
2
1
w
 and  (
)
(
)
(
)
(
)⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
k
k
k
k
a
c
a
a
a
w
w
w
τ
τ
τ
τ
.
.
.
2
1
w
 
(4.7) 
Figure 4.1. Feedback control structure 
Let the value 
( )t
wi
, 
c
i
,...,
2,1
=
, of the vector component be from a finite set 
i
W  
of real numbers. 
State variables of SYST are decomposed in Figure 4.1 into two subsets given 
by s and w. The decomposition model of SYST now distinguishes two subsystems 
S and C. w is input and s output for S, s input and w output for C. 
Very often Equation (4.6) can be simplified considering the assumption that 
 
τ
τ
τ
τ
Δ
=
Δ
=
=
Δ
=
Δ
1
–
2
1
...
va
a
a
 
  (4.8) 
SYST
S
C
s~
 
w~

44 
Modeling and Control of Discrete-event Dynamic Systems 
i.e., the variable values in Equation (4.6) are given in time points delayed with 
respect to 
1
1
−
−
v
a
a
τ
τ
 by a fixed time τ
Δ
 suitable chosen with respect to the system 
dynamics so that 
 
(
)
(
)
(
)
τ
τ
τ
τ
τ
τ
Δ
+
Δ
+
Δ
+
=
−1
2
1
...
~
va
a
a
w
w
w
w
 
  (4.9) 
In order to avoid model complications assume that 
 
v
v
i
a
i
a
i
a
τ
τ
τ
τ
τ
τ
τ
τ
τ
<
Δ
+
<
Δ
+
<
Δ
+
−1
3
2
2
1
M
 
Control of the system S (Figure 4.1) can be described using a vector function 
f in the following way: 
 
(
)
(
) (
)
(
)
(
)
r
k
k
k
k
a
a
a
a
−
−
=
Δ
+
τ
τ
τ
τ
τ
s
s
s
f
w
...,
,
,
1
 
   (4.10) 
where r=0, 1, 2, …, k–1 and 
.1
...,
,2
,1
−
+
+
=
v
r
r
k
 The index r determines the 
depth of the influence of the system history on the control in the actual time point. 
The function f expresses the overall control strategy with respect to control goals. 
Fulfilment of the goals is verified using the control quality criteria. 
 Now, to illustrate our model of the system states, events, and control actions 
Figure 4.2 is used to depict their time development. 
Some of the control actions can be empty. If it is not empty an immediate event 
after control action represents an effect of the control. There can be more 
complicated time relations among the states and events. Our assumptions enable 
one to gain the first view of the DEDS function. 
It is useful to structure the control scheme depicted in Figure 4.1 in order to 
express the relation between the system and its outside objects. Variable (
)
k
a
τ
s
 
from Figure 4.1 is decomposed into the input variable (
)
k
a
τ
x
, output variable 
(
)
k
a
τ
y
 and internal state variable (
)
k
a
τ
z
 as shown in Figure 4.3. 
Classification of the actual system variables in the introduced variable groups 
according to the structure in Figure 4.3 is not strictly and uniquely given for a 
particular system. It depends largely on a control designer. 
Presently, the control systems are predominantly realized by control computers. 
There are various designs or versions. Their main and common feature is the 
possibility to program their operation by a sequence of instructions – a program. 
There are two basic kinds of programs:  
• 
Transformation programs 
• 
Reactive programs 

 
Control of DEDS 
45 
Figure 4.2. Time diagram for states, events and control 
 
S
C
w~
x~
z~
y~
 
Figure 4.3. Input-output control structure 
A transformation program represents a traditional way of computer usage. It 
produces a final data result starting from some initial data through a sequence of 
instruction steps that depend only on the situation and states within the program 
itself. A reactive program has to react to external situation of the system during its 
execution, i.e., to states and changes occurring outside the program. In other words, 
during its execution, a reactive program has to be able to accept and detect external 
variables and external data sources and to produce stimuli for the environment. 
The character of reactive programs exactly matches the function of control 
systems as described above. A reactive program realizes a control function 
according to Equation (4.10) by processing the system variable (
)
k
a
τ
s
 in course of 
time and producing the control actions generated by the computer realizing the 
control program.  
Using the above level of abstraction we have not treated technical details on 
how reactive programs are implemented in a control system. There are many ways 
that external variables can be detected and data conveyed into the control system or 
1ie
 
2ie
 
3ie
2
−
vie
1
−
vie
vie
1iτ
2iτ
3iτ
2
−
viτ
1
−
viτ
viτ
 
1as
 
2
as
2
−
v
as
 
1
−
v
as
1a
τ
 
2
a
τ
 
2
−
va
τ
 
1
−
va
τ
(
)
τ
τ
Δ
+
1a
w
(
)
τ
τ
Δ
+
2
a
w
(
)
τ
τ
Δ
+
−2
va
w
(
)
τ
τ
Δ
+
−1
va
w
time  

46 
Modeling and Control of Discrete-event Dynamic Systems 
from it into the system to be controlled. There are basically two ways that the 
system reaction can be realized: using interrupts or sampling of external variables. 
As we mentioned before there are various control system technical forms. A form 
very often used in practice is a programmable logic controller. It is constructed as a 
modular input-output system for a reliable and robust realization of control 
functions in industrial environments.  
In the control system design it is first necessary to know and to be able to 
specify the required behavior of the controlled system. It is reasonable to use an 
appropriate and formally well-elaborated specification tool. Second, it is necessary 
to specify and analyze the control function again using a suitable specification tool. 
Third, it is to write, implement and verify the correct final control program.  
In this context it is important to emphasize the difference between 
specifications of the whole system denoted as SYST (Figure 4.1) and the function 
of the control part C. The same tool can be used for both cases. However, 
describing the whole system first seems to be natural and facilitating the control 
design. 
 A flow diagram is a conventional type of program specification used prior to 
final program writing. However, flow diagrams are insufficient for the 
specification of the reactive programs. One of the aims of this book is to present 
more effective and suitable specification means for the design of the DEDS control 
realized through the reactive programs. 
4.3 Problems and Exercises 
4.1. Determine the function (
)
τ
τ
Δ
+
k
a
w
 given by the expression (4.10) for the 
case of deterministic finite automata. 
Figure 4.4. Figure for Problem 4.2 
4.2. Given a tank as shown in Figure 4.4, determine controlled part, control, and a 
control strategy such that the tank maintains at the average level as much as 
possible. The sensory system can detect whether the current level is at Min, Low, 
Average, High, and Max levels, and whether the outlet valve is off and on (either 
Control 
Valve 
Outlet 
Valve 
Max 
 
High 
 
Average 
 
Low 
 
Min 

 
Control of DEDS 
47 
high or low flow rate). The control on the inlet valve can be controlled so that it is 
off and on (high, average, and low). 
4.3. Analyze the relation of the basic transition system in Section 5.1 with the 
model of the system control described using discrete processes according the input-
output control structure in Figure 4.3. 

5 
Finite Automata 
 
5.1 Basic Definitions 
Finite automata are a classical tool used for many years for DEDS modeling. A 
finite automaton incorporates both principal system features - system states and 
system transitions in an abstract form. The basic definition of a finite automaton is 
given in the sequel. 
Definition 5.1. The deterministic finite automaton (DFA) is a quintuple 
 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 
(5.1)  
where 
Σ  is a nonempty finite set of events, 
Q is a nonempty finite set of elements called states, 
Q
q ∈
0
 is an initial (or start) state, 
δ  is a state transition partial function given by 
Q
Q
→
Σ
×
:
δ
, where the 
Cartesian product ×  means  that an ordered pair of elements from Q and 
Σ  is mapped into an element of set Q, and the term “partial function” 
means that the function δ  may not be defined for all ordered pairs that can 
be created of the sets Q and Σ , and 
F is a set of final states given as a subset of Q: 
Q
F ⊆
, where F can be the 
empty set. 
There are several modifications of the deterministic finite automaton definition. 
The definition given above is useful in the context of formal languages because a 
deterministic finite automaton can serve as a formal language generator or acceptor. 
Let a deterministic finite automaton
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 be given where 
{
}
ne
e
e
,...,
,
2
1
=
Σ
and 
{
}
m
q
q
q
Q
,...,
,
1
0
=
. Consider sequences of state transitions, 
which always start in the initial state 
0
q  and the sequential states are obtained by 

50 
Modeling and Control of Discrete-event Dynamic Systems 
repeatedly applying the function δ  to stepwise generated states. The sequence of 
state transitions is given by 
 
(
)
(
)
(
)
k
k
k
j
i
j
j
i
j
j
i
q
e
q
q
e
q
q
e
q
=
=
=
−,
,
.....
,
,
,
,
1
2
2
1
1
1
0
δ
δ
δ
 
(5.2) 
where  
kj
j
q
q
q
,
...
,
,
1
0
 are states, i.e., 
Q
q
Q
q
Q
q
kj
j
∈
∈
∈
,
...
,
,
1
0
, and the function 
δ  is defined for each pair (state, event) in Equation (5.2). A sequence  
 
kj
j
j
q
q
q
q
...
~
2
1
0
=
ω
 
(5.3) 
for which each part of  Equation (5.2) is fulfilled is called the state path in DFA 
associated with the event string 
ki
i
i
e
e
e
...
~
2
1
=
η
. The state path in DFA is oriented. 
The length (symbol “
” ) of the state path is 
k
=
ω~
. There can be several 
different sequences in a given DFA starting with the same element. A singular case 
would occur if (
)
ie
q ,
0
δ
 is not defined for any element of Σ . 
The sequence 
 
ki
i
i
e
e
e
...
~
2
1
=
η
 
(5.4)  
associated with the state path at Equation (5.3), for which each partial expression 
in Equation (5.2) holds is called an event path in DFA. Hence, each event path 
starts with an event applied in the initial state 
0
q . Now, it is possible to proceed to 
the definition of the formal language generator. 
Definition 5.2. A deterministic finite automaton given by a quintuple 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 is called a generator of the formal language L over the 
alphabet Σ , whereby the language is given by the set of all possible event paths 
ki
i
i
e
e
e
...
~
2
1
=
η
 in the DFA, and a generator of the marked language 
m
L , where 
m
L  is a set of all possible event paths whose last  element of the state path 
kj
j
j
q
q
q
q
...
~
2
1
0
=
ω
, associated with η~ , is from the set F . Formally, L is a set of 
strings η~ : 
 
(
)
{
}
defined
 
is
,
ˆ
~
0 η
δ
η
q
L =
 
(5.5) 
where δˆ  is an extended partial transition function 
Q
Q →
×
Σ*
:
ˆδ
 obtained from 
the transition function δ  defined by 
 
(
)
string
empty 
 
 the
is
~
,
,
~
,
ˆ
ε
ε
δ
Q
q
q
q
∈
=
 
(5.6) 

 
Finite Automata 
51 
 
(
)
k
k
i
i
i
j
e
e
e
q
q
...
~
,
~
,
ˆ
2
1
=
=
η
η
δ
 
(5.7) 
and 
 
(
)
(
)
1
1
1
,
 
and
 
defined
 
is
,
j
i
i
q
e
q
e
q
=
δ
δ
 
(5.8) 
 
(
)
(
)
2
2
1
2
1
,
 
and
 
defined
 
is
,
j
i
j
i
j
q
e
q
e
q
=
δ
δ
 
(5.9) 
 
… 
 
(
)
(
)
k
k
k
k
k
j
i
j
i
j
q
e
q
e
q
=
−
−
,
 
and
 
defined
 
is
,
1
1
δ
δ
 
(5.10) 
For the marked language 
m
L , the ending state 
F
q
kj ∈
.  
From Definition 5.1 it follows that a finite automaton is a simple labeled 
directed graph denoted for short in Chapter 2 as a digraph. Recalling Definition 2.2 
we can see that the set of states corresponds to the set of graph nodes: 
Q
A =
. 
Relation R is given recursively by the function δ  starting from the initial state 
0
q . 
Function δ  determines the next node 
b
q  by applying the input 
ie  to the actual 
node 
a
q , i.e., 
(
)
i
a
b
e
q
q
,
δ
=
. Thus, the function δ  yields ordered pairs of states 
constituting the graph relation. It is used to be given by the state transition table 
(see the following example). An oriented arc corresponds to (
)
b
a q
q ,
 with label 
ie , 
i.e.,
∅
=
1f
 and 
Σ
→
R
f :
2
. Any finite automaton can be represented in a drawn 
graphical form. 
Example 5.1. A deterministic finite automaton 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 is given by 
 
{
}
(
)
{
}
{
}
(
)
(
)
1
2
2
1
2
1
0
2
1
0
0,
1,
,
,
0,
1,0
q
q
q
q
q
q
q
Q
q
F
q
q
=
=
=
=
=
=
Σ
δ
δ
δ
 
This automaton generates a marked language equal to the one from Example 
3.3, namely 
{
}
,.....
010101
,
0101
,
01
,
~ε
=
L
. It is better understood from the 
drawn-graphical automaton form in Figure 5.1. 
 
q0 
q1
q2
0 
0 
1 
 
Figure 5.1. Finite automaton generating a language 

52 
Modeling and Control of Discrete-event Dynamic Systems 
5.2 Description of the System Behavior Using Finite Automata 
Application of finite automata for describing the system behavior will be illustrated 
through the following example. 
Example 5.2. Consider a flexible manufacturing system depicted in Figure 5.2. It 
consists of two input and one output conveyors, a servicing robot and a processing-
assembling center. Workpieces to be processed come irregularly in a one-after-
another sequence into the system. The workpieces of type A are delivered via 
conveyor C1 and workpieces of type B via conveyor C2. Only one workpiece can 
be on the input conveyor. A robot R transfers workpieces one by one into the 
processing center M. The next workpiece can be put on the input conveyor when it 
has been emptied by the robot. The production technology requires that first one A-
workpiece is inserted into M and processed, then one B-workpiece is added into 
the center M, and last both workpieces are assembled. Afterwards, the assembled 
product is picked up by the robot and put on the output conveyor C3. The 
assembled product can be transferred onto C3 only when the output conveyor is 
empty and ready to receive the next product. The finite automaton describing 
behavior of the flexible manufacturing system is in Figure 5.3. Following 
Definition 5.1 we have 
 
{
}
ABN
ABO
BM
AM
T
T
T
T
IB
IA
,
,
,
,
,
=
Σ
 
(5.11) 
where 
IA denotes input of a workpiece A to conveyor C1, 
IB denotes input of a workpiece B to conveyor C2, 
AM
T
 represents transfer of workpiece A into machine M by using robot R, 
BM
T
 represents analogously for a workpiece B, 
ABO
T
 represents transfer of the product AB assembled of A and B from 
machine M onto output conveyor C3 by robot R, and 
ABN
T
 represents transfer of the product AB from conveyor C3 out of the 
manufacturing cell, i.e., emptying the output conveyor. 
The automaton states are 
 
{
}
23
2
1
0
...,
,
,
,
q
q
q
q
Q =
 
where 
0
q  is the initial state depicted in Figure 5.3 by a double circle. For final 
states we have F = Q. 
The transition function δ  is specified by a graph representation of the 
automaton in Figure 5.3. The table form of δ  called the state transition table is 
given in Table 5.1. Actual states are on the left-hand side of the table, inputs are 
given as headings of the table columns. Table entries are the next states, and a 
hyphen indicates that δ  is undefined. 

 
Finite Automata 
53 
A
B
AB
R
M
C1
C3
C2
 
Figure 5.2. Flexible manufacturing system with one robot 
The arcs of the graph in Figure 5.3 are labeled with events of Σ . If the 
automaton is in some state, e.g., 
0
q , and a workpiece  (of type A) arrives in the 
system (event IA), then the automaton passes from 
0
q  into state 
1q . Being in 
1q  
two events can occur; either a workpiece B arrives (event IB) or the workpiece A is 
transferred into machine M (event 
AM
T
). Behavior of the system with respect to 
other events is represented analogously. 
An additional description of the automaton states is given in Figure 5.3. 
Symbol A indicates that a workpiece A is available at the input after it arrives in 
the system. Notation using symbol B has an analogous meaning. AinM, BinM 
represent states when workpieces A and B are inside machine M. ABO denotes that 
in the given state, the product AB is on the output conveyor. 
In the adopted finite automaton representation of the system, it is assumed that 
just one event occurs at a discrete time point. Technologically simultaneous actions 
are performed in the consecutive steps at separate discrete time points. The time 
interval between individual steps can be very short relative to the system dynamics. 
In practice, the interval is given by the processing time of the considered system 
control unit. Thus the required parallelism of the system actions can be ensured by 
relatively quick consecutive (serial) system actions, which can be quite sufficient 
with respect to time requirements of a particular system. 
If we consider the finite automaton in this example as a generator of a formal 
language, the generated words can be constructed in the following way (recall 
event paths in DFA): 
 
.
~
~
~
~
4
3
2
1
etc
IA
IB
T
T
T
IB
IA
T
IA
T
T
T
IB
IA
T
IA
T
T
T
IB
T
IA
IB
T
IA
ABN
ABO
BM
AM
ABN
ABO
BM
AM
ABN
ABO
BM
AM
AM
=
=
=
=
α
α
α
α
 

54 
Modeling and Control of Discrete-event Dynamic Systems 
A cyclic repetition of the manufacturing program yields infinite words which 
all belong to the generated formal language. In practice, the process stops on 
operator’s command, e.g., at the end of a working shift. 
 
IA 
IB 
A
B 
IB 
A,B 
IA 
TAM 
AinM 
IA 
AinM
A
IB
AinM
A,B
TBM
BinM
AinM
BinM
A
IB
AinM
A,B
TABO
ABO
A
TABN 
TAM
AinM
ABO
IB
AinM
ABO
B
TABN
q0 
TAM
AinM
B
IA
TBM
AinM
BinM
IA
IB
AinM
BinM
B
IA
TBM
AinM 
BinM 
ABO 
TABN
IB
IA
AinM
BinM
ABO
B
AinM
BinM
ABO
A
TABN
TABN
IA
IB
TABN
AinM
BinM
ABO
A,B
TABN
TABN
IA
IB
AinM
ABO,A
AinM
ABO
A,B 
TBM 
q1 
q2 
ABO
A,B
ABO
B
IB
TABO
TABO
TABN 
TABN
TABO
TABN 
ABO
IB 
q3
q4
q5
q6
q7 
q8 
q9 
q10
q11
q12
q13 
q14
q15
q16
q17
q18
q19 
q20
q21
q22
IA
TAM
IA
TABN 
q23
IA
IB
 
Figure 5.3. Finite automaton for a flexible manufacturing system 

 
Finite Automata 
55 
Table 5.1. State transition table for the automaton in Figure 5.3 
5.3 Control Specification Using Finite Automata 
The goal of the DEDS control is to generate control variables 
( )t
w
 as shown in 
Chapter 4. In the previous section a finite automaton is used for describing the 
DEDS behavior. By means of a finite automaton it is also possible to specify the 
system control, i.e., the function of a control subsystem C (Figure 4.1). We extend 
Definition 5.1 for that purpose. Let the modified model be called a deterministic 
finite automaton with outputs – DFAO. Its structure is very close to the one of the 
finite automaton defined before. 
q i  \ e j
IA
IB
T AM
T BM
T ABO
T ABN
q 0
q 1
q 8
-
-
-
-
q 1
-
q 9
q 2
-
-
-
q 2
q 3
q 10
-
-
-
-
q 3
-
q 4
-
-
-
-
q 4
-
-
-
q 5
-
-
q 5
-
q 6
-
-
q 14
-
q 6
-
-
-
-
q 7
-
q 7
-
-
q16
-
-
q 9
q 8
q 9
-
-
-
-
-
q 9
-
-
q 10
-
-
-
q 10
q 4
-
-
q 11
-
-
q 11
q 5
q 12
-
-
q 23
-
q 12
q 6
-
-
-
q 13
-
q 13
-
-
-
-
-
q 8
q 14
-
q 7
q 15
-
-
q 1
q 15
q 17
q 16
-
-
-
q2
q 16
q18
-
-
q 19
-
q 10
q 17
-
q 18
-
-
-
q 3
q 18
-
-
-
q 22
-
q 4
q 19
q 22
q 20
-
-
-
q 11
q 20
q 21
-
-
-
-
q 12
q 21
-
-
-
-
-
q 6
q 22
-
q 21
-
-
-
q 5
q 23
q14
q13
-
-
-
q 0

56 
Modeling and Control of Discrete-event Dynamic Systems 
It is natural to proceed as follows. The set of events Σ  is constructed as inputs 
to the control system from system S (Figure 4.1). Definition 5.1 is extended by a 
new set – the outputs, and the output function. 
Definition 5.3. A deterministic finite automaton with outputs (DFAO) is the triple 
 
(
)
ϕ
,
,Y
A
AC =
 
(5.12) 
where A is a deterministic finite automaton, Y is a finite set of outputs, and ϕ  is a 
function 
Y
Q →
:
ϕ
. 
Example 5.3. Consider a set of events 
{
}
R
,1,0
=
Σ
 and a set of outputs 
{
}
R
Y
,1,0
=
. 
0 and 1 are binary digits. R is the symbol denoting the event “no digit”. The 
symbol serves as a separator. Let a deterministic finite automaton with outputs be 
constructed to model a serial conversion of binary numbers into arithmetic binary 
complements used in the computers for the representation of negative numbers. For 
instance, the binary number 0 0 1 1 0 1 0 0 is given. The lowest order bit is at the 
right-hand side. The highest order bit is the seventh one on left and the eighth one 
is the sign bit. The digits and/or separators appear as a sequence where the first 
digit element in the sequence is the lowest bit etc.  
RRR
R
101100
00
~ =
ω
. Now the 
arithmetic complement is 
 
0   0 1 1 0 1 0 0 → 1  1 0 0 1 0 1 1 
 
 + 
1 
 
 
____________ 
 
 
1  1 0 0 1 1 0 0 
The sequence  R 0 0 1 0 1 1 0 0 R R R  whose elements are ordered as usual in 
sequences, i.e., the lowest order being assigned to the first left-hand digit element 
in the sequence should be converted into the sequence   R 0 0 1 1 0 0 1 1 R R R. 
The sequences are inversely written compared with the writing of the binary 
numbers. Time is not expressed explicitly. Event order is given by event sequences. 
The task is to construct DFAO such that the serially arriving binary numbers 
are converted into serially generated arithmetic complements. The conversion 
function is described as a DFAO as follows: 
 
{
}
{
}
{
}
Q
F
R
Y
q
q
q
q
q
Q
R
=
=
=
=
Σ
,1,0
state
 
initial
  
 the
is
 
 
where
,
,
,
,1,0
0
3
2
1
0
 
The functions δ  and ϕ  are specified in the graphical form in Figure 5.4. The 
control function of the DFAO being in an actual state 
k
q  and receiving an event 
ie  
is to generate an output 
Y
yk ∈
 and to go into the next state 
(
)
i
k
k
e
q
q
,
1
δ
=
+
. The 
outputs influence the controlled system. 

 
Finite Automata 
57 
 
q0/R 
q1/0 
q2/1
q3/0
0 
R 
0 
R 
R 
R 
0 
0 
1 
1 
1 
1 
 
Figure 5.4. Finite automaton of the binary number conversion 
Let us return to Example 5.2. For the sake of a better understanding we notate by 
XIA an event related to IA, XIB to IB etc. The DFAO is given as follows: 
 
(
)
ϕ
,
, Y
A
AC =
 
 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 
where  
{
}
ABN
ABO
BM
AM
XT
XT
XT
XT
XIB
XIA
,
,
,
,
,
=
Σ
 
{
}
kx
x
x
q
q
q
q
q
q
q
Q
,...,
,
,
,...,
,
,
2
1
23
2
1
0
=
 
Q
F =
 
and ϕ  is given below. 
The meaning of elements in set Σ  is slightly different from Equation (5.11). 
XIA denotes a signal from a sensor detecting the arrival of a workpiece A on the 
conveyor C1. An analogous meaning has the element XIB. Similarly, 
,
,
,
ABO
BM
AM
XT
XT
XT
 and 
ABN
XT
 correspond to signals indicating that a workpiece 
A, a workpiece B, and the assembled product are in the machine, on the output 
conveyor, and leaving the output conveyor, respectively.  The set of outputs is  
{
}
YABN
YABO
YBM
YAM
Y
,
,
,
,
λ
=
 
(5.13) 
where λ  stands for the empty symbol, YAM is a command for the robot to pick up 
a workpiece from conveyor C1 and to insert it into machine M. 
Function ϕ  is defined as follows: 

58 
Modeling and Control of Discrete-event Dynamic Systems 
 
( )
( )
( )
( )
( )
( )
( )
( )
( )
( )
(
)
(
)
.
,
,
,
,
,
,
,
,
,
,
,
,
1
10
9
8
7
6
5
4
3
2
1
0
etc
q
YBM
q
YAM
q
q
YABN
q
YABO
q
q
YBM
q
q
q
YAM
q
q
x
λ
ϕ
ϕ
ϕ
λ
ϕ
ϕ
ϕ
λ
ϕ
ϕ
λ
ϕ
λ
ϕ
ϕ
λ
ϕ
=
=
=
=
=
=
=
=
=
=
=
=
 
A command for the transfer of a B-workpiece into machine M is realized after a 
fixed given time interval when it is certain that the operation in the machine has 
been finished. It is analogous for the transfer of a product from M or from 
conveyor C3. Another possibility could be to introduce additional signals 
announcing completion of the respective operations.   A  DFAO is to be derived 
from the automaton in Figure 5.3 for different Σ  and using the set of outputs 
together with the function ϕ . A part of the deterministic finite automaton with 
outputs is sketched in Figure 5.5. The state transition table can be written as before. 
It must be extended by a table representing function ϕ , as exemplified by Table 
5.2. 
Finally, recall the regular expressions described in Chapter 3. It can be proved 
that the languages generated by finite automata are of type 3, i.e., regular 
languages. Inversely, regular languages are generated by finite automata or by their 
marked languages. The regular languages can be specified by regular expressions. 
Therefore, it is possible to apply triangular transformations according to the 
scheme in Figure 5.6. 
The regular expression 
β
αβ
∪
=
∗
L
 in Example 3.4 is generated according to 
Definition 5.2 by a deterministic finite automaton depicted in Figure 5.7. 
XIA
XIB
λ  
XIB 
YAM
XIA
XTAM
XIA
XIB
YBM
q0 
XTAM
YBM
XIA
XTBM
q1 
q2
XTABN
YABN
XIB
q3
q4
q8 
q9
q10
YAM 
λ
λ
q23
λ  
XTBM
q1x XTAM
q2x
XTBM
q5 
 
Figure 5.5. A control automaton 

 
Finite Automata 
59 
Table 5.2. Table for the output function ϕ  
 
Regular language
Regular expression
Deterministic finite automaton
 
Figure 5.6. Relation between regular language, regular expression and automaton 
 
q2 
q0 
q1 
α
 β  
 β  
 
Figure 5.7. Finite automaton generating the language given by a regular expression 
q 0
-
q 1
AM
q 2
-
q 3
-
q 4
BM
.
.
.
.
q 8
-
q 9
AM
q 10
BM
.
.
.
.
q 23
ABN
q 1x
-
.
.

60 
Modeling and Control of Discrete-event Dynamic Systems 
5.4 Non-deterministic Finite Automata 
Sometimes uncertainties may occur in the system. There is a whole theoretical 
branch, namely the fuzzy set theory and its applications dealing with uncertainties. 
In the finite automata, the uncertainty can be represented by a modification of the 
transition function δ . Instead of the next state a subset of next states is defined. 
Definition 5.4. A non-deterministic finite automaton is a quintuple 
 
(
)
F
q
Q
NA
,
,
,
,
0 δ
Σ
=
 
(5.14) 
where all symbols but the transition function δ  have the same meaning as in 
Definition 5.1. In this case 
 
Q
Q
2
:
→
Σ
×
δ
 
(5.15)  
An ordered pair state-event is mapped into a subset of Q. The power set 
Q
2  is the 
set of all subsets of Q  and always including the empty set. 
Non-deterministic finite automata are generators of the formal languages in the 
sense of Definition 5.2, as well. Both kinds of automata are equivalent with respect 
to language generation. If a non-deterministic finite automaton generates a 
language then a deterministic finite automaton can be constructed generating the 
same language. The inverse holds true, as well. 
5.5 Problems and Exercises 
5.1. Figure 5.8 shows a robotized manufacturing system with three robots. Robot 
R1 picks up a part of type A from input I1 (if available) and loads it in the milling 
machine M1. When milling is finished, R2 transfers the part on the assembling 
table. Similarly robot R2 picks up from input I2, a part of type B and loads it in M2. 
When the milling is finished in M2 and there is part type A on the assembling table, 
the part from M2 is transferred onto the assembling table where the final product is 
assembled of the parts. Then robot R3 puts the product on the output O. The 
manufacturing process repeats cyclically.  
Solve the following problems. 
a. Represent the described system and its behavior by a finite automaton in a 
graphic mode. The number of states is restricted to 30. 
b. Show how a finite automaton with outputs can specify control of the 
system. The state number is restricted within or to 20. 
c. Write several event strings generated by the automaton. 

 
Finite Automata 
61 
Figure 5.8. Manufacturing system with three robots 
 
q0
q1
q2
q3
e1
e2
e3
e4
e5
y3
y2
y1
y4
s0
s1
s2
e1
e3
e2
z1
z2
y3
e2
 
Figure 5.9. Two finite automata with outputs for Exercise 5.2 
 
5.2. Two finite automata with outputs are depicted in Figure 5.9. Specify their 
event sets, state sets and outputs. Determine the formal languages they are 
generating. Choose some states as the set for one automaton and specify the 
marked language, which it generates.  
Form the so-called product of automata with the set of states given by the 
Cartesian product of their state sets using a modeling assumption that only one 
event occurs at a discrete time point. 
5.3. Modify slightly the flexible manufacturing system in Figure 5.2 as depicted in 
Figure 5.10. The system has one input belt conveyor, two working machines and 
one assembly center. Parts of one kind are coming into the system one by one via 
the input conveyor. The robot transfers parts in free M1 or M2. Both machines 
have capacity one part. Then the parts from M1 or M2 are transferred to AC. There 
Input I1
Input I2
M1
M2 
R1 
R2
T
R3 
Output O  

62 
Modeling and Control of Discrete-event Dynamic Systems 
two parts are necessary for assembly. After assembly the product is transferred on 
the output conveyor. M1 and M2 perform the same operation but with different 
times.  
Make a deterministic finite automaton in the graphic form describing the 
function of the system. 
 
Figure 5.10. Modified flexible manufacturing system 
IC 
OC
M1 
M2
AC
R 

6 
Reactive Flow Diagrams 
6.1 Standard Flow Diagrams 
Flow diagrams, sometimes called flow charts, are popular in programming. They 
are graphical tools for drawn-graphical visualization of algorithms to be 
programmed and executed by computers. Flow diagrams make final programming 
easier and help one minimize programming errors.  
Flow diagrams have been developed and used for decades for transformation 
programs dealt with in Section 4.2. A flow diagram prescribes a sequence of 
computer operations forced by computer instructions. There are four basic 
elementary building blocks used in flow diagrams: operational block (Fig. 6.1a), 
decision block (Fig. 6.1b), start and end block (Fig. 6.1c), and subprogram block 
(6.1d). The blocks are connected with arrows determining the next operation block. 
The decision block is equipped with one or more conditions.  A continuation of a 
program depends on the conditions. A cyclic repetition of a same group of 
operations can be specified by means of a decision block, too. 
 
a. Operational block 
b. Decision block. 
c. Start and end block.
d. Subprogram block. 
Condition?
Y
N
 
Figure 6.1. Elementary building blocks of flow diagrams 
Application of the flow diagram technique to transformation programs is well 
known. A different situation arises if flow diagrams are used for reactive programs. 
In his book Zöbel (1987) analyzes in detail and shows troubles with standard flow 
diagrams used for control system programming. 

64 
Modeling and Control of Discrete-event Dynamic Systems 
6.2. Reactive Flow Diagrams 
Reactive programs are able to respond to external stimuli during their execution. 
Flow diagrams used for reactive program specification must be adapted for that 
purpose. An important problem regarding how to manage and process concurrent 
processes is connected with the reactivity property. In a controlled DEDS several 
technological operations usually run in parallel. In such a system there are signals 
mediating data about the system events. Such events are called concurrent.  
Let us return to Example 5.2 and consider the state 
0
q  in the finite automaton 
in Figure 5.5. Both asynchronous and spontaneous concurrent input variables XIA 
and XIB are to be detected. Similarly XIB and XTAM in the state 
1q : arrival of a 
workpiece B on the input conveyor B (variable XIB) and transfer of a workpiece A 
into machine M (variable XTAM) are concurrent events. Both events are 
spontaneous and do not influence each other. XIB may occur earlier than XTAM or 
vice versa. The control system passes into the next state according to the occurred 
event. As mentioned earlier, in a finite automaton model it is assumed that no two 
events occur exactly at the same time. It is clear that this assumption is very well 
substantiated in case of one-processor control system. 
The adaptation of a traditional flow diagram technique uses a cyclic repetition 
of a flow diagram or of its part, and locking or unlocking groups of operations in 
order to enable real-time processing of concurrent system events (Hrúz 1994). A 
cyclic repetition of program operations has to be sufficiently quick with respect to 
the controlled system dynamic requirements. 
There are only two ways to ensure fulfilment of the above-mentioned 
requirements if one control computer, or generally speaking one control processor 
is used in the system: 
a. Repetitive or cyclic sampling of concurrent variables 
b. Use of the computer interrupt (alarm) system 
Both ways can be mixed together in practical DEDS control.  
The solution may be different if two or more control processors are used in the 
system. Of course, the processors must somehow communicate. We will deal with 
the solution mostly encountered in practice, namely the use of one processor and 
item a. 
We will show the use of a reactive flow diagram to a control finite automaton 
(deterministic finite automaton with outputs) whose structure paradigm is depicted 
in Figure 6.2. It includes all situations encountered in finite automata: sequences of 
states, branching from a state and a feedback. Two related finite automata are used 
in order to show better the use of reactive flow diagrams for concurrent processes. 
{
}
5
2
1
,...,
,
e
e
e
 are inputs, {
}
4
3
2
1
,
,
,
y
y
y
y
 are outputs, {
}
3
2
1
0
,
,
,
q
q
q
q
 are the 
automaton states, and 
0
q  is the initial state for the first automaton. {
}
3
2
1
,
,
e
e
e
 are 
inputs, {
}
3
2
1
,
,
y
z
z
 outputs, {
}
2
1
0
,
,
s
s
s
 states, and 
0s  is the initial state for the 
second automaton. States of the whole shuffle automaton are given by the parallel 

 
Reactive Flow Diagrams 
65 
composition of the described automata (treated as sub-automata) states. The set of 
outputs is union of the sets of the sub-automata outputs. 
The finite automaton has been converted into the reactive flow diagram as 
shown in Figure 6.3, where the sampling or polling technique with the cyclic 
structure has been utilized. In the reactive flow diagram, the states of a finite 
automaton are represented by the operation blocks that are either locked or 
unlocked by means of the auxiliary variables from the set K: 
{
}
7
6
5
4
3
2
1
,
,
,
,
,
,
k
k
k
k
k
k
k
K =
. 
When a transition from one state to another occurs, the block associated with 
the active state is locked using variables from set K and the block associated with 
the next state is released. Figure 6.3 explains how branching and looping is solved 
using the same idea. As mentioned above, another possibility would be to use the 
interrupt mechanism or to combine it with the cyclic polling technique just 
described. 
Control finite automata outputs are control variables for the controlled system. 
They are denoted as y or z. Inputs to the automaton are outputs of the controlled 
system, that represent events e. Branching in the first automaton in state 
2
q  is 
solved by a block which is guarded by the variable 
1
3 =
k
 while 
0
,0
,0
4
2
1
=
=
=
k
k
k
 so that the other three remaining blocks corresponding to the 
first automaton are locked. It also means that the state 
2
q  is active. Depending on 
the arrival of the events 
1e  or 
5e , the next active state will be 
3
q  or 
1q , 
respectively. Guarding variables associated with the second automaton are k5, k6, 
and k7. Processes are parallel when, for example, 
1
and
1
5
3
=
=
k
k
. Two blocks 
are accessible in that case in a reactive flow diagram.  
 
q0
q1
q2
q3
e1
e2
e3
e4
e5
y3
y2
y1
y4
s0
s1
s2
e1
e3
e2
z1
z2
y3
e2
 
Figure 6.2. A structure paradigm for control finite automata 

66 
Modeling and Control of Discrete-event Dynamic Systems 
`
START
,
3y
y =
0
,
,
,
,
7
6
4
3
2
=
k
k
k
k
k
1
,
5
1
=
k
k
N
Y
Sampling period
expired?
Y
N
k1=1
 e=e2
Y
N
k1:=0
k2:=1
k2=1
Y
Y
N
N
 e=e4
k2:=0
Y
Y
N
N
k3=1
 e=e1
k3:=0
 e=e5
N
Y
k3:=0
Y
N
k4=1
 e=e3
N
Y
k4=0
Y
N
k5=1
 e=e1
N
Y
y:=y2
k3:=1
y:=y1
k4:=1
y:=y4
k2:=1
y:=y2
k3=1
y:=y1
k5=0
k6=1
z:=z2
Y
N
k6=1
 e=e3
N
Y
k6=0
k7=1
z:=y3
Y
N
k7=1
 e=e2
N
Y
k7=0
k5=1
z:=z1
 e=e2
k6=0
k5=1
Y
N
1z
z =
 
Figure 6.3. Reactive flow diagram for the finite automata in Figure 6.2 

 
Reactive Flow Diagrams 
67 
As mentioned earlier, the sampling frequency has to be such that the response 
to the events is sufficiently quick. Expression 
4
:
y
y =
 means that the variable y is 
set value to 
4y , 
1
:
z
z =
 means that  z is set to 
1z , etc., and similarly for the 
variables 
ik . The rest is clear from Figures 6.2 and 6.3. 
6.3 Problems and Exercises 
6.1. Minimum time duration of signals that are external ones for the control 
systems is decisive for a good control function. Consider a reactivity problem of 
the control function with respect to temporal properties of external signals using 
reactive flow diagram with its cyclic repetition as described in this chapter. 
6.2. Figure 6.4 shows a robotic manufacturing cell. Workpieces A are processed 
sequentially with robot R1 and with robot R2 respectively. The sequence results in 
the product A. 
Figure 6.4. A two-robot manufacturing cell 
A similar operation sequence is applied for workpieces B resulting in products of 
the kind B. Workpieces come in the cell irregularly. Specify control of the robotic 
cell with the use of a reactive flow diagram. 
 
R1
R2
Product A
Product B 
C12
C11
C21
C22
Assembling 
Table 1 
Assembling 
Table 2 
o
o
o
o
o
o
o
o
F11
F12
F21
F22
Workpiece A
Workpiece B

7 
Petri Net Models of DEDS 
7.1 Notion of Petri Nets 
As described in Chapter 5, a finite automaton specifies a system by means of a set 
of states and a transition function. The arguments of the transition function are the 
state and event. We can speak about an actual state. The transition function assigns 
a state to an actual state. The assigned state is a next state while the actual state can 
be called the active present state. By repeating the assignments, a sequence of 
actual states is obtained. In the finite automaton there is always only one state 
active. 
A system can often be broken down into subsystems. If it is required to 
describe activities of subsystems and their mutual relations, a finite automaton 
model can be cumbrous because each combination of subsystem states needs a 
separate state of the finite automaton. Another model known as a Petri net removes 
that inadequacy. Petri nets are named after a German mathematician C. A. Petri 
who first proposed a model of that kind (C. A. Petri, 1962). With Petri nets the 
main idea is to represent states of subsystems separately. Then, the distributed 
activities of a system can be represented very effectively. Many properties of the 
DEDS, e.g., synchronization, concurrency, and choices can be well presented and 
analyzed using Petri nets. They can be used not only for the specification of the 
DEDS behavior but also the control design. However, Petri nets have various other 
uses. To illustrate them we introduce, e.g., fuzzy reasoning with Petri nets (Gao et 
al. 2003, 2004) or creation of algorithms (Hanzálek 1998a, b). Several supporting 
programs exist for design and analysis of Petri nets, e.g., PESIM (Češka 1994), 
MATLAB® Toolbox (Svádová and Hanzálek 2001), CPN analysis tools (Jensen 
1997), SPNP (Hirel et al. 2000), and many others. 
Let a manufacturing cell be configured as shown in Figure 7.1. A workpiece 
arriving at the cell on the input conveyor is transferred to the milling machine. 
Both workpiece and robot must be available to perform first the transfer operation 
of the workpiece into the machine input. Then the milling is taking place in the 
milling machine. Obviously, the milling machine must be free for that. After 
milling, the workpiece is moved onto the machine output. Then, if the robot is free, 
the processed workpiece is transferred by the robot onto the cell output conveyor. 

70 
Modeling and Control of Discrete-event Dynamic Systems 
Only one workpiece can be located in any of the cell subsystems. So far, 
technological conditions and the procedure have been described verbally. 
MILLING
MACHINE
Output conveyor
Machine input
Machine output
Robot
Input conveyor
 
Figure 7.1. A robotic manufacturing cell 
Figure 7.2 shows how the function of the manufacturing cell with its 
subsystems can be presented using a Petri net. Let the circles in Figure 7.2 denoted 
by
5
2
1
,
,
p
p
p
 and 
7
p  correspond to four subsystems as follows: input conveyor - 
1p , robot - 
2
p , milling machine -
5
p  and output conveyor -
7
p . Let the other 
circles correspond to the following operations: transfer of a workpiece into the 
milling machine by means of the robot - 
3
p , milling operation - 
4
p , transfer of 
the milled workpiece on the output conveyor - 
6
p . The circles are called places of 
Petri nets. The presence or availability of a workpiece at the cell input is modeled 
by a dot in place 
1p . We say that a token is in 
1p . Analogously, a token in 
2
p  
(Figure 7.2b) means that the robot is free or available to transfer a workpiece 
somewhere. Figure 7.2a shows a situation when both conditions for the transfer of 
a workpiece into the machine are not satisfied. A vertical bar denoted as 1t  is 
called a transition. It symbolizes an event. In this case, it is the start of the transfer 
operation.  Transition  
2t   represents  the  end of the transfer and start of the 
milling operation. Clearly, realization of this event requires that the transfer has 
been performed and the milling machine is available. 
3t  denotes the end of the 
milling and start of the workpiece transfer on the output conveyor; 
4t  is the end of 
the output transfer and arrival of a workpiece on the output conveyor. 
The token distribution describes an actual state of the system. It changes 
through a so-called transition firing. A transition firing is possible if all places 
before this transition have enough tokens – the transition is said to be enabled. 
Firing has the following effect: one token is taken from all places before the 
transition and one token is placed into each place located after the transition. The 
effect complies with the so-called firing rules just described. According to Figure 
7.2b both conditions are met for a workpiece transfer. Figure 7.2c shows the next 
system state: the robot moves the workpiece from the input conveyor into the 

 
Petri Net Models of DEDS 
71 
p1
p2
workpiece at
input
robot available
transfer into
machine
p3
t1
milling machine
available
milling
operation
transfer on
output
workpiece at
output
p4
p5
p6
p7
t2
t3
t4
p1
p2
p3
t1
p4
p5
p6
p7
t2
t3
t4
milling machine. Figure 7.2d gives the next state when the milling operation is in 
progress and the robot is again free. 
a. 
b. 
c. 
Figure 7.2. Petri net of a manufacturing cell: a. input conditions not met; b. input conditions 
met; c. workpiece transfer into the milling machine; and d. milling operation in progress 
p1
p2
p3
t1
p4
p5
p6
p7
t2
t3
t4

72 
Modeling and Control of Discrete-event Dynamic Systems 
p1
p2
p3
t1
p4
p5
p6
p7
t2
t3
t4
 
d. 
Figure 7.2. (continued) 
The Petri net places are connected with transitions through oriented arcs. The 
arcs pointing to a transition from places (called input places) indicate that those 
places should have tokens in order for the transition to fire. Speaking in terms of 
systems to be modeled, an event can occur when the required state conditions are 
fulfilled. Firing a transition corresponds to occurrence of an associated event with 
it. The event causes a state change. In the Petri net, a new state is given by change 
or flow of tokens according to the above given rules. Oriented arcs going out of the 
transition to some places (called output places) indicate that the place-
corresponding subsystems will be active after the transition fires. 
The Petri net model of the DEDS from Figure 7.1 corresponds to a real system 
if the meaning of the Petri net elements is properly chosen and used. Our model 
bears some risk.  Imagine, that the milling operation runs (Figure 7.2d) and a new 
workpiece arrives in the cell. The robot is available, thus according to the Petri net 
the workpiece can be put into the transfer process. The robot is occupied by the 
transfer. On the other hand, the robot is needed for the transfer of the processed 
workpiece out of the machine. The system will be in a deadlock, i.e., no 
continuation is possible. Occurrence of the deadlock depends on the time 
circumstances. If a workpiece, and accordingly a token, comes in 
1p  in due time, 
i.e., if the intervals between two inputs of workpieces are not smaller than some 
allowed value, the deadlock does not occur in this cell. 
Another possibility to avoid the described difficulty with deadlocks is to 
improve the Petri net model to be closer to a real manufacturing system. Usually a 
milling machine has an input place where a workpiece waits for milling and a place 
at the machine output where a workpiece is placed after milling. The next 
workpiece can be placed to the machine input during the milling of another 
workpiece. A new workpiece can be milled when the processed workpiece is 
moved to the output place. A Petri net model describing the work of the 
manufacturing cell more realistically is shown in Figure 7.3. There are some new 
places and transitions in Figure 7.3 specifying a correct function of the cell without 
system deadlocks. If a workpiece appears at the input, a token is placed in 
1p . 
Place 
32
p
 ensures that the transfer of a next workpiece into the machine starts only 
when the machine input is free. Similarly, a token in 
42
p
 means that the machine 

 
Petri Net Models of DEDS 
73 
output is empty. Place 
61
p  guards the transfer onto the output conveyor. We can 
see that Petri nets can well express the distributed activities in the modeled system. 
The situation just described is very often encountered in the design practice.  If 
the Petri net in Figure 7.2d is correct with respect to the system behavior, the real 
system should be re-arranged and improved. Petri nets can thus help discover an 
ill-shaped technological layout. On the other hand, they may not correctly specify 
the system. A solution of that case is shown in Figure 7.3 using a corrected net.  
milling machine
available
milling
operation
p4
p5
t2
t3
transfer on
cell output
workpiece
 at output
p6
p7
t4
p1
p2
workpiece
at input
robot available
transfer into
machine
p3
t1
p31
machine
input
t21
t31
p61
output conveyor
empty
t41
p41
machine
output
p32
p42
 
Figure 7.3. An improved Petri net model of the manufacturing cell 
Figure 7.4. Petri net model of the manufacturing cell with the arc weights 
Consider now a situation when three parts are to be fed into the milling 
machine. In the machine the parts are simultaneously processed and assembled in 
one product. The situation can be modeled using weights of the Petri net arcs. 
According to modified rules for transition firing, each place before a transition 
must have at least as many tokens as the weight of the arc connecting the place and 
the transition. Tokens whose quantity is equal to the arc weight are removed from 
each input place of the considered transition.  On the other hand, after a transition 
fires, as many tokens are put into each output place as the weight of the outgoing 
arc from the transition to the place. The weights are positive integers. The use of 
weights is illustrated in Figure 7.4. A weight is assumed to be 1 if no number is 
associated with an arc. It was the case in Figures 7.2a–d and 7.3. Other weights 
milling machine 
available 
milling 
operation
p4
p5
t2 
t3
transfer on 
cell output
workpiece 
 at output 
p6
p7 
t4
p1 
p2 
workpiece 
at input
robot available 
transfer into 
machine 
p3 
t1 
p31
machine 
input
t21
t31
p61
output conveyor 
free
t41 
p41
machine 
output
p32
p42
3 
3 

74 
Modeling and Control of Discrete-event Dynamic Systems 
than one are given as arc labels. Transition 
21
t
 can be fired only when the machine 
is free (a token is in 
5
p ) and three tokens in 
31
p . Then, three tokens are taken 
away from 
31
p , one from 
5
p  and one is placed into 
4
p . 
Figure 7.5. Petri net for the manufacturing system from Figure 1.3 
 
z 
z z 
z 
z
z
z
z 
z
zzz
p1 
p2
p3 
p5 
p4 
p7
p6
p8
p9
p10
p11
p13
p14
p12
p15
p16
p17
p18 
p19
p20
p21
p23 
p24
p25 
p22
t1 
t2 
t3 
t4 
t5 
t6 
t7 
t8 
t9 
t10 
t11 
t12 
t13 
t14 
t15 
t16 
t17 
t18 
t19 
t20 

 
Petri Net Models of DEDS 
75 
We are now able to construct a Petri net for the manufacturing system in Figure 
1.3. The Petri net is depicted in Figure 7.5. The place and transition meaning is 
explained in Tables 7.1 and 7.2. 
Table 7.1. Meaning of places of the Petri net in Figure 7.5 by a token presence 
p1
Waiting on workpiece arrival
p2
Workpiece in the detection area of sensor P11 
p3
Workpiece between sensors P11 and P12
p4
Capacity of conveyor C1
p5
Workpiece ready at the end of C1 for the transfer into machine M
p6
Machine M free
p7
Transfer of the workpiece into machine M is in progress
p8
Workpiece waitng for processing in M
p9
Processing of the workpiece in machine M is running
p10
Workpiece waiting on transfer onto conveyor C2
p11
Workpiece transfer on conveyor C2
p12
Capacity of conveyor C2
p13
Workpiece waiting on processing
p14
Workpiece between sensors P21 a P22
p15
Workpiece at the end of conveyor C2
p16
Transfer of the workpiece into machine G is in progress
p17
Workpiece waiting on processing
p18
Machine G is free
p19
Processing of the workpiece in machine G is running
p20
Workpiece waiting for transfer onto conveyor C3
p21
Transfer of the workpiece onto conveyor C3 in progress
p22
Capacity of conveyor C3
p23
Workpiece at the begin of conveyor C3
p24
Work-piece between sensors P31 and P32
p25
Work-piece at the end of conveyor C3
 

76 
Modeling and Control of Discrete-event Dynamic Systems 
Table 7.2. Meaning of transitions of the Petri net in Figure 7.5 
t1
Work-piece arrives into the detection area of sensor P11
t2
Work-piece arrives into the area between sensors P11 and P12
t3
Work-piece arrives at the end of conveyor C1
t4
Start of the work-piece transfer from conveyor C1 into machine M
t5
End of the work-piece transfer into machine M
t6
Start of the work-piece processing in machine M
t7
End of the work-piece processing in machine M
t8
Start of the work-piece transfer from machine M onto conveyor C2  
t9
End of the work-piece transfer from machine M onto conveyor C2
t10
Work-piece arrived in the area between P21 and P22
t11
Work-piece arrived at the end of conveyor C2
t12
Start of the work-piece transfer from conveyor C2 into machine G
t13
End of the work-piece transfer into machine G
t14
Start of the work-piece processing in machine G
t15
End of the work-piece processing in machine M
t16
Start of the work-piece transfer from machine G onto conveyor C3
t17
End of the work-piece transfer from machine G onto conveyor C3
t18
Work-piece arrived in the area between P31 and P32
t19
Work-piece arrived at the end of conveyor C3
t20
Work-piece left conveyor C3 and the manufacturing system
 
7.2 Basic Definitions 
The notion introduced intuitively in the preceding section is systematically 
analyzed and defined in this section. First, the basic definition of a net is given. 
Definition 7.1. The net NET is defined by a triple 
 
(
)
F
T
P
NET
,
,
=
 
(7.1) 
where P={p1, p2, …, pn} is a finite non-empty set of elements called places, T={t1, 
t2, …, tm }is a finite non-empty set of elements called transitions, and F is the union 
of two binary relations F1  and F2: F = F1∪F2. P and T  are the disjunctive sets, i.e., 
P∩T= ∅ (empty set). F1 is a binary relation from P to T : F1⊆ P×T. Analogously 
F2⊆ T×P is the binary relation  from T to P. F is the set of ordered pairs consisting 
of a place (transition) at the first position and a transition (place) at the second one. 
F is called a flow relation. P, T and F are such that the following holds for them: 

 
Petri Net Models of DEDS 
77 
 
T
t
P
p
j
i
∈
∃
∈
∀
:
 such that (
)
F
t
p
j
i
∈
,
 or (
)
F
p
t
i
j
∈
,
and 
 
P
p
T
t
r
s
∈
∃
∈
∀
:
 such that (
)
F
p
t
r
s
∈
,
 
or (
)
F
t
p
s
r
∈
,
. 
According to the definition, each place is included at least in one ordered pair of F. 
Similarly, each transition is included in at least one ordered pair of F. In other 
words there are neither isolated places nor isolated transitions in net NET. 
Definition 7.2. A Petri net PN is defined by the triple 
(
)
0
,
,
M
W
NET
PN =
 
(7.2) 
where  NET  is a net by Definition 7.1 such that 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 
(7.3) 
W is the weight function given as 
+
→N
F
W :
where 
+
N
 is a set of positive 
integers. 
N
P
M
→
:
0
 is a function called the initial marking whose element M0(p) 
is the number of tokens initially in place p where N is a set of non-negative integers. 
 
The numbers to which are mapped the pairs of F are called weights. Obviously, 
the weights are positive integers. The initial marking is non-negative integers. 
Definition 7.3. The function 
N
P
M
→
:
 is called the marking of a Petri net. M(p) 
represents the number of tokens in place p at marking M. 
The initial marking is specifically given in the definition of a Petri net. 
Similarly as in finite automata, it is reasonable to include the initial state in Petri 
net model definition because any real system begins its activity at an initial state. 
The different functions 
N
P
M
→
:
correspond to the different markings. 
Consider a Petri net PN and a transition 
T
t ∈
. The set of input places of t as 
denoted by  t
•  and called preset of t is  
 
(
)
{
}
F
t
p
p
t
i
i
∈
=
•
,
 
(7.4) 
According to Equation (7.4), set t
•  contains each place 
ip  being in the flow 
relation F with the given transition t. The set of output places belonging to t, called 
post-set of t, is 
 
(
)
{
}
F
p
t
p
t
i
i
∈
=
•
,
 
(7.5) 
Similarly, the set of the input and output transitions pertaining to a given place 
p is 

78 
Modeling and Control of Discrete-event Dynamic Systems 
 
(
)
{
}
F
p
t
t
p
j
j
∈
=
•
,
 
(7.6) 
 
(
)
{
}
F
t
p
t
p
j
j
∈
=
•
,
  
(7.7) 
Input and output places of a transition are also named pre- and post-places. 
Similarly, input and output transitions of a place are also named pre- and post-
transitions. 
The next two definitions define the transition enabling and firing rules-they are 
together also called the execution rules of a Petri net. 
Definition 7.4. (Enabling rule) A transition t in a given Petri net is called fireable 
or enabled by a marking M if and only if (iff for short):  
a. For each pre-place of t, its marking is equal or greater than the weight of 
the arc from it to t, or 
b. 
t
•  has no pre-place.    
Mathematically, a transition t is fireable iff 
 
( )
(
)t
p
W
p
M
t
p
,
:
≥
∈
∀
•
 
(7.8) 
or 
 
∅
=
•t
 
(7.9) 
 
Equation (7.9) means that a transition without any pre-place is fireable by any 
marking. Such a transition is called a source transition. The notation 
(
)t
p
W
,
 
means the value of the function W for the ordered pair (
)t
p,
. Strictly writing, it is 
(
)
(
)
t
p
W
,
. 
Definition 
7.5. 
(Firing 
rules) 
Consider 
a 
Petri 
net 
and 
marking 
( )
{
}
n
p
p
p
p
p
M
,...,
,
,
2
1
∈
. Assume that transition t is fireable. Then, the marking 
after t’s firing is 
 
( )
( )
(
)
(
)
(
) (
)
( )
(
)
(
) (
)
( )
(
)
(
) (
)
( )
(
) (
)
⎪
⎪
⎪
⎩
⎪⎪
⎪
⎨
⎧
∉
∧
∉
∈
∧
∉
+
∉
∧
∈
−
∧
∈
∧
∈
+
−
=
•
•
•
•
•
•
•
•
t
p
t
p
M
t
p
t
p
p
t
W
p
M
t
p
t
p
t
p
W
p
M
t
t
p
p
t
W
t
p
W
p
M
p
M
p
    
if
    
          
          
          
    
if
         
          
,
     
          
          
    
if
         
          
,
s
expression
 
logical
 
of
n 
conjunctio
 
for the
  
stands
 
 where
 
,
p
if
,
,
'
 
 
 
(7.10) 

 
Petri Net Models of DEDS 
79 
'
M  is called immediately reachable from M. M is reachable from M0 if firing a 
sequence of enabled transitions leads M0 to M. All markings reachable from M0 
form a set called the reachability set. An alternative definition of a Petri net is often 
used as follows. 
Definition 7.6. The Petri net PN is defined by a quintuple 
 
(
)
0
,
,
,
,
M
O
I
T
P
PN =
 
(7.11) 
where 
{
}
n
p
p
p
P
,...,
,
2
1
=
 is a finite non-empty set of elements called places,  
{
}
mt
t
t
T
,...,
, 2
1
=
is a finite non-empty set of elements called transitions and 
∅
=
∩T
P
,  
I is a function 
N
T
P
I
→
×
:
 called input function,  
O  is a function 
N
T
P
O
→
×
:
 called output function, and  
0
M  is a function 
N
P
M
→
:
0
called the initial marking. 
 
Definition 7.6 can define an equivalent Petri net with that defined by Definition 
7.2. Let us formulate it as a theorem. 
Theorem 7.1. A Petri net defined by Definition 7.2 is equivalent with that defined 
by Definition 7.6 iff the following conditions hold for F, W, I, and O: 
 
(
)
(
)
(
)t
p
W
t
p
I
F
t
p
,
,
,
=
⇒
∈
 
(7.12) 
 
(
)
(
)
0
,
,
=
⇒
∉
t
p
I
F
t
p
 
(7.13) 
 
(
)
(
)
(
)
p
t
W
t
p
O
F
p
t
,
,
,
=
⇒
∈
 
(7.14) 
 
(
)
(
)
0
,
,
=
⇒
∉
t
p
O
F
p
t
 
(7.15) 
and inversely 
 
(
)
(
)
(
)
(
)t
p
I
t
p
W
and
F
t
p
t
p
I
,
,
,
0
,
=
∈
⇒
≠
 
(7.16) 
 
(
)
(
)
(
)
defined
not 
 
is
,
,
0
,
t
p
W
and
F
t
p
t
p
I
∉
⇒
=
 
(7.17) 
 
(
)
(
)
(
)
(
)t
p
O
p
t
W
and
F
p
t
t
p
O
,
,
,
0
,
=
∈
⇒
≠
 
(7.18) 
 
(
)
(
)
(
)
defined
not 
 
is
,
,
0
,
p
t
W
and
F
p
t
t
p
O
∉
⇒
=
 
(7.19) 
This theorem follows directly from Definitions 7.2 and 7.6. 
Equation (7.10) can be written in a simple way using Definition 7.6. Firing an 
enabled (firable) transition t at M leads to a new marking M′  such that    
 
P
p∈
∀
, 
( )
( )
(
)
(
)t
p
O
t
p
I
p
M
p
M
,
,
+
−
=
′
 
(7.20) 

80 
Modeling and Control of Discrete-event Dynamic Systems 
From the graph-theoretical viewpoint, the Petri net defined by Definition 7.1 is 
a directed bi-partite labeled simple graph (not a multi-graph). The set of Petri net 
nodes consists of two disjunctive sets, namely P and T. The flow relation F 
corresponds to the set of directed (oriented) graph arcs. An arc is given by the 
relevant ordered pair. Direction of the arc is determined by the order of the pair 
elements. The weights defined by function W are the arc labels. 
The same graph is defined according to Definition 7.6. If (
)
0
,
,
≠
=
k
k
t
p
I
 
(
)
(
)
0
,
,
≠
=
k
k
t
p
O
 then there exists the directed arc from p to t (from t to p) with 
the weight equal k. 
7.3 Vector and Matrix Representation of Petri Nets 
In a given Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 for each transition t of PN and always 
for all places 
P
p ∈
 we create the functions 
+t , 
−t  and t
Δ  as follows: 
 
( )
(
)
⎩
⎨
⎧
∈
=
•
+
otherwise
        
0
    
if
    
,
t
p
p
t
W
p
t
 
(7.21) 
 
( )
(
)
    
otherwise
        
0
    
if
    
,
⎩
⎨
⎧
∈
=
•
−
t
p
t
p
W
p
t
 
(7.22) 
 
( )
( )
( )
p
t
p
t
p
t
−
+
−
=
Δ
 
(7.23) 
Values of the functions 
t
t
t
Δ
−
+
  
and
,
,
 along with their argument p can be 
represented as vectors 
t
t
t
Δ
−
+
  
and
,
,
 having the dimension equal to the number n  
of the Petri net places. It is assumed that the first entry of each vector corresponds 
to place 
1p , the second one to 
2
p , etc., up to the n-th entry corresponding to 
n
p . 
By that construction places and transitions are numerated or indexed ordinarily 
according to Definition 7.1, namely, 
{
}
n
p
p
p
P
...,
,
2
1
=
 and 
{
}
mt
t
t
T
,...,
, 2
1
=
. Then 
 
( )
(
)
(
)
( )
(
)
(
)
( )
(
)
(
)⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
Δ
Δ
Δ
=
Δ
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
−
−
−
−
+
+
+
+
n
n
n
p
t
p
t
p
t
p
t
p
t
p
t
p
t
p
t
p
t
M
M
M
2
1
2
1
2
1
,
,
t
t
t
 
(7.24) 
Arithmetic operations of addition and subtraction are performed by vector 
entries, e.g., the sum of two vectors 
2t
Δ
 and 
4t
Δ
is 

 
Petri Net Models of DEDS 
81 
 
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
Δ
+
Δ
Δ
+
Δ
Δ
+
Δ
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
Δ
Δ
Δ
+
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
Δ
Δ
Δ
=
Δ
+
Δ
n
n
n
n
p
t
p
t
p
t
p
t
p
t
p
t
p
t
p
t
p
t
p
t
p
t
p
t
4
2
2
4
2
2
1
4
1
2
4
2
4
1
4
2
2
2
1
2
M
M
M
4
2
t
t
  (7.25) 
Another variable useful to be represented as a vector is the Petri net marking M. 
Similarly under the above assumptions we have 
 
(
)
(
)
(
)⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
n
p
M
p
M
p
M
M
2
1
m
 
(7.26) 
Consider 
two 
markings 
m
m
′
  
and
  
 given 
for 
a 
Petri 
net. 
If 
( )
( )
P
p
p
p
∈
∀
′
≤
for  
  
 
m
m
, then 
m
m
′
≤
, where 
( )
p
m
 is a vector entry equal 
( )
P
p
p
M
∈
,
 according to Equation (7.26). Further if 
m
m
m
m
′
≠
′
≤
  
and
  
, then 
m
m
′
<
. The inequality 
m
m
′
≠
 is satisfied when at least for one corresponding 
pair of the vector entries holds the inequality 
( )
( )
p
M
p
M
'
≠
. 
Theorem 7.2. Consider a Petri net. Then a transition 
T
t ∈
 is fireable by marking 
m  iff 
m
t
≤
−
. If t is fireable by marking m  then marking 
t
m
m
Δ
+
=
'
 is 
obtained by firing of  t. The notation used for that event is 
[
m
m
′
>
t
. Expressed in 
another way, 
[
'
m
m
>
t
 means that firing of t leads from markings m  to m′ . 
Proof. The proof refers to Definition 7.4 dealing with the fireability of Petri net 
transitions, and to Equation (7.22). Consider a transition t and a marking m . Let  t 
be fireable by m . If some place p is not a pre-place of the transition then the 
corresponding entry of the vector 
−t
 is zero, which is less or equal to the 
corresponding entry of m for any value of the marking m . If the considered place 
is a pre-place of t , the entry of 
−t  is the weight 
(
)t
p
W
,
. According to Equation 
(7.8) it should be less or equal to 
( )
p
M
 and this is just the condition contained in 
the corresponding vector entry of the expression 
m
t
≤
−
. Thus the necessary 
condition (t is fireable ⇒ 
m
t
≤
−
) is proved. The sufficient condition 
(
m
t
≤
−
⇒t is fireable) follows directly from the fireability definition. The 
validity of the expression 
t
m
m
Δ
+
=
'
 results directly from the definition of the 
vector t
Δ . 

82 
Modeling and Control of Discrete-event Dynamic Systems 
Dynamic behavior of the of a system represented by the Petri net can be 
expressed using the Petri net incidence matrix 
(
)
ij
a
=
A
 . A is an 
m
n×
 matrix 
with entries given by 
 
(
)
(
)
m
j
T
t
n
i
P
p
t
p
I
t
p
O
a
j
i
j
i
j
i
ij
,...,
2,1
,
,
,...,
2,1
,
,
,
,
=
∈
=
∈
−
=
 
 
 
(7.27) 
The incidence matrix A can be given in terms of the vectors 
jt
Δ
,
m
j
,...,
2,1
=
, 
as 
 
(
)
m
t
t
t
A
Δ
Δ
Δ
=
,...,
,
2
1
 
(7.28) 
Now, a new marking m′  obtained from the marking m  by firing the fireable 
transition 
jt  can be expressed using the incidence matrix as 
 
x
A
m
m
+
=
′
 
(7.29) 
where 
 
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
=
0
.
.
0
1
0
.
0
0
th
j
x
 
(7.30) 
is an m-dimensional vector whose j -th vector entry equals 1 while the other 
entries equal zero.  
Example 7.1. The behavior of the flexible manufacturing system with one robot 
was described in Example 5.2, Figure 5.2, Chapter 5, using the finite automaton 
(Figure 5.3). We will represent the system by the Petri net shown in Figure 7.6, in 
order to compare both ways of the DEDS modeling.  
A token in the place 
0
A
p
 represents a situation when the conveyor A is empty. 
The event “a workpiece occurred at the system input” changes the input state. 
Afterwards the workpiece is prepared for manufacturing. The event is represented 
by firing 
At . Transition 
At  is fireable and on its firing the token from
0
A
p
 is 
removed and is placed into the place 
1
A
p
. In the Petri net it is not specified when 
the event happens. Places 
1
0 and
B
B
p
p
 have an analogous meaning for the input

 
Petri Net Models of DEDS 
83 
Figure 7.6. Petri net model of the flexible manufacturing system from Figure 5.2 
workpieces of kind B. If the robot is available (a token is in 
R
p ), a workpiece A is 
available (a token in 
1
A
p
), and the previous machine process is completed (a token 
in 
MF
p
) then the robotic transfer of the workpiece A can start (firing transition 1t ). 
Place 
TA
p
is occupied by a token during the transport. The end of the transport and 
loading the workpiece into machine M is specified by transition 
2t . After firing 
2t  
a token is placed in 
MA
p
. End of processing of the workpiece A is specified by 
transition 
3t  and the start of the transport of B into the machine by 
4t . Then a 
token comes to the place 
TB
p
, which indicates that the transfer of the workpiece B 
is in progress; 
5t denotes end of the transfer and start of the assembly operation; 6t  
specifies end of the assembly operation; 
7t  specifies start of the product transfer 
from M onto the conveyor C3 (
7t  is fired and a token appears in 
TO
p
). After the 
transfer of the product AB on C3 and its leaving out the cell, the token moves to 
the
OF
p
 place. The place 
MF
p
 ensures that the next part A is loaded into machine 
Processing part A → adding B → assembling AB 
 
pA0 
pA1 
pTA
pMA
pTB
pMAB
pABW 
pTO 
pO
pOF
pR
pB0
pB1
pMF
tA 
t1 
t2
t4
t5
t6
t7
t8
t9
tB
pAW
t3

84 
Modeling and Control of Discrete-event Dynamic Systems 
M only after the assembly process has been finished. The next workpiece A can be 
loaded at the earliest on the conveyor C1 (firing 
At ) when the preceding workpiece 
A is in the transfer to the machine M (
TA
p
 marked). Considering it we have: 1t  
fires and then 
At  fires.  First, A has to arrive to be processed in M (a token in 
MA
p
) 
and after that it waits in the machine (token in 
AW
p
) and only then B can be 
loaded into the machine.  The place 
ABW
p
 corresponds to the machine output. A 
token is in 
ABW
p
 if the assembled product AB is at the machine output. After the 
product leaves machine M, M is free again. 
The created Petri net specifies the structure and behavior of the flexible 
manufacturing system in a transparent and concise way. The relation between the 
system states and its dynamics is graphically visible using the properties and rules 
of Petri nets. A new workpiece can be loaded into the machine M when it is 
present at the cell input and the machine M is free (place 
MF
p
 has a token).  
Moreover, the obtained Petri net specifies the cyclic repetition of the 
manufacturing process. Conditions and development of the manufacturing process 
can be verified thus the Petri net presents a basis for developing the control 
program.  
The incidence matrix can be computed via the vectors 
jt
Δ
 or via functions 
(
)
j
i t
p
O
,
 and (
)
j
i t
p
I
,
.  
The incidence matrix expressed via the vectors is 
 
(
)
9
8
2
1
,
,...,
,
,
,
t
t
t
t
t
t
A
Δ
Δ
Δ
Δ
Δ
Δ
=
B
A
  
(7.31) 
where, for example,  
(
)
T
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
=
+
A
t
, 
(
)
T
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
=
−
A
t
, 
(
)
T
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
−
=
Δ
A
t
 in which the order of the places is 
,
,
,
,
,
1
0
1
0
TA
B
B
A
A
p
p
p
p
p
R
OF
O
TO
MF
AB
MAB
TB
AW
MA
p
p
p
p
p
p
p
p
p
p
,
,
,
,
,
,
,
,
,
; 
(
)
T
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
=
+
B
t
, 
(
)
T
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
=
−
B
t
, 
(
)
T
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
−
=
Δ B
t
 etc. 
The functions (
)
j
i t
p
O
,
 and (
)
j
i t
p
I
,
 are calculated as follows: 
 
(
)
(
)
(
)
(
)
,0
,
,
...
,1
,
,0
,
,0
,
9
0
1
0
0
0
=
=
=
=
t
p
O
t
p
O
t
p
O
t
p
O
A
A
B
A
A
A
 
 
(
)
(
)
(
)
(
)
,0
,
,
...
,0
,
,0
,
,1
,
9
1
1
1
1
1
=
=
=
=
t
p
O
t
p
O
t
p
O
t
p
O
A
A
B
A
A
A
etc. 
 
(
)
(
)
(
)
(
)
,0
,
,
...
,0
,
,0
,
,1
,
9
0
1
0
0
0
=
=
=
=
t
p
I
t
p
I
t
p
I
t
p
I
A
A
B
A
A
A
 
 
(
)
(
)
(
)
(
)
,0
,
,
...
,1
,
,0
,
,0
,
9
1
1
1
1
1
=
=
=
=
t
p
I
t
p
I
t
p
I
t
p
I
A
A
B
A
A
A
 
etc. 

 
Petri Net Models of DEDS 
85 
The incidence matrix using Equation (7.27) or (7.28) is 
 
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
=
0
1
1
0
1
1
0
1
1
0
0
1
0
1
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
1
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
0
0
0
0
1
0
1
1
0
1
0
R
OF
O
TO
MF
AB
MAB
TB
AW
MA
TA
B
B
A
A
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
A
 
  
(7.32)
 
The matrix columns from the 1st up to 11th one correspond to the transitions 
9
2
1
,...,
,
,
,
t
t
t
t
t
B
A
, respectively. The initial marking is 
 
(
)
T
1,1,0,0,1,0,0,0,0,0,0,1,0,1
0 =
m
 
(7.33) 
The next marking after the initial one is obtained through firing 
At , i.e., 
 
(
)
(
)
T
T
0
1,1,0,0,1,0,0,0,0,0,0,1,1,0
0
,...,
0,0,1
=
+
=
′
A
m
m
 
(7.34) 
The matrix representation of a Petri net can be simplified for a Petri net class 
called pure Petri nets. Figure 7.7 shows the case when the given Petri net includes 
a direct loop. A Petri net without the direct loops is called the pure Petri net. The 
limitation due to the structural purity condition is relatively small. A direct loop 
can be easily removed by the rearrangement shown in Figure 7.8, which practically 
does not bring about any discrepancy with the real system. 
Figure 7.7. A direct loop in a Petri net 
 
 t
p

86 
Modeling and Control of Discrete-event Dynamic Systems 
Figure 7.8. Removal of a direct loop from a  Petri net 
Formally, a Petri net is pure iff the following implication holds: 
 
 
 
(
)
(
)
F
p
t
F
t
p
∉
⇒
∈
,
,
 
(7.35) 
Now let us return to the matrix simplification question. Consider a pure Petri 
net. A vector 
it  can be associated with 
T
ti ∈
 in a different way than using 
Equation (7.24), in particular,  
 
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
i
P
ki
i
i
i
t
t
t
t
.
.
2
1
t
,     
(
)
(
)
(
)
(
)
⎪⎩
⎪⎨
⎧
∈
+
∈
−
=
otherwise
0
,
t
if
,
,
 
if
,
i
F
p
p
t
W
F
t
p
t
p
W
t
k
k
i
i
k
i
k
ki
 
(7.36) 
The number of the vector 
it  entries is equal to the number of places in set P, i.e., 
P . In the simplified case is the incidence matrix  
 
(
)
m
t
t
t
A
,....,
,
2
1
=
  
(7.37) 
As before the new marking is given by  
 
x
A
m
m
+
=
′
 
(7.38) 
For the vector x  see Equation (7.30). The reader can see why a direct loop in a 
Petri net cannot be represented in the simplified way. The direct loop case cannot 
be distinguished from the one when no arc is connecting the place 
k
p  with it . 
The Petri net in Figure 7.6 is a pure Petri net. The simplified incidence matrix is 
 t
p
p`

 
Petri Net Models of DEDS 
87 
 
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
=
0
1
1
0
1
1
0
1
1
0
0
1
0
1
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
1
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
0
0
0
0
1
0
1
A
    
(7.39)
 
The modeling power of Petri nets can be increased by adding inhibitors and/or 
incidentors as a new kind of oriented arcs. They are defined next. 
Definition 7.7. The Petri net with inhibitors and incidentors is defined by 
 
(
)
INHD
INHD L
INHD
PN
PI
,
,
,
λ
=
 
(7.40) 
where  
PN is the Petri net according to Definition 7.2; 
{ }
1,0
×
×
⊆
T
P
INHD
, and the set of triples (p, t, 0) for p∈P and t∈T  is 
called the set of inhibitors, and the set of triples (p,t,1) is called the set of 
incidentors;  
INHD
INHD
L
INHD →
:
λ
 is the function mapping the inhibitors or 
incidentors onto a set of logical assertions specifying the function of these 
special group of arcs. The assertions are related to markings of place p in (p, 
t, 0) or (p, t, 1). Such an assertion specifies additional conditions for the 
fireability of a transition pointed by the arc. For an inhibitor, a condition is 
defined stating when a transition is not fireable. Inversely, for an incidentor, 
a condition is stating when the corresponding transition is fireable.  
 
For example, the following assertion is mapped to an inhibitor: a transition is 
not fireable if its inhibitor pre-place has one or more tokens. Another is that it is 
fireable if its incidentor pre-place has exactly three tokens. All the other rules for 
the net are in effect. Inhibitors and incidentors bring about additional firing 

88 
Modeling and Control of Discrete-event Dynamic Systems 
conditions about transitions. However, they do not affect the token flow during any 
transition firing in a sense that no tokens “flow” through them.  
Figure 7.9. Modification of the Petri net in Figure 7.6 using an inhibitor 
Example 7.2. Usage of inhibitors will be illustrated by means of a fine structural 
change in the Petri net from Figure 7.6. After substituting the arc (
)
MF
p
t ,
6
 for 
(
)
MF
p
t ,
7
 we have the modification; see Figure 7.9. The new structure indicates 
that after firing 
6t  the machine M is again free. As assumed and modeled in Figure 
7.6, it is not possible to enter any further workpiece into M for some technological 
Processing part A → adding B → assembling AB 
 
pA0 
pA1 
pTA
pMA
pTB
pMAB
pABW 
pTO 
pO 
pOF
pR
pB0
pB1
pMF
tA 
t1 
t2
t4
t5
t6
t7
t8
t9
tB
pAW
t3

 
Petri Net Models of DEDS 
89 
reasons. Another way to express the situation is to use an inhibitor (
)
0,
, 1t
p ABW
 
according to Figure 7.9. 
Figure 7.10. Flexible and automatic assembly of printed circuit board 
Example 7.3. Another flexible manufacturing system will be considered in this 
example (Zhou and Leu 1991). It is a two robot flexible system for the automatic 
assembly of printed circuit boards. The block scheme of the system is in Figure 
7.10. The two robot system cares for automatic picking and inserting electronic 
components onto a printed circuit board (PCB). The components are supplied from 
a feeder. The sequence of operations to be realized are: picking up a component 
from the feeder by a robot, pulling back the robot arm, moving to the workspace, 
inserting the component, pulling back the robot arm, moving back to the feeder etc., 
cyclically. 
Only one robot can be in the feeder and workspace, respectively. Therefore the 
system control should avoid a collision of robots in those areas. The robot arm is 
pulled back after component picking and inserting. Both robots with their arms 
pulled back can move in the space between the feeder and the PCB. The Petri net 
describing the system behavior is in Figure 7.11. The meaning of places and 
transitions with respect to the real system are inscribed in the Petri net. The places 
3
p  and 
4
p  ensure that picking or inserting is allowed only for one of the robots. 
The initial marking is given in Figure 7.11. In the initial state, both robots are 
available. At the beginning it is assumed that the robots are close to the feeder area. 
Both the feeder area and the workspace are free at the beginning. The Petri net 
shows possible continuations of the system behavior.  Either of robots R1 or R2 
picks up the electronic component from the feeder. Components of the Petri net 
show that either transition 11
t  or 
21
t
 can fire separately, but not together. It is not 
specified in the Petri net which transition fires, and when. The next required step 
(or in the Petri net terms: the next transition firing) has to be activated by a system 
control. We will deal with this question in the following sections. In what follows 
an attention will be focused on a kind of indeterminism contained in Petri nets. A 
potential possibility of an indeterministic situation arises when there is more than 
 
F e e d e r w ith
c o m p o n e n ts
R o b o t 2
W ork s p a c e  w ith
p rin te d  c irc u it b o a rd
R o b o t 1

90 
Modeling and Control of Discrete-event Dynamic Systems 
one arc coming out of a place. It is the case of the places 
3
p  and 
4
p in Figure 7.11. 
Using inhibitors and incidentors is one possible way of avoiding this 
indeterminism. Let in the analyzed system the robot R1 has always a preference 
(priority) before the robot R2. Figure 7.12 shows the use of the inhibitors for this. 
An inhibitor (
)
0,
, 21
11 t
p
disables firing of the transition 
21
t
 by the marking 
depicted in Figure 7.12. The effect of using the other inhibitor when both places 
14
p
 and 
24
p
 have a token is similar. Another possible behavior would be the 
alternation of the robots as shown in Figure 7.13. 
Figure 7.11. Petri net for the printed circuit board (PCB) assembly 
 
p11 
z 
p12 
t12 
t11 
z 
p13 
p14 
t14 
t13 
p15 
t15 
p16 
p17 
t17 
t16 
p21
z 
p22
t22 
t21 
z 
p23
p24
t24 
t23 
p25
t25 
p26
p27
t27 
t26 
z 
z 
p3 
p4 
p1 
p2 
z 
z 
Component for R1
available 
R1_fa 
R2_fa 
Component for R2
available 
Feeder area 
available
PCB area 
available
R1 picking 
R2 
picking 
arm R1 re- 
turning 
arm R2 
retur- 
ning 
R1 moving 
to PCB 
R1 moving 
to PCB 
R2 
avail. 
R1 
avail. 
R1 inserting 
R1 inser- 
 ting 
arm R1  
returning 
arm R2 
retur- 
ning 
R1 moving 
to FA 
R2 
moving 
to FA

 
Petri Net Models of DEDS 
91 
Figure 7.12. Petri net with inhibitors for the printed circuit board (PCB) assembly 
7.4 Petri Net Classes 
In Sections 7.1–7.3 we dealt with the most used standard Petri net definitions. They 
serve as basic or reference Petri net models. There are many modifications to the 
basic models. According to David and Alla (1994), they can be classified as 
abbreviations or extensions. 
 
p11 
z 
p12 
t12 
t11 
z 
p13 
p14 
t14 
t13 
p15 
t15 
p16 
p17 
t17 
t16 
p21
z 
p22
t22 
t21 
z 
p23
p24
t24 
t23 
p25
t25 
p26
p27
t27 
t26 
z 
z 
p3 
p4 
p1 
p2 
z 
z 
Component for R1
available 
R1_fa 
R2_fa 
Component for R2
available 
Feeder area 
available
PCB area 
available
R1 picking 
R2 
picking 
arm R1 re- 
turning 
arm R2 
retur- 
ning 
R1 moving 
to PCB 
R1 moving 
to PCB 
R2 
avail. 
R1 
avail. 
R1 inserting 
R1 inser- 
 ting 
arm R1  
returning 
arm R2 
retur- 
ning 
R1 moving 
to FA 
R2 
moving 
to FA
°
°

92 
Modeling and Control of Discrete-event Dynamic Systems 
Figure 7.13. Petri net for printed circuit board (PCB) assembly with alternation of robots 
Abbreviations of the basic Petri net model enable one to represent a DEDS in a 
simplified way, for example, colored Petri nets, Petri nets with capacities and 
others. An abbreviated representation can always be converted to a basic Petri net 
model though the latter may be much larger and less transparent.  
On the other hand, the extensions are actually Petri net models with additional 
functional rules to those defined for the basic model. Extensions arise, for example, 
when special arcs called inhibitors and incidentors are added to the arc set or when 
further firing conditions are added to the transitions. The additional conditions may 
be deterministic, stochastic, timed etc. In such a case the transition firing is bound 
 
p11 
z 
p12 
t12 
t11 
z 
p13 
p14 
t14 
t13 
p15 
t15 
p16 
p17 
t17 
t16 
p21
z 
p22
t22 
t21 
z 
p23
p24
t24 
t23 
p25
t25 
p26
p27
t27 
t26 
z 
z 
p3a
p4 
p1 
p2 
z 
z 
Component for R1 
available 
R1_fa 
R2_fa 
Component for R2 
available 
Feeder area 
available
PCB area 
available
R1 picking 
R2 
picking 
arm R1 re- 
turning 
arm R2 
retur- 
ning 
R1 moving 
to PCB 
R1 moving 
to PCB 
R2 
avail. 
R1 
avail. 
R1 inserting 
R1 inser- 
 ting 
arm R1  
returning 
arm R2 
retur- 
ning 
R1 moving 
to FA 
R2 
moving 
to FA
p3 
p4a

 
Petri Net Models of DEDS 
93 
to external or internal states or events – a kind of model synchronization. 
Extensions are capable of representing many reactive control functions and 
therefore, the extension class is called the Petri nets interpreted for control. The 
chosen abbreviation and extension classes will be treated in the sequel. 
Petri net models within each class can further be classified into sub-classes, 
with respect to the structural properties. Consider the class of standard Petri nets 
specified by Definition 7.2. The following sub-classes can be distinguished 
1. Binary Petri nets. 
A Petri net is called binary or ordinary if all its weights are 1s, i.e.,  
 
{ }
1
:
→
F
W
 
(7.41) 
An example of a binary Petri net is in Figure 7.3. 
2. Petri net state machines. 
A Petri net state machine is a binary Petri net such that each transition has 
exactly one input place (pre-place) and exactly one output place (post-
place). Given formally: 
 
1
:
=
•
=
•
∈
∀
t
t
T
t
 
(7.42) 
The name of this sub-class suggests that it is very close to the finite 
automata models. Figure 7.14 shows an example of the vending machine 
model. The machine accepts only 5 cent and 10 cent coins and it vends a 
bottle of coke for 20 c or candy for 15 c. Arrival of a token in places 
4
3, p
p
 starts counting the time interval “int”. It starts a counting renewal if 
the interval has not expired. If the required amount of money has not been  
accepted within the interval “int” the machine returns coins and waits. 
3. Marked graphs. 
A binary Petri net is called a marked graph or event graph if each place has 
exactly one pre-transition and exactly one post-transition. Formally, 
 
1
:
=
•
=
•
∈
∀
p
p
P
p
 
(7.43) 
Figure 7.13 is an example of a marked graph. 
4. Free-choice nets. 
A free-choice net is a binary Petri net such that every arc going out of a 
place is either (a) unique arc incoming into a transition and no other arcs go 
out of the place or (b) there are more arcs, but each of them is unique arc 
going into the transition. Figure 7.15 shows elementary structures 
characterizing the free-choice sub-class. Formal description of the sub-
class is 

94 
Modeling and Control of Discrete-event Dynamic Systems 
waiting 
on coin 
      t1 
other coin 
 p1 
 t2 
return 
p2 
t3 
t4
deposit 5c
coin
deposit 10c
coin
start time  
interval int
start time  
interval int
t5
no coin in 
int, return
t6 
no coin in 
int, return
p3
p4
p5
p6
other  
coin 
return of 
other coin
other  coin
return of 
other  coin
deposit 
5c coin
t7
t8
 p7 
 p8 
deposit 10c
coin
deposit 
10c
5
10
15 
20 
t9
deposit 5c 
coin
get coke for 20c
get candy for 15c
t10
t11
 
Figure 7.14. Petri net state machine model of a vending machine 
 
(
) { }
p
p
p
P
p
=
•
•
≤
•
∈
∀
or
1
:
 
(7.44) 
where (
)
•
p
 are all post-transitions of place p, and (
)
•
• p
 means the set of 
pre-places of all transitions of the set (
)
•
p
.  

 
Petri Net Models of DEDS 
95 
Note that in Figure 7.15, the first statement of Equation (7.44) holds for 
1p , 
2
p , 
4
p , and 
5
p : 
0
,0
,1
,1
5
4
2
1
=
•
=
•
=
•
=
•
p
p
p
p
, and the 
second one holds for 
3
p : (
)
{
}
3
2
3
,t
t
p
=
•
, (
)
{
} { }
3
3
2
3
,
p
t
t
p
=
•
=
•
•
. 
 
p1 
p2 
p3 
p4 
p5 
t1
t2
t3 
 
Figure 7.15. A free-choice net example 
5. Safe Petri nets. 
A Petri net is safe if for all markings reachable from 
0
M :  
 
(
)
1
,
≤
∈
∀
ip
M
P
p
 
(7.45) 
For example the Petri net in Figure 7.3 is safe. 
Each sub-class is specific as to various Petri net properties, which will be analyzed 
in the next chapter. 
7.5 Petri Nets Interpreted for Control 
In preceding sections Petri nets were used as a tool for discrete event system 
description from the observer’s point of view. Internal structural relations in the 
system are expressed according to the Petri net components and rules. The 
relations determine the Petri net behavior so that the particular Petri net specifies 
the actual behavior and function of the represented system. The question of how to 
achieve the required behavior using Petri nets has not been treated yet. 
DEDS control problems were considered in Chapter 4. It was shown that the 
system SYST in Figure 4.1 can be modeled as a Petri net. This was the main 
approach in the previous parts of this textbook. Now, we are interested in the 
DEDS control design. The control system C in Figure 4.1 can be represented as a 
Petri net as well. For that purpose the Petri net introduced in Definition 7.2 should 
be augmented. This new class of the modeling tools will be called the Petri nets 
interpreted for control. 

96 
Modeling and Control of Discrete-event Dynamic Systems 
Definition 7.8. A Petri net interpreted for the DEDS control is given by the 
quintuple 
(
)
COM
LOG
PI
PC
,
,
,
,
ζ
ψ
=
 
(7.46) 
where  
PI is a Petri net given by Definition 7.7; 
LOG
T →
:
ψ
 is a function mapping the transition set T onto a set of  
logical assertions containing logical variables, predicates, events, and the 
empty symbol; 
COM
P →
:
ζ
 is a function mapping the set of places onto a set of value 
assignments to control variables including the empty variable, and of 
events, the value assignments and events are realized when the place 
marking changes from 0 to a non-zero value. 
The Petri nets firing rules are completed in a natural way. A transition 
T
ti ∈
of 
a Petri net interpreted for control (PC) is fireable if all fireability conditions for 
Petri nets with inhibitors and incidentors are fulfilled and all logical assertions 
mapped from the transition it  are true. Logical assertions are logical expressions 
and predicates consisting of variables aggregated into vector ( )t
u
; See equation 
(4.1) in Chapter 4. These variables are outputs of the controlled system and inputs 
to the control system (as shown in Figure 4.1). 
COM serves as a set of control commands. The commands are disabled when in 
a considered place to which they are mapped there is no token, and they are 
enabled when a token or tokens arrive in the place. Nature of the commands can be 
twofold: level commands (corresponding to setting of the control variable values) 
or impulse commands (corresponding to event forcing). This issue will be treated 
in detail later in connection with Grafcet. It is quite understandable that the 
commands correspond to the variable 
( )t
w
 in Equation (4.7) related to the 
feedback structure of Figure 4.1.  
As mentioned in the preceding section, Petri nets interpreted for control are 
sometimes called synchronized Petri nets (David and Alla 1994) because the 
transition firings are conditioned and synchronized by external variables. 
Now we are able to generate a Petri net interpreted for control for the flexible 
manufacturing system depicted in Figure 5.2. This task is simplified with help of 
the Petri net in Figure 7.9. This problem was discussed in Chapter 4. The Petri net 
of the controlled system is always structurally very close to the Petri net interpreted 
for control of that system. Usually it is not the same. The Petri net interpreted for 
control PC is in Figure 7.16. Meanings of logical expressions mapped to transitions 
of the Petri net in Figure 7.16 are described in Table 7.3. Notation of control 
variables is given in Table 7.4. 

 
Petri Net Models of DEDS 
97 
pA0 
pA1 
pTA
pMA
pTB
pAB
pTO
pO
pOF
pR
pB0
pB1
pMF
tA 
t1 
t2
t3
t4
t5
t6 
t7
t8
tB
ia 
AM 
tam
OPA ea
ib
BM
tbm
pMA
OPAB
eab 
ABO 
tabo 
ABN 
tabn  
Figure 7.16. Control: processing of part A → adding B → assembling AB 

98 
Modeling and Control of Discrete-event Dynamic Systems 
Table 7.3. Description of logical conditions in the Petri net of Figure 7.16 
Logical Expression 
Meaning 
ia=0 
No part of kind A at the input 
ia=1 
A part A at the input 
tam=0 
No end of transfer of A into the machine M 
tam=1 
End of transfer of A into the machine M 
ea=0 
No end of processing A in the machine M 
ea=1 
End of processing A in the machine M 
ib=0 
No part of kind B at the input 
ib=1 
A part B at the input 
tbm=0 
No end of transfer of B into the machine M 
tbm=1 
End of transfer of B into the machine M 
eab=0 
No end of AB assembly 
eab=1 
End of AB assembly 
tabo=0 
No end of transfer of AB to the output 
tabo=1 
End of transfer of AB to the output 
tabn=0 
AB did not leave conveyor 
3
C  
tabn=1 
AB left conveyor 
3
C  
Table 7.4. Commands realized by control variables 
Commands 
AM 
For robot to transfer a part A from the input into the machine M 
OPA 
For start of processing A 
BM 
For robot to transfer a part B from the input into the machine M 
OPAB
To start the assembly of AB 
ABO 
For transfer AB on the output 
ABN 
To move AB out of conveyor 
3
C  

 
Petri Net Models of DEDS 
99 
7.6 Petri Nets with Capacities 
The modeling convenience of Petri nets can be enhanced by introducing the place 
capacity. The capacity restricts the number of tokens that can be located in a place 
as the following definition formally states. 
Definition 7.9. The Petri net with capacities is given by a couple 
 
(
)
K
,
PN
PCA =
 
(7.47) 
where PN is a standard Petri net by Definition 7.2 and K is the function 
 
+
→N
P
:
K
 
(7.48) 
The firing rules for Petri nets with capacities are 
 
(
) (
)
[
  
          
          
K
j
i
i
i
t
m
m
t
m
m
t
>
⇔
Δ
+
≥
∧
≤
−
 
(7.49) 
where capacities are expressed by a vector 
 
(
)
(
)
(
)⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
n
p
p
p
K
K
K
K
2
1
M
 
(7.50) 
According to the firing rules it is not allowed to put into a place of a Petri net 
with capacities more tokens than its capacity.  Such nets are also called finite-
capacity Petri nets. The next manufacturing system example illustrates some 
essential differences between a traditional modeling method using Petri nets, 
termed as process-oriented modeling, and a resource-oriented modeling method 
using finite-capacity Petri nets. The latter was pioneered by Wu (1999) and later 
developed for various applications (Wu and Zhou 2001, 2004, 2005). 
Example 7.4. An automated manufacturing system is shown in Figure 7.17. It 
contains machines M1 and M2 that can concurrently handle two types of parts, A 
and B. An A-part has two operations 1 and 2 to be processed by M1 and M2, 
respectively while a B-part requires M2 to process first, and then M1. We assume 
that raw materials are continuously supplied while the produced parts are shipped 
away when they are ready, i.e., neither starving nor blocking exists. Each machine 
can process a part at a time. 
By modeling each part’s process using two places and two types of raw 
material availability using two separate places, we can derive the model as shown 
in Figure 7.18. 

100 Modeling and Control of Discrete-event Dynamic Systems 
 
Figure 7.17. An automated manufacturing system producing A- and B-type parts 
n
n
pA0
pA1
pA2
pB0
pB1
pB2
pM1
pM2
tA1
tA2
tA3
tB1
tB2
tB3
 
Figure 7.18. Petri net model resulting from a process-oriented modeling method 
For i=0, 1 and 2, places pAi models raw pieces for part A are available, A-part’s 
operations 1 and 2, respectively. For i=1, 2 and 3, transitions tAi models starting the 
first operation, second operation of a raw piece for part A and completion of an A-
part, respectively. The explanations hold true for pBi, tBi and B-parts. Places pM1 and 
pM2 models the availability of machines 1 and 2. The arcs are added according to 
the operational requirements in order to produce A- and B-parts. 
A resource-oriented modeling method models each resource as a finite-capacity 
place whose capacity is the resource’s processing capability. In this system, since 
machine i has single capacity for i=1 and 2, place pi has capacity K(pi)=1. Place p0 
models the raw material supply and product take-away and, hence, K(p0)=n can be 

 
Petri Net Models of DEDS 101 
viewed as infinity. From the resource-oriented modeling viewpoint, an A-raw piece 
visits each resource in a pre-defined order starting from p0, to p1 and p2, and then 
back to p0.  Similarly, a B-raw piece visits each resource in a pre-defined order 
starting from p0, to p2 and p1, and then back to p0.  They can be built separately as 
shown in Figure 7.19a, b. Their union (by sharing those same places and transitions 
if applicable) leads to the Petri net model as shown in Figure 19c. Transition tij 
means an A- or B-piece is being transferred from resources i to j. For example, t01 
means an A-rawpiece being transferred from raw material supply modeled by p0 to 
machine 1 modeled by p1. Transition t21 means a B-semi-finished piece being 
transferred from machine 2 modeled by p2 to machine 1 modeled by p1. 
p1
t12
t01
t20
n
p0
t21
t10
t02
p2
p1
t12
t01
t20
n
p2
p0
p1
t21
t10
t02
n
p2
p0
a.
b.
c.
 
Figure 7.19. A finite-capacity Petri net model resulting from a resource-oriented modeling 
method 

102 Modeling and Control of Discrete-event Dynamic Systems 
and deadlock control. On the other hand, a process-oriented Petri net modeling 
method is more generic as it can model the details and more complex resource 
requirements, e.g., an operation requiring multiple resources.  
According to Murata (1989), each finite-capacity Petri net can be transferred 
into an equally functioning standard Petri net without capacities called the 
complementary Petri net. We leave this to the reader as an exercise problem. 
7.7 Problems and Exercises 
7.1. Show that the Petri net in Figure 7.20 fits the Petri net Definition 7.2. 
Figure 7.20. Petri net for Exercise 7.1 
Specify the given Petri net using Definition 7.6. 
7.2. Figure 7.21 shows a manufacturing system consisting of three production cells 
VA, VB, VC and a robot room SR. Transport of the parts to be processed in the 
system is executed by four robots. Their possible movements are indicated with 
arrows. Only one robot can move through passages between the cells. Let the robot 
movements be controlled by the semaphores located at the passages. The robot 
transfers are subordinated to the following rules: 
1. Maximum number of robots in VA and VB together can be 3. 
2. Maximum number of robots in VB and VC together can be 2. 
Solve the following problems: 
a. Design the Petri net describing the operation of the system with respect to 
the robot motion. 
b. Design the Petri net interpreted for the control specifying the robot motion 
control. Add to the system sensors necessary for the control. 
p1 
p2 
p3
t1 
t2 
It is clear that the resource-oriented modeling method can lead to a much 
simpler Petri net model and thus bring certain advantages in the system analysis 

 
Petri Net Models of DEDS 103 
Figure 7.21. Manufacturing system with four robots 
7.3. A Petri net is given in Figure 7.22.   The initial marking is 
(
)
T
0
0
0
1
=
m
.  
a. Compose vectors 
i
i
i
t
t
t
Δ
−
+
,
,
,
3,2,1
=
i
. 
b. Consider sequential firing of transitions 
.
,
,
3
2
1
t
t
t
Prove validity of the 
expression 
[
[
[
3
3
2
2
1
1
0
m
m
m
m
>
>
>
t
t
t
 and find values of 
3
2
1
,
,
m
m
m
. 
Figure 7.22. Petri net for Exercise 7.3 
7.4. A pure Petri net is given by the following vectors: 
 
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
=
Δ
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
=
Δ
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
=
Δ
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛−
=
Δ
1
1
0
1
1
,
1
0
1
0
0
,
0
1
0
1
0
,
0
0
1
1
1
4
3
2
1
t
t
t
t
 
The vectors correspond to transitions t1–t4. The initial marking is  
 
SR 
VC
VA
VB
 
p1 
p2
p3
t1
t2 
t3 

104 Modeling and Control of Discrete-event Dynamic Systems 
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
0
0
0
0
1
0
m
.  
Draw the Petri net in the graphic form and check if the transition 
1t is fireable at 
0
m . 
7.5. A factory transportation system using automatic guided vehicles is 
schematically depicted in Figure 7.23.  Semi-products S1 are unloaded from the 
belt conveyor B1 and transported via the track T1 with vehicle V1 to the 
processing center C3. The emptied vehicle V1 returns back along the same track to 
load another semi-product from B1. Semi-products S2 are transported to the center 
C1. After processing in C1 they are transported with V3 swinging between C1 and 
C2. V4 transports semi-products S2 after processing in C3 to C2. S1 and S2 are 
assembled in C2 and transported to the factory output.  
Describe the transportation system behavior using a Petri net. For that purpose 
divide the tracks into sections in which there can always be only one vehicle. 
Specify the behavior so that the transport is prevented from the vehicle collision. 
Show how the Petri net can be used for the construction of the Petri net interpreted 
for control of the system. The system should be equipped for the control purposes 
with sensors detecting vehicle arrival in and departure of the track sections.  
7.6. Propose for the robotic cell depicted in Figure 6.4 (Exercise 6.2) a Petri net 
specifying the required dynamic behavior of the cell. 
7.7. Using the Petri net proposed in the previous Exercise 7.6, create a Petri net 
interpreted for control, which represents the control function ensured by a control 
computer such that the required function of the cell is achieved. 
7.8. Convert the finite-capacity Petri net model in Figure 19c into an equivalent 
complementary Petri net. Suppose Machine M1’s processing capacity becomes 2 
and M2’s becomes 3. What is the new equivalent complementary Petri net? 

 
Petri Net Models of DEDS 105 
C1
C3
C2
V1
V2
V3
V4
V5
B1
B2
B3
S1
S2
T1
T2
T3
T4
T5
 
Figure 7.23. A factory AGV transportation system 

8 
Properties of Petri Nets 
8.1  Marking Reachability 
Many important properties of Petri nets can be analyzed by means of Petri net 
reachability and coverability graphs. The reachability graph relates to the Petri net 
marking reachability. A frequently asked question is whether a given marking m  
is reachable by a transition firing sequence. First let us define the transition firing 
sequence. The starting marking is important in that question. 
Definition 8.1. Consider Petri net PN and its marking m . The sequence 
 
ki
i
i
t
t
t
...
~
2
1
=
σ
 
(8.1) 
is called the transition firing sequence starting from marking m  iff  
 
T
t
T
t
T
t
ki
i
i
∈
∈
∈
,
.
.
.
,
,
2
1
 
(8.2) 
 
1
1
1
,
i
i
t
m
m
m
t
Δ
+
=
≤
−
 
(8.3) 
 
2
2
1
2
1,
i
i
t
m
m
m
t
Δ
+
=
≤
−
 
(8.4) 
 
k
k
i
k
k
k
i
t
m
m
m
t
Δ
+
=
≤
−
−
−
1
1,
 
(8.5) 
The meaning of the notation in Equations (8.2)–(8.5) has been described in 
Section 7.3. Marking 
k
m  obtained via a transition firing sequence starting from 
marking m  is called the reachable marking in PN from m . For handling 
convenience, assume that m is reachable from m . 
Substituting Equation (8.3) in Equation (8.4) yields 
 
2
1
2
i
i
t
t
m
m
Δ
+
Δ
+
=
 
(8.6) 
By analogy we obtain 

108 Modeling and Control of Discrete-event Dynamic Systems 
 
∑
=
Δ
+
=
k
s
i
k
s
1
t
m
m
 
(8.7) 
The validity of Equation (8.7) alone is the necessary condition for the sequence 
ki
i
i
t
t
t
...
~
2
1
=
σ
 to be the transition firing sequence starting from m . If Equation 
(8.7) does not hold, σ~  is not a transition firing sequence starting from m . The 
sufficiency can be formulated as follows: σ~  is a transition firing sequence starting 
from m  if  
 
∑
=
Δ
+
=
r
s
i
r
s
1
t
m
m
, 
{
}
k
r
,...,
2,1
∈
∀
 
(8.8) 
and 
 
m
t
≤
−
1i
  and   
1
−
−≤
r
ir
m
t
, 
{
}
k
r
,...,
3,2
∈
∀
 
(8.9) 
The fireability of 
sit
 at 
1
−
s
m
 for pure Petri nets can be formulated in the 
following way: 
sit  is fireable at 
1
−
s
m
 iff  
 
0
t
m
≥
Δ
+
−
si
s 1
. 
(8.10) 
Considering Equation (8.10) in a different formulation: 
ki
i
i
t
t
t
...
~
2
1
=
σ
 is a 
transition firing sequence starting in marking m for the class of pure Petri nets iff  
 
∑
=
Δ
+
≤
r
s
is
1
t
m
0
,  
{
}
k
r
,...,
2,1
∈
∀
 
(8.11) 
To provide a detailed explanation of the above reasoning, consider a non-pure 
Petri net. Let a transition has one direct loop consisting of one arc with weight 
(
)
i
j p
t
W
,
 going back from transition 
jt  to its pre-place 
ip , and another arc going 
from 
ip
 to 
jt
 with 
weight 
).
,
(
j
i t
p
W
 If 
)
(
)
,
(
i
j
i
p
M
t
p
W
>
 and  
(
)
(
)
i
j
j
i
p
t
W
t
p
W
,
,
<
 then the condition at Equation (8.10) is fulfilled. However, in 
spite of it, 
jt  cannot be fired. Consider the non-sufficiency of Equation (8.7) for 
the following case. Let σ~ =
jt , M(
ip )=1, 
(
)
j
i t
p
W
,
=2 and 
(
)
i
j p
t
W
,
=3. Given 
Mk(
ip )=2, we have Mk(
ip )=M(
ip )+Δ
jt . However, Mk(
ip ) is not reachable from 
M(
ip ) and σ~  is not a fireable sequence at M(
ip ). 
Equation (8.10) is a necessary and sufficient condition for the fireability of 
sit at 
1
−
s
m
 in pure Petri nets, which can be explained as follows. Entries of vector 
1
−
s
m
 

 
Properties of Petri Nets 109 
are 
(
)
i
s
p
1
−
m
, 
P
pi ∈
∀
, where 
ip  is either a pre-place or post-place of 
sit . In pure 
Petri nets it is impossible that both cases occur simultaneously. In the former case 
(
)
0
=
+
i
i
p
st
 and 
(
)
0
≠
−
i
i
p
st
 so that from inequality 
0
t
m
≥
Δ
+
−
si
s 1
 we have 
(
)
(
)
(
)
(
)
(
)
0
1
1
≥
−
=
−
+
−
−
−
+
−
i
i
i
s
i
i
i
i
i
s
p
p
p
p
p
s
s
s
t
m
t
t
m
, which is the fireability 
condition by definition. In the latter case 
(
)
0
≠
+
i
i
p
st
 and 
(
)
0
=
−
i
i
p
st
 yields 
(
)
(
)
0
1
=
≥
−
−
i
i
i
s
p
p
st
m
 from Equation (8.10), which is always true because 
(
)
0
1
≥
−
i
s
p
m
. To conclude: in pure Petri nets 
0
t
m
≥
Δ
+
−
si
s 1
 is equivalent to 
(
)
(
)
P
p
p
p
i
i
i
i
s
s
∈
∀
≥
−
−
,
1
t
m
, or for vectors 
−
−≥
si
s
t
m
1
. 
The most important reachability property in Petri nets is related to the initial 
marking value 
0
m . In PN the set of all reachable markings from 
0
m  is simply 
called the reachability set of PN. From that we have the following definition. 
Definition 8.2. In PN, marking 
k
m  is reachable iff a transition firing sequence 
starting in 
0
m  exists for which 
∑
=
Δ
+
=
k
s
i
k
s
1
0
t
m
m
. The set of all reachable 
markings is called the reachability set of PN and is given by 
 
(
) {
}
reachable
 
is
0
k
k
PN
R
m
m
m
=
 
(8.12) 
0
m  is defined as reachable: 
(
)
0
0
m
m
PN
R
∈
 as introduced after Definition 8.1. 
Sometimes it is useful to have an analogously defined set of markings 
reachable from other markings 
0
m
m ≠
. Such a set is called the reachability set 
from m and denoted as 
( )
m
PN
R
. 
8.2. Reachability Graph 
The reachability set and firing sequences for a given Petri net can be graphically 
visualized using an oriented graph called the reachability graph.  
Definition 8.3. Consider a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 having a finite 
reachability set. The simple labeled directed mathematical graph (see Definition 
2.2)  
 
(
)
(
)
T
f
f
REL
R
RG
PN
PN
,
,
,
,
,
2
1
0
∅
=
m
 
(8.13) 
is the reachability graph for PN, where 

110 Modeling and Control of Discrete-event Dynamic Systems 
(
)
0
m
PN
R
 is the set of nodes that is the reachability set of PN, and the node 
associated to 
0
M  or 
0
m  is called the root of the graph; 
(
)
(
)
0
0
m
m
PN
PN
R
R
REL
×
⊆
 is the relation defining the set of oriented arcs 
connecting the marking pairs (
)
(
),
,
,
,
0
m
PN
k
i
k
i
R
M
M
M
M
∈
 such that the 
marking 
k
M  is obtained by firing a transition 
jt  at 
i
M ; 
1f  is the function mapping P into the empty set 
∅
=
1
S
 (the function is 
empty); 
T
REL
f
→
:
2
 is a function defining the arc label for each arc 
(
)
(
),
,
,
,
0
m
PN
k
i
k
i
R
M
M
M
M
∈
 where the label is transition 
jt
 whose 
firing changes 
i
M  into 
k
M , and the arc including its label can be denoted 
as a triple (
)
k
j
i
M
t
M
,
,
. Then, the relation REL including labels becomes 
Initial data:  set of graph nodes                      
(
)
{
}
0
0
m
m
=
PN
R
                                        set of oriented labeled arcs     
{
} ∅
=
=
,,
lab
REL
Repetition of the algorithm steps 
E 
N 
D 
node found 
yes 
no 
(
)
?
0
m
m
PN
k
R
∈
yes 
no 
 %
 % 
put 
k
m  into 
(
)
0
m
PN
R
: 
(
)
(
)
{
}
k
PN
PN
R
R
m
m
m
∪
=
0
0 :
put the labeled arc (
)
k
j
i t m
m
,
,
 in 
(
)
{
}
k
j
i
lab
lab
lab
t
REL
REL
REL
m
m
,
,
:
:
∪
=
 
Choice of a node 
i
m from 
(
)
0
m
PN
R
 for which a fireable transition 
jt  
exists and 
j
i
k
t
m
m
Δ
+
=
 and (
)
lab
k
j
i
REL
t
∉
m
m
,
,
 
 
Figure 8.1. Nassi-Schneiderman structogramme of the reachability graph construction 
algorithm 

 
Properties of Petri Nets 111 
 
(
)
(
)
[
{
}
k
j
i
j
PN
k
i
k
j
i
lab
M
t
M
T
t
R
M
M
M
t
M
REL
>
∧
∈
∧
∈
=
0
,
,
,
m
 
 
 
(8.14) 
Instead of functions M0, Mi, and Mk, the corresponding vectors m0, mi, and mk 
can be used for the marking representation as explained before. The vector version 
of the algorithm for the reachability graph construction using Nassi-
Schneiderman’s structogramme is shown in Figure 8.1. The structogramme form of 
the algorithm description supports structured programming without GOTO 
instructions and lessens programming errors. Graphical elements of the 
structogramme are self-explanatory. Decision blocks are depicted as triangles. An 
action always continues through neighboring horizontal edges of the 
structogramme. An exception is the repetition block where the continuation edge 
after the bottom edge is the top edge of the whole repeated action group. “%” 
denotes the empty action, i.e., a skip to the next edge. 
More about reachability analysis can be found in Hudák (1999), Jeng and Peng 
(1999) and Wang et al. (2004). 
Example 8.1. The reachability graph construction will be illustrated on a case study 
of a filling and mixing system with two tanks in Figure 8.2. V11, V12, V21, and V22 
are valves. The required volumes of two liquids to be mixed are prepared using 
tanks T1 and T2. The process start is initiated by the push-button S. Valves V12 and 
V22 are opened simultaneously when the liquid levels in both tanks achieve their 
maximum detected by the corresponding sensors L1max and L2max, respectively. 
Valves V12 and V22 are closed separately (independently) when the level Limin in 
the corresponding tank is detected and the tank is immediately filled up: valve Vi1 
is opened. After reaching Limax, valve Vi1 is closed and, if the other tank is not yet 
full, it is necessary to wait. Then again both tanks are emptied together. At any 
time the filling can be stopped by the emergency button E. Then regardless of the 
system state both valves V11 and V21 are closed and both valves V12 and V22 are 
opened. The system returns to the ready state when both tanks are empty. 
 
V11 
V21 
V12 
V22 
L1max 
L1min 
L2max 
L2min 
S  start 
E  emergency 
    emptying 
T1 
T2 
T3 
 
Figure 8.2. A two-tank filling system 

112 Modeling and Control of Discrete-event Dynamic Systems 
Now, the Petri net describing the system behavior (Figure 8.3) is analyzed. 
Descriptions of places and transitions are in Tables 8.1 and 8.2. The inhibitors and 
incidentor are used in the net. For the sake of brevity, the inhibitors going out from 
12
p  and 
13
p  are branched from a common arc. 
Figure 8.3. Petri net for the two tank system 
Table 8.1. Description of the Petri net places 
p1
Ready state of the system, both tanks are empty
p2
Filling T1
p3
Filling T2
p4
T1 is full
p5
T2 is full
p6
Emptying T1
p7
Emptying T2
p8
Emergent emptying T2
p9
Emergent emptying T1
p10
T2 is empty
p11
T1 is empty
p12
System is not  in emergency state
p13
System is in emergency state
 
t16 
t17 
t1
t2 
t3
t4
t5
t6
t7
t8
t9
t10
t11
t12
t13
t14







 


 







p1
p2 
p3
p4 
p5
p6
p7
p8
p9
p10
p11 
p12 
p13 
z
z
t15 
z 

 
Properties of Petri Nets 113 
Table 8.2. Description of the Petri net transitions 
t1
Start of filling
t2
T1 achieved its maximum level
t3
T2 achieved its maximum level
t4
Start of both tanks emptying
t5
T1 achieved its minimum level
t6
T2 achieved its minimum level
t7
Interrupt of T2 filling and start emptying by emergency stop
t8
Interrupt of T1 filling and start emptying  by emergency stop
t9
Start of  T2 emptying by emergency stop
t10
Start of  T1 emptying by emergency stop
t11
Confirmation of T2 emptying by emergency stop
t12
Confirmation of T1 emptying by emergency stop
t13
T2 achieved its minimum level
t14
T1 achieved its minimum level 
t15
Transition to the ready state
t16
The emergency push-button activated
t17
Start or transition to the non-emergency state when system is in ready state
 
As already discussed, it is assumed that only one transition can fire in a time 
point. For example an “immediate” parallel emptying of the tanks in case of the 
emergency stop is in fact decomposed into an event sequence. Consider for 
example that a token is in 
3
p  and another in 
4
p , i.e., 
21
V  is open and 
22
V  closed, 
tank 
2
T  is being filled, 
1T  is full, and 
11
V  and 
12
V are closed. If in such a situation 
the emergency switch is pressed, the token from 
12
p  goes into 
13
p . Transition 16
t
 
corresponds to this event. Transitions 
3t  and 
4t cannot fire but 
7t  or 10
t
 can. A 
possible event sequence can be as follows: firing of 
7t , then 10
t . Transition 13
t  
cannot fire due to the inhibitor arc (
)
13
4,t
p
. A next continuation can be 14
t
and 13
t , 
so that we obtain the sequence 
15
13
14
10
7
~
t
t
t
t
t
=
σ
. Note that a verbal description 
of the tank system can hardly be as exact as the Petri net description. 
The particular event sequence depends on the chosen control policy. There is 
no special priority requirement in our example. Anyhow, a decision should be 
made in the control process. From the point of view of the required system 
function, the inhibitors going into 
14
13 and t
t
 are redundant, but they help to reduce 
the reachability graph dimension (Figure 8.4). The reachability graph is in Figure 
8.4. It has been constructed according to the algorithm described above. By using 
inhibitors, the number of nodes has been reduced as indicated above. 
According to Definition 8.3, the reachability graph is a simple labeled directed 
graph (see also Definition 2.2). Labels of the graph are the underlying Petri net 
transitions causing change from one marking to another. The reachability graph is 
always a connected one. It follows from the connectivity according to Definition 
2.6. The marking reachability can be determined using the reachability graph. In 

114 Modeling and Control of Discrete-event Dynamic Systems 
PN, marking 
k
m  is reachable from m  if there exists a directed path a~  from m to 
k
m  in the reachability graph. The reachability set 
(
)
0
m
PN
R
 corresponds to the set 
of all nodes of the reachability graph constructed for PN. 
Figure 8.4. Reachability graph of the Petri net 
 
10000000000 10 
10000000000 01 
 t5
 t16
 t1 
 t16 
 t17 
01100000000 10 
 t16 
 t2 
 t3
 01100000000 01 
 00110000000 10
 01001000000 10
 t7 
 t10 
 01000001000 01 
 00100000100 01 
 t7 
 t10
 00000001100 01 
 t13 
 t14 
 00000000110 01 
 00000001001 01 
 00000000011 01 
 t14 
 t13 
 t15 
 00011000000 10
 t2
 t16
 01001000000 01
 t3
 t16 
 t4
 t9
 t8
 00000110000 10
 t16
 t6
 00100100000 10 
 00000110000 01
 01000010000 10 
 00011000000 01
 00110000000 01
 t10
 t9 
 00010001000 01
00100000100 01 
 t10 
 t9
 t10
 00001000100 01
 t9
 t7
 t11
 t12
 00000010100 01
 t11
 00000101000 01
 t12
 t16
 01000010000 01
 t11
 t8
 t8
 t11
 01000001000 01
 00000010100 01
 t2
 00010010000 10
 t16
 t6
 t16 
 t3 
 00100100000 01 
 t7
 00000101000 01
 t12
 00010010000 01
 t10
 t11
 00001100000 10 
 t16
 00001100000 01 
 t9
 t12
 t6 
 t5 
 10000000000 01 
 t17 
p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11      p12 p13 
 Places distribution in nodes: 
 t5 

 
Properties of Petri Nets 115 
A reachable marking m for which there is no fireable transition is called the 
dead marking. It represents the system deadlock. The system stops in the state 
corresponding to m because no event is executable. 
8.3  Boundedness  
On specifying behavior/control of a DEDS, an important question arises about 
whether the set of states of the specified system is finite. This question is frequent 
in case of real systems. In Petri nets this question concerns boundedness. 
Definition 8.4. Let p be a place of PN, i.e., 
{
}
np
p
p
P
p
,...,
,
2
1
=
∈
. It is bounded 
if for each 
k
m , which is reachable in PN, i.e., 
(
)
0
m
m
PN
k
R
∈
, the following holds: 
 
( )
j
p
k
≤
m
,
+
∈N
j
 
(8.15) 
If a place of PN is bounded by some j for which 
( )
j
p
k
≤
m
, we can state more 
exactly that it is j-bounded. PN is j-bounded if each place of it is j-bounded. PN is 
bounded if all its places are bounded. The relationship between PN’s boundedness 
and finiteness of its reachability set is well-stated in the following theorem. 
Theorem 8.1. A Petri net PN is bounded iff its reachability set is finite. 
Proof. ⇐: Any initial marking is given by finite natural numbers associated with 
places. Weights of a Petri net are finite positive integers. Due to the firing rules in 
Definition 7.5, the generated markings have vector components again including 
finite positive integers. This is due to finite reachability set generated using only a 
finite number of sums of finite integers. The Petri net is bounded. 
⇒: Conversely, if PN is bounded, markings of the reachability set are 
always achieved by a finite number of firings so that the reachability set is finite. 
Corollary 8.1. The reachability graph of a Petri net can be constructed if and only 
if the Petri net is bounded. 
If a Petri net is not bounded, there are an infinite number of markings and 
correspondingly an infinite number of reachability graph nodes. Therefore, it is not 
possible to construct the entire graph. 
Example 8.2. An unbounded Petri net is shown in Figure 8.5. A transition firing 
sequence 
 
etc.
t
t
t
t
t
t
t
t
...
~
2
1
2
1
2
1
2
1
=
σ
, 
(8.16) 
generates the sequence of marking vectors as follows: 

116 Modeling and Control of Discrete-event Dynamic Systems 
 
p1 
p2 
t1 
t2 
p3 
z 
z z 
z
2 
2 
2 
 
Figure 8.5. Unbounded Petri net 
 
 
...
0
0
2
1
...
5
0
0
3
2
1
4
0
0
2
2
1
3
0
0
1
2
1
~
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
=
π
 
(8.17) 
Another firing sequence, t2 t1 t2 t1 …, can generate anthoer sequence of markings:  
 
...
4
2
2
1
...
2
4
2
3
2
1
1
4
2
2
2
1
0
4
2
1
2
1
'
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
=
π
 
(8.18) 
Marking 
(
)
3
p
M
 of 
3
p  grows to infinity. The number of reachability graph nodes 
is unlimited. An application of the reachability graph construction algorithm in 
Figure 8.6 shows that the marking of 
3
p  can be infinite in combination with many 
other markings of 
1p  and 
2
p . These markings are as follows  
 
∞
=
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
∞
,...,
2,1
 
where
2
,...,
6
3
,
4
2
,
2
1
i
i
i
 
(8.19) 
As a result, every place can grow its marking to infinity. 
8.4  Coverability 
The reader could ask how to represent the marking state space for unbounded Petri 
nets in a finite way. It is possible using the coverability property and the so-called 
coverability graph. 
Definition 8.5. Let 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 be a Petri net. A reachable marking 
m of the Petri net PN  is said to be covered by a marking m′  iff 

 
Properties of Petri Nets 117 
  
1 2 1 
0 0 3 
2 4 0
1 2 2 
0 0 4 
2 4 1
1 2 3 
0 0 5 
2 4 2
1 2 4 
0 0 6 
2 4 3
1 2 5 
0 0 7 
2 4 4
1 2 6 
0 0 8 
2 4 5
1 2 7 
0 0 9 
2 4 6
1 2 8 
0 0 10 
2 4 7
3 6 0
3 6 1
4 8 0
3 6 2
4 8 1
3 6 3
5 10 0
4 8 2
3 6 4
3 6 5
4 8 3
5 10 1
6 12 0
5 10 2
4 8 4
6 12 1
t1 
t2 
t2 
t1 
t1 
t1 
t1 
t1 
t1 
t1 
t1 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t2 
t1 
t1 
t1 
t1 
t1 
t1 
t1 
t2 
t2 
t2 
t1 
t1 
t2 
t1 
t1 
t2 
t2 
t1 
t2 
t1 
t1 
t2 
t2 
t1 
t2 
t1 
t2 
t1 
t2 
t2 
t1 
t2 
t1 
t1 
t2 
t1 
t2 
t2 
t1 
t2 
t1 
t2 
 
Figure 8.6. Construction of the reachability graph for an unbounded Petri net; to construct 
the complete graph is impossible 
 
m
m ≥
′
 
(8.20) 
The inequality at Equation (8.20) means that for each pair of corresponding vector 
entries 
( )
( )i
m
i
m
≥
′
 for 
P
i
,...,
2,1
=
. Note that Definition 8.5 concerns any 
marking m′  of PN, not only the reachable ones. Here, recall Definition 7.3 

118 Modeling and Control of Discrete-event Dynamic Systems 
defining both reachable and unreachable Petri net markings. The next definition 
deals with coverability with respect to a reachable marking in the given Petri net. 
Definition 8.6. Given a Petri net PN. A marking m is said to be coverable in PN if 
there is a reachable marking m′  in PN , i.e., 
(
),
0
m
m
PN
R
∈
′
 such that  
 
m
m ≥
′
 
(8.21) 
Definition 8.6 specifically deals with the coverability connected with a given 
Petri net. The initial marking 
0
M  used in the Petri net definition can be replaced 
by vector 
0
m . 
In order to augment the coverability concept for unbounded Petri nets, ω , a 
special symbol for infinity, has been supplemented to the marking value set. A 
slightly modified definition will serve for the augmentation. 
Definition 8.7. Given an unbounded Petri net PN. The function  
 
{ }
{ }
ω
∪
∪
→
+
0
:
N
P
M
 
(8.22) 
is called the augmented marking of PN. For each 
+
∈N
n
: 
ω
ω
ω
ω
ω
≥
=
±
>
,
,
n
n
.  
For example an augmented marking 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
ω
0
10
1
m
 in a Petri net with four places 
is covered by marking 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
′
ω
ω
0
2
m
 because 
≥
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
ω
ω
0
2
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
ω
0
10
1
m
. 
8.5  Coverability Graph 
Like the reachability graph described above for bounded Petri nets, the coverability 
graph is used for unbounded Petri nets. The coverability graph enables to represent 
in a finite form the marking state space so that the finite number of augmented 
markings cover all actual markings of the considered Petri net. The coverability 
graph construction is based on the following theorem. 
Theorem 8.2. Given a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 and two firing sequences 
μ~  and ν~ , where ν~  is a non-empty firing sequence starting from marking 
0
m , μ~  
can also be the empty firing sequence. If μ~  is empty (
ε
μ
~
~ =
), then 
[
0
0 ~
m
m
>
ε
. If 

 
Properties of Petri Nets 119 
 
[
[
m
m
m
′
>
>
ν
μ
~
~
0
   and    
m
m >
′
 
(8.23) 
the Petri net PN is unbounded. 
Proof. Inequality 
m
m >
′
means that, at least for one entry of those vectors, 
 
( )
( )i
m
i
m
>
′
, 
P
i
,...,
2,1
∈
 
(8.24) 
while for the other entries for which Equation (8.24) is not valid, the equality holds. 
The vector entries considered in Equation (8.24) correspond to place 
ip . 
Let the first transition in the non-empty firing sequence ν~  be 
kt . If 
kt  is 
fireable by m even more it is fireable by marking m′ . The structure and weights 
of the Petri net PN are fixed. Some tokens are removed by firing 
kt  from 
ip  and 
some are added in 
ip  according to the firing rules in Definition 7.5. If there are 
more tokens added to 
ip  than those removed from it, Equation (8.24) holds. 
Consider that the firing sequence ν~  is again applied starting from marking m′  
and 
[
m
m
′′
>
′ν~
. The inequality 
m
m
′
>
′′
 holds for the above-mentioned reason. 
Continuing the reasoning in the described way, it can be concluded that the number 
of tokens in 
ip  grows to infinity. A similar situation can occur for more than one 
place. In such a case, the number of tokens in such places increases beyond any 
integer limit. 
The idea of the coverability graph is to construct a graph of markings using the 
augmented markings and to achieve a finite graphical representation so that all 
reachable markings even unlimited are covered by a finite number of augmented 
markings. Then the coverability graph has a finite number of graph nodes.  
Definition 8.8. The coverability set for a given unbounded Petri net PN is a finite 
set of augmented markings covering all reachable markings in PN.  
 
Now we can formulate the coverability graph definition similar to the one of 
reachability graph. 
Definition 8.9. Consider a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 be given. The simple 
labeled directed mathematical graph 
 
(
)
(
)
T
f
f
RELC
C
CG
PN
PN
,
,
,
,
,
2
1
0
∅
=
m
 
(8.25) 
is the coverability graph of PN, where 
(
)
0
m
PN
C
 
 
 
is the coverability set of PN 
(
)
(
)
0
0
m
m
PN
PN
C
C
RELC
×
⊆
 is the set of oriented arcs labeled by the 
function 
2f  

120 Modeling and Control of Discrete-event Dynamic Systems 
(
)
∅
→
0
1 :
m
PN
C
f
 is not defined or empty function 
T
RELC
f
→
:
2
 is a function mapping the arcs of RELC into the set of 
transitions. The labeled arcs are represented via the triples (
)
Ak
j
Ai
M
t
M
,
,
. 
The labeled relation is 
lab
RELC
. Transition 
jt  is fireable by all reachable 
markings (standard, i.e., not augmented marking) covered by the 
augmented marking 
Ai
M
 and the firing brings about a marking covered by 
an augmented marking 
Ak
M
, 
jt  is a label of the arc from 
Ai
M
 to 
Ak
M
. In 
this way, all reachable markings of PN are covered by 
(
)
0
m
PN
C
 and all 
possible transition firings are among the labels of the coverability graph. 
A coverability graph node corresponding to an augmented marking may cover 
some subset of standard reachable markings in PN. For each possible transition 
firing in these reachable markings there exists an arc labeled with the transition and 
going into another augmented marking, possibly in the same augmented marking 
(feedback loop). Several reachable markings covered by an augmented marking 
can enable firing of the same transition represented by the same arc. Construction 
of a coverability graph according to Definition 8.9 is not an unambiguous task. 
There can be several coverability graphs for the same Petri net. Each node of the 
coverability graph represents a marking that covers a subset of the reachable 
marking of the given Petri net. Firing of a transition can change a marking that 
belongs to one covered subset to another marking belonging to another subset. 
Each subset is represented by an augmented marking that covers its subset. In a 
special case, a transition firing can return to the same subset. 
A coverability graph of PN can be constructed according to the following 
verbal algorithm. The algorithm proceeds in consecutive steps if not otherwise 
specified. 
STEP 1. Define three empty sets denoted as “NOT_ANALYZED”, “DEAD”, 
and “ANALYZED”. 
STEP 2. Put the initial marking represented by the vector 
0
m
 into 
NOT_ANALYZED. 
STEP 3. If  NOT_ANALYZED is empty, go to STEP 11, otherwise go to 
STEP 4. 
STEP 4. Select and withdraw a marking from the set NOT_ANALYZED and 
denote it as m . Draw a node of the coverability graph which 
corresponds to the marking m . 
STEP 5. If no transition is fireable by m put marking m into DEAD and go to 
STEP 3, otherwise go to STEP 6. 
STEP 6. Define set 
T
Tm ⊆
of all fireable transitions by m . 
STEP 7. If 
m
T  is empty go to STEP 3, and otherwise go to STEP 8. 
STEP 8. Withdraw a transition t from 
m
T  and by its firing in PN obtain 
marking m′ , that is 
[
m
m
′
>
t
.  

 
Properties of Petri Nets 121 
STEP 9.  If there is a marking 
e
m  equal to m′  in ANALYZED or DEAD, 
draw an arc from node m to 
e
m , label it with t and go to STEP 7, 
otherwise go to STEP 10. 
STEP 10. If there is one or more markings m ′′  on any possible directed path 
from 
0
m  to m′ , for which 
m
m
′′
>
′
, then replace the number of 
tokens for each place 
P
p ∈
 for which 
( )
( )
p
p
m
m
′′
>
′
 with symbol 
ω  standing for the infinite number of tokens, i.e., the original 
marking is replaced by an appropriate augmented marking. Recall 
that ω  does not strictly cover ω  because it is defined that 
ω
ω ≥
, 
this case does not lead to a new covering marking. In the case that 
there is not the same marking as m′  in ANALYZED or DEAD, add 
a new node corresponding to the modified augmented marking m′  
into  the coverability  graph and draw an arc from m  to the modified 
marking m′ . Put marking m′  into set NOT_ANALYZED, else 
draw only an arc. Go to STEP 7. 
STEP 11. END. 
It is evident that STEP 10 is directly implied by Theorem 8.2. If some newly 
generated marking “sharply” covers a marking somewhere on the backtracked path 
in the coverability graph, then Theorem 8.2 can be applied. The fact that in one 
place tokens will be cumulated without limits is interpreted by replacing the 
marking with infinity ω . From this moment when a transition t is fired by m′, the 
number of tokens in place p is considered infinitely large. Recall that the addition 
of k tokens to p gives 
ω
ω
=
+ k
 and similarly for any subtraction. For covering 
ω  holds 
ω
ω ≥
. 
A Nassi-Schneiderman structogramme is depicted in Figure 8.7. It specifies 
practically the same construction algorithm as verbally described earlier. The 
structogramme is more transparent and enables to program better the algorithm 
using a computer. The structogramme design principles have been explained when 
constructing the reachability graph. 
Example 8.3. Construction of the coverability graph is illustrated using the Petri net 
from Example 8.2, which is depicted in Figure 8.5.  
The initial marking is 
(
)
T
0
1
2
1
=
m
. There are two transitions fireable by 
0
m : 
1t  and 
2t . Next markings are (
)
T
3
0
0
 and (
)
T
0
4
2
. None of these markings 
cover 
some 
of 
their 
ancestors, 
namely 
(
)
(
)
T
T
1
2
1
3
0
0
>/
 and 
(
)
(
)
T
T
1
2
1
0
4
2
>/
, either. Now there are two markings in the set 
NOT_ANALYZED. Considering first (
)
T
3
0
0
, only 
2t  is fireable at (
)
T
3
0
0
. 
The next marking is (
)
T
2
2
1
 which sharply covers 
(
)
T
0
1
2
1
=
m
 as 
(
)
(
)
0
T
T
1
2
1
2
2
1
m
m
m
=
′′
=
>
=
′
. For 
3
p , since m'(p3)> m"(p3), the marking 
at p3 becomes ω. Since 
ω
ω
=
−1
, the next marking resulting from firing t1 is 

122 Modeling and Control of Discrete-event Dynamic Systems 
(
)
T
0
0
ω
. Continue the process according to the algorithm; we obtain the 
coverability graph in Figure 8.8. It has only six distinct nodes, i.e.,  
 
,
0
0
,
2
1
,
0
4
2
,
3
0
0
,
1
2
1
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
ω
ω
and 
.
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
ω
ω
ω
 
Figure 8.7. Nassi-Schneiderman structogramme for the coverability graph construction 
algorithm 
 
Choice of a node 
i
m  such that 
(
)
,
,
0
T
t
C
j
PN
i
∈
∃
∈
∃
m
m
 
(
):
0
m
m
PN
k
C
∈
∀
[
(
)∧
>
k
j
i t
m
m
  (
)
RELC
t
k
j
i
∉
m
m
,
,
 
Initial data: set of graph nodes                        
(
)
0
0
m
m
=
PN
C
 
set of labeled oriented graph arcs                    
{
}
∅
=
=
,,
lab
RELC
(empty) 
Repetition of algorithm steps 
E 
N 
D 
node found 
yes 
no 
(
)
?
0
m
m
PN
k
C
∈
yes
no 
 % 
Creation of an augmented 
marking 
*
m
 
( )
ω
=
p
*
m
 if 
k
m
 has an 
ancestor 
−
m
 such that  
−
> m
m k
 and  
( )
( )
p
p
k
−
> m
m
, 
otherwise 
( )
( )
p
p
k
m
m
=
*
 
W ithdrawal of the existing 
marking 
k
m
 of  set 
(
)
0
m
PN
C
 and creation of 
marking 
*
m
 
( )
ω
=
p
*
m
 if 
k
m
 has an 
ancestor 
−
m
 such that 
−
> m
m k
 and  
( )
( )
p
p
k
−
> m
m
, 
oherwise 
( )
( )
p
p
k
m
m
=
*
 
(
)
(
)
{
}
*
:
0
0
m
m
m
∪
=
PN
PN
C
C
(
)
{
}
*
,
,
:
m
m
j
lab
lab
t
RELC
RELC
∪
=

 
Properties of Petri Nets 123 
 
t1 
t2 
t2 
t1 
t2 
t1 
t2 
t1 
t2 
ω
0
0
ω
2
1
ω
ω
ω
3
0
0
0
4
2
1
2
1
 
Figure 8.8. Coverability graph for the Petri net in Figure 8.5 
t1
t2
t2
t1
t2
t1
t2
t1
t2
ω
ω
0
ω
2
1
ω
ω
ω
3
0
0
0
4
2
1
2
1
ω
ω
1
t2 
t1 
ω
ω
2
t1 
t2
 
Figure 8.9. Coverability graph for the Petri net in Figure 8.5 
The example allows one to demonstrate the ambiguity of the coverability graph 
construction. In Figure 8.9 there is a different coverability graph that complies with 
Definition 8.9 though it has not been designed using the above described algorithm. 
With its augmented markings the coverability graph in Figure 8.9 covers all 
reachable markings of the net in Figure 8.5. Each possible firing has an associated 
arc from one augmented marking covering of the coverability graph to another of 
the next marking after the firing. 
Example 8.4. Consider the net in Figure 8.10. It comprises a transition without any 
outgoing arc. Such a structure complies with Definition 7.2. Its coverability graph 
is shown in Figure 8.11 and has two dead markings. They are contained in the set 
DEAD filled up during the algorithm execution. 

124 Modeling and Control of Discrete-event Dynamic Systems 
 
p1 
p2 
t1 
t2 
p3 
z
t3 
 
Figure 8.10. An unbounded Petri net 
Figure 8.11. Coverability graph for the Petri net in Figure 8.10 
Design of the reachability and coverability graphs can be analogously done for 
the Petri nets with inhibitors and incidentors PI, for the Petri nets with capacities 
PCA, and for the Petri nets interpreted for control PC. The PI’s and PCA’s firing of 
a transition is subordinated to the existence of inhibitors or incidentors, and to the 
place capacities, as well. For PC the arcs in the reachability and coverability 
graphs are labeled both with firing transitions and with additional firing conditions. 
8.6  Liveness 
The next property we intend to study is the liveness. It is related to the deadlock 
free operation of discrete event systems. Liveness can be analyzed in terms of 
marking and event. 
 
0
0
1
1
1
0
ω
0
1
0
0
0
ω
1
0
ω
0
0
t1 
t3 
t2 
t3 
t1 
t2 
dead 
dead 

 
Properties of Petri Nets 125 
Given a Petri net PN we say that a reachable marking 
(
)
0
m
m
PN
d
R
∈
 is dead if 
there is no transition fireable at 
d
m . Put simply, if a Petri net is a correct model of 
a real system and reaches 
d
m
, then the system cannot continue its 
operation/function. No event is executable and the system is in a deadlock.  
Moreover, we are interested in the system event history leading to a deadlock. 
The history can be expressed in terms of firing sequences. Firing sequences are a 
very basis for the definition of Petri net liveness. 
Definition 8.10. Consider 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
. A transition 
T
t ∈
 is said to be  
• 
Live at level 0
L (or dead) if there is no firing sequence beginning at 
0
m and 
containing t, 
• 
Live at level L1 if t can be fired at least once in a firing sequence beginning 
at 
0
m , 
• 
Live at level L2 if t can be fired at least k (k≥1) times in a firing sequence 
beginning at 
0
m , 
• 
Live at level L3 if t can be fired infinite times in a firing sequence 
beginning at 
0
m , 
• 
Live at level L4 (or live) if at each reachable marking of PN, there is at 
least one firing sequence in which t fires at least once. 
It is possible to express L4 in terms of L1 as follows: transition t is live at level 
L4 if for each reachable marking 
(
)
0
m
m
PN
R
∈
 it is L1-live. In other words, 
starting from every reachable marking there should exist a firing sequence in which 
t fires at least once.  
Liveness at level Lk is denoted as Lk-liveness for brevity. 
The following implications can be easily understood: 
L4-liveness ⇒ L3-liveness ⇒ L2-liveness ⇒ L1-liveness 
t is said to be strictly Lk-live if it is Lk-live but at the same time it is not 
L(
)1
+
k
-live. 
The minimum liveness property with respect to all transitions of a Petri net is 
transferred into the property of the whole Petri net, i.e., if all transitions of PN are 
Lk-live, PN is Lk-live.  
Many authors use the tag “live” for the L4-liveness. Consequently if t is not live 
then it may not be dead, it can be, e.g., L2-live, and inverse of dead (L0-liveness) is 
not live but can be any Lk-liveness, k=1,2,3, and 4. 
Example 8.5. Figure 8.12 shows a Petri net that serves for liveness study. Only 1t  
is fireable at initial marking 
(
)
T
0
0
  
1
  
0
  
0
  
1
=
m
. After firing 1t  the next marking is 
(
)
T
0
  
0
  
0
  
1
  
0
 and then only 
3t
 is fireable. Firing it leads to (
)
T
0
  
0
  
1
  
0
  
1
. 

126 Modeling and Control of Discrete-event Dynamic Systems 
Afterwards, 
4t  and 5t  can alternate their firing infinitely. Transition 
2t  never fires. 
Therefore it is L0-live. Transitions 1t  and 3t  fire exactly once – they are strictly 
L1-live, and 
4t  and 5t  can fire for infinite times – they are live at level L3. The 
Petri net as a whole is live at level L0, thus it is dead. The liveness situation is 
evident from the reachability graph in Figure 8.13. Obviously, in the loop 
(
)
(
)
(
)
....
0
0
1
0
1
1
0
0
0
0
0
0
1
0
1
T
T
T
→
→
→
 transitions 
4t  and 5t  can fire for an 
infinity number of times. 
The analyzed Petri net is bounded. 
 
  
p1 
p2 
t1 
t2 
p3 
z 
z
p4 
p5 
t3 
t4 
t5 
 
Figure 8.12. Petri net showing Lk liveness, k=0, 1, 2, 3, and 4 
 
1   0   0   1   0
0   1   0   0   0
1   0   1   0   0
0   0   0   0   1
t 1  
t 3  
t 4  
t 5  
0
m
 
Figure 8.13. Reachability graph for the Petri net in Figure 8.12 

 
Properties of Petri Nets 127 
8.7  Reversibility 
Many processes in DEDS have a cyclic character. For example, production jobs in 
manufacturing systems run cyclically. Some product is manufactured out of input 
parts through a sequence of operations that are repeatedly executed during a work 
shift. The Petri net model of a DEDS reflects the cyclic character through a 
property called reversibility defined as follows. 
Definition 8.11. A Petri net PN is reversible iff for each reachable marking 
(
)
0
m
m
PN
R
∈
 the initial marking 
0
m  belongs to the reachability set from m  in 
PN, i.e., 
 
( )
m
m
PN
R
∈
0
 
(8.26) 
Simply speaking, the reversibility property says that for every reachable 
marking there exists at least one firing sequence beginning at it and going back to 
the initial marking. From the point of view of the reachability graph, for every 
graph node there exists a directed path starting in the node and going back to the 
root. The reversibility is illustrated via the following example. 
Example 8.6. Consider the Petri net in Figure 8.14. At the beginning, just 
2t  is 
fireable, then, either 1t  or 3t  is fireable. After having fired 1t , transition 
2t  can be 
fired. After repeating this sequence k-times, k-tokens are delivered into 
3
p . When 
afterwards transitions 3t  and 
4t  are fired k-times, the initial marking (
)
T
0
  
1
  
0
  
1
  
0
 
is obtained.  
 
Figure 8.14. Petri net for the reversibility illustration 
   
p1
p2
t1 
t2 
p3
z
p4
p5
t3 
t4 
z

128 Modeling and Control of Discrete-event Dynamic Systems 
 
t2 
0 1 0 1 0
1 0 1 1 0
t2 
0 1 ω 1 0 
1 0 ω 1 0 
0 1 ω 0 1 
1 0 0 0 1
0 1 0 0 1
1 0 0 1 0
1 0 ω 0 1 
t1 
t2 
t3 
t1 
t3 
t4 
t1 
t2 
t3 
t1 
t4 
t4 
t1 
 
Figure 8.15. Coverability graph for the reversible Petri net in Figure 8.14 
 
 
Evidently, the Petri net is a reversible one because from any reachable marking 
it is always possible to return to the initial marking through appropriate transition 
firings. The corresponding coverability graph is given in Figure 8.15. The graph 
will later be used in the summary analysis of the Petri net properties in Section 
8.12. 
8.8  Persistence and Fairness 
An interesting property of the DEDS is the realizeability of an event with respect to 
the realization of another event. The question formulated in terms of Petri nets is 
whether a transition once being fireable or enabled can lose the fireability prior to 
its actually being fired. 
A Petri net is said to be persistent if, having two or more transitions fireable in 
a state,  firing a transition of them does not remove the fireability of the other 
transitions.  
A property closely related to the persistence is fairness. A Petri net is said to be 
bounded fair if every pair of its transitions is bounded fair. A transition pair is 
bounded fair if every transition of the pair can fire k-times at maximum before the 
other transition in the pair fires. More about persistence in connection with 
concurrency and conflict will be written later in this textbook. Fairness is dealt 
with, for example, in the excellent survey paper of Murata (1989). 

 
Properties of Petri Nets 129 
8.9 Conservativeness 
Petri nets are often used to model the utilization of various system resources. For 
example, the utilization of computer processors, memory devices, input/output 
units etc., requires modeling their availability or occupation in distributed 
computer systems. Frequently the number of resources in a system remains 
constant. In Petri nets the situation is reflected through  conservativeness. 
Definition 8.12. A Petri net PN is strictly conservative if in all reachable markings 
the total sum of tokens in the net is constant. Formally expressed 
 
(
)
(
)
(
)
0
1
0
1
for
m
m
m
m
PN
P
i
i
P
i
i
R
p
p
∈
∀
= ∑
∑
=
=
 
(8.27) 
If two or more resources, e.g., a part and robot, are represented each by a 
separate token and then the action “The robot picks up the part” by one token, then 
the number of tokens is changed from two to one. That kind of system situation can 
be coped with the weighted conservativeness, which is subject of the next 
definition. 
Definition 8.13. A Petri net PN is conservative with respect to a weight vector v  if  
 
( ) ( )
( )
( )
(
)
P
v
m
m
m
v
m
v
m
v
m
v
N
R
p
p
p
p
PN
P
i
i
i
P
i
i
i
∈
∈
∀
=
=
=
∑
∑
=
=
and
for
0
1
0
1
0
T
T
 
(8.28) 
Example 8.7. Distributed computer networks are a frequently used discrete event 
systems. In the adapted example inspired by Starke (1990), the system comprises 
three processors communicating via two transmission channels. Conflict situations 
occur due to the use of only two communication resources by three competing 
users. The system layout with main data channels is shown in Figure 8.16. 
Variables: 
ir  represents the requirement of the processor Proc i to communicate data;  
if   announces disconnection from the used channel and end of the 
communication;  
i
w  is the communication start command for Proc i.  
First, the system is specified as a deterministic finite automaton, and then as a 
Petri net. Thus the example is used to compare both approaches. 

130 Modeling and Control of Discrete-event Dynamic Systems 
 
Proc 1 
Proc 2
Proc 3
CM1 
CM2
CM3
Chan1 
Chan2 
Communication server
r2 
r1 
r3 
f1 
f2 
f3 
w3 
w2 
w1 
 
Figure 8.16. Data communication network 
There are seven states characterizing the system situations and six events 
driving the system behavior. Only one processor can use a channel at a time. The 
state transition table of the automaton is shown in Table 8.3 and its graphical 
representation is in Figure 8.17. The abbreviation  “Proc i” is used for the i-th 
system processor. The used communication channel is not specified, as it can be 
seen from the state transition table. 
Important information is if one channel, regardless which one of two available 
channels, is busy or not. The Petri net of the described system is shown in Figure 
8.18. The meaning of places and transitions is described in Tables 8.4 and 8.5. 
The state transition table or graph of the finite automaton (Figure 8.17) 
provides much less information about structural and behavioral properties of the 
modeled system than the corresponding Petri net does. From the finite automaton 
specification it can be found that, if a state change occurs by event 
ie , the inverse 
back leading change occurs by event 
3
+
ie
.  
A finite automaton specifying the control of the communication is shown in 
Figure 8.19. It is a part of the complete automaton. Control commands 
i
w  are set 
to value 
i
C  in the respective states. The complete automaton would be rather 
complex. 
Place 
7
p
 in the Petri net represents free channels. The initial marking 
(
)
2
7
0
=
p
m
 says that there are two free channels available for processors at the 
beginning. From the net we know that two activities run in parallel at a reachable 
marking 
(
)
T
0
  
0
  
1
   
0
  
1
  
0
  
1
=
m
: processor 1 works using one channel and 
processor 3 works using the other channel. No other channel is available until one 
of the processors returns a channel it occupies.  

 
Properties of Petri Nets 131 
Table 8.3. State transition table 
 
e1 
e2 
e3 
e4 
e5 
e6 
 
q0 
q1 
q2 
q3 
 
 
 
Initial state 
q1 
 
q4 
q5 
q0 
 
 
Proc1 uses 
one channel 
q2 
q4 
 
q6 
 
q0 
 
Proc2 uses 
one channel 
q3 
q5 
q6 
 
 
 
q0 
Proc3 uses 
one channel 
q4 
 
 
 
q2 
q1 
 
Proc1 and 
Proc2 use 
both channels 
q5 
 
 
 
q3 
 
q1 
Proc1 and 
Proc3 use 
both channels 
q6 
 
 
 
 
q3 
q2 
Proc2 and 
Proc3 use 
both channels 
 
Proc1 
starts 
using a 
channel 
Proc2 
starts 
using a 
channel 
Proc3 
starts  
using a 
channel
Proc1 
ends 
using a 
channel
Proc2 
ends 
using a 
channel
Proc3 
ends 
using a 
channel
 
 
q0 
q3 
q2 
q1 
q5 
q4 
q6 
e1 
e4 
e2 e5 
e3 
e6 
e2 e5 
e3 
e6 
e1 
e4 
e2 
e1 e3 
e6
e1 
e4 
 
Figure 8.17. Graphical representation of the finite automaton 

132 Modeling and Control of Discrete-event Dynamic Systems 
Figure 8.18. Petri net for a three-processor and two-channel system 
Table 8.4. Meaning of the Petri net places 
Meaning 
P1 
Proc1 uses one channel 
P2 
Proc2 uses one channel 
P3 
Proc3 uses one channel 
P4 
Proc1 does not use a channel 
P5 
Proc2 does not use a channel 
P6 
Proc3 does not use a channel 
P7 
Number of tokens in it indicates the number of free channels  
Table 8.5. Meaning of the Petri net transitions 
 
Meaning 
t1 
Proc1 starts using one free channel 
t2 
Proc2 starts using one free channel 
t3 
Proc3 starts using one free channel 
t4 
Proc1 ends using one channel 
t5 
Proc2 ends using one channel 
t6 
Proc3 ends using one channel 
   
p1
p2 
t1 
t2 
p3
p4
p5 
t3 
t4 
z 
z z
z
z
p6
p7
t5 
t6 

 
Properties of Petri Nets 133 
 
q000 
q000 
q001 
q011 
q100 
q101 
q001 
q010 
q011 
1q100 
3q110 
1q110 
2q100 
2q110 
r1 
r3 
f3 
r1 
r2 
f2 
r1 
f1 
r2 
f2 
r3 
f1 
f2 
f3 
r2 
f2 
r2 
r3 
r3 
f1 
w1:=C1 
w3:=C3 
w2:=C2 
w2:=C2 
w3:=C3 
f3 
r2 
r3 
r2 
r1 
f2 
f3 
f2 
f1 
r1 
f1 
w3:=C3 
w1:=C1 
f1 
f2 
f3 
 
Figure 8.19. Partial finite automaton with outputs specifying control 
Figure 8.20. Petri net interpreted for control of a three-processor and two-channel system 
The Petri net interpreted as a control model for the system of three processors 
and two channels is shown in Figure 8.20. A new element is used in the net, 
namely the source place. Source places are hatched in the figure. A token is 
generated in the source place when an associated requirement of the system 
resource occurs. Depositing a token in source places pr1, pr2 and pr3 indicates the 
  
p11
p21 
t11
t21
p31
Ps1
Ps2
t31
z
z z
z
z
Ps3
p7
t12
pr1
C1
t32
pr3
pe3
t22 
pr2
pe2 
pe1
C3
C2 

134 Modeling and Control of Discrete-event Dynamic Systems 
requirement of the corresponding processor to be connected to a free channel. The 
token presence in 
ei
p  indicates the end of the transmission process of the i-th 
processor and the demand for disconnecting from the used channel. Place 
si
p  is 
used to indicate that the disconnection takes place. 
i
C  is the command for 
connecting the i-th processor.  
The above examples clearly show that the control specification using Petri nets 
is much more effective than the one using a finite automaton. The Petri net model 
in Figure 8.20 specifies the main function of the server managing the connections. 
Other control functions can be completed using the shown approach.  
Furthermore, the presented example shows an alternative way of how to build-
in input signals from the controlled system into the control one, by using the source 
places to associate logical conditions with transitions (in comparison with the way 
in Section 7.4). 
8.10  P-invariants and T-invariants 
In a Petri net, the existence of a P-invariant and/or T-invariant is a structural 
property, i.e., the properties are independent of the initial marking. 
Definition 8.14. A vector
T
P
P
N
∈
i
, where N is the set of natural numbers, the 
cardinality of the set P  is 
n
P =
 and 
T
P
N
 is the set of the transposed n-tuples, is 
called the P-invariant of a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 if  
 
0
i
N
=
Δ
P
T
,
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
n
P
P
P
P
i
i
i
M
2
1
i
 
(8.29) 
where at least one entry of vector 
Pi  is nonzero. 
Δ
N is an incidence matrix of PN  
(also denoted as A in Section 7) and the dimension of the zero vector 0  is 
m
T =
.  
 
The case when 
(
)
T
0
,...,
0,0
=
Pi
 is trivial and hence it is excluded by definition. 
Equation (8.29) is in fact a system of homogeneous linear algebraic equations 
 
0
...
0
...
0
...
2
2
1
1
2
2
22
1
21
1
2
12
1
11
=
+
+
+
=
+
+
+
=
+
+
+
n
P
mn
P
m
P
m
n
P
n
P
P
n
P
n
P
P
i
a
i
a
i
a
i
a
i
a
i
a
i
a
i
a
i
a
M
 
(8.30) 

 
Properties of Petri Nets 135 
Obviously, its zero solution always exists. Generally, it is implied by the 
Frobenius theorem stating that if the rank of the coefficient matrix of the system at 
Equation (8.29) is equal to the rank of the augmented matrix, the system has a 
solution. The zero solution of Equation (8.30) is 
 
0
...
2
1
=
=
=
=
n
P
P
P
i
i
i
 
(8.31) 
For a system of linear algebraic equations it is well known that when the rank r 
of its coefficient matrix is equal to the number of equations 
n
r =
, exactly one 
solution exists. For the case of the homogeneous system at Equation (8.30) there is 
the solution at Equation (8.31). Coefficients 
ij
a  in the system at Equation (8.30) 
are integers as it follows from the construction of the Δ -incidence matrix. If the 
searched unknowns are allowed to be real numbers then there are infinitely many 
solutions for 
n
r <
. If only integers are allowed, the condition 
n
r <
 is necessary 
but not sufficient for the existence of solutions other than Equation (8.31). 
Sometimes, even a stronger restriction can be imposed on the solution space, 
namely that the unknowns should be natural numbers (non-negative integers). In 
this case, even more so the condition 
n
r <
 is not sufficient.  
As mentioned above we are interested in nonzero P-invariants and 
consequently in nonzero solutions of Equation (8.30) in the integer space or even 
in the space of natural numbers. 
In what follows we will show that the conservativeness property of a Petri net 
is a corollary of the Petri net P-invariant presence. Suppose a given Petri net has a 
P-invariant 
Pi . Then owing to Definition 8.14  
 
0
i
N
=
Δ
P
T
 
(8.32) 
Recalling Equation (7.29), Definition 8.1 and Equation (8.7) we have for a 
reachable marking 
k
m  
 
∑
=
Δ
+
=
k
s
i
k
s
1
0
t
m
m
 
(8.33) 
which can be given as 
 
z
N
m
m
Δ
+
=
0
k
 
(8.34) 
where 
(
)
T
2
1
,...,
,
m
z
z
z
=
z
, 
N
zi ∈
, 
(
)
m
i
,...,
2,1
∈
 determines how many times the 
vector 
it
Δ
 occurs in a particular firing sequence. 
From Equation (8.34) we have 
 
z
N
m
m
Δ
=
−
0
k
 
(8.35) 

136 Modeling and Control of Discrete-event Dynamic Systems 
Transposing Equation (8.35) yields  
 
T
T
T
0
T
Δ
=
−
N
z
m
m k
 
(8.36) 
and multiplying by 
Pi  gives 
 
(
)
P
P
k
i
N
z
i
m
m
T
T
T
0
T
Δ
=
−
 
(8.37) 
Due to the assumption of P-invariant  
 
(
)
0
T
T
0
T
=
=
−
0
z
i
m
m
P
k
 
 (8.38) 
 
P
P
k
i
m
i
m
T
0
T
=
 
(8.39) 
 
(
)
(
)
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
n
P
P
P
P
n
P
P
P
k
P
k
k
i
i
i
m
m
m
i
i
i
m
m
m
M
M
2
1
0
20
10
2
1
2
1
,...,
,
,...,
,
 
(8.40) 
 
n
P
P
P
P
n
P
k
P
P
k
P
k
i
m
i
m
i
m
i
m
i
m
i
m
0
2
20
1
10
2
2
1
1
..
.
..
.
+
+
+
=
+
+
+
 
 
 
 
(8.41) 
According to Equation (8.41) in a Petri net the sum of tokens distributed in 
places with respect to the initial marking, and weighted (multiplied) by the 
components of P-invariant 
Pi
 is constant  for all reachable markings 
(
)
0
m
m
PN
k
R
∈
. If some of the P-invariant components is zero, the number of 
tokens in the corresponding place is excluded from the sum (8.41). A term P-
invariant support is used in this connection. The P-invariant support is the set of 
Petri net places corresponding to nonzero entries in 
Pi
. Using the concept of 
support, the weighted sum of tokens in the places of the P-invariant support is 
constant for all reachable markings.  
It is possible to prove the inverse proposition to (8.32) ⇒(8.39), namely 
(8.39) ⇒(8.32) for L1-live Petri net. Assume for L1-live Petri net 
P
P
k
i
m
i
m
T
0
T
=
 
for all reachable markings 
(
)
0
m
m
PN
k
R
∈
 and for some 
T
P
P
N
∈
i
. Then 
0
T
0
T
=
−
P
P
k
i
m
i
m
 and (
)
0
T
0
T
=
−
P
k
i
m
m
. Further 
T
T
T
0
T
Δ
+
=
N
z
m
m k
so that 
(
)
0
T
0
T
T
T
0
=
−
+
Δ
Pi
m
N
z
m
 where 
0
z
≠
T
. We have (
)
0
T
T
=
Δ
Pi
N
z
 and 
0
N
z
≠
Δ
T
T
 
for entries corresponding 
Pi  yielding
0
i
N
=
Δ
P
T
. 
The concept of P-invariants is useful for the solution to various problems in 
Petri nets and via them also in DEDS as we will see later on. A similar concept of 
T-invariants is introduced in the following definition. 

 
Properties of Petri Nets 137 
Definition 8.15. A vector 
T
T
T
N
∈
i
, where N is the set of natural numbers, the 
cardinality of set T  is 
m
T =
and 
T
T
N
is the set of transposed m-tuples, is called 
the T-invariant of a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 if  
 
0
i
N
=
Δ
T
, 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
m
T
T
T
T
i
i
i
M
2
1
i
 
(8.42) 
where at least one entry of the vector 
Ti  is nonzero. 
Δ
N is an incidence matrix of 
the Petri net PN  and the dimension of the zero vector 0  is 
n
P =
. 
Note that the incidence matrix in the definition is not transposed. If 
ks
s
s
t
t
t
...
2
1
is 
a transition firing sequence beginning in marking 
0
m  and referring to (8.33) and 
(8.34) we have 
 
z
N
m
t
m
m
Δ
=
+
=
Δ
+
=
∑
0
1
0
k
s
i
k
s
 
(8.43) 
If z  is a T-invariant it follows 
 
0
and
m
m
0
z
N
=
=
Δ
k
 
(8.44) 
Theorem 8.3. The existence of a T-invariant is a necessary condition for a Petri net 
to be reversible. 
Proof. The principle of the Petri net reversibility consists in that for each reachable 
marking 
k
m there is a transition firing sequence continuation from 
k
m  reaching 
the marking 
0
m , i.e., in terms of Equation 8.43, 
z
N
m
m
Δ
+
=
0
0
. Therefore 
0
z
N
=
Δ
has to hold, hence z is a T-invariant. 
Proposition of Theorem 8.3 can be expressed by the implication: 
 
Petri net is reversible ⇒ T-invariant exists 
Using a counterexample it will be shown that the inverse implication:  
 
T-invariant exists ⇒ Petri net is reversible 
does not hold. See Petri net in Figure 8.21. We have: 

138 Modeling and Control of Discrete-event Dynamic Systems 
 
p1 
p2 
t3 
p3 
z 
t1 
t2 
 
Figure 8.21. Petri net with a T-invariant 
 
1  0  0  
0  1  1  
t1 
t3 
0  0  2  
0  2  0  
t2 
t3 
t2  
Figure 8.22. Reachability graph for the Petri net in Figure 8.21 
 
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
=
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
−
−
−
0
0
0
1
1
0
1
1
1
1
1
1
0
0
1
 
A T-invariant exists, it is 
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
=
1
1
0
Ti
, but the reachability graph indicates that the 
Petri net is not reversible (Figure 8.22). 
A way to find the solutions to the linear algebraic system of equations (8.32) in 
the space of integer numbers is to use the standard methods used for the real 
number space hoping that an integer solution could be obtained or extracted from a 
real number solution. The following example illustrates this solution way. An exact 
method yielding the solution directly is described later.  
Example 8.8. A robotic manufacturing cell as adapted from Abel (1990) is depicted 
in Figure 8.23. Workpieces of type A are transported into the cell with conveyor 
C1 and workpieces B with C3. The Petri net specifying this cell’s operation is 
shown in Figure 8.24. Presence of a token in place 
1p  corresponds to the presence 
of a workpiece A ready for technological processing at the end of conveyor C1. 
The part of the net for B-workpieces is quite symmetrical with respect to that for 

 
Properties of Petri Nets 139 
A-workpieces. Transition 
1t  expresses the technological processing start with 
assistance of robot R1. Availability of R1 is expressed by a token in 
7
p . After 1t  
fires the tokens are removed from 
1p  and 
7
p  and a token is placed in 
2
p , which 
means that the processing is in progress in machine center MA1 using robot R1. 
An example is coachwork welding in the automobile industry. The end of this 
technological step and start of the processing in MA2 using R2 is marked by firing 
2t . Firing 3t  means that the processing in MA2 has been completed and the next 
workpiece to be processed is available at the input on C1. The last event 
represented by 
3t  may seem to be a little bit artificial: the end of the processing 
and arrival of an A-workpiece both represented by one transition means that the 
robot R2 is kept busy until the A-workpiece arrival.  
It would be possible to add more places and transitions and to express the 
operation more precisely. The used representation illustrates a natural way of a 
Petri net construction – from a simpler and rough net to the extensions. This 
construction way is called top-down design. We will keep the Petri net in the form 
in Figure 8.24 just for the sake of simplicity of the following considerations.  
 
 
A  
B  
C 1  
C 3
C 2  
C 4
R 1
R 2
M A 1  
M A 2  
M B 1
M B 2  
 
Figure 8.23. A two-robot manufacturing cell 

140 Modeling and Control of Discrete-event Dynamic Systems 
In the example, the task is to find P-invariants for the Petri net describing the 
robotic cell. The transposed Δ -incidence matrix is 
 
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
−
−
−
=
Δ
1
0
1
0
1
0
0
0
1
1
1
1
0
0
0
0
0
1
0
1
1
0
0
0
1
0
0
0
0
1
0
1
1
1
0
0
0
1
1
0
0
1
0
0
0
0
1
1
T
N
 
(8.45) 
       From the equation 
0
i
N
=
Δ
P
T
, we get a system of equations to be solved 
(having omitted the index P for simplicity): 
 
0
0
0
0
0
0
8
6
4
8
7
6
5
7
5
4
8
3
1
8
7
3
2
2
1
=
+
−
=
−
+
+
−
=
−
+
−
=
+
−
=
−
+
+
−
=
+
−
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
 
 
 
(8.46) 
 
p1 
p2 
p3 
p4 
p5 
p6 
p7 
p8 
t2 
t3 
t4 
t5 
t6 
t1 
z
z
z
z
 
Figure 8.24. Petri net for the robotic manufacturing cell 
 

 
Properties of Petri Nets 141 
The calculation of the coefficient matrix determinant and of the lower order 
determinants shows that the rank of the coefficient matrix is 
4
=
r
. It means that 
there are two equations in Equation (8.46), which linearly depend on the remaining 
four. Summing the first and second equations gives: 
 
0
    
         
 
      
0
0
8
3
1
8
7
3
2
7
2
1
=
−
+
−
=
−
+
+
−
=
−
+
−
i
i
i
i
i
i
i
i
i
i
 
(8.47) 
and multiplication by  –1 gives the third equation in Equation (8.46). Similarly, the 
sum of the fourth and fifth equations multiplied by –1 gives the sixth equation. 
Hence, both the third and sixth equations can be omitted and we have finally 
 
0
0
0
0
8
7
6
5
7
5
4
8
7
3
2
7
2
1
=
−
+
+
−
=
−
+
−
=
−
+
+
−
=
−
+
−
i
i
i
i
i
i
i
i
i
i
i
i
i
i
  
 
 
(8.48) 
The particular integer values of four unknowns can be chosen arbitrarily of and 
the remaining four unknowns can be calculated. Values of the four unknowns are 
chosen as follows: 
 
4
8
3
7
2
4
1
1
λ
λ
λ
λ
=
=
=
=
i
i
i
i
 
(8.49) 
and for transparency we denote the remaining dependent unknowns as 
 
6
4
5
3
3
2
2
1
i
x
i
x
i
x
i
x
=
=
=
=
 
(8.50) 

142 Modeling and Control of Discrete-event Dynamic Systems 
 
3
4
4
3
3
2
3
3
4
2
1
3
1
1
λ
λ
λ
λ
λ
λ
λ
λ
−
=
+
−
+
=
−
=
+
−
+
=
x
x
x
x
x
x
 
(8.51) 
Using the Cramer’s rule  
 
(
)
4
2
4
3
2
3
4
1
2
3
1
3
1
3
4
3
2
3
4
3
1
1
1
1
1
0
0
1
0
0
0
1
1
1
0
0
0
1
0
0
0
0
1
1
0
0
0
1
1
1
0
0
1
0
0
0
1
0
0
0
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
λ
+
=
+
=
+
=
+
=
−
+
=
−
−
−
−
+
−
+
=
x
x
x
x
     
(8.52) 
Returning to the original notation the P-invariants are given by 
 
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
+
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
+
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
+
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
1
0
1
0
0
1
0
0
0
1
0
1
0
0
1
0
0
0
1
1
1
0
0
0
0
0
0
0
0
1
1
1
4
3
2
1
8
7
6
5
4
3
2
1
λ
λ
λ
λ
i
i
i
i
i
i
i
i
 
(8.53) 
This equation determines all P-invariants for the values of 
4
3
2
1
,
,
,
λ
λ
λ
λ
; λ1, λ2, 
λ3, and λ4 are chosen from the set of integers. Obviously, the non-negative P-
invariants are obtained choosing them from the set of natural numbers. First, 
consider the P-invariants obtained for their values from { }
1,0
 only. The obtained 
P-invariants and their corresponding supports are listed below: 
Now, the system is 

 
Properties of Petri Nets 143 
 
{
}
{
}
{
}
{
}
{
}
{
},
,
,
,
,
0
1
0
1
0
1
2
1
,
,...,
0
0
1
1
1
1
1
1
,
,
,
1
0
1
0
0
1
0
0
,
,
,
0
1
0
1
0
0
1
0
,
,
,
0
0
1
1
1
0
0
0
,
,
,
0
0
0
0
0
1
1
1
7
5
3
2
1
6
1
8
6
3
7
5
2
6
5
4
3
2
1
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
⇒
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⇒
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⇒
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⇒
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⇒
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⇒
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
 
 
etc.  
 
 
(8.54) 
For example, according to the first P-invariant the number of tokens in places 
{
}
3
2
1
,
,
p
p
p
 is equal to 1 for all reachable markings. Consider the last P-invariant 
shown above. The number of tokens in 
2
p  is weighted by 2. By inspection of the 
Petri net in Figure 8.24 the weighted sum of tokens in places {
}
7
5
3
2
1
,
.
,
,
p
p
p
p
p
 is 
always 2. 
The P-invariants express the grouping of the system components from the 
viewpoint of technology and operation. For example the first P-invariant in 
Equation (8.54) groups the places comprising the component route of the 
workpieces A. The second P-invariant has an analogous meaning for the 
workpieces B. On the other hand, the third P-invariant is associated with the 
operation state of robot R1. It works either with workpiece A or B or is waiting to 
start work. 
The procedure shown above may not be successful in finding the existing 
integer solutions of the equation system at Equation (8.30). The main idea of a 
method always giving the answer about the system solvability and in the positive 
case the solutions themselves will be presented next.  
For the sake of a transparent explanation, consider a very simple case  
 
b
x
a
x
a
=
+
2
2
1
1
 
(8.55) 
where the coefficients 
2
1,a
a
and b  and unknowns 
1x  and 
2x  are supposed to be 
integers, i.e., 
 
I
x
x
b
a
a
∈
2
1
2
1
,
,
,
,
.  
(8.56) 

144 Modeling and Control of Discrete-event Dynamic Systems 
The greatest common divisor of the coefficients 
2
1,a
a
 will be denoted 
(
)
2
1,a
a
GDIV
. It can always be extracted from the left-hand side of Equation (8.55) 
 
(
)(
)
b
x
a
x
a
a
a
GDIV
=
+
2
1
1
2
1
'
'
,
, 
I
a
a
∈
2
1
'
,
'
 
(8.57) 
and 
 
(
)
2
1
2
2
1
1
,
'
'
a
a
GDIV
b
x
a
x
a
=
+
 
(8.58) 
The following theorem is based on the previous facts. 
Theorem 8.4. Equation (8.55) under the condition at Equation (8.56) has a solution 
if and only if the right-hand side coefficient b is divisible by the greatest common 
divisor of 
1a  and 
2
a . 
Theorem 8.4 can be easily extended to the system 
 
m
n
mn
j
mj
m
m
i
n
in
j
ij
i
i
n
n
j
j
n
n
j
j
b
x
a
x
a
x
a
x
a
b
x
a
x
a
x
a
x
a
b
x
a
x
a
x
a
x
a
b
x
a
x
a
x
a
x
a
=
+
+
+
+
+
=
+
+
+
+
+
=
+
+
+
+
+
=
+
+
+
+
+
...
...
..........
..........
..........
..........
..........
...
...
...
..........
..........
..........
..........
..........
..........
...
...
...
...
2
2
1
1
2
2
1
1
2
2
2
2
22
1
21
1
1
1
2
12
1
11
 
(8.59) 
The divisibility of 
ib through 
(
)
in
i
i
a
a
a
GDIV
,...,
,
2
1
 is a necessary and sufficient 
condition for the solution existence of the system at Equation (8.59) together with 
Frobenius condition. 
Further consider that for the absolute values in Equation (8.55) the following 
holds: 
 
2
1
a
a ≥
 
 (8.60) 
Using the Euclid algorithm we can write  
 
(
)
(
)
(
)
2
2
1
2
1
,
,
,
a
a
a
GDIV
a
a
GDIV
Mod
=
 
(8.61) 
where 
(
)
2
1,a
a
Mod
 is the remainder after the integer division of 
1a  by 
2
a . The 
result of the integer division is denoted by 
⎥
⎦
⎥
⎢
⎣
⎢
2
1
a
a
. For example, for 

 
Properties of Petri Nets 145 
18
,
21
2
1
=
=
a
a
, Mod(21, 18)=3, because 
1
18
21 =
⎥⎦
⎥
⎢⎣
⎢
 with the remainder 3. The 
following inequality is always fulfilled: 
 
(
)
2
2
1,
a
a
a
<
Mod
 
(8.62) 
if Equation (8.60) holds. By substituting in Equation (8.55) the following 
unknowns, 
 
2
1
2
1
2
1
1
ξ
ξ
ξ
+
⎥
⎦
⎥
⎢
⎣
⎢
−
=
=
a
a
x
x
 
(8.63) 
we obtain 
 
b
a
a
a
a
=
⎟⎟
⎠
⎞
⎜⎜
⎝
⎛
⎥
⎦
⎥
⎢
⎣
⎢
−
+
1
2
1
2
2
1
1
ξ
ξ
ξ
 
(8.64) 
 
b
a
a
a
a
a
=
+
⎟⎟
⎠
⎞
⎜⎜
⎝
⎛
⎥
⎦
⎥
⎢
⎣
⎢
−
2
2
1
2
1
2
1
ξ
ξ
 
 (8.65) 
 
(
)
b
a
a
a
=
+
2
2
1
2
1,
ξ
ξ
Mod
 
(8.66) 
Applying Theorem 8.4, the necessary and sufficient condition for an integer 
solution of Equation (8.66) is divisibility of b by 
(
)
(
)
2
2
,1
, a
a
a
GDIV Mod
, which is 
equivalent to the divisibility of b by 
(
)
2
1,a
a
GDIV
 due to (8.61). Therefore, if 
Equation (8.66) has an integer solution then Equation (8.55) does have, too. 
Between unknowns 
(
)
2
1 ξ
ξ
 and 
(
)
2
1 x
x
 there is an injection relation. Due to the 
important fact, namely 
(
)
2
2
1,
a
a
a
<
Mod
, repeating transformation at Equation 
(8.63) we either find that  an integer solution does not exist, or obtain a unit 
coefficient of some unknown. In the latter case we multiply the transformed 
equation by a suitable integer and subtract it from another equation following the 
Gauss reduction technique.  
The backward transformation from Equation (8.63) to the explicitly given 
unknowns 
nx
x
x
,...,
,
2
1
 is unambiguously executable, as we can see from 
 
2
1
2
1
2
1
1
x
x
a
a
x
+
⎥
⎦
⎥
⎢
⎣
⎢
=
=
ξ
ξ
 
(8.67) 

146 Modeling and Control of Discrete-event Dynamic Systems 
It is reasonable to start the solution of Equation (8.59) with the equation 
containing the least coefficient. Let this coefficient in system at Equation (8.59) be 
ij
a . For such a general case we have the following transformation: 
  
(
)
(
)
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⎥
⎥
⎦
⎥
⎢
⎢
⎣
⎢
−
⎥
⎥
⎦
⎥
⎢
⎢
⎣
⎢
−
⎥
⎥
⎦
⎥
⎢
⎢
⎣
⎢
−
⎥
⎥
⎦
⎥
⎢
⎢
⎣
⎢
−
=
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
+
−
m
j
ij
in
ij
j
i
ij
j
i
ij
i
m
j
a
a
a
a
a
a
a
a
x
x
x
x
ξ
ξ
ξ
ξ
.
.
.
.
.
.
1
0
.
.
.
.
.
.
.
.
0
0
1
0
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0
.
.
.
0
1
0
.
.
0
0
.
.
.
.
1
.
.
0
.
.
.
.
.
0
1
0
.
0
.
.
.
.
.
.
.
.
.
.
.
0
.
.
.
.
.
.
0
1
0
0
0
.
.
.
.
.
.
.
0
1
0
0
.
.
.
.
.
.
.
0
0
1
.
.
.
.
.
.
2
1
1
1
1
2
1
 
 
 
(8.68) 
The coefficients of the i-th equation of the transformed system are 
 
(
)
ij
ip
ij
ip
ij
ip
ip
a
a
a
a
a
a
a
,
'
Mod
=
⎥
⎥
⎦
⎥
⎢
⎢
⎣
⎢
−
=
 for 
n
p
,...,
2,1
=
 
(8.69) 
and 
 
ij
ip
a
a
<
'
 
(8.70) 
The reader can see that the divisibility conditions are similar to before and the 
value of coefficients in the equations can be lowered step-by-step to one, if of 
course an integer solution exists. As far as this is achieved, the equation is used for 
the reduction of the number of unknowns.  
It can be shown that a reverse transformation of step-by-step (8.68) leads 
unambiguously back to the original unknowns of the original system of the 
equations. In terms of the algebraic structure theory the described method applies 
only operations over the ring of integers. Division of the integer numbers is not 
defined there. Such a division requires the rational numbers. 
Interested reader can find more about the method in Abel (1990) containing 
further references.  The described method is clearer with the help of a simple 
example. 

 
Properties of Petri Nets 147 
Example 8.9. Find the integer solutions of 
 
5
2
3
2
1
−
=
−x
x
 
(8.71) 
There are two unknowns in just one equation. Evidently, 
 
(
)
(
)
1
2
,3
,
12
11
=
−
= GDIV
a
a
GDIV
 
(8.72) 
The right-hand side of Equation (8.71) is divisible by 1, hence an integer 
solution exists. The transformed equation is 
 
(
)
(
)
5
2
2
,3
2
1
−
=
−
+
−
ξ
ξ
Mod
 
(8.73) 
 
5
2
5
2
1
2
1
2
1
−
=
⇒
−
=
−
ξ
ξ
ξ
ξ
 
 (8.74) 
Let 
2
ξ  be a free unknown. Its value can be a number k, then 
 
k
=
2
ξ
    and    
5
2
1
−
= k
ξ
 
(8.75) 
Returning to the original unknowns we have 
 
(
)
5
3
5
2
1
5
2
2
1
12
11
2
2
1
1
1
−
=
−
+
=
⎥
⎦
⎥
⎢
⎣
⎢
−
=
−
=
=
k
k
k
x
a
a
x
k
x
x
ξ
ξ
ξ
 
(8.76) 
The integer solution is illustrated in Table 8.6. 
Table 8.6. Integer solutions of equation: 3x1 – 2x2 = –5 
k   
xi 
-1 
 0 
 1 
 2 
 3 
x1 
-7 
-5 
-3 
-1 
+1 
x2 
-8 
-5 
-2 
+1 
+4 
Example 8.10. Two equations (m=2) in three unknowns (n=3) are given: 
 
0
3
5
2
0
4
2
3
3
2
1
3
2
1
=
+
+
−
=
−
+
x
x
x
x
x
x
 
(8.77) 
We are searching integer solutions of Equation (8.77). The rank of the 
coefficient matrix 
2
=
r
, 
n
m
r
<
=
, i.e., the integer value of one unknown, can be 
chosen arbitrarily and the values of the remaining two are determined. Choose 

148 Modeling and Control of Discrete-event Dynamic Systems 
coefficient 
2
,1
,
12
=
=
=
j
i
a
aij
. According to Equation (8.68) the transformation 
equation is 
 
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
−
=
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
3
2
1
3
2
1
1
0
0
2
1
1
0
0
1
ξ
ξ
ξ
x
x
x
  
(8.78) 
The second row of the transformation matrix is 
 
(
)
2
2
2
4
;1
;1
2
3
12
13
12
11
=
−
−
=
⎥⎦
⎥
⎢⎣
⎢−
−
=
⎥
⎦
⎥
⎢
⎣
⎢
−
−
=
⎥⎦
⎥
⎢⎣
⎢
−
=
⎥
⎦
⎥
⎢
⎣
⎢
−
a
a
a
a
 
(8.79) 
and 
 
3
3
3
2
1
2
1
1
2
ξ
ξ
ξ
ξ
ξ
=
+
+
−
=
=
x
x
x
 
(8.80) 
And by substituon into Equation (8.77) 
 
0
13
5
7
0
2
3
2
1
2
1
=
+
+
−
=
+
ξ
ξ
ξ
ξ
ξ
  
(8.81) 
Multiplying the first equation by 7 and adding it to the second one yields 
 
0
13
19
3
2
=
+
ξ
ξ
 
(8.82) 
or 
 
2
3
2
3
13
19
19
13
ξ
ξ
ξ
ξ
−
=
⇒
=
−
 
 (8.83) 
When choosing 
 
I
k
k
∈
−
=
,
13
2
ξ
 
 (8.84) 
the solution is kept in the integer domain, as it is evident from 
 
(
)
k
k
19
13
13
19
3
=
−
−
=
ξ
 
(8.85) 

 
Properties of Petri Nets 149 
The last unknown will be 
 
(
)
k
k
26
13
2
2
2
1
=
−
−
=
−
=
ξ
ξ
 
(8.86) 
Returning to the original unknowns, all integer solutions of the equation system 
at Equation (8.77) are obtained as follows: 
 
k
x
k
k
k
x
k
x
19
38
39
2
26
3
3
2
1
2
1
1
=
−
=
+
−
=
+
+
−
=
=
=
ξ
ξ
ξ
ξ
 
(8.87) 
where 
I
k ∈
. 
8.11  Concurrency and Conflict 
The notions “concurrency” and “parallelism” are frequently used in the DEDS. 
They are related to the time evolution of the system events. In such considerations 
a certain time scale is necessary. There can be troubles with time relations if 
systems are distributed in space because of the physical relativity phenomena. One 
can imagine the problems when time synchronization signals are transmitted over 
long distance among individual components of a system. 
Petri nets as a tool for the DEDS representation can reflect the considered 
notions in some way. Let us introduce the following definition coping with the 
problem. 
Definition 8.16. Consider Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
. Let 
T
S ⊆
 be a subset 
of its transitions with cardinality greater than 1 and m be a reachable marking in 
PN. S is called the concurrent subset of the transitions at m if 
 
m
t
s
≤
=∑
∈
−
−
S
t
 
(8.88) 
Vectors 
−t  has been defined in Section 7.2. The meaning of the definition will 
be illustrated in the following example. 
Example 8.11. Consider a Petri net depicted in Figure 8.25 with the initial marking 
specified. Let us analyze whether 
{
}
2
1
1
,t
t
S =
 is a concurrent subset of the 
transitions by 
0
m . We have 

150 Modeling and Control of Discrete-event Dynamic Systems 
 
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
−
−
0
0
1
0
0
,
0
0
0
1
1
2
1
t
t
 
(8.89) 
 
0
1
0
0
1
1
1
0
0
1
1
1
0
0
1
0
0
0
0
0
1
1
1
m
t
s
=
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
≤
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
+
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
= ∑
∈
−
−
S
t
 
(8.90) 
It can be concluded that 
1
S  is a concurrent subset of the transitions at 
0
m . On 
the other hand,  
 
{
}
3
2
1
2
,
,
t
t
t
S =
 
(8.91) 
is not a concurrent subset of the transitions at 
0
m  because 
 
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
>
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
+
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
+
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
−
0
0
1
1
1
0
0
2
1
1
0
0
1
0
0
0
0
1
0
0
0
0
0
1
1
2s
 
(8.92) 
 p1 
p2 
p4 
p5 
t4 
t1 
p3 
z 
z 
z 
t2 
t3 
 
Figure 8.25. Petri net for concurrency analysis 

 
Properties of Petri Nets 151 
The main idea of Definition 8.16 is that a marking, as 
0
m in the example, 
should have so many tokens in the pre-places of transitions belonging to set 
1
S  
that all transitions in 
1
S  can fire simultaneously. In other words, firing a transition 
from 
1
S  does not influence the possibility to fire any of the remaining transitions 
in it. We remember that a standard way of the Petri net modeling technique is 
based on the assumption that at a time point just one transition fires. When 
considering concurrency, the possibility of simultaneous firing is investigated. 
Obviously, the modeling can be based on the assumption of simultaneous transition 
firing but the risk of conflicts and behavior complexity grow considerably.  
The concurrency is closely related to the possibility of arbitrary order of the 
firing, which is dealt with in the following theorems. 
Theorem 8.5. Consider a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
. Let S be a concurrent 
subset of transitions at a reachable marking m . Let a firing sequence σ~  start 
in m and contain any transition of S just once. Then the order of transition firing is 
arbitrary. 
Proof. Concurrency of transitions in S enables simultaneous firing of all transitions 
at m , i.e., for a single firing of transitions from S there are enough tokens in the 
pre-places of transitions belonging to S, regardless of a firing order. 
A slightly more complicated situation is with the reverse theorem. 
Theorem 8.6. Consider a pure Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
. If each transition 
of a subset S is fireable once in an arbitrary ordered firing sequence beginning in 
m and containing just transitions of S (the order of the transition firing is arbitrary), 
then S is a concurrent subset of transitions at m . 
The proof of the theorem can be found in Starke (1990). The role of the Petri 
net purity can be illustrated by a simple Petri net in Figure 8.26. Transitions 1t  and 
2t  can fire in an arbitrary order by 
0
m . However, despite this, the subset 
{
}
2
1,t
t
S =
 does not meet the requirement of Definition 8.16, as easily checked: 
 
( ) ( )
( )
( )1
2
1
1
0
2
1
=
>
=
+
=
+
=
−
−
−
m
t
t
s
 
(8.93) 
 
t1 
p1 
t2 
z 
 
Figure 8.26. Non-pure Petri net and concurrency 

152 Modeling and Control of Discrete-event Dynamic Systems 
It is also evident that both 
1t  and 
2t  cannot fire simultaneously. The next 
definition deals with the concurrency and conflict. 
Definition 8.17. Consider a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
. A conflict is said to 
be in a subset S of the PN transitions at a reachable marking m if all transitions in S 
are fireable at m but S is not a concurrent subset of the transitions at m. In 
particular, two transitions  ti, tj ∈ T of PN are said to be in the conflict at the 
reachable marking m if there is a conflict in the subset S={ti, tj}.  
Definition 8.18. A Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 is said to be conflictless iff 
there is no such a reachable marking at which two transitions of PN are in conflict. 
8.12  Analysis of Petri Net Properties 
Several properties of Petri nets can be analyzed using the reachability graph or the 
coverability graph. Using them may be different. The difference will be treated. 
Next, we consider a particular Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
 to be analyzed. 
Marking Reachability 
Let a marking represented by a vector m be given. Its dimension is 
n
P =
. 
Consider a bounded Petri net PN so that the reachability graph can be constructed. 
The vector m is not reachable if there is no node corresponding to m in the 
reachability graph. If such a node exists, m is reachable. 
If the considered PN is unbounded, the coverability graph can be constructed 
instead the reachability graph. In the coverability graph a node covering a given m 
is searched. Its existence is a necessary but not a sufficient condition for the 
reachability of m. The strings leading from m0 to the nodes covering m should be 
analyzed and checked whether m is contained in some of them. 
A necessary condition for m to be reachable is the existence of an integer 
solution of the linear algebraic system of equations 
 
x
N
m
m
Δ
=
−
0
 
(8.94) 
where 
Δ
N is a Δ -incidence matrix of PN and 
{ }
(
)
T
0
T
N
∪
∈
+
x
. The necessary 
condition is a consequence of Definitions 8.1 and 8.7. ( )
T
T
 is a transposition of 
m-tuple giving vectors. 
The system deadlock can be analyzed using the following definition. 
Definition 8.19. In a Petri net a dead marking is such a marking at which no 
oriented arc goes out the corresponding node in the reachability graph. 

 
Properties of Petri Nets 153 
Boundedness 
Very often, the inspection of a given Petri net and a simulation of transition firing 
by means of a Petri net graphical editor reveals the Petri net boundedness.  
Another possibility is to use the reachability graph. A Petri net is bounded if the 
reachability graph exists, i.e., if the number of nodes does not grow to infinity on 
constructing the graph. The coverability graph construction algorithm can be 
directly used. In such a case if the Petri net is bounded, the result will be the 
reachability graph. Otherwise the coverability graph is obtained and the Petri net is 
unbounded. 
Liveness 
A Petri net PN is L0-live or dead if there exists a transition 
T
t ∈
 that does not 
occur as a label of any arc of PN’s reachability or coverability graph. Transition t is 
L1-live if it appears as a label of at least one arc in the reachability or coverability 
graphs. It is L2-live if in the reachability or coverability graphs there exists an 
oriented path 
,
...
2
1
ki
i
i
a
a
a
containing at least two arcs labeled with t. t is L3-live 
if t is a label of an arc in the reachability or coverability graphs and the arc is an 
element of a cycle. 
The L4-livenes is more complicated. It can be resolved by means of the strong 
connectivity of the reachability or coverability graphs. First, a sufficient condition 
for the L4-livenes can be formulated as a theorem. 
Theorem 8.7. Consider a Petri net PN. If either its reachability or coverability 
graph is strongly connected and PN is L1-live then PN is L4-live. 
Proof. In the strongly connected reachability or coverability graph each pair of 
nodes is connected by an oriented path in both directions. Each transition occurs at 
least once in the graphs because PN is L1-live. There is always at least one oriented 
paths going out of each reachable marking and reaching the initial marking and 
from there continuing with paths, in which according to  L1-liveness there are  all 
transitions as labels at least once, as it is required by the L4-liveness. 
It is not necessary that the whole reachability or coverability graph be strongly 
connected as shown in the following theorem. The notion of the graph strong 
component was treated in Chapter 2. The extended notion of the sink strong 
component used in the theorem denotes such  a strong component for which no arc 
of its component nodes goes out to a node not belonging to it. 
Theorem 8.8. A Petri net PN is live (i.e., L4-live) iff there is at least one sink 
strong component in the reachability or coverability graph of PN ,and all sink 
strong components are L1-live. 
Proof. The L1-liveness of the strong component is defined analogously as that of 
the whole Petri net. A slight difference consists in that in case of the L1-liveness of 
the strong component, for each transition t there is a firing sequence going out of a 

154 Modeling and Control of Discrete-event Dynamic Systems 
node of the component and containing transition t as a label. Then, considerations 
of the proof of Theorem 8.7 apply. 
Obviously, all results in this section hold for Petri nets with capacities, too. In 
order to diversify provided examples, the following one uses this kind of Petri net. 
Example 8.12. An illustrative example from Abel (1990) is used to show the point 
of the last two theorems. The analyzed Petri net is shown in Figure 8.27. Its 
reachability graph is in Figure 8.28. 
 
p1 
p2 
p4 
C(p1)=2 
t4 
p3 
z 
t2 
t3 
z 
t1 
t5 
C(p2)=2 
C(p3)=2 
C(p4)=2 
 
Figure 8.27. Petri net with capacities illustrating meaning of strong components for the 
liveness 
1  1  0  0  
2  0  0  0   
t1 
t3 
0  2  0  0 
1  0  1  0  
t2 
t3 
t2 
t1 
0  1  1  0  
0  1  0  1  
0  0  1  1  
0  0  2  0  
1  0  0  1   
t2 
t1 
t3 
t4 
t5 
t2 
t1 
t3 
t5 
t5 
Strong component CMP1 
Strong component CMP2 - sink 
 
Figure 8.28. One L1-live sink strong component in the reachability graph for Petri net in 
Figure 8.27 

 
Properties of Petri Nets 155 
Reversibility 
In terms of reachability/coverability graph, a Petri net is reversible if from each 
node of the graph a directed path exists ending in the initial node. The reversibility 
and connectivity are dealt with in the following theorem. 
Theorem 8.9. A Petri net is reversible if its reachability or coverability graph is 
strongly connected. 
Proof. The theorem is a direct result of the graph strong connectivity property. On 
the other hand, an unbounded Petri net can be reversible even if its coverability 
graph is not strongly connected. We refer to Example 8.6 with Figure 8.15 in 
Section 8.7 illustrating the case. In such cases reversibility can be analyzed 
analogously as liveness using the properties of the sink strong components of the 
coverability graph. 
A necessary and sufficient condition for reversibility is formulated in the 
following theorem. 
Theorem 8.10. A bounded Petri net is reversible iff its reachability graph is 
strongly connected. 
Proof. If a bounded Petri net is reversible, then from each node of its reachability 
graph a firing sequence leads to the initial marking 
0
m  and from it to each 
reachable marking. A consequence of this is the strong connectivity of the 
reachability graph. The inverse implication is dealt with in the Theorem 8.9. 
Finally, an important relation of the main Petri net properties is given next. 
Theorem 8.11. All three Petri net properties, i.e., liveness, boundedness and 
reversibility, are mutually independent. 
Proof. The proof through counterexamples is applied. Some examples showing 
independence have already been introduced. See live, unbounded, non-reversible 
PN in Figure 8.5; non-live, unbounded, non-reversible PN in Figure 8.10; non-live, 
bounded, non-reversible PN in Figure 8.12; live, unbounded, reversible PN in 
Figure 8.14; etc. 
8.13  Structural Properties 
The main properties of Petri nets were analyzed in the previous section. However, 
it is necessary to mention briefly basic structural properties of Petri nets. A 
structural property does not depend on the initial marking. Let us define the Petri 
net structure for this purpose. 

156 Modeling and Control of Discrete-event Dynamic Systems 
Definition 8.20. Consider a Petri net 
(
)
0
,
,
,
,
M
W
F
T
P
PN =
. The structure of the 
Petri net PN is given by 
 
(
)
W
F
T
P
PS
,
,
,
=
 
(8.95) 
Some chosen structural properties based on PS only are listed below. 
Structural Liveness 
PN is said to be structurally live if there exists an initial marking 
0
M  at which PN 
is live. 
Structural Boundedness 
PN is said to be structurally bounded if it is bounded given any initial marking 
0
M . 
Structural Conservativeness 
PN is structurally conservative if for any initial marking, PN is conservative with 
respect to a vector 
iv . 
Siphons and Traps 
Siphons and traps are two important structural objects in a PN and closely related 
to the Petri net properties, especially deadlock and liveness. Before their definition, 
the following notation is introduced. The pre-set of a place p, denoted as ●p, is the 
set of p’s input transitions, i.e., ●p={t∈T, O(p, t) ≠0} formally. Its post-set is  
p●={t∈T, I(p, t) ≠0}. Consider a set of non-empty places S⊆P. Its pre-set is 
●S=U
S
p∈
●p  and and post-set S●=U
S
p∈
p●. 
 
Definition 8.21. A set of place S⊆P is called a siphon if ●S⊆S●. It is a trap if S●⊆●S. 
 
Their physical meanings are explained as follows. A siphon can keep or lose its 
tokens during any transition firing. Once it loses all tokens, it remains empty and 
thus disables all of its output transitions. An empty siphon is, therefore, the cause 
of partial or complete deadlock. A trap can keep or gain tokens during any 
transition firings. Once it receives tokens or is marked, it remains marked 
regardless which transition fires. 
Example 8.13. Consider the Petri net in Figure 7.18 and S={pM1, pM2, pA2, pB2}. It is 
easy to find that: 
 
●pM1={ tA2, tB3},  ●pM2={ tA3, tB2}, ●pA2={ tA2 }, ●pB2={ tB2} 

 
Properties of Petri Nets 157 
pM1
●={ tA1, tB2},  pM2
●={ tA2, tB1}, pA2
●={ tA3 }, pB2
●={ tB3} 
 
Thus 
 
●S={ tA2, tA3, tB2, tB3} and S●={ tA1, tA2, tA3, tB1, tB2, tB3}. 
 
Clearly, ●S⊂S●. Hence, S is a siphon. Initially it is marked with two tokens. 
Starting at the initial marking in Figure 7.18, after firing transitions tA1 and tB1 
respectively, S is empty and the net enters a deadlock marking.  
Now consider S={pM1, pA1, pB2}. We can easily find that ●S=S●={ tA1, tA2, tB2, 
tB3}. Hence it is a siphon and trap as well. It is initially marked with a token and 
remains so regardless of marking evolution. 
 
A siphon is minimal iff it contains no other siphons as its proper subset. A 
minimal siphon is strict if it contains no marked trap. A strict minimal siphon may 
become empty during the marking evolution. Hence, to make such net live is 
control such siphons so that they are never empty. A P-invariant-based control 
method can be developed to achieve this purpose. By adding a control place (called 
monitor), these siphons can be well controlled (Ezpeleta et al. 1995). Unfortunately, 
the number of such siphons grows exponentially with the size of a Petri net and 
thus leads to very complex control structure for a sizable system. To reduce the 
control complexity, Li and Zhou (2004, 2006) invented the concept of elementary 
siphons whose control can prevent all other siphons from being emptied. They 
number is bounded by the smaller of |P| and |T|. 
There are other structural properties related to non-structural ones studied by 
many researchers. Often, they are studied in relation to a particular Petri net class, 
e.g., marked graphs, free-choice nets, assembly Petri nets, disassembly Petri nets, 
augmented marked graphs, and production Petri nets. A very good systematic 
treatment of them can be found in an excellent tutorial paper written by Murata 
(1989) and books such as Zhou and Venkatesh (1998). 
8.14 Problems and Exercises 
8.1. A pure Petri net is given by the vectors 
 
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
=
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
=
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
=
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
=
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛−
=
1
0
0
0
1
1
,
0
1
1
0
0
1
,
1
0
1
1
0
0
,
0
1
0
1
1
0
,
0
0
1
1
1
1
5
4
3
2
1
t
t
t
t
t
 
corresponding to transitions t1–t5. The initial marking is 
(
)
T
0
0
0
0
0
0
1
=
m
. 

158 Modeling and Control of Discrete-event Dynamic Systems 
Represent the Petri net in the graphic form. Using vector representation 
determine if 
1t  is fireable at 
0
m . Construct the reachability graph. Analyze the 
Petri net properties: boundedness, liveness and reversibility.  
8.2. A Petri net is depicted in Figure 8.29. Draw the coverability graph for it. 
Figure 8.29. A Petri net the coverability graph to be drawn for Exercise 8.2 
8.3. Analyze basic properties of the following Petri net in Figure 8.30. 
Figure 8.30. A Petri net for Exercise 8.3 
What graph is it possible to construct: the reachability or coverability one? Use 
Theorem 8.2 to show whether the Petri net is unbounded. 
8.4. A Petri net is given in Figure 8.31. Draw the reachability graph for it and using 
the graph determine its following properties: boundedness, liveness and 
reversibility. Find a P–invariant for the given Petri net. 
8.5. Consider a computer processor with an input buffer having capacity 1 for 
waiting task to be processed by the processor. If a task requires processing, either 
the buffer is free and the task is put into it or if the buffer is occupied the task is 
refused. If a task is in the buffer and the processor is free, the task is moved from 
the buffer to the processor. Only one task can be processed in the processor. After 
processing, the task is removed from the processor and the processor is free.  
• 
Describe the behavior of the specified buffer-processor system using a 
deterministic finite automaton. 
p1
p2
p3
p4
2
t1 
t2 
t3 
p1 
p2 
p3 
t2 
2 
2
2
t1 

 
Properties of Petri Nets 159 
• 
Describe the same with a Petri net and compare both representations. 
• 
Modify the Petri net for the case when the buffer capacity is two. 
• 
Analyze the properties of both Petri nets. 
 
Figure 8.31. A Petri net for Exercise 8.4 
8.6. The Petri net in Figure 8.32 has the initial marking 
(
)
T
0
1
1
0
0
=
m
. Find a 
concurrent subset of transitions at 
(
)
T
0
1
2
2
=
m
where the number of elements in 
the subset is greater than 1.  Prove the concurrency using vectors. 
Is there a conflict in the Petri net at some reachable marking? 
Figure 8.32. A Petri net for concurrency analysis 
8.7. Is it possible that a Petri net live at level 4 is not reversible? Find a counter-
example.  
8.8. Prove that the existence of T-invariant is a necessary condition for a Petri net 
to be reversible.  
8.9. Derive all the structural properties of the Petri net in Figure 8.31. 
8.10. Derive all the structural properties of the Petri net in Figure 8.32. 
8.11. Given the Petri net in Figure 8.33, 1) derive the reachability graphs when 
initial marking is m0=(2 0 0 0)T and m0=(2 1 0 0)T; 2) derive P and T-invariants; 3) 
find all deadlocks; and 4) analyze its structural properties. 
p1 
p2
p3
p4
p5 
t1 
t2 
t3
t4
p1
p2
p3
p4
2
t2
t1 
t3
2

160 Modeling and Control of Discrete-event Dynamic Systems 
 
Figure 8.33. A Petri net for property analysis in Exercise 8.11 
 
 
 
Figure 8.34. A Petri net for property analysis in Exercise 8.12 
 
8.12. Given the Petri net in Figure 8.34, 1) derive the reachability graphs when 
initial marking is m0=(2 1 0 0 0 0)T and m0=(2 2 0 0 0 0)T; 2) derive P and T-
invariants; 3) find all deadlocks; and 4) analyze its structural properties. 
8.13. Construct Petri net examples such that 1) it is live and safe but non-reversible; 
and 2) it is reversible and safe but non-live, respectively. 
8.14. Given the Petri net in Figure 8.33, find all the minimal siphons. 
8.15. Given the Petri net in Figure 8.34, find all the minimal siphons. Define a 
minimum trap as one that contains no trap as its proper set. Find all the minmim 
traps for the net in Figure 8.34. 
8.16. Given the Petri net in Figure 8.33, when the net evovles to a deadlock, e.g., (0, 
2, 0, 0)T, prove that {p1, p3, p4} is a siphon.  
8.17. Prove that given any Petri net with an initial marking, at any deadlock 
marking, all the places with no token form a siphon. 
 

9 
Grafcet 
9.1  Basic Grafcet Components 
Grafcet is designed as a specification tool for logic control to be implemented 
preferably on programmable logic controllers (PLC).  It is a tool related closely to 
the binary safe Petri nets interpreted for control (Section 7.5). The marking of such 
Petri nets is formally expressed by 
 
(
)
{ }
(
)
0
 
1,0
,
m
PN
k
i
k
R
M
v
v
p
M
∈
∀
∈
=
, 
P
pi ∈
∀
 
(9.1) 
Equation (9.1) results in the weights of the Petri net given by 
{}
1
:
→
F
W
, i.e., 
the weights are units. 
The syntax of Grafcet components and elements has been precisely elaborated 
in order to support effective and correct implementation of the control policy into 
final control programs. In that context the position of the Grafcet is similar to that 
of the finite automata, Petri nets, state charts, etc., being a tool standing between 
the system control requirements and the instruction codes realizing the control 
programs in the used hardware environment.  
Like the Petri nets interpreted for control, Grafcet may be viewed as an 
extension of standard Petri nets defined in Definition 7.2. Quoting David and Alla 
(1994), the extension makes it possible to describe not only what “happens” but 
also “when it happens”.  
A series of international standards like IEC 848, ISO 7185 establishes concepts 
and guidelines for PLC recommended properties and programming technology. 
The standardization efforts in this field resulted in a complex standard IEC 61131, 
which supports design of industrial automation systems using programmable logic 
controllers both in hardware and software aspects. Basic features of hardware and 
software automation means are specified in the standard IEC 61131. Grafcet 
belongs to the tools keeping in line with concepts and ideas of that standard. 
IEC 61131, part 3, provides three textual PLC programming languages and 
three graphical ones (John and Tiegelkamp 2001). The Sequential Function Chart 
graphical programming language is in essence close to Grafcet, while it has several 

162 Modeling and Control of Discrete-event Dynamic Systems 
additional language constructs (e.g., sequence, loop or divergent path with user-
defined priority) and it is framed into broader structural context with other PLC 
programming languages. We refer readers for more details to an excellent book 
(John and Tiegelkamp 2001). 
The aim of this chapter is to follow up concepts of the Petri nets interpreted for 
control, which are melted into Grafcet, and not all PLC programming languages 
used in practice. 
It is possible to define a class of Petri nets, which corresponds to a set of 
Grafcet models. The class is characterized as Petri nets with capacities and weights 
equal to one, and the binary initial marking. Firing rules of the Petri net class 
corresponding to Grafcet models should have been slightly adapted in order to 
ensure the correspondence. 
We emphasize that Grafcet is intended for the DEDS control specification 
within the structure of Figure 4.1, enabling one to consider the system inputs and 
outputs, synchronization of events by external inputs and generation of output 
control commands. Particular graphic models, which are put together by means of 
Grafcet are called grafcets and written with the small letter. A grafcet is a simple 
labeled oriented mathematical graph with two disjunctive sets of nodes: steps and 
transitions, i.e., it is a bipartite oriented graph. 
 
3
1
2
(1) 
(2) 
b. 
2 
3 
Inactive step 
Active step 
Transition 
1 
Initial step 
a. 
4 
(1) 
(3) 
r1 
r1 
r2 
r3 
 
Figure 9.1. Grafcet steps, transitions, and oriented arcs 
Steps in a grafcet are connected with the transitions and vice versa transitions 
with steps via oriented arcs. Steps correspond to Petri net places and Grafcet 
transitions to Petri net transitions. A step can be active or inactive. An active step 
indicates some partial situation or state in a system and a Grafcet transition, when 

 
Grafcet 163 
fired, implies occurrence of an event. A step activity is marked by a token located 
in the step. The step is represented by a square, the initial step by a double square, 
and the transition by a short bar (Figure 9.1a). The initial step is automatically set 
active at the beginning of the system control based on Grafcet. 
In Grafcet the arcs are oriented always from the top down; in such case arrows 
are not used. An arrow is added only to the bottom-up running part of an arc 
(Figure 9.1b). A layout of a simple sequence of steps and transitions is shown in 
Figure 9.1b.  
A natural question arises about arcs joining or branching. Their syntax is ruled 
in the following way: 
a. Two or more arcs coming in a transition can be joined only by a double bar 
as shown in Figure 9.2a. The joining is called junction AND. 
b. An arc going out of a transition can be branched into arcs and go to steps 
only through a double bar as shown in Figure 9.2b. The branching is called 
distribution AND. 
Figure 9.2a–f. Syntax of the Grafcet graphical components 
 
1 
2 
3 
4 
(1) 
5 
1 
2 
3 
(1) 
4 
5 
1 
2 
3 
(1) 
4 
5 
1 
2 
3 
(1) 
4 
(2) 
1 
2 
(1) 
(2) 
3 
1 
(1) 
(2) 
(3) 
d. 
b. 
e. 
f. 
c. 
a. 
r1 
r1 
r2
r1
r1
r2
r3 
r1 
r1
r2

164 Modeling and Control of Discrete-event Dynamic Systems 
c. Two or more arcs each coming out from a transition can join and go in a 
step as shown in Figure 9.2c. Such joining is called junction OR. 
d. An arc going out of a step can branch into arcs going each in its transition 
as shown in Figure 9.2d. The branching is called distribution OR. 
The combination of cases a and b from Figure 9.2a, b is possible, resulting in 
Figure 9.2e. It is to be underlined that component connections other than those 
presented in Figure 9.2a–d are not allowed. For example, the structure depicted in 
Figure 9.2f is not allowed. 
Step and transition indexing is clear from Figure 9.2. Steps and transitions 
without input (output) arcs are allowed and are called source (sink) steps or source 
(sink) transitions. 
A logic expression has to be associated with each transition. The expression is a 
Boolean variable or function. It is called the receptivity. If being true, it expresses 
that the transition firing condition is met. In Figure 9.2 the receptivity is denoted as 
ir , i=1, 2 and 3. 
9.2  Dynamics Modeling with Grafcet 
In Grafcet the system dynamics is represented via the following firing rules: 
1. A transition is fireable iff all preceding steps (the pre-steps) are active and 
the transition receptivity is logically true. This rule is graphically expressed 
by a double bar in the junction AND. 
2. If a transition is fireable it is immediately fired whereby firing consists in 
deactivating all steps preceding the transition and activating all steps 
following it (the post-steps). Again this rule is graphically expressed by a 
double bar in the distribution AND.  
3. Simultaneously fireable transitions are simultaneously fired. 
4. When a step has to be simultaneously activated and deactivated, it remains 
active. 
5. When a transition is fireable, the tokens are removed from all its pre-steps 
and are put into all post-steps. 
The transition receptivity is built up of Boolean variables, which can be internal 
or external ones. The internal variables are states of the steps. It is usual that for a 
step with index i a Boolean variable 
i
X  is defined. If 
1
=
i
X
, i.e., 
i
X  is true, then 
the step i is active. Inversely, 
0
=
i
X
 means that the step i is inactive. A general 
form of the receptivity is 
 
C
E
R
∧
=
 
(9.2) 
where ∧ denotes logical conjunction of the event E and the logic condition C. 
Event 
a
E =↑
 is defined as a Boolean variable or function that is true for the rising 

 
Grafcet 165 
edge of another Boolean variable a . The variable is true in a discrete time point, 
i.e., for an infinitely short time interval. In other words, 
true
a =
↑
 iff a  changes 
from 0 to 1. Similarly, 
a
↓
 is related to the falling edge of an external logic 
variable or function. C in Equation (9.2) is a logic variable or function, which can 
be external or internal one with respect to a given Grafcet. Condition C may not 
contain events.  
The distribution OR elementary structure (see Figure 9.2d) may bring about an 
indeterminism in the case when receptivities r1, r2, and r3 are not mutually logic 
exclusive. PLC hardware implementations of the receptivities may not be 
simultaneous in spite of the designer’s assumption they are when step 1 is active 
(Figure 9.2d) and, e.g., receptivities r1 and r2 are true in “the same time”. In such a 
case, despite of the assumption, hazardous dynamics causes the post-step of 
transition (1) can be activated, step 1 deactivated and post-step of transition (2) 
may not be active. Designers have to analyze hardware features in order to obtain 
the required behavior. A safer way is to use mutual logic receptivity exclusion in 
divergence OR. 
 Active influence on the controlled and control systems is modeled in the 
Grafcet by the so called actions. They are graphically represented by rectangles 
positioned to the right from the steps (Figure 9.3). There are two kinds of actions: 
level and impulse actions. An action is set if its associated step is active.  
A level action is realized by means of a Boolean variable, e.g., 
switch_on_motor_M  where switch_on_motor_M=1 means that motor M is 
switched on; switch_on_motor_M=0 means that there is no signal for keeping 
motor M on; similarly switch_off_motor_M=1 represents a signal for motor 
switching off while switch_off_motor_M=0 means that there is no signal for motor 
switching off. The Boolean variable switch_on_motor_M is set to logic 1 if the 
corresponding step is active. The action for deactivation of switching has the 
variable 
M
motor
on
switch
_
_
_
 (logic inversion). 
3 
1 
2 
(2) 
(1) 
(3) 
r1 
r2 
r3 
Switch_on_motor_M 
 Switch_off_motor_M 
  if 
y
X ∧
4
 
4 
r4 
r5 
 
Figure 9.3. Level actions: unconditioned for step 2, conditioned for step 3 

166 Modeling and Control of Discrete-event Dynamic Systems 
 
Figure 9.4. Impulse actions 
Boolean variables associated with level actions are actually control commands 
that force either the external system to be controlled to some action by the Grafcet, 
or internally influence the control system itself via internal variables. The level 
actions may be unconditioned or conditioned by a Boolean variable or Boolean 
function. The use of the level actions is illustrated in Figure 9.3. The variable 
“switch_off_motor_M” is true if step 3 is active and step 4 is active and variable y  
is true. 
An impulse action associated with step 
i
X  is called as event 
i
X
↑
 that sets a 
command variable 
i
w  to a logic value 
i
w  for an infinitely short duration. The 
variable 
i
w  may be interpreted as an order. Figure 9.4 shows a Grafcet and the 
corresponding time diagrams illustrating the impulse actions. Impulse actions are 
represented by hatched rectangles. The impulse action produces an impulse 
Boolean variable, which causes the motor switching on. Impulse actions can be 
unconditioned or conditioned, similarly as the level actions.  
A useful component of the Grafcet is a macrostep. Its idea is to represent a part 
of a Grafcet by one step, which is described in detail elsewhere. The macrostep 
should have an identification tag. A detailed macrostep presentation, the so-called 
macrostep expansion, is presented separately and begins with an input step I and 
ends with an output step O.  
The use and properties of macrosteps depend on particular hardware units. The 
macrostep design must comply with the following rules: 
 
3 
1 
2 
(2) 
(1) 
(3) 
r1 
r2 
r3 
2 
Order_to_switch_motor_M_on 
Order_to_switch_motor_M_off
4 
(4) 
r4 
r1 
r2 
r3 
r4 
2
X
Order_to_switch_motor_M_on
3
X
4
X
Order_to_switch_motor_M_off
State of motor switching on

 
Grafcet 167 
1. The macrostep expansion contains just one input and one output step. 
2. Each transition firing before a macrostep activates the input step of the 
macrostep expansion. 
3. The output step of the macrostep expansion contributes in enabling the 
downstream transitions according to the Grafcet structure. 
4. There are no arc connections between the macrostep expansion (of course 
with the exception of the input and output steps) and the rest of the grafcet 
An example of a macrostep is given in Figure 9.5. 
Grafcet considers time via time logic variable denoted as 
 
Δ
=
/
/ i
t
v
 
(9.3) 
where t indicates a time variable, i refers to the logic variable 
i
X  and Δ  is a time 
interval. If 
0
=
v
 before 
i
X  becomes 1, then after event 
i
X
↑
 the interval Δ  
elapses and v changes from 0 to 1. If 
1
=
v
 and 
i
X  changes from 0 to 1, v becomes 
0 and, similarly as before, v will be 1 after the interval Δ . If after 
i
X
↑
, event 
i
X
↑
 repeats in time period shorter than Δ , time counting starts from the last 
event 
i
X
↑
. Figure 9.6 illustrates the use of a time variable in a Grafcet. A Grafcet 
with a time variable 
6
/
4
/t
 is given. The time unit is 1 s. Time diagrams for the 
grafcet in Figure 9.6 is given in Figure 9.7. 
A situation when several transitions can be fired immediately one after another 
is called unstable. If a step is activated and after its activation the related transition 
is fireable, the situation is unstable. Such an iterated firing ends in a step whose 
deactivation depends on the next transition’s receptivity that has not yet been true, 
or on activities of other pre-steps of this transition. Such a situation is stable. A 
level action can be realized only in the stable situation while an impulse action can 
be realized both in a stable as well as in an unstable situation. 
 
 
O
I
1
(2) 
(1) 
r1 
r2 
1 
M 
Action
 
Figure 9.5. Expansion of the macrostep 

168 Modeling and Control of Discrete-event Dynamic Systems 
 
 
6  
2  
4  
(2) 
(1) 
(3) 
r2= a 
r4= t/4 /6
b
a ∧
=
3r
1
3  
V 1  
5  
V 2  
(4) 
(5) 
r5= 1
r1= s 
 
Figure 9.6. Work with time in Grafcet 
Figure 9.7. Time diagram for grafcet in Figure 9.6. 
 
s 
a 
b 
X1 
X2 
X3 
X4 
X5 
X6 
V1 
V2 

 
Grafcet 169 
9.3  Comparison of Petri Nets and Grafcet 
Petri nets interpreted for control (Section 7.4) and Grafcet have many common 
features. In fact, Grafcet may be viewed as being derived from the Petri nets. Both 
tools produce models that are bipartite oriented labeled mathematical graphs. Petri 
nets have places and transitions, while Grafcet has steps and transitions as graph 
nodes. Distributed and parallel activities are specified through markings and the 
system dynamics through transition firings subdued to firing rules. 
Grafcet has a few specific properties differentiating it from Petri nets 
interpreted for control (PNC). The differences are as follows. 
Marking of grafcets is a binary one whereas marking of PNC can be numerical. 
Firing rules in Grafcet are consequently subjected to the binary marking case. A 
step can only be active or inactive. Figure 9.8 illustrates how it works. Transition 
(1) is fireable and its firing only confirms activation of step 2 as shown in Figure 
9.8b. 
Figure 9.8a, b. The marking in Grafcet is strictly binary 
Fireable transitions in Grafcet fire simultaneously while in the Petri nets 
fireable transitions can fire only one at a time. Figure 9.9 shows the marking 
development in PNC and in grafcets; x is a logic expression constituting a 
receptivity in grafcets or a logic firing condition in PNC. The marking result in 
Figure 9.9c is reached after firing 1t  and then 
2t . Another possibility is firing 
2t  
first and then 1t . 
Mutual relation of Petri nets and Grafcet is the following. If a Petri net is safe, 
then an equivalent Grafcet exists. On the other hand, it is not possible to represent 
every grafcet by an equivalent PNC according to Definiton 7.2. This is true if in a 
grafcet there is not any of the structures, which differentiate Grafcet from PNC 
(depicted in Figures 9.8 and 9.9), as then a PNC exists being equivalent to it. In 
such a case, all tools for Petri net analysis are applicable for Grafcet as well. 
Otherwise, the analysis tools are to be adapted for Grafcet. More comparisons 
between Petri nets and Grafcet can be found in Giua and DiCesare (1993) and 
Zhou and Twiss (1996). 
 
 
⇒ 
x 
x 
p1 
p1 
p2 
p2 
z 
z 
z z 
a. 
⇒ 
1 
1 
2 
2 
r1=x
(1)
(1)
z 
z 
z 
b. 
r1=x 

170 Modeling and Control of Discrete-event Dynamic Systems 
Example 9.1. Figure 9.10 shows the crossing of cars and pedestrians. They all need 
to pass through the narrow part of the street. Either one car at a time can pass 
through the narrow part in one of the two directions, or pedestrians may cross the 
street there. The crossing control ensures a cyclic alteration of the car directions. 
Pedestrians are allowed to cross the street only after pushing the button on any side 
of the street when the time interval for car passing has expired.  
or
x
p1
p2
z
a.
b.
t1
p3
t2
x
x
p1
z
t1
t2
x
x
p1
t1
z
p3
t2
x
⇒
p2
p3
p2
1
2
r1=x
(1)
z
3
r2=x
(2)
1
2
r1=x
(1)
3
r2=x
(2)
⇒
z
z
x
p3
t2
x
z
z
p1
p1
t1
x
p3
t2
x
z
z
p1
p1
t1
⇒
or
x
p3
t2
x
z
p1
p1
t1
z
3
1
r1=x
(1)
z
2
r2=x
(2)
z
c.
3
1
r1=x
(1)
z
2
r2=x
(2)
⇒
d.
 
Figure 9.9. Comparison of the firing rules 

 
Grafcet 171 
 
Push 
button b1 
Push 
button b2
STOP 
GO 
STOP 
GO 
S1
F1
S2 F2 
F3 S3 
F4 
S4 
CONTROL START
sw0 
sw1 
 
Figure 9.10. Situation on a crossing 
Grafcet specifying the control of the crossing is shown in Figure 9.11. If a push 
button is pressed, the pedestrian is allowed to cross after the time interval for cars 
expires. Then a car can pass through. If sw1 is activated and the running time 
interval is finished, the system returns to the initial state. Other details are evident 
from the Grafcet.  

172 Modeling and Control of Discrete-event Dynamic Systems 
Figure 9.11. Grafcet for the example with crossing 
Example 9.2. Control of the manufacturing cell in Figure 5.1 is written by a 
Grafcet in Figure 9.12. The reader can compare it with the Petri net in Figure 7.16. 
As an exercise it is possible to complete receptivities in the Grafcet (as is done for 
transitions (1) and (2) in Figure 9.12). 
 
2 
3 
10
(2) 
15
(21) 
6 
(5) 
(12) 
1
sw
X13 ∧
 
1 
(1) 
S1,S2,S3,S4,
F4
,
F3
,
F2
,
F1
 
t/4/60 sec
t/2/30 sec
(3) 
4 
5 
(4) 
S1,S2,S3,S4,F1 
F1,S2,S3,S4,S1
S1,S2,S3,F4,S4
(14)
1
sw
X13 ∧
7 
S1,S2,S3,S4,F4
t/6/60 sec 
(7) 
(6) 
8 
S1,F2,F3,S4,
S3
,
S2
9 
S1,S2,S3,S4,
F3
,
F2
t/8/60 sec 
(8) 
1
sw
X13 ∧
 
(11) 
sw1 
sw0 
(15) 
sw0
14
sw0
(
)
sw1
b
b
2
1
∧
∨
11
12
(16)
13
sw1
X9 ∧
2
1
b
b ∨
sw0
sw0 
1
sw
X13 ∧
 
sw1
(9) 
(10) 
(13)
(17) 
(18) 
(19) 
(20) 

 
Grafcet 173 
Figure 9.12. Grafcet for the manufacturing cell in Figure 5.1 
9.4 Problems and Exercises 
9.1. Complete all receptivities in Figure 9.12. Compare the grafcet with the 
corresponding Petri net. 
9.2. Machine M serves for the production of products C from input workpieces A 
and B, respectively as Figure 9.13 shows. One workpiece A and one B must be 
available for the start of production. Solve the following design problems: 
1 
2 
3 
4 
5 
6 
7 
10
11
12
14
8 
9 
13 
15 
AM 
OPA 
BM 
OPAB 
ABO 
16
17
18
12
X
ia 
(1) 
(2) 

174 Modeling and Control of Discrete-event Dynamic Systems 
a. Complete the system with necessary sensors enabling its control according 
to the function described above. 
b. Draw a grafcet specifying the system control with respect to the workpiece 
transfer and execution of the production. 
Figure 9.13. Production cell with one machine 
9.3. Find a Petri net interpreted for control specifying the crossing control from 
Example 9.1. Compare both Petri net and Grafcet of this syetem. Think about the 
use of the found Grafcet and the Petri net to write a control program of the crossing. 
Figure 9.14. A grafcet for Exercise 9.4 
9.4. A Grafcet is given in Figure 9.14. Analyze the control specified by the Grafcet. 
Figure 9.15 is a diagram of the logic variables s, a, and b. Complete the diagram 
with the time courses of the logic variables 
6
1,..., X
X
 corresponding to the grafcet 
A 
B 
M
C 
1
2
3
4
5
6
V1
V2
(1)
(2)
(3)
(4)
(5)
b
a
6
/
4
/t
=1
s
a

 
Grafcet 175 
steps and the time course of the logic time variable 
6
/
4
/t
. Time is given in 
seconds. 
Figure 9.15. Timing diagram of logical variables s, a and b 
 
1 
0 
2 
3
4
5
6
7
8
9
10
b 
a 
s 
t

10 
Timed and High-level Petri Nets 
10.1  From Standard to Higher-level Petri Nets 
Petri nets in the standard form as considered until now are an effective tool for 
DEDS modeling and control design. They enable one to specify powerfully the 
system function. Analysis methods are used for testing Petri net model properties 
and hence to check the correct system function (Desel 2000). Very often 
quantitative properties of the system behavior are another point of interest. In other 
words, a kind of system function performance or system efficiency is dealt with. In 
order to make the performance analysis feasible, additional values, parameters, and 
variables are used within the Petri nets (Čapkovič 1993, 1994, 1998). Another 
reason for  additional values to be built in the Petri nets is to make the Petri net 
models more transparent and understandable even for large and complex DEDS. 
Such extensions are often denoted as  high level Petri nets (Struhar 2000) or 
generalized Petri nets (Juhás 2000). 
Standard Petri nets are not suitable for performance analysis. Undoubtedly, for 
performance analysis, an important system variable is time. Time enriches 
information by telling in what time or time interval a particular event occurs or 
should occur (Čapek and Hanzálek 2000). There are three ways to embed time into 
Petri nets. The first is to map the Petri net places into time intervals given as real or 
integer numbers; the second is to map them analogously into the Petri net 
transitions; and the last is to map into the arcs (Zhou and Venkatesh 1998). The 
options can be used separately or together. The given time intervals cause delays in 
firing the respective transitions. Time intervals can be considered in deterministic 
or stochastic ways. The deterministic case of the timed Petri nets will be studied in 
Section 10.2 and the stochastic case in Section 10.3.  
Section 10.4 deals with a class of high level Petri nets called colored Petri nets. 
The main idea is that each token in a colored Petri net has its individuality 
represented by a specific data value called color. Places, transitions and arcs of a 
Petri net can be equipped with logic conditions respecting the particular color of 
each token. Section 10.5 deals with a class of the high level Petri nets including the 
fuzziness property. Adaptive Petri nets are studied in Section 10.6 and Petri net-
based design tools are presented in Section 10.7. 

178 Modeling and Control of Discrete-event Dynamic Systems 
10.2  Deterministic Timed Petri Nets 
Time may be associated either with the Petri net places or transitions, or with both. 
We will follow a general approach in (Zhou and Venkatesh 1998) covering three 
associations either together or separately in a deterministic way. The deterministic 
time association is a Petri net model extension enabling performance analysis using 
time relations. Deterministic approach is not applicable for all Petri nets defined by 
Definition 7.2. The problem originates mainly from the Petri net conflicts not 
excluded in the definition. A typical Petri net class with conflicts is the class of 
free-choice nets described in Section 7.4. Two or more arcs outgoing from a place 
bring about conflicts. The uncertainty about the continuation of the transition firing 
being in a conflict needs to model time behavior in a stochastic way. The 
deterministic way is very difficult or rather impossible to apply in praxis. 
Therefore, the deterministic time association is mostly restricted to the class of the 
marked graphs (see Section 7.4) – also named event graphs. The timed marked 
graphs are delimited by the following definition. 
Definition 10.1. A timed marked graph is given by 
 
(
)
τ
π ,
,
.
,
,
,
0
M
W
F
T
P
TMG =
 
(10.1) 
where the meaning of 
0
,
,
,
,
M
W
F
T
P
 is the same as in Definition 7.2, 
(
)
0
,
,
,
,
M
W
F
T
P
MG =
 is a marked graph (
)1
:
 
=
•
=
•
∈
∀
p
p
P
p
i.e.,
, and π is the 
place delay function 
+
→R
P
:
π
( the set of non-negative real numbers), τ is the 
transition firing time function 
+
→R
T
:
τ
 and  
1. A token, which arrives in a place, is not available for the connected 
transition with the place during the time associated with the place. 
2. A transition is fireable and fires if all its pre-places contain the available 
tokens (i.e., tokens not time blocked) required by the arc weights.  
3. If a transition is fireable, its firing starts by removing the respective number 
of tokens from pre-places and firing completes after the time associated 
with the transition expires and the tokens are deposited in the respective 
post-places. 
In what follows, we will show a paradigm for the system performance analysis 
via deterministic timed Petri nets. For this purpose the timed marked graphs will be 
considered having all arc weights equal to one. In other words, we consider Petri 
nets belonging to the class of timed binary marked graphs. Moreover, we consider 
strongly connected timed binary marked graphs where for the graph connectivity 
property both places and transitions are considered as graph nodes.  
In the above delimited Petri net sub-class, the performance analysis is based on 
directed simple cycles contained in the particular Petri net, which is taken as a 
mathematical graph with places and transitions given as a set of nodes. In a 
directed simple cycle, the total time delay is a sum of times associated with all 

 
Timed and High-level Petri Nets 179 
places and transitions comprised in the cycle. In a simple cycle the total number of 
tokens is the number of tokens present in all the places in the cycle. Note that a 
directed simple cycle is one that contains no repeated nodes except the beginning 
and ending ones. The minimum cycle time of the analyzed marked graph as a 
whole is 
 
i
i
i
N
D
max
=
μ
 
(10.2) 
where Di is the total time delay of the i-th directed simple cycle and Ni is the total 
number of tokens in this cycle, Di/Ni is the cycle time.  
The bottleneck cycle is the j-th one where Dj/Nj = μ holds. A system may have 
multiple such cycles. When additional resources are available to improve the 
system productivity, one should certainly invest into the facility causing the 
bottleneck. The acquisition of a same machine can be reflected through the 
increase of a token in a loop. The improvement in the speed of a process can be 
reflected through the reduction of the delay in a place or transition. The delay can 
also be associated with the arcs in a marked graph, simulating the time for a token 
to flow through the arc. This extension is useful in modeling transportation of 
goods over conveyors, or fluid flowing through a pipe in process industry. 
The use of the above approach via the enumeration of cycles is of exponential 
computational complexity. In other words, it is not applicable to large-size marked 
graphs. Fortunately, the minimum cycle times can be obtained, e.g., by linear 
programming (Morioka and Yamada 1991; Campos et al. 1992; Zhou and 
Venkatesh 1998).  
The described analysis method via the cycle enumeration is illustrated in the 
following example. 
Example 10.1. The Petri net in Figure 10.1 is a model of a manufacturing system 
where 
1p  stands for the processed part availability (if marked with a token), 
4
3
2
,
,
p
p
p
 stand for manufacturing process on the machines A, B, C, respectively, 
and 
5
p  for availability of machine A. Maximum two parts can be prepared for 
processing at the input. Time delays associated with places and transitions are 
introduced in the Petri net. A part from input is deposited with delay 
3
1 =
τ
 in the 
working range of machines A and C. When A completes its job, the processing 
continues in machine B, which starts its required operation. When machines B and 
C complete their operations, the product is transferred to the output and the next 
part is deposited to the input. The delays connected with the places mean the 
lengths of operations and are denoted as 
iδ . Simple cycles and delays are in Table 
10.1. The resulting minimum cycle time is 13 time units. The manufacturing 
process can start again not earlier than after 13 time units. The bottleneck takes 
place at cycle  p1t1 p2 t2 p3 t3 p1. 

180 Modeling and Control of Discrete-event Dynamic Systems 
 
p1
p2
p3
p4
p5
t1 
t2
t3 
p5
2
1 =
δ
6
2 =
δ
9
3 =
δ
7
4 =
δ
0
5 =
δ
3
1 =
τ
 
2
2 =
τ
4
3 =
τ
 
Figure 10.1. Timed marked graph with time delays 
Table 10.1. Time delays of simple cycles in the Petri net of Figure 10.1 
Simple cycle 
Total time delay 
Token sum 
Cycle time 
p1t1 p2 t2 p3 t3 p1 
26 
2 
13 
p1 t1 p4 t3 p1 
16 
2 
8 
p5 t1 p2 t2 p5 
11 
1 
11 
The timed marked graphs can be developed as a powerful tool for bottleneck 
analysis and thus help identify where one should invest and where one should not. 
For the above example, adding another machine of type A, i.e., p5 receiving one 
more token, contributes none to the cycle time reduction. On the other hand, 
doubling Machine A’s processing speed, i.e., reducing p2’s delay to 3, can reduce 
the system cycle time from 13 to 11.5 time units.  
10.3  Stochastic Timed Petri Nets 
In stochastic timed Petri nets, firing rates and time delays associated with Petri net 
transitions are assumed to be random variables. In this section, we are restricted to 
the cases when the stochastic time variables are associated with transitions only 
and exponentially distributed. Such models are termed stochastic Petri nets, SPN 
for short. Primarily, firing rates associated with transitions are considered. They 
determine firing repetitions when firing conditions are permanently fulfilled. The 
reciprocals of average firing rates are average time delays and vice versa. 
Stochastic timed Petri net models are related to the models based on the Markov 
chains (Zhou and Zurawski 1995; Bause and Kritzinger 1996). A thorough 
treatment of this topic can also be found in (Ajmone Marsan et al. 1995) and 

 
Timed and High-level Petri Nets 181 
(Wang 1998). Basic properties and application of the stochastic timed Petri nets are 
illustrated through an example. 
There are a number of extensions to the above discussed stochastic Petri nets. If 
some transitions can fire much faster than others, their firing rate can be viewed as 
an infinite value. In other words, firing them takes nearly zero time. Such 
transitions are called immediate transitions. They always fire before any timed 
transitions if enabled at the same time. The resulting model is called Generalized 
Stochastic Petri Nets, GSPN for short (Ajmone Marsan et al. 1995). It is proved 
that both SPN and GSPN can be converted into their equivalent Markov chain 
models. Hence, the technique used to solve Markov chain models can be utilized to 
solve both models. Under certain conditions, some transitions are allowed to have 
deterministic time delay, resulting in Deterministic Stochastic Petri Nets (DSPN). 
They can assume to have arbitrary distributed time delay and lead to Extended 
Stochastic Petri Nets (ESPN). Both DSPN and ESPN can be converted into their 
equivalent semi-Markov chains for their solutions. When a transition is associated 
with a delay of arbitrary distribution, the resulting timed Petri nets cannot be 
analytically analyzed in general. The in-depth treatment of the topic can be found 
in (Wang 1998). The following is an exhibit of solving a stochastic Petri net via an 
example. 
 
Example 10.2. Consider a manufacturing layout, which is modeled with a Petri net 
(Figure 10.2). Marked place 
1p  represents a work-piece available at the input; 
2
p , 
and 
4
p
 represent operations executed during processing a work-piece with 
machines A and B, respectively. When both operations are finished (a token is both 
in 
3
p  and 
5
p ) the processed workpiece is unloaded and a new part is deposited in 
the input. Places 
7
6
p
p −
 represent states when A or B is in repair. 
 
7
λ
6
λ
5
λ
1
λ
p1
p2
p3
p4
p5
t1 
t2
t3 
2
λ
3
λ
t4
t5 
4
λ
p6 
p7
t6 
t7
t8
8
λ
 
Figure 10.2. Stochastic timed Petri net with firing rates 

182 Modeling and Control of Discrete-event Dynamic Systems 
Average firing rates 
iλ  are associated with transitions. Reciprocals of the rates 
are the average times of the respective operations. For example, when a token 
arrives in place 
2
p , transition 
2t  starts firing, which takes a delay comprising 
operation at machine A and unloading the workpiece from the machine when the 
operation is finished. The time is a random variable with an average equal to 
2
/
1 λ . 
For other transitions, the situation is similar. Table 10.2 describes the transition 
meanings. 
Table 10.2. Meaning of transitions in the Petri net of Figure 10.2 
Transition 
Meaning 
t1 
Loading work-piece from input into the processing range of machines 
A and B 
t2 
Processing a work-piece by machine A and unloading  
t3 
When both operations are finished, removing the processed work-
piece and loading a new work-piece at the input 
t4 
Processing of a work-piece by machine B and unloading  
t5 
Machine A breaks down 
t6 
Machine A is being repaired 
t7 
Machine B breaks down 
t8 
Machine B is being repaired 
Table 10.3. Firing rates in the example 
Transition 
Firing rate 
t1 
20
1 =
λ
 
t2 
4
2 =
λ
 
t3 
15
3 =
λ
 
t4 
2
4 =
λ
 
t5 
2
5 =
λ
 
t6 
1
6 =
λ
 
t7 
2
7 =
λ
 
t8 
2
8 =
λ
 

 
Timed and High-level Petri Nets 183 
By comparing the net in Figure 10.2 with the one in Figure 10.1 with respect to 
machine A it is evident that 
6
p  has been added. It represents a state when A is in 
repair after a breakdown. The place is connected to new transitions 5t  and 6t . Each 
transition in the net represents a whole process that takes some randomly 
distributed time, and during it the tokens are blocked in the transition. Table 10.2 
shows that more actions can be covered by one transition.  
The i-th average firing rate associated to 
it  is denoted as 
iλ , the i-th time delay 
is 
iz . Firing rates for our example are given in Table 10.3. When a transition starts 
its firing, tokens from pre-places are taken and when firing ends the tokens are 
deposited in post-places. All weights are equal to one. The firing rules are usual. 
The reachability graph for the Petri net is shown in Figure 10.3. Each arc of the 
graph is labeled as usual with it  leading to the passage from one marking to its 
successor. Each arc is additionally labeled with the average firing rate 
iλ  
associated with the corresponding transition. The markings are the states of the 
system. A Markov chain can be generated for the states. Its topology is the same as 
of the reachability graph. In the Markov chain transit arcs between states are 
equally labeled with the firing rates 
iλ . The transition rate matrix for the Markov 
chain is  
The first row and first column correspond to marking (state) 
0
m , the second ones 
to 
1
m  etc.; 
kλ  is assigned to the matrix entry (
)
j
i
j
i
≠
,
,
, if there is a transit from 
state 
i
m  to 
j
m  via transition kt . For 
j
i =
, the negative sum of firing rates of the 
rest of entries in the i-th row is assigned to the entry (
)i
i,
. The assignment is 
evident from the reachability graph and matrix A. The following matrix equation is 
well known from the theory of Markov chains 
 
(
)
0
.....
8
2
1
0
=
A
π
π
π
π
 
(10.3) 
and, of course, 
 
1
.
..
.
8
2
1
0
=
+
+
+
+
π
π
π
π
 
(10.4) 
1
1
2
4
5
7
2
4
5
7
4
7
4
7
3
3
8
8
2
2
5
5
6
6
6
6
8
8
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
−
⎛
⎞
⎜
⎟
−
−
−
−
⎜
⎟
⎜
⎟
−
−
⎜
⎟
−
⎜
⎟
⎜
⎟
=
−
⎜
⎟
−
−
⎜
⎟
⎜
⎟
−
⎜
⎟
−
⎜
⎟
⎜
⎟
−
⎝
⎠
A

184 Modeling and Control of Discrete-event Dynamic Systems 
(
)
7
7 λ
t
4
m
6
m
2
m
(
)
8
8 λ
t
(
)
5
5 λ
t
(
)
4
4 λ
t
( )
6
6 λ
t
(
)
3
3 λ
t
(
)
2
2 λ
t
(
)
5
5 λ
t
(
)
1
1 λ
t
1 0 0 0 0 0 0
0 1 0 1 0 0 0
0 0 1 1 0 0 0
0 1 0 0 0 0 1
0 0 1 0 1 0 0
0 0 1 0 0 0 1
0 0 0 0 1 1 0
(
)
4
4 λ
t
0
m
1
m
3
m
8
m
5
m
0 1 0 0 1 0 0
7
m
0 0 0 1 0 1 0
(
)
2
2 λ
t
(
)
7
7 λ
t
( )
6
6 λ
t
(
)
8
8 λ
t
 
Figure 10.3. Reachability graph for Petri net in Figure 10.2 
where 
i
π  is a probability that the system is in a state represented by a marking 
i
m . 
To explain  Equation (10.3), consider, e.g., the first column of matrix A: entries for 
8
1
m
m −
 correspond to transits from them to 
0
m ; the entry for 
0
m  in this row 
according to the construction of A corresponds to all transits from 
0
m  to other 
markings. The sum of products of probabilities and firing rates for passes into the 
state 
0
m  should be balanced with the same sum for the passes out of 
0
m .  
The solution to Equations (10.3) and (10.4) with the firing rates in Table 10.3 
provides probabilities given in Table 10.4. 
Table 10.4. Calculated probabilities for Example 10.2 
0
π  
1
π  
2
π  
3
π  
4
π  
5
π  
6
π  
7
π  
8
π  
0.029 
0.098 
0.196 
0.039
0.196
0.050
0.098
0.196
0.098 
Various performance characteristics can be calculated from the model, e.g., 
exploitation of machine A is 24.6% as follows from 
 
246
.0
8
5
1
=
+
+
π
π
π
 
(10.5) 
The system throughput given as a rate can be calculated as follows: 
 
585
.0
3
3
=
λ
π
 
(10.6) 

 
Timed and High-level Petri Nets 185 
which corresponds to 
 
units
 
  time
71
.1
1
3
3
=
λ
π
 
(10.7) 
A breakdown of the machine B is characterized by probability  
 
294
.0
8
4
=
+π
π
  
(10.8) 
or 29.4% of the production execution time. 
10.4  Colored Petri Nets 
If the relations between the system states given by markings are complex and/or 
the system consists of many identical subsystems, then the Petri nets in the 
standard form become very complicated and difficult to read. Each subsystem 
requires its own Petri net subset. The colored Petri nets (CP-nets) were introduced 
by Jensen (1981) in order to solve the problem of the Petri net invariants for the so-
called high-level Petri nets presented by Genrich and Lautenbach (1981). Jensen’s 
improved version of the high level Petri nets was later developed into a nice tool-
CPN (Jensen 1997).  
The basic idea is that in colored Petri net tokens have their own individuality or 
identity represented by data values of some prescribed type called colors. Logic 
expressions and functions can be built up using the token colors and can be 
associated with places, transitions and arcs of a CP-net. 
An exact description of colors has to be attached to each colored Petri net. 
Nowadays, colored Petri net designers often use a language called CPN ML for the 
CP-net design. CPN ML is closely related to the constructions and declarations 
used in ordinary high level programming languages. In what follows we give a 
basic introduction to CP-nets using the following example. In its development we 
rely on reader’s intuition bearing in mind that the notation of CPN ML is familiar. 
Example 10.3. Consider a system with two processes sharing two different kinds of 
resources. There are one resource of type R and three resources of kind S available. 
These may be for instance a robot and machines in a manufacturing line, 
concurrently manufacturing two kinds of products. The process p (manufacturing 
of a product of type p) needs two machines of type S to be assigned in a certain 
time. The process q needs, besides two machines S, also robot R for its finishing. 
Both processes are running cyclically. A model of the system represented by a P/T 
Petri net is shown in Figure 10.4. 
Each process is represented by one “subnet”, the subnets are mutually 
interconnected through places R and S representing the shared resources. A 
standard Petri net representation of this kind of system would be very complicated 
due to a higher number of processes and resources. In this situation modeling by a 
colored Petri net is very helpful (Figure 10.5).   

186 Modeling and Control of Discrete-event Dynamic Systems 
 
Process q 
        T1q 
            T2q 
             T3q 
       T2p 
         T3p 
Process p 
Bp
Cp
Cq 
Bq 
Aq 
S 
R 
2 
2 
2 
 
Figure 10.4. A system with two processes modeled by a P/T Petri net 
 
 
1`(p,0) 
 e 
1`e 
3`e 
E 
E 
 T3 
T1 
T2 
[x=q] 
1`(q,0) 
1`(p,0)
if x=q 
then 1`(q,i+1) 
if x=p 
then 1`(p,i+1) 
1`(q,0) 
case x of 
p=>2`e 
if x=q then 1`e 
color U = with p | q; 
color I = int; 
color P = product U * I; 
color E = with e; 
U
R 
2`e 
1
1 
3 
 S 
P 
A 
(x,i)
(x,i)
(x,i)
(x,i)
P 
B 
(x,i)
P 
C 
 e 
1`e 
3`e 
1 
 
Figure 10.5. A system with two processes modeled by a colored Petri net 
By inspecting the two figures, it is clear that colored Petri net notation is 
slightly different compared with the standard P/T Petri net conventions. A colored 
net consists of three parts: a net structure (places, transitions and arcs), 

 
Timed and High-level Petri Nets 187 
declarations (listed in a frame in the left upper corner) and net inscriptions 
connected with the net elements. A fundamental difference with respect to P/T 
Petri nets lies in the token color. Each token is assigned its own color as some 
value of certain data type. This data type can also be complex, e.g., a structure or a 
record, where for instance the first item is a real number, the second is a text string 
and the third could be a record of integer pairs. In this example we have used 
tokens of two color types (Figure 10.5, in a frame): P and E, where color P is a 
Cartesian product of colors U and I. Color U contains a binary value of two options: 
p and q, corresponding to the type of the process. Color I is introduced in addition 
to the standard P/T net representation and contains an integer value, which counts 
the total number of finished cycles for each process. By introducing a color I, it is 
demonstrated how it is possible to extend simply modeling convenience of the 
standard P/T nets using the token colors. Now, color P contains information about 
the process and also about the number of finished products – outcomes of the 
process. Color E contains just information about the type of the shared resource. 
Hence, there are two different kinds of tokens in the net, but in each place only 
tokens of one certain type is possible in this example. 
A possible color, called color set, is expressed by inscription in italic associated 
with each place. Thus places R and S can contain tokens of color E and places A, B, 
and C tokens of color P. A careful reader has surely noted different marking 
inscriptions. The names of places are written inside the places instead of tokens. 
Because of the need to know both the number of tokens and their color, the 
marking is written near the places in such a manner that the total number of tokens 
in the respective place is written as a number in a small ring followed by a multi-
set inscription representing color and number of tokens. For example, next to place 
A there is a marking  
1`(q,0)
1 
, which means that in the place, there is one token 
in total, namely one token with color (q,0) (q is the process type and 0 means the 
number of finished products of type q). By convention, we omit the marking of 
places with no token. The initial marking is represented by underlined expressions 
placed next to the respective places. The system in Figure 10.5 is in the initial state. 
Hence, the actual marking is equal to the initial one. 
Assigning a color to each token and a color set to each place allows one to use a 
smaller number of places than in standard P/T nets. In this example, places Bp, Bq 
and Cp, Cq have been joined. Using colors we do not lose the possibility to 
distinguish the process types. This possibility brings about an important benefit in 
more complicated systems. However, by introducing colors the Petri net dynamics 
becomes more complex. It is necessary to introduce more complex expressions 
associated with arcs to describe fine possibilities of the marking evolution. 
Therefore arcs contain expressions whose results are elements of multi-sets, 
namely colored tokens. Sometimes such an arc can “transmit” a token without any 
change, e.g., the arc connecting A and T1, where arc (x,i) moves the token from 
place A via transition T1 into place B without change. We can use an abbreviation. 
Instead of 1’e it is sufficient to write the symbol e as, e.g., for the arc connecting R 
and T1. A transition is enabled/fireable iff all its pre-places contain tokens with 
proper colors as specified by its input arcs. There is a more complex arc inscription: 
“if x=p then 1`(p,i+1) else empty” at the arc leading from T3 to B. The token 
passes this arc only if it is the token concerning process p. This arc also increases 

188 Modeling and Control of Discrete-event Dynamic Systems 
the number of finished products of type p. There is a similar inscription at arc 
connecting S and T2: “case x of p=>2`e |q=>1`e”. In case when the value of color x 
of the token passing transition T2 is p, two tokens of type e are withdrawn from 
place S (if available). If it is a token of color q, only one token is withdrawn 
(according to the structure in Figure 10.4). A condition [x=q] at transition T1 
means that there is a part of the net concerning only process q and that no token of 
the type p may pass this transition (such a kind of token is not possible here 
because of the net structure, initial marking and arc expressions). When a transition 
fires, tokens with colors specified by its output arcs are deposited to its post-places. 
It is further possible to develop and adapt the described CP-net, e.g., by joining 
places concerning the shared resources into one place and adding the necessary arc 
inscriptions, etc. However, such subsequent adaptations could reduce the 
transparency or readability of the net. 
Example 10.4. Consider an automatic guided vehicle system depicted in Figure 
10.6. The system consists of fixed tracks divided into sections. This is a long 
practice to ensure transportation safety. A collision-free function is achieved by the 
condition that only one vehicle can be in a section. The vehicles move through the 
sections in both directions. The switches are routing vehicles according to the 
chosen vehicle path. A normal stop is not allowed in the switch area except 
between switches SW2 and SW1, and between SW7 and SW8. There a vehicle can 
stop and change its direction, if necessary. Sensors detect the presence of a vehicle 
in a section. There are no sensors in the switch sections, with the exceptions 
mentioned above. Processing centers are situated along some sections.  
A control system provides a collision-free guidance of the vehicles to fulfil 
their transportation tasks. The route optimization problem has not been considered 
here. We have adopted an acceptable solution to determine for each vehicle’s 
section position, possible continuations to the goal section avoiding collisions (see 
more in Hrúz et al. 2002).  
 
S10 
S1 
S2 
S3 
S5 
S4 
S12 
S11 
S6 
S7 
S8 
S9 
SW1 
SW2 
SW3 
SW4 
SW5 
SW6 
SW7 
SW8 
SW9 
 
Figure 10.6. AGV system with fixed tracks 

 
Timed and High-level Petri Nets 189 
An ordinary Petri net modeling the transportation system is given in Figure 
10.7. There are three subnets in it corresponding to three vehicles moving in the 
system. An identical subnet has been added for each further vehicle. Places p14 
and p13 correspond to the special switch sections SW1–SW2 and SW7–SW8. 
Other switch sections are not represented by places. A vehicle presence is modeled 
by a deposit of a token in the place of a corresponding subnet. Analyze the 
movement control of the 1st vehicle. According to its task we have the following: 
for a transit from sections 
iS  to 
j
S , a command is released for its motion to the 
next chosen section that has no other vehicle. It is clear that many vehicles will 
make the ordinary Petri net very complicated and cumbersome to model and solve 
the transportation control problem. 
  
Figure 10.7. Petri net for the transportation system 

190 Modeling and Control of Discrete-event Dynamic Systems 
pS8 
pS7 
pS9 
pS4 
pS6 
1’(1,3,9,8,2,0) 
1
p
f8sw 
pSW 
fsw8‘ 
f8sw‘ 
fsw6 
fsw8 
fsw6‘ 
f6sw 
f6sw‘ 
C
C
C
C 
C 
C 
 
Figure 10.8. A part of CP-net 
Table 10.5. Definitions of token colors 
 
An efficient way to solve the problem is to use CP-nets. For the illustration 
consider a situation around switches SW6–SW8 with help of a colored Petri net, 
which would be a part of the complete CP-net. 
The net with the colors and their description is shown in Figure 10.8. The 
switch section is represented by pSW and the surrounding sections by pSi. The color 
inscriptions are in Table 10.5. 
The token color contains more additional information according to the needs of 
the control system, e.g., starting section of the transfer, final section of the transfer, 
job number assigned to a vehicle and its priority. We also add a value for “partial 
destination” – the next section, through which an AGV should move to execute the 
actual transfer. 
At the start of the transfer as well as in each section crossed by the AGV, the 
partial destination is computed from the reachability graph to select the optimal 
path direction of the movement (with respect to path length or transfer time). All 
places in the net can contain a token of color type C, which is the Cartesian product 
of all needed value elements. For safety we assume the capacity of all places to be 
1. In terms of CP-nets we do not indicate current marking by dots put in places; 
instead, a token is represented by a small circle next to the place showing overall 
count of tokens in this place followed by the text representation of particular values 
as shown with place pS8. 
color Id = int; (* AGV id – number *) 
color Start = int; (* starting section of transfer *) 
color Dest = int; (* final section of transfer *) 
color Pd = int; (* partial destination *) 
color Job = int; (* assigned job *) 
color Prio = int; (* priority of the job (vehicle)*) 
color C = product Id*Start*Dest*Pd*Job*Prio; 

 
Timed and High-level Petri Nets 191 
Table 10.6. Arc expressions 
 
The main functionality of this CP-net is realized by arc expressions represented 
by functions fij. By means of fij the next section is computed, to which the vehicle 
will be directed and the movement is realized by setting appropriate external 
signals. 
A simplified example of arc expressions for Section 8 is shown in Table 10.6, 
and expressions for other arcs are generated similarly (not shown in Figure 10.8.).  
When the net is externally synchronized with the process, we obtain a control 
algorithm represented by the CP-net. It is easy to see that the movements of all 
vehicles can be represented in one net. It is not necessary to have a separate subnet 
for each vehicle. The inscriptions of colors are easy to to understand: „int“ means 
values of the type integer; “Id” is a color identifying a vehicle, with three vehicles 
having the colors 1, 2, and 3. Similarly, it is with starting and goal section of 
a transfer job; “Pd” is a color for the partial destination calculated by an 
optimization program. The calculation considers possible partial destinations and 
tries to find the best way respecting the occupation of the continuation places. 
Further, there are colors “Job” and “Prio”. The tokens in the CP-net (three in the 
example) are given colors according to the product Id*Start*Dest*Pd*Job*Prio. 
The arc expression constructs are self-explanatory. An idea is that the expressions 
set the condition of the arc to the token color if the achievable partial destination is 
in the vicinity. 
To model a smart card associated with a batch of parts/materials to be 
processed and meet the need to analyze and control deadlocks in automated 
production, a token’s colors are introduced into Petri nets, which are different from 
the above introduced in (Wu 1999 and Wu and Zhou 2001, 2004, 2005, 2007). 
They represent the output transitions of a place, which a token in the place intends 
to enable following the determined part routes. The resulting models are called 
colored resource-oriented Petri nets. They has been applied to DEDS in flexible 
manufacturing and assembly, Automated Guided Vehicle (AGV) systems, track 
systems and cluster tools in semincoductor fabrication, and oil-refinary scheduling 
problems. The work has great significance in simplifying the deadlock modeling, 
analysis and control complexity. It can also facilitate the scheduling and help 
derive optimal schedules. 
f8sw : 
(* call next section planning algorithm and set pd *) 
f8sw’ : 
if (pd in {4,6,7,9} then 1’(Id,Start,Dest,Pd,Job,Prio); 
fsw8 : 
1’(Id,Start,Dest,Pd,Job,Prio); 
fsw8’ : 
if (pd=8) then 1’(Id,Start,Dest,8,Job,Prio); 

192 Modeling and Control of Discrete-event Dynamic Systems 
10.5  Fuzzy Petri Nets 
The fuzziness concept can be incorporated in Petri nets. Some additional aspects 
should be supplemented for that purpose. Fuzzy Petri nets are useful as models for 
expert rule-based decisions, temporal reasoning and many others. A rich collection 
of contributions to various aspects of the fuzziness used with Petri nets can be 
found in Cardoso and Camargo (1999).  
In this section we have chosen from many possibilities a kind of fuzzy Petri 
nets adapted for the temporal problem solutions. First of all, let us introduce a few 
notions from the fuzzy set theory. 
Definition 10.2. A fuzzy set A in a universe of discourse U, written A in U, is 
defined by a set of pairs 
 
( )
(
)
{
}
x
x
A
A
,
μ
=
 
(10.9) 
where 
[
]1,0
:
→
U
A
μ
  (a real number interval) is a membership function, which 
represents the element’s 
U
x ∈
 degree of membership (by mapping U into interval 
[0,1]) of the fuzzy set A.  
The notion of a fuzzy number is further necessary for data operations in fuzzy 
Petri nets. If a fuzzy set in the domain U consisting of real numbers is  
a) normal, 
( )
1
max
=
∈
x
i.e.,
A
U
x
μ
 and  
b) convex, 
2
1
2
1
,
,
,
x
x
x
U
x
x
x
i.e., 
<
<
∈
∀
,    
( )
( )
(
)
(
)
2
1 ,
min
x
x
x
A
A
A
μ
μ
μ
≥
  
then it is a fuzzy number. Binary fuzzy operations are defined for fuzzy numbers 
(recall that a binary operation on a set M is a mapping 
M
M
M
→
×
); they are 
similar to ordinary binary operations on the real number domain. Fuzzy number 
operations 
( )
()
min
,
max
,:
,
,
,
⊗
−
⊕
 can be defined similarly as ordinary arithmetic 
operations 
min
max,
:,
,
,
, ×
−
+
. For example, fuzzy operation ⊕ for fuzzy numbers 
A, and B is defined by 
 
( )
( )
( )
(
)
[
]
y
x
z
B
A
y
x
z
B
A
μ
μ
μ
,
min
sup
+
=
⊕
=
, 
U
z
y
x
∈
,
,
 
(10.10) 
The resulting fuzzy number 
B
A
Z
⊕
=
 is given by the membership function 
( )z
B
A⊕
μ
. Consider its value for one particular z. It is calculated as a supremum of 
all pairs of ordinary numbers x and y, which give the value z by taking a minimum 
of the membership functions of x and y; and the supremum of those minimums 
defines the resulting membership value for one value of z. In this way, all points of 
the membership function of Z can be calculated. 
Consider the timed fuzzy Petri nets from (Ribarič and  Bašič 1998). The time 
value is given on a time scale T, which is a linearly ordered set like 
+
R  and 
+
N . 
Following the fuzzy concept there is an uncertainty in determining a time point. 
This uncertain knowledge about the time a (when some event occurs) can be 
expressed by a possibility distribution function 
[
]1,0
:
→
T
a
π
, i.e., 
( ) [
]1,0
∈
t
a
π
 for 

 
Timed and High-level Petri Nets 193 
T
t ∈
∀
. 
a
π
 is a numerical estimate of a possibility that the time point a is 
precisely t, whereby the time as a physical variable varies independently. 
a
π  is 
equivalent to 
( )t
A
μ
 under the assumptions that 
a
π
 is normal and convex, and 
( )t
A
μ
 is normal and convex, too. Then the fuzzy set A is associated with the 
considered fuzzy time point a and A is a fuzzy number determining the time point 
a in a fuzzy way. Denote by
( )
T
D
 the set of all normal and convex possibility 
distributions π  defined on T. 
Now we are ready for the following example taken from Ribarič and  Bašič 
(1998): Fred, John and Mark have a meeting as soon as all arrive at work. Fred 
leaves home about 7:00 in the morning. He goes by car and arrives to work about 
20 minutes later. John comes to work a few min earlier than Fred. Mark leaves the 
house approximately at the same time as Fred. He takes a bus. The bus takes about 
20 min to reach the bus stop nearest to the office. Then it takes him a few minutes 
more to get to the office. The question is: What are possible starting times of the 
meeting?  
We can well present the fuzzy temporal relations by means of a fuzzy Petri net 
in Figure 10.9. Marked places can represent partial states as described in Figure 
10.9. Transitions represent actions described by fuzzy temporal linguistic 
expressions. The places can be marked with fuzzy tokens. Each token has its 
identity given by data values as in colored Petri nets. A possible marking of place 
ip  is one of the following ordered pairs: 
( )
(
)
( )
(
)
( )
( )
(
),
,
,
,
,
,
i
e
i
b
i
e
i
b
π
π
π
π
∅
∅
and (
)
∅
∅,
. 
The last case means that no token is in place 
ip . 
( )i
b
π
 and 
( )i
e
π
 are possibility 
distribution functions. 
( )i
b
π
 stands for the time point of the beginning of a token 
presence in place 
ip , 
( )i
e
π
 is for the end time point. A token is assigned the 
distributions as values on its arrival in a particular place. 
In the treated fuzzy Petri nets, three functions have been used: 
1. Function 
( )
∅
∪
→
T
D
P
:
τ
. Let 
iτ
 be associated with place pi. It 
determines in a fuzzy way the detainment of a token in pi. 
2. Function Θ  related to function τ . When a token arrives in a place 
ip  it is 
assigned value 
( )
(
)
∅
,
i
b
π
. Function Θ  changes according to τ  
( )
(
)
∅
,
i
b
π
 
on 
( )
( )
(
)
i
e
i
b
π
π
,
 where 
( )
( )
i
i
b
i
e
τ
π
π
⊕
=
. 
3. Function λ , which maps the set T of transitions to a set of fuzzy operations 
( )
,
max
,
min
,
,
κ
κ
−
⊕
 etc., where κ  is a fuzzy number. The operations 
are applied to a pair (
)
e
b π
π ,
. Practically, the beginning given by the fuzzy 
number in the post-place 
( )j
b
π
 is obtained by a fuzzy operation, e.g., 
( )
( )
k
i
b
j
b
κ
π
π
⊕
=
 where 
ip  is a pre-place of a transition 
kt . 

194 Modeling and Control of Discrete-event Dynamic Systems 
 
p1
p2
p3 
p4
p5
t1
t2
t3
Fred leaves 
Approximately at  the same 
Mark is in the 
bus 
About 20 minutes 
A few minutes  later 
Fred is coming to work 
A few minutes  earlier 
John is coming to work 
Meeting begins 
p6
As soon as last
t4
t5
 
Figure 10.9. Fuzzy Petri net model of temporal relations 
Table 10.7 lists the results of functions τ  and λ . Fuzzy numbers in Table 10.7 
are represented in the so-called triangular form when the membership function is 
given as a triangle (see Figure 10.10 for 
1
κ ). Using the triangle membership 
function, the statement “about 20 min later” is interpreted according to Figure 
10.10 as “within ± 5 min around 20 min”. 
Starting from the initial marking 
( )
(
)
[
]
T
b
∅
∅
∅
∅
∅
∅
=
,
,
,
,
,
,
1
0
π
m
 and 
performing fuzzy operations by stepwise applying the functions τ  and λ  we 
obtain the final marking  
(
)
6
,
,
,
,
,
m
∅
∅
∅
∅
∅
 
where 
( )
( )
( )
(
)
(
)
∅
=
,
,
,
max
5
4
2
6
b
b
b
m
π
π
π
. Max is a fuzzy operation of maximum as 
illustrated in Figure 10.11. It is the fuzzy expression of the time of the meeting 
beginning by using the membership function or the corresponding fuzzy number. It 
is easy to imagine that similar fuzzy temporal relations can occur in various kinds 
of DEDS. 

 
Timed and High-level Petri Nets 195 
Table 10.7. Description of fuzzy relations 
State, action 
Infliction of τ  and λ  
State: Fred leaves home  
(
)
0
1 =
p
τ
 because it is the start of the 
process 
Action: about 20 min later 
( )
1
1
κ
λ
⊕
=
t
, 
(
)
25
,
20
,
15
1 =
κ
 
State: Fred is coming to work  
(
)
0
2 =
p
τ
because he is ready for the 
meeting immediately after the arrival 
of all others 
Action: approximately at the same time 
( )
(
)
5,0,5
,
2
2
2
−
=
⊕
=
κ
κ
λ t
 
State: Mark is in the bus 
(
) (
)
25
,
20
,
15
3 =
p
τ
, Mark is about 20 
min in bus, therefore 
( )
(
)
25
,
20
,
15
3 =
e
π
 
Action: a few minutes later 
( )
(
)
10
,5,0
,
3
3
3
=
⊕
=
κ
κ
λ t
 
State: Mark is coming to work 
(
)
0
4 =
p
τ
 
Action: a few minutes earlier 
( )
(
)
0,5
,
10
,
4
4
4
−
−
=
⊕
=
κ
κ
λ t
 
State: John is coming to work 
(
)
0
5 =
p
τ
 
Action: as soon as last 
( ) (
)
∅
=
,
max
5t
λ
 
Membership Function 
1 
15 
20 
25 
 
Figure 10.10.  Membership function of a fuzzy number 
 

196 Modeling and Control of Discrete-event Dynamic Systems 
 
6.55 
7.00 
7.05 
7.10
7.15
7.20
7.25
7.30
7.35
7.40
7.45 
7.50 
1 
 
Figure 10.11. Resulting fuzzy expressed time of the meeting beginning expressed by the 
membership function 
10.6 Adaptive Petri Nets 
Incorporating learning capability into a Petri net framework leads to adaptive Petri 
nets. Broadly speaking, intelligent techniques such as artificial neural network, 
fuzzy logic and knowledge based systems together can bring adaptable feature to 
Petri nets. Consequently, adaptive Petri nets can become a framework for dynamic 
knowledge inference under changing environments (Asar et al. 2005). The basic 
conditions need to be defined under which a Petri net can be modeled to qualify for 
adaptive task similar to biological neural network. The related approaches have 
borrowed the concepts from the work based purely on biological brain model. Thus 
the developed models can mimic a biological brain in terms of its distributed 
function feature. Some work involves synergy of Petri nets and intelligent 
techniques where ideas are motivated from the concepts of fuzzy logic and neural 
networks through the weights and learning features. A small percentage of 
researchers are active in applying intelligent techniques in conjunction with the 
Petri net methodology on real world problems. This section intends to focus on 
presenting the concept and examples of adaptive Petri nets based on the work (Li et 
al. 2000; Yeung and Tsang 1998; and Gao et al. 2003) for the purpose of dynamic 
knowledge inference. 
In many situations, it is difficult to capture data in a precise form. In order to 
represent certain knowledge, fuzzy production rules are used for knowledge 
representation (Chen et al. 1990, Gao et al. 2003). A fuzzy production rule is a rule 
which describes the fuzzy relation between two propositions. Its antecedent portion 
may contain ''AND'' or ''OR'' connectors. If the relative degree of importance of 
each proposition in the antecedent contributing to the consequent is considered, a 
Weighted Fuzzy Production Rule is needed (Yeung and Tsang 1998). For example, 
R1: IF it is dark (p1) and Vision Processing System (VPS) works well 
(p2) THEN the data from VPS is not dependable (p3) with certainty 
factor μ1=0.9, threshold λ1=0.5, and weights w1=0.6 and w2=0.4. 
 

 
Timed and High-level Petri Nets 197 
 
Figure 10.12. The Petri net representation of a weighted fuzzy production rule 
This rule means that  
1. p1 and p2 are two antecedent propositions and p3 a consequent one (may 
become an antecedent proposition of other rules). 
2. This rule’s certainty factor is 0.9. 
3. If the sum of p1 and p2’s truth degrees (not given) weighted by their 
weights w1=0.6 and w2=0.4 exceeds the firing threshold value λ1=0.5, this 
rule is executable. 
4. p1 and p2’s weights are 0.6 and 0.4-implying that p1 is more important than 
p2. Their sum should be one given a conjunctive rule.  
The importance weight should be one by default for the cases of a single 
antecedent proposition, or multiple propositions connected with OR. Please note 
that in (Yeung and Tsang 1998), the threshold value is defined for each proposition 
and then an exactly same or close statement is as an input to the rule’s antecedent 
propositions. The similarity value between an input proposition and that in a rule 
has to be computed. The rule can be executed only if it exceeds the threshold for 
each proposition. 
This example rule can be easily converted to a Petri net as shown in Figure 
10.12 where each place represents a proposition and transition t1 represents rule R1. 
Suppose that p1 and p2’s truth degrees are given as θ1=0.4 and θ2=0.5. Since 
y=w1θ1+w2θ2=0.24+0.2=0.44<λ1=0.5, this rule cannot be executed. However, if θ1 
increases to 0.6, y=0.36+0.2=0.56>λ1=0.5. Hence, this rule can generate the results. 
If p3 has no other input transitions, its truth degree is: θ3=yμ1=0.56×0.9=0.504. 
In addition, different from the other “non-reasoning” Petri nets, θ1=0.4 and 
θ2=0.5 remain unchanged at p1 and p2 unless new updates arrive. Note that some 
previous work removes them as they are treated as tokens (Li et al. 2000). When p 
has multiple input transitions fired, e.g., t1-k with yj as the weighted truth degrees 
and μj as the certainty factor of tj, j=1, 2, .., k, p’s truth degree is derived as the 
center of gravity of these fired transitions, i.e., 
 

198 Modeling and Control of Discrete-event Dynamic Systems 
 
j
j
j
j
j y
p
μ
μ
θ
∑
∑
=
)
(
 
With the above background of fuzzy reasoning Petri nets, we can now 
introduce an adaptive Petri net concept as follows. 
Definition 10.3. An adaptive Petri net is a 9-tuple 
 
)
,
,
,
,
,
,
,
(
μ
λ
θ W
O
I
T
P
APN =
 
where P, T, I, and O defines APN structure, or more specifically  
1. 
}
,
,
,
{
2
1
n
p
p
p
P
⋅⋅⋅
=
 is a finite set of propositions or called places. 
2. 
}
,
,
,
{
2
1
mt
t
t
T
⋅⋅⋅
=
 is a finite set of rules or called transitions. 
3. I: P×T→{0,1}, is an n×m input matrix defining the directed arcs from 
propositions to rules. I(
ip ,
jt ) =1, if there is a directed arc from 
ip  to 
jt ; 
and I(
ip ,
jt )=0，if there is no directed arcs from 
ip  to 
jt , for i=1,2,...,n, 
and j=1,2,...,m. 
4. O: P×T→{0,1}, is an n×m output matrix defining the directed arcs from 
rules to propositions. O(
ip ,
jt ) =1, if there is a directed arc from 
jt  to 
ip ; 
O(
ip ,
jt ) =0, if there is no directed arcs from 
jt  to 
ip  for i=1,2,...,n, and 
j=1,2,...,m. 
5. 
]1,0
[
:
→
T
θ
 is a truth degree vector. θ =(
T
n )
,
,
2
1
θ
θ
θ
⋅⋅
⋅
, where 
iθ ∈ [0,1] 
means the truth degree of 
ip , i = 1, 2, ..., n. The initial truth degree vector 
is denoted by 
0
θ . It is treated as a marking (no longer integer but any real 
number between 0 and 1). 
6. 
]1,0
[
:
→
×T
P
W
 is the weight function that associates a weight with an 
input arc from a place to a transition. If a transition t has multiple input 
places, the sum of all the weights from these places to t must equal one. If t 
has a single input place p, then W(p,t)=1. 
7. 
]1,0
[
:
→
T
λ
 is the function that assigns a threshold value to .
it
  
8. 
]1,0
[
:
→
T
μ
 is the function that assigns a certainty factor value to .
it
 
Assume that the weights need to be learned given the input and output date of 
place truth degrees. To do so, we need to define the execution rule first. 
Definition 10.4. Given APN, 
T
t ∈
∀
, t  is enabled if 
t
p
•
∈
∀
, 
0
)
(
>
p
θ
. Firing an 
enabled t produces the new truth degree for its output place(s), denoted by y(t): 

 
Timed and High-level Petri Nets 199 
 
⎪⎩
⎪⎨
⎧
<
⋅
∑
>
⋅
∑
⋅
∑
=
)
(
)
,
(
)
(
,0
)
(
)
,
(
)
(
,
)
,
(
)
(
)
(
t
t
p
W
p
t
t
p
W
p
t
p
W
p
t
y
j
j
j
j
j
j
j
j
j
λ
θ
λ
θ
θ
 
(10.11) 
1. If p has no input transition, its truth degree must be given initially. 
2. If p has only one input transition t, 
)
(
)
(
)
(
t
t
y
p
μ
θ
=
.  
3. If p has multiple fired input transitions, t1-k with yj as the weighted truth 
degrees and μj as the certainty factor of tj, j=1, 2, .., k, p’s truth degree is 
derived as the center of gravity of the fired transitions, i.e.,  
 
j
j
j
j
j y
p
μ
μ
θ
∑
∑
=
)
(
 
According to the above definitions, a transition t is enabled if all its input places 
have their truth degrees positive. If the sum of their weighted truth degrees is 
greater than its threshold λ(t), t fires. Thus, through firing transitions, truth degrees 
can be reasoned from a set of known antecedent propositions to a set of consequent 
propositions step by step. We may use a continuous function 
)
,
( x
t
y
 to 
approximate 
)
(t
y
 in Equation (10.11). Let 
 
)
(
)
,
(
x
F
x
x
t
y
⋅
=
 
where  
 
)
,
(
)
(
t
p
W
p
x
j
j
j
⋅
= ∑θ
 
)
(x
F
 is a sigmoid function that approximates the threshold of ,t   
 
(
)
))
(
(
1
/
1
)
(
t
x
b
e
x
F
λ
−
−
+
=
 
where b  is a large constant called steepness. If b  is large enough, when 
),
(t
x
λ
>
 
0
))
(
(
≈
−
−
t
x
b
e
λ
 , then 
,1
)
(
≈
x
F
 and when 
),
(t
x
λ
<
 
∞
→
−
−
))
(
(
t
x
b
e
λ
 , then 
.0
)
(
≈
x
F
 This approximation is essential to equip the net with learning capability 
to be shown later. 
Algorithm 10.1. (Fuzzy Reasoning) 
INPUT: APN with initial truth degrees of a set of antecedent propositions, i.e., 
0
θ
. 
OUTPUT: The truth degrees of consequence propositions 
Initialization: k = 0. 

200 Modeling and Control of Discrete-event Dynamic Systems 
Step 1. Let k = k+1. Find and fire all enabled transitions and update truth 
degree of places according to Definition 10.4 to obtain 
k
θ . 
Step 2. If 
1
−
≠
k
k
θ
θ
, go to Step 1. 
Theorem 10.1. If an APN is acyclic, i.e., it contains no cycles, then Algorithm 
10.1 terminates in a finite number of steps. 
Proof. It is clear that when input places to a transition have the same truth degrees, 
the result from firing it changes no truth degrees. As the net is acyclic, only limited 
number of steps will be needed such that all places will end up with their constant 
truth degrees. 
Example 10.5. Suppose that an expert system has the following weighted fuzzy 
production rules: 
R1: IF p1 THEN p4 with certainty factor μ1 and threshold λ1. 
R2: IF p2 AND  p4 THEN p5 with certainty factor μ2, threshold λ2, and 
weights w1 (input arc from p2 to t2) and w2 (input from p4 to t2). 
R3: IF p3 OR  p5 THEN p6 with certainty factors μ3 for t3 between p3 
and p6, μ4 for t4 between p5 and p6, and thresholds λ3 and λ4. 
The system is converted into Figure 10.13 where R1 and R2 are clear while R3 is 
converted into a subnet with two transitions t3 and t4. 
 
Figure 10.13. APN of a given expert system 

 
Timed and High-level Petri Nets 201 
Suppose that the data are given as follows: 
 
37
.0
,
63
.0
40
.0
,
60
.0
,
55
.0
,
50
.0
82
.0
,
75
.0
,
85
.0
,
80
.0
2
1
4
3
2
1
4
3
2
1
=
=
=
=
=
=
=
=
=
=
w
w
λ
λ
λ
λ
μ
μ
μ
μ
 
We use the following sigmoid functions as 
 
4
,3
,2
,1
  
,
1
:
)
(
)
(
=
+
=
−
−
i
e
x
F
i
i x
b
i
i
λ
μ
 
to approximate the four thresholds 
4
1−
λ
 where steepness 
ib  is selected as b= 200 . 
These functions vs x are drawn in Figure 10.14. For transition t2 , y(t2,x)= xF2(x) 
where 
2
4
1
2
)
(
)
(
w
p
w
p
x
θ
θ
+
=
. 
-0.2
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
3
4
1
2
 
Figure 10.14. Four sigmoid functions in Example 10.5 
Table 10.8 gives the reasoning results of APN given the above data, and truth 
degrees of places p1-3. Each process involves only two steps. If multiple transition 
fires, they can fire together following Definition 10.4. This is one major difference 
between standard Petri nets and “Petri nets for reasoning”. 
One can see that some truth degrees of places are zero. This means that the 
corresponding thresholds are not passed. For example, in Group 1, since 
θ(p1)=0.219<
1
λ =0.5, 1t  cannot fire, leading to θ(p4)=0.  
In Example 10.5, we assume that weights are known. Suppose that weights are 
unknown but we have sufficient data obtained from the expert system. We can then 
introduce the neural network concept and related back-propagation algorithm to 
learn these weights. These weights can be updated when new data are introduced. 

202 Modeling and Control of Discrete-event Dynamic Systems 
Table 10.8. APN Reasoning results given the weights, threshold, certainty factor, steepness, 
and truth degrees θ(p1)–θ(p3) 
Group No. 
Θ(p1) 
Θ(p2) 
Θ(p3) 
Θ(p4) 
Θ(p5) 
Θ(p6) 
1 
0.2190 
0.0470 
0.6789 
0 
0 
0.3243 
2 
0.6793 
0.9347 
0.3835 
0.5434 
0.5850 
0.3055 
3 
0.5194 
0.8310 
0.0346 
0.4072 
0.4517 
0.2359 
4 
0.0535 
0.5297 
0.6711 
0 
0 
0.3206 
5 
0.0077 
0.3834 
0.0668 
0 
0 
0 
6 
0.4175 
0.6868 
0.5890 
0 
0 
0.0279 
7 
0.9304 
0.8462 
0.5269 
0.7443 
0.6647 
0.3472 
8 
0.0920 
0.6539 
0.4160 
0 
0 
0 
9 
0.7012 
0.9103 
0.7622 
0.5610 
0.5867 
0.6705 
10 
0.2625 
0.0475 
0.7361 
0 
0 
0.3516 
Example 10.6. (continued from Example 10.5) The learning part of the APN (see 
the part in the dashed box in Figure 10.13) may be formed as a standard single-
layer neural network as shown in Figure 10.15. Assume the ideal weights are 
 
,
63
.0
1 =
w
 and 
37
.0
2 =
w
. 
The sigmoid function for transition t2 is  
 
)
55
.0
(
200
2
1
85
.0
:
)
(
−
−
+
=
x
e
x
F
 
 
Figure 10.15. The neural network translation of the learning part in Example 10.6 

 
Timed and High-level Petri Nets 203 
Suppose that inputs θ(p1) and θ(p2) are given random data from 0 to 1, and the 
real output θ(p5) is obtained according to the expert system. Given any initial 
condition for 
1
w  and 
,
2
w
 put the same inputs to the neural network. The error 
between the output of neural network θ′(p5) and that of the expert system θ(p5) can 
be used to modify the weights with the following learning law:  
 
(
)
( )
( ) ( )
( )
(
)( )
(
)( )
k
p
k
p
k
e
k
k
e
y
k
W
k
W
5
5
:
1
θ
θ
δ
′
−
=
Θ
+
=
+
 
where 
)]
1
(
),
1
(
[
)1
(
2
1
+
+
=
+
k
w
k
w
k
W
 is the weight at iteration k+1; 
)]
(
),
(
[
)
(
2
1
k
w
k
w
k
W
=
is the weight at iteration k; 
)
55
.0
(
200
1
85
.0
−
−
+
=
x
e
x
y
 
δ is the learning rate whose small value assures that the learning process 
converges. Select 
07
.0
=
δ
;  
)],
)(
(
),
)(
(
[
)
(
4
2
k
p
k
p
k
θ
θ
=
Θ
 and θ(p2)(k) is a given truth degree of p2, 
θ(p4)(k) is the reasoned truth degree of p4; 
θ′(p5)(k) the reasoned truth degree of p5 (the output of neural network); and  
θ(p5)(k) is the given truth degree of p5 from the expert system, all at 
iteration k. 
After a training process (
400
>
k
), the weights converge to real values. Figure 
10.16 shows simulation results. 
In this example there is only one learning layer. A more complicated case with 
two learning layers can be found in (Li et al. 2000). 
The development of theory and applications of Adaptive Petri Net (APN) still 
represents a hot research direction. APN promises to solve the knowledge learning 
problem in expert systems and other application problems. 
0
1 00
20 0
3 0 0
40 0
5 00
60 0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
w 4
w 2
 
Figure 10.16. Single layer learning results of Example 10.5 

204 Modeling and Control of Discrete-event Dynamic Systems 
10.7 Petri Net-based Design Tools 
This section presents a brief overview of many significant tools that have been 
constructed and applied in academia and industry. The Petri net community has 
well maintained an active website, i.e., the Petri Nets World, and e-mail list. The 
website address for about seventy registered Petri net-based design tools is 
http://www.informatik.uni-hamburg.de/TGI/PetriNets/tools/quick.html 
Most of these tools are free of charge for academic research. There are also many 
tools in use, which may be found in a variety of publications. The authors have 
directly or indirectly used the following tools. 
SPNP 
http://www.ee.duke.edu/~kst/ 
SPNP supports the analysis of stochastic Petri nets. It was developed by Ciardo et 
al. (Hirel et al. 2000). The model type used for input is a stochastic reward net 
(SRN). SRNs incorporate several structural extensions to GSPNs such as marking 
dependencies (marking dependent arc cardinalities, guards, etc.) and allow reward 
rates to be associated with each marking. The reward function can be marking 
dependent as well. They are specified using CSPL (C based SRN Language) 
which is an extension of the C programming language with additional constructs 
for describing the SRN models. SRN specifications are automatically converted 
into a Markov reward model which is then solved to compute a variety of transient, 
steady-state, cumulative, and sensitivity measures. For SRNs with absorbing 
markings or deadlocks, mean time to absorption and expected accumulated reward 
until absorption can be computed. This tool has been widely used for performance 
evaluation of various discrete event systems (Zhou and Venkatesh 1998). 
GreatSPN 
http://www.di.unito.it/~greatspn/index.html 
GreatSPN stands for GRaphical Editor and Analyzer for Timed and Stochastic 
Petri Nets. It is one of the earliest tools that can graphically represent Petri nets, 
simulate them, and evaluate Generalized Stochastic Petri nets (GSPN). In GSPN, 
both immediate and exponentially distributed timed transitions are allowed. 
The most recent version is called GreatSPN2.0. It is a software package for the 
modeling, validation, and performance evaluation of distributed systems using 
Generalized Stochastic Petri Nets and their colored extension. It provides a friendly 
framework and implements efficient algorithms for complex applications not just 
toy examples. One of its unique features is that it is composed of many separate 
programs that cooperate in the construction and analysis of PN models by sharing 
files. Using network file system capabilities, different analysis modules can be run 
on different machines in a distributed computing environment. Its modular 

 
Timed and High-level Petri Nets 205 
structure allows easy addition of new analysis modules. All modules are written in 
C programming language to guarantee portability and efficiency on different Unix 
machines. All solution modules use special storage techniques to save memory 
both for intermediate result files and for program data structures. Its applications to 
various DEDS are well documented in a book (Ajmone Marsan et al. 1995). 
INA 
http://www2.informatik.hu-berlin.de/~starke/ina.html 
INA represents Integrated Net Analyzer. INA is a tool package supporting the 
analysis of Petri nets and colored Petri nets. It consists of:  
• 
A textual editor for nets  
• 
A by-hand simulation part  
• 
A reduction part for Petri nets  
• 
An analysis part to compute  
- 
Structural information  
- 
Place and transition invariants  
- 
Reachability and coverability graphs 
The by-hand simulation part allows starting at a given marking to forward fire 
either single transitions or maximal steps; the user can thus traverse parts of the 
reachability graph.  
The reduction part can be used to reduce the size of a net (and of its 
reachability graph) whilst preserving liveness and boundedness.  
The analysis can be carried out under different transition rules (normal, safe, 
under capacities), with or without priorities or time restrictions (three types), and 
under firing of single transitions or maximal sets of concurrently enabled 
transitions. INA can compute the following structural information:  
• 
Conflicts (static, dynamic) and their structure (e.g., free choice property)  
• 
Deadlocks and traps (deadlock-trap-property)  
• 
State machine decomposition and covering 
Invariant analysis can be done by computing generator sets of all 
place/transition invariants and of all non-negative invariants. Vectors can be tested 
for invariance properties.  
For bounded nets, the reachability graph can be computed and analysed for 
liveness, reversability, realizable transition invariants, and livelocks. The 
symmetries of a given net can be computed and used to reduce the reachability 
graph size. It is also possible to apply stubborn reduction. Furthermore, minimal 
paths can be computed, and the non-reachability of a marking can be decided.  
Some external graphical editors and tools can export nets to INA. This tool has 
been proven robust and very useful. For example it is used for deadlock control 
design in (Li and Zhou 2006) and (Uzam and Zhou 2006). 

206 Modeling and Control of Discrete-event Dynamic Systems 
http://www.informatik.uni-hamburg.de/TGI/PetriNets/tools/db/cpntools.html 
It is a widespread tool for editing, simulating and analyzing colored Petri nets. It 
features incremental syntax checking and code generation which take place while a 
net is being constructed. A fast simulator efficiently handles both untimed and 
timed nets. Full and partial state spaces can be generated and analyzed for 
boundedness and liveness properties. It is possible to specify and check system-
specific properties. The tool also provides support for simulation-based 
performance analysis.  
10.8 Problems and Exercises 
10.1. Figure 10.17 models a discrete event system. Initial marking is shown in the 
figure, times delay j time units is associated with place pj and i units with ti. Please 
show all the cycles and find the system cycle time delay. Given two extra tokens, 
which place(s) should receive them to minimize the cycle time? 
 
Figure 10.17. A marked graph for Exercise 10.1 
10.2. Assume initial marking of the stochastic Petri net is shown in Figure 10.18 
and transition ti has its firing rate λi. Please derive the productivity if firing t4 
signifies the completion of a product. Do so for m0=(4 1 0 0 0 0)T when λi =i. 
Another influential tool is CPN Tools at the following site: 

 
Timed and High-level Petri Nets 207 
 
Figure 10.18. A stochastic Petri net for Exercise 10.2 
10.3. A serial manufacturing system is schematically given in Figure 10.19. It 
consists of three cells. Products are coming one by one to the system via input. 
After processing in cell 3 they are moved onto the output. Draw a color Petri net 
specifying the function of the manufacturing system. 
Figure 10.19. A serial manufacturing line 
10.4. For Example 10.3 create a Petri net modeling the behavior of the given 
system. Consider a serial manufacturing system with ten cells and compare the 
Petri net and the color Petri net models. 
10.5. A circle rail track is shown in Figure 10.20. Two trains are moving on the 
track clockwise. A train can pass in the next section only if next two sections are 
free.  
a. Find a Petri net describing the prescribed moves of the trains.  
b. Analyze the basic properties of the derived Petri net. 
c. Find a color Petri net describing the prescribed train behavior. 
10.6. Suppose that in Example 10.6, w1 and w2 are fixed but the certainty factors μ2 
and μ4 are unknown. Assume that the random input and accurate output data from 
the expert system can be obtained with their ideal values at  
μ2 = 0.8 and μ4 = 0.5.  
Derive the back-propagation algorithm to learn these two parameters, and 
investigate the convergence with different initial values of μ2 and μ4 between 0 and 
1, different steepness, and learning rates. 
Cell 1
Cell 2
Cell 3
input 
output

208 Modeling and Control of Discrete-event Dynamic Systems 
Figure 10.20. Circular rail track with two trains and seven sections
Section 0
1
2
3
4 
5 
6
Train A
Train B

11 
Statecharts 
11.1  Introduction 
So far it could be observed how some shortcomings of finite automata used for 
DEDS modeling were overcome by Petri nets and Grafcet. This is mainly due to 
the latter’s ability to specify the parallel activities of subsystem states and 
concurrency of events. However, a certain imperfection of both persists. 
Difficulties in visualizing large and complex DEDS require to apply a sort of 
hierarchical decomposition. Another tool for coping with this problem is 
statecharts (Havel 1987 and Fogel 1997, 1998). 
Statecharts use the same notions as the tools mentioned above, namely state and 
event, and are based on the basic transition system as well. They represent 
structure and dynamic behavior in a drawn graphical form. Their set-theoretic and 
functional description is possible, too. The next section introduces their concepts 
and Section 11.3 presents their applications to DEDS. 
11.2  Basic Statechart Components 
In a statechart, states are represented by rounded rectangles marked with a symbol, 
usually a letter as illustrated in Figure 11.1. 
The state Q in Figure 11.1a, which can be decomposed into three sub-states A, 
B, and C as shown in Figure 11.1b, can be viewed as a superstate. Transition from 
Figure 11.1a to Figure 11.1b is an example of state refinement as opposed to state 
clustering (corresponding to the transition from Figure 11.1b to Figure 11.1a. 
According to the principle of state encapsulation, the state Q encapsulates states 
A, B, and C. Figure 11.1c depicts a three-level state hierarchy. The semantics of 
the decomposition depicted in Figure 11.1 is exclusive-or (XOR) whereby in 
Figure 11.1b the situation “state Q is active” means that one and only one of states 
A, B, and C is active at some time. If saying “the system is in state Q” we mean 
that it is, e.g., in state B. If the system in Fig, 11.1c is in state Q it can be in state A 

210 Modeling and Control of Discrete-event Dynamic Systems 
being in state V. In such a case Q can be neither in state B nor C, nor A nor U at 
the same time.  
Transition from one state into another one is represented by an arrow labeled 
with abbreviation of an event. The event label “e” may be completed with a 
condition in parentheses e(P) indicating that through event “e” the system transits 
from one state to the other if the additional condition P holds on the event 
occurrence (Figure 11.2). An option is that an arrow is labeled only with condition 
(P). 
Figures 11.2a and b are equivalent as for the representation of the state transfer 
R
Q →
, which is carried out if condition P holds on event e1. Arrows can be 
directed either into a superstate, e.g., the arrow labeled with e2 in Figure 11.2b or 
out of a superstate, e.g., the arrows labeled with e1. 
Thus far, time was not explicitly considered in the described statechart 
components. There are several possibilities to include time conditions in the 
statecharts, for example, similarly to those in Petri nets. The order of state 
transitions is specified like that in untimed Petri nets. 
 
 
A
Q 
Q 
Q 
A
B
C
B
C
U 
V 
a. 
b.
c.
 
Figure 11.1. Representation of states for exclusive-or activities with hierarchical 
involvement 
 
Figure 11.2. State transit representation using arrows labeled with events 
  
 
Q 
a. 
b.
R 
e1(P) 
Q 
R 
A
B 
e1(P)
e1(P)
e2 

 
Statecharts 211 
In statecharts a default state activation can be specified with an arrow and a dot 
as shown in Figure 11.3. The state transfer is performed according to the arrows 
pointing at default states. In Figure 11.3a, the default transit to state Q by event “e” 
is accomplished through the transit in A given by the transit to the default state V. 
As a whole, event “e” transfers the system from state R to V. Other needed arrows 
are left out. 
 
Q 
A 
B
C 
U 
V 
b.
Q 
A
B
C
U 
V 
R 
R 
a. 
e 
e
 
Figure 11.3. Default state activation 
 
Q 
A 
B
C 
U 
V 
R 
e1 
P 
e2 
H 
 
Figure 11.4. Use of the history node 
Figure 11.5. Orthogonal states Q1 and Q2 
 
Q 
e1 
P 
e 
A
B 
C 
D
e2 
e3 
e4 
Q1
Q2

212 Modeling and Control of Discrete-event Dynamic Systems 
Figure 11.6. Use of the orthogonal states 
Another useful component is a history node as shown in Figure 11.4. The 
semantics of the graphical scheme is as follows: if a system is in state R and event 
“e1” occurs, the system goes into one of the states from the level of the superstate 
Q, which is A, B or C depending on the most recently active state before Q was left 
by event e2. If by chance it were A, state R would be transferred in V because of 
the arrow indicating a default state. Notation H* means the transit in the most 
recently active state on the lowest hierarchical level. 
Concurrency and independency are represented by dashed rectangles within a 
superstate (Figure 11.5). It represents an AND relation of the state activities. On 
entering state Q, both states Q1 and Q2 are active. The activity by refinement means 
that both states A and D are active simultaneously. For Q1 it is A and then via “e1” 
B, for Q2 it is D and then via event “e4” C. The same event can effect both 
components of Q if, , e2= e4. The states within a superstate being in the AND 
relation are called orthogonal. Entering from a state into an AND box ensures the 
activation of a state in each component of the box as shown in Figure 11.6. In 
hierarchically embedded levels the AND boxes can be used similarly as the XOR 
boxes. 
There are two kinds of the stimuli considered for state transitions: the event “e” 
alone or “e” accompanied by a condition P denoted by a label e(P). The event 
represents a stimulus acting over an infinitely short time interval or in a discrete 
time point. State transfer by an event is realized if a durable (level kind) condition 
P is met. The generation of events can be connected with transits of states (notation 
e1/s) or with the states themselves. The possibilities are explained in Figure 11.7. 
The generated events are called actions and the changes of values are called 
activities. Thus s is an action, which is generated by the transfer 
Q
P →
 and is 
firing transit
B
A →
. Start (X) and end (X) are special events setting and resetting 
X. An example of an activity is setting Y by entering state C, setting Z by the exit 
from C, setting W during the activity of state C.  
The reader can find more information about the statecharts and their formal 
definitions in (Harel 1987) and (Harel et al. 1987). Their applications to the 
modeling of reactive systems together with a statechart-based structured analysis 
method called STATEMATE are in detail presented in (Harel and Politi 1998). A 
thorough treatment of converting Petri nets into statecharts is given in (Eshuis 
 
Q 
e1 
P 
e0 
A
B 
C 
D
e2 
e3
e4 
Q1
Q2
R 
e5

 
Statecharts 213 
2006). An algorithm of polynomial complexity is proposed to translate a class of 
Petri nets into an equivalent statechart. Meanwhile, the Petri net structure is 
preserved. Some recent applications to industrial automation can be found in (Lee 
et al. 2005). 
11.3  Statechart Application 
A printed circuit board (PCB) assembly cell in Figure 7.10 is used as an illustrating 
example. The Petri net interpreted for control and a statechart specification are 
compared. Figure 11.8 shows the Petri net interpreted for the cell control. The 
alteration of the robots by both the component picking and inserting has been 
chosen. The cell and the Petri net specification are described in Example 7.3, 
Section 7.3. The meaning of additional transition conditions and control commands 
associated with places is given in Table 11.1. If a transition bears a condition, 
CR1_a, it is a shortage for a test if variable CR1_a = = true (logic one).  
The same control as that from the Petri net has been specified using the 
statechart depicted in Figure 11.9. Both representations offer the similar 
complexity graphically. 
 
 
e1/s 
P 
Q 
R 
e2/start(X) 
s 
A 
B 
C 
e3/end(X)
entry Y 
exit Z 
throughout W 
e0(in A) 
D 
e4 
e5
 
Figure 11.7. Actions and activities in a statechart 

214 Modeling and Control of Discrete-event Dynamic Systems 
Table 11.1. Petri net logic conditions and control commands 
Logical conditions attached to transitions 
CR1_a   (CR2_a) 
Electronic component for R1 (R2) is available 
R1_ep    (R2_ep) 
End of component picking from feeder by robot R1 (R2) 
AR1_b   (AR2_b) 
Arm of robot R1 (R2) pulling back done 
R1_pcb  (R2_pcb) 
Robot R1 (R2) is near to PCB area prepared for inserting 
R1_cins  (R2_pcb) 
Inserting of a component by R1 (R2) done 
R1_fa     (R2_fa) 
Robot R1 (R2) is near to feeder area prepared for picking 
Control commands 
R1_P        (R2_P) 
Command for R1 (R2) to pick an electronic component 
AR1_B     (AR2_B) 
Command pull back the arm of robot R1 (R2) 
R1_MPC (R2_MPC) 
Command for R1 (R2) to move to PCB area 
R1_IC      (R2_IC) 
Command to insert a component  
R1_MFA (R2_MFA) 
Command to move to feeder area 
11.4 Problems and Exercises 
11.1. For the manufacturing system in Exercise 1.5, elaborate a statechart 
specifying its control according to the required function of the system. 
11.2. Compare the state chart in Exercise 11.1 with the specification using Petri 
nets interpreted for control. 
11.3. Derive the statechart for the Petri net model given in Figure 7.12. 

 
Statecharts 215 
p11
p12
t12
t11
p13
p14
t14
t13
p15
t15
p16
p17
t17
t16
p21
p22
t22
t21
p23
p24
t24
t23
p25
t25
p26
p27
t27
t26
p3
p3a
p4
p4a
p1
p2
CR1_a
R1_P
R1_ep
AR1_B
AR1_b
R1_MPC
R1_pcb
R1_IC
R1_eins
AR1_B
AR1_b
R1_MFA
R1_fa
CR2_a
R2_P
R2_ep
AR2_B
AR2_b
R2_MPC
R2_pcb
R2_IC
R2_eins
AR2_B
AR2_b
R2_MFA
R2_fa
 
Figure 11.8. Petri net interpreted for control of the PCB assembly 

216 Modeling and Control of Discrete-event Dynamic Systems 
 
S13 
S11 
S12 
(wait  on compon. 
for R1)
(R1 available) 
 
SF 
(in 
 S31) 
CR1_a
S14 
entry R1_P     
AR1_b
 S16 
entry R1_MP     
S17 
R1_pcb 
S18 
entry R1_IC     
AR1_b 
 S20 
entry R1_MF   
R1_ep 
S15 
entry AR1_B    
(in S41)
R1_cins 
S19 
entry AR1_B    
R1_fa 
S23 
S21 
S22 
(wait  on compon.
for R2) 
(R2 available)
SG
(in 
 S33) 
CR2_a
S24 
entry R2_P      
AR2_b
 S26 
entry R2_MP     
S27 
R2_pcb 
S28 
entry R2_IC     
AR2_b 
 S30 
entry R2_MF     
R2_ep 
S25 
entry AR2_B    
(in S41)
R2_cins 
S29 
entry AR2_B    
R2_fa 
S31 
S32 
S41 
S42 
S44 
S34 
S33 
CR1_a 
AR1_b 
CR2_a 
AR2_b 
R1_pcb 
AR1_b 
R2_pcb 
AR2_b 
S43 
SA 
SB 
SC
SD 
SE 
 
Figure 11.9. Statechart for a two-robot system for PCB component insertion 

12 
DEDS Modeling, Control and Programming 
12.1 Modeling Methodology 
Finite automata, Petri nets, Grafcet, statecharts, etc., are tools for DEDS 
specification and analysis. They represent a system as a whole or its chosen parts. 
The function of the control system to be designed requires specific extensions of 
the expression means in order to enable a reactive performance of the control in a 
feedback system structure.  
Generating a DEDS model is a highly creative process. There are many ways 
how to achieve this goal. However, precise and exhausting hints for it do not exist. 
Rather there are several supporting methodologies. One of useful practical ways is 
to first elaborate a model of the complete system as it appears to an observer with 
the control included. Second, a model of the system control is to be elaborated, 
which may serve for the control function analysis and writing control programs. 
Operations in execution represent partial system states, which change through 
events. From the abstract system viewpoint the basic DEDS features are generally 
as follows: 
a. Concurrency of operations 
b. Synchronization of operations 
c. Sharing common resources such as machines, robots, storages, data blocks, 
etc. 
d. Limitation of resources 
e. Cyclic behavior, i.e., the repetition of some procedure schemes 
f. 
Failure-safe processing without shutdowns, deadlocks, etc. 
g. Achieving maximum efficiency with respect to some criteria, e.g., right 
product mix, maximum throughput, minimum make-span and other, via 
optimal routing of objects in the system and scheduling of operations. 
Considering Petri nets as a main DEDS modeling tool in this book, it is easy to 
verify that the individual features are ensured as follows: 

218 Modeling and Control of Discrete-event Dynamic Systems 
 
(b) 
(a) 
⇔ 
⇔
 
 
(c) 
(d) 
⇔ 
⇔ 
 
 
(f) 
⇔ 
⇔ 
(e) 
 
Figure 12.1. Basic Petri net transformation rules 
Feature d: 
by the boundedness; 
Feature e: 
by the reversibility; 
Feature f: 
by the liveness; 
Feature g: 
by the Petri nets interpreted for control.  
Then a basic goal is to create a bounded, reversible and live Petri net as a 
DEDS model having all required states or markings reachable. There are two ways 
to achieve it: 
1. To generate a Petri net without any constraints and then to check the 
analyzed features and make necessary corrections. 
2. To use elementary building blocks preserving the required features in 
bottom-up composition or in top-down refinement. 
Frequently, the complexity of a real DEDS leads to a large and complex Petri 
net. Analyzing such nets is practically very difficult and time consuming. 
Therefore, availability of a systematic approach to the Petri net design is highly 
desirable. The substance of such approaches is model reduction and composition 
techniques. Such a transformation, either reduction or composition, helps to 
Features a through c: they are contained in the very substance of Petri nets; 

 
DEDS Modeling, Control and Programming 219 
simplify or create Petri nets preserving the required properties, and makes an 
analysis of Petri nets easier. 
A basic list of the most frequently used transformation rules is presented 
graphically in Figure 12.1. The rules (Murata 1989; Zhou and Venkatesh 1998) 
include: 
a. Fusion of series places; 
b. Fusion of series transitions; 
c. Fusion of parallel places; 
d. Fusion of parallel transitions; 
e. Elimination of self-loop places; 
f. 
Elimination of self-loop transitions. 
Often it is advantageous to use a hierarchical decomposition of a Petri net (a 
higher level) into subnets (lower level). A standard way is to develop either a 
transition of a hierarchically higher Petri net into a subnet or place into a subnet 
(Abel 1990). In the former case, the developed transition splits into two transitions 
between which the subnet is located, whereby no arcs are permitted between the 
subnet and the nodes of the higher level Petri net. The latter case is treated 
similarly using place splitting. Decomposition of a transition is illustrated in Figure 
12.2. 
p1 
p21 
p2 
t1 
p3 
t2 
t2 
t2 
p23 
p22 
p24 
t21 
t22 
 
Figure 12.2. Decomposition of a transition 
Consider a composition method (Ferrarini 1992, 1995 and Ferrarini et al. 1994) 
as a model of such efforts. The basic idea is to represent an elementary control task 
using a strongly connected binary Petri net state machine (SCSM, see Section 7.4) 
with one and only one marked place within the initial marking. A complex control 
function is designed using a composition of a group of  elementary control tasks 
represented by a composition of the corresponding elementary SCSMs. The SCSM 
interactions have to satisfy various relations, e.g., synchronization and blocking. 
Properties like liveness and boundedness are preserved by the composition. 

220 Modeling and Control of Discrete-event Dynamic Systems 
Various kinds of interconnections are shown in Figure 12.3. There are:  (a) self-
loop, (b) inhibitor arc, and (c) synchronization. The functions of the 
interconnections are easy to understand from the graphical representation where 
the elementary SCSM are noted as E1, E2, … , and Ek. 
Zhou and DiCesare (1991) and Zhou et al. (1992) proposed one of the excellent 
reduction/composition methodologies. The core idea of their methodology is a top-
down refinement of a relatively simple first-level Petri net, which models basic 
system operations, and a bottom-up completion of the net with places and 
transitions corresponding to the system resources. More discussions can be found 
in (Zhou and DiCesare 1993). Brief introduction to their results is presented below. 
A common DEDS feature is the possibility to distinguish the following system 
components: 
1. Operations performed in the system, e.g., processing parts in a flexible 
manufacturing system (FMS), and processing pieces of data in a distributed 
computer system. 
2. Subsystems representing fixed resources, e.g., machines and robots in FMS, 
and computer processors. 
3. Subsystems representing variable resources, e.g., pallets or fixtures in FMS, 
and external memory devices in the computer systems. 
Petri net models reflect the three groups of components. A set of places 
corresponds to each group. Petri net places for the first group are characterized by 
a zero initial marking places; for the second group by some non-zero binary or 
fixed marking place, and for the third group by some non-zero possibly variable 
numerical marking places. 
The first-level Petri net represents the system operations. Then, using the top-
down approach more details are added by refining the net of operations and their 
relations. Afterwards, the Petri net places for resources are added to the net in a 
bottom-up manner. 
 
Figure 12.3. Three kinds of elementary structure connections by the composition 
 
p11 
p12 
t11 
p21 
p22 
t21 
E1
E2 
a. 
p11
p12
t11
p21
p22
t21
E1
E2
b.
{
p11
p12
t1~k
E1
p21
p22
E2
pk1
pk2
Ek
c.

 
DEDS Modeling, Control and Programming 221 
 p1 
p2 
pn 
t1 
. . . . . 
tn 
pn+1 
 
Figure 12.4. A sequence Petri net 
 
pn+1 
p1 
. 
. 
. 
t1 
t2 
pn 
pn+2 
 
Figure 12.5. A parallel Petri net 
 
pn+1 
tn+1 
t2n+1 
t1 
tn 
. . . . . 
. . . . . 
p1 
pn 
t2n 
pn+2 
t2n+2 
. . . . . 
 
Figure 12.6. A choice Petri net 
The first-level Petri net is composed of basic design modules. They are chosen 
to posses the three most important properties reflecting real-world systems, namely 
boundedness, reversibility and liveness. The basic design modules include: 
a. Sequence Petri net (Figure 12.4), 
b. Parallel Petri net (Figure 12.5), 
c. Choice Petri net (Figure 12.6), 
d. Decision-free choice Petri net (Figure 12.7). 
It has been proved in the above-mentioned works of Zhou et al., that any 
composition of basic design modules preserves the three mentioned basic 
properties: boundedness, reversibility and liveness. In the refinement process, 
modules a and b can replace a place, and modules c and d can replace a transition. 
The bottom-up procedure resolves the problem of sharing the system resources. 
Two kinds of resource sharing can be distinguished: a parallel mutual exclusion of 
resources and a serial mutual exclusion of resources. Resource sharing situations in 

222 Modeling and Control of Discrete-event Dynamic Systems 
pn+1 
p1 
pn+2 
p2 
tn+1 
t2n+1 
z 
t1 
tn+2 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
t2 
tn 
pn 
t2n 
t2n+2 
 
Figure 12.7. A decision-free Petri net 
 
p2 
z 
z 
p3 
t2 
t1 
p1 
p4 
p5 
t3 
t4 
z 
z 
z 
. . . . . . . . 
z 
p6 
p7 
t5 
t6 
p2n
p2n+1 
t2n-1 
t2n 
 
a. 
 
t1 
z z 
z z 
z 
z z 
z 
z 
z z 
. . . . . 
p1 
p2 
p3 
t1 
t2 
p4 
p5 
p6 
p7 
p8 
p9 
p2n 
p2n+1 
t2 
t3 
t4 
t2n-1 
t2n 
t5 
p2n+2
 
b. 
Figure 12.8a. Parallel mutual exclusion and b. Serial mutual exclusion, also called 
sequential mutual exclusion 

 
DEDS Modeling, Control and Programming 223 
DEDS expressed by means of the Petri net elementary structures are depicted in 
Figures 12.8. The initial marking in Figure 12.8 is one possible example. However, 
there are several possibilities depending on the actual requirements. It has been 
proved that structures in Figure 12.8 preserve the basic Petri net properties 
considered above both individually or in combination with the basic design 
modules under certain conditions. 
The described methodology is applicable in the DEDS regardless of the 
system’s substance. Next this methodology will be illustrated on a flexible 
manufacturing system depicted in Figure 12.9 (Niemi et al. 1992).  
 
Vision 
system 
Input conveyor 
M illing 
machine 
Drilling 
machine 
M easuring 
station 
Storage 
Output conveyor 
Control 
computer 
Robot 
 
Figure 12.9. Layout of an FMS 
This system comprises a semiconductor camera vision system for the 
recognition and location of parts coming into the system on an input conveyor. A 
central transferring server of the system is a robot. Further, there are two NC 
machining units: a drilling machine with two drills above an xy-table and a three-
axis milling machine with a tool changer. A measuring station is located between 
the milling and drilling machines. There is an intermediate storage where the robot 
can temporarily put the parts, and an output conveyor. The intermediate storage 
can be used as a multiple storage for more types of the products.  The system is 
equipped with control computers on both process and coordination levels.  
A particular technological process to be cyclically realized in the system is as 
follows. There are two different types of raw parts at the input. The first is intended 
for the product of type A, the second for type B. The parts come irregularly, i.e., 
with random time intervals between two parts and with a random number of 
consecutive parts of one type. The parts are recognized and located by the camera 
vision system. Product A is obtained by drilling followed by measuring. Product B 
is obtained by milling. The cell robot provides the necessary transfers of the parts 
or products. No intermediate storage is considered in this particular example. 

224 Modeling and Control of Discrete-event Dynamic Systems 
Example 12.1. Figure 12.10 shows the first step of a Petri net system performance 
modeling. The places of Petri nets correspond to operations. For the sake of brevity 
the meaning of the system places is given in Figure 12.11, which shows the next 
stage-refined model. Transitions correspond to the starts and ends of operations. 
The first stage Petri net model is drawn in full lines (the Petri net is not a strongly 
connected one). The question of reachability, boundedness, liveness and 
reversibility is to be resolved. Undoubtedly a full-line Petri net is bounded, live and 
each of its marking is reachable. However, it is not reversible. The additional parts 
of the net drawn in dashed lines turn the Petri net into a reversible one. 
 
p 
p 
p 
p 
p 
p 
p 
p 
p 
p 
p 
t 
t 
t 
t 
t 
t 
t 
t 
t 
A1 
DA
O1
A0 
OA
B1 
B0 
MB
QB
O2
OB
A 
B 
DS 
DE
MS 
ME(QS)
OEA
OEB 
QE
 
Figure 12.10. First stage Petri net model 
The next refined Petri net model is shown in Figure 12.11. The availability of 
machines is given by marked places, e.g., the drilling machine is free if place 
D
p  
contains a token. If the part of the net modeling the robot function is omitted, a 
marked graph (Section 7.4) is obtained which is evidently bounded, reversible and 
live for the given initial marking. The robot presents a shared resource with 
conflicts (there are more arcs outgoing of place 
R
p ). The conflicts are of mutual 
exclusion type. Though the resulting net is no more a marked graph, nevertheless it 
is bounded, reversible and live as discussed earlier in this section. 

 
DEDS Modeling, Control and Programming 225 
 
p 
p 
p 
p
p p 
p 
p 
p
p
p
p 
p
p
p
p 
p
p
p 
p 
p
p 
p 
p 
t 
t 
t
t
t 
t
t
t
t
t
t
t 
t 
t 
A0 
A1 
IDA
DS 
DE
D 
IDA 
DA 
WA
OA
DOA
DOA
OSA
OEA
R 
M 
A 
B 
B1 
B0 
IMB
IMB 
MS 
MB 
ME
W1B
MQB
MQB
QS
O1
QB
QE
Q
W2B 
t
t
QOB
QOB
OSB
O2
tOEB
OB 
Description of places (under assumption 
they are occupied with a token): 
Availability of parts at input                        Descriptions of transitions: 
p     part of the type A                                    
p     part of the type B                                t      start of transfer  of the part A  
              
 
 
 
         in drilling machine 
Availability of system resources    
  t      end of transfer and start of 
p     robot             
 
 
         drilling  
p     drilling machine      
 
  t      end of drilling 
p     milling machine      
 
  t      start of transfer of the product A
p     measuring system                                      on the ouput conveyer 
p     output conveyer for product A 
  t      end of transfer and moving by output conveyer 
p     output conveyer for product B  
          etc.  
       
Operations 
p     transfer of the part A from input to drilling by robot
p    drilling A 
p     part A waiting in drilling machine
p     transfer from drilling machine to output by robot
p     transfer  of the product A at output by conveyer
p     transfer of the part B from input to milling by robot
p    milling B 
p     measuring of the semiproduct B,  etc., analogously as for A     
A1 
B1 
R 
M 
D 
Q 
OA 
OB 
IDA 
DA 
WA 
DOA 
O1 
IMB 
MB 
QB 
IDA
DS
DE
DOA 
OSA
 
Figure 12.11. Petri net model for FMS 
12.2  Resolution of Conflicts  
System conflicts reflected as Petri net conflicts are to be removed by practical 
control solutions (Hrúz et al. 1996; Hrúz 1997). The following three figures show 
the basic Petri net interpreted for control structures corresponding to three basic 
conflict situations in which the resources can be involved. 

226 Modeling and Control of Discrete-event Dynamic Systems 
Figure 12.12. Resources and operations (a) without (b) with conflict 
Figure 12.12(a) shows a typical conflict-free situation. Places p11–p1k  specify 
the semi-products s1–sk needed for the job realization. If the places are occupied 
with tokens, the required semi-products are available. Tokens in pa, pb, …,  and pz 
indicate that the second kind of resources described in the preceding section like 
processing machines, robots etc., are available for the job performance. The job or 
operation itself is represented by 
3
p . In this Petri net the command for the 
operation start is S:=1. Place 
2
p  specifies a required transfer of semi-products to 
the input of the processing machine (command I:=1), and 
4
p  (command O:=1) is 
connected with the transfer out of the manufacturing cell. Various events, e.g., 
semi-product presence signals, start or end of the operations etc., can be associated 
with the transitions. Output places p21–p2l indicate that the operation brings about 
several different workpieces as the output. Let us follow a portion of the model 
dynamics. After firing 1t  (if cond1 is met), a token goes to 
2
p  and the command 
I:=1 is generated forcing the transfer of semi-products to the processing machine, 
start of conveyors etc. When the process variable i gets the value 1, transition 
2t  
fires and a token comes to 
3
p  and 
a
p , respectively. The command S is set to one 
which triggers the operation. Analogously, after the end of operation (process 
variable 
1
=
=
e
), the semi-products obtained in the operation are transferred to the 
output and the machine is free. The outgoing arcs from the transitions 
4
3
2
,
,
t
t
t
 
p11 
p 2 
p a1 
p 1 
p 2 
p 3 
p 6 
p 5 
p R 
p 4 
p b1 
p 3 
p 4 
p12 
p 1k 
p21 
p a 
p b 
p z 
p22 
p2l 
t1 
t2 
ta1 
t1 
t2 
ta2 
tb2 
t4 
t3 
tb1 
t3 
t4 
I:=1 i==1 
e==1 
cond1 
cond2 
S:=1 
T1:=1 
S1:=1 
S2:=1 
T2:=1 
O:=1 
a. 
b.

 
DEDS Modeling, Control and Programming 227 
specify that, after the corresponding events, the resources are again available. The 
Petri net in Figure 12.12a belongs to the Petri net class called marked graphs with 
respect to the structure. There are no conflicts in the marked graphs. 
The next typical situation in FMS is modeled by a Petri net interpreted for 
control as depicted in Figure 12.12b. One resource, e.g., a robot (available if place 
R
p  is occupied with a token) is used or shared by two operations, namely a 
workpiece transfer  to  the  first  machine  (place 
2
p , control command 
1
:
1 =
T
) 
and a workpiece transfer to the second one (
5
p , control command T2:=1). The 
individual machine operations are initiated by means of commands S1 and S2. 
There can be more shared resources. For brevity, the elementary structure in Figure 
12.12b is limited to one shared resource only. Obviously, it is a parallel mutual 
exclusion. Finally, Figure 12.13 shows a situation when a job decision or choice 
occurs in the system. Then, p indicates the availability of a semi-product for the 
next processing that can be performed either by operation O1 (place
1
OP
p
) or by O2 
(place 
2
OP
p
 ), etc., up to the operation Oj (
OPj
p
). As is clear from Figure 12.13, 
machine M1 is required for the operation O1, machine M2 for O2, etc. 
The composition of the above described elementary building blocks (Figures 
12.12 and 12.13) can generate aggregated and more complex Petri net structures 
containing conflicts. Consider a Petri net interpreted for control (further denoted as 
a PC) is built up of the elementary structures shown in Figures 12.12b and 12.13. 
The conflicts which may occur in the PC are to be eliminated in order to achieve a 
required deterministic behavior via control. 
Assume that a reversible, bounded and live (on level L4) PC has been designed 
using the methodology described in Section 12.1 and it specifies the desired 
control. Conflicts due to the shared resources with or without operation choice can 
be eliminated by means of inhibitors and incidentors. The elimination method 
consists of the following steps. 
 
pMj 
pM2 
pM1 
pOP1 
pOP2 
pOPj 
pN1 
pN2 
pNj 
p 
 
Figure 12.13. Conflict situation due to operation choice 

228 Modeling and Control of Discrete-event Dynamic Systems 
Step 1 
The given PC is inspected in order to find all places with two or more outgoing 
arcs. Let the set of such places be denoted as 
O
P . Then the set of places with more 
than one incoming arcs is found and denoted 
IP  . The two sets may not be 
disjunctive (they can intersect), i.e., generally 
∅
≠
∩
I
O
P
P
. If the PC contains 
operation choice, it is assumed that according to the elementary structure in Figure 
12.13, the resources for the operations are represented by the corresponding places 
in the net. 
Step 2 
For each place 
O
k
P
p ∈
 the set of outgoing arcs is   
 
(
) (
)
(
)
{
}
kj
k
j
k
j
k
k
t
p
t
p
t
p
A
,
,...,
,
,
,
2
1
=
 
(12.1) 
where  
 
(
)
(
)
(
)
F
t
p
F
t
p
F
t
p
kj
k
j
k
j
k
∈
∈
∈
,
,...,
,
,
,
2
1
 
(12.2) 
Step 3 
For each place 
I
m
P
p ∈
 a set of incoming arcs is  
 
(
) (
)
(
)
{
}
m
j
m
j
m
j
m
p
t
p
t
p
t
B
m ,
,...,
,
,
,
2
1
=
 
(12.3) 
where 
 
(
)
(
)
(
)
F
p
t
F
p
t
F
p
t
m
j
m
j
m
j
m
∈
∈
∈
,
,...,
,
,
,
2
1
 
(12.4) 
Step 4 
Denote the elements of the sets 
k
A  and
m
B  respectively as 
 
{
} and
,...,
,
2
1
k
kj
k
k
k
a
a
a
A =
  
{
}
m
mj
m
m
m
b
b
b
B
,...,
,
2
1
=
 
(12.5) 
All combinations of two elements (arcs) from set 
k
A  are taken into account. 
Consider one such combination, say {
}
v
u a
a ,
, where 
(
)
(
)
v
k
v
u
k
u
t
p
a
t
p
a
,
,
,
=
=
. 
The arcs 
v
u a
a ,
 point to the transitions 
v
u t
t , , respectively. Further, the pre-places 
u
p~  and 
vp~  of ut  and 
vt  other than 
k
p  are considered. An inhibitor going out of 
u
p~  is generated pointing to the post-transition of 
v
p~ . Depending on the required 
system behavior this can also be done inversely. If there are more pre-places, it is 
sufficient to generate just one inhibitor for one combination of arcs. 

 
DEDS Modeling, Control and Programming 229 
This step is repeated for all combinations of elements from set 
k
A ; the 
procedure is repeated for all sets 
k
A  , k = 1,2,...,. If necessary, it is also repeated 
for sets 
m
B , m = 1,2,....,. In case of shared resources it is sufficient to deal with sets 
k
A  only. 
The case when neither 
u
p~  nor 
v
p~  exists has to be specially treated. It should 
be noted that a formal application of the described method can generate redundant 
inhibitors because several inhibitors can eliminate the same conflict. After adding 
inhibitors, reversibility, boundedness and liveness of the obtained Petri net has to 
be analyzed. 
Example 12.2. In this example a more complicated situation is shown using a 
technology layout of Figure 12.9. For the system in Figure 12.9 Let us consider 
two intermediate storages of parts and the following production task: one type of 
product is to be produced by a freely ordered milling and drilling of a raw part 
coming irregularly at the input. Input, output and storages are considered as 
operations in a broader sense. Possible prescribed sequences of operations are: 
1. Input 
1. Input 
1. Input 
1. Input 
2. Milling 
2. Milling 
2. Drilling 
2. Drilling 
3. Drilling 
3. Storage no. 1 
3. Milling 
3. Storage no. 2 
4. Output no. 1 
4. Drilling 
4. Output no. 2 
4. Milling 
5. Output no. 1 
5. Output no. 2 
An ordinary Petri net modeling the given system behavior is drawn in full line 
in Figure 12.14.  Places and transitions are similar to those in Figure 12.12. The 
capacity of storages is 5, and the same are capacities of the corresponding places, 
namely 
1
1,
WS
S
p
p
, as well as of places 
2
2,
WS
S
p
p
. As in the previous case, sharing 
of resources appears with places
,
,
M
R p
p
 and 
D
p
. It brings about mutual 
exclusions, treated in the previous section.  
The arcs (
)
11
,t
p A
 and (
)
21
,t
p A
 represent a conflict situation, namely an 
operation conflict. It occurs if the places 
D
M
R
A
p
p
p
p
,
,
,
 all contain a token. 
Analogously an operation conflict can appear with place 
1
WM
p
 or 
2
WD
p
. The 
places associated with the operation conflict are crosshatched in Figure 12.14. This 
type of conflicts is called a branching operation conflict. On the other hand, 
RMSD
p
 
and 
RDSM
p
 bring about the so-called merging operation conflict.  
For control design it is necessary to eliminate the indeterminacy produced by 
any type of conflict. PC extends the modeling power of standard Petri nets, 
involving a larger class of flexible manufacturing systems. Control needs to deal 
with the conflicts of all three groups, i.e., 1) branching operation conflicts, 2) 
merging operation conflicts, and 3) resource sharing conflicts that should be 
identified and eliminated using PC. 

230 Modeling and Control of Discrete-event Dynamic Systems 
Figure 12.14. FMS Petri net model with conflicting operations 
Let us consider the first group. In Figure 12.14 the involved places are 
crosshatched. Take 
A
p  and extensions drawn in dashed lines. A token in 
1p , the 
empty place 
2
p  and a token in all places 
,
A
p
D
M
R
p
p
p
,
,
 represent a situation 
when (under safe rules respecting capacities) an otherwise conflicting situation is 
removed. Let M(p, r) denote the marking in p at the r-th time point. 
A similar situation occurs if 
 
p 
p
p 
p
p 
p
p
p 
p
p
p
p
p 
p
p 
p
p 
p
p
p 
t
t
t 
t 
t 
t
t
t
t
t 
t
t
t
t 
p
p 
p 
p 
p
t 
t 
t 
t
t
p
t
p
p
t
t 
t 
t
A 
A1 
A2 
I1
I2 
11 
12 
RIM 
RID 
21 
22 
DA2
23
WD2
R
M
24
MA1
13
WM1
14
15
RMSD p
R
D
RDSM
p
R
25
31
RMS
32
S
WS1
33
c   =5
c   =5
c   =5
c   =5
S2 
4
S
3
18 
RDO
O
17 
WD
16 
DA1 
p
p
R
R
MA2 
26 
WM2 
27 
O2 
RMO
28 
43
pR
p
R
p
R
RDS
42
p
R
WS2
S2 
41
p 
p 
p
p
4
2 
1 
3
t 
t
t
t
t
t
t
t
t
t 
t
t
t
t 
11
21
11
21 
27 
43
1
21
27
43
41
24
11
21

 
DEDS Modeling, Control and Programming 231 
 
(
)
(
)
(
)
(
)
(
)
(
)
0
,
,1
,
,1
,
,1
,
,0
,
,1
,
2
1
=
=
=
=
=
=
r
p
M
r
p
M
r
p
M
r
p
M
r
p
M
r
p
M
D
M
R
A
 
The incidentor (
)
21
1, t
p
eliminates the conflict for the marking 
 
(
)
(
)
(
)
(
)
(
)
(
)
1
,
,1
,
,1
,
,0
,
,0
,
,1
,
2
1
=
=
=
=
=
=
r
p
M
r
p
M
r
p
M
r
p
M
r
p
M
r
p
M
D
M
R
A
 
whereby the control policy giving priority milling over drilling in a symmetric 
situation has been used. The inhibitor (
)
21
1,t
pWM
 eliminates the conflict in case 
when drilling both as the first operation as well as the second one is possible. The 
branching operations conflicts associated with 
1
WM
p
 and 
2
WD
p
 are solved 
similarly as with 
A
p  . 
The merging operation conflict associated with 
RMSD
p
 is solved by means of 
the inhibitors (
)
33
1,t
pWM
 and (
)
33
3,t
p
 giving priority to the firing of 14
t
. The latter 
inhibitor “covers” the whole occupation of the drilling machine. Similarly it is with 
place 
RDSM
p
 . 
Each resource sharing conflict has to be solved by analyzing the situation in the 
pre-places of the transitions involved in the conflict. The pre-places are hatched or 
crosshatched. A resource sharing conflict can be solved by an appropriate use of 
inhibitors, e.g., if for the markings at the r-th time point 
 
(
)
(
)
(
)
(
)
(
)
(
)
,1
,
,0
,
,1
,
,1
,
,1
,
,1
,
2
3
2
1
=
=
=
=
=
=
r
p
M
r
p
M
r
p
M
r
p
M
r
p
M
r
p
M
O
D
WM
R
WS
 
then the conflict is eliminated by means of the inhibitor  (
)
27
1, t
pWS
 whereby a 
priority is given to the transfer to the drilling machine, according to the second 
operation sequence introduced above. Some resource sharing conflicts can be 
solved within the solution of operation conflicts. For example, a resource sharing 
conflict with (
)
11
,t
pR
 and (
)
21
,t
pR
is solved within the solution of the branching 
operation conflict associated with 
A
p . The same happens if both 
R
p  and 
1
WM
p
 
are occupied and a branching operation conflict for 
1
WM
p
 is solved. 
Inhibitors and incidentors eliminate conflicts and generate the final PC-Petri 
net with complete transition conditions and place control variables. 
Example 12.3. A PC is to be generated (Figure 12.15) for the technological layout 
in Figure 12.9 and the following production: 
two products are to be produced, each from its own input raw part 

232 Modeling and Control of Discrete-event Dynamic Systems 
 
2nd operation–milling 
product X2: 
one operation–milling 
After drilling, semi-product X1 can be stored in the intermediate storage if the 
milling machine is occupied; and product X2 can only go directly to the output. 
Each product has its own output. Drilling X1 is preferred to milling X2. Milling X2 
is preferred, if possible, to storing. Other relations are obtainable, at least the 
authors hope, from the “talk” of the Petri net model. 
Figure 12.15. FMS job with operation conflicts due to the use of storage 
p 
p 
p 
p 
p
p 
p
p
p
p 
p
p 
p
p 
p
p
01 
02 
0 
1 
2
D 
3
4 
5
6
7
8 
9 
10
11
R
p
M
t 
t 
t 
t 
t
t
t
t
t
t
t
t 
t
t
1 
2 
3
4t
5
6
7 
8
9
10 
t 11
12
13
14
x  = =1 
x   = =1 
h   = = 1
1 
2 
d 
e    = = 1
d
h   = = 1 
m 
h   = = 1 for t 
m
e   = = 1 
m
e   = = 1
m
c = 10
h  = = 1
s
p
R
h    = = 1 
c 
h   = = 1
c
RCDX1:=1
RDSX1:=1
RCMX2:=1 
MX2:=1
RMX2:=1
DX1:=1
w:=1
w:=0
Control action for 
p4
if w = = 0  RDMX1:=1; 
if w = = 1  RSMX1:=1; 
MX1:=1
RMX1:=1 
DX1:=0 
MX1:=0
MX2:=0
01 
02 
RDX1:=0  etc.
p 
1a 
8 
product X1:   
1st operation–drilling 

 
DEDS Modeling, Control and Programming 233 
Example 12.4. Figure 12.16 represents a robotic cell with one robot R, two 
processing machines M1 and M2, input (C1) and output (C2) belt conveyors. 
Workpieces gather at the stop S where a photo-sensor P1 detects a workpiece to be 
prepared for the processing in the cell. The machines perform different jobs with 
different operation times. A prepared workpiece is transferred to a free machine. If 
both machines are free, M1 has priority.  
After finishing the job, the robot transfers the processed workpiece on the 
output conveyor C2 (assuming that there is free space for it). The robotic cell 
coordination control is represented by a PC in Figure 12.17. 
M1 
R 
M2 
C1 
P1 S 
P2 
C2 
 
Figure 12.16. A robotic manufacturing cell 
 
Figure 12.17. PC-Petri net for the control of robotic cell 

234 Modeling and Control of Discrete-event Dynamic Systems 
In this example, the robot is a typical shared resource. The corresponding place 
in the PC in Figure 12.17 is 
R
p . Place
RB
p
 if occupied with a token, specifies a 
control situation when the command is generated to return the robot to the home 
position. Places 
1
M
p
 and 
2
M
p
 stand for the availability of M1 and M2, 
analogously place 
2
c
p
 for the conveyor C2. Condition 
1
1
=
=
f
(or shortly 
1
1 =
f
) 
signals the presence of a workpiece at the input. The control commands are 
associated with places, e.g., the command C1M1:=1 starts the transfer of the 
workpiece from a fixed position at conveyor C1 into machine M1, and the 
command C1M2 into M2. 
12.3  Control Programs in DEDS  
The framework for the DEDS control problems was treated in Chapter 4. After 
control specification, the next step towards writing a control program is choice of a 
suitable tool.  Control programs belong to the reactive kind of programs. The 
programming language for reactive programs can be procedural or graphical. In 
both cases the control system reactivity can be achieved either by a cyclic sampling 
of the system variables or by system interrupts (Zöbel 1987). The former case 
means that the control program should repeat sufficiently rapidly the following 
control scheme: evaluation of the actual system data and successive production of 
the required actions. The latter requires a possibility to program responses to 
system interrupts. Petri nets interpreted for control, Grafcet, and statecharts support 
the creation of control reactive programs responding to external events. 
The so-called real-time programming languages and instruction lists pertain to 
the group of the procedural programming languages for reactive programs. On the 
other hand popular ladder logic diagrams pertain to the group of the graphical 
programming languages for the reactive programs. The borders between system 
control specification tools and programming languages are fuzzy. In fact, the 
control program written using a programming language is the final specification or 
determination of the system control. 
There are many real-time programming languages, e.g., PEARL, Occam, Forth, 
and Ada. A possible real-time programming way is to use a standard programming 
language co-operating with a real-time operating system that completes the real-
time and reactive control functions. There are many combinations of the control 
specification tools and real-time programming languages. In this section, the 
substance of the control synthesis methods using such combinations is illustrated 
on a few chosen cases. 
The real-time programming language PEARL (Werum and Windauer 1989; 
Zöbel 1987) will be treated as a representative of the procedural programming 
languages for reactive programs. PEARL is a multitasking language with all the 
real-time specific features: 
• 
Modularity 
• 
Language elements and constructs for real time 
• 
Processing of external events 

 
DEDS Modeling, Control and Programming 235 
• 
Programming of input/output operations 
• 
Parallel processes 
• 
Process synchronization  
• 
Exceptions  
A program module is delimited with instruction words MODULE <name>; and 
MODEND;. Modules are compiled independently. A module consists of a system 
division and/or problem division introduced by words SYSTEM; and PROBLEM; 
respectively. Data are allowed to be used only when defined. PEARL distinguishes 
local (on the module level) and global (for all modules) data and variables. The 
system division contains description of the system hardware components and their 
mutual connections in the particular configuration. The description has to meet the 
given syntax rules but its actual contents depends on the computer system used and 
the language compiler for the system. 
The problem division contains specification of the input and output data 
stations and interrupt specification referring to the description in the system 
division. Further it contains the declaration of all variables used in the program. 
The specifications are introduced by the keyword SPECIFY or by short SPC. The 
data submitted by a data station can be specified in details with keywords IN, OUT, 
INOUT, ALPHIC, BASIC and others. The following statements provide data from 
the data stations: READ with its counterpart WRITE (for data transfer without 
transformation), GET – PUT (for data transfer with transformation from the 
external alphabetic form into the computer internal binary form), and TAKE – 
SEND (for transfering data with attribute BASIC without transformation). One can 
declare (DECLARE or DCL) all usual types of variables and types necessary for 
the reactive programs with the keywords FLOAT, FIXED, BIT, DURATION, 
CLOCK, CHARACTER, SEMA, STRUCT, etc. 
The subroutines and function are available through the keyword pair 
PROCEDURE – RETURN. They are called using CALL <identifier> 
[list_of_actual_parameters]. The brackets  [ ] denote an option, i.e., a non-
compulsory fraction of the statement.  
PEARL has rich expression facilities like IF – THEN – ELSE – FIN block, 
CASE – ALT – OUT – FIN block, FOR – FROM – BY – TO – REPEAT – END 
block, and many others. PEARL enables one to write highly structured programs 
where transferring data via data stations and data manipulating in the statement 
expressions are possible only if the conform variables are correspondingly 
specified or declared. The reader can find a detailed description e.g., in Werum and 
Windauer (1989), or in Reißenweber (1988). 
The possibility of dealing with interrupts is an important property of the 
reactive programs. The following self-explanatory program example shows how it 
is possible to deal with interrupts in PEARL (keywords are written bold). 
MODULE MOD1; 
SYSTEM; 
ALARM: INT*3; /*INT*3 is the name recognized by the compiler 
in the actual computer systems*/ 
 
. 

236 Modeling and Control of Discrete-event Dynamic Systems 
 
. 
PROBLEM; 
SPECIFY ALARM INTERRUPT 
START: 
TASK PRIORITY 10; 
 
WHEN ALARM ACTIVATE EMERG1; 
 
END; 
 
. 
MODEND; 
The TASK definition is an important property for the program reactivity. Tasks 
specified and started in PEARL represent autonomous processes competing 
mutually for the computer processor.  The following instructions are available to 
define the time or event condition for activating a task, which after its activation 
competes for getting the processor: 
Task definition 
<name>:     
TASK [PRIORITY <priority level>]; 
 
. 
 
. 
 
task statements 
 
. 
 
. 
 
END; 
Task activation or suspension 
[<schedule>] 
ACTIVATE  <name>; 
 
SUSPEND 
[<name>]; 
[<simple schedule>] 
CONTINUE [<name>]; 
 <simple schedule>  
RESUME; 
 
PREVENT 
[<name>]; /*task schedule is suspended*/ 
 
TERMINATE [<name>]; /*task is terminated, schedule  
 
 
remained*/ 
Task control 
 
AT 
<time> 
 
AFTER 
 <duration> 
 
WHEN 
<interrupt> 
 
UNTIL 
<time> 
 
DURING 
<duration> 

 
DEDS Modeling, Control and Programming 237 
The structure of the above-introduced options is graphically illustrated in 
Figure 12.18. 
 
Start by 
statement 
Start by 
interrupt 
yes 
no 
Start delayed? 
Start delayed? 
yes 
no 
AT 
<time> 
AFTER
<time> 
ACTIVATE
<name> 
WHEN 
<name> 
AT 
<time> 
AFTER
<time> 
ACTIVATE
<name> 
Periodic start?
ALL 
<duration>
Ending condition? 
yes 
no 
yes 
no 
Alternative continuation:
Merging point: 
 
Figure12.18. Activation condition for a task 

238 Modeling and Control of Discrete-event Dynamic Systems 
pi1 
z 
z z 
z 
z 
pi2 
pia 
t 
po1
z
z
po2
pob
z
ta 
tb 
tz 
wi1
wi2 
wia 
wo1
wo2
wob
wb=vb 
w1=v1 
w2=v2 
 
Figure 12.19. A Petri net transition activation paradigm 
Consider a Petri net belonging to a class of the Petri nets interpreted for control. 
A method of transforming PEARL program consists in writing an individual task 
for each transition. A general one-transition structure is shown in Figure 12.19.  
The pre-places of transition t are 
ia
i
p
p ,...,
1
, its post-places are 
ob
o
p
p ,...,
1
; L is 
a set of logical conditions for firing t; 
ia
i
w
w ,...,
1
, and 
ob
o
w
w ,...,
1
 are pre-place and 
post-place arc weights, respectively; 
b
w
w
w
,...,
,
2
1
 are vector control variables 
having a level character. For example, in Figure 12.19, the control variables are set 
to 
b
v
v
v
,...,
,
2
1
 whenever the associated place with an assigned variable changes 
marking state from non-marked to marked. The structure around t is transformed 
into the PEARL program part in the following way.  
PROBLEM; 
T: TASK PRIO 16; 
IF MPI1>=WI1 AND MPI2>=WI2 AND… AND MPIA>=WIA 
AND X1==U1 AND X2==U2 AND…  AND XC==UC 
THEN 
MPI1:=MPI1-WI1; 
MPI2:=MPI2-WI2; 
…; 
MPIA:=MPIA-WIA;  
MPO1:=MO1+WO1; 
MPO2:=MPO2+WO2;…, 
MPOB:=MPOB+WOB; 
W1:=V1; W2:=V2; . . ., WB:=VB; 
PREVENT; 
ACT_T:=0; 
IF ACT_TA==0  
THEN 
ALL 
DA 
SEC 
ACTIVATE 
TA; 
ACT_T:=0; ACT_TA:=1;  
FIN; 
IF ACT_TB==0 
THEN 
ALL 
DB 
SEC 
ACTIVATE 
TB; 
ACT_T:=0; ACT_TB:=1; 
FIN; 
 
 . 
 
 . 

 
DEDS Modeling, Control and Programming 239 
IF ACT_TZ==0 
THEN 
ALL 
DZ 
SEC 
ACTIVATE 
TZ; 
ACT_T:=0; 
ACT_TZ:=1; 
FIN; 
 
END; 
Note that the notation of variables complies with the PEARL requirements, and 
therefore, they are written in capitals. Value 1 of the variable ACT_T means that 
the task T corresponding to transition t is active; analogously for transitions 
z
b
a
t
t
t
,...,
,
. These variables help to protect an active transition from being 
activated again. Some PEARL versions do not support this. A task T is deactivated 
by instruction PREVENT <name>. If name is not specified, the instruction refers 
to the task where it is located; otherwise it is applied to the task name. A task T 
ends with END;. Note that it finishes immediately with TERMINATE;, if this 
instruction is used, all its scheduling is cancelled so that it can no longer start. The 
structure of activation of the next transitions can be modified according to the 
possibilities described above. Time intervals DA, DB, ..., and DZ can be equal, 
which is a simpler case. Their values must correspond to the dynamics of the 
system variables. The above program part can be further improved following the 
introduced programming paradigm.We will show the use of the PEARL language 
program based on the Petri net in Example 12.5. 
Example 12.5. The technological layout is given in Figure 12.20. The workpieces 
arrive separately and irregularly into the manufacturing line. A row of workpieces 
stops at the gate Gt being down. The gate is operated down and up by a pneumatic 
cylinder Cl2. A workpiece is pressed down by cylinder Cl1 located on the plate 
between belt conveyors B1 and B2 when there is a sufficient stock of parts at the 
input. The stock of parts is considered sufficient if all four photo-sensors P1 
through P4 are signaling simultaneously a workpiece presence. Thus, the minimum 
number of parts is four. The variables associated with the photo-sensors P1 through 
P4 are denoted as F1 through F4, respectively. In case of a sufficient stock, the gate 
Gt driven by the cylinder Cl2 lifts up and the pair of workpieces moves on 
conveyor B2. When it reaches the inductive sensor IS, a manipulator Sb shifts the 
pair aside onto conveyor B3, which starts moving. When the pair is passing photo-
sensor P5, Gt goes down and the pairing cycle can start again. A collision can 
occur if the manipulator is not in the basic position back when a pair is at sensor P5. 
In such a case motor M2 stops and the pair has to wait until the manipulator comes 
back. Then B2 is started again. The paired workpieces move to the working space 
of the 3-axial Cartesian robot, which picks it up and puts into one of the two 
processing machines or into the buffer to wait. 
Now the system variable table to be put together (Table 12.1) and a Petri net 
interpreted for the control (Figure 12.21) specify the control of the manufacturing 
line. In the Petri net it is strictly assumed that just one transition fires at a time 
point. The meaning of the places and transitions of the Petri net is given in Table 
12.2. It is a binary Petri net model. 

240 Modeling and Control of Discrete-event Dynamic Systems 
Figure 12.20. Manufacturing line for handling workpieces 
Table 12.1. Meaning of the input and output variables for the control unit 
Input variables 
(to the process computer) 
Meaning 
START=1 
Start given by an operating personnel 
STOP=1 
Stop the input and empty the line 
Fi=1 (0) 
A workpiece is (is not) at sensor Pi, 
i=1, 2, …, 6 
ISP=1 (0) 
A workpiece is (is not) at ind. sens. IS 
PF=1 (0) 
Manipulator Sb is (is not) shifted out 
PB=1 (0) 
Manipulator Sb is (is not) in the basic 
position 
Output variables 
(commands from the control 
computer) 
Meaning 
MD1=1 (0) 
The belt conveyor B1 on (off) 
MD2=1 (0) 
The belt conveyor B2 on (off) 
MD3=1 (0) 
The belt conveyor B3 on (off) 
V1=1 and V2=0 and V3=0 
Cylinder Cl1 pushes the break up and 
the gate Gt  down 
V1=0 and V2=1 
Cylinder Cl1 down 
V1=0 and V3=1 
Gate Gt up 
MF=1 (0) 
Manipulator Sb moves forward 
MB=1 (0) 
Manipulator Sb moves back 
Z
X
3-axial robotic system 
F1 
F2 
F3
F4
F5
F6
M
M
M
ISP 
 
IS 
M
Sb 
M
F
E2 
PF 
E1 
PB 
MD1 
MD2 
MD3 
B1 
B2
B3
Cl1
Cl2
V2 
V3 
Cl1 
 
V1 
V2 
St 
A-A 
P1 
P2 
P3
P4
P5
P6
A 
A
B
B
Gt
Cl2 
 
V2 
V3 
B1 
B2
B-B Cl1 
 
V1 
V2 

 
DEDS Modeling, Control and Programming 241 
 
Figure 12.21. Petri net for the manufacturing line 
 
P1 
P2 
P10
P9 
P8 
P11 
P7 
P12
P14 
P13
P6 
P3 
P5 
P4 
P15 
P16 
T1 
T2 
T3 
T4 
T14 
T15 
T6 
T11
T12 
T13
T10
T9 
T8 
T7 
V1,MD1:=1 
MD2,MB:=1 
MD3,MF:=0 
V2,V3:=0 
START 
F1∧F2∧F3∧F4 
V1:=0, V2,V3:=1 
V1:=1, V2,V3:=0 
F4 
F1∧F2∧F3∧F5∧STOP
STOP 
time delay 
all 
drives 
off 
F5 
MD2:=0 
MD2:=1 
ISP 
MF:=1 
MB:=0 
PF 
MF:=0 
MB:=1 
PB 
F6 
MD3:=1 
MD3:=0 

242 Modeling and Control of Discrete-event Dynamic Systems 
Table 12.2. Definition of Petri net places and transitions 
Place 
Meaning 
P1 
Initial state before the operation starts 
P2 
Waiting for the input (workpieces) 
P3 
Command state:  break down, gate up 
P4 
Wait for sufficient workpiece stock or STOP 
P5 
Open the break and close the gate 
P6 
Interstate after a pair is at sensor P5  
P7 
Manipulator was free and a pair moves toward sensor IS 
P8 
Command for the manipulator forward 
P9 
Manipulator backward 
P10 
Start of conveyor B3 
P11 
Conveyor B3 free 
P12 
Manipulator free 
P13 
Stop conveyor B3 because the manipulator is busy 
P14 
Start B3 again 
P15 
After STOP signal time delay during which no new 
workpieces are paired and the line is emptied 
P16 
All drives off 
Transition  
Meaning 
T1 
Transition from the initial state when it was waiting for the 
START signal to the state in which the needed drives are 
set on 
T2 
If there is a sufficient stock of workpieces and P2 is active 
(marked) passage to the state in which the break is pressed 
down and the gate opens 
etc.  
The meaning of the other transitions is evident from the 
place definitions and Figure 12.21. 
A partial control action is associated with the particular place, which is active if 
the place is marked. Some of the transitions introduce additional logical variables 
or functions, which should be true in order to enable the transition firing. It is 
denoted as, e.g., START instead of the full condition START==1 or 
4
3
2
1
F
F
F
F
∧
∧
∧
 instead of the expression  
(
)
(
)
(
)
(
)1
4
1
3
1
2
1
1
=
=
=
=
=
=
=
=
F
AND
F
AND
F
AND
F
.  
An inhibitor coming from place P12 to T11 removes the conflict between T6 
and T11 if P6 is marked. If P12 is marked, T11 is inhibited and only T6 can fire. 
This corresponds to the situation when manipulator Sb is in its basic position. On 
the contrary, if P12 is not marked, T6 cannot fire (token flow rule) but T11 is not 
inhibited and can fire. Then B2 stops because new pair is at F5 but Sb is not back. 
A subtle problem is solved by inhibitor (P6,T3). If there is a gap between 
workpieces of a pair and P3 is marked (indicating that a new pair is on the way) the 
gap produces a false firing of T3 and the control collapses. A time delay introduced 

 
DEDS Modeling, Control and Programming 243 
in the place P15 provides time for waiting until the manufacturing line is empty 
and all drives are switched off (place P16). 
A part of the control program written in PEARL illustrates the method 
described in this section. 
MODULE (MAIN); 
SYSTEM; 
 TERM: CON; 
 DIG_IN_0: DIGE(0)*1*0,15; 
 DIG_OUT_0: DIGA(1)*1*0,15; 
PROBLEM; 
 SPC DIG_IN_0 DATION IN BASIC; 
 SPC DIG_OUT_0 DATION OUT BASIC; 
 SPC DID_IO_INIT ENTRY GLOBAL; 
DCL SCREEN DATION INOUT ALPHIC DIM(2,24,80) 
DIRECT GLOBAL CREATED (TERM); 
DCL VARINP BIT(16) INIT (‘0000’B4); 
DCL (PER1, PER2) DUR INIT (0,0); 
DCL (START, STOP) FIXED INIT (0, 0); 
DCL (F1, F2, F3, F4, F5, F6) FIXED INIT (0, 0, 0, 0, 0, 0); 
DCL (ISP, PF, PB) FIXED INIT (0, 0, 0); 
DCL (MD1, MD2, MD3) FIXED INIT (0, 0, 0); 
DCL (V1, V2, V3) FIXED INIT (0, 0, 0); 
DCL (MF, MB) FIXED INIT (0,0); 
DCL (P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, 
P15, P16) 
FIXED INIT (1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1); 
DCL (ACT_T1, ACT_T2, ACT_T3, ACT_T4, ACT_T5, ACT_T6, 
ACT_T7, ACT_T8, ACT_T9, ACT_T10, ACT_T11, ACT_T12, 
ACT_T13, ACT_T14, ACT_T15) 
FIXED INIT(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); 
DIN: 
PROC RETURNS (BIT(16)); 
DCL WD BIT(16); 
TAKE WD FROM DIG_IN_0; 
RETURN (WD); 
END; 
DOUT:PROC (B FIXED, H FIXED); /*INDEX OF THE BIT IN 
THE OUTPUT WORD FOR MD1 IS 1, 
MD2:2,MD3:3,V1:4,V2:5, 
V3:6,MF:7,MB:8*/ 
IF H==0 
THEN SEND 0 TO DIG_OUT_0 BY CONTROL((B-1), 
(0)); 
ELSE SEND 1 TO DIG_OUT BY CONTROL((B-1),(0)); 
FIN; 
END; 
DINALL: 
TASK PRIO 6; 

244 Modeling and Control of Discrete-event Dynamic Systems 
VARINP:=DIN; 
F1:=VARINP.BIT(16); 
F2:=VARINP.BIT(15); 
F3:=VARINP.BIT(14); 
F4:=VARINP.BIT(13); 
F5:=VARINP.BIT(12); 
F6:=VARINP.BIT(11); 
START:=VARINP.BIT(10); 
STOP:= VARINP.BIT(9); 
ISP:= VARINP.BIT(8); 
PF:= VARINP.BIT(7); 
PB:= VARINP.BIT(6); 
END; 
 STRT:  
TASK PRIO 8; 
CALL DID_IO_INIT; 
ACTIVATE STARTTASK; 
END; 
STARTTASK: TASK PRIO 8; 
OPEN SCREEN; 
PUT 
‘START 
WITH 
START-PUSH-
BUTTON’ 
TO 
SCREEN 
BY 
POS(1,2,2), A; 
ALL PER1 ACTIVATE DINALL; 
ALL PER2 ACTIVATE T1; 
END; 
T1: 
TASK PRIO 7; 
IF P1==1 AND P16==1 AND START==1 
THEN CLOSE SCREEN; 
P1:=0; P16:=0; P2:=1; 
DOUT (4,1); DOUT (5,0); DOUT (6,0); 
DOUT (1,1); DOUT (2,1); DOUT (3,0); DOUT (7,0); DOUT (8,1); 
PREVENT; 
ACT_T1:=0; 
IF ACT_T2==0 
THEN ALL PER2 ACTIVATE T2; 
FIN; 
FIN; 
 END; 
T2: 
TASK PRIO 7; 
 IF P2==1 AND F1==1 AND F2==1 AND F3==1 AND F4==1 
THEN  
P2:=0; P1:=1; P3:=1; 
DOUT(4,0); 
DOUT(5,1); 
DOUT(6,1); 
PREVENT; 
ACT_T2:=0; 
IF ACT_T3==0 

 
DEDS Modeling, Control and Programming 245 
THEN ACT_T3:=1; ALL PER2 ACTIVATE T3; 
FIN; 
IF ACT_T1==0 
THEN ACT_T1:=1; ALL PER2 ACTIVATE T1; 
FIN; 
FIN; 
END; 
T3: TASK PRIO 7; 
IF P3==1 AND P6==0 AND F5==1 
THEN 
P3:=0; P4:=1; P6:=1; 
PREVENT; 
ACT_T3:=0; 
IF ACT_T6==0 
THEN ACT_T6:=1; ALL PER2  ACTIVATE 
T6; 
FIN; 
IF ACT_T11==0 
THEN ACT_T11:=1;  
ALL PER2  ACTIVATE T11; 
FIN; 
IF ACT_T14==0 
THEN ACT_T14:=1; 
ALL  PER2 ACTIVATE T14; 
FIN; 
IF ACT_T4==0 
THEN ACT_T4:=1;  
ALL PER2 ACTIVATE T4; 
FIN; 
FIN; 
END; 
 
. 
 
. 
MODEND; 
Let us make a few remarks about the program. The keywords and syntax signs 
are written in bold and the variables not in bold in order to make the program more 
transparent. DID_IO_INIT is an external procedure containing the driver of the 
input and output modules and their initialization. The task with the label STRT in 
the module MAIN is automatically activated after the program is loaded by the 
system. Other tasks should be activated internally in the program. Instruction 
w.BIT(k) picks out the k-th bit from the bit string word w. 
There are many programming languages that enable to set programs similarly 
as shown above. The instruction lists can be more or less comprehensive but they 
have to enable to interpret the basic real-time or reactive features of a control 
system. 

246 Modeling and Control of Discrete-event Dynamic Systems 
2.4 Ladder Logic Diagrams 
The popular programming technique is based on the so-called ladder diagrams. 
Ladder diagrams are a graphical tool for presenting the instruction set. The 
reactivity of the control program is provided by cyclically repeating the ladder 
rungs from the beginning of the program to its end. Each rung is subordinated to 
the scheme 
CONDITIONS ⇒ ΑCTIONS 
Figure 12.22. One rung of a ladder diagram 
The conditions are given by states and actual events in the controlled system. A 
state is a consequence of its preceding events. The actions are programmed 
interventions of the control system to the controlled one. Figure 12.22 shows a 
generalized rung of a ladder diagram. The conditions are expressed using the 
Boolean logic. 
,
,...,
,
2
1
k
a
a
a
 
,
,...,
,
2
1
lb
b
b
 
,
,...,
,
2
1
m
c
c
c
 
,
,...,
,
2
1
n
d
d
d
 
,
,...,
,
2
1
p
y
y
y
 
rz
z
z
,...,
,
2
1
are Boolean variables. The sense of the logical condition 
at the left-hand part of the rung in Figure 12.22 expressed in the logic form is 
(
) (
) ...
...
...
...
...
2
1
2
1
2
1
2
1
∨
∧
∧
∧
∧
∧
∧
∧
∨
∧
∧
∧
∧
∧
∧
∧
=
n
m
l
k
d
d
d
c
c
c
b
b
b
a
a
a
C
  
 
 
 (12.6) 
where the inversion of 
1b  is denoted as 
1b , etc. A serial arrangement of the 
conditions expresses the logical conjunction of the Boolean variables, the parallel 
 
L
L
L
U
U
U
a1 
a2 
ak
b1
b2
bl
c1 
c2 
cm
d1
d2
dn
y1
y2
yp
z1
z2
zr

 
DEDS Modeling, Control and Programming 247 
arrangement the logical disjunction. Obviously, the diagram in Figure 12.22 is 
based on the properties of the contact relay networks. If condition C or Equation 
(12.6) is true, then the values “logical true” are assigned to all variables 
p
y
y
y
,...,
,
2
1
 and the values “logical false” to all variables 
rz
z
z
,...,
,
2
1
. In this way 
an IF …..THEN…..ELSE is incorporated in the ladder diagram. Letter L means 
that if the whole condition is true the rung circuit is latched, i.e., the associated 
action or control variable is set. Letter U stands for unlatched.  
The ladder logic diagram consists of rungs that are translated into the machine 
instructions of a particular PLC and executed (Hrúz et al. 2000; Mudrončík and 
Zolotová 2000). The possibilities and the form of the ladder diagrams depend on 
the properties of the used PLC and its programming facilities, e.g., an action may 
set some variables and start the counters as well. The condition part of the rungs 
can contain the counter states, which can influence the generation of other actions. 
The ladder diagrams have several drawbacks from the software engineering 
point of view. They are less transparent. Their readability is comparatively difficult 
by other programmers than by the program authors. This is very bulging when such 
a program is put into operation and debugged. Any change or adaptation of the 
ladder diagram program to other control computers is usually difficult. An inter-
stage specification link like Petri nets is therefore useful. In what follows we will 
show the transformation of the Petri nets into the ladder diagrams. 
Consider a binary and safe elementary Petri net given in Figure 12.23. L is the 
set of Boolean conditional expressions for firing transition t; 
s
ry
y
y
+
,...,
,
2
1
 are 
control variables representing the control actions. 
The ladder diagram presentation of the required control function ensuring the 
partial dynamic behavior related to t’s firing is in Figure 12.24. In Figure 12.24 the 
block L is broken down by the corresponding serial and/or parallel structure of the 
contacts in a manner treated earlier. The Petri net marking is represented using the 
variables 
)
(
)2
(
)1
(
2
1
,...,
,
,
,...,
,
s
r
p
r
p
r
p
pr
p
p
v
v
v
v
v
v
+
+
+
 in the ladder diagram. 
p1
p2
pr
t
pr+1
pr+2
pr+s
y1
y2
yr
yr+1,  
ry
y
y
,...,
,
2
1
yr+2
yr+s
L
.
.
.
.
.
.
 
Figure 12.23. An elementary Petri net structure for transformation into a ladder program 

248 Modeling and Control of Discrete-event Dynamic Systems 
L 
L
L
L
U
U
U
L
L
U
vp1 vp2 
vpr 
vp(r+1)
vp(r+2)
vp(r+s)
vp1 
vp2 
vpr 
yr+1 
yr+s 
y1 
U
yr 
 
Figure 12.24. Ladder diagram for the Petri net of Figure 12.23 
Another possible basic Petri net structure is shown in Figure 12.25. As before a 
binary and safe Petri net interpreted for control is assumed. The partial logical 
conditions 
k
L
L
L
,...,
,
2
1
 are such that only one of them is true. Then the diagram in 
Figure 12.26 corresponds to the Petri net in Figure 12.25. The reader can imagine 
how different Petri net structures can be transformed into ladder diagrams. An 
inverse situation to that of Figures  12.25 and 12.26 is depicted in Figures 12.27 
and 12.28. For each transition of the Petri net being transformed into the ladder 
diagram, a rung is constructed under the assumption that in the Petri net there are 
no conflicts, and it is safe and only one transition can fire at a discrete time point. 

 
DEDS Modeling, Control and Programming 249 
 
p0 
.
.
.
p1 
p1 
pk 
t1 
t2 
tk 
L1 
L2 
Lk 
 
Figure 12.25. A Petri net elementary structure 
Figure 12.26. A ladder diagram for the Petri net of Figure 12.25 
Figure 12.27. A Petri net elementary structure 
 
L
v p 0  
L 1  
v p 1  
L
v p 0  
L 2  
v p 2  
L
v p 0  
L k  
v p k  
v p 1  
U
v p 0  
v p 2  
U
v p 0  
.  
.  
.  
v p k  
U
v p 0  
 
p0 
p1 
p2 
pk 
t1 
t2 
tk 
L1 
L2 
Lk 
.
.
.

250 Modeling and Control of Discrete-event Dynamic Systems 
Figure 12.28. A ladder diagram for the Petri net of Figure 12.27 
A non-binary Petri net can also support the ladder diagram programming. In 
such a case an instruction set of the used PLC has to be available. An elementary 
net in Figure 12.29 illustrates the case. The control variables are omitted in the 
example. The corresponding ladder diagram is in Figure 12.30. 
 
p1 
p2 
t 
p3 
2 
3 
3 
 
Figure 12.29. An elementary non-binary Petri net structure 
The elementary structures and their transformation into ladder diagrams 
depicted in Figures 12.22–12.30 serve as paradigms for the transformation 
procedure. They can be used and extended to build up complex ladder diagram 
programs based on the Petri nets specifying DEDS control. 
Example 12.6. Figure 12.31 shows an electro-pneumatic motion drive. It consists 
of three pneumatic pistons, A, B and C, operated by electro-pneumatic two-way 
solenoid valves. The basic position of the pistons is the terminal position on the left. 
Pressure air is fed to the left-hand part of each piston after the activation of the 
valve. The activation signal for A is a+=1, while a–=0, etc., for others. On a+=1, a–
=0 piston A moves to the right. If  a+=0 and a–=1 piston A moves back to the basic 
position on the left. The inductive sensors indicate terminal positions of the
 
L
v p 1  
L 1  
v p 0  
L
v p 2  
L 2  
v p 0  
L
v p k  
L k  
v p 0  
.  
.  
.  
U
v p 0  
L 1  
v p 1  
U
v p 0  
L 2  
v p 2  
U
v p 0  
L k  
v p k  

 
DEDS Modeling, Control and Programming 251 
 
L
x1 
L
2
1 ≥
C
3
1 ≥
C
x2 
x1 
x2 
3
:
3
3
+
= C
C
2
:
1
1
−
= C
C
3
:
2
2
−
= C
C
U
U
x1
x2 
 
Figure 12.30. Ladder diagram for the Petri net of Figure 12.29 
Figure 12.31. Three-piston electro-pneumatic motion system 
A 
B 
C 
a+
a-
b-
b+
c+
c-
a0 
a1 
b0 
b1 
c0 
c1 
PB1 
PB2 
PB3 

252 Modeling and Control of Discrete-event Dynamic Systems 
Figure 12.32. Petri net for the piston motion system 
 
p1 
a+:=1 
a-:=0 
z 
a0==1 
b0==1
c0==1 
pb1==1 
p2 
a1==1 
b+:=1 
b-:=0 
p3 
b1==1
pb3==0 
pb3==1
c+:=1 
c-:=0 
a+:=0
a-:=1 
c1==1 
a0==1 
pb3==0 
pb3==0
pb3==0 
b+:=0 
b-:=1 
c+:=0
c-:=1
time delay 5 sec 
pb3==0 
delay_ expired==1 
b0==1 
c0==1 
pb3==0 
pb2==0 
z 
pb2==1
pb3==0 
pb3==1
pb3==1
pb3==1
pb3==1
pb3==1
a+:=0
a-:=1
b+:=0
b-:=1
c+:=0 
c-:=1 
a0==1 
b0==1 
c0==1 
pb1==1 
pb3==1 
p4 
p5 
p6 
p7 
p8 
p9 
p10
p11 
p12
p13
p14
p15
p16
p17
p18
p19 
p20 
p21 
p22 
p23 

 
DEDS Modeling, Control and Programming 253 
Figure 12.33. Ladder diagram program for the piston system: segments A and B 
U
p1 
a+
U
L
U
a0 
b0 
c0 
pb1 
a-
L
p1 
p2 
p2 
a1 
b+
b-
L
U
L
p2 
p3 
L
p3 
a+
U
U
b1 pb3 
a-
L
p3 
c-
c+
L
U
L
p4 
p5 
(continuation) 
A1 
A2
A1
A2 
U 
p3 
L 
pb3 
p3 
p13 
U 
p4 
L 
c1 pb3 
(continuation) 
p4 
p6 
U 
p5 
L 
a0 pb3
p5 
p7 
U 
p4 
L 
pb3 
p4 
p13 
U 
p5 
L 
pb3 
p5 
p13 
U 
p6 
L 
pb3 
p6 
p13 
U 
p7 
L 
pb3 
p7 
p13 
B1
B2 

254 Modeling and Control of Discrete-event Dynamic Systems 
Figure 12.33. (continued): segments C and D 
U 
U 
p21 
p23 
L 
(continuation) 
p1 
U 
p11
U 
L 
U 
p21
L 
p21 
p2 
p21 p23 pb3
U 
p21
L 
pb3
p21 
p20 
U 
p11
L 
pb3
p11 
p13 
U 
p12
L 
pb3
p12 
p13 
p12
p11 
p12 
p21 
L 
p22 
p23 pb2 pb3
 
U
U
p6 
p7 
L
(continuation) 
p8 
L
p8 
U
dlex pb3 
b-
L
U
U
L
p8 
p9 
U
p9 
L
b0 
p9 
p11 
p6 
p7 pb3 
time delay 
var dlex:=0
b+
c-
c+
p10 
L
U
p10 
L
c0 
p10
p12 
C1 
C2
C1
C2 
D1
D2 
B1 
B2

 
DEDS Modeling, Control and Programming 255 
Figure 12.33. (continued): segments E and F 
E1 
E2
E1
E2 
D1 
D2
U
L
p13
p14
L
(continuation) 
p15
L
U
L
U
p14 
L
a0 
p14
p17
U
p22 
L
pb2
p22
p23
L
p13 
U
a-
L
p16
a+
b-
b+
c-
U
c+
 
U 
p14
L 
a0 
p14 
p17 
U 
p15
L 
b0 
p15 
p18 
U 
p16
L 
c0 
p16 
p19 
U 
p17
U 
p17 
p18 
p18 p19
U 
L 
p19 
p20 
U 
p20
L 
a- 
pb1
U 
L 
p20 
p2 
a+ 

256 Modeling and Control of Discrete-event Dynamic Systems 
pistons. Consider the pistons having to accomplish a sequence of motions defined 
by the following expression: 
 
[A+, B+, (C+, A–), 5 sec, (B–, C–)] 
(12.7) 
where A+ means the motion of the piston A to the right, A– to the left; analogously 
it is for other pistons. Motions in the square brackets are to be executed 
sequentially while those in the round brackets simultaneously or in parallel. The 
value 5 s in Equation (12.7) means that the motion will continue after the 
expiration of a 5-s time delay. a0, a1, b1, etc., are variables representing the piston 
positions, a-, a+, b–, etc., are valve control variables. The sequence is initiated by 
operation of push-button PB1. A regular stop is given by PB2. After pushing PB2 
the actually running cycle is completed and then the pistons stop in their basic 
positions. A new start is initiated again by PB1. The push-button PB3 causes the 
emergency stop; the piston motions are interrupted and the pistons return to their 
basic position on the left.  Petri net for the system is shown in Figure 12.32 and its 
ladder transformation in Figure 12.33. 
Concurrent processes can be graphically specified by reactive flow diagrams 
(Chapter 6). To know their relation to Petri nets may be useful. The relation will be 
demonstrated on an example of the Petri net in Figure 12.34, which is a typical 
structure reflecting concurrent processes. 
The Petri net in Figure 12.34 is interpreted for control; 
...
,
2
1 y
y
 are control 
variables. Their values are set by token arrival. L1, L2, … are logic expressions 
extending the fireability conditions. Figure 12.35 is a reactive flow diagram 
corresponding to the described Petri net. k1, k2, … are auxiliary internal variables 
determining the system states in the diagram, 
t
Δ  is a time interval for a periodic 
execution of individual flow diagram blocks. 
p2 
p3 
p1 
t1 
p4 
p5 
t2 
t3 
t4 
y1=d1
L1 
L2 
L3 
L4 
• 
y2=d2
y3=d3
y4=d4
y5=d5
 
Figure 12.34. A Petri net with concurrent events 
12.5 Problems and Exercises 
12.1. Exercise 6.2 deals with a manufacturing cell using two robots. Derive a Petri 
net interpreted for control specifying the required function of the system. On the 
basis of the Petri net model, write a program in the form of the ladder logic 
diagram for the system control. For the comparison of the programming technique, 
write a part of the program in a real-time programming language, e.g., in the 
language PEARL or in some other language you know. 

 
DEDS Modeling, Control and Programming 257 
k1:=1, k2:=0, k3:=0, k4:=0, k5:=0,
y1:=d1
Y
L1==true
k1==1
N
k1:=0, k2=1, k3=1
    y2:=d2, y3:= d3
k2==1
N
L2==true
Y
Y
Y
N
N
N
Y
t
Δ exp.
    k2:=0, k4=1
          y4:=d4
Start
            
 
k4==1
N
L4==true
Y
Y
N
 k4:=0,k5:=0,k1=1
          y1:=d1  
k3==1
N
L3==true
Y
Y
N
    k3:=0, k5=1 
          y5:=d4  
k5==1
N
Y
 
 
Figure 12.35. Reactive flow diagram corresponding to the Petri net in Figure 12.34 
12.2. Consider a four-piston electro-pneumatic move system. Complete necessary 
sensors for the system control purpose. Let the pistons perform repeatedly the 
following cycle of movements: 
 
 [A+, B+, (C+, D+, A-), 5 sec. interval, (B-, C-, D-)] 

258 Modeling and Control of Discrete-event Dynamic Systems 
Consider one push button for the start of the move execution and another for the 
emergency stop of the execution. For the control specification, use Grafcet. With 
the help of Grafcet, write the ladder logic diagram realizing the move control. 
12.3. A robotic cell for the PCB assembly is depicted in Figure 11.8. Write the 
control program in the form of a ladder logic diagram. 
 
12.4. Workpieces are fed by conveyors C1 and C2 in a sorter as shown in Figure 
12.36. Each workpiece is stopped at photosensor P1 and inspected by the vision 
system VS, which determines which box the workpiece is to be thrown out by a 
manipulator. 
a. 
Construct a Petri net describing the required function of the sorter. 
Hint: use a shift register for storing the box number where the 
inspected workpiece should be placed. The number is shifted in the 
register or deleted on signals from photocells. Analyze the time 
relations, for instance, C1 is started again only after signal from P1 
etc., is received. 
b. 
Construct a Petri net interpreted for control of the sorter. 
c. 
Create a Grafcet specifying the sorter control. 
d. 
Write the control program in the form of the ladder logic diagram. 
e. 
Write the control program using a real-time programming language. 
 
Figure 12.36. Workpiece sorter with four manipulators 
12.5. A train loaded with containers is to be unloaded as shown in Figure 12.37. Its 
containers are to be moved on to the second empty train. The trains are under two 
automatic portal cranes operating on the same rails. The transferring scheme is 
given from the coordination control level.  
a. 
Express the collision-free movements of the cranes by means of a 
Petri net. Hint: create for each crane a partial Petri net where the 
marking of one place represents the number of free crane positions to 
the left of the crane and the marking of another place serves similarly 
for the free positions to the right of the crane. For positions between 
the cranes the two places merge in one place. For readers interested 
in more details of this exercise we recommend the book of Abel 
(1990) and references for Chapters 7–9. 
b. 
Outline how you could utilize the created Petri net for the control of 
the crane operation. 
C1 
B1
B2
B3
B4
C2
P0
P1
P2
P3
P4
VS 
M1
M2
M3
M4

 
DEDS Modeling, Control and Programming 259 
CRANE 1
CRANE 2
TRAIN 1 
TRAIN 2 
c. 
Analyze the properties of the Petri net. How can the number of the 
crane movements for a given reloading scheme be optimized? Note 
that it is possible to consider genetic algorithms for that optimization 
purpose 
Figure 12.37. Train reloading station 
 
 

13 
Supervisory Control 
13.1  Basic Notion 
The basic notion of discrete event dynamic systems (DEDS) was introduced in 
Chapter 1. Finite automata and Petri nets have been studied as powerful models of 
DEDS for their behavior modeling and control. It has been shown that the states 
and transitions are key features of both models. 
Consider an event-driven system being in its initial state. The complete 
behavior of the system is given by all possible event strings beginning in the initial 
state. The event strings are formally described by Equations (1.11) and (1.12). 
Such a system description is the core of a DEDS model proposed by Wonham and 
Ramadge (1987) and Ramadge and Wonham (1989) in the form 
 
(
)
K
L
S
,
,
,
*
Σ
Σ
=
 
(13.1) 
where Σ is a finite non-empty set of events, 
*
Σ  is the set of all sequences (strings) 
that can be generated from the elements of Σ  and the empty sequence ε~ , 
*
Σ
⊆
L
 
is a formal language comprising all event sequences realizable in the underlying 
real system, and 
L
K ⊂
 is a sub-language of L, where K specifies the required 
behavior of the system.  
The assumption for the model at Equation (13.1) has been adopted that only 
one event can occur at a discrete time point. The model at Equation (13.1) 
describes the behavior of a system in terms of the event strings; but considers no 
system states. It represents a different approach as usually the state machine 
models do. 
In DEDS two types of the control can be distinguished, namely process control 
and supervisory control. The considerations developed in Chapters 1 and 4 will be 
used to characterize these two types. Equation (4.10) determines a control action, 
which is a function of states and the states depend on the event string starting in a 
system state and developing from the first event up to the (
)1
−
v
-st event at the 
(
)1
−
v
-st discrete time point. At the time point 
1
−
v
a
τ
 the system reaches the state 

262 Modeling and Control of Discrete-event Dynamic Systems 
when function f in Equation (4.10) determines the value of the control 
variable
(
)
τ
τ
Δ
+
−1
v
a
w
. In the overall system SYST in Figure 4.1, setting w  is 
considered as a new state. In system S (considering refined structure 
decomposition), (
)
τ
τ
Δ
+
−1
va
w
 represents an input activity effecting the behavior of 
system S.  We can see that it is a system point of view.  
In the case when for each k=1,2,…,v-2,  
 
(
)
(
)
(
)
1
1
,
+
+
<
Δ
+
Δ
+
=
k
k
k
k
k
k
a
a
a
a
a
a
τ
τ
τ
τ
τ
τ
w
pcontr
s
 
(13.2) 
where pcontr is a vector function, we speak about the process control. In the case 
when 
(
)
k
k
a
a
τ
τ
Δ
+
w
 only delimits possible states and the particular next state 
depends on the next event in S, we speak about the supervisory control. The range 
of the possibilities is a matter of system autonomy. The function of the supervisory 
control is to keep the system within some subsets of the state set Q. It means that  
 
{
}
(
)
(
)
k
k
k
a
a
a
in
states
admissible
of
set
τ
τ
τ
Δ
+
=
+
w
supvis
1
. 
From the point of view of the model at Equation (13.1), S is to be ruled so that 
only strings of sub-language K occur in it. 
There are two kinds of requirements to be laid on an event-driven system. The 
first is characterized by defining prohibited states. The second is characterized by 
requirements to preserve some event strings without violating the state prohibition.  
A required system behavior cannot be achieved if a controllable agent does not 
exist in the system. A subset 
Σ
⊆
Σc
 of controllable events serves for that. A 
controllable event can be allowed or prohibited by a control system. This is not 
possible with the uncontrollable events of set 
Σ
⊆
Σu
. Together we have  
 
∅
=
Σ
∩
Σ
Σ
∪
Σ
=
Σ
u
c
u
c
,
 
(13.3) 
The supervisory control keeps the system within limits, enabling only event 
strings of language K to occur. It means that the range of the system autonomy or 
freedom is adjusted by the supervisory control via the controllable events. When 
∅
≠
Σ u
, the interventions into the controlled system have to anticipate possible 
occurrence of uncontrollable events that could violate the behavior limits given by 
the sub-language K. 
13.2 System Controllability 
Assume the system to be specified by Equations (13.1) and (13.3) and the required 
behavior by language
L
K ⊂
. Another possible way, in this context, to express the 
restriction on the event strings is the prohibition of certain states and preservation 

 
Supervisory Control 263 
of certain event strings as always possible. This will be explained by using 
examples.  
The behavior restriction determined by states and event strings may not always 
be easy to transform into language K or vice versa. An important question 
concerning K is whether the language can be secured by the supervisory control. It 
is known as the question of the DEDS controllability.  
A common feature of real systems is the existence of an initial state. Any 
activity of a real system starts in this state. Suppose that an event string 
ki
i
i
e
e
e
...
~
2
1
=
σ
 has been realized starting from the initial state. Obviously, all 
partial event strings are also realized in the system, namely 
 
1
2
1
3
2
1
2
1
1
...
~
,...
,
~
,
~
,
~
1
3
2
1
−
=
=
=
=
−
ki
i
i
k
i
i
i
i
i
i
e
e
e
e
e
e
e
e
e
σ
σ
σ
σ
 
(13.4) 
Such strings are related to the prefix languages. A string u~  is a prefix of a 
string 
*
~
Σ
∈
v
 if 
w
u
v
~
~
~ =
 and 
*
~
Σ
∈
w
. It follows that w~  can be the empty string 
denoted ε~ , i.e., 
ε~
~ =
w
; thus a word v~  is a prefix to itself. If v~  is an event string 
in a real system, then all its prefixes have to occur in the system. 
 
The prefix language L of language 
*
Σ
∈
L
 is 
 
{
}
*
~
,
~
~
~
Σ
∈
∈
=
w
L
w
u
u
L
 
(13.5) 
From Equation (13.5) we have  
 
L
L ⊆
 
(13.6) 
i.e., all strings of L pass over in language L  because w~ can be ε~. 
If language L describes a real system, then L should contain all its prefixes, i.e., 
 
L
L ⊆
 
(13.7) 
From Equations (13.6) and (13.7), a language L describing the real system must 
meet the condition 
 
L
L =
 
(13.8) 
A language with the property at Equation (13.8) is called a prefix closed language. 
Example 13.1. Consider a language L over the event set 
{
}
β
α,
=
Σ
 containing the 
empty string ε~  and strings beginning with α  or β  whereby in each string α  
and β  alternate. The language has the following strings: 

264 Modeling and Control of Discrete-event Dynamic Systems 
 
{
}
....
,
,
,
,
,
,
,
~
βαβ
αβα
βα
αβ
β
α
ε
=
L
 
Obviously, the prefix language L  of L is the same as L: 
 
{
}
....
,
,
,
,
,
,
,
~
βαβ
αβα
βα
αβ
β
α
ε
=
L
 
such that  
 
L
L =
 
The conclusion is that L is a prefix closed language. 
Example 13.2. Let a language L describe the events of a palette buffer with a 
capacity equal to three palettes. The empty buffer represents the initial state. The 
event set is 
{
}
ψ
ω,
=
Σ
, where ω  means one palette insertion and ψ one palette 
pick-up from the buffer. The events occur irregularly and asynchronously. The 
number of insertions ins  has to be always greater or at least equal to the number 
of the pick-ups pck  
 
pck
ins ≥
 
The set of strings of L is 
 
{
}
...
,
,
,
,
,
,
,
,
,
,
~
ωωωψ
ωψω
ωωψω
ωωψψ
ωωψ
ωψ
ωωω
ωω
ω
ε
=
L
 
Thus it is a prefix closed language. 
Properties of prefix formal languages can be used to check the supervisory 
controllability of systems. A language K is said to be controllable with respect to a 
language L iff 
 
K
L
K
u
⊆
∩
Σ
, by assumption 
∅
≠
Σu
 
(13.9) 
where 
u
K Σ  is the set of all strings w~
~ν
given by the concatenation of all strings 
K
v ∈
~
 and all strings consisting of one uncontrollable event, i.e., 
u
w
Σ
∈
~
. 
The controllability property at Equation (13.9) is induced by the fact that for an 
event string 
ki
i
i
k
e
e
e
...
~
2
1
=
σ
starting in the initial state, the system goes through all 
prefixes of 
k
σ~ . Formally stated it means that in the system the following event 
strings have been realized: 
 
1
2
1
2
2
1
1
2
1
1
2
2
1
~
,
~
,
~
,
~
i
i
i
i
i
i
k
i
i
i
k
e
e
e
e
e
e
e
e
e
k
k
=
=
=
=
−
−
−
−
σ
σ
σ
σ
K
K
K
 (13.10) 

 
Supervisory Control 265 
First, Equation (13.9) means that the considered strings are limited to be from 
the realizable language L and therefore there is the set intersection operation 
L
∩
 
in Equation (13.9). Second, the strings realizable in a system S and belonging to 
language K as well as all prefixes of these strings (which altogether are strings of 
language K ) with a supplemented uncontrollable event should still be the strings of 
K . The reason for that is that no control can prevent an uncontrollable event to 
occur. Note that there is nothing said about the closure property of K. Generally 
speaking, K can be controllable with respect to L without property
K
K =
. In other 
words, there can be strings of K  not belonging to K (it is not the case in languages 
based on real systems). For those strings the condition at Equation 13.9 has to hold, 
too. Such considerations are rather theoretical and we concentrate in Section 13.3 
later on the case of the prefix-closed languages K. 
For controllability by definition the following proposition holds: K is 
controllable if and only if K  is controllable. It is understandable because 
K
K =
.  
Controllable events are used to keep the system within K. However, 
uncontrollable events represent a frequent and serious problem in supervisory 
control. 
A natural question is how to resolve the situation when K is not controllable. 
First consider a more general case without condition
K
K =
.  In such a situation 
we seek a language closest to K, which is controllable and prefix closed just 
following the property of DEDS. Such a language is called the supremal 
controllable sublanguage to K and is defined as 
 
( )
{
}
L
J
K
J
J
K
C
 
respect to
 with 
le
controllab
 
is
and
:
sup
⊆
∪
=
 
(13.11) 
Here the symbol “ ∪” denotes the set union of all controllable languages J or more 
strictly the set union of all their strings. Then obviously J satisfies 
 
J
L
J
u
⊆
∩
Σ
 
(13.12) 
The fixpoint characterization of 
( )
K
C
sup
 underlies the theoretical reasoning 
that makes for the supervisory control resolution. We explain it below. 
Let Λ  be the set of all languages over the event set 
u
c
Σ
∪
Σ
=
Σ
 and let Ω  be 
an operator 
 
:
Ω  
Λ
→
Λ
  
(13.13)  
such that for some given languages, M, 
Λ
∈
L
  and 
L
K ⊂
 
 
(
)
{
}
M
L
T
T
T
T
T
K
M
u
⊆
∩
Σ
=
Σ
⊆
∩
=
Ω
∗
,
,
:
supremum
 
(13.14) 
Over the event set Σ , operator 
(
)
M
Ω
 transforms a language M to another one with 
respect to the given languages L and K. The obtained language is derived from the 

266 Modeling and Control of Discrete-event Dynamic Systems 
supremum of the languages (in the sense of the number of strings of languages T) 
that are prefix-closed and all its strings (including prefixes of T delimited by K ) 
with a supplemented event of 
u
Σ  are realizable (the strings are included in L) and 
contained in M , as well as in K.  
Wonham and Ramadge proved (1987) the following proposition. 
Proposition 13.1. Given languages L, K and operator 
(
)
M
Ω
 over the event set 
u
c
Σ
∪
Σ
=
Σ
by Equation (13.14). Denote
( )
K
C
S
sup
=
. Then  
 
( )
S
S
Ω
=
 
(13.15) 
and for every M such that 
(
)
M
M
Ω
=
: 
 
S
M ⊆
 
(13.16) 
 
Obviously, the operator Ω  is purposely chosen. It includes an important 
property for the controllability, namely, 
T
T =
. In looking for a supremal 
controllable language for a given language K with respect to L , it considers just 
prefix-closed languages. 
According to Proposition 13.1 
( )
K
C
sup
 is the fixpoint of operator Ω  and any 
fixpoint of Ω , i.e., 
(
)
M
M
Ω
=
 is a sublanguage of S from Equation (13.16). V 
(13.16) valid for 
(
)
M
M
Ω
=
 supports the idea of using a limit process to find 
( )
K
C
sup
. The authors of the above-mentioned paper have proved that an iteration 
process as follows: 
 
K
M
=
0
 
(13.17) 
 
(
)
0
1
M
M
Ω
=
 
(13.18) 
 
(
)
1
2
M
M
Ω
=
 
(13.19) 
 
M  
 
(
)
1
−
Ω
=
j
j
M
M
 
(13.20) 
converges to S in the sense that 
 
LIM
j
j
M
M
=
∞
→
lim
 
(13.21) 
exists and  
 
LIM
M
S ⊆
 
(13.22) 
If languages L and K in Equation (13.14) are regular then, in addition, 

 
Supervisory Control 267 
 
LIM
LIM
M
S
M
S
=
⇒
⊇
 
(13.23) 
 In what follows we confine ourselves to the regular languages and their 
controllability as an important case with respect to the real systems encountered in 
practice. 
A task of the following example is used to elucidate the above mentioned 
concepts. 
Example 13.3. A production layout is depicted in Figure 13.1. It consists of the 
cells A1 and A2 located on the plant’s first floor, the connecting area A3, and the 
cells B0 up to B4 on the second floor. Two mobile robots are moving in the layout 
performing various transport and production tasks. We are going to study the 
behavior of the robots in the described production system using a formal language 
approach. Our considerations are restricted on robot R1. The case for R2 is similar. 
We need to define the event set: it is the set of controllable and uncontrollable 
transfers between cells including transfers between cells and the platform A3, as 
well. They are listed in Table 13.1 where, for example, A1A3c means a 
controllable event that a robot at room A1 enters A3; and A1A2u means an 
uncontrollable event that a robot at room A1 enters A2. 
 
1 st floor 
2 nd floor 
A 3 
A 3 
A 3 
B 1 
B 0 
B 2 
B 3
B 4
A 1 
A 2 
C ontrollable events 
U ncontrollable events 
L  
K  
M  
 
Figure 13.1. Illustration of the relation between languages L, K, and M 

268 Modeling and Control of Discrete-event Dynamic Systems 
Table 13.1. Controllable and uncontrollable events for the layout in Figure 13.1 
Controllable events 
A1A3c, A3A1c, B1B3c, B3B1c, B1B0c, B0B1c, B3B4c, B4B3c, B0B2c, B2B0c, B0B4c, 
B4B0c 
Uncontrollable events 
A1A2u, A2A1u, A2A3u, A3A2u, A3B1u, B1A3u, A3B2u, B2A3u, A1B3u, B3A1u 
 
 
All formal languages considered in this example for the system description are 
given by the strings generated from the position of robot R1 in cell B0. If the robot 
returns to B0, the string is assumed to be finished. The next movements represent 
new strings. Clearly, all considered languages are prefix closed ones.  
The set Λ  of languages over the event set 
u
c
Σ
∪
Σ
=
Σ
 specified in Table 13.1 
is defined according to Equation (13.14). Let language L correspond to all possible 
movements of robot R1 in the layout of Figure 13.1 from the initial position as 
stated before. The movements and transfer strings occur within the dashed line area 
in Figure 13.1. Let a language 
L
K ⊂
 be given corresponding to the solid line area 
encompassing the movements of this language and a language M corresponding to 
the dashed and dotted line area. One can see that language K is not controllable 
because an uncontrollable event cannot be prevented for example after the string 
B0B1c, B1B3c, B3A1u, and A1A2u, which belongs obviously to K but the string 
B0B1c, B1B3c, B3A1u, A1A2u, A2A3u not. Hence one has to look for the supremal 
controllable sublanguage 
( )
K
C
S
sup
=
. 
Consider, for example, a language M for the application of operator Ω  as 
given in Equation (13.14). The language T from Equation (13.14) consists of 
strings from M, which do not contain events B0B1c and B3B1c because the 
uncontrollable event B1A3u leads a string not belonging to M. Equation (13.14) 
determines an operator on a set of languages respecting two given languages K and 
L where
L
K ⊂
. 
Conjunction with K in Equation (13.14) means deleting all strings from T 
containing event A2A3u. After the deletion, we get the language 
(
)
M
Ω
. T obtained 
as described obviously, which is supremal.  
The iteration process in Equations (13.17) to (13.20) can be illustrated as 
follows. Iteration starts with K. The first step yields language T ′ . It is a language T 
without strings containing A1A2u because after that event A2A3u could occur 
giving strings not present in K. On the other hand, in T ′  strings with B3A1u can 
exist according to the first application of Ω . The second iteration step, i.e., the 
second application of Ω  requires to delete strings with B3A1u from T ′  because 
A1A2u coming after B3A1u causes an exit from T ′  (
( )
K
T
Ω
=
′
) and this deletion 
gives 
( )
T
T
′
Ω
=
′′
. T ′′  is then the supremal controllable sublanguage for K 
according to the assumptions of this example. 

 
Supervisory Control 269 
13.3  Supervisory Control Solution Based on Finite Automata 
Regular languages play a decisive role in practical applications of the supervisory 
control. As treated in Chapter 5 every regular language corresponds to a finite 
automaton, called the generator in this context. In other words, every finite 
automaton 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 generates a regular language L and a regular 
marked language 
m
L  (see Definition 5.2).  
Proposition 13.2. A language generator generates languages L  for which 
L
L =
. 
Proof. The proof follows directly from the definitions of the language generator 
and the prefix closure property. 
A language 
m
L  may not be the prefix-closed language.  
As mentioned in Section 5.1, a simple labeled directed mathematical graph 
corresponds one-to-one to a language generator 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
. 
For a finite automaton A, the accessible set 
ac
Q
 is 
 
(
)
{
}
*
0
~
  
some
for 
~
,
q
ˆ
and
:
Σ
∈
=
∈
=
η
η
δ
q
Q
q
q
Qac
 
(13.24) 
and the co-accessible set is 
 
(
)
{
}
*
~
  
some
for 
~
q,
ˆ
and
:
Σ
∈
∈
∈
=
η
η
δ
F
Q
q
q
co
Q
 
(13.25) 
A finite automaton A is said to be accessible if 
Q
Qac =
, and co-accessible if 
Q
Qco =
. It is said to be the trim iff  
 
Q
Q
Q
co
ac
=
=
 
(13.26) 
A marked language has the following property for a trim. 
Proposition 13.3. Let a generator of a formal language L and a marked formal 
language 
m
L  be a trim. Then 
 
m
L
L =
 
(13.27) 
Proof. First, 
L
Lm ⊆
 and each string of 
m
L
 belongs to L according to the 
generation rules for L and 
m
L , that is 
L
Lm ⊆
. But second also 
m
L
L ⊆
 because 
each string of L belongs to 
m
L
 as each string of L can be prolonged to reach a state 
of F (the trim property). 
L
Lm ⊆
 and 
m
L
L ⊆
 results in Equation (13.27). 

270 Modeling and Control of Discrete-event Dynamic Systems 
The trim property means that some required system states (set F) can be 
reached from each state. It is useful to use the trim property under the supervisory 
control solution when it is required to preserve the system state reachability. This is 
contained in the following proposition. 
Now consider a question: what does it mean when a generator of a formal 
language is accessible but not co-accessible? It means that there are states, or at 
least one state, from which it is not possible to reach the set F. We say that such a 
generator or finite automaton is blocking. Obviously, it is not a trim. It yields that 
such strings, from which F cannot be reached, are not contained in 
m
L
 and, 
therefore, Equation (13.27) is not valid, i.e., 
m
L
L ≠
. As far as all strings of 
m
L
 
belongs to L, it yields 
L
Lm ⊂
.  The last expression is a necessary and sufficient 
condition a finite automaton to be blocking. The states from which the set F cannot 
be reached are: 
a. States, from which no transition to another state exists, the so-called 
deadlocks 
b. States, from which transitions to another states exist (but no path to F), 
forming the so-called livelocks 
Figure 13.2 illustrates the blocking property. The generator (finite automaton) 
depicted in Figure 13.2 is accessible and not co-accessible. The states 
F
q
q
∈
4
3,
 
are not reachable from 
5
q  and 
5
q , which are forming a livelock, and 
7
q  is a 
deadlock. 
By the supervisory control solution it is often a task to find 
( )
K
C
sup
 and its 
corresponding generator to be not blocking. It is meant to find such a supremal 
sublanguage for K, which is a trim. 
Prior to formulating the proposition, consider A that is not a trim. Then the trim 
component 
( )
A
Tr
 of the automaton 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 is a finite automaton given 
by 
 
( ) (
)
tr
tr
tr
Q
F
q
Q
A
Tr
∩
Σ
=
,
,
,
,
0 δ
 
(13.28) 
where 
∅
≠
tr
Q
, 
δ
δ
=
∩
=
tr
co
ac
tr
Q
Q
Q
,
for set 
tr
Q
Σ ×
; and 
tr
δ
is a partial 
function with respect to set  
.
Q
Σ ×
 
 

 
Supervisory Control 271 
             Figure 13.2. An accessible and not co-accessible finite automaton 
Proposition 13.4. Let 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 and 
(
)
j
j
j
j
j
H
p
P
B
,
,
,
,
0 ξ
Σ
=
 be trim 
finite automata. The automaton A generates the formal language L and the marked 
formal language 
m
L  that is denoted as A  indicating the relation with automaton 
A . Let automaton 
j
B  generate the marked language 
A
B
J
j
j
⊂
=
; further let 
the mathematical graph corresponding to 
j
B  be a proper subdigraph of the 
mathematical graph corresponding to A such that 
j
p0  corresponds to 
0
q . It means 
that the subdigraph includes the initial state, which corresponds to 
0
q . The event 
sets in both automata are the same and consist of the controllable and 
uncontrollable events: 
∅
=
Σ
∩
Σ
Σ
∪
Σ
=
Σ
u
c
u
c
,
. Then there exists the unique 
function 
 
Q
P
h
j
j
→
:
 
(13.29)  
satisfying the following equality: 
 
   
(
)
[
]
(
)
ρ
δ
ρ
ξ
~
,
ˆ
~
,
ˆ
0
0
q
p
h
j
j
j
=
 
(13.30) 
for each string 
 
   
j
B
∈
ρ~
 
(13.31) 
0
q
 
1q
 
3
q
 
4
q
 
2
q
 
5
q
 
6
q
 
7
q
 

272 Modeling and Control of Discrete-event Dynamic Systems 
where 
j
B
 is the prefix language of language 
j
B
. 
Proof. Equations (13.29) and (13.30) follows directly from the fact that the graph 
of 
j
B  is a proper mathematical subdigraph of the graph of automaton A. The state 
node set of the graph of 
j
B  is a proper subset of the set of the state nodes of the 
graph of A. The unique mapping according to Equation (13.29) exists for this 
subset. The end node of any path in the graph of 
j
B  is mapped into the node of A, 
i.e., Equation (13.30); and there is always a path in A ending in that node. As a 
matter of fact A covers 
j
B .  
Recall from Chapter 5 that the automaton A generates the formal language L 
and the marked formal language 
A
Lm =
 representing all realizable event strings 
ending in the states of set F. We can imagine such event strings as those 
corresponding to all feasible finished jobs in the real system considered. Obviously, 
j
B
 has a sense if 
j
H  is not empty. 
Proposition 13.5. Let 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 and 
(
)
j
j
j
j
j
H
p
P
B
,
,
,
,
0
ξ
Σ
=
 be trim 
automata as assumed in Proposition 13.4. The operator Ω  for given languages 
m
L and 
m
L
J ⊂
0
(
m
L  and 
0
J  stands for L and K, respectively, in Equation (13.14)) 
is determined by the transformation of automaton 
j
B  to 
1
+
j
B
described in details 
below. Ω  is such that 
1
+
j
B
 is a trim automaton. The transformation gives the 
searched supremum of controllable language T. The supremum is generated by the 
trim automaton resulting from the transformation. Define the transformation such 
that it goes through an intermediate automaton 
j
B′ , i.e., 
j
B  is transformed to
j
B′  
and then 
j
B′  to 
1
+
j
B
. The automata generate the following languages 
,
'
'
,
j
j
j
j
B
J
B
J
=
=
 
1
1
+
+ =
j
j
B
J
. 
Thus, 
(
)
j
j
J
J
Ω
=
+1
 where 
(
)
{
}
j
m
u
j
J
L
T
T
T
T
T
J
J
⊆
∩
Σ
=
Σ
⊆
∩
=
Ω
,
,
:
sup
*
0
. An iteration process for i=0, 
1, 2, … has been anticipated as shown below. For all subsequent iterations of the 
iteration process the following setting 
0
0
B
J
K
=
=
 is taken as language K in 
Equation (13.14). The automata transformation realizing Ω  is a reduction, which 
is carried out in two steps: 
1. The states of automaton 
j
B  are mapped by a partial injection mapping 
(one-to-one mapping) to the states of automaton 
j
B′ . Such states are 
mapped, which fulfil the conditions described below. The partial mapping 
is 
a 
subset 
of 
the 
one-to-one 
correspondences 
j
j
p
p
,0
,0
′
↔
, 
j
j
p
p
,1
,1
′
↔
, …., etc., where 
,
,...
,
,1
,0
j
j
j
P
p
p
∈
 
j
j
j
P
p
p
′
∈
′
′
,...
,
,1
,0
. A string 
η~  satisfies 

 
Supervisory Control 273 
 
(
)
j
j
k
j
j
P
p
J
J
′
∈
′
Ω
=
∈
+
,
1
  
and
  
~η
                             
(13.32) 
if and only if 
j
J
∈
η~
 and for each prefix π~  of η~  holds 
    
      
(
)
(
)
(
)
(
)
j
k
u
j
k
j
j
j
j
k
p
p
h
p
p
,
,
,0
,
~
,
ˆ
′
Σ
⊆
Σ
∩
′
′
Σ
⇒
′
′
=
′
π
ξ
 
(13.33)          
where (
)
j
k
p ,′
Σ
 denotes a subset of Σ  for which the partial function 
′
j
ξ
  is 
defined in state 
j
k
p ,′
. Similarly it is for 
(
)
(
)
j
k
j p
h
,′
′
Σ
 and function δ . 
Proposition 13.4 holds for function 
jh′ . The states not satisfying Equation 
(13.33) are cancelled from set 
jP′  and function 
′
j
ξ
 is adjusted 
correspondingly to the state cancellation.  In the graphical representation 
the arcs connected to the cancelled state nodes are removed, as well. If 
j
p ,0′  is not cancelled and 
∅
≠
′j
H
then the automaton 
 
   
⎟⎠
⎞
⎜⎝
⎛
′
′
′
′
Σ
=
′
j
j
j
j
j
H
p
P
B
,
,
,
,
,0
ξ
 
(13.34)  
is obtained; and otherwise it is not defined.  
2. If 
j
B′  is defined, then the trim component of 
j
B′  is constructed as follows: 
 
(
)
(
)
⎟⎠
⎞
⎜⎝
⎛
⎟⎠
⎞
⎜⎝
⎛
′
′
′
′
Σ
=
′
=
Σ
=
+
+
+
+
+
j
j
j
j
j
j
j
j
j
j
H
p
P
Tr
B
Tr
H
p
P
B
,
,
,
,
,
,
,
,
,0
1
1
1
,0
1
1
ξ
ξ
  
 (13.35) 
where the partial injection mapping of the states from set 
jP′  is given as 
before. The mapping yields a subset of correspondences 
1
,0
,0
+
↔
′
j
j
p
p
, 
1
,1
,1
+
↔
′
j
j
p
p
, ….  where 
j
j
j
P
p
p
′
∈
′
′
,...
,
,1
,0
, 
1
1
,1
1
,0
,...
,
+
+
+
∈
j
j
j
P
p
p
. Here, 
some of the correspondences do not exist because of the reduction of the 
states of 
j
B′  in order for 
1
+
j
B
 to be a trim automaton. 
1
+
j
B
 is defined if the 
correspondence for the initial states 
1
,0
,0
+
↔
′
j
j
p
p
 is preserved on the way 
to obtain the trim; otherwise 
1
+
j
B
 is not defined. 
1
+
j
B
 generates language 
(
)
j
j
J
J
Ω
=
+1
 and the graph of 
1
+
j
B
 is a proper mathematical subgraph of 
j
B . 
Proof. This proposition concerns the controllability. The operator (
)
j
J
Ω
 provides 
supremum of the prefix closed languages, which fulfils the condition 
(
)
j
m
u
J
L
T
⊆
∩
Σ
. Parameters of the operator are languages 
m
L  and 
m
L
J ⊆
0
 (in 

274 Modeling and Control of Discrete-event Dynamic Systems 
comparison with Equation (13.14)). The concatenation of any uncontrollable event 
to the strings of T does not break the membership of the strings in 
j
J . The 
conjunction 
m
L
∩
 in the condition ensures the restriction of strings only to the 
strings of language A . The supremal language T is obtained by meeting the 
condition at Equation (13.33). It cancels those states in which uncontrollable 
events may occur and realize prohibited strings. It is the first step towards creating 
operator Ω  and possible canceling of some states; the next step in completing 
operator Ω  is to create the trim automaton. The creation of the trim automaton is 
substantiated because the set of strings is limited to the strings of 
0
J . Namely, this 
limitation can spoil the trim property. Strings, which do not end in the states of 
j
H ′ , 
are to be removed. Possibly some additional states are to be cancelled next along 
with their related arcs, as well. The iterative application of Ω  gives the supremal 
controllable sublanguage. It is based on Proposition 13.1 and the fact that all 
languages generated by finite automata are regular and Equation (13.23) holds. 
By Proposition 13.4 we have established a way for determining operator Ω  
and are prepared to formulate an algorithm for finding the supremal sublanguage 
given a language. The algorithm is given below: 
Algorithm 13.1. 
1. Let 
(
)
F
q
Q
A
,
,
,
,
0 δ
Σ
=
 be a trim automaton generating the language 
m
L . 
2. The variable j is set to
0
=
j
. 
3. Let 
(
)
H
p
P
B
,
,
,
,
0
0
ξ
Σ
=
 be a trim automaton generating the language of 
the required behavior 
K
J
=
0
. 
4. For automaton 
j
B , automaton 
1
+
j
B
 is constructed satisfying the onditions 
at Equations (13.33) and (13.35). 
1
+
j
B
 generates language 
1
+
j
J
. 
5. If 
1
+
j
B
 cannot be constructed, go to Step 9. 
6. If 
j
j
B
B
=
+1
 go to Step 8. 
7. Increase j by one, i.e., 
1
:
+
= j
j
 and go to Step 4. 
8. End. 
j
B  generates the supremal sublanguage for the required language K. 
9. End. 
1
+
j
B
 cannot be constructed. 
If the algorithm ends with step 8, a solution has been found. In each state the 
resulting automaton 
j
B  determines which controllable events are allowed and 
which are prohibited. A control automaton can be constructed for that purpose. It is 
illustrated in the following example. 

 
Supervisory Control 275 
Example 13.4. For the purpose of surveillance, a sea region is divided into sections 
according to the shape of the seabed as it is schematically shown in Figure 13.3. 
Two submarines A and B cruise and guard the sea region. A has its own separate 
repair port – section No. 5, its home harbor is section No. 2, while B has home and 
repair harbor in section No. 4. Due to the seabed form and the sea underwater 
streams, as well as different size of the submarines, possible and controllable 
transits of the submarines between sections are those shown in Figure 13.3.  
Meeting of the submarines in any section of the guarded sea region is 
prohibited for safety reasons. At the beginning of the inspection, A is in section No. 
5 and B in section No. 4. As for event strings it is required that in any situation 
each submarine can start from its home harbor and return there. Such a requirement 
is meant in the sense that a submarine has possibly to wait until the other 
submarine undertakes some admissible transits. Thus the start or return is not 
immediately feasible but in no case does a deadlock occur when no transit is 
possible because of the violation of the “no-meeting” condition. A stronger 
condition could be put on the guard system, i.e., the transits of a submarine to start 
or return are always and immediately realizable without waiting for the other 
submarine. 
In this example the supervisory control of the submarine guard system can be 
solved using finite automaton modeling. The task of the supervisory control is to 
prevent the violation of the requirements described above. 
5 
2 
0 
1 
3 
4 
a 1
a 0
a 2
a 6
a 5 
a 4
a 3
b 2
b 3
b 1
controllable event for subm arine A  
uncontrollable event for subm arine A  
controllable event for subm arine B  
 
Figure 13.3. Space guarded by the submarines 

276 Modeling and Control of Discrete-event Dynamic Systems 
The finite automaton specifying all possible and feasible transits in the studied 
system is shown in Figure 13.4. Considering the automaton as a language generator 
we can see that it generates 
m
L  when the final state set is 
{ }
24
=
F
 and 
{ }
54
0 =
q
. 
A state notation ij  means that submarine A is in the i-th and B in the j-th section, 
respectively. In other words an automaton state is a combination of submarine 
positions. Such an automaton is called the shuffle automaton and is designed by 
combining two sub-automata. The choice of state 24  for F represents the 
requirement that transit event strings always exist enabling each submarine to 
return to its home harbor. Automaton A in Figure 13.4 is accessible and co-
accessible. 
54 
24 
04
34
14 
53 
23 
03
33
13 
10 
30
00
20 
50 
a0 
a0 
a0 
a1 
a1 
a1 
a2
a2
a2
a3
a3
a3
a4
a4
a4
a5
a5
a5
a6
a6 
a6
b1 
b1
b1
b1 
b2 
b2
b2
b2 
b3 
b3
b3
b3 
b1 
b2 
b3 
 
Figure 13.4. The finite automaton representing all possible states and transits in the 
submarine system 
54
24 
04
34
14 
53
23 
03
13 
10 
30
20 
50
a0 
a0 
a0 
a1 
a1 
a1 
a2
a2
a3
a4
a4
a5
a5
a6
a6 
a6
b1 
b1
b1 
b2 
b2 
b3 
b3
b3
b1
b2
b3 
 
Figure 13.5. The finite automaton after removing the prohibited states 

 
Supervisory Control 277 
540 
240 
040
340
140 
530 
230 
130 
100 
300
200 
500 
a0 
a0 
a0 
a1 
a1 
a1 
a2
a3
a4
a4
a5
a5
a6
a6 
a6
b1 
b1 
b2 
b2 
b3 
b3
b3 
b1 
b2 
b3 
 
Figure 13.6. The trim automaton 
Now let finite automaton 
0
B  specifying the required behavior be constructed. 
It is done by a reduction of automaton A. Obviously the forbidden states are 00  
and 33 . They are removed from A as shown in Figure 13.5. The automaton is 
accessible but not co-accessible. The state 03 must be removed in order to keep 
the co-accessibility of the automaton (Figure 13.6). The automaton in Figure 13.6 
is a trim and it is a finite automaton denoted 
0
B  in Algorithm 13.1. Recall that by 
Proposition 13.5 both automata A and 
j
B  should be trims in order to be able to 
form the operator Ω  by the finite automata reduction. 
Now, the operator Ω  is given first by the changeover from automaton 
0
B  to 
0
B′  and by changeover from automaton 
0
B′  to 
1
B  in the sense of Proposition 13.5.  
By comparing with Equation (13.29), the function 
0
h  is obviously 
 
(
)
(
)
(
)
(
)
,
34
34
,
04
04
,
24
24
,
54
54
0
0
0
0
0
0
0
0
=
=
=
=
h
h
h
h
 
 
(
)
(
)
(
)
(
)
,
13
13
,
23
23
,
53
53
,
14
14
0
0
0
0
0
0
0
0
=
=
=
=
h
h
h
h
 
 
(
)
(
)
(
)
(
)
.
10
10
,
30
30
,
20
20
,
50
50
0
0
0
0
0
0
0
0
=
=
=
=
h
h
h
h
 
 Function 
0
h′  is 
 
24
24
,
54
54
0
0
0
0
=
⎟⎠
⎞
⎜⎝
⎛
′
′
=
⎟⎠
⎞
⎜⎝
⎛
′
′
h
h
 etc. 
 as Figure 13.7 specifies. 

278 Modeling and Control of Discrete-event Dynamic Systems 
a0 
a0 
a0 
a1 
a1 
a1 
a2 
a3 
a4 
a4 
a5 
a5 
a6 
a6 
b1 
b2 
b3 
b3 
b3 
b1 
b2 
b3 
'
0
24
'
0
54  
'
0
04
'
0
34
'
0
14
'
0
53  
'
0
23
'
0
50  
'
0
20
'
0
30
'
0
10
 
Figure 13.7. Reduction according to the condition (13.35) 
The condition at Equation (13.33) is checked based on Table 13.2. For the 
empty set 
{
}
1
3,b
a
⊆
∅
 holds and analogously for other rows of Table 13.2. The 
condition is not fulfilled in one row of the table, namely for state 
′
0
13
. There 
{
}
2
6
5
b
,
a
a ⊆/
and state 
′
0
13
should be cancelled (Figure 13.7) in order to approach 
the finite automaton, which results from the application of the operator Ω . 
Table 13.2. The transition table for checking the condition at Equation (13.33) 
 
040’ 100’ 130’ 140’ 200’ 230’ 240’ 300’ 340’ 500’ 530’ 540’
(
)
(
)
(
)
'
'
0
j
u
j
p
p
h
Σ
⊆
Σ
∩
Σ
 
040’ 
 
 
 
 
 
 
 
 
a3
 
 
 
Ø 
a3, b1 
100’ 
 
 
 
b3 
a6
 
 
a5
 
 
 
 
a5 
a5, a6, b3 
130’ 
 
b2 
 
 
 
a6
 
 
 
 
 
 
a5 
a6, b2 
140’ 
 
 
b1 
 
 
 
a6
 
a5
 
 
 
a5 
a5, a6, b1 
200’ 
 
 
 
 
 
 
b3
 
 
a0
 
 
Ø 
a0, b3 
230’ 
 
 
 
 
b2
 
 
 
 
 
a0
 
Ø 
a0, b2 
240’ 
a2 
 
 
 
 
b1
 
 
 
 
 
a0
Ø 
a0, a2, b1 
300’ 
 
a4 
 
 
 
 
 
 
b3
 
 
 
a4 
a4, b3 
340’ 
 
 
 
a4 
 
 
 
 
 
 
 
 
a4 
a4 
500’ 
 
 
 
 
a1
 
 
 
 
 
 
b3
Ø 
a1, b3 
530’ 
 
 
 
 
 
a1
 
 
 
b2
 
 
Ø 
a1, b2 
540’ 
 
 
 
 
 
 
a1
 
 
 
b1
 
Ø 
a1, b1 

 
Supervisory Control 279 
The next step is to preserve the trim property. The states 300′ and 100′ are not 
accessible and are to be cancelled. According to Figure 13.8, 
1h  is defined 
(
)
(
)
,
24
24
,
54
54
1
1
1
1
=
=
h
h
 etc.  
The result of the last step is depicted in Figure 13.8 and Tables 13.3–13.5. 
Then, the above steps are repeated. A table corresponding to Table 13.2 is 
Table 13.3. As there is no more reduction of the automaton, the algorithm stops. 
The automaton depicted in Figure 13.8 generates the supremal controllable 
sublanguage of language 
0
B .   
541 
241 
041
301
141 
531 
231 
201 
501 
a0 
a0 
a0 
a1 
a1 
a1 
a2
a3
a4
a5
a6
b1 
b2 
b3 
b1 
b2 
b3 
 
Figure 13.8. Finite automaton B1 generating language J1 
Table 13.3. The transition table for the next step of Algorithm 13.1. 
 
041’ 
141’ 
201’ 
231’ 
241’
341’
501’ 531’
541’
(
)
(
)
(
)
'
'
0
j
u
j
p
p
h
Σ
⊆
Σ
∩
Σ
 
041’ 
 
 
 
 
 
a3
 
 
 
 
a3, b1 
141’ 
 
 
 
 
a6
a5
 
 
 
a5 
a5, a6, b1 
201’ 
 
 
 
 
b3
 
a0
 
 
 
a0, b3 
231’ 
 
 
b2 
 
 
 
 
a0
 
 
a0, b2 
241’ 
a2 
 
 
b1 
 
 
 
 
a0
 
a0, a2, b1 
341’ 
 
a4 
 
 
 
 
 
 
 
a4 
a4 
501’ 
 
 
a1 
 
 
 
 
 
b3
 
a1, b3 
531’ 
 
 
 
a1 
 
 
b2
 
 
 
a1, b2 
541’ 
 
 
 
 
a1
 
 
b1
 
 
a1, b1 

280 Modeling and Control of Discrete-event Dynamic Systems 
The supervisory control is performed through the controllable events. In each 
possible system state the allowed or prohibited events are set up. For example let 
the system be in state 
1
04 . The study of state 04  in Figures 13.8 and 13.4 yields 
that event 
1b  is to be prohibited and 
3a  is to be allowed. 
Table 13.4. States of the control automaton 
 
041 
141 
201
231
241
341
501
531
541 
041 
 
 
 
 
 
a3 
 
 
 
141 
 
 
 
 
a6 
a5 
 
 
 
201 
 
 
 
 
b3 
 
a0 
 
 
231 
 
 
b2 
 
 
 
 
a0 
 
241 
a2 
 
 
b1 
 
 
 
 
a0 
341 
 
a4 
 
 
 
 
 
 
 
501 
 
 
a1 
 
 
 
 
 
b3 
531 
 
 
 
a1 
 
 
b2 
 
 
541 
 
 
 
 
a1 
 
 
b1 
 
Table 13.5. Outputs of the control automaton 
 
wa0 
wa1
wa2
wa3
wa6
wb1
wb2
wb3
041 
 
 
 
1 
 
0 
 
 
141 
 
 
 
 
1 
0 
 
 
201 
1 
 
0 
 
 
 
 
1 
231 
 
 
0 
 
 
 
1 
 
241 
 
 
1 
 
 
1 
 
 
341 
 
 
 
 
 
0 
 
 
501 
 
1 
 
 
 
 
 
1 
531 
 
1 
 
 
 
 
1 
 
541 
 
1 
 
 
 
1 
 
 
A deterministic finite automaton with outputs can be constructed by setting up 
the controllable events. Such an automaton would have the same topology as 
1
B  
with outputs for the event control. It can be minimized by finding the state classes 
equivalent from the output point of view. Denote the automaton outputs 
ai
w  and 
bi
w . If 
1
,1
=
=
bi
ai
w
w
, events 
ia  and 
ib are allowed, while in the inverse case 

 
Supervisory Control 281 
they are prohibited.  The free outputs or the so-called “don’t care” are purposely 
completed with suitable values.  
The equivalent classes are  
 
{
}
{
}
1
1
1
1
1
1
1
1
1
53
,
50
,
34
,
23
,
20
,
14
,
04
2
,
54
,
24
1
=
=
C
C
 
(Table 13.6). 
A suitable completion of the output function is given in Table 13.5. The 
minimum control automaton is depicted in Figure 13.9. The outputs 
3
2
6
3
1
0
,
,
,
,
,
b
b
a
a
a
a
w
w
w
w
w
w
are permanently set to logical one.  
Table 13.6. Completion of the “don’t care” 
 
041 141 201 231 241 341 501 531 541 wa0 wa1 wa2 wa3 wa6 wb1 wb2 wb3 
041 
 
 
 
 
a3
1
1
0
1
1
0
1 
1 
141 
 
 
 
a6 
a5
1
1
0
1
1
0
1 
1 
201 
 
 
 
b3 
a0
1
1
0
1
1
0
1 
1 
231 
 
b2 
 
 
a0
1
1
0
1
1
0
1 
1 
241 
a2 
 
b1 
 
a0
1
1
1
1
1
1
1 
1 
341 
 
a4 
 
 
 
1
1
0
1
1
0
1 
1 
501 
 
a1 
 
 
b3
1
1
0
1
1
0
1 
1 
531 
 
 
a1 
 
b2
1
1
0
1
1
0
1 
1 
541 
 
 
 
a1 
b1
1
1
1
1
1
1
1 
1 
041-141-201-231-
341-501-531 
241 -541 
a1,  a6,  b3 
a2,  b1 
wa2=1 
wb1=1 
wa2=0 
wb1=0 
wa0=1 
wa1=1 
wa3=1 
wa6=1 
wb2=1 
wb3=1 
wa0=1 
wa1=1 
wa3=1 
wa6=1 
wb2=1 
wb3=1 
 
Figure 13.9. The supervisory control finite automaton with outputs 

282 Modeling and Control of Discrete-event Dynamic Systems 
13.4  Supervisory Control Solution with P-invariants 
A method based on Petri nets and place invariants (Moody and Antsaklis 1998; 
Yamalidou et al. 1996) appeared to be able to cope with the state space 
dimensionality. The dimensionality problem can appear in the method which uses 
the finite automaton described in the previous section or the reachability graph of 
the Petri net to be discussed later. The P-invariant method does not require the 
state space construction, is computationally very effective and can be used for 
large and complex systems. On the other hand the method neither resolves the 
problem of uncontrollable transitions nor the problem of the required accessibility 
of the home places directly. A partial elimination of these drawbacks is possible by 
transforming the problem into the proper system constraints. There is also the 
possibility to transform the constraints given in other forms into the form required 
by the method. 
The method using the place invariants, P-invariants for short, of a Petri net 
enables design of the feedback supervisory controller. The idea is to enhance the 
given Petri net describing the system so that the enhanced Petri net contains the 
required P-invariants. The P-invariants are derived from the linear constraints 
imposed on the Petri net markings, which represent the supervisory requirements 
and restrictions imposed on the system under supervisory control. It was shown in 
Section 8.10 that a place invariant determines the set of places for which the 
weighted sum of tokens remains constant for all markings in the reachability set 
(
)
0
m
PN
R
 of a Petri net PN. 
Consider a Petri net PN with n places and m transitions representing the 
controlled system. Let 
Δ
N
 be the Δ -incidence matrix of this net. Control 
requirements for PN are realized by a Petri net supplement representing a Petri net 
controller. The Δ -incidence matrix of the supplemented control part of the Petri 
net is denoted by 
c
Δ
N
.  
A control requirement imposed on the system is formulated in the form of 
inequality 
 
 
(
)
β
≤
∑
=
n
i
i
r
i
p
M
l
1
, 
(13.36) 
where 
(
)
i
r p
M
 is the marking of the place 
ip  (given as an integer) and 
(
)
0
m
PN
r
R
M ∈
 is any reachable marking in Petri net PN, 
il  and β  are the 
coefficients given as the natural numbers. 
The constraint at Equation (13.36) can be transformed into equality by 
introducing a nonnegative integer slack variable 
rc
μ
: 
 
(
)
β
μ
=
+
∑
=
rc
n
i
i
r
i
p
M
l
1
 
(13.37) 

 
Supervisory Control 283 
where 
rc
μ
 represents a marking of the supplementary control place 
cp , which 
holds the extra tokens to meet the equality. Values of 
rc
μ
 are chosen to preserve 
the equality for all reachable markings for the extended Petri net. The described 
procedure can be applied to more constraints given in the form of Equation (13.36) 
leading to more supplemented places. Then the structure of the supplemented 
control part of the Petri net is to be determined. As a matter of fact it is necessary 
to determine the arcs connecting the supplemented places with the transitions of 
the Petri net PN and the initial marking of the control places. This is based on the 
determination of the place invariants. A constraint in the form of equality 
introduces a place invariant into the Petri net, i.e., the weighted sum of tokens in all 
places of PN and in the supplementary place 
c
p  are constant and equal β . The 
number of supplementary places of the controller part of the Petri net is equal to 
the number of constraints to be enforced. Every place of the controller part adds 
one row to the incidence matrix 
s
Δ
N
 of the whole controlled system.  Thus, 
s
Δ
N
 
is composed of two matrices, namely 
Δ
N  of the system to be controlled and 
c
Δ
N
 
of the controller net.  
The arcs connecting the controller places to the original Petri net of the system 
can be computed by Equation (8.29) defining place-invariants  
 
T
T
T
0
N
i
0
i
N
=
⇒
=
Δ
Δ
s
P
P
s
, 
(
)
43
42
1
times
m−
=
0
,...,
0,0
T
0
 
(13.38) 
where the unknowns are the elements of the new rows of the matrix 
s
Δ
N
, i.e., the 
elements of matrix 
c
Δ
N
 and vector 
Pi
 is the desired P-invariant  according to 
Equations (8.41) and (13.37) and it is obviously given by  
 
(
)1
...
1
T
n
P
l
l
=
i
 
(13.39) 
The variable 
rc
μ
 has a coefficient one. 
All constraints in the form of Equation (13.36) can be aggregated in a matrix 
where the number of constraints is nc: 
 
b
m
L
≤
r
 
(13.40) 
The matrix equality is  
 
b
m
m
L
=
+
c
r
r
, 
(13.41) 
where L  is an 
n
nc ×
 matrix of non-negative integers containing the constraint 
coefficients, b is an 
1
×
cn
 vector of non-negative integers, 
r
m  is a vector variable 
representing  reachable markings of the original Petri net with n components (for 

284 Modeling and Control of Discrete-event Dynamic Systems 
places of the original Petri net), 
c
r
m  is an 
1
×
cn
 vector variable of non-negative 
integers that represents markings of the supplementary controller places, and 
cn  is 
the number of constraints. For all constraints we have 
 
(
)
( ) (
)
( )
0
N
N
L
N
N
I
L
0
N
I
L
=
+
⇒
⎟⎟
⎠
⎞
⎜⎜
⎝
⎛
=
=
Δ
Δ
Δ
Δ
Δ
c
c
s
.
 
(13.42) 
where L is a matrix whose rows are the transposed P-invariant vectors, I is an 
c
c
n
n ×
 identity matrix and ( )
0  is an 
m
nc ×
 zero matrix. The matrix 
c
Δ
N
 contains 
arcs that connect the controller net places with the transitions of the original Petri 
net PN and is given by 
 
Δ
Δ
−
= LN
N c
 
(13.43) 
The initial marking of the supplementary controller part of the extended Petri 
net is calculated from the place invariant conditions that are initially met: 
 
b
m
m
L
=
+
0
0
c
 
(13.44) 
where 
0
m  is the initial marking of the Petri net PN and 
0
c
m
 is the searched initial 
marking of the supplementary places, i.e., 
 
0
0
m
L
b
m
−
=
c
 
(13.45) 
The described control is maximally permissive from the point of view of 
possible transition firings in the controlled Petri net. Consider Δ - incidence matrix 
Δ
N  and assume its rank 
n
r <
. Then the Petri net PN has 
(
)
r
n
k
−
=
 P-invariants 
because the homogenous equation at Equation (8.29) has k basic linearly 
independent non-zero solutions (each solution is a vector). The invariants represent 
bindings or restrictions contained in the original PN. The Δ - incidence matrix of 
the extended Petri net is  
 
⎟⎟
⎠
⎞
⎜⎜
⎝
⎛
−
=
⎟⎟
⎠
⎞
⎜⎜
⎝
⎛
=
Δ
Δ
Δ
Δ
Δ
N
L
N
N
N
N
c
S
 
(13.46) 
The rows of the lower matrix part are linear combinations of the rows of 
Δ
N . 
The rank of 
k
S =
Δ
N
, i.e., it is equal to the rank of 
Δ
N . Thus there are no new 
bindings due to the control extension of the Petri net PN. 

 
Supervisory Control 285 
D1
P 
A
C1
C3
C2
S1
S2 
D5
D2
D3 
D4
 
Figure 13.10. A manufacturing layout with the transport system 
Example 13.5. A technological layout is schematically illustrated in Figure 13.10. 
Its transportation part works as follows. Four palettes are in room P and four 
automatic guided vehicles in room A at the beginning. The palettes are cleaned in 
P after some number of uses. The accumulators of the vehicles are loaded when 
necessary in room A. The palettes are transported to room C1 by belt conveyor S1, 
which has capacity of four palettes. The capacity of S2 is four palettes, too. The 
vehicles go one by one to room C1 where a palette is mounted on a vehicle. Only 
one vehicle can be in one-way corridor D1 at a time. The same holds true for D5. 
Each vehicle with a palette on it can move between the manufacturing cells as the 
arrows indicate. The manufactured parts are transported with the help of vehicles 
with the palettes. After some transportation a palette is taken from the vehicle and 
transported back in P via the belt conveyor S2 while the vehicle goes to room A for 
the accumulator reloading.  
Only one vehicle with a palette can pass through bidirectional corridors D2 up 
to D4. The number of the vehicles can be maximally two in rooms C1 and C2 
together including the corridor between the rooms. Moreover in the corridor D2 
can be only one vehicle. Analogously maximally three vehicles can be in rooms C2 
and C3 together with corridor D3 and one vehicle in corridor D3. Maximally one 
vehicle can be in corridor D4.  
The Petri net describing the transportation part of the system is represented by 
solid lines in Figure 13.11. 
The inequalities expressing the condition of the system behavior given above 
are 

286 Modeling and Control of Discrete-event Dynamic Systems 
 
( )
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
1
,1
,1
,1
,1
3
,2
12
15
8
7
5
4
11
10
9
8
7
6
6
5
4
3
≤
≤
≤
+
≤
+
≤
+
≤
+
+
+
≤
+
+
+
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
p
M
r
r
r
r
r
r
r
r
r
r
r
r
r
r
r
r
 
The slack variables for the inequalities are 
(
)
(
)
(
)
7
2
1
,
...
,
,
c
r
c
r
c
r
p
M
p
M
p
M
, 
respectively. 
 
p1 
p2 
p12 
p14 
t2 
t1 
z z
z z
p15 
p3 
z z
z
z
t18 
p13 
t15 
p9 
z 
pc6 
z 
p10 
p11 
z
pc7 
t13 
t12 
pc3 
t14 
t11 
z
z 
t3 
t6 
pc1 
p5 
p4 
pc4 
z 
t5 
p6 
t17 
t16 
t4 
z z
z
pc2 
t8 
t9 
p7 
p8 
pc5 
t7 
t10 
 
 
Figure 13.11. Petri net of the system transportation part 

 
Supervisory Control 287 
The controller Petri net structure is given by the Δ -incidence matrix 
c
Δ
N
. It 
specifies a supplementary structure, which binds the system behavior. It is drawn 
with dashed lines in the Petri net in Figure 13.11. The Petri net is a base for the 
system supervisory control. Suppose that the passages of vehicles and palettes are 
controllable. The Petri net transitions correspond to the passages. The transition 
firings are guarded by places 
7
1,...,
c
c
p
p
. If a transition in the Petri net is not 
fireable the corresponding passage is not allowed. Using the Petri net of Figure 
13.11, a control program for the control of the passages can be written. 
The Δ -incidence matrix 
c
Δ
N
 is 
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
−
−
−
−
−
−
=
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
−
×
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
=
−
=
Δ
Δ
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
1
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
1
1
0
1
0
0
1
0
0
0
0
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
1
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
1
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
0
0
7
6
5
4
3
2
1
c
c
c
c
c
c
c
c
p
p
p
p
p
p
p
N
L
N
 

288 Modeling and Control of Discrete-event Dynamic Systems 
A correct required behavior depends on the formulation of the inequalities at 
Equation (13.40). If for example we put the restrictions as follows 
 
(
)
(
)
(
)
(
)
3
,2
9
6
6
3
≤
+
≤
+
p
M
p
M
p
M
p
M
 
While the rest are given as before, the P-invariant method gives a structure that 
includes dead-locks. Seemingly the inequalities specify the same behavior but the 
control structure is not good. We postpone the supervisory control for the 
erroneous inequalities to the reader. 
The presented method does not directly solve the case of uncontrollable events. 
It can be resolved by a suitable set of inequalities at Equation (13.40). The problem 
of proper inequalities will be treated in the following example. 
Example 13.6. Consider Example 13.5 with the same behavior requirements. It is 
required that in every situation each submarine can immediately start from its 
home position or to return there. As before, transits a4 and a5 are uncontrollable, 
and the other transitions are controllable (in comparison with Figure 13.2). The 
system Petri net is represented via solid arcs in Figure 13.12. Obviously, to prevent 
the submarines’ meeting requires the following inequalities:  
 
(
)
(
)
(
)
(
) 1
,1
3
3
0
0
≤
+
≤
+
B
r
A
r
B
r
A
r
p
M
p
M
p
M
p
M
  
(13.47) 
where the place 
0
A
p
corresponds to the presence of the submarine A in section 0, 
and similarly for other places. The prohibition of uncontrollable event 
5
a  when 
submarine B is accidentally in section 3 requires that sections 1 and 3 together 
contain just one submarine. Moreover, in the situation when submarine A is in 
section 0 and B in section 3 the system is in a deadlock because B cannot return 
immediately to its home section 4 unless it meets A. The last problem can be coped 
with by requirement that if A is in section 1, there cannot be B in section 3, and if 
A is in 0, B cannot be in section 3, and finally if B is in 3, A cannot be in 1 or 0. 
Expressing it by an inequality we have 
 
(
)
(
)
(
)
1
0
3
1
≤
+
+
A
r
B
r
A
r
p
M
p
M
p
M
 
(13.48) 
Now Equations (13.47) and (13.48) completely cover requirements of the 
admitted states or events and the deadlock prevention. The solution with the P-
invariants is 

 
Supervisory Control 289 
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
=
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
−
−
−
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎝
⎛
−
=
−
=
Δ
Δ
0
1
1
1
1
1
1
1
0
0
0
1
1
0
1
1
1
0
0
0
1
1
0
0
0
0
1
1
0
0
1
1
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
0
1
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
1
0
0
0
1
1
1
0
0
0
0
0
0
0
0
1
1
0
1
0
1
0
1
0
0
0
1
0
0
1
0
0
0
1
0
0
0
0
1
0
0
N
L
N
c
 
where the columns of  L and the rows of 
Δ
N correspond to the places pA5, pA2, pA0, 
pA3, pA1, pB4, pB3, and pB0, , respectively, and the columns of 
Δ
N  correspond to the 
transitions ta0–ta2 and tb1–tb3 respectively. The supplementary control places are pc1, 
pc2, and pc3 corresponding respectively to the rows of matrix L. The control part of 
the Petri net is depicted with dashed lines in Figure 13.12. 
Figure 13.12. Petri net for the submarine system 
  
z
pA5
pA2
pA0
ta1
z
pA3
pA1
ta0
ta6
ta2
ta3
ta4
ta5 
pB0
pB4
pB3 
tb3
tb1
tb2
pc1
z
z 
pc2 
z
pc3

290 Modeling and Control of Discrete-event Dynamic Systems 
Impact of the requirement inequalities on the solution is visible from the next 
reasoning. The inequalities at Equations (13.47) and (13.48) can be equivalently 
substituted by two inequalities as follows 
 
(
)
(
)
(
)
(
)
(
)
(
) 1
1
0
0
3
1
3
0
≤
+
≤
+
+
+
B
r
A
r
B
r
A
r
A
r
A
r
p
M
p
M
p
M
p
M
p
M
p
M
 
In this case 
 
⎟⎟
⎠
⎞
⎜⎜
⎝
⎛
−
−
−
−
=
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
−
−
−
−
−
−
×
⎟⎟
⎠
⎞
⎜⎜
⎝
⎛
−
=
−
=
Δ
Δ
1
1
0
0
0
0
1
1
0
0
0
1
1
1
0
0
0
1
0
0
1
1
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
0
1
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
1
0
0
0
1
1
1
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
1
0
1
1
1
0
0
N
L
N c
 
The Petri net for the described case is shown in Figure 13.13. 
Example 13.7. Figure 13.14 shows landing and starting fields of an airport. Q1 and 
Q2 are the air parking sections. On commands from the control tower airplanes can 
transfer from Q1 or Q2 to parking airspace S consisting of sections S1 through S4. 
In S can be only one airplane. Transfers between sections S1 through S4 are 
uncontrollable events. Transfers between sections A1, K, and A2 of the landing 
field I are controllable events. So are those for the landing field II and the starting 
field. In sections A1, K, and A2 together can be only one airplane. The same holds 
for the landing field II. Each of sections R1, K, and R2 can host at most one 
airplane. In T1 and T2 together is allowed one airplane. The airport traffic is 
subdued to the control requirements given below. Of course, the goal of the 
supervisory control is to avoid the airplane collisions.  
The Petri net for the P-invariant method of the supervisory control solution is in 
Figure 13.15. The respective matrices are given in a tabular form as shown in 
Tables 13.7–13.9. Control places are connected to the system Petri net model with 
dashed lines. 

 
Supervisory Control 291 
 
z
pA5 
pA2 
pA0 
ta1 
z
pA3 
pA1 
ta0 
ta6 
ta2 
ta3 
ta4 
ta5 
pB0 
pB4 
pB3 
tb3 
tb1 
tb2 
z
pc1 
z 
pc2 
 
Figure 13.13. Modified Petri net for the submarine system 
Q1
Q2
S1
S2
S3
S4 
A1
K 
A2
R2
T1
T2
B 
R1
Štartovacia dráha 
    Landing field I 
   Landing filed II 
Starting field 
S 
 
Figure 13.14. Organization of the airport traffic 

292 Modeling and Control of Discrete-event Dynamic Systems 
pB
t9 
t1 
t11
pC3
t3 
t2 
t10
z 
z
z
pQ2 
pC1 
pC2 
t4 
pS1 
pS2 
pS3 
pS4 
t5 
t6 
t7 
t8 
t12
pC4
pC7
pR2
pT1
pT2
t16
pC5
pC6
pR1
p2
K
p1
K
pQ1 
pA1
pA2
t13
t14
t15 
pC11
pC9 
t20 
pC10 
t17
t18
t19
pC8 
z
z
z 
z
z
z
z
z
 
Figure 13.15. Petri net for the supervisory control of the airport traffic 

 
Supervisory Control 293 
 
Control requirements: 
Corresponding control place: 
 
1
1 ≤
Q
p
 
1
C
p
 
 
1
C
p
 
2
C
p
 
 
1
4
3
2
1
≤
+
+
+
S
S
S
S
p
p
p
p
 
3
C
p
 
 
1
≤
B
p
 
4
C
p
 
 
1
2
1
1
≤
+
+
A
K
A
p
p
p
 
5
C
p
 
 
1
1 ≤
R
p
 
6
C
p
 
 
1
2
1
≤
+
+
T
T
B
p
p
p
 
7
C
p
 
 
1
2
1
≤
+
T
T
p
p
 
8
C
p
 
 
1
2 ≤
K
p
 
9
C
p
 
 
1
2 ≤
R
p
 
10
C
p
 
 
1
2
1
≤
+
K
K
p
p
 
11
C
p
 
 Place markings are for simplicity denoted equally as corresponding places. 
Table 13.7. Matrix 
Δ
N
 
 
t1 
t2 
t3 
t4 
t5 
t6 
t7
t8
t9
t10
t11
t12
t13
t14
t15
t16
t17
t18 t19 t20 
pQ1 
1 
0 –1 0 
0 
0 
0
0
0
0
0
0
0
0
0
0
0
0 
0 
0 
pQ2 0 
1 
0 –1 0 
0 
0
0
0
0
0
0
0
0
0
0
0
0 
0 
0 
pS1 
0 
0 
1 
1 –1 0 
0
1
–1
0
–1
0
0
0
0
0
0
0 
0 
0 
pS2 
0 
0 
0 
0 
1 –1 0
0
0
0
0
0
0
0
0
0
0
0 
0 
0 
pS3 
0 
0 
0 
0 
0 
1 –1
0
0
0
0
0
0
0
0
0
0
0 
0 
0 
pS4 
0 
0 
0 
0 
0 
0 
1
–1
0
0
0
0
0
0
0
0
0
0 
0 
0 
pB 
0 
0 
0 
0 
0 
0 
0
0
0
0
1
–1
0
0
0
0
0
0 
0 
0 
pA1 0 
0 
0 
0 
0 
0 
0
0
1
–1
0
0
0
0
0
0
0
0 
0 
0 
p1
K 
0 
0 
0 
0 
0 
0 
0
0
0
1
0
0
–1
0
0
0
0
0 
0 
0 
pA2 0 
0 
0 
0 
0 
0 
0
0
0
0
0
0
1
0
0
0
0
0 
0 –1 
pR1 0 
0 
0 
0 
0 
0 
0
0
0
0
0
0
0
–1
1
0
0
0 
0 
0 
p2
K 0 
0 
0 
0 
0 
0 
0
0
0
0
0
0
0
1
0
–1
0
0 
0 
0 
pR2 0 
0 
0 
0 
0 
0 
0
0
0
0
0
0
0
0
0
1
–1
0 
0 
0 
pT1 
0 
0 
0 
0 
0 
0 
0
0
0
0
0
0
0
0
0
0
1
–1 0 
0 
pT2 
0 
0 
0 
0 
0 
0 
0
0
0
0
0
0
0
0
0
0
0
1 –1 0 

294 Modeling and Control of Discrete-event Dynamic Systems 
Table 13.8. Matrix L 
 
pQ1
pQ2 pS1 
pS2 pS3
pS4
pB
pA1
p1
K
pA2
pR1
p2
K
pR2
pT1 pT2 
pC1 
1 
0 
0 
0 
0
0
0
0
0
0
0
0
0
0 
0 
pC2 
0 
1 
0 
0 
0
0
0
0
0
0
0
0
0
0 
0 
pC3 
0 
0 
1 
1 
1
1
0
0
0
0
0
0
0
0 
0 
pC4 
0 
0 
0 
0 
0
0
1
0
0
0
0
0
0
0 
0 
pC5 
0 
0 
0 
0 
0
0
0
1
1
1
0
0
0
0 
0 
pC6 
0 
0 
0 
0 
0
0
0
0
0
0
1
0
0
0 
0 
pC7 
0 
0 
0 
0 
0
0
1
0
0
0
0
0
0
1 
1 
pC8 
0 
0 
0 
0 
0
0
0
0
0
0
0
0
0
1 
1 
pC9 
0 
0 
0 
0 
0
0
0
0
0
0
0
1
0
0 
0 
pC10 
0 
0 
0 
0 
0
0
0
0
0
0
0
0
1
0 
0 
pC11 
0 
0 
0 
0 
0
0
0
0
1
0
0
1
0
0 
0 
Table 13.9. Matrix 
Δ
Δ
−
=
N
L
N
C
 
 
t1 
t2
t3 t4 t5 t6 t7
t8
t9
t10
t11
t12
t13
t14
t15
t16
t17
t18 t19 t20 
pC1 
–1 0
1 
0 
0 
0 
0
0
0
0
0
0
0
0
0
0
0
0 
0 
0 
pC2 
0 –1
0 
1 
0 
0 
0
0
0
0
0
0
0
0
0
0
0
0 
0 
0 
pC3 
0 
0
–1 –1 0 
0 
0
0
1
0
1
0
0
0
0
0
0
0 
0 
0 
pC4 
0 
0
0 
0 
0 
0 
0
0
0
0
–1
1
0
0
0
0
0
0 
0 
0 
pC5  
0 
0
0 
0 
0 
0 
0
0
–1
0
0
0
0
0
0
0
0
0 
0 
1 
pC6 
0 
0
0 
0 
0 
0 
0
0
0
0
0
0
0
1
–1
0
0
0 
0 
0 
pC7 
0 
0
0 
0 
0 
0 
0
0
0
0
–1
1
0
0
0
0
–1
0 
1 
0 
pC8 
0 
0
0 
0 
0 
0 
0
0
0
0
0
0
0
0
0
0
–1
0 
1 
0 
pC9 
0 
0
0 
0 
0 
0 
0
0
0
0
0
0
0
–1
0
1
0
0 
0 
0 
pC10 0 
0
0 
0 
0 
0 
0
0
0
0
0
0
0
0
0
–1
1
0 
0 
0 
pC11 0 
0
0 
0 
0 
0 
0
0
0
–1
0
0
1
–1
0
1
0
0 
0 
0 

 
Supervisory Control 295 
The initial marking of control places is 
 
(
)
(
)
(
) .
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
T
T
T
0
0
=
−
=
−
=
m
L
b
m c
 
The system of conditions can be simplified. The conditions 
1
2
1
≤
+
+
T
T
B
p
p
p
, 
1
≤
B
p
 and 
1
2
1
≤
+
T
T
p
p
 can be equivalently substituted by condition 
1
2
1
≤
+
+
T
T
B
p
p
p
. Similarly 
1
2 ≤
K
p
 and 
1
2
2
≤
+
K
K
p
p
 by 
1
2
2
≤
+
K
K
p
p
. Eight 
conditions give the same result as the original eleven ones. 
The discussed method is widely used. Its recent application is to synthesize the 
deadlock control policies in (Uzam and Zhou 2006). 
13.5  Supervisory Control Solution with Reachability Graph 
The Petri net reachability graphs offer a good tool for the study and design of the 
supervisory control. In what follows their use in supervisory control will be 
described. The Petri nets interpreted for DEDS control will be used.  
Let a Petri net interpreted for the control PCN be given. Petri nets interpreted 
for the control were treated in Section 7.5. For the given PCN a function 
LOG
T →
:
ψ
 is defined where LOG is a set of the logical expressions whose 
value can be true or false, and T is the set of the transitions of PCN. In this section 
we assume the logic expressions are Boolean propositions in the form 
1
=
=
i
w
 
where 
i
w  is a Boolean variable. One such a proposition is associated with each 
transition so that 
1
=
=
i
w
 is associated with transition 
it , 
T
ti ∈
. If 
1
=
i
w
 then 
the value of the proposition
1
=
=
i
w
 is true. Transition 
it  in turn is associated with 
event 
ie . The functionς  is empty (see Section 7.5). Transition it  is fireable if the 
actual marking fulfils the firing conditions valid for PNC, which includes a 
condition that the logical proposition associated with 
it  is true.  
The first step of the method for the solution of the supervisory control of a 
DEDS is design of PNC specifying the complete and possible system behavior. In 
terms of the model Equation (13.1) the behavior is specified by the language L. 
The strings or words of events of language L are given by the set of all possible 
transition firing sequences from the initial marking of the given Petri net PNC. All 
Boolean variables 
i
w  have value 
1
=
i
w
 for the specification of language L by 
PNC. The event string 
pi
i
i
e
e
e
...
~
2
1
=
σ
 clearly corresponds to transition string 
pi
i
i
t
t
t
...
~
2
1
=
κ
in the time points given by  
pi
i
i
τ
τ
τ
τ
...
~
2
1
=
.  

296 Modeling and Control of Discrete-event Dynamic Systems 
For language K the values
i
w  determine whether the corresponding transitions 
of the Petri net are fireable in a particular situation represented by an actual 
marking. The words of K are given by the restriction through the supervisory 
control. A function 
(
)
W
PNC
R
F
2
:
0 →
m
 can be defined where 
{
}
m
w
w
w
W
,...,
,
2
1
=
 
is the set of the variables associated with the Petri  net  transitions  that  have  value 
1 for  the  actual marking while the other have value 0. As a matter of fact the 
variables of set W control the fireability of the transitions depending on the 
marking.  
The Petri net reachability graph (see Section 8.2) is useful for the supervisory 
control solution. Each arc of the reachability graph is labeled with a transition. The 
transition is fireable and a change of marking arises if the associated variable 
i
w  is 
true, i.e., 
1
=
i
w
. It is assumed in the method that the Petri net, which models the 
given system, is bounded so that the reachability graph can be composed. 
The second step of the method is assure by means of a sublanguage K  the 
system behavior, which is represented by the model at Equation (13.1).  Using  the  
Petri  net  PNC  as  the  system model the behavior is specified by means of 
inadmissible system states and/or a set of the graph nodes that can be reachable by 
oriented paths from any reachable and admissible graph node in the reachability 
graph. As explained above, inadmissible states can be represented by inadmissible 
markings of the system modeling Petri net. It follows naturally that no oriented 
path of the required connection can contain an inadmissible marking. The nodes to 
be always accessible are called the home states or home markings. A general case 
is a requirement that at least one element of the set of the home markings should be 
reachable from any reachable marking. These can be distinguished by mulitple sets 
of the home markings denoted as H1, H2, …, Hz. The sense of the accessibility 
results from the system function and the supervisory requirements. It was discussed 
in the connection with the P-invariant methods studied in the previous section. 
More will be understandable from the example discussed below. 
The third step of the method can be modified according to the behavior 
requirements. The first version is suitable for the case when only inadmissible 
states are defined and no achievability of home nodes is required. The second more 
complete version satisfies both requirements. The third step varies depending on 
the computational problem with respect to the state space dimension. The problem 
can be formulated in terms of Petri nets as a problem of the cardinality of its 
reachability set. If it is computationally acceptable the reachability graph for the 
given Petri net is constructed. The procedure using the reachability graph will be 
described below. The procedure covers both system requirements: avoidance of the 
inadmissible states and/or preserving of the paths to the specified home states.  
The third step can be modified for the case when the reachability graph is too 
large and its computation is practically impossible. The predecessors of the 
inadmissible markings are computed and if they are connected to the inadmissible 
markings with uncontrollable arcs, the predecessors are put into the set of 
inadmissible markings, too. Possible transition activations are searched for in the 
actual state (marking). Those transitions are further analyzed which do not lead 
into an inadmissible marking. The required paths to the home markings should be 
checked from the admissible next markings in order to exclude the deadlocks. If 

 
Supervisory Control 297 
via a reasonable computation one finds that the path to the home marking exists, 
the next marking is finally allowed. In the opposite case the next marking is 
denoted as inadmissible. The supervisor should decide if in that case the system 
can undergo the risk of the deadlock in some of the successor states. The 
supervisor decision can be based on heuristic approaches. 
In the rest of this section we will study the case when it is possible to construct 
the reachability graph for a given bounded Petri net starting from the given initial 
marking, and the construction is computationally acceptable. As explained above, 
each arc of the graph is labeled with the transition whose activation causes the 
transfer from one marking to the next. The arc is also associated with the control 
variable that can enable or disable the transition and accordingly can enable or 
disable the corresponding event. The uncontrollable transitions are specified and 
they are associated with control variables having a constant value of 1 that means 
they are permanently enabled..  
The method can be divided into the following three parts. 
Part 1 
We denote the set of inadmissible markings as IA. The set IA initially consists of 
the a priori given forbidden markings and of the dead markings if there are any. A 
dead marking is characterized by the property that no arc is going out of it. Then 
we add to IA all those markings from which an arc labeled with uncontrollable 
transitions goes to an inadmissible marking from IA.  
Part 2 
The set of not allowed arcs denoted as NA is further formed. To the set belong 
those arcs that are labeled with the controllable transitions and go in an 
inadmissible node belonging to the set IA. The so-called NA-dead-markings are 
searched for and put in the set IA. The NA-dead-marking is the marking from 
which only not allowed (belonging to the set NA) arcs go out. 
Part 3 
Each element of the reachability set is analyzed and its outgoing allowed arcs are 
checked. If there is an oriented path leading into an element of the given set or sets 
of the home markings, the arc remains allowed; otherwise it is not allowed and is 
placed into the set NA. After that the conditions on inadmissibility of the nodes are 
repeated continuing from Part 1 because it is possible that the new not allowed arcs 
cause some nodes to become inadmissible. The procedure is repeated until no new 
and not allowed arcs and no new inadmissible markings spring up. 
 
An algorithm resolving the supervisory control is described concisely as 
follows. 
Step 1. Construct the reachability graph for the supervisory control 
assuming an bounded Petri net interpreted for the control is given. Label 
each arc with the corresponding activated transition. 
Step 2. Create empty sets IA and NA, respectively.  

298 Modeling and Control of Discrete-event Dynamic Systems 
Step 3. Put in set IA the inadmissible markings according to the system 
requirements. 
Step 4. Add into set IA dead markings (those with no arcs going out at all). 
Step 5. Add into IA the markings from which an arc labeled with an 
uncontrollable transition goes in an inadmissible marking. 
Step 6. Put into set NA the allowed arcs labeled with a controllable 
transition and going in an inadmissible marking. 
Step 7. Add NA-dead-markings into IA. The NA-dead-marking is the 
marking from which no outgoing arcs are allowed, i.e., the arcs belonging 
to NA. 
Step 8. If in Steps 4 through 6 a new not-allowed arc arises and/or in Step 7 
a new inadmissible marking arises continue with Step 4; and otherwise 
with Step 9. 
Step 9. Check if from any admissible marking (not an element of IA), there 
exist, an oriented path leading to at least one element of the home markings 
H1, the same into H2, …, up to Hz. Put the admissible marking not 
fulfilling the condition into IA. 
Step 10. If in Step 9 a marking was added to IA continue with Step 4; and 
otherwise end. 
Example 13.8. A manufacturing cell with mobile robots for the handling of the 
manufactured parts is depicted in Figure 13.16. Two robots R1 and R2 transfer 
parts of two kinds A and B within the cell. Robot R1 picks up a part A from the 
input conveyor C1 and transports it into rooms S2–S4 to machines M1–M5. The 
doorway to S5 is not passable for R1. Analogously it is for the movements of robot 
R2 as Figure 13.16 shows. Manufacturing runs according to an actual 
technological scheme including the processing at machines and movements of the 
robots with semi-products. 
Whether the movements are managed by an operator or control unit, the task of 
the supervisory control is to prevent the forbidden situations which are the 
meetings of the robots in the same room. On the other hand the return of R1 to S1 
and R2 to S5 in each position of the robots should be possible under the 
assumption that robots can realize movements, which loosen the movements of the 
other robot. For example, one robot moves back to a room and the second can 
continue in its route.  
The control agent used in the system determines the back tracking maneuvers. 
It is important that the system leads to no deadlock. The initial position of the 
robots is indicated in Figure 13.16.  
The Petri net serving for the supervisory control design is in Figure 13.17. The 
reachability graph is in Figure 13.18. 
 
 
 

 
Supervisory Control 299 
 
Figure 13.16. A manufacturing cell with mobile robots 
  
t1 
z 
z
t2 
uncontrollable 
transition 
t3 
t4 
t5 
t6 
t11
t12 
t8 
t7 
t9 
t10
p1 
p2
p3
p7
p6
p5
p4
p8
 
pi: R1 at room Si, i=1, 2, 3 and 4; 
p5: R2 at room S5; p6: R2 at room S3; p7: R2 at room S2; and p8: R2 at room S4. 
Transitions represent the movement of a robot from one room to another. 
Hollow-bar transitions are uncontrollable while solid-bar ones are controllable. 
Figure 13.17. Petri net for the manufacturing system (two separate Petri nets are in fact two 
automata) 
 
C1 
C2 
C4
C3
A 
B
R1 
R2
M3
M4
M1
M2
controllable event for R1 
controllable event for R2 
uncontrollable event for R1 
uncontrollable event for R2 
M5
S1 
S2 
S3 
S4 
S5 
 
 
 
 
 
z
z
z
z
z

300 Modeling and Control of Discrete-event Dynamic Systems 
1 0 0 0 1 0 0 0
0 1 0 0 1 0 0 0 
1 0 0 0 0 1 0 0
0 0 1 0 1 0 0 0 
0 0 0 1 1 0 0 0 
0 0 0 1 0 1 0 0 
0 0 0 1 0 0 1 0 
0 0 1 0 0 0 1 0 
0 1 0 0 0 0 1 0 
1 0 0 0 0 0 1 0 
0 1 0 0 0 1 0 0
t1 
t2 
t3 
t4 
t7
t8
t5 
t6 
t7 
t8 
0 0 1 0 0 1 0 0
t7 
t8
t6 
t5
t9 
t10 
t6 
t5 
t10 
t9
t4 
t3 
t2 
t1 
t4
t3
t10
t9
t7
t8
1 0 0 0 0 0 0 1
t11
t12
0 1 0 0 0 0 0 1
0 0 1 0 0 0 0 1 
0 0 0 1 0 0 0 1 
t1
t2
t12
t11
t1
t2
t3
t4 
t11
t12 
t5 
t6 
t11
t12
ti
uncontrollable 
transition, i=3, 4, 9 and 10. 
p1 p2 p3 p4 p5 p6 p7 p8
Distribution of places: 
t10 
t9
Collisions of the robots are represented by nodes: (0 0 1 0 0 1 0 0), (0 0 0 1 0 0 
0 1), and (0 1 0 0 0 0 1 0). The predecessors connected with them by 
uncontrollable transitions are: (0 0 1 0 0 0 1 0) and (0 1 0 0 0 1 0 0). A reduced 
reachability graph is shown in Figure 13.19.  There is no NA-dead-marking, and 
crosses denote the arcs from the NA set. 
The algorithm is finished because set IA and NA are stablized. The reachability 
graph renders the values of the transition control variables 
i
w  in each marking 
(state) of the system. The movements of the robot for any schedule are subdued to 
the reduced reachability graph. 
Figure 13.18. Reachability graph in the supervisory control design 

 
Supervisory Control 301 
Figure 13.19. The reduced reachability graph 
13.6 Problems and Exercises 
13.1. Propose supervisory control for the robotized manufacturing system depicted 
in Figure 7.18 (Exercise 7.2) using P-invariant method. For the robot movements 
assume the same requirements as in Exercise 7.2. 
Give a basic idea of how the supervisory control could be realized from the 
technical and programming point of view. 
1 0 0 0 1 0 0 0
0 1 0 0 1 0 0 0
1 0 0 0 0 1 0 0
0 0 1 0 1 0 0 0 
0 0 0 1 1 0 0 0 
0 0 0 1 0 1 0 0 
0 0 0 1 0 0 1 0 
t1 
t2 
t3 
t4 
t7
t5 
t6 
t7 
t8 
t7
t6 
t9 
t10 
t6 
t7
t8
1 0 0 0 0 0 0 1
t11
t12
0 1 0 0 0 0 0 1
0 0 1 0 0 0 0 1 
t1
t2
t12
t1
t3
t4 
t12 
t5 
t11
p1 p2 p3 p4 p5 p6 p7 p8
 
1 0 0 0 0 0 1 0 
t1
t9 
t10
ti
uncontrollable 
transition, i=3, 4, 9 and 10. 
Distribution of places:

302 Modeling and Control of Discrete-event Dynamic Systems 
13.2. Two robots R1 and R2 are moving in the space divided into rooms (Figure 
13.20). Initially R1 is in the room 2 and R2 in the room 4. Doors between rooms 
denoted A are passable in the directions of arrows for R1, denoted B for R2. All 
doors except for the movements A13 and A31 are controllable. Robots execute 
transfers of objects within the given space. One such task is defined by a start and a 
final room. Tasks are given by a supervisory control level while a particular path is 
elaborated by a local control system. Supervisory control level determines which 
doors can be used in every actual situation. 
Figure 13.20. Movement space for two robots 
Describe the movements of robots with a Petri net. The required supervisory 
control propose using the P-invariant method and compare it with the reachability 
graph method. 
13.3. A popular story of eating philosophers is illustrated in Figure 13.21. A meal 
is prepared. 
Figure 13.21. Three philosopher problem 
B43 
1
2
3
0
4
A13 
A31 
A12
A20
A03 
B04
B30
Aij means Robot R1 can 
pass from 
Room i to Room j. 
Bij means Robot R2 can 
pass from 
Room i to Room j. 
There are in total five 
rooms. 
F1
F2 
F3

 
Supervisory Control 303 
Each philosopher has one fork right and one left. When a philosopher wants to eat 
he takes forks one by one and afterwards drops them on the table. Philosophers are 
stubborn - if they want to eat they do not give warning. A philosopher needs both 
forks left and right to eat; otherwise he waits for free ones. Solve the supervisory 
control problem saying what forks cannot be picked up in order to prevent dead-
lock when all philosophers want to eat. 
Represent the behavior of philosophers using the Petri net and solve the 
supervisory control problem with the reachability graph of the Petri net. 
13.4. Consider the transportation system in Figure 7.20 of Exercise 7.5. It is 
reasonable for transportation control to divide the vehicle tracks into sections. A 
crossing is always a separate section. Let only the entry to the first section of each 
track be a controllable event. Solve the supervisory control for such an 
arrangement of the system.  
13.5. A transportation system using three automatic guided vehicles (AGV) in a 
manufacturing plant is depicted in Figure 13.22.  The vehicle tracks are divided 
into sections. Only one AGV can be present in a section – to go through or to stop 
there. No AGV can stop in any crossing. Each section is separated by two control 
points using sensors.   
A way to solve the AGV control is the supervisory control approach. As far as 
the supervisory control is preventing the AGVs from collisions and deadlocks, the 
personnel doesn’t have to take care about contemporary state of the system during 
the programming of new transportation requests. Use a Petri subnet for each AGV 
as it is shown in Figure 13.23. 
Figure 13.22. An AGV transportation system operating in a manufacturing plant 
SS2 
SS10 
SS1
SS3 
SS5 
SS4
SS11 
SS6
SS7
SS8
SS9
SSW2
SSW3
SSW4 
SSW5 
SSW6
SSW7
 
SSW9 
SS12 
SSW1

304 Modeling and Control of Discrete-event Dynamic Systems 
 
p13
p11
p12
p14
p1
p10
p7
p8
p9
p2
p3
p4
p5
p6
p25
p26
p16
p17
p18
p19
p20
p39
p40
p30
p31
p32
p33
p34
 
Figure 13.23. Petri net for the transportation system 
Places p2, p16, p30 in the respective subnets correspond to the presence of an 
AGV in the same section, namely the section S2. 
Formulate the solution of the supervisory control preventing collisions and 
deadlocks using the reachability graph of the Petri net consisting of the three 
subnets according to Figure 13.23. The nodes of the graph can be calculated 
comparatively easily by enumerating combinations of the AGV positions by a 
computer program. The forbidden nodes serve to avoid AGV collisions by 
performing the planned routes of the vehicles. What do you propose for planning at 
least near to optimal routing of the vehicles from given the initial section to the 
required goal. 

14 
Job Scheduling 
14.1  Problem Formulation 
Job scheduling or operation scheduling is a typical problem frequently appearing 
within DEDS. The core of the problem consists in how to achieve an optimal 
distribution of jobs or operations among the processing units or servers available in 
the system under various criteria. In other words, the problem is the optimal 
allocation of the system resources (Frankovič and Budinská 1998). 
Typical environments in which a scheduling problem occurs are flexible 
manufacturing systems, distributed computer systems, database systems, and other. 
For example, flexible manufacturing systems (FMS) usually consist of product 
processing or machining units, measuring and testing equipments, transportation 
facilities, manipulators and robots, intermediate storages, input and output devices. 
Various methods have been developed for scheduling problems (Engell 1989; Li et 
al., 1995; Zhou and Venkatesh, 1998). 
It has been discussed earlier in this book that process control means control of 
the basic processes at the level responsible for direct control. It is the control level 
or layer closest to the system processes. A hierarchically higher level is the co-
ordination level of the basic processes. Here, the co-ordination is considered as a 
selection of servers performing basic processing, if there are more options. For 
example, in flexible manufacturing systems it is a selection of production units if 
there are more options to realize a prescribed technological recipe. One of co-
ordination aims is to accomplish the required jobs in the minimum time span. For 
this aim it is necessary to know the duration times of the scheduled operations. 
Other scheduling optimization criteria can be, e.g., the maximum utilization of the 
resources and minimum tardiness of the required operations. A problem related to 
the job scheduling is routing of semi-products to servers according to a chosen 
scheduling. 
The first step in the solution of a job scheduling problem is a system 
specification using a suitable tool. The specification has to bring about such an 
abstraction that enables to present and solve the problem. An efficient specification 
is based on Petri nets (Lee and F. DiCesare, 1994, 1995; Xiong and Zhou 1998; 
Zhou and Venkatesh, 1998) and max-plus algebra (Moßig and Rehkopf, 1996). 

306 Modeling and Control of Discrete-event Dynamic Systems 
The first approach to be dealt with in this chapter is oriented on Petri net 
specification (Section 14.2). Obviously, from the nature of the scheduling 
problems, some extension with respect to time relations is necessary. Some 
researchers associate time with Petri net transitions. In Section 14.2 another 
approach is presented by utilizing a certain kind of place timing. Another approach 
is the max-plus algebra (Section 14.3). 
For our purposes, consider a system specified as  
 
(
)
T
op
S
SYST
,
,
, Ω
=
            
(14.1) 
where 
S:   a set of servers 
{
}
S
S
S
S
S
,...,
,
2
1
=
, 
:
Ω  a set of all different operations realizable in system SYST by servers, 
op: 
Ω
→2
S
 is a mapping of the set S into the set of the operation subsets, 
+
→
Ω
×
N
S
tu :
 is a function mapping a particular operation performed at 
a particular server into a positive integer representing the number of time 
units consumed by the operation. 
Let the i-th individual subset of the co-domain of the function op be denoted as 
 
{
}
Ω
∈
=
Ω
Ω
Ω
i
i
i
i
i
i
i
i
i
κ
κ
κ
κ
κ
κ
,...,
,
,
,...,
,
2
1
2
1
 
(14.2) 
where 
i
Ω denotes the set of operations available at the server 
iS , 
S
i
,...,
2,1
=
. 
The operations are from the set Ω ; then the function op can be expressed as 
 
( )
i
iS
op
Ω
=
             
(14.3) 
From Equations (14.2) and (14.3) it is possible to write  
 
(
)
i
k
i
k
i
i
k
S
i
S
tu
Ω
=
=
=
,...,
2,1
,
,...,
2,1
,
,
τ
κ
        
(14.4) 
The system flexibility is due to the fact that an operation can alternatively be 
performed on different system resources (servers). Thus 
 
∅
≠
Ω
∩
Ω
2
1
i
i
 for some 
2
1
i
i ≠
            
(14.5) 
In such a case times of the same operation performed on different servers may not 
be the same. 
Various processing procedures can be realized in the system SYST. In FMS 
terminology it means various technological work-plans. Let the p-th processing 
procedure be defined by a sequence of operations 
 
pr
p
p
p
o
o
o
O
...
~
2
1
=
 
(14.6) 

 
Job Scheduling 307 
where 
Ω
∈
pr
p
p
o
o
o
,...,
,
2
1
 are operations taken from the set Ω  defined in Equation 
(14.1). Each procedure is determined by its own sequence, e.g., the p-th procedure 
by 
p
O~ . There are several alternatives how to use the servers in a case when more 
servers can perform the same operation 
pj
o
 . It is the case when the required 
operation is included in several subsets 
i
Ω . It is assumed  that each operation 
depends only on one preceding operation, and a next operation can start after the 
preceding operation has been accomplished..  
A system SYST can be additionally completed with the input servers 
{
}
I
X
X
X
X
,...,
,
2
1
=
 and the output servers 
{
}
O
Y
Y
Y
Y
,...,
,
2
1
=
. Availability of an 
object to be processed can be specified by means of an input server. Analogously, 
output servers are used for outputs. A particular scheduling task can be defined as 
follows. A part available at an input server passes through a prescribed processing 
procedure realized on a chosen set of servers realizing a sequence of operations. 
Finally, the part appears at an output server ready for a next use. 
The scheduling problem formulation as presented above will be illustrated on 
an example. Figure 14.1 shows a manufacturing system with three servers, two 
inputs and two outputs. Let a technological work-plan be realized on the described 
manufacturing system. The work-plan is specified in Table 14.1. There are two 
kinds of products to be produced. The notation 
2
1 / S
S
 means an optional 
realization of the first technological step for the job 
1J  either on the server 
1
S  or 
on the server
2
S . Figure 14.1 depicts possible transportation routes of parts. 
Through X1, X2 parts are fed in a random sequence. When the manufacturing is 
finished, the manufactured parts are placed at the output servers Y1, Y2. For each 
job and each step of a particular work-plan operations are assigned so that the set 
of servers is 
{
}
3
2
1
,
,
S
S
S
S =
 and the set of operations is 
{
}
4
3
2
1
,
,
,
ω
ω
ω
ω
=
Ω
. The 
same operation can be prescribed in different jobs.  Keeping in mind the notation at 
Equation (14.2) we have 
 
 
X1 
X2 
Y2 
Y1 
S1 
S2 
S3 
 
Figure 14.1. Technological layout of the manufacturing cell 

308 Modeling and Control of Discrete-event Dynamic Systems 
 
{
} {
}
{
} {
}
{
} {
}
4
3
2
3
3
2
3
1
3
3
4
2
1
3
2
2
2
1
2
2
4
3
1
3
1
2
1
1
1
1
,
,
,
,
,
,
,
,
,
,
,
,
ω
ω
ω
κ
κ
κ
ω
ω
ω
κ
κ
κ
ω
ω
ω
κ
κ
κ
=
=
Ω
=
=
Ω
=
=
Ω
 
(14.7) 
Order of elements in equal sets of Equation (14.7) determines the element 
correspondence. Processing procedures are given by the following sequences: 
 
(
)(
)
(
)(
)
1
3
3
2
3
1
2
3
2
1
4
3
22
21
2
1
3
2
1
1
2
1
1
2
1
12
11
1
or
or
or
~
or
or
~
κ
κ
κ
κ
κ
ω
ω
κ
κ
κ
κ
ω
ω
=
=
=
=
=
=
o
o
O
o
o
O
 
(14.8) 
Table 14.1. A particular work-plan to be realised in the manufacturing cell 
Job J1 
Job J2 
Step 
Operation 
Available at 
Step
Operation 
Available at 
1 
1
ω  
S1/ S2 
1 
3
ω  
S1/ S3 
2 
2
ω  
S2/ S3 
2 
4
ω  
S1/ S2/ S3 
 
X1 
X2 
Y2 
Y1 
S1 
S2 
S3 
1
1 
2
2
3
3
1 
1 
2
2
1
3
3
2
2
 
Figure 14.2. Optional routes of workpieces in the processing according to the work-plan in 
Table 14.1 
Table 14.2. Operation times in the manufacturing cell  
Operation 
1
ω  
1
ω
2
ω
2
ω
3
ω
3
ω
4
ω
4
ω
4
ω  
Server 
S1 
S2 
S2 
S3 
S1 
S3 
S1 
S2 
S3 
Duration 
3 
4 
3 
2 
4 
2 
3 
4 
4 

 
Job Scheduling 309 
Figure 14.2 shows optional transfer of workpieces according to the work-plan 
given in Table 14.1. The operation times are given in Table 14.2. 
14.2  Job Scheduling and Petri Nets 
Job scheduling can be solved using Petri nets. There are many ways to use Petri 
nets for this purpose. Two approaches based on the scheduling analysis presented 
in the previous section will be presented. Timed Petri nets are always necessary.  
 
Figure 14.3. Petri net representation of the scheduling solution 
In the first approach, the binary timed safe Petri nets are considered, in which 
the scheduled operations are associated with timed places (Lee and DiCesare 1995). 
The timed places are mapped to times equal to the respective operation durations. 
A token is blocked after arriving in the timed place during the corresponding 
operation time. By convention, the operation time is expressed by the number of 
time units. After expiration of the time the token is free for transition firing under 
standard firing rules. Figure 14.3 shows a Petri net for the manufacturing cell 
depicted in Figure 14.1 and for the work-plan given in Table 14.1. The work-plan 
is cyclically repeated. It is assumed that there is sufficient stock of parts at the 
input. The cycle is finished when both parts to be processed are at the output. Only 
then does a new manufacturing cycle start. An alternative for a production 

310 Modeling and Control of Discrete-event Dynamic Systems 
optimization is to minimize the time (work-span) from start to end of one cycle. 
The optimal solution of scheduling chosen from possible routings can be achieved 
by means of the reachability graph. A time account has to be accomplished for the 
timed places in the reachability graph. A change in the Petri net marking is 
possible when the blocking time for some place has expired and some transition is 
fireable. 
The places 
2
1,
X
X
p
p
 stand for the input servers. Presence of a token in one of 
them indicates that a part is available for processing. An analogous notation is used 
for output. A timed place is denoted by 
1,1
,1 S
J
p
; it corresponds to an operation 
running in the job J1 on the server S1 in the step 1 and similarly for the rest of the 
operations. The place 
1,Ip
 is an intermediate place used to avoid potential 
deadlocks.  
If the reachability graph is too large, a suitable heuristic decision technique can 
be used to seek the optimum path, as in artificial intelligence methods. In such a 
case, only a part of the reachability graph nodes is considered. The sequence of 
nodes and the continuation towards the final node are selected according to some 
heuristic rule. For example, the next node to proceed in the graph is the one 
enabling unblocking at the earliest opportunity a timed place of the considered 
node. Such similar heuristic rules provide very good results in practice. 
Next, another way of using a Petri net is presented. Let a technological layout 
shown in Figure 14.1 be used for the work-plan given in Table 14.3. X1 is the input 
for the job J1 , Y1 is the output, X2 is the input for the job J2 , Y2 is the output. 
Table 14.3. Example of a work-plan to be realised in the manufacturing cell in Figure 14.1 
Job J1 
Job J2 
Step 
Operation 
Available at 
Step
Operation
Available at 
1 
1
ω  
S1/ S2 
1 
3
ω  
S1 
2 
2
ω  
S3 
2 
4
ω  
S3 
Table 14.4. Operation times in the manufacturing cell for the second example 
Operation 
1
ω  
1
ω
 
2
ω  
3
ω  
4
ω  
Server 
S1 
S2 
S3 
S1 
S3 
Duration 
4 
3 
3 
1 
2 
For this case operation times are given in Table 14.4.  There are two kinds of 
parts to be processed simultaneously available at the input. A part of the first 
(second) kind is processed into the first (second) kind of product.  
As in the previous example, the optimum manufacturing is considered in terms 
of the optimum of one production cycle. The servers perform the following 
different operations in the respective steps: 

 
Job Scheduling 311 
 
{
} {
}
{
} {
}
{
} {
}
4
2
2
3
1
3
3
1
1
2
2
3
1
2
1
1
1
1
,
,
,
,
ω
ω
κ
κ
ω
κ
ω
ω
κ
κ
=
=
Ω
=
=
Ω
=
=
Ω
 
(14.9) 
and processing is executed by the following sequences: 
 
(
)
2
3
2
1
4
3
22
21
2
1
3
1
2
1
1
2
1
12
11
1
~
or
~
κ
κ
ω
ω
κ
κ
κ
ω
ω
=
=
=
=
=
=
o
o
O
o
o
O
 
            (14.10) 
A special class of Petri nets supporting operation scheduling analysis and 
solution is defined in the following where the timed Petri net for the scheduling 
problem is given by the 6-tuple 
 
(
)
INH
c
M
W
F
T
P
TPNS
,
,
,ˆ
,
,
,
0
=
 
(14.11) 
where 
0
,
,
,
M
F
T
P
 are defined as usual. The function 
+
→N
P
c :
 associates 
capacities with  places, 
T
P
INH
×
⊆
is a set of inhibitors disabling transition 
firings if the source node of an inhibitor has at least one token. Timing consists in 
that the marking is a function of places and of the discrete time 
N
P
M
→
Θ
×
:
, 
{
}
....
,
2
1 ϑ
ϑ
=
Θ
, 
....
0
2
1
<
<
<
ϑ
ϑ
are discrete time points. Wˆ is a specially defined 
function 
 
(
)
{
}
ip
c
F
W
→
:
ˆ
   for
ip and 
T
t j ∈
∀
 for which (
)
F
p
t
i
j
∈
,
, 
 
{ }
1
→
F
  for (
) F
t
p
j
i
∈
∀
,
 
Firing of a transition 
jt  in the TPNS Petri net is enabled iff  
 
c
t
m
0
k
≤
+
=
j
ϑ
, 
(
)
0
m
m
k
TPNS
R
∈
ϑ
 
(14.12) 
where the actual marking M in the discrete time point 
k
ϑ is aggregated into the 
vector 
k
mϑ ; 
jt  is a vector associated with the transition 
jt ; 
(
)
0
m
TPNS
R
 is a 
reachability set. If the transition 
jt  is firable (enabled), a new marking is obtained 
according to the vector equation 
 
j
k
k
t
m
m
+
=
+
ϑ
ϑ
1
 
(14.13) 
Consider a system SYST according to Equation (14.1), which can be 
represented by the TPNS Petri net. The Petri net construction is as follows.  

312 Modeling and Control of Discrete-event Dynamic Systems 
t6
t1
t2
t7
t4
t3
t8
t5
o21S1
(1)
(1)
(2)
(4)
(5)
(3)
(4)
5
4
2
4
4
3
o11S2
o11S1
X2
X1
o22S3
o12S3
Y2
Y1
 
Figure 14.4. The Petri net representing the required processing 
Elements of the operation sequences 
p
O~  are associated with the TPNS places. 
For each 
S
i
r
v
o
i
pv
,...,
2,1
;
,...,
2,1
,
=
=
Ω
∈
 , a place denoted as 
i
pvS
o
 is put 
into the net. The place is given a capacity equal to 
1
+
ik
τ
, where 
ik
τ  is given by 
Equation (14.4). The arcs connecting the place 
i
pvS
o
 with all places 
(
)
i
v
p
S
o
1
+
 via 
post-transitions are added to the net. According to the TPNS definition weights of 
the arcs are 1 and (
)1
+
ik
τ
, respectively. Input and output servers are associated 
with corresponding places. The TPNS Petri net construction is depicted in Figure 
14.4. 
Inhibitors are used to prevent a transition firing when a token is in the 
respective place. Not to prevent the firing would be considered as a misuse of the 
already occupied server. 
The first step of the scheduling problem solution procedure is creation of the 
system model SYST defined by Equation (14.1). Operation times 
ik
τ  are expressed 
in terms of multiples of the basic sampling time period 
τ
Δ
, whereby 
τ
Δ
 is 
chosen as large as possible with respect to a sufficiently accurate representation of 
the system dynamics. 
The model SYST at Equation (14.1) is transformed into the TPNS Petri net. The 
initial marking represents input availability of the objects to be processed. It is non-
zero for the places associated with the input servers. Initial marking of places 
i
pvS
o
 is set to zero as well. Fireable transitions in the created TPNS Petri net are 
fired in discrete time points, which are multiples of the basic time period τ
Δ
, i.e., 
...
,
...,
,
2
,
,0
τ
τ
τ
Δ
Δ
Δ
k
. Prior to firing the transitions, the marking of each place 

 
Job Scheduling 313 
i
pvS
o
 is decreased by one if 
(
) 1
>
i
pvS
o
M
, otherwise it remains unchanged. After 
the marking is decreased, the fireable transitions are fired and a new marking is 
obtained. 
The obtained TPNS may contain conflicts reflecting existence of various 
possibilities of how to perform the required operation sequences. Consider the 
minimum time span criterion applied to the operation sequences. Hence the goal is 
to find out preferences among the possible ways of performing the operation 
sequence with respect to the specified cost function. 
The optimization problem can be solved using the reachability graph of the 
TPNS. The nodes of the graph correspond to the reachable markings 
k
ϑ
m
. Possible 
paths in the reachability graph corresponding to the individual required operation 
sequences can be analyzed in order to select the best solution with respect to the 
chosen criterion. 
The described approach will be illustrated on an FMS layout with a required 
work-plan defined in Table 14.3. As mentioned earlier, processing of the next pair 
of input parts can start when both products are ready at the output. The goal is to 
find the processing procedure requiring minimum overall time for processing one 
pair of the parts. The reachability graph of the TPNS Petri net is in Figure 14.5. 
There are three possible paths specifying the operation scheduling. The first, which 
starts with the activation of transition 1t , is the most time consuming. The other 
two are better with respect to the minimum work-span criterion. The path starting 
with 6t  is the best. 
In this section an approach to the scheduling problem solution using a special 
class of Petri nets is presented. It constitutes a framework to cope with the problem. 
The drawback of the solution is a tremendous increase of the nodes number in the 
reachability graph to be analyzed. One possibility to avoid this difficulty is to apply 
heuristic searches as mentioned in the description of the first approach in this 
section. The case of the dynamic processing of inputs during processing of the 
previous ones can be solved following the presented framework, too. 
14.3  Job Scheduling Based on the Max-plus Algebra 
The job scheduling problem in Sections 14.1 and 14.2 was studied under the 
restriction that each operation depends on one preceding and finished operation. 
But frequently there can be the dependence on more operations. Such dependence 
can be presented in a graphical form. Figure 14.6 shows an example. Circles 
represent operations and arc weights given as real numbers represent the necessary 
durations of the preceding operations, after which the next operation can start. For 
example, the second operation can start when time equal to 3 from the start of the 
first operation elapsed and time equal to 2 from the start of the third operation 
elapsed. Note that the example is adopted from Moßig and Rehkop (1996). 

314 Modeling and Control of Discrete-event Dynamic Systems 
 
  t2 
11 00000 00 
01 50000 00 
01 40000 00 
01 30000 00 
01 20000 00 
01 10000 00 
01 00040 00 
00 02030 00 
00 01020 00 
00 00040 01
00 00100 01
00 00101 00
00 00102 00
00 00103 00
00 01200 00
00 02300 00
01 00400 00
10 02000 00
00 01400 00
00 00303 00
00 00202 00
00 00101 00
00 00100 01
00 01010 00 
00 00030 01
00 01000 10 
00 00003 10 
00 00040 01
00 00300 01
00 00200 01
00 00020 01
00 00010 01
00 00100 01
00 00002 10 
00 00001 10 
00 00000 11 
t1 
t3 
 t6 
t5 
t7 
 t8 
t6
 t6
  t7
  t8
  t5
t2
t7
t8
t4
t5
Distribution of the places in the nodes 
 
2
1
3
22
3
12
2
11
1
21
1
11
2
1
Y
Y
S
o
S
o
S
o
S
o
S
o
X
X
 
Figure 14.5. A reachability graph considering duration of operations 

 
Job Scheduling 315 
 1 
2 
3 
4 
3
2
4
2
5
1
 
Figure 14.6. Graphical representation of operation dependence 
Note that there are no cycles in the graph in Figure 14.6. Such a situation will 
be supposed in the sequel until another assumption is made.   
The Petri net approach can be less effective if there is the operation dependence 
described above. The so-called max-plus algebra may be more productive. The 
max-plus algebra is used as a tool for modeling the time development operations 
and the scheduling problem can be solved on the simulation basis trying different 
operation setup. 
The max-plus algebra [
]
⊗
⊕,
,
max
R
is defined by: 
a. The fundamental set 
max
R
 
 
{
}
+∞
−∞
∪
=
,
max
R
R
 
(14.14) 
where R  is the set of real numbers;
+∞
−∞,
are additional elements, for 
which 
 
+∞
<
<
−∞
x
,     
R
x ∈
∀
  
(14.15) 
b. The binary operation ⊕, defined as the maximum of two real numbers – 
elements of  
max
R
, whereby the inequality at Equation (14.15) provides the 
result of the operation ⊕ for elements 
+∞
∞
−
,
.  
The operation ⊕ is commutative, associative, with the neutral element – ∞, 
and is idempotent (
a
a
a
R
a
=
⊕
−∞
=
−∞
⊕
∈
∀
,
max
). 
c. The binary operation ⊗, defined as  
 
R
b
a
b
a
b
a
∈
∀
+
=
⊗
,
,
 
(14.16) 
where + is the usual operation over the field of the real numbers [
].,
,+
R
. 
For the additional elements 
+∞
−∞,
 holds: 

316 Modeling and Control of Discrete-event Dynamic Systems 
 
−∞
=
+∞
⊗
−∞
=
−∞
⊗
∞
+
−∞
=
−∞
⊗
∞
−
+∞
=
+∞
⊗
∞
+
+∞
=
⊗
+∞
=
+∞
⊗
−∞
=
⊗
−∞
=
−∞
⊗
a
a
a
a
 
(14.17) 
d. The operation ⊗ is commutative, associative, and distributive over ⊕, i.e., 
 
(
)
(
)
(
)
(
)
(
)
(
)
b
c
a
c
b
a
c
c
b
c
a
c
b
a
R
c
b
a
⊗
⊕
⊗
=
⊕
⊗
⊗
⊕
⊗
=
⊗
⊕
∈
∀
,
,
,
,
max
. 
The following does not hold: 
(
)
(
)
(
)
c
b
c
a
c
b
a
⊕
⊗
⊕
=
⊕
⊗
 
for example, if  
 
(
)
(
)
[
]
(
)
(
)
[
]
[
]
12
6
6
6,3
max
6,2
max
6
3
6
2
6
6,
3
2
max
6
3
2
,6
,3
,2
=
+
=
+
=
⊕
⊗
⊕
≠
=
+
=
⊕
⊗
=
=
=
c
b
a
 
The neutral element in the operation ⊗is 0, as it is in the field of real 
numbers. The following holds 
+∞
=
+
∞
+
−∞
=
+
−∞
0
,
0
. 
From the viewpoint of algebraic structure theory the max-plus algebra 
[
]
⊗
⊕,
,
max
R
 as defined above is a special commutative field (sometimes simply 
called the field). It is because [
]
⊗
⊕,
,
max
R
 is a ring where [
]
⊗
,
max
R
 is a monoid 
and 
{
}
[
]
⊗
+∞
∞
−
−
,
,
max
R
 is a commutative group. In other words, [
]
⊗
,
R
 is a 
commutative group. 
The max-plus algebra can be extended to the fundamental set of matrices M. 
Let the matrix entries be elements of 
max
R
. The operation ⊕ then 
 
(
)
ij
ij
ij
b
a ⊕
=
⊕B
A
 
(14.18) 
where 
ij
a  is the entry in the i-th row and the j-th column of the matrix A, 
(
)
(
)
r
m
r
m
R
R
×
×
∈
∈
max
max
,B
A
. 
The operation ⊗ is given by 
 
(
)
(
)
(
)
(
)
(
)
n
r
r
m
kj
ik
k
kj
ik
r
k
ij
R
R
b
a
b
a
×
×
=
∈
∈
⊗
=
⊗
=
⊗
⊕
max
max
1
,
,
max
B
A
B
A
     
 
 
(14.19) 

 
Job Scheduling 317 
The max-plus algebra [
]
⊗
⊕,
,
M
 has the same properties as [
]
⊗
⊕,
,
max
R
 except 
for the neutral element in ⊕ being the  matrix 
 
(
)
−∞
=
=
ij
ij
n
n
,
N
 
(14.20) 
The neutral element in ⊗is the matrix 
 
( )
⎩
⎨
⎧
≠
∞
=
=
=
j
i
i
i
ij
ij
for
-
j
i
for
0
,
I
 
(14.21) 
The dependence of an operation on the others can be expressed by the equation 
 
(
)
j
ij
j
i
x
a
x
+
= max
 
(14.22) 
where 
jx  is the start time of the j-th operation preceding the i-th operation, 
ij
a is 
the time necessary to run the j-th operation before the i-th operation starts. Because 
the i-th operation depends on several operations, the start of 
ix  is given by 
Equation (14.22) as the maximum time of the preceding operation starts and the 
operation durations. 
The diagrams in Figure 14.7 illustrate the meaning of Equation (14.22). The 3rd 
operation can start only when the times 
31
a
 and 
32
a
 of the 1st and 2nd operations 
respectively have elapsed. The starting point of the 3rd operation is then 
 
(
)
3
'
2
'
1
3
,
max
x
x
x
x
=
=
 
(14.23) 
Using the max-plus algebra 
 
(
) (
)
(
)
k
k
j
ij
j
ij
j
ij
i
x
a
x
a
x
a
x
⊗
⊕
⊕
⊗
⊕
⊗
=
....
2
2
1
1
 
(14.24) 
Moreover, it is possible to extend Equation (14.22) by an additional time 
condition, namely that the i-th operation cannot start before a given time point 
iu . 
It can be either 
i
i
x
u >
 where 
ix  is calculated by Equation (14.22) and then the i-th 
operation starts in 
iu , or 
i
i
x
u <
 and then the i-th operation starts in 
.
ix  Extension 
of Equation (14.22) is as follows: 
 
(
)
i
j
ij
j
i
u
x
a
x
,
max
+
=
 
(14.25) 
In terms of the max-plus algebra  
 
(
) (
)
(
)
i
j
ij
j
ij
j
ij
i
u
x
a
x
a
x
a
x
k
k
⊕
⊗
⊕
⊕
⊗
⊕
⊗
=
....
2
2
1
1
 
(14.26) 

318 Modeling and Control of Discrete-event Dynamic Systems 
 
x1 
x2 
'
1x
3
'
2
x
x =
 t 
1st operation 
2nd operation 
3rd  operation 
 
Figure 14.7. Dependence of operations 
Using the matrix the dependence of n operations can be expressed as follows: 
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⊗
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⊕
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
⊗
⎟⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
=
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎟
⎠
⎞
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
n
nn
n
n
n
n
n
r
r
r
nn
n
n
n
n
n
r
r
r
u
u
u
b
b
b
b
b
b
b
b
b
x
x
x
a
a
a
a
a
a
a
a
a
x
x
x
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2
1
2
1
2
22
21
1
12
11
1
2
1
1
1
2
1
2
22
21
1
12
11
2
1
 
 
 
(14.27) 
or shortly 
 
(
)
(
)
u
B
x
A
x
⊗
⊕
⊗
=
−1
r
r
 
(14.28) 
where r denotes the r-th step of the iterative operation dependence. Recall that the 
dependence is without feedback loops, i.e., without cycles in the graph 
representation. One starts with the step for 
2
=
r
 and 
1
1=
−
r
 and continues with 
1
:
+
= r
r
. If there is no dependence between the j-th and i-th operation, the entry 
ij
a  in the matrix A is equal −∞. According to Equation (14.27) dependent 
operations are associated with the rows of the matrix (index i). Entries of matrix B 
are 0 or −∞. In the former case an additional time condition is put into force, in 
the latter there is no additional condition on the start. If there is no forced starting 
condition 
iu  is set to zero as illustrated in the accompanying example. Equation 
(14.28) represents the state equation of the system with operation dependence.  
In the example the state equation without additional starting conditions (Figure 
14.6) is considered:  

 
Job Scheduling 319 
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
⊗
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
−
−
−
−
4
1
3
1
2
1
1
1
4
3
2
1
5
1
4
2
2
3
x
x
x
x
x
x
x
x
r
r
r
r
r
r
r
r
 
            (14.29) 
The neutral element −∞ for the operation ⊕ is used when there is no 
dependence between two operations. The starting time point for the first operation 
is set to 
0
1
1
=
x
; e.g.,  
(
) (
) (
) (
) (
) (
)
3
1
1
1
4
1
3
1
2
1
1
1
2
2
3
2
3
x
x
x
x
x
x
x
r
r
r
r
r
r
r
−
−
−
−
−
−
⊗
⊕
⊗
=
∞⊗
−
⊕
⊗
⊕
∞⊗
−
⊕
⊗
=
 
 is a dependence, which can be verified by the graph in Figure 14.6. 
The development of the state equation is possible considering n operations in 
the system 
 
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
)
(
) (
)
u
B
I
A
A
x
A
u
B
u
B
A
u
B
A
x
A
u
B
u
B
A
u
B
A
x
A
u
B
u
B
A
u
B
x
A
A
u
B
u
B
A
x
A
u
B
u
B
x
A
A
u
B
x
A
x
⊗
⊗
⊕
⊕
⊕
⊕
⊗
=
⊗
⊕
⊕
⊗
⊗
⊕
⊗
⊗
⊕
⊗
=
⊗
⊕
⊗
⊗
⊕
⊗
⊗
⊕
⊗
=
⊗
⊕
⊗
⊗
⊕
⊗
⊕
⊗
⊗
=
⊗
⊕
⊗
⊗
⊕
⊗
=
⊗
⊕
⊗
⊕
⊗
⊗
=
⊗
⊕
⊗
=
−
−
−
−
−
−
−
−
−
....
.....
2
1
0
2
1
0
2
3
3
3
2
2
2
2
1
n
n
n
n
n
n
n
n
n
n
n
n
M
 
 
 
(14.30) 
Entries of the matrix 
n
A  are the maximum weight sums of the paths of the 
length n between the column and row operation pairs of the graph nodes. As there 
are no cycles in the graph  
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
=
=
.
.
.
.
.
.
.
.
.
.
N
An
 
(14.31) 
so that 
 
(
)
u
B
I
A
A
x
⊗
⊗
⊕
⊕
⊕
=
−
−
....
2
1
n
n
n
 
(14.32) 
In our example  

320 Modeling and Control of Discrete-event Dynamic Systems 
 
(
)
u
B
I
A
A
A
x
⊗
⊗
⊕
⊕
⊕
=
2
3
4
 
(14.33) 
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
⊗
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
⊗
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
=
0
0
0
0
0
0
0
0
0
5
1
7
0
2
2
0
4
0
4x
 
(14.34) 
where the first operation starts in time 0 and setting the entries of u to zero means 
that there is no forced starting condition applied. According to Equation (14.34)  
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
7
2
4
0
4
4
3
4
2
4
1
4
4
x
x
x
x
x
 
(14.35) 
Time developments of operations are depicted in Figure 14.8. 
Let the first and the second operation has the forced starting points 
1u  and 
2
u , 
6
1 =
u
, 
11
2 =
u
. Then Equation (14.30) becomes 
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
⊗
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
⊗
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
∞
−
∞
−
∞
−
∞
−
∞
−
∞
−
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
0
0
0
0
0
5
1
7
0
2
2
0
4
0
2
1
4
4
3
4
2
4
1
4
u
u
x
x
x
x
  (14.36) 
 
(
)
(
)
(
)⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
⊗
⊕
⊗
⊗
⊕
⊗
⊗
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
2
1
1
2
1
4
4
3
4
2
4
1
4
1
7
2
4
0
u
u
u
u
u
u
x
x
x
x
 
(14.37) 
and the result is 
 
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
=
⎟⎟
⎟
⎟
⎟
⎠
⎞
⎜⎜
⎜
⎜
⎜
⎝
⎛
13
8
11
6
4
4
3
4
2
4
1
4
x
x
x
x
 
(14.38) 

 
Job Scheduling 321 
 
x1 
x3 
 t 
1st operation 
2nd operation 
3rd operation 
4th operation 
x2 
x4 
 
Figure 14.8. The development of operations 
Figure 14.9 shows the operation diagrams in case of additional starting conditions. 
Additional starting conditions can be utilized in the solution when the graph of 
the operation dependences illustrated in Figure 14.6 contains cycles. The values of 
the vector u are changing during the steps of the iterative process analogous to 
Equation (14.30) and depend on the operation starting points according to the 
function  
x
R
u
1
−
=
r
r
 where R is a transfer matrix. The reader can learn more in 
(Dorn and Moßig 1997), and from the references listed therein. Optimal scheduling 
solution can be found by simulation approaches based on models obtained with the 
described method and by changing the system structure. 
 
x1 
x3 
 t 
1st operation 
2nd operation 
3rd operation 
4th operation 
x2 
x4 
 
Figure 14.9. Development of operations under additional starting conditions 
14.4 Problems and Exercises 
14.1. An actual technological process in a manufacturing system with two 
processing machines is given in the following table. 

322 Modeling and Control of Discrete-event Dynamic Systems 
Technologic steps 
Jobs 
 
J1 
J2 
1 
M1/M2 
M2 
2 
M2 
M1/M2 
The same input semi-products are manufactured in both jobs. Find an optimal 
process assuming that both jobs always start simultaneously. The start is possible 
whenever both products are at the output. Optimum is decided on the operation 
time basis according to the following table. 
Operation 
Duration 
O111 
2 
O112 
1 
O122 
3 
O212 
2 
O221 
1 
O222 
2 
Create a Petri net necessary for use of the heuristic scheduling method  where 
the schedule is searched for using the function 
( )
( )
( )
m
m
m
h
g
f
+
=
. m is a 
marking vector, g the shortest time to reach m , and h is the minimum time to be 
left of the remaining times to the end of the running operations in the state 
corresponding to m . On about 10 nodes of the reachability graph show the use of 
the method. 
14.2. Apply the max-plus algebra on the planning of the design activities 
characterized by the following figure. 
Figure 14.9. A graph of the design activities and their dependences 
Durations in the graph is in time units, e.g., months. Find when the whole design 
process could be on earliest finished using the max-plus algebra approach. 
A1
A2
A3
A4
2
1
3
1
2

 
Job Scheduling 323 
14.3. Duration of the processes in the distributed computer network and their 
dependences are depicted in Figure 14.10. Write the state equation of the process 
starts in term of the max-plus algebra. Calculate times when earliest can start 
separate processes. 
 
Figure 14.10. Dependences of the processes in the distributed computer network 
P1
P3
P2
2
2
3

 
References 
References for Chapter 1 
Bogdan S., Lewis F.L., Kovacic Z., Mireles J. Jr. (2006) Manufacturing Systems Control 
Design: A Matrix-based Approach. Springer, London. 
Cao X. R. (1989) A comparison of the dynamics of continuous and discrete event systems. 
Proc. IEEE, Vol. 77, No 1, pp.7–12. 
Cassandras C.G. (1993). Discrete event systems: Modeling and performance analysis. Irwin, 
Homewood, Boston. 
Cassandras C.G., Lafortune S. (1999) Introduction to Discrete Event Systems, Springer, NY. 
Frištacký N., et al. (1981) Programmable Logic Processors. SNTL Prague (in Czech),  
Frištacký N., Kolesár M., Kolenička J., Hlavatý J. (1990) Logic circuits. Alfa Bratislava (in 
Slovak).  
Ho Y.C. (1989) Dynamics of a discrete event system. Proc. IEEE, Vol. 77, No 1, pp. 3–6. 
Ho Y.C. (1991) Discrete event dynamic systems: Analyzing complexity and performance in 
the modern world. IEEE Press, New York. 
Ho Y.C., Cassandras C.G. (1983) A new approach to the analysis of discrete event dynamic 
systems. Automatica, Vol. 19, pp. 149–167.  
Jafari M. (1995) Supervisory control specification and synthesis. In: Zhou M.C. (ed.) Petri 
nets in flexible and agile automation. Kluwer Academic Publishers, Boston, MA, 1995. 
Jörgl H.P. (1993) Repetitorium regelungstechnik. R. Oldenbourg Verlag, Wien, München. 
Kozák Š. (2002) Development of control engineering methods and their applications in 
industry. In: Proc. of the 5th International Scientific-Technical Conference “Process 
Control 2002”. Kouty nad Desnou, Czech Republic, June 9–12, 2002, str. R218. 
Manna Z., Pnueli A. (1991) The temporal logic of reactive and concurrent systems. 
Springer-Verlag, New York. 
Marko H. (1986) Methoden der Systemtheorie. Springer Verlag, New York. 
Wonham W.M., Ramadge P.J. (1987) On the supremal controllable sublangauge of a given 
language. SIAM Journal on Control and Optimization, Vol. 25, pp. 637–659. 
Schnieder 
E. 
(1991) 
Braucht 
die 
Automatisierungstechnik 
eine 
Theorie? 
Automatisierungstechnik, Vol. 39, pp. 391–401. 
Stanat, D., McAllister D. (1977) Discrete mathematics in computer science. Prentice-Hall, 
Englewood Cliffs, NJ.  
Voigt, G., Cramer S. (1986) Diskontinuierliche technologische Prozesse. Akademie Verlag, 
Berlin. 
Zhou, M.C. DiCesare F. (1993) Petri Net Synthesis for Discrete Event Control of 
Manufacturing Systems. Kluwer Academic Publishers, Boston, MA, 1993. 

326 References 
Zhou M.C. (ed.) (1995) Petri nets in flexible and agile automation. Kluwer Academic 
Publishers, Boston. 
Zhou M.C., Venkatesh K. (1998)  Modeling, simulation and control of flexible 
manufacturing Systems: A Petri net approach. World Scientific, Singapore. 
References for Chapter 2 
Deo N. (1974) Graph theory with applications to engineering and computer science. 
Prentice-Hall, Englewood Cliffs, NJ. 
Harary F. (1969) Graph theory. Addison-Wesley, Reading, MA. 
Liu C.L. (1977) Elements of discrete mathematics. McGraw-Hill, New York. 
References for Chapter 3 
Carroll J., Long D. (1989) Theory of finite automata with an introduction to formal 
languages. Prentice-Hall, Englewood Cliffs, NJ. 
Hopcroft J.E., Ullman J.D. (1979) Introduction to automata theory, languages, and 
computation. Addison-Wesley, Reading, MA. 
References for Chapter 4 
Martins de Carvalho J.L. (1993) Dynamical systems and automatic control. Prentice-Hall, 
New York. 
Voigt G., Cramer S. (1986) Diskontinuierliche technologische prozesse. Akademie Verlag, 
Berlin. 
References for Chapter 5 
Tornambé A. (1995) Discrete-event system theory. World Scientific, Singapore. 
Krapp M. (1988) Digitale automaten. VEB Verlag Technik, Berlin. 
References for Chapter 6 
Hrúz B. (1994) Discrete event systems modeling and real-time control. Journal of Electrical 
Engineering, Vol. 45, No 10, pp. 363–370.  
Zöbel D. (1987) Programmierung von echtzeitsystemen. R. Oldenbourg Verlag, München. 
References for Chapters 7, 8 and 9 
Abel D. (1990) Petri neze für inmgenieure. Springer Verlag, Berlin. 
Češka M. (1994) Petriho sítě. Akademické nakladatelství CERM, Brno. 
David R., Alla H. (1992) Petri nets and Grafcet. Prentice Hall, New York. 
David R., Alla H. (1994) Petri nets for modeling of dynamic systems – a survey. Automatica, 
Vol. 30, No 2, pp. 175–202. 
Ezpeleta J., Colom J. and Martinez J. (1995). A Petri net based deadlock prevention policy 
for flexible manufacturing system. IEEE Trans. Robot. Automat., vol. 11, no.5, pp. 173-
184. 
Gao M., Zhou M.C., Huang X., Wu Z. (2003) Fuzzy reasoning Petri nets. IEEE Trans. on 
Systems, Man, and Cybernetics: Part A, 33(3), pp. 314–324. 
Gao M., Zhou M.C., Tang Y. (2004) Intelligent decision making in disassembly process 
based on fuzzy reasoning Petri nets,” IEEE Trans. on Systems, Man, and Cybernetics: 
Part B, 34(5), 2029–2034. 
Giua A. DiCesare F. (1993) Grafcet and Petri nets in manufacturing. In: Gruver W.A.,  
Boudreaux J.C. (eds.) Intelligent manufacturing: Programming environments for CIM.  
pp. 153–76, Springer-Verlag. 

 
References 327 
Hanzálek Z. (1998a) A parallel algorithm for gradient training of feedforward neural 
network. Parallel Computing, No 24, pp. 823–839. 
Hanzálek Z. (1998b) Algorithm modeling with Petri nets. IEEE Conference on  System, 
Man and Cybernetics Piscataway, pp. 214–220. 
Hirel C., Tuffin B., Trivedi K.S. (2000) SPNP: Stochastic Petri nets Version 6.0, 11th 
International 
Conference 
of 
TOOLS 
2000, 
Schaumburg, 
US. 
Also, 
http://www.ee.duke.edu/~chirel/IRISA/spnpInstructions.html 
Hrúz B. (1994) Discrete event systems modeling and real-time control. Journal of Electrical 
Engineeirng. Vol. 45, No 10, pp. 363–370. 
Hudák Š. (1999). Reachability analysis of systems based on Petri nets. Academic Press Elfa, 
Ltd., Košice. 
Jensen K. (1997) Coloured Petri nets.Vol. I., II., III., second edition, Springer, Berlin. 
John K.-H., Tiegelkamp M. (2001) IEC 61131-3: Programming industrial automation 
systems. Springer, Berlin. 
König R. and Quäck L. (1988) Petri-netze in der steuerungs- und digitaltechnik. Oldenbourg 
Verlag, München. 
Jeng M.D. and Peng M.Y. (1999) Augmented Reachability Trees for 1-Place-
Unbounded Generalized Petri Nets. IEEE Trans. on Systems, Man, and 
Cybernetics, 29(2), pp. 173-183. 
Li Z. and Zhou M.C. (2004) Elementary Siphons of Petri Nets and Their 
Applications to Deadlock Prevention in Flexible Manufacturing Systems. IEEE 
Trans. on Systems, Man, and Cybernetics, 34(1), pp. 38-51. 
Li Z. and Zhou M.C. (2006) Two-stage method to design liveness-enforcing Petri 
net supervisor for FMS. IEEE Trans. on Industrial Informatics, Vol. 2, No. 4, 
pp. 313-325. 
Murata T. (1989) Petri nets: properties, analysis and applications. Proc. IEEE, Vol. 77, No 4, 
pp. 541–580. 
Peterson J. (1981) Petri net theory and the modeling of systems. Prentice Hall, Englewood 
Cliffs, NJ. 
Petri C.A. (1962) Kommunikation mit automaten. Thesis, Schriften des Instituts für 
Instrumentelle Mathematik, No 3, Bonn University. 
Schnieder E. (ed.) (1992) Petrinetze in der automatisierungstechnik. R. Oldenbourg Verlag, 
München. 
Starke P.H. (1990) Analyse von Petri-netz-modellen. B.G. Teubner, Stuttgart. 
Svádová M., Hanzálek Z. (2001) Tool demonstration in ICATPN 2001, Newcastle upon 
Tyne, University of Newcastle, pp. 35–39. 
Wang F.-Y., Gao Y., Zhou M.C. (2004) A modified reachability tree approach to analysis of 
unbounded Petri nets. IEEE Trans. on Systems, Man, and Cybernetics: Part B, Vol 34, 
No. 1, 303–308. 
Wu N.Q. Necessary and sufficient conditions for deadlock-free operation in flexible 
manufacturing systems using a colored Petri net model, IEEE Trans. on Systems, Man, 
and Cybernetics, Part C, vol. 29, no. 2, pp. 192–204, 1999. 
Wu N.Q., Zhou M.C. (2001) Avoiding deadlock and reducing starvation and blocking in 
automated manufacturing systems. IEEE Transactions on Robotics and Automation, vol. 
17, no.5, pp. 657–668. 
Wu N., Zhou M.C. (2004) Deadlock modeling and control of automated guided vehicle 
systems. IEEE/ASME Trans. on Mechatronics, 9(1), pp. 50–57. 
Wu N., Zhou M.C. (2005) Modeling and deadlock avoidance of automated manufacturing 
systems with multiple automated guided vehicles. IEEE Trans. on Systems, Man, and 
Cybernetics: Part B, 35(6), pp. 1193–1202. 

328 References 
Zhou M.C., Leu M.C. (1991) Modeling and performance analysis of a flexible PCB 
assembly station using Petri nets. Transactions of the ASME. Journal of Electronic 
Packaging, Vol. 113, No 4, pp. 410–416.  
Zhou M.C. (ed.) (1995) Petri nets in flexible and agile automation. Kluwer Academic 
Publishers, Boston. 
Zhou M.C. Twiss E. (1996) Discrete event control design methods: A review. Preprints of 
13th IFAC World Congress, San Francisco, CA, Vol. 9, pp. 401–409. 
Zhou M.C., Venkatesh K. (1998)  Modeling, simulation and control of flexible 
manufacturing Systems: A Petri net approach. World Scientific, Singapore 
References for Chapter 10 
Ajmone Marsan M., Balbo G., Conte G., Donatelli S., Franceschinis G. (1995) Modeling 
with generalized stochastic Petri nets. John Wiley & Sons, New York. 
Asar A.U., Zhou M.C., Caudill R.J. (2005) Making Petri nets adaptive: a critical review. 
Proc. of IEEE Int. Conf. on Networking, Sensors and Control, Tucson, AZ, March 19–
21, 2005, pp. 644–649. 
Bause F., Kritzinger P.S. (1996) Stochastic Petri nets. Verlag Vieweg,, Wiesbaden. 
Campos J., Chiola G., Colom J.M. Silva M. (1992). Properties and performance bounds for 
timed marked graphs. IEEE Trans. On Circuits and Systems –I, 39(5), pp. 386–401. 
Cardoso J., Camargo H. (1999) Fuzziness in Petri nets. Physica-Verlag, Springer Verlag 
Company, Heidelberg. 
Čapek J., Hanzálek Z. (2000) STPN model of physical and MAC layer of lonworks. 
Preprints of the IFAC Conference on Control Systems Design, Bratislava, June 18-20, 
2000, pp.335–340. 
Čapkovič F. (1993) Modelling and justifying discrete production processes by Petri nets. 
Computer Integrated Manufacturing Systems, Vol. 6, No 1, pp. 27–35. 
Čapkovič F. (1994) Petri net-based approach to the maze problem solving. In: Balemi S.,  
Kozák P., Smedinga R. (eds.) Discrete event systems: Modelling and control, 
Birkhäuser Verlag, Basel, pp. 173–179. 
Čapkovič F. (1998) Knowledge-based control synthesis of discret event dynamic systems. In: 
Tzafestas S.G. (ed.) Advances in manufacturing, decision, control and information 
technology, Springer, London. 
Chen S., Ke J., Chang J. (1990) Knowledge representation using fuzzy Petri nets. IEEE 
Trans. Knowledge and Data Engineering, Vol.2, No. 3, pp.311–319. 
Desel J. (2000) Simulation of Petri net processes. Preprints of the IFAC Conference on 
Control Systems Design, Bratislava, June 18-20, 2000, pp.14-25. 
Gao M., Zhou M.C., Huang X., Wu Z. (2003) Fuzzy reasoning Petri nets. IEEE Trans. on 
Systems, Man, and Cybernetics: Part A, Vol. 33(3), pp. 314–324. 
Genrich H.J., Lautenbach K. (1981) System modeling with high-level Petri nets. Theoretical 
Computer Science, Vol. 13, 1981, North-Holland, pp.109–136. 
Hanisch H.M. (1993) Analysis of place/transition nets with timed arcs and its application to 
batch process control. In: Marsan M.A. (ed.) Applications and theory of Petri nets. 
Lecture Notes in Computer Science 691, Springer, pp. 282–299. 
Hirel C., Tuffin B., Trivedi K.S. (2000) SPNP: Stochastic Petri Nets. Version 6.0. In:  
Haverkort B., Bohnenkamp H., Smith C. (eds.) 11th international conference computer 
performance evaluation: modelling tools and techniques Schaumburg Il., USA. Lecture 
Notes in Computer Science 1786, Springer. 
Hilion H.P., Prpth J.M. (1989) Performance evaluation of job-shop systems using timed-
event-graphs. IEEE Trans. On Automatic Control, Vol. 34, pp.3–9. 
Hrúz B., Mrafko L., Bielko V. (2002) A comparison of the AGV control solution 
approaches using Petri nets.  Proc. of the 2002 IEEE International Conference on 
Systems, Man and Cybernetics, Yasmine Hammamet, Tunisia, October 6–9, 2002. 

 
References 329 
Jensen K. (1981) Colored Petri nets and the invariant method. Theoretical Computer Science, 
Vol. 14, pp. 317-336 
Jensen K. (1997) Coloured Petri nets.Vol. I., II., III., second edition, Springer, Berlin. 
Juhás G. (2000) A unified approach to modelling and control of a class of discrete event and 
hybrid systems via algebraically generalized Petri nets. Preprints of the IFAC 
Conference on Control Systems Design, Bratislava, June 18–20, 2000, pp. 349–354. 
Li X., Yu W., Lara-Rosano F. (2000) Dynamic knowledge inference and learning under 
adaptive fuzzy Petri net framework. IEEE Trans. System, Man, and Cybernetics, Part C, 
Vol. 30(4), pp. 442–450. 
Li Z., Zhou M.Z. (2006) Two-stage method to design liveness-enforcing Petri net supervisor 
for FMS. IEEE Trans. on Industrial Informatics, Vol. 2, No. 4, pp. 313–325. 
Morioka S., Yamada T. (1991). Performance evaluation of marked graphs by linear 
programming. Int. J. of Systems Science, 22(9), 1541–1552. 
Ribarič S., Bašič B.D. (1998) Fuzzy time Petri net primitives for processing fuzzy temporal 
knowledge. Proc. of the 9th Mediterranean Electrotechnical Conference, May 18-20, 
1998, Tel-Aviv, Vol. 1, pp.549–553. 
Struhar M. (2000) A fuzzy object Petri net model applied for control. PhD Dissertation, 
Faculty of Electrical Eng. and Information Technology, Slovak University of 
Technology, Bratislava. 
Yeung D.S., Tsang E.C.C. (1998) A multilevel weighted fuzzy reasoning algorithm for 
expert systems. IEEE Trans. System, Man, and Cybernetics, Part A: Systems and 
Humans, Vol. 28, No.2, pp. 149-158. 
Uzam M., Zhou M.C. (2006) An improved iterative synthesis method for liveness Enforcing 
supervisors of flexible manufacturing systems,” Int. J. of Production Research, Vol. 44, 
No. 10, 1987–2030. 
Wang J. (1998) Timed Petri nets: Theory and application, Kluwer Academic Publishers, 
Boston, MA. 
Wu N.Q. (1999) Necessary and sufficient conditions for deadlock-free operation in flexible 
manufacturing systems using a colored Petri net model. IEEE Trans. on Systems, Man, 
and Cybernetics, Part C, vol. 29, no. 2, pp. 192–204. 
Wu N.Q., Zhou M.C. (2001) Avoiding deadlock and reducing starvation and blocking in 
automated manufacturing systems. IEEE Transactions on Robotics and Automation, 
17(5), pp. 657–668. 
Wu N.Q., Zhou M.C. (2004)  Modeling and deadlock control of automated guided vehicle 
systems. IEEE/ASME Transactions on Mechatronics, vol. 9, no. 1, pp. 50–57. 
Wu N., Zhou M.C. (2005) Modeling and deadlock avoidance of automated manufacturing 
systems with multiple automated guided vehicles. IEEE Trans. on Systems, Man, and 
Cybernetics: Part B, 35(6), pp. 1193–1202. 
Wu, N. and Zhou M.C. (2007) Deadlock and Blocking-free Shortest Routing of Bi-
directional Automated Guided Vehicles. IEEE Trans. on Mechatronics, 12(1), 
pp. 63-72. 
Wu, N. and Zhou M.C. (2007) Deadlock-free scheduling for semiconductor track 
systems based on resource-oriented Petri nets. OR Spectrum, 29(3), pp. 421–
443. 
Wu, N. and Zhou M.C. (2007) Deadlock modeling and control of semiconductor 
track systems using resource-oriented Petri nets,” Int. J. of Production Research, 
45(15), pp. 3439–3456. 
Zhou M.C. and Venkatesh K. (1998)  Modeling, simulation and control of flexible 
manufacturing Systems: A Petri net approach. World Scientific, Singapore. 

330 References 
Zhou M.C., Zurawski R. (1995) Introduction to Petri nets in flexible and agile automation. 
In: Zhou M.C. (ed.) Petri nets in flexible and agile automation, Kluwer Academic 
Publishers, Boston, MA, 1–42. 
References for Chapter 11 
Eshuis R. (2006) Statecharting Petri nets. Technical report (BETA working paper 153), 
Eindhoven University of Technology, available at http://is.tm.tue.nl/staff/heshuis/pn2sc-
beta.pdf. 
Fogel J. (1997) A statecharts approach to the modeling of discrete manufacturing systems. 
Proc. of the 7th Symposium on Computer Aided Control Systems Design, Gent, April 
28–30, 1997. 
Fogel J. (1998) A statecharts approach to the modelling and simulation of discrete 
manufacturing systems. In: Frankovič B. (Ed.) Control Theory and Applications, Veda, 
Bratislava, str. 33–44. 
Harel D. (1987) Statecharts: A visual formalism for complex systems. Science of Computer 
Programming, North Holland, Vol. 8, pp.231–274. 
Harel D., Pnueli A., Schmidt J.P., Sherman R. (1987) On the formal semantics of statecharts. 
Proc. of the 2nd IEEE Symp.on Logic in Computer Science, New York, pp.54–64. 
Harel D., Politi M. (1998) Modeling reactive systems with statecharts: the STATEMATE 
Approach. McGraw-Hill. 
Lee, J. S., Zhou M.C., and Hsu P. L. (1995) Statechart modeling and Web-based 
simulation of hybrid dynamic systems for e-Automation. Journal of Chinese 
Institute of Industrial Engineers, 22(1), pp. 19-27. 
Schnabel M.K., Nenninger G.M., Krebs V.G. (1999) Konvertierung sicherer Petri-netze in 
statecharts. Automatisierungstechnik, Vol. 47, No 12, pp. 571–580. 
References for Chapter 12 
Abel D. (1990) Petri neze für inmgenieure. Springer Verlag, Berlin. 
Brand K.P., Kopainsky J. (1988) Principles and engineering of process control with Petri 
nets. IEEE Trans. On Automatic Control, Vol. 33, No 2, pp. 138–149. 
Ferrarini L. (1992) An incremental approach to logic controller design with Petri nets. IEEE 
Trans. on Systems, Man, and Cybernetics, Vol. 22, pp. 461–473. 
Ferrarini, L. Narduzzi, M. and Tassan-Solet, M. (1994) A new approach to modular 
liveness analysis conceived for large logic controllers' design. IEEE Transactions 
on Robotics and Automation, 10(2),  pp. 169 - 184. 
Ferrarini L. (1995). Computer aided design of logic controllers with Petri nets. In: Zhou, 
M.C. (ed.) (1995) Petri nets in flexible and agile automation. Kluwer Academic 
Publishers, Boston, pp. 71–92. 
Hrúz B. (1997) A design method of the conflict-free Petri net models for the manufacturing 
systems control. Proc. of the 2nd IFAC Workshop on New Trends in Design of Control 
Systems, Bratislava, Sept. 7-10, 1997, pp. 259–264.  
Hrúz B., Jörgl H.P., Kopčok I.K., Kozák Š. (2000) Control of the bouncing ball laboratory 
experiment with an Allen–Bradley PLC. Proc. of IFAC/IEEE Symposium on Advances 
in Control Education ACE 2000. Sea World Nara Resort, Gold Coast, Australia, 
December17–19, 2000. 
Hrúz B., Niemi A., Virtanen T. (1996) Composition of conflict-free Petri net models for 
control of flexible manufacturing systems. Proc. of the 13th IFAC World Congress, San 
Francisco, Vol. B, pp. 37–42. 
Hrúz B., Ondráš J., Flochová J. (1997) Discrete event systems – an approach to education. 
Proc. of the 4th IFAC Symposium on Advances in Control Education, 14-16 July, 1997, 
Istanbul, pp. 283–288. 

 
References 331 
Mudrončík D., Zolotová I. (2000) Industrial programmable logic controllers. Publishing 
House Elfa, Ltd., Košice. 
Murata T. (1989) Petri nets: properties, analysis and applications. Proc. IEEE, Vol. 77, No 4, 
pp. 541–580. 
Niemi A. J., Ylinen R., Heikkilä A., Niemi E., Virtanen T. (1992) Automatic FMC with 
vision as test bed for control methods. Int. Journal of Advanced Manufacturing 
Technology, Vol. 7, pp. 353–659. 
Quäck L. (1991) Aspekte der Modellierung und realisierung der steuerung technologischer 
prozesse mit Petri-netzen. Automatisierungstechnik, Vol. 39, No 4, pp. 116–120, No 5, 
pp. 158-164. 
Reißenweber B. (1988) Programmieren mit PEARL. Oldenbourg Verlag, München. 
Venkatesh K., Zhou M.C., Caudill R.J. (1995) Discrete event control design for 
manufacturing systems via ladder logic diagrams and Petri nets: A comparative study. In: 
Zhou, M.C. (ed.) (1995). Petri nets in flexible and agile automation, Kluwer Academic 
Publishers, Boston, pp. 265–304. 
Werum W., Windauer H. (1989) Introduction to PEARL. Process and Experiment 
Automation Realtime Language. Vieweg, Braunschweig. 
Zhou M.C., DiCesare F. (1991) Parallel and sequential mutual exclusions for Petri net 
modeling of manufacturing systems with shared resources. IEEE Trans. on Robotics and 
Automation, Vol. 7, pp. 515–527. 
Zhou M.C. DiCesare F. (1993) Petri net synthesis for discrete event control of 
manufacturing systems. Kluwer Academic Publishers, Boston, MA, 1993. 
Zhou M.C., DiCesare F., Desrochers A.A. (1992) A hybrid methodology for synthesis of 
Petri net models for manufacturing systems. IEEE Trans. on Robotics and Automation, 
Vol. 8, No 3, pp.350–361. 
Zhou M.C., DiCesare F., Rudolph D.L. (1992) Design and implementation of a Petri net 
based supervisor for a flexible manufacturing system. Automatica, Vol. 28, pp. 1199–
1208. 
Zhou M.C., McDermott K., Patel P.A. (1993) Petri net synthesis and analysis of a flexible 
manufacturing system cell. IEEE Trans. on Systems, Man, and Cybernetics, Vol. 23, No 
2, pp. 523–531. 
Zhou M.C., Twiss E. (1998) Design of industrial automated systems via relay ladder logic 
programming and Petri nets. IEEE Trans. on Systems, Man, and Cyberentics, Part C: 
Applications and Reviews, Vol. 28, pp. 137–150. 
Zhou M.C., Venkatesh K. (1998)  Modeling, simulation and control of flexible 
manufacturing Systems: A Petri net approach. World Scientific, Singapore. 
Zöbel D. (1987) Programmierung von echtzeitsystemen. R. Oldenbourg Verlag, München. 
References for Chapter 13 
Balemi S., Hoffman G.J., Gyugyi P., Wong-Toi H., Franklin G.F. (1993) Supervisory 
control of a rapid thermal multiprocessor. IEEE Trans. on Automatic Control, Vol. 38, 
pp. 1040–1059.  
Flochová J., Hrúz B., Jirsák P. (1997) Program solution of supervisory control based on 
Petri nets. Proc. of the 1st IFAC Workshop on New Trends in Design of Control Systems, 
Bratislava, Sept. 7-10, 1997, pp.278–282. 
Flochová J., Lipták R., Boel R.K. (2001) A MATLAB-based Petri net supervisory controller 
discrete event systems. Proc. of the IFAC Workshop on Programmable Devices and 
Systems, Gliwice, Poland, November 22-23, 2001, pp. 119–126.  
Giua A., DiCesare F., Silva M. (1992) Generalized mutual exclusion constraints on nets 
with uncontrollable transitions. Proc. of the 1992 IEEE International Conference on 
Systems, Man, and Cybernetics, Chicago, pp. 974–979. 

332 References 
Harušťák M., Hrúz B. (2000) Supervisory control of discrete event systems and its solution 
with the Petri net P-invariants. Preprints of the IFAC Conference on Control Systems 
Design, Bratislava, June 18-20, 2000, pp.390–394. 
Holloway L.E., Krogh B.H. (1990) Synthesis of feedback control logic for a class of 
controlled Petri nets. IEEE Trans. on Automatic Control, Vol. 35, No 5, pp. 514-523. 
Hrúz B. (1994) The supervisory control problem solved via Petri nets. Proc. of the 1st IFAC 
Workshop on New Trends in Design of Control Systems, Bratislava, Sept. 7–10, 1997, 
pp.386–391. 
Jafari M.A. (1995) Supervisory control specification and synthesis. In: Zhou, M.C. (ed.) 
(1995) Petri nets in flexible and agile automation, Kluwer Academic Publishers, Boston, 
pp. 337–368. 
Moody J.O., Antsaklis P.J. (1998) Supervisory control of discrete event systems using Petri 
nets. Kluwer Academic Publishers, Boston. 
Ramadge P.J., Wonham W.M. (1989) The control of discrete event systems. Proc. of the 
IEEE, Vol. 77, pp. 81–98. 
Uzam M., Zhou M.C. (2006) An improved iterative synthesis method for liveness Enforcing 
supervisors of flexible manufacturing systems. Int. J. of Production Research, Vol. 44, 
No. 10, pp.  1987–2030. 
Wonham W.M., Ramadge P.J. (1987) On the supremal controllable sublangauge of a given 
language. SIAM Journal on Control and Optimization, Vol. 25, pp. 637–659. 
Yamalidou K., Moody J., Lemmon M., Antsaklis P. (1996) Feedback control of Petri nets 
based on place invariants. Automatica, Vol. 32, pp. 15–28. 
References for Chapter 14 
Dorn C., Moßig K. (1997) Erweiterter Steuerungsentwurf für ereignisdiskrete 
Systeme mit Hilfe der Max-Plus-Algebra. Automatisierungstechnik, pp. 407-413. 
Engell S. (1989) Modeling and on-line scheduling of flexible manufacturing systems. Proc. 
of the IFAC/IFORS/IMACS Symposium on Large Scale Systems 89, August 29–31, 
1989, Berlin, pp. 379–383. 
Frankovič B, Budinská I. (1998) Single and multi machine scheduling of jobs in production 
system. In Tzafestas, S.G. (ed.) Advances in manufacturing, decision, control and 
information technology, Springer, London. 
Hrúz B. (2000) A class of the timed Petri nets used for the solution of scheduling. Preprints 
of the IFAC Conference on Control Systems Design, Bratislava, June 18–20, 2000, 
pp.361–365. 
Lee D.Y., DiCesare F. (1994) Scheduling flexible manufacturing systems using Petri nets 
and heuristic search. IEEE Trans. on Robotics and Automation, Vol. 10, pp. 123–132. 
Lee D.Y., DiCesare F. (1995) Petri net-based heuristic scheduling for flexible 
manufacturing. In: Zhou M.C. (ed.) (1995) Petri nets in flexible and agile automation, 
Kluwer Academic Publishers, Boston, pp. 149–187. 
Li S., Takamori T., Tadokoro S. (1995) Scheduling and re-scheduling of AGVs for flexible 
and agile manufacturing. In: Zhou, M.C. (ed.) (1995) Petri nets in flexible and agile 
automation, Kluwer Academic Publishers, Boston, pp. 189–205. 
Moßig K., Rehkopf A. (1996) Einführung in die Max-Plus–algebra zur beschreibung 
ereignisdiskreter dynamischer  prozesse. Automatisierungstechnik, Vol. 44, No 1, pp. 3–
9. 
Xiong, H.H., Zhou M.C. (1998) Scheduling of Semiconductor Test Facility via 
Petri Nets and Hybrid Heuristic Search. IEEE Transactions on Semiconductor 
Manufacturing, 11(3), pp. 384-393. 
Zhou M.C., Venkatesh K. (1998)  Modeling, simulation and control of flexible 
manufacturing Systems: A Petri net approach. World Scientific, Singapore. 
 

 
Index 
acceptor     49 
accessible     65, 270, 276, 277 
definition     269 
ACT_T     238 
action     165, 212 
activated     164 
active     162, 165, 209, 242 
state     69 
active step     162 
acyclic     199 
Ada     234 
adaptive Petri net     195, 197 
AGV     see automatic guided vehicle 
airport traffic     291 
alphabet     33, 34, 50 
ALPHIC     235 
antecedent proposition     196 
APN     see adaptive Petri net 
artificial intelligence     310 
artificial neural network     195 
assembly cell     213 
assembly Petri net     157 
augmented marked graph     157 
augmented marking     118 
automated manufacturing system 
example     99 
automatic control     4 
automatic guided vehicle     190, 285 
system     188 
back-propagation algorithm     200 
BASIC     235 
basic design modules     223 
behavior     84 
restriction     263 
binary fuzzy operation     191 
binary operation 
⊕     315 
associativity     315 
commutativity     315 
⊗     315 
associativity     316 
commutativity     316 
binary Petri net     93 
binary Petri net model     239 
binary relation     5 
bipartite oriented graph     162 
bipartite oriented labeled mathematical 
graph     169 
BIT     235 
blocking     219 
Boolean algebra     13 
Boolean variable     246 
bottleneck      
analysis     180 
cycle     179 
example     180 
bottom-up     218 
bounded fair     128 
bounded Petri Net 218 
example     126 
boundedness     115, 153, 218 
branch     163 
branching     65 

334 Index 
branching operation conflicts     229 
CALL     235 
cardinality     137 
Cartesian product     6, 49 
CASE – ALT – OUT – FIN     235 
certainty factor     196 
CHARACTER     235 
choice     228 
Petri net     221 
circle     23 
CLOCK     235 
co-accessible     270, 276, 277 
definition     269 
co-domain     5, 306 
color     177, 185 
set     187 
type     187 
colored Petri net     92, 177, 185, 188 
commutative field     316 
commutative group     316 
compiler     235 
complex     186 
composition method     219 
concatenation     17, 38 
concurrency     149, 212, 217 
concurrent     151 
condition     164 
conflict     152, 204, 225, 248 
conjunctive rule     196 
connected     27 
consequent     196 
conservativeness     129 
context grammar     37 
context-free grammar     37 
context-free languages     37 
continuous system     1 
continuous-variable dynamic system     
1 
control     42, 55 
action     44 
automaton     58, 274 
command     96 
engineering     4 
finite automata 
example     65 
function     42 
performance     42 
place     293 
program     46, 234 
example     243 
requirement     293 
specification     162, 234 
system     42, 46, 56, 188 
design     46 
variable     42, 43 
controllability     263 
controllable     262, 264 
controllable event     262 
controlled system     4, 65, 262 
convex possibility distribution     192 
coordination     223, 305 
coverability graph     118 
construction algorithm     122 
definition     119 
example     121 
node     120 
covered     116 
CPN Tools     20  
CP-net     185, 190 
Cramer’s rule     142 
CVDS     see continuous-variable 
dynamic system 
cycle     27 
cycle time     179 
cycle time reduction     180 
cyclic behavior     217 
cyclic repetition     63 
cyclic sampling     64 
Δ-incidence matrix    134, 135, 137, 
140, 152, 287 
data     235 
database system     305 
DCL     235 
deactivated     164 
deactivation     165 
dead     125, 153 
dead marking     115, 152 
deadlock     204, 270 
decision block     63 
decision-free choice Petri net     221 
declaration     186 
DECLARE     235 
6

 
Index 335 
DEDS     see discrete-event dynamic 
system 
default state     212 
deterministic     92 
deterministic finite automaton     49, 50 
example     51 
with outputs     55, 56, 57, 280 
Deterministic Stochastic Petri Nets     
181 
DFA     see deterministic finite 
automaton 
DFAO     see deterministic finite 
automaton with outputs 
DID_IO_INIT     245 
digraph     25 
dimensionality problem     282 
direct loop     85, 86 
directed arc     23 
directed bi-partite labeled simple graph     
80 
directed cycle     27 
directed multigraph     28 
directed path     27 
disassembly Petri net     157 
discrete-event dynamic system     3, 34, 
41, 217, 261 
example     13 
discrete event systems     3 
discrete process     6, 42 
discrete system     1 
discrete variable     5 
disjunctive     24, 228 
distributed computer system     305 
distribution AND     163 
distribution OR     164 
distributive     319 
divergence OR     165 
DSPN     see Deterministic Stochastic 
Petri Nets 
durable     212 
DURATION     235 
dynamic behavior     81 
electro-pneumatic motion drive     250 
elementary control task     219 
elementary net     250 
elementary non-binary Petri net      
example     250 
elementary Petri net     247 
elementary SCSM     220 
elementary structures     227 
elimination method     228 
empty sequence     33 
empty set     49 
empty word     35 
enabled     70 
definition     78 
END     238 
enumeration     179 
ESPN     see Extended Stochastic Petri 
Net 
event     4, 12, 33, 44, 164, 210, 261 
graph     93 
string     262 
event-driven system     3 
exceptions     235 
exclusive-or activities     210 
executable     115 
expert system      
example     199 
exponential computational complexity     
179 
exponentially distributed     180 
Extended Stochastic Petri Net     181 
external event     234 
fairness     128 
feedback     43 
feedback control structure     43 
feedback system     217 
field     319 
filling and mixing system     111 
final state     49, 52 
finite automaton     10, 38, 49, 64, 69, 
261 
example     52, 131 
with outputs     281 
finite-capacity Petri net     99 
example     101 
finite-state machine     37 
fireability     81, 87, 108 
fireable     78, 96, 108, 164, 178 
firing     70, 78 
rate     180 

336 Index 
rule     70 
threshold     196 
first-level Petri net     220 
FIXED     235 
flexibility     307 
flexible     8 
flexible manufacturing system, 52, 305 
example     82, 89, 96, 232 
FLOAT     235 
flow chart     63 
flow diagram     46, 63 
flow relation     77 
FMS     see flexible manufacturing 
system 
FOR – FROM – BY – TO – REPEAT 
– END     235 
formal grammar     34, 36 
example     36 
formal language     10, 33, 50 
example     34 
generator     50 
Forth     234 
free-choice net     93 
example     95 
Frobenius theorem     135 
function     49 
fuzziness     191 
fuzzy logic     195 
fuzzy number     191, 194 
fuzzy operation     191 
fuzzy Petri net     191 
fuzzy production rule     195 
fuzzy reasoning     198 
fuzzy set     60, 191 
fuzzy set theory     191 
fuzzy temporal relation     192 
fuzzy time point     192 
fuzzy token     192 
general one-transition structure     237 
Generalized Stochastic Petri Net     181, 
203 
generation rule     37 
generator     50 
GET     235 
grafcet     162 
Grafcet     10, 161, 169 
graph component     25 
graph node     178 
GreatSPN     203 
GSPN     see Generalized Stochastic 
Petri Net 
Heuristic decision technique     310 
heuristic rule     310 
hierarchical decomposition     219 
hierarchically higher Petri net     219 
higher-level Petri net     219 
high-level Petri net     185 
homogenous equation     284 
hybrid system     2 
idempotent     315 
IF – THEN – ELSE – FIN     235 
immediate transition     181 
immediately reachable     79 
impulse     165 
action     166 
IN     235 
INA     204 
inactive     162 
incidence matrix     25, 82 
incidentor     87, 228 
example     90, 112, 231 
incoming arc     231 
independency     212 
inhibitor     87, 228, 312 
arc     220 
example     88, 90, 112, 242 
initial element     35 
initial marking     77, 187 
definition     79 
example     194 
initial state     49, 187 
initial step     163 
INOUT     235 
input     44 
function     79 
place     72, 77 
step     166 
interrupt     64, 234 
mechanism     65 
intersect     228 

 
Index 337 
j-bounded     115 
job realization     226 
job scheduling     305 
join     163 
junction AND     163 
junction OR     164 
keyword     245 
Kleene closure     39 
knowledge-based system     195 
L0-live     125, 153 
L1-live     125, 153 
L2-live     125, 153 
L3-live     125, 153 
L4-live     125, 153 
ladder diagram     246 
example     251 
ladder logic diagram     10, 234 
language      
example     36 
language generator     269 
learning     202 
law     202 
rate     202 
length     33, 50 
level     165 
action     165 
kind     212 
live     125, 153, 218 
livelock     270 
liveness     124, 218 
example     125 
Lk-live     125 
logic expression     164 
looping     65 
macrostep     166 
manufacturing cell     69 
example     173, 298 
manufacturing line     240 
example     185 
manufacturing system     307 
example     6, 8, 299 
marked     156, 238 
marked graph     93, 178, 224, 227 
marked language     50, 51 
marked trap     157 
marking      
definition     77 
reachability     107 
Markov chain     181, 183 
matrix representation     85 
maximally permissive     284 
maximum strongly connected 
subdigraph     28 
max-plus algebra     10, 315 
membership function     191 
merging operation conflict     229 
minimal     157 
minimum cycle time     179 
modeling power     87 
modularity     234 
module     235 
monoid     316 
multiplicity     28 
multiset     28 
Nassi-Schneiderman’s structogramme     
111 
net      
definition     76 
inscription     186 
structure     186 
neural network     200, 202 
neutral element     319 
node     23 
non-deterministic finite automaton     
60 
non-directed graph     24 
non-labeled digraph     23 
non-marked     238 
non-terminal element     34 
object     1 
Occam     234 
operation     306 
dependence     315 
scheduling     305 
time     312 
operational block     63 
ordinary Petri net     93, 188 
oriented arc     87 
orthogonal state     212 

338 Index 
OUT     235 
outgoing arc     228 
output     44, 56 
output function     56 
definition     79 
example     59 
place     77 
step     166 
P/T Petri net     186 
parallel     65 
parallel mutual exclusion     221 
parallel Petri net     221 
parallel places     219 
parallel processes     234 
parallel transitions     219 
parallelism     149 
partial control action     242 
partial function     49 
partial injection mapping     272 
partial subdigraph     26 
partial transition function     50 
path     27, 50 
PC     96 
PCB     see printed circuit board 
PCN     295 
pcontr     262 
PEARL     234 
performance analysis     179 
persistent     128 
Petri net     10, 25, 69, 169, 217, 261  
basic structure     248 
definition     77 
example     71, 132, 241 
for control 
example     233 
interpreted for control     91, 96, 
169, 213, 218, 237, 295 
interpreted for DEDS control     95 
model     220 
example     74, 225 
state machine     92 
structure     227 
with capacities     92 
P-invariant     134 
method     290 
support     136 
vector     284 
piston motion system     252 
place     72, 76 
place delay function     178 
place-invariant     283 
PLC     see programmable logic 
controller 
polling     65 
post-place     108, 178 
post-set     156 
post-step     164, 165 
post-transition     95 
power set     60 
prefix     263 
closed language     263 
example     264 
language     263 
pre-place     78, 95, 108, 178, 229 
preset     77 
pre-set     156 
pre-step     164 
PREVENT     238 
printed circuit board     90 
PROBLEM     235 
problem division     235 
PROCEDURE     235 
process     1 
control     261 
synchronization     234 
product of automata     61 
production execution time     185 
production Petri net     157 
production rule     35 
productivity     179 
program module     235 
programmable logic controller     161, 
247 
programming language     234 
prohibited state     262 
proper subdigraph     26 
pure     86 
pure Petri net     85, 108 
push-down automata     37 
PUT     235 
random variable     180 
randomly distributed time     183 

 
Index 339 
rank     284 
reachability     152 
graph     107, 109, 296, 310 
construction algorithm     110 
example     113, 126, 183, 314 
set     79, 109 
example     115 
reachable     79, 95, 107, 109, 152, 218 
reactive flow diagram     10, 256 
reactive program     45, 46, 64, 234 
reactive system     212 
READ     235 
realizable     261 
realizable transition invariant     204 
real-time operating system     234 
real-time programming language     
238 
receptivity     164 
refined Petri net model     224 
refinement     212 
regular expression     38, 58 
example     39 
regular grammar     38 
regular language     38, 58 
relation     5 
repetitive     64 
requirements     262 
resource sharing     221 
resource-oriented modeling method     
100 
RETURN     235 
reversibility     127, 155, 218 
reversible     137, 155, 218 
definition     127 
reward function     203 
robotic cell     41, 232 
robotic manufacturing cell     70, 138 
example     233 
robotized manufacturing system     60 
root     29, 109 
route optimization problem     188 
routes     308 
rule 
example     37 
rung     247, 248 
safe     170 
safe Petri net     95 
sampling frequency     66 
scheduling analysis     309 
SCSM     see strongly connected binary 
Petri net state machine 
self-loop     220 
self-loop places     219 
self-loop transitions     219 
SEMA     235 
SEND     235 
separator     56 
sequence     33, 261 
sequence Petri net     221 
Sequential Function Chart     161 
serial mutual exclusion     221 
series places     219 
series transitions     219 
shared resource     185 
shuffle automaton     64, 276 
sigmoid function     198 
simple labeled directed mathematical 
graph     24, 109 
simple non-labeled digraph     25 
simple non-labeled directed 
mathematical graph     23 
simple path     27 
sink     164 
siphon     156 
source     164 
SPC     235 
specification     42, 217 
SPECIFY     235 
SPNP     203 
SRN     see stochastic reward net 
standard Petri net     177 
standard single-layer neural network     
201 
state     4, 11, 49, 209 
encapsulation     209 
equation     319 
hierarchy     209 
space     282 
transfer     210 
variable     41, 44 

340 Index 
statechart     10, 209 
state-event     60 
STATEMATE     212 
step     162 
stochastic     92 
stochastic reward net     203 
stochastic timed Petri net     180 
strict     163 
strict minimal siphon     163 
strictly conservative     131 
string     33, 50, 261 
strong component     28 
strongly connected     27, 178 
strongly connected binary Petri net 
state machine     219 
STRUCT     235 
structural property     161 
structural purity condition     85 
structurally bounded     161 
structurally live     156 
structure     84 
subdigraph     26 
subgraph     25 
sub-language     261 
submarine system     297 
subnet     185 
subprogram block     63 
subsystem     43 
superstate     209 
supervisory control     261 
supplementary control place     283 
supplementary controller     284 
supplementary place     283 
support     136 
supremal controllable sublanguage     
265, 274, 279 
supremal sublanguage     270, 274 
supremum     192, 266 
symbol     34 
synchronization     93, 162, 217, 219, 
220 
synchronized Petri net     96 
syntax rule     235 
syntax sign     245 
system     1, 2, 42 
behavior     42 
deadlock     115 
state     44 
throughput     184 
SYSTEM     235 
TAKE     235 
tardiness     305 
TASK     236 
temporal logic     10 
terminal element     34 
TERMINATE     238 
time delay     180 
time diagram     45, 166 
timed     92 
timed binary marked graph     178 
timed marked graph     178 
example     180 
timed Petri net     309 
timed place     310 
timed transition     181 
time-dependent     42 
time-driven systems     3 
T-invariant     134 
token     72, 77, 178 
example     82 
top-down     218 
top-down approach     220 
top-down refinement     220 
TPNS     312 
transfer matrix     321 
transformation program     63 
transit     212 
transition     11, 12, 49, 65, 76, 162, 
248 
basic model     11 
basic system     209 
firing     70 
sequence     107 
time function     178 
function     52, 60 
rate matrix     183 
transport system     285 

 
Index 341 
trap     156, 204 
tree     29 
triangular form     193 
trim     270 
automaton      
example     277 
definition     269 
finite automata     271 
type 0 grammar     37 
type 1 grammar     37 
unbounded Petri net     116 
example     116 
unboundedness     152 
uncertainty     60 
uncontrollable event     262, 288 
union     38, 65 
universe of discourse     191 
unreachable     118 
utilization     305 
vertices     23 
weight function     77 
Weighted Fuzzy Production Rule     
195 
word     33 
generation     35 
work-plans     306 
work-span     8 
WRITE     235 
 
 

