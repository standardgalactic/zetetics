A Game-Centered, Interactive Approach for Using Programming Exercises in
Introductory Physics
Orban, C.∗, Porter, C. D, Smith, J. R. H., and Brecht, N. K.
Department of Physics, The Ohio State University, Columbus, OH, 43210
Britt, C. A.
ASC Tech, The Ohio State University, Columbus, OH, 43210
Teeling-Smith, R. M.
Marion Technical College, Marion, OH, 43302 and
University of Mt.
Union, Alliance, OH, 44601
Harper, K. A.
Department of Engineering Education, The Ohio State University, Columbus, OH, 43210∗
(Dated: June 2, 2017)
Incorporating computer programming exercises in introductory physics is a delicate task that
involves a number of choices that may have a strong aﬀect on student learning. We present an
approach that speaks to a number of common concerns that arise when using programming exercises
in introductory physics classes where most students are absolute beginner programmers.
These
students need an approach that is (1) simple, involving 75 or fewer lines of well-commented code,
(2) easy to use, with browser-based coding tools, (3) interactive, with a high frame rate to give
a video-game like feel, (4) step-by-step with the ability to interact with intermediate stages of
the “correct” program and (5) thoughtfully integrated into the physics curriculum, for example, by
illustrating velocity and acceleration vectors throughout. We present a set of hour-long activities for
classical mechanics that resemble well-known games such as “asteroids”, “lunar lander” and “angry
birds”. Survey results from the ﬁrst activity from four semesters of introductory physics classes at
OSU in which a high percentage of the students are weak or absolute beginner programmers seems
to conﬁrm that the level of diﬃculty is appropriate for this level and that the students enjoy the
activity. These exercises are available for general use at http://compadre.org/PICUP In the future
we plan to assess conceptual knowledge using an animated version of the Force Concept Inventory
originally developed by [1].
I.
INTRODUCTION
The need to incorporate programming content into in-
troductory physics is widely appreciated by the academic
community [2]. By some estimates, at least 70% of new
STEM jobs in the US will require computer program-
ming skills [3] and in the sciences computer programming
skills have become an essential part of many disciplines.
In response to these shifts, groups like code.org and the
“hour of code” have brought coding tutorials to wider
and younger audiences [4]. These groups also inﬂuenced
federal education legislation in the US. In particular, the
Every Student Succeeds Act (ESSA), which was signed
into law in December 2015, designates computer science
as a “core subject” for the ﬁrst time. This is a signiﬁcant
change that places computer science on the same level
as english and mathematics [5]. The 2017-2018 school
year will be the ﬁrst school year that this legislation will
be fully implemented. Yet, for physics instruction, and
perhaps even more generally, the task of re-imagining
STEM courses with computer science as a crucial element
is still far from complete. Although there is signiﬁcant
∗orban@physics.osu.edu
research [6] and a number of universities using vpython
[7] in calculus-based introductory physics, vpython exer-
cises are much less often used in algebra-based physics
and at the high school level. There is some evidence that
the approach is too diﬃcult for this level. [8] describes a
masters degree project by a high-school physics teacher
who worked for two years to develop a vpython curricu-
lum for a 9th grade high school physics class and found
that only 1/3rd of the class successfully completed the
exercises and perhaps only 20% understood the itera-
tive nature of the physics as intended. While [8] used
a small sample (N = 32), the results underscore the
need to develop a curriculum that adds programming into
algebra-based physics with a higher success rate. In this
paper we discuss an approach that that diﬀers from the
vpython exercises described by [8] and in the vpython-
based Matter & Interactions curriculum [9] in important
ways.
The content we describe here also compliments
the existing computational exercises that are hosted on
the AAPT Partnership for Integrating Computation into
Undergraduate Physics (compadre.org/PICUP) by pro-
viding content that is aimed at algebra-based physics
and non-major physics courses [10]. For convenience we
have made the exercises described here available on the
PICUP site.
arXiv:1701.01867v2  [physics.ed-ph]  1 Jun 2017

2
What the approach we describe here and other com-
putational physics education eﬀorts have in common is a
desire to change how students experience physics courses
and how they think about physics [7, 11]. Programming
activities represent a kind of third “canvas” for illustrat-
ing physics ideas besides pen & paper calculations and
laboratory exercises [12]. Whereas pen and paper activ-
ities tend to emphasize mathematical calculations that
describe how forces take an initial state of a system to a
ﬁnal state over some time interval, programming activ-
ities emphasize how forces can act in an iterative sense
over a number of much smaller time intervals to produce
the same behavior. This may seem like a subtle distinc-
tion, but to a student learning physics for the ﬁrst time,
and who may have been exposed to computer program-
ming ideas through activities like code.org, they may ﬁnd
programming activities in physics to be more intuitive
than pen & paper calculations or laboratory exercises
and some authors argue that numerical exercises high-
light the physics of complicated interactions in a clearer
way [7, 13].
To other students who may be comfort-
able with pen & paper calculations, programming activi-
ties provide another perhaps unfamiliar context to apply
their physics knowledge.
To the extent that expertise
involves the ability to accurately apply concepts in unfa-
miliar situations [14], programming activities can provide
an interesting challenge to students – do they understand
physics well enough to program a computer to simulate
a physics problem?
While there are plenty of reasons to be optimistic
about adding programming content to introductory
physics [e.g. 15–18], and in this paper we describe a
speciﬁc implementation in use at Ohio State Univer-
sity (OSU) that we are beginning to test in high-school
physics classes, it should be said that there are unan-
swered questions about whether these activities provide
physics learning gains beyond conventional web interac-
tives [e.g. 19, 20] where the student does not see the un-
derlying code. Another re-statement of this question is:
under what conditions does working with a physics simu-
lation code cause students to think more deeply about the
physics content? As the title of this paper suggests, our
hypothesis is that students must both develop a computer
program step-by-step and participate in goal-oriented
game-like activities in interacting with this program to
appreciate the physics on a deeper level. Although there
are some exceptions, goal-oriented game-like activities
are typically not a part of programming exercises at the
introductory level. In the Matter & Interactions curricu-
lum that integrates vpython into calculus-based physics
[9], many of these programs, such as a three-body grav-
itational simulation or the 3D pendulum [7], are writ-
ten for the student to passively watch except perhaps for
changing the perspective. And while there are a large
number of exercises currently available on the AAPT’s
Partnership for the Integration of Computation into Un-
dergraduate Physics (compadre.org/PICUP), only few of
them involve a high level of interactivity. But there some
groups that focus on science-based computer activities
in primary and secondary schools appreciate the impor-
tance of video-game like goals [18, 21].
Proving the value of game-like activities in program-
ming exercises in a deﬁnitive way is beyond the scope of
this paper. Instead we will here describe a set of seven
diﬀerent computer programming activities designed for
absolute beginner programmers in introductory physics
(mechanics) classes. Survey results from four semesters
of student data that probe student experiences with the
ﬁrst exercise will be presented. We also describe an as-
sessment framework that we plan to use that is based on
an animated version of the Force Concept Inventory [1]
that we have reconstructed from various sources and in
a way that that can be used on modern computers and
without any java dependencies. A larger study with more
deﬁnitive conclusions will be described in future work.
We believe that the exercises described in the next
section fulﬁll many of the basic requirements of any ap-
proach to incorporating programming into introductory
physics in classes with absolute beginner programmers.
These students need an approach that is
1. simple, involving about 75 or fewer lines of well-
commented code, and no calculus knowledge
2. easy to use, with browser-based coding tools that
include real-time bug-ﬁnding capabilities
3. interactive, with a fast frame rate (≈60 frames per
second), high-quality 2D graphics and responsive
keyboard controls
4. step-by-step, including the capability for students
to interact with correct versions of the intermedi-
ate stages of the program but without seeing the
correct code,
5. and thoughtfully incorporated into the physics cur-
riculum.
The following sections will focus especially on the ﬁrst
and ﬁfth items above. Regarding items 2, 3, and 4 we use
a programming framework called processing that was de-
veloped to give artists a simple but graphically powerful
programming language to create interactive art [22]. We
ﬁnd that this framework, which uses a syntax similar to
C/C++, is very capable of producing 2D physics interac-
tives that run at a very high frame rate (≈60 frames per
second) on modest computers, such as the chromebook
laptops that most high schools have on hand. Frame-rate
is key to producing smooth-running interactives that are
passable as video games.
Processing also has built-in
aliasing that takes advantage of high-resolution screens.
Importantly, processing can produce these high-quality
interactive visualizations using any browser and without
any required installations or plugins. This removes the
tedious step of conferring with IT staﬀto install soft-
ware on each computer and periodically upgrading this
software if there are updates. The framework can also

3
be used to allow students to interact with as many in-
termediate stages of the program as necessary without
revealing the code.
Processing is a free resource with
good documentation and an active, growing community.
Processing has two diﬀerent browser-based coding meth-
ods, of which p5.js [23] is the more developed method
that we highlight here.
Although there is good work in the literature describ-
ing how numerical exercises can be connected with lab-
oratory exercises [e.g. 12], we consider this out of scope
for the present work. Processing does have capabilities
to interact with Arduino circuit boards [22, 24], making
this an interesting possibility for future work.
II.
OVERVIEW OF PROGRAMMING
ACTIVITIES FOR MECHANICS
In a semester course of introductory physics at Ohio
State University at the regional campus in Marion, we
include six required programming activities and a sev-
enth activity that is optional or extra credit. In most
other ways the course is identical to the same course on
the Columbus campus.
The oﬃcial description of this
course is calculus-based physics I, but on all OSU cam-
puses students only need to be concurrently enrolled in
calculus in order to take the course, and as a result the
calculus content in the course is limited. Moreover, the
students at OSU’s regional campuses are less prepared
than their peers on OSU’s Columbus campus. Both of
these facts make this course an interesting venue for inte-
grating programming exercises into introductory physics
with the end goal of creating a curriculum that might
succeed in the high school physics classroom.
Each activity is designed to take about an hour to com-
plete. To date, about 125 students from OSU’s regional
campus in Marion have completed the exercises described
here.
All of the exercises illustrate the velocity, acceleration
and force vectors using the same color scheme for these
vectors used by the textbook. All of the exercises build
oﬀof each other in a way that would make it hard for
a student to start in the middle, and the ﬁrst exercise
gives the student much of the code that they will need,
only asking them to modify certain parts of the code
in certain ways as will be discussed in the next section.
All of the exercises contain optional “challenges” that
encourage the student to develop some functionality that
often adds an interesting element to the game. The last
two exercises utilize a graphing system that we developed
in order to show, for example, how vy changes with time
in a projectile problem, or how the x position of some
object oscillates. The list of exercises is as follows:
1. Planetoids (similar to the classic game “Asteroids”)
2. Lunar descent (similar to the classic game “Lunar
lander”)
3. Bellicose birds (similar to the popular game “angry
birds”)
4. Planetoids with momentum
5. Planetoids with torque
6. Planetoids with a spring (harmonic motion)
7. Extra credit: Bellicose birds with energy
The choice of an asteroids-like game for the ﬁrst ac-
tivity is intentional. This puts the student in the frame
of reference as a rocket in free space, which is a situa-
tion where the laws of physics are particularly simple. In
the second exercise (“Lunar descent”), adding two lines
of code to the planetoids exercise is all that is needed
to add gravity to the interactive simulation.
And in
the third exercise (“Bellicose birds”), only a handful of
changes are needed to convert the “lunar descent” ac-
tivity into something that resembles the popular game
“angry birds”. The task in this exercise is to draw the
expected trajectory of a bird-like projectile before it is
launched. Exercises 4-7 will be discussed later.
This sequence is designed to accompany a typical
physics course where momentum is not introduced un-
til mid-way through the course, followed by concepts of
torque and, later, harmonic motion. The energy exercise
is made available to students in the middle of the course
when energy is introduced, but this exercise is more dif-
ﬁcult than the others as will be discussed later.
III.
PLANETOIDS: THE FIRST
PROGRAMMING ACTIVITY
The natural environment for illustrating Newton’s laws
is free space, away from any sources of gravity. In such
an environment, objects in motion will of course con-
tinue with the same velocity, moving in a straight line,
unless a force is acting on it. The classic game “aster-
oids” illustrates this well with a ship that drifts through
free space, except when its rockets ﬁre to avoid asteroids
that are also drifting through free space. The net force
is either zero, or constant and in the direction the ship is
pointing.
A.
Structure of the Program and Choices
Fig. 1 shows what the student sees at the beginning of
this exercise. Initially, the ship can only move in the x
direction and the ﬁrst task is to allow the ship to rotate
when the user presses the left and right arrow buttons
by changing the value of θ. It is worth commenting on
Fig. 1 in detail because even at this stage there are a
number of choices that have been made that could aﬀect
student learning. One important choice made to simplify
the cognitive load for the student is to “hide” a signiﬁ-
cant amount of code in the display() function. In this

4
FIG. 1. The code (left) and corresponding interactive (right) that the student sees at the beginning of the ﬁrst exercise. This
code is written with the processing javascript library p5.js. As a result, the code has a C/C++ like syntax except that draw()
replaces main() and draw() is run 60 times per second until the user stops the program. The interactive (right) shows a ship
traveling towards the right with constant velocity indicated by a red velocity vector. On the left panel the student sees about
50 lines of code, but about half of these lines are spaces or comments.
example, there are about 3× more lines of code deﬁning
the display() function than the ≈50 lines of code that
the student sees and modiﬁes.
Another important choice is to hide the variable types.
There are no float, int, double or var declarations
used to initialize the variables. Instead, variables are im-
plicitly declared to be ﬂoating point decimals and the
number of characters that the student sees is minimized.
This syntax is essentially the same as used in matlab,
which is a popular language for absolute beginner pro-
grammers. We use the processing javascript library p5.js
for these exercises and as a result the code shown in Fig. 1
is javascript which does not produce an error for missing
variable types. A possible drawback of postponing the
discussion of variable types is that the diﬀerence between
global and local variables is not explained at this stage.
Students may not realize that accelx, which is only used
and deﬁned inside of an if statement, is a local variable
while deltaVx is a global variable, but this is unlikely
to cause a problem at this stage. Our philosophy is to
explain subtleties like these in the step-by-step tutorial
only if absolutely necessary for completing a particular
exercise.
The structure of the program in Fig. 1 is an important
choice that may aﬀect student learning. The sections of
the code are as follows:
1. Variable initializations
2. the draw() function – velocity and position advance
3. the draw() function – keyboard inputs
4. the draw() function – display() function followed
by other user-deﬁned graphics
It is understood that the draw() function is run many
times per second so that after the display() function
is executed the program will go back to the beginning
of draw() and advance the velocity and position again

5
and go through the whole sequence again until the user
presses stop.
Because draw() is being run again and
again, one could easily change the sequence so that, for
example, the display() function would be ﬁrst and the
velocity and position advance would be last. The draw-
back of this approach is that when the student parses the
code for the ﬁrst time they would see the physics content
of the code last. Perhaps a computer science instructor
would have written the exercise with that order since,
from their point of view, there is nothing special about
the physics part of the code.
Putting the physics section at the earliest place it can
be shows the student how familiar ideas like d = vt are
implemented in a computer code before getting into un-
familiar syntax like keyboard commands.
Although it
is not explained to the student until much later in the
energy exercise, the integration scheme is Euler-Cromer
[25]. Following the physics section there is a line of code
∆vx = 0 which is accompanied by a comment “veloc-
ity is unchanged if there are no forces”. This is just a
restatement of Newton’s ﬁrst law in a form that a com-
puter can understand. Following this the program checks
if the user is pressing certain buttons on the keyboard.
The drawback to this physics-ﬁrst, keyboard com-
mands later approach is that the student may not fully
appreciate that the program holds on to the global vari-
able deltaVx, which is determined from the keyboard
command section, only using it again at the beginning
of the next iteration of draw(). In fact, many students
struggle to appreciate that draw() is run again and again.
An interesting line of inquiry would be whether this tacit
understanding that the special function draw() is exe-
cuted many times causes more confusion than it elimi-
nates by keeping the code very compact.
In a couple of steps the user is asked to put non-zero
values in the section of the keyboard input section that
changes the angle of the ship. Then the student is asked
to enable motion in the y direction by imitating the code
for advancing the velocity and position in the x direc-
tion. Finally, the student is asked to determine the cor-
rect change in velocity due to a constant force (thrust) in
the y direction. This involves realizing that while cos θ
gives the component of the force oriented in the x direc-
tion, one must use sin θ to obtain the component of the
force in the y direction. In this way the activity assumes
trigonometry knowledge.
At each step in the tutorial, the student can click links
to see and interact with how the program should work
at a particular stage, but without seeing the source code
for the completed step. This is an important capability
that gives the student instant guidance on whether they
have completed a particular programming task correctly,
leaving the instructor more time to spend on subtle is-
sues.
Common mistakes that students make include forget-
ting to set ∆vy = 0, in which case the ship accelerates
uncontrollably in the y direction. Students also tend to
do a quick copy paste of the acceleration code without
changing the trigonometric function from cosine to sine.
This causes ∆vy = ∆vx and as a result the ship only
travels on a diagonal line.
B.
Challenges
Students must also implement 1-2 “challenges”. The
challenges in this exercise include creating “planetoids”
(a word play on the astronomical term planetesimals)
that drift across the screen using the ellipse() func-
tion and adding reverse thrusters when the down arrow
is pressed (which can be done by copying the code from
the up arrow and adding minus signs to change the di-
rection of the force). Students can also allow the ship
to shoot a projectile using the point() function and the
code includes an if statement that detects if spacebar is
pressed for this purpose. This task is the more diﬃcult
than the others because the projectile must be launched
in the same direction as the ship whereas the planetoids
can be given a random velocity using the random() func-
tion. One can also include the velocity of the ship when
determining the velocity of the projectile as a fun illus-
tration of Galilean invariance. Most students will just
implement the reverse thrusters challenge.
For students who create “planetoids” as their chal-
lenge, a interesting activity would be to ask the student
to change the mass of the ship and the force of the rocket
thruster to ﬁnd the best combination for avoiding plane-
toids. The student may realize through this activity that
it is only the ratio of the force to the mass that matters
for determining the acceleration of the ship. Because of
the length of Exercise 1, this is typically not done until
Exercise 5, but with more class time this would be an
interesting option.
1.
Student data
A few weeks into the course, after the student com-
pletes the ﬁrst exercise there is a detailed online survey
that probes their experience in completing the activity.
While the questions in this survey are qualitative and in-
volve student self-reporting, the results can oﬀer insight
on whether the level of diﬃculty of the ﬁrst exercise is
appropriate and whether students ﬁnd the exercises to
be enjoyable to complete. Appendix A shows the precise
wording of the questions that were used in the survey.
Fig. 2 summarizes the results of the survey from four
semesters of students (Spring 2015 – Fall 2016).
The
upper left plot in Fig. 2 shows that there is a signiﬁcant
number of absolute beginner programmers and weak pro-
grammers in the class. As noted in the appendix, the full
wording of the “some experience” option for this question
is “Yes, I have some experience with programming but
I still feel like I have a lot to learn (For example: you
took a programming course or are taking a programming
course now, or have learned some programming on your

6
No
Yes, a little bit
Some experienceSignificant experience
0
5
10
15
20
25
30
35
Number of Student Responses
Have you ever written or modified a computer program before?
Ntot = 83
Easy
Semi−easy Semi−difficult
Difficult!
           Extremely Difficult!
0
5
10
15
20
25
30
Number of Student Responses
Level of Difficulty
Ntot = 81
Not really
A little bit
Somewhat
It helped a lot!
0
5
10
15
20
25
30
35
Number of Student Responses
Did the programming lab help you understand vectors better?
Ntot = 85
Not really
Somewhat
It was enjoyable It was a lot of fun
0
5
10
15
20
25
30
35
40
Number of Student Responses
Was the programming lab fun?
Ntot = 80
FIG. 2. Survey results from Ohio State Marion students who completed the ﬁrst programming exercise (rocket in free space).
Results are cumulative from four semesters of students (Spring 2015 - Fall 2016).
own in some other context.)” The high percentage of stu-
dents selecting this option is likely from students who
take physics and an introductory C++ course concur-
rently. Many of these students may have been absolute
beginner programmers at the beginning of the semester.
The upper right plot in Fig. 2 shows that the diﬃ-
culty level seems to be appropriate for the population of
students, with a signiﬁcant number of students selecting
“Easy!”. The lower right plot in Fig. 2 indicates that
many of the students found the programming activities
to be enjoyable or fun. The options in these plots corre-
spond exactly to the options in the survey as discussed in
the appendix. Students also have many positive things
to say about the programming exercises in written eval-
uations at the end of the course after all of the exercises
have been completed.
Regarding the bottom left plot in Fig. 2, student re-
porting of learning gains should be met with skepticism.
We regard the results for this question ”Did the program-
ming lab help you understand vectors better?” primarily
as a gauge of student perceptions of how connected (or
disconnected) the programming activities are from other
course material. The mixed results from this question
underscores the need to carefully integrate the exercise
with instructional material and targeted assessment as
we discuss later. In the absence of this, students may re-
gard the activity as just another video game even when
velocity and acceleration vectors are illustrated, as they
are in this example. We outline our plan for more de-
tailed assessment in Sec. X.
IV.
EXERCISE 2: CONSTANT
GRAVITATIONAL ACCELERATION
In Exercise 2, the student needs to add a variable g
to the beginning of the program and set it to the value
1.63 which is the gravitational acceleration constant on
the moon in m/s2 units. For simplicity, we follow pro-
cessing’s convention in using pixel values for distances
which means that the 750x500 pixel window that shows
the interactive is in reality 750 meters × 500 meters wide.
In both the previous exercise and this exercise we use a
time interval of ∆t = 0.1 for each iteration of the draw()
function. Although it is not explained to the student,
this implies that a interactive running at 60 frames-per-
second is really showing 6 simulated seconds per 1 second
of actual time. In the end, these choices cause the ship
to fall towards the ground over a period of several actual
seconds, neither too slow nor too fast to be uninteresting.
Students are told to add gravity to the simulation by
adding this line of code: deltaVy += - g*dt after the
keyboard input section. This representation emphasizes
gravity as a constant acceleration rather than as a force.
This is another choice that simpliﬁes the code but may
increase the cognitive load in later exercises (particularly
exercise 6 which includes a horizontal spring force and
the force of the rocket engine).
The activity in this exercise is to try and land the ship
on the bottom of the screen. Students are given an if
statement to include in the code that allows the ship to
land if the ship’s height is close to the bottom of the
screen and the velocity is small. The student also adds

7
FIG. 3. An interactive from the 3rd programming exercise.
Students must conﬁgure the program to draw the expected
trajectory before the projectile is launched.
The keyboard
controls the launch angle.
an if statement to trigger a “Game over!” if the height of
the ship becomes negative.
Students can customize the game by changing the vari-
able θ so the ship initially points upward instead of to the
right as in the previous exercise. Challenges include cre-
ating a time limit, or a limit to the amount of fuel.
V.
EXERCISE 3: CONSTANT ACCELERATION
WITH AN INITIAL VELOCITY
In this exercise the student moves the position of the
ship to the bottom left part of the screen and conﬁgures
the if statement that checks if the spacebar is pressed so
that the ship is given an initial velocity that depends on
the angle that the ship is pointing. Students need to ﬁll
in the blank with the correct formula for vx and vy at
the moment that the projectile is launched. Again, this
draws from their knowledge of trigonometry to realise
that vx = vi cos θ and vy = vi sin θ. Even in a calculus
based physics class, some students have diﬃculty arriving
at this answer, perhaps, in part, due to the the unfamiliar
environment of computer programming. One hopes that
this task reinforces this concept when the student works
on pen and paper calculations.
The next task, which is also the most diﬃcult, is draw-
ing the expected trajectory of the projectile before it is
launched. This is an interesting goal because this tra-
jectory changes depending on the launch angle of the
projectile.
Using step-by-step interactives the student
can see and interact with the correct implementation of
the trajectory in the program but they cannot see the
source code.
Although the expected trajectory is just
y = yi + vyit −(1/2)gt2 and x = xi + vxit students of-
ten struggle to produce these formulas and when they do
they often use the current velocity vx and vy of the pro-
jectile in place of the initial velocities vxi and vyi, which
has the eﬀect of making the trajectory change in strange
ways after the projectile is launched. Once the students
have completed this task they are asked to empirically
show that a launch angle of 45o gives the furthest dis-
tance, a task that some students may have diﬃculty in
proving analytically.
The challenge for this exercise is to conﬁgure the if
statement that checks if the spacebar is pressed to only
run “then” code if the spacebar is pressed for the ﬁrst
time. Without this, it is easy to press the spacebar a
moment too long and give the projectile its initial velocity
again while it is already ﬂying through the air. When
this happens the projectile’s motion and the expected
trajectory do not agree to the extent that it does in Fig. 3.
So while this task is more computer science than physics,
it serves to make the program more physically realistic.
In this way this task supports our main goal of teaching
students how to write computer programs to accurately
solve physics problems.
VI.
EXERCISE 4: MOMENTUM AND
COLLISIONS
In this exercise the student uses the ellipse() function
to add a circular “sticky blob” initially at rest that the
ship will make a perfectly inelastic collision with. The
student is given an if statement that detects if the x po-
sition of the ship has passed closer than 1 radius away
from the blob. The student must modify this if statement
to properly detect a collision if both the x and y posi-
tions of the ship and the blob are close enough. Even in a
calculus-based physics class, students have trouble using
the Pythagorean theorem to determine the distance that
separates the ship and the blob.
Another common problem encountered in this activity
is that the students correctly determine the new velocity
of the blob after the perfectly inelastic collision but they
forget to set the velocity of the ship to this new velocity.
In the next few timesteps the ship and blob, which are
close to each other, will inelastically collide again and
again until the blob reaches the same velocity of the ship.
An important component of this activity is to carefully
check that the ﬁnal velocity of the ship and blob reach
the values expected from momentum conservation. The
problems students encounter are again more computer
science than physics, but it reinforces the idea that the
output of the code needs to be checked carefully to ensure
that the program is modeling the physics correctly.
VII.
EXERCISE 5: TORQUE
In this exercise, the student modiﬁes the code so ship
spins at a constant rate unless thrusters apply a constant
torque. The ship can still accelerate forward as before
and no changes are needed to that part of the keyboard
input section. Once the torque and rotation modiﬁca-
tions are completed the students are asked to change the

8
FIG. 4. An interactive from the 5th programming exercise.
Students must modify the mass, thrust and length of the ship
to ﬁnd a combination that gives the ship the most agility
to avoid drifting “planetoids”.
These variables aﬀect both
the acceleration in the direction of the ship and the angular
acceleration when a constant torque is applied.
force of the thrusters, mass of the ship, and length of the
ship to ﬁnd optimal values that allow the ship to avoid
hitting the planetoids. There is obviously no correct an-
swer to this task, but it forces the student to think about
how the acceleration and angular acceleration of the ship
depend on these variables in a way that might not oth-
erwise occur to them. There are no quantitative tasks in
this activity, as in exercise 4.
A common mistake in this activity is when students
forget to set the angular acceleration to zero at the be-
ginning of the keyboard input section, which reﬂects the
idea that the angular acceleration is zero if there is no
torque on the system. When this happens the ship, once
spinning, will rotate faster and faster. The students are
given step-by-step interactives that clearly show this does
not happen, but many students do not notice this.
For an interesting comparison to how an exercise like
this might be put together in vpython, [13] describes a
similar programming activity where students conﬁgure a
rocket to spin and thrust and are asked to predict the
motion beforehand.
VIII.
EXERCISE 6: SPRING FORCES AND
HARMONIC MOTION
The ﬁnal required exercise involves an interesting mod-
iﬁcation of Exercise 4 (momentum) where the sticky blob
is attached to a spring. Initially the spring is drawn on
the screen (as shown in Fig. 5) and as before the blob
is initially at rest, but there is no restoring force imple-
mented in the code yet and the ship can ﬂy into the blob
and collide with a perfectly inelastic collision and carry
the blob oﬀthe screen. Students must modify the code
to add the restoring force of the spring so that when the
ship collides with the blob, this begins harmonic motion.
FIG. 5. An interactive from the 6th programming exercise.
The user can collide the ship with a “blob” (i.e. the circle in
the plot) that is attached to a spring, which begins periodic
motion. Unlike other exercises, this interactive has a graph
that charts the position and velocity of the blob with time.
As seen in Fig. 5, a graphing system is used here to plot
the position and velocity of the ship as this motion oc-
curs. The code for this graphing system is hidden away
in the display() function.
An interesting aspect of this activity is that the ship
is “stuck” to the blob but user can still ﬁre the thrusters
to increase or decrease the amplitude of oscillations. The
interactive activity is for the students to show that the
“half-cycle time” does not depend on the amplitude of
the motion. The program includes a simple counter of
how long it takes the blob to go from the relaxed po-
sition to maximum compression or extension and back
again. Even with a simple scheme like Euler-Cromer in-
tegration [25], one can easily show with good accuracy
that the period and amplitude are independent of each
other ([25] argues that the scheme performs rather well
for oscillatory problems). The tutorial only refers to the
“half-cycle time” in an intentional eﬀort to make stu-
dents think about the motion and the code in order to
realize that this is just half of the period. Students must
calculate the expected “half-cycle time” from the spring
constant and the mass of the blob and ship with the only
hint being ω =
p
k/m.
The challenge in this exercise is to add linear damping
(b ̸= 0) to the system and measure the half-cycle time in
that case, comparing it to the expected half-cycle time
from ω =
p
k/m −(b/2m)2. If b is chosen to be neither
too big (overdamped – less than one oscillation) nor too
small (almost no damping) one can obtain good agree-
ment between the expectation and the measured period
in the program.
It should be said that at any point in the execution
of the program, the student can ﬁre the rocket thrusters
to try and push the blob left or right. For example, the
student might try to ﬁre the thrusters in a futile but
entertaining eﬀort to try to resist the restoring force and
any damping.
An additional virtue of the spring exercise (and one

9
FIG. 6. An interactive from an optional extra credit exercise
that examines total energy conservation in the 3rd exercise
that resembles the popular game “angry birds”. The graph
shows that when the kinetic energy and potential energy are
added together the result (black line) is not perfectly constant
as expected. The exercise discusses this result and guides the
student to ﬁx this by modifying part of the code.
reason for the ubiquity of spring systems in computa-
tional physics tutorials) is that instructors often mention
to students that drag forces in real physical systems are
more often proportional to the velocity squared.
Stu-
dents could easily modify the program to include this
more realistic drag force if desired. But in a typical course
without numerical exercises, an instructor would have to
say that, due to the complexity of the diﬀerential equa-
tion in this case, there is no method at the students’ dis-
posal that would allow them to make any progress. Many
authors have argued that situations like these – systems
that are analytically frustrating or intractable – are an
important motivator for including numerical exercises in
introductory physics [e.g. 7, 13, 15].
IX.
EXERCISE 7: ENERGY CONSERVATION
This exercise adds a graph to Exercise 3 (“bellicose
birds”) and students notice that when the kinetic energy
and potential energy of the projectile are added together
one does not quite get perfect energy conservation as one
would expect, regardless of the initial launch angle of the
projectile. In Fig. 6, if one looks closely, one can see a
slight downward slant to the black line that shows the
total energy instead of a horizontal line as one would ex-
pect. Because the integration scheme uses Euler-Cromer
integration [25], the total energy is not perfectly con-
served and each time step loses a small amount of en-
ergy. If the student allows the projectile to “fall through
the ﬂoor” (as they are instructed to do in the exercise by
commenting out certain lines of code) this slant becomes
much more obvious.
Philosophically this is an impor-
tant moment because it reveals that the computer did
not determine the trajectory of the projectile perfectly.
Instead, students will have to change something about
the program to make this happen.
Students are asked to examine if the velocity update is
to blame for the energy conservation problem by modify-
ing the code to plot vy vs t to check if this is a diagonal
line with negative slope as expected. Because the pro-
gram updates the velocity with ∆vy = ay∆t this turns
out to look ﬁne and the next part of the tutorial instructs
the student that the problem must be in the position up-
date. If one looks closely at the code in Fig. 1, one notices
that the x position is updated with the already updated
velocity, which is the Euler-Cromer method. In Exercise
1, the students mimic this same code to update vy and
the y position.
As is well known, changing the position update to
use the half-advanced velocity (vy + ∆vy/2), one can
change the integration scheme from Euler to trapezodial
(a.k.a. ”midpoint”) and perfect energy conservation is
restored for constant acceleration problems. This can be
explained to the students in terms of calculating how far
a car will travel when it is accelerating at a constant rate
from zero to 60 mph. If we tried to model this in our pro-
gram using one very large time step, say ∆t = 5 seconds,
then the original program would say that the distance
traveled is vf∆t because the original program uses the
updated velocity to calculate the distance traveled. But
this would be like assuming that the car traveled 60 mph
for a full ﬁve seconds, which would be too far.
If we
switch the order of the position advance and the velocity
advance so we use the un-updated velocity (vi = 0 mph)
times the time interval to determine the distance trav-
eled we will get zero for the distance. The right answer
is to use the average velocity over the interval that gives
the correct distance traveled. We can implement this in
the program by using the half-advanced velocity in the
position advance.
This is the newest exercise and very few students have
completed it so far. Student experiences with this exer-
cise will be discussed in future work. We include it here
because it illustrates how topics like Euler vs Trapezoidal
integration can be discussed at an introductory (i.e. pre-
calculus) level. The exercise is also a stepping-stone to-
wards simulating gravitational problems which require a
better-than-Euler scheme to convincingly produce ellipti-
cal orbits and Kepler’s laws. Discussing the Trapezoidal
method for the ﬁrst time in such an exercise could be
more confusing to the student than introducing it in a
constant gravitational acceleration case.
X.
PLANS FOR ASSESSMENT
The Force Concept Inventory (FCI) [26] is a well-
studied metric that is often used to quantify student
learning and learning gains.
What is less well-known
is that M. Dancy created an animated version of the
FCI, using essentially the same java-based framework as
physlet physics [27], and compared results from a signif-

10
icant number of students completing the animated ver-
sion and the often-used written version [1]. From stu-
dent interviews [1] found that the animated version gave
students a more accurate understanding of the questions
being asked. We comment here to mention that many
of the questions that did not have any diagrams in the
written version have animations depicting each multiple-
choice option where originally there was just a sentence
describing the motion. Thus it is understandable why
the animated version seemed to do a better job of com-
municating the questions to the students. We view the
animations as a substantial improvement over the written
FCI, and it seems like a natural place to start in assessing
whether students gain a better conceptual understanding
of physics from working through the programming exer-
cises.
In particular, because of our emphasis on a ship trav-
eling in free space, questions 21 through 24 on the FCI
seem particularly relevant. In these questions, students
are asked to identify the correct trajectory of a rocket
drifting through free space, followed by a period of con-
stant thrust.
With questions 21 & 22, there are dia-
grams in the written version that the animated version
emulates. With questions 23 & 24, which describe the
motion of the ship after the thrust has turned oﬀ, in our
opinion the animated version does a signiﬁcantly better
job of explaining the nature of the question.
We re-created the animated FCI using ﬁles from the
supplemental info for [1], and using libraries from the
CD that comes with the physlet physics textbook [27].
To create a version of the animated FCI that does not
require the student’s computer to run java applets (which
are increasingly obsolete due to security risks), we had to
make screen capture videos from a computer with a java-
capable browser, and incorporate these screen capture
videos (which involve commonly-used mp4 ﬁle formats)
into an online quiz. After some work we were able to
re-create all 30 animated FCI questions in this way.
In the future, we plan to increase this sample size sub-
stantially, and we plan to integrate animated FCI ques-
tions into a custom-built website (stemcoding.osu.edu)
where students will complete the exercises using an in-
browser editor with bug-ﬁnding capabilities. This web-
site will be conﬁgured to ask students animated ques-
tions as a kind of ”pre-lab” immediately before they start
working on the code and immediately after they submit
their code for grading, so as to avoid a situation where
student performance could be attributed to something
besides the programming exercises. This website, which
can be thought of as a p5.js-based learning management
system, also has a capability for teachers to quickly view
submissions and give feedback to students in a much
more streamlined way than would otherwise be possible.
This is an important capability for any eﬀort to scale
up these kinds of programming activities to signiﬁcantly
larger classes. This website was used for the ﬁrst time in
spring 2017 physics courses at OSU’s Marion campus.
XI.
SUMMARY AND CONCLUSION
We present a comprehensive set of programming ex-
ercises for introductory physics that are appropriate for
algebra-based and calculus-based physics classes at either
the high school or college level where students may be ab-
solute beginner programmers. Creating content at this
level is a challenging task and we argue that there are a
number of important considerations: (1) the code that
the student sees must be well commented and involve 75
or fewer lines of code, (2) the activities must be easy-to-
use with browser-based coding tools, (3) these exercises
must emphasize interactivity and include goal-oriented
game-like activities, (4) the directions must be step-by-
step with the ability to interact with intermediate stages
of the ”correct” program, and (5) the exercises must be
thoughtfully integrated into the physics curriculum.
In an introductory class at OSU where a substantial
fraction of the students are weak or absolute beginner
programmers, student survey data (N ≈80 −85) seems
to conﬁrm that the ﬁrst exercise, which produces an in-
teractive simulation that resembles the classic game “as-
teroids”, is at an appropriate diﬃculty level, and that
students overall seem to enjoy this exercise.
We describe ﬁve other required exercises and one extra
credit exercise. Following the ﬁrst exercise, students com-
plete an exercise where gravity is added to the simulation
by adding two lines of code. Another exercise, which is
not unlike the popular game angry birds, asks students to
conﬁgure the code to draw a line of the expected trajec-
tory of a projectile launched from the ground and to con-
ﬁrm that the max distance occurs for a 45o launch angle.
Exercises following this return to the ship in space theme
and sequentially build upon another, discussing momen-
tum, torque and harmonic motion.
Game-like goal-
oriented activities are included throughout, such as an
activity to determine the best values of the ship’s mass,
length and force of the thrusters to navigate through an
asteroid ﬁeld. In another activity students use the ship’s
thrusters to increase the amplitude of a spring system
and demonstrate that the period of motion is insensitive
to the amplitude. Finally, an extra credit exercise takes
the angry-birds-like code and reveals that the total en-
ergy is not perfectly conserved.
A gentle introduction
to the Euler-Cromer and trapezoidal (a.k.a. midpoint)
methods of determining the path of motion is presented
that does not assume calculus knowledge.
Like other authors [e.g. 7], our ultimate goal is to im-
prove the student’s conceptual knowledge of physics and
ability to solve problems. We outline a plan for detailed
assessment of student learning using an animated version
of the Force Concept Inventory [1] that we have repro-
duced from various sources to allow the animations to
play on modern computers. These questions will be in-
tegrated into a custom-designed p5.js learning manage-
ment system in order to query students shortly before
they begin and after they ﬁnish a programming exercise.
This p5.js learning management system is in operation

11
and it will allow students in physics classes at OSU’s
Marion campus starting in spring 2017 to complete the
exercises using an in-browser code editor and it will give
teachers a convenient interface for the otherwise tedious
task of providing student feedback and grades. We wel-
come inquiries from collaborators who may wish to use
these animations in their high school or early college-
level courses, or who may be interested in using the p5.js
learning management system.
The full set of exercises and code described here is
available at http://compadre.org/PICUP
ACKNOWLEDGMENTS
The authors thank Kyle Decot and Michael Hardesty
for their collaboration on a p5.js learning management
system. CO thanks Annika Peter, Gregory Ngirmang,
and Kelly Roos for discussions. This project was made
possible through a Connect and Collaborate Grant, a
program supporting innovative and scholarly engagement
programs that leverage academic excellence of The Ohio
State University in mutually beneﬁcial ways with exter-
nal partners.
Appendix A: Survey Questions
As discussed in Sec. III B 1, a few weeks into the course and after the student submits the ﬁrst programming exercise
for grading/feedback, the students are asked a series of questions in an online form. Fig. 2 shows the results from
four semesters of students taking this survey. The precise questions are as follows:
1.
Question #1
Question: Have you ever written or modiﬁed a computer program before?
Option A: No, I have never done any programming before
Option B: Yes, I have done a little bit of programming before
Option C: Yes, I have some experience with programming but I still feel like I have a lot to learn (For example:
you took a programming course or are taking a programming course now, or have learned some programming on your
own or in another context)
Option D: Yes, I have a signiﬁcant amount of programming experience (ex. completed more than one programming
course, or signiﬁcant programming experience outside of class or in projects).
Option E: Prefer not to answer (but still get the point for the question)
2.
Question #2
Question: From the point you got the planetoids program working until you ﬁnished the programming lab (including
one of the challenges), compared to the diﬃculty of completing other Physics 1250 labs, how diﬃcult was
it to complete the programming tasks described on the planetoids page?
Option A: Easy!
Option B: Semi-Easy
Option C: Semi-diﬃcult
Option D: Diﬃcult!
Option E: Extremely Diﬃcult!
Option F: Prefer not to answer (but still get the point)
3.
Question #3
Question: Did the programming lab help you understand vectors better?
Option A: Not really
Option B: A little bit
Option C: Somewhat
Option D: It actually helped a lot
Option E: Prefer not to answer (but still get the point)

12
4.
Question #4
Question: Was the programming lab fun?
Option A: Not really
Option B: Somewhat
Option C: It was enjoyable
Option D: Actually it was a lot of fun
Option E: Prefer not to answer (but still get the point)
[1] M. H. Dancy and R. Beichner, Physical Review Special Topics Physics Education 2, 010104 (2006).
[2] R. G. Fuller, Computing in Science Engineering 8, 16 (2006), ISSN 1521-9615.
[3] U. B. of Labor Statistics, Online Publication (2014), URL https://www.bls.gov/careeroutlook/2014/spring/art01.
pdf.
[4] C. N. proﬁt organization), Promote computer science, https://code.org/promote, accessed: 2016-12-30.
[5] D. F. Smith, What the essa means for the future of computer science in stem, http://www.edtechmagazine.com/k12/
article/2015/12/what-essa-means-future-computer-science-and-stem (2015), accessed: 2016-12-30.
[6] M. D. Caballero, M. A. Kohlmyer, and M. F. Schatz, Physical Review Special Topics Physics Education 8, 020106 (2012),
1107.5216.
[7] R. Chabay and B. Sherwood, American Journal of Physics 76, 307 (2008).
[8] J. M. Aiken, M. D. Caballero, S. S. Douglas, J. B. Burk, E. M. Scanlon, B. D. Thoms, and M. F. Schatz, in American
Institute of Physics Conference Series, edited by P. V. Engelhardt, A. D. Churukian, and N. S. Rebello (2013), vol. 1513
of American Institute of Physics Conference Series, pp. 46–49, 1207.1764.
[9] R. Chabay and B. Sherwood, Matter & Interactions, 4th edition (Wiley & Sons, 2015).
[10] E. Behringer and L. Engelhardt, American Journal of Physics 85, 325 (2017), http://dx.doi.org/10.1119/1.4981900, URL
http://dx.doi.org/10.1119/1.4981900.
[11] B. L. Sherin, International Journal of Computers for Mathematical Learning 6, 1 (2001), ISSN 1573-1766, URL http:
//dx.doi.org/10.1023/A:1011434026437.
[12] R. M. Serbanescu, P. J. Kushner, and S. Stanley, American Journal of Physics 79, 919 (2011).
[13] A. Buﬄer, S. Pillay, F. Lubben, and R. Fearick, American Journal of Physics 76, 431 (2008), URL http://scitation.
aip.org/content/aapt/journal/ajp/76/4/10.1119/1.2835045.
[14] K. J. Holyoak, K. A. Ericsson, and J. Smith, Symbolic connectionism: toward third-generation theories of expertise (Cam-
bridge University press, Cambridge, 1991), pp. 301–336.
[15] E. F. Redish and J. M. Wilson, American Journal of Physics 61, 222 (1993).
[16] R. Landau, Computing in Science Engineering 8, 22 (2006), ISSN 1521-9615.
[17] R. H. Landau, M. J. Paez, C. Bordeianu, and S. Haerer, Computer Physics Communications 182, 2071 (2011), ISSN 0010-
4655, computer Physics Communications Special Edition for Conference on Computational Physics Trondheim, Norway,
June 23-26, 2010, URL http://www.sciencedirect.com/science/article/pii/S0010465510004522.
[18] D. Weintrop, E. Beheshti, M. Horn, K. Orton, K. Jona, L. Trouille, and U. Wilensky, Journal of Science Education and
Technology 25, 127 (2016), ISSN 1573-1839, URL http://dx.doi.org/10.1007/s10956-015-9581-5.
[19] K. Perkins, W. Adams, M. Dubson, N. Finkelstein, S. Reid, C. Wieman, and R. LeMaster, The Physics Teacher 44, 18
(2006).
[20] N. S. Podolefsky, K. K. Perkins, and W. K. Adams, Phys. Rev. ST Phys. Educ. Res. 6, 020117 (2010), URL http:
//link.aps.org/doi/10.1103/PhysRevSTPER.6.020117.
[21] R. Taub, M. Armoni, E. Bagno, and M. M. Ben-Ari, Computers & Education 87, 10
(2015), ISSN 0360-1315, URL
http://www.sciencedirect.com/science/article/pii/S0360131515000913.
[22] C. Reas and B. Fry, Processing: A Programming Handbook for Visual Designers and Artists, 2nd edition (The MIT Press,
2014).
[23] L. McCarthy and the Processing Foundation, p5.js home, https://p5js.org (2016), accessed: 2016-12-30.
[24] H. Barragn and C. Reas, Electronics and processing, https://processing.org/tutorials/electronics/ (2014), accessed:
2016-12-30.
[25] A. Cromer, American Journal of Physics 49, 455 (1981), http://dx.doi.org/10.1119/1.12478, URL http://dx.doi.org/
10.1119/1.12478.
[26] D. Hestenes, M. Wells, and G. Swackhamer, The Physics Teacher 30, 141 (1992).
[27] W. Christian and M. Belloni, Physlet Physics: Interactive Illustrations, Explorations, and Problems for Introductory Physics
(Addison-Wesley, 2003).

