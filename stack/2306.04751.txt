How Far Can Camels Go? Exploring the State of
Instruction Tuning on Open Resources
Yizhong Wangâˆ—â™£â™ 
Hamish Ivisonâˆ—â™£
Pradeep Dasigiâ™£
Jack Hesselâ™£
Tushar Khotâ™£
Khyathi Raghavi Chanduâ™£
David Waddenâ™£
Kelsey MacMillanâ™£
Noah A. Smithâ™£â™ 
Iz Beltagyâ™£
Hannaneh Hajishirziâ™£â™ 
â™£Allen Institute for AI
â™ University of Washington
{yizhongw,hamishi}@allenai.org
Abstract
In this work we explore recent advances in instruction-tuning language models on
a range of open instruction-following datasets. Despite recent claims that open
models can be on par with state-of-the-art proprietary models, these claims are
often accompanied by limited evaluation, making it difficult to compare models
across the board and determine the utility of various resources. We provide a large
set of instruction-tuned models from 6.7B to 65B parameters in size, trained on
12 instruction datasets ranging from manually curated (e.g., OpenAssistant) to
synthetic and distilled (e.g., Alpaca) and systematically evaluate them on their
factual knowledge, reasoning, multilinguality, coding, and open-ended instruction
following abilities through a collection of automatic, model-based, and human-
based metrics. We further introduce TÃœLU
, our best performing instruction-tuned
model suite finetuned on a combination of high-quality open resources.
Our experiments show that different instruction-tuning datasets can uncover or
enhance specific skills, while no single dataset (or combination) provides the best
performance across all evaluations. Interestingly, we find that model and human
preference-based evaluations fail to reflect differences in model capabilities exposed
by benchmark-based evaluations, suggesting the need for the type of systemic
evaluation performed in this work. Our evaluations show that the best model in
any given evaluation reaches on average 83% of ChatGPT performance, and 68%
of GPT-4 performance, suggesting that further investment in building better base
models and instruction-tuning data is required to close the gap. We release our
instruction-tuned models, including a fully finetuned 65B TÃœLU
, along with our
code, data, and evaluation framework to facilitate future research.2
1
Introduction
The latest generation of large language models has brought unprecedented attention to the potential
of language technologies. To support imperative user requests and a chat interface, these models
often undergo an instruction-tuning step which involves training on supervised input/output pairs.
Instruction tuning corpora are often gathered via crowdsourcing (Dolly [12], Open Assistant [23])
or via distillation from another model (Alpaca [38], Vicuna [8]). However, while some public,
instruction-tuned models are advertised as comparable to powerful closed-source proprietary models
such as ChatGPT, most experiments that support such claims only cover a small set of tasks, and
mostly rely on model-based evaluation metrics [8, 50]. We contend that the evaluation setup should
âˆ—Equal contribution.
2https://github.com/allenai/open-instruct
Preprint. Under review.
arXiv:2306.04751v1  [cs.CL]  7 Jun 2023

include tasks that test core reasoning and fact-recall skills of the model, in addition to testing model-
or human-annotated generation quality, which may be more open-ended and subjective.
This paper provides a comprehensive evaluation of instruction-tuning resources: specifically, we
conduct a large number of instruction tuning experiments spanning a dozen public corpora, and
models ranging in scale from 6.7B to 65B. We evaluate both specific model capabilities (i.e., factual
knowledge, reasoning, multilinguality, coding) and open-ended instruction-following abilities. We
report results based on automatic, model-based, and human-based evaluation metrics.
Our evaluation reveals that instruction tuning over different datasets appears to promote specific
skills, and no one dataset provides the best performance across all evaluations. We also find that
the underlying base model is paramount, with better base models (whether it be models trained on
more tokens or larger models) performing better across the board. Surprisingly, we also find that
models preferred in model-based evaluation do not match those that perform best on benchmark-based
automatic evaluations, potentially partially due to a strong bias toward long, diverse generations by
GPT-4.
Building on our findings, we introduce TÃœLU
, a suite of 7B to 65B LLAMA models fine-tuned
on a combination of data sources. TÃœLU
65B is the largest publicly-released fully-instruction
tuned LLAMA variant at the time of writing, to the best of the authorsâ€™ knowledge. It is trained on 7
popular available datasets, and yields the best average performance while remaining within 15% of
the best-performing model on each individual task. In summary, our key findings include:
â€¢ Instruction datasets targeted at specific domains and/or capabilities are extremely effective at
improving model performance in those aspects.
â€¢ Larger or pretrained-for-longer base models consistently perform better after instruction tuning.
â€¢ Our model TÃœLU
â€“ fine-tuned LLaMa on a combination of existing instruction datasets â€“ achieves
the best average performance across benchmarks, although it is not the overall best when considering
different evaluation settings independently.
â€¢ Even a very large (65B) model finetuned on a large mix of instruction datasets fails to outperform
ChatGPT, although it does perform significantly better than similar smaller models.
â€¢ Model-based preference evaluation on open-ended instruction following correlates strongly with
the average number of unique tokens generated by a model, suggesting that model-based preference
evaluation has biases that may hide differences in model capabilities.
We open-source the code for training and evaluating these large language models. We also release
checkpoints trained on the different instruction datasets and their mixtures, including TÃœLU
. We
hope this facilitates further development and investigation of open instruction-tuned models.
2
Background: Instruction Tuning and Resources
2.1
Instruction Tuning
Instruction tuning, in general, refers to the practice of finetuning pretrained language models to better
understand and respond to a wide variety of human requests that are expressed in natural language
[27, 43, 30]. It has arisen as a critical step for generalizing models to new scenarios without dedicated
training, and for letting non-experts naturally interact with these models. The training paradigms
of instruction tuning can vary from supervised learning using demonstrations [43, 34, 42, 26] to
reinforcement learning from feedback data [30, 3]. In this work, we focus on the supervised learning
setup considering the current open resources for the RL-based approach are still rare, and we leave
the exploration of it for future work.
The success of instruction tuning requires at least two key components: 1) a powerful pretrained
language model that has grasped a vast amount of knowledge from web-scale pretraining, and 2) an
instruction dataset that is diverse and representative enough to adapt the LM to potential downstream
usage. We study these two factors in this work and introduce our studied open resources below.
2

Table 1: Instruction datasets investigated in this work. CoT and FLAN V2 are sampled to 100K to
match the sizes of other datasets. We report the average number of rounds ( Ì„ğ‘rounds), average length
of prompts ( Ì„ğ¿prompt), average length of completion ( Ì„ğ¿completion).
Datasets
Sourced from
# Instances
Ì„ğ‘rounds
Ì„ğ¿prompt
Ì„ğ¿completion
SuperNI [42]
NLP datasets + Human-written Instructions
96,913
1.0
291.1
38.7
CoT [44]
NLP datasets + Human-written CoTs
100,000
1.0
266.0
53.2
Flan V2 [26]
NLP datasets + Human-written Instructions
100,000
1.0
355.7
31.2
Dolly [12]
Human-written from scratch
15,011
1.0
118.1
91.3
Open Assistant 1 [23]
Human-written from scratch
34,795
1.6
34.8
212.5
Self-instruct [41]
Generated w/ vanilla GPT3 LM
82,439
1.0
41.5
29.3
Unnatural Instructions [21] Generated w/ Davinci-002
68,478
1.0
107.8
23.6
Alpaca [38]
Generated w/ Davinci-003
52,002
1.0
27.8
64.6
Code-Alpaca [6]
Generated w/ Davinci-003
20,022
1.0
35.6
67.8
GPT4-Alpaca [31]
Generated w/ Davinci-003 + GPT4
52,002
1.0
28.0
161.8
Baize [46]
Generated w/ ChatGPT
210,311
3.1
17.6
52.8
ShareGPT3
User prompts + outputs from various models
168,864
3.2
71.0
357.8
2.2
Instruction Datasets
We attempt to collect a representative sample of different styles of datasets (listed in Table 1), including
datasets: (1) created by researchers from existing NLP datasets (SuperNI [42], Flan V2 [26]); (2)
written by humans from scratch for the purpose of instruction tuning (Dolly [12], Open Assistant 1
[23]); (3) generated by proprietary models (Self-Instruct [41], Unnatural Instructions [21], Alpaca
[38], Baize [46], GPT4-Alpaca [31]); (4) comprised of user-shared prompts accompanied by model-
generated completions (ShareGPT3 [8]); (5) built for specific skills (CoT [44] for chain-of-thought,
Code-Alpaca [6] for code generation). See Appendix A for further details.
2.3
Pretrained Models
Table 2: Base models that we fine-
tuned in this work.
Base LMs # Params # Tokens
LLaMa [39]
6.7B
1.0T
13.0B
1.0T
32.5B
1.4T
65.2B
1.4T
OPT [48]
6.7B
180B
Pythia [4]
6.9B
300B
We primarily use the LLAMA suite [39], a series of pretrained
models ranging in size from 6.7B to 65B parameters. These
models represent the largest, highest-quality pretrained models
available to the community (albeit under restrictive licensing).
We also consider OPT [48] and Pythia [4] models with a size
comparable to the LLAMA 6.7B model to examine the effect
of different base models. For simplicity, we will round all the
sizes to the nearest integer number. We note several ongoing
efforts to pre-train similar- or better-quality models [18, 28, 1].
We believe our findings should hold for these models and future
stronger open base models.
3
Training Models with Various Datasets
3.1
Unifying the Format
We format all datasets to follow a chatbot-style schema to unify the varied styles and formats of the
instruction datasets, shown in Figure 1. This allows us to fit arbitrary rounds of interactions between
the user and the language model (a.k.a. â€œassistantâ€) into one input sequence and encode them together
with a causal language model. We add special tokens <|user|> and <|assistant|> before user
utterances and target assistant responses respectively, and an end-of-text marker </s> at the end of
each assistant output, which, at inference time, will stop the modelâ€™s response for each round.
3.2
Model Training Details
3 ShareGPT (https://sharegpt.com/) data was used to build the Vicuna model [8], but the exact dataset
has not been released. We instead use a reproduced version from https://huggingface.co/datasets/
anon8231489123/ShareGPT_Vicuna_unfiltered/tree/main/HTML_cleaned_raw_dataset, and fol-
low Vicuna to split the long conversations into blocks with a maximum length of 2048 tokens.
3

<|assistant|>
The reaction control system (RCS) on the Space 
Shuttle was designed to be fault-tolerant, 
meaning it was able to continue functioning 
even if one or more of its components failed. 
The RCS consisted of two sets of ... </s>
<|assistant|>
There were several instances where the 
reaction control system (RCS) on the Space 
Shuttle experienced failures or malfunctions 
during on-orbit missions. These ... </s>
<|user|>
Explain the fault-tolerance of the reaction 
control system on the Space Shuttle.
<|user|>
Did the RCS have any on-orbit failures?
ğŸ‘±
ğŸ‘±
ğŸ¤–
ğŸ¤–
Figure 1: An example from ShareGPT data. We use
<|role|> to set the boundary between messages.
The entire sequence is encoded together, and loss
is computed on the assistant part (colored in blue).
During training, we compute loss only on to-
kens after <|assistant|> and before the next
<|user|> token. More formally, we consider
an instruction dataset as consisting of ğ‘tuples,
each with ğ‘–turns, {(ğ‘¥ğ‘—
1, ğ‘¦ğ‘—
1, ğ‘¥ğ‘—
2, ğ‘¦ğ‘—
2, ...ğ‘¥ğ‘—
ğ‘–, ğ‘¦ğ‘—
ğ‘–)}ğ‘
ğ‘—=1,
where ğ‘¥ğ‘–is a user prompt and ğ‘¦ğ‘–the desired out-
put. For most instances, ğ‘–= 1, and we train the
model to output ğ‘¦ğ‘—given ğ‘¥ğ‘—. However, in the
case of conversation datasets, we train the model
to predict ğ‘¦ğ‘—
ğ‘–given some conversation history
ğ‘¥ğ‘—
1, ğ‘¦ğ‘—
1, ğ‘¥ğ‘—
2, ..., ğ‘¥ğ‘—
ğ‘–. We train decoder-only models,
and use teacher-forcing with loss masking to
train the models, where we mask all tokens be-
longing to the input sequence(s) ğ‘¥ğ‘–. Given ğ‘‹as
the tokens belonging to the input, and ğ‘Œas the
target tokens, the loss function is:
ğ¿= âˆ’
âˆ‘
ğ‘—
log ğ‘ğœƒ(ğ‘¡ğ‘—âˆ£ğ‘¡<ğ‘—) Ã—
{1
if ğ‘¡ğ‘—âˆˆğ‘Œ
0
otherwise
where ğ‘¡ğ‘—is the ğ‘—th input token (belonging to ğ‘‹or ğ‘Œ). See Appendix Â§B for further training details.
3.3
TÃœLU
: a Better Instruction-Tuned Model by Combining Resources
Existing studies [42, 26] (and our own evaluation below) have shown that increasing the diversity of
instructions can effectively improve the performance of instruction tuning. Following this motivation,
we create two mixtures of datasets:
Human data mixture, which comprises the best human-authored datasets, including FLAN V2,
CoT, Dolly, and Open Assistant 1 (we exclude SuperNI as FLAN V2 already includes most tasks in
SuperNI);
Human+GPT data mixture, which comprises the human mixture and three additional datasets that
have generations by OpenAI GPT models, including GPT4-Alpaca, Code-Alpaca, and ShareGPT.
For both mixtures, we concatenate datasets and leave exploring more complex sampling mixtures to
future work. We name LLAMA models trained on the Human+GPT data mixture TÃœLU
, after a
hybrid camel resulting from interbreeding between different species.
4
Evaluation Setup
Evaluation of instruction-following models remains a challenging problem due to the enormous
scope of â€œgeneralityâ€ and its open-ended nature. However, we argue that general-purpose models
should be able to perform some core tasks before they can generalize to satisfy various practical
needs. As such, we set up a multi-faceted evaluation to cover several key aspects of capabilities
covering core abilities and open-ended instruction following. Our evaluations closely follow prior
work on evaluating instruction-tuned models [9, 2, 41, 8, 16], but serve as the first one to compile
them together for systematic evaluation.
4.1
Facets of Evaluation
Factual knowledge is essential for language models to serve usersâ€™ information needs. We use the
Massive Multitask Language Understanding dataset (MMLU [20]) for measuring modelsâ€™ factual
knowledge. MMLU consists of a set of questions about 57 subjects ranging in difficulty from
elementary levels to professional levels, and its multiple-choice format makes it suitable for probing
modelsâ€™ knowledge without worrying about the open-endedness of generations.
Reasoning is another fundamental ability for models, especially for solving complex tasks. We use
the test split of Grade School Math dataset (GSM [11]) to evaluate modelsâ€™ mathematical reasoning
4

capabilities. We also adopt Big-Bench-Hard (BBH [37]), which contains 23 challenging tasks from
Big-Bench [36], to evaluate modelsâ€™ general reasoning capabilities.
Multilinguality acts as an important perspective of models for serving people from different back-
grounds. We use TyDiQA [10], a multilingual question answering benchmark covering 11 typo-
logically diverse languages for testing how much models can process non-Engish text. We use the
gold-passage setup where one passage containing the reference answer is given.
Coding is a particular application that people have used language models for and might be important
for integrating these models with external tools [5]. We use the HumanEval dataset [7] to evaluate
the modelsâ€™ capability to generate functionally correct programs from docstrings. To avoid ambiguity
with our human evaluation, we call this dataset Codex-Eval in this paper.
Open-ended instruction following. While the performance on the benchmarks above quantifies the
modelsâ€™ ability at specific skills, it may not reflect how well the models can handle instructions from
real users, which cover highly diverse requests and are often open-ended. For example, the popular
ShareGPT dataset contains instances of users asking for programming help, resume formatting tips,
educational role-playing, pronunciation suggestion, fanfiction writing, and more. We evaluate such
open-ended instructability of models using both model-based evaluation (Â§4.2) and human evaluation
(Â§4.3), both of which consist of multiple test sets from existing studies [41, 8, 23, 3, 19].
For all the benchmark-based evaluations, we follow their standard metrics, while we subsample GSM
and BBH to a reasonable size to improve the efficiency of doing chain-of-thought reasoning. We refer
the reader to Appendix Â§C for the setup details.
4.2
Model-Based Evaluation using GPT-4
To evaluate the open-ended instructability, we first adopt a model-based approach introduced in
AlpacaFarm [16]. The test set consists of 805 instructions, with 252 instructions from the Self-
Instruct evaluation [41], 188 from the Open Assistant evaluation [23], 129 from the helpful evaluation
by Anthropic [3], 80 from the Vicuna evaluation [8], and 156 from the Koala evaluation [19].
We use their simulated GPT-4 annotator, which computes the win rate of the testing model as judged
by GPT-4 when compared to the outputs produced by Davinci-003. Unlike AlpacaFarm, which limits
the output length to 300 tokens, we allow all models to generate up to 2048 tokens, in order to avoid
many cut-off generations and make the model comparison fairer. We then prompt GPT-4 to choose a
model generation from the two choices. When doing pairwise comparisons with GPT-4, the orders of
model outputs are randomized to avoid position bias during evaluation [40].
4.3
Human Evaluation
To further test the quality of the open-ended generations, we conduct a human evaluation based on
332 instructions that combine the Self-Instruct evaluation set [41] and Vicuna evaluation set [8].
Inspired by Bai et al. [3], we design a similar interface (Figure 5) for gathering human judgments of
model outputs along the following dimensions.
Individual acceptability. We ask human raters to assess whether each systemâ€™s responses were
acceptable in isolation. This is a binary decision, and we ask the raters to mark a response as acceptable
if and only if the response answered the request in the query, had no significant errors, and did not
have repetitive information.
Pairwise preference. We then ask humans to compare the outputs of two systems and select which
one they think is more helpful. This is a 5-way decision, and the raters could select if one of the
responses is â€œclearlyâ€ or â€œslightlyâ€ better than the other or if it is a tie implying that both responses
were equally good or bad.
To get a more reliable evaluation, we recruited a group of 18 expert annotators who are researchers at
AI2 or students at UW. All of them are fluent English speakers, holding bachelorâ€™s degrees or above.
5

Table 3: Comparison of different instruction tuning datasets, showing that different instruction-tuning
datasets can excel in different aspects, and mixtures perform best on average. Cells are blue if the
finetuning boosts the vanilla LLAMA performance, and orange if the finetuning hurts the performance.
MMLU
(factuality)
GSM
(reasoning)
BBH
(reasoning)
TydiQA
(multilinguality)
Codex-Eval
(coding)
AlpacaFarm
(open-ended) Average
EM
(0-shot)
EM
(8-shot, CoT)
EM
(3-shot, CoT)
F1
(1-shot, GP)
P@10
(0-shot)
Win % vs
Davinci-003
Vanilla LLaMa 13B
42.5
14.0
36.9
47.4
26.6
-
-
+SuperNI
49.8
4.0
2.8
51.4
13.1
5.0
21.0
+CoT
44.5
39.5
39.0
52.2
23.3
4.7
33.9
+Flan V2
50.7
21.0
39.2
47.5
16.2
5.3
30.0
+Dolly
45.3
17.0
26.0
46.8
31.4
18.3
30.8
+Open Assistant 1
43.1
16.0
38.5
38.3
31.8
55.2
37.1
+Self-instruct
30.3
9.0
29.6
40.4
13.4
7.3
21.7
+Unnatural Instructions
46.2
7.5
32.8
39.3
24.8
10.8
26.9
+Alpaca
45.1
8.0
34.5
32.8
27.6
33.2
30.2
+Code-Alpaca
42.6
12.0
36.6
41.3
34.5
21.3
31.4
+GPT4-Alpaca
47.0
14.0
38.3
24.4
32.5
63.6
36.6
+Baize
43.5
8.5
36.7
33.9
27.3
33.9
30.6
+ShareGPT
49.2
16.0
40.1
30.1
31.6
69.1
39.3
+ Human data mix
50.4
36.5
39.4
49.8
23.7
38.5
39.7
+Human+GPT data mix.
49.2
36.5
42.8
46.1
35.0
57.2
44.5
Table 4: Performance of different base models after training on the Human+GPT data mixture.
MMLU
(factuality)
GSM
(reasoning)
BBH
(reasoning)
TydiQA
(multilinguality)
Codex-Eval
(coding)
AlpacaFarm
(open-ended) Average
EM
(0-shot)
EM
(8-shot, CoT)
EM
(3-shot, CoT)
F1
(1-shot, GP)
P@10
(0-shot)
Win % vs
Davinci-003
Pythia 6.9B
34.6
15.5
27.8
33.4
21.4
9.3
23.7
OPT 6.7B
34.9
15.5
27.9
27.2
7.9
14.5
21.3
LLAMA7B
44.5
27.0
39.2
45.7
27.8
48.6
38.8
5
Results
5.1
Analysis of Instruction Tuning Datasets and Base Models
To understand how the instruction datasets listed in Table 1 contribute to model abilities, we evaluated
LLaMa 13B models trained on these datasets using our evaluation suite. Table 3 shows the results on
our benchmark evaluation set, with more extensive results in App. D. We find that:
There is not a single best instruction tuning dataset across all tasks. Different datasets enable
different capabilities in the model. Noteworthy examples include training on CoT being particularly
helpful for mathematical reasoning in GSM and Code-Alpaca being helpful for Codex-Eval. We
hypothesize that success on these tasks, which are significantly different from the rest of the evaluation
tasks, calls for training sets where these tasks are well-represented. Apart from constructing task-
specific datasets manually, distilling task-specific data from large models also appears to be an effective
way to ensure this (e.g., CodeAlpaca is distilled from Davinci-003).
Combining datasets results in the best overall performance on the benchmark tasks. While
models trained on our combination datasets are often not the best model for a single task (being the
best only in 2 out of 5 evaluation settings), they are the best when measuring average performance
across tasks. This suggests that future work into better dataset mixing or instruction-tuning modular
models (e.g., mixture-of-experts [35]) is a promising direction for developing models that retain
strong performance across all evaluation settings.
Base model quality is extremely important for downstream performance. We examine the impact
of using different base models in Table 4, comparing LLAMA, OPT [48], and Pythia [4] models of
comparable size trained on the Human+GPT data mix. Across all evaluation settings, we find that
using LLAMA performs best by a significant margin, likely due to the fact that LLAMA is pretrained
6

Table 5: Performance of TÃœLU and other of our trained models to vanilla LLAMA models and the
state-of-the-art proprietary models across evaluation settings. See Table 7 for a complete list.
MMLU
(factuality)
GSM
(reasoning)
BBH
(reasoning)
TydiQA
(multilinguality)
Codex-Eval
(coding)
AlpacaFarm
(open-ended) Average
EM
(0-shot)
EM
(8-shot, CoT)
EM
(3-shot, CoT)
F1
(1-shot, GP)
P@10
(0-shot)
Win % vs
Davinci-003
Vanilla LLaMa models â†“
LLaMa 7B
31.0
9.0
33.3
39.1
18.3
-
-
LLaMa 13B
42.5
14.0
36.9
47.4
26.6
-
-
LLaMa 30B
54.1
33.5
48.5
57.5
42.9
-
-
LLaMa 65B
58.7
50.5
57.1
57.4
42.9
-
-
65B models trained on alternate data mixtures â†“
ShareGPT 65B
61.5 (+2.8)
42.0 (-8.5)
52.1 (-5.0)
33.5 (-23.9)
53.5 (+10.6)
72.8
52.6
Human mix. 65B 60.7 (+2.0)
57.5 (+7.0)
52.7 (-4.4)
58.5 (+1.1)
43.2 (+0.3)
47.4
53.3
models trained on our final Human+GPT data mixture â†“
TÃœLU
7B
44.5 (+13.5) 27.0 (+18.0)
39.2 (+5.9)
45.7 (+6.6)
27.8 (+9.5)
48.3
38.8
TÃœLU
13B
49.2 (+6.7)
36.5 (+22.5)
42.8 (+5.9)
46.1 (-1.3)
35.0 (+8.4)
53.9
44.5
TÃœLU
30B
57.7 (+3.6)
51.0 (+17.5)
48.7 (+0.2)
58.2 (+0.7)
46.0 (+3.1)
63.5
54.1
TÃœLU
65B
59.2 (+0.5)
60.0 (+9.5)
53.5 (-3.6)
51.8 (-5.6)
45.9 (+3.0)
62.7
55.7
Proprietary models â†“
ChatGPT
67.9
76.0
66.1
51.9
88.4
84.4
72.2
GPT-4
82.4
92.5
88.0
70.8
94.1
91.6
86.8
on significantly more tokens than the other models (see Table 2). This suggests that models pretrained
on larger (or potentially higher-quality) corpora are preferable as base models for instruction tuning.
5.2
Pushing the Limits of Open Models
Having established that (a) using a broad mix of data is best, and (b) using LLAMA as the base
model is preferable to other open alternatives, we compare the performance of models trained on the
Human+GPT data mix (TÃœLU models) across all LLAMA sizes in Table 5. We find that:
Instruction tuning brings large benefits on top of LLAMA models at all sizes. On average, all
LLAMA models improve considerably after instruction tuning.
Smaller models benefit most from instruction tuning. We find that relative improvements from
instruction tuning are largest for the smallest models, and shrink as models get larger. Notably, the
65B LLAMA model performs comparably or better than the 65B TÃœLU model on MMLU, BBH,
and TydiQA. This suggests that instruction-tuning does not help to enhance strong capabilities
already present in the original model, and also highlights that care must be taken during finetuning
to avoid forgetting the base modelâ€™s original capabilities.
TÃœLU still lags behind state-of-the-art proprietary models. Despite the impressive performance
of TÃœLU 65B, it lags behind both ChatGPT and GPT-4 in all evaluation settings, contrary to prior
claims that models trained on these open resources can match ChatGPT [50, 8]. We note we cannot
discount the possibility that either ChatGPT or GPT-4 was trained on significant portions of
our evaluation suite. However, the presence of a significant gap between TÃœLU models and ChatGPT
matches our findings in the model and human-based evaluation settings, which are less likely to be
compromised.
5.3
Model-Based Evaluation Results for Open-Ended Generation
We report the AlpacaFarm win-rates of our models in Table 6. We find that:
Models trained on mixtures based on traditional NLP datasets perform poorly. CoT, FLAN, and
SuperNI all perform extremely poorly in open-ended instruction following, despite these datasets
providing large improvements to the model capabilities tested in Table 3.
7

Training Dataset â†“
7B
13B
30B
65B
SuperNI
5.7
6.2
-
-
CoT
4.2
5.6
-
-
Flan V2
4.6
5.5
-
-
Dolly
12.7
16.2
-
-
Open Assistant 1
47.8
53.5
-
-
Self-instruct (original)
7.5
6.8
-
-
Unnatural Instructions
8.2
10.9
-
-
Alpaca
21.1
28.7
-
-
Code-Alpaca
17.5
19.4
-
-
GPT4-Alpaca
57.0
61.1
-
-
Baize
23.5
28.7
-
-
ShareGPT
58.3
68.9
70.2
72.8
Human mix.
29.4
36.3
44.6
46.5
TÃœLU
48.3
53.9
63.5
62.7
Table 6: Win-rate (%) of LLAMA models of vary-
ing sizes fine-tuned on the given dataset against
Davinci-003 using AlpacaFarm [16].
GPT-4
ChatGPT
Davinci-003
SuperNI
CoT
Flan V2
Dolly
Open Assistant 1
ShareGPT
Self-instruct
Unnatural Instructions
Alpaca
Code-Alpaca
GPT4-Alpaca
Baize
Human mix.
Human+GPT mix.
0
25
50
75
100
0
40
80
120
160
Win % vs Davinci-003 (GPT-4 Eval)
Avg. # of Unique Tokens in Response
Figure 2: Win-rate scores of 13B models (trained
on different datasets) given by GPT-4 strongly
correlate with the average numbers of unique to-
kens in the model responses (Pearson ğ‘Ÿ= 0.96).
Datasets that encourage long, diverse generations perform best. Intrigued by ShareGPTâ€™s perfor-
mance, we plot the average number of unique tokens in model generations against the AlpacaFarm
win-rate in Figure 2. We find that the evaluation is strongly correlated with the average number
of unique tokens (Pearson correlation of 0.96, ğ‘â‰ª0.05). Given GPT-4â€™s strong performance on
other tasks, we do not believe that GPT-4 evaluation is merely counting unique tokens, but this result
highlights how model preference scores do not necessarily reward only model capabilities.
ShareGPT performs best. We find that ShareGPT consistently performs best across all model
sizes, including models trained on data mixes that include ShareGPT. Models trained on ShareGPT
achieve higher win-rates than models over twice their size (e.g., 13B ShareGPT vs 65B TÃœLU). We
hypothesize this is due to ShareGPTâ€™s diversity, size, and the high average # tokens of target responses.
Overall, these results suggest that while model preference evaluation is important, it does not provide
a holistic evaluation of these models. Instead, model preference evaluation should only be included
as part of a larger, more comprehensive evaluation setup.
5.4
Human Evaluation Results for Open-Ended Generation
Finally, we show the human evaluation results in Figure 4 and we refer the reader to appendix Â§E.2 for
the inner-annotator agreement. We find that the human evaluation results largely correlate with the
AlpacaFarm and benchmark-based evaluation: all evaluations suggest evaluations show that 65B
TÃœLU outperforms 7B TÃœLU, suggesting making use of larger base models is important, and there is
still a nontrivial gap in performance between 65B TÃœLU and ChatGPT. We also find that making use
of distilled datasets provides a large performance boost, suggesting that human-authored datasets
are lacking in comparison. These observations are also consistent with the acceptability scores in
Figure 3. However, we note that 7B TÃœLU outperforms the human-mix 65B TÃœLU in the model
preference evaluation, but if we compare the acceptability scores in Figure 3, the opposite appears true.
This is further evidence that model pairwise evaluation may not always reveal model deficiencies. In
this case, the 65B human-mix model is more likely to yield acceptable (if not high-quality) responses
than the 7B model.
6
Related Work
Instruction Tuning of LMs
Finetuning language models on diverse instruction sets alongside
regular samples has been shown to greatly improve zero-shot performance on unseen tasks [34, 45,
43, 27, 9, 42], and serves as a good base for further finetuning in supervised settings [26]. Increasing
the number of diverse prompts [34], the number of tasks [42, 9], and diversity of data [50] have all
been shown to be important to performance. More recently, a growing number of models have made
use of model-generated instruction-augmented data [41, 21, 24, 47], most often generated or collected
8

90.1%
79.8%
68.7%
72.3%
ChatGPT
TÃ¼lu 65B
TÃ¼lu 7B
TÃ¼lu 65B
Acceptance Rate
(Human mix.)
Figure 3:
Human acceptance
rates for four evaluated models.
TÃ¼lu 65B
TÃ¼lu 65B
TÃ¼lu 65B
ChatGPT
TÃ¼lu 7B
TÃ¼lu 65B
(human mix.)
27.7%
39.2%
45.2%
22.8%
50.0%
20.1%
26.8%
23.2%
29.8%
12.3% 7.8%
24.1%
21.1%
31.9%
11.7% 11.1%
7.2%
20.5%
33.1%
19.3%
19.9%
L is clearly better
L is slightly better
Tie
R is slightly better
R is clearly better
Figure 4: Human preference rates for three comparison pairs of
models.
from larger proprietary models such as ChatGPT or GPT-4 [8, 15, 38, 46, 31, inter alia]. Despite
the explosion of models and datasets, evaluation remains inconsistent and difficult, with different
evaluation setups used across models. Prior work has examined models trained on varying dataset
sources with the aim of identifying â€˜the best mixtureâ€™ [26, 22], but is often limited to examining
only benchmark performance, and covers a smaller number of instruction sources than in this work.
QLoRA [14] also explores (quantized and parameter-efficient) instruction-tuning of recent models
and datasets, but explores a smaller range of models, datasets, and evaluations than this work.
Evaluation of LMs
Given the success of LMs on NLP and instruction-following tasks, many
evaluation frameworks have been proposed. Frameworks such as HELM [25] and LM Evaluation
Harness [17] cover a broad range of NLP tasks but are often focused on evaluating the base models
as opposed to instruction-tuned ones. Similar to our work, Chung et al. [9] focus on a series of
benchmark evaluations focused around factuality and reasoning, but largely neglect open-ended
instruction following abilities. Releases of large (closed) proprietary models such as GPT-4 [29]
and PaLM v2 [2] are often accompanied with comprehensive evaluations over a wide variety of
benchmarks, although both similarly neglect evaluation of open-ended instruction following. Recently,
evaluation frameworks such as Alpaca Farm [16] and Chatbot Arena [49] have been proposed to
evaluate the open-ended instruction following ability of LMs, moving beyond benchmark-based
evaluations. These either make use of other models (in the case of AlpacaFarm) or humans (in the
case of Chatbot Arena) as annotators for judging model generations. We make use of this recent
work and evaluate our models on traditional benchmarks, model-based evaluation, and human-based
evaluation.
7
Conclusion
In this work, we provide an extensive evaluation of a wide variety of publicly-available resources for
instruction-tuning models, and compare them to the strongest proprietary models currently available.
We find that using strong base models is vital to performance, combining datasets works best on
average (but does result in slight performance drops compared to best performance in specific tasks),
and our strongest open models do not yet match ChatGPT or GPT-4. Furthermore, we believe that
our evaluation highlights the need for the continued development of strong base models and broader,
diverse datasets. Finally, we hope that our evaluation and released code and models enable more
comprehensive evaluations and spur research to close these gaps and shed insights on all large language
models, closed or open.
8
Limitations
Despite the comprehensiveness of our evaluations, we note that we did not exhaustively cover all
possible evaluations: for example, we do not explicitly evaluate models on their multi-turn dialogue
abilities nor their summarization abilities. Instead, we focus on a core set of capabilities we believe
important, and cover broad open-ended tasks via our model and human preference-based evaluations.
We also note that we do not cover all possible instruction datasets and open models released re-
cently, due to the computational cost of doing this. Instead, we focus on a wide set of datasets we
believe are broadly representative of the type of open instruction datasets available (human-authored,
9

skill-targeted, GPT-distilled, etc), and focused on the strongest base model widely available when
performing experiments. Future work could investigate whether more recent strong base models (e.g.,
the Falcon model [1]), or other instruction datasets, perform significantly better or differently from
the models explored in this work.
Despite not being completely exhaustive in this work, we believe that by covering a broad range of
models, it still serves as a useful and important contribution in showing what type of open resources
work, and where future community efforts should go (better base models, more diverse instruction-
tuning datasets).
9
Broader Impact
We believe that a rigorous evaluation of existing resources is broadly positive, exposing the strengths
and deficiencies of currently widely-available resources. Furthermore, as all resources used are widely
available, the harm posed by training these models is fairly small. We do note that training and
releasing especially large instruction-tuned models without well-tested guides carries a degree of risk,
and such initially release our largest models with a gated setup to limit potential harm.
Acknowledgments
We thank colleagues at AI2 and UW NLP for their constructive feedback and intellectual support.
We are particularly grateful to Tim Dettmers for his suggestions on efficient inference techniques,
and Artidoro Pagnoni for providing the reproduced FLAN V2 dataset. We also acknowledge support
from AMD and CSCâ€™s LUMI cluster, and the Beaker team at AI2, which provided the essential
computational infrastructure for our experiments. Finally, we are sincerely thankful for the following
contributors to our human evaluation: Valentina Pyatkin, Clara Na, Yuling Gu, Yuchen Lin, Haiyan
He, David Graham, Hao Peng, Hyunwoo Kim, Alisa Liu, Youngjae Yu, Tal August, and Egor Klevak.
References
[1] E. Almazrouei, H. Alobeidli, A. Alshamsi, A. Cappelli, R. Cojocaru, M. Debbah, E. Goffinet,
D. Heslow, J. Launay, Q. Malartic, B. Noune, B. Pannier, and G. Penedo. Falcon-40B: an open
large language model with state-of-the-art performance. 2023.
[2] R. Anil, A. M. Dai, O. Firat, M. Johnson, D. Lepikhin, A. Passos, S. Shakeri, E. Taropa, P. Bailey,
Z. Chen, E. Chu, J. H. Clark, L. E. Shafey, Y. Huang, K. Meier-Hellstern, G. Mishra, E. Moreira,
M. Omernick, K. Robinson, S. Ruder, Y. Tay, and et al. Palm 2 technical report, 2023.
[3] Y. Bai, A. Jones, K. Ndousse, A. Askell, A. Chen, N. DasSarma, D. Drain, S. Fort, D. Ganguli,
T. Henighan, et al. Training a helpful and harmless assistant with reinforcement learning from
human feedback. arXiv preprint arXiv:2204.05862, 2022.
[4] S. Biderman, H. Schoelkopf, Q. Anthony, H. Bradley, K. Oâ€™Brien, E. Hallahan, M. A. Khan,
S. Purohit, U. S. Prashanth, E. Raff, A. Skowron, L. Sutawika, and O. van der Wal. Pythia: A
suite for analyzing large language models across training and scaling, 2023.
[5] T. Cai, X. Wang, T. Ma, X. Chen, and D. Zhou. Large language models as tool makers. arXiv
preprint arXiv:2305.17126, 2023.
[6] S. Chaudhary. Code alpaca: An instruction-following llama model for code generation. https:
//github.com/sahil280114/codealpaca, 2023.
[7] M. Chen, J. Tworek, H. Jun, Q. Yuan, H. P. de Oliveira Pinto, J. Kaplan, H. Edwards, Y. Burda,
N. Joseph, G. Brockman, A. Ray, R. Puri, G. Krueger, and M. P. et al. Evaluating large language
models trained on code, 2021.
[8] W.-L. Chiang, Z. Li, Z. Lin, Y. Sheng, Z. Wu, H. Zhang, L. Zheng, S. Zhuang, Y. Zhuang,
J. E. Gonzalez, I. Stoica, and E. P. Xing. Vicuna: An open-source chatbot impressing gpt-
4 with 90%* chatgpt quality. Blog post, March 2023. URL https://lmsys.org/blog/
2023-03-30-vicuna/.
10

[9] H. W. Chung, L. Hou, S. Longpre, B. Zoph, Y. Tay, W. Fedus, E. Li, X. Wang, M. De-
hghani, S. Brahma, et al. Scaling instruction-finetuned language models. arXiv preprint
arXiv:2210.11416, 2022.
[10] J. H. Clark, E. Choi, M. Collins, D. Garrette, T. Kwiatkowski, V. Nikolaev, and J. Palomaki.
TyDi QA: A benchmark for information-seeking question answering in typologically diverse
languages. TACL, 2020. URL https://arxiv.org/abs/2003.05002.
[11] K. Cobbe, V. Kosaraju, M. Bavarian, M. Chen, H. Jun, L. Kaiser, M. Plappert, J. Tworek,
J. Hilton, R. Nakano, C. Hesse, and J. Schulman. Training verifiers to solve math word problems.
arXiv preprint arXiv:2110.14168, 2021.
[12] Databricks.
Free dolly:
Introducing the worldâ€™s first truly open instruction-tuned
llm.
Blog post, 2023.
URL https://www.databricks.com/blog/2023/04/12/
dolly-first-open-commercially-viable-instruction-tuned-llm.
[13] T. Dettmers, M. Lewis, Y. Belkada, and L. Zettlemoyer. LLM.int8(): 8-bit matrix multiplication
for transformers at scale. In Advances in Neural Information Processing Systems, 2022.
[14] T. Dettmers, A. Pagnoni, A. Holtzman, and L. Zettlemoyer. Qlora: Efficient finetuning of
quantized llms, 2023.
[15] N. Ding, Y. Chen, B. Xu, S. Hu, Y. Qin, Z. Liu, M. Sun, and B. Zhou. Ultrachat: A large-scale
auto-generated multi-round dialogue data. https://github.com/thunlp/ultrachat, 2023.
[16] Y. Dubois, X. Li, R. Taori, T. Zhang, I. Gulrajani, J. Ba, C. Guestrin, P. Liang, and T. B.
Hashimoto. Alpacafarm: A simulation framework for methods that learn from human feedback,
2023.
[17] L. Gao, J. Tow, S. Biderman, S. Black, A. DiPofi, C. Foster, L. Golding, J. Hsu, K. McDonell,
N. Muennighoff, J. Phang, L. Reynolds, E. Tang, A. Thite, B. Wang, K. Wang, and A. Zou. A
framework for few-shot language model evaluation, Sept. 2021. URL https://doi.org/10.
5281/zenodo.5371628.
[18] X. Geng and H. Liu. Openllama: An open reproduction of llama, May 2023. URL https:
//github.com/openlm-research/open_llama.
[19] X. Geng, A. Gudibande, H. Liu, E. Wallace, P. Abbeel, S. Levine, and D. Song. Koala: A
dialogue model for academic research. Blog post, April 2023. URL https://bair.berkeley.
edu/blog/2023/04/03/koala/.
[20] D. Hendrycks, C. Burns, S. Basart, A. Zou, M. Mazeika, D. Song, and J. Steinhardt. Mea-
suring massive multitask language understanding. In International Conference on Learning
Representations (ICLR), 2020.
[21] O. Honovich, T. Scialom, O. Levy, and T. Schick. Unnatural instructions: Tuning language
models with (almost) no human labor, 2022.
[22] S. Iyer, X. V. Lin, R. Pasunuru, T. Mihaylov, D. Simig, P. Yu, K. Shuster, T. Wang, Q. Liu, P. S.
Koura, X. Li, B. Oâ€™Horo, G. Pereyra, J. Wang, C. Dewan, A. Celikyilmaz, L. Zettlemoyer, and
V. Stoyanov. Opt-iml: Scaling language model instruction meta learning through the lens of
generalization, 2023.
[23] A. KÃ¶pf, Y. Kilcher, D. von RÃ¼tte, S. Anagnostidis, Z.-R. Tam, K. Stevens, A. Barhoum, N. M.
Duc, O. Stanley, R. Nagyfi, et al. Openassistant conversationsâ€“democratizing large language
model alignment. arXiv preprint arXiv:2304.07327, 2023.
[24] A. KÃ¶ksal, T. Schick, A. Korhonen, and H. SchÃ¼tze. Longform: Optimizing instruction tuning
for long text generation with corpus extraction, 2023.
[25] P. Liang, R. Bommasani, T. Lee, D. Tsipras, D. Soylu, M. Yasunaga, Y. Zhang, D. Narayanan,
Y. Wu, A. Kumar, B. Newman, B. Yuan, B. Yan, C. Zhang, C. Cosgrove, C. D. Manning, C. Râ€™e,
D. Acosta-Navas, D. A. Hudson, E. Zelikman, E. Durmus, F. Ladhak, F. Rong, H. Ren, H. Yao,
J. Wang, K. Santhanam, L. J. Orr, L. Zheng, M. Yuksekgonul, M. Suzgun, N. S. Kim, N. Guha,
11

N. S. Chatterji, O. Khattab, P. Henderson, Q. Huang, R. Chi, S. M. Xie, S. Santurkar, S. Ganguli,
T. Hashimoto, T. F. Icard, T. Zhang, V. Chaudhary, W. Wang, X. Li, Y. Mai, Y. Zhang, and
Y. Koreeda. Holistic evaluation of language models. Annals of the New York Academy of
Sciences, 2022.
[26] S. Longpre, L. Hou, T. Vu, A. Webson, H. W. Chung, Y. Tay, D. Zhou, Q. V. Le, B. Zoph, J. Wei,
and A. Roberts. The flan collection: Designing data and methods for effective instruction tuning,
2023.
[27] S. Mishra, D. Khashabi, C. Baral, and H. Hajishirzi. Cross-Task Generalization via Natural
Language Crowdsourcing Instructions. In Annual Meeting of the Association for Computational
Linguistics (ACL), 2022.
[28] MosaicML. Introducing mpt-7b: A new standard for open-source, commercially usable llms,
2023. URL https://www.mosaicml.com/blog/mpt-7b.
[29] OpenAI. Gpt-4 technical report, 2023.
[30] L. Ouyang, J. Wu, X. Jiang, D. Almeida, C. L. Wainwright, P. Mishkin, C. Zhang, S. Agarwal,
K. Slama, A. Ray, et al. Training Language Models to Follow Instructions with Human Feedback.
In Advances in Neural Information Processing Systems (NeurIPS), 2022.
[31] B. Peng, C. Li, P. He, M. Galley, and J. Gao. Instruction tuning with gpt-4. arXiv preprint
arXiv:2304.03277, 2023.
[32] S. Rajbhandari, J. Rasley, O. Ruwase, and Y. He. Zero: Memory optimizations toward training
trillion parameter models. In Proceedings of the International Conference for High Performance
Computing, Networking, Storage and Analysis, SC â€™20. IEEE Press, 2020. ISBN 9781728199986.
[33] J. Rasley, S. Rajbhandari, O. Ruwase, and Y. He. Deepspeed: System optimizations enable
training deep learning models with over 100 billion parameters. In Proceedings of the 26th
ACM SIGKDD International Conference on Knowledge Discovery & Data Mining, 2020.
[34] V. Sanh, A. Webson, C. Raffel, S. Bach, L. Sutawika, Z. Alyafeai, A. Chaffin, A. Stiegler, A. Raja,
M. Dey, M. S. Bari, C. Xu, U. Thakker, S. S. Sharma, E. Szczechla, T. Kim, G. Chhablani,
N. Nayak, D. Datta, J. Chang, M. T.-J. Jiang, H. Wang, M. Manica, S. Shen, Z. X. Yong,
H. Pandey, R. Bawden, T. Wang, T. Neeraj, J. Rozen, A. Sharma, A. Santilli, T. Fevry, J. A.
Fries, R. Teehan, T. L. Scao, S. Biderman, L. Gao, T. Wolf, and A. M. Rush. Multitask Prompted
Training Enables Zero-Shot Task Generalization. In International Conference on Learning
Representations (ICLR), 2022.
[35] N. Shazeer, A. Mirhoseini, K. Maziarz, A. Davis, Q. Le, G. Hinton, and J. Dean. Outrageously
large neural networks: The sparsely-gated mixture-of-experts layer. In International Conference
on Learning Representations, 2017.
[36] A. Srivastava, A. Rastogi, A. Rao, A. A. M. Shoeb, A. Abid, A. Fisch, A. R. Brown, A. Santoro,
and et al. Beyond the imitation game: Quantifying and extrapolating the capabilities of language
models. arXiv preprint arXiv:2206.04615, 2022.
[37] M. Suzgun, N. Scales, N. SchÃ¤rli, S. Gehrmann, Y. Tay, H. W. Chung, A. Chowdhery, Q. V. Le,
E. H. Chi, D. Zhou, et al. Challenging big-bench tasks and whether chain-of-thought can solve
them. arXiv preprint arXiv:2210.09261, 2022.
[38] R. Taori, I. Gulrajani, T. Zhang, Y. Dubois, X. Li, C. Guestrin, P. Liang, and T. B. Hashimoto.
Stanford alpaca: An instruction-following llama model. https://github.com/tatsu-lab/
stanford_alpaca, 2023.
[39] H. Touvron, T. Lavril, G. Izacard, X. Martinet, M.-A. Lachaux, T. Lacroix, B. RoziÃ¨re, N. Goyal,
E. Hambro, F. Azhar, A. Rodriguez, A. Joulin, E. Grave, and G. Lample. Llama: Open and
efficient foundation language models, 2023.
[40] P. Wang, L. Li, L. Chen, D. Zhu, B. Lin, Y. Cao, Q. Liu, T. Liu, and Z. Sui. Large language
models are not fair evaluators, 2023.
12

[41] Y. Wang, Y. Kordi, S. Mishra, A. Liu, N. A. Smith, D. Khashabi, and H. Hajishirzi. Self-instruct:
Aligning language models with self-generated instructions, 2022.
[42] Y. Wang, S. Mishra, P. Alipoormolabashi, Y. Kordi, A. Mirzaei, A. Arunkumar, A. Ashok,
A. S. Dhanasekaran, A. Naik, D. Stap, et al. Super-NaturalInstructions: Generalization via
Declarative Instructions on 1600+ Tasks. In EMNLP, 2022.
[43] J. Wei, M. Bosma, V. Zhao, K. Guu, A. W. Yu, B. Lester, N. Du, A. M. Dai, and Q. V. Le.
Finetuned Language Models are Zero-Shot Learners. In International Conference on Learning
Representations (ICLR), 2022.
[44] J. Wei, X. Wang, D. Schuurmans, M. Bosma, E. Chi, Q. Le, and D. Zhou. Chain of thought
prompting elicits reasoning in large language models. arXiv preprint arXiv:2201.11903, 2022.
[45] O. Weller, N. Lourie, M. Gardner, and M. E. Peters. Learning from task descriptions. In Proceed-
ings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP),
pages 1361â€“1375, Online, Nov. 2020. Association for Computational Linguistics. doi: 10.18653/
v1/2020.emnlp-main.105. URL https://aclanthology.org/2020.emnlp-main.105.
[46] C. Xu, D. Guo, N. Duan, and J. McAuley. Baize: An open-source chat model with parameter-
efficient tuning on self-chat data, 2023.
[47] C. Xu, Q. Sun, K. Zheng, X. Geng, P. Zhao, J. Feng, C. Tao, and D. Jiang. Wizardlm: Empow-
ering large language models to follow complex instructions, 2023.
[48] S. Zhang, S. Roller, N. Goyal, M. Artetxe, M. Chen, S. Chen, C. Dewan, M. Diab, X. Li, X. V.
Lin, T. Mihaylov, M. Ott, S. Shleifer, K. Shuster, D. Simig, P. S. Koura, A. Sridhar, T. Wang,
and L. Zettlemoyer. Opt: Open pre-trained transformer language models, 2022.
[49] L. Zheng, Y. Sheng, W.-L. Chiang, H. Zhang, J. E. Gonzalez, and I. Stoica. Chatbot Arena:
Benchmarking LLMs in the Wild with Elo Ratings. Blog post, May 2023. URL https:
//lmsys.org/blog/2023-05-03-arena/.
[50] C. Zhou, P. Liu, P. Xu, S. Iyer, J. Sun, Y. Mao, X. Ma, A. Efrat, P. Yu, L. Yu, S. Zhang, G. Ghosh,
M. Lewis, L. Zettlemoyer, and O. Levy. Lima: Less is more for alignment, 2023.
13

Supplementary Material
A
Instruction Datasets Details
We provide a brief description of all the instruction datasets used (and licenses) below:
â€¢ SuperNI: A collection of diverse NLP tasks with instructions, created by Wang et al. [42]. The
dataset uses the Apache-2.0 license.
â€¢ CoT: A collection of datasets annotated with chain-of-thoughts [44]. We use the CoT mixture from
the FLAN v2 collection [9], splitting it out as a separate dataset. The FLAN mixture is released
under the Apache-2.0 license, although the component datasets may not use this license.
â€¢ Flan V2: A collection of NLP tasks that combines a number of existing NLP datasets with various
data augmentations, introduced by Chung et al. [9]. The mixture is released under the Apache-2.0
license, although the component datasets may not use this license.
â€¢ Dolly: A collection of instruction-following samples created by Databricks employees [12]. The
dataset is released under the Creative Commons Attribution-ShareAlike 3.0 Unported License.
â€¢ Open Assistant 1: A crowdsourced human-annotated assistant-style conversation corpus, consist-
ing of a large number of sample conversations in a wide variety of languages [23]. The dataset is
released under the Apache-2.0 license.
â€¢ Self-Instruct: A dataset of instruction-following samples created by prompting GPT-3 to create
new samples given some example instances [41]. The dataset is released under the Apache-2.0
license.
â€¢ Unnatural Instructions: A dataset of instruction-following samples created by prompting Davinci-
002 using the method introduced by Honovich et al. [21]. The dataset is released under the MIT
license.
â€¢ Alpaca: A dataset created using a self-instruct-style method with Davinci-003 as the generation
model and some over improvements over self-instruct [38]. The dataset is released under a
Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) license.
â€¢ Code-Alpaca: A dataset created using the Alpaca method, but focussing on code generation [6].
The dataset is released under the Apache-2.0 license.
â€¢ GPT-4 Alpaca: A dataset created using the Alpaca dataset as inputs, but replacing the example
generations with generations from GPT-4 [31]. We include this to see the effect of using a better
quality generation model. The dataset is released under the Apache-2.0 license.
â€¢ Baize: A dataset created by prompt ChatGPT and letting it converse with itself [46]. The dataset is
released under the GNU General Public License v3.0.
â€¢ ShareGPT: A collection of user interactions with various chat systems publicly shared. We use the
â€˜html-cleanedâ€™ variant available at https://huggingface.co/datasets/anon8231489123/
ShareGPT_Vicuna_unfiltered/tree/main/HTML_cleaned_raw_dataset. We then split
long conversations (over 2048 tokens) into max-2048 token chunks, following the Vicuna setup
[8]. We do not do any further filtering of samples. This dataset is released under the Apache-2.0
license.
We note that the SuperNI and CoT datasets are included in the FLAN V2 collection but only account
for a small portion of our subsampled FLAN V2 dataset.
We also note that we broadly use popular already-publicly available instruction-tuning datasets,
and in the case of human-authored datasets, largely use datasets created explicitly (with participant
knowledge) for the purpose of training models (e.g., Dolly, Open Assistant 1). As instruction-tuning
data, most data is not likely to contain personally identifying details, although we note that we did
not make an effort to remove offensive content, and so our models may produce toxic or harmful
generations.
B
Model Training Details and Compute
We train all models for two epochs with a learning rate of 2ğ‘’âˆ’5 (1ğ‘’âˆ’5 for 30B and 65B models), with
no weight decay and a learning rate with linear decay and linear warmup for 3% of the total training
14

steps. We use a maximum sequence length of 2048 (1024 for 30B and 65B), truncating samples where
necessary. During training, we make use of the DeepSpeed library [33] and ZeRO optimizer [32]
to allow for large-scale model finetuning. In all cases, we fully finetune models. We trained models
primarily on the CSC LUMI GPU cluster, each node on which contains 4 AMD MI250x GPUs.
C
Evaluation Setups
We provide further details on the evaluation setups used below. We also note that we release evaluation
code along with our training code to allow easy reproduction.
â€¢ MMLU: We use the official MMLU evaluation script and prompts available at https://github.
com/hendrycks/test, with modifications to allow for batch processing. We evaluate using 0
and 5 few-shot examples, following the original setup of MMLU.
â€¢ GSM: We evaluate models on the test set of GSM. Following Wei et al. [44], we evaluate with
and without chain-of-thought (CoT vs Direct). Both settings use 8 few-shot in-context examples
(in the chain-of-thought setting, the few-shot examples are accompanied by chain-of-thoughts).
Because all answers in GSM are numbers, we extract the last number in the model response as the
final answer. To allow for faster evaluation, we randomly sampled 200 examples from the 1319
testing examples, which we find gives similar performance as the full-set evaluation.
â€¢ BBH: We follow the setup described in the original paper Suzgun et al. [37], and evaluate with and
without chain-of-thought (CoT vs Direct). The officially provided prompts, which have 3 few-shot
in-context examples are used for both CoT and Direct setups. For the CoT setup, we extract the first
word after the phrase â€˜So the answer isâ€™, or the entire response if there is no such substring present.
â€¢ TydiQA We follow the setup described in the PaLM 2 technical report [2] to evaluate modelsâ€™
performance in answering multilingual questions under two settings: 1) when the gold passage that
contains the answer is given (GoldP/GP); 2) when there is no context given (Closed-Book/CB).
One in-context example is used to familiarize the model with the answering format.
â€¢ Codex-Eval We use the HumanEval dataset in the Codex paper [7] for evaluating modelsâ€™ coding
ability. The dataset contains 164 programming problems, where models are prompted to complete
the Python function given its docstring. Following the original paper, we compute unbiased
estimates of pass@k to measure the functional correctness of modelsâ€™ outputs. We report both
pass@1 and pass@10. The pass@1 results were obtained by sampling with a temperature of 0.1
and the pass@10 results with a temperature of 0.8.
â€¢ AlpacaFarm We use the code provided by Dubois et al. [16], but augment it to use a single GPT-4
annotator (â€˜greedy_gpt4â€™). We replace the original Davinci-003 reference text with our own,
regenerated with a higher maximum token limit (2048) and a temperature of 0. For the models
being evaluated, we use the same prompts as Dubois et al. [16], slightly altered to fit our message
format. We greedily decode up to 2048 tokens and then pairwise compare these responses with
those from Davinci-003. By default, we use a batch of 5 (i.e., ask GPT-4 to annotate 5 examples at
once), but we reduce the batch to fit examples if they exceed the 8192 token context window limit.
The reported win-rate is the percentage of model generations that GPT-4 reports as being preferred
over the generations from Davinci-003.
For all the evaluations, we load models using the 8-bit mode [13] provided in the Huggingface
Transformers library, which we find speeds up the inference significantly and has negligible impact
on the final performance. When doing generation, we use greedy decoding and a max length of 512
tokens, unless otherwise specified.
D
Overview of all the automatic evaluation results
Table 7 presents a compilation of the results of all models trained as part of this work on all the
evaluation benchmarks. We list multiple scenarios for all evaluation settings except AlpacaFarm,
which has one setting. Please refer to Â§C for the meanings of the reported metrics.
We also calculate an average across benchmarks in Table 7. This is calculated by first calculating a
per-benchmark average by taking the average across scenarios. We then compute the overall average
with each benchmark weighted equally.
15

Table 7: An overview of the performance of all models finetuned for this work, along with proprietary
models, on selected benchmarks. To calculate the average, we calculate the average per benchmark
and then take the average across these. See App. D for more details.
MMLU
GSM
BBH
TydiQA
Codex-Eval
AlpacaFarm
Average
0-shot 5-shot
Direct
CoT Direct
CoT
GP
CB
P@1 P@10
v Davinci-003
-
Proprietary models â†“
GPT-4
82.4
83.9
35.0
92.5
50.9
88.0
70.8 27.6
85.7
94.1
91.5
74.5
ChatGPT
67.9
69.9
32.5
76.0
49.0
66.1
51.9 20.0
72.2
88.4
84.4
63.6
LLaMa 65B finetuning experiments â†“
Vanilla LLaMa
58.3
63.4
14.0
50.5
45.5
57.1
57.4
16.6
24.4
42.9
-
-
ShareGPT
61.5
62.8
14.5
42.0
42.4
52.1
33.5
9.5
29.9
54.0
72.8
45.6
Human mix.
60.7
61.6
8.0
57.5
50.1
52.7
58.5
15.9
24.5
43.2
46.5
43.8
H+GPT mix (
)
59.2
61.1
9.0
60.0
48.1
53.5
51.8 13.3
28.9
45.9
62.7
46.3
LLaMa 30B finetuning experiments â†“
Vanilla LLaMa
54.1
58.4
12.5
33.5
37.5
48.5
57.5
15.6
19.5
42.9
-
-
ShareGPT
54.7
57.8
13.5
38.5
41.0
50.6
32.4
9.9
25.9
37.9
70.2
41.9
Human mix.
56.3
58.9
6.5
49.5
46.6
47.8
58.9
12.7
22.6
39.4
44.6
40.7
H+GPT mix (
)
57.7
58.4
6.0
51.0
45.8
48.7
58.2 12.3
25.4
46.0
63.5
44.7
LLaMa 13B finetuning experiments â†“
Vanilla LLaMa
42.5
46.9
6.5
14.0
38.7
36.9
47.4 11.5
14.8
26.6
-
-
SuperNI
49.8
50.8
2.5
4.0
38.3
2.8
51.4 10.4
8.2
13.1
6.2
20.3
CoT
44.5
45.4
9.5
39.5
38.6
39.0
52.2
11.5
11.5
23.3
5.6
27.2
Flan V2
50.7
51.2
4.0
21.0
42.2
39.2
47.5
10.9
7.2
16.2
5.5
25.1
Dolly
45.3
44.7
6.0
17.0
31.4
26.0
46.8
12.4
13.4
31.4
16.2
25.5
Open Assistant 1
43.1
34.0
5.0
16.0
34.8
38.5
38.3
9.2
14.1
31.8
53.5
31.1
Self-instruct
30.3
32.3
4.5
9.0
33.6
29.6
40.4
9.3
8.6
13.4
6.8
18.7
Unnat. Instruct.
46.2
45.7
5.0
7.5
37.6
32.8
39.3
9.1
13.9
24.8
10.9
23.6
Alpaca
45.1
47.1
6.0
8.0
35.0
34.5
32.8
7.8
15.7
27.6
28.7
26.4
Code-Alpaca
42.6
44.3
5.0
12.0
35.5
36.6
41.3 10.9
20.1
34.5
19.4
26.8
GPT4-Alpaca
47.0
46.9
7.5
14.0
34.9
38.3
24.4
6.1
15.8
32.5
61.1
32.5
Baize
43.5
41.5
4.5
8.5
35.3
36.7
33.9
9.0
14.5
27.3
28.7
26.0
ShareGPT
49.2
47.4
7.0
16.0
23.6
40.1
30.1
8.3
16.1
31.6
68.9
33.9
Human mix.
50.4
51.2
6.5
36.5
40.6
39.4
49.8
9.3
11.3
23.7
36.3
32.6
H+GPT mix (
)
49.2
51.8
5.0
36.5
41.3
42.8
46.1
9.2
21.3
35.0
53.9
37.2
LLaMa 7B finetuning experiments â†“
Vanilla LLaMa
31.9
35.2
6.0
9.0
34.0
33.3
39.1
9.5
11.6
18.3
-
-
SuperNI
44.1
43.4
3.0
4.0
38.4
1.9
47.9
7.1
7.0
11.7
5.7
18.3
CoT
41.3
42.5
6.5
27.5
33.7
31.3
44.4
8.5
7.4
17.3
4.2
22.4
Flan V2
45.4
47.1
3.5
13.0
38.6
36.1
45.0
8.3
9.6
12.9
4.6
22.4
Dolly
38.0
35.8
5.0
7.0
27.2
24.4
43.6
8.7
11.1
22.1
12.7
20.7
Open Assistant 1
32.9
29.7
6.0
6.5
20.4
29.5
26.8
7.8
10.1
20.4
47.8
23.8
Self-instruct
35.7
33.2
4.0
6.5
29.9
29.2
35.4
8.7
6.2
12.1
7.5
18.0
Unnat. Instruct.
42.9
38.1
3.5
5.0
31.4
30.0
36.3
6.5
10.3
19.8
8.2
20.0
Alpaca
41.5
40.3
7.0
10.0
32.6
31.8
31.2
7.2
13.2
22.0
21.1
23.3
Code-Alpaca
34.7
34.5
6.5
7.5
29.6
30.5
36.7
10.5
16.5
29.2
17.5
22.6
GPT4-Alpaca
42.6
38.3
6.5
10.0
28.5
32.3
23.6
5.8
13.2
25.0
57.0
28.3
Baize
40.3
38.6
3.5
5.5
30.6
32.4
29.8
7.9
12.2
23.8
23.5
22.6
ShareGPT
44.3
40.0
8.0
9.5
5.2
32.6
25.5
8.9
10.9
21.6
58.3
26.9
Human mix
46.2
48.0
4.5
26.5
35.6
34.8
42.2
7.7
9.4
20.2
29.4
27.8
H+GPT mix (
)
44.5
47.0
6.0
27.0
38.1
39.2
45.7
7.7
17.5
27.8
48.3
33.1
Non-LLaMa 7B finetuning experiments â†“
OPT 6.7B
25.4
25.3
6.0
3.5
31.4
28.5
15.5
3.6
0.6
0.9
-
-
+H+GPT mix
33.8
34.9
3.0
15.5
31.9
27.9
27.2
4.1
4.8
7.9
14.5
18.3
Pythia 6.9B
25.7
24.1
5.5
3.0
29.5
29.3
28.4
5.0
8.2
13.5
-
-
+H+GPT mix
34.1
34.6
3.5
15.5
31.3
27.8
33.4
3.8
14.3
21.4
9.2
19.8
16

E
Human Evaluation Details
E.1
Setup
Here we provide more details for the human evaluation described in Â§4.3. Our evaluation contains 332
instructions, including 252 instructions from the Self-Instruct evaluation set [41] and 80 instructions
from the Vicuna evaluation set [8]. Our evaluation is conducted for 3 pairs of models: 1) TÃœLU 65B
vs ChatGPT, 2) TÃœLU 65B vs TÃœLU 7B, 3) TÃœLU 65B v.s. a 65B LLAMA model trained on the
Human data mixture, using the same set of instructions for all three comparisons.
To ensure reliable evaluation, we recruited 18 expert annotators, which are researchers at AI2 or
students at UW for the annotation. All these annotators are fluent English speakers and hold bachelorâ€™s
degrees or above.
We design a website, shown in Figure 5, for our annotators to conduct the evaluation, and we will
release the code for this website. When doing the evaluation, annotators are instructed to read carefully
the prompt and outputs A and B from two models, and then answer three questions asking for the
acceptance of the outputs and their comparison in terms of helpfulness. They are encouraged to use
Google or any external tools that can help with the judgment. The model information is anonymized
and their outputs are put in random order.
Figure 5: The website interface for our human evaluation. Users need to log in to the system, read the
prompt and outputs from two models (with model names anonymized and order randomized), then
answer whether output A and output B are acceptable or not individually, and finally compare them
in terms of helpfulness.
E.2
Inter-Annotator Agreement
We measure the agreement of our annotators on a subset of 119 examples (63 instances randomly
sampled from the ChatGPT3 vs TÃœLU 65B comparison, and 59 instances randomly sampled from
the TÃœLU 65B vs TÃœLU 7B comparison). We assign two annotators for each of these examples and
compute their agreement for both the acceptance evaluation and pairwise comparison evaluation.
17

The annotators achieve an agreement of 0.84 for whether a model output should be accepted or not.
For the pairwise comparison, following Zhou et al. [50], we report a tie-discounted accuracy, which
assigns one point if both annotators agreed, half a point if either annotator (but not both) labeled a tie,
and zero point otherwise. We also merged â€œclearly betterâ€ and â€œslightly betterâ€ together, so our final
options will be simply comparing which of A and B is better, or a tie. Our annotators achieved an
agreement of 0.72 for this pairwise comparison.
Although these numbers show reasonable agreement, we also note that there is a large extent of
subjectivity in human evaluation. This noise level also indicates that some prior work [8, 49] that
uses a small number of examples for human evaluation might not be reliable enough. We suggest
that the community needs to further improve the reliability and scalability of human evaluation for
instruction-following models.
18

