Scholars' Mine 
Scholars' Mine 
Doctoral Dissertations 
Student Theses and Dissertations 
Fall 2012 
Null Convention Logic applications of asynchronous design in 
Null Convention Logic applications of asynchronous design in 
nanotechnology and cryptographic security 
nanotechnology and cryptographic security 
Jun Wu 
Follow this and additional works at: https://scholarsmine.mst.edu/doctoral_dissertations 
 Part of the Computer Engineering Commons 
Department: Electrical and Computer Engineering 
Department: Electrical and Computer Engineering 
Recommended Citation 
Recommended Citation 
Wu, Jun, "Null Convention Logic applications of asynchronous design in nanotechnology and 
cryptographic security" (2012). Doctoral Dissertations. 1971. 
https://scholarsmine.mst.edu/doctoral_dissertations/1971 
This thesis is brought to you by Scholars' Mine, a service of the Missouri S&T Library and Learning Resources. This 
work is protected by U. S. Copyright Law. Unauthorized use including reproduction for redistribution requires the 
permission of the copyright holder. For more information, please contact scholarsmine@mst.edu. 

NULL CONVENTION LOGIC APPLICATIONS OF ASYNCHRONOUS DESIGN
IN NANOTECHNOLOGY AND CRYPTOGRAPHIC SECURITY
by
JUN WU
A DISSERTATION
Presented to the Faculty of the Graduate School of the
MISSOURI UNIVERSITY OF SCIENCE AND TECHNOLOGY
In Partial Fulﬁllment of the Requirements for the Degree
DOCTOR OF PHILOSOPHY
in
COMPUTER ENGINEERING
2012
Approved
Dr. Minsu Choi, Advisor
Dr. Daryl G. Beetner
Dr. Sahra Sedighsarvestani
Dr. Yiyu Shi
Dr. Dan Lin

c⃝2012
Jun Wu
All Rights Reserved

iii
ABSTRACT
This dissertation presents two Null Convention Logic (NCL) applications of
asynchronous logic circuit design in nanotechnology and cryptographic security. The
ﬁrst application is the Asynchronous Nanowire Reconﬁgurable Crossbar Architecture
(ANRCA); the second one is an asynchronous S-Box design for cryptographic system
against Side-Channel Attacks (SCA).
The following are the contributions of the ﬁrst application:
1) Proposed a diode- and resistor- based ANRCA (DR-ANRCA). Three con-
ﬁgurable logic block (CLB) structures were designed to eﬃciently reconﬁgure a given
DR-PGMB as one of the 27 arbitrary NCL threshold gates. A hierarchical archi-
tecture was also proposed to implement the higher level logic that requires a large
number of DR-PGMBs, such as multiple-bit NCL registers.
2) Proposed a memristor look-up-table based ANRCA (MLUT-ANRCA). An
equivalent circuit simulation model has been presented in VHDL and simulated in
Quartus II. Meanwhile, the comparison between these two ANRCAs have been ana-
lyzed numerically.
3) Presented the defect-tolerance and repair strategies for both DR-ANRCA
and MLUT-ANRCA.
The following are the contributions of the second application:
1) Designed an NCL based S-Box for Advanced Encryption Standard (AES).
Functional veriﬁcation has been done using Modelsim and Field-Programmable Gate
Array (FPGA).
2) Implemented two diﬀerent power analysis attacks on both NCL S-Box and
conventional synchronous S-Box.
3) Developed a novel approach based on stochastic logics to enhance the re-
sistance against DPA and CPA attacks. The functionality of the proposed design
has been veriﬁed using an 8-bit AES S-box design. The eﬀects of decision weight,
bitstream length, and input repetition times on error rates have been also studied.
Experimental results shows that the proposed approach enhances the resistance to
against the CPA attack by successfully protecting the hidden key.

iv
ACKNOWLEDGMENT
I would like to thank Dr. Minsu Choi, my advisor and the chairman of my
doctoral committee. The present work would not have been completed without his
great advice and insightful guidance. It has been a pleasure working in his research
group.
I would like to express my sincere gratitude to the remainder of my doctoral
committee. Dr. Yiyu Shi and Dr. Daryl G. Beetner provided useful integrated circuit
design background for the present work. Dr. Sahra Sedighsarvestani and Dr. Dan
Lin has taken time to review this work and has provided useful outside perspectives.
Most of my doctoral research was supported in part by the National Science
Foundation under Award Number ECCS-0801362.
Finally, I would like to thank my parents, Zhuanfang Wu and Huimin Su for
their continuous encouragement and support. I thank my husband, Hengsi, for his
great love.

v
TABLE OF CONTENTS
ABSTRACT ...........................................................................
iii
ACKNOWLEDGMENT ..............................................................
iv
LIST OF ILLUSTRATIONS ......................................................... vii
LIST OF TABLES ....................................................................
ix
SECTION
1. INTRODUCTION ...............................................................
1
1.1. OVERVIEW OF NCL .....................................................
2
1.2. ADVANTAGES OF USING NCL .........................................
5
1.3. WORKS SUMMARY ......................................................
7
2. PROJECT I: ANRCA ...........................................................
9
2.1. BACKGROUND............................................................
9
2.2. ADVANTAGES OF ANRCA .............................................. 11
2.3. DIODE- AND RESISTOR-BASED ANRCA (DR-ANRCA)............ 12
2.4. NUMERICAL ANALYSIS OF DR-ANRCA ............................. 15
2.4.1. Area .................................................................. 15
2.4.2. Programming Steps ................................................. 17
2.4.3. Latency .............................................................. 18
2.5. DEFECT/FAULT ISSUES OF DR-ANRCA ............................. 20
2.6. MEMRISTOR LOOK-UP-TABLE BASED ANRCA.................... 23
2.7. DEFECT/FAULT ISSUES OF DR-MLUT............................... 26
2.8. COMPARISON BETWEEN DR-ANRCA AND MLUT-ANRCA ...... 28
2.9. CONCLUSIONS............................................................ 31
3. PROJECT II: NCL S-BOX DESIGN .......................................... 32
3.1. BACKGROUND............................................................ 32
3.2. EXISTING COUNTERMEASURES ..................................... 33
3.3. NCL AES S-BOX DESIGN................................................ 35
3.4. FUNCTIONAL VERIFICATION ......................................... 38
3.5. POWER MEASUREMENT EXPERIMENT ............................ 41
3.6. DIFFERENTIAL POWER ANALYSIS ................................. 42
3.7. CORRELATION POWER ANALYSIS ................................... 45
3.8. NUMBER OF TRACES ................................................... 51

vi
3.9. CONCLUSIONS............................................................ 54
4. PROJECT III: STOCHASTIC BITSTREAMS COMPUTATION........... 55
4.1. BACKGROUND............................................................ 55
4.2. STOCHASTIC CRYPTOGRAPHIC DEVICES ......................... 57
4.2.1. MATLAB Simulink Structure ...................................... 57
4.2.2. Hardware Implementation of Bitstream Based AES S-Box ...... 60
4.3. LOGIC VALIDATION ..................................................... 63
4.4. CPA RESULTS ............................................................. 64
4.5. CONCLUSIONS............................................................ 66
5. SUMMARY AND CONCLUSIONS ............................................ 68
5.1. SUMMARY OF CONTRIBUTIONS ..................................... 68
5.2. FUTURE WORK .......................................................... 69
BIBLIOGRAPHY ..................................................................... 71
VITA ................................................................................... 80

vii
LIST OF ILLUSTRATIONS
Figure
Page
1.1
Block diagram of NCL combinational logic with two DI registers. .........
4
1.2
Threshold gate TH34w2........................................................
4
2.1
Typical nanowire crossbar structure. ......................................... 10
2.2
TH23 gate realized on a programmable gate macro block. .................. 13
2.3
NCL full adder implemented in CMOS (left) and CLB-1 (right). .......... 14
2.4
The second and third variations of (CLB-2 and CLB-3)..................... 15
2.5
1-bit NCL register implemented in one CLB. ................................ 16
2.6
Two-level hierarchical architecture for the proposed ANRCA............... 16
2.7
Curve ﬁtting results of programming steps for various CLBs. .............. 18
2.8
A single NCL cycle of DATA-to-DATA latency. ............................. 19
2.9
Demonstration of defect tolerance methods. ................................. 21
2.10
A case study of successfully realized on a defective DR-PGMB of TH34w2
gate. ............................................................................. 23
2.11
TH23 gate realized on a MLUT-PGMB. ..................................... 25
2.12
Waveform of TH23 gate. ....................................................... 26
2.13
A defective MLUT-PGMB and a version repaired using the redundancy
method. ......................................................................... 27
2.14
Percentage of crosspoints that are programmed to 1 for each TH gate..... 28
2.15
Crosspoints utilization comparison. ........................................... 30
2.16
Programming time comparison. ............................................... 30
3.1
Block diagram of a combinational S-Box with encryption and decryption
datapaths........................................................................ 36
3.2
An input-complete NCL multiplexer design. ................................. 38
3.3
Input-complete NCL XOR (left) and NCL AND (right) functions for the
proposed NCL S-Box. .......................................................... 38

viii
3.4
ModelSim waveform for the proposed NCL S-Box with input signals
changing from 0d to 3d......................................................... 39
3.5
Power waveform of NCL S-Box design. ....................................... 41
3.6
Speciﬁed side channel attack standard evaluation FPGA board (SASEBO-
GII).............................................................................. 43
3.7
Block diagram illustrating the DPA attack steps. ........................... 44
3.8
Power peaks for various key assumptions for a DPA attack on syn-
chronous S-Box design and NCL S-Box design. .............................. 46
3.9
CPA result for synchronous S-Box design and NCL S-Box design. ......... 52
3.10
The number of traces needed for a successful CPA attack................... 53
4.1
A stochastic bitstream with value 3/8. ....................................... 55
4.2
An AND gate to implement multiplication. .................................. 56
4.3
Stochastic implementation of a combinational logic in simulink. ........... 58
4.4
Encoder block................................................................... 58
4.5
Generated bitstreams waveform of AND function............................ 59
4.6
Decoder block. .................................................................. 60
4.7
Final output waveform. ........................................................ 61
4.8
System diagram................................................................. 62
4.9
Error rate of stochastic bitstream S-box. ..................................... 64
4.10
Power traces comparison between regular S-box (Top) and stochastic S-
box (Bottom) design. .......................................................... 65
4.11
CPA results of stochastic bitstream S-box. ................................... 66

ix
LIST OF TABLES
Table
Page
1.1
Truth table of NCL TH23 gate. ...............................................
5
1.2
Twenty-seven NCL TH gates. .................................................
6
2.1
Test Tuples for TH34w2 gate. ................................................. 24
3.1
Boolean equations for aﬃne transformation and inverse aﬃne transfor-
mation components. ............................................................ 37
3.2
Simulation results for 10 arbitrary samples from conventional synchronous
S-Box and the proposed NCL S-Box. ......................................... 40
3.3
Power simulation results for synchronous AES S-Box and NCL AES S-
Box using Accusim and AdvanceMS. ......................................... 42

1. INTRODUCTION
Synchronous logic with clocked structures has dominated the digital design
over the past decades. As the decrease of feature sizes and the increase of the oper-
ating frequency of integrated circuits (IC), clock-related issues become more serious,
such as clock skews, increased power at the clock edges, extra area, and layout com-
plexity for clock distribution networks, and glitches. These motivate the research of
asynchronous (i.e., clockless) logic design which has beneﬁts of eliminating all the
clock-related issues listed above.
Null Convention Logic (NCL) is a delay-insensitive (DI) logic that belongs to
the category of asynchronous logic. NCL was ﬁrst proposed by Karl Fant and Scott
Brandt in 1994 [1, 2, 3], and further developed by Dr. Scott Smith’s research group
[4]. NCL initially aimed at designing Application Speciﬁc Integrated Circuit (ASIC)
and Very-large-scale Integration (VLSI) circuits with lower power, lower noise, and
lower electromagnetic interference (EMI). Various NCL based circuits have shown
these characteristics. An NCL based Motorola STAR08 processor [5] shows the power
and noise reduction up to 40% and 10dB, respectively, comparing to its synchronous
counterpart. In [6], an 8-operation NCL ALUs was designed as a benchmark. The
simulation result shows that the dual-rail NCL circuit consumes less power but re-
quires a larger area compared with the conventional Boolean logic version. Other
designs like NCL divider [7] and NCL multiply-and-accumulate unit [8] have shown
the beneﬁts of speed improvement and reduction in power consumption, noise, and
EMI.
Designing an NCL circuit is less complex than designing the traditional asyn-
chronous circuit due to the absence of global clock and the property of DI, which
does not need worse-case delay analysis and extensive delay matching to synchronize
the datapath and control-path without a clock signal. The current research of NCL
mainly focuses on the formal design and optimization of NCL, such as the FPGA
implementations of NCL[9], Design For Test (DFT) techniques for NCL [10], speed
increase of NCL using cycle reduction techniques [11], and timing/gate optimization

2
methods [12]. However, there is few study at the application level of NCL. And its
advantages are not fully investigated.
This dissertation proposes and demonstrates two NCL applications to explore
some other beneﬁts of NCL. The ﬁrst application is the Asynchronous Nanowire
Reconﬁgurable Crossbar Architecture (ANRCA). Potential beneﬁts from ANRCA
include enhanced manufacturability, scalability, modularity, and robustness.
The
second NCL application is an asynchronous S-Box design for cryptographic system
to resist side-channel attacks (SCA). This design demonstrates that NCL has the
advantage of securing cryptographic devices against various power analysis attacks,
including Simple Power Analysis (SPA), Diﬀerential Power Analysis (DPA), and Cor-
relation Power Analysis (CPA). In order to enhance security, scholastic bit streams
based logics were proposed. The stochastic bit streams method has good scalability
and it can be applied to many other devices when they require enhanced security.
1.1. OVERVIEW OF NCL
NCL uses dual-rail or quad-rail signaling methods to achieve the DI [4]. A
pair of dual-rail signals A0 and A1 could be either 10 (i.e., DATA0), 01 (i.e., DATA1),
or 00 (i.e., NULL); as 11 is considered invalid.
Same for the quad-rail signaling
method but it uses four rails instead of two. The possible sets for quad-rail signaling
method would be DATA0 (1000), DATA1 (0100), DATA2 (0010), DATA3 (0001),
and NULL (0000). NCL uses two states, DATA (i.e., data representation) and NULL
(i.e., control representation) to synchronize itself and control the input and output,
eliminating the need of a reference clock signal. To mark the transition between the
NULL and DATA states, each NCL combination logic must be bracketed by input and
output DI registers, these registers have an input/output acknowledgment signal that
alternates between 0s and 1s to provide request-for-NULL (i.e.,RFN) and request-for-
DATA (i.e.,RFD), respectively. An example is shown in Figure 1.1. These signals are
used to initiate a delay insensitive handshaking protocol that handles timing locally.
The four-phase handshaking protocol includes: 1) The proper conditions are met
to provide DATA at the output of the registration element; 2) RFN goes back to its
previous state; 3) All of the inputs to the registration element are at NULL state; and
4) RFD is generated and it goes back to the previous state. The completion detection

3
component is used to determine whether the corresponding pipeline stage is ready for
another DATA/NULL cycle. It consists a cascade of NCL AND gates at which the
output is fed back to the previous register. When it detects the current operation is
a complete DATA set or a complete NULL set, the output will be asserted to request
the next cycle. Therefore, the period of DATA-to-DATA cycle consists of four stages:
1. Time for NULL combinational evaluation (TNi →TRNi+1);
2. Time for NULL completion acknowledgement (TNi+1 →TRDi);
3. Time for DATA combinational evaluation (TDi →TRDi+1);
4. Time for DATA completion acknowledgement (TDi+1 →TRNi);
where TDi and TDi+1 represent the propagation time of DATA in the current stage
and next stage, respectively. Similarly, TNi and TNi+1 represent the propagation time
of NULL on the current stage and next stage, respectively. TRNi, TRDi, TRNi+1 and
TRDi+1 represent the acknowledge time of request for NULL/DATA on the current or
next stage, respectively.
Threshold gates provide the basic building block of NCL designs. There are
two types of NCL threshold gates: THmn and THmnWw1..wR, where n represents
the number of inputs and m is the threshold value of the gate [13].
This means
that at least m of the n inputs must be asserted before the output becomes asserted.
Available w1..wR are the integer weights of input1..inputR, respectively. For example,
a TH34w2 gate has n = 4 inputs and its weight of the ﬁrst input is w1 = 2. In order
to assert its output, at least three of the four inputs must be asserted since m = 3.
Figure 1.2 shows the symbol of a TH34w2 gate [13]. The inputs and outputs of a
threshold gate can be one of two states, NULL or DATA. For example, the 1-bit NCL
register consists of two TH22n gates and a TH12 gate. A threshold gate starting
with its output in an NULL state will remain in the NULL state until the speciﬁed
number of inputs are placed in the DATA state. Once the gate reaches the DATA
state, it remains in this state until all of the inputs return to the NULL state. The
hysteresis in the threshold gate provides the threshold needed to keep from switching
during intermediate state when the number of inputs in the DATA state is between
zero and the threshold limit.

4
NCL Register
Completion Detection
2n
2n
1
Acknowledge
to previous 
stage
Acknowledge 
from next stage
NCL 
Register
NCL 
Register
Completion 
Detection
4
4
4
4
4
Combinational 
Logic
Figure 1.1. Block diagram of NCL combinational logic with two DI registers.
Figure 1.2. Threshold gate TH34w2.
There are twenty-seven fundamental threshold gates (TH gates) with hys-
teresis capability [13]. Each uses no more than four inputs. The TH gate provides a
threshold for the output assertion condition and hysteresis for state-holding behavior.
This allows all the inputs to be incorporated before generating the outputs, ensuring
a complete transition. Any arbitrary logic(s) can be obtained by using diﬀerent com-
binations of these TH gates [4]. For example, the Boolean equation of TH23 gate is
Z = AB + BC + CA + (A + B + C)Z∗where AB + BC + CA is the threshold term,
A + B + C is the hold condition, and Z∗is the previous output. Table 1.1 shows the
truth table of this gate. When Z∗is 0, the updated output is the same result of the
threshold equation, but once it becomes 1, the output will remain 1 until all inputs
(i.e., A, B, C) become 0 eventually. This principle is designed in all TH gates that
are shown in Table 1.2.

5
Table 1.1. Truth table of NCL TH23 gate.
Z∗
A B C
Z
Z∗
A B C
Z
0
0 0 0
0
1
0 0 0
0
0
0 0 1
0
1
0 0 1
1
0
0 1 0
0
1
0 1 0
1
0
0 1 1
1
1
0 1 1
1
0
1 0 0
0
1
1 0 0
1
0
1 0 1
1
1
1 0 1
1
0
1 1 0
1
1
1 1 0
1
0
1 1 1
1
1
1 1 1
1
In order to retain DI, NCL circuits should satisfy the condition of input-
completeness and observability [14]. Input-completeness requires that the transition
of all outputs in a combinational circuit should wait until all inputs have transitioned
from either NULL to DATA or DATA to NULL completely. In another word, all
outputs cannot transition before all inputs arrive. The observability condition ensures
that every gate transition is observable at the outputs, meaning that there is no
orphans could propagate through a gate [13]. For example, an incomplete NCL AND
function (Z = A • B) can be designed using a TH12 gate and a TH22 gate, where
Z1 = A1 • B1 and Z0 = A0 + B0. It is incomplete because the output can transfer
from NULL to DATA0 without both inputs are DATA, which breaks the condition of
input-completeness. To make it complete, the equation for DATA0 Z0 = A0 +B0 can
be changed to Z0 = A0(B0 + B1) + B0(A0 + A1) = A0B0 + A0B1 + A1B0; Therefore,
a complete NCL AND function could be designed using a THand0 gate and a TH22
gate.
1.2. ADVANTAGES OF USING NCL
NCL is an asynchronous logic, which eliminates the need for a global clock and
the clock distribution network. Therefore, timing design is easier than its synchronous
counterpart due to the lack of requirement to compensate clock skew, clock jitter, and
glitches. Unlike traditional asynchronous design techniques (i.e., Huﬀman circuits)

6
Table 1.2. Twenty-seven NCL TH gates.
NCL TH Gate
Boolean Equation
NCL TH Gate
Boolean Equation
TH12
A+B
TH22
AB
TH13
A+B+C
TH23
AB+AC+BC
TH33
ABC
TH23w2
A+BC
TH33w2
AB+AC
TH14
A+B+C+D
TH24
AB+AC+AD+BC+BD+CD
TH34
ABC+ABD+ACD+BCD
TH44
ABCD
TH24w2
A+BC+BD+CD
TH34w2
AB+AC+AD+BCD
TH44w2
ABC+ABD+ACD
TH34w3
A+BCD
TH44w3
AB+AC+AD
TH24w22
A+B+CD
TH34w22
AB+AC+AD+BC+BD
TH44w22
AB+ACD+BCD
TH54w22
ABC+ABD
TH34w32
A+BC+BD
TH54w32
AB+ACD
TH44w322
AB+AC+AD+BC
TH54w322
AB+AC+BCD
THxor0
AB+CD
THand0
AB+BC+AD
TH24comp
AC+BC+AD+BD
[15] that need timing analysis to achieve the delay matching so as to synchronize
the datapath and control path with the absence of a clock.
NCL circuits do not
need such extensive timing analysis, which makes the design much less complex. In
another word, NCL has the potential to process at its maximum frequency due to the
fact that the data go through path with minimal delay. This allows a NCL circuit to
potentially operate faster than a Boolean asynchronous design.
Another beneﬁt of NCL is the lower power consumption. The demonstration
could be found in section 3 that total power consumption of both synchronous S-Box
and NCL S-Box is compared based on the measurement results of EDA tools and
FPGA simulation. The rational is NCL’s monotonic transition between DATA wave
and NULL wave, creating an idle power state and eliminating the glitch power [13].
NCL circuits only switch when useful work is being performed, not every clock edge
like Boolean circuits. NCL systems also distribute the demand for power over time
and area, reducing the occurrence of hot spots, system noise, and peak power demand
[16]. According to [2], because of the DI, NCL is insensitive to the changes of physical
implementations and parameters, such as the scale changes, variations in propagation
delay, aging issues, temperature, manufacturing variations, and so on. Therefore, a
NCL circuit is anticipated to operating at a lower voltage with fast speed when the
high performance is not required. As discussed in later sections, the NCL’s power

7
consumption characteristic has the beneﬁt of increased security for cryptographic
devices.
This dissertation have explored more advantages of using NCL in two appli-
cation areas. They are: 1) NCL based nanowire crossbar architectures, which have
the beneﬁt of enhanced manufacturability, scalability, modularity, and robustness. 2)
NCL based AES S-Box design that could successfully resist various SCAs, including
DPA and CPA. More speciﬁc explanations will be presented in Section 2 and Section
3, respectively.
1.3. WORKS SUMMARY
This dissertation consists of three projects.
The NCL-based nanowire crossbar reconﬁgurable architectures are presented
in Section 2. It studies two implementations of ANRCA and discusses the advantages
of using asynchronous logic for nanoscale crossbar structure. The proposed ANRCAs
are unique for two reasons: 1) It is based on asynchronous NCL, clock-related failures
can be removed; 2) It addresses design, test, and manufacturing issues in nanowire
crossbar architecture by designing hierarchical structure, introducing function test,
and presenting fault-tolerance and repair strategies. Part of Section 2 comes from the
following publications:
• Advances in Nanowire-Based Computing Architectures, a book chapter pub-
lished in Cutting Edge Nanotechnology, 2010.
• Latency/Area Analysis and Optimization of Asynchronous Nanowire Reconﬁg-
urable Crossbar System, Nano Communication Network 2010.
• Asynchronous Nanowire Reconﬁgurable Crossbar Architectures, submitted to
IEEE Transaction on Nanotechnology 2011.
• Area and Latency Measurement and Optimization of Clock-Free Nanowire Re-
conﬁgurable Crossbar Systems, IEEE I2MTC 2010.
• Memristor Lookup Table (MLUT)-Based Asynchronous Nanowire Crossbar Ar-
chitecture, IEEE Nanotechnology 2011.

8
• Post-Conﬁguration Repair Strategy for Asynchronous Nanowire Crossbar Sys-
tem, IEEE MWSCAS 2012.
• Conﬁgurable Logic Block (CLB) Design for Asynchronous Nanowire Crossbar
System, IEEE MWSCAS 2012.
Section 3 focuses on the development of NCL based AES S-Box. The objective
is to demonstrate NCL S-Box could eﬀectively resist various SCAs and has lower total
power consumption than its synchronous counterpart. The hardware implementation
of NCL S-Box is designed in VHDL and simulated using both EDA tools and a SCA
evaluation FPGA board (SASEBO-GII). Part of Section 3 comes from the following
publications:
• Measurement and Evaluation of Power Analysis Attacks on Asynchronous S-
Box, accepted for publication in IEEE Transaction on Instrumentation and
Measurement 2012.
• FPGA-based Measurement and Evaluation of Power Analysis Attack Resistant
Asynchronous S-Box, IEEE I2MTC 2011.
• Asynchronous Nanowire Reconﬁgurable Crossbar Architectures, GLSVLSI 2010.
Section 4 presents a novel implementation of S-Box design that is based on
stochastic logic.
By involving probabilistic bit streams in logic implementations,
power traces become more unpredictable and data independent. This highly ran-
domness property is helpful for cryptographic devices against power analysis attacks.
However, such nondeterministic encoding scheme might generate logic errors. There-
fore, diﬀerent factors that would improve the accuracy have been analyzed in this
section, including the length of bit streams, the decision weight, and the repetition
times of the inputs. The enhanced security of stochastic logic-based AES S-Box has
been experimentally veriﬁed on the same SASEBO-GII board. Part of section 4 will
be submitted to IEICE Electronics Express (ELEX) 2012.
Finally, Section 5 discusses the contribution of this dissertation and suggestions
for future works.

9
2. PROJECT I: ANRCA
2.1. BACKGROUND
Many challenges have arisen with continued scaling of Complementary Metal-
Oxide-Silicon (CMOS) technology, including the increase of integrated circuit com-
plexity, increase in frequency, power density, non-recoverable expenses, and so on.
These diﬃculties have made it troublesome to further progress with, leading nan-
otechnologies to take the forefront of continuing the technological advancement. One
of the most promising nanotechnologies is the nanowire crossbar-based architecture:
a two-dimensional array formed by the intersection of two orthogonal sets of parallel
and uniformly-spaced synthesized nanowires such as carbon nanotubes (CNTs) and
silicon nanowires (SiNWs) [17, 18, 19]. These wires can be aligned to construct an
array with nanometer-scale spacing and formed crosspoints of nanoscale wires that
can be used as functional logic devices. These devices include programmable diodes,
ﬁeld-eﬀect transistors (FETs), and memristors, depending on the nature of nanowires
and interlayer material. The resulting structures act like programmable logic arrays
to implement conventional logics. The memristors based nanowire crossbar could also
be used to build memories due to its non-volatile characteristic. A typical nanowire
crossbar structure is shown in Figure 2.1. Nanowire crossbars oﬀer both opportunities
and challenges. One of the opportunities is to achieve ultra-high density which has
never been achieved by photolithography (a density of 1011 crosspoints per square
centimeters has been reported in [20]). The most important challenge is to make
them reliable enough in computational applications because of the high fabrication
defect densities (as high as 10%, are expected [21]).
Synthesizing nanowires can be done eﬃciently through bottom-up fabrication
paradigm, meaning that the CNTs and SiNWs are synthesized ﬁrst, then assembled
into functional devices. The traditional top-down lithographic manufacturing would
not be practical [22]. Combined with ﬂuidic ﬂow techniques by Langmuir-Blodgett
(LB) [23], these wires can be aligned to construct arrays that can be used multiple
times to yield complex hierarchically assembled nano-systems. Unfortunately, this

10
Function Devices
(Programmable Diodes, 
FETs, and memristors)
Crosspoint
Figure 2.1. Typical nanowire crossbar structure.
technique can lead to random breaks between the ends of the nanowires from re-
arranging them to scale down the size. Thus, a hierarchical structure is better than a
monolithic structure for integrated nano-systems due to the fact that small amount of
defects would not cause system failure. Hewlett-Packard (HP)’s lab have successfully
fabricated 8 × 8 (i.e., 64 bits) crossbar memory arrays by using a fabrication technique
of nanoscale crossbar called nano-imprint lithography [24, 25]. The fabrication process
reveals that the amount of defects increases proportionally to the decrease in the size
of the memory arrays. Challenges still arise with the enhancement of lithographic
resolutions and defect tolerance even though these fabrication techniques produce
results that are quite favorable for synthesizing nanowires eﬃciently.
Until now, various nanowire crossbar structures have been proposed: Dehon
et al. [26] have developed an operational reconﬁgurable computing system, known
as NanoPLA, utilizing these nanowires and molecular-scale devices. HP [27, 28] an-
nounced a computational structure with a decoder scheme for addressing nanowires
with micro-scale wires. They have also recently demonstrated a nanoscale crossbar-
based memristor array [29]. An analysis of diode-resistor based nanoPLA was present
in [30]. Other nanoscale reconﬁgurable homogeneous architectures, such as NanoFab-
ric [31, 32, 33]; follow a similar principle; grouping multiple crosspoints together to

11
serve as a memory device or logic element, and the CMOS/Nano hybrid structure
has been used to conﬁgure the interface.
2.2. ADVANTAGES OF ANRCA
Unlike those proposed nano-structures that are all based on synchronous op-
eration, the presented work proposes Asynchronous Nanowire Reconﬁgurable Cross-
bar Architectures (ANRCA). They have a distinct feature of asynchronous operation,
which is based on the NCL, a delay-insensitive data encoding and self-timed logic[14].
Potential beneﬁts of using NCL for nanowire crossbar design include:
1. Easy for manufacturing because of the clock-less characteristic, eliminating all
clock-related hardware.
2. ANRCAs are designed in a bottom-up manner and integrated without the trou-
ble of synchronizing each module, which indicates better scalability and modu-
larity than its clocked counterparts because the timing complexity remains the
same as the circuit size increases.
3. The complemented primary inputs (e.g., A, B, C and D) used in NanoFabric
[31] and the Field Eﬀect Transistor (FET) based inverters used in NanoPLA [26,
18] are no longer needed because they can be implemented simply by crossing
over the NCL dual-rail signals.
4. Due to non-determinism in the bottom-up self-assembly approach, exhibiting
variations in physical parameters in nanowire crossbar structures. These varia-
tions would have negative eﬀects on the timing behavior of circuits. ANRCAs
are independent of timing issues, thus they are anticipated to have better ro-
bustness over the design parameter variations.
5. Stuck-at-1 faults are easy to detect, which relatively reduces testing complexity.
Once a fault has occurred, the NCL circuit will be halted because it interferes
with the transition from DATA (either 01 or 10) to NULL (00). Also, the dual-
rail signal 11 is invalid in NCL; therefore, any permanent or transient fault that
results in this invalid state can be easily detected.

12
This section presents two implementations of ANRCA. One uses crosspoints
as programmable diodes that create AND/OR planes to implement logic gates (Sec-
tion 2.3). The other uses conﬁgurable memristors to realize nanoscale lookup tables
(LUTs)(Section 2.6). Discussions of defect issues and repair strategies for these two
optimization models are comprehensively studied. Comparisons between these two
optimization models have been analyzed in terms of area, programming steps, cross-
points utilization rate, and defect tolerance(Section 2.8). The above contributions
of this project are particularly beneﬁcial in designing an optimized reconﬁguration
hardware fabrication and in eﬃciently mapping any given complex logic.
2.3. DIODE- AND RESISTOR-BASED ANRCA (DR-ANRCA)
The primitive unit of DR-ANRCA is the Programmable Gate Macro Block
(PGMB), DR-PGMB for short. A single DR-PGMB is made of six horizontal nanowires
that cross over eleven vertical nanowires to form sixty-six crosspoints. These cross-
points are formed by programmable diodes to create an AND/OR logic plane. The
use of pull-up resistors on the vertical nanowires create the AND-plane, and pull-down
resistors on the horizontal wires create the OR-plane, enabling each DR-PGMB to
be programmed to realize any given NCL threshold gate function in sum-of-product
(i.e., SOP) form. For example, Figure 2.2 shows a DR-PGMB implementing a TH23
NCL gate, whose boolean expression is Z = AB + BC + CA + (A + B + C)Z∗, where
Z∗represents the previous output value of the TH23 gate, which is fed back to the
input nanowire.
For the purpose of eﬃciently reconﬁguring the given DR-PGMB as one of the
27 arbitrary NCL threshold gates, three conﬁgurable logic block (CLB) structures
were designed: CLB-1, CLB-2, and CLB-3. Figure 2.3 shows that the CLB-1 structure
consists of four DR-PGMBs which are surrounded by nanowires and demultiplexers.
The demultiplexers are used as the interface between microwires and nanowires since
they can use a small number of microwires to control a relatively large number of
nanowires. The input lines for addressing the demultiplexers are microwires, which
can be implemented on a CMOS substrate [34]. The output lines are nanowires that
are used to control crosspoints in DR-PGMBs. The number of input microwires (M)
and output nanowires (N) is expressed as N = 2M. The demultiplexers must be placed

13
VCC
A
B
C
Z
Feedback
Figure 2.2. TH23 gate realized on a programmable gate macro block.
on the side of the rows and columns to program all the crosspoints to ON/OFF states
by applying positive or negative voltages. Assuming that the unselected outputs are
driven by ground, then the intersection of driven nanowires would have a voltage drop
that is diﬀerent from other unselected crosspoints. This would allow the conﬁguration
of crosspoints sensitivity to voltage to drop across them.
For example, driving a
positive voltage on one of the column nanowires and a negative voltage on one of
the row nanowires, the rest of nanowires would be driven with ground, the selected
crosspoint is deﬁned as the intersection of driven nanowires.
The CLB-1 shown in Figure 2.3 is conﬁgured to function as a NCL full adder.
Two TH23 gates and two TH34w2 gates are implemented in four PGMBs, then,
interconnected in the conﬁgurable interconnection grid. Three inputs X, Y , Ci and
two outputs S, Co are represented by X0, X1, Y 0, Y 1, Ci0, Ci1, Co0, Co1, S0, S1
encoded in dual-rail logic. The top demultiplexer is used to decode the input signals
from DR-PGMB to determine which nanowires are selected. The other demultiplexers
are used to select diﬀerent DR-PGMBs to receive those input signals. The following
steps are used to program logic onto the CLB: 1) Use the top and right demultiplexers
to choose input crosspoints; 2) Use the bottom and right demultiplexers to map the
selected crosspoints to each DR-PGMB; 3) Program each DR-PGMB to the required
threshold gate. 4) Retrieve the generated output from the designated DR-PGMB.

14
2
2
3
3
Ci
0
Ci
1
X0
X1
Y0
Y1
1-bit NCLFull Adder
Co
0
Co
0
S0
S1
DEMUX
DEMUX
Ci
0Ci
1
Co
0Co
1
X1
X0
Y1
Y0
DEMUX
S
0
S
1
TH23
TH34w2
row address 
micro-wires
{
column address 
micro-wires
{
Figure 2.3. NCL full adder implemented in CMOS (left) and CLB-1 (right).
The three CLBs are distinguished by the number of demultiplexers on the right side:
CLB-1 has one, while CLB-2 and CLB-3 (Figure.2.4) have two and four, respectively.
The microwire address lines may be shared among multiple demultiplexers to allow
multiple crosspoints to be simultaneously accessed.
NCL delay-insensitive registers are needed to bracket the combinational logic
design to achieve the transition between DATA and NULL state.
An 1-bit NCL
register can be implemented on a single CLB using two TH22 gates and a TH12
as shown in Figure 2.5. The schematic of an 1-bit NCL register has been shown in
Figure 1.1. I0, I1, O0 and O1 represent input and output data rails, respectively. Ki
and Ko are the handshaking signals. The complemented value of Ko can be designed
by crossing over the wires due to its dual-rail property. For the full adder design,
an 3-bit input register (i.e., three CLBs) and 2-bit output register (i.e., two CLBs)
are needed to provide the appropriate number of input/output signals.
Thus, an
FPGA-like hierarchical architecture was proposed to implement the higher level logic
that requires a large number of DR-PGMBs, such as multiple bits full adder. Figure

15
DEMUX
PGMB
PGMB
PGMB
PGMB
DEMUX
DEMUX
DEMUX
DEMUX
DEMUX
DEMUX
PGMB
PGMB
PGMB
PGMB
DEMUX
DEMUX
DEMUX
CLB-2
CLB-3
Figure 2.4. The second and third variations of (CLB-2 and CLB-3).
2.6 shows the structure of the two-level hierarchical architecture that can be used for
implementing a 4-bit adder. Compared with the nanowire crossbar 3-bit adder design
that was introduced in [35], although the proposed DR-ANRCA consumes more area,
it is relatively easier to reconﬁgure and unaﬀected from any timing variations because
of its delay-insensitivity.
2.4. NUMERICAL ANALYSIS OF DR-ANRCA
2.4.1. Area.
The area-eﬃcient demultiplexer designs reported in [36] are
used in the proposed CLB designs. Thus, the demultiplexers selected by the DR-
PGMB on the right are assumed to be allocated on the same column-wise area of the
substrate. According to the NanoPLA assembly parameters provided by Dehon[26],
the lithographic interconnect pitch can be estimated as 105nm for the 45nm node.
A 10nm nanowire pitch is acceptable for assembling the crosspoints between each
pair of crossed nanowires. Nanowire with 3nm diameters has been demonstrated.
Microwires have diameters of around 45nm [26]. The pitch between microwires and
nanowires is assumed to be a median of Pn and Pm, which is around 60nm. Thus, as

16
TH22
TH22
TH12
DEMULTIPLEXER
DEMUX
I
0I
1Ki
O
0O
1 Ko
Ko
1
0
0
1
Invert value
DEMUX
Figure 2.5. 1-bit NCL register implemented in one CLB.
CLB
CLB
CLB
CLB
Switching 
matrix
16 inputs
4 outputs
4×CLB
4×CLB
4×CLB
4×CLB
Interconnect 
switching 
matrix
The maximum 
number of inputs 
is 64
Maximum: 16 outputs
4×CLB
Figure 2.6. Two-level hierarchical architecture for the proposed ANRCA.
shown in Figure 2.3, the overall area of each CLB can be estimated as the product of
the width and height (Area = Width × Height):

17
Width = Pn × (Nv −1) + Pm × (Mv −1) + Pmn + Nv × Dn + Mv × Dm
(1)
Height = Pn×(Nh −1)+Pm ×(Mh −1)×2+Pmn ×2+Nh ×Dn +Mh ×Dm×2 (2)
where: Nv and Nh represent the number of nanowires in vertical and horizontal direc-
tion, respectively; Mv and Mh represent the number of microwires for demultiplexers
in vertical and horizontal direction, respectively; Pn and Pm, Dn and Dm are the
pitch and diameter of the nanowires and microwires, respectively; and Pmn is the
pitch between microwires and nanowires. Thus, in calculating their areas using the
above equations, the estimated areas of the proposed CLB-1, CLB-2, and CLB-3 are
1.477um2, 1.265um2, and 1.053um2, respectively.
2.4.2. Programming Steps.
The complexity of the logic mapping opera-
tion is another factor that should be considered to optimize the design. A program-
ming step is deﬁned as selecting and programming a speciﬁc crosspoint in a given
CLB. The average programming step count is deﬁned as the estimated number of
steps needed to program a given number (i.e., 2, 4, 8, or 10) of randomly distributed
crosspoints among DR-PGMBs. For example, say there are four crosspoints need
to be programmed and they are randomly distributing on the crossbar. If they are
programmed by the design of CLB-1, each point would be selected one by one since
there is only one PGMB select demultiplexer. Thus the programming step count in
this case is four. For CLB-2 and CLB-3, actual programming step count depends
on the geometric distribution of crosspoints being programmed because diﬀerent de-
multiplexers are controlling the selection of rows. One extreme case is that the four
crosspoints happen to locate on the same column of each PGMB controlled by the
four demultiplexers of CLB-3. The total step of programming these four points is one
since four demultiplexers can select them simultaneously in this case. However, other
distributions should be considered too. Therefore, a numerical analysis program for
calculating the average steps has been implemented in MATLAB. A probabilistic al-
gorithm and a square curve ﬁtting algorithm were developed to derive the average
number of steps. Figure 2.7 shows the relationship between the number of crosspoints
to be programmed and the average number of steps required to fully program them.

18
0
5
10
15
20
25
30
0
5
10
15
20
25
30
Number of corsspoints
Average programming steps
 
 
CLB−1
CLB−2
CLB−3
Figure 2.7. Curve ﬁtting results of programming steps for various CLBs.
2.4.3. Latency.
Latency is deﬁned as the total time required to process
input to generate output. System latency for the proposed ANRCA consists of two
parts: the cycle of combinational logic implemented by the CLBs and the cycle of
NULL and DATA handshaking feedback signal propagation. A single cycle in one
DR-PGMB of CLB evaluates both input (i.e., in AND-plane) and output (i.e., in
OR-plane). The total time for a single input/output plane is estimated based on
the following equations: the latency for the input plane and output plane can be
estimated as
TinP lane = Nci × Td
(3)
ToutP lane = Nco × Td
(4)
and the latency for a demultiplexer is estimated as
Tpropagation = Np × Tp
(5)

19
thus the overall latency is
Tcycle
=
TinP lane + ToutP lane + Tpropagation
=
(Nci + Nco) × Td + Np × Tp
(6)
where: Nci and Nco represent the number of input and output crosspoints of an
DR-PGMB, respectively; Td is the processing time of demultiplexers; Tp is the prop-
agation delay of programming one crosspoint on its DR-PGMB. Np represents the
total number of crosspoints on an DR-PGMB. The comparison for the latency of
diﬀerent CLBs, is dependent on the logic that is implemented on it. A full adder
design is used as a benchmark to make a simple comparison of the latency among
three CLBs: CLB-1, CLB-2, and CLB-3 is 18Td + 90Tp, 10Td + 54Tp, and 5Td +
37Tp, respectively.
Generally, a single NCL cycle comprises the propagation delay of NULL/DATA
and the acknowledge time of a request for DATA/NULL [37] as Figure 2.8 shows.
Data(i) 
propagation
Request 
NULL
Request 
DATA(i+1)
NULL
propagation
Time
Figure 2.8. A single NCL cycle of DATA-to-DATA latency.
The proposed ANRCA also follows this rule since it is based on NCL. There-
fore, the DATA-to-DATA latency is given by:
TDitoDi+1 = TDi + TRNi + TNi + TRDi+1
(7)

20
where TDi and TNi represent the propagation time of DATA and NULL in the current
stage, respectively; TRNi is the acknowledge time of request for NULL in the current
stage; TRDi+1 is the acknowledge time of request for DATA in the next stage.
2.5. DEFECT/FAULT ISSUES OF DR-ANRCA
One of the main problems with nanoscale crossbar architecture is the high
inherent defect density that is caused by the bottom-up self-assembly fabrication
technique[38]. The conventional fault-tolerance and reliable design are not adequate
in nanoscale integration because of the increased defect and fault rates. Therefore,
fault-tolerance techniques for nanowire crossbar structure is critically needed. Sev-
eral test algorithms have been developed by our research group, including defect-
unaware, defect-aware, and function test algorithm (FTA) [39, 40]. This dissertation
uses FTA to detect defective crosspoint locations, focuses on the development of post-
conﬁguration repair technique, and fault-tolerance techniques to increase the reliabil-
ity of the proposed ANRCAs. The fault-tolerance approaches include permutation,
commutative method, and redundancy. There are three ways to tolerate defects in a
DR-PGMB:
1. Reconﬁgure the order of primary inputs utilizing the demultiplexer that is des-
ignated to select inputs. The number of combinations for rearranging the order
of inputs can be determined from factorial of the number of inputs.
2. Rearrange the order of columns of the given DR-PGMB base on the commuta-
tive law since the product terms in the sum-of-product (SOP) of TH gates can
be rearranged.
3. Include redundant rows and columns in each DR-PGMB to increase the chances
of generating the correct output by forcing the desired logic.
Using a TH23 gate (i.e., Z = AB+BC +AC +(A+B+C)Z∗) as an example,
the above defect tolerance methods are demonstrated in Figure 2.9. It shows a side-
by-side comparison of a defective DR-PGMB with a corrected DR-PGMB that is
based upon the respective methods described above. Figure 2.9(a) shows the matrix
implementation of a TH23 gate on a DR-PGMB with defects on the intersection of

21
A
B
C
Incorrect
B
C
A
Correct
Defective 
crosspoints
A
B
C
Incorrect
A
B
C
Correct
Z=AB+BC+AC
Z=AB+AC+BC
(a)
(b)
A
B
C
Incorrect
A
B
C
Correct
Redundant row and column
(c)
Figure 2.9. Demonstration of defect tolerance methods.
(2,1) and (3,2). To avoid these defective crosspoints, the input order can be simply
changed from A,B,C to B,C,A. Figure 2.9(b) shows the defective crosspoints located
at (2,2) and (1,3); in this case, the SOP can be rearranged from Z = AB + BC +
AC + (A + B + C)Z∗to Z = AB + AC + BC + (A + B + C)Z∗. Figure 2.9(c) shows
the defective crosspoints located at (1,1) and (2,1). The product term of the TH23
gate can not be mapped on the ﬁrst column without using extra rows. Therefore,
the solution is to use extra rows or columns. If the number of defective crosspoints
are too large to be tolerated by the selected DR-PGMB, the worst-case scenario is to
discard the selected DR-PGMB and use another one to reprogram the given TH gate
function.
FTA uses a test tuple that combines the input patterns and the previously
asserted output patterns to list all possible faults for the mapped TH gate. Based on
FTA, a new post-conﬁguration repair technique was derived to provide a balanced
combination of tolerable repair time and acceptable repair performance [39, 40]. Test
tuples having one-to-one correspondence with defective crosspoints are applied ﬁrst to
detect and then isolate DR-PGMB rows and columns that are needed to be repaired.

22
Consider a TH34w2 gate shown in Figure 2.10.
The black dots represent
programmed-ON crosspoints and crosses represent defective crosspoints. The combi-
nation of both symbols represents defective crosspoints that aﬀect the functionality
of the gate. To implement a TH34w2 gate on a DR-PGMB, a total of 25 crosspoints
must be programmed on the speciﬁc locations. In this case, there are 7 defective cross-
points among a total of 66 crosspoints. The defect rate is approximately 10% and ﬁve
of the defective crosspoints, (2,4), (4,8), (6,1), (6,5), (6,8) aﬀect the functionality of
the TH34w2 gate and three of them are located on the OR plane. Thus, according to
the functionality of TH34w2 (i.e., Z = AB +AC +AD +BCD +(A+B +C +D)Z∗)
and its speciﬁc coordinates shown in Figure 2.10 part (a), a test tuple table (see
Table 2.1) was generated for TH34w2 to sort the test vectors for related defective
crosspoints. The OR plane takes the priority because it reﬂects the various results
from the AND plane [40]. The initial state of input is assumed to be 0000 so that the
output Z will be 0 as well. Any stuck-at-1 crosspoints in the OR plane could be tested
using this test vector. Although test tuple 0000 could be used to test all the required
crosspoints, it takes a long time to go through all the required crosspoints (i.e., 25
in this example). Therefore, a combinations of various inputs could make the testing
more eﬃcient. For example, the input 0001 with Z∗= 0 (i.e., Z∗is the previous
output) could be used to test the defective crosspoints with coordinates (1,3), and
(5,8). According to the functionality of TH34w2, the correct result would be 0 when
input is 0001 and Z∗is equal to 0. However, it becomes 1 since the crosspoints (1,3) is
defective. A similar testing algorithm could be used for other crosspoints required to
implement a TH34w2 gate. Thus the fault location has been detected whenever the
observed output does not match the desired one. Using this method, all 25 required
crosspoints could be covered within 20 steps.
Once the location of the defective crosspoints have been conﬁrmed, the repair
strategy could be developed to avoid the defective crosspoints by either rearranging
the mapping or using extra rows or columns. As Figure 2.10 part (b) shows, with
column 4 moved to column 10 and column 8 moved to column 9, the remaining two
defective crosspoints with initial locations (6,1) and (6,5) are moved to (7,1) and (7,5),
respectively. The existing defective crosspoints could be avoided. However, another
round of FTA should be used to test the new location of these crosspoints to ensure

23
A
B
C
Defective TH34w2
D
A
B
C
Repaired TH34w2
D
AND Logic
OR Logic
(a)
(b)
Figure 2.10. A case study of successfully realized on a defective DR-PGMB of TH34w2
gate.
the functionality of TH34w2 would work property. The algorithm could be modiﬁed
to test other TH gates on the DR-PGMB.
2.6. MEMRISTOR LOOK-UP-TABLE BASED ANRCA
Memristor, another promising technology for nanoscale computation systems,
is considered as the fourth fundamental circuit element [41]. It is expected to have
advantages in building nanoelectronic memories, computer logic, and neuromorphic
computer architectures [42]. It is also capable of replacing programmable resistors or
rectifying devices to yield conﬁgurable crossbar junctions (i.e., crosspoints). There
are two important properties of memristors[43] : (a) as a memory storage element,
each memristor crosspoint can be programmed independently into a low-conductance
(Logic 0) or a high-conductance (Logic 1) as normal resistive switching elements. (b)
as a switche, low-conductance (OFF-state) and high-conductance (ON-state) refer
to the unconnected state and the connected state, respectively.
Various research
papers describe the way to write/read memristor based nanowire crossbar[44, 45, 46].
A tutorial of using memristor-based crossbars has been presented in [47]. Using the
properties of memristors, this work proposes another implementation of ANRCA that
relies on conﬁgurable memristors to realize nanoscale look-up-tables (LUTs).

24
Table 2.1. Test Tuples for TH34w2 gate.
Test Tuples (input bits)
Required Crosspoints Coordinates
0000
OR Plane and F(1,5), (2,6), (3,7), (4,8)
0001
F(1,3), F(5,8)
0010
F(1,2), F(5,7)
0011
F(2,4), F(1,3), F(1,2)
0100
F(1,1), F(5,6)
0101
F(1,1), F(1,3), F(3,4)
0110
F(1,1), F(1,2), F(4,4)
0111
F(1,1), F(1,2), F(1,3)
1000
F(2,1), F(3,2), F(4,3), (5,5)
1001
F(2,1), F(3,2)
1010
F(2,1), F(4,3)
1011
F(2,1), F(2,4)
1100
F(3,2), F(4,3)
1101
F(3,2), F(3,4)
1110
F(4,4), F(4,3)
1111
N/A
The basic unit of MLUT-ANRCA is the MLUT based PGMBs, MLUT-PGMB
for short. A single MLUT-PGMB consists of eight horizontal nanowires crossing over
four vertical nanowires that are surrounded by column/row demultiplexers and a
multiplexer (see Figure 2.11). It can be programmed to realize any given NCL gate
by directly implementing the truth table of the given gate function using MLUT with
the hysteresis (i.e., state-holding behavior) that is required to achieve the proposed
delay-insensitivity via a feedback interconnect.
Figure 2.11 shows the implementation of a MLUT-PGMB programmed to
function as an NCL TH23 gate. The demultiplexers located at the row and column

25
Mux
Demux
Demux
Z* CD
A
B
1/0
1/0
Z* CD
Z
00
01
10
11
000
001
010
011
100
101
110
111
Figure 2.11. TH23 gate realized on a MLUT-PGMB.
of the MLUT-PGMB are utilized to select a programmable memristor junction. Light-
colored dots represent the memristor crosspoints programmed as 0, while the dark-
colored dots are 1. A feedback signal is sent to provide Z∗to the row demultiplexers
for hysteresis behavior. If Z∗is equal to 0, then the top half of the LUT is selected
to provide the output setting logic. If Z∗is equal to 1, the bottom half of the LUT
is selected to provide the output resetting logic. An equivalent circuit simulation
has been presented in [48]. As shown in this example, a single MLUT-PGMB can
be programmed to function as a TH gate. Likewise, multiple MLUT-PGMBs can
be programmed and interconnected via a reconﬁgurable interconnection network to
form a higher level circuit in nanoscale. This is similar to the hierarchal architecture
presented in DR-ANRCA section. Another beneﬁt of the MLUT-PGMB design is
that it simpliﬁes the reading procedure by assuring that the memristors at each
crosspoints are required to be programmed either ON or OFF state (i.e., 1 or 0 in
Boolean) so that the LUT could be setup. This eliminated the need of using the
adaptive measurement algorithm proposed in [43]. Because the comparison of two
diﬀerent states is only necessary. Also, for any TH gate, the initial crosspoint (1,1)
(i.e., all inputs are 0) is always programmed to 0 and the last crosspoint (8,4) (i.e.,
all inputs are 1) is always programmed to 1, therefore they are used as references to
determine the value of a selected output.

26
The functionality of the proposed MLUT-PGMB’s threshold and hysteresis
behaviors were veriﬁed by implementing a structural model in VHDL. A timing sim-
ulation is also performed using the design automation tool. The simulation waveform
is shown in Figure 2.12. Output F becomes ’1’ when ABC becomes ’011’ (i.e., thresh-
old behavior), then maintains this value until ABC resets back to ’000’ (i.e., hysteresis
behavior). The results demonstrate that the structural model’s functionality accu-
rately matches the logic of the TH23 gate.
Figure 2.12. Waveform of TH23 gate.
2.7. DEFECT/FAULT ISSUES OF DR-MLUT
To address the high inherent defect density in the context of MLUT-ANRCA
design, this study focuses on a MLUT-PGMB as a basic unit of MLUT-ANRCA
to realize the proposed defect-tolerance methods. There are three states in which
a defective crosspoint can be detected: nonprogrammable, stuck-at-1, or stuck-at-0.
A crosspoint in a non-programmable state can not be changed to an ON or OFF
state. A comparison method is used to detect whether or not a crosspoint is in this
a state. This method utilizes the initial crosspoint (1,1) and the last crosspoint (8,4)
as references for comparing a selected crosspoint. If the selected crosspoint does not
match either of the reference values, it can be considered as a nonprogrammable
crosspoint. This method is based on the assumption that the reference crosspoints
are programmed properly. The crosspoints with stuck-at-0 or stuck-at-1 faults can
be simply detected by programming opposite values on them and then utilize the
proposed comparison method to determine whether it is reconﬁgurable.

27
Tolerance for these defective crosspoints can be attained by the use of redun-
dancy, replacement, or a passive approach. Redundancy is the basic method in the
fault-tolerance system, it involves the use of spare wires to reprogram copies of se-
lected logic. The area provided by the MLUT-PGMB allows crosspoints on speciﬁc
rows to be available for redundancy based on the number of inputs for the mapped
TH gate. For example, consider the worst case scenario of a 10% defect rate. The
left part of Figure 2.13 shows a defective MLUT-PGMB implementing a given TH23
function. The crosspoints (1,3), (3,4), and (5,2) are crossed out to indicate that there
are defects. The right part of Figure 2.13 shows a repaired version of the same gate.
Crosspoints (2,3), (4,4), (6,2) have been used to replace those defective crosspoints.
The same method can be applied to other four inputs TH gates by adding extra wires
to increase the number of rows/columns. Relatively high defect rates can be tolerated
using this method, especially for the three/two inputs TH gates which require a lower
number crosspoints to be programmed on a 8×4 MLUT-PGMB. Defect rates of 50%
or even 75% can be tolerated without increasing the size of the MLUT-PGMB.
AB
00 01 10 11
FCD
000
001
010
011
100
101
110
111
Redundant rows for 
3-input TH gate
AB
00 01 10 11
FCD
000
001
010
011
100
101
110
111
Figure 2.13. A defective MLUT-PGMB and a version repaired using the redundancy
method.
The hysteresis function of NCL determines that the number of crosspoints
programmed to 1 is more than the number of crosspoints programmed to 0, because
the asserted output will become 0 only when all inputs become 0. Based on this
observation, we can use a passive approach to deal with stuck-at-1 faults. If these
faults occur at the crosspoints that are originally going to be programmed to 1, they

28
can be ignored because the desired functionality can still be achieved. Figure 2.14
shows a bar graph that indicates the percentage of crosspoints that are programmed
to 1 for each TH gate. It shows that more than 50% of the crosspoints on TH gates are
programmed to 1. Thus, this method can be used to tolerate most of stuck-at-1 faults
on MLUT-PGMBs. The same method can be applied to stuck-at-0 faults, however,
the number of crosspoints that are programmed to 0 for each TH gate is relatively
low. To deal with the faults that cannot be ignored, the wires can be rearranged by
changing the switching function of the demultiplexer to tolerate them. This approach
rearranges the programmed crosspoints to a position where the faults do not interfere
with the functionality of the desired TH gate. Alternatively, redundant rows can be
used to replace the defective row.
5
10
15
20
25
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
NCL TH Gates
Percentage
Figure 2.14. Percentage of crosspoints that are programmed to 1 for each TH gate.
2.8. COMPARISON BETWEEN DR-ANRCA AND MLUT-ANRCA
The two designs introduced in this dissertation present novel implementations
of ANRCA that achieve the goal of eliminating the dependency of a global clock by
implementing the NCL on nanowire crossbar architectures. The DR-ANRCA utilizes

29
crosspoints as programmable diodes that create an AND/OR plane to implement TH
gates. MLUT-ANRCA, on the other hand, uses conﬁgurable memristors to realize
nanoscale lookup tables (LUTs) to represent each TH gate. The comparison of both
in terms of structure, control method, and defect-tolerance analysis are introduced in
this section to realize the pros and cons of each method.
The structure of a DR-PGMB consists of 6 × 11 nanowires to create a total
of 66 crosspoints to implement any TH gate, whereas a MLUT-PGMB consists of
8 × 4 nanowires to create a total of 32 crosspoints to perform the same functionality.
Clearly, MLUT-PGMB requires fewer crosspoints to provide the same functionality.
Another beneﬁt of the MLUT-PGMB structure is that it has a better utilization rate
of crosspoints than DR-PGMB when implementing the same TH gate function. For
example, to program a TH23 gate on both designs, a DR-PGMB requires 18 out of
66 crosspoints, whereas a MLUT-PGMB requires 16 out of 32. The utilization rate
is 27.3% versus 50%. Figure 2.15 shows the comparison of crosspoints utilization
rate between these two designs for all TH gates. This work also compares the two
ANRCAs in terms of area, programming latency, and defect tolerance. The structure
of these two designs are diﬀerent. DR-ANRCA utilizes a combination of three or more
demultiplexers to eﬀectively control and program DR-PGMBs in a CLB. Each MLUT-
PGMB needs two demultiplexers and one multiplexer to program a TH gate. Similar
to DR-ANRCA, it can be managed by a switching matrix to communicate with other
MLUT-PGMBs in a CLB. Therefore, a DR-ANRCA uses fewer demultiplexers to
implement a CLB, making it relatively easier to be reconﬁgured than MLUT-CLBs
do. According to the NanoPLA assembly parameters provided in [26], 10nm nanowire
pitch is acceptable for assembling the crosspoints between each crossed nanowire
and 3nm nanowire diameters have also been demonstrated.
The area of a single
DR-PGMB nano-array and a MLUT-PGMB nano-array is 9, 044nm2 and 7, 276nm2,
respectively. As Figure 2.15 shows, for most of the TH gates that are implemented
in MLUT-PGMB, the crosspoints utilization rate is 100% since all 32 crosspoints will
be programmed to achieve its functionality, where the same TH gates require fewer
crossponits (up to 50%) to be implemented on a DR-PGMB. Therefore, assuming the
latency of programming a crosspoint is the same for both PGMBs (i.e., ts), the total
time required to program a MLUT-PGMB would be considerably greater than that

30
needed to program a DR-PGMB. Figure 2.16 demonstrates a scatter graph that plots
the propagation time of programming each TH gate on both PGMBs. The order of
TH gates on the x-axis are done in ascending order according to the number of inputs.
5
10
15
20
25
0
20
40
60
80
100
120
NCL Threshold Gates
Utilization Rate %
 
 
MLUT−PGMB
DR−PGMB
Figure 2.15. Crosspoints utilization comparison.
5
10
15
20
25
0
5
10
15
20
25
30
35
NCL Threshold Gates
Time x ts
 
 
MLUT−PGMB (Ttotal=736ts)
DR−PGMB (Ttotal=510ts)
Figure 2.16. Programming time comparison.

31
Introducing redundancy is a common method that has been widely used in
the ﬁeld of fault-tolerance and reliability. Usually there are two types of redundancy
methods: spatial redundancy and temporal redundancy [27]. This work utilized the
spatial redundancy method for tolerating these defective crosspoints in the proposed
ANRCAs. The cost of spatial redundancy is that larger areas will be consumed when
the crossbar scales up. In this regard, MLUT-PGMBs are more ﬂexible in the replace-
ment of a defective crosspoints than DR-PGMBs are because the latter must rely on
the AND/OR functions when using the redundancy crosspoints, and the defective
crosspoints cannot be fully replaced without increasing the size of each PGMB. How-
ever, the defective crosspoints in MLUT-PGMB, especially when it is implementing
a two- or three-input TH gate, can be ignored or replaced by adjacent crosspoints, as
explained in section 2.7. The comparison made here are based on theoretical designs;
a more detailed comparison can be made by evaluating the performance of diodes
and memristors.
2.9. CONCLUSIONS
This section has presented two diﬀerent implementations of ANRCA: DR-
ANRCA and MLUT-ANRCA. Both of them are based on NCL that intrinsically
eliminate many clock-related issues caused by complex clock distribution networks.
Synthesizing nanowires is based on bottom-up fabrication paradigm. The integrated
nano-systems prefer using a hierarchical structure over monolithic structure.
The
studies of ANRCAs start with its primitive conﬁgurable logic unit (PGMB), then
three versions of CLB for reconﬁguration, and ﬁnally an FPGA-like hierachical ar-
chitecture. With all these features, ANRCAs are anticipated to have the advantages
of improved manufacturability, scalability, modularity, and robustness.
Comparisons between diﬀerent designs are discussed in terms of of area, pro-
gramming steps, and latency. Due to the high inherent defect density in nanowire
crossbar caused by the self-assembly fabrication techniques, the conventional fault-
tolerance methods are not adequate for ANRCAs. This research have proposed some
defect-tolerance and repair strategies for both ANRCAs, including FTA based post-
conﬁguration, permutation and commutative method, spatial redundancy, replace-
ment, and passive strategy.

32
3. PROJECT II: NCL S-BOX DESIGN
3.1. BACKGROUND
In relation to the market of digital information security, crypto-hardware de-
vices that have enhanced security measures while being energy eﬃcient are in high
demand. The growth of innovation for these devices can be seen in today’s mobile
phones and portable devices and computer/network security in industrial control sys-
tems [49]. In order to reach this demand of low powered devices with high security
features, researchers generally focus around the actually cryptographic algorithm im-
plemented in the hardware itself to encrypt and decrypt information. Thus, securing
cryptographic devices against various side channel attacks (SCA) has become a very
attractive research topic in recent years along with the developments of information
technologies. SCAs explore the security information (i.e., secret key) by monitoring
the emitted outputs from physical cryptosystems. These outputs include execution
timing, power consumptions, electromagnetic leaks, and even thermal/acoustic ema-
nations [50]. Accurate measurement and estimation of these outputs is the key point
of a successful attack. The measurement should be based on the hardware gate-level
approach rather than the software instruction-level estimation [51, 52, 53, 54]. Also,
for the power consumption measurement, the focus would be the dynamic power con-
sumption that is dissipated during the transistors switching rather than static leakage
power consumption [55]. Advanced Encryption Standard (AES) was announced with
the intention of being a faster and more secure encryption algorithm over others since
its algorithm is comprised of multiple processes used to encrypt information with
supports of up to 256 bits key and block sizes, making an exhaustive search impos-
sible to check all 2256 possibilities. Usually the hardware AES implementation has a
higher reliability than software since it is diﬃcult to be read or modiﬁed by attackers
and less prone to reverse engineering. Unfortunately, AES is still vulnerable to SCA
[56, 57]. The published SCA include simple power analysis (SPA), diﬀerential power
analysis (DPA), correlation power analysis (CPA) [50, 58], collision attack[59], and

33
leakage power analysis (LPA) [60]. Among them, DPA and CPA are the most pop-
ular and eﬀective attack that has been reviewed by numerous researchers on various
crypto-systems during these years [50]. In the meantime, many countermeasures for
resisting SCA attacks were proposed as well. Most of the countermeasures designed
for hardware implementations of AES are based on securing the logics cells to balance
the power consumption of the system and make it independent of the processing data.
This process of adjusting the basic units of the system makes the overall design less
vulnerable to attacks. The hardware implementation of AES essentially has higher
reliability than software because it is diﬃcult to be read or modiﬁed by the attackers
and less prone to reverse engineering [61]. These countermeasures can be separated
into two categories based on the framework of the circuit they are implemented on,
synchronous and asynchronous.
3.2. EXISTING COUNTERMEASURES
The countermeasures for synchronous circuits include Sense Ampliﬁer Basic
Logic (SABL) [62], an improved two-spacer alternating dual rail circuit [63], Wave
Dynamic Diﬀerential Logic (WDDL) [64], a dynamic voltage and frequency switching
approach [65], masked logic styles [66, 67], using Fourier Transform [68], Random
Switching Logic (RSL) [69] with its simpliﬁed version Dual-rail random-switching
logic [70], and recently proposed Masked Dual-Rail Pre-charged Logic (MDPL) and its
improved version [71, 72]. These works are centered around resisting DPA attacks and
introduce methods on how to eﬀectively reduce the impact of DPA attack. However,
they are fundamentally based on synchronized circuits, which either requires a precise
control of timing or suﬀer from some timing related issues, such as glitches [71, 73],
hazard, and early propagation [73, 72, 74], which still could leak some side-channel
information to the attackers.
Asynchronous circuits, on the other hand, have natural advantages in terms
of SCA resistance. The clock-related information leakage can be either eliminated
or signiﬁcantly reduced, which extensively increases the diﬃculties of attack due to
the lack of timing references. The countermeasures based on asynchronous circuits
include Balanced delay insensitive method [75], GALS module [76], and 1-of-n data
encoded speed independent (SI) circuit [77, 78]. However, the increased security does

34
not come for free. The area required to implement them are potentially larger than
their synchronized counterparts. The beneﬁts in terms of total power consumption
and speed are still questionable. In addition, some of the countermeasures are based
on the EDA tool simulation results or theoretical analysis, which may not eﬀectively
prove that these methods could resist real SCA attacks experimentally.
From these existing countermeasures, the dual-rail encoding[63, 79], with the
pre-charge method, spacers, or return to zero (RTZ) protocols are frequently used in
both synchronous and asynchronous designs. The dual-rail encoding provides better
data independence with the power consumption since the Hamming weights of each
data set are the same. A RTZ, spacer, or pre-charge method is used to achieve the
monotonic transition to enhance the security. Our proposed Null Conventional Logic
(NCL) based S-Box design essentially matches all these important security proper-
ties: asynchronous, dual-rail encoding, and an intermediate state (i.e., NULL). Un-
like other asynchronous designs, NCL adheres to the monotonic transitions between
DATA (i.e., data representation) and NULL (i.e., control representation), which uti-
lizes dual-rail and quad-rail signaling methods to achieve the delay-insensitivity [9].
This would signiﬁcantly reduce the design complexity. With the absence of a clock,
the NCL system is proved to reduce the power consumption, noise, and electromag-
netic interference [80, 81]. Furthermore, this work has demonstrated that NCL could
also resist SCA without worrying about the glitches and power supply variations
[82]. This work provides an extension to what has been presented in [82]. Besides
the DPA attack, a CPA attack has been also applied to both synchronous and NCL
S-Box design to demonstrated that the proposed NCL S-Box is capable of resisting
CPA attack as well.
Usually, there are four methods to conduct the power measurement experi-
ments: 1) use computer-aided design (CAD) tools [61], 2) use regular FPGA board
[64], 3) use the SASEBO-GII FPGA board, and 4) use a taped-out ASIC chip. The
procedures of taping out a chip include the front-end veriﬁcation using CAD tools
and FPGA board. They are complicated, time consuming, and expensive. Therefore,
in order to prove the proposed idea in a more eﬀective way, the ﬁrst three methods
have been tried and the experimental results show that the third method is the most
eﬀective one among these three methods. The rational behind lies as follows: 1) while

35
CAD-tool-based simulation shows the synchronous S-Box design is indeed vulnerable
to the DPA attacks, the DPA attacks could not be successfully implemented on the
NCL S-Box by such simulation due to too much regularity in the simulated power
traces. The reason is that the CAD tools approximate the simulation results. 2)
There are many constraints on using regular FPGA board for this experiment. All
the decoupling capacitors related to the core power supply should be removed to in-
crease the chance of successful attacks. Also, a current probe is needed to measure
the current consumed by the core of the FPGA chip. However, the bandwidth of
current probes is usually lower than that of voltage probes, which might not be able
to capture the high-frequency AC current variations caused by data transients. 3) A
stable power supply is critically important for power analysis experiments. Therefore,
using the SASEBO-GII FPGA board is the most eﬀective way because it is designed
for the purpose of SCA experiment and it solves all the issues that a regular FPGA
board has. In summary, this work provides a general testing procedure to do SCA
attacks on the SASEBO-GII FPGA board.
3.3. NCL AES S-BOX DESIGN
AES algorithm consists of a number of rounds that are dependent on the key
size. For both cipher and decipher of AES algorithm, each round consists of linear
operation (i.e., AddRoundKey, ShiftRows, and MixColumns steps) and non-linear
operation (i.e., SubBytes step). SubBytes step is the ﬁrst step of AES round. Each
byte in the array is updated by an 8-bit substitution box (S-Box), derived from
the multiplicative inverse over GF(28). AES S-Box is constructed by combining the
inverse function with an invertible aﬃne transformation in order to avoid attacks
based on mathematics.
The S-Box is one the of most critical components in the
implementation of AES hardwares. It consumes the majority of power and is also
the most vulnerable component to SCAs. A block diagram of AES S-Box is shown
in Figure 3.1. The block diagram of multiplicative inversion over GF(28) component
where MM is modular multiplication, and XOR is exclusive-or operation [83].
The hardware implementation of AES S-Box adapted in this research follows
the combinational logic circuit architecture presented in [83], but uses NCL gates

36
(a)
(b)
Figure 3.1. Block diagram of a combinational S-Box with encryption and decryption
datapaths.
instead of Boolean logic gates. The aﬃne transformation and inverse aﬃne transfor-
mation components follow a series of Boolean equations given in Table 3.1, where i
and q represents the 8-bit input and output, respectively. Both transformations re-
quire many XOR gates. The multiplicative inversion in GF(28) follows the procedure
shown in Figure 3.1 part (b). 1) Map operation converts the 8-bit input into elements
of GF(24) (i.e. ah and al); 2) Calculate the square of ah and al. It should be no-
ticed that multiplication in GF(24) is done by multiplying the polynomial ah(x)ah(x)
followed by a modular reduction; 3) A series of multiplication and XOR operations
were implemented to extend the ﬁeld GF(24) to the ﬁeld GF(28). To implement
this conventional S-Box using NCL, the XOR, AND, and MUX operation in dual-rail
NCL gates are required [61].
NCL has a total of 27 threshold gates to realize various logic functions. In
order to achieve the input-completeness and observability, it is important to choose
appropriate threshold gates. For example, in the design of a two-to-one multiplexer,
according to the Karnaugh map in Figure 3.2(a), the sum-of-product (SOP) functions
can be simpliﬁed as follows:

37
Table 3.1. Boolean equations for aﬃne transformation and inverse aﬃne transforma-
tion components.
q = aff trans(i)
q = aff trans−1(i)
q0 = (i0 ⊕i4) ⊕(i5 ⊕i6) ⊕(i7 ⊕1)
q0 = i2 ⊕i5 ⊕i7 ⊕1
q1 = i1 ⊕i5 ⊕i6 ⊕i7 ⊕i0 ⊕1
q1 = i0 ⊕i3 ⊕i6
q2 = i2 ⊕i6 ⊕i7 ⊕i0 ⊕i1
q2 = i1 ⊕i4 ⊕i7 ⊕1
q3 = i3 ⊕i7 ⊕i0 ⊕i1 ⊕i2
q3 = i2 ⊕i5 ⊕i0
q4 = i4 ⊕i0 ⊕i1 ⊕i2 ⊕i3
q4 = i1 ⊕i3 ⊕i6
q5 = i1 ⊕i5 ⊕i2 ⊕i3 ⊕i4 ⊕1
q5 = i2 ⊕i4 ⊕i7
q6 = i6 ⊕i2 ⊕i3 ⊕i4 ⊕i5 ⊕1
q6 = i0 ⊕i3 ⊕i5 ⊕1
q7 = i7 ⊕i3 ⊕i4 ⊕i5 ⊕i6
q7 = i1 ⊕i4 ⊕i6
Z0 = A0S0 + S1B0;
(8)
Z1 = A1S0 + S1B1;
(9)
After modifying both functions for input-completeness, new SOP functions are
obtained:
Z0 = A0S0(A0 + A1)(B0 + B1) + S1B0(A0 + A1)(B0 + B1);
(10)
Z1 = A1S0(A0 + A1)(B0 + B1) + S1B1(A0 + A1)(B0 + B1);
(11)
and both of them can be mapped to a NCL circuit with a TH24comp gate, a THand0
gate, and a TH22 gate. The ﬁnalized NCL MUX logic diagram is shown in Figure
3.2(b).
Likewise, two TH24comp gates can be used to implement an XOR logic func-
tion. A THand0 and a TH22 gate are used to implement an AND logic function. The
logic diagrams are shown in Figure 3.3.

38
S
0
1
AB
00
01
11
10
0
1
0
0
0
1
1
1
THand0
THand0
A1 B0 B1 S0 S1
2
2
Z1
Z0
(a)
(b)
A0
TH24comp
Figure 3.2. An input-complete NCL multiplexer design.
Figure 3.3. Input-complete NCL XOR (left) and NCL AND (right) functions for the
proposed NCL S-Box.
3.4. FUNCTIONAL VERIFICATION
The proposed NCL S-box has been implemented in VHDL and simulated with
ModelSim by Mentor Graphics. By referring to the waveform shown on Figure 3.4, the
initial value of the input and output is NULL and DATA0, respectively, as previous
input registers are reset to NULL and output registers are reset to DATA0. As soon as
the resets fall down to 0, Ko from the output register becomes 1 and Ki from the input
register connected to Ko becomes 1. As Ki rises, the input is changed to the waiting
input signal, 0101010101010101 in dual-rail signaling which means 00000000 in binary

39
(0x00 in hexadecimal). The output arrives later due to the propagation delay, the
output becomes 0110100101011010 in NCL which means 01100011 in binary and 0x63
in hexadecimal. The input signals are cumulative from 0 to 255, increment by 1 in
each cycle. As shown in Figure 3.4, the input signal increases from 0x00 to 0x02
and the corresponding output signals are 0x63, 0x7C, and 0x77, respectively. The
results are matching with the standard S-Box announced by the NIST [84]. As every
bit of the output signal changes from NULL to DATA , Ko falls to 0, which means
that the output register has received the proper output DATA signal. Every single
component (i.e. aﬃne and inverse aﬃne transformation, multiplicative inversion) has
been veriﬁed separately. All the input/output date were extracted using the VHDL
textio package, then, a scripting program was written to verify each of the output
date, ensuring they function correctly. Table 3.2 shows the encryption and decryption
simulation results for both synchronous S-Box and NCL S-Box using 10 arbitrary
sample inputs, 5 for encryption and 5 for decryption, respectively. On the NCL S-
Box output column, the results are shown as 16 bits, which are the extended dual-rail
signals. For example, for input 158, the NCL S-Box output is 0101010110011010, and
this dual-rail encoded data word is equivalent to 00001011 in binary which is equal
to the output of the conventional synchronous S-Box.
Figure 3.4.
ModelSim waveform for the proposed NCL S-Box with input signals
changing from 0d to 3d.

40
Table 3.2. Simulation results for 10 arbitrary samples from conventional synchronous
S-Box and the proposed NCL S-Box.
Simulation Results
Mode
Input
Output
S-Box
NCL S-Box
Encrypt
9
00000001
0101010101010110
26
10100010
1001100101011001
106
00000010
0101010101011001
122
11011010
1001101001101001
158
00001011
0101010110011010
Decrypt
32
01010100
0110011001100101
51
01100110
0110100101101001
156
00011100
0101011010100101
185
11011011
1010011010011010
203
01011001
0110011010010110
Besides ModelSim simulation, the Field-Programmable Gate Array (FPGA)
based veriﬁcation has also been done on both synchronous S-Box and NCL S-Box
designs. Figure 3.5 is an oscilloscope screen image of the NCL S-Box hardware im-
plementation with the embedded key 11010100. The 16 digital signals represent the
dual-rail outputs of NCL S-Box. The blue waveform (Channel 1) is the voltage across
a shunt resistor of the FPGA core. It is used to measure the current of the FPGA,
which represents the power consumption of the FPGA core. The green (Channel 2)
and purple (Channel 3) waveforms are used to set the triggers to ease data alignment
for SCA programming. The falling edge of the green signal means that all 256 input
data have been processed and the last one would be Binary 11111111. Since the key is
11010100, after the bit-wise XOR function, the actual input goes to the S-Box would
be 00101011. According to the standard S-Box table[84], the corresponding output
is 11110001, which is 1010101001010110 in NCL or 0xF1 in hexadecimal as shown
in the Figure 3.5. Following that, the input signal is incremented to 00000000 and
the S-Box input becomes 00000000 L11010100 = 11010100, which generates the cor-
responding output 01001000 (i.e. 0x48). Similarly, hexadecimal numbers 0x03 and
0xF6 shown in the Figure 3.5 can be derived as well. All 256 inputs with diﬀerent

41
Figure 3.5. Power waveform of NCL S-Box design.
keys have been veriﬁed during the power analysis programming using Matlab. The
correct behavior of the function is the prerequisite for a successful power attack.
3.5. POWER MEASUREMENT EXPERIMENT
FPGA provides an eﬀective platforms for fast and highly reconﬁgurable pro-
totyping of integrated circuits.
Various instrumentation and measurements meth-
ods were implemented or demonstrated on FPGAs [85, 86]. A power measurement
methodology for FPGA was also presented to break down the power consumption of
diﬀerent elements inside the logic [87], allowing attackers to get detailed information
inside the circuit. This section goes into detail on the procedures used for the author’s
experiments and the results obtained from the power measurement associated to the
comparison of the synchronous AES S-Box. The total power consumption has been
measured using the MG tools in [61] and Table 3.3 presents the measurement results
on both designs. It shows the proposed NCL S-Box has 22% to 26% lower total power
consumption than synchronous S-Box. Figure 3.6 shows the SASEBO-GII board [88]

42
that is used as the basic platform in this experiment. There are two FPGA cores in
this board that can be utilized; the AES S-Box circuit is implemented in the cryp-
tographic circuit and the conﬁguration circuit is programmed into the conﬁguration
FPGA. The purpose of separating these two circuits is to prevent the power trace of
the conﬁguration circuit from interfering with the power trace of the cryptographic
circuit, so that the measurements of making/resisting power analysis attacks can be
done fairly. Two diﬀerent power analysis attacks were conducted on both synchronous
and NCL designs: Diﬀerential Power Analysis (DPA) and Correlation Power Analysis
(CPA).
Table 3.3. Power simulation results for synchronous AES S-Box and NCL AES S-Box
using Accusim and AdvanceMS.
Temperature: 27◦C
Synch S-Box
NCL S-Box
VDD: 1.8V
Total Power Dissipation
2.474E-08
1.934E-08
(Watts) - Accusim+Eldo
Total Power Dissipation
2.686E-08
1.981E-08
(Watts) - AdvanceMS
3.6. DIFFERENTIAL POWER ANALYSIS
DPA is a traditional power analysis attack that was ﬁrst proposed by Kocher
et al. [89] in 1999. DPA is a more eﬀective and sophisticated form of a power analysis
attack than SPA is. DPA utilizes a statistical method to analyze the relationship
between the key and the power consumption, even when the power consumption vari-
ations are so small that SPA could not deal with [89]. Once the logic circuits were
programmed into the FPGAs, measurements on the power waveform were performed
using an oscilloscope (i.e.,Tektronix MSO 4054 for this study). Figure 3.5 indicates
that most of the power consumption from the S-box occurs during the transition
between the DATA and NULL process in NCL logic. A trigger signal was designed

43
Cryptographic 
FPGA
Configuration 
FPGA
Take the power 
consumption
Figure 3.6. Speciﬁed side channel attack standard evaluation FPGA board (SASEBO-
GII).
to check the cycle of operation encompassing 256 ascending inputs. Following that,
experimental data were collected between two trigger pulses. The experimental data
consisted of 1 million points of the FPGA core current (representing power consump-
tion) and the digital output data along a time span of 400µs. The resolution time is
thereby 4ns. Thus, 165 points have been sampled for each input data.
The sampled data are then processed in Matlab to implement a DPA attack.
There are 256 outputs of data, each of which is related to a speciﬁc input datum.
Figure 3.7 illustrates the steps to this statistical analysis. In this ﬁgure, the solid
lines represent the path of the security key traveling through the system, while the
dash lines represents the hypothetical keys moving through the system. The process
of DPA consist of the following steps:

44
I1,I2...In
Security key
Cryptographic 
algorithm
O1,O2...On
Selection function
(sort by an arbitrary bit)
G(x,0,i)
G(x,1,i)
A(0,x)
A(1,x)
RMS
Avg(O1,O2...On)
Power differential
DPA results 
Key hypotheses
Directly sorting follow the 
same bit
Figure 3.7. Block diagram illustrating the DPA attack steps.
1. The average current corresponding to each output data are calculated in Matlab
using root mean square (RMS) algorithm.
Ap =
v
u
u
t
1
Nsample
Nsample
X
k=0
x2
i
(12)
Ap is the average of Nsample sampled current for output data i;

45
2. Two groups are deﬁned according to the select function when the secret key is
used (Detailed explanation could be found in[89]).
A0,x = 1
N0
Gx,0,i
X
Ap,i
(13)
A1,x = 1
N1
Gx,1,j
X
Ap,j
(14)
Gx,0,i and Gx,1,j are two sets of average current, respectively, and they are
grouped according to an arbitrary bit in the output.
3. The average power in each group is calculated using the results of the ﬁrst two
steps and then the diﬀerence in average power between these two groups is the
result of the DPA process.
dx = |A0,x −A1,x|
(15)
A0,x and A1,x are the average currents of 0-group and 1-group, respectively, for
a hypothetical key x; dx is the diﬀerence between the average currents.
This DPA process has been implemented on both synchronous S-Box and
NCL S-Box with 256 keys. Figure 3.8 part (a) is the result of the DPA attack on
the synchronous S-Box design; the correct key (16d) is clearly identiﬁable since the
power peak is much higher than other hypothesized keys. Figure 3.8 part (b) shows
the result of the DPA attack on the same S-Box design using NCL. The attacker
can not identify the correct key since its power peak is not prominent compared to
others. Due to the limited amount of space, only three other randomly selected keys
are shown here.
The DPA attack results show that the selected keys can not be
identiﬁed from other assumption keys. Therefore, the proposed NCL S-Box design
signiﬁcantly improves security against DPA attacks.
3.7. CORRELATION POWER ANALYSIS
A more eﬀective way to ﬁnd the secret key of a cryptographic device is to ana-
lyze the correlative relationship between the plain-text/cipher-text and instantaneous

46
50
100
150
200
250
0
1
2
3
4
5
6 x 10
−4
Hypothetical Keys
DPA Peak
(a)
50
100
150
200
250
0
0.5
1
1.5
2
2.5
3
3.5
4
x 10
−5
Hypothetical Keys
DPA Peak
Key = 16d
50
100
150
200
250
0
0.5
1
1.5
2
2.5
3
3.5
4
x 10
−5
Hypothetical Keys
DPA Peak
Key = 124d
50
100
150
200
250
0
0.5
1
1.5
2
2.5
3
3.5
4
x 10
−5
Hypothetical Keys
DPA Peak
Key = 189d
50
100
150
200
250
0
0.5
1
1.5
2
2.5
3
x 10
−5
Hypothetical Keys
DPA Peak
Key = 238d
(b)
Figure 3.8. Power peaks for various key assumptions for a DPA attack on synchronous
S-Box design and NCL S-Box design.
power consumption of the device. Pearson correlation coeﬃcient is the most familiar
measure of dependence between two quantities. Correlation power analysis (CPA) is
an improvement of DPA [90, 72, 91, 92]. In CPA, a power model is used to predict

47
the power consumption in terms of hypothetical keys and various input/output data;
the predicted power is then compared with the measured power using a correlation
coeﬃcient algorithm [93, 94, 95]. If the hypothetical key is the secret key, its cor-
relation coeﬃcient with the measured power will be signiﬁcantly higher than other
incorrect hypothetical keys.
Before introducing the detailed steps of CPA, an experimental setup (hardware
conﬁguration) is described below, which is important for obtaining a suﬃcient number
of power traces to execute a successful attack. Similar to the DPA experiment, CPA
was implemented in the S-Box design, which is downloaded into the SASEBO-GII
FPGA board. The core current of the cryptographic FPGA was measured through
a shunt resistor in the core power supply and it represents the instantaneous power
consumption.
The output of the S-box was sampled for the attacks attempts. A one bit
digital signal from the conﬁguration FPGA is also sampled. Its falling edge represents
the instant when an input datum is fed to the cryptographic FPGA. In this way the
current measurement (analog signal) can be easily aligned with the output of the
S-box (digital signals).
Such alignment is crucial for successful CPA attacks[93].
All analog and digital signals were measured using a Tektronix 500 MHz-bandwidth
oscilloscope MSO4054. The total number of data for one set of measurement is 10
million samples. The main clock for the FPGA board is 24 MHz and an input data
are sent to the cryptographic FPGA every 16 clock cycles. Therefore, the rate of
data is 24/16 = 1.5 MHz and the time span for each data is
1
1.5 MHz = 666.67 ns. The
sampling rate of the oscilloscope is 2.5 GHz for analog signals and 500 MHz for digital
signals, which are the maximum settings for MSO4054 oscilloscope. Therefore, the
length of instantaneous power measurement is 2500 GHz
24 MHz × 16 = 1666 samples for each
of datum
Unlike the DPA experiment, where the power consumption of all possible keys
(including the hypothetical keys and the secret key) are required to collect from the
FPGA board, CPA only requires the power consumption of the cryptographic device
to be collected while the secret key is embedded within it. The power consumption of
other hypothetical keys could be predicted using a power model; a Hamming Weight

48
(HW) model is used in this experiment [93]. The steps for revealing a secret key using
CPA is described as follows:
1. Retrieve a set of expected cipher-texts (O) (the output of the S-Box in this case)
that are generated by a set of plain texts (I) and a set of hypothetical keys (K).
Let Ii be an element in I (i ∈[1, nd] and nd is the number of plain texts) and
Kj be an element in K (j ∈[1, nk]] and nk = 256 is the number of possible key
for an 8-bit S-box). Deﬁne the S-box as a function name O(·) = SBox(·). Then
an element in O matrix is calculated as
Oi,j = SBox(IixorKj).
(16)
By applying (16), the O matrix is given by
Outputnd,nk =


O1,1
O1,2
· · ·
O1,nk
O2,1
O2,2
· · ·
O2,nk
...
...
...
...
Ond,1
Ond,2
· · ·
Ond,nk.


(17)
2. Apply a power consumption mode and build a hypothetical power consumption
matrix HW from the cipher-text matrix O. In this work, the Hamming weight
of a given cipher-text (the output of the S-box) is used as the power consumption
model.
HWi,j = HammingWeight(Oi,j).
(18)
By applying (18), the HW matrix is given by
HWnd,nk =


HW1,1
HW1,2
· · ·
HW1,nk
HW2,1
HW2,2
· · ·
HW2,nk
...
...
...
...
HWnd,1
HWnd,2
· · ·
HWnd,nk.


(19)

49
3. Measure the real power consumption of the cryptographic device for nd number
of inputs. As explained above, the instantaneous current consumption during
DATA transitions is the most important information for CPA. Therefore, this
experiment needs the transients power between the outputs rather than the
steady power. The alignment between the measured power and its correspond-
ing data is another critical fact for a successful CPA attack. As a result, each
data window is deﬁned as from 100 samples before a transient to 1500 sample
points after a transient (a total of 1600 samples per data window). The transient
signal is the falling edge from the conﬁguration FPGA, as discussed before. In
this way the digital sampling data can be accurately aligned with the measured
analog power. According to previous discussion, each datum has 1666 sampled
real power consumption points. There are 66 points discarded because they
are all in steady-state so that they play an insigniﬁcant role in CPA attacks.
Therefore, the windows length for each datum nt = 1600. A total number of
nd × nt sampled points are re-organized into a real power consumption matrix
RP. At the end of this step, a real power consumption matrix RPnd,nt of S-Box
should be generated, which is given by
RPnd,nt =


RP1,1
RP1,2
· · ·
RP1,nt
RP2,1
RP2,2
· · ·
RP2,nt
...
...
...
...
RPnd,1
RPnd,2
· · ·
RPnd,nt.


(20)
4. Compare the HW matrix with the RP matrix using the correlation coeﬃcient
formula to ﬁnd out the correct key that has the highest correlation value. There
are a total number of nk ∗nt correlation coeﬃcients to be calculated. In each
round of calculation, take one column Xj (j ∈[1, nk]) of the HW matrix
Xj =
h
HW1,j
HW2,j
· · ·
HWnd,j
iT
(21)
take one column Yt (t ∈[1, nt]) of the RP matrix
Yt =
h
RP1,t
RP2,t
· · ·
RPnd,t
iT
(22)

50
and calculate an element of the correlation coeﬃcient matrix Corr as
Corr(Xj, Yt) =
Cov(Xj, Yt)
p
V ar(Xj) · V ar(Yt)
.
(23)
The correlation coeﬃcient is deﬁned as equation (23). It is used to estimate
the relationship between two vectors Xj and Yt. Cov(Xj, Yt) represents the
covariance between Xj and Yt. V ar(Xj) and V ar(Yt) represent the standard
deviations of Xj and Yt, respectively. The Pearson correlation coeﬃcient esti-
mator r between Xj and Yt could be written in equation (24) for a series of n
measurements, where ¯x and ¯y represent the mean value of Xj and Yt, respec-
tively.
r =
Pn
i=1 (xi −¯x) · (yi −¯y)
qPn
i=1 (xi −¯x)2 · Pn
i=1 (yi −¯y)2
(24)
By applying (23), the correlation coeﬃcient matrix is give by
Corrnk,nt =


Corr1,1
Corr1,2
· · ·
Corr1,nt
Corr2,1
Corr2,2
· · ·
Corr2,nt
...
...
...
...
Corrnk,1
Corrnk,2
· · ·
Corrnk,nt.


(25)
Figure 3.9 shows the results of CPA attacks on the synchronous S-Box design
and NCL S-Box design, respectively.
The X-axis represents the length of a data
window and Y-axis represents the correlation value for each key hypothesis. There
would be total 28 = 256 possibilities from 0 to 255 for a 8-bit key. Thus, there are
256 correlation values in Y-axis for every sampled point in the data window. Correct
Keys are plotted in black, while the other key assumptions are plotted in grey. The
highest correlation peaks happened during the time of data transition. Therefore,
for synchronous S-Box design, the highest correlation value occurs at 200 ÷ 2.5e9 =
80(ns), which is around the
80 ns
666.67 ns × nt = 191th data point for a data window (as
shown in Figure 3.9(a)). This result shows that the CPA attack on the synchronous

51
S-Box is successful. For the NCL S-Box design, there are two signiﬁcant correlation
peaks in Figure 3.9(b) due to the transition between two data units being processed
as DATA1 to NULL, then NULL to DATA2. Using the similar method mentioned
previously, the two data transition points are around the 300th data point and the
1200th data point for a data window. The correct key (247d) is plotted in black,
while other key hypothesis are plotted in grey. Figure 3.9(a) shows that the correct
key (247d) is clearly revealed by observing the highest correlation value, while it can’t
be observed in Figure 3.9(b) because it is buried by other keys. Similarly, three other
random keys are selected for the CPA attacks, but none of the keys have the highest
correlation coeﬃcient. Therefore, the NCL S-Box design is resistant to CPA attacks.
3.8. NUMBER OF TRACES
Besides proper data alignment, another important factor is to get enough
number of power traces to conduct a successful DPA or CPA attack. The more traces
are measured, the more elements are in the RP matrix, the measurement noises
would cause less aﬀect, and the correlation between the measurement power and
power model would be more precise. However, too many power traces would increase
the time to gather data and the time to process the data. Therefore, it is interesting
to analyze the eﬀect of number of power traces on the success of CPA attacks. For
a given set of number of trace ntr ∈[1, 500] and a given key kj ∈K, In the HW
matrix, take the column corresponding to the key kj for ntr number of traces,
X
′
j =
h
HW1,j
HW2,j
· · ·
HWntr,j.
iT
(26)
In the RP matrix, take the column when transients happen (column 191 for syn-
chronous S-box and column 300 for NCL S-box, respectively, as discussed previously)
Y
′
t =
h
RP1,tran
RP2,tran
· · ·
RPntr,tran.
iT
(27)
And calculate the correlation coeﬃcient between vectors X
′
j and Y
′
t .
Repeat the
above process for all possible combinations of ntr and kj, the results are shown in
Figure 3.10 part (a) and part (b), for synchronous S-box and NCL S-box, respectively.

52
0
200
400
600
800
1000
1200
1400
1600
−0.5
−0.4
−0.3
−0.2
−0.1
0
0.1
0.2
0.3
0.4
Time (Sampling Point)
Correlation
(a)
0
200
400
600
800
1000
1200
1400
1600
−0.2
−0.1
0
0.1
0.2
0.3
Key = 124d
Time (Sampling Point)
Correlation
0
200
400
600
800
1000
1200
1400
1600
−0.2
−0.1
0
0.1
0.2
0.3
Key = 189d
Time (Sampling Point)
Correlation
0
200
400
600
800
1000
1200
1400
1600
−0.2
−0.1
0
0.1
0.2
0.3
Key = 212d
Time (Sampling Point)
Correlation
0
200
400
600
800
1000
1200
1400
1600
−0.2
−0.1
0
0.1
0.2
0.3
Key = 247d
Time (Sampling Point)
Correlation
(b)
Figure 3.9. CPA result for synchronous S-Box design and NCL S-Box design.
Figure 3.10 provides the threshold of how many traces are needed for attackers on
both designs at the instant of data transients.
The X-axis represents the number of traces and Y-axis represents the correla-
tion value at the time of data transients. The correct key (247d) is plotted in black,
and other keys are plotted in grey. For the synchronous S-Box, when the number of
power traces is small (ie. less than 25), the correlation coeﬃcient of the correct key

53
0
50
100
150
200
250
300
350
400
450
500
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
Traces
Correlation
(a)
0
50
100
150
200
250
300
350
400
450
500
−1
−0.5
0
0.5
1
Traces
Correlation
Key = 124d
0
50
100
150
200
250
300
350
400
450
500
−1
−0.5
0
0.5
1
Traces
Correlation
Key = 189d
0
50
100
150
200
250
300
350
400
450
500
−1
−0.5
0
0.5
1
Traces
Correlation
Key = 212d
0
50
100
150
200
250
300
350
400
450
500
−1
−0.5
0
0.5
1
Traces
Correlation
Key = 247d
(b)
Figure 3.10. The number of traces needed for a successful CPA attack.
is buried by the correlation coeﬃcient of other keys. This means that CPA would
fail when the number of power traces is too small. When there is enough number of
power traces (ie, more than 50), the correlation coeﬃcient of the correct key begins
to stand out from others. CPA attack in this case will be successful. However, for
the NCL S-Box design, the correct key does not stand out from other keys even the

54
number of traces pass 500. Therefore, it demonstrated that NCL makes the attack
more diﬃcult.
3.9. CONCLUSIONS
In this section, a hardware implementation of the proposed low power SCA
resistant asynchronous S-Box design for the AES crypto-system is revealed to be suc-
cessfully resisting DPA and CPA attacks. The asynchronous S-Box design is based
on a self-timing logic referred to as NCL, which supports beneﬁcial properties for
resisting DPA/CPA: clock-free, dual-rail signal, and monotonic transitions. These
beneﬁcial properties make it diﬃcult for attackers to decipher secret keys embedded
within the cryptographic circuit of the FPGA board. Utilizing the two FPGAs in-
cluded in the SASEBO-GII board, the conﬁguration and cryptographic functions are
able to be performed separately to ensure that the power trace measurements for the
analysis attacks do not interfere with each other. Experimental results of the original
design against the proposed S-Box revealed that the asynchronous design decreased
the amount of information leaked from both DPA and CPA attack. Results also re-
vealed that the proposed design showed beneﬁts of ﬂatter power peaks and 22% to
26% lower total power consumption during regular operation.
The proposed DPA and CPA attacks procedure based on power measurement
is comprehensive and general, not limited to SASEBO-GII board. It can be revised
and used for studying SCAs on other devices.

55
4. PROJECT III: STOCHASTIC BITSTREAMS COMPUTATION
4.1. BACKGROUND
Unlike most digital circuits that are designed to transfer deﬁnite inputs into
deﬁnite outputs. (i.e., Boolean, integer, and real value). Stochastic logic operates on
probabilistic bitstreams, where the signal is encoded by the probability of obtaining a
one or a zero from a given input signal [96]. An illustration of a stochastic bitstream
is shown in Figure 4.1 [97]. A real value x = 3/8 ( 0 ≤x ≤1) is represented as a
bitstream with three bits are one.
Figure 4.1. A stochastic bitstream with value 3/8.
Stochastic logic can be adapted to any combinational circuits, with stochastic
bitstreams as inputs and/or outputs. Therefore, logical computation in the determin-
istic Boolean number domain is transformed into probabilistic computation in the real
number domain. Figure 4.2 [97] shows an AND gate with bitstreams as inputs and
outputs, the probabilities of obtaining a one in the input streams are 0.8 and 0.5.
The probability of obtaining a one in the output stream is 0.4, which is 0.8 × 0.5.
The beneﬁts of using stochastic logic are:
1. A complex operations in Boolean logic can be designed in a simple way using
stochastic logic. For example, the multiplication operation can be implemented
using a single AND gate as shown in Figure 4.2[97]. In contrast, conventional
digital multiplier design needs a much complex design. More complex functions

56
Figure 4.2. An AND gate to implement multiplication.
such as the Taylor expansion of an exponential function and the square root
function can also be implemented using stochastic methodology [98, 99].
2. Stochastic logic circuits are highly tolerant to errors in signal processing where
small ﬂuctuations can be tolerated but large errors are catastrophic [100]. For
example, if a single bit occasionally ﬂipped into its complementary value (i.e.,
logic one becomes logic zero or vice-versa), the probability of occurrence of zeros
and ones are not substantially changed. But if the same thing happened to a
conventional circuit, bit ﬂips can be a serious problem.
3. Stochastic representation of data could be either serial streaming on a single
wire or in parallel on a bundle of wires. The parallel bitstreams can be synthe-
sized into nanowire crossbar arrays [101]. The high fault-tolerance is also very
important for nanoscale computation.
4. The highly randomness property of stochastic logic is helpful for cryptographic
devices against power analysis attacks and thus, to enhance hardware security.
This work has addressed this advantage by implementing an 8-bit AES S-Box
with stochastic bitstreams.
However, things always come with tradeoﬀs. Comparing with conventional bi-
nary radix encoding, the stochastic logic encoding generates a large delay in obtaining
the computation results [96]. A binary encoding can represent 2n numbers with only
n bits, while to present real numbers with a resolution of 2−n, numbers of the form
x
2n for integers x between 0 and 2n, a stochastic encoding requires a stream of 2n

57
bits. Stochastic logic uses probabilistic bitstreams to represent the binary logic state.
Thus, the random ﬂuctuation will generate some errors during the logic computation.
In Figure 4.2, if the input stream A changes to 0,1,0,1,1,1,1,1,1 (a=0.8), while input
stream B remain the same, the output bitstream will become 0,0,0,1,0,0,1,0,0,1, which
is 0.3, not 0.4 any more. Therefore, the 100% accuracy in stochastic bitstreams is
diﬃcult to achieve.
4.2. STOCHASTIC CRYPTOGRAPHIC DEVICES
Utilizing the concept of stochastic bitstreams, a novel approach to enhance the
security of cryptographic devices against power analysis attacks has been presented
in this work.
The proposed structure has good compatibility that could be used
in diﬀerent combinational logic core of encryption standards. To demonstrate the
methodology, a MATLAB simulink based simulation was designed to show the idea.
Following that, a VHDL hardware implementation of an 8-bit AES S-Box was built
to verify the resistance of power analysis attacks.
4.2.1. MATLAB Simulink Structure.
For a given combinational logic
(i.e., a two-input AND gate followed by a two-input OR gate in this case), an encoder
with a random number generator is needed to generate the bitstreams. The output
of the combinational logic is bitstreams, therefore a decoder is needed to convert
the bitstreams to binary numbers for logic veriﬁcation. The system structure of this
MATLAB Simulink based simulation is shown in Figure 4.3.
The simulation model includes three encoders for each input signal, a given
combinational logic, and a decoder for output. The block diagram of an encoder is
shown in Figure 4.4. It consists of a build-in random number generator (RNG) with
sampling rate of 100 KHz, a decision function, and a comparator. RNG generates a
random number (RN) in the range of 0 to 1. The expression of decision function is
P = 0.25 + 0.5 × x, where x represents the input. P is the design weight; P = 0.25
when x = 0, meaning that the probability of 0s in the bitstreams is 25%; similarly,
the probability of 1s in the bitstreams is 75%. The output becomes 1 if RN ≤P,
and 0 if RN > P. The generated bitstreams can be seen in Figure 4.5. The top two
signals (i.e., andin1, andin2) represent the two input bitstreams of the AND gate, and
the bottom signal (i.e., andout) is the output bitstreams of the AND gate.

58
Figure 4.3. Stochastic implementation of a combinational logic in simulink.
Figure 4.4. Encoder block.
Figure 4.6 shows the block diagram of a decoder. The input of the decoder is
the output of stochastic logic blocks, which is in the form of stochastic bitstreams.
The up-counter counts the number of 1s in the bitstream and the probability of 1s
is calculated by dividing the counter value by the length of the bitstream window.
The comparator determines the output state, by comparing the calculated possibility
with 0.5. If the calculated probability is larger than 0.5, the output is considered as
1 in conventional logic. On the other hand, it is considered as 0 in conventional logic
if the probability is less than 0.5.

59
and_in2
and_in1
and_out
0.5
0.9
1
0.7
0.3
0.4
0.2
0.8
0.6
0
0.1
0.2
0.4
0.3
0
0.1
0.6
0.7
0.8
0.9
1
0.5
× 1e-2
8.701
8.706 8.707
8.705
8.704
8.703
8.7
8.699
8.702
0.1
1
0.8
0.9
0
0.7
0.6
0.5
0.4
0.3
0.2
Figure 4.5. Generated bitstreams waveform of AND function.
The ﬁnal output of the MATLAB simulink based simulation is shown in Figure
4.7. It shows that output is exactly matching with this combinational logic function
OUT ⇐(In1 • In2) + In3;
This simulation model has demonstrated the idea of utilizing encoder and
decoder to convert signals between stochastic bitstreams and conventional binary
signals for a given combinational logic. However, in order to do the power analysis
attack, a synthesizable hardware model of a cryptosystem need to be designed, so the
power traces can be measured using the SASEBO-GII FPGA board.

60
Figure 4.6. Decoder block.
4.2.2.
Hardware Implementation of Bitstream Based AES S-Box.
This subsection presents the hardware implementation of an 8-bit AES S-Box that
is based on stochastic bitstreams. As mentioned earlier, S-Box is the most critical
component of AES cryptographic devices because it is the most vulnerable component
to SCA. Its Boolean logic implementation has been presented in Section 3.3. In a
stochastic logic system, encoders and decoders are needed. The system diagram of
the proposed structure is shown in Figure 4.8. In this work, the author deﬁnes HIGH
and LOW to represent two possible states in a binary encoded bit in the input and
output, while 1s and 0s to represent bits in the stochastic bitstreams. For clarity, in
Figure 4.8, the solid lines represent the conventional logic states, while the dash lines
represent the stochastic bitstreams.
The input (i.e., plaintext) and output (i.e., ciphertext) of the proposed design
are in standard boolean logic. As Figure 4.8 shows, there are eight encoders, which
generate stochastic bitstreams for each bit of the input data. The inputs of encoders
are one bit from the input data and a 32-bit ﬁxed-point random number (RN), which
is ranging from 0 to 1. The random numbers are generated by combining the design
of linear feedback shift register (LFSR) and cellular automata shift register (CASR)
based pseudo-random number generators. This combined Random Number Generator
(RNG) has better bit independence, longer cycle length, and enhanced unpredictable
randomness [102]. The equation of encoders is

61
in1
out
in3
in2
0
0.6
0.8
0.4
0.2
1
0.8
0
0.6
0.2
0.4
1
0.02
0.16
0.08
0.04
0.12
0.2
0.18
0
0.14
0.1
0.06
1
0.2
0
0.8
0.4
0.6
0.4
0.2
1
0.6
0.8
0
Figure 4.7. Final output waveform.
Eo(i) =





1,
(x = HIGH ∧P1 ≥RN) ∨(x = LOW ∧P0 ≥RN)
0,
(x = HIGH ∧P1 < RN) ∨(x = LOW ∧P0 < RN)
(28)
where x represents the input bit, P1 and P0 are the decision weight of the encoders,
which dictate the probability of 1s and 0s in the bitstreams, respectively, when input
is HIGH. Note that P1 + P0 = 1 (P1 > 0, P0 > 0). The distribution of P1 and P0
deﬁnes the decision weight of encoders, which aﬀects the performance of the proposed

62
Encoder
Encoder
Encoder
Encoder
Encoder
Encoder
Encoder
Encoder
RNG
RNG
RNG
RNG
RNG
RNG
RNG
RNG
Combinational 
Logic AES S-Box
Decoder
Decoder
Decoder
Decoder
Decoder
Decoder
Decoder
Decoder
Plain 
Text
Cipher 
Text
Figure 4.8. System diagram.
structure. The outputs of each encoder (Eo) are stochastic bitstreams that has the
probability of P1 to be ’1’ when its input is HIGH and the probability of P0 to be ’1’
when its input is LOW. RN represents the random number that is generated by the
RNGs.
The outputs of all encoders combine together to form an 8-bit bitstream (i.e.,
Eo(0) to Eo(7) ), contain information of the plaintext and are fed into a combinational
logic S-box. The outputs of the S-box are the encrypted information, which is also in
bitstreams. Therefore, decoders are needed to obtain the ciphertext, which count the
number of 1s to determine whether the present bitstream represents HIGH or LOW
logic. The equation of decoder is
Do(i) =





HIGH,
Na=1
Nclk ≥0.5,
LOW,
Na=1
Nclk < 0.5,
(29)
where Na=1 is the number of 1s in the input bitstreams of a decoder and Nclk is the
number of bitstream bits for an input logic state. Do is the output of decoder. The

63
following sections will discuss two aspects of the proposed stochastic logic S-box: (1)
functionality and (2) resistance to power analysis attacks.
4.3. LOGIC VALIDATION
Stochastic logic injects randomness and uncertainty into the data ﬂow, which
helps in resisting power analysis attacks, but errors are inherently inevitable due to
probabilistic nature of it. For cryptographic devices, 100% encryption/decryption
accuracy is important. Thus, the accuracy of the implemented combinational logic
should be analyzed and veriﬁed. In general, three factors may aﬀect the accuracy of
stochastic logic devices: the length of bitstreams for a given logic state, the decision
weight of the encoders, and the repetition times of an input.
The proposed design has been implemented in VHDL and simulated using
ModelSim. The output data are exported to a text ﬁle using the VHDL textio pack-
age, and then, compared with the correct output responses using a script. In this
way, errors can be located and the error rate can be calculated as well. An intuitive
method to decrease the likelihood of error is to repeat the input data. A given input
datum is repeated by Nr times. The decoder side takes Nr number of output data and
takes the one that appears most the times as the output. Given a total number of M
input data, the error rate Er is deﬁned as Er = Mwrong
M
, where Mwrong is the number
of error outputs, which are deﬁned as the output of the decoder is diﬀerent from the
expected output value, among M input data. Figure 4.9 shows numerous error rate
curves obtained by varying decision weight, bitstream length and repetition times.
For each bitstream length, the error rate increases as P0 increases. Increase in the
diﬀerence between P0 and P1 means the resulting bitstreams exhibit less randomness.
P0 = P1 = 0.5 means complete randomness (i.e., the bitstreams contain no informa-
tion), while P0 = 0, P1 = 1 means no randomness (same as the conventional binary
logic). In Figure 4.9, more randomness results in a higher error rate. The longer the
bitstream for an input state is, the lower the error rate is. The more repetition times
for an input, the lower the error rate is.
Based on the simulation results, there are several patterns lead the proposed
structure to achieve near 100% accuracy. For example, two possible patterns are: 1)

64
Decision weight of P0 = 0.1, P1 = 0.9 with bitstream length of 512 or more, and 2)
P0 = 0.05, P1 = 0.95 with bitstream length of 256 or more.
Figure 4.9. Error rate of stochastic bitstream S-box.
4.4. CPA RESULTS
Besides ModelSim simulation, the proposed stochastic bitstream S-Box has
been also veriﬁed using a speciﬁed SCA standard evaluation FPGA board (SASEBO-
GII). It includes two FPGA cores to implement cryptographic logic and conﬁguration
logic separately. So the power traces from cryptographic core would not be aﬀected
by conﬁguration circuit. Figure 4.10 compares the power traces between regular S-
box (Top) and stochastic S-box (Bottom) design. It shows that switching power is
much less in the stochastic S-box design.
Among various SCA methods, CPA is considered to be more advanced and
eﬀective.
CPA calculates the correlation coeﬃcients between an estimated power
model and the real measured power consumption.
Since the power consumption
of an integrated circuit can be estimated by the Hamming Distance (HD) between
the current state and its consequential state [73].
The estimated power model is
the Hamming Weight (HW) matrix of all outputs for all possible hypothesis keys.

65
Figure 4.10. Power traces comparison between regular S-box (Top) and stochastic
S-box (Bottom) design.
Once the correlation coeﬃcients between the HW matrix and the measured power
consumption matrix are calculated. The trace with the highest correlation coeﬃcient
is chosen to be the correct secret key. A detailed procedure of carrying a CPA attack
has been reported in [103].
Figure 4.11 shows the result of an attempted CPA attack on the proposed
design. The X-axis represents the length of a data window and Y-axis represents the
correlation value for each key hypothesis. There would be total of 256 possibilities
for an 8-bit key. The correct key (63d) is plotted in black, while other hypothesis
keys are plotted in grey. The correct key is buried by the other keys. There is no
correlation coeﬃcient trace that is signiﬁcantly higher than the others. Therefore,
it is statistically infeasible to reveal the correct secret key in the given case. This

66
indicates that the stochastic bitstream S-box design is resistant to the CPA attacks.
The same CPA has conducted to a regular Boolean S-box design in [103], the attack
was found to be successful. The proposed stochastic bitstream method can enhance
security against power analysis attacks without the need to completely re-design the
core logic functional blocks. Therefore, the method in this work can be applied to
many other devices when they require enhanced security.
Figure 4.11. CPA results of stochastic bitstream S-box.
4.5. CONCLUSIONS
This section presents a novel approach to enhance the security of cryptographic
devices against the power analysis attacks. The proposed approach uses stochastic
logic, which utilizes probabilistic bitstreams to represent cryptographic information.
The stochastic bitstream is generated by encoders with combination of CASR and
LFSR based random number generators. The input and output signals of the core
cryptographic component are the stochastic bitstreams and their randomness makes
it diﬃcult to carry out power analysis attacks. The output bitstreams are converted

67
back to the conventional binary logic signals by decoders to ensure compatibility with
other logic functions. The functionality of the proposed design has been veriﬁed us-
ing an 8-bit AES S-box design. The eﬀects of decision weight, bitstream length, and
input repetition times on error rates have been also studied. Experimental results
obtained from a SASEBO-GII crypto-hardware evaluation board shows that the pro-
posed approach enhances the resistance to against the CPA attack by successfully
protecting the hidden key.

68
5. SUMMARY AND CONCLUSIONS
5.1. SUMMARY OF CONTRIBUTIONS
The objective of this dissertation is to study and analyze two applications of
NCL and to explore more beneﬁts of asynchronous NCL circuits and related system.
NCL is an asynchronous logic with the feature of delay-insensitivity and dual-rail
logic representation. Various NCL circuits have been designed with the purpose of
improving power consumption and reducing noise and EMI. However, NCL designs
require a much larger area than conventional Boolean logic designs, which might not
be optimal for the applications like potable digital devices. Therefore, in order to
fully demonstrate the merits of NCL, and to locate the appropriate applications for
it, this dissertation introduces two applications.
The ﬁrst one is NCL-based ANRCAs for nano-scale computing. With the ab-
sent of clock distribution network, ANRCAs are anticipated to make the nanowire
crossbar design much more ﬂexible and fault tolerant for manufacturing. The author
has proposed two implementations of ANRCA, DR-ANRCA and MLUT-ANRCA,
both of which have the advantages of eliminating clock-related issues, good scalabil-
ity, and high reliability. Starting with primitive conﬁgurable logic unit (PGMB), a
number of diﬀerent reconﬁgurable CLBs, the fundamental building blocks of FPGA-
like hierarchical architectures, have been designed and analyzed. The author also has
compared diﬀerent design schemes in terms of area, programming steps, and latency.
Finally, defect-tolerance and repair strategies have been presented and discussed. All
these together provide the backbones for the future development of nano-scale asyn-
chronous logic, especially reconﬁgurable devices.
The second contribution of this dissertation is NCL-based cryptographic de-
vices for enhanced security against SCAs. An 8-bit AES S-Box, the core compo-
nents of AES cryptographic devices, is used as demonstration. The NCL-based asyn-
chronous S-Box design has a number of features that help improve the resistance to
SCAs, such as clock-free, dual-rail signals, and monotonic transitions. Such novel

69
S-Box designs has been implemented in VHDL and tested in both software simula-
tion and hardware experiment. The detail procedure to carry out two popular SCAs,
DPA and CPA, is provided. It has been demonstrated that the proposed NCL-based
S-Box has the ability to resist various SCAs, and to have lower total power con-
sumption, by comparing with its synchronous counterparts. As more people become
concerned with cyber-security recently, the contribution in this section presents a
security enhancement approach in the circuit design level.
Security of cryptographic devices would also be improved by using stochastic
logic, which uses probabilistic bit streams to represent cryptographic information.
This dissertation proposes a encoder/decoder scheme to use probabilistic bit streams
without re-writing everything from scratch. The core component, in stochastic bit
streams, has the feature of randomness to make SCAs very diﬃcult.
Meanwhile,
the proposed design ensures compatibility with other logic functions. The author
has studied the eﬀects of a number of parameters on the performance of the pro-
posed design scheme. Hardware demonstration on an 8-bit AES S-box conﬁrms the
enhancement against CPA attacks.
5.2. FUTURE WORK
The future work includes but is not limited to the following topics:
1) One topic is to develop an experimental prototype of the proposed ANR-
CAs using existing nanowire fabrication strategies. As discussed in Section 2, two
approaches are possible, including bottom-up or hybrid bottom-up/top-down ap-
proaches [104, 105]. DR-ANRCA, MLUT-ANRCA, and some other design techniques
developed in this dissertation have the potential in the application of the prototype
nanowire-based integrated circuit. Silicon Nanowires (SiNWs) has been extensively
studied by many researchers [106] because silicon is the dominant material of the ex-
isting semiconductor industry. On the other hand, Germanium Nanowires (GeNWs)
has also been studied to implement high performance tunnel diodes recently [107],
which could be a good candidate to implement the proposed DR-ANRCAs.
The
studies of memristor materials are updated frequently with diﬀerent features [47].
The state-of-the-art in memristors uses titanium dioxide (TiO2) as resistive mate-
rial, which is sandwiched between platinum electrodes. A silicon-based memristor

70
was proposed in [108]. ANRCAs experimental prototype can be developed using dif-
ferent materials. Then, the device characterization data would be collected for the
performance comparison.
2) Nanowire-based integrated circuit, because of its bottom-up structure, re-
quires major innovation in Computer-Aid Design (CAD) tools. An automated design
optimization tool could be developed for the FPGA-like hierarchical ANRCAs. The
tool should be able to maximize the utility of PGMBs, optimize programming steps,
and take care of the inherent fabrication defect issues.
3) The NCL-based S-Box design can be extended to a full 14 rounds of 256-bit
AES design. The ﬁrst step would be to test the full NCL AES on the FPGA board.
And then a NCL-based AES core processor prototype could also be in the process
of taping out. Various SCAs are applied to the ASIC to verify its resistance against
SCAs. It would be interesting to study and to analyze the practical issues to do
successful SCAs on ASIC-based chips. It is also necessary to study the eﬀect of ASIC
layout on the chance of successful SCAs.
4) Another enhanced security strategy is to involve a Spatial and Tempo-
ral Random Dynamic Voltage Scaling (STRDVS) technology, which can provide
additional resistance to SCAs and to further reduce the power consumption [109].
STRDVS can be implemented inside the NCL-base crypto-processor with diﬀerent
voltage levels. Scaling down the supply voltage will have impacts on the chip perfor-
mance, such as speed and fault tolerance. Therefore, a series of numerical analysis is
needed to determine the boundary of voltage scaling range. And the issue of fault-
tolerance in high-speed low-voltage digital integrated circuits has become attractive
recently. It is interesting to see how fault-tolerance calculation is related to NCL-
based crypto-processors.
5) The proposed scholastic bit streams based encoder/decoder scheme needs
further optimization to eliminate the errors generated by randomness. The regular
error detection and repair strategy is no longer applicable to cryptographic applica-
tions due to the fact that the errors in the ciphertext are unpredictable. An automatic
scholastic analysis tool could be developed to ﬁnd the proper distribution between
scholastic logic and conventional logic functions.

71
BIBLIOGRAPHY
[1] K. Fant and S. Brandt, “Null convention logicTM: a complete and consistent
logic for asynchronous digital circuit synthesis,” International Conference on
Application Speciﬁc Systems, Architectures and Processors, pp. 261–273, 1996.
[2] K. M. Fant and S. A. Brandt, “Null convention logic: A complete and consistent
logic for asynchronous digital circuit synthesis,” in Proceedings of the IEEE
International Conference on Application-Speciﬁc Systems, Architectures, and
Processors, p. 261, 1996.
[3] K. M. Fant and S. A. Brandt, “Null convention logic system,” US Patent (US
5305463), 04 1994.
[4] S. C. Smith, “Speedup of null convention digital circuits using null cycle reduc-
tion,” Journal of System Architecture, vol. 52, no. 7, pp. 411–422, 2006.
[5] J. McCardle and D. Chester, “Measuring an asynchronous processor’s power
and noise,” Proceedings of the Synopsys User Group Conference, 2001.
[6] S. K. Bandapati and S. C. Smith, “Design and characterization of null con-
vention arithmetic logic units,” Microelectron. Eng., vol. 84, pp. 280–287, Feb.
2007.
[7] S. C. Smith, “Design of a null convention self-timed divider,” in The Interna-
tional Conference on VLSI, vol. 1, pp. 447–453, 2004.
[8] L. Zhou and S. Smith, “Speedup of a large word-width high-speed asynchronous
multiply and accumulate unit,” in 52nd IEEE International Midwest Sympo-
sium on Circuits and Systems, pp. 499 –502, Aug. 2009.
[9] S. Smith, “Design of an FPGA logic element for implementing asynchronous null
convention logic circuits,” IEEE Transactions on Very Large Scale Integration
(VLSI) Systems, vol. 15, no. 6, pp. 672 –683, 2007.
[10] V. Satagopan, B. Bhaskaran, W. K. Al-Assadi, S. C. Smith, and S. Kakarla,
“DFT techniques and automation for asynchronous null conventional logic cir-
cuits,” IEEE Transactions on Very Large Scale Integr. Syst., vol. 15, pp. 1155–
1159, October 2007.
[11] S. C. Smith, “Speedup of null convention digital circuits using null cycle reduc-
tion,” Journal of System Architecture, vol. 52, pp. 411–422, July 2006.
[12] S. C. Smith, R. F. DeMara, J. S. Yuan, D. Ferguson, and D. Lamb, “Optimiza-
tion of null convention self-timed circuits,” Elsevier’s Integration, The VLSI
Journal, vol. 37, pp. 135–165, Aug. 2004.

72
[13] S. Smith and J. Di, “Designing asynchronous circuits using null convention logic
(NCL),” Synthesis Lectures on Digital Circuits and Systems, July 2009.
[14] K. Fant and S. Brandt, “Null convention logicTM: a complete and consis-
tent logic for asynchronous digital circuit synthesis,” Proceedings of Interna-
tional Conference on Application Speciﬁc Systems, Architectures and Proces-
sors, pp. 261–273, Aug 1996.
[15] S. Hauck, “Asynchronous design methodologies: an overview,” Proceedings of
the IEEE, vol. 83, pp. 69 –93, jan 1995.
[16] V. B. A. Joshi, M.V. Jegadeesan, “NCL implementation of dual-rail 2 s com-
plement 88 booth2 multiplier using static and semi-static primitives,” IEEE
Region 5 Technical Conference, pp. 59–64, April 2007.
[17] A. DeHon, “Deterministic addressing of nanoscale devices assembled at sub-
lithographic pitches,” IEEE Transactions on Nanotechnology, vol. 4, pp. 681 –
687, Nov. 2005.
[18] J. Mustafa and R. Waser, “A novel reference scheme for reading passive resistive
crossbar memories,” IEEE Transactions on Nanotechnology, vol. 5, pp. 687 –
691, Nov. 2006.
[19] M. Ziegler and M. Stan, “Design and analysis of crossbar circuits for molecu-
lar nanoelectronics,” Proceedings of the IEEE Conference on Nanotechnology,
pp. 323–327, 2002.
[20] N. A. Melosh, A. Boukai, F. Diana, B. Gerardot, A. Badolato, P. M. Petroﬀ,
and J. R. Heath, “Ultrahigh-Density Nanowire Lattices and Circuits,” Science,
vol. 300, no. 5616, pp. 112–115, 2003.
[21] M. Tehranipoor, “Defect tolerance for molecular electronics-based nanofabrics
using built-in self-test procedure,” in Proceedings of the 20th IEEE International
Symposium on Defect and Fault Tolerance in VLSI Systems, pp. 305–313, 2005.
[22] J. R. Heath, P. J. Kuekes, G. S. Snider, and R. S. Williams, “A defect-tolerant
computer architecture: Opportunities for nanotechnology,” Science, vol. 280,
pp. 1716–1721, 1998.
[23] J. Hu, T. W. Odom, and C. M. Lieber, “Chemistry and physics in one di-
mension: Synthesis and properties of nanowires and nanotubes,” Accounts of
Chemical Research, vol. 32, no. 5, pp. 435–445, 1999.
[24] Y. Chen and D. Ohlberg, “Nanoscale molecular-switch devices fabricated by
imprint lithography,” vol. 82, pp. 1610–1612, Mar 2003.
[25] L. Paulson, “Researchers work on transistor successor,” Computer, vol. 38,
pp. 17–23, May 2005.

73
[26] A. Dehon, “Nanowire-based programmable architectures,” ACM Journal on
Emerging Technologies in Computing Systems (JETC), vol. 1, no. 2, pp. 109–
162, 2005.
[27] K. P. H. T. Snider, G. and R. Stanley Willams, “Nanoelectronic architectures,”
Applied Physics A 80, pp. 1183–1195, March 2005.
[28] G. Snider and P. Kuekes, “Nano state machines using hysteretic resistors and
diode crossbars,” IEEE Transactions on Nanotechnology, vol. 5, pp. 129 – 137,
March 2006.
[29] D. B. Strukov, G. S. Snider, D. R. Stewart, and S. R. Williams, “The missing
memristor found,” Nature, vol. 453, pp. 80–83, May 2008.
[30] R. S. Chakraborty, S. Paul, and S. Bhunia, “Analysis and robust design of
diode-resistor based nanoscale crossbar pla circuits,” in Proceedings of the 21st
International Conference on VLSI Design, pp. 441–446, 2008.
[31] S. C. Goldstein and M. Budiu, “Nanofabrics: Spatial computing using molecu-
lar electronics,” in Proceedings of the 28th annual international symposium on
Computer architecture, pp. 178–191, 2001.
[32] S. C. Goldstein and Rosewater, “Digital logic using molecular electronics,” in
International Solid-State Circuits Conference, pp. 125–128, 2002.
[33] M. Mishra and S. C. Goldstein, “Scalable defect tolerance for molecular elec-
tronics,” in International Symposium on High-Performance Computer Archi-
tecture (HPCA), p. 78, 2002.
[34] D. Strukov and K. Likharev, “Reconﬁgurable hybrid cmos/nanodevice circuits
for image processing,” IEEE Transactions on Nanotechnology, vol. 6, pp. 696
–710, Nov. 2007.
[35] K. Likharev, “Defect-tolerant hybrid CMOS/Nanoelectronic Circuits,” in IEEE
International Symposium on Defect and Fault Tolerance of VLSI Systems,
p. 504, Oct. 2008.
[36] S. Mitra, L. Avya, and E. McCluskey, “Eﬃcient multiplexer synthesis tech-
niques,” IEEE Design and Test of Computers, vol. 17, pp. 90–97, Oct-Dec 2000.
[37] S. C. Smith, R. F. Demara, J. S. Yuan, M. Hagedorn, and D. Ferguson, “Delay-
insensitive gate-level pipelining,” Integration, the VLSI journal, vol. 30, pp. 103–
131, 2001.
[38] J. Huang, M. Tahoori, and F. Lombardi, “On the defect tolerance of nano-
scale two-dimensional crossbars,” IEEE International Symposium on Defect and
Fault Tolerance in VLSI Systems, pp. 96–104, Oct. 2004.

74
[39] S. Venkateswaran, J.-S. Lee, and M. Choi, “Novel functional testing technique
for asynchronous nanowire crossbar system,” in IEEE Instrumentation and
Measurement Technology Conference, pp. 1121 –1125, May 2009.
[40] S. Venkateswaran and M. Choi, “Post-conﬁguration testing of asynchronous
nanowire crossbar architecture,” in IEEE Conference on Nanotechnology,
pp. 899 –902, Aug. 2008.
[41] L. Chua, “Memristor-the missing circuit element,” IEEE Transactions on Cir-
cuit Theory, vol. 18, pp. 507–519, January 2003.
[42] J. R.Colin, “Memristor created: Rewrite the textbook,” EETIMES, 2008.
[43] P. O. Vontobel, W. Robinett, P. J. Kuekes, D. R. Stewart, J. Straznicky, and
R. S. Williams, “Writing to and reading from a nano-scale crossbar memory
based on memristors,” Nanotechnology, vol. 20, no. 42, pp. 425–504, 2009.
[44] Y. Ho, G. Huang, and P. Li, “Nonvolatile memristor memory: Device charac-
teristics and design implications,” in IEEE/ACM International Conference on
Computer-Aided Design - Digest of Technical Papers, pp. 485 –490, 2009.
[45] K.-H. Jo, C.-M. Jung, K.-S. Min, and S.-M. Kang, “Self-adaptive write cir-
cuit for low-power and variation-tolerant memristors,” IEEE Transactions on
Nanotechnology, vol. 9, pp. 675 –678, Nov. 2010.
[46] S. Shin, K. Kim, and S.-M. Kang, “Memristor applications for programmable
analog ICs,” IEEE Transactions on Nanotechnology, vol. 10, pp. 266 –274,
March 2011.
[47] T. Raja and S. Mourad, “Digital logic implementation in memristor-based cross-
bars - a tutorial,” in IEEE International Symposium on Electronic Design, Test
& Applications, pp. 303–309, 2010.
[48] J. Wu and M. Choi, “Memristor lookup table (mlut)-based asynchronous
nanowire crossbar architecture,” in IEEE Conference on Nanotechnology,
pp. 1100 –1103, Aug. 2010.
[49] M. Lazzaroni, V. Piuri, and C. Maziero, “Computer security aspects in indus-
trial instrumentation and measurements,” in IEEE Instrumentation and Mea-
surement Technology Conference (I2MTC), pp. 1216 –1221, May 2010.
[50] J. Kocher, P. Jaﬀe and B. Jun, “Introduction to diﬀerential power analysis
and related attacks,” in Technical Report, Cryptography Research Inc., San
Francisco, California, 1998.
[51] D. Macii and D. Petri, “Accurate software-related average current drain mea-
surements in embedded systems,” IEEE Transactions on Instrumentation and
Measurement, vol. 56, pp. 723 –730, June 2007.

75
[52] V. Konstantakos, K. Kosmatopoulos, S. Nikolaidis, and T. Laopoulos, “Mea-
surement of power consumption in digital systems,” IEEE Transactions on In-
strumentation and Measurement, vol. 55, pp. 1662 –1670, Oct. 2006.
[53] D. Macii and D. Petri, “An eﬀective power consumption measurement procedure
for bluetooth wireless modules,” IEEE Transactions on Instrumentation and
Measurement, vol. 56, pp. 1355 –1364, aug. 2007.
[54] L. Angrisani, M. D’Apuzzo, and M. Vadursi, “Power measurement in digital
wireless communication systems through parametric spectral estimation,” IEEE
Transactions on Instrumentation and Measurement, vol. 55, pp. 1051 – 1058,
Aug. 2006.
[55] T. Lopez and R. Elferich, “Measurement technique for the static output char-
acterization of high-current power MOSFETs,” IEEE Transactions on Instru-
mentation and Measurement, vol. 56, pp. 1347 –1354, Aug. 2007.
[56] S. Ors, F. Gurkaynak, E. Oswald, and B. Preneel, “Power-analysis attack on
an ASIC AES implementation,” in International Conference on Information
Technology: Coding and Computing, vol. 2, pp. 546 – 552, Apr. 2004.
[57] Y. Han, X. Zou, Z. Liu, and Y. Chen, “Improved diﬀerential power analysis
attacks on AES hardware implementations,” in International Conference on
Wireless Communications, Networking and Mobile Computing, pp. 2230 –2233,
Sep. 2007.
[58] P. Kocher, “Design and validation strategies for obtaining assurance in coun-
termeasures to power analysis and related attacks,” in Proceedings of the NIST
Physical Security Workshop, 2005.
[59] A. Bogdanov, “Multiple-diﬀerential side-channel collision attacks on AES,” in
Cryptographic Hardware and Embedded Systems (CHES), Washington, D.C.,
USA, August, pp. 30–44, 2008.
[60] M. Alioto, L. Giancane, G. Scotti, and A. Triﬁletti, “Leakage power analysis
attacks: A novel class of attacks to nanometer cryptographic circuits,” Circuits
and Systems I: Regular Papers, IEEE Transactions on, vol. 57, pp. 355 –367,
feb. 2010.
[61] J. Wu, Y.-B. Kim, and M. Choi, “Low-power side-channel attack-resistant asyn-
chronous S-box design for AES cryptosystems,” in Proceedings of the 20th Sym-
posium on Great Lakes Symposium on VLSI, pp. 459–464, 2010.
[62] K. Tiri and I. Verbauwhede, “Securing encryption algorithms against DPA at
the logic level: Next generation smart card technology,” in Workshop on Cryp-
tographic Hardware and Embedded Systems (CHES), pp. 125–136, 2003.

76
[63] D. Sokolov, J. P. Murphy, A. Bystrov, and A. Yakovlev, “Improving the security
of dual-rail circuits,” in Workshop on Cryptographic Hardware and Embedded
Systems(CHES), pp. 282–297, 2004.
[64] K. Tiri and I. Verbauwhede, “A logic level design methodology for a secure DPA
resistant ASIC or FPGA implementation,” in Design, Automation and Test in
Europe Conference and Exhibition, vol. 1, pp. 246–251, Feb. 2004.
[65] S. Yang, W. Wolf, N. Vijaykrishnan, D. N. Serpanos, and Y. Xie, “Power at-
tack resistant cryptosystem design: A dynamic voltage and frequency switching
approach,” in Proceedings of the conference on Design, Automation and Test in
Europe, pp. 64–69, 2005.
[66] J. Golic and R. Menicocci, “Universal masking on logic gate level,” Electronics
Letters, vol. 40, pp. 526 – 528, Apr. 2004.
[67] C. Gebotys, “A table masking countermeasure for low-energy secure embedded
systems,” IEEE Transactions on Very Large Scale Integration (VLSI) Systems,
vol. 14, pp. 740 –753, july 2006.
[68] J.-S. Coron, “Resistance against diﬀerential power analysis for elliptic curve
cryptosystems,” Cryptographic Hardware and Embedded Systems, vol. 1717,
pp. 725–726, 1999.
[69] D. Suzuki, M. Saeki, and T. Ichikawa, “Random switching logic: A counter-
measure against DPA based on transition probability,” tech. rep., International
Association for Crpyotologic Research (IACR) EPrint Archive, 2004.
[70] A. Razaﬁndraibe, M. Robert, and P. Maurine, “Analysis and improvement of
dual rail logic as a countermeasure against DPA,” in Integrated Circuit and
System Design. Power and Timing Modeling, Optimization and Simulation,
vol. 4644, pp. 340–351, 2007.
[71] S. Mangard, “Masked dual-rail pre-charge logic: DPA-resistance without routing
constraints,” in Workshop on Cryptographic Hardware and Embedded Systems
(CHES), pp. 172–186, 2005.
[72] T. Popp, M. Kirschbaum, T. Zeﬀerer, and S. Mangard, “Evaluation of the
masked logic style MDPL on a prototype chip,” in Workshop on Cryptographic
Hardware and Embedded Systems (CHES), pp. 81–94, 2007.
[73] T. Popp, M. Kirschbaum, and S. Mangard, “Practical attacks on masked hard-
ware,” in The Cryptographers’ Track at the RSA Conference on Topics in Cryp-
tology, pp. 211–225, 2009.
[74] M. Ahn and H. Lee, “Experiments and hardware countermeasures on power
analysis attacks,” in Computational Science and Its Applications (ICCSA),
vol. 3982, pp. 48–53, 2006.

77
[75] K. J. Kulikowski, M. Su, A. Smirnov, A. Taubin, M. G. Karpovsky, and D. Mac-
Donald, “Delay insensitive encoding and power analysis: A balancing act,” in
Proceedings of the 11th IEEE International Symposium on Asynchronous Cir-
cuits and Systems (ASYNC), pp. 116–125, 2005.
[76] F. Gurkaynak, S. Oetiker, H. Kaeslin, N. Felber, and W. Fichtner, “Improving
DPA security by using globally-asynchronous locally-synchronous systems,” in
Proceedings of the 31st European Solid-State Circuits Conference, pp. 407 – 410,
Sept. 2005.
[77] S. Moore, R. Anderson, P. Cunningham, R. Mullins, and G. Taylor, “Improving
smart card security using self-timed circuits,” in Proceedings of the 8th Interna-
tional Symposium on Asynchronous Circuits and Systems, pp. 211–218, 2002.
[78] S. Moore, R. Anderson, R. Mullins, G. Taylor, and J. J. A. Fournier, “Bal-
anced self-checking asynchronous logic for smart card applications,” Journal of
Microprocessors and Microsystems, vol. 27, pp. 421–430, 2003.
[79] D. Sokolov, J. Murphy, A. Bystrov, and A. Yakovlev, “Design and analysis of
dual-rail circuits for security applications,” IEEE Transactions on Computers,
vol. 54, pp. 449–460, April 2005.
[80] V. Satagopan, B. Bhaskaran, A. Singh, and S. C. Smith, “Automated energy
calculation and estimation for delay-insensitive digital circuits,” Microelectron
Journal, vol. 38, pp. 1095–1107, October 2007.
[81] A. Bailey, A. A. Zahrani, G. Fu, J. Di, and S. C. Smith, “Multi-threshold asyn-
chronous circuit design for ultra-low power,” Journal of Low Power Electronics,
vol. 4, Dec.
[82] J. Wu, Y. Shi, and M. Choi, “FPGA-based measurement and evalution of power
analysis attack resistant asynchronous S-Box,” in IEEE Instrumentation and
Measurement Technology Conference (I2MTC), pp. 1–6, May. 2011.
[83] J. Wolkerstorfer, E. Oswald, and M. Lamberger, “An ASIC implementation of
the AES S-Boxes,” in Proceedings of the The Cryptographer’s Track at the RSA
Conference on Topics in Cryptology, pp. 67–78, 2002.
[84] NIST, “Advanced encryption standard (AES),FIPS PUBS 197, national insti-
tute of standards and technology,” in NIST, 2001.
[85] L. Medina, R. de Jesus Romero-Troncoso, E. Cabal-Yepez, J. de Jesus Rangel-
Magdaleno, and J. Millan-Almaraz, “FPGA-based multiple-channel vibration
analyzer for industrial applications in induction motor failure detection,” IEEE
Transactions on Instrumentation and Measurement, vol. 59, pp. 63 –72, Jan.
2010.

78
[86] J. Hunsinger and B. Serio, “FPGA implementation of a digital sequential phase-
shift stroboscope for in-plane vibration measurements with subpixel accuracy,”
IEEE Transactions on Instrumentation and Measurement, vol. 57, pp. 2005
–2011, Sept. 2008.
[87] R. Jevtic and C. Carreras, “Power measurement methodology for FPGA de-
vices,” IEEE Transactions on Instrumentation and Measurement, vol. 60,
pp. 237 –247, Jan. 2011.
[88] R. C. for Information Security, “Side-channel attack standard evaluation board
SASEBO-GII speciﬁcation,” September 2009.
[89] P. Kocher, J. Jaﬀe, and B. Jun, “Diﬀerential power analysis,” pp. 388–397,
Springer-Verlag, 1999.
[90] T. Katashita, A. Satoh, T. Sugawara, N. Homma, and T. Aoki, “Enhanced cor-
relation power analysis using key screening technique,” in International Con-
ference on Reconﬁgurable Computing and FPGAs, pp. 403 –408, Dec. 2008.
[91] S. Guilley, L. Sauvage, F. Flament, V.-N. Vong, P. Hoogvorst, and R. Pacalet,
“Evaluation of power constant dual-rail logics countermeasures against DPA
with design time security metrics,” IEEE Transactions on Computers, vol. 59,
pp. 1250 –1263, Sept 2010.
[92] H. Li, K. Wu, B. Peng, Y. Zhang, X. Zheng, and F. Yu, “Enhanced correlation
power analysis attack on smart card,” in International Conference for Young
Computer Scientists, pp. 2143 –2148, Nov. 2008.
[93] S. Mangard, E. Oswald, and T. Popp, Power Analysis Attacks-Revealing the
Secrets of Smart Cards. Springer, March, 2007.
[94] N. Homma, S. Nagashima, T. Sugawara, T. Aoki, and A. Satoh, “A high-
resolution phase-based waveform matching and its application to side-channel
attacks,” IEICE Transactions on Fundamentals of Electronics, Communica-
tions and Computer Sciences, vol. E91-A, pp. 193–202, January 2008.
[95] H. Alstad and S. Aunet, “Improving circuit security against power analysis
attacks with subthreshold operation,” in IEEE Workshop on Design and Diag-
nostics of Electronic Circuits and Systems (DDECS), pp. 1–2, April 2008.
[96] W. Qian and M. Riedel, “The synthesis of robust polynomial arithmetic with
stochastic logic,” in 45th ACM/IEEE Design Automation Conference, pp. 648
–653, June 2008.
[97] W. Qian, X. Li, M. Riedel, K. Bazargan, and D. Lilja, “An architecture for fault-
tolerant computation with stochastic logic,” IEEE Transactions on Computers,
vol. 60, pp. 93 –105, Jan. 2011.

79
[98] S. Toral, J. Quero, and L. Franquelo, “Stochastic pulse coded arithmetic,”
in The 2000 IEEE International Symposium on Circuits and Systems, vol. 1,
pp. 599 –602, 2000.
[99] B. Brown and H. Card, “Stochastic neural computation. i. computational ele-
ments,” IEEE Transactions on Computers, vol. 50, pp. 891 –905, Sep 2001.
[100] W. Qian, M. Riedel, H. Zhou, and J. Bruck, “Transforming probabilities with
combinational logic,” IEEE Transactions on Computer-Aided Design of Inte-
grated Circuits and Systems, vol. 30, pp. 1279 –1292, Sep. 2011.
[101] B. J. Weikang Qian and M. Riedel, “International journal of nanotechnology
and molecular computation (ijnmc),” The Synthesis of Stochastic Circuits for
Nanoscale Computation, pp. 39 –57, April. 2009.
[102] W. Wijesinghe, M. Jayananda, and D. Sonnadara, “Hardware implementation
of random number generators,” in Proceedings of the Technical Session of In-
stitute of Physics, vol. 1, pp. 25–36, 2006.
[103] J. Wu, Y. Shi, and M. Choi, “Measurement and evaluation of power analysis
attacks on asynchronous S-Box,” in IEEE Transactions on Instrumentation and
Measurement, Dec. 2012.
[104] M. Dong and L. Zhong, “Logic synthesis with nanowire crossbar: reality check
and standard cell-based integration,” in Proceedings of the conference on Design
Automation and Test, DATE ’08, pp. 268–271, ACM, 2008.
[105] W. Lu and C. M. Lieber, “Nanoelectronics from the bottom up,” Nature Ma-
terials, vol. 6, pp. 841–850, Nov. 2007.
[106] P. Lu, Wei. Xie and C. M. Lieber, “Nanowire transistor performance limits and
applications,” IEEE transactions on electron devices, vol. 55, pp. 2859–2876,
Nov. 2008.
[107] L. Feng, Wayne. Cheng and W. Lu, “Esaki tunnel diodes based on vertical si-ge
nanowire heterojunctions,” Applied Physics Letters, vol. 99, April 2012.
[108] A. Mehonic, S. Cueﬀ, M. Wojdak, S. Hudziak, O. Jambois, C. Labbe, B. Gar-
rido, R. Rizk, and A. Kenyon, “Resistive switching in silicon suboxide ﬁlms,”
Journal of Applied Physics, vol. 111, April 2012.
[109] C. Sui, J. Wu, Y. Shi, Y.-B. Kim, and M. Choi, “Random dynamic voltage
scaling design to enhance security of NCL S-Box,” in Internatinal Midwest
Symposium on Circuits and Systems, 2011.

80
VITA
Jun Wu was born in Lushan, Jiangxi, China. She received her B.S. degrees in
Electrical Engineering from Beijing University of Technology, Beijing, China in 2006.
She joined Coolsand Technologies in May 2006 as an ASIC Veriﬁcation Engineer re-
sponsible for verifying multimedia chips for mobile phones. After two years working
in Coolsand Technologies, she started her Ph.D. program in Computer Engineering
at Missouri University of Science and Technology in August 2008. She worked as
a research assistant and a teaching assistant. In December 2012, she received her
Ph.D. degree in Computer Engineering from the Department of Electrical and Com-
puter Engineering, Missouri University of Science and Technology (Missouri S&T),
Rolla, MO, USA. Upon graduation, she will be a hardware engineer at Algotochip
Corporation, Sunnyvale, CA.

