15
Theorem-proving support in programming
language semantics
Yves Bertot
INRIA Sophia-Antipolis M´editerran´ee
This paper is dedicated to the memory of Gilles Kahn, my thesis advisor,
my mentor, my friend.
Abstract
We describe how the formal description of a programming language
can be encoded in the Coq theorem prover. Four aspects are covered:
Natural semantics (as advocated by Gilles Kahn), axiomatic semantics,
denotational semantics, and abstract interpretation. We show that most
of these aspects have an executable counterpart and describe how this
can be used to support proofs about programs.
15.1 Introduction
Nipkow demonstrated in [25] that theorem provers could be used to
formalize many aspects of programming language semantics. In this
paper, we want to push the experiment further to show that this formal-
ization eﬀort also has a practical outcome, in that it makes it possible to
integrate programming tools inside theorem provers in an uniform way.
We re-visit the study of operational, denotational semantics, axiomatic
semantics, and weakest pre-condiction calculus as already studied by
Nipkow and we add a small example of a static analysis tool based on
abstract interpretation.
To integrate the programming tools inside the theorem prover we rely
on the possibility to execute the algorithms after they have been formally
described and proved correct, a technique known as reﬂection [3, 11].
We also implemented a parser, so that the theorem prover can be used
as a playground to experiment on sample programs. We performed this
From Semantics to Computer Science Essays in Honour of Gilles Kahn,
eds Yves
Bertot, G´erard Huet, Jean-Jacques L´evy and Gordon Plotkin. Published by Cambridge
University Press.
c
⃝Cambridge University Press 2009.
337
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

338
Y. Bertot
experiment using the Coq system [17, 8]. The tools that are formally
described can also be “extracted” outside the proof environment, so that
they become stand alone programs [23].
The desire to use computers to verify proofs about programming
language semantics was probably one of the main incentives for the
design of modern interactive theorem provers. The LCF system was a
pioneer in this direction. The theory of programming languages was so
grounded in basic mathematics that a tool such as LCF was quickly
recognized as a tool in which mathematical reasoning can also be
simulated and proofs can be veriﬁed by decomposing them in sound
basic logical steps. LCF started a large family of theorem-proving tools,
among which HOL [19] and Isabelle [26] have achieved an outstanding
international recognition. Nipkow’s experiments were conducted using
Isabelle.
In the family of theorem-proving tools, there are two large sub-
families: there are the direct descendants of the LCF system [20], which
rely on simply-typed λ-calculus and the axioms of higher-order logic
to provide foundations for a large portion of mathematics; on the
other hand, there are systems descending from de Bruijn’s Automath
system and Martin-L¨of’s theory of types, where propositions are directly
represented as types, “non-simple” types, namely dependent types,
can be used to represent quantiﬁed statements, and typed functions
are directly used to represent proofs. In systems of the LCF family,
typed λ-terms are used in the representation of logical statements and
proofs are objects of another nature. In systems of the latter family,
usually called type theory-based theorem-proving tools, typed λ-terms
are used both in the representation of logical statements and in the
representation of proofs. Well-known members of the type theory-based
family of theorem-proving tools are Nuprl [13], Agda [14], and Coq.
The fact that typed λ-terms are used both to represent logical
statements and proofs in type theory-based theorem-proving tools has
the consequence that computation in the typed λ-calculus plays a
central role, because verifying that a theorem is applied to an argument
of the right form may require an arbitrary large computation in these
systems. By contrast, computation plays only a secondary role in LCF-
style theorem-proving tools and facilities to execute programs eﬃciently
to support proofs was only added recently [4].
With structural operational semantics and natural semantics, Gordon
Plotkin and Gilles Kahn provided systematic approaches to describing
programming languages relying mostly on the basic concepts of inductive
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 339
types and inductive propositions. Execution states are represented as
environments, in other words lists of pairs binding a variable name and
a value. Programs themselves can also be represented as an inductive
data-type, following the tradition of abstract syntax trees, a streamlined
form of parsing trees. Execution of instructions can then be described as
inductive propositions, where executing an instruction is described as a
ternary relation between an input environment, an instruction, and an
output value. The execution of each program construct is described by
composing “smaller” executions of this construct or its sub-components.
Another approach to semantics is to express that a program links
properties of inputs with properties of outputs. In other words, one
provides a logical system to describe under which condition on a
program’s input a given condition on the program’s output can be
guaranteed (as long as the program terminates). This style of description
is known as axiomatic semantics and was proposed by Hoare [21]. We
can again use an inductive type to represent properties of input and
output of programs. We will show that axiomatic semantics can easily be
described using inductive properties and recursive functions and we will
prove the consistency with the initial operational semantics. Axiomatic
semantics also supports an algorithmic presentation, known as a veriﬁ-
cation condition generator for the weakest pre-condition calculus as
advocated by Dijkstra [16]. Again, we provide an implementation of this
generator, a proof that it is correct, and examples of using this through
reﬂection to establish properties of sample programs.
The next style of semantic description that we will study will be
the style known as denotational semantics or domain theory, actually
the style that motivated the ﬁrst implementation of the LCF system.
Here, the semantics of the instructions is described as a collection of
partial functions from a type of inputs to a type of outputs. The kind of
functions that are commonly used in type-theory-based theorem-proving
tools are not directly suited for this approach, for fundamental reasons.
We will show which axioms of classical logical can be used to provide
a simple encoding of the partial functions we need. However, using
these axioms precludes computing inside the theorem prover, so that
the function we obtain is executable only after extraction outside the
theorem prover. This approach can still be used to derive an interpreter,
a tool to execute programs, with a guarantee that the interpreter respects
the reference operational semantics.
The last aspect is an approach to the static analysis of programs
known as abstract interpretation. While other approaches aim at giving
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

340
Y. Bertot
a completely precise understanding of what happens in programs,
abstract interpretation focuses on hiding enough details so that the
information that is obtained from the analysis is easier to manage and
more importantly the computations to perform the analysis can be
performed automatically with guaranteed termination.
These experiments are available as a Coq contribution [7].
15.1.1 Related work
The main reference we used on programming language semantics is
Winskel’s text book [32].
Many publications have been provided to show that these various
aspects of programming language could be handled in theorem provers.
Our ﬁrst example is [9] where we described the correctness of a program
transformation tool with respect to the language’s operational semantics.
This work was performed in the context of the Centaur system [10]
where semantic descriptions could be executed with the help of a prolog
interpreter or reasoned about using a translation to the Coq theorem
prover [29]. The most impressive experiment is described in [25], who
approximately formalizes the ﬁrst 100 pages of Winskel’s book, thus
including a few more proofs around the relations between operational
semantics, axiomatic semantics, and denotational semantics than we
describe here. The diﬀerence between our work and Nipkow’s is that we
rely more on reﬂection and make a few diﬀerent choices, like the choice
to provide a minimal syntax for assertions, while Nipkow directly uses
meta-level logical formulas and thus avoid the need to describe substi-
tution. On the other hand, our choice of an abstract syntax for assertions
makes it possible to integrate our veriﬁcation generator with a parser,
thus providing a more user-friendly approach to annotated programs.
The work on denotational semantics is a transposition and a reduction
of the work on domain theory that could already be described formally
in the framework of logic of computable functions, in Isabelle [24].
The study of interactions between abstract interpretation and theorem
provers is the object of more recent work. Intermediate approaches use
abstract interpreters to generate proofs of correctness of programs in
axiomatics semantics as in [12]. Pichardie [27] provides a more advanced
formal study than ours, however our approach has the advantage of being
based on natural semantics: thanks to this, recursion can be based on
the structure of programs, while his approach imposes using the style of
well-founded induction, which makes it ill-suited for reﬂection.
Application domains for theorem prover-aware formal semantics of
programming languages abound. Nipkow and his team [31], Jacobs
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 341
and his team [30], and Barthe and his team [2, 6] showed the beneﬁts
there could be in describing the Java programming language and the
Java virtual machine, to verify soundness properties of the byte-code
veriﬁer and apply this to the guarantees of the security that the Java
language and its Smartcard-aware oﬀspring, JavaCard. More recent
work by Leroy and his team show that this work can be extended to
the formalization of eﬃcient compilers. The interest is also spreading
in the community of researchers working on the design of programming
language, as witnessed by the success of the PoplMark challenge [1].
15.2 Concrete and abstract syntax
We consider a while loop programing language with simple arithmetic
expressions: it is the Imp language of [25] without the conditional
instruction. The language has been trimmed to a bare skeleton, but
still retains the property of being Turing complete. We will use ρ as
meta-variables for variable declarations (we will also often use the word
environment), e for expressions, b for boolean expressions, and i for
instructions. We use an inﬁnite denumerable set of variable names
whose elements are written x, y, x1, . . . and we use n, n1, n′ to represent
integers. The syntactic categories are deﬁned as follows:
ρ:: = (x, n) · ρ|∅
e:: = n | x | e+e
b:: = e <e
i:: = skip | x: =e | i;i | while b do i done
The intended meaning of most of these constructs should be obvious.
In the theorem prover, we use inductive types to describe these
syntactic categories. The convention that numbers are expressions needs
to be modiﬁed: there is a constructor anum in the type of arithmetic
expression aexpr that maps a number to the corresponding expression.
Similarly, variable names are transformed into arithmetic expressions
and assignments just use variable names as ﬁrst components.
Inductive aexpr : Type :=
avar (s : string) | anum (n : Z) | aplus (e1 e2 :aexpr).
Inductive bexpr : Type := blt (e1 e2 : aexpr).
Inductive instr : Type :=
assign (s: string)(e:aexpr) | sequence (i1 i2:instr)
| while (b:bexpr)(i:instr) | skip.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

342
Y. Bertot
15.3 Operational semantics
15.3.1 Evaluation and environment update
15.3.1.1 Inference rules
We will describe the evaluation of expressions using judgments of the
form ρ ⊢e →v or ρ ⊢b →v (with a straight arrow). These judgments
should be read as in environment ρ, the arithmetic expression e (resp.
the expression b) has the value v. The value v is an integer or a boolean
value depending on the kind of expression being evaluated. The rules
describing evaluation are as follows:
ρ ⊢n →n
(x, n) · ρ ⊢x →n
ρ ⊢x →n
x ̸= y
(y, n′) · ρ ⊢x →n
ρ ⊢e1 →n1
ρ ⊢e2 →n2
ρ ⊢e1+e2 →n1 + n2
ρ ⊢e1 →n1
ρ ⊢e2 →n2
n1 < n2
ρ ⊢e1<e2 →true
ρ ⊢e1 →n1
ρ ⊢e2 →n2
n2 ≤n1
ρ ⊢e1<e2 →false
During the execution of instructions, we will regularly need describing
the modiﬁcation of an environment, so that the value associated to a
variable is modiﬁed. We use judgments of the form ρ ⊢x, n &→ρ′, which
should be read as x has a value in ρ and ρ′ and the value for x in ρ′ is
n; every other variable that has a value in ρ has the same value in ρ′.
This is simply described using two inference rules, in the same spirit as
rules to evaluate variables.
15.3.1.2 Theorem prover encoding
Judgments of the form · ⊢· →· are represented by three-argument
inductive predicates named aeval and beval. We need to have two
predicates to account for the fact that the same judgment is actually
used to describe the evaluations of expressions of two diﬀerent types. The
encoding of premises is quite straightforward using nested implications,
and we add universal quantiﬁcations for every variable that occurs in
the inference rules. All inference rules for a given judgment are grouped
in a single inductive deﬁnition. This makes it possible to express that
the meaning of the judgment · ⊢· →· is expressed by these inferences
and only these inferences rules.
Environments are encoded as lists of pairs, so that the empty
environment is encoded as nil and the environment (x, n) · ρ is (x,n)::r
when r is the encoding of ρ.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 343
Deﬁnition env := list(string*Z).
Inductive aeval : env →aexpr →Z →Prop :=
ae int : ∀r n, aeval r (anum n) n
| ae var1 : ∀r x n, aeval ((x,n)::r) (avar x) n
| ae var2 : ∀r x y v v’ , x ̸= y →aeval r (avar x) v →aeval ((y,v’)::r) (avar x) v
| ae plus : ∀r e1 e2 v1 v2, aeval r e1 v1 →aeval r e2 v2 →
aeval r (aplus e1 e2) (v1 + v2).
Inductive beval : env →bexpr →bool →Prop :=
| be lt1 : ∀r e1 e2 v1 v2, aeval r e1 v1 →aeval r e2 v2 →v1 < v2 →
beval r (blt e1 e2) true
| be lt2 : ∀r e1 e2 v1 v2, aeval r e1 v1 →aeval r e2 v2 →v2 ≤v1 →
beval r (blt e1 e2) false.
The four place judgment · ⊢·, · &→· is also encoded as an inductive
deﬁnition for a predicate named update.
Induction principles are automatically generated for these declarations
of inductive predicates. These induction principles are instrumental for
the proofs presented later in the paper.
15.3.2 Functional encoding
The judgment ρ ⊢e →n actually describes a partial function. To
describe a partial function, we use the type constructor option, which
deﬁnes a new type with an extra element None.
Inductive option (A:Type) : Type := Some : A →option A | None : option A.
We describe the evaluation function in two steps with lookup and af,
which return values in option Z. When computing additions, we need
to compose partial functions. For this, we deﬁne a bind function that
takes care of undeﬁned values in intermediate results. The pre-deﬁned
function string dec is used to compare two strings.
Fixpoint lookup (r:env)(s:string){struct r} : option Z :=
match r with
nil ⇒None | (a,b)::tl ⇒if (string dec a s) then Some b else lookup tl s
end.
Deﬁnition bind (A B:Type)(v:option A)(f:A→option B) : option B :=
match v with Some x ⇒f x | None ⇒None end.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

344
Y. Bertot
Fixpoint af (r:env)(e:aexpr) {struct e} : option Z :=
match e with
avar index ⇒lookup r index
| anum n ⇒Some n
| aplus e1 e2 ⇒bind (af r e1) (fun v1 ⇒bind (af r e2) (fun v2 ⇒Some (v1+v2)))
end.
We can deﬁne functions bf to evaluate boolean expressions and uf to
compute updated environments in a similar way.
We use two functions to describe the evaluation of arithmetic
expressions, the Fixpoint construct imposes that one states which
argument is decreasing at each call: for lookup it is the environment and
for af it is the expression.
With aeval and af, we have two encodings of the same concept. We
show that these encodings are equivalent with the following lemmas.
Lemma lookup aeval : ∀r s v, lookup r s = Some v →aeval r (avar s) v.
Lemma af eval : ∀r e v, af r e = Some v →aeval r e v.
Lemma aeval f : ∀r e n, aeval r e n →af r e = Some n.
The proof of the ﬁrst lemma is done by induction on the structure of
r, the proof of the second lemma is done by induction on e, while the
proof of the third lemma is done by induction on the structure of the
proof for aeval (using the induction principle, which is generated when
the inductive predicate is declared). Using simple proof commands, each
of these proofs is less than ten lines long.
15.3.3 Natural semantics
With natural semantics [22], Gilles Kahn proposed that one should
rely on judgments expressing the execution of program fragments until
they terminate. The same style was also called big-step semantics. The
main advantage of this description style is that it supports very concise
descriptions for sequential languages. For our little language with four
instructions, we only need ﬁve inference rules.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 345
We rely on judgments of the form ρ ⊢i ; ρ′ (with a twisted
arrow). These judgments should be read as executing i from the initial
environment ρ terminates and yields the new environment ρ′.
ρ ⊢skip ; ρ
ρ ⊢e →n
ρ ⊢x, n &→ρ′
ρ ⊢x: =e ; ρ′
ρ ⊢i1 ; ρ′
ρ′ ⊢i2 ; ρ′′
ρ ⊢i1;i2 ; ρ′′
ρ ⊢b →false
ρ ⊢while b do i done ; ρ
ρ ⊢b →true
ρ ⊢i ; ρ′
ρ′ ⊢while b do i done ; ρ′′
ρ ⊢while b do i done ; ρ′′
Because it is described using collections of rules, the judgment · ⊢· ; ·
can be described with an inductive predicate exactly like the judgments
for evaluation and update. We use the name exec for this judgment.
It is also possible to describe the programming language as a transition
semantics in which each transition maps the pair of an environment and
an instruction to a new environment and instruction. The transition
only describes an elementary step of execution and the new instruction
describes what remains to be done. This style is called structural
operational semantics or small step semantics and was advocated by
Plotkin [28]. We also developed a small-step description of the language
and proved its consistency with the natural semantics, but we will not
describe it in this paper, for lack of space.
As with the judgment ρ ⊢e →v, the judgment ρ ⊢i ; ρ′
actually describes a partial function. However, this partial function
cannot be described as a structural recursive function as we did when
deﬁning the functions lookup and af. For while loops, such a function
would present a recursive call where neither the environment nor the
instruction argument would be a sub-structure of the corresponding
initial argument. This failure also relates to the fact that the termination
of programs is undecidable for this kind of language, while structural
recursion would provide a terminating tool to compute whether
programs terminate. In the later section on denotational semantics, we
will discuss ways to encode a form of recursion that is powerful enough
to describe the semantics as a recursive function.
15.4 Axiomatic semantics
We study now the encoding of axiomatic semantics as proposed by Hoare
[21] and the weakest pre-condition calculus as proposed by Dijkstra [16].
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

346
Y. Bertot
The principle of this semantic approach is to consider properties that are
satisﬁed by the variables of the program before and after the execution.
15.4.1 The semantic rules
To describe this approach, we use judgments of the following form:
{P}i{Q}. This should be read as if P is satisﬁed before executing i
and executing i terminates, then Q is guaranteed to be satisﬁed after
executing i. These judgments are also called Hoare triples.
There are two key aspects in axiomatic semantics: ﬁrst the behavior
of assignment is explained by substituting variables with arithmetic
expressions; second the behavior of control operators is explained by
isolating properties that are independent from the choice made in the
control operator and properties that can be deduced from this choice.
{P}skip{P}
{P}i1{Q}
{Q}i2{R}
{P}i1;i2{R}
{P[x ←e]}x: =e{P}
{b ∧P}i{P}
{P}while b do i done{¬b ∧P}
P ⇒P1
{P1}i{Q1}
Q1 ⇒Q
{P}i{Q}
In the rule for while loops, the property P corresponds to something
that should be veriﬁed whether the loop body is executed 0, 1, or many
times: it is independent from the choice made in the control operator.
However, when the loop terminates, one knows that the test must have
failed, this is why the output property for the loop contains ¬b. Also, P
should be preserved through execution of the loop body, but only when
the test is satisﬁed, this is why the premise has b in the left-hand side
assertion.
We call the ﬁrst four rules structural rules. The last rule, known as the
consequence rule, makes it possible to include logical reasoning about
the properties. To prove the two premises that are implications, it is
necessary to master the actual meaning of the properties, conjunction,
and negation.
15.4.2 Theorem-prover encoding
The ﬁrst step is to deﬁne a data-type for assertions. Again, we keep
things minimal. Obviously, the inference rules require that the language
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 347
of assertions contain at least conjunctions, negations, and tests from the
language’s boolean expressions. We also include the possibility to have
abitrary predicates on arithmetic expressions, represented by a name
given as a string.
Inductive assert : Type :=
a b (b: bexpr) | a not (a: assert) | a conj (a a’: assert)
| pred (s: string)(l: int aexpr).
Inductive condition : Type := c imp (a a’:assert).
The type condition contains the implications that used for the
consequence rule.
For variables that occur inside arithmetic expressions, we use
valuation functions of type string→Z instead of environments and we
deﬁne a new function af’ (respectively bf’, lf’) to compute the value
of an arithmetic expression (respectively boolean expressions, lists of
arithmetic expressions) for a given valuation. The function af’ is more
practical to use and deﬁne than af because it is total, while af was
partial.
Fixpoint af’ (g:string→Z)(e:aexpr) {struct e}: Z :=
match e with avar s ⇒g s | anum n ⇒n | aplus e1 e2 ⇒af’ g e1 + af’ g e2 end.
To give a meaning to assertion predicates, we use lists of pairs associating
names and Coq predicates on lists of integers as predicate environments
and we have a function f p to map an environment and a string to a
predicate on integers.
With all these functions, we can interpret assertions as propositional
values using a function i a and conditions using a function i c.
Deﬁnition p env := list(string*(list Z→Prop)).
Fixpoint i a (m: p env)(g:string→Z)(a:assert) : Prop :=
match a with
a b e ⇒bf’ g e
| a not a ⇒˜ i a m g a
| pred p l ⇒f p m p (lf’ g l) | a conj a1 a2 ⇒i a m g a1 ∧i a m g a2
end.
Deﬁnition i c (m:p env)(g:string→Z)(c:condition) :=
match c with c imp a1 a2 ⇒i a m g a1 →i a m g a2 end.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

348
Y. Bertot
The validity of conditions can be expressed for a given predicate
environment by saying that their interpretation should hold for any
valuation.
Deﬁnition valid (m:p env)(c:condition) := ∀g, i c m g c.
We
also
deﬁne
substitution
for
arithmetic
expressions,
boolean
expressions, and so on, each time traversing structures. The function at
the level of assertions is called a subst. We can then deﬁne the axiomatic
semantics.
Inductive ax sem (m :p env): assert →instr →assert →Prop:=
ax1 : ∀P, ax sem m P skip P
| ax2 : ∀P x e, ax sem m (a subst P x e) (assign x e) P
| ax3 : ∀P Q R i1 i2, ax sem m P i1 Q →ax sem m Q i2 R →
ax sem m P (sequence i1 i2) R
| ax4 : ∀P b i, ax sem m (a conj (a b b) P) i P →
ax sem m P (while b i) (a conj (a not (a b b)) P)
| ax5 : ∀P P’ Q’ Q i,
valid m (c imp P P’) →ax sem m P’ i Q’ →valid m (c imp Q’ Q) →
ax sem m P i Q.
15.4.3 Proving the correctness
We want to certify that the properties of programs that we can prove
using axiomatic semantics hold for actual executions of programs, as
described by the operational semantics. We ﬁrst deﬁne a mapping from
the environments used in operational semantics to the valuations used
in the axiomatic semantics. This mapping is noted r@g; for a variable
x it returns the value of x in environment r when it is deﬁned and g x
otherwise. We express the correctness of axiomatic semantics by stating
that if “exec r i r′” and “ax sem P i Q” hold, if P holds in the initial
environment, Q should hold in the ﬁnal environment r.
Theorem ax sem sound : ∀g m i P Q r r’, ax sem m P i Q →exec r i r’ →
i a m (r@g) P →i a m (r’@g) Q.
This statement is best proved with two nested inductions, starting with
an induction on the ax sem statement. A key lemma shows that updating
an environment for a variable and a value, as performed in operational
semantics, and substituting an arithmetic expression for a variable, as
performed in axiomatic semantics, are consistent:
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 349
Lemma a subst correct : forall a r1 e v m g r2 x,
aeval r1 e v →s update r1 x v r2 →
(i a m (r1@g) (a subst a x e) ↔i a m (r2@g) a).
15.4.4 The weakest pre-condition calculus
The structure of a proof for a Hoare triple {P}i{Q} can mostly be
deduced from the structure of the instruction i, but the assertions in
loop invariants and in consequence rules cannot be found automatically.
Dijkstra proposed to annotate programs with the missing formulas and
to gather the implications used in consequence steps as a collection of
conditions to be proved on the side. The result is a veriﬁcation condition
generator which takes an annotated program as input and returns a list
of conditions. We will now describe such a generator, called vcg.
We need to deﬁne a new data-type for these annotated programs.
Inductive a instr : Type :=
prec (a:assert)(i:a instr) | a skip | a assign (s:string)(e:aexpr)
| a sequence (i1 i2:a instr) | a while (b:bexpr)(a:assert)(i:a instr).
The prec constructor is used to assert properties at any point in the
program. The while statement has an extra ﬁeld a for the invariant.
We also provide a projection that maps annotated instructions to
bare instructions by forgetting the assumptions, so that we can use an
annotated instruction like plain instructions.
There are two main steps. The ﬁrst step is to understand what is the
pre-condition for an annotated instruction and a given post-condition.
For the a while and prec constructs, the pre-condition is simply the one
declared in the corresponding annotation, for the other constructs, the
pre-condition has to be computed using substitution and composition.
Fixpoint pc (i:a instr)(a:assert) {struct i} : assert :=
match i with
prec a’ i ⇒a’
| a while b a’ i ⇒a’
| a skip ⇒a
| a assign x e ⇒a subst a x e
| a sequence i1 i2 ⇒pc i1 (pc i2 a)
end.
The second step is to gather all the conditions that would appear in a
minimal axiomatic semantics proof for the given post-condition and the
pre-condition computed in the ﬁrst step using pc.
Fixpoint vcg (i:a instr)(post : assert) {struct i} : list condition :=
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

350
Y. Bertot
match i with
a skip ⇒nil
| a assign
⇒nil | prec a i ⇒c imp a (pc i post)::vcg i post
| a sequence i1 i2 ⇒vcg i2 post ++ vcg i1 (pc i2 post)
| a while e a i ⇒
c imp (a conj (a not (a b e)) a) post
:: c imp (a conj (a b e) a) (pc i a) :: vcg i a
end.
We proved a correctness statement, which expresses that the validity
of all the generated conditions suﬃces for the Hoare triple to hold.
This proof is done by induction on the instruction. We can then obtain
a statement that relates the condition generator and the operational
semantics.
Theorem vcg sound :
∀m i A, (valid l m (vcg i A)) →∀g r1 r2, exec r1 i r2 →
i a m (r1@g) (pc i A) →i a m (r2@g) A.
15.4.5 Using the generator in a proof by reﬂection
In this example, we consider the program that adds the n ﬁrst positive
integers and we prove the usual identity about the result. We use a
predicate environment ex m that maps the names le and pp to predicates
on lists of two integers x and y, which hold when x ≤y and 2 × y =
x × (x + 1), respectively. With the help of a parser, we can state our
claim in a concise manner:
Example ex1 : ∀g r2, 0 < n →
exec ((”x”, 0)::(”y”, 0)::(”n”,n)::nil)
(parse ”while x < n do [le(x,n) ∧pp(y,x)] x:=x+1;y:=x+y done”) r2 →
2*(r2@g)”y” = (r2@g)”x”*((r2@g)”x”+1).
The conclusion actually is an instance of the pp predicate, and we apply
the vcg sound theorem, which leads to two requirements. The ﬁrst is that
the veriﬁcation conditions hold:
valid l ex m
(vcg (parse instr’ ”while x < n do [le(x,n) ∧pp(y,x)] x:=x+1;y:=x+y done”)
(parse assert’ ”pp(y,n)”))
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 351
After forcing the computation of the parser and the condition generator,
this leads to the following logical statement:
∀x y n.
(x ̸< n ∧x ≤n ∧2y = x(x + 1) ⇒2 ∗y = n(n + 1))∧
(x < n ∧x ≤n ∧2y = x(x + 1) ⇒x + 1 ≤n∧
2(x + 1 + y) = (x + 1)(x + 2)).
This is easily proved using regular Coq tactics. The second requirement
is that the pre-condition should hold for the initial environment.
0 ≤n ∧2 × 0 = 0 × (0 + 1).
This statement is also proved easily. This example shows that we have
a simple model of tools like Why [18].
15.5 Denotational semantics
In denotational semantics, the aim is to describe the meaning of
instructions as functions. The functions need to be partial, because
some instructions never terminate on some inputs. We already used
partial functions for the functional encoding of expression evaluation.
However, the partial recursive function that we deﬁned were structural,
and therefore guaranteed to terminate. The execution function for
instructions does not ﬁt in this framework and we will ﬁrst deﬁne a
new tool to deﬁne recursive function. Most notably, we will need to use
non-constructive logic for this purpose.
Again the partial functions will be implemented with the option
inductive type, but the None constructor will be used to represent either
that an error occurs or that computation does not terminate.
15.5.1 The ﬁxpoint theorem
The approach described in [32] relies on Tarski’s ﬁxpoint theorem, which
states that every continuous function in a complete partial order with a
minimal element has a least ﬁxpoint and that this ﬁxpoint is obtained
by iterating the function from the minimal element.
Our deﬁnition of complete partial order relies on the notion of chains,
which are monotonic sequences. A partial order is a type with a relation
⊆that is reﬂexive, antisymmetric, and transitive; this partial order
is complete if every chain has a least upper bound. A function f is
continuous if for every chain c with a least upper bound l, the value f(l)
is the least upper bound of the sequence f(cn). Notice that when deﬁning
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

352
Y. Bertot
continuous function in this way, we do not require f to be monotonic;
actually, we prove that every continuous function is monotonic.
The proof of Tarski’s theorem is quite easy to formalize and it can be
formalized using intuitionistic logic, so the plain calculus of constructions
is a satisfactory framework for this.
15.5.2 The complete partial order of partial functions
The main work in applying Tarski’s theorem revolves around proving
that types of partial functions are complete partial orders. A type of
the form option A has the structure of a complete partial order when
choosing as order the relation such that x ⊆y exactly when x = y or
x = None. The element None is the minimal element. Chains have a
ﬁnite co-domain, with at most two elements, the least upper bound of
chains can be proved to exist using the non-constructive excluded-middle
axiom.
Given an arbitrary complete partial order (B, ⊆), the type of functions
of type A →B is a complete partial order for the order deﬁned as
follows:
f ⊆g ⇔∀x, f(x) ⊆g(x).
The proof that this is a complete partial order requires other non-
constructive axioms: extensionality is required to show that the order
is antisymetric and a description operator is required to construct the
least upper bound of a chain of functions. We actually rely on the non-
constructive ϵ operator proposed by Hilbert and already used in HOL or
Isabelle/HOL. This ϵ operator is a function that takes a type T, a proof
that T is inhabited, a predicate on T, and returns a value in T that is
guaranteed to satisfy the predicate when possible.
For a sequence of functions fn (not necessarily a chain), we can deﬁne
a new function f, which maps every x to the value given by the ϵ operator
for the predicate “to be the least upper bound of the sequence fn(x)”.
Now, if it happens that fn is a chain, then each of the sequences fn(x)
is a chain, f(x) is guaranteed to be the least upper bound, and f is the
least upper bound of fn.
In practice, Tarski’s least ﬁxpoint theorem gives us a programming
tool, which we call Tarski ﬁx and a theorem about this tool, which we
call Tarski ﬁx prop. If one wishes to deﬁne a function with a recursive
deﬁnition of the form
f x = e
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 353
such that f appears in e, it suﬃces that we have a theorem th stating
that λf.λx.e is continuous. The function f can then be deﬁned by the
following equation:
f = Tarski ﬁx (λfx.e)
The theorem Tarski ﬁx prop states that f is the least ﬁxed-point of λfx.e.
15.5.3 Deﬁning the semantics
For a while loop of the form while b do i done, such that the semantic
function for i is fi, we want the semantic function to be the function
φb,i such that :
φb,i(ρ) =



ρ
if bf b=false
φb,i(ρ′)
if bf b=true and fi(ρ) = Some ρ′
None
otherwise
This function φb,i is the least ﬁxpoint of the function F phi obtained
by combining a conditional construct, a sequential composition function
(already described using the bind function), and a few constant functions.
We encode F phi and phi as follows:
Deﬁnition ifthenelse (A:Type)(t:option bool)(v w: option A) :=
match t with Some true ⇒v | Some false ⇒w | None ⇒None end.
Notation ”’IF x ’THEN a ’ELSE b” := (ifthenelse
x a b) (at level 200).
Deﬁnition F phi (A:Set)(t:A→option bool)(f g :A→option A)
: A →option A := fun r ⇒’IF (t r) ’THEN (bind (f r) g) ’ELSE (Some r).
We proved that each of the constructs and F phi are continuous. The
semantics for instructions can then be described by the following
functions:
Deﬁnition phi := fun A t f ⇒Tarski ﬁx (F phi A t f).
Fixpoint ds(i:instr) : (list(string*Z)) →option (list(string*Z)) :=
match i with
assign x e ⇒fun l ⇒bind (af l e)(fun v ⇒update l x v)
| sequence i1 i2 ⇒fun r ⇒(ds i1 r)(ds i2)
| while e i ⇒fun l ⇒phi env (fun l’ ⇒bf l’ e)(ds i) l
| skip ⇒fun l ⇒Some l
end.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

354
Y. Bertot
We also proved the equivalence of this semantic deﬁnition and the
natural semantics speciﬁcation:
Theorem ds eq sn : ∀i l l’, ds i l = Some l’ ↔exec l i l’.
We actually rely on a lemma which states that the least ﬁxpoint of a
continuous function is the least upper bound of the chain obtained by
iterating the function on the least element. In our case, this gives the
following corollary:
∀x v, phi x = Some v ⇒∃n, F phin (fun y →None) x = Some x
We can then proceed with a proof by induction on the number n.
Unlike the functions af, af’, or vcg, the function phi is not usable
for computation inside the theorem prover, but F phin can be used
to compute using approximations. We can still extract this code and
execute it in Ocaml, as long as we extract the Tarski ﬁxpoint theorem
to a simple ﬁxpoint function:
let rec ﬁx f = f (fun y →ﬁx f y)
This interpreter loops when executing a looping program; this is
predicted in the Coq formalization by a value of None.
15.6 Abstract interpretation
The goal of abstract interpretation [15] is to infer automatically
properties about programs based on approximations described as
abstract values. Approximations make it possible to consider several
executions at a time, for example all the executions inside a loop. This
way the execution of arbitrary programs can be approximated using an
algorithm that has polynomial complexity.
Abstract values are supposed to represent subsets of the set of
concrete values. Each abstract interpreter works with a ﬁxed set of
abstract values, which must have a certain structure. An operation on
abstract values must be provided for each operation in the language (in
our case we only have to provide an addition). The subset represented
by the result of an abstract operation must contain all the concrete
values of the corresponding operation when applied to values in the
input subsets. The domain of abstract values is also ordered, in a way
that respects inclusion for the subsets they represent. Also, the type
of abstract values should also contain an element corresponding to
the whole set of integers. We will call this element the top abstract
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 355
value. The theoretical foundations provided by Cousot and Cousot [15]
actually enumerate all the properties that are required from the abstract
values.
Given an abstract valuation where variable names are mapped to
abstract values, we program an abstract evaluation function ab eval for
arithmetic expressions that returns a new abstract value. This function
is programmed exactly like the function af’ we used for axiomatic
semantics, simply replacing integer addition with an abstract notion of
addition on abstract values.
As a running example, we will use an abstract domain of intervals,
whose bounds can be regular integers or inﬁnite bounds, and we use a
natural extension of addition to inﬁnite bounds (we agree that −∞+
∞= ∞, but this never occurs in our computation). The addition of
intervals can be deﬁned as the result of adding the lower bounds together
and adding the upper bounds together.
When we need to evaluate with respect to an abstract environment
l, i.e. a ﬁnite list of pairs of variable names and abstract values, we use
the function (ab lookup l) that associates the top value to all variables
that do not occur in the abstract environment.
Abstract execution of instructions takes as input an abstract
environment and a bare instruction and returns the pair of an annotated
instruction and an optional ﬁnal abstract environment. When the
optional ﬁnal environment is None, this means that the analysis detected
guaranteed non-termination. The annotations in the result instruction
describe information that is guaranteed to be satisﬁed when execution
reaches the corresponding point.
Abstract execution for assignments, sequences, and skip instructions
naturally follows the concrete semantics. For while loops, we depart from
the concrete semantics to ensure that our tool always terminates even
on non-terminating programs. The approach is to make over approxi-
mations with abstract environments that get coarser and coarser, until
we reach an approximation that is stable through abstract interpre-
tation of the loop body. Thus, we want to ﬁnd an invariant abstract
environment for loops, as we did in axiomatic semantics. We chose a
simple strategy.
(i) We use information from the loop test, when this is possible.
(ii) We check whether the abstract environment after testing and
executing the loop body once is stable, i.e. if abstract values in the
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

356
Y. Bertot
output of the executing the loop body environment are included in
the corresponding input values.
(iii) If this fails, we use a widen heuristic function to compute an over-
approximation and we try again.
(iv) If this fails again, we use a drastic over-approximation that is
guaranteed to succeed: the environment that maps the top abstract
value to every variable.
To use information from the loop test, when it has the form v < e, where
v is a variable, we reﬁne the abstract value for v inside the loop and after
exiting the loop. We may detect that the reﬁned value represents the
empty set, when the test can never succeed or never fail, and in this case
we have found dead-code. This is performed by a function intersect env.
This function takes a ﬁrst boolean argument that is used to express that
we check whether the test is satisﬁed or falsiﬁed. This function returns
None when the test can never be satisﬁed or can never be falsiﬁed. When
dead-code is detected, we annotate the instruction with false assertions,
to mark that the location is never reached, (this is done in mark).
For example, when using intervals, executing with respect to the
environment l1 = (x,[1,1]).∅, and analyzing the instruction
while x < 10 do x := x+1 end,
we use intersect env to discover that the test does not restrict the possible
values for x. After executing the loop body, we obtain an environment l2
= (x,[2,2]).∅. After combining with the initial environment, we obtain a
third environment l3 = (x, [1,2]).∅. This environment is not stable. We
use the widen heuristic to propose an over-approximating interval for
x and we start again with the environment l4 = (x,[1,+∞]).∅. we use
intersect env to compute the environment l5 that includes information
from the test. We obtain l5 = (x,[1,9]).∅. After executing the assignment
we obtain a new l6 = (x,[2,10]).∅. We combine l6 and l5 to obtain a new
environment l7 = (x,[1,10]).∅. Using intersect env again, but with l7 as
input, we obtain again l5, then l6, then combining again with l7 we ﬁnd
that l7 is stable. In this example, we ﬁnd a ﬁxed-point at the second
stage. We can then compute the abstract environment at the exit of the
loop, this time intersecting the ﬁxed-point abstract environment with
the negated test. The output abstract environment is l8 = (x,[10,10]).∅.
The three stages are described in a function fp that computes an
abstract ﬁxed-point for this abstract interpretation. This function has
the following type:
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 357
fp : ab env →bexpr →instr →(ab env →a instr*option ab env) →
a instr*option ab env
The function argument (fourth argument) is the function that computes
abstract interpretation on the loop body.
Our abstract interpreter is then described as a recursive function
abstract i (here we use to a to transform an environment into an
assertion, and to a’ for optional environments, mapping None to
false assert).
Fixpoint abstract i (i : instr)(l : ab env) : a instr*option ab env :=
match i with
skip ⇒(prec (to a l) a skip, Some l)
| sequence i1 i2 ⇒
let (i’1, l’) := abstract i i1 l in
match l’ with
None ⇒(a sequence i’1 (prec false assert (mark i2)), None)
| Some l’ ⇒let (i’2, l’’) := abstract i i2 l’ in (a sequence i’1 i’2, l’’)
end
| assign x e ⇒
(prec (to a l) (a assign x e), Some (ab update l x (ab eval (ab lookup l) e)))
| while b i ⇒
match intersect env true l b with
None ⇒
(prec (to a l)(a while b (a conj (a not (a b b)) (to a l)) (mark i)), Some l)
| Some l’ ⇒
let (i’,l’’) := fp l b i (abstract i i) in
match l’’ with
None ⇒(prec (to a l) (a while b (to a l) i’), intersect env false l)
| Some l’’ ⇒(prec (to a l) (a while b (to a l’’) i’), intersect env false l’’ b)
end
end
end.
This abstract interpreter is a programming tool: it can be run with
an instruction and initial approximations for variables. It returns the
same instruction, annotated with properties about the variables at each
location, together with the ﬁnal abstract environment. We proved a
correctness statement for this abstract interpreter. This statement relies
on the veriﬁcation condition generator that we described earlier.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

358
Y. Bertot
Theorem abstract i sound:
∀i e i’ e’, abstract i i e = (i’, e’) →valid l m (vcg i’ (to a’ e’))).
This theorem is proved by induction on i. We need to establish a few
facts.
(i) The order of variables does not change in successive abstract
environments.
(ii) Abstract
execution
is
monotonic:
given
wider
approximations,
execution yields wider results (assuming reasonable assumptions for
widen and intersect env).
(iii) The fp function either yields a result that is wider than its input or
detects non-termination of the loop body.
(iv) The veriﬁcation condition generator is monotonic with respect to
implication: if the conditions generated for i and a post-condition P
hold and P →P is valid, then the conditions generated for i and Q
also hold and pc i P →pc i Q is also valid. This property is needed
because abstract interpreters and condition generators work in reverse
directions.
This abstract interpreter was developed in a modular fashion, in which
the domain of abstract values is described using a module interface. We
implemented an instance of this domain for intervals. This interpreter
can actually be run inside Coq on small examples.
15.7 Conclusion
This overview of formalized programming language semantics is
elementary in its choice of a very limited programming language.
Because of this, some important aspects of programming languages
are overlooked: binding, which appears as soon as local variables
or procedures and functions are allowed; typing, which is a useful
programming concept for the early detection of programming errors;
concurrency, which is useful to exploit modern computing architectures,
etc. Even for this simplistic programming language, we could also
have covered two more aspects: program transformations [9] and
compilation [5].
Three aspects of this work are original: we obtain tools that can be
executed inside the Coq prover for proof by reﬂection; our work on
denotational semantics shows that the conventional extraction facility
of the Coq system can also be used for potentially non terminating
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 359
functions, thanks to well chosen extraction for Tarski’s ﬁxpoint theorem;
last, our description of an abstract interpreter is the ﬁrst to rely on
axiomatic semantics to prove the correctness of an abstract interpreter.
Concerning reﬂection, we ﬁnd it exciting that the theorem prover
can be used to execute programs in the object language (in work not
reported here we show how to construct an incomplete interpreter from
a structural operational semantics), to generate condition veriﬁcations
about programs (thanks to the veriﬁcation condition generator), and to
prove the conditions as usual logical statements. More interestingly, the
abstract interpreter can be run on programs to generate simultaneously
annotated programs and the proof that these annotated programs are
consistent.
Formal
veriﬁcation
techniques
based
on
veriﬁcation
condition
generators suﬀer from the burden of explicitely writing the loop
invariants. Chaieb already suggested that the loop invariants could be
obtained through abstract interpretation [12], generating proof traces
that can be veriﬁed in theorem provers. Our partial correctness theorem
for the abstract interpreter suggests a similar approach here, except
that we also proved the abstract interpreter correct. An interesting
improvement would be to make manually written assertions collaborate
with automatically generated ones; considering manual annotation as
part of the input for the widen heuristic is an easy approach to this
improvement.
Bibliography
[1]
B. E. Aydemir, A. Bohannon, M. Fairbairn, J. N. Foster, B. C. Pierce,
P. Sewell, D. Vytiniotis, G. Washburn, S. Weirich and S. Zdancewic.
Mechanized metatheory for the masses: The POPLmark challenge. In
Proceedings of the Eighteenth International Conference on Theorem Proving
in Higher Order Logics (TPHOLs 2005), pp. 50–65. Springer-Verlag, 2005.
[2]
G. Barthe, G. Dufay, L. Jakubiec, S. Melo de Sousa and B. Serpette. A
formal executable semantics of the JavaCard platform. In D. Sands (ed.)
Proceedings of ESOP’01, volume 2028 Lecture Notes in Computer Science,
pp. 302–319. Springer-Verlag, 2001.
[3]
G. Barthe, M. Ruys and H. Barendregt. A two-level approach towards
lean proof-checking. In TYPES ’95: Selected papers from the International
Workshop on Types for Proofs and Programs, London, UK, pp. 16–35.
Springer-Verlag, 1996.
[4]
S.
Berghofer
and
T.
Nipkow.
Executing
higher
order
logic.
In
P. Callaghan, Z. Luo, J. McKinna and R. Pollack (eds) TYPES, volume
2277, Lecture Notes in Computer Science, pp. 24–40. Springer-Verlag, 2000.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

360
Y. Bertot
[5]
Y. Bertot. A Certiﬁed Compiler for an Imperative Language. Research
Report RR-3488, INRIA, 1998.
[6]
Y. Bertot. Formalizing a jvml veriﬁer for initialization in a theorem
prover. In Computer Aided Veriﬁcation (CAV’2001), volume 2102, Lecture
Notes in Computer Science, pp. 14–24. Springer-Verlag, 2001.
[7]
Y. Bertot. A survey of semantics styles, 2007. available on the Coq site
at coq.inria.fr/Semantics survey.html.
[8]
Y. Bertot and P. Cast´eran. Interactive Theorem Proving and Program
Development, Coq’Art:the Calculus of Inductive Constructions. Springer-
Verlag, 2004.
[9]
Y. Bertot and R. Fraer. Reasoning with executable speciﬁcations. In
TAPSOFT’95, volume 915, Lecture Notes in Computer Science, pp. 531–
545, 1995.
[10]
P. Borras, D. Cl´ement, T. Despeyroux, J. Incerpi, G. Kahn, B. Lang
and V. Pascual. Centaur: the system. In Third Symposium on Software
Development Environments, 1988.
[11]
S. Boutin. Using reﬂection to build eﬃcient and certiﬁed decision
procedures. In Theoretical Aspects of Computer Science, volume 1281,
Lecture Notes in Computer Science, pp. 515–529. Springer-Verlag, 1997.
[12]
A.
Chaieb.
Proof-producing
program
analysis.
In
K.
Barkaoui,
A. Cavalcanti and A. Cerone (eds) ICTAC, volume 4281, Lecture Notes in
Computer Science, pp. 287–301. Springer-Verlag, 2006.
[13]
R.
Constable,
S. F.
Allen,
H. M.
Bromley,
W. R.
Cleaveland,
J. F. Cremer, R. W. Harber, D. J. Howe, T. B. Knoblock, N. P. Mendler,
P. Panangaden, J. T. Sasaki and S. F. Smith. Implementing Mathematics
with the Nuprl Proof Development System. Prentice-Hall, 1986.
[14]
C. Coquand. Agda. www.cs.chalmers.se/˜catarina/agda.
[15]
P. Cousot and R. Cousot. Abstract interpretation: a uniﬁed lattice
model for static analysis of programs by construction or approximation
of ﬁxpoints. In Conference Record of the Fourth Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, pp. 238–
252, Los Angeles, California, 1977. ACM Press, New York, NY.
[16]
E. W. Dijkstra. A discipline of Programming. Prentice Hall, 1976.
[17]
G. Dowek, A. Felty, H. Herbelin, G. Huet, C. Murthy, C. Parent,
C. Paulin-Mohring and B. Werner. The Coq Proof Assistant User’s Guide.
INRIA, May 1993. Version 5.8.
[18]
J.-C. Filliˆatre. Proof of imperative programs in type theory. In Interna-
tional Workshop TYPES’98, volume 1657, Lecture Notes in Computer
Science, pp. 78–92. Springer-Verlag, March 1998.
[19]
M. J. C. Gordon and T. F. Melham. Introduction to HOL : a theorem-
proving environment for higher-order logic. Cambridge University Press,
1993.
[20]
M. J. C. Gordon, R. Milner and C. P. Wadsworth. Edinburgh LCF,
volume 78, Lecture Notes in Computer Science. Springer-Verlag, 1979.
[21]
C. A. R. Hoare.
An
axiomatic
basis
for
computer
programming.
Communications of the ACM, 12:576–580, 1969.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

Theorem-proving support in programming language semantics 361
[22]
G.
Kahn.
Natural
semantics.
In
K.
Fuchi
and
M.
Nivat
(eds)
Programming of Future Generation Computers, pp. 237–258. North-
Holland, 1988. (also appears as INRIA Report no. 601).
[23]
P. Letouzey. A new extraction for Coq. In H. Geuvers and F. Wiedijk
(eds) TYPES 2002, volume 2646, Lecture Notes in Computer Science,
pp. 200–219. Springer-Verlag, 2003.
[24]
O. M¨uller, T. Nipkow, D. von Oheimb and O. Slotosch. HOLCF = HOL
+ LCF. Journal of Functional Programming, 9:191–223, 1999.
[25]
T. Nipkow. Winskel is (almost) right: Towards a mechanized semantics.
Formal Asp. Computing, 10(2):171–186, 1998.
[26]
L. C. Paulson and T. Nipkow. Isabelle : a Generic Theorem Prover,
volume 828, Lecture Notes in Computer Science. Springer-Verlag, 1994.
[27]
D.
Pichardie.
Interpr´etation
abstraite
en
logique
intuitionniste
:
extraction d’analyseurs Java certiﬁ´es. PhD thesis, Universit´e Rennes 1,
2005. (In French).
[28]
G. Plotkin. Structural operational semantics. Lecture notes DAIMI FN-
19, Aarhus University, 1981. (reprinted 1991).
[29]
D. Terrasse. Encoding natural semantics in Coq. In Proceedings of the
Fourth International Conference on Algebraic Methodology and Software
Technology, AMAST’95, Lecture Notes in Computer Science, pp. 230–244.
Springer-Verlag, 1995.
[30]
J. van den Berg and B. Jacobs. The loop compiler for Java and JML. In
TACAS 2001, pp. 299–312. Springer-Verlag, 2001.
[31]
D. von Oheimb. Analyzing Java in Isabelle/HOL, Formalization, Type
Safety, and Hoare Logic. PhD thesis, Technische Universit¨at M¨unchen, 2000.
[32]
G. Winskel. The Formal Semantics of Programming Languages, an
introduction. Foundations of Computing. The MIT Press, 1993.
https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

https://doi.org/10.1017/CBO9780511770524.016 Published online by Cambridge University Press

