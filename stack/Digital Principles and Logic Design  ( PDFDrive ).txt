
Digital
igital P Principles
rinciples
and
and
Logic Design
Logic Design

LICENSE, DISCLAIMER OF LIABILITY, AND LIMITED WARRANTY
The CD-ROM that accompanies this book may only be used on a single PC. This 
license does not permit its use on the Internet or on a network (of any kind). By 
purchasing or using this book/CD-ROM package(the “Work”), you agree that this 
license grants permission to use the products contained herein, but does not give 
you the right of ownership to any of the textual content in the book or ownership 
to any of the information or products contained on the CD-ROM. Use of third 
party software contained herein is limited to and subject to licensing terms for the 
respective products, and permission must be obtained from the publisher or the 
owner of the software in order to reproduce or network any portion of the textual 
material or software (in any media) that is contained in the Work.
INFINITY SCIENCE PRESS LLC (“ISP” or “the Publisher”) and anyone involved in the 
creation, writing or production of the accompanying algorithms, code, or computer 
programs (“the software”) or any of the third party software contained on the CD-
ROM or any of the textual material in the book, cannot and do not warrant the 
performance or results that might be obtained by using the software or contents of 
the book. The authors, developers, and the publisher have used their best efforts 
to insure the accuracy and functionality of the textual material and programs 
contained in this package; we, however, make no warranty of any kind, express or 
implied, regarding the performance of these contents or programs. The Work is sold 
“as is” without warranty (except for defective materials used in manufacturing the 
disc or due to faulty workmanship);
The authors, developers, and the publisher of any third party software, and anyone 
involved in the composition, production, and manufacturing of this work will not be 
liable for damages of any kind arising out of the use of (or the inability to use) the 
algorithms, source code, computer programs, or textual material contained in this 
publication. This includes, but is not limited to, loss of revenue or proﬁ t, or other 
incidental, physical, or consequential damages arising out of the use of this Work.
The sole remedy in the event of a claim of any kind is expressly limited to 
replacement of the book and/or the CD-ROM, and only at the discretion of the 
Publisher.
The use of “implied warranty” and certain “exclusions” vary from state to state, and 
might not apply to the purchaser of this product.

Digital Principles
Digital Principles
and
and
Logic Design
Logic Design
A. SAHA
N. MANNA
INFINITY
NFINITY S SCIENCE
CIENCE P PRESS
RESS LLC
LLC
Hingham, Massachusetts
New Delhi

Reprint & Revision Copyright © 2007. INFINITY SCIENCE PRESS LLC. All rights reserved.
Copyright © 2007. Laxmi Publications Pvt. Ltd.
This publication, portions of it, or any accompanying software may not be reproduced in any 
way, stored in a retrieval system of any type, or transmitted by any means or media, electronic 
or mechanical, including, but not limited to, photocopy, recording, Internet postings or 
scanning, without prior permission in writing from the publisher.
Publisher: David F. Pallai
INFINITY SCIENCE PRESS LLC
11 Leavitt Street
Hingham, MA 02043
Tel. 877-266-5796 (toll free)
Fax 781-740-1677
info@inﬁ nitysciencepress.com
www.inﬁ nitysciencepress.com
This book is printed on acid-free paper.
A. Saha and N. Manna. Digital Principles and Logic Design.
ISBN: 978-1-934015-03-2
The publisher recognizes and respects all marks used by companies, manufacturers, and 
developers as a means to distinguish their products. All brand names and product names 
mentioned in this book are trademarks or service marks of their respective companies. Any 
omission or misuse (of any kind) of service marks or trademarks, etc. is not an attempt to 
infringe on the property of others. 
Library of Congress Cataloging-in-Publication Data
Saha, A. (Arjit)
  Digital principles and logic design / A. Saha and N. Manna.
       p. cm.
  Includes bibliographical references and index.
  ISBN 978-1-934015-03-2 (hardcover with cd-rom : alk. paper)
 1.  Electric circuits--Design and construction. 2.  Digital electronics. 3.  Logic design.  I. 
Manna, N. (Nilotpal) II. Title.
  TK454.S3135 2007
  621.319’2--dc22
                                                            2007013970
07 8 9 5 4 3 2 1
Our titles are available for adoption, license or bulk purchase by institutions, corporations, 
etc. For additional information, please contact the Customer Service Dept. at 877-266-5796 
(toll free in US).
Requests for replacement of a defective CD-ROM must be accompanied by the original disc, your mailing 
address, telephone number, date of purchase and purchase price.  Please state the nature of the problem, and 
send the information to INFINITY SCIENCE PRESS, 11 Leavitt Street, Hingham, MA 02043.
The sole obligation of INFINITY SCIENCE PRESS to the purchaser is to replace the disc, based on defective 
materials or faulty workmanship, but not based on the operation or functionality of the product.

Dedication
To our parents 
who have shown us 
the light of the world.


CONTENTS
Preface  
 
(xiii)
1. DATA AND NUMBER SYSTEMS 
1
 
1.1 
Introduction 
1
 
1.2 
Number Systems 
2
 
1.3 
Conversion between Number Systems 
2
 
1.4 
Complements 
10
 
1.5 
Binary Arithmetic 
13
 
1.6 
1's And 2's Complement Arithmetic 
17
 
1.7 
Signed Binary Numbers  
19
 
1.8  7's And 8's Complement Arithmetic  
21
 
1.9  9's And 10's Complement Arithmetic  
23
 1.10 
15's And 16's Complement Arithmetic 
25
 1.11 
BCD Addition 
27
 1.12 
BCD Subtraction 
28
 
 
Review Questions 
30
2. CODES AND THEIR CONVERSIONS 
31
 
2.1 
Introduction 
31
 
2.2 
Codes  
31
 
2.3 
Solved Problems 
44
 
 
Review Questions 
49
3. BOOLEAN ALGEBRA AND LOGIC GATES 
51
 
3.1 
Introduction 
51
 
3.2 
Basic Deﬁ nitions 
51
 
3.3 
Deﬁ nition of Boolean Algebra 
52
 
3.4 
Two-valued Boolean Algebra 
54

 
3.5 
Basic Properties And Theorems of Boolean Algebra 
55
 
3.6 
Venn Diagram 
57
 
3.7 
Boolean Functions 
58
 
3.8 
Simpliﬁ cation of Boolean Expressions 
59
 
3.9 
Canonical And Standard Forms 
60
 3.10 
Other Logic Operators 
67
 3.11 
Digital Logic Gates 
67
 3.12  Positive And Negative Logic 
83
 3.13 
Concluding Remarks 
84
 
Review Questions 
85
4. SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 89
 
4.1 
Introduction 
89
 
4.2 
Two-variable Karnaugh Maps 
89
 
4.3 
Three-variable Karnaugh Maps 
90
 
4.4 
Four-variable Karnaugh Maps 
93
 
4.5 
Five-variable Karnaugh Maps 
99
 
4.6 
Six-variable Karnaugh Maps 
100
 
4.7 
Don't-care Combinations 
102
 
4.8 
The Tabulation Method 
103
 
4.9 
More Examples 
106
 4.10 
Variable-entered Karnaugh Maps 
113
 4.11 
Concluding Remarks 
123
 
 
Review Questions 
123
5. COMBINATIONAL LOGIC CIRCUITS 
125
 
5.1 
Introduction 
125
 
5.2 
Design Procedure 
126
 
5.3 
Adders  
126
 
5.4  Subtractors 
129
 
5.5  Code Conversion 
132
 
5.6  Parity Generator And Checker 
141
 
5.7 
Some Examples of Combinational Logic Circuits 
143
 
5.8 
Combinational Logic with MSI And LSI 
156
 
5.9 
Four-bit Binary Parallel Adder 
157
 5.10 
Magnitude Comparator 
167

 5.11 
Decoders 
168
 5.12 
Encoders 
174
 5.13 
Multiplexers or Data Selectors 
175
 5.14  Demultiplexers or Data Distributors 
188
 5.15  Concluding Remarks 
190
 
 
Review Questions
190
6. PROGRAMMABLE LOGIC DEVICES 
193
 
6.1 
Introduction 
193
 
6.2 
PLD Notation 
195
 
6.3 
Read Only Memory (ROM) 
195
 
6.4 
Programmable Logic Array (PLA) 
202
 
6.5 
Programmable Array Logic (PAL) Devices 
208
 
6.6 
Registered PAL Devices 
210
 
6.7 
Conﬁ gurable PAL Devices 
211
 
6.8 
Generic Array Logic Devices 
211
 
6.9 
Field-Programmable Gate Array (FPGA) 
211
 6.10 
Concluding Remarks 
212
Review Questions 
212
7. SEQUENTIAL LOGIC CIRCUITS 
215
 
7.1 
Introduction 
215
 
7.2 
Flip-ﬂ ops 
216
 
7.3 
Types of Flip-ﬂ ops 
218
 
7.4  Clocked S-R Flip-ﬂ op 
221
 
7.5 
Clocked D Flip-ﬂ op 
225
 
7.6 
J-K Flip-ﬂ op 
228
 
7.7 
T Flip-ﬂ op 
233
 
7.8 
Toggling Mode of S-R and D Flip-ﬂ ops 
235
 
7.9 
Triggering of Flip-ﬂ ops 
235
 7.10 
Excitation Table of a Flip-ﬂ op 
237
 7.11 
Interconversion of Flip-ﬂ ops 
237
 7.12 
Sequential Circuit Model 
248
 7.13 
Classiﬁ cation of Sequential Circuits 
248
 7.14 
Analysis of Sequential Circuits 
250
 7.15  Design Procedure of Sequential Circuits 
254
 
 
Review Questions 
260

8. REGISTERS 
263
 
8.1 
Introduction 
263
 
8.2 
Shift Register 
263
 
8.3 
Serial-in–Serial-out Shift Register 
264
 
8.4 
Serial-in–Parallel-out Register 
269
 
8.5 
Parallel-in–Serial-out Register 
270
 
8.6 
Parallel-in–Parallel-out Register 
272
 
8.7  Universal Register 
274
 
8.8  Shift Register Counters 
276
 
8.9  Sequence Generator 
279
 8.10  Serial Addition 
283
 8.11  Binary Divider 
284
 
 
Review Questions 
289
9. COUNTERS 
291
 
9.1 
Introduction 
291
 
9.2 
Asynchronous (Serial or Ripple) Counters 
292
 
9.3 
Asynchronous Counter ICs 
302
 
9.4 
Synchronous (Parallel) Counters 
309
 
9.5 
Synchronous Down-Counter 
311
 
9.6 
Synchronous Up-Down Counter 
312
 
9.7 
Design Procedure of Synchronous Counter 
313
 
9.8 
Synchronous/Asynchronous Counter 
325
 
9.9 
Presettable Counter 
326
 9.10 
Synchronous Counter ICs 
327
 9.11  Counter Applications 
335
 9.12  Hazards in Digital Circuits 
338
Review Questions 
344
10. A/D AND D/A CONVERSION 
345
 10.1 
Introduction 
345
 10.2 
Digital-to-Analog Converters (DAC) 
345
 10.3 
Speciﬁ cation of D/A Converters 
355
 10.4  An Example of a D/A Converter 
357
 10.5 
Analog-to-Digital Converters 
360
 10.6 
Speciﬁ cation of an A/D Converter 
371

 10.7  An Example of an A/D Converter IC 
372
 10.8 
Concluding Remarks 
374
 
Review Questions 
374
11. LOGIC FAMILY 
377
 11.1 
Introduction 
377
 11.2 
Characteristics of Digital IC 
379
 11.3 
Bipolar Transistor Characteristics 
382
 11.4  Resistor-Transistor Logic (RTL) 
385
 11.5 
Diode Transistor Logic (DTL) 
387
 11.6 
Transistor Transistor Logic (TTL) 
389
 11.7 
Emitter-Coupled Logic (ECL) 
407
 11.8 
Integrated-Injection Logic (I2L) 
410
 11.9 
Metal Oxide Semiconductor (MOS) 
412
 11.10  Comparison of Different Logic Families 
420
 11.11 
Interfacing 
421
 11.12 
Some Examples 
424
 
 
Review Questions 
427
Appendix 1: Alternate Gate Symbols 
431
Appendix 2: 74 Series Integrated Circuits 
433
Appendix 3: Pin Conﬁ guration of 74 Series Integrated Circuits 
439
Appendix 4: 4000 Series Integrated Circuits 
459
Appendix 5: Pin Conﬁ guration of 4000 Series Integrated Circuits 
465
Appendix 6: About the CD-ROM 
481
Glossary
483
Bibliography
487
Index  
 
 
489


PREFACE
With the advancement of technology, digital logic systems became inevitable and became 
the integral part of digital circuit design. Digital logic is concerned with the interconnection 
of digital components and modules, and is a term used to denote the design and analysis 
of digital systems. Recent technology advancements have led to enhanced usage of digital 
systems in all disciplines of engineering and have also created the need of in-depth 
knowledge about digital circuits among the students as well as the instructors. It has been 
felt that a single textbook dealing with the basic concepts of digital technology with design 
aspects and applications is the standard requirement. This book is designed to fulﬁ ll such 
a requirement by presenting the basic concepts used in the design and analysis of digital 
systems, and also providing various methods and techniques suitable for a variety of digital 
system design applications.
This book is suitable for an introductory course of digital principles with emphasis on 
logic design as well as for more advanced courses. The contents of this book are chosen and 
illustrated in such a way that there does not need to be any special background knowledge 
on the part of the reader.
The philosophy underlying the material presented in this book is to describe the 
classical methods of design technique. The classical method has been predominant in the 
past for describing the operation of digital circuits. With the advent of integrated circuits, 
and especially the introduction of microprocessors, microcontrollers, microcomputers and 
various LSI components, the classical method seems to be far removed from practical 
applications. Although the classical method of describing complex digital systems is not 
directly applicable, the basic concepts of Boolean algebra, combinational logic, and sequential 
logic procedures are still important for understanding the internal construction of many 
digital functions. The philosophy of this book is to provide a strong foundation of basic 
principles through the classical approach before engaging in practical design approach and 
the use of computer-aided tools. Once the basic concepts are mastered, the utilization of 
practical design technique and design software become meaningful and allow the students 
to use them more effectively.
The book is divided into 11 chapters. Each chapter begins with the introduction and ends 
with review questions and problems. Chapter 1 presents various binary systems suitable for 
representation of information in digital systems and illustrates binary arithmetic. Chapter 
2 describes various codes, conversion, and their utilization in digital systems.
Chapter 3 provides the basic postulates and theorems related to Boolean algebra. 
The various logic operations and the correlation between the Boolean expression and its 
implementation with logic gates are illustrated. The various methods of minimization and 
simpliﬁ cation of Boolean expressions, Karnaugh maps, tabulation method, etc. are explained 
xiii

in Chapter 4. Design and analysis procedures for combinational circuits are provided in 
Chapter 5. This chapter also deals with the MSI components. Design and implementation of 
combinational circuits with MSI blocks like adders, decoders, and multiplexers are explained 
with examples. Chapter 6 introduces LSI components—the read-only memory (ROM) and 
various programmable logic devices (PLD), and demonstrates design and implementation 
of complex digital circuits with them.
Chapter 7 starts with the introduction of various types of ﬂ ip-ﬂ ops and demonstrates 
the design and implementation of sequential logic networks explaining state table, state 
diagram, state equations, etc. in detail. Chapter 8 deals with various types of registers and 
sequence generators. Chapter 9 illustrates synchronous and asynchronous types of counters, 
and design and application of them in detail.
Chapter 10 discusses various methods of digital-to-analog conversion (DAC) as well 
as analog-to-digital conversion (ADC) techniques. Chapter 11 deals with the various logic 
families and their characteristics and parameters with respect to propagation delay, noise 
margin, power dissipation, power requirements, fan out, etc. Appendices have been provided 
at the end of the book as ready reference for 74-series and 4000-series integrated circuit 
functions and their pinout conﬁ gurations.
Clear diagrams and numerous examples have been provided for all the topics, and 
simple language has been used throughout the book to facilitate understanding of the 
concepts and to enable the readers to design digital circuits efﬁ ciently.
The authors express their thanks to their respective wives and children for their 
continuous support and enormous patience during the preparation of this book.
The authors welcome any suggestions and corrections for the improvement of the 
book.
—AUTHORS

1
1.1  INTRODUCTION
O
ne of the ﬁ rst things we have to know is that electronics can be broadly classiﬁ ed 
into two groups, viz. analog electronics and digital electronics. Analog electronics 
deals with things that are continuous in nature and digital electronics deals with 
things that are discrete in nature. But they are very much interlinked. For example, if we 
consider a bucket of water, then it is analog in terms of the content i.e., water, but it is 
discrete in terms of the container, i.e., bucket. Now though in nature most things are analog, 
still we very often require digital concepts. It is because it has some speciﬁ c advantages 
over analog, which we will discuss in due course of time.
Many of us are accustomed with the working of electronic ampliﬁ ers. Generally they 
are used to amplify electronic signals. Now these signals usually have a continuous value 
and hence can take up any value within a given range, and are known as analog signals.
The electronic circuits which are used to process such signals are called analog circuits and 
the circuits based on such operation are called analog systems.
On the other side, in a computer, the input is given with the help of the switches. Then 
this is converted into electronic signals, which have two distinct discrete levels or values. 
One of them is called HIGH level whereas the other is called LOW level. The signal must 
always be in either of the two levels. As long as the signal is within a prespeciﬁ ed range 
of HIGH and LOW, the actual value of the signal is not that important. Such signals are 
called digital signals and the circuit within the device is called a digital circuit. The system 
based on such a concept is an example of a digital system.
Since Claude Shannon systemized and adapted the theoretical work of George Boole 
in 1938, digital techniques saw a tremendous growth. Together with developments in 
semiconductor technology, and with the progress in digital technology, a revolution in digital 
electronics happened when the microprocessor was introduced in 1971 by Intel Corporation 
of America. At present, digital technology has progressed much from the era of vacuum 
tube circuits to integrated circuits. Digital circuits ﬁ nd applications in computers, telephony, 
radar navigation, data processing, and many other applications. The general properties of 
DATA AND NUMBER SYSTEMS
1
C h a p t e r

2
DIGITAL PRINCIPLES AND LOGIC DESIGN
number systems, methods of their interconversions, and arithmetic operations are discussed 
in this chapter.
1.2  NUMBER SYSTEMS
There are several number systems which we normally use, such as decimal, binary, octal, 
hexadecimal, etc. Amongst them we are most familiar with the decimal number system. These 
systems are classiﬁ ed according to the values of the base of the number system. The number 
system having the value of the base as 10 is called a decimal number system, whereas that 
with a base of 2 is called a binary number system. Likewise, the number systems having 
base 8 and 16 are called octal and hexadecimal number systems respectively. 
With a decimal system we have 10 different digits, which are 0, 1, 2, 3, 4, 5, 6, 7, 8, 
and 9. But a binary system has only 2 different digits—0 and 1. Hence, a binary number 
cannot have any digit other than 0 or 1. So to deal with a binary number system is quite 
easier than a decimal system. Now, in a digital world, we can think in binary nature, e.g.,
a light can be either off or on. There is no state in between these two. So we generally use 
the binary system when we deal with the digital world. Here comes the utility of a binary 
system. We can express everything in the world with the help of only two digits i.e., 0 and 
1. For example, if we want to express 2510 in binary we may write 110012. The right most 
digit in a number system is called the ‘Least Signiﬁ cant Bit’ (LSB) or ‘Least Signiﬁ cant 
Digit’ (LSD). And the left most digit in a number system is called the ‘Most Signiﬁ cant 
Bit’ (MSB) or ‘Most Signiﬁ cant Digit’ (MSD). Now normally when we deal with different 
number systems we specify the base as the subscript to make it clear which number system 
is being used. 
In an octal number system there are 8 digits—0, 1, 2, 3, 4, 5, 6, and 7. Hence, any 
octal number cannot have any digit greater than 7. Similarly, a hexadecimal number system 
has 16 digits—0 to 9— and the rest of the six digits are speciﬁ ed by letter symbols as A, 
B, C, D, E, and F. Here A, B, C, D, E, and F represent decimal 10, 11, 12, 13, 14, and 15 
respectively. Octal and hexadecimal codes are useful to write assembly level language.
In general, we can express any number in any base or radix “X.” Any number with base X, 
having n digits to the left and m digits to the right of the decimal point, can be expressed as:
a
X
a
X
a
X
a
X
a
X
b X
b
X
b
X
n
n
n
n
n
n
m
m
−
−
−
−
−
−
−
−
+
+
+
+
+
+
+
+
+
1
1
2
2
3
2
1
1
0
1
1
2
2
...
...
where an is the digit in the nth position. The coefﬁ cient an is termed as the MSD or Most 
Signiﬁ cant Digit and bm is termed as the LSD or the Least Signiﬁ cant Digit.
1.3  CONVERSION BETWEEN NUMBER SYSTEMS
It is often required to convert a number in a particular number system to any other 
number system, e.g., it may be required to convert a decimal number to binary or octal or 
hexadecimal. The reverse is also true, i.e., a binary number may be converted into decimal 
and so on. The methods of interconversions are now discussed.
1.3.1 Decimal-to-binary Conversion
Now to convert a number in decimal to a number in binary we have to divide the decimal 
number by 2 repeatedly, until the quotient of zero is obtained. This method of repeated 
division by 2 is called the ‘double-dabble’ method. The remainders are noted down for each 

DATA AND NUMBER SYSTEMS 3
of the division steps. Then the column of the remainder is read in reverse order i.e., from 
bottom to top order. We try to show the method with an example shown in Example 1.1. 
Example 1.1. Convert 2610 into a binary number.
Solution.
Division 
Quotient 
Generated remainder
26
2  
13 
0
13
2  
6 
1
6
2 
3 
0
3
2 
1 
1
1
2  
0 
1
Hence the converted binary number is 110102.
1.3.2 Decimal-to-octal Conversion
Similarly, to convert a number in decimal to a number in octal we have to divide 
the decimal number by 8 repeatedly, until the quotient of zero is obtained. This method 
of repeated division by 8 is called ‘octal-dabble.’ The remainders are noted down for each 
of the division steps. Then the column of the remainder is read from bottom to top order, 
just as in the case of the double-dabble method. We try to illustrate the method with an 
example shown in Example 1.2.
Example 1.2. Convert 42610 into an octal number.
Solution.
 
Division 
Quotient 
Generated remainder
426
8
53 
2
8
53
 
6 
5
6
8 
0 
6
Hence the converted octal number is 6528.
1.3.3 Decimal-to-hexadecimal Conversion
The same steps are repeated to convert a number in decimal to a number in hexadecimal. 
Only here we have to divide the decimal number by 16 repeatedly, until the quotient of zero 
is obtained. This method of repeated division by 16 is called ‘hex-dabble.’ The remainders 
are noted down for each of the division steps. Then the column of the remainder is read 
from bottom to top order as in the two previous cases. We try to discuss the method with 
an example shown in Example 1.3.

4
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 1.3. Convert 34810 into a hexadecimal number.
Solution.
 
Division 
Quotient 
Generated remainder
348
16
21 
12
21
16  
1 
5
1
16  
0 
1
Hence the converted hexadecimal number is 15C16.
1.3.4 Binary-to-decimal Conversion
Now we discuss the reverse method, i.e., the method of conversion of binary, octal, or 
hexadecimal numbers to decimal numbers. Now we have to keep in mind that each of the 
binary, octal, or hexadecimal number system is a positional number system, i.e., each of 
the digits in the number systems discussed above has a positional weight as in the case of 
the decimal system. We illustrate the process with the help of examples.
Example 1.4. Convert 101102 into a decimal number.
Solution. 
The binary number given is  
1 0 1 1 0
 
Positional weights 
4 3 2 1 0
The positional weights for each of the digits are written in italics below each digit. 
Hence the decimal equivalent number is given as:
 
 
1 × 24 + 0 × 23 + 1 × 22 + 1 × 21 + 0 × 20
 
= 16 + 0 + 4 + 2 + 0
 
= 2210.
Hence we ﬁ nd that here, for the sake of conversion, we have to multiply each bit with 
its positional weights depending on the base of the number system. 
1.3.5 Octal-to-decimal Conversion
Example 1.5. Convert 34628 into a decimal number.
Solution.  The octal number given is  
3 4 6 2
 
Positional weights 
3 2 1 0
The positional weights for each of the digits are written in italics below each digit. 
Hence the decimal equivalent number is given as:
 
 
3 × 83 + 4 × 82 + 6 × 81 + 2 × 80
 
= 1536 + 256 + 48 + 2 
 
= 184210.

DATA AND NUMBER SYSTEMS 5
1.3.6 Hexadecimal-to-decimal Conversion
Example 1.6. Convert 42AD16 into a decimal number.
Solution.  The hexadecimal number given is  
4 2 A D
 
Positional weights 
3 2 1 0
The positional weights for each of the digits are written in italics below each digit. 
Hence the decimal equivalent number is given as:
 
 
4 × 163 + 2 × 162 + 10 × 161 + 13 × 160
 
= 16384 + 512 + 160 + 13 
 
= 1706910.
1.3.7 Fractional Conversion
So far we have dealt with the conversion of integer numbers only. Now if the number 
contains the fractional part we have to deal in a different way when converting the number 
from a different number system (i.e., binary, octal, or hexadecimal) to a decimal number 
system or vice versa. We illustrate this with examples.
Example 1.7. Convert 1010.0112 into a decimal number.
Solution.
The binary number given is 
1 0 1 0. 0 1 1
 
Positional weights 
3 2 1 0 -1-2-3
The positional weights for each of the digits are written in italics below each digit. 
Hence the decimal equivalent number is given as:
 
 
1 × 23 + 0 × 22 + 1 × 21 + 0 × 20 + 0 × 2–1 + 1 × 2–2 + 1 × 2–3
 
= 8 + 0 + 2 + 0 + 0 + 0.25 + 0.125
 
= 10.37510.
Example 1.8. Convert 362.358 into a decimal number.
Solution.The octal number given is  
 
3 6 2. 3 5
 
 
 
Positional weights 
 
 
2 1 0 -1-2 
The positional weights for each of the digits are written in italics below each digit. 
Hence the decimal equivalent number is given as:
 
  
3 × 82 + 6 × 81 + 2 × 80 + 3 × 8–1 + 5 × 8–2
 
 = 192 + 48 + 2 + 0.375 + 0.078125
 
 = 242.45312510.
Example 1.9. Convert 42A.1216 into a decimal number.
Solution.
The hexadecimal number given is 
4 2 A. 1 2
 
Positional weights 
2 1 0 -1-2
The positional weights for each of the digits are written in italics below each digit. 
Hence the decimal equivalent number is given as:
 
 
4 × 162 + 2 × 161 + 10 × 160 + 1 × 16–1 + 1 × 16–2
 
= 1024 + 32 + 10 + 0.0625 + 0.00390625
 
= 1066.0664062510.

6
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 1.10. Convert 25.62510 into a binary number.
Solution. Division 
Quotient 
Generated remainder
25
2  
12 
1
12
2  
6 
0
6
2  
3 
0
3
2  
1 
1
1
2  
0 
1
Therefore,      (25)10 = (11001)2
Fractional Part
 
 
 
0.625 
 
0.250 
 
0.500
 
 
 
   ×2 
 
   ×2 
 
   ×2
 
 
 
1.250 
 
0.500 
 
1.000
 
 
 
 
 
 
1 
 
0 
 
1
i.e., 
 
(0.625)10 = (0.101)2
Therefore, 
(25.625)10 = (11001.101)2
Example 1.11. Convert 34.52510 into an octal number.
Solution.
Division 
Quotient 
Generated remainder
34
8  
4 
2 
4
8  
0 
4
Therefore, 
(34)10 = (42)8
Fractional Part
 
 
 
0.525 
 
0.200 
 
0.600 
 
 
 
 
   ×8 
 
   ×8 
 
   ×2 
 
 
 
4.200 
 
1.600 
 
1.200 
 
 
 
 




 
 
 
4 
 
1 
 
1 
 
i.e., 
 
(0.525)10 = (0.411)8
Therefore, 
(34.525)10 = (42.411)8
Example 1.12. Convert 92.8510 into a hexadecimal number.
Solution. Division 
Quotient 
Generated remainder
92
16 
5 
12

DATA AND NUMBER SYSTEMS 7
5
16 
0 
5
Therefore, 
(92)10 = (5C)16
Fractional Part
 
 
 
0.85 
 
0.60
 
 
 
 ×16 
 
 ×16
 
 
 
13.60 
 
9.60
 
 
 
 
 
 
13 
 
9
i.e., 
 
(0.85)10 = (0.D9)16
Therefore, 
(92.85)10 = (5C.D9)16
1.3.8 Conversion from a Binary to Octal Number and Vice Versa
We know that the maximum digit in an octal number system is 7, which can be 
represented as 1112 in a binary system. Hence, starting from the LSB, we group three 
digits at a time and replace them by the decimal equivalent of those groups and we get 
the ﬁ nal octal number.
Example 1.13. Convert 1011010102 into an equivalent octal number.
Solution. 
The binary number given is 
101101010
 
Starting with LSB and grouping 3 bits 
101 101 010
 
Octal equivalent  
 5   5   2
 
Hence the octal equivalent number is (552)8.
Example 1.14. Convert 10111102 into an equivalent octal number.
Solution. 
The binary number given is 
1011110
 
Starting with LSB and grouping 3 bits 
001 011 110
 
Octal equivalent 
 1   3   6
 
Hence the octal equivalent number is (176)8.
Since at the time of grouping the three digits in Example 1.14 starting from the LSB, 
we ﬁ nd that the third group cannot be completed, since only one 1 is left out in the third 
group, so we complete the group by adding two 0s in the MSB side. This is called left-
padding of the number with 0. Now if the number has a fractional part then there will 
be two different classes of groups—one for the integer part starting from the left of the 
decimal point and proceeding toward the left and the second one starting from the right of 
the decimal point and proceeding toward the right. If, for the second class, any 1 is left out, 
we complete the group by adding two 0s on the right side. This is called right-padding.
Example 1.15. Convert 1101.01112 into an equivalent octal number.
Solution. 
The binary number given is  
1101.0111
 
Grouping 3 bits 
001 101. 011 100
 
Octal equivalent: 
 1  5  3  4
 
 
 
Hence the octal number is (15.34)8.

8
DIGITAL PRINCIPLES AND LOGIC DESIGN
Now if the octal number is given and you're asked to convert it into its binary equivalent, 
then each octal digit is converted into a 3-bit-equivalent binary number and—combining all 
those digits we get the ﬁ nal binary equivalent.
Example 1.16. Convert 2358 into an equivalent binary number.
Solution.
The octal number given is 
2      3      5
 
3-bit binary equivalent 
010    011   101
 
Hence the binary number is (010011101)2.
Example 1.17. Convert 47.3218 into an equivalent binary number.
Solution. 
The octal number given is 
4      7      3      2      1
 
3-bit binary equivalent 
100   111    011    010   001
 
Hence the binary number is (100111.011010001)2.
1.3.9 Conversion from a Binary to Hexadecimal Number and Vice Versa
We know that the maximum digit in a hexadecimal system is 15, which can be 
represented by 11112 in a binary system. Hence, starting from the LSB, we group four digits 
at a time and replace them with the hexadecimal equivalent of those groups and we get 
the ﬁ nal hexadecimal number. 
Example 1.18. Convert 110101102 into an equivalent hexadecimal number.
Solution. 
The binary number given is 
11010110
 
Starting with LSB and grouping 4 bits 
1101  0110
 
Hexadecimal equivalent 
D      6
 
Hence the hexadecimal equivalent number is (D6)16.
Example 1.19. Convert 1100111102 into an equivalent hexadecimal number.
Solution.
The binary number given is 
110011110
 
Starting with LSB and grouping 4 bits 
0001 1001  1110
 
Hexadecimal equivalent 
  1     9      E
 
Hence the hexadecimal equivalent number is (19E)16.
Since at the time of grouping of four digits starting from the LSB, in Example 1.19 we 
ﬁ nd that the third group cannot be completed, since only one 1 is left out, so we complete 
the group by adding three 0s to the MSB side. Now if the number has a fractional part, 
as in the case of octal numbers, then there will be two different classes of groups—one for 
the integer part starting from the left of the decimal point and proceeding toward the left 
and the second one starting from the right of the decimal point and proceeding toward the 
right. If, for the second class, any uncompleted group is left out, we complete the group by 
adding 0s on the right side.
Example 1.20. Convert 111011.0112 into an equivalent hexadecimal number.
Solution. 
The binary number given is 
111011.011 
 
Grouping 4 bits 
0011  1011. 0110
 
Hexadecimal equivalent 
3        B      6
 
Hence the hexadecimal equivalent number is (3B.6)16.
Now if the hexadecimal number is given and you're asked to convert it into its binary 
equivalent, then each hexadecimal digit is converted into a 4-bit-equivalent binary number 
and by combining all those digits we get the ﬁ nal binary equivalent.

DATA AND NUMBER SYSTEMS 9
Example 1.21. Convert 29C16 into an equivalent binary number.
Solution. 
The hexadecimal number given is 
2   9   C
 
4-bit binary equivalent 
0010  1001  1100
 
Hence the equivalent binary number is (001010011100)2.
Example 1.22. Convert 9E.AF216 into an equivalent binary number.
Solution. 
The hexadecimal number given is 
9   E   A   F   2
 
4-bit binary equivalent 
1001 1110 1010 1111 0010
 
Hence the equivalent binary number is (10011110.101011110010)2.
1.3.10 Conversion from an Octal to Hexadecimal Number and Vice Versa
Conversion from octal to hexadecimal and vice versa is sometimes required. To convert 
an octal number into a hexadecimal number the following steps are to be followed:
 (i) First convert the octal number to its binary equivalent (as already discussed 
above).
 (ii) Then form groups of 4 bits, starting from the LSB.
 (iii) Then write the equivalent hexadecimal number for each group of 4 bits.
Similarly, for converting a hexadecimal number into an octal number the following 
steps are to be followed:
 (i) First convert the hexadecimal number to its binary equivalent.
 (ii) Then form groups of 3 bits, starting from the LSB.
 (iii) Then write the equivalent octal number for each group of 3 bits.
Example 1.23. Convert the following hexadecimal numbers into equivalent octal 
numbers.
 
(a) A72E 
(b) 4.BF85
Solution.
   (a) 
Given hexadecimal number is  
A   7   2   E
 
Binary equivalent is 
1010 0111 0010 1110
 
 
= 1010011100101110
 
Forming groups of 3 bits from the LSB 
001 010 011 100 101 110
 
Octal equivalent 
1   2  3  4  5  6
 
Hence the octal equivalent of (A72E)16 is  (123456)8.
   (b) 
Given hexadecimal number is  
4   B   F   8   5
 
Binary equivalent is 
0100 1011 1111 1000 0101
 
 
= 0100.1011111110000101
 
Forming groups of 3 bits 
100. 101 111 111 000 010 100
 
Octal equivalent 
  4  5  7  7  0  2  4
 
Hence the octal equivalent of (4.BF85)16 is (4.577024)8.

10
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 1.24. Convert (247)8 into an equivalent hexadecimal number.
Solution. 
Given octal number is 
2   4   7
 
Binary equivalent is 
010  100  111
 
 
= 010100111
 
Forming groups of 4 bits from the LSB 
1010  0111
 
Hexadecimal equivalent  
A    7
 
Hence the hexadecimal equivalent of (247)8 is (A7)16.
Example 1.25. Convert (36.532)8 into an equivalent hexadecimal number.
Solution. 
Given octal number is 
3  6  5  3  2
 
Binary equivalent is  
011 110 101 011 010
 
 
=011110.101011010
 
Forming groups of 4 bits 
0001 1110. 1010 1101
 
Hexadecimal equivalent  
 1   E.   A   D
 
Hence the hexadecimal equivalent of (36.532)8 is (1E.AD)16.
1.4  COMPLEMENTS
Complements are used in digital computers for simplifying the subtraction operation and 
for logical manipulations. There are two types of complements for each number system of 
base-r: the r’s complement and the (r – 1)’s complement. When we deal with a binary system 
the value of r is 2 and hence the complements are 2’s and 1’s complements. Similarly for 
a decimal system the value of r is 10 and we get 10’s and 9’s complements. With the same 
logic if the number system is octal we get 8’s and 7’s complement, while it is 16’s and 15’s 
complements for hexadecimal system.
1.4.1 The r’s Complement
If a positive number N is given in base r with an integer part of n digits, the r’s 
complement of N is given as rn–N for N z 0 and 0 for N = 0. The following examples will 
clarify the deﬁ nition.
The 10’s complement of (23450)10 is 
105 – 23450 = 76550.
The number of digits in the number is 
n = 5.
The 10’s complement of (0.3245)10 is 
100 – 0.3245 = 0.6755.
Since the number of digits in the integer part of the number is n = 0, we have 100 = 1.
The 10’s complement of (23.324)10 is 
102 – 23.324 = 76.676.
The number of digits in the integer part of the number is n = 2.
Now if we consider a binary system, then r = 2.
The 2’s complement of (10110)2 is 
(25)10–(10110)2 = (100000 – 10110)2 = 01010.
The 2’s complement of (0.1011)2 is 
(20)10–(0.1011)2 = (1 – 0.1011)2 = 0.0101.
Now if we consider an octal system, then r = 8.
The 8’s complement of (2450)8 is 
(84)10 – (2450)8.

DATA AND NUMBER SYSTEMS 11
 
 
 
 
 
 
 
 
= (409610 – 24508)
 
 
 
 
 
 
 
 
= (409610 – 132010)
 
 
 
 
 
 
 
 
= 277610.
 
 
 
 
 
 
 
 
= 53308.
Now if we consider a hexadecimal system, then r = 16.
The 16’s complement of (4A30)16 is 
 
(164)10 – (4A30)16
 
 
 
 
 
 
 
 
= (6553610 – 4A3016)
 
 
 
 
 
 
 
 
= (6553610 – 1899210)
 
 
 
 
 
 
 
 
= 4654410
 
 
 
 
 
 
 
 
= B5D016.
From the above examples, it is clear that to ﬁ nd the 10’s complement of a decimal number 
all of the bits until the ﬁ rst signiﬁ cant 0 is left unchanged and the ﬁ rst nonzero least-signiﬁ cant 
digit is subtracted from 10 and the rest of the higher signiﬁ cant digits are subtracted from 9. 
With a similar reasoning, the 2’s complement of a binary number can be obtained by leaving 
all of the least signiﬁ cant zeros and the ﬁ rst nonzero digit unchanged, and then replacing 1’s 
with 0’s and 0’s with 1’s. Similarly the 8’s complement of an octal number can be obtained 
by keeping all the bits until the ﬁ rst signiﬁ cant 0 is unchanged, and the ﬁ rst nonzero least-
signiﬁ cant digit is subtracted from 8 and the rest of the higher signiﬁ cant digits are subtracted 
from 7. Similarly, the 16’s complement of a hexadecimal number can be obtained by keeping all 
the bits until the ﬁ rst signiﬁ cant 0 is unchanged, and the ﬁ rst nonzero least-signiﬁ cant digit 
is subtracted from 16 and the rest of the higher signiﬁ cant digits are subtracted from 15.
Since r’s complement is a general term, r can take any value e.g., r = 11. Then we will 
have 11’s complement for r’s complement case and 10’s complement for (r – 1)’s complement 
case.
1.4.2 The (r–1)’s Complement
If  a positive number N is given in base r with an integer part of n digits and a 
fraction part of m digits, then the (r – 1)’s complement of N is given as (rn – r–m – N)  for 
N z 0 and 0 for N = 0. The following examples will clarify the deﬁ nition.
The 9’s complement of (23450)10 is 
105 – 100 – 23450 = 76549.
Since there is no fraction part, 
10–m = 100 = 1.
The 9’s complement of (0.3245)10 is 
100 – 10–4 – 0.3245 = 0.6754.
Since there is no integer part, 
10n = 100 = 1.
The 9’s complement of (23.324)10 is 
102 – 10–3 – 23.324 = 76.675.
Now if we consider a binary system, then r = 2, i.e., (r – 1) = 1.
The 1’s complement of (10110)2 is  
(25–1)10 – (10110)2 = 01001.
The 1’s complement of (0.1011)2 is 
(1–2–4)10 – (0.1011)2 = 0.0100.
Now if we consider an octal system, then r = 8, i.e., (r – 1) = 7.
The 7’s complement of (2350)8 is 
84 – 80 – 23508
 
 
= 409510 – 125610

12
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
= 283910
 
 
= 54278.
The 15’s complement of (A3E4)16 is  
164 – 160 – A3E416
 
 
= 6553510 – 4195610
 
 
= 2357910
 
 
= 5C1B16.
From the above examples, it is clear that to ﬁ nd the 9’s complement of a decimal 
number each of the digits can be separately subtracted from 9. The 1’s complement of a 
binary number can be obtained by changing 1s into 0s and 0s into 1s. Similarly, to ﬁ nd 
the 7’s complement of a decimal number each of the digits can be separately subtracted 
from 7. Again, to ﬁ nd the 15’s complement of a decimal number each of the digits can be 
separately subtracted from 15.
Example 1.26. Find out the 11’s and 10’s complement of the number (576)11.
Solution.
The number in base is 11. So to ﬁ nd 11’s complement we have to follow the r’s 
complement rule and in order to get 10’s complement the (r – 1)’s complement rule is to 
be followed. 
11’s complement:
rn – N = 113 – 57611
           = (1331)10 – (576)11
Now,     57611  = 5 × 112 + 7 × 111 + 6 × 110
           = 605 + 77 + 6
           = 68810
Therefore, 11’s complement is 133110 – 68810 = 64310
Now, the decimal number has to be changed in the number system of base 11.
 
Division 
Quotient 
Generated remainder
643
11  
58 
5
58
11  
5 
3
5
11 
0 
5
Hence the 11’s complement number is (535)11.
10’s complement:
rn – r–m – N = 113 – 110 – 57611
            = (1331)10 – (1)10 – (576)11
Therefore, 10’s complement is 133110 – 110 – 68810 = 64210

DATA AND NUMBER SYSTEMS 13
Now, the decimal number has to be changed in the number system of base 11.
 
Division 
Quotient 
Generated remainder
642
11  
58 
4
58
11 
5 
3
5
11 
0 
5
Hence the 10’s complement number is (534)11.
1.5 BINARY ARITHMETIC
We are very familiar with different arithmetic operations, viz. addition, subtraction, 
multiplication, and division in a decimal system. Now we want to ﬁ nd out how those same 
operations may be performed in a binary system, where only two digits, viz. 0 and 1 exist. 
1.5.1 Binary Addition
The rules of binary addition are given in Table 1.1.
Table 1.1
Augend 
Addend 
Sum 
Carry 
Result  
 
0 
0 
0 
0 
0
 
0 
1 
1 
0 
1
 
1 
0 
1 
0 
1
 
1 
1 
0 
1 
10
The procedure of adding two binary numbers is same as that of two decimal numbers. 
Addition is carried out from the LSB and it proceeds to higher signiﬁ cant bits, adding the 
carry resulting from the addition of two previous bits each time.
Example 1.27. Add the binary numbers:
 
 
(a) 1010 and 1101 
 
(b) 0110 and 1111
Solution.
(a) 
 
1 
0 
1 
0
 
 
 
(+) 
1 
1 
0 
1
 
 
 
1 
0 
1 
1 
1
 
 
 
 
 
Carry
 
 
(b)  
 
(1) 
(1) 

 
  Carry
 
 
 
 
 0 
 1 
 1 
  0
 
 
 
(+) 
 1 
 1 
 1 
  1
 
 
 
1 
 0 
 1 
 0 
  1
 
 
 
 
 
 
Carry

14
DIGITAL PRINCIPLES AND LOGIC DESIGN
1.5.2 Binary Subtraction
The rules of binary subtraction are given in Table 1.2.
Table 1.2
Minuend 
Subtrahend 
Difference 
Borrow 
 
0 
0 
0 
0
 
0 
1 
1 
1
 
1 
0 
1 
0
 
1 
1 
0 
0 
Binary subtraction is also carried out in a similar method to decimal subtraction. The 
subtraction is carried out from the LSB and proceeds to the higher signiﬁ cant bits. When 
borrow is 1, as in the second row, this is to be subtracted from the next higher binary bit 
as it is performed in decimal subtraction.
Actually, the subtraction between two numbers can be performed in three ways, viz.
 (i) the direct method, 
 (ii) the r’s complement method, and 
 (iii) the (r – 1)’s complement method.
Subtraction Using the Direct Method
The direct method of subtraction uses the concept of borrow. In this method, we 
borrow a 1 from a higher signiﬁ cant position when the minuend digit is smaller than the 
corresponding subtrahend digit. 
Example 1.28. Using the direct method to perform the subtraction
 
 
 
1001 – 1000. 
Solution:
 
 
 
 
1  0  0  1
 
 
        (–) 
1  0  0  0
 
 
 
 
0  0  0  1
Example 1.29. Using the direct method to perform the subtraction 
 
 
 
1000 – 1001. 
Solution.
 
 
 
 
1  0  0  0
 
 
        (–) 
1  0  0  1
End carry 
1  1  1  1  1
End carry has to be ignored.
Answer:  1111 = (2’s complement of 0001).
When the minuend is smaller than the subtrahend the result of subtraction is negative 
and in the direct method the result obtained is in 2’s complement form. So to get back the 
actual result we have to perform the 2’s complement again on the result thus obtained.
But to tackle the problem shown in Example 1.29 we have applied a trick. When a 

DATA AND NUMBER SYSTEMS 15
digit is smaller in the minuend than that in the subtrahend we add 2 (the base of the 
binary system) to the minuend digit mentally and we perform the subtraction (in this case 
1 from 2) in decimal and write down the result in the corresponding column. Since we have 
added 2 to the column, we have to add 1 to the subtrahend digit in the next higher order 
column. This process is to be carried on for all of the columns whenever the minuend digit 
is smaller than the corresponding subtrahend digit.
The rest of the two binary subtraction methods, i.e., the r’s complement and the (r
– 1)’s complement methods will be discussed in due course.
 
 
 
 
 
(+2)    (+2)    (+2)    (+2)
 
 
 
 
 
  1 
  0 
  0 
   0
 
 
 
 
 
  1     0      0            1
 
 
 
 
(+1)  
(+1)  
(+1)      (+1)
End carry 
      1   1   1    1   1
End carry has to be ignored.
1.5.3 Binary Multiplication
Binary multiplication is similar to decimal multiplication but much simpler than that. 
In a binary system each partial product is either zero (multiplication by 0) or exactly the 
same as the multiplicand (multiplication by 1). The rules of binary multiplication are given 
in Table 1.3.
Table 1.3
Multiplicand 
Multiplier 
Result
 
0 
0 
0
 
0 
1 
0
 
1 
0 
0
 
1 
1 
1
Actually, in a digital circuit, the multiplication operation is done by repeated additions 
of all partial products to obtain the full product.
Example 1.30. Multiply the following binary numbers: 
(a) 0111 and 1101 and (b) 1.011 and 10.01.
Solution.
 
 
(a) 
0111 × 1101
 
 
 
 
 
 
0 
1 
1 
1 
Multiplicand
 
 
 
 
 
    × 
1   
1   
0   
1 
Multiplier
 
 
 
 
 
 
0 
1 
1 
1
 
 
 
 
 
0 
0 
0 
0 
 
Partial
 
 
 
 
0 
1 
1 
1 
 
 
Products
 
 
 
0 
1 
1 
1
 
 
 
1 
0 
1 
1 
0 
1 
1 
Final Product

16
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
(b)  1.011 × 10.01 
 
     
 
 
 
 
 
 
1. 
0 
1 
1 
Multiplicand
 
 
 
 
 
   × 1  
0. 
0 
1 
Multiplier
 
 
 
 
 
 
1 
0 
1 
1
 
 
 
 
 
0 
0 
0 
0 
 
Partial
 
 
 
 
0 
0 
0 
0 
 
 
Products
 
 
 
1 
0 
1 
1
 
 
 
1 
1 . 
0 
0 
0 
1 
1 
Final Product
1.5.4 Binary Division
Binary division follows the same procedure as decimal division. The rules regarding 
binary division are listed in Table 1.4.
Table 1.4
Dividend 
Divisor 
Result 
 
0 
0 
Not allowed
 
0 
1 
0
 
1 
0 
Not allowed
 
1 
1 
1
Example 1.31. Divide the following binary numbers: 
(a) 11001 and 101 and (b) 11110 and 1001.
Solution.
 
 
 
(a)  11001 y 101
 
 
 
 
 
 
 
1 
0 
1 
 
 
 
 
1 
 0 
 1 
1  
1  
0  
0  
1
 
 
 
 
 
 
 
1 
0 
1
 
 
 
 
 
 
 
0 
0 
1 
0 
1
 
 
 
 
 
 
 
 
 
1 
0 
1
 
 
 
 
 
 
 
 
 
0 
0 
0
 
 
Answer: 101
 
 
(b)  11110 y 1001
 
 
 
 
 
 
 
1 
1. 
0 
1 
0
 
 
1 
 0 
0 
1 
1  
1  
1  
1  
0
 
 
 
 
 
 
 
1 
0 
0 
1
 
 
 
 
 
 
0 
1 
1 
0 
0
 
 
 
 
 
 
 
1 
0 
0 
1

DATA AND NUMBER SYSTEMS 17
 
 
 
 
 
 
 
1 
0 
0 
0 
0
 
 
 
 
 
 
 
 
1 
0 
0 
1
 
 
 
 
 
 
 
 
 
1 
1 
0
 
 
 
 
 
 
 
 
1 
0 
0 
1
 
 
 
 
 
 
 
 
 
1 
0 
1
 
 
Answer: 11.010
1.6  1’S AND 2’S COMPLEMENT ARITHMETIC
Digital circuits perform binary arithmetic operations. It is possible to use the circuits designed 
for binary addition to perform binary subtraction. Only we have to change the problem of 
subtraction into an equivalent addition problem. This can be done if we make use of 1’s 
and 2’s complement form of the binary numbers as we have already discussed.
1.6.1 Subtraction Using 1’s Complement
Binary subtraction can be performed by adding the 1’s complement of the subtrahend to 
the minuend. If a carry is generated, remove the carry, add it to the result. This carry is called 
the end-around carry. Now if the subtrahend is larger than the minuend, then no carry is 
generated. The answer obtained is 1’s complement of the true result and opposite in sign.
Example 1.32. Subtract (1001)2 from (1101)2 using the 1’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
 
Direct Subtraction 
 
 
1’s complement method
 
 
 
 
1 1 0 1  
 
 
 
1 1 0 1   (+)
 
 
 
   – 
1 0 0 1  
1’s complement 
 
0 1 1 0
 
 
 
 
0 1 0 0  
  Carry    
1 0 0 1 1
 
 
 
 
 
 
  Add Carry 
 
       1
 
 
 
 
 
 
 
 
 
0 1 0 0
Example 1.33. Subtract (1100)2 from (1001)2 using the 1’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
   Direct Subtraction  
 
 
1’s complement method
 
 
 
  1 0 0 1 
 
 
 
 
  1 0 0 1  (+)
 
 
 
– 1 1 0 0 
  1’s complement  
 
  0 0 1 1
Carry
 
1 1 1 0 1 
 
 
 
 
  1 1 0 0
2’s complement 
  0 0 1 1 
  1’s complement 
 
  0 0 1 1
True result 
  0 0 1 1 
    True result 
 
– 0 0 1 1
In the direct method, whenever a larger number is subtracted from a smaller number, 
the result obtained is in 2’s complement form and opposite in sign. To get the true result 
we have to discard the carry and make the 2’s complement of the result obtained and put 
a negative sign before the result.

18
DIGITAL PRINCIPLES AND LOGIC DESIGN
In the 1’s complement subtraction, no carry is obtained and the result obtained is in 
1’s complement form. To get the true result we have to make the 1’s complement of the 
result obtained and put a negative sign before the result.
1.6.2 Subtraction Using 2’s Complement
Binary subtraction can be performed by adding the 2’s complement of the subtrahend 
to the minuend. If a carry is generated, discard the carry. Now if the subtrahend is larger 
than the minuend, then no carry is generated. The answer obtained is in 2’s complement 
and is negative. To get a true answer take the 2’s complement of the number and change the 
sign. The advantage of the 2’s complement method is that the end-around carry operation 
present in the 1’s complement method is not present here.
Example 1.34. Subtract (0111)2 from (1101)2 using the 2’s complement method. Also 
subtract using the direct method and compare.
Solution.
 
 
 
Direct Subtraction 
 
 
1’s complement method
 
 
 
1 1 0 1  
 
 
 
 
 1 1 0 1     (+)
 
 
   – 0 1 1 1  
 
2’s complement 
 
 1 0 0 1
 
 
 
0 1 1 0  
 
Carry      
  
1 0 1 1 0
 
 
 
 
 
 
Discard Carry  
 0 1 1 0 (Result)
Example 1.35. Subtract (1010)2 from (1001)2 using the 1’s complement method. Also 
subtract using the direct method and compare.
Solution.
 
 
 
Direct Subtraction 
 
 
1’s complement method
 
 
 
1 0 0 1  
 
 
 
 
1 0 0 1     (+)
 
 
   – 1 0 1 0  
 
2’s complement 
 
0 1 1 0
Carry
   1 1 1 1 1  
 
 
 
 
1 1 1 1
2’s complement 
0 0 0 1  
 
2’s complement 
 
0 0 0 1
True result 
–0001  
 
  True result 
–0001
In the direct method, whenever a larger number is subtracted from a smaller number, 
the result obtained is in 2’s complement form and opposite in sign. To get the true result 
we have to discard the carry and make the 2’s complement of the result obtained and put 
a negative sign before the result. 
In the 2’s complement subtraction, no carry is obtained and the result obtained is in 
2’s complement form. To get the true result we have to make the 2’s complement of the 
result obtained and put a negative sign before the result. 
1.6.3 Comparison between 1’s and 2’s Complements
A comparison between 1’s and 2’s complements reveals the advantages and disadvantages 
of each.
 (i)  The 1’s complement has the advantage of being easier to implement by digital 
components (viz. inverter) since the only thing to be done is to change the 1s to 0s and 
vice versa. To implement 2’s complement we can follow two ways: (1) by ﬁ nding out the 
1’s complement of the number and then adding 1 to the LSB of the 1’s complement, 

DATA AND NUMBER SYSTEMS 19
and (2) by leaving all leading 0s in the LSB positions and the ﬁ rst 1 unchanged, and 
only then changing all 1’s to 0s and vice versa.
 (ii)  During subtraction of two numbers by a complement method, the 2’s complement 
is advantageous since only one arithmetic addition is required. The 1’s complement 
requires two arithmetic additions when an end-around carry occurs.
 (iii)  The 1’s complement has an additional disadvantage of having two arithmetic zeros: 
one with all 0s and one with all 1s. The 2’s complement has only one arithmetic zero. 
The fact is illustrated below:
We consider the subtraction of two equal binary numbers 1010 – 1010.
Using 1’s complement:
 
 1010
 
+ 0101 (1’s complement of 1010)
 
+ 1111 (negative zero)
We complement again to obtain (– 0000) (positive zero).
Using 2’s complement:
 
 1010
 
+ 0110 (2’s complement of 1010)
 
+ 0000
In this 2’s complement method no question of negative or positive zero arises. 
1.7 SIGNED BINARY NUMBERS
So far whatever discussions were made, there was no consideration of sign of the numbers. But 
in real life one may have to face a situation where both positive and negative numbers may 
arise. So we have to know how the positive and negative binary numbers may be represented. 
Basically there are three types of representations of signed binary numbers— sign-magnitude 
representation, 1’s complement representation, and 2’s complement representations, which 
are discussed below.
1.7.1 Sign-magnitude Representation
In decimal system, generally a plus (+) sign denotes a positive number whereas a 
minus (–) sign denotes a negative number. But, the plus sign is usually dropped, and no 
sign means the number is positive. This type of representation of numbers is known as 
signed numbers. But in digital circuits, there is no provision to put a plus or minus sign, 
since everything in digital circuits have to be represented in terms of 0 and 1. Normally an 
additional bit is used as the sign bit. This sign bit is usually placed as the MSB. Generally a 
0 is reserved for a positive number and a 1 is reserved for a negative number. For example, 
an 8-bit signed binary number 01101001 represents a positive number whose magnitude 
is (1101001)2 = (105)10. The MSB is 0, which indicates that the number is positive. On 
the other hand, in the signed binary form, 11101001 represents a negative number whose 
magnitude is (1101001)2 = (105)10. The 1 in the MSB position indicates that the number is 
negative and the other seven bits give its magnitude. This kind of representation of binary 
numbers is called sign-magnitude representation.

20
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 1.36. Find the decimal equivalent of the following binary numbers assuming 
the binary numbers have been represented in sign-magnitude form.
 
(a) 0101100 
 
(b) 101000 
 
(c) 1111  
(d) 011011
Solution.
 
 
(a) 
Sign bit is 0, which indicates the number is positive.
 
 
 
Magnitude 
 
101100 = (44)10
 
 
 
Therefore 
 
(0101100)2 = (+44)10.
 
 
(b) 
Sign bit is 1, which indicates the number is negative.
 
 
 
Magnitude 
 
01000 = (8)10
 
 
 
Therefore 
 
(101000)2 = (–8)10.
 
 
(c) 
Sign bit is 1, which indicates the number is negative.
 
 
 
Magnitude 
 
111 = (7)10
 
 
 
Therefore 
 
(1111)2 = (–7)10.
 
 
(d) 
Sign bit is 0, which indicates the number is positive.
 
 
 
Magnitude 
 
11011 = (27)10
 
 
 
Therefore 
 
(011011)2 = (+27)10.
1.7.2 1’s Complement Representation
In 1’s complement representation, both numbers are a complement of each other. If one 
of the numbers is positive, then the other will be negative with the same magnitude and 
vice versa. For example, (0111)2 represents (+ 7)10, whereas (1000)2 represents (– 7)10 in 1’s 
complement representation. Also, in this type of representation, the MSB is 0 for positive 
numbers and 1 for negative numbers.
Example 1.37. Represent the following numbers in 1’s complement form.
 
 
 
(a) +5 and –5 (b) +9 and –9 (c) +15 and –15
Solution.
 
 
(a)  
 
(+5)10 = (0101)2
 
 
         and 
(–5)10 = (1010)2
 
 
(b)  
 
(+9)10 = (01001)2
 
 
         and 
(–9)10 = (10110)2
 
 
(c)  
 
(+15)10 = (01111)2
 
 
         and 
(–15)10 = (10000)2
From the above examples it can be observed that for an n-bit number, the maximum 
positive number which can be represented in 1’s complement form is (2n–1–1) and the 
maximum negative number is –(2n–1 – 1).
1.7.3 2’s Complement Representation
If 1 is added to 1’s complement of a binary number, the resulting number is 2’s 
complement of that binary number. For example, (0110)2 represents (+6)10, whereas (1010)2
represents (–6)10 in 2’s complement representation. Also, in this type of representation, 

DATA AND NUMBER SYSTEMS 21
the MSB is 0 for positive numbers and 1 for negative numbers. For an n-bit number, the 
maximum positive number which can be represented in 2’s complement form is (2n–1–1) and 
the maximum negative number is –2n–1.
Example 1.38. Represent the following numbers in 2’s complement form.
 
 
(a) +11 and –11 
 
(b) +9 and –9  
(c) +18 and –18
Solution.
 
 
(a) 
 
(+11)10 = (01011)2
 
 
 
and 
(–11)10 = (10101)2
 
 
(b)  
 
(+9)10 = (01001)2
 
 
 
and 
(–9)10 = (10111)2
 
 
(c) 
 
(+18)10 = (010010)2
 
 
 
and 
(–18)10 = (101110)2
Example 1.39. Represent (–19) in
 
   (a) Sign-magnitude, 
 
   (b) one’s complement, and
 
   (c) two’s complement representation.
Solution.
The minimum number of bits required to represent (+19)10 in signed number format is six.
Therefore,  
(+19)10 = (010011)2
Therefore, 
(–19)10 is represented by
 
 
(a) 
110011 in sign-magnitude representation.
 
 
(b) 
101100 in 1’s complement representation.
 
 
(c) 
101101 in 2’s complement representation. 
1.8  7’s AND 8’s COMPLEMENT ARITHMETIC
The 7’s complement of an octal number can be found by subtracting each digit in the number 
from 7. The 8’s complement can be obtained by subtracting the LSB from 8 and the rest 
of each digit in the number from 7. The 7’s and 8’s complement of the octal digits 0 to 7 
is shown in Table 1.5. 
The method of subtraction using 7’s complement method is the same as 1’s complement 
method in binary system. Here also the carry obtained is added to the result to get the 
true result. And as in the previous cases, if the minuend is larger than the subtrahend, 
no carry is obtained and the result is obtained in 7’s complement form. To get the true 
result we have to again get the 7’s complement of the result obtained and put a negative 
sign before it.
Similarly, the method of subtraction using 8’s complement method is the same as 2’s 
complement method in a binary system. Here also the carry obtained is discarded to get the 
true result. And as in the previous cases, if the minuend is larger than the subtrahend, no carry 
is obtained and the result is obtained in 8’s complement form. To get the true result we have 
to again get the 8’s complement of the result obtained and put a negative sign before it.

22
DIGITAL PRINCIPLES AND LOGIC DESIGN
Table 1.5
Octal digit 
7’s complement 
8’s complement
 
0 
7 
8
 
1 
6 
7
 
2 
5 
6
 
3 
4 
5
 
4 
3 
4
 
5 
2 
3
 
6 
1 
2
 
7 
0 
1
1.8.1 Subtraction Using 7’s Complement
Example 1.40. Subtract (372)8 from (453)8 using the 7’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
 
Direct Subtraction 
 
 
7’s complement method
 
 
 
   4 5 3 
 
 
 
 
 4 5 3      (+)
 
 
 
  – 3 7 2 
 
7’s complement  
  4 0 5
 
 
 
    6 1 
 
 
 
 
1 0 6 0
 
 
 
 
 
 
Add Carry    
     1
 
 
 
 
 
 
 
 
 
  (6 1)8 (Result)
Example 1.41. Subtract (453)8 from (372)8 using the 7’s complement method. Also 
subtract using the direct method and compare.
Solution.
 
 
 
Direct Subtraction 
 
 
7’s complement method
 
 
 
   3 7 2 
 
 
 
 
 3 7 2      (+)
 
 
 
   4 5 3 
 
7’s complement 
  3 2 4
 
 
 
  1 7 1 7 
 
 
 
 
 7 1 6
Discard Carry  
   7 1 7 
 
7’s complement 
   6 1
8’s complement 
    6 1
True result 
    (–61)8  
True result  
     
  (–61)8
In the direct method, whenever a larger number is subtracted from a smaller number, 
the result obtained is in 8’s complement form and opposite in sign. To get the true result 
we have to discard the carry and make the 8’s complement of the result obtained and put 
a negative sign before the result.
1.8.2 Subtraction Using 8’s Complement
Example 1.42. Subtract (256)8 from (461)8 using the 8’s complement method. Also 
subtract using the direct method and compare. 

DATA AND NUMBER SYSTEMS 23
Solution.
 
 
  Direct Subtraction  
 
8’s complement method
 
 
 
4 6 1 
 
 
 
 
 4 6 1      (+)
 
 
  – 2 5 6 
 
8’s complement 
  5 2 2
 
 
 
2 0 3 
 
   Carry   
  1 2 0 3
 
 
 
 
 
Discard Carry  
 (2 0 3)8 (Result)
Example 1.43. Subtract (461)8 from (256)8 using the 8’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
  Direct Subtraction  
 
8’s complement method
 
 
 
2 5 6 
 
 
 
 
 2 5 6      (+)
 
 
  – 4 6 1 
 
8’s complement 
  3 1 7
 
 
   1 5 7 5 
 
 
 
 
 5 7 5
Discard Carry    5 7 5 
 
8’s complement 
  2 0 3 
8’s complement  2 0 3
 
  True result (–203)8  
  True result 
 (–203)8
In the direct method, whenever a larger number is subtracted from a smaller number, 
the result obtained is in 8’s complement form and opposite in sign. To get the true result 
we have to discard the carry and make the 8’s complement of the result obtained and put 
a negative sign before the result.
1.9 9’s AND 10’s COMPLEMENT ARITHMETIC
The 9’s complement of a decimal number can be found by subtracting each digit in the 
number from 9. The 10’s complement can be obtained by subtracting the LSB from 10 and 
the rest of each digit in the number from 9. The 9’s and 10’s complement of the decimal 
digits 0 to 9 is shown in Table 1.6.
Table 1.6
Decimal digit 
9’s complement 
10’s complement 
 
0 
9 
10
 
1 
8 
9
 
2 
7 
8
 
3 
6 
7
 
4 
5 
6
 
5 
4 
5
 
6 
3 
4
 
7 
2 
3
 
8 
1 
2
 
9 
0 
1

24
DIGITAL PRINCIPLES AND LOGIC DESIGN
The method of subtraction using 9’s complement method is the same as 1’s complement 
method in a binary system. Here also the carry obtained is added to the result to get the true 
result. And as in the previous cases, if the minuend is larger than the subtrahend, no carry 
is obtained and the result is obtained in 9’s complement form. To get the true result we have 
to again get the 9’s complement of the result obtained and put a negative sign before it.
Similarly, the method of subtraction using 10’s complement method is the same as 2’s 
complement method in a binary system. Here also the carry obtained is discarded to get 
the true result. And as in the previous cases, if the minuend is larger than the subtrahend, 
no carry is obtained and the result is obtained in 10’s complement form. To get the true 
result we have to again get the 10’s complement of the result obtained and put a negative 
sign before it.
1.9.1 Subtraction Using 9’s Complement
Example 1.44. Subtract (358)10 from (592)10 using the 9’s complement method. Also 
subtract using the direct method and compare.
Solution.
 
 
 Direct Subtraction  
 
 
9’s complement method
 
 
    5 9 2  
 
 
 
    5 9 2      (+)
 
 
  –  3 5 8  
9’s complement 
     6 4 1
 
 
    2 3 4  
 
 
 
   1 2 3 3
 
 
 
 
 
Add Carry   
 
 
   1
 
 
 
 
 
 
 
 
 
(2 3 4)10 (Result)
Example 1.45. Subtract (592)10 from (358)10 using the 9’s complement method. Also 
subtract using the direct method and compare.
Solution.
 
 
 Direct Subtraction  
 
 
9’s complement method
 
 
    3 5 8  
 
 
 
    3 5 8      (+)
 
 
  –  5 9 2  
9’s complement
     4 0 7
 
 
  – 1 7 6 6  
  
 
    7 6 5
Discard carry 
 7 7 6  
9’s complement 
     2 3 4
10’s complement 2 3 4  
True result 
 
 
 (–234)10
True result 
 (–234)10
1.9.2 Subtraction Using 10’s Complement
Example 1.46. Subtract (438)10 from (798)10 using the 10’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
 Direct Subtraction  
 
 
10’s complement method
 
 
    7 9 8  
 
 
 
    7 9 8      (+)
 
 
  –  4 3 8  
10’s complement 
     5 6 2
 
 
 
 3 6 0  
 
Carry   
1 3 6 0
 
 
 
 
 
Discard Carry  
    (3 6 0)10 (Result)

DATA AND NUMBER SYSTEMS 25
Example 1.47. Subtract (798)10 from (438)10 using the 10’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
  Direct Subtraction  
 
10’s complement method
 
 
    4 3 8  
 
 
 
  4 3 8      (+)
 
 
  –  7 9 8  
10’s complement 
   2 0 2
 
 
   1 6 4 0  
 
 
 
  6 4 0
Discard carry    6 4 0  
10’s complement 
    3 6 0 
10’s complement 3 6 0  
True result 
 
  (–360)10
True result    (–360)10
1.10  15’s AND 16’s COMPLEMENT ARITHMETIC
The 15’s complement of a hexadecimal number can be found by subtracting each digit in 
the number from 15. The 16’s complement can be obtained by subtracting the LSB from 
16 and the rest of each digit in the number from 15. The 15’s and 16’s complement of the 
hexadecimal digits 0 to F is shown in Table 1.7. 
Table 1.7
Hexadecimal digit 
15’s complement 
16’s complement 
 
0 
15 
16
 
1 
14 
15
 
2 
13 
14 
 
3 
12 
13
 
4 
11 
12
 
5 
10 
11
 
6 
9 
10
 
7 
8 
9
 
8 
7 
8
 
9 
6 
7
 
A 
5 
6
 
B 
4 
5
 
C 
3 
4
 
D 
2 
3
 
E 
1 
2
 
F 
0 
1
The method of subtraction using 15’s complement method is the same as 9’s complement 
method in a decimal system. Here also the carry obtained is added to the result to get the true 
result. And as in the previous cases, if the minuend is larger than the subtrahend, no carry is 
obtained and the result is obtained in 15’s complement form. To get the true result we have 
to again get the 15’s complement of the result obtained and put a negative sign before it.

26
DIGITAL PRINCIPLES AND LOGIC DESIGN
Similarly, the method of subtraction using 16’s complement method is the same as 
10’s complement method in a decimal system. Here also the carry obtained is discarded 
to get the true result. And as in the previous cases, if the minuend is larger than the 
subtrahend, no carry is obtained and the result is obtained in 16’s complement form. To 
get the true result we have to again get the 16’s complement of the result obtained and 
put a negative sign before it.
1.10.1 Subtraction Using 15’s Complement
Example 1.48. Subtract (2B1)16 from (3A2)16 using the 15’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
 Direct Subtraction  
 
15’s complement method
 
 
    
3 A 2  
 
 
 
 3 A 2      (+)
 
 
  –  2 B 1  
15’s complement 
 D 4 E
 
 
     F 1  
 
 
 
1 0 F 0
 
 
 
 
 
Add Carry    
   1
 
 
 
 
 
 
 
 
  (F 1)16 (Result)
Example 1.49. Subtract (3A2)16 from (2B1)16 using the 15’s complement method. Also 
subtract using the direct method and compare.
Solution.
 
 
 Direct Subtraction  
 
15’s complement method
 
 
    2 B 1  
 
 
 
 2 B 1      (+)
 
 
 –
3 A 2  
15’s complement 
 C 5 D
 
 
   1 F 0 F  
 
 
 
 F 0 E
Discard Carry  F 0 F  
15’s complement 
 F 1
16’s complement F 1
True result    (–F1)16 
  True result 
  (–F1)16
In the direct method, whenever a larger number is subtracted from a smaller number, 
the result obtained is in 16’s complement form and opposite in sign. To get the true result 
we have to discard the carry and make the 16’s complement of the result obtained and put 
a negative sign before the result.
1.10.2 Subtraction Using 16’s Complement
Example 1.50. Subtract (1FA)16 from (2DC)16 using the 16’s complement method. Also 
subtract using the direct method and compare.
Solution.
 
 
 Direct Subtraction  
 
16’s complement method
 
 
     2 D C  
 
 
      2 D C      (+)
 
 
 –   1 F A  
16’s complement 
   E 0 6
 
 
 
  E 2  
 
Carry         1 0 E 2
 
 
 
 
 
Discard Carry  
  (E 2)16 (Result)

DATA AND NUMBER SYSTEMS 27
Example 1.51. Subtract (2DC)16 from (1FA)16 using the 16’s complement method. Also 
subtract using the direct method and compare. 
Solution.
 
 
 Direct Subtraction  
 
 
16’s complement method
 
 
 
1 F A  
 
 
 
 
1 F A      (+)
 
 
   –2 D C  
16’s complement 
  
D 2 4
 
 
    1 0 1 E  
 
 
 
 
F 1 E
Discard carry   1 E  
16’s complement 
  
 E 2 
16’s complement  E 2
True result 
 (–E2)16  
   True result 
 
 (–E2)16
1.11 BCD ADDITION
The full form of BCD is Binary Coded Decimal. We will discuss this in detail in the next 
chapter. The only thing we want to mention here is that, in this code, each decimal digit 
from 1 to 9 is coded in 4-bit binary numbers. But with 4-bit binary sixteen different groups 
can be obtained, whereas we require only ten groups to write BCD code. The other six groups 
are called forbidden codes in BCD and they are invalid for BCD. BCD is a numerical code. 
Many applications require arithmetic operation. Addition is the most important of these 
because the other three operations, viz. subtraction, multiplication, and division, can be 
performed using addition.
There are certain rules to be followed in BCD addition as given below.
 (i) First add the two numbers using normal rules for binary addition.
 (ii) If the 4-bit sum is equal to or less than 9, it becomes a valid BCD number.
 (iii) If the 4-bit sum is greater than 9, or if a carry-out of the group is generated, it is an 
invalid result. In such a case, add (0110)2 or (6)10 to the 4-bit sum in order to skip 
the six invalid states and return the code to BCD. If a carry results when 6 is added, 
add the carry to the next 4-bit group.
Example 1.52. Add the following BCD numbers: 
(a) 0111 and 1001 and (b) 10010010 and 01011000. 
Solution.
(a) 
 
 
0  1  1  1
 
 
 
+ 1  0  0  1
 
 
 
1 0  0  0  0 
 
 
Invalid BCD number
 
 
 
+ 0  1  1  0 
 
 
Add 6
 
 
0  0  0  1   0  1  1  0 
 
 
Valid BCD number
  1             6

28
DIGITAL PRINCIPLES AND LOGIC DESIGN
(b) 
     1 0 0 1 
0  0  1  0
 
    + 0 1 0 1 
1  0  0  0
   1 1 1 0 
1  0  1  0 
 
Both groups are invalid
 + 0 1 1 0 
0  1  1  0 
 
Add 6
 
0  0  0  1    0 1 0 1 
0  0  0  0 
 
Valid BCD number
                   1             5       0
1.12  BCD SUBTRACTION
There are two methods that can be followed for BCD subtraction.
METHOD 1. In order to subtract any number from another number we have to add 
the 9’s complement of the subtrahend to the minuend. We can use the 10’s complement also 
to perform the subtraction operation.
Example 1.53. Carry out BCD subtraction for (893) – (478) using 9’s complement method. 
Solution.
 
9’s complement of 478 is    
999
 
 
 – 478
 
 
  
521
 
Direct method 
  
893
 
 
 – 478
 
 
  
415
Now in BCD form we may write   
1000 1001 0011
 
 
 + 0101 0010 0001
 
 
  
1101 1011 0100 Left and middle groups are invalid
 
 
 + 0110 0110   
Add 6
 
 
1  
0100 0001 0100
 
 
  
 
 
    1 End around carry
 
 
  
0100 0001 0101
Hence, the ﬁ nal result is (0100 0001 0101)2 or (415)10.
Example 1.54. Carry out BCD subtraction for (768) – ( 274) using 10’s complement 
method.
Solution.
 
10’s complement of 274 is  9910
 
 
– 274
 
 
   726
 
Direct method 
 768
 
 
– 274
 
 
 494

DATA AND NUMBER SYSTEMS 29
Now in BCD form we may write    0111 0110 1000
 
 
+  0111 0010 0110
 
 
   1110  1000 1110 Left and right groups are invalid
  
Therefore 
  1110  1000 1110
 
 
+ 0110      0110 Add 6
 
Ignore Carry 
 
1 0100  1001 0100
Hence, the ﬁ nal result is (0100 1001 0100)2 or (494)10.
METHOD 2 
. Table 1.8 shows an algorithm for BCD subtraction. 
Table 1.8
Decade
Sign of total result
 result 
 
(+) End around carry = 1 
 
(–) End around carry = 0
 
 
Transfer true results of adder 1 
Transfer 1’s complement of result of adder 1
Cn = 1 
0000 is added in adder 2 
1010 is added in adder 2
Cn = 0 
1010 is added in adder 2 
0000 is added in adder 2
Total result positive
 
 736 
 
0111  0011  0110
 
–273 
 
1101  1000  1100 
  
 1’s complement of 0010 0111 0011
    + 463 
1 
0100  1011  0010
 
 
 
 
 
    1     1
 
 
 
0100  1100  0011
 
 
 
0000  1010   0000
 
 
 
0100  10110  0011
 
 
 
 4   6   3
 
 
 
 
 
 
Ignore this carry 1 
Total result negative
 
 427 
 
0100 
0010 
 0111
   –572 
 
1010 
1000 
 1101 
 
 1’s complement of 0101 0111 0010
   145 
 
1110 
1010 
0100
 
 
 
 
    1 
 
 
 
 
1011      
 
 
 
0001 
0100   1011 
 Transfer 1’s complement of adder 1 output
 
 
 
0000 
0000  1010
 
 
 
0001 
0100    10101
 
 
 
   1 
  4    5 
 
 
 
 
 
 
 
 
Ignore this carry 1

30
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 1.55. Determine the base of the following arithmetic operation:
 
 
 
1234 + 5432 = 6666
Solution. Let us assume that the base of the system is x.
Hence we may write, 
(1 × x3 + 2 × x2 + 3 × x1 + 4 × x0) + (5 × x3 + 4 × x2 + 3 × x1 + 2 × x0)
 
 
 
 
 
 
= (6 × x3 + 6 × x2 + 6 × x1 + 6 × x0)
or, x = 0.
Hence, the value of the base can be any number greater than or equal to 7. Since the 
maximum digit in the problem is 6, the base cannot be less than 7.
Example 1.56. Determine the base of the following arithmetic operation:
 
 
 
302= 12.1
20
Solution. Let us assume that the base of the system is x.
Hence we may write, 
3 × x2 + 0 × x1 + 2 × x0
3x2 + 2
1
x
2x
= 1 × x1 + 2 × x0 + 1 × x1
= x + 2 +
or,
2 × x1 + 0 × x0
or,   x2 – 4x = 0
or,   x(x – 4) = 0
∴     x = 0, or, x = 4
Now, the value of the base of a number system cannot be 0. Hence the value of the base is 4. 
REVIEW QUESTIONS
1.1 Convert the decimal number 247.8 to base 3, base 4, base 5, base 11, and base 16.
1.2 Convert the following decimal numbers to binary: 12.345, 103, 45.778, and 9981.
1.3  Convert the following binary numbers to decimal: 11110001, 00101101, 1010001, and 1001110.
1.4 Perform the subtractions with the following binary numbers using (1) 1’s complement and 
(2) 2’s complement. Check the answer by straight binary subtractions.
 
 (a)  10011 – 10001,  
(b) 10110 – 11000, and  
(c)   100111011 – 10001.
1.5 Perform the subtractions with the following decimal numbers using (1) 9’s complement and 
(2) 10’s complement. Check the answer by straight subtractions.
 
 (a)  1045 – 567,  
(b) 4587 – 5668, and  
(c)   763 – 10001.
1.6 Perform the BCD addition of the following numbers: 
 
 (a)  234 + 146,  
(b) 67 + 39, and  
(c) 9234 + 4542.
1.7 Each of the following arithmetic operations is correct in at least one number system. Determine 
the bases in each operation:
 
 (a) 41
13
3 =
 
(b)
= 5
41
 and  
(c) 23 + 44 + 14 + 32 = 223
1.8 Add and multiply the following numbers in the given base without converting to decimal.
 
 (a) (1231)4 and (32)4, 
(b) (135.3)6 and (42.3)6 and, 
(c) (376)8 and (157)8.
1.9  Find the 10’s complement of (349)11.
1.10 Explain how division and multiplication can be performed in digital systems.
❑ ❑ ❑

31
2.1  INTRODUCTION
A
s we have discussed, digital circuits use binary signals but are required to handle 
data which may be alphabetic, numeric, or special characters. Hence the signals 
that are available in some other form other than binary have to be converted into 
suitable binary form before they can be processed further by digital circuits. This means 
that in whatever format the information may be available it must be converted into binary 
format. To achieve this, a process of coding is required where each letter, special character, 
or numeral is coded in a unique combination of 0s and 1s using a coding scheme known 
as code.
In digital systems a variety of codes are used to serve different purposes, such as data 
entry, arithmetic operation, error detection and correction, etc. Selection of a particular code 
depends on the requirement. Even in a single digital system a number of different codes 
may be used for different operations and it may even be necessary to convert data from 
one type of code to another. For conversion of data, code converter circuits are required, 
which will be discussed in due time.
Codes can be broadly classified into five groups, viz. (i) Weighted Binary Codes, 
(ii) Nonweighted Codes, (iii) Error-detection Codes, (iv) Error-correcting Codes, and 
(v) Alphanumeric Codes.
2.2  CODES
Computers and other digital circuits process data in binary format. Various binary codes are 
used to represent data which may be numeric, alphabetic or special characters. Codes are also 
used for error detection and error correction in digital systems. Although, in digital systems 
in every code used, the information is represented in binary form, but the interpretation of 
the data is only possible if the code in which the data is being represented is known. For 
example, the binary number 1000010 represents 66 (decimal) in straight binary, 42 (decimal) 
in BCD, and letter B in ASCII code. Hence, while interpreting the data, one must be very 
careful regarding the code used. Some of the commonly used codes are discussed below.
CODES AND THEIR
CONVERSIONS
2
C h a p t e r

32
DIGITAL PRINCIPLES AND LOGIC DESIGN
2.2.1 Weighted Binary Codes
If each position of a number represents a speciﬁ c weight then the coding scheme is called 
weighted binary code. In such coding the bits are multiplied by their corresponding individual 
weight, and then the sum of these weighted bits gives the equivalent decimal digit.
BCD Code or 8421 Code
The full form of BCD is ‘Binary-Coded Decimal.’ Since this is a coding scheme relating 
decimal and binary numbers, four bits are required to code each decimal number. For 
example, (35)10 is represented as 0011 0101 using BCD code, rather than (100011)2. From 
the example it is clear that it requires more number of bits to code a decimal number using 
BCD code than using the straight binary code. However, inspite of this disadvantage it is 
convenient to use BCD code for input and output operations in digital systems.
The code is also known as 8-4-2-1 code. This is because 8, 4, 2, and 1 are the weights 
of the four bits of the BCD code. The weight of the LSB is 20 or 1, that of the next higher 
order bit is 21 or 2, that of the next higher order bit is 22 or 4, and that of the MSB is 23
or 8. Therefore, this is a weighted code and arithmetic operations can be performed using 
this code, which will be discussed later on. The bit assignment 0101, for example, can be 
interpreted by the weights to represent the decimal digit 5 because 0 × 8 + 1 × 4 + 0 × 2 
+ 1 × 1 = 5. Since four binary bits are used the maximum decimal equivalent that may be 
coded is 1510 (i.e., 11112). But the maximum decimal digit available is 910. Hence the binary 
codes 1010, 1011, 1100, 1101, 1110, 1111, representing 10, 11, 12, 13, 14, and 15 in decimal 
are never being used in BCD code. So these six codes are called forbidden codes and the 
group of these codes is called the forbidden group in BCD code. BCD code for decimal digits 
0 to 9 is shown in Table 2.1.
Example 2.1. Give the BCD equivalent for the decimal number 589.
Solution.  
The decimal number is 589
 
 
 
BCD code is  0101 
1000 
1001
 
 
 
Hence, (589)10 = (010110001001)BCD
Example 2.2. Give the BCD equivalent for the decimal number 69.27.
Solution.  
The decimal number  6 
92 
7
 
 
 
BCD code is 
 
0110 
1001 
0010 
0111
 
 
 
Hence, (69.27)10 = (01101001.00100111)BCD
84-2-1 Code
It is also possible to assign negative weights to decimal code, as shown by the 84-
2-1 code. In this case the bit combination 0101 is interpreted as the decimal digit 3, as 
obtained from 0 × 8 + 1 × 4 + 0 × (–2) + 1 × (–1) = 3. This is a self-complementary code, 
that is, the 9’s complement of the decimal number is obtained just by changing the 1s to 
0s and 0s to 1s, or in effect by getting the 1’s complement of the corresponding number. 
For example, if we change the 1s to 0s and 0s to 1s in the previous example we have 1010, 
which is interpreted as decimal 6, as obtained from 1 × 8 + 0 × 4 + 1 × (–2) + 0 × (–1) 
= 6. And 6 is the 9’s complement of 3. This property is useful when arithmetic operations 
are done internally with decimal numbers (in a binary code) and subtraction is calculated 
by means of 9’s complement. 

CODES AND THEIR CONVERSIONS 33
2421 Code
Another weighted code is 2421 code. The weights assigned to the four digits are 2, 4, 
2, and 1. The 2421 code is the same as that in BCD from 0 to 4; however, it varies from 
5 to 9. For example, in this case the bit combination 0100 represents decimal 4; whereas 
the bit combination 1101 is interpreted as the decimal 7, as obtained from 2 × 1 + 1 × 4 
+ 0 × 2 + 1 × 1 = 7. This is also a self-complementary code, that is, the 9’s complement of 
the decimal number is obtained by changing the 1s to 0s and 0s to 1s. The 2421 codes for 
decimal numbers 0 through 9 are shown in Table 2.1.
2.2.2 Nonweighted Codes
These codes are not positionally weighted. It basically means that each position of 
the binary number is not assigned a ﬁ xed value. Excess-3 codes and Gray codes are such 
non-weighted codes. 
Excess-3 Code
A decimal code that has been used in some old computers is Excess-3 code. This is a 
nonweighted code. This code assignment is obtained from the corresponding value of 4-bit 
binary code after adding 3 to the given decimal digit. Here the maximum value may be 
11002. Since the maximum decimal digit is 9 we have to add 3 to 9 and then get the BCD 
equivalent. Like 84-2-1 and 2421 codes Excess-3 is also a self-complementary code, that is, 
the 9’s complement of the decimal number is obtained by changing the 1s to 0s and 0s to 1s. 
This self-complementary property of the code helps considerably in performing subtraction 
operation in digital systems.
Example 2.3. Convert (367)10 into its Excess-3 code.
Solution. 
The decimal number is 
  3 
  6 
  7
 
Add 3 to each bit  
+3 
+3 
+3
 
Sum 
 
 
  6 
  9 
10
 
 
Converting the above sum into 4-bit binary equivalent, we have a
 
 
4-bit binary equivalent of 
0110 
1001 
1010
 
 
Hence, the Excess-3 code for (367)10 = 0110 1001 1010
Example 2.4. Convert (58.43)10 into its Excess-3 code.
Soluton. 
The decimal number is   
  5 
  8 
  4 
  3
 
Add 3 to each bit 
 
+3 
+3 
+3 
+3
 
Sum 
 
 
 
  8 
 11 
  7 
  6
 
 
 
Converting the above sum into 4-bit binary equivalent, we have a
 
 
 
4-bit binary equivalent of 
1000 
1011 
0111 
0110
 
 
 
Hence, the Excess-3 code for (367)10 = 10001011.01110110

34
DIGITAL PRINCIPLES AND LOGIC DESIGN
Table 2.1 Binary codes for decimal digits
Decimal 
(BCD)
 
digit 
8421 
84-2-1 
2421 
Excess-3
 
0  
0000 
0000 
0000 
0011
 
1 
0001 
0111 
0001 
0100
 
2 
0010 
0110 
0010 
0101
 
3 
0011 
0101 
0011 
0110
 
4 
0100 
0100 
0100 
0111
 
5 
0101 
1011 
1011 
1000
 
6 
0110 
1010 
1100 
1001
 
7 
0111 
1001 
1101 
1010
 
8 
1000 
1000 
1110 
1011
 
9 
1001 
1111 
1111 
1100
Gray Code
Gray code belongs to a class of code known as minimum change code, in which a number 
changes by only one bit as it proceeds from one number to the next. Hence this code is not 
useful for arithmetic operations. This code ﬁ nds extensive use for shaft encoders, in some types 
of analog-to-digital converters, etc. Gray code is reﬂ ected code and is shown in Table 2.3. The 
Gray code may contain any number of bits. Here we take the example of 4-bit Gray code. The 
code shown in Table 2.3 is only one of many such possible codes. To obtain a different reﬂ ected 
code, one can start with any bit combination and proceed to obtain the next bit combination by 
changing only one bit from 0 to 1 or 1 to 0 in any desired random fashion, as long as two numbers 
do not have identical code assignments. The Gray code is not a weighted code. 
Table 2.2 Four-bit reﬂ ected code
Reﬂ ected Code 
Decimal Equivalent
 
m4 0000 
0
 
m3 0001 
1
 
0011 
2
 
m2 0010 
3
 
0110 
4
 
0111 
5
 
0101 
6
 
m1 0100 
7
 
1100 
8
 
1101 
9
 
1111 
10
 
m5 1110 
11
 
1010 
12
 
m6 1011 
13
 
m7 1001 
14
 
1000 
15

CODES AND THEIR CONVERSIONS 35
Now we try to analyze the name “Reﬂ ected Code.” If we look at the Table 2.3 we can 
consider seven virtual mirrors m1, m2, m3, m4, m5, m6, and m7 placed. Now, for mirror 
m1, if we consider the MSB as the refractive index of the input and output medium then 
leaving out the MSB we can see that all of the eight combinations of three bits each have 
their corresponding reﬂ ected counterparts. Similarly, for mirrors m2 and m5, if we now leave 
the actual MSB we can consider the combination of three bits where now we consider the 
third bit as the new MSB. And similar arguments follow for mirror m1. Similarly, we may 
analyze the cases for mirrors m3, m4, m6, and m7.
Table 2.3 Binary and Gray codes
Decimal numbers 
Binary code  
Gray code
 
0 
0000 
0000
 
1 
0001 
0001
 
2 
0010 
0011
 
3 
0011 
0010
 
4 
0100 
0110
 
5 
0101 
0111
 
6 
0110 
0101
 
7 
0111 
0100
 
8 
1000 
1100
 
9 
1001 
1101
 
10 
1010 
1111
 
11 
1011 
1110
 
12 
1100 
1010
 
13 
1101 
1011
 
14 
1110 
1001
 
15 
1111 
1000
Conversion of a Binary Number into Gray Code
Any binary number can be converted into equivalent Gray code by the following 
steps:
 (i) the MSB of the Gray code is the same as the MSB of the binary number;
 (ii) the second bit next to the MSB of the Gray code equals the Ex-OR of the MSB and 
second bit of the binary number; it will be 0 if there are same binary bits or it will 
be 1 for different binary bits;
 (iii) the third bit for Gray code equals the exclusive-OR of the second and third bits 
of the binary number, and similarly all the next lower order bits follow the same 
mechanism.

36
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 2.5. Convert (101011)2 into Gray code.
Solution.
Step 1. 
The MSB of the Gray code is the same as the MSB of the binary number.
 
 
 
 
1 
0 
1 
0 
1 
1 
Binary
 
 
 
 
 
 
 
 
1 
 
 
 
 
 
Gray
Step 2. 
 Perform the ex-OR between the MSB and the second bit of the binary. The 
result is 1, which is the second bit of the Gray code.
 
 
 
 
1  
0 
1 
0 
1 
1 
Binary
 
 
 
 
 
 
 
 
 
1 
1  
 
 
 
 
Gray 
Step 3.
Perform the ex-OR between the second and the third bits of the binary. The 
result is 1, which is the third bit of the Gray code.
 
 
 
 
1  
0  
1 
0 
1 
1 
Binary
 
 
 
 
 
 
 
 
 
 
1  
1  
1 
 
 
 
Gray 
Step 4.
Perform the ex-OR between the third and the fourth bits of the binary. The 
result is 1, which is the fourth bit of the Gray code.
 
 
 
 
1  
0  
1  
0 
1 
1 
Binary
 
 
 
 
 
 
 
 
 
 
 
1  
1  
1 
1 
 
 
Gray 
Step 5.
Perform the ex-OR between the fourth and the ﬁ fth bits of the binary. The 
result is 1, which is the ﬁ fth bit of the Gray code.
 
 
 
 
1  
0  
1  
0  
1 
1 
Binary
 
 
 
 
 
 
 
 
 
 
 
 
1  
1  
1 
1 
1 
 
Gray
Step 6.
Perform the ex-OR between the ﬁ fth and the sixth bits of the binary. The 
result is 0, which is the last bit of the Gray code.
 
 
 
 
1  
0  
1  
0  
1  
1 
Binary
 
 
 
 
 
 
 
 
 
 
 
 
 
1  
1  
1 
1 
1 
0 
Gray 
After completing the conversion the Gray code of binary 101011 is 111110.

CODES AND THEIR CONVERSIONS 37
Example 2.6. Convert (564)10 into Gray code.
Solution.
Step 1. 
Convert the decimal 564 into equivalent binary.
 
 
Decimal number 564
 
 
Binary number 1000110100
Step 2.  Convert the binary number into equivalent Gray code.
 
1 
 
0 
 0  
0 
 1  1  0  1  0  0 Binary
 
1 
 
1 
 
0 
 
0 
 
1 
 
0 
 
1 
 
1 
 
1 
 
0 Gray
Conversion of Gray Code into a Binary Number
Any Gray code can be converted into an equivalent binary number by the following 
steps:
 (i) the MSB of the binary number is the same as the MSB of the Gray code;
 (ii) the second bit next to the MSB of the binary number equals the Ex-OR of the MSB 
of the binary number and second bit of the Gray code; it will be 0 if there are same 
binary bits or it will be 1 for different binary bits;
 (iii) the third bit for the binary number equals the exclusive-OR of the second bit of the 
binary number and third bit of the Gray code, and similarly all the next lower order 
bits follow the same mechanism.
Example 2.7. Convert the Gray code 101101 into a binary number.
Solution.
Step 1. The MSB of the binary number is the same as the MSB of the Gray code.
 
 
 
 
1 
0 
1 
1 
0 
1 
Gray 
 
 
 
 
 
 
 
 
1  
 
 
 
 
 
Binary 
Step 2. Perform the ex-OR between the MSB of the binary number and the second bit of the 
Gray code. The result is 1, which is the second bit of the binary number.
 
 
 
 
1  
0 
1 
1 
0 
1 
Gray 
 
 
 
 
  
 
 
 
 
1 
 1  
 
 
 
 
Binary 
Step 3. Perform the ex-OR between the second bit of the binary number and the third bit of 
the Gray code. The result is 0, which is the third bit of the binary number.
 
 
 
 
1  
0  
1 
1 
0 
1 
Gray
 
 
 
 
 
 
 
 
 
 
1  
1 
 0 
 
 
 
Binary 

38
DIGITAL PRINCIPLES AND LOGIC DESIGN
Step 4. Perform the ex-OR between the third bit of the binary number and the fourth bit 
of the Gray code. The result is 1, which is the fourth bit of the binary number.
 
 
 
 
1  
0  
1  
1 
0 
1 
Gray
 
 
 
 
 
 
 
 
 
 
 
1  
1  
0 
 1 
 
 
Binary 
Step 5. Perform the ex-OR between the fourth bit of the binary number and the ﬁ fth bit 
of the Gray code. The result is 1, which is the ﬁ fth bit of the binary number.
 
 
 
 
1  
0  
1  
1  
0 
1 
Gray 
 
 
 
 
 
 
 
 
 
 
 
 
1  
1  
0 
1 
 1 
 
Binary
Step 6. Perform the ex-OR between the ﬁ fth bit of the binary number and the sixth bit of 
the Gray code. The result is 0, which is the last bit of the binary number.
 
 
 
 
1  
0  
1  
1  
0  
1 
Gray 
 
 
 
 
 
 
 
 
 
 
 
 
 
1  
1  
0 
1 
1
 
0 
Binary
After completing the conversion, the binary number of the Gray code 101101 is 
110110.
2.2.3 Error-detection Codes
Parity Bit Coding Technique 
Binary information may be transmitted through some form of communication medium 
such as wires or radio waves or ﬁ ber optic cables, etc. Any external noise introduced into 
a physical communication medium changes bit values from 0 to 1 or vice versa. An error-
detection code can be used to detect errors during transmission. The detected error cannot 
be corrected, but its presence is indicated.
A parity bit is an extra bit included with a message to make the total number of 
1s either odd or even. A message of four bits and a parity bit, P, are shown in Table 2.4. 
In (a), P is chosen so that the sum of all 1s is odd (including the parity bit). In (b), P is 
chosen so that the sum of all 1s is even (including the parity bit). In the sending end, the 
message (in this case the ﬁ rst four bits) is applied to a “parity generation” circuit where 
the required P bit is generated. The message, including the parity bit, is transferred to its 
destination. In the receiving end, all the incoming bits (in this case ﬁ ve) are applied to a 
“parity check” circuit to check the proper parity adopted. An error is detected if the checked 
parity does not correspond to the adopted one. The parity method detects the presence of one, 
three, ﬁ ve, or any odd combination of errors. An even combination of errors is undetectable 
since an even number of errors will not change the parity of the bits. The parity bit may 
be included with the message bits either on the MSB or on the LSB side. Hence, in such 
cases, some other coding scheme is to be adopted. Such a coding technique is Check Sums, 
which will be discussed next.

CODES AND THEIR CONVERSIONS 39
Table 2.4 Parity bit
(a) Message  
P (odd)  
(b) Message  
P (even)
 
0000 
1 
0000 
0
 
0001 
0 
0001 
1
 
0010 
0 
0010 
1
 
0011 
1 
0011 
0
 
0100 
0 
0100 
1
 
0101 
1 
0101 
0
 
0110 
1 
0110 
0
 
0111 
0 
0111 
1
 
1000 
0 
1000 
1
 
1001 
1 
1001 
0
 
1010 
1 
1010 
0
 
1011 
0 
1011 
1
 
1100 
1 
1100 
0
 
1101 
0 
1101 
1
 
1110 
0 
1110 
1
 
1111 
1 
1111 
0
Check Sums
As we have discussed aboves the parity bit technique fails for double errors, hence we 
use the Check Sums method in such case. Initially any word A 10010011 is transmitted; next 
another word B 01110110 is transmitted. The binary digits in the two words are added and the 
sum obtained is retained in the transmitter. Then any other word C is transmitted and added 
to the previous sum retained in the transmitter and the new sum is now retained. In a similar 
manner, each word is added to the previous sum already retained; after transmitting all the 
words, the ﬁ nal sum, which is called the Check Sum, is also transmitted. The same operation 
is done at the receiving end and the ﬁ nal sum, which has been obtained here, is being checked 
against the transmitted Check Sum. There is no error if the two sums are equal. 
2.2.4 Error-correcting Codes
We have already discussed two coding techniques that may be used in transmission 
to detect errors. But, unfortunately, those discussed above are not capable of correcting the 
errors. For correction of errors we will now discuss a code called the Hamming code.
Hamming Code
This coding had been developed by R. W. Hamming where one or more parity bits are 
added to a data character methodically in order to detect and correct errors. The number 
of bits changed from one code word to another is known as Hamming distance.
Let us consider Ai and Aj to be any two code words in any particular block code. Now 
the Hamming distance dij between the two vectors Ai and Aj is deﬁ ned by the number of 

40
DIGITAL PRINCIPLES AND LOGIC DESIGN
components in which they differ. Assuming that dij is determined for each pair of code words, 
the minimum value of dij is called the minimum Hamming distance, dmin.
 
For example,
 
 
 
Ai  
1 
0 
0 
1 
0 
1 
1
 
 
 
 
 
 
 
 
 
 
Aj 
0 
0 
1 
1 
0 
0 
1
 
Here, these code words differ in the MSB and in the third and sixth bit positions 
from the left. Hence, dij is 3.
 
From Hamming’s analysis of code distances, some important properties have been 
derived:
 (i) For detection of a single error dmin should be at least two.
 (ii) For single error correction, dmin should be at least three, since the number of errors, 
E d [(dmin  1)  /  2].
 (iii) Greater values of dmin will provide detection and/or correction of more number of 
errors.
The 7-bit Hamming (7, 4) code word h1 h2 h3 h4 h5 h6 h7 associated with a 4-bit binary 
number b3 b2 b1 b0 is:
 
 
 
h1 = b3  b2  b0
 
 
 
h2 = b3  b1  b0
 
 
 
h4 = b2  b1  b0
 
 
 
h3 = b3
 
 
 
h5 = b2
 
 
 
h6 = b1
 
 
 
h7 = b0
Bits h1, h2, and h4 produce even parity bits for the bit ﬁ elds b3 b2 b0, b3 b1 b0, and b2
b1 b0 respectively. Generally the parity bits (h1, h2, h4, h8, h16…) are located in the positions 
corresponding to ascending powers of two (i.e., 20, 21, 22, 23, 24… = 1, 2, 4, 8,16…).
The h1 parity bit has a 1 in the LSB position of its binary representation. Therefore 
it can check all the bit positions, including those that have 1s in the LSB position in the 
binary representation (i.e., h1, h3, h5, and h7). The binary representation of h2 has a 1 in the 
middle bit position. Therefore it can check all the bit positions, including those that have 1s 
in the middle bit position in the binary representation (i.e., h2, h3, h6, and h7). The h4 parity 
bit has a 1 in the MSB position of its binary representation. Therefore it can check all the 
bit positions, including those that have 1s in the MSB position in the binary representation 
(i.e., h4, h5, h6, and h7).
To decode a Hamming code, checking needs to be done for odd parity over the bit ﬁ elds 
in which even parity was previously established. For example, a single bit error is indicated 
by a nonzero parity word a4 a2 a1, where
 
 
  
a1 = h1  h3  h5  h7

CODES AND THEIR CONVERSIONS 41
 
 
 
 
a2 = h2 h3  h6  h7
 
 
 
 
a4 = h4 h5  h6  h7
If a4 a2 a1 = 000, we conclude there is no error in the Hamming code. On the other 
hand, if it has a nonzero value, it indicates the bit position in error. For example, if a4 a2
a1 = 110, then bit 6 is in error. To correct this error, bit 6 has to be complemented.
Example 2.8. Encode data bits 0110 into a 7-bit even parity Hamming code.
Solution. Given   
 
b3 b2 b1 b0 = 0 1 1 0
 
 
 
Therefore, 
h1 = b3  b2  b0 = 0  1  0 = 1
 
 
 
 
 
h2 = b3  b1  b0 = 0  1  0 = 1
 
 
 
 
 
h4 = b2  b1  b0 = 1  1  0 = 0
 
 
 
 
 
h3 = b3 = 0
 
 
 
 
 
h5 = b2 = 1
 
 
 
 
 
h6 = b1 = 1
 
 
 
 
 
h7 = b0 = 0
 
 
 
 
 
h1
h2
h3
h4
h5
h6
h7
 
 
 
 
 
1 
1 
0 
0 
1 
1 
0 
Example 2.9. A 7-bit Hamming code is received as 0110110. What is its correct code?
Solution.
h1
h2
h3
h4
h5
h6
h7
 
 
 
0 
1 
1 
0 
1 
1 
0 
Now, to ﬁ nd the error,
 
 
 
a
h
h
h
h
a
h
h
h
h
a
h
h
h
h
1
1
3
5
7
2
2
3
6
7
4
4
5
6
7
0
1
1
0
0
1
1
1
0
1
0
1
1
0
0
=
⊕
⊕
⊕
=
⊕
⊕
⊕
=
=
⊕
⊕
⊕
=
⊕
⊕
⊕
=
=
⊕
⊕
⊕
=
⊕
⊕
⊕
=
 
Thus, a4 a2 a1 = 010. Therefore, bit 2 is in error and the corrected code can be 
obtained by complementing the second bit in the received as 00 10110.
2.2.5 Alphanumeric Codes 
Many applications of the computer require not only handling of numbers, but also of 
letters. To represent letters it is necessary to have a binary code for the alphabet. In addition, 
the same binary code must represent the decimal numbers and some other special characters. 
An alphanumeric code is a binary code of a group of elements consisting of ten decimal digits, 
the 26 letters of the alphabet (both in uppercase and lowercase), and a certain number of 
special symbols such as #, /, &, %, etc. The total number of elements in an alphanumeric code 
is greater than 36. Therefore it must be coded with a minimum number of 6 bits (26 = 64, 
but 25 = 32 is insufﬁ cient). One possible 6-bit alphanumeric code is given in Table 2.5. It 
is used in many computers to represent alphanumeric characters and symbols internally and 
therefore can be called “internal code.” Frequently there is a need to represent more than 
64 characters, including the lowercase letters and special control characters. For this reason 
the following two codes are normally used.

42
DIGITAL PRINCIPLES AND LOGIC DESIGN
ASCII
The full form of ASCII (pronounced “as-kee”) is “American Standard Code for Information 
Interchange,” used in most microcomputers. It is actually a 7-bit code, where a character 
is represented with seven bits. The character is stored as one byte with one bit remaining 
unused. But often the extra bit is used to extend the ASCII to represent an additional 
128 characters. Some of the codes are shown in Table 2.5.
EBCDIC
The full form of EBCDIC is “Extended Binary Coded Decimal Interchange Code.” It 
is also an alphanumeric code generally used in IBM equipment and in large computers 
for communicating alphanumeric data. For the different alphanumeric characters the code 
grouping in this code is different from the ASCII code. It is actually an 8-bit code and a 
ninth bit is added as the parity bit.
Hollerith Code
Generally this code is used in punched cards. A punched card consists of 12 rows and 
80 columns. An alphanumeric character is represented by each column of 12 bits each by 
punching holes in the appropriate rows. The presence of a hole represents a 1 and its absence 
indicates 0. The 12 rows are marked starting from the top, as 12, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 
and 9. The ﬁ rst three rows are called the zone punch and the last nine are called the numeric 
punch. The code used here is called the Hollerith code. The letters are represented as two 
holes in a column, one in zone punch and the other in numeric punch; decimal digits are 
represented as a single hole in a numeric punch. Special characters are represented as one, 
two, or three holes in a column; while the zone is always used, the other two holes, if used, 
are in a numeric punch with the eighth punch being commonly used. The Hollerith code is 
BCD and hence the transition from EBCDIC is simple. The Hollerith code is used in the card 
readers and punches of large computers, while EBCDIC may be used within the computer.
Table 2.5 Partial list of alphanumeric codes
Character 
6-bit  
7-bit 
8-bit 
12-bit
 
 
Internal code  
ASCII code 
EBCDIC code Hollerith code
 
A 
010001 
1000001 
11000001 
12,1
 
B 
010010 
1000010 
11000010 
12,2
 
C 
010011 
1000011 
11000011 
12,3
 
D 
010100 
1000100 
11000100 
12,4
 
E 
010101 
1000101 
11000101 
12,5
 
F 
010110 
1000110 
11000110 
12,6
 
G 
010111 
1000111 
11000111 
12,7
 
H 
011000 
1001000 
11001000 
12,8
 
I 
011001 
1001001 
11001001 
12,9
 
J 
100001 
1001010 
11010001 
11,1
 
K 
100010 
1001011 
11010010 
11,2
 
L 
100011 
1001100 
11010011 
11,3
 
M 
100100 
1001101 
11010100 
11,4

CODES AND THEIR CONVERSIONS 43
 
N 
100101 
1001110 
11010101 
11,5
 
O 
100110 
1001111 
11010110 
11,6
 
P 
100111 
1010000 
11010111 
11,7
 
Q 
101000 
1010001 
11011000 
11,8
 
R 
101001 
1010010 
11011001 
11,9
 
S 
110010 
1010011 
11100010 
0,2
 
T 
110011 
1010100 
11100011 
0,3
 
U 
110100 
1010101 
11100100 
0,4
 
V 
110101 
1010110 
11100101 
0,5
 
W 
110110 
1010111 
11100110 
0,6
 
X 
110111 
1011000 
11100111 
0,7
 
Y 
111000 
1011001 
11101000 
0,8
 
Z 
111001  
1011010 
11101001 
0,9
 
0 
000000 
0110000 
11110000 
0
 
1 
000001 
0110001 
11110001 
1
 
2 
000010 
0110010 
11110010 
2
 
3 
000011 
0110011 
11110011 
3
 
4 
000100  
0110100 
11110100 
4
 
5 
000101 
0110101 
11110101 
5
 
6 
000110 
0110110 
11110110 
6
 
7 
000111 
0110111 
11110111 
7
 
8 
001000 
0111000 
11111000 
8
 
9 
001001 
0111001 
11111001 
9
 
Blank 
110000 
0100000 
01000000 
No punch
 
. 
011011 
0101110 
01001011 
12,3,8
 
( 
111100 
0101000 
01001101 
12,5,8
 
+ 
010000 
0101011 
01001110 
12,6,8
 
* 
101100 
0101010 
01011100 
11,4,8
 
$ 
101011 
0100100 
01011011 
11,3,8
 
) 
011100  
0101001 
01011101  
11,5,8
 
/ 
110001 
0101111 
01100001 
0,1
 
, 
111011 
0111100 
01101011 
0,3,8
 
= 
001011 
0111101 
01111110 
6,8
 
– 
100000 
0101101 
01100000 
11

44
DIGITAL PRINCIPLES AND LOGIC DESIGN
2.3 SOLVED PROBLEMS
Example 2.10. Encode the following decimal numbers in BCD code:
   
 
(a) 45  
(b) 273.98 
 
(c) 62.905
Solution. (a) Decimal number is  
4 
5
   
 
BCD code is   
0100 
0101
 
  
 
Hence the BCD coded form of 4510 is 0100 0101
 
 
(b) 
Decimal number is  
2 
7 
3 
9 
8
   
 
BCD code is   
0010 
0111 
0011 
1001 
1000
 
 
 
Hence the BCD coded form of 273.9810 is 0010 0111 0011.1001 1000
 
 
(c) 
Decimal number is  
6 
2 
9 
0 
5
   
 
BCD code is   
0110 
0010 
1001 
0000 
0101
 
 
 
Hence the BCD coded form of 62.90510 is 0110 0010.1001 0000 0101
Example 2.11. Write down the decimal numbers represented by the following BCD 
codes:
 
   (a) 100101001 
 (b) 100010010011  
(c) 01110001001.10010010
Solution. (a) BCD code is  
 
 
  
1 
0010 
1001
  
 By padding up the ﬁ rst number with 3 zeros  
0001 
0010 
1001
 
  Decimal number is 
 
 
 
 1  
 2  
9 
 
 Hence the decimal number is 129.
 
(b) BCD code is  
 
 
 
 
1000 
1001 
0011
  
 Decimal number is 
 
 
 
 8  
 9  
3 
 
 Hence the decimal number is 893.
 
(c) BCD code is  
 
 
 
  011  1000  1001  1001  0010
  
 By padding up the ﬁ rst number with 1 zero  0011 1000  1001  1001  0010
 
  Decimal number is 
 
 
   3    8      9       9    2
 
 Hence the decimal number is 389.92.
Example 2.12. Encode the following decimal numbers to Excess-3 code:
 
  
(a) 38  
(b) 471.78 
  (c) 23.105
Solution.
(a) Decimal number is   3       8
  
 BCD code is  
0011 
1000
 
  Now adding 3  
+0011 
+0011
 
  Excess-3 code is  
0110 
1011
 
  Hence the Excess-3 coded form of 3810 is 0110 1011
(b) Decimal number is  
4 
7 
1 
7 
8
  
 BCD code is  
0100 
0111 
0001 
0111 
1000
 
  Now adding 3  
+0011 
+0011 
+0011 
+0011 
+0011
 
  Excess-3 code is  
0111  
1010  
0100 
1010 
1011
 
  Hence the Excess-3 coded form of 471.7810 is 0111 1010 0100.1010 1011

CODES AND THEIR CONVERSIONS 45
 
(c) Decimal number is  
2 
3 
1 
0 
5
  
 BCD code is  
0010 
0011 
0001 
0000 
0101
 
  Now adding 3  
+0011 
+0011 
+0011 
+0011 
+0011
 
 Excess-3 code is  
0101 
0110 
0100 
0011 
1000
 
  Hence the Excess-3 coded form of 23.10510 is 0101 0110.0100 0011 1000
Example 2.13. Express the following Excess-3 codes as decimal numbers:
 
 (a) 0101 1011 1100 0111  (b) 0011 1000 1010 0100  (c) 0101 1001 0011
Solution. (a) Excess-3 code is  
 
 0101 
 1011 
 1100 
 0111
 
  Subtracting 3 from each digit 
–0011 
–0011 
–0011 
–0011
 
  BCD number is 
 
 0010 
 1000 
 1001 
 0100
 
  Decimal number is 
 
 2 
 8 
 9 
 4
 
  Hence the decimal number is 2894.
 
(b) Excess-3 code is  
 
 0011 
 1000 
 1010 
 0100
 
  Subtracting 3 from each digit 
–0011 
–0011 
–0011 
–0011
 
  BCD number is 
 
 0000 
 0101 
 0111 
 0001
 
  Decimal number is 
 
 0 
 5 
 7 
 1
 
  Hence the decimal number is 571.
 
(c) Excess-3 code is  
 
 0101  
 1001  
 0011
 
  Subtracting 3 from each digit 
–0011 
–0011 
–0011
 
 BCD number is 
 
 0010 
 0110 
 0000
 
  Decimal number is 
 
 2 
 6 
 0
 
  Hence the decimal number is 260.
Example 2.14. Encode the following decimal numbers to Gray codes:
 
 (a) 61   (b) 83     (c) 324      (d) 456
Solution. (a) Decimal number is 
61
 
  Binary code is  
111101
 
  Gray code is  
100011
 
(b) Decimal number is  
83
 
  Binary code is  
1010011
 
  Gray code is  
1111010
 
(c) Decimal number is  
324
 
  Binary code is  
101000100
 
  Gray code is  
111100110
 
(d) Decimal number is  
456
 
  Binary code is  
111001000
 
  Gray code is  
100101100

46
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 2.15. Express the following binary numbers as Gray codes:
 
 (a) 10110         (b) 0110111      (c) 101010011
 
 (d) 101011100      (e) 110110001      (f ) 10001110110
Solution. (a) Binary number is  
10110
 
  Gray code is  
11101
 
(b) Binary number is  
0110111
 
  Gray code is  
0101100
 
(c) Binary number is  
101010011
 
  Gray code is  
111111010
 
(d) Binary number is  
101011100
 
  Gray code is  
111110010
 
(e) Binary number is  
110110001
 
  Gray code is  
101101001
 
(f ) Binary number is  
10001110110
 
  Gray code is  
 11001001101
Example 2.16. Express the following Gray codes as binary numbers:
 
 
 
(a) 10111      (b) 0110101      (c) 10100011
 
 
 
(d) 100111100       (e) 101010001      (f ) 10110010101
Solution.
(a) Gray code is  
10111
 
  Binary number is 
11010
 
(b) Gray code is  
0110101
 
  Binary number is 
0100110
 
(c) Gray code is  
10100011
 
  Binary number is 
11000010
 
(d) Gray code is  
100111100
 
  Binary number is 
111010111
 
(e) Gray code is  
101010001
 
  Binary number is 
110011110
 
(f ) Gray code is  
 10110010101
 
  Binary number is 
11011100110
Example 2.17. Encode the following binary numbers as 7-bit even Hamming codes:
 
 
 (a) 1000   (b) 0101   (c) 1011
Solution.
(a) Binary number is  
    b3 b2 b1 b0 = 1000
Now  
 
 
h1 = b3  b2  b0 = 1  0  0 = 1
 
 
 
 
h2 = b3  b1  b0 = 1  0  0 = 1

CODES AND THEIR CONVERSIONS 47
 
 
 
 
h4 = b2  b1  b0 = 0  0  0 = 0
 
 
 
 
h3 = b3 = 1
 
 
 
 
h5 = b2 = 0
 
 
 
 
h6 = b1 = 0
 
 
 
 
h7 = b0 = 0
 
 
 
 
   h1   h2   h3   h4
h5
h6
h7
 
 
 
 
   1      1      1      0      0      0      0
 
(b) 
Binary number is  
b3 b2 b1 b0 = 0101
   
Now  
 
h1 = b3  b2  b0 = 0  1  1 = 0
 
 
 
 
h2 = b3  b1  b0 = 0  0  1 = 1
 
 
 
 
h4 = b2  b1  b0 = 1  0  1 = 0
 
 
 
 
h3 = b3 = 0
 
 
 
 
h5 = b2 = 1
 
 
 
 
h6 = b1 = 0
 
 
 
 
h7 = b0 = 1
 
 
 
 
   h1
h2
h3
h4
h5
h6
h7
 
 
 
 
   0      1      0      0      1      0      1
 
(c) 
Binary number is  
b3 b2 b1 b0 = 1011
   
Now  
 
h1 = b3  b2  b0 = 1  0  1 = 0
 
 
 
 
h2 = b3  b1  b0 = 1  1 1 = 1
 
 
 
 
h4 = b2  b1  b0 = 0  1 1 = 0
 
 
 
 
h3 = b3 = 1
 
 
 
 
h5 = b2 = 0
 
 
 
 
h6 = b1 = 1
 
 
 
 
h7 = b0 = 1
 
 
 
 
   h1
h2
h3
h4
h5
h6
h7
 
 
 
 
   0      1      1      0      0      1      1
Example 2.18. Use the (a) 6-bit internal code, (b) 7-bit ASCII code, and (c) 8-bit 
EBCDIC code to represent the statement:
 
 
 
 
P = 4*Q
Solution.
(a) P is encoded in 6-bit internal code as 100111
 
  = is encoded in 6-bit internal code as 001011
 
  4 is encoded in 6-bit internal code as 000100
 
  * is encoded in 6-bit internal code as 101100
 
  Q is encoded in 6-bit internal code as 101000
 
  Hence the encoded form of  P = 4*Q is  100111 001011 000100 101100 101000

48
DIGITAL PRINCIPLES AND LOGIC DESIGN
 (b) P is encoded in 7-bit ASCII code as 
1010000
 
  = is encoded in 7-bit ASCII code as 
0111101
 
  4 is encoded in 7-bit ASCII code as 
0110100
 
  * is encoded in 7-bit ASCII code as 
0101010
 
  Q is encoded in 7-bit ASCII code as 
1010001
 
  Hence the encoded form of P = 4*Q is  1010000 0111101 0110100 0101010 1010001
 (c) P is encoded in 8-bit EBCDIC code as 11010111
 
 = is encoded in 8-bit EBCDIC code as 01111110
 
  4 is encoded in 8-bit EBCDIC code as 11110100
 
  * is encoded in 8-bit EBCDIC code as 01011100
 
  Q is encoded in 8-bit EBCDIC code as 11011000
 
  Hence the encoded form of P = 4*Q is 
11010111 01111110 11110100 01011100 11011000 
Example 2.19. Express the following decimal numbers as 2421 codes:
 
 
(a) 168  (b) 254 
(c) 6735 
(d) 1973 
(e) 9021
Solution. (a) Decimal number given is  
1 
6 
8
 
  Equivalent 2421 code is 
0001 
1100 
1110
 
(b) Decimal number given is  
2 
5 
4
 
  Equivalent 2421 code is 
0010 
1011 
0100
 
(c) Decimal number given is  
6 
7 
3 
5
 
  Equivalent 2421 code is 
1100 
1101 
0011 
1011
 
(d) Decimal number given is  
1 
9 
7 
3
 
  Equivalent 2421 code is 
0001 
1111 
1101 
0011
 
(e) Decimal number given is  
9 
0 
2 
1
 
  Equivalent 2421 code is 
1111 
0000 
0010 
0001
Example 2.20. Express the following 2421 codes as decimal numbers:
 
(a) 1110 1011 1101  (b) 0010 1100 0001 (c) 1011 0100 1111 (d) 1101 1111 1011
Solution. (a) 2421 code given is   
 
1110 
1011 
1101
 
  Equivalent decimal number is 
  8 
  5 
  7
 
(b) 2421 code given is   
 
0010 
1100 
0001
 
  Equivalent decimal number is 
  2 
 6 
  1
 
(c) 2421 code given is   
 
1011 
0100 
1111
 
  Equivalent decimal number is 
  5 
 4 
  9
 
(d) 2421 code given is   
 
1101 
1111 
1011
 
  Equivalent decimal number is 
  7 
  9 
  5

CODES AND THEIR CONVERSIONS 49
REVIEW QUESTIONS
2.1 Express the following decimal numbers in Excess-3 code form:
  
 (a) 245, 
(b) 739, 
(c) 4567, and 
(d) 532.
2.2 Express the following Excess-3 codes as decimals:
 
  (a) 100000110110,  
(b) 0111110010010110, and 
(c) 110010100011.
2.3 Convert the following binary numbers to Gray codes:
  
 (a) 10110, 
(b) 1110111, 
(c) 101010001, and 
(d) 1001110001110.
2.4 Express the following decimals in Gray code form:
 
  (a) 5,  
(b) 27,  
(c) 567, and 
(d) 89345.
2.5 Write your ﬁ rst name and last name in an 8-bit code made up of the seven ASCII bits and an 
odd parity bit in the most signiﬁ cant position. Include blanks between names.
2.6 Express the following decimals in (1) 2,4,2,1 code and (2) 8, 4, –2, –1 code form:
  
 (a) 35,  
(b) 7,  
(c) 566, and 
(d) 8945.
2.7 What is the difference between ASCII and EBCDIC codes? Why are EBCDIC codes used?
 2.8 Why is Gray code called the reﬂ ected code? Explain. 
 2.9 What is Hamming code and how is it used?
 2.10 Explain with an example how BCD addition is carried out?
❑ ❑ ❑


51
3.1  INTRODUCTION
B
inary logic deals with variables that have two discrete values—1 for TRUE and 0 for 
FALSE. A simple switching circuit containing active elements such as a diode and 
transistor can demonstrate the binary logic, which can either be ON (switch closed) 
or OFF (switch open). Electrical signals such as voltage and current exist in the digital 
system in either one of the two recognized values, except during transition.
The switching functions can be expressed with Boolean equations. Complex Boolean 
equations can be simpliﬁ ed by a new kind of algebra, which is popularly called Switching 
Algebra or Boolean Algebra, invented by the mathematician George Boole in 1854. Boolean 
Algebra deals with the rules by which logical operations are carried out.
3.2  BASIC DEFINITIONS
Boolean algebra, like any other deductive mathematical system, may be deﬁ ned with a set of 
elements, a set of operators, and a number of assumptions and postulates. A set of elements 
means any collection of objects having common properties. If S denotes a set, and X and Y 
are certain objects, then X ∈ S denotes X is an object of set S, whereas Y ∉ denotes Y is not 
the object of set S. A binary operator deﬁ ned on a set S of elements is a rule that assigns to 
each pair of elements from S a unique element from S.  As an example, consider this relation 
X*Y = Z. This implies that * is a binary operator if it speciﬁ es a rule for ﬁ nding Z from the 
objects ( X, Y ) and also if all X, Y, and Z are of the same set S. On the other hand, * can not 
be binary operator if X and Y are of set S and Z is not from the same set S.
The postulates of a mathematical system are based on the basic assumptions, which 
make possible to deduce the rules, theorems, and properties of the system. Various algebraic 
structures are formulated on the basis of the most common postulates, which are described 
as follows.
 
1. Closer:  A set is closed with respect to a binary operator if,  for every pair of elements 
of S, the binary operator speciﬁ es a rule for obtaining a unique element of S. For 
example, the set of natural numbers N = {1, 2, 3, 4, ...} is said to be closed with respect 
BOOLEAN ALGEBRA AND
LOGIC GATES
3
C h a p t e r

52
DIGITAL PRINCIPLES AND LOGIC DESIGN
to the binary operator plus ( + ) by the rules of arithmetic  addition, since for any 
X,Y ∈  N  we obtain a unique element Z ∈ N by the operation X + Y = Z. However, 
note that the set of natural numbers is not closed with respect to the binary operator 
minus (–) by the rules of arithmetic subtraction  because  for 1 – 2 = –1, where –1 
is not of the set of naturals numbers.
 
2. Associative Law: A binary operator * on a set S is said to be associated whenever
 
   
 
(A*B)*C = A*(B*C) 
 
 
for all A,B,C ∈ S.
 
3. Commutative Law: A binary operator * on a  set S is said to be commutative 
whenever
 
   
 
A*B = B*A  
 
 
 
for all A,B ∈ S.
 
4. Identity Element: A set S is to have an identity element with respect to a binary 
operation * on S, if there exists an element E ∈ S with the property
 
   
 
E*A = A*X = A.
Example: The element 0 is an identity element with respect to the binary operator + 
on the set of integers I = {.... –4, –3, –2, –1, 0, 1, 2, 3, 4, ....} as
 
   
 
A + 0 = 0 + A = A.
 
 Similarly, the element 1 is the identity element with respect to the binary operator × as 
 
   
 
A × 1 = 1 × A = A.
 
5. Inverse: If a set S has the identity element E with respect to a binary operator *, there 
exists an element B ∈ S, which is called the inverse, for every A ∈ S, such that A*B = E.
Example: In the set of integers I with E = 0, the inverse of an element A is (-A) since 
A + (–A) = 0.
 
6. Distributive Law: If * and (.)  are two binary operators on a set S, * is said to be 
distributive over (.), whenever
 
   
 
A*(B.C) = (A*B).(A*C).
If summarized, for the ﬁ eld of real numbers, the operators and postulates have the 
following meanings:
The binary operator + deﬁ nes addition.
The additive identity is 0.
The additive inverse deﬁ nes subtraction.
The binary operator (.) deﬁ nes multiplication.
The multiplication identity is 1.
The multiplication inverse of A is 1/A, deﬁ nes division i.e., A. 1/A = 1.
The only distributive law applicable is that of (.) over +
 
 
 
A . (B + C) = (A . B) + (A . C)
3.3  DEFINITION OF BOOLEAN ALGEBRA
In 1854 George Boole introduced a systematic approach of logic and developed an algebraic 
system to treat the logic functions, which is now called Boolean algebra. In 1938 C.E. Shannon 

BOOLEAN ALGEBRA AND LOGIC GATES 53
developed a two-valued Boolean algebra called Switching algebra, and demonstrated that the 
properties of two-valued or bistable electrical switching circuits can be represented by this 
algebra. The postulates formulated by E.V. Huntington in 1904 are employed for the formal 
deﬁ nition of Boolean algebra. However, Huntington postulates are not unique for deﬁ ning 
Boolean algebra and other postulates are also used. The following Huntington postulates 
are satisﬁ ed for the deﬁ nition of Boolean algebra  on  a set of elements S together with 
two binary operators (+) and (.).
 
1. (a) Closer with respect to the operator (+).
 
 (b) Closer with respect to the operator (.).
 
2. (a) An identity element with respect to + is designated by 0 i.e.,
 
   
A + 0 = 0 + A = A.
 
 (b) An identity element with respect to . is designated by 1 i.e.,
 
   
A.1 = 1. A = A.
 
3. (a) Commutative with respect to (+), i.e., A + B = B + A.
 
 (b) Commutative with respect to (.), i.e., A.B = B.A.
 
4. (a) (.) is distributive over (+), i.e., A . (B+C) = (A . B) + (A . C).
 
 (b) (+) is distributive over (.), i.e., A + (B .C) = (A + B) . (A + C).
 
5. For every element A ∈ S, there exists an element A' ∈ S (called the complement  of 
A) such that A + A′ = 1 and A . A′ = 0.
 
6. There exists at least two elements A,B ∈ S, such that A is not equal to B.
Comparing Boolean algebra with arithmetic and ordinary algebra (the ﬁ eld of real 
numbers), the following differences are observed:
 
1. Huntington postulates do not include the associate law. However, Boolean algebra 
follows the law and can be derived from the other postulates for both operations.
 
2. The distributive law of (+) over ( . ) i.e., A+ (B.C) = (A+B) . (A+C) is valid for Boolean 
algebra, but not for ordinary algebra.
 
3. Boolean algebra does not have additive or multiplicative inverses, so there are no 
subtraction or division operations.
 
4. Postulate 5 deﬁ nes an operator called Complement, which is not available in ordinary 
algebra.
 
5. Ordinary algebra deals with real numbers, which consist of an inﬁ nite set of elements. 
Boolean algebra deals with the as yet undeﬁ ned set of elements S, but in the two-
valued Boolean algebra, the set S consists of only two elements—0 and 1.
Boolean algebra is very much similar to ordinary algebra in some respects. The symbols 
(+) and (.) are chosen intentionally to facilitate Boolean algebraic manipulations by persons 
already familiar to ordinary algebra. Although one can use some knowledge from ordinary 
algebra to deal with Boolean algebra, beginners must be careful not to substitute the rules 
of ordinary algebra where they are not applicable.
It is important to distinguish between the elements of the set of an algebraic structure 
and the variables of an algebraic system. For example, the elements of the ﬁ eld of real 
numbers are numbers, the variables such as X, Y, Z, etc., are the symbols that stand for 

54
DIGITAL PRINCIPLES AND LOGIC DESIGN
real numbers, which are used in ordinary algebra. On the other hand, in the case of Boolean 
algebra, the elements of a set S are deﬁ ned, and the variables A, B, C, etc., are merely 
symbols that represent the elements. At this point, it is important to realize that in order 
to have Boolean algebra, the following must be shown.
 
1. The elements of the set S.
 
2. The rules of operation for the two binary operators.
 
3. The set of elements S, together with the two operators satisﬁ es six Huntington 
postulates.
One may formulate many Boolean algebras, depending on the choice of elements of 
set S and the rules of operation. In the subsequent chapters, we will only deal with a 
two-valued Boolean algebra i.e., one with two elements. Two-valued Boolean algebra has 
the applications in set theory and propositional logic. But here, our interest is with the 
application of Boolean algebra to gate-type logic circuits.
3.4  TWO-VALUED BOOLEAN ALGEBRA
Two-valued Boolean algebra is deﬁ ned on a set of only two elements, S = {0,1}, with rules 
for two binary operators (+) and (.) and inversion or complement as shown in the following 
operator tables at Figures 3.1, 3.2, and 3.3 respectively.
 
A 
B 
A + B 
A 
B 
A.B 
A 
A′
 
0 
0 
0 
0 
0 
0 
0 
1 
 
0 
1 
1 
0 
1 
0 
1 
0 
 
1 
0 
1 
1 
0 
0 
 
  
 
1 
1 
1 
1 
1 
1 
 
  
 
Figure 3.1 
Figure 3.2 
Figure 3.3
The rule for the complement operator is for veriﬁ cation of postulate 5.
These rules are exactly the same for as the logical OR, AND, and  NOT operations, 
respectively. It can be shown that the Huntington postulates are applicable for the set 
S = {0,1} and the two binary operators deﬁ ned above.
 
1. Closure is obviously valid, as form the table it is observed that the result of each 
operation is either 0 or 1 and 0,1 ∈ S.
 
2. From the tables, we can see that
 
 (i) 0 + 0 = 0 
 
0 + 1 = 1 + 0 = 1
 
 (ii) 1 . 1 = 1 
 
0 . 1 = 1 . 0 = 0
      which veriﬁ es the two identity elements 0 for (+) and 1 for (.) as deﬁ ned by postulate 2.
 
3. The commutative laws are conﬁ rmed by the symmetry of binary operator tables.
 
4. The distributive laws of (.) over (+) i.e., A . (B+C) = (A . B) + (A . C), and (+) over 
(.) i.e., A + ( B . C) =  (A+B) . (A+C) can be shown to be applicable with the help of 
the truth tables considering all the possible values of  A, B, and C as under.

BOOLEAN ALGEBRA AND LOGIC GATES 55
From the complement table it can be observed that
(a) Operator (.) over (+)
 
A 
B 
C 
B + C 
A. (B + C) 
A. B 
A. C 
(A. B) + (A.C)
 
0 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
1 
1 
0 
0 
0 
0 
 
0 
1 
0 
1 
0 
0 
0 
0 
 
0 
1 
1 
1 
0 
0 
0 
0 
 
1  
0 
0 
0 
0 
0 
0 
0 
 
1 
0 
1 
1 
1 
0 
1 
1 
 
1 
1 
0 
1 
1 
1 
0 
1 
 
1 
1 
1 
1 
1 
1 
1 
1
Figure 3.4
 
(b) Operator (+) over (.)
 
A 
B 
C 
B . C 
A+(B . C) 
A+B 
A+C 
(A+B).(A+C) 
 
0 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
1 
0 
0 
0 
1 
0 
 
0 
1 
0 
0 
0 
1 
0 
0 
 
0 
1 
1 
1 
1 
1 
1 
1 
 
1 
0 
0 
0 
1 
1 
1 
1 
 
1 
0 
1 
0 
1 
1 
1 
1 
 
1 
1 
0 
0 
1 
1 
1 
1 
 
1 
1 
1 
1 
1 
1 
1 
1 
Figure 3.5
 
 (c) A + A′ = 1, since  0 + 0' = 1 and 1 + 1' = 1.
 
 (d) A . A′ = 0, since 0 . 0' = 0 and 1 . 1' = 0.
      These conﬁ rm postulate 5.
 
5. Postulate 6 also satisﬁ es two-valued Boolean algebra that has two distinct elements 
0 and 1 where 0 is not equal to 1.
3.5  BASIC PROPERTIES AND THEOREMS OF BOOLEAN ALGEBRA
3.5.1 Principle of Duality
From Huntington postulates, it is evident that they are grouped in pairs as (a) and (b)
and every algebraic expression deductible from the postulates of Boolean algebra remains 
valid if the operators and identity elements are interchanged. This means one expression can 

56
DIGITAL PRINCIPLES AND LOGIC DESIGN
be obtained from the other in each pair by interchanging  every element i.e., every 0 with 
1, every 1 with 0, as well as interchanging the operators i.e., every (+) with (.) and every 
(.) with (+). This important property of Boolean algebra is called principle of duality.
3.5.2 DeMorgan's Theorem
Two theorems that were proposed by DeMorgan play important parts in Boolean 
algebra.
The ﬁ rst theorem states that the complement of a product is equal to the sum of the 
complements. That is, if the variables are A and B, then 
 
 
 
(A.B)′ = A′ +  B′
The second theorem states that the complement of a sum is equal to the product of 
the complements. In equation form, this can be expressed as
 
 
 
(A + B)′ = A′ .  B′
The complements of Boolean logic function or a logic expression may be simpliﬁ ed or 
expanded by the following steps of DeMorgan’s theorem.
 
(a) Replace the operator (+) with (.) and (.) with (+) given in the expression.
 
(b) Complement each of the terms or variables in the expression.
DeMorgan’s theorems are applicable to any number of variables. For three variables 
A, B, and C, the equations are
 
 
 
(A.B.C)′ = A′ + B′ + C′ 
and 
 
 
 
(A + B + C)′ = A′.B′.C′
3.5.3 Other Important Theorems
Theorem 1(a): A + A = A
A + A = (A + A).1 
 
 
by postulate 2(b)
 
= (A + A) . ( A + A′) 
 
by postulate 5
 
= A + A.A′
 
= A + 0 
 
 
 
by postulate 4
 
= A  
 
 
 
by postulate 2(a)
Theorem 1(b): A . A = A
 A . A = (A . A) + 0 
 
 
by postulate 2(a)
 
= (A . A) + ( A . A′) 
 
by postulate 5
 
= A (A + A′)
 
= A . 1 
 
 
 
by postulate 4
 
= A  
 
 
 
by postulate 2(b)
Theorem 2(a): A + 1 = 1
Theorem 2(b): A . 0 = 0
Theorem 3(a): A + A.B = A
A + A.B = A . 1 + A.B 
 
 
by postulate 2(b)
 
=  A ( 1 + B) 
 
 
by postulate 4(a)
 
=  A . 1  
 
 
by postulate 2(a)
 
=  A 
 
 
 
by postulate 2(b)

BOOLEAN ALGEBRA AND LOGIC GATES 57
Theorem 3(b): 
A ( A + B ) = A 
by duality
The following is the complete list of postulates and theorems useful for two-valued 
Boolean algebra.
Postulate 2 
(a) A + 0 = A 
(b) A.1 = A 
Postulate 5 
(a) A + A′ = 1 
(b) A.A′ = 0 
Theorem 1 
(a) A + A = A 
(b) A.A = A 
Theorem 2 
(a) A + 1 = 1 
(b) A.0 = 0 
Theorem 3, Involution 
   (A′)′ = A 
 
Theorem 3, Commutative 
(a) A + B = B + A 
(b) A.B = B.A 
Theorem 4, Associative 
(a) A + (B + C) = (A + B) + C 
(b) A.(B.C) = (A.B).C 
Theorem 4, Distributive 
(a) A(B + C) = A.B + A.C 
(b) A + B.C = (A + B).(A + C) 
Theorem 5, DeMorgan 
(a) (A + B)′ = A′.B′ 
(b) (A.B)′ = A′ + B′
Theorem 6, Absorption 
(a) A + A.B = A 
(b) A.(A + B) = A
Figure 3.6
3.6  VENN DIAGRAM
A Venn diagram is a helpful illustration to visualize the relationship among the variables 
of a Boolean expression. The diagram consists of a rectangle as shown in Figure 3.7, inside 
two overlapping circles are drawn, which represent two variables. Each circle is labeled by a 
variable. We consider that the area inside the circle belongs to the named variable and area 
outside circle does not belong to that variable. For example, if the variables are A and B, then 
A = 1 for inside the circle A, A = 0 for outside of circle A, and B = 1 for inside the circle B, 
B = 0 for outside of circle B. Now for two overlapping circles as in Figure 3.7,  four distinct areas 
are available inside the rectangle area belonging to A only or AB', area belonging to B only or 
A'B, area belonging to both A and B i.e., A.B and area belonging to neither A or B i.e., A′B′.
Figure 3.7
Figure 3.8

58
DIGITAL PRINCIPLES AND LOGIC DESIGN
A Venn diagram may be used to illustrate the postulates of Boolean algebra or to 
explain the validity of theorems. For example, Figure 3.8 shows that the area belonging to 
AB is inside the circle A, and therefore A + AB = A.
Figure 3.9
Figure 3.9 demonstrates the distributive law A(B + C) = AB + AC. In this ﬁ gure three 
variables A, B, and C are used. It is possible to demonstrate eight distinct areas available 
for three variables in a Venn diagram. For this particular example, the distributive law is 
explained by showing the area intersecting the circle A with area enclosed by B or C is the 
same area belonging to AB or AC.
3.7  BOOLEAN FUNCTIONS
Binary variables have two values, either 0 or 1. A Boolean function is an expression formed 
with binary variables, the two binary operators AND and OR, one unary operator NOT, 
parentheses and equal sign. The value of a function may be 0 or 1, depending on the values 
of variables present in the Boolean function or expression. For example, if a Boolean function 
is expressed algebraically as 
 
 
 
 
 
F = AB′C
then the value of F will be 1, when A = 1, B = 0, and C = 1. For other values of A, B, C 
the value of F is 0.
Boolean functions can also be represented by truth tables. A truth table is the tabular 
form of the values of a Boolean function according to the all possible values of its variables. For 
an n number of variables, 2n combinations of 1s and 0s are listed and one column represents 
function values according to the different combinations. For example, for three variables the 
Boolean function F = AB + C truth table can be written as below in Figure 3.10.
 
A 
B 
C 
F 
 
0 
0 
0 
0 
 
0 
0 
1 
1 
 
0 
1 
0 
0 
 
0 
1 
1 
1 
 
1 
0 
0 
0 
 
1 
0 
1 
1 
 
1 
1 
0 
1 
 
1 
1 
1 
1
Figure 3.10

BOOLEAN ALGEBRA AND LOGIC GATES 59
A Boolean function from an algebraic expression can be realized to a logic diagram 
composed of logic gates. Figure 3.11 is an example of a logic diagram realized by the basic 
gates like AND, OR, and NOT gates. In subsequent chapters, more logic diagrams with 
various gates will be shown.
Figure 3.11
3.8  SIMPLIFICATION OF BOOLEAN EXPRESSIONS
When a Boolean expression is implemented with logic gates, each literal in the function 
is designated as input to the gate. The literal may be a primed or unprimed variable. 
Minimization of the number of literals and the number of terms leads to less complex 
circuits as well as less number of gates, which should be a designer’s aim. There are several 
methods to minimize the Boolean function. In this chapter, simpliﬁ cation or minimization 
of complex algebraic expressions will be shown with the help of postulates and theorems 
of Boolean algebra.
Example 3.1. Simplify the Boolean function F=AB+ BC + B′C.
Solution. F = AB + BC + B′C
 
 = AB + C(B + B′)
  
 = AB + C
Example 3.2. Simplify the Boolean function F= A + A′B.
Solution. F = A+ A′B
 
 = (A + A′) (A + B)
 
 = A + B
Example 3.3. Simplify the Boolean function F= A′B′C + A′BC + AB′.
Solution. F = A′B′C + A′BC + AB′
 
 = A′C (B′+B) + AB′
 
 = A′C + AB′
Example 3.4. Simplify the Boolean function F = AB + (AC)′ + AB′C(AB + C).
Solution. F = AB + (AC)′ + AB′C(AB + C)
 
 = AB + A′ + C′+ AB′C.AB + AB′C.C
 
 = AB + A′ + C′ + 0 + AB′C 
 
(B.B′ = 0 and C.C = C)
 
 = ABC + ABC′ + A′ + C′ + AB′C (AB = AB(C + C′) = ABC + ABC′)
 
 = AC(B + B′) + C′(AB + 1) + A′
 
 = AC + C′+A′ 
 
 
 
(B + B′ = 1 and AB + 1 = 1)
 
 = AC + (AC)′
 
 = 1

60
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 3.5. Simplify the Boolean function F = ((XY′ + XYZ)′ + X(Y + XY′))′.
Solution. F = ((XY′ + XYZ)′ + X(Y + XY′))′
 
 = ((X(Y′ + YZ))′ + XY + XY′)′
 
 = ((X(Y′Z + Y′ + YZ))′ + X(Y + Y′))′ 
(Y′ = Y′(Z + 1) = Y′Z + Y′)
 
 = (X(Y′ + Z))′ + X)′
 
 = (X′ + (Y′ + Z)′ + X)′
 
 = (1+ YZ′)′
 
 = 1′
 
 = 0
Example 3.6. Simplify the Boolean function F = XYZ + XY′Z + XYZ′.
Solution. F = XYZ + XY′Z + XYZ′
 
 = XZ (Y + Y′) + XY (Z + Z′)
 
 = XZ + XY
 
 = X (Y + Z)
3.9  CANONICAL AND STANDARD FORMS
Logical functions are generally expressed in terms of different combinations of logical variables 
with their true forms as well as the complement forms. Binary logic values obtained by the 
logical functions and logic variables are in binary form. An arbitrary logic function can be 
expressed in the following forms.
 (i) Sum of the Products (SOP)
 (ii) Product of the Sums (POS)
Product Term. In Boolean algebra, the logical product of several variables on which a 
function depends is considered to be a product term. In other words, the AND function is 
referred to as a product term or standard product. The variables in a product term can be 
either in true form or in complemented form. For example, ABC′ is a product term.
Sum Term. An OR function is referred to as a sum term. The logical sum of several 
variables on which a function depends is considered to be a sum term. Variables in a sum 
term can also be either in true form or in complemented form. For example, A + B + C′ is 
a sum term.
Sum of Products (SOP). The logical sum of two or more logical product terms is 
referred to as a sum of products expression. It is basically an OR operation on AND operated 
variables. For example, Y = AB + BC + AC or Y = A′B + BC + AC′ are sum of products 
expressions.
Product of Sums (POS). Similarly, the logical product of two or more logical sum terms 
is called a product of sums expression. It is an AND operation on OR operated variables. 
For example, Y = (A + B + C)(A + B′ + C)(A + B + C′) or Y = (A + B + C)(A′ + B′ + C′)
are product of sums expressions.
Standard form. The standard form of the Boolean function is when it is expressed in 
sum of the products or product of the sums fashion. The examples stated above, like Y = 
AB + BC + AC or  Y = (A + B + C)(A + B′ + C)(A + B + C′) are the standard forms.

BOOLEAN ALGEBRA AND LOGIC GATES 61
However, Boolean functions are also sometimes expressed in nonstandard forms like 
F = (AB + CD)(A′B′ + C′D′), which is neither a sum of products form nor a product of sums 
form. However, the same expression can be converted to  a standard form with help of 
various Boolean properties, as
 
 
 
F = (AB + CD)(A′B′ + C′D′) = A′B′CD + ABC′D′
3.9.1 Minterm
A product term containing all n variables of the function in either true or complemented 
form is called the minterm. Each minterm is obtained by an AND operation of the variables 
in their true form or complemented form. For a two-variable function, four different 
combinations are possible, such as, A′B′, A′B, AB′, and AB. These product terms are called 
the fundamental products or standard products or minterms.  In the minterm, a variable 
will possess the value 1 if it is in true or uncomplemented form, whereas, it contains the 
value 0 if it is in complemented form. For three variables function, eight minterms are 
possible as listed in the following table in Figure 3.12.
 
A 
B 
C 
Minterm 
 
0 
0 
0 
A′B′C′
 
0 
0 
1 
A′B′C
 
0 
1 
0 
A′BC′
 
0 
1 
1 
A′BC
 
1 
0 
0 
AB′C′
 
1 
0 
1 
AB′C
 
1 
1 
0 
ABC′
 
1 
1 
1 
ABC
Figure 3.12
So, if the number of variables is n, then the possible number of minterms is 2n. The 
main property of a minterm is that it possesses the value of 1 for only one combination 
of n input variables and the rest of the 2n – 1 combinations have the logic value of 0. 
This means, for the above three variables example, if A = 0, B = 1, C = 1 i.e., for input 
combination of 011, there is only one combination A′BC that has the value 1, the rest of 
the seven combinations have the value 0.
Canonical Sum of Product Expression. When a Boolean function is expressed as the 
logical sum of all the minterms from the rows of a truth table, for which the value of the 
function is 1, it is referred to as the canonical sum of product expression. The same can be 
expressed in a compact form by listing the corresponding decimal-equivalent codes of the 
minterms containing a function value of 1. For example, if the canonical sum of product 
form of a three-variable logic function F has the minterms  A′BC, AB′C, and ABC′, this can 
be expressed as the sum of the decimal codes corresponding to these minterms as below.
 
 
F (A,B,C) 
=   (3,5,6)
 
 
 
 
= m3 + m5 + m6
 
 
 
 
= A′BC + AB′C + ABC′
where Σ (3,5,6) represents the summation of minterms corresponding to decimal codes 3, 
5, and 6.

62
DIGITAL PRINCIPLES AND LOGIC DESIGN
The canonical sum of products form of a logic function can be obtained by using the 
following procedure.
 
1. Check each term in the given logic function. Retain if it is a minterm, continue to 
examine the next term in the same manner.
 
2. Examine for the variables that are missing in each product which is not a minterm. 
If  the missing variable in the minterm is X, multiply that minterm with (X+X′).
 
3. Multiply all the products and discard the redundant terms.
Here are some examples to explain the above procedure.
Example 3.7. Obtain the canonical sum of product form of the following function.
 
F (A, B) = A + B
Solution. The given function contains two variables A and B. The variable B is missing 
from the ﬁ rst term of the expression and the variable A is missing from the second term 
of the expression. Therefore, the ﬁ rst term is to be multiplied by (B + B′) and the second 
term is to be multiplied by (A + A′) as demonstrated below.
 
F (A, B) = A + B
 
 = A.1 + B.1
 
 = A (B + B′) + B (A + A′)
 
 = AB + AB′ + AB + A′B
 
 = AB + AB′ + A′B 
 
(as AB + AB = AB)
Hence the canonical sum of the product expression of the given function is 
 
F (A, B) = AB + AB′ + A′B.
Example 3.8. Obtain the canonical sum of product form of the following function.
  
F (A, B, C) = A + BC
Solution.  Here neither the ﬁ rst term nor the second term is minterm. The given 
function contains three variables A, B, and C. The variables B and C are missing from 
the ﬁ rst term of the expression and the variable A is missing from the second term of the 
expression. Therefore, the ﬁ rst term is to be multiplied by (B + B′) and (C + C′). The second 
term is to be multiplied by (A + A′). This is demonstrated below.
 
F (A, B, C) = A + BC
 
 = A (B + B′) (C + C′) + BC (A + A′)
 
 = (AB + AB′) (C + C′) + ABC + A′BC
 
 = ABC + AB′C + ABC′ + AB′C′ + ABC + A′BC
 
 = ABC + AB′C + ABC′ + AB′C′ + A′BC (as ABC + ABC = ABC)
Hence the canonical sum of the product expression of the given function is 
 
F (A, B) = ABC + AB′C + ABC′ + AB′C′ + A′BC.
Example 3.9. Obtain the canonical sum of product form of the following function.
 
F (A, B, C, D) = AB + ACD
Solution. F (A, B, C, D) = AB + ACD
 
 = AB (C + C′) (D + D′) + ACD (B + B′)
 
 = (ABC + ABC′) (D + D′) + ABCD + AB′CD
 
 = ABCD + ABCD′ + ABC′D + ABC′D′ + ABCD + AB′CD
 
 = ABCD + ABCD′ + ABC′D + ABC′D′ + AB′CD
 
Hence above is the canonical sum of the product expression of the given function.

BOOLEAN ALGEBRA AND LOGIC GATES 63
3.9.2 Maxterm
A sum term containing all n variables of the function in either true or complemented 
form is called the maxterm. Each maxterm is obtained by an OR operation of the variables 
in their true form or complemented form. Four different combinations are possible for a 
two-variable function, such as, A′ + B′, A′ + B, A + B′, and A + B. These sum terms are 
called the standard sums or maxterms. Note that, in the maxterm, a variable will possess 
the value 0, if it is in true or uncomplemented form, whereas, it contains the value 1, if it 
is in complemented form. Like minterms, for a three-variable function, eight maxterms are 
also possible as listed in the following table in Figure 3.13.
 
A 
B 
C 
Maxterm 
 
0 
0 
0 
A + B + C 
 
0 
0 
1 
A + B + C′
 
0 
1 
0 
A + B′ + C 
 
0 
1 
1 
A + B′ + C′
 
1 
0 
0 
A′ + B + C 
 
1 
0 
1 
A′ + B + C′
 
1 
1 
0 
A′ + B′ + C 
 
1 
1 
1 
A′ + B′ + C′
Figure 3.13
So, if the number of variables is n, then the possible number of maxterms is 2n. The main 
property of a maxterm is that it possesses the value of 0 for only one combination of n input 
variables and the rest of the 2n –1 combinations have the logic value of 1. This means, for the 
above three variables example, if A = 1, B = 1, C = 0 i.e., for input combination of 110, there 
is only one combination A′ + B′ + C that has the value 0, the rest of the seven combinations 
have the value 1.
Canonical Product of Sum Expression. When a Boolean function is expressed as the 
logical product of all the maxterms from the rows of a truth table, for which the value of 
the function is 0, it is referred to as the canonical product of sum expression. The same 
can be expressed in a compact form by listing the corresponding decimal equivalent codes 
of the maxterms containing a function value of 0. For example, if the canonical product of 
sums form of a three-variable logic function F has the maxterms  A + B + C, A + B′ + C, 
and A′ + B + C′, this can be expressed as the product of the decimal codes corresponding 
to these maxterms as below,
 
F (A,B,C = Π (0,2,5)
 
 
= M0 M2 M5
 
 
= (A + B + C) (A + B′ + C) (A′ + B + C′)
where Π (0,2,5) represents the product of maxterms corresponding to decimal codes 0, 2, 
and 5.
The canonical product of sums form of a logic function can be obtained by using the 
following procedure.
 
1. Check each term in the given logic function. Retain it if it is a maxterm, continue to 
examine the next term in the same manner.

64
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
2. Examine for the variables that are missing in each sum term that is not a maxterm. 
If the missing variable in the maxterm is X, multiply that maxterm with (X.X′).
 
3. Expand the expression using the properties and postulates as described earlier and 
discard the redundant terms.
Some examples are given here to explain the above procedure.
Example 3.10. Obtain the canonical product of the sum form of the following function.
 F (A, B, C) = (A + B′) (B + C) (A + C′)
Solution. In the above three-variable expression, C is missing from the ﬁ rst term, A 
is missing from the second term, and B is missing from the third term. Therefore, CC′ is 
to be added with ﬁ rst term, AA′ is to be added with the second, and BB′ is to be added 
with the third term. This is shown below.
 F (A, B, C) = (A + B′) (B + C) (A + C′)
 
 = (A + B′ + 0) (B + C + 0) (A + C′ + 0)
 
 = (A + B′ + CC′) (B + C + AA′) (A + C′ + BB′)
 
 = (A + B′ + C) (A + B′ + C′) (A + B + C) (A′ + B + C) (A + B + C′)
 
  (A + B′ + C′)
 
  [using the distributive property, as X + YZ = (X + Y)(X + Z)]
 
 = (A + B′ + C) (A + B′ + C′) (A + B + C) (A′ + B + C) (A + B + C′)
 
  [as (A + B′ + C′) (A + B′ + C′) = A + B′ + C′]
Hence the canonical product of the sum expression for the given function is
 F (A, B, C) = (A + B′ + C) (A + B′ + C′) (A + B + C) (A′ + B + C) (A + B + C′)
Example 3.11. Obtain the canonical product of the sum form of the following function.
 F (A, B, C) = A + B′C
Solution. In the above three-variable expression, the function is given at sum of the 
product form. First, the function needs to be changed to product of the sum form by applying 
the distributive law as shown below. 
 F (A, B, C) = A + B′C
 
 = (A + B′) (A + C)
Now, in the above expression, C is missing from the ﬁ rst term and B is missing from 
the second term. Hence CC′ is to be added with the ﬁ rst term and BB′ is to be added with 
the second term as shown below.
 F (A, B, C) = (A + B′) (A + C)
 
 = (A + B′ + CC′) (A + C + BB′)
 
 = (A + B′ + C) (A + B′ + C′) (A + B + C) (A + B′ + C)
 
  
 
[using the distributive property, as X + YZ = (X + Y) (X + Z)]
 
 = (A + B′ + C) (A + B′ + C′) (A + B + C)
 
  
[as (A + B′ + C) (A + B′ + C) = A + B′ + C]
Hence the canonical product of the sum expression for the given function is
 F (A, B, C) = (A + B′ + C) (A + B′ + C′) (A + B + C).

BOOLEAN ALGEBRA AND LOGIC GATES 65
3.9.3 Deriving a Sum of Products (SOP) Expression from a Truth Table
The sum of products (SOP) expression of a Boolean function can be obtained from its 
truth table summing or performing OR operation of the product terms corresponding to 
the combinations containing a function value of 1. In the product terms the input variables 
appear either in true (uncomplemented) form if it contains the value 1, or in complemented 
form if it possesses the value 0.
Now, consider the following truth table in Figure 3.14, for a three-input function Y. 
Here the output Y value is 1 for the input conditions of 010, 100, 101, and 110, and their 
corresponding product terms are A′BC′, AB′C′, AB′C, and ABC′ respectively.
Inputs 
 
Output 
Product terms 
Sum terms 
 
A 
B 
C 
Y
 
0 
0 
0 
0 
 
A + B + C 
 
0 
0 
1 
0 
 
A + B + C′
 
0 
1 
0 
1 
A′BC′
 
0 
1 
1 
0 
 
A + B′ + C′
 
1 
0 
0 
1 
AB′C′
 
1 
0 
1 
1 
AB′C
 
1 
1 
0 
1 
ABC′
 
1 
1 
1 
0 
 
A′ + B′ + C′
Figure 3.14
The ﬁ nal sum of products expression (SOP) for the output Y  is derived by summing 
or performing an OR operation of the four product terms as shown below.
 
 
Y = A′BC′ + AB′C′ + AB′C + ABC′
In general, the procedure of deriving the output expression in SOP form from a truth 
table can be summarized as below.
 
1. Form a product term for each input combination in the table, containing an output 
value of 1.
 
2. Each product term consists of its input variables in either true form or complemented 
form. If the input variable is 0, it appears in complemented form and if the input 
variable is 1, it appears in true form.
 
3. To obtain the ﬁ nal SOP expression of the output, all the product terms are OR operated.
3.9.4 Deriving a Product of Sums (POS) Expression from a Truth Table
As explained above, the product of sums (POS) expression of a Boolean function can 
also be obtained from its truth table by a similar procedure. Here, an AND operation is 
performed on the sum terms corresponding to the combinations containing a function value 
of 0. In the sum terms the input variables appear either in true (uncomplemented) form if 
it contains the value 0, or in complemented form if it possesses the value 1.
Now, consider the same truth table as shown in Figure 3.14, for  a three-input function 
Y. Here the output Y value is 0 for the input conditions of 000, 001, 011, and 111, and 
their corresponding product terms are A + B + C, A + B + C′, A + B′ + C′, and A′ + B′ + C′
respectively.

66
DIGITAL PRINCIPLES AND LOGIC DESIGN
So now, the ﬁ nal product of sums expression (POS) for the output Y  is derived by 
performing an AND operation of the four sum terms as shown below.
 
 
Y = (A + B + C) (A + B + C′) (A + B′ + C′) (A′ + B′ + C′)
In general, the procedure of deriving the output expression in POS form from a truth 
table can be summarized as below.
 
1. Form a sum term for each input combination in the table, containing an output value of 0.
 
2. Each product term consists of its input variables in either true form or complemented 
form. If the input variable is 1, it appears in complemented form and if the input 
variable is 0, it appears in true form.
 
3. To obtain the ﬁ nal POS expression of the output, all the sum terms are AND 
operated.
3.9.5 Conversion between Canonical Forms
From the above example, it may be noted that the complement of a function expressed 
as the sum of products (SOP) equals to the sum of products or sum of the minterms which 
are missing from the original function. This is because the original function is expressed 
by those minterms that make the function equal to 1, while its complement is 1 for those 
minterms whose values are 0. According to the truth table given in Figure 3.14:
 
F (A,B,C) = 6 ( 2,4,5,6)
 
 = m2 + m4 + m5 + m6
 
 = A′BC′ + AB′C′ + AB′C + ABC′.
This has the complement that can be expressed as
 
F′ (A,B,C) =   (0,1,3,7)
 
 = m0 + m1 + m3 + m7
Now, if we take complement of F′ by DeMorgan’s theorem, we obtain F as 
 
F (A,B,C) = (m0 + m1 + m3 + m7)′
 
 = m0′m1′m3′m′7
 
 = M0M1M3M7
 
 = Π(0,1,3,7)
 
 = (A + B + C)(A + B + C′) (A + B′ + C′) (A′ + B′ + C′).
The last conversion follows from the deﬁ nition of minterms and maxterms as shown in the 
tables in Figures 3.12 and 3.13. It can be clearly noted that the following relation holds true
m′j = Mj.
That is, the maxterm with subscript j is a complement of the minterm with the same 
subscript j, and vice versa.
This example demonstrates the conversion between a function expressed in sum of 
products (SOP) and its equivalent in product of maxterms. A similar example can show the 
conversion between the product of sums (POS) and its equivalent sum of minterms. In general, 
to convert from one canonical form to other canonical form, it is required to interchange the 
symbols Σ and π, and list the numbers which are missing from the original form.
Note that, to ﬁ nd the missing terms, the total 2n number of minterms or maxterms 
must be realized, where n is the number of variables in the function.

BOOLEAN ALGEBRA AND LOGIC GATES 67
3.10  OTHER LOGIC OPERATORS
When the binary operators AND and OR are applied on two variables A and B, they form 
two Boolean Functions A.B and A+B respectively. However, 16 possible Boolean function 
can be generated using two variables, the binary operators AND and OR, and one unary 
operator NOT or INVERT or complement. These functions, with an accompanying name 
and a comment that explains each function in brief, are listed in the table in Figure 
3.15.
 
Boolean Functions 
Operator Symbol 
Name 
Comments
 
F0 = 0 
 
Null 
Binary constant 0
 
F1 = AB 
A . B 
AND 
A and B
 
F2 = AB′ 
A / B 
Inhibition 
A but not B
 
F3 = A 
 
Transfer 
A 
 
F4 = A′B 
B / A 
Inhibition 
B but not A
 
F5 = B 
 
Transfer 
B
 
F6 = AB′ + A′B 
A ⊕ B 
Exclusive-OR 
A or B but not both
 
F7  = A + B 
A + B 
OR 
A or B
 
F8 = (A+B)′ 
A ↓ B 
NOR 
Not OR
 
F9 = AB + A′B′ 
A   B 
Equivalence* 
A equals B
 
F10 = B′ 
B′ 
Complement 
Not B
 
F11 = A + B′ 
A ⊂ B 
Implication 
If B then A
 
F12 = A′ 
A′ 
Complement 
Not A
 
F13 = A′ + B 
A ⊃ B 
Implication 
If A then B
 
F14 = (AB)′ 
A ↑ B 
NAND 
Not AND
 
F15 = 1 
 
Identity 
Binary constant 1
*Equivalence is also termed as equality, coincidence, and exclusive-NOR.
Figure 3.15
Although these functions can be represented in terms of AND, OR, and NOT operation, 
special operator symbols are assigned to some of the functions.
The 16 functions as listed in the table can be subdivided into three categories.
 
1. Two functions produce a constant 0 or 1.
 
2. Four functions with unary operations complement and transfer.
 
3. Ten functions with binary operators deﬁ ning eight different operations—AND, OR, 
NAND, NOR, exclusive-OR, equivalence, inhibition, and implication.
3.11  DIGITAL LOGIC GATES
As Boolean functions are expressed in terms of AND, OR, and NOT operations, it is easier to 
implement the Boolean functions  with these basic types of gates.  However, for all practical 
purposes,  it is possible to construct other types of logic gates. The following factors are to 
be considered for construction of other types of gates.

68
DIGITAL PRINCIPLES AND LOGIC DESIGN
Name 
Graphic Symbol 
Algebraic Function 
 Truth Table
 
 
 
 
A 
B 
F 
 
 
 
 
0 
0 
0 
AND
 
  F = AB 
0 
1 
0 
 
 
 
 
1 
0 
0 
 
 
 
 
1 
1 
1 
 
 
 
 
A 
B 
F 
 
 
 
 
0 
0 
0 
OR  
   
  F = A + B 
0 
1 
1 
 
 
 
 
1 
0 
1 
 
 
 
 
1 
1 
1 
 
 
 
 
 
A 
F 
Inverter
 
  F = A′ 
 
0 
1 
or NOT 
 
 
 
 
1 
0 
 
 
 
 
 
A 
F 
Buffer
 
  F = A 
 
0 
0 
 
 
 
 
 
1 
1 
 
 
 
 
A 
B 
F 
 
 
 
 
0 
0 
1 
NAND
 
  F = (AB)′ 
0 
1 
1 
 
 
 
 
1 
0 
1 
 
 
 
 
1 
1 
0 
 
 
 
 
A 
B 
F 
 
 
 
 
0 
0 
1 
NOR
 
  F = (A + B)′ 
0 
1 
0 
 
 
 
 
1 
0 
0 
 
 
 
 
1 
1 
0 
 
 
 
  
A 
B 
F
 
 
 
 
0 
0 
0 
Exclusive-OR
 
 F = AB′ + A′B 
0 
1 
1 
(XOR) 
 
 
 = A ⊕ B 
1 
0 
1 
 
 
 
 
1 
1 
0 
Equivalence 
 
 
 
A 
B 
F
Or 
 
F = AB + A′B′ 
0 
0 
1
Exclusive-NOR
 
   = A   B 
0 
1 
0
(XNOR) 
 
 
 
1 
0 
0
 
 
 
 
1 
1 
1
Figure 3.16

BOOLEAN ALGEBRA AND LOGIC GATES 69
 
1. The feasibility and economy of producing the gate with physical parameters.
 
2. The possibility of extending to more than two inputs.
 
3. The basic properties of the binary operator such as commutability and associability.
 
4. The ability of the gate to implement the Boolean functions alone or in conjunction 
with other gates.
Out of the 16 functions described in the table in Figure 3.15, we have seen that 
two are equal to constant, and four others are repeated twice. Two functions—inhibition 
and implication, are impractical to use as standard gates due to lack of commutative or 
associative properties. So, there are eight functions—Transfer (or buffer), Complement, AND, 
OR, NAND, NOR, Exclusive-OR (XOR), and Equivalence (XNOR) that may be considered 
to be standard gates in digital design.
The graphic symbols and truth tables of eight logic gates are shown in Figure 3.16. 
The transfer or buffer and complement or inverter or NOT gates are unary gates, i.e., they 
have single input, while other logic gates have two or more inputs.
3.11.1 Extension to Multiple Inputs
A gate can be extended to have multiple inputs if its binary operation is commutative 
and associative. AND and OR gates are both commutative and associative.
 
 
For the AND function, AB = BA 
 
 
-commutative
 
 
and
 
 
(AB)C = A(BC) = ABC. 
 
 
 
-associative 
 
 
For the OR function, A + B  = B + A  
 
-commutative
 
 
and
 
 
(A + B) + C = A + (B + C). 
 
 
 
-associative
These indicate that the gate inputs can be interchanged and these functions can be 
extended to three or more variables very simply as shown in Figures 3.17(a) and 3.17(b).
Figure 3.17(a)
Figure 3.17(b)
The NAND and NOR functions are the complements of AND and OR functions 
respectively. They are commutative, but not associative. So these functions can not be extended 
to multiple input variables very simply. However, these gates can be extended to multiple 
inputs with slightly modiﬁ ed functions as shown in Figures 3.18(a) and 3.18(b) below.
 
 
For NAND function,  (AB)′ = (BA)′. 
-commutative
 
 
But,  ((AB)′C)′ ≠ (A(BC)′)′. 
 
-does not follow associative property.

70
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
As ((AB)′ C)′ =(AB) + C′   and
 
 
(A(BC)′)′ = A′  + BC.
Similarly, for NOR function,  ((A + B)′ + C)′ ≠ (A + (B + C)′)′.
 
 
As, ((A + B)′ + C)′ = (A + B) C′ = AC′ + BC′.
 
 
And (A + (B + C)′)′  = A′(B + C) = A′B + A′C.
Figure 3.18(a)
Figure 3.18(b)
The Exclusive-OR gates and equivalence gates both possess commutative and associative 
properties, and they can be extended to multiple input variables. For a multiple-input Ex-OR 
(XOR) gate output is low when even numbers of 1s are applied to the inputs, and when the 
number of 1s is odd the output is logic 0. Equivalence gate or XNOR gate is equivalent to XOR 
gate followed by NOT gate and hence its logic behavior is opposite to the XOR gate. However, 
multiple-input exclusive-OR and equivalence gates are uncommon in practice. Figures 3.19(a)
and 3.19(b) describe the extension to multiple-input exclusive-OR and equivalence gates.
Figure 3.19(a)
Figure 3.19(b)
3.11.2  Universal Gates
NAND gates and NOR gates are called universal gates or universal building blocks,
as any type of gates or logic functions can be implemented by these gates. Figures 
3.20(a)-(e) show how various logic functions can be realized by NAND gates and Figures 
3.21(a)-(d) show the realization of various logic gates by NOR gates.
 NOT function: F = A′ 
 
 
 
AND function:  F = AB
 Figure 3.20(a) 
 
 
 
 
Figure 3.20(b)

BOOLEAN ALGEBRA AND LOGIC GATES 71
OR function: F = A + B  
 
Ex-OR function: F= ((AB′)′(A′B)′)′ =AB′ + A′B
Figure 3.20(c) 
Figure 3.20(d)
 
Ex-OR gate with reduced number of NAND gates
Figure 3.20(e)
NOT function: F = A′ 
OR function:  F = A + B
Figure 3.21(a) 
Figure 3.21(b)
 
AND function: F = AB
 
Figure 3.21(c)
 
Ex–OR function: F = [((A′ + B)′ + (A + B′)′] = AB′ + A′B
Figure 3.21(d)
3.11.3  Realization of Logic Functions by Nand Gates
Since any gate can be realized by the universal gates, i.e., NAND gates or NOR gates, 
as shown above, any logic function can be realized by the universal gates. Universal gates are 
easier to fabricate with electronic components. The advantage of using the universal gates for 
implementation of logic functions is that it reduces the number of varieties of gates. As an 
example, if the logic function F = AB + CD is to be implemented, it requires two AND gates 
and an OR gate, that means two different types of ICs (Integrated Circuits) are required. 
A
A'
(AB')'
B
B'
(A'B)'
F
A
A'
(A' + B)'
(A + B )''
F
B'
B

72
DIGITAL PRINCIPLES AND LOGIC DESIGN
Whereas, the same logic function can be developed by two NAND gates or one single IC 
(generally one NAND IC contains four gates of similar function). So the logic functions can 
be implemented by only a single type of gate and thus reduces power consumption as well 
as the inventory and cost of inventory in practical situations in industry. 
To achieve the realization of logic functions by NAND gates, the ﬁ rst step is to express 
the function in SOP form (sum of products) and simply replace the gates with NAND gates. 
In other words, logic functions with ﬁ rst level AND gates and second level OR gates can 
be replaced by NAND-NAND realization. The concept can be understood by the diagram in 
Figures 3.22(a)-(c), considering the logic expression F = AB + CD.
Figure 3.22(a)
Figure 3.22(b)
Figure 3.22(c)
Figure 3.22(a) shows the normal AND-OR realization of the function F = AB + CD. 
In Figure 3.22(b), two INVERTER gates are introduced at the outputs of AND gates. 
When two INVERTERs are cascaded, the function remains the same as complement to 
complement of a function is its true form. Now an AND gate followed by an INVERTER 
is a NAND gate, as explained in 3.10.1, and an OR gate preceded by INVERTERs can be 
replaced by a NAND, as from Figures 3.20(a) and 3.21(c). These are shown by the dashed 
lines in Figure 3.22(b). Thus the function F = AB + CD can be realized by NAND gates 
as in Figure 3.22(c).
The same can be explained using Boolean algebra and DeMorgan’s theorems.
 
F = AB + CD
 
 = ((AB + CD)′)′ 
 
- complement to complement operation
 
 = ((AB)′ (CD)′)′ 
 
- applying DeMorgan’s theorem
Note that the derived expression is in terms of NAND function only.

BOOLEAN ALGEBRA AND LOGIC GATES 73
A convenient way to implement a logic circuit with NAND gates is to obtain the simpliﬁ ed 
Boolean function in terms of AND, OR, and NOT and convert the functions to NAND logic 
as explained above. The conversion of the algebraic expression from AND, OR, and NOT 
operations is usually quite complicated because it involves a large number of applications 
of DeMorgan’s theorem. This difﬁ culty is avoided by the use of circuit manipulations as 
explained by the Figures 3.22(a), 3.22(b), and 3.22(c).
The implementation of Boolean functions with NAND gates by circuit manipulation or 
block diagram manipulation is simple and straightforward. The method requires two other 
logic diagrams to be drawn prior to obtaining the NAND logic diagram. Simple rules for 
circuit manipulation are outlined below.
 
1. From the given algebraic expression, draw the logic diagram with AND, OR, and NOT 
gates. Assume that both normal and complement inputs are available.
 
2. Draw a second logic diagram with NAND logic, as given in the Figures 3.20(a)-(e), 
substituted for each AND, OR, and NOT gate.
 
3. Remove any two cascaded inverters from the diagram, since double inversion does not 
perform a logic function. Remove inverters connected to single external inputs and 
complement the corresponding input variable. The new logic diagram is the required 
NAND gate implementation.
The procedure can be illustrated with the example as follows.
Example 3.12. Realize the following function by NAND gates only, F = B(A + CD) + AC′.
Figure 3.23(a) Realization by AND, OR, and NOT gates.
Figure 3.23(b) AND and OR gates are replaced by equivalent NAND gates.
The AND-OR implementation of the function is shown in Figure 3.23(a). Now each 
of the ANDs is replaced by a NAND gate followed by an INVERTER, and each of the OR 
gates is replaced by INVERTERS followed by a NAND gate. This logic diagram is shown in 
Figure 3.23(b). In the next step, two cascaded INVERTERS are removed to obtain the logic 
diagram in Figure 3.23(c), which is a required NAND realization of the given function.

74
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 3.23(c) NAND gate realization after two cascaded inverters are removed.
It may be noticed that the number of NAND gates required to implement the Boolean 
function is equal to the number of AND-OR gates, provided both normal and complement 
inputs are available. If only the normal inputs are available, INVERTERs must be introduced 
to generate the complemented inputs.
3.11.4  Realization of Logic Functions by NOR Gates
Similarly, any logic function can be developed by using only NOR gates. To achieve the 
realization of logic functions by NOR gates only, the ﬁ rst step is to express the function at 
POS form (products of sums) and replace the AND gates and OR gates with NOR gates. 
Logic functions with ﬁ rst level OR gates and second level AND gates can be replaced by 
NOR-NOR realization. This can be demonstrated by the diagram in Figures 3.24(a)-(c), 
considering the logic expression F = (A + B) (C + D).
Figure 3.24(a)
Figure 3.24(b)
Figure 3.24(c)
Figure 3.24(a) shows the normal OR-AND realization of the function F = (A + B) (C + D). 
In Figure 3.24(b), two INVERTER gates are introduced at the outputs of OR gates. Two 
cascaded INVERTERs bring back the function to its original true form. Now an OR gate 
C
D
F
A'
B
A
C′
C
F
D
B
A

BOOLEAN ALGEBRA AND LOGIC GATES 75
followed by an INVERTER is a NOR gate, as explained in 3.10.1, and an AND gate preceded 
by INVERTERs can be replaced by a NOR, as shown in Figures 3.21(a) and 3.20(c). The 
blocks formed by dashed lines at Figure 3.24(b) represent NOR gates. Thus the function 
F = (A + B) (C + D) can be realized by NOR gates as in Figure 3.24(c).
This concept can also be explained by Boolean algebra and DeMorgan’s theorem.
 
F = (A + B) (C + D)
 
 = (((A + B) (C + D))′)′ 
- complement to complement operation
 
 = ((A + B)′ + (C + D)′)′ 
- applying DeMorgan’s theorem
The derived expression is in terms of NOR function only.
Similar to realization with NAND gates of the Boolean functions, circuit manipulation 
techniques may be adopted to implement the Boolean functions with NOR gates. Here also, a 
simple procedure is followed to realize the function with NOR gates, which is illustrated below.
 
1. From the given algebraic expression, draw the logic diagram with AND, OR, and NOT 
gates. Assume that both normal and complement inputs are available.
 
2. Draw a second logic diagram with NOR logic, as given in Figures 3.21(a)-(d), substituted 
for each AND, OR, and NOT gate.
 
3. Remove pairs of cascaded inverters from the diagram, since double inversion does not 
perform a logic function. Remove inverters connected to single external inputs and 
complement the corresponding input variable. The new logic diagram is the required 
NOR gate implementation.
The procedure can be demonstrated with the example that follows.
Example 3.13. Realize the following function by NOR gates only, F = A(B + CD) + BC′.
Figure 3.25(a) Circuit realization by AND-OR gates.
Figure 3.25(b) AND and OR gates are replaced by NOR gates.

76
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 3.25(c) Implementation by NOR gates after two cascaded inverters are removed.
First the function is realized with AND-OR gates as shown in Figure 3.25(a). At the 
next step, each of the AND gates are replaced by INVERTERS followed by a NOR gate, and 
OR gates are substituted by NOR gates followed by INVERTERs as illustrated in Figure 
3.25(b). Finally, the logic diagram is redrawn after removing two cascaded INVERTERs in 
Figure 3.25(c), which represents the NOR gate implementation of the given function.
The number of NOR gates for the Boolean function  is equal to the number of AND-
OR gates plus  one additional INVERTER at the output. In general, the number of NOR 
gates required to implement a Boolean function equals the number of AND-OR gates, except 
for an occasional INVERTER. This is true if both normal and complemented inputs are 
provided, because the conversion requires certain complemented input.
3.11.5  Two-level Implementation of Logic Networks
The maximum number of gates cascaded in series between an input and output is called 
the level of gates. For example, a sum of products (SOP) expression can be implemented using 
a two-level gate network, i.e., AND gates at the ﬁ rst-level and an OR gate at the second 
level. Similarly, a product of sums (POS) expression can be implemented by a two-level gate 
network, as OR gates at the ﬁ rst level and an AND gate at the second level. It is important 
to note that INVERTERS are not considered to decide the level of gate network.
Apart from the realization of Boolean functions using AND gates and OR gates, the 
NAND gates and NOR gates are most often found in the implementation of logic circuits as 
they are universal type by nature. Some of the NAND and NOR gates allow the possibility 
of a wire connection between the outputs of two gates to provide a speciﬁ c logic function. 
This type of logic is called wired logic. (This will be discussed in detail in Chapter 11: Logic 
Family.) When two NAND gates are wired together as shown in Figure 3.26(a), they perform 
the wired-AND logic function. AND drawn with lines going through the center of the gate 
is symbolized as a wired-AND logic function. The wired-AND gate is not a physical gate, 
but only a symbol to designate the function obtained from the indicated wired connections. 
The logic function implemented by the circuit of Figure 3.26(a) is 
 
 
F = (WX)′.(YZ)′ = (WX + YZ)′.
 
 
Figure 3.26(a) 
Figure 3.26(b)

BOOLEAN ALGEBRA AND LOGIC GATES 77
The above function is referred to as an AND-OR-INVERT function. Similarly, some 
specially constructed NOR gates outputs can be tied together to form the wired-OR function 
as shown in Figure 3.26(b). The logic function implemented by Figure 3.26(b) is 
 
 
F = (W + X)′ + (Y + Z)′ = [(W + X). (Y + Z)]′.
This function is called an OR-AND-INVERT function.
The wired logic gate does not produce a physical second level gate since it is just the 
wire connection. However, according to the logic function concerned, wired logic is considered 
a two-level implementation.
Degenerate and Nondegenerate Forms
It may be noted that, although there may be 16 combinations of two-level implementation 
of gates possible, four types of gates AND, OR, NAND, and NOR are considered. Eight of 
these combinations are similar in nature. As an example, an AND gate at ﬁ rst level with 
an AND gate at second level is practically performing a single operation. Similarly, an OR 
gate followed by an OR gate performs a single operation. These types of combinations are 
called degenerate forms.
The other eight combinations produce sum of the products or product of sums functions 
and they are called nondegenerate forms. The eight nondegenerate forms are below.
 
AND-OR 
OR-AND 
NOR-NOR 
NAND-NAND
 
AND-NOR 
OR-NAND 
NOR-OR 
NAND-AND
In each form the ﬁ rst gate represents the ﬁ rst level and second gate is for second 
level.
3.11.6  Multilevel Gating Networks
The number of levels can be increased by factoring the sum of products expression for 
an AND-OR network, or by multiplying out some terms in the product of sums expression 
for an OR-AND network. If a switching network is implemented using gates in more than 
two levels, then it is called a multilevel gate network. Some examples are given here to 
illustrate the multilevel gate network.
Example 3.14. Realize the function F = BC′ + A′B + D with a multilevel network.
Solution. The function can be realized in a two-level AND-OR network as shown is 
Figure 3.27(a). However, by factoring some part of the function, it can be rewritten as F = B 
(A′ + C′) + D and implemented as a multilevel gate network in Figure 3.27(b).
Figure 3.27(a)  
 
 
 
Figure 3.27(b)
The logic circuit in Figure 3.27(a) consists of two 2-input AND gates, a 3-input OR 
gate, and ﬁ ve literals or inputs, whereas the logic circuit in Figure 3.27(b) is a three-level 
representation of the same function containing two 2-input OR gates, a 2-input AND gate, 
and four literals. Thus it reduces the number of gate inputs by one.

78
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 3.15. Realize the function Y = BD′E + BF + C′D′E + C′F + A with a multilevel 
network.
By the straightforward method, the function can be realized in a two-level AND-OR 
network as shown in Figure 3.28(a). However, the expression may be factored into a different 
form as below.
 
Y = BD′E + BF + C′D′E + C′F + A
 
 = B (D′E + F) + C′ (D′E + F) + A
 
 = (D′E + F) (B + C′) + A
The same function can be realized as a multilevel gate network as shown in Figure 3.28(b).
 
Figure 3.28(a)  
Figure 3.28(b)
The logic diagram in Figure 3.28(a) is a normal two-level AND-OR network consisting 
of two 3-input AND gates, two 2-input AND gates, one 5-input OR gate (a 5-input OR gate 
is not normally available in practice and an 8-input OR gate is to be used in place of that), 
and eleven literals or inputs. However, equivalent multilevel network is realized in Figure 
3.28(b), which contains two 2-input AND gates, three 2-input OR gates, and six inputs. Hence 
the multilevel network reduces the number of literals as well as the variety of gate types.
Hence, from the above examples, we observe that the multilevel network has distinct 
advantages over the two-level network, which may be summarized as below.
 
1. Multilevel networks use less number of literals or inputs, thus reducing the number 
of wires for connection.
 
2. Sometimes the multilevel network reduces the number of gates.
 
3. It reduces the variety type of gates and hence the number of ICs (integrated 
circuits).
 
4. Multilevel gate networks can be very easily converted to universal gates realization 
by the procedure described in sections 3.10.3 and 3.10.4 of this chapter. In that case 
the switching network can be implemented by less variety of the logic gates.
However, the biggest disadvantage of the multilevel network is that it increases the 
propagation delay. The propagation delay is the inherent characteristics of any logic gate, 
and it increases with the increase of number of levels. So a designer must consider these 
factors while designing a switching network and its application.
3.11.7  Some Examples of Realization of Logic Functions
Example 3.16. Realize the function F = B′C′ + A′C′ + A′B′ by (i) basic gates, (ii) NAND 
gates only, (iii) NOR gates only.
B
C′
D′
D′
E
F
E
F
B
C′
A
B
D′
E
C′
Y
Y
F
A

BOOLEAN ALGEBRA AND LOGIC GATES 79
Solution. (i) The function is realized basic gates as in Figure 3.29.
Figure 3.29
(ii) For the NAND realization, at the ﬁ rst step, each of the gates are converted to 
NAND gates as in Figure 3.30(a). Figure 3.30(b) demonstrates the all NAND realization.
Figure 3.30(a)
Figure 3.30(b)
(iii) Figure 3.31(a) represents the conversion of each gate to a NOR gate and Figure 
3.31(b) is the logic diagram for the given function realized with NOR gates only.
Figure 3.31(a)

80
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 3.31(b)
Example 3.17. Realize the function F = (A + B)(A’ + C)(B + D) by (i) basic gates, 
(ii) NAND gates only, (iii) NOR gates only.
Solution. (i) The function is realized basic gates as in Figure 3.32.
Figure 3.32
(ii) Realization by NAND gates only is demonstrated in Figure 3.33.
Figure 3.33

BOOLEAN ALGEBRA AND LOGIC GATES 81
(iii) The given function has been implemented with NOR gates only in Figure 3.34.
Figure 3.34
Example 3.18. Realize the function F = (AB)′ + A + (B + C)′ NAND gates only.
Solution. Figure 3.35 is the NAND gate implementation of the given function.
Figure 3.35
Example 3.19. (a) Realize the function F = A + BCD′ using NAND gates only.
(b) Realize the function F = (A + C)(A + D′) (A + B + C′) using NOR gates only.
Solution. (a) 
F = A + BCD′ = [(A + BCD′)′]′
 
 = [A′(BCD′)′]′
Figure 3.36 is the NAND gate implementation of the given function. 
Figure 3.36
(b) 
F = (A + C) (A + D′) (A + B + C′)
 
 = [{(A + C) (A + D′) (A + B + C′)}′]′
 
 = [(A + C)′ + (A + D′)′ + (A + B + C′)′]′

82
DIGITAL PRINCIPLES AND LOGIC DESIGN
The logic diagram of the given function is implemented in Figure 3.37 with NOR gates 
only.
Figure 3.37
Example 3.20. (a) Realize the function F = (A + C) (B′ + D′) (A′ + B′ + C′) with 
multilevel NAND gates. Use 2-input NAND gates only.
(b) Realize the function in Figure 3.20(a) with multilevel NOR gates. Use 2-input NOR 
gates only.
Solution. The function is ﬁ rst realized by basic gates as in Figure 3.38(a) and it is 
implemented with all 2-input gates as in Figure 3.38(b).
Figure 3.38(a)  
 
 
Figure 3.38(b)
(a) All the basic gates are converted to NAND gates as shown in Figure 3.39(a). At 
the next step, cascaded pairs of INVERTERs gates are removed and also the INVERTERs 
at the inputs are eliminated assuming complement inputs are available. Figure 3.39(b) is 
the NAND realization of the given function.
Figure 3.39(a)

BOOLEAN ALGEBRA AND LOGIC GATES 83
Figure 3.39(b)
(b) For realization with all NOR gates, each of the gates of the logic diagram of 
Figure 3.37(b) is converted to NOR gates as shown in Figure 3.40(a). Then cascaded pairs 
of INVERTERs are  removed and the ﬁ nal logic diagram with all NOR gates is realized 
as in Figure 3.40(b).
Figure 3.40(a)
Figure 3.40(b)
3.12  POSITIVE AND NEGATIVE LOGIC
The binary signals at the inputs or outputs of any gate may be one of two values,
except during transitions. One signal value represents logic 1, and the other is logic 0. For 
a positive logic system, the most positive voltage level represents logic 1 state or HIGH level 

84
DIGITAL PRINCIPLES AND LOGIC DESIGN
(H) and the lowest voltage level represents logic 0 state or LOW level (L). For a negative logic
system, the most positive voltage level represents logic 0 state and the lowest voltage level 
represents logic 1 state. For example, if the voltage levels are –1 volt and –10 volt in a positive 
logic system, then –1 volt represents logic 1 and –10 volt represents logic 0. In a negative logic 
system, logic 1 state is represented by –10 volt and logic 0 is represented by –1 volt. Figure 
3.41(a) represents the positive logic system choosing the highest voltage level as logic 1 and 
the lowest voltage level as logic 0. Whereas Figure 3.41(b) represents the negative logic system 
assigning the highest voltage level as logic 0 and the lowest voltage level as logic 1.
 
Figure 3.41(a)  
Figure 3.41(b)
The effect of changing one logic system to an other logic system is equivalent to 
complementing the logic function. The simple method of converting from one logic system to 
an other is to change all 0s of a truth table with 1s and all 1s with 0s. The resulting logic 
function is determined accordingly. For example, if 0s and 1s are interchanged in the truth 
table, the positive logic OR function converts to a negative logic AND function. Similarly, 
a positive logic NOR function turns to a negative logic NAND function.
The logic gates are commercially available in integrated circuit (IC) form, and according 
to the construction of basic structure and fabrication process they are classiﬁ ed into various 
groups termed as logic families. Parameters and characteristics are different for different 
logic families. In each family, there is a range of voltage values that the circuit will recognize 
as HIGH or LOW level. The table in Figure 3.42 describes the ranges of voltage levels for 
some of the widely used logic families.
IC family 
Supply 
 High-level voltage (V) 
 Low-level voltage (V)
 types 
Voltage (V) 
Range 
 
Typical 
Range  
Typical
TTL 
VCC = 5 
2.4 to 5 
 
3.5 
0 to 0.4  
0.2
ECL 
VEE = –5.2 
–0.95 to –0.7  
–0.8 
–1.9 to –1.6 
–1.8
CMOS 
VDD = 3 to 10 
VDD 
 
VDD 
0 to 0.5  
0
 
Positive logic 
Logic 1 
Logic 0
 
Negative logic 
Logic 0 
Logic 1
Figure 3.42
However, there is no real advantage of either logic system over the other and the 
choice of using a positive logic system or negative logic system solely depends on the logic 
designer. In practice, a positive logic system is followed mostly.
3.13  CONCLUDING REMARKS
The basic digital principles, postulates, Boolean algebra and its simpliﬁ cation rules and 
implementation with logic gates have been discussed in this chapter. Logic gates are the 
electronic circuits constructed with basic electronic components such as resistors, diodes, 

BOOLEAN ALGEBRA AND LOGIC GATES 85
transistors, etc., and fabricated in one chip referred to as integrated circuit or IC with the 
interconnections among the components within the chip. According to the construction and 
fabrication process of the basic structure of the logic gates, they are classiﬁ ed into different 
logic families, the parameters and characteristics of which are different for one family to 
an other. The governing characteristics are propagation delay, operating voltage level, fan 
out, power dissipation, etc., and they play an important part in the logic design. These will 
be discussed in detail in Chapter 11.
REVIEW QUESTIONS
 3.1 State the methods used to simplify the Boolean equations.
 3.2 State and explain the basic Boolean logic operations.
 3.3 What are the applications of Boolean algebra?
 3.4 Deﬁ ne truth table.
 3.5 How is the AND multiplication different from the ordinary multiplication?
 3.6 How does OR  addition differ from the ordinary addition method?
 3.7 What are the basic laws of Boolean algebra?
 3.8 State and prove Absorption and Simpliﬁ cation theorems.
 3.9 State and prove Associative and Distributive theorems.
 3.10 What is meant by duality in Boolean algebra?
 3.11 State DeMorgan’s theorem.
3.12 State and explain the DeMorgan’s theorem that converts a sum into a product and vice versa. 
Draw the equivalent logic circuits using basic gates.
 3.13 Explain the terms—(a) input variable, (b) minterm, (c) maxterm.
 3.14 Prove DeMorgan’s theorem for a 4-variable function.
 3.15 What is the truth table and logic symbol of a three-input OR gate?
 3.16 Write the expression for a 4-input AND gate. Construct the complete truth table showing the 
output for all possible cases.
 3.17 Does any three-input INVERTER exist?
 3.18 Deﬁ ne NAND and NOR gates with their truth tables.
 3.19 What is a logic gate? Explain logic designation.
 3.20 Discuss the operation of Ex-OR and Ex-NOR gates with truth tables and logic diagram.
 3.21 Explain the term ‘universal gate.’ Name the universal gates.
 3.22 Explain how basic gates can be realized by NAND gates.
 3.23 Explain how basic gates can be realized by NOR gates.
 3.24 Construct a two-input XOR gate using NAND gates. Construct the same with NOR gates.
3.25 Realize an INVERTER with two-input XOR gate only.
 3.26 Realize the logic expression for A⊕B⊕C⊕D.
 3.27 Draw a logic circuit for the function F = (A + B)(B + C)(A + C), using NOR gates only.
 3.28 How can an AND-OR network be converted to all NAND network?

86
DIGITAL PRINCIPLES AND LOGIC DESIGN
 3.29 How can an AND-OR network be converted to an all-NOR network?
 3.30 What are the advantages and disadvantages of a multilevel gate network?
 3.31 For the function F = AB′C′ + AB, ﬁ nd the logic value of F under the conditions—
 
 (a) A = 1, B = 0, C = 1; 
(b) A = 0, B = 1, C = 1;
 
 (c) A = 0, B = 0, C = 0
 3.32 Simplify the following expressions:
 
 (a) AB′C′ + A′B′C′ + A′BC′ + A′B′C
 
 (b) ABC + A′BC + AB′C + ABC′ + AB′C′ + A′BC′ + A′B′C′
 
 (c) A(A + B + C) (A′ + B + C) (A + B′ + C) (A + B + C′)
 
 (d) (A + B + C) (A + B′ + C′) (A + B + C’) (A + B′ + C)
 3.33 Draw truth tables for the following expressions:
 
 (a) F = AC + AB 
(b) F = AB (B + C + D′)
 
 (c) Y= A (B′ + C′) 
(d) Y = (A + B + C) AB′
 
 (e) F = ABC (C + D′) 
(f) F = AB + BA + C (A + B)
 3.34 Reduce the Boolean expressions given below:
 
 (a) A + A′ + B + C 
(b) AB + BB + C + B′
 
 (c) ABC (ABC + 1) 
(d) AB + B + A + C
 
 (e) AAB + ABB + BCC 
(f) A (A′ + B)
 
 (g) AB (B + C) 
(h) ABB (ABC + BC)
 
 (i) (AB + C) (AB + D) 
(j) AB′C + A′B′C
 
 (k) AB′C + A′BC + ABC 
(l) (A′B) AB + AB
 
 (m) (AB′ + AC′) (BC + BC′) (ABC) 
(n) A + B′C (A + B′C)
 
 (o) A [(ABC)′ + AB′C] 
(p) [(ABC)′ + A′B′ + BC]
 
 (q) A [B + C(AB + AC)′] 
(r) (M + N) (M′ + P) (N′ + P)
 3.35   
Find the complements of the following expressions:
 
 (a) A + BC + AB 
(b) (A + B)(B + C)(A + C)
 
 (c) AB + BC + CD 
(d) AB (C′D + B′C)
 
 (e) A (B + C) (C′ + D′)
 3.36 Apply DeMorgan’s theorem to each of the following expressions:
 
 (a) (AB′ + C + D′)′ 
(b) [AB (CD + EF)]′
 
 (c) (A + B′ + C + D′)′ + (ABCD′)′ 
(d) (AB + CD)′
 
 (e) [(A′ + B + C + D′)′ + (AB′C′D)]′ 
(f) [(AB)′ (CD + E’F) ((AB)′ + (CD)′)]′
 
 (g) (AB)′ + (CD)′ 
(h) (A + B′) (C′ + D)
 3.37 Simplify the following Boolean expressions using Boolean technique:
 
 (a) AB + A (B + C) + B (B + C) 
(b) AB(C + BD′) (AB)′
 
 (c) A + AB + AB′C 
(d) (A′ + B)C + ABC
 
 (e) AB′C (BD + CDE) + AC′ 
(f) BD + B (D + E) + D′ (D + F)

BOOLEAN ALGEBRA AND LOGIC GATES 87
  
 (g) A′B′C + (A + B + C′)′ + A′B′C′D′ 
(h) (B + BC) (B + B′C) (B + D)
 
 (i) ABCD + AB (CD)′ + (AB)′CD 
(j) ABC [AB + C′ (BC + AC)]
 
 (k) A + A′B + (A + B)′ C + (A + B + C + D) (l) AB′ + AC + BCD + D′
 
 (m) A + A′B′ + BCD′ + BD′ 
(n) AB′C + (B′ + C′) (B′ + D′) + (A + C + D)′
 3.38 Prove the following using Boolean theorems:
 
 (a) (A + C)(A + D)(B + C)(B + D) = AB + CD
 
 (b) (A′ + B′ + D′) (A′ + B + D′) (B + C + D) (A + C′) (A + C′ + D) = A′C′D + ACD’′+ BC′D′
 3.39 (a)  Find the Boolean expression for F, when F is 1 only if A is 1 and B is 1, or if A is 0 and 
 
B is 0.
 
 (b) Find the Boolean expression for F, when F is 1 only if A, B, C are all 1s, or if one of the 
 
variables is 0.
 3.40 (a) Convert Y = ABCD + A′BC + B′C′ into a sum of minterms by algebraic method.
 
 (b) Convert Y = AB + B′CD into a product of maxterms by algebraic method.
 3.41 Find the canonical sum of products and product of sums expression for the function
 
 F = X1X2X3 + X1X3X4 + X1X2X4.
 3.42 (a) Express the function Y =  ( 1,3,5,7)  as a product of maxterms.
 
 (b) Express the complement of the function as a sum of the minterms.
 
 (c)  Express the complement of the function as a product of maxterms.
 3.43 Simplify the function F =  ( 0,2,3,6,8,10,11,14,15) and implement it with
 
 (a) AND-OR network, 
(b) OR-AND network,
 
 (c) NAND-NAND network, and 
(d) NOR-NOR network.
 3.44 Realize the following function using a multilevel NAND-NAND network and NOR-NOR 
network:
 
 F = A′B + B (C + D) + EF′ (B′ + D′).
 3.45 Seven switches operate a lamp in the following way; if switches 1, 3, 5, and 7 are closed and 
switch 2 is opened, or if switches 2, 4, and 6 are closed and switch 3 is opened, or if all seven 
switches are closed the lamp will glow. Use basic gates to show how the switches are to be 
connected.
 3.46 A corporation having 100 shares entitles the owner of each share to cast one vote at the share-
holders’ meeting. Assume that A has 60 shares, B has 30 shares, C has 20 shares, and D has 
10 shares. A two-third majority is required to pass a resolution in a share-holders’ meeting. 
Each of these four men has a switch which he closes to vote YES and opens to vote NO for 
his percentage of shares. When the resolution passed, one output LED is ON. Derive a truth 
table for the output function and give the sum of product equation for it.
 3.47 Prove that  (X + Y) ⊕ (X + Z) = X′ (Y ⊕ Z).
❑ ❑ ❑


89
4.1  INTRODUCTION
T
he complexity of digital logic gates to implement a Boolean function is directly related 
to the complexity of algebraic expression. Also, an increase in the number of variables 
results in an increase of complexity. Although the truth table representation of a Boolean 
function is unique, its algebraic expression may be of many different forms. Boolean functions 
may be simpliﬁ ed or minimized by algebraic means as described in Chapter 3. However, this 
minimization procedure is not unique because it lacks speciﬁ c rules to predict the succeeding step 
in the manipulative process. The map method, ﬁ rst proposed by Veitch and slightly improvised 
by Karnaugh, provides a simple, straightforward procedure for the simpliﬁ cation of Boolean 
functions. The method is called Veitch diagram or Karnaugh map, which may be regarded either 
as a pictorial representation of a truth table or as an extension of the Venn diagram.
The Karnaugh map provides a systematic method for simpliﬁ cation and manipulation 
of a Boolean expression. The map is a diagram consisting of squares. For n variables on a 
Karnaugh map there are 2n numbers of squares. Each square or cell represents one of the 
minterms. Since any Boolean function can be expressed as a sum of minterms, it is possible 
to recognize a Boolean function graphically in the map from the area enclosed by those 
squares whose minterms appear in the function. It is also possible to derive alternative 
algebraic expressions or simplify the expression with a minimum number of variables or 
literals and sum of products or product of sums terms, by analyzing various patterns. In 
fact, the map represents a visual diagram of all possible ways a function can be expressed 
in a standard form and the simplest algebraic expression consisting of a sum of products 
or product of sums can be selected. Note that the expression is not necessarily unique.
4.2  TWO-VARIABLE KARNAUGH MAPS
A two-variable Karnaugh map is shown in Figure 4.1. Since a two-variable system can form 
four minterms, the map consists of four cells—one for each minterm. The map has been 
SIMPLIFICATION AND
MINIMIZATION OF BOOLEAN
FUNCTIONS
4
C h a p t e r

90
DIGITAL PRINCIPLES AND LOGIC DESIGN
redrawn in Figure 4.1(b) to show the relationship between the squares and the two variables 
A and B. Note that, in the ﬁ rst row, the variable A is complemented, in the second row 
A is uncomplemented, in the ﬁ rst column variable B is complemented and in the second 
column B is uncomplemented. 
The two-variable Karnaugh map is a useful way to represent any of the 16 Boolean 
functions of two variables as described in section 3.7, if the squares are marked with 1 whose 
minterms belong to a certain function. As an example, the function AB has been shown in Figure 
4.2(a). Since the function AB is equal to the minterm m3, a 1 is placed in the cell corresponding 
to m3. Similarly, the function A + B has three minterms of A′B, AB′, and AB, as
 
A + B = A (B + B′) + B (A + A′) = AB + AB′ + AB + A′B = A′B + AB′ + AB.
So the squares corresponding to A′B, AB′, and AB are marked with 1 as shown in 
Figure 4.2(b).
 
B′ 
B 
 
B′ 
B
  A′
m0
m1 
A′ 
A′B′ 
A′B
  A 
m2
m1 
A 
AB′ 
AB
Figure 4.1(a) 
 
 
Figure 4.1(b)
 
 
 
 
B′ 
B 
 
B′ 
B
  A′ 
 
 
A′ 
 
1
  A 
 
1 
A 
1 
1
 
 
   F = AB 
 
 
 
 
  F = A + B
Figure 4.2(a) 
 
 
Figure 4.2(b)
4.3  THREE-VARIABLE KARNAUGH MAPS
Since, there are eight minterms for three variables, the map consists of eight cells or squares, 
which is shown in Figure 4.3(a). It may be noticed that the minterms are arranged, not 
according to the binary sequence, but according to the sequence similar to the reﬂ ected code, 
which means, between two consecutive rows or columns, only one single variable changes 
its logic value from 0 to 1 or from 1 to 0. Figure 4.3(b) shows the relationship between the 
squares and the variables. Two rows are assigned to A′ and A, and four columns to B′C′,
B′C, BC, and BC′. The minterm m3, for example, is assigned in the square corresponding 
to row 0 and column 11, thus making the binary number 011. Another way of analyzing 
the square m3, is to consider it to be in the row A′ and column BC, as m3 = A′BC. Note 
that, each of the variables has four squares where its logic value is 0 and four squares 
with logic value 1.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 91
Figure 4.3 (a)
Figure 4.3 (b)
Figure 4.4 (a) 
Figure 4.4 (b)
The three-variable Karnaugh Map can be constructed in other ways, too. Figure 4.4(a)
shows if variable C is assigned to the rows and variables A and B are assigned along the 
columns. Figure 4.4(b) demonstrates where variable A is along columns and variables 
B and C are along the rows. Corresponding minterms are shown in the ﬁ gures.
To understand the usefulness of the map for simplifying the Boolean functions, we 
must observe the basic properties of the adjacent squares. Any two adjacent squares in 
the Karnaugh map differ by only one variable, which is complemented in one square and 
uncomplemented in one of the adjacent squares. For example, in Figure 4.3(a), m1 and 
m3 are placed at adjacent squares, where variable B is complemented at m1 while it is 
uncomplemented at m3. From the postulates of Boolean algebra, the sum of two minterms 
can be simpliﬁ ed to a single AND term consisting of less number of literals. As in the case 
of m1 and m3, m1 + m3 can be reduced to the term below.
 
 
m1 + m3 = AB′C + ABC = AC (B′ + B) = AC
So it can be observed, the variable which has been changed at the adjacent squares 
can be removed, if the minterms of those squares are ORed together.
Example 4.1. Simplify the Boolean function
 
 
 
F = A′BC + A′BC′ + AB′C′ + AB′C.
Solution. First, a three-variable Karnaugh map is drawn and 1s are placed at the 
squares according to the minterms of the function as shown in Figure 4.5. Now two 1s 
m0
m1
m5
m7
m6
m3
m2
B C′
′
B C
′
BC
BC′
A′
A
B C′
′
B C
′
BC
BC′
A′
A
A B C
′ ′ ′
A B C
′ ′
A BC
′
A BC
′
′
AB C
′ ′
AB C
′
ABC
ABC′
A B
′ ′
A B
′
AB
AB′
C′
C
m3
m7
m5
m0
m2
m6
m4
                  
A′
m0
m4
m1
m5
m3
m7
m2
m6
A
B C
′
′
B C
′
BC
BC′

92
DIGITAL PRINCIPLES AND LOGIC DESIGN
of adjacent squares are grouped together. As in the ﬁ gure, A′BC and A′BC′ are grouped 
together at the ﬁ rst row, and AB′C′ and AB′C are grouped together. From the ﬁ rst row, the 
reduced term of ABC + A′BC′ is A′B, as C is the variable which changes its form. Similarly 
from the second row, AB′C′+ AB′C can be simpliﬁ ed to AB′. Now, as further simpliﬁ cation 
is not possible for this particular Boolean function, the simpliﬁ ed sum of the product of the 
function can be written as,
 
 
 
F = A′B + AB′.
 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
 
 
1 
1 
 
 
 
 
 
 
A 
1 
1 
 
 
 
 
Figure 4.5
Example 4.2. Simplify the expression F = A′BC + AB′C′ + ABC + ABC′.
Solution. The Karnaugh map for this function is shown in Figure 4.6. There are four 
squares marked with 1s, each for one of the minterms of the function.
 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
 
 
1 
 
 
 
 
 
 
 
A  
1 
 
1 
1 
 
 
 
Figure 4.6
In the third column, two adjacent squares are grouped together to produce the simpliﬁ ed 
term BC. The other two 1s are placed at the ﬁ rst column and last column of the same second 
row. Note that these 1s or minterms can be combined to produce a reduced term. Here the 
B variable is changing its form, from uncomplemented to complemented. After combining 
these two minterms, we get the reduced term AC′. This can be conﬁ rmed by applying the 
Boolean algebra, AB′C′ + ABC′ = AC′ (B + B′) = AC′.
Therefore, the ﬁ nal simpliﬁ ed expression can be written as,
 
 
 
F = BC + AC′.
As in the previous examples, it is shown that two adjacent squares consisting of 1s 
can be combined to form reduced terms. Similarly, it is possible to combine four adjacent 
squares consisting of 1s, in the process of simpliﬁ cation of Boolean functions. Let us consider 
the next example.
Example 4.3. Simplify the expression F = A′B′C + A′BC + A′BC′ + AB′C + ABC.
Solution. The Karnaugh map is shown in Figure 4.7. The four adjacent squares 
comprising the minterms A′B′C, A′BC, AB′C, and ABC can be combined. Here, it may 
observed that two of the variables A and B are changing their forms form uncomplemented 
to complemented. Therefore, these variables can be removed to form the reduced expression 
to C.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 93
 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
 
1 
1 
1 
 
 
 
 
 
 
A 
 
1 
1 
 
Figure 4.7
Again, two adjacent squares comprising the minterms A′BC and A′BC′ can be combined to 
produce the reduced term A′B. So the ﬁ nal simpliﬁ ed expression of the given function is 
 
  
F = C + A′B.
Note that squares that are already considered in one group, can be combined with 
other group or groups.
Example 4.4. Simplify the expression F (A, B, C) = Σ (0, 2, 4, 5, 6).
 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
1 
 
 
1 
 
 
 
 
 
 
A 
1 
1 
 
1 
Figure 4.8
The Karnaugh map is shown in Figure 4.8. Here, the minterms are given by their 
decimal-equivalent numbers. The squares according to those minterms are ﬁ lled with 1s. A′B′C′,
ABC′, AB′C′, and ABC′ are grouped to produce the reduced term of C′ and, AB′C′ and AB′C
are grouped to produce the term AB′. So the ﬁ nal simpliﬁ ed expression may be written as 
 
 
F = C′ + AB′.
Note that four squares of the ﬁ rst column and last column may be combined just like 
the two squares combination explained in Example 4.2.
4.4  FOUR-VARIABLE KARNAUGH MAPS
Similar to the method used for two-variable and three-variable Karnaugh maps, four-variable 
Karnaugh maps may be constructed with 16 squares consisting of 16 minterms as shown 
in Figure 4.9(a). The same is redrawn in Figure 4.9(b) to show the relationship with the 
four binary variables. The rows and columns are numbered in a reﬂ ected code sequence, 
where only one variable is changing its form between two adjacent squares. The minterm 
of a particular square can be obtained by combining the row and column. As an example, 
the minterm of the second row and third column is A′BCD i.e., m7.
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
CD′
 
A′B′
m0
m1
m3
m2 
A′B′ A′B′C′D′ 
A′B′C′D 
A′B′CD 
A′B′CD′
 
A′B
m4
m5
m7
m6 
A′B 
A′BC′D′ 
A′BC′D 
A′BCD 
A′BCD’′
 
AB 
m12
m13
m15
m14 
AB 
ABC′D′ 
ABC′D 
ABCD 
ABCD′
 
AB′
m8
m9
m11
m10 
AB′ 
AB′C′D′ 
AB′C′D 
AB′CD 
AB’CD′
 
 
 Figure 4.9(a)  
Figure 4.9(b)

94
DIGITAL PRINCIPLES AND LOGIC DESIGN
Different four-variable Karnaugh maps can be redrawn, if the variables are assigned 
an other way. Figure 4.10(a) and 4.10(b) also demonstrate the location of minterms for 
four-variable Karnaugh maps when variables A and B are assigned along the columns and 
variables C and D are assigned along the rows. 
 
 
A′B′ 
A′B 
AB 
AB′ 
 
A′B′ 
A′B 
AB 
AB′
 
C′D′
m0
m4
m12
m8 
C′D′ A′B′C′D′ 
A′BC′D′ 
ABC′D′ 
AB′C′D′
 
C′D
m1
m5
m13
m9 
C′D 
A′B′C′D 
A′BC′D 
ABC′D 
AB′C′D
 
CD 
m3
m7
m15
m11 
CD 
A′B′CD 
A′BCD 
ABCD 
AB′CD
 
CD′
m2
m6
m14
m10 
CD′ 
A′B′CD′ 
A′BCD′ 
ABCD′ 
AB′CD′
 
 
 Figure 4.10(a)  
 
Figure 4.10(b)
The minimization of four-variable Boolean functions using Karnaugh maps is similar to 
the method used to minimize three-variable functions. Two, four, or eight adjacent squares 
can be combined to reduce the number of literals in a function. The squares of the top and 
bottom rows as well as leftmost and rightmost columns may be combined. For example, m0
and m2 can be combined, as can m4 and m6, m12 and m14, m8 and m10, m0 and m8, m1 and 
m9, m3 and m11, and m2 and m10. Similarly, the four squares of the corners i.e., the minterms 
m0, m2, m8, and m10 can also be combined.
When two adjacent squares are combined, it is called a pair and represents a term 
with three literals.
Four adjacent squares, when combined, are called a quad and its number of literals is 
two.
If eight adjacent squares are combined, it is called an octet and represents a term 
with one literal.
If, in the case all sixteen squares can be combined, the function will be reduced to 1.
Example 4.5. Simplify the expression F (A, B, C, D) = m1 + m5 + m10 + m11 + m12 + 
m13 + m15.
Solution. The Karnaugh map for the above expression is shown in Figure 4.11.
 
 
C′D′ 
C′D 
CD 
CD′
 
A′B′ 
 
1 
 
 
 
A′B 
 
1 
 
 
AB 
1 
1 
1 
 
 
 
AB′ 
 
 
1 
1 
 
Figure 4.11
From the ﬁ gure, it can be seen that four pairs can be formed. The simpliﬁ ed expression 
may be written as, F = A′C′D + ABC′ + ACD + AB′C.
Note that the reduced expression is not a unique one, because if pairs are formed in 
different ways as shown in Figure 4.12, the simpliﬁ ed expression will be different. But both 
expressions are logically correct.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 95
The simpliﬁ ed expression of the given function as per the Karnaugh map of Figure 
4.12 is
 
 
F = A′C′D + ABC′ + ABD + AB′C.
  
 
C′D′ 
C′D 
CD 
CD′
 
A′B′ 
 
1 
 
 
 
 
 
 
 
 
A′B 
 
1 
 
 
 
 
 
 
 
 
AB  
1 
1 
1 
 
 
 
 
 
 
 
AB′ 
 
 
1 
1 
 
 
Figure 4.12
Example 4.6. Simplify the expression F (A, B, C, D) = m7 + m9 + m10 + m11 + m12 + 
m13 + m14 + m15.
Solution. The Karnaugh map for the above expression is shown in Figure 4.13.
 
 
C′D′ 
C′D 
CD 
CD′
  
A′B′ 
 
 
 
 
 
A′B 
 
 
1 
 
 
 AB  
1 
1 
1 
1 
 
 
 
 
 AB′ 
 
1 
1 
1 
 
Figure 4.13
Three quads and one pair are formed as shown in the ﬁ gure.
The simpliﬁ ed expression of the given function is,
 
 
F = AB + AC + AD + BCD.
Example 4.7. Plot the logical expression F(A, B, C, D) = ABCD + AB′C′D′ + AB′C + 
AB on a four-variable Karnaugh map. Obtain the simpliﬁ ed expression.
Solution. To form a Karnaugh map for a logical expression, the function is to be 
expanded to either canonical SOP form or canonical POS form. The canonical SOP form 
for the above expression can be obtained as follows.
 F (A, B, C, D) 
= ABCD + AB′C′D′ + AB′C + AB
 
 
= ABCD + AB′C′D′ + AB′C (D + D′) + AB (C + C′) (D + D′)
 
 
= ABCD + AB′C′D′ + AB′CD + AB′CD′ + (ABC + ABC′) (D + D′)
 
 
= ABCD + AB′C′D′ + AB′CD + AB′CD′ + ABCD + ABC′D + 
 
 
  
ABCD′ + ABC′D′
 
 
= ABCD + AB′C′D′ + AB′CD + AB′CD′ + ABC′D + ABCD′ + ABC′D′
 
 
= Σ (8, 10, 11, 12, 13, 14, 15)
The Karnaugh map for the above expression is shown in Figure 4.14.

96
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
C′D′ 
C′D 
CD 
CD′
  
A′B′ 
 
 
 
 
 
 
 
 
 
  
A′B 
 
 
 
 
 
 
 
 
 
 
AB 
1 
1 
1 
1 
 
 
 
 
 
 
AB′ 
1 
 
1 
1 
Figure 4.14
Three quads (one of them is a roll-over type formed with ﬁ rst column and fourth 
column) are formed. The simpliﬁ ed expression is
 
 
 
 
F = AB + AC + AD′.
Example 4.8. Simplify the expression F (W,X,Y,Z) = Σ (0, 1, 2, 4, 5, 6, 8, 9, 12, 13, 14).
Solution. The Karnaugh map for the above function is shown in Figure 4.15.
One octet and two quads are formed. The simpliﬁ ed expression is
 
 
 
 
F = Y′ + W′Z′ + XZ′.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
  
W′X′ 
1 
1 
 
1 
 
 
 
 
 
  
W′X 
1 
1 
 
1 
 
 
 
 
 
  
WX  
1 
1 
 
1 
 
WX′ 
1 
1 
 
 
Figure 4.15
Example 4.9. Simplify the expression F (W, X, Y, Z) = W′X′Y′ + X′YZ′ + W′XYZ′ + 
WX′Y′.
Solution. To obtain the minterms for the above expression, it needs to be expanded 
to the canonical SOP form as below.
F (W,X,Y,Z) = W′X′Y′ + X′YZ′ + W′XYZ′ + WX′Y′
 
= W′X′Y′ (Z + Z′) + X′YZ′(W + W′) + W′XYZ′ + WX′Y′(Z + Z′)
 
= W′X′Y′Z + W′X′Y′Z′ + WX′YZ′ + W′X′YZ′ + W′XYZ′ + WX′Y′Z + WX′Y′Z′
The Karnaugh map for the above function is shown in Figure 4.16.
One pair and two quads are formed (one quad consists of the four squares of the 
corners). The simpliﬁ ed expression is 
 
 
 
F = X′Y′ + X′Z′ + W′YZ′.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 97
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
W′X′ 
1 
1 
 
1 
 
 
 
 
 
 
W′X 
 
 
 
1 
 
 
 
 
 
 
WX  
 
 
 
 
 
 
 
 
 
 
WX′ 
1 
1 
 
1  
 
 
 
 
Figure 4.16
Note that, to form the Karnaugh map above like an expression, it is not always 
necessary to expand the Boolean expression as described above. For the term W′X′Y′, the 
squares W′X′Y′Z and W′X′Y′Z′ are marked with 1s. For the term X′YZ′′, the squares WX′YZ′
and W′X′YZ′ are marked with 1s. For the term WX′Y′, the squares WX′Y′Z and WX′Y′Z′
are marked with 1s. Lastly, the term W′XYZ′ is the minterm itself, and is marked with 1. 
After forming the Karnaugh map, SOP expression can be realized as above.
Example 4.10. Simplify the expression F (W,X,Y,Z) = Σ (3, 4, 5, 7, 9, 13, 14, 15).
Solution. The Karnaugh map for the above function is shown in Figure 4.17.
Four pairs are formed. It may be noted that one quad can also be formed, but it is 
redundant as the squares contained by the quad are already covered by the pairs which 
are essential. The simpliﬁ ed expression may be written as 
 
 
 
F = W′XY′ + W′YZ + WY′Z + WXY.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
  
W′X′ 
 
 
1 
 
 
W′X 
1 
1 
1 
 
 
 
 
 
 
  
WX  
 
1 
1 
1 
 
 
 
 
 
  
WX′ 
 
1 
 
 
 
 
Figure 4.17
Example 4.11. Simplify the expression F (W,X,Y,Z) = 
 (0, 1, 4, 5, 6, 8, 9, 12, 13, 14).
Solution. The above expression is given in respect to the maxterms. In the Karnaugh 
map, 0s are to placed instead of 1s at the corresponding maxterm squares. The rest of the 
squares are ﬁ lled with 1s.
The Karnaugh map for the above function is shown in Figure 4.18(a). There are two 
ways to achieve the minimized expression above. One way to is consider the 0s of the 
Karnaugh map. One octet and one quad has been formed with 0s. As we are considering 
the 0s, the simpliﬁ ed expression will be,
 
 
 
F′ = Y′ + XZ′.

98
DIGITAL PRINCIPLES AND LOGIC DESIGN
 Or,   
 
F = (Y′ + XZ′)′ = Y (X′ + Z).
 
 
Y′Z′ 
Y′Z 
Y′Z′ 
YZ′
  
W′X′ 
0 
0 
1 
1 
 
 
 
 
 
 
 W′X 
0 
0 
1 
0 
 
 
 
 
 
 
 WX  
0 
0 
1 
0 
 
 
 
 
 
  
WX′ 
0 
0 
1 
1 
Figure 4.18(a)
The other way to achieve the minimized expression is to consider the 1s of the Karnaugh 
map as shown in Figure 4.18(b). Two quads are formed considering the 1s.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
  
W′X′ 
0 
0 
1 
1 
 
 
 
 
 
 
 W′X 
0 
0 
1 
0 
 
 
 
 
 
  
WX  
0 
0 
1 
0 
 
 
 
 
 
  
WX′ 
0 
0 
1 
1 
Figure 4.18(b)
The minimized expression can be written as 
 
 
 
 
F  
=  YZ + X′Y
 
 
 
  
 
=  Y(X′ + Z).
Note that the ﬁ nal expressions are the same in both cases.
Example 4.12. Obtain (a) the minimal sum of the products and (b) minimal product 
of the sums for the function F (W,X,Y,Z) = Σ (0, 1, 2, 5, 8, 9, 10).
Solution.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
  
W′X′ 
1 
1 
0 
1 
 
 
 
 
 
  
W′X 
0 
1 
0 
0 
 
 
 
 
 
  
WX  
0 
0 
0 
0 
 
 
 
 
 
  
WX′ 
1 
1 
0 
1 
Figure 4.19(a)

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 99
(a) The Karnaugh map for the above function is shown in Figure 4.19(a). Two quads 
and a pair are formed considering the 1s of the Karnaugh map.
 
The SOP expression of the above is F = X′Y′ + X′Z′ + W′Y′Z.
(b) The Karnaugh map for the above function is shown in Figure 4.19(b). Three quads 
are formed considering the 0s of the Karnaugh map.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
  
W′X′ 
1 
1 
0 
 1 
 
 
 
 
 
  
W′X 
0 
1 
0 
0 
 
 
 
 
 
  
WX  
0 
0 
0 
0 
 
 
 
 
 
  
WX′ 
1 
1 
0 
1 
Figure 4.19(b)
The POS expression of above funtion can be derived as,
 
 
 
F′ = XZ′ + WX + YZ.
 
Or,  
 
F = (X′ + Z) (W′ + X′) (Y′ + Z′).
4.5  FIVE-VARIABLE KARNAUGH MAPS
Karnaugh maps with more than four variables are not simple to use. The number of cells or 
squares becomes excessively large and combining the adjacent squares becomes complex. The 
number of cells or squares is always equal to the number of minterms. A ﬁ ve-variable Karnaugh 
map contains 25 or 32 cells, which are used to simplify any ﬁ ve-variable logic function. Figures 
4.20(a) and 4.20(b) demonstrate the ﬁ ve-variable Karnaugh map and its minterms.
 
 
C′D′E′ 
C′D′E 
C′DE 
C′DE′  
CDE′ 
CDE 
CD′E 
CD′E′
A′B′
m0
m1
m3
m2
m6
m7
m5
m4
 
A′B
m8
m9
m11
m10
m14
m15
m13
m12
 
AB 
m24
m25
m27
m26
m30
m31
m29
m28
 
AB′
m16
m17
m19
m18
m22
m23
m21
m20
Figure 4.20(a)
 
 
C′D′E′ 
C′D′E 
C′DE 
C′DE′  
CDE′ 
CDE 
CD′E 
CD′E′
 
A′B′  A′B′C′D′E′
 A′B′C′D′E A′B′C′DE  A′B′C′DE′  A′B′CDE′  A′B′CDE  A′B′CD′E  A′B′CD′E′
 
A′B 
 A′B C′D′E′  A′B C′D′E  A′B C′DE  A′B C′DE′  A′BCDE′  A′BCDE  A′BCD′E  A′BCD′E′
 
AB  
 ABC′D′E′  ABC′D′E  ABC′DE 
 ABC′DE′  ABCDE′ 
 ABCDE  ABCD′E 
 ABCD′E′
 
AB′ 
 AB′C′D′E′  AB′C′D′E  AB′C′DE  AB′C′DE′  AB′CDE′  AB′CDE  AB′CD′E  AB′CD′E′
Figure 4.20(b)

100
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figures 4.21, 4.22, and 4.23 also demonstrate ﬁ ve-variable Karnaugh maps, if the 
variables are assigned in different ways. The ﬁ ve-variable Karnaugh maps have properties 
similar to the two-, three-, or four-variable Karnaugh maps described earlier, i.e., adjacent 
squares can be grouped together. In addition to those, while making groups or combinations, 
in Figures 4.20 and 4.21, the 1st column with 4th column, 2nd column with 7th column, and 
3rd column with 6th column can be combined together, as there is only one variable which is 
changing its form for those columns. Similarly, according to Figures 4.22 and 4.23, the 1st
row with 4th row, 2nd row with 7th row, and 3rd row with 6th row can be combined together 
to get the terms of reduced literals.
 
 
A′B′C′ 
A′B′C 
A′BC 
A′BC′  
ABC′ 
ABC 
AB′C 
AB′C′
 
C′D′
m0 
m4 
m12 
m8  
m24 
m28 
m20 
m16
 
C′D
m1 
m5 
m13 
m9  
m25 
m29 
m21 
m17
 
CD 
m3 
m7 
m15 
m11  
m27 
m31 
m23 
m19
 
 CD′
m2 
m6 
m14 
m10  
m26 
m30 
m22 
m18
Figure 4.21
 
 
D′E′ 
D′E 
DE 
DE′ 
 
A′B′ 
A′B 
AB 
AB′
 
A′B′C′
m0
m1
m3
m2 
C′D′E′
m0
m8
m24
m16
 
A′B′C
m4
m5
m7
m6 
C′D′E
m1
m9
m25
m17
 
A′BC
m11
m12
m15
m14 
C′DE
m3
m11
m27
m19
 
A′BC′
m8
m9
m7
m10 
C′DE′
m2
m10
m26
m18
 
 
 
 
 
 
 
 
 
 
ABC′
m24
m25
m27
m26 
CDE′
m6
m14
m30
m22
 
ABC 
m28
m29
m31
m30 
CDE 
m7
m15
m31
m23
 
AB′C
m20
m21
m23
m22 
CD′E
m5
m13
m29
m21
 
AB′C′
m16
m17
m19
m18 
CD′E′
m4
m12
m28
m20
Figure 4.22 
Figure 4.23
4.6 
SIX-VARIABLE KARNAUGH MAPS
Six-variable Karnaugh maps consist of 26 or 64 squares or cells. Similar to the method 
described above, six-variable Karnaugh maps are formed with 64 minterms as demonstrated 
in Figure 4.24(a). Figure 4.24(b) also represents six-variable Karnaugh maps when the 
variables are assigned differently.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 101
Apart from the properties described for two-, three- and four-variable Karnaugh maps 
that adjacent squares can be grouped together, similar to ﬁ ve-variable maps, the 1st column 
with 4th column, 2nd column with 7th column, 3rd column with 6th column, 1st row with 4th
row, 2nd row with 7th row, and 3rd row with 6th row can be combined together to get the 
terms of reduced literals.
 
 
D′E′F′ 
D′E′F 
D′EF 
D′EF′  
DEF′ 
DEF 
DE′F 
DE′F′
 
A′B′C′
m0
m1
m3
m2
m6
m7
m5
m4
 
A′B′C
m8
m9
m11
m10
m14
m15
m13
m12
 
A′BC
m24
m25
m27
m26
m30
m31
m29
m28
 
A′BC′
m16
m17
m19
m18
m22
m23
m21
m20
 
ABC′
m48
m49
m51
m50
m54
m55
m53
m52
 
ABC 
m56
m57
m59
m58
m62
m63
m61
m60
 
AB′C
m40
m41
m43
m42
m46
m47
m45
m44
 
AB′C′
m32
m33
m35
m34
m38
m39
m37
m36
Figure 4.24(a)
 
 
A′B′C′ 
A′B′C 
A′BC 
A′BC′  
ABC′ 
ABC 
AB′C 
AB′C′
 
D′E′F′
m0
m8
m24
m16
m48
m56
m40
m32
 
D′E′F
m1
m9
m25
m17
m49
m57
m41
m33
 
D′EF
m3
m11
m27
m19
m51
m59
m43
m35
 
D′EF′
m2
m10
m26
m18
m50
m58
m42
m34
 
DEF′
m6
m14
m30
m22
m54
m62
m46
m38
 
DEF 
m7
m15
m31
m23
m55
m63
m47
m39
 
DE′F
m5
m13
m29
m21
m53
m61
m45
m37
 
DE′F′
m4
m12
m28
m20
m52
m60
m44
m36
Figure 4.24(b)
Example 4.13. Obtain the minimal sum of the products for the function 
 F (A, B, C, D, E) = Σ (0, 2, 5, 7, 9, 11, 13, 15, 16, 18, 21, 23, 25, 27, 29, 31).
Solution. The ﬁ ve-variable Karnaugh map for the above function is shown in Figure 
4.25.

102
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
C′D′E′ 
C′D′E 
C′DE 
C′DE′  
CDE′ 
CDE 
CD′E 
CD′E′
 
 
 
 
 
 
 
 
 
 
A′B′ 
1 
 
 
1 
 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
 
1 
1 
 
 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
 
1 
1 
 
 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
1 
 
 
1 
 
 
1 
1 
 
Figure 4.25
An octet at the 6th and 7th column with 1st to 4th rows, one octet at the 2nd, 3rd, 6th,
and 7th columns with 2nd and 3rd rows, and one quad at the 1st and 4th rows with 1st and 
4th columns are formed. The minimized expression can be written as,
 
 
 
F = CE + BE + B′C′E′.
Example 4.14. Obtain the minimal sum of the products for the function 
  F (A, B, C, D, E) = Σ (0, 2, 4, 6, 9, 11, 13, 15, 17, 21, 25, 27, 29, 31).
Solution. The ﬁ ve-variable Karnaugh map for the function is shown in Figure 4.26.
 
 
C′D′E′ 
C′D′E 
C′DE 
C′DE′  
CDE′ 
CDE 
CD′E 
CD′E′
 
A′B′ 
1 
 
 
1 
 
1 
 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
 
1 
1 
 
 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
 
1 
1 
 
 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
 
1 
 
 
 
 
 
1
Figure 4.26
An octet at the 2nd, 3rd, 6th, and 7th columns with 2nd and 3rd rows, one quad at the 
1st row with 1st, 4th, 5th, and 8th columns, and one quad at 3rd and 4th rows with 2nd and 6th
columns are formed. The minimized expression can be written as,
 
 
 
F = BE + A′B′E′ + AD′E.
4.7  DON’T-CARE COMBINATIONS
In certain digital systems, some input combinations never occur during the process of a 
normal operation because those input conditions are guaranteed never to occur. Such input 
combinations are called Don’t-Care Combinations. The function output may be either 1 or 
0 and these functions are called incompletely speciﬁ ed functions. These input combinations 
can be plotted on the Karnaugh map for further simpliﬁ cation of the function. The don’t-
care combinations are represented by d or x or Φ.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 103
When an incompletely speciﬁ ed function, i.e., a function with don’t-care combinations 
is simpliﬁ ed to obtain minimal SOP expression, the value 1 can be assigned to the selected 
don’t care combinations. This is done to form groups like pairs, quadoctet, etc., for further 
simpliﬁ cation. In each case, choice depends only on need to achieve simpliﬁ cation. Similarly, 
selected don’t care combinations may be assumed as 0s to form groups of 0s for obtaining 
the POS expression.
Example 4.15. Obtain the minimal sum of the products for the function
 
 
F (A, B, C, D) = Σ (1,3,7,11,15) + Φ(0,2,5).
The Karnaugh map for the above function is shown in Figure 4.27.
 
 
C′D′ 
C′D 
CD 
CD′
  
A′B′ 
X 
1 
1 
X 
 
 
 
 
 
  
A′B
X 
1 
  
AB  
1
  
AB′
1
 
 
 
 
 
 
Figure 4.27
In the Karnaugh map of Figure 4.27, the minterm m0 and m2 i.e., A′B′C′D′ and 
A′B′CD′, are the don’t care terms which have been assumed as 1s, while making a quad. 
The simpliﬁ ed SOP expression of above function can be written as 
 
 
 
F = A′B′ + CD.
4.8  THE TABULATION METHOD
The Karnaugh map method is a very useful and convenient tool for simpliﬁ cation of Boolean 
functions as long as the number of variables does not exceed four (at the most six). But if 
the number of variables increases, the visualization and selection of patterns of adjacent 
cells in the Karnaugh map becomes complicated and difﬁ cult. The tabular method, also 
known as the Quine-McCluskey method, overcomes this difﬁ culty. It is a speciﬁ c step-by-step 
procedure to achieve guaranteed, simpliﬁ ed standard form of expression for a function.
The following steps are followed for simpliﬁ cation by the tabular or Quine-McCluskey 
method.
 
1. An exhaustive search is done to ﬁ nd the terms that may be included in the simpliﬁ ed 
functions. These terms are called prime implicants.
 
2. Form the set of prime implicants, essential prime implicants are determined by 
preparing a prime implicants chart.
 
3. The minterms that are not covered by the essential prime implicants, are taken into 
consideration by selecting some more prime implications to obtain an optimized Boolean 
expression.

104
DIGITAL PRINCIPLES AND LOGIC DESIGN
4.8.1 Determination of Prime Implicants
The prime implicants are obtained by the following procedure:
 
1. Each minterm of the function is expressed by its binary representation.
 
2. The minterms are arranged according to increasing index (index is deﬁ ned as the 
number of 1s in a minterm). Each set of minterms possessing the same index are 
separated by lines.
 
3. Now each of the minterms is compared with the minterms of a higher index. For 
each pair of terms that can combine, the new terms are formed. If two minterms are 
differed by only one variable, that variable is replaced by a ‘-’ (dash) to form the new 
term with one less number of literals. A line is drawn in when all the minterms of 
one set is compared with all the minterms of a higher index.
 
4. The same process is repeated for all the groups of minterms. A new list of terms is 
obtained after the ﬁ rst stage of elimination is completed.
 
5. At the next stage of elimination two terms from the new list with the ‘-’ of the same 
position differing by only one variable are compared and again another new term is 
formed with a less number of literals. 
 
6. The process is to be continued until no new match is possible.
 
7. All the terms that remain unchecked i.e., where no match is found during the process, 
are considered to be the prime implicants.
4.8.2 Prime Implicant Chart
 
1. After obtaining the prime implicants, a chart or table is prepared where rows are 
represented by the prime implicants and the columns are represented by the minterms 
of the function.
 
2. Crosses are placed in each row to show the composition of the minterms that makes 
the prime implicants.
 
3. A completed prime implicant table is to be inspected for the columns containing only 
a single cross. Prime implicants that cover the minterms with a single cross are called 
the essential prime implicants.
The above process to ﬁ nd the prime implicants and preparation of the chart can be 
illustrated by the following examples.
Example 4.16. Obtain the minimal sum of the products for the function 
   
 
F (A, B, C, D) = Σ (1, 4, 6, 7, 8, 9, 10, 11, 15).
Solution. The table in Figure 4.28 shows the step-by-step procedure the Quine-
McCluskey method uses to obtain the simpliﬁ ed expression of the above function.
Column I consists of the decimal equivalent of the function or the minterms and column 
II is the corresponding binary representation. They are grouped according to their index i.e.,
number of 1s in the binary equivalents. In column III, two minterms are grouped if they are 
differed by only a single variable and equivalent terms are written with a ‘-’ in the place 
where the variable changes its logic value. As an example, minterms 1 (0001) and 9 (1001) 
are grouped and written as 1,9 (– 001) and so on for the others. Also, the terms of column 
II, which are considered to form the group in column III, are marked with ‘√’.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 105
I 
II 
III 
IV
 
Decimal  
Binary equivalent 
 
 
 
 equivalent 
A 
B 
C 
D 
 
     ABCD 
 
      ABCD
 
1 
0 
0 
0 
1 
√ 
1,9 
–001 
 
8,9,10,11  10– –
 
4 
0 
1 
0 
0 
√ 
4,6 
01–0 
 
8,10,9,11  10– – 
 
8 
1 
0 
0 
0 
√ 
8,9 
100– 
√
 
 
 
 
 
 
 
8,10 
10–0 
√
 
6 
0 
1 
1 
0 
√ 
6,7 
011–
 
9 
1 
0 
0 
1 
√ 
9,11 
10–1 
√
 
10 
1 
0 
1 
0 
√ 
10,11 
101– 
√
 
7 
0 
1 
1 
1 
√ 
7,15 
–111
 
11 
1 
0 
1 
1 
√ 
11,15 
1–11
 
15 
1 
1 
1 
1 
√
Figure 4.28
The terms which are not marked with ‘√’ are the Prime implicants. To express the 
prime implicants algebraically, variables are to be considered as true form in place of 1s, as 
complemented form in place of 0s, and no variable if ‘-’ appears. Here the prime implicants 
are B′C′D, A′BD′, A′BC, BCD, ACD (from column III), and AB′ (from column IV). So the 
Boolean expression of the given function can be written as 
 
 
F = AB′ + B′C′D + A′BD′ + A′BC + BCD + ACD.
But the above expression may not be of minimized form, as all the prime implicants 
may not be necessary. To ﬁ nd out the essential prime implicants, the following steps are 
carried out. A table or chart consisting of prime implicants and the decimal equivalent of 
minterms as given in the expression, as in Figure 4.29 is prepared.
Prime
 Implicants 
1 
4 
6 
7 
8 
9 
10 
11 
15 
√ AB′ 
 
 
 
 
X 
X 
X 
X 
 
√ B′C′D 
X 
 
 
 
 
X
√ A′BD′ 
 
X 
X 
 
 
 
 
 
 
   A′BC 
 
 
X 
X 
 
 
 
 
 
   BCD 
 
 
 
X 
 
 
 
 
X 
   ACD 
 
 
 
 
 
 
 
X 
X 
√
√
√
√
√
√
√
Figure 4.29

106
DIGITAL PRINCIPLES AND LOGIC DESIGN
In the table, the prime implicants are listed in the 1st column and Xs are placed against 
the corresponding minterms. The completed prime implicant table is now inspected for the 
columns containing only a single X. As in Figure 4.29, the minterm 1 is represented by only 
a single prime implicant B′C′D, and only a single X in that column, it should be marked as 
well as the corresponding column should be marked. Similarly, the prime implicants AB′ and 
AB′D′ are marked. These are the essential prime implicants as they are absolutely necessary 
to form the minimized Boolen expression. Now all the other minterms corresponding to these 
prime implicants are marked at the end of the columns i.e., the minterms 1, 4, 6, 8, 9, 10, 
and 11 are marked. Note that the terms A′BC, BCD, and ACD are not marked. So they 
are not the essential prime implicants. However, the minterms 7 and 15 are still unmarked 
and both of them are covered by the term BCD and are included in the Boolean expression. 
Therefore, the simpliﬁ ed Boolen expression of the given function can be written as 
 
 
 
F = AB′ + B′C′D + A′BD′ + BCD.
The simpliﬁ ed expressions derived in the preceeding example are in the sum of products 
form. The Quine-McClusky method can also be adopted to derive the simpliﬁ ed expression 
in product of sums form. In the Karnaugh map method the complement of the function 
was considered by taking 0s from the initial list of the minterns. Similarly the tabulation 
method or Quine-McClusky method may be carried out by considering the 0s of the function 
to derive the sum of products form. Finally, by making the complement again, we obtain 
the simpliﬁ ed expression in the form of product of sums.
A function with don’t-care conditions can be simpliﬁ ed by the tabulation method with 
slight modiﬁ cation. The don’t-care conditions are to be included in the list of minterms while 
determining the prime implicants. This allows the derivation of prime implicants with the 
least number of literals. But the don’t-care conditions are excluded in the list of minterms 
when the prime implicants table is prepared, because these terms do not have to be covered 
by the selected prime implicants.
4.9  MORE EXAMPLES
Example 4.17. Obtain the minimal sum of the products for the function F (A,B,C,D) = Σ
(1, 2, 3, 7, 8, 9, 10, 11, 14, 15) by the Quine-McClusky method.
Solution. The ﬁ rst step is to ﬁ nd out the prime implicants as described by the table 
in Figure 4.30. 
The prime implicants are B′D, B′C, AB′, CD, and AC. The prime implicant table is 
prepared as in Figure 4.31.
 
I 
           II 
 
 
         III 
 
 
IV 
 
Decimal  
  Binary equivalent 
 
 
 
 equivalent 
A 
B 
C 
D 
 
       ABCD 
 
       ABCD 
 
1 
0 
0 
0 
1 
√ 
1,3 
00–1 
√ 
1,3,9,11  –0–1
 
2 
0 
0 
1 
0 
√ 
1,9 
–001 
√ 
2,3,10,11  –01–
 
8 
1 
0 
0 
0 
√ 
2,3 
001– 
√ 
8,9,10,11  10– –
 
 
 
 
 
 
 
2,10 
–010 
√ 
3,7,11,15  – –11

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 107
 
 
 
 
 
 
 
8,9 
100– 
√ 
10,11,14,15  1–1–
 
 
 
 
 
 
 
8,10 
10–0 
√
 
3 
0 
0 
1 
1 
√ 
3,7 
0–11 
√
 
9 
1 
0 
0 
1 
√ 
3,11 
–011 
√
 
10 
1 
0 
1 
0 
√ 
9,11 
10–1 
√
 
 
 
 
 
 
 
10,11 
101– 
√
 
 
 
 
 
 
 
10,14 
1–10 
√
 
7 
0 
1 
1 
1 
√ 
7,15 
–111 
√
 
11 
1 
0 
1 
1 
√ 
11,15 
1–11 
√
 
14 
1 
1 
1 
0 
√ 
14,15 
111– 
√
 
15 
1 
1 
1 
1 
√
Figure 4.30
 Prime
 Implicants 
1 
2 
3 
7 
8 
9 
10 
11 
14 
15 
√ B′D 
X 
 
X 
 
 
X 
 
X 
 
 
√ B′C 
 
X 
X 
 
 
 
X 
X 
 
 
√ AB′ 
 
 
 
 
X 
X 
X 
X 
 
 
√ CD 
 
 
X 
X 
 
 
 
X 
 
X 
√ AC 
 
 
 
 
 
 
X 
X 
X 
X 
√
√
√
√
√
√
√
√
√
√
Figure 4.31
All the prime implicants are essential. So the simpliﬁ ed Boolean expression of the 
given function is
 
 
 
F = B′D + B′C + AB′ + CD + AC.
Example 4.18. Using the Quine-McClusky method, obtain the minimal sum of the 
products expression for the function F(A, B, C, D) = Σ (1, 3, 4, 5, 9, 10, 11) + Φ (6, 8).
Solution. The prime implicants are obtained from the table in Figure 4.32.

108
DIGITAL PRINCIPLES AND LOGIC DESIGN
I 
         II  
 
 
         III 
 
       IV 
 
Decimal  
Binary equivalent 
 
 
 
 equivalent 
A 
B 
C 
D 
 
       ABCD 
 
     ABCD 
 
1 
0 
0 
0 
1 
√ 
1,3 
00–1 
√ 
1,3,9,11  –0 –1 
 
4 
0 
1 
0 
0 
√ 
1,5 
0–01 
 
8,9,10,11  10– –
 
8 
1 
0 
0 
0 
√ 
1,9 
–001 
√
 
 
 
 
 
 
 
4,5 
010–
 
 
 
 
 
 
 
4,6 
01–0
 
 
 
 
 
 
 
8,9 
100– 
√
 
 
 
 
 
 
 
8,10 
10–0 
√
 
3 
0 
0 
1 
1 
√ 
3,11 
–011 
√
 
5 
0 
1 
0 
1 
√ 
9,11 
10–1 
√
 
6 
0 
1 
1 
0 
√ 
10,11 
101– 
√
 
9 
1 
0 
0 
1 
√
 
10 
1 
0 
1 
0 
√
 
11 
1 
0 
1 
1 
√
Figure 4.32
The prime implicants are A′C′D, A′BC′, A′BD′, B′D, and AB′. The prime implicant table 
is prepared as in Figure 4.33.
Prime
  
Implicants  
1 
3 
4 
5 
9 
10 
11 
  
A′C′D 
 
X 
 
 
X 
 
 
 
  
A′BC′ 
 
 
 
X 
X 
 
 
 
  
A′BD′ 
 
 
 
X 
 
 
 
 
√ B′D 
 
X 
X 
 
 
X 
 
X 
√ AB′ 
 
 
 
 
 
X 
X 
X 
 
 
√
√ 
 
 
√
√
√
Figure 4.33

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 109
From the table, we obtain the essential prime implicants B′D and AB′. The minterms 
4 and 5 are not marked in the table. The term A′BC′ is considered, which covers both the 
minterms 4 and 5. So the simpliﬁ ed Boolean expression for the given function is
 
 
 
 
 
F = A′BC′ + B′D + AB′.
Example 4.19. Using the Karnaugh map method obtain the minimal sum of the 
products and product of sums expressions for the function 
 
 
 
 
F(A,B,C,D) = Σ (1, 3, 4, 5, 6, 7, 9, 12, 13).
Solution. The Karnaugh map for the above function is in Figure 4.34. To obtain the 
SOP expression, 1s of the Karnaugh map are considered.
 
 
C′D′ 
C′D 
CD 
CD′
  
A′B′ 
 
1 
1 
 
 
 
 
 
 
 
A′B 
1 
1 
1 
1 
 
 
 
 
 
  
AB  
1 
1 
 
 
 
 
 
 
 
  
AB′ 
 
1 
 
 
Figure 4.34
The simpliﬁ ed Boolean expression for the function is
 
 
 
 
F = A′B + BC′ + C′D + A′D.
To derive the POS expression, the 0s of the Karnaugh map are considered as in Figure 
4.35.
 
 
C′D′ 
C′D 
CD 
CD′
  
A′B′ 
0 
 
 
0 
 
 
 
 
 
 
 A′B 
 
 
 
 
 
 
 
 
 
  
AB  
 
 
0 
0 
 
 
 
 
 
  
AB′ 
0 
 
0 
0 
Figure 4.35
From the Karnaugh map we obtain F′ = AC + B′D′.
So the POS expression for the above function is
 
 
F = (AC + B′D′)′ = (AC)′. (B′D′)′ = (A′ + C′). (B + D).

110
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 4.20. Using the Karnaugh map method obtain the minimal sum of the 
products and product of sums expressions for the function 
 
 
 
F(A,B,C,D) = Σ (1, 5, 6, 7, 11, 12, 13, 15).
Solution. The Karnaugh map for the above function is in Figure 4.36. To obtain the 
SOP expression, 1s of the Karnaugh map are considered.
The simpliﬁ ed Boolean expression for the function is
 
 
 
F = A′C′D + A′BC + ABC′ + ACD = B(A′C + AC′) + D(A′C′ + AC)
 
  
 
  = B (A ⊕ C) + D(A ⊕ C)′.
 
 
C′D′ 
C′D 
CD 
CD′
 
 A′B′ 
 
1 
 
 
 
 
 
 
 
 
 A′B 
 
1 
1 
1 
 
 
 
 
 
 
 AB  
1 
1 
1 
 
 
 
 
 
 
 
 AB′ 
 
 
1 
Figure 4.36
To derive the POS expression, the 0s of the Karnaugh map are considered as in Figure 
4.37.
 
 
C′D′ 
C′D 
CD 
CD′
 
 A′B′ 
0 
 
0 
0 
 
 
 
 
 
 
 A′B 
0 
 
 
 
 
 
 
 
 
 
AB  
 
 
 
0 
 
 
 
 
 
 
AB′ 
0 
0 
 
0 
Figure 4.37
From the Karnaugh map we obtain 
   
 
F′ = A′C′D′ + A′B′C + AB′C′ + ACD′.
So the POS expression for the above function is
 
 
 
F = (A + C + D) (A + B + C′) (A′ + B + C) (A′ + C′ + D).
Example 4.21. Using the Karnaugh map method obtain the minimal sum of the 
products expression for the function 
   F(A,B,C,D) = Σ (0, 2, 3, 6, 7) +d (8, 10, 11, 15).
Solution. The Karnaugh map for the above function is in Figure 4.38.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 111
 
 
C’D′ 
C′D 
CD 
CD′
 
 A′B′ 
1 
 
1 
1 
 
 
 
 
 
  
A′B 
 
 
1 
1 
 
 
 
 
 
  
AB  
 
 
X 
 
 
 
 
 
 
  
AB′ 
X 
 
X 
X  
 
Figure 4.38
The simpliﬁ ed Boolean expression for the function is
 
 
 
 
F = A′C + B′D′.
Example 4.22. Using the Karnaugh map method obtain the minimal product of the 
sums expression for the function given in example 4.21.
Solution. To derive the POS expression, the 0s of the Karnaugh map are considered 
as in Figure 4.39.
 
 
C′D′ 
C′D 
CD 
CD′
  
A′B′ 
 
0 
 
 
 
 
 
 
 
  
A′B 
0 
0 
 
 
 
 
 
 
 
  
AB  
0 
0 
X 
0 
 
 
 
 
 
  
AB′ 
X 
0 
X 
X 
Figure 4.39
The simpliﬁ ed Boolean expression for the function is
 
 
 
F′ = A + C′D + BC′.
So  
F = A′ (C + D′) (B′ + C).
Example 4.23. Using the Karnaugh map method obtain the minimal sum of the 
products expression for the function 
 
F(A,B,C,D) = Σ (1, 5, 7, 13, 14, 15, 17, 18, 21, 22, 25, 29) + d(6, 9, 19, 23, 30).
Solution. The Karnaugh map for the above function is in Figure 4.40.

112
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
C′D′E′ 
C′D′E 
C′DE 
C′DE′  
CDE′ 
CDE 
CD′E 
CD′E′
 
 
 
 
 
 
 
 
 
 
 
A′B′ 
 
1 
 
 
 
X 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
 
X 
 
 
 
1 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
 
1 
 
 
 
X 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
 
1 
X 
1 
 
1 
X 
1 
Figure 4.40
The simpliﬁ ed Boolean expression for the function is
 
 
 
F = D′E + A′CD + AB′D.
Example 4.24. Using the Quine-McClusky method obtain the minimal sum of the 
products expression for the function
   
F(A,B,C,D,E) = Σ (0, 2, 3, 5, 7, 9, 11, 13, 14, 16, 18, 24, 26, 28, 30).
Solution. The prime implicants are obtained from the table in Figure 4.41.
I 
         II  
 
 
         III 
 
        IV 
 
Decimal  
Binary equivalent 
 
 
 
 equivalent 
A 
B 
C 
D 
E 
 
          ABCDE 
 
            ABCDE
 
0 
0 
0 
0 
0 
0 
√ 
0,2 
000–0 
√ 
0,2,16,18   –00–0
 
2 
0 
0 
0 
1 
0 
√ 
0,16 
–0000 
√ 
16,18,24,26  1–0–0
 
16 
1 
0 
0 
0 
0 
√ 
 
 
 
24,26,28,30 11– –0
 
3 
0 
0 
0 
1 
1 
√ 
2,3 
0001–
 
5 
0 
0 
1 
0 
1 
√ 
2,18 
–0010 
√
 
9 
0 
1 
0 
0 
1 
√ 
16,18 
100–0 
√
 
18 
1 
0 
0 
1 
0 
√ 
16,24 
1–000 
√
 
24 
1 
1 
0 
0 
0 
√
 
7 
0 
0 
1 
1 
1 
√ 
3,7 
00–11
 
11 
0 
1 
0 
1 
1 
√ 
3,11 
0–011
 
13 
0 
1 
1 
0 
1 
√ 
5,7 
001–1
 
14 
0 
1 
1 
1 
0 
√ 
5,13 
0–101
 
26 
1 
1 
0 
1 
0 
√ 
9,13 
01–01

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 113
 
28 
1 
1 
1 
0 
0 
√ 
18,26 
1–010 
√
 
 
 
 
 
 
 
 
24,26 
110–0 
√
 
 
 
 
 
 
 
 
24,28 
11–00 
√
 
30 
1 
1 
1 
1 
0 
√ 
14,30 
–1110
 
 
 
 
 
 
 
 
26,30 
11–10 
√
 
 
 
 
 
 
 
 
28,30 
111–0 
√
Figure 4.41
The prime implicant table is prepared as in Figure 4.42. 
The essential prime implicants are B′C′E′, ABE′, A′C′DE, A′BD′E, and BCDE′, as each 
of them represent at least one minterm which is not represented by any of the other prime 
implicants. The term A′B′CE may be considered to include minterms 5 and 7.
 Prime 
 Implicants 
0 
2 
3 
5 
7 
9 
11 
13 
14 
16 
18 
24 
26 
28 
30
√ B′C′E′ 
X X 
 
 
 
 
 
 
 
X 
X 
 
 
 
 
 AC′E′ 
 
 
 
 
 
 
 
 
 
X 
X 
X 
X 
 
 
√ ABE′ 
 
 
 
 
 
 
 
 
 
 
 
X 
X 
X 
X 
 A′B′C′D 
 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
 A′B′DE 
 
 
X 
 
X 
 
 
 
 
 
 
 
 
 
 
√ A′C′DE 
 
 
X 
 
 
 
X 
 
 
 
 
 
 
 
 
 A′B′CE 
 
 
 
X 
X 
 
 
 
 
 
 
 
 
 
 
 A′CD′E 
 
 
 
X 
 
 
 
X 
 
 
 
 
 
 
 
√ A′BD′E 
 
 
 
 
 
X 
 
X 
 
 
 
 
 
 
 
√ BCDE′ 
 
 
 
 
 
 
 
 
X 
 
 
 
 
 
X 
√
√
√ 
 
 
√
√
√
√
√
√
√
√
√
√
Figure 4.42
The simpliﬁ ed expression of the function is
 
 
F = B′C′E + ABE′ + A′C′DE + A′B′CE + A′BD′E + BCDE′.
4.10  VARIABLE-ENTERED KARNAUGH MAPS
There is another method of simpliﬁ cation of Boolean functions which is not widely used, 
but certainly has some importance from an academic point of view. Earlier in this section 
we have already discussed ﬁ ve-variable and six-variable Karnaugh maps, which are a little 
complex and difﬁ cult while making pairs, quads, or octets. Variable-entered Karnaugh maps
may be used in cases where the number of variables exceeds four. It is the useful extension 
of normal Karnaugh maps as discussed earlier. In variable-entered Karnaugh maps, one or 
more Boolean variables can be used as map entries along with 1s, 0s, and don’t-cares. The 
variables associated with the entries in these maps are called map-entered variables.

114
DIGITAL PRINCIPLES AND LOGIC DESIGN
The signiﬁ cance of variable-entered maps is that they provide for map compression. 
Normally an nth order Karnaugh map is associated with the Boolean functions of n number 
of variables. However, if one of the Boolean variables is used as a map-entered variable, the 
Karnaugh map will be reduced to an order of n–1. In general, if the number of map-entered 
variables is m of the total number of variables n, the Karnaugh map of the order of n–m
will sufﬁ ce to associate in the necessary simpliﬁ cation process. ( n > m ).
A useful application for variable-entered maps arises in the problems that have 
infrequently appearing variables. In such situations it is convenient to have the functions 
of the infrequently appearing variables as the entries within the map, allowing a high-order 
Boolean function to be represented by a low-order map.
4.10.1  Contruction of Variable-entered MAPS
To understand the construction of variable-entered Karnaugh maps, consider the generic 
truth table in Figure 4.43, where the functional value for row i is denoted by Fi. From the 
truth table the Karnaugh map is constructed in Figure 4.44. The entries within the cells 
are the Fi’s, which, in turn, correspond to the 0s, 1s, and don’t-cares that normally appear 
in the last column of the truth table.
Alternatively, the generic minterm canonical formula for the truth table of Figure 4.43 
can be written as 
 
F (A,B,C) = F0. A′B′C′ + F1.A′B′C + F2.A′BC′ + F3.A′BC + F4.AB′C′ + F5.AB′C
+ F6.ABC′ + F7.ABC.
Using Boolean algebra, this expression can be modiﬁ ed as 
F(A,B,C) = A′B′ (F0.C′ + F1.C) + A′B (F2.C′ + F3.C) + AB′ (F4.C′ + F5.C) + AB (F6.C′
     + F7.C).
 A 
B 
C 
Fi
 0 
0 
0 
F0
 0 
0 
1 
F1
 0 
1 
0 
F2
 0 
1 
1 
F3
 1 
0 
0 
F4
 1 
0 
1 
F5 
 
B′C′ 
B′C 
BC 
BC′
 1 
1 
0 
F6 
A′   
F0 
F1 
F3 
F2
 1 
1 
1 
F7 
A 
F4 
F5 
F7 
F6
   Figure 4.43 
 
 
 
 
 
 
Figure 4.44 
Since this equation consists of four combinations of A and B variables in their 
complemented and uncomplemented form, a map can be prepared from the equation by 
using A and B variables as the row and column labels and the terms within the parentheses 
as cell entries. This is illustrated in Figure 4.45. Now too may noticed that the Karnaugh 

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 115
map of order three has been reduced to the order of two. Hence, the map compression is 
achieved. In this example, A and B are called map variables, and C is treated as a map-
entered variable as it is appearing in the cell entries.
 
 
B′ 
B 
 
 
A′ 
F0.C′ + F1.C 
F2.C′ + F3.C
      
A 
F4.C′ + F5.C 
F6.C′ + F7.C
Figure 4.45
The above expression may also be written as
F (A,B,C) = A′C′ (F0.B′ + F2.B) + A′C (F1.B′++ F3.B) + AC′ (F4. B′ + F6.B) + AC (F5.B′
+ F7.B).
Here A and C are the map variables and B may be used as a map-entered variable, 
if the Karnaugh map, according to this expression, is to be formed.
Also, the same equation may be expressed as
F (A,B,C) = B′C′(F0.A′ + F4.A) + B′C(F1.A′ + F5.A) + BC′(F2.A′ + F6.A) + BC(F3.A′ + 
F7.A).
Where B and C are the map variables, and A is the map-entered variable for its 
Karnaugh map.
It may be noted that the Karnaugh map for the above expression can be further 
compressed in respect of its order, if the expression is rewritten as below.
F (A,B,C) = A′(F0.B′C′ + F1.B′C + F2.BC′ + F3.BC) + A(F4. B′C′+ F5.B′C + F6.BC′ + 
F7.BC)
In this case, A is the map variable, and B and C are the map-entered variable. The 
Karnaugh map can be constructed as in Figure 4.46.
 
A′ 
A  
 
 F0.B′C′+F1.B′C + F2.BC′+ F3.BC 
 F4.B′C′+ F5.B′C + F6.BC′+ F7.BC
Figure 4.46
Thus higher order Karnaugh maps can be reduced to lower order maps using one or 
more variables within the cells. However, the degree of difﬁ culty in interpreting compressed 
maps lies in the complexities of the entered function. Alternatively, variable-entered maps 
may be derived by partitioning of the truth table. The truth table of Figure 4.43 may be 
reconstructed like Figure 4.47, where rows are paired such that they correspond to equal 
values of A and B. The two possible values of the C variable appear within each pair and the 
last column of the truth table consists of single variable functions corresponding to C. Since 
within each of the partitions A and B possess the same value, the partitioned truth table 
can now be used to form the variable-entered map. This means that for each combination 
of A and B variables, the cell entries become the function of the C variable.
We have so far discussed the map entries as single-variable functions. The map 
entries functions may be generalized as Fi.V′ + Fj.V where Fi and Fj are the functions F0,
F1, ..., F7. Now, with the assumption of completely speciﬁ ed Boolean function and truth table, 

116
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
A 
B 
C 
Fi 
Fi 
Fi 
Fj 
Fi.V′ + Fj.V Map entry 
 
0 
0 
0 
F0 
 F0.C′+F1.C 
0 
0 
0 + 0 = 0 
0 
 
0 
0 
1 
F1 
 
0 
1 
0 + V = V 
V 
 
0 
1 
0 
F2 
 F2.C′+ F3.C 
1 
0 
V′ + 0 = V′ 
V′
 
0 
1 
1 
F3 
 
1 
1 
V′ + V = 1 
1 
 
1 
0 
0 
F4 
 F4.C′+ F5.C
   Figure 4.48
 
1 
0 
1 
F5
 
1 
1 
0 
F6 
 F6.C′+ F7.C
 
1 
1 
1 
F7
Figure 4.47
i.e., there are no don’t-care condition, it may be noted that values of Fi and Fj are restricted 
to only 0s and 1s. The table in Figure 4.48 illustrates the four possible value assignments 
to Fi and Fj and corresponding map entries in respect to V, where V is generalized as a 
map-entered variable. In addition to these, the don’t-care conditions are to be considered 
as map entries wherever necessary.
A 
B 
C 
F
0 
0 
0 
1
0 
0 
1 
1
0 
1 
0 
1
0 
1 
1 
0
1 
0 
0 
0
1 
0 
1 
1 
 
 B′ 
B
1 
1 
0 
0 
A′ 
1 
C′
1 
1 
1 
0 
A 
C 
0
   Figure 4.49  
 
 
 
 
Figure 4.50 
Now let us consider a practical example of a Boolean function according to the truth 
table of Figure 4.49. The Boolean expression of the function is
 
 
F (A,B,C) = A′B′C′ + A′B′C + A′BC′ + AB′C.
The expression may be modiﬁ ed as 
 
 
F (A,B,C) = A′B′ (C′ + C) + A′BC′ + AB′C
   
 
     = A′B′(1) + A′B(C′) + AB′(C).

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 117
The expressions within the parentheses correspond to the single variable map entries. 
With C as the map-entered variable, the Karnaugh map is constructed as in Figure 4.50.
Another example may be cited here for the Boolean expression as below. 
 
 
F (X,Y,A,B,C) = XA′B′C′ + A′B′C + A′BC + YABC′ + ABC 
In this expression, variables X and Y appear infrequently and may be considered as 
map-entered variables. The Karnaugh map is constructed as in Figure 4.51.
 
 
B′C′ 
B′C 
BC 
BC′
 
 
 
 
 
 
 
A′ 
X 
1 
1 
0 
 
 
 
 
 
 
A 
0 
0 
1 
Y 
Figure 4.51
4.10.2  Formation of Minimal Sums and Products with Map-entered Variables
Just like normal Karnaugh maps, minimal sum terms or product terms can be obtained 
from variable-entered Karnaugh maps by grouping and subgrouping of cells. However, while 
obtaining a minimal sum, it is necessary to form groups involving the map-entered variable 
in addition to 1s. Similarly, the map-entered variables are to be considered for formation of 
group in addition to 0s, while obtaining minimal products. We know from the Boolean algebra 
that V + V′ = 1, where V is the generalized notation of a map-entered variable. Therefore 
a 1 in a cell can be grouped with V as well as V′. This may be clariﬁ ed by considering the 
Karnaugh map of Figure 4.47. The 1 at cell A′B′ may be represented as C + C′ (here the 
map-entered variable is C). The map can be reconstructed as in Figure 4.52(a). Now the 
1 can be grouped with C as well as C′, if they are placed at adjacent cells. This has been 
demonstrated in Figure 4.52(b). The minimal terms are obtained as B′C (where two Cs are 
grouped) and A′C′ (for the group of two Cs).
 
 
B′ 
B 
 
B′ 
B 
 
 
A′ 
 C + C′ 
C′ 
A′ 
C + C′ 
C′
 
A 
C 
0 
A 
C 
0 
Figure 4.52(a) 
Figure 4.52(b)
 
 
B′ 
B 
 
 
A′ 
1 
C′
 
 
 
 
 
 A 
C 
C .  C′
 
Figure 4.52(c)

118
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
Therefore, the ﬁ nal minimal sum of the products expression is
 
 
F (A,B,C) = B′C + A′C′.
 
The same technique may be applied to derive the minimal product of the sums 
expression, where groups or subgroups are formed with 0s as from Boolean algebra V.V′=0.
This has been shown in Figure 4.52(c). Therefore, the product of the sums expression of 
function is 
 
 
F′ (A,B,C) = (B + C′). (A + C).
This may be summarized to a two-step procedure for obtaining minimal sums for 
completely speciﬁ ed Boolean functions from a variable-entered map as stated below.
 
1. Consider each map entry having literal V and V′. Form the groups with the maximum 
number of elements involving the literal V using cells containing 1s as don’t-care cells 
and V′ as 0-cells. Next form the groups involving the literal V′ using cells containing 
1s as don’t-care cells and the cells containing literal V as 0-cells.
 
2. After formation of groups involving V and V′, form the groups of cells containing 1s but not 
completely covered in step 1. One approach for doing this is to let all the cells containing 
the literals V and V′ become 0 and all 1s that were completely covered at step 1 become 
don’t-care cells. Another way for the not completely covered 1-cells is to use V-cells and 
V′-cells from step 1 that ensures that all the 1-cells are completely covered.
Example 4.25. Let us consider the Boolean function that has the Karnaugh map as 
per ﬁ gure 4.53(a).
 
 
B′C′ 
B′C 
BC 
BC′ 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
D 
1 
1 
0 
A′ 
D 
1 
1 
0  
 
 
 
 
 
 
 
 
 
 
A 
0 
D′ 
1 
0 
 A 
0 
D’ 
1 
0 
 
 
         Figure 4.53(a) 
 
 
     Figure 4.53(b)
 
 
B′C′ 
B′C 
BC 
BC′ 
 
B′C′ 
B′C 
BC 
BC′
 
 
 
 
 
 
   
 
 
 
 
 
A′ 
D 
1 
1 
0 
A′ 
D 
1 
1 
0 
 
 
 
 
 
 
    
 
 
 
 
 
A 
0 
D′ 
1 
0 
A 
0 
D′ 
1 
0
Figure 4.53(c)  
 
 
 
  Figure 4.53(d)
At the ﬁ rst step, the cell with D is grouped with adjacent 1 as in Figure 4.53(b). For this 
the minimal term is obtained as A′B′D. Next D′ is grouped with adjacent 1s as a quad, which 
is demonstrated in Figure 4.53(c). The minimal term is obtained as CD′. Now, note that the 
1-cell at A′B′C is grouped with D as well as D′. Therefore, it can be stated that this 1-cell is 
completely covered. But 1s at A′BC and ABC are considered in the grouping of D′ only, so these 
1-cells are not completely covered and they are grouped again separately as shown in Figure 
4.53(d). The minimal term obtained is BC. So, considering all the minimal terms obtained, the 
ﬁ nal expression is derived as 

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 119
 
 
 
F(A,B,C,D) = A′B′D + CD′ + BC.
In the above example, the minimal terms are determined in three steps. This is done for 
illustration purposes and in practice minimal terms may be determined in a single-step only.
Example 4.26. Find the sum of the product expression for the Boolean function whose 
variable-entered Karnaugh map is shown in Figure 4.54(a).
 
 
B′C′ 
B′C 
BC 
BC′ 
 
B′C′ 
B′C 
BC 
BC′
 
 
 
 
 
   
 
 
 
 
 
A′ 
D′ 
D′ 
D′ 
D′ 
A′ 
D′ 
D′ 
D′ 
D′
 
 
 
 
 
    
 
 
 
 
A 
D′ 
1 
D 
D′ 
A 
D′ 
1 
D 
D′
Figure 4.54(a)  
 
 
 
   Figure 4.54(b)
Solution. The required sum of the product expression is 
 
 
 
F (A,B,C,D) = A′D′ + C′D′ + B′D′ + ACD.
The 1-cell has been grouped with D as well as D′ to make it completely covered.
4.10.3  Variable-entered MAPS with Don’t-care Conditions
So far variable-entered mapping has been discussed for the Boolean functions that are 
completely speciﬁ ed. However, incompletely speciﬁ ed Boolean functions i.e., those having 
don’t-care conditions, commonly occur in logic design process. It is possible to generalize 
the construction and reading of variable-entered maps with don’t-care conditions.
Let us assume again that map entries in a variable-entered map correspond to single-
variable functions. Previously it was shown that the map entries functions may be generalized 
as Fi.V′ + Fj.V where Fi and Fj are the functions F0, F1,….etc. Fi and Fj may have the values 
of 0, 1, or don’t-care. A table in Figure 4.55 lists the nine possible assignments to Fi and Fj,
the evaluation of Fi .V′ + Fj.V for each case, and the corresponding entries for a variable-
entered map. The don’t-cares are denoted by X in the expressions.
Fi 
Fj 
Fi .V′ + Fj.V 
Map entry
 
0 
0 
0.V′+0.V = 0+0 = 0 
0 
 
0 
1 
0.V′+1.V = 0+1 = 1 
1 
 
0 
X 
0.V′+X.V = 0+X.V = X.V 
V, 0 
 
1 
0 
1.V′+0.V = V′+0 = V′ 
V′
 
1 
1 
1.V′+1.V = V′+V = 1 
1 
 
1 
X 
1.V′+X.V = V′+X.V  
V′, 1 
 
X 
0 
X.V′+0.V = X.V′+0 = X.V′ 
V′, 0 
 
X 
1 
X.V′+1.V = X.V′+V  
V, 1 
 
 X 
X 
X.V′+X.V  
X 
Figure 4.55

120
DIGITAL PRINCIPLES AND LOGIC DESIGN
It may be noted from the table in Figure 4.55 that there are some double entries in 
the map, which signiﬁ es that these cells can have both values. The ﬁ rst part of the double 
entry is referred to as the literal part and the second part is the constant part. The process 
of reading a variable-entered map with don’t-care conditions is more complex, since the 
double entry cells in the map provide ﬂ exibility. Again, two-step process may be adopted 
for the formation of groups and subgroups to obtain the minimal terms.
 
1. Form an optimal collection or group for all entries that consist of only a single literal, 
i.e., V or V′, using 1s, Xs and double entries having a 1 constant part as don’t-cares. 
In addition, double entries having a 0 constant part can be used as don’t-cares for the 
formation of groups that agree with the literal part of that double entry.
 
2. Form a step 2 as follows,
 
(a) Replace the single literal entries, i.e., V and V′ by 0.
 
(b) Retain the single 0 and X entries.
 
(c) Replace each single 1 entry with an X, if it was completely covered in step 1, 
otherwise retain a single 1 entry.
 
(d) Replace the double entries having a 0 as a constant part, i.e., V,0 and V′,0 as 0.
 
(e) Replace each double entry having a 1 as a constant part by X, if the cell was 
used in step 1 to form at least one group agreeing with the literal part, otherwise 
replace the double entry having a 1 constant part by a 1. (It should be noted 
that the second case corresponds to the cell not being covered at all or only used 
in association with the complement of the literal part of a double entry).
The resulting step 2 map only has 0, 1, and X entries. Minimal terms are to be 
obtained considering the X-cells, also. This may be illustrated by considering the practical 
example that follows.
Example 4.27. Consider the Boolean function
F (A,B,C,D) = Σ (3, 5, 6, 7, 8, 9, 10) + Φ (4, 11, 12, 14, 15).
The corresponding truth table is presented in Figure 4.56. Variables A, B, and C 
are considered as map variables, and D is considered as a map-entered variable. In the 
truth table, columns are provided for the function Fi .V′ + Fj.V and map-entry values. The 
variable-entered Karnaugh map is shown in Figure 4.57(a). Figure 4.57(b) demonstrates 
how map entries are grouped at step 1. Here, one D entry is grouped with 1, X, and (D′,1),
as (D′,1) may be interpreted as don’t-care while grouping with D. Thus the minimal term 
is formed as CD.
At the next step, replace (D′,1) at the cell position AB′C with 1 as this was once grouped 
with D. Replace (D,1) of cell position A′BC′ with 1 and (D′,0) of cell position ABC′ with 
0. The Karnaugh map is reconstructed with changes as shown in Figure 4.57(c). Minimal 
terms are obtained from this map as AB′ and A′B.
So the ﬁ nal expression for the given Boolean function can be written as
 
 
 
F (A,B,C,D) = CD + AB′ + A′B.

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 121
 
A 
B 
C 
D 
F 
Fi .V′ + Fj.V 
Map entry 
 
0 
0 
0 
0 
0 
0+0 
0 
 
0 
0 
0 
1 
0 
 
 
 
0 
0 
1 
0 
0 
0+D 
D 
 
0 
0 
1 
1 
1 
 
 
 
0 
1 
0 
0 
X 
X.D′+D 
D,1 
 
0 
1 
0 
1 
1 
 
 
 
0 
1 
1 
0 
1 
D′+D 
1 
 
0 
1 
1 
1 
1 
 
 
 
1 
0 
0 
0 
1 
D′+D 
1 
 
1 
0 
0 
1 
1 
 
 
 
1 
0 
1 
0 
1 
D′+X.D 
D′,1
 
1 
0 
1 
1 
X 
 
 
 
1 
1 
0 
0 
X 
X.D′+0 
D′,0
 
1 
1 
0 
1 
0 
 
 
 
1 
1 
1 
0 
X 
X.D′+X.D 
X 
 
1 
1 
1 
1 
X 
 
Figure 4.56
 
 
B′C′ 
B′C 
BC 
BC′ 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
0 
D 
1 
D,1 
  A′ 
0 
D 
1 
D,1 
 
 
 
 
 
 
 
 
 
 
 
 
A 
1 
D′,1 
X 
D′,0 
   A 
1 
D′,1 
X 
D′,0
Figure 4.57(a)  
 
 
 
 
Figure 4.57(b)
 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
0 
0 
1 
1 
 
 
 
 
 
 
 
 
A 
1 
1 
X 
0 
 
 
 
 
 
Figure 4.57(c) 

122
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 4.28. Find the Boolean expression for the following function using variable-
entered map technique. 
 
 
 
F (A,B,C,D) = Σ (0, 4, 5, 6, 13, 14, 15) + Φ (2, 7, 8, 9)
Solution. Let A, B, and C be map variables and D be a map-entered variable. The 
truth table with map entry is prepared as in Figure 4.58(a). The Karnaugh map according 
to the truth table is formed in Figure 4.58(b). At ﬁ rst step, group formation consisting of 
single literal is done. The minimal terms thus obtained are A′D′ and BD. (D′, 1 may be 
considered as don’t-care while grouped with D, as once it has been considered as D′.)
At the next step, the Karnaugh map is reconstructed in Figure 4.58(c). Here the single 
literal entries D and D′ are replaced by 0s as they are already used. (D′,0) at cell position 
A′B′C is replaced by 0. (D′,1) at cell position A′BC is replaced by X as this has been grouped 
with both D as well as D′ and similarly 1 at cell position A′BC replaced by X as this also 
has been grouped with D as well as D′. The minimal term obtained from this map is BC.
Therefore, the ﬁ nal expression of the given Boolean function may be derived as 
 
 
 
F (A,B,C,D) = A′D′ + BD + BC.
A 
B 
C 
D 
F 
Fi .V′ + Fj.V 
Map entry
 
0 
0 
0 
0 
1 
D′+0 
D′
 
0 
0 
0 
1 
0 
 
 
 
0 
0 
1 
0 
  X 
X.D′+0 
D′,0
 
0 
0 
1 
1 
0 
 
 
 
0 
1 
0 
0 
1 
D′+D 
1 
 
0 
1 
0 
1 
1 
 
 
 
0 
1 
1 
0 
1 
D′+X.D 
D′,1
 
0 
1 
1 
1 
X 
 
 
 
1 
0 
0 
0 
X 
X.D′+X.D 
X 
 
1 
0 
0 
1 
X 
 
 
 
1 
0 
1 
0 
0 
0+0 
0 
 
1 
0 
1 
1 
0 
 
 
 
1 
1 
0 
0 
0 
0+D 
D 
 
1 
1 
0 
1 
1 
 
 
 
1 
1 
1 
0 
1 
D′+D 
1 
 
1 
1 
1 
1 
1 
 
 
Figure 4.58(a)

SIMPLIFICATION AND MINIMIZATION OF BOOLEAN FUNCTIONS 123
 
 
B′C′ 
B′C 
BC 
BC′ 
 
B′C′ 
B′C 
BC 
BC′
 
A′ 
D′ 
D′,0 
D′,1 
1 
A′ 
0 
0 
X 
X 
 
 
 
 
 
 
   
 
 
 
 
 
A 
X 
0 
1 
D 
A 
X 
0 
1 
0 
Figure 4.58(b) 
Figure 4.58(c)
The above examples demonstrate how a single variable is used as a map-entered 
variable. However, more than one variable may used as map-entered variables. But these 
increase the complexities and difﬁ culties in the simpliﬁ cation process.
4.11  CONCLUDING REMARKS
Two methods of Boolean function simpliﬁ cation are shown in this chapter. The criterion for 
simpliﬁ cation is to minimize the number of literals in the sum of products or product of 
sums forms. Both the map and the tabulation methods are restricted in their capabilities 
as they are useful for simplifying the Boolean functions expressed in the standard forms. 
Although this is a disadvantage, it is not very critical, as most of the applications prefer 
the standard forms over any other form. The gate implementation of standard expressions 
requires no more than two levels of gates. Expressions not in the standard forms are 
implemented with more than two levels.
It should be observed that the reﬂ ected code sequence chosen for the maps is not unique. 
It is possible to draw the maps assigning different code sequences to rows and columns 
keeping reﬂ ected code sequence in mind. This is already shown in this chapter. Also, the 
simpliﬁ ed expression for a function may not be unique, if pairs, quads, etc., are considered 
differently. The map method is preferable because of its simplicity when the number of 
variables is restricted to four, at the most ﬁ ve. For more than ﬁ ve variables, grouping of 
binary sequences leads to confusion and error.
The tabulation method has the distinct advantage at this point, as a step-by-step 
procedure is followed to minimize the literals. Moreover, this formal procedure is suitable 
for computer mechanization. But the tabulation process always starts with the minterm 
list of the function. If the function is not in this form, it is to be converted and the list of 
minterms is to be prepared.
In this chapter, we have considered the simpliﬁ cations of functions with many input 
variables and a single output. However, some digital circuits have more than one output. 
Such circuits with multiple outputs may sometimes have common terms among the various 
functions which can be utilized to form common gates during the implementation. This results 
in further simpliﬁ cation which is not found in the simpliﬁ cation process if done separately. 
There exists an extension of the tabulation process for multiple-output functions. However, 
the method is too specialized and very tedious for human manipulation.
REVIEW QUESTIONS
 4.1 What are the don’t-care conditions?
 4.2 Explain the terms (a) prime implicant, and (b) essential prime implicant.
 4.3 What are the advantages of the tabulation method?

124
DIGITAL PRINCIPLES AND LOGIC DESIGN
4.4 Draw a Karnaugh map for a four-variable Ex-OR function and derive its expression.
 4.5 How does a Karnaugh map differ from a truth table?
 4.6 What kind of network is developed by sum of the products?
4.7 Using a Karnaugh map, simplify the following functions and implement them with basic gates.
 
 (a) F (A, B, C, D) = Σ (0, 2, 3, 6, 7, 8, 10, 11, 12, 15)
 
 (b) F (A, B, C, D) = Σ (0, 2, 3, 5, 7, 8, 13) + d (1, 6, 12)
 
 (c) 
F (A, B, C, D) = Σ (1, 7, 9, 10, 12, 13, 14, 15) + d (4, 5, 8) 
 
 (d) F (A, B, C, D) = π (0, 8, 10, 11, 14) + d (6)
 
 (e) 
F (A, B, C, D) = π (2, 8, 11, 15) + d (3, 12, 14)
 
 (f) 
F (W, X, Y, Z) = π (0, 2, 6, 11, 13, 15) + d (1, 9, 10, 14)
4.8 Prepare a Karnaugh map for the following functions.
 
 (a) F = ABC + A'BC + B'C' 
 
 (b) F = A + B + C'
 
 (c) 
Y = AB + B'CD
 4.9 Using the Karnaugh map method, simplify the following functions, obtain their sum of the 
products form, and product of the sums form. Realize them with basic gates. 
 
 (a) F (W, X, Y, Z) = Σ (1, 3, 4, 5, 6, 7, 9, 12, 13)
 
 (b) F (W, X, Y, Z) = Σ (1, 5, 6, 7, 11, 12, 13, 15)
 4.10 Determine the don’t-care conditions for the Boolean expression BE + B'DE', which is the simpliﬁ ed 
version of the expression A'BE + BCDE + BC'D'E + A'B'DE' + B'C'DE'.
 4.11 Obtain the sum of the products expressions for the following functions and implement them 
with NAND gates as well as NOR gates.
 
 (a) F = Σ (1, 4, 7, 8, 9, 11) + d (0, 3, 5)
 
 (b) F = Σ (0, 2, 3, 5, 6, 7, 8, 9) + φ(10, 11, 12, 13, 14, 15)
 4.12  A combinational switching network has four inputs A, B, C, and D, and one output Z. The 
output is to be 0, if the input combination is a valid Excess-3 coded decimal digit. If any 
other combinations of inputs appear, the output is to be 1. Implement the network using basic 
gates.
 4.13 Design a circuit similar to problem 4.7 for BCD digits.
4.14 Using the Quine-McCluskey method obtain all the prime implicants, essential prime implicants, 
and minimized Boolean expression for the following functions.
 
 (a) F (A, B, C, D, E) = Σ (4, 5, 6, 7, 9, 10, 14, 19, 26, 30, 31)
 
 (b) F (A, B, C, D) = Σ (7, 9, 12, 13, 14, 15) + d (4, 11)
 
 (c) 
F (A, B, C, D, E) = Σ (1, 3, 6, 10, 11, 12, 14, 15, 17, 19, 20, 22, 24, 29, 30)
 
 (d) F (A, B, C, D) = Σ (4, 5, 8, 9, 12, 13) + d (0, 3, 7, 10, 11)
 4.15 Determine the simpliﬁ ed expression for each of following functions using variable-entered maps 
where A, B, and C are map variables.
 
 (a) F (A, B, C, D) = Σ (2, 3, 5, 12, 14) + d (0, 4, 8, 10, 11)
 
 (b) F (A, B, C, D) = Σ (1, 5, 6, 7, 9, 11, 12, 13) + d (0, 3, 4)
 
 (c) 
F (A, B, C, D) = Σ (1, 5, 7, 10, 11) + d (2, 3, 6, 13)
 
 (d) F (A, B, C, D) = Σ (5, 6, 7, 12, 13, 14) + d (3, 8, 9)

125
5.1  INTRODUCTION
The digital system consists of two types of circuits, namely
 
  (i) Combinational circuits and 
 
  (ii) Sequential circuits
A combinational circuit consists of logic gates, where outputs are at any instant and are 
determined only by the present combination of inputs without regard to previous inputs or 
previous state of outputs. A combinational circuit performs a speciﬁ c information-processing 
operation assigned logically by a set of Boolean functions. Sequential circuits contain logic gates 
as well as memory cells. Their outputs depend on the present inputs and also on the states 
of memory elements. Since the outputs of sequential circuits depend not only on the present 
inputs but also on past inputs, the circuit behavior must be speciﬁ ed by a time sequence of 
inputs and memory states. The sequential circuits will be discussed later in the chapter.
In the previous chapters we have discussed binary numbers, codes, Boolean algebra and 
simpliﬁ cation of Boolean function, logic gates, and economical gate implementation. Binary 
numbers and codes bear discrete quantities of information and the binary variables are the 
representation of electric voltages or some other signals. In this chapter, formulation and 
analysis of various systematic design of combinational circuits and application of information- 
processing hardware will be discussed.
Figure 5.1
A combinational circuit consists of input variables, logic gates, and output variables. The 
logic gates accept signals from inputs and output signals are generated according to the logic 
    
Combinational
Logic
Circuit
..
.
.
..
.
.
m  output
variables
n input
variables
COMBINATIONAL
LOGIC CIRCUITS
5
C h a p t e r

126
DIGITAL PRINCIPLES AND LOGIC DESIGN
circuits employed in it. Binary information from the given data transforms to desired output 
data in this process. Both input and output are obviously the binary signals, i.e., both the input 
and output signals are of two possible states, logic 1 and logic 0. Figure 5.1 shows a block 
diagram of a combinational logic circuit. There are n number of input variables coming from 
an electric source and m number of output signals go to an external destination. The source 
and/or destination may consist of memory elements or sequential logic circuit or shift registers, 
located either in the vicinity of the combinational logic circuit or in a remote external location. 
But the external circuit does not interfere in the behavior of the combinational circuit.
For n number of input variables to a combinational circuit, 2n possible combinations of 
binary input states are possible. For each possible combination, there is one and only one 
possible output combination. A combinational logic circuit can be described by m Boolean 
functions and each output can be expressed in terms of n input variables.
5.2  DESIGN PROCEDURE
Any combinational circuit can be designed by the following steps of design procedure.
 
1. The problem is stated.
 
2. Identify the input variables and output functions.
 
3. The input and output variables are assigned letter symbols.
 
4. The truth table is prepared that completely deﬁ nes the relationship between the input 
variables and output functions.
 
5. The simpliﬁ ed Boolean expression is obtained by any method of minimization—algebraic 
method, Karnaugh map method, or tabulation method.
 
6. A logic diagram is realized from the simpliﬁ ed expression using logic gates.
It is very important that the design problem or the verbal speciﬁ cations be interpreted 
correctly to prepare the truth table. Sometimes the designer must use his intuition and 
experience to arrive at the correct interpretation. Word speciﬁ cation are very seldom exact 
and complete. Any wrong interpretation results in incorrect truth table and combinational 
circuit.
Varieties of simpliﬁ cation methods are available to derive the output Boolean functions 
from the truth table, such as the algebraic method, the Karnaugh map, and the tabulation 
method. However, one must consider different aspects, limitations, restrictions, and criteria 
for a particular design application to arrive at suitable algebraic expression. A practical 
design approach should consider constraints like—(1) minimum number of gates, (2) minimum 
number of outputs, (3) minimum propagation time of the signal through a circuit, (4) 
minimum number of interconnections, and (5) limitations of the driving capabilities of each 
logic gate. Since the importance of each constraint is dictated by the particular application, 
it is difﬁ cult to make all these criteria satisﬁ ed simultaneously, and also difﬁ cult to make 
a general statement on the process of achieving an acceptable simpliﬁ cation. However, in 
most cases, ﬁ rst the simpliﬁ ed Boolean expression at standard form is derived and then 
other constraints are taken care of as far as possible for a particular application.
5.3  ADDERS
Various information-processing jobs are carried out by digital computers. Arithmetic operations 
are among the basic functions of a digital computer. Addition of two binary digits is the 

COMBINATIONAL LOGIC CIRCUITS 127
most basic arithmetic operation. The simple addition consists of four possible elementary 
operations, which are 0+0 = 0, 0+1 = 1, 1+0 = 1, and 1+1 = 10. The ﬁ rst three operations 
produce a sum of one digit, but the fourth operation produces a sum consisting of two 
digits. The higher signiﬁ cant bit of this result is called the carry. A combinational circuit 
that performs the addition of two bits as described above is called a half-adder. When the 
augend and addend numbers contain more signiﬁ cant digits, the carry obtained from the 
addition of two bits is added to the next higher-order pair of signiﬁ cant bits. Here the 
addition operation involves three bits—the augend bit, addend bit, and the carry bit and 
produces a sum result as well as carry. The combinational circuit performing this type of 
addition operation is called a full-adder. In circuit development two half-adders can be 
employed to form a full-adder.
5.3.1  Design of Half-adders
As described above, a half-adder has two inputs and two outputs. Let the input variables 
augend and addend be designated as A and B, and output functions be designated as S for 
sum and C for carry. The truth table for the functions is below.
Input variables 
Output variables
 
A 
B 
S 
C 
 
0 
0 
0 
0 
 
0 
1 
1 
0 
 
1 
0 
1 
0 
 
1 
1 
0 
1
Figure 5.2
From the truth table in Figure 5.2, it can be seen that the outputs S and C functions 
are similar to Exclusive-OR and AND functions respectively, as shown in Figure 3.5 in 
Chapter 3. The Boolean expressions are
 
 
 
 
S = A′B+AB′   and
 
 
 
 
C = AB.
Figure 5.3 shows the logic diagram to implement the half-adder circuit. 
Figure 5.3
5.3.2  Design of Full-adders
A combinational circuit of full-adder performs the operation of addition of three bits—the 
augend, addend, and previous carry, and produces the outputs sum and carry. Let us designate 
A
B
S
C

128
DIGITAL PRINCIPLES AND LOGIC DESIGN
the input variables augend as A, addend as B, and previous carry as X, and outputs sum 
as S and carry as C. As there are three input variables, eight different input combinations 
are possible. The truth table is shown in Figure 5.4 according to its functions.
Input variables 
 
Outputs 
 
X 
A 
B 
S 
C 
 
0 
0 
0 
0 
0 
 
0 
0 
1 
1 
0 
 
0 
1 
0 
1 
0 
 
0 
1 
1 
0 
1 
 
1 
0 
0 
1 
0 
 
1 
0 
1 
0 
1 
 
1 
1 
0 
0 
1 
 
1 
1 
1 
1 
1 
Figure 5.4
To derive the simpliﬁ ed Boolean expression from the truth table, the Karnaugh map 
method is adopted as in Figures 5.5(a)-(b).
 
 
A′B′ 
A′B 
AB 
AB′ 
 
A′B′ 
A′B 
AB 
AB′
 
X′ 
 
1 
 
1 
X′ 
 
 
1 
 
 
 
 
X 
1 
 
   1 
 
X 
 
1 
1 
1 
 
Figure 5.5(a) Map for function S. 
Figure 5.5(b) Map for function C.
The simpliﬁ ed Boolean expressions of the outputs are
 
 
S = X′A′B + X′AB′ + XA′B′ + XAB  
 
 
and
 
 
C = AB + BX + AX.
The logic diagram for the above functions is shown in Figure 5.6. It is assumed 
complements of X, A, and B are available at the input source.
Note that one type of conﬁ guration of the combinational circuit diagram for full-adder 
is realized in Figure 5.6, with two-input and three-input AND gates, and three input and 
four-input OR gates. Other conﬁ gurations can also be developed where number and type of 
gates are reduced. For this, the Boolean expressions of S and C are modiﬁ ed as followo.

COMBINATIONAL LOGIC CIRCUITS 129
Figure 5.6
 
 
S = X′A′B + X′AB′ + XA′B′ + XAB
 
   
  = X′ (A′B + AB′) + X (A′B′ + AB)
 
         = X′ (A ⊕ B) + X (A ⊕ B)′
 
 
   = X ⊕ A ⊕ B
    
C = AB + BX + AX  = AB + X (A + B)
 
         = AB + X (AB + AB′ + AB + A′B)
 
         = AB + X (AB + AB′ + A’B)
 
         = AB + XAB + X (AB′ + A’B)
 
         = AB + X (A ⊕ B)
Logic diagram according to the modiﬁ ed expression is shown Figure 5.7.
Figure 5.7
You may notice that the full-adder developed in Figure 5.7 consists of two 2-input AND gates, 
two 2-input XOR (Exclusive-OR) gates and one 2-input OR gate. This contains a reduced number 
of gates as well as type of gates as compared to Figure 5.6. Also, if compared with a half-adder 
circuit, the full-adder circuit can be formed with two half-adders and one OR gate.
5.4  SUBTRACTORS
Subtraction is the other basic function of arithmetic operations of information-processing 
tasks of digital computers. Similar to the addition function, subtraction of two binary digits 
consists of four possible elementary operations, which are 0–0 = 0, 0–1 = 1 with borrow of 
X
A
B
X′
A′
B′
C
S
X
A
B
B
A
S
X
C

130
DIGITAL PRINCIPLES AND LOGIC DESIGN
1, 1–0 = 1, and 1–1 = 0. The ﬁ rst, third, and fourth operations produce a subtraction of one 
digit, but the second operation produces a difference bit as well as a borrow bit. The borrow 
bit is used for subtraction of the next higher signiﬁ cant bit. A combinational circuit that 
performs the subtraction of two bits as described above is called a half-subtractor. The digit 
from which another digit is subtracted is called the minuend and the digit which is to be 
subtracted is called the subtrahend. When the minuend and subtrahend numbers contain 
more signiﬁ cant digits, the borrow obtained from the subtraction of two bits is subtracted 
from the next higher-order pair of signiﬁ cant bits. Here the subtraction operation involves 
three bits—the minuend bit, subtrahend bit, and the borrow bit, and produces a different 
result as well as a borrow. The combinational circuit that performs this type of addition 
operation is called a full-subtractor. Similar to an adder circuit, a full-subtractor combinational 
circuit can be developed by using two half-subtractors.
5.4.1  Design of Half-subtractors
A half-subtractor has two inputs and two outputs. Let the input variables minuend 
and subtrahend be designated as X and Y respectively, and output functions be designated 
as D for difference and B for borrow. The truth table of the functions is as follows.
 
          
Input variables 
              Output variables 
 
X 
Y 
D 
B 
 
0 
0 
0 
0 
 
0 
1 
1 
1 
 
1 
0 
1 
0 
 
1 
1 
0 
0 
 
 
 
 
 
Figure 5.8
By considering the minterms of the truth table in Figure 5.8, the Boolean expressions 
of the outputs D and B functions can be written as 
 
 
 
D = X′Y + XY′    
and
 
 
 
B = X′Y.
Figure 5.9 shows the logic diagram to realize the half-subtractor circuit.
Figure 5.9
X
Y
D
B

COMBINATIONAL LOGIC CIRCUITS 131
5.4.2  Design of Full-subtractors
A combinational circuit of full-subtractor performs the operation of subtraction of three 
bits—the minuend, subtrahend, and borrow generated from the subtraction operation of 
previous signiﬁ cant digits and produces the outputs difference and borrow. Let us designate 
the input variables minuend as X, subtrahend as Y, and previous borrow as Z, and outputs 
difference as D and borrow as B. Eight different input combinations are possible for three 
input variables. The truth table is shown in Figure 5.10(a) according to its functions.
 Input variables 
 
 
         Outputs 
 
X 
Y 
Z 
D 
B 
 
0 
0 
0 
0 
0 
 
0 
0 
1 
1 
1 
 
0 
1 
0 
1 
1 
 
0 
1 
1 
0 
1 
 
1 
0 
0 
1 
0 
 
1 
0 
1 
0 
0 
 
1 
1 
0 
0 
0 
 
1 
1 
1 
1 
1 
Figure 5.10(a)
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
 
1 
 
1 
X′ 
 
1 
1 
1 
 
 
X 
1 
 
   1 
 
X 
 
 
1
Figure 5.10(b) Map for function D. 
Figure 5.10(c) Map for function B.
Karnaugh maps are prepared to derive simpliﬁ ed Boolean expressions of D and B as 
in Figures 5.10(b) and 5.10(c), respectively.
The simpliﬁ ed Boolean expressions of the outputs are
 
 
S = X′Y′Z + X′YZ′ + XY′Z′ + XYZ  
 
 
and
 
 
C = X′Z + X′Y + YZ.
The logic diagram for the above functions is shown in Figure 5.11.
Similar to a full-adder circuit, it should be noticed that the conﬁ guration of the 
combinational circuit diagram for full-subtractor as shown in Figure 5.11 contains two-input 
and three-input AND gates, and three-input and four-input OR gates. Other conﬁ gurations 
can also be developed where number and type of gates are reduced. For this, the Boolean 
expressions of D and B are modiﬁ ed as follows.

132
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.11
 
 
D = X′Y′Z + X′YZ′ + XY′Z′ + XYZ
 
   
  = X′ (Y′Z + YZ′) + X (Y′Z′ + YZ)
 
         = X′ (Y⊕Z) + X (Y⊕Z)′
 
         = X⊕Y⊕Z
    
B = X′Z + X′Y +YZ  = X′Y + Z (X′ + Y)
 
         = X′Y + Z(X′Y + X′Y′ + XY + X′Y)
 
         = X′Y + Z(X′Y + X′Y′ + XY)
 
         = X′Y + X′YZ + Z(X′Y′ + XY)
 
         = X′Y + Z(X⊕Y)′
Logic diagram according to the modiﬁ ed expression is shown in Figure 5.12. 
Figure 5.12
Note that the full-subtractor developed in Figure 5.12 consists of two 2-input AND 
gates, two 2-input XOR (Exclusive-OR) gates, two INVERTER gates, and one 2-input OR 
gate. This contains a reduced number of gates as well as type of gates as compared to Figure 
5.12. Also, it may be observed, if compared with a half-subtractor circuit, the full-subtractor 
circuit can be developed with two half-subtractors and one OR gate.
5.5  CODE CONVERSION
We have seen in Chapter 2 that a large variety of codes are available for the same discrete 
elements of information, which results in the use of different codes for different digital 
X
Y
Z
X′
Y′
Z′
D
X′
B
Y
Z
X
Z
Y
D
B

COMBINATIONAL LOGIC CIRCUITS 133
systems. It is sometimes necessary to interface two digital blocks of different coding systems. 
A conversion circuit must be inserted between two such digital systems to use information of 
one digital system to other. Therefore, a code converter circuit makes two systems compatible 
when two systems use different binary codes.
To convert from one binary code A to binary code B, the input lines must provide 
the bit combination of elements as speciﬁ ed by A and the output lines must generate the 
corresponding bit combinations of code B. A combinational circuit consisting of logic gates 
performs this transformation operation. Some speciﬁ c examples of code conversion techniques 
are illustrated in this chapter.
5.5.1  Binary-to-gray Converter
The bit combinations 4-bit binary code and its equivalent bit combinations of gray code 
are listed in the table in Figure 5.13. The four bits of binary numbers are designated as 
A, B, C, and D, and gray code bits are designated as W, X, Y, and Z. For transformation 
of binary numbers to gray, A, B, C, and D are considered as inputs and W, X, Y, and Z are 
considered as outputs. The Karnaugh maps are shown in Figures 5.14(a)-(d).
Binary 
Gray 
 
A 
B 
C 
D 
W 
X 
Y 
Z 
 
0 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
0 
1 
0 
0 
0 
1 
 
0 
0 
1 
0 
0 
0 
1 
1 
 
0 
0 
1 
1 
0 
0 
1 
0 
 
0 
1 
0 
0 
0 
1 
1 
0 
 
0 
1 
0 
1 
0 
1 
1 
1 
 
0 
1 
1 
0 
0 
1 
0 
1 
 
0 
1 
1 
1 
0 
1 
0 
0 
 
1 
0 
0 
0 
1 
1 
0 
0 
 
1 
0 
0 
1 
1 
1 
0 
1 
 
1 
0 
1 
0 
1 
1 
1 
1 
 
1 
0 
1 
1 
1 
1 
1 
0 
 
1 
1 
0 
0 
1 
0 
1 
0 
 
1 
1 
0 
1 
1 
0 
1 
1 
 
1 
1 
1 
0 
1 
0 
0 
1 
 
1 
1 
1 
1 
1 
0 
0 
0
Figure 5.13

134
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
CD′
  A′B′ 
 
 
 
 
A′B′ 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
A′B 
 
 
 
 
A′B 
1 
   1 
   1 
1 
  
AB 
1 
1 
 1 
1 
AB 
 
 
 
 
 
AB′ 
1 
1 
1 
1 
AB′ 
1 
1 
1 
 1 
 
  Figure 5.14(a) Karnaugh map for W. 
              Figure 5.14(b) Karnaugh map for X.
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
CD′
  A′B′ 
 
 
1 
1 
A′B′ 
 
1 
 
1
 
 A′B 
1 
1 
 
 
A′B 
 
1 
 
1
 
 AB 
1 
1 
 
 
AB 
 
1 
 
1
 
 AB′ 
 
 
1 
1 
AB′ 
 
1 
 
1 
 
 
 
 
 
 
 
   Figure 5.14(c) Karnaugh map for Y.    
  Figure 5.14(d) Karnaugh map for Z.
From the Karnaugh maps of Figure 5.14, we get
 
 
W = A,  
 
 
 
X = A′B + AB′ = A⊕B,
 
 
Y = BC′ + B′C = B⊕C,   and  
Z = C′D + CD′= C⊕D.
Figure 5.15
Figure 5.15 demonstrates the circuit diagram with logic gates.

COMBINATIONAL LOGIC CIRCUITS 135
5.5.2  Gray-to-binary Converter
Using the same conversion table as in Figure 5.13, the Karnaugh maps are formed 
in Figures 5.16(a)-(d). Here the inputs are considered as W, X, Y, and Z, whereas, outputs 
are A, B, C, and D.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
W′X′ 
 
 
 
 
 W′X′ 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
W′X 
 
 
 
  
W′X 
1 
1 
1 
1
 
 
 
 
 
 
 
 
 
 
 WX 
1 
1  
1 
1 
WX 
 
 
 
 
 
 
 
 
 
  
W′X′ 
1 
1 
 1 
1 
WX′ 
1 
1 
1 
1
 
 
 
 
 
 
 
 
 
 
 
 
  Figure 5.16(a) Karnaugh map for A.  
  Figure 5.16(b) Karnaugh map for B.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
 W′X′ 
 
 
1 
1  
W′X′ 
 
1 
 
1 
  
W′X 
1 
1 
 
 
W′X 
1 
 
1 
 
  
WX 
 
 
1 
1 
 WX 
 
1 
 
1 
 
  
WX′ 
1 
1 
 
 
 WX′ 
1 
 
1 
 
 
  Figure 5.16(c) Karnaugh map for C.  
   Figure 5.16(d) Karnaugh map for D.
The Boolean expressions from Figure 5.16 are,
 A = W
 B = W′X + WX′ = W⊕X
 C = W′X′Y + W′XY′ + WXY + WX′Y′
 
 = W′(X′Y + XY′) + W(XY + X′Y′)
 
 = W′(X⊕Y) + W(X⊕Y)′
 
 = W⊕X⊕Y 
 
 
 
 
or, 
C = B⊕Y
 D = W′X′Y′Z + W′X′YZ′ + W′XY′Z′ + W′XYZ + WXY′Z + WXYZ′ + WX′Y′Z′ + WX′YZ
 
 = W′X′(Y′Z + YZ′) + W′X(Y′Z′ + YZ) + WX(Y′Z + YZ′) + WX′(Y′Z′ + YZ)
 
 = W′X′(Y⊕Z) + W′X(Y⊕Z)′ + WX(Y⊕Z) + WX′(Y⊕Z)′
 
 = (W′X + WX′)(Y⊕Z)′ + (W′X′ + WX) (Y⊕Z)
 
 = (W⊕X) (Y⊕Z)′ + (W⊕X)′ (Y⊕Z)
   = W⊕X⊕Y⊕Z  
 
 
or, 
D = C⊕Z.

136
DIGITAL PRINCIPLES AND LOGIC DESIGN
From the Boolean expressions above, the circuit diagram of a gray-to-binary code 
converter is shown in Figure 5.17.
Figure 5.17
It may be noticed that a binary-to-gray converter and a gray-to-binary converter as 
illustrated above are four bits. However, these codes are not limited to four bits only. By 
similar process both the binary-to-gray and gray-to-binary code converter can be developed 
for a higher number of bits.
5.5.3  BCD-to-excess-3 Code Converter
The bit combinations of both the BCD (Binary Coded Decimal) and Excess-3 codes 
represent decimal digits from 0 to 9. Therefore each of the code systems contains four bits 
and so there must be four input variables and four output variables. Figure 5.18 provides the 
list of the bit combinations or truth table and equivalent decimal values. The symbols A, B, 
C, and D are designated as the bits of the BCD system, and W, X, Y, and Z are designated 
as the bits of the Excess-3 code system. It may be noted that though 16 combinations are 
possible from four bits, both code systems use only 10 combinations. The rest of the bit 
combinations never occur and are treated as don’t-care conditions.
Decimal 
BCD code 
Excess-3 code 
 
Equivalent 
A 
B 
C 
D 
W 
X 
Y 
Z
 
0 
0 
0 
0 
0 
0 
0 
1 
1 
 
1 
0 
0 
0 
1 
0 
1 
0 
0 
 
2 
0 
0 
1 
0 
0 
1 
0 
1 
 
3 
0 
0 
1 
1 
0 
1 
1 
0 
 
4 
0 
1 
0 
0 
0 
1 
1 
1 
 
5 
0 
1 
0 
1 
1 
0 
0 
0 
 
6 
0 
1 
1 
0 
1 
0 
0 
1 
 
7 
0 
1 
1 
1 
1 
0 
1 
0 
 
8 
1 
0 
0 
0 
1 
0 
1 
1 
 
9 
1 
0 
0 
1 
1 
1 
0 
0
Figure 5.18
W
Y
B
D
C
X
Z
A

COMBINATIONAL LOGIC CIRCUITS 137
For the BCD-to-Excess-3 converter, A, B, C, and D are the input variables and W, 
X, Y, and Z are the output variables. Karnaugh maps are shown in Figures 5.19(a)-(d) to 
derive each of the output variables. The simpliﬁ ed Boolean expressions of W, X, Y, and Z 
are given below.
 
 
C′D′ 
C′D 
CD 
CD’ 
 
C′D′ 
C′D 
 CD 
  CD′
 
A′B′ 
 
 
 
 
A′B′ 
 
 1 
 1   
   1   
 
A′B 
 
1 
1 
1 
A′B 
 1
  
 
 
 
 
AB 
X 
X 
X 
X 
AB 
 X  
  X 
  X 
   X 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
1 
1 
X 
X 
AB′ 
 
 1 
 X   
   X  
 
 
 
 
 
 
 
 
 
 
 
 Figure 5.19(a) Karnaugh map for W.  
  Figure 5.19(b) Karnaugh map for X.
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
   CD′
 
A′B′ 
1 
 
1 
 
A′B′ 
1 
 
 
   1 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
1 
 
1 
 
A′B 
1 
 
 
   1 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
1 
X 
X 
X 
AB 
X 
X 
  X 
  X 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
1 
 
1 
X 
AB′ 
1 
 
  X 
  X 
 
 
 
 
 
 
 
 
 
 
 
 Figure 5.19(c) Karnaugh map for Y. 
 
  Figure 5.19(d) Karnaugh map for Z.
 
W = A + BC + BD
 
X = B′C + B′D + BC′D′
 
Y = CD + C′D′
 
Z = D′
According to the Boolean expression derived above, the logic diagram of a BCD-to-
Excess-3 converter circuit is shown in Figure 5.20.
A good designer will always look forward to reduce the number and types of gates. 
It can be shown that reduction in the types and number of gates is possible to construct 
the BCD-to-Excess-3 code converter circuit if the above Boolean expressions are modiﬁ ed 
as follows.

138
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.20
Figure 5.21
 
W = A + BC + BD = A + B(C + D)
 
X = B′C + B′D + BC′D′ = B′(C + D) + BC′D′ = B′(C + D) + B(C + D)′
 
Y = CD + C′D′ = CD + (C + D)′
 
Z = D′
X
B
C
D
Y
Z
W
A

COMBINATIONAL LOGIC CIRCUITS 139
The BCD-to-Excess-3 converter circuit has been redrawn in Figure 5.21 according to 
the modiﬁ ed Boolean expressions above. Here, three-input AND gates and three-input OR 
gates are totally removed and the required number of gates has been reduced. 
5.5.4  Excess-3-to-BCD Code Converter
To construct the Excess-3-to-BCD converter circuit, a similar truth table as in Figure 
5.18 may be used. In this case, W, X, Y, and Z are considered as input variables and A, B, 
C, and D are termed as output variables. The required Karnaugh maps are prepared as 
per Figures 5.22(a)-(d).
 
 
Y′Z′ 
Y′Z 
YZ 
YZ’ 
 
Y′Z′ 
Y′Z 
 YZ 
   YZ′
 
W′X′ 
 X 
X 
 
X 
W′X′ 
X 
X 
 
   X 
 
 
 
 
 
 
 
 
 
 
 
 
W′X 
 
 
 
 
W′X 
 
 
 1 
 
 
 
 
 
 
 
 
 
 
 
 
 
WX 
1 
X 
X 
X 
WX 
 
X 
 X 
   X 
 
 
 
 
 
 
 
 
 
 
 
 
WX′ 
 
 
1 
 
WX′ 
1 
1 
 
   1
 
  Figure 5.22(a) Karnaugh map for A. 
 
   Figure 5.22(b) Karnaugh map for B.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
 YZ′
 
W′X′ 
X 
X 
 
X 
W′X′ 
X 
X 
 
X 
 
 
 
 
 
 
 
 
 
 
 
 
W′X 
 
1 
 
1 
W′X 
1 
 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
WX 
 
X 
X 
X 
WX 
1 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
WX′ 
 
1 
 
1 
WX′ 
1 
 
 
X 
 
 
 
 
 
 
 
 
 
 
 
 
  Figure 5.22(c) Karnaugh map for C. 
 
   Figure 5.22(d) Karnaugh map for D.
The Boolean expressions of the outputs are 
 
A = WX + WYZ
 
B = X′Y′ + X′Z′ + XYZ
 
C = Y′Z + YZ′
 
D = Z′.

140
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.23
The logic diagram of an Excess-3-to-BCD converter is shown in Figure 5.23.
The alternative circuit diagram of Figure 5.24 can be made after the following modiﬁ cation 
on the above Boolean expressions. 
 
A = WX + WYZ = W(X + YZ)
 
B = X′Y′ + X′Z′ + XYZ = X′(Y′ + Z′) + XYZ = X′(YZ)′ + XYZ
 
C = Y′Z + YZ′
 
D = Z′
Figure 5.24

COMBINATIONAL LOGIC CIRCUITS 141
5.6  PARITY GENERATOR AND CHECKER
Parity is a very useful tool in information processing in digital computers to indicate any 
presence of error in bit information. External noise and loss of signal strength cause loss of 
data bit information while transporting data from one device to other device, located inside 
the computer or externally. To indicate any occurrence of error, an extra bit is included with 
the message according to the total number of 1s in a set of data, which is called parity. If 
the extra bit is considered 0 if the total number of 1s is even and 1 for odd quantities of 
1s in a set of data, then it is called even parity. On the other hand, if the extra bit is 1 for 
even quantities of 1s and 0 for an odd number of 1s, then it is called odd parity.
5.6.1  Parity Generator
A parity generator is a combination logic system to generate the parity bit at the 
transmitting side. A table in Figure 5.25 illustrates even parity as well as odd parity for a 
message consisting of four bits.
Four bit Message 
Even Parity 
Odd Parity
 
D3D2D1D0 
( P e ) 
( Po ) 
 
0000 
0 
1 
 
0001 
1 
0 
 
0010 
1  
0 
 
0011 
0 
1 
 
0100 
1 
0 
 
0101 
0 
1 
 
0110 
0 
1 
 
0111 
1 
0 
 
1000 
1 
0 
 
1001 
0 
1 
 
1010 
0 
1 
 
1011 
1 
0 
 
1100 
0 
1 
 
1101 
1 
0 
 
1110 
1 
0 
 
1111 
0 
1 
Figure 5.25
If the message bit combination is designated as D3D2D1D0, and Pe , Po are the even 
and odd parity respectively, then it is obvious from the table that the Boolean expressions 
of even parity and odd parity are
 
Pe = D3⊕D2⊕D1⊕D0  
and
 
Po = (D 3⊕D2⊕D1⊕D0)′.
 
These can be conﬁ rmed by Karnaugh maps, also (not shown here). The logic diagrams 
are shown in Figures 5.26(a)-(b).

142
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.26(a) Even parity generator.
Figure 5.26(b) Odd parity generator.
The above illustration is given for a message with four bits of information. However, 
the logic diagrams can be expanded with more XOR gates for any number of bits.
5.6.2  Parity Checker
The message bits with the parity bit are transmitted to their destination, where they 
are applied to a parity checker circuit. The circuit that checks the parity at the receiver 
side is called the parity checker. The parity checker circuit produces a check bit and is very 
similar to the parity generator circuit. If the check bit is 1, then it is assumed that the 
received data is incorrect. The check bit will be 0 if the received data is correct.
 
4-bit message 
Even 
Even Parity 
4-bit message 
Odd 
Odd Parity
 
D3D2D1D0 
Parity 
Checker 
D3D2D1D0 
Parity 
Checker
 
 
(P e) 
(Ce) 
 
 ( P0 ) 
(Co)
 
0000 
0 
0 
0000 
1 
0 
 
0001 
1 
0 
0001 
0 
0 
 
0010 
1  
0 
0010 
0 
0 
 
0011 
0 
0 
0011 
1 
0 
 
0100 
1 
0 
0100 
0 
0 
 
0101 
0 
0 
0101 
1 
0 
 
0110 
0 
0 
0110 
1 
0 
 
0111 
1 
0 
0111 
0 
0 
 
1000 
1 
0 
1000 
0 
0 
 
1001 
0 
0 
1001 
1 
0 
 
1010 
0 
0 
1010 
1 
0 
 
1011 
1 
0 
1011 
0 
0 
 
1100 
0 
0 
1100 
1 
0 
 
1101 
1 
0 
1101 
0 
0 
 
1110 
1 
0 
1110 
0 
0 
 
1111 
0 
0 
1111 
1 
0 
Figure 5.27(a) Even parity checker. 
 
Figure 5.27(b) Odd parity checker.
D 3
D 2
D 1
D 0
P e
D 3
D 2
D 1
D 0
P o

COMBINATIONAL LOGIC CIRCUITS 143
The tables in Figures 5.27(a)-(b) demonstrate the above. Note that the check bit is 
0 for all the bit combinations of correct data. For incorrect data the parity check bit will 
be another logic value. Parity checker circuits are the same as parity generator circuits as 
shown in Figures 5.28(a)-(b).
Figure 5.28(a) Even parity checker.
Figure 5.28(b) Odd parity checker.
5.7  SOME EXAMPLES OF COMBINATIONAL LOGIC CIRCUITS
Example 5.1. Find the squares of 3-bit numbers.
Solution. With three bits a maximum of eight combinations are possible with decimal 
equivalents of 0 to 7. By squaring of the decimal numbers the maximum decimal number produced 
is 49, which can be formed with six bits. Let us consider three input variables are X, Y, and Z, 
and six output variables are A, B, C, D, E, and F. A truth table is prepared as in Figure 5.29 
and Karnaugh maps for each of the output variables are shown in Figures 5.30(a)-(f).
Input variables 
Output variables
 
Decimal  
X 
Y 
Z 
Decimal 
A 
B 
C 
D 
E 
F 
 
 Equivalent 
 
 
 
Equivalent
 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
1 
0 
0 
1 
1 
0 
0 
0 
0 
0 
1 
 
2 
0 
1 
0 
4 
0 
0 
0 
 1 
0 
0 
 
3 
0 
1 
1 
9 
0 
0 
1 
0 
0 
1 
 
4 
1 
0 
0 
16 
0 
1 
0 
0 
0 
0 
 
5 
1 
0 
1 
25 
0 
1 
1 
0 
0 
1 
 
6 
1 
1 
0 
36 
1 
0 
0 
1 
0 
0 
 
7 
1 
1 
1 
49 
1 
1 
0 
0 
0 
1 
Figure 5.29
D 3
D 2
D 1
D 0
P e
C e
D3
D2
D1
D0
Po
Co

144
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
 
 
 
 
 X′
 
 
 
 
 
X 
 
 
1 
1  
X 
1  
 1  
1 
 
 
 
 
 
 
 
 
 
 
 
   Figure 5.30(a) Karnaugh map for A. 
     Figure 5.30(b) Karnaugh map for B.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
 
 
1 
 
X′ 
 
 
 
1 
 
 
X 
  
1 
 
 
X 
 
 
 
1 
 
 
 
 
 
 
 
 
 
 
 
     Figure 5.30(c) Karnaugh map for C. 
    Figure 5.30(d) Karnaugh map for D.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ’′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
0 
0 
0 
0 
X′ 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
X 
0 
0 
0 
0 
X 
 
1 
1 
 
 Figure 5.30(e) Karnaugh map for E.  
  Figure 5.30(f) Karnaugh map for F.
Figure 5.31
X
A
B
C
D
E
F
Y
Z

COMBINATIONAL LOGIC CIRCUITS 145
The Boolean expressions of the output variables are 
 
A = XY 
B = XY′ + XZ
 
C = X′YZ + XY′Z = (X′Y + XY′)Z  
D = YZ′
 
E = 0            and 
F = Z.
The circuit diagram of the combinational network to obtain squares of three-bit numbers 
is shown in Figure 5.31.
Example 5.2. Find the cubes of 3-bit numbers.
Solution. Eight combinations are possible with 3-bit numbers and produce decimal 
equivalents of a maximum of 343 when cubes of them are calculated. These can be formed 
with nine bits. Let us consider the three input variables are X, Y, and Z, and the nine 
output variables are A, B, C, D, E, F, G, H, and I. A truth table is prepared as in Figure 
5.32 and Karnaugh maps for each of the output variables are shown in Figures 5.34(a)-(i). 
The circuit diagram of this combinational network is shown in Figure 5.33.
The Boolean expressions of the output variables are
 
A = XYZ 
B = XYZ′ 
C = X
 
D = XY′Z 
E = XY + YZ + XZ
 
F = X′Y + YZ′ + XY′Z = (X′ + Z′)Y + XY′Z = (XZ)′Y + XZY′
 
G = XZ 
H = YZ 
I = Z.
Input variables 
Output variables 
 
Decimal 
X 
Y 
Z 
Decimal 
A 
B 
C 
D 
E 
F 
G 
H 
I
 Equivalents 
 
 
 
Equivalents 
 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
1 
0 
0 
1 
1 
0 
0 
0 
0 
0 
0 
0 
0 
1 
 
2 
0 
1 
0 
8 
0 
0 
0 
0 
0 
1 
0 
0 
0 
 
3 
0 
1 
1 
27 
0 
0 
0 
0 
1 
1 
0 
1 
1 
 
4 
1 
0 
0 
64 
0 
0 
1 
0 
0 
0 
0 
0 
0 
 
5 
1 
0 
1 
125 
0 
0 
1 
1 
1 
1 
1 
0 
1 
 
6 
1 
1 
0 
216 
0 
1 
1 
0 
1 
1 
0 
0 
0 
 
7 
1 
1 
1 
343 
1 
0 
1 
0 
1 
0 
1 
1 
1 
Figure 5.32

146
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.33
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
 
 
 
 
X′ 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
X 
 
 
1 
 
X 
 
 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 Figure 5.34(a) Karnaugh map for A. 
 
  Figure5.34(b) Karnaugh map for B.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
 
 
 
 
X′ 
 
 
 
 
 
X 
1 
1 
1 
1 
X 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   Figure 5.34(c) Karnaugh map for C.  
   Figure 5.34(d) Karnaugh map for D.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
 
 
1 
 
 X′ 
 
 
1 
1 
 
X 
 
1 
1 
1 
 X 
 
1 
 
1 
  Figure 5.34(e) Karnaugh map for E.  
  Figure 5.34(f) Karnaugh map for F.

COMBINATIONAL LOGIC CIRCUITS 147
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
X′ 
 
 
 
 
 X′ 
 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
X 
 
1 
1 
 
 X 
 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Figure 5.34(g) Karnaugh map for G.  
  Figure 5.34(h): Karnaugh map for H.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
 X′ 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 X 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.34(i) Karnaugh map for I.
Example 5.3. Design a combinational circuit for converting 2421 code to BCD code.
Solution. Both the 2421 code and BCD code are 4-bit codes and represent the decimal 
equivalents 0 to 9. To design the converter circuit for the above, ﬁ rst the truth table is 
prepared as in Figure 5.35 with the input variables W, X, Y, and Z of 2421 code, and the 
output variables A, B, C, and D. Karnaugh maps to obtain the simpliﬁ ed expressions of 
the output functions are shown in Figures 5.36(a)-(d). Unused combinations are considered 
as don’t-care condition.
Decimal 
Input varibles 
Output variables
 
Equivalent 
2421 code 
BCD code
 
 
W 
X 
Y 
Z 
A 
B 
C 
D 
 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
1 
0 
0 
0 
1 
0 
0 
0 
1 
 
2 
0 
0 
1 
0 
0 
0 
1 
0 
 
3 
0 
0 
1 
1 
0 
0 
1 
1 
 
4 
0 
1 
0 
0 
0 
1 
0 
0 
 
5 
1 
0 
1 
1 
0 
1 
0 
1 
 
6 
1 
1 
0 
0 
0 
1 
1 
0 
 
7 
1 
1 
0 
1 
0 
1 
1 
1 
 
8 
1 
1 
1 
0 
1 
0 
0 
0 
 
9 
1 
1 
1 
1 
1 
0 
0 
1
Figure 5.35

148
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
W′X′ 
 
 
 
 
W′X′ 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
W′X 
 
X 
X 
X 
 W′X 
1 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
WX 
 
 
1 
1 
WX 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
WX′ 
X 
X 
 
X 
 WX′ 
X 
X 
1 
X 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.36(a) Karnaugh map for A. 
Figure 5.36(b) Karnaugh map for B.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
W′X′ 
 
 
1 
1 
 W′X′ 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
W′X 
 
X 
X 
X 
 W′X 
 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
WX 
1 
1 
 
 
 WX 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
WX′ 
X 
X 
 
X 
 WX′ 
X 
X 
1 
X 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.36(c) Karnaugh map for C. 
Figure 5.36(d) Karnaugh map for D.
Figure 5.37

COMBINATIONAL LOGIC CIRCUITS 149
The Boolean expressions for the output functions are 
A = XY 
B = XY′+WX′
C = W′Y + WY′ 
D = Z.
The logic diagram of the required converter is shown in Figure 5.37.
Example 5.4. Design a combinational circuit that converts 2421 code to 84-2-1 code, 
and also the converter circuit for 84-2-1 code to 2421 code.
Solution. Both the codes represent binary codes for decimal digits 0 to 9. Let A, B, 
C, and D be represented as 2421 code variables and W, X, Y, and Z be variables for 84-2-1. 
The truth table is shown in Figure 5.38. The Karnaugh maps for W, X, Y, and Z in respect 
to A, B, C, and D are shown in Figure 5.39(a)-(d).
 
Decimal 
2421 Code 
84-2-1 code 
 
Digits 
A 
B 
C 
D 
W 
X 
Y 
Z 
 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
1 
0 
0 
0 
1 
0 
1 
1 
1 
 
2 
0 
0 
1 
0 
0 
1 
1 
0 
 
3 
0 
0 
1 
1 
0 
1 
0 
1 
 
4 
0 
1 
0 
0 
0 
1 
0 
0 
 
5 
1 
0 
1 
1 
1 
0 
1 
1 
 
6 
1 
1 
0 
0 
1 
0 
1 
0 
 
7 
1 
1 
0 
1 
1 
0 
0 
1 
 
8 
1 
1 
1 
0 
1 
0 
0 
0 
 
9  
1 
1 
1 
1 
1 
1 
1 
1
Figure 5.38
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
CD′
 
A′B′ 
 
 
 
 
A′B′ 
 
1 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
 
X 
X 
X 
A′B 
1 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
1 
1 
1 
1 
AB 
 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
X 
X 
1 
X 
AB′ 
X 
X 
 
X 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.39(a) Karnaugh map for W. 
Figure 5.39(b) Karnaugh map for X.

150
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
CD′
 
A′B′ 
 
1 
 
1 
A′B′ 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
 
X 
X 
X 
A′B 
 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
1 
 
1 
 
AB 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
X 
X 
1 
X 
AB′ 
X 
X 
1 
X 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.39(c) Karnaugh map for Y. 
Figure 5.39(d) Karnaugh map for Z.
The Boolean expressions for a 2421-to-84-2-1 code converter are
 W = A
 X = A′B + A′C + A′D + BCD = A′(B + C + D) + BCD
 Y = AC′D′ + ACD + A′C′D + A′CD′
 Z = D.
The circuit diagram for a 2421-to-84-2-1 code converter is shown in Figure 5.40.
Figure 5.40
To design the 84-2-1-to-2421 code converter, the Karnaugh maps for the variables A, 
B, C, and D in respect to W, X, Y, and Z are shown in Figures 5.41(a)-(d). 

COMBINATIONAL LOGIC CIRCUITS 151
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
W′X′ 
 
X 
X 
X 
 W′X′ 
 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
W′X 
 
 
 
 
 W′X 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
WX 
X 
X 
1 
X 
 WX 
X 
X 
1 
X 
 
 
 
 
 
 
 
 
 
 
 
 
WX′ 
1 
1 
1 
1 
 WX′ 
1 
1 
 
1 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.41(a) Karnaugh map for A. 
Figure 5.41(b) Karnaugh map for B.
 
 
Y′Z′ 
Y′Z 
YZ 
YZ′ 
 
Y′Z′ 
Y′Z 
YZ 
YZ′
 
W′X′ 
 
X 
X 
X 
 W′X′ 
 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
W′X 
 
1 
 
1 
 W′X 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
WX 
X 
X 
1 
X 
 WX 
X 
X 
1 
X 
 
 
 
 
 
 
 
 
 
 
 
 
WX′ 
1 
 
1 
 
 WX′ 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.41(c) Karnaugh map for C. 
Figure 5.41(d) Karnaugh map for D.
Figure 5.42

152
DIGITAL PRINCIPLES AND LOGIC DESIGN
The Boolean expressions for an 84-2-1-to-2421 code converter are
 
A = W
 
B = WX + WY′ + XY′Z′ + WYZ′
 
C = WY′Z′ + WYZ + XY′Z + XYZ′
 
D = Z.
The combinational circuit for an 84-2-1-to-2421 code converter is shown in Figure 5.42.
Example 5.5. Design a combinational circuit for a BCD-to-seven-segment decoder.
Solution. Visual display is one of the most important parts of an electronic circuit. 
Often it is necessary to display the data in text form before the digits are displayed. Various 
types of display devices are commercially available. Light Emitting Diode or LED is one 
of the most widely used display devices and it is economical, low-power-consuming, and 
easily compatible in electronic circuits. They are available in various sizes, shapes, and 
colors. Here our concern is to display the decimal numbers 0 to 9 with the help of LEDs. 
Special display modules consisting of seven LEDs ‘a, b, c, d, e, f, and g’ of a certain shape 
and placed at a certain orientation as in Figure 5.43(a) are employed for this purpose. For 
its shape and as each of the LEDs can be controlled individually, this display is called the 
seven segment display.
Decimal digits 0 to 9 can be displayed by glowing some particular LED segments. As 
an example, digit ‘0’ may be represented by glowing the segments a, b, c, d, e, and f as in 
Figure 5.43(b). Digit ‘1’ may be represented by glowing b and c as in Figure 5.43(c). Other 
digits are also displayed by glowing certain segments as illustrated in Figures 5.43(d) to 
5.43(k). In the ﬁ gures, thick segments represent the glowing LEDs. 
 
Figure 5.43(a) 
Figure 5.43(b)
Figure 5.43(c)
Figure 5.43(d) 
Figure 5.43(e) Figure 5.43(f)
 
(Orientation of 
(Digit 0) 
(Digit 1) 
(Digit 2) 
(Digit 3) 
(Digit 4)
 
seven LEDs in
 
a seven-segment
 
LED display.)
 
 
Figure 5.43(g)
Figure 5.43(h)
Figure 5.43(i) 
Figure 5.43(j) Figure 5.43(k)
 
 
(Digit 5) 
(Digit 6) 
(Digit 7) 
(Digit 8) 
(Digit 9)
Two types of seven-segment display modules are available—common cathode type and 
common anode type, the equivalent electronic circuits are shown in Figures 5.44(a) and 
5.44(b). From the equivalent circuit, it is clear that to glow a particular LED of common 
cathode type, logic 1 is to be applied at the anode of that LED as all the cathodes are 
grounded. Alternatively, logic 0 is to be applied to glow certain LEDs of common anode 
type, as all the anodes are connected to high-voltage Vcc.
a
a
a
a
a
a
f
f
f
f
f
f
e
e
e
e
g
e
e
d
d
d
d
d
d
c
c
c
c
c
c
b
b
b
b
b
b
a
a
a
a
a
f
f
f
f
f
e
e
e
g
e
e
d
d
d
d
d
c
c
c
c
c
b
b
b
b
b

COMBINATIONAL LOGIC CIRCUITS 153
Figure 5.44(a) Common cathode LED. 
Figure 5.44(b) Common anode LED.
 
Decimal 
Input Variables 
Output Variables as Seven Segment Display
 
Numbers 
A 
B 
C 
D 
a 
b 
c 
d 
e 
f 
g
 
0 
0 
0 
0 
0 
1 
1 
1 
1 
1 
1 
0 
 
1 
0 
0 
0 
1 
0 
1 
1 
0 
0 
0 
0 
 
2 
0 
0 
1 
0 
1 
1 
0 
1 
1 
0 
1 
 
3 
0 
0 
1 
1 
1 
1 
1 
1 
0 
0 
1 
 
4 
0 
1 
0 
0 
0 
1 
1 
0 
0 
1 
1 
 
5 
0 
1 
0 
1 
1 
0 
1 
1 
0 
1 
1 
 
6 
0 
1 
1 
0 
0 
0 
1 
1 
1 
1 
1 
 
7 
0 
1 
1 
1 
1 
1 
1 
0 
0 
0 
0 
 
8 
1 
0 
0 
0 
1 
1 
1 
1 
1 
1 
1 
 
9 
1 
0 
0 
1 
1 
1 
1 
0 
0 
1 
1
Figure 5.45 (For a common cathode display.)
Every decimal digit of 0 to 9 is represented by the BCD data, consisting of four input 
variables A, B, C, and D. A truth table can be made for each of the LED segments. A 
truth table for a common cathode display is shown in Figure 5.45. The Boolean expression 
for output variables a to g are obtained with the help of the Karnaugh maps as shown in 
Figures 5.46(a) to 5.46(g). The circuit diagram is developed as shown in Figure 5.47.
Note that the Boolean expressions of the outputs of a common anode type display are 
the complemented form of the respective outputs of a common cathode type.
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
 CD′
 
A′B′ 
1 
 
1 
1 
A′B′ 
1 
1 
1 
 1 
 
A′B 
 
1 
1 
 
A′B 
1 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
X 
X 
X 
X 
AB 
X 
X 
X 
 X 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
1 
1 
X 
X 
AB′ 
1 
1 
X 
 X 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.46(a) Karnaugh map for a.
    Figure 5.46(b) Karnaugh map for b.

154
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
CD′
 
A′B′ 
1 
1 
1 
 
A′B′ 
1 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
1 
1 
1 
1 
A′B 
 
1 
 
1 
 
 
 
 
 
 
AB 
X 
X 
X 
X 
AB 
X 
X 
X 
X 
 
AB′ 
1 
1 
X 
X 
AB′ 
1 
 
X 
X 
Figure 5.46(c) Karnaugh map for c.
Figure 5.46(d) Karnaugh map for d.
 
 
C′D′ 
C′D 
CD 
CD′ 
 
C′D′ 
C′D 
CD 
CD′
 
A′B′ 
1 
 
 
1 
A′B′ 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
 
 
 
1 
A′B 
1 
1 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
X 
X 
X 
X 
AB 
X 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
1 
 
X 
X 
AB′ 
1 
1 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.46(e) Karnaugh map for e.
Figure 5.46(f) Karnaugh map for f.
 
 
C′D′ 
C′D 
CD 
CD′
 
A′B′ 
 
 
1 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
A′B 
1 
1 
 
1 
 
 
 
 
 
 
 
 
 
 
 
 
 
AB 
X 
X 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
AB′ 
1 
1 
X 
X 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 5.46(g) Karnaugh map for g.

COMBINATIONAL LOGIC CIRCUITS 155
Figure 5.47
The Boolean expressions for a to g are given as
a = A + CD + BD + B′D′
b = B′ + C′D′ + CD
c = B + C′ + D
d = B′D′ + CD′ + B′C + BC′D
e = B′D′ + CD′
f = A + C′D′ + BC′ + BD′
g = A + BC′ + CD′ + B′C.
The BCD-to-seven-segment decoders are commercially available in a single IC 
package.

156
DIGITAL PRINCIPLES AND LOGIC DESIGN
5.8  COMBINATIONAL LOGIC WITH MSI AND LSI
The purpose of simpliﬁ cation of Boolean functions is to obtain an algebraic expression with 
less number of literals and less numbers of logic gates. This results in low-cost circuit 
implementation. The design procedure for combinational circuits as described in the preceding 
sections is intended to minimize the number of logic gates to implement a given function. 
This classical procedure realizes the logic circuit with fewer gates with the assumption that 
the circuit with fewer gates will cost less. However, in practical design, with the arrival of 
a variety of integrated circuits (IC), this concept is always true.
Since one single IC package contains several number of logic gates, it is economical to 
use as many of the gates from an already used package, even if the total number of gates 
is increased by doing so. Moreover, some of the interconnections among the gates in many 
ICs are internal to the chip and it is more economical to use such types of ICs to minimize 
the external interconnections or wirings among the IC pins as much as possible. A typical 
example of this is if the circuit diagrams of Figures 5.23 and 5.24 are considered. Both circuit 
diagrams perform the function of Excess-3-to-BCD code conversion and consist of 13 logic 
gates. However, the circuit of Figure 5.23 needs six ICs (one 3-input OR, one 3-input AND, 
two 2-input AND, one 2-input OR, and one INVERTER, since one 3-input OR IC package 
contains three gates, one 3-input AND IC contains three gates, one 2-input AND IC contains 
four gates, one 2-input OR IC contains four gates, and one INVERTER IC contains six gates), 
but the circuit diagram of Figure 5.24 requires four ICs (two 2-input AND IC, one 2-input 
OR IC, and one INVERTER). So obviously, logic implementation of Figure 5.24 is economical 
because of its fewer number of IC packages. So for design with integrated circuits, it is not 
the count of logic gates that reduces the cost, but the number and type of IC packages used 
and the number of interconnections required to implement certain functions. 
Though the classical method constitutes a general procedure, is very easy to understand, 
and certain to produce a result, on numerous occasions it does not achieve the best possible 
combinational circuit for a given function. Moreover, the truth table and simpliﬁ cation 
procedure in this method become too cumbersome if the number of input variables is 
excessively large and the ﬁ nal circuit obtained may require a relatively large number of ICs 
and interconnecting wires. In many cases the alternative design approach can lead to a far 
better combinational circuit for a given function with comparison to the classical method. 
The alternate design approach depends on the particular application and the ingenuity as 
well as experience of the designer. To handle a practical design problem, it should always 
be investigated which method is more suitable and efﬁ cient.
Design approach of a combinational circuit is ﬁ rst to analysis and to ﬁ nd out whether 
the function is already available as an IC package. Numerous ICs are commercially available, 
some of which perform speciﬁ c functions and are commonly employed in the design of 
digital computer system. If the required function is not exactly matched with any of the 
commercially available devices, a good designer will formulate a method to incorporate the 
ICs that are nearly suitable to the function.
A large number of integrated circuit packages are commercially available nowadays. 
They can be widely categorized into three groups—SSI or small scale integration where the 
number of logic gates is limited to ten in one IC package, MSI or medium scale integration 
where the number of logic gates is eleven to one hundred in one IC package, and LSI or 
large-scale integration containing more than one hundred gates in one package. Some of 
them are fabricated for speciﬁ c functions. VLSI or very large scale integration IC packages 

COMBINATIONAL LOGIC CIRCUITS 157
are also introduced, which perform dedicated functions achieving high circuit space reduction 
and interconnection reduction.
5.9  FOUR-BIT BINARY PARALLEL ADDER
In the preceding section, we discussed how two binary bits can be added and the addition 
of two binary bits with a carry. In practical situations it is required to add two data each 
containing more than one bit. Two binary numbers each of n bits can be added by means of a 
full adder circuit. Consider the example that two 4-bit binary numbers B4B3B2B1 and A4A3A2A1
are to be added with a carry input C1. This can be done by cascading four full adder circuits 
as shown in Figure 5.48. The least signiﬁ cant bits A1, B1, and C1 are added to the produce 
sum output S1 and carry output C2. Carry output C2 is then added to the next signiﬁ cant 
bits A2 and B2 producing sum output S2 and carry output C3. C3 is then added to A3 and B3
and so on. Thus ﬁ nally producing the four-bit sum output S4S3S2S1 and ﬁ nal carry output 
Cout. Such type of four-bit binary adder is commercially available in an IC package.
Figure 5.48
For the addition of two n bits of data, n numbers of full adders can be cascaded as 
demonstrated in Figure 5.48. It can be constructed with 4-bit, 2-bit, and 1-bit full adder 
IC packages. The carry output of one package must be connected to the carry input of the 
next higher order bit IC package of higher order bits.
The addition technique adopted here is a parallel type as all the bit addition operations 
are performed in parallel. Therefore, this type of adder is called a parallel adder. Serial types 
of adders are also available where a single full adder circuit can perform any n number 
of bit addition operations in association with shift registers and sequential logic network. 
This will be discussed in the later chapters. 
The 4-bit parallel binary adder IC package is useful to develop combinational circuits. 
Some examples are demonstrated here.
Example 5.6. Design a BCD-to-Excess-3 code converter.
Figure 5.49
B4
B3
B 2
B1
S 4
S 3
C 3
C 4
C 2
C 1
S 2
S1
FA
FA
FA
FA
Cout
A4
A3
A 2
A1
Excess-3 Outputs
Logic 0
Logic 0
Logic 1
Not Used
Cout
BCD Inputs
B4
A4
B3
A3
B2
A2
B1
A1
Cin
4-BIT BINARY ADDER
S4
S3
S2
S 1

158
DIGITAL PRINCIPLES AND LOGIC DESIGN
If we analyze the BCD code and Excess-3 code critically, you will see that Excess-3 code
can be achieved by adding 0011 (decimal equivalent is 3) with BCD numbers. So a 4-bit 
binary adder IC can solve this very easily as shown in Figure 5.49.
It may be noticed that a BCD-to-Excess-3 converter has been implemented by classical 
method in Section 5.5.3, where four OR gates, four AND gates, and three INVERTER 
gates are employed. In terms of IC packages, three SSI packages (one AND gates IC, one 
OR gate IC, and one INVERTER IC) are used and a good amount of interconnections are 
present. In comparison to that the circuit developed in Figure 5.49 requires only one MSI 
IC of 4-bit binary adder and interconnections have reduced drastically. So the combinational 
circuit of Figure 5.49 is of low cost, trouble-free, less board, space consuming and less power 
dissipation.
5.9.1  Four-bit Binary Parallel Subtractor
It is interesting to note that a 4-bit binary adder can be employed to obtain the 4-bit 
binary subtraction. In Chapter 1, we saw how binary subtraction can be achieved using 
1’s complement or 2’s complement. By 1’s complement method, the bits of subtrahend are 
complemented and added to the minuend. If any carry is generated it is added to the sum 
output. Figure 5.50 demonstrates the subtraction of B4B3B2B1 from A4A3A2A1. Each bit of 
B4B3B2B1 is ﬁ rst complemented by using INVERTER gates and added to A4A3A2A1 by a 4-bit 
binary adder. End round carry is again added using the C in pin of the IC.
Figure 5.50
5.9.2  Four-bit Binary Parallel Adder/Subtractor
Due to the property of the 4-bit binary adder that it can perform the subtraction 
operation with external inverter gates, a single combinational circuit may be developed 
that can perform addition as well as the subtraction introducing a control bit. A little 
modiﬁ cation helps to obtain this dual operation. Figure 5.51 demonstrates this dual-purpose 
combinational logic circuit.
XOR gates are used at addend or subtrahend bits when one of the inputs of the XOR gate 
is connected to the ADD/SUBTRACT terminal, which is acting as control terminal. The same 
terminal is connected to Cin. When this terminal is connected to logic 0 the combinational 
circuit behaves like a 4-bit full adder, as at this instant Cin is logic low and XOR gates are 
acting as buffers whose outputs are an uncomplemented form of inputs. If logic 1 is applied 
to the ADD/SUBTRACT terminal, the XOR gates behave like INVERTER gates and data bits 
are complemented. The 4-bit adder now performs the addition operation of data A3A2A1A0
with complemented form of data B3B2B1B0 as well as with a single bit 1, as Cin is now logic 
1. This operation is identical to a subtraction operation using 2’s complment.
End Round Carry
Cout
4bit M inuend
4bit Subtrahend
4-BIT BINARY ADDER
B4
A 4
B3
A 3
B2
A 2
B1
A 1
Cin
S4
S3
S2
S 1
S4
S3
S2
S 1

COMBINATIONAL LOGIC CIRCUITS 159
Figure 5.51
5.9.3  Fast Adder
The addition of two binary numbers in parallel implies that all the bits of both augend 
and addend are available at the same time for computation. In any combinational network, 
the correct output is  available only after the signal propagates through all the gates of its 
concern. Every logic gate offers some delay when the signal passes from its input to output, 
which is called the propagation delay of the logic gate. So every combinational circuit takes 
some time to produce its correct output after the arrival of all the input, which is called 
total propagation time and is equal to the propagation delay of individual gates times the 
number of gate levels in the circuit. In a 4-bit binary parallel adder, carry generated from 
the ﬁ rst full adder is added to the next full adder, carry generated form here is added to 
the next full adder and so on (refer to Figure 5.48). Therefore, the steady state of ﬁ nal 
carry is available after the signal propagating through four full adder stages and suffers 
the longest propagation delay with comparison to the sum outputs, as the sum outputs are 
produced after the signal propagation of only one full adder stage. 
The number of gate levels for the carry propagation can be found from the circuit of 
full adder. The circuit shown in Figure 5.7 is redrawn in Figure 5.52 for convenience. The 
input and output variables use the subscript i to denote a typical stage in the parallel adder. 
In Figure 5.52, Pi and Gi represent the intermediate signals settling to their steady sate 
values after the propagation through the respective gates and common to all full adders 
and depends only on the input augend and addend bits. The signal from input carry Ci
to output carry Ci+1 propagates through two gate levels—an AND gate and an OR gate. 
Therefore, for a four-bit parallel adder, the ﬁ nal carry will be available after propagating 
through 2 × 4 = 8 gate levels. For an n-bit parallel adder there will be 2n number of gate 
levels to obtain the ﬁ nal carry to its steady state. 
Figure 5.52
B3
A3
B2
A2
B1
B0
A1
A0
Add'/Subtract
Cout
Addend Bits
Augend Bits
S4
S4
S3
S3
S2
S2
S1
S1
Cin
4-BIT BINARY ADDER
A i
B i
C i
G i
Pi
S i
C i+1

160
DIGITAL PRINCIPLES AND LOGIC DESIGN
Although any combinational network will always have some value at the output 
terminals, the outputs should not be considered correct unless the signals are given enough 
time to propagate through all the gates required for computation from input stage to 
output. For a 4-bit parallel binary adder, carry propagation plays an important role as it 
takes the longest propagation time. Since all other arithmetic operations are implemented 
by successive addition process, the time consumed during the addition process is very 
critical. One obvious method to reduce the propagation delay time is to use faster gates. 
But this is not always the practical solution because the physical circuits have a limit to 
their capability. Another technique is to employ a little more complex combinational circuit, 
which can reduce the carry propagation delay time. There are several techniques for the 
reduction of carry propagation delay time. However, the most widely used method employs 
the principle of look ahead carry generation, which is illustrated below.
5.9.4  Look-ahead Carry Generator
Consider the full adder circuit in Figure 5.52. Two intermediate variables are deﬁ ned 
as Pi and Ci such that 
 
 
Pi = Ai ⊕ Bi 
 
and 
 
Gi = AiBi.
The output sum and carry can be expressed in terms of Pi and Gi as
 
 
Si = Pi ⊕ Ci 
 
and 
 
Ci+1 = Gi + PiCi.
Gi is called the carry generate and it generates an output carry if both the inputs Ai
and Bi are logic 1, regardless of the input carry. Pi is called the carry propagate because it 
is the term associated with the propagation of the carry from Ci to Ci+1.
Figure 5.53
Now the Boolean expressions for the carry output of each stage can be written after 
substituting Ci and Ci+1 as
P 3
G 3
P 2
G 2
P 1
G 1
C 1
C 2
C 3
C 4

COMBINATIONAL LOGIC CIRCUITS 161
C2 = G1 + P1C1
C3 = G2 + P2C2 = G2 + P2(G1 + P1C1) = G2 + P2G1 + P2P1C1
C4 = G3 + P3C3 = G3 + P3G2  + P3P2G1 + P3P2P1C1
C5 = G4 + P4C4 = G4 + P4G3  + P4P3G2 + P4P3P2G1 + P4P3P2P1C1.
Each of the above Boolean expressions are in sum of products form and each function 
can be implemented by one level of AND gates followed by one level of OR gates (or by two 
levels of NAND gates). So the ﬁ nal carry C5 after 4-bit addition now has the propagation 
delay of only two level gates instead of eight levels as described earlier. In fact, all the 
intermediate carry as well as the ﬁ nal carry C2, C3, C4, and C5 can be implemented by only 
two levels of gates and available at the same time. The ﬁ nal carry C5 need not have to 
wait for the intermediate carry to propagate. The three Boolean functions C2, C3, and C4
are shown in Figure 5.53 which is called the look ahead carry generator.
The 4-bit parallel binary adder can be constructed with the association of a look-ahead 
carry generator as shown in Figure 5.54. Pi and Gi signals are generated with the help of 
XOR
Figure 5.54
P4
G 4
Cout
B4
B3
B2
B1
A4
A3
A2
A1
P3
G 3
P2
P1
G 2
G 1
C 4
C 3
C 2
C 1
C 1
Look
C 5
S 4
S 3
S 2
S 1
       Ahead   
 C arry
Generator

162
DIGITAL PRINCIPLES AND LOGIC DESIGN
gates and AND gates, and sum outputs S1 to S4 are derived by using XOR gates. Thus, 
all sum outputs have equal propagation delay. Therefore, the 4-bit parallel binary adder 
realized with a look-ahead carry generator has reduced propagation delay and has a higher 
speed of operation.
5.9.5  Decimal Adder
Since computers and calculators perform arithmetic operations directly in the decimal 
number system, the arithmetic data employed in those devices must be in binary coded 
decimal form. The arithmetic circuit must accept data in coded decimal numbers and produce 
the outputs in the accepted code. For general binary addition, it is sufﬁ cient to consider 
two signiﬁ cant bits at a time and the previous carry.  
But each decimal number of binary coded form consists of four bits. So the combinational 
network for addition of two decimal numbers involves at least nine input variables (two 
decimal numbers each of the four bits and a carry bit from the previous stage) and ﬁ ve 
output variables (four bits for the sum result and a carry bit).
There are a wide variety of combinational circuits for addition operations of decimal 
numbers depending on the code used. The design of nine-input ﬁ ve-output combinational 
circuits by classical method requires a truth table of 29 = 512 entries. Many of the input 
conditions are don’t-care conditions as binary code representing decimal numbers have nine 
valid combinations and six combinations are invalid. To obtain the simpliﬁ ed expression of 
each of the output is too lengthy and cumbersome by classical method. A computer-generated 
program for the tabulation method may be adopted, but that too will involve a lot of logic 
gates and interconnections. A 4-bit parallel binary adder may be employed for this purpose 
if illegal bit combinations are intelligently tackled.
5.9.5.1  BCD Adder
Consider the arithmetic addition of two decimal numbers in BCD (Binary Coded 
Decimal) form together with a possible carry bit from a previous stage. Since each input 
cannot exceed 9, the output sum must not exceed 9 + 9 + 1 = 19 (1 in the sum is input 
carry from a previous stage). If a four-bit binary adder is used, the normal sum output 
will be of binary form and may exceed 9 or carry may be generated. So the sum output 
must be converted to BCD form. A truth table is shown in Figure 5.55 for the conversion 
of binary to BCD for numbers 0 to 19. Here, the sum outputs of a 4-bit binary adder 
are considered as X4X3X2X1 with its carry output K and they are converted to BCD form 
S4S3S2S1 with a ﬁ nal carry output C.
By examining the contents of the table, it may be observed that the output of the BCD 
form is identical to the binary sum when the binary sum is equal to or less than 1001 or 
9, and therefore, no conversion is needed for these bit combinations. When the binary sum 
is greater than 1001, they are invalid data in respect to BCD form. The valid BCD form 
can be obtained with the addition of 0110 to the binary sum and also the required output 
carry is generated.

COMBINATIONAL LOGIC CIRCUITS 163
Decimal 
Binary sum 
BCD sum 
 
 
K 
X4 
X3 
X2 
X1 
C 
S4 
S3 
S2 
S1
 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
1 
0 
0 
0 
0 
1 
0 
0 
0 
0 
1 
 
2 
0 
0 
0 
1 
0 
0 
0 
0 
1 
0 
 
3 
0 
0 
0 
1 
1 
0 
0 
0 
1 
1 
 
4 
0 
0 
1 
0 
0 
0 
0 
1 
0 
0 
 
5 
0 
0 
1 
0 
1 
0 
0 
1 
0 
1 
 
6 
0 
0 
1 
1 
0 
0 
0 
1 
1 
0 
 
7 
0 
0 
1 
1 
1 
0 
0 
1 
1 
1 
 
8 
0 
1 
0 
0 
0 
0 
1 
0 
0 
0 
 
9 
0 
1 
0 
0 
1 
0 
1 
0 
0 
1 
 
10 
0 
1 
0 
1 
0 
1 
0 
0 
0 
0 
 
11 
0 
1 
0 
1 
1 
1 
0 
0 
0 
1 
 
12 
0 
1 
1 
0 
0 
1 
0 
0 
1 
0 
 
13 
0 
1 
1 
0 
1 
1 
0 
0 
1 
1 
 
14 
0 
1 
1 
1 
0 
1 
0 
1 
0 
0 
 
15 
0 
1 
1 
1 
1 
1 
0 
1 
0 
1 
 
16 
1 
0 
0 
0 
0 
1 
0 
1 
1 
0 
 
17 
1 
0 
0 
0 
1 
1 
0 
1 
1 
1 
 
18 
1 
0 
0 
1 
0 
1 
1 
0 
0 
0 
 
19 
1 
0 
0 
1 
1 
1 
1 
0 
0 
1 
Figure 5.55
A logic circuit is necessary to detect the illegal binary sum output and can be derived 
from the table entries. It is obvious that correction is needed when the binary sum produces 
an output carry K = 1, and for six illegal combinations from 1010 to 1111. Let us consider a 
logic function Y is generated when the illegal data is detected. A Karnaugh map is prepared for
 
X2′X1′ 
X2′X1 
X2X1 
X2X1′
  
X4′X3′
  
X4′X3
  
X4X3 
1 
1 
1 
1
  
X4X3′ 
 
 
1 
1
Figure 5.56

164
DIGITAL PRINCIPLES AND LOGIC DESIGN
Y with the variables X4, X3, X2, and X1 in Figure 5.56. The output carry K is left aside as 
we know correction must be done when K = 1. The simpliﬁ ed Boolean expression for Y with 
variables X4, X3, X2, and X1 is
 
 
Y = X4X3 + X4X2.
As the detection logic is also 1 for K = 1, the ﬁ nal Boolean expression of Y taking the 
variable K into account will be
 
 
Y = K + X4X3 + X4X2.
The complete combinational circuit for a BCD adder network implemented with the 
help of a 4-bit binary adder is shown in Figure 5.57.
Figure 5.57
A BCD adder is a combinational circuit that adds two BCD numbers in parallel and 
produces a sum output also in BCD form. A BCD adder circuit must have the correction 
logic circuit in its internal construction. The correction logic is activated when the stage of 
binary sum is greater than 1001 and adds 0110 to the binary sum with the help of another 
binary adder. The output carry generated from the later stage of addition may be ignored 
as the ﬁ nal carry bit is already established.
The BCD adder circuit may be implemented by two 4-bit binary adder MSI ICs and 
one IC to generate the correction logic. However, a BCD adder is also available in an MSI 
package. To achieve shorter propagation delay, an MSI BCD adder includes the necessary 
look ahead carry generator circuit. The adder circuit for the correction logic does not need 
all four full adders and it is optimized within the IC package.
B3 B2
A 3
B1
A2
B0
A 1
S3 S2
S1
Cin
4-BIT BIN ARY ADDER
Cout
BCD INPUT (B)
BCD INPUT (A)
LOGIC  0
Cin
4-BIT BIN ARY ADDER
Cout
CARRY
BC D SUM  (S)
A 0
S0
B3 B2
A 3
B1
A 2
B0
A1
S3 S2
S 1
A0
S0

A decimal parallel adder of n decimal digits requires n numbers of BCD adder stages. 
The output carry from one stage must be connected to the input carry of the next higher 
order stage.
5.9.6  Parallel Multiplier
To understand the multiplication process, let us consider the multiplication of two 4-bit 
binary numbers, say 1101 and 1010.
 
 
 
 
  1 1 0 1 → Multiplicand
 
 
 
 
 × 1 0 1 0 → Multiplier
 
 
 
 
  0 0 0 0
 
 
 
 
 1 1 0 1  
 
Partial Products
 
 
 
 0 0 0 0  
 
 
 1 1 0 1
 
   1 0 0 0 0 0 1 0 → Final Product
From the above multiplication process, one can easily understand that if the multiplier 
bit is 1, the multiplicand is simply copied as a partial product. If the multiplicand bit is 0, 
partial product is 0. Whenever a partial product is obtained, it is placed by shifting one bit 
left to the previous partial product. After obtaining all the partial products and placing them 
in the above manner, they are added to get the ﬁ nal product. The multiplication, as illustrated 
above, can be implemented by a 4-bit binary adder. Figure 5.58  demonstrates a 4-bit binary 
parallel multiplier using three 4-bit adders and sixteen 2-input AND gates. Here, each group 
of four AND gates is used to obtain partial products while 4-bit parallel adders are used to 
add the partial products.
The operation of the 4-bit parallel multiplier is explained in symbolic form of a binary 
multiplication process as follows.
X3
X2
X1
X0
Multiplicand
Y3
Y2
Y1
Y0
Multiplier
X3 Y0
X2 Y0
X1 Y0
X0 Y0
Partial Product
X3 Y1
X2 Y1
X1 Y1
X0 Y1
Partial Product
C2
C1
C0
C3
S3
S2
S1
S0
Addition
X3 Y2
X2 Y2
X1 Y2
X0 Y2
Partial Product
C6
C5
C4
C7
S7
S6
S5
S4
Addition
X3 Y3
X2 Y3
X1Y3
X0Y3
Partial Product
C10
C9
C8
C11
S11
S10
S9
S8
Addition
M7
M6
M5
M4
M3
M2
M1
M0
Final Product
COMBINATIONAL LOGIC CIRCUITS 165

166
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.58
M 7
M 5 M 4
M 3
Cin
Cin
Cin
X3
Cout
Cout
Cout
4-Bit Binary Adder
4-Bit Binary Adder
4-Bit Binary Adder
X2
X1
Y 3
Y 2
Y 1
Y 0
X 0
M 2
M 1
M 0
M 6
B3
B 2
A3
B1
A2
B0
A1
S 3
S2
S1
A 0
S0
B3
B2
A3
B1
A2
B0
A 1
S3
S2
S1
A0
S0
B3
B2
A3
B 1
A2
B0
A1
S3
S 2
S 1
A0
S 0
X3
X2
X1
X 0
X 3
X 2
X 1
X0
X3
X 2
X1
X 0

COMBINATIONAL LOGIC CIRCUITS 167
5.10  MAGNITUDE COMPARATOR
A magnitude comparator is one of the useful combinational logic networks and has wide 
applications. It compares two binary numbers and determines if one number is greater 
than, less than, or equal to the other number. It is a multiple output combinational logic 
circuit. If two binary numbers are considered as A and B, the magnitude comparator gives 
three outputs for A > B, A < B, and A = B.
For comparison of two n-bit numbers, the classical method to achieve the Boolean 
expressions requires a truth table of 22n entries and becomes too lengthy and cumbersome. 
It is also desired to have a digital circuit possessing with a certain amount of regularity, 
so that similar circuits can be applied for the comparison of any number of bits. Digital 
functions that follow an inherent well-deﬁ ned regularity can usually be developed by means 
of algorithmic procedure if it exists. An algorithm is a process that follows a ﬁ nite set of 
steps to arrive at the solution to a problem. A method is illustrated here by deriving an 
algorithm to design a 4-bit magnitude comparator.
The algorithm is the direct application of the procedure to compare the relative 
magnitudes of two binary numbers. Let us consider the two binary numbers A and B are 
expanded in terms of bits in descending order as 
 
 
A = A4A3A2A1
 
 
B = B4B3B2B1,
where each subscripted letter represents one of the digits in the number. It is observed 
from the bit contents of the two numbers that A = B when A4 = B4, A3 = B3, A2 = B2, and 
A1 = B1. As the numbers are binary they possess the value of either 1 or 0, the equality 
relation of each pair can be expressed logically by the equivalence function as
 
Xi = AiBi + Ai′Bi′ 
for  
i  = 1, 2, 3, 4.
Or, 
Xi = (A⊕B)′.  
Or,  Xi ′ = A ⊕ B.
Or,  
Xi = (AiBi′ + Ai′Bi)′.
Xi is logic 1 when both Ai and Bi are equal i.e., either 1 or 0 at the same instant. To 
satisfy the equality condition of two numbers A and B, it is necessary that all Xi must be 
equal to logic 1. This dictates the AND operation of all Xi variables. In other words, we can 
write the Boolean expression for two equal 4-bit numbers
 
 
F (A 
= B) = X4X3X2X1.
To determine the relative magnitude of two numbers A and B, the relative magnitudes 
of pairs of signiﬁ cant bits are inspected from the most signiﬁ cant position. If the two digits of 
the most signiﬁ cant position are equal, the next signiﬁ cant pair of digits are compared. The 
comparison process is continued until a pair of unequal digits is found. It may be concluded 
that A>B, if the corresponding digit of A is 1 and B is 0. On the other hand, A<B if the 
corresponding digit of A is 0 and B is 1. Therefore, we can derive the logical expression of 
such sequential comparison by the following two Boolean functions,
 
 
F (A>B) = A4B4′ +X4A3B3′ +X4X3A2B2′ +X4X3X2A1B1′ 
 
and
 
 
F (A<B) = A4′B4 +X4A3′B3 +X4X3A2′B2 +X4X3X2A1′B1.
The logic gates implementation for the above expressions are not too complex as they 
contains many subexpressions of a repetitive nature and can be used at different places. The 
complete logic diagram of a 4-bit magnitude comparator is shown in Figure 5.59. This is a 

168
DIGITAL PRINCIPLES AND LOGIC DESIGN
multilevel implementation and you may notice that the circuit maintains a regular pattern. 
Therefore, an expansion of binary magnitude comparator of higher bits can be easily obtained. 
This combinational circuit is also applicable to the comparison of BCD numbers.
Figure 5.59
5.11  DECODERS
In a digital system, discrete quantities of information are represented with binary codes. A 
binary code of n bits can represent up to 2n distinct elements of the coded information. A 
decoder is a combinational circuit that converts n bits of binary information of input lines 
to a maximum of 2n unique output lines. Usually decoders are designated as an n to m lines 
decoder, where n is the number of input lines and m (=2n) is the number of output lines. 
Decoders have a wide variety of applications in digital systems such as data demultiplexing, 
digital display, digital to analog converting, memory addressing, etc. A 3-to-8 line decoder 
is illustrated in Figure 5.60.
F(A < B)
F(A > B)
F(A = B)
A4
B4
A3
B3
A2
B2
A1
B1

COMBINATIONAL LOGIC CIRCUITS 169
Figure 5.60
Input variables 
Outputs 
 
A 
B 
C 
D0 
D1 
D2 
D3 
D4 
D5 
D6 
D7
 
0 
0 
0 
1 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
1 
0 
1 
0 
0 
0 
0 
0 
0 
 
0 
1 
0 
0 
0 
1 
0 
0 
0 
0 
0 
 
0 
1 
1 
0 
0 
0 
1 
0 
0 
0 
0 
 
1 
0 
0 
0 
0 
0 
0 
1 
0 
0 
0 
 
1 
0 
1 
0 
0 
0 
0 
0 
1 
0 
0 
 
1 
1 
0 
0 
0 
0 
0 
0 
0 
1 
0 
 
1 
1 
1 
0 
0 
0 
0 
0 
0 
0 
1
Figure 5.61
The 3-to-8 line decoder consists of three input variables and eight output lines. Note that 
each of the output lines represents one of the minterms generated from three variables. The 
internal combinational circuit is realized with the help of INVERTER gates and AND gates.
The operation of the decoder circuit may be further illustrated from the input output 
relationship as given in the table in Figure 5.61. Note that the output variables are mutually 
exclusive to each other, as only one output is possible to be logic 1 at any one time.
In this section, the 3-to-8 line decoder is illustrated elaborately. However, higher order 
decoders like 4 to 16 lines, 5 to 32 lines, etc., are also available in MSI packages, where 
the internal circuits are similar to the 3-to-8 line decoder.
A
B
C
D  = A'B'C '
0
D  = A'B'C
1
D  = A'BC '
2
D  = A'BC
3
D  = AB'C
5
D  = ABC '
6
D  = ABC
7
D  = AB'C '
4

170
DIGITAL PRINCIPLES AND LOGIC DESIGN
5.11.1  Some Applications of Decoders
As we have seen that decoders give multiple outputs equivalent to the minterms 
corresponding to the input variables, it is obvious that any Boolean expression in the sum of 
the products form can be very easily implemented with the help of decoders. It is not necessary 
to obtain the minimized expression through simplifying procedures like a Karnaugh map, or 
tabulation method, or any other procedure. It is sufﬁ cient to inspect the minterm contents 
of a function from the truth table, or the canonical form of sum of the products of a Boolean 
expression and selected minterms obtained from the output lines of a decoder may be simply 
OR-gated to derive the required function. The following examples will demonstrate this.
Example 5.7. Implement the function F (A,B,C) = Σ (1,3,5,6).
Solution. Since the above function has three input variables, a 3-to-8 line decoder may 
be employed. It is in the sum of the products of the minterms m1, m3, m5, and m6, and so 
decoder output D1, D3, D5, and D6 may be OR-gated to achieve the desired function. The 
combinational circuit of the above functions is shown in Figure 5.62.
Figure 5.62
Figure 5.63
Example 5.8. Design a full adder circuit with decoder IC.
Solution. We have seen that full adder circuits are implemented with logic gates in 
Section 5.3.2. This can be very easily implemented with the help of a decoder IC. Observe 
the truth table of a full adder in Figure 5.4. In respect to minterms, the Boolean expression 
of sum output S and carry output C can be written as:
A
B
C
E N
3-TO -8
D EC O D ER
LO G IC  1
F
D
D
D
D
D
D
D
7
6
5
4
3
2
1
D 0
A
B
C
E N
3-TO -8
D EC O D ER
LO G IC  1
B
A
X
S
C
D
D
D
D
D
D
D
7
6
5
4
3
2
1
D 0

COMBINATIONAL LOGIC CIRCUITS 171
 
 
S = X′A′B + X′AB′ + XA′B′ + XAB 
 
and
 
 
C = X′AB + XA′B + XAB′ + XAB.
The above expression can be realized in Figure 5.63.
Example 5.9. Similarly, a full-subtractor as described at Section 5.4.2 can be developed 
with the help of decoder. From the truth table in Figure 5.10 the Difference D and Borrow 
B outputs may be written as
 
 
D = X′Y′Z + X′YZ′ + XY′Z′ + XYZ 
 
and
 
 
B = X′Y′Z + X′YZ′ + X′YZ + XYZ.
The combinational circuit with decoder is shown in Figure 5.64.
Figure 5.64
Example 5.10. Design a BCD-to-decimal decoder with the use of a decoder.
Solution. BCD code uses four bits to represent its different numbers from 0 to 9. So 
the decoder should have four input lines and ten output lines. By simple method a BCD-
to-decimal coder may use a 4-to-16 line decoder. But at output, six lines are illegal and 
they are deactivated with the use of AND gates or any other means. However, a 3-to-8 line 
decoder may be employed for this purpose with its intelligent utilization. A partial truth 
table of a BCD-to-decimal decoder is shown in Figure 5.65.
Input variables 
Output 
 
A 
B 
C 
D 
D0 
D1 
D2 
D3 
D4 
D5 
D6 
D7 
D8 
D9
 
0 
0 
0 
0 
1 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
0 
1 
0 
1 
0 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
1 
0 
0 
0 
1 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
1 
1 
0 
0 
0 
1 
0 
0 
0 
0 
0 
0 
 
0 
1 
0 
0 
0 
0 
0 
0 
1 
0 
0 
0 
0 
0 
 
0 
1 
0 
1 
0 
0 
0 
0 
0 
1 
0 
0 
0 
0 
 
0 
1 
1 
0 
0 
0 
0 
0 
0 
0 
1 
0 
0 
0 
 
0 
1 
1 
1 
0 
0 
0 
0 
0 
0 
0 
1 
0 
0 
 
1 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
1 
0 
 
1 
0 
0 
1 
0 
0 
0 
0 
0 
0 
0 
0 
0 
1
Figure 5.65
A
B
C
E N
3-TO -8
D EC O D ER
LO G IC  1
Z
Y
X
D
B
D
D
D
D
D
D
D
7
6
5
4
3
2
1
D 0

172
DIGITAL PRINCIPLES AND LOGIC DESIGN
Since the circuit has ten outputs, ten Karnaugh maps are drawn to simplify each one 
of the outputs. However, it would be useful to construct a single map similar to a Karnaugh 
map indicating the outputs and don’t-care conditions as in Figure 5.66. It can be seen that 
pairs and groups may be formed considering the don’t-care conditions.
The Boolean expressions of the different outputs may be written as
 
 
D0 = A′B′C′D′,  D1 = A′B′C′D,  
D2 = B′CD′,
 
 
D3 = B′CD, 
 
D4 = BC′D′, 
 
 
D5 = BC′D,
 
 
D6 = BCD′, 
 
D7 = BCD,  
 
 
D8 = AD′.
 
 
and  
 
 
D9 = AD.
 
 
 
C′D′ 
C′D 
CD 
CD′
 
 
A′B′ 
D0 
D1 
D3 
D2
 
 
A′B 
D4 
D5 
D7 
D6  
 
 
 
 
 
 
AB 
X 
X 
X 
X  
 
 
 
 
 
 
AB′ 
D8 
D9 
X 
X  
 
 
 
 
Figure 5.66
Figure 5.67
Figure 5.67 illustrates the complete circuit diagram of a BCD decoder implemented 
with a 3-to-8 decoder IC, with B, C, and D as input lines to the decoder.
B
A
C
D
E N
3-TO -8
D EC O D ER
LO G IC  1
D
D
D
D
D
D
D
7
6
5
4
3
2
1
D 0
D
D
D
9
8
0
D
D
D
D
D
D
D
7
6
5
4
3
2
1

COMBINATIONAL LOGIC CIRCUITS 173
Example 5.11. Construct a 3-to-8 line decoder with the use of a 2-to-4 line decoder.
Figure 5.68
Solution. Lower order decoders can be cascaded to build higher order decoders. Normally 
every commercially available decoder ICs have a special input other than normal working 
input variables called ENABLE. The use of this ENABLE input is that when activated the 
complete IC comes to the working condition for its normal functioning. If ENABLE input 
is deactivated the IC goes to sleep mode, the normal functioning is suspended, and all the 
outputs become logic 0 irrespective of normal input variables conditions. This behavior of 
ENABLE input makes good use of a cascade connection as in Figure 5.69 where a 3-to-8 
line decoder is demonstrated with a 2-to-4 line decoder. Here input variables are designated 
as X, Y, and Z, and outputs are denoted as Q0 to Q7. X input is connected to the ENABLE 
input of one decoder and X is used as an ENABLE input of another decoder. When X is 
logic 0, a lower decoder is activated and gives output Q0 to Q3 and an upper decoder is 
activated for X is logic 1, output Q4 to Q7 are available this time.
Figure 5.69
A
A
Y
B
B
Z
X
E N
E N
2-T O -4
D E C O D E R  
2-T O -4
D E C O D E R  
Q
Q
Q
Q
7
6
5
4
D
D
D
3
2
1
0
D
D
D
D
3
2
1
0
D
Q
Q
Q
Q
3
2
1
0
X
Y
Z
W
E N
E N
D  TO D
8
15
D  TO D
0
7
3-TO-8
DECODER
3-TO-8
DECODER

174
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 5.12. Construct a 4-to-16 line decoder using a 3-to-8 line decoder.
Solution. A 4-to-16 line decoder has four input variables and sixteen outputs, whereas 
a 3-to-8 line decoder consists of three input variables and eight outputs. Therefore, one of 
the input variables is used as the ENABLE input as demonstrated in Example 5.11. Two 
3-to-8 line decoders are employed to realize a 4-to-16 line decoder as shown in Figure 5.69. 
Input variables are designated as W, X, Y, and Z. W input is used as the ENABLE input 
of the upper 3-to-8 line decoder, which provides D8 to D16 outputs depending on other input 
variables X, Y, and Z. W is also used as an ENABLE input at inverted mode to a lower 
decoder, which provides D0 to D7 outputs.
5.12  ENCODERS
An encoder is a combinational network that performs the reverse operation of the decoder. 
An encoder has 2n or less numbers of inputs and n output lines. The output lines of an 
encoder generate the binary code for the 2n input variables. Figure 5.70 illustrates an eight 
inputs/three outputs encoder. It may also be referred to as an octal-to-binary encoder where 
binary codes are generated at outputs according to the input conditions. The truth table is 
given in Figure 5.71.
Figure 5.70
Inputs 
  Outputs
 
D0 
D1 
D2 
D3 
D4 
D5 
D6 
D7 
A 
B 
C
 
1 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
0 
1 
0 
0 
0 
0 
0 
0 
0 
0 
1 
 
0 
0 
1 
0 
0 
0 
0 
0 
0 
1 
0 
 
0 
0 
0 
1 
0 
0 
0 
0 
0 
1 
1 
 
0 
0 
0 
0 
1 
0 
0 
0 
1 
0 
0 
 
0 
0 
0 
0 
0 
1 
0 
0 
1 
0 
1 
 
0 
0 
0 
0 
0 
0 
1 
0 
1 
1 
0 
 
0 
0 
0 
0 
0 
0 
0 
1 
1 
1 
1 
Figure 5.71
A = D  + D  + D  + D
4
5
6
7
B = D  + D  + D  + D
2
3
6
7
C = D  + D  + D  + D
1
3
5
7
D
D
D
D
D
D
D
0
1
2
3
4
5
6
D 7

COMBINATIONAL LOGIC CIRCUITS 175
The encoder in Figure 5.70 assumes that only one input line is activated to logic 1 at 
any particular time,  otherwise the other circuit has no meaning. It may be noted that for 
eight inputs there are a possible 28 = 256 combinations, but only eight input combinations 
are useful and the rest are don’t-care conditions. It may also be noted that D0 input is not 
connected to any of the gates. All the binary outputs A, B, and C must be all 0s in this 
case. All 0s output may also be obtained if all input variables D0 to D7 are logic 0. This 
is the main discrepancy of this circuit. This discrepancy can be eliminated by introducing 
another output indicating the fact that all the inputs are not logic 0.
However, this type of encoder is not available in an IC package because it is not easy to 
implement with OR gates and not much of the gates are used. The type of encoder available 
in IC package is called a priority encoder. These encoders establish an input priority to 
ensure that only highest priority input is encoded. As an example, if both D2 and D4 inputs 
are logic 1 simultaneously, then output will be according to D4 only i.e., output is 100.
5.13  MULTIPLEXERS OR DATA SELECTORS
A multiplexer is one of the important combinational circuits and has a wide range of 
applications. The term multiplex means “many into one.” Multiplexers transmit large 
numbers of information channels to a smaller number of channels. A digital multiplexer is 
a combinational circuit that selects binary information from one of the many input channels 
and transmits to a single output line. That is why the multiplxers are also called data
selectors. The selection of the particular input channel is controlled by a set of select inputs. 
A digital multiplexer of 2n input channels can be controlled by n numbers of select lines 
and an input line is selected according to the bit combinations of select lines.
Selection Inputs 
Input Channels 
Output 
 
S1 
S0 
I0 
I1 
I2 
I3 
Y 
 
0 
0 
0 
X 
X 
X 
0 
 
0 
0 
1 
X 
X 
X 
1 
 
0 
1 
X 
0 
X 
X 
0 
 
0 
1 
X 
1 
X 
X 
1 
 
1 
0 
X 
X 
0 
X 
0 
 
1 
0 
X 
X 
1 
X 
1 
 
1 
1 
X 
X 
X 
0 
0 
 
1 
1 
X 
X 
X 
1 
1
Figure 5.72
A 4-to-1 line multiplexer is deﬁ ned as the multiplexer consisting of four input channels 
and information of one of the channels can be selected and transmitted to an output line 
according to the select inputs combinations. Selection of one of the four input channels is 
possible by two selection inputs. Figure 5.72 illustrates the truth table. Input channels I0,
I1, I2, and I3 are selected by the combinations of select inputs S1 and S0. The circuit diagram 
is shown in Figure 5.73. To demonstrate the operation, let us consider that select input 
combination S1S0 is 01. The AND gate associated with I1 will have two of inputs equal to 
logic 1 and a third input is connected to I1. Therefore, output of this AND gate is according 

176
DIGITAL PRINCIPLES AND LOGIC DESIGN
to the information provided by channel I1. The other three AND gates have logic 0 to at least 
one of their inputs which makes their outputs to logic 0. Hence, OR output (Y) is equal to 
the data provided by the channel I1. Thus, information from I1 is available at Y. Normally 
a multiplexer has an ENABLE input to also control its operation. The ENABLE input (also 
called STROBE) is useful to expand two or more multiplexer ICs to a digital multiplexer 
with a larger number of inputs, which will be demonstrated in a later part of this section. 
A multiplexer is often abbreviated as MUX. Its block diagram is shown in Figure 5.74.
Figure 5.73
If the multiplexer circuit is inspected critically, it may be observed that the multiplexer 
circuit resembles the decoder circuit and indeed the n select lines are decoded to 2n lines 
which are ANDed with the channel inputs. Figure 5.75 demonstrates how a decoder is 
employed to form a 4-to-1 multiplexer.
Figure 5.74
In some cases two or more multiplexers are accommodated within one IC package. The 
selection and ENABLE inputs in multiple-unit ICs may be common to all multiplexers.
Y
I
I
I
I
0
1
2
3
S
S
1
0
E N
Y
I
I
I
0
1
2
I3
S1
S 0
4-to-1
M ULTIPLEXER

COMBINATIONAL LOGIC CIRCUITS 177
Figure 5.75 
Figure 5.76
Y
I
I
I
I
3
2
1
0
S
S
1
0
D 3
D
D
D
2
1
0
2-to-4
M ULTIPLEXER
EN
EN
A1
A
A
A
2
3
4
B
B
B
B
2
3
4
1
S
(Select)
Y
Y
Y
Y
2
3
4
1

178
DIGITAL PRINCIPLES AND LOGIC DESIGN
The internal circuit diagram of a quadruple 2-to-1 multiplexer IC is illustrated in 
Figure 5.76. It has four multiplexers, each capable of selecting one of two input lines. 
Either of the inputs A1 or B1 may be selected to provide output at Y1. Similarly, Y2 may 
have the value of A2 or B2 and so on. One input selection line S is sufﬁ cient to perform the 
selection operation of one of the two input lines in all four multiplexers. The control input 
EN enables the multiplexers for their normal function when it is at logic 0 state, and all 
the multiplexers suspend their functioning when EN is logic 1.
A function table is provided in Figure 5.77. When EN = 1, all the outputs are logic 0, 
irrespective of any data at inputs I0, I1, I2, or I4. When EN = 0, all the multiplexers become 
activated, outputs possess the A value if S = 0 and outputs are equal to data at B if S = 1.
E 
S 
Output Y 
 
1 
X 
All 0’s 
 
0 
0 
Select A 
 
0 
1 
Select B 
Figure 5.77
5.13.1  Cascading of Multiplexers
As stated earlier, multiplexers of a larger number of inputs can be implemented by 
the multiplexers of a smaller number of input lines. Figure 5.78 illustrates that an 8-to-1 
line multiplexer is realized by two 4-to-1 line multiplexers.
Figure 5.78
A
B
C
Y
F
X
X
X
0
1
2
X3
I
I
I
0
1
2
I3
S1
S0
4-to-1
M UX
EN
X
X
X
4
5
6
X7
I
I
I
0
1
2
I3
S1
EN
S0
4-to-1
M UX

COMBINATIONAL LOGIC CIRCUITS 179
Here, variables B and C are applied to select inputs S1 and S0 of both multiplexers whereas 
the ENABLE input of the upper multiplexer is connected to A and the lower multiplexer is 
connected to A. So for A = 0, the upper multiplexer is selected and input lines X0 to X3 are 
selected according to the selected inputs and data is transmitted to an output through the 
OR gate. When A = 1, the lower multiplexer is activated and input lines X4 to X7 are selected 
according to the selected inputs.
Similarly, a 16-to-1 multiplexer may be developed by two 8-to-1 multiplexers as shown 
in Figure 5.79. Alternatively, a 16-to-1 multiplxer can be realized with ﬁ ve 4-to-1 multiplexers 
as shown in Figure 5.80.
Figure 5.79
The multiplexer is a very useful MSI function and has various ranges of applications in 
data communication. Signal routing and data communication are the important applications 
of a multiplexer. It is used for connecting two or more sources to guide to a single destination 
among computer units and it is useful for constructing a common bus system. One of the 
general properties of a multiplexer is that Boolean functions can be implemented by this 
device, which will be demonstrated here.
EN S 2 S1
I
I
I
I
I
I
I
I
0
1
2
3
4
5
6
7
8-to-1
M UX
Y
S0
IN PUTS
X  TO X
0
7
S 2 S1
I
I
I
I
I
I
I
I
0
1
2
3
4
5
6
7
8-to-1
M UX
Y
S0
IN PUTS
X  TO X
8
15
A
B
C
D

180
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.80
4-TO-1
M UX
X
X
X
X
0
1
2
3
I
I
I
0
1
2
3
I
EN
S1 S0
4-TO-1
M UX
X
X
X
X
4
5
6
7
I
I
I
0
1
2
3
I
EN
S1 S0
4-TO-1
M UX
X
X
X
X
8
9
10
11
I
I
I
0
1
2
3
I
EN S 1 S 0
4-TO-1
M UX
X
X
X
X
12
13
14
15
I
I
I
0
1
2
3
I
EN S 1 S 0
4-TO-1
M UX
A
B
C
D
I
I
I
0
1
2
3
I EN S 1 S0
Y
Y
Y
F
Y

COMBINATIONAL LOGIC CIRCUITS 181
5.13.2  Boolean Function Implementation
In the previous section it was shown that decoders are employed to implement the Boolean 
functions by incorporating an external OR gate. It may be observed that multiplexers are 
constructed with decoders and OR gates. The selection of minterm outputs of the decoder can 
be controlled by the input lines. Hence, the minterms included in the Boolean function may 
be chosen by making their corresponding input lines to logic 1. The minterms not needed for 
the function are disabled by making their input lines equal to logic 0. By this method Boolean 
functions of n variables can be very easily implemented by using a 2n-to-1 multiplexer. However, 
a better approach may be adopted with the judicious use of the function variables.
If a Boolean function consists of n+1 number of variables, n of these variables may be used 
as the select inputs of the multiplexer. The remaining single variable of the function is used as 
the input lines of the multiplexer. If X is the left-out variable, the input lines of the multiplexer 
may be chosen from four possible values, - X, X′, logic 1, or logic 0. It is possible to implement 
any Boolean function with a multiplexer by intelligent assignment of the above values to input 
lines and other variables to selection lines. By this method a Boolean function of n+1 variables 
can be implemented by a 2n-to-1 line multiplexer. Assignment of values to the input lines can 
be made through a typical procedure, which will be demonstrated by the following examples.
Example 5.13. Implement the 3-variable function F(A,B,C) = (0,2,4,7) with a multiplexer.
Solution. Here the function has three variables, A, B, and C and can be implemented 
by a 4-to-1 line multiplexer as shown in Figure 5.82. Figure 5.81 presents the truth table of 
the above Boolean function. Two of the variables, say B and C, are connected to the selection 
lines S1 and S0 respectively. When both B and C are 0, I0 is selected. At this time, the output 
required is logic 1, as both the minterms m0 (A′B′C′) and m4 (AB′C′) produce output logic 1 
regardless of the input variable A, so I0 should be connected to logic 1. When select inputs 
BC=01, I1 is selected and it should be connected to logic 0 as the corresponding minterms 
m1 (A′B′C) and m5 (AB′C) both produce output 0. For select inputs BC = 10, I2 is selected 
and connected to variable A′, as only one minterm m2 (A′BC′) associated with A′ produce 
output logic 1, whereas the minterm m6 (ABC′) associated with A produces output 0. And 
ﬁ nally, I3 is selected and connected to variable A, when select inputs BC = 11, because only 
the minterm m7 (ABC) produce output 1, whereas output is 0 for the mintrem m3 (A′BC).
Multiplexer must be in ENABLE mode to be at its working condition. Hence EN input is 
connected to logic 1. 
Minterms 
A 
B 
C 
F
 
0 
0 
0 
0 
1 
 
 
1 
0 
0 
1 
0 
 
 
2 
0 
1 
0 
1 
 
 
3 
0 
1 
1 
0 
 
 
4 
1 
0 
0 
1 
 
 
5 
1 
0 
1 
0 
 
 
6 
1 
1 
0 
0 
 
 
7 
1 
1 
1 
1
             Figure 5.81  
 
 
Figure 5.82
I
I
I
0
1
2
3
I
EN
Y
S 1
S0
4-TO-1
M ULTIPLEXER
F
1
0
A
A
′
1
B
C

182
DIGITAL PRINCIPLES AND LOGIC DESIGN
The above analysis describes how a Boolean function can be implemented with the help 
of multiplexers. However, there is a general procedure for the implementation of Boolean 
functions of n variables with a 2n-1-to-1 multiplexer.
First, the function is expressed in its sum of the minterms form. Assume that the most 
signiﬁ cant variables will be used at input lines and the other n–1 variables will be connected 
to selection lines of the multiplexer in ordered sequence. This means the lowest signiﬁ cant 
variable is connected to S0 input, the next higher signiﬁ cant variable is connected to S1, the 
next higher variable to S2, and so on. Now consider the single variable A. Since this variable 
represents the highest order position in the sequence of variables, it will be at complemented 
form in the minterms 0 to 2n-1, which comprises the ﬁ rst half of the list of minterms. The 
variable A is at uncomplemented form in the second half of the list of the minterms. For a 
three-variable function like Example 5.13, among the possible eight minterms, A is complemented 
for the minterms 0 to 3 and at uncomplemented form for the minterms 4 to 7.
An implementation table is now formed, where the input designations of the multiplexer 
are listed in the ﬁ rst row. Under them the minterms where A is at complemented form are 
listed row-wise. At the next row other minterms of A at uncomplemented form are listed. 
Circle those minterms that produce output to logic 1.
 
 If the two elements or minterms of a column are not circled, write 0 under that 
column.
 
 If both the two elements or minterms of a column are circled, write 1 under that 
column.
 
 If the upper element or minterm of a column is circled but not the bottom, write A′
under that column.
 
 If the lower element or minterm of a column is circled but not the upper one, write 
A under that column.
 
 The lower most row now indicates input behavior of the corresponding input lines of 
the multiplexer as marked at the top of the column.
The above procedure can be more clearly understood if we consider Example 5.13 again. 
Since this function can be implemented by a multiplexer, the lower signiﬁ cant variables B 
and C are applied to S1 and S0 respectively. The inputs of multiplexer I0 to I3 are listed at 
the uppermost row. A′ and its corresponding minterms 0 to 3 are placed at the next row. 
Variable A and the rest of the minterms 4 to 7 are placed next as in Figure 5.83. Now circle 
the minterms 0, 2, 4, and 7 as these minterms produce logic 1 output.
Figure 5.83
From Figure 5.83, it can seen that both the elements of the ﬁ rst column 0 and 4 
are circled. Therefore, ‘1’ is placed at the bottom of that column. At the second column no 
elements are circled and so ‘0’ is placed at the bottom of the column. At the third column 
only ‘2’ is circled. Its corresponding variable is A′ and so A′ is written at the bottom of this 
0
1
2
3
I0
I1
I2
I3
A′
4
5
6
7
1
0
A′
A
A

COMBINATIONAL LOGIC CIRCUITS 183
column. And ﬁ nally, at the fourth column only ‘7’ is circled and A is marked at the bottom of 
the column. The muxltiplexer inputs are now decided as I0 =1, I1 =0, I2 = A′, and I3 = A.
Figure 5.84
Figure 5.85
It may be noted that it is not necessary to reserve the most signiﬁ cant variable for 
use at multiplexer inputs. Example 5.13 may also be implemented if variable C is used 
at multiplexer inputs and, A and B are applied to selection inputs S1 and S0 respectively. 
In this case the function table is modiﬁ ed as in Figure 5.84 and circuit implementation is 
shown in Figure 5.85. Note that the places of minterms are changed in the implementation 
table in Figure 5.84 due to the change in assignment of selection inputs.
It should also be noted that it is not always necessary to assign the most signiﬁ cant 
variable or the least signiﬁ cant variable out of n variables to the multiplexer inputs and 
the rest to selection inputs. It is also not necessary that the selection inputs are connected 
in order. However, these types of connections will increase the complexities at preparation 
of an implementation table as well as circuit implementation.
Multiplexers are employed at numerous applications in digital systems. They 
are used immensely in the ﬁ elds of data communication, data selection, data routing, 
operation sequencing, parallel-to-serial conversion, waveform generation, and logic function 
implementation.
Example 5.14. Implement the following function using a multiplexer.
 
 
F(A, B, C) =   (1, 3, 5, 6)
Solution. The given function contains three variables. The function can be realized by 
one 4-to-1 multiplexer. The implementation table is shown in Figure 5.86 and the circuit 
diagram is given in Figure 5.87.
0
2
4
6
I0
I1
I2
I3
C′
1
3
5
7
C′
C′
C′
C
C
F
C
I
I
I
0
1
2
3
I
EN S1
S 0
4-TO-1
M ULTIPLEXER
1
B
C

184
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
Figure 5.86 
                                     Figure 5.87 
Example 5.15. Implement the following function with a multiplexer.
 
 
 
F (A, B, C, D) =   (0, 1, 3, 4, 8, 9, 15)
Solution. The given function contains four variables. The function can be realized by 
one 8-to-1 multiplexer. The implementation table is shown in Figure 5.88 and the circuit 
diagram is given in Figure 5.89.
Figure 5.88
Figure 5.89
0
1
2
3
I0
I1
I2
I3
A'
4
5
6
7
0
1
A
A'
A
F
I
I
I
0
1
2
3
I
EN S1
S0
A
B
C
4-TO-1
M ULTIPLEXER
5v
0
4
1
5
2
6
3
7
I0
I4
I1
I5
I2
I6
I3
I7
A′
8
12
9
13
10
14
11
15
1
A′
1
0
0
0
A′
A
A
F
I
I
I
0
1
2
3
I
EN S1
S0
A
B
C
4-TO-1
M ULTIPLEXER
5v

COMBINATIONAL LOGIC CIRCUITS 185
Example 5.16. Implement a BCD-to-seven segment decoder with multiplexers.
Solution. A BCD-to-seven segment decoder is already described by classical approach and 
realized with simple gates. The same circuit can be realized with the help of multiplexers. The 
truth table of a BCD-to-seven segment decoder (for common cathode type) is repeated here at 
Figure 5.90 for convenience. As there are four input variables, 4-to-1 multiplexers are employed 
to develop the combinational logic circuit. Implementation tables for each of the outputs a to g 
are shown in Figures 5.91(a)-(g). The logic diagram implementation of a BCD-to-seven segment 
decoder with 4-to-1 multiplexers is shown in Figure 5.92. Note that don’t-care combinations 
(X) are judiciously considered as logic 1 or logic 0 in the implementation table.
Decimal 
Input Variables 
Output Variables as Seven Segment Display 
 Numbers 
A 
B 
C 
D 
a 
b 
c 
d 
e 
f 
g 
 
0 
0 
0 
0 
0 
1 
1 
1 
1 
1 
1 
0 
 
1 
0 
0 
0 
1 
0 
1 
1 
0 
0 
0 
0 
 
2 
0 
0 
1 
0 
1 
1 
0 
1 
1 
0 
1 
 
3 
0 
0 
1 
1 
1 
1 
1 
1 
0 
0 
1 
 
4 
0 
1 
0 
0 
0 
1 
1 
0 
0 
1 
1 
 
5 
0 
1 
0 
1 
1 
0 
1 
1 
0 
1 
1 
 
6 
0 
1 
1 
0 
0 
0 
1 
1 
1 
1 
1 
 
7 
0 
1 
1 
1 
1 
1 
1 
0 
0 
0 
0 
 
8 
1 
0 
0 
0 
1 
1 
1 
1 
1 
1 
1 
 
9 
1 
0 
0 
1 
1 
1 
1 
0 
0 
1 
1
Figure 5.90 (For a common cathode display.)
Figure 5.91(a)  For a.
Figure 5.91(b)  For b.
0
4
1
5
2
6
3
7
I0
I4
I1
I5
I2
I6
I3
A′
8
12
9
13
10
14
11
15
1
0
X
A
1
X
1
X
0
X
1
X
1
X
A
0
4
1
5
2
6
3
7
A′
8
12
9
13
10
14
11
15
1
1
X
1
0
X
1
X
0
X
1
X
1
X
A
I0
I4
I1
I5
I2
I6
I3

186
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 5.91(c)  For c.
Figure 5.91(d)  For d.
Figure 5.91(e)  For e.
Figure 5.91(f)  For f.
Figure 5.91(g) For g.
0
4
1
5
2
6
3
7
A′
8
12
9
13
10
14
11
15
1
1
X
1
1
X
0
X
1
X
1
X
1
X
A
I0
I4
I1
I5
I2
I6
I3
0
4
1
5
2
6
3
7
A′
8
12
9
13
10
14
11
15
1
0
X
0
1
X
1
X
1
X
1
X
0
X
A
I0
I4
I1
I5
I2
I6
I3
0
4
1
5
2
6
3
7
A′
8
12
9
13
10
14
11
15
1
0
X
0
0
X
1
X
1
X
0
X
0
X
A
I0
I4
I1
I5
I2
I6
I3
0
4
1
5
2
6
3
7
A′
8
12
9
13
10
14
11
15
1
1
X
A
1
X
0
X
1
X
0
X
0
X
A
I0
I4
I1
I5
I2
I6
I3
0
4
1
5
2
6
3
7
A′
8
12
9
13
10
14
11
15
A
1
X
A
1
X
1
X
1
X
1
X
0
X
A
I0
I4
I1
I5
I2
I6
I3

COMBINATIONAL LOGIC CIRCUITS 187
Figure 5.92
A B C
D
LOGIC 1
I7 I6 I5 I4 I3I2 I1 I0
EN
S2
S1
S0
8 : 1
M UX
Y
a
I7 I6 I5 I4 I3I2 I1 I0
EN
S2
S1
S0
8 : 1
M UX
Y
b
I7 I6 I5 I4 I3I2 I1 I0
EN
S2
S1
S0
8 : 1
M UX
Y
c
I7 I6 I5 I4 I3I2 I1 I0
EN
S2
S1
S0
8 : 1
M UX
Y
d
I7 I6 I5 I4 I3I2 I1 I0
EN
S2
S1
S0
8 : 1
M UX
Y
e
I7 I6 I5 I4 I3I2 I1 I0
EN
S 2
S 1
S 0
8 : 1
M UX
Y
f
I7 I6 I5 I4 I3I2 I1 I0
EN
S 2
S 1
S 0
8 : 1
M UX
Y
g
LOGIC 0

188
DIGITAL PRINCIPLES AND LOGIC DESIGN
5.14  DEMULTIPLEXERS OR DATA DISTRIBUTORS
The term “demultiplex” means one into many. Demultiplexing is the process that receives 
information from one channel and distributes the data over several channels. It is the reverse 
operation of the multiplexer. A demultiplexer is the logic circuit that receives information 
through a single input line and transmits the same information over one of the possible 2n
output lines. The selection of a speciﬁ c output line is controlled by the bit combinations of 
the selection lines. 
Selection Inputs 
Outputs 
 
A 
B 
C 
Y0 
Y1 
Y2 
Y3 
Y4 
Y5 
Y6 
Y7
 
0 
0 
0 
Y0 = I 
0 
0 
0 
0 
0 
0 
0 
 
0 
0 
1 
0 
Y1 = I 
0 
0 
0 
0 
0 
0 
 
0 
1 
0 
0 
0 
Y2 = I 
0 
0 
0 
0 
0 
 
0 
1 
1 
0 
0 
0 
Y3 = I 
0 
0 
0 
0 
 
1 
0 
0 
0 
0 
0 
0 
Y4 = I 
0 
0 
0 
 
1 
0 
1 
0 
0 
0 
0 
0 
Y5 = I 
0 
0 
 
1 
1 
0 
0 
0 
0 
0 
0 
0 
Y6 = I 
0 
 
1 
1 
1 
0 
0 
0 
0 
0 
0 
0 
Y7 = I
Figure 5.93
 
 
     Figure 5.94 
 
 
 
     Figure 5.95
A
B
C
Y 7
Y 6
Y 5
Y 4
Y 3
Y 2
Y 1
Y 0
I
1-to-8
DEM UX
Y
Y
Y
Y
Y
Y
Y
Y
7
6
5
4
3
2
1
0
I
S2 S1 S0

COMBINATIONAL LOGIC CIRCUITS 189
A 1-to-8 demultiplexer circuit is demonstrated in Figure 5.94. The selection input 
lines A, B, and C activate an AND gate according to its bit combination. The input line 
I is common to one of the inputs of all the AND gates. So information of I passed to the 
output line is activated by the particular AND gate. As an example, for the selection input 
combination 000, input I is transmitted to Y0. A truth table is prepared in Figure 5.93 to 
illustrate the relation of selection inputs and output lines. The demultiplexer is symbolized 
in Figure 5.95 where S2, S1, and S0 are the selection inputs.
It may be noticed that demultiplexer circuits may be derived from a decoder with the 
use of AND gates. As we have already seen, decoder outputs are equivalent to the minterms, 
these minterms can be used as the selection of output lines, and when they are ANDed with 
input line I, the data from input I is transmitted to output lines as activated according to 
the enabled minterms. Figure 5.96 demonstrates the construction of a 1-to-4 demultiplexer 
with a 2-to-4 decoder and four AND gates.
Figure 5.96
Figure 5.97
Like decoders and multiplexers, demultiplexers can also be cascaded to form higher 
order demultiplexers. Figure 5.97 demonstrates how a 1-to-8 demultiplexer can be formed 
I
E N
A
B
2-TO-4
DECODER
D
D
D
D
3
2
1
0
Y
Y
Y
3
2
1
0
Y
LOGIC  1
I
A
B
C
D
D
D
D
7
6
5
4
Y
Y
Y
3
2
1
0
Y
EN
1-to-4
DEM UX
I
S 1
S0
D
D
D
D
3
2
1
0
Y
Y
Y
3
2
1
0
Y
EN
1-to-4
DEM UX
I
S 1
S0

190
DIGITAL PRINCIPLES AND LOGIC DESIGN
with two 1-to-4 demultiplexers. Here, the highest signiﬁ cant bit A of the selection inputs is 
connected to the ENABLE inputs, one directly and the other one is complemented. When A 
is logic 0, one of the output lines D0 to D3 will be selected according to selection inputs B 
and C, and when A is logic 1, one of the output lines D4 to D7 will be selected.
5.15  CONCLUDING REMARKS
Various design methods of combinational circuits are described in this chapter. It is also 
illustrated and demonstrated that a number of SSI and MSI circuits can be used while 
designing more complicated digital systems. More complicated digital systems can be realized 
with LSI circuits, which will be discussed in Chapter 6.
The MSI functions discussed here are also described in the data books and catalog 
along with other commercially available ICs. IC data books contain exact descriptions of 
many MSI and other integrated circuits.
There are varieties of applications of combinational circuits in SSI or MSI or LSI form. 
A resourceful designer ﬁ nds many applications to suit their particular needs. Manufactures 
of integrated circuits publish application notes to suggest the possible utilization of their 
products.
REVIEW QUESTIONS
 5.1 What is a half-adder? Write its truth table.
5.2 Design a half-adder using NOR gates only.
5.3 What is a full-adder? Draw its logic diagram with basic gates.
5.4 Implement a full-adder circuit using NAND gates only.
5.5 Implement a full-adder circuit using NOR gates only.
5.6 What is the difference between a full-adder and full-subtractor?
5.7 Construct a half-subtractor using (a) basic gates, (b) NAND gates, and (c) NOR gates.
5.8 Construct a full-subtractor using (a) basic gates, (b) NAND gates, and (c) NOR gates.
5.9 Show a full-adder can be converted to a full-subtractor with the addition of an INVERTER.
5.10 Design a logic diagram for an addition/subtraction circuit, using a control variable P such that 
this operates as a full-adder when P = 0 and as a full-subtractor for P = 1.
5.11 What is a decoder? Explain a 3-to-8 decoder with logic diagram.
5.12 What is a priority encoder?
5.13 Can more than one output be activated for a decoder? Justify the answer.
5.14 Design a 4-bit binary subtractor using a 4-bit adder and INVERTERs.
5.15 What is a look ahead carry generator? What is its importance? Draw a circuit for a 3-bit binary 
adder using a look ahead carry generator and other gates.
5.16 What is a magnitude comparator?
5.17 What is a multiplexer? How is it different from a decoder?
5.18 How are multiplexers are useful in developing combinational circuits?
5.19 What is the function of enable input(s) for a decoder?

COMBINATIONAL LOGIC CIRCUITS 191
5.20 What are the major applications of multiplexers?
5.21 Design a combinational circuit for a BCD-to-gray code using (a) standard logic gates, (b) decoder, 
(c) 8-to-1 multiplexer, and (d) 4-to-1 multiplexer.
5.22 Design a combinational circuit for a gray-to-BCD code using (a) standard logic gates, (b) decoder, 
(c) 8-to-1 multiplexer, and (d) 4-to-1 multiplexer.
5.23 A certain multiplexer can switch one of 32 data inputs to output. How many different inputs 
does this MUX have?
5.24 An 8-to-1 MUX has inputs A, B, and C connected to selection lines S2, S1, and S0 respectively. 
The data inputs I0 to I7 are connected as I1 = I2 = I7 = 0, I3 = I5 = 1, I0 = I4 = D, and I6 = D'. 
Determine the Boolean expression of the MUX output.
5.25  Design an 8-bit magnitude comparator using 4-bit comparators and other gates.
5.26 Implement the Boolean function F(A, B, C, D) = Σ ( 1, 3, 4, 11, 12, 13, 15) using (a) decoder 
and external gates, and (b) 8-to-1 MUX and external gates.
5.27 Is it possible to implement the Boolean function of problem 5.26 using one 4-to-1 MUX and 
external gates?
5.28 Design an Excess-3-to-8421 code converter using a 4-to-16 decoder with enable input E' and 
associated gates.
5.29 Repeat problem 5.28 using 8-to-1 multiplexers.
❑ ❑ ❑


193
6.1  INTRODUCTION
I
n Chapter 5, we discussed various combinational circuits that are commercially available 
in IC packages. We also saw how other combinational circuits and Boolean functions are 
realized with the help of these commercially available IC packages. With the advent of 
large-scale integration technology, it has become feasible to fabricate large circuits within 
a single chip. One such consequence of this technology is the Programmable Logic Devices
or PLDs.
The advantages of using programmable logic devices are:
 
 1. Reduced space requirements.
 
 2. Reduced power requirements.
 
 3. Design security.
 
 4. Compact circuitary.
 
 5. Short design cycle.
 
 6. Low development cost.
 
 7. Higher switching speed.
 
 8. Low production cost for large-quantity production.
In earlier chapters, we have seen that any Boolean function or combinational circuit 
can be  represented by sum of the products form or sum of the required minterms. It was 
also shown that a decoder generates 2n  minterms  for  n number of input variables and 
required minterm outputs of a decoder are fed to an OR gate to obtain a desired function. 
This fact leads to the development of IC packages with larger integration that contain 
decoders with a number of OR gates or one single chip containing a large number of basic 
gates—AND, OR, and NOT. These ICs are programmed according to desired functions by 
the manufacturers or the designers. Another advantage of employing these ICs is that one 
single IC can generate multiple outputs, thus reducing the board space, interconnections, 
and power consumption.
PROGRAMMABLE
LOGIC DEVICES
6
C h a p t e r

194
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 6.1
The general structure of programmable logic devices is illustrated in Figure 6.1. The 
inputs to the PLD are applied to a set of buffers/inverters. Buffers/inverters provide the true 
values of the inputs as well as the complemented values of the inputs. In addition,  they 
also provide the necessary drive for the AND array, which consists of a large number of AND 
gates that follow next to buffers/inverters. The AND array produces p numbers of product 
terms from n numbers of input variables and their complements. These product terms are 
fed to the OR array, which follows next. The OR array also consists of several numbers of 
OR gates and realizes a set of m numbers of outputs at sum of the products form.
Programmable logic devices are broadly classiﬁ ed as three types of devices—Read Only 
Memory or ROM, Programmable Logic Array or PLA, and Programmable Array Logic or 
PAL. PLDs serve as the general circuits for realization of a set of Boolean functions. One or 
both of the arrays of PLDs are programmable in the sense that the logic designer can select 
the connections within the array. In ROM and PAL, one of the arrays are programmable 
whereas both the arrays are programmable for PLA. The following table summarizes which 
arrays are programmable for the various PLDs.
Device type 
AND array 
OR array
 ROM 
Fixed 
Programmable 
 
PLA 
Programmable 
Programmable 
 
PAL 
Programmable 
Fixed 
In a programmable array, the connections of gates can be selected. The simple approach 
for fabricating the programmable gate is to employ fuse links at each of the inputs of the 
gate as demonstrated in Figure 6.2(a). Some of the fuses are programmed to blow out  to 
achieve the desired output from the gate. As an example, if the desired output of the gate 
is BC, then fuses at A and D are to be blown out as shown in Figure 6.2(b). Similarly, the 
same gate may be programmed for the function ACD, if only the fuse at input B is blown 
out. Therefore, with the blowing of fuses with proper programming, the same gate can 
generate several Boolean functions.
 
Figure 6.2(a) 
Figure 6.2(b)
p
product-term
lines
n
buffers/
inverters
AND
array
OR
array
m
output
lines
n
input
lines
A
B
C
D
F
A
B
C
D
F = BC

PROGRAMMABLE LOGIC DEVICES 195
Although various schemes are used at fabrication of these types of gate arrays, this 
simple approach is assumed here to understand the function of PLDs. It should also be 
assumed that the open inputs of an AND gate array are connected to logic 1 and open 
inputs of an OR gate are connected to logic 0.
6.2  PLD NOTATION
To indicate the connections to an AND array and an OR array of a PLD, a simpliﬁ ed 
notation is frequently used. The notation is illustrated in Figures 6.3(a) and 6.3(b). Rather 
than drawing all the inputs to the AND gate or OR gate, a single line is drawn to the 
input to the gate. The inputs  are indicated by the right-angled lines. The connected input 
variables are indicated by cross (×) at junctions and unconnected inputs are left blank. 
The cross-marked junctions represent the fusible joints while junctions with dots indicate 
permanent junctions that are not fusible.
Figure 6.3(a) All fuses are intact.
Figure 6.3(b) Fuses A and D are blown to obtain function F=BC.
6.3  READ ONLY MEMORY (ROM)
A ROM is essentially a memory device for storage purpose in which a ﬁ xed set of binary 
information is stored. An user must ﬁ rst specify the binary information to be stored and 
then it is embedded in the unit to form the required interconnection pattern. ROM contains 
special internal links that can be fused or broken. Certain links are to be broken or blown 
out to realize the desired interconnections for a particular application and to form the 
required circuit path. Once a pattern is established for a ROM, it remained ﬁ xed even if 
the power supply to the circuit is switched off and then switched on again.
A block diagram of  ROM is shown in Figure 6.4. It consists of n input lines and m
output lines. Each bit combination of input variables is called an address and each bit 
combination that is formed at output lines is called a word. Thus, an address is essentially 
a binary number that denotes one of the minterms of n variables and the number of bits 
per word is equal to the number of output lines m. It is possible to generate p = 2n number 
of distinct addresses from n number of input variables. Since there are 2n distinct addresses 
in a ROM, there are 2n distinct words which are said to stored in the device and an output 
word can be selected by a unique address. The address value applied to the input lines 
speciﬁ es the word at output lines at any given time. A ROM is  characterized by the number 
of words 2n and number of bits per word m and denoted as 2n × m ROM.
A
B
C
D
F
F
A
B C D
A
B
C
D
F = BC
F = BC
A
B C D

196
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 6.4
As an example, consider a 32 × 8 ROM. The device contains 32 words of 8 bits each. 
This means there are eight output lines and there are 32 numbers of distinct words stored 
in that unit, each of which is applied to the output lines. The particular word selected 
from the presently available output lines is determined by ﬁ ve input variables, as there 
are ﬁ ve input lines for a 32 × 8 ROM, because 25 = 32. Five input variables can specify 32 
addresses or minterms and for each address input there is a unique selected word. Thus, 
if the input address is 0000, word number 0 is selected. For address 0001, word number 
1 is selected and so on.
A ROM is sometimes speciﬁ ed by the total number of bits it contains, which is 2n × m.
For example, a 4,096-bit ROM may be organized as 512 words of 8 bits each. That means 
the device has 9 input lines (29 × m = 512) and 8 output lines.
In Figure 6.4, the block consisting of an AND array with buffers/inverters is equivalent 
to a decoder. The decoder basically is a combinational circuit that generates 2n numbers of 
minterms from n number of input lines as already discussed in Chapter 5. 2n or p numbers 
of minterms are realized from n number of input variables with the help of n numbers of 
buffers, n numbers of inverters, and 2n numbers of AND gates. Each of the minterms is 
applied to the inputs of m number of OR gates through fusible links. Thus, m numbers of 
output functions can be produced after blowing of some selected fuses. The equivalent logic 
diagram of a 2n×m ROM is shown in Figure 6.5(a) and its logic diagram with PLD notation 
is redrawn in Figure 6.5(b).
Figure 6.5(a)
The ROM is a two-level logic representation in the sum of products form. It may not 
be essentially an AND-OR realization, but it can be realized by other two-level minterm 
implementations. The second level is usually a  wired-logic connection to facilitate the 
blowing of the links.
:
:
:
:
:
:
:
:
n
input
lines
AN D array
with
buffers/
inverters
OR
array
p
product-term
lines
m
output
lines
:
:
:
:
..
..
..
m 0
m 1
m p
n to p
Decoder
n
input
lines
OR
array
m  output lines

PROGRAMMABLE LOGIC DEVICES 197
Figure 6.5(b)
ROM has many important applications in the design of digital computer systems. 
Realization of complex combinational circuits, code conversions, generating bit patterns, 
performing arithmetic functions like multipliers, forming look-up tables for arithmetic 
functions, and bit patterns for characters are some of its applications. They are particularly 
useful for the realization of multiple output combinational circuits with the same set of 
inputs. As such, they are used to store ﬁ xed bit patterns that represent the sequence of 
control variables needed to enable the various operations in the system. They are also used 
in association with microprocessors and microcontrollers.
6.3.1  Implementation of Combinational Logic Circuits
The implementation of Boolean functions using decoders was already discussed in 
Chapter 5. The same approach is applicable in using ROM, since ROM is the device 
that includes both a decoder and OR gates within the same chip. Given a set of Boolean 
expressions in minterms canonical form or a set of expressions in truth table form, ﬁ rst it is 
only necessary to select a ROM according to the input variables and number of output lines, 
and then to identify which links of the ROM are to be retained and which are to be blown. 
The blowing off of appropriate fuses or opening the links is referred to as programming.
The designer needs only to specify a ROM program table that provides information for the 
required paths in the ROM. Some examples of ROM-based design are demonstrated here.
Example 6.1. Consider that the following Boolean functions are to be developed using 
ROM.
 
 
 
F1 (A, B, C) =   ( 0,1,2,5,7) 
 
and
 
 
 
F2 (A, B, C) =   (1,4,6).
When a combinational circuit is developed by means of a ROM, the functions must be 
expressed in the sum of minterms or by a truth table. The truth table of the above functions 
is shown in Figure 6.6. Since there are three input variables, a ROM containing a 3-to-8 
line decoder is needed. In addition, since there are two output functions, the OR array must 
contain at least two OR gates. That means, a 23 × 2 ROM or 8 × 2 ROM is to be employed to 
realize the above functions. The logic diagram of the ROM after blowing off the appropriate 
fuses is illustrated in Figure 6.7. Obviously, this is too simple a combinational circuit to 
be implemented with a ROM. This example is merely for illustration purpose only. From 
the practical point of view, the real advantage of a ROM is in implementation of complex 
combinational networks having a large number of inputs and outputs.
:
:
:
:
m 0
m 1
m p
n to p
Decoder
n
input
lines
OR
array
m  output lines
x
x
x
x
x
x
x
x
x

198
DIGITAL PRINCIPLES AND LOGIC DESIGN
Some ROM units are available with INVERTERs after each of the OR gates and 
they are speciﬁ ed as having initially all 0s at their outputs. The programming procedure 
in such ROMs require to blow off  the  link paths of the minterms (or addresses) that 
specify an output of 1 in the truth table. The outputs of the OR gates will then generate 
the complements of the functions, but the INVERTERs placed after OR gates complement 
the functions once more to provide the desired outputs. This is shown in Figure 6.8 for 
implementation of the logic functions as described in the previous example.
Decimal 
Input Variables 
Outputs
 
Equivalent 
A 
B 
C 
F1 
F2
 
0 
0 
0 
0 
1 
0
 
1 
0 
0 
1 
1 
1
 
2 
0 
1 
0 
1 
0
 
3 
0 
1 
1 
0 
0
 
4 
1 
0 
0 
0 
1
 
5 
1 
0 
1 
1 
0
 
6 
1 
1 
0 
0 
1
 
7 
1 
1 
1 
1 
0
Figure 6.6
Figure 6.7
The previous example demonstrates the general procedure for implementing any 
combinational circuit with a ROM. From the number of inputs and outputs, the size of the 
ROM is determined ﬁ rst and then the programming for blowing off the appropriate fuse 
links is required with the help of the truth table or minterms. No further manipulation or 
simpliﬁ cation of Boolean functions is required. In practice, while designing with ROM, it 
is not essential to show the internal gate connections of links inside the unit. The designer 
A
B
3-to-8
D ecoder
C
F 1
F2
m
m
m
m
m
m
m
m
0
1
2
3
4
5
6
7

PROGRAMMABLE LOGIC DEVICES 199
simply has to specify the particular ROM and provide the ROM truth table as in Figure 
6.6. The truth table provides all the information for programming of ROM. No internal logic 
diagram is necessary to accompany the truth table.
Figure 6.8
Example 6.2. Find the squares of 3-bit numbers.
Solution. This example has already been discussed and implemented with the classical 
method in Chapter 5. There are three input variables and six output functions. To implement 
with ROM, a 23 × 6 ROM or 8 × 6 ROM is required. The truth table is again shown in 
Figure 6.9 for convenience. Figure 6.10 shows the inputs and outputs with ROM and the 
internal fusible junctions are shown in Figure 6.11 after programming.
 
Input variables 
Output variables
 Decimal 
X 
Y 
Z 
Decimal 
A 
B 
C 
D 
E 
F 
 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
 
1 
0 
0 
1 
1 
0 
0 
0 
0 
0 
1 
 
2 
0 
1 
0 
4 
0 
0 
0 
 1 
0 
0 
 
3 
0 
1 
1 
9 
0 
0 
1 
0 
0 
1 
 
4 
1 
0 
0 
16 
0 
1 
0 
0 
0 
0 
 
5 
1 
0 
1 
25 
0 
1 
1 
0 
0 
1 
 
6 
1 
1 
0 
36 
1 
0 
0 
1 
0 
0 
 
7 
1 
1 
1 
49 
1 
1 
0 
0 
0 
1
Figure 6.9
A
B
3-to-8
D ecoder
C
F 1
F 2
m
m
m
m
m
m
m
m
0
1
2
3
4
5
6
7

200
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 6.10
Figure 6.11
Example 6.3. Design a code converter circuit for BCD-to-Excess-3 as well as BCD-to-
2421 code using ROM.
Solution.
 
Decimal 
BCD code 
Excess-3 code 
2421 code
 Equivalent 
A 
B 
C 
D 
W 
X 
Y 
Z 
P 
Q 
R 
S 
 
0 
0 
0 
0 
0 
0 
0 
1 
1 
0 
0 
0 
0 
 
1 
0 
0 
0 
1 
0 
1 
0 
0 
0 
0 
0 
1 
 
2 
0 
0 
1 
0 
0 
1 
0 
1 
0 
0 
1 
0 
 
3 
0 
0 
1 
1 
0 
1 
1 
0 
0 
0 
1 
1 
 
4 
0 
1 
0 
0 
0 
1 
1 
1 
0 
1 
0 
0 
 
5 
0 
1 
0 
1 
1 
0 
0 
0 
1 
0 
1 
1 
 
6 
0 
1 
1 
0 
1 
0 
0 
1 
1 
1 
0 
0 
 
7 
0 
1 
1 
1 
1 
0 
1 
0 
1 
1 
0 
1 
 
8 
1 
0 
0 
0 
1 
0 
1 
1 
1 
1 
1 
0 
 
9 
1 
0 
0 
1 
1 
1 
0 
0 
1 
1 
1 
1 
Figure 6.12
Here, two code converter circuits are housed in one single device. There are four input 
variables and eight output lines (four outputs for Excess-3 and four outputs for 2421). 
X
8 x 4
ROM
A
B
C
D
E
F
Y
Z
X
Y
3-to-8
D ecoder
Z
A
D
B
E
C
F
X
X
X
X
X
X
X
X
X
m
m
m
m
m
m
m
m
0
1
2
3
4
5
6
7

PROGRAMMABLE LOGIC DEVICES 201
Therefore, the ROM size required is 24 × 8 or 16 × 8. The combined truth table is presented in 
Figure 6.12. A logic diagram with PLD notation using ROM is given in Figure 6.13.
Figure 6.13
6.3.2  Types of ROM
The programming of ROM for selection of required paths may be done by two ways. 
The ﬁ rst is called mask programming and is done by the manufacturer during the last 
fabrication process of the device. The procedure for fabricating ROM is that the customer 
should  provide the truth table for the ROM to the manufacturer in a prescribed format. 
The manufacturer makes the corresponding mask for the links according to the truth table 
provided by the customer. This procedure is costly as the manufacturer demands a  special 
charge from the customer for custom masking of a ROM. This procedure is economic only 
for large production of the same type of ROM. It is also less ﬂ exible because once it is 
programmed the functions cannot be modiﬁ ed by any means. With the advent of technology 
development various types of ROM are available nowadays.
1. Programmable Read Only Memory (PROM). It is more economic in cases requiring 
small quantities. In this method the manufacturer provides the PROM with all 0s (or 
all 1s) in every bit of the stored words. The required links are broken by application 
of current pulses. This allows the user to program the device in his own laboratory 
to obtain the desired relationship between input addresses and stored words. Special 
equipments called PROM Programmers are commercially available to facilitate this 
procedure. In any case, all procedures for programming ROMs are hardware procedures 
even though the word programming is used.
2. Erasable PROM (EPROM). The hardware procedure for programming of ROMs or 
PROMs as described above is irreversible, and once programmed, the conﬁ guration 
is ﬁ xed and cannot be altered. The device must be discarded if the bit pattern is 
required to be changed or modiﬁ ed. A third type of unit is available to overcome this 
disadvantage which is called Erasable PROM or EPROM. This device can reconstruct 
the initial bit patterns of all 0s or all 1s, though it is already programmed for some 
bit conﬁ guration. In other words, this device can be erased. This is achieved by placing 
A
4-to-16
Decoder
m 0
m 15
W
X
Y
Z
P
Q
R
S
2421
Excess-3
Code
B
C
D
x
x
xx
xx
xx
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
xx
x

202
DIGITAL PRINCIPLES AND LOGIC DESIGN
the Erasable PROM or EPROM under a special ultraviolet light for a given time. The 
short wave radiation discharges the internal gates that serve as links or contacts. 
After erasure, the device returns to its initial state and can be reprogrammed.
 
3. Electrically Erasable PROM (EEPROM). With the advancement of fabrication technology, 
further improvement of ROM has taken place, where ultraviolet light is not necessary 
to erase the programmed data. A new technique has been introduced to erase the bit 
pattern of ROM, where bit patterns are reset to their original state of all 0s or all 1s 
by applying a special electrical signal. Afterwards, the device can be reprogrammed 
with an alternate bit pattern. The equipment called EPROM Programmer serves the 
purpose of erasure as well as programming the bit patterns.
The function of a ROM may be interpreted two different ways. The ﬁ rst interpretation is 
of a device that realizes any combinational circuit. Each output terminal may be considered 
separately as the out of a Boolean function expressed in sum of the minterms. Secondly, 
it may be considered as a storage unit having a ﬁ xed pattern of bit strings called words.
From this point of view, the inputs specify an address to a speciﬁ c stored word which is 
then applied to the outputs.  For example, the ROM in Figure 6.10 has three address lines 
specifying eight stored words, each of which is four bits long as given in the truth table. 
For this reason the device is called read only memory. Generally a storage device is called 
memory and the terminology read signiﬁ es the content in a speciﬁ ed location of a memory 
device, as addressed by the inputs available at the output. Thus, a ROM is a memory unit 
with a ﬁ xed word pattern that can be read out upon application of a given address. The bit 
pattern of ROM is permanent and cannot be altered during normal operation.
6.4  PROGRAMMABLE LOGIC ARRAY (PLA)
A combinational network may occasionally contain don’t-care conditions. During the ROM 
implementation of this combinational circuit, this don’t-care condition also forms an address 
input that will never occur. The words at the don’t-care addresses need not be programmed 
and may be left in their original state of all 0s or all 1s. Since some of the bit patterns are 
not at all used, the address locations corresponding to don’t-care conditions are considered 
a waste of memory.
Consider the simple case for Example 6.3,  where code conversation from BCD to 
Excess-3 as well as 2421 code is demonstrated. It may be noted that for four input lines 
and eight output lines a 16 × 8 ROM has been used. This device has 16 addresses, though 
only 10 addresses are used because six addresses are attributed to don’t-care conditions. 
That means, six words or 6 × 8 bit locations are wasted.
For the cases where don’t-care conditions are excessive, it is more economical to use 
a second type of LSI device called a Programmable Logic Array or PLA. A PLA is similar 
to a ROM in concept. However, a PLA does not contain all AND gates to form the decoder 
or does not generate all the minterms like ROM. In the PLA, the decoder is replaced by a 
group of AND gates with buffers/inverters, each of which can be programmed to generate 
some product terms of input variable combinations that are essential to realize the output 
functions. The AND and OR gates inside the PLA are initially fabricated with the fusible 
links among them. The required Boolean functions are implemented in sum of the products 
form by opening the appropriate links and retaining the desired connections.
A block diagram of the PLA is shown in Figure 6.14. It consists of n inputs, m outputs, 
p product terms, and m sum terms. The product terms are obtained from an AND array 

PROGRAMMABLE LOGIC DEVICES 203
containing p number of AND gates and the sum terms are developed by an OR array 
consisting of m number of OR gates. Fusible links are provided to each of the inputs of 
each of the AND gates as well as the OR gates. Additionally, outputs are provided with an 
INVERTER array with fusible links, so that the outputs are available at uncomplemented 
form as well as at complemented form. Therefore, the function is implemented in either 
AND-OR form when the output link across INVERTER is in place, or in AND-OR-INVERT 
form when the link is blown off. The general structure of a PLA with internal connections 
is shown Figure 6.15.
Figure 6.14
Figure 6.15
The size of a PLA is speciﬁ ed by the number of inputs, the number of product terms, 
and the number of outputs. The number of sum terms is equal to the number of outputs. 
The PLA described in Figure 6.14 or Figure 6.15 is speciﬁ ed as n × p × m PLA. The number 
:
:
:
:
:
:
:
:
2n x p
links
AN D
array
p product
trm s
OR
array
m  sum
term s
p x m
links
m
links
m
output
lines
n
input
lines
..
..
..
.......
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
......
........
n
input
lines
p product term s
OR
array
m  output lines

204
DIGITAL PRINCIPLES AND LOGIC DESIGN
of programmable links is 2n × p + p × m + m,  whereas that of ROM is 2n × m. A typical 
PLA of 16 × 48 × 8 has 16 input variables, 48 product terms, and 8 output lines.
A comparison between ROM and PLA can be made to show how reduction in the 
number of gates is possible in PLA. Consider a typical example of implementation of a 
combinational circuit of 16 inputs, 8 outputs, and no more than 48 product terms. A 16 × 
48 × 8 PLA can serve the purpose, which consists of 48 product terms. To implement the 
same combinational circuit, a 216 × 8 ROM is needed, which consists of 216 = 65536 minterms 
or product terms. So there is a drastic reduction in number of AND gates within the chip, 
thus reducing the fabrication time and cost. It should be noted that both complemented 
and uncomplemented inputs, i.e., 2n number of inputs appear at each AND gate providing 
maximum ﬂ exibility in product term generation.
Like a ROM,  the PLA may also be mask-programmable or ﬁ eld programmable. For a 
mask-programmable PLA, the user must submit a PLA program table to the manufacturer to 
produce a custom made PLA that has the required internal paths between inputs and outputs. 
The second type of PLA available is called a ﬁ eld programmable logic array or FPLA. The FPLA 
can be programmed by the users by means of certain recommended procedures. Programmer 
equipment is available commercially for use in conjunction with certain FPLAs.
6.4.1  Design Procedure with PLA
In the case of ROM-based design, we have seen that, since all the minterms are 
generated in a ROM, the realization of a set of Boolean functions is based on minterms 
canonical expressions. It is never necessary to minimize the expressions prior to obtaining 
the realization with a ROM. On the other hand, in the case of PLA, the product terms 
generated are not necessarily the minterms, as these product terms depend upon how the 
fuses are programmed. As a consequence, the realization using PLA is based on the sum of 
the products expressions. Also, it is signiﬁ cant that the number of product terms is limited 
for a PLA and the logic designer must utilize them most intelligently. This implies that 
it is necessary to obtain a set of expressions in such a way that the number of product 
terms does not exceed the number of AND gates in the PLA. Therefore, some degree of 
simpliﬁ cation of Boolean functions is needed. Several techniques of minimization of Boolean 
expressions have already been discussed in earlier chapters.
Example 6.4. To demonstrate the use of PLA to implement combinational logic circuits, 
consider the following expression
 
 
 
F1 ( A, B, C) =   (0, 1, 3, 4) 
 
and
 
 
 
F2 ( A, B, C) =   (1, 2, 3, 4, 5).
Figure 6.16(a) Map for function F1.
Figure 6.16(b) Map for function F2.
Assume that a 3 × 4 × 2 PLA is available for the realization of the above functions. 
It should be noted that according to the number of inputs and output, the speciﬁ ed PLA 
1
1
B'C'
B'C'
A'
A'
A
A
B'C
B'C
BC
BC
BC '
BC '
1
1
1
1
1
1
1

PROGRAMMABLE LOGIC DEVICES 205
is sufﬁ cient to realize the functions. However, total distinct  minterms in the functions are 
six, whereas available product terms or the number of AND gates in the speciﬁ ed PLA is 
four. So some simpliﬁ cation or minimization is required for the functions. Karnaugh maps 
are drawn in Figures 6.16(a) and 6.16(b) for this purpose.
The simpliﬁ ed Boolean expressions for the functions are
 
 
 
F1 = B′C′ + A′C 
 
 
and
 
 
 
F2 = A′B + A′C + AB′.
In these expressions, there are four distinct product terms—B′C′, A′C, A′B, and AB′. So 
these function can be realized by the speciﬁ ed 3 × 4 × 2 PLA. The internal connection diagram 
for the functions using PLA after fuse-links programming is demonstrated in Figure 6.17.
Figure 6.17
Programming the PLA means to specify the paths in its AND-OR-INVERT pattern. 
A PLA program table is a useful tool to specify the input-output relationship indicating 
the number of product terms and their expressions. It also speciﬁ es whether the output is 
complemented or not. The program table for the above example is shown in Figure 6.18.
Product 
 
Inputs 
 
 Outputs
 
 
Terms 
A 
B 
C 
F1 
F2
 
A′B 
1 
0 
1 
- 
- 
1
 
A′C 
2 
0 
- 
1 
1 
1
 
AB′
3
1 
0 
- 
- 
1
 
B′C′ 
4 
- 
0 
0 
1 
-
 
 
 
 
 
 
T 
T 
T/C 
Figure 6.18
The ﬁ rst column lists the product terms numerically. The second column speciﬁ es the 
required paths between inputs and AND gates. The third column indicates the paths between 
A
B
C
F 1
F 2
X
X
X
X
X
X
X
X
X
X
X
X
X

206
DIGITAL PRINCIPLES AND LOGIC DESIGN
the AND gates and OR gates. Under each output variable, T is written if output INVERTER 
is bypassed i.e., the output at true form, and C is written if output is complemented with 
INVERTER. The Boolean terms listed at the leftmost  are for reference only, they are not 
part of the table.
For each product term, the inputs are marked with 1, 0, or – (dash). If the input 
variable is present in the product term at its uncomplemented form, the corresponding 
input variable is marked with a 1. If the input variable appears in the product term at 
its complemented form, it is marked with a 0. If the variable does not at all appear in the 
product term, it is marked with a – (dash). Thus the paths between the inputs and the 
AND gates are speciﬁ ed under the column heading inputs and accordingly the links at the 
inputs of AND gates are to be retained or blown off. The AND gates produce the required 
product term. The open terminals of AND gates behave like logic 1.
The paths between the AND gates and OR gates are speciﬁ ed under the column heading 
outputs. Similar to the above, the output variables are also marked with 1, 0, or – (dash) 
depending upon the presence of product terms in the output expressions. Finally, a T (true) 
output dictates that links across the INVERTER are retained and for C (complemented) at 
output indicates that the link across the INVERTER is to be broken. The open terminals 
of OR gates are assumed to be logic 0.
While designing a digital system with PLA, there is no need to show the  internal 
connections of the unit. The PLA program table is sufﬁ cient to specify the appropriate paths. 
For a custom made PLA chip this program table is needed to provide to the manufacturer.
Since for a given PLA, the number of AND gates is limited, careful investigation must 
be carried out, while implementing a combinational circuit with PLA, in order to reduce the 
total number of distinct product terms. This can be done by simplifying each function to 
a minimum number of terms. Note that the number of literals in a term is not important 
as all the inputs are available. It is required to obtain the simpliﬁ ed expressions both of 
true form and its complement form for each of the functions to observe which one can be 
expressed with fewer product terms and which one provides product terms that are common 
to other functions. The following example will clarify this.
Example 6.5. Implement the following Boolean functions using a 3 × 4 × 2 PLA.
 
 
 
F1 ( A, B, C) =   (3, 5, 6, 7) 
 
and
 
 
 
F2 ( A, B, C) =   (0, 2, 4, 7).
Solution. A total of seven minterms are present in the two functions above, whereas the 
number of AND gates is four in the speciﬁ ed PLA. So simpliﬁ cation of the above functions 
is necessary. Simpliﬁ cation is carried out for both the true form as well as the complement 
form for each of the functions. Karnaugh maps are drawn in Figure 6.19(a)-(d).
 
Figure 6.19(a) Map for function F1.
Figure 6.19(b) Map for function F2.
1
1
B'C'
B'C'
A'
A'
A
A
B'C
B'C
BC
BC
BC '
BC '
1
1
1
1
1
1

PROGRAMMABLE LOGIC DEVICES 207
Figure 6.19(c) Map for function F1′.
Figure 6.19(d) Map for function F2′.
The Boolean expressions are
 
 
F1 = AC + AB + BC 
 
and 
 
F2 = B′C′ + A′C′ + ABC
 
 
F1′ = B′C′ + A′B′ + A′C′ 
and 
 
F2′ = A′C + B′C + ABC′.
From the Boolean expressions it can be observed that if both the true forms of F1 and 
F2 are selected for implementation, the total number of distinct product terms needed to be 
realized is six, which is not possible by the speciﬁ ed 3 × 4 × 2 PLA.  However, if F1′ and F2
are selected, then the total number of distinct product terms reduces to four, which is now 
possible to be implemented by the speciﬁ ed PLA. F1′ can be complemented by the output 
INVERTER to obtain its true form of F1. The PLA program table for these expressions 
is prepared in Figure 6.20. Note that the C (complement) is marked under the output F1
indicating that output INVERTER exists at the output path of F1. The logic diagram for 
the above combinational circuit is shown in Figure 6.21.
Product 
 
Inputs 
 
 
Outputs 
 
 
 
Terms 
A 
B 
C 
F1 
F2
 
B′C′ 
1 
- 
0 
0 
1 
1 
 
 
A′B′ 
2 
0 
0 
- 
1 
- 
 
 
A′C′ 
3 
0 
- 
0 
1 
1 
 
 
ABC 
4 
1 
1 
1 
- 
1 
 
 
 
 
 
 
 
C 
T 
T/C 
Figure 6.20
Figure 6.21
0
0
0
0
0
B'C'
B'C'
A'
A'
A
A
B'C
B'C
BC
BC
BC '
BC '
0
0
0
A
B
C
F 1
F2
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X

208
DIGITAL PRINCIPLES AND LOGIC DESIGN
It should be noted that the combinational circuits for the examples presented here are 
too small and simple for practical implementation with PLA. But they do serve the purpose of 
demonstration and show the concept of PLA combinational logic design. A typical commercial PLA 
would have over 10 inputs and about 50 product terms. The simpliﬁ cation of so many variables 
are carried out by means of tabular method or other computer-based simpliﬁ cation methods. 
Thus, the computer program assists in designing the complex digital systems. The computer 
program simpliﬁ es each of the functions of the combinational circuit and its complements to 
a minimum number of terms. Then it optimizes and selects a minimum number of distinct 
product terms that cover all the functions in their true form or complement form.
6.5  PROGRAMMABLE ARRAY LOGIC (PAL) DEVICES
The ﬁ nal programmable logic device to be discussed is the Programmable Array Logic or 
PAL device. The general structure of this device is similar to PLA, but in a PAL device only 
AND gates are programmable. The OR array in this device is ﬁ xed by the manufacturer. 
This makes PAL devices easier to program and less expensive than PLA. On the other hand, 
since the OR array is ﬁ xed, it is less ﬂ exible than a PLA device.
Figure 6.22
Figure 6.23
:
:
:
:
:
:
:
:
2n x p
links
n
input
lines
AN D
array
p product
term s
OR
array
m  sum
term s
m
output
lines
F1
F2
F 3
A
B
C
D

PROGRAMMABLE LOGIC DEVICES 209
Figure 6.22 represents the general structure of a PAL device. It has n input lines 
which are fed to buffers/inverters. Buffers/inverters are connected to inputs of AND gates 
through programmable links. Outputs of AND gates are then fed to the OR array with ﬁ xed 
connections. It should be noted that, all the outputs of an AND array are not connected to 
an OR array. In contrast to that, only some of the AND outputs are connected to an OR 
array which is at the manufacturer's discretion. This can be clariﬁ ed by Figure 6.23, which 
illustrates the internal connection of a four-input, eight AND-gates and three-output PAL 
device before programming. Note that while every buffer/inverter is connected to AND gates 
through links, F1-related OR gates are connected to only three AND outputs, F2 with three 
AND gates, and F3 with two AND gates. So this particular device can generate only eight 
product terms, out of which two of the three OR gates may have three product terms each 
and the rest of the OR gates will have only two product terms. Therefore, while designing 
with PAL, particular attention is to be given to the ﬁ xed OR array.
6.5.1  Designing with Programmable Array Logic
Let us consider that the following functions are to be realized using a PAL device.
 
 
 
F1 (A,B,C) =   ( 1,2,4,5,7)
 
 
 
F2 (A,B,C) =   ( 0,1,3,5,7)
Similar to designing with PLA, in the case of a PAL device some simpliﬁ cation must 
be carried out to reduce the total number of distinct product terms. Karnaugh maps for the 
above functions are drawn in Figures 6.24(a) and 6.24(b).
Figure 6.24(a) Map for function F1.
Figure 6.24(b) Map for function F2.
The Boolean expressions are 
 
 
 
F1 (A,B,C) = AB′ + AC + B′C + A′BC′  
and
 
 
 
F2 (A,B,C) = C + A′B′.
To use the PAL device as illustrated in Figure 6.23 for realization of the above expressions, 
it may be noted that a problem occurs that the speciﬁ ed PAL device has at the most three 
product terms associated with one OR gate, whereas one of the given functions F1 has four 
product terms. However, realization of the functions are achievable with the speciﬁ ed PAL 
device by the following method.
Let the above expressions be rewritten as 
 
 
 
F1 (A,B,C) 
= F3 + B′C + A′BC′
 
 
 
F2 (A,B,C) 
= C + A′B′
where,  
 
F3 = AB′ + AC.
Now there are three functions each of which contains no more than three product 
terms and these can be realizable by the speciﬁ ed PAL. The connection diagram of PAL is 
illustrated in Figure 6.25.
1
1
1
1
1
B'C'
B'C'
A'
A'
A
A
B'C
B'C
BC
BC
BC '
BC '
1
1
1
1
1

210
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 6.25
Here, one subfunction F3 has been generated with two product terms, and this sub-
function is connected to one of the inputs to realize the ﬁ nal function F1. To realize F2, only 
two terms need to be generated. Since a three-input OR gate is used, the input must be 
kept at logic 0, so as not to affect the F2 output. This is achieved by keeping all the fuses 
intact to the AND gate that serves as the third input to the OR gate which is indicated by 
an ‘×’ mark on the AND gate in Figure 6.24. With a variable and its complement as inputs 
an AND gate always produces logic 0.
It should be noted that the PAL device as demonstrated here is too small for the 
practical point of view. Similar to a PLA device, a practical PAL device contains at least ten 
inputs and about ﬁ fty product terms. This small and simple PAL device has been illustrated 
here only to show its general internal architecture and how the combinational circuits are 
realized. Simpliﬁ cation of Boolean functions should be carried out and special attention 
must be given while selecting the minimal terms as the number of OR gates is limited as 
well as limited product terms are connected to them.
With the fast advancement of technology, various types of programmable logic devices 
are being developed to meet the users desire. Programmable logic devices are also available 
with ﬂ ip-ﬂ ops. Some of the useful programmable devices are mentioned here.
6.6  REGISTERED PAL DEVICES
Flip-ﬂ ops are employed in sequential digital circuits in addition to the combinational circuits, 
and therefore for the design of sequential circuits, PALs have been developed with ﬂ ip-ﬂ ops in 
the outputs. These devices are referred to as registered PALs. The ﬂ ip-ﬂ ops are all controlled 
by a common clock and another dedicated input pin is provided for output ENABLE control of 
INVERTERs.
x
x
x
x
x
x
x
x
x
x
x
x
x
x
A
B
C
D
F 1
F 2
F 3

PROGRAMMABLE LOGIC DEVICES 211
6.7  CONFIGURABLE PAL DEVICES
Development in the design of programmable array logic devices led to the introduction  of 
conﬁ gurable outputs enhancing the output capabilities of such devices. The conﬁ gurable device 
architecture is achieved by providing some special circuitary at the output stage, known 
as macrocells. Each of the macrocells are provided with two fuses that can be programmed 
for four different conﬁ gurations of outputs. The output conﬁ guration may be of true output 
without ﬂ ip-ﬂ op or complemented output without ﬂ ip-ﬂ op or true output with ﬂ ip-ﬂ op or 
complemented output with ﬂ ip-ﬂ op. So it may be observed that this type of device  can 
function for sequential logic circuits as well as for combinational logic circuits and in each 
case outputs are available in inverted form or noninverted form.
6.8  GENERIC ARRAY LOGIC DEVICES
The Generic Array Logic or GAL device is another type of conﬁ gurable PAL device. GAL 
devices are intended as pin-to-pin replacements for a wide variety of PAL devices. It is 
designed to be compatible, all the way to the fuse level, for any simpler PAL which can be 
directly implemented in the GAL device. In this device, the OR gate is considered to be a 
part of a macrocell to obtain various types of I/O conﬁ gurations found in the PAL devices 
that it is designed to replace. 
Another family of devices that are intended for PAL replacements are programmable
electrically erasable logic or PEEL devices. Its output macrocell can be programmed for 
numerous types of I/O conﬁ gurations.
6.9  FIELD-PROGRAMMABLE GATE ARRAY (FPGA)
These type of programmable devices are based on the basic structure equivalent to 
programmable logic array or PLA. Over the years, programmable arrays have increased 
in size and complexity. Highly conﬁ gurable macrocells have been induced to enhance their 
ﬂ exibility and capability. Field-programmable gate array or FPGA has been developed with 
the concept of alternate architecture, to increase the effective size and to provide more 
functional ﬂ exibility in a single programmable device. The densities of FPGAs are much 
higher than any other PLDs. Each FPGA accommodates 1,200 to 20,000 equivalent gates 
whereas PLDs range in size from a few hundred to 2,000 equivalent gates.
An FPGA contains a number of relatively independent conﬁ gurable logic modules, 
conﬁ gurable I/Os and programmable interconnection paths or routing channels. All the 
resources of this device are uncommitted and these must be selected, conﬁ gured, and 
interconnected by the user to form a logic system for his application. FPGAs are speciﬁ ed by 
their size, conﬁ guration of their logic modules, and interconnection requirements. FPGA with 
larger logic modules may not be sufﬁ ciently utilized to perform simple logic functions and 
thereby wasting the logic modules. Use of smaller logic modules leads to a larger number of 
interconnections with the device causing signiﬁ cant propagation delay as well as consuming 
a large percentage of FPGA area. The designer must optimize the logic module size and 
interconnection requirements according to the application of logic system design. For a given 
FPGA device, there are many possible ways to conﬁ gure to meet the design requirements. 
Different types of FPGAs are available that differ in their architecture, technologies, and 
programming techniques.

212
DIGITAL PRINCIPLES AND LOGIC DESIGN
6.10  CONCLUDING REMARKS
The basic concepts of programmable logic devices and programmable gate arrays have been 
discussed. With the development of these devices, complex digital systems have become 
possible to be designed. However, high-level design techniques and computer-aided tools are 
required to realize efﬁ cient PLD and FPGA implementations. The emergence of these devices 
has revolutionized the design of digital systems similar to the emergence of microprocessor 
or microcontrollers. The programmable logic concept has provided the power to design one’s 
custom ICs which cannot be copied by others.
REVIEW QUESTIONS
6.1 Deﬁ ne PLD. What are the advantages PLD?
6.2 What are the types of PLD?
6.3 List the applications of PLD.
6.4 What is PLA? How does it differ from ROM? Draw the block diagram of PLA.
6.5 What is PAL? How does it differ from ROM? Draw the block diagram of PAL.
6.6 What are the advantages of FPGA over other types of PLD?
6.7 Draw the internal logic construction of 32 × 4 ROM.
6.8 Give the comparison among PROM, PLA, and PAL.
6.9 How many words can be stored in a ROM of capacity 16K × 32?
6.10 What is the bit storage capacity of a 512 × 4 ROM?
6.11 State the differences among ROM, PROM, EPROM, and EEPROM.
6.12 Explain the difference between ROM and RAM.
6.13 What do a dot and an × represent in a PLD diagram?
6.14 How many memory locations are there for address values?
 
   
(a) 0000 to 7FFF,  (b) C000 to C3FF,  or  (c) A000 to BFFF.
6.15 Specify the size of a ROM for implementation of the following combinational circuit.
 
   
(a) a binary multiplier for multiplication of two 4-bit numbers, or (b) a 4-bit 
adder/subtractor.
6.16 Implement the following Boolean expressions using ROM.
 
   
F1 (A, B, C) = Σ (0, 2, 4, 7),  F2 (A, B, C) = Σ (1, 3, 5, 7)
6.17 Implement the following Boolean expressions using PLA.
 
   
F1 (A, B, C) = Σ (0, 1, 3, 5),  F2 (A, B, C) = Σ (0, 3, 5, 7)
6.18 Implement the following Boolean expressions using PAL.
 
   
F1 (A, B, C, D) = Σ (1, 2, 5, 7, 8, 10, 12, 13)  
 
   
F2 (A, B, C, D) = Σ (0, 2, 6, 8, 9, 14)
 
   
F3 (A, B, C, D) = Σ (0, 3, 7, 9, 11, 12, 14)  
 
   
F4 (A, B, C, D) = Σ (1, 2, 4, 5, 9, 10, 14)
6.19 Tabulate the PLA programmable table for the four Boolean functions listed below.
 
   
A (X, Y, Z) = Σ (0, 1, 2, 4, 6)

PROGRAMMABLE LOGIC DEVICES 213
 
   
B (X, Y, Z) = Σ (0, 2, 6, 7)
 
   
C (X, Y, Z) = Σ (3, 6)
 
   
D (X, Y, Z) = Σ (1, 3, 5, 7)
6.20 Design a BCD-to-Excess-3 code converter using (a) PROM, (b) PLA, and (c) PAL.
6.21 Design an Excess-3-to-BCD code converter using (a) PROM, (b) PLA, and (c) PAL.
6.22 Design a BCD-to-seven segment display decoder using (a) PROM, (b) PLA, and (c) PAL.
6.23 Tabulate the PLA programmable table for the four Boolean functions listed below.
 
   
A (X, Y, Z) = Σ (1, 2, 4, 6)
 
   
B (X, Y, Z) = Σ (0, 1, 6, 7)
 
   
C (X, Y, Z) = Σ (2, 6)
 
   
D (X, Y, Z) = Σ (1, 2, 3, 5, 7)
6.24 Following is a truth table of a three-input, four-output, combinational circuit. Tabulate the PAL 
programming table for the circuit and mark the fuse map in the diagram.
 
  
 
Inputs 
 
               Outputs
 
  
X 
Y 
Z 
A 
B 
C 
D
 
  
0 
0 
0 
0 
1 
0 
0
 
  
0 
0 
1 
1 
1 
1 
1
 
  
0 
1 
0 
1 
0 
1 
1
 
  
0 
1 
1 
0 
1 
0 
1
 
  
1 
0 
0 
1 
0 
1 
0
 
  
1 
0 
1 
0 
0 
0 
1
 
  
1 
1 
0 
1 
1 
1 
0
 
  
1 
1 
1 
0 
1 
1 
1
6.25 Design a code converter that converts 2421 code to BCD as well as to Excess-3 code using 
(a) PROM, (b) PLA, and (c) PAL.
❑ ❑ ❑


Next State
Logic
External
Inputs
M em ory
Elem ents
Excitation
Output
Logic
External
Outputs
Clock
215
7.1  INTRODUCTION
S
o far, all of the logic circuits we have studied were basically based on the analysis 
and design of combinational digital circuits. Though these type of circuits are very 
important, they constitute only a part of digital systems. The other major aspect of a 
digital system is the analysis and design of sequential digital circuits. However, sequential 
circuit design depends, greatly, on the combinational circuit design.
The logic circuits whose outputs at any instant of time depend only on the input signals 
present at that time are known as combinational circuits. The output in combinational 
circuits does not depend upon any past inputs or outputs. Moreover, in a combinational 
circuit, the output appears immediately for a change in input, except for the propagation 
delay through circuit gates.
On the other hand, the logic circuits whose outputs at any instant of time depend on 
the present inputs as well as on the past outputs are called sequential circuits. In sequential 
circuits, the output signals are fed back to the input side. A block diagram of a sequential 
circuit is shown in Figure 7.1
Figure 7.1 Block diagram of a sequential circuit.
From Figure 7.1, we ﬁ nd that it consists of combinational circuits, which accept digital 
signals from external inputs and from outputs of memory elements and generates signals 
for external outputs and for inputs to memory elements, referred to as excitation.
SEQUENTIAL LOGIC CIRCUITS
7
C h a p t e r

...
...
t <<T
p
0
T
2T
(n–1)T
(n+1)T
nT
n
Bit-tim e
Bit-tim e
n + 1
t
216
DIGITAL PRINCIPLES AND LOGIC DESIGN
A memory element is a medium in which one bit of information (0 or 1) can be stored 
or retained until necessary, and thereafter its contents can be replaced by a new value. 
The contents of memory elements can be changed by the outputs of combinational circuits 
that are connected to its input.
Combinational circuits are often faster than sequential circuits since the combinational 
circuits do not require memory elements whereas the sequential circuit needs memory 
elements to perform its operations in sequence.
Sequential circuits are broadly classiﬁ ed into two main categories, known as synchronous 
or clocked and asynchronous or unclocked sequential circuits, depending on the timing of 
their signals.
A sequential circuit whose behavior can be deﬁ ned from the knowledge of its signal at 
discrete instants of time is referred to as a synchronous sequential circuit. In these systems, 
the memory elements are affected only at discrete instants of time. The synchronization is 
achieved by a timing device known as a system clock, which generates a periodic train of 
clock pulses as shown in Figure 7.2. The outputs are affected only with the application of 
a clock pulse. The rate at which the master clock generates pulses must be slow enough 
to permit the slowest circuit to respond. This limits the speed of all circuits. Synchronous 
circuits have gained considerable domination and wide popularity.
A sequential circuit whose behavior depends upon the sequence in which the input 
signals change is referred to as an asynchronous sequential circuit. The output will be 
affected whenever the input changes. The commonly used memory elements in these circuits 
are time-delay devices. There is no need to wait for a clock pulse. Therefore, in general, 
asynchronous circuits are faster than synchronous sequential circuits. However, in an 
asynchronous circuit, events are allowed to occur without any synchronization. And in such 
a case, the system becomes unstable. Since the designs of asynchronous circuits are more 
tedious and difﬁ cult, their uses are rather limited. The memory elements used in sequential 
circuits are ﬂ ip-ﬂ ops which are capable of storing binary information.
Figure 7.2  Train of pulses.
7.2  FLIP-FLOPS
The basic 1-bit digital memory circuit is known as a ﬂ ip-ﬂ op. It can have only two states, 
either the 1 state or the 0 state. A ﬂ ip-ﬂ op is also known as a bistable multivibrator. Flip-ﬂ ops 
can be obtained by using NAND or NOR gates. The general block diagram representation of a 
ﬂ ip-ﬂ op is shown in Figure 7.3. It has one or more inputs and two outputs. The two outputs 
are complementary to each other. If Q is 1 i.e., Set, then Q' is 0; if Q is 0 i.e., Reset, then 
Q' is 1. That means Q and Q' cannot be at the same state simultaneously. If it happens by 
any chance, it violates the deﬁ nition of a ﬂ ip-ﬂ op and hence is called an undeﬁ ned condition.
Normally, the state of Q is called the state of the ﬂ ip-ﬂ op, whereas the state of Q' is called 
the complementary state of the ﬂ ip-ﬂ op. When the output Q is either 1 or 0, it remains in 

SEQUENTIAL LOGIC CIRCUITS 217
Q
Q'
Norm al output
Inverted output
Inputs
R C
R C
R B
R B
T 1
T 2
Q'
Q
V C C
Set
(S)
Reset
(R )
that state unless one or more inputs are excited to effect a change in the output. Since the 
output of the ﬂ ip-ﬂ op remains in the same state until the trigger pulse is applied to change 
the state, it can be regarded as a memory device to store one binary bit.
As mentioned earlier, a ﬂ ip-ﬂ op is also known as a bistable multivibrator, whose circuit 
is shown in Figure 7.4, where the trigger inputs are named as Set and Reset.
Figure 7.3 Block diagram of a ﬂ ip-ﬂ op.
Figure 7.4 Bistable multivibrator circuit.
From the circuit shown in Figure 7.4, we ﬁ nd that the multivibrator is basically two 
cross-coupled inverting ampliﬁ ers, comparising of two transistors and four resistors. Obviously, 
if transistor T1 is initially turned ON (saturated) by applying a positive signal through the Set 
input at its base, its collector will be at VCE (sat) (0.2 to 0.4 V). The collector of T1 is connected 
to the base of T2, which cannot turn T2 On. Hence, T2 remains OFF (cut off). Therefore, the 
voltage at the collector of T2 tries to reach VCC. This action only enhances the initial positive 
signal applied to the base of T1. Now if the initial signal at the Set input is removed, the 
circuit will maintain T1 in the ON state and T2 in the OFF state indeﬁ nitely, i.e., Q = 1 and 
Q' = 0. In this condition the bistable multivibrator is said to be in the Set state.
A positive signal applied to the Reset input at the base of T2 turns it ON. As we 
have discussed earlier, in the same sequence T2 turns ON and T1 turns OFF, resulting in 
a second stable state, i.e., Q = 0 and Q' = 1. In this condition the bistable multivibrator is 
said to be in the Reset state.
7.2.1  Latch
We consider the fundamental circuit shown in Figure 7.5. It consists of two inverters G1
and G2 (NAND gates are used as inverters). The output of G1 is connected to the input of G2
(A2) and the output of G2 is connected to the input of G1 (A1). Let us assume the output of 
G1 to be Q = 0, which is also the input of G2 (A2 = 0). Therefore, the output of G2 will be Q' 
= 1, which makes A1 = 1 and consequently Q = 0 which is according to our assumption.

218
DIGITAL PRINCIPLES AND LOGIC DESIGN
Similarly, we can demonstrate that if Q = 1, 
then Q' = 0 and this is also consistent with the circuit 
connections. Hence we see that Q and Q' are always 
complementary. And if the circuit is in 1 state, it 
continues to remain in this state and vice versa is also 
true. Since this information is locked or latched in this 
circuit, therefore, this circuit is also referred to as a latch.
In this circuit there is no way to enter the desired digital 
information to be stored in it. To make that possible we 
have to modify the circuit by replacing the inverters by 
NAND gates and then it becomes a ﬂ ip-ﬂ op.
7.3  TYPES OF FLIP-FLOPS
There are different types of ﬂ ip-ﬂ ops depending on how their inputs and clock pulses cause 
transition between two states. We will discuss four different types of ﬂ ip-ﬂ ops in this 
chapter, viz., S-R, D, J-K, and T. Basically D, J-K, and T are three different modiﬁ cations 
of the S-R ﬂ ip-ﬂ op.
7.3.1  S-R (Set-Reset) Flip-ﬂ op
An S-R ﬂ ip-ﬂ op has two inputs named Set (S) and 
Reset (R), and two outputs Q and Q'. The outputs are 
complement of each other, i.e., if one of the outputs is 
0 then the other should be 1. This can be implemented 
using NAND or NOR gates. The block diagram of an S-R 
ﬂ ip-ﬂ op is shown in Figure 7.6.
S-R Flip-ﬂ op Based on NOR Gates
An S-R ﬂ ip-ﬂ op can be constructed with NOR gates at ease by connecting the NOR 
gates back to back as shown in Figure 7.7. The cross-coupled connections from the output 
of gate 1 to the input of gate 2 constitute a feedback path. This circuit is not clocked and is 
classiﬁ ed as an asynchronous sequential circuit. The truth table for the S-R ﬂ ip-ﬂ op based 
on a NOR gate is shown in the table in Figure 7.8.
Figure 7.7 NOR-based S-R ﬂ ip-ﬂ op.
To analyze the circuit shown in Figure 7.7, we have to consider the fact that the output 
of a NOR gate is 0 if any of the inputs are 1, irrespective of the other input. The output 
is 1 only if all of the inputs are 0. The outputs for all the possible conditions as shown in 
the table in Figure 7.8 are described as follows.
Figure 7.6 Block diagram
of an S-R ﬂ ip-ﬂ op.
Figure 7.5 Cross-coupled inverters 
as a memory element.
Q
A1
G 1
A2
G 2
Q'
Q
Reset (R )
Q'
Set (S)
1
2

SEQUENTIAL LOGIC CIRCUITS 219
Inputs 
Outputs 
Action 
 
S 
R 
Qn+1 
Q'n+1
 
0 
0 
Qn 
Q'n 
No change
 
0 
1 
0 
1 
Reset
 
1 
0 
1 
0 
Set
 
1 
1 
0 
0 
Forbidden (Undeﬁ ned)
 
0 
0 
– 
– 
Indeterminate 
Figure 7.8
Case 1. For S = 0 and R = 0, the ﬂ ip-ﬂ op remains in its present state (Qn). It means 
that the next state of the ﬂ ip-ﬂ op does not change, i.e., Qn+1 = 0 if Qn = 0 and vice versa. 
First let us assume that Qn = 1 and Q'n = 0. Thus the inputs of NOR gate 2 are 1 and 0, 
and therefore its output Q'n+1 = 0. This output Q'n+1 = 0 is fed back as the input of NOR gate 
1, thereby producing a 1 at the output, as both of the inputs of NOR gate 1 are 0 and 0; so 
Qn+1 = 1 as originally assumed.
Now let us assume the opposite case, i.e., Qn = 0 and Q'n = 1. Thus the inputs of NOR 
gate 1 are 1 and 0, and therefore its output Qn+1 = 0. This output Qn+1 =0 is fed back as the 
input of NOR gate 2, thereby producing a 1 at the output, as both of the inputs of NOR 
gate 2 are 0 and 0; so Q'n+1 = 1 as originally assumed. Thus we ﬁ nd that the condition S 
= 0 and R = 0 do not affect the outputs of the ﬂ ip-ﬂ op, which means this is the memory 
condition of the S-R ﬂ ip-ﬂ op.
Case 2. The second input condition is S = 0 and R = 1. The 1 at R input forces the 
output of NOR gate 1 to be 0 (i.e., Qn+1 = 0). Hence both the inputs of NOR gate 2 are 0 
and 0 and so its output Q'n+1 = 1. Thus the condition S = 0 and R = 1 will always reset 
the ﬂ ip-ﬂ op to 0. Now if the R returns to 0 with S = 0, the ﬂ ip-ﬂ op will remain in the 
same state.
Case 3. The third input condition is S = 1 and R = 0. The 1 at S input forces the output 
of NOR gate 2 to be 0 (i.e., Q'n+1 = 0). Hence both the inputs of NOR gate 1 are 0 and 0 
and so its output Qn+1 = 1. Thus the condition S = 1 and R = 0 will always set the ﬂ ip-ﬂ op 
to 1. Now if the S returns to 0 with R = 0, the ﬂ ip-ﬂ op will remain in the same state.
Case 4. The fourth input condition is S = 1 and R = 1. The 1 at R input and 1 at S 
input forces the output of both NOR gate 1 and NOR gate 2 to be 0. Hence both the outputs 
of NOR gate 1 and NOR gate 2 are 0 and 0; i.e., Qn+1 = 0 and Q'n+1 = 0. Hence this condition
S = 1 and R = 1 violates the fact that the outputs of a ﬂ ip-ﬂ op will always be the complement 
of each other. Since the condition violates the basic deﬁ nition of ﬂ ip-ﬂ op, it is called the 
undeﬁ ned condition. Generally this condition must be avoided by making sure that 1s are 
not applied simultaneously to both of the inputs. 
Case 5. If case 4 arises at all, then S and R both return to 0 and 0 simultaneously, 
and then any one of the NOR gates acts faster than the other and assumes the state. For 
example, if NOR gate 1 is faster than NOR gate 2, then Qn+1 will become 1 and this will 
make Q'n+1 = 0. Similarly, if NOR gate 2 is faster than NOR gate 1, then Q'n+1 will become 1 
and this will make Qn+1 = 0. Hence, this condition is determined by the ﬂ ip-ﬂ op itself. Since 
this condition cannot be controlled and predicted it is called the indeterminate condition.

220
DIGITAL PRINCIPLES AND LOGIC DESIGN
S'-R' Flip-ﬂ op Based on NAND Gates
An S'-R' ﬂ ip-ﬂ op can be constructed with NAND gates by connecting the NAND gates 
back to back as shown in Figure 7.9. The operation of the S'-R' ﬂ ip-ﬂ op can be analyzed 
in a similar manner as that employed for the NOR-based S-R ﬂ ip-ﬂ op. This circuit is also 
not clocked and is classiﬁ ed as an asynchronous sequential circuit. The truth table for the 
S'-R' ﬂ ip-ﬂ op based on a NAND gate is shown in the table in Figure 7.10.
Figure 7.9 NAND-based S'-R' ﬂ ip-ﬂ op.
To analyze the circuit shown in Figure 7.9, we have to remember that a LOW at any 
input of a NAND gate forces the output to be HIGH, irrespective of the other input. The 
output of a NAND gate is 0 only if all of the inputs of the NAND gate are 1. The outputs 
for all the possible conditions as shown in the table in Figure 7.10 are described below.
Inputs 
Outputs 
Action 
 
S' 
R' 
Qn+1 
Q'n+1
 
1 
1 
Qn 
Qn 
No change
 
1 
0 
0 
1 
Reset
 
0 
1 
1 
0 
Set
 
0 
0 
1 
1 
Forbidden (Undeﬁ ned)
 
1 
1 
– 
– 
Indeterminate 
Figure 7.10
Case 1. For S' = 1 and R' = 1, the ﬂ ip-ﬂ op remains in its present state (Qn). It means 
that the next state of the ﬂ ip-ﬂ op does not change, i.e., Qn+1 = 0 if Qn = 0 and vice versa. 
First let us assume that Qn =1 and Q'n = 0. Thus the inputs of NAND gate 1 are 1 and 0, 
and therefore its output Qn+1 = 1. This output Qn+1 = 1 is fed back as the input of NAND 
gate 2, thereby producing a 0 at the output, as both of the inputs of NAND gate 2 are 1 
and 1; so Q'n+1 = 0 as originally assumed.
Now let us assume the opposite case, i.e., Qn = 0 and Q'n = 1. Thus the inputs of 
NAND gate 2 are 1 and 0, and therefore its output Q'n+1 = 1. This output Q'n+1 = 1 is fed 
back as the input of NAND gate 1, thereby producing a 0 at the output, as both of the 
inputs of NAND gate 1 are 1 and 1; so Qn+1 = 0 as originally assumed. Thus we ﬁ nd that 
the condition S' = 1 and R' = 1 do not affect the outputs of the ﬂ ip-ﬂ op, which means this 
is the memory condition of the S'-R' ﬂ ip-ﬂ op.
Case 2. The second input condition is S' = 1 and R' = 0. The 0 at R' input forces the output 
of NAND gate 2 to be 1 (i.e., Q'n+1 = 1). Hence both the inputs of NAND gate 1 are 1 and 1 
Q
Reset (R ')
Q'
Set (S')
1
2

SEQUENTIAL LOGIC CIRCUITS 221
and so its output Qn+1 = 0. Thus the condition S' = 1 and R' = 0 will always reset the ﬂ ip-ﬂ op 
to 0. Now if the R' returns to 1 with S' = 1, the ﬂ ip-ﬂ op will remain in the same state.
Case 3. The third input condition is S' = 0 and R' = 1. The 0 at S' input forces the output 
of NAND gate 1 to be 1 (i.e., Qn+1 = 1). Hence both the inputs of NAND gate 2 are 1 and 1 
and so its output Q'n+1 = 0. Thus the condition S' = 0 and R' = 1 will always set the ﬂ ip-ﬂ op 
to 1. Now if the S' returns to 1 with R' = 1, the ﬂ ip-ﬂ op will remain in the same state.
Case 4. The fourth input condition is S' = 0 and R' = 0. The 0 at R' input and 0 at 
S' input forces the output of both NAND gate 1 and NAND gate 2 to be 1. Hence both the 
outputs of NAND gate 1 and NAND gate 2 are 1 and 1; i.e., Qn+1 = 1 and Q'n+1 = 1. Hence 
this condition S' = 0 and R' = 0 violates the fact that the outputs of a ﬂ ip-ﬂ op will always be 
the complement of each other. Since the condition violates the basic deﬁ nition of a ﬂ ip-ﬂ op, 
it is called the undeﬁ ned condition. Generally, this condition must be avoided by making 
sure that 0s are not applied simultaneously to both of the inputs. 
Case 5. If case 4 arises at all, then S' and R' both return to 1 and 1 simultaneously, 
and then any one of the NAND gates acts faster than the other and assumes the state. For 
example, if NAND gate 1 is faster than NAND gate 2, then Qn+1 will become 1 and this will 
make Q'n+1 = 0. Similarly, if NAND gate 2 is faster than NAND gate 1, then Q'n+1 will become 
1 and this will make Qn+1 = 0. Hence, this condition is determined by the ﬂ ip-ﬂ op itself. Since 
this condition cannot be controlled and predicted it is called the indeterminate condition.
Figure 7.11  An S-R ﬂ ip-ﬂ op using NAND gates.
Thus, comparing the NOR ﬂ ip-ﬂ op and the NAND ﬂ ip-ﬂ op, we ﬁ nd that they basically 
operate in just the complement fashion of each other. Hence, to convert a NAND-based S'-R' 
ﬂ ip-ﬂ op into a NOR-based S-R ﬂ ip-ﬂ op, we have to place an inverter at each input of the 
ﬂ ip-ﬂ op. The resulting circuit is shown in Figure 7.11, which behaves in the same manner 
as an S-R ﬂ ip-ﬂ op.
7.4  CLOCKED S-R FLIP-FLOP
Generally, synchronous circuits change their states only when clock pulses are present. The 
operation of the basic ﬂ ip-ﬂ op can be modiﬁ ed by including an additional input to control 
the behaviour of the circuit. Such a circuit is shown in Figure 7.12.
The circuit shown in Figure 7.12 consists of two AND gates. The clock input is connected 
to both of the AND gates, resulting in LOW outputs when the clock input is LOW. In this 
situation the changes in S and R inputs will not affect the state (Q) of the ﬂ ip-ﬂ op. On the 
other hand, if the clock input is HIGH, the changes in S and R will be passed over by the
S'
S
Q
Q'
R'
R
3
4
1
2

222
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 7.12 Block diagram of a clocked S-R ﬂ ip-ﬂ op.
AND gates and they will cause changes in the output (Q) of the ﬂ ip-ﬂ op. This way, any 
information, either 1 or 0, can be stored in the ﬂ ip-ﬂ op by applying a HIGH clock input 
and be retained for any desired period of time by applying a LOW at the clock input. This 
type of ﬂ ip-ﬂ op is called a clocked S-R ﬂ ip-ﬂ op. Such a clocked S-R ﬂ ip-ﬂ op made up of two 
AND gates and two NOR gates is shown in Figure 7.13.
Figure 7.13 A clocked NOR-based S-R ﬂ ip-ﬂ op.
Now the same S-R ﬂ ip-ﬂ op can be constructed using the basic NAND latch and two 
other NAND gates as shown in Figure 7.14. The S and R inputs control the states of the 
ﬂ ip-ﬂ op in the same way as described earlier for the unclocked S-R ﬂ ip-ﬂ op. However, the 
ﬂ ip-ﬂ op only responds when the clock signal occurs. The clock pulse input acts as an enable 
signal for the other two inputs. As long as the clock input remains 0 the outputs of NAND 
gates 1 and 2 stay at logic 1. This 1 level at the inputs of the basic NAND-based S-R ﬂ ip-
ﬂ op retains the present state.
Figure 7.14 A clocked NAND-based S-R ﬂ ip-ﬂ op.
The logic symbol of the S-R ﬂ ip-ﬂ op is shown in Figure 7.15. It has three inputs: S, R, 
and CLK. The CLK input is marked with a small triangle. The triangle is a symbol that 
denotes the fact that the circuit responds to an edge or transition at CLK input.
Q
S
S-R flip-flop
Q'
R
R
CLK
S
CLK
R
S
1
3
2
4
Q
Q'
CLK
S
R
1
3
2
4
Q
Q'

SEQUENTIAL LOGIC CIRCUITS 223
Assuming that the inputs do not change during 
the presence of the clock pulse, we can express the 
working of the S-R ﬂ ip-ﬂ op in the form of the truth 
table in Figure 7.16. Here, Sn and Rn denote the inputs 
and Qn the output during the bit time n (Figure 7.2). 
Qn+1 denotes the output after the pulse passes, i.e., in 
the bit time n + 1.
Inputs 
Output
 
Sn 
Rn 
Qn+1
 
0 
0 
Qn
 
0 
1 
0
 
1 
0 
1
 
1 
1 
–
Figure 7.16
Case 1. If Sn = Rn = 0, and the clock pulse is not applied, the output of the ﬂ ip-ﬂ op 
remains in the present state. Even if Sn = Rn = 0, and the clock pulse is applied, the output 
at the end of the clock pulse is the same as the output before the clock pulse, i.e., Qn+1 = 
Qn. The ﬁ rst row of the table indicates that situation.
Case 2. For Sn = 0 and Rn = 1, if the clock pulse is applied (i.e., CLK = 1), the output 
of NAND gate 1 becomes 1; whereas the output of NAND gate 2 will be 0. Now a 0 at the 
input of NAND gate 4 forces the output to be 1, i.e., Q' = 1. This 1 goes to the input of 
NAND gate 3 to make both the inputs of NAND gate 3 as 1, which forces the output of 
NAND gate 3 to be 0, i.e., Q = 0.
Case 3. For Sn = 1 and Rn = 0, if the clock pulse is applied (i.e., CLK = 1), the output 
of NAND gate 2 becomes 1; whereas the output of NAND gate 1 will be 0. Now a 0 at 
the input of NAND gate 3 forces the output to be 1, i.e., Q = 1. This 1 goes to the input 
of NAND gate 4 to make both the inputs of NAND gate 4 as 1, which forces the output of 
NAND gate 4 to be 0, i.e., Q' = 0.
Case 4. For Sn = 1 and Rn = 1, if the clock pulse is applied (i.e., CLK = 1), the outputs 
of both NAND gate 2 and NAND gate 1 becomes 0. Now a 0 at the input of both NAND gate 
3 and NAND gate 4 forces the outputs of both the gates to be 1, i.e., Q = 1 and Q' = 1. When 
the CLK input goes back to 0 (while S and R remain at 1), it is not possible to determine 
the next state, as it depends on whether the output of gate 1 or gate 2 goes to 1 ﬁ rst.
7.4.1  Preset and Clear
In the ﬂ ip-ﬂ ops shown in Figures 7.13 or ﬁ gure 7.14, when the power is switched on, 
the state of the circuit is uncertain. It may come to reset (Q = 0) or set (Q = 1) state. But 
in many applications it is required to initially set or reset the ﬂ ip-ﬂ op., i.e., the initial state 
of the ﬂ ip-ﬂ op is to be assigned. This is done by using the direct or asynchronous inputs. 
These inputs are referred to as preset (Pr) and clear (Cr) inputs. These inputs may be applied 
at any time between clock pulses and is not in synchronism with the clock. Such an S-R 
ﬂ ip-ﬂ op containing preset and clear inputs is shown in Figure 7.17. From Figure 7.17, we 
see that if Pr = Cr = 1, the circuit operates according to the table in Figure 7.16.
Figure 7.15 Logic symbol of 
a clocked S-R ﬂ ip-ﬂ op.
Q
S
CLK
Q'
R

224
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 7.17 An S-R ﬂ ip-ﬂ op with preset and clear.
If Pr = 1 and Cr = 0, the output of NAND gate 4 is forced to be 1, i.e., Q' = 1 and 
the ﬂ ip-ﬂ op is reset, overwriting the previous state of the ﬂ ip-ﬂ op.
If Pr = 0 and Cr = 1, the output of NAND gate 3 is forced to be 1, i.e., Q = 1 and the 
ﬂ ip-ﬂ op is set, overwriting the previous state of the ﬂ ip-ﬂ op. Once the state of the ﬂ ip-ﬂ op 
is established asynchronously, the inputs Pr and Cr must be connected to logic 1 before 
the next clock is applied. 
The condition Pr = Cr = 0 must not be applied, since this leads to an uncertain 
state.
The logic symbol of an S-R ﬂ ip-ﬂ op with Pr and 
Cr inputs is shown in Figure 7.18. Here, bubbles 
are used for Pr and Cr inputs, which indicate 
these are active low inputs, which means that the 
intended function is performed if the signal applied 
to Pr and Cr is LOW. The operation of Figure 7.18 
is shown in the table in Figure 7.19. The circuit 
can be designed such that the asynchronous inputs 
override the clock, i.e., the circuit can be set or reset 
even in the presence of the clock pulse.
 
Inputs 
 
Output 
Operation
 
CLK 
Cr 
Pr 
Q 
performed 
 
1 
1 
1 
Qn+1 (Figure 7.3) 
Normal ﬂ ip-ﬂ op
 
0 
1 
0 
1 
Preset
 
0 
0 
1 
0 
Clear
 
0 
0 
0 
– 
Uncertain
Figure 7.19
7.4.2  Characteristic Table of an S-R Flip-ﬂ op
From the name itself it is very clear that the characteristic table of a ﬂ ip-ﬂ op actually 
gives us an idea about the character, i.e., the working of the ﬂ ip-ﬂ op. Now, from all our 
above discussions, we know that the next state ﬂ ip-ﬂ op output (Qn+1) depends on the present 
Figure 7.18 Logic symbol of an S-R 
ﬂ ip-ﬂ op with preset and clear.
Clear (Cr)
Preset (Pr)
S
1
3
QQ
Q'
2
4
CLK
R
Q
S
CLK
Q'
R
Cr
Pr

SEQUENTIAL LOGIC CIRCUITS 225
inputs as well as the present output (Qn). So in order to know the next state output of a 
ﬂ ip-ﬂ op, we have to consider the present state output also. The characteristic table of an 
S-R ﬂ ip-ﬂ op is given in the table in Figure 7.20. From the characteristic table we have to 
ﬁ nd out the characteristic equation of the S-R ﬂ ip-ﬂ op. 
Flip-ﬂ op inputs 
Present output 
Next output 
 
S 
R 
Qn 
Qn+1
 
0 
0 
0 
0
 
0 
0 
1 
1
 
0 
1 
0 
0
 
0 
1 
1 
0
 
1 
0 
0 
1
 
1 
0 
1 
1
 
1 
1 
0 
X
 
1 
1 
1 
X
Figure 7.20
Now we will ﬁ nd out the characteristic equation of the S-R ﬂ ip-ﬂ op from the characteristic 
table with the help of the Karnaugh map in Figure 7.21.
Figure 7.21
From the Karnaugh map above we ﬁ nd the expression for Qn=1 as
 
 
 
Qn+1 = S + R'Qn. 
(7.1)
Along with the above equation we have to consider the fact that S and R cannot be 
simultaneously 0. In order to take that fact into account we have to incorporate another 
equation for the S-R ﬂ ip-ﬂ op. The equation is given below.
 
 
 
SR = 0 
(7.2)
Hence the characteristic equations of an S-R ﬂ ip-ﬂ op are
 
 
 
Qn+1 = S + R'Qn
 
 
 
SR = 0.
7.5  CLOCKED D FLIP-FLOP
The D ﬂ ip-ﬂ op has only one input referred to as the D input, or data input, and two outputs 
as usual Q and Q'. It transfers the data at the input after the delay of one clock pulse at 
0
1
0
0
X
X
1
1
00
0
1
01
11
10
RQ n
R'Q n
S
S

226
DIGITAL PRINCIPLES AND LOGIC DESIGN
the output Q. So in some cases the input is referred to as a delay input and the ﬂ ip-ﬂ op 
gets the name delay (D) ﬂ ip-ﬂ op. It can be easily constructed from an S-R ﬂ ip-ﬂ op by simply 
incorporating an inverter between S and R such that the input of the inverter is at the S end 
and the output of the inverter is at the R end. We can get rid of the undeﬁ ned condition, i.e.,
S = R = 1 condition, of the S-R ﬂ ip-ﬂ op in the D ﬂ ip-ﬂ op. The D ﬂ ip-ﬂ op is either used as a 
delay device or as a latch to store one bit of binary information. The truth table of D ﬂ ip-
ﬂ op is given in the table in Figure 7.23. The structure of the D ﬂ ip-ﬂ op is shown in Figure 
7.22, which is being constructed using NAND gates. The same structure can be constructed 
using only NOR gates.
Figure 7.22 A D ﬂ ip-ﬂ op using NAND gates.
Input 
Output
 
Dn 
Qn+1
 
0 
0
 
1 
1
Figure 7.23
Case 1. If the CLK input is low, the value of the D input has no effect, since the S 
and R inputs of the basic NAND ﬂ ip-ﬂ op are kept as 1.
Case 2. If the CLK = 1, and D = 1, the NAND gate 1 produces 0, which forces the 
output of NAND gate 3 as 1.  On the other hand, both the inputs of NAND gate 2 are 
1, which gives the output of gate 2 as 0. Hence, the output of NAND gate 4 is forced to 
be 1, i.e., Q = 1, whereas both the inputs of gate 5 are 1 and the output is 0, i.e., Q' = 
0. Hence, we ﬁ nd that when D = 1, after one clock pulse passes Q = 1, which means the 
output follows D.
Figure 7.24(a) An S-R ﬂ ip-ﬂ op 
converted into a D ﬂ ip-ﬂ op.
Figure 7.24 (b) the logic 
symbol of a D ﬂ ip-ﬂ op.
S
Q
Q'
R
1
3
2
4
5
CLK
D
S                 Q
R                 Q'
D
CLK
Cr
Pr
D                 Q
Q'
D
CLK
Cr
Pr

SEQUENTIAL LOGIC CIRCUITS 227
Case 3. If the CLK = 1, and D = 0, the NAND gate 1 produces 1. Hence both the 
inputs of NAND gate 3 are 1, which gives the output of gate 3 as 0. On the other hand, D 
= 0 forces the output of NAND gate 2 to be 1. Hence the output of NAND gate 5 is forced 
to be 1, i.e., Q' = 1, whereas both the inputs of gate 4 are 1 and the output is 0, i.e., Q = 
0. Hence, we ﬁ nd that when D = 0, after one clock pulse passes Q = 0, which means the 
output again follows D.
A simple way to construct a D ﬂ ip-ﬂ op using an S-R ﬂ ip-ﬂ op is shown in Figure 7.24(a).
The logic symbol of a D ﬂ ip-ﬂ op is shown in Figure 7.24(b). A D ﬂ ip-ﬂ op is most often used 
in the construction of sequential circuits like registers.
7.5.1  Preset and Clear
In the ﬂ ip-ﬂ ops shown in Figure 7.22, we can incorporate two asynchronous inputs 
in order to initially set or reset the ﬂ ip-ﬂ op, i.e., in order to assign the initial state of the 
ﬂ ip-ﬂ op. These inputs are referred to as preset (Pr) and clear (Cr) inputs as we did in the 
case of S-R ﬂ ip-ﬂ ops. These inputs may be applied at any time between clock pulses and 
is not in synchronism with the clock. Such a D ﬂ ip-ﬂ op containing preset and clear inputs 
is shown in Figure 7.25. From Figure 7.25, we see that if Pr = Cr = 1, the circuit operates 
according to the table in Figure 7.23.
If Pr = 1 and Cr = 0, the output of NAND gate 5 is forced to be 1, i.e., Q' = 1 and 
the ﬂ ip-ﬂ op is reset, overwriting the previous state of the ﬂ ip-ﬂ op. 
If Pr = 0 and Cr = 1, the output of NAND gate 4 is forced to be 1, i.e., Q = 1 and the 
ﬂ ip-ﬂ op is set, overwriting the previous state of the ﬂ ip-ﬂ op. Once the state of the ﬂ ip-ﬂ op 
is established asynchronously, the inputs Pr and Cr must be connected to logic 1 before 
the next clock is applied. 
The condition Pr = Cr = 0 must not be applied, since this leads to an uncertain 
state.
Figure 7.25 A D-type ﬂ ip-ﬂ op with preset and clear.
The logic symbol of a D ﬂ ip-ﬂ op with Pr and Cr inputs is shown in Figure 7.24. 
Here, bubbles are used for Pr and Cr inputs, which indicate these are active low inputs, 
which means that the intended function is performed if the signal applied to Pr and Cr is 
LOW. The operation of Figure 7.25 is shown in the table in Figure 7.26. The circuit can be 
designed such that the asynchronous inputs override the clock, i.e., the circuit can be set 
or reset even in the presence of the clock pulse.
5
4
Q'
Q
Pr
Cr
3
1
2
CLK
D

228
DIGITAL PRINCIPLES AND LOGIC DESIGN
Inputs 
 
Output 
Operation
 
CLK 
Cr 
Pr 
Q 
performed 
 
1 
1 
1 
Qn+1 
Normal ﬂ ip-ﬂ op
 
0 
1 
0 
1 
Preset
 
0 
0 
1 
0 
Clear
 
0 
0 
0 
– 
Uncertain
Figure 7.26
7.5.2  Characteristic Table of a D Flip-ﬂ op
As we have already discussed the characteristic equation of an S-R ﬂ ip-ﬂ op, we can 
similarly ﬁ nd out the characteristic equation of a D ﬂ ip-ﬂ op. The characteristic table of a 
D ﬂ ip-ﬂ op is given in the table in Figure 7.27. From the characteristic table we have to 
ﬁ nd out the characteristic equation of the D ﬂ ip-ﬂ op. 
Flip-ﬂ op inputs 
Present output 
Next output 
 
D 
Qn 
Qn+1
 
0 
0 
0
 
0 
1 
0
 
1 
0 
1
 
1 
1 
1
Figure 7.27
Now we will ﬁ nd out the characteristic equation of the D ﬂ ip-ﬂ op from the characteristic 
table with the help of the Karnaugh map in Figure 7.28.
Figure 7.28
From the map, we obtain
 
 
 
Qn+1 = D. 
(7.3)
Hence, the characteristic equation of a D ﬂ ip-ﬂ op is
 
 
 
Qn+1 = D.
7.6  J-K FLIP-FLOP
A J-K ﬂ ip-ﬂ op has very similar characteristics to an S-R ﬂ ip-ﬂ op. The only difference is 
that the undeﬁ ned condition for an S-R ﬂ ip-ﬂ op, i.e., Sn = Rn = 1 condition, is also included 
0
0
1
1
0
0
1
1
Q n
D
D

SEQUENTIAL LOGIC CIRCUITS 229
in this case. Inputs J and K behave like inputs S and R to set and reset the ﬂ ip-ﬂ op 
respectively. When J = K = 1, the ﬂ ip-ﬂ op is said to be in a toggle state, which means the 
output switches to its complementary state every time a clock passes.
The data inputs are J and K, which are ANDed with Q' and Q respectively to obtain 
the inputs for S and R respectively. A J-K ﬂ ip-ﬂ op thus obtained is shown in Figure 7.29. 
The truth table of such a ﬂ ip-ﬂ op is given in Figure 7.32, which is reduced to Figure 7.33 
for convenience. 
Figure 7.29 An S-R ﬂ ip-ﬂ op converted into a J-K ﬂ ip-ﬂ op.
Figure 7.30 A J-K ﬂ ip-ﬂ op using NAND gates.
Figure 7.31 Logic symbol of a J-K ﬂ ip-ﬂ op.
S = JQ'
CLK
1
2
Pr
Cr
S-R
FF
R = KQ
P
J
Q
Q'
1
2
4
3
J
CLK
Q'
Q
R
Q
Q'
S
Pr
Cr
K
Q
Q'
J
K
CLK
J-K
FF
Cr
Pr

230
DIGITAL PRINCIPLES AND LOGIC DESIGN
It is not necessary to use the AND gates of Figure 7.29, since the same function can 
be performed by adding an extra input terminal to each of the NAND gates 1 and 2. With 
this modiﬁ cation incorporated, we get the J-K ﬂ ip-ﬂ op using NAND gates as shown in Figure 
7.30. The logic symbol of a J-K ﬂ ip-ﬂ op is shown in Figure 7.31.
Data inputs 
Outputs  
Inputs to S-R FF 
Output
 
Jn 
Kn 
Qn 
Q'n 
Sn 
Rn 
Qn+1
 
0 
0 
0 
1 
0 
0 
0
 
0 
0 
1 
0 
0 
0 
1
 
0 
1 
0 
1 
0 
0 
0
 
0 
1 
1 
0 
0 
1 
0
 
1 
0 
0 
1 
1 
0 
1
 
1 
0 
1 
0 
0 
0 
1
 
1 
1 
0 
1 
1 
0 
1
 
1 
1 
1 
0 
0 
1 
0
Figure 7.32
Case 1. When the clock is applied and J = 0, whatever the value of Q'n (0 or 1), the 
output of NAND gate 1 is 1. Similarly, when K = 0, whatever the value of Qn (0 or 1), the 
output of gate 2 is also 1. Therefore, when J = 0 and K = 0, the inputs to the basic ﬂ ip-ﬂ op 
are S = 1 and R = 1. This condition forces the ﬂ ip-ﬂ op to remain in the same state.
Inputs 
Output  
 
Jn 
Kn 
Qn+1
 
0 
0 
Qn
 
0 
1 
0
 
1 
0 
1
 
1 
1 
Q'n
Figure 7.33
Case 2. When the clock is applied and J = 0 and K = 1 and the previous state of the 
ﬂ ip-ﬂ op is reset (i.e., Qn = 0 and Q'n = 1), then S = 1 and R = 1. Since S = 1 and R = 1, 
the basic ﬂ ip-ﬂ op does not alter the state and remains in the reset state. But if the ﬂ ip-ﬂ op 
is in set condition (i.e., Qn = 1 and Q'n = 0), then S = 1 and R = 0. Since S = 1 and R = 0, 
the basic ﬂ ip-ﬂ op changes its state and resets.
Case 3. When the clock is applied and J = 1 and K = 0 and the previous state of the 
ﬂ ip-ﬂ op is reset (i.e., Qn = 0 and Q'n = 1), then S = 0 and R = 1. Since S = 0 and R = 1, 
the basic ﬂ ip-ﬂ op changes its state and goes to the set state. But if the ﬂ ip-ﬂ op is already 
in set condition (i.e., Qn = 1 and Q'n = 0), then S = 1 and R = 1. Since S = 1 and R = 1, 
the basic ﬂ ip-ﬂ op does not alter its state and remains in the set state.
Case 4. When the clock is applied and J = 1 and K = 1 and the previous state of the 
ﬂ ip-ﬂ op is reset (i.e., Qn = 0 and Q'n = 1), then S = 0 and R = 1. Since S = 0 and R = 1, 

SEQUENTIAL LOGIC CIRCUITS 231
the basic ﬂ ip-ﬂ op changes its state and goes to the set state. But if the ﬂ ip-ﬂ op is already 
in set condition (i.e., Qn = 1 and Q'n = 0), then S = 1 and R = 0. Since S = 1 and R = 0, 
the basic ﬂ ip-ﬂ op changes its state and goes to the reset state. So we ﬁ nd that for J = 1 
and K = 1, the ﬂ ip-ﬂ op toggles its state from set to reset and vice versa. Toggle means to 
switch to the opposite state. 
7.6.1  Characteristic Table of a J-K Flip-ﬂ op
As we have already discussed the characteristic equation of an S-R ﬂ ip-ﬂ op, we can 
similarly ﬁ nd out the characteristic equation of a J-K ﬂ ip-ﬂ op. The characteristic table of 
a J-K ﬂ ip-ﬂ op is given in the table in Figure 7.34. From the characteristic table we have 
to ﬁ nd out the characteristic equation of the J-K ﬂ ip-ﬂ op.
Flip-ﬂ op inputs 
Present output 
Next output 
 
J 
K 
Qn 
Qn+1
 
0 
0 
0 
0
 
0 
0 
1 
1
 
0 
1 
0 
0
 
0 
1 
1 
0
 
1 
0 
0 
1
 
1 
0 
1 
1
 
1 
1 
0 
1
 
1 
1 
1 
0
Figure 7.34
Now we will ﬁ nd out the characteristic equation of the J-K ﬂ ip-ﬂ op from the characteristic 
table with the help of the Karnaugh map in Figure 7.35.
Figure 7.35
From the Karnaugh map, we obtain
 
 
 
Qn+1 = JQ'n + K'Qn. 
(7.4)
Hence, the characteristic equation of a J-K ﬂ ip-ﬂ op is
 
 
 
Qn+1 = JQ'n + K'Qn.
7.6.2  Race-around Condition of a J-K Flip-ﬂ op
The inherent difﬁ culty of an S-R ﬂ ip-ﬂ op (i.e., S = R = 1) is eliminated by using the 
feedback connections from the outputs to the inputs of gate 1 and gate 2 as shown in Figure 
0
1
0
0
1
0
1
1
00
0
1
01
11
10
KQ n
K'Q n
J
JQ'n

232
DIGITAL PRINCIPLES AND LOGIC DESIGN
7.30. Truth tables in Figure 7.32 and Figure 7.33 were formed with the assumption that 
the inputs do not change during the clock pulse (CLK = 1). But the consideration is not 
true because of the feedback connections.
Figure 7.36 A clock pulse.
Consider, for example, that the inputs are J = K = 1 and Q = 1, and a pulse as shown 
in Figure 7.36 is applied at the clock input. After a time interval 't equal to the propagation 
delay through two NAND gates in series, the outputs will change to Q = 0. So now we 
have J = K = 1 and Q = 0. After another time interval of 't the output will change back 
to Q = 1. Hence, we conclude that for the time duration of tP of the clock pulse, the output 
will oscillate between 0 and 1. Hence, at the end of the clock pulse, the value of the output 
is not certain. This situation is referred to as a race-around condition.
Generally, the propagation delay of TTL gates is of the order of nanoseconds. So if the 
clock pulse is of the order of microseconds, then the output will change thousands of times 
within the clock pulse. This race-around condition can be avoided if tp< 't < T. Due to the small 
propagation delay of the ICs it may be difﬁ cult to satisfy the above condition. A more practical 
way to avoid the problem is to use the master-slave (M-S) conﬁ guration as discussed below.
7.6.3  Master-Slave J-K Flip-ﬂ op
A master-slave (M-S) ﬂ ip-ﬂ op is shown in Figure 7.37. Basically, a master-slave ﬂ ip-ﬂ op 
is a system of two ﬂ ip-ﬂ ops—one being designated as master and the other is the slave.
From the ﬁ gure we see that a clock pulse is applied to the master and the inverted form 
of the same clock pulse is applied to the slave. 
Figure 7.37 A master-slave J-K ﬂ ip-ﬂ op.
When CLK = 1, the ﬁ rst ﬂ ip-ﬂ op (i.e., the master) is enabled and the outputs Qm and 
Q'm respond to the inputs J and K according to the table shown in Figure 7.13. At this time 
the second ﬂ ip-ﬂ op (i.e., the slave) is disabled because the CLK is LOW to the second ﬂ ip-
Tp
Leading or positive edge
Trailing or negative edge
∆t
0
T
Slave
M aster
Cr
R s
4
3
2
1
J
P
CLK
Q m
5
7
Q
Q'
8
6
Pr
S s
Q'm

SEQUENTIAL LOGIC CIRCUITS 233
ﬂ op. Similarly, when CLK becomes LOW, the master becomes disabled and the slave becomes 
active, since now the CLK to it is HIGH. Therefore, the outputs Q and Q' follow the outputs 
Qm and Q'm respectively. Since the second ﬂ ip-ﬂ op just follows the ﬁ rst one, it is referred 
to as a slave and the ﬁ rst one is called the master. Hence, the conﬁ guration is referred to 
as a master-slave (M-S) ﬂ ip-ﬂ op. 
In this type of circuit conﬁ guration the inputs to the gates 5 and 6 do not change at the 
time of application of the clock pulse. Hence the race-around condition does not exist. The 
state of the master-slave ﬂ ip-ﬂ op, shown in Figure 7.37, changes at the negative transition 
(trailing edge) of the clock pulse. Hence, it becomes negative triggering a master-slave ﬂ ip-
ﬂ op. This can be changed to a positive edge triggering ﬂ ip-ﬂ op by adding two inverters to 
the system—one before the clock pulse is applied to the master and an additional one in 
between the master and the slave. The logic symbol of a negative edge master-slave is shown 
in Figure 7.38. 
The system of master-slave ﬂ ip-ﬂ ops is not restricted to J-K master-slave only. There 
may be an S-R master-slave or a D master-slave, etc., in all of them the slave is an S-R 
ﬂ ip-ﬂ op, whereas the master changes to J-K or S-R or D ﬂ ip-ﬂ ops.  
Figure 7.38 A negative edge-transition master-slave J-K ﬂ ip-ﬂ op.
7.7  T FLIP-FLOP
With a slight modiﬁ cation of a J-K ﬂ ip-ﬂ op, we can construct a new ﬂ ip-ﬂ op called a T ﬂ ip-
ﬂ op. If the two inputs J and K of a J-K ﬂ ip-ﬂ op are tied together it is referred to as a T 
ﬂ ip-ﬂ op. Hence, a T ﬂ ip-ﬂ op has only one input T and two outputs Q and Q'. The name T 
ﬂ ip-ﬂ op actually indicates the fact that the ﬂ ip-ﬂ op has the ability to toggle. It has actually 
only two states—toggle state and memory state. Since there are only two states, a T ﬂ ip-
ﬂ op is a very good option to use in counter design and in sequential circuits design where 
switching an operation is required. The truth table of a T ﬂ ip-ﬂ op is given in Figure 7.39.
T 
Qn 
Qn+1
 
0 
0 
0
 
0 
1 
1
 
1 
0 
1
 
1 
1 
0
Figure 7.39
If the T input is in 0 state (i.e., J = K = 0) prior to a clock pulse, the Q output will not 
change with the clock pulse.  On the other hand, if the T input is in 1 state (i.e., J = K = 1) 
Q
Q'
J
K
CLK
Cr
Pr

234
DIGITAL PRINCIPLES AND LOGIC DESIGN
prior to a clock pulse, the Q output will change to Q' with the clock pulse. In other words, 
we may say that, if T = 1 and the device is clocked, then the output toggles its state.
The truth table shows that when T = 0, then Qn+1 = Qn, i.e., the next state is the same 
as the present state and no change occurs. When T = 1, then Qn+1 = Q'n, i.e., the state of 
the ﬂ ip-ﬂ op is complemented. The circuit diagram of a T ﬂ ip-ﬂ op is shown in Figure 7.40 
and the block diagram of the ﬂ ip-ﬂ op is shown in Figure 7.41.
Figure 7.40 A T ﬂ ip-ﬂ op.
 
Figure 7.41(a) A J-K ﬂ ip-ﬂ op converted into a  
Figure 7.41(b) the logic symbol of a 
 
T ﬂ ip-ﬂ op. 
T ﬂ ip-ﬂ op.
7.7.1  Characteristic Table of a T Flip-ﬂ op
As we have already discussed the characteristic equation of a J-K ﬂ ip-ﬂ op, we can 
similarly ﬁ nd out the characteristic equation of a T ﬂ ip-ﬂ op. The characteristic table of a 
T ﬂ ip-ﬂ op is given in Figure 7.42. From the characteristic table we have to ﬁ nd out the 
characteristic equation of the T ﬂ ip-ﬂ op.
Flip-ﬂ op inputs 
Present output 
Next output 
 
T 
Qn 
Qn+1
 
0 
0 
0
 
0 
1 
1
 
1 
0 
1
 
1 
1 
0
Figure 7.42
T
Pr
Cr
Q'
Q
CLK
Q
Q'
T
J
K
CLK
Cr
J-K
FF
Pr
Q
Q'
T
CLK
Cr
T
FF
Pr

SEQUENTIAL LOGIC CIRCUITS 235
Now we will ﬁ nd out the characteristic equation of the T ﬂ ip-ﬂ op from the characteristic 
table with the help of the Karnaugh map in Figure 7.43.
Figure 7.43
From the Karnaugh map, the Boolean expression of Qn+1 is derived as
 
 
 
Qn+1 = TQ'n + T'Qn. 
(7.5)
Hence, the characteristic equation of a T ﬂ ip-ﬂ op is
 
 
 
Qn+1 = TQ'n + T'Qn.
7.8  TOGGLING MODE OF S-R AND D FLIP-FLOPS
Though an S-R ﬂ ip-ﬂ op cannot be converted into a T ﬂ ip-ﬂ op since S = R = 1 is not allowed, 
but an S-R ﬂ ip-ﬂ op can be made to work in toggle mode, where the output Q changes with 
every clock pulse. The circuit is shown in Figure 7.44. The toggle mode of operation for a 
D ﬂ ip-ﬂ op is also shown in Figure 7.45.
 
Figure 7.44  An S-R ﬂ ip-ﬂ op in toggle mode. 
Fig 7.45 A D ﬂ ip-ﬂ op in toggle mode.
If at any instant, Q = 1 and Q' = 0, then S = 0 and R = 1. Hence, with the clock pulse 
the S-R ﬂ ip-ﬂ op gets reset, i.e., Q = 0 and Q' = 1. Again, if at any instant, Q=0 and Q' = 1, 
then S = 1 and R = 0. Hence, with the clock pulse the S-R ﬂ ip-ﬂ op gets set, i.e., Q = 1 and 
Q' = 0. Hence, the ﬂ ip-ﬂ op acts like a toggle ﬂ ip-ﬂ op where the output is changing with 
each clock pulse.
Similarly, for a D ﬂ ip-ﬂ op, if at any instant, Q = 1 and Q' = 0, then D = 0. Hence, with 
the clock pulse the D ﬂ ip-ﬂ op gets reset, i.e., Q = 0 and Q' = 1. Again, if at any instant, 
Q = 0 and Q' = 1, then D = 1. Hence, with the clock pulse the D ﬂ ip-ﬂ op gets set, i.e., Q = 1 
and Q' = 0. Hence, the ﬂ ip-ﬂ op acts like a toggle ﬂ ip-ﬂ op where the output is changing 
with each clock pulse.
7.9  TRIGGERING OF FLIP-FLOPS
Flip-ﬂ ops are synchronous sequential circuits. This type of circuit works with the application 
of a synchronization mechanism, which is termed as a clock. Based on the speciﬁ c interval 
0
1
0
1
0
0
1
1
Q n
T
Q
S
Q'
R
CLK
S-R
FF
Q
D
Q'
CLK
D
FF

236
DIGITAL PRINCIPLES AND LOGIC DESIGN
or point in the clock during or at which triggering of the ﬂ ip-ﬂ op takes place, it can be 
classiﬁ ed into two different types—level triggering and edge triggering.
A clock pulse starts from an initial value of 0, goes momentarily to 1, and after a short 
interval, returns to the initial value.
7.9.1  Level Triggering of Flip-ﬂ ops
If a ﬂ ip-ﬂ op gets enabled when a clock pulse goes HIGH and remains enabled throughout 
the duration of the clock pulse remaining HIGH, the ﬂ ip-ﬂ op is said to be a level triggered 
ﬂ ip-ﬂ op. If the ﬂ ip-ﬂ op changes its state when the clock pulse is positive, it is termed as a 
positive level triggered ﬂ ip-ﬂ op. On the other hand, if a NOT gate is introduced in the clock 
input terminal of the ﬂ ip-ﬂ op, then the ﬂ ip-ﬂ op changes its state when the clock pulse is 
negative, it is termed as a negative level triggered ﬂ ip-ﬂ op.
The main drawback of level triggering is that, as long as the clock pulse is active, the 
ﬂ ip-ﬂ op changes its state more than once or many times for the change in inputs. If the 
inputs do not change during one clock pulse, then the output remains stable. On the other 
hand, if the frequency of the input change is higher than the input clock frequency, the 
output of the ﬂ ip-ﬂ op undergoes multiple changes as long as the clock remains active. This 
can be overcome by using either master-slave ﬂ ip-ﬂ ops or the edge-triggered ﬂ ip-ﬂ op. 
7.9.2  Edge-triggering of Flip-ﬂ ops
A clock pulse goes from 0 to 1 and then returns from 1 to 0. Figure 7.46 shows the 
two transitions and they are deﬁ ned as the positive edge (0 to 1 transition) and the negative
edge (1 to 0 transition). The term edge-triggered means that the ﬂ ip-ﬂ op changes its state 
only at either the positive or negative edge of the clock pulse.
Figure 7.46 Clock pulse transition.
Figure 7.47 RC differentiator circuit for edge triggering.
One way to make the ﬂ ip-ﬂ op respond to only the edge of the clock pulse is to use 
capacitive coupling. An RC circuit is shown in Figure 7.47, which is inserted in the clock 
input of the ﬂ ip-ﬂ op. By deliberate design, the RC time constant is made much smaller 
0
1
Positive pulse
Negative pulse
Positive edge, Negative edge
Negative edge, Positive edge
C
0
1
R

SEQUENTIAL LOGIC CIRCUITS 237
than the clock pulse width. The capacitor can charge fully when the clock goes HIGH. This 
exponential charging produces a narrow positive spike across the resistor. Later, the trailing 
edge of the pulse results in a narrow negative spike. The circuit is so designed that one of 
the spikes (either the positive or negative) is neglected and the edge triggering occurs due 
to the other spike.
7.10  EXCITATION TABLE OF A FLIP-FLOP
The truth table of a ﬂ ip-ﬂ op is also referred to as the characteristic table of a ﬂ ip-ﬂ op, 
since this table refers to the operational characteristics of the ﬂ ip-ﬂ op. But in designing 
sequential circuits, we often face situations where the present state and the next state of 
the ﬂ ip-ﬂ op is speciﬁ ed, and we have to ﬁ nd out the input conditions that must prevail for 
the desired output condition. By present and next states we mean to say the conditions 
before and after the clock pulse respectively. For example, the output of an S-R ﬂ ip-ﬂ op 
before the clock pulse is Qn = 1 and it is desired that the output does not change when 
the clock pulse is applied. 
Now from the characteristic table of an S-R ﬂ ip-ﬂ op (Figure 7.20), we obtain the 
following conditions:
 
1. S = R = 0 (second row)
 
2. S = 1, R = 0 (sixth row).
We come to the conclusion from the above conditions that the R input must be 0, 
whereas the S input may be 0 or 1 (i.e., don’t-care). Similarly, for all possible situations, the 
input conditions can be found out. A tabulation of these conditions is known as an excitation
table. The table in Figure 7.48 gives the excitation table for S-R, D, J-K, and T ﬂ ip-ﬂ ops. 
These conditions are derived from the corresponding characteristic tables of the ﬂ ip-ﬂ ops. 
Present 
Next 
S-R FF 
D-FF 
J-K FF 
T-FF
 
State (Qn) 
State (Qn+1) 
Sn 
Rn 
Dn 
Jn 
Kn 
Tn
 
0 
0 
0 
X 
0 
0 
X 
0
 
0 
1 
1 
0 
1 
1 
X 
1
 
1 
0 
0 
1 
0 
X 
1 
1
 
1 
1 
X 
0 
1 
X 
0 
0
Figure 7.48 Excitation table of different ﬂ ip-ﬂ ops.
7.11  INTERCONVERSION OF FLIP-FLOPS
In many applications, we are being given a type of ﬂ ip-ﬂ op, whereas we may require some 
other type. In such cases we may have to convert the given ﬂ ip-ﬂ op to our required ﬂ ip-
ﬂ op. Now we may follow a general model for such conversions of ﬂ ip-ﬂ ops. The model is 
shown in Figure 7.49.
From the model we see that it is required to design the conversion logic for converting 
new input deﬁ nitions into input codes that will cause the given ﬂ ip-ﬂ op to work like the 
desired ﬂ ip-ﬂ op.  To design the conversion logic we need to combine the excitation table 
for both ﬂ ip-ﬂ ops and make a truth table with data input(s) and Q as the inputs and the 
input(s) of the given ﬂ ip-ﬂ op as the output(s). 

238
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 7.49 General model for conversion of one type of ﬂ ip-ﬂ op to another type
7.11.1  Conversion of an S-R Flip-ﬂ op to a D Flip-ﬂ op
The excitation tables of S-R and D ﬂ ip-ﬂ ops are given in the table in Figure 7.48 from 
which we make the truth table given in Figure 7.50.
FF data inputs 
Output 
S-R FF inputs 
 
D 
Q 
S 
R
 
0 
0 
0 
X
 
1 
0 
1 
0
 
0 
1 
0 
1
 
1 
1 
X 
0
Figure 7.50
From the table in Figure 7.50, we make the Karnaugh maps for inputs S and R as 
shown in Figure 7.51(a) and Figure 7.51(b).
Figure 7.51(a) 
Figure 7.51(b)
Simplifying with the help of the Karnaugh maps, we obtain   S = D and R = D'.
Hence the circuit may be designed as in Figure 7.52.
Figure 7.52 A D ﬂ ip-ﬂ op using an S-R ﬂ ip-ﬂ op.
Flip-flop
conversion
logic
Given
Flip-flop
Q
Flip-flop
Q'
Data Inputs
0
0
X
1
0
0
1
1
Q
D
D
For S
X
1
0
0
0
0
1
1
Q
D'
D
For R
Q
Q'
D
S
R

SEQUENTIAL LOGIC CIRCUITS 239
7.11.2  Conversion of an S-R Flip-ﬂ op to a J-K Flip-ﬂ op
The excitation tables of S-R and J-K ﬂ ip-ﬂ ops are given in the table in Figure 7.48 
from which we make the truth table given in Figure 7.53.
FF data inputs 
Output 
S-R FF inputs 
 
J 
K 
Q 
S 
R 
 
0 
0 
0 
0 
X
 
0 
1 
0 
0 
X
 
1 
0 
0 
1 
0
 
1 
1 
0 
1 
0
 
0 
1 
1 
0 
1
 
1 
1 
1 
0 
1
 
0 
0 
1 
X 
0
 
1 
0 
1 
X 
0
Figure 7.53
From the truth table in Figure 7.53, the Karnaugh map is prepared as shown in Figure 
7.54(a) and Figure 7.54(b).
 
Figure 7.54(a)
Figure 7.54(b)
Hence we get the Boolean expression for S and R as
 
 
S = JQ'
and 
 
R = KQ.
Hence the circuit may be realized as in Figure 7.55.
Figure 7.55 A J-K ﬂ ip-ﬂ op using an S-R ﬂ ip-ﬂ op.
0
X
0
0
1
0
X
1
00
0
1
01
11
10
KQ
J
JQ'
For S
X
0
1
X
0
1
0
0
00
0
1
01
11
10
KQ
J
KQ
For R
1
2
K
J
Q
S
Q'
R

240
DIGITAL PRINCIPLES AND LOGIC DESIGN
7.11.3  Conversion of an S-R Flip-ﬂ op to a T Flip-ﬂ op
The excitation tables of S-R and T ﬂ ip-ﬂ ops are given in Figure 7.48 from which we 
make the truth table given in Figure 7.56.
FF data inputs 
Output 
S-R FF inputs 
 
T 
Q 
S 
R
 
0 
0 
0 
X
 
1 
0 
1 
0
 
1 
1 
0 
1
 
0 
1 
X 
0
Figure 7.56
From the table in Figure 7.56, we prepare the Karnaugh maps as per Figure 7.57(a)
and Figure 7.57(b).
Figure 7.57(a) 
Figure 7.57(b)
Hence we get,
 
 
S = TQ'
and 
 
R = TQ.
Hence the circuit may be designed as in Figure 7.58.
Figure 7.58 A T ﬂ ip-ﬂ op using an S-R ﬂ ip-ﬂ op.
7.11.4  Conversion of a D Flip-ﬂ op to an S-R Flip-ﬂ op
The excitation tables of S-R and D ﬂ ip-ﬂ ops are given in the table in Figure 7.48 from 
which we derive the truth table in Figure 7.59.
0
X
0
1
0
0
1
1
Q
TQ'
T
For S
X
0
1
0
0
0
1
1
Q
TQ
T
For R
T
Q
S
Q'
R

SEQUENTIAL LOGIC CIRCUITS 241
FF data inputs 
Output 
D FF inputs
 
S 
R 
Q 
D
 
0 
0 
0 
0
 
0 
1 
0 
0
 
1 
0 
0 
1
 
0 
1 
1 
0
 
0 
0 
1 
1
 
1 
0 
1 
1
Figure 7.59
The Karnaugh map is shown in Figure 7.60 according to the truth table in Figure 
7.59.
Figure 7.60
Hence we get
 
 
 
D = S + R'Q.
Hence the circuit may be realized as in Figure 7.61.
Figure 7.61 An S-R ﬂ ip-ﬂ op using a D ﬂ ip-ﬂ op.
7.11.5  Conversion of a D Flip-ﬂ op to a J-K Flip-ﬂ op
The excitation tables of J-K and D ﬂ ip-ﬂ ops are given in the table in Figure 7.48 from 
which we make the truth table given in Figure 7.62.
From the truth table in Figure 7.62, the Karnaugh map is drawn as in Figure 7.63.
0
1
1
0
X
X
1
1
00
0
1
01
11
10
RQ
S
R'Q
S
S
R
D
Q
Q'

242
DIGITAL PRINCIPLES AND LOGIC DESIGN
FF data inputs 
Output 
D FF inputs
 
J 
K 
Q 
D 
 
0 
0 
0 
0
 
0 
1 
0 
0
 
1 
0 
0 
1
 
1 
1 
0 
1
 
0 
1 
1 
0
 
1 
1 
1 
0
 
0 
0 
1 
1
 
1 
0 
1 
1
Figure 7.62
Figure 7.63
From the Karnaugh map above, the Boolean expression for D is derived as 
 
 
 
D = JQ' + K'Q.
Hence the circuit may be designed as in Figure 7.64.
Figure 7.64 A J-K ﬂ ip-ﬂ op using a D ﬂ ip-ﬂ op.
7.11.6  Conversion of a D Flip-ﬂ op to a T Flip-ﬂ op
The excitation tables of D and T ﬂ ip-ﬂ ops are given in the table in Figure 7.48 from 
which we derive the required truth table as given in Figure 7.65.
0
1
0
0
1
0
1
1
00
0
1
01
11
10
KQ
J
K'Q
JQ'
J
K
D
Q
Q'

SEQUENTIAL LOGIC CIRCUITS 243
From the truth table in Figure 7.65, we make the Karnaugh map in Figure 7.66.
FF data inputs 
Output 
D FF inputs 
 
T 
Q 
D 
 
0 
0 
0
 
1 
0 
1
 
1 
1 
0
 
0 
1 
1 
Figure 7.65
Figure 7.66
The Boolean expression we get is
 
 
 
D = TQ' + T'Q.
Hence the circuit may be designed as in Figure 7.67.
Figure 7.67 A T ﬂ ip-ﬂ op using a D ﬂ ip-ﬂ op.
7.11.7  Conversion of a J-K Flip-ﬂ op to a D Flip-ﬂ op
The excitation tables of J-K and D ﬂ ip-ﬂ ops are given in Figure 7.48 from which we 
make the truth table in Figure 7.68.
FF data inputs 
Output 
J-K FF inputs 
 
D 
Q 
J 
K 
 
0 
0 
0 
X
 
1 
0 
1 
X
 
0 
1 
X 
1
 
1 
1 
X 
0
Figure 7.68
0
1
0
1
0
0
1
1
Q
T Q
′
T
TQ'
T
T
Q
Q'

244
DIGITAL PRINCIPLES AND LOGIC DESIGN
The Karnaugh maps are prepared for J and K as in Figure 7.69(a) and Figure 
7.69(b).
 
Figure 7.69(a) 
Figure 7.69(b)
The Boolean expression for J and K are obtained as,
 
 
 
J = D
and 
 
 
K = D'.
Hence the circuit may be designed as in Figure 7.70.
Figure 7.70 A D ﬂ ip-ﬂ op using a J-K ﬂ ip-ﬂ op.
7.11.8  Conversion of a J-K Flip-ﬂ op to a T Flip-ﬂ op
The excitation tables of J-K and T ﬂ ip-ﬂ ops are given in Figure 7.48 from which the 
required truth table is derived in Figure 7.71.
FF data inputs 
Output 
J-K FF inputs 
 
T 
Q 
J 
K 
 
0 
0 
0 
X
 
1 
0 
1 
X
 
1 
1 
X 
1
 
0 
1 
X 
0
Figure 7.71
Figure 7.72(a) 
Figure 7.72(b)
0
X
X
1
0
0
1
1
Q
T
T
For J
X
0
1
X
0
0
1
1
Q
T
D
For K
J                 Q
K                Q'
D
0
X
X
1
0
0
1
1
Q
T
T
For J
X
0
1
X
0
0
1
1
Q
T
D
For K

SEQUENTIAL LOGIC CIRCUITS 245
The Karnaugh maps for J and K are prepared as in Figure 7.72(a) and Figure 7.72(b),
according to the truth table described above in Figure 7.71.
Hence we get,
 
 
 
J = T
and 
 
 
K = T.
The circuit may be realized as in Figure 7.73.
Figure 7.73 A T ﬂ ip-ﬂ op using a J-K ﬂ ip-ﬂ op.
7.11.9  Conversion of a T Flip-ﬂ op to an S-R Flip-ﬂ op
The truth table for the relation between S-R and T ﬂ ip-ﬂ ops is derived as in Figure 
7.74, from the excitation table mentioned in Figure 7.48.
FF data inputs 
Output 
D FF inputs
 
S 
R 
Q 
T
 
0 
0 
0 
0
 
0 
1 
0 
0
 
1 
0 
0 
1
 
0 
1 
1 
1
 
0 
0 
1 
0
 
1 
0 
1 
0
Figure 7.74
From the truth table in Figure 7.74, we make the Karnaugh map as shown in Figure 
7.75.
Figure 7.75
We obtain the Boolean expression,
 
 
 
T = SQ' + RQ.
Hence the circuit may be designed as shown in Figure 7.76.
J                 Q
K                Q'
T
0
0
1
0
X
X
0
1
00
0
1
01
11
10
RQ
S
RQ
SQ '

246
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 7.76 An S-R ﬂ ip-ﬂ op using a T ﬂ ip-ﬂ op.
7.11.10  Conversion of a T Flip-ﬂ op to a J-K Flip-ﬂ op
The excitation tables of J-K and T ﬂ ip-ﬂ ops are given in Figure 7.48, from which we 
make the truth table given in Figure 7.77.
FF data inputs 
Output 
T FF inputs
 
J 
K 
Q 
T 
 
0 
0 
0 
0
 
0 
1 
0 
0
 
1 
0 
0 
1
 
1 
1 
0 
1
 
0 
1 
1 
1
 
1 
1 
1 
1
 
0 
0 
1 
0
 
1 
0 
1 
0
Figure 7.77
From the truth table in Figure 7.77, we make the Karnaugh map in Figure 7.78.
Figure 7.78
We get,
 
 
 
T = JQ' + KQ.
Hence the circuit may be designed as in Figure 7.79.
T
Q
Q'
S
R
0
0
1
0
1
1
0
1
00
0
1
01
11
10
KQ
J
KQ
JQ'

SEQUENTIAL LOGIC CIRCUITS 247
Figure 7.79 A J-K ﬂ ip-ﬂ op using a T ﬂ ip-ﬂ op.
7.11.11  Conversion of a T Flip-ﬂ op to a D Flip-ﬂ op
The excitation tables of D and T ﬂ ip-ﬂ ops are given in Figure 7.48 from which we 
make the truth table given in Figure 7.80.
FF data inputs 
Output 
T FF inputs
 
D 
Q 
T 
 
0 
0 
0
 
1 
0 
1
 
0 
1 
1
 
1 
1 
0
Figure 7.80
Figure 7.81
The Karnaugh map is shown in Figure 7.81 and the Boolean expression is derived as
 
 
T = D'Q + DQ'.
Hence the circuit may be designed as shown in Figure 7.82.
Figure 7.82 A D ﬂ ip-ﬂ op using a T ﬂ ip-ﬂ op.
T
Q
Q'
J
K
0
1
0
1
0
0
1
1
Q
D'Q
D
DQ'
T
Q
Q'
D

248
DIGITAL PRINCIPLES AND LOGIC DESIGN
7.12  SEQUENTIAL CIRCUIT MODEL
The model for a general sequential circuit is shown in Figure 7.83. The present state of the 
circuit is stored in the memory element. The memory can be any device capable of storing 
enough information to specify the state of the circuit. 
Figure 7.83 General sequential circuit model.
The next state (NS) of the circuit is determined by the present state (PS) of the 
circuit and by the inputs (In). The function of the Next state decoder logic is to decode the 
external inputs and the present state of the circuit and to generate an output called the 
Next state variable. These next state variables will become the present state variables when 
the memory loads them. This process is called a state change. Thus, sequential circuit is a 
feedback system where the present state of the circuit is fed back to the next state decoder 
and used along with the input to determine the next state. 
The output (Out) of the circuit is determined by the present state of the machine and 
possibly by the input of the circuit. The output of a synchronous machine may be clocked, 
just as the state transition is clocked.
7.13  CLASSIFICATION OF SEQUENTIAL CIRCUITS
From the general sequential circuit model discussed in the preceding section, shown in 
Figure 7.83, sequential circuits are generally classiﬁ ed into ﬁ ve different classes:
 
1. Class A circuits
 
2. Class B circuits
 
3. Class C circuits
 
4. Class D circuits
 
5. Class E circuits.
Next state decoder
(com binational logic)
M em ory elem ents
Output decoder
(com binational logic)
Inputs (In)
....
....
Present state
Variables (PS)
Outputs (O ut)
N e x t  S t a t e
Variables (NS)
NS = f(In, PS)

SEQUENTIAL LOGIC CIRCUITS 249
The Class A circuit is deﬁ ned as a MEALY machine, named after G. H. Mealy. The basic 
property of a Mealy machine is that the output is a function of the present input conditions 
and the present state of the circuit. The model of a Mealy machine is the same as shown in 
Figure 7.83.
The Class B and Class C circuits are generally deﬁ ned as a MOORE machine, named 
after E. F. Moore. In these types of circuits the output is strictly a function of the present 
state (PS) of the circuit inputs. The block diagram of Class B and Class C circuits are shown 
in Figure 7.84 and Figure 7.85 respectively.
Both Mealy and Moore circuits are widely used. Even in some circuits a combination 
of both types are used. Class A, B, and C circuits with a single input form the general 
model for a counter circuit in which the events to be counted are entered directly into the 
memory element or through the next state decoder. Also, these circuits are equally applicable 
to both synchronous and asynchronous circuits.
Figure 7.84 Class B circuit (MOORE machine with an output decoder).
Figure 7.85 Class C circuit (MOORE machine without an output decoder).
The minimum number of inputs to any of these circuits is one. For synchronous circuits, 
the single input is clock input. The block diagram connections for Class D and Class E 
sequential circuits are shown in Figure 7.86 and Figure 7.87 respectively.
Next state decoder
M em ory elem ents
Output decoder
Inputs (In)
....
....
Outputs (Out)
Next state decoder
M em ory elements
Inputs (In)
....
....
Outputs (Out)

250
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 7.86 Class D circuit.
Figure 7.87 Class E circuit.
7.14  ANALYSIS OF SEQUENTIAL CIRCUITS
The behavior of a sequential circuit is determined from the inputs, the outputs, and the 
states of the ﬂ ip-ﬂ ops. Both the outputs and the next state are a function of the inputs 
and the present state. The analysis of sequential circuits consists of obtaining a table or a 
diagram for the time sequence of inputs, outputs, and internal states. Boolean expressions 
can be written that describe the behavior of the sequential circuits. We ﬁ rst introduce a 
speciﬁ c example of a clocked sequential circuit to understand its behavior.
Figure 7.88 Example of a clocked sequential circuit.
Next state decoder
M em ory elem ents
Inputs (In)
Outputs (O ut)
M em ory elem ents
Inputs (In)
Outputs (O ut)
x
A
A'
B
B'
CLK
J
J
P
P
Q
Q
Q
Q
K
K
1
2
3
4
x'
x
B
A'
x
x'
B'
A
A
y
B′
Logic 1
5

SEQUENTIAL LOGIC CIRCUITS 251
7.14.1  State Table
The time sequence of inputs, outputs, and ﬂ ip-ﬂ op states may be enumerated in a state 
table. The state table for the circuit in Figure 7.88 is shown in the table in Figure 7.89. Here 
in the table there are three sections designated as present state, next state, and output. The 
present state designates the states of the ﬂ ip-ﬂ ops before the occurrence of the clock pulse. The 
next state designates the states of the ﬂ ip-ﬂ ops after the application of the clock pulse. The 
output section shows the values of the output variables during the present state. Again, both the 
output and the next state sections have two columns, one for x = 0 and the other for x = 1.
The analysis of the circuit can start from any arbitrary state. In our example, we start 
the analysis from the initial state 00. When the present state is 00, A = 0 and B = 0. From the 
logic diagram, with x = 0, we ﬁ nd both AND gates 1 and 2 produce logic 0 signal and hence 
the next state remains unchanged. Also, B ﬂ ip-ﬂ op for both AND gates 3 and 4 produce logic 
0 signal and hence the next state of B also remains unchanged. Hence, with the clock pulse, 
ﬂ ip-ﬂ op A and B are both in the memory state, making the next state 00. Similarly, with 
A = 0 and B = 0, with x = 1, we ﬁ nd that gate 1 produces logic 0, whereas gate 2 produces 
logic 1. Again, with the same condition, gate 3 produces logic 1 whereas gate 4 produces 
logic 0. Hence, with the clock pulse, ﬂ ip-ﬂ op A is cleared and B is set, making the next 
state 01. This information is listed in the ﬁ rst row of the state table.
Present 
Next state 
Output 
 
 state 
x = 0 
x = 1 
x = 0 
x = 1 
 
AB 
AB 
AB 
y 
y
 
00 
00 
01 
0 
0
 
01 
11 
01 
0 
0
 
10 
10 
00 
0 
1
 
11 
10 
11 
0 
0
Figure 7.89 State table.
In a similar manner, we can derive the other conditions of the state table also. When 
the present state is 01, A = 0 and B = 1. From the logic diagram, with x = 0, we ﬁ nd gate 
1 produces logic 1 signal and gate 2 produces logic 0. For B ﬂ ip-ﬂ op both gates 3 and 4 
produce logic 0 signal and hence the next state of B remains unchanged. Hence, with the 
clock pulse, ﬂ ip-ﬂ op A is set and B remains in the memory state, making the next state 
11. Similarly, with A = 0 and B = 1, with x = 1, we ﬁ nd that both gates 1 and 2 produce 
logic 0. Again, with the same condition, both gates 3 and 4 produce logic 0. Hence, with 
the clock pulse, both ﬂ ip-ﬂ ops A and B remain in the memory state, making the next state 
01. This information is listed in the second row of the state table.
When the present state is 10, A = 1 and B = 0. From the logic diagram, with x = 0, 
we ﬁ nd both gates 1 and 2 produce logic 0. For B ﬂ ip-ﬂ op gate 3 produces logic 0 signal 
but gate 4 produces logic 1. Hence, with the clock pulse, ﬂ ip-ﬂ op A remains in the memory 
state and B is reset, making the next state 10. Similarly, with A = 1 and B = 0, with x = 
1, we ﬁ nd that gate 1 produces logic 0, whereas gate 2 produces logic 1. Again, with the 
same condition, both gates 3 and 4 produce logic 0. Hence, with the clock pulse, A is reset 
and B remains in the memory state, making the next state 00. This information is listed 
in the third row of the state table.

252
DIGITAL PRINCIPLES AND LOGIC DESIGN
Finally when the present state is 11, A = 1 and B = 1. From the logic diagram, with 
x = 0, we ﬁ nd gate 1 produces logic 1 and gate 2 produces logic 0. For B ﬂ ip-ﬂ op gate 3 
produces logic 0 signal but gate 4 produces logic 1. Hence, with the clock pulse, ﬂ ip-ﬂ op 
A remains in the memory state and B is reset, making the next state 10. Similarly, with 
A = 1 and B = 1, with x = 1, we ﬁ nd that both gates 1 and 2 produce logic 0. Again, with 
the same condition, both gates 3 and 4 produce logic 0. Hence, with the clock pulse, both 
A and B remain in the memory state, making the next state 11. This information is listed 
in the last row of the state table.
The entries in the output section are easier to derive. In our example, output y is equal 
to 1 only when x = 1, A  = 1, and B = 0. Hence the output columns are marked with 0s 
except when the present state is 10 and input x = 1, for which y is marked as 1.
The state table of any sequential circuit is obtained by the same procedure used in the 
example. In general, a sequential circuit with m ﬂ ip-ﬂ ops and n input variables will have 
2m rows, one for each state. The next state and output sections will have 2n columns, one 
for each input combination.
The external output of a sequential circuit may come from memory elements or logic 
gates. The output section is only included in the state table if there are outputs from logic 
gates. Any external output taken directly from a ﬂ ip-ﬂ op is already listed in the present 
state of the state table. 
7.14.2  State Diagram
All the information available in the state table may be represented graphically in the 
state diagram.
Figure 7.90 State diagram for the circuit in Figure 7.88.
In the diagram, a state is represented by a circle and the transitions between states 
is indicated by direct arrows connecting the circles. The binary number inside each circle 
identiﬁ es the state the circle represents. The direct arrows are labeled with two binary 
numbers separated by a /. The number before the / represents the value of the external 
input, which causes the state transition, and the number after the / represents the value of 
the output during the present state. For example, the directed arrow from the state 11 to 
10 while x = 0 and y = 0, and that on the termination of the next clock pulse, the circuit 
goes to the next state 10. A directed arrow connecting a circle with itself indicates that no 
change of the state occurs. 
00
11
10
01
1/0
0/0
1/1
1/0
1/0
0/0
0/0
0/0

SEQUENTIAL LOGIC CIRCUITS 253
There is no difference between a state table and a state diagram except in the manner 
of representation. The state table is easier to derive from a given logic diagram and the 
state diagram directly follows the state table. The state diagram gives a pictorial form of 
the state transitions and hence is easier to interpret. 
7.14.3  State Equation
A state equation is an algebraic expression that speciﬁ es the conditions for a ﬂ ip-ﬂ op state 
transition. The left side of the equation denotes the next state of the ﬂ ip-ﬂ op and the right side 
a Boolean function that speciﬁ es the present state conditions that make the next state equal to 
1. The state equation is derived directly from a state table. For example, the state equation for 
ﬂ ip-ﬂ op A can be derived from the table in Figure 7.89. From the next state columns we ﬁ nd 
that ﬂ ip-ﬂ op A goes to the 1 state four times: when x = 0 and AB = 01 or 10 or 11, or when x
= 1 and AB = 11. This can be expressed algebraically in a state equation as follows:
 
A (t + 1) = (A'B + AB' + AB)x' + ABx.
Similarly, from the next state columns we ﬁ nd that ﬂ ip-ﬂ op B goes to the 1 state 
four times: when x = 0 and AB = 01, or when x = 1 and AB = 00 or 01 or 11. This can be 
expressed algebraically in a state equation as follows:
 
B (t + 1) = A'Bx' + (A'B' + A'B + AB)x.
The right-hand side of the state equation is a Boolean function for the present state. 
When this function is equal to 1, the occurrence of a clock pulse causes ﬂ ip-ﬂ op A or ﬂ ip-
ﬂ op B to have a next state of 1. When this function is equal to 0, the occurrence of a clock 
pulse causes ﬂ ip-ﬂ op A or ﬂ ip-ﬂ op B to have a next state of 0. The left side of the equation 
identiﬁ es the ﬂ ip-ﬂ op by its letter symbol, followed by the time function designation (t +
1), to emphasize that this value is to be reached by the ﬂ ip-ﬂ op one pulse sequence later. 
The state equation for ﬂ ip-ﬂ op A and B are simpliﬁ ed algebraically below.
Hence, we get
 
A (t + 1) = (A'B + AB' + AB)x' + ABx
 
 = (Bx')A' + AB'x' + AB
 
 = (Bx')A' + (B + B'x')A
 
 = (Bx')A' + (B + x')A
 
 = (Bx')A' + (B'x)A.
If we let Bx' = J and B'x = K, we obtain the relationship:
 
A (t + 1) = JA' + KA.
which is the characteristic equation of the J-K ﬂ ip-ﬂ op. This relationship between the state 
equation and the characteristic equation can be justiﬁ ed from inspection of the logic diagram 
in Figure 7.88. In it we ﬁ nd that the J input of ﬂ ip-ﬂ op A is equal to the Boolean function 
Bx' and the K input is equal to B'x.
Similarly, for ﬂ ip-ﬂ op B we get
 
B (t + 1) = A'Bx' + (A'B' + A'B + AB)x
 
 = (A'x)B' + A'Bx' + Bx
 
 = (A'x)B' + (x + A'x')B
 
 = (A'x)B' + (x + A')B
 
 = (A'x)B' + (Ax')B.

254
DIGITAL PRINCIPLES AND LOGIC DESIGN
If we let A'x = J and Ax' = K, we obtain the relationship:
 
B(t + 1) = JB' + KB
which is the characteristic equation of the J-K ﬂ ip-ﬂ op. In the diagram in Figure 7.88, we 
ﬁ nd that the J input of ﬂ ip-ﬂ op B is equal to the Boolean function A'x and the K input is 
equal to Ax'.
7.15  DESIGN PROCEDURE OF SEQUENTIAL CIRCUITS
The design of a sequential circuit follows certain steps. The steps may be listed as 
follows:
 
1. The word description of a circuit may be given accompanied with a state diagram, or 
timing diagram, or other pertinent information.
 
2. Then from the given state diagram the state table has to be prepared.
 
3. If the state reduction mechanism is possible, then the number of states may be 
reduced.
 
4. After state reduction, assign binary values to the states if the states contain letter 
symbols.
 
5. Then the number of ﬂ ip-ﬂ ops required is to be determined. Each ﬂ ip-ﬂ op is assigned 
a letter symbol.
 
6. Then the choice has to be made regarding the type of ﬂ ip-ﬂ op to be used.
 
7. With the help of a state table and the ﬂ ip-ﬂ op excitation table the circuit excitation 
and the output tables have to be determined.
 
8. Then using some simpliﬁ cation technique e.g., a Karnaugh map or some other method, 
the circuit output functions and the ﬂ ip-ﬂ op input functions have to be determined. 
 
9. Then the logic diagram has to be drawn.
Although certain steps have been speciﬁ ed for designing the sequential circuit, the 
procedure can be shortened with experience. A sequential circuit is made up of ﬂ ip-ﬂ ops and 
combinational gates. One of the most important parts is the choice of ﬂ ip-ﬂ op. From the 
excitation table of different ﬂ ip-ﬂ ops we see that the J-K ﬂ ip-ﬂ op excitation table contains 
the maximum number of don’t-care conditions. Hence, for designing any sequential circuit, 
it will be most simpliﬁ ed if the circuit is designed with, J-K ﬂ ip-ﬂ op.
The number of ﬂ ip-ﬂ ops is determined by the number of states. A circuit may have 
unused binary states if the total number of states is less than 2m. The unused states are 
taken as don’t-care conditions during the design of the combinational part of the circuit.
Any design process must consider the problem of minimizing the cost of the ﬁ nal 
circuit. The most obvious cost reductions are reductions in the number of ﬂ ip-ﬂ ops and the 
number of gates. The reduction of the number of ﬂ ip-ﬂ ops in a sequential circuit is referred 
to as the state reduction. Since m ﬂ ip-ﬂ ops produce 2m states, a reduction in the number 
of states may (or may not) result in a reduction of the number of ﬂ ip-ﬂ ops. State reduction 
algorithms are concerned with procedures for reducing the number of states in a state table 
while keeping the external input-output requirements unchanged.
An algorithm for the state reduction is given here. If two states in a state table are 
equivalent, one of them can be removed without altering the input-output relationships. 

SEQUENTIAL LOGIC CIRCUITS 255
Now two states are said to be equivalent if, for each member of the set of inputs, they give 
exactly the same output and send the circuit to the same state or to an equivalent state. 
We will discuss the state reduction problem with an example in this section later on.
In certain cases the states are speciﬁ ed in letter symbols. In such cases there comes 
another factor, called state assignment. State assignment procedures are concerned with 
methods for assigning binary values to states in such a way as to reduce the cost of the 
combinational circuit that drives the ﬂ ip-ﬂ op. For any problem there may be a number 
of different state assignments leading to different combinational parts of the sequential 
circuit. The most common criterion is that the chosen assignment should result in a simple 
combinational circuit for the ﬂ ip-ﬂ op inputs. However, to date, there are no state assignment 
procedures that guarantee a minimal-cost combinational circuit. In fact, state assignment 
is one of the most challenging problems of sequential circuit design.
We now wish to design the clocked sequential circuit whose state diagram is given 
below.
Figure 7.91 State diagram.
The state table for the state diagram shown in Figure 7.91 is shown in the table in 
Figure 7.92.
Present 
Next state 
Output 
 
 state 
x = 0 
x = 1 
x = 0 
x = 1 
a 
f 
b 
0 
0
b 
d 
c 
0 
0
c 
f 
e 
0 
0
d 
g 
a 
1 
0
e 
d 
c 
0 
0
f 
f 
b 
1 
1
g 
g 
h 
0 
1
h 
g 
a 
1 
0
Figure 7.92 State table.
We now look for two equivalent states, and ﬁ nd that d and h are two such states; they both 
go to g and a and have outputs of 1 and 0 for x = 0 and x = 1, respectively. Therefore, states d and 
h are equivalent; one can be removed. Similarly, we ﬁ nd that b and e are again two such states; 
a
c
e
d
b
g
h
f
1/0
0/1
1/1
0/0
0/1
0/0
1/0
1/0
1/0
1/1
0/0
0/1
0/0
1/0
1/0
0/0

256
DIGITAL PRINCIPLES AND LOGIC DESIGN
they both go to d and c and have outputs of 0 and 0 for x = 0 and x = 1, respectively. Therefore, 
states b and e are also equivalent; and one can be removed. The procedure of removing a state 
and replacing it by its equivalent is demonstrated in the table in Figure 7.93.
From the table in Figure 7.93 we ﬁ nd that present state c now has next states f and b and 
outputs 0 and 0 for x = 0 and x = 1, respectively. The same next states and outputs appear in 
the row with present state a. Therefore, states a and c are equivalent; state c can be removed 
and replaced by a. The ﬁ nal reduced state table is shown in Figure 7.94. The state diagram 
for the reduced state table consists of only ﬁ ve states and is shown in Figure 7.95.
Present 
Next state 
Output 
 
 state 
x = 0 
x = 1  
x = 0 
x = 1
a 
f 
b 
 
0 
0
b 
d 
c 
a 
0 
0
c 
f 
e 
b 
0 
0
d 
g 
a 
 
1 
0
e 
d 
c 
 
0 
0
f 
f 
b 
 
1 
1
g 
g 
h 
d 
0 
1
h 
g 
a 
 
1 
0
Figure 7.93 Reducing the state table.
Present 
Next state 
Output 
 
 state 
x = 0 
x = 1 
x = 0 
x = 1 
a 
f 
b 
0 
0
b 
d 
a 
0 
0
d 
g 
a 
1 
0
f 
f 
b 
1 
1
g 
g 
d 
0 
1
Figure 7.94 Reduced state table.
Figure 7.95 Reduced state diagram.
a
g
d
b
f
0/1
1/1
1/1
1/0
0/1
1/0
1/0
0/0
0/0
0/0

SEQUENTIAL LOGIC CIRCUITS 257
We now assign the different states the binary values. As we have already discussed, 
there may be a variety of state assignments. Some of them are shown in the table in Figure 
7.96. Among them we may choose any of them and accordingly design the circuit.
State 
Assignment 1 
Assignment 2 
Assignment 3 
Assignment 4 
a 
000 
001 
111 
011
b 
001 
010 
001 
101
d 
010 
011 
110 
111
f 
011 
100 
101 
001
g 
100 
101 
010 
000
Figure 7.96 Four possible binary assignments.
Present 
Next state 
Output 
 
 state 
x = 0 
x = 1  
x = 0 
x = 1
 
000 
011 
001 
0 
0
 
001 
010 
000 
0 
0
 
010 
100 
000 
1 
0
 
011 
011 
001 
1 
1
 
100 
100 
010 
0 
1
Figure 7.97 Reduced state table with binary assignment 1.
In the table in Figure 7.97, we have used binary assignment 1 to substitute the letter 
symbols of the ﬁ ve states. It is obvious that a different binary assignment will result in 
a state table, with completely new binary values for the states while the input-output 
relationships will remain the same. We will now show the procedure for obtaining the 
excitation table and the combinational gate structure.
 Present state 
Input 
Next state 
Flip-ﬂ op inputs 
 Output
 
A 
B 
C 
x 
A 
B 
C 
JA 
KA 
JB 
KB 
JC 
KC 
y
 
0 
0 
0 
0 
0 
1 
1 
0 
X 
1 
X 
1 
X 
0
 
0 
0 
0 
1 
0 
0 
1 
0 
X 
0 
X 
1 
X 
0
 
0 
0 
1 
0 
0 
1 
0 
0 
X 
1 
X 
X 
1 
0
 
0 
0 
1 
1 
0 
0 
0 
0 
X 
0 
X 
X 
1 
0
 
0 
1 
0 
0 
1 
0 
0 
1 
X 
X 
1 
0 
X 
1
 
0 
1 
0 
1 
0 
0 
0 
0 
X 
X 
1 
0 
X 
0
 
0 
1 
1 
0 
0 
1 
1 
0 
X 
X 
0 
X 
0 
1
 0 
1 
1 
1 
0 
0 
1 
0 
X 
X 
1 
X 
0 
1
 1 
0 
0 
0 
1 
0 
0 
X 
0 
0 
X 
0 
X 
0
 1 
0 
0 
1 
0 
1 
0 
X 
1 
1 
X 
0 
X 
1
Figure 7.98
The derivation of the excitation table is facilitated if we arrange the state table in a 
different form. This form is shown in the table in Figure 7.98, where the present state and 

258
DIGITAL PRINCIPLES AND LOGIC DESIGN
the input variables are arranged in the form of a truth table. As we have previously said, 
we may use any ﬂ ip-ﬂ op, but the simplest form of the circuit is possible with J-K ﬂ ip-ﬂ ops. 
So we now design the circuit using J-K ﬂ ip-ﬂ ops.
There are three unused states in this circuit: binary states 101, 110, and 111. When 
an input of 0 or 1 is included with these unused states, we obtain six don’t-care terms. 
These six binary combinations are not listed in the table under the present state or input 
and are treated as don’t-care terms.
Karnaugh maps are prepared for JA, KA, JB, KB, JC, and KC in Figures 7.99(a),
7.99(b), 7.99(c), 7.99(d), 7.99(e), and 7.99(f).
 
Figure 7.99(a) 
Figure 7.99(b)
From the Karnaugh maps for JA and KA, we obtain
 
 
 
JA = BC 'x'    and
 
 
 
KA = x.
 
Figure 7.99(c) 
Figure 7.99(d)
The Boolean expressions are derived for JB and KB from the Karnaugh maps as
 
 
 
JB = Ax + A'x' and
 
 
 
KB = C' + x.
0
0
0
0
0
X
X
0
X
X
0
X
X
1
X
X
00
00
01
11
10
01
11
10
Cx
AB
For JA
X
X
X
X
X
X
X
X
X
X
X
X
1
X
X
0
00
00
01
11
10
01
11
10
Cx
AB
For KA
1
0
0
1
X
X
X
X
X
X
X
X
1
X
X
0
00
00
01
11
10
01
11
10
Cx
AB
For JB
X
X
X
X
0
X
X
1
X
X
1
X
1
X
0
00
00
01
11
10
01
11
10
Cx
AB
For KB
X

SEQUENTIAL LOGIC CIRCUITS 259
Figure 7.99(e)
Figure 7.99(f)
Similarly, the expressions for JC and KC we obtain as 
 
 
 
JC = A'B' 
and
 
 
 
KC = B'.
A Karnaugh map has been also prepared for output y in Figure 7.99(g) and the Boolean 
expression for y is obtained as
 
 
 
Y = Bx' + BC + Ax.
Figure 7.99(g)
1
1
X
X
X
X
X
X
X
X
0
X
0
0
X
0
00
00
01
11
10
01
11
10
Cx
AB
For JC
X
X
1
1
0
X
X
0
X
X
X
X
X
X
X
X
00
00
01
11
10
01
11
10
Cx
AB
For KC
0
0
0
0
1
X
X
1
X
X
0
X
1
1
X
0
00
00
01
11
10
01
11
10
Cx
AB
For Y

260
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 7.100 Logic diagram for the circuit.
The circuit diagram of the desired sequential logic network is shown in Figure 7.100.
REVIEW QUESTIONS
7.1 Show the logic diagram of a clocked D ﬂ ip-ﬂ op with four NAND gates.
7.2 What is the difference between a level-triggered clock and an edge-triggered clock?
7.3 What is the difference between a latch and a ﬂ ip-ﬂ op?
7.4 What is the race-around condition of a J-K ﬂ ip-ﬂ op? How can it be avoided?
7.5 Draw the logic diagram of master-slave D ﬂ ip-ﬂ op. Use NAND gates.
7.6 Derive the state table and the state diagram of the sequential circuit shown below.
A
A'
B
B'
C
C'
y
J
J
J
Q
Q
Q
Q
Q
Q
K
K
K
x
A
A'
B
B'
J
J
C
C
Q
Q
K
K

SEQUENTIAL LOGIC CIRCUITS 261
7.7 Obtain the excitation table of the J'K ﬂ ip-ﬂ op.
7.8 A sequential circuit has one input and one output. The state diagram is shown below. Design 
the circuit with (a) JK ﬂ ip-ﬂ ops, (b) D ﬂ ip-ﬂ ops, (c) SR ﬂ ip-ﬂ ops, and (d) T ﬂ ip-ﬂ ops.
❑ ❑ ❑
001
010
000
011
100
0/0
0/0
1/0
1/1
0/0
0/0
1/1
1/1
1/1
0/0


263
8.1  INTRODUCTION
A
register is a group of binary storage cells capable of holding binary information. A group 
of ﬂ ip-ﬂ ops constitutes a register, since each ﬂ ip-ﬂ op can work as a binary cell. An
n-bit register, has n ﬂ ip-ﬂ ops and is capable of holding n-bits of information. In addition 
to ﬂ ip-ﬂ ops a register can have a combinational part that performs data-processing tasks. 
Various types of registers are available in MSI circuits. The simplest possible register 
is one that contains no external gates, and is constructed of only ﬂ ip-ﬂ ops. Figure 8.1 
shows such a type of register constructed of four S-R ﬂ ip-ﬂ ops, with a common clock pulse 
input. The clock pulse enables all the ﬂ ip-ﬂ ops at the same instant so that the information 
available at the four inputs can be transferred into the 4-bit register. All the ﬂ ip-ﬂ ops in 
a register should respond to the clock pulse transition. Hence they should be either of the 
edge-triggered type or the master-slave type. A group of ﬂ ip-ﬂ ops sensitive to the pulse 
duration is commonly called a gated latch. Latches are suitable to temporarily store binary 
information that is to be transferred to an external destination. They should not be used 
in the design of sequential circuits that have feedback connections.
Figure 8.1 4-bit register
8.2  SHIFT REGISTER
A register capable of shifting its binary contents either to the left or to the right is called a 
shift register. The shift register permits the stored data to move from a particular location 
CLK
Q 1
I1
I2
I3
I4
Q 2
Q 3
Q 4
Q
Q
Q
Q
S
S
S
S
R
R
R
R
REGISTERS
8
C h a p t e r

264
DIGITAL PRINCIPLES AND LOGIC DESIGN
to some other location within the register. Registers can be designed using discrete ﬂ ip-ﬂ ops 
(S-R, J-K, and D-type).
The data in a shift register can be shifted in two possible ways: (a) serial shifting 
and (b) parallel shifting. The serial shifting method shifts one bit at a time for each clock 
pulse in a serial manner, beginning with either LSB or MSB. On the other hand, in parallel 
shifting operation, all the data (input or output) gets shifted simultaneously during a single 
clock pulse. Hence, we may say that parallel shifting operation is much faster than serial 
shifting operation.
There are two ways to shift data into a register (serial or parallel) and similarly two 
ways to shift the data out of the register. This leads to the construction of four basic types of 
registers as shown in Figures 8.2(a) to 8.2(d). All of the four conﬁ gurations are commercially 
available as TTL MSI/LSI circuits. They are:
 
1. Serial in/Serial out (SISO) – 54/74L91, 8 bits
 
2. Serial in/Parallel out (SIPO) – 54/74164, 8 bits
 
3. Parallel in/Serial out (PISO) – 54/74265, 8 bits
 
4. Parallel in/Parallel out (PIPO) – 54/74198, 8 bits.
Figure 8.2 Four types of shift registers.
8.3  SERIAL-IN–-SERIAL-OUT SHIFT REGISTER
From the name itself it is obvious that this type of register accepts data serially, i.e., one 
bit at a time at the single input line. The output is also obtained on a single output line 
in a serial fashion. The data within the register may be shifted from left to right using 
shift-left register, or may be shifted from right to left using shift-right register. 
n-bit
Serial data
Serial data
input
output
n-bit
Serial data
input
M SB
LSB
...
Parallel data outputs
(a) Serial in/Serial out.
(b) Serial in/Parallel out.
n-bit
Serial data
Parallel data inputs
Parallel data inputs
output
n-bit
M SB
M SB
M SB
LSB
LSB
LSB
......
.....
.....
Parallel data outputs
(c) Parallel in/Serial out.
(d) Parallel in/Parallel out.

REGISTERS 265
8.3.1  Shift-right Register
A shift-right register can be constructed with either J-K or D ﬂ ip-ﬂ ops as shown in 
Figure 8.3. A J-K ﬂ ip-ﬂ op–based shift register requires connection of both J and K inputs. 
Input data are connected to the J and K inputs of the left most (lowest order) ﬂ ip-ﬂ op. To 
input a 0, one should apply a 0 at the J input, i.e., J = 0 and K = 1 and vice versa. With 
the application of a clock pulse the data will be shifted by one bit to the right.
In the shift register using D ﬂ ip-ﬂ op, D input of the left most ﬂ ip-ﬂ op is used as a 
serial input line. To input 0, one should apply 0 at the D input and vice versa. 
Figure 8.3 Shift-right register (a) using D ﬂ ip-ﬂ ops, (b) using J-K ﬂ ip-ﬂ ops.
The clock pulse is applied to all the ﬂ ip-ﬂ ops simultaneously.  When the clock pulse 
is applied, each ﬂ ip-ﬂ op is either set or reset according to the data available at that point 
of time at the respective inputs of the individual ﬂ ip-ﬂ ops. Hence the input data bit at the 
serial input line is entered into ﬂ ip-ﬂ op A by the ﬁ rst clock pulse. At the same time, the 
data of stage A is shifted into stage B and so on to the following stages. For each clock 
pulse, data stored in the register is shifted to the right by one stage. New data is entered 
into stage A, whereas the data present in stage D are shifted out (to the right).  
Table 8.1 Operation of the Shift-right Register
Timing pulse 
QA          QB         QC         QD 
Serial output at QD
Initial value 
0 
0 
0 
0 
0 
After 1st clock pulse 
1 
0 
0 
0 
0
After 2nd clock pulse 
1 
1 
0 
0 
0
After 3rd clock pulse 
0 
1 
1 
0 
0
After 4th clock pulse 
1 
0 
1 
1 
1 
For example, consider that all the stages are reset and a logical input 1011 is applied at the 
serial input line connected to stage A. The data after four clock pulses is shown in Table 8.1.
Let us now illustrate the entry of the 4-bit number 1011 into the register, beginning 
with the right-most bit. A 1 is applied at the serial input line, making D = 1. As the ﬁ rst 
D
D
D
D
Q
Q
Q
Q
Q
Q
Q
Q
D
C
B
A
Q
Q
Q
Q
A
CLK
Serial
input
data
B
C
D
Serial
output
data
(a)
J
J
J
J
K
K
K
K
Q
Q
Q
Q
Q
Q
Q
Q
D
C
B
A
Q
Q
Q
Q
A
CLK
Serial
input
data
B
C
D
Serial
output
data

266
DIGITAL PRINCIPLES AND LOGIC DESIGN
clock pulse is applied, ﬂ ip-ﬂ op A is SET, thus storing the 1. Next, a 1 is applied to the 
serial input, making D = 1 for ﬂ ip-ﬂ op A and D = 1 for ﬂ ip-ﬂ op B also, because the input 
of ﬂ ip-ﬂ op B is connected to the QA output.
When the second clock pulse occurs, the 1 on the data input is “shifted” to the ﬂ ip-ﬂ op 
A and the 1 in the ﬂ ip-ﬂ op A is “shifted” to ﬂ ip-ﬂ op B. The 0 in the binary number is now 
applied at the serial input line, and the third clock pulse is now applied. This 0 is entered 
in ﬂ ip-ﬂ op A and the 1 stored in ﬂ ip-ﬂ op A is now “shifted” to ﬂ ip-ﬂ op B and the 1 stored 
in ﬂ ip-ﬂ op B is now “shifted”  to ﬂ ip-ﬂ op C. The last bit in the binary number that is the 
1 is now applied at the serial input line and the fourth clock pulse is now applied. This 1 
now enters the ﬂ ip-ﬂ op A and the 0 stored in ﬂ ip-lop A is now “shifted” to ﬂ ip-ﬂ op B and 
the 1 stored in ﬂ ip-ﬂ op B is now “shifted” to ﬂ ip-ﬂ op C and the 1 stored in ﬂ ip-ﬂ op C is 
now “shifted” to ﬂ ip-ﬂ op D. Thus the entry of the 4-bit binary number in the shift-right 
register is now completed.
From the third column of Table 8.1 we can get the serial output of the data that is 
being entered in the register. We ﬁ nd that after the ﬁ rst, second, and the third clock pulses 
the output at the serial output line i.e., QD is 0. After the fourth clock pulse the output at 
the serial output line is 1. If we want to get the total data that we have entered in the 
register in a serial manner from QD, then we have to apply another three clock pulses. After 
the ﬁ fth clock pulse we will gate another 1 at QD. After the sixth clock pulse the output at 
QD will be 0 and after the seventh clock pulse the output at QD will be 1. In this process 
of the ﬁ fth, sixth, and the seventh clock pulses if no data is being supplied at the serial 
input line then the A, B, and C ﬂ ip-ﬂ ops will again be RESET with output 0.  
Figure 8.4 Waveforms of 4-bit serial input shift-right register.
1
Q
Q
Q
Q
0
K
Clock 0
Tim e
A
B
C
D
Serial
input
data
1
J
D
C
B
A
1
0
1

REGISTERS 267
The waveforms shown in Figure 8.4 illustrate the entry of a 4-bit number 1011. For 
a J-K ﬂ ip-ﬂ op, the data bit to be shifted into the ﬂ ip-ﬂ op must be present at the J and K 
inputs when the clock transitions from low to high occur. Since the data bit is either 1 or 
0, there can be two different cases:
 
1. To shift a 1 into the ﬂ ip-ﬂ op, J = 1 and K = 0,
 
2. To shift a 0 into the ﬂ ip-ﬂ op, J = 0 and K = 1.
At time A: All the ﬂ ip-ﬂ ops are reset. At the serial data input line a 1 is given and 
with the ﬁ rst clock pulse this 1 is shifted at QA making QA = 1. At the same time the 0 in 
QA is shifted to QB, and the 0 in QB is shifted to QC and the 0 in QC is shifted to QD. Hence 
the ﬂ ip-ﬂ op outputs just after time A are QAQBQCQD = 1000.
At time B: The ﬂ ip-ﬂ op A contains 1, and all other ﬂ ip-ﬂ op contains 0. Now, again, 1 
is given at the serial data input line. With the second clock pulse this 1 is shifted to QA.
The 1 in QA is shifted to QB and the 0 in QB is shifted to QC and the 0 in QC is shifted to 
QD. Hence the ﬂ ip-ﬂ op outputs just after time B are QAQBQCQD = 1100.
At time C: The ﬂ ip-ﬂ op A and ﬂ ip-ﬂ op B contain 1, and all other ﬂ ip-ﬂ ops contain 0. 
Now a 0 is given at the serial data input line. With the third clock pulse this 0 is shifted to 
QA. The 1 in QA is shifted to QB and the 1 in QB is shifted to QC and the 0 in QC is shifted 
to QD. Hence the ﬂ ip-ﬂ op outputs just after time C are QAQBQCQD = 0110.
At time D: The ﬂ ip-ﬂ op B and ﬂ ip-ﬂ op C contain 1, and all other ﬂ ip-ﬂ ops contain 0. 
Now another 1 is given at the serial data input line. With the fourth clock pulse this 1 is 
shifted to QA. The 0 in QA is shifted to QB and the 1 in QB is shifted to QC and the 1 in QC
is shifted to QD. Hence the ﬂ ip-ﬂ op outputs just after time C are QAQBQCQD = 1011.
To summarize, we have shifted 4 data bits in a serial manner into four ﬂ ip-ﬂ ops. These 
4 data bits could represent a 4-bit binary number 1011, assuming that we began shifting 
with the LSB ﬁ rst. Notice that the LSB is in D and the MSB is in A. These four ﬂ ip-ﬂ ops 
could be deﬁ ned as a 4-bit shift register. 
8.3.2  Shift-left Register
A shift-left register can also be constructed with either J-K or D ﬂ ip-ﬂ ops as shown 
in Figure 8.5. Let us now illustrate the entry of the 4-bit number 1110 into the register, 
beginning with the right-most bit. A 0 is applied at the serial input line, making D = 0. As 
the ﬁ rst clock pulse is applied, ﬂ ip-ﬂ op A is RESET, thus storing the 0. Next a 1 is applied 
to the serial input, making D = 1 for ﬂ ip-ﬂ op A and D = 0 for ﬂ ip-ﬂ op B, because the input 
of ﬂ ip-ﬂ op B is connected to the QA output.
When the second clock pulse occurs, the 1 on the data input is “shifted” to the ﬂ ip-ﬂ op 
A and the 0 in the ﬂ ip-ﬂ op A is “shifted” to ﬂ ip-ﬂ op B. The 1 in the binary number is now 
applied at the serial input line, and the third clock pulse is now applied. This 1 is entered 
in ﬂ ip-ﬂ op A and the 1 stored in ﬂ ip-ﬂ op A is now “shifted” to ﬂ ip-ﬂ op B and the 0 stored 
in ﬂ ip-ﬂ op B is now “shifted”  to ﬂ ip-ﬂ op C. The last bit in the binary number that is the 
1 is now applied at the serial input line and the fourth clock pulse is now applied. This 1 
now enters the ﬂ ip-ﬂ op A and the 1 stored in ﬂ ip-ﬂ op A is now “shifted” to ﬂ ip-ﬂ op B and 
the 1 stored in ﬂ ip-ﬂ op B is now “shifted” to ﬂ ip-ﬂ op C and the 0 stored in ﬂ ip-ﬂ op C is 
now “shifted” to ﬂ ip-ﬂ op D. Thus the entry of the 4-bit binary number in the shift-right 
register is now completed.

268
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 8.5 Shift-left register (a) using D ﬂ ip-ﬂ ops, (b) using J-K ﬂ ip-ﬂ ops.
Table 8.2 Operation of the Shift-left Register
Timing pulse 
QD          QC         QB         QA 
Serial output at QD
Initial value 
0 
0 
0 
0 
0
After 1st clock pulse 
0 
0 
0 
0 
0
After 2nd clock pulse 
0 
0 
0 
1 
0
After 3rd clock pulse 
0 
0 
1 
1 
0
After 4th clock pulse 
0 
1 
1 
1 
0
8.3.3  8-bit Serial-in–Serial-out Shift Register
The pinout and logic diagram of IC 74L91 is shown in Figure 8.6. IC 74L91 is actually 
an example of an 8-bit serial-in–serial-out shift register. This is an 8-bit TTL MSI chip. 
There are eight S-R ﬂ ip-ﬂ ops connected to provide a serial input as well as a serial output. 
The clock input at each ﬂ ip-ﬂ op is negative edge-triggered. However, the applied clock signal 
is passed through an inverter. Hence the data will be shifted on the positive edges of the 
input clock pulses. 
An inverter is connected in between R and S on the ﬁ rst ﬂ ip-ﬂ op. This means that this 
circuit functions as a D-type ﬂ ip-ﬂ op. So the input to the register is a single liner on which 
the data can be shifted into the register appears serially. The data input is applied at either 
A (pin 12) or B (pin 11). The data level at A (or B) is complemented by the NAND gate 
and then applied to the R input of the ﬁ rst ﬂ ip-ﬂ op. The same data level is complemented 
by the NAND gate and then again complemented by the inverter before it appears at the 
S input. So, a 0 at input A will reset the ﬁ rst ﬂ ip-ﬂ op (in other words this 0 is shifted into 
the ﬁ rst ﬂ ip-ﬂ op) on a positive clock transition.   
The NAND gate with A and B inputs provide a gating function for the input data 
stream if required, if gating is not required, simply connect pins 11 and 12 together and 
apply the input data stream to this connection. 
Q
Q
Q
Q
D
D
D
D
Q
Q
Q
Q
A
B
C
D
Q
Q
Q
Q
CLK
Serial
input
data
Serial
output
data
D
C
B
A
(a)
Q
Q
Q
Q
J
J
J
J
K
K
K
K
Q
Q
Q
Q
A
B
C
D
Q
Q
Q
Q
CLK
Serial
input
data
Serial
output
data
D
C
B
A
(b)

REGISTERS 269
Figure 8.6 8-bit shift register—IC 74L91.
8.4  SERIAL-IN–PARALLEL-OUT REGISTER
In this type of register, the data is shifted in serially, but shifted out in parallel. To obtain 
the output data in parallel, it is required that all the output bits are available at the same 
time. This can be accomplished by connecting the output of each ﬂ ip-ﬂ op to an output pin. 
Once the data is stored in the ﬂ ip-ﬂ op the bits are available simultaneously. The basic 
conﬁ guration of a serial-in–parallel-out shift register is shown in Figure 8.2 (b).
8.4.1  8-bit Serial-in–Parallel-out Shift Register
The pinout and logic diagram of IC 74164 is shown in Figure 8.7. IC 74164 is an 
example of an 8-bit serial-in–parallel-out shift register. There are eight S-R ﬂ ip-ﬂ ops, which 
are all sensitive to negative clock transitions.  The logic diagram in Figure 8.7 is almost the 
same as shown in Figure 8.6 with only two exceptions: (1) each ﬂ ip-ﬂ op has an asynchronous 
CLEAR input; and (2) the true side of each ﬂ ip-ﬂ op is available as an output—thus all 8 
bits of any number stored in the register are available simultaneously as an output (this 
is a parallel data output). 
Hence, a low level at the CLR input to the chip (pin 9) is applied through an ampliﬁ er 
and will reset every ﬂ ip-ﬂ op. As long as the CLR input to the chip is LOW, the ﬂ ip-ﬂ op 
outputs will all remain low. It means that, in effect, the register will contain all zeros. 
Shifting of data into the register in a serial fashion is exactly the same as the IC 
74L91. Data at the serial input may be changed while the clock is either low or high, but 
the usual hold and setup times must be observed. The data sheet for this device gives hold 
time as 0.0 ns and setup time as 30 ns.
Now we try to analyze the gated serial inputs A and B. Suppose that the serial data 
is connected to B; then A can be used as a control line. Here’s how it works:
CLK
A
B
S
S
S
S
S
S
S
S
R
R
R
R
R
R
R
R
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
(a)  Logic diagram.
    Q '             Q             A              B           G ND         C LK         NC
IC 74L91
    NC
       NC       
 NC
        NC         V C C
       NC         N C
14
Output
Output
Input
13
12
11
10
8
7
1
2
3
5
6
4
9
(b) Pinout diagram of IC 74L91.

270
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 8.7 8-bit shift register—IC 74164.
A is held high: The NAND gate is enabled and the serial input data passes through 
the NAND gate inverted. The input data is shifted serially into the register.
A is held low: The NAND gate output is forced high, the input data steam is inhibited, 
and the next clock pulse will shift a 0 into the ﬁ rst ﬂ ip-ﬂ op. Each succeeding positive clock 
pulse will shift another 0 into the register. After eight clock pulses, the register will be full 
of zeros. 
Example 8.1. How long will it take to shift an 8-bit number into a 74164 shift register 
if the clock is set at 1 MHz?
Solution. A minimum of eight clock Pulses will be required since the data is entered 
serially. One clock pulse period is 1000 ns, so it will require 8000 ns minimum.
8.5  PARALLEL-IN–SERIAL-OUT REGISTER
In the preceding two cases the data was shifted into the registers in a serial manner. We 
now can develop an idea for the parallel entry of data into the register. Here the data bits 
are entered into the ﬂ ip-ﬂ ops simultaneously, rather than a bit-by-bit basis.
A 4-bit parallel-in–serial-out register is illustrated in Figure 8.8. A, B, C, and D are the 
four parallel data input lines and SHIFT / LOAD (SH / LD) is a control input that allows 
the four bits of data at A, B, C, and D inputs to enter into the register in parallel or shift 
the data in serial. When SHIFT / LOAD is HIGH, AND gates G1, G3, and G5 are enabled, 
R
R
R
R
R
R
R
R
S
A
B
CLK
CLR'
S
S
S
S
S
S
S
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
A
B
C
D
E
F
G
H
Q
Q
Q
Q
Q
Q
Q
(a)  Logic diagram.
14
13
12
11
10
9
8
1
VC C
A
QH
B
QG
Q A
QF
QB
QE
QC
QD
CLR'
CLK
GND
Data inputs
Data Outputs
IC  74164
Data outputs
2
3
4
5
6
7
(b) Pinout diagram of IC 74164.

REGISTERS 271
allowing the data bits to shift right from one stage to the next. When SHIFT / LOAD is
LOW, AND gates G2, G4, and G6 are enabled, allowing the data bits at the parallel inputs. 
When a clock pulse is applied, the ﬂ ip-ﬂ ops with D = 1 will be set and the ﬂ ip-ﬂ ops with 
D = 0 will be reset, thereby storing all the four bits simultaneously. The OR gates allow 
either the normal shifting operation or the parallel data-entry operation, depending on which 
of the AND gates are enabled by the level on the SHIFT / LOAD input. 
Figure 8.8 A 4-bit parallel-in–serial-out shift register.
8.5.1  8-bit Parallel-in–Serial-out Shift Register
The pinout and logic diagram of IC 74165 is shown in Figure 8.9. IC 74165 is an
example of an 8-bit serial/parallel-in and serial-out shift register. The data can be loaded into 
A
B
C
D
G 1
G 2
G 3
G 4
G 6
G 5
D
CLK
D
D
D
Q
Q
Q
Q
Q D
Q C
Q B
Q A
Q
Q
Q
Q
SH IFT/LO AD
Q H
S
S
S
S
S
S
S
S
A
Serial input
D s
SH /LD
CLK
CLK
inhibit
B
C
D
Parallel inputs
E
F
G
H
R
R
R
R
R
R
R
R
Q
Q
Q
Q
Q
Q
Q
Q
Q'H
(a) Logic diagram.

272
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 8.9 8-bit serial/parallel-in and serial-out shift register—IC 74165.
the register in parallel and shifted out serially at QH using either of two clocks (CLK or 
CLK inhibit). It also contains a serial input, DS through which the data can be serially 
shifted in.
When the input SHIFT / LOAD (SH / LD) is LOW, it enables all the NAND gates 
for parallel loading. When an input data bit is a 0, the ﬂ ip-ﬂ op is asynchronously RESET 
by a LOW output of the lower NAND gate. Similarly, when the input data bit is a 1, the 
ﬂ ip-ﬂ op is asynchronously SET by a LOW output of the upper NAND gate. The clock is 
inhibited during parallel loading operation. A HIGH on the SHIFT / LOAD input enables 
the clock causing the data in the register to shift right. With the low to high transitions of 
either clock, the serial input data (DS) are shifted into the 8-bit register.
8.6  PARALLEL-IN–PARALLEL-OUT REGISTER
There is a fourth type of register already mentioned in Section 8.2, which is designed such 
that data can be shifted into or out of the register in parallel. The parallel input of data 
has already been discussed in the preceding section of parallel-in–serial-out shift register. 
Also, in this type of register there is no interconnection between the ﬂ ip-ﬂ ops since no serial 
shifting is required. Hence, the moment the parallel entry of the data is accomplished the 
data will be available at the parallel outputs of the register. A simple parallel-in–parallel-
out shift register is shown in Figure 8.10. 
Figure 8.10 A 4-bit parallel-in–parallel-out shift register.
Here the parallel inputs to be applied at A, B, C, and D inputs are directly connected to 
the D inputs of the respective ﬂ ip-ﬂ ops. On applying the clock transitions, these inputs are 
16
15
14
13
12
11
10
9
1
VC C
SH /LD
CLK
inhibit
D
E
C
F
B
D S
QH
H
G
Q'H
A
CLK
GND
IC  74165
Parallel inputs
2
3
4
5
6
7
8
Parallel inputs
(b) Pinout diagram of IC 74165.
Q A
Q
Q
Q
D
C
B
A
D
D
D
D
Q
Q
Q
Q
Q
Q
Q
Q
CLK
B
C
D

REGISTERS 273
entered into the register and are immediately available at the outputs Q1, Q2, Q3, and Q4.
8.6.1  8-bit Serial/Parallel-in and Serial/Parallel-out Shift Register
The pinout diagram of IC 74198 is shown in Figure 8.11. IC 74198 is an example of 
an 8-bit parallel-in and parallel-out shift register. IC 74198 is a 24-pin package where 16 
pins are needed just for the input and output data lines. This chip can even shift data 
through the register in either direction, i.e., shift-right and shift-left.
Figure 8.11 Pinout diagram of IC 74198, 8-bit parallel-in–parallel-out shift register.
L i.e., pin 22 in Figure 8.11, represents the shift-left serial input and R (pin 2) represents 
the shift-right serial input. An 8-bit register can be created by either connecting two 4-bit 
registers in series or by manufacturing the two 4-bit registers on a single chip and placing 
the chip in a 24-pin package such as IC 74198. 
There are a number of 4-bit parallel-input–parallel-output shift registers available 
since they can be conveniently packaged in a 16-pin dual-inline package. IC 74195 is a 4-bit 
TTL MSI having both serial/parallel input and serial/parallel output capability. The pinout 
diagram of IC 74195 is shown in Figure 8.12. Since this IC has a serial input, it can also 
be used for serial-in–serial-out and serial-in–parallel-out operation. This IC can be used for 
parallel-in–serial-out operation by using QD as the output.
Figure 8.12 Pinout diagram of IC 74195.
When the SH / LD input is LOW, the data on the parallel inputs, i.e., A, B, C, and D 
are entered synchronously on the positive transition of the clock. When SH / LD is HIGH, 
the stored data will shift right (QA to QD) synchronously with the clock. J and K are the 
serial inputs to the ﬁ rst stage of the register (QA); QD can be used for getting a serial output 
data. The active low clear is asynchronous.
24
23
22
21
20
16
19
15
18
14
17
13
1
VC C
S0
S1
L
A
H
Q H
Q A
QG
QB
QF
QC
QD
QE
F
B
D
C
CLK
G
E
R
CLR
GND
IC  74198
2
3
4
5
9
6
10
7
11
8
12
16
15
14
13
12
11
10
9
1
VC C
SH /LD
K
J
A
CLK
QA
Q B
QC
QD
QD
C
B
D
CLR
GND
IC  74195
2
3
4
5
6
7
8

274
DIGITAL PRINCIPLES AND LOGIC DESIGN
8.7  UNIVERSAL REGISTER
A register that is capable of transfering data in only one direction is called a ‘unidirectional 
shift register,’ whereas the register that is capable of transfering data in both left and right 
direction is called a ‘bidirectional shift register.’ Now if the register has both the shift-right 
and shift-left capabilities, along with the necessary input and output terminals for parallel 
transfer, then it is called a shift register with parallel load or ‘universal shift register.’ 
The most general shift register has all the capabilities listed below. Others may have 
only some of these functions, with at least one shift operation.
 
1. A shift-right control to enable the shift-right operation and the serial input and output 
lines associated with the shift-right. 
 
2. A shift-left control to enable the shift-left operation and the serial input and output 
lines associated with the shift-left. 
 
3. A parallel-load control to enable a parallel transfer and the n input lines associated 
with the parallel transfer. 
4. n parallel output lines.
 
5. A clear control to clear the register to 0.
 
6. A CLK input for clock pulses to synchronize all operations.
 
7. A control state that leaves the information in the register unchanged even though 
clock pulses are continuously applied.
Figure 8.13 4-bit universal shift register.
S
CLK
Serial input for
shift-right
Clear
Q
Q
Q
Q
D
D
D
D
1
S
I
A
I
A
Parallel outputs
Parallel inputs
I
A
I
A
0
4
4
3
3
2
2
1
1
3   2   1    0
3   2   1    0
3   2   1    0
3   2   1    0
4 × 1
M UX
4 × 1
M UX
4 × 1
M UX
4 × 1
M UX
Serial input
for shift-left

REGISTERS 275
The diagram of a shift-register with all the capabilities listed above is shown in Figure 
8.13. This is similar to IC type 74194. Though it consists of four D ﬂ ip-ﬂ ops, S-R ﬂ ip-ﬂ ops can 
also be used with an inverter inserted between the S and R terminals. The four multiplexers 
drawn are also part of the register. The four multiplexers have two common selection lines 
S1 and S0. When S1S0 = 00, the input 0 is selected for each of the multiplexers. Similarly, 
when S1S0 = 01, the input 1, when S1S0 = 10, the input 2 and for S1 S0 = 11, the input 3, is 
selected for each of the multiplexers.
The S1 and S0 inputs control the mode of operation of the register as speciﬁ ed in 
the entries of functions in Table 8.3. When S1S0 = 00, the present value of the register is 
applied to the D inputs of the ﬂ ip-ﬂ ops. Hence this condition forms a path from the output 
of each ﬂ ip-ﬂ op into the input of the same ﬂ ip-ﬂ op. The next clock pulse transition transfers 
into each ﬂ ip-ﬂ op the binary value held previously, and no change of state occurs. When 
S1S0 = 01, terminals 1 of each of the multiplexer inputs have a path to the D inputs of 
each of the ﬂ ip-ﬂ ops. This causes a shift-right operation, with the serial input transferred 
into ﬂ ip-ﬂ op A4. Similarly, with S1S0 = 10, a shift-left operation results, with the other serial 
input going into ﬂ ip-ﬂ op A1. Finally, when S1S0 = 11, the binary information on the parallel 
input lines is transferred into the register simultaneously during the next clock pulse. 
Table 8.3 Function table for the universal register
Mode control 
Register operation 
 
S1 
S0
 
0 
0 
No change
 
0 
1 
Shift-right
 
1 
0 
Shift-left
 
1 
1 
Parallel load 
A universal register is a general-purpose register capable of performing three operations: 
shift-right, shift-left, and parallel load. Not all shift registers available in MSI circuits have 
all these capabilities. The particular application dictates the choice of one MSI circuit over 
another.  As we have already mentioned IC 74194 is a 4-bit bidirectional shift register with 
parallel load. The pinout diagram of IC 74194 is shown in Figure 8.14.
Figure 8.14 Pinout diagram of IC 74194.
The parallel loading of data is accomplished with a positive transition of the clock 
and by applying the four bits of data to the parallel inputs and a HIGH to the S1 and S0
inputs. Similarly, shift-right is accomplished synchronously with the positive edge of the 
16
15
14
13
12
11
10
9
1
VC C
B
A
C
CLK
QA
QB
Q C
S1
S0
QD
D
SLSER
SR SER
CLR
GND
IC  74194
2
3
4
5
6
7
8

276
DIGITAL PRINCIPLES AND LOGIC DESIGN
clock when S0 is HIGH and S1 is LOW. In this mode the serial data is entered at the shift-
right serial input. In the same manner, when S0 is LOW and S1 is HIGH, data bits shift left 
synchronously with the clock pulse and new data is entered at the shift-left serial input.
8.8  SHIFT REGISTER COUNTERS
Shift registers may be arranged to form different types of counters. These shift registers 
use feedback, where the output of the last ﬂ ip-ﬂ op in the shift register is fed back to the 
ﬁ rst ﬂ ip-ﬂ op. Based on the type of this feedback connection, the shift register counters are 
classiﬁ ed as (i) ring counter and (ii) twisted ring or Johnson or Shift counter.
8.8.1  Ring Counter
It is possible to devise a counter-like circuit in which each ﬂ ip-ﬂ op reaches the state 
Q = 1 for exactly one count, while for all other counts Q = 0. Then Q indicates directly 
an occurrence of the corresponding count. Actually, since this does not represent binary 
numbers, it is better to say that the outputs of the ﬂ ip-ﬂ ops represent a code.  Such a 
circuit is shown in Figure 8.15, which is known as a ring counter. The Q output of the 
last stage in the shift register is fed back as the input to the ﬁ rst stage, which creates a 
ring-like structure.
Hence a ring counter is a circular shift register with only one ﬂ ip-ﬂ op being set at any 
particular time and all others being cleared. The single bit is shifted from one ﬂ ip-ﬂ op to 
the other to produce the sequence of timing signals. Such encoding where there is a single 
1 and the rest of the code variables are 0, is called a one-hot code.
Table 8.4 Truth table for a 4-bit ring counter
INIT 
CLK 
QA 
QB 
QC 
QE
 
L 
X 
0 
0 
0 
1
 
H 
↑ 
1 
0 
0 
0
 
H 
↑ 
0 
1 
0 
0
 
H 
↑ 
0 
0 
1 
0
 
H 
↑ 
0 
0 
0 
1
The circuit shown in Figure 8.15 consists of four ﬂ ip-ﬂ ops and their outputs are QA,
QB, QC, and QE respectively. The PRESET input of the last ﬂ ip-ﬂ op and the CLEAR inputs 
of the other three ﬂ ip-ﬂ ops are connected together. Now, by applying a LOW pulse at this 
line, the last ﬂ ip-ﬂ op is SET and all the others are RESET, i.e., QAQBQCQE = 0001. Hence, 
from the circuit it is clear that DA = 1, DB = 0, DC = 0, and DE = 0. Therefore, when a clock 
pulse is applied, the ﬁ rst ﬂ ip-ﬂ op is set to 1, while the other three ﬂ ip-ﬂ ops are reset to 0 
i.e., the output of the ring counter is QAQBQCQE = 1000. Similarly, when the second clock 
pulse is applied, the 1 in the ﬁ rst ﬂ ip-ﬂ op is shifted to the second ﬂ ip-ﬂ op and the output 
of the ring counter becomes QAQBQCQE = 0100; on occurrence of the third clock pulse, the 
output will be QAQBQCQE = 0010; on occurrence of the fourth clock pulse the output becomes 
QAQBQCQE = 0001, i.e., the initial state. Thus, the 1 is shifted around the register as long 
as the clock pulses are applied. The truth table that describes the operation of the above 
4-bit ring counter is shown in Table 8.4. 

REGISTERS 277
Figure 8.15 A 4-bit ring counter using D ﬂ ip-ﬂ ops.
8.8.2  Johnson Counter
A k-bit ring counter circulates a single bit among the ﬂ ip-ﬂ ops to provide k distinguishable 
states. The number of sates can be doubled if the shift register is connected as a switch-tail
ring counter. A switch-tail ring counter is a circular shift register with the complement of 
the last ﬂ ip-ﬂ op being connected to the input of the ﬁ rst ﬂ ip-ﬂ op. Figure 8.16 shows such 
a type
Figure 8.16 A 4-bit Johnson counter using D ﬂ ip-ﬂ ops and decoding gates.
D
D
D
D
PR
PR
PR
PR
Q
Q
Q
Q
Q
CLK
Q A
Q B
Q C
Q E
IN IT
Q
Q
Q
CLR
CLR
CLR
CLR
D
D
D
D
PR
A'E'
AB'
BC '
CE'
AE
A'B
B'C
C'E
PR
PR
PR
Q
Q
Q
Q
Q
Q
Q
Q
Q A
Q B
Q C
Q E
CLR
CLK
CLR
CLR
CLR

278
DIGITAL PRINCIPLES AND LOGIC DESIGN
of shift register. The circular connection is made from the complement of the rightmost ﬂ ip-
ﬂ op to the input of the leftmost ﬂ ip-ﬂ op. The register shifts its contents once to the right 
with every clock pulse, and at the same time, the complement value of the E ﬂ ip-ﬂ op is 
transferred into the A ﬂ ip-ﬂ op. Starting from a cleared state, the switch-tail ring counter 
goes through a sequence of eight states as listed in Table 8.5. In general a k-bit switch-tail 
counter will go through 2k states. Starting with all 0s each shift operation inserts 1s from 
the left until the register is ﬁ lled with all 1s. In the following sequences, 0s are inserted 
from the left until the register is again ﬁ lled with all 0s.
A Johnson or moebius counter is a switch-tail ring counter with 2k decoding gates to 
provide outputs for 2k timing signals. The decoding gates are also shown in Figure 8.16. 
Since each gate is enabled during one particular state sequence, the outputs of the gates 
generate eight timing sequences in succession. 
The decoding of a k-bit switch-tail ring counter to obtain 2k timing sequences follows 
a regular pattern. The all-0s state is decoded by taking the complement of the two extreme 
ﬂ ip-ﬂ op outputs. The all-1s state is decoded by taking the normal outputs of the two extreme 
ﬂ ip-ﬂ ops. All other states are decoded from an adjacent 1, 0 or 0, 1 pattern in the sequence. 
For example, sequence 6 has an adjacent 0 and 1 pattern in ﬂ ip-ﬂ ops A and B. the decoded 
output is then obtained by taking the complement A and the normal of B, or the A′B.
Table 8.5 Count sequence of a 4-bit Johnson counter
Sequence 
 
Flip-ﬂ op outputs
 
number 
A 
B 
C 
E
 
1 
0 
0 
0 
0
 
2 
1 
0 
0 
0
 
3 
1 
1 
0 
0
 
4 
1 
1 
1 
0
 
5 
1 
1 
1 
1
 
6 
0 
1 
1 
1
 
7 
0 
0 
1 
1
 
8 
0 
0 
0 
1
One disadvantage of the circuit in Figure 8.16 is that, if it ﬁ nds itself in an unused 
state, it will persist in moving from one invalid state to another and never ﬁ nd its way to a 
valid state. The difﬁ culty can be corrected by modifying the circuit to avoid this undesirable 
condition. One correcting procedure is to disconnect the output from ﬂ ip-ﬂ op B that goes to 
the D input of ﬂ ip-ﬂ op C, and instead enable the input of ﬂ ip-ﬂ op C by the function:
 
 
DC = (A + C)B
where DC is the ﬂ ip-ﬂ op input function for the D input of the ﬂ ip-ﬂ op C. 
Johnson counters can be constructed for any number of timing sequences. The number 
of ﬂ ip-ﬂ ops needed is one-half the number of timing signals. The number of decoding gates 
is equal to the number of timing sequences and only 2-input gates are employed. Ring 
counter does not require any decoding gates, since in ring counter only one ﬂ ip-ﬂ op will be 
in the set condition at any time.

REGISTERS 279
8.9  SEQUENCE GENERATOR
A sequence generator is a circuit that generates a desired sequence of bits in synchronization with 
a clock. A sequence generator can be used as a random bit generator, code generator, and prescribed 
period generator. The block diagram of a sequence generator is shown in Figure 8.17.
Figure 8.17 Block diagram of a sequence generator.
The sequence generator can be constructed using shift register and a next state 
decoder. The output of the next state decoder (Z) is a function of QN-1, QN-2,……Q1, Q0 and 
is connected to the serial input of the shift register. This sequence generator is similar to 
a ring counter or a Johnson counter. 
8.9.1  Design of a 4-bit Sequence Generator
We consider the design of a sequence generator to generate a sequence of 1001. The 
minimum number of ﬂ ip-ﬂ ops (n) required to generate a sequence of length N is given by 
 
 
 
N < 2" – 1
Here N = 4 and hence, the minimum value of n to satisfy the above condition is 3, 
i.e., three ﬂ ip-ﬂ ops are required to generate the given sequence. If the given sequence does 
not lead to four distinct states, then more than three ﬂ ip-ﬂ ops are required. The states of 
the given sequence generator are given in Table 8.6. 
Table 8.6 State table for a 4-bit (1001) sequence generator
CLK 
Flip-Flop outputs 
Serial Input
 
 
Q2 
Q1 
Q0 
Z 
 
1 
1 
1 
0 
0 
 
2 
0 
1 
1 
0 
 
3 
0 
0 
1 
1 
 
4 
1 
0 
0 
1 
 
1 
1 
1 
0 
0 
 
2 
0 
1 
1 
0 
 
X 
0 
0 
1 
1 
 
X 
1 
0 
0 
1
In Table 8.6, the given sequence (1001) is listed under Q2 and the sequence under Q1
and Q0 are the same sequence delayed by one and two clock pulses respectively as indicated 
Shift Register
Next State Decoder
CLK
Z
Serial input
Sequence O/P
QN –1
Q 1 Q 0
Q N –2
.........

280
DIGITAL PRINCIPLES AND LOGIC DESIGN
by arrow marks. Also, it is observed that all the four states are distinct and hence three 
ﬂ ip-ﬂ ops are sufﬁ cient to implement the sequence generator. The last column gives the 
serial input required at the shift register (i.e., D2 of MSB ﬂ ip-ﬂ op), assuming D ﬂ ip-ﬂ ops 
are used and considering the output at Q2. Now, the K-map for the serial input (Z) is shown 
in Figure 8.18.
Figure 8.18 K-map of serial input (Z) for a 4-bit (1001) sequence generator.
From the K-map shown in Figure 8.18, the simpliﬁ ed expression for serial input Z 
can be written as
 
 
 
Z = Q′1.
Therefore, using the simpliﬁ ed expression for Z, the logic diagram of a given 4-bit 
sequence generator can be drawn as shown in Figure 8.19.
Figure 8.19 Logic diagram of a 4-bit (1001) sequence generator.
8.9.2  Design of a 5-bit Sequence Generator
We consider the design of a sequence generator to generate a sequence of 10011. The 
minimum number of ﬂ ip-ﬂ ops (n) required to generate a sequence of length N is given by 
the equation
 
 
 
N < 2" – 1.
Here N = 5 and hence, the minimum number of ﬂ ip-ﬂ ops required (n) to satisfy the 
above condition is 3. If the given sequence does not lead to ﬁ ve distinct states, then more 
than three ﬂ ip-ﬂ ops may be required. The states of the given sequence generator are shown 
in Table 8.7.
As explained in the previous section, the given sequence (10011) is listed under Q2
and the sequence under Q1 and Q0 are the same sequence delayed by one and two clock 
pulses respectively as indicated by arrow marks. Also, it is observed that all 5 states are 
distinct and hence three ﬂ ip-ﬂ ops are sufﬁ cient to implement the sequence generator. The 
last column gives the serial input required at the shift register (i.e., D2 of MSB ﬂ ip-ﬂ op), 
assuming D ﬂ ip-ﬂ ops are used and considering the output at Q2. Now, the K-map for the 
serial input (Z) is shown in Figure 8.20.
X
1
X
X
X
1
00
0
1
01
11
10
Q Q
1
0
Q 2
Q'1
0
0
D
Serial
input (Z)
Sequence generator
output
D
Q 2
Q 1
Q 0
D
CLK
Q
Q
Q
Q
Q
Q

REGISTERS 281
Table 8.7 State table for a 5-bit (10011) sequence generator
CLK 
    Flip-Flop outputs 
Serial Input
 
 
Q2 
Q1 
Q0 
Z 
 
1 
1 
1 
1 
0 
 
2 
0 
1 
1 
0 
 
3 
0 
0 
1 
1 
 
4 
1 
0 
0 
1 
 
5 
1 
1 
0 
1 
 
1 
1 
1 
1 
0 
 
2 
0 
1 
1 
0 
 
X 
0 
0 
1 
1 
 
X 
1 
0 
0 
1 
 
X 
1 
1 
0 
1 
Figure 8.20 K-map of serial input (Z) for a 5-bit (10011) sequence generator.
From the K-map shown in Figure 8.20, the simpliﬁ ed expression for serial input Z 
can be written as
 
 
 
Z = Q′1 + Q′0.
 
Therefore, using the simpliﬁ ed expression for Z, the logic diagram of a given 5-bit 
sequence generator can be drawn as shown in Figure 8.21.
Figure 8.21 Logic diagram of a 5-bit (10011) sequence generator.
X
1
0
X
1
0
X
1
00
0
1
01
11
10
Q Q
1
0
Q 2
Q'1
Q'0
Serial
Input (Z)
Sequence generator 
output
Q 2
Q 1
Q 0
D
D
D
Q
Q
Q
Q
Q
Q
CLK

282
DIGITAL PRINCIPLES AND LOGIC DESIGN
8.9.3  Design of a 6-bit Sequence Generator
We consider the design of a sequence generator to generate a sequence of 110101. The minimum 
number of ﬂ ip-ﬂ ops (n) required to generate a sequence of length N is given by the equation
 
 
 
N < 2" – 1.
Here N = 6 and hence, the minimum number of ﬂ ip-ﬂ ops required (n) to satisfy the above 
condition is 3. If the given sequence does not lead to six distinct states, then more than three 
ﬂ ip-ﬂ ops may be required. The states of the given sequence generator are shown in Table 8.8. 
Table 8.8 State table for a 6-bit (110101) sequence generator
CLK 
 
Flip-Flop outputs 
 
 
Q2 
Q1 
Q0
 
1 
1 
1 
0 
 
2 
1 
1 
1 
 
3 
0 
1 
1 
 
4 
1 
0 
1 
 
5 
0 
1 
0 
 
6 
1 
0 
1 
 
1 
1 
1 
0 
 
2 
1 
1 
1
Table 8.9 Modiﬁ ed state table for a 6-bit (110101) sequence generator
CLK 
Flip-Flop outputs 
  Serial Input 
 
 
Q3 
Q2 
Q1 
Q0 
Z 
 
1 
1 
1 
0 
1 
1 
 
2 
1 
1 
1 
0 
0 
 
3 
0 
1 
1 
1 
1 
 
4 
1 
0 
1 
1 
0 
 
5 
0 
1 
0 
1 
1 
 
6 
1 
0 
1 
0 
1 
 
1 
1 
1 
0 
1 
1 
 
2 
1 
1 
1 
0 
0 
 
3 
0 
1 
1 
1 
1 
 
4 
1 
0 
1 
1 
0 
 
5 
0 
1 
0 
1 
1 
 
6 
1 
0 
1 
0 
1 

REGISTERS 283
As explained in the previous section, the given sequence (110101) is listed under Q2
and the sequence under Q1 and Q0 are the same sequence delayed by one and two clock 
pulses respectively as indicated by arrow marks. From Table 8.8, it is observed that all six 
states are not distinct, i.e., 101 state occurs twice. Hence three ﬂ ip-ﬂ ops are not sufﬁ cient 
to generate the given sequence. Next, assuming n = 4, the modiﬁ ed state table for the given 
sequence generator can be shown in Table 8.9. 
From Table 8.9, it is observed that all six states are distinct and hence four ﬂ ip-ﬂ ops 
are sufﬁ cient to implement the sequence generator. The last column gives the serial input 
required at the shift register (i.e., D3 of the MSB ﬂ ip-ﬂ op), assuming D ﬂ ip-ﬂ ops are used 
and considering the output at Q3. Now, the K-map for the serial input (Z) is shown in 
Figure 8.22.
Figure 8.22 K-map of serial input (Z) for a 6-bit (110101) sequence generator.
From the K-map shown in Figure 8.18, the simpliﬁ ed expression for serial input Z 
can be written as 
 
 
 
Z = Q′3 + Q′1 + Q′2Q′0.
Therefore, using the simpliﬁ ed expression for Z, the logic diagram of a given 6-bit 
sequence generator can be drawn as shown in Figure 8.23.
Figure 8.23 Logic diagram of a 6-bit (110101) sequence generator.
8.10  SERIAL ADDITION
Serial addition is much slower than parallel addition, but requires less equipment. We now 
demonstrate the serial mode of operation.
X
X
X
X
X
1
X
0
X
X
0
1
X
1
1
X
00
00
11
01
10
01
11
10
Q Q
1
0
Q Q
3
2
Sequence generator 
output
D
D
D
D
Q
Q
Q
Q
Q 0
Q 1
Q 2
Q 3
Serial
input (Z)
CLK
Q
Q
Q
Q

284
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 8.24 Serial adder
The two binary numbers to be added serially are stored in two shift registers. Bits 
are added one pair at a time, sequentially, through a single full-adder (FA) circuit shown 
in Figure 8.24. The carry out of the full adder is transferred to a D ﬂ ip-ﬂ op. The output 
of this ﬂ ip-ﬂ op is then used as an input carry for the next pair of signiﬁ cant bits. The two 
shift registers are shifted to the right for one word-time period. The sum bits from the S
output of the full adder could be transferred into a third shift register. By shifting the sum 
into A while the bits of A are shifted out, it is possible to use one register to store both 
the augend and the sum bits. The serial input (SI) of register B is able to receive a new 
binary number while the addend bits are shifted out during the addition.
The operation of the serial adder is as follows. Initially the augend is in register A,
the addend is in register B, and the carry ﬂ ip-ﬂ op is cleared to 0. The serial outputs (SO) 
of A and B provide a pair of signiﬁ cant bits for the full-adder at x and y. Output Q of the 
ﬂ ip-ﬂ op gives the input carry as z. The shift-right control enables both registers and the 
carry ﬂ ip-ﬂ op. Hence at the next clock pulse, both registers are shifted once to the right, the 
sum bit from S enters the leftmost ﬂ ip-ﬂ op of A, and the output carry is transferred into the 
ﬂ ip-ﬂ op Q. The shift-right control enables the registers for a number of clock pulses equal 
to the number of bits in the registers. For each succeeding clock pulse, a new sum bit is 
transferred to A, a new carry is transferred to Q, and both registers are shifted once to the 
right. This process continues until the shift-right control gets disabled. Thus the addition is 
accomplished by passing each pair of bits together with the previous carry through a single 
full-adder circuit and transferring the sum, one bit at a time, into register A.
If a new number has to be added to the contents of register A, this number must 
be ﬁ rst transferred into register B. Repeating the process once more will add the second 
number to the previous number in A.
8.11  BINARY DIVIDER
We consider the design of a parallel divider for positive binary numbers. As an example 
we design a network to divide a 6-bit dividend by a 3-bit divisor to obtain a 3-bit quotient. 
The following example illustrates the division process:
Q
Q
x
S
SO
SO
SI
Shift-right
External
input
CP
Shift-register A
Shift-register B
C
y
FA
z
D

REGISTERS 285
 
 
 
 
     111 
 
quotient
 
 
divisor    101   100110 
 
( with a remainder of 4)
 
 
 
         101   
 
dividend     
 
 
 
 
   1001
 
 
 
 
   101
 
 
 
 
   1000
 
 
 
 
   101 
 
 
 
 
   011  
 
remainder.
Binary division can be carried out by a series of subtract and shift operations. To 
construct the divider, we will use a 7-bit dividend register and a 3-bit divisor register as 
shown in Figure 8.25. During the division process, instead of shifting the divisor right before 
each subtraction, we will shift the dividend to the left. Now an extra bit is required to the 
left end of the dividend register so that a bit is not lost when the dividend is shifted left. 
Instead of using a separate register to store the quotient, we will enter the quotient bit-by-
bit into the right end of the dividend register as the dividend is shifted left.
Figure 8.25 Block diagram for a parallel binary divider.
The preceding division example ( ) is reworked below showing location of the bits in the 
registers at each clock time. Initially the dividend and the divisor are entered as follows:
Subtraction cannot be carried out with a negative result, so we will shift before we 
subtract. Instead of shifting the divisor one place to the right, we will shift the dividend 
one place to the left: 
1   0   0   1   1   0    0   
Dividing line between dividend and quotient.
    1   0   1        
Note that after the shift, the rightmost position in 
 
the dividend is “empty.” In effect, the quotient bit is 
 
initially set to 0 and if subtraction occurs, it is changed 
 
to 1.
x7
y 3
Subtracter
and
Com parator
x6
y2
x5
y1
Clock
Divisor
C
Su
Sh
x 4
x 3
Dividend R egister
St (Start Signal)
x 2
x 1
Control
V
(Overflow Indicator)

286
DIGITAL PRINCIPLES AND LOGIC DESIGN
Subtraction is now carried out and the ﬁ rst quotient digit of 1 is stored in the unused 
position of the dividend register:
 
0   1   0   0   1   0     1 
 
ﬁ rst quotient digit.
Next we shift the dividend one place to the left:
 
1   0   0   1   0     1   0
       1   0   1
Subtraction is again carried out and the second quotient digit of 1 is stored in the 
unused position of the dividend register:
 
0   1   0   0   0      1   1 
         
We shift the dividend one place to the left again:
 
1   0   0   0     1   1    0
       1   0   1
A ﬁ nal subtraction is carried out and the third quotient bit is set to 1:
 
0   0   1   1     1   1   1 
    remainder      quotient
The ﬁ nal result agrees with that obtained in the ﬁ rst example.
If, as a result of a division operation, the quotient would contain more bits than are 
available for storing the quotient, we say that an overﬂ ow has occurred. For the divider 
of Figure 8.25, an overﬂ ow may occur if the quotient is greater than 7, since only 3 bits 
are provided to store the quotient. It is not actually necessary to carry out the division to 
determine if an overﬂ ow condition exists, since an initial comparison of the dividend and 
divisor will tell if the quotient will be too large. For example, if we attempt to divide 38 
by 4, the initial contents of the registers would be:
 
0   1   0   0   1   1   0
       1   0   0
Since subtraction can be carried out with a nonnegative result, we should subtract 
the divisor from the dividend and enter a quotient bit of 1 in the rightmost place in the 
dividend register. However, we cannot do this because the rightmost place contains the least 
signiﬁ cant bit of the dividend, and entering a quotient bit here will destroy that dividend 
bit. Therefore the quotient will be too large to store in the 3 bits we have allocated for 
it, and an overﬂ ow condition is detected. In general, for Figure 8.25, if initially x7x6x5x4 > 
y3y2y1 (i.e., if the left four bits of the dividend register exceeds or equal the divisor) the 
quotient will be grater than 7 and an overﬂ ow occurs. Note that if x7x6x5x4 > y3y2y1, the 
quotient is
The operation of the divider can be explained in terms of the block diagram of Figure 
8.25. A shift signal (Sh) will shift the dividend one place to the left. A subtract signal (Su) will 
x x x x x x x
y y y
x x x x
y y y
7
6
5
4 3
2
1
3
2
1
7
6
5
4
3
2
1
000
≥
 = 
x x x x
y y y
7
6
5
4
3
2
1
8
8.
×
≥

REGISTERS 287
subtract the divisor from the four leftmost bits in the dividend register and set the quotient 
bit (the rightmost bit of the dividend register) to 1. If the divisor is greater than the four 
leftmost dividend bits, the comparator output is C = 0; otherwise C = 1. The control circuit 
generates the required sequence of shift and subtract signals. Whenever C = 0, subtraction 
cannot occur without a negative result, so a shift signal is generated. Whenever C = 1, a 
subtract signal is generated and the quotient bit is set to one.
Figure 8.26 shows the state diagram for the control circuit. Initially, the 6-bit dividend 
and the 3-bit divisor are entered into the appropriate registers. The circuit remains in the 
stop state (S0) until a start signal (St) is applied to the control circuit. If the initial value 
of C is 1, the quotient would require four or more bits. Since space is only provided for a 
3-bit quotient, this condition leads to an overﬂ ow, so the divider is stopped and the overﬂ ow 
indicator is set by the V output. Normally, the initial value of C is 0, so a shift will occur 
ﬁ rst and the control circuit will go to state S1. Then, if C = 1 subtraction takes place. After 
the subtraction is completed, C will always be 0, so that the next clock pulse will produce 
a shift. This process continues until three shifts have occurred and the control is in state 
S3. Then a ﬁ nal subtraction occurs if necessary, and the control returns to the stop state. 
Figure 8.26 State graph for control circuit.
For this example, we will assume that when the start signal (St) occurs, it will be 1 for one 
clock time, and then it will remain 0 until the clock network is back in state S0. Therefore, St 
will always be 0 in states S1, S2, and S3. Table 8.10 gives the state table for the control circuit. 
Since we assumed that St = 0 in states S1, S2, and S3, the next states and outputs are don’t-cares 
for these states when St = 1. The entries in the output table indicate which outputs are 1.
Table 8.10 State table for Figure 8.26
Present 
StC 
Output
 
AB 
State 
00 
01 
11 
10 
00 
01 
11 
10
 
00 
S0
S0
S0
S0 
S1
0 
0 
V 
Sh
 
01 
S1
S2
S1 
– 
– 
Sh 
Su 
– 
–
 
11 
S2
S3
S2 
– 
– 
Sh 
Su 
– 
–
 
10 
S3
S0 
S0 
– 
 – 
 0 
Su 
– 
– 
S
(Stop)
0
St'/0
C'/0
C/Su
C'St/Sh
CSt/V
S 2
S 3
S1
C/Su
C'/Sh
C'/Sh
C/Su

288
DIGITAL PRINCIPLES AND LOGIC DESIGN
For example, the entry Sh means Sh = 1 and the other outputs are 0. Using the state 
assignment shown in Table 8.10 for J-K ﬂ ip-ﬂ ops A and B, the following equations may be 
derived for the control circuit:
JA = BC′, 
KA = B′, 
JB = St • C′, 
KB = AC′,
Sh = (St + B)C′, 
Su = C(A + B), 
V = C • St.
Figure 8.27 Logic diagram for binary divider.
Figure 8.27 shows a logic diagram for the subtractor/comparator, dividend register 
and control network. The subtractor is constructed using four full subtractors. When the 
numbers are entered into the divisor and dividend registers, the borrow signal will propagate 
through the full subtractors before the subtractor output is transferred to the dividend 
register. If the last borrow signal (b8) is 1, this means that the result would be negative if 
the subtraction were carried out. Hence, if b8 is 1, the divisor is greater than x7x6x5x4, and 
C = 0. Therefore, C = b′8 and the dividend register so that if Sh = 1 a left shift will take 
place when the clock pulse occurs, and if Su = 1 the subtractor output will be transferred 
to the dividend register when the clock pulse occurs. For example,
D 7
x 7
x 6
x 5
x 4
x 3
x 2
x 2
x 1
x1
x'7
x'6
x'5
x'4
x'3
x'2
x'1
D 6
D 5
D 4
D 3
D 2
Sh
Control
Circuit
Su
Sh  x
     Su
7   
x7
x6
x5
x4
y3
y2
y1
0
C
Divisor
Sh  x
    Su
5     
Sh  x
     Su
4     
Sh  x3
d4
FS
FS
FS
FS
d  = 0
4
b  = C'
8
Su
Su
v
Sh
St
St
A'
A'
A
B
KA
B'
B
A
St
C'
C'
C'
KA
JA
JB
C'
C
Sh
Su
CLK
4-bit serial-parallel left
shift register
D 1

REGISTERS 289
D4 = Su • d4 + Sh • x3 = x+
4.
If Su = 1 and Sh = 0, and the subtracter output is transferred to the register of ﬂ ip-
ﬂ ops. If Su = 0 and Sh = 1,  and a left shift occurs. Since D1 = Su, the quotient bit (x1) is 
cleared when shifting occurs (Su = 0) and the quotient bit is set to 1 during subtraction 
(Su = 1). Note that the clock pulse is gated so that ﬂ ip-ﬂ ops x7, x6, x5, x4, and x1 are clocked 
when Su or Sh is 1, while ﬂ ip-ﬂ ops x3 and x2 are clocked only when Sh is 1.
REVIEW QUESTIONS
8.1 A shift register has seven ﬂ ip-ﬂ ops. What is the largest binary number that can be stored in 
it? Octal number? Decimal number? Hexadecimal number?
8.2 What are the four basic types of shift registers? Draw a block diagram for each of them.
8.3 The hexadecimal number AC is stored in the IC 7491 shown in Figure 8.6. Show the waveforms 
at the output, assuming that the clock is allowed to run for eight cycles and that A = C = 0.
8.4 Why are shift registers considered to be basic memory devices? 
8.5 Explain the workings of a serial-in–parallel-out shift register with logic diagram and 
waveforms.
8.6 Explain the workings of a serial-in–serial-out shift register with logic diagram and waveforms.
8.7 Describe a parallel-in–parallel-out shift register with a neat logic diagram.
8.8 Explain how a parallel-in–serial-out shift register works with a logic diagram.
8.9 Why does a Johnson counter have decoding gates, whereas a ring counter does not?
8.10 Construct a Johnson counter for twelve timing sequences.
8.11 Why are sequence generators used? Design a sequence generator to generate the sequence 111011.
8.12 Design a 6-bit ring counter using J-K ﬂ ip-ﬂ ops.
8.13 Determine the frequency of the pulses at points a, b, c, and d in the circuit of Figure P. 8.1. 
Figure P.8.1
8.14 The content of a 4-bit register is initially 1011. The register is shifted 7 times to the right with 
the serial input being 1010110. What is the content of the register after each shift?
8.15 Draw the circuit for a universal shift register and explain its operation.
8.16 (a) List the eight unused states in the switch-tail ring counter of Figure 8.16. Determine the 
next state for each unused state and show that, if the circuit ﬁ nds itself in an invalid state, it 
does not return to a valid state. 
 
 (b) Modify the circuit as recommended in the text and show that:
 
   (1) The circuit produces the same sequences as listed in Table 8.5, and 
 
   (2) The circuit reaches a valid state from any one of the unused states.
8.17 Write a short note on a Johnson counter.
❑ ❑ ❑
10-bit
ring
counter
320 KHz
4-bit
parallel
counter
M OD-20
ripple
counter
5-bit
Johnson
counter
a
b
c
d
10-bit
ring
counter
4-bit
parallel
counter
M OD-20
ripple
counter
5-bit
Johnson
counter
a
b
c
d


291
9.1  INTRODUCTION
C
ounters are one of the simplest types of sequential networks. A counter is usually 
constructed from one or more ﬂ ip-ﬂ ops that change state in a prescribed sequence 
when input pulses are received. A counter driven by a clock can be used to count the 
number of clock cycles. Since the clock pulses occur at known intervals, the counter can be 
used as an instrument for measuring time and therefore period of frequency. Counters can 
be broadly classiﬁ ed into three categories:
 (i) Asynchronous and Synchronous counters.
 (ii) Single and multimode counters.
 (iii) Modulus counters.
The asynchronous counter is simple and straightforward in operation and construction 
and usually requires a minimum amount of hardware. In asynchronous counters, each ﬂ ip-
ﬂ op is triggered by the previous ﬂ ip-ﬂ op, and hence the speed of operation is limited. In 
fact, the settling time of the counter is the cumulative sum of the individual settling times 
of the ﬂ ip-ﬂ ops. This type of counters is also called ripple or serial counter.
The speed limitation of asynchronous counters can be overcome by applying clock pulses 
simultaneously to all of the ﬂ ip-ﬂ ops. This causes the settling time of the ﬂ ip-ﬂ ops to be equal 
to the propagation delay of a single ﬂ ip-ﬂ op. The increase in speed is usually attained at the 
price of increased hardware. This type of counter is also known as a parallel counter.
The counters can be designed such that the contents of the counter advances by one 
with each clock pulse; and is said to operate in the count-up mode. The opposite is also 
possible, when the counter is said to operate in the count-down mode. In both cases the 
counter is said to be a single mode counter. If the same counter circuit can be operated in 
both the UP and DOWN modes, it is called a multimode counters.
Modulus counters are deﬁ ned based on the number of states they are capable of 
counting. This type of counter can again be classiﬁ ed into two types: Mod N and MOD < N.
For example, if there are n bits then the maximum number counted can be 2n or N. If the 
counter is so designed that it can count up to 2n or N states, it is called MOD N or MOD 
COUNTERS
9
C h a p t e r

292
DIGITAL PRINCIPLES AND LOGIC DESIGN
2n counter. On the other hand, if the counter is designed to count sequences less than the 
maximum value attainable, it is called a MOD < N or MOD < 2n counter.
9.2  ASYNCHRONOUS (SERIAL OR RIPPLE) COUNTERS
The simplest counter circuit can be built using T ﬂ ip-ﬂ ops because the toggle feature is 
naturally suited for the implementation of the counting operation. J-K ﬂ ip-ﬂ ops can also 
be used with the toggle property in hand. Other ﬂ ip-ﬂ ops like D or S-R can also be used, 
but they may lead to more complex designs. 
In this counter all the ﬂ ip-ﬂ ops are not driven by the same clock pulse. Here, the clock 
pulse is applied to the ﬁ rst ﬂ ip-ﬂ op; i.e., the least signiﬁ cant bit state of the counter, and the 
successive ﬂ ip-ﬂ op is triggered by the output of the previous ﬂ ip-ﬂ op. Hence the counter has 
cumulative settling time, which limits its speed of operation. The ﬁ rst stage of the counter 
changes its state ﬁ rst with the application of the clock pulse to the ﬂ ip-ﬂ op and the successive 
ﬂ ip-ﬂ ops change their states in turn causing a ripple-through effect of the clock pluses. As the 
signal propagates through the counter in a ripple fashion, it is called a ripple counter.
9.2.1  Asynchronous (or Ripple) Up-counter 
Figure 9.1 shows a 3-bit counter capable of counting from 0 to 7. The clock inputs 
of the three ﬂ ip-ﬂ ops are connected in cascade. The T input of each ﬂ ip-ﬂ op is connected 
to a constant 1, which means that the state of the ﬂ ip-ﬂ op will toggle (reverse) at each 
negative edge of its clock. We are assuming that the purpose of this circuit is to count the 
number of pulses that occur on the primary input called CLK (Clock). Thus the clock input 
of the ﬁ rst ﬂ ip-ﬂ op is connected to the Clock line. The other two ﬂ ip-ﬂ ops have their clock 
inputs driven by the Q output of the preceding ﬂ ip-ﬂ op. Therefore, they toggle their state 
whenever the preceding ﬂ ip-ﬂ op changes its state from Q = 1 to Q = 0, which results in a 
negative edge of the Q signal.
Figure 9.1(b) shows a timing diagram for the counter. The value of Q0 toggles once 
each clock cycle. The change takes place shortly after the negative edge of the Clock signal. 
The delay is caused by the propagation delay through the ﬂ ip-ﬂ op. Since the second ﬂ ip-ﬂ op 
is clocked by Q0, the value of Q1 changes shortly after the negative edge of the Q0 signal. 
Similarly, the value of Q2 changes shortly after the negative edge of the Q1 signal. If we look 
at the values Q2 Q1 Q0 as the count, then the timing diagram indicates that the counting 
sequence is 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, and so on. This circuit is a modulo-8 counter. Since 
it counts in the upward direction, we call the circuit an up-counter.
(a) Logic circuit diagram.
1
+ Vcc
CLK
T
T
T
Q
Q
Q
Q
Q
Q
Q 0
Q 1
Outputs
Q 2

COUNTERS 293
(b) Timing diagram.
Figure 9.1 A 3-bit asynchronous up-counter.
The counter in Figure 9.1(a) has three stages, each comprising of a single ﬂ ip-ﬂ op. 
Only the ﬁ rst stage responds directly to the Clock signal. Hence we may say that this stage 
is synchronized to the clock. The other two stages respond after an additional delay. For 
example, when count = 3, the next clock pulse will change the count to 4. Now this change 
requires all three ﬂ ip-ﬂ ops to toggle their states. The change in Q0 is observed only after a 
propagation delay from the negative edge of the clock pulse. The Q1 and Q2 ﬂ ip-ﬂ ops have 
not changed their states yet. Hence, for a brief period, the count will be Q2Q1Q0 = 010. 
The change in Q1 appears after a second propagation delay, and at that point the count 
is Q2Q1Q0 = 000. Finally, the change in Q2 occurs after a third delay, and hence the stable 
state of the circuit is reached and the count is Q2Q1Q0 = 100.     
Table 9.1 shows the sequence of binary states that the ﬂ ip-ﬂ ops will follow as clock 
pulses are applied continuously. An n-bit binary counter repeats the counting sequence for 
every 2n (n = number of ﬂ ip-ﬂ ops) clock pulses and has discrete states from 0 to 2n–1.
Table 9.1 Count sequence of a 3-bit binary ripple up-counter
Counter State  
Q2 
Q1 
Q0
 
0 
0 
0 
0 
 
1 
0 
0 
1 
 
2 
0 
1 
0 
 
3 
0 
1 
1 
 
4 
1 
0 
0 
 
5 
1 
0 
1 
 
6 
1 
1 
0 
 
7 
1 
1 
1 
Clock
Q 1
Q 2
0
1
2
3
4
5
6
7
0
Q 0
1
2
3
4
5
6
7
8

294
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 9.2 shows the 3-bit binary ripple counter with decoded outputs. It consists of 
the same circuit as shown in Figure 9.1 with additional decoding circuitry. In decoding 
the states of a ripple counter, pulses of one clock duration will occur at the decoding gate 
outputs as the ﬂ ip-ﬂ ops change their state.
Figure 9.2 3-bit binary asynchronous counter with decoded outputs.
The decoding gates are connected to the outputs such that their outputs will be high 
only when the counter content is equal to the given state. For example, a decoding gate Q6
connected in the circuit will decode state 6 (i.e., QAQBQC = 110). Thus the gate output will be 
high only when QA = 1, QB = 1, and QC = 0. The remaining seven states of the 3-bit counter 
can be decoded in a similar manner using AND gates as Q0, Q1, Q2, Q3, Q4, Q5, and Q7.
Now, theoretically each decoding output will be high only when the counter content 
is equal to a given state, and this state occurs only once during a cycle of 2n states of the 
counter, where n is the number of ﬂ ip-ﬂ ops in the counter. But practically in an asynchronous 
counter, the decoding gate produces a high output more than once during the cycle of 2n
states. Such undesired high or low pulses of short duration, that appear at the decoding 
gate output at undesired time instants are known as spikes or glitches. The reason for these 
spikes is the cumulative propagation delay in the synchronous counter, which was already 
discussed in this chapter.
As TTL circuits are very fast, they will respond to even glitches of very small duration 
(a few nanoseconds). Therefore, these glitches should be eliminated. These can be eliminated 
by using any one of the following methods: (i) clock input to strobe the decoding gates, or
(ii) using synchronous counters.
T
T
T
Q
Q
Q
Q
C
B
A
Q  = Q' Q' Q'
0
A
B
C
Q  = Q' Q' Q
1
A
B
C
Q  = Q' Q Q'
2
A
B
C
Q  = Q' Q Q
3
A
B
C
Q  = Q Q' Q'
4
A
B
C
Q  = Q Q' Q
5
A
B
C
Q  = Q Q Q'
6
A
B
C
Q  = Q Q Q
7
A
B
C
Q
Q
+Vcc
CLK

COUNTERS 295
To understand the strobing of decoding gates with clock pulse input, we consider a 
four input AND gate to decode state 5 as shown in Figure 9.3. Here we are using the clock 
input as the strobe. 
Figure 9.3 Decoding gate Q5 with a clock as the strobe input.
When the clock input is used to strobe the decoding gate, as shown in Figure 9.3, it 
will produce the desired output only when the clock is high, resulting in perfect decoding 
of gate output (Q5 × CLK) without any glitches. Thus, by strobing the decoding gates with 
the clock inputs, glitches can be completely avoided.
Modulus or MOD-Number of the Counter
The counter shown in Figure 9.2 has 8 different states. Thus it is a MOD-8 asynchronous 
counter. The Modulus (or MOD-number) of a counter is the total number of unique states 
it passes through in each of the complete cycles.
 
 
Modulus = 2n
where
n = Number of ﬂ ip-ﬂ ops.
The maximum binary number that can be counted by the counter is 2n –1. Hence, a 
3-ﬂ ip-ﬂ op counter can count a maximum of (111)2 = 23 – 1 = 710.
Frequency Division
Let us consider the counter shown in Figure 9.1. The input consists of a sequence 
of pulses of frequency, f. As already discussed, Q0 changes only when the clock makes a 
transition from 1 to 0. Thus, at the ﬁ rst negative transition Q0 changes from 0 to 1, and 
with the second negative transition of the clock Q0 shifts from 1 to 0. Hence, two input 
pulses will result in a single pulse in Q0. Hence the frequency of Q0 will be f/2. Similarly, 
the frequency of Q1 signal will be half that of Q0 signal. Therefore its frequency is f/4.
Similarly, the frequency of Q2 will be f/8. Hence the circuit can be used to divide the input 
frequency. These circuits are called frequency dividers. If there are n ﬂ ip-ﬂ ops used in the 
circuit then the frequency will be divided by 2n.
9.2.2  Asynchronous (or Ripple) Counter With Modulus < 2n
The ripple counter shown in Figure 9.1 is a MOD N or MOD 2n counter, where n is 
the number of ﬂ ip-ﬂ ops and N is the number of count sequences. This is the maximum 
MOD-number that is attainable by using n ﬂ ip-ﬂ ops. But in practice, it is often required 
to have a counter which has a MOD-number less than 2n. In such cases, it is required that 
the counter will skip states that are normally a part of the counting sequences. A MOD-6 
ripple counter is shown in Figure 9.4.
In the circuit shown in Figure 9.4(a), without the NAND gate, the counter functions as 
a MOD-8 binary ripple counter, which can count from 000 to 111. However, when a NAND 
gate is incorporated in the circuit as shown in Figure 9.4(a) the sequence is altered in the 
following way:
QA
Q 5 × CLK
Q C
Q′B
CLK

296
DIGITAL PRINCIPLES AND LOGIC DESIGN
(a) Circuit.
(b) Waveform.
Figure 9.4 MOD-6 asynchronous counter.
 
1. The NAND gate output is connected to the clear inputs of each ﬂ ip-ﬂ op. As along as 
the NAND gate produces a high output, it will have no effect on the counter. But 
when the NAND gate output goes low, it will clear all ﬂ ip-ﬂ ops, and the counter will 
immediately go to the 000 state. 
 
2. The outputs Q2, Q1, and Q′0 are given as the inputs to the NAND gate. The NAND 
output occurs low whenever Q2Q1Q0 = 110. This condition will occur on the sixth clock 
pulse. The low at the NAND gate output will clear the counter to the 000 state. Once 
the ﬂ ip-ﬂ ops are cleared the NAND gate output goes back to 1.
 
3. Hence, again, the cycle of the required counting sequence repeats itself.
Although the counter goes to the 110 state, it remains there only for a few nanoseconds 
before it recycles to the 000 state. Hence we may say that the counter counts from 000 to 
101, it skips the states 110 and 111; thus it works as a MOD-6 counter.
From the waveform shown in Figure 9.4(b), it can be noted that the Q1 output contains 
a spike or glitch caused by the momentary occurrence of the 110 state before the clearing 
operation takes place. This glitch is essentially very narrow (owing to the propagation delay of 
the NAND gate). It can be noted that the Q2 output has a frequency equal to 1/6 of the input 
frequency. So we may say that the MOD-6 counter has divided the input frequency by 6.
1
Q 0
Q 1
Q 2
NAND output
2
3
4
6
7
5
Clock

COUNTERS 297
To construct any MOD-N counter, the following general steps are to be followed.
 
1. Find the number of ﬂ ip-ﬂ ops (n) required for the desired MOD-number using the 
equation
 
   
 
2n-1 < N < 2n.
 
2. Then connect all the n ﬂ ip-ﬂ ops as a ripple counter.
 
3. Find the binary number for N.
 
4. Connect all the ﬂ ip-ﬂ op outputs, for which Q = 1, as well as Q′ = 1, when the count 
is N, as inputs to the NAND gate.
 
5. Connect the NAND gate output to the clear input of each ﬂ ip-ﬂ op.
When the counter reaches the N-th state, the output of the NAND gate goes low,
resetting all ﬂ ip-ﬂ ops to 0. So the counter counts from 0 through N – 1, having N states.
9.2.3 Asynchronous (or Ripple) Down-counter 
A down-counter using n ﬂ ip-ﬂ ops counts downward starting from a maximum count of 
(2n – 1) to zero. The count sequence of such a 3-bit down-counter is given in Table 9.2.
Table 9.2 Count sequence of a 3-bit binary ripple down-counter
Counter State  
Q2 
Q1 
Q0
 
7 
1 
1 
1
 
6 
1 
1 
0
 
5 
1 
0 
1
 
4 
1 
0 
0
 
3 
0 
1 
1
 
2 
0 
1 
0
 
1 
0 
0 
1
 
0 
0 
0 
0
Such a down-counter may be designed in three different ways as follows:
Case 1. The circuit shown in Figure 9.1 can be kept intact; only the outputs of the 
counter may be taken from the complement outputs of the ﬂ ip-ﬂ ops, i.e., Q′, rather than 
from the normal outputs for each ﬂ ip-ﬂ op as shown in Figure 9.5(a). The waveform is shown 
in Figure 9.5(b).
(a) Circuit.
T
T
T
Q
Q
Q
Q
Q
Q
+Vcc
CLK
Q'  (LSB)
0
Q'  
1
Q'  (M SB)
2

298
DIGITAL PRINCIPLES AND LOGIC DESIGN
(b) Waveform.
Figure 9.5 A 3-bit asynchronous down-counter (taking outputs from
the complements of each ﬂ ip-ﬂ op).
Here, since the outputs are taken from the complements of the ﬂ ip-ﬂ ops, the starting 
count sequence is Q′2Q′1Q′0 = 111. With each negative edge of the clock Q0 toggles its state. 
Similarly, with each negative transition of the output Q0, the output Q1 toggles and the 
same thing happens for Q2, also. Hence the count sequences goes on decreasing from 7, 6, 
5, 4, 3, 2, 1, 0, 7, and so on with each clock pulse.
Case 2. The circuit may be slightly modiﬁ ed so that the clock inputs of the second, third, 
and subsequent ﬂ ip-ﬂ ops may be driven by the Q′ outputs of the preceding stages, rather than 
by the Q outputs as shown in Figure 9.6(a). The waveform is shown in Figure 9.6(b).
If the initial counter content is 000, at the ﬁ rst negative transition of the clock, the 
counter content changes to 111; at the second negative transition, the content becomes 110; 
at the third negative transition of clock, the content changes to 101, and so on. Thus, in 
the down-counter, the counter content is decremented by one for every negative transition 
of the clock pulse.
(a) Circuit.
Clock
Q 0
Q'0
Q 1
Q 2
Q'1
Q'2
1
1
1
0
0
0
1
0
1
1
1
1
1
0
0
0
1
0
1
0
0
0
0
1
1
1
1
T
T
T
Q
Q
Q
Q
Q
Q
+Vcc
CLK
Q  (LSB)
0
Q1
Q  (M SB)
2

COUNTERS 299
(b) Waveform.
Figure 9.6 A 3-bit asynchronous down-counter (clock inputs of each ﬂ ip-ﬂ op driven by Q′).
Case 3. The ﬂ ip-ﬂ ops used in the case of the up-counter shown in Figure 9.1, may be 
replaced by positive edge-triggering ﬂ ip-ﬂ ops as shown in Figure 9.7(a). The waveform is 
shown in Figure 9.7(b).
Here, since the ﬂ ip-ﬂ ops used for the circuit are all positive edge-triggering ﬂ ip-ﬂ ops, 
the ﬂ ip-ﬂ ops toggle their states with each positive edge transition of the clock pulse. If 
initially all the ﬂ ip-ﬂ ops are reset, with the ﬁ rst positive edge of the clock pulse Q0 toggles 
to 1. Similarly, since Q0 is driving the second ﬂ ip-ﬂ op, Q0 toggles from 0 to 1, and positive 
edge Q1 also toggles from 0 to 1. A similar thing happens with Q2. Hence, after the ﬁ rst 
clock pulse, the counter content becomes 111. Similarly, other count sequences also occur. 
The major application of down-counters lies in situations where a desired number of 
input pulses that have occurred are found. In these situations, the down-counter is preset
to the desired number and then allowed to countdown as the pulses are applied. When 
the counter reaches the zero state, it is detected by a logic gate whose output at that time 
indicates that the preset number of pulses are applied.
(a) Circuit.
Clock
Q 0
Q'0
Q 1
Q 2
Q'1
1
1
1
0
0
0
1
0
1
1
1
0
0
0
1
0
1
0
0
0
0
1
1
1
0
0
0
T
T
T
Q
Q
Q
Q
Q
Q
+Vcc
CLK
Q  (LSB)
0
Q1
Q  (M SB)
2

300
DIGITAL PRINCIPLES AND LOGIC DESIGN
(b) Waveform.
Figure 9.7 A 3-bit asynchronous down-counter (using positive edge-triggering ﬂ ip-ﬂ ops).
9.2.4  Asynchronous (or Ripple) Up-down Counter 
We have already considered up-counters and down-counters separately. But both of the 
units can be combined in a single up-down counter. Such a combined unit of up-down counter 
can count both upward as well as downward. Such a counter is also called a multimode
counter. In the up-counter each ﬂ ip-ﬂ op is triggered by the normal output of the preceding 
ﬂ ip-ﬂ op; whereas in a down-counter, each ﬂ ip-ﬂ op is triggered by the complement output 
of the preceding ﬂ ip-ﬂ op. However, in both the counters, the ﬁ rst ﬂ ip-ﬂ op is triggered by 
the input pulses. 
A 3-bit up-down counter is shown in Figure 9.8. The operation of such a counter is 
controlled by the up-down control input. The counting sequence of the up-down counter in 
the two modes of counting is given in Table 9.3. From the circuit diagram we ﬁ nd that 
three logic gates are required per stage to switch the individual stages from count-up to 
count-down mode. The logic gates are used to allow either the noninverted output or the 
inverted output of one ﬂ ip-ﬂ op to the clock input of the following ﬂ ip-ﬂ op, depending on the 
status of the control input. An inverter has been inserted in between the count-up control 
line and the count-down control line to ensure that the count-up and count-down cannot 
be simultaneously in the HIGH state.
Figure 9.8 Asynchronous 3-bit up-down counter.
Clock
Q 0
Q 1
Q 2
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
T
T
T
Q
Q
Q
Q
A
Q A
Q B
Q C
B
C
Q
Q
Count
UP/Down
Vcc

COUNTERS 301
Table 9.3 Count sequence for a 3-bit binary ripple up-down counter
COUNT-UP Mode 
COUNT-DOWN Mode
States 
QC 
QB 
QA 
States 
QC 
QB 
QA
 
0 
0 
0 
0 
7 
1 
1 
1
 
1 
0 
0 
1 
6 
1 
1 
0
 
2 
0 
1 
0 
5 
1 
0 
1
 
3 
0 
1 
1 
4 
1 
0 
0
 
4 
1 
0 
0 
3 
0 
1 
1
 
5 
1 
0 
1 
2 
0 
1 
0
 
6 
1 
1 
0 
1 
0 
0 
1
 
7 
1 
1 
1 
0 
0 
0 
0
When the count-up/down line is held HIGH, the lower AND gates will be disabled and 
their outputs will be zero. So they will not affect the outputs of the OR gates. At the same 
time the upper AND gates will be enabled. Hence, QA will pass through the OR gate and 
into the clock input of the B ﬂ ip-ﬂ op. Similarly, QB will be gated into the clock input of the 
C ﬂ ip-ﬂ op. Thus, as the input pulses are applied, the counter will count up and follow a 
natural binary counting sequence from 000 to 111. 
Similarly, with count-up/down line being logic 0, the upper AND gates will become 
disabled and the lower AND gates are enabled, allowing Q′A and Q′B to pass through the 
clock inputs of the following ﬂ ip-ﬂ ops. Hence, in this condition the counter will count in 
down mode, as the input pulses are applied. 
9.2.5  Propagation Delay in an Asynchronous Counter
Asynchronous counters are simple in circuitry. But the main disadvantage of these type 
of counters is that they are slow. In asynchronous counters each ﬂ ip-ﬂ op is triggered by 
the transition of the output of the preceding ﬂ ip-ﬂ op. Because of the inherent propagation 
delay time (tpd), the ﬁ rst ﬂ ip-ﬂ op only responds after a period of tpd after receiving a clock 
pulse. Similarly, the second ﬂ ip-ﬂ op only responds after a period of 2tpd after the input pulse 
occurs. Hence, the nth ﬂ ip-ﬂ op cannot change states for a period of n × tpd even after the 
input clock pulse occurs. Therefore, to allow all the ﬂ ip-ﬂ ops in an n-bit counter to change 
states in response to a clock, the period of the clock T should be:
 
 
 
T > n × tpd .
Thus, the maximum frequency (f) that can be used in an asynchronous counter for 
reliable operation is given by:
 
 
 
 > n × tpd
 
 
or,   
 > f
Thus, f should be less than or equal to        . Hence, the maximum clock frequency 
that can be applied in an n-bit asynchronous counter is 
1
f
1
pd
n × t
1
pd
n × t

302
DIGITAL PRINCIPLES AND LOGIC DESIGN
fmax =  
.
Example 9.1. In a 5-stage ripple counter, the propagation delay of each ﬂ ip-ﬂ op is 50 
ns. Find the maximum frequency at which the counter operates reliably.
Solution. The maximum frequency is
fmax =  
 
 
= 4 MHz.
9.3  ASYNCHRONOUS COUNTER ICs
The design of the asynchronous counter using ﬂ ip-ﬂ ops has been discussed above. Some 
asynchronous counters are available in MSI and are given in Table 9.4 along with some 
of their features. Depending on these features these ICs are divided into three groups A, 
B, and C. The group to which a particular IC belongs is indicated in the table. All these 
ICs consist of four master-slave ﬂ ip-ﬂ ops. The set, reset (clear), and load operations are 
asynchronous, i.e., independent of the clock pulse.
9.3.1  Group A Asynchronous Counter ICs
Figure 9.9 shows the basic internal structure of IC 7490. IC 7490 is basically a BCD 
counter or decade counter (MOD 10), which consists of four master-slave ﬂ ip-ﬂ ops internally 
connected to provide a MOD-2 counter and a MOD-5 counter. The reset inputs R1 and R2 are 
connected to logic 1, to reset the counter to 0000, and the set inputs S1 and S2 are connected 
to logic 1 to set the counter to 1001. Since the output QA from ﬂ ip-ﬂ op A is not internally 
connected to the succeeding stages, the counter can be operated in two count modes. 
Table 9.4 Asynchronous counter ICs
IC No. 
Description 
Features 
Group
 
7490, 74290 
BCD counter 
Set, reset 
A 
 
74490 
Dual BCD counter 
Set, reset 
A 
 
7492 
Divide-by-12 counter 
Reset 
B 
 
7493, 74293 
4-bit binary counter 
Reset 
B 
 
74390 
Dual decade counters 
Reset 
B 
 
74393 
Dual 4-bit binary counters 
Reset 
B 
 
74176, 74196 
Presettable BCD counter 
Reset, load 
C 
 
74177, 74197 
Presettable 4-bit binary counter 
Reset, load 
C 
 
1. When used as a BCD counter, the B input must be externally connected to the QA
output. The incoming pulses are received by the input A, and a count sequence is 
obtained as the BCD output sequence as shown in Table 9.5. Two gated inputs are 
provided to reset the counter to 0. In addition, two more inputs are also provided to 
set a BCD count of 9 for 9’s complement decimal applications. 
1
pd
n × t
1
5 × 50ns

COUNTERS 303
 
2. When it is required to function as a MOD-2 counter and a MOD-5 counter, no external 
connections are necessary. Flip-ﬂ op A is used as a binary element for the MOD-2 
function. The B input is used to obtain binary MOD-5 operation at the QB, QC, and 
QD outputs. In this mode, the two counters operate independently. But all four ﬂ ip-
ﬂ ops are reset simultaneously.
Figure 9.9 Internal structure of an IC 7490 ripple counter.
IC 74490 is a dual BCD counter consisting of two independent BCD counters. Each 
section consists of four ﬂ ip-ﬂ ops, all connected internally to form a decade counter. For each 
section there is a set (S) and a reset (R) input which are active high. 
Table 9.5 Count sequence for IC 7490
Mode-1 (MOD-10) 
Mode-2 (MOD-5)
 
QD 
QC 
QB 
QA 
QD 
QC 
QB
 
0 
0 
0 
0 
0 
0 
0
 
0 
0 
0 
1 
0 
0 
1
 
0 
0 
1 
0 
0 
1 
0
 
0 
0 
1 
1 
0 
1 
1
 
0 
1 
0 
0 
1 
0 
0
 
0 
1 
0 
1
 
0 
1 
1 
0
 
0 
1 
1 
1
 
1 
0 
0 
0
 
1 
0 
0 
1
Example 9.2. In a 7490 IC, if QD output is connected to A input and the pulses are 
applied at B input, ﬁ nd the count sequence of the Q outputs.

304
DIGITAL PRINCIPLES AND LOGIC DESIGN
Solution. If QD output is connected to A input and the pulses are applied at B input, 
we have the MOD-5 counter followed by the MOD-2 counter. The count sequence obtained 
is given in Table 9.6. Here the states of the MOD-5 counter change in a normal binary 
sequence and QA changes whenever QD goes from 1 to 0.
Table 9.6
Counter State 
Flip-ﬂ op outputs 
 
 
QD 
QC 
QB 
QA
 
0 
0 
0 
0 
0 
 
1 
0 
0 
1 
0 
 
2 
0 
1 
0 
0 
 
3 
0 
1 
1 
0 
 
4 
1 
0 
0 
0 
 
5 
0 
0 
0 
1 
 
6 
0 
0 
1 
1 
 
7 
0 
1 
0 
1 
 
8 
0 
1 
1 
1 
 
9 
1 
0 
0 
1 
 
10 
0 
0 
0 
0
The count sequence of this counter is different from that of a normal decade counter, 
although both are MOD-10 counters. 
Example 9.3. In a 7490 IC, if QA output is connected to B input and the pulses are 
applied at A input, ﬁ nd the count sequence of the Q outputs.
Table 9.7
Counter State 
Flip-ﬂ op outputs 
 
 
QD 
QC 
QB 
QA
 
0 
0 
0 
0 
0
 
1 
0 
0 
0 
1
 
2 
0 
0 
1 
0
 
3 
0 
0 
1 
1
 
4 
0 
1 
0 
0
 
5 
0 
1 
0 
1
 
6 
0 
1 
1 
0
 
7 
0 
1 
1 
1
 
8 
1 
0 
0 
0
 
9 
1 
0 
0 
1
 
10 
0 
0 
0 
0

COUNTERS 305
Solution. If QA output is connected to B input and the pulses are applied at A input, 
we have the MOD-2 counter followed by the MOD-5 counter. The count sequence obtained 
is given in Table 9.7. Here, when QA changes from 0 to 1, the state of MOD-5 counter does 
not change, whereas when QA changes from 1 to 0, the state of MOD-5 counter goes to the 
next state.
Example 9.4. Design a MOD-5 counter using 7490 IC.
Solution. First the counter is connected as a MOD-10 counter for normal binary 
sequence (as shown in Example 9.3). Then outputs QA and QC are connected to the reset 
inputs. Hence, as soon as QA and QC both become 1, the counter is reset to 0000. Figure 
9.10 shows the MOD-5 ripple counter.
Figure 9.10 A MOD-5 ripple counter using IC 7490.
9.3.2  Group B Asynchronous Counter ICs
The basic structure of IC 7493 is shown in Figure 9.11. Basically the asynchronous 
counter ICs like 7492 and 74293 follows the same internal structure as IC 7493. The 
operation of these ICs is identical to the operation of IC 74990 except that the set inputs 
are not present. 
IC 7493 is a 4-bit binary ripple counter that consists of four master-slave J-K ﬂ ip-ﬂ ops. 
These four ﬂ ip-ﬂ ops are internally connected to provide a MOD-2 and MOD-8 counter, the 
reset inputs R1 and R2 are used to reset the counter to 0000. Since the output QA from ﬂ ip-
ﬂ op A is not internally connected to the succeeding ﬂ ip-ﬂ ops, the counter may be operated 
in two independent modes as discussed below.
 
1. If the counter is to be used as a 4-bit ripple counter, output QA must be externally 
connected to input B. The input pulses are applied to input A. Simultaneous divisions 
of 2, 4, 8, and 16 are performed at the QA, QB, QC, and QD outputs respectively. The 
count sequence for this connection is given in Table 9.8. 
 
2. If the counter is to be used as a 3-bit ripple counter, the input pulses are applied to 
the input B. Simultaneous frequency divisions of 2, 4, and 8 are performed at the QB,
QC, and QD outputs. Independent use of ﬂ ip-ﬂ op A is available if the reset function 
coincides with the reset of the 3-bit ripple counter.
Basically, these ICs are not used as counters but are used for frequency division. IC 
7492 is a divide-by-12 counter, which consists of four master-slave J-K ﬂ ip-ﬂ ops. These four 
ﬂ ip-ﬂ ops are internally connected to provide a MOD-2 and MOD-6 counter. IC 74390 is a 

306
DIGITAL PRINCIPLES AND LOGIC DESIGN
dual BCD counter consisting of two independent BCD counters similar to IC 7490. There is 
one reset (R) input for each section. IC 74393 is a dual 4-bit binary counter with one reset
(R) input for each section that is active-high.
Figure 9.11 Internal structure of IC 7493—4-bit ripple counter.
Table 9.8 Count sequence for IC 7493—4-bit binary ripple counter
Mode-1 (MOD-16) 
Mode-2 (MOD-8)
 
QD 
QC 
QB 
QA 
QD 
QC 
QB
 
0 
0 
0 
0 
0 
0 
0
 
0 
0 
0 
1 
0 
0 
1
 
0 
0 
1 
0 
0 
1 
0
 
0 
0 
1 
1 
0 
1 
1
 
0 
1 
0 
0 
1 
0 
0
 
0 
1 
0 
1 
1 
0 
1
 
0 
1 
1 
0 
1 
1 
0
 
0 
1 
1 
1 
1 
1 
1
 
1 
0 
0 
0
 
1 
0 
0 
1
 
1 
0 
1 
0
 
1 
0 
1 
1
 
1 
1 
0 
0
 
1 
1 
0 
1
 
1 
1 
1 
0
 
1 
1 
1 
1
 
0 
0 
0 
0

COUNTERS 307
Example 9.5. If the output QA of a MOD-12 ripple counter 7492 IC is connected to the 
B input and the pulses are applied at the A input, ﬁ nd the count sequence.
Solution. The count sequence is shown in Table 9.9. Here, it may be noted that simultaneous 
divisions of 2, 6, and 12 are performed at the QA, QC, and QD outputs respectively.
Table 9.9
Counter State 
Flip-ﬂ op outputs 
 
 
QD 
QC 
QB 
QA
 
0 
0 
0 
0 
0 
 
1 
0 
0 
0 
1 
 
2 
0 
0 
1 
0 
 
3 
0 
0 
1 
1 
 
4 
0 
1 
0 
0 
 
5 
0 
1 
0 
1 
 
6 
1 
0 
0 
0 
 
7 
1 
0 
0 
1 
 
8 
1 
0 
1 
0 
 
9 
1 
0 
1 
1 
 
10 
1 
1 
0 
0 
 
11 
1 
1 
0 
1
9.3.3  Group C Asynchronous Counter ICs
The basic internal structure of group C counter ICs is shown in Figure 9.12. IC 74196 
and IC 74176 are both BCD counters with a difference in only maximum clock frequency 
speciﬁ cation. Similarly, IC 74197 and IC 74177 are both 4-bit binary counters with the same 
difference.
Figure 9.12 Basic internal structure of group C asynchronous counter ICs.
These counters are actually presettable versions of 7490 and 7493 counters respectively. 
The counter is cleared by connecting logic 0 to the clear input, which is active-low. The 

308
DIGITAL PRINCIPLES AND LOGIC DESIGN
counter can be stopped any time and any binary number present at the preset inputs 
may be loaded into the counter by setting the load input to logic 0, while the clear input 
is at logic 1. For normal UP counting operation, both the load and clear inputs should be 
connected to logic 1.
The presettable 4-bit binary counters can be used as variable MOD-n counters in which 
the counter modulus is equal to 15–P, where P is the binary number connected at the preset 
input. In other words, for designing a MOD-n counter, the value of P is 15–n. When the counter 
output reaches the count 1111, the counter must be loaded again with P.  This is made possible 
by using a four-input NAND gate between the Q outputs of the counter and the load input. 
Example 9.6. Design a divide-by-10 counter using IC 74177.
Solution. The circuit of a divide-by-10 counter is shown in Figure 9.13. The value of 
P (= 15–n) is P = 1111–1010 = 0101. The counter is now loaded with 0101 as soon as the 
output reaches 1111.
Figure 9.13 A divide-by-10 counter using IC 74177.
9.3.4  Cascading of Ripple Counter ICs
By cascading the ICs that were discussed above, we can construct ripple counters of 
any cycle length. The desired cycle length is decoded and used to reset all the counters to 
0. The strobe should be used to eliminate false data.
The cascading arrangement for all the synchronous counter ICs is same where QD of 
the preceding stage goes to the clock input terminal of the succeeding stage. The load and 
clear inputs of all ICs are to be connected together.
Example 9.7. Design a 2-decade BCD counter using IC 74390.
Solution. The 74390 is a dual Decade counter and belongs to the Group B group of 
ICs. Hence only one IC is required to design a 2-decade BCD counter. The 2-decade counter 
is shown in Figure 9.14.
Input B
      74177               Load 
Clear     
P     P    P    P
A
B
C
D
Q A
Q B
Q C
Q D
Outputs
+VC C
+VC C
Input A

COUNTERS 309
Figure 9.14 A 2-decade BCD counter using IC 74390.
9.4  SYNCHRONOUS (PARALLEL) COUNTERS
The ripple or asynchronous counter is the simplest to build, but its highest operating 
frequency is limited because of ripple action. Each ﬂ ip-ﬂ op has a delay time. In ripple 
counters these delay times are additive and the total “settling” time for the counter is 
approximately the product of the delay time of a single ﬂ ip-ﬂ op and the total number of 
ﬂ ip-ﬂ ops. Again, there is the possibility of glitches occurring at the output of decoding gates 
used with a ripple counter. 
Both of these problems can be overcome, if all the ﬂ ip-ﬂ ops are clocked synchronously. 
The resulting circuit is known as a synchronous counter. Synchronous counters can be designed 
for any count sequence (need not be straight binary). These can be designed following a 
systematic approach. Before we discuss the formal method of design for such counters, we 
shall consider an intuitive method.
Figure 9.15 A 4-bit (MOD-16) synchronous counter.
A 4-bit synchronous counter with parallel carry is shown in Figure 9.15. In this circuit 
the clock inputs of all the ﬂ ip-ﬂ ops are tied together so that the input clock signal may be 
applied simultaneously to each ﬂ ip-ﬂ op. Only the LSB ﬂ ip-ﬂ op A has its T input connected 
permanently to logic 1 (i.e., VCC), while the T inputs of the other ﬂ ip-ﬂ ops are driven by 
some combination of ﬂ ip-ﬂ op outputs. The T input of ﬂ ip-ﬂ op B is connected to the output 
QA of ﬂ ip-ﬂ op A; the T input of ﬂ ip-ﬂ op C is connected with the AND-operated output of 
QA and QB. Similarly, the T input of D ﬂ ip-ﬂ op is connected with the AND-operated output 
of QA, QB, and QC.
Q D 1
Q D 0
Q C 1
Q C 0
Q B 1
Q B 0
Q A 1
Q A 0
M SD
LSD
 Q D
 QD
 Q C
 QC
 Q B
B
Input A
 Q B
 Q A
 Q A
74390
       Section 1
       Section 2
Input B
Input A
    R
    R

310
DIGITAL PRINCIPLES AND LOGIC DESIGN
From the circuit, we can see that ﬂ ip-ﬂ op A changes its state with the negative transition 
of each clock pulse. Flip-ﬂ op B changes its state only when the value of QA is 1 and a negative 
transition of the clock pulse takes place. Similarly, ﬂ ip-ﬂ op C changes its state only when 
both QA and QB are 1 and a negative edge transition of the clock pulse takes place. In the 
same manner, the ﬂ ip-ﬂ op D changes its state when QA = QB = QC = 1 and when there is a 
negative transition at clock input. The count sequence of the counter is given in Table 9.10.
Table 9.10 Count sequence of a 4-bit binary synchronous counter
State  
QD 
QC 
QB 
QA
 
0 
0 
0 
0 
0
 
1 
0 
0 
0 
1
 
2 
0 
0 
1 
0
 
3 
0 
0 
1 
1
 
4 
0 
1 
0 
0
 
5 
0 
1 
0 
1
 
6 
0 
1 
1 
0
 
7 
0 
1 
1 
1
 
8 
1 
0 
0 
0
 
9 
1 
0 
0 
1
 
10 
1 
0 
1 
0
 
11 
1 
0 
1 
1
 
12 
1 
1 
0 
0
 
13 
1 
1 
0 
1
 
14 
1 
1 
1 
0
 
15 
1 
1 
1 
1
 
0 
0 
0 
0 
0
9.4.1  Propagation Delay in a Synchronous Counter
Unlike asynchronous counters where the total propagation delay is given by the 
cumulative effect of the ﬂ ip-ﬂ ops, the total settling or response time of a synchronous 
counter is given as follows: the time taken by one ﬂ ip-ﬂ op to toggle plus the time for the 
new logic levels to propagate through a single AND gate to reach the T inputs of the 
following ﬂ ip-ﬂ op.
Total delay = Propagation delay of one ﬂ ip-ﬂ op + Propagation delay of an AND gate.
Irrespective of the total number of ﬂ ip-ﬂ ops, the propagation delay will always be 
the same. Normally, this will be much lower than the propagation delay in asynchronous 
counters with the same number of ﬂ ip-ﬂ ops. Thus, the speed of operation of synchronous 
counters is limited by the propagation delays of an AND gate and a single ﬂ ip-ﬂ op. Hence, 
the maximum frequency of operation of a synchronous counter is given by 
fmax =  1
tp + tg

COUNTERS 311
where tp is the propagation delay of one ﬂ ip-ﬂ op and tg is the propagation delay of one 
AND gate.
Because of common clocking of all the ﬂ ip-ﬂ ops, glitches can be avoided completely in 
synchronous counters. 
9.4.2  Synchronous Counter with Ripple Carry
The 4-bit synchronous counter discussed in the previous section is said to be a synchronous 
counter with parallel carry. Moreover, in this type of counter, as the number of stages increases, 
the number of AND gates also increases, along with the number of inputs for each of those 
AND gates. This is a certain disadvantage for such type of circuits. Now this problem can be 
eliminated if we use the synchronous counter with ripple carry shown in Figure 9.16.
Figure 9.16 A 4-bit synchronous counter with ripple carry.
But in such circuits the maximum clock frequency of the counter is reduced. This 
reduction of the maximum clock frequency is due to the delay through control logic which is 
now 2tg instead of tg which was achieved with parallel carry. The maximum clock frequency 
for an n-bit synchronous counter with ripple carry is given by
where n = number of ﬂ ip-ﬂ op stages.
9.5  SYNCHRONOUS DOWN-COUNTER 
A parallel down-counter can be made to count down by using the inverted outputs
of ﬂ ip-ﬂ ops to feed the various logic gates. Even the same circuit may be retained and the
Figure 9.17 A 4-bit synchronous down-counter.
max
1
f
= tp + (n - 2)tg

312
DIGITAL PRINCIPLES AND LOGIC DESIGN
outputs may be taken from the complement outputs of each ﬂ ip-ﬂ op. The parallel counter shown 
in Figure 9.17 can be converted to a down-counter by connecting the Q′A, Q′B, and Q′C outputs 
to the AND gates in place of QA, QB, and QC respectively as shown in Figure 9.17. In this case 
the count sequences through which the counter proceeds will be as shown in Table 9.11.
Table 9.11 Count sequence of a 4-bit synchronous down-counter
State  
QD 
QC 
QB 
QA
 
15 
1 
1 
1 
1
 
14 
1 
1 
1 
0
 
13 
1 
1 
0 
1
 
12 
1 
1 
0 
0
 
11 
1 
0 
1 
1
 
10 
1 
0 
1 
0
 
9 
1 
0 
0 
1
 
8 
1 
0 
0 
0
 
7 
0 
1 
1 
1
 
6 
0 
1 
1 
0
 
5 
0 
1 
0 
1
 
4 
0 
1 
0 
0
 
3 
0 
0 
1 
1
 
2 
0 
0 
1 
0
 
1 
0 
0 
0 
1
 
0 
0 
0 
0 
0
 
15 
1 
1 
1 
1
9.6  SYNCHRONOUS UP-DOWN COUNTER
Combining both the functions of up- and down-counting in a single counter, we can make 
a synchronous up-down counter as shown in Figure 9.18. Here the control input (count-
up/down) is used to allow either the normal output or the inverted output of one ﬂ ip-ﬂ op 
to the T input of the following ﬂ ip-ﬂ op. Two separate control lines (count-Up and count- 
Figure 9.18 A MOD-8 synchronous up-down-counter.

COUNTERS 313
down) could have been used but in such case we have to be careful that both of the lines 
cannot be simultaneously in the high state. When the count-up/down line is high, then the 
upper AND gates will be active and the lower AND gates will remain inactive and hence 
the normal output of each ﬂ ip-ﬂ op is carried forward to the following ﬂ ip-ﬂ op. In such case, 
the counter will count from 000 to 111. On the other hand, if the control line is low, then 
the upper AND gates remain inactive, while the lower AND gates will become active. So 
the inverted output comes into operation and the counter counts from 111 to 000. 
9.7  DESIGN PROCEDURE OF A SYNCHRONOUS COUNTER
Following certain general steps, synchronous counters of any given count sequence and 
modulus can be designed. The steps are listed below:
Step 1. From the given word description of the problem, draw a state diagram that 
describes the operation of the counter.
Step 2. From the state table, write the count sequences in the form of a table as 
shown in Table 9.10.
Step 3. Find the number of ﬂ ip-ﬂ ops required.
Step 4. Decide the type of ﬂ ip-ﬂ op to be used for the design of the counter. Then 
determine the ﬂ ip-ﬂ op inputs that must be present for the desired next state from the 
present state using the excitation table of the ﬂ ip-ﬂ ops.
Step 5. Prepare K-maps for each ﬂ ip-ﬂ op input in terms of ﬂ ip-ﬂ op outputs as the 
input variables. Simplify the K-maps and obtain the minimized expressions.
Step 6. Connect the circuit using ﬂ ip-ﬂ ops and other gates corresponding to the 
minimized expressions. 
9.7.1  Synchronous Counter with Modulus < 2n
We have already discussed asynchronous (ripple) counters and different types of 
synchronous (parallel) counters, all of which have the ability to operate in either a count-
up or count-down mode. But all of these counters progress one count at a time in a strict 
binary progression, and they all have a modulus given by 2n, where n indicates the number 
of ﬂ ip-ﬂ ops. Such counters are said to have a “natural count” of 2n.
A MOD-2 counter consists of a single ﬂ ip-ﬂ op; a MOD-4 counter requires two ﬂ ip-ﬂ ops, 
and it counts four discrete states. Three ﬂ ip-ﬂ ops form a MOD-8 counter, while four ﬂ ip-ﬂ ops 
form a MOD-16 counter and so on. Thus we can construct counters that have a natural 
count of 2, 4, 8, 16, and so on. But it is often desirable to use counters having a modulus 
other than 2, 4, 8, 16, and so on. For example, a counter having a modulus of 3, 5, or 10 
may be useful. A smaller modulus counter can always be constructed from a larger modulus 
counter by skipping state. Such counters are said to have a modiﬁ ed count.
9.7.2  Design of a MOD-3 Counter
A MOD-3 counter is a counter which has only three distinct states. To design a counter 
with three states, the number of ﬂ ip-ﬂ ops required can be found using the equation  , where 
n is the number of ﬂ ip-ﬂ ops required and N is the number of states present in the counter. 
For N = 3, from the above equation, n = 2, i.e., two ﬂ ip-ﬂ ops are required. Now we draw 
the state diagram as shown in Figure 9.19. Here it is assumed that the state transition 

314
DIGITAL PRINCIPLES AND LOGIC DESIGN
from one state to another takes place only when a clock transition takes place. From the 
state diagram, we can form the state table for the counter as shown in Table 9.12. From 
the state table, along with the excitation table of the ﬂ ip-ﬂ ops, we can form the excitation 
table for the MOD-3 counter as shown in Table 9.13. Although any one of the four ﬂ ip-
ﬂ ops, i.e., S-R, J-K, T, and D can be used, we select here T ﬂ ip-ﬂ ops, which results in a 
simpliﬁ ed circuit.
Figure 9.19 State diagram of a MOD-3 counter.
Table 9.12 State table for the counter
Present state 
Next state
 
00 
01
 
01 
10
 
10 
00
Table 9.13 Excitation table for the MOD-3 counter
Count Sequence 
Flip-ﬂ op inputs
 
A1 
A0 
TA1 
TA0
 
0 
0 
0 
1
 
0 
1 
1 
1
 
1 
0 
1 
0
Table 9.13 is the excitation table for the MOD-3 counter. The two ﬂ ip-ﬂ ops are given 
variable designations A1 and A0. The ﬂ ip-ﬂ op excitation for the T inputs is derived from the 
excitation table of the T ﬂ ip-ﬂ op and from inspection of the state transition from a given 
count (present state) to the next below it (next state). As an illustration, consider the count 
sequence for the row 00. The next state is 01. Comparing these two counts, we note that A1
goes from 0 to 0; so TA1 is marked with a 0 because ﬂ ip-ﬂ op A1 remains unchanged when 
a clock transition takes place. A0 goes from 0 to 1; so TA0 is marked with a 1 because ﬂ ip-
ﬂ op A0 must be complemented in the next clock transition. The last row with the present 
state 10 is compared with the ﬁ rst count 00, which is its next state.
The ﬂ ip-ﬂ op input functions from the excitation tables are simpliﬁ ed in the K-maps of 
Figure 9.20. The Boolean functions listed under each map specify the combinational-circuit 
part of the counter. Including these functions with the two ﬂ ip-ﬂ ops, we obtain the logic 
diagram of the counter as shown in Figure 9.21.
00
10
01

COUNTERS 315
 
(a) For TA1 
(b) For TA0
 
TA1 = A1 + A0 
TA0 = A′1
Figure 9.20 K-maps for a MOD-3 counter.
Figure 9.21 Logic diagram of a MOD-3 binary counter.
9.7.3  Design of a MOD-5 Counter
In order to design a MOD-5, which has ﬁ ve distinct states, the number of ﬂ ip-ﬂ ops 
required can be found using the equation , where n is the number of ﬂ ip-ﬂ ops required and 
N is the number of states present in the counter. For N = 5, from the above equation, 
n = 3, i.e., three ﬂ ip-ﬂ ops are required. Now we draw the state diagram as shown in Figure 
9.22. From the state diagram, we can form the state table for the counter as shown in 
Table 9.14. From the state table, along with the excitation table of the ﬂ ip-ﬂ ops, we can 
form the excitation table for the MOD-5 counter as shown in Table 9.15. Since we have 
already developed several counter circuits using T ﬂ ip-ﬂ ops, we select here J-K ﬂ ip-ﬂ ops, 
which also results in a simple circuit.
Figure 9.22 State diagram of a MOD-5 counter.
A1
1
1
X
0
0
0
1
1
A0
000
100
011
001
010

316
DIGITAL PRINCIPLES AND LOGIC DESIGN
Table 9.14 State table for the counter
Present state 
Next state
 
000 
001
 
001 
010
 
010 
011
 
011 
100
 
100 
000
Table 9.15 Excitation table for the MOD-5 counter
Count Sequence 
Flip-ﬂ op inputs 
 
A2 
A1 
A0 
JA2 
KA2 
JA1 
KA1 
JA0 
KA0
 
0 
0 
0 
0 
X 
0 
X 
1 
X
 
0 
0 
1 
0 
X 
1 
X 
X 
1
 
0 
1 
0 
0 
X 
X 
0 
1 
X
 
0 
1 
1 
1 
X 
X 
1 
X 
1
 
1 
0 
0 
X 
1 
0 
X 
0 
X
Table 9.15 is the excitation table for the MOD-5 counter. The three ﬂ ip-ﬂ ops are 
given variable designations A2, A1, and A0. The ﬂ ip-ﬂ op excitations for the J and K inputs 
are derived from the excitation table of the J-K ﬂ ip-ﬂ op and from inspection of the state 
transition from a given count (present state) to the next below it (next state). 
The ﬂ ip-ﬂ op input functions from the excitation tables are simpliﬁ ed in the K-maps of 
Figure 9.23. The Boolean functions listed under each map specify the combinational-circuit 
part of the counter. Including these functions with the two ﬂ ip-ﬂ ops, we obtain the logic 
diagram of the counter as shown in Figure 9.24.
(a)
For JA2
(b)
For KA2
JA2 = A1A .
0
KA2 = 1.
(c)
For JA1
(d)
For KA1
JA1 = A .
0
KA1 = A .
0

COUNTERS 317
Figure 9.23 K-maps for a MOD-5 counter.
Figure 9.24 Logic diagram of a MOD-5 binary counter.
9.7.4  Design of a MOD-10 (or BCD or Decade) Counter
In order to design a MOD-10 or decade counter, which has ten distinct states, four ﬂ ip-
ﬂ ops are required. Now we draw the state diagram as shown in Figure 9.25. From the state 
diagram, we can form the state table for the counter as shown in Table 9.16. From the state 
table and using the excitation table of the ﬂ ip-ﬂ ops, we can form the excitation table for the 
MOD-10 counter as shown in Table 9.17. We select T ﬂ ip-ﬂ ops to design the circuit.
Figure 9.25 State diagram of a MOD-10 counter.
(e)
For JA0
(f)
For KA0
JA0 = A  .
′2
KA0 = 1.
0000
1001
1000
0111
0110
0011
0010
0001
0100
0101

318
DIGITAL PRINCIPLES AND LOGIC DESIGN
Table 9.16 State table for the counter
Present state 
Next state
 
0000 
0001
 
0001 
0010
 
0010 
0011
 
0011 
0100
 
0100 
0101
 
0101 
0110
 
0110 
0111
 
0111 
1000
 
1000 
1001
 
1001 
0000
Table 9.17 Excitation table for the MOD-10 counter
Count Sequence 
Flip-ﬂ op inputs
 
A3 
A2 
A1 
A0 
TA3 
TA2 
TA1 
TA0
 
0 
0 
0 
0 
0 
0 
0 
1
 
0 
0 
0 
1 
0 
0 
1 
1
 
0 
0 
1 
0 
0 
0 
0 
1
 
0 
0 
1 
1 
0 
1 
1 
1
 
0 
1 
0 
0 
0 
0 
0 
1
 
0 
1 
0 
1 
0 
0 
1 
1
 
0 
1 
1 
0 
0 
0 
0 
1
 
0 
1 
1 
1 
1 
1 
1 
1
 
1 
0 
0 
0 
0 
0 
0 
1
 
1 
0 
0 
1 
1 
0 
0 
1
Table 9.17 is the excitation table for the MOD-10 counter. The four ﬂ ip-ﬂ ops are given 
variable designations A3, A2, A1, and A0. The ﬂ ip-ﬂ op excitations for the T inputs are derived 
from the excitation table of the T ﬂ ip-ﬂ op and from inspection of the state transition from 
a given count (present state) to the next below it (next state). 
The ﬂ ip-ﬂ op input functions from the excitation tables are simpliﬁ ed in the K-maps of 
Figure 9.26. The Boolean functions listed under each map specify the combinational-circuit 
part of the counter. Including these functions with the two ﬂ ip-ﬂ ops, we obtain the logic 
diagram of the counter as shown in Figure 9.27.

COUNTERS 319
Figure 9.26 K-maps for a MOD-10 counter.
Figure 9.27 Logic diagram of a MOD-10 binary counter.
(a) 
For TA3
(b)
For TA2
TA3 = A3A0 + A2A1A .
0
TA2 = A1A .
0
(c) 
For TA 1
(d) 
For TA0
TA2 = A′3A .
0
TA0 = 1.

320
DIGITAL PRINCIPLES AND LOGIC DESIGN
9.7.5  Lock Out
In the counters with modulus less than 2n, it may happen that the counter by chance 
ﬁ nds itself in any one of the unused states. For example, in the MOD-10 counter, logic states, 
A3A2A1A0 = 1010, 1011, 1100, 1101, 1110, and 1111 are not used. Now, if by chance the counter 
enters into any one of these unused states, its next state will not be known. It may be possible 
that the counter might go from one unused state to another and never arrive at a used state. 
In such a situation the counter becomes useless for its intended purpose. A counter whose 
unused states have this feature is said to suffer from lock out. To make sure that at the 
starting point the counter is in its initial state or it comes to its initial state within a few 
clock cycles (count error due to noise), external logic circuitry is provided.
To ensure that lock out does not occur, we design the counter assuming the next state 
to be the initial state, from each of the unused states. Beyond this, the design procedure 
is the same as discussed earlier.
9.7.6  Design of an Irregular MOD-5 Counter
The counter circuit that follows irregular count sequences is called an irregular counter. 
It does not follow the natural binary sequence. The count sequences are prespeciﬁ ed, and 
the counter progresses according to that. To illustrate this, we can consider an irregular 
sequence and try to design the circuit for such a counter.
The count sequences are taken as: 000¬010¬100¬101¬110. Now the state diagram is shown 
in Figure 9.28, and the excitation table is shown in Table 9.18. We can design the counter with 
any ﬂ ip-ﬂ op. Here we consider the T ﬂ ip-ﬂ op, which will lead to the simplest design.
Fig 9.28 State diagram of the irregular MOD-5 counter.
Table 9.18 Excitation Table for the Counter
Count Sequence 
Flip-ﬂ op inputs
 
A2 
A1 
A0 
TA2 
TA1 
TA0
 
0 
0 
0 
0 
1 
0
 
0 
1 
0 
1 
1 
0
 
1 
0 
0 
0 
0 
1
 
1 
0 
1 
0 
1 
1
 
1 
1 
0 
1 
1 
0
000
110
101
010
100

COUNTERS 321
Table 9.18 is the excitation table for the irregular counter. The three ﬂ ip-ﬂ ops are given 
variable designations A2, A1, and A0. The ﬂ ip-ﬂ op excitations for the T inputs are derived 
from the excitation table of the T ﬂ ip-ﬂ op and from inspection of the state transition from 
a given count (present state) to the next below it (next state).
The ﬂ ip-ﬂ op input functions from the excitation tables are simpliﬁ ed in the K-maps of 
Figure 9.29. The Boolean functions listed under each map specify the combinational-circuit 
part of the counter. Including these functions with the two ﬂ ip-ﬂ ops, we obtain the logic 
diagram of the counter as shown in Figure 9.30.
Figure 9.29 K-maps for the irregular MOD-5 counter.
Figure 9.30 Logic diagram of the irregular MOD-5 binary counter.
9.7.7  Design of a MOD-8 Synchronous Counter Using S-R, J-K, and D Flip-ﬂ ops
Normally, synchronous counters are designed using J-K or T ﬂ ip-ﬂ ops, since they lead 
to a simple design. However, synchronous counters can also be designed using S-R or D 
ﬂ ip-ﬂ ops. We have already designed a MOD-8 counter using T ﬂ ip-ﬂ ops. Now we want to 
show the design of the same counter using S-R, J-K, and D ﬂ ip-ﬂ ops.
0
1
X
X
X
X
1
1
1
1
X
X
0
1
0
0
00
00
0
0
1
1
01
01
11
11
10
10
A A
1
0
A A
1
0
A2
A 2
(a) For TA2
(b) For TA1
TA2 = A .1
TA1 = A′2 + A1 + A .
0
0
X
X
0
0
X
1
1
00
0
1
01
11
10
A A
1
0
A2
(c)
For TA0
TA0 = A0 + A2A  .
′1

322
DIGITAL PRINCIPLES AND LOGIC DESIGN
To design a MOD-8 counter the number of ﬂ ip-ﬂ ops required is four. We now draw the 
state diagram of the counter. The state diagram is shown in Figure 9.31. Since we are using 
all three ﬂ ip-ﬂ ops for the counter design, the excitation table has entries for ﬂ ip-ﬂ op inputs 
S2R2, S1R1, S0R0 (for design using S-R ﬂ ip-ﬂ ops); J2K2, J1K1, J0K0 (for design using J-K ﬂ ip-
ﬂ ops) and D2, D1, D0 (for design using D ﬂ ip-ﬂ ops). The table is shown in Table 9.19.
Figure 9.31 State diagram of a MOD-8 counter.
Table 9.19 Excitation table for the counter
Count 
SR Flip-ﬂ op inputs 
JK Flip-ﬂ op inputs 
D Flip-ﬂ op
 
Sequence 
 
 
inputs
 
A2 
A1 
A0 SA2 RA2 SA1 RA1 SA0 RA0 JA2 KA2 JA1 KA1 JA0 KA0 DA2 DA1 DA0
 
0 
0 
0 
0 
X 
0 
X 
1 
0 
0 
X 
0 
X 
1 
X 
0 
0 
1
 
0 
0 
1 
0 
X 
1 
0 
0 
1 
0 
X 
1 
X 
X 
1 
0 
1 
0
 
0 
1 
0 
0 
X 
X 
0 
1 
0 
0 
X 
X 
0 
1 
X 
0 
1 
1
 
0 
1 
1 
1 
0 
0 
1 
0 
1 
1 
X 
X 
1 
X 
1 
1 
0 
0
 
1 
0 
0 
X 
0 
0 
X 
1 
0 
X 
0 
0 
X 
1 
X 
1 
0 
1
 
1 
0 
1 
X 
0 
1 
0 
0 
1 
X 
0 
1 
X 
X 
1 
1 
1 
0
 
1 
1 
0 
X 
0 
X 
0 
1 
0 
X 
0 
X 
0 
1 
X 
1 
1 
1
 
1 
1 
1 
0 
1 
0 
1 
0 
1 
X 
1 
X 
1 
X 
1 
0 
0 
0
Table 9.19 is the excitation table for the MOD-8 counter. The three ﬂ ip-ﬂ ops are given 
variable designations A2, A1, and A0. The ﬂ ip-ﬂ op excitations for the S-R, J-K, and D inputs 
are derived from the excitation table of the S-R, J-K, and D ﬂ ip-ﬂ ops and from inspection 
of the state transition from a given count (present state) to the next below it (next state). 
The S-R ﬂ ip-ﬂ op input functions from the excitation tables are simpliﬁ ed in the K-maps 
of Figure 9.32. Similarly, the J-K and the D ﬂ ip-ﬂ op input functions from the excitation 
tables are simpliﬁ ed in the K-maps of Figure 9.33 and Figure 9.34 respectively. The Boolean 
functions listed under each map specify the combinational-circuit part of the counter. Including 
these functions with the two ﬂ ip-ﬂ ops, we obtain the logic diagram of the counter using S-
R, J-K, and D ﬂ ip-ﬂ ops as shown in Figure 9.35, Figure 9.36, and Figure 9.37 respectively.
000
111
110
101
011
010
001
100

COUNTERS 323
Figure 9.32 K-maps for the MOD-8 counter using S-R ﬂ ip-ﬂ ops.
X
X
0
X
0
1
0
0
00
0
1
01
11
10
A A
1
0
A2
0
0
1
0
0
X
X
00
0
1
01
11
10
A A
1
0
A2
X
(a) For SA2
(b) For RA2
SA2 = A′2A1A .
0
RA2 = A2A1A .
0
(c)
For SA1
(d) For RA1
SA1 = A′1A .
0
RA1 = A1A .
0
(e)
For SA0
(f) For RA0
SA0 = A′ .
0
RA0 = A .
0
(a) For JA2
(b) For KA2
JA2 = A1A .
0
KA2 = A1A .
0

324
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 9.33 K-maps for the MOD-8 counter using J-K ﬂ ip-ﬂ ops.
Figure 9.34 K-maps for the MOD-8 counter using D ﬂ ip-ﬂ ops.
(c)
For JA1
(d) For KA1
JA1 = A .
0
KA1 = A .
0
JA0 = 1.
KA0 = 1.
(e)
For JA0
(f) For KA0
0
0
0
1
1
0
0
1
1
1
0
0
1
1
1
0
00
00
0
0
1
1
01
01
11
11
10
10
A A
1
0
A A
1
0
A2
A2
(a) For DA2
(b) For DA1
DA2 = A2A′1 + A2A′0 + A′2A1A .
0
DA1 = A′1A0 + A1A′ .
0
1
0
0
1
1
0
0
1
00
0
1
01
11
10
A A
1
0
A2
(c)
For DA0
DA0 = A′ .
0

COUNTERS 325
Figure 9.35 Logic diagram of the MOD-8 binary counter using S-R ﬂ ip-ﬂ ops.
Figure 9.36 Logic diagram of the MOD-8 binary counter using J-K ﬂ ip-ﬂ ops.
Figure 9.37 Logic diagram of the MOD-8 binary counter using D ﬂ ip-ﬂ ops.
9.8 SYNCHRONOUS/ASYNCHRONOUS COUNTER
This type of counter circuit may be formed by combining the synchronous and asynchronous 
counters. They represent a compromise between the simplicity of asynch-ronous counters and 
the speed of synchronous counters. In the BCD synchronous/asynchronous counter shown 
in Figure 9.38, the input pulses are only applied to ﬂ ip-ﬂ op A in asynchronous counters, 
CLK
Q
Q
Q
Q
S
S
R
R
A  (M SB)
2
A1
A  (LSB)
0
Q
Q
S
R

326
DIGITAL PRINCIPLES AND LOGIC DESIGN
whereas the output QA drives the clock inputs of both B and D ﬂ ip-ﬂ ops so that they trigger 
simultaneously as in a synchronous counter. The operation of the counters is given below:
Figure 9.38 Synchronous/Asynchronous BCD counter.
 
1. Let us assume that the counter is initially in the 0000 state. Hence the J and K 
inputs of ﬂ ip-ﬂ ops A0, A1, A2 are all HIGH. The ﬂ ip-ﬂ op A3 has J = 0 and K = 1 and 
so it will not be affected by any clock transition.
 
2. Flip-ﬂ ops A0, A1, A2 will function as a normal ripple counter for the ﬁ rst seven input 
pulses. When the present state is 0110, the input J becomes 1 for the ﬂ ip-ﬂ op A3, but 
since the ﬂ ip-ﬂ op A3 is active in the negative edge-transition of the clock pulse (which 
is coming from A0), the ﬂ ip-ﬂ op A3 does not change its state.
 
3. In the 0111 state, the AND gate output is 1, so the ﬂ ip-ﬂ op A3 will have J = K = 1. 
When the eighth input pulse occurs, it will toggle ﬂ ip-ﬂ op A0 to the zero state, which 
in turn will toggle ﬂ ip-ﬂ op A1 LOW and ﬂ ip-ﬂ op A3 HIGH. The A1 output transition 
will toggle A2 LOW. Thus, the counter is now in the 1000 state.
 
4. The ninth input pulse simply toggles A0 HIGH bringing the counter to the 1001 
state.
 
5. In the 1001 state, the AND gate output is again 0, so ﬂ ip-ﬂ op A3 has J = 0, 
K = 1, which means it will go LOW on the next negative transition at its clock input. 
The ﬂ ip-ﬂ op A1 also has J = 0, K = 1 so it will remain in the LOW state. Thus, when 
the tenth pulse occurs, ﬂ ip-ﬂ op A0 will toggle LOW, which in turn will toggle A3 LOW 
bringing the counter back to the 0000 state. The operation then returns to step 1 and 
repeats the sequence.
9.9  PRESETTABLE COUNTER
The up-counters generally start the count sequence from 00….0 state while down-counters 
start from 11.…1 state. This is accomplished by applying a momentary pulse to all the ﬂ ip-
ﬂ op’s CLEAR inputs before the counting operation begins. A counter can also be made to 
start counting in any desired state through the use of appropriate logic circuitry. Counters 
that have the capability to start counting from any desired state are called presettable or
programmable counters.
A presettable MOD-16 ripple up-counter is illustrated in Figure 9.39. In this counter, 
the desired state is entered using the PRESET and CLEAR inputs irrespective of what is 
happening at the J and K or the clock inputs. The desired preset count is determined by 
the preset inputs PA, PB, PC, and PD whose values are transferred into the counter ﬂ ip-
ﬂ ops when the PRESET LOAD input is momentarily pulsed to the LOW level. When the 

COUNTERS 327
PRESET LOAD input returns to HIGH, the NAND gates are disabled and the counter 
is free to count input clock pulses starting from the newly entered count that has been 
preset into the ﬂ ip-ﬂ ops.
Figure 9.39 A presettable MOD-16 counter.
9.10  SYNCHRONOUS COUNTER ICs
Design of synchronous counters using ﬂ ip-ﬂ ops have been discussed above. Counters with 
any count sequence and modulus can be designed using these methods. Some synchronous 
counters are available as MSI ICs. They are listed in Table 9.20 along with some of their 
features. All these ICs are positive-edge-triggered, i.e., the synchronous loading, clearing, 
change of states all take place on the positive going edge of the input clock pulse. Basically, 
these ICs can be divided into four groups—A, B, C, and D depending on their features.
Table 9.20 Synchronous counter ICs
 
IC No. 
Description  
Features  
Group  
 
74160 
Decade Up-counter 
Synchronous preset and  
A 
 
 
 
asynchronous clear
 
74161 
4-bit binary Up-counter 
Synchronous preset and 
A 
 
 
 
asynchronous clear
 
74162 
Decade Up-counter 
Synchronous preset and clear 
A 
 
74163 
4-bit binary Up-counter 
Synchronous preset and clear 
A 
 
74168 
Decade Up-Down counter 
Synchronous preset and no clear 
B 
 
74169 
4-bit binary Up-Down counter 
Synchronous preset and no clear 
B 
 
74100 
Decade Up-Down counter 
Asynchronous preset and no clear 
C 
 
74191 
4-bit binary Up-Down counter 
Asynchronous preset and no clear 
C 
 
74192 
Decade Up-Down counter 
Asynchronous preset and clear 
D 
 
74193 
4-bit binary Up-Down counter 
Asynchronous preset and clear 
D

328
DIGITAL PRINCIPLES AND LOGIC DESIGN
9.10.1  Group A Synchronous Counter IC
The block diagram and the function table of these types of ICs are given in Figure 
9.40. There are two separate enable inputs in these types of ICs. They are ENT and ENP. 
The counting can be stopped asynchronously by setting either of these enable inputs to logic 
0. Ripple carry (RC) output is normally at logic 0 and goes to logic 1 whenever the counter 
reaches its highest count (binary 9 for BCD counters and binary 15 for 4-bit counters). 
Setting ENT to logic 0 also inhibits RC changing from logic 0 to logic 1.
(a) Block diagram.
Load L 
ENP 
ENT 
Cr 
CLK 
Mode
 
0 
X 
X 
1 
 
Preset
 
1 
0 
1 
1 
X 
Stop count
 
1 
X 
0 
1 
X 
Stop count, disable RC
 
X 
X 
X 
0 
* 
Reset to zero
 
1 
1 
1 
1 
 
UP count
 
*  X    for 74160 and 74161
 
for 74162 and 74163.
(b) Function table.
Figure 9.40 Group A synchronous counter.
Example 9.8. Design a normal MOD-13 
counter using IC 74161.
Solution. The circuit is designed for 
normal up-counting. The QD, QC, and QA
outputs are connected to the Cr terminal 
through a NAND gate, which clears the 
counter as soon as the output is 1101. The 
states of the counter are from 0000 to 1100. 
The MOD-13 counter is shown in Figure 9.41. 
In fact, using the above approach, the count 
can be terminated at any desired value and 
a counter with any modulus (less than 16 for 
binary and less that 10 for decade counter) 
can be obtained. 
Figure 9.41 MOD-13 counter using IC 74161.

COUNTERS 329
Example 9.9. Design a divide-by-12 counter using IC 74163. Make use of the RC 
output and preset inputs.
Solution. For obtaining a divide-by-12 counter using IC 74163, the counter is preset at 
binary 0100 (decimal 4). When the count reaches 1111, RC output goes to 1, which is used 
to load the data present at the preset inputs into the counter. The circuit of the counter is 
shown in Figure 9.42.
In general, for obtaining a divide-by-m counter, the preset input, P, is given by
 
 
 
P = 16–m for a 4-bit binary counter
 
 
 
 = 10–m for a decade counter 
Figure 9.42 Divide-by-12 counter using IC 74163.
Figure 9.43 Cascading arrangement of Group A synchronous counter ICs.
9.10.2  Group B Synchronous Counter IC
The block diagram and the function table of group B synchronous counter ICs are 
given in Figure 9.44. The functions ENT and ENP are the same as in Group A ICs except 
that these are active-low. Ripple carry (RC) output is normally at logic 1 and goes to logic 
0 whenever the counter reaches its highest count during up-counting, and when the count 
reaches minimum during down-counting. The value of the signal at the U/D′ decides the 
PA
QA
PB
QB
PC
QC
PD
VC C
QD
RC
EN P
Logic 1
Logic 1
Pulses
EN T
CLK
74163
Load
Cr
PA
PA
PA
QA
QA
QA
PB
PB
PB
QB
QB
QB
PC
PC
PC
QC
QC
QC
PD
PD
PD
QD
QD
QD
Logic 1
Clear
Load
CLK
CLK
CLK
CLK
EN T
EN T
EN T
IC 1
IC 2
IC 3
EN P
EN P
EN P
Cr
Cr
Cr
RC
RC
RC
L
L
L
LSD
Clear
Carry
To
Next
Counter
CLK
Load
EN P

330
DIGITAL PRINCIPLES AND LOGIC DESIGN
direction of the counting operation. When U/D′ = 1, up-counting takes place and when 
U/D′ = 0, the down-counting happens.
Here the clear terminal in not available. Hence, if it is desired to terminate the count 
before it reaches the maximum value, a NAND gate is used to detect the count corresponding 
to the required number and its output is connected to the load input terminal. The preset 
input can be given corresponding to the required starting state of the counter.
(a) Block diagram.
Load L 
ENP 
ENT 
U/D′ 
CLK 
Mode
 
0 
X 
X 
X 
 
Preset
 
1 
1 
0 
X 
X 
Stop count
 
1 
X 
1 
X 
X 
Stop count, disable RC
 
1 
0 
0 
1 
 
UP count
 
1 
0 
0 
0 
 
DOWN count
(b) Function table.
Figure 9.44 Group B synchronous counter.
9.10.2.1  Frequency of Group B Synchronous Counter ICs
The frequency of the output waveform at RC (fout) is related to the input clock frequency 
(fin) as follows:
Decade counter 74168
 
 
 
 (for up-counting)
 
 
 
 
 (for down-counting)
Binary counter 74169
 
 (for up-counting)
CLK
EN T
EN P
U/D′
74168, 74169
Preset inputs
(M SB)
Load (L)
PA
QA
PB
QB
PC
QC
PD
QD
(M SB)
Outputs
RC
=
≤
≤
in
out
,0
N
8
10 – N
f
f
=
≤
≤
in
,1
N
9
N + 1
f
=
≤
≤
in
out
,0
N
14
16 – N
f
f

COUNTERS 331
 
 
 
 
 (for down-counting)
where N is the decimal equivalent of the preset input.
The cascading of the group B counter ICs is similar to that of group A counter ICs.
Example 9.10. Design a counter with states 0011 through 1110 using the IC 74169 
counter.
Solution. The preset input is 0011 and as soon as the output reaches 1110, on the 
next pulse it should come back to its original state. Therefore, the number corresponding to 
the highest required state is to be detected for loading the counter. The counter is shown in
Figure 9.45. If the counter is required to count up to the maximum/minimum value then 
the RC output is to be connected to the load input, for loading the initial count at the next 
pulse after maximum/minimum count has been reached.
Figure 9.45 Counter for Example 9.10.
9.10.3  Group C Synchronous Counter IC
The block diagram and the function table of group C synchronous counter ICs are given in 
Figure 9.46. These ICs have only one enable input ENAB, which is active-low. MAX/MIN
(a) Block diagram.
=
≤
≤
in
,1
N
15
N + 1
f
CLK
EN T
EN P
U/D'
74169
VC C
VC C
Load
QA
PA
QB
PB
QC
PC
QD
PD
Pulses
CLK
EN AB
D/U'
74190, 74191
Preset inputs
(M SB)
Load (L)
PA
QA
PB
QB
PC
QC
PD
QD (M SB) R C  M AX/MIN
Outputs

332
DIGITAL PRINCIPLES AND LOGIC DESIGN
Load (L) 
ENAB 
D/U′ 
CLK 
Mode
 
X 
1 
X 
X 
Stop count
 
0 
0 
X 
X 
Preset
 
1 
0 
0 
 
Up-count
 
1 
0 
1 
 
Down-count
(b) Function table.
Figure 9.46 Group C synchronous counter.
output is used to detect the maximum or minimum count of the counter. It is normally at 
logic 0 and goes to logic 1 when the count is maximum (1001 for 74190 and 1111 for 74191) 
for the up-counting and minimum (0000) for the down-counting. It serves the purpose of an 
underﬂ ow detector while down-counting and an overﬂ ow detector while up-counting. The 
RC output is normally at logic 1, and goes to logic 0 when the counter reaches a MAX/MIN 
point and the CLK input is low.
9.10.3.1  Frequency Dividers
These counters can also be used as programmable frequency dividers. By presetting any 
desired number into the counter and counting to the minimum (down-counting) or maximum 
(up-counting) count, division is achieved. The RC output is connected to the load input. 
The required output waveform is obtained at MAX/MIN output. The input clock frequency 
fin and the frequency of the output waveform fout are related as follows:
Decade Counter 74190
 
 
 
 (for down-counting)
 
 
 
 
 (for up-counting)
Binary Counter 74191
 
 (for down-counting)
 
 
 
  (for up-counting)
where N is the decimal equivalent of the preset input. For example, in the case of 74190, 
if the preset input is 0111 (decimal 7), and the clock frequency is 560 Hz, the frequency of
the output waveform will be 280 Hz for up-counting and 80 Hz for down-counting. With the 
same values for the preset input and the clock frequency in the case of 74191, the frequency 
of the output waveform will be 70 Hz for up-counting and 80 Hz for down-counting.
9.10.3.2  Cascading of Group C Counters
These counters may be cascaded in three different ways:
 
1. Synchronous counter ICs cascaded with ripple carry between stages. The RC output of 
each stage is connected to the ENAB input of the succeeding stage. All CLK inputs are 
connected together and the clock pulses are applied at this common clock terminal.
 
2. Synchronous counter ICs cascaded with parallel carry. The speed of operation is 
maximum in this type of cascading. The number of stages that may be cascaded in 
in
out
,1
N
9
N
f
f
=
≤
≤
=
≤
≤
in
,1
N
8
9 – N
f
in
out
,1
N
15
N
f
f
=
≤
≤
=
≤
≤
in
,0
N
14
15 – N
f

COUNTERS 333
this manner may be restricted due to loading of MAX/MIN output by the external 
gating. A 3-decade synchronous counter with parallel carry is shown in Figure 9.47.
 
3. Synchronous counter ICs cascaded as an asynchronous counter. In this type of cascading, 
the RC output of each stage is connected to the CLK input of the succeeding stage and 
the clock pulses are applied at the CLK input of the ﬁ rst stage. In this, each IC is 
synchronous within itself, but between stages the overall system is a ripple counter.
Figure 9.47 A 3-decade synchronous counter using 74190 counter ICs with parallel carry.
9.10.4  Group D Synchronous Counter IC
In the group D counters for down-counting, the clock is applied at the CLK-DOWN 
terminal with CLK-UP connected to logic 1, and for up-counting it is applied at the CLK-
UP terminal with CLK-DOWN connected to logic 1. The block diagram of such a counter 
IC and its function table is given in Figure 9.48.
The carry and borrow outputs are normally at logic 1. The carry output drops to logic 0 
when the counter shows its maximum count while up-counting and the CLK-UP input is at 
logic 0. The borrow output remains at logic 1 as long as the circuit is operating from the CLK-
UP input. The function of borrow in down-counting is same as that of carry in up-counting.
(a) Block diagram.
Logic 1
D/U'
Clock
input
Q 0
Q A
Q A
Q A
Q 4
Q 8
Q 1
Q B
Q B
Q B
Q 5
Q 9
LSD
Q 2
Q C
Q C
Q C
Q 6
Q 10
Q 3
Q D
Q D
Q D
M AX/
M IN
M AX/
M IN
M AX/
M IN
CLK
CLK
CLK
74190
74190
74190
EN AB     Load D/U '
EN AB     Load D/U '
EN AB
 Load D /U'
Q 7
Q 11

334
DIGITAL PRINCIPLES AND LOGIC DESIGN
Load (L) Clear (Cr) CLK-UP C LK-DOWN 
Mode 
 
X 
1 
X 
X 
Reset to Zero 
 
1 
0 
 
1 
Up-count 
 
1 
0 
1 
 
Down-count 
 
0 
0 
X 
X 
Preset 
 
1 
0 
1 
1 
Stop count 
 (b) Function table.
Figure 9.48 Group D synchronous counter.
9.10.4.1  Frequency Dividers
These counters can be used as programmable frequency dividers in a similar manner 
as the one used for group C counters except that carry (or borrow) output is to be connected 
to the load input for up (or down) counting.
The input clock frequency fin and the frequency of the output waveform fout are related 
as follows:
Decade Counter 74192
 
 
 
 (for down-counting)
 
 
 
 
 (for up-counting)
Binary Counter 74193
 
 (for down-counting)
 
 
 
  (for up-counting)
where N is the decimal equivalent of the preset input. For example, in the case of 74193, if 
the preset input is 1011 (decimal 11), and the clock frequency is 550 Hz, the frequency of the 
pulses at the borrow output will be 137.5 Hz for up-counting and 50 Hz for down-counting.
9.10.4.2  Cascading of Group D Counters
In order to cascade these counter ICs, the borrow and carry outputs of each stage are 
to be connected to the CLK_DOWN and CLK-UP inputs of the succeeding stage respectively. 
For steering the clock to CLK-DOWN or CLK-UP input the circuit shown in Figure 9.49 
may be used. 
Figure 9.49 Circuit for steering clock pulses to CLK-UP (for up-count) or 
CLK-DOWN (for down-count).
in
out
,1
N
9
N
f
f
=
≤
≤
=
≤
≤
in
,1
N
8
9 – N
f
in
out
,1
N
15
N
f
f
=
≤
≤
=
≤
≤
in
,0
N
14
15 – N
f

COUNTERS 335
9.11  COUNTER APPLICATIONS
There are many applications of the counters we have discussed. In this section we will 
discuss three representative applications.
9.11.1  Frequency Counter
A frequency counter is a circuit that can measure and display the frequency of a signal. 
The method for constructing a frequency counter is shown in Figure 9.50. The counter is 
driven by the output of an AND gate. The AND gate inputs are input pulses with unknown 
frequency, fx, and a SAMPLE pulse that controls the time through which the pulses are 
allowed to pass through the AND gate into the counter.
The counter is usually made up of cascaded BCD counters, and the decoder/display 
unit converts the BCD outputs into a decimal display for easy monitoring.
The SAMPLE pulse goes HIGH from t1 to t2; this is called the sampling interval.
During this sampling interval the unknown frequency pulses will pass through the AND 
gate and will be counted by the counter. After t2 the AND gate output becomes LOW and 
the counter stops counting. Thus the counter counts the number of pulses that occur during 
the sampling interval. This is a direct measure of the frequency of the pulse waveform. 
Figure 9.50 Basic frequency counter method.
The accuracy of this method depends almost entirely on the duration of the sampling 
interval, which must be very accurately controlled. A commonly used method for obtaining 
Z
Clear
Counter
Decoder/display
Unknow n frequency
SAM PLE pulse
(a)
fx
t1
t2
SAM PLE pulses
Z
Clear
Sam pling interval
            (b)

336
DIGITAL PRINCIPLES AND LOGIC DESIGN
very accurate sample pulses is shown in Figure 9.51. A crystal controlled oscillator is used 
to generate a very accurate 100 kHz waveform, which is shaped into square pulses and 
fed to a series of decade counters that are being used to successively divide this 100 kHz 
frequency by 10. The frequencies at the output of each decade counter are as accurate 
(percentage wise) as the crystal frequency. These decade counters are usually binary or 
Johnson counters.
The switch is used to select one of the decade counter output frequencies to be fed to 
the clock input of a single ﬂ ip-ﬂ op to be divided by 2.
Figure 9.51 Method for obtaining accurate sampling intervals for frequency counters.
9.11.2  Measurement of Period
The principle of operation of the frequency counter can be modiﬁ ed and applied to the 
measurement of period rather than frequency. The basic idea is shown in Figure 9.52. An accurate 
1 MHz reference frequency is gated into the counter/display for time duration equal to Tx, the 
period of the signal being measured. The counter counts and displays the values of Tx in units 
of µ’s. For example, if Tx is 1.17 ms, the gate will allow 1170 pulses into the counter.
Figure 9.52 Measurement of period.
Crystal
oscillator
Pulse
shaper
Decade
counter
DIV 10
Decade
counter
DIV 10
Decade
counter
DIV 10
Decade
counter
DIV 10
Decade
counter
DIV 10
100 kHz
100 kHz
10 kH z
1 kHz
100 H z
10 Hz
1Hz
6
5
4
3
2
1
1s
0.1 m s
10 m s
1 m s
100 µs
10 µs
Sam ple interval
select switch
Q
Q
J
J
T/2
Sam ple
pulses
To AND
gate
T
T
T
T
x
x
x
Crystal 
oscillator
Pulse shaper
1 M Hz
Counter/
Display
Q
Q
J
K
1
1
Input signal

COUNTERS 337
9.11.3 Digital Clock
A digital clock, which displays the time of day in hours, minutes, and seconds, is one 
of the most common applications of counters. To construct an accurate digital clock, a very 
highly controlled basic clock frequency is required. For battery-operated digital clocks (or 
watches) the basic frequency can be obtained from a quartz-crystal oscillator. Digital clocks 
operated from the AC power line can use the 50 Hz power frequency as the basic clock 
frequency. In either case, the basic frequency has to be divided down to a frequency of 1 
Hz or pulse of 1 second (pps). The basic block diagram for a digital clock operating from 
50 Hz is shown in Figure 9.53. 
The 50 Hz signal is sent through a Schmitt trigger circuit to produce square pulses 
at the rate of 50 pps. The 50 pps waveform is fed into a MOD-50 counter, which is used to 
divide the 50 pps down to 1 pps. The 1-pps signal is then fed into the SECONDS section. 
This section is used to count and display seconds from 0 through 59. The BCD counter 
advances one count per second. After 9 seconds the BCD counter recycles to 0. This triggers 
the MOD-6 counter and causes it to advance one count. This continues for 59 seconds. At 
this point, the BCD counter is at 1001 (9) count and the MOD-6 counter is at 101 (5). 
Hence, the display reads 59 seconds. The next pulse recycles the BCD counter to 0. This, 
in turn, recycles the MOD-6 counter to 0.
Figure 9.53 Block diagram for a digital clock.
The output of the MOD-6 counter in the SECONDS section has a frequency of 1 pulse 
per minute. This signal is fed to the MINUTES section, which counts and displays minutes 
from 0 through 59. The MINUTES section is identical to the SECONDS section and operates 
in exactly the same manner. 
The output of the MOD-6 counter in the MINUTES section has a frequency of 1 pulse 
per hour. This signal is fed to the HOURS section, which counts and displays hours from 
Pulse 
50 Hz input
50 pps
1 pps
shaper
M OD -50
counter
Display
''H ours'' section
''M inutes'' section
''Seconds'' section
CLR'
CLR'
M OD-2
(one f/f)
BCD
counter
M OD-6
counter
M OD-6
counter
BCD
counter
BCD
counter
Decoder/
Display
Decoder/
Display
Decoder/
Display
Decoder/
Display
Decoder/
Display
0 –1
0 – 5
0 – 5
0 – 9
0 – 9
0 – 9
1 pulse/hour
1 pulse/min

338
DIGITAL PRINCIPLES AND LOGIC DESIGN
1 through 12. The HOURS section is different from the MINUTES and SECONDS section 
in that it never goes to the zero state. The circuitry in this section is different. When the 
hours counter reaches 12, it will be reset to zero by the NAND gate.
9.12  HAZARDS IN DIGITAL CIRCUITS
In asynchronous sequential circuits it is important that undesirable glitches on signals should 
not occur. The designer should be aware of the possible sources of glitches and ensure that 
the transitions in a circuit will be glitch free. The glitches caused by the structure of a 
given circuit and the propagation delays in the circuit are referred to as hazards.
If, in response to an input change and for some combination of propagation delays, a 
network output may momentarily go to 0 when it should remain a constant 1, we say the 
network has a static 1-hazard. Similarly, if the network output may momentarily go to 1 
when it should remain a constant 0, we say the network has a static 0-hazard. If when, the 
output is supposed to change from 1 to 0 (or 0 to 1), the output may change three or more 
times, we say the network has a dynamic hazard. Figure 9.54 illustrates possible outputs 
from a network with hazards.
Figure 9.54 Types of hazards.
9.12.1  Static Hazards
A circuit with a static hazard is shown in Figure 9.55. Suppose that the circuit is in 
the state where x1 = x2 = x3 = 1, in which case f = 1. Now let x1 change from 1 to 0. Then 
the circuit is supposed to maintain f = 1.
Figure 9.55 Circuit with a static 1-hazard.
Now we take into consideration the propagation delays through the gates. The change 
in x1 will probably be observed at point p before it will be seen at point q. This is since the 
path from x1 to q has an extra NOT gate in it. Hence the signal at p will become 0 before 
1
1
1
1
0
0
(c) Dynamic hazard.
(a) Static 1-hazard.
(b) Static 0-hazard.

COUNTERS 339
the signal at q becomes equal to 1. Thus, for a short time both p and q will be zero. This 
causes f to drop to 0 before it can recover back to 1. This gives rise to a static 1-hazard. 
The circuit implements the function
 
.
The corresponding Karnaugh map is shown in Figure 9.56. In the example, note that 
although in the steady state x1 and x′1 are complements, under transient conditions they 
are not. Thus, in the analysis of a network for hazards, we must treat a variable and its 
complements as if they were two independent variables. The hazard can be eliminated by 
including a redundant gate. Then the function would be implemented as 
 
.
Figure 9.56 Karnaugh map for the circuit shown in Figure 9.55.
Now the change in x1 from 1 to 0 would have no effect on the output f because the 
product term x2x3 would be equal to 1 if x2 = x3, regardless of the value of x1. The resulting 
hazard-free circuit is shown in Figure 9.57.
A potential hazard exists whenever two adjacent 1s in a Karnaugh map are not covered 
by a single product term. Therefore, a technique for removing hazards is to ﬁ nd a cover 
in which some product term includes each pair of adjacent 1s. Then, since a change in an 
input variable causes a transition between two adjacent 1s, no glitch can occur because 
both 1s are included in a product term.
Figure 9.57 (a) Karnaugh map for a hazard-free circuit, (b) Hazard-free circuit.
From the previous example, it seems that static hazards can be avoided by including all 
prime implicants in a sum-of-products circuit that realizes a given function. This is indeed 
true. But it is not always necessary to include all prime implicants. It is only necessary 
to include product terms that cover the adjacent pair of 1s. There is no need to cover the 
don’t-care vertices.
We consider the function in Figure 9.58. A hazard-free circuit that implements this 
function should include the encircled terms, which gives
1
2
1
3
f
x x
x x
=
+
1
2
1
3
2
3
f
x x
x x
x x
=
+
+
(a)
(b)

340
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
 
1
3
2
3
3
4
f
x x
x x
x x
=
+
+
.
Figure 9.58 Karnaugh map for the above example.
The prime implicant     is not needed to prevent hazards, because it would account 
only for the two 1s in the left-most column. These 1s are already covered by     .
Static hazards can also occur in other types of circuits. Figure 9.59(a) depicts a product-
of-sums circuit that contains a hazard. If x1 = x3 = 0 and x2 changes from 0 to 1, then f
should remain at 0. However, if the signal at p changes earlier than the signal at q, then 
p and q will both be equal to 1 for a short time, causing a glitch 0 → 1 → 0 on f.
In a POS circuit, it is the transitions between adjacent 0s that may lead to hazards. 
Thus, to design a hazard-free circuit, it is necessary to include sum terms that cover all 
pairs of adjacent 0s. In this example, we will get
 
 
 
1
2
2
3
1
3
(
)(
)
(
)
f
x
x
x
x
x
x
=
+
+
+
+
.
The circuit is shown in Figure 9.59(c).
Figure 9.59 Static 0-hazard in a POS circuit and removal of hazard.
X
X
1
1
1
1
1
1
00
00
11
01
10
01
11
10
x2x1
x4x3
1
X
x2x1
x1x3
(a) Circuit with static 0-hazard.
    (b) Karnaugh map.
(c) Hazard-free circuit.

COUNTERS 341
In summary, the following procedure can be used to ﬁ nd all static 1- and 0-hazards 
in a network due to single input variable changes: 
 
1. Determine the transient output function of the network Ft, and reduce Ft to SOP form 
treating each variable and its complement as separate variables.
 
2. Examine each pair of adjacent input states for which Ft is 1. If there is no 1-term 
that includes both input states of the pair, a 1-hazard is present. This is conveniently 
accomplished by plotting the 1-terms of Ft on a Karnaugh map and checking each 
pair of adjacent 1s on the map.
 
3. If the sum of products for Ft does not contain the product of a variable and its 
complement, no 0-hazards are present. If the sum of products for Ft contains the 
product of a variable and its complement, a 0-hazard may be present. To detect all 
0-hazards,
(a) Obtain the POS form for Ft by factoring or other means. xi and x′i are still treated 
as separate variables.
(b) Examine each pair of adjacent input states for which Ft is 0. If there is no 
0-term that includes both input states of the pair, a 0-hazard is present. This 
can be conveniently done by plotting the 0-terms of Ft on a Karnaugh map and 
checking each pair of adjacent 0s on the map. 
Static 0- and 1-hazards can be eliminated by adding additional gates to the network 
to produce the missing 1-terms and 0-terms. 
9.12.2  Dynamic Hazards 
Dynamic hazards due to a change in an input variable xi can only occur if there are 
three or more paths between xi (and/or x′i) input and the network output. This is necessary 
since a dynamic hazard involves a triple change in output, so the effect of the input change 
must reach the output at three different times. A network may have a dynamic hazard even 
if it is free of static hazards as illustrated by the example in Figure 9.60. For this network, 
the transient output function is 
Yt = (ac' + bc)(a' + c') = a'bc + ac' + bcc'
 
= (ac' + b)(ac' + c)(a' + c') = (a + b)(b' + c)(a + c)(c + c')(a' + c').
a'
a
b
c'
c'
c
G4
0
1
1
1
0
0
1
1
G2
G3
1
1
G1
0
0
0
1
1
0
0
0
1
1
0
Y
1
(a)

342
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 9.60 Network with a dynamic hazard.
Plotting the 1-terms and the 0-terms of Yt on the map of Figure 9.60(b) reveals that 
there are no 1- or 0-hazards. Inspection of the network shows that the only input variable 
that could cause a dynamic hazard when it changes is c (since c is the only variable with 
three paths to the output). If we choose, , the effect of a change in c can propagate to the 
output along all three paths. If the gate outputs change in the order shown in Figure 
9.60(c), the G3 output undergoes a 1-0-1 change before the G4 output changes 1 to 0, and 
the dynamic hazard shows up at the output.  Dynamic hazards are not easy to detect nor 
easy to deal with. The designer can avoid dynamic hazards simply by using two-level circuits 
and ensuring that there are no static hazards. 
9.12.3  Essential Hazards
Even though an asynchronous sequential network is free of critical races and the 
combinational part of the network is free of static and dynamic hazards, timing problems 
due to propagation delays may still cause the network to malfunction and go to the wrong 
state. For example, we consider the network of Figure 9.61. Clearly, there are no hazards 
in the combinational part of the network, and inspection of the ﬂ ow table shows that there 
are no critical races. If we start in state “a” and change x to 1, the network should go to 
state “d.” However, consider the following possible sequence of events:
1. x changes 0 to 1.
 
2. Gate 2 output changes 0 to 1.
 
3. Flip-ﬂ op f1 output changes 0 to 1.
(b)
C
G 1
G 2
G 3
G 4
Y
(c)

COUNTERS 343
 
4. Gate 4 output changes 0 to 1.
 
5. Flip-ﬂ op f2 output changes 0 to 1.
 
6. Inverter output x′ changes 0 to 1.
 
7. Gate 1 output changes 0 to 1, gate 2 output changes back to 0, and gate 4 output 
changes back to 0.
 
8. Flip-ﬂ op output f1 changes back to 0.
Figure 9.61 Network with essential hazards.
We may note that the ﬁ nal state of the network is “b” instead of “d.” This came about 
because the delay in the inverter was longer than the other delays in the network. Hence, 
in effect, part of the network saw the value of x = 1 while the other part of the network 
had x = 0. The net result was that the network acted as if the input x had changed three 
times instead of once so that the network went through the sequence of states f1f2 = 00, 
10, 11, 01.
The malfunction illustrated in the previous example is termed an essential hazard. 
Essential hazards can be located by inspection of the ﬂ ow table. Hence, we may deﬁ ne an 
essential hazard as follows:
A ﬂ ow table has an essential hazard starting in stable total state “s” for input variable 
f′1
R 1
R 2
f1
f2
S1
S2
f2
f2
f1
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
1
1
1
1
1
1
1
1
1
0
0
0
1
x
x
x
f′2
f′1
(a)
00
a
10
d
00
a
b
11
c
11
c
01
b
10
d
0
0
00
00
11
11
01
01
10
10
1
1
x
x
f f
1 2
f f
1 2
01
(b)

344
DIGITAL PRINCIPLES AND LOGIC DESIGN
xi if, and only if, the stable total state reached after one change in xi is different from the 
stable total state reached after three changes in xi.
Essential hazards can be eliminated by adding delays to the network. For the example 
discussed above, if we add a sufﬁ ciently large delay to the output of ﬂ ip-ﬂ op f1, then the 
change in x will propagate to all of the gates before the change in f1 takes place and the 
essential hazard is eliminated. 
REVIEW QUESTIONS
9.1 Compare between a ripple and a synchronous counter.
9.2 Design a MOD-18 ripple counter using J-K ﬂ ip-ﬂ ops.
9.3 Design a MOD-32 parallel counter using S-R ﬂ ip-ﬂ ops.
9.4 Draw the gates necessary to decode all the stages of a MOD-16 counter using active-HIGH outputs.
9.5 What is the lock-out condition of a counter?
9.6 How can you convert an up-counter into a down-counter?
9.7 Design a MOD-16 up-down counter using D ﬂ ip-ﬂ ops.
9.8 Which ﬂ ip-ﬂ op is best suited for designing a counter and why?
9.9 How does a digital clock operate? Explain.
9.10 What is meant when we say that a counter is presettable?
9.11 Explain why a ripple counter’s maximum frequency limitation decreases as more ﬂ ip-ﬂ ops are 
added to the counter.
9.12 A certain J-K ﬂ ip-ﬂ op has propagation delay of 12 ns. What is the largest MOD counter that 
can be constructed from these ﬂ ip-ﬂ ops and still operate up to 10 MHz?
9.13 What would the notation “DIV32” mean on a counter symbol?
9.14 Explain why the decoding gates for an asynchronous counter may have glitches on their outputs.
9.15 How does strobing eliminate decoding glitches?
9.16 Discuss the procedure for designing synchronous counters.
9.17 Design a synchronous counter that has the following sequence: 0010, 0110, 1000, 1001, 1100, 
1101, and repeat. From the undesired states the counter must always go to 0010 on the next 
clock pulse.
9.18 Design a 4-bit counter with one control signals S. The counter should operate as
 
 (a) binary down-counter when S = 0,
 
 (b) binary up-counter when S = 1.
9.19 How many decade counters are necessary to implement a DIV1000 counter and DIV10000 
counter?
9.20 Analyze the counter shown in Figure P.9.1 for a “lock-up” condition in which the counter cannot 
escape from an invalid state or states. An invalid state is one that is not in the counter’s normal 
sequence.
Figure P.9.1
❑ ❑ ❑

345
10.1  INTRODUCTION
T
here are numerous advantages to processing signals using digital systems. And because of 
these advantages, digital systems are widely used for control, communication, computers, 
instrumentation, etc. In many such applications of digital systems, the signals are not 
available in the digital form. Therefore, to process these analog signals using digital hardware, 
they have to be converted into digital form. The process of conversion of analog signal to digital 
signal is referred as analog-to-digital conversion. The system that realizes the conversion is 
referred to as an analog-to-digital converter or A/D Converter or ADC.
The output of the system may be desired to be of analog form. Therefore, the output of the 
digital system is required to be converted back to the analog form. The process of converting 
the digital signal to analog form is called digital-to-analog conversion and the system used for 
this purpose is referred to as a digital to analog converter or D/A converter or DAC.
Figure 10.1
In the present trend of technology, most of the signal processing is based on digital 
systems. But the real-world signals are analog in nature. A/D converter and D/A converter 
are the bridge between the analog world and digital world. They ﬁ nd their applications in 
almost every system of signal processing. An elementary analog signal-processing system 
with the use of a digital processor is illustrated with the block diagram in Figure 10.1. In 
this chapter the D/A converter will be discussed ﬁ rst as it also serves as a sub-system of 
the A/D converter.
10.2  DIGITAL-TO-ANALOG CONVERTERS (DAC)
The input of a D/A converter is an n-bit binary signal, available in parallel form. Normally, 
digital signals are available at the output of latches or registers and the voltages correspond to 
Analog to
Digital
Converter
Digital
Processor
Digital to
Analog
Converter
Digital
Signal
Digital
Signal
Analog
Signal
Analog
Signal
A/D AND D/A 
CONVERSION
10
C h a p t e r

346
DIGITAL PRINCIPLES AND LOGIC DESIGN
logic 0 and logic 1. In general, the logic levels do not have precisely ﬁ xed voltages. Therefore, 
these voltages are applied directly to the converter for digital-to-analog computation, but 
they are used to operate digitally controlled switches. The switch is operated to one of 
the two positions depending upon the digital signal logic levels (logic 0 or logic 1) which 
connects precisely ﬁ xed voltages  or voltage references V(1) or V(0) to the converter input, 
corresponding to logic 1 and logic 0 respectively.
The analog output voltage Vo of an n-bit straight binary D/A converter can be related 
to the digital input by the equation
Vo = K (2n-1 . bn–1 + 2n–2 . bn–2 + 2n–3 . bn–3 + ………+ 22. b2 + 2. b1 + b0). 
(10.1)
Where  K = proportionality factor equivalent to step size in voltage,
bn = 
1, 
if the nth bit of the digital input is 1,
 
 
    = 
0, 
if the nth bit of the digital input is 0.
As an example, for a 4-bit D/A converter, there are 16 voltage levels and they are tabulated 
in Figure 10.2 assuming the voltage step size or the proportionality factor K = 1.
There are two types of commonly used D/A converters as mentioned below.
 
1. Weighted-resistor D/A converter, and  
 
2. R-2R ladder D/A converter.
     Digital Input 
               Analog Output
 
D3 
D2 
D1 
D0 
V
 
0 
0 
0 
0 
0
 
0 
0 
0 
1 
1
 
0 
0 
1 
0 
2
 
0 
0 
1 
1 
3
 
0 
1 
0 
0 
4
 
0 
1 
0 
1 
5
 
0 
1 
1 
0 
6
 
0 
1 
1 
1 
7
 
1 
0 
0 
0 
8
 
1 
0 
0 
1 
9
 
1 
0 
1 
0 
10
 
1 
0 
1 
1 
11
 
1 
1 
0 
0 
12
 
1 
1 
0 
1 
13
 
1 
1 
1 
0 
14
 
1 
1 
1 
1 
15
Figure 10.2

A/D AND D/A CONVERSION 347
10.2.1  Weighted-resistor D/A Converter
Let us consider a resistor network that has N-bit straight binary inputs (through 
digitally controlled electronic switches), which produces a current I corresponding to logic 
1 at the most signiﬁ cant bit, I/2 corresponding to logic 1 at the next lower bit, I/22 for the 
next lower bit and so on, and I/ 2N–1 for logic 1 at the least signiﬁ cant bit position. The 
total current thus produced will be proportional to the digital inputs. This current can be 
converted to voltage with the help of a current-to-an voltage converter circuit by an using 
operational ampliﬁ er (OP AMP). The produced voltage is analog in nature and will be 
proportional to the digital inputs.
The scheme above for converting digital signals to analog voltage can be realized by 
the circuit diagram as shown in Figure 10.3. It may be observed in the circuit diagram that 
different values of resistances are used at the digital inputs and the resistance values are 
the multiple of the resistance corresponding to the most signiﬁ cant digital input to produce 
the currents I, I/2, I/22, .... I/ 2N–1. Since the resistance values are weighted in accordance 
with the binary weights of the digital inputs, this circuit is referred to as a weighted-resistor
D/A converter.
In the circuit in Figure 10.3, digitally controlled switches have two positions once they 
are connected to voltage V(1), which is equivalent to logic 1,  and  at other positions they 
are connected to V(0), which equivalent to logic 0.
Figure 10.3
Current produced at the most signiﬁ cant bit through resistor R is IN–1, at resistor 2R is 
IN–2, at resistor 4R is IN–3,  so on, and at the least signiﬁ cant bit through resistor 2N–1, R 
current is I0. Then,
 
IN–1  = VN–1/R        
 
IN–2  = VN–2/2R
 
IN–3  = VN–3/22R  
 
 
 
:
 
 
:
I0 = V0/2N–1R. 
(10.2)
Where Vn = V(1) if bn = 1
 
 
 
= V(0) if bn = 0.
R f
2**(N-1).R
V o
D igitally
C ontrolled
Switches
V(1)
V(0)
:
:
:
R
2R
4R
M SB
LSB

348
DIGITAL PRINCIPLES AND LOGIC DESIGN
Vn is the voltage of the nth bit and bn is the nth bit.
So, the total current at the input of OP AMP 
Ii = IN–1 + IN–2 + IN–3 + …. + I2 + I1 + I0.  
(10.3)
Or, 
Ii = VN–1/R + VN–2/2R + VN–3/22R + .... + V2/2N=3R + V1/2N–2R + V0/2N–1R.  (10.4)
If the output of OP AMP is considered as Vo, then Ii may be equated as –Vo/RF, or
–Vo/RF = VN–1/R + VN–2/2R + VN–3/22R + .... + V2/2N=3R + V1/2N–2R + V0/2N–1R.
Or, 
Vo = –RF (VN–1/R + VN–2/2R + VN–3/22R + .... + V2/2N=3R + V1/2N–2R + V0/2N–1R).
Or,  
Vo = –(RF /2N–1R) (2N–1VN–1 + 2N–1VN–2 + 2N–1VN–3 +.... +22V2 + 21V1 +20V0).
(10.5)
For straight binary inputs, V(0) = 0 and V(1) = VR.  Therefore Vo may be expressed as
Vo = –RF (VR bN–1/R + VR bN–2/2R + VR bN–3/22R +....+ VR b2/2N=3R + VR b1/2N–2R + VR
b0/2N–1R)
= –VR(RF bN–1/R + RF bN–2/2R + RF bN–3/22R +....+ RF b2/2N=3R + RF b1/2N–2R + RF b0/2N–1R).
(10.6)
From the above Expressions 10.5 and 10.6, we may conclude that output voltage Vo is 
the summation of input bits multiplied by the factor RF/2N–1R, where N is the bit position. 
These expressions are similar to the Expression 10.1 with the multiplying factor 
 
 
 
 
K = (RF/2N–1R) VR. 
 
 
(10.7)
In this circuit the output swings in only one direction and therefore it is unipolar. 
Sometimes it may require that the output is desired with some offset voltage. This arrangement 
can be done with some modiﬁ cation of the circuit as in Figure 10.4.
Figure 10.4
The offset produced in this circuit is –Voff.RF/Roff, and the revised expression for the 
output will be
Vo = –Voff.RF/Roff –(RF/2N–1R) (2N–1VN–1 + 2N–1VN–2 +2N–1VN–3 +....+ 22V2 + 21V1 + 20V0).
 
 
 
 
 
 
 
 
 
  (10.8)
For straight binary inputs where V(1) = 1 and V(0) = 0, the output expression will be
Vo = –Voff.RF/Roff –VR(RF bN–1/R + RF bN–2/2R + RF bN–3/22R +....+ RF b2/2N=3R + 
RF b1/2N–2R + RF b0/2N–1R). 
 
 
 
 
 
 
           (10.9)
D igital
C ontrol
Switches
R
2R
4R
M SB
LSB
:
:
:
V(1)
V(0)
2
.R
(N -1)
V f
o
R off
R f
Vo

A/D AND D/A CONVERSION 349
Example 10.1. (a) Consider a 4-bit D/A converter with V(1) = –1 V, V(0) = 0 V, and 
RF = 8R. Obtain the analog voltage for each of the digital inputs from 0000 to 1111. (b) Adjust the 
offset voltage, using the circuit of Figure 10.4, such that Vo = 0 V for digital input 1000. Obtain 
analog voltage for each of the digital inputs with this offset. (c) Using  the above offset voltage, 
obtain the analog voltages if MSB is complemented before applying to the D/A converter. 
Solution. (a) For a 4-bit D/A converter, the output voltage using Equation 10.6, Vo can 
be expressed as 
Vo = –VR(RF bN–1/R + RF bN–2/2R + RF bN–3/22R + RF bN–4/23R)
 
= –VR(RF b3/R + RF b2/2R + RF b1/4R + RF b0/8R)
= 8b3 + 4b2 + 2b1 + b0 V. 
(Substituting RF = 8R and VR = –1 V.)   (10.10)
The table for digital inputs 0000 to 1111 with their corresponding output voltages is 
similar to Figure 10.2 (notation D3, D2, D2, D0 are to be replaced by b3, b2, b1, b0).
Digital Input 
Analog Output
 
b3 
b2 
b1 
b0 
V
 
0 
0 
0 
0 
-8
 
0 
0 
0 
1 
-7
 
0 
0 
1 
0 
-6
 
0 
0 
1 
1 
-5
 
0 
1 
0 
0 
-4
 
0 
1 
0 
1 
-3
 
0 
1 
1 
0 
-2
 
0 
1 
1 
1 
-1
 
1 
0 
0 
0 
0
 
1 
0 
0 
1 
1
 
1 
0 
1 
0 
2
 
1 
0 
1 
1 
3
 
1 
1 
0 
0 
4
 
1 
1 
0 
1 
5
 
1 
1 
1 
0 
6
 
1 
1 
1 
1 
7
Figure 10.5
(b)  From the table in Figure 10.2, we can see that without applying the offset voltage, 
the output voltage is 8 V when digital input is 1000. So an offset voltage of –8 V must be 
produced. Therefore,
 
 
 
 
–Voff.RF/Roff = –8 V.
We may use Roff = R and Voff = 1 V . The analog voltage corresponding to digital inputs 
with the offset voltage is shown in Figure 10.5.

350
DIGITAL PRINCIPLES AND LOGIC DESIGN
(c) If MSB is complemented, i.e., digital input b3 is complemented to b3', the analog 
voltage outputs are shown in the table in Figure 10.6, applying the same offset voltage.
You may notice from the table in Figure 10.6, that this is a D/A converter, which 
converts 2’s complement format to an analog signal.
Digital Input 
Analog Output
 
b3 
b2 
b1 
b0 
V 
 
1 
0 
0 
0 
–8 
 
1 
0 
0 
1 
–7 
 
1 
0 
1 
0 
–6 
 
1 
0 
1 
1 
–5 
 
1 
1 
0 
0 
–4 
 
1 
1 
0 
1 
–3 
 
1 
1 
1 
0 
–2 
 
1 
1 
1 
1 
–1 
 
0 
0 
0 
0 
0 
 
0 
0 
0 
1 
1 
 
0 
0 
1 
0 
2 
 
0 
0 
1 
1 
3 
 
0 
1 
0 
0 
4 
 
0 
1 
0 
1 
5 
 
0 
1 
1 
0 
6 
 
0 
1 
1 
1 
7
Figure. 10.6
Example 10.2. Design a D/A converter for 4-bit digital inputs in 1’s complement format.
Solution. For 1’s complement format, when MSB is 0 the data is positive and data is 
assumed as negative when MSB is 1. Therefore, 4-bit format data 0000 to 0111 represent 
positive numbers 0 to +7 and are the same as the representations of the unipolar binary 
numbers. No offset voltage is required for these inputs. 
For negative numbers 1111 to 1000, the output analog voltage is offset by –15 V.  This 
can be achieved by operating a switch with MSB of input to introduce the proper value of 
Voff. The circuit diagram is shown in Figure 10.7. The circuit components are 
 
 
 
RF =8R, V(1) = –1 V, V(0) = 0 V.
The weighted-resistor D/A converter has the problem of having a wide range of resistance 
values of R to 2N–1.R. They are required to be very precise and also required to track over 
a wide temperature range to achieve analog voltage with high precision. It is very difﬁ cult 
to fabricate such a wide range of high-precision resistance values in a monolithic IC.  This 
difﬁ culty is eliminated by an R-2R ladder network type D/A converter as discussed next.

A/D AND D/A CONVERSION 351
Figure 10.7
10.2.2  R-2R Ladder D/A Converter
The circuit diagram in Figure 10.8 illustrates an R-2R ladder D/A converter. It's 
comprised of only two types of resistor values, R and 2R. The inputs to the resistor network 
are applied through digitally controlled switches. A switch is in position 0 or 1 corresponding 
to digital input for that bit position being 0 or 1, respectively. To analyze the circuit, for 
simplicity, let us consider a 3-bit R-2R ladder network as in Figure 10.9(a) assuming the 
digital input as 001.
Figure 10.8
 
 
Figure 10.9(a)  
 
 
Figure 10.9(b)
D igital
C ontrol
Switches
R
2R
4R
M SB
LSB
V(1)
V(0)
8R
Voffset
R f
V o
V o
R
R
R
2R
LSB
2R
2R
2R
2R
2R
M SB
2R
R f
+
VR
+
+
X
R
R
2R
2R
2R
2R
2R
LSB
Vr
Y
Z
R
R
R
2R
V /2
R
2R
2R
Z
Y
+

352
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
Figure 10.9(c)  
 
Figure 10.9(d)
The circuit is simpliﬁ ed using Thevinin’s theorem. Applying Thevnin’s theorem at X, 
the circuit of Figure 10.9(a) may be modiﬁ ed to the circuit in Figure 10.9(b). The equivalent 
resistance before X is modiﬁ ed to R with the voltage source VR/2. Similarly, applying Thevnin’s 
theorem at Y of the circuit in Figure 10.9(b), an equivalent circuit can be reconstructed as 
in Figure 10.9(c).
Finally, an equivalent circuit is obtained in Figure 10.9(d), by applying Thevnin’s 
theorem again at Z. You may notice in the circuit diagram in Figure 10.9(d) that equivalent 
resistance is R and equivalent voltage is VR/23. Here LSB is assumed as 1. 
Figure 10.10
Similarly, for the digital inputs 010 and 100, the equivalent voltages will be VR/22
and VR/2 respectively. Now, by applying superposition theorem, all the digital inputs of the 
equivalent circuit can be reconstructed as in Figure 10.10, where effective resistance for 
each digital input is 3R. The output analog voltage VO may be expressed as 
VO = –{(RF/3R).(VR/23).b0 + (RF/3R).(VR/22).b1 + (RF/3R).(VR/2).b2} 
(10.11)
 
= –{(RF/3R).(VR/23).(22b2 + 21b1 + 20b0)}. 
 
(10.12)
The above circuit may be expanded to any number of digital inputs. With the circuit 
analysis as above, it may be observed that for Nth digital input effective resistance is 3R and 
effective voltage applied is VR/2N. The generalized expression for analog output voltage is
VO = –{(RF/3R).(VR/2N).(2N–1bN–1 + 2N–2bN–2 +....+ 22b2 + 21b1 + 20b0)}. 
(10.13)
Choosing RF = 3R and VR = –2N V, the above expression for analog output voltage is 
reduced to
VO = (2N–1bN–1 + 2N–2bN–2 +....+ 22b2 + 21b1 + 20b0). 
(10.14)
The number of resistors required for an N-bit D/A converter is 2N in the case of an R-
2R ladder type D/A converter, whereas the number of resistors required for weighted resistor 
type D/A converter is N. However, for an R-2R ladder network the type of resistance values 
is only two, which are required to be precise. On the other hand, if the number of bits N 
+
+
V /2
R
2
V /2
R
3
R
R
2R
2R
R
2R
Z
R F
V o
+
3R
3R
3R
LSB
M SB
V /2
R
V /2
R
3
V /2
R
2

A/D AND D/A CONVERSION 353
is large, the weighted-resistor type D/A converter needs wide-spread precision resistance 
values and hence it is not suitable for practical purpose. However, the weighted-resistor 
network can be modiﬁ ed in such a way that it can accommodate a large number of bits 
without consequent spread in resistance values.
10.2.3  Modiﬁ ed Weighted-resistor D/A Converter
Figure 10.11 illustrates one circuit example of modiﬁ ed type of weighted-resistor D/A 
converter. Here the bits are divided into groups of four. Each of the groups comprises a 
weighted-resistor type network. The most signiﬁ cant group of four bits is directly connected 
to the OP AMP input, but the least signiﬁ cant group is connected to the OP AMP input 
through an additional resistor RX. The resistance RX is introduced to produce input currents 
of OP AMP due to the least signiﬁ cant group of four bits and the most signiﬁ cant group of 
four bits in the ratio of 1:16. This means
Figure 10.11
 
 
 
 
(10.15)
The resistor RX is determined by the following way. Let the bit b3 be 1 and b2, b1, and 
b0 are 0. The part of the circuit consisting of b3, b2, b1, and b0 is drawn at Figure 10.12(a)
for simpliﬁ cation of analysis, and its further simpliﬁ ed equivalent circuit is drawn in Figure 
10.12(b). From Figure 10.12(b), input current to OP AMP Iin(1) is calculated, assuming OP 
AMP inputs are virtual grounded.
 
 
 
RY = 2R || 4R || 8R = R . 8/7 
(10.16)
So,   Iin(1)  =  
(10.17) 
R
R
2R
2R
4R
4R
8R
8R
R f
R x
+
b 7
b 6
b 5
b 4
b 3
b 2
b 1
b 0
V o
V
R
R (R.8 / 7)
R
R.8 / 7
x
R.8 / 7
R
R.8 / 7
V
R
R .15 / 8.
R
x
x
x
R
x
+
+
+
=
+
3
0
2
1
7
6
5
4
1
16
=
=
=
=
b
b
b
b
b
b
b
b
.

354
DIGITAL PRINCIPLES AND LOGIC DESIGN
Similarly, input current to OP AMP Iin(2) is calculated considering b7 bit is 1 and all 
other bits 0. 
 
 
 
Iin(2) = VR/R 
 
(10.18)
Now, Iin(2) = 16 Iin(1),  
so, VR/R = 16. VR/ (R + RX . 15/8).
After simpliﬁ cation, we get RX = 8R.  
 
(10.19)
Figure 10.12(a) 
 
 
 
Figure 10.12(b)
The relation RX = 8R may be veriﬁ ed for the other digital inputs b2, b1, and b0, for 
which input current will be 1/16th of the currents due to b6, b5, and b4 respectively. The 
output voltage VO of this modiﬁ ed D/A converter as shown in Figure 10.11 for RX = 8R, can 
be expressed as follows
VO = –{(VR/R)RFb7 + (VR/2R)RFb6 + (VR/4R)RFb5 + (VR/8R)RFb4 + (VR/16R)RFb3
                                 + (VR/32R)RFb2 + (VR/64R)RFb1 + (VR/128R)RFb0}
= –{(VR/27) (RF/R) (27b7 + 26b6 + 25b5 + 24b4 + 23b3 + 22b2 + 21b1 + 20b0)}.   (10.20)
Note that the analog voltage output derived in Expression 10.20 is proportional to the 
digital input. The number of resistors in this circuit is less and also the variety of resistor 
values is reduced. The circuit conﬁ guration can be extended to any number of bits.
Example 10.3. Design a 2-decade BCD D/A converter.
Solution. We have seen in the earlier chapters that each of the BCD numbers 
consists of four binary digits. Therefore, 2-decade numbers will have 8 binary digits. The 
modiﬁ ed weighted resistor D/A converter conﬁ guration may be used to design the 2-decade 
D/A converter. The binary inputs corresponding to the least signiﬁ cant digit are applied at 
b3, b2, b1, and b0 and the next signiﬁ cant digit is applied to b7, b6, b5, and b4. The circuit 
diagram is similar to Figure 10.11. The little difference for the BCD converter is that the 
value of RX should be such that the input current to the OP AMP corresponding to the least 
signiﬁ cant digit is 1/10th of the input current due to the next signiﬁ cant digit. This means 
the equation at 10.15 is modiﬁ ed as
 
 
 
 
  
(10.21)
Using Equation 10.17, input current Iin(1) due to b3, when other bits b2, b1, and b0 are 
grounded, is calculated as
 
 
 
 
(10.22) 
R
2R
R f
R x
4R
8R
R
R f
R y
R x
+
+
+
+
b 3
b 2
b 1
b 0
V o
V o
3
0
2
1
7
6
5
4
1
10
=
=
=
=
b
b
b
b
b
b
b
b
.
Iin (1)  = 
V
R
R 15/ 8
R
x.
+
.

A/D AND D/A CONVERSION 355
Similarly, input current to OP AMP Iin(2) is calculated considering b7 bit is 1 and all 
other bits 0. 
 
 
 
 
Iin (2) = VR/R 
(10.23)
Now, 
 
 
Iin(2) = 10 Iin(1), 
So, VR/R = 10. VR/(R + RX.15/8).
After simpliﬁ cation, we get
 
 
 
 
RX = 4.8R. 
 
(10.24)
Therefore, by using resistor value RX as 4.8R, the circuit diagram as illustrated in 
Figure 10.11 can be converted to a 2-decade BCD D/A converter.
10.3  SPECIFICATION OF D/A CONVERTERS 
It is very important that the designers as well as the users be aware of the governing 
characteristics of D/A converters, as these characteristics play an important role to determine 
the stability and accuracy in analog output. The following characteristics of D/A converters 
are generally speciﬁ ed by the manufacturers.
 
1. Resolution.
 
2. Linearity.
 
3. Accuracy.
 
4. Settling time. 
 
 
5. Temperature sensitivity. 
10.3.1  Resolution
It is deﬁ ned by the smallest possible change in the output voltage as a fraction or 
percentage of the full-scale output range. If an 8-bit D/A converter is considered for an 
example, there are 28 or 256 possible values of output analog voltage. Hence the smallest 
change in the output voltage is 1/255th of full-scale output range. Therefore, the resolution is 
calculated as 1/255 or 0.4%. So a general expression of resolution for an N-bit D/A converter 
may be deﬁ ned as below.
Resolution =  
(10.25)
Alternatively, resolution is also deﬁ ned by the number of bits accepted by the D/A 
converter. For example, a 12-bit D/A converter has 12-bit resolution.
10.3.2   Linearity
In D/A converters, it is desired that equal increments in the numerical signiﬁ cance of the 
digital inputs should result in equal increments in the analog output voltage. However, in practical 
circuits, due to an error in resistor values and potential loss at the switches, this type of linear 
input-output relationship is never achievable. The term linearity of a converter determines the 
measure of precision with which the linear input-output relationship is satisﬁ ed.
Figure 10.13 demonstrates the input-output relationship of a 3-bit D/A converter. The 
horizontal axis represents the input bit combinations with ﬁ xed interval separations in 
order of numerical signiﬁ cance and the vertical axis represents the output analog voltage. 
The output corresponding to each input is indicated by a dot. If the D/A converter is ideal 
or perfectly linear, the dots would be on the straight line.
N
1
100%.
2
1
×
−

356
DIGITAL PRINCIPLES AND LOGIC DESIGN
However, in Figure 10.13, it has been shown that the dots are not in a single straight 
line. This is to show the practical nonlinearity behavior of the converter. The linearity error 
for a digital input is the difference between the actual voltage obtained corresponding to 
the dot and the ideal voltage expected. This is denoted by ε. The normal analog output 
voltage change corresponding to a digital input change equivalent to the least signiﬁ cant 
bit is indicated by ∆. This means the resolution of the converter is ∆.
Figure 10.13
The linearity of a D/A converter is generally speciﬁ ed by comparing ε with ∆. For 
example, the linearity of a commercially available D/A converter is usually speciﬁ ed as less
than ½  LSB. This implies that |ε|< ½  ∆.
10.3.3  Accuracy
The accuracy of a D/A converter is determined by the measure of the difference between 
the actual output voltage and the expected output voltage. It is speciﬁ ed as the percentage of 
maximum output or the full-scale output voltage. For example, if a D/A converter is speciﬁ ed 
as the accuracy of 0.1%, with full-scale of maximum output voltage of 10 V, the maximum error 
at output voltage corresponding to any input combination will be 10 × 0.1/100 V = 10 mV.
10.3.4  Settling Time
It is one of the important governing factor of a D/A converter. For any change in 
digital input, the analog output voltage does not instantaneously attain its expected value 
corresponding to the digital input and takes some time to attain the steady state output. This 
is due to transients that appear at the output voltage and oscillation may occur because of 
the presence of switches, active devices, stray capacitance, and inductance associated with 
passive circuit components. A typical plot of change in analog output voltage with respect 
to time is shown in Figure 10.14.
The time required for analog output to settle to within ± ½   LSB of the ﬁ nal value 
due to a change in the digital input is usually speciﬁ ed by the manufacturers and is referred 
to as settling time. In Figure 10.14, it has been demonstrated that the ﬁ nal value of output 
voltage is settled within  ± ½   LSB of the ﬁ nal value at time T, which is called settling 
000
001
010
011
100
101
110
111
0
1
2
3
4
5
6
7
Digital Input
ε
∆
Analog
Voltage
Output

A/D AND D/A CONVERSION 357
time. Settling time limits the speed and operating frequency of a D/A converter. Operating 
frequency of the converter should be such that analog output must be settled to the correct 
voltage before any change in the digital input.
This means, if operating frequency is FO, then FO < 1/T.
Figure 10.14
10.3.5  Temperature Sensitivity
The analog output voltage for any ﬁ xed digital input varies with temperature. This is 
due to the temperature sensitiveness of various active and passive components like reference 
voltage source, resistors, diodes, transistors, OP AMPs, etc. The temperature sensitivity is 
deﬁ ned by the change in output voltage from its expected value in respect to temperature 
and is speciﬁ ed in terms of ± ppm/°C.
10.4  AN EXAMPLE OF A D/A CONVERTER
To understand the speciﬁ cation and application of a D/A converter, a typical commercially 
available D/A converter IC DAC 80 is being discussed here. The functional block diagram of 
this D/A converter IC  is shown in Figure 10.15. It is a 12-bit D/A converter available in a 
24-pin DIP package. It consists of matched bipolar switches, a precision resistor network, a 
low-drift high-stability voltage reference network with optional output ampliﬁ er. The options 
are available for 12-bit complementary binary (CBI) or three-digit BCD (complementary coded 
decimal—CCD) input codes, as well as the current or voltage output modes. The important 
performance characteristics are described below.
Most of the pins of the D/A converter are used in two options—voltage model and 
current model. The pins marked with dual functions have the ﬁ rst function for the voltage 
model and the second function for the current model.  The table in Figure 10.16 describes 
the different input modes of operation of the D/A converter and the table in Figure 10.17 
gives the various connections to be made to obtain different full-scale ranges (FSR).
The DAC 80 accepts complementary digital input codes in either binary (CBI) or decimal 
(CCD) format. The CBI code may be any one of these codes—complementary straight binary 
(CSB), complementary offset binary (COB), or complementary 2’s complement. The 12-bit 
digital input is connected to pins B1 to B12, where B1 is MSB and B12 is LSB.
LSB
½  LSB
Analog
Output
Final
Value
Initial
Value
Tim e
T = Settling tim e

358
DIGITAL PRINCIPLES AND LOGIC DESIGN
Resolution 
: 
12 bits (binary) or 3 digits BCD
Linearity error 
: 
± 0.12 % (maximum)
Maximum gain drift 
: 
± 30 ppm/ 0C
Power dissipation  
: 
925 mW (maximum)
Maximum conversion time  
: 
5 µs (voltage output)
(settling time to ± 0.01% of full scale range) 
 
1 µs (current output)
Digital input format  
: 
12 bit CBI or 3 digit CCD
Analog output voltage ranges 
: 
± 2.5 V,  ± 5 V, ± 10 V, 0 to +5 V, 
 
 
0 to +10 V (CBI), or 0 to +10 V (CCD)
Output current  
: 
± 5 mA (minimum)
Output impeadance (DC) 
: 
0.05 Ω
Analog output current ranges 
: 
± 1 mA, 0 to –2 mA (CBI)
 
 
0 to –2 mA (CCD)
Output impeadance 
: 
3.2 KΩ (bipolar) or 6.6 KΩ (unipolar)
Figure 10.15
Digital input 
Analog output 
Format 
Code 
Complementary 
Complementary 
Complementary 
Complementary
 
 
straight binary 
offset binary 
2’s complement 
coded decimal
 
 
(CSB) 
(COB) 
(CTC) 
(CCD)
Binary 000000000000 
+ Full scale 
+ Full scale 
1 LSB 
–
 
011111111111 
+ ½  Full scale 
Zero 
– Full scale 
–
 
100000000000 
Mid scale-1 LSB 
– 1LSB 
+ Full scale 
–
 
111111111111 
 
– Full scale 
Zero 
–
BCD 
011001100110 
      – 
    – 
    – 
+ Full scale
 
111111111111 
      – 
    – 
    – 
Zero
Figure 10.16
12-BIT
Resistor
ladder
network
and
current
switches
5K
6.3K
5K
1
12
2
11
3
10
4
9
5
8
6
7
24
23
22
14
REF
Control
circuit
21
15
16
17
18
19
20
B 2
B 3
B 4
B 9
B 5
B 8
B 6
B 7
13
B 1
6.3 Vref OUT           
Gain adjust                  
Com m on                        
+Vs(+15 V)                     
Sum m ing junction/scaling network 
20 V Range/scaling network        
10 V Range/scaling network        
Bipolar offset               
REF Input                      
Vout/Iout                      
– Vs(–15 V)
Logic supply(+5 V)             
B
       
12
 B
        
10
B
      
11
+

A/D AND D/A CONVERSION 359
Output range 
Digital input codes 
Connect pin 
Connect pin  
Connect pin 1
 
 
 15 to pin 
17 to pin 
19 to pin
± 10 V 
COB or CTC 
19 
20 
15 
± 5 V 
COB or CTC 
18 
20 
NC 
± 2.5 V 
COB or CTC 
18 
20 
20 
0 to +10 V 
CSB 
18 
21 
NC 
0 to +5 V 
CSB 
18 
21 
20 
0 to +10 V  
CCD 
19 
NC 
15
Figure 10.17
10.4.1   Calibration
Few external components are required for proper operation of the D/A converter and 
its offset and gain adjustment. This is demonstrated in Figure 10.18.
Figure 10.18
Offset Adjustment. Some external components are added as in Figure 10.18, to achieve 
the proper offset voltage. For unipolar operation, the digital code that should produce zero 
output voltage is applied and adjusts the offset potentiometer to produce zero output. For 
bipolar output conﬁ guration, digital input is applied in such a way that maximum negative 
output is produced and the offset potentiometer is also adjusted.
Gain Adjustment. Gain potentiometer, as indicated in Figure 10.18, is adjusted for 
maximum positive output of full-scale voltage after applying the digital input code that 
should produce maximum output.
The gain and offset adjustments for unipolar and bipolar modes of a D/A converter are 
shown in Figures 10.19(a) and 10.19(b).
0.01uF
100M
39M
1uF
1uF
+Vs
–Vs
– Vs
+VL
+Vs
10K to   
100K
Gain Adj.
10K to    
100K
Offset Adj.
12-BIT
Resistor
ladder
network
and
current
switches
5K
6.3K
5K
1
12
2
11
3
10
4
9
5
8
6
7
24
23
22
14
REF
Control
circuit
21
15
16
17
18
19
20
B2
B3
B4
B9
B5
B8
B6
B7
13
B1
B
       
12
 B
        
10
B
      
11
+
1uF

360
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 10.19(a)
Figure 10.19(b)
10.5  ANALOG-TO-DIGITAL CONVERTERS
An analog-to-digital converter, or A/D converter, is the reverse system of a D/A converter, 
which converts an analog signal to its digital form. In an analog-to-digital converter, the 
input analog voltage may have any value in a range and it will produce the digital output 
of 2N number of discrete values for an N-bit converter. Therefore, the whole range of analog 
voltage is required to be represented suitably in 2N intervals, and each of the intervals 
corresponds to a digital output.
Let us consider that an analog voltage range of 0 to V is represented by 3-bits digital 
output. Since a 3-bit digital system can generate 23 = 8 different digital outputs, the full 
analog range will be divided into 8 intervals, and each interval of voltage of the size of 
V/8 is assigned unique digital value. This process is called quantization. The interval of 
analog voltage and their corresponding digital representations are tabulated in Figure 10.20. 
Range of Gain adj.
Gain adjustm ent varies
within these lim its
Full-Scale
Range
Range of
Offset adj.
All bits = 1
All bits = 0
Range of
Gain adjustm ent
Gain adjustm ent
varies within these lim its
+ Full Scale
Range of
Offset adj.
All bits = 1
All bits = 0
– Full scale

A/D AND D/A CONVERSION 361
It may be observed from the ﬁ gure that a complete voltage interval is represented by a 
digital value, irrespective of any voltage value within the interval. Therefore, there involves 
always some error while converting any analog voltage interval to its digital value, which 
is referred to as quantization error.
Figure 10.20
In Figure 10.20, the voltage interval 0 to 1/8 V is assigned to the digital value 000, 
voltage interval 1/8 V to 2/8 V is assigned to digital value 001, and so on. Also, it may be 
noted from the ﬁ gure that the maximum quantization error is E = 1/8 V. This quantization 
error may be reduced if the analog voltage interval limits are considered a different way. Let 
us choose the size of voltage interval as 1/7 V, except the top and bottom intervals which are 
1/14 V. The interval limits are at the middle of the voltage corresponding to the digital 
values shown in Figure 10.21.
Figure 10.21
Note that the quantization error in this case is 1/14 V and is equal to one half of 
the size of voltage interval or the quantization interval. This is less when compared to the 
earlier case in Figure 10.20. In practice, the quantization error is speciﬁ ed in terms of LSB. 
According to Figure 10.21, the maximum quantization error is ± LSB.
Analog voltage
Equivalent digital value
V
7/8 V
6/8 V
5/8 V
4/8 V
3/8 V
2/8 V
1/8 V
0
111
110
101
100
011
010
001
000
Quantization Error E = 1/8 V
Analog voltage
Digital value
Equivalent analog output voltage
V
V
6/7 V
5/7 V
4/7 V
3/7 V
2/7 V
1/7 V
0
13/14 V
11/14 V
9/14 V
7/14 V
5/14 V
3/14 V
1/14 V
0
111
110
101
100
011
010
001
000
Size of voltage interval
Quantization error

362
DIGITAL PRINCIPLES AND LOGIC DESIGN
Example 10.4. An analog voltage of the range of –V to +V is required to be converted into 
3-bit 2’s complement digital format. The digital value for 0 V should be 000 and the maximum 
quantization error should not exceed ± LSB. Determine the quqntization interval.
Solution. If the quantization interval is denoted as S, then the digital value 000 should 
be assigned to the analog voltage interval 0V ± S/2. This is illustrated in Figure 10.22 along 
with the 2’s complement representation corresponding to the analog voltage levels. Since 
in 2’s complement representation, there is  one more negative number than the positive 
number, the full analog voltage range from –V to +V is divided into seven intervals, each 
of size 2V/7, and one digital value is assigned to each interval. Therefore, the quntization 
interval is S = 2V/7. The extra digital value 100 may be assigned to represent the interval 
–V to –9/7 V.
Figure 10.22
Some of the commonly used A/D converter techniques are discussed here.
10.5.1  Parallel Comparator A/D Converter
The schematic diagram of a 3-bit parallel-comparator type A/D converter is shown in 
Figure 10.23. Va is the analog voltage that is converted to digital form. The corresponding 
full-scale voltage is V, and different reference voltage levels V1 to V7 have been generated 
with the help of a resistor network from the full-scale voltage V. The analog voltage Va is 
simultaneously compared by seven comparators with reference voltage levels V1 to V7.  Each 
of the outputs of the comparators is digital in nature and has only two levels. The seven 
outputs of the comparators are stored in latches. The seven output latches are converted to 
3-bit binary format with the use of a decoder. The comparator outputs and corresponding 
digital output for each interval of analog voltage are given in the table in Figure 10.24.
The concept and principle of parallel comparator A/D conversion is the simplest as well 
as the fastest. Digital output with any number of bit system for an A/D converter can be 
realized by this simple concept of operation. However, as the number of bits for digital output 
increases, the number of comparators requirement increases. Here lies the main disadvantage 
of this type of A/D converter, because the number of comparators increases exponentially,  as for
N-bit A/D converters the number of comparators required is 2N-1. Also, this increases the 
number of latches and complications of the decoder circuit.
Analog voltage
Equivalent digital value
+V
+ 5/7 V
+ 3/7 V
+1/7 V
–1/7 V
S = 2V/7
–3/7 V
–5/7 V
– V
–9/7 V
011
010
001
000
111
110
101
100
0
S/2

A/D AND D/A CONVERSION 363
Figure 10.23
Analog Input 
Comparator Outputs 
Digital Output
 
Va 
C7 
C6 
C5 
C4 
C3 
C2 
C1 
D2 
D1 
D0
0< Va< V1 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0
V1< Va< V2 
0 
0 
0 
0 
0 
0 
1 
0 
0 
1
V2< Va< V3 
0 
0 
0 
0 
0 
1 
1 
0 
1 
0
V3< Va< V4 
0 
0 
0 
0 
1 
1 
1 
0 
1 
1
V4< Va< V5 
0 
0 
0 
1 
1 
1 
1 
1 
0 
0
V5< Va< V6 
0 
0 
1 
1 
1 
1 
1 
1 
0 
1
V6< Va< V7 
0 
1 
1 
1 
1 
1 
1 
1 
1 
0
V7< Va< V 
1 
1 
1 
1 
1 
1 
1 
1 
1 
1
Figure 10.24
10.5.2  Successive Approximation A/D Converter
The essential elements of a successive approximation type A/D converter are a D/A 
converter and comparator. When any unknown analog voltage Va is applied for A/D conversion, 
ﬁ rst it is compared with the analog voltage generated from the internal D/A converter, which 
is equivalent to ½ of the full-scale range. If the unknown voltage Va is higher than ½ the 
full-scale range, then it is compared with ¾ of full-scale voltage generated from the internal 
R/2
Va
Analog
voltage
Digital
output
R
R
R
R
R
R
R/2
V
+
+
+
+
+
+
+
L
A
T
C
H
E
S
D
E
C
O
D
E
R
C 7
C 6
C 5
C 4
C 3
C 2
C 1
D 2
D 1
D 0
V  = 13/14V
7
V  = 11/14V
6
V  = 9/14V
5
V  = 7/14V
4
V  = 5/14V
3
V  = 3/14V
2
V  = 1/14V
1

364
DIGITAL PRINCIPLES AND LOGIC DESIGN
D/A converter, and if the analog voltage is less than the 1/2 full-scale voltage, then it will be 
compared with ¼  the full-scale voltage. Again, the analog voltage Va will be compared with 
1/8 the full scale if it is less than ¼   the full scale, or with 3/8 the full scale if it is higher 
than ¼  the ful scale, or with 5/8 the full scale if it is lower than ¾  the full scale, or with 
7/8 the full scale if it is higher than ¾  the full-scale voltage. For an N-bit A/D converter, 
this comparison process is continued up to the lowest voltage segment of 1/2N the full-
scale range. The digital output is considered at the end of the comparison process and is 
determined by the last set input of a D/A converter. Since the digital output is determined 
by successive comparison technique, the process is referred to as successive approximation. 
The comparison process of  a 3-bit successive approximation A/D converter is illustrated by 
the ﬂ ow chart in Figure 10.25.  An offset voltage is also introduced for calibration.
Vr = Reference analog voltage generated from a D/A converter
Vd = Digital output
Figure 10.25
Figure 10.26
V >V
= 100
a
r
V
= 000
d
V >V
= 001
a
r
V >V
= 010
a
r
V >V
= 110
a
r
V >V
= 011
a
r
V >V
= 101
a
r
V >V
= 111
a
r
V
= 001
d
V
= 010
d
V
= 011
d
V
= 100
d
V
= 101
d
V
= 110
d
Vd
= 111
No
No
No
No
No
Yes
Yes
Yes
Yes
Yes
No
Yes
No
Yes
D igital
Output
Analog Input
C lock
Program m er
D /A converter
Va
Vr
+
V
V o
Offest voltage

A/D AND D/A CONVERSION 365
The schematic diagram of successive approximation type A/D converter is shown in Figure 
10.26. In addition to the D/A converter and comparator, programmer and clock are also included 
to synchronize and monitor the comparison process. The programmer generated the digital 
reference which is converted to analog voltage and compared with the input unknown analog 
voltage. The comparator output sets or resets to generate the next digital data that is to be 
compared with the synchronization of the clock pulse. To start conversion, the programmer 
sets the MSB to 1 and all other bits to 0. If input analog voltage Va is higher than Vr which 
is the analog equivalent of digital data set by the programmer, then comparator output is 
high, which sets next lower MSB to 1. On the other hand, if Va<Vr, then comparator output 
is low and it reset MSB to 0 and set next lower MSB to 1. Thus, a 1 is tried in each of the 
D/A converters until the binary equivalent of analog input voltage is obtained.
Note that, unlike the parallel comparator A/D converter, the successive approximation 
type converter employs only one comparator, and associated hardware is much less. However, 
in successive approximation technique, the input analog voltage is compared N times for an 
N-bit A/D converter and N number of clock pulses are required to obtain the desired digital 
output. Hence it is slower than the parallel comparator type, but faster than other types of 
A/D converters and it is also very accurate. Therefore, it is very popular in practice.
10.5.3   Counting A/D Converter
The concept of a counting A/D converter is very similar to a successive approximation 
type A/D converter. The basic difference is that an up-counter is employed at counting type 
A/D converter in place of a programmer that is used in successive approximation type. The schematic 
diagram of a counting A/D converter is shown in Figure 10.27. The comparator output and clock are 
ANDed by an AND gate and applied to the clear input of the UP counter. The converter converts 
the counter output to analog voltage. To start the conversion, the counter is at the reset position, 
i.e, all the counter output bits are 0. So, D/A converter output is 0 and comparator output Vo is 
high because of the application of unknown analog input voltage. Therefore, clock is enabled and 
the counter starts counting upward. Since the number of clock pulses counted increases linearly 
with time, the D/A converter output voltage Vr increases, as shown in Figure 10.28. The counting 
process will stop when D/A converter output Vr is higher than analog input voltage Va (Vr>Va),
and comparator output Vo is low to disable the AND gate. Since no clock pulse is now available, 
the counter will stop counting and at this instant digital output is available. Offset voltage may 
be applied at the input of the comparator for calibration purpose.
Figure 10.27
Analog Input
C lock
u p - counter
D /A  converter
Va
Vr
+
V
Vo
Digital
Output
Offset Voltage

366
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 10.28
It may be noted that the conversion time for a counting A/D converter depends on 
counting the number of clock pulses. Therefore, the maximum conversion time for an N-bit 
converter is the time lapsed by 2N number of clock pulses. Hence this type of A/D converter 
is slower than the previous two types of A/D converters.
10.5.4   Dual-Slope A/D Converter
A dual-slope A/D converter is one of the most commonly used types of converter. The 
schematic diagram of a dual-slope A/D converter is illustrated in Figure 10.29. It consists 
of the following major functional blocks.
 
1. An integrator.
 
2. A comparator.
 
3. A binary counter.
 
4. A switch driver.
Figure 10.29
1
0
2
3
4
5
6
7
8
9
10
Num ber of clock pulses
Analog
Voltage
V a
Va
–Vr
S2
Com parator
R
C
Integrator
N-bit binary output
B N -1
Vo
Clock
pulses
V c
+
+
N-bit
Binary Ck
Counter
Q
Flip-flop
Ck
B B
1
0
S 1

A/D AND D/A CONVERSION 367
Figure 10.30
The principle of operation can be understood with the help of the timing diagram in 
Figure 10.30. Let us consider, the conversion process starts at time t = 0 with the switch 
S1  connected to analog input voltage Va and the N-bit counter is at cleared state, i.e, its 
output is all 0s. Analog voltage is passed through an integrator circuit with time constant 
ζ = RC. The integrator output 
 
 
 
 
  
 
(10.26)
As Vo is negative, this will make the comparator output Vc HIGH, and enable the clock 
pulses to reach the clock input (Ck) of the N-bit binary counter. The counter will count from 
00…00 to 11..11 when 2N–1 clock pulses are applied. At the application of 2Nth clock pulse at 
time T1, the counter is cleared to all 0s output setting the ﬂ ip-ﬂ op output Q to 1. Now the 
switch S1 will connect reference voltage –Vr to the integrator. The integrator output Vo starts to 
increase in a positive direction and at time instant T2 it crosses zero voltage. The comparator 
output Vc remains HIGH up to time T2 and becomes LOW after T2. The counter will continue 
to count up to the time T2, as comparator HIGH output enables the clock pulses to reach the 
counter clock input and thereafter the counter stops counting when Vc is low to disable the 
AND gate to prevent the clock pulses. The integrator output Vo and comparator output Vc
behaviors are shown in Figure 10.30. Now, from the following derivation, it can be seen that 
the last counter reading where it stopped is directly proportional to the analog voltage.
From Equation 10.26, we obtain Vo = –(Va/ζ)t, while at negative slope. So at time T1
 
 
 
Vo = –(Va/ζ)T1.  
(10.27)
When a switch is connected to reference voltage –Vr, the voltage expression of Vo can 
be written as 
 
 
 
Vo = –(Va/ζ)T1 + (Vr/ζ)(t – T1). 
(10.28)
At time t = T2, Vo = 0, as it reaches zero voltage, from Equation 10.28, we derive
 
 
 
0 = –(Va/ζ)T1 + (Vr/ζ)(T2 – T1).
Or, T2 – T1 = (Va/Vr) T1.  
 
(10.29)
0
T 1
T2
t
0
Vc
–(V / )t
a ζ
–(V / )t + (V / )(t–T )
a
r
1
ζ
ζ
0
Vo
t
t
V
V
V
o = −
= −
1
0
/
(
/ )
ζ
ζ
a
a
t
dt
t.
∫

368
DIGITAL PRINCIPLES AND LOGIC DESIGN
Now, if we assume that the duration of the clock pulse is Tc, then T1 = 2N. Tc, as within 
the time T1, the counter counted 2N number of clock pulses. Again, if we assume that the 
counter stopped after nth count at time instant T2, then T2 – T1 = n.Tc, as the counter was 
reset at time instant T1. So from Equation 10.28,
 
 
T2 – T1 = n.Tc = (Va/Vr) T1 = (Va/Vr) 2N.Tc.
Or, 
n = (Va/Vr) 2N. 
(10.30)
From Equation 10.30, we observe that the count recorded at the counter is proportional 
to the input analog voltage Va.
This type of A/D converter has very good conversion accuracy and is of low cost. This is 
often used in a digital voltmeter. However, the disadvantage of the dual-slope A/D converter 
is its slow speed.
10.5.5    A/D Converter Using Voltage-to-Frequency Conversion
An analog voltage can be converted into digital form by generating pulses whose 
frequency is proportional to the analog voltage. These pulses are then counted by a counter 
for a ﬁ xed time duration and the reading of the counter will be proportional to the frequency 
of the pulses and hence, to the analog voltage.
Figure 10.31 Voltage-to-frequency converter.
The concept of an A/D converter using a voltage-to-frequency converter is illustrated by 
the schematic diagram in Figure 10.31. The voltage-to-frequency converter section consists 
of an integrator, a comparator, and a monostable multivibrator. The analog input voltage 
is applied to the integrator whose output is applied to the inverting input terminal of the 
comparator. A reference voltage Vr is applied through the noninverting input terminal of 
the comparator. The comparator output activates a monostable multivibrator to produce a 
short pulse to control the active switch S of the integrator. The comparator will generate 
a pulse train. The operation can be explained with the help of a timing diagram as shown 
in Figure 10.32.
When the analog input is applied, at t = 0, integrator output starts decreasing with 
slope of time constant ζ = RC. At this instant integrator output Vo will be the function of 
analog input of the following relation.
 
 
 
  
(10.31)
o
0
V
1/
(
/ )
t
a
a
V
dt
V
= −
ζ
= −
ζ
∫
t

A/D AND D/A CONVERSION 369
The integrator output will continue to decrease and the comparator output is LOW. 
At time instant t = T, the integrator output will cross the reference voltage –Vr, and 
the comparator output will be HIGH. The high output of the comparator activates the 
monostable multivibrator to produce a pulse to close the switch S for discharging the 
integrator capacitor. Monostable pulse width is very small compared to T, but sufﬁ cient to 
discharge the capacitor completely to make Vo = 0. Let the monostable pulse width be Td,
so the switch S is closed for time Td and again Vo starts decreasing when S is open. Thus, 
a pulse train will be produced at comparator output Vc, as shown in Figure 10.32. Now we 
can write from Equation 10.31 
Figure 10.32
 
 
 
Vo = (Va/ζ)T = Vr.
Or, 
 
T = (Vr/Va) ζ. 
(10.32)
If monostable pulse-width Td is too small, such that T >> Td, then comparator output 
frequency F can be derived as 
 
 
 
F = 1/(T + Td) ≈ 1/T = (1/ζ) (Va/Vr) 
[from equation 10.32]. (10.33)
From Equation 10.33, you may notice that comparator output signal frequency F is 
proportional to the analog input voltage Va.
Comparator output is now applied to the clock input Ck of an N-bit binary counter 
through an AND gate. An enable pulse of ﬁ xed duration TC is applied to the other input of 
the AND gate. Therefore, clock pulses are available to the binary counter for a time duration 
of TC and the counter will count the number of pulses for that duration. If the number of 
pulses recorded at the counter is n, then TC = n.T.
 
So, 
 
TC = n/F.
 
Or, 
 
n = F. TC.
 
Or, 
 
n =  (1/ζ) (Va/Vr). TC.  
 
(10.34)
T
T
Td
t
t
t
0
Vc
VE N
T  = nT
C
–Vr
0
Vo

370
DIGITAL PRINCIPLES AND LOGIC DESIGN
From Expression 10.34, we can observe that the number of pulses counted in the counter 
is proportional to the analog input voltage and thus we obtain the equivalent digital form 
of the analog voltage. In this system, it is assumed the analog input voltage is constant 
over the time duration of TC.
10.5.6    A/D Converter using Voltage-to-Time Conversion
The concept of an A/D converter using voltage-to-time conversion is very similar to the 
A/D converter with voltage-to-frequency conversion, as the digital output for both types of 
converters is derived by counting the number of pulses that is proportional to the analog 
input voltage. The difference is that an A/D converter using voltage-to-frequency conversion 
is based on the counting of pulses of variable frequency for a ﬁ xed time duration, whereas 
the A/D converter using voltage-to-time conversion counts the pulses of ﬁ xed frequency but of 
variable time. The schematic diagram of the A/D converter using voltage-to-time conversion 
is illustrated by Figure 10.33. 
As shown in Figure 10.33, in this type of converter, a negative voltage reference 
–Vr is integrated ﬁ rst by an integrator circuit with time constant ζ = RC. At time t = 0, VEN
is LOW and switch S at integrator  is open. The opening and closing of switch S is controlled 
by an ENABLE pulse control circuit. The output of the integrator will start increasing and 
it is compared with the analog input voltage. Initially, when analog voltage Va is higher 
than the reference voltage (i.e., Va > Vr), then comparator output Vc is HIGH. 
Figure 10.33
The comparator output is applied to one of the inputs of a 3-input AND gate, where 
the other two inputs of the AND gate complement VEN and clock pulses time period TC.
Therefore the AND gate is enabled when comparator output is HIGH and VEN is LOW, and 
clock pulses will reach the binary counter for count operation.
When integrator output will reach the analog input Va,  at t = T,  the comparator 
output is LOW and the AND gate is disabled to stop counting at the counter. Now the digital 
output from the counter is proportional to the analog input and may be considered as the 
digital conversion of analog voltage. This can be proved by the following derivation. 
For  0 < t < T, 
  
 
(10.35)
At t = T,  comparator output equals to Va, so Va = (Vr /ζ) T. 
(10.36)
y
r
a
ni
B
r
e
t
n
u
o
c
Com parator
Integrator
Ck
N-bit
Binary
output
–Vr
V
Analog voltage
a
Clock
pulses
Vo
Vc
Enable
Pulse
Control
R
C
S
VE N
+
+
V
V
V
o = −
= −
1
0
/
(
/ )
ζ
ζ
r
r
t
dt
t.
∫

A/D AND D/A CONVERSION 371
Now, if the counter records the counting of n number of pulses and each pulse time period 
is TC, then  
        T = n. TC. 
 
 
 
 
 
         (10.37)
Therefore, 
Va = (Vr /ζ)T = Va = (Vr /ζ) n.TC.
Or, 
 
 
n = (ζ/TC) (Va/Vr). 
(10.38)
Equation 10.38 indicates that counter reading is proportional to the analog input voltage Va.
Though the digital output is obtained from the counter, the integrator output will 
continue to increase till VEN  is LOW. At t = T1, switch S is closed as VEN is HIGH and 
integrator capacitor discharges. At t = T2, when the integrator capacitor is fully discharged, 
VEN is made LOW to enable a fresh cycle of conversion operation.
Figure 10.34
10.6  SPECIFICATION OF AN A/D CONVERTER
The A/D converters are usually speciﬁ ed by the following characteristics.
 
1. Range of input voltage. This is the factor that speciﬁ es the minimum and maximum 
analog input voltage that can be accepted by an A/D converter.
 
2. Input impedance. This is an important design criteria that limits the maximum input 
current to the A/D converter without deteriorating its performance or damage.
 
3. Accuracy. It is the error involved in the conversion process and is represented in %.
 
4. Conversion time. This characteristics specifies the maximum time required for 
the conversion process and is very critical while interfacing with other devices 
and synchronization with time. The output is considered only after the end of 
conversion.
 
5. Format of digital output. Digital output may be of various formats, like unipolar, bipolar, 
parallel, serial, etc. The information is essential while designing and interfacing with 
other networks.
Vo
Va
Vc
VE N
T1
T2
t
t
t
1
0
T
0
1

372
DIGITAL PRINCIPLES AND LOGIC DESIGN
10.7  AN EXAMPLE OF AN A/D CONVERTER IC
A/D converters are commercially available in monolithic IC packages. One of the A/D converters, 
ADC 80, is discussed here. It is a 12-bit successive approximation type A/D converter available 
in 32-pin DIP. The important performance characteristics are described below.
Linearity error 
: 
± 0.012 %
Maximum gain temperature coefﬁ cient 
: 
30 ppm/°C
Power dissipation  
: 
800 mW
Maximum conversion time 
: 
25 µs
Digital output format 
: 
Unipolar and bipolar, Parallel and serial
Output drive 
: 
2 TTL loads
Analog voltage range 
: 
± 2.5 V, ± 5 V,  ± 10 V (bipolar) or
 
 
0 to 5 V, 0 to 10 V (unipolar)
The functional block diagram of A/D converter ADC 80 is shown in Figure 10.35. It 
consists of a successive approximation register (SAR), 12-bit D/A converter (DAC), clock and 
control circuit, a reference generator, and comparator.
Figure 10.35
10.7.1  Operation
After receiving the convert start command, the A/D converter converts the voltage 
applied at its analog input terminal to an equivalent 12-bit binary number. How to connect 
the analog input will be discussed later in this chapter. The successive approximation register 
(SAR) generates a 12-bit binary number and it compared with the input analog voltage. 
During the conversion process, the status ﬂ ag remains set. When the conversion is over, 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
12-BIT
DAC
Reference
Comparator
B1
B2
B3
B4
B5
B (LSB)
0
B6
B7
B 8
B9
B10
B
(M SB)
11
Serial out
B
'(M SB)
11
–15V or –12V
R ef out(6.3V)
Digital GND
C lock out
+5V Digital supply
+5V Analog supply
Comparator in
Status
Bipolar offset out
Short cycle
C lock inhibit
10V span in
20V span in
External clock in
Analog GND
Convert start
Gain adj
+15V or +12V
Clock
and
control
circuit
T
I
B
-
2
1
R
A
S
+

A/D AND D/A CONVERSION 373
the status ﬂ ag is reset and parallel output data becomes available. In-built parallel-to-serial 
register is provided in this A/D converter to make serial data available at output.
10.7.2  Analog input
The analog input is scaled as close to the maximum input signal range as possible in 
order to achieve the maximum resolution of the A/D converter. Different input signal ranges 
can be programmed by selecting appropriate external connections of input pins and span 
inputs as described in the table in Figure 10.36.
Input signal 
Connect pin 12  
Connect pin 14 
Connect input
 
Ranges 
To pin 
To 
Signal to pin
        
± 10 V 
11 
Input signal 
14 
 
± 5  V 
11 
Open 
13 
 
± 2.5 V 
11 
Pin 11 
13 
 
0 to +5 V 
15 
Pin 11 
13 
 
0 to +10 V 
15 
Open 
13 
Figure 10.36
The analog ground and digital ground must be connected together at one point, usually 
at the system’s power supply ground.
10.7.3  Digital Output 
The parallel digital data is available at pins B11 (MSB) to B0 (LSB). For unipolar input 
ranges, the output is in the form of complementary straight binary code (CSB), whereas for 
bipolar input ranges the output is either in complementary offset binary (COB) format or 
in complementary 2’s complement binary (CTC) format. For complementary offset binary 
(COB) format, pin 6 (B11) is used as MSB, whereas for complementary 2’s complement binary 
(CTC) format pin 8 (B11') is used as MSB.
Serial data is available in CSB format for unipolar input ranges and in COB form for 
bipolar input ranges. The ﬁ rst bit at serial output is MSB and LSB comes out last.
The A/D converter can be used for 12-bit, 10-bit, or 8-bit resolution by connecting the 
short cycle terminal (pin 21) to pin 9, pin 28, or pin 30 respectively. The conversion time 
is reduced to 21 µs and 17 µs for 10-bit and 8-bit operations, respectively.
10.7.4  Calibration
For calibration of the device, zero adjustment and gain adjustment are performed by 
employing external potentiometers as shown in Figure 10.37. To prevent interaction of 
these two adjustments, zero is always adjusted ﬁ rst and then gain. Zero is adjusted with 
the analog input voltage near the most negative end of the analog voltage range (0 is for 
unipolar and full scale for bipolar input ranges). Gain is adjusted with the analog input 
voltage near the most positive end of the analog range. The analog input voltages to be 
used for these adjustments and the corresponding digital outputs are given in the table
in Figure 10.38, for two ranges. Similarly, the corresponding analog input voltages can be 
determined for other ranges, also.

374
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 10.37
 Input signal 
Set analog input 
Adjust zero for 
Adjust gain for
 
range 
 voltage to 
digital output 
digital output
 0 to +10 V  
+1 LSB = 0.0024 V 
111111111110 
–
  
+FSR – 2LSB = 9.9952 V 
– 
000000000001 
  
+5 V (Digital output 
  
= 011111111111) 
 
 –10 V to +10 V 
-9.9952 V  
111111111110 
–
  
+9.9952 V  
– 
000000000001
  
0.0 (Digital output
  
= 011111111111)
Figure 10.38
10.8  CONCLUDING REMARKS
Some of the commonly used techniques for digital-to-analog and analog-to-digital 
conversions are discussed in this chapter. The techniques are explained here with 
functional blocks for design concepts only. In actual practice, the circuits are more 
complex in nature.
Among the A/D converters discussed here, the fastest is the parallel comparator type. 
Therefore, this type of converter is the best choice where maximum speed of operation is 
required. The speed of the successive approximation type A/D converter is less than that of the 
parallel comparator type. But this requires less hardware and hence it is quite popular.
One of the most popular A/D converters is the dual-slope type and is widely used in 
instruments, such as digital voltmeters or digital multimeters, where conversion speed is 
not important.
The output voltage levels of A/D converters are often made compatible with different 
logic families such as TTL, CMOS, ECL, etc.
REVIEW QUESTIONS
10.1 What are D/A converters and A/D converters and what are their uses?
10.2 Refer to Figure 10.3. For an 8-bit weighted resistor D/A converter, what is the maximum resistor 
value if the value of the resistor for MSB is 2.2K ?
+15V
Adjust
10K to 100K
Zero
+15V
Gain
10K to 100K
Adjust
–15V
–15V
1.8M
10M
11
16
AD
AD C 80

A/D AND D/A CONVERSION 375
10.3 For question 10.2, what should the value of Rf be to make a full-scale analog output of 10V if 
V(1) = –5 V?
10.4 Verify equation 10.9 for bits b2, b1, and b0.
10.5 Explain the terms linearity, resolution, and accuracy.
10.6 What is the conversion time of a D/A converter?
10.7 Explain the following codes and give examples using 4 bits. 
 
 (a) CSB,  (b) COB,  
(c) CTC,  
(d) CCD
10.8 What is quantization and what is quantization error?
10.9 What is the maximum quantization error for an 8-bit A/D converter if a full-scale analog input 
is 10 V?
10.10 An A/D converter has the conversion time of 20 µs. Find whether this A/D converter is suitable 
if the analog input is sampled at 100 kHz.
10.11 An 8-bit D/A converter provides an analog output that has a maximum value of 10 V. The 
output may have an error of ∆V due to drift in component values, temperature, etc. How large 
can ∆V be before the least signiﬁ cant bit would no longer be signiﬁ cant?
10.12 For the circuit diagram in Figure 10.39, ﬁ nd the analog output voltage for each of the digital 
inputs and show that this circuit can be used for converting digital signal in 1’s complement 
format to analog input.
10.13 In the circuit in Figure P.10.1, if the offset switch is removed and the switch S2 is replaced by 
a switch S2' (with its resistor R/4 is replaced by a resistor R/3), verify that the operation of the 
circuit will not change.
Figure P.10.1
10.14 Design a D/A converter circuit similar to the circuit in problem 10.2 for 4-bit input.
10.15 Design a D/A converter circuit similar to the circuit in problem 10.3 for 4-bit input.
10.16 Design a 3-bit parallel comparator A/D converter for 2’s complement format.
10.17 A dual-slope A/D converter has a resolution of 12 bits. If the clock rate is 100 kHz, what is the 
maximum rate at which samples can be converted?
10.18 A D/A converter has a full-scale analog output of 10 V and accepts six binary bits as inputs. 
Find the voltage corresponding to each analog step.
Vo
V(1)
=-1/2V
V(0)
0
0
S 2
S 1
S0
S 4
1
1
1
1
0
0
=1/2V
1/2V
1/2V
R /4
R /2
R
R off = R /7
Rf=R
+
+
+
+
Offset sw itch
+

376
DIGITAL PRINCIPLES AND LOGIC DESIGN
10.19 Find the analog voltage corresponding to the LSB for each of the ranges of 
 
 (a) DAC 80
 
 (b) ADC 80
10.20 How many bits are required at the input of a converter to achieve a resolution of 1mV, if full 
scale is + 5 V ?
10.21 What clock frequency must be used for a 10-bit dual-slope A/D converter if it is capable of 
making at least 7000 conversions per second?
10.22 What is the conversion time of a 12-bit successive approximation type A/D converter using a 1 MHz 
clock?
❑ ❑ ❑

377
11.1  INTRODUCTION
L
ogic gates and memory devices are fabricated as integrated circuits (ICs) because 
the components used, such as resistors, diodes, bipolar junction transistors, and the 
insulated gate or metal-oxide semiconductor ﬁ eld-effect transistors are the integral 
parts of the chip. The various components are interconnected within the chip to form an 
electronic circuit during assembly. The chip is mounted on a metal or plastic package, and 
connections are welded to the external pins to form an IC. The ICs result in an increase 
in reliability and reduction in weight and size.
Small-scale integration (SSI) refers to ICs housing fewer than 10 gates in a single chip. 
Medium-scale integration (MSI) includes 11 to 100 gates, whereas large-scale integration 
(LSI) refers to more than 100 to 5000 gates in a single chip. Very large-scale integration 
(VLSI) devices contain several thousands of gates per chip.
Integrated circuits are classiﬁ ed into two general categories—(a) linear and (b) digital.
Linear integrated circuits are operated with continuous signals and are used to construct 
electronic circuits such as ampliﬁ ers, voltage comparators, voltage regulators, etc. Digital 
circuits are operated with binary signals and are invariably constructed with integrated 
circuits. This chapter describes the basic internal structure of different types of logic families 
and analysis of their operation.
The various logic families can be broadly classiﬁ ed into categories according to the IC 
fabrication process—(a) bipolar and (b) metal oxide semiconductor (MOS). Integrated circuits 
are available in various types of packages as mentioned below.
 (i) Dual-in-Line Package or DIP
 (ii) Leadless Chip Carrier or LCC
 (iii) Plastic Leaded Chip carrier or PLCC
 (iv) Plastic QUAD Flat Package or PQFP
 (v) Pin Grid Array or PGA
According to the internal construction and fabrication process involved in the integrated 
circuits, they are placed in different logic families as follows.
LOGIC FAMILY
11
C h a p t e r

378
DIGITAL PRINCIPLES AND LOGIC DESIGN
RTL 
 
Resistor-transistor logic
DTL  
 
Diode-transistor logic
TTL 
 
Transistor-transistor logic
ECL 
 
Emitter-coupled logic
I2L  
 
Integrated-injection logic
MOS 
 
Metal oxide semiconductor
CMOS 
 
Complementary metal oxide semiconductor
The ﬁ rst two, RTL and DTL logic families have only historical signiﬁ cance, since they 
are seldom used in new designs. RTL was the ﬁ rst commercially available family to have 
been used extensively. It is included here because it represents a useful starting point 
to understand the basic operation of digital gates. A TTL circuit is the modiﬁ cation of a 
DTL and hence, DTL circuits have been gradually replaced by TTL. The operation of TTL 
will be easier to understand after DTL gates are discussed. These families have a large 
number of SSI circuits as well as MSI and LSI circuits. I2L and MOS are mostly used for 
the construction of LSI functions.
The basic circuit in each digital IC logic family is either a NAND or a NOR gate. 
Combinational logic functions and more complex functions are generated using this basic 
circuit, which may be referred to as the primary building block. As an example, an RS latch 
is constructed from two NAND gates or two NOR gates connected back to back. A master-
slave ﬂ ip-ﬂ op is obtained from the interconnection of about ten logic gates. Each of the logic 
families provides numerous types of ICs that perform different types of logic functions. The 
differences in the logic functions available from different logic families are not so much in 
the function that they achieve, but they are different in speciﬁ c characteristics of the basic 
building blocks from which the functions are constructed.
Figure 11.1
NAND and NOR gates are usually deﬁ ned by the Boolean functions in terms of binary 
variables. While analyzing them as electronic circuits, it is more convenient to investigate 
their input-output relationship in terms of two voltage levels—high level (H) and low level 
(L) (refer to section 3.11). Binary variables use the logic values of 1 and 0. When positive 
Inputs
NAND gate
(a) If 
 input is LOW, the output is HIGH.
any
(b) If 
 the inputs are H IGH, the output is LOW.
all
A
L
L
H
H
B
L
H
L
H
Outnputs
F
H
H
H
L
A
F
B
Inputs
NOR gate
(a) If 
 input is HIGH , the output is LOW.
any
(b) If 
 the inputs are LOW, the output is HIGH.
all
A
L
L
H
H
B
L
H
L
H
Outnputs
F
H
L
L
L
A
F
B

LOGIC FAMILY 379
logic is adopted, the high-voltage level is assigned the binary value of logic 1 and the low-
voltage level is a binary 0. From the truth table of a positive logic NAND gate, we deduce 
its behavior in terms of high and low levels as indicated in Figure 11.1. The corresponding 
behavior of the NOR gate is also stated in the same ﬁ gure. These statements must be 
remembered because they will be used during the analysis of all gates in this chapter.
11.2  CHARACTERISTICS OF DIGITAL IC
The various digital logic families are usually evaluated by comparing the characteristics of 
the basic gates of each family. The most important governing parameters or properties of 
various logic families are listed below.
 
1. Propagation delay (speed of operation).
 
2. Power dissipation.
 
3. Fan in.
 
4. Fan out.
 
5. Noise immunity.
 
6. Operating temperature.
 
7. Power supply requirement.
 
8. Current and voltage parameters.
11.2.1  Propagation Delay
Propagation delay is deﬁ ned as the time taken for the output of a logic gate to change 
after the inputs have changed. It is the transition time for the signal to propagate from 
input to output. This factor governs the speed of operation of a logic circuit. 
Figure 11.2
A logic signal always experiences a delay in going through a circuit. Two types of 
propagation delay times are explained by Figure 11.2, which are deﬁ ned as 
 (a) tpLH : It is the propagation delay time for a signal to change from logic LOW (0 state) 
to HIGH (1 state).
 (b) tpHL : It is the propagation delay time for a signal to change from logic HIGH (1 state) 
to LOW (0 state).
The delay times are measured by time lapsed between the 50% voltage levels of the 
input and the output waveforms while making the transition. In general, the two delays tpLH
and tpHL, are not necessarily equal and will vary depending on load conditions. The average 
1
1
0
0
Output
Input
50%
50%
tpH L
tpH L

380
DIGITAL PRINCIPLES AND LOGIC DESIGN
of the two propagation delays (tpLH + tpHL)/2 is called the average delay and this parameter 
is used to rate the circuit. It depends on the switching time of the individual transistors 
or MOSFETs in the circuit.
11.2.2  Power Dissipation
Power dissipation is the measure of the power consumed by logic gates when fully 
driven by all inputs. The average power or the DC power dissipation is the product of DC 
supply voltage and the mean current consumed from that supply.
11.2.3  Fan In
The maximum number of inputs that can be connected to a logic gate without any 
impairment of its normal operation is referred to as fan in. For example, if the maximum of eight 
input loads is connected to a logic gate without any degradation of its normal operation, then 
its fan-in is 8. The parameter determines the functional capabilities of the logic circuit.
11.2.4  Fan Out
Fan out refers to the maximum number of standard loads that the output of the gate 
can drive without any impairment or degradation of its normal operation. A standard load 
is deﬁ ned as the current ﬂ owing in the input of a gate in the same IC family. In a logic 
circuit a logic gate normally drives several other gates and the input current of each of 
the driven gates must be supplied from the driving gate. The driving gate must be capable 
of supplying this current while maintaining the required voltage level. Fan out depends 
on the output impedance of the driving gate and the input impedance of the driven gate. 
Usually the output impedance of a logic gate is made very low, while input impedance is 
made very high, so that a logic gate can drive many logic gates.
11.2.5  Noise Immunity or Noise Margin
The term noise denotes any unwanted signal, such as transients, glitches, hum, etc. 
Noise sometimes causes the change in the input voltage level, if it is too high, and leads 
to unreliable operation. Noise immunity or the noise margin is the limit of noise voltage 
that may appear at the input of the logic gate without any impairment of its proper logic 
operation. The difference between the operating input logic voltage level and the threshold 
voltage is the noise margin of the circuit.
Noise margin is related with the input-output transfer characteristics of a logic gate, which 
in turn depends on loading factors, power supply, operating temperature, fabrication process 
by the manufacturers, etc. These factors affect the signal values and sometimes they change 
the desired voltage levels causing unreliable operation. Considering these affecting factors, 
the input-output transfer characteristics of a logic gate must be kept within the maximum and 
minimum characteristics as speciﬁ ed by the manufacturer, which is shown in Figure 11.3. 
Two circled points of the maximum and minimum transfer characteristics of Figure 
11.3 are of notable interest. From the maximum characteristics, it is considered that any 
input voltage level less than VIL(max) is recognized by the logic gate as low-voltage level 
or logic 0. On the other hand, any input voltage level greater than VIH(min) is recognized 
as high level or logic 1. Regarding the minimum characteristics, the manufacture speciﬁ es 
that low level or logic 0 output voltage does not exceed VOL(max) and  the high level or 
logic 1 output is always greater than VOH(min).

LOGIC FAMILY 381
Hence, two types of noise margins may be derived. The worst-case low-level noise margin 
is VIL(max) – VOL(max) and the worst-case high-level noise margin is VOH(min) – VIH(min).
Figure 11.3
11.2.6  Operating Temperature
All the ICs are semiconductor devices and they are temperature sensitive by nature. 
The operating temperature ranges of an IC vary from 0°C to + 70°C for commercial and 
industrial application, and from –55°C to 125°C for military application.
11.2.7  Power Supply Requirements
The amount of power and supply voltage required for an IC is one of the important 
parameters for its normal operation. They are different for different logic families. The logic 
designer should consider these parameters while choosing the proper power supply.
11.2.8  Current and Voltage Parameters
All the IC manufacturers specify some voltage and current parameters for the input as 
well as for the output that are very important in designing the digital systems. A designer 
must consider these parameters as they directly affect the normal operation of the digital 
system. These are listed below.
High-level input voltage (VIH)[Vin(1)]. It is the minimum voltage level required for a logical 
1 at an input.
Low-level input voltage (VIL)[Vin(0)]. It is the maximum voltage level required for a logical 
0 at an input.
High-level output voltage (VOH)[Vout(1)]. It is the minimum voltage level available for a logical 
1 at an output.
Low-level input voltage (VOL)[Vout(0)]. It is the maximum voltage level available for a logical 
0 at an output.
High-level input current (IIH)[Iin(1)]. It is the current ﬂ ow to an input when high-voltage level 
corresponding to a logical 1 is applied.
Vout
Actual
high-level
output range
Actual
low-level
output range
Allow able low-level
input range
M axim um
characteristics
M inim um
characteristics
V
(m in)
O H
V
(m ax)
O L
V
(m ax)
IL
V
(m in)
IH
Allow able high-level
input rage
Vin

382
DIGITAL PRINCIPLES AND LOGIC DESIGN
Low-level input current (IIL)[Iin(0)]. It is the current ﬂ ow to an input when low-voltage level 
corresponding to a logical 0 is applied.
High-level output current (IOH)[Iout(1)]. It is the current available from the output when the 
output is considered to be of high-voltage level corresponding to a logical 1.
Low-level output current (IOL)[Iout(0)]. It is the current available from the output when the 
output is considered to be of low-voltage level corresponding to a logical 0.
11.3  BIPOLAR TRANSISTOR CHARACTERISTICS
It may not be irrelevant to review the characteristics of a bipolar transistor, which ﬁ nds its 
application to form the internal structure of the logic gates. This section is devoted for this 
purpose. The information will be used for the analysis of basic circuits of ﬁ ve bipolar logic 
families.
A bipolar junction transistor (BJT) is the familiar npn or pnp junction transistor, and 
they are constructed either with germanium or silicon semiconductor material. IC transistors, 
however, are made with silicon. The operation of a bipolar transistor depends upon the ﬂ ow of 
two types of carriers—electrons and holes. In contrast to that, the ﬁ eld effect transistor (FET) 
is said to be unipolar, as its operation depends on the ﬂ ow of only one type of majority carrier 
which may be electrons (n-channel) or holes (p-channel). The ﬁ rst ﬁ ve logic families of the list 
of the previous section—RTL, DTL, TTL, ECL, and I2L use the bipolar transistors. The last 
two logic families of the list—MOS and CMOS employ a type of unipolar transistor called a 
metal-oxide semiconductor ﬁ eld effect transistor, abbreviated MOSFET or MOS in short.
Figure 11.4(a)
Figure 11.4(b) 
Figure 11.4(c)
IB
IE
VO
IC
R C
VC C
V i
RB
0.6
0.7
0.8
V
 (V)
B E
V
/R
C C
C
V
 (V)
C E
I  = 0.2m A
B
0.3
0.4
0.5
0.6
V C C
I
(m A)
B
I
(m A)
C

LOGIC FAMILY 383
The basic data needed for the analysis of digital circuits may be obtained from the typical 
characteristics curves of a common emitter npn silicon transistor, as shown in Figure 11.4. The 
circuit in Figure 11.4(a) consists of two resistors and a transistor, which performs as a logic 
inverter. The current marked IC ﬂ ows through resistor RC and the collector of the transistor. 
Current IB ﬂ ows through resistor RB and the base of the transistor. The emitter is connected 
to the ground and its current IE = IC + IB. The supply voltage is between VCC and the ground. 
The input is between Vi and the ground, and the output is between Vo and the ground.
The normal direction of currents of an npn transistor is indicated by the arrow marks 
in the ﬁ gure. Collector current IC and base current IB are assumed to be positive when 
they ﬂ ow into the transistor and the emitter current IE is positive when it ﬂ ows out of the 
transistor. The symbol VCE stands for the voltage difference from collector to emitter and is 
always positive. VBE denotes the voltage difference across the base to the emitter junction. 
This junction is termed to be forward biased when VBE is positive and termed as negative 
biased when VBE is negative.
The base-emitter characteristics of the npn transistor as biased as in Figure 11.4(a) are 
given in Figure 11.4(b). This is a plot of base current IB with respect to VBE. For a silicon-
type transistor, if the base-emitter voltage is less than 0.6 V, the transistor is said to be 
cut-off and no base current ﬂ ows. When the base-emitter junction is forward-biased with 
a voltage greater than 0.6 V, the transistor conducts and its base current IB starts rising 
very fast with a very small rise of VBE. The voltage VBE across the base to the emitter of a 
conducting transistor seldom exceeds 0.8 V.
Figure 11.4(c) is the graphical representation of collector-emitter characteristics, together 
with the load line. When VBE is less than 0.6 V, the transistor is at cut-off and no base 
current ﬂ ows (IB = 0) and a negligible current ﬂ ows in the collector. The collector-to-emitter 
circuit then behaves like an open circuit. In an active region the collector-to-emitter voltage 
VCE may be anywhere between 0.8 V to VCC. Approximate collector current IC in this region 
can be obtained by the relation IC = hFE.IB, where hFE is a transistor parameter called DC
current gain. It should be noted that the maximum collector current does not depend on 
the IB, but on the external circuit components connected to the collector. This is because 
VCE is always positive and its lowest possible value is 0 V (practically minimum VCE  value 
is 0.2 V for silicon transistor). For example, in the inverter circuit shown in Figure 11.4(a),
the maximum IC obtained is VCC/RC, assuming VCE = 0.
The collector current-to-base-current relationship IC = hFE. IB is valid only when the 
transistor is at active region. The parameter hFE varies widely over the operating range of 
the transistor, but still it is useful to consider as an average value for the sake of analysis of 
transistor characteristics. In a typical operating range, hFE may be of the value of 50, but under 
certain condition it may vary up to the value of 20. It may be observed that the base current 
may be increased to any desirable value, but the collector current is limited by the external 
circuit component, as in this case it is limited to VCC/RC. As a consequence, a situation can be 
reached when hFE.IB is greater than IC. This is the condition when the transistor is said to be 
in saturation region. Thus, the condition for saturation is determined by the relation
 
 
 
 
h
I
I
or
I
I
h
FE. B
CS
B
CS
FE
≥
≥
where ICS is the maximum collector current ﬂ owing during saturation. VCE attains its 
minimum value at saturation to 0.2V.

384
DIGITAL PRINCIPLES AND LOGIC DESIGN
The typical values of basic parameters of the transistor characteristics are listed in the 
table in Figure 11.5, which are useful for the analysis digital circuit. In the cut-off region, VBE
is less than 0.6 V, VCE is considered to be an open circuit and both base current and collector 
current are negligible. In the active region, VBE is about 0.7 V, VCE may vary over a wide 
range, and IC can be calculated as a function of IB. In saturation region VBE hardly changes, 
but VCE drops to 0.2 V and the base current must be large enough to satisfy the relation IB
= IC/hFE. VBE is considered as 0.7 V when the transistor is in active or saturation region.
Operating Region 
VBE (V) 
VCE (V) 
Current Relationship
 
Cut-off 
< 0.6 
Open circuit 
IB = IC = 0 
 
Active 
0.6 to 0.7 
> 0.2 
IC = hFE IB
 
Saturation 
0.7 to 0.8 
0.2 
IB > ICS/hFE
Figure 11.5
The analysis of digital circuits may be performed by following a prescribed procedure. For 
each transistor in the circuit where VBE is less than 0.6 V, it is assumed that the transistor 
is at cut-off region and its collector to emitter is considered to be open circuit. If VBE is 
greater than 0.6 V, the transistor may be in the active region or in saturation region. The 
base current is calculated considering VBE = 0.7 V and the maximum possible value of the 
collector current ICS is calculated as ICS = (VCC – VCE)/RC, assuming VCE = 0.2 V. If the base 
current is large enough to be IB > ICS/hFE, we deduce that the transistor is at saturation 
region. However, if the base current is smaller and the above relationship is not satisﬁ ed, 
The transistor is said to be in the active region and IC  is recalculated using the relationship
IC = hFE.IB.
To demonstrate with an example, let us consider the inverter circuit of Figure 11.4(a)
with the following parameters:
 
RC = 
1K  
VCC = 5 V (voltage supply)
 
RB = 
22K 
H = 5 V (high voltage level)
hFE = 
50  
L = 0.2 V (low voltage level)
If the input voltage Vi = L = 0.2 V, the transistor is at cut-off as VBE < 0.6V. The 
collector-to-emitter circuit behaves like an open circuit and the voltage available at the 
output Vo = H = 5V. 
When the input voltage Vi = H = 5 V, VBE > 0.6 V. Assuming VBE = 0.7V, base current 
is calculated as 
(11.1)
Considering VCE = 0.2 V, the maximum collector current 
(11.2)
Now,  
ICS/hFE  = 4.8 mA/50 = 0.096 mA  
(11.3)
Comparing Equations 11.1 and 11.3, we observe that 0.195 mA > 0.096 mA and hence,
 
 
IB > ICS/hFE.
B E
B
B
V
V
5
0.7
I
0.195 m A.
R 
22K
i −
−
=
=
=
I
V
V
R
5
0.2
1K
4.8 mA.
CS
CC
CE
C
=
−
=
−
=

LOGIC FAMILY 385
Therefore the transistor is at saturation region when Vi is high (H) and output
 
 
Vo = VCE(saturation) = 0.2 V = L.
Thus it is proved that the circuit behaves like an inverter.
It should be noted that the transistor in the inverter circuit above presents the desired 
output at only two of its operating conditions. Output is H, when input is L and transistor 
is at cut-off. On the other hand, output is L when input is H and the transistor is at 
saturation. The active region operation of the transistor is bypassed and hence this type 
of logic operation is referred to as saturated logic. Most of the bipolar logic families adopt 
the saturated logic operation. The procedure just described will be used extensively during 
the analysis of various digital circuits in the following sections.
There are occasions where not only transistors but also diodes are used in digital 
circuits. An IC diode is usually constructed from a transistor with its collector connected 
to the base as shown in Figure 11.6(a). The graphical symbol of a diode is shown in Figure 
11.6(b). The diode behaves like a base-emitter junction of a transistor. A graphical plot of 
current ID through the diode against its forward voltage drop VD is shown in Figure 11.6(c),
which is exactly identical to the transistor base characteristics. We can consider that a diode 
is off or nonconducting if its forward voltage VD is less than 0.6V. When the diode conducts, 
current ID  ﬂ ows in the direction as shown in Figure 11.6(b) and VD stays at about 0.7 V. 
An external resistor must always be provided to limit the current in a conducting diode.
Figure 11.6(b) 
Figure 11.6(c)
11.4  RESISTOR-TRANSISTOR LOGIC (RTL)
Resistor-transistor logic or RTL is the ﬁ rst-generation digital logic circuit. The basic circuit 
of the RTL digital logic family is the NOR gate as shown in Figure 11.7. Each input is 
associated with one resistor and a transistor. The collectors of the transistors are tied together 
with a common resistor to the VCC supply. The output is taken from the collectors joint. The 
voltage levels of the circuit are 0.2 V for low level and 1 to 3.6 V for high level.
Analysis of an RTL gate is simple. If any of the inputs is at high level, the corresponding 
transistor is at saturation. This causes the output at low irrespective of the conditions of 
other transistors, as all the transistors are connected in parallel. If all the inputs are at low 
level at 0.2 V, all the transistors are at cut-off condition because base-to-emitter voltage of 
all the transistors VBE < 0.6 V, causing the output of the circuit at high level approaching 
the value of the supply voltage VCC. Thus conﬁ rms the conditions of a NOR logic. Note that 
the noise margin for low signal input is 0.6 – 0.2 = 0.4 V.
0.6
0.7
0.8
V  (V)
D
I
(m A)
D
VD
+
–
ID
Figure 11.6(a)

386
DIGITAL PRINCIPLES AND LOGIC DESIGN
Figure 11.7
The RTL logic circuit has many drawbacks. The base current is practically independent 
of the emitter junction characteristics. The resistors increase the input resistance and reduce 
the switching speed of the circuit. This degrades the rise and fall times of any input pulse. 
Reduction in base resistors reduces the input resistance, increases power consumption, and 
decreases the fan in. An approach used in practice to increase the speed of RTL circuits is 
to connect speed-up capacitors parallel to the base resistors. In an RTL digital circuit the 
transistors are driven heavily to saturation resulting in long turn-off delays. The output high-
voltage level reduces with the increase of load or the number of gates connected at output. 
Also, the collector reverse saturation current of a driver transistor at high temperature may 
become large enough to lower the already low output voltage.
The fan out of the RTL gate is limited by the value of the output voltage when high. 
As the output is loaded with inputs of other gates, more current is consumed by the load. 
This current must ﬂ ow through RC (typical value of RC is 640 Ω). Assuming hFE drops to 
the value of 20, with each of the base resistor value R = 450 Ω and VCC = 3.6 V, the output 
voltage drops to 1 V when the fan out is 5. Any voltage below 1 V at the output may not 
drive the next transistor into saturation as required.
The following are the characteristics of the RTL family.
 
1. Speed of operation is low, i.e., the propagation delay is high up to the order of 
500 ns. It cannot operate at more than 4 MHz.
 
2. Fan out is 4 or 5 with a switching delay of 50 ns and fan in is 4.
 
3. Poor noise immunity.
 
4. High average power dissipation. Elimination of base resistors in RTL will reduce the 
power dissipation, which results in Direct-coupled Transistor Logic (DCTL).
 
5. Sensitive to temperature.
The RTL logic circuit of a NOR gate has been discussed here with three inputs. The 
working principle is similar for any number of inputs.
11.4.1  Resistor Capacitor Transistor Logic (RCTL)
RCTL circuit is an improvement over the RTL digital circuit, which employs a capacitor 
in parallel with each of the input resistors to increase speed and to improve noise immunity. 
The basic RCTL NOR gate circuit is shown in Figure 11.8.

LOGIC FAMILY 387
Figure 11.8
During the switching of logic levels the capacitor bypasses the resistor, resulting in 
the generation of base currents and the input capacitance discharges more quickly. The use 
of the capacitors allows employing higher values of resistors and thus lowering the power 
dissipation per gate. In comparison to the RTL family, the propagation delay of the RCTL 
circuit is less, although the fan in and fan out are the same. The main drawback of the 
RCTL circuit is that it is very difﬁ cult to fabricate the pn junction capacitor and it occupies 
a large area. Also, the RCTL circuit is not ideal for fabrication because it includes a high 
proportion of resistors and capacitors. 
11.5  DIODE TRANSISTOR LOGIC (DTL)
The DTL family eliminates the problem of decreasing the output voltage with the increase 
of load. The basic circuit of a DTL NAND gate is shown in Figure 11.9. Each input is 
associated with one diode. The input diodes DA, DB, DC, and resistor RD form an AND gate. 
The transistor Q1 serves as a current ampliﬁ er as well as a digital INVERTER. The two 
voltage levels are 0.2 V for the low level and 4 V for the high level.
Figure 11.9
If any input of the gate is low to 0.2 V, the corresponding diode is forward biased and 
conducts current through VCC and RD. The voltage at point P is equal to the input voltage 
0.2 V plus one diode drop of 0.7 V, for a total of 0.9 V. This is not sufﬁ cient to drive the 
transistor Q1 into conducting. In order for the transistor to conduct the voltage at P it must 
overcome a potential of one VBE (0.6 V) drop in Q1 and two diode voltage drops (0.6 V each) 
5K
5K
2K
A
D 1
Q1
D 2
B
C
P
=5V
V C C
R D
R B
R C
D A
D B
D C
Y=(ABC )'

388
DIGITAL PRINCIPLES AND LOGIC DESIGN
across D1 and D2, or 0.6 + 2 × 0.6 = 1.8 V. Hence, the transistor Q1 remains at cut-off 
condition and its collector to emitter behaves like an open circuit. Therefore, the output 
voltage at collector of the transistor Y is high at 5 V (power supply VCC is 5 V).
If all the inputs of the gate are high to 5 V, all the diodes are reverse biased and the 
current will ﬂ ow through RD, D1, D2, and the base of the transistor. The transistor is now 
driven to saturation region. The voltage at P is equal to one VBE drop plus two diode drops 
across D1 and D2, or 3 × 0.7V = 2.1 V (VBE drop is 0.7 V while conducting and forward 
biased diode drop becomes 0.7 V). This conforms that all the input diodes are reverse biased 
and off. With the transistor at saturated condition, the output drops to VCE(sat) = 0.2 V, 
which is low level for the gate. Thus the DTL circuit operation as above conforms NAND 
logic gate behavior. The working principle is similar to any number of inputs.
The DTL family has better noise margin, higher fan out capability, and faster response 
than the RTL family. The DTL family has the following characteristics.
 
1. The propagation delay of a DTL circuit is in the order of 30 ns. The turn-off delay is 
considerably larger than the turn-on delay by a factor of 2 or 3.
 
2. Fan out is as high as 8, because the input impedance is high for DTL gates due to 
reverse biased input diodes at logic 1 states. 
 
3. Fan in is at the order of 8.
 
4. Noise margin is high due to two diodes D1 and D2 connected in series. Typically the 
noise margin of a DTL NAND gate circuit is 0.8 V when the output is low and 3.4 V 
when the output is high.
Figure 11.10
The fan out of the DTL circuit can be improved by replacing one of the diodes in 
the base circuit D1 with a transistor Q2 as shown in Figure 11.10. The biasing of the 
transistor Q2 is modiﬁ ed with resistors RD1 and RD2 as shown in the ﬁ gure. The transistor 
Q2 is maintained at active region when the output transistor Q1 is at saturation. As a 
consequence, the modiﬁ ed circuit can supply a larger amount of base current to the output 
transistor, due to that RD1 is made smaller compared to RD of a DTL circuit. The output 
transistor Q1 can draw a larger amount of collector current, before it goes to saturation. 
Part of the collector current comes from the conducting diodes of the loading gates, when 
=5V
R B
A
B
C
D B
D A
D C
R C
R D 1
R D 2
V C C
5K
2K
1.6K
2K
Y=(ABC)'
D2
Q2
Q1

LOGIC FAMILY 389
Q2 is in saturation. Thus, an increase in allowable collector current allows more loads to 
be connected at the output, and therefore increases the fan out capability of the gate.
11.5.1  High Threshold Logic (HTL)
There are several applications where the digital circuits operate in an environment 
that produces very high noise signals. For operation in such surroundings, a type of DTL 
gate is available that possesses a high threshold to noise immunity. This type of gate is 
called a high threshold logic or HTL gate.
Figure 11.11
The HTL gate is the modiﬁ cation over the DTL gate of Figure 11.10. An HTL gate is 
shown in Figure 11.1. The normal diode D1, as used in DTL, has been replaced by a zenner 
diode (Z) in HTL. The supply voltage has been changed to 15 V and the resistor values 
have been modiﬁ ed accordingly to maintain an equal current with DTL. The zenner diode 
has the characteristics of maintaining a constant voltage of 6.9 V when reverse biased.
In order for output transistor Q1 to conduct, the emitter of Q2 must rise to a potential of 
one VBE plus ﬁ xed zenner voltage of 6.9 V, that means a total of about 7.5 V. With a low-level 
input of 0.2 V, the base of Q2 is at 0.9 V and so Q1 is at cut-off. The noise signal must be 
higher than 7.5 V to change the state of Q1. With all inputs at high level to 15 V, sufﬁ cient 
voltage and current are available at the base of Q1 to drive it to saturation. On the other 
hand, the noise signal must be greater than 7.5 V in the opposite side to turn the transistor 
off. Thus the noise margin of the HTL gate is about 7.8V for both voltage levels.
HTL gates are quite useful in the industrial environment where the noise level is usually 
high due the presence of motors, high-voltage switches, relays, circuit breakers, etc. 
11.6  TRANSISTOR TRANSISTOR LOGIC (TTL)
TTL is the most popular of all the logic families. The original basic TTL gate was a slight 
improvement over the DTL gate. As the TTL technology progressed, more and more additional 
improvements were carried out to make this logic family the most widely used type in the 
design of digital systems. Gates of this family possesses the highest switching speed when 
compared to other logic families that utilize the saturated transistors. TTL family, or the 
commercially available 74/54 series, evolved into ﬁ ve major divisions.
= 15V
R B
A
B
C
D B
D A
D C
R C
R D 1
R D 2
V C C
5K
15K
3K
12K
Y=(ABC)'
6.9V
Q2
Z
Q1

390
DIGITAL PRINCIPLES AND LOGIC DESIGN
 (i) Standard TTL (74/54 series)
 (ii) High-speed TTL (74H/54H series)
 (iii) Low-power TTL (74L/54L series)
 (iv) Schottky diode clamped TTL (74S/54S series)
 (v) Low-power schottky TTL (74LS/54LS series)
Although the high-speed and low-power TTL devices are designed for speciﬁ c applications, 
all the groups of the family have several common features, and are compatible and capable 
of interfacing directly with one another. They have the following typical characteristics in 
common.
 (i) Supply voltage is 5V.
 (ii) Logic 0 output voltage level is 0 V to 0.4 V.
 (iii) Logic 1 output voltage level is 2.4 V to 5 V.
 (iv) Logic 0 input voltage level is 0 V to 0.8 V.
 (v) Logic 1 input voltage level is 2 V to 5 V.
 (vi) Noise immunity is 0.4 V.
But the ﬁ ve different TTL series as mentioned above differ from one another in terms 
of propagation delay and power dissipation values. Speed-power product is an important 
parameter for comparing the basic gates. This is a product of the propagation delay and the 
power dissipation measured in picojoules (pJ). A low value of this parameter is desirable in 
designing the digital circuit, because it indicates a low propagation delay without excessive 
power consumption or vice versa. Figure 11.12 provides a table comprising of the typical 
values of propagation delay, power consumption, speed-power product, maximum operating 
frequency, and fan out for different TTL series. 
Name of 
Abbreviation Propagation 
Power  
Speed-power Maximum Fan out
the series 
 
delay (ns) 
 dissipation 
product 
clock rate 
 
 
 
(mW) 
(pJ) 
(MHz)
Standard TTL 
TTL 
10 
10 
100 
35 
10 
Low-power TTL  
LTTL 
33 
1 
33 
3 
10 
High-speed TTL  
HTTL 
6 
22 
132 
50 
10 
Schottky TTL 
STTL  
3 
19 
57 
125 
10 
Low-power Schottky TTL 
LSTTL 
9.5 
2 
19 
45 
10 
Figure 11.12
The standard TTL gate was the ﬁ rst version of TTL family. The basic gate was constructed 
with different resistor values to produce gates with lower power dissipation or higher speed. 
The propagation delay of saturated logic family largely depends upon two factors—storage 
time and RC time constants. Reducing the storage time decreases the propagation delay 
and also reducing the resistor values in the circuit reduces the RC time constant, which in 
turn reduces the propagation delay. But reduction in resistor values causes higher power 
consumption. The speed of the gate is inversely proportional to the propagation delay.
All TTL versions are available in SSI packages and in more complex forms as MSI 
and LSI functions. The differences in the TTL versions are not in the digital functions that 

LOGIC FAMILY 391
they perform, but rather in the values of resistors and type of transistor that are used to 
form their basic gates. In any case, TTL gates in all the versions come in three different 
types of output conﬁ gurations as below.
 
1. Open collector output conﬁ guration.
 
2. Totem pole output conﬁ guration.
 
3. Tristate or three-states output conﬁ guration.
11.6.1  Standard TTL with Open Collector Output Conﬁ guration
The basic TTL NAND gate is shown in Figure 11.13, which is the modiﬁ ed circuit of 
a DTL gate. Q1 is a multiple emitters transistor and the logic inputs are applied to the 
emitters of Q1. These emitters behave like the input diodes in the DTL gate, as they form 
pn junction with their common base. The base-collector junction of Q1 acts like another 
pn junction diode, equivalent to the diode D1 of the DTL gate (refer to Figure 11.9). The 
transistor Q2 replaces the second diode D2 of the DTL gate. The output of the TTL gate 
is taken from the open collector of Q3.  A resistor must be connected externally at the 
collector of Q3 to VCC, to maintain the output voltage level to high when Q3 is at cut-off. 
The external resistor is termed as a pull-up resistor.
Figure 11.13
The two voltage levels of the TTL circuit are 0.2 V for the low level and 2.4 V to 5 V 
for the high level. If any input is low, the corresponding base emitter junction of Q1 becomes 
forward biased. The voltage level at the base of the transistor Q1 is 0.2 V plus one VBE drop 
of 0.7 V, i.e., 0.9 V. This voltage level is not sufﬁ cient to drive the transistor Q2 and Q3, 
and they are at cut-off condition. The voltage required at the base of Q1, to drive Q2 and 
Q3 into saturation should be VBE of Q3 plus VBE of Q2 plus one pn junction diode drop of 
Q1, i.e., 0.7 V + 0.7 V + 0.7 V = 2.1V. When the output transistor Q3 cannot conduct, the 
output voltage level at Y will be high if any external resistor RL is connected to VCC.
When all the inputs are high, no base emitter junction of Q1 is forward biased and 
voltage at the base of Q1 is higher than 2.1 V. Hence transistor Q2 is driven to saturation 
as well as Q3, provided it has the current through the collector. The collector current may 
be available from the external pull-up resistance or from the connected loads at the output. 
Y
A
Q1
Q2
Q3
4K
1.6K
1K
C
B
VC C
RL
VC C
=5V
=5V

392
DIGITAL PRINCIPLES AND LOGIC DESIGN
The output voltage at Y is VCE (saturation) i.e., 0.2 V. Thus the gate operation conforms the 
NAND function, as when any of the inputs is low, output Y is high and if all the inputs 
are high, output Y is low. 
In the above analysis, it has been stated that the base-collector junction of Q1 acts 
like a pn diode junction. This is true in the steady state condition. However, during the 
turn-off transition, Q1 does exhibit transistor action resulting in a reduction in propagation 
delay. When one of the inputs is brought to low level from an all high inputs condition, 
both Q2 and Q3 are turning off. At this time the collector junction of Q1 is reverse biased 
and the emitter junction is forward biased. Hence the transistor momentarily goes into the 
active region. The collector current of Q1 comes from the base of Q2 and quickly removes 
the excess charge stored in Q2 during its previous saturation state. This results in the 
reduction in the storage time of the circuit as compared to the DTL type of input and also 
results in the reduction of the gate turn-off time of the gate.
You may notice that the TTL gate with an open collector output conﬁ guration can be 
operated without using any external resistor when connected to the inputs of other TTL 
gates. However, this is not recommended because noise immunity becomes low. Without an 
external resistor, the output of the gate will be an open circuit when Q3 is at cut-off. An 
open circuit to an input of a TTL gate behaves like a high-level input, but a very small 
amount of noise may change this to a low level. When Q3 conducts, its collector current 
will be available from the input of the loading gate through VCC, the 4K resistor, and the 
forward-biased base-emitter junction.
The open collector output conﬁ guration has many useful applications. The output may 
be interfaced with another circuit that has a different supply voltage. The external resistor 
may be selected of a suitable value according to the supply voltage it is connected to. This 
facilitates to drive a lamp or a relay which may have a supply voltage other than 5 V used 
for TTL, directly from the open collector gate as shown in Figure 11.14. When the output 
transistor is off, no current ﬂ ows through the lamp or relay and it remains off. When the 
output transistor Q3 is on, current path is available for the lamp or relay to make it on. 
Also, the open collector output gates can be used for interfacing with gates of another family 
like CMOS, where supply voltage varies from 3 V to 15 V.
Figure 11.14
Y
A
Q1
Q2
Q3
4K
1.6K
1K
C
B
VC C
V
= 5 V
= 12 V
Lam p
Load

LOGIC FAMILY 393
If the outputs of several open collector TTL gates are tied together with a single 
external pull-up resistor, a wired-AND logic is achieved. Remembered that a positive wire-
AND function gives high level if all the outputs of the gates are high. This is due to that 
all the output transistors are at cut-off making the wired logic high. If any output transistor 
conducts, it forces the output to a low state.
 
Figure 11.15(a) 
Figure 11.15(b)
The wired logic function is illustrated in Figure 11.15. The physical wire connection is 
shown in Figure 11.15(a). Two open collector NAND gates are tied together and connected 
to a common resistor to VCC. The graphic symbol of a wired-AND function is demonstrated 
in Figure 11.15(b). The AND gate drawn with the lines going through the center of the gate 
is distinguished from the conventional gate and symbolized as wired-AND. The Boolean 
expression obtained from the circuit of Figure 11.15 is the AND operation between the 
outputs of two NAND gates.
 
 
 
Y = (AB)′.(CD)′ = (AB + CD)′
The second expression is preferred, as it is the commonly used AND-OR-INVERT 
expression.
Another important application of the open collector gates is to form a common bus by 
tying several such gates together. At any time, all the gates, except one, must be maintained 
in their output state. The selected gate output may be either high or low according to its 
logic information to be transmitted. A control circuit is provided to select the particular gate 
that drives the bus at any given time.
Figure 11.16
D
D
C
C
VC C
B
B
A
A
OC
OC
OC
OC
Y
Y

394
DIGITAL PRINCIPLES AND LOGIC DESIGN
Formation of the common bus line with four sources tying together is demonstrated 
in Figure 11.16. (The control circuit mentioned above is not shown here.) Each of the four 
sources drives an open-collector inverter, and the outputs of the inverters are tied together 
with a common pull-up resistor to VCC to form a single bus line. If any data is transmitted 
from the source I1, then all the other sources (I2 to I4) are logic 0, so that they produce logic 
1 on the bus line. The input I1 can now transmit information through the common bus line 
to the output inverter G5. Note that the AND operation is performed on the common bus by 
the wired logic. If I1 is 0, its corresponding inverter OC1 produces logic 1 and so common 
bus has logic 1, because other open collector gates outputs are 1, hence output Y is 0. And 
if I1 is logic1, the common bus is logic 0 and so Y is logic 1.
11.6.2  Standard TTL with Totem Pole Output Conﬁ guration
The TTL NAND gate with totem pole output conﬁ guration is shown in Figure 11.17. It 
is the same circuit as the open-collector gate, except for the output transistor Q4, a diode 
D1, and resistor 130Ω at the collector of Q4. It is called the totem pole output conﬁ guration, 
because the transistor Q4 sits upon Q3. The base of the transistor Q4 is driven from the 
collector of Q2, as shown in Figure 11.17.
Figure 11.17
The two voltage levels of the TTL circuit are 0.2 V for the low level and 2.4 V to 5 V 
for the high level. If any input is low, the corresponding base emitter junction of Q1 becomes 
forward biased. The voltage level at the base of the transistor Q1 is 0.2 V plus one VBE drop 
of 0.7 V, i.e., 0.9 V. This voltage level is not sufﬁ cient to drive the transistor Q2 and Q3, 
and they are cut-off condition. The voltage required at the base of Q1, to drive Q2 and Q3 
into saturation should be VBE of Q3 plus VBE of Q2 plus one pn junction diode drop of Q1, 
i.e., 0.7 V + 0.7 V + 0.7 V = 2.1V. When Q2 and Q3 are off, high base current available for 
Q4 to operate and the output Y is logic high. The currents for the output loads or the gates 
connected at the output are supplied through transistor Q4 and its collector resistor 130Ω.
When all the inputs are high, no base-emitter junction of Q1 is forward biased and 
voltage at the base of Q1 is higher than 2.1 V. Hence, transistors Q2 and Q3 are driven to 
saturation. The output voltage at Y is VCE (saturation) i.e., 0.2 V. The voltage at the collector 
of Q2 is equal to one VBE drop of Q3 plus one VCE (saturation) drop of Q2, i.e., 0.7 V + 0.2 
V
 = 5V
C C
Y
A
Q1
Q2
Q3
Q4
4K
1.6K
1K
130Ω
C
B
D1

LOGIC FAMILY 395
V = 0.9 V. This voltage level is applied to the base of Q4 and is not sufﬁ cient to drive the 
transistor Q4. Since, to drive the transistor Q4, the voltage required at its base is one 
VCE (saturation) for Q3 plus one diode drop against D1 plus one VBE drop of Q4, i.e., 0.2 
V + 0.7 V + 0.7 V = 1.6 V. Hence Q4 is at cut-off condition. While Q3 is in saturation, its 
collector current is available from the connected loads at the output. Thus the gate operation 
conﬁ rms the NAND function, as when any of the inputs is low, output Y is high and if all 
the inputs are high, output Y is low. 
The output impedance of a gate is normally a resistive plus a capacitive load. The capacitive 
load consists of the capacitance of the output transistor, the capacitance of any of the fan out 
gates and any stray capacitance. When the output changes from low state to high state due 
to a change in the input condition, the output transistor goes from saturation to cut-off state. 
As soon as the transistor Q2 turns off and Q4 conducts because its base is connected to VCC
and the total load capacitance, C charges exponentially from the low- to high-voltage level 
with the time constant of RC, where R is the resistance value at the collector of the output 
transistor Q3 to supply voltage VCC, which is also referred to as a pull-up resistor. For totem 
pole conﬁ guration as above, a network consisting of a transistor Q4, diode D1, and resistor 
130Ω, is connected at the collector of the output transistor Q3 and is referred to as an active 
pull-up circuit. The active pull-up circuit offers low output impedance and hence the rise time 
of output is faster and in turn, the propagation delay is reduced to the order of 10 ns. Another 
advantage of the active pull-up circuit is that because of its low output impedance, it is capable 
of supplying more currents to the driven gate, and so the fan out capability increases.
As the capacitive load charges, the output voltage raises and the current in Q4 
decreases, bringing the transistor into the active region. Thus, in contrast to the other 
transistors, Q4 is in the active region when a steady state condition is reached. The ﬁ nal 
value of the output voltage is 5V minus one VBE drop of Q4, minus one diode drop of D1, 
i.e., 5 V – 0.7 V – 0.7 V = 3.6 V. The transistor Q3 goes into cut-off very fast, but during the 
initial transition time both Q3 and Q4 are on and a peak current is drawn from the power 
supply. This current spike generates noise in the power supply distribution system. If the 
change of state is frequent, the transient current spikes increase the power supply current 
requirement and the average power dissipation of the circuit increases.
A wired logic connection like open-collector gates is not allowed with totem pole output 
conﬁ guration. When two totem poles are wired together with the output of one gate high 
and the output of other gate is low, an excessive amount of current will be drawn to produce 
heat and this may cause damage to the transistors in the circuit. Some TTL gates are 
constructed to withstand the amount of current that is produced under this condition. In 
any case, the collector current in the low gate may be high enough to move the transistor 
into the active region and produce an output voltage in the wired connection greater than 
0.8 V, which is not a valid binary signal for TTL gates.
11.6.3  TTL Gate With Tri-state Output Conﬁ guration
As mentioned in the previous section that the outputs of the TTL gates with totem 
pole structures cannot be connected together in wired-AND fashion as in the open collector 
gates. There is, however, a special type of totem pole gate—the tri-state gate—that allows 
the wired connections at the outputs for the purpose of forming a common bus system.
We have seen that all the logic gates have two output states—logic 0 and logic 1. But the 
tri-state or three-state gate, as its name implies, has three output states as follows.

396
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
1. A low-level state or logic 0 state, when the lower transistor in the totem pole is on 
and the upper transistor is off.
 
2. A high-level state or logic 1 state, when the lower transistor in the totem pole is off 
and the upper transistor is on.
 
3. A third state when both transistors in the totem pole are off. This provides an open 
circuit or high impedance state which allows the direct wired connection of many 
outputs on a common line. Three states eliminates the need of open collector gates 
in common bus conﬁ gurations.
 
Figure 11.18(a) 
Figure 11.18(b)
 
Figure 11.19(a) 
Figure 11.19(b)
The graphic symbol of a tri-state buffer gate and inverter are shown in Figures 
11.18(a) and 11.19(a) respectively, and their truth tables are in Figures 11.18(b) and 11.19(b)
respectively. Tri-state gates consists of an extra input called a control or enable input. Here, 
the control input is such that when it is logic 0, the gate performs its normal operation. 
When the control input is logic 1, the output of the gate goes to tri-state or high impedance 
state regardless of the value of input A. Other types of logic gates are also available with 
control input and tri-state output. Gates are also available with reverse control logic, i.e.,
they perform their normal operation for control input of logic 1 and tri-state output for 
control input of logic 0.
The circuit diagram of a tri-state two-input NAND gate is shown in Figure 11.20. A 
and B are the data input and C is used as the control input. As compared to the standard 
TTL gate with totem pole output, the transistors Q6, Q7, and Q8 are introduced in a tri-
state gate circuit, which is associated with the control input to form an open-circuit-type 
inverter and is connected to the collector of Q2 through diode D1. Transistors Q1 to Q5 
associated with the data inputs form a totem pole NAND gate.  When control input C is 
low, the base-emitter junction of Q6 is forward biased and sufﬁ cient base current as well 
as base voltage are not available to make Q7 on. This in turn makes Q8 off and no current 
will ﬂ ow through the collector of Q8 and diode D1. Thus there is no potential effect at the 
collector of Q2 and the circuit performs a NAND operation on data from A and B. 
When control input C is high, The base-emitter junction of transistor Q6 is reverse 
biased and the base-collector junction of it is forward biased. Thus voltage level at the base 
of Q7 is higher and sufﬁ cient current is available to make the transistor Q7 on and hence 
the transistor Q8 also becomes on and driven to saturation. The current will ﬂ ow though 
the collector of Q8 and the diode D1. Therefore, the voltage level at the collector of Q2 is 
one diode drop plus one VCE (saturation) drop of transistor Q7, i.e., 0.7 V + 0.2 V = 0.9 
V. This voltage level keeps the transistors Q5 and Q4 off, which requires at least two VBE
Input
1
0
X
0
0
1
Output
Enable
1
0
Tristate
A
Y
 C
Input
1
0
X
0
0
1
Output
Enable
0
1
Tristate
A
Y
 C

LOGIC FAMILY 397
drop i.e., 1.4 V to turn them on. At the same time the saturation state of the transistor Q8 
exhibits low input to one of the emitters of Q1 forcing the transistors Q2 and Q3 to turn 
off. As a result, both the totem pole transistors Q3 and Q4 are turned off and the output 
of the circuit behaves like an open circuit with a very high output impedance.  The circuit 
operation may be tabulated to form a truth table as in Figure 11.21, which conﬁ rms the 
behavior of a NAND gate with a control input.
Figure 11.20
Control input 
Data input 
Output
 
C 
A 
B 
Y
 
0 
0 
0 
1 
 
0 
0 
1 
1 
 
0 
1 
0 
1 
 
0 
1 
1 
0 
 
1 
X 
X 
High impedance 
Figure 11.21
Note that there is little difference between the standard totem pole TTL and the tri-state 
TTL at the output totem pole section of the circuit. In the standard totem pole conﬁ guration 
a transistor and a diode were used at the upper part, which have been replaced by two 
transistors Q4 and Q5 in darlington mode in tri-state output conﬁ guration. A darlington 
pair of transistors provides a very high current gain and extremely low impedance. This 
is exactly required during low- to high-voltage level swing at the output, resulting in a 
reduction of propagation delay. This circuit also takes care of the diode drop as well as 
increases in the current output capability.

398
DIGITAL PRINCIPLES AND LOGIC DESIGN
A three-state bus can be created by wiring several three-state outputs together. At 
any given time, control input of only one single gate is enabled to transmit its information 
on the common output bus, and control inputs for all other gates must be disabled at that 
time instant to keep their outputs at a high impedance state. Extreme care must be taken 
to select the control input. If two or more control inputs are enabled at the same time, the 
undesirable condition of two or more active totem pole outputs will arise.
An important feature of most tri-state gates is that the output enable delay is longer 
than the output disable delay.  If a control circuit enables one gate and disables another 
gate at the same time, then the disable gate enters the high impedance state before the 
enable gate comes to its action. This eliminates the undesirable situation of both gates 
being active at the same time.
There is a very small leakage current associated with the high impedance state condition 
in a tri-state gate. However, this current is so small that as many as 100 tri-state gates can be 
connected together to form a common bus line without degrading logic behavior of the gates.
11.6.4  Schottky TTL Gates
As mentioned earlier, a reduction in storage time results in the reduction of propagation 
delay. This is due to the time needed for a transistor to come out of its saturation condition 
delays the switching of the transistor from the on saturation condition to cut-off condition. 
Saturation condition can be eliminated by placing a Schottky diode between the base and 
the collector of each saturated transistor in the circuit as shown in Figure 11.22. The 
Schottky diode is formed by the junction of a metal and a semiconductor, in contrast to the 
conventional pn diode which is formed by the junction of p-type and n-type semiconductors. 
The forward-biased voltage across the Schottky diode is 0.4 V as compared to .7 V in a 
conventional diode. The presence of a Schottky diode between the base and collector prevents 
the transistor from driving into saturation. A transistor with a Schottky diode is referred to 
as a Schottky transistor. Figure 11.22 shows the graphic symbols of a Schottky diode and a 
Schottky transistor. The use of Schottky transistors in TTL circuits results in the reduction 
in propagation delay without sacriﬁ cing the power dissipation.
Figure 11.22
A two-input Schottky TTL NAND gate circuit is shown in Figure 11.23. With comparison 
to the standard TTL gate, all the transistors of the Schottky TTL circuit are of Schottky 
type, except Q4.  Exception is made because the transistor Q4 does not go to the saturation 
region but remains at active region. It should be noted that the resistor values have been 
reduced to further decrease in the propagation delay.
In addition to employing the Schottky transistors and reducing the circuit resistor 
values, the Schottky TTL circuit in Figure 11.23 includes other modiﬁ cations over the 
standard TTL circuit in Figure 11.17. Two new transistors, Q5 and Q6, have been introduced 
and Schottky diodes are provided at each of the input terminals to ground. The transistors 
Schottky
Diode
Schottky
Transistor
=

LOGIC FAMILY 399
Q5 and Q4 are in darlington mode taking care of the diode VBE drops, higher current gain 
and current output capability, low output impedance and reduction in propagation delay as 
already explained in the previous section.
The diodes at each input terminal as shown in the circuit are provided to prevent any 
ringing that may occur in the input lines. Under transient switching conditions, the signal 
lines appear inductive. This, along with the stray capacitance of the circuit, cause signals to 
oscillate or ring. When the output of a gate changes its level from high to low, the ringing 
waveform at the input of the connecting gate may have the excursions below ground as 
high as 2 to 3 V depending on the line length. The diodes connected to the ground help 
to clamp the ringing as they conduct when the negative voltage exceeds 0.4 V. When the 
negative excursion is limited, the positive swing also becomes limited and thus reduces the 
ringing as well as unwanted switching of the gate.
Figure 11.23
The emitter circuit of Q2 in Figure 11.17 has been modiﬁ ed in Figure 11.23 by a circuit 
consisting of a transistor Q6 and two resistors. The turn-off current spikes are reduced due 
to this modiﬁ cation, which also helps to reduce the propagation time of the gate.
11.6.5  TTL Parameters
TTL devices work reliably over a supply voltage range of 4.75 V to 5.25 V and within 
the temperature range of 0 to 70°C. However, some TTL devices are specially manufactured 
for the operating temperature range of –55°C to +125°C for military application.
 
Figure 11.24(a) 
Figure 11.24(b)
Q4
Q3
Y
V
 = 5V
C C
A
B
Q 1
Q2
Q6
Q5
2.8K
900Ω
50Ω
250Ω
500Ω
3.5K
D1
D2

400
DIGITAL PRINCIPLES AND LOGIC DESIGN
Floating inputs. When a TTL input is at high level or logic 1 (ideally +5 V) as shown 
in Figure 11.24(a), the emitter current is zero. If the TTL input is unconnected or ﬂ oating 
as shown in Figure 11.24(b), there is no ﬂ ow of emitter current because of the open circuit. 
Hence, a ﬂ oating input may be considered as high input.
Also, when the input terminal of a TTL gate is left open, it acts like a small antenna 
and picks up stray electromagnetic noise resulting in malfunctioning or undesirable operation 
of the gate. Therefore, it is mandatory to terminate the unused input terminals with either 
VCC or ground depending on the gate function. For example, the unused terminals of an 
AND gate or NAND must be connected to VCC, whereas the unused terminals of an OR 
gate or NOR gate should be connected to the ground.
Current sourcing and current sinking. When the output of a gate is high, it provides 
current to the input of the gate being driven, and in this situation, the output is said to 
act as the current source. For a TTL circuit the maximum current drawn by an input from 
a high output is 40 µA.
When the output of a TTL gate is at low level, it acts as a current sink, because it 
sinks current from the gate inputs, which are driven to low. In a standard TTL gate, when 
one of its inputs becomes low, the typical value of current that ﬂ ows out of the device is 
1.6 mA. (Refer to Figures 11.25(a) and 11.25(b).) Thus, 
 
 
 
IIL (maximum) = –1.6 mA  
and
 
 
 
IIH (maximum) = +40 µA.
Here, the negative sign indicates that the current ﬂ ows out of the device.
Standard loading. A TTL device can act as the source of the current when its output 
is high and it can sink the current when the output is low. The standard TTL datasheets 
specify that the TTL devices can sink up to 16 mA, denoted by IOL(max) = 16 mA, and can 
source up to 400 µA,  denoted by IOH(max) = –400µA. The negative sign denotes that the 
current is ﬂ owing out of the device. Since the maximum output current capabilities—IOH(max)
and IOL(max)—are ten times larger than the input currents IIH(max) and IOH(max), up to 10 
TTL gates can be connected at the output of a TTL gate.
 
Figure 11.25(a) 
Figure 11.25(b)
Fan out. The maximum number of TTL loads that can be driven by a TTL driver is 
called fan out. As discussed above 10 numbers of standard TTL loads can be connected to 
the output of a standard TTL gate. Thus the fan out of a standard TTL is 10. When the 
130Ω
130Ω
V
 = 5V
C C
V
 = 5V
C C
V
 = 5V
C C
V
 = 5V
C C
ON
4K
4K
  I=40µA
OFF
OFF
ON
HIGH
LOW
I=1.6mA
STANDARD TTL

LOGIC FAMILY 401
totem pole output of a standard TTL goes high, it reverse biases another gate input with 
the resulting current of 40 µA maximum, as shown in Figure 11.25(a). While standard TTL 
output goes low, it must sink the current of 1.6 mA from a standard TTL gate as shown 
in Figure 11.25(b). But in case of a low-power Schottky TTL the sink current is 0.36 mA. 
Using the standard unit as a reference, one unit load is then the same as the current of 
1.6 mA into a low input. Since the standard TTL output drive is capable of sinking 16 mA 
of current, it can drive up to 10 loads.
For low-power TTL,
 
 
 
IIL(max) = –0.18mA, 
IIH(max) = 10 µA
 
 
 
IOL(max) = 3.6 mA, 
IOH(max) = –200 µA.
Considering high-output state, IOH(max)/IIH(max) = 200 µA/10 µA = 20.
Considering low-output state, IOL(max)/IIL(max) = 3.6 mA/0.18 mA = 20.
Therefore, 20 numbers of low-power TTL gate can be connected to the output of another 
low-power TTL gate or fan out is 20.
For low-power Schottky TTL,
 
 
 
IIL(max) = –0.36 mA, IIH(max) = 20 µA
 
 
 
IOL(max) = 8 mA, 
 
IOH(max) = –400 µA.
Considering high-output state, IOH(max)/IIH(max) = 400 µA/20 µA = 20.
Considering low-output state, IOL(max)/IIL(max) = 8 mA/0.36 mA = 22.
Therefore, 20 numbers (whichever is less) of low-power Schottky TTL gate can be 
connected to the output of another low-power Schottky TTL gate or the fan out is 20.
Also, a particular type of TTL gate can be connected with other types of TTL. For 
example, if a standard TTL gate is connected with HTTL, the fan out is 8. Fan out will be 
40, if LTTL is connected to the output of a TTL gate. A table is provided in Figure 11.26 
for summarized data regarding fan out for different types of TTL loads.
TTL gates 
TTL loads
    as driver 
Standard 
High-speed 
Low-power 
Schottky 
Low-power
  
TTL 
TTL 
TTL 
TTL 
Schottky TTL
 Standard TTL 
10 
8 
40 
8 
20 
 High-speed TTL 
12 
10 
50 
10 
25 
 Low-power TTL 
2 
1 
20 
1 
10 
 Schottky TTL 
12 
10 
100 
10 
50 
 Low-power Schottky TTL 
5 
4 
40 
4 
20 
Figure 11.26
Switching speed. The TTL circuit has the fastest switching speed among all the saturated 
logic circuits. The propagation delay of the gate directly affects the switching speed. It is 
related with two switching parameters—propagation delay tpHL during transition from logic 
1 to logic 0 and propagation delay tpLH during the transition from logic 0 to logic 1 at the 
output. It may be noted that tpHL decreases with the increase in temperature, whereas tpLH
is independent of temperature. For a standard TTL gate, typical value of propagation delay 
is 10 ns.

402
DIGITAL PRINCIPLES AND LOGIC DESIGN
Supply current characteristics. Power supply current requirements for all types of TTL 
families are speciﬁ ed as maximum current drain at maximum permissible power supply 
voltage VCC. Maximum current drain ICCL (for logic 0) per gate is speciﬁ ed as 5.5 mA and 
maximum current drain ICCH (for logic 1) per gate is speciﬁ ed as 2.0 mA. At the nominal 
supply voltage of VCC = 5V, typical ICCL is 3 mA and ICCH is 1 mA. Hence, ICCL is three times 
higher than ICCH.
Worst-case input and output voltages. For the TTL family, theoretically, the low state 
is 0 V and high sate is 5 V. But practically, this ideal situation never occurs and a range 
of voltage is deﬁ ned to recognize each of the logic states. They are explained below.
VIL(max) = 0.8 V. It means any voltage from 0 V to 0.8 V is recognized by the TTL 
gates as the low input level range without changing the output.
VIH(min) =  2 V. This implies that any voltage from 2 V to 5 V is recognized by the 
TTL gates as the high input level range without changing the output.
A low voltage greater than 0.8 V and a high voltage lower than 2 V are not desirable 
at the input and lead to unpredictable output at the TTL gates. Similarly, worst-case output 
voltage ranges are deﬁ ned below.
VOL(max) = 0.4 V. This implies that logic low output voltage level must be within 0 V 
to 0.4 V.
VOH(min) = 2.4 V. This means that logic high output voltage level must be within 2.4 V 
to 5 V.
Hence, as far as the TTL output is concerned, any voltage from 0.4 V to 2.4 V is 
undesirable and leads to an unpredictable output state.
Noise immunity. It is the maximum induced noise voltage a TTL device can withstand 
without any false change in the output state. This has been discussed in detail in earlier part 
of this chapter. The rating of the circuit depends on the smallest noise voltage that makes 
undesirable operation of the circuit. The noise immunity of TTL gates is much less. This can be 
understood from worst-case input/output voltage levels as discussed in the previous section.
The worst-case low voltages are 
 
 
VIL(max) = 0.8 V 
 
and 
 
VOL(max) = 0.4 V.
The worst-case high voltages are
 
 
VIH(min) = 2 V  
and 
 
VOH(min) = 2.4 V.
Therefore, as deﬁ ned in the earlier part of this chapter, the worst-case low-level noise 
immunity is
 
 
VIL(max) – VOL(max) = 0.8 V – 0.4 V = 0.4V.
And the worst-case high-level noise margin is 
 
 
VOH(min) – VIH(min) = 2.4 V – 2.0 V = 0.4 V.
Power dissipation. A standard TTL gate is operated with a power supply of 5 V, and 
its average current consumption is 2 mA. Therefore, average power dissipation of the TTL 
gate is 5 V × 2 mA = 10 mW.
Loading rules. A single TTL output may be connected to several TTL gates. When the 
gate output is low, the output transistor Q3 of the totem pole combination is at saturation 
condition and is acting as the current sink for all the currents from loading gates, as 
illustrated in Figure 11.27.

LOGIC FAMILY 403
Figure 11.27
Although the transistor Q3 is saturated, its on-state resistance possesses some value 
other than zero. Therefore, the total low-level output sink current IOL, which is the summation 
of all low-level input current of individual gate IIL, produces an output voltage drop VOL.
The value of VOL must not exceed 0.4 V for TTL, and this limits the value of IOL, which in 
turn limits the number of loads to be connected.
Figure 11.28
Figure 11.28 demonstrates the high state current situation. For high state output, 
the TTL gate behaves like a source and provides the currents to the external loads. At 
this condition, the transistor Q4 of the totem pole combination is in the active region and 
output source current IOH passes through 130Ω resistor, Q4, and diode D1, and produces 
voltage drop across them. Output current IOH increases with the number of gates driven 
and provides input high level current IIH for each of the gates. Increase in IOH results in 
increase in potential drop across Q4, D1, and 130Ω resistor network, and thus decrease 
in the output voltage level VOH. But VOH must not decrease below the minimum allowable 
voltage of 2.4 V and hence the number of loads is limited to this parameter.
4K
4K
4K
D1
IIL
IO L
IIL
IIL
130Ω
1.6K
Q4
Q3
V
 = 5V
CC
V
 = 5V
C C
V
 = 5V
CC
V
 = 5V
C C
ON
OFF
Low state
4K
4K
4K
D1
IO H
IIH
IIH
IIH
VO H
130Ω
1.6K
Q4
Q3
V
 = 5V
CC
V
 = 5V
C C
V
 = 5V
CC
V
 = 5V
C C
ON
OFF
High state

404
DIGITAL PRINCIPLES AND LOGIC DESIGN
Protective (clamping) diodes. The input signals of TTL circuits are always positive. 
If negative signals are inadvertently applied, excess input currents may ﬂ ow through the 
input transistor, which might damage the circuit. Therefore, in general, protective diodes, 
called clamping diodes, are used at each of the input terminals of the TTL gate as shown 
in Figure 11.29. 
Figure 11.29
Also, these protective diodes suppress the oscillation or ringing at the input terminals, 
which are developed due to stray capacitance or large input cable length. This has been 
discussed in detail in earlier parts of this chapter.
11.6.6  Other TTL Gates
In the previous section, various conﬁ gurations of TTL gates were discussed considering 
the NAND gate only, because it is the universal gate and any other logic gate can be realized 
on the basis of this universal gate. In this section, the internal circuits of other gates are 
also illustrated with basic totem pole conﬁ guration.
Figure 11.30
A
V
 = 5V
C C
B
C
V
 = 5V
C C
Y=A’
A
Q1
Q2
Q3
Q4
D1
R1
R2
R3
R4
D2

LOGIC FAMILY 405
TTL INVERTER. The TTL INVERTER circuit diagram is shown in Figure 11.30. Q1 
is the input coupling transistor forming two diodes from its base-emitter junction and base-
collector junction. If input is low the base-emitter junction is forward biased and voltage 
level at the base of Q2 is much less to make Q2 and Q3 off. At this instant, the transistor Q4 
receives sufﬁ cient base voltage and current to drive it to the active region. Therefore, output 
Y is logic high.
When the input of the gate is at high state, the base-emitter junction of Q1 is reverse 
biased and the base-collector junction is forward biased. Hence sufﬁ cient current and voltage 
is available at the base of Q2 making Q2 as well as Q3 turn on. At the same time, Q4 is 
at cut-off. So voltage level of output Y is equal to the VCE (saturation) or low-level state. 
Thus, the circuit conforms the INVERTER operation.
TTL NOR gate. The TTL NOR gate circuit is shown in Figure 11.31. Here the base of 
two transistors Q3 and Q4 are connected to the collectors of Q1 and Q2 respectively. When 
both the inputs of the circuit A and B are at low level, the base-emitter junctions of both 
the transistors are forward biased, providing no current at the bases of the transistors Q3 
and Q4. Hence, both Q3 and Q4 are at cut-off, and also the transistor Q5 is at cut-off. At 
this time Q6 receives sufﬁ cient current to drive into the active region making output Y at 
high state.
If either or all the inputs of A and B are high, the base-collector junction of either or 
both the transistors Q1 and Q2 are forward biased, making either or both of Q3 and Q4 turn 
on. So base voltage and current for the transistor Q5 is available to drive it to saturation. 
At this time, base of Q6 is too low to turn on the transistor Q6. Therefore, output Y is 
driven to low state, conforming the NOR logic function.
Figure 11.31
TTL AND gate. The TTL NAND gate circuit has already been discussed in detail in 
this chapter. As AND logic is the complement of NAND logic function, an AND circuit is 
almost similar to the NAND circuit. The TTL AND gate is shown in Figure 11.32. The main 
difference from the NAND circuit is that a transistor and a diode have been introduced 
after the input circuit to obtain the inverter action. When either or both the inputs are at 
R1
D1
B
Q1
A
Y=(A+B)’
V
 = 5V
C C
R2
D2
R3
R4
D1
Q2
Q3
Q4
Q5
Q6
R5

406
DIGITAL PRINCIPLES AND LOGIC DESIGN
logic 0, one or both of the base-emitter junctions of Q1 are forward biased making Q2 and 
Q3 turn off. Now base current for transistor Q4 is available to drive it into saturation. 
Hence, the transistor Q6 is at cut-off and transistor Q5 is at saturation. Therefore, output 
Y is at low state.
If both inputs A and B are high, the base-collector junction is forward biased, driving 
the transistor Q2 and Q3 into saturation. Hence, the base voltage of transistor Q4 is low 
enough to keep it at cut-off. This, in turn, makes the transistor Q5 remain at cut-off. At 
this time, sufﬁ cient base current is available for the transistor Q6 to drive it to the active 
region. So, output Y goes to high state, conforming the AND logic operation.
Figure 11.32
TTL OR gate. As OR function is the complement of NOR function, their circuits are 
similar. The circuit of a TTL OR gate is illustrated in Figure 11.33.
Figure 11.33
When both inputs are at logic 0, base-emitter junctions of both the transistors Q1 
and Q2 are forward biased, keeping the transistors Q3 and Q4 at cut-off. Base current 
is available for Q6, driving it into saturation, in turn the transistor Q7 is also driven to 
saturation. At this time upper transistor Q8 of the totem pole is at cut-off, and output Y 
becomes low state.
D3
D4
D2
D1
Q4
Q2
Q3
R3
Q5
R5
Q6
R6
R4
B
A
Y=AB
V
 = 5V
C C
Q1
R1
R2
D4
D3
D2
B
A
D1
Y=A+B
V
 = 5V
C C
Q1
R1
Q2
Q3
Q4
Q5
Q6
Q7
Q8
R2
R3
R4
R5
R6
R7

LOGIC FAMILY 407
When either or both of the inputs are high, the base-collector junction of either or 
both of the transistors Q1 and Q2 are forward biased, driving either or both the transistors 
Q3 and Q4 into saturation, also the transistor Q5. So the transistors Q6 as well as Q7 are 
at cut-off. Now sufﬁ cient base current is available to drive the transistor Q8 to the active 
region. Hence, output Y becomes logic high, thus conforming the OR logic operation.
11.6.7  Other TTL Series
The standard TTL with its various output conﬁ gurations as well as Schottky TTL 
series have been discussed in detail in this section, as they form the basic structures of 
all TTL series. However, for critical design application, some special types of TTL series 
components are used. They are a little variation over the standard TTL series or Schottky 
TTL series as mentioned below.
Low-power TTL. The basic circuit is similar to the standard TTL series, except that 
all the resistor values are increased. The increase in resistor values results in the reduction 
in power dissipation. The power requirements of low-power gates are less than one-tenth of 
those of standard TTL gates. 74L/54L series devices have power dissipation in order of 1 mW 
per gate. But propagation delay for low-power TTL gates increases and they are used at low 
power and low frequency application, like battery-operated systems, calculators, etc.
High-speed TTL. The basic circuitry for this series of ICs is essentially the same as the 
standard TTL series, except that smaller resistor values are used and the upper transistor 
Q4 of the totem pole section (refer to Figure 11.17) is replaced with a darlington pair of 
transistors. This arrangement provides higher speed of operation, but with the sacriﬁ ce 
of power consumption. Flip-ﬂ pos, counters, high-speed data transfer network, etc., are the 
ﬁ elds of application of 74H/54H series high-speed TTL gates.
Low-power Schottky TTL. With a little increase of internal resistor values and using 
Schottky devices, a compromise has been made between the speed of operation and power 
dissipation. Thus, ICs of this series (74LS/54LS) are faster as well as consume less power 
with comparison to the standard TTL gates.
11.7  EMITTER-COUPLED LOGIC (ECL)
Emitter-coupled logic (ECL) is a current mode logic (CML) or nonsaturated digital logic 
family. We have seen in earlier sections that the time taken for a transistor to come out of 
its saturation delays the switching of the transistor from on condition to the off condition 
and it directly affects the speed of operation of the logic gates. For the gates of the ECL 
family, the transistors never go to saturation and operate within the cut-off region to the 
active region. That is why the ECL family is called a nonsaturated logic family. Since the 
transistors do not saturate in the ECL family, it is possible to achieve propagation delay 
as low as 2 ns and even below 1 ns. The ECL family has the lowest propagation delay of 
all the families and is used mostly in systems requiring a very high speed of operation. Its 
noise immunity and power dissipation are, however, the worst of all the logic families.
A typical basic circuit of the ECL family is shown in Figure 11.34. The outputs provide 
both the OR and NOR functions. Each input is connected to the base of a transistor. In 
contrast to other logic families, negative power supply of –5.2 V to ground is used in the 
case of the ECL family. However, positive logic is employed here, i.e., the lowest voltage 
level of –5.2 V is equivalent to logic 0 and the highest voltage level of ground level or 0 V is 

408
DIGITAL PRINCIPLES AND LOGIC DESIGN
equivalent to logic 1. Practically, a voltage level higher than –0.8 V is considered high-level 
logic and voltage level below –1.8 V is considered low-level logic. The ECL circuit consists 
of a differential ampliﬁ er, a temperature- and voltage-compensated bias network, and an 
emitter follower output. The emitter outputs require pull-down resistors for current to ﬂ ow. 
This is obtained from the input resistor, any of R1 to R4 of another similar gate connected, 
or from an external resistor connected to the negative power supply.
Figure 11.34
The temperature- and voltage-compensated bias network is formed by the transistor 
Q6, diodes D1, D2, and resistors R6, R7, and R10. The bias circuit provides a reference 
voltage of VBB = –1.3 V to the differential ampliﬁ er, which is set at the midpoint of the 
signal logic swing. The bias voltage VBB is constant despite any change in temperature or 
supply voltage.
If any input of the ECL gate is high (–0.8V assumed for worst case), the corresponding 
transistor is turned on and its emitter voltage level is –1.6 V. Hence the emitter of the 
transistor Q5 possesses the voltage level of –1.6 V. This forces the transistor Q5 to cut-off, as 
its base voltage is maintained at –1.3 V, which is not sufﬁ cient to turn it on (VBE drop must 
be greater than 0.6 V to make a transistor on). Therefore, the base current for transistor 
Q8 is available through the resistor R9, driving Q8 into the active region, provided a load 
resistor is connected at the emitter of Q8. The voltage across R9 is nominal and the OR 
output is almost equal to –0.8 V, which is equivalent to high logic state. At this time, current 
through the resistor R8 is such that the voltage drop across R8 is 1 V below ground level. 
So, NOR output voltage level is –1 V minus one VBE drop of the transistor Q7, i.e., –1 V 
–0.8 V = –1.8 V, which is considered to be of low logic level.
If all the inputs are low level (below -1.8 V), all the input transistors Q1 to Q4 turn 
off, and Q5 conducts. The voltage at the common emitter node is VBB minus one VBE drop 
for Q5, i.e., –1.3 V –0.8 V = –2.1 V. Each of the input transistors Q1 to Q4 has the input 
R8
R9
V
 = GN D
C C 1
V
 = – 5.2V
E E
V
 =
– 1.3V
B B
V
 = GN D
C C 2
Q8
Q7
Y
Y'
OR
Output
Output
NOR
D1
D2
Q6
Q5
Q4
Q3
Q2
Q1
R7
R6
R5
R4
R3
R2
R1
779Ω
50K
50K
50K
50K
A
B
C
D
4.98K
6.1K
R10
220Ω
245Ω
907Ω

LOGIC FAMILY 409
voltage of –1.8 V and each base-emitter junction has the voltage difference of 0.3 V, which 
is not sufﬁ cient to turn them on. The voltage drop across R9 is about 1 V below ground 
level. The OR output is equal to –1 V minus one VBE drop for Q8, or –1 V – 0.8 V = –1.8 
V, which is considered to be of low state. On the other hand, as all the transistors from 
Q1 to Q4 are off, transistor Q7 receives base current through the resistor R8 to conduct. 
Current through R7 is so low that it produces nominal voltage drop against R8 and may 
be neglected. So, the NOR output will be one VBE drop below ground or –0.8 V, which is 
equivalent to high state. This veriﬁ es the OR and NOR operations of the circuit.
As no transistor of the ECL circuit is driven to saturation, the minimum propagation 
delay is achieved in order of 2 ns. The power dissipation is 25 mW. This gives the speed-
power product of 50, which is about the same as for Schottky TTL. The noise margin of 
an ECL gate is about 0.3 V, which is not as good as in the TTL gate. An ECL circuit has 
high input impedance due to the presence of a differential ampliﬁ er and also low output 
impedance due to an emitter follower at the output, making it possible to achieve high 
fan out. It may be noted that a power supply with any end grounded may be used for an 
ECL circuit, however, a positive grounded power supply is recommended for better noise 
margin.
The graphic symbol for the ECL gate is shown in Figure 11.35(a). Two outputs are 
available—one for the OR function and other for the NOR function. Wired logic is possible 
for ECL gates by tying two or more gate outputs together. As shown in Figure 11.35(b), an 
external wired connection of two OR outputs produces a wired-AND logic, and an external 
wired connection of two NOR outputs generates a wired-OR function. This property of ECL 
gates may be utilized to form the OR-AND-INVERT and the OR-AND functions.
 
Figure 11.35(a) 
Figure 11.35(b)
11.7.1  ECL Characteristics
An ECL family possesses the least propagation delay, and it is used in high-speed 
application. The characteristics of an ECL circuit are summarized as below.
 
1. The logic levels are nominally –0.8 V for high state and –1.8 V for low state.
 
2. The transistors never saturate, so storage delay in an ECL circuit is eliminated, and 
switching speed is high. Typical propagation delay is 2 ns, which makes it faster than 
advanced Schottky TTL devices (74AS series).
 
3. Because of very low noise margin in the order of 0.3 V only, ECL circuits are not 
suitable in heavy industrial environments.
 
4. An ECL gate is generally provided with true output and its complement, thus eliminating 
the need of an INVERTER.
 
5. Power supply requirement is –5.2 V.
 
6. Fan out is typically 25.
A
A
C
Y =A+B
B
B
D
Y '=(A +B )'
(A +B )(C +D )
(A +B )'+(C +D )'
=[(A+B )(C +D )]'

410
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
7. Typical power dissipation is 25 mW, which is a little higher in comparison with TTL 
gates. This is because the transistors of an ECL circuit are operating in the active 
region.
 
8. The total current ﬂ ow in an ECL circuit remains relatively constant regardless of its 
logic state. This helps to maintain a constant current drain from the power supply, 
even during the switching and transitions. Thus, unlike TTL circuits,  no noise spikes 
are internally generated for ECL.
ECL devices are not widely used as TTL and MOS families, except in applications where 
speed is critical. Their low noise margin and high power consumption are disadvantages 
in comparison to other logic families. Also, the use of negative power supply makes them 
incompatible to other logic families and difﬁ cult to interface. Because of the extreme high-
speed of operation, external wires act like transmission lines. Except for very short wires of 
a few centimeters, ECL outputs must be used with coaxial cables with a resistor termination 
to reduce line reﬂ ections and interferences. 
11.8  INTEGRATED-INJECTION LOGIC (I2L)
Integrated-injection logic, or IIL, or I2L, is latest generation LSI technique, also called Merged 
Transistor Logic (MTL), that uses both npn and pnp bipolar junction transistors to form a 
large number of logic gates on a single chip. It reduces the number of metal connections. 
This allows more circuits to be placed in a chip to form complex digital functions. It also 
eliminates all the resistors in the circuit, thus increasing the speed as well as reducing 
power dissipation.
The I2L basic gate is similar to the RTL gate, with a few major differences. 
 (a) The base resistor used in an RTL gate is removed altogether in the I2L gate. 
 (b) The collector resistor used in an RTL gate is replaced by a pnp transistor that acts 
as a load for the I2L gate.
 (c) I2L transistors use multiple collectors instead of individual transistors as employed in 
RTL.
The schematic diagram of a basic I2L inverter gate is shown in Figure 11.36. It has a 
multiple collector transistor Q1 and a pnp transistor Q2 at the base of Q1. The emitter of 
Q2 is connected to the supply voltage VBB and its base is grounded. Q2 acts as a current 
source and active pull-up, and the multiple collector npn transistor Q1 operates as an inverter 
when one or more collectors are connected with other gates. Most of the current leaving 
from Q2 is injected directly to the base of Q1, and hence the emitter of Q2 is known as the 
injector and the integrated structure is called the integrated injection logic.
Figure 11.36
Q2
Q1
Inverter
outputs
V
 = 1.5V
B B
Input

LOGIC FAMILY 411
The operation of the basic gate can be best analyzed when it is connected to other 
gates. Figure 11.37 demonstrates a NOR logic function implemented with I2L basic gates.
Figure 11.37
In Figure 11.37, transistors Q1 and Q2 are multiple collector transistors acting as 
inverters. Their base currents are injected through the multiple collector pnp transistor Q3, 
which is also acting as an active pull-up at the bases of Q1 and Q2. It is also acting as 
the active pull-up of the collector of transistor Q2. Collectors of Q1 and Q2 are connected 
with active pull-up pnp transistor Q4, producing a NOR function (A+B)′. Input signal B is 
complemented by the transistor Q2, which is connected to the base of the transistor Q5. One 
of the collectors of Q5 is connected with one of the collectors of Q1 and also to the active 
pull-up Q4, producing another NOR function (A + B′)′. OR functions may be available by 
the transistors Q6 and Q7, if they are connected to a pull-up circuit or other gates. Thus 
we can see that two NOR functions are realized just with a few number of transistors or 
basic gates. The graphic symbol of the functions as produced by the ﬁ gure is shown in 
Figure 11.38.
Figure 11.38
Use of Merged Transistor Logic (MTL) with multiple collectors and pnp transistors 
turned out to be most efﬁ cient method of construction of ICs of the I2L family, since it 
reduces the required chip area and increases the package density. The typical value of 
package density is 1500 gates per square mm. Complex digital circuits may be constructed 
with less numbers of active devices. I2L devices also consume less power. At high speeds, 
when propagation delay is 5 ns, it dissipates only 5 mW per gate. The typical values of 
parameters of I2L devices are as follows.
V
 = 1.5V
B B
Q1
A
B
(A+B)'
(A+B')'
Q2
Q3
Q4
Q6
Q7
Q5
B'

412
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
Packing density: 
 
1500 gates/sq. mm
 
 
Gate delay: 
 
 
25 to 250 ns
 
 
Power dissipation per gate: 
5 mW to 75 mW
 
 
Supply voltage: 
 
1 to 15 V
 
 
Logic voltage swing: 
 
0.6 V 
Because of high speed, low power consumption, and high package density, the I2L devices 
ﬁ nd their application mostly in LSI functions and large computers. It is not available in SSI 
packages containing individual gates. Its range of application includes microprocessor and 
microcontroller chips, memory devices, video games, watches, television tuning and control, 
etc.
11.9  METAL OXIDE SEMICONDUCTOR (MOS)
The ﬁ eld-effect transistor (FET) is a unipolar transistor, since its operation depends on the 
ﬂ ow of only one type of carrier—either holes or electrons. There are two types of ﬁ eld-effect 
transistors—junction ﬁ eld-effect transistors (JFET) and metal oxide semiconductor ﬁ eld-effect 
transistors (MOSFET). The JFETs are used in linear circuits, whereas the MOSFETs are 
employed in developing digital circuits.
11.9.1  Construction of a Mosfet
MOS technology derives its name from the basic structure of a metal electrode on an 
oxide insulator over a semiconductor substrate. The basic structure of the MOS transistor is 
shown in Figure 11.39(a). The p-channel MOS consists of a lightly doped substrate of n-type
silicon material. Two regions are heavily doped by diffusion with p-type impurities to form 
the source and drain. The region between the two heavily doped areas of p-sections serves as 
the channel. A metal plate is placed on the channel area with a separation layer consisting 
of insulating dielectric of silicon dioxide. The metal plate serves as a gate. When a negative 
voltage with respect to the substrate is applied to the gate, it causes an induced electric ﬁ eld 
in the channel, which attracts p-type carriers from the substrate. As the magnitude of the 
negative voltage on the gate increases, the region below the gate accumulates more p-type
carriers, conductivity in the channel region increases, and current can ﬂ ow from source to 
drain, provided a voltage difference is maintained between these two terminals.
Figure 11.39(a) p-channel MOS.
There are four basic types of MOS structures. The channel can be either p-type or 
n-type. If the majority of carriers is positive type or holes, it is called a p-type MOS, and it 
is called an n-type MOS when the majority of carriers are negative type or electrons. The 
p
p
+ + + + + + + + + +
n-type substrate
Drain (-)
Gate (-)
Source
M etal plate
Insulating layer
of silicon dioxide

LOGIC FAMILY 413
basic structure of an n-channel MOS is shown in Figure 11.36(b). The mode of operation 
can be enhancement type or depletion type, depending on the state of the channel region 
at zero voltage. If the channel is initially doped lightly with impurities (diffused channel), 
a conducting channel exists at zero gate voltage, and the device is called a depletion type. 
In this mode, current ﬂ ows unless the channel is depleted by an applied gate ﬁ eld. If the 
channel region is initially uncharged, the gate ﬁ eld induces a conducting channel before 
current can ﬂ ow. Thus the current is enhanced with the application of gate voltage and 
such a device is called an enhancement type.
Figure 11.39(b) n-channel MOS.
The terminal through which the majority of carriers enter the semiconductor bar is 
called the source, and through drain, the majority carriers of leave the bar. For a p-channel 
MOS, the source terminal is connected to the substrate and a negative voltage is applied to 
the drain terminal. When the gate is above threshold voltage (VT) of about –2 V, no current 
will ﬂ ow in the channel, and the drain to the source path is like an open circuit. When the 
gate voltage is sufﬁ ciently negative below VT, a channel is established and p-type carriers ﬂ ow 
from source to drain. The p-type carriers are positive and hence the corresponding positive 
current ﬂ ow from source to drain. The p-channel MOSs are normally referred to as PMOS.
In the n-channel MOS, the source is connected to the substrate and positive voltage 
is applied to the drain terminal with respect to the source or the substrate. When the 
gate voltage is below the threshold voltage VT (about 2 V), no current ﬂ ows through the 
channel. If sufﬁ ciently large positive gate voltage is applied above the threshold voltage, 
n-type carriers will ﬂ ow from source to drain. As n-type carriers are negative in nature, 
positive current will ﬂ ow from drain to source. The threshold voltage may vary from 1 V 
to 4 V, depending on the particular process of fabrication used. The n-channel MOSs are 
generally referred as NMOS.
Figure 11.40
The graphic symbols of  MOS transistors are shown in Figure 11.40. G, D, and S 
represent the gate, drain, and source respectively. Enhancement types of MOSFETs are 
symbolized by the broken lines between source and drain. In these symbols substrates can 
be identiﬁ ed and are shown connected to the source. The arrow indicates the direction of 
the ﬂ ow of carriers.
n
n
n-type substrate
Drain (+)
Gate (+)
Source
M etal plate
Insulating layer
of silicon dioxide
G
G
G
G
D
D
D
D
S
S
S
S
p-channel
enhancem ent
type
n-channel
enhancem ent
type
p-channel
depletion
type
n-channel
depletion
type
(a)
(c)
(b)
(d)

414
DIGITAL PRINCIPLES AND LOGIC DESIGN
Because of the symmetrical construction of the source and drain in the MOS transistors, 
they can be operated as bilateral devices. Although in normal operation carriers are allowed 
to ﬂ ow from source to drain, in certain circumstances it is convenient to allow the carriers 
to ﬂ ow from drain to source.
One advantage of the MOS device is that it can be used not only as transistor, but 
also as a resistor. A resistor may be constructed with technology by permanently biasing 
the gate terminal for conduction. The value of resistance is determined by the ratio of the 
source-drain voltage to the channel current. Different resistor values may be realized during 
construction by ﬁ xing the channel length and width of the MOS device.
11.9.2  Mosfet Logic Gates
Three logic gates using MOS devices are shown in Figure 11.41. For an n-channel MOS, 
positive supply voltage VDD (about + 5 V) is applied between the drain and source with 
substrate connected to the source to allow positive current ﬂ ow from drain to source. The 
n-channel gates generally employ positive logic and the two voltage levels are the function 
of the threshold voltage VT. Any voltage from 0 V to VT is considered low logic level and 
high-level ranges from VT to VDD. Negative supply voltage for VDD is used with p-channel
MOS devices to allow positive current ﬂ ow from source to drain. It is convenient to use a 
negative logic system with p-channel MOS circuits.
Figure 11.41
Figure 11.41(a) shows an INVERTER logic circuit with the use of MOS devices. Two 
MOSFETs, Q1 and Q2, are used here. Q1 acts as a normal MOS transistor, but Q2 behaves 
like a load resistor as its gate is biased with VDD and is always in the conduction state. When 
a low-level logic (below VT) is applied at the gate of Q1, it remains at cut-off. Since Q2 is 
at conduction state, the output voltage of Y is at about VDD or high logic state. When input 
A is of high-level logic (above VT), MOS transistor Q1 turns on and current ﬂ ows from VDD
through load resistor Q2 and into Q1. The output Y becomes low, as its voltage level goes 
below the threshold voltage VT. This veriﬁ es the INVERTER action. Note that resistance 
of Q1 while conducting must be much less compared to that of Q2. This means RDS(ON) of 
Q1<< RDS(ON) of Q2, where RDS(ON) is on-state resistance of MOS transistor.
A NAND gate circuit has been shown in Figure 11.41(b), three MOS transistors are 
used. Q1 and Q2 are the normal MOS transistors connected in series, and Q3 acts as a 
Y=(A+B)'
B
Y=(AB)′
B
A
A
V D D
V D D
V D D
A
Y=A'
Q1
Q2
Q1
Q2
Q3
Q3
Q1
Q 2
(a) INVERTER
(b) N AND
(c) NOR

LOGIC FAMILY 415
load resistor. When either or all the inputs A and B are low, the corresponding transistor(s) 
will be at the cut-off state preventing any current through Q1 or Q2. So output Y is at 
high state. When both the inputs A and B are high, both the transistors Q1 and Q2 turn 
on, producing a current path through Q1 and Q2. Hence the voltage level of output drops 
below the threshold voltage and becomes low logic level. Again, the condition that must be 
fulﬁ lled is RDS(ON) of Q1 + RDS(ON) of Q2 << RDS(ON) of Q3.
Similarly, a NOR gate circuit has realized with MOS devices as in Figure 11.41(c).
Here two MOS transistors, Q1 and Q2, are active devices connected in parallel and Q3 
behaves like a load resistor for both Q1 and Q2. When both the inputs A and B are at low 
logic state, none of Q1 and Q2 is operating, hence output Y is at high state. If either or all 
of the inputs are high, the corresponding transistor(s) turns on and the output Y becomes 
low. Thus conforms the NOR logic. The similar condition of the above regarding on-state 
resistance of MOS must be maintained.
MOSFET logic gates consume much less power and possess higher noise margin. It 
has high fan out capabilities, because of the extremely high input resistance at each of the 
inputs. It is also very simple to fabricate as it does not require resistors or diodes, etc., 
that leads to high package density. Its low power dissipation makes it ideally suited for 
LSI packages, this is where the MOS logic has made its greatest impact in the digital ﬁ eld. 
However, MOS gates are slower than the TTL gates.
11.9.3  Complementary MOS (CMOS) Logic
Complementary metal oxide semiconductors or CMOS circuits take advantage of the 
fact that both n-channel and p-channel devices can be fabricated on the same substrate. In 
CMOS circuits, both types of MOS devices are interconnected to form the logic functions. The 
power consumption of CMOS devices is extremely low. They have enhanced noise immunity, 
high fan out capability, and simpler interfacing with other logic circuits.
Figure 11.42
The CMOS inverter circuit can be made with only one n-channel MOS and one 
p-channel MOS transistor as shown in Figure 11.42(a). The source terminal of the p-channel
device is connected at VDD and the source terminal of the n-channel device at ground. The 
value of VDD may be anywhere from +3 V to +18 V. The two logic voltage levels are 0V for 
low-level logic and VDD for high-level logic. To understand the operation of the CMOS circuit, 
the following behaviors of the CMOS devices must be remembered.

416
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
1. The n-channel MOS conducts when its gate-to-source voltage is positive.
 
2. The p-channel MOS conducts when its gate-to-source voltage is negative.
 
3. Either type of device is turned off when gate-to-source voltage is zero.
In Figure 11.42(a), Q1 is in the n-channel MOS and Q2 is the p-channel MOS. Input A 
is connected to the gates of both Q1 and Q2. When a low-level input is applied at A, gates 
of both the transistors Q1 and Q2 are at zero potential. This keeps Q1 at off condition, but 
Q2 turns on as its gate-to-source voltage is effectively negative. Under this condition, a low 
impedance path from VDD to output is available, and output terminal to ground becomes 
a very high impedance path and hence output Y becomes logic high. On the other hand, 
when input A is at high state, gate-to-source voltage of Q1 is high and it turns on. Whereas 
gate-to-source voltage of Q2 is effectively zero and it turns off. As a result, the output Y 
approaches to low level to 0 V.
Figure 11.42(b) represents a CMOS two-input NAND gate circuit. Here, the transistors 
Q1 and Q3 form the complementary pair where Q1 is n-channel MOS and Q3 is p-channel
MOS, and one of the inputs A is connected to their gates. Similarly, Q2 is an n-channel
MOS and Q4 is a p-channel MOS making another complementary pair, and their gates 
are connected to another input B. The n-channel MOS transistors Q1 and Q2 are in series 
and p-channel MOS transistors are in parallel. When both the inputs A and B are at low 
logic level, both n-channel transistors Q1 and Q2 are at off condition, and both p-channel
transistors Q3 and Q4 are at conduction as their base voltages are negative with respect 
to sources, producing a low impedance path from VDD to output Y. Therefore output Y 
becomes high level. If input A is low and B is high, Q1 is off and Q2 is on. Their respective 
complementary transistors Q3 is on and Q4 is off. Hence, a low impedance path from VDD to 
Y is available through Q3, one of the transistors of parallel combination, and Y to ground 
level is at high impedance as Q1, one of the transistors of the series combination, is off. 
This makes output Y at high level. Similarly, if A is high and B is low, output Y remains 
high. Because this time, transistor Q2 of the series combination is at off state, producing 
a high impedance path for Y to ground, and transistor Q4 of the parallel combination is 
at conduction state providing a low impedance path from VDD to output Y. When both the 
inputs A and B are at high state, both the transistors Q1 and Q2 of the series combination 
are conduction state whereas the transistors Q3 and Q4 of parallel combination are at off 
condition. So a high impedance path is produced for VDD to Y and low impedance path is 
available from Y to ground. Therefore Y becomes low and the above input-output combinations 
verify the function of a NAND logic gate.
The two-input NOR circuit in Figure 11.42(c) can be explained in similar fashion. Here 
the n-channel MOS transistors Q1 and Q2 are employed in parallel, and p-channel transistors 
Q3 and Q4 are used in series. When both the inputs A and B are at low level, both the 
transistors Q1 and Q2 of parallel combination are at off state, and both the transistors 
Q3 and Q4 of series combination are at on conduction, producing a high impedance path 
for Y to ground and a low impedance path for VDD to Y. Hence output Y becomes high. 
When either or both the inputs are high level, one or both the transistors of the parallel 
combination of Q1 and Q2 conducts producing a low impedance path for Y to ground. At 
the same time one or both transistors of the series combination of Q3 and Q4 is at cut-off 
state, preventing any low impedance path from VDD to Y. Therefore, output Y remains at 
low level, which are conditions for a NOR logic function.

LOGIC FAMILY 417
11.9.3.1  Characteristics of CMOS Logic Gates
One great advantage of the CMOS logic gate is that it consumes extremely low DC 
power usually in the order of 10 nW and high package density. This is why this technology 
is becoming more and more popular and ﬁ nds its wide application in the fabrication of 
LSI chips as well as SSI and MSI chips. Other advantages include higher noise immunity, 
high fan out capability, and wide range of supply voltage. The characteristics of the CMOS 
family are described below.
Power dissipation. We have seen that one of the transistors of the complementary pair 
of CMOS gates is always at off condition while the other is at conduction. This situation 
prevails under static condition when the output is constant. Therefore, in this condition, 
the power dissipation of a CMOS circuit is extremely small (10 nW) as already mentioned, 
which is referred to as DC power dissipation. However, at the instant of switching, when 
output changes state from low to high or high to low, the power dissipation increases. This 
is due to the fact that during transition both the MOSFETs are in conduction for a small 
period of time. This leads to spikes in the supply current.
Therefore, during transition, an appreciable amount of drain current ﬂ ows. Moreover, 
any output stray capacitance has to be charged before the change in output can take place. 
The charging of the capacitor requires additional current that is drawn from the power 
supply resulting in an increase of instantaneous power dissipation.
The average power dissipation of a CMOS device whose output is continuously changing 
is called the active power dissipation. The active power dissipation increases with the 
increase in supply voltage as well as the frequency of operation. The power consumption 
of a CMOS gate is around 10 mW with operating frequency in the 10 MHz region. Thus, 
at higher frequencies the CMOS circuit losses its advantages.
Propagation delay time. The propagation delay of a standard CMOS gate ranges from 
25 ns to 150 ns. This factor depends on the power supply voltage and other factors. 
Voltage levels. CMOS circuits can be operated over a voltage range of 3 V to 15 V. 
A supply voltage of 9 V to 12 V can be used to obtain the overall best performance of a 
CMOS gate in respect to high speed and noise immunity. When CMOS gates are used in 
association with TTL gates, the VDD supply voltage is made 5 V, so that the voltage levels 
of the two families are the same.
Noise immunity. The CMOS family has the highest noise margin among all the logic 
families. It depends on the operating supply voltage and is typically about 45% of the supply 
voltage VDD. Noise margin is the same for both high level and low level. For a power supply 
VDD of 5 V, the noise margin is at least 2.25 V.
Floating inputs. A ﬂ oating input for a CMOS gate may be considered as either of the 
logic levels, and noise will be generated at the input terminal. This results in an excessive 
power dissipation. Therefore, it is recommended that all the unused input terminals must 
be connected to either VDD or to ground.
Current sourcing and sinking. When the output of a CMOS gate is at low state, it 
draws current from the driven gate in the order of only 1 µA. This means the sink current 
of the CMOS gate is 1 µA. Similarly, when output of the gate is at high level, it delivers 
current to the input of the driven gate. This is the source current and is in order of 1 µA. 
The worst-case input and output currents of the CMOS devices are as follows.

418
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
IIL(max) = –1 µA, 
 
IIH(max) = 1 µA
 
IOL(max) = 10 µA, 
 
IOH(max) = –10 µA
Fan out. The fan out of the CMOS gate depends on the type of load being connected. 
For a CMOS gate driving another CMOS gate the fan out can be calculated from the input 
and output currents as mentioned above.
 
Considering the low input state,  
IOL(max)/ IIL(max) = 10 µA/ 1µA = 10.
 
Considering the high output state,  
IOH(max)/ IIH(max) = 10 µA/ 1µA = 10.
Therefore, 10 CMOS gates can be connected at the output of another CMOS gate. 
Hence the fan out of a CMOS gate is 10.
Several series of the CMOS digital logic family are commercially available in the market. 
The original design of the CMOS series is recognized from 4000 number designations, which 
was produced by RCA company. Now a days CMOS devices are available in 74 series numbers 
and  they are pin compatible as well as function compatible with TTL devices having the same 
number. The CMOS devices of 74 series are indicated by 74C. The performance characteristics 
of 74C series are about the same as 4000 series. 74HC and 74HCT are the other CMOS 
series, which are of high speed and pin compatible with the TTL family of 74 series and the 
CMOS devices of later series are also electrically compatible with TTL family.
At LSI range, CMOS circuits are widely used because of the several advantages already 
mentioned. RAM, PROM, EPROM, microprocessors, microcontrollers, and several VLSI chips 
employ CMOS technology.
11.9.4  BiCMOS Logic Circuits
BiCMOS logic circuits are the latest development of digital technology in the silicon 
fabrication process that combines the speed and driving capabilities of bipolar junction 
transistors with the density and low power consumption of CMOS devices. BiCMOS 
technology is employed to develop low-voltage analog circuits, VLSI circuits, Application-
speciﬁ c integrated circuits or ASIC, and high-density gate arrays. The package density 
of BiCMOS circuits is sacriﬁ ced to accommodate the bipolar devices. Because of the low 
output impedance and increased charging and discharging current of BJTs, the propagation 
delay of the BiCMOS gates does not increase much as in CMOS gates. Also, it has good 
compatibility with the voltage levels of ECL and TTL for ready interfacing and minimum 
loss of switching speed. BiCMOS circuits may be employed in place of CMOS buffers for its 
high current capability and faster response. In terms of speed, power, and density BiCMOS 
IC can be compared with ECL.
BiCMOS INVERTER. The circuit of a basic BiCMOS inverter is shown in Figure 11.43. 
It is the extended version of a CMOS inverter, where two extra bipolar matching transistors 
T1 and T2 are used with each of the MOS transistors Q1 and Q2 respectively. When input A 
is low, the n-channel MOS Q1 is at cut-off. So, no base current is available for transistor T1 
and it is at off state. At the same time the channel MOS Q2 is on. Therefore base current 
for the transistor T2 is available. So T2 operates at the active region and supplies (β+1)
times the base current at the emitter of T2 to charge the load capacitance CL. The output Y 
thus becomes high level. When the logic input is high, it turns on the MOS transistor Q1, 
and at the same time Q2 becomes off. As Q1 supplies the base current for the transistor 
T1, a low impedance path is formed for output Y to ground to provide the discharge of load 
capacitance CL. Hence the output becomes low. 

LOGIC FAMILY 419
 
Figure 11.43 
Figure 11.44
The transfer characteristics and switching speed of the transistors can be improved 
by providing discharge paths for excess carriers from bases of the transistors T1 and T2. 
Additional NMOS transistors may be employed for this purpose at the bases of the bipolar 
transistors. Figure 11.44 shows the inverter circuit with the scheme of provision of the 
discharge path of excess carriers using additional NMOS transistors Q3 and Q4, which is 
a more conventional and practical circuit implementation for the BiCMOS inverter.
Figure 11.45
BiCMOS NAND. A conventional BiCMOS two-input NAND logic circuit is shown in 
Figure 11.45. It is the modiﬁ cation of the CMOS NAND circuit in Figure 11.42(b), where 
bipolar transistors T1 and T2 are provided to form the BiCMOS structure and additional 
NMOS transistors Q5, Q6, and Q7 are introduced to provide the discharge paths for the 
excess carriers accumulated at the bases of the bipolar transistors.
C L
T2
T1
Q2
Q3
Y=A'
VD D
A
Q1
Q4
B
Q3
Q2
Q1
V D D
Y=(AB)'
Q4
C L
A
Q5
Q6
Q7
T2
T1

420
DIGITAL PRINCIPLES AND LOGIC DESIGN
BiCMOS NOR. A practical circuit for a BiCMOS two-input NOR logic function is shown 
in Figure 11.46 with BJTs T1 and T2 providing the BiCMOS characteristics and NMOS 
transistors Q5, Q6, and Q7 to provide the discharge path for excess carriers accumulated 
at the bases of bipolar transistors.
Figure 11.46
11.10  COMPARISON OF DIFFERENT LOGIC FAMILIES
In this chapter, different logic families—their structures and characteristics—have been discussed. 
Among them, the TTL and the CMOS logic gates are the most widely used logic devices, as 
they are easily commercially available and economic. I2L and BiCMOS logic devices are gaining 
popularity and applied at special ﬁ elds. Each logic family projects different characteristics in 
terms of static and dynamic performance, size, and cost. A brief comparison of typical performance 
characteristics of commonly used IC families is tabulated in Figure 11.47.
Logic Families 
Propagation 
Power 
Noise 
Fan 
Logic voltage
and basic gates 
delay (ns) 
dissipation (mW) 
immunity (V) 
out 
swing (V) 
RTL (NOR) 
12 
20 
0.3 
5 
2.5 
DTL (NAND/NOR) 
12 
9 
0.3 
8 
4.7 
TTL (NAND) 
10 
10 
0.4 
10 
3.8 
STTL (NAND) 
3 
2 
0.5 
10 
3.8 
ECL (NOR/OR) 
2 
25 
0.3 
16 
3.6 
I2L (NAND) 
0.7 
0.1 
0.4 
12 
3.6 
MOS (NAND/NOR) 
1 
0.1 
2.5 
10 
3.8 
CMOS (NAND/NOR) 
1 
0.002 
2.5 
10 
5
Figure 11.47
Q4
Q3
Q2
Q1
V DD
Y=(A + B)'
T1
T2
C L
A
B
Q7
Q5
Q6

LOGIC FAMILY 421
11.11  INTERFACING 
The output(s) of a circuit or a system should match the input(s) of another circuit or system 
that has different electrical characteristics. In modular design technique, different circuit 
modules may be realized with the devices of different logic families. It is always necessary 
to match the driver circuit module or system with the load circuit in terms of electrical 
parameters. This is referred to as compatibility. Proper interfacing between different logic 
families is important for compatibility. An interfacing circuit is one that is connected between 
the driver and the load. The function of an interfacing circuit is to receive the driver output 
and condition it so that it is compatible with the input requirements of the load. 
A circuit designer must take care of the current and voltage characteristics of the 
two circuits of different logic families while connecting together. For example, an interface 
circuit is provided, if one of the circuits uses a negative logic system and is connected to a 
positive logic system. Similarly, an interface circuit is provided to convert an ECL output to 
a TTL signal if it is connected to a system that employs TTL devices. An interfacing circuit 
is also needed between a high-speed logic family and a low-speed logic family. Therefore, 
it is necessary to confer the electrical parameters of the logic families of the driver circuit 
as well as the load. 
The devices of TTL and CMOS families are most commonly used in designing the 
digital circuits. The worst-case values of electrical parameters of a commercially available 
series of these families are tabulated in Figure 11.48 for ready reference.
TTL/CMOS 
VIH(min) VIL(max) VOH(min) 
VOL(max) 
IIH(min) IIL(max)  IOH(min) IOL(max)
series 
(V) 
 (V) 
(V) 
(V) 
(mA) 
(mA) 
(mA) 
(mA)
TTL (74) 
2.0 
0.8  
2.4 
0.4 
0.04 
1.6 
0.04 
16 
TTL (74LS) 
2.0 
0.8 
2.7 
0.5 
0.02 
0.4 
0.4 
8.0 
TTL (74AS) 
2.0 
0.8 
2.7 
0.5 
0.02 
2.0 
2.0 
20 
TTL (74ALS) 
2.0 
0.8 
2.7 
0.4 
0.02 
0.1 
0.4  
8.0 
CMOS (4000B) 
3.5 
1.5 
4.95 
0.05 
0.001 
0.001 
1.6  
0.4 
CMOS (74C) 
3.5 
1.0 
4.9 
0.5 
0.001 
0.001 
1.75 
1.75 
CMOS (74HCT) 
2.0 
0.8 
4.9 
0.1 
0.001 
0.001 
4.0 
4.0 
* The data presented here are the typical values at supply voltage of +5 V. They may differ for gate to gate. 
** CMOS driving CMOS gates only.
Figure 11.48
11.11.1  Interfacing CMOS with TTL
The TTL devices operate on 5 V supply whereas the supply voltage for CMOS devices ranges 
from 3 V to 18 V. As the supply requirement is different, an interfacing circuit is needed.
TTL driving CMOS with the same supply voltage. As the CMOS devices work on a 
supply voltage ranging from 3V to 18V, which covers the TTL supply voltage of 5 V, an 
approach to interface the TTL circuit with a CMOS circuit is to use same supply voltage of 
5 V. When a TTL load drives a CMOS input, there is no problem for low-level input, as the 
maximum low-level output for TTL VOL(max) is 0.4 V. This voltage level is always interpreted 
as low-level input for CMOS, as maximum low-level input voltage for CMOS VOH(max) is 

422
DIGITAL PRINCIPLES AND LOGIC DESIGN
1.5 V. For high-level output from TTL, problems may arise because the minimum high-
level output of TTL VOH(min) is 2.4 V, whereas the minimum low-level input for the CMOS 
family VIH(min) is 3.5 V. Thus the voltage level from 2.4 V to 3.5 V at the input of a 
CMOS device is indeterminate and will cause malfunction in a CMOS circuit. Therefore, it 
is recommended to use an external pull-up resistance RL at the output of the TTL driver 
to the supply as shown in Figure 11.49. The effect of the pull-up resistance is to raise the 
output level nearer to 5 V. With the pull-up resistor, if the output of the drive is low, the 
resistor is grounded and low-level input will be considered by the CMOS load.
Figure 11.49
The value of the pull-up resistor may be chosen as 3.3K. The current through RL is 
5V/3.3K =1.5 mA approximately, when TTL output is low.  The TTL driver will sink this 
current and must be within the capacity. As for TTL the maximum sink current IOL(max)
is 16 mA, so it is well within the range. The gate capacitance of a CMOS load has to be 
charged through the pull-up resistor RL. To enhance the switching speed, it is important to 
decrease the value of RL. The minimum permissible value of resistor RL is determined by 
the maximum sink current of TTL i.e., 16 mA. In this case, if the maximum supply voltage 
variation is considered as 5.25 V, then the minimum value of the pull-up resistor will be 
 
 
RL = 5.25V/ 16 mA = 328Ω ≡ 330Ω (approximately).
TTL driving CMOS at different supply voltages. For CMOS logic gates, the best 
performance is achievable when their supply voltage is kept within range of 9 V to 12 V. 
At lower supply voltage, the performance of CMOS gates deteriorates with the increase of 
propagation delay and decease in noise immunity. Therefore, it is recommended to use 12 
V supply voltage for the CMOS circuits. In this case, if the CMOS circuit is to be driven 
by a TTL driver, an open-collector TTL gate should be employed, with a pull-up resistor RL
to the supply voltage 12 V, as shown in Figure 11.50.
Figure 11.50
The pull-up resistor RL may be selected as 6.8 K. If output of the TTL driver is low, 
its maximum output voltage VOL(max) is 0.4 V and it must sink current with the pull-up 
resistor. The sink current may be calculated as 12V/6.8K = 1.76 mA, which is within limit 
of the maximum TTL sink current of 16 mA (IOL(max)). When TTL output is at high level, 
TTL
+5V
+12V
R  = 6.8 K
L
CM OS

LOGIC FAMILY 423
the open collector output of the TTL gate approaches 12 V and this is acceptable as high 
level for a CMOS gate. So now the TTL outputs are compatible to CMOS input states.
CMOS driving TTL. To interface a CMOS gate with a standard TTL load, the low 
input of the CMOS output gate VOL(max) must be less than 0.8 V, which is the maximum 
allowable low-level input VIL(max) of TTL. Similarly, for high-level output from a CMOS 
driver, the minimum output voltage VOH(min) of CMOS must be higher than 2 V, which is 
the minimum high input level VIH(min) of TTL. Therefore, as per voltage levels concerned 
there is no mismatch between CMOS driver and TTL load provided their supply voltages 
are made the same to 5 V.
But while interfacing, one must not forget the current requirement of the driver gate 
and the driven loads. The low-level output current of the driver must be greater than the 
low-level input current to the load, and also the high-level output current of the driver 
must be greater than high-level input current of the load. The worst-case output currents 
of CMOS are 
 
 
IOL(max) = 400 µA, when output is low, 
 
and
 
 
IOH(min) = 40 µA, when output is high.
The worst-case input currents for TTL are
 
 
IIL(max) = 1.6 mA, for a low input, 
 
 
and 
 
 
I IH(min) = 400 µA, for a high input.
From the above data, we can see that for a high output level, there is no problem of 
interfacing. However, for a low output from driver, the maximum sink current capacity of 
CMOS (IOL(max) = 400 µA) is much lower than low-level input current (IIL(max) = 1.6 mA). 
So CMOS output is not compatible with standard TTL loads.
Let us consider the case that CMOS is driving the low power Schottky TTL load. 
Regarding the input/output voltage levels, they are compatible. Regarding the current 
requirements we observe that:
The worst-case output currents of CMOS are 
 
 
IOL(max) = 400 µA, when output is low, 
 
and
 
 
IOH(min) = 40 µA, when output is high.
The worst-case input currents for TTL are
 
 
IIL(max) = 400 µA, for a low input, 
 
 
and 
 
 
I IH(min) = 20 µA, for a high input.
Figure 11.51
It may be noticed from the above data that for a high driver output, the output 
current from a CMOS driver is sufﬁ cient to drive LSTTL (low-power Schottky TTL) gate. 

424
DIGITAL PRINCIPLES AND LOGIC DESIGN
However, for low logic output, maximum low-level output current of CMOS is just equal to 
the maximum low-level input current of LSTTL. Therefore, with a simple interface circuit 
conﬁ guration as in Figure 11.51, the CMOS driver can drive only one LSTTL load. 
The above problem can be eliminated by employing a CMOS buffer, which boosts up 
the current capability as an interface circuit as shown in Figure 11.52. For example, a 
CMOS current buffer 74C902 has the worst-case current output of IOL(max) = 3.6 mA, for 
low output, and IOH(min) = 800 µA, for high output. Since IIL(max) = 1.6 mA for standard 
TTL, the CMOS buffer can drive two standard TTL gates.
Figure 11.52
11.12  SOME EXAMPLES
Example 11.1. For the DTL NAND gate as shown in Figure 11.53, VBE(sat) = 0.8 V, Vγ = 
0.5 V, VCE(sat) = 0.2 V, the drop across the connecting diode is 0.7 V and Vγ (diode) = 0.6 V. 
The inputs of this switch are obtained from the outputs of similar gates.
 (a) Verify that the circuit functions as a positive NAND and calculate hFE(min).
 (b) Will the circuit operate properly if D2 is not used?
 (c) Calculate the noise margin if all the inputs are high.
 (d) Calculate the noise margin if at least one input is low. Assume for the moment that 
Q is not loaded by a following stage.
 (e) Calculate the fan out.
 (f) Obtain average power.
 
 (Assume hFE = 30)
Figure 11.53
Solution. (a) The logic levels are VCE(sat) = 0.2 V for logic 0, and VCC = + 5 V for 
logic 1. If any of the inputs A, B, or C is at logic 0 state, then the corresponding diode will 
V
 = 5V
C C
R C
R B
P1
I1
B1
I2
R D
B2
D 1
D 2
D A
P 2
Y
A
IC
IIN
Q1
D2
D1
DA
R D
DB
D C
C
B
A
6.8K
3.3K
6.8K
6.8K
V
 = 5V
C C
IB

LOGIC FAMILY 425
conduct and voltage at P1 is VP1 = 0.2 + 0.7 V = 0.9 V. Condition for diodes D1 and D2 in 
conduction is that  VP1  must be greater than the diode drop of D1 plus diode drop of D2 
plus VBE drop of the transistor Q1 = 0.7 + 0.7 + 0.7 V = 2.1 V. Therefore, diodes D1, and 
D2 are not conducting and also transistor Q1 is not conducting as sufﬁ cient voltage is not 
available at its base. Hence, output Y is 5 V, i.e., logic 1. 
If all the inputs are high to 5 V, all the diodes DA, DB, and DC are reverse biased and 
nonconducting. Hence, diodes D1 and D2  are conducting and transistor Q1 turns on. The 
voltage at P1 is
 
 
VP1 = VD1 + VD1 + VBE(sat) = 0.7+0.7+0.8 V = 2.2 V.
So the voltage across each diode DA, DB, or DC is 5 V –2.2 V = 2.8 V at reverse direction, 
conforming that they are off. At this time, Q1 is on and so Y = VCE(sat) = 0.2 V. Hence is 
low, thus conforming the NAND operation.
To ﬁ nd hFE(min),
Therefore,
I
V
V
R
5
2.2
6.8 10
0.412mA
1
CC
P1
D
3
=
−
=
−
×
=
I
V
(sat)
R
0.8
6.8 10
0.112 mA
2
BE
B
3
=
=
×
=
IB = I1 – I2 = 0.412 – 0.112 = 0.3 mA
I
h
V
V
(sat)
R
5
0.2
3.3 10
1.45 mA.
C
CC
CE
C
3
=
−
=
−
×
=
FE(min) =
=
=
I
I
1.45mA
0.3mA
4.83.
C
B
To assure the transistor Q1 for saturation, hFE must be greater than hFE(min).
(b) If one diode D2 is not used, then under all inputs low condition, VP1 = 0.2 + 0.7 
V = 0.9 V. Voltage at B1 or at the base of the transistor, VB1 = 0.9 – 0.6 V = 0.3 V, where 
cut-in voltage of the diode is 0.6 V. Since VB1 < Vγ, where Vγ = 0.5 V is the cut-in voltage 
of the transistor, theoretically the transistor Q1 is in cut-off. But a little spike in inputs or 
noise may turn on the transistor and logic function will be indeterminate.
(c) For all inputs are high, the output will be low. VP1 = 2.2 V. The input diode will 
start conducting if its cathode terminal voltage falls below VP1 – 0.6 V = 2.2 -0.6 V = 1.6 
V. This means VIH(min) = 1.6 V or the input high voltage must not fall below 1.6 V. The 
normally available high input voltage is 5 V. Hence noise margin = 5 – 1.6 V = 3.4 V.
(d) If one of the inputs becomes low, then the output is high. Voltage at P1, VP1 = 0.9 
V and Q1 is off. To drive the transistor just into the active region voltage, P1 is required 
to be Vγ (for D1) + Vγ (for D2) + Vγ (for Q1) = 0.6 + 0.6 + 0.5 V = 1.7 V. Hence the noise 
margin = 1.7 – 0.9 V = 0.8 V.
(e) From part (a), we have seen that the maximum collector current of the transistor Q1, 
unloaded condition, is 1.45 mA, when output becomes low. At this time, if another DTL gate 
is connected as in Figure 11.53, the driver gate must sink from the driven gate. At low-level 
condition, the driven gate can deliver the current IIN, which may be calculated as follows.
I
V
V
R
5
0.9
6.8 10
0.60 mA
IN
CC
P2
D
3
=
−
=
−
×
=

426
DIGITAL PRINCIPLES AND LOGIC DESIGN
 
 
(VP2 = 0.9 V under low input condition. VP2 is equivalent to VP1.)
If N number of DTL gates are connected, then the collector current will be,
 
 
IC = N × 0.6 + 1.45 mA.
Assuming  hFE = 30,
 
 
IC = hFE × IB = 30 × 0.3 mA = 9 mA.
So, 
N × 0.6 + 1.45 = 0.9.
Or, 
Therefore, fan out of the given DTL gate is 12.
(f) When the output is low the power consumption PLOW is given by
 
 
PLOW = VCC (I1 + IC) = 5(0.412 + 1.45) = 5.31 mW.
When the output is high, at least one input diode conducts. IC = 0, as the transistor 
is at cut-off. Power is drawn by RD only. Current through RD is
Power dissipation in the gate at high output state, PHIGH is  
 
 
PHIGH = VCC × I1 = 5 × 0.6 = 3mW.
Therefore, average power dissipation is
Example 11.2. (a) Determine the fan out of a 74LS00 NAND gate. (b) How many 
74LS00 inputs can a 7400 output drive?
Solution. (a) From the data sheet of 74S00, under the worst-case condition, we get,
 
 
IOH(min) = 0.4 mA,  IOL(max) = 8 mA
 
 
IIH(min) = 0.02 mA,  IIL(max) = 0.4 mA.
Fan out (at high state) =
Fan out (at low state) =
Therefore, fan out of 74LS00 gate is 20.
(b) As per the 74 series data sheet, the currents at worst-case conditions are,
 
 
IOH(min) = 0.4 mA, 
IOL(max) = 16 mA
 
 
IIH(min) = 0.4 mA, 
IIL(max) = 1.6 mA.
At high state, the number of 74LS00 gates that can be driven by 7400,
N
9
1.45
0.6
12.58 12.
=
−
=
=
I
V
V
R
5
0.9
6.8 10
0.6.
1
CC
P1
D
3
=
−
=
−
×
=
PAVERAGE = P
P
2
5.31
3
2
6.155mW.
LOW
HIGH
+
=
+
=
I
(min)
I
(min)
0.4
0.02
20.
OH
IH
=
=
I
(max)
I (max)
8
0.4
20.
OL
IL
=
=
=
=
=
I
(min)of 7400
I
(min)of 74LS00
0.4
0.02
20.
OH
IH

LOGIC FAMILY 427
At low state, the number of 74LS00 gates that can be driven by 7400,
=
=
=
I
(max)of 7400
I (max)of 74LS00
16
0.4
40.
OL
IL
Therefore, the number of 74LS00 gates can be driven by a 7400 gate is 20.
Example 11.3. Draw the interconnection of I2L gates to form a 2 to 4 decoder.
Solution. We know, for a 2 to 4 decoder there are two inputs and four outputs. If the 
inputs are designated as A and B, then the outputs will be A′B′, A′B, AB′, and AB. The 
circuit diagram with I2L gates to realize above functions is in Figure 11.54.
Figure 11.54
Q1, Q2, Q3, and Q4 are the multiple-collectors npn transistors. Q5 and Q6 are the pnp
transistors serving as the active pull-ups. Q7, Q8, Q9, and Q10 are the output transistors 
to show the completeness of the circuit.
REVIEW QUESTIONS
11.1 Deﬁ ne logic family?
11.2 Explain the governing parameters of the logic families.
11.3 Describe the difference between the bipolar integrated circuits and MOS integrated circuits.
11.4 What is noise immunity? What is propagation delay?
11.5 Describe the advantages and disadvantages of totem pole output conﬁ guration.
11.6 Explain current sourcing and current sinking.
Q7
Q3
Q6
Q5
B′
Q4
Q2
B
A
Q1
V
 = 1.5 V
B B
A′
Q8
Q9
Q10
=A B′ ′
=A B′
=AB′
=AB
(A + B)′
(A + B )′ ′
(A  + B)
′
′
(A  + B )
′
′ ′

428
DIGITAL PRINCIPLES AND LOGIC DESIGN
11.7 Draw and explain the circuit diagram of a 3-input I2L NOR gate.
11.8 What is the fastest logic family? Explain.
11.9 Explain why an open TTL gate acts as logic high.
11.10 What is the advantage of ECL logic family?
11.11 What are the Schottky diode and Schottky transitor?
11.12 What is a multiple emitter transistor?
11.13 Discuss why wired logic should not be used for active pull-up outputs.
11.14 Describe the characteristics of MOS logic.
11.15 Describe enhance type MOS and depletion type MOS with constructional details.
11.16 Why is CMOS faster than PMOS/NMOS?
11.17 Write a note on interfacing of CMOS with TTL and vice versa.
11.18 What is the necessity of an interfacing circuit?
11.19 Explain the purpose of totem pole at the TTL output conﬁ guration.
11.20 What is the function of the diode at output stage of a totem pole output conﬁ guration
11.21 Draw a 4-input CMOS NAND gate. Repeat for a 4-input NOR gate with CMOS.
11.22 Draw the basic BiCMOS inverter and explain.
11.23 What are the advantages of a BiCMos logic circuit?
11.24 What is tri-state logic. What is its application.
11.25 Compare the characteristics of different logic families.
11.26 (a) Determine the high-level output voltage of the RTL gate for a fan out of 5.
(b) Determine the minimum input voltage required to drive an RTL transistor to saturation, 
when HFE = 20.
(c) 
From the results from (a) and (b), determine the noise margin of the RTL gate when the 
input is high and fan out is 5.
11.27 Show that the output transistor of the DTL gate of Figure 11.9 goes to saturation when all the 
inputs are high. Assume hFE  = 25.
11.28 Connect the output Y of the DTL gate shown in Figure 11.9 to N inputs of other DTL gates. 
Assume that the output transistor is saturated and its base current is 0.44 mA. Its hFE is 20.
 
 (a) Calculate the current through a 2 K resistor.
 
 (b) Determine the current coming from each input connected to the gate.
 
 (c) 
Determine the total collector current in the output transistor as a function of N.
 
 (d) Find the value of N that will keep the transistor in saturation.
 
 (e) 
What is the fan out of the gate?
11.29 Let all the inputs of the open-collector TTL gate of Figure 11.13 be at high state of 3 V. 
 
 (a) Calculate the voltages in the base, collector, and emitter of all the transistors.
 
 (b) Calculate hFE(minimum) of Q2 that ensures the saturation of the transistor.
 
 (c) 
Assuming the minimum hFE of Q3 is 6.18, determine the maximum current that can be   
tolerated in the collector to ensure saturation.
 
 (d) What is the minimum value of RL while ensuring the saturation of Q3?

LOGIC FAMILY 429
11.30 (a)
Show with the truth table that when two open collector true outputs are wired connected 
with an external resistor to VCC, the output will produce an AND function.
 
 (b)
Prove with the truth table that when two open collector complemented outputs are wired 
connected with an external resistor to VCC, the output will produce a NOR function.
11.31 Why should the totem pole outputs not be tied together to form wired logic? Explain with 
the circuit diagram. Show that the load current (base current plus collector current of Q4) in
Figure 11.17 is about 32 mA. Compare this value with the recommended load current in the 
high sate of 0.4 mA.
11.32 Realize the logic diagram for the function F= ABCDEFGH using open collector two-input AND 
gates. Use IC 7409, which is a quad two-input AND gate IC. How many such ICs are required 
to implement the above function?
11.33 Calculate the emitter current IE across R5 in the ECL gate of Figure 11.35. When
(a) 
At least one input is high at –0.8 V.
(b) 
All inputs are low at –1.8 V.
 
Calculate the voltage drop across the collector resistor R9 in each case and show it is about 
1 V as required. Assume IC = IE.
11.34 Show that when NOR outputs of ECL gates are wired connected, the output produces an OR 
function.
11.35 Calculate the noise margin of an ECL gate.
11.36 The MOS transistors are bilateral, i.e., current may ﬂ ow from source to drain or from 
drain to source. Using this property, realize a circuit that implements the following Boolean 
functions—
 
   
 
F = (AB + CD + AED + BEC)′.
11.37 (a) Draw the circuit diagram of a 4-input NAND gate using CMOS transistors.
 
 (b) Repeat for a 4-input NOR function.
❑ ❑ ❑


431
D
ifferent types of logic gates and their symbols have been discussed in this book with 
their applications. However, readers may ﬁ nd alternate gate symbols while referring 
to other books. The alternate gate symbols are with the circles or bubbles at the 
inputs. The circles or the bubbles imply that the inputs are complemented ﬁ rst followed 
by the normal operation of the gates. The following table describes the graphic symbols of 
these gates and their functions.
❑ ❑ ❑
Graphic Sym bol of logic gates
Functions
Boolean Expressions
A
Y
INVERTER
Y = A'
Y
Y
Y
Y
A
A
A
A
B
B
B
B
AND
Y = AB
N AN D
Y = (AB)'
OR
Y = A+B
N OR
Y = (A+B)'
ALTERNATE GATE
SYMBOLS
1
A p p e n d i x


433
T
his section presents the available TTL 54/74 series of ICs for ready reference for logic 
designers. The IC numbers given here are with the reference of their functions. However, 
the actual IC numbers as speciﬁ ed by the manufacturers also indicates the exact section of 
the logic family they belong, though their logic functions are the same. As an example, 74LS00 
indicates quad 2-input NAND gates of the low-power Schottky family, whereas 74H00 indicates quad 
2-input NAND gates of high-speed TTL. Both 54 and 74 series ICs have the same functions, 
but the 54 series is used for military application, for the operating temperature is –55°C to 
+ 125°C, whereas 74 series ICs are used in industrial and commercial application with a 
temperature range of  0°C to +85°C. The pin conﬁ guration of both series is similar.
IC Number 
Function
7400 
Quad 2-input NAND gates
7401 
Quad 2-input NAND gates (open collector)
7402 
Quad 2-input NOR gates
7403 
Quad 2-input NAND gates (open collector)
7404 
Hex Inverters
7405 
Hex Inverters (open collector)
7406 
Hex Inverter Buffers/Drivers (open collector)
7407 
Hex Buffers/Drivers (open collector)
7408 
Quad 2-input AND gates 
7409 
Quad 2-input AND gates (open collector)
7410 
Triple 3-input NAND gates 
7411 
Triple 3-input AND gates 
7412 
Triple 3-input NAND gates (open collector)
7413 
Dual 4-input NAND Schmitt Triggers
7414 
Hex Schmitt Trigger Inverters
7415 
Triple 3-input AND gates (open collector)
74 SERIES INTEGRATED
CIRCUITS
2
A p p e n d i x

434
DIGITAL PRINCIPLES AND LOGIC DESIGN
7416 
Hex Inverter Buffers/Drivers (open collector)
7417 
Hex Buffers/Drivers (open collector)
7420 
14-input NAND gates
7421 
Dual 4-input AND gates
7422 
Dual 4-input NAND gates (open collector)
7423 
Expandable Dual 4-input NOR gates with Strobe
7425 
Dual 4-input NOR gates with strobe
7426 
Quad 2-input NAND Buffers (open collector)
7427 
Triple 3-input NOR gates
7428 
Quad 2-input NOR Buffers
7430 
8-input NAND gates
7432 
Quad 2-input OR gates
7433 
Quad 2-input NOR Buffers (open collector)
7437 
Quad 2-input NAND Buffers
7438 
Quad 2-input NAND Buffers (open collector)
7439 
Quad 2-input NAND Buffers
7440 
Dual 4-input NAND Buffers
7441 
BCD-to-Decimal Decoder/Driver (open collector)
7442 
BCD-to-decimal Decoder
7443 
Excess-3-to-Decimal Decoder
7444 
Excess-3-Gray-to-BCD Decoder
7445 
BCD-to-Decimal Decoder/Driver (open collector)
7446 
BCD-to-Seven Segments Decoder/Driver (open collector)
7447 
BCD-to-Seven Segments Decoder/Driver (open collector)
7448 
BCD-to-Seven Segments Decoder/Driver (open collector)
7449 
BCD-to-Seven Segments Decoder/Driver (open collector)
7450 
Expandable Dual 2-wide 2-input AND-OR-INVERT gates
7451 
Dual 2-wide 2-input AND-OR-INVERT gates
7452 
Expandable 4-wide AND-OR gates
7453 
Expandable 4-wide 2-input AND-OR-INVERT gates
7454 
4-wide 2-input AND-OR-INVERT gates
7455 
Expandable 2-wide 4-input AND-OR-INVERT gates
7460 
Dual 4-input Expanders
7461 
Triple 3-input Expanders
7462 
4-wide AND-OR Expander
7464 
4-wide AND-OR-INVERT gates
7465 
4-wide AND-OR-INVERT gates (open collector)

74 SERIES INTEGRATED CIRCUITS 435
7470 
AND-gated J-K Flip-ﬂ op
7471 
AND-gated R-S Flip-ﬂ op
7472 
AND-gated J-K Flip-ﬂ op
7473 
Dual J-K Flip-ﬂ ops
7474 
Dual D Flip-ﬂ ops
7475 
Dual 2-bit Transparent Latch
7476 
Dual J-K Filp-ﬂ ops
7477 
Dual 2-bit Transparent Latch
7478 
Dual JK Flip-ﬂ ops
7480 
Gated Full Adder
7482 
2-bit Binary Adder
7483 
4-bit Binary Adder
7485 
4-bit Magnitude Comparator
7486 
Quad XOR gates
7487 
4-bit True/Complement, Zero/One Element
7489 
16 × 4 RAM (open collector)
7490 
BCD Counter
7491 
8-bit Serial-in Serial-out Shift Register
7492 
Divide-by-12 Counter
7493 
4-bit Binary Counter
7494 
4-bit Serial/Parallel-in Serial-out Shift Register
7495 
4-bit Serial/Parallel-in Parallel-out Shift Register
7496 
5-bit Serial/Parallel-in Parallel out, Serial-in Serial-out Shift Register
7499 
4-bit Bidirectional Universal Shift Register
74100 
Dual 4-bit Transparent Latch
74101 
AND-OR-gated J-K Flip-ﬂ op
74102 
Dual J-K Flip-ﬂ ops
74103 
Dual J-K Flip-ﬂ ops
74106 
Dual J-K Flip-ﬂ ops
74107 
Dual J-K Flip-ﬂ ops
74108 
Dual J-K Flip-ﬂ ops
74109 
Dual J-K Flip-ﬂ ops
74110 
AND-OR-gated J-K Flip-ﬂ op
74111 
Dual J-K Flip-ﬂ ops
74112 
Dual J-K Flip-ﬂ ops
74113 
Dual J-K Flip-ﬂ ops
74114 
Dual J-K Flip-ﬂ ops

436
DIGITAL PRINCIPLES AND LOGIC DESIGN
74116 
Dual 4-bit Transparent Latches
74121 
Monostable Multivibrator
74122 
Retriggerable Monostable Multivibrator
74123 
Dual Retriggerable Monostable Multivibrators
74124 
Dual Voltage-controlled Oscillators
74125 
Tri-state Quad Buffers
74126 
Tri-state Quad Buffers
74128 
Quad 2-input NOR Buffers
74132 
Quad 2-input NAND Schmitt Triggers
74133 
13-input NAND gate
74134 
Tri-state 12-input NAND gate
74135 
Quad XOR/XNOR gates
74136 
Quad XOR gates (open collector)
74138 
1:8 Demultiplexer
74139 
Dual 1:4 Demultiplexer
74141 
BCD-to-Decimal Decoder/Driver (open collector)
74145 
BCD-to-Decimal Decoder/Driver (open collector)
74147 
Priority Encoder (Decimal to Binary)
74148 
Priority Encoder (Octal to Binary)
74150 
16:1 Multiplexer
74151 
8:1 Multiplexer
74152 
8:1 Multiplexer
74153 
Dual 4:1 Multiplexers
74154 
1:16 Demultiplexer 
74155 
Dual 1:4 Demultiplexers
74156 
Dual 1:4 Demultiplexers (open collector)
74157 
Quad 2:1 Multiplexers
74158 
Quad 2:1 Multiplexers
74159 
1:16 Demultiplexer
74160 
Decade Up-counter
74161 
4-bit Binary Up-counter
74162 
Decade Up-counter
74163 
4-bit Binary Up-counter
74164 
8-bit Serial-in Parallel-out Shift Register
74165 
8-bit Serial-in/Parallel-in Serial-out Shift Register
74166 
8-bit Serial-in/Parallel-in Serial-out Shift Register
74168 
Decade Up-down Counter

74 SERIES INTEGRATED CIRCUITS 437
74169 
4-bit Binary Up-down Counter
74174 
Hex D Flip-ﬂ ops
74175 
Quad D Flip-ﬂ ops
74176 
Presettable BCD Counter
74177 
Presettable 4-bit Binary Counter
74178 
4-bit Universal Shift Register
74179 
4-bit Universal Shift Register
74180 
8-bit Parity Generator/Checker
74181 
Arithmetic Logic Unit (ALU)
74182 
Look-ahead Carry Generator
74184 
BCD-to-Binary Code Converter
74185A 
6-bit Binary-to-BCD converter
74190 
Decade Up-down Counter
74191 
4-bit Binary Up-down Counter
74192 
Decade Up-down Counter
74193 
4-bit Binary Up-down Counter
74194 
4-bit Bidirectional Universal Shift Register
74195 
4-bit Serial/Parallel-in Parallel-out Shift Register
74196 
Presettable BCD Counter
74197 
Presettable 4-bit Binary Counter
74198 
8-bit Bidirectional Universal Shift Register
74199 
8-bit Serial/Parallel-in Parallel-out Shift Register
74206 
256-bit RAM (open collector)
74221 
Dual Monostable Multivibrator
74240 
Tri-state Octal Inverter Buffers
74241 
Tri-state Octal Buffers
74244 
Tri-state Octal Buffers
74246 
BCD-to-Seven Segment Decoder/Driver (open collector)
74247 
BCD-to-Seven Segment Decoder/Driver (open collector)
74248 
BCD-to-Seven Segment Decoder/Driver 
74249 
BCD-to-Seven Segment Decoder/Driver (open collector)
74256 
Dual 4-bit Addressable Latches
74260 
Dual 5-input NOR gates
74266 
Quad XNOR gates (open collector)
74273 
Octal D Flip-ﬂ ops
74276 
Quad J-K Flip-ﬂ ops
74279 
Quad S-R Flip-ﬂ ops

438
DIGITAL PRINCIPLES AND LOGIC DESIGN
74280 
9-bit Parity Generator/Checker
74283 
4-bit Binary Adder with Fast Carry
74289 
16 × 4 RAM (open collector)
74290 
BCD counter
74293 
4-bit Binary Counter
74352 
Dual 4:1 Multiplexers
74365 
Tri-state Hex Buffers
74366 
Tri-state Hex Buffers
74367 
Tri-state Hex Buffers
74368 
Tri-state Hex Buffers
74375 
Dual 2-bit Transparent Latches
74376 
Quad J-K Flip-ﬂ ops
74381 
Arithmetic Logic Unit/Function Generator
74386 
Quad XOR gates
74390 
Dual Decade Counters
74393 
Dual 4-bit Binary Counters
74425 
Tri-state Quad Buffers
74426 
Tri-state Quad Buffers
74445 
BCD to Decimal Decoder/Driver (open collector)
74490 
Dual BCD Counters
❑ ❑ ❑

439
T
his section presents the pinout conﬁ guration of some commonly used integrated circuits 
of 74 series for ready reference. These may be helpful for logic designers. Open collector 
ICs of TTL are marked with a (*). Similar to the open collector TTL devices, CMOS 
devices with open drain output conﬁ guration are also marked with a (*).
G N D
G N D
V cc
V cc
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
    7400/7403*/7426*/7437/7438*/74132
7401*/7439
G N D
G N D
V cc
V cc
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
7402/7428/7433*/74128
7404/7405*/7406*/7416*
PIN CONFIGURATION OF
74 SERIES INTEGRATED
CIRCUITS
3
A p p e n d i x

440
DIGITAL PRINCIPLES AND LOGIC DESIGN
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Vcc
Vcc
  7407*7417
 7408/7409*
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Vcc
Vcc
      7410/7412*
7411/7415*
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Vcc
V cc
  7413
 7414
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Vcc
Vcc
      7420/7422*/7440
  7421

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 441
Strobe
Strobe
Strobe
Strobe
X
X′
G N D
G N D
7
8
6
7
5
6
4
5
3
4
13
14
12
13
11
12
10
11
9
10
8
9
2
3
14
15
16
1
2
1
Vcc
Vcc
7423
   7425
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
V cc
V cc
    7427
  7430
G N D
G N D
7
8
6
7
5
6
4
5
3
4
13
14
12
13
11
12
10
11
9
10
8
9
2
3
14
15
16
1
2
1
Y8
Y0
Y1
Y5
Y4
Y6
Y7
Y3
Y9
A
D
B
C
Y2
Vcc
Vcc
7432
7441*/74141*
f
B
g
C
a
LT
b
BI/
c
R B I
d
D
e
A
G N D
G N D
8
8
7
7
6
6
5
5
4
4
14
14
13
13
12
12
11
11
10
10
9
9
3
3
15
15
16
16
2
2
1
1
Y0
Y1
Y2
Y3
Y4
Y5
Y6
A
B
C
D
Y9
Y8
Y7
RBO
Vcc
Vcc
 7442/7443/7444/7445*/74145*/74445
7446*/7447*/74246*/74247*

442
DIGITAL PRINCIPLES AND LOGIC DESIGN
f
f
B
B
g
g
C
C
a
a
BI
LT
b
b
D
BI/
c
c
A
R B I
R B O
d
d
e
D
e
A
G N D
8
7
6
5
4
14
13
12
11
10
9
3
15
16
2
1
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Vcc
V cc
 7448/74248
7449*/74249*
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
X′
X
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Vcc
Vcc
    7450
     7451
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
I
B
H
X′
G
X
F
H
X
G
Y
Y
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
A
A
C
C
D
D
E
E
F
B
V cc
V cc
7452
7453

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 443
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
B
H
G
F
H
E
G
X′
Y
Y
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
A
A
D
C
E
D
F
X
C
B
Vcc
V cc
    7454
7455
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
D 1
X1'
D 2
X1
X2
X2
X2'
C 3
B3
Y3
A3
Y1
Y2
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
A1
A1
C 1
C 1
A2
A2
B2
B2
C 2
C 2
B1
B1
Vcc
V cc
   7460
7461
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
J
J
I
I
Y
Y
H
H
G
G
F
F
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
A
K
C
B
D
C
E
D
X′
E
B
A
Vcc
Vcc
    7461
7464/7465*

444
DIGITAL PRINCIPLES AND LOGIC DESIGN
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
J1
S1
J2
S2
J3
S3
Q '
Q '
S = S1.S 2.S3     R  = R 1.R 2.R 3
J = J1.J2.J3'     K = K 1.K2.K3'
Cr
Cr
Pr
Pr
CK
CK
K2
R3
K1
R2
K3
R1
Q
Q
Vcc
V cc
7470
7471
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
J1
K1
J2
J2
J3
Q '
Cr
Cr1
Cr2
CK1
CK2
Pr
Q1'
J1
CK
Q1
K3
K2
K2
K1
Q2
Q
Q2'
J = J1.J2.J3   K = K 1.K2.K3
V cc
V cc
7472/74110
7473/74103
Q 1'
D 1
D 2
C K 3/4
D 3
G N D
8
7
6
5
4
14
13
12
11
10
9
3
15
16
2
1
D4
Q4'
G N D
7
6
5
4
3
13
C r2
D 2
C K 2
Pr2
Q 2
Q 2'
12
11
10
9
8
2
14
1
C K 1
D 1
Q1
Q2
Q2' CK1/2
Q3'
Q3
Q4
Cr1
Pr1
Q1
Q1'
V cc
V cc
  7474
7475

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 445
C K 1
J1
G N D
8
7
6
5
4
14
13
12
11
10
9
3
15
16
2
1
Pr2
CK2
Cr2
G N D
7
6
5
4
3
13
Q 2
Q 1
C K 1/2
Q 3
Q 4
12
11
10
9
8
2
14
1
C K 3/4
D 1
D 2
K1
Q1
Q1'
Q2
K2
Q2'
J2
D3
D4
Pr1
Cr1
Vcc
Vcc
 7476/74106
   7477
G N D
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
B1
B2
Ac
A*
A2
A1
C K
K2
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Q 1'
J1
B*
K1
Bc
Q 1
S
Q2'
S'
Q2
Pr2
Cr
Pr1
J2
Cn
Cn+1
Vcc
Vcc
    7478
          7480
A3
B2
G N D
8
7
6
5
4
14
13
12
11
10
9
3
15
16
2
1
B1
S1
A1
G N D
7
6
5
4
3
13
B2
A1
S1
C out
12
11
10
9
8
2
14
1
B0
S0
A0
B3
S3
Cout
Cin
B0
A0
S0
Cin
S2
A2
Vcc
Vcc
    7482
   7483

446
DIGITAL PRINCIPLES AND LOGIC DESIGN
B3
A>B
A>B
A=B
A<B
G N D
8
7
6
5
4
14
13
12
11
10
9
3
15
16
2
1
A3
B2
A2
B1
A1
A0
B0
A<B
A=B
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Vcc
V cc
7485
   7486
A0
G N D
8
7
6
5
4
14
13
12
11
10
9
3
15
16
2
1
DO1
DI1
A1
A2
A3
CE'
R/W '
G N D
7
6
5
4
3
13
A4
Y4
A3
Y3
B
12
11
10
9
8
2
14
1
Y1
C
A1
A2
Y2
DI0
DO0
DI3
D03
DI2
DO2
Vcc
V cc
   7487
7489*/74289*
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
Q
Q '
A
A
B
C K '
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
R 2
B
R 1
S2
S1
Qa
Qd
Qb
Qc
Vcc
V cc
     7490
          7491

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 447
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
Q a
Q d
A
A
Q A
Q b
Q C
Q b
Q d
Q c
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
B
R1
R2
R2
R1
B
Vcc
Vcc
7492
   7493
1A
JD
G N D
8
7
6
5
4
14
13
12
11
10
9
3
15
16
2
1
Ser
In
Load
1
CK
G N D
7
6
5
4
3
13
Q a
Q b
Q c
Q d
R S
C K 1
LS
C K 2
12
11
10
9
8
2
14
1
B
C
Ser
In
A
2A
Pr
2
Load
2B
Pr
2D
Pr
2C
Pr
Cr
out
D
M ode
Con
1B
1C
V cc
Vcc
7494
7495
A
C
C
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
E
M
D
D
Load
CK1
A
CK
J
B
B
G N D
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Cr
K'
Qa
Qa
Qb
Qb
Qd
Qd'
Qc
Qc
Qe
Qd
In
Ser
CK2
Vcc
Vcc
7495
7499

448
DIGITAL PRINCIPLES AND LOGIC DESIGN
74100
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
C K
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
J2
J2a
J2b
C r
J1a
J1
J1b
J3
Pr
Q′
Q
Pr
K3
K2
K1
Q
CK
K2a
K2b
K1b
K1a
Q'
V cc
V cc
  74101
  74102
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Q 1
Q 1'
K1
J1
J1
K1
Q 1'
Q 1
Q2
Q2'
Q2'
Q2
Cr1
Pr1
CK1
Cr
K2
J2
Cr2
Pr2
CK2
CK
J2
K2
V cc
Vcc
  74107
      74108

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 449
J1
C K 1
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Q1'
Q1'
Q1
Q1
Pr1
J1
CK1
Pr1
K1
Cr1
Cr1
K1'
G N D
14
14
13
13
12
12
11
11
9
9
10
10
15
15
16
16
K2
Cr2
Pr2
J2
CK2
Pr2
Cr2
K2'
J2
CK2
Q2'
Q2
Q2
Q2'
GND
Vcc
Vcc
    74109
  74111
8
7
6
5
4
3
2
1
K1
CK1
J1
G N D
G N D
14
13
12
11
10
9
15
16
Cr1
J2
Cr2
Pr2
CK2
Q2
K2
Pr1
Q1
Q1'
Q2'
7
6
5
4
3
13
K2
12
11
10
9
8
2
14
1
CK2
J2
Pr2
Q2
Q2'
CK1
Pr1
K1
Q1
J1
Q1'
Vcc
V cc
   74112
    74113
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
A1
J1
K1
A2
Q '
C r
B
Q1
Q
Q1'
CK
K2
J2
Pr2
Q2
Cext
Rint
Rext
Cext
Q2'
Pr1
Vcc
Vcc
    74114
74121

450
DIGITAL PRINCIPLES AND LOGIC DESIGN
1
24
2
23
Q3
D3
Q2
D2
Q1
D1
Q0
D0
E1
E0
M R
E0
M R
E1
D0
Q0
D2
D1
Q2
Q1
D3
Q3
GND
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
12
13
V cc
74116
A1
Q 1'
Q 2
8
7
6
5
4
3
2
1
Rext2/
Cext 2
Cext 2
B1
Cr1
G N D
14
13
12
11
10
9
15
16
Rext2/
Cext2
Cext2
Cr2
Q2'
Q1
B2
A2
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
B1
B2
A1
A2
Cr
Q
Rext/
Cext
Rint
Cext
Vcc
V cc
    74122
74123
8
7
6
5
4
3
2
1
Y1
G1'
Cext 1
Vc
GND
Freq
Con2
Freq
Con1
Range1
G N D
14
13
12
11
10
9
15
16
Vc R ange 2
Cext 2
Y2
G2'
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Cext 2
V cc
Vcc
74124
   74125/74425

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 451
8
7
6
5
4
3
2
1
G N D
G N D
14
13
12
11
10
9
15
16
13
2
14
1
5
4
3
12
11
10
6
9
7
8
V cc
Vcc
74126/74426
74133
3
3
2
2
1
1
14
14
15
15
16
16
8
8
7
7
6
6
5
5
4
4
G N D
G N D
13
13
12
12
11
11
10
10
9
9
Vcc
V cc
  74134
  74135
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
S0
EN
S1
S0
Select
Enable
S2
S1
G3
Y0
G2
Y1
G1
Y2
Y7
Y3
Y0
EN
Y1
S0
Y2
S1
Y3
Y0
Y4
Y1
Y5
Y2
Y6
Y3
Vcc
Vcc
   74138
  74139

452
DIGITAL PRINCIPLES AND LOGIC DESIGN
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
I4
I4
I5
I5
I6
I6
I7
I7
I8
EI
C
A2
B
A1
E0
D
GS
I3
I3
I2
I2
I1
I1
I9
I0
A
A0
V cc
Vcc
  74147
74148
1
24
2
23
I8
I9
I10
I11
I12
I13
I14
I15
A
I6
I7
I5
I4
I3
I2
I1
I0
Strb
Out
D
(D ata
Select)
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
GND
12
13
B
C
Data Select
V cc
74150
3
2
1
14
15
16
5
4
G N D
13
12
11
8
7
6
10
9
D3
D2
D1
D0
Y
Y'
Strb
D4
D5
D6
D7
A
B
C
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
I5
I6
I7
S0
S1
S2
I4
I3
I2
I1
I0
Y'
V cc
Vcc
   74151A
74152

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 453
1C 2
1C 1
1Y3
1Y2
1Y1
1Y0
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
1Y
1C0
B
G1
1G
Data C 1
1C3
B
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
2G
Data C 2
A
G2
2Y2
2C3
2C2
2C1
2C0
2Y
A
2Y3
2Y1
2Y0
G N D
G N D
Vcc
Vcc
    74153
74155/74156*
1
24
2
23
A
B
C
D
G2
G1
Y15
Y14
Y13
Y12
Y11
Y1
Y0
Y2
Y3
Y4
Y5
Y6
Y7
Y8
Y9
Y10
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
GND
12
13
V cc
74154/74159*
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
Cr
A1
CK
B1
Pa
Y1
Pb
A2
Pc
B2
Pd
Y2
EN
RC
A4
Strb
Qa
B4
Qb
Y4
Qc
A3
Qd
B3
EN
Y3
Load
Sel
Vcc
V cc
74157/74158
74160/74161/74162/74163

454
DIGITAL PRINCIPLES AND LOGIC DESIGN
3
2
1
14
15
16
5
4
G N D
13
12
11
8
7
6
10
9
Shift/
Load
CK
E
F
G
H
Q'
CK
Inh
D
C
B
A
Ser
In
Q
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Qh
Qg
Qf
Qe
Cr
CK
A
B
Qa
Qb
Qc
Qd
V cc
V cc
   74164
74165
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
U/D'
Ser
In
CK
A
Pa
B
Pb
C
Pc
D
Pd
CK
Inh
EN
CK
Ripple
Carry
out
Shift/
Load
Qa
H
Qb
Q
Qc
G
Qd
F
EN
E
Load
Cr
GND
V cc
V cc
  74166
74168/74169
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
Cr
Cr
Q1
Q1
Q1'
D1
D1
D2
D2
Q2
Q2'
Q2
D3
Q3
Q4'
Q4
D6
Q6
D4
D5
D3
Q5
Q3'
D4
Q3
Q4
CK
CK
GND
V cc
V cc
   74174
 74175

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 455
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
C
Cr
D
Qd
Shift
Pd
Qd
Pb
Load
Qb
Qc
A
B
Load
A
Qc
Ser
In
Pc
Qa
Pa
CK
Qa
Qb
B
V cc
V cc
74176/74177/74196/74197
 74178
3
2
1
14
15
16
5
4
G N D
13
12
11
8
7
6
10
9
Cr
B
A
Ser
In
Qa
CK
Qb
C
D
Shift
Qd'
Qd
Load
Qc
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
F
E
D
C
B
A
G
H
Even
In
Odd
In
Even
Out
Odd
Out
V cc
V cc
  74179
    74180
1
24
2
23
A1
B1
A2
B2
A3
B3
G
Cn + 4
P
A = B
F3
B0
A0
S3
S2
S1
S0
Cn
M
F0
F1
F2
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
12
13
GND
V cc
74181

456
DIGITAL PRINCIPLES AND LOGIC DESIGN
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
Y1
G1
Y2
P1
Y3
G0
Y4
P0
Y5
G3
Y6
P3
Y7
Pout
E
G
G2
P2
D
Cn
C
Cn+x
B
Cn+y
A
G
Y8
Cn+z
GND
V cc
V cc
            74182
74184/74185
Up
Down
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
Pb
Pb
Qb
Qb
Qa
Qa
Count Count
G
U/D
Qc
Qc
Qd
Qd
Cr
Pa
CK
Pa
Borrow
Clock
Ripple M ax/
Carry
M in
Load
Load
Pc
Pc
Pd
Pd
GND
V cc
V cc
       74190/74191
74192/74193
3
3
2
2
1
1
14
14
15
15
16
16
5
5
4
4
G N D
13
13
12
12
11
11
8
8
7
7
6
6
10
10
9
9
Cr
Cr
J
Ser In
Parallel In
Ser
In
Right
K'
A
A
B
B
C
C
D
D
Ser
In
Left
Qb
Qa
Qb
Qa
Qc
Qc
Qd
Qd
Qd'
CK
CK
S1
Shift
Load
S0
GND
V cc
V cc
74194
74195

PIN CONFIGURATION OF 74 SERIES INTEGRATED CIRCUITS 457
1
24
2
23
S1
Ser In
Left
H
Qh
G
Qg
F
Qf
E
Qe
Cr
Ser In
Right
S0
A
Qa
Qb
B
C
Qc
D
Qd
CK
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
12
13
GND
V cc
74198
1
24
2
23
SH /
Load
H
Qh
G
Qg
F
Qf
E
Qe
Cr
CK
J
Ser In
K'
A
Qa
Qb
B
C
Qc
D
Qd
CK
Inh
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
12
13
GND
V cc
74199
M E 2
Q 1′
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
D
Y
Cext2 Cext2/
Rext2
M E3
Q2
B
B1
A
A1
M E1
Cr1
G N D
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
C
Cext1
H
Cext1
G
Cr2
In
Q1
EN
Q2'
F
B2
E
A2
Data W R
Rext1/
V cc
  74206*
 74221

458
DIGITAL PRINCIPLES AND LOGIC DESIGN
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
11
GND
V cc
74240
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
11
GND
V cc
74241
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
11
GND
V cc
     
3
2
1
14
15
16
5
4
G N D
13
12
11
8
7
6
10
9
A0
A1
Da
Q0a
Q1a
Q2a
Q3a
E
Cr
Db
Q3b
Q2b
Q1b
Q0b
V cc
74244
74256

459
T
he 4000 series of integrated circuits represents the CMOS IC logic family. This section 
presents the available 4000 series of ICs for ready reference for logic designers. The IC 
numbers given here are with the reference of their functions. However, the actual IC numbers 
as speciﬁ ed by the manufacturers also indicate the electrical and physical characteristics. 
IC Number 
Function
4000 
Dual 3-input NOR gates, one inverter
4001 
Quad 2-input NOR gates 
4002 
Dual 4-input NOR gates
4006 
Shift register with variable length (maximum 18 bits)
4007 
Dual Complementary pair MOS, one inverter
4008 
4-bit Full-Adder
4009 
Hex Inverters/Buffers
4010 
Hex Buffers, noninverting
4011 
Quad 2-input NAND gates 
4012 
Dual 4-input NAND gates 
4013 
Dual D Flip-ﬂ ops with Preset and Clear 
4014 
8-bit Parallel Input Shift Register 
4015 
Dual 4-bit Serial-in Parallel-out Shift Register
4016 
Quad Bilateral Analog/Digital Switches
4017 
Synchronous Decimal Up-counter with Decimal Decoder
4018 
5-bit Programmable Divider/Counter
4019 
Quad 2:1 Common Addressable Multiplexers
4020 
Asynchronous 14-bit Binary Up-counter
4021 
8-bit Parallel Input Shift Register
4022 
Synchronous Octal Counter with Decoded Outputs
4000 SERIES
INTEGRATED CIRCUITS
4
A p p e n d i x

460
DIGITAL PRINCIPLES AND LOGIC DESIGN
4023 
Triple 3-input NAND gates 
4024 
Asynchronous 7-bit Binary Up-counter 
4025 
Triple 3-input NOR gates 
4026 
Decimal Up-counter with Seven Segment Decoder
4027 
Dual Positive Edge-triggered J-K Flip-ﬂ op with Preset and Clear
4028 
BCD-to-Decimal Decoder
4029 
Synchronous 4-bit Binary Up-down Counter with Preset
4030 
Quad 2-input XOR gates
4031 
64-bit Serial Shift Register
4032 
Triple Serial Adder
4033 
Decimal Up-counter with Seven Segment Decoder and Ripple Blanking
4034 
8-bit Bi-directional Bus Register
4035 
4-bit Parallel Input/Parallel Output Shift Register with Clear
4036 
4 × 8-Bit RAM
4037 
Triple AND/OR Combination Gates
4038 
Triple Serial Adder (Negative Logic)
4039 
4 × 8-Bit RAM
4040 
Asynchronous Binary 12-bit Counter
4041 
Quad True/Complement Buffers
4042 
Quad D Flip-ﬂ ops with Common Clock
4043 
Quad NOR-gated R-S Flip-ﬂ ops
4044 
Quad NAND-gated R-S Flip-ﬂ ops
4045 
Asynchronous Binary 21-bit Up-counter 
4046 
Phased Locked Loop (PLL)
4047 
Monostable/Astable Multivibrator
4048 
8-input Multifunction Gate
4049 
Hex Inverters/Buffers
4050 
Hex Buffers/TTL Drivers
4051 
8:1 Analog/Digital Multiplexer
4052 
Dual 4:1 Analog/Digital Multiplexers
4053 
Triple 2:1 Analog/Digital Multiplexers
4054 
4-segment LCD Driver
4055 
BCD-to-Seven Segment Decoder/LCD Driver
4056 
BCD-to-Seven Segment Decoder/LCD Driver with Memory
4059 
16-bit Programmable Divider
4060 
Asynchronous Binary 14-bit Up-counter with Internal Oscillator
4062 
200-bit Dynamic Serial Shift Register

4000 SERIES INTEGRATED CIRCUITS 461
4063 
4-bit Comparator
4066 
Quad Bilateral Analog/Digital Switches
4067 
16-channel Analog/Digital Multiplexer/Demultiplexer
4069 
Hex Inverters
4070 
Quad 2-input XOR gates
4071 
Quad 2-input OR gates 
4072 
Dual 4-input OR gates 
4073 
Triple 3-input AND gates
4075 
Triple 3-input OR gates
4076 
4-bit D-Latches, noninverting
4077 
Quad 2-input XNOR gates
4078 
8-input OR/NOR gate
4081 
Quad 2-input AND gates
4082     
Dual 4-input AND gates
4085 
Dual 2-input AND/NOR Combination gates
4086 
Dual 2 × 2-input Expandable AND/NOR Combination gates
4089 
Binary Rate Multiplier
4093 
Quad 2-input NAND Schmitt Trigger
4094 
8-bit Shift Register with Output Latches
4095 
Positive Edge-triggered J-K Flip-ﬂ op AND Input with Preset and Clear
4096 
Positive Edge-triggered J-K Flip-ﬂ op AND Input with Preset and Clear 
4097 
Dual 8-channel Analog/Digital Input Multiplexers/Demultiplexers
4098 
Dual Monostable with Schmitt Trigger Input and Clear
4099 
8-bit Addressable D Latch
40014 
Hex Schmitt Trigger
40085 
4-bit Comparator
40097 
Hex Buffers/Drivers
40098 
Hex Inverters
40100 
32-bit Left/Right Serial Shift Register
40101 
9-bit Parity Generator/Parity Checker
40102 
Synchronous 2-decade Down-counter with Preset
40103 
Asynchronous 8-bit Down-counter with Preset
40104 
4-bit Parallel-in/Parallel-out Left/Right Shift Register
40105 
16 × 4-bit FIFO
40106 
Hex Schmitt Trigger Inverters
40107 
Dual 2-input NAND Drivers
40108 
4 × 4 Multiport Register

462
DIGITAL PRINCIPLES AND LOGIC DESIGN
40109 
Quad Level Changer, noninverting
40110 
Decimal Up-down Counter with Register, Seven Segment Decoder Driver
40117 
Dual 4-bit Data Switch
40147 
BCD Priority Encoder
40160 
Synchronous Decimal Up-down Counter with Preset and Clear
40161 
Synchronous 4-bit Binary Up-down Counter with Preset and Clear 
40162 
Synchronous Decimal Up-down Counter with Preset and Clear 
40174 
6-bit D Register with Clear, noninverting
40175 
4-bit D Register with Clear, noninverting
40181 
4-bit ALU
40182 
Carry Unit for 40181
40192 
Synchronous Decimal Up-down Counter with Preset
40194 
4-bit Parallel-in/Parallel-out with Right/Left Shift 
40195 
4-bit Universal Shift Register
40198 
Synchronous 4-bit Binary Up-down Counter with Preset
40208 
4 × 4-bit Multiport Register
40240 
8-bit Bus Line Driver with 2 Enable Inputs, inverting type
40244 
2 × 4-bit Bus Driver with Separate Enable Input, noninverting
40245 
Octal Bus Transceiver, noninverting
40257 
Quad 2:1 Multiplexers
40373 
8-bit D Latch with Enable, noninverting
40374 
8-bit D Latch with Enable, noninverting
40511 
BCD to Seven Segment Decoder/Memory/Driver (Hexadecimal Code) 
4104 
Quad TTL/CMOS Level Changer 
4402 
Dual 4-input NOR gate with Transistor Output
4412 
Dual 4-input NAND gate with Transistor Output
4415 
Quad Precision Timers/Drivers
4426 
Decimal Up-counter with Seven Segment Decoder
4428 
Binary to Octal Decoder
4433 
Decimal Up-counter with Seven Segment Decoder and Ripple Blanking
4441 
Quad True/Complement Buffers
4449 
Hex True/Complement Buffers
4490 
Hex Contact Bounce Eliminator
4500 
1-bit Processing Unit
4501 
Dual 4-input NAND gate, 2-input NOR/OR gate 
4502 
Hex Inverters/Buffers with Inhibit and Enable 
4503 
Hex Buffers/Drivers

4000 SERIES INTEGRATED CIRCUITS 463
4504 
Hex TTL/CMOS or CMOS/CMOS Level Shifter
4505 
64 × 1-bit RAM 
4506 
Dual Expandable AND/OR/INVERTER Combination gates 
4507 
Quad 2-input XOR gates 
4508 
Dual 4-bit R-S Flip-ﬂ ops
4510 
Synchronous Decimal Up-down Counter with Preset
4511 
BCD-to-Seven Segment Decoder/Memory/Driver
4512 
8:1 Data Selector/Multiplexer with Enable
4513 
BCD to Seven Segment Decoder/Memory/Driver with Ripple Blanking
4514 
4-bit Binary Decoder/Demultiplexer with Input Latch
4515 
4-bit Binary Decoder/Demultiplexer with Input Latch
4516 
Synchronous 4-bit Binary Up-down Counter with Preset
4517 
Dual 64-bit Serial Shift Register
4518 
Dual Synchronous Decimal Up-counter 
4519 
Quad Common Addressable 2:1 Multiplexers
4520 
Dual Synchronous Binary Up-counter 
4521 
24-bit Binary Counter/Divider
4522 
BCD Down-counter with Preset
4524 
256 × 4-bit ROM
4526 
4-bit Binary Down-counter with Preset
4527 
Decimal Rate Multiplier
4528 
Dual Post Triggerable Monostable with Clear
4529 
Dual 4-channel Analog Multiplexers
4530 
Dual 5-input Majority Logic Gate
4531 
12-bit Parity Unit
4532 
3-bit Priority Encoder
4534 
Pental Count Decades with Multiplexed Outputs
4536 
Programmable Timer
4537 
256 × 1-bit RAM
4538 
Dual Post-Triggerable Precision Monostable 
4539 
Dual 4:1 Data Selector/Multiplexer
4541 
Programmable Timer with RC Oscillator
4543 
BCD-to-Seven Segment Decoder/Memory/-Driver
4544 
BCD-to-Seven Segment Decoder/Memory/Driver with Ripple Blanking
4547 
BCD-to-Seven Segment Decoder/Memory/Driver
4548 
Dual Post-Triggerable Precision Monostable
4549 
8-bit Register for Successive Approximation in A/D Changer
4551 
Quad 2-channel Analog Multiplexers
4552 
64 × 4-bit RAM

464
DIGITAL PRINCIPLES AND LOGIC DESIGN
4553 
3-place Decimal Up-counter
4554 
Dual 2-bit Parallel Binary Multiplier
4555 
Dual 4-channel Demultiplexers
4556 
Dual 4-channel Demultiplexers 
4557 
64-bit Presettable Serial Shift Register
4558 
BCD-to-Seven Segment Decoder
4559 
8-bit Register for Successive Approximation in A/D Changer
4560 
4-bit BCD Adder
4561 
9’s Complementer
4562 
128-bit Shift Register with Parallel Outputs 
4566 
Universal Time Base Generator
4568 
Phase Comparator and Counter with Preset
4569 
Dual Fast 4-bit Down-counter with Preset
4572 
Quad INVERTERs, 2-input NOR gate and 2-input NAND gate
4573 
Quad Programmable OPAMP
4574 
Quad Programmable Comparators
4575 
Dual Programmable OPAMP and Comparator
4578 
Comparator with Voltage Follower
4580 
4 × 4-bit Multiport Register
4581 
4-bit ALU
4582 
Carry Generator
4583 
Dual Schmitt Trigger with Presettable Hysterisis
4584 
Hex Schmitt Trigger Inverters
4585 
4-bit Comparator
4597 
8-bit D Latch with Address Counter Bus Compatible
4599 
8-bit Addressable D Latch
4720 
256 × 1-bit RAM
4723 
Dual 4-bit Addressable D Latch with Clear
4724 
8-bit Addressable D Latch
4731 
Quad 64-bit Serial Shift Register
4737 
4½  Decade Counter
4738 
IEC/IEEE Bus Interface
4750 
Frequency Syntheszer
4751 
Universal Programmable 5-stage Frequency Divider
4752 
AC Motor Control Circuit
4753 
Universal Time Base Generator
4754 
18 Elements Bar Graph LCD Driver
4755 
Transceiver Serial Data Communication
❑ ❑ ❑

465
T
his section presents the pinout conﬁ guration of some commonly used integrated circuits 
of 4000 series for ready reference. These may be helpful for logic designers. The pin 
conﬁ gurations given here are for DIP packages only. Designers must refer to the data books 
of the manufacturers for other types of packages like SMD (Surface Mount Devices), etc.
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
V dd
Vdd
     4000
     4001
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Q1+4 Q3+5 Q3+4 Q2+4 Q4+5 Q4+4
D1
CK
D3
D2
D4
Vdd
Vdd
   4002
    4006
PIN CONFIGURATION
OF 4000 SERIES
INTEGRATED CIRCUITS
5
A p p e n d i x

Vss
7
6
5
4
3
13
12
11
10
9
8
2
14
1
B2
A2
8
7
6
5
4
3
2
1
A1
B1
B3
A4
A3
G N D
14
13
12
11
10
9
15
16
B4
CY0
S2
S3
S4
S1
CY1
Vdd
V dd
   4008
       4009
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
G N D
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Vcc
Vcc
Vdd
Vdd
4009
4010
5
5
4
4
3
3
13
13
12
12
11
11
10
10
2
2
14
14
1
1
G N D
G N D
7
7
6
6
9
9
8
8
Vdd
V dd
4011/4093
  4012
466
DIGITAL PRINCIPLES AND LOGIC DESIGN

D 3
D 2
8
7
6
5
4
3
2
1
D0
D1
GND
Q5
D7
Q1
Q2
Q1'
Q2'
CK1
CK2
R1
R2
D1
D2
S1
S2
Q7
14
13
12
11
10
9
15
16
D6
D5
D4
CK
Q6
D8
L/S'
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Vdd
V dd
   4013
   4014/4021
1Q 1
1Q 0
8
7
6
5
4
3
2
1
1D
1R
GND
2Q3
2CK
1Q2
14
13
12
11
10
9
15
16
2D
2R
2Q0
1Q3
2Q1 2Q2
1CK
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
V dd
Vdd
   4015
     4016/4066
Q 1′
Q 0'
Q 2
Q 6
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
D2
Q2′
Q7
Q3
GND
D0
Q1
D5
Q5
D1
Q0
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
D4
M R
Cr
CK
CK
Q3'
Q9
CY0'
Q4'
EN '
CK
PL
Q4
D3
Q8
V cc
Vdd
    4017
4018
PIN CONFIGURATION OF 4000 SERIES INTEGRATED CIRCUITS 467

Q 6
Q 5
A2
B2
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Q4
Q7
A1
B1
GND
Q13
A3
Q12
B4
Q14
B3
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Q9
Q11
A4
Q10
B
Cr
Q2
Q3
Q8
Q4
SEL
SEL
CK
Q1
Q1
A
Vdd
V dd
     4019
4020
Q 5
Q 6
8
7
6
5
4
3
2
1
Q3
Q0
Q1
Q2
G N D
14
13
12
11
10
9
15
16
Cr
CK
Q4
CY0'
EN '
CK
Q7
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Vdd
Vdd
      4022
   4023
  4024
        4025
468
DIGITAL PRINCIPLES AND LOGIC DESIGN

D S P
1R
C Y 0
1K
f
1J
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
g
1S
CK
1Q'
EN '
IN
OUT
CK
1Q
DSP
1CK
G N D
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
R
2Q
Q2
2Q'
e
2K
b
2R
c
2CK
a
2J
d
2S
Vdd
V dd
      4026
4027
C Y 1′
7
9
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
CY0'
Q0
5
6
GND
Q3
2
SEN
4
D3
0
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
D1
CK
3
Q2
1
Q1
D3
D2
D2
D1
U/D'
D0
B/D'
8
D0
V dd
Vdd
    4028
4029
3
2
1
14
15
16
5
4
G N D
13
12
11
8
7
6
10
9
DSB
CK
Q
Q'
DSA
M C
CK Out
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
V dd
Vdd
4030/4070
4031
PIN CONFIGURATION OF 4000 SERIES INTEGRATED CIRCUITS 469

C Y 0
IN V2
S2
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
g
f
Cr
IN V1
GND
CK
EN
IN V3
CK
S3
RBI'
CK
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
b
R
A3
LT
B3
e
B1
B2
c
A2
a
A1
d
S1
RBO
Vdd
Vdd
 4032/4038
     4033
A6
A5
A4
A3
A2
A1
A0
A/S'
CK
P/S'
B5
B4
B3
B2
B1
B0
STR
DS
A/B'
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
12
13
GND
1
24
2
23
A7
B6
B7
V dd
4034
Q 4
J
R
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Q2
Q3
CK
P/S'
GND
Q6
T/C'
Q12
Q0
Q5
K
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Q9
Q11
Q1
Q10
Q2
Cr
D2
D3
Q8
Q3
CK
D1
Q1
D0
Q7
V dd
V dd
     4035
      4040
470
DIGITAL PRINCIPLES AND LOGIC DESIGN

C-
IN H
R-
IN H
Q0
Q1
Q2
Q3
Q4
Q6
Q5
Q7
D0
D1
D2
D3
D4
D5
D6
D7
M B
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
12
13
GND
1
24
2
23
A0
W /R
A1
Vdd
4036
Q0
W D3
Q1
W D2
Q2
Q3
Q4
Q6
Q5
Q7
D0
D1
D2
D3
D4
D5
D6
D7
M B
3
22
4
21
5
20
6
19
7
18
8
17
9
16
10
15
11
14
12
13
GND
1
24
2
23
W D4
W /R
W D1
Vdd
4039
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
3
2
1
14
15
16
5
4
G N D
13
12
11
8
7
6
10
9
Q1
Q2
Q2'
D2
CK
PO L
D4
D1
Q1'
D3
Q3'
Q3
Q4
Q4'
V dd
V dd
   4041
4042
PIN CONFIGURATION OF 4000 SERIES INTEGRATED CIRCUITS 471

EN
S1
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
S2'
R2'
S2
R2
GND
D0
Q1
Q4
Q4
S1'
R1
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
R3'
S4'
R4
R4'
S4
S3'
R3
S3
Q1
Q3
Q3
Q2
Q2
R1'
EN
Vdd
V dd
4043
         4044
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Cext
Q'
Cext
Q
GND
GND
PC 1
SN
PC P
SP
COM
IN
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Rext
PC 3
Qext2
Qext1
SIG
IN
Rext
PC 2
OUT
DEM
IN
VC O
VC O
OUT
IN H
Vdd
Vdd
  4045
4046
F
8
7
6
5
4
3
2
1
S1
E
GND
EN
Q
H
14
13
12
11
10
9
15
16
C
EXP
A
D
B
S2
S0
G
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
R ext/
C ext
AS T′
C ext R ext
AST
TR
OUT
OSC
RETR
Q'
Q
R
TR+
V dd
V dd
 4047
4048
472
DIGITAL PRINCIPLES AND LOGIC DESIGN

8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
G N D
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Vdd
Vdd
4049
          4050
2X1
X7
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Vee
EN '
EN '
Vee
GND
2X2
X6
2X0
X4
Y2
Y
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
1X0
1X2
X2
1X1
X1
X0
1X3
S0
X3
Y1
S0
S1
S1
S2
2X3
X5
V dd
Vdd
4051
4052
Q 2
Y3
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Vee
Q1
EN '
Vee
GND
DF1
2X0
STR4
2X1
Q4
3X1
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
STR2
D4
Y2
STR3
Y1
1X1
D2
S1
1X0
D3
STR1
S2
D1
S3
Q3
3X0
Vdd
V dd
4053
4054
PIN CONFIGURATION OF 4000 SERIES INTEGRATED CIRCUITS 473

Q 5
8
7
6
5
4
3
2
1
Q4
Q7
GND
Q13
Q12
Q14
14
13
12
11
10
9
15
16
Cr
Q10
Q8
CK
Q9
Rext
Cext
Q6
8
7
6
5
4
3
2
1
DF1
Vee
D2
DF0/
STR
D1
G N D
14
13
12
11
10
9
15
16
q
f
e
c
d
b
a
D0
D3
V dd
Vdd
 4055/4056
   4060
8
7
6
5
4
3
2
1
A=B
A<B
A<B
B3
A=B
G N D
14
13
12
11
10
9
15
16
A3
B2
A2
B1
A1
A0
B0
A>B
A>B
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
Vdd
Vdd
4063
4068
13
13
2
2
14
14
1
1
7
7
6
6
5
5
4
4
3
3
12
12
11
11
10
10
9
9
8
8
G N D
G N D
Vdd
Vdd
4069
4071
474
DIGITAL PRINCIPLES AND LOGIC DESIGN

G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
V dd
Vdd
    4072
     4073
8
7
6
5
4
3
2
1
Q3
CK
EN 02′
EN 01′
Q0
G N D
14
13
12
11
10
9
15
16
M R
D0
D1
D3
D2
EN I2 EN I1
Q2
Q1
G N D
7
6
5
4
3
13
12
11
10
9
8
2
14
1
V dd
Vdd
    4075
  4076
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Vdd
Vdd
 4077/4507
4078
PIN CONFIGURATION OF 4000 SERIES INTEGRATED CIRCUITS 475

G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
Vdd
Vdd
    4081
      4082
G N D
G N D
7
7
6
6
5
5
4
4
3
3
13
13
C K
12
12
11
11
10
10
9
9
8
8
2
2
14
14
1
1
J1
J2
J1
J2
R
R
J3'
J3
Q'
Q'
S
K1
K2
K3'
Q
S
CK
K1
K2
K3
Q
V dd
Vdd
    4095
4096
A0
TR 1+
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
A2
A1
Q1
Q1'
GND
R
Rext1/
Cext1
Q7
Cext1
D
R1'
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Q3
Q6
Cext2
Q5
Rext2/
Cext2
R2'
Q2
TR2–
TR2+
Q4
Q1
Q2
Q0
Q2'
EN '
TR1–
V dd
Vdd
  4098/4528/4538
 4099
476
DIGITAL PRINCIPLES AND LOGIC DESIGN

Q 2
D 1
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Q3
D3
D3
EN 1
GND
Q1
CK
Cr'
Cr'
D1
D0
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Q5
Q6
CY
D6
Q0
Q1
D4
Q3
Q2
D5
Q4
EN 2
CK
S'
D2
D2
V dd
Vdd
   40160/40161/40162/40163
       40174
C K
D 1
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Q3
Q2
D2'
Q2
GND
Q1
Q1
D1
Cr'
Q0
Q1'
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
CYU'
D0
Q4
Cr
Q4'
D4
S'
Q3'
D3
CYD'
D2
Q3
D3
CK
CK
D2
Down Up
Vdd
V dd
40175
40192/40193
D 1
D 1
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
D3
D2
D3
DSL
GND
J
CSR
Cr'
Cr'
K'
D0
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
Q3
Q0
Q0
Q1
Q1
Q2
Q3'
CK
Q3
Q2
CK
S1
S/L'
S0
D0
D2
Vdd
V dd
   40194
   40195
PIN CONFIGURATION OF 4000 SERIES INTEGRATED CIRCUITS 477

EN 2'
Q0'
D7
Q1'
D6
Q2'
D5
D4
Q3'
EN 1'
D0
Q7'
D1
Q6'
D2
Q5'
D3
Q4'
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
GND
11
Vdd
40240
EN 2'
Q0
D7
Q1
D6
Q2
D5
D4
Q3
EN 1'
D0
Q7
D1
Q6
D2
Q5
D3
Q4
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
GND
11
Vdd
40244
EN '
B0
B1
B2
B3
B4
B5
B7
B6
DIR
A0
A1
A2
A3
A4
A5
A6
A7
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
GND
11
Vdd
40245
478
DIGITAL PRINCIPLES AND LOGIC DESIGN

Q7
D7
D6
Q6
Q5
D5
D4
EN 1/CK
Q4
EN 0'
Q0
D0
D1
Q1
Q2
D2
D3
Q3
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
GND
11
V dd
40373/40374
8
8
7
7
6
6
5
5
4
4
3
3
G N D
G N D
14
14
13
13
12
12
11
11
10
10
9
9
2
2
1
1
15
15
16
16
EN '
IN H
Vdd
Vdd
4501
     4502
8
8
7
7
6
6
5
5
4
4
3
3
2
2
1
1
Vcc
G N D
G N D
14
14
13
13
12
12
11
11
10
10
9
9
15
15
16
16
EN 2'
EN 1'
M ODE
Vdd
V dd
     4503
4504
PIN CONFIGURATION OF 4000 SERIES INTEGRATED CIRCUITS 479

8
9
7
8
6
7
5
6
4
5
3
4
2
3
1
2
1
D3
D0
D0
RBI
D2
LT'
D1
D2
D1
LT'
BI'
G N D
G N D
14
15
13
14
12
13
11
12
10
11
9
10
15
16
16
17
18
f
f
g
g
a
a
c
c
b
b
d
d
e
e
RBO
EN '
D3
BI'
EN '
V dd
Vdd
   4511
4513
8
9
7
8
6
7
5
6
4
5
3
4
2
3
1
2
1
PH
BI
BI'
RBO
D2
D1
EN
D2
EN
D1
D3
G N D
G N D
14
15
13
14
12
13
11
12
10
11
9
10
15
16
16
17
18
f
f
g
g
e
e
c
c
d
d
b
b
a
a
RBI
D0
PH
D3
D0
V dd
Vdd
4543
4544
480
DIGITAL PRINCIPLES AND LOGIC DESIGN

Included on the CD-ROM are simulations, ﬁ gures from the text, third party software, 
and other ﬁ les related to topics in digital principles and logic design.
See the “README" ﬁ les for any speciﬁ c information/system requirements related to each 
ﬁ le folder, but most ﬁ les will run on Windows 2000 or higher and Linux.
ABOUT THE CD-ROM
6
A p p e n d i x
481


GLOSSARY
483
Access Time: Time between the memory receiving a new input address and the output 
data’s becoming available in a read operation.
Active Load: A transistor that acts as a load for another transistor.
Active Low: The low state is the one that causes the circuit to become active rather than 
the high state.
Active Power Dissipation: The power dissipation of a device under switching conditions. 
It differs from static power dissipation because of the large current spikes during 
output transitions.
ADC: Analog-to-digital converter.
Addend: Number to be added to another.
Alphanumeric Codes: Codes that present numbers, letters, punctuation marks, and special 
characters.
Arithmetic-Logic Unit (ALU): Digital circuit used in computers to perform various 
arithmetic and logic operations.
Assert: To activate. If an input line has a bubble on it, the input can be asserted by making 
it low.
Astable Multivibrator: Digital circuit that oscillates between two unstable output states.
Asynchronous Transfer: Data transfer performed without the aid of a clock.
Augend: Number to which the addend is added.
Bilateral Switch: CMOS switch which acts like a single-pole, single-through switch (SPST) 
controlled by an input logic level.
Binary Numbers: A number code that uses only the digits 0 and 1 to represent quantities.
Bipolar: Having two types of charge carriers; free electrons and holes.
Bistable Multivibrator: Name that is sometimes used to describe a ﬂ ip-ﬂ op.
Bit: An abbreviation for binary digit. It combines the ﬁ rst letter of binary and the last two 
letters of digit.

484
DIGITAL PRINCIPLES AND LOGIC DESIGN
Buffer/Driver: Circuit designed to have a greater output current and/or voltage capability 
than an ordinary circuit.
Buffer Register: Register that holds digital data temporarily.
Byte: A binary number with 8 bits.
Checksum: Special data word stored in the last ROM location. It is derived from 
the addition of all other data words in the ROM, and is used for error checking 
purposes.
Compatibility: Ability of the output of one device to drive the input of another device.
Contact Bounce: Opening and closing of a set of contacts as a result of the mechanical 
bounce that occurs when the device is switched.
DAC: Digital-to-analog converter.
Data Selector: A synonym for multiplexer.
Decoder: A circuit that is similar to demultiplexer, except there is no data input. The control 
input bits produce one active output line.
Demultiplexer: A circuit with one input and many outputs.
Differential Linearity: A measure of the variation in size of the input voltage to an A/D 
converter which causes the converter to change from one state to the next. 
DIP: Dual-in-line package. This is the most common type of IC package.
Don’t-Care Condition: An input-output condition that never occurs during normal operation. 
Since the condition never occurs, one can use an X on the Karnaugh map. This X can 
be a 0 or 1, whichever is preferable.
Edge Detector: Circuit that produces a narrow positive spike that occurs coincident with 
the active transition of a clock input pulse.
Encoder: Digital circuit that produces an output code depending on which of the inputs 
is activated. 
EPROM: An erasable programmable read-only memory. With this device, the user can erase 
the stored content with ultraviolet light and electrically store new data.
Even Parity: A binary number with an even number of 1s.
Fall Time: The time required for a signal to transition from 90 percent of its maximum 
value down to 10 percent of its maximum.
Fan out: Maximum number of standard logic inputs that the output of a digital circuit 
can drive reliably.
Full-Adder: A logic circuit with three inputs and two outputs. The circuit adds 3 bits at a 
time, giving a sum and carry output. 
Glitch: Very narrow positive or negative pulse that appears as an unwanted signal.
Half-Adder: A logic circuit with two inputs and two outputs. The circuit adds 2 bits at a 
time, giving a sum and carry output. 
Hold Time: The minimum amount of time that data must be present after the clock trigger 
arrives.
Inhibit Circuits: Logic circuits that control the passage of an input signal through to the 
output.

GLOSSARY 485
Karnaugh Map: A drawing that shows all the fundamental products and the corresponding 
output values of a truth table.
LED: A light-emitting diode.
Logic Circuit: A digital circuit, a switching circuit, or any kind of two-state circuit that 
duplicates mental processes and behaves according to a set of logic rules.
Low-Power Schottky TTL (LS-TTL): TTL subfamily that uses the identical Schottky TTL 
circuit but with larger resistor values.
Low-Power TTL: TTL subfamily that uses basic TTL standard circuit except that all 
resistor values are increased.
LSB: Least signiﬁ cant bit.
Millman’s Theorem: A theorem from network analysis which states that the voltage at 
any node in a resistive network is equal to the sum of the currents entering the 
node divide by the sum of the conductances connected to the node, all determined by 
assuming the voltage at the node is zero.
Modulus: Deﬁ nes the number of states through which a counter can progress.
MSB: Most signiﬁ cant bit.
Multiplexer: A circuit with many inputs and one output.
Natural Count: The maximum number of states through which a counter can progress. It 
is given by 2n, where n is the number of ﬂ ip-ﬂ ops in the counter.
Nibble: A binary number with 4 bits.
Octet: Eight adjacent 1s in a 2×4 shape on a Karnaugh map.
Odd Parity: A binary number with odd number of 1s.
Offset Error: Deviation from the ideal zero volts at the output of a digital-to-analog 
converter when the input is all 0s. In reality, there is a very small output voltage for 
this situation.
Overﬂ ow: An unwanted carry that produces an answer outside the valid range of the 
numbers being represented.
Overlapping Groups: Using the same 1 more than once when looping the 1s of a Karnaugh 
map.
Pair: Two horizontally or vertically adjacent 1s on a Karnaugh map.
Percentage Resolution: Ratio of the step size to the full-scale value of a digital-to-analog 
converter. Percentage resolution can also be deﬁ ned as the reciprocal of the maximum 
number of steps of a digital-to-analog converter. 
Priority Encoder: Special type of encoder that senses when two or more inputs are 
activated simultaneously and then generates a code corresponding to the highest-
numbered input.
Product-of-Sums Equation: A Boolean equation that is the logical product of logical sums. 
This type of equation applies to an OR-AND circuit.
Quad: Four horizontal, vertical, or rectangular 1s on a Karnaugh map.
Quantization Error: The error inherent in any digital system due to the size of the 
LSB.

486
DIGITAL PRINCIPLES AND LOGIC DESIGN
Redundant Group: A group of 1s on a Karnaugh map that are all part of other groups. 
Redundant groups may be eliminated.
Rise Time: The time required for a signal to transition from 10 percent of its maximum 
value up to 90 percent of its maximum.
SAR: Sequential approximation register, used in a sequential ADC.
Setup Time: The minimum amount of time required for data inputs to be present before 
the clock arrives.
Static Power Dissipation: The product of DC voltage and current.
Strobe: An input that disables or enables a circuit.
Sum-of-Products Equation: A Boolean equation that is the logical sum of logical products. 
This type of equation applies to an AND-OR circuit.
Timing Diagram: A picture that shows the input-output waveforms of a logical circuit.
Truth Table: Logic table that depicts a circuit’s output response to the various combinations 
of the logic levels at its inputs.
Wired-AND: Term used to describe the logic function created when open-collector outputs 
are tied together.
❑ ❑ ❑

BIBLIOGRAPHY
487
 
1. Taub. H., and D. Schilling, Digital Integrated Electronics, New York; McGraw-Hill 
Book Co., 1977.
 
2. Roth Charles H., Jr., Fundamentals of Logic Design, Mumbai, Jaico Publishing House, 
2003.
 
3. Brown Stephen, and Vranesic Zvonko, Fundamentals of Digital Logic With Verilog 
Design, New Delhi, Tata McGraw-Hill Publishing Co. Ltd., 2002.
 
4. Malvino Albert Paul, and Leach Donald P., Digital Principles and Applications, New 
Delhi, Tata McGraw-Hill Publishing Co. Ltd., 1996.
 
5. Salivahanan S, and Arivazhagan S, Digital Circuits and Design, New Delhi, Vikash 
Publishing House Pvt. Ltd., 2005.
 
6. Mano. M. Morris, Digital Logic and Computer Design, New Delhi, Prentice Hall of 
India, 2001.
 
7. Tocci Ronald J., Digital Systems Principles and Applications, New Delhi, Prentice Hall 
of India, 2001.
 
8. Jain R P, Modern Digital Electronics, New Delhi, Tata McGraw-Hill Publishing Co. 
Ltd., 2001.
 
9. Lee, Samuel C., Digital Circuits and Logic design, New Delhi, Prentice Hall of India, 
2001.
 10. Peatman, J. P., The Design of Digital Systems, New York; McGraw-Hill Book Co., 1972.
11. The TTL Data Book for Design Engineers. Dallas, Texas: Texas Instruments Inc., 1976.
12. MECL Integrated Circuits Data Book. Phonenix, Ariz.: Motorola Semiconductor Products, 
Inc., 1972.
13. RCA Solid State Data Book Series: COS/MOS Digital Integrated Circuits. Somerville, 
NJ: RCA Solid State Div., 1974.
 14. Givone, Donald D., Digital Principles and Design, New Delhi, Tata McGraw-Hill 
Publishing Co. Ltd., 2002.
❑ ❑ ❑


489
ASCII  31, 42, 49
Associative law  52
Asynchronous  291, 292, 301, 327
Asynchronous counter  291, 301, 302, 333
Asynchronous down-counter  298, 299, 300
Asynchronous up-counter  293
Augend  13, 127, 128, 159
B
Basic circuit  378, 382
Basic gate  379, 390, 420
BCD  31, 33, 45, 337
BCD adder  162, 164
BCD to decimal  171
BCD to decimal decoder  171
BCD to seven segment  152, 155, 185
BiCMOS  418, 419, 420
Bidirectional  274, 275
Binary  2, 3, 157, 158
Binary adder  157, 158, 164, 165
Binary addition  13, 17, 27
Binary arithmetic  13, 17
Binary divider  284, 285, 288
Binary division  16
(r–1)’s complement  11
1’s complement  10, 19, 30
10’s complement  10, 23, 30
2’s complement  10, 20, 30
2421  33, 34, 48
84-2-1  32, 33, 34
8421  32, 34
9’s complement  11, 24, 28
A
A/D converter  345, 364, 370, 376
Active pull-up  395
Active region  383, 398, 406, 425
Added  158, 165
Addend  13, 127
Adder  127, 157, 158, 161
Addition  17, 27
Address  195, 198, 202
Adjacent squares  91, 94, 101
Alphanumeric  31, 41
Analysis  215, 250, 251
AND  51, 65, 74, 77, 87
AND gate  72, 73, 74, 75, 76
AND-OR-INVERT  77
INDEX

490
DIGITAL PRINCIPLES AND LOGIC DESIGN
Binary logic  51, 60
Binary multiplication  15
Binary numbers  13, 15, 19
Binary operator  52, 67
Binary parallel adder  157, 158, 159
Bipolar  377, 382, 420, 427
Bit  7, 14, 19
Boolean algebra  51, 52, 53, 84, 85
Boolean function  58, 59, 69, 73
Borrow  14
C
Canonical forms  66
Carry  13, 14, 25, 26
Carry propagate  160
Characteristic equation  225, 228, 231, 
254
Characteristic table  224, 225, 228, 237
Characteristics  378, 379, 417, 418
Chart  103, 104, 105
Circuit model  248
Classiﬁ cation  248
Clocked  216, 220, 221, 260
CMOS  378, 382, 428, 429
CMOS with TTL  421, 428
Code conversion  132, 156
Codes  31, 32, 46, 48
Combinational logic  126, 143, 167, 185
Commutative law  52, 54
Complement  10, 11, 29, 30
Conversion  2, 3, 4, 9
Conversion between  66
Counter  291, 292, 337, 344
Counting type  365
Cut-off  384, 385, 425, 426
D
D ﬂ ip-ﬂ op  225, 226, 260, 261
Darlington pair  397, 407
Data selector  175
DC current gain  383
Decimal  136, 143, 158
Decimal adder  162
Decoder  155, 168, 185
Deﬁ nition  51, 52, 66
Depletion type  413, 428
Design  291, 302, 322, 327
Design of  302, 313, 321, 327
Design procedure  254
Digital circuit  383, 384, 411, 421
Digital system  1, 30
Diode  377, 378, 399, 404
DIP  377
DTL  378, 382, 420, 428
Dual Slope  366, 375, 376
Duality  55, 56, 85
Dynamic hazards  341, 342
E
EBCDIC  42, 47, 49
Edge-triggered ﬂ ip-ﬂ op  236
EEPROM  202, 212
EPROM  201, 202, 212
Error correcting  39
Error detection  31, 38
Error detection codes  38
Essential  97, 103, 113, 123
Excess-3  33, 44, 45
Excess-3 code  44, 45, 49
Excitation table  237, 238, 247, 261
Exclusive  67, 68, 70
F
Flip-ﬂ op  216, 217, 236, 261
FPGA  211, 212

INDEX 491
G
Gate  59, 67, 77, 86
Graphic symbol  68, 69
Gray  33, 34, 45, 49
Gray code  33, 34, 45, 49
H
Hexadecimal  2, 3, 11, 25
Hexadecimal code  2
Hexadecimal numbers  4, 9
Huntington postulates  53, 54, 55
I
Identity element  52, 54, 55
Interfacing  390, 423
Inverse  52
J
Johnson  277, 278, 279
Johnson counter  277, 278, 279
K
Karnaugh map  89, 90, 110, 124
L
Level triggering  236
Literal  59, 77, 78
M
Map method  89, 103, 111, 124
Minuend  14, 15, 25
Moebius counter  278
N
NAND  67, 68, 77, 87
NAND gate  70, 71, 79, 85
Negative logic  83, 84
Nondegenerate forms  77
NOR  79, 87
NOR gate  70, 71, 81, 85
NOT  54, 58, 68, 73
O
Octal numbers  8, 9
P
PLA  194, 202, 203, 213
PLA program table  204, 205, 206, 207
PLD  193, 194, 211, 212
Positive logic  83, 84
Postulates  51, 53, 54, 55, 64
Product of maxterms  63, 66, 87
Product of sums  60, 63, 65, 87
Product terms  60, 61, 65
Programmable  193, 194, 208, 213
Q
Quine-McCluskey method  103, 106
R
R’s complement  10, 11, 14
Read Only Memory  194, 195, 201
Register  263, 264, 285, 289
Ring  277, 278, 279, 289
Ring counter  276, 277, 289
S
Serial addition  283
Shift left  275, 276
Shift register  263, 264, 279, 289
Shift right  271, 272, 275
Sign bit  19, 20
Simpliﬁ cation  59, 84, 85
Speciﬁ cation  355, 371
Standard forms  60
Standard product  60, 61
Standard sum  63
Subtraction  10, 13, 15, 29, 30
Successive approximation type  363, 365, 376
Sum of minterms  66, 87
Sum of products  60, 62, 77

492
DIGITAL PRINCIPLES AND LOGIC DESIGN
T
Tabulation method  103, 106, 123
Types of  201, 211, 212
U
Universal  70, 71, 
Universal gates  70, 71, 85
V
Voltage to time conversion  370
W
Wired  76, 77
Wired logic  76, 77
With NOR  74, 75, 81
With ROM  198, 199
Word  195, 202
X
XOR 68, 69, 85
XNOR 68, 69, 70

