Daniel W. Cunningham
Mathematical Logic

Also of Interest
Advanced Mathematics
An Invitation in Preparation for Graduate School
Patrick Guidotti, 2022
ISBN 978-3-11-078085-7, e-ISBN (PDF) 978-3-11-078092-5
Abstract Algebra
An Introduction with Applications
Derek J. S. Robinson, 2022
ISBN 978-3-11-068610-4, e-ISBN (PDF) 978-3-11-069116-0
A Primer in Combinatorics
Alexander Kheyfits, 2021
ISBN 978-3-11-075117-8, e-ISBN (PDF) 978-3-11-075118-5
Brownian Motion
A Guide to Random Processes and Stochastic Calculus
Ren√© L. Schilling, 2021
ISBN 978-3-11-074125-4, e-ISBN (PDF) 978-3-11-074127-8
General Topology
An Introduction
Tom Richmond, 2020
ISBN 978-3-11-068656-2, e-ISBN (PDF) 978-3-11-068657-9
Partial Differential Equations
An Unhurried Introduction
Vladimir A. Tolstykh, 2020
ISBN 978-3-11-067724-9, e-ISBN (PDF) 978-3-11-067725-6

Daniel W. Cunningham
Mathematical
Logic
‡±©
An Introduction

Mathematics Subject Classification 2020
03-01, 03B05, 03B10, 03B22, 03B25, 03D10, 03D20
Author
Dr. Daniel W. Cunningham
Department of Mathematics
Californial State University
5245 North Backer Avenue M/S PB108
Fresno CA 93740
USA
dwc17@csufresno.edu
ISBN 978-3-11-078201-1
e-ISBN (PDF) 978-3-11-078207-3
e-ISBN (EPUB) 978-3-11-078219-6
Library of Congress Control Number: 2023931072
Bibliographic information published by the Deutsche Nationalbibliothek
The Deutsche Nationalbibliothek lists this publication in the Deutsche Nationalbibliografie;
detailed bibliographic data are available on the Internet at http://dnb.dnb.de.
¬© 2023 Walter de Gruyter GmbH, Berlin/Boston
Cover image: cicerocastro / iStock / Getty Images Plus
Typesetting: VTeX UAB, Lithuania
Printing and binding: CPI books GmbH, Leck
www.degruyter.com

Preface
Mathematical logic is a particular branch of mathematics that applies mathematical
tools to investigate the nature of mathematics. Consequently, in this book our atten-
tion will be focused on the language of mathematics. This will be done by discussing
formal languages, first-order logic, model-theoretic semantics, deductive systems, and
their mathematical properties and relations. Such a focus radiates a bright and direct
light on mathematics itself.
Aristotle was the first formal logician who identified several key principles of cor-
rect reasoning, namely, the syllogisms. On the other hand, modern mathematical logic
is based on the late nineteenth- and early twentieth-century innovative work of Boole,
Frege, Peano, Russell, Whitehead, Hilbert, Skolem, G√∂del, Tarski, Cantor, and their fol-
lowers. The material presented in this text is the result of these pioneers in mathematical
logic.
This textbook delivers an upper-division undergraduate course in mathematical
logic. This subject typically attracts students with various backgrounds, some of whom
may be quite familiar with logical notation and mathematical proof while others may
not be as familiar. The book strives to address the needs of such a course. My primary
goal was to write a book that would be accessible to all readers having a fundamental
background in mathematics. Thus, I have made an effort to write clear and complete
proofs throughout the text. In addition, these proofs favor detail over brevity. This ap-
proach should be to the benefit of all students, readers, and instructors.
Topics covered
The book presents the fundamental topics in mathematical logic that will lead to the
statements and coherent proofs of G√∂del‚Äôs completeness and incompleteness theorems.
The basics of logic and elementary set theory are first discussed in Chapter 1. Since stu-
dents, typically, are acquainted with these topics, one should not necessarily begin the
book by starting with this chapter. However, Section 1.1.5 and Theorem 1.1.27 should def-
initely be discussed. In particular, Theorem 1.1.27 is a recursion theorem that justifies
many of the key definitions and proofs that are presented in the text. Few books in math-
ematical logic explicitly state and prove this often applied result. Such books usually jus-
tify their definitions and proofs with the expression ‚Äúby recursion;‚Äù however, we in such
cases will cite and apply Theorem 1.1.27. Understanding the statement of this theorem is
more important than reading and understanding its proof.
Chapter 2 introduces the syntax and semantics of propositional logic. The chapter
also carefully discusses an induction principle that is illustrated by correctly proving
fundamental results about the language of propositional logic. This is followed by estab-
lishing the completeness of the logical connectives, the compactness theorem, and the
deduction theorem. We also state and prove the associated soundness and completeness
https://doi.org/10.1515/9783110782073-201

VI
‡±™
Preface
theorems. Most students who are familiar with propositional logic have not yet seen a
mathematical development of this logic. Therefore, these topics offer an important pre-
requisite for the development of first-order logic.
Chapter 3 discusses the syntax and semantics of first-order languages. First-order
logic is quite a bit more subtle than propositional logic, although they do share some
common characteristics. The chapter also introduces structures, which can be viewed as
vehicles for interpreting a given first-order language. Tarski‚Äôs definition of satisfaction
gives a precise meaning that yields a method for interpreting a first-order language in
a given structure. This is then followed by the notion of a deduction (formal proof) in a
first-order language.
The main goal of Chapter 4 is to present and prove the soundness and completeness
theorems of first-order logic. For each of these proofs, I have respectively isolated the
technical lemmas (Sections 4.1.1 and 4.2.1) that support the proofs of these important
theorems. The compactness theorem is then presented with a proof. The chapter ends
with several applications of the soundness, completeness, and compactness theorems.
In G√∂del‚Äôs proof of the incompleteness theorem, he encodes formulas into natural
numbers using (primitive) recursive functions. In preparation for the proof of G√∂del‚Äôs
theorem, Chapter 5 covers (primitive) recursive functions and relations. Since G√∂del‚Äôs
encoding techniques created a link between logic and computing, we begin the chapter
with an introduction to abstract computing machines and partial recursive functions.
Today, computability theory in mathematical logic is closely related to the theory of com-
putation in computer science.
In Chapter 6 the focus is on the language of elementary number theory ‚Ñíand the
standard model ùí©for number theory. The chapter begins with the question: Is there a
decidable set of ‚Ñí-sentences, that hold in ùí©, from which one can deduce all the sentences
that are true in ùí©? This is followed by an introduction to the Œ©-axioms. These axioms
allow one to deduce some of the basic statements that are true in the standard model.
Then representable relations and functions are discussed. Eventually it is established
that a function is representable if and only if the function is recursive. Then a technique
is presented that allows one to perform a G√∂del encoding of all of the formulas in the
language ‚Ñí. This is followed by a proof of the fixed-point lemma and two results of G√∂del,
namely, the first and second incompleteness theorems. These two theorems are among
the most important results in mathematical logic.
How to use the book
It is strongly recommended that the reader be familiar with the basics of sets, functions,
relations, logic, and mathematical induction. These topics are typically introduced in a
‚Äútechniques of proof‚Äù course (for example, see [1]). As the emphasis will be on theorems
and their proofs, the reader should be comfortable reading and writing mathematical
proofs.

How to use the book
‡±™
VII
If time is short or an instructor would like to end a one-semester course by cover-
ing G√∂del‚Äôs incompleteness theorems, certain topics can be bypassed. In particular, the
following sections can be omitted without loss of continuity:
‚Äì
3.2.5 Classes of structures
‚Äì
3.2.6 Homomorphisms
‚Äì
4.3.1 Nonstandard models
‚Äì
4.3.4 Prenex normal form
‚Äì
5.1 The informal concept
‚Äì
5.2.1 Turing machines
‚Äì
5.2.2 Register machines
Furthermore, an instructor could focus on the statements of the technical lemmas in Sec-
tions 4.1.1 and 4.2.1 rather than on the proofs of these lemmas. These proofs could then be
given as assigned reading. These technical lemmas support the respective proofs of the
soundness and completeness theorems in Chapter 4. Similarly, in Sections 5.3 and 5.4 one
could focus attention on the results rather than on the proofs. Of course, the material in
Chapter 6 is more interesting than the proofs presented in these two sections. Perhaps,
after seeing the theorems presented in Chapter 6, one would be more interested in the
meticulous proofs presented in Sections 5.3 and 5.4.
Exercises are given at the end of each section in a chapter. An exercise marked with
an asterisk ‚àóis one that is cited, or referenced, elsewhere in the book. Suggestions are
also provided for those exercises that a newcomer to upper-division mathematics may
find more challenging.


Acknowledgments
This book began as a set of lecture notes for an undergraduate course in mathematical
logic that I taught at SUNY Buffalo State. The textbook used for this course was A Mathe-
matical Introduction to Logic by Herbert B. Enderton [2]. As an undergraduate at UCLA,
I also took courses in mathematical logic that used Enderton‚Äôs book. Needless to say, my
respect for Enderton‚Äôs book has influenced the topics and presentation in my own book.
Sherman Page deserves to be recognized for his meticulous copy-editing and review
of the manuscript. Sherman found many typos and errors that I had overlooked. I am
extremely grateful for his salient comments and corrections. I am also grateful to Steven
Elliot, editor at De Gruyter, for his guidance and enthusiasm. Thank you, Marianne Foley,
for your support and tolerance.
https://doi.org/10.1515/9783110782073-202


Contents
Preface ‡±©V
Acknowledgments ‡±©IX
1
Basic set theory and basic logic ‡±©1
1.1
Basic set theory ‡±©1
1.1.1
Relations ‡±©2
1.1.2
Equivalence classes and partitions ‡±©4
1.1.3
Functions ‡±©5
1.1.4
Induction and recursion ‡±©6
1.1.5
Defining sets by recursion ‡±©7
1.1.6
Countable sets ‡±©11
1.1.7
Cardinality ‡±©13
1.1.8
The axiom of choice ‡±©14
1.2
Basic logic ‡±©16
1.2.1
Propositions and logical connectives ‡±©16
1.2.2
Truth tables and truth functions ‡±©17
1.2.3
Predicates and quantifiers ‡±©19
2
Propositional logic ‡±©27
2.1
The language ‡±©27
2.2
Truth assignments ‡±©32
2.2.1
Some tautologies ‡±©36
2.2.2
Omitting parentheses ‡±©37
2.3
Completeness of the logical connectives ‡±©39
2.4
Compactness ‡±©44
2.5
Deductions ‡±©48
3
First-order logic ‡±©52
3.1
First-order languages ‡±©52
3.1.1
Terms and atomic formulas ‡±©54
3.1.2
Induction on terms principle ‡±©56
3.1.3
Well-formed formulas ‡±©58
3.1.4
Induction on wffs principle ‡±©59
3.1.5
Free variables ‡±©60
3.1.6
Notational abbreviations ‡±©62
3.1.7
Examples of languages ‡±©63
3.2
Truth and structures ‡±©66
3.2.1
Structures for first-order languages ‡±©66
3.2.2
Satisfaction (Tarski‚Äôs definition) ‡±©68

XII
‡±™
Contents
3.2.3
Logical implication ‡±©74
3.2.4
Definability over a structure ‡±©76
3.2.5
Classes of structures ‡±©78
3.2.6
Homomorphisms ‡±©80
3.3
Deductions ‡±©90
3.3.1
Tautologies in first-order logic ‡±©91
3.3.2
Generalization and substitution ‡±©93
3.3.3
The logical axioms ‡±©97
3.3.4
Formal deductions ‡±©99
3.3.5
Metatheorems about deductions ‡±©102
3.3.6
Equality ‡±©109
3.3.7
More metatheorems about deductions ‡±©112
4
Soundness and completeness ‡±©119
4.1
The soundness theorem ‡±©119
4.1.1
Technical lemmas ‡±©119
4.1.2
Proof of the soundness theorem ‡±©123
4.2
The completeness theorem ‡±©124
4.2.1
Technical lemmas ‡±©125
4.2.2
Proof of the completeness theorem ‡±©129
4.2.3
The compactness theorem ‡±©134
4.3
Applications ‡±©136
4.3.1
Nonstandard models ‡±©137
4.3.2
L√∂wenheim‚ÄìSkolem theorems ‡±©139
4.3.3
Theories ‡±©141
4.3.4
Prenex normal form ‡±©145
5
Computability ‡±©148
5.1
The informal concept ‡±©148
5.1.1
Decidable sets ‡±©149
5.1.2
Computable functions ‡±©151
5.2
Formalizations‚Äîan overview ‡±©159
5.2.1
Turing machines ‡±©159
5.2.2
Register machines ‡±©163
5.2.3
Primitive recursiveness and partial search ‡±©166
5.3
Recursive functions ‡±©172
5.3.1
Bounded search ‡±©187
5.4
Recursively enumerable sets and relations ‡±©195
5.4.1
Decidability revisited ‡±©201
6
Undecidability and incompleteness ‡±©205
6.1
Introduction ‡±©205

Contents
‡±™
XIII
6.2
Basic axioms for number theory ‡±©206
6.3
Representable relations and functions ‡±©211
6.3.1
Recursive relations and functions are representable ‡±©219
6.4
Arithmetization of the formal language ‡±©225
6.4.1
The logical axioms revisited ‡±©232
6.5
The incompleteness theorems ‡±©238
6.5.1
G√∂del‚Äôs first incompleteness theorem ‡±©241
6.5.2
G√∂del‚Äôs second incompleteness theorem ‡±©244
6.5.3
Epilogue ‡±©247
Bibliography ‡±©249
Symbol Index ‡±©251
Subject Index ‡±©253


1 Basic set theory and basic logic
1.1 Basic set theory
Fundamental definitions of set theory
A set is a collection of objects which are called its elements. As usual, we write ‚Äút ‚ààA‚Äù to
say that t is a member of A, and we write ‚Äút ‚àâA‚Äù‚Äô to say that t is not a member of A. We
write A = B to mean that the sets A and B are equal, that is, they have the same elements.
For sets A and B we write A ‚äÜB to mean to mean that set A is a subset of set B, that is,
every element of A is also an element of B.
Remark. Recall the following:
1.
A ‚äÜB means that for all x, if x ‚ààA, then x ‚ààB.
2.
A = B means that for all x, x ‚ààA if and only if x ‚ààB.
3.
One special set is the empty set ‚åÄ, which has no members at all. Note that ‚åÄ‚äÜA for
any set A.
4.
For any object x, the set {x} is called a singleton because it has only one element,
namely, x.
We now identify some important sets that often appear in mathematics:
1.
‚Ñï= {x : x is a natural number} = {0, 1, 2, 3, . . . },
2.
‚Ñ§= {x : x is an integer} = {. . . , ‚àí3, ‚àí2, ‚àí1, 0, 1, 2, 3, . . . },
3.
‚Ñö= {x : x is a rational number}; for example, ‚àí2, 2
3 ‚àà‚Ñö,
4.
‚Ñù= {x : x is a real number}; for example, 2
3, œÄ ‚àà‚Ñù.
Given a property P(x) we can form the set of just those elements in a set A that make
P(x) true, that is, we can form the set {x ‚ààA : P(x)}. For example, let ‚Ñïbe the set of
natural numbers. Suppose we want to collect just those elements in ‚Ñïthat are odd. We
can easily describe this set by {n ‚àà‚Ñï: n is odd}, that is, ‚Äúthe set of all n ‚àà‚Ñïsuch that n
is odd.‚Äù Thus, {n ‚àà‚Ñï: n is odd} = {1, 3, 5, 7, . . . }.
Definition 1.1.1. Given two sets A and B we define the following:
1.
A ‚à©B = {x : x ‚ààA and x ‚ààB} is the intersection of A and B,
2.
A ‚à™B = {x : x ‚ààA or x ‚ààB} is the union of A and B,
3.
A \ B = {x : x ‚ààA and x ‚àâB} is the set difference of A and B (also stated in English as
A ‚Äúminus‚Äù B),
4.
A and B are disjoint if they have no elements in common, that is, A ‚à©B = ‚åÄ,
5.
to add one extra object t to a set A, we will write A; t to denote the set A ‚à™{t}.
Consider a set A whose members are themselves sets. The union of A, denoted by
‚ãÉA, is the set of objects that belong to some member of A, that is,
‚ãÉA = {x : x belongs to some member of A}.
https://doi.org/10.1515/9783110782073-001

2
‡±™
1 Basic set theory and basic logic
When A is nonempty, the intersection of A, denoted by ‚ãÇA, is the set of objects that
belong to every member of A, that is,
‚ãÇA = {x : x belongs to every member of A}.
For example, if A = {{0, 1, 5}, {1, 6}, {1, 5}}, then
‚ãÉA = {0, 1, 5, 6}
and
‚ãÇA = {1}.
In cases where we have a set Ai for each i ‚ààI, the set {Ai : i ‚ààI} is called an indexed
family of sets. The union ‚ãÉ{Ai : i ‚ààI} is usually denoted by ‚ãÉi‚ààI Ai or ‚ãÉi Ai. The inter-
section ‚ãÇ{Ai : i ‚ààI} is usually denoted by ‚ãÇi‚ààI Ai or ‚ãÇi Ai. We will often be dealing with
unions of the form ‚ãÉn‚àà‚ÑïAn and intersections of the form ‚ãÇn‚àà‚ÑïAn.
More generally, a set having the form {xi : i ‚ààI} is called an indexed set and each
i ‚ààI is called an index. Every element in {xi : i ‚ààI} has the form xi for some i ‚ààI. Such
sets appear frequently in mathematics and will also appear in this text.
Definition 1.1.2. Let A be a set. The power set of A, denoted by ùí´(A), is the set whose
elements are all of the subsets of A, that is, ùí´(A) = {X : X ‚äÜA}.
Thus, X ‚ààùí´(A) if and only if X ‚äÜA. If A is a finite set with n elements, then one can
show that the set ùí´(A) has 2n elements. The set A = {1, 2, 3} has three elements, so ùí´(A)
has eight elements, namely,
ùí´(A) = {‚åÄ, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}.
1.1.1 Relations
Definition 1.1.3. An ordered pair has the form ‚ü®a, b‚ü©, where a is referred to as the first
component and b is identified as the second component.
Example 1.1.4. The pair ‚ü®2, 3‚ü©is an ordered pair, and so is ‚ü®3, 2‚ü©. Note that these are
different ordered pairs, that is, ‚ü®2, 3‚ü©
Ã∏= ‚ü®3, 2‚ü©.
Definition 1.1.5. Given sets A and B, the Cartesian product A √ó B is the set
A √ó B = {‚ü®a, b‚ü©: a ‚ààA and b ‚ààB}.
In other words, A√óB is the set of all ordered pairs with first component in A and second
component in B.
Definition 1.1.6. An n-sequence is an ordered list of the form ‚ü®a1, a2, . . . , an‚ü©, where n ‚â•1
is a natural number. The term a1 is called the first component, a2 is the second compo-
nent, . . . , and an is the n-th component. We say that ‚ü®a1, a2, . . . , ak‚ü©is a proper initial
segment of ‚ü®a1, a2, . . . , an‚ü©when 1 ‚â§k < n.

1.1 Basic set theory
‡±™
3
Given an n-sequence s = ‚ü®a1, a2, . . . , an‚ü©and an m-sequence t = ‚ü®b1, b2, . . . , bm‚ü©, the
concatenation of s with t is the (n+m)-sequence given by
s‚å¢t = ‚ü®a1, a2, . . . , an, b1, b2, . . . , bm‚ü©.
Example 1.1.7. The sequence ‚ü®3, ‚àí1, 2, 2‚ü©is a 4-sequence, and so is ‚ü®2, ‚àí1, 3, 2‚ü©. Note that
these are different sequences, that is, ‚ü®3, ‚àí1, 2, 2‚ü©
Ã∏= ‚ü®2, ‚àí1, 3, 2‚ü©.
We will just say that ‚ü®a1, a2, . . . , an‚ü©is a sequence, when n is understood.
Definition 1.1.8. Let n ‚â•1 and let A be a set. Then the set An is defined to be
An = {‚ü®a1, a2, . . . , an‚ü©: a1 ‚ààA, a2 ‚ààA, . . . , an ‚ààA}.
In other words, An is the set of all n-sequences whose components are all in A.
For the record, an n-sequence ‚ü®a1, a2, . . . , an‚ü©is rigorously defined to be a function
f : {1, 2, . . . , n} ‚Üí{a1, a2, . . . , an}
such that f (1) = a1, f (2) = a2, . . . , f (n) = an. Thus, ‚ü®a, b‚ü©= ‚ü®c, d‚ü©if and only if a = c
and b = d. Moreover, ‚ü®a1, a2, . . . , an‚ü©= ‚ü®b1, b2, . . . , bm‚ü©if and only if n = m and a1 =
b1, . . . , an = bm.
Definition 1.1.9. A subset R of An is said to be an n-place relation on A. We will write
R(a1, a2, . . . , an) to indicate that ‚ü®a1, a2, . . . , an‚ü©‚ààR.
A 1-place relation on a set A is simply a subset of A.
Definition 1.1.10. A 2-place relation R on a set A is often just called a relation on A. The
domain of R, dom(R), is the set {x ‚ààA : ‚ü®x, y‚ü©‚ààR for some y}. The range of R, ran(R), is
the set {y ‚ààA : ‚ü®x, y‚ü©‚ààR for some x}. The union of dom(R) and ran(R) is called the field
of R, fld(R).
A relation R on A is a subset of A √ó A, that is, R ‚äÜA √ó A. We shall customarily write
xRy or R(x, y) to denote ‚ü®x, y‚ü©‚ààR.
The equality relation is reflexive, symmetric, and transitive. Many relations also
have some of these properties. Relations that have all of these properties often appear
in mathematics.
Definition 1.1.11. For a relation ‚àºon A, we define the following:
‚àºis reflexive if and only if x ‚àºx for all x ‚ààA,
‚àºis symmetric if and only if whenever x ‚àºy, then also y ‚àºx,
‚àºis transitive if and only if whenever both x ‚àºy and y ‚àºz, then x ‚àºz.
Finally, we say that a relation ‚àºon A is an equivalence relation if and only if ‚àºis
reflexive, symmetric, and transitive.

4
‡±™
1 Basic set theory and basic logic
1.1.2 Equivalence classes and partitions
A partition is a way of breaking up a set into nonempty disjoint parts such that each
element of the set is in one of the parts.
Definition 1.1.12. Let A be a set. Let P be a collection of nonempty subsets of A. We say
that P is a partition of A if the following hold:
1.
For every element a ‚ààA there is a set S ‚ààP such that a ‚ààS.
2.
For all S, T ‚ààP, if S
Ã∏= T, then S ‚à©T = ‚åÄ.
Example 1.1.13. The set P = {S1, S2, S3} forms a partition of the set ‚Ñ§where
S1 = {. . . , ‚àí6, ‚àí3, 0, 3, 6, . . . },
S2 = {. . . , ‚àí5, ‚àí2, 1, 4, 7, . . . },
S3 = {. . . , ‚àí4, ‚àí1, 2, 5, 8, . . . }.
That is, P = {S1, S2, S3} breaks ‚Ñ§up into three disjoint nonempty sets and every integer
is in one of these sets.
Definition 1.1.14. Let ‚àºbe an equivalence relation on a set A and let a ‚ààA be an element
of A. The equivalence class of a, denoted by [a]‚àº, is defined by
[a]‚àº= {b ‚ààA : b ‚àºa}.
We write [a] = [a]‚àºwhen the relation ‚àºis clearly understood. So if a ‚ààA, then
a ‚àà[a] as a ‚àºa.
Theorem 1.1.15. Let ‚àºbe an equivalence relation on A. Then for all a, b ‚ààA,
a ‚àºb
if and only if
[a] = [b].
Proof. Let ‚àºbe an equivalence relation on A. Let a, b ‚ààA. We shall prove that
a ‚àºb
if and only if
[a] = [b].
(‚áí). Assume that a ‚àºb. We prove that [a] = [b]. First we prove that [a] ‚äÜ[b]. Let
x ‚àà[a]. We show that x ‚àà[b]. Since x ‚àà[a] and [a] = {y ‚ààA : y ‚àºa}, it follows that x ‚àºa.
By assumption, we also have a ‚àºb. Hence, x ‚àºa and a ‚àºb. Since ‚àºis transitive, we
conclude that x ‚àºb. Now, because [b] = {y ‚ààA : y ‚àºb}, it follows that x ‚àà[b]. Therefore,
[a] ‚äÜ[b]. The proof that [b] ‚äÜ[a] is very similar. So [a] = [b].
(‚áê). Assume that [a] = [b]. We prove that a ‚àºb. Since a ‚àà[a] and [a] = [b], it follows
that a ‚àà[b]. But [b] = {y ‚ààA : y ‚àºb}. Therefore, a ‚àºb.

1.1 Basic set theory
‡±™
5
Corollary 1.1.16. Let ‚àºbe an equivalence relation on a set A. Then for all a ‚ààA and b ‚ààA,
a ‚àà[b] if and only if [a] = [b].
Theorem 1.1.17 (Fundamental theorem on equivalence relations). Whenever ‚àºis an equiv-
alence relation on a set A, the collection P = {[a] : a ‚ààA} is a partition of A. We denote
this partition by P = A/‚àº.
Proof. Let ‚àºbe an equivalence relation on A. We prove that the set P = {[a] : a ‚ààA} is a
partition of A, that is, we prove that:
(i)
for every element x ‚ààA we have x ‚àà[x],
(ii) for all x, y ‚ààA, if [x] ‚à©[y]
Ã∏= ‚åÄ, then [x] = [y].
Proof of (i). Let x ‚ààA. Clearly, [x] ‚ààP and x ‚àà[x].
Proof of (ii). Let x, y ‚ààA. Thus, [x] ‚ààP and [y] ‚ààP. We must prove that if [x]
Ã∏= [y],
then [x] ‚à©[y] = ‚åÄ. So assume [x]
Ã∏= [y]. Assume, for a contradiction, that [x] ‚à©[y]
Ã∏= ‚åÄ.
Since [x] ‚à©[y]
Ã∏= ‚åÄ, there exists a z ‚ààA such that z ‚àà[x] and z ‚àà[y]. However, since
[x] = {b ‚ààA : b ‚àºx} and [y] = {b ‚ààA : b ‚àºy}, it thus follows that z ‚àºx and z ‚àºy.
Because ‚àºis symmetric, we conclude that x ‚àºz and z ‚àºy. As ‚àºis transitive, we further
conclude that x ‚àºy. But Theorem 1.1.15 now implies that [x] = [y], which contradicts
our assumption that [x]
Ã∏= [y]. Therefore, [x] ‚à©[y] = ‚åÄ.
1.1.3 Functions
One of the most important concepts in mathematics is the function concept. A function
is a way of associating each element of a set A with exactly one element in another set B.
We will give a precise set-theoretic definition of a function using relations.
Definition 1.1.18. A relation R is single-valued if for each x ‚ààdom(R) there is exactly
one y such that ‚ü®x, y‚ü©‚ààR.
Thus, if R is a single-valued relation, then whenever ‚ü®x, y‚ü©‚ààR and ‚ü®x, z‚ü©‚ààR, we
can conclude that y = z.
Definition 1.1.19. A function f is any single-valued relation; in other words, for each
x ‚ààdom(f ) there is only one y such that ‚ü®x, y‚ü©‚ààf .
Let A and B be sets. A function f from A to B is a subset of A √ó B such that for each
x ‚ààA there is exactly one y ‚ààB so that ‚ü®x, y‚ü©‚ààf . For example, let A = {a, b, c, d, e} and
B = {5, 6, 7, 8, 9}. Then
f = {‚ü®a, 8‚ü©, ‚ü®b, 7‚ü©, ‚ü®c, 9‚ü©, ‚ü®d, 6‚ü©, ‚ü®e, 5‚ü©}
is a function from A to B because for each x ‚ààA, there is exactly one y ‚ààB such that
‚ü®x, y‚ü©‚ààf . We now express this notion in terms of a formal definition.

6
‡±™
1 Basic set theory and basic logic
Definition 1.1.20. Let A and B be sets and let f be a relation from A to B. Then f is said
to be a function from A to B if the following two conditions hold:
(1) dom(f ) = A, that is, for each x ‚ààA, there is a y ‚ààB such that ‚ü®x, y‚ü©‚ààf ,
(2) f is single-valued, that is, if ‚ü®x, y‚ü©‚ààf and ‚ü®x, z‚ü©‚ààf , then y = z.
The set A is the domain of f and the set B is called the codomain of f .
We write f : A ‚ÜíB to indicate that f is a function from the set A to the set B. Thus,
for each x ‚ààA, there is exactly one y ‚ààB such that ‚ü®x, y‚ü©‚ààf . This unique y is called ‚Äúthe
value of f at x‚Äù and is denoted by f (x). Therefore, ‚ü®x, y‚ü©‚ààf if and only if f (x) = y. We
will say that x ‚ààA is an input to the function f and f (x) is the resulting output. One can
also say that the function f maps x to f (x), denoted by x Û≥®É‚Üíf (x).
Given a function f : A ‚ÜíB, the set {f (x) : x ‚ààA} is called the range of f and is
denoted by ran(f ). Clearly, ran(f ) is a subset of B. The following lemma offers a useful
tool for showing that two functions are equal.
Lemma 1.1.21. Let f and g be functions such that dom(f ) = dom(g). Then f = g if and
only if f (x) = g(x) for all x in their common domain.
Definition 1.1.22. For a natural number n ‚â•2 and a function f : Xn ‚ÜíY from the set of
sequences Xn to the set Y, we shall write f (‚ü®x1, x2, . . . , xn‚ü©) = f (x1, x2, . . . , xn) for every
element of ‚ü®x1, x2, . . . , xn‚ü©‚ààXn. We will say that f is an n-place function or that f has
arity n.
1.1.4 Induction and recursion
Let ‚Ñï= {0, 1, 2, 3, . . . } be the set of natural numbers. Often one can use proof by mathe-
matical induction to establish statements of the form ‚Äúfor all n ‚àà‚Ñï, P(n).‚Äù
Principle of mathematical induction
Let S ‚äÜ‚Ñï. If
1.
0 ‚ààS and
2.
for all n ‚àà‚Ñï, if n ‚ààS, then n + 1 ‚ààS,
then S = ‚Ñï.
Proof by mathematical induction
Let P(n) be a statement concerning a natural number variable n. If
1.
P(0) is true and
2.
for all n ‚àà‚Ñï, if P(n), then P(n + 1),
then P(n) is true for all natural numbers n.

1.1 Basic set theory
‡±™
7
Principle of strong induction
Let P(n) be a statement about a natural number variable n. If
1.
P(0) is true and
2.
the statements P(0), P(1), . . . , P(n ‚àí1) imply P(n), for all n ‚àà‚Ñï,
then P(n) is true for all natural numbers n.
Induction is often applied in mathematical proofs. One can also define a function by
induction (recursion). A recursively defined function is one that is defined in terms of
‚Äúpreviously evaluated values of the function.‚Äù A function h on ‚Ñïis defined recursively
if its value at 0 is first specified and then all of the remaining values are defined by using
a value that has previously been evaluated. A proof of the following theorem is given in
[3, Theorem 4.2.1].
Theorem 1.1.23 (Recursion on ‚Ñï). Let a ‚ààA and let g: A ‚ÜíA be a function, where A is a
set. Then there exists a unique function h: ‚Ñï‚ÜíA such that:
1.
h(0) = a,
2.
h(n + 1) = g(h(n)), for all n ‚àà‚Ñï.
1.1.5 Defining sets by recursion
In this section, we shall develop and state a generalization of the above Theorem 1.1.23.
First we must talk about defining sets by recursion. A recursive definition of a set C has
the following form:
(a) Basis: Specify the ‚Äúinitial‚Äù elements of C.
(b) Induction: Give one or more operations for constructing ‚Äúnew‚Äù elements of C from
‚Äúold‚Äù elements of C.
(c) Closure: The set C is the smallest set that contains the initial elements and is also
closed under the operations (see Theorem 1.1.25).
Suppose that U is a set and we are given a function f : Un ‚ÜíU. We say that a set S ‚äÜU is
closed under f if and only if whenever x1, x2, . . . , xn ‚ààS we have f (x1, x2, . . . , xn) ‚ààS. For
any A ‚äÜU, let us define
f [A] = {f (x1, x2, . . . , xn) : x1, x2, . . . , xn ‚ààA}.
Now let ‚Ñ±be a set of functions ‚Ñìwhich have the form ‚Ñì: Un ‚ÜíU, where n is the arity of ‚Ñì.
The functions in ‚Ñ±can have different arity. For any A ‚äÜU let us define ‚Ñ±[A] = ‚ãÉ{‚Ñì[A] :
‚Ñì‚àà‚Ñ±}. Given B ‚äÜU, in the next theorem, we show how to construct the smallest set C
such that B ‚äÜC ‚äÜU and C is closed under every function in ‚Ñ±.
Theorem 1.1.24. Let U be a set and let ‚Ñ±be a set of functions ‚Ñìof the form ‚Ñì: Un ‚ÜíU,
where n is the arity of ‚Ñì. Now let B ‚äÜU. Define, by recursion on ‚Ñï, the following sets:

8
‡±™
1 Basic set theory and basic logic
(1) C0 = B,
(2) Cn+1 = Cn ‚à™‚Ñ±[Cn] for all n ‚àà‚Ñï.
Let C = ‚ãÉn‚àà‚ÑïCn. Then B ‚äÜC ‚äÜU and C is closed under all the functions in ‚Ñ±.
Proof. See Exercise 5.
The set C, defined in Theorem 1.1.24, is referred to as the set generated from B by the
functions in ‚Ñ±. One feature of defining the set C by the above recursion is that it yields
an induction principle that will be frequently applied in the coming pages.
Theorem 1.1.25 (Induction principle). Let U be a set and let ‚Ñ±be a set of functions ‚Ñìwhich
have the form ‚Ñì: Un ‚ÜíU, where n is the arity of ‚Ñì. Suppose that C is the set generated from
B by the functions in ‚Ñ±. If I ‚äÜC satisfies
(a) B ‚äÜI and
(b) I is closed under all of the functions in ‚Ñ±,
then I = C.
Proof. One can prove by induction on n that Cn ‚äÜI using (1) and (2) of Theorem 1.1.24.
Thus, C ‚äÜI, and since I ‚äÜC, it follows that I = C.
Suppose that U is a set and that f is a function of the form f : Un ‚ÜíU. Let C ‚äÜU
and suppose that C is closed under f . Then the function fC: Cn ‚ÜíC is defined by
fC(x1, x2, . . . , xn) = f (x1, x2, . . . , xn) for all x1, x2, . . . , xn ‚ààC.
Definition 1.1.26. Suppose that U is a set and ‚Ñ±is a set of functions ‚Ñìof the form
‚Ñì: Un ‚ÜíU, where n is the arity of ‚Ñì. We shall say that C is freely generated from B by the
functions in ‚Ñ±if the following hold:
1.
the set C is generated from B by the functions in ‚Ñ±,
2.
fC is one-to-one for every f ‚àà‚Ñ±,
3.
the range of fC and B are disjoint, for all f ‚àà‚Ñ±,
4.
the range of fC and the range of gC are disjoint for all distinct f , g ‚àà‚Ñ±.
The following theorem shows that if a set C is freely generated from B, then a func-
tion h defined on the initial elements B can be extended to a function h defined on all of
the elements in C. This theorem will justify many results to be covered in the text. The
proof requires some special set-theoretic tools and can be summarized as follows: The
intersection of all the approximations to h is in fact h.
Theorem 1.1.27 (Recursion theorem). Let U be a set and let ‚Ñ±be a set of functions ‚Ñìof the
form ‚Ñì: Un ‚ÜíU, where n is the arity of ‚Ñì. Let B ‚äÜU and let C be freely generated from B
by the functions in ‚Ñ±. Let V be a set. Assume that:
(a) we are given a function h: B ‚ÜíV, and
(b) for each ‚Ñì‚àà‚Ñ±, there is an associated function F‚Ñì: V n ‚ÜíV of the same arity as ‚Ñì.

1.1 Basic set theory
‡±™
9
Then there is a unique function h: C ‚ÜíV such that:
(i)
h(x) = h(x) for all x ‚ààB,
(ii) for each ‚Ñì‚àà‚Ñ±, we have
h(‚Ñì(x1, x2, . . . , xn)) = F‚Ñì(h(x1), h(x2), . . . , h(xn))
for all x1, x2, . . . , xn ‚ààC, where n is the arity of ‚Ñì.
Proof. Let us call a relation R ‚äÜC √ó V suitable if the following two conditions hold:
(1) ‚ü®b, h(b)‚ü©‚ààR, for all b ‚ààB,
(2) for all ‚Ñì‚àà‚Ñ±of arity n, if x1, x2, . . . , xn ‚ààdom(R), then for each 1 ‚â§i ‚â§n, we have
‚ü®xi, yi‚ü©‚ààR for some yi ‚ààV and
‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©‚ààR.
Our goal is to construct a suitable relation that is also a function.
Every suitable relation is a subset of C √ó V. Let ùíÆ= {R : R is suitable}. Because C √ó V
is a suitable relation, ùíÆis nonempty. Let h = ‚ãÇùíÆ. Clearly, h ‚äÜC √ó V, so h is a relation.
We now prove that h is suitable and that it is a function.
Claim 1. The relation h is suitable.
Proof. We need to show that h satisfies items (1) and (2). Let b ‚ààB. Every relation in ùíÆis
suitable. So ‚ü®b, h(b)‚ü©is an element in every relation in ùíÆ. Thus, ‚ü®b, h(b)‚ü©‚àà‚ãÇùíÆ, that is,
‚ü®b, h(b)‚ü©‚ààh for every b ‚ààB. To prove (2), let ‚Ñì‚àà‚Ñ±be of arity n and let x1, x2, . . . , xn ‚àà
dom(h). Therefore, for each 1 ‚â§i ‚â§n, ‚ü®xi, yi‚ü©‚ààh for some yi ‚ààV. As h = ‚ãÇùíÆ, it
follows that each ‚ü®xi, yi‚ü©belongs to every relation in ùíÆ. Let R ‚ààùíÆ. Since ‚ü®xi, yi‚ü©‚ààR for
all 1 ‚â§i ‚â§n and R is suitable, item (2) implies that ‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©‚àà
R. Thus, ‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©belongs to every relation in ùíÆand therefore,
‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©‚ààh. Hence, h is suitable.
(Claim 1)
We now must prove that h is a function with domain C.
Claim 2. The relation h is a function from C to V.
Proof. To prove that h is a function from C to V, we must show that for each x ‚ààC, there
is exactly one y ‚ààV such that ‚ü®x, y‚ü©‚ààh. Let I ‚äÜC be defined by
I = {x ‚ààC : there is exactly one y ‚ààV such that ‚ü®x, y‚ü©‚ààh}.
We shall prove that I = C by applying Theorem 1.1.25. To do this, we must first prove that
B ‚äÜI. Let b ‚ààB. We know that ‚ü®b, h(b)‚ü©‚ààh, because h is suitable. To prove that b ‚ààI,
we need to show there is no ‚ü®b, y‚ü©‚ààh where y
Ã∏= h(b). Suppose, for a contradiction, that
‚ü®b, y‚ü©‚ààh, where y
Ã∏= h(b). Consider the relation R = h \ {‚ü®b, y‚ü©}. So (Û≥µ≥) ‚ü®b, y‚ü©‚àâR. Since C
is freely generated from B by the functions in ‚Ñ±, it follows that whenever ‚Ñì‚àà‚Ñ±, we have

10
‡±™
1 Basic set theory and basic logic
‚Ñì(x1, x2, . . . , xn) ‚àâB for all x1, x2, . . . , xn ‚ààC. As h is suitable, it thus follows that R is also
suitable. Hence, R ‚ààùíÆ. Since h = ‚ãÇùíÆ, we conclude that h ‚äÜR, and thus, ‚ü®b, y‚ü©‚ààR, which
contradicts (Û≥µ≥). Thus, h(b) is the only element in V such that ‚ü®b, h(b)‚ü©‚ààh. Therefore,
B ‚äÜI.
Now we show that I is closed under all of the functions in ‚Ñ±. Let g: Uk ‚ÜíU be a
function in ‚Ñ±and let z1, z2, . . . , zk ‚ààI. We need to show that g(z1, z2, . . . , zk) ‚ààI. For each
1 ‚â§i ‚â§k, since zi ‚ààI, there is a unique wi such that ‚ü®zi, wi‚ü©‚ààh. Because h is suitable,
we conclude that
‚ü®g(z1, z2, . . . , zk), Fg(w1, w2, . . . , wk)‚ü©‚ààh.
To show that g(z1, z2, . . . , zk) ‚ààI, we must show there is no ‚ü®g(z1, z2, . . . , zk), y‚ü©‚ààh where
Fg(w1, w2, . . . , wk)
Ã∏= y. Suppose, for a contradiction, that there exists a y ‚ààV such that
(Û≥∂£) ‚ü®g(z1, z2, . . . , zk), y‚ü©‚ààh where (Û≥∂É) Fg(w1, w2, . . . , wk)
Ã∏= y. Consider the relation
R = h \ {‚ü®g(z1, z2, . . . , zk), y‚ü©}.
Clearly, (‚ß´) ‚ü®g(z1, z2, . . . , zk), y‚ü©‚àâR. We now show that R is suitable. Let b ‚ààB. Since
C is freely generated from B by the functions in ‚Ñ±, it follows that g(z1, z2, . . . , zk)
Ã∏= b.
Since h is suitable, it follows that ‚ü®b, h(b)‚ü©‚ààR. Thus, R satisfies item (1) of the above
definition of suitability. To verify that R satisfies item (2), let ‚Ñì‚àà‚Ñ±be of arity n and let
x1, x2, . . . , xn ‚ààdom(R). Since R ‚äÜh, we have x1, x2, . . . , xn ‚ààdom(h). Since h is suitable,
it follows that
‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©‚ààh.
So if
‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©
Ã∏= ‚ü®g(z1, z2, . . . , zk), y‚ü©,
then ‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©‚ààR. On the other hand, if
‚ü®‚Ñì(x1, x2, . . . , xn), F‚Ñì(y1, y2, . . . , yn)‚ü©= ‚ü®g(z1, z2, . . . , zk), y‚ü©,
then
(‚ô£) ‚Ñì(x1, x2, . . . , xn) = g(z1, z2, . . . , zk)
and
(Û≥∂≥) F‚Ñì(y1, y2, . . . , yn) = y.
Because C is freely generated from B by the functions in ‚Ñ±, (‚ô£) implies that ‚Ñì= g, n = k,
and x1 = z1, x2 = z2, . . . , xn = zk. Therefore, x1, x2, . . . , xn ‚ààI and thus, y1 = w1, y2 =
w2, . . . , yn = wk. Hence,
F‚Ñì(y1, y2, . . . , yn) = Fg(w1, w2, . . . , wk),
which contradicts (Û≥∂É) and (Û≥∂≥). Thus, R is suitable. So R ‚ààùíÆ. Since h = ‚ãÇùíÆ, we con-
clude that h ‚äÜR so ‚ü®g(z1, z2, . . . , zk), y‚ü©‚ààR (see (Û≥∂£)), which contradicts (‚ß´). Therefore,

1.1 Basic set theory
‡±™
11
g(z1, z2, . . . , zk) ‚ààI. Theorem 1.1.25 now implies that I = C and, as a result, h is a function
from C to V.
(Claim 2)
Since the function h is suitable, it satisfies conditions (i) and (ii) given in the
statement of the theorem. To prove that h is unique, let g: C ‚ÜíV also satisfy prop-
erties (i) and (ii). Thus, g is a suitable relation, so g ‚ààùíÆ. Since h = ‚ãÇùíÆ, we have h ‚äÜg.
As h and g are functions with domain C, Lemma 1.1.21 implies that h = g. Hence, h is
unique.
(Theorem)
The function h in Theorem 1.1.27, satisfying (1) and (2), is often said to be defined
by recursion. If a function is defined by recursion, then proofs of statements about this
function typically use ‚Äúproof by induction.‚Äù
The proof of Theorem 1.1.27 requires that C be freely generated. To illustrate this, let
f : ‚Ñï‚Üí‚Ñïand g: ‚Ñï‚Üí‚Ñïbe defined by f (n) = n2 and g(n) = n3. Let B = {0, 1, 2}. Let C be
the set generated from B by the functions in ‚Ñ±= {f , g}. The functions in ‚Ñ±are one-to-
one. However, their ranges are not disjoint and their ranges are not disjoint with B. So C
is not freely generated. Now let Ff : ‚Ñù‚Üí‚Ñùbe the identity function and let Fg: ‚Ñù‚Üí‚Ñùbe
the cube root function. Let h: {0, 1, 2} ‚Üí‚Ñùbe such that h(1) = 3. If h could be extended
to a function h: C ‚Üí‚Ñùas in Theorem 1.1.27, then we would have
h(f (1)) = Ff (h(1)) = Ff (3) = 3,
h(g(1)) = Fg(h(1)) = Fg(3) =
3‚àö3.
Since f (1) = g(1) = 1, we conclude that h(1) = 3 and h(1) =
3‚àö3. Thus, no such func-
tion h exists.
1.1.6 Countable sets
Let ‚Ñï= {0, 1, 2, 3, . . . } be the set of natural numbers. A set is countable if it has the
same size as some subset of ‚Ñï. In other words, a set is countable if there is a one-to-one
correspondence between the set and a subset of ‚Ñï. Our next definition expresses this
concept in mathematical terms.
Definition 1.1.28. A set A is countable if and only if there exists a one-to-one function
f : A ‚Üí‚Ñï.
The following theorem will be used to prove that the set of all finite sequences of a
countable set is also countable (see Theorem 1.1.30). A proof of this theorem is given
in [1, Theorem 4.4.7].
Theorem 1.1.29 (Fundamental theorem of arithmetic). For every natural number n > 1,
there exist distinct primes p1, p2, . . . , pk together with natural numbers a1 ‚â•1, a2 ‚â•
1, . . . , ak ‚â•1 such that

12
‡±™
1 Basic set theory and basic logic
n = pa1
1 pa2
2 ‚ãÖ‚ãÖ‚ãÖpak
k .
Furthermore, given any prime factorization into distinct primes,
n = qb1
1 qb2
2 ‚ãÖ‚ãÖ‚ãÖqb‚Ñì
‚Ñì
we have ‚Ñì= k, the primes qi are the same as the primes pj (except for order), and the
corresponding exponents are the same.
Theorem 1.1.30. Let A be a set and let S be the set of all finite sequences of elements of A.
If A is countable, then S is countable.
Proof. Let A be a countable set and let f : A ‚Üí‚Ñïbe one-to-one. Let S be the set of all
finite sequences of elements of A. Thus,
S = ‚ãÉ
n‚àà‚Ñï
An+1.
Let h: S ‚Üí‚Ñïbe defined as follows: Let ‚ü®a1, a2, . . . , am‚ü©‚ààS. Define
h(‚ü®a1, a2, . . . , am‚ü©) = 2f (a1)+1 ‚ãÖ3f (a2)+1 ‚ãÖ5f (a3)+1 ‚ãÖ‚ãÖ‚ãÖpf (am)+1
m
,
where pm is the m-th prime. To prove that h: S ‚Üí‚Ñïis one-to-one, let ‚ü®a1, a2, . . . , am‚ü©and
‚ü®b1, b2, . . . , bn‚ü©be arbitrary elements of S and assume that
h(‚ü®a1, a2, . . . , am‚ü©) = h(‚ü®b1, b2, . . . , bn‚ü©).
Thus
2f (a1)+1 ‚ãÖ3f (a2)+1 ‚ãÖ5f (a3)+1 ‚ãÖ‚ãÖ‚ãÖpf (am)+1
m
= 2f (b1)+1 ‚ãÖ3f (b2)+1 ‚ãÖ5f (b3)+1 ‚ãÖ‚ãÖ‚ãÖpf (bn)+1
n
.
By Theorem 1.1.29, we conclude that m = n and
f (a1) + 1 = f (b1) + 1, f (a2) + 1 = f (b2) + 1, . . . , f (am) + 1 = f (bn) + 1.
Because f is one-to-one, we see that
a1 = b1, a2 = b2, . . . , am = bn.
Hence,
‚ü®a1, a2, . . . , am‚ü©= ‚ü®b1, b2, . . . , bn‚ü©,
and thus h: S ‚Üí‚Ñïis one-to-one. Therefore, S is countable.

1.1 Basic set theory
‡±™
13
Definition 1.1.31. Let A be a nonempty set. We shall say that A is denumerable if and
only if there is an enumeration
a1, a2, a3, . . . , an, . . .
(1.1)
of all of the elements in A, that is, every element in A appears in the above list indexed
by the positive natural numbers.
So a set is denumerable if we can list the elements of the set in the same way that we
list the set of nonzero natural numbers, namely, 1, 2, 3, 4, 5, . . . . However, our definition
of a denumerable set allows elements in the list (1.1) to be repeated, or not to be repeated.
We will show below that a countable set is denumerable. Using an enumeration
of a set will allow us to construct new sets that will be useful in Chapters 2 and 4 (for
example, see the proof of Theorem 2.4.2 on page 44).
Theorem 1.1.32. Let A be a nonempty countable set. Then there is a function g: ‚Ñï‚ÜíA
that is onto A.
Proof. Assume that A is a nonempty countable set. Thus, there is a function f : A ‚Üí‚Ñï
that is one-to-one. We shall use the function f to define our desired function g: ‚Ñï‚ÜíA.
Let c ‚ààA be some fixed element. Define g as follows: For each n ‚àà‚Ñï,
g(n) = {a,
if n is in the range of f and f (a) = n,
c,
otherwise.
Because f : A ‚Üí‚Ñïis one-to-one, one can show that g is a function and it is onto.
Corollary 1.1.33. Let A be a nonempty countable set. Then A is denumerable.
Proof. Assume that A is a nonempty countable set. Theorem 1.1.32 implies that there is a
function g: ‚Ñï‚ÜíA that is onto. For each n ‚â•1 let an = g(n ‚àí1). Since g is onto, it follows
that the enumeration a1, a2, a3, . . . , an, . . . lists every element in A.
1.1.7 Cardinality
The cardinality of a set is a measure of how many elements are in the set. For example,
the set A = {1, 2, 3, . . . , 10} has 10 elements, so the cardinality of A is 10, denoted by |A| =
10. The cardinality of an infinite set X will also be denoted by |X|. In this section, we
briefly discuss Georg Cantor‚Äôs method for measuring the size of an infinite set without
the use of numbers. There are two infinite sets where one of these sets has cardinality
much larger than the other infinite set. Therefore, it is possible for one infinite set to
have ‚Äúmany more‚Äù elements than another infinite set.
What does it mean to say that two sets have the same cardinality, that is, the same
size? Cantor discovered a simple answer to this question.

14
‡±™
1 Basic set theory and basic logic
Definition 1.1.34. For sets A and B, we say that A has the same cardinality as B, denoted
by |A| =c |B|, if there is a bijection f : A ‚ÜíB.
The expression |A| =c |B| looks like an equation; however, the assertion |A| =c |B|
should be viewed only as an abbreviation for the statement ‚ÄúA has the same cardinal-
ity as B.‚Äù In other words, |A| =c |B| means that ‚Äúthere is a function f : A ‚ÜíB that is
one-to-one and onto B.‚Äù The relationship =c, given in Definition 1.1.34, is reflexive, sym-
metric, and transitive.
The following theorem is very useful for proving many results about cardinality.
The theorem states that if there are functions f : A ‚ÜíB and g: B ‚ÜíA that are both one-
to-one, then there exists a function h: A ‚ÜíB that is one-to-one and onto B.
Theorem 1.1.35 (Schr√∂der‚ÄìBernstein). Let A and B be any two sets. Suppose that |A| ‚â§c |B|
and |B| ‚â§c |A|. Then |A| =c |B|.
1.1.8 The axiom of choice
Suppose that a set S contains only nonempty sets. Is it possible to uniformly select exactly
one element from each set in S? In other words, is there a function F so that for each
A ‚ààS, we have F(A) ‚ààA? The following set-theoretic principle will allow us to positively
answer this question.
Axiom of Choice. Let ùíûbe a set of nonempty sets. Then there is a function H: ùíû‚Üí‚ãÉùíû
such that H(A) ‚ààA for all A ‚ààùíû.
Cantor developed a theory of infinite cardinal numbers which, assuming the axiom
of choice, allows one to measure the size of any infinite set. Thus, if A is an infinite set,
there is a cardinal number Œ∫ such that Œ∫ = |A|. Moreover, there is an ordering on these
cardinal numbers such that for any cardinal numbers Œª and Œ∫, we have Œª ‚â§Œ∫ or Œ∫ ‚â§Œª.
Moreover, if Œª ‚â§Œ∫ and Œ∫ ‚â§Œª, then Œª = Œ∫. The cardinality of any countable infinite set
is denoted by the cardinal ‚Ñµ0.
Zorn‚Äôs lemma is an important theorem about sets that is normally used to prove the
existence of a mathematical object when it cannot be explicitly identified. The lemma
involves the concept of a chain. A chain is a collection of sets C such that for all sets x
and y in C, we have either x ‚äÜy or y ‚äÜx.
Zorn‚Äôs Lemma 1.1.36. Let ‚Ñ±be a set of sets. Suppose that for every chain C ‚äÜ‚Ñ±, ‚ãÉC is
in ‚Ñ±. Then there exists an M ‚àà‚Ñ±that is maximal, that is, M is not the proper subset of
any A ‚àà‚Ñ±.
Surprisingly, Zorn‚Äôs lemma is equivalent to the axiom of choice. There will be times
when we may apply the axiom of choice or Zorn‚Äôs lemma. However, when working with
countable sets, Corollary 1.1.33 will allow us to avoid such applications.

1.1 Basic set theory
‡±™
15
Exercises 1.1.
1. Let A be a set and let ‚Ñ±be a nonempty set of sets. Prove the following:
(1) A \ ‚ãÉ‚Ñ±= ‚ãÇ{A \ C : C ‚àà‚Ñ±},
(2) A \ ‚ãÇ‚Ñ±= ‚ãÉ{A \ C : C ‚àà‚Ñ±}.
2. Consider the function h: ‚Ñï‚Üí‚Ñïdefined by the recursion
(a) h(0) = 0,
(b) h(n + 1) = 5h(n) + 1, for all n ‚àà‚Ñï.
Prove by induction that h(n) = 5n‚àí1
4
for all n ‚àà‚Ñï.
3. Let A and B be countable sets. Since A is countable, there is a one-to-one func-
tion f : A ‚Üí‚Ñï. Also, as B is countable, there is a one-to-one function g: B ‚Üí‚Ñï.
(a) Prove that the function h: A ‚Üí‚Ñïdefined by h(a) = 2f (a)+1 is one-to-one.
(b) Prove that the function k: B ‚Üí‚Ñïdefined by k(b) = 3g(b)+1 is one-to-one.
(c) Define the function ‚Ñì: A ‚à™B ‚Üí‚Ñïby
‚Ñì(x) = {h(x),
if x ‚ààA,
k(x),
if x ‚ààB \ A,
for each x ‚ààA ‚à™B. Prove that ‚Ñìis one-to-one. Thus, A ‚à™B is countable.
4. Let ‚Ñì: ‚Ñï√ó ‚Ñï‚Üí‚Ñïbe defined by ‚Ñì(x, y) = 2x+1 ‚ãÖ3y+1 and let g: ‚Ñï‚Üí‚Ñïbe defined by
g(x) = 2x+1. Let C be the set generated from B = {1, 2} by the set ‚Ñ±= {‚Ñì, g}.
(a) Find C1 and then find an element in C2.
(b) Show that ‚ÑìC and gC are one-to-one (use Theorem 1.1.29).
(c) Show that the set C is freely generated by B.
(d) Let h: B ‚Üí‚Ñùbe defined by h(1) = œÄ and h(2) = e. Let F‚Ñì: ‚Ñù√ó ‚Ñù‚Üí‚Ñùand
Fg: ‚Ñù‚Üí‚Ñùbe defined by F‚Ñì(x, y) = x + y and Fg(x) = 5x. Let h: C ‚Üí‚Ñùbe the
function given by Theorem 1.1.27. Find h(36), h(4), and h(72).
*5. Let U be a set and let ‚Ñ±be a set of functions ‚Ñìof the form ‚Ñì: Un ‚ÜíU, where n is
the arity of ‚Ñì. Let B ‚äÜU and let C be generated from B by the functions in ‚Ñ±.
(a) Prove that C is closed under the functions in ‚Ñ±.
(b) Let B ‚äÜD, where D is closed under the functions in ‚Ñ±. Prove that C ‚äÜD.
6. Let U be a set and let ‚Ñ±be a set of functions ‚Ñìof the form ‚Ñì: Un ‚ÜíU, where n is
the arity of ‚Ñì. Let B ‚äÜU and let C be freely generated from B by the functions in ‚Ñ±.
Let f , g ‚àà‚Ñ±, x1, x2, . . . , xn ‚ààC, and z1, z2, . . . , zk ‚ààC. Suppose that f (x1, x2, . . . , xn) =
g(z1, z2, . . . , zk). Explain why one can conclude that f = g, n = k, and x1 = z1, x2 =
z2, . . . , xn = zk.
7. In the proof of Theorem 1.1.25, show that Cn ‚äÜI for all n ‚àà‚Ñï.
*8. Let U be a set and let ‚Ñ±be a set of functions ‚Ñìof the form ‚Ñì: Un ‚ÜíU, where n is
the arity of ‚Ñì. Let B ‚äÜB‚Ä≤ ‚äÜU. Let C be generated from B by the functions in ‚Ñ±and
let C‚Ä≤ be generated from B‚Ä≤ by the functions in ‚Ñ±. Prove that C ‚äÜC‚Ä≤.
*9. Let U be a set and let ‚Ñ±be a set of functions ‚Ñìof the form ‚Ñì: Un ‚ÜíU, where n is the
arity of ‚Ñì. For each ‚Ñì‚àà‚Ñ±, let F‚Ñì: V n ‚ÜíV be of the same arity as ‚Ñì. Let B ‚äÜB‚Ä≤ ‚äÜU.
Let C be freely generated from B by the functions in ‚Ñ±and let C‚Ä≤ be freely generated

16
‡±™
1 Basic set theory and basic logic
from B‚Ä≤ by the functions in ‚Ñ±. Let h: B ‚ÜíV and g: B‚Ä≤ ‚ÜíV be such that h(b) = g(b)
for all b ‚ààB. Show that h(x) = g(x) for all x ‚ààC.
*10. Let U be a set and let ‚Ñ±be a set of functions ‚Ñìof the form ‚Ñì: Un ‚ÜíU, where n
is the arity of ‚Ñì. For each ‚Ñì‚àà‚Ñ±, let F‚Ñì: V n ‚ÜíV be of the same arity as ‚Ñì. Let
B ‚äÜU, let h: B ‚ÜíV, and let C be freely generated from B by the functions in ‚Ñ±as
in Theorem 1.1.24, that is, C = ‚ãÉn‚àà‚ÑïCn, where:
(1) C0 = B,
(2) Cn+1 = Cn ‚à™‚Ñ±[Cn] for all n ‚àà‚Ñï.
Suppose that:
‚Äì
the function h is one-to-one;
‚Äì
for each ‚Ñì‚àà‚Ñ±, F‚Ñìis one-to-one and the functions h, F‚Ñìhave disjoint ranges;
‚Äì
F‚Ñìand F‚Ñì‚Ä≤ have disjoint ranges whenever ‚Ñì, ‚Ñì‚Ä≤ ‚àà‚Ñ±are distinct.
Let h: C ‚ÜíV be as in Theorem 1.1.27. Prove by induction on n that h is one-to-one
on Cn. Then conclude that h is one-to-one.
Exercise Notes: For Exercise 8, let I = C ‚à©C‚Ä≤. Using Theorem 1.1.25, prove that I = C.
For Exercise 9, C ‚äÜC‚Ä≤ by Exercise 8. Let I = {x ‚ààC : h(x) = g(x)}. Using Theorem 1.1.25,
prove that I = C. For Exercise 10, if c ‚ààCn+1, let k be the least such that c ‚ààCk. If k > 0,
then c is in the range of a function in ‚Ñ±restricted to Ck‚àí1.
1.2 Basic logic
1.2.1 Propositions and logical connectives
A proposition is a declarative sentence that is either true or false, but not both. When
discussing the logic of propositional statements in this section, we shall use symbols to
represent these statements. Capital letters, for instance, P, Q, R, are used to symbolize
propositional statements which may be called propositional components. Using the five
logical connectives ‚àß, ‚à®, ¬¨, ‚Üí, ‚Üîtogether with the components, we can form new logical
sentences called compound sentences. For example:
1.
P ‚àßQ (means ‚ÄúP and Q‚Äù and is called a conjunction),
2.
P ‚à®Q (means ‚ÄúP or Q‚Äù and is called a disjunction),
3.
¬¨P (means ‚Äúnot P‚Äù and is called a negation),
4.
P ‚ÜíQ (means ‚Äúif P, then Q‚Äù and is called a conditional),
5.
P ‚ÜîQ (means ‚ÄúP if and only if Q‚Äù and is called a biconditional).
Using the propositional components and the logical connectives, one can construct more
complicated sentences, for example,
((P ‚àß(¬¨Q)) ‚à®(S ‚Üí(¬¨R))).
We will more formally investigate propositional logic in Chapter 2.

1.2 Basic logic
‡±™
17
1.2.2 Truth tables and truth functions
Given a collection of propositional components, say P, Q, and R, we can assign truth
values to these components. For example, we can assign the truth values T, F, T to P, Q, R,
respectively, where T means ‚Äútrue‚Äù while F means ‚Äúfalse.‚Äù The truth value of a sentence
of propositional logic can be evaluated from the truth values assigned to its components.
We shall explain what this ‚Äúmeans‚Äù by using truth tables.
The logical connectives ‚àß, ‚à®, ¬¨ yield the natural truth values given by Table 1.1.
Table 1.1: Truth tables for conjunction, disjunction, and negation.
(1) Conjunction
(2) Disjunction
(3) Negation
P
Q
P ‚àßQ
P
Q
P ‚à®Q
P
¬¨P
T
T
T
T
T
T
T
F
T
F
F
T
F
T
F
T
F
T
F
F
T
T
F
F
F
F
F
F
Table 1.1(1) has four rows (not including the header). The columns beneath P and
Q list all the possible pairs of truth values that can be assigned to the components P
and Q. For each such pair, the corresponding truth value for P ‚àßQ appears to the right.
For example, consider the third pair of truth values in this table, FT. Thus, if the propo-
sitional components P and Q are assigned the respective truth values F and T, we see
that the truth value of P ‚àßQ is F.
Table 1.1(2) shows that if P and Q are assigned the respective truth values T and F,
then the truth value of P ‚à®Q is T. Moreover, when P and Q are assigned the truth values
T and T, the truth value of P ‚à®Q is also T. In mathematics, the logical connective ‚Äúor‚Äù
has the same meaning as ‚Äúand/or,‚Äù that is, P ‚à®Q is true if and only if only P is true, only
Q is true, or both P and Q are true. Table 1.1(3) shows that the negation of a statement
reverses the truth value of the statement.
A truth function accepts truth values as input and yields a unique truth value as out-
put. Let V = {T, F}. The above three truth tables yield the corresponding truth functions
F‚àß: V 2 ‚ÜíV, F‚à®: V 2 ‚ÜíV, and F¬¨: V ‚ÜíV, defined by
F‚àß(x, y) = {T,
if x = T and y = T,
F,
otherwise,
(1.2)
F‚à®(x, y) = {T,
if x = T or y = T,
F,
otherwise,
(1.3)
F¬¨(x) = {T,
if x = F,
F,
otherwise.
(1.4)

18
‡±™
1 Basic set theory and basic logic
The standard truth tables for the conditional and biconditional connectives are
given in Table 1.2, which states that when P and Q are assigned the respective truth
values T and F, then the truth value of P ‚ÜíQ is F; otherwise, it is T. In particular, when
P is false, we shall say that P ‚ÜíQ is vacuously true. Table 1.2(5) shows that P ‚ÜîQ is true
when P and Q are assigned the same truth value; when P and Q have different truth
values, then the biconditional is false.
Table 1.2: Truth tables for the conditional and biconditional.
(4) Conditional
(5) Biconditional
P
Q
P ‚ÜíQ
P
Q
P ‚ÜîQ
T
T
T
T
T
T
T
F
F
T
F
F
F
T
T
F
T
F
F
F
T
F
F
T
Let V
= {T, F}. The conditional and biconditional truth tables yield the two truth
functions F‚Üí: V 2 ‚ÜíV and F‚Üî: V 2 ‚ÜíV, defined by
F‚Üí(x, y) = {F,
if x = T and y = F,
T,
otherwise,
(1.5)
F‚Üî(x, y) = {T,
if x = y,
F,
otherwise.
(1.6)
Using the truth tables for the sentences P ‚àßQ, P ‚à®Q, ¬¨P, P ‚ÜíQ, and P ‚ÜîQ, one
can build truth tables for more complicated compound sentences. Given a compound
sentence, the ‚Äúoutside‚Äù connective is the ‚Äúlast connective that one needs to evaluate.‚Äù
After the outside connective has been determined, one can break up the sentence into
its ‚Äúparts.‚Äù For example, in the compound sentence ¬¨P ‚àß(Q ‚à®P) we see that ‚àßis the
outside connective with two parts ¬¨P and Q ‚à®P.
Problem 1.2.1. Construct a truth table for the sentence ¬¨P ‚Üí(Q ‚àßP).
Solution. The two components P and Q will each need a column in our truth table. Since
there are two components, there are four truth assignments for P and Q. We will enter
these combinations in the two leftmost columns in the same order as in Table 1.1(1). The
outside connective of the propositional sentence ¬¨P ‚Üí(Q ‚àßP) is ‚Üí. We can break this
sentence into the two parts ¬¨P and Q ‚àßP. So these parts will also need a column in our
truth table. As we can break the sentences ¬¨P and Q ‚àßP only into components (namely,
P and Q), we obtain the following truth table:

1.2 Basic logic
‡±™
19
P
Q
¬¨P
Q ‚àßP
¬¨P ‚Üí(Q ‚àßP)
T
T
F
T
T
T
F
F
F
T
F
T
T
F
F
F
F
T
F
F
Step #
1
1
2
3
4
We will now describe in steps how to obtain the truth values in the above table.
Step 1: Specify all of the truth values that can be assigned to the components.
Step 2: In each row, use the truth value assigned to the component P to obtain the cor-
responding truth value for ¬¨P, using Table 1.1(3).
Step 3: In each row, use the truth values assigned to Q and P to determine the corre-
sponding truth value in the column under Q ‚àßP via Table 1.1(1).
Step 4: In each row, use the truth values assigned to ¬¨P and Q‚àßP to evaluate the match-
ing truth value for the final column under the sentence ¬¨P ‚Üí(Q‚àßP), employing
Table 1.2(4).
1.2.3 Predicates and quantifiers
Variables are used throughout mathematics and logic to represent unspecified values.
They are used when one is interested in ‚Äúproperties‚Äù that may be true or false depending
on the values represented by the variables. A predicate is just a statement that asserts
that certain variables satisfy a property. For example, ‚Äúx is an irrational number‚Äù is a
predicate. We can symbolize this predicate as Ix, where I is called a predicate symbol.
Of course, the truth or falsity of the expression Ix can be evaluated only when a value
for x is given. For example, if x is given the value ‚àö2, then Ix would be true, whereas if
x is given the value 2, then Ix would be false.
When our attention is focused on just the elements in a particular set, we will re-
fer to that set as our universe of discourse. For example, if we were just talking about
real numbers, then our universe of discourse would be the set of real numbers ‚Ñù. Ev-
ery statement made in a specific universe of discourse applies only to the elements in
that universe.
Given a predicate Px and variable x, we may want to assert that every element x
in the universe of discourse satisfies Px. We may also want to express the fact that at
least one element x in the universe makes Px true. We can then form logical sentences
using the quantifiers ‚àÄand ‚àÉ. The quantifier ‚àÄmeans ‚Äúfor all‚Äù and is called the universal
quantifier. The quantifier ‚àÉmeans ‚Äúthere exists‚Äù and it is referred to as the existential
quantifier. For example, we can form the sentences:
1.
‚àÄxPx (which means ‚Äúfor all x, Px‚Äù),
2.
‚àÉxPx (which means ‚Äúthere exists an x such that Px‚Äù).

20
‡±™
1 Basic set theory and basic logic
A statement of the form ‚àÄxPx is called a universal statement. Any statement having the
form ‚àÉxPx is called an existential statement. Quantifiers offer a valuable tool for clear
thinking in mathematics, where many ideas begin with the expression ‚Äúfor every‚Äù or
‚Äúthere exists.‚Äù Of course, the truth or falsity of a quantified statement depends on the
particular universe of discourse.
Let x be a variable that appears in a predicate Px. In the statements ‚àÄxPx and ‚àÉxPx,
we say that x is a bound variable because x is bound by a quantifier. In other words,
when every occurrence of a variable in a statement is attached to a quantifier, then
that variable is called a bound variable. If a variable appears in a statement and it is
not bound by a quantifier, then the variable is said to be a free variable. Whenever a
variable is free, substitution may take place, that is, one can replace a free variable with
any particular value from the universe of discourse‚Äîperhaps 1 or 2. For example, the
assertion ‚àÄx(Px ‚Üíx = y) has the one free variable y. Therefore, we can perform a
substitution to obtain ‚àÄx(Px ‚Üíx = 1). In a given context, if all of the free variables
in a statement are replaced with values from the universe of discourse, then one can
determine the truth or falsity of the resulting statement.
Problem 1.2.2. Consider the predicates (properties) Px, Ox, and Dxy, where the vari-
ables x and y are intended to represent natural numbers:
1.
Px represents the statement ‚Äúx is a prime number,‚Äù
2.
Ox represents the statement ‚Äúx is an odd natural number,‚Äù
3.
Dxy represents the statement ‚Äúx evenly divides y.‚Äù
Using the above predicates, determine whether or not the following logical formulas are
true or false, where the universe of discourse is the set of natural numbers:
1.
‚àÄx(Px ‚ÜíOx),
2.
‚àÄy(y ‚â•2 ‚Üí‚àÉx(Px ‚àßDxy)).
Solution. The expression ‚àÄx(Px ‚ÜíOx) states that ‚Äúall prime numbers are odd,‚Äù which
is clearly false. On the other hand, item 2 states that ‚Äúevery natural number greater than
or equal to 2 is divisible by a prime number‚Äù and this is true.
We will formally investigate predicates and quantifiers in Chapter 3. The under-
standing of the logic of quantifiers is (one can argue) a requisite tool for the study
of mathematics and logic. To help students learn the language of quantifier logic, Jon
Barwise and John Etchemendy created an innovative software program called Tarski‚Äôs
World. This program presents a visual display of geometric shapes sitting on a grid, re-
ferred to as a world (or universe). The shapes have a variety of colors and positions on
the grid. The user can create logic formulas and then determine whether or not these
formulas are true or false in the world. Tarski‚Äôs World is named after Alfred Tarski,
an early pioneer in mathematical logic. We end this section with our own version of
Tarski‚Äôs World. In the following problem, we are given a Tarskian World and some

1.2 Basic logic
‡±™
21
English statements. We will be given some predicates and be asked to translate these
statements into logical form.
Problem 1.2.3. Consider the following Tarskian World, where some of the individuals
are labeled with a name. The universe consists of all the objects in this Tarskian world.
Define the following predicates (properties):
‚Äì
Tx means ‚Äúx is a triangle.‚Äù Cx means ‚Äúx is a circle.‚Äù Sx means ‚Äúx is a square.‚Äù
‚Äì
Ix means ‚Äúx is white.‚Äù Gx means ‚Äúx is gray.‚Äù Bx means ‚Äúx is black.‚Äù
‚Äì
Nxy means ‚Äúx is on the northern side of y.‚Äù
‚Äì
Wxy means ‚Äúx is on the western side of y.‚Äù
‚Äì
Kxy means ‚Äúx has the same color as y.‚Äù
The constants a, c, d, g, j are the names of five individuals in the above world. Using the
given predicates, write each of the following statements in logical form, looking for pos-
sible hidden quantifiers and logical connectives.
1.
There is a black square.
2.
Every circle is white.
3.
There are no black circles.
4.
a is north of c.
5.
a is not north of j.
6.
Every circle is north of d.
7.
Some circle has the same color as d.
8.
d is west of every circle.
Solution. Statements 2, 6, and 7 are the only ones that are false in the given Tarskian
world. We express the above sentences in the following logical forms:
1.
The sentence means that ‚Äúfor some x, x is black and x is a square.‚Äù In logical form,
we have ‚àÉx(Bx ‚àßSx).
2.
The sentence means that ‚Äúfor all x, if x is a circle, then x is white.‚Äù In logical form,
‚àÄx(Cx ‚ÜíIx).

22
‡±™
1 Basic set theory and basic logic
3.
The sentence can be stated in two equivalent ways. First, the sentence means that
‚Äúit is not the case that some circle is black,‚Äù that is, ¬¨(some circle is black). In logical
form, we obtain ¬¨‚àÉx(Cx ‚àßBx). Second, the sentence also means that ‚Äúevery circle is
not black‚Äù and we get ‚àÄx(Cx ‚Üí¬¨Bx).
4.
In logical form, the sentence becomes Nac.
5.
The logical form of this sentence is ¬¨Naj.
6.
Rephrasing, we obtain ‚Äúfor all x, if x is a circle, then x is north of d.‚Äù In logical form,
we have ‚àÄx(Cx ‚ÜíNxd).
7.
The sentence asserts that ‚Äúfor some x, x is a circle and x has the same color as d.‚Äù In
logical form, we have ‚àÉx(Cx ‚àßKxd).
8.
Stated more clearly, we obtain ‚Äúfor all x, if x is a circle, then d is west of x.‚Äù In logical
form, we have ‚àÄx(Cx ‚ÜíWdx).
There will be cases when we will have to prove that there is exactly one value that
satisfies a property. There is another quantifier that is sometimes used. It is called the
uniqueness quantifier. This quantifier is written as ‚àÉ!xPx, which means that ‚Äúthere exists
a unique x satisfying Px,‚Äù whereas ‚àÉxPx simply asserts that ‚Äúat least one x satisfies Px.‚Äù
The quantifier ‚àÉ! can be expressed in terms of the other quantifiers ‚àÉand ‚àÄ. In
particular, the statement ‚àÉ!xPx is equivalent to
‚àÉxPx ‚àß‚àÄx‚àÄy((Px ‚àßPy) ‚Üíx = y),
because the above statement means that ‚Äúthere is an x such that Px holds, and any indi-
viduals x and y that satisfy Px and Py must be the same individual.‚Äù
Quantifier negation laws
We now introduce logic laws that involve the negation of quantifiers. Let Px be any pred-
icate. The statement ‚àÄxPx means that ‚Äúfor every x, Px is true.‚Äù Thus, the assertion ¬¨‚àÄxPx
means that ‚Äúit is not the case that every x makes Px true.‚Äù Therefore, ¬¨‚àÄxPx means there
is an x that does not make Px true, which can be expressed as ‚àÉx¬¨Px. This reasoning is
reversible, as we will now show. The assertion ‚àÉx¬¨Px means that ‚Äúthere is an x that
makes Px false.‚Äù Hence, Px is not true for every x, that is, ¬¨‚àÄxPx. Therefore, ¬¨‚àÄxPx and
‚àÉx¬¨Px are logically equivalent. Similar reasoning shows that ¬¨‚àÉxPx and ‚àÄx¬¨Px are also
equivalent. We now formally present these important logic laws that connect quanti-
fiers with negation.
Quantifier Negation Laws 1.2.4. The following logical equivalences hold for any pred-
icate Px:
1.
¬¨‚àÄxPx ‚áî‚àÉx¬¨Px,
2.
¬¨‚àÉxPx ‚áî‚àÄx¬¨Px,
3.
¬¨‚àÄx¬¨Px ‚áî‚àÉxPx,
4.
¬¨‚àÉx¬¨Px ‚áî‚àÄxPx.

1.2 Basic logic
‡±™
23
We will be using the symbols ‚áîand ‚áíto abbreviate two English expressions. The
symbol ‚áîdenotes the phrase ‚Äúis equivalent to‚Äù and ‚áídenotes the word ‚Äúimplies.‚Äù
Quantifier interchange laws
Adjacent quantifiers have four forms: ‚àÉx‚àÉy, ‚àÄx‚àÄy, ‚àÄx‚àÉy, and ‚àÉx‚àÄy. How should one in-
terpret statements that contain adjacent quantifiers? If a statement contains adjacent
quantifiers, one should address the quantifiers, one at a time, in the order in which they
are presented. This is illustrated in our solutions of the following three problems.
Problem 1.2.5. Let the universe of discourse be a group of people and let Lxy mean ‚Äúx
likes y.‚Äù What do the following formulas mean in English?
1.
‚àÉx‚àÉyLxy,
2.
‚àÉy‚àÉxLxy.
Solution. Note that ‚Äúx likes y‚Äù also means that ‚Äúy is liked by x.‚Äù We will now translate
each of these formulas from ‚Äúleft to right‚Äù as follows:
1.
‚àÉx‚àÉyLxy means ‚Äúthere is a person x such that ‚àÉyLxy,‚Äù that is, ‚Äúthere is a person x
who likes some person y.‚Äù Therefore, ‚àÉx‚àÉyLxy means that ‚Äúsomeone likes someone.‚Äù
2.
‚àÉy‚àÉxLxy states that ‚Äúthere is a person y such that ‚àÉxLxy,‚Äù that is, ‚Äúthere is a person
y who is liked by some person x.‚Äù Thus, ‚àÉy‚àÉxLxy means that ‚Äúsomeone is liked by
someone.‚Äù
Hence, the statements ‚àÉx‚àÉyLxy and ‚àÉy‚àÉxLxy mean the same thing.
Problem 1.2.6. Let the universe of discourse be a group of people and let Lxy mean ‚Äúx
likes y.‚Äù What do the following formulas mean in English?
1.
‚àÄx‚àÄyLxy,
2.
‚àÄy‚àÄxLxy.
Solution. We will work again from ‚Äúleft to right‚Äù as follows:
1.
‚àÄx‚àÄyLxy means ‚Äúfor every person x, we have ‚àÄyLxy,‚Äù that is, ‚Äúfor every person x, x
likes every person y‚Äù; hence, ‚àÄx‚àÄyLxy means that ‚Äúeveryone likes everyone‚Äù;
2.
‚àÄy‚àÄxLxy means that ‚Äúfor each person y, we have ‚àÄxLxy,‚Äù that is, ‚Äúfor each person y,
y is liked by every person x‚Äù; thus, ‚àÄy‚àÄxLxy means ‚Äúeveryone is liked by everyone.‚Äù
So the statements ‚àÄx‚àÄyLxy and ‚àÄy‚àÄxLxy mean the same thing.
Adjacent quantifiers of a different type are referred to as mixed quantifiers.
Problem 1.2.7. Let the universe of discourse be a group of people and let Lxy mean ‚Äúx
likes y.‚Äù What do the following mixed quantifier formulas mean in English?
1.
‚àÄx‚àÉyLxy,
2.
‚àÉy‚àÄxLxy.

24
‡±™
1 Basic set theory and basic logic
Solution. We will translate the formulas as follows:
1.
‚àÄx‚àÉyLxy asserts that ‚Äúfor every person x, we have ‚àÉyLxy,‚Äù that is, ‚Äúfor every per-
son x, there is a person y such that x likes y.‚Äù Thus, ‚àÄx‚àÉyLxy means that ‚Äúeveryone
likes someone.‚Äù
2.
‚àÉy‚àÄxLxy states that ‚Äúthere is a person y such that ‚àÄxLxy,‚Äù that is, ‚Äúthere is a person
y who is liked by every person x.‚Äù In other words, ‚àÉy‚àÄxLxy means ‚Äúsomeone is liked
by everyone.‚Äù
We conclude that the mixed quantifier statements ‚àÄx‚àÉyLxy and ‚àÉy‚àÄxLxy are not logi-
cally equivalent, that is, they do not mean the same thing.
To clarify the conclusion that we obtained in our solution of Problem 1.2.7, consider
the universe of discourse U = {a, b, c, d}, which consists of just four individuals with
names as given. Figure 1.1 presents a world in which ‚àÄx‚àÉyLxy is true, where we por-
tray the property Lxy using the ‚Äúarrow notation‚Äù x
likes
Û≥®ÄÛ≥®ÄÛ≥®ÄÛ≥®Ä‚Üíy. In this world, ‚Äúeveryone
likes someone.‚Äù
Figure 1.1: A world where ‚àÄx‚àÉyLxy is true, because everyone likes someone.
Let us focus our attention on Figure 1.1. Clearly, the statement ‚àÄx‚àÉyLxy is true in the
world depicted in this figure. Moreover, note that ‚àÉy‚àÄxLxy is actually false in this world.
This is the case because there is no individual whom everyone likes. Thus, ‚àÄx‚àÉyLxy is
true and ‚àÉy‚àÄxLxy is false in the world of Figure 1.1. We can now conclude that ‚àÄx‚àÉyLxy
and ‚àÉy‚àÄxLxy do not mean the same thing.
Our solution to Problem 1.2.5 shows that assertions ‚àÉx‚àÉyLxy and ‚àÉy‚àÉxLxy both
mean ‚Äúsomeone likes someone.‚Äù This supports the equivalence:
‚àÉx‚àÉyLxy ‚áî‚àÉy‚àÉxLxy.
Similarly, Problem 1.2.6 confirms the equivalence:
‚àÄx‚àÄyLxy ‚áî‚àÄy‚àÄxLxy.
Therefore, interchanging adjacent quantifiers of the same kind does not change the
meaning. Problem 1.2.7, however, demonstrates that the two statements ‚àÄy‚àÉxLxy and
‚àÉx‚àÄyLxy are not equivalent. We conclude this discussion with a summary of the above
observations:

1.2 Basic logic
‡±™
25
‚Äì
Adjacent quantifiers of the same type are interchangeable.
‚Äì
Adjacent quantifiers of a different type may not be interchangeable.
Quantifier Interchange Laws 1.2.8. For every predicate Pxy, the following three state-
ments are valid:
1.
‚àÉx‚àÉyPxy ‚áî‚àÉy‚àÉxPxy,
2.
‚àÄx‚àÄyPxy ‚áî‚àÄy‚àÄxPxy,
3.
‚àÉx‚àÄyPxy ‚áí‚àÄy‚àÉxPxy.
It should be noted that the implication in item 3 cannot, in general, be reversed.
Quantifier distribution laws
A quantifier can sometimes ‚Äúdistribute‚Äù over a conjunction or a disjunction. The quanti-
fier distribution laws, given below, express relationships that hold between a quantifier
and the two logical connectives ‚à®and ‚àß. Namely, the existential quantifier distributes
over disjunction (see 1.2.9(1)), and the universal quantifier distributes over conjunction
(see 1.2.9(2)). The following four quantifier distribution laws can be useful when prov-
ing certain set identities.
Quantifier Distribution Laws 1.2.9. For any predicates Px and Qx, we have the follow-
ing distribution laws:
1.
‚àÉxPx ‚à®‚àÉxQx ‚áî‚àÉx(Px ‚à®Qx),
2.
‚àÄxPx ‚àß‚àÄxQx ‚áî‚àÄx(Px ‚àßQx).
If R is a predicate that does not involve the variable x, then we have:
3.
R ‚àß‚àÉxQx ‚áî‚àÉx(R ‚àßQx),
4.
R ‚à®‚àÄxQx ‚áî‚àÄx(R ‚à®Qx).
Exercises 1.2.
1. Let C(x) represent the predicate ‚Äúx is in the class‚Äù and let Mx represent ‚Äúx is a
mathematics major.‚Äù Let the universe of discourse be the set of all students. Analyze
the logical form of the following sentences.
(a) Everyone in the class is a mathematics major.
(b) Someone in the class is a mathematics major.
(c) No one in the class is a mathematics major.
2. Determine whether the following statements are true or false in the universe ‚Ñù:
(a) ‚àÄx(x2 + 1 > 0),
(b) ‚àÄx(x2 + x ‚â•0),
(c) ‚àÄx(x > 1
2 ‚Üí1
x < 3),
(d) ‚àÉx( 1
x‚àí1 = 3),
(e) ‚àÉx( 1
x‚àí1 = 0).
3. Given the properties and the Tarskian world in Problem 1.2.3 on page 21, determine
the truth or falsity of the following statements:

26
‡±™
1 Basic set theory and basic logic
(a) ‚àÄx(Ix ‚Üí(Tx ‚à®Sx)),
(b) ‚àÄx(Bx ‚Üí(Tx ‚à®Sx)),
(c) ‚àÉy(Cy ‚àßNyd),
(d) ‚àÉy(Cy ‚àßNdy),
(e) ‚àÉy(Cy ‚àß(Nyd ‚àßNdy)).
4. Using the Tarskian predicates given in Problem 1.2.3, translate the following English
sentences into logical sentences where b and d are names of individuals in some
Tarskian world:
(a) Something is white.
(b) Some circle is white.
(c) All squares are black.
(d) No squares are black.
(e) All triangles are west of d.
(f) A triangle is west of d.
(g) Some triangle is north of d.
(h) Some triangle is not gray.
(i)
Every triangle is north of b.
(j)
No square has the same color as b.

2 Propositional logic
In this chapter we will utilize mathematical tools, namely induction and recursion, to
formally investigate an important form of logic called propositional logic. In particular,
we will establish a number of significant theorems concerning the syntax and semantics
of propositional logic. An informal introduction to this topic is given in Section 1.2.1.
2.1 The language
The syntax of the language of propositional logic is specified by first identifying the sym-
bols (the alphabet) of the language and then defining expressions to be any finite string
of these symbols. Some expressions are meaningful while others are not. To single out
the meaningful expressions requires a recursive definition (see Section 1.1.5). The mean-
ingful expressions in propositional logic will be called well-formed formulas (wffs).
Definition 2.1.1. Our official language for propositional logic, denoted by ‚Ñí, consists of
the distinct symbols in the set
‚Ñí= { (, ), ¬¨, ‚àß, ‚à®, ‚Üí, ‚Üî, A1, A2, . . . , An, . . . },
where the symbols in the language ‚Ñíare described in the following table:
Symbol
Name
Remark
(
left parenthesis
punctuation
)
right parenthesis
punctuation
¬¨
negation
English: not
‚àß
conjunction
English: and
‚à®
disjunction
English: or
‚Üí
conditional
English: if , then
‚Üî
biconditional
English: if and only if
A‡∞∏
first sentence symbol
A‡∞π
second sentence symbol
...
...
An
n-th sentence symbol
...
...
Remark. Several remarks are in order:
1.
The distinct symbols ¬¨, ‚àß, ‚à®, ‚Üí, ‚Üîare called logical connectives.
2.
The infinite number of distinct symbols A1, A2, . . . , An, . . . are called sentence sym-
bols. Each Ai stands for a particular sentence.
Recall that ‚ü®a1, a2, . . . , an‚ü©denotes a sequence (see Definition 1.1.6).
https://doi.org/10.1515/9783110782073-002

28
‡±™
2 Propositional logic
Definition 2.1.2. An ‚Ñí-expression is a finite string of symbols from ‚Ñíobtained by omit-
ting the sequence brackets ‚ü®‚ü©and the commas from a finite sequence of symbols from ‚Ñí.
If Œ± and Œ≤ are ‚Ñí-expressions, then Œ±Œ≤ is the ‚Ñí-expression consisting of the symbols in the
expression Œ± followed by the symbols in the expression Œ≤.
Example 2.1.3. Clearly, ‚ü®(, ¬¨, A1, )‚ü©is a finite sequence of symbols from ‚Ñí, and after re-
moving the sequence brackets and commas we obtain the ‚Ñí-expression (¬¨A1). Let Œ± =
(¬¨A1) and Œ≤ = A1. Then Œ± and Œ≤ are ‚Ñí-expressions. In addition, we can write (Œ± ‚ÜíŒ≤)
to denote the ‚Ñí-expression ((¬¨A1) ‚ÜíA1). Also, note that ¬¨ ‚Üí)(A8 is an ‚Ñí-expression.
Moreover, Œ±Œ≤ is the expression (¬¨A1)A1.
There is a one-to-one correspondence between each ‚Ñí-expression Œ± and a finite se-
quence of symbols in ‚Ñídenoted by ‚ü®Œ±‚àó‚ü©, where Œ±‚àódenotes the result of putting commas
between all of the symbols in Œ±. So an ‚Ñí-expression Œ± is a proper initial segment of the
‚Ñí-expression Œ≤ when ‚ü®Œ±‚àó‚ü©is a proper initial segment of ‚ü®Œ≤‚àó‚ü©(see Definition 1.1.6).
Grammatically correct expressions
Is the English expression ‚Äúthen work not. is, Sally work is Bill if at at‚Äù a grammatically
correct sentence? No! English expressions that are not grammatically correct make no
sense. This observation motivates the following question: What does it mean for an
‚Ñí-expression to be grammatically correct? Surely, the ‚Ñí-expression (A2 ‚ÜíA5) is a mean-
ingful expression. However, the expression ‚ÜíA2)(A5 appears to be nonsensical. We
know that English has ‚Äúcorrect grammar.‚Äù Can we give the language ‚Ñícorrect gram-
mar? The answer is yes.
We want to define the notion of a well-formed formula (wff ) in the language ‚Ñí. The
wffs will be the grammatically correct ‚Ñí-expressions. Our definition will have the fol-
lowing consequences:
(a) Every sentence symbol is a wff.
(b) If Œ± and Œ≤ are wffs, then so are (¬¨Œ±), (Œ± ‚àßŒ≤), (Œ± ‚à®Œ≤), (Œ± ‚ÜíŒ≤), and (Œ± ‚ÜîŒ≤).
(c) Every wff is obtained by applying (a) or (b).
We will often use lower-case Greek characters to represent wffs and upper-case Greek
characters to represent sets of wffs.
Items (a)‚Äì(c) above declare that every sentence symbol is a wff and every other wff
is built from other wffs by using the logical connectives and parentheses in particular
ways. For example, A1123, (A2 ‚Üí(¬¨A1)), and (((¬¨A1)‚àß(A1 ‚ÜíA7)) ‚ÜíA7) are all wffs, but
X3, (A5), ()¬¨A41, A5 ‚ÜíA7), and (A2 ‚à®(¬¨A1) are not wffs.
In order to define wffs we will need the following five formula building functions:
Let Œ± and Œ≤ be ‚Ñí-expressions. Then
‚Ñ∞¬¨(Œ±) = (¬¨Œ±),
‚Ñ∞‚àß(Œ±, Œ≤) = (Œ± ‚àßŒ≤),
‚Ñ∞‚à®(Œ±, Œ≤) = (Œ± ‚à®Œ≤),
(2.1)

2.1 The language
‡±™
29
‚Ñ∞‚Üí(Œ±, Œ≤) = (Œ± ‚ÜíŒ≤),
‚Ñ∞‚Üî(Œ±, Œ≤) = (Œ± ‚ÜîŒ≤).
Using the above operations, our next definition is an application of Theorem 1.1.24.
Definition 2.1.4. Let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚àß, ‚Ñ∞‚à®, ‚Ñ∞‚Üí, ‚Ñ∞‚Üî} and let ùíÆ‚äÜ{A1, A2, A3, . . . } be a set of
sentence symbols in the language ‚Ñí. Let ùíÆbe the set generated from ùíÆby the functions
in ‚Ñ±. An ‚Ñí-expression Œ± is a well-formed formula (wff or formula) with sentence symbols
in ùíÆif and only if Œ± ‚ààùíÆ. The set ùíÆis the set of wffs that can be built from the symbols
in S using the five formula building functions in (2.1). When ùíÆis the set of all sentence
symbols, we shall just say that Œ± is a well-formed formula (wff or formula).
For example, if S = {A3, A7}, then ùíÆconsists of the wffs whose only sentence symbols
are A3 and/or A7.
Remark. Let ùíÆand ùíØbe sets of sentence symbols. Exercise 8 on page 37 implies that if
ùíÆ‚äÜùíØ, then ùíÆ‚äÜùíØ.
Definition 2.1.4 asserts that a wff is an expression that can be built from sentence
symbols by applying the formula building functions a finite number of times (see Sec-
tion 1.1.5). Thus, a wff is constructed by using the sentence symbols as building blocks
and the formula building functions as mortar. This leads to the following definition,
which gives a road map for the construction of a particular wff.
Definition 2.1.5. A construction sequence is a finite sequence ‚ü®Œµ1, Œµ2, . . . , Œµn‚ü©of ‚Ñí-expres-
sions such that for each i ‚â§n one of the following holds:
1.
Œµi is a sentence symbol,
2.
Œµi = ‚Ñ∞¬¨(Œµj) for some j < i,
3.
Œµi = ‚Ñ∞‚ä°(Œµj, Œµk) for some j < i and k < i, where ‚ä°represents any of the connectives
‚àß, ‚à®, ‚Üí, ‚Üî.
An ‚Ñí-expression Œ± is a wff whenever there is a construction sequence ‚ü®Œµ1, Œµ2, . . . , Œµn‚ü©
such that Œ± = Œµn, that is, the sequence ends in Œ±.
Problem 2.1.6. Let Œ± denote the wff ((A1 ‚àßA10) ‚Üí((¬¨A3) ‚à®A8)). Identify a construction
sequence that ends with Œ±.
Solution. The following ‚Äútree‚Äù gives a picture of how the above wff Œ± is constructed
from its sentence symbols using the formula building functions:

30
‡±™
2 Propositional logic
Thus we have the following construction sequence that ends in Œ±:
‚ü®A1, A10, (A1 ‚àßA10), A3, (¬¨A3), A8, ((¬¨A3) ‚à®A8), Œ±‚ü©.
Induction on wffs principle
To construct a wff, one starts with the sentence symbols and then applies the formula
building functions. Consequently, Theorem 1.1.25 yields the following induction on wffs
principle and associated proof strategy.
Wff Induction Principle. Let ùïä(Œ±) be a statement about a wff Œ±. If
1.
ùïä(Ai) is true for every sentence symbol Ai and
2.
for all wffs Œ± and Œ≤, if ùïä(Œ±) and ùïä(Œ≤), then ùïä((¬¨Œ±)) and ùïä((Œ± ‚ä°Œ≤)) (here ‚ä°represents
each of the connectives ‚àß, ‚à®, ‚Üí, ‚Üî),
then ùïä(Œ±) is true for all wffs Œ±.
Proof Strategy. In order to prove a statement ‚Äúfor all wffs Œ±, ùïä(Œ±)‚Äù by induction, use the
following diagram:
Base step:
Prove ùïä(Ai) for all sentence symbols Ai.
Inductive step:
Let Œ± and Œ≤ be arbitrary wffs.
Assume ùïä(Œ±) and ùïä(Œ≤).
Prove ùïä((¬¨Œ±)) and ùïä((Œ± ‚ä°Œ≤)).
Applications of the induction principle
Theorem 2.1.7. Let Œ± be any wff. The number of left parentheses equals the number of
right parentheses in Œ±.
Proof. We shall use proof by induction on wffs.
Base step: Let Œ± = Ai be a sentence symbol. Then Ai has zero left parentheses and the
same number of right parentheses.
Inductive step: Let Œ± and Œ≤ be arbitrary wffs. Assume the induction hypothesis
the number of left parentheses in Œ± equals the number of right parentheses,
the number of left parentheses in Œ≤ equals the number of right parentheses.
(IH)
We must prove that the same holds for each of the following:
(¬¨Œ±), (Œ± ‚àßŒ≤), (Œ± ‚à®Œ≤), (Œ± ‚ÜíŒ≤), (Œ± ‚ÜîŒ≤).
From the induction hypothesis (IH), it immediately follows that the number of left paren-
theses in (¬¨Œ±) equals the number of right parentheses. A similar argument applies for
the rest of the binary connectives.

2.1 The language
‡±™
31
Theorem 2.1.8. A proper initial segment of a wff has more left parentheses than right
parentheses. Thus, no proper initial segment of a wff is itself a wff.
Proof. We shall use proof by induction on wffs.
Base step: Let Œ± = Ai be a sentence symbol. Since Ai has no proper initial segments, the
result follows vacuously.
Inductive step: Let Œ± and Œ≤ be arbitrary wffs. Assume the induction hypothesis
a proper initial segment of Œ± has more left parentheses than right parentheses,
a proper initial segment of Œ≤ has more left parentheses than right parentheses.
(IH)
We must prove that any proper initial segment of each of the following has more left
parentheses than right parentheses:
(¬¨Œ±), (Œ± ‚àßŒ≤), (Œ± ‚à®Œ≤), (Œ± ‚ÜíŒ≤), (Œ± ‚ÜîŒ≤).
Let us first consider the wff (Œ± ‚à®Œ≤). Any proper initial segment of (Œ± ‚à®Œ≤) has one of the
following forms:
1.
(,
2.
(Œ±0, where Œ±0 is a proper initial segment of Œ±,
3.
(Œ±,
4.
(Œ± ‚à®,
5.
(Œ± ‚à®Œ≤0, where Œ≤0 is a proper initial segment of Œ≤,
6.
(Œ± ‚à®Œ≤.
Case 1 is clear. In cases 3, 4, and 6, Theorem 2.1.7 implies that these proper initial
segments have more left parentheses than right ones. For cases 2 and 5, the induction
hypothesis implies that these two proper initial segments have more left parentheses
than right parentheses. A similar argument applies for the other logical connectives.
Theorem 2.1.7 now implies that a proper initial segment of a wff is not a wff.
Exercises 2.1.
1. Let B and S be sentence symbols that represent the sentences ‚ÄúBill is at work‚Äù and
‚ÄúSally is at work,‚Äù respectively. Translate the following English sentences into wffs:
(a) Bill is at work and Sally is not at work.
(b) If Bill is at work, then Sally is not at work.
(c) Bill is not at work if and only if Sally is at work.
2. Let Œ± be the wff ((¬¨A1) ‚Üí((A4‚à®(A3 ‚ÜîA2))‚àßA3)). Identify a construction sequence
that ends with Œ±.
3. Given any wff Œ±, let
s(Œ±) = the number of occurrences of sentence symbols in Œ±,

32
‡±™
2 Propositional logic
c(Œ±) = the number of occurrences of binary connectives in Œ±.
Prove by induction on Œ± the following statement: For all wffs Œ±, s(Œ±) = c(Œ±) + 1.
4. In the inductive step in the proof of Theorem 2.1.8, using the induction hypothesis,
show that any proper initial segment of (¬¨Œ±) is not a wff.
5. Prove by induction on Œ± the following statement: For every wff Œ± there is a con-
struction sequence that ends with Œ± (see Definition 1.1.6).
6. Let Œ±1, Œ±2, . . . , Œ±n be wffs, where n > 1. Show that Œ±1Œ±2 ‚ãÖ‚ãÖ‚ãÖŒ±n is not a wff.
2.2 Truth assignments
The set of truth values {F, T} consists of two distinct items:
F, called falsity,
T, called truth.
Clearly, there are an infinite number of sentence symbols. Suppose that we have truth
values assigned to each of these sentence symbols. Can we then identify a function that
will evaluate the truth value of all the wffs? If so, is there only one such function? In
order to address these questions, we first need to establish a unique readability theorem,
that is, we need to show that one can read a wff without ambiguity.
Theorem 2.2.1 (Unique readability). Let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚àß, ‚Ñ∞‚à®, ‚Ñ∞‚Üí, ‚Ñ∞‚Üî} and let B = {A1, A2, A3,
. . . }. When restricted to the set of wffs, we have the following:
(a) The range of each operation in ‚Ñ±is disjoint from B.
(b) Any two distinct operations in ‚Ñ±have disjoint ranges.
(c) Every operation in ‚Ñ±is one-to-one.
In other words, the set of all wffs is freely generated from the set of sentence symbols by
the five operations ‚Ñ∞‚àß, ‚Ñ∞‚à®, ‚Ñ∞¬¨, ‚Ñ∞‚Üí, ‚Ñ∞‚Üî.
Proof. Let ‚Ñ±= {‚Ñ∞‚àß, ‚Ñ∞‚à®, ‚Ñ∞¬¨, ‚Ñ∞‚Üí, ‚Ñ∞‚Üî} and let B = {A1, A2, A3, . . . }.
(a) We show that the range of ‚Ñ∞‚àßis disjoint from B. Let Œ± and Œ≤ be wffs. Clearly, (Œ±‚àßŒ≤)
Ã∏=
Ai, because Ai has no parentheses. Hence, the range of ‚Ñ∞‚àßis disjoint from B. A similar
argument applies for the other operations in ‚Ñ±.
(b) We need to show that any two distinct operations in ‚Ñ±have disjoint ranges. Let
Œ±, Œ≤, Œ≥, and œÉ be wffs. Suppose that (Œ± ‚àßŒ≤) = (Œ≥ ‚à®œÉ). Then, by dropping the first
parenthesis in each expression, the resulting expressions are equal, that is,
Œ± ‚àßŒ≤) = Œ≥ ‚à®œÉ).
(2.2)
Since Œ± and Œ≥ are wffs, Theorem 2.1.8 implies that Œ± and Œ≥ cannot be proper initial
segments of the other. Thus, (2.2) implies that ‚àßŒ≤) = ‚à®œÉ). So ‚àß= ‚à®, which is a

2.2 Truth assignments
‡±™
33
contradiction. So ‚Ñ∞‚àßand ‚Ñ∞‚à®have disjoint ranges. Similar reasoning applies in the
other cases.
(c) Finally, we must show that each operation in ‚Ñ±is one-to-one. So let Œ±, Œ≤, Œ≥, and œÉ be
wffs. Suppose that (Œ± ‚àßŒ≤) = (Œ≥ ‚àßœÉ). Reasoning as in part (b), we see that Œ± = Œ≥ and
thus, Œ≤ = œÉ. Thus, ‚Ñ∞‚àßis one-to-one on the wffs. Similar reasoning also shows that
the other operations are one-to-one.
The unique readability theorem will allow us to positively address the questions
posed at the beginning of this section (see Theorem 2.2.4 below).
Definition 2.2.2. Let ùíÆbe a set of sentence symbols. A function v: ùíÆ‚Üí{F, T} is called a
truth assignment for ùíÆ.
Example 2.2.3. Consider the set ùíÆ= {A3, A6, A8} of sentence symbols. Then the function
v: ùíÆ‚Üí{F, T} defined by
v(A3) = T,
v(A6) = F,
v(A8) = F
is a truth assignment for ùíÆ.
Let ùíÆbe a set of sentence symbols and let v: ùíÆ‚Üí{F, T} be a truth assignment
for ùíÆ. Let ‚Ñ±= {‚Ñ∞‚àß, ‚Ñ∞‚à®, ‚Ñ∞¬¨, ‚Ñ∞‚Üí, ‚Ñ∞‚Üî}. Theorem 2.2.1 implies that the set ùíÆof all wffs gen-
erated by ùíÆfrom the functions in ‚Ñ±is freely generated. For each function in ‚Ñ±we also
have the corresponding truth functions F‚àß, F‚à®, F¬¨, F‚Üí, F‚Üîintroduced in Section 1.2.2
(see (1.2)‚Äì(1.6)). Theorem 1.1.27 now implies the following result.
Theorem 2.2.4. Let ùíÆbe a set of sentence symbols and let v: ùíÆ‚Üí{F, T} be a truth assign-
ment for ùíÆ. Then there is a unique function v: ùíÆ‚Üí{F, T} satisfying the following:
(i)
For every A ‚ààùíÆ, v(A) = v(A).
(ii) For every Œ±, Œ≤ ‚ààùíÆ, we have:
(1) v((¬¨Œ±)) = {T,
if v(Œ±) = F,
F,
if v(Œ±) = T,
(2) v((Œ± ‚àßŒ≤)) = {T,
if v(Œ±) = T and v(Œ≤) = T,
F,
otherwise,
(3) v((Œ± ‚à®Œ≤)) = {T,
if v(Œ±) = T or v(Œ≤) = T (or both),
F,
otherwise,
(4) v((Œ± ‚ÜíŒ≤)) = {F,
if v(Œ±) = T and v(Œ≤) = F,
T,
otherwise,
(5) v((Œ± ‚ÜîŒ≤)) = {T,
if v(Œ±) = v(Œ≤),
F,
otherwise.
Conditions (1)‚Äì(5) of the above theorem are given in tabular form below:

34
‡±™
2 Propositional logic
Œ±
Œ≤
(¬¨Œ±)
(Œ± ‚àßŒ≤)
(Œ± ‚à®Œ≤)
(Œ± ‚ÜíŒ≤)
(Œ± ‚ÜîŒ≤)
T
T
F
T
T
T
T
T
F
F
F
T
F
F
F
T
T
F
T
T
F
F
F
T
F
F
T
T
Remark 2.2.5 (On Theorem 2.2.4). Let ùíÆbe a set of sentence symbols and v: ùíÆ‚Üí{F, T}
be a truth assignment for ùíÆ. Let v: ùíÆ‚Üí{F, T} be as in Theorem 2.2.4. For all Œ±, Œ≤ ‚ààùíÆ(iff
means ‚Äúif and only if‚Äù),
(1) v((¬¨Œ±)) = T iff v(Œ±) = F,
(2) v((Œ± ‚àßŒ≤)) = T iff v(Œ±) = T and v(Œ≤) = T,
(3) v((Œ± ‚à®Œ≤)) = T iff v(Œ±) = T or v(Œ≤) = T,
(4) v((Œ± ‚ÜíŒ≤)) = T iff if v(Œ±) = T, then v(Œ≤) = T,
(5) v((Œ± ‚ÜîŒ≤)) = T iff v(Œ±) = v(Œ≤).
Example 2.2.6. Consider the set ùíÆ= {A3, A6, A8} of three sentence symbols and let
v: ùíÆ‚Üí{F, T} be defined by
v(A3) = T,
v(A6) = F,
v(A8) = F.
Let Œ±, Œ≤, and Œ≥ be defined by
Œ± = (A3 ‚Üí(¬¨A6)),
Œ≤ = (A3 ‚Üí(A6 ‚à®A8)),
Œ≥ = ((A3 ‚Üí(¬¨A6)) ‚Üî(A3 ‚Üí(A6 ‚à®A8))).
So Œ±, Œ≤, Œ≥ ‚ààùíÆ. What is v(Œ±), v(Œ≤), v(Œ≥)?
Definition 2.2.7. Let œÜ be a wff. Let v be a truth assignment defined on the sentence
symbols appearing in œÜ. Then v satisfies œÜ if and only if v(œÜ) = T.
Example 2.2.8. Let ùíÆ= {A3, A6, A8}, let v: ùíÆ‚Üí{F, T}, and let Œ±, Œ≤, Œ≥ all be as in the above
Example 2.2.6. Does v satisfy Œ±? Answer the same question for Œ≤ and Œ≥.
Definition 2.2.9. Let Œ£ be a set of wffs and let v be a truth assignment defined on the
sentence symbols appearing in any wff from Œ£. Then v satisfies Œ£ if and only if v(œÜ) = T
for every œÜ ‚ààŒ£. We shall say that Œ£ is satisfiable if there is a truth assignment that
satisfies Œ£.
Given that Œ£ is a set of wffs and œÑ is a wff, our next definition will address the fol-
lowing question: When can we view œÑ as a conclusion that follows from Œ£, where Œ£ is
regarded as a set of hypotheses?

2.2 Truth assignments
‡±™
35
Definition 2.2.10. Let Œ£ be a set of wffs and let œÑ be a wff. Then Œ£ tautologically implies œÑ
(written Œ£ Û≥ÄÄÛ≥®êœÑ) if and only if for every truth assignment v defined on the sentence sym-
bols that appear in wffs in Œ£ and in œÑ, if v satisfies Œ£, then v satisfies œÑ.
Exercise 9 on page 15 implies the following theorem.
Theorem 2.2.11. Let v1: ùíÆ‚Üí{F, T} and v2: ùíØ‚Üí{F, T} be two truth assignments, where
ùíÆand ùíØare sets of sentence symbols such that ùíÆ‚äÜùíØ. If v1(Ai) = v2(Ai) for all Ai ‚ààùíÆ,
then v1(Œ±) = v2(Œ±) for all Œ± ‚ààùíÆ.
Corollary 2.2.12. Let Œ£ be a set of wffs and let œÑ be a wff. Let
ùíÆ= {Ai : Ai appears in a wff in Œ£ or in œÑ}
and let ùíØbe a set of sentence symbols such that ùíÆ‚äÜùíØ. Then Œ£ Û≥ÄÄÛ≥®êœÑ if and only if every
truth assignment for ùíØthat satisfies every member in Œ£ also satisfies œÑ.
Definition 2.2.10 can be used to identify valid forms of reasoning, or inference rules.
For example, let Œ£ = {(Œ± ‚ÜíŒ≤), Œ±} and let v be a truth assignment that satisfies Œ£. Thus,
v((Œ± ‚ÜíŒ≤)) = T and v(Œ±) = T. So, by Remark 2.2.5(4), we conclude that v(Œ≤) = T. There-
fore, Œ£ Û≥ÄÄÛ≥®êŒ≤. This particular tautological implication justifies the formal inference rule
called modus ponens, represented by the diagram
Œ± ‚ÜíŒ≤
Œ±
‚à¥Œ≤
,
which asserts that if (Œ± ‚ÜíŒ≤) and Œ± are true, we therefore can conclude that Œ≤ is true. In
other words, modus ponens offers an argument that is truth preserving.
Remark 2.2.13. A few special cases concerning Definitions 2.2.7‚Äì2.2.10 deserve some
comments.
(a) If Œ£ is the empty set ‚åÄ, then every truth assignment satisfies Œ£.
(b) It follows from (a) that ‚åÄÛ≥ÄÄÛ≥®êœÑ if and only if every truth assignment satisfies œÑ. In this
case, we say that œÑ is a tautology (written Û≥ÄÄÛ≥®êœÑ). In other words, œÑ is a tautology if and
only if for every truth assignment v containing the sentence symbols in œÑ, we have
v(œÑ) = T.
(c) If there is no truth assignment that satisfies Œ£, then for any œÑ it is vacuously true that
Œ£ Û≥ÄÄÛ≥®êœÑ. This can occur if Œ£ contains a contradiction; for example, if (Ai ‚àß(¬¨Ai)) ‚ààŒ£.
(d) If Œ£ is a singleton {œÉ}, then we write œÉ Û≥ÄÄÛ≥®êœÑ in place of {œÉ} Û≥ÄÄÛ≥®êœÑ.
Problem 2.2.14. Let Œ± and Œ≤ be wffs. Show that (Œ± ‚Üí(Œ≤ ‚ÜíŒ±)) is a tautology.
Solution. We apply Remark 2.2.13(b). Let v be a truth assignment that contains the sen-
tence symbols occurring in Œ± and Œ≤. We must show that v((Œ± ‚Üí(Œ≤ ‚ÜíŒ±))) = T. Suppose,

36
‡±™
2 Propositional logic
for a contradiction, that v((Œ± ‚Üí(Œ≤ ‚ÜíŒ±))) = F. By Theorem 2.2.4(4), (Û≥µ≥) v(Œ±) = T and
v((Œ≤ ‚ÜíŒ±)) = F. Since v((Œ≤ ‚ÜíŒ±)) = F, we conclude that v(Œ±) = F, which contradicts (Û≥µ≥).
So v((Œ± ‚Üí(Œ≤ ‚ÜíŒ±))) = T. Thus, (Œ± ‚Üí(Œ≤ ‚ÜíŒ±)) is a tautology.
Definition 2.2.15. Let œÉ and œÑ be wffs. Then œÉ and œÑ are said to be tautologically equiv-
alent (written œÉ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œÑ) if œÉ Û≥ÄÄÛ≥®êœÑ and œÑ Û≥ÄÄÛ≥®êœÉ.
Remark 2.2.16 (On Definition 2.2.15). Let œÉ and œÑ be wffs. Then one can show that œÉ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œÑ
if and only if for every truth assignment v containing the sentence symbols in œÉ and œÑ,
we have v(œÉ) = v(œÑ).
2.2.1 Some tautologies
For the remainder of this chapter, we will let A, B, C, ‚Ä¶, Z denote arbitrary sentence
symbols. We note the following.
1.
Two simple tautologies:
(A ‚ÜíA)
(A ‚à®(¬¨A))
2.
De Morgan‚Äôs laws:
((¬¨(A ‚à®B)) ‚Üî((¬¨A) ‚àß(¬¨B)))
((¬¨(A ‚àßB)) ‚Üî((¬¨A) ‚à®(¬¨B)))
3.
Commutative laws:
((A ‚àßB) ‚Üî(B ‚àßA))
((A ‚à®B) ‚Üî(B ‚à®A))
4.
Associative laws:
((A ‚à®(B ‚à®C)) ‚Üî((A ‚à®B) ‚à®C))
((A ‚àß(B ‚àßC)) ‚Üî((A ‚àßB) ‚àßC))
5.
Distribution laws:
((A ‚àß(B ‚à®C)) ‚Üî((A ‚àßB) ‚à®(A ‚àßC)))
((A ‚à®(B ‚àßC)) ‚Üî((A ‚à®B) ‚àß(A ‚à®C)))
6.
Conditional laws:
((A ‚ÜíB) ‚Üî((¬¨A) ‚à®B))
((A ‚ÜíB) ‚Üî(¬¨(A ‚àß(¬¨B))))
(((¬¨A) ‚ÜíB) ‚Üî(A ‚à®B))
((¬¨(A ‚Üí(¬¨B))) ‚Üî(A ‚àßB))
7.
Double negation law: ((¬¨(¬¨A)) ‚ÜîA)
8.
Contrapositive law: ((A ‚ÜíB) ‚Üî((¬¨B) ‚Üí(¬¨A)))
9.
Biconditional law: ((A ‚ÜîB) ‚Üî((A ‚ÜíB) ‚àß(B ‚ÜíA)))
10. Exportation law: (((A ‚àßB) ‚ÜíC) ‚Üî(A ‚Üí(B ‚ÜíC)))

2.2 Truth assignments
‡±™
37
2.2.2 Omitting parentheses
We now describe some conventions that will allow us to reduce (without any ambiguity)
the number of parentheses used in our wffs. These conventions will give us a ‚Äúshortcut‚Äù
in how we can correctly express a propositional statement.
1.
The outermost parentheses need not be explicitly mentioned. For example, we can
write A ‚àßB to denote (A ‚àßB).
2.
The negation symbol shall apply to as little as possible. For example, we can write
¬¨A ‚àßB to denote (¬¨A) ‚àßB, that is, ((¬¨A) ‚àßB).
3.
The conjunction and disjunction symbols shall apply to as little as possible. For ex-
ample, we will write
A ‚àßB ‚Üí¬¨C ‚à®D to denote ((A ‚àßB) ‚Üí((¬¨C) ‚à®D)),
using conventions 1 and 2.
4.
When one logical connective is used repeatedly, the parentheses are assumed to be
grouped to the right. For example, we shall write
Œ± ‚àßŒ≤ ‚àßŒ≥ to denote Œ± ‚àß(Œ≤ ‚àßŒ≥) and
Œ± ‚ÜíŒ≤ ‚ÜíŒ≥ to denote Œ± ‚Üí(Œ≤ ‚ÜíŒ≥).
This convention allows us to observe that for n ‚â•2,
Œ±1 ‚àßŒ±2 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ±n ‚àßŒ±n+1 denotes Œ±1 ‚àßŒ±2 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àß(Œ±n ‚àßŒ±n+1),
(2.3)
Œ±1 ‚ÜíŒ±2 ‚Üí‚ãÖ‚ãÖ‚ãÖ‚ÜíŒ±n ‚ÜíŒ±n+1 denotes Œ±1 ‚ÜíŒ±2 ‚Üí‚ãÖ‚ãÖ‚ãÖ‚Üí(Œ±n ‚ÜíŒ±n+1).
(2.4)
In some of the following exercises, we will omit parentheses following these conven-
tions.
Exercises 2.2.
1. Using Theorem 2.2.11, prove Corollary 2.2.12.
*2. Let Œ£ be a set of wffs and let œÑ be a wff. Let œÑ be either in Œ£ or a tautology. Show that
Œ£ Û≥ÄÄÛ≥®êœÑ.
3. Determine whether or not ((A ‚ÜíB) ‚à®(B ‚ÜíA)) is a tautology.
*4. Let Œ± and Œ≤ be wffs. Show that Œ± ‚ÜíŒ≤ ‚Üí(Œ± ‚àßŒ≤) is a tautology.
*5. Let Œ± and Œ≤ be wffs. Show that (¬¨Œ± ‚ÜíŒ≤) ‚Üí(¬¨Œ± ‚Üí¬¨Œ≤) ‚ÜíŒ± is a tautology.
*6. Let Œ£ be a set of wffs and let Œ∏, œà be wffs. Suppose that Œ£ Û≥ÄÄÛ≥®êŒ∏ and Œ£ Û≥ÄÄÛ≥®ê(Œ∏ ‚Üíœà). Show
that Œ£ Û≥ÄÄÛ≥®êœà.
7. Let Œ£1 and Œ£2 be sets of wffs and let Œ± and Œ≤ be wffs. Suppose that Œ£1 Û≥ÄÄÛ≥®êŒ± and Œ£2 Û≥ÄÄÛ≥®êŒ≤.
Show that Œ£1 ‚à™Œ£2 Û≥ÄÄÛ≥®ê(Œ± ‚àßŒ≤).
8. Let Œ£ = {Œ±1, Œ±2, . . . , Œ±n} be a finite set of wffs and let œÑ be a wff. Prove that if Œ£ Û≥ÄÄÛ≥®êœÑ,
then (Œ±1 ‚àßŒ±2 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ±n) ‚ÜíœÑ is a tautology.

38
‡±™
2 Propositional logic
*9. Let Œ£ be any set of wffs and let Œ± and Œ≤ be wffs. Show that the following hold:
(a) Œ£ ‚à™{Œ±} Û≥ÄÄÛ≥®êŒ≤ iff Œ£ Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤),
(b) Œ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Œ≤ iff Û≥ÄÄÛ≥®ê(Œ± ‚ÜîŒ≤).
*10. Suppose that (Œ± ‚ÜîŒ≤) is a tautology. Show that (Œ± ‚ÜíŒ≤) is a tautology.
11. Suppose that either Œ£ Û≥ÄÄÛ≥®êŒ± or Œ£ Û≥ÄÄÛ≥®êŒ≤. Prove that Œ£ Û≥ÄÄÛ≥®ê(Œ± ‚à®Œ≤).
12. Find Œ£, Œ±, Œ≤ such that Œ£ Û≥ÄÄÛ≥®ê(Œ± ‚à®Œ≤), and yet Œ£
Ã∏Û≥ÄÄÛ≥®êŒ± and Œ£
Ã∏Û≥ÄÄÛ≥®êŒ≤.
13. Let Œ±, Œ≤ be wffs. Suppose that Œ± and (Œ± ‚ÜîŒ≤) are both tautologies. Show that Œ≤ is
also a tautology.
*14. Let Œ±, Œ±‚Ä≤, Œ≤, and Œ≤‚Ä≤ be wffs. Suppose that Œ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Œ±‚Ä≤ and Œ≤ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Œ≤‚Ä≤. Show that
(a) (¬¨Œ±) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
(¬¨Œ±‚Ä≤),
(b) (Œ± ‚àßŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
(Œ±‚Ä≤ ‚àßŒ≤‚Ä≤),
(c) (Œ± ‚à®Œ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
¬¨((¬¨Œ±‚Ä≤) ‚àß(¬¨Œ≤‚Ä≤)),
(d) (Œ± ‚àßŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
¬¨(Œ±‚Ä≤ ‚Üí(¬¨Œ≤‚Ä≤)).
15. The sets of wffs below are either satisfiable or not. Determine which are satisfiable
by finding a truth assignment that satisfies the given set Œ£. If Œ£ is not satisfiable,
explain (that is, give an argument) why this is the case.
(a) Œ£ = {A, (A ‚ÜíB), ¬¨B},
(b) Œ£ = {(A ‚ÜíB), ¬¨A, ¬¨B},
(c) Œ£ = {(A ‚ÜíB), ¬¨A, B},
(d) Œ£ = {(A ‚àßB), ¬¨A, ¬¨B},
(e) Œ£ = {(A ‚àß¬¨A), ¬¨C, B},
(f) Œ£ = {¬¨(A ‚ÜîB), A, ¬¨B},
(g) Œ£ = {(A ‚ÜîB), ¬¨A, ¬¨B},
(h) Œ£ = {A ‚àßB, ¬¨(C ‚àßD), D ‚Üí¬¨A, C ‚Üí¬¨B},
(i)
Œ£ = {A ‚àßB, ¬¨C ‚àßD, D ‚Üí¬¨A, C ‚Üí¬¨B}.
*16. Let Œ£ be a set of wffs and let œÑ be a wff. Prove that
Œ£
Ã∏Û≥ÄÄÛ≥®êœÑ
if and only if
Œ£ ‚à™{¬¨œÑ} is satisfiable.
17. Let Œ£ be a set of wffs and let œÜ, œà be wffs. Let v be a truth assignment that satisfies
Œ£. Prove the following statements:
(a) If (œÜ ‚àßœà) ‚ààŒ£, then v(œÜ) = T.
(b) If (œÜ ‚Üíœà) ‚ààŒ£ and ¬¨œà ‚ààŒ£, then v(¬¨œÜ) = T.
(c) If (œà ‚ÜíœÜ) ‚ààŒ£ and ¬¨œÜ ‚ààŒ£, then v(œà) = F.
(d) If ¬¨(œà ‚ÜíœÜ) ‚ààŒ£, then v(œà) = T.
18. Determine whether or not the following statements are true. Explain (that is, give
an argument) why each statement is true or explain why it is false.
(a) Let Œ£ = {A, (A ‚ÜíB)}. Then Œ£ Û≥ÄÄÛ≥®êB.
(b) Let Œ£ = {(A ‚à®B), ¬¨B}. Then Œ£ Û≥ÄÄÛ≥®êA.
(c) Let Œ£ = {C ‚Üí(A ‚ÜíB), A, C}. Then Œ£ Û≥ÄÄÛ≥®ê(C ‚ÜíB).
(d) Let Œ£ = {C ‚Üí(¬¨A ‚ÜíB), C}. Then Œ£ Û≥ÄÄÛ≥®ê(¬¨B ‚ÜíA).
(e) Let Œ£ = {(A ‚ÜîB), ¬¨C}. Then Œ£ Û≥ÄÄÛ≥®ê(A ‚ÜíB).

2.3 Completeness of the logical connectives
‡±™
39
(f) Let Œ£ = {(A ‚ÜîB), ¬¨C}. Then Œ£ Û≥ÄÄÛ≥®êA.
(g) Let Œ£ = {(A ‚ÜîB), ¬¨C, ¬¨B}. Then Œ£ Û≥ÄÄÛ≥®ê¬¨A.
(h) Let Œ£ = {(A ‚à®B), ¬¨C}. Then Œ£ Û≥ÄÄÛ≥®êA.
(i)
Let Œ£ = {(A ‚àß¬¨A), ¬¨C, B}. Then Œ£ Û≥ÄÄÛ≥®êD.
19. Let ùíÆbe the set of all sentence symbols. For a set Œì of wffs, define the truth assign-
ment vŒì: ùíÆ‚Üí{F, T} by
vŒì(Ai) = {T,
if Ai ‚ààŒì,
F,
if Ai ‚àâŒì.
Justify your answers to the following questions:
(a) Let Œì = {(A ‚àßB), A, ¬¨B}. Does vŒì satisfy Œì?
(b) Let Œì = {(A ‚àß¬¨A), C, B}. Does vŒì satisfy Œì?
(c) Let Œì = {¬¨(A ‚ÜîB), A, ¬¨B}. Does vŒì satisfy Œì?
(d) Let Œì = {(A ‚ÜîB), ¬¨A, ¬¨B}. Does vŒì satisfy Œì?
(e) Let Œì = {A ‚àßB, ¬¨(C ‚àßD), D ‚Üí¬¨A, C ‚Üí¬¨B, A, B}. Does vŒì satisfy Œì?
(f) Let Œì = {D, ¬¨C ‚àßD, D ‚Üí¬¨A, C ‚Üí¬¨B}. Does vŒì satisfy Œì?
20. (Substitution) Let Œ±1, Œ±2, ‚Ä¶, Œ±n, . . . be an infinite sequence of wffs. For each wff œÜ,
let œÜ‚àóbe the result of replacing each occurrence of An in œÜ with Œ±n.
(a) Let v be a truth assignment for the set ùíÆof all the sentence symbols. Define
u: ùíÆ‚Üí{F, T} by u(An) = v(Œ±n). Prove that u(œÜ) = v(œÜ‚àó) for all wffs œÜ.
(b) Prove that if œÜ is a tautology, then so is œÜ‚àó.
(c) Prove that if œà Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œÜ, then œà‚àóÛ≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œÜ‚àó.
Exercise Notes: For Exercise 14, apply Remark 2.2.16. For Exercise 19, note that if Œì =
{(A ‚àßB), A, ¬¨B}, then A ‚ààŒì and B ‚àâŒì. For Exercise 20(a), let P(œÜ) be the statement
u(œÜ) = v(œÜ‚àó). Now prove ‚Äúfor all wffs œÜ, P(œÜ)‚Äù by induction on œÜ. (Question: Is (œÜ‚àßœà)‚àó=
(œÜ‚àó‚àßœà‚àó)?)
2.3 Completeness of the logical connectives
In logic, a truth function is one that accepts truth values as input and produces a unique
truth value as output. Let V = {T, F}. Thus, an n-place truth function has the form
H: V n ‚ÜíV for some n ‚â•1. Truth functions are also called Boolean functions. Such func-
tions are applied in a variety of different fields, namely, electrical engineering, computer
science, game theory, and combinatorics.
Let Œ± be a wff whose sentence symbols are among A1, A2, . . . , An. We can now define
an n-place truth function HŒ±: V n ‚ÜíV by
HŒ±(x1, x2, . . . , xn) = v(Œ±), where v(A1) = x1, v(A2) = x2, ‚Ä¶, v(An) = xn.
(2.5)

40
‡±™
2 Propositional logic
So, given any wff, we can use it to define a truth function. For example, let Œ± be the wff
(A1 ‚à®¬¨A2). Then we see that HŒ±: V 2 ‚ÜíV satisfies
HŒ±(T, T) = T,
HŒ±(T, F) = T,
HŒ±(F, T) = F,
HŒ±(F, F) = T,
which is essentially the truth table for Œ±. This invites an interesting question: Given any
truth function G, is there a wff œà such that G = Hœà? Before addressing this question, let
us look at some examples.
Example 2.3.1. Suppose that G: V 3 ‚ÜíV always has output F. Let Œ± be the wff (A1 ‚àß¬¨A1).
Since Œ± is always false and its sentence symbols are among A1, A2, A3, by applying (2.5)
we see that HŒ±(x1, x2, x3) = v(Œ±) = F for all x1, x2, x3 ‚ààV (see Theorem 2.2.11). So G = HŒ±.
Example 2.3.2. Let G: V 3 ‚ÜíV be such that
G(x1, x2, x3) = {T,
if x1 = T, x2 = F, x3 = T,
F,
otherwise.
Thus, G(T, F, T) = T and this is the only input that produces the output value T. Let Œ≥
be the wff (A1 ‚àß¬¨A2 ‚àßA3) which corresponds to T, F, T. Note that v(Œ≥) = T if and only
if v(A1) = T, v(A2) = F, v(A3) = T. Thus, by applying (2.5), we see that G(x1, x2, x3) =
HŒ≥(x1, x2, x3) = v(Œ≥) for all x1, x2, x3 ‚ààV. So G = HŒ≥.
In the above two examples, we were given relatively simple truth functions G and
we were able to find a wff œà such that G = Hœà. Our next example gives a slightly more
complicated truth function. These examples will provide a guide that will allow us to
prove that for any truth function G there is always a wff œà such that G = Hœà.
Example 2.3.3. Suppose that truth function G: V 3 ‚ÜíV is such that
G(T, T, T) = T,
G(T, T, F) = F,
G(T, F, T) = F,
G(T, F, F) = T,
(2.6)
G(F, T, T) = F,
G(F, T, F) = T,
G(F, F, T) = T,
G(F, F, F) = F.

2.3 Completeness of the logical connectives
‡±™
41
Let us focus on the cases in (2.6) that produce the value T. Also, for each such case let us
identify a corresponding wff Œ≥i as was done in Example 2.3.2, namely,
G(T, T, T) = T
Œ≥1 = (A1 ‚àßA2 ‚àßA3),
G(T, F, F) = T
Œ≥2 = (A1 ‚àß¬¨A2 ‚àß¬¨A3),
G(F, T, F) = T
Œ≥3 = (¬¨A1 ‚àßA2 ‚àß¬¨A3),
G(F, F, T) = T
Œ≥4 = (¬¨A1 ‚àß¬¨A2 ‚àßA3).
(2.7)
Now let Œ± = Œ≥1 ‚à®Œ≥2 ‚à®Œ≥3 ‚à®Œ≥4, that is, let Œ± be the following wff:
(A1 ‚àßA2 ‚àßA3) ‚à®(A1 ‚àß¬¨A2 ‚àß¬¨A3) ‚à®(¬¨A1 ‚àßA2 ‚àß¬¨A3) ‚à®(¬¨A1 ‚àß¬¨A2 ‚àßA3).
Note that v(Œ±) = T if and only if G(v(A1), v(A2), v(A3)) = T. By applying (2.5), we see that
G(x1, x2, x3) = HŒ±(x1, x2, x3) = v(Œ±) for all x1, x2, x3 ‚ààV. So G = HŒ±.
The above examples offer a foundation for the proof of the following theorem.
Theorem 2.3.4. Let V = {T, F} and let G: V n ‚ÜíV be any truth function. Then there is a
wff Œ± such that G = HŒ±, where HŒ± is defined by (2.5).
Proof. If G: V n ‚ÜíV is always false, then let Œ± be the wff (A1 ‚àß¬¨A1). Thus, G = HŒ± (see
Example 2.3.1). Suppose now that G has some output values being T, say, k many such
cases. Let us list all the cases that yield the value T. For each such case let us also identify
a corresponding wff Œ≥i as was done in Example 2.3.3 (see (2.7)), specifically,
G(x11, x12, . . . , x1n) = T,
Œ≥1 = (Œ≤11 ‚àßŒ≤12 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ≤1n),
G(x21, x22, . . . , x2n) = T,
Œ≥2 = (Œ≤21 ‚àßŒ≤22 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ≤2n),
...
...
G(xk1, xk2, . . . , xkn) = T,
Œ≥k = (Œ≤k1 ‚àßŒ≤k2 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ≤kn),
where for 1 ‚â§i ‚â§k and 1 ‚â§j ‚â§n, we have
Œ≤ij = {Aj,
if xij = T,
¬¨Aj,
if xij = F.
Note that v(Œ≥i) = T if and only if v(A1) = xi1, v(A2) = xi2, . . . , v(An) = xin. Let Œ± = Œ≥1 ‚à®Œ≥2 ‚à®
‚ãÖ‚ãÖ‚ãÖ‚à®Œ≥k. So v(Œ±) = T if and only if G(v(A1), v(A2), . . . , v(An)) = T. By applying (2.5), we see
that G(x1, x2, . . . , xn) = HŒ±(x1, x2, . . . , xn) = v(Œ±) for all x1, x2, . . . , xn ‚ààV. So G = HŒ±.
Theorem 2.3.4 shows that every truth function is equal to a function of the form HŒ±
for some wff Œ±. For this reason, the set {‚àß, ‚à®, ¬¨, ‚Üí, ‚Üî} of logical connectives can be said
to be truth functionally complete. In fact, the proof of Theorem 2.3.4 shows that {‚àß, ‚à®, ¬¨}

42
‡±™
2 Propositional logic
is also truth functionally complete. To clarify this assertion, let us say that a wff Œ± is in
disjunctive normal form if
Œ± = Œ≥1 ‚à®Œ≥2 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®Œ≥k,
where each Œ≥i is a conjunction of the form
Œ≥i = (Œ≤i1 ‚àßŒ≤i2 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ≤in)
and each Œ≤ij is a sentence symbol or the negation of a sentence symbol. The proof of
Theorem 2.3.4 shows that every truth function is equal to a function of the form HŒ±,
where Œ± is in disjunctive normal form. Thus, {‚àß, ‚à®, ¬¨} is truth functionally complete as
well. This discussion now allows us to establish the following result.
Theorem 2.3.5. Every wff œÜ is tautologically equivalent to a wff Œ± in disjunctive normal
form.
Proof. Let œÜ be a wff and let HœÜ be the truth function defined by (2.5). The proof of
Theorem 2.3.4 shows that HœÜ = HŒ±, where Œ± is in disjunctive normal form. Exercise 3
below shows that œÜ and Œ± are tautologically equivalent.
Definition 2.3.6. Let ùíûbe a subset of {‚àß, ‚à®, ¬¨, ‚Üí, ‚Üî}. Then ùíûis tautologically complete
if and only if every wff Œ± is tautologically equivalent to a wff Œ±‚Ä≤ that contains only the
connectives in ùíû.
The following result follows from Theorem 2.3.5.
Theorem 2.3.7. The set {‚àß, ‚à®, ¬¨} is tautologically complete.
Theorem 2.3.8. The sets {¬¨, ‚àß} and {¬¨, ‚à®} are both tautologically complete.
Proof. We will only prove that the set {¬¨, ‚àß} is tautologically complete. A similar proof
shows that {¬¨, ‚à®} is tautologically complete. By Theorem 2.3.7 we know that every wff is
tautologically equivalent to a wff which contains only the connectives in {‚àß, ‚à®, ¬¨}. So it is
sufficient to prove by induction that every wff Œ± containing only connectives in {‚àß, ‚à®, ¬¨}
is tautologically equivalent to a wff Œ±‚Ä≤ with connectives only in {¬¨, ‚àß}.
Base step: Let Œ± = Ai. As Œ± has no connectives, Œ±‚Ä≤ = Œ± as required.
Inductive step: Let Œ± and Œ≤ be arbitrary wffs that contain only the connectives in the set
{‚àß, ‚à®, ¬¨}. Assume the induction hypothesis
Œ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Œ±‚Ä≤,
where Œ±‚Ä≤ contains only the connectives in {¬¨, ‚àß},
Œ≤ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Œ≤‚Ä≤,
where Œ≤‚Ä≤ contains only the connectives in {¬¨, ‚àß}.
(IH)
We prove that each of the wffs (¬¨Œ±), (Œ± ‚àßŒ≤), (Œ± ‚à®Œ≤) is tautologically equivalent to a wff
that contains only connectives in {¬¨, ‚àß}.

2.3 Completeness of the logical connectives
‡±™
43
For (¬¨Œ±), from (IH) and Exercise 14(a) on page 38, it follows that (¬¨Œ±) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
(¬¨Œ±‚Ä≤),
where (¬¨Œ±‚Ä≤) has connectives only in {¬¨, ‚àß}.
For (Œ± ‚àßŒ≤), from (IH) and Exercise 14(b) on page 38, we have (Œ± ‚àßŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
(Œ±‚Ä≤ ‚àßŒ≤‚Ä≤),
where (Œ±‚Ä≤ ‚àßŒ≤‚Ä≤) contains only connectives in {¬¨, ‚àß}.
For (Œ± ‚à®Œ≤), from (IH) and Exercise 14(c) on page 38, we have
(Œ± ‚à®Œ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
¬¨((¬¨Œ±‚Ä≤) ‚àß(¬¨Œ≤‚Ä≤)),
where ¬¨((¬¨Œ±‚Ä≤) ‚àß(¬¨Œ≤‚Ä≤)) contains only connectives in {¬¨, ‚àß}.
Remark 2.3.9. Let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚àß, ‚Ñ∞‚à®} and let ùíÆ= {A1, A2, A3, . . . } be the set of all sentence
symbols in the language ‚Ñí. Let ùíÆbe the set generated from ùíÆby the functions in ‚Ñ±.
Theorem 1.1.25 validates the proof by induction given in Theorem 2.3.8.
Exercises 2.3.
1. For each of the following wffs Œ±, using the tautologies in Section 2.2.1, find a wff that
is tautologically equivalent to Œ± which contains connectives only in ùíû:
(a) Œ± = (A ‚ÜíB) ‚Üî(C ‚ÜíA) and ùíû= {‚àß, ‚à®, ¬¨},
(b) Œ± = (A ‚ÜíB) ‚Üî(C ‚ÜíA) and ùíû= {¬¨, ‚àß}.
2. Let V = {T, F} and define the truth function G: V 3 ‚ÜíV by
G(x1, x2, x3) = {T,
if exactly two of x1, x2, x3 are T,
F,
otherwise.
Find a wff Œ± in disjunctive normal form such that G = HŒ±, where HŒ± is defined as
in (2.5).
*3. Let Œ± and Œ≤ be wffs with the same sentence symbols among A1, A2, . . . , An. Let HŒ±
and HŒ≤ be defined as in (2.5). Prove that HŒ± = HŒ≤ if and only if Œ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Œ≤.
4. Using the fact that {¬¨, ‚àß} is tautologically complete, prove (by induction) that {¬¨, ‚à®}
is tautologically complete.
*5. Given that {¬¨, ‚àß} is tautologically complete, prove (by induction) that {¬¨, ‚Üí} is tau-
tologically complete.
6. Let ‚Ñ±= {‚Ñ∞‚àß, ‚Ñ∞‚Üí} and let ùíÆ= {A1, A2, A3, . . . } be the set of all sentence symbols in
the language ‚Ñí. Let ùíÆbe the set generated from ùíÆby the functions in ‚Ñ±. Now let
v: S ‚Üí{F, T} be defined by v(Ai) = T for all i = 1, 2, 3, . . . . Prove by induction on Œ±
that v(Œ±) = T for all Œ± ‚ààùíÆ. Is {‚àß, ‚Üí} tautologically complete?
Exercise Notes: For Exercises 4 and 5, read the first paragraph of the proof of The-
orem 2.3.8. For Exercise 5, see Exercise 14(d) on page 38.

44
‡±™
2 Propositional logic
2.4 Compactness
Let Œ£ be an infinite set of wffs. Suppose that every finite subset of Œ£ is satisfiable. Thus,
every finite subset of Œ£ has a particular truth assignment that satisfies all of the wffs
in this finite subset. Is there a truth assignment that will thus satisfy all of the infinite
number of wffs in Œ£? The compactness theorem addresses this interesting question. In
this section, we shall give a proof of the compactness theorem, for propositional logic.
We begin by formally introducing the following pertinent definition.
Definition 2.4.1. A set of wffs Œ£ is finitely satisfiable if and only if every finite subset of
Œ£ is satisfiable.
The proof of the following theorem shows that a sophisticated mathematical argu-
ment can establish a powerful result about propositional logic. A similar argument will
be applied in Section 4.2.
Theorem 2.4.2 (Compactness theorem). Let Œ£ be a set of wffs. If Œ£ is finitely satisfiable,
then Œ£ is satisfiable.
Proof. The basic idea behind the proof is as follows: Given that Œ£ is finitely satisfiable,
we first construct a set of wffs Œî such that:
(1) Œ£ ‚äÜŒî;
(2) Œî is finitely satisfiable;
(3) for every wff Œ±, either Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî.
We shall then use Œî to define a truth assignment that satisfies Œ£.
Note that Theorem 1.1.30 (on page 12) implies that the set of all wffs is a countable
set, because the set of all wffs is a subset of the set of all finite sequences of symbols in
the countable language ‚Ñí. Thus, let
Œ±1, Œ±2, Œ±3, . . . , Œ±n, . . .
(2.8)
be a fixed enumeration (see Corollary 1.1.33) of all the wffs in the language ‚Ñí. Define by
recursion on ‚Ñï(see Theorem 1.1.23) the following sets:
(i)
Œî0 = Œ£,
(ii) Œîn+1 = {Œîn ‚à™{Œ±n+1},
if Œîn ‚à™{Œ±n+1} is finitely satisfiable,
Œîn ‚à™{¬¨Œ±n+1},
otherwise.
From the above recursive definition, we see that Œîn ‚äÜŒîn+1 for all n ‚àà‚Ñï. Thus,
Œ£ = Œî0 ‚äÜŒî1 ‚äÜŒî2 ‚äÜ‚ãÖ‚ãÖ‚ãÖ.
We shall now establish four claims.
Claim 1. For all n ‚àà‚Ñï, Œîn is finitely satisfiable.

2.4 Compactness
‡±™
45
Proof of Claim 1. We shall use induction on n.
Base step: Let n = 0. Then Œî0 = Œ£, which is finitely satisfiable by assumption.
Inductive step: Let n ‚àà‚Ñïbe arbitrary. Assume the induction hypothesis
Œîn is finitely satisfiable.
(IH)
We prove that Œîn+1 is finitely satisfiable. Since Œîn is finitely satisfiable, Exercise 1 below
implies that Œîn+1 is finitely satisfiable.
(Claim 1)
Let Œî = ‚ãÉn‚àà‚ÑïŒîn. Clearly, Œ£ ‚äÜŒî as Œî0 = Œ£. Recall that Œîn ‚äÜŒîn+1 for all n ‚àà‚Ñï.
Claim 2. The set Œî is finitely satisfiable.
Proof of Claim 2. We show that each finite subset of Œî is satisfiable. Let Œ† be a finite
subset of Œî. Since Œ† ‚äÜŒî = ‚ãÉn‚àà‚ÑïŒîn and Œ† is finite, it follows that Œ† ‚äÜŒîn for some n. By
Claim 1, Œîn is finitely satisfiable. Thus, Œ† is satisfiable.
(Claim 2)
Claim 3. For every wff Œ±, either Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî, but not both.
Proof of Claim 3. Let Œ± be any wff. Since (2.8) enumerates all of the wffs, there is an n ‚àà‚Ñï
such that Œ± = Œ±n. Either Œ±n ‚ààŒîn or (¬¨Œ±n) ‚ààŒîn by (ii) of the above construction. Since
Œîn ‚äÜŒî, it follows that Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî. If both Œ± ‚ààŒî and (¬¨Œ±) ‚ààŒî, then {Œ±, (¬¨Œ±)} would
be a finite subset of Œî. Since Œî is finitely satisfiable, we must conclude that {Œ±, (¬¨Œ±)} is
satisfiable. This is a contradiction, as the set {Œ±, (¬¨Œ±)} is not satisfiable. Therefore, we
cannot have both Œ± ‚ààŒî and (¬¨Œ±) ‚ààŒî.
(Claim 3)
We now continue with the proof of the theorem. Note that:
(1) Œ£ ‚äÜŒî;
(2) Œî is finitely satisfiable by Claim 2;
(3) for every wff Œ±, either Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî, but not both, by Claim 3.
We will now use Œî to define a truth assignment. Let ùíÆbe the set of all the sentence
symbols and define v: ùíÆ‚Üí{F, T} by
v(Ai) = {T,
if Ai ‚ààŒî,
F,
if Ai ‚àâŒî.
(2.9)
Let v: ùíÆ‚Üí{F, T} be the extension of v as given by Theorem 2.2.4.
Claim 4. For every wff œÜ, we have
v(œÜ) = T
if and only if
œÜ ‚ààŒî.
(2.10)
Proof of Claim 4. We shall prove that (2.10) holds by induction on Œ±.

46
‡±™
2 Propositional logic
Base step: Let Œ± = Ai be any sentence symbol. Since v(Ai) = v(Ai), (2.9) implies that
v(Ai) = T iff Ai ‚ààŒî.
Inductive step: Let Œ± and Œ≤ be arbitrary wffs. Assume the induction hypothesis
v(Œ±) = T
iff
Œ± ‚ààŒî,
v(Œ≤) = T
iff
Œ≤ ‚ààŒî.
(IH)
We must prove that the same holds for each of the following wffs:
(¬¨Œ±), (Œ± ‚àßŒ≤), (Œ± ‚à®Œ≤), (Œ± ‚ÜíŒ≤), (Œ± ‚ÜîŒ≤).
Case (¬¨Œ±): We prove that v((¬¨Œ±)) = T iff (¬¨Œ±) ‚ààŒî.
(‚áí). Assume that v((¬¨Œ±)) = T. Since v((¬¨Œ±)) = T, it follows that v(Œ±) = F. So, Œ± ‚àâŒî
by (IH). Therefore, by (3), (¬¨Œ±) ‚ààŒî.
(‚áê). Assume that (¬¨Œ±) ‚ààŒî. Since (¬¨Œ±) ‚ààŒî, it follows that Œ± ‚àâŒî; because if Œ± ‚ààŒî, then
by (2) {(¬¨Œ±), Œ±} is a satisfiable subset of Œî, which is false. Thus, Œ± ‚àâŒî and the induction
hypothesis (IH) implies that v(Œ±) = F, and therefore v((¬¨Œ±)) = T.
Case (Œ± ‚àßŒ≤): We must prove that v((Œ± ‚àßŒ≤)) = T iff (Œ± ‚àßŒ≤) ‚ààŒî.
(‚áí). Assume that v((Œ±‚àßŒ≤)) = T. We need to show that (Œ±‚àßŒ≤) ‚ààŒî. Since v((Œ±‚àßŒ≤)) = T,
it follows that v(Œ±) = T and v(Œ≤) = T. So by (IH), Œ± ‚ààŒî and Œ≤ ‚ààŒî. Suppose, for a
contradiction, that (Œ± ‚àßŒ≤) ‚àâŒî. Therefore, by (3), we conclude that (¬¨(Œ± ‚àßŒ≤)) ‚ààŒî. So
{Œ±, Œ≤, ¬¨(Œ± ‚àßŒ≤)} is a finite subset of Œî and by (2) it is satisfiable, which is false. Therefore,
(Œ± ‚àßŒ≤) ‚ààŒî.
(‚áê). Assume that (Œ± ‚àßŒ≤) ‚ààŒî. We will show that v((Œ± ‚àßŒ≤)) = T. As (Œ± ‚àßŒ≤) ‚ààŒî, it
must be the case that Œ± ‚ààŒî and Œ≤ ‚ààŒî. To see this, suppose that either Œ± ‚àâŒî or Œ≤ ‚àâŒî. If
Œ± ‚àâŒî, then by (3), we have (¬¨Œ±) ‚ààŒî. So {(Œ± ‚àßŒ≤), (¬¨Œ±)} is a finite subset of Œî and by (2) it is
satisfiable, which is false. A similar argument shows that Œ≤ ‚ààŒî. Hence, Œ± ‚ààŒî and Œ≤ ‚ààŒî
and by (IH), we have v(Œ±) = T and v(Œ≤) = T. Therefore, v((Œ± ‚àßŒ≤)) = T by Remark 2.2.4(2).
Cases (Œ± ‚à®Œ≤), (Œ± ‚ÜíŒ≤), and (Œ± ‚ÜîŒ≤): See Exercise 4 below.
(Claim 4)
Claim 4 implies that v satisfies Œî. Since Œ£ ‚äÜŒî, it follows that v satisfies Œ£. Therefore,
there is a truth assignment that satisfies Œ£.
(Theorem)
Remark 2.4.3. If we were working in a language that had uncountably many sentence
symbols, then Theorem 2.4.2 could be established by using Zorn‚Äôs lemma (Lemma 1.1.36)
to obtain a set of wffs Œî that satisfies items (1), (2), and (3) in the above proof. The re-
mainder of the proof would then be as that after the proof of Claim 3.
The next useful corollary is just the contrapositive of the Compactness Theorem 2.4.2.
Corollary 2.4.4. Let Œ£ be a set of wffs. If Œ£ is not satisfiable, then there is a finite subset Œ£‚Ä≤
of Œ£ that is not satisfiable.

2.4 Compactness
‡±™
47
Let Œ£ be a set of wffs and let œÑ be a wff. From Exercise 16 on page 38, we have
Œ£
Ã∏Û≥ÄÄÛ≥®êœÑ
if and only if
Œ£ ‚à™{¬¨œÑ} is satisfiable.
(2.11)
The above equivalence (2.11) will be used in the proof of the following corollary.
Corollary 2.4.5. If Œ£ Û≥ÄÄÛ≥®êœÑ, then there is a finite Œ£0 ‚äÜŒ£ such that Œ£0 Û≥ÄÄÛ≥®êœÑ.
Proof. Assume that Œ£ Û≥ÄÄÛ≥®êœÑ. We shall prove that there is a finite Œ£0 ‚äÜŒ£ such that Œ£0 Û≥ÄÄÛ≥®êœÑ.
Suppose, for a contradiction, that for every finite Œ£0 ‚äÜŒ£, we have Œ£0
Ã∏Û≥ÄÄÛ≥®êœÑ. The above (2.11)
implies that
for every finite Œ£0 ‚äÜŒ£, Œ£0 ‚à™{¬¨œÑ} is satisfiable.
(2.12)
Consider the set of wffs Œ† = Œ£‚à™{¬¨œÑ}. The above statement (2.12) implies that every finite
subset of Œ† is satisfiable (why?). The compactness theorem thus asserts that Œ† = Œ£‚à™{¬¨œÑ}
is satisfiable. Thus, by (2.11), we have that Œ£
Ã∏Û≥ÄÄÛ≥®êœÑ, which contradicts our assumption.
Exercises 2.4.
*1. Let Œ£ be a set of wffs and let Œ± be a wff. Assume that Œ£ is finitely satisfiable. Prove
that either Œ£ ‚à™{Œ±} or Œ£ ‚à™{¬¨Œ±} is finitely satisfiable.
2. Let Œ£ be a set of wffs. Show Œ£ is not satisfiable if and only if Œ£ Û≥ÄÄÛ≥®ê(A ‚àß(¬¨A)).
3. Using the above Exercise 2, show that Corollary 2.4.5 implies Theorem 2.4.2.
*4. In the proof of Theorem 2.4.2, complete the proof of Claim 4.
5. Let Œ£ be the following 3-element set of wffs:
Œ£ = {((¬¨A ‚à®¬¨B) ‚àßC), ((¬¨A ‚à®¬¨C) ‚àßB), ((¬¨C ‚à®¬¨B) ‚àßA)}.
(a) Show that every subset of Œ£ containing less than three elements is satisfiable.
(b) Is Œ£ is satisfiable?
6. Let Œ£ and Œ† be sets of wffs. Suppose that for every finite Œ†0 ‚äÜŒ†, the set Œ£ ‚à™Œ†0 is
satisfiable. Using the compactness theorem, prove that Œ£ ‚à™Œ† is satisfiable.
7. Let Œî be a set of wffs such that:
(1) Œî is finitely satisfiable and
(2) for every wff Œ±, either Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî.
Let Œ≥ and Œ≤ be wffs.
(a) Suppose that Œ≥ ‚ààŒî and Œ≤ is tautologically equivalent to Œ≥. Show that Œ≤ ‚ààŒî.
(b) Show that Œ≥ ‚àßŒ≤ ‚ààŒî if and only if Œ≥ ‚ààŒî and Œ≤ ‚ààŒî.
(c) Show that Œ≥ ‚à®Œ≤ ‚ààŒî if and only if either Œ≥ ‚ààŒî or Œ≤ ‚ààŒî.
(d) Prove that (Œ≥ ‚ÜíŒ≤) ‚ààŒî if and only if Œ≥ ‚àâŒî or Œ≤ ‚ààŒî.
Exercise Notes: For Exercise 1, if Œ£‚à™{Œ±} and Œ£‚à™{¬¨Œ±} are not finitely satisfiable, then
there are finite subsets Œ£1 and Œ£2 of Œ£ such that Œ£1 ‚à™{Œ±} and Œ£2 ‚à™{¬¨Œ±} are not satisfiable.
Why? Now consider the finite set Œ£1 ‚à™Œ£2.

48
‡±™
2 Propositional logic
2.5 Deductions
Let Œ£ be a set of wffs and let œà be a wff. We know that Œ£ Û≥ÄÄÛ≥®êœà means that every truth as-
signment that satisfies every formula in Œ£ will also satisfy œà. Rather than working with
all such truth assignments, is it possible to ‚Äúdeduce‚Äù œà from Œ£? If so, what methods of
deduction would be required to demonstrate this fact? Whenever mathematicians com-
pose a proof, they justify a final conclusion by means of a series of intermediate steps.
Such steps typically appeal to some given assumptions and/or previously established
theorems. A theorem in mathematics is a statement that is true. Therefore, mathemati-
cians use assumptions and true statements to derive new results. In propositional logic,
can we use assumptions and tautologies to derive new results? In this section we will
positively address this question.
Definition 2.5.1. Let Œ£ be a set of wffs and let œà be a wff. A deduction of œà from Œ£ is a
finite sequence of wffs ‚ü®Œ±1, Œ±2, . . . , Œ±n‚ü©such that Œ±n = œà and for each k ‚â§n,
1.
Œ±k ‚ààŒ£,
2.
Œ±k is a tautology, or
3.
Œ±k is obtained by modus ponens from some Œ±i = (Œ±j ‚ÜíŒ±k) and Œ±j, where i, j < k.
When there is a deduction of œà from Œ£, we shall say that œà is deducible from Œ£ or that œà
is a theorem of Œ£, and we shall write Œ£ ‚ä¢œà. Recall that the inference rule modus ponens
is discussed on page 35.
A deduction can be viewed as a ‚Äúformal proof,‚Äù where each step is governed by
rules (1)‚Äì(3) of Definition 2.5.1. We use the term deduction to avoid confusion with our
own mathematical proofs.
We now present two examples of deductions for which each ‚Äúdeduction sequence‚Äù
is written in a vertical form with a parallel justification for each step.
Example 2.5.2. Let Œ£ = {Œ±, Œ≤}. Show that Œ£ ‚ä¢(Œ± ‚àßŒ≤).
Solution. The following (vertical) sequence satisfies the conditions in Definition 2.5.1:
1. Œ±
in Œ£,
2. Œ≤
in Œ£,
3. Œ± ‚ÜíŒ≤ ‚Üí(Œ± ‚àßŒ≤)
tautology (see Exercise 4 on page 37),
4. Œ≤ ‚Üí(Œ± ‚àßŒ≤)
from 1 and 3, by modus ponens,
5. (Œ± ‚àßŒ≤)
from 2 and 4, by modus ponens.
Therefore, Œ£ ‚ä¢(Œ± ‚àßŒ≤).
Example 2.5.3. Let Œ£ = {H ‚Üí¬¨B, D ‚ÜíB, H}. Show that Œ£ ‚ä¢(¬¨D).

2.5 Deductions
‡±™
49
Solution. The (vertical) sequence below is a deduction:
1. H ‚Üí¬¨B
in Œ£,
2. D ‚ÜíB
in Œ£,
3. H
in Œ£,
4. ¬¨B
from 1 and 3, by modus ponens,
5. (D ‚ÜíB) ‚Üí(¬¨B ‚Üí¬¨D)
tautology (see contrapositive law),1
6. ¬¨B ‚Üí¬¨D
from 2 and 5, by modus ponens,
7. ¬¨D
from 4 and 6, by modus ponens.
Hence, Œ£ ‚ä¢(¬¨D).
The definition of Œ£ Û≥ÄÄÛ≥®êœà involves truth assignments and the definition of Œ£ ‚ä¢œà in-
volves a ‚Äúdeduction sequence.‚Äù On the surface, these two concepts, Œ£ Û≥ÄÄÛ≥®êœà and Œ£ ‚ä¢œà,
seem to be unrelated. However, they are in fact intimately related. Our next two theo-
rems will confirm this purported intimacy. The first theorem shows that if the assump-
tions in Œ£ are true and Œ£ ‚ä¢œà, then the deduction œà is also true, that is, our deduction
system preserves truth and for this reason, it is said to be sound.
Theorem 2.5.4 (Propositional soundness). Let Œ£ be a set of wffs and œà be a wff. If Œ£ ‚ä¢œà,
then Œ£ Û≥ÄÄÛ≥®êœà.
Proof. Suppose that Œ£ ‚ä¢œà. So let ‚ü®Œ±1, Œ±2, . . . , Œ±n‚ü©, where Œ±n = œà, be a deduction of œà
from Œ£. For each natural number k, we shall prove that if 1 ‚â§k ‚â§n, then Œ£ Û≥ÄÄÛ≥®êŒ±k. We
shall use strong induction on k. If k = 1, then by Definition 2.5.1, either Œ±1 ‚ààŒ£ or Œ±1 is a
tautology. It thus follows that Œ£ Û≥ÄÄÛ≥®êŒ±1 (see Exercise 2 on page 37). Now let k be such that
1 < k ‚â§n and assume the induction hypothesis
Œ£ Û≥ÄÄÛ≥®êŒ±i
for all i < k.
(IH)
We must show that Œ£ Û≥ÄÄÛ≥®êŒ±k. Again, if Œ±k ‚ààŒ£ or Œ±k is a tautology, then we have Œ£ Û≥ÄÄÛ≥®êŒ±k. On
the other hand, suppose that Œ±k is obtained by modus ponens from some Œ±i = (Œ±j ‚ÜíŒ±k)
and Œ±j, where i, j < k. By the induction hypothesis (IH), we have Œ£ Û≥ÄÄÛ≥®ê(Œ±j ‚ÜíŒ±k) and
Œ£ Û≥ÄÄÛ≥®êŒ±j. Hence, Œ£ Û≥ÄÄÛ≥®êŒ±k (see page 35). This completes the induction, and thus, Œ£ Û≥ÄÄÛ≥®êœà.
Our next theorem shows that the converse of Theorem 2.5.4 holds, that is, for every
wff œà, if Œ£ tautologically implies œà, then there is a deduction of œà from Œ£. Thus, our
deduction system is said to be complete.
Theorem 2.5.5 (Propositional completeness). Let Œ£ be a set of wffs and let œà be a wff. If
Œ£ Û≥ÄÄÛ≥®êœà, then Œ£ ‚ä¢œà.
1 See Exercise 10 on page 38.

50
‡±™
2 Propositional logic
Proof. Assume that Œ£ Û≥ÄÄÛ≥®êœà. Corollary 2.4.5 implies that there is a finite Œ£0 ‚äÜŒ£ such that
Œ£0 Û≥ÄÄÛ≥®êœÑ. Let Œ£0 = {Œ±1, Œ±2, . . . Œ±n}. Exercise 6 below implies that
Œ±1 ‚ÜíŒ±2 ‚Üí‚ãÖ‚ãÖ‚ãÖ‚ÜíŒ±n ‚Üíœà
is a tautology. By repeated use of modus ponens, it easily follows that Œ£0 ‚ä¢œà. As Œ£0 ‚äÜŒ£,
we conclude that Œ£ ‚ä¢œà.
Theorems 2.5.4 and 2.5.5 immediately establish the following result.
Theorem 2.5.6. Let Œ£ be a set of wffs and let œà be a wff. Then Œ£ Û≥ÄÄÛ≥®êœà if and only if Œ£ ‚ä¢œà.
Our next theorem can sometimes be used to indirectly show that a deduction exists.
Our proof of this result applies Theorem 2.5.6.
Theorem 2.5.7 (Deduction theorem). Let Œ£ be a set of wffs and let Œ± and Œ≤ be wffs. Then
Œ£ ‚ä¢(Œ± ‚ÜíŒ≤) if and only if Œ£ ‚à™{Œ±} ‚ä¢Œ≤.
Proof. Let Œ£ be a set of wffs and let Œ± and Œ≤ be wffs. We thus have
Œ£ ‚ä¢(Œ± ‚ÜíŒ≤)
iff
Œ£ Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)
by Theorem 2.5.6,
iff
Œ£ ‚à™{Œ±} Û≥ÄÄÛ≥®êŒ≤
by Exercise 9 on page 38,
iff
Œ£ ‚à™{Œ±} ‚ä¢Œ≤
by Theorem 2.5.6.
Example 2.5.2 shows that {Œ≥, œÉ} ‚ä¢(Œ≥ ‚àßœÉ). So by Theorem 2.5.7, {Œ≥} ‚ä¢(œÉ ‚Üí(Œ≥ ‚àßœÉ)),
where Œ£ = {Œ≥}, Œ± is œÉ, and Œ≤ is (Œ≥ ‚àßœÉ).
In the conditional Œ± ‚ÜíŒ≤, Œ± is called the hypothesis and Œ≤ is called the conclusion. In
a mathematical proof of a conditional ‚Äúif , then ‚Äù, one typically assumes the hypothe-
sis and then derives the conclusion. The deduction theorem affirms that this is a valid
technique of proof in mathematics.
Our final theorem of this section verifies that ‚Äúproof by contradiction‚Äù is a valid
proof technique.
Definition 2.5.8. A set of wffs Œ£ is said to be inconsistent if there exists a wff Œ≤ such that
Œ£ ‚ä¢Œ≤ and Œ£ ‚ä¢¬¨Œ≤. Moreover, Œ£ is consistent if for no wff Œ≤ we have Œ£ ‚ä¢Œ≤ and Œ£ ‚ä¢¬¨Œ≤.
Theorem 2.5.9. Let Œ£ be a set of wffs and let Œ± be a wff. If Œ£ ‚à™{¬¨Œ±} is inconsistent, then
Œ£ ‚ä¢Œ±.
Proof. Assume that Œ£ ‚à™{¬¨Œ±} is inconsistent. Hence, for some wff Œ≤ we have Œ£ ‚à™{¬¨Œ±} ‚ä¢Œ≤
and Œ£‚à™{¬¨Œ±} ‚ä¢¬¨Œ≤. Thus, by Theorem 2.5.7 (the deduction theorem), we have Œ£ ‚ä¢(¬¨Œ± ‚ÜíŒ≤)
and Œ£ ‚ä¢(¬¨Œ± ‚Üí¬¨Œ≤). By Exercise 5 on page 37,
(¬¨Œ± ‚ÜíŒ≤) ‚Üí(¬¨Œ± ‚Üí¬¨Œ≤) ‚ÜíŒ±
is a tautology. Exercise 4 below now implies that Œ£ ‚ä¢Œ±.

2.5 Deductions
‡±™
51
There are alternative deduction systems for propositional logic that are equivalent
to the one presented in this section. In particular, there are deduction systems that start
with a finite set of tautologies and from this finite set one can then deduce all of the other
tautologies. Consequently, the deductions in such systems can be much longer than those
presented in this text. On the other hand, there are deduction systems that consist only
of a finite number of inference rules and from these rules one can deduce all of the tau-
tologies. Again, such deductions can be longer than the ones presented here. For each
of these alternative systems, one can prove a corresponding analogue of Theorem 2.5.6,
and thus these deduction systems are equivalent. In an introductory course in mathe-
matical logic, we believe that one should present a deduction system that is succinct and
produces the desired results.
Exercises 2.5.
1. Let Œ£ be an infinite set of wffs and let Œ± be a wff. Show that if Œ£ ‚ä¢Œ±, then there is a
finite Œ£0 ‚äÜŒ£ such that Œ£0 ‚ä¢Œ±.
2. Let Œ£ be a set of wffs and let Œ± be a wff. Let Œ£0 ‚äÜŒ£. Show that if Œ£0 ‚ä¢Œ±, then Œ£ ‚ä¢Œ±.
3. Let Œ£ be a set of wffs and let œà be a tautology. Show that Œ£ ‚ä¢œà.
*4. Let Œ£ be a set of wffs and let Œ∏, œà be wffs. Suppose that Œ£ ‚ä¢Œ∏ and Œ£ ‚ä¢(Œ∏ ‚Üíœà). Show
that Œ£ ‚ä¢œà.
5. Let Œ£1 and Œ£2 be sets of wffs and let Œ± and Œ≤ be wffs. Suppose that Œ£1 ‚ä¢Œ± and Œ£2 ‚ä¢Œ≤.
Show that Œ£1 ‚à™Œ£2 ‚ä¢(Œ± ‚àßŒ≤).
*6. Let n ‚â•1 be a natural number and let Œ£n = {Œ±1, Œ±2, . . . Œ±n} be a set of n wffs. Prove
that for all wffs Œ∏, if Œ£n Û≥ÄÄÛ≥®êŒ∏, then Œ±1 ‚ÜíŒ±2 ‚Üí‚ãÖ‚ãÖ‚ãÖ‚ÜíŒ±n ‚ÜíŒ∏ is a tautology.
7. Let n ‚â•1 be a natural number and let Œ£n = {Œ±1, Œ±2, . . . Œ±n} be a set of n wffs. Prove
that for all wffs Œ∏, if Œ±1 ‚ÜíŒ±2 ‚Üí‚ãÖ‚ãÖ‚ãÖ‚ÜíŒ±n ‚ÜíŒ∏ is a tautology, then Œ£n Û≥ÄÄÛ≥®êŒ∏.
8. Give a deduction from the set Œ£ = {¬¨A ‚à®B, B ‚ÜíC, A} whose last component is C.
9. Let Œ£ be an infinite set of wffs. Show that if Œ£ is inconsistent, then a finite subset of
Œ£ is inconsistent.
Exercise Notes: For Exercise 6, one can repeatedly apply Exercise 9 on page 38 (see
Remark 2.2.13(b)). A more formal proof of this result can be obtained by induction on n.
For Exercise 7, a proof of this result is obtained by induction on n (see (2.4) on page 37).

3 First-order logic
Mathematical logic is a branch of mathematics that investigates the foundations of math-
ematics. In this chapter, we shall do the same. Specifically, in Section 3.1, we discuss first-
order languages, together with some examples of first-order languages. First-order logic
is rich enough to formalize virtually all of mathematics. In Section 3.2, we will investi-
gate mathematical structures (models) and Tarski‚Äôs definition of truth (satisfaction) in a
structure. In Section 3.3, we shall examine the definition of proof (deduction) in a first-
order language.
3.1 First-order languages
In this section, we will formally define the syntax of the language of first-order logic.
First-order logic deals with formal statements that are expressed in terms of predicates,
logical connectives, variables, and quantifiers. A preview of such a logic is given in Sec-
tion 1.2.3. We will first identify the symbols of the language. An expression will then be
any finite string of these symbols. Some expressions will be nonsensical, while others
will be meaningful. Some of the meaningful expressions will denote terms which act as
the nouns and pronouns of the language; the terms can be interpreted as naming an
individual object. Once we have the terms of the language, we can define the atomic
formulas of the language. Atomic formulas are analogous to the sentence symbols of
propositional logic. We can then identify the correct rules of grammar and define the
well-formed formulas (wffs) of the language. To specify the terms and wffs requires def-
inition by recursion (see Section 1.1.5).
Definition 3.1.1. The alphabet of a first-order language ‚Ñíconsists of the following dis-
tinct symbols:
A.
Required symbols
1.
Parentheses: (, ).
2.
Logical connectives: ‚Üí, ¬¨.
3.
Variables: v1, v2, v3, v4, . . . , vn, . . . .
4.
Predicate symbols: For each natural number n > 0, a (possibly empty) set of
n-place predicate symbols.
5.
Quantifier symbol: ‚àÄ.
B.
Optional symbols
1.
Equality symbol: Ãá=, a 2-place relation.
2.
Constant symbols: A set of symbols, for example, {c1, c2, . . . }.
3.
Function symbols: For each natural number n > 0, a (possibly empty) set of
n-place function symbols.
https://doi.org/10.1515/9783110782073-003

3.1 First-order languages
‡±™
53
A dot over a familiar symbol is used to emphasize that the symbol has to be inter-
preted. This is also done to make a distinction between the symbol itself and the object
that it commonly represents.
A finite string of symbols from the language ‚Ñíwill be called an ‚Ñí-expression. For
example, v3c4c1)v3 is an ‚Ñí-expression that starts with the symbol v3. Moreover, v3c4 is
a proper initial segment of v3c4c1)v3. The ‚Ñí-expression v3c4c1)v3 does not appear to be
expressive. We will soon isolate the meaningful ‚Ñí-expressions from those that are mean-
ingless.
There exists a one-to-one correspondence between each ‚Ñí-expression Œ± and a finite
sequence of symbols in ‚Ñídenoted by ‚ü®Œ±‚àó‚ü©, where Œ±‚àóis the result of putting commas
between all of the symbols in Œ±. So an ‚Ñí-expression Œ± is a proper initial segment of the
‚Ñí-expression Œ≤ when ‚ü®Œ±‚àó‚ü©is a proper initial segment of ‚ü®Œ≤‚àó‚ü©(see Definition 1.1.6).
In the formal language ‚Ñí, we have listed only the logical connectives ‚Üíand ¬¨. Since
these two connectives are tautologically complete (see Exercise 5 on page 43), there is
no need to add more.
We also only identified the universal quantifier ‚àÄ. Since ¬¨‚àÄx¬¨Px is equivalent to
‚àÉxPx (see Quantifier Negation Laws 1.2.4(3)), the existential quantifier ‚àÉx can be viewed
as an abbreviation for ¬¨‚àÄx¬¨.
In the language ‚Ñí, an n-place function symbol is intended to represent a function of
n relevant ‚Ñí-expressions Œµ1, Œµ2, . . . , Œµn. Let f be a 3-place function with input Œµ1, Œµ2, Œµ3. In
mathematics f (Œµ1, Œµ2, Œµ3) would be the standard notation for the output value; however,
if f is a function symbol in the language ‚Ñí, we shall represent this output value by using
the Polish notation fŒµ1Œµ2Œµ3, where there are no parentheses or commas.
An n-place predicate symbol is intended to represent a property or relationship
of n relevant ‚Ñí-expressions; for example, if P is a 4-place predicate symbol in the lan-
guage ‚Ñí, then PŒµ1Œµ2Œµ3Œµ4 can be viewed as an assertion about Œµ1, Œµ2, Œµ3, Œµ4. Predicate sym-
bols are sometimes also called relation symbols.
The predicate, constant, and function symbols can be viewed as the parameters of
the language. To specify a language we must identify the particular predicate, constant,
and function symbols that we wish to use. Suppose our language ‚Ñícontains the equality
symbol, the predicate symbols P1, P2, . . . , constant symbols c1, c2, . . . , and function sym-
bols f1, f2, . . . . In the future we shall describe a language ‚Ñíby expressing it as a set of
these selected parameters, that is, we shall say that ‚Ñíis the set
‚Ñí= {P1, P2, . . . , c1, c2, . . . , f1, f2, . . . , Ãá=}.
Example 3.1.2 (Language of groups). When working with groups, one employs the lan-
guage ‚Ñí= {e, ‚àó, Ãá=}, which has a 2-place function symbol ‚àófor the group operation and a
constant symbol e for the identity element. We can write v1 ‚àóv2 and v1 Ãá= v2 to represent
the Polish notation Ãá=v1v2 and ‚àóv1v2, respectively.

54
‡±™
3 First-order logic
Example 3.1.3 (Language of set theory). Set theory uses the language ‚Ñí= { Ãá‚àà, Ãá=}, where
Ãá‚ààis a 2-place predicate symbol. We shall write v1 Ãá‚ààv2 to denote Ãá‚ààv1v2.
Example 3.1.4 (Language of elementary number theory). In number theory one can use
the language ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=}, which has a 2-place relation symbol Ãá<, a constant
symbol Ãá0, a 1-place function symbol ÃáS (successor), and 2-place function symbols Ãá+ (addi-
tion), Ãá√ó (multiplication), and ÃáE (exponentiation). Using Polish notation with these func-
tion symbols,
ÃáSx denotes ‚Äúx Ãá+ 1,‚Äù
Ãá+xy denotes ‚Äúx Ãá+ y,‚Äù
Ãá√óxy denotes ‚Äúx Ãá√ó y,‚Äù
ÃáExy denotes ‚Äúxy.‚Äù
We will write x
Ãá< y to represent
Ãá<xy. The Polish notation
ÃáS ÃáS Ãá0 can be translated to
ÃáS( ÃáS( Ãá0)). Continuing in this vein, how does one translate
Ãá+ ÃáS ÃáS Ãá0 ÃáS ÃáS ÃáS Ãá0? Since ÃáS ÃáS ÃáS Ãá0 trans-
lates to
ÃáS( ÃáS( ÃáS( Ãá0))) and
ÃáS ÃáS Ãá0 translates to
ÃáS( ÃáS( Ãá0)), we see that
Ãá+SS Ãá0 ÃáS ÃáS Ãá0 translates to
ÃáS( ÃáS( Ãá0)) Ãá+ ÃáS( ÃáS( ÃáS( Ãá0))). For any natural number n, we will write
ÃáSn Ãá0 =
n times
‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû
ÃáS ÃáS ‚ãÖ‚ãÖ‚ãÖÃáS Ãá0.
Example 3.1.5 (A language for real analysis). In real analysis, one could use the language
‚Ñí= { Ãá<, Ãá‚àí, Ãá0, c, | |, f , Ãá=} which has a 2-place relation symbol Ãá< (less than), constant symbols
Ãá0 (zero) and c, a 2-place function symbol Ãá‚àí(subtraction), and 1-place function symbols
| | (absolute value) and f .
3.1.1 Terms and atomic formulas
We will now describe how to generate the terms of a language ‚Ñí. The method we shall
use to construct the terms is not new; it is just an application of Theorem 1.1.24. Let U be
the set of all ‚Ñí-expressions. For each n-place function symbol f in the language ‚Ñí, define
the (mathematical) function ‚Ñ∞f : Un ‚ÜíU by
‚Ñ∞f (Œµ1, Œµ2, . . . , Œµn) = fŒµ1Œµ2 ‚ãÖ‚ãÖ‚ãÖŒµn.
(3.1)
Definition 3.1.6. Let ‚Ñ±= {‚Ñ∞f : f is a function symbol in ‚Ñí} and let ùíØbe the set of all
the variables and constants in the language ‚Ñí. Let ùíØbe the set generated from ùíØby the
functions in ‚Ñ±. An ‚Ñí-expression œÑ is an ‚Ñí-term if and only if œÑ ‚ààùíØ.

3.1 First-order languages
‡±™
55
So the set of ‚Ñí-terms ùíØis the set of ‚Ñí-expressions that can be constructed by starting
with the variables and constants and by repeatedly applying the functions in ‚Ñ±. This
may all seem a bit abstract. Let us try to make Definition 3.1.6 a little more concrete by
revisiting Theorem 1.1.24 in the current context.
Let C0 = ùíØbe the set of all the variables and constants in the language ‚Ñí. Constants
and variables are ‚Ñí-terms, and we can use these to build more ‚Ñí-terms. Let h be a 3-place
function symbol in ‚Ñí. Thus,
‚Ñ∞h(Œµ1, Œµ2, Œµ3) = hŒµ1Œµ2Œµ3,
by (3.1). Now, using ‚Ñ∞h, the following set produces more ‚Ñí-terms:
‚Ñ∞h[C0] = {hŒµ1Œµ2Œµ3 : Œµ1, Œµ2, Œµ3 ‚ààC0}.
Thus, t ‚àà‚Ñ∞h[C0] if and only if t = hŒµ1Œµ2Œµ3, where Œµ1, Œµ2, Œµ3 are constants or variables.
For example, t1 = hv7c5v3 and t2 = hc4c1v2 are ‚Ñí-terms in ‚Ñ∞h[C0]. This is only a small
sample of all the ‚Ñí-terms that can be constructed. For any other function symbol g in ‚Ñí,
there are new ‚Ñí-terms in ‚Ñ∞g[C0] as well. To put all of these ‚Ñí-terms together in one set,
we define C1 = C0 ‚à™‚ãÉ{‚Ñ∞f [C0] : ‚Ñ∞f ‚àà‚Ñ±}, where ‚Ñ±is as in Definition 3.1.6. So t1, t2 ‚ààC1.
Using all of the ‚Ñí-terms in C1, we can build more ‚Ñí-terms by letting C2 = C1 ‚à™‚ãÉ{‚Ñ∞f [C1] :
‚Ñ∞f ‚àà‚Ñ±}. So, for example, if g is a 4-place function symbol in ‚Ñí, then gv4t1c1t2 ‚ààC2. Note
that
gv4t1c1t2 = gv4hv7c5v3c1hc4c1v2.
By repeating this process, we get the set of ‚Ñí-terms
Cn+1 = Cn ‚à™‚ãÉ{‚Ñ∞f [Cn] : ‚Ñ∞f ‚àà‚Ñ±}
for each n. Then the set of all the ‚Ñí-terms is ùíØ= ‚ãÉn‚àà‚ÑïCn, that is, the set ùíØis generated
from ùíØby the functions in ‚Ñ±. Definition 3.1.6 and the previous discussion justify the
following useful remark.
Remark 3.1.7. An ‚Ñí-expression t is an ‚Ñí-term of a language ‚Ñíif and only if either
1.
t is a variable, or
2.
t is a constant symbol, or
3.
t is ft1t2 ‚ãÖ‚ãÖ‚ãÖtn, where f is an n-place function symbol of ‚Ñíand each ti is an ‚Ñí-term.
If the language ‚Ñíhas no function symbols, then the terms are just the constants and
the variables.

56
‡±™
3 First-order logic
3.1.2 Induction on terms principle
Since there is a procedure for building all of the ‚Ñí-terms by starting with the variables
and constants and then repeatedly applying the function symbols of ‚Ñí, Theorem 1.1.25
yields the following term induction principle and associated proof strategy.
Term Induction Principle. Let ùïä(t) be a statement about ‚Ñí-terms t. If
1.
ùïä(v) and ùïä(c) hold for all the variables v and constants c and
2.
for all n-place function symbols f in ‚Ñíand all ‚Ñí-terms t1, t2, . . . , tn, if S(ti) holds for
each 1 ‚â§i ‚â§n, then ùïä(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn),
then ùïä(t) is true for all ‚Ñí-terms t.
Proof Strategy. In order to prove an assertion ‚Äúfor all ‚Ñí-terms t, ùïä(t)‚Äù by induction on
‚Ñí-terms, use the following proof diagram:
Base step:
Prove ùïä(v) and ùïä(c) for all the variables v and constants c.
Inductive step:
Let f be an n-place function symbol and let t1, t2, . . . , tn be ‚Ñí-terms.
Assume ùïä(ti) for each 1 ‚â§i ‚â§n.
Prove ùïä(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn).
Applications of the term induction principle
Theorem 3.1.8. Let ‚Ñíbe a language. For all ‚Ñí-terms t and œÑ, neither t nor œÑ is a proper
initial segment of the other.
Proof. For all ‚Ñí-expressions œÑ and t, we shall write œÑ ‚â∫t to mean that œÑ is a proper initial
segment of t and write œÑ ‚äÄt to mean that œÑ is not a proper initial segment of t. Consider
the following statement about ‚Ñí-terms t:
For all ‚Ñí-terms œÑ, œÑ ‚äÄt and t ‚äÄœÑ.
We prove that the above statement holds for all ‚Ñí-terms t by induction.
Base step: Let t be a variable or a constant symbol and let œÑ be any ‚Ñí-term. As t has
no proper initial segments, we see that œÑ ‚äÄt. Since t is either a variable or a constant
symbol, Exercise 1 below implies that t ‚äÄœÑ.
Inductive step: Let f be an n-place function symbol in ‚Ñíand also let t1, t2, . . . , tn be
‚Ñí-terms. Assume the induction hypothesis:
For all ‚Ñí-terms œÑ, œÑ ‚äÄti and ti ‚äÄœÑ, whenever 1 ‚â§i ‚â§n.
(IH)
Let œÑ be any ‚Ñí-term. We must prove that
œÑ ‚äÄft1t2 ‚ãÖ‚ãÖ‚ãÖtn
and
ft1t2 ‚ãÖ‚ãÖ‚ãÖtn ‚äÄœÑ.

3.1 First-order languages
‡±™
57
First we show that œÑ ‚äÄft1t2 ‚ãÖ‚ãÖ‚ãÖtn. Assume, to the contrary, that (Û≥µ≥) œÑ ‚â∫ft1t2 ‚ãÖ‚ãÖ‚ãÖtn. Hence,
œÑ must start with the symbol f . Since f is an n-place function symbol and œÑ is a term,
œÑ must have the form œÑ = fœÑ1œÑ2 ‚ãÖ‚ãÖ‚ãÖœÑn, where œÑ1, œÑ2, . . . , œÑn are ‚Ñí-terms. From (Û≥µ≥), we obtain
fœÑ1œÑ2 ‚ãÖ‚ãÖ‚ãÖœÑn ‚â∫ft1t2 ‚ãÖ‚ãÖ‚ãÖtn. By dropping the common starting symbol f , we conclude that
œÑ1œÑ2 ‚ãÖ‚ãÖ‚ãÖœÑn ‚â∫t1t2 ‚ãÖ‚ãÖ‚ãÖtn.
(3.2)
As œÑ1 and t1 are ‚Ñí-terms, the induction hypothesis (IH) implies that œÑ1 and t1 cannot be
proper initial segments of one another. Thus, (3.2) implies that œÑ1 = t1. Hence,
œÑ2 ‚ãÖ‚ãÖ‚ãÖœÑn ‚â∫t2 ‚ãÖ‚ãÖ‚ãÖtn.
(3.3)
By similar reasoning, (3.3) implies that œÑ2 = t2. Continuing in this manner, we infer that
œÑ1 = t1, œÑ2 = t2, . . . , œÑn‚àí1 = tn‚àí1. From (3.2), we now conclude that tn ‚â∫œÑn, which contra-
dicts (IH). Hence, œÑ ‚äÄft1t2 ‚ãÖ‚ãÖ‚ãÖtn. A very similar argument shows that ft1t2 ‚ãÖ‚ãÖ‚ãÖtn ‚äÄœÑ.
Theorem 3.1.9 (Unique readability of terms). Let ‚Ñíbe a language and let ùíØbe the set of
all the variables and constant symbols. Moreover, let ùíØbe the set of terms generated from
ùíØby the functions in ‚Ñ±= {‚Ñ∞f : f is a function symbol in ‚Ñí}. When the functions in ‚Ñ±are
restricted to the set of ‚Ñí-terms ùíØ, we have the following:
(a) The range of each function in ‚Ñ±is disjoint from ùíØ.
(b) Any two distinct functions in ‚Ñ±have disjoint ranges.
(c) Every function in ‚Ñ±is one-to-one.
That is, the set of all terms is freely generated from the set ùíØby the functions in ‚Ñ±.
Proof. Let ‚Ñí, ùíØ, ‚Ñ±, and ùíØbe as stated in the theorem and let all the functions in ‚Ñ±be
restricted to ùíØ.
(a) Let ‚Ñ∞f ‚àà‚Ñ±. Since every term in the range of ‚Ñ∞f starts with the function symbol f , we
see that the range of ‚Ñ∞f is disjoint from ùíØ.
(b) Let f and g be two distinct function symbols in ‚Ñí. Since f
Ã∏= g, we see that the ranges
of ‚Ñ∞f and ‚Ñ∞f are disjoint.
(c) Let f be an n-place function symbol in ‚Ñí. We must show that ‚Ñ∞f is one-to-one. Let
œÑ1, œÑ2, . . . , œÑn and t1, t2, . . . , tn be ‚Ñí-terms. Assume that
‚Ñ∞f (œÑ1, œÑ2, . . . , œÑn) = ‚Ñ∞f (t1, t2, . . . , tn).
Thus, fœÑ1œÑ2 ‚ãÖ‚ãÖ‚ãÖœÑn = ft1t2 ‚ãÖ‚ãÖ‚ãÖtn. Theorem 3.1.8, together with its proof, allows us to
conclude that œÑ1 = t1, œÑ2 = t2, . . . , œÑn = tn.
The above unique readability theorem (Theorem 3.1.9) will now allow us, via Theo-
rem 1.1.27, to recursively define a function on the ‚Ñí-terms using a function that is only
defined on the variables and constants of a language ‚Ñí.
We are now able to define the atomic formulas.

58
‡±™
3 First-order logic
Definition 3.1.10. An atomic formula of a language ‚Ñíis an expression of the form
Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn, where P is an n-place predicate symbol of ‚Ñíand each ti is an ‚Ñí-term.
For example, if the language ‚Ñíhas the 2-place equality symbol, then the expression
Ãá=vivj is an atomic formula as the variables are ‚Ñí-terms. In the future, we shall let Ãá=vivj
be denoted by vi Ãá= vj. In the language of set theory, Ãá‚ààvivj is an atomic formula, which we
will denote by vi Ãá‚ààvj. As we will see, the atomic formulas will play a role similar to that
of the sentence symbols of propositional logic.
Theorem 3.1.8 directly implies an analogous result for atomic formulas.
Theorem 3.1.11. Let ‚Ñíbe a language. No proper initial segment of an atomic formula is
itself an atomic formula.
3.1.3 Well-formed formulas
We will now formally define the concept of a well-formed formula (wff or formula) in
first-order logic. Informally speaking, wffs are the atomic formulas and those expres-
sions that can be built up from the atomic formulas using the logical connectives and
the quantifier symbol.
Before defining wffs, we need the following formula building functions. Let Œ± and Œ≤
be expressions. Then
‚Ñ∞¬¨(Œ±) = (¬¨Œ±),
‚Ñ∞‚Üí(Œ±, Œ≤) = (Œ± ‚ÜíŒ≤),
(3.4)
‚Ñ∞Qi(Œ±) = ‚àÄviŒ±,
where i = 1, 2, 3, . . . . The following definition is a special case of Theorem 1.1.24.
Definition 3.1.12. Let ‚Ñíbe a language, let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚Üí, ‚Ñ∞Q1, ‚Ñ∞Q2, . . . }, and let ùíÆbe a set of
all of the atomic formulas in the language ‚Ñí. Let ùíÆbe the set generated from ùíÆby the
functions in ‚Ñ±. An ‚Ñí-expression Œ± is a wff if and only if Œ± ‚ààùíÆ.
We will also say that Œ± is an ‚Ñí-formula, or an ‚Ñí-wff , to mean that Œ± is a wff in the
language ‚Ñí. The following remark is justified by Definition 3.1.12.
Remark 3.1.13. An ‚Ñí-expression œà is a wff if and only if either
1.
œà is an atomic formula, or
2.
œà has the form (¬¨Œ±), where Œ± is a wff, or
3.
œà has the form (Œ± ‚ÜíŒ≤), where Œ± and Œ≤ are wffs, or
4.
œà has the form ‚àÄviŒ±, where Œ± is a wff and i ‚â•1.
Example 3.1.14. Let ‚Ñí= {P, f , c, Ãá=}, where P is a 2-place predicate symbol, f is a 1-place
function symbol, and c is a constant symbol. The following are ‚Ñí-formulas:

3.1 First-order languages
‡±™
59
1.
‚àÄv1(Pv1c ‚Üív1 Ãá= fc), where Pv1c and v1 Ãá= fc are atomic formulas,
2.
‚àÄv1(fv2 Ãá= fc ‚Üí(¬¨Pfv1c)), where fv2 Ãá= fc and Pfv1c are atomic formulas,
3.
‚àÄv1‚àÄv2(fv1 Ãá= fv2 ‚Üív1 Ãá= v2), where fv1 Ãá= fv2 and v1 Ãá= v2 are atomic formulas.
3.1.4 Induction on wffs principle
Since Definition 3.1.12 ensures that there is a procedure for building each wff by first
starting with atomic formulas and then applying the connective symbols ¬¨, ‚Üíand the
quantifier symbol ‚àÄ, Theorem 1.1.25 validates the following induction on wffs princi-
ple.
Wff Induction Principle. Let ùïä(Œ±) be a statement about an arbitrary wff Œ±. If
1.
ùïä(œï) is true for all atomic formulas œï and
2.
for all wffs Œ± and Œ≤, ùïä(Œ±) and ùïä(Œ≤) imply that ùïä((¬¨Œ±)), ùïä((Œ± ‚ÜíŒ≤)), and ùïä(‚àÄviŒ±),
then ùïä(Œ±) is true for all wffs Œ±.
Proof Strategy. In order to prove an assertion ‚Äúfor all wffs Œ±, ùïä(Œ±)‚Äù by induction, use
the following diagram:
Base step:
Prove ùïä(œï) for all atomic formulas œï.
Inductive step:
Let Œ± and Œ≤ be arbitrary wffs.
Assume ùïä(Œ±) and ùïä(Œ≤).
Prove ùïä((¬¨Œ±)), ùïä((Œ± ‚ÜíŒ≤)), and ùïä(‚àÄviŒ±).
Applications of wff induction principle
Theorem 3.1.15. Let ‚Ñíbe a language. For all wffs Œ± and Œ≤, neither Œ± nor Œ≤ is a proper
initial segment of the other.
Proof. For all ‚Ñí-expressions œà and œÜ, we shall write œà ‚â∫œÜ to mean that œà is a proper
initial segment of œÜ and write œà ‚äÄœÜ to mean that œà is not a proper initial segment of œÜ.
Consider the following statement about wffs Œ±:
For all wffs Œ≥, Œ≥ ‚äÄŒ± and Œ± ‚äÄŒ≥.
We prove that the above statement holds for all wffs Œ± by induction.
Base step: Let Œ± be an atomic formula and let Œ≥ be an arbitrary wff. To show that
Œ≥ ‚äÄŒ±, assume, to the contrary, that Œ≥ ‚â∫Œ±. Since Œ± is an atomic formula, there exist
an n-place predicate symbol P and terms t1, t2, . . . , tn such that Œ± = Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn. Hence,
(Û≥µ≥) Œ≥ ‚â∫Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn. So Œ≥ starts with the predicate symbol P. As Œ≥ is a wff, it follows
that Œ≥ must also be an atomic formula. Thus, (Û≥µ≥) contradicts Theorem 3.1.11. A similar
argument shows that Œ± ‚äÄŒ≥.

60
‡±™
3 First-order logic
Inductive step: Let Œ± and Œ≤ be wffs. Assume the induction hypothesis:
For all wffs Œ≥, we have Œ≥ ‚äÄŒ±, Œ± ‚äÄŒ≥ and Œ≥ ‚äÄŒ≤, Œ≤ ‚äÄŒ≥.
(IH)
Let Œ≥ be any wff. We must prove that Œ≥ ‚äÄœà and œà ‚äÄŒ≥ whenever œà has the form
(1) (¬¨Œ±),
(2) (Œ± ‚ÜíŒ≤), or
(3) ‚àÄviŒ±.
Let us first consider case (2). To show that Œ≥ ‚äÄ(Œ± ‚ÜíŒ≤), assume (for a contradiction) that
(Û≥∂É) Œ≥ ‚â∫(Œ± ‚ÜíŒ≤). So Œ≥ starts with the symbol (. Thus, as Œ≥ is a wff, Œ≥ must have the form
(¬¨œë) or (Œ∂ ‚ÜíœÜ), where œë, Œ∂, and œÜ are wffs (see Remark 3.1.13). If Œ≥ had the form (¬¨œë),
then (Û≥∂É) would imply that the wff Œ± starts with the symbol ¬¨, which is impossible. Hence,
Œ≥ = (Œ∂ ‚ÜíœÜ), and thus (Œ∂ ‚ÜíœÜ) ‚â∫(Œ± ‚ÜíŒ≤). Therefore, by dropping the left parenthesis,
the induction hypothesis (IH) implies that Œ∂ = Œ±. It now follows that œÜ ‚â∫Œ≤ (why?), which
contradicts (IH). An analogous argument shows that (Œ± ‚ÜíŒ≤) ‚äÄŒ≥. The proofs of cases (1)
and (3) also follow by a similar argument.
It is now straightforward to establish the following important theorem (see the
proof of Theorem 2.2.1).
Theorem 3.1.16 (Unique readability of wffs). Let ‚Ñíbe a language and let ùíÆbe the set of all
the atomic formulas. Moreover, let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚Üí, ‚Ñ∞Q1, ‚Ñ∞Q2, . . . }. Let ùíÆbe the set generated
from ùíÆby the functions in ‚Ñ±. When the functions in ‚Ñ±are restricted to the set of wffs ùíÆ,
we have the following:
(a) The range of each function in ‚Ñ±is disjoint from ùíÆ.
(b) Any two distinct functions in ‚Ñ±have disjoint ranges.
(c) Every function in ‚Ñ±is one-to-one.
That is, the set of all wffs is freely generated from the set ùíÆby the functions in ‚Ñ±.
Theorem 3.1.16 will now allow us, via Theorem 1.1.27, to recursively define a function
on the wffs of a language ‚Ñíusing a function that is only defined on the atomic formulas
of the language.
3.1.5 Free variables
A variable v is free in a wff if it occurs at least once in the formula without being intro-
duced by the quantified expression ‚àÄv. In set theory one uses the language ‚Ñí= { Ãá‚àà, Ãá=},
which has the 2-place predicate symbol Ãá‚àà. Here are two wffs from the language of set
theory and their translations into English.

3.1 First-order languages
‡±™
61
1. ‚àÄv1(v1 Ãá‚ààv1)
English: ‚ÄúEvery set is an element of itself.‚Äù
2. ‚àÄv3(v3 Ãá‚ààv1 ‚Üív3 Ãá‚ààv2)
English: ‚ÄúEvery element in v1 is also in v2.‚Äù
There is a critical difference between these two formulas. The first formula translates
to a complete English sentence, whereas the second formula translates to an English
expression containing the two variables v1 and v2. In the second formula, we shall say
that v1 and v2 are ‚Äúfree variables.‚Äù Note the variable in the first formula is attached to a
quantifier. In this case we say that the variable is bound by a quantifier. For another ex-
ample, let ‚Ñí= {P, c, Ãá=}, where P is a 2-place predicate symbol and c is a constant symbol.
Then the variable v1 is free in the wff (‚àÄv1Pv1v1 ‚Üí(¬¨Pv1c)) because the appearance of
v1 after ‚Üíis not attached to the quantifier.
The above descriptions of ‚Äúfree‚Äù and ‚Äúnot free‚Äù variables may seem a bit vague. We
shall now give a precise mathematical definition for the concept of a variable occurring
free in a wff. The following definition by recursion is an application of Theorems 1.1.27
and 3.1.16, as will be demonstrated. It is this definition that one should use to determine
whether or not a variable appears free in a wff.
Definition 3.1.17. Let ‚Ñíbe a language with variable v. The concept that v occurs free in
a wff of ‚Ñíis defined recursively as follows:
1.
v occurs free in œï if œï is an atomic formula and v appears as a symbol in œï;
2.
v occurs free in (¬¨Œ±) if and only if v occurs free in Œ±;
3.
v occurs free in (Œ± ‚ÜíŒ≤) if and only if v occurs free in Œ± or v occurs free in Œ≤;
4.
v occurs free in ‚àÄviŒ± if and only if v occurs free in Œ± and v
Ã∏= vi.
We will now formally justify the validity of Definition 3.1.17. Before continuing, it is
recommended that one revisit Theorem 1.1.27. Let ‚Ñíbe a language and let V be the set of
all finite sets of the variables of ‚Ñí. Let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚Üí, ‚Ñ∞Q1, ‚Ñ∞Q2, . . . }, let S be the set of atomic
formulas, and let ùíÆbe the set generated from ùíÆby the functions in ‚Ñ±. Of course, ùíÆis the
set of all the wffs. For each function in ‚Ñ±we define the associated functions F¬¨: V ‚ÜíV,
F‚Üí: V 2 ‚ÜíV, FQi: V ‚ÜíV (for each i ‚â•1) as follows:
F¬¨(a) = a,
F‚Üí(a, b) = a ‚à™b,
FQi(a) = a \ {vi}.
Now let h: S ‚ÜíV be defined by
h(œï) = set of variables, if any, that occur in the atomic formula œï.
Theorems 1.1.27 and 3.1.16 imply that there is a unique h: ùíÆ‚ÜíV such that:
(1) h(Œ±) = h(Œ±) if Œ± is an atomic formula,
(2) h((¬¨Œ±)) = h(Œ±),

62
‡±™
3 First-order logic
(3) h((Œ± ‚ÜíŒ≤)) = h(Œ±) ‚à™h(Œ≤),
(4) h(‚àÄviŒ±) = h(Œ±) \ {vi}.
For every wff Œ±, it follows that h(Œ±) is the set of all the free variables in Œ±. Thus, if h(Œ±) = ‚åÄ,
then Œ± has no free variables.
Definition 3.1.18. Let Œ± be a wff in a language ‚Ñí. If no variable occurs free in Œ±, then Œ±
is called a sentence, or an ‚Ñí-sentence.
Let Œ± be a sentence. When one translates Œ± into English, one will obtain a complete
English sentence. On the other hand, if Œ≤ is a wff in which variables occur free, then an
English translation of Œ≤ will lead to an English expression containing variables.
3.1.6 Notational abbreviations
The limitations that our first-order languages have imposed upon us should be clear.
For example, we cannot use the logical connectives ‚àßand ‚à®, and we cannot use the
existential quantifier ‚àÉv. These restrictions will now be removed by using the method
of ‚Äúabbreviations,‚Äù which will translate our wffs into a more readable form. This method
does not change our formal definition of a wff; it will only enhance the readability of our
wffs. However, whenever we define or prove new results about a first-order language,
we will use Definition 3.1.12 as our definition of a wff.
Since the set of logical connectives {¬¨, ‚Üí} is tautologically complete, the usage of
the logical connectives ‚àßand ‚à®can be expressed in terms of the connectives ¬¨ and ‚Üí.
Moreover, the existential quantifier ‚àÉcan be expressed in terms of ¬¨ and ‚àÄ(recall the
Quantifier Negation Law 1.2.4(3)). Hence, we will be using the following abbreviations
and conventions. The word ‚Äúabbreviated‚Äù is intended to mean ‚Äúeasier to read.‚Äù
1.
The expression (Œ± ‚àßŒ≤) is the abbreviated form of (¬¨(Œ± ‚Üí(¬¨Œ≤))).
2.
The expression (Œ± ‚à®Œ≤) is the abbreviated form of ((¬¨Œ±) ‚ÜíŒ≤).
3.
The expression (Œ± ‚ÜîŒ≤) is equivalent to ((Œ± ‚ÜíŒ≤) ‚àß(Œ≤ ‚ÜíŒ±)) and thus the abbrevi-
ated form of
(¬¨((Œ± ‚ÜíŒ≤) ‚Üí(¬¨(Œ≤ ‚ÜíŒ±)))).
4.
The expression ‚àÉvŒ± is the abbreviated form of (¬¨‚àÄv(¬¨Œ±)).
5.
x Ãá=y is the abbreviated form of Ãá=xy. Similar abbreviations will apply to several other
2-place predicate and function symbols; namely, x Ãá<y is the abbreviated form of Ãá<xy
and x Ãá+ y is the abbreviated form of Ãá+xy.
6.
x
Ã∏Ãá= y is the abbreviated form of ¬¨ Ãá=xy. Similar abbreviations apply to the negation
of a few other 2-place predicate symbols. For example, x Ã∏Ãá<y is the abbreviated form
of ¬¨ Ãá<xy.

3.1 First-order languages
‡±™
63
7.
The outermost parentheses need not be explicitly written. So we can write ‚àÄxŒ± ‚ÜíŒ≤
rather than (‚àÄxŒ± ‚ÜíŒ≤) and ¬¨Œ± rather than (¬¨Œ±).
8.
¬¨, ‚àÄ, and ‚àÉapply to as little as possible. For example,
(a) ¬¨Œ± ‚àßŒ≤ denotes (¬¨Œ±) ‚àßŒ≤, and not ¬¨(Œ± ‚àßŒ≤);
(b) ‚àÄxŒ± ‚ÜíŒ≤ denotes (‚àÄxŒ± ‚ÜíŒ≤), and not ‚àÄx(Œ± ‚ÜíŒ≤);
(c) ‚àÉxŒ± ‚àßŒ≤ denotes (‚àÉxŒ± ‚àßŒ≤), and not ‚àÉx(Œ± ‚àßŒ≤).
9.
‚àßand ‚à®will apply to as little as possible, given that convention 8 is observed. For
example, Œ± ‚àßŒ≤ ‚Üí¬¨Œ≥ ‚à®Œ¥ denotes ((Œ± ‚àßŒ≤) ‚Üí((¬¨Œ≥) ‚à®Œ¥)).
10. When one connective is used repeatedly, grouping is to the right. For example, we
will write Œ± ‚àßŒ≤ ‚àßŒ≥ to denote Œ± ‚àß(Œ≤ ‚àßŒ≥) and Œ± ‚ÜíŒ≤ ‚ÜíŒ≥ to denote Œ± ‚Üí(Œ≤ ‚ÜíŒ≥).
11. We will add parentheses when necessary to ensure readability.
Given an abbreviated wff, one can eliminate all of the abbreviations and obtain the un-
abbreviated version. For example, consider the abbreviated wff ‚àÉx(Œ±‚àßŒ≤). We can begin
to ‚Äúexpand‚Äù it to the original wff as follows:
‚àÉx(Œ± ‚àßŒ≤) ‚áî(¬¨‚àÄx(¬¨(Œ± ‚àßŒ≤)))
by item 4 above,
‚áî(¬¨‚àÄx(¬¨(¬¨(Œ± ‚Üí(¬¨Œ≤)))))
by item 1 above.
Thus, ‚àÉx(Œ± ‚àßŒ≤) expands to (¬¨‚àÄx(¬¨(¬¨(Œ± ‚Üí(¬¨Œ≤))))). Now, if required, expand Œ± and Œ≤,
and do a substitution. For another example, let us rewrite ‚àÉxŒ± ‚ÜíŒ≤. We obtain
‚àÉxŒ± ‚ÜíŒ≤ ‚áî(‚àÉxŒ± ‚ÜíŒ≤)
adding parentheses,
‚áî((¬¨‚àÄx(¬¨Œ±)) ‚ÜíŒ≤)
by item 4 above.
Throughout the text, we will attempt to use the following conventions:
‚Äì
Predicate symbols: Upper-case symbols. Also, Ãá‚àà, Ãá<, and Ãá=.
‚Äì
Variables: vi, u, v, x, y, z.
‚Äì
Function symbols: f , g, h. Also, S, Ãá+, Ãá‚àí, Ãá√ó, etc.
‚Äì
Constant symbols: c1, c2, . . . , a, b, c, . . . . Also, Ãá0.
‚Äì
Terms: t, œÑ.
‚Äì
Wffs: Lower-case Greek letters.
‚Äì
Sets of wffs: Upper-case Greek letters.
3.1.7 Examples of languages
Example 3.1.19 (Language of groups). The language ‚Ñí= {e, ‚àó, Ãá=} is used in group theory.
The language ‚Ñíhas a 2-place function symbol ‚àófor the group operation and a constant
symbol e for the identity element. The quantifier ‚àÄis intended to mean ‚Äúfor all elements
in the group.‚Äù Using ‚Ñíand writing ‚àóxy as x ‚àóy, we can express the following group ax-
ioms:

64
‡±™
3 First-order logic
1.
‚àÄv1‚àÄv2‚àÄv3(v1 ‚àó(v2 ‚àóv3) Ãá= (v1 ‚àóv2) ‚àóv3),
(associativity)
2.
‚àÄv1(v1 ‚àóe Ãá= v1),
(identity element)
3.
‚àÄv1‚àÉv2(v1 ‚àóv2 Ãá= e).
(inverses exists)
Example 3.1.20 (Language of set theory). In set theory one employs the language ‚Ñí=
{ Ãá‚àà, Ãá=}, which has a 2-place predicate symbol Ãá‚àà. It is intended that ‚àÄshould mean ‚Äúfor all
sets.‚Äù Using ‚Ñíand writing Ãá‚ààxy as x Ãá‚àày, one can express the following:
1.
‚àÄv1‚àÉv2(v1 Ãá‚ààv2):
‚Äúevery set is an element of some set,‚Äù
2.
‚àÄv3(v3 Ãá‚ààv1 ‚Üív3 Ãá‚ààv2):
‚Äúevery element in v1 is also in v2,‚Äù
3.
‚àÄv2‚àÄv3((v3 Ãá‚ààv1 ‚àßv2 Ãá‚ààv1) ‚Üív2 Ãá= v3):
‚Äúv1 has at most one element.‚Äù
Example 3.1.21 (A language for real analysis). If we are working in real analysis, then we
could use a language like ‚Ñí= { Ãá<, Ãá‚àí, Ãá0, c, ‚Ñì, | |, f }, which has a 2-place relation symbol Ãá<
(less than); constant symbols Ãá0 (zero), c, and ‚Ñì; a 2-place function symbol Ãá‚àí(subtraction);
the 1-place function symbol | | (absolute value); and the 1-place function symbol f . It is
intended that ‚àÄshould mean ‚Äúfor all real numbers.‚Äù The following wff in the language
‚Ñíasserts that limx‚Üíc f (x) = ‚Ñì:
‚àÄv1‚àÉv2( Ãá0 Ãá< v1 ‚Üí‚àÄv3(( Ãá0 Ãá< |v3 ‚àíc| ‚àß|v3 ‚àíc| Ãá< v2) ‚Üí|fv3 ‚àí‚Ñì| Ãá< v1)).
Example 3.1.22 (Language of elementary number theory). In elementary number theory
one can use the language ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=}, which has a 2-place relation symbol Ãá<
(less than), a constant symbol Ãá0, a 1-place function symbol ÃáS (successor; ÃáS Ãá0 denotes 1,
ÃáS ÃáS Ãá0 denotes 2, etc.), and three 2-place function symbols Ãá+ (addition), Ãá√ó (multiplication),
and ÃáE (exponentiation; ÃáExy usually denotes xy). The universal quantifier ‚àÄis intended
to mean ‚Äúfor all natural numbers.‚Äù The wff
‚àÄv1(( ÃáS ÃáS ÃáS Ãá0 Ãá< v1 ‚à®v1 Ãá= ÃáS ÃáS ÃáS Ãá0) ‚Üí‚àÄv2‚àÄv3‚àÄv4( ÃáEv2v1 Ãá+ ÃáEv3v1
Ã∏Ãá=
ÃáEv4v1))
in the language ‚Ñíasserts Fermat‚Äôs last theorem: ‚ÄúFor all v1 ‚â•3, the equation vv1
2 +vv1
3 = vv1
4
has no solutions.‚Äù
Exercises 3.1.
1. Prove that every ‚Ñí-term cannot have a variable or constant symbol as a proper
initial segment.
2. Prove Theorem 3.1.11.
3. Let ‚Ñíbe a language. Prove that every wff has an even number of parentheses.
4. Let t1, t2, . . . , tn be ‚Ñí-terms, where n > 1. Show that t1t2 ‚ãÖ‚ãÖ‚ãÖtn is not an ‚Ñí-term.
5. Let ‚Ñíbe a language and let Œ±1, Œ±2, . . . , Œ±n be wffs, where n > 1. Show that Œ±1Œ±2 ‚ãÖ‚ãÖ‚ãÖŒ±n
is not a wff.
6. Let ‚Ñíbe a language and let Œ±1, Œ±2, . . . , Œ±n, Œ≤1, Œ≤2, . . . , Œ≤n be wffs, where n ‚â•1. Show
that if Œ±1Œ±2 ‚ãÖ‚ãÖ‚ãÖŒ±n = Œ≤1Œ≤2 ‚ãÖ‚ãÖ‚ãÖŒ≤n, then Œ±i = Œ≤i for all i ‚â§n.

3.1 First-order languages
‡±™
65
7. Let ‚Ñíbe a language and let Œ±1, Œ±2, . . . , Œ±k, Œ≤1, Œ≤2, . . . , Œ≤n be wffs, where 1 ‚â§k < n.
Show that Œ±1Œ±2 ‚ãÖ‚ãÖ‚ãÖŒ±k
Ã∏= Œ≤1Œ≤2 ‚ãÖ‚ãÖ‚ãÖŒ≤n.
8. Let ‚Ñíbe a language and let Œ±1, Œ±2, . . . , Œ±n, Œ≤1, Œ≤2, . . . , Œ≤m be wffs, where n, m ‚â•1. Show
that if Œ±1Œ±2 ‚ãÖ‚ãÖ‚ãÖŒ±n = Œ≤1Œ≤2 ‚ãÖ‚ãÖ‚ãÖŒ≤m, then m = n and Œ±i = Œ≤i for all i ‚â§n.
9. In the proof of Theorem 3.1.15, complete the proof of the inductive step by estab-
lishing cases (1) and (3).
10. Let ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} be as in Example 3.1.22.
(a) Construct one term using all of the function symbols ÃáS, Ãá√ó, and Ãá+.
(b) Construct one term using all of the function symbols ÃáS, Ãá+, Ãá√ó, and ÃáE.
(c) Using only your terms in (a) and (b), give an example of an atomic formula.
*11. Let ‚Ñíbe a language and let ùíØbe the set of all the variables and constant symbols.
Let ùíØbe the set of the terms of ‚Ñí. Let x ‚ààùíØbe a variable and let t ‚ààùíØ. Define
h: ùíØ‚ÜíùíØby
h(v) = {t,
if v = x,
v,
if v
Ã∏= x.
(3.5)
By Theorems 3.1.9 and 1.1.27, there is a unique function h: ùíØ‚ÜíùíØsuch that:
(1) h(v) = h(v) for each v ‚ààùíØ;
(2) h(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn) = f h(t1)h(t2) ‚ãÖ‚ãÖ‚ãÖh(tn) for each n-place function symbol f and terms
t1, t2, . . . , tn.
For all œÑ ‚ààùíØ, let œÑx
t = h(œÑ). Prove by induction on terms that for all terms œÑ, œÑx
t is
the term obtained by replacing all occurrences of x in œÑ with t.
12. Let ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} be as in Example 3.1.22. For each of the following wffs,
find the free variables, if any:
(a) x Ãá< ÃáS ÃáS Ãá0,
(b)
Ãá0 Ãá< ÃáS ÃáS Ãá0,
(c) x Ãá< ÃáS ÃáSy,
(d) x Ãá= ÃáS Ãá0 ‚à®y Ãá= Ãá0,
(e) ‚àÄx(x Ãá< ÃáS ÃáS Ãá0) ‚Üí(x Ãá= ÃáS Ãá0 ‚à®x Ãá= Ãá0),
(f) ‚àÄx(x Ãá< ÃáS ÃáS Ãá0 ‚Üí(x Ãá= ÃáS Ãá0 ‚à®x Ãá= Ãá0)).
Which of these wffs are sentences?
13. Eliminate all of the abbreviations and obtain the unabbreviated version of the fol-
lowing wffs, where P, H, C, D are 1-place predicate symbols:
(a) ‚àÉv1Pv1 ‚à®Pv1,
(b) ‚àÄv1Pv1 ‚àßHv1 ‚Üí‚àÉv2¬¨Cv2 ‚à®Dv2.
14. Prove Theorem 3.1.16.
15. Let ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} be as in Example 3.1.22. Write wffs that express each of
the following:
(a) ‚Äúv5 is even,‚Äù
(b) ‚Äúv5 is odd,‚Äù

66
‡±™
3 First-order logic
(c) ‚Äúv5 is a prime number,‚Äù
(d) ‚Äúthere is no largest even number,‚Äù
(e) ‚Äúv1 is a perfect square,‚Äù
(f) ‚Äúevery natural number is the sum of four perfect squares.‚Äù
16. Let ‚Ñí= {P, c}, where P is a 3-place predicate symbol and c is a constant symbol.
Using the induction on wffs principle, prove that for every wff Œ±, the number of
symbols n (counting repetitions and parentheses) in Œ± can be written as a linear
combination of 2 and 3, that is, n = 2a + 3b, where a and b are integers. (Note:
abbreviations are not allowed and a variable vi is counted as one symbol.)
Exercise Notes: For Exercise 1, use induction on terms. For Exercise 2, no induction is
required. Read the inductive step of the proof of Theorem 3.1.15. For Exercise 7, use proof
by contradiction and then conclude that Œ±k = Œ≤kŒ≤k+1 ‚ãÖ‚ãÖ‚ãÖŒ≤n.
3.2 Truth and structures
In Section 3.1, we investigated the syntax of first-order languages. This syntax involves
certain rules of grammar that dictate the correct formation of a wff. Semantics, on the
other hand, involves giving meaning to these logical formulas. In this section, we will
pursue the semantics of these languages and attach meaning to their wffs. This involves
the definition of a structure which interprets the parameters of the language. To define
the concept of a wff being ‚Äútrue‚Äù in such a structure requires a precise mathematical
definition. This formidable definition is due to Alfred Tarski and formalizes the intuitive
meanings of the logical connectives and the quantifiers. Because of its mathematical
precision, Tarski‚Äôs semantic conception of truth is often said to be the best formulation
of truth in a structure.
3.2.1 Structures for first-order languages
In order to determine the truth value of a wff that contains quantified variables, we must
investigate structures in which one can deal with the possible values that the variables
may possess. Structures will also address the following questions:
‚Äì
What are the objects that the universal quantifier ‚àÄrefers to?
‚Äì
What objects do the constant, function, and predicate symbols represent?
Given a language of the form
‚Ñí= {P1, P2, . . . , c1, c2, . . . , f1, f2, . . . , Ãá=},
a structure A for the language ‚Ñí, or an ‚Ñí-structure, is a sequence of the form

3.2 Truth and structures
‡±™
67
A = ‚ü®A; PA
1 , PA
2 , . . . , cA
1 , cA
2 , . . . , f A
1 , f A
2 , . . . ‚ü©
such that:
1.
The set A is nonempty and is called the domain of A. The set A is sometimes denoted
by |A|.
2.
A assigns to each n-place predicate symbol P an n-place relation PA ‚äÜAn.
3.
A assigns to each constant symbol c a member cA of the universe A.
4.
A assigns to each n-place function symbol f an n-place function f A: An ‚ÜíA.
5.
The equality symbol Ãá= will always be interpreted as ‚Äúequality.‚Äù
The idea is that A assigns meaning to each of the parameters of the language ‚Ñí. The
quantifier ‚àÄis to mean ‚Äúfor every element in A.‚Äù The symbol c is the name of an element
cA in A. Each atomic formula Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn is to be interpreted as asserting that the n-tuple
of elements in A, named by t1, . . . , tn, is in the relation PA. Each term of the form ft1t2 ‚ãÖ‚ãÖ‚ãÖtn
can be interpreted as being the value of the function f A: An ‚ÜíA when applied to the
elements in A which are named by t1, . . . , tn.
Example 3.2.1 (Groups). Consider the language ‚Ñí= {e, ‚àó, Ãá=} of groups discussed in Ex-
ample 3.1.19. A structure for this language is A = ‚ü®‚Ñö+; eA, ‚àóA‚ü©, where ‚Ñö+ is the set
of all positive rational numbers, eA = 1, and ‚àóA is the usual multiplication of rational
numbers. This structure is a group as it satisfies the following group axioms:
1.
‚àÄv1‚àÄv2‚àÄv3(v1 ‚àó(v2 ‚àóv3) Ãá= (v1 ‚àóv2) ‚àóv3),
(associativity)
2.
‚àÄv1(v1 ‚àóe Ãá= v1),
(identity element)
3.
‚àÄv1‚àÉv2(v1 ‚àóv2 Ãá= e).
(inverses exists)
Example 3.2.2 (Set theory). Let ‚Ñí= { Ãá‚àà, Ãá=} be the language of set theory presented in
Example 3.1.20. A structure for this language is A = ‚ü®‚Ñï; ‚ààA‚ü©, where
Ãá‚ààA = {‚ü®m, n‚ü©: m < n and m, n ‚àà‚Ñï}.
The structure A satisfies the sentence ‚àÄv1‚àÉv2(v1 Ãá‚ààv2), as for every v1 ‚àà‚Ñïthere is a v2 ‚àà‚Ñï
such that v1 < v2.
Example 3.2.3. Consider the language ‚Ñí= {L, f , c}, where L is a 2-place predicate sym-
bol, f is a 1-place function symbol, and c is a constant symbol. Now let A be the structure
A = ‚ü®‚Ñï; LA, f A, cA‚ü©, where:
(a) A = ‚Ñï,
(b) LA is the set of pairs ‚ü®m, n‚ü©such that m < n,
(c) f A = S is the successor function S(n) = n + 1,
(d) cA = 0 is the natural number zero.
The sentence ‚àÄxLxfx is true in the structure A, because n < n + 1 for all n ‚àà‚Ñï.

68
‡±™
3 First-order logic
In the above examples, we have used the ambiguous notions that ‚ÄúA satisfies œÜ‚Äù
or that ‚ÄúœÜ is true in A,‚Äù where œÜ is a sentence of the language. Is the concept of being
true in a structure so vague that one cannot hope to give an accurate formalization of
this concept? That is, can one give a precise mathematical definition for the concept of
a formula being ‚Äútrue in a structure‚Äù?
In 1933, the mathematician Alfred Tarski published a paper in which he discussed
the conditions that a definition for a ‚Äútrue sentence‚Äù should satisfy. In 1956, he and his
colleague Robert Vaught at UC Berkeley published a revised version of this paper to serve
as a definition of truth in a structure for first-order languages. In the next section, we
shall present Tarski‚Äôs definition of truth.
3.2.2 Satisfaction (Tarski‚Äôs definition)
We will define a satisfaction relation between a structure and wffs. Let A be a structure
for a language ‚Ñíwith domain A. The satisfaction relation between A and a wff will be
defined by means of the following ordered steps:
(a) We first assign each variable in ‚Ñíto an element in A.
(b) Using the assignment in (a), we assign each term in ‚Ñíto an element in A.
(c) Using the assignment in (b), we define the satisfaction relation on the wffs.
Definition 3.2.4. Let A be an ‚Ñí-structure with domain A. Let V be the set of all the vari-
ables of ‚Ñí. A function ŒΩ: V ‚ÜíA is called a variable assignment. Now let ùíØbe the set of
all the variables and constant symbols in ‚Ñí. Given a variable assignment ŒΩ, we shall call
the function s: ùíØ‚ÜíA defined by
s(v) = {ŒΩ(vi),
if v = vi, a variable,
cA,
if v = c, a constant symbol,
(3.6)
an assignment.
Let A be a structure for a language ‚Ñí, with domain A. Let s: ùíØ‚ÜíA be an assignment
as defined in (3.6). Let ‚Ñ±= {‚Ñ∞f : is a function symbol in ‚Ñí} (see (3.1)). Theorem 3.1.9
implies that ùíØis the set of all the terms and is freely generated from ùíØby the functions
in ‚Ñ±. For each function ‚Ñ∞f in ‚Ñ±, we also have the corresponding function f A assigned
by the structure A. Theorem 1.1.27 now implies the following result.
Theorem 3.2.5. Let A be an ‚Ñí-structure with domain A and let s: ùíØ‚ÜíA be an assign-
ment. Then there is a unique function s: ùíØ‚ÜíA satisfying the following:
(1) s(v) = s(v) for each variable v;
(2) s(c) = cA for each constant symbol c;
(3) s(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn) = f A(s(t1), s(t2), . . . , s(tn)) for each n-place function symbol f and terms
t1, t2, . . . , tn.

3.2 Truth and structures
‡±™
69
Theorem 3.2.5 shows that for any given assignment s, the extension s assigns all of
the terms in ‚Ñíto elements in A. So each term t in ‚Ñícan be viewed as a name for the
element s(t) in A.
As we will see, a wff is satisfiable in a structure if it holds under some assignment
of its variables. In the definition below, the satisfaction relation is first defined on the
atomic formulas. The atomic formulas are the building blocks for constructing all of
the wffs. Then we define the satisfaction relation by recursion on the more complicated
formulas which are built from the building blocks using ¬¨, ‚Üí, and ‚àÄ. The validity of this
recursive definition follows from Theorems 1.1.27 and 3.1.16, as will be shown.
Definition 3.2.6 (Tarski‚Äôs definition). Let ‚Ñíbe a language and let A be an ‚Ñí-structure. We
define the relation A Û≥ÄÄÛ≥®êœÜ[s], for all assignments s and all formulas œÜ, by recursion as
follows:
(1) A Û≥ÄÄÛ≥®êÃá=t1t2[s] iff s(t1) = s(t2), for terms t1 and t2;
(2) A Û≥ÄÄÛ≥®êPt1 ‚ãÖ‚ãÖ‚ãÖtn[s] iff ‚ü®s(t1), . . . , s(tn)‚ü©‚ààPA, for atomic formulas Pt1 ‚ãÖ‚ãÖ‚ãÖtn;
(3) A Û≥ÄÄÛ≥®ê(¬¨œÜ)[s] iff A
Ã∏Û≥ÄÄÛ≥®êœÜ[s];
(4) A Û≥ÄÄÛ≥®ê(œÜ ‚Üíœà)[s] iff (if A Û≥ÄÄÛ≥®êœÜ[s], then A Û≥ÄÄÛ≥®êœà[s]);
(5) A Û≥ÄÄÛ≥®ê‚àÄvœÜ[s] iff for all d ‚ààA, A Û≥ÄÄÛ≥®êœÜ[sv|d].
In (5), the assignment sv|d is exactly like s except at the variable v, where sv|d(v) = d, that
is,
sv|d(v‚Ä≤) = {s(v‚Ä≤),
if v‚Ä≤
Ã∏= v,
d,
if v‚Ä≤ = v.
(3.7)
Example 3.2.7. Let ‚Ñí= {L, f , c} and let A = ‚ü®‚Ñï; LA, f A, cA‚ü©be the structure for this
language as defined in Example 3.2.3, that is,
(a) A = ‚Ñï,
(b) LA is the set of pairs ‚ü®m, n‚ü©such that m < n,
(c) f A = S is the successor function S(n) = n + 1,
(d) cA = 0 is the natural number zero.
Let ùíØbe the set of all the variables and constant symbols and let s: ùíØ‚Üí‚Ñïbe the
assignment satisfying (Û≥µ≥) s(vi) = i ‚àí1 for i = 1, 2, . . . . So s(v1) = 0, s(v2) = 1. Thus,
(1) s(c) = 0, by Theorem 3.2.5(2);
(1) s(ffc) = f A(s(fc)) = f A(f A(s(c))) = S(S(0)) = 2, by Theorem 3.2.5(3) and (c);
(2) s(ffv3) = S(S(2)) = 4 and s(fv6) = S(5) = 6, by Theorem 3.2.5(3) and (c);
(3) A Û≥ÄÄÛ≥®êLcfv6[s], because ‚ü®s(c), s(fv6)‚ü©= ‚ü®0, 6‚ü©‚ààLA, by Definition 3.2.6(2);
(4) A Û≥ÄÄÛ≥®ê‚àÄv2Lcfv2[s], because

70
‡±™
3 First-order logic
A Û≥ÄÄÛ≥®ê‚àÄv2Lcfv2[s]
iff
for all n ‚àà‚Ñï, A Û≥ÄÄÛ≥®êLcfv2[sv2|n],
Definition 3.2.6(5)
iff
for all n ‚àà‚Ñï, ‚ü®sv2|n(c), sv2|n(fv2)‚ü©‚ààLA,
Definition 3.2.6(2)
iff
for all n ‚àà‚Ñï, ‚ü®0, f A(sv2|n(v2))‚ü©‚ààLA,
Theorem 3.2.5(2)(3)
iff
for all n ‚àà‚Ñï, ‚ü®0, f A(n)‚ü©‚ààLA,
by (3.7)
iff
for all n ‚àà‚Ñï, ‚ü®0, S(n)‚ü©‚ààLA,
since f A = S
iff
for all n ‚àà‚Ñï, ‚ü®0, n + 1‚ü©‚ààLA,
S(n) = n + 1
iff
for all n ‚àà‚Ñï, 0 < n + 1;
by (b)
thus, A Û≥ÄÄÛ≥®ê‚àÄv2Lcfv2[s] because it is true that for all n ‚àà‚Ñï, 0 < n + 1;
(5) A
Ã∏Û≥ÄÄÛ≥®ê‚àÄv2Lv3fv2[s]; otherwise,
A Û≥ÄÄÛ≥®ê‚àÄv2Lv3fv2[s]
iff
for all n ‚àà‚Ñï, A Û≥ÄÄÛ≥®êLv3fv2[sv2|n],
Definition 3.2.6(5)
iff
for all n ‚àà‚Ñï, ‚ü®sv2|n(v3), sv2|n(fv2)‚ü©‚ààLA,
Definition 3.2.6(2)
iff
for all n ‚àà‚Ñï, ‚ü®2, sv2|n(fv2)‚ü©‚ààLA,
by (3.7) and (Û≥µ≥)
iff
for all n ‚àà‚Ñï, ‚ü®2, f A(sv2|n(v2))‚ü©‚ààLA,
Theorem 3.2.5(3)
iff
for all n ‚àà‚Ñï, ‚ü®2, f A(n)‚ü©‚ààLA,
by (3.7)
iff
for all n ‚àà‚Ñï, ‚ü®2, S(n)‚ü©‚ààLA,
as f A = S
iff
for all n ‚àà‚Ñï, ‚ü®2, n + 1‚ü©‚ààLA,
S(n) = n + 1
iff
for all n ‚àà‚Ñï, 2 < n + 1;
a falsehood
thus, A
Ã∏Û≥ÄÄÛ≥®ê‚àÄv2Lv3fv2[s], as 2
Ã∏< 0 + 1 and 0 ‚àà‚Ñï.
Remark 3.2.8 (Extended definition of satisfaction). The abbreviations presented in Sec-
tion 3.1.6 allow us to extend Definition 3.2.6. Let A be an ‚Ñí-structure. Then for all as-
signments s and all formulas Œ± and Œ≤, one can establish the following extension of Defi-
nition 3.2.6:
(1) A Û≥ÄÄÛ≥®êÃá=t1t2[s] iff s(t1) = s(t2), for terms t1 and t2;
(2) A Û≥ÄÄÛ≥®êPt1 ‚ãÖ‚ãÖ‚ãÖtn[s] iff ‚ü®s(t1), . . . , s(tn)‚ü©‚ààPA, for atomic formulas Pt1 ‚ãÖ‚ãÖ‚ãÖtn;
(3) A Û≥ÄÄÛ≥®ê(¬¨Œ±)[s] iff A
Ã∏Û≥ÄÄÛ≥®êŒ±[s];
(4) A Û≥ÄÄÛ≥®ê(Œ± ‚àßŒ≤)[s] iff (A Û≥ÄÄÛ≥®êŒ±[s] and A Û≥ÄÄÛ≥®êŒ≤[s]);
(5) A Û≥ÄÄÛ≥®ê(Œ± ‚à®Œ≤)[s] iff (A Û≥ÄÄÛ≥®êŒ±[s] or A Û≥ÄÄÛ≥®êŒ≤[s]);
(6) A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[s] iff (if A Û≥ÄÄÛ≥®êŒ±[s], then A Û≥ÄÄÛ≥®êŒ≤[s]);
(7) A Û≥ÄÄÛ≥®ê(Œ± ‚ÜîŒ≤)[s] iff (A Û≥ÄÄÛ≥®êŒ±[s] iff A Û≥ÄÄÛ≥®êŒ≤[s]);
(8) A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s] iff for all d ‚ààA, A Û≥ÄÄÛ≥®êŒ±[sv|d];
(9) A Û≥ÄÄÛ≥®ê‚àÉvŒ±[s] iff for some d ‚ààA, A Û≥ÄÄÛ≥®êŒ±[sv|d].
When applying Remark 3.2.8 on a wff with multiple quantifiers, note the next re-
mark.

3.2 Truth and structures
‡±™
71
Remark 3.2.9. Let A be an ‚Ñí-structure and let s: ùíØ‚ÜíA be an assignment, where ùíØis
the set of the variables and constant symbols in ‚Ñí. For a variable v and d ‚ààA, recall that
the function sv|d is exactly like s, except at v, where sv|d(v) = d, that is,
sv|d(v‚Ä≤) = {s(v‚Ä≤),
if v‚Ä≤
Ã∏= v,
d,
if v‚Ä≤ = v.
Let x be a variable where x
Ã∏= v and let e ‚ààA. Then, the function (sv|d)x|e is exactly like s,
except at the variables v and x, where
(sv|d)x|e(v) = d
and
(sv|d)x|e(x) = e.
Observe that
(sv|d)x|e = (sx|e)v|d.
(3.8)
On the other hand, one can show that (sv|d)v|e = sv|e and (sx|e)x|d = sx|d.
We end this section by showing, as promised, that Definition 3.2.6 is an application
of Theorems 1.1.27 and 3.1.16. Let A be an ‚Ñí-structure with domain A. Let ùíÆbe the set of
all the atomic formulas of ‚Ñí, let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚Üí, ‚Ñ∞Q1, ‚Ñ∞Q2, . . . } (see (3.4)), and let ùíÆbe the set
generated from ùíÆby the functions in ‚Ñ±. By Theorem 3.1.16, we know that ùíÆis the set of
all the wffs and that ùíÆis freely generated from the set ùíÆby the functions in ‚Ñ±. Let U be
the set of all assignments and let ùí∞be the set of all subsets of U. For each function in ‚Ñ±
we define the associated functions F¬¨: ùí∞‚Üíùí∞, F‚Üí: ùí∞2 ‚Üíùí∞, FQi: ùí∞‚Üíùí∞(for each i ‚â•1)
as follows:
F¬¨(a) = U \ a,
F‚Üí(a, b) = (U \ a) ‚à™b,
FQi(a) = {s ‚ààU : for all d ‚ààA, svi|d ‚ààa}.
Now define h: ùíÆ‚Üíùí∞by
h( Ãá=t1t2) = {s ‚ààU : s(t1) = s(t2)},
h(Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn) = {s ‚ààU : ‚ü®s(t1), . . . , s(tn)‚ü©‚ààPA},
for each atomic formula Ãá=t1t2 and Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn. Theorems 1.1.27 and 3.1.16 now imply that
there is a unique function h: ùíÆ‚Üíùí∞such that:
(1) h(Œ±) = h(Œ±) if Œ± is an atomic formula,
(2) h((¬¨Œ±)) = U \ h(Œ±),
(3) h((Œ± ‚ÜíŒ≤)) = (U \ h(Œ±)) ‚à™h(Œ≤),
(4) h(‚àÄviŒ±) = {s ‚ààU : for all d ‚ààA, svi|d ‚ààh(Œ±)}.

72
‡±™
3 First-order logic
Define the relation A Û≥ÄÄÛ≥®êœÜ[s] between œÜ and s by
A Û≥ÄÄÛ≥®êœÜ[s]
if and only if
s ‚ààh(œÜ)
(3.9)
for all wffs œÜ and all assignments s. Using (3.9) and conditions (1)‚Äì(4), one can show that
the relation A Û≥ÄÄÛ≥®êœÜ[s] satisfies Definition 3.2.6.
Satisfaction relation for sentences
A sentence in a first-order language has no free variables. So given a structure for this
language, one may suspect that if a sentence is true in the structure, then its truth should
be independent of any assignment to the variables in the language. Our focus in this
section is on addressing this suspicion. First we must show that if two assignments agree
on all of the variables in a term, then the two assignments will assign the term to the
same element in the domain of the structure.
Lemma 3.2.10. Let A be a structure for a language ‚Ñí. Suppose that s and s‚Ä≤ are assign-
ments that agree on all of the variables in a term t. Then s(t) = s‚Ä≤(t), where s‚Ä≤ = s‚Ä≤.
Proof. We prove the following statement by induction on terms: Whenever assign-
ments s and s‚Ä≤ agree on all of the variables in a term t, then s(t) = s‚Ä≤(t).
Base step: Let c and v be a constant and a variable, respectively, of the language ‚Ñí.
Clearly, s(c) = s‚Ä≤(c) by the definition of s and s‚Ä≤, for any two assignments s and s‚Ä≤. If
s and s‚Ä≤ agree on the variables in v, then s(v) = s‚Ä≤(v), and thus s(v) = s‚Ä≤(v).
Inductive step: Let f be an arbitrary n-place function symbol in ‚Ñíand let t1, t2, . . . , tn be
arbitrary terms. Assume the induction hypothesis
For each i ‚â§n, if s and s‚Ä≤ agree on the variables in ti, then s(ti) = s‚Ä≤(ti).
(IH)
We must prove that the same holds for the term ft1t2 ‚ãÖ‚ãÖ‚ãÖtn. Let s and s‚Ä≤ be assignments
that agree on the variables in ft1t2 ‚ãÖ‚ãÖ‚ãÖtn. Then for each i ‚â§n s and s‚Ä≤ agree on the vari-
ables in ti. Hence
s(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn) = f A(s(t1), s(t2), . . . , s(tn))
by Theorem 3.2.5(3),
= f A(s‚Ä≤(t1), s‚Ä≤(t2), . . . , s‚Ä≤(tn))
by (IH),
= s‚Ä≤(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn)
by Theorem 3.2.5(3).
We can now extend Lemma 3.2.10 to formulas as well.
Theorem 3.2.11. Let A be an ‚Ñí-structure. For all assignments s and s‚Ä≤ that agree on all
of the free variables in the wff œÜ, we have
A Û≥ÄÄÛ≥®êœÜ[s]
if and only if
A Û≥ÄÄÛ≥®êœÜ[s‚Ä≤].

3.2 Truth and structures
‡±™
73
Proof. We prove the following statement by induction on wffs: If assignments s and s‚Ä≤
agree on all of the free variables in œÜ, then A Û≥ÄÄÛ≥®êœÜ[s] if and only if A Û≥ÄÄÛ≥®êœÜ[s‚Ä≤].
Base step: Let œï = Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn be an atomic formula and let s and s‚Ä≤ be assignments that
agree on all of the free variables in Pt1 ‚ãÖ‚ãÖ‚ãÖtn. Hence, s and s‚Ä≤ agree on all of the free
variables in t1, . . . , tn. Thus,
A Û≥ÄÄÛ≥®êPt1t2 ‚ãÖ‚ãÖ‚ãÖtn[s]
iff
‚ü®s(t1), . . . , s(tn)‚ü©‚ààPA
by Definition 3.2.6(2),
iff
‚ü®s‚Ä≤(t1), . . . , s‚Ä≤(tn)‚ü©‚ààPA
by Lemma 3.2.10,
iff
A Û≥ÄÄÛ≥®êPt1t2 ‚ãÖ‚ãÖ‚ãÖtn[s‚Ä≤]
by Definition 3.2.6(2).
Therefore, the proof of the base step is complete.
Inductive step: Let Œ± and Œ≤ be arbitrary wffs. Assume the induction hypothesis
A Û≥ÄÄÛ≥®êŒ±[s]
iff
A Û≥ÄÄÛ≥®êŒ±[s‚Ä≤],
A Û≥ÄÄÛ≥®êŒ≤[s]
iff
A Û≥ÄÄÛ≥®êŒ≤[s‚Ä≤],
(IH)
for all assignments s and s‚Ä≤ that agree on the free variables in the formulas Œ± and Œ≤,
respectively. We must prove that the same holds for each of the following:
(¬¨Œ±), (Œ± ‚ÜíŒ≤), ‚àÄvŒ±.
Case (¬¨Œ±): Let s and s‚Ä≤ be assignments that agree on all of the free variables in (¬¨Œ±). It
follows that s and s‚Ä≤ agree on all of the free variables in Œ±. Therefore, the first part of the
induction hypothesis (IH) holds. Hence
A Û≥ÄÄÛ≥®ê(¬¨Œ±)[s]
iff
A
Ã∏Û≥ÄÄÛ≥®êŒ±[s]
by Definition 3.2.6(3),
iff
A
Ã∏Û≥ÄÄÛ≥®êŒ±[s‚Ä≤]
by (IH),
iff
A Û≥ÄÄÛ≥®ê(¬¨Œ±)[s‚Ä≤]
by Definition 3.2.6(3).
Case (Œ± ‚ÜíŒ≤): Let s and s‚Ä≤ be assignments that agree on all of the free variables in the
wff (Œ± ‚ÜíŒ≤). It follows that s and s‚Ä≤ agree on all of the free variables in both Œ± and Œ≤.
Therefore, the induction hypothesis (IH) holds. Hence
A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[s]
iff
A Û≥ÄÄÛ≥®êŒ±[s] implies A Û≥ÄÄÛ≥®êŒ≤[s]
by Definition 3.2.6(4),
iff
A Û≥ÄÄÛ≥®êŒ±[s‚Ä≤] implies A Û≥ÄÄÛ≥®êŒ≤[s‚Ä≤]
by (IH),
iff
A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[s‚Ä≤]
by Definition 3.2.6(4).
Case ‚àÄvŒ±: Let s and s‚Ä≤ be assignments that agree on all of the free variables in ‚àÄvŒ±. Since
v is not free in ‚àÄvŒ±, it does not follow that s and s‚Ä≤ agree on the variable v. However, for
any d ‚ààA, it does follow that sv|d and s‚Ä≤
v|d agree on v and hence on all the variables in

74
‡±™
3 First-order logic
Œ±. Thus, the induction hypothesis (IH) implies that A Û≥ÄÄÛ≥®êŒ±[sv|d] if and only if A Û≥ÄÄÛ≥®êŒ±[s‚Ä≤
v|d],
for any d ‚ààA. Therefore,
A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s]
iff
for every d ‚ààA, A Û≥ÄÄÛ≥®êœÜ[sv|d]
by Definition 3.2.6(5),
iff
for every d ‚ààA, A Û≥ÄÄÛ≥®êœÜ[s‚Ä≤
v|d]
by (IH),
iff
A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s‚Ä≤]
by Definition 3.2.6(5).
The following corollary shows that for a sentence œÜ, the truth or falsity of A Û≥ÄÄÛ≥®êœÜ[s]
is independent of the assignment s. Thus, we can write A Û≥ÄÄÛ≥®êœÜ if for some (hence every)
assignment s, we have A Û≥ÄÄÛ≥®êœÜ[s].
Corollary 3.2.12. Let A be a structure for a language ‚Ñí. Let œÜ be a sentence. Then
A Û≥ÄÄÛ≥®êœÜ[s] for every assignment s if and only if A Û≥ÄÄÛ≥®êœÜ[s‚Ä≤] for some assignment s‚Ä≤.
Proof. Let A be a structure for a language ‚Ñíwith domain A. Let œÜ be any sentence.
(‚áí). Assume that A Û≥ÄÄÛ≥®êœÜ[s] for every assignment s. Then (since A is nonempty) it
follows that A Û≥ÄÄÛ≥®êœÜ[s‚Ä≤] for some assignment s‚Ä≤.
(‚áê). Assume that A Û≥ÄÄÛ≥®êœÜ[s‚Ä≤] for some assignment s‚Ä≤. We shall show that A Û≥ÄÄÛ≥®êœÜ[s] for
every assignment s. Let s be an arbitrary assignment. Since œÜ is a sentence, it has no free
variables. Thus, s and s‚Ä≤ agree on all the free variables in œÜ. Theorem 3.2.11 now implies
that A Û≥ÄÄÛ≥®êœÜ[s].
Corollary 3.2.12 supports our next definition.
Definition 3.2.13. Let A be an ‚Ñí-structure. Let œÜ be any sentence. We shall say that œÜ is
true in A or that A is a model of œÜ, denoted by A Û≥ÄÄÛ≥®êœÜ, if for some (or every) assignment s,
we have A Û≥ÄÄÛ≥®êœÜ[s]. In addition, let Œ£ be a set of sentences. We shall say that A is a model
of Œ£ if A Û≥ÄÄÛ≥®êœÜ for all œÜ in Œ£.
Example 3.2.14. Let ‚Ñí= { Ãá0, Ãá1, Ãá+, Ãá√ó, Ãá=} be the language having equality, two 2-place func-
tion symbols Ãá+ and Ãá√ó, and two constant symbols Ãá0, Ãá1. Now consider the two structures
R = ‚ü®‚Ñù; 0, 1, +, √ó‚ü©and Q = ‚ü®‚Ñö; 0, 1, +, √ó‚ü©, where + and √ó are the standard addition and
multiplication operations. Find a sentence œÜ in the language ‚Ñíthat is true in one of these
structures but false in the other.
Solution. Let œÜ be the sentence ‚àÉv(v Ãá√ó v = Ãá1 Ãá+ Ãá1). Then R Û≥ÄÄÛ≥®êœÜ since ‚àö2 ‚àà‚Ñù. However,
Q
Ã∏Û≥ÄÄÛ≥®êœÜ because ‚àö2 ‚àâ‚Ñö.
3.2.3 Logical implication
Logical implication is a truth preserving relation between a given set of premises and
a conclusion; namely, whenever the premises are all true, the conclusion is true. The
definition of logical implication in first-order logic is very similar to the definition of

3.2 Truth and structures
‡±™
75
tautological implication in propositional logic (see Definition 2.2.10). However, the fol-
lowing definition of logical implication is more complicated than that of tautological
implication, in part because Tarski‚Äôs definition of satisfaction is complex.
For the duration of this section, let ‚Ñíbe a given language and let ùíØbe the set of all
the variables and constant symbols in ‚Ñí.
Definition 3.2.15. Let Œì be a set of wffs and let œÜ be a wff. Then Œì logically implies œÜ,
denoted by Œì Û≥ÄÄÛ≥®êœÜ, if and only if for every structure A and every assignment s: ùíØ‚ÜíA, if
A Û≥ÄÄÛ≥®êŒ±[s] for every Œ± in Œì, then A Û≥ÄÄÛ≥®êœÜ[s].
Remark 3.2.16. Some special cases concerning Definition 3.2.15 deserve mention.
(a) If Œì is the empty set ‚åÄ, then every structure models Œì.
(b) It follows from (a) that ‚åÄÛ≥ÄÄÛ≥®êœÜ if and only if A Û≥ÄÄÛ≥®êœÜ[s] for every structure A and every
assignment s.
(c) If there is no structure and assignment that will satisfy all of the wffs in Œì, then it is
vacuously true that Œì Û≥ÄÄÛ≥®êœÜ, for any œÜ.
(d) If Œì is a singleton {Œ≥}, then we write Œ≥ Û≥ÄÄÛ≥®êœÜ in place of {Œ≥} Û≥ÄÄÛ≥®êœÜ.
Definition 3.2.17. Let œÜ be a wff. Then œÜ is logically valid (written as Û≥ÄÄÛ≥®êœÜ) if and only if
for every structure A and every assignment s: ùíØ‚ÜíA, we have A Û≥ÄÄÛ≥®êœÜ[s].
Definition 3.2.18. Two wffs œÜ and œà are logically equivalent (denoted by œÜ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œà) if œÜ Û≥ÄÄÛ≥®êœà
and œà Û≥ÄÄÛ≥®êœÜ.
Corollary 3.2.12 implies that for sentences, Definition 3.2.15 does not depend on the
assignments. So logical implication can be stated more concisely for sentences.
Corollary 3.2.19. Let Œ£ be a set of sentences and let œà be a sentence. Then:
1.
Œ£ Û≥ÄÄÛ≥®êœà if and only if every model of Œ£ is also a model of œà;
2.
œà is logically valid if and only if œà is true in every structure.
Example 3.2.20. Let ‚Ñí= {Q, P}, where Q is a 1-place predicate symbol and P is a 2-place
predicate symbol. Show that the following hold:
1.
‚àÄv1Qv1 Û≥ÄÄÛ≥®êQv2,
2.
Qv1
Ã∏Û≥ÄÄÛ≥®ê‚àÄv1Qv1,
3.
Û≥ÄÄÛ≥®ê¬¨¬¨Œ± ‚ÜíŒ±,
4.
‚àÄv1Qv1 Û≥ÄÄÛ≥®ê‚àÉv2Qv2,
5.
‚àÉx‚àÄyPxy Û≥ÄÄÛ≥®ê‚àÄy‚àÉxPxy,
6.
‚àÄy‚àÉxPxy
Ã∏Û≥ÄÄÛ≥®ê‚àÉx‚àÄyPxy,
7.
Û≥ÄÄÛ≥®ê‚àÉx(Qx ‚Üí‚àÄyQy).
Solution. We will show why items 1‚Äì7 hold.
1.
To show ‚àÄv1Qv1 Û≥ÄÄÛ≥®êQv2, let A be an ‚Ñí-structure with assignment s: ùíØ‚ÜíA such that
A Û≥ÄÄÛ≥®ê‚àÄv1Qv1[s]. We must show that A Û≥ÄÄÛ≥®êQv2[s], that is, we must show that s(v2) ‚ààQA.

76
‡±™
3 First-order logic
Let d = s(v2). Since A Û≥ÄÄÛ≥®ê‚àÄv1Qv1[s], it follows that A Û≥ÄÄÛ≥®êQv1[sv1|d]. Thus, sv1|d(v1) ‚ààQA,
so d ‚ààQA. Therefore, s(v2) ‚ààQA.
2.
To show Qv1
Ã∏Û≥ÄÄÛ≥®ê‚àÄv1Qv1, we must find a structure A and an assignment s: ùíØ‚ÜíA
such that A Û≥ÄÄÛ≥®êQv1[s] and A
Ã∏Û≥ÄÄÛ≥®ê‚àÄv1Qv1[s]. Let A = {1, 2}, QA = {2}, PA = ‚åÄand let
A = ‚ü®A; QA, PA‚ü©. For an assignment s such that s(v1) = 2, one can now show that
A Û≥ÄÄÛ≥®êQv1[s] and A
Ã∏Û≥ÄÄÛ≥®ê‚àÄv1Qv1[s].
3.
To show Û≥ÄÄÛ≥®ê¬¨¬¨Œ± ‚ÜíŒ±, let A be an ‚Ñí-structure with assignment s: ùíØ‚ÜíA. Assume
that A Û≥ÄÄÛ≥®ê¬¨¬¨Œ±[s]. We must show that A Û≥ÄÄÛ≥®êŒ±[s]. Since A Û≥ÄÄÛ≥®ê¬¨¬¨Œ±[s], it follows that
A
Ã∏Û≥ÄÄÛ≥®ê¬¨Œ±[s] by Remark 3.2.8(3). Since A
Ã∏Û≥ÄÄÛ≥®ê¬¨Œ±[s], it follows that A Û≥ÄÄÛ≥®êŒ±[s], again by
Remark 3.2.8(3).
4.
To show ‚àÄv1Qv1 Û≥ÄÄÛ≥®ê‚àÉv2Qv2, let A be an ‚Ñí-structure with assignment s: ùíØ‚ÜíA. As-
sume that A Û≥ÄÄÛ≥®ê‚àÄv1Qv1[s]. We must show that A Û≥ÄÄÛ≥®ê‚àÉv2Qv2[s], that is, we must show
that for some d ‚ààA we have A Û≥ÄÄÛ≥®êQv2[sv2|d]. Since A Û≥ÄÄÛ≥®ê‚àÄv1Qv1[s], it follows that for
all d ‚ààA, A Û≥ÄÄÛ≥®êQv1[sv1|d]. Thus, because the universe of A is nonempty, there is a
d ‚ààA such that A Û≥ÄÄÛ≥®êQv1[sv1|d]. Hence, sv1|d(v1) = d ‚ààQA, so sv2|d(v2) = d ‚ààQA. We
conclude that A Û≥ÄÄÛ≥®ê‚àÉv2Qv2[s].
5.
To show ‚àÉx‚àÄyPxy Û≥ÄÄÛ≥®ê‚àÄy‚àÉxPxy, let A be an ‚Ñí-structure and let s: ùíØ‚ÜíA be such that
A Û≥ÄÄÛ≥®ê‚àÉx‚àÄyPxy[s]. By Remark 3.2.8(8)(9), there exists a d ‚ààA such that for all e ‚ààA,
we have A Û≥ÄÄÛ≥®êPxy[(sx|d)y|e] (see Remark 3.2.9). So, for all e ‚ààA, there is a d ‚ààA
such that A Û≥ÄÄÛ≥®êPxy[(sy|e)x|d] (see equation (3.8)). Therefore, by Remark 3.2.8(8)(9),
A Û≥ÄÄÛ≥®ê‚àÄy‚àÉxPxy[s].
6.
To show ‚àÄy‚àÉxPxy
Ã∏Û≥ÄÄÛ≥®ê‚àÉx‚àÄyPxy, we must find a structure A and s: ùíØ‚ÜíA such that
A Û≥ÄÄÛ≥®ê‚àÄy‚àÉxPxy[s] and A
Ã∏Û≥ÄÄÛ≥®ê‚àÉx‚àÄyPxy[s]. Let A = ‚Ñ§, PA = < (the standard less than
relation), QA = ‚åÄand let A = ‚ü®A; QA, PA‚ü©. For any assignment s, one can now
show that A Û≥ÄÄÛ≥®ê‚àÄy‚àÉxPxy[s] (because there is no largest integer) and A
Ã∏Û≥ÄÄÛ≥®ê‚àÉx‚àÄyPxy[s]
(because there is no smallest integer).
7.
To show that Û≥ÄÄÛ≥®ê‚àÉx(Qx ‚Üí‚àÄyQy), let A be an ‚Ñí-structure and let s: ùíØ‚ÜíA. We must
show that A Û≥ÄÄÛ≥®ê‚àÉx(Qx ‚Üí‚àÄyQy)[s]. There are two cases to consider.
Case (i): QA = A. Let d ‚ààA. As QA = A, we see that d ‚ààQA. So A Û≥ÄÄÛ≥®êQx[sx|d] and
A Û≥ÄÄÛ≥®ê‚àÄyQy[sx|d]. It thus follows that A Û≥ÄÄÛ≥®ê(Qx ‚Üí‚àÄyQy)[sx|d], by Remark 3.2.8(6).
Therefore, A Û≥ÄÄÛ≥®ê‚àÉx(Qx ‚Üí‚àÄyQy)[s], by Remark 3.2.8(9).
Case (ii): QA
Ã∏= A. Let d ‚ààA be such that d ‚àâQA. We see that A
Ã∏Û≥ÄÄÛ≥®êQx[sx|d]. It thus fol-
lows (vacuously) that if A Û≥ÄÄÛ≥®êQx[sx|d], then A Û≥ÄÄÛ≥®ê‚àÄyQy[s]. Hence, by Remark 3.2.8(6),
A Û≥ÄÄÛ≥®ê(Qx ‚Üí‚àÄyQy)[sx|d]. Therefore, A Û≥ÄÄÛ≥®ê‚àÉx(Qx ‚Üí‚àÄyQy)[s], by Remark 3.2.8(9).
3.2.4 Definability over a structure
Let A be an ‚Ñí-structure with universe A. Some subsets of A and relations on A can be
singled out by using a wff and the satisfaction relation. In this case, we can say that the
subset or relation is definable over A. This is an important concept that we will pursue
in this section. Theorem 3.2.11 justifies the following definition.

3.2 Truth and structures
‡±™
77
Definition 3.2.21. Let A be an ‚Ñí-structure and let œÜ be a wff having all of its free vari-
ables in the list v1, v2, . . . , vk. For all a1, a2, . . . , ak in A, the notation
A Û≥ÄÄÛ≥®êœÜ‚ü¶a1, a2, . . . , ak‚üß
means that for some (hence for any) assignment s: ùíØ‚ÜíA such that s(vi) = ai for each
i = 1, 2, . . . , k, we have A Û≥ÄÄÛ≥®êœÜ[s].
Example 3.2.22. Let ‚Ñí= {L, f , c} and let A be as in Example 3.2.7. Let œÜ be the wff
‚àÉv2Lfv2v1. Then A Û≥ÄÄÛ≥®êœÜ‚ü¶2‚üßand A
Ã∏Û≥ÄÄÛ≥®êœÜ‚ü¶1‚üß.
Let ‚Ñí= { Ãá0, Ãá1, Ãá+, Ãá√ó, Ãá=} be the language having equality, two 2-place function symbols
Ãá+ and Ãá√ó, and two constant symbols Ãá0, Ãá1. Let R = ‚ü®‚Ñù; 0, 1, +, √ó‚ü©be the structure, where
+ and √ó are the standard operations of addition and multiplication. The structure R is
called the real field. Note that for any a ‚àà‚Ñù, it follows that a ‚â•0 if and only if a = x2 for
some x ‚àà‚Ñù. This fact implies that there is a wff œÜ with a free variable such that
R Û≥ÄÄÛ≥®êœÜ‚ü¶a‚üß
iff
a ‚â•0.
Let œÜ be the wff ‚àÉx(v1 Ãá= x Ãá√ó x). Then
R Û≥ÄÄÛ≥®ê‚àÉx(v1 Ãá= x Ãá√ó x)‚ü¶a‚üß
iff
a ‚â•0.
For this reason, we shall say that the interval [0, ‚àû) is definable over R and that the
formula ‚àÉx(v1 Ãá= x Ãá√ó x) defines [0, ‚àû) in R.
Moreover, for any a, b ‚àà‚Ñù, a ‚â§b if and only if b = a + x2 for some x ‚àà‚Ñù. Thus, the
ordering relation ‚Äúless than or equal to‚Äù is also definable over the structure R, that is,
there is a wff œà with two free variables such that
R Û≥ÄÄÛ≥®êœà‚ü¶a, b‚üß
iff
a ‚â§b.
Let œà be the wff ‚àÉx(v2 Ãá= v1 Ãá+ x Ãá√ó x). Then
R Û≥ÄÄÛ≥®ê‚àÉx(v2 Ãá= v1 Ãá+ x Ãá√ó x)‚ü¶a, b‚üß
iff
a ‚â§b.
Thus, we can say that the relation {‚ü®a, b‚ü©‚àà‚Ñù√ó ‚Ñù| a ‚â§b} is definable over R and that
the formula ‚àÉx(v2 Ãá= v1 Ãá+ x Ãá√ó x) defines this relation in R.
We now give a precise description of the concept of definability over a structure.
Definition 3.2.23. Let A be an ‚Ñí-structure with domain A. Let œÜ be a wff having all of
its free variables in the list v1, v2, . . . , vk. Then the k-ary relation on A
{‚ü®a1, a2, . . . , ak‚ü©| A Û≥ÄÄÛ≥®êœÜ‚ü¶a1, a2, . . . , ak‚üß}
is definable over A and the formula œÜ defines this k-ary relation in A.

78
‡±™
3 First-order logic
Example 3.2.24 (Sublanguage of elementary number theory). Recall
the
language
of
number theory ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} in Example 3.1.4. Consider the sublanguage
‚Ñí‚Ä≤ = { Ãá0, ÃáS, Ãá+, Ãá√ó, Ãá=} of ‚Ñíand also the ‚Ñí‚Ä≤-structure ùí©= ‚ü®‚Ñï; 0, S, +, √ó‚ü©, where Ãá0ùí©= 0,
ÃáSùí©= S (successor function), and
Ãá+ùí©= +,
Ãá√óùí©= √ó are the standard operations of
addition and multiplication, respectively. We identify some subsets of ‚Ñïand relations
on ‚Ñïthat are definable over ùí©:
1.
Let m, n ‚àà‚Ñï. Clearly, m < n if and only if n = m + k for some k ‚àà‚Ñï, where k ‚â•1.
Moreover, k ‚â•1 when k = i + 1 for an i ‚àà‚Ñï. This allows us to now show that the
relation {‚ü®m, n‚ü©: m < n} is definable over ùí©. The formula
‚àÉv3(v2 Ãá= v1 Ãá+ ÃáSv3)
is such that
m < n
iff
ùí©Û≥ÄÄÛ≥®ê‚àÉv3(v2 Ãá= v1 Ãá+ ÃáSv3)‚ü¶m, n‚üß.
2.
For each n ‚àà‚Ñï, it follows that {n} is definable. For example, for the wff v1
Ãá= ÃáS ÃáS ÃáS Ãá0,
we see that {3} = {n : ùí©Û≥ÄÄÛ≥®êv1 Ãá= ÃáS ÃáS ÃáS Ãá0‚ü¶n‚üß}.
3.
The set of prime numbers is also definable over ùí©. Observe that p ‚àà‚Ñïis a prime
if and only if 1 < p and for all m, n ‚àà‚Ñï, if m ‚ãÖn = p, then m = 1 or n = 1. Let us
first try the following formula, where 1 is represented by ÃáS Ãá0, p is represented by the
variable v1, and v2 and v3 represent m and n, respectively. Thus, we obtain
ÃáS Ãá0 < v1 ‚àß‚àÄv2‚àÄv3(v2 Ãá√ó v3 Ãá= v1 ‚Üí(v2 Ãá= ÃáS Ãá0 ‚à®v3 Ãá= ÃáS Ãá0)).
As < is not part of the language ‚Ñí‚Ä≤, we must replace ÃáS Ãá0 < v1 with an appropriate
‚Ñí‚Ä≤-wff. By item 1, we have 1 < p if and only if ùí©Û≥ÄÄÛ≥®ê‚àÉv3(v1 Ãá= ÃáS Ãá0 Ãá+ ÃáSv3)‚ü¶p‚üß. Thus, the
set of primes is definable over ùí©by the ‚Ñí‚Ä≤-wff
‚àÉv3(v1 Ãá= ÃáS Ãá0 Ãá+ ÃáSv3) ‚àß‚àÄv2‚àÄv3(v2 Ãá√ó v3 Ãá= v1 ‚Üí(v2 Ãá= ÃáS Ãá0 ‚à®v3 Ãá= ÃáS Ãá0)).
Some relations on a structure are definable over the structure and some are not.
The concept of a homomorphism (see Section 3.2.6) can sometimes be used to show that
a relation is not definable over a given structure.
3.2.5 Classes of structures
A structure consists of a set along with functions and relations that are defined on the
set. In mathematics, one often studies a particular collection of structures because they
each satisfy a specific set of axioms. For example, groups, rings, fields, and vector spaces
are four types of structures that each satisfy four different sets of axioms. In this section,

3.2 Truth and structures
‡±™
79
we want to pursue this theme in terms of structures of a particular language that satisfy
all of the sentences in a specific set.
Definition 3.2.25. Let Œ£ be a set of sentences in a given language ‚Ñí. Then Mod(Œ£) de-
notes the class (collection) of all ‚Ñí-structures in which every sentence in Œ£ is true, that
is, Mod(Œ£) is the collection of all ‚Ñí-structures A such that A Û≥ÄÄÛ≥®êœÜ for all œÜ ‚ààŒ£.
For a single sentence œà we shall write Mod(œà) rather than Mod({œà}).
Example 3.2.26. Consider the language ‚Ñí= {e, ‚àó, Ãá=} of groups as discussed in Exam-
ple 3.2.1. Let Œ£ be the set consisting of the following three group axioms:
1.
‚àÄv1‚àÄv2‚àÄv3(v1 ‚àó(v2 ‚àóv3) Ãá= (v1 ‚àóv2) ‚àóv3),
2.
‚àÄv1(v1 ‚àóe Ãá= v1),
3.
‚àÄv1‚àÉv2(v1 ‚àóv2 Ãá= e).
Then Mod(Œ£) is the collection of all groups.
Let ùí¶be a collection of structures for a language. Suppose that every structure in
ùí¶satisfies one particular sentence and any structure that satisfies this sentence is also
in ùí¶. When this is the case, ùí¶is called an elementary class (EC).
Definition 3.2.27. Let ùí¶be a class of structures for a given language ‚Ñí. Then ùí¶is said
to be an EC if ùí¶= Mod(œà) for some ‚Ñí-sentence œà.
The term ‚Äúelementary‚Äù is a synonym for ‚Äúfirst-order‚Äù and the term ‚Äúclass‚Äù is a
synonym for the word ‚Äúcollection.‚Äù Our next definition is just an extension of Defini-
tion 3.2.27.
Definition 3.2.28. A class ùí¶of ‚Ñí-structures is said to be an EC in the wider sense (ECŒî)
if ùí¶= Mod(Œ£) for some set of ‚Ñí-sentences Œ£.
Two structures for a language may be different, but they may be alike with respect
to satisfying the exact same sentences in the language.
Definition 3.2.29. Let A and B be ‚Ñí-structures. Then A and B are elementarily equiva-
lent, denoted by A ‚â°B, if and only if for every sentence œÜ
A Û≥ÄÄÛ≥®êœÜ
iff
B Û≥ÄÄÛ≥®êœÜ.
That is, two structures are elementarily equivalent if they satisfy the same sen-
tences. Different worlds can sometimes share the same truths.
Definition 3.2.30. Let ùí¶be a class of ‚Ñí-structures. Then ùí¶is elementarily closed if for
all ‚Ñí-structures A and B, if A ‚ààùí¶and A ‚â°B, then B ‚ààùí¶.
Let Œ£ be a set of sentences in a language ‚Ñí. Then ùí¶= Mod(Œ£) is elementarily closed,
because if A ‚ààùí¶and A ‚â°B, then B Û≥ÄÄÛ≥®êœÜ for all œÜ ‚ààŒ£, so B ‚ààùí¶.

80
‡±™
3 First-order logic
Definition 3.2.31. Let A be an ‚Ñí-structure. The theory of A, denoted by Th(A), is the set
of all ‚Ñí-sentences true in A, that is,
Th(A) = {œÜ : œÜ is a sentence and A Û≥ÄÄÛ≥®êœÜ}.
Let A be an ‚Ñí-structure. Then A ‚ààMod(Th(A)) and, as noted above, Mod(Th(A))
is elementarily closed. So, in particular, given any ‚Ñí-structure A there is always a set of
sentences Œ£ such that A ‚ààMod(Œ£).
3.2.6 Homomorphisms
In linear algebra there is an interest in functions from one vector space V into another
vector space W that preserve vector addition and scalar multiplication.
Definition. If T: V ‚ÜíW is a function from a vector space (V, +, ‚ãÖ) to the vector space
(W, ‚äï, ‚àó), then T is called a linear transformation if for all vectors x and y in V and for
all scalars c, the following hold:
(1) T(x + y) = T(x) ‚äïT(y),
(2) T(c ‚ãÖx) = c ‚àóT(x).
In group theory one defines what it means for a function from one group G to an-
other group G‚Ä≤ to preserve the algebraic structure of the group G.
Definition. Let (G, ‚àó) and (G‚Ä≤, ‚äõ) be two groups. A function œÜ : G ‚ÜíG‚Ä≤ is called a homo-
morphism if for all a, b ‚ààG, œÜ(a ‚àób) = œÜ(a) ‚äõœÜ(b).
In this section, we will generalize these fundamental concepts to structures.
Functions that preserve operations and relations of structures
In mathematics, one uses a function to relate one set to another set. In mathematical
logic, a homomorphism relates one structure with another structure. More specifically,
a homomorphism is a structure preserving function between two structures of the same
language. The word homomorphism is derived from ancient Greek, where ‚Äúhomos‚Äù
means ‚Äúsame‚Äù and ‚Äúmorphe‚Äù means ‚Äúform.‚Äù
Definition 3.2.32. Let A = ‚ü®A; . . . ‚ü©and B = ‚ü®B; . . . ‚ü©be ‚Ñí-structures. A function h: A ‚ÜíB
is called a homomorphism if h has the following properties:
(1) For each n-place predicate symbol P and for all a1, a2, . . . , an ‚ààA, we have
‚ü®a1, a2, . . . , an‚ü©‚ààPA
iff
‚ü®h(a1), h(a2), . . . , h(an)‚ü©‚ààPB.
(2) For each n-place function symbol f and for all a1, a2, . . . , an ‚ààA, we have

3.2 Truth and structures
‡±™
81
h(f A(a1, a2, . . . , an)) = f B(h(a1), h(a2), . . . , h(an)).
(3) For each constant symbol c, we have h(cA) = cB.
Conditions (1)‚Äì(3) are often expressed, respectively, as: ‚Äúh preserves the relations,
the functions, and the constants.‚Äù
Example 3.2.33. Consider the language ‚Ñí= { Ãá+, Ãá√ó} and let A = ‚ü®‚Ñï; Ãá+A, Ãá√óA‚ü©, where
Ãá+A and
Ãá√óA are the standard addition and multiplication operations, respectively, on
the natural numbers. Define a new structure, whose domain has just two elements, by
B = ‚ü®{o, e}; Ãá+B, Ãá√óB‚ü©, where Ãá+B and Ãá√óB are given by the following addition and multi-
plication tables:
Ãá+B
e
o
e
e
o
o
o
e
Ãá√óB
e
o
e
e
e
o
e
o
The addition table can be viewed as saying that ‚Äúeven plus even is even,‚Äù ‚Äúeven plus odd
is odd,‚Äù and ‚Äúodd plus odd is even,‚Äù and similarly for the multiplication table.
Now define h: ‚Ñï‚Üí{o, e} by
h(n) = {e,
if n is even,
o,
if n is odd.
Then h is a homomorphism, as clause (2) of Definition 3.2.32 is satisfied as follows:
h(n Ãá+A m) = h(n) Ãá+B h(m),
h(n Ãá√óA m) = h(n) Ãá√óB h(m).
For example, if m and n are both odd, then n
Ãá√óA m is odd. Thus, h(n
Ãá√óA m) = o and
h(n) Ãá√óB h(m) = o Ãá√óB o = o. Hence, h(n Ãá√óA m) = h(n) Ãá√óB h(m).
Definition 3.2.34. Let A = ‚ü®A; . . . ‚ü©and B = ‚ü®B; . . . ‚ü©be structures for the language ‚Ñí.
Let h: A ‚ÜíB be a homomorphism.
‚Äì
We shall say h is a homomorphism of A into B.
‚Äì
We shall say that h: A ‚ÜíB is an isomorphism or an isomorphic embedding if h is
one-to-one. In this case, we shall say that h is an isomorphism of A into B.
‚Äì
When h: A ‚ÜíB is onto B, we shall say that h is a homomorphism of A onto B.
‚Äì
If h is both one-to-one and onto B, then A and B are isomorphic, denoted by A ‚âÖB.
In this case, we shall say that h is an isomorphism of A onto B.
Example 3.2.35. Let ‚Ñí= { Ãá<} and let ùí´= ‚ü®‚Ñô; Ãá<ùí´‚ü©, where ‚Ñô= {1, 2, 3, . . . } and Ãá<ùí´is the
standard ‚Äúless than‚Äù relation on ‚Ñô. Let ùí©= ‚ü®‚Ñï; Ãá<ùí©‚ü©, where ‚Ñï= {0, 1, 2, 3, . . . } and Ãá<ùí©

82
‡±™
3 First-order logic
is the standard ‚Äúless than‚Äù relation on ‚Ñï. Define h: ‚Ñô‚Üí‚Ñïby h(n) = n ‚àí1. Then h is a
homomorphism, as clause (1) of Definition 3.2.32 is satisfied as follows:
n Ãá<ùí´m
iff
h(n) Ãá<ùí©h(m).
Since h is one-to-one, we conclude that h is an isomorphic embedding. In addition, be-
cause h is onto ‚Ñï, we see that the structures ùí´and ùí©are isomorphic.
Definition 3.2.36. Let A = ‚ü®A; . . . ‚ü©and B = ‚ü®B; . . . ‚ü©be ‚Ñí-structures. We shall say that A
is a substructure of B if A ‚äÜB and the following conditions hold:
(a) For each n-place predicate symbol P and for all a1, a2, . . . , an ‚ààA, we have
‚ü®a1, a2, . . . , an‚ü©‚ààPA
iff
‚ü®a1, a2, . . . , an‚ü©‚ààPB.
(b) For each n-place function symbol f and for all a1, a2, . . . , an ‚ààA, we have
f A(a1, a2, . . . , an) = f B(a1, a2, . . . , an).
(c) For each constant symbol c, we have cA = cB.
Example 3.2.37. Consider the language ‚Ñí= { Ãá+} and let ùí¨= ‚ü®‚Ñö; Ãá+ùí¨‚ü©, where ‚Ñöis the set
of rational numbers and Ãá+ùí¨is the standard addition operation on ‚Ñö. Let ‚Ñõ= ‚ü®‚Ñù; Ãá+‚Ñõ‚ü©,
where ‚Ñùis the set of real numbers and
Ãá+‚Ñõis the standard addition operation on ‚Ñù.
Then ùí¨is a substructure of ‚Ñõbecause clause (b) of Definition 3.2.36 is satisfied, that is,
the operations Ãá+ùí¨and Ãá+‚Ñõagree on the rational numbers.
Let A and B be structures for the language ‚Ñí. Then A is a substructure of B if and
only if A ‚äÜB and the identity function i: A ‚ÜíB is a homomorphism.
The homomorphism theorem
We will soon state and prove our primary theorem about homomorphisms. The last part
of this theorem will provide us with a technique for showing that some relations are not
definable over a structure (see Theorem 3.2.41).
We begin by making some relevant remarks. Let A = (A; . . . ) and B = (B; . . . ) be
‚Ñí-structures and let ùíØbe the set of all the variables and constants of ‚Ñí. Let s: ùíØ‚ÜíA
be an assignment. Thus, by Theorem 3.2.5, there is a unique extension s: ùíØ‚ÜíA, where
ùíØis the set of all the terms of ‚Ñí. Suppose that h is a homomorphism of A into B. Then
h ‚àòs: ùíØ‚ÜíB is also an assignment, where (h ‚àòs)(v) = h(s(v)) for all v ‚ààùíØ. Thus, by
Theorem 3.2.5, there is a unique extension h ‚àòs: ùíØ‚ÜíB. We also note that a quantifier-
free wff is one in which no quantifier appears in the formula.
Theorem 3.2.38 (Homomorphism theorem). Let A and B be ‚Ñí-structures, let h be a ho-
momorphism of A into B, and let s: ùíØ‚ÜíA be an assignment, where ùíØis the set of all the
variables and constant symbols of ‚Ñíand A is the domain of A.

3.2 Truth and structures
‡±™
83
(a) For every term t of the language, h(s(t)) = h ‚àòs(t).
(b) For every quantifier-free wff œÜ that does not contain the equality symbol,
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs].
(c) If h is one-to-one, then for every quantifier-free wff œÜ that can contain the equality
symbol,
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs].
(d) If h is onto B, then for every wff œÜ that does not contain the equality symbol,
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs].
(e) If h is one-to-one and onto B, then for every wff œÜ,
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs].
Proof. We shall prove (a)‚Äì(e) below. Let h be a homomorphism of A into B. In the proofs
of (a)‚Äì(c), let s: ùíØ‚ÜíA be an arbitrary assignment.
(a) We must first prove that for every term t of the language, h(s(t)) = h ‚àòs(t). This will
be accomplished by induction on terms (see Section 3.1.2 on page 56).
Base step: For a constant symbol c, we have h(s(c)) = h(cA) = cB by Theorem 3.2.5(2)
and Definition 3.2.32(3). Also, h ‚àòs(c) = cB by Theorem 3.2.5(2) applied to h ‚àòs.
Therefore, h(s(c)) = h ‚àòs(c). In the case where v is a variable,
h(s(v)) = h(s(v)) = (h ‚àòs)(v) = h ‚àòs(v),
by Theorem 3.2.5(1) applied to s and h ‚àòs.
Inductive step: Let f be an n-place function symbol in ‚Ñíand let t1, t2, . . . , tn be terms.
Assume the induction hypothesis
For each i ‚â§n, we have h(s(ti)) = h ‚àòs(ti).
(IH)
We prove that the same holds for the term ft1t2 ‚ãÖ‚ãÖ‚ãÖtn, that is, we prove that
h(s(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn)) = h ‚àòs(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn).
We do this as follows:
h(s(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn)) = h(f A(s(t1), s(t2), . . . , s(tn)))
by Theorem 3.2.5(3),
= f B(h(s(t1)), h(s(t2)), . . . , h(s(tn)))
by Definition 3.2.32(2),

84
‡±™
3 First-order logic
= f B(h ‚àòs(t1), h ‚àòs(t2), . . . , h ‚àòs(tn))
by (IH),
= h ‚àòs(ft1t2 ‚ãÖ‚ãÖ‚ãÖtn)
by Theorem 3.2.5(3).
(b) For every œÜ that is a quantifier-free wff not containing the symbol Ãá=, we prove that
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs].
(Û≥µ≥)
We use induction on wffs.
Base step: We show that (Û≥µ≥) holds for all atomic formulas. So, let P be an n-place
predicate symbol and let t1, . . . , tn be terms. We show that
A Û≥ÄÄÛ≥®êPt1t2 ‚ãÖ‚ãÖ‚ãÖtn[s]
iff
B Û≥ÄÄÛ≥®êPt1t2 ‚ãÖ‚ãÖ‚ãÖtn[h ‚àòs]
as follows:
A Û≥ÄÄÛ≥®êPt1t2 ‚ãÖ‚ãÖ‚ãÖtn[s]
iff
‚ü®s(t1), . . . , s(tn)‚ü©‚ààPA
by Definition 3.2.6(2),
iff
‚ü®h(s(t1)), . . . , h(s(tn))‚ü©‚ààPB
by Definition 3.2.32(1),
iff
‚ü®h ‚àòs(t1), . . . , h ‚àòs(tn)‚ü©‚ààPB
by part (a) above,
iff
B Û≥ÄÄÛ≥®êPt1t2 ‚ãÖ‚ãÖ‚ãÖtn[h ‚àòs]
by Definition 3.2.6(2).
Inductive step: Let Œ± and Œ≤ be quantifier-free formulas that do not contain the equal-
ity symbol. Assume the induction hypothesis
A Û≥ÄÄÛ≥®êŒ±[s]
iff
B Û≥ÄÄÛ≥®êŒ±[h ‚àòs],
A Û≥ÄÄÛ≥®êŒ≤[s]
iff
B Û≥ÄÄÛ≥®êŒ≤[h ‚àòs].
(IH)
One must now prove that (¬¨Œ±) and (Œ± ‚ÜíŒ≤) both satisfy condition (Û≥µ≥). We first prove
that (¬¨Œ±) satisfies condition (Û≥µ≥) with the following argument:
A Û≥ÄÄÛ≥®ê¬¨Œ±[s]
iff
A
Ã∏Û≥ÄÄÛ≥®êŒ±[s]
by Definition 3.2.6(3),
iff
B
Ã∏Û≥ÄÄÛ≥®êŒ±[h ‚àòs]
as Œ± satisfies (IH),
iff
B Û≥ÄÄÛ≥®ê¬¨Œ±[h ‚àòs]
by Definition 3.2.6(3).
We now prove that (Œ± ‚ÜíŒ≤) satisfies condition (Û≥µ≥) as follows:
A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[s]
iff
A Û≥ÄÄÛ≥®êŒ±[s] implies A Û≥ÄÄÛ≥®êŒ≤[s]
by Definition 3.2.6(4),
iff
B Û≥ÄÄÛ≥®êŒ±[h ‚àòs] implies B Û≥ÄÄÛ≥®êŒ≤[h ‚àòs]
as Œ±, Œ≤ satisfy (IH),
iff
B Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[h ‚àòs]
by Definition 3.2.6(4).
(c) We must show that if h is one-to-one, then for every quantifier-free formula œÜ,
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs].

3.2 Truth and structures
‡±™
85
The argument is by induction, just as in the above proof of part (b). However, in the
base step of (b), we need to add the following proof showing that the atomic formula
Ãá=t1t2 satisfies (Û≥µ≥). Let t1 and t2 be terms. We then have the following:
A Û≥ÄÄÛ≥®êÃá=t1t2[s]
iff
s(t1) = s(t2)
by Definition 3.2.6(1),
iff
h(s(t1)) = h(s(t2))
because h is one-to-one,
iff
h ‚àòs(t1) = h ‚àòs(t2)
by part (a) above,
iff
B Û≥ÄÄÛ≥®êÃá=t1t2[h ‚àòs]
by Definition 3.2.6(1).
The rest of the argument is exactly like the one given for (b).
(d) Let h be onto B. For every formula œÜ not containing the symbol Ãá=, we prove that
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs],
for all assignments s.
(3.10)
The argument is by induction. For atomic formulas œÜ, the proof of (3.10) is as in
the above proof of part (b). However, in the inductive step, we need to include the
quantifier symbol ‚àÄ. The proof of this case follows. Let Œ± be a formula that does not
contain the equality symbol. Assume the induction hypothesis
A Û≥ÄÄÛ≥®êŒ±[s]
iff
B Û≥ÄÄÛ≥®êŒ±[h ‚àòs],
for all assignments s.
(IH)
We must show that
A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s]
iff
B Û≥ÄÄÛ≥®ê‚àÄvŒ±[h ‚àòs],
for all assignments s.
Let s: ùíØ‚ÜíA be an arbitrary assignment and let B be the domain of B. Thus,
A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s]
iff
for all a ‚ààA, A Û≥ÄÄÛ≥®êŒ±[sv|a]
by Definition 3.2.6(5),
iff
for all a ‚ààA, B Û≥ÄÄÛ≥®êŒ±[h ‚àòsv|a]
by (IH); sv|a is an assignment,
iff
for all a ‚ààA, B Û≥ÄÄÛ≥®êŒ±[(h ‚àòs)v|h(a)]
as h ‚àòsv|a = (h ‚àòs)v|h(a),
iff
for all b ‚ààB, B Û≥ÄÄÛ≥®êŒ±[(h ‚àòs)v|b]
as h: A ‚ÜíB is onto B,
iff
B Û≥ÄÄÛ≥®ê‚àÄvŒ±[(h ‚àòs)]
by Definition 3.2.6(5).
(e) Suppose that h is one-to-one and onto B. We must show that for every formula œÜ,
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs],
for all assignments s.
The argument is by induction on wffs. For the base step one uses the arguments
given for the base steps in the above proofs of (b) and (c). For the inductive step one
uses the arguments given for the inductive steps in the above proofs of (b) and (d).
This completes the proof of the homomorphism theorem.

86
‡±™
3 First-order logic
Applications of the homomorphism theorem
Before we state and prove the next theorem, recall that h is said to be an isomorphism
of A onto B when h: A ‚ÜíB is both a one-to-one and onto homomorphism. In this case,
A and B are said to be isomorphic, denoted by A ‚âÖB. Also, recall Definition 3.2.29.
Theorem 3.2.39. Let A and B be structures for a language ‚Ñí. Suppose that A and B are
isomorphic. Then A ‚â°B.
Proof. Assume that A ‚âÖB. Let œÜ be a sentence. We will show that A Û≥ÄÄÛ≥®êœÜ iff B Û≥ÄÄÛ≥®êœÜ. Let
h be an isomorphism of A onto B and let s: ùíØ‚ÜíA be an assignment, where ùíØis the set
of all the variables and constant symbols of ‚Ñí. Then
A Û≥ÄÄÛ≥®êœÜ
iff
A Û≥ÄÄÛ≥®êœÜ[s]
by Definition 3.2.13,
iff
B Û≥ÄÄÛ≥®êœÜ[h ‚àòs]
by Theorem 3.2.38(e),
iff
B Û≥ÄÄÛ≥®êœÜ
by Definition 3.2.13.
Application 1. Let ‚Ñí= { Ãá<, Ãá=} and let ùí´= ‚ü®‚Ñô; Ãá<ùí´‚ü©, where ‚Ñô= {1, 2, 3, . . . } and Ãá<ùí´is the
standard ‚Äúless than‚Äù relation on ‚Ñô. Let ùí©= ‚ü®‚Ñï; Ãá<ùí©‚ü©, where ‚Ñï= {0, 1, 2, 3, . . . } and Ãá<ùí©
is the standard ‚Äúless than‚Äù relation on ‚Ñï. Now define h: ‚Ñô‚Üí‚Ñïby
h(n) = n ‚àí1.
As discussed in Example 3.2.35, h is a one-to-one and onto homomorphism, and thus
ùí´and ùí©are isomorphic. So by Theorem 3.2.39, for any ‚Ñí-sentence œÜ, we have ùí´Û≥ÄÄÛ≥®ê
œÜ iff ùí©Û≥ÄÄÛ≥®êœÜ, that is, ùí´and ùí©are elementarily equivalent.
On the other hand, let us define h‚Ä≤: ‚Ñô‚Üí‚Ñïto be
h‚Ä≤(n) = n.
Then h‚Ä≤ is also a homomorphism and is one-to-one, but it is not onto ‚Ñï. Let s: T ‚Üí‚Ñôbe
an assignment. Hence, by Theorem 3.2.38(c), if œÜ is quantifier-free, then
ùí´Û≥ÄÄÛ≥®êœÜ[s]
iff
ùí©Û≥ÄÄÛ≥®êœÜ[h‚Ä≤ ‚àòs].
(3.11)
The equivalence (3.11) may fail for a formula œÜ that contains quantifiers. To illustrate
this, let s be an assignment such that s(v1) = 1. Since h‚Ä≤ is the identity function, it follows
that h‚Ä≤ ‚àòs = s. Let œÜ be the quantified statement
‚àÄv2(v1
Ã∏Ãá= v2 ‚Üív1 Ãá< v2).
Since s(v1) = 1 and (h‚Ä≤ ‚àòs)(v1) = 1, it follows that ùí´Û≥ÄÄÛ≥®êœÜ[s] and ùí©
Ã∏Û≥ÄÄÛ≥®êœÜ[h‚Ä≤ ‚àòs]. So, because
h‚Ä≤ is one-to-one and not onto ‚Ñï, (3.11) can fail when œÜ contains quantifiers.
Definition 3.2.40. Let A = ‚ü®A; . . . ‚ü©be an ‚Ñí-structure. A function h: A ‚ÜíA is called an
automorphism of the structure A if h is an isomorphism of A onto A.

3.2 Truth and structures
‡±™
87
Let A = ‚ü®A; . . . ‚ü©be a structure for a language ‚Ñí. Recall that a k-ary relation R on A
is definable over A if there is a wff œÜ with free variables v1, . . . , vk such that
‚ü®a1, a2, . . . , ak‚ü©‚ààR
iff
A Û≥ÄÄÛ≥®êœÜ‚ü¶a1, a2, . . . , ak‚üß
for all a1, a2, . . . , ak ‚ààA.
Theorem 3.2.41. Let A be a structure for a language ‚Ñíand let h be an automorphism of
the structure A. Let R be a k-ary relation that is definable over A. Then
‚ü®a1, a2, . . . , ak‚ü©‚ààR
iff
‚ü®h(a1), h(a2), . . . , h(ak)‚ü©‚ààR
for all a1, a2, . . . , ak ‚ààA.
Proof. Let œÜ be a wff that defines R. For all a1, a2, . . . , ak ‚ààA, we have
‚ü®a1, a2, . . . , ak‚ü©‚ààR
iff
A Û≥ÄÄÛ≥®êœÜ‚ü¶a1, a2, . . . , ak‚üß
because œÜ defines R,
iff
A Û≥ÄÄÛ≥®êœÜ
?h(a1), h(a2), . . . , h(ak)
?
by Theorem 3.2.38(e),
iff
‚ü®h(a1), h(a2), . . . , h(ak)‚ü©‚ààR
because œÜ defines R.
Application 2. Let ‚Ñí= { Ãá<, Ãá=} and let R = ‚ü®‚Ñù; <‚ü©, where ‚Ñùis the set of real numbers and
< is the usual ‚Äúless than‚Äù relation on ‚Ñù. Define h: ‚Ñù‚Üí‚Ñùby
h(x) = x3.
Then h is a homomorphism, because clause (1) of Definition 3.2.32 holds as follows:
x < y
iff
h(x) < h(y).
Since h is one-to-one and onto ‚Ñù, we conclude that h is an automorphism of the struc-
ture R. Note that ‚Ñï‚äÜ‚Ñù. We can now show that ‚Ñïis not definable over R. Suppose, for
a contradiction, that there is a wff œÜ such that
a ‚àà‚Ñï
iff
R Û≥ÄÄÛ≥®êœÜ‚ü¶a‚üß
for all a ‚àà‚Ñù. Theorem 3.2.41 then implies that for all a ‚àà‚Ñù,
a ‚àà‚Ñï
iff
h(a) ‚àà‚Ñï.
Let a =
3‚àö2. Since h(a) = 2 ‚àà‚Ñï, the above equivalence implies that
3‚àö2 ‚àà‚Ñï. This
contradiction shows that ‚Ñïis not definable over R.
Exercises 3.2.
1. Verify item (9) of Remark 3.2.8.
2. Let A be an ‚Ñí-structure and let s be an assignment, as in Definition 3.2.4. Let œà be
a wff. Show that either A Û≥ÄÄÛ≥®êœà[s] or A Û≥ÄÄÛ≥®ê(¬¨œà)[s], but not both.

88
‡±™
3 First-order logic
3. Let ‚Ñí= {L, f , c} and let A be as in Example 3.2.7. Let s: ùíØ‚Üí‚Ñïbe an assignment
satisfying s(vi) = i + 1. So, s(v1) = 2 and s(v2) = 3. Show that:
(a) A Û≥ÄÄÛ≥®ê‚àÉv2Lv2fc[s],
(b) A Û≥ÄÄÛ≥®ê‚àÉv2Lv2v1[s],
(c) A
Ã∏Û≥ÄÄÛ≥®ê‚àÉv2Lv2c[s].
4. Let ‚Ñí= {L, f , c} and let A be as in Example 3.2.7. Show that:
(a) A Û≥ÄÄÛ≥®ê‚àÄv1‚àÉv2Lfv1v2,
(b) A
Ã∏Û≥ÄÄÛ≥®ê‚àÉv2‚àÄv1Lfv1v2.
5. Let ‚Ñí= { Ãá+, Ãá0, Ãá1, Ãá2, Ãá=}, where Ãá+ is a 2-place function symbol and Ãá0, Ãá1, Ãá2 are constant
symbols.
(a) Find a structure for the language ‚Ñíin which the two sentences Ãá1 Ãá+ Ãá1 = Ãá2 and
‚àÄv(v Ãá+ Ãá0 Ãá= v) are true.
(b) Find a structure for the language ‚Ñíin which the two sentences Ãá1 Ãá+ Ãá1 = Ãá2 and
‚àÄv(v Ãá+ Ãá0 Ãá= v) are false.
6. Let ‚Ñí= {f , Ãá=} be a language where f is a 1-place function symbol.
(a) Find a sentence œÜ so that A Û≥ÄÄÛ≥®êœÜ if and only if f A: A ‚ÜíA is one-to-one, for any
structure A = ‚ü®A; f A‚ü©.
(b) Find a sentence œÜ so that A Û≥ÄÄÛ≥®êœÜ if and only if f A: A ‚ÜíA is onto A, for any
structure A = ‚ü®A; f A‚ü©.
7. Let ‚Ñí= { Ãá<} be the language having just the 2-place relation symbol Ãá<. Consider the
structures A = ‚ü®‚Ñï; Ãá<A‚ü©and B = ‚ü®‚Ñù; Ãá<B‚ü©, where Ãá<A and Ãá<B are to be interpreted
as the standard ‚Äúless than‚Äù relation. Find a sentence œÜ in the language ‚Ñíthat is true
in one of the structures but false in the other.
8. Let ‚Ñí= { Ãá√ó, Ãá=} be the language having equality and Ãá√ó, a 2-place function symbol.
Let A = ‚ü®‚Ñù; Ãá√óA‚ü©and B = ‚ü®‚Ñù‚àó; Ãá√óB‚ü©be structures where ‚Ñù‚àóis the set of nonzero
real numbers and Ãá√óA and Ãá√óB are both the usual multiplication operation. Find a
sentence œÜ in the language ‚Ñíthat is true in one of the structures but false in the
other.
*9. Let Œ±, œà, œÜ be wffs and let Œì be a set of wffs in a language ‚Ñí. Show that
(a) Œì ‚à™{Œ±} Û≥ÄÄÛ≥®êœÜ if and only if Œì Û≥ÄÄÛ≥®ê(Œ± ‚ÜíœÜ),
(b) œÜ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œà if and only if Û≥ÄÄÛ≥®ê(œÜ ‚Üîœà).
10. Show that the set of any two of the following sentences does not logically imply the
third sentence:
(a) ‚àÄx‚àÄy‚àÄz(Pxy ‚ÜíPyz ‚ÜíPxz),
(b) ‚àÄx‚àÄy(Pxy ‚ÜíPyx ‚Üíx Ãá= y),
(c) ‚àÄx‚àÉyPxy ‚Üí‚àÉy‚àÄxPxy.
*11. Let A be a structure and let s be an assignment such that s(x) = s(y), where x and
y are variables.
(a) Prove that for all terms t, if t‚Ä≤ is obtained from t by replacing some, none, or
all of the occurrences of x in t with y, then s(t) = s(t‚Ä≤).

3.2 Truth and structures
‡±™
89
(b) Let Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn be an atomic formula and let Pt‚Ä≤
1t‚Ä≤
2 ‚ãÖ‚ãÖ‚ãÖt‚Ä≤
n be the result of replacing
some, none, or all of the occurrences of x in Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn with y. Show that A Û≥ÄÄÛ≥®ê
Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn[s] if and only if A Û≥ÄÄÛ≥®êPt‚Ä≤
1t‚Ä≤
2 ‚ãÖ‚ãÖ‚ãÖt‚Ä≤
n[s].
*12. Show that {‚àÄx(Œ± ‚ÜíŒ≤), ‚àÄxŒ±} Û≥ÄÄÛ≥®ê‚àÄxŒ≤.
*13. Show that if x does not occur free in Œ±, then Œ± Û≥ÄÄÛ≥®ê‚àÄxŒ±.
*14. Show that a wff Œ∏ is logically valid if and only if ‚àÄxŒ∏ is logically valid.
15. Let ‚Ñí= { Ãá+, Ãá√ó, Ãá=} and let ùí©= ‚ü®‚Ñï; +, √ó‚ü©be an ‚Ñí-structure, where
Ãá+ùí©= + and
Ãá√óùí©= √ó are the usual operations of addition and multiplication, respectively. Show
that each of the following sets are definable over ùí©:
(a) {0},
(b) {1},
(c) {‚ü®m, n‚ü©: n is the successor of m},
(d) {‚ü®m, n‚ü©: m < n}.
16. Let ‚Ñí= { Ãá+, Ãá√ó, Ãá=} be the language having equality and 2-place function symbols Ãá+
and Ãá√ó. Consider the ‚Ñí-structure R = ‚ü®‚Ñù; +, √ó‚ü©, where + and √ó are the usual addition
and multiplication operations.
(a) Show that [0, ‚àû) is definable over R.
(b) Show that {1} is definable over R.
(c) Show that {2} is definable over R.
17. Let Œ£ and Œì be sets of sentences in a language ‚Ñí. Show that:
(a) if Œì ‚äÜŒ£, then Mod(Œ£) ‚äÜMod(Œì),
(b) Mod(Œì) ‚à©Mod(Œ£) = Mod(Œì ‚à™Œ£),
(c) Mod(Œì) ‚à™Mod(Œ£) ‚äÜMod(Œì ‚à©Œ£).
18. Let Œ£ = {œÜ1, œÜ2, . . . , œÜn} be a finite set of ‚Ñí-sentences and let œà = œÜ1 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßœÜn. Show
that Mod(Œ£) = Mod(œà).
*19. Let A and B be ‚Ñí-structures.
(a) Show that for every ‚Ñí-sentence œà, either œà ‚ààTh(B) or ¬¨œà ‚ààTh(B).
(b) Show that if A Û≥ÄÄÛ≥®êTh(B), then A and B are elementarily equivalent.
20. Let ‚Ñí= { Ãá<, Ãá=} and let R = ‚ü®‚Ñù; <‚ü©, where ‚Ñùis the set of real numbers and < is the
standard ‚Äúless than‚Äù relation on ‚Ñù.
(a) What subsets of ‚Ñùare definable over R?
(b) Let R ‚äÜ‚Ñù2 be such that ‚ü®a, a‚ü©‚ààR and ‚ü®b, b‚ü©‚àâR. Is R definable over R?
(c) Let R ‚äÜ‚Ñù2 be such that ‚ü®a, b‚ü©‚ààR and ‚ü®c, d‚ü©‚àâR. Show that if a < b and c < d,
then R is not definable over R.
21. Let ‚Ñí= { Ãá<, Ãá=}, where Ãá< is a 2-place predicate symbol. Let ùíµ= ‚ü®‚Ñ§; <‚ü©be the struc-
ture, where ‚Ñ§is the set of integers and < is the standard less than relation.
(a) Prove that for all n ‚àà‚Ñ§, the set {n} is not definable over ùíµ.
(b) Let Œ∏ be a wff with one free variable v1. Suppose that ùíµÛ≥ÄÄÛ≥®êŒ∏‚ü¶2‚üß. Using Theo-
rem 3.2.38, prove that ùíµÛ≥ÄÄÛ≥®ê‚àÄv1Œ∏.
22. Let ‚Ñí= { Ãá<, Ãá√ó, Ãá=} be a language with a 2-place predicate symbol Ãá< and 2-place func-
tion symbol Ãá√ó. Let ‚Ñõ= ‚ü®‚Ñô; <, √ó‚ü©be the structure, where ‚Ñôis the set of positive real

90
‡±™
3 First-order logic
numbers, < is the standard less than relation, and √ó is the standard multiplication
function on the positive real numbers.
(a) Define the function h: ‚Ñô‚Üí‚Ñôby h(x) = x2. Prove that h is an automorphism of
the structure ‚Ñõ.
(b) Let A = {‚ü®x, y, z‚ü©‚àà‚Ñô3 : x + y = z}. Prove that A is not definable over ‚Ñõ.
Exercise Notes: For Exercise 1, use Definition 3.2.6 and abbreviation 4 on page 62. For
Exercise 3 and Exercise 4, use Remark 3.2.8. For Exercise 11, use induction on terms. For
Exercise 21(b), show that ùíµÛ≥ÄÄÛ≥®êŒ∏‚ü¶n‚üßfor all n ‚àà‚Ñ§.
3.3 Deductions
What is proof?
In Section 3.1 we described a formal language ‚Ñíand also defined what it means for
a formula of the language to be grammatically correct. In addition, in Section 3.2 we
defined the notion of ‚Äútruth‚Äù in a structure, that is, A Û≥ÄÄÛ≥®êœÜ, where œÜ is a sentence. Recall
that a sentence œÜ is logically implied by a set of sentences Œì, denoted by Œì Û≥ÄÄÛ≥®êœÜ, if every
model of Œì is a model of œÜ. In this section we shall define the notion of ‚Äúproof‚Äù from a
set of axioms (or formulas), that is, we shall define when œÜ is deducible from the axioms
in Œì, denoted by Œì ‚ä¢œÜ.
Surely the most important discovery for mathematics by the ancient Greeks was
the notion of proof, turning mathematics into a deductive science. Each theorem œÜ must
have a proof from a set Œì of more or less explicitly stated assumptions, or axioms. The
proof must demonstrate that the conclusion œÜ follows from the axioms in Œì by the laws
of logic alone. The natural question is:
Can the notions of ‚Äúlaws of logic‚Äù and ‚Äúproof‚Äù be made mathematically precise?
A proof is an argument that you give to someone else which completely convinces him
or her of the correctness of your assertion. Thus, a proof should be finitely long, as you
cannot give an infinite argument to another person. If the set of axioms Œì is infinite, that
is fine, but they cannot all be used in one proof (otherwise, we would have an infinitely
long proof). Another essential feature of a proof is that it must be possible for another
person to check the proof to ascertain that it contains no fallacies.
In Section 2.5, we presented a system of deduction for propositional logic, where
our axioms were the tautologies of propositional logic and our one rule of inference
was modus ponens. Our system of deduction for first-order logic will be similar. We will
select a set Œõ of wffs to be called logical axioms and we will use modus ponens as our
one rule of inference. This will enable us to deduce a new wff from other wffs. Then
for a set Œì of wffs, the theorems of Œì will be the wffs which can be deduced from Œì ‚à™Œõ.
A wff œÜ will be a theorem of Œì (written Œì ‚ä¢œÜ) if and only if there a finite sequence of

3.3 Deductions
‡±™
91
wffs which identifies how œÜ was derived from Œì ‚à™Œõ. Such a derivation, which uses the
logical axioms and the rule of inference, will be called a deduction of œÜ from Œì. The term
deduction will be used to avoid confusion with our own mathematical proofs.
There are other deduction systems for first-order logic that are equivalent to the
one we shall present. Each such system of deduction may have a different version of Œõ
and different rules of inference, but each system will produce the same theorems.
Before we identify the set of logical axioms Œõ, we must first discuss tautologies, gen-
eralizations, and substitutions in first-order logic.
3.3.1 Tautologies in first-order logic
In Remark 2.2.13, we defined the concept of a tautology in propositional logic. The def-
inition of a tautology can be extended to wffs in first-order logic, where the wff may
contain quantifiers‚Äîan attribute absent from wffs in propositional logic.
Definition 3.3.1 (First-order tautologies). Let ‚Ñíbe a first-order language and let A1, A2,
A3, . . . be the sentence symbols of propositional logic. Let œÜ be a tautology in proposi-
tional logic containing only the connectives ¬¨ and ‚Üí. Suppose that the sentence sym-
bols in œÜ are in the list A1, A2, . . . , An. Let œÜ‚àóbe the result of replacing A1, A2, . . . , An with
Œ±1, Œ±2, . . . , Œ±n, where each Œ±i is a first-order wff in ‚Ñí. We shall then say that œÜ‚àóis a first-
order tautology.
First-order tautologies are simple generalizations of the tautologies of propositional
logic. For example, the propositional wff
(A ‚ÜíB) ‚Üí(¬¨B ‚Üí¬¨A)
(3.12)
is a tautology where A and B are two sentence symbols. We can use this tautology to
create first-order tautologies. Let œÜ and œà be wffs of first-order logic. Then
(œÜ ‚Üíœà) ‚Üí(¬¨œà ‚Üí¬¨œÜ)
is a first-order tautology. All the first-order tautologies are obtained in this manner, that
is, from the tautologies of propositional logic.
For another example, consider the propositional tautology (3.12). Let Œ± and Pt be any
two formulas of first-order logic, where Pt is an atomic formula. Then
(‚àÄvŒ± ‚ÜíPt) ‚Üí((¬¨Pt) ‚Üí(¬¨‚àÄvŒ±))
is a first-order tautology. We now present four more examples of first-order tautologies.
In these examples, we reverse the replacement procedure and then determine if we get
a propositional tautology. If so, we have a first-order tautology.

92
‡±™
3 First-order logic
1.
(‚àÄzPz ‚à®¬¨‚àÄzPz)
Replace the wff ‚àÄzPz with the sentence symbol A. Thus, item 1 is a first-order tau-
tology, because (A ‚à®¬¨A) is a tautology.
2.
(‚àÉzPz ‚Üí‚àÄxQx) ‚Üí(¬¨‚àÄxQx ‚Üí¬¨‚àÉzPz)
Replace ‚àÉzPz with the sentence symbol A and replace ‚àÄxQx with B. Item 2 is a first-
order tautology, because (A ‚ÜíB) ‚Üí(¬¨B ‚Üí¬¨A) is a tautology.
3.
¬¨(‚àÄzPz ‚ÜíQx) ‚Üí‚àÄzPz
Replace ‚àÄzPz with A and replace Qx with B. Item 3 is a first-order tautology because
¬¨(A ‚ÜíB) ‚ÜíA is a tautology.
4.
¬¨(‚àÄzPz ‚ÜíQx) ‚Üí¬¨Qx
Replace ‚àÄzPz with A and replace Qx with B. Item 4 is a first-order tautology because
¬¨(A ‚ÜíB) ‚Üí¬¨B is a tautology,
Propositional logic revisited
We will now apply certain concepts from propositional logic, covered in Chapter 2, to
first-order logic. We will also refer to a first-order wff as being an ‚Ñí-formula. In proposi-
tional logic, the concept of a truth assignment is based on having sentence symbols. Can
the concept of a sentence symbol be extended to first-order logic?
Definition 3.3.2 (Prime formulas). We divide the ‚Ñí-formulas into two groups:
1.
A wff is called prime if it is an atomic formula or has the form ‚àÄvŒ± for a wff Œ±.
2.
A wff is called nonprime if it has the form (¬¨Œ±) or (Œ± ‚ÜíŒ≤) for wffs Œ± and Œ≤.
Thus, ¬¨‚àÄz¬¨Pz is a nonprime formula, whereas ‚àÄz¬¨Pz is a prime formula. The prime
formulas of first-order logic can be viewed as analogues of the sentence symbols in
propositional logic.
Definition 3.3.3. Let ùíÆbe a set of prime formulas. Then we shall let ùíÆbe the set of wffs
that can be built from the prime formulas in ùíÆby using the two formula building func-
tions ‚Ñ∞¬¨ and ‚Ñ∞‚Üí.
Every wff of first-order logic can be built up from the prime formulas by the opera-
tions ‚Ñ∞¬¨ and ‚Ñ∞‚Üí. Thus, if one considers the prime formulas as ‚Äúsentence symbols,‚Äù then
the wffs of first-order logic can also be seen, from a global point of view, as ‚Äúformulas of
propositional logic.‚Äù
Definition 3.3.4. Let ùíÆbe a set of prime formulas in a first-order language ‚Ñí. A function
u: ùíÆ‚Üí{F, T} is called an ‚Ñí-truth assignment for ùíÆ.
Let ùíÆbe a set of prime formulas and let u: ùíÆ‚Üí{F, T} be an ‚Ñí-truth assignment for ùíÆ.
Let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚Üí}. Theorem 2.2.1 implies that the set ùíÆof all wffs generated by ùíÆfrom
the functions in ‚Ñ±is freely generated. Thus, there is a unique function u: ùíÆ‚Üí{F, T}
satisfying the analogous conclusions of Theorem 2.2.4(1)(4).

3.3 Deductions
‡±™
93
Let œà be a wff of first-order logic. Recall Definition 3.3.1. One can now show that œà
is a first-order tautology if and only if for every ‚Ñí-truth assignment u, defined on the
prime formulas in œà, we have u(œà) = T.
Remark 3.3.5. Let A be an ‚Ñí-structure with domain A and also let s: ùíØ‚ÜíA be an as-
signment, where ùíØis the set of all the variables and constant symbols of ‚Ñí. Now let u be
an ‚Ñí-truth assignment. It is possible that u(‚àÄvŒ±) = F, while A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s]. Thus, an ‚Ñí-truth
assignment may disagree with the satisfaction relation of Definition 3.2.6.
Definition 3.3.6. Let œÜ be an ‚Ñí-formula and let u be an ‚Ñí-truth assignment that is de-
fined on the prime formulas in œÜ. Then u satisfies œÜ if and only if u(œÜ) = T.
Let œÜ and œà be two ‚Ñí-wffs. Then œÜ tautologically implies œà if and only if for every
‚Ñí-truth assignment u defined on all of the prime formulas that appear in œÜ and œà, if u
satisfies œÜ, then u satisfies œà. Moreover, œÜ and œà are tautologically equivalent if œÜ tauto-
logically implies œà and the converse holds as well.
Definition 3.3.7. Let Œ£ be a set of ‚Ñí-wffs. Then Œ£ is ‚Ñí-satisfiable if there is an ‚Ñí-truth
assignment u that is defined on the prime formulas in every œÜ ‚ààŒ£ such that u(œÜ) = T
for every œÜ ‚ààŒ£.
Definition 3.3.8. A set of ‚Ñí-formulas Œ£ is finitely ‚Ñí-satisfiable if and only if every finite
subset of Œ£ is ‚Ñí-satisfiable.
The notion of tautological implication can now be applied to first-order logic.
Definition 3.3.9. Let Œ£ be a set of ‚Ñí-formulas and let œÜ be an ‚Ñí-formula. Then Œ£ tauto-
logically implies œÜ if and only if for every ‚Ñí-truth assignment u, defined on the prime
formulas occurring in formulas in Œ£ and in œÜ, if u satisfies Œ£, then u(œÜ) = T.
Theorem 2.4.2, the compactness theorem of propositional logic, and its corollaries
now extend to first-order logic.
Theorem 3.3.10. Let Œ£ be a set of ‚Ñí-formulas. If Œ£ is finitely ‚Ñí-satisfiable, then Œ£ is
‚Ñí-satisfiable.
The above extension of the propositional compactness theorem holds even when
the set of prime formulas is uncountable (see Remark 2.4.3). The proof of Corollary 2.4.5
establishes the following result.
Corollary 3.3.11. If a set of ‚Ñí-formulas Œ£ tautologically implies an ‚Ñí-formula œÜ, then Œ£0
tautologically implies œÜ for some finite Œ£0 ‚äÜŒ£.
3.3.2 Generalization and substitution
Given an ‚Ñí-formula œà, a generalization of œà is the result of putting universal quantifiers
prior to œà.

94
‡±™
3 First-order logic
Definition 3.3.12 (Generalization). Let ‚Ñíbe a first-order language. Let œà be a wff. A wff
œÜ is a generalization of œà if and only if for some n ‚â•0 and some variables x1, x2, . . . , xn,
œÜ = ‚àÄx1‚àÄx2 ‚ãÖ‚ãÖ‚ãÖ‚àÄxnœà.
In particular, when n = 0, any wff is a generalization of itself.
Substitution
In mathematics, one often replaces a variable with some expression that represents a
possible value of the variable. We will also need to do this in first-order logic. In particu-
lar, we will need to substitute a free variable appearing in a wff Œ± with a term. We shall
write Œ±x
t to denote the wff obtained by replacing the free occurrences of the variable x
in the wff Œ± with the term t.
Before we give a mathematical definition of the operation Œ±x
t , we give an example of
what the operation Œ±x
t should not do. Let ‚Ñí= { Ãá+, Ãá0}, where Ãá+ is a 2-place function symbol
and Ãá0 is a constant symbol. Consider the wff ‚àÄx(x Ãá+ Ãá0 Ãá=x). If we replace the variable x with
the term Ãá0, then we obtain the expression ‚àÄÃá0( Ãá0 Ãá+ Ãá0 Ãá= Ãá0), which is not a wff. One cannot
‚Äúquantify over a constant.‚Äù So, the definition of the operation Œ±x
t must avoid replacing a
quantified variable with the term t (see item 4 of the following definition).
Definition 3.3.13 (The operation Œ±x
t ). Let ‚Ñíbe a language where x is a variable and t is a
term. Let Œ± be a wff. The wff Œ±x
t is defined recursively as follows:
1.
Œ±x
t is the result of replacing all occurrences of x in Œ± with t, when Œ± is atomic;
2.
(¬¨Œ±)x
t = ¬¨Œ±x
t ;
3.
(Œ± ‚ÜíŒ≤)x
t = Œ±x
t ‚ÜíŒ≤x
t ;
4.
(‚àÄvŒ±)x
t = {‚àÄvŒ±,
if x = v,
‚àÄvŒ±x
t ,
if x
Ã∏= v.
In the right hand side of the equalities in items 2 and 3 of Definition 3.3.13, we have
dropped the outermost parentheses (see 7 on page 63). Exercise 5 shows that Defini-
tion 3.3.13 is an application of Theorems 1.1.27 and 3.1.16.
We offer some observations and examples that illustrate Definition 3.3.13:
(a) œÜx
x = œÜ for all wffs œÜ;
(b) œÜx
t = œÜ when x is not a free variable in œÜ;
(c) observe that
(Qx ‚Üí‚àÄyPy)x
y = Qxx
y ‚Üí(‚àÄyPy)x
y = Qy ‚Üí‚àÄyPy
by items 3, 1, and 4 of Definition 3.3.13;
(d) note that
(¬¨‚àÄyLxy)x
z = ¬¨(‚àÄyLxy)x
z = ¬¨‚àÄyLxyx
z = ¬¨‚àÄyLzy

3.3 Deductions
‡±™
95
by items 2, 4, and 1 of Definition 3.3.13;
(e) observe that
‚àÄx¬¨‚àÄyLxy ‚Üí(¬¨‚àÄyLxy)x
z = ‚àÄx¬¨‚àÄyLxy ‚Üí¬¨‚àÄyLzy
by item (c). This example has the form ‚àÄxŒ± ‚ÜíŒ±x
t , where t is a term.
One might wonder why we have the two-case distinction in item 4 of Definition 3.3.13.
Suppose that instead, item 4 was defined to be (‚àÄvŒ±)x
t = ‚àÄvŒ±x
t even if v = x. Then this
version of Definition 3.3.13 would allow us to conclude that
(‚àÉx(x
Ã∏Ãá= y))
x
y = ‚àÉx(y
Ã∏Ãá= y),
which is false in all structures and all assignments. This illustrates why item 4 is defined
as it is in Definition 3.3.13.
The next two examples (i) and (ii) illustrate the concept of being and not being ‚Äúsub-
stitutable,‚Äù respectively. Let ‚Ñí= {L, f , c}, where L is a 2-place predicate symbol, f is a
1-place function symbol, and c is a constant symbol. Consider the wff Œ± = ‚àÄvLvx. Note
that Œ± contains the two distinct variables v and x. Using the terms fy and fv, let us eval-
uate the new formulas Œ±x
fy and Œ±x
fv:
(i)
Œ±x
fy = (‚àÄvLvx)x
fy = ‚àÄvLvfy
So, when the term fy is substituted for the variable x, the quantifier ‚Äú‚àÄv‚Äù does not
‚Äúcapture‚Äù the variable y in fy.
(ii) Œ±x
fv = (‚àÄvLvx)x
fv = ‚àÄvLvfv
Thus, when the term fv is substituted for the variable x, the quantifier ‚Äú‚àÄv‚Äù does
‚Äúcapture‚Äù the variable v in fv.
In (i) we shall say that fy is ‚Äúsubstitutable‚Äù for x, whereas in (ii) we shall say that fv is not
‚Äúsubstitutable‚Äù for x. We want to avoid substitutions, as in (ii), that result in a variable
in a term being ‚Äúcaptured‚Äù by a quantifier. Why? See Example 3.3.14, below.
Example 3.3.14. The wff ‚àÄxŒ± ‚ÜíŒ±x
t asserts that ‚Äúif Œ± is true of everything, then Œ± is true
of t.‚Äù This appears to be obviously true. Let ‚Ñí= { Ãá=} and let A be an ‚Ñí-structure whose
domain contains at least two elements. Now let Œ± be the formula (¬¨‚àÄy(x Ãá= y)). Observe
that Œ±x
y = (¬¨‚àÄy(x Ãá= y))x
y = ¬¨‚àÄy(y Ãá= y). Thus, the conditional ‚àÄxŒ± ‚ÜíŒ±x
y is
‚àÄx¬¨‚àÄy(x Ãá= y) ‚Üí¬¨‚àÄy(y Ãá= y).
(3.13)
The hypothesis ‚àÄx¬¨‚àÄy(x Ãá=y) in (3.13) is equivalent to ‚àÄx‚àÉy(x
Ã∏Ãá= y), which is true in A. On
the other hand, the conclusion ¬¨‚àÄy(y Ãá= y) in (3.13) is equivalent to ‚àÉy(y
Ã∏Ãá= y), so it is false
in A. Thus, sentence (3.13) is also false in A. The problem here is that the substitution
(¬¨‚àÄy(x Ãá= y))x
y resulted in a variable being ‚Äúcaptured‚Äù by a quantifier.

96
‡±™
3 First-order logic
We conclude from Example 3.3.14 that when performing a substitution, we must
avoid capturing a variable by a quantifier. Thus, we must identify a specific restriction
that will prevent a variable from being so captured. A term will be said to be substi-
tutable for a variable in a formula if its substitution does not produce a captured vari-
able. The formal definition follows.
Definition 3.3.15 (Substitutable). Let ‚Ñíbe a language with variable x and term t. Then
‚Äút is substitutable for x in Œ±‚Äù is defined recursively as follows:
1.
t is always substitutable for x in Œ± when Œ± is an atomic formula;1
2.
t is substitutable for x in (¬¨Œ±) iff t is substitutable for x in Œ±;
3.
t is substitutable for x in (Œ± ‚ÜíŒ≤) iff t is substitutable for x in both Œ± and Œ≤;
4.
t is substitutable for x in (‚àÄvŒ±) iff either
(a) x does not occur free in (‚àÄvŒ±)2 or
(b) v does not occur in t and t is substitutable for x in Œ±.3
It follows from Definition 3.3.15 that a variable x is substitutable for x in every wff.
Remark. Given a wff Œ± and a term t, the operation Œ±x
t is always defined, but it may be
the case that t is not substitutable for x in Œ±. However, if a term t is a constant symbol or
contains no variables, then t will always be substitutable for x in Œ±.
Problem 3.3.16. Let ‚Ñí= {P, Q, f , g, c}, where P, Q are 2-place predicate symbols, f , g are
1-place function symbols, and c is a constant symbol. Let œÜ be the wff (Pxy ‚Üí‚àÄxQgxz)
and consider the term fx. Evaluate the wff œÜz
fx and decide if fx is substitutable for z in œÜ.
Solution. We evaluate œÜz
fx as follows:
œÜz
fx = (Pxy ‚Üí‚àÄxQgxz)z
fx
by definition of œÜ,
= Pxyz
fx ‚Üí(‚àÄxQgxz)z
fx
by Definition 3.3.13(3),
= Pxy ‚Üí(‚àÄxQgxz)z
fx
by Definition 3.3.13(1),
= Pxy ‚Üí‚àÄxQgxfx
by Definition 3.3.13(4).
Thus, œÜz
fx is the wff Pxy ‚Üí‚àÄxQgxfx. However, the term fx is not substitutable for z in œÜ
because fx is not substitutable for z in ‚àÄxQgxz by condition 4(b) of Definition 3.3.15 (x in
the term fx is captured by ‚àÄx).
1 There are no quantifiers in an atomic formula, so no variable in t can be captured.
2 In this case, (‚àÄvŒ±)x
t = ‚àÄvŒ±.
3 This ensures that the quantifier ‚Äú‚àÄv‚Äù does not capture any variable in t and that no variable in t will
get captured in Œ±x
t .

3.3 Deductions
‡±™
97
3.3.3 The logical axioms
There are some formulas in a first-order language that are logically valid, that is, these
formulas are satisfied by every structure and every assignment. Usually one selects a
minimal set of such formulas to be identified as the logical axioms. From a selected set
of logical axioms, one must be able to deduce all the other logically valid formulas. Our
discussions on first-order tautologies, generalizations, and substitutions will now allow
us to present a set Œõ of the logical axioms, which are arranged in six groups.
Logical Axioms 3.3.17. Let ‚Ñíbe a language of first-order logic. Let Œõ be the set of all
generalizations of wffs having the following forms, where x, y are any variables, Œ±, Œ≤ are
any wffs, and t is any term:
1.
first-order tautologies;
2.
‚àÄxŒ± ‚ÜíŒ±x
t , where t is substitutable for x in Œ±;
3.
‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄxŒ± ‚Üí‚àÄxŒ≤);
4.
Œ± ‚Üí‚àÄxŒ±, where x does not occur free in Œ±.
If the language ‚Ñíincludes the equality symbol Ãá=, then we add the following forms:
5.
x Ãá= x;
6.
x Ãá= y ‚Üí(Œ± ‚ÜíŒ±x
y), where Œ± is an atomic formula.
We shall call the resulting set Œõ the set of logical axioms.
We prove in Section 4.1 that every logical axiom in Œõ is logically valid (see Defini-
tion 3.2.17), that is, each logical axiom holds in all structures and for all assignments.
Remark (On the logical axioms). In Logical Axiom 1, the first-order tautologies will also
be called tautologies. They are included to handle the propositional connective sym-
bols. Logical Axiom 2 reflects the intended meaning of the quantifier symbol, that is, if
a statement is true of all objects in the domain, then the statement is true of an individ-
ual denoted by t. Logical Axioms 3 and 4 are used to prove the generalization theorem
(Theorem 3.3.29) later in this section. Logical Axioms 1 and 2 are used to deduce the im-
portant properties of equality (see Theorem 3.3.54). Logical Axiom 6 is an application of
Leibniz‚Äôs law: If two things are equal, then whatever is true of one is true of the other.
Generalizations of logical axioms are also logical axioms.
In the following problem, one is asked to identify whether or not a given wff is a
logical axiom.
Problem 3.3.18. Let ‚Ñí= {P, Q, R, c}, where P, Q are 1-place predicate symbols, R is a
2-place predicate symbol, and c is a constant symbol. To which logical axiom groups, if
any, do each of the following wffs belong?
1.
(‚àÉzPz ‚Üí‚àÄxQx) ‚Üí(¬¨‚àÄxQx ‚Üí¬¨‚àÉzPz).
2.
‚àÄx(‚àÄzPz ‚à®¬¨‚àÄzPz).

98
‡±™
3 First-order logic
3.
‚àÄzQz ‚ÜíQc.
4.
‚àÄx‚àÄzQz ‚ÜíQc.
5.
‚àÄx‚àÄyRxy ‚Üí‚àÄyRcy.
6.
‚àÄx‚àÄyRxy ‚Üí‚àÄyRyy.
7.
‚àÄx(‚àÉzPz ‚Üí‚àÄzPz) ‚Üí(‚àÄx‚àÉzPz ‚Üí‚àÄx‚àÄzPz).
8.
‚àÉzPz ‚Üí‚àÄx‚àÉzPz.
Solution.
1.
(‚àÉzPz ‚Üí‚àÄxQx) ‚Üí(¬¨‚àÄxQx ‚Üí¬¨‚àÉzPz)
The above wff belongs to axiom group 1. To verify this, let Œ± be the wff ‚àÉzPz and let
Œ≤ be the wff ‚àÄxQx. The above can then be written as
(Œ± ‚ÜíŒ≤) ‚Üí(¬¨Œ≤ ‚Üí¬¨Œ±),
which is a tautology.
2.
‚àÄx(‚àÄzPz ‚à®¬¨‚àÄzPz)
The above wff belongs to axiom group 1, since it is a generalization of a tautology.
To see this, let Œ± be the wff ‚àÄzPz. The above can then be written as a generalization
of (Œ± ‚à®¬¨Œ±), which is a tautology.
3.
‚àÄzQz ‚ÜíQc
This wff belongs to axiom group 2. To affirm this, let Œ± be the wff Qz. The above can
then be written as ‚àÄzŒ± ‚ÜíŒ±z
c and c is substitutable for z in Œ±.
4.
‚àÄx‚àÄzQz ‚ÜíQc
The above wff is not a logical axiom. Note that the above wff is not a generalization
of an axiom in group 2.
5.
‚àÄx‚àÄyRxy ‚Üí‚àÄyRcy
The given wff belongs to axiom group 2. To see this, let Œ± be the wff ‚àÄyRxy. The above
can then be written as ‚àÄxŒ± ‚ÜíŒ±x
c and c is substitutable for x in Œ±.
6.
‚àÄx‚àÄyRxy ‚Üí‚àÄyRyy
The above wff is not a logical axiom, for the following reason. Let Œ± be the wff ‚àÄyRxy.
Then the above wff has the form ‚àÄxŒ± ‚ÜíŒ±x
y. However, y is not substitutable for x in
Œ±. So, the above wff is not a logical axiom.
7.
‚àÄx(‚àÉzPz ‚Üí‚àÄzPz) ‚Üí(‚àÄx‚àÉzPz ‚Üí‚àÄx‚àÄzPz)
The above wff belongs to axiom group 3. To confirm this, let Œ± be the wff ‚àÉzPz and
let Œ≤ be the wff ‚àÄzPz. The above wff can then be written as
‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄxŒ± ‚Üí‚àÄxŒ≤).
8.
‚àÉzPz ‚Üí‚àÄx‚àÉzPz
This wff belongs to axiom group 4. To see this, let Œ± be the wff ‚àÉzPz. The above can
then be written as Œ± ‚Üí‚àÄxŒ± and x is not free in Œ±.

3.3 Deductions
‡±™
99
3.3.4 Formal deductions
A deduction in first-order logic, as in propositional logic, is going to be a finite list of
formulas that satisfies certain conditions.
Definition 3.3.19 (An inference rule). Let ‚Ñíbe a language of first-order logic. Let Œ± and
Œ≤ be wffs in the language ‚Ñí. Modus ponens is the rule of inference: From the formulas Œ±
and Œ± ‚ÜíŒ≤ we can infer Œ≤, that is,
Œ± ‚ÜíŒ≤
Œ±
‚à¥Œ≤
.
(modus ponens)
Definition 3.3.20. Let Œì be a set of formulas. A deduction of œÜ from Œì is a sequence
‚ü®Œ±1, . . . , Œ±n‚ü©of formulas such that Œ±n = œÜ and for all 1 ‚â§k ‚â§n, either
(a) Œ±k is in Œì ‚à™Œõ, or
(b) Œ±k is obtained by modus ponens from two earlier wffs in the sequence, that is, for
some i and j less than k, the wffs Œ±i and Œ±j = (Œ±i ‚ÜíŒ±k) are in the sequence.
Definition 3.3.21. Let Œì be a set of formulas. A formula œÜ is a theorem of Œì, denoted by
Œì ‚ä¢œÜ, if there is a deduction of œÜ from Œì. When Œì = {œà} we shall write œà ‚ä¢œÜ to denote
that there is a deduction of œÜ from the wff œà. When Œì = ‚åÄwe shall write ‚ä¢œÜ to denote
that there is a deduction of œÜ from the logical axioms alone.
In Definition 3.3.21, Œì can be viewed as a set of assumptions. The notation Œì ‚ä¢œÜ
means that one can deduce œÜ from the assumptions and the logical axioms.
Example 3.3.22. Let ‚Ñícontain two 1-place predicate symbols P, Q and a constant sym-
bol c. Let Œì = {‚àÄx(Px ‚ÜíQx), ‚àÄzPz}. Show that Œì ‚ä¢Qc.
Solution. A deduction of Qc from Œì (with explanation) is given below:
1.
‚àÄx(Px ‚ÜíQx)
in Œì,
2.
‚àÄzPz
in Œì,
3.
‚àÄx(Px ‚ÜíQx) ‚Üí(Pc ‚ÜíQc)
by Logical Axiom 2,
4.
‚àÄzPz ‚ÜíPc
by Logical Axiom 2,
5.
Pc ‚ÜíQc
from 1 and 3, by modus ponens,
6.
Pc
from 2 and 4, by modus ponens,
7.
Qc
from 5 and 6, by modus ponens.
Therefore, Œì ‚ä¢Qc.
Example 3.3.23. Let P be a 1-place predicate symbol. Show that ‚ä¢Px ‚Üí‚àÉxPx.

100
‡±™
3 First-order logic
Solution. A deduction of Px ‚Üí¬¨‚àÄx¬¨xPx (with explanation) is given below:
1.
‚àÄx¬¨Px ‚Üí¬¨Px
by Logical Axiom 2,
2.
(‚àÄx¬¨Px ‚Üí¬¨Px) ‚Üí(Px ‚Üí¬¨‚àÄx¬¨Px)
by Logical Axiom 1,
3.
Px ‚Üí¬¨‚àÄx¬¨Px
from 1 and 2, by modus ponens.
Since ¬¨‚àÄx¬¨Px is abbreviated by ‚àÉxPx, we conclude that ‚ä¢Px ‚Üí‚àÉxPx.
In the above step 1 we used ¬¨Px as Œ± and t = x in Logical Axiom 2, that is, ‚àÄxŒ± ‚ÜíŒ±x
x
is the instance of Logical Axiom 2 that we used. Moreover, in step 2 we used the tautology
(A ‚Üí¬¨B) ‚Üí(B ‚Üí¬¨A).
Example 3.3.24. Let P be a 1-place predicate symbol. Show that ‚ä¢‚àÄx(Px ‚Üí‚àÉyPy).
Solution. A deduction of ‚àÄx(Px ‚Üí¬¨‚àÄy¬¨Py) (with explanation) is given below:
1.
‚àÄx(‚àÄy¬¨Py ‚Üí¬¨Px)
Logical Axiom 2 (gen),
2.
‚àÄx( (‚àÄy¬¨Py ‚Üí¬¨Px) ‚Üí(Px ‚Üí¬¨‚àÄy¬¨Py) )
Logical Axiom 1 (gen),
3.
‚àÄx( (‚àÄy¬¨Py ‚Üí¬¨Px) ‚Üí(Px ‚Üí¬¨‚àÄy¬¨Py) )
‚Üí( ‚àÄx(‚àÄy¬¨Py ‚Üí¬¨Px) ‚Üí‚àÄx(Px ‚Üí¬¨‚àÄy¬¨Py) )
Logical Axiom 3,
4.
‚àÄx(‚àÄy¬¨Py ‚Üí¬¨Px) ‚Üí‚àÄx(Px ‚Üí¬¨‚àÄy¬¨Py)
modus ponens: 2 and 3,
5.
‚àÄx(Px ‚Üí¬¨‚àÄy¬¨Py)
modus ponens: 1 and 4.
Thus, ‚ä¢‚àÄx(Px ‚Üí‚àÉyPy).
In the above solution, ‚Äúgen‚Äù means ‚Äúgeneralization.‚Äù In step 1 we used ¬¨Py as Œ± and
t = x in Logical Axiom 2, that is, ‚àÄyŒ± ‚ÜíŒ±y
x is the instance of Logical Axiom 2 we applied.
In step 2 we used the tautology (A ‚Üí¬¨B) ‚Üí(B ‚Üí¬¨A). In step 3 we used (‚àÄy¬¨Py ‚Üí¬¨Px)
as Œ± and (Px ‚Üí¬¨‚àÄy¬¨Py) as Œ≤ in Logical Axiom 3.
Example 3.3.25. Let ‚Ñíhave a 1-place predicate symbol Q. Show that ‚àÄyQy ‚ä¢‚àÄxQx.
Solution. A deduction of ‚àÄxQx from ‚àÄyQy (with explanation) is given below:
1.
‚àÄyQy
given,
2.
‚àÄx(‚àÄyQy ‚ÜíQx)
Logical Axiom 2 (gen),
3.
‚àÄyQy ‚Üí‚àÄx‚àÄyQy
Logical Axiom 4,
4.
‚àÄx(‚àÄyQy ‚ÜíQx) ‚Üí(‚àÄx‚àÄyQy ‚Üí‚àÄxQx)
Logical Axiom 3,
5.
‚àÄx‚àÄyQy ‚Üí‚àÄxQx
modus ponens: 2 and 4,
6.
‚àÄx‚àÄyQy
modus ponens: 1 and 3,
7.
‚àÄxQx
modus ponens: 5 and 6.
So ‚àÄyQy ‚ä¢‚àÄxQx.
All of the standard proof techniques that are used in mathematics hold for deduc-
tions as well; for example, ‚Äúproof by contradiction‚Äù can be used to show that a deduction
exists in first-order logic (see Corollary 3.3.37 below).

3.3 Deductions
‡±™
101
We will now present and prove lemmas and theorems about deductions. In our first
such result we identify some useful observations about deductions. Each item in the
following lemma follows directly from Definition 3.3.20.
Lemma 3.3.26. Let Œì be a set of formulas and let Œ±, Œ≤, Œ¥, and Œ≥ be formulas.
1.
If Œ± ‚ààŒì or Œ± ‚ààŒõ, then Œì ‚ä¢Œ±.
2.
If ‚ä¢Œ±, then Œì ‚ä¢Œ±.
3.
If Œ± ‚ä¢Œ≤ and Œ≤ ‚ä¢Œ≥, then Œ± ‚ä¢Œ≥.
4.
If Œì ‚ä¢Œ± and Œ± ‚ä¢Œ≤, then Œì ‚ä¢Œ≤.
5.
If Œì ‚ä¢Œ¥ and Œì ‚ä¢(Œ¥ ‚ÜíŒ≤), then Œì ‚ä¢Œ≤.
The proof of our next result can be seen as an application of the compactness theo-
rem of propositional logic.
Theorem 3.3.27. Let Œì be a set of wffs of first-order logic and let œÜ be a wff of first-order
logic. Then Œì ‚ä¢œÜ if and only if Œì ‚à™Œõ tautologically implies œÜ.
Proof. (‚áí): Assume that Œì ‚ä¢œÜ. We shall show that Œì ‚à™Œõ tautologically implies œÜ. Let
‚ü®Œ±1, Œ±2, . . . , Œ±n‚ü©be a deduction of œÜ from the set Œì of wffs. We shall prove the following
statement: For all k ‚â§n, Œì‚à™Œõ tautologically implies Œ±k. We shall use strong induction on
the natural number variable k.
Base step: Let k = 1. Since Œ±1 is the first step in the deduction, we must have Œ±1 ‚ààŒì ‚à™Œõ.
Thus, Œì ‚à™Œõ tautologically implies Œ±1.
Inductive step: Assume the strong induction hypothesis
Œì ‚à™Œõ tautologically implies Œ±i for all i < k.
(SIH)
We show that Œì‚à™Œõ tautologically implies Œ±k. As Œ±k is in the deduction, either (a) Œ±k ‚ààŒì‚à™Œõ
or (b) Œ±k is obtained by modus ponens from some Œ±i and Œ±j = (Œ±i ‚ÜíŒ±k), where i, j < k.
If (a) holds, then Œì ‚à™Œõ tautologically implies Œ±k just as in the above base step. If (b)
holds, then by the strong induction hypothesis (SIH), we conclude that Œì‚à™Œõ tautologically
implies Œ±i and Œì ‚à™Œõ tautologically implies (Œ±i ‚ÜíŒ±k). Hence, Œì ‚à™Œõ tautologically implies
Œ±k (see page 35).
(‚áê): Assume that Œì ‚à™Œõ tautologically implies œÜ. As Œì ‚à™Œõ tautologically implies œÜ,
Corollary 3.3.11 implies that there exists a finite subset Œì0 of Œì ‚à™Œõ such that Œì0 tautolog-
ically implies œÜ. Since Œì0 is finite, let Œì0 = {Œ≥1, Œ≥2, . . . , Œ≥n}. It follows (see Exercise 6 on
page 51) that
Œ≥1 ‚ÜíŒ≥2 ‚Üí‚ãÖ‚ãÖ‚ãÖ‚ÜíŒ≥n ‚ÜíœÜ
is a tautology. By repeated use of modus ponens, it easily follows that Œì0 ‚ä¢œà. As Œì0 ‚äÜŒì,
we conclude that Œì ‚ä¢œÜ.

102
‡±™
3 First-order logic
Note that the above Theorem 3.3.27 was established by giving a mathematical proof
in English. That is, we proved a theorem about deductions. Hence, one is now in a po-
sition to prove theorems about ‚Äúmathematical proof.‚Äù It is generally accepted that all
proofs in classical mathematics can be expressed as a deduction in first-order logic.
Thus, one can now ask and answer questions about the limits of mathematical proof.
3.3.5 Metatheorems about deductions
If Œì ‚ä¢Œ±, then we say that Œ± is a theorem of Œì. However, we have also been using the word
‚Äútheorem‚Äù in a different way when proving theorems in English about deductions. These
English theorems are sometimes referred to as being metatheorems to emphasize that
they are statements in English about deductions and first-order logic.
We now pose a question about deductions.
How can we show that a deduction exists without actually giving one?
Answer: One must first prove metatheorems about deductions.
Induction on deductions
Let S be a set of wffs. Then S is said to be closed under modus ponens if whenever Œ± ‚ààS
and (Œ± ‚ÜíŒ≤) ‚ààS, we have Œ≤ ‚ààS. Since there is a procedure for building all the theorems
of Œì using the formulas in Œì ‚à™Œõ and applying modus ponens, we have the following
induction principle.
Theorem 3.3.28 (Induction principle). Let S be a set of wffs such that:
(1) Œì ‚à™Œõ ‚äÜS,
(2) S is closed under modus ponens.
Then {œÜ : Œì ‚ä¢œÜ} ‚äÜS, that is, S contains all the theorems of Œì.
Proof. Let S and Œì be as stated. Assume that Œì ‚ä¢œÜ. Now let ‚ü®Œ±1, Œ±2, . . . , Œ±n‚ü©be a deduction
of œÜ from the set Œì of wffs. Thus, Œ±n = œÜ. We shall prove that for all k ‚â§n, Œ±k ‚ààS. We
shall use strong induction on the natural number variable k.
Base step: Let k = 1. Since Œ±1 is the first step in the deduction, we must have Œ±1 ‚ààŒì ‚à™Œõ.
Thus, Œ±1 ‚ààS by (1).
Inductive step: Assume the strong induction hypothesis
Œ±i ‚ààS for all i < k.
(SIH)
We show that Œ±k ‚ààS. As Œ±k is in the deduction, either (a) Œ±k ‚ààŒì‚à™Œõ or (b) Œ±k is obtained by
modus ponens from some Œ±i and Œ±j = (Œ±i ‚ÜíŒ±k), where i, j < k. If (a) holds, then Œ±k ‚ààS.

3.3 Deductions
‡±™
103
If (b) holds, then by the induction hypothesis we see that Œ±i ‚ààS and (Œ±i ‚ÜíŒ±k) ‚ààS. By
(2), S is closed under modus ponens. Hence, Œ±k ‚ààS. Therefore, for all k ‚â§n, Œ±k ‚ààS. In
particular, œÜ ‚ààS.
Theorem 3.3.28 validates the following strategy, which will allow us to prove results
about formulas œÜ that are deducible from a set of wffs Œì.
Proof Strategy. Let ùïä(œÜ) be a statement about a wff œÜ. In order to prove an assertion
‚Äúfor all wffs œÜ, if Œì ‚ä¢œÜ, then ùïä(œÜ)‚Äù by induction, use the following diagram:
Base step:
Prove ùïä(œï) for all formulas œï ‚ààŒì ‚à™Œõ.
Inductive step:
Let Œ± and Œ≤ be wffs.
Assume ùïä(Œ±) and ùïä(Œ± ‚ÜíŒ≤).
Prove ùïä(Œ≤).
The above proof strategy is Theorem 3.3.28 applied to the set S = {œÜ is a wff : ùïä(œÜ)}.
We will apply this strategy in the proof of our next theorem, where ùïä(œÜ) is ‚ÄúŒì ‚ä¢‚àÄxœÜ.‚Äù In
this proof we will tacitly be using Lemma 3.3.26.
Theorem 3.3.29 (Generalization theorem). Suppose that x does not occur free in any for-
mula in Œì. For all wffs œÜ, if Œì ‚ä¢œÜ, then Œì ‚ä¢‚àÄxœÜ.
Proof. Assume that the variable x does not occur free in any formula in Œì. Using the
induction principle, we shall prove the following: For all wffs œÜ, if Œì ‚ä¢œÜ, then Œì ‚ä¢‚àÄxœÜ.
Base step: Let œï be in Œì ‚à™Œõ. If œï ‚ààŒì, then x does not occur free in œï. Thus, (œï ‚Üí‚àÄxœï)
is in axiom group 4 of the logical axioms (page 97). Since Œì ‚ä¢œï and Œì ‚ä¢(œï ‚Üí‚àÄxœï), we
conclude (by modus ponens) that Œì ‚ä¢‚àÄxœï. If œï ‚ààŒõ, then œï is a logical axiom. Thus, the
generalization ‚àÄxœï is also a logical axiom. Therefore, Œì ‚ä¢‚àÄxœï.
Inductive step: Let Œ± and Œ≤ be wffs. Assume the induction hypothesis
Œì ‚ä¢‚àÄxŒ±
and
Œì ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤).
(IH)
We need to prove that Œì ‚ä¢‚àÄxŒ≤. Note that (Û≥µ≥) ‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄxŒ± ‚Üí‚àÄxŒ≤) is in axiom
group 3 of the logical axioms. By (IH) we have Œì ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤) and Œì ‚ä¢‚àÄxŒ±. Thus, by
applying modus ponens twice to (Û≥µ≥), we have Œì ‚ä¢‚àÄxŒ≤.
A converse of the generalization theorem (Theorem 3.3.29) holds, whether or not x
occurs free in a formula in Œì.
Theorem 3.3.30. For all wffs œÜ, if Œì ‚ä¢‚àÄxœÜ, then Œì ‚ä¢œÜ.
Proof. Assume that Œì ‚ä¢‚àÄxœÜ. By Logical Axiom 2, we have Œì ‚ä¢(‚àÄxœÜ ‚ÜíœÜ). Thus, by
modus ponens, we conclude that Œì ‚ä¢œÜ.
Given that certain deductions exist, the following ‚Äútautology rule‚Äù allows one to
show that another deduction exists.

104
‡±™
3 First-order logic
Theorem 3.3.31 (Rule T). If Œì ‚ä¢Œ±1, . . . , Œì ‚ä¢Œ±n and {Œ±1, . . . , Œ±n} tautologically implies Œ≤,
then Œì ‚ä¢Œ≤.
Proof. Assume that Œì ‚ä¢Œ±1, . . . , Œì ‚ä¢Œ±n and that {Œ±1, . . . , Œ±n} tautologically implies Œ≤. Thus,
Œ±1 ‚ÜíŒ±2 ‚Üí‚ãÖ‚ãÖ‚ãÖ‚ÜíŒ±n ‚ÜíŒ≤ is a tautology (see Exercise 6 on page 51), so it is in axiom
group 1 of the logical axioms. Since Œì ‚ä¢Œ±1, . . . , Œì ‚ä¢Œ±n, we conclude that Œì ‚ä¢Œ≤ by applying
modus ponens n times.
Note that ¬¨(œà ‚ÜíŒ∏) tautologically implies œà and ¬¨Œ∏ and that {œà, ¬¨Œ∏} tautologically
implies ¬¨(œà ‚ÜíŒ∏). We therefore have the following corollary.
Corollary 3.3.32. We have Œì ‚ä¢¬¨(œà ‚ÜíŒ∏) if and only if Œì ‚ä¢œà and Œì ‚ä¢¬¨Œ∏.
In order to simplify our notation, we shall write Œì; œà as an abbreviation for Œì ‚à™{œà}.
Theorem 3.3.33 (Deduction theorem). Let Œì be a set of wffs and Œ≥, œÜ be wffs. Then Œì; Œ≥ ‚ä¢œÜ
if and only if Œì ‚ä¢(Œ≥ ‚ÜíœÜ).
Proof. Let Œì be a set of wffs and let Œ≥, œÜ be wffs. Then
Œì; Œ≥ ‚ä¢œÜ
iff
Œì; Œ≥ ‚à™Œõ tautologically implies œÜ
by Theorem 3.3.27,
iff
Œì ‚à™Œõ tautologically implies (Œ≥ ‚ÜíœÜ)
by Exercise 9 on page 38,
iff
Œì ‚ä¢(Œ≥ ‚ÜíœÜ)
by Theorem 3.3.27.
Thus, to deduce a conditional, one can assume the hypothesis and then deduce the
conclusion, just like in mathematics.
Corollary 3.3.34. Let Œì be a set of wffs. If Œ± and Œ≤ are tautologically equivalent, then:
(1) Œì ‚ä¢Œ± iff Œì ‚ä¢Œ≤,
(2) Œì; Œ± ‚ä¢œÜ iff Œì; Œ≤ ‚ä¢œÜ, for any wff œÜ.
Proof. Let Œì be a set of wffs and let Œ± and Œ≤ be wffs that are tautologically equivalent.
Thus, Œ± ‚ÜíŒ≤ and Œ≤ ‚ÜíŒ± are tautologies. To prove (1), assume that Œì ‚ä¢Œ±. Since Œ± ‚ÜíŒ≤ is
a tautology, we see that Œì ‚ä¢Œ≤. The converse holds in a similar fashion.
To prove (2), let œÜ be a wff. Since Œ± and Œ≤ are tautologically equivalent, it follows
that (Û≥µ≥) Œ± ‚ÜíœÜ and Œ≤ ‚ÜíœÜ are tautologically equivalent. Thus,
Œì; Œ± ‚ä¢œÜ
iff
Œì ‚ä¢(Œ± ‚ÜíœÜ)
by Theorem 3.3.33,
iff
Œì ‚ä¢(Œ≤ ‚ÜíœÜ)
by (1) and (Û≥µ≥),
iff
Œì; Œ≤ ‚ä¢œÜ
by Theorem 3.3.33.
Corollary 3.3.35 (Contraposition). We have Œì; œÜ ‚ä¢¬¨œà iff Œì; œà ‚ä¢¬¨œÜ.
Proof. Let Œì be a set of wffs and let œÜ, œà be wffs. Since
(œÜ ‚Üí¬¨œà) and (œà ‚Üí¬¨œÜ) are tautologically equivalent,
(Û≥µ≥)

3.3 Deductions
‡±™
105
we have
Œì; œÜ ‚ä¢¬¨œà
iff
Œì ‚ä¢(œÜ ‚Üí¬¨œà)
by Theorem 3.3.33,
iff
Œì ‚ä¢(œà ‚Üí¬¨œÜ)
by Corollary 3.3.34(1) and (Û≥µ≥),
iff
Œì; œà ‚ä¢¬¨œÜ
by Theorem 3.3.33.
Definition 3.3.36. A set Œì of wffs is consistent if there is no formula Œ≤ such that Œì ‚ä¢Œ≤
and Œì ‚ä¢¬¨Œ≤; Œì is inconsistent if Œì ‚ä¢Œ≤ and Œì ‚ä¢¬¨Œ≤ for some formula Œ≤.
If a set of wffs Œì is inconsistent, then for any wff Œ±, we have Œì ‚ä¢Œ±. The reason for
this follows. Let Œ≤ such that Œì ‚ä¢Œ≤ and Œì ‚ä¢¬¨Œ≤. Since Œ≤ ‚Üí(¬¨Œ≤ ‚ÜíŒ±) is a tautology, it
follows that Œì ‚ä¢Œ± via modus ponens.
Proof by contradiction is often used in mathematical proofs. It can also be used in
first-order logic to show that a deduction exists.
Corollary 3.3.37 (Reductio ad absurdum). If Œì; œÜ is inconsistent, then Œì ‚ä¢¬¨œÜ.
Proof. Assume that Œì; œÜ is inconsistent. So, there is a formula Œ≤ such that Œì; œÜ ‚ä¢Œ≤ and
Œì; œÜ ‚ä¢¬¨Œ≤. Thus, Œì ‚ä¢(œÜ ‚ÜíŒ≤) and Œì ‚ä¢(œÜ ‚Üí¬¨Œ≤) by the deduction theorem. Since
{œÜ ‚ÜíŒ≤, œÜ ‚Üí¬¨Œ≤} tautologically implies ¬¨œÜ, we conclude that Œì ‚ä¢¬¨œÜ by Rule T.
Theorem 3.3.38. If a set of formulas Œì is inconsistent, then a finite subset of Œì is inconsis-
tent.
Proof. See Exercise 12.
Strategies to show that deductions exist
To show that a deduction exists without having to explicitly present a deduction, one
may be able to use the following eight deduction strategies:
(S1) To show that Œì ‚ä¢(œà ‚ÜíŒ∏), it is sufficient to show that Œì; œà ‚ä¢Œ∏, by the deduction
theorem.
(S2) To show that Œì; ¬¨œà ‚ä¢¬¨Œ∏, it is sufficient to show that Œì; Œ∏ ‚ä¢œà, by contraposition.
Also, Œì; Œ± ‚ä¢¬¨‚àÄxœà iff Œì; ‚àÄxœà ‚ä¢¬¨Œ±.
(S3) To show that Œì ‚ä¢‚àÄxœà, it is sufficient to show that Œì ‚ä¢œà when x does not occur free
in Œì, by the generalization theorem (Theorem 3.3.29).
(S4) To show that Œì ‚ä¢¬¨(œà ‚ÜíŒ∏), it is sufficient to show that Œì ‚ä¢œà and Œì ‚ä¢¬¨Œ∏, by Rule T
and the fact that {œà, ¬¨Œ∏} tautologically implies ¬¨(œà ‚ÜíŒ∏).
(S5) To show that Œì ‚ä¢¬¨¬¨œà, it is sufficient to show that Œì ‚ä¢œà, by Rule T and the fact that
{œà} tautologically implies ¬¨¬¨œà.
(S6) To show that Œì ‚ä¢¬¨œà, it is sufficient to show that Œì; œà is inconsistent, by reductio ad
absurdum.
(S7) To show that Œì ‚ä¢¬¨‚àÄxœà, it is sufficient to show that Œì ‚ä¢¬¨œàx
t for some term t. Note
that Œì ‚ä¢(¬¨œàx
t ‚Üí¬¨‚àÄxœà) by Logical Axiom 2 and Corollary 3.3.34(1). Thus, Œì ‚ä¢¬¨‚àÄxœà
would follow by modus ponens. (If this is not useful, try (S6).)

106
‡±™
3 First-order logic
(S8) To show that Œì; ‚àÄyŒ± ‚ä¢¬¨‚àÄxœà, try to show that Œì; ‚àÄxœà ‚ä¢¬¨Œ±. Thus, Œì; Œ± ‚ä¢¬¨‚àÄxœà, and
since ‚àÄyŒ± ‚ÜíŒ± is a logical axiom, we have Œì; ‚àÄyŒ± ‚ä¢¬¨‚àÄxœà. Now apply contraposition,
Corollary 3.3.35, to conclude that Œì; ‚àÄyŒ± ‚ä¢¬¨‚àÄxœà.
Problem 3.3.39. Using the above strategies, show that:
(1) ‚ä¢‚àÄxPx ‚Üí‚àÉxPx,
(2) ‚àÄx‚àÄyPxy ‚ä¢‚àÄy‚àÄzPzy,
(3) ‚àÄxPx ‚ä¢‚àÄxQx ‚Üí‚àÄx¬¨(Px ‚Üí¬¨Qx).
Solution. For each of the above items, we will show that such a deduction exists.
(1) To show that ‚ä¢‚àÄxPx ‚Üí‚àÉxPx, we will apply (S1). By the deduction theorem, we
just need to show that ‚àÄxPx ‚ä¢‚àÉxPx. Theorem 3.3.30 implies that ‚àÄxPx ‚ä¢Px. By
Example 3.3.23 on page 99 and the deduction theorem, we have Px ‚ä¢‚àÉxPx. Since
‚àÄxPx ‚ä¢Px and Px ‚ä¢‚àÉxPx, Lemma 3.3.26(4) implies that ‚àÄxPx ‚ä¢‚àÉxPx. Therefore,
‚ä¢‚àÄxPx ‚Üí‚àÉxPx.
(2) We shall show that ‚àÄx‚àÄyPxy ‚ä¢‚àÄy‚àÄzPzy. Two applications of Logical Axiom 2 and
modus ponens shows that ‚àÄx‚àÄyPxy ‚ä¢Pzy. Since z is not free in ‚àÄx‚àÄyPxy, we see
that ‚àÄx‚àÄyPxy ‚ä¢‚àÄzPzy, by applying (S3). Similarly, as y is not free in ‚àÄx‚àÄyPxy, we
conclude that ‚àÄx‚àÄyPxy ‚ä¢‚àÄy‚àÄzPzy.
(3) We will show that ‚àÄxPx ‚ä¢‚àÄxQx ‚Üí‚àÄx¬¨(Px ‚Üí¬¨Qx). By the deduction theorem, it
is sufficient to show that {‚àÄxPx, ‚àÄxQx} ‚ä¢‚àÄx¬¨(Px ‚Üí¬¨Qx). So by strategy (S3), we
just need to show that {‚àÄxPx, ‚àÄxQx} ‚ä¢¬¨(Px ‚Üí¬¨Qx). By Logical Axiom 2 and modus
ponens, we see that
{‚àÄxPx, ‚àÄxQx} ‚ä¢Px and {‚àÄxPx, ‚àÄxQx} ‚ä¢Qx.
Thus, {‚àÄxPx, ‚àÄxQx} ‚ä¢Px, and {‚àÄxPx, ‚àÄxQx} ‚ä¢¬¨¬¨Qx by Corollary 3.3.34(1). Applying
strategy (S4), we conclude that {‚àÄxPx, ‚àÄxQx} ‚ä¢¬¨(Px ‚Üí¬¨Qx). Therefore, ‚àÄxPx ‚ä¢
‚àÄxQx ‚Üí‚àÄx¬¨(Px ‚Üí¬¨Qx).
Problem 3.3.40. Show that ‚ä¢‚àÉx‚àÄyœÜ ‚Üí‚àÄy‚àÉxœÜ.
Solution. We will show that a deduction of ‚àÉx‚àÄyœÜ ‚Üí‚àÄy‚àÉxœÜ exists. By the deduction the-
orem it is sufficient to show that ‚àÉx‚àÄyœÜ ‚ä¢‚àÄy‚àÉxœÜ. Hence, by the generalization theorem
(Theorem 3.3.29), it is sufficient to show that ‚àÉx‚àÄyœÜ ‚ä¢‚àÉxœÜ. Removing the abbreviations,
we need to show that ¬¨‚àÄx¬¨‚àÄyœÜ ‚ä¢¬¨‚àÄx¬¨œÜ. By contraposition, this reduces to showing
that ‚àÄx¬¨œÜ ‚ä¢‚àÄx¬¨‚àÄyœÜ (see Corollary 3.3.35). So, by the generalization theorem (Theo-
rem 3.3.29), we must show that ‚àÄx¬¨œÜ ‚ä¢¬¨‚àÄyœÜ and thus, by reductio ad absurdum, it is
now sufficient to show that Œ£ = {‚àÄx¬¨œÜ, ‚àÄyœÜ} is inconsistent. Note that Œ£ ‚ä¢¬¨œÜ and Œ£ ‚ä¢œÜ
by Logical Axiom 2 and modus ponens. Hence, Œ£ is inconsistent. Therefore, it follows
that there is a deduction of ‚àÉx‚àÄyœÜ ‚Üí‚àÄy‚àÉxœÜ.
Proposition 3.3.41. Let Œ± be a wff. Then ‚ä¢¬¨‚àÄxŒ± ‚Üî‚àÉx¬¨Œ± and ‚ä¢¬¨‚àÉxŒ± ‚Üî‚àÄx¬¨Œ±.

3.3 Deductions
‡±™
107
Proposition 3.3.42. If x does not occur free in Œ±, then
‚ä¢(Œ± ‚Üí‚àÄxŒ≤) ‚Üî‚àÄx(Œ± ‚ÜíŒ≤).
Proof. By Rule T, it is sufficient to show that
‚ä¢(Œ± ‚Üí‚àÄxŒ≤) ‚Üí‚àÄx(Œ± ‚ÜíŒ≤),
(‚ãÜ)
‚ä¢‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(Œ± ‚Üí‚àÄxŒ≤).
(‚ãÜ‚ãÜ)
To prove (‚ãÜ), by the deduction theorem, we must show that
(Œ± ‚Üí‚àÄxŒ≤) ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤).
By assumption, x does not occur free in Œ±. Hence, x does not occur free in (Œ± ‚Üí‚àÄxŒ≤).
Therefore, by Theorem 3.3.29, it is now enough to show that (Œ± ‚Üí‚àÄxŒ≤) ‚ä¢(Œ± ‚ÜíŒ≤).
Again, by the deduction theorem, it is enough to show that {(Œ± ‚Üí‚àÄxŒ≤), Œ±} ‚ä¢Œ≤. Let
Œì = {(Œ± ‚Üí‚àÄxŒ≤), Œ±}. We argue that Œì ‚ä¢Œ≤ as follows:
(1)
Œì ‚ä¢Œ± ‚Üí‚àÄxŒ≤
in Œì,
(2)
Œì ‚ä¢Œ±
in Œì,
(3)
Œì ‚ä¢‚àÄxŒ≤
by (1), (2), and modus ponens,
(4)
Œì ‚ä¢‚àÄxŒ≤ ‚ÜíŒ≤
by Logical Axiom 2,
(5)
Œì ‚ä¢Œ≤
by (3), (4), and modus ponens.
This completes the proof of (‚ãÜ). Note that the above list (1)‚Äì(5) is not a deduction. It is
just part of a proof showing that a deduction of (‚ãÜ) exists.
To establish (‚ãÜ‚ãÜ), we need to show, by the deduction theorem, that
‚àÄx(Œ± ‚ÜíŒ≤) ‚ä¢(Œ± ‚Üí‚àÄxŒ≤).
So, again by the deduction theorem, we must show that {‚àÄx(Œ± ‚ÜíŒ≤), Œ±} ‚ä¢‚àÄxŒ≤. Since x
does not occur free in ‚àÄx(Œ± ‚ÜíŒ≤) or in Œ±, the generalization theorem (Theorem 3.3.29)
implies that we just need to show {‚àÄx(Œ± ‚ÜíŒ≤), Œ±} ‚ä¢Œ≤. Let Œì = {‚àÄx(Œ± ‚ÜíŒ≤), Œ±}. We show
that Œì ‚ä¢Œ≤ as follows:
(1)
Œì ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤)
in Œì,
(2)
Œì ‚ä¢Œ±
in Œì,
(3)
Œì ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(Œ± ‚ÜíŒ≤)
by Logical Axiom 2,
(4)
Œì ‚ä¢Œ± ‚ÜíŒ≤
by (1), (3), and modus ponens,
(5)
Œì ‚ä¢Œ≤
by (2), (4), and modus ponens.
Proposition 3.3.43. If x is not free in Œ±, then ‚ä¢(Œ± ‚Üí‚àÉxŒ≤) ‚Üî‚àÉx(Œ± ‚ÜíŒ≤).

108
‡±™
3 First-order logic
Proposition 3.3.44. If x is not free in Œ≤, then ‚ä¢(‚àÄxŒ± ‚ÜíŒ≤) ‚Üî‚àÉx(Œ± ‚ÜíŒ≤).
Proposition 3.3.45. If x is not free in Œ≤, then ‚ä¢(‚àÉxŒ± ‚ÜíŒ≤) ‚Üî‚àÄx(Œ± ‚ÜíŒ≤).
Proof. By Rule T, it is sufficient to show that
‚ä¢(‚àÉxŒ± ‚ÜíŒ≤) ‚Üí‚àÄx(Œ± ‚ÜíŒ≤),
(‚ãÜ)
‚ä¢‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(‚àÉxŒ± ‚ÜíŒ≤).
(‚ãÜ‚ãÜ)
We shall first prove (‚ãÜ). It is sufficient to show that
(‚àÉxŒ± ‚ÜíŒ≤) ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤),
(3.14)
by the deduction theorem. By assumption, x does not occur free in Œ≤. Thus, x does not
occur free in (‚àÉxŒ± ‚ÜíŒ≤). To establish (3.14), the generalization theorem (Theorem 3.3.29)
implies that it is enough to verify that (‚àÉxŒ± ‚ÜíŒ≤) ‚ä¢(Œ± ‚ÜíŒ≤). Again, by the deduction
theorem, we now just need to show that {(‚àÉxŒ± ‚ÜíŒ≤), Œ±} ‚ä¢Œ≤. Let Œì = {(‚àÉxŒ± ‚ÜíŒ≤), Œ±}.
Thus, as ‚àÉxŒ± is an abbreviation for ¬¨‚àÄx¬¨Œ±, we have
(1)
Œì ‚ä¢¬¨‚àÄx¬¨Œ± ‚ÜíŒ≤
in Œì,
(2)
Œì ‚ä¢Œ±
in Œì,
(3)
Œì ‚ä¢‚àÄx¬¨Œ± ‚Üí¬¨Œ±
by Logical Axiom 2,
(4)
Œì ‚ä¢Œ± ‚Üí¬¨‚àÄx¬¨Œ±
by (3) and Corollary 3.3.34(1),
(5)
Œì ‚ä¢¬¨‚àÄx¬¨Œ±
by (2), (4), and modus ponens,
(6)
Œì ‚ä¢Œ≤
by (1), (5), and modus ponens.
In (4) we used the fact that (‚àÄx¬¨Œ± ‚Üí¬¨Œ±) and (Œ± ‚Üí¬¨‚àÄx¬¨Œ±) are tautologically equivalent.
We shall now prove (‚ãÜ‚ãÜ). By the deduction theorem we need to show that
‚àÄx(Œ± ‚ÜíŒ≤) ‚ä¢(‚àÉxŒ± ‚ÜíŒ≤).
So, by the deduction theorem and contraposition, it is sufficient to show that
{‚àÄx(Œ± ‚ÜíŒ≤), ¬¨Œ≤} ‚ä¢¬¨‚àÉxŒ±.
By Corollary 3.3.34(1), we only need to show that
{‚àÄx(Œ± ‚ÜíŒ≤), ¬¨Œ≤} ‚ä¢‚àÄx¬¨Œ±.
Since x does not occur free in Œ≤, we see that x does not occur free in any formula in the
set {‚àÄx(Œ± ‚ÜíŒ≤), ¬¨Œ≤}. So, by the generalization theorem (Theorem 3.3.29), it is enough to
show that
{‚àÄx(Œ± ‚ÜíŒ≤), ¬¨Œ≤} ‚ä¢¬¨Œ±.

3.3 Deductions
‡±™
109
Furthermore, by contraposition, we just need to show that
{‚àÄx(Œ± ‚ÜíŒ≤), Œ±} ‚ä¢Œ≤.
Let Œì = {‚àÄx(Œ± ‚ÜíŒ≤), Œ±}. We show that Œì ‚ä¢Œ≤ as follows:
(1)
Œì ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤)
in Œì,
(2)
Œì ‚ä¢Œ±
in Œì,
(3)
Œì ‚ä¢‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(Œ± ‚ÜíŒ≤)
by Logical Axiom 2,
(4)
Œì ‚ä¢Œ± ‚ÜíŒ≤
by (1), (3), and modus ponens,
(5)
Œì ‚ä¢Œ≤
by (2), (4), and modus ponens.
The following theorem can be useful to show that certain deductions exist.
Theorem 3.3.46. Let Œ± and Œ≤ be wffs. If ‚ä¢Œ± ‚ÜíŒ≤, then ‚ä¢‚àÄxŒ± ‚Üí‚àÄxŒ≤.
3.3.6 Equality
As you may recall, the logical axioms have two groups of axioms that concern equality.
However, as yet, we have not discussed deductions that involve the equality symbol Ãá=.
In this section, we will examine deductions in languages ‚Ñíthat contain the equality
symbol. Using the logical axioms, we will show that all of the common properties of
equality can be deduced from the axioms. One should go to page 97 and review the
logical axioms and the equality axioms before continuing.
Proposition 3.3.47. We have ‚ä¢‚àÄx(x Ãá= x).
Proof. Since x Ãá= x is a logical axiom, ‚àÄx(x Ãá= x) is also a logical axiom by generalization
(a generalization of a logical axiom is a logical axiom).
Proposition 3.3.48. Let Œì be any set of wffs and let t be a term. Then Œì ‚ä¢t Ãá= t.
Proof. The following holds for any set Œì, even the empty set:
(1)
Œì ‚ä¢‚àÄx(x Ãá= x)
by Proposition 3.3.47,
(2)
Œì ‚ä¢‚àÄx(x Ãá= x) ‚Üít Ãá= t
by Logical Axiom 2,
(3)
Œì ‚ä¢t Ãá= t
by (1), (2), and modus ponens.
In (2) we are using x Ãá= x as Œ± in Logical Axiom 2 and (x Ãá= x)x
t is t Ãá= t.
Before we prove our next result, we introduce some temporary notation. Let Œ± be an
atomic formula. The formula Œ± may have multiple occurrences of a particular variable,
say x. To identify all of the occurrences of x that appear in Œ±, we shall use the nota-
tion Œ±(x, . . . , x). In our next proposition, we will discuss the result of replacing some of

110
‡±™
3 First-order logic
these occurrences of x with another variable. To distinguish the occurrences of the vari-
able x that are to be kept from those that are to be replaced, we shall use the notation
Œ±(x, . . . , x|x, . . . , x), where the occurrences of x on the left of | are to be kept and the oc-
currences on the right are to be replaced. Again, this somewhat ambiguous notation is
only temporary. Recall that Œì; (x Ãá= y) is the set Œì ‚à™{x Ãá= y}.
Proposition 3.3.49. Suppose that Œì; (x Ãá=y) ‚ä¢Œ±, where Œ± is an atomic formula and x, y are
variables. Let Œ±‚Ä≤ be the result of replacing some or all of the occurrences of x in Œ± with y.
Then Œì; (x Ãá= y) ‚ä¢Œ±‚Ä≤.
Proof. We are given that Œì; (x
Ãá= y) ‚ä¢Œ±. As discussed above, we shall use the notation
Œ±(x, . . . , x|x, . . . , x) to indicate that the occurrences of x on the right of | are to be replaced
by y. Thus, Œ±‚Ä≤ = Œ±(x, . . . , x|y, . . . , y). Now let z be a variable that is distinct from x, y, and
all of the variables that appear in Œ±. Consider the new atomic formula Œ±(z, . . . , z|x, . . . , x).
We observe that the formula
x Ãá= y ‚ÜíŒ±(z, . . . , z|x, . . . , x) ‚ÜíŒ±(z, . . . , z|x, . . . , x)x
y
(3.15)
is in logical axiom group 6. Since Œ±(z, . . . , z|x, . . . , x)x
y
= Œ±(z, . . . , z|y, . . . , y), we see
that (3.15) is the same as
x Ãá= y ‚ÜíŒ±(z, . . . , z|x, . . . , x) ‚ÜíŒ±(z, . . . , z|y, . . . , y).
(3.16)
Let Œ≤ denote the formula in (3.16). Therefore, by generalization, ‚àÄzŒ≤ is in logical axiom
group 6 and ‚àÄzŒ≤ ‚ÜíŒ≤z
x is in logical axiom group 2. By modus ponens, we infer that
Œì; (x Ãá= y) ‚ä¢Œ≤z
x.
Since Œ±(z, . . . , z|x, . . . , x)z
x = Œ± and Œ±(z, . . . , z|y, . . . , y)z
x = Œ±‚Ä≤, we see that Œ≤z
x is the formula
x Ãá= y ‚ÜíŒ± ‚ÜíŒ±‚Ä≤. Hence,
Œì; (x Ãá= y) ‚ä¢x Ãá= y ‚ÜíŒ± ‚ÜíŒ±‚Ä≤.
As Œì; (x Ãá= y) ‚ä¢Œ±, by applying modus ponens twice, we see that Œì; (x Ãá= y) ‚ä¢Œ±‚Ä≤.
Proposition 3.3.50. We have ‚ä¢‚àÄx‚àÄy(x Ãá= y ‚Üíy Ãá= x).
Proof. By Theorem 3.3.29, it is sufficient to show that ‚ä¢(x
Ãá= y ‚Üíy
Ãá= x), and by the
deduction theorem, we just need to show that {x Ãá= y} ‚ä¢y Ãá= x. We do this as follows:
(1)
{x Ãá= y} ‚ä¢x Ãá= x
as x Ãá= x is a logical axiom,
(2)
{x Ãá= y} ‚ä¢y Ãá= x
by Proposition 3.3.49.
In (2) we are using x Ãá= x as Œ± in Proposition 3.3.49.
The proof of the following result is requested in Exercise 19.

3.3 Deductions
‡±™
111
Proposition 3.3.51. We have ‚ä¢‚àÄx‚àÄy‚àÄz(x Ãá= y ‚Üíy Ãá= z ‚Üíx Ãá= z).
Proposition 3.3.52. We have ‚ä¢‚àÄx1‚àÄx2‚àÄy1‚àÄy2(x1 Ãá= y1 ‚Üíx2 Ãá= y2 ‚ÜíPx1x2 ‚ÜíPy1y2).
Proof. By the generalization theorem (Theorem 3.3.29), it is sufficient to show that
‚ä¢x1 Ãá= y1 ‚Üíx2 Ãá= y2 ‚ÜíPx1x2 ‚ÜíPy1y2.
By the deduction theorem we need to prove that
{x1 Ãá= y1, x2 Ãá= y2, Px1x2} ‚ä¢Py1y2.
Let Œì = {x1 Ãá= y1, x2 Ãá= y2, Px1x2}. We now show that Œì ‚ä¢Py1y2 as follows:
(1)
Œì ‚ä¢Px1x2
in Œì,
(2)
Œì ‚ä¢Py1x2
by Proposition 3.3.49,
(3)
Œì ‚ä¢Py1y2
by Proposition 3.3.49.
Proposition 3.3.53. We have ‚ä¢‚àÄx1‚àÄx2‚àÄy1‚àÄy2(x1 Ãá= y1 ‚Üíx2 Ãá= y2 ‚Üífx1x2 Ãá= fy1y2).
Proof. By the generalization theorem (Theorem 3.3.29), it is sufficient to show that
‚ä¢x1 Ãá= y1 ‚Üíx2 Ãá= y2 ‚Üífx1x2 Ãá= fy1y2.
By the deduction theorem we need to prove that
{x1 Ãá= y1, x2 Ãá= y2} ‚ä¢fx1x2 Ãá= fy1y2.
Let Œì = {x1 Ãá= y1, x2 Ãá= y2}. We now prove that Œì ‚ä¢fx1x2 Ãá= fy1y2 as follows:
(1)
Œì ‚ä¢fx1x2 Ãá= fx1x2
by Proposition 3.3.48,
(2)
Œì ‚ä¢fx1x2 Ãá= fy1x2
by Proposition 3.3.49,
(3)
Œì ‚ä¢fx1x2 Ãá= fy1y2
by Proposition 3.3.49.
The following theorem follows directly from Propositions 3.3.47‚Äì3.3.53.
Theorem 3.3.54. We have:
1.
‚ä¢‚àÄx(x Ãá= x),
2.
‚ä¢‚àÄx‚àÄy(x Ãá= y ‚Üíy Ãá= x),
3.
‚ä¢‚àÄx‚àÄy‚àÄz(x Ãá= y ‚Üíy Ãá= z ‚Üíx Ãá= z),
4.
‚ä¢‚àÄx1‚àÄx2‚àÄy1‚àÄy2(x1 Ãá= y1 ‚Üíx2 Ãá= y2 ‚ÜíPx1x2 ‚ÜíPy1y2), where P is a 2-place predicate
symbol, and similarly for n-place predicate symbols,
5.
‚ä¢‚àÄx1‚àÄx2‚àÄy1‚àÄy2(x1
Ãá= y1 ‚Üíx2
Ãá= y2 ‚Üífx1x2
Ãá= fy1y2), where f is a 2-place function
symbol, and similarly for n-place function symbols.

112
‡±™
3 First-order logic
Items 1‚Äì3 of Theorem 3.3.54 show that equality is reflexive, symmetric, and transi-
tive, respectively. Items 4 and 5 show that the substitution property of equality holds,
that is, if two quantities are equal, then one can replace one with the other. Thus, the
important properties of equality can be deduced from the logical axioms alone.
3.3.7 More metatheorems about deductions
The next problem illustrates an ability to ‚Äúgeneralize on a constant.‚Äù
Problem 3.3.55. Let ‚Ñícontain a constant symbol c and 1-place predicate symbols P
and Q. Let Œì = {‚àÄx(Px ‚ÜíQx), ‚àÄzPz}. One can show that Œì ‚ä¢Qc. Since c does not ap-
pear in any formula in Œì, can one then show that Œì ‚ä¢‚àÄxQx?
Solution. We show, in steps, that such a deduction exists.
(a) Œì ‚ä¢Qc
A deduction confirming (a) is given in Example 3.3.22 on page 99.
(b) Œì ‚ä¢Qy
To confirm (b), in the deduction given in Example 3.3.22, replace c with y.
(c) Œì ‚ä¢‚àÄyQy
This follows from (b) by Theorem 3.3.29, as y does not occur in Œì.
(d) ‚àÄyQy ‚ä¢‚àÄxQx
This is proven in Example 3.3.25 on page 100.
(e) Œì ‚ä¢‚àÄxQx
This follows from (c) and (d).
Our next theorem shows that the steps in the solution of the above problem can
be generalized. Let Œ± be a wff and let y be a variable that does not occur in Œ±. Define
Œ±c
y to be the wff obtained by replacing all occurrences of the constant symbol c in Œ±
with y.
Theorem 3.3.56 (Generalization on constants). Suppose that Œì ‚ä¢œÜ and let c be a constant
symbol that occurs in no formula in Œì. Then there is a variable y which does not appear in
œÜ such that Œì ‚ä¢‚àÄyœÜc
y. Moreover, there is a deduction of ‚àÄyœÜc
y from Œì in which c does not
occur.
Proof. Assume Œì ‚ä¢œÜ and assume that c is a constant symbol that occurs in no formula
in Œì. Let ‚ü®Œ±1, . . . , Œ±n‚ü©be a deduction of œÜ from Œì, where Œ±n = œÜ. So for all k ‚â§n, either
(a) Œ±k is in Œì ‚à™Œõ, or
(b) Œ±k is obtained by modus ponens from two earlier wffs in the sequence ‚ü®Œ±1, . . . , Œ±k‚ü©.
Now, let y be a variable that does not occur in Œ±k for all 1 ‚â§k ‚â§n. We will show that
‚ü®Œ±1
c
y, . . . , Œ±n
c
y‚ü©is a deduction of œÜc
y from Œì. Let k be so that 1 ‚â§k ‚â§n.

3.3 Deductions
‡±™
113
Case (a): Suppose that Œ±k is in Œì ‚à™Œõ. If Œ±k ‚ààŒì, then c does not occur in Œ±k. Thus,
Œ±k
c
y = Œ±k, and therefore Œ±k
c
y ‚ààŒì. If Œ±k ‚ààŒõ, then Œ±k
c
y is also a logical axiom (for each Œ±
that appears in a logical axiom, by replacing Œ± with Œ±c
y we get another logical axiom).
Therefore, Œ±k
c
y ‚ààŒõ.
Case (b): If Œ±k is obtained by modus ponens from two earlier wffs in the sequence
‚ü®Œ±1, . . . , Œ±k‚ü©, then for some i and j less than k, the wffs Œ±i and Œ±j = (Œ±i ‚ÜíŒ±k) are in the
sequence ‚ü®Œ±1, . . . , Œ±k‚ü©. Since
Œ±j
c
y = (Œ±i ‚ÜíŒ±k)c
y = (Œ±i
c
y ‚ÜíŒ±k
c
y),
we see that Œ±k
c
y is obtained by modus ponens from two earlier wffs in the sequence
‚ü®Œ±1
c
y, . . . , Œ±k
c
y‚ü©.
So ‚ü®Œ±1
c
y, . . . , Œ±n
c
y‚ü©is a deduction of œÜc
y from Œì. Let
Œ¶ = {Œ±i : Œ±i ‚ààŒì and 0 ‚â§i ‚â§n}.
Since Œ±i
c
y = Œ±i for all Œ±i ‚ààŒ¶, we see that Œ¶ ‚ä¢œÜc
y. As y does not occur in any formula
in Œ¶, the generalization theorem (Theorem 3.3.29) implies that Œ¶ ‚ä¢‚àÄyœÜc
y. Since Œ¶ ‚äÜŒì,
we conclude that Œì ‚ä¢‚àÄyœÜc
y.
Therefore, ‚ü®Œ±1
c
y, . . . , Œ±n
c
y‚ü©is a deduction of œÜc
y from Œì that does not involve the con-
stant c. As the proof of Theorem 3.3.29 adds no new symbols to a deduction, we conclude
there is a deduction of ‚àÄyœÜc
y from Œì in which c does not occur.
Lemma 3.3.57 (Re-replacement). Let x be a variable and let œÜ be a wff in which the vari-
able y does not appear. Then x is substitutable for y in the wff œÜx
y and œÜxy
yx = œÜ.
Proof. See Exercise 21.
Corollary 3.3.58. Assume Œì ‚ä¢œÜx
c, where c is a constant symbol that does not occur in œÜ
and c does not occur in any formula in Œì. Then Œì ‚ä¢‚àÄxœÜ. In addition, there is a deduction
of ‚àÄxœÜ from Œì in which c does not occur.
Proof. Assume Œì ‚ä¢œÜx
c, where c is a constant symbol that occurs neither in œÜ nor in any
formula in Œì. Theorem 3.3.56 implies that there is a variable y which does not occur in
œÜx
c such that Œì ‚ä¢‚àÄyœÜxc
cy. In addition, there is a deduction of ‚àÄyœÜxc
cy from Œì in which c
does not occur. Since c does not occur in œÜ, we see that œÜxc
cy = œÜx
y. Hence, (Û≥µ≥) Œì ‚ä¢‚àÄyœÜx
y.
Lemma 3.3.57 asserts that x is substitutable for y in œÜx
y. Thus,
‚àÄyœÜx
y ‚ÜíœÜxy
yx
is in axiom group 2. Since Lemma 3.3.57 also asserts that œÜxy
yx = œÜ, we conclude that
‚àÄyœÜx
y ‚ÜíœÜ

114
‡±™
3 First-order logic
is a logical axiom. Thus, ‚ä¢‚àÄyœÜx
y ‚ÜíœÜ. So, by the deduction theorem, we have ‚àÄyœÜx
y ‚ä¢œÜ.
Since x does not occur free in ‚àÄyœÜx
y, the generalization theorem (Theorem 3.3.29) implies
that ‚àÄyœÜx
y ‚ä¢‚àÄxœÜ. Because Œì ‚ä¢‚àÄyœÜx
y by (Û≥µ≥), we conclude that Œì ‚ä¢‚àÄxœÜ.
In mathematics, suppose that one can prove a result by using an arbitrary constant.
Afterwards, one can then ask: Is there a proof that does not use the constant? The next
corollary positively addresses this question.
Corollary 3.3.59. Let c be a constant symbol that does not occur in œÜ, in œà, or in any
formula in Œì. If Œì; œÜx
c ‚ä¢œà, then Œì; ‚àÉxœÜ ‚ä¢œà. Moreover, there is a deduction of œà from Œì; ‚àÉxœÜ
in which c does not occur.
Proof. Let c be a constant symbol that does not occur in œÜ, in œà, or in any formula in Œì.
Suppose that Œì; œÜx
c ‚ä¢œà. By contraposition (Corollary 3.3.35), we see that Œì; ¬¨œà ‚ä¢¬¨œÜx
c.
Corollary 3.3.58 implies that Œì; ¬¨œà ‚ä¢‚àÄx¬¨œÜ and this can be confirmed by a deduction in
which c does not appear. Thus, by contraposition, Œì; ¬¨‚àÄx¬¨œÜ ‚ä¢œà. Hence, Œì; ‚àÉxœÜ ‚ä¢œà and
this can be verified by a deduction in which c does not occur.
Alphabetic variants
We begin with some terminology. Let v be a variable and consider a wff of the form ‚àÄxœÜ.
If v occurs in œÜ, then v is said to be within the scope of the quantifier ‚àÄ. An alphabetic
variant of wff Œ± is a wff Œ± that is the result of a one-to-one replacement of some, none, or
all of the quantified variables of Œ± with variables that are not in the scope of a quantifier
in Œ±. A precise definition of an alphabetic variant can be given by recursion (see the proof
of Theorem 3.3.61 below). Here are some examples:
1.
The wff ‚àÄw‚àÄxPwx is an alphabetic variant of ‚àÄy‚àÄzPyz, because the change of quan-
tified variables y Û≥®É‚Üíw, z Û≥®É‚Üíx is one-to-one and w, x do not occur in ‚àÄy‚àÄzPyz.
2.
The wff ‚àÄz‚àÄzPzz is not an alphabetic variant of ‚àÄy‚àÄzPyz, because the change of the
quantified variable y Û≥®É‚Üíz is such that z is in the scope of ‚àÄin ‚àÄy‚àÄzPyz.
Here are two examples which indicate that one can deduce alphabetic variants:
1.
‚àÄyQy ‚ä¢‚àÄxQx (see Example 3.3.25),
2.
‚àÄy‚àÄzPyz ‚ä¢‚àÄx‚àÄwPxw.
The above examples illustrate that one can deduce a ‚Äúchange of quantified variables.‚Äù
In Theorem 3.3.61 below, such a ‚Äúchange of variables‚Äù result is established in general.
Consequently, when a term is not substitutable for a variable in a given wff, one can
change the quantified variables so that the term will become substitutable.
The following is essentially a restatement of Theorem 3.3.46.
Lemma 3.3.60. Let Œ± and Œ≤ be wffs and let x be any variable. If Œ± ‚ä¢Œ≤, then ‚àÄxŒ± ‚ä¢‚àÄxŒ≤.

3.3 Deductions
‡±™
115
Given a term t and a wff œÜ, the term t may not be substitutable for a specific variable
in œÜ. The following theorem shows that one can change the quantified variables in œÜ to
get an equivalent formula œÜ in which t is substitutable.
Theorem 3.3.61 (Alphabetic variants). Let œÜ be a wff, t a term, and x a variable. There
exists an alphabetic variant œÜ of œÜ such that:
(a) œÜ ‚ä¢œÜ and œÜ ‚ä¢œÜ;
(b) t is substitutable for x in œÜ.
Proof. Let the variable x and let term t be fixed. If t is substitutable for x in œÜ, then let
œÜ = œÜ. Otherwise, we will define œÜ and prove the following statement by induction on
œÜ: œÜ ‚ä¢œÜ, œÜ ‚ä¢œÜ, and t is substitutable for x in œï.
Base step: Let œï = Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn be an atomic sentence. Let œï = œï. Clearly, œï ‚ä¢œï, œï ‚ä¢œï, and
t is substitutable for x in œï.
Inductive step: Let Œ± and Œ≤ be arbitrary wffs. Assume the induction hypothesis that there
are wffs Œ± and Œ≤ such that
Œ± ‚ä¢Œ±, Œ± ‚ä¢Œ±, and t is substitutable for x in Œ±,
Œ≤ ‚ä¢Œ≤, Œ≤ ‚ä¢Œ≤, and t is substitutable for x in Œ≤.
(IH)
We must prove that the same holds for each of the following: ¬¨Œ±, Œ± ‚ÜíŒ≤, ‚àÄyŒ±.
Case ¬¨Œ±: Let ¬¨Œ± = ¬¨Œ±. By (IH), contraposition, and Definition 3.3.15, we see that ¬¨Œ± ‚ä¢¬¨Œ±,
¬¨Œ± ‚ä¢¬¨Œ±, and t is substitutable for x in ¬¨Œ±.
Case Œ± ‚ÜíŒ≤: Let Œ± ‚ÜíŒ≤ = Œ± ‚ÜíŒ≤. By (IH), Exercise 22, and Definition 3.3.15, we see that
(Œ± ‚ÜíŒ≤) ‚ä¢(Œ± ‚ÜíŒ≤), (Œ± ‚ÜíŒ≤) ‚ä¢(Œ± ‚ÜíŒ≤), and t is substitutable for x in Œ± ‚ÜíŒ≤.
Case ‚àÄyŒ± : Choose a variable z
Ã∏= x that occurs neither in Œ± nor in t. Let ‚àÄyŒ± = ‚àÄzŒ±y
z. We
must prove that
‚àÄyŒ± ‚ä¢‚àÄzŒ±y
z, ‚àÄzŒ±y
z ‚ä¢‚àÄyŒ±, and t is substitutable for x in ‚àÄzŒ±y
z.
We first show that t is substitutable for x in ‚àÄzŒ±y
z. By the induction hypothesis (IH),
the term t is substitutable for x in Œ±. Since x
Ã∏= z and z does not occur in t, it follows
that t is substitutable for x in Œ±y
z. Thus, by Definition 3.3.15(4)(b), we conclude that t is
substitutable for x in ‚àÄzŒ±y
z.
By the induction hypothesis we have Œ± ‚ä¢Œ±. Since z does not occur in Œ±, we see that
(‚ãÜ) z is substitutable for y in Œ±. Also, as z does not occur in Œ±, it follows that z does not
occur free in Œ± (if it occurred free in Œ±, it would occur in Œ±). Therefore, (‚ãÜ‚ãÜ) z does not
occur free in ‚àÄyŒ±. We now prove that ‚àÄyŒ± ‚ä¢‚àÄz(Œ±)y
z as follows:
Œ± ‚ä¢Œ±
by (IH),
‚àÄyŒ± ‚ä¢‚àÄyŒ±
by Lemma 3.3.60,

116
‡±™
3 First-order logic
‚àÄyŒ± ‚ä¢Œ±y
z
by modus ponens as ‚àÄyŒ± ‚ÜíŒ±y
z is a logical axiom (group 2) via (‚ãÜ),
‚àÄyŒ± ‚ä¢‚àÄzŒ±y
z
by (‚ãÜ‚ãÜ) and the generalization theorem (Theorem 3.3.29).
We now prove that ‚àÄzŒ±y
z ‚ä¢‚àÄyŒ±. Recall that z does not appear in Œ±. Lemma 3.3.57 thus
implies that y is substitutable for z in Œ±y
z and that Œ±yz
zy = Œ±. Also, we note that (Û≥µ≥) y does
not occur free in ‚àÄzŒ±y
z. Since ‚àÄzŒ±y
z ‚ÜíŒ±yz
zy is a logical axiom, we see that (Û≥∂É) ‚àÄzŒ±y
z ‚ä¢Œ±yz
zy.
Finally, we prove that ‚àÄzŒ±y
z ‚ä¢‚àÄyŒ± as follows:
‚àÄzŒ±y
z ‚ä¢Œ±yz
zy
by (Û≥∂É,)
‚àÄzŒ±y
z ‚ä¢Œ±
because Œ±yz
zy = Œ±,
‚àÄzŒ±y
z ‚ä¢Œ±
by (IH) Œ± ‚ä¢Œ±, and so Lemma 3.3.26(4) applies,
‚àÄzŒ±y
z ‚ä¢‚àÄyŒ±
by (Û≥µ≥) and the generalization theorem (Theorem 3.3.29).
Exercises 3.3.
*1. Let ùíÆbe the set of all prime formulas in a language ‚Ñí. Let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚Üí} and let ùíÆ
be the set of all wffs generated by ùíÆfrom the functions in ‚Ñ±. Prove by induction on
wffs that every wff is in ùíÆ.
*2. Let A be an ‚Ñí-structure with domain A. Let V be the set of all the variables of ‚Ñí. Let
s: V ‚ÜíA be a variable assignment. Define a truth assignment on the set of prime
wffs Œ± by
u(Œ±) = {T,
if A Û≥ÄÄÛ≥®êŒ±[s],
F,
if A
Ã∏Û≥ÄÄÛ≥®êŒ±[s].
(a) Show that for all wffs Œ∏,
u(Œ∏) = T
iff
A Û≥ÄÄÛ≥®êŒ∏[s].
(b) Let Œì be a set of wffs and let œÜ be a wff. Show that if Œì tautologically implies œÜ,
then Œì logically implies œÜ.
3. Show that the wff ‚àÄv1(v1 Ãá=v1) ‚Üív1 Ãá=v1 is logically valid and that it is not a first-order
tautology.
4. Let ‚Ñí= {c, f , Ãá=}, where c is a constant symbol and f is a 1-place function symbol. For
each of the following wffs œÜ and terms t, evaluate œÜx
t and decide if t is substitutable
for x in œÜ:
(a) ‚àÄx(x Ãá= y ‚Üífx Ãá= fy) and t is fc,
(b) ‚àÄy(x Ãá= y ‚Üífx Ãá= fy) and t is fy,
(c) (x Ãá= y ‚Üí‚àÄx(fx Ãá= fy)) and t is fy.
*5. Let ‚Ñíbe a language, let x be a variable in ‚Ñí, and, in particular, let x = vi0. Now let
t be a term. Let A be the set of all the atomic formulas and let X be the set of wffs
defined by

3.3 Deductions
‡±™
117
X = {‚àÄvi0Œ± : Œ± is a wff}.
Thus, X is the set of wffs of the form ‚àÄxŒ±, where Œ± is some wff. Let ùíÆ= A ‚à™X, a
disjoint union. Let Q = {‚Ñ∞Qi : i
Ã∏= i0}. Let ‚Ñ±= {‚Ñ∞¬¨, ‚Ñ∞‚Üí} ‚à™Q (see (3.4)) and let ùíÆbe
the set generated from ùíÆby the functions in ‚Ñ±. Theorem 3.1.16 implies that ùíÆis
the set of all the wffs and is freely generated from the set ùíÆby the functions in ‚Ñ±.
By Exercise 11 on page 65, for each term œÑ, œÑx
t is the term obtained by replacing all
occurrences of x in œÑ with t. Define h: ùíÆ‚ÜíùíÆby
h(v) = {PœÑ1
x
t œÑ2
x
t ‚ãÖ‚ãÖ‚ãÖœÑn
x
t ,
if v = PœÑ1œÑ2 ‚ãÖ‚ãÖ‚ãÖœÑn is in A,
‚àÄxŒ±,
if v = ‚àÄxŒ± is in X.
(3.17)
Theorem 1.1.27 implies there is a unique function h: ùíÆ‚ÜíùíÆsuch that
(1) h(Œ±) = h(Œ±) if Œ± ‚ààS,
(2) h((¬¨Œ±)) = ¬¨h(Œ±),
(3) h((Œ± ‚ÜíŒ≤)) = h(Œ±) ‚Üíh(Œ≤),
(4) h(‚àÄvŒ±) = ‚àÄvh(Œ±) whenever v
Ã∏= x.
Prove, by induction on wffs, that for all wffs Œ±, h(Œ±) = Œ±x
t .
6. Let ‚Ñí= {P, Q, c}, where P is a 1-place predicate symbol, Q is a 2-place predicate
symbol, and c is a constant symbol. To which logical axiom groups, if any, do each
of the following wffs belong?
(a) ((‚àÄxPx ‚Üí‚àÄyPy) ‚ÜíPz) ‚Üí(‚àÄxPx ‚Üí(‚àÄyPy ‚ÜíPz)).
(b) ‚àÄy(‚àÄx(Px ‚ÜíPx) ‚Üí(Pc ‚ÜíPx)).
(c) ‚àÄx‚àÉyQxy ‚Üí‚àÉyQyy.
7. Using Definition 3.3.20, prove Lemma 3.3.26.
8. Suppose that Œì is consistent and Œì ‚ä¢œÜ. Show that Œì ‚à™{œÜ} is consistent.
9. Let Œì = {‚àÄxŒ±, ‚àÄx¬¨Œ±}, where Œ± is a wff. Show that Œì is inconsistent.
*10. Suppose that the term t is substitutable for x in wff Œ±. Show that ‚ä¢Œ±x
t ‚Üí‚àÉxŒ±.
11. Show that ‚ä¢‚àÄxœÜ ‚Üí‚àÉxœÜ by presenting an explicit deduction.
*12. Prove Theorem 3.3.38.
13. Prove Proposition 3.3.41.
14. Prove Proposition 3.3.43.
15. Prove Proposition 3.3.44.
16. Prove Theorem 3.3.46.
17. Show the following:
(a) ‚ä¢‚àÉx(Px ‚Üí‚àÄxPx),
(b) {Qx, ‚àÄy(Qy ‚Üí‚àÄzPz)} ‚ä¢‚àÄxPx.
18. Show that ‚àÄx‚àÄyPxy ‚Üí‚àÄy‚àÄxPyx.
*19. Prove Proposition 3.3.51.
*20. Let f be a 1-place function symbol and let t and œÑ be terms. Show that:
(a) ‚ä¢‚àÄx‚àÄy(x Ãá= y ‚Üífx Ãá= fy),
(b) ‚ä¢(t Ãá= œÑ ‚Üíft Ãá= fœÑ).

118
‡±™
3 First-order logic
*21. Prove Lemma 3.3.57 by induction on œÜ.
*22. Suppose that:
1.
Œ± ‚ä¢Œ± and Œ± ‚ä¢Œ±,
2.
Œ≤ ‚ä¢Œ≤ and Œ≤ ‚ä¢Œ≤.
Prove that (Œ± ‚ÜíŒ≤) ‚ä¢(Œ± ‚ÜíŒ≤) and (Œ± ‚ÜíŒ≤) ‚ä¢(Œ± ‚ÜíŒ≤).
23. Let Œì and Œî be sets of wffs. Suppose that Œì ‚ä¢œÜ for all œÜ ‚ààŒî and that Œî ‚ä¢œÉ. Prove
that Œì ‚ä¢œÉ.
*24. Prove that a set of wffs Œì is consistent if and only if every finite subset of Œì is con-
sistent.
*25. Suppose that Œì is a consistent set of wffs and let œÜ be a wff. Show that if Œì ‚ä¨œÜ, then
Œì ‚à™{¬¨œÜ} is consistent.
26. Suppose Œ£ is a set of sentences, œÜ is any wff, and x is any variable. Prove that Œ£ ‚ä¢œÜ
if and only if Œ£ ‚ä¢‚àÄxœÜ.
*27. Show that ‚ä¢¬¨‚àÄvŒ± ‚Üí¬¨‚àÄv¬¨¬¨Œ±.
28. Show that ‚ä¢‚àÉxŒ≤ ‚Üí‚àÄxŒ≤ if x does not occur free in Œ≤.
29. Show that ‚ä¢‚àÉx(‚àÉxPx ‚ÜíPx).
30. Let Œ£0 ‚äÜŒ£1 ‚äÜŒ£2 ‚äÜŒ£3 ‚äÜ‚ãÖ‚ãÖ‚ãÖbe sets of wffs. Suppose that each Œ£i is consistent. Show
that ‚ãÉi‚àà‚ÑïŒ£i is consistent.
Exercise Notes: For Exercise 11, ‚àÄxœÜ ‚ÜíœÜ and ‚àÄx¬¨œÜ ‚Üí¬¨œÜ are logical axioms. In addi-
tion,
(‚àÄx¬¨œÜ ‚Üí¬¨œÜ) ‚Üí(œÜ ‚Üí¬¨‚àÄx¬¨œÜ) and
(‚àÄxœÜ ‚ÜíœÜ) ‚Üí(œÜ ‚Üí¬¨‚àÄx¬¨œÜ) ‚Üí(‚àÄxœÜ ‚Üí¬¨‚àÄx¬¨œÜ)
are tautologies. For Exercise 17, use reductio ad absurdum by showing that
‚àÄx¬¨(Px ‚Üí‚àÄxPx) ‚ä¢‚àÄxPx
(via Logical Axiom 2, a tautology, and generalization) and showing, via Logical Axiom 2
and a tautology, that ‚àÄx¬¨(Px ‚Üí‚àÄxPx) ‚ä¢¬¨‚àÄxPx. For Exercise 18, use Problem 3.3.39(2) on
page 106. For Exercise 20, by Theorem 3.3.61 one can assume that x and y do not appear
in t or œÑ.

4 Soundness and completeness
Is there a relationship between the concept of truth and the concept of proof ? In the
previous chapter we investigated what it means for a structure to satisfy a first-order
formula and then we discussed deductions of first-order formulas. In this chapter we
will establish two consequential relationships between satisfaction and deduction. The
first relationship is called the soundness theorem, which implies that every first-order
formula that is deducible, from the logical axioms alone, is logically valid. The second
relationship, the completeness theorem, shows that every first-order formula that is log-
ically valid is deducible.
4.1 The soundness theorem
The soundness theorem asserts that ‚Äúdeductions preserve truth,‚Äù that is, if Œì is a set of
well-formed formulas (wffs) and each wff in Œì holds in a structure, then any wff that is
deducible from Œì will also hold in this structure. The goal of this section is to prove the
soundness theorem.
Theorem (Soundness). Let Œì be a set of formulas. If Œì ‚ä¢œÜ, then Œì Û≥ÄÄÛ≥®êœÜ.
The soundness theorem shows that if a formula œÜ is deducible from a set of wffs Œì,
then the set Œì logically implies œÜ (see Definition 3.2.15). Therefore, deductions produce
valid conclusions, that is, these deduced conclusions will hold in every structure in
which the assumptions hold. This confirms why proof in mathematics is so important.
Before we present the proof of this theorem, we need to state and prove some technical
lemmas.
4.1.1 Technical lemmas
Our first two technical lemmas are used to prove that all the logical axioms are logically
valid, that is, every logical axiom is true in every structure. Recall that for a wff Œ±, we
defined the wff Œ±x
t in Definition 3.3.13 so that Œ±x
t is the result of ‚Äúreplacing the variable x
in Œ± with the term t,‚Äù with one exception (item 4 of Definition 3.3.13). Now, given a term œÑ,
let us define œÑx
t to be the term obtained by replacing the variable x in œÑ with the term t
(see Exercise 11 on page 65). Also recall that, given an assignment s, sx|d is the function
which is exactly like s except for one thing: at the variable x it assumes the value d,
that is,
sx|d(v) = {s(v),
if v
Ã∏= x,
d,
if v = x.
https://doi.org/10.1515/9783110782073-004

120
‡±™
4 Soundness and completeness
Given an assignment s, we will show in our next lemma that the value of s(œÑx
t ) can be
obtained by using the assignment sx|s(t).
Lemma 4.1.1. Let A be a structure and let s be an assignment. For terms œÑ, t and variable
x we have s(œÑx
t ) = sx|s(t)(œÑ).
Proof. Let A be a structure, s an assignment, t a term, and x a variable. We shall prove
that s(œÑx
t ) = sx|s(t)(œÑ) by induction on terms œÑ.
Base step: Let c and v be a constant and a variable, respectively, of the language ‚Ñí.
Clearly, cx
t = c, so s(cx
t ) = cA = sx|s(t)(c) by Definition 3.2.4. If v
Ã∏= x, then vx
t = v, so
s(vx
t ) = s(v) = sx|s(t)(v). If v = x, then xx
t = t, so s(xx
t ) = s(t) = sx|s(t)(x).
Inductive step: Let f be an n-place function symbol in ‚Ñíand let œÑ1, . . . , œÑn be terms. As-
sume the induction hypothesis
For each i ‚â§n we have s(œÑi
x
t ) = sx|s(t)(œÑi).
(IH)
We must prove that the same holds for the term fœÑ1 ‚ãÖ‚ãÖ‚ãÖœÑn. Thus,
s((fœÑ1 ‚ãÖ‚ãÖ‚ãÖœÑn)x
t ) = s(f œÑ1
x
t ‚ãÖ‚ãÖ‚ãÖœÑn
x
t )
Exercise 11(2), page 65,
= f A(s(œÑ1
x
t ), . . . , s(œÑn
x
t ))
by Theorem 3.2.5(3),
= f A(sx|s(t)(œÑ1), . . . , sx|s(t)(œÑn))
by (IH),
= sx|s(t)(fœÑ1 ‚ãÖ‚ãÖ‚ãÖœÑn)
by Theorem 3.2.5(3).
Lemma 4.1.2 (Substitution). If the term t is substitutable for the variable x in the wff œÜ,
then for every structure A and every assignment s, we have
A Û≥ÄÄÛ≥®êœÜx
t [s]
iff
A Û≥ÄÄÛ≥®êœÜ[sx|s(t)].
Proof. Let A be an arbitrary structure. We shall prove the following statement by induc-
tion on wffs: If t is substitutable for x in œÜ, then
A Û≥ÄÄÛ≥®êœÜx
t [s]
iff
A Û≥ÄÄÛ≥®êœÜ[sx|s(t)] for all assignments s.
Base step: Let PœÑ1 ‚ãÖ‚ãÖ‚ãÖœÑn be an atomic formula. Let s be an assignment. We note that
(‚ãÜ) (PœÑ1 ‚ãÖ‚ãÖ‚ãÖœÑn)x
t = PœÑ1
x
t ‚ãÖ‚ãÖ‚ãÖœÑn
x
t . Thus,
A Û≥ÄÄÛ≥®ê(PœÑ1 ‚ãÖ‚ãÖ‚ãÖœÑn)x
t [s]
iff
A Û≥ÄÄÛ≥®êùí´œÑ1
x
t ‚ãÖ‚ãÖ‚ãÖœÑn
x
t [s]
by (‚ãÜ),
iff
‚ü®s(œÑ1
x
t ), . . . , s(œÑn
x
t )‚ü©‚ààPA
by Definition 3.2.6(2),
iff
‚ü®sx|s(t)(œÑ1), . . . , sx|s(t)(œÑn)‚ü©‚ààPA
by Lemma 4.1.1,
iff
A Û≥ÄÄÛ≥®êPœÑ1 ‚ãÖ‚ãÖ‚ãÖœÑn[sx|s(t)]
by Definition 3.2.6(2).
Inductive step: Let Œ± and Œ≤ be arbitrary wffs. Assume the induction hypothesis

4.1 The soundness theorem
‡±™
121
if t is substitutable for x in Œ±, then A Û≥ÄÄÛ≥®êŒ±x
t [s] iff A Û≥ÄÄÛ≥®êŒ±[sx|s(t)],
if t is substitutable for x in Œ≤, then A Û≥ÄÄÛ≥®êŒ≤x
t [s] iff A Û≥ÄÄÛ≥®êŒ≤[sx|s(t)]
(IH)
for all assignments s. We must prove that the same holds for each of the following:
(¬¨Œ±), (Œ± ‚ÜíŒ≤), ‚àÄvŒ±.
Case (¬¨Œ±): Let s be an assignment and let t be substitutable for x in (¬¨Œ±). It follows that
t is substitutable for x in Œ± (see Definition 3.3.15) and that (¬¨Œ±)x
t = ¬¨Œ±x
t . Hence
A Û≥ÄÄÛ≥®ê(¬¨Œ±)x
t [s]
iff
A
Ã∏Û≥ÄÄÛ≥®êŒ±x
t [s]
by Definition 3.2.6(3),
iff
A
Ã∏Û≥ÄÄÛ≥®êŒ±[sx|s(t)]
by (IH),
iff
A Û≥ÄÄÛ≥®ê(¬¨Œ±)[sx|s(t)]
by Definition 3.2.6(3).
Case (Œ± ‚ÜíŒ≤): Let s be an assignment and let t be substitutable for x in (Œ± ‚ÜíŒ≤). Thus, t
is substitutable for x in Œ± and in Œ≤, and (Œ± ‚ÜíŒ≤)x
t = (Œ±x
t ‚ÜíŒ≤x
t ). Hence
A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)x
t [s]
iff
A Û≥ÄÄÛ≥®êŒ±x
t [s] implies A Û≥ÄÄÛ≥®êŒ≤x
t [s]
by Definition 3.2.6(4),
iff
A Û≥ÄÄÛ≥®êŒ±[sx|s(t)] implies A Û≥ÄÄÛ≥®êŒ≤[sx|s(t)]
by (IH),
iff
A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[sx|s(t)]
by Definition 3.2.6(4).
Case ‚àÄvŒ±: Let s be an assignment and t be substitutable for x in ‚àÄvŒ±. By Definition 3.3.15,
either (a) x does not occur free in (‚àÄvŒ±) or (b) v does not occur in t and t is substitutable
for x in Œ±.
(a) Suppose x does not occur free in ‚àÄvŒ±. Thus, (Û≥µ≥) (‚àÄvŒ±)x
t = ‚àÄvŒ±. Also, it follows that
s and sx|s(t) agree on the free variables in ‚àÄvŒ±. Thus, by Theorem 3.2.11 we have
A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s] if and only if A Û≥ÄÄÛ≥®ê‚àÄvŒ±[sx|s(t)]. So, by (Û≥µ≥), A Û≥ÄÄÛ≥®ê(‚àÄvŒ±)x
t [s] if and only if
A Û≥ÄÄÛ≥®ê‚àÄvŒ±[sx|s(t)].
(b) Assume v does not occur in t and t is substitutable for x in Œ±. By Definition 3.3.13, we
have
(‚àÄvŒ±)x
t = {‚àÄvŒ±,
if x = v,
‚àÄvŒ±x
t ,
if x
Ã∏= v.
If x = v, then x does not occur free in ‚àÄvŒ±, and this is just case (a) above. If x
Ã∏= v,
then (‚àÄvŒ±)x
t = ‚àÄvŒ±x
t . Therefore, letting A be the domain of A, we have
A Û≥ÄÄÛ≥®ê(‚àÄvŒ±)x
t [s]
iff
for every d ‚ààA, A Û≥ÄÄÛ≥®êŒ±x
t [sv|d]
by Definition 3.2.6(5),
iff
for every d ‚ààA, A Û≥ÄÄÛ≥®êœÜ[sv|d,x|s(t)]
by (IH),
iff
A Û≥ÄÄÛ≥®ê‚àÄvŒ±[sx|s(t)]
by Definition 3.2.6(5).
This completes the proof of the substitution lemma.

122
‡±™
4 Soundness and completeness
Recall that an alphabetic variant of wff œÜ is obtained by replacing some, none, or all
of the quantified variables of œÜ with different variables (see page 114). Lemma 4.1.2 and
Theorem 3.3.61 imply the following observation.
Corollary 4.1.3. Let t be a term, x a variable, and œÜ a wff. There is an alphabetic variant œÜ
of œÜ such that
œÜ ‚ä¢œÜ, œÜ ‚ä¢œÜ, t is substitutable for x in œÜ,
and for every structure A and every assignment s, we have
A Û≥ÄÄÛ≥®êœÜx
t [s]
iff
A Û≥ÄÄÛ≥®êœÜ[sx|s(t)].
Lemma 4.1.4. Every logical axiom is logically valid.
Proof. By Exercise 14 on page 89, we know that any generalization of a logically valid
formula is also logically valid. Therefore, we only need to prove the logical validity of
the axioms described in the six groups of Logical Axioms 3.3.17. Let A be a structure and
let s be an assignment. We shall show that A Û≥ÄÄÛ≥®êœÜ[s] for every œÜ that belongs to one of
the six categories in Logical Axioms 3.3.17.
1.
Suppose œÜ is a tautology. Exercise 2(b) on page 116 (where Œì = ‚åÄ) implies that Û≥ÄÄÛ≥®êœÜ,
and therefore A Û≥ÄÄÛ≥®êœÜ[s].
2.
Assume that œÜ has the form ‚àÄxŒ± ‚ÜíŒ±x
t , where t is substitutable for x in Œ±. We must
show that A Û≥ÄÄÛ≥®ê(‚àÄxŒ± ‚ÜíŒ±x
t )[s]. So, assume that A Û≥ÄÄÛ≥®ê‚àÄxŒ±[s]. We conclude that A Û≥ÄÄÛ≥®ê
Œ±[sx|s(t)]. The substitution lemma (Lemma 4.1.2) implies that A Û≥ÄÄÛ≥®êŒ±x
t [s]. Therefore,
A Û≥ÄÄÛ≥®ê(‚àÄxŒ± ‚ÜíŒ±x
t )[s].
3.
Let œÜ have the form ‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄxŒ± ‚Üí‚àÄxŒ≤). To show that
A Û≥ÄÄÛ≥®ê(‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄxŒ± ‚Üí‚àÄxŒ≤))[s],
assume that A Û≥ÄÄÛ≥®ê‚àÄx(Œ± ‚ÜíŒ≤)[s] and A Û≥ÄÄÛ≥®ê‚àÄxŒ±[s]. Exercise 12 on page 89 implies that
A Û≥ÄÄÛ≥®ê‚àÄxŒ≤[s].
4.
Let œÜ be of the form Œ± ‚Üí‚àÄxŒ±, where x does not occur free in Œ±. To show that A Û≥ÄÄÛ≥®ê
(Œ± ‚Üí‚àÄxŒ±)[s], assume A Û≥ÄÄÛ≥®êŒ±[s]. Thus, A Û≥ÄÄÛ≥®ê‚àÄxŒ±[s] by Exercise 13 on page 89.
5.
Suppose œÜ has the form x Ãá= x. We must show that A Û≥ÄÄÛ≥®ê(x Ãá= x)[s]. This follows imme-
diately from Definition 3.2.6(1), the definition of satisfaction.
6.
Assume that œÜ has the form x
Ãá= y ‚Üí(Œ± ‚ÜíŒ±x
y), where Œ± is an atomic formula. We
must show that
A Û≥ÄÄÛ≥®ê(x Ãá= y ‚Üí(Œ± ‚ÜíŒ±x
y))[s].
To affirm this, assume that A Û≥ÄÄÛ≥®ê(x Ãá=y)[s]. Thus, s(x) = s(y). By Exercise 11 on page 88,
we have A Û≥ÄÄÛ≥®êŒ±[s] iff A Û≥ÄÄÛ≥®êŒ±x
y[s]. It thus follows that A Û≥ÄÄÛ≥®ê(x Ãá= y ‚Üí(Œ± ‚ÜíŒ±x
y))[s].

4.1 The soundness theorem
‡±™
123
4.1.2 Proof of the soundness theorem
Theorem 4.1.5 (Soundness). Let Œì be a set of formulas. If Œì ‚ä¢œÜ, then Œì Û≥ÄÄÛ≥®êœÜ.
Proof. Assume that Œì ‚ä¢œÜ. Let ‚ü®Œ±1, Œ±2, . . . , Œ±n‚ü©be a deduction from the set Œì of wffs, where
Œ±n = œÜ. We shall prove the following statement: For all k ‚â§n, Œì Û≥ÄÄÛ≥®êŒ±k. We shall use strong
induction on the natural number variable k.
Base step: Let k = 1. We must show that Œì Û≥ÄÄÛ≥®êŒ±1. Since Œ±1 is the first item in the deduction,
either (a) Œ±1 ‚ààŒì or (b) Œ±1 is a logical axiom. If Œ±1 ‚ààŒì, then clearly we have Œì Û≥ÄÄÛ≥®êŒ±1. If Œ±1 is
a logical axiom, then Lemma 4.1.4 implies that Œì Û≥ÄÄÛ≥®êŒ±1.
Inductive step: Let k ‚â§n. Assume the strong induction hypothesis
Œì Û≥ÄÄÛ≥®êŒ±i
for all i < k.
(SIH)
We must show that Œì Û≥ÄÄÛ≥®êŒ±k. Since Œ±k is in the deduction, either (a) Œ±k ‚ààŒì, or (b) Œ±k is
a logical axiom, or (c) Œ±k is obtained by modus ponens from an Œ±i and Œ±j = (Œ±i ‚ÜíŒ±k),
where i, j < k. If (a) or (b) hold, then we can conclude that Œì Û≥ÄÄÛ≥®êŒ±k just as in the base
step. So, suppose that (c) holds. By the strong induction hypothesis (SIH), we conclude
that Œì Û≥ÄÄÛ≥®êŒ±i and Œì Û≥ÄÄÛ≥®ê(Œ±i ‚ÜíŒ±k). It now follows that Œì Û≥ÄÄÛ≥®êŒ±k.
Corollary 4.1.6. Let Œì be a set of formulas. If Œì
Ã∏Û≥ÄÄÛ≥®êœÜ, then Œì ‚ä¨œÜ.
Corollary 4.1.7. Let œÜ be a wff. If ‚ä¢œÜ, then Û≥ÄÄÛ≥®êœÜ.
Corollary 4.1.8. If ‚ä¢(œÜ ‚Üîœà), then the wffs œÜ and œà are logically equivalent.
Proof. Assume ‚ä¢(œÜ ‚Üîœà). By the soundness theorem, we conclude that Û≥ÄÄÛ≥®ê(œÜ ‚Üîœà).
Exercise 9(b) on page 88 implies that œÜ and œà are logically equivalent.
Recalling Theorem 3.3.61, a wff œÜ is an alphabetic variant of œÜ when œÜ differs from
œÜ only in the choice of quantified variables. For example, ‚àÄx‚àÄwPxw is an alphabetic
variant of ‚àÄx‚àÄzPxz.
Corollary 4.1.9. Suppose that œÜ is an alphabetic variant of œÜ. Then œÜ and œÜ are logically
equivalent.
Proof. Let œÜ be an alphabetic variant of œÜ. It follows from Theorem 3.3.61 that œÜ ‚ä¢œÜ and
œÜ ‚ä¢œÜ. By the soundness theorem, we have œÜ Û≥ÄÄÛ≥®êœÜ and œÜ Û≥ÄÄÛ≥®êœÜ‚Ä≤. Therefore, œÜ and œÜ are
logically equivalent.
Definition 4.1.10. A set of wffs Œì is satisfiable if for some structure A and some assign-
ment s we have A Û≥ÄÄÛ≥®êœÜ[s] for all œÜ ‚ààŒì.
Corollary 4.1.11. If Œì is satisfiable, then Œì is consistent.
Proof. Assume that Œì is satisfiable. We will show that Œì is consistent. Suppose, for a con-
tradiction, that there is a wff Œ≤ such that Œì ‚ä¢Œ≤ and Œì ‚ä¢¬¨Œ≤. Since Œì is satisfiable, let A

124
‡±™
4 Soundness and completeness
be a structure and let s be an assignment that satisfies every wff in Œì. The soundness
theorem now implies that A Û≥ÄÄÛ≥®êŒ≤[s] and A
Ã∏Û≥ÄÄÛ≥®êŒ≤[s], which is a contradiction.
Exercises 4.1.
1. Let c be a constant symbol and let Œ± be a wff. So c is substitutable for x in Œ±. Let A
be a structure and let s be an assignment. Let s(c) = d. Show that
A Û≥ÄÄÛ≥®êŒ±x
c[s]
iff
A Û≥ÄÄÛ≥®êŒ±[sx|d].
Conclude that if A Û≥ÄÄÛ≥®êŒ±x
c[s], then A Û≥ÄÄÛ≥®ê‚àÉxŒ±[s].
2. Let c be a constant symbol, let Œì be a set of wffs, and let œà be a wff. Suppose that
Œì Û≥ÄÄÛ≥®êœàx
c. Using Exercise 1, show that Œì Û≥ÄÄÛ≥®ê‚àÉxœà.
*3. Let t be a term that is substitutable for x in the wff œÜ. Show that {œÜx
t , x Ãá= t} Û≥ÄÄÛ≥®êœÜ.
4. Show that Px ‚ä¨‚àÄxPx. Conclude that {Px, ¬¨‚àÄxPx} is consistent.
5. Let Œì = {¬¨‚àÄv1Pv1, Pv2, Pv3, Pv4, . . . }. Is Œì is consistent?
6. A set of wffs Œì is said to be independent if for every wff œÜ ‚ààŒì, Œì \ {œÜ} ‚ä¨œÜ. Suppose
that for every œÜ ‚ààŒì, the set of wffs (Œì \ {œÜ}) ‚à™{¬¨œÜ} is satisfiable. Show that Œì is
independent.
7. Let ‚Ñí= { Ãá=} and let Œ± be the sentence ‚àÉx‚àÄy(y Ãá= x). Show that ‚ä¨Œ± and ‚ä¨¬¨Œ±.
4.2 The completeness theorem
The completeness theorem is the converse of the soundness theorem, but it is a much
deeper result. Given a set Œì of wffs, the completeness theorem shows that if Œì logically
implies a formula, then that formula is deducible from Œì. The completeness theorem
and its proof first appeared in the 1930 doctoral dissertation of Kurt G√∂del. The proof of
the completeness theorem presented below is due to Leon Henkin.
Theorem (Completeness). Let Œì be a set of first-order formulas and let œÜ be a wff.
(a) If Œì Û≥ÄÄÛ≥®êœÜ, then Œì ‚ä¢œÜ.
(b) If Œì is consistent, then Œì is satisfiable.
The basic idea behind the proof of (b) is as follows: Given that Œì is consistent, we
first construct a set of wffs Œî such that:
(1) for each wff œÜ and variable x, the wff ‚àÉxœÜ ‚ÜíœÜx
c is in Œî for a constant symbol c;
(2) Œì ‚äÜŒî;
(3) Œî is consistent;
(4) for every wff Œ±, either Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî.
We shall then use Œî to build a structure that satisfies Œì. Before we present the proof of
the completeness theorem, we need to state and prove some technical lemmas that will

4.2 The completeness theorem
‡±™
125
allow us to complete the above steps (1)‚Äì(4). In the proof of the completeness theorem,
we will then focus on the construction of the structure that satisfies Œì.
4.2.1 Technical lemmas
On page 2 we discussed indexed sets, that is, sets of the form {xi : i ‚ààI}, where I is an
unspecified set. Such notation will be used in this section.
Definition 4.2.1. Let ‚Ñíbe a first-order language. Let ‚Ñí‚Ä≤ = ‚Ñí‚à™{ci : i ‚ààI}, where each
ci is a new constant symbol that does not appear in ‚Ñíand ci
Ã∏= cj whenever i, j ‚ààI are
distinct. Then ‚Ñí‚Ä≤ is an extension of ‚Ñíby new constants.
Lemma 4.2.2 (Adding constants). Suppose Œì is a consistent set of wffs in a language ‚Ñí. Let
‚Ñí‚Ä≤ be an extension of ‚Ñíby new constants. Then Œì remains a consistent set of wffs in the
extended language ‚Ñí‚Ä≤.
Proof. Assume that Œì is a consistent set of wffs in the language ‚Ñí. Suppose, for a con-
tradiction, that Œì is an inconsistent set of wffs in the language ‚Ñí‚Ä≤. Therefore, there is
an ‚Ñí‚Ä≤-formula œÜ such that Œì ‚ä¢œÜ and Œì ‚ä¢¬¨œÜ, where the deductions take place in the
language ‚Ñí‚Ä≤. Let ‚ü®Œ±1, Œ±2, . . . , œÜ‚ü©be an ‚Ñí‚Ä≤-deduction of œÜ and let ‚ü®Œ≤1, Œ≤2, . . . , ¬¨œÜ‚ü©be an ‚Ñí‚Ä≤-
deduction of ¬¨œÜ. Since these two deductions are finite, there is only a finite number of
the new constant symbols that appear in these deductions. Suppose that the finite list
c1, . . . , cn contains all of the new constant symbols that appear in these deductions. The
proof of Theorem 3.3.56 implies that there are variables y1, . . . , yn that do not appear in
the two deductions ‚ü®Œ±1, Œ±2, . . . , œÜ‚ü©and ‚ü®Œ≤1, Œ≤2, . . . , ¬¨œÜ‚ü©such that the replacement of each
new constant symbol ci in the deductions with the variable yi results in ‚Ñí-deductions
‚ü®Œ±‚Ä≤
1, Œ±‚Ä≤
2, . . . , œÜ‚Ä≤‚ü©and ‚ü®Œ≤‚Ä≤
1, Œ≤‚Ä≤
2, . . . , ¬¨œÜ‚Ä≤‚ü©from Œì. We conclude that Œì is inconsistent in ‚Ñí. This
contradiction completes the proof.
In our next lemma, we will be adding constants to ‚Ñíthat act as ‚Äúwitnesses.‚Äù They
are called Henkin constants and will allow us to construct a structure in which each
existential formula that holds in the structure can be verified by a witness among the
new constants. Recall that ‚àÉvŒ± is an abbreviation of ¬¨‚àÄv¬¨Œ±.
Lemma 4.2.3 (Ensuring witnesses). Let ‚Ñíbe a first-order language and let Œì be a consis-
tent set of wffs in the language ‚Ñí. Let ‚Ñí‚Ä≤ = ‚Ñí‚à™{c‚Ä≤
i : i ‚ààI} be an extension of ‚Ñíby new
constants where ‚Ñíand I have the same cardinality. Then there is a set Œò of wffs in the
language ‚Ñí‚Ä≤ such that:
(1) Œì ‚äÜŒò;
(2) for every ‚Ñí‚Ä≤-wff œÜ and every variable x, the wff ‚àÉxœÜ ‚ÜíœÜx
c is in Œò for some new con-
stant symbol c;
(3) Œò is consistent in ‚Ñí‚Ä≤.

126
‡±™
4 Soundness and completeness
Before we present the proof, we make a comment. Let S = {c‚Ä≤
1, c‚Ä≤
2, c‚Ä≤
3, . . . } be an in-
finite set of new constant symbols. Given a finite subset A of S we shall be referring to
the ‚Äúfirst new constant symbol c not in A‚Äù. This will mean that c = c‚Ä≤
k, where k is the
smallest k such that c‚Ä≤
k ‚àâA. For example, if A = {c‚Ä≤
1, c‚Ä≤
2, c‚Ä≤
3, c‚Ä≤
6}, then c = c‚Ä≤
4 is the first new
constant symbol not in A.
Proof. Let ‚Ñíbe a countable first-order language and let ‚Ñí‚Ä≤ = ‚Ñí‚à™{c‚Ä≤
1, c‚Ä≤
2, c‚Ä≤
3, . . . } be an
extension of ‚Ñíby new constants. Consider the set
P = {‚ü®œÜ, v‚ü©: œÜ is an ‚Ñí‚Ä≤-wff and v is a variable of the language}.
Theorem 1.1.30 (on page 12) implies that the set of all wffs in the language ‚Ñí‚Ä≤ is a count-
able set, because the set of all wffs is a subset of the set of all finite sequences of symbols
in the countable language ‚Ñí‚Ä≤. From this it follows that the set P of pairs is also a count-
able set. Thus, let
‚ü®œÜ1, x1‚ü©, ‚ü®œÜ2, x2‚ü©, ‚ü®œÜ3, x3‚ü©, . . . , ‚ü®œÜn, xn‚ü©, . . .
(4.1)
be a fixed enumeration of all the pairs in P. Let Œ∏1 be the wff
‚àÉx1œÜ1 ‚ÜíœÜ1
x1
c1,
where c1 is the first new constant symbol not occurring in œÜ1. In general, let us define
(by recursion on ‚Ñï) Œ∏n to be the wff
‚àÉxnœÜn ‚Üí(œÜn)xn
cn,
where cn is the first new constant symbol not occurring in œÜn or in Œ∏k for all k < n. Let
Œò = Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏n, . . . }.
Clearly Œì satisfies conditions (1) and (2) of the statement of this lemma. We thus need to
show that Œò satisfies condition (3), that is, we must show that Œò is consistent.
Suppose, for a contradiction, that Œò is inconsistent. Theorem 3.3.38 implies that a
finite subset of Œò is inconsistent. Thus, there is a natural number m such that
Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m+1}
is inconsistent. Assume that m is the least such m. Since Œì is consistent, we must have
m ‚â•0. By the reductio ad absurdum corollary (Corollary 3.3.37), it follows that
Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m} ‚ä¢¬¨Œ∏m+1.
That is,

4.2 The completeness theorem
‡±™
127
Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m} ‚ä¢¬¨(‚àÉxœÜ ‚ÜíœÜx
c)
for some œÜ, x, c. As ¬¨(‚àÉxœÜ ‚ÜíœÜx
c) ‚Üí‚àÉxœÜ and ¬¨(‚àÉxœÜ ‚ÜíœÜx
c) ‚Üí¬¨œÜx
c are tautologies, rule T
(Theorem 3.3.31) implies that
Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m} ‚ä¢‚àÉxœÜ,
(‚ãÜ)
Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m} ‚ä¢¬¨œÜx
c.
(‚ãÜ‚ãÜ)
Since the constant symbol c occurs neither in œÜ nor in any formula in Œì‚à™{Œ∏1, Œ∏2, . . . , Œ∏m},
Corollary 3.3.58 with (‚ãÜ‚ãÜ) implies that
Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m} ‚ä¢‚àÄx¬¨œÜ.
However, (‚ãÜ) implies (after removing the abbreviation) that
Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m} ‚ä¢¬¨‚àÄx¬¨œÜ.
So, Œì ‚à™{Œ∏1, Œ∏2, . . . , Œ∏m} is inconsistent. This contradicts the leastness of m if m > 0, and
contradicts the consistency of Œì if m = 0.
Remark 4.2.4. The proof of Lemma 4.2.3 assumes that the language ‚Ñíis countable. The
lemma still holds for uncountable languages by a modification of this proof, which re-
quires knowledge of cardinal numbers. Suppose that ‚Ñíand I both have cardinality Œ∫,
where Œ∫ is an uncountable cardinal. We can presume that I = Œ∫. In the above proof,
replace (4.1) with the sequence of pairs
‚ü®œÜŒ≥, xŒ≥‚ü©Œ≥‚ààŒ∫
indexed by the ordinals Œ≥ ‚ààŒ∫. For each Œ≥ ‚ààŒ∫, define (by recursion) Œ∏Œ≥ to be the wff
‚àÉxŒ≥œÜŒ≥ ‚Üí(œÜŒ≥)xŒ≥
cŒ≥,
where cŒ≥ is the first new constant symbol not occurring in œÜŒ≥ or in Œ∏Œ∑ for all Œ∑ ‚ààŒ≥. It
then follows that Œò = Œì ‚à™{Œ∏Œ∑ : Œ∑ ‚ààŒ∫} is consistent.
Let Œò be as in Lemma 4.2.3. Our next result will allow us to extend Œò to a maximal
consistent set of wffs.
Lemma 4.2.5 (Going to the max). Let ‚Ñíbe a first-order language and suppose that Œò is a
consistent set of wffs in the language ‚Ñí. Then there is a set Œî of wffs in the language ‚Ñísuch
that:
(1) Œò ‚äÜŒî;
(2) Œî is consistent;
(3) for every wff œÜ, either œÜ ‚ààŒî or (¬¨œÜ) ‚ààŒî but not both;
(4) for every wff œÜ, if Œî ‚ä¢œÜ, then œÜ ‚ààŒî.

128
‡±™
4 Soundness and completeness
Proof. Let ‚Ñíbe a countable first-order language. Theorem 1.1.30 (on page 12) implies that
the set of all wffs is a countable set, because the set of all wffs is a subset of the set of all
finite sequences of symbols in the language ‚Ñí. Thus, let
Œ¥1, Œ¥2, Œ¥3, . . . , Œ¥n, . . .
(4.2)
be a fixed enumeration of all the wffs in the language ‚Ñí. Define by recursion on ‚Ñïthe
following sets:
(i)
Œî0 = Œò
(ii) Œîn+1 = {Œîn ‚à™{Œ¥n+1},
if Œîn ‚à™{Œ¥n+1} is consistent,
Œîn ‚à™{¬¨Œ¥n+1},
otherwise.
We shall now establish four claims.
Claim 1. For all n ‚àà‚Ñï, Œîn is consistent.
Proof of Claim 1. We shall use induction on n.
Base step: Let n = 0. Then Œî0 = Œò, which is consistent by assumption.
Inductive step: Let n ‚àà‚Ñïbe arbitrary. Assume the induction hypothesis
Œîn is consistent.
(IH)
We will prove that Œîn+1 is consistent. Suppose, for a contradiction, that Œîn+1 is not consis-
tent. Thus, it follows from the above definition (ii) of Œîn+1 that Œîn ‚à™{Œ¥n+1} is inconsistent
and Œîn‚à™{¬¨Œ¥n+1} is inconsistent. By the reductio ad absurdum corollary (Corollary 3.3.37),
it follows that
Œîn ‚ä¢¬¨Œ¥n+1,
Œîn ‚ä¢Œ¥n+1.
Thus, Œîn is inconsistent, contradicting the induction hypothesis (IH).
(Claim 1)
Let Œî = ‚ãÉn‚àà‚ÑïŒîn. Clearly, Œò ‚äÜŒî (as Œò = Œî0), and (Û≥µ≥) Œîn ‚äÜŒîn+1 for all n ‚àà‚Ñï.
Claim 2. The set Œî is consistent.
Proof of Claim 2. Suppose, to the contrary, that Œî is inconsistent. By Theorem 3.3.38 there
is a finite subset Œ† of Œî that is inconsistent. Since Œ† ‚äÜŒî = ‚ãÉn‚àà‚ÑïŒîn and Œ† is finite, it
follows, from (Û≥µ≥), that Œ† ‚äÜŒîn for some n. Hence, Œîn must be inconsistent, contradicting
Claim 1.
(Claim 2)
Claim 3. For every wff Œ±, either Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî, but not both.
Proof of Claim 3. Let Œ± be any wff. Since (4.2) lists all of the wffs, there is an n ‚àà‚Ñïsuch
that Œ± = Œ±n. So either Œ±n ‚ààŒîn or (¬¨Œ±n) ‚ààŒîn by (ii) above. Since Œîn ‚äÜŒî, it follows that

4.2 The completeness theorem
‡±™
129
Œ± ‚ààŒî or (¬¨Œ±) ‚ààŒî. If Œ± ‚ààŒî and (¬¨Œ±) ‚ààŒî, then Œî would be inconsistent, contradicting
Claim 2. Hence, we cannot have Œ± ‚ààŒî and (¬¨Œ±) ‚ààŒî.
(Claim 3)
Claim 4. For every wff œÜ, if Œî ‚ä¢œÜ, then œÜ ‚ààŒî.
Proof of Claim 4. Let Œ± be any wff. Assume that Œî ‚ä¢œÜ. To prove that œÜ ‚ààŒî, suppose
to the contrary that œÜ ‚àâŒî. By Claim 3, we see that ¬¨œÜ ‚ààŒî. Thus, Œî ‚ä¢¬¨œÜ. Hence, Œî is
inconsistent, contradicting Claim 2.
(Claim 4)
Therefore, Œî satisfies conditions (1)‚Äì(4) stated in the lemma.
(Lemma)
Remark 4.2.6. The proof of Lemma 4.2.5 assumes that the language ‚Ñíis countable. How-
ever, Lemma 4.2.5 also holds when ‚Ñíis uncountable. In this case, one can obtain the set
Œî by applying Zorn‚Äôs lemma (Lemma 1.1.36).
4.2.2 Proof of the completeness theorem
Given a consistent set of ‚Ñí-wffs Œì, the upcoming proof of the completeness theorem con-
structs a structure A and an assignment s. It is then shown that A Û≥ÄÄÛ≥®êŒ±[s] for all Œ± ‚ààŒì. To
do this, one first lets ‚Ñí‚Ä≤ be an extension of ‚Ñíby adding infinitely many new constants.
The structure A is then constructed, surprisingly, by using the terms of ‚Ñí‚Ä≤.
Definition 4.2.7. Let ‚Ñíbe a language. For each wff Œ±, let n(Œ±) be the number of places
at which connectives and quantifier symbols appear in Œ±.
For example, let Œ± be the wff ‚àÄv(Pv ‚Üí¬¨Qt). Then n(Œ±) = 3 and n(Qt) = 0. Now let
Œ± be any wff. For any variable x and term t, note that the resulting substitution Œ±x
t does
not add any connectives and quantifier symbols to Œ±. In fact, n(Œ±) = n(Œ±x
t ).
Theorem 4.2.8 (Completeness). Let Œì be a set of ‚Ñí-wffs and let œÜ be an ‚Ñí-wff.
(a) If Œì Û≥ÄÄÛ≥®êœÜ, then Œì ‚ä¢œÜ.
(b) If Œì is consistent, then Œì is satisfiable.
Proof. We only provide a proof of (b), as (b) implies (a) (see Exercise 2). So, let Œì be
a consistent set of formulas in a language ‚Ñí. We must prove that Œì is satisfiable, that
is, we must identify a structure and an assignment that satisfies every wff œÜ in Œì. Let
‚Ñí‚Ä≤ = ‚Ñí‚à™{ci : i ‚ààI} be an extension of ‚Ñíby new constants where ‚Ñíand I have the same
cardinality. By the ‚Äúadding constants‚Äù Lemma 4.2.2, we know that Œì remains consistent
in the language ‚Ñí‚Ä≤. By the ‚Äúensuring witnesses‚Äù Lemma 4.2.3, we know that there is a set
Œò of wffs in the language ‚Ñí‚Ä≤ such that
(1) Œì ‚äÜŒò;
(2) for every ‚Ñí‚Ä≤-wff œÜ and every variable x, the wff ‚àÉxœÜ ‚ÜíœÜx
c is in Œò for some new
constant symbol c;
(3) Œò is consistent in ‚Ñí‚Ä≤.

130
‡±™
4 Soundness and completeness
By the ‚Äúgoing to the max‚Äù Lemma 4.2.5, there is a set Œî of ‚Ñí‚Ä≤-wffs such that:
(4) Œò ‚äÜŒî;
(5) Œî is consistent;
(6) for every wff œÜ, either œÜ ‚ààŒî or (¬¨œÜ) ‚ààŒî, but not both;
(7) for every wff œÜ, if Œî ‚ä¢œÜ, then œÜ ‚ààŒî.
We will now construct a structure. There are two cases to consider. The first case is when
the language ‚Ñídoes not contain the equality symbol
Ãá=. The second case is when the
language does contain Ãá=.
Case 1: The language ‚Ñídoes not contain the equality symbol
Note that Œì ‚äÜŒò ‚äÜŒî. We shall now use the set Œî to construct a structure A for the
language ‚Ñí‚Ä≤ as follows:
(a) Let A, the domain of A, be the set of all terms in the language ‚Ñí‚Ä≤.
(b) For each n-place predicate symbol P define PA by
‚ü®t1, t2, . . . , tn‚ü©‚ààPA
iff
the atomic formula Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn belongs to Œî.
(c) For each n-place function symbol f define f A by
f A(t1, t2, . . . , tn) = ft1t2 ‚ãÖ‚ãÖ‚ãÖtn.
(d) For each constant symbol c define cA by cA = c.
Now define an assignment s by
s(v) = {v,
if v is a variable,
c,
if v is a constant symbol c.
(Û≥µ≥)
Note that s: ùíØ‚ÜíùíØ, where ùíØconsists of the variables and constant symbols of ‚Ñí‚Ä≤ and
ùíØis the set of all the terms of ‚Ñí‚Ä≤. Also note that A = ùíØ.
Claim 1. For all terms t, we have s(t) = t.
Proof. One can prove this by using induction on terms using (Û≥µ≥).
(Claim 1)
Claim 2. For every wff œÜ, we have A Û≥ÄÄÛ≥®êœÜ[s] if and only if œÜ ‚ààŒî.
Proof. Let A and s be defined as above. We shall prove the following statement by strong
induction on the natural number k:
For all ‚Ñí‚Ä≤-wffs œÜ, if n(œÜ) = k, then A Û≥ÄÄÛ≥®êœÜ[s] iff œÜ ‚ààŒî.
Base step: Let k = 0. If n(œÜ) = 0, then œÜ = Pt1 ‚ãÖ‚ãÖ‚ãÖtn for some atomic formula. Thus,

4.2 The completeness theorem
‡±™
131
A Û≥ÄÄÛ≥®êPt1 ‚ãÖ‚ãÖ‚ãÖtn[s]
iff
‚ü®s(t1), . . . , s(tn)‚ü©‚ààPA
by Definition 3.2.6(2),
iff
‚ü®t1, . . . , tn‚ü©‚ààPA
by Claim 1,
iff
Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn ‚ààŒî
by (b), above.
Inductive step: Let k > 0. Assume the strong induction hypothesis:
For all ‚Ñí‚Ä≤-wffs œÜ, if n(œÜ) < k, then
A Û≥ÄÄÛ≥®êœÜ[s]
iff
œÜ ‚ààŒî.
(IH)
Let Œ∏ be an ‚Ñí‚Ä≤-wff such that n(Œ∏) = k. We must prove that A Û≥ÄÄÛ≥®êŒ∏[s] iff Œ∏ ‚ààŒî. Since k > 0,
Œ∏ must have one of the following forms:
(¬¨Œ±), (Œ± ‚ÜíŒ≤), ‚àÄvŒ±,
where n(Œ±) < k and n(Œ≤) < k. Thus, the induction hypothesis applies to Œ± and Œ≤.
Case (¬¨Œ±): We show that A Û≥ÄÄÛ≥®ê(¬¨Œ±)[s] iff (¬¨Œ±) ‚ààŒî as follows:
A Û≥ÄÄÛ≥®ê(¬¨Œ±)[s]
iff
A
Ã∏Û≥ÄÄÛ≥®êŒ±[s]
by Definition 3.2.6(3),
iff
Œ± ‚àâŒî
by (IH),
iff
¬¨Œ± ‚ààŒî
by (6), above.
Case (Œ± ‚ÜíŒ≤): We show that A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[s] iff (Œ± ‚ÜíŒ≤) ‚ààŒî as follows:
A Û≥ÄÄÛ≥®ê(Œ± ‚ÜíŒ≤)[s]
iff
if A Û≥ÄÄÛ≥®êŒ±[s], then A Û≥ÄÄÛ≥®êŒ≤[s]
by Definition 3.2.6(4),
iff
if Œ± ‚ààŒî, then Œ≤ ‚ààŒî
by (IH),
iff
(Œ± ‚ÜíŒ≤) ‚ààŒî
by Exercise 1.
Case ‚àÄvŒ±: We must show that A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s] iff ‚àÄvŒ± ‚ààŒî.
(‚áí). Assume that A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s], that is, assume that A Û≥ÄÄÛ≥®êŒ±[sv|t], for all t ‚ààA (by
Definition 3.2.6(5) and as A = ùíØ). Thus, in particular, we have
A Û≥ÄÄÛ≥®êŒ±[sv|c], for all constant symbols c ‚ààA.
(4.3)
We shall prove that ‚àÄvŒ± ‚ààŒî. Suppose, for a contradiction, that ‚àÄvŒ± ‚àâŒî. By (6) we infer
that ¬¨‚àÄvŒ± ‚ààŒî. By Exercise 27 on page 118, we have ‚ä¢¬¨‚àÄvŒ± ‚Üí¬¨‚àÄv¬¨¬¨Œ±. Thus, Œî ‚ä¢‚àÉv¬¨Œ±
(using the abbreviation). So, by (2), (4), and (7), we conclude that
¬¨Œ±v
c ‚ààŒî
for some constant symbol c.
(4.4)
As n(Œ±v
c) = n(Œ±) < k, the induction hypothesis (IH) and (4.4) imply that A Û≥ÄÄÛ≥®ê¬¨Œ±v
c[s]. Thus,
A Û≥ÄÄÛ≥®ê¬¨Œ±[sv|s(c)] by Lemma 4.1.2. As s(c) = c by Claim 1, we conclude that A Û≥ÄÄÛ≥®ê¬¨Œ±[sv|c] and
this contradicts (4.3). Therefore, ‚àÄvŒ± ‚ààŒî.

132
‡±™
4 Soundness and completeness
(‚áê). Assume that ‚àÄvŒ± ‚ààŒî. We will show that A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s], that is, we will show that
A Û≥ÄÄÛ≥®êŒ±[sv|t], for all t ‚ààA. To do this, let t ‚ààA. Corollary 4.1.3 implies that there is a wff Œ±
such that n(Œ±) = n(Œ±), Œ± ‚ä¢Œ±, Œ± ‚ä¢Œ±, t is substitutable for v in Œ±, and
A Û≥ÄÄÛ≥®êŒ±v
t [s]
iff
A Û≥ÄÄÛ≥®êŒ±[sv|t],
(4.5)
as s(t) = t by Claim 1. We now show that A Û≥ÄÄÛ≥®êŒ±[sv|t]. Since Œ± ‚ä¢Œ±, Lemma 3.3.60 implies
that ‚àÄvŒ± ‚ä¢‚àÄvŒ±. As ‚àÄvŒ± ‚ààŒî, we conclude that ‚àÄvŒ± ‚ààŒî by (7). Because t is substitutable
for v in Œ±, we see that ‚àÄvŒ± ‚ÜíŒ±v
t is a logical axiom. Hence, Œî ‚ä¢Œ±v
t so Œ±v
t ‚ààŒî. Since
n(Œ±v
t ) = n(Œ±) < k, the induction hypothesis (IH) implies that A Û≥ÄÄÛ≥®êŒ±v
t [s]. By (4.5), we
conclude that A Û≥ÄÄÛ≥®êŒ±[sv|t]. Since Œ± ‚ä¢Œ±, the soundness theorem (Theorem 4.1.5) implies
that A Û≥ÄÄÛ≥®êŒ±[sv|t]. Therefore, A Û≥ÄÄÛ≥®ê‚àÄvŒ±[s].
(Claim 2)
Thus, the structure A and the assignment s satisfy every formula in Œî and, because
Œì ‚äÜŒî, A and s satisfy every formula in Œì. Recall, however, that A is a structure for
the language ‚Ñí‚Ä≤. By restricting the structure A to the language ‚Ñí(that is, by removing
the interpretations of new constant symbols from A), we shall then have our desired
structure for the language ‚Ñí.
Case 2: The language ‚Ñídoes contain the equality symbol
Recall that Œì ‚äÜŒò ‚äÜŒî. By ignoring the equality symbol, we can construct the struc-
ture A just as was done in case 1. Thus, the domain of the structure A is the set A of all
the terms of the language ‚Ñí‚Ä≤. We can now use A to build a new structure whose domain
is a set of equivalence classes of A, also called a quotient structure.
Before we construct our new structure, we first define an equivalence relation on
the set A of terms. For any t, œÑ ‚ààA, define the relation t ‚àºœÑ as follows:
œÑ ‚àºt
iff
(œÑ Ãá= t) ‚ààŒî.
(4.6)
One can now prove that ‚àºis a symmetric relation on A as follows. Assume that t1 ‚àºt2.
Then (t1 Ãá= t2) ‚ààŒî, and thus Œî ‚ä¢t1 Ãá= t2. Using Logical Axiom 2, Theorem 3.3.54(2) implies
that Œî ‚ä¢t2
Ãá= t1, and thus (t2
Ãá= t1) ‚ààŒî. So t2 ‚àºt1. Similar reasoning will confirm the
following claim.
Claim 3. Let ‚àºbe the relation on A defined by (4.6). Then:
(i)
‚àºis an equivalence relation on A;
(ii) for all terms t1, t2 and œÑ1, œÑ2, if t1 ‚àºœÑ1 and t2 ‚àºœÑ2, then
Pt1t2 ‚ààŒî
iff
PœÑ1œÑ2 ‚ààŒî,
where P is a 2-place predicate symbol, and similarly for n-place predicate symbols;
(iii) for all terms t1, t2 and œÑ1, œÑ2, if t1 ‚àºœÑ1 and t2 ‚àºœÑ2, then ft1t2 ‚àºfœÑ1œÑ2, where f is a 2-place
function symbol, and similarly for n-place function symbols.

4.2 The completeness theorem
‡±™
133
Proof Sketch. Note that for all œÑ, t ‚ààA, we have
œÑ ‚àºt
iff
(œÑ Ãá= t) ‚ààŒî
iff
Œî ‚ä¢œÑ Ãá= t.
One proves items (i), (ii), and (iii) as follows:
(i)
To show that ‚àºis an equivalence relation on A, one uses items (1), (2), and (3) of
Theorem 3.3.54 and Logical Axiom 2.
(ii) One applies (4) of Theorem 3.3.54 to show that for all terms t1, t2 and œÑ1, œÑ2, if t1 ‚àºœÑ1
and t2 ‚àºœÑ2, then
Pt1t2 ‚ààŒî
iff
PœÑ1œÑ2 ‚ààŒî,
where P is a 2-place predicate symbol, and similarly, for n-place predicate symbols.
(iii) One employs (5) of Theorem 3.3.54 to show that for all terms t1, t2 and œÑ1, œÑ2, if t1 ‚àºœÑ1
and t2 ‚àºœÑ2, then ft1t2 ‚àºfœÑ1œÑ2, where f is a 2-place function symbol, and similarly for
n-place function symbols.
(Claim 3)
Since ‚Ñícontains equality, we use the set Œî, together with the equivalence relation
‚àº, to construct a structure B for the language ‚Ñí‚Ä≤ (see Section 1.1.2) as follows:
(a) Let the domain of B be B = A/‚àº= {[t] : t ‚ààA}, the set of all equivalence classes.
(b) For each n-place predicate symbol P, define PB by
‚ü®[t1], [t2], . . . , [tn]‚ü©‚ààPB
iff
the atomic formula Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn belongs to Œî.
(c) For each n-place function symbol f , define f B by
f B([t1], [t2], . . . , [tn]) = [ft1t2 ‚ãÖ‚ãÖ‚ãÖtn].
(d) For each constant symbol c, define cB by cB = [c].
Claim 3 implies that every PB and f B are ‚Äúcompatible‚Äù with ‚àº. Thus, each PB and f B
is ‚Äúwell-defined.‚Äù Now define an assignment s by
s(v) = {[v],
if v is a variable,
[c],
if v is a constant symbol c.
(4.7)
Using Claim 3, the proofs of the following two claims are very similar to the proofs of
the corresponding Claims 1 and 2 in case 1. For the proof of Claim 5 below, in the ‚Äúbase
step‚Äù one must include the atomic formula t1 Ãá= t2 for terms t1 and t2.
Claim 4. For all terms t, we have s(t) = [t].
Claim 5. For every wff œÜ, we have B Û≥ÄÄÛ≥®êœÜ[s] if and only if œÜ ‚ààŒî.

134
‡±™
4 Soundness and completeness
As before, after restricting the structure B to the language ‚Ñí, we have our desired struc-
ture in the language ‚Ñíand an assignment that satisfies every wff œÜ in Œì.
(Theorem)
So, given a consistent set of formulas Œì, it has a model. The early attempts to prove
Euclid‚Äôs parallel postulate by contradiction would have benefited from the knowledge of
the completeness theorem. An historical remark: Girolamo Saccheri tried to prove the
parallel postulate by reductio ad absurdum, that is, he denied the parallel postulate and
assumed the other axioms of geometry, hoping to derive a contradiction. This failed at-
tempt could make one wonder if the negation of the parallel postulate is consistent with
the other axioms. In any case, Saccheri made no attempt to find a model of geometry
in which the parallel postulate is false. He had no idea that the result of his investiga-
tions were theorems about non-Euclidean geometry. Saccheri gave up his study of the
negation of the parallel postulate and, as a result, was not credited with the discovery
of non-Euclidean geometry.
The soundness theorem (Theorem 4.1.5) and the completeness theorem (Theo-
rem 4.2.8) clearly imply the following equivalence.
Corollary 4.2.9. Let Œì be a set of formulas. Then Œì ‚ä¢œÜ if and only if Œì Û≥ÄÄÛ≥®êœÜ.
4.2.3 The compactness theorem
The next theorem is the key result that led the logician Abraham Robinson to discover
nonstandard analysis. Nonstandard analysis revives the notion of an ‚Äúinfinitesimal‚Äù‚Äîa
number that is infinitely small yet greater than zero (see Section 4.3.1). New theorems
in analysis, functional analysis, and other areas of mathematics have been discovered
as a result of Robinson‚Äôs work. Apparently, mathematical logic is an applicable branch
of mathematics.
Theorem 4.2.10 (Compactness theorem). Let Œì be a set of wffs and let œÜ be a wff.
(a) If Œì Û≥ÄÄÛ≥®êœÜ, then for some finite Œì0 ‚äÜŒì, we have Œì0 Û≥ÄÄÛ≥®êœÜ.
(b) If every finite subset of Œì is satisfiable, then Œì is satisfiable.
Proof. Let Œì be a set of formulas.
(a) Assume that Œì Û≥ÄÄÛ≥®êœÜ. The completeness theorem thus implies that Œì ‚ä¢œÜ. Since de-
ductions are finite, there is a finite subset Œì0 ‚äÜŒì such that Œì0 ‚ä¢œÜ. Thus, by the
soundness theorem, we conclude that Œì0 Û≥ÄÄÛ≥®êœÜ.
(b) Assume that every finite subset of Œì is satisfiable. Thus, every finite subset of Œì is
consistent by Corollary 4.1.11. Hence, by Exercise 24 on page 118, Œì is consistent. So
Œì is satisfiable by part (b) of the completeness theorem (Theorem 4.2.8).
The following definition is presented here for some of the exercises.

4.2 The completeness theorem
‡±™
135
Definition 4.2.11. A set of formulas Œ£ is maximally consistent if Œ£ is consistent but Œ£‚à™{œÜ}
is inconsistent for any œÜ ‚àâŒ£.
Exercises 4.2.
*1. Let Œ±, Œ≤, and Œî be as in the proof of Theorem 4.2.8. Show that
if Œ± ‚ààŒî, then Œ≤ ‚ààŒî
iff
(Œ± ‚ÜíŒ≤) ‚ààŒî.
*2. In Theorem 4.2.8, show that (b) implies (a).
3. Let Œì be a set of ‚Ñí-wffs and let œÜ be a logically valid wff. Show that Œì ‚ä¢œÜ.
4. Let Œì be a set of ‚Ñí-wffs, let A be an ‚Ñí-structure with domain A, and let V be the set
of variables in ‚Ñí. We write A Û≥ÄÄÛ≥®ê‚àóŒì to mean that A Û≥ÄÄÛ≥®êœÜ[s] for every assignment
s: V ‚ÜíA and for every œÜ ‚ààŒì. Now let Œì and Œ£ be sets of ‚Ñí-wffs. Suppose that for
every ‚Ñí-structure A, we have
A Û≥ÄÄÛ≥®ê‚àóŒì
iff
A Û≥ÄÄÛ≥®ê‚àóŒ£.
Show that
for all wffs œÜ, Œì ‚ä¢œÜ
iff
Œ£ ‚ä¢œÜ.
5. Let A be a structure and let s be an assignment. Prove that Œ£ = {œÜ : A Û≥ÄÄÛ≥®êœÜ[s]} is
maximally consistent.
6. Let Œ£ be a maximally consistent set of formulas. Prove that if œÜ is a formula and
Œ£ ‚ä¢œÜ, then œÜ ‚ààŒ£.
*7. Let t be a term that is substitutable for x in the wff œÜ. Show that {œÜx
t , x Ãá= t} ‚ä¢œÜ.
8. Suppose that Œ£ is a maximally consistent set of formulas and œÜ is a formula. Prove
that ¬¨œÜ ‚ààŒ£ if and only if œÜ ‚àâŒ£.
9. Let Œì be a set of sentences in a language ‚Ñí. Suppose that for every ‚Ñí-structure A,
there is a sentence œÉ ‚ààŒì such that A Û≥ÄÄÛ≥®êœÉ. Using the compactness theorem, show
that there must be a finite number of sentences œÉ1, œÉ2, . . . , œÉn in Œì such that the
sentence œÉ1 ‚à®œÉ2 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®œÉn is logically valid.
10. Let Œì be a set of sentences in a language ‚Ñí. Suppose that Œì is finitely satisfiable. Let
œÜ be a wff. Show that either Œì ‚à™{œÜ} or Œì ‚à™{¬¨œÜ} is finitely satisfiable.
11. Let Œ£0 ‚äÜŒ£1 ‚äÜŒ£2 ‚äÜŒ£3 ‚äÜ‚ãÖ‚ãÖ‚ãÖbe sets of wffs where each Œ£i is finitely satisfiable.
Show that ‚ãÉi‚àà‚ÑïŒ£i is finitely satisfiable. Conclude that there is a structure A and an
assignment s such that A Û≥ÄÄÛ≥®êœÜ[s] for all œÜ ‚àà‚ãÉi‚àà‚ÑïŒ£i.
12. Let c be a constant symbol that does not appear in the wffs œÜ, œà, or in any wff in Œì.
Suppose that Œì; œàx
c Û≥ÄÄÛ≥®êœÜ. Show that Œì; ‚àÉxœà Û≥ÄÄÛ≥®êœÜ.
13. Let Œì be a set of ‚Ñí-wffs and let ‚Ñí‚Ä≤ be an extension of ‚Ñíby new constants. Show that
for every ‚Ñí-wff œÜ, if there is a deduction of œÜ from Œì in the language ‚Ñí‚Ä≤, then there
is a deduction of œÜ from Œì in the language ‚Ñí.

136
‡±™
4 Soundness and completeness
Exercise Notes: For Exercise 1, ¬¨(Œ± ‚ÜíŒ≤) ‚ÜíŒ± and ¬¨(Œ± ‚ÜíŒ≤) ‚Üí¬¨Œ≤ are tautologies. For
Exercise 2, see Exercise 25 on page 118. For Exercise 7, see Exercise 3 on page 124. For
Exercise 12, see Theorem 3.3.56.
4.3 Applications
In this section, we will present some applications of the soundness, completeness, and
compactness theorems. We first give an application of the compactness theorem. Recall
that the compactness theorem implies that if every finite subset of a set of sentences Œ£
has a model, then Œ£ also has a model.
Theorem 4.3.1. Let Œ£ be a set of sentences in the language ‚Ñí. If Œ£ has arbitrarily large
finite models, then Œ£ has an infinite model.
Before we prove this theorem, we discuss the idea behind the proof. One first identi-
fies an infinite set Œì of sentences which describes the desired properties. Then one shows
that every finite subset of Œì has a model. The compactness theorem then implies that Œì
has a model and this model will have all of the desired properties.
Proof of Theorem 4.3.1. Let Œ£ be a set of sentences. Suppose that Œ£ has arbitrarily large
finite models. Let us assume that the language contains the equality symbol Ãá=. For each
k ‚â•2, let Œªk be an ‚Ñí-sentence that asserts ‚Äúthere are at least k things;‚Äù for example,
Œª3 = ‚àÉv1‚àÉv2‚àÉv3(v1
Ã∏Ãá= v2 ‚àßv1
Ã∏Ãá= v3 ‚àßv2
Ã∏Ãá= v3)
asserts ‚Äúthere are at least three things.‚Äù We show that Œì = Œ£ ‚à™{Œª2, Œª3, . . . } has a model.
Let Œ† ‚äÜŒì be finite. We can write Œ† = Œ†0 ‚à™Œ†1, where Œ†0 ‚äÜŒ£ and Œ†1 ‚äÜ{Œª2, Œª3, . . . }. Since
Œ†1 is finite, it has the form
Œ†1 = {Œªi1, . . . , Œªik},
where k ‚àà‚Ñï.
Let n = max{i1, . . . , ik}. Thus, n is the largest natural number so that Œªn ‚ààŒ†1. By our
assumption, there is a model A of Œ£ with at least n elements. Thus, A Û≥ÄÄÛ≥®êŒªn and hence,
A Û≥ÄÄÛ≥®êŒ†1. Since Œ†0 ‚äÜŒ£, A satisfies all of the sentences in Œ†0. It now follows that A must
also satisfy all of the sentences in Œ†. So every finite subset of Œì has a model and thus, by
the compactness theorem (Theorem 4.2.10), Œì has a model B. Since Œ£ ‚äÜŒì and B Û≥ÄÄÛ≥®êŒªk
for all k ‚â•2, it follows that B is an infinite model of Œ£.
If the language does not contain the equality symbol Ãá=, then one can add it to the
language ‚Ñíand then argue as above to get the model B of Œ£. Then we remove Ãá=B from
B to get an infinite ‚Ñí-model of Œ£.

4.3 Applications
‡±™
137
4.3.1 Nonstandard models
In mathematical logic, a nonstandard model is a structure that is a proper elementary
extension of a standard model.
Definition 4.3.2. Let A and B be ‚Ñí-structures, where A is a substructure of B. Then B
is said to be an elementary extension of A, denoted by A ‚â∫B, if and only if for every
assignment s: ùíØ‚ÜíA and every ‚Ñí-formula œÜ, we have
A Û≥ÄÄÛ≥®êœÜ[s]
iff
B Û≥ÄÄÛ≥®êœÜ[s],
where ùíØis the set of all the variables and constants in ‚Ñíand A is the domain of A.
Consider the language ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} and the ‚Ñí-structure
ùí©= ‚ü®‚Ñï; 0, S, <, +, √ó, E‚ü©,
where Ãá0ùí©= 0, ÃáSùí©= S (successor function), Ãá<ùí©= < (the usual ‚Äúless than‚Äù relation),
and Ãá+ùí©= +, Ãá√óùí©= √ó, ÃáEùí©= E are the usual operations of addition, multiplication, and
exponentiation, respectively. The structure ùí©is called the standard model of arithmetic
because it is a number system that is commonly used in mathematics and its domain is
the set of the standard natural numbers
‚Ñï= {0, 1, 2, 3, 4, . . . }.
A nonstandard model of arithmetic is one that contains nonstandard numbers. Using
the compactness theorem, we can construct a nonstandard model of arithmetic.
Let Œì = Th(ùí©) (see Definition 3.2.31) and let ‚Ñí‚Ä≤ = ‚Ñí‚à™{c} be an extension of ‚Ñíby one
new constant symbol. Let Œ£ be the following infinite set of atomic ‚Ñí‚Ä≤-formulas
Œ£ = { Ãá0 Ãá< c,
ÃáS Ãá0 Ãá< c, ÃáS ÃáS Ãá0 Ãá< c, . . . , ÃáSn Ãá0 Ãá< c, . . . },
where ÃáSn Ãá0 denotes the term
n times
‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû
ÃáS ÃáS ‚ãÖ‚ãÖ‚ãÖÃáS Ãá0. Note that ( ÃáSn Ãá0)ùí©= n for each natural number n ‚â•
1. Let Œ† ‚äÜŒì ‚à™Œ£ be finite. Let Œ† = Œ†0 ‚à™Œ†1, where Œ†0 ‚äÜŒì and Œ†1 ‚äÜŒ£. Since ùí©Û≥ÄÄÛ≥®êŒ†0,
we just need to interpret c so that we can use ùí©to get a model of Œ†1 as well. Since Œ†1 is
finite, it has the form
Œ†1 = { ÃáSn1 Ãá0 Ãá< c, . . . , ÃáSni Ãá0 Ãá< c},
where i ‚àà‚Ñï.
Let k = max{n1, . . . , ni} + 1. Thus, ( ÃáSn1 Ãá0)ùí©< k, ‚Ä¶, ( ÃáSni Ãá0)ùí©< k. Therefore, the structure
ùí©k = ‚ü®‚Ñï; 0, S, <, +, √ó, E, k‚ü©,
where cùí©k = k,

138
‡±™
4 Soundness and completeness
is a model of Œ†1 and thus it is a model of Œ†, because ùí©k Û≥ÄÄÛ≥®êŒ†0. By the compactness
theorem (Theorem 4.2.10), Œì ‚à™Œ£ has a model
‚Ñ≥= ‚ü®M; Ãá0‚Ñ≥, ÃáS‚Ñ≥, Ãá<‚Ñ≥, Ãá+‚Ñ≥, Ãá√ó‚Ñ≥, ÃáE‚Ñ≥, c‚Ñ≥‚ü©.
Now let ‚Ñ≥be the following restriction of ‚Ñ≥to the original language ‚Ñí, that is, let
‚Ñ≥= ‚ü®M; Ãá0‚Ñ≥, ÃáS‚Ñ≥, Ãá<‚Ñ≥, Ãá+‚Ñ≥, Ãá√ó‚Ñ≥, ÃáE‚Ñ≥‚ü©.
Thus, ‚Ñ≥is a model of Th(ùí©). As every n ‚àà‚Ñïcan be identified with ( ÃáSn Ãá0)‚Ñ≥, we can
view ‚Ñïas being a subset of M. However, since ‚Ñ≥contains the ‚Äúinfinite‚Äù number c‚Ñ≥,
it follows that ‚Ñ≥and ùí©are not isomorphic. Nevertheless, Exercise 19(b) on page 89
implies that ùí©and ‚Ñ≥are elementarily equivalent. Moreover, one can show that ‚Ñ≥is
a proper elementary extension of the standard model ùí©(see Definition 4.3.2).
The standard ordered field of real numbers is the structure ‚ü®‚Ñù; +, √ó, <, 0, 1‚ü©for the
language ‚Ñí= { Ãá+, Ãá√ó, Ãá<, Ãá0, Ãá1, Ãá=}, where Ãá+, Ãá√ó are two 2-place function symbols, Ãá< is a 2-place
relation symbol, Ãá0, Ãá1 are constant symbols, and
Ãá= is the equality symbol. We will now
discuss how to construct a nonstandard ‚Äúreal‚Äù field. Let
‚Ñí‚Ä≤ = { Ãá+, Ãá√ó, Ãá<, Ãá0, Ãá1, Ãá=} ‚à™{cr : r ‚àà‚Ñù},
where cr is a constant symbol for each real number r. Consider the ‚Ñí-structure
‚Ñõ= ‚ü®‚Ñù; +, √ó, <, 0, 1, {c‚Ñõ
r : r ‚àà‚Ñù}‚ü©,
where c‚Ñõ
r = r for each r ‚àà‚Ñù. For each n ‚â•2, let n denote the ‚Ñí‚Ä≤-term
n times
‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû
Ãá1 Ãá+ Ãá1 Ãá+ ‚ãÖ‚ãÖ‚ãÖÃá+ Ãá1. Thus,
n‚Ñõ= n for all n ‚â•2. Now let Œì = Th(‚Ñõ) and let ‚Ñí‚àó= ‚Ñí‚Ä≤ ‚à™{c} be an extension of ‚Ñí‚Ä≤ by the
one new constant symbol c. Let Œ£ be the following infinite set of atomic ‚Ñí‚àó-formulas:
Œ£ = {2 Ãá< c, 3 Ãá< c, 4 Ãá< c, . . . , n Ãá< c, . . . }.
Let Œ† ‚äÜŒì ‚à™Œ£ be finite. Let Œ† = Œ†0 ‚à™Œ†1, where Œ†0 ‚äÜŒì and Œ†1 ‚äÜŒ£. Since ‚ÑõÛ≥ÄÄÛ≥®êŒ†0, we just
need to interpret c so that we can use ‚Ñõto get a model of Œ†1 as well. Since Œ†1 is finite, it
has the form
Œ†1 = {n1 Ãá< c, . . . , ni Ãá< c},
where i ‚àà‚Ñï.
Let n = max{n1, . . . , ni}. Thus, n is the largest natural number so that (n Ãá< c) ‚ààŒ†1. Let
k = n + 1. Thus, the structure
‚Ñõk = ‚ü®‚Ñù; +, √ó, <, 0, 1, {c‚Ñõ
r : r ‚àà‚Ñù}, k‚ü©,
where c‚Ñõk = k,

4.3 Applications
‡±™
139
is a model of Œ†1 and therefore it is a model of Œ†, because ‚Ñõk Û≥ÄÄÛ≥®êŒ†0. By the compactness
theorem (Theorem 4.2.10), Œì ‚à™Œ£ has a model
‚Ñ≥= ‚ü®M; Ãá+‚Ñ≥, Ãá√ó‚Ñ≥, Ãá<‚Ñ≥, Ãá0‚Ñ≥, Ãá1‚Ñ≥, {c‚Ñ≥
r
: r ‚àà‚Ñù}, c‚Ñ≥‚ü©.
Since ‚Ñ≥is a model of Th(‚Ñõ), it follows that ‚Ñ≥is an ordered field that contains the
‚Äúinfinite‚Äù number c‚Ñ≥. Moreover, ‚Ñ≥contains infinitesimals. Since ‚Ñ≥Û≥ÄÄÛ≥®ê( Ãá0 Ãá< n Ãá< c) for
all n ‚â•2, it follows that ‚Ñ≥Û≥ÄÄÛ≥®ê( Ãá0 Ãá< 1
c Ãá< 1
n) for all n ‚â•2, where 1
c and 1
n denote the inverses,
respectively, of c and n in ‚Ñ≥. Hence, the inverse of c‚Ñ≥in ‚Ñ≥is an infinitesimal. Now
let ‚Ñ≥be the restriction of ‚Ñ≥to the original language ‚Ñí, namely,
‚Ñ≥= ‚ü®M; Ãá+‚Ñ≥, Ãá√ó‚Ñ≥, Ãá<‚Ñ≥, Ãá0‚Ñ≥, Ãá1‚Ñ≥‚ü©.
Clearly, ‚Ñ≥is also an ordered field and c‚Ñ≥‚ààM. As every r ‚àà‚Ñùcan be identified with
c‚Ñ≥
r , we can view ‚Ñùas being a subset of M. Moreover, ‚Ñ≥contains infinite numbers
and infinitesimals. It thus follows that ‚Ñõand ‚Ñ≥and are not isomorphic; but ‚Ñõand ‚Ñ≥
are elementarily equivalent. Moreover, one can show that ‚Ñ≥is a proper elementary
extension of the standard model ‚ü®‚Ñù; +, √ó, <, 0, 1‚ü©.
In this section we have shown that there is a structure that contains all the natural
numbers and satisfies all of the first-order sentences that hold in the standard model ùí©,
but this new structure also includes infinite numbers. Thus, we have constructed a new
number system.
We have also shown that there exists a structure that contains all the real numbers
and satisfies all of the first-order sentences that hold in the ordered field of real numbers.
However, this structure contains infinitely large and infinitely small numbers. Again, we
have constructed a new system of numbers.
4.3.2 L√∂wenheim‚ÄìSkolem theorems
Suppose that a set of wffs Œì in a countable language has an uncountable model. Thus, Œì is
satisfiable. Does Œì have a countable model? This question will be addressed by our next
theorem. Leopold L√∂wenheim and Thoralf Skolem were two mathematicians who asked
such questions and, as a result, established theorems on the existence and cardinality
of structures.
Theorem 4.3.3 (L√∂wenheim‚ÄìSkolem). Let Œì be a satisfiable set of wffs in a countable lan-
guage ‚Ñí. Then there is a countable model A that satisfies Œì.
Proof. Let Œì be a satisfiable set of formulas in a countable language ‚Ñí. First, we shall
assume that ‚Ñídoes not contain equality. Recall the proof of the completeness theorem
(Theorem 4.2.8) in this case. In the proof, as ‚Ñíis countable, we considered the extension
‚Ñí‚Ä≤ = ‚Ñí‚à™{c1, c2, c3, . . . }, where the ci‚Äôs are new constant symbols. It thus follows that ‚Ñí‚Ä≤

140
‡±™
4 Soundness and completeness
is countable. Consequently, the set of terms of the language ‚Ñí‚Ä≤ is countable. Now, in the
proof of case 1 of Theorem 4.2.8 we constructed a model A of Œì consisting of the terms
in the language ‚Ñí‚Ä≤. Therefore, A is a countable model satisfying Œì.
Suppose that the language ‚Ñídoes contain equality. Under case 2 in the proof of The-
orem 4.2.8, we constructed a model B of Œì consisting of equivalence classes of the terms
in the language ‚Ñí‚Ä≤. Since the set of these equivalence classes cannot have more elements
than the set of terms in the language ‚Ñí‚Ä≤, it follows that the model B is a countable model
of Œì.
Corollary 4.3.4. Let A be an uncountable structure for a countable language. Then there
is a countable structure B such that A ‚â°B.
Proof. Let Œì = Th(A). Theorem 4.3.3 implies that there exists a countable structure B
that satisfies Œì. Exercise 19 on page 89 implies that A ‚â°B.
The proof of the above theorem adapts to establish our next result, which is referred
to as the downward L√∂wenheim‚ÄìSkolem theorem. The remainder of this section assumes
familiarity with cardinal numbers.
Theorem 4.3.5 (L√∂wenheim‚ÄìSkolem). Let Œì be a satisfiable set of wffs, where ‚Ñíhas cardi-
nality Œ∫. Then there is a model A of cardinality ‚â§Œ∫ that satisfies Œì.
The following theorem is called the upward L√∂wenheim‚ÄìSkolem theorem.
Theorem 4.3.6 (Tarski). Let ‚Ñíbe of cardinality Œª and let Œì be a set of ‚Ñí-wffs. If an infinite
structure satisfies Œì, then for every cardinal Œ∫ ‚â•Œª, there is a structure B of cardinality Œ∫
that satisfies Œì.
Proof. Let ‚Ñíbe of cardinality Œª and let Œì be a set of ‚Ñí-wffs. Assume that Œì is satisfiable
in an infinite structure A with domain A. Let Œ∫ ‚â•Œª and let ‚Ñí‚Ä≤ = ‚Ñí‚à™{ci : i ‚ààŒ∫} be an
extension of ‚Ñíby new constant symbols. It follows that ‚Ñí‚Ä≤ has cardinality Œ∫. Let
Œ£ = {ci
Ã∏Ãá= cj : i, j ‚ààŒ∫ are distinct}.
We now show that Œì ‚à™Œ£ is finitely satisfiable. Let Œ† ‚äÜŒì ‚à™Œ£ be finite. Let Œ† = Œ†0 ‚à™Œ†1,
where Œ†0 ‚äÜŒì and Œ†1 ‚äÜŒ£. Clearly A satisfies Œ†0, and Œ†1 is finite. Let ci1, . . . cin be a finite
list of all the new constant symbols that appear in Œ†1. Since A is infinite, we can assign
the distinct constant symbols in ci1, . . . cin to distinct elements ai1, . . . ain in A. Now extend
A by adding cA
i1 = ai1, . . . cA
in = ain to A and get a structure that satisfies Œ†. Therefore,
Œì ‚à™Œ£ is finitely satisfiable. By Theorem 4.3.5, there is a structure B of cardinality ‚â§Œ∫
that satisfies Œì ‚à™Œ£. Since any model of Œ£ must have cardinality ‚â•Œ∫, we conclude that B
has cardinality Œ∫.
Corollary 4.3.7. Let A be an infinite structure for a countable language ‚Ñí. Then for every
infinite cardinal Œ∫, there is a structure B of cardinality Œ∫ such that A ‚â°B.

4.3 Applications
‡±™
141
Proof. Let Œì = Th(A) and let Œ∫ be an infinite cardinal. As ‚Ñíis countable, it has cardinality
‚â§Œ∫. Thus, by Theorem 4.3.6, there is a structure B of cardinality Œ∫ that satisfies Œì. By
Exercise 19 on page 89, A ‚â°B.
4.3.3 Theories
A theory is a set of sentences in a language which contains all the sentences that are
logically implied by the set.
Definition 4.3.8. Let T be a set of sentences of a language. Then T is said to be a theory
if and only if T is closed under logical implication, that is, for any sentence œÉ of the
language,
if T Û≥ÄÄÛ≥®êœÉ,
then œÉ ‚ààT.
A theory T is said to be complete if for every sentence œÜ, either œÜ ‚ààT or ¬¨œÜ ‚ààT.
Let A be a structure. Recalling Definition 3.2.31, Th(A) is the set of all sentences œÜ
such that A Û≥ÄÄÛ≥®êœÜ. It thus follows that Th(A) is a complete theory. The proof of the next
result is established in Exercise 1.
Theorem 4.3.9. Let T be a theory in a language ‚Ñí. Then T is complete if and only if for all
‚Ñí-structures A and B, if A Û≥ÄÄÛ≥®êT and B Û≥ÄÄÛ≥®êT, then A ‚â°B.
Theorem 4.3.9 provides a method for determining whether or not a theory is com-
plete. We will present another such method that depends on the next definition. As you
may recall, ‚Ñµ0 is the cardinality of any countable infinite set.
Definition 4.3.10. Let T be a theory in a language ‚Ñíand let Œ∫ ‚â•‚Ñµ0 be a cardinal. Then
T is Œ∫-categorical if all models of T having cardinality Œ∫ are isomorphic.
In 1954, Jerzy ≈Åo≈õ and Robert L. Vaught independently proved our next theorem.
Theorem 4.3.11 (≈Åo≈õ‚ÄìVaught test). Let T be a theory in a countable language. If T has no
finite models and is Œ∫-categorical for some cardinal Œ∫ ‚â•‚Ñµ0, then T is complete.
Proof. Let Œ∫ ‚â•‚Ñµ0 be a cardinal and let T be a theory in a countable language. Assume
that T is Œ∫-categorical and has no finite models. We shall apply Theorem 4.3.9. Let A
and B be models of T. Because T has no finite models, A and B must be infinite. Corol-
lary 4.3.7 implies that there are structures A‚Ä≤ and B‚Ä≤ of cardinality Œ∫ such that A‚Ä≤ ‚â°A
and B‚Ä≤ ‚â°B. Since T is Œ∫-categorical, we conclude that A ‚â°A‚Ä≤ ‚âÖB‚Ä≤ ‚â°B. Theorem 3.2.39
now implies that A ‚â°B. Thus, by Theorem 4.3.9, T is complete.
Definition 4.3.12. Let ùí¶be a class of structures of a given language. We define the theory
of ùí¶, denoted as Th(ùí¶), to be the set of sentences defined by

142
‡±™
4 Soundness and completeness
Th(ùí¶) = {œÜ : œÜ is a sentence such that A Û≥ÄÄÛ≥®êœÜ for all A ‚ààùí¶}.
(4.8)
Theorem 4.3.13. Let ùí¶be a class of structures of a given language. Then Th(ùí¶) is a theory.
Moreover, Th(ùí¶) is a complete theory if and only if for all structures A, B ‚ààùí¶, we have
A ‚â°B.
Proof. Let œÉ be a sentence of the language. Assume that Th(ùí¶) Û≥ÄÄÛ≥®êœÉ. We must prove that
œÉ ‚ààTh(ùí¶). In order to prove that œÉ ‚ààTh(ùí¶), we must show that A Û≥ÄÄÛ≥®êœÉ for all A ‚ààùí¶. To
do this, let A ‚ààùí¶. Since A ‚ààùí¶, it follows from (4.8) that A Û≥ÄÄÛ≥®êœÜ for all œÜ ‚ààTh(ùí¶). Because
Th(ùí¶) Û≥ÄÄÛ≥®êœÉ, it now follows that A Û≥ÄÄÛ≥®êœÉ. Thus, Th(ùí¶) is a theory. For the remainder of the
proof, see Exercise 2.
For example, let ‚Ñí= {e, ‚àó, Ãá=} be the language of groups (Example 3.1.2). So, if ùí¢is
the class of all groups, then the theory Th(ùí¢) is the set of all ‚Ñí-sentences that are true in
all groups. Since some groups are Abelian and others are not, it follows that Th(ùí¢) is not
complete.
Let Œ£ be a set of sentences in a language ‚Ñí. Recalling Definition 3.2.25, Mod(Œ£) is
the class of all ‚Ñí-structures A such that A Û≥ÄÄÛ≥®êœÜ for all œÜ ‚ààŒ£. Thus, by Definition 4.3.12,
Th(Mod(Œ£)) is the set of all ‚Ñí-sentences that are true in all models of Œ£, that is, œÜ ‚àà
Th(Mod(Œ£)) if and only if Œ£ Û≥ÄÄÛ≥®êœÜ.
Definition 4.3.14. Let Œ£ be a set of sentences in a language ‚Ñí. The consequences of Œ£,
denoted by Cn(Œ£), are the set
Cn(Œ£) = {œÜ : œÜ is a sentence and Œ£ Û≥ÄÄÛ≥®êœÜ}.
Of course, Cn(Œ£) = Th(Mod(Œ£)) and Cn(Œ£) is a theory. One can confirm that Œ£ is a
theory if and only if Cn(Œ£) = Œ£ (see Exercise 3). For a single sentence œÜ, we write Cn(œÜ)
for Cn({œÜ}).
Definition 4.3.15. A theory T is finitely axiomatizable if T = Cn(Œ£) for some finite set Œ£
of sentences.
We will apply the compactness theorem in the proof of the following result.
Theorem 4.3.16. Let Œ£ be a set of sentences. If Cn(Œ£) is finitely axiomatizable, then there
is a finite set Œ£0 ‚äÜŒ£ such that Cn(Œ£0) = Cn(Œ£).
Proof. Let Œ£ be a set of sentences such that Cn(Œ£) is finitely axiomatizable. So there is a
finite set Œ† = {Œ±1, Œ±2, . . . , Œ±n} of sentences such that (Û≥µ≥) Cn(Œ£) = Cn(Œ†). Let
œÜ = Œ±1 ‚àßŒ±2 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ±n.
It follows that Cn(Œ†) = Cn(œÜ). Thus, by (Û≥µ≥), Cn(œÜ) = Cn(Œ£), and therefore Œ£ Û≥ÄÄÛ≥®êœÜ. The
compactness theorem (Theorem 4.2.10(a)) implies that there is a finite Œ£0 ‚äÜŒ£ such that
Œ£0 Û≥ÄÄÛ≥®êœÜ. Since Œ£0 Û≥ÄÄÛ≥®êœÜ and Œ£0 ‚äÜŒ£, Exercise 7 implies that

4.3 Applications
‡±™
143
Cn(œÜ) ‚äÜCn(Œ£0) ‚äÜCn(Œ£).
Since Cn(œÜ) = Cn(Œ£), we conclude that Cn(Œ£0) = Cn(Œ£).
We now give an example of a finitely axiomatizable theory. Let ‚Ñí= { Ãá<, Ãá=} and let Œ®
be the set consisting of the following axioms for a dense linear order without endpoints:
1.
Asymmetry:
‚àÄx‚àÄy(x Ãá< y ‚Üíy
Ã∏Ãá< x)
2.
Trichotomy:
‚àÄx‚àÄy(x Ãá< y ‚à®x Ãá= y ‚à®y Ãá< x)
3.
Transitivity:
‚àÄx‚àÄy‚àÄz(x Ãá< y ‚Üíy Ãá< z ‚Üíx Ãá< z)
4.
Density:
‚àÄx‚àÄy(x Ãá< y ‚Üí‚àÉz(x Ãá< z Ãá< y))
5.
No endpoints:
‚àÄx‚àÉy‚àÉz(y Ãá< x Ãá< z).
The theory Cn(Œ®) is called the theory of dense linear orders without endpoints. Let ùí¨=
‚ü®‚Ñö; <‚ü©and ‚Ñõ= ‚ü®‚Ñù; <‚ü©, where ‚Ñöis the set of rational numbers, ‚Ñùis the set of real num-
bers, and < is the usual ‚Äúless than‚Äù relation on ‚Ñöand ‚Ñù. Clearly, ùí¨Û≥ÄÄÛ≥®êŒ® and ‚ÑõÛ≥ÄÄÛ≥®êŒ®.
These two structures are not isomorphic because ‚Ñöis countable and ‚Ñùis uncountable
(see [3]); nevertheless, are the structures ùí¨and ‚Ñõelementarily equivalent? The follow-
ing theorem is due to Georg Cantor, and its proof appears below.
Theorem 4.3.17. Let ‚Ñí= { Ãá<, Ãá=} and let Œ® be the set of axioms for a dense linear order
without endpoints. Any two countable models of Œ® are isomorphic.
Before proving Theorem 4.3.17, we need to make several preparatory remarks. First
of all, Exercise 10 shows that any model of Œ® must be infinite. Let A and B be countable
models of Œ® with the respective domains A = {a1, a2, . . . } and B = {b1, b2, . . . }. Let <
denote Ãá<A and let ‚â∫denote Ãá<B. Let n ‚â•1 and
A‚Ä≤ = {a‚Ä≤
1, a‚Ä≤
2, . . . , a‚Ä≤
n} ‚äÜA
and
B‚Ä≤ = {b‚Ä≤
1, b‚Ä≤
2, . . . , b‚Ä≤
n} ‚äÜB
be such that
a‚Ä≤
1 < a‚Ä≤
2 < ‚ãÖ‚ãÖ‚ãÖ< a‚Ä≤
i < a‚Ä≤
i+1 < ‚ãÖ‚ãÖ‚ãÖ< a‚Ä≤
n,
b‚Ä≤
1 ‚â∫b‚Ä≤
2 ‚â∫‚ãÖ‚ãÖ‚ãÖ‚â∫b‚Ä≤
i ‚â∫b‚Ä≤
i+1 ‚â∫‚ãÖ‚ãÖ‚ãÖ‚â∫b‚Ä≤
n.
Let a ‚ààA \ A‚Ä≤ and b ‚ààB \ B‚Ä≤. We will say that b has the same relationship to B‚Ä≤ as a does
to A‚Ä≤ when the following items hold:
(1) if a‚Ä≤
i < a < a‚Ä≤
i+1, then b‚Ä≤
i ‚â∫b ‚â∫b‚Ä≤
i+1, whenever 1 ‚â§i < n;
(2) if a < a‚Ä≤
1, then b ‚â∫b‚Ä≤
1, and if a‚Ä≤
n < a, then b‚Ä≤
n ‚â∫b.
Since A and B are models of Œ®, it follows that for all a ‚ààA \ A‚Ä≤, there is a b ‚ààB \ B‚Ä≤ such
that a and b satisfy (1) and (2). Inversely, we shall say that a has the same relationship to
A‚Ä≤ as b does to B‚Ä≤, when the following items hold:
(3) if b‚Ä≤
i ‚â∫b ‚â∫b‚Ä≤
i+1, then a‚Ä≤
i < a < a‚Ä≤
i+1, whenever 1 ‚â§i < n;
(4) if b ‚â∫b‚Ä≤
1, then a < a‚Ä≤
1, and if b‚Ä≤
n ‚â∫b, then a‚Ä≤
n < a.

144
‡±™
4 Soundness and completeness
It also follows that for all b ‚ààB \ B‚Ä≤, there exists an a ‚ààA \ A‚Ä≤ such that a and b satisfy (3)
and (4). We will say that h‚Ä≤: A‚Ä≤ ‚ÜíB‚Ä≤ is a partial isomorphism if h‚Ä≤ is a bijection such that
x < y
if and only if
h‚Ä≤(x) ‚â∫h‚Ä≤(y), for all x, y ‚ààA‚Ä≤.
Finally, let X = {x1, x2, x3, . . . }. For any nonempty X‚Ä≤ ‚äÜX, we will say that x is the ‚Äúleast‚Äù
element in X‚Ä≤ if x = xn and n is the least natural number such that xn ‚ààX‚Ä≤.
Proof of Theorem 4.3.17. Let A and B be two countable models of Œ® with respective do-
mains A = {a1, a2, . . . } and B = {b1, b2, . . . }. Let < denote Ãá<A and let ‚â∫denote Ãá<B. We will
construct an isomorphism h: A ‚ÜíB by recursion on the natural numbers.
Base step: Let A1 = {a1} and B1 = {b1}. Define h1: A1 ‚ÜíB1 by h1(a1) = b1. The function h1
is vacuously a partial isomorphism.
Inductive step: Let n ‚â•1. Assume that An, Bn, and hn: An ‚ÜíBn have been defined such
that An ‚äÜA and Bn ‚äÜB, where An and Bn have n elements, and hn: An ‚ÜíBn is a partial
isomorphism. If n is odd, then let a be the ‚Äúleast‚Äù element in a ‚ààA\An. Now let b ‚ààB\Bn
be so that b has the same relationship to Bn as a does to An. If n is even, then let b be the
‚Äúleast‚Äù element in b ‚ààB \ Bn. Now let a ‚ààA \ An be so that a has the same relationship to
An as b does to Bn. Let An+1 = An ‚à™{a}, Bn+1 = Bn ‚à™{b}, and define hn+1: An+1 ‚ÜíBn+1 by
hn+1(v) = {hn(v),
if v ‚ààAn,
b,
if v = a.
(4.9)
Clearly, hn+1 is a partial isomorphism.
One can now show that A = ‚ãÉn‚â•1 An, B = ‚ãÉn‚â•1 Bn, and that h = ‚ãÉn‚â•1 hn is an isomor-
phism between A and B.
The method used in the above proof is referred to as Cantor‚Äôs back-and-forth method.
Corollary 4.3.18. The theory Cn(Œ®) is complete and the structures ùí¨= ‚ü®‚Ñö; <‚ü©and ‚Ñõ=
‚ü®‚Ñù; <‚ü©are elementarily equivalent.
Proof. Theorem 4.3.17 implies Cn(Œ®) is ‚Ñµ0-categorical. Theorems 4.3.17 and 4.3.11 imply
that Cn(Œ®) is a complete theory. So by Theorem 4.3.9, ùí¨and ‚Ñõare elementarily equiva-
lent.
Since ùí¨Û≥ÄÄÛ≥®êŒ®, Corollary 4.3.18 and Exercise 5 imply that Th(ùí¨) = Cn(Œ®). Therefore,
Th(ùí¨) is finitely axiomatizable. The same holds for Th(‚Ñõ).
Corollary 4.3.19. Let ‚Ñí= { Ãá<, Ãá=} and ùí¨= ‚ü®‚Ñö; <‚ü©. Then for every ‚Ñí-sentence œÜ, we have
ùí¨Û≥ÄÄÛ≥®êœÜ if and only if Œ® ‚ä¢œÜ.
Proof. Let œÜ be an ‚Ñí-sentence. Since Th(ùí¨) = Cn(Œ®), we conclude that ùí¨Û≥ÄÄÛ≥®êœÜ if and only
if Œ® Û≥ÄÄÛ≥®êœÜ. Corollary 4.2.9 implies that ùí¨Û≥ÄÄÛ≥®êœÜ if and only if Œ® ‚ä¢œÜ.

4.3 Applications
‡±™
145
4.3.4 Prenex normal form
We establish a result that follows (indirectly) from the soundness theorem (Theo-
rem 4.1.5). Given a wff Œ± with quantifiers, is it the case that Œ± is logically equivalent
to a wff œÜ where all of the quantifiers in œÜ appear at the beginning of œÜ? In this section,
we prove that this is the case. First we present a formal definition.
Definition 4.3.20. A prenex formula is a wff that has the form
Q1x1Q2x2 ‚ãÖ‚ãÖ‚ãÖQnxnŒ≤,
where each Qi is ‚àÄor ‚àÉand Œ≤ is quantifier-free.
For example, the formula
‚àÄx‚àÉy‚àÄz(Pxy ‚ÜíQyz)
is a prenex formula.
Corollary 4.1.8 and Propositions 3.3.41‚Äì3.3.45 imply the following theorem, which
concerns quantifier manipulation and logical equivalence. This theorem presents
‚Äúrules‚Äù that can be applied to transform any wff into an equivalent formula that is
in prenex form. In fact, we will use these ‚Äúrules‚Äù to prove that every formula is logically
equivalent to a prenex formula. However, in order to apply these ‚Äúrules,‚Äù one may have
to first apply Theorem 3.3.61 (on alphabetic variants).
Theorem 4.3.21. The following six logical equivalences identify valid operations that in-
volve quantifier manipulation:
1.
¬¨‚àÉxŒ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
‚àÄx¬¨Œ±,
2.
¬¨‚àÄxŒ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
‚àÉx¬¨Œ±,
3.
(Œ± ‚Üí‚àÄxŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
‚àÄx(Œ± ‚ÜíŒ≤) if x is not free in Œ±,
4.
(Œ± ‚Üí‚àÉxŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
‚àÉx(Œ± ‚ÜíŒ≤) if x is not free in Œ±,
5.
(‚àÄxŒ± ‚ÜíŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
‚àÉx(Œ± ‚ÜíŒ≤) if x is not free in Œ≤,
6.
(‚àÉxŒ± ‚ÜíŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
‚àÄx(Œ± ‚ÜíŒ≤) if x is not free in Œ≤.
Theorem 4.3.22. Every wff is logically equivalent to a prenex formula.
Proof. We prove the following statement by induction on wffs: For all wffs œÜ, there exists
a prenex formula œà such that œÜ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œà.
Base step: Let œï = Pt1t2 ‚ãÖ‚ãÖ‚ãÖtn be an atomic formula. Since œï has no quantifiers, œï is
already a prenex formula and it is logically equivalent to itself.
Inductive step: Let Œ± and Œ≤ be arbitrary wffs. Assume the induction hypothesis
Œ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Q1x1Q2x2 ‚ãÖ‚ãÖ‚ãÖQnxnŒ≥,
Œ≤ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
Q‚Ä≤
1y1Q‚Ä≤
2y2 ‚ãÖ‚ãÖ‚ãÖQ‚Ä≤
kykŒ∏,
(IH)

146
‡±™
4 Soundness and completeness
where Œ≥ and Œ∏ are quantifier-free and Qi and Q‚Ä≤
i are quantifiers. We must prove that the
same holds for each of the following:
(¬¨Œ±), (Œ± ‚ÜíŒ≤), ‚àÄvŒ±.
Case (¬¨Œ±): From (IH), by repeatedly applying Theorem 4.3.21(1)(2), we obtain
¬¨Œ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
¬¨Q1x1Q2x2 ‚ãÖ‚ãÖ‚ãÖQnxnŒ≥ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
ÃÇQ1x1ÃÇQ2x2 ‚ãÖ‚ãÖ‚ãÖÃÇQnxn¬¨Œ≥,
where ÃÇ‚àÄ= ‚àÉand ÃÇ‚àÉ= ‚àÄ. Since ¬¨Œ≥ is quantifier-free, we see that ¬¨Œ± is logically equivalent
to a prenex formula.
Case (Œ± ‚ÜíŒ≤): After applying Theorem 3.3.61 (if necessary), we can be assured that the
variables x1, . . . , xn, y1, . . . yk in (IH) are all distinct, that none of the variables x1, . . . , xn
occur free in Œ∏, and that none of the variables y1, . . . , yk occur free in Œ≥. From (IH), by
repeatedly applying Theorem 4.3.21(3)‚Äì(6), we obtain
(Œ± ‚ÜíŒ≤) Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
ÃÇQ1x1ÃÇQ2x2 ‚ãÖ‚ãÖ‚ãÖÃÇQnxnQ‚Ä≤
1y1Q‚Ä≤
2y2 ‚ãÖ‚ãÖ‚ãÖQ‚Ä≤
kyk(Œ≥ ‚ÜíŒ∏).
As (Œ≥ ‚ÜíŒ∏) is quantifier-free, (Œ± ‚ÜíŒ≤) is logically equivalent to a prenex formula.
Case ‚àÄvŒ± : From (IH), we conclude that
‚àÄvŒ± Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
‚àÄvQ1x1Q2x2 ‚ãÖ‚ãÖ‚ãÖQnxnŒ≥,
and this completes the proof.
Exercises 4.3.
*1. Prove Theorem 4.3.9.
*2. Let ùí¶be a class of structures of a given language. Prove that Th(ùí¶) is a complete
theory if and only if for all structures A, B ‚ààùí¶, we have A ‚â°B.
*3. Let Œ£ be a set of sentences in a language ‚Ñí. Prove that Œ£ is a theory if and only if
Cn(Œ£) = Œ£.
4. Let Œ£ be a set of sentences in a language ‚Ñíand let A be an ‚Ñí-structure. Show that
if A Û≥ÄÄÛ≥®êŒ£, then A Û≥ÄÄÛ≥®êCn(Œ£).
*5. Let Œ£ be a set of sentences in a language ‚Ñíand let A be an ‚Ñí-structure. Suppose that
Cn(Œ£) is a complete theory and A Û≥ÄÄÛ≥®êŒ£. Show that Th(A) = Cn(Œ£).
6. Let Œ£ be a set of sentences in a language ‚Ñíand let A be an ‚Ñí-structure such that
Th(A) = Cn(Œ£). Show that A Û≥ÄÄÛ≥®êœÜ if and only if Œ£ ‚ä¢œÜ, for every ‚Ñí-sentence œÜ. Now
show that for any ‚Ñí-sentence œÜ, either Œ£ ‚ä¢œÜ or Œ£ ‚ä¢¬¨œÜ, but not both.
*7. Let Œ£1 and Œ£2 be sets of sentences in a language ‚Ñí.
(a) Suppose that Œ£1 ‚äÜŒ£2. Show that Cn(Œ£1) ‚äÜCn(Œ£2).
(b) Suppose that Œ£1 Û≥ÄÄÛ≥®êŒ± for all Œ± ‚ààŒ£2. Show that Cn(Œ£2) ‚äÜCn(Œ£1).
8. Let Œ£1, Œ£2, Œ£ be sets of ‚Ñí-sentences and let ùí¶1, ùí¶2, ùí¶be classes of ‚Ñí-structures.
(a) Show that if Œ£1 ‚äÜŒ£2, then Mod(Œ£2) ‚äÜMod(Œ£1).

4.3 Applications
‡±™
147
(b) Show that Œ£ ‚äÜTh(Mod(Œ£)).
(c) Show that if ùí¶1 ‚äÜùí¶2, then Th(ùí¶2) ‚äÜTh(ùí¶1).
(d) Show that ùí¶‚äÜMod(Th(ùí¶)).
(e) Using (a), (b), and (d), show that Mod(Œ£) = Mod(Th(Mod(Œ£))).
(f) Using (b), (c), and (d), show that Th(ùí¶) = Th(Mod(Th(ùí¶))).
9. Find prenex formulas that are logically equivalent to the following:
(a) (‚àÉxPx ‚Üí‚àÄxQx),
(b) ¬¨(‚àÉxPx ‚Üí‚àÉxQx),
(c) ‚àÄv(‚àÄxPxv ‚Üí‚àÄxQvx).
*10. Let ‚Ñí= { Ãá<, Ãá=} and let Œ® be the set of ‚Ñí-sentences given on page 143. Show that Œ®
has no finite models.
11. Let A = {a1, a2, . . . } and let ‚ãÉn‚â•1 An be as in the proof of Theorem 4.3.17. From the
proof, we have A1 ‚äÜA2 ‚äÜ‚ãÖ‚ãÖ‚ãÖand ‚ãÉn‚â•1 An ‚äÜA. Prove that A ‚äÜ‚ãÉn‚â•1 An.
12. Let A and B be as in the proof of Theorem 4.3.17. Complete this proof by showing
that A = ‚ãÉn‚â•1 An, B = ‚ãÉn‚â•1 Bn, and that h = ‚ãÉn‚â•1 hn is an isomorphism between A
and B.
13. Let ‚Ñí= { Ãá<}, where Ãá< is a 2-place relation symbol. Consider the ‚Ñí-structure ùí©=
‚ü®‚Ñï; <‚ü©, where < is the usual ordering. Show that there is a model ‚Ñ≥with domain
M that is elementarily equivalent to ùí©such that there is a sequence ‚ü®ai : i ‚àà‚Ñï‚ü©of
elements in M such that ‚Ñ≥Û≥ÄÄÛ≥®ê(ai+1 Ãá< ai), for all i ‚àà‚Ñï.
14. Suppose that the sentence œÜ is true in all infinite models of a theory T. Show that
there is a natural number k ‚â•1 such that œÜ is true in all models of T whose domain
has at least k many elements.
Exercise Notes: For Exercise 11, use proof by contradiction. Let k > 1 be the least such
that ak ‚ààA and ak is not in ‚ãÉn‚â•1 An. Thus, {a1, a2, . . . , ak‚àí1} ‚äÜ‚ãÉn‚â•1 An. It follows that
{a1, a2, . . . , ak‚àí1} ‚äÜAn for some odd n (why?). Derive a contradiction. For Exercise 13, let
‚Ñí‚Ä≤ = ‚Ñí‚à™{c1, c2, c3, . . . }, where the ci‚Äôs are new constant symbols. For each k ‚â•1, let Œªk
be the sentence
ck < ck‚àí1 ‚àßck‚àí1 < ck‚àí2 ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßc1 < c0.
Apply the compactness theorem. For Exercise 14, assume, for a contradiction, that for
all k ‚â•2 there is a model A of T such that A Û≥ÄÄÛ≥®ê¬¨œÉ and A has at least k elements. Review
the proof (and its notation) of Theorem 4.3.1. Show that from this assumption there is a
model of T ‚à™{¬¨œÉ} ‚à™{Œª2, Œª3, . . . }.

5 Computability
What is computability theory?
Computability theory arose from the concept of an algorithm. Computability theory, also
called recursion theory, is now a branch of mathematical logic that originated in the
1930s, before there were computers, with the study of computable functions and Turing
degrees. The field has grown to include the study of generalized computability and defin-
ability. For the computer scientist, computability theory shows that there is a theoretical
limit to what computer programs can actually do.
Let ‚Ñï= {0, 1, 2, 3, 4, . . . } be the set of natural numbers and let f be a function of the
form f : ‚Ñï‚Üí‚Ñï. What does it mean to say that f is computable? One could say that f is
computable if there is an algorithm such that for each n ‚àà‚Ñï, the algorithm with input
n will produce the output f (n). This of course would require one to define the meaning
of an algorithm.
Questions
1.
Consider the function f : ‚Ñï‚Üí‚Ñïdefined by f (n) = n + 123,572. Is f computable?
2.
Consider the function f : ‚Ñï‚Üí‚Ñïdefined by f (n) = 7n. Is f computable?
3.
Consider the function f : ‚Ñï‚Üí‚Ñïdefined by f (n) = r, where r is the remainder
obtained after dividing n by 5. Is f computable?
4.
Suppose that the functions f : ‚Ñï‚Üí‚Ñïand g: ‚Ñï‚Üí‚Ñïare computable. Define the
function h: ‚Ñï‚Üí‚Ñïby h(n) = f (n) + g(n). Is h computable?
5.
Are all functions of the form f : ‚Ñï‚Üí‚Ñïcomputable?
6.
How many computable functions are there?
7.
Suppose that the function f : ‚Ñï‚Üí‚Ñïis computable and suppose that a function
g: ‚Ñï‚Üí‚Ñïsatisfies g(n) < f (n) for all n ‚àà‚Ñï. Is g computable?
Is it possible to give a mathematically precise definition of a computable function? Yes!
Alan Turing was one of the first mathematicians to give such a definition.
5.1 The informal concept
Computability theory is the branch of mathematical logic that studies and identifies
problems that are computationally solvable using different models of computation.
A central question of computer science is to address the limits of computing devices by
understanding the problems that computers can solve. In this section we shall discuss
the basic concepts that appear in the theory of computation.
https://doi.org/10.1515/9783110782073-005

5.1 The informal concept
‡±™
149
5.1.1 Decidable sets
A function f : ‚Ñïk ‚Üí‚Ñïis computable if there is an effective (algorithmic) procedure that
can evaluate f , that is, given any input n1, . . . , nk of k natural numbers, the algorithm
will evaluate f (n1, . . . , nk).
In this section, we will use pseudocode to describe our algorithms and procedures.
As you may know, pseudocode is a compact and informal high-level description of an
algorithm. Programmers use pseudocode to develop their algorithms.
The first computability concept that we discuss is the concept of a decidable set.
A set is decidable if there is an effective procedure which will determine whether or not
any legitimate candidate is a member of the set. An effective procedure is an algorithm
that can be carried out by following the specific steps of an algorithm.
Definition 5.1.1. Given any set S of natural numbers, we will say that S is decidable if
there is an effective procedure such that whenever one applies the procedure to any
natural number n, the procedure will eventually end and respond ‚Äúyes‚Äù if n ‚ààS and
‚Äúno‚Äù if n ‚àâS.
Definition 5.1.1 applies only to subsets of ‚Ñï, the set of natural numbers. This defini-
tion can be generalized to other sets as well.
Example 5.1.2. Let S = {n ‚àà‚Ñï: n is a prime number}. Show that S is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
If n = ‡∞∑or n = ‡∞∏, then let A=No.
If n > ‡∞∏, then perform the following:
Let A=Yes.
For j = ‡∞πto n ‚àí‡∞∏;
If j | n, then let A=No.
End of For Loop
Return A
End of Procedure
The above algorithm is summarized as follows: Given a natural number n, if n ‚â§1,
then return No and halt. If n > 1, then search the numbers 2, 3, 4, . . . , n ‚àí1 for a number
j such that j | n (j evenly divides n). If you find one, then return No and halt. If you do
not find such a number, then return Yes and halt. We note that j | n if and only if n = jk
for some k ‚àà‚Ñï.
In every step of an effective procedure, one must be able to use an algorithm to
decide if a condition is true. Can the truth of the condition ‚Äúj | n‚Äù be checked by an
algorithm? One can effectively decide whether or not j | n holds by carrying out the
algorithm called long division. If the remainder is 0, then j | n. Otherwise, j ‚à§n.

150
‡±™
5 Computability
Example 5.1.3. Let S = {n ‚àà‚Ñï: n = 7q + 3 for some natural number q}. Show that S is
decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform long division by dividing n by ‡∞æ.
If the remainder is 3, then return Yes.
If the remainder is not 3, then return No.
End of Procedure
In other words, given a number n, divide n by 7. If the remainder is 3, then return
Yes and halt. If the remainder is not 3, then return No and halt.
Example 5.1.4. Suppose that S ‚äÜ‚Ñïis decidable. Show that ‚Ñï\ S is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform the procedure for deciding whether or not n ‚ààS.
If n ‚ààS, then return No.
If n ‚àâS, then return Yes.
End of Procedure
That is, given n, using the decision procedure for S, check to see if n belongs to S or
not. If n ‚ààS, then return No and halt. If n ‚àâS, then return Yes and halt.
Example 5.1.5. Let A ‚äÜ‚Ñïand B ‚äÜ‚Ñïbe decidable. Show that A \ B is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform the procedure for deciding whether or not n ‚ààA.
Perform the procedure for deciding whether or not n ‚ààB.
If n ‚ààA and n ‚àâB, then return Yes.
If n ‚àâA or n ‚ààB, then return No.
End of Procedure
Given n, using the decision procedure for A, check to see if n is a member of A or
not. Using the decision procedure for B, check to see if n belongs to B or not. If n ‚ààA and
n ‚àâB, then return Yes and halt. If n ‚àâA or n ‚ààB, then return No and halt.
Example 5.1.6. Let A ‚äÜ‚Ñïbe a finite set. Show that A is decidable.

5.1 The informal concept
‡±™
151
Solution. Let A = {k1, k2, . . . , k‚Ñì} and n ‚àà‚Ñï. The procedure is described as follows:
Begin Procedure
Let R=No.
If n = k‡∞∏, then let R=Yes.
If n = k‡∞π, then let R=Yes.
...
If n = k‚Ñì, then let R=Yes.
Return R.
End of Procedure
That is, given n, check to see if n is in the finite list k1, k2, . . . , k‚Ñìor not. If n is not in
the list, then return No and halt. If n is in the list, then return Yes and halt.
The notion of an effective procedure is somewhat vague and we have not yet given
a precise mathematical definition. We will shortly be giving just such a definition. There
are at least two different but equivalent ways to define an effective procedure: Turing
machines and register machines. There is also a more mathematical way of defining
computable functions which involves the definition of partial recursive functions.
Are all subsets of ‚Ñïdecidable? One can show that there are only countably many
effective procedures. Since ùí´(‚Ñï) (power set of ‚Ñï) is uncountable, it follows that the
majority of sets of natural numbers are not decidable.
5.1.2 Computable functions
Definition 5.1.7. Let k ‚â•1 be a natural number. A k-place total function has the form
f : ‚Ñïk ‚Üí‚Ñïand its domain is the entire set ‚Ñïk. A k-place partial function is a function
whose domain is a subset of ‚Ñïk and whose values are in ‚Ñï. A total function will also be
viewed as a partial function. The empty function is the partial function that is undefined
for every input. When we say that f : ‚Ñïk ‚Üí‚Ñïis a partial function, we mean that the
domain of f is a subset of ‚Ñïk.
Example 5.1.8. Define the 2-place total function f : ‚Ñï2 ‚Üí‚Ñïand the 2-place partial func-
tion g: ‚Ñï2 ‚Üí‚Ñïby
f (m, n) = {m ‚àín,
if m ‚â•n,
0,
if m < n,
g(m, n) = {m ‚àín,
if m ‚â•n,
‚Üë,
if m < n,
where ‚Üëmeans that g(m, n) is undefined. So g(5, 2) is defined and (5, 2) is in the domain
of g; but g(2, 5) is undefined and thus, (2, 5) is not in the domain of g.

152
‡±™
5 Computability
We write ‚Éóx ‚àà‚Ñïk to indicate that ‚Éóx is a k-tuple of the form x1, . . . , xk or ‚ü®x1, . . . , xk‚ü©,
depending on the context.
Definition 5.1.9. Let f be a k-place partial function. The function f is effectively com-
putable if there exists an effective procedure that satisfies the following:
1.
Given a k-tuple ‚Éóx in the domain of f , the procedure eventually halts and returns the
correct value for f ( ‚Éóx).
2.
Given a k-tuple ‚Éóx not in the domain of f , the procedure will not halt and thereby
will not return a value.
For example, the partial function for subtraction
g(m, n) = {m ‚àín,
if m ‚â•n,
‚Üë,
if m < n
is effectively computable because there is a procedure for subtracting natural numbers,
which we learned in elementary school. The procedure can be described as follows:
Begin Procedure
If m ‚â•n
compute r = m ‚àín, return r and halt.
Else
Infinite Loop.
End of Procedure
An infinite loop is a procedure that does not terminate, that is, it runs forever. The
empty function is effectively computable by the following procedure:
Begin Procedure
Infinite Loop.
End of Procedure
The concept of a decidable set can now be described in terms of functions. Let
S ‚äÜ‚Ñïk. We say that S is decidable if its characteristic function (which is total)
CS( ‚Éóx) = {1,
if ‚Éóx ‚ààS,
0,
if ‚Éóx ‚àâS
is effectively computable. Thus, S is decidable if its characteristic function CS is a com-
putable total function.

5.1 The informal concept
‡±™
153
Remark 5.1.10. If S ‚äÜ‚Ñïk is decidable, we can use the computable total function CS to
construct another effectively computable partial function, namely, we can use the fact
that CS( ‚Éóx) = 1 if ‚Éóx is in S and CS( ‚Éóx) = 0 if ‚Éóx is not in S, for any ‚Éóx ‚àà‚Ñïk.
Definition 5.1.11. A set S ‚äÜ‚Ñïk is semi-decidable if its semi-characteristic function
cS( ‚Éóx) = {1,
if ‚Éóx ‚ààS,
‚Üë,
if ‚Éóx ‚àâS
is an effectively computable partial function.
Remark 5.1.12. Thus, a set S is semi-decidable if there is an effective procedure so that
for any input ‚Éóx ‚àà‚Ñïk the procedure will halt and return ‚Äúyes‚Äù if and only if ‚Éóx ‚ààS. Thus,
if ‚Éóx ‚àâS, then the procedure will not halt (that is, cS( ‚Éóx) is undefined).
Any decidable set is also semi-decidable; for example, suppose that S is a decidable
subset of ‚Ñïk. Then the following procedure shows that S is semi-decidable.
Begin Procedure
Run CS( ‚Éóx)
If output = ‡∞∏
return ‡∞∏and halt.
Else
Infinite Loop.
End of Procedure
A universal 2-place partial function
Now, let us just consider those effective procedures that have only one natural num-
ber as input and return at most one natural number as output. Suppose that we have
adopted a fixed method of encoding each of these procedures P by a single natural num-
ber w. Suppose, further, that each such code w can be effectively decoded in such a way
to retrieve the program P (this can be done). Then the following 2-place ‚Äúuniversal func-
tion‚Äù
Œ¶(w, x) = the result of applying the procedure coded by w to the input x
is an effectively computable partial function. It is to be understood that Œ¶(w, x) is unde-
fined (that is, does not halt) when the procedure coded by w fails to halt and return an
output.
Remark 5.1.13. We present an effective procedure that can be used to show that Œ¶ is
effectively computable. The procedure has inputs w and x.

154
‡±™
5 Computability
Begin Procedure
Decode w into a procedure P.
If P is not a valid procedure, then infinite loop.
Execute procedure P with input x; set r = return value.
If r = empty
Infinite Loop.
Else
Return r and halt.
End of Procedure
The function Œ¶ is not total for at least two reasons: Some natural numbers w will
not decode and produce a procedure. If w does decode into a valid procedure, then this
procedure may not yield an output. We shall write Œ¶(w, x)‚Üìto mean that the procedure
in Remark 5.1.13 halts with inputs w and x and returns an output value. Thus, Œ¶(w, x)‚Üì
means that the procedure coded by w with input x halts and returns an output value.
The notation Œ¶(w, x)‚Üëmeans that the procedure fails to halt.
Using the universal function Œ¶ we can enumerate all of the 1-place effectively com-
putable partial functions. First, note that for any 1-place effectively computable partial
function f there is a natural number e that encodes the procedure for f . Thus,
f (x) = Œ¶(e, x)
for all x ‚àà‚Ñï.
For this reason, we shall use the notation ‚ü¶e‚üßto denote the corresponding function f .
Hence, ‚ü¶e‚üß(x) = f (x) = Œ¶(e, x) for all x ‚àà‚Ñï.
Thus, for any natural number e, we will now let ‚ü¶e‚üßbe the partial computable func-
tion defined by ‚ü¶e‚üß(x) = Œ¶(e, x). Of course, some natural numbers e may not code a
procedure and then ‚ü¶e‚üßmay be the empty function. In any case, we can conclude that
every 1-place effectively computable partial function appears in the list
‚ü¶0‚üß, ‚ü¶1‚üß, ‚ü¶2‚üß, ‚ü¶3‚üß, ‚ü¶4‚üß, . . . .
(5.1)
Since an effectively computable function can be computed by more than one procedure,
a computable function may have more than one representation in the list (5.1).
In computability theory, the halting problem can be stated as follows: Given a com-
puter program, decide whether the program will eventually halt when it is executed
with a given input or the program will run forever.
Definition 5.1.14 (Turing). Define the halting relation H on ‚Ñïby
‚ü®w, x‚ü©‚ààH
iff
‚ü¶w‚üß(x)‚Üì,
where ‚ü¶w‚üß(x)‚Üìmeans that the procedure coded by w with input x halts and has an output
value.

5.1 The informal concept
‡±™
155
Of course, ‚ü¶w‚üß(x)‚Üìis equivalent to Œ¶(w, x)‚Üì. Is the relation H decidable? Is there a
procedure that will determine whether or not a program coded by w with input x halts?
Alan Turing proved in 1936 that no such procedure exists.
Theorem 5.1.15 (Turing). The halting relation H is not decidable.
Proof. Suppose, to the contrary, that H is decidable. Thus, the characteristic function CH
defined by
CH(w, x) = {1,
if ‚ü®w, x‚ü©‚ààH,
0,
if ‚ü®w, x‚ü©‚àâH
(5.2)
is effectively computable. Define the partial function f : ‚Ñï‚Üí‚Ñïby
f (n) = {1,
if CH(n, n) = 0,
‚Üë,
if CH(n, n) = 1.
(5.3)
It follows that f is an effectively computable partial function (see Remark 5.1.10). Thus,
there is a procedure P that evaluates f . So, if CH(n, n) = 1, then the procedure P with in-
put n, which attempts to evaluate f (n), will not halt. Since f is an effectively computable
partial function, there is a natural number e such that ‚ü¶e‚üß= f . There are two cases to
consider: Either CH(e, e) = 0 or CH(e, e) = 1.
Case 1. Suppose CH(e, e) = 0. Thus, f (e) = 1 and so ‚ü¶e‚üß(e) = 1. Hence, ‚ü®e, e‚ü©‚ààH because
the procedure coded by e with input e halts. Therefore, (5.2) implies that CH(e, e) = 1,
which is a contradiction.
Case 2. Suppose CH(e, e) = 1. Thus, by (5.3), f (e) is undefined because the procedure that
attempts to evaluate f (e) does not halt. Since ‚ü¶e‚üß= f , we conclude that ‚ü¶e‚üß(e) does not
halt. Hence, CH(e, e) = 0, which is a contradiction.
Turing‚Äôs proof presents an example of a diagonal argument, which was introduced
by Georg Cantor in 1873 to prove that the set of real numbers is uncountable.
Even though the halting relation is not decidable, it is semi-decidable as ‚ü®w, x‚ü©‚ààH
if and only if Œ¶(w, x)‚Üì. Thus, the semi-characteristic function cH satisfies
cH(w, x) = {1,
if ‚ü®w, x‚ü©‚ààH,
‚Üë,
if ‚ü®w, x‚ü©‚àâH
and is an effectively computable partial function. The following psuedocode offers an
effective procedure for evaluating cH(w, x) (see Remark 5.1.12 and Definition 5.1.9):

156
‡±™
5 Computability
Begin Procedure
Execute procedure Œ¶(w, x).
Return ‡∞∏and halt.
End of Procedure
Definition 5.1.16. Define the subset K on ‚Ñïby
K = {x ‚àà‚Ñï: Œ¶(x, x)‚Üì} = {x ‚àà‚Ñï: ‚ü¶x‚üß(x)‚Üì}.
The set K is semi-decidable as the following procedure indicates:
Begin Procedure
Execute procedure Œ¶(x, x).
Return ‡∞∏and halt.
End of Procedure
Theorem 5.1.17 (Kleene). Let S be a subset of ‚Ñïk. Then S is decidable if and only if both S
and its complement S = ‚Ñïk \ S are semi-decidable.
Proof. Let S ‚äÜ‚Ñïk.
(‚áí). Assume that S is decidable. Then, as we have seen before, S is semi-decidable be-
cause the following effective procedure applies:
Begin Procedure
Run CS( ‚Éóx)
If output = ‡∞∏
return ‡∞∏and halt.
Else
Infinite Loop.
End of Procedure
By replacing ‚Äúoutput = 1‚Äù in the above procedure with ‚Äúoutput = 0,‚Äù we obtain an
effective procedure that shows that S is semi-decidable.
(‚áê). Assume that S and S are semi-decidable. Thus, the partial functions cS and cS are
effectively computable. We shall prove that S is decidable, using a ‚Äúsystem timer‚Äù as
follows: Run the cS( ‚Éóx)-procedure for one minute and then freeze it. Now, in another
part of executable memory, run the cS( ‚Éóx)-procedure for one minute and then freeze it.
Now continue the cS( ‚Éóx)-procedure for one minute and then freeze it, and then continue
the cS( ‚Éóx)-procedure for one minute and then freeze it. Keep alternating this ‚Äúsharing of

5.1 The informal concept
‡±™
157
system time‚Äù until one of the procedures halts and yields an output of 1. If cS( ‚Éóx) = 1, then
return 1. If cS( ‚Éóx) = 1, then return 0.
Theorem 5.1.18. Let k be a natural number.
1.
A k-place relation is semi-decidable if and only if the relation is the domain of some
effectively computable partial function.
2.
A partial function f is effectively computable if and only if {‚ü®‚Éóx, y‚ü©: f ( ‚Éóx) = y} is a
semi-decidable relation.
Proof. Let S ‚äÜ‚Ñïk.
1.
We prove that a k-place relation is semi-decidable if and only if the relation is the
domain of some effectively computable partial function.
(‚áí). Suppose that S ‚äÜ‚Ñïk is semi-decidable. Thus, by definition, the function cS is
an effectively computable function. Since
cS( ‚Éóx) = {1,
if ‚Éóx ‚ààS,
‚Üë,
if ‚Éóx ‚àâS,
we see that S is the domain of some effectively computable partial function.
(‚áê). Suppose that S ‚äÜ‚Ñïk is the domain of some effectively computable partial
function, say f . We note that the following procedure evaluates cS:
Begin Procedure
Run f( ‚Éóx).
Return ‡∞∏and halt.
End of Procedure
Since the procedure f ( ‚Éóx) halts if and only if ‚Éóx ‚ààS, we conclude that cS is an effec-
tively computable function.
2.
We shall prove that a partial function f is effectively computable if and only if the
set G = {‚ü®‚Éóx, y‚ü©: f ( ‚Éóx) = y} is a semi-decidable relation.
(‚áí). Let f be effectively computable. Consider the following procedure with inputs
‚Éóx and y:
Begin Procedure
Run f( ‚Éóx).
If output = y
Return ‡∞∏and halt.
Else
Infinite Loop
End of Procedure

158
‡±™
5 Computability
Thus, the above effective procedure evaluates cG. Therefore, G is semi-decidable.
(‚áê). Let G = {‚ü®‚Éóx, y‚ü©: f ( ‚Éóx) = y} be a semi-decidable relation and let cG be the semi-
characteristic function of G, which is a computable partial function. Given ‚Éóx, execute
the following procedure:
Begin Procedure
Let n = ‡∞∑.
(L)
For j = ‡∞∑to n;
Run cG( ‚Éóx, j) for n + ‡∞∏minutes.
If cG( ‚Éóx, j) has halted and cG( ‚Éóx, j) = ‡∞∏, then return j and go to (E).
End for Loop
Let n = n + ‡∞∏and go to (L).
(E)
Halt (End of Procedure)
If f ( ‚Éóx)‚Üì, then this procedure will eventually halt and return the value f ( ‚Éóx). If f ( ‚Éóx)‚Üë,
then this procedure will not halt. Therefore, f is effectively computable.
Let us explain what the above procedure does. We know that G is semi-decidable.
Thus, there is a procedure P such that when given an input ‚ü®‚Éóx, y‚ü©, the procedure
will halt and return ‚Äúyes‚Äù if and only if ‚ü®‚Éóx, y‚ü©‚ààG. We now try to compute f ( ‚Éóx), if
it is defined. The plan is to use the procedure P to check ‚ü®‚Éóx, 0‚ü©, ‚ü®‚Éóx, 1‚ü©, ‚ü®‚Éóx, 2‚ü©, . . . for
membership in G. To do this, we must budget our time by using a method called
‚Äúdovetailing.‚Äù We execute the following steps:
(1) Spend 1 minute testing whether ‚ü®‚Éóx, 0‚ü©is in G.
(2) Spend 2 minutes each on ‚ü®‚Éóx, 0‚ü©and ‚ü®‚Éóx, 1‚ü©testing for membership in G.
(3) Spend 3 minutes each on ‚ü®‚Éóx, 0‚ü©, ‚ü®‚Éóx, 1‚ü©, ‚ü®‚Éóx, 2‚ü©testing for membership in G.
...
...
If at a step we find an ‚ü®‚Éóx, k‚ü©‚ààG, then we return the value k and halt. If f ( ‚Éóx)‚Üì, then
this process will eventually halt and return the correct value for f ( ‚Éóx). On the other
hand, if f ( ‚Éóx)‚Üë, then this process will not halt, that is, the process will run forever.
Therefore, the partial function f is effectively computable.
Exercises 5.1.
1. Let A ‚äÜ‚Ñïand B ‚äÜ‚Ñïbe decidable. Show that A ‚à©B is decidable, that is, let n ‚àà‚Ñï
and identify an effective procedure that decides whether or not n ‚ààA ‚à©B.
2. Let A and B be decidable subsets of ‚Ñï. Show that A ‚à™B is decidable.
3. Let A and B be semi-decidable subsets of ‚Ñï. Show that A ‚à©B is semi-decidable.
4. Let A and B be semi-decidable subsets of ‚Ñï. Show that A ‚à™B is semi-decidable.
5. Let R ‚äÜ‚Ñï2 be a decidable relation. Show that the set {x : ‚ü®x, i‚ü©‚àà‚Ñù}, domain of R,
is semi-decidable. (Review the proof of Theorem 5.1.18(2).)
6. Suppose that f : ‚Ñï‚Üí‚Ñïis a computable partial function. Show that the domain of
f , {x ‚àà‚Ñï: f (x)‚Üì}, is semi-decidable.

5.2 Formalizations‚Äîan overview
‡±™
159
7. Let f : ‚Ñï‚Üí‚Ñïbe a total computable function. Show that the range {f (x) : x ‚àà‚Ñï} is
semi-decidable.
5.2 Formalizations‚Äîan overview
In the preceding section, we used the term ‚Äúeffectively computable‚Äù to refer to an in-
tuitive notion of an effective (algorithmic) procedure. In this section we present an
overview of three different (but equivalent) methods that allow one to replace the no-
tion of effectively computable with one that is mathematically precise. One of these
methods will be developed in more detail in Sections 5.3 and 5.4. It is important to
emphasize that these three approaches are equivalent (see Theorems 5.2.20 and 5.2.11).
5.2.1 Turing machines
A Turing machine is a device that manipulates symbols on a tape according to a set of
instructions. Despite its simplicity, a Turing machine can be adapted to simulate the logic
of any computer algorithm. The Turing machine is not intended as a practical method for
implementing algorithms, but rather as a hypothetical device representing a computing
machine. Turing machines help computer scientists understand the limits of mechanical
computation.
A Turing machine has a potentially infinite tape, marked into squares and a tape
head which has an arrow pointing at the square on the tape that is currently being ad-
dressed. Each square can hold a symbol or a blank space. The symbols must be taken
from a given alphabet Œ£. Initially, the tape contains only the input string (word) and is
blank everywhere else (see Figure 5.1).
Figure 5.1: A tape with an input string from the alphabet Œ£ = {a, t, 3}.
A Turing machine instruction commands the machine to perform the simple steps
indicated below:
(a) read the tape square under the tape head,
(b) write a symbol on the tape in that square,
(c) move the tape head to the left or right, and
(d) proceed to a new instruction.
Steps (b) through (d) all depend upon what symbol appears on the tape square being
scanned before the instruction is executed. The machine can be in any one of finitely

160
‡±™
5 Computability
many ‚Äústates‚Äù q1, q2, . . . , qr. A machine instruction has the form ‚ü®state, read, write, move,
next-state‚ü©. A program for a Turing machine consists of a finite set of Turing machine
instructions.
Words and alphabets
Consider the set consisting of the English alphabet {a, b, c, d, . . . , x, y, z}. A finite string
or word over this alphabet is a string of letters; for example, aaactu and zadw are two
strings (words) of letters over the English alphabet.
We will now consider more general alphabets. Let Œ£ be a finite set of symbols. Then
Œ£‚àóis the set of all words over the alphabet Œ£ (including the empty word Œª). For example,
let Œ£ = {1, b, c}. Then
Œ£‚àó= {Œª, 1, a, b, 1a, a1, bbb, abcabc, . . . }.
We shall denote the ‚Äúempty‚Äù word with the symbol Œª, and this symbol is not allowed to
occur in any alphabet.
Turing machine instructions
An instruction has the form ‚ü®qi, Sj, Sk, D, qm‚ü©, where qi is the current state, Sj and Sk are
symbols in Œ£ (the given alphabet), D is either R or L (right or left), and qm is the next
state. If the machine is in state qi, then the instruction ‚ü®qi, Sj, Sk, D, qm‚ü©tells the machine
to look at the square currently under the tape head (the arrow) and do the following (in
order):
1.
If the square contains symbol Sj, then replace it with the symbol Sk.
2.
If D = R, then move the tape head to the next square on the right; if D = L, then
move the tape head to the next square on the left.
3.
Go into state qm.
4.
Let S be the current symbol in the square under the tape head.
5.
Now execute the instruction that has state qm and symbol S as its first two compo-
nents. If there is no such instruction, then halt!
We will not allow the symbol B to be used in any alphabet. The capital letter B will
be used to represent a ‚Äúblank‚Äù symbol (that is, an empty square). Thus, an instruction
‚ü®qi, Sj, B, D, qm‚ü©means to ‚Äúerase‚Äù symbol Sj and the instruction ‚ü®qi, B, Sk, D, qm‚ü©means
that if the square is blank, then write the given symbol Sk into this square. A Turing
machine cannot have two different instructions that have the same first two components.
Suppose that we are working in the two-letter alphabet Œ£ = {a, b} and we want to
write a Turing machine that takes a word in this alphabet as input and will append the
letter a to each such word (on the right). For example, if the tape has the initial input
abb, then after running the machine the tape should have the output abba. Figure 5.2
illustrates another example. Such a Turing machine is given in Example 5.2.1 below.

5.2 Formalizations‚Äîan overview
‡±™
161
Figure 5.2: The Turing input and output.
Example 5.2.1. Let Œ£ = {a, b} be a two-letter alphabet. We will present a Turing ma-
chine M which consists of six instructions with just three states q1, q2, q3, where q1 is
designated as being the initial state. The state q3 will be the halt state, that is, the ma-
chine will stop operating. When we start this machine in state q1 it will scan the first
letter and then will eventually append the letter a to the word on the right. We show in
Figure 5.3 how this machine executes the program on the input word ab. The box above
the tape head identifies the ‚Äúcurrent‚Äù state of the machine. We have
‚ü®q1, a, a, R, q1‚ü©
‚ü®q1, b, b, R, q1‚ü©
‚ü®q1, B, a, L, q2‚ü©
‚ü®q2, a, a, L, q2‚ü©
‚ü®q2, b, b, L, q2‚ü©
‚ü®q2, B, B, R, q3‚ü©.
(M)
Example 5.2.2. Let Œ£ = {a, b} be a two-letter alphabet. Let f : Œ£‚àó‚ÜíŒ£‚àóbe the 1-place
function defined by f (w) = wa, where w ‚ààŒ£‚àóis any word in the alphabet Œ£. The machine
M in Example 5.2.1 computes the total function f . So we can say that the function f is
Turing computable. Note that f (Œª) = a, where Œª is the empty word.
Now suppose that Œ£ is a finite alphabet (the blank B does not count as a member
of Œ£). Let Œ£‚àóbe the set of all words over this alphabet (that is, Œ£‚àóis the set of all finite
strings, including the empty string, consisting of members of Œ£).
Definition 5.2.3. Suppose that f is a k-place partial function from (Œ£‚àó)k into Œ£‚àó. We will
say that f is Turing computable if there exists a Turing machine M that, when started
in its initial state scanning the first symbol of a k-tuple
‚Éów of words (written on the tape,
with a blank square between words, and with the rest of the tape blank), behaves as
follows:
1.
If f ( ‚Éów)‚Üì(i. e., ‚Éów is in the domain of f ), then M eventually halts and returns the value
f ( ‚Éów), which is the word on the tape whose first letter is under the tape head and
whose last letter is followed by a blank square.
2.
If f ( ‚Éów)‚Üë(i. e.,
‚Éów is not in the domain of f ), then M never halts.

162
‡±™
5 Computability
Figure 5.3: The machine runs with input ab and halts with output aba.
Turing developed these ideas prior to the introduction of modern digital computers.
After World War II, Turing played an active role in the development of early comput-
ers and in the emerging field of artificial intelligence. During the war, he also worked
on deciphering the German battlefield code Enigma, which was militarily important
work that remained classified until after Turing‚Äôs death. Turing‚Äôs remarkable contribu-
tions to the war effort have been celebrated in recent years. However, before his death,
Turing was persecuted by the English judicial system on account of his sexual orienta-
tion.
Turing computability of functions on ‚Ñïk
The definition of Turing computability can be adapted to k-place functions on ‚Ñï. One
way to do this is to use the single-letter alphabet Œ£ = {1} and represent the natural num-
bers 0, 1, 2, 3, 4, . . . as follows: 1, 11, 111, 1111, 11111, . . . . Thus, the 3-tuple ‚ü®3, 0, 5‚ü©would be
represented on a Turing tape as

5.2 Formalizations‚Äîan overview
‡±™
163
1 1 1 1
1
1 1 1 1 1 1 .
It turns out that every computable function (like the ones in Section 5.1.2) on the nat-
ural numbers is Turing computable. For example, the function f (m, n) = mn is Turing
computable. Thus, there is a Turing machine such that when given the input ‚ü®m, n‚ü©, the
machine will halt with the output mn. For example, if this machine were given the input
‚ü®3, 4‚ü©represented on the tape as
1 1 1 1
1 1 1 1 1 ,
then the machine would halt with the output
1 1 1 1 1 1 1 1 1 1 1 1 1 ,
which represents 12.
5.2.2 Register machines
In theoretical computer science a register machine is an abstract machine that is used in
a manner similar to that of a Turing machine. Furthermore, every Turing computable
function on the natural numbers can be computed by a register machine and vice
versa.
A register machine is a conceptual computing device with a finite number of regis-
ters, numbered 0, 1, 2, . . . , K. Each register is capable of storing a natural number of any
magnitude‚Äîthere is no limit to the size of this number. The operation of the machine
is determined by a program. A program is a finite sequence of instructions, drawn from
the following list:
‚Äì
I r (where 0 ‚â§r ‚â§K). ‚ÄúIncrement r.‚Äù This instruction results in an increase of the
contents of register r by 1. The machine then proceeds to the next instruction in the
program (if any).
‚Äì
D r (where 0 ‚â§r ‚â§K). ‚ÄúDecrement r.‚Äù The effect of this instruction depends on
the number in register r. If that number is nonzero, it is decreased by 1 and the
machine proceeds not to the next instruction, but to the following one. However, if
the number in register r is zero, then the machine proceeds to the next instruction.
In other words, the machine attempts to decrement register r and if it is successful,
then it skips one instruction.
‚Äì
J q (where q is an integer‚Äîpositive, negative, or zero). ‚ÄúJump q.‚Äù All registers remain
unchanged. The machine takes as its next instruction the q-th instruction following
this one (if q ‚â•0) or the |q|-th instruction preceding this one (if q < 0). The machine
halts if there is no such instruction in the program. Thus, the instruction J 0 results
in an infinite loop, by repeating this one instruction over and over again.

164
‡±™
5 Computability
This programming language has only these three types of instructions. (Strictly speak-
ing, in these instructions, r and q are numerals, not numbers, that is, an instruction
should be a sequence of symbols. If we use base-10 numerals, then the alphabet is
I, D, J, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ‚àí. An instruction is a correctly formed word over this alpha-
bet.) A register program will halt when the machine cannot find the ‚Äúnext‚Äù instruction.
Example 5.2.4 (CLEAR 7). Consider the following program, called ‚ÄúCLEAR 7,‚Äù which will
replace the contents of register 7 with the number 0. The comments (on the right) are
added to explain the individual steps in the program.
D
7
Try to decrement register 7.
J
2
Halt when zero.
J
‚àí‡∞π
Go back and repeat.
The program has three instructions and halts by seeking a fourth instruction. In
addition, we can replace 7 with any register number and obtain a program that will
clear that particular register, for example, the following program CLEAR 3 will clear
register 3.
D
3
J
2
J
‚àí‡∞π
Example 5.2.5 (MOVE r to s). Let r and s be different register numbers. Consider the fol-
lowing program, called ‚ÄúMOVE r to s,‚Äù which will move the number in register r into
register s. This program ‚Äúcalls‚Äù on the CLEAR program.
CLEAR
s
Ensure that register s is set to zero.
D
r
Decrement register r.
J
3
Halt when zero.
I
s
Increment register s.
J
‚àí‡∞∫
Go back and repeat.
The above program leaves a zero in register r and contains seven instructions. The
program halts by seeking an eighth instruction.
Example 5.2.6 (ADD 1 to 2 and 3). Consider the following program, called ‚ÄúADD 1 to 2
and 3,‚Äù which will add the number in register 1 to the numbers in register 2 and regis-
ter 3.

5.2 Formalizations‚Äîan overview
‡±™
165
D
1
Decrement register 1.
J
4
Halt when zero.
I
2
Increment register 2.
I
3
Increment register 3.
J
‚àí‡∞ª
Go back and repeat.
This program leaves a zero in register 1. Moreover, the program has five instructions
and halts by seeking a sixth instruction. It is clear how to adapt this program to add any
register to one or more registers.
Example 5.2.7 (COPY from r to s (using t)). Consider the following program, called ‚ÄúCOPY
from r to s (using t),‚Äù which copies the number in register r to register s (leaving register
r unchanged). The program ‚Äúcalls‚Äù on the programs CLEAR, MOVE, and ADD.
CLEAR
s
Set register s to zero.
MOVE
r to t
ADD
t to r and s
When this program terminates, register r contains the same value as it did when
the program began. The program contains 15 instructions and halts by seeking a 16th
instruction.
Example 5.2.8. Let R0, R1, R2, R3 denote registers 0, 1, 2, and 3. Suppose that x and y
are in registers 1 and 2. The following program will put the sum x + y in register 0. The
comments on the right depict the register contents at each step of the program.
R‡∞∑
R‡∞∏
R‡∞π
R‡∞∫
CLEAR
0
‡∞∑
x
y
MOVE
1 to 3
‡∞∑
0
y
x
ADD
3 to 1 and 0
x
x
y
0
MOVE
2 to 3
x
x
0
y
ADD
3 to 2 and 0
x + y
x
y
0
At the end of this program, registers 1 and 2 contain the same value as they did
when the program began. The program has 27 instructions and halts by seeking a 28th
instruction.
Definition 5.2.9. Suppose that f : ‚Ñïn
‚Üí
‚Ñïis an n-place partial function. Then f
is register-machine computable if there exists a register program P that, whenever
‚Éóx = ‚ü®x1, x2, . . . , xn‚ü©and x1 is in register 1, x2 is in register 2, . . . , xn is in register n, and 0
is in the other registers, behaves as follows:

166
‡±™
5 Computability
1.
If f ( ‚Éóx)‚Üì(i. e., ‚Éóx is in the domain of f ), then P eventually halts and returns the value
f ( ‚Éóx) in register 0. Furthermore, the program halts by seeking a (p + 1)st instruction
when the program P contains p instructions.
2.
If f ( ‚Éóx)‚Üë(i. e., ‚Éóx is not in the domain of f ), then P never halts.
Example 5.2.10. Let f : ‚Ñï2 ‚Üí‚Ñïbe defined by f (x, y) = x + y. Example 5.2.8 shows that f
is register-machine computable.
Theorem 5.2.11. Let f : ‚Ñï2 ‚Üí‚Ñïbe a partial function. Then f is Turing computable if and
only if f is register-machine computable.
5.2.3 Primitive recursiveness and partial search
For a third formalization of the computability concept, we will define a certain class of
partial functions on ‚Ñïto be the smallest class that contains a few simple functions and is
also closed under certain constructions that generate more complicated functions. This
particular formalization requires no particular type of computing device.
For the initial functions, we take the following very simple total functions:
‚Äì
For each k ‚â•0, the zero function Ãäf : ‚Ñïk ‚Üí‚Ñïdefined by the equation
Ãäf (x1, . . . , xk) = 0
is an initial function. The constant 0 is viewed as a 0-place initial function.
‚Äì
The successor function S: ‚Ñï‚Üí‚Ñïdefined by the equation
S(x) = x + 1
is an initial function.
‚Äì
For all natural numbers 1 ‚â§i ‚â§k, the projection function Ik
i : ‚Ñïk ‚Üí‚Ñïdefined by
the equation
Ik
i (x1, . . . , xk) = xi
is an initial function. The function Ik
i just selects the i-th component as its value.
We next identify two ways to generate new functions from the initial functions and those
that have already been constructed. Recall that when f : ‚Ñï‚Üí‚Ñïand g: ‚Ñï‚Üí‚Ñï, we can
construct the composite function (f ‚àòg): ‚Ñï‚Üí‚Ñïdefined by
(f ‚àòg)(n) = f (g(n))
for all n ‚àà‚Ñï. We will generalize this operation in our next definition.

5.2 Formalizations‚Äîan overview
‡±™
167
Definition 5.2.12. Let n ‚â•1 and k ‚â•1. Suppose that f : ‚Ñïn ‚Üí‚Ñïand gi: ‚Ñïk ‚Üí‚Ñïfor each
i = 1, 2, . . . , n. Then we can define the function h: ‚Ñïk ‚Üí‚Ñïby composition as follows:
h( ‚Éóx) = f (g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx)).
In Definition 5.2.12, if f and g1, g2, . . . , gn are partial functions, then h( ‚Éóx) is defined if
and only if g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx) and f (g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx)) are all defined.
Example 5.2.13. Let n = 3, let k = 2, let f : ‚Ñï3 ‚Üí‚Ñïbe defined by f (a, b, c) = ab + c, and
let g1(x, y) = 2x, g2(x, y) = 2y, and g3(x, y) = x + y. Then
h(x, y) = f (g1(x, y), g2(x, y), g3(x, y)) = f (2x, 2y, x + y)
= (2x)(2y) + (x + y) = 4xy + x + y.
Another method that we will use to generate functions is called primitive recursion.
Recall (Section 1.1.4) that if we have a function g: ‚Ñï‚Üí‚Ñïand an element a ‚àà‚Ñï, then
we can define a function h: ‚Ñï‚Üí‚Ñïby the following recursion:
1.
h(0) = a,
2.
h(n + 1) = g(h(n)), for all n ‚àà‚Ñï.
We will now generalize this definition.
Definition 5.2.14. Let k ‚â•1 and suppose that f : ‚Ñïk ‚Üí‚Ñïand g: ‚Ñïk+2 ‚Üí‚Ñï. Then we
can define a function h: ‚Ñïk+1 ‚Üí‚Ñïby the following primitive recursion:
(1) h( ‚Éóx, 0) = f ( ‚Éóx),
(2) h( ‚Éóx, n + 1) = g(h( ‚Éóx, n), ‚Éóx, n), for all n ‚àà‚Ñï.
In Definition 5.2.14, if f and g are partial functions, then h( ‚Éóx, n + 1) is defined if
and only if h( ‚Éóx, n) and g(h( ‚Éóx, n), ‚Éóx, n) are both defined. Furthermore, the function h is
uniquely defined by the above conditions (1) and (2). In fact, Theorem 1.1.27 implies that
the function h exists and is unique.
Example 5.2.15. Let k = 2. Let f : ‚Ñï2 ‚Üí‚Ñïbe defined by f (a, b) = (a+1)b and g: ‚Ñï4 ‚Üí‚Ñï
be defined by g(w, x, y, z) = wx + yz. Then we can define a function h: ‚Ñï3 ‚Üí‚Ñïby the
following primitive recursion:
(1) h(x, y, 0) = f (x, y) = (x + 1)y,
(2) h(x, y, n + 1) = g(h(x, y, n), x, y, n), for all n ‚àà‚Ñï.
Since we have the value h(x, y, 0), we can evaluate h(x, y, 1) as follows:
h(x, y, 1) = g(h(x, y, 0), x, y, 0) = g((x + 1)y, x, y, 0) = (x + 1)yx + y ‚ãÖ0 = (x2 + x)y.
Now that we have the value h(x, y, 1), we can evaluate h(x, y, 2) as follows:

168
‡±™
5 Computability
h(x, y, 2) = g(h(x, y, 1), x, y, 1) = g((x2 + x)y, x, y, 1) = (x3 + x2)y + y ‚ãÖ1 = (x3 + x2 + 1)y.
Continuing in this manner we can evaluate h(x, y, n) for any natural number n.
Now that we have the initial functions and two methods of producing functions, we
can define the smallest set that contains the initial functions and all the functions that
can be generated from the initial functions using composition and primitive recursion.
Definition 5.2.16. A function f : ‚Ñïk ‚Üí‚Ñïis said to be primitive recursive if f can be con-
structed starting with the zero, successor, and projection functions using composition
and primitive recursion.
Thus, if the functions f : ‚Ñïn ‚Üí‚Ñïand gi: ‚Ñïk ‚Üí‚Ñïfor each i = 1, 2, . . . , n are primitive
recursive, then function h: ‚Ñïk ‚Üí‚Ñïdefined by the composition
h( ‚Éóx) = f (g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx))
is also primitive recursive. Furthermore, if f : ‚Ñïk ‚Üí‚Ñïand g: ‚Ñïk+2 ‚Üí‚Ñïare primitive
recursive, the function h: ‚Ñïk+1 ‚Üí‚Ñïthat satisfies
(1) h( ‚Éóx, 0) = f ( ‚Éóx),
(2) h( ‚Éóx, n + 1) = g(h( ‚Éóx, n), ‚Éóx, n), for all n ‚àà‚Ñï,
is also primitive recursive.
Again, the collection of all primitive recursive functions is the smallest set that
contains the initial functions and is closed under composition and primitive recursion.
Thus, the collection of primitive recursive functions is the smallest set ùíûthat contains
the zero, successor, and projection functions and whenever a function f is constructed
from functions in ùíûusing composition or primitive recursion, f is also in ùíû.
Example 5.2.17. Show that the function h: ‚Ñï3 ‚Üí‚Ñïthat satisfies
(1) h(x, y, 0) = y,
(2) h(x, y, n + 1) = h(x, y, n) + 2, for all n ‚àà‚Ñï,
is primitive recursive.
Solution. According to Definition 5.2.14, we need to find primitive recursive functions
f and g that satisfy:
(a) h(x, y, 0) = f (x, y), where f is a 2-place function,
(b) h(x, y, n + 1) = g(h(x, y, n), x, y, n), for all n ‚àà‚Ñï, where g is a 4-place function.
The function h has two parts of its definition, namely (1) and (2). We will find the func-
tions f and g by using the following tree to show how h is built up from certain primitive
recursive functions. The left branch below focuses on part (1) of the definition of h and
the right branch addresses part (2) of this definition.

5.2 Formalizations‚Äîan overview
‡±™
169
h
h(x, y, 0) = y
= I2
2(x, y)
= f (x, y)
w = h(x, y, n)
h(x, y, n + 1) = w + 2
= (w + 1) + 1
= S(w) + 1
= S(S(w))
= S(S(I4
1 (w, x, y, n)))
= g(w, x, y, n)
The function f defined by f (x, y) = I2
2(x, y) is an initial function, so f is primitive recur-
sive. The function g defined by g(w, x, y, n) = S(S(I4
1 (w, x, y, n))) is primitive recursive
because g is the result of composing initial functions. Thus, h is a primitive recursive
function.
We note that every primitive recursive function is a total function. This is because
the initial functions are all total, the composition of total functions is total, and a function
obtained by primitive recursion from total functions is also total.
We will show in Section 5.3 that many of the common functions on ‚Ñïare primitive
recursive. For example, we shall show that the operations of addition and multiplication
on the natural numbers are primitive recursive.
It seems clear that every primitive recursive function should be regarded as be-
ing effectively computable. The initial functions are computable and the composition of
computable functions produces a computable function. Whenever h is obtained by prim-
itive recursion from computable functions f and g, then it is easy to see how one can ef-
fectively find h( ‚Éóx, 99), by first finding h( ‚Éóx, 0) and then working one‚Äôs way up as in Exam-
ple 5.2.15. Therefore, h is computable. However, in order to generate all of the effectively
computable functions on the natural numbers, we need to have one more operation.
Before we formally identify this new operation, we begin with a motivating discussion.
Let us take a function g(x, y). Let x ‚àà‚Ñïand suppose there is at least one value of y
which makes g(x, y) = 0 and we want to find the least value of y for which g(x, y) = 0.
There is an effective method for doing this. We know that y is a natural number. We
first set y = 0 and then compute g(x, y); if we get 0 we stop, because we have found
the least y such that g(x, y) = 0; but if not, we try the next natural number 1. We try
y = 0, 1, 2, 3 . . . until we reach the first value such that g(x, y) = 0. Then we define h(x) =
y and thereby get a new function. When we know that there is such a value, then this
method will terminate in a finite amount of time with the correct answer. Moreover, if
h(x) is a function that computes the least y such that g(x, y) = 0, then h is computable.
We will say that h is produced from g by minimization.
However, we do not always know that there is a y where g(x, y) = 0. Hence the
project of testing y = 0, 1, 2, 3, . . . may never terminate. If we run the test anyway, which

170
‡±™
5 Computability
is called unbounded minimization, we will get h to be a partial function. For this reason,
we will refer to unbounded minimization as partial search because such searches may
not be successful and thus can produce a partial function.
Since we will be working with partial functions, we will use the notation h( ‚Éóx)‚Üìto
indicate that the function h is defined at ‚Éóx, and we will write h( ‚Éóx)‚Üëwhen h is undefined
at ‚Éóx. Moreover, when we say that h: ‚Ñïk ‚Üí‚Ñïis a partial function, we mean that the
domain of h may be a proper subset of ‚Ñïk. We now introduce the Œº-operator, which
searches for the least natural number that yields a functional value of 0.
Definition 5.2.18. Let g be a (k+1)-place function on ‚Ñï. We say that the k-place function
h is obtained (constructed) from g by partial search if h satisfies
h( ‚Éóx) = Œºy(g( ‚Éóx, y) = 0),
that is, for each ‚Éóx ‚àà‚Ñïk, we have h( ‚Éóx)‚Üìand h( ‚Éóx) = y if and only if y satisfies the following
two conditions:
1.
g( ‚Éóx, y)‚Üìand g( ‚Éóx, y) = 0,
2.
g( ‚Éóx, s)‚Üìand g( ‚Éóx, s) > 0 for all s < y.
When the function g in Definition 5.2.18 is effectively computable, then so is h be-
cause we can evaluate h( ‚Éóx) by investigating the values g( ‚Éóx, 0), g( ‚Éóx, 1), . . . , g( ‚Éóx, i) (in this
order) until we find the first solution y to the equation g( ‚Éóx, y) = 0. If there is no such y,
then the search will never end.
Using the initial functions and the operations of composition, primitive recursion,
and partial search, we can now define a class of functions that includes the primitive
recursive functions.
Definition 5.2.19. A function is partial recursive if it can be generated by starting with
the initial functions and using the operations of composition, primitive recursion, and
partial search.
The collection of partial recursive functions is the smallest set that contains the ini-
tial functions and is closed under composition, primitive recursion, and partial search.
Such functions can be partial functions, because the operation of partial search can pro-
duce partial functions. However, the expression ‚Äúpartial recursive‚Äù is an inseparable
phrase, that is, it should be thought of as ‚Äúpartial-recursive.‚Äù
In Section 5.2.1, we said that a partial function f : ‚Ñïk ‚Üí‚Ñïis Turing computable
when there is a Turing machine that will evaluate f . Thus, the definition of a Turing
computable function is very different from the definition of a partial recursive function.
Is there a connection between these two dissimilar ways of defining functions? Alan
Turing was the first to prove the following striking result.
Theorem 5.2.20 (Turing). Let f : ‚Ñïk ‚Üí‚Ñïbe a partial function. Then f is partial recursive
if and only if f is Turing computable.

5.2 Formalizations‚Äîan overview
‡±™
171
There are mathematically formal definitions of a function being Turing computable,
register-machine computable, and partial recursive. All three of these computational
processes are equivalent, that is, all three approaches define the same class of functions.
However, we have not given a formal definition of a function being computable. This is
because the notion of being computable is intuitive and consequently cannot be given a
precise formal definition. A thesis identified by Alonzo Church and Alan Turing relates
the informal idea of being computable to the formal ideas presented in this section. It is
an observation that has been verified by very strong evidence.
Church-Turing Thesis. Let f be a partial function on the natural numbers. Then the fol-
lowing are equivalent:
‚Äì
f is computable;
‚Äì
f is Turing computable;
‚Äì
f is register-machine computable;
‚Äì
f is partial recursive.
Exercises 5.2.
1. Let Œ£ = {a, b} be a two-letter alphabet. Let f : Œ£‚àó‚ÜíŒ£‚àóbe the 1-place Turing com-
putable function defined by the Turing machine (TM), where q1 is the initial state.
Evaluate f (aabb), f (aba), and f (bbaa). We have
‚ü®q1, a, b, R, q2‚ü©
‚ü®q1, b, a, R, q2‚ü©
‚ü®q1, B, a, R, q2‚ü©
‚ü®q2, a, b, L, q3‚ü©
‚ü®q2, b, a, R, q2‚ü©
‚ü®q2, B, a, L, q3‚ü©.
(TM)
2. Let Œ£ = {a, b} be a two-letter alphabet. Let f : Œ£‚àó‚ÜíŒ£‚àóbe the 1-place function defined
by f (w) = wbb for all w ‚ààŒ£‚àó. Show that the function f is Turing computable. Then
verify that your machine, when given the input ab, will produce abbb as its output.
3. Let Œ£ = {a, b} be a two-letter alphabet. Let f : Œ£‚àó‚ÜíŒ£‚àóbe the 1-place function that
will switch the first letter of every nonempty word in Œ£‚àóto the ‚Äúother‚Äù letter. For
example, f (aabb) = babb and f (bbb) = abb. Show that f is Turing computable. Then
verify that your machine, when given the input aab, will produce bab as its output.
4. Let Œ£ = {a, b} be a two-letter alphabet. Let f : Œ£‚àó‚ÜíŒ£‚àóbe the 1-place function that
will take any nonempty word in Œ£‚àóand change every occurrence of the letter a in
the word to the letter b and will not change any occurrence of letter b in the word.
For example, f (aaba) = bbbb and f (baa) = bbb. Show that f is Turing computable.
Then verify that your machine, when given the input aab, will produce bbb as its
output.
5. Give a register-machine program that computes f (x, y) = max{x ‚àíy, 0}.
6. Give a register-machine program that computes f (x, y) = x ‚ãÖy.

172
‡±™
5 Computability
7. Give a register-machine program that computes f (x, y) = max{x, y}.
8. Let h: ‚Ñï4 ‚Üí‚Ñï, f : ‚Ñï‚Üí‚Ñï, g: ‚Ñï‚Üí‚Ñïbe primitive recursive functions. Using
Definitions 5.2.12 and 5.2.16, show that the function k(x, y, z) = h(f (x), z, g(y), 2) is
primitive recursive.
9. Show that function p defined by (a) and (b) below is a primitive recursive function:
(a) p(m, 0) = m,
(b) p(m, n + 1) = p(m, n) + 1.
Prove that p(m, n) = m + n by induction on n.
10. Show that function h defined by (a) and (b) below is a primitive recursive function:
(a) h(m, 0) = 0,
(b) h(m, n + 1) = h(m, n) + m.
Prove that h(m, n) = mn by induction on n.
Exercise Notes: For Exercise 5, x is in register 1 and y is in register 2. Now move
register 1 into register 0. Keep decrementing registers 2 and 0 until register 2 contains 0.
For Exercise 6, x is in register 1 and y is in register 2. Register 0 initially contains the value
0. Copy register 1 into register 3. Each time you can decrement register 2, add register 3
to register 0 and then copy register 1 into register 3. For Exercise 7, x is in register 1
and y is in register 2. Copy registers 1 and 2 into registers 3 and 4, respectively. Start
decrementing registers 1 and 2. The first such register who gets to 0 had the smallest
initial value.
5.3 Recursive functions
In the previous section, we discovered that the concept of a computable function on the
natural numbers has several equivalent definitions (there are more). In this section, we
will focus our attention on the class of functions that are recursive. Recursive functions
include the primitive recursive functions and are closed under a search operation sim-
ilar to that of partial search (see Definition 5.2.18).
Recalling Definition 5.2.16, a function f from ‚Ñïk to ‚Ñïis primitive recursive if it can
be constructed starting with the zero, successor, and projection functions using com-
position and primitive recursion. Primitive recursion and composition are the key op-
erations that are used to build the primitive recursive functions. Primitive recursive
functions are the computable functions that form an important building block on the
way to capture all of the computable functions. Most of the functions normally studied
in number theory are primitive recursive; for example, addition, division, factorial, ex-
ponentiation, and the n-th prime are all primitive recursive functions. Let us revisit the
initial functions that were introduced in Section 5.2.3 and the operations of composition
and primitive recursion.

5.3 Recursive functions
‡±™
173
Definition 5.3.1. The initial functions are defined as follows:
‚Äì
For each k ‚â•0, the zero function Ãäf : ‚Ñïk ‚Üí‚Ñïis defined by Ãäf (x1, . . . , xk) = 0. The
constant 0 is viewed as a 0-place zero function.
‚Äì
The successor function S: ‚Ñï‚Üí‚Ñïis defined by S(x) = x + 1.
‚Äì
For all 1 ‚â§i ‚â§k, the projection function Ik
i : ‚Ñïk ‚Üí‚Ñïis defined by the equation
Ik
i (x1, . . . , xk) = xi.
Definition 5.3.2. Let n ‚â•1 and k ‚â•1. Suppose that f : ‚Ñïn ‚Üí‚Ñïand gi: ‚Ñïk ‚Üí‚Ñïfor each
i = 1, 2, . . . , n. We can then form the composite function h: ‚Ñïk ‚Üí‚Ñï, which is defined by
h( ‚Éóx) = f (g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx)).
The composition
h( ‚Éóx) = f (g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx))
can be illustrated as a tree with a vertex having (n + 1) branches:
h
f
g1
g2
‚ãÖ‚ãÖ‚ãÖ
gn
Here, f must be an n-place function and g1, . . . , gn must all have the same number of
places as the function h.
The projection functions can be used to avoid the apparent rigidity in terms of the
arity of the functions used in composition. By using compositions with various projec-
tion functions, it is possible to pass a subset of the arguments of one function to another
function. For example, if g and h are 2-place functions, then the function
f (a, b, c) = g(h(c, a), h(a, b))
can be obtained by a composition of projection functions, namely,
f (a, b, c) = g(h(I3
3(a, b, c), I3
1 (a, b, c)), h(I3
1 (a, b, c), I3
2(a, b, c))).
Definition 5.3.3. Let k ‚â•1 and suppose that f : ‚Ñïk ‚Üí‚Ñïand g: ‚Ñïk+2 ‚Üí‚Ñï. Then we can
define a function h: ‚Ñïk+1 ‚Üí‚Ñïby the following primitive recursion:
(1) h( ‚Éóx, 0) = f ( ‚Éóx),
(2) h( ‚Éóx, n + 1) = g(h( ‚Éóx, n), ‚Éóx, n), for all n ‚àà‚Ñï.
We note that Theorem 1.1.27 implies that the function h in Definition 5.3.3 exists and
is unique. The construction of this function h from the functions f and g is illustrated
by the following tree, where the left branch illustrates the ‚Äúbase step‚Äù (1) and the right
branch illustrates the ‚Äúinductive step‚Äù (2).

174
‡±™
5 Computability
h
h( ‚Éóx, 0) = f ( ‚Éóx)
w = h( ‚Éóx, n)
h( ‚Éóx, n + 1) = g(w, ‚Éóx, n)
Note that g must have two more places than f and one more place than h. For example, if
h is a 2-place function, then g must be a 3-place function and f must be a 1-place function.
Definition 5.3.4. A function f from ‚Ñïk to ‚Ñïis primitive recursive if it can be constructed
starting with the zero, successor, and/or projection functions using composition and/or
primitive recursion.
Recall that the operation of partial search may not be successful. Consequently, this
operation can produce a partial function. The set of recursive functions is obtained by
requiring an additional closure condition which is a modification of the partial search
operation. This modification, when applicable, will always produce a total function.
Definition 5.3.5. Let g: ‚Ñïk+1 ‚Üí‚Ñïbe a total function. Suppose that for all
‚Éóx ‚àà‚Ñïk,
there is a y ‚àà‚Ñïsuch that g( ‚Éóx, y) = 0. We say that the k-place function h is obtained
(constructed) from g by total search if h satisfies
h( ‚Éóx) = Œºy(g( ‚Éóx, y) = 0),
that is,
h( ‚Éóx) = the least y such that g( ‚Éóx, y) = 0.
Definition 5.3.6. A function f from ‚Ñïk to ‚Ñïis recursive if it can be constructed start-
ing with the zero, successor, and/or projection functions using composition, primitive
recursion, and/or total search.
We observe that every recursive function is a total function. Moreover, every prim-
itive recursive function is a recursive function, and every recursive function is a partial
recursive function. We note that there are recursive functions that are not primitive re-
cursive, and there are partial recursive functions that are not recursive. In Chapter 6,
we will show that there is a close relationship between deductions in number theory
and recursive functions.
The set of recursive functions can be defined by recursion (see Section 1.1.5). Let B
be the set that consists of the zero, successor, and projection functions. Let ‚Ñ±be the set of
operations that correspond to composition, primitive recursion, and total search. Then,
as in Theorem 1.1.24, we can inductively define the sets of functions:
(1) C0 = B,
(2) Cn+1 = Cn ‚à™‚Ñ±[Cn], for all n ‚àà‚Ñï.

5.3 Recursive functions
‡±™
175
Then C = ‚ãÉn‚àà‚ÑïCn is the set of all the recursive functions. Moreover, if a set contains
the zero, successor, and projection functions and is closed under composition, primitive
recursion, and total search, then the set contains all of the recursive functions.
We will now begin to show that many of the functions on the natural numbers that
we use in mathematics are (primitive) recursive. Each function that we construct can
be used to construct additional (primitive) recursive functions.
Proposition 5.3.7. The addition function h(x, y) = x + y is primitive recursive.
Proof. Observe that:
‚Äì
x + 0 = x,
‚Äì
x + (n + 1) = (x + n) + 1, for all n ‚àà‚Ñï.
Thus, letting h(x, y) = x + y, we have:
‚Äì
h(x, 0) = x,
‚Äì
h(x, n + 1) = h(x, n) + 1, for all n ‚àà‚Ñï.
We will now show that h is primitive recursive. We must find primitive recursive func-
tions f and g that satisfy Definition 5.3.3:
(1) h(x, 0) = f (x), where f is a 1-place function,
(2) h(x, n + 1) = g(h(x, n), x, n), for all n ‚àà‚Ñï, where g is a 3-place function.
The function h has two parts of its definition, namely items (1) and (2). We will find the
two functions f and g by using the following tree to show how h is built up from certain
primitive recursive functions. The left branch focuses on part (1) of the definition of h
and the right branch addresses part (2) of this definition.
h
h(x, 0) = x
= I1
1(x)
w = h(x, n)
h(x, n + 1) = w + 1
= S(w)
= S(I3
1 (w, x, n))
The desired function f is f (x) = I1
1(x), which is an initial function and therefore prim-
itive recursive. The desired function g is g(w, x, n) = S(I3
1 (w, x, n)), which is primitive
recursive because it is the result of composing initial functions. Hence, h is a primitive
recursive function.
The symbol ‚ÄúÛ≥®É‚Üí‚Äù is read as ‚Äúmaps to.‚Äù This symbol gives us an easier way to identify
a function. The notation ‚ü®x, y‚ü©Û≥®É‚Üíx + y indicates that the function is a 2-place function
with input ‚ü®x, y‚ü©and output x + y.

176
‡±™
5 Computability
Proposition 5.3.8. Let k ‚àà‚Ñï. The constant function ‚Éóx Û≥®É‚Üík is primitive recursive.
Let k ‚àà‚Ñï. The constant function ‚Éóx Û≥®É‚Üík is primitive recursive because it is the
result of composing initial functions. For example, suppose k = 3 and let h(x, y, z, w) = 3.
Observe that
h(x, y, z, w) = 3 = S(S(S(0))) = S3(0) = S3( Ãäf (x, y, z, w)),
where Ãäf is the 4-place zero function. Since h is the composition of initial functions, it is
primitive recursive. For k ‚â•1 we shall let kf denote the constant function kf ( ‚Éóx) = k, for
all ‚Éóx ‚àà‚Ñïk. The constant i = Si(0) shall be viewed as a 0-place constant function.
Proposition 5.3.9. The multiplication function ‚ü®x, y‚ü©Û≥®É‚Üíx √ó y is primitive recursive.
Proof. We note that:
(1) x √ó 0 = 0,
(2) x √ó (n + 1) = (x √ó n) + x, for all n ‚àà‚Ñï.
We will find the functions f and g by using the following tree to show how h is built up
from certain primitive recursive functions. The following left branch focuses on part (1)
of the definition of h and the right branch addresses part (2) of this definition.
h
h(x, 0) = 0
= Ãäf (x)
w = h(x, n)
h(x, n + 1) = w + x
= I3
1 (w, x, n) + I3
2(w, x, n)
The desired function f is f (x) = Ãäf (x), the zero function which is primitive recursive. The
desired function g is g(w, x, n) = I3
1 (w, x, n) + I3
2(w, x, n), which is primitive recursive
because addition is primitive recursive. Therefore, h is primitive recursive.
Since the function h(x, y) = x √ó y is primitive recursive, we see that
h(I2
1 (x, y), I2
1 (x, y)) = x √ó x = x2,
h(3f (x, y), I2
1 (x, y)) = 3 √ó x = 3x
are primitive recursive. Propositions 5.3.7, 5.3.8, and 5.3.9 imply that any polynomial
function with coefficients from ‚Ñïis primitive recursive. Thus, p(z, y, z) = 3xy8 + z2 is
primitive recursive.
Remark 5.3.10. Given any (primitive) recursive function f , we can define another func-
tion by replacing any of the variables in f with constants or by interchanging and/or

5.3 Recursive functions
‡±™
177
repeating the variables of f . The new function will then be (primitive) recursive. This
follows by composing f with the appropriate projection and constant functions.
Proposition 5.3.11. The exponentiation function ‚ü®x, y‚ü©Û≥®É‚Üíxy is primitive recursive.
Proof. Since
‚Äì
x0 = 1,
‚Äì
xn+1 = xn √ó x for all n ‚àà‚Ñï,
one can now show, in a manner similar to that in the proof of Proposition 5.3.9, that
exponentiation is primitive recursive.
The exponentiation function ‚ü®x, y‚ü©Û≥®É‚Üíyx is also primitive recursive. This is estab-
lished by composing certain projection functions with the primitive recursive function
in Proposition 5.3.11; namely, let h(x, y) = xy. Define the function g by
g(x, y) = h(I2
2(x, y), I2
1 (x, y)) = h(y, x) = yx.
Since g is constructed by composing primitive recursive functions, it follows that g is
primitive recursive. Since h(3, 4)
Ã∏= g(3, 4), xy and yx are different functions.
Proposition 5.3.12. The factorial function x Û≥®É‚Üíx! is primitive recursive.
Proof. We have:
‚Äì
0! = 1,
‚Äì
(n + 1)! = n! √ó (n + 1), for all n ‚àà‚Ñï.
Thus, letting h(x) = x!, we see that:
‚Äì
h(0) = 1,
‚Äì
h(n + 1) = h(n) √ó (n + 1), for all n ‚àà‚Ñï.
The following tree shows that h is primitive recursive.
h
h(0) = 1
w = h(n)
h(n + 1) = w √ó (n + 1)
= w √ó S(n)
= I2
1 (w, n) √ó S(I2
2(w, n))
Here, 1 is a 0-place primitive recursive function and g(w, n) = I2
1 (w, n) √ó S(I2
2(w, n)) is a
2-place primitive recursive function.

178
‡±™
5 Computability
Proposition 5.3.13. The predecessor function pred(x) = x ‚àí1 (where pred(0) = 0) is
primitive recursive.
Proof. We have:
‚Äì
pred(0) = 0,
‚Äì
pred(n + 1) = n, for all n ‚àà‚Ñï.
Thus, letting h(x) = pred(x), we see that:
‚Äì
h(0) = 0,
‚Äì
h(n + 1) = n, for all n ‚àà‚Ñï.
The following tree shows that h is primitive recursive.
h
h(0) = 0
w = h(n)
h(n + 1) = n
= I2
2(w, n)
Here, 0 is a 0-place primitive recursive function and g(w, n) = I2
2(w, n) is a 2-place prim-
itive recursive function.
Proposition 5.3.14. The proper subtraction function x
‚àò‚àíy is primitive recursive, where
x ‚àò‚àíy is defined by x ‚àò‚àíy = max{x ‚àíy, 0}.
Proof. To see this, observe that:
‚Äì
x ‚àò‚àí0 = x,
‚Äì
x ‚àò‚àí(n + 1) = pred(x ‚àò‚àín), for all n ‚àà‚Ñï.
Thus, letting h(x, y) = x ‚àò‚àíy, we see that:
‚Äì
h(x, 0) = x,
‚Äì
h(x, n + 1) = pred(h(x, n)), for all n ‚àà‚Ñï.
The following tree shows that h is primitive recursive.
h
h(x, 0) = x
= I1
1(x)
w = h(x, n)
h(x, n + 1) = pred(w)
= pred(I3
1 (w, x, n))

5.3 Recursive functions
‡±™
179
Here, I1
1 is a 1-place projection function and g(w, x, n) = pred(I3
1 (w, x, n)) is a 3-place
primitive recursive function.
We are now ready to show that bounded sums and products are recursive. First,
we review summation and product notation. Let f : ‚Ñï‚Üí‚Ñïand n ‚àà‚Ñï. The summation
notation ‚àët<n f (t) and the product notation ‚àèt<n f (t) are defined as follows:
‚àë
t<n
f (t) = f (0) + f (1) + f (2) + ‚ãÖ‚ãÖ‚ãÖ+ f (n ‚àí1),
‚àè
t<n
f (t) = f (0) √ó f (1) √ó f (2) √ó ‚ãÖ‚ãÖ‚ãÖ√ó f (n ‚àí1),
where ‚àët<0 f (t) = 0 and ‚àèt<0 f (t) = 1. Observe that
‚àë
t<(n+1)
f (t) = (‚àë
t<n
f (t)) + f (n)
and
‚àè
t<(n+1)
f (t) = (‚àè
t<n
f (t)) √ó f (n).
Proposition 5.3.15. Suppose that f : ‚Ñïk+1 ‚Üí‚Ñïis (primitive) recursive. Then the summa-
tion function s and the product function p defined by
s( ‚Éóx, y) = ‚àë
t<y
f ( ‚Éóx, t)
and
p( ‚Éóx, y) = ‚àè
t<y
f ( ‚Éóx, t)
are (primitive) recursive.
Proof. Since addition and multiplication are primitive recursive, the functions s and p
are defined, respectively, by primitive recursion as follows:
(1) s( ‚Éóx, 0) = 0,
(2) s( ‚Éóx, n + 1) = s( ‚Éóx, n) + f ( ‚Éóx, n), for all n ‚àà‚Ñï;
(1) p( ‚Éóx, 0) = 1
(2) p( ‚Éóx, n + 1) = p( ‚Éóx, n) √ó f ( ‚Éóx, n), for all n ‚àà‚Ñï.
Proposition 5.3.16. Define the function z by
z(x) = {1,
if x = 0,
0,
if x > 0.
Then z is primitive recursive.
Proof. We have z(x) = 1 ‚àò‚àíx, and 1 ‚àò‚àíx is primitive recursive (see Remark 5.3.10). To see
why z(x) = 1 ‚àò‚àíx, observe that:
‚Äì
z(x) = 1 if and only if x = 0 if and only if 1 ‚àò‚àíx = 1,
‚Äì
z(x) = 0 if and only if x > 0 if and only if 1 ‚àò‚àíx = 0.
Another way to show that z is primitive recursive is to observe that:

180
‡±™
5 Computability
(1) z(0) = 1,
(2) z(n + 1) = 0, for all n ‚àà‚Ñï.
Thus, one can define z by primitive recursion as illustrated in the following tree.
z
z(0) = 1
w = z(n)
z(n + 1) = 0
= Ãäf (w, n)
Here, 1 is a 0-place constant function and Ãäf (w, n) is the 2-place zero function.
Proposition 5.3.17. Define the function h by
h(x, y) = {1,
if x ‚â§y,
0,
if x > y.
(5.4)
Then h is primitive recursive.
Proof. Clearly the function z(x ‚àò‚àíy) is the composition of primitive recursive functions.
To see that h(x, y) = z(x ‚àò‚àíy) satisfies (5.4), note that:
‚Äì
h(x, y) = 1 if and only if x ‚â§y if and only if x ‚àò‚àíy = 0 if and only if z(x ‚àò‚àíy) = 1,
‚Äì
h(x, y) = 0 if and only if x > y if and only if x ‚àò‚àíy > 0 if and only if z(x ‚àò‚àíy) = 0.
Thus, the function defined by (5.4) is primitive recursive.
We have been building recursive functions. We can thus build a recursive relation
by using its characteristic function.
Definition 5.3.18. Let k ‚â•1. We say that a k-place relation R on ‚Ñïis (primitive) recur-
sive if its characteristic function is (primitive) recursive.
In other words, a k-place relation R on ‚Ñïis (primitive) recursive if the function
CR(x1, x2, . . . , xk) = {1,
if ‚ü®x1, x2, . . . , xk‚ü©‚ààR,
0,
if ‚ü®x1, x2, . . . , xk‚ü©‚àâR
is (primitive) recursive. Thus, Proposition 5.3.17 shows that the 2-place relation
{‚ü®x, y‚ü©: x ‚â§y}
is primitive recursive. Proposition 5.3.16 shows that the set {0} is primitive recursive.

5.3 Recursive functions
‡±™
181
Given an n-place (primitive) recursive relation R and n k-place (primitive) recursive
functions g1, g2, . . . , gn, we can define the k-place relation Q by
Q = { ‚Éóx : ‚ü®g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx)‚ü©‚ààR}.
Since the characteristic function for Q is equal to the composition
CQ( ‚Éóx) = CR(g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx)),
it follows that the relation Q is also (primitive) recursive. This observation shall be re-
ferred to as the substitution rule.
For any n-place relation R on ‚Ñï, we shall write R( ‚Éóx) to mean ‚Éóx ‚ààR. Thus, the substi-
tution rule states that if R is (primitive) recursive and g1, g2, . . . , gn are k-place (primitive)
recursive functions, then a relation Q that satisfies
Q( ‚Éóx)
if and only if
R(g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx))
(5.5)
is also (primitive) recursive.
Proposition 5.3.19. Show that the relation {‚ü®x, y‚ü©: x ‚â•y} is primitive recursive.
Proof. Let Q = {‚ü®x, y‚ü©: x ‚â•y}. We know by Proposition 5.3.17 that ‚â§is primitive recur-
sive. Recall that x ‚â•y if and only if y ‚â§x. Since
Q(x, y)
if and only if
I2
2(x, y) ‚â§I2
1 (x, y),
the substitution rule implies that the relation Q is primitive recursive.
Example 5.3.20. Show that the relation {‚ü®x, y‚ü©: x ‚â§y + 1} is primitive recursive.
Solution. Let Q be the relation {‚ü®x, y‚ü©: x ‚â§y + 1}. We know that ‚â§is primitive recursive
by Proposition 5.3.17. Since the successor function S(y) = y+1 is primitive recursive and
Q(x, y)
iff
x ‚â§S(y)
iff
I2
1 (x, y) ‚â§S(I2
2(x, y)),
the substitution rule implies that the relation {‚ü®x, y‚ü©: x ‚â§y + 1} is primitive recursive.
From two k-place relations R and Q on ‚Ñï, we define the following three new rela-
tions:
‚Äì
R = { ‚Éóx ‚àà‚Ñïk : not R( ‚Éóx)},
‚Äì
R ‚à©Q = { ‚Éóx ‚àà‚Ñïk : R( ‚Éóx) and Q( ‚Éóx)},
‚Äì
R ‚à™Q = { ‚Éóx ‚àà‚Ñïk : R( ‚Éóx) or Q( ‚Éóx)}.

182
‡±™
5 Computability
The relation R is called the complement of R and satisfies R( ‚Éóx) if and only if ‚Éóx ‚àâR. The
relation R ‚à©Q is the intersection of R and Q, and the relation R ‚à™Q is the union of the
relations R and Q.
Theorem 5.3.21. Suppose that R and Q are k-place (primitive) recursive relations. Then
the following relations are also (primitive) recursive:
1.
R = { ‚Éóx ‚àà‚Ñïk : not R( ‚Éóx)},
2.
R ‚à©Q = { ‚Éóx ‚àà‚Ñïk : R( ‚Éóx) and Q( ‚Éóx)},
3.
R ‚à™Q = { ‚Éóx ‚àà‚Ñïk : R( ‚Éóx) or Q( ‚Éóx)}.
Proof. Let CR and CQ be the respective characteristic functions of the relations R and Q.
Assuming that CR and CQ are (primitive) recursive, we shall show that the relations R,
R ‚à©Q, and R ‚à™Q are also (primitive) recursive.
1.
First we show that CR( ‚Éóx) = z(CR( ‚Éóx)). Observe that
CR( ‚Éóx) = 1
iff
CR( ‚Éóx) = 0
iff
z(CR( ‚Éóx)) = 1.
Furthermore,
CR( ‚Éóx) = 0
iff
CR( ‚Éóx) = 1
iff
z(CR( ‚Éóx)) = 0.
Thus, CR( ‚Éóx) = z(CR( ‚Éóx)), which is a composition of (primitive) recursive functions.
Hence, R is a (primitive) recursive relation.
2.
One can easily check that CR‚à©Q( ‚Éóx) = CR( ‚Éóx) √ó CQ( ‚Éóx), which is a composition of (prim-
itive) recursive functions. Hence, R ‚à©Q is a (primitive) recursive relation.
3.
First we show that CR‚à™Q( ‚Éóx) = 1 ‚àò‚àíz(CR( ‚Éóx) + CQ( ‚Éóx)). Note that
CR‚à™Q( ‚Éóx) = 1
iff
CR( ‚Éóx) + CQ( ‚Éóx) ‚â•1
iff
z(CR( ‚Éóx) + CQ( ‚Éóx)) = 0
iff
1 ‚àò‚àíz(CR( ‚Éóx) + CQ( ‚Éóx)) = 1.
Moreover,
CR‚à™Q( ‚Éóx) = 0
iff
CR( ‚Éóx) + CQ( ‚Éóx) = 0
iff
z(CR( ‚Éóx) + CQ( ‚Éóx)) = 1
iff
1 ‚àò‚àíz(CR( ‚Éóx) + CQ( ‚Éóx)) = 0.
Thus, CR‚à™Q( ‚Éóx) = 1 ‚àò‚àíz(CR( ‚Éóx)+CQ( ‚Éóx)), a composition of (primitive) recursive functions.
Therefore, R ‚à™Q is a (primitive) recursive relation.

5.3 Recursive functions
‡±™
183
By a pertinent application of the projection functions, Theorem 5.3.21 implies that
the conjunction and disjunction of any two (primitive) recursive relations are also
(primitive) recursive. For example, if R(x, y) and S(y, z) are recursive, then the rela-
tion P(x, y, z) defined by ‚ÄúR(x, y) and S(y, z)‚Äù is also recursive.
From Theorem 5.3.21(2)(3), using a proof by induction, one can now show that any
finite intersection or union of recursive sets is also recursive.
Corollary 5.3.22. Let n ‚àà‚Ñïand suppose that R1, R2, . . . , Rn are k-place (primitive) recur-
sive relations. Then
‚ãÇ
1‚â§i‚â§n
Ri
and
‚ãÉ
1‚â§i‚â§n
Ri
are (primitive) recursive.
We now apply Theorem 5.3.21 to show that the relations <, >, and = are primitive
recursive.
Proposition 5.3.23. The following relations are primitive recursive:
1.
{‚ü®x, y‚ü©: x < y},
2.
{‚ü®x, y‚ü©: x > y},
3.
{‚ü®x, y‚ü©: x = y}.
Proof. We show that the relations are primitive recursive as follows:
1.
Theorem 5.3.21(1) implies that {‚ü®x, y‚ü©: x < y} is primitive recursive, since < is the
complement of the relation ‚â•, which is primitive recursive by Proposition 5.3.19.
2.
Theorem 5.3.21(1) implies that {‚ü®x, y‚ü©: x > y} is primitive recursive, as > is the
complement of the relation ‚â§, which is primitive recursive by Proposition 5.3.17.
3.
Clearly, E = {‚ü®x, y‚ü©: x = y} is the intersection of ‚â§and ‚â•. Propositions 5.3.17
and 5.3.19 and Theorem 5.3.21(2) imply that E is primitive recursive.
We can now prove that any finite set of natural numbers is primitive recursive.
Proposition 5.3.24. Let A = {n1, n2, . . . , nk} be a finite set of natural numbers. Then A is
primitive recursive.
Proof. Let ni ‚ààA, where 1 ‚â§i ‚â§k. We first show that the singleton {ni} is primitive
recursive. Let nif be the constant function defined by nif (x) = ni, for all x ‚àà‚Ñï. The
function nif is primitive recursive by Proposition 5.3.8. Clearly, x ‚àà{ni} if and only if
x = ni. It follows from the substitution rule that {ni} is primitive recursive. To formally
establish this, let I1
1 be the 1-place projection function. By Proposition 5.3.23, the relation
x = y is primitive recursive. As
x ‚àà{ni}
iff
I1
1(x) = nif (x),

184
‡±™
5 Computability
the substitution rule (see (5.5)) implies that {ni} is primitive recursive. Hence, since A =
‚ãÉ1‚â§i‚â§k{ni}, Corollary 5.3.22(2) implies that A is primitive recursive.
We now show that the graph of a recursive function is itself recursive. The converse
also holds (see Exercise 14).
Proposition 5.3.25. Let f : ‚Ñïn ‚Üí‚Ñïbe a (primitive) recursive function. Then the relation
G = {‚ü®‚Éóx, y‚ü©: f ( ‚Éóx) = y}, the graph of f , is (primitive) recursive.
Proof. Since the relation = is primitive recursive and
G( ‚Éóx, y)
if and only if
f ( ‚Éóx) = y,
it follows from the substitution rule that G is a (primitive) recursive relation. More
specifically, since ‚Éóx denotes the n-tuple x1, x2, . . . , xn, we see that In+1
i
( ‚Éóx, y) = xi for each
1 ‚â§i ‚â§n and In+1
n+1( ‚Éóx, y) = y. For every ‚Éóx ‚àà‚Ñïn and y ‚àà‚Ñï, define
g1( ‚Éóx, y) = f (In+1
1
( ‚Éóx, y), . . . , In+1
n
( ‚Éóx, y))
and
g2( ‚Éóx, y) = In+1
n+1( ‚Éóx, y).
Then g1 and g2 are (primitive) recursive, where g1( ‚Éóx, y) = f ( ‚Éóx) and g2( ‚Éóx, y) = y. Thus,
G( ‚Éóx, y)
if and only if
g1( ‚Éóx, y) = g2( ‚Éóx, y).
As the relation = is primitive recursive, the substitution rule (see (5.5)) implies that the
relation G is (primitive) recursive.
The next theorem gives a condition for which one can define a (primitive) recursive
function by cases.
Theorem 5.3.26. Let Q be a k-place (primitive) recursive relation. If f and g are k-place
(primitive) recursive functions, then the k-place function h defined by
h( ‚Éóx) = {f ( ‚Éóx),
if Q( ‚Éóx),
g( ‚Éóx),
if not Q( ‚Éóx)
is also (primitive) recursive.
Proof. Note that
h( ‚Éóx) = (f ( ‚Éóx) √ó CQ( ‚Éóx)) + (g( ‚Éóx) √ó CQ( ‚Éóx)),
which is (primitive) recursive by Propositions 5.3.9 and 5.3.7 and Theorem 5.3.21.
Theorem 5.3.26 can be extended to more than just two exclusive cases. For example,
suppose that f1, f2, f3, f4 are k-place (primitive) recursive functions and suppose that R
and Q are k-place (primitive) recursive relations. Then Theorem 5.3.21 implies that the
function h: ‚Ñïk ‚Üí‚Ñïdefined by

5.3 Recursive functions
‡±™
185
h( ‚Éóx) =
{
{
{
{
{
{
{
{
{
{
{
f1( ‚Éóx),
if Q( ‚Éóx) and R( ‚Éóx),
f2( ‚Éóx),
if Q( ‚Éóx) and not R( ‚Éóx),
f3( ‚Éóx),
if R( ‚Éóx) and not Q( ‚Éóx),
f4( ‚Éóx),
if not Q( ‚Éóx) and not R( ‚Éóx)
is also (primitive) recursive. In the above definition of h, no two of the four cases occur
at the same time, that is, the cases are exclusive. Furthermore, for each ‚Éóx exactly one of
these cases holds.
As another example, let f1, f2, f3, f4 be k-place (primitive) recursive functions and
let Q1, Q2, Q3 be k-place (primitive) recursive relations. Suppose that the relations are
exclusive, that is, for any ‚Éóx, no two of the relations Q1( ‚Éóx), Q2( ‚Éóx), and Q3( ‚Éóx) hold at the
same time. Then the function h: ‚Ñïk ‚Üí‚Ñïdefined by
h( ‚Éóx) =
{
{
{
{
{
{
{
{
{
{
{
f1( ‚Éóx),
if Q1( ‚Éóx),
f2( ‚Éóx),
if Q2( ‚Éóx),
f3( ‚Éóx),
if Q3( ‚Éóx),
f4( ‚Éóx),
if none of the above hold
is (primitive) recursive.
Bounded number quantifiers are very useful when one wants to put some restric-
tion on the numbers being quantified. To say that all natural numbers x < 9 satisfy the
property P(x), we shall write (‚àÄx < 9)P(x). Similarly, to say that some natural num-
ber x < 4 satisfies P(x), we can write (‚àÉx < 4)P(x).
Definition 5.3.27 (Bounded number quantifiers). When a is a specific number, we write
(‚àÄx < a)P(x) to mean that for every natural number x < a, P(x) is true. We also write
(‚àÉx < a)P(x) to assert that for some natural number x < a, P(x) is true.
In our proof of the next theorem we will be using the 1-place function pos defined by
pos(x) = {1,
if x > 0,
0,
if x = 0.
(5.6)
In Exercise 3, one is asked to prove that pos is primitive recursive.
Theorem 5.3.28. If Q is a (k + 1)-place (primitive) recursive relation, then the two follow-
ing (k + 1)-place relations are also (primitive) recursive:
1.
R = {‚ü®‚Éóx, y‚ü©: (‚àÄt < y)Q( ‚Éóx, t)},
2.
P = {‚ü®‚Éóx, y‚ü©: (‚àÉt < y)Q( ‚Éóx, t)}.
Proof. Let Q be a (k + 1)-place (primitive) recursive relation. Thus, the characteristic
function CQ is (primitive) recursive. The characteristic function of the relation R is
CR( ‚Éóx, y) = ‚àè
t<y
CQ( ‚Éóx, t),

186
‡±™
5 Computability
which is (primitive) recursive by Proposition 5.3.15. Furthermore, the characteristic
function of the relation P is
CP( ‚Éóx, y) = pos(‚àë
t<y
CQ( ‚Éóx, t)),
which is also (primitive) recursive by Exercise 3 and Proposition 5.3.15.
Theorem 5.3.28 implies that whenever Q is a (k + 1)-place (primitive) recursive re-
lation and we define a (k + 1)-place relation R by
R( ‚Éóx, y)
if and only if
(‚àÄt < y)Q( ‚Éóx, t),
then R is (primitive) recursive. Similarly, if we define a (k + 1)-place relation P by
P( ‚Éóx, y)
if and only if
(‚àÉt < y)Q( ‚Éóx, t),
we can conclude that P is (primitive) recursive.
Example 5.3.29. Show that the 2-place relation R = {‚ü®x, y‚ü©: (‚àÉq < y + 1)(x √ó q = y)} is
primitive recursive.
Solution. Observe that the 3-place relation Q defined by
Q(x, q, y)
if and only if
x √ó q = y
is primitive recursive by Proposition 5.3.25. Define the 3-place relation P by
P(x, y, z)
if and only if
(‚àÉq < z)(x √ó q = y).
Theorem 5.3.28(2) implies that P is primitive recursive. Now let g1(x, y) = I2
1 (x, y),
g2(x, y) = I2
2(x, y), and g3(x, y) = S(I2
2(x, y)). Clearly, g1, g2, and g3 are primitive recursive
functions. By the substitution rule (see page 181) the relation
P(g1(x, y), g2(x, y), g3(x, y))
is primitive recursive. Observe that
P(g1(x, y), g2(x, y), g3(x, y))
iff
P(x, y, y + 1)
iff
(‚àÉq < y + 1)(x √ó q = y)
iff
R(x, y).
Therefore, the relation R is primitive recursive.
Proposition 5.3.30. The divisibility relation x | y is primitive recursive.

5.3 Recursive functions
‡±™
187
Proof. Since x | y if and only if x √ó q = y for some q, we must show that the relation
{‚ü®x, y‚ü©: x √ó q = y for some q}
is primitive recursive. To verify this, observe that
x | y
iff
‚àÉq(x √ó q = y)
iff
(‚àÉq ‚â§y)(x √ó q = y)
iff
(‚àÉq < y + 1)(x √ó q = y).
Example 5.3.29 now implies that the divisibility relation x | y is primitive recursive.
Remark 5.3.31. It now follows that if we define a relation using bounded quantifiers,
constants, (primitive) recursive relations, (primitive) recursive functions, and the three
logical connectives ‚Äúand‚Äù, ‚Äúor‚Äù, and ‚Äúnot‚Äù, then the relation is (primitive) recursive.
Proposition 5.3.32. The set {2, 3, 5, 7, . . . } of prime numbers is primitive recursive.
Proof. We show that the 1-place relation {x ‚àà‚Ñï: x is a prime} is primitive recursive.
Observe that
x is a prime
iff
1 < x and (‚àÄa < x)(‚àÄb < x)(a √ó b
Ã∏= x),
where the relations < and Ã∏= are primitive recursive, and the function √ó is also primitive
recursive. Therefore, the set of primes forms a primitive recursive set.
5.3.1 Bounded search
The total search operator (see Definition 5.3.5), also called the Œº-operator, provides a
method for defining a function whose value is the least number that satisfies a particular
condition. We will now define a search operation that will only perform a search when
there is an upper bound on the number of the searches allowed, that is, the search will
terminate after looking at finitely many cases.
Definition 5.3.33. Let R be a (k + 1)-place relation on ‚Ñï. For each ‚Éóx ‚àà‚Ñïk, define the
number (Œºt < y)R( ‚Éóx, t) by
(Œºt < y)R( ‚Éóx, t) = {the least t that satisfies t < y and R( ‚Éóx, t),
y,
if no such t exists.
Thus, for any (k + 1)-place relation R on ‚Ñï, we can define the following total (k + 1)-
place function f : ‚Ñïk+1 ‚Üí‚Ñïby
f ( ‚Éóx, y) = (Œºt < y)R( ‚Éóx, t).

188
‡±™
5 Computability
The function f is said to be defined by bounded minimization or bounded search. Observe
that f ( ‚Éóx, y) = y if and only if there is no t < y that satisfies R( ‚Éóx, t).
For example, consider the 2-place relation ‚Äút is a prime and t > x.‚Äù So we can define
the 2-place function f : ‚Ñï2 ‚Üí‚Ñïby
f (x, y) = (Œºt < y)[t is a prime and t > x].
To illustrate how to evaluate this function, we obtain
f (4, 9) = (Œºt < 9)[t is a prime and t > 4] = 5,
f (4, 20) = (Œºt < 20)[t is a prime and t > 4] = 5,
f (9, 4) = (Œºt < 4)[t is a prime and t > 9] = 4,
f (9, 0) = (Œºt < 0)[t is a prime and t > 9] = 0.
Theorem 5.3.34. If R is a (primitive) recursive relation, then the function
f ( ‚Éóx, y) = (Œºt < y)R( ‚Éóx, t)
is (primitive) recursive.
Proof. We will show that f can be defined by primitive recursion. Observe that:
(1) f ( ‚Éóx, 0) = 0,
(2) f ( ‚Éóx, n + 1) =
{
{
{
{
{
{
{
f ( ‚Éóx, n),
if f ( ‚Éóx, n) < n,
n,
if f ( ‚Éóx, n) = n and R( ‚Éóx, n),
n + 1,
if f ( ‚Éóx, n) = n and not R( ‚Éóx, n),
for all n ‚àà‚Ñï.
Thus, we get the following tree, where g is (primitive) recursive (see Proposition 5.3.23,
Remark 5.3.31, and Theorem 5.3.26).
f
f ( ‚Éóx, 0) = 0
= Ãäf ( ‚Éóx)
w = f ( ‚Éóx, n)
f ( ‚Éóx, n + 1) =
{
{
{
{
{
{
{
w,
if w < n,
n,
if w = n & R( ‚Éóx, n),
n + 1,
if w = n & ¬¨R( ‚Éóx, n)
= g(w, ‚Éóx, n)
Euclid proved that there are infinitely many prime numbers. So the function
h: ‚Ñï‚Üí‚Ñïdefined in our next theorem is a total function.

5.3 Recursive functions
‡±™
189
Theorem 5.3.35. Let h: ‚Ñï‚Üí‚Ñïbe defined by
h(x) = the smallest prime number that is strictly larger than x.
(5.7)
Then h is primitive recursive.
Proof. First we prove that for every natural number x there is a prime number p such
that x < p ‚â§x! + 1. Note that every prime number q ‚â§x evenly divides x!. We know that
every natural number greater than 1 is divisible by a prime. Since x! + 1 > 1, the natural
number x! + 1 is divisible by a prime p. Because p evenly divides x! + 1, it follows that p
does not evenly divide x!. Therefore, x < p ‚â§x! + 1. It now follows that
h(x) = (Œºt < (x! + 2))[t is a prime and t > x].
(5.8)
The predicate
t is a prime and t > x
is primitive recursive by Propositions 5.3.32 and 5.3.23 and Theorem 5.3.21(2). Also, the
function x Û≥®É‚Üíx! is primitive recursive by Proposition 5.3.12. So f : ‚Ñï‚Üí‚Ñïdefined by
f (x) = x! + 2 is primitive recursive. Theorem 5.3.34 implies that the function
‚ü®x, y‚ü©Û≥®É‚Üí(Œºt < y)[t is a prime and t > x]
is primitive recursive. Therefore, by composition, the function h satisfying (5.8) is also
primitive recursive.
For each x ‚àà‚Ñï, let px be the (x + 1)-st prime number. Thus,
p0 = 2,
p1 = 3,
p2 = 5,
p3 = 7,
p4 = 11, . . . , p25 = 101, . . . .
One can easily prove, by induction, that px > x + 1 for all x ‚àà‚Ñï.
Proposition 5.3.36. The function x Û≥®É‚Üípx is primitive recursive.
Proof. Let g be defined by g(x) = px. Now let h be the primitive recursive function in
Theorem 5.3.35. Then g can be defined by primitive recursion as follows:
(1) g(0) = 2,
(2) g(n + 1) = h(g(n)), for all n ‚àà‚Ñï.
Thus, the function g is primitive recursive.
An important feature of the natural numbers is that one can code a finite sequence
of natural numbers by a single natural number. The fundamental theorem of arithmetic
(see Theorem 1.1.29 on page 11) states that every natural number x has a unique prime

190
‡±™
5 Computability
factorization. This theorem allows us to encode any finite tuple of natural numbers by
a single natural number using the following bracket notation:
[ ] = 1,
[x, y] = 2x+13y+1,
[x, y, z] = 2x+13y+15z+1,
...
[x0, x1, . . . , xk] = 2x0+13x1+15x2+1 ‚ãÖ‚ãÖ‚ãÖpxk+1
k
,
(5.9)
where [ ] encodes the ‚Äúempty‚Äù tuple and pk denotes the (k + 1)-st prime. For example,
[2, 1] = 72 and [2, 1, 0] = 360. Let S be the set of all finite sequences (tuples) of natural
numbers. Then the function h: S ‚Üí‚Ñïdefined by h(‚ü®x0, x1, . . . , xk‚ü©) = [x0, x1, . . . , xk] is
one-to-one; however, h is not onto since 10 = 2 √ó 5 is not a value of this function.
Theorem 5.3.37. Let k be a natural number. The function h: ‚Ñïk+1 ‚Üí‚Ñïdefined by
h(x0, x1, . . . , xk) = [x0, x1, . . . , xk]
(5.10)
is primitive recursive.
Proof. Let k ‚àà‚Ñï. As h(x0, x1, . . . , xk) = 2x0+13x1+15x2+1 ‚ãÖ‚ãÖ‚ãÖpxk+1
k
, it follows from Proposi-
tion 5.3.15 that h is primitive recursive because exponentiation is primitive recursive
(see Propositions 5.3.11).
Let s be a natural number which codes a sequence, that is, s = [a0, a1, a2, . . . , ak]
for some finite (k + 1)-tuple of natural numbers a0, a1, a2, . . . , ak. We will next show that
there is a primitive recursive ‚Äúdecoding‚Äù function ‚ü®s, i‚ü©Û≥®É‚Üí(s)i such that (s)i = ai for
each i ‚â§k. For example, since [2, 1] = 72, we have (72)0 = 2 and (72)1 = 1.
Proposition 5.3.38. A primitive recursive decoding function ‚ü®s, i‚ü©Û≥®É‚Üí(s)i exists.
Proof. For a prime number q, the largest exponent e such that qe | s is also the least
natural number k such that qk+1 ‚à§s, that is, e = Œºk(qk+1 ‚à§s). Since q ‚â•2 and qe | s,
we have e < qe ‚â§s. Hence, e = (Œºk < s)(qk+1 ‚à§s). Thus, the exponent of q in the prime
factorization of s is equal to
(Œºk < s)(qk+1 ‚à§s).
When q = pi, the (i + 1)-st prime, define
(s)‚àó
i = (Œºk < s)(pk+1
i
‚à§s),

5.3 Recursive functions
‡±™
191
which is the largest exponent of pi in the prime factorization of s. For our decoding
function we need one less than the exponent of the prime pi in the prime factorization
of s. Thus, we have
(s)i = (s)‚àó
i
‚àò‚àí1 = (Œºk < s)(pk+1
i
‚à§s) ‚àò‚àí1,
which is primitive recursive since the far right hand side of the above equations involves
the composition of primitive recursive functions (see Theorems 5.3.34 and 5.3.21(1) and
Propositions 5.3.36 and 5.3.14).
Note that (s)i is defined for all s, i ‚àà‚Ñï, even when s does not code a sequence.
Definition 5.3.39. A natural number s is called a sequence number if s = [ ] or s =
[a0, a1, a2, . . . , ak] for some (k + 1)-tuple of natural numbers a0, a1, a2, . . . , ak.
For example, 1 and 108 are sequence numbers because 1 = [ ] and [1, 2] = 2233 = 108,
but 10 is not a sequence number.
Proposition 5.3.40. The set of sequence numbers is primitive recursive.
Proof. See Exercise 11.
One can prove (by induction) that n + 1 < pn for all natural numbers n. Let x ‚àà‚Ñï
and let k be the smallest such that pk ‚à§x. So x ‚â•1. If k = 0, then k < x. If k > 0, then
pk‚àí1 | x. Thus, pk‚àí1 ‚â§x and hence, k = (k ‚àí1) + 1 < pk‚àí1 ‚â§x, that is, k < x. Therefore, if
k is the smallest such that pk ‚à§x, then k < x. This justifies the upper bound of x on the
Œº-operator in the following proposition.
Proposition 5.3.41. The function lh(x) = (Œºk < x)(pk ‚à§x) is primitive recursive.
Proof. This holds because lh(x) = (Œºk < x)(pk ‚à§x) and the right hand side of this
equation is primitive recursive.
The function lh(x) is called the length function and gives the length of a sequence
coded by x; for example, since 360 = 23 √ó 32 √ó 5 = [2, 1, 0] and p3 = 7 is the least prime
that does not divide 360, we have lh(360) = 3. In general, if x = [a0, a1, a2, . . . , ak], then
lh(x) = k + 1. In addition, (x)lh(x) ‚àò‚àí1 = ak is the last component of the sequence. We note
that lh(0) = 0 by Definition 5.3.33.
Let x = [a0, a1, a2, . . . , ak] be a sequence number and let y ‚â§k + 1. Consider the
function ‚ü®x, y‚ü©Û≥®É‚Üíx ‚Üæy defined by
x ‚Üæy = [a0, a1, a2, . . . , ay‚àí1].
We say that x ‚Üæy is the restriction of x to y and gives us the code for the sequence
consisting of the first y components of the sequence coded by x.
Proposition 5.3.42. The function ‚ü®x, y‚ü©Û≥®É‚Üíx ‚Üæy is primitive recursive.

192
‡±™
5 Computability
Proof. This holds because
x ‚Üæy = ‚àè
t<y
p(x)‚àó
t
t
(5.11)
and the right hand side of (5.11) is a composition of primitive recursive functions.
For example, if x = [a0, a1, . . . , ak] and y ‚â§k + 1, then
x ‚Üæy = [a0, a1, . . . , ay‚àí1] = pa0+1
0
pa1+1
1
‚ãÖ‚ãÖ‚ãÖp
ay‚àí1+1
y‚àí1
= p(x)‚àó
0
0
p(x)‚àó
1
1
‚ãÖ‚ãÖ‚ãÖp
(x)‚àó
y‚àí1
y‚àí1
= ‚àè
t<y
p(x)‚àó
t
t
.
Furthermore, if k = lh(x) ‚àò‚àí1, then x ‚Üæk = [a0, a1, a2, . . . , ak‚àí1] results in the deletion of
the last component in the sequence coded by x.
Let x = [a0, a1, a2, . . . , ak] and y = [b0, b1, b2, . . . , b‚Ñì] be two sequence numbers. Con-
sider the function ‚ü®x, y‚ü©Û≥®É‚Üíx ‚àóy defined by
x ‚àóy = [a0, a1, a2, . . . , ak, b0, b1, b2, . . . , b‚Ñì].
We say that x ‚àóy is the concatenation of x to y.
Proposition 5.3.43. The concatenation function ‚ü®x, y‚ü©Û≥®É‚Üíx ‚àóy is primitive recursive.
Proof. We must show that there is a 2-place primitive recursive function such that if x
and y are sequence numbers, then ‚ü®x, y‚ü©Û≥®É‚Üíx ‚àóy. This is done by defining
x ‚àóy = x √ó ‚àè
t<lh(y)
p(y)‚àó
t
t+lh(x),
which is a composition of primitive recursive functions.
Since [2, 1] = 23 √ó 32 = 72,
72 ‚àó72 = [2, 1] ‚àó[2, 1] = [2, 1, 2, 1] = 72 √ó 53 √ó 72 = 441, 000.
Moreover, if x is a sequence number and i ‚àà‚Ñï, then x ‚àó[i] is the sequence number of
the sequence obtained by adjoining i at the end of the sequence coded by x. We note that
x ‚àóy is defined for all x and y in ‚Ñï, even if x and y are not sequence numbers.
We can define the operation of concatenation of more than two sequence numbers.
Suppose that x0, x1, . . . xk‚àí1 are sequence numbers. Then we can concatenate all of the
sequences coded by x0, x1, . . . xk‚àí1, denoted by‚àót<k xt, as follows:
‚àó
t<k
xt = x0 ‚àóx1 ‚àó‚ãÖ‚ãÖ‚ãÖ‚àóxk‚àí1,
where on the right hand side of the above equation the operation ‚àóis associative.

5.3 Recursive functions
‡±™
193
Proposition 5.3.44. Let f be a (primitive) recursive (k + 1)-place function. Then the func-
tion ‚ü®‚Éóx, y‚ü©Û≥®É‚Üí‚àót<y f ( ‚Éóx, t) is (primitive) recursive.
Proof. Note that the function ‚ü®‚Éóx, y‚ü©Û≥®É‚Üí‚àót<y f ( ‚Éóx, t) can be defined by primitive recursion
as follows:
(1) ‚àót<0 f ( ‚Éóx, t) = 1,
(2) ‚àót<(n+1) f ( ‚Éóx, t) = (‚àót<n f ( ‚Éóx, t)) ‚àóf (x, n), for all n ‚àà‚Ñï.
Therefore, the function ‚ü®‚Éóx, y‚ü©Û≥®É‚Üí‚àót<y f ( ‚Éóx, t) is (primitive) recursive.
For any (k + 1)-place function f , we define a new (k + 1)-place function f by
f ( ‚Éóx, y) = [f ( ‚Éóx, 0), f ( ‚Éóx, 1), . . . , f ( ‚Éóx, y ‚àí1)] = ‚àè
t<y
pf ( ‚Éóx,t)+1
t
.
So the function f encodes the first y values f ( ‚Éóx, 0), f ( ‚Éóx, 1), . . . , f ( ‚Éóx, y ‚àí1) of f as a single
natural number. For example, f ( ‚Éóx, 0) = [ ] = 1 and f ( ‚Éóx, 2) = [f ( ‚Éóx, 0), f ( ‚Éóx, 1)]. Clearly,
f ( ‚Éóx, y) is always a sequence number of length y.
Proposition 5.3.45. Let f be a (primitive) recursive (k +1)-place function. Then the (k +1)-
place function f is (primitive) recursive.
Proof. Since f ( ‚Éóx, y) = ‚àèt<y pf ( ‚Éóx,t)+1
t
, we see that the right hand side of this equation is a
composition of (primitive) recursive functions.
Given any (k +2)-place function g, there exists a unique (k +1)-place function h that
satisfies the equation
h( ‚Éóx, y) = g(h( ‚Éóx, y), ‚Éóx, y),
where we must first know the value of
h( ‚Éóx, y) = [h( ‚Éóx, 0), h( ‚Éóx, 1), . . . , h( ‚Éóx, y ‚àí1)]
before we can evaluate h( ‚Éóx, y). For example,
h( ‚Éóx, 0) = g([ ], ‚Éóx, 0),
h( ‚Éóx, 1) = g([h( ‚Éóx, 0)], ‚Éóx, 1),
h( ‚Éóx, 2) = g([h( ‚Éóx, 0), h( ‚Éóx, 1)], ‚Éóx, 2),
(Û≥µ≥)
...
h( ‚Éóx, n) = g([h( ‚Éóx, 0), h( ‚Éóx, 1), . . . , h( ‚Éóx, n ‚àí1)], ‚Éóx, n),
h( ‚Éóx, n + 1) = g([h( ‚Éóx, 0), h( ‚Éóx, 1), . . . , h( ‚Éóx, n ‚àí1), h( ‚Éóx, n)], ‚Éóx, n + 1).

194
‡±™
5 Computability
The definition of a function by primitive recursion allows one to define the value
of a function h( ‚Éóx, n + 1) in terms of its preceding value h( ‚Éóx, n) (see Definition 5.2.14).
The above (Û≥µ≥) clearly illustrates how to define the value of a function in terms of all
its preceding values, namely, by coding the sequence of preceding values as a sequence
number. In computability theory, a course-of-values recursion is a technique for defining
number-theoretic functions by recursion.
Proposition 5.3.46 (Course of values recursion). Let g be a (primitive) recursive (k + 2)-
place function. Then the (k + 1)-place function h that satisfies
h( ‚Éóx, n) = g(h( ‚Éóx, n), ‚Éóx, n), for all ‚Éóx and n,
is (primitive) recursive.
Proof. To prove that h is (primitive) recursive, we first show (paradoxically) that h is
(primitive) recursive. Note that h satisfies the primitive recursion:
(1) h( ‚Éóx, 0) = 1,
(2) h( ‚Éóx, n + 1) = h( ‚Éóx, n) ‚àó[g(h( ‚Éóx, n)), ‚Éóx, n)], for all n ‚àà‚Ñï.
Thus, h is (primitive) recursive. Since (h( ‚Éóx, n+1))n = h( ‚Éóx, n), we conclude that h is (prim-
itive) recursive. From (2), we also conclude that
(h( ‚Éóx, n + 1))n = (h( ‚Éóx, n) ‚àó[g(h( ‚Éóx, n)), ‚Éóx, n)])n.
Thus, h( ‚Éóx, n) = g(h( ‚Éóx, y), ‚Éóx, n).
We end this section by showing how the total search operation can be used to con-
struct a recursive function.
Proposition 5.3.47. Let R ‚äÜ‚Ñïk+1 be a recursive relation such that for all ‚Éóx ‚àà‚Ñïk there is
a p ‚àà‚Ñïsuch that R( ‚Éóx, p). Then the function f : ‚Ñïk ‚Üí‚Ñïdefined by
f ( ‚Éóx) = the least p ‚àà‚Ñïsuch that R( ‚Éóx, p)
(5.12)
is recursive and R( ‚Éóx, f ( ‚Éóx)) for all ‚Éóx ‚àà‚Ñïk.
Proof. Since for all ‚Éóx ‚àà‚Ñïk there exists a p ‚àà‚Ñïsuch that R( ‚Éóx, p), the function f : ‚Ñïk ‚Üí‚Ñï
defined by (5.12) satisfies f ( ‚Éóx) = Œºp(1
‚àò‚àíCR( ‚Éóx, p) = 0). Therefore, f is recursive and
R( ‚Éóx, f ( ‚Éóx)) for all ‚Éóx ‚àà‚Ñïk.
Exercises 5.3.
1. Show that the function f : ‚Ñï‚Üí‚Ñïdefined by f (x) = x2 is primitive recursive.
2. Show that the function f : ‚Ñï‚Üí‚Ñïdefined by
f (n) = {1,
if n is even,
0,
if n is odd

5.4 Recursively enumerable sets and relations
‡±™
195
is primitive recursive.
*3. Show that the function pos defined by (5.6) is primitive recursive.
4. Let f : ‚Ñï‚Üí‚Ñïand the 2-place relation Q be (primitive) recursive. Show, as in Ex-
ample 5.3.29, that R = {‚ü®x, y‚ü©: (‚àÉq < f (y))Q(x, q)} is (primitive) recursive.
5. Show that the set {i2 : i ‚àà‚Ñï} is primitive recursive.
6. Show that the set {2i : i ‚àà‚Ñï} is primitive recursive.
7. Using definition by cases, show that the following functions f : ‚Ñï2 ‚Üí‚Ñïare primi-
tive recursive:
(a) f (x, y) = |x ‚àíy|,
(b) f (x, y) = max{x, y},
(c) f (x, y) = min{x, y}.
8. Find a nontotal 2-place function g such that the function h defined by
h(x) = Œºy(g(x, y) = 0),
that is,
h(x) = the least y such that g(x, y) = 0,
is a total function.
9. For each i ‚àà‚Ñï, by Proposition 5.3.38, the function t Û≥®É‚Üí(t)i is primitive recursive.
Evaluate (24)0, (24)1, (45)0, (45)1, (45)2, (23)0, and (23)1.
10. Define m: ‚Ñïk+1 ‚Üí‚Ñïby m( ‚Éóx, n) = max{f ( ‚Éóx, i) : 0 ‚â§i ‚â§n}, where f : ‚Ñïk+1 ‚Üí‚Ñïis
(primitive) recursive. Show that m is (primitive) recursive.
*11. Prove Proposition 5.3.40.
12. For each n ‚àà‚Ñï, let An be a recursive subset of ‚Ñï. Show that ‚ãÇn
i=0 Ai and ‚ãÉn
i=0 Ai are
recursive, for all n ‚àà‚Ñï.
13. Let g: ‚Ñï‚Üí‚Ñïbe (primitive) recursive. Let g(0)(i) = i and whenever p ‚â•1, let
g(p) = g ‚àòg ‚àò‚ãÖ‚ãÖ‚ãÖ‚àòg
‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü‚èü
p-times
.
Define f : ‚Ñï2 ‚Üí‚Ñïby f (i, n) = g(n)(i). Show that f is (primitive) recursive.
*14. Let f : ‚Ñïk ‚Üí‚Ñïbe a total function. Show that if the graph of f is recursive, then f is
recursive.
5.4 Recursively enumerable sets and relations
Some sets of natural numbers are recursive and some are almost recursive. Recall that
a recursive nonempty set A ‚äÜ‚Ñïis one whose characteristic function CA is recursive.
Using CA, one can effectively enumerate the elements of A. Let k0 ‚ààA and define the
function f : ‚Ñï‚Üí‚Ñïby

196
‡±™
5 Computability
f (n) = {n,
if CA(n) = 1,
k0,
if CA(n) = 0.
Clearly, f is a recursive function and the range of f is equal to A. Thus, we can list all the
values of f as follows: f (0), f (1), f (2), . . . . This listing also effectively enumerates all of the
elements of A. Theorem 5.3.21 implies that ‚Ñï\ A is recursive. Thus, in a similar manner,
we can effectively enumerate the elements of ‚Ñï\ A (if nonempty). This motivates our
next definition.
Definition 5.4.1. A set A ‚äÜ‚Ñïis recursively enumerable if and only if A = ‚åÄor there is a
recursive function f : ‚Ñï‚Üí‚Ñïsuch that A is the range of f .
The function f in Definition 5.4.1 is not required to be one-to-one. However, Exer-
cise 7 shows that every infinite recursively enumerable subset of ‚Ñïis the range of a
one-to-one recursive function.
A recursively enumerable set of natural numbers can be viewed as being ‚Äúalmost
recursive.‚Äù A recursively enumerable set is also said to be semi-recursive. There is an
alternative interpretation of a set being recursively enumerable.
Proposition 5.4.2. A set A ‚äÜ‚Ñïis recursively enumerable if and only if there is a 2-place
recursive relation R such that A = {n ‚àà‚Ñï: ‚àÉpR(n, p)}.
Proof. Let A ‚äÜ‚Ñï.
(‚áí). Assume that A is recursively enumerable. Let f : ‚Ñï‚Üí‚Ñïbe a recursive function
such that A equals the range of f . Consider the relation
R = {‚ü®n, p‚ü©: n = f (p)}.
Since the relation = is primitive recursive, the substitution rule (see (5.5) on page 181)
implies that the relation R is recursive. Clearly, A = {n ‚àà‚Ñï: ‚àÉpR(n, p)}.
(‚áê). Assume that A = {n ‚àà‚Ñï: ‚àÉpR(n, p)} for some recursive relation R. If A = ‚åÄ, then
we are done. So let k ‚ààA. By Proposition 5.3.38, the ‚Äúdecoding‚Äù operation (s)i is defined
for all s, i ‚àà‚Ñï. Let f : ‚Ñï‚Üí‚Ñïbe defined by
f (n) = {(n)0,
if R((n)0, (n)1),
k,
if not R((n)0, (n)1).
Then f is recursive (see Proposition 5.3.38) and the range of f is A.
Proposition 5.4.2 allows us to broaden the definition of recursively enumerable.
Definition 5.4.3. A relation P ‚äÜ‚Ñïk is recursively enumerable if and only if there is a
(k + 1)-place recursive relation R such that

5.4 Recursively enumerable sets and relations
‡±™
197
P( ‚Éóx)
iff
‚àÉpR( ‚Éóx, p)
for all ‚Éóx ‚àà‚Ñïk.
Our goal now is to establish a surprising result: Every total partial recursive func-
tion is, in fact, a recursive function (see Theorem 5.4.12).
Theorem 5.4.4 (Selection theorem). Let S ‚äÜ‚Ñïk+1 be recursively enumerable and suppose
that for all ‚Éóx ‚àà‚Ñïk there exists an i ‚àà‚Ñïsuch that S( ‚Éóx, i). Then there is a recursive function
f : ‚Ñïk ‚Üí‚Ñïsuch that S( ‚Éóx, f ( ‚Éóx)) for all ‚Éóx ‚àà‚Ñïk.
Proof. Given that S is recursively enumerable, there is a recursive relation R such that
S( ‚Éóx, i)
iff
‚àÉjR( ‚Éóx, i, j).
Suppose that for all ‚Éóx ‚àà‚Ñïk there exists an i ‚àà‚Ñïsuch that S( ‚Éóx, i). Thus, for all ‚Éóx ‚àà‚Ñïk
there are i, j ‚àà‚Ñïsuch that R( ‚Éóx, i, j). Define h: ‚Ñïk ‚Üí‚Ñïby
h( ‚Éóx) = the least p ‚àà‚Ñïsuch that R( ‚Éóx, (p)0, (p)1).
Note that h( ‚Éóx) = Œºp(1
‚àò‚àíCR( ‚Éóx, (p)0, (p)1) = 0) and this is obtained from the recursive
function g( ‚Éóx, p) = 1 ‚àò‚àíCR( ‚Éóx, (p)0, (p)1) by a total search (Definition 5.3.5). So h is recursive.
Define f : ‚Ñïk ‚Üí‚Ñïby f ( ‚Éóx) = (h( ‚Éóx))0. Thus, f is recursive and S( ‚Éóx, f ( ‚Éóx)) for all ‚Éóx ‚àà‚Ñïk.
We now show that the set of recursively enumerable relations is closed under re-
cursive substitutions, conjunction, and disjunction.
Lemma 5.4.5. Suppose that P is an n-place recursively enumerable relation and that
g1, g2, . . . , gn are k-place recursive functions. Then the k-place relation Q defined by
Q( ‚Éóx)
iff
P(g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx))
is recursively enumerable.
Proof. Given that P is recursively enumerable, there is an (n+1)-place recursive relation
R such that P(x1, . . . , xn) iff ‚àÉiR(x1, . . . , xn, i). Thus, for all ‚Éóx ‚àà‚Ñïk, we have
Q( ‚Éóx)
iff
P(g1( ‚Éóx), . . . , gn( ‚Éóx))
iff
‚àÉiR(g1( ‚Éóx), . . . , gn( ‚Éóx), i).
By the substitution rule, the relation R(g1( ‚Éóx), . . . , gn( ‚Éóx), i) is recursive. Therefore, Q is
recursively enumerable.
Lemma 5.4.6. Let R ‚äÜ‚Ñïk and Q ‚äÜ‚Ñïk.
1.
If R is a recursive relation, then R is recursively enumerable.
2.
If R and Q are recursively enumerable relations, then the following relations are also
recursively enumerable:

198
‡±™
5 Computability
(a) R ‚à©Q = { ‚Éóx ‚àà‚Ñïk : R( ‚Éóx) and Q( ‚Éóx)},
(b) R ‚à™Q = { ‚Éóx ‚àà‚Ñïk : R( ‚Éóx) or Q( ‚Éóx)}.
Proof. Suppose that R ‚äÜ‚Ñïk and Q ‚äÜ‚Ñïk.
1.
Let R be a recursive relation. The relation S ‚äÜ‚Ñïk+1 defined by S( ‚Éóx, p) iff R( ‚Éóx) is
recursive, as S is the result of a composition of R with the projection functions
Ik+1
i
(x1, . . . , xk, p) = xi, where 1 ‚â§i ‚â§k. Clearly, R( ‚Éóx) iff ‚àÉpS( ‚Éóx, p). So R is recursively
enumerable.
2.
Assume that R and Q are recursively enumerable. Therefore, there are recursive
relations S ‚äÜ‚Ñïk+1 and U ‚äÜ‚Ñïk+1 such that
(R( ‚Éóx)
iff
‚àÉpS( ‚Éóx, p))
and
(Q( ‚Éóx)
iff
‚àÉpU( ‚Éóx, p)).
Thus,
(R( ‚Éóx) and S( ‚Éóx))
iff
‚àÉp(S( ‚Éóx, (p)0) and U( ‚Éóx, (p)1)),
(R( ‚Éóx) or S( ‚Éóx))
iff
‚àÉp(S( ‚Éóx, p) or U( ‚Éóx, p)).
Therefore, Theorem 5.3.21 and the substitution rule imply that the conjunction
‚ÄúR( ‚Éóx) and S( ‚Éóx)‚Äù and disjunction ‚ÄúR( ‚Éóx) or S( ‚Éóx)‚Äù are recursively enumerable.
By a suitable use of the projection functions, part 2 of Lemma 5.4.6 implies that
the conjunction and disjunction of any two recursively enumerable relations are re-
cursively enumerable. For example, if R(x, y) and S(y, z) are recursively enumerable,
then the relation P(x, y, z) defined by ‚ÄúR(x, y) and S(y, z)‚Äù is recursively enumerable.
Moreover, by applying a proof by induction, part 2 of Lemma 5.4.6 implies that the con-
junction or disjunction of any finite number of recursively enumerable relations is also
recursively enumerable.
Corollary 5.4.7. Let n ‚àà‚Ñïand suppose that R1, R2, . . . , Rn are k-place recursively enu-
merable relations. Then
1.
‚ãÄn
i=1 Ri( ‚Éóx) = R1( ‚Éóx) ‚àßR2( ‚Éóx) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßRn( ‚Éóx) is recursively enumerable,
2.
‚ãÅn
i=1 Ri( ‚Éóx) = R1( ‚Éóx) ‚à®R2( ‚Éóx) ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®Rn( ‚Éóx) is recursively enumerable.
We will now show that the set of recursively enumerable relations is closed under
the bounded number quantifiers and the existential quantifier.
Lemma 5.4.8. Let Q ‚äÜ‚Ñïk+1 be recursively enumerable and let n ‚àà‚Ñï. Then:
1.
The relation (‚àÄi < n)Q( ‚Éóx, i) is recursively enumerable.
2.
The relation (‚àÉi < n)Q( ‚Éóx, i) is recursively enumerable.
3.
The relation ‚àÉiQ( ‚Éóx, i) is recursively enumerable.
Proof. Let Q ‚äÜ‚Ñïk+1 be recursively enumerable. Thus, there is a recursive relation R
such that

5.4 Recursively enumerable sets and relations
‡±™
199
Q( ‚Éóx, i)
iff
‚àÉjR( ‚Éóx, i, j).
The desired conclusion follows from the following equivalences:
(‚àÄi < n)Q( ‚Éóx, i)
iff
(‚àÄi < n)‚àÉjR( ‚Éóx, i, j)
iff
‚àÉj(‚àÄi < n)R( ‚Éóx, i, (j)i),
(5.13)
(‚àÉi < n)Q( ‚Éóx, i)
iff
(‚àÉi < n)‚àÉjR( ‚Éóx, i, j)
iff
‚àÉj(‚àÉi < n)R( ‚Éóx, i, j),
(5.14)
‚àÉiQ( ‚Éóx, i)
iff
‚àÉi‚àÉjR( ‚Éóx, i, j)
iff
‚àÉkR( ‚Éóx, (k)0, (k)1).
(5.15)
To confirm (5.13), given that for each i < n there is a ji ‚àà‚Ñïsuch that R( ‚Éóx, i, ji), let j be the
sequence number j = [j0, j1, . . . , jn‚àí1]. Then (‚àÄi < n)R( ‚Éóx, i, (j)i). Thus, ‚àÉj(‚àÄi < n)R( ‚Éóx, i, (j)i).
The converse holds similarly. Theorem 5.3.28 implies that the right hand sides of (5.13)
and (5.14) are recursively enumerable, and the substitution rule implies that the right
hand side of (5.15) is recursively enumerable.
The set of partial recursive functions can be defined by induction (see Section 1.1.5).
Let B be the set consisting only of the zero, successor, and projection functions. Let ‚Ñ±
be the set of functional operations that correspond to composition, primitive recursion,
and partial search. Then, as in Theorem 1.1.24, we inductively define the following sets
of functions:
(1) C0 = B,
(2) Cn+1 = Cn ‚à™‚Ñ±[Cn], for all n ‚àà‚Ñï.
Then C = ‚ãÉn‚àà‚ÑïCn is the set of all the partial recursive functions. Moreover, whenever
a set contains the zero, successor, and projection functions and it is closed under com-
position, primitive recursion, and partial search, then the set contains all of the partial
recursive functions (see Exercise 5(b) on page 15). We will apply this observation in the
proof of our next theorem. First we give a definition.
Definition 5.4.9. Let h be a k-place partial recursive function. Then the graph of h is the
(k + 1)-place relation
Gh = {( ‚Éóx, y) : h( ‚Éóx) = y}.
The next theorem shows that there exists a close connection between partial recur-
sive functions and recursively enumerable relations.
Theorem 5.4.10. For every partial recursive function h, the graph of h is recursively enu-
merable.
Proof. Let S be the set of all partial recursive functions whose graph is recursively enu-
merable. We shall prove by induction that S contains all partial recursive functions.
Base step: We must show that every initial function is in S. To do this, let h be an
initial function. Since h is a recursive function, Gh is recursive by Proposition 5.3.25.
Lemma 5.4.6(1) now implies that the relation Gh is recursively enumerable.

200
‡±™
5 Computability
Inductive step: We must show that S is closed under (1) composition, (2) primitive re-
cursion, and (3) partial search. Let f , g, g1, g2, . . . , gn be partial recursive functions and
assume that all of these functions are in S, that is, assume the induction hypothesis
Gf , Gg, Gg1, . . . , Ggn are recursively enumerable.
(IH)
We now establish closure under the above identified operations (1), (2), and (3).
(1) Assume that f : ‚Ñïn ‚Üí‚Ñïand gi: ‚Ñïk ‚Üí‚Ñïfor each i = 1, 2, . . . , n. We must show that
function h: ‚Ñïk ‚Üí‚Ñïdefined by the composition
h( ‚Éóx) = f (g1( ‚Éóx), g2( ‚Éóx), . . . , gn( ‚Éóx))
is also in S. Since
h( ‚Éóx) = y
iff
‚àÉv1 ‚ãÖ‚ãÖ‚ãÖ‚àÉvn(
n
‚ãÄ
i=1
gi( ‚Éóx) = vi and f (v1, v2, . . . , vn) = y),
(IH), Corollary 5.4.7, and Exercise 11 imply that Gh is recursively enumerable.
(2) Assume that f : ‚Ñïk ‚Üí‚Ñïand g: ‚Ñïk+2 ‚Üí‚Ñï. We must show that the function
h: ‚Ñïk+1 ‚Üí‚Ñïdefined by the primitive recursion
(a) h( ‚Éóx, 0) = f ( ‚Éóx),
(b) h( ‚Éóx, n + 1) = g(h( ‚Éóx, n), ‚Éóx, n), for all n ‚àà‚Ñï,
is also in S. Because
h( ‚Éóx, n) = y
iff
‚àÉp(f ( ‚Éóx) = (p)0 and (‚àÄi < n)(g((p)i, ‚Éóx, i) = (p)i+1) and (p)n = y),
Lemmas 5.4.5, 5.4.6, and 5.4.8(1)(2) and (IH) imply that Gh is recursively enumerable.
(3) Assume that g is a (k + 1)-place function. We must show that the k-place function h
defined by the partial search
h( ‚Éóx) = Œºy(g( ‚Éóx, y) = 0)
is in S. Since
h( ‚Éóx) = y
iff
g( ‚Éóx, y) = 0 and (‚àÄi < y)‚àÉv(g( ‚Éóx, s) = v and v > 0),
Lemmas 5.4.6 and 5.4.8(1)(2) and (IH) imply that Gh is recursively enumerable.
Theorem 5.4.10 and a modification of the proof of Theorem 5.4.4 (see Exercise 5) now
imply the following equivalence.
Theorem 5.4.11. Let h: ‚Ñïk ‚Üí‚Ñïbe a partial function. Then h is partial recursive if and
only if Gh is recursively enumerable.
Theorems 5.4.10 and 5.4.4 also imply that every total partial recursive function is
recursive.

5.4 Recursively enumerable sets and relations
‡±™
201
Theorem 5.4.12. Let h: ‚Ñïk ‚Üí‚Ñïbe a total partial recursive function. Then h is a recursive
function.
Proof. Let h be a total partial recursive function. Theorem 5.4.10 implies the relation
Gh( ‚Éóx, y)
iff
h(x) = y
(5.16)
is recursively enumerable. Since h is total, we know that for all ‚Éóx ‚àà‚Ñïk, there is a y
such that Gh( ‚Éóx, y). The selection theorem (Theorem 5.4.4) implies that there is a recursive
function f : ‚Ñïk ‚Üí‚Ñïsuch that Gh( ‚Éóx, f ( ‚Éóx)) for all ‚Éóx ‚àà‚Ñïk. Therefore, by (5.16), we conclude
that h( ‚Éóx) = f ( ‚Éóx) for all ‚Éóx ‚àà‚Ñïk, that is, h is a recursive function.
5.4.1 Decidability revisited
In Section 5.1.1 we presented a definition of a decidable (semi-decidable) set. However,
this definition was given in terms of the intuitive concept of an ‚Äúeffective procedure.‚Äù
Because of Theorems 5.2.11 and 5.2.20 and the Church‚ÄìTuring thesis, we can now give a
mathematically precise definition of a set being decidable (semi-decidable).
Definition 5.4.13. Let S ‚äÜ‚Ñïk. Then S is decidable if its characteristic function
CS( ‚Éóx) = {1,
if ‚Éóx ‚ààS,
0,
if ‚Éóx ‚àâS
is partial recursive. Moreover, S is semi-decidable if its semi-characteristic function
cS( ‚Éóx) = {1,
if ‚Éóx ‚ààS
‚Üë,
if ‚Éóx ‚àâS
is partial recursive.
In light of Theorem 5.4.12, the above definition of a set being decidable can be made
stronger. Our next result confirms this by showing that a relation is decidable if and only
if its characteristic function is recursive.
Theorem 5.4.14. Let S ‚äÜ‚Ñïk. Then S is decidable if and only if S is recursive.
Proof. Assume that S is decidable. Thus, the characteristic function CS is total and par-
tial recursive. Theorem 5.4.12 implies that CS is recursive, so S is recursive. Conversely,
suppose that S is recursive. Then CS is recursive and hence, it is partial recursive. There-
fore, S is decidable.
Theorem 5.4.15. Let S ‚äÜ‚Ñïk. Then S is semi-decidable if and only if S is recursively enu-
merable.
Proof. Assume that S is semi-decidable. So cS is partial recursive. By Theorem 5.4.10, the
graph GcS( ‚Éóx, y) of cS is recursively enumerable. Since

202
‡±™
5 Computability
‚Éóx ‚ààS
iff
‚àÉyGcS( ‚Éóx, y),
Lemma 5.4.8(3) implies that S is recursively enumerable.
For the converse, suppose that S is recursively enumerable. Definition 5.4.3 implies
that there is a recursive (k + 1)-place relation R such that
S( ‚Éóx)
iff
‚àÉpR( ‚Éóx, p).
Since R is recursive, the characteristic function CR is recursive. Let h be the partial re-
cursive function
h( ‚Éóx) = Œºp(1 ‚àò‚àíCR( ‚Éóx, p) = 0),
where h is the result of applying partial search (see Definition 5.2.18) to the recursive
function g( ‚Éóx, p) = 1 ‚àò‚àíCR( ‚Éóx, p). Then CR( ‚Éóx, h( ‚Éóx)) is the semi-characteristic function of S.
Therefore, S is semi-decidable.
We now show that a relation is recursive if and only if the relation and its comple-
ment are recursively enumerable.
Theorem 5.4.16. Let P ‚äÜ‚Ñïk. Then P is recursive if and only if P and ‚Ñïk \P are recursively
enumerable.
Proof. Let P ‚äÜ‚Ñïk. Then P and ‚Ñïk \ P are recursive. Lemma 5.4.6(1) implies that both
of these sets are recursively enumerable. Now assume that P and ‚Ñïk \ P are recursively
enumerable. Thus, there are recursive (k + 1)-relations R and S such that
‚Éóx ‚ààP
iff
‚àÉiR( ‚Éóx, i),
(5.17)
‚Éóx ‚àâP
iff
‚àÉiS( ‚Éóx, i),
(5.18)
for all ‚Éóx ‚àà‚Ñïk. Hence, for all ‚Éóx ‚àà‚Ñïk, there exists an i such that R( ‚Éóx, i) or S( ‚Éóx, i). By
Lemma 5.4.6(2b), the relation ‚ÄúR( ‚Éóx, i) or S( ‚Éóx, i)‚Äù is recursive. So, by total search, the func-
tion h: ‚Ñïk ‚Üí‚Ñïdefined by
h( ‚Éóx) = Œºi(R( ‚Éóx, i)
or
S( ‚Éóx, i))
is recursive. Since ‚Éóx ‚ààP iff R( ‚Éóx, h( ‚Éóx)), it follows that P is recursive.
In Section 5.1.1 we presented an intuitive argument that was designed only to con-
firm Theorem 5.1.17. Theorems 5.4.14, 5.4.15, and 5.4.16 now provide a mathematically
rigorous proof of Theorem 5.1.17, which is restated below.
Theorem 5.4.17 (Kleene). Let S ‚äÜ‚Ñïk. Then S is decidable if and only if S and its comple-
ment ‚Ñïk \ S are semi-decidable.

5.4 Recursively enumerable sets and relations
‡±™
203
Exercises 5.4.
1. Let f : ‚Ñï‚Üí‚Ñïbe recursive. Show that the semi-characteristic function of the range
of f , {f (x) : x ‚àà‚Ñï}, is partial recursive.
2. Let f : ‚Ñï‚Üí‚Ñïbe a recursive bijection. Show that f ‚àí1 is recursive.
3. Let A ‚äÜ‚Ñïbe the nonempty range of a partial recursive function. Show that A is
recursively enumerable.
4. Let A ‚äÜ‚Ñïbe recursively enumerable. Show that A is the domain of a partial re-
cursive function.
*5. Let h: ‚Ñïk ‚Üí‚Ñïbe a partial function. Show that if Gh is recursively enumerable,
then h is partial recursive.
*6. Let f : ‚Ñï‚Üí‚Ñïbe a recursive function. Show that if f is strictly increasing, then its
range {f (x) : x ‚àà‚Ñï} is recursive.
*7. Let f : ‚Ñï‚Üí‚Ñïbe recursive, where ran(f ) = {f (x) : x ‚àà‚Ñï} is infinite.
(a) For all n ‚àà‚Ñï, show that there is an i > n such that (‚àÄj ‚â§n)(f (j)
Ã∏= f (i)).
(b) For all n ‚àà‚Ñï, let i be the least such that i > n and (‚àÄj ‚â§n)(f (j)
Ã∏= f (i)). Show
that (‚àÄj < i)(f (j)
Ã∏= f (i)).
(c) Define g: ‚Ñï‚Üí‚Ñïby
g(n) = the least i ‚àà‚Ñïsuch that i > n and (‚àÄj < i)(f (j)
Ã∏= f (i)).
Show that g is recursive. Clearly, n < g(n) for all n ‚àà‚Ñï.
(d) Define h: ‚Ñï‚Üí‚Ñïby h(0) = 0 and h(n + 1) = g(h(n)). Thus, h is recursive.
Show that h(n) < h(n + 1) for all n ‚àà‚Ñï. Hence, h is one-to-one and strictly
increasing.
(e) Show that f (h(n))
Ã∏= f (j) for all j < h(n), for each n ‚àà‚Ñï.
(f) Show that v: ‚Ñï‚Üí‚Ñïdefined by v(n) = f (h(n)) is one-to-one.
(g) Let y ‚ààran(f ) and let i ‚àà‚Ñïbe the least such that f (i) = y. Therefore, (‚àÄj <
i)(f (j)
Ã∏= f (i)). Show that i = h(n) for some n. Now conclude that ran(v) =
ran(f ).
8. Let A ‚äÜ‚Ñïbe an infinite recursive set. Show that A is the range of a strictly increas-
ing recursive function.
9. Let A ‚äÜ‚Ñïbe an infinite recursively enumerable set. Show that there is an infinite
recursive set B such that B ‚äÜA.
10. Prove Corollary 5.4.7.
*11. Let Q ‚äÜ‚Ñïk+n be recursively enumerable. Prove that the relation
‚àÉi1‚àÉi2 . . . ‚àÉinR( ‚Éóx, i1, i2, . . . , in),
where ‚Éóx ‚àà‚Ñïk, is recursively enumerable.
Exercise Notes: For Exercise 7(c), see Proposition 5.3.47. For Exercise 7(f), if not, then
by (d) there exists an n such that h(n) < i < h(n + 1). Exercise 7 shows that every infi-

204
‡±™
5 Computability
nite recursively enumerable subset of ‚Ñïis the range of a one-to-one recursive function.
For Exercise 9, by Definition 5.4.1 there is a recursive function f : ‚Ñï‚Üí‚Ñïsuch that A
is the range of f . Use f to construct a strictly increasing recursive function h such that
the range of h is a subset of A; Exercise 6 (above) implies that the range of h is recur-
sive.

6 Undecidability and incompleteness
6.1 Introduction
Let ‚Ñíbe a language that is commonly used in mathematics. Let us say that a set of
‚Ñí-sentences is decidable if there is an effective procedure to decide whether or not a
sentence belongs to the set. In particular, a finite set of sentences is decidable. Now let
A be an ‚Ñí-structure.
Can we find a decidable set Œì of ‚Ñí-sentences such that A Û≥ÄÄÛ≥®êŒì and
A Û≥ÄÄÛ≥®êœÜ if and only if Œì ‚ä¢œÜ, for each ‚Ñí-sentence œÜ?
(Q1)
That is, is there a reasonable set of axioms that can be used to deduce the statements
that are true in the structure A? This is a question that is often posed in mathematics. If
one is going to make deductions from a set of axioms, then one must be able to clearly
identify the axioms, that is, the set of axioms must be decidable.
Let us direct question (Q1) to some mathematical languages and structures. Let
‚Ñí= { Ãá<, Ãá=} and let Œ® be the axioms for dense linear orders without endpoints (see
page 143). Recall that ùí¨Û≥ÄÄÛ≥®êŒ®. Corollary 4.3.19 shows that ùí¨Û≥ÄÄÛ≥®êœÜ if and only if Œ® ‚ä¢œÜ, for
all ‚Ñí-sentences œÜ. Thus, in this case, there is a positive answer to question (Q1). More-
over, let Œ∏ be an ‚Ñí-sentence. Corollary 4.3.19 implies that either Œ® ‚ä¢Œ∏ or Œ® ‚ä¢¬¨Œ∏, but
not both. Since Œ® is finite and the set of logical axioms is decidable, we can effectively
enumerate all of the deductions from Œ® and eventually find a deduction of either Œ∏ or
¬¨Œ∏. So we can effectively answer the question: Does Œ® ‚ä¢Œ∏?
Now let us consider the language of elementary number theory (see Section 4.3.1)
‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} and the standard model of arithmetic (see page 137)
ùí©= ‚ü®‚Ñï; 0, S, <, +, √ó, E‚ü©.
Let us rephrase question (Q1) with respect to ‚Ñíand ùí©:
Is there a decidable set of ‚Ñí-sentences Œì such that ùí©Û≥ÄÄÛ≥®êŒì and
ùí©Û≥ÄÄÛ≥®êœÜ if and only if Œì ‚ä¢œÜ, for each ‚Ñí-sentence œÜ?
(Q2)
Our development in Sections 5.3 and 5.4 on recursive functions and decidability will
allow us to address question (Q2). As we will see, mathematical logic and computability
are intimately connected.
Remark. The above question (Q2) inspired much of the early growth of mathematical
logic. At the International Congress of Mathematicians, a meeting held in Paris in 1900,
David Hilbert challenged mathematicians to identify a set of axioms for number theory
that would positively address question (Q2). David Hilbert (1862‚Äì1943), whose name is
attached to the concept of a Hilbert space, was one of the most influential and compre-
hensive mathematicians of the late nineteenth and early twentieth centuries.
https://doi.org/10.1515/9783110782073-006

206
‡±™
6 Undecidability and incompleteness
6.2 Basic axioms for number theory
In our quest to address the preceding question (Q2), we will first identify a finite set of
axioms for number theory which will help us to answer this question. These axioms are
first-order sentences in the language ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} and hold in ùí©, the standard
model of arithmetic. We will use x Ãá‚â§y as an abbreviation for (x Ãá< y ‚à®x Ãá= y) and use x Ã∏Ãá< y,
x
Ã∏Ãá= y to respectively abbreviate ¬¨(x Ãá< y), ¬¨(x Ãá= y).
Basic Axioms 6.2.1. Let ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=}. Let Œ© consist of the following 11 axioms,
where x, y are variables:
(A1) ‚àÄx( ÃáSx
Ã∏Ãá= Ãá0),
(A2) ‚àÄx‚àÄy( ÃáSx Ãá= ÃáSy ‚Üíx Ãá= y),
(A3) ‚àÄx‚àÄy(x Ãá< ÃáSy ‚Üîx Ãá‚â§y),
(A4) ‚àÄx(x
Ã∏Ãá< Ãá0),
(A5) ‚àÄx‚àÄy(x Ãá< y ‚à®x Ãá= y ‚à®y Ãá< x),
(A6) ‚àÄx(x Ãá+ Ãá0 Ãá= x),
(A7) ‚àÄx‚àÄy(x Ãá+ ÃáSy Ãá= ÃáS(x Ãá+ y)),
(A8) ‚àÄx(x Ãá√ó Ãá0 Ãá= Ãá0),
(A9) ‚àÄx‚àÄy(x Ãá√ó ÃáSy Ãá= (x Ãá√ó y) Ãá+ x),
(A10) ‚àÄx( ÃáEx Ãá0 Ãá= ÃáS Ãá0),
(A11) ‚àÄx‚àÄy( ÃáEx ÃáSy Ãá= ÃáExy Ãá√ó x).
These 11 sentences shall be called the Œ©-axioms (Omega axioms).
Axioms (A1)‚Äì(A5) concern the successor operation and the less than relation. The
other six axioms, (A6)‚Äì(A11), relate to the steps used to generate the primitive recursive
operations of addition, multiplication, and exponentiation (see the proofs of Proposi-
tions 5.3.7, 5.3.9, and 5.3.11, respectively). Clearly, ùí©Û≥ÄÄÛ≥®êŒ©. Thus, Œ© is consistent by Corol-
lary 4.1.11. Let Œ£ be a set of ‚Ñí-sentences such that Œ© ‚äÜŒ£. If ùí©Û≥ÄÄÛ≥®êŒ£, then for any ‚Ñí-sentence
œÜ we know that Œ£ ‚ä¢œÜ implies ùí©Û≥ÄÄÛ≥®êœÜ, by the soundness theorem. Can we find a decidable
set Œ£ so that the converse implication holds?
We will now show that some basic sentences that are true in ùí©are deducible from
the Œ©-axioms. For any natural number n, to simplify the notation, we will let n denote
the ‚Ñí-term ÃáSn Ãá0, that is,
n = ÃáSn Ãá0 =
n times
‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû
ÃáS ÃáS ‚ãÖ‚ãÖ‚ãÖÃáS Ãá0.
(6.1)
So n + 1 = ÃáSn, 1 = ÃáS Ãá0, and 0 = Ãá0. The terms n are called numerals, and we have nùí©= n,
where nùí©is the term n interpreted in ùí©. Our next lemma shows that when n > 0, one
can deduce from Œ© that the only objects less than n are Ãá0, 1, 2, . . . , n ‚àí1. So in any model
of Œ©, the interpretation of the terms Ãá0, 1, 2, . . . are ordered like the standard natural num-
bers.

6.2 Basic axioms for number theory
‡±™
207
Lemma 6.2.2. For every natural number n > 0, we have
Œ© ‚ä¢x Ãá< n ‚Üî(x Ãá= Ãá0 ‚à®x Ãá= 1 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®x Ãá= n ‚àí1).
Proof. We shall use natural number induction on n.
Base step: Let n = 1. We must show that Œ© ‚ä¢(x
Ãá< 1 ‚Üîx
Ãá= Ãá0). Since 1 =
ÃáS Ãá0, we have
Œ© ‚ä¢x Ãá< 1 ‚Üîx Ãá‚â§Ãá0 by axiom (A3). Moreover, by axiom (A4), we see that Œ© ‚ä¢x Ãá‚â§Ãá0 ‚Üîx Ãá= Ãá0.
Therefore, Œ© ‚ä¢(x Ãá< 1 ‚Üîx Ãá= Ãá0).
Inductive step: Let n ‚àà‚Ñïbe such that n ‚â•1. Assume the induction hypothesis
Œ© ‚ä¢x Ãá< n ‚Üî(x Ãá= Ãá0 ‚à®x Ãá= 1 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®x Ãá= n ‚àí1).
(IH)
From the induction hypothesis we conclude that
Œ© ‚ä¢(x Ãá< n ‚à®x Ãá= n) ‚Üî(x Ãá= Ãá0 ‚à®x Ãá= 1 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®x Ãá= n ‚àí1 ‚à®x Ãá= n).
Since x Ãá‚â§n is an abbreviation for (x Ãá< n ‚à®x Ãá= n), axiom (A3) implies
Œ© ‚ä¢x Ãá< n + 1 ‚Üî(x Ãá= Ãá0 ‚à®x Ãá= 1 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®x Ãá= n).
Thus, any nonstandard ‚Äúnumber‚Äù x in a model of Œ© satisfies n Ãá< x for all n ‚àà‚Ñï.
We now introduce two more abbreviations. For any ‚Ñí-formula œÜ(x) and n > 0, we
let (‚àÄx
Ãá< n)œÜ(x) abbreviate the wff ‚àÄx(x
Ãá< n ‚ÜíœÜ(x)) and we let (‚àÉx
Ãá< n)œÜ(x) abbrevi-
ate the wff ‚àÉx(x
Ãá< n ‚àßœÜ(x)). The quantifiers (‚àÄx
Ãá< n) and (‚àÉx
Ãá< n) are called bounded
quantifiers.
Let œÜ1, œÜ2, œÜ3 be ‚Ñí-wffs. To show that Œ© ‚ä¢œÜ1 ‚ÜîœÜ2 and Œ© ‚ä¢œÜ2 ‚ÜîœÜ3, it can be more
illuminating to derive these consecutive results by using the vertical list
Œ© ‚ä¢œÜ1 ‚ÜîœÜ2
‚ÜîœÜ3
and thereby conclude that Œ© ‚ä¢œÜ1 ‚ÜîœÜ3. This will be done in the proof of Lemma 6.2.3.
Lemma 6.2.3. Let œÜ(x) be an ‚Ñí-formula. For any natural number n > 0,
(1) Œ© ‚ä¢(‚àÄx Ãá< n)œÜ(x) ‚Üî(œÜ( Ãá0) ‚àßœÜ(1) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßœÜ(n ‚àí1)),
(2) Œ© ‚ä¢(‚àÉx Ãá< n)œÜ(x) ‚Üî(œÜ( Ãá0) ‚à®œÜ(1) ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®œÜ(n ‚àí1)).
Proof. We now prove (1). We first observe that
Œ© ‚ä¢(‚àÄx Ãá< n)œÜ(x) ‚Üî‚àÄx(x Ãá< n ‚ÜíœÜ(x))
abbreviation,
‚Üî‚àÄx((x Ãá= Ãá0 ‚à®x Ãá= 1 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®x Ãá= n ‚àí1) ‚ÜíœÜ(x))
by Lemma 6.2.2,
‚Üî(œÜ( Ãá0) ‚àßœÜ(1) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßœÜ(n ‚àí1))
logical equivalence.

208
‡±™
6 Undecidability and incompleteness
As ‚àÄx((x
Ãá= Ãá0 ‚à®x
Ãá= 1 ‚à®‚ãÖ‚ãÖ‚ãÖ‚à®x
Ãá= n ‚àí1) ‚ÜíœÜ(x)) and (œÜ( Ãá0) ‚àßœÜ(1) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßœÜ(n ‚àí1)) are
logically equivalent, the completeness theorem justifies the above derivation. Therefore,
Œ© ‚ä¢(‚àÄx Ãá< n)œÜ(x) ‚Üî(œÜ( Ãá0) ‚àßœÜ(1) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßœÜ(n ‚àí1)). A similar argument proves (2).
The following lemma will be used to show that for every ‚Ñí-term t which contains
no variables, there is a natural number n such that Œ© ‚ä¢t Ãá= n.
Lemma 6.2.4. For all natural numbers m and n,
(1) Œ© ‚ä¢m Ãá+ n Ãá= m + n,
(2) Œ© ‚ä¢m Ãá√ó n Ãá= m √ó n,
(3) Œ© ‚ä¢ÃáE mn Ãá= mn.
Proof. Let m ‚àà‚Ñï. We will prove (1) by induction on n.
Base step: Let n = 0. We must show that Œ© ‚ä¢m
Ãá+ 0 Ãá= m + 0. By axiom (A6), we have
Œ© ‚ä¢m Ãá+ 0 Ãá= m. Therefore, Œ© ‚ä¢m Ãá+ 0 Ãá= m + 0, as m = m + 0.
Inductive step: Let n ‚àà‚Ñïbe arbitrary. Assume the induction hypothesis
Œ© ‚ä¢m Ãá+ n Ãá= m + n.
(IH)
We need to prove that Œ© ‚ä¢m Ãá+ n + 1 Ãá= m + n + 1. Since n + 1 =
ÃáSn, axiom (A7) implies
that Œ© ‚ä¢m
Ãá+ n + 1
Ãá= ÃáS(m
Ãá+ n). From the induction hypothesis (IH), we conclude that
Œ© ‚ä¢m Ãá+ n + 1 Ãá= ÃáS(m + n). As ÃáS(m + n) = m + n + 1, we see that
Œ© ‚ä¢m Ãá+ n + 1 Ãá= m + n + 1.
The proofs of (2) and (3) follow in a similar manner using axioms (A8)‚Äì(A9) and
(A10)‚Äì(A11), respectively.
We now show that Œ©-axioms ‚Äúagree‚Äù with ùí©about equality.
Lemma 6.2.5. For all natural numbers m and n,
(1) if m = n, then Œ© ‚ä¢m Ãá= n;
(2) if m
Ã∏= n, then Œ© ‚ä¢m
Ã∏Ãá= n.
Proof. For (1), if m = n, then the terms m and n are identical, that is, m = n. Hence,
Œ© ‚ä¢m Ãá= n. The proof of (2) is by the following induction on n.
Base step: Let n = 0 and assume that m
Ã∏= 0. We must show that Œ© ‚ä¢m
Ã∏Ãá= 0. Since m
Ã∏= 0,
there is an x ‚àà‚Ñïsuch that m = x + 1. Thus, m = ÃáS x. Axiom (A1) implies that Œ© ‚ä¢ÃáS x
Ã∏Ãá= Ãá0.
Thus, Œ© ‚ä¢m
Ã∏Ãá= 0.
Inductive step: Let n ‚àà‚Ñïbe arbitrary. Assume the induction hypothesis
for all m ‚àà‚Ñï, if m
Ã∏= n, then Œ© ‚ä¢m
Ã∏Ãá= n.
(IH)

6.2 Basic axioms for number theory
‡±™
209
Let m ‚àà‚Ñïbe such that m
Ã∏= n + 1. We prove that Œ© ‚ä¢m Ã∏Ãá= n + 1. If m = 0, then m = Ãá0 and
Œ© ‚ä¢ÃáSn
Ã∏Ãá= Ãá0 by axiom (A1). Thus, Œ© ‚ä¢m
Ã∏Ãá= n + 1. If m > 0, then m = x + 1 for some x ‚àà‚Ñï.
So m = ÃáS x and x
Ã∏= n. The induction hypothesis (IH) implies that Œ© ‚ä¢x
Ã∏Ãá= n. Axiom (A2)
now implies that Œ© ‚ä¢ÃáS x
Ã∏Ãá= ÃáSn, that is, Œ© ‚ä¢m
Ã∏Ãá= n + 1.
Lemma 6.2.6. For each variable-free ‚Ñí-term t, there is a unique n ‚àà‚Ñïsuch that Œ© ‚ä¢t Ãá=n.
Proof. Uniqueness follows from Lemma 6.2.5(2). We use induction on terms to prove
that for all terms t‚àó,
if t‚àóis variable-free, then Œ© ‚ä¢t‚àóÃá= n, for some natural number n.
(6.2)
Base step: t‚àó= Ãá0. Since 0 = Ãá0, we clearly have Œ© ‚ä¢Ãá0 Ãá= 0.
Inductive step: Let t and œÑ be variable-free ‚Ñí-terms. Assume the induction hypothesis
Œ© ‚ä¢t Ãá= k
and
Œ© ‚ä¢œÑ Ãá= m,
(IH)
for k, m ‚àà‚Ñï. We must prove that (6.2) holds for each of the variable-free terms
ÃáSt, t Ãá+ œÑ, t Ãá√ó œÑ,
ÃáEtœÑ.
Since Œ© ‚ä¢t Ãá= k, we have Œ© ‚ä¢ÃáSt Ãá= ÃáS k. Thus, as ÃáS k = k + 1, Œ© ‚ä¢ÃáSt Ãá= k + 1. The induction
hypothesis (IH) implies that Œ© ‚ä¢t Ãá+ œÑ Ãá= k Ãá+ m. So, by Lemma 6.2.4(1), Œ© ‚ä¢t Ãá+ œÑ Ãá= k + m.
The argument for the terms t Ãá√ó œÑ and ÃáEtœÑ is similar.
The Œ©-axioms also ‚Äúagree‚Äù with ùí©about inequality.
Lemma 6.2.7. For all natural numbers n and m,
(1) if m < n, then Œ© ‚ä¢m Ãá< n,
(2) if m
Ã∏< n, then Œ© ‚ä¢m
Ã∏Ãá< n.
Proof. The proofs of both conditionals (1) and (2) are by induction on n.
(1) Let m ‚àà‚Ñï. We prove the above item (1) by the following induction on n.
Base step: Let n = 0. In this case, the conditional (1) is vacuously true.
Inductive step: Let n ‚àà‚Ñïbe arbitrary. Assume the induction hypothesis
if m < n,
then Œ© ‚ä¢m Ãá< n.
(IH)
Assume that m < n + 1. So either m < n or m = n. By the induction hypothesis and
Lemma 6.2.5(1), we have either Œ© ‚ä¢m Ãá< n or Œ© ‚ä¢m Ãá= n. Hence,
Œ© ‚ä¢(m Ãá< n ‚à®m Ãá= n).
So Œ© ‚ä¢m Ãá‚â§n. Axiom (A3) implies that Œ© ‚ä¢m Ãá< ÃáSn. Therefore, Œ© ‚ä¢m Ãá< n + 1.

210
‡±™
6 Undecidability and incompleteness
(2) Let m ‚àà‚Ñï. We now prove the above item (2) by induction.
Base step: Let n = 0. Axiom (A4) implies that Œ© ‚ä¢m
Ã∏Ãá< Ãá0. So (2) holds for n = 0.
Inductive step: Let n ‚àà‚Ñïbe arbitrary. Assume the induction hypothesis
if m
Ã∏< n,
then Œ© ‚ä¢m
Ã∏Ãá< n.
(IH)
Assume that m
Ã∏< n + 1. Thus, m
Ã∏< n and m
Ã∏= n. By the induction hypothesis and
Lemma 6.2.5(2), we have Œ© ‚ä¢m
Ã∏Ãá< n and Œ© ‚ä¢m
Ã∏Ãá= n. Hence,
Œ© ‚ä¢(m
Ã∏Ãá< n ‚àßm
Ã∏Ãá= n).
So Œ© ‚ä¢¬¨(m Ãá< n ‚à®m Ãá= n) (De Morgan‚Äôs law), that is, Œ© ‚ä¢¬¨(m Ãá‚â§n). Axiom (A3) implies
that Œ© ‚ä¢¬¨(m Ãá< ÃáS n), that is, Œ© ‚ä¢m
Ã∏Ãá< n + 1.
Lemmas 6.2.5‚Äì6.2.7 imply a partial answer to question (Q2) posed on page 205.
Theorem 6.2.8. For every quantifier-free sentence œÜ,
(1) if ùí©Û≥ÄÄÛ≥®êœÜ, then Œ© ‚ä¢œÜ,
(2) if ùí©Û≥ÄÄÛ≥®ê¬¨œÜ, then Œ© ‚ä¢¬¨œÜ.
Proof. The proof is by induction on the construction of the quantifier-free sentences as
outlined in Exercise 2.
An existential sentence has the form ‚àÉx1 ‚ãÖ‚ãÖ‚ãÖ‚àÉxnŒ∏, where Œ∏ is quantifier-free. Our
next result is an extension of Theorem 6.2.8.
Corollary 6.2.9. Let œÜ be an existential sentence. If ùí©Û≥ÄÄÛ≥®êœÜ, then Œ© ‚ä¢œÜ.
Proof. Let œÜ be an existential sentence of the form ‚àÉxŒ±, where Œ± is quantifier-free. Sup-
pose that ùí©Û≥ÄÄÛ≥®ê‚àÉxŒ±. Thus, for some natural number n, we have ùí©Û≥ÄÄÛ≥®êŒ±x
n. Since Œ±x
n is
a quantifier-free sentence, Theorem 6.2.8 implies that Œ© ‚ä¢Œ±x
n. Exercise 10 on page 117
implies that Œ© ‚ä¢Œ±x
n ‚Üí‚àÉxŒ±. Thus, Œ© ‚ä¢‚àÉxŒ±. One can now extend this argument, by
induction, to existential sentences with more than one such quantifier.
Corollary 6.2.9 does not hold, in general, for the negation of an existential sentence.
Exercises 6.1.
1. Let m, n ‚àà‚Ñï. Show that if Œ© ‚ä¨m Ãá< n, then Œ© ‚ä¢(m Ãá= n ‚à®n Ãá< m).
*2. Let t and œÑ be variable-free terms in the language ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=}. Prove
Theorem 6.2.8 by induction as follows:
Base step:
(a) Show that if ùí©Û≥ÄÄÛ≥®êt Ãá= œÑ, then Œ© ‚ä¢t Ãá= œÑ.
(b) Show that if ùí©Û≥ÄÄÛ≥®êt
Ã∏Ãá= œÑ, then Œ© ‚ä¢t
Ã∏Ãá= œÑ.
(c) Show that if ùí©Û≥ÄÄÛ≥®êt Ãá< œÑ, then Œ© ‚ä¢t Ãá< œÑ.
(d) Show that if ùí©Û≥ÄÄÛ≥®êt
Ã∏Ãá< œÑ, then Œ© ‚ä¢t
Ã∏Ãá< œÑ.

6.3 Representable relations and functions
‡±™
211
Inductive step: Let œÜ and œà be quantifier-free sentences. Assume the following:
(a) If ùí©Û≥ÄÄÛ≥®êœÜ, then Œ© ‚ä¢œÜ.
(b) If ùí©Û≥ÄÄÛ≥®ê¬¨œÜ, then Œ© ‚ä¢¬¨œÜ.
(c) If ùí©Û≥ÄÄÛ≥®êœà, then Œ© ‚ä¢œà.
(d) If ùí©Û≥ÄÄÛ≥®ê¬¨œà, then Œ© ‚ä¢¬¨œà.
Let ÃÉœÜ ‚àà{œÜ, ¬¨œÜ} and œà ‚àà{œà, ¬¨œà}. Show the following:
‚Äì
If ùí©Û≥ÄÄÛ≥®ê(ÃÉœÜ ‚Üíœà), then Œ© ‚ä¢(ÃÉœÜ ‚Üíœà),
‚Äì
If ùí©Û≥ÄÄÛ≥®ê¬¨(ÃÉœÜ ‚Üíœà), then Œ© ‚ä¢¬¨(ÃÉœÜ ‚Üíœà).
*3. Show that for all natural numbers n, Œ© ‚ä¢ÃáSn Ãá= Sn.
4. Show that there is a formula œÜ(x, y) such that for all m, n ‚àà‚Ñï, m | n if and only if
Œ© ‚ä¢œÜ(m, n).
5. Prove Proposition 6.2.4(2).
6. Prove Proposition 6.2.4(3).
7. Let œÜ(x) be an ‚Ñí-formula. Let n ‚àà‚Ñï. Suppose that for all k < n + 1, Œ© ‚ä¢œÜ(k). Show
that Œ© ‚ä¢(‚àÄx < n + 1)œÜ(x).
8. Show that Œ© ‚ä¢m Ãá+ n Ãá= n Ãá+ m, for all m, n ‚àà‚Ñï.
9. Show that Œ© ‚ä¢n Ãá< n Ãá+ 1, for all n ‚àà‚Ñï.
10. Let œÜ(x) be an ‚Ñí-formula. Show that if Œ© ‚ä¢œÜ(4), then Œ© ‚ä¢(‚àÉx < 44)œÜ(x).
11. Let œÜ(x) be an ‚Ñí-formula. Show that if Œ© ‚ä¢¬¨œÜ(2), then Œ© ‚ä¢¬¨(‚àÄx < 4)œÜ(x).
6.3 Representable relations and functions
Again, let ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} be the language for elementary number theory and
let Œ© be the basic axioms of number theory. In this section, we present a concept called
representability, which shows that recursive functions and relations can be represented
by formulas that can be deduced from the Œ©-axioms. In Section 6.2, we have already
shown that the relation < and the operations + and √ó, when applied to specific natural
numbers, can be interpreted as ‚Ñí-sentences that are deducible from Œ©. In particular,
Lemma 6.2.7 shows that if m < n, then Œ© ‚ä¢m Ãá< n, where m Ãá< n is an atomic sentence.
Moreover, Propositions 5.3.23, 5.3.7, and 5.3.9 show that <, +, and √ó are all recursive. In
this section, we will show that these results can be extended to include all recursive
relations and functions.
We will use the notation Œ∏(x1, x2, . . . , xk) to indicate that the free variables in the wff
Œ∏ are among the distinct variables x1, x2, . . . , xk. Moreover, the notation Œ∏(n1, n2, . . . , nk)
will be used to denote the result of substituting the free variables in Œ∏ with the corre-
sponding terms n1, n2, . . . , nk where we let ni = ÃáSni Ãá0 for i = 1, . . . , k, that is, we let
Œ∏(n1, n2, . . . , nk) = Œ∏x1‚ãÖ‚ãÖ‚ãÖxk
n1‚ãÖ‚ãÖ‚ãÖnk.
Similarly, for a term œÑ, the notation œÑ(x1, x2, . . . , xk) will be used to indicate that the vari-
ables which appear in œÑ are among the distinct variables x1, x2, . . . , xk. We will also let

212
‡±™
6 Undecidability and incompleteness
œÑ(n1, n2, . . . , nk) = œÑx1‚ãÖ‚ãÖ‚ãÖxk
n1‚ãÖ‚ãÖ‚ãÖnk,
that is, œÑ(n1, n2, . . . , nk) is the result of replacing the variables x1, x2, . . . , xk in œÑ with the
respective terms n1, n2, . . . , nk (see Exercise 11 on page 65).
Definition 6.3.1. A relation R
‚äÜ
‚Ñïk is representable if there exists an ‚Ñí-formula
œÜ(x1, x2, . . . , xk) such that for all n1, n2, . . . , nk ‚àà‚Ñï,
(1) if ‚ü®n1, n2, . . . , nk‚ü©‚ààR, then Œ© ‚ä¢œÜ(n1, n2, . . . , nk),
(2) if ‚ü®n1, n2, . . . , nk‚ü©‚àâR, then Œ© ‚ä¢¬¨œÜ(n1, n2, . . . , nk).
When (1) and (2) hold, we shall say that œÜ represents the relation R.
Lemma 6.2.7 shows that the formula x1
Ãá< x2 represents the relation <. Similarly,
Lemma 6.2.5 implies that the relation = is representable.
The representability concept bears resemblance to that of definability over ùí©. How-
ever, definability over ùí©involves truth in the structure ùí©. Representability, on the other
hand, involves deductions from the Œ©-axioms. Nevertheless, in our next lemma we es-
tablish a connection between representability and definability over ùí©.
Definition 6.3.2. Let œÜ(x1, x2, . . . , xk) be an ‚Ñí-well-formed formula (‚Ñí-wff) where all of
the free variables in œÜ are among x1, x2, . . . , xk. We say that œÜ is numeralwise determined
if for all natural numbers n1, n2, . . . , nk, we have either
Œ© ‚ä¢œÜ(n1, n2, . . . , nk),
or
Œ© ‚ä¢¬¨œÜ(n1, n2, . . . , nk).
(6.3)
The following lemma shows that a relation is representable if the relation is defin-
able over ùí©by means of a formula that is numeralwise determined. First observe that
if œÜ(x1, . . . , xk) is numeralwise determined and ùí©Û≥ÄÄÛ≥®êœÜ(n1, . . . , nk), then it follows that
Œ© ‚ä¢œÜ(n1, . . . , nk). Otherwise, Definition 6.3.2 would imply that Œ© ‚ä¢¬¨œÜ(n1, . . . , nk) and
hence, ùí©Û≥ÄÄÛ≥®ê¬¨œÜ(n1, . . . , nk) as ùí©Û≥ÄÄÛ≥®êŒ©.
Lemma 6.3.3. A formula œÜ represents a relation R if and only if œÜ is numeralwise deter-
mined and œÜ defines R over ùí©.
Proof. Recall that (Û≥µ≥) ùí©Û≥ÄÄÛ≥®êŒ©. If œÜ represents R, then by Definition 6.3.1(1)(2) we see
that œÜ is numeralwise determined and, by the soundness theorem, œÜ defines R over ùí©.
Conversely, if (a) œÜ is numeralwise determined and (b) œÜ defines R over ùí©, then
‚ü®n1, n2, . . . , nk‚ü©‚ààR ‚áíùí©Û≥ÄÄÛ≥®êœÜ(n1, n2, . . . , nk)
by (b),
‚áíŒ© ‚ä¢œÜ(n1, n2, . . . , nk)
by (a), (6.3), and (Û≥µ≥).
Similarly, ‚ü®n1, n2, . . . , nk‚ü©‚àâR implies Œ© ‚ä¢¬¨œÜ(n1, n2, . . . , nk). So œÜ represents R.

6.3 Representable relations and functions
‡±™
213
So if a formula œÜ is numeralwise determined, then œÜ identifies a representable re-
lation. Our next result shows how one can take advantage of Lemma 6.3.3 to build new
representable relations from existing ones. Recall that (‚àÄx Ãá< y)œÜ and (‚àÉx Ãá< y)œÜ are the
abbreviated forms of ‚àÄx(x Ãá< y ‚ÜíœÜ) and ‚àÉx(x Ãá< y ‚àßœÜ), respectively.
Theorem 6.3.4. Let œÜ and œà be ‚Ñí-wffs.
(1) If œÜ is an atomic formula, then œÜ is numeralwise determined.
(2) If œÜ and œà are numeralwise determined, then so are ¬¨œÜ and œÜ ‚Üíœà.
(3) If œÜ is numeralwise determined, then so are (‚àÄx Ãá< y)œÜ and (‚àÉx Ãá< y)œÜ.
Proof. Let œÜ and œà be wffs in the language ‚Ñí.
(1) Let œÜ be the atomic formula t Ãá< œÑ, where t and œÑ are both terms. Let n1, n2, . . . , nk be
natural numbers. Theorem 6.2.8 implies that either
Œ© ‚ä¢t(n1, n2, . . . , nk) Ãá< œÑ(n1, n2, . . . , nk),
or
Œ© ‚ä¢t(n1, n2, . . . , nk)
Ã∏Ãá< œÑ(n1, n2, . . . , nk).
Similarly, if œÜ is the atomic formula t Ãá= œÑ, then Theorem 6.2.8 implies that either
Œ© ‚ä¢t(n1, n2, . . . , nk) Ãá= œÑ(n1, n2, . . . , nk),
or
Œ© ‚ä¢t(n1, n2, . . . , nk)
Ã∏Ãá= œÑ(n1, n2, . . . , nk).
(2) See Exercise 4.
(3) Let œÜ(x, y, x1, . . . , xk) be numeralwise determined. Let n, n1, n2, . . . , nk be natural
numbers and let ÃÉœÜ(x) denote the wff œÜ(x, n, n1, n2, . . . , nk). If n = 0, then one can
show that
Œ© ‚ä¢(‚àÄx Ãá< Ãá0)ÃÉœÜ(x)
and
Œ© ‚ä¢¬¨(‚àÉx Ãá< Ãá0)ÃÉœÜ(x).
So let n > 0. We first show that either
Œ© ‚ä¢(‚àÄx Ãá< n)ÃÉœÜ(x),
or
Œ© ‚ä¢¬¨(‚àÄx Ãá< n)ÃÉœÜ(x).
By Lemma 6.2.2, there are two cases two consider.
Case 1: For every m < n, we have Œ© ‚ä¢ÃÉœÜ(m). In this case, Lemma 6.2.3(1) implies that
Œ© ‚ä¢(‚àÄx Ãá< n)ÃÉœÜ(x).
Case 2: For some m < n, we have Œ© ‚ä¨ÃÉœÜ(m). Since œÜ is numeralwise determined,
we conclude that Œ© ‚ä¢¬¨ÃÉœÜ(m). Lemma 6.2.3(1) now implies that Œ© ‚ä¢¬¨(‚àÄx
Ãá< n)ÃÉœÜ(x).
Using Lemma 6.2.3(2), one can similarly prove that (‚àÉx
Ãá< y)œÜ is also numeralwise
determined.

214
‡±™
6 Undecidability and incompleteness
Theorem 6.3.4 is a useful tool for showing that many relations are representable.
Let œÜ(v) be the formula
ÃáS Ãá0 Ãá< v ‚àß(‚àÄx Ãá< v)(‚àÄy Ãá< v)(x Ãá√ó y
Ã∏Ãá= v).
Theorem 6.3.4 implies that œÜ(v) is numeralwise determined. Since œÜ(v) defines the set
of primes in ùí©, Lemma 6.3.3 shows that the set of primes is representable.
Definition 6.3.5. A function f : ‚Ñïk ‚Üí‚Ñïis said to be functionally representable if there
is an ‚Ñí-formula œÜ(x1, x2, . . . , xk, v) such that for all n1, n2, . . . , nk ‚àà‚Ñï,
Œ© ‚ä¢‚àÄv(œÜ(n1, n2, . . . , nk, v) ‚Üîv Ãá= f (n1, n2, . . . , nk)).
(6.4)
When (6.4) holds, we will say that œÜ functionally represents f .
Remark 6.3.6. Let f satisfy (6.4). Thus,
Œ© ‚ä¢‚àÄv(v Ãá= f (n1, n2, . . . , nk) ‚ÜíœÜ(n1, n2, . . . , nk, v)),
(6.5)
Œ© ‚ä¢‚àÄv(œÜ(n1, n2, . . . , nk, v) ‚Üív Ãá= f (n1, n2, . . . , nk)).
(6.6)
The above (6.5) implies that
Œ© ‚ä¢œÜ(n1, n2, . . . , nk, f (n1, n2, . . . , nk)),
and therefore Œ© ‚ä¢‚àÉvœÜ(n1, n2, . . . , nk, v). Thus, (6.5) and (6.6) imply that
Œ© ‚ä¢‚àÉ!vœÜ(n1, n2, . . . , nk, v),
where ‚àÉ! is the uniqueness quantifier (see page 22).
The substitution property of equality asserts that if two quantities are equal, then
one can replace one with the other. Theorem 3.3.54 shows that this substitution property
is formally deducible. Thus, Lemma 6.2.4(1) and Theorem 3.3.54 imply that
Œ© ‚ä¢‚àÄv(m Ãá+ n Ãá= v ‚Üîv Ãá= m + n)
for all m, n ‚àà‚Ñï. Let œÜ(x1, x2, v) be the ‚Ñí-formula x1 Ãá+ x2 Ãá= v. Thus, the particular formula
œÜ(x1, x2, v) is an equation and functionally represents +, that is, it represents the func-
tion f : ‚Ñï2 ‚Üí‚Ñïdefined by f (x1, x2) = x1 + x2. Furthermore, Lemma 6.2.4 and Exercise 3
on page 211 imply that the three equational formulas x1
Ãá√ó x2
Ãá= v, ÃáEx1x2
Ãá= v, and ÃáSx1 Ãá= v
functionally represent the operations √ó, E, and S, respectively. These four examples mo-
tivate a generalization. Again, œÑ(x1, x2, . . . , xk) denotes a term whose variables, if any, are
among x1, x2, . . . , xk.

6.3 Representable relations and functions
‡±™
215
Lemma 6.3.7. Let œÑ(x1, x2, . . . , xk) be an ‚Ñí-term and define fœÑ: ‚Ñïk ‚Üí‚Ñïby
fœÑ(n1, n2, . . . , nk) = the unique n such that Œ© ‚ä¢(œÑ(n1, n2, . . . , nk) Ãá= n).
Then the equational formula œÑ(x1, x2, . . . , xk) Ãá= v functionally represents fœÑ.
Proof. Let n1, n2, . . . , nk ‚àà‚Ñï. Lemma 6.2.6 implies that there exists a unique n ‚àà‚Ñïsuch
that Œ© ‚ä¢œÑ(n1, n2, . . . , nk) = n. Thus, by definition of fœÑ, n = fœÑ(n1, n2, . . . , nk). Therefore,
Œ© ‚ä¢œÑ(n1, n2, . . . , nk) Ãá= fœÑ(n1, n2, . . . , nk), and this implies that
Œ© ‚ä¢‚àÄv(œÑ(n1, n2, . . . , nk) Ãá= v ‚Üîv Ãá= fœÑ(n1, n2, . . . , nk)).
Hence, the equation œÑ(x1, x2, . . . , xk) Ãá= v functionally represents fœÑ.
Corollary 6.3.8. Let f : ‚Ñïk ‚Üí‚Ñïand let œÑ be a term so that for all n1, n2, . . . , nk, n ‚àà‚Ñï,
f (n1, n2, . . . , nk) = n
iff
ùí©Û≥ÄÄÛ≥®êœÑ(n1, n2, . . . , nk) Ãá= n.
(6.7)
Then the equational formula œÑ(x1, x2, . . . , xk) Ãá= v functionally represents f .
Proof. For all n1, n2, . . . , nk, n ‚àà‚Ñï, Theorems 6.2.8 and 4.1.5 imply that
ùí©Û≥ÄÄÛ≥®êœÑ(n1, n2, . . . , nk) Ãá= n
iff
Œ© ‚ä¢œÑ(n1, n2, . . . , nk) Ãá= n.
Thus, from (6.7), we conclude that
f (n1, n2, . . . , nk) = the unique n such that Œ© ‚ä¢(œÑ(n1, n2, . . . , nk) Ãá= n).
So, by Lemma 6.3.7, f = fœÑ and œÑ(x1, x2, . . . , xk) Ãá= v functionally represents f .
We now illustrate how to apply Corollary 6.3.8. Let f : ‚Ñï2 ‚Üí‚Ñïand œÑ be defined by
f (x1, x2) = S(x1) √ó x2
and
œÑ(x1, x2) = ÃáSx1 Ãá√ó x2.
Since f and œÑ satisfy condition (6.7) of Corollary 6.3.8, we conclude that the formula
œÑ(x1, x2) Ãá= v functionally represents f . For a second example, let f : ‚Ñï2 ‚Üí‚Ñïbe defined
by f (x1, x2) = 0 and let œÑ = Ãá0. Clearly, f and œÑ satisfy condition (6.7). Therefore, by Corol-
lary 6.3.8, the equational formula Ãá0 Ãá= v functionally represents f .
Corollary 6.3.9. The initial and constant functions are functionally representable.
Proof. Corollary 6.3.8 implies the following:
1.
The zero function Ãäf : ‚Ñïk ‚Üí‚Ñï, as defined by Ãäf (x1, . . . , xk) = 0, is functionally repre-
sented by the equational formula Ãá0 Ãá= v.
2.
For m ‚àà‚Ñï, the constant function mf : ‚Ñïk ‚Üí‚Ñï, defined by mf (x1, . . . , xk) = m, is
functionally represented by the equational formula m Ãá= v.
3.
The successor function S(x) is represented by the equational formula ÃáSx Ãá= v.

216
‡±™
6 Undecidability and incompleteness
4.
For all natural numbers 1 ‚â§i ‚â§k, the projection function Ik
i : ‚Ñïk ‚Üí‚Ñï, defined by
Ik
i (x1, . . . , xk) = xi, is functionally represented by the formula xi Ãá= v.
Corollary 6.3.8 therefore implies that many functions are represented by an equa-
tional formula. However, this is not true for all representable functions.
There is another natural notion that concerns the representability of a function.
Definition 6.3.10. A function f : ‚Ñïk ‚Üí‚Ñïis said to be graph representable if the graph
of f
Gf = {‚ü®n1, n2, . . . , nk, n‚ü©: f (n1, n2, . . . , nk) = n}
is representable as a relation, that is, there is a formula œÜ(x1, . . . , xk, x) such that for all
n1, n2, . . . , nk, n ‚àà‚Ñï,
(1) if f (n1, n2, . . . , nk) = n, then Œ© ‚ä¢œÜ(n1, n2, . . . , nk, n),
(2) if f (n1, n2, . . . , nk)
Ã∏= n, then Œ© ‚ä¢¬¨œÜ(n1, n2, . . . , nk, n).
It turns out that a function is functionally representable if and only if the function
is graph representable. However, the proof of this equivalence is a bit subtle. The next
lemma will be used to prove Theorem 6.3.12 below, which establishes this equivalence.
Lemma 6.3.11. Let f : ‚Ñïk ‚Üí‚Ñïand let n1, n2, . . . , nk ‚àà‚Ñï. Let œÜ(x1, . . . , xk, x) be such that
(1) and (2) of Definition 6.3.10 hold for all n ‚àà‚Ñï. If f (n1, n2, . . . , nk) = n, then
Œ© ‚ä¢œÜ(n1, n2, . . . , nk, n) ‚àß(‚àÄy Ãá< n)¬¨œÜ(n1, n2, . . . , nk, y).
(6.8)
Proof. Let n1, n2, . . . , nk ‚àà‚Ñïand f be as stated and let f (n1, n2, . . . , nk) = n. Therefore,
Œ© ‚ä¢œÜ(n1, n2, . . . , nk, n) by Definition 6.3.10(1). Let m < n. Thus, f (n1, n2, . . . , nk)
Ã∏= m.
Definition 6.3.10(2) implies that Œ© ‚ä¢¬¨œÜ(n1, n2, . . . , nk, m). Lemma 6.2.3 now implies that
Œ© ‚ä¢(‚àÄy Ãá< n)¬¨œÜ(n1, n2, . . . , nk, y). Hence, (6.8) holds.
Theorem 6.3.12. Let f : ‚Ñïk ‚Üí‚Ñï. Then f is functionally representable if and only if f is
graph representable.
Proof. Let f : ‚Ñïk ‚Üí‚Ñï.
(‚áí). Assume that f is functionally representable. By Definition 6.3.5, there exists an
‚Ñí-formula œÜ(x1, . . . , xk, v) such that for all n1, n2, . . . , nk ‚àà‚Ñï,
Œ© ‚ä¢‚àÄv(œÜ(n1, n2, . . . , nk, v) ‚Üîv Ãá= f (n1, n2, . . . , nk)).
By Logical axiom 3.3.17(2), we conclude that
Œ© ‚ä¢œÜ(n1, n2, . . . , nk, n) ‚Üîn Ãá= f (n1, n2, . . . , nk)
(6.9)

6.3 Representable relations and functions
‡±™
217
for all n1, n2, . . . , nk, n ‚àà‚Ñï. Lemma 6.2.5 and (6.9) now easily imply (1) and (2) of Defini-
tion 6.3.10. Therefore, f is graph representable.
(‚áê). Assume that f is graph representable. Let œÜ(x1, . . . , xk, x) be a formula that sat-
isfies (1) and (2) of Definition 6.3.10 for all n1, n2, . . . , nk, n ‚àà‚Ñï. We need to find a formula
Œ∏(x1, . . . , xk, v) such that for all n1, n2, . . . , nk ‚àà‚Ñï,
Œ© ‚ä¢‚àÄv(Œ∏(n1, n2, . . . , nk, v) ‚Üîv Ãá= f (n1, n2, . . . , nk)).
Let n1, n2, . . . , nk ‚àà‚Ñïbe arbitrary and let ÃÉœÜ(v) denote the ‚Ñí-wff œÜ(n1, n2, . . . , nk, v). Now
consider the formula
ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y),
which appears in (6.8) of Lemma 6.3.11 (where v replaces n). We will now show that
Œ© ‚ä¢‚àÄv((ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y)) ‚Üîv Ãá= f (n1, n2, . . . , nk)).
(6.10)
Let f (n1, n2, . . . , nk) = n. Since n and f (n1, n2, . . . , nk) are exactly the same term, we can
replace f (n1, n2, . . . , nk) in (6.10) with n. By Theorem 3.3.29 and the biconditional law, it
is now enough to show that
Œ© ‚ä¢(ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y)) ‚Üív Ãá= n,
(6.11)
Œ© ‚ä¢v Ãá= n ‚Üí(ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y)).
(6.12)
To establish (6.11), Theorem 3.3.33 implies that we just need to prove that
Œ© ‚à™{ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y)} ‚ä¢v Ãá= n.
(6.13)
To do this, we will first show that
Œ© ‚à™{ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y)} ‚ä¢v
Ã∏Ãá< n,
(6.14)
Œ© ‚à™{ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y)} ‚ä¢n
Ã∏Ãá< v.
(6.15)
Recall that (‚àÄy Ãá< v)¬¨ÃÉœÜ(y) is the abbreviated form of ‚àÄy(y Ãá< v ‚Üí¬¨ÃÉœÜ(y)). To verify (6.14),
we shall use Corollary 3.3.37. Let
Œì = Œ© ‚à™{ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y), v Ãá< n}.
We will show that Œì is inconsistent. By Lemma 6.3.11, we have
Œ© ‚ä¢(‚àÄy Ãá< n)¬¨ÃÉœÜ(y).

218
‡±™
6 Undecidability and incompleteness
Therefore, Œì ‚ä¢(‚àÄy Ãá<n)¬¨ÃÉœÜ(y). Since v Ãá<n is in Œì, we conclude that (Û≥µ≥) Œì ‚ä¢¬¨ÃÉœÜ(v). However,
as ÃÉœÜ(v) is in Œì, we also have Œì ‚ä¢ÃÉœÜ(v). This together with (Û≥µ≥) shows that Œì is inconsistent.
Therefore, (6.14) holds by Corollary 3.3.37.
We now prove (6.15). By Lemma 6.3.11, we have (Û≥∂É) Œ© ‚ä¢ÃÉœÜ(n). Let
Œì‚àó= Œ© ‚à™{ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y), n Ãá< v}.
So Œì‚àó‚ä¢¬¨ÃÉœÜ(n) and Œì‚àóis inconsistent by (Û≥∂É). Hence, (6.15) is confirmed. Axiom (A5), to-
gether with (6.14) and (6.15), establishes (6.13), that is,
Œ© ‚à™{ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y)} ‚ä¢v Ãá= n.
To prove (6.12), we only need to show that
Œ© ‚à™{v Ãá= n} ‚ä¢ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y).
Lemma 6.3.11 implies that Œ© ‚ä¢ÃÉœÜ(n) ‚àß(‚àÄy Ãá< n)¬¨ÃÉœÜ(y). Hence, by Exercise 7 on page 135,
Œ© ‚à™{v Ãá= n} ‚ä¢ÃÉœÜ(v) ‚àß(‚àÄy Ãá< v)¬¨ÃÉœÜ(y). Therefore, f is functionally representable.
By Theorem 6.3.12, we can now say that a function f is representable to mean that f is
functionally representable and/or graph representable. The next theorem summarizes
some of the observations made in this section.
Theorem 6.3.13. The relations < and = and the functions +, √ó, E, and S defined on the
natural numbers are all representable.
We end this section by proving that all representable relations give rise to repre-
sentable functions.
Theorem 6.3.14. Let R ‚äÜ‚Ñïk be a relation. Then R is representable if and only if its char-
acteristic function CR is representable.
Proof. Let R ‚äÜ‚Ñïk be a relation.
(‚áí). Assume the relation R is representable. By Definition 6.3.1, let œÜ(x1, . . . , xk)
represent R. Thus, (Û≥µ≥) œÜ is numeralwise determined and (Û≥∂É) œÜ defines R over ùí©, by
Lemma 6.3.3. We will show that CR is graph representable. Let œà be the ‚Ñí-wff
(œÜ(x1, . . . , xk) ‚àßv Ãá= 1 ) ‚à®(¬¨œÜ(x1, . . . , xk) ‚àßv Ãá= Ãá0).
(6.16)
Clearly, by (Û≥∂É), the formula œà defines the graph of CR over ùí©. Moreover, by (Û≥µ≥), œà is
numeralwise determined (see Exercises 1 and 1). Therefore, by Lemma 6.3.3, CR is graph
representable.
(‚áê). Assume CR is representable. So let Œ∏(x1, . . . , xk, v) be a formula that verifies that
CR is graph representable. The formula Œ∏(x1, . . . , xk, 1) thus represents R.

6.3 Representable relations and functions
‡±™
219
6.3.1 Recursive relations and functions are representable
We have shown that the initial functions are representative (see Corollary 6.3.9). So,
to prove that every recursive function is representable, we need to prove that the set
of all representable functions is closed under composition, total search, and primitive
recursion.
Theorem 6.3.15. The composition of representable functions is representable.
Proof. Let g1, . . . , gj be functionally representable functions from ‚Ñïk to ‚Ñïand let
f : ‚Ñïj ‚Üí‚Ñïbe functionally representable. We will show that the composition
f (g1(x1, . . . , xk), . . . , gj(x1, . . . , xk))
is functionally representable. Let Œ∏1(x1, . . . , xk, v1), . . . , Œ∏j(x1, . . . , xk, vj) functionally rep-
resent g1, . . . gj, respectively. Thus, for each i, where 1 ‚â§i ‚â§j, we have
Œ© ‚ä¢‚àÄvi(Œ∏i(n1, . . . , nk, vi) ‚Üîvi Ãá= gi(n1, . . . , nk)),
for all n1, . . . , nk ‚àà‚Ñï.
(6.17)
Also let œà(x1, . . . , xj, v) functionally represent f , that is,
Œ© ‚ä¢‚àÄv(œà(n1, . . . , nj, v) ‚Üîv Ãá= f (n1, . . . , nj)),
for all n1, . . . , nj ‚àà‚Ñï.
(6.18)
Remark 6.3.6 shows that (6.17) implies, for each i, that Œ© ‚ä¢‚àÉ!viŒ∏i(n1, n2, . . . , nk, vi), that is,
there is exactly one such vi, namely, gi(n1, . . . , nk). Now let œÜ(x1, . . . , xk, v) be the formula
‚àÉv1 ‚ãÖ‚ãÖ‚ãÖ‚àÉvj(Œ∏1(x1, . . . , xk, v1) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ∏j(x1, . . . , xk, vj) ‚àßœà(v1, . . . , vj, v)).
Since (6.17) holds for each i, where 1 ‚â§i ‚â§j, and (6.18) holds, it follows that each of the
following successive biconditionals are deducible from Œ©:
œÜ(n1, . . . , nk, v)
‚Üî‚àÉv1 ‚ãÖ‚ãÖ‚ãÖ‚àÉvj(Œ∏1(n1, . . . , nk, v1) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßŒ∏j(n1, . . . , nk, vj) ‚àßœà(v1, . . . , vj, v))
‚Üî‚àÉv1 ‚ãÖ‚ãÖ‚ãÖ‚àÉvj(v1 Ãá= g1(n1, . . . , nk) ‚àß‚ãÖ‚ãÖ‚ãÖ‚àßvj Ãá= gj(n1, . . . , nk) ‚àßœà(v1, . . . , vj, v))
‚Üîœà(g1(n1, . . . , nk), . . . , gj(n1, . . . , nk), v)
‚Üîv Ãá= f (g1(n1, . . . , nk), . . . , gj(n1, . . . , nk)).
Therefore,
Œ© ‚ä¢‚àÄv(œÜ(n1, . . . , nk, v) ‚Üîv Ãá= f (g1(n1, . . . , nk), . . . , gj(n1, . . . , nk))).
Hence, the composition is functionally representable.

220
‡±™
6 Undecidability and incompleteness
Theorems 6.3.15 and 6.3.14 imply that representable relations are also closed under
composition with representable functions.
Theorem 6.3.16. Let g1, . . . , gj be representable functions from ‚Ñïk to ‚Ñïand let R ‚äÜ‚Ñïj be
representable. Then the relation S ‚äÜ‚Ñïk defined by
S(x1, x2, . . . , xk)
iff
R(g1(x1, . . . , xk), . . . , gj(x1, . . . , xk))
is representable.
Corollary 6.3.9 confirms that the projection functions are representable. Therefore,
by Theorem 6.3.15, one can compose a representable function with a projection function
and thereby obtain a representable function. Theorems 6.3.15 and 6.3.16 assume that the
functions g1, . . . , gj have the same arity. However, the projection functions can be used
to circumvent this apparent rigidity. By applying compositions with various projection
functions, one can apply Theorems 6.3.15 and 6.3.16 when the functions g1, . . . , gj have
different arity. For example, let f : ‚Ñï2 ‚Üí‚Ñïand let g1: ‚Ñï2 ‚Üí‚Ñïand g2: ‚Ñï‚Üí‚Ñï. Then the
function
h(a, b) = f (g1(a, b), g2(b))
can be obtained by a composition with a projection function, namely,
h(a, b) = f (g1(a, b), g2(I2
2(a, b))).
We have now shown that the set of representable functions contains all of the initial
functions and is also closed under composition. The next theorem shows that the set of
representable functions is closed under the total search operation (see Definition 5.3.5).
Upon completing its proof, we will be closer to showing that all recursive functions are
representable. To complete this task, we will need to show that the set of representable
functions is closed under primitive recursion.
Theorem 6.3.17. Let g: ‚Ñïk+1 ‚Üí‚Ñïbe representable. Suppose that for all ‚Éóx ‚àà‚Ñïk, there is
a y ‚àà‚Ñïsuch that g( ‚Éóx, y) = 0. Then the function h: ‚Ñïk ‚Üí‚Ñïdefined by
h( ‚Éóx) = Œºy(g( ‚Éóx, y) = 0)
is representable.
Proof. We will show that h is graph representable. Let œà( ‚Éóx, y, z) affirm that g is graph
representable. Since
h( ‚Éóx) = the least y such that g( ‚Éóx, y) = 0,
we see that

6.3 Representable relations and functions
‡±™
221
h( ‚Éóx) = y
iff
g( ‚Éóx, y) = 0 ‚àß(‚àÄv < y)g( ‚Éóx, v)
Ã∏= 0.
(6.19)
Now let Œ∏( ‚Éóx, y) be the ‚Ñí-wff
œà( ‚Éóx, y, Ãá0) ‚àß(‚àÄv Ãá< y)¬¨œà( ‚Éóx, v, Ãá0).
This wff Œ∏( ‚Éóx, y) formalizes the right hand side of (6.19) and thus defines the graph of
h over ùí©. Since œà is representable, Theorem 6.3.4 implies that Œ∏( ‚Éóx, y) is numeralwise
determined. Therefore, the graph of h is representable by Lemma 6.3.3.
Corollary 6.3.18. Let R ‚äÜ‚Ñïk+1 be a representable relation. Suppose that for all ‚Éóx ‚àà‚Ñïk
there is a y ‚àà‚Ñïsuch that R( ‚Éóx, y). Then the function f : ‚Ñïk ‚Üí‚Ñïdefined by
f ( ‚Éóx) = the least y ‚àà‚Ñïsuch that R( ‚Éóx, y)
(6.20)
is representable. Moreover, R( ‚Éóx, f ( ‚Éóx)) for all ‚Éóx ‚àà‚Ñïk.
Proof. Let R ‚äÜ‚Ñïk+1 be a representable relation. Let R = ‚Ñïk+1 \ R. By Exercise 2 and
Theorem 6.3.14, the characteristic function CR is representable. Since for all
‚Éóx ‚àà‚Ñïk
there is a y ‚àà‚Ñïsuch that R( ‚Éóx, y), the function f : ‚Ñïk ‚Üí‚Ñïdefined by (6.20) satisfies
f ( ‚Éóx) = Œºy(CR( ‚Éóx, y) = 0). Thus, f is representable by Theorem 6.3.17. In addition, R( ‚Éóx, f ( ‚Éóx))
for all ‚Éóx ‚àà‚Ñïk.
Recall that prime numbers and exponents are very useful for coding finite se-
quences of natural numbers. In Section 5.3, we showed how to encode any finite se-
quence ‚ü®x0, x1, . . . , xk‚ü©of natural numbers by a single natural number which is denoted
by [x0, x1, . . . , xk] (see (5.9) on page 190). Any such natural number is called a sequence
number. To show that representable functions are closed under primitive recursion,
we will show that there exists a representable function that can decode any sequence
number. We first formally repeat an observation that was made earlier.
Proposition 6.3.19. The set of prime numbers is a representable set.
Proof. Let œÄ(v) be the formula
ÃáS Ãá0 Ãá< v ‚àß(‚àÄx Ãá< v)(‚àÄy Ãá< v)(x Ãá√ó y
Ã∏Ãá= v).
(6.21)
Theorem 6.3.4 implies that œÄ(v) is numeralwise determined. Since œÄ(v) defines the set
of primes in ùí©, Lemma 6.3.3 shows that the set of primes is representable.
Two prime numbers x and y are said to be adjacent primes when x < y and no other
prime number is strictly between x and y.
Proposition 6.3.20. Let R = {‚ü®x, y‚ü©‚àà‚Ñï2 : x and y are adjacent primes}. Then R is repre-
sentable.

222
‡±™
6 Undecidability and incompleteness
Proof. Let œÄ(v) be the formula (6.21) in the above proof that represents the set of prime
numbers. Let Œ±(x, y) be the formula
œÄ(x) ‚àßœÄ(y) ‚àß(‚àÄz Ãá< y)((x Ãá< z ‚àßz Ãá< y) ‚Üí¬¨œÄ(z)).
Clearly, Œ±(x, y) defines the relation R over ùí©. Proposition 6.3.19, Theorem 6.3.4, and
Lemma 6.3.3 imply that Œ±(x, y) represents R.
For each x ‚àà‚Ñï, let px be the (x + 1)-st prime number and let g: ‚Ñï‚Üí‚Ñïbe defined
by g(x) = px. In the proof of Proposition 5.3.36, the function g is defined by primitive
recursion. Since we have not yet shown that such functions are representable, we will
show that g is representable by proving that its graph is representable.
Let k ‚àà‚Ñïand consider the natural number z which is a product of adjacent primes,
z = p0
0 ‚ãÖp1
1 ‚ãÖp2
2 ‚ãÖp3
3 ‚ãÖ‚ãÖ‚ãÖpk
k = 20 ‚ãÖ31 ‚ãÖ52 ‚ãÖ73 ‚ãÖ114 ‚ãÖ‚ãÖ‚ãÖpk
k,
where each succeeding exponent is the successor of the previous exponent. So, 2 ‚à§z.
Let p be a prime number such that p3 | z and p4 ‚à§z. What is p? Yes, p = p3 = 7. In
fact, by the definition of z, we see that p3 = 7 if and only if 73 | z and 74 ‚à§z. Note that
20 ‚ãÖ31 ‚ãÖ52 ‚ãÖ73 ‚â§71 ‚ãÖ72 ‚ãÖ73 ‚â§732. One can show in general that
z = 20 ‚ãÖ31 ‚ãÖ52 ‚ãÖ73 ‚ãÖ114 ‚ãÖ‚ãÖ‚ãÖpk
k ‚â§pk2
k .
(6.22)
Also, each of the above exponents on the left hand side of ‚â§are strictly less than z. These
observations will be employed in the obscure proof of our next proposition.
Proposition 6.3.21. Let function g: ‚Ñï‚Üí‚Ñïdefined by g(x) = px be representable.
Proof. We show that g is graph representable. Consider the representable relations:
1.
Œ†(p): ‚Äúp is a prime,‚Äù
2.
A(q, r): ‚Äúq and r are adjacent primes,‚Äù
3.
E(qi, z, ri+1): ‚Äúqi | z if and only if ri+1 | z,‚Äù
4.
B(px, z, px+1): ‚Äúpx | z and px+1 ‚à§z.‚Äù
The divisibility relation m | n is representable by Exercise 1. Also, items 3 and 4 are rep-
resentable by Theorems 6.3.13 and 6.3.16. It now follows that px = p if and only if
Œ†(p) ‚àß(‚àÉz ‚â§px2
)(2 ‚à§z ‚àß(‚àÄq < p)(‚àÄr ‚â§p)(A(q, r) ‚Üí(‚àÄi < z)E(qi, z, ri+1))
‚àßB(px, z, px+1)).
The conjunction above B(px, z, px+1) ensures that z has the form in (6.22), at least up to px
x.
Thus, g is graph representable. So g is representable by Theorem 6.3.12.

6.3 Representable relations and functions
‡±™
223
Now, let s be a natural number that codes a sequence, that is, s = [a0, a1, a2, . . . , ak].
For i ‚â§k, we let (s)i = ai. Therefore, the function ‚ü®s, i‚ü©Û≥®É‚Üí(s)i acts as a ‚Äúdecoding‚Äù func-
tion. Proposition 5.3.38 shows this decoding function is primitive recursive. Our next
proposition shows that this function is representable.
Proposition 6.3.22. The function ‚ü®s, i‚ü©Û≥®É‚Üí(s)i is functionally representable.
Proof. Let R be the representable relation defined by
R(s, i, y)
iff
s = 0 ‚à®py+2
i
‚à§s.
Clearly, for all natural numbers s and i, there exists a y such that R(s, i, y). Therefore,
(s)i = ŒºyR(s, i, y) and is representable by Corollary 6.3.18.
Note that (s)i is defined for all s, i ‚àà‚Ñï, even when s does not code a sequence.
Using Proposition 6.3.22, we can now prove that a function defined by primitive
recursion, using representable functions, is itself representable. The proof is similar to
item (2) in the proof of Theorem 5.4.10.
Theorem 6.3.23. Let f : ‚Ñïk ‚Üí‚Ñïand g: ‚Ñïk+2 ‚Üí‚Ñïbe representable. Then the function
h: ‚Ñïk+1 ‚Üí‚Ñïdefined by the primitive recursion
(a) h( ‚Éóx, 0) = f ( ‚Éóx),
(b) h( ‚Éóx, n + 1) = g(h( ‚Éóx, n), ‚Éóx, n), for all n ‚àà‚Ñï,
is also representable.
Proof. Let f : ‚Ñïk ‚Üí‚Ñïand g: ‚Ñïk+2 ‚Üí‚Ñïbe graph representable. We will show that the
same holds for h. Consider the relation R ‚äÜ‚Ñïk+2 defined by
R( ‚Éóx, n, s)
iff
(f ( ‚Éóx) = (s)0
and
(‚àÄi < n)(g((s)i, ‚Éóx, i) = (s)i+1)).
Proposition 6.3.22, Lemma 6.3.3, Theorem 6.3.4, and Theorem 6.3.16 imply that R is rep-
resentable. Clearly, for all ‚Éóx ‚àà‚Ñïk and n ‚àà‚Ñï, there is an s ‚àà‚Ñïsuch that R( ‚Éóx, n, s).
Corollary 6.3.18 thus implies that there is a representable function ‚Ñì: ‚Ñïk+1 ‚Üí‚Ñïsuch
that R( ‚Éóx, n, ‚Ñì( ‚Éóx, n)), for every ‚Éóx ‚àà‚Ñïk and n ‚àà‚Ñï. Because h( ‚Éóx, n) = (‚Ñì( ‚Éóx, n))n for each
‚Éóx ‚àà‚Ñïk and n ‚àà‚Ñï, Theorem 6.3.15 implies that h is representable.
Representability Theorem 6.3.24. Every recursive function and recursive relation is rep-
resentable.
Proof. The initial functions are representable by Corollary 6.3.9. Furthermore, the set
of representable functions is closed under composition, total search, and primitive re-
cursion by Theorems 6.3.16, 6.3.17, and 6.3.23. Thus, as discussed on page 175, the set of
representable functions contains all of the recursive functions. Since a recursive rela-
tion is one whose characteristic function is recursive, we also see that every recursive
relation is representable.

224
‡±™
6 Undecidability and incompleteness
Lemma 6.3.3 implies that every representable relation is definable over ùí©. Thus,
the following corollary follows from Theorem 6.3.24.
Corollary 6.3.25. Every recursive relation is definable over ùí©.
The converse of Theorem 6.3.24 also holds (see Theorem 6.4.26).
Exercises 6.2.
*1. Let R = {‚ü®m, n‚ü©: m | n}. Show that R, the divisibility relation, is representable.
*2. Let R ‚äÜ‚Ñïk. Show that R is representable if and only if ‚Ñïk \ R is representable.
3. Let ‚àºbe an equivalence relation on ‚Ñï. Suppose that ‚àºis representable. Show that
each equivalence class is representable.
*4. Let œÜ and œà be numeralwise determined. Show that each of the following formulas
is also numeralwise determined:
(a) ¬¨œÜ,
(b) œÜ ‚Üíœà,
(c) œÜ ‚àßœà,
(d) œÜ ‚à®œà.
*5. Let k ‚àà‚Ñï. Show that each formula listed below is numeralwise determined:
(a) v Ãá= k,
(b) v Ãá< k,
(c) k Ãá< v.
*6. Let R ‚äÜ‚Ñïk be representable. Show that there is an ‚Ñí-formula œÜ(x1, x2, . . . , xk) such
that for all n1, n2, . . . , nk ‚àà‚Ñï,
(1) ‚ü®n1, n2, . . . , nk‚ü©‚ààR if and only if Œ© ‚ä¢œÜ(n1, n2, . . . , nk),
(2) ‚ü®n1, n2, . . . , nk‚ü©‚àâR if and only if Œ© ‚ä¢¬¨œÜ(n1, n2, . . . , nk).
*7. Let œÜ(v1, v2, . . . , vk) represent a relation R ‚äÜ‚Ñïk. Show that ‚ü®n1, n2, . . . , nk‚ü©‚ààR if
and only if ùí©Û≥ÄÄÛ≥®êœÜ‚ü¶n1, n2, . . . , nk‚üß, for all ‚ü®n1, n2, . . . , nk‚ü©‚àà‚Ñïk.
8. Let R ‚äÜ‚Ñïk and S ‚äÜ‚Ñïk be representable relations. Show that R ‚à©S and R ‚à™S are
representable.
9. Let œÑ(x) be a term and let g: ‚Ñï‚Üí‚Ñïbe representable. Let h: ‚Ñï‚Üí‚Ñïbe defined by
h(x) = g(œÑùí©(x)). Show that h is representable.
10. Let R ‚äÜ‚Ñïk be a representable relation and let f : ‚Ñïk ‚Üí‚Ñïand g: ‚Ñïk ‚Üí‚Ñïbe rep-
resentable functions. Show that the function h: ‚Ñïk ‚Üí‚Ñïis representable, where
h( ‚Éóx) = {f ( ‚Éóx),
if ‚Éóx ‚ààR,
g( ‚Éóx),
if ‚Éóx ‚àâR.
11. Prove Corollary 6.3.25.
12. Let R ‚äÜ‚Ñïk be decidable. Show that R is representable.
13. Show that if œÜ is numeralwise determined, then so are (‚àÄx Ãá‚â§y)œÜ and (‚àÉx Ãá‚â§y)œÜ.

6.4 Arithmetization of the formal language
‡±™
225
6.4 Arithmetization of the formal language
The next important step which will allow us to address question (Q2) on page 205 is to
take our formal language for number theory and define an effective correspondence
between the formulas of this language and a recursive set of natural numbers. Such a
correspondence is called an arithmetization, or G√∂del numbering, of the language. Using
our primitive recursive coding of sequences (via powers of primes) developed in Sec-
tion 5.3, we can assign a unique natural number to each formula. We can then ask if the
set of natural numbers that code all the valid formulas is decidable.
Again, let ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=}. We will assign natural numbers, called G√∂del num-
bers, to all the terms and wffs of ‚Ñí. We denote this assignment function by #. Thus, for
every wff œÜ, #(œÜ) will be the G√∂del number of œÜ. Recall that the operation [x0, x1, . . . , xk]
denotes a sequence number (see Definition 5.3.39) which encodes the finite sequence of
natural numbers ‚ü®x0, x1, x2, . . . , xk‚ü©by a single natural number. Let Sq denote the set of
sequence numbers.
Definition 6.4.1. Let V = {v1, v2, v3, . . . } be the set of all the variables of ‚Ñí. Let ùíØbe the
set of all the variables and the constant symbol in ‚Ñí. Define #: ùíØ‚Üí‚Ñïby
#(v) = {[2i],
if v = vi,
[1],
if v = Ãá0.
(6.23)
Let V # = {#(vi) : vi ‚ààV}. Since m ‚ààV # if and only if m = [2i] for an i such that
0 < i < m, it follows that V # is primitive recursive. Theorem 1.1.27 implies that we can
extend the function # to all of the terms of ‚Ñías in our next definition.
Definition 6.4.2. Let T be the set of terms of ‚Ñí. Define the function #: T ‚Üí‚Ñïby
#( ÃáSt) = [3, #(t)],
#(t Ãá+ œÑ) = [5, #(t), #(œÑ)],
#(t Ãá√ó œÑ) = [7, #(t), #(œÑ)],
#( ÃáEtœÑ) = [9, #(t), #(œÑ)].
Let T# = {#(t) : t is a term} be the set consisting of all the G√∂del numbers of ‚Ñí-terms.
Now let C be the characteristic function of T# and let m ‚àà‚Ñï. How can we evaluate C(m)?
If m = [1] or m = #(vi), then C(m) = 1. If m is a sequence number of length 2 and (m)0 = 3,
then C(m) = C((m)1). If m is a sequence number of length 3 and either (m)0 = 5, 7, or 9,
then C(m) = C((m)1) ‚ãÖC((m)2). If none of the previous conditions hold, then C(m) = 0.
Note that (m)0, (m)1, (m)2 are all strictly less than m. Thus, we can evaluate C(m) using
the values C(0), C(1), . . . , C(m ‚àí1) and m.
We now expand the function # in Definition 6.4.2 to include the atomic formulas.

226
‡±™
6 Undecidability and incompleteness
Definition 6.4.3. Let A be the set of all the atomic formulas of ‚Ñíand define the function
#: A ‚Üí‚Ñïby
#(t Ãá< œÑ) = [11, #(t), #(œÑ)],
#(t Ãá= œÑ) = [13, #(t), #(œÑ)].
Let A# = {#(œÜ) : œÜ is an atomic formula} and m ‚àà‚Ñï. How can we evaluate C(m),
when C is the characteristic function of A#? If m is a sequence number of length 3 and
(m)0 = 11 or (m)0 = 13, and (m)1, (m)2 ‚ààT#, then C(m) = 1. Otherwise, C(m) = 0.
Theorem 1.1.27 again implies that the function # given in Definition 6.4.3 can be ex-
tended, as in the next definition, to all the wffs of the language ‚Ñí.
Definition 6.4.4. Let W be the set of wffs of ‚Ñí. Define the function #: W ‚Üí‚Ñïby
#(¬¨œà) = [15, #(œà)],
#(œà ‚ÜíœÜ) = [17, #(œà), #(œÜ)],
#(‚àÄviœà) = [19, #(vi), #(œà)].
Let W# = {#(œÜ) : œÜ is a wff} and m ‚àà‚Ñï. How can we evaluate C(m), when C is the
characteristic function of W#? If m ‚ààA#, then C(m) = 1. If m is a sequence number of
length 2 and (m)0 = 15, then C(m) = C((m)1). When m is a sequence number of length 3
and (m)0 = 17, then C(m) = C((m)1) ‚ãÖC((m)2). If m is a sequence number of length 3,
(m)0 = 19, and (m)1 = [2i], where i ‚â•1, then C(m) = C((m)2). If all of these conditions
fail to hold, then C(m) = 0.
The observations we made on the characteristic functions of T#, A#, and W# are
formalized in the proof of our next result.
Proposition 6.4.5. The following sets of natural numbers are primitive recursive:
1.
T# = {#(t) : t is an ‚Ñí-term};
2.
A# = {#(œÜ) : œÜ is an ‚Ñí-atomic formula};
3.
W# = {#(œÜ) : œÜ is an ‚Ñí-wff}.
Proof. We will be applying Proposition 5.3.46, by defining a course-of-values recursion.
Recall that if C: ‚Ñï‚Üí‚Ñïand s = C(m) = [C(0), C(1), . . . , C(m ‚àí1)], then (s)i = C(i) for
i < m. Let Sq be the set of sequence numbers and let lh be the length function.
1.
Let C be the characteristic function of T#. We shall define a primitive recursive func-
tion g such that C(m) = g(C(m), m) for all m. Define g: ‚Ñï2 ‚Üí‚Ñïby
g(s, m) =
{
{
{
{
{
{
{
{
{
{
{
{
{
1,
if m = [1] or m ‚ààV #,
(s)(m)1,
if m ‚ààSq, lh(m) = 2, and (m)0 = 3,
(s)(m)1 √ó (s)(m)2,
if m ‚ààSq, lh(m) = 3, and (m)0 = 5, 7, or 9,
0,
otherwise.

6.4 Arithmetization of the formal language
‡±™
227
By letting s = C(m) = [C(0), C(1), . . . , C(m ‚àí1)] for each m ‚àà‚Ñï, we infer (see the
discussion after Definition 6.4.2) that
C(m) = g(C(m), m).
(6.24)
One can formally prove (6.24) by induction on m. Since Sq and lh are primitive recur-
sive by Propositions 5.3.40 and 5.3.41, one can now easily confirm that the conditions
in the definition of g are all primitive recursive. Proposition 5.3.46 thus implies that
C is primitive recursive.
2.
Let C be the characteristic function of A#. Then
C(m) = {1,
if m ‚ààSq, lh(m) = 3, (m)0 = 11 or 13, (m)1 ‚ààT#, and (m)2 ‚ààT#,
0,
otherwise.
Since T# is primitive recursive and the conditions in the description of C are all
primitive recursive, we conclude that A# is primitive recursive.
3.
As in item 1, one can evaluate C(m), the characteristic function of W#, using the
values C(0), C(1), . . . , C(m ‚àí1) and m. See Exercise 4.
When applying the function # to a term œÑ or formula œÜ, we may write #œÑ and #œÜ to
denote, respectively, #(œÑ) and #(œÜ). In particular, #œÑx
t = #(œÑx
t ) and #œÜx
t = #(œÜx
t ). We note
that Exercise 10 on page 16 implies that the function # is one-to-one.
Given a wff Œ±, a term t, and a variable x, Definition 3.3.13 presents a recursive defi-
nition of the substitution operation Œ±x
t . Given the G√∂del numbers of Œ±, t, and x, can we
effectively get the G√∂del number of Œ±x
t ? The answer is yes.
First we address this question when Œ± is a term œÑ. Consider the G√∂del number #œÑvi
t ,
where œÑ, t are terms and vi is a variable. How can we evaluate the natural number #œÑvi
t
using the natural numbers #t, #vi, #œÑ? Consider the following recursive attempt:
#œÑvi
t =
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
#t,
if #œÑ = #vi,
[3, #qvi
t ],
if #œÑ = [3, #q], where q is a term,
[5, #qvi
t , #zvi
t ],
if #œÑ = [5, #q, #z], where q, z are terms,
[7, #qvi
t , #zvi
t ],
if #œÑ = [7, #q, #z], where q, z are terms,
[9, #qvi
t , #zvi
t ],
if #œÑ = [9, #q, #z], where q, z are terms,
#œÑ,
otherwise.
This attempt motivates our subsequent proof where, in the definition of g, the inputs
u, i, m correspond, respectively, to the above #t, #vi, #œÑ.
Proposition 6.4.6. There is a primitive recursive function Sb‚Ä≤: ‚Ñï3 ‚Üí‚Ñïsuch that for any
‚Ñí-term t and variable vi, we have Sb‚Ä≤(#t, #vi, #œÑ) = #œÑvi
t for all terms œÑ.

228
‡±™
6 Undecidability and incompleteness
Proof. Define g: ‚Ñï4 ‚Üí‚Ñïby
g(s, u, i, m) =
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
u,
if m = #vi,
(1)
[(m)0, (s)(m)1],
if m ‚ààSq, (m)0 = 3, and lh(m) = 2,
(2)
[(m)0, (s)(m)1, (s)(m)2],
if m ‚ààSq, (m)0 = 5, and lh(m) = 3,
(3)
[(m)0, (s)(m)1, (s)(m)2],
if m ‚ààSq, (m)0 = 7, and lh(m) = 3,
(4)
[(m)0, (s)(m)1, (s)(m)2],
if m ‚ààSq, (m)0 = 9, and lh(m) = 3,
(5)
m,
otherwise.
(6)
Define h: ‚Ñï3 ‚Üí‚Ñïby h(u, i, m) = g(h(u, i, m), u, i, m). Since g is primitive recursive, h is
primitive recursive by Proposition 5.3.46. Let t be a term and let vi be a variable.
Claim. For all terms œÑ, h(#t, #vi, #œÑ) = #œÑvi
t .
Proof of claim. We prove that h(#t, #vi, #œÑ) = #œÑvi
t , by induction on terms œÑ.
Base step: If œÑ = vi, then #œÑ = #vi. Thus, by (1) of the definition of g, we see that
h(#t, #vi, #œÑ) = g(h(#t, #vi, #vi), #t, #vi, #vi) = #t.
If œÑ = vj, where j
Ã∏= i, then #œÑ = #vj. Thus, by (6) of the definition of g,
h(#t, #vi, #vj) = g(h(#t, #vi, #vj), #t, #vi, #vj) = #vj.
If œÑ = Ãá0, then #œÑ = # Ãá0, and by (6) of the definition of g,
h(#t, #vi, # Ãá0) = g(h(#t, #vi, # Ãá0), #t, #vi, # Ãá0) = # Ãá0.
Inductive step: Let œÑ and ÃÇœÑ be arbitrary terms. Assume the induction hypothesis
h(#t, #vi, #œÑ) = #œÑvi
t
and
h(#t, #vi, #ÃÇœÑ) = #ÃÇœÑvi
t .
(IH)
We must prove that the same holds for each of the terms ÃáSœÑ, œÑ
Ãá+ ÃÇœÑ, œÑ
Ãá√ó ÃÇœÑ, and ÃáEœÑÃÇœÑ. It is
important to note that, by the definition of h, we have
(h(#t, #vi, m))k = h(#t, #vi, k),
whenever k < m.
(6.25)
We now show that h(#t, #vi, # ÃáSœÑ) = #( ÃáSœÑ)vi
t . By Definition 6.4.2, # ÃáSœÑ = [3, #œÑ]. Also note
that (‚ãÜ) ([3, #œÑ])1 = #œÑ. Thus,
h(#t, #vi, # ÃáSœÑ) = g(h(#t, #vi, [3, #œÑ]), #t, #vi, [3, #œÑ])
by definition of h,
= [3, (h(#t, #vi, [3, #œÑ]))#œÑ]
by (‚ãÜ) and (2) of the definition of g,
= [3, h(#t, #vi, #œÑ)]
by (6.25) as #œÑ < [3, #œÑ],
= [3, #œÑvi
t ] = #( ÃáSœÑ)vi
t
by (IH) and Definition 6.4.2.

6.4 Arithmetization of the formal language
‡±™
229
Therefore, h(#t, #vi, # ÃáSœÑ) = #( ÃáSœÑ)vi
t . The proofs for the terms œÑ
Ãá+ ÃÇœÑ, œÑ
Ãá√ó ÃÇœÑ, and
ÃáEœÑÃÇœÑ are
similar (see Exercise 5).
(Claim)
Let Sb‚Ä≤ = h. Thus, Sb‚Ä≤ is as required.
(Proposition)
Therefore, Sb‚Ä≤(#t, #v, #œÑ) is the G√∂del number obtained when ‚Äút replaces v in œÑ.‚Äù
Corollary 6.4.7. There is a primitive recursive relation O ‚äÜ‚Ñï2 such that for every term œÑ
and variable vi,
‚ü®#vi, #œÑ‚ü©‚ààO
if and only if
vi occurs in the term œÑ.
Proof. Clearly, ‚ü®#vi, #œÑ‚ü©‚ààO if and only if Sb‚Ä≤(# Ãá0, #vi, #œÑ)
Ã∏= #œÑ.
Now let Sb(#t, #vi, #Œ±) denote the G√∂del number #Œ±vi
t , where Œ± is a wff, vi is a variable,
and t is a term. Can we evaluate #Œ±vi
t using only the natural numbers #t, #vi, and #Œ±?
Consider the recursive attempt, which is modeled after Definition 3.3.13:
#Œ±vi
t =
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
[11, #qvi
t , #zvi
t ],
if #Œ± = [11, #q, #z], where q, z are terms,
[13, #qvi
t , #zvi
t ],
if #Œ± = [13, #q, #z], where q, z are terms,
[15, #œàvi
t ],
if #Œ± = [15, #œà], where œà is a formula,
[17, #œàvi
t , #œÜvi
t ],
if #Œ± = [17, #œà, #œÜ], where œà, œÜ are formulas,
[19, #vj, #œàvi
t ],
if #Œ± = [19, #vj, #œà], where #vi
Ã∏= #vj and œà is a wff,
#Œ±,
otherwise.
The above ‚Äúrecursive attempt‚Äù is presented only to assist the reader in extending
the proof of Proposition 6.4.6 and thereby prove the following result (see Exercise 6).
Proposition 6.4.8. There is a primitive recursive function Sb: ‚Ñï3 ‚Üí‚Ñïsuch that for any
‚Ñí-term t and variable vi, we have Sb(#t, #vi, #Œ±) = #Œ±vi
t for all wffs Œ±.
Sb(#t, #v, #Œ±) is the G√∂del number obtained when ‚Äút replaces v in Œ±,‚Äù if v is free in Œ±.
Corollary 6.4.9. There is a primitive recursive relation F ‚äÜ‚Ñï2 such that for every term
or formula Œ± and variable vi,
‚ü®#vi, #Œ±‚ü©‚ààF
if and only if
vi occurs free in Œ±.
Proof. Define F by
‚ü®k, a‚ü©‚ààF
iff
(a ‚ààT# and Sb‚Ä≤(# Ãá0, k, a)
Ã∏= a)
or
(a ‚ààW# and Sb(# Ãá0, k, a)
Ã∏= a).
Thus, F is primitive recursive and satisfies the required condition.
Let S# = {#œÜ : œÜ is an ‚Ñí-sentence}. We can now prove that S# is primitive recursive.
Proposition 6.4.10. The set S# of G√∂del numbers of sentences is primitive recursive.

230
‡±™
6 Undecidability and incompleteness
Proof. Let S# be the set of G√∂del numbers of sentences. Then
a ‚ààS#
iff
a ‚ààW#
and
(‚àÄb < a)(if b ‚ààV #, then ‚ü®b, a‚ü©‚àâF).
Since W#, V #, and F are primitive recursive, S# is primitive recursive.
Recall that a term t is substitutable for a variable x in a formula Œ± if the resulting
substitution Œ±x
t does not produce a captured variable. We will next show that, with re-
spect to G√∂del numbers, the substitutability relation is primitive recursive. This is done
by a course-of-values recursion (one should review Proposition 5.3.46).
As you may remember, Definition 3.3.15 recursively defines the notion of a term be-
ing substitutable for a variable in a formula (one should also review Definition 3.3.15).
This definition has multiple technical cases. The proof of our next proposition will there-
fore also have multiple technical cases.
To prepare for the proof, let us revisit the definition of substitutability via G√∂del
numbers. Let t be a term and let vi be a variable. Let K: ‚Ñï‚Üí{0, 1} be such that for any
wff Œ±, K(#Œ±) = 1 if and only if ‚Äút is substitutable for vi in Œ±.‚Äù For each wff Œ±, K(#Œ±) can be
defined recursively, as in Definition 3.3.15, by
K(#Œ±) =
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
1,
if #Œ± ‚ààA#,
K(#œà),
if #Œ± = [15, #œà],
K(#œà) √ó K(#œÜ),
if #Œ± = [17, #œà, #œÜ],
1,
if #Œ± = [19, #vj, #œà] and ‚ü®#vi, #Œ±‚ü©‚àâF,
K(#œà),
if #Œ± = [19, #vj, #œà], ‚ü®#vi, #Œ±‚ü©‚ààF,
and ‚ü®#vj, #t‚ü©‚àâO,
0,
otherwise.
(6.26)
Since K is defined recursively, one might reasonably infer that K is recursive, as defined
by Definition 5.3.6. In the proof of our next proposition, we will prove that K is, in fact,
primitive recursive. However, the proof is rather technical because it applies a ‚Äúcourse-
of-values‚Äù argument.
Here is a summary of the proof: The above recursive definition of K will guide us
in defining a primitive recursive function g(s, x, y, m) where the variables x, y, m cor-
respond to the above #t, #vi, #Œ±. Using g, we will apply a course-of-values recursion to
show that the notion of being substitutable can be interpreted, via the G√∂del numbering,
as being primitive recursive.
Proposition 6.4.11. Let Sbl be the 3-place relation on G√∂del numbers defined by
‚ü®#t, #vi, #Œ±‚ü©‚ààSbl
if and only if
t is substitutable for vi in Œ±,
(6.27)
whenever t is a term, vi is a variable, and Œ± is a formula. Then the relation Sbl is primitive
recursive.

6.4 Arithmetization of the formal language
‡±™
231
Proof. Define the primitive recursive function g: ‚Ñï4 ‚Üí‚Ñïby
g(s, x, y, m) =
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
1,
if m ‚ààA#,
(1)
(s)(m)1,
if m ‚ààSq, lh(m) = 2, and (m)0 = 15,
(2)
(s)(m)1 √ó (s)(m)2,
if m ‚ààSq, lh(m) = 3, and (m)0 = 17,
(3)
1,
if m ‚ààSq, lh(m) = 3, (m)0 = 19,
(4)
and ‚ü®y, m‚ü©‚àâF,
(s)(m)2,
if m ‚ààSq, lh(m) = 3, (m)0 = 19,
(5)
‚ü®y, m‚ü©‚ààF, and ‚ü®(m)1, x‚ü©‚àâO,
0,
otherwise.
(6)
The cases in the definition of g are exclusive. Define h: ‚Ñï3 ‚Üí‚Ñï
h(x, y, m) = g(h(x, y, m), x, y, m).
(6.28)
Since g is primitive recursive, h is also primitive recursive by Proposition 5.3.46. Let
K: ‚Ñï3 ‚Üí{0, 1} be the characteristic function of Sbl. Let t be a term and let vi be a variable.
By induction on Œ±, we prove that for every formula Œ±,
h(#t, #vi, #Œ±) = K(#t, #vi, #Œ±).
(6.29)
Base step: Let Œ± be an atomic formula. By Definition 3.3.15 and (1) of the definition of g,
we see that h(#t, #vi, #Œ±) = K(#t, #vi, #Œ±).
Inductive step: Let œà and œÜ be arbitrary wffs. Assume the induction hypothesis
h(#t, #vi, #œà) = K(#t, #vi, #œà),
h(#t, #vi, #œÜ) = K(#t, #vi, #œÜ).
(IH)
We must prove that the same holds for the wffs ¬¨œà, œà ‚ÜíœÜ, and ‚àÄvjœà. Let us first con-
sider the formula ‚àÄvjœà. Thus, (Û≥∂É) #(‚àÄvjœà) = [19, #vj, #œà]. Thus, either (4), (5), or (6) in the
definition of g holds. Note that ([19, #vj, #œà])2 = #œà. Hence,
h(#t, #vi, #(‚àÄvjœà)) = g(h(#t, #vi, #(‚àÄvjœà)), #t, #vi, #(‚àÄvjœà))
by (6.28)
= g(h(#t, #vi, #(‚àÄvjœà)), #t, #vi, [19, #vj, #œà])
by (Û≥∂É)
=
{
{
{
{
{
{
{
1,
if (4) of the definition of g holds,
h(#t, #vi, #(‚àÄvjœà))#œà,
if (5) of the definition of g holds,
0,
if (6) of the definition of g holds
=
{
{
{
{
{
{
{
1,
if (4) holds,
h(#t, #vi, #œà),
if (5) holds, as #œà < #(‚àÄvjœà),
0,
if (6) holds

232
‡±™
6 Undecidability and incompleteness
=
{
{
{
{
{
{
{
1,
if (4) holds,
K(#t, #vi, #œà),
if (5) holds, by (IH),
0,
if (6) holds
= K(#t, #vi, #(‚àÄvjœà)),
where the last equality follows from (6.26). Hence,
h(#t, #vi, #(‚àÄvjœà)) = K(#t, #vi, #(‚àÄvjœà)).
The completion of the induction proof for the two wffs ¬¨œà and (œà ‚ÜíœÜ) is an exercise.
Thus, (6.29) holds for all terms t, variables vi, and wffs Œ±. Hence, for all x, y, m ‚àà‚Ñï,
‚ü®x, y, m‚ü©‚ààSbl
if and only if
x ‚ààT#, y ‚ààV #, m ‚ààW#, and h(x, y, m) = 1.
Therefore, Sbl is primitive recursive.
Proposition 6.4.12. Define the 2-place relation Gen on the G√∂del numbers by Gen(#œà, #œÜ)
if and only if œÜ is a generalization of œà. Then Gen is primitive recursive.
Proof. Let K: ‚Ñï2 ‚Üí{0, 1} be such that K(#œà, #œÜ) = 1 if and only if Gen(#œà, #œÜ), whenever
œà and œÜ are wffs. By applying Definition 3.3.12, the function K satisfies the following
recursive definition:
K(#œà, #œÜ) =
{
{
{
{
{
{
{
1,
if #œÜ = #œà,
K(#œà, #Œ≤),
if #œÜ = [19, #vi, #Œ≤] and #œà < #œÜ,
0,
otherwise,
for all wffs œà and œÜ. Using the above recursive definition as a guide, one can now prove
that Gen is primitive recursive using a course-of-values recursion (see Exercise 8).
6.4.1 The logical axioms revisited
Recall that the logical axioms are generalizations of the following, where x and y denote
any of the variables in V:
1.
first-order tautologies;
2.
‚àÄxŒ± ‚ÜíŒ±x
t , where t is substitutable for x in Œ±;
3.
‚àÄx(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄxŒ± ‚Üí‚àÄxŒ≤);
4.
Œ± ‚Üí‚àÄxŒ±, where x does not occur free in Œ±;
5.
x Ãá= x;
6.
x Ãá= y ‚Üí(Œ± ‚ÜíŒ±x
y), where Œ± is an atomic formula.

6.4 Arithmetization of the formal language
‡±™
233
In this section, we will show that the set of G√∂del numbers of each of the six logical axiom
groups is primitive recursive. First we address tautologies.
The subformulas of a wff Œ± are defined by the following recursion:
1.
If Œ± is atomic, then Œ± is its only subformula.
2.
If Œ± is ¬¨œà, then the subformulas of Œ± are Œ± and the subformulas of œà.
3.
If Œ± is œà ‚ÜíœÜ, then the subformulas of Œ± are Œ± and the subformulas of œà and œÜ.
4.
If Œ± is ‚àÄxœà, then the subformulas of Œ± are Œ± and the subformulas of œà.
Let Œ± be a wff. It follows that if Œ≤ is a subformula of Œ±, then #Œ≤ ‚â§#Œ±. Thus, as # is one-to-
one, the number of subformulas of Œ± is less than or equal to #Œ±.
It also follows from Exercise 1 on page 116 that every wff Œ± is generated by the prime
subformulas of Œ± (see Definition 3.3.2). Hence, to determine whether or not a wff Œ± is a
tautology, it is sufficient to assign truth values to every subformula of Œ± such that the as-
signment agrees with the truth table assignments for negations and conditionals. More
specifically, let S be the set of all the subformulas of Œ± and let v: S ‚Üí{T, F} be a truth as-
signment. Suppose that ¬¨œà and Œ≤ ‚ÜíœÜ are subformulas of Œ±. In order for v to agree with
the truth table assignments for negation and the conditional, we must have v(¬¨œà) = T if
and only if v(œà) = F and v(Œ≤ ‚ÜíœÜ) = T if and only if v(Œ≤) = T implies v(œÜ) = T. Given any
such truth assignment v, v(Œ±) determines the truth value of Œ±. So if v(Œ±) = T for every
such truth assignment, then Œ± is a tautology. This conclusion depends only on the values
that these truth assignments give to the prime subformulas of Œ±. Thus, having S contain
all the subformulas of Œ± (or more) is a harmless overkill (see Theorem 2.2.11).
Since we are involved with number theory, we will now view a truth assignment
as a sequence number v of a finite sequence of 0‚Äôs and 1‚Äôs, where 0, 1 represent F, T,
respectively. For example, v = [1, 0, 1, 0] will be understood to be a truth assignment,
where (v)2 = 1. Now let Œ± be a wff. Since #Œ≤ ‚â§#Œ± for every subformula Œ≤ of Œ±, we need
to use truth assignments v of length #Œ± + 1 in order to evaluate the value of (v)#Œ±. Such
a truth assignment that always assigns the value of 1 satisfies an inequality:
[
#Œ± + 1 times
‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû
1, 1, 1, . . . , 1] = p2
0 ‚ãÖp2
1 ‚ãÖ‚ãÖ‚ãÖp2
#Œ± < p2
#Œ± ‚ãÖp2
#Œ± ‚ãÖ‚ãÖ‚ãÖp2
#Œ± = p2(#Œ±+1)
#Œ±
.
Moreover, this truth assignment is larger than all other truth assignments v of length
#Œ± + 1. These inequalities justify an upper bound used in the proof of our next result.
Let Taut = {#Œ± ‚ààW# : Œ± is a tautology}, the set of G√∂del numbers of tautologies.
Proposition 6.4.13. The set Taut is primitive recursive.
Proof. Using logical notation, let Ta(v) be the primitive recursive relation
v ‚ààSq ‚àß(‚àÄi < lh(v))((v)i ‚â§1)
‚àß(‚àÄi < lh(v))([15, i] < lh(v) ‚Üí((v)[15,i] = 1 ‚Üî(v)i = 0))
‚àß(‚àÄi, j < lh(v))([17, i, j] < lh(v) ‚Üí((v)[17,i,j] = 1 ‚Üî((v)i = 1 ‚Üí(v)j = 1))).

234
‡±™
6 Undecidability and incompleteness
Ta(v) asserts that v is a truth assignment that agrees with the truth table assignments for
the G√∂del numbers of the negations and conditionals in its domain. Thus, again using
logical notation, we have
#Œ± ‚ààTaut
iff
#Œ± ‚ààW# ‚àß(‚àÄv < p2(#Œ±+1)
#Œ±
)((Ta(v) ‚àß(lh(v) = #Œ± + 1)) ‚Üí(v)#Œ± = 1).
Therefore, Taut is primitive recursive.
Proposition 6.4.14. The set of G√∂del numbers of formulas of the form ‚àÄviŒ± ‚ÜíŒ±vi
t , where
t is substitutable for vi in Œ±, is primitive recursive.
Proof. If a wff œÜ has the form ‚àÄviŒ± ‚ÜíŒ±vi
t , then #œÜ = #(‚àÄviŒ± ‚ÜíŒ±vi
t ). Hence, by Defini-
tion 6.4.4 and Proposition 6.4.8, we have
#œÜ = [17, #‚àÄviŒ±, #Œ±vi
t ] = [17, [19, #vi, #Œ±], Sb(#t, #vi, #Œ±)].
It thus follows that #vi, #t, #Œ± < #œÜ. By using logical notation and Proposition 6.4.11, we
therefore see that #œÜ is the G√∂del number of a wff of the desired form if and only if
(‚àÉv < #œÜ)(‚àÉx < #œÜ)(‚àÉa < #œÜ)(v ‚ààV # ‚àßx ‚ààT# ‚àßa ‚ààW#
‚àß#œÜ = [17, [19, v, a], Sb(x, v, a)] ‚àß‚ü®x, v, a‚ü©‚ààSbl).
Therefore, the set of such G√∂del numbers is primitive recursive.
Proposition 6.4.15. The set of G√∂del numbers of formulas of the form
‚àÄvi(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄviŒ± ‚Üí‚àÄviŒ≤)
is primitive recursive.
Proof. If a wff œÜ has the form ‚àÄvi(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄviŒ± ‚Üí‚àÄviŒ≤), then
#œÜ = #(‚àÄvi(Œ± ‚ÜíŒ≤) ‚Üí(‚àÄviŒ± ‚Üí‚àÄviŒ≤)).
Hence, by Definition 6.4.4, we have
#œÜ = [17, #‚àÄvi(Œ± ‚ÜíŒ≤), #(‚àÄviŒ± ‚Üí‚àÄviŒ≤)],
(6.30)
where
(a) #‚àÄvi(Œ± ‚ÜíŒ≤) = [19, #vi, [17, #Œ±, #Œ≤]],
(b) #(‚àÄviŒ± ‚Üí‚àÄviŒ≤) = [17, #‚àÄviŒ±, #‚àÄviŒ≤] = [17, [19, #vi, #Œ±], [19, #vi, #Œ≤]].
After substituting (a) and (b) into (6.30), it follows that the set of G√∂del numbers #œÜ sat-
isfying (6.30) is primitive recursive, as in the proof of Proposition 6.4.14.

6.4 Arithmetization of the formal language
‡±™
235
Proposition 6.4.16. The set of G√∂del numbers of formulas of the form Œ± ‚Üí‚àÄviŒ±, where
vi does not occur free in Œ±, is primitive recursive.
Proof. The proof is similar to that of Proposition 6.4.14, using the primitive recursive
relation F in Corollary 6.4.9.
Proposition 6.4.17. The set of G√∂del numbers of formulas of the form vi Ãá= vj is primitive
recursive.
Proof. By Definition 6.4.3, #œÜ is the G√∂del number of a wff of the form vi Ãá= vj if and only
if (‚àÉv < #œÜ)(‚àÉv‚Ä≤ < #œÜ)(v ‚ààV # ‚àßv‚Ä≤ ‚ààV # ‚àß#œÜ = [13, v, v‚Ä≤]). Therefore, the set of G√∂del
numbers of formulas of this form is primitive recursive.
Proposition 6.4.18. The set of G√∂del numbers of formulas of the form
vi Ãá= vj ‚Üí(Œ± ‚ÜíŒ±vi
vj),
where Œ± is an atomic formula, is primitive recursive.
Proof. The proof is similar to that of Proposition 6.4.14, using the primitive recursive
function Sb in Corollary 6.4.8.
Definition 6.4.19. Let Œ©# be the set of G√∂del numbers of all the sentences in Œ© and let
MP be the relation defined by
MP = {‚ü®#(œÜ ‚Üíœà), #œÜ, #œà‚ü©: œÜ ‚Üíœà, œÜ, œà are wffs}.
Let LA‚Ä≤
i be the set of G√∂del numbers of the wffs in logical axiom group i, where i =
1, 2, . . . , 6. For each such i, let
LAi = LA‚Ä≤
i ‚à™{#œÜ : (‚àÉ#Œ± < #œÜ)(Gen(Œ±, œÜ) ‚àßŒ± ‚ààLA‚Ä≤
i)}.
Now let LA = ‚ãÉ1‚â§i‚â§6 LAi.
Therefore, the set LA consists of the G√∂del numbers of all the logical axioms and
their generalizations.
Proposition 6.4.20. The sets LA, Œ©# and the relation MP are primitive recursive.
Proof. Propositions 6.4.13‚Äì6.4.18 imply, respectively, that LA‚Ä≤
i is primitive recursive for
each i = 1, 2, . . . , 6. Proposition 6.4.12 implies that the relation Gen is primitive recursive.
Thus, for each such i, LAi is primitive recursive. Since LA = ‚ãÉ1‚â§i‚â§6 LAi, Corollary 5.3.22(2)
implies that LA is primitive recursive. Because Œ© is a finite set, Proposition 5.3.24 implies
that Œ©# is primitive recursive. Finally, since
‚ü®#(œÜ ‚Üíœà), #œÜ, #œà‚ü©‚ààMP
iff
#œÜ ‚ààW# and #œà ‚ààW# and #(œÜ ‚Üíœà) = [17, #œÜ, #œà],
it follows that MP is primitive recursive.

236
‡±™
6 Undecidability and incompleteness
Let Œì be a set of ‚Ñí-wffs and let Œõ be the set of logical axioms and their generalizations.
Recalling Definition 3.3.20, a deduction is a sequence of formulas ‚ü®Œ±1, . . . , Œ±n‚ü©such that
for all 1 ‚â§k ‚â§n, either
(a) Œ±k is in Œì ‚à™Œõ, or
(b) Œ±k is obtained by modus ponens from two earlier wffs in the sequence, that is, for
some i and j less than k, the wffs Œ±i and Œ±j = (Œ±i ‚ÜíŒ±k) are in the sequence.
We now rephrase this definition in terms of sequence numbers consisting of G√∂del num-
bers. We then show that the set of such sequence numbers is primitive recursive.
Definition 6.4.21. Let Œì be a set of ‚Ñí-wffs. Then:
(1) ùîªŒì = {[#Œ±1, . . . , #Œ±n] : n ‚â•1 and ‚ü®Œ±1, . . . , Œ±n‚ü©is a deduction from Œì};
(2) ‚ÑôŒì = {‚ü®s, m‚ü©: ùîªŒì(s) and (s)lh(s)‚àí1 = m}.
In Definition 6.4.21, ùîªŒì(s) asserts that ‚Äús codes a deduction from Œì,‚Äù and ‚ÑôŒì(s, m)
asserts that ‚Äús codes a deduction (proof) of the formula with G√∂del number m.‚Äù For any
set Œì of wffs, we will let Œì# = {#œÜ : œÜ ‚ààŒì}. Note that if ùîªŒì(s), then (s)i ‚ààW# for all
i < lh(s). Of course, ùîªŒì(s) means that s ‚ààùîªŒì.
Theorem 6.4.22. For any set Œì of wffs, if Œì# is (primitive) recursive, then the set ùîªŒì and
the relation ‚ÑôŒì are (primitive) recursive.
Proof. Assume that Œì# is (primitive) recursive. Let U = Œì# ‚à™LA. Since
ùîªŒì(s)
iff
Sq(s) ‚àß(‚àÄk < lh(s))(((s)k ‚ààU) ‚à®(‚àÉi < k)(‚àÉj < k)MP((s)i, (s)j, (s)k)),
we see that ùîªŒì is (primitive) recursive. Hence, ‚ÑôŒì is (primitive) recursive.
Corollary 6.4.23. For any set Œì of wffs, if Œì# is (primitive) recursive, then the set of G√∂del
numbers {#œÜ : Œì ‚ä¢œÜ} is recursively enumerable.
Proof. Assume that Œì# is (primitive) recursive. Let D = {#œÜ : Œì ‚ä¢œÜ}. Then m ‚ààD if and
only if ‚àÉs‚ÑôŒì(s, m). Thus, D is recursively enumerable.
Theorem 6.3.24 shows that every recursive function and relation is representable.
We will soon establish the converse. Recall that for any natural number n, we let n denote
the ‚Ñí-term ÃáSn Ãá0, that is,
n = ÃáSn Ãá0 =
n times
‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû
ÃáS ÃáS ‚ãÖ‚ãÖ‚ãÖÃáS Ãá0.
So n + 1 =
ÃáSn, 1 =
ÃáS Ãá0, and 0 =
Ãá0. Given any natural number n, can we recursively
compute the G√∂del number #n of the term n? Yes.
Lemma 6.4.24. The function f : ‚Ñï‚Üí‚Ñïdefined by f (n) = #n is primitive recursive.

6.4 Arithmetization of the formal language
‡±™
237
Proof. Since f satisfies the primitive recursion
(1) f (0) = # Ãá0,
(2) f (n + 1) = [3, f (n)] for all n ‚àà‚Ñï,
we conclude that f is primitive recursive.
Lemma 6.4.25. Let Œ∏(x1, x2, . . . , xk) be a wff whose free variables are among x1, x2, . . . , xk.
The function g: ‚Ñïk ‚Üí‚Ñïdefined by
g(n1, n2, . . . , nk) = #Œ∏(n1, n2, . . . , nk)
is primitive recursive.
Proof. Let f : ‚Ñï‚Üí‚Ñïbe as in Lemma 6.4.24. Thus, f (ni) = #ni for 1 ‚â§i ‚â§k. Using
Proposition 6.4.8, we observe that
1.
#Œ∏(n1, x2, . . . , xk) = #Œ∏x1
n1 = Sb(f (n1), #x1, #Œ∏),
2.
#Œ∏(n1, n2, . . . , xk) = #Œ∏x1
n1
x2
n2 = Sb(f (n2), #x2, #Œ∏x1
n1)
= Sb(f (n2), #x2, Sb(f (n1), #x1, #Œ∏)),
...
k.
#Œ∏(n1, n2, . . . , nk) = #Œ∏x1
n1 ‚ãÖ‚ãÖ‚ãÖxk
nk = Sb(f (nk), #xk, #Œ∏x1
n1
x2
n2 ‚ãÖ‚ãÖ‚ãÖxk‚àí1
nk‚àí1)
= Sb(f (nk), #xk, Sb(f (nk‚àí1), #xk‚àí1, Sb(. . . . . . ))).
As Sb and f are primitive recursive, it follows, for each i = 1, 2, . . . , k, that the natural
number #Œ∏x1
n1
x2
n2 ‚ãÖ‚ãÖ‚ãÖxi
ni is the value of a composition of primitive recursive functions. In
particular, g(n1, n2, . . . , nk) = #Œ∏(n1, n2, . . . , nk) = #Œ∏x1
n1
x2
n2 ‚ãÖ‚ãÖ‚ãÖxk
nk is the value of a (finite)
composition of primitive recursive functions. Thus, g is primitive recursive.
Theorem 6.4.26. Every representable relation and function is recursive.
Proof. Let P ‚äÜ‚Ñïk be a representable relation. Thus, by Exercise 6 on page 224, there is
a formula œÜ(x1, x2, . . . , xk) such that for all n1, n2, . . . , nk ‚àà‚Ñï,
(1) ‚ü®n1, n2, . . . , nk‚ü©‚ààP if and only if Œ© ‚ä¢œÜ(n1, n2, . . . , nk),
(2) ‚ü®n1, n2, . . . , nk‚ü©‚àâP if and only if Œ© ‚ä¢¬¨œÜ(n1, n2, . . . , nk).
Define g: ‚Ñïk ‚Üí‚Ñïby (Û≥µ≥) g(n1, n2, . . . , nk) = #œÜ(n1, n2, . . . , nk). Hence,
‚ü®n1, n2, . . . , nk‚ü©‚ààP
iff
Œ© ‚ä¢œÜ(n1, n2, . . . , nk)
by (1),
iff
‚àÉs‚ÑôŒ©(s, #œÜ(n1, n2, . . . , nk))
by Definition 6.4.21,
iff
‚àÉs‚ÑôŒ©(s, g(n1, . . . , nk))
by (Û≥µ≥).
Since Œ©# is primitive recursive (by Proposition 6.4.20), Theorem 6.4.22 implies that the
relation ‚ÑôŒ© is primitive recursive. Lemma 6.4.25 implies that the function g is primitive

238
‡±™
6 Undecidability and incompleteness
recursive. Lemma 5.4.5 and the above equivalences now allow us to conclude that P is re-
cursively enumerable. A similar argument shows that ‚Ñïk \P is recursively enumerable.
Therefore, by Theorem 5.4.16, P is recursive.
If a function f is representable, then Theorem 6.3.12 and the above argument shows
that the graph of f is recursive. Thus, by Exercise 14 on page 195, f is recursive.
Theorem 6.3.24 and Theorem 6.4.26 show that a function (relation) is representable
if and only if the function (relation) is recursive.
Exercises 6.3.
1. Suppose that #‚àÄviŒ± = #‚àÄviŒ≤, where Œ± and Œ≤ are wffs in ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=}. Show
that #Œ± = #Œ≤.
2. Show that there is a primitive recursive function f such that for all wffs Œ±, if #Œ± is
the G√∂del number of Œ±, then f (#Œ±) is the G√∂del number of ‚àÄviŒ±.
3. Complete the proof of item 1 of Proposition 6.4.5 by proving that C satisfies (6.24)
for all m ‚àà‚Ñï.
*4. Prove item 3 of Proposition 6.4.5.
*5. Complete the proof of the claim in the proof of Proposition 6.4.6.
*6. Prove Proposition 6.4.8.
7. Complete the induction proof of Proposition 6.4.11 for the wffs ¬¨œà and œà ‚ÜíœÜ.
*8. Prove Proposition 6.4.12.
9. Let R be the 2-place relation on G√∂del numbers defined by R(#œà, #Œ±) if and only if
œà is a subformula of Œ±. Show that R is primitive recursive.
10. Let P ‚äÜ‚Ñïk be recursively enumerable. Show that there is a (k + 1)-place primitive
recursive relation R such that P( ‚Éóx) if and only if ‚àÉpR( ‚Éóx, p), for all ‚Éóx ‚àà‚Ñïk.
11. Show that every representable relation is decidable.
Exercise Notes: For Exercise 10, first show that it holds when P is just recursive. Con-
sider applying Theorem 6.3.24 and the proof of Theorem 6.4.26.
6.5 The incompleteness theorems
We are working with the language ‚Ñí= { Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá=} and the standard model of
arithmetic
ùí©= ‚ü®‚Ñï; 0, S, <, +, √ó, E‚ü©.
We now repeat the question that opened this chapter:
Is there a decidable set of ‚Ñí-sentences Œì such that ùí©Û≥ÄÄÛ≥®êŒì and
ùí©Û≥ÄÄÛ≥®êœÜ if and only if Œì ‚ä¢œÜ, for each ‚Ñí-sentence œÜ?
(Q2)

6.5 The incompleteness theorems
‡±™
239
Kurt G√∂del was the first to answer this question. His resulting theorems in this area are
among the most significant results produced in modern mathematical logic.
The next amazing lemma follows from arguments first presented by Kurt G√∂del in
[4]. The proof of this lemma is rather tricky, but the following proof is designed to ensure
validity and readability. With this result, we will have sentences that indirectly refer to
themselves. We let x denote an arbitrary variable.
Fixed-Point Lemma 6.5.1. For any formula Œ∏(x) in which only x occurs free, there is a
sentence œÉ such that
Œ© ‚ä¢œÉ ‚ÜîŒ∏(#œÉ).
Proof. Let the variable x be fixed. Define the function f : ‚Ñï2 ‚Üí‚Ñïby
f (m, n) = {Sb(#n, #x, m),
if m ‚ààW#,
0,
otherwise.
It follows from Proposition 6.4.8 that the function f is primitive recursive. Recall that
Sb(#n, #x, #Œ±) = #Œ±x
n and #Œ±x
n = #Œ±(n) when x is the only free variable in the wff Œ±.
Hence, in such a case,
f (#Œ±, #Œ±) = Sb(##Œ±, #x, #Œ±) = #Œ± x
#Œ± = #Œ±(#Œ±),
(6.31)
where #Œ± is the term ÃáS#Œ± Ãá0 in the language ‚Ñí(see page 236). Theorem 6.3.24 implies that
f is functionally representable. Therefore, there is an ‚Ñí-formula œÜ(v1, v2, v) whose free
variables are among v1, v2, v, such that for all n1, n2 ‚àà‚Ñï,
Œ© ‚ä¢‚àÄv(œÜ(n1, n2, v) ‚Üîv Ãá= f (n1, n2)).
(6.32)
By means of an alphabetic variant, we can assume that the variable x does not appear
in œÜ(v1, v2, v). Now let Œ±(x) be the formula
‚àÄv(œÜ(x, x, v) ‚ÜíŒ∏(v)),
(6.33)
where we assume that v is substitutable for x in Œ∏ (otherwise replace v with a variable
that is substitutable for x). Let e = #Œ± be the G√∂del number of the formula Œ±(x) in (6.33).
Note that this formula has only x as a free variable. Hence, Œ±(e) is the sentence
‚àÄv(œÜ(e, e, v) ‚ÜíŒ∏(v)).
(6.34)
Since e = #Œ±, (6.31) implies that f (e, e) = #Œ±(e). So from (6.32), we conclude that
Œ© ‚ä¢‚àÄv(œÜ(e, e, v) ‚Üîv Ãá= #Œ±(e)).
(6.35)

240
‡±™
6 Undecidability and incompleteness
Furthermore, by Logical axiom 3.3.17(2), (6.35) implies that
Œ© ‚ä¢œÜ(e, e, #Œ±(e)) ‚Üî#Œ±(e) Ãá= #Œ±(e).
(6.36)
Therefore, from (6.36) and Proposition 3.3.48, it follows that (Û≥µ≥) Œ© ‚ä¢œÜ(e, e, #Œ±(e)).
Claim. We have Œ© ‚ä¢Œ±(e) ‚ÜîŒ∏(#Œ±(e)).
Proof. We first show that Œ© ‚ä¢Œ±(e) ‚ÜíŒ∏(#Œ±(e)). Since Œ±(e) is the formula in (6.34), Logical
axiom 3.3.17(2) and (6.34) imply that
Œ©; Œ±(e) ‚ä¢œÜ(e, e, #Œ±(e)) ‚ÜíŒ∏(#Œ±(e)).
Thus, by (Û≥µ≥) and modus ponens, Œ©; Œ±(e) ‚ä¢Œ∏(#Œ±(e)). Hence, Œ© ‚ä¢Œ±(e) ‚ÜíŒ∏(#Œ±(e)), by the
deduction theorem (Theorem 3.3.33).
Now we show that Œ© ‚ä¢Œ∏(#Œ±(e))‚ÜíŒ±(e). Since Œ±(e) is the formula in (6.34), we must
show, by the deduction theorem, that
Œ©; Œ∏(#Œ±(e)) ‚ä¢‚àÄv(œÜ(e, e, v) ‚ÜíŒ∏(v)).
(6.37)
By the generalization theorem (Theorem 3.3.29) and the deduction theorem (Theo-
rem 3.3.33), to prove (6.37), it is sufficient to show that
Œ© ‚à™{Œ∏(#Œ±(e)), œÜ(e, e, v)} ‚ä¢Œ∏(v).
(6.38)
Note that (6.35) implies that
Œ© ‚à™{œÜ(e, e, v)} ‚ä¢v Ãá= #Œ±(e).
(6.39)
Moreover, Exercise 7 on page 135 implies that
{Œ∏(#Œ±(e)), v Ãá= #Œ±(e)} ‚ä¢Œ∏(v).
(6.40)
Clearly, (6.39) and (6.40) imply (6.38). Therefore, (6.37) holds.
(Claim)
Now let œÉ be the sentence Œ±(e). The claim implies that Œ© ‚ä¢œÉ ‚ÜîŒ∏(#œÉ).
(Lemma)
Lemma 6.5.1 and Theorem 4.1.5 imply the following corollary.
Corollary 6.5.2. For any formula Œ∏(x) in which only x occurs free, there is a sentence œÉ
such that ùí©Û≥ÄÄÛ≥®êœÉ ‚ÜîŒ∏(#œÉ).
The above corollary, together with the fixed-point lemma, will allow us to prove a
significant theorem due to Alfred Tarski. As you may recall, Tarski provided, in English,
a definition of truth in a structure for a first-order language (see Definition 3.2.6). Using

6.5 The incompleteness theorems
‡±™
241
this definition, one can determine which ‚Ñí-sentences are true in the standard model ùí©
and which are false. The next theorem shows that Tarski‚Äôs definition of truth, when
applied to the structure ùí©, cannot be translated into the language ‚Ñí.
Recall that the theory of ùí©, denoted by Th(ùí©), is the set of all ‚Ñí-sentences that are
true in ùí©. Consequently, Th(ùí©)# = {#œÜ : œÜ ‚ààTh(ùí©)} is the set of G√∂del numbers of
‚Ñí-sentences that are true in ùí©.
Tarski Undefinability Theorem 6.5.3. The set Th(ùí©)# is not definable over ùí©.
Proof. Suppose, for a contradiction, that the set Th(ùí©)# is definable over ùí©. Thus, let
Œ∏(v1) be a formula with one free variable such that for all ‚Ñí-sentences œÜ,
ùí©Û≥ÄÄÛ≥®êœÜ
iff
ùí©Û≥ÄÄÛ≥®êŒ∏‚ü¶#œÜ‚üß.
(6.41)
Since ¬¨Œ∏(v1) has only one free variable, Corollary 6.5.2 asserts that there exists an
‚Ñí-sentence œÉ such that ùí©Û≥ÄÄÛ≥®êœÉ ‚Üî¬¨Œ∏(#œÉ). Since #œÉ
ùí©= #œÉ, we conclude that
ùí©Û≥ÄÄÛ≥®êœÉ
iff
ùí©Û≥ÄÄÛ≥®ê¬¨Œ∏‚ü¶#œÉ‚üß,
which contradicts (6.41) by letting œÜ = œÉ.
Theorem 5.4.14 justifies our next definition.
Definition 6.5.4. Let Œì be a set of wffs. Then Œì is decidable if and only if Œì# is recursive.
Definition 6.5.4 and Theorem 6.5.3 imply that the theory of ùí©is undecidable.
Lemma 6.5.5. The set Th(ùí©)# is not recursive.
Proof. If Th(ùí©)# were recursive, then, by Corollary 6.3.25, it would be definable over ùí©,
contradicting Theorem 6.5.3.
6.5.1 G√∂del‚Äôs first incompleteness theorem
We are now in a position to answer the question that was posed at the beginning of this
chapter, namely:
Is there a decidable set of ‚Ñí-sentences Œì such that ùí©Û≥ÄÄÛ≥®êŒì and
ùí©Û≥ÄÄÛ≥®êœÜ if and only if Œì ‚ä¢œÜ, for each ‚Ñí-sentence œÜ?
(Q2)
We begin by reviewing some relevant definitions. A set T of ‚Ñí-sentences is said to be a
theory if and only if T is closed under logical implication, that is, by the completeness
theorem (Theorem 4.2.8), for any sentence œÉ,
if T ‚ä¢œÉ,
then œÉ ‚ààT.

242
‡±™
6 Undecidability and incompleteness
A theory T is complete if for every sentence œÜ, either T ‚ä¢œÜ or T ‚ä¢¬¨œÜ.
In Definition 4.3.14, we defined Cn(Œì) to be the set of consequences of Œì, where Œì is
a set of ‚Ñí-sentences. By the completeness theorem (Theorem 4.2.8), we can also define
Cn(Œì) to be the set of sentences œÜ such that Œì ‚ä¢œÜ. We let Cn(Œì)# = {#œÜ : Œì ‚ä¢œÜ}. Thus,
if Œì is a theory, then Cn(Œì) = Œì. Finally, recall that Œì is consistent if there is no formula
Œ≤ such that Œì ‚ä¢Œ≤ and Œì ‚ä¢¬¨Œ≤.
The next definition is a relevant extension of Definition 4.3.15.
Definition 6.5.6. A theory T is said to be axiomatizable if T = Cn(Œì) for some set of
sentences Œì such that Œì# is recursive.
Definitions 6.5.4 and 6.5.6 allows us to rephrase question (Q2) as follows:
Is the theory Th(ùí©) axiomatizable?
Lemma 6.5.7. Let Œì be a consistent set of ‚Ñí-sentences. If Œì# is recursive and Cn(Œì) is a
complete theory, then Cn(Œì)# is recursive.
Proof. Assume that Œì is consistent, Œì# is recursive, and Cn(Œì) is also a complete theory.
Let S# be the set of G√∂del numbers of sentences. By Proposition 6.4.10, S# is recursive.
Let A = Cn(Œì)#. As in the proof of Corollary 6.4.23, we have #œÜ ‚ààA if and only if #œÜ ‚ààS#
and ‚àÉs‚ÑôŒì(s, #œÜ). Therefore, by Theorem 6.4.22 and Proposition 6.4.10, A is recursively
enumerable. Now let B = {#œÜ ‚ààS# : Œì ‚ä¢¬¨œÜ}. By similar reasoning, we see that B is
recursively enumerable. Since Œì is consistent, we see that A ‚à©B = ‚åÄ. Moreover, because
Cn(Œì) is a complete theory, it follows that A ‚à™B = S#. Since S# is recursive, Exercise 4
implies that A is recursive, that is, Cn(Œì)# is recursive.
Lemma 6.5.7 demonstrates that a complete axiomatizable theory is recursive.
G√∂del Incompleteness Theorem 6.5.8. Let Œì be a set of ‚Ñí-sentences such that ùí©Û≥ÄÄÛ≥®êŒì. If
Œì# is recursive, then Cn(Œì) is not a complete theory.
Proof. Let Œì be a set of ‚Ñí-sentences such that ùí©Û≥ÄÄÛ≥®êŒì and Œì# is recursive. Suppose, for
a contradiction, that Cn(Œì) is a complete theory. Lemma 6.5.7 thus implies that Cn(Œì)# is
recursive. Moreover, Exercise 5 on page 146 implies that Cn(Œì) = Th(ùí©). Hence, Cn(Œì)# =
Th(ùí©)#. Thus, Th(ùí©)# is recursive, which contradicts Lemma 6.5.5.
Theorem 6.5.8 provides a clear negative answer to question (Q2) (see page 241). The
theorem implies there is no decidable set Œì of ‚Ñí-sentences such that (1) ùí©Û≥ÄÄÛ≥®êŒì and
(2) every sentence that is true in ùí©is also deducible from Œì. Thus, for any decidable
set Œì such that ùí©Û≥ÄÄÛ≥®êŒì, there is a sentence Œ≤ such that Œì ‚ä¨Œ≤ and Œì ‚ä¨¬¨Œ≤. Since either
ùí©Û≥ÄÄÛ≥®êŒ≤ or ùí©Û≥ÄÄÛ≥®ê¬¨Œ≤, it follows that there is a sentence that is true in ùí©and yet, it is not
deducible from Œì.
Corollary 6.5.9. The theory Cn(Œ©) is not complete.

6.5 The incompleteness theorems
‡±™
243
Lemma 6.5.10. Let Œì be a set of ‚Ñí-sentences and let œÉ be an ‚Ñí-sentence. If Cn(Œì)# is recur-
sive, then Cn(Œì; œÉ)# is recursive.
Proof. Let Œì and œÉ be as stated and assume that Cn(Œì)# is recursive. By the deduction
theorem (Theorem 3.3.33), for any wff œÜ, we have
Œì; œÉ ‚ä¢œÜ
iff
Œì ‚ä¢(œÉ ‚ÜíœÜ).
Hence,
#œÜ ‚ààCn(Œì; œÉ)#
iff
#(œÉ ‚ÜíœÜ) ‚ààCn(Œì).
(6.42)
Let g: ‚Ñï‚Üí‚Ñïbe defined by g(m) = [17, #œÉ, m] (see Definition 6.4.4). Clearly, g is primi-
tive recursive and (6.42) implies that
m ‚ààCn(Œì; œÉ)#
iff
g(m) ‚ààCn(Œì)#.
Thus, by the substitution rule (5.5), we conclude that Cn(Œì; œÉ)# is recursive.
By induction, we have the following corollary.
Corollary 6.5.11. Let Œì be a set of ‚Ñí-sentences and let Œ£ be a finite set of ‚Ñí-sentences. If
Cn(Œì)# is recursive, then Cn(Œì ‚à™Œ£)# is recursive.
Theorem 6.5.12. Let Œì be a set of ‚Ñí-sentences such that Œì ‚à™Œ© is consistent. Then Cn(Œì)#
is not recursive.
Proof. Let Œì be such that Œì‚à™Œ© is consistent. Suppose, to the contrary, that Cn(Œì)# is recur-
sive. Hence, by Corollary 6.5.11, Cn(Œì‚à™Œ©)# is recursive. Thus, Cn(Œì‚à™Œ©)# is representable
by Theorem 6.3.24. Therefore, by Definition 6.3.1, there exists a formula Œ∏(x) such that
for each ‚Ñí-sentence œÉ,
Œì ‚à™Œ© ‚ä¢œÉ implies Œ© ‚ä¢Œ∏(#œÉ),
(6.43)
Œì ‚à™Œ© ‚ä¨œÉ implies Œ© ‚ä¢¬¨Œ∏(#œÉ).
(6.44)
By Lemma 6.5.1, there is a particular sentence œÉ such that
Œ© ‚ä¢œÉ ‚Üî¬¨Œ∏(#œÉ).
(6.45)
Logical axiom 3.3.17(1) and (6.45) imply that
(Û≥µ≥) Œ© ‚ä¢Œ∏(#œÉ) ‚Üí¬¨œÉ
and
(Û≥∂É) Œ© ‚ä¢¬¨Œ∏(#œÉ)‚ÜíœÉ.
There are two cases to consider: Either Œì ‚à™Œ© ‚ä¢œÉ or Œì ‚à™Œ© ‚ä¨œÉ. If Œì ‚à™Œ© ‚ä¢œÉ, then we infer
that

244
‡±™
6 Undecidability and incompleteness
Œì ‚à™Œ© ‚ä¢œÉ ‚áíŒ© ‚ä¢Œ∏(#œÉ)
by (6.43),
‚áíŒ© ‚ä¢¬¨œÉ
by (Û≥µ≥) and modus ponens.
So Œì ‚à™Œ© ‚ä¢œÉ and Œ© ‚ä¢¬¨œÉ. This contradicts our assumption that Œì ‚à™Œ© is consistent.
If Œì ‚à™Œ© ‚ä¨œÉ, then we conclude that
Œì ‚à™Œ© ‚ä¨œÉ ‚áíŒ© ‚ä¢¬¨Œ∏(#œÉ)
by (6.44),
‚áíŒ© ‚ä¢œÉ
by (Û≥∂É) and modus ponens.
So Œì ‚à™Œ© ‚ä¨œÉ and Œ© ‚ä¢œÉ, which are contradictory. Hence, Cn(Œì)# is not recursive.
Corollary 6.5.13. The set Cn(Œ©)# is not recursive.
The following corollary is an extension of G√∂del‚Äôs incompleteness theorem. It is the
result of replacing ‚Äúùí©Û≥ÄÄÛ≥®êŒì‚Äù in Theorem 6.5.8 with ‚ÄúŒì ‚à™Œ© is consistent.‚Äù
Corollary 6.5.14. Let Œì be a set of ‚Ñí-sentences. If the set Œì# is recursive and Œì ‚à™Œ© is con-
sistent, then the theory Cn(Œì) is not complete.
The completeness theorem implies that an ‚Ñí-sentence œÜ is logically valid if and only
if ‚ä¢œÜ, that is, œÜ is deducible from the logical axioms. Let ùïçbe the set of all ‚Ñí-sentences
that are logically valid. It follows that Cn(ùïç) = ùïç.
Corollary 6.5.15 (Alonzo Church). The set ùïç# is not recursive.
G√∂del‚Äôs (1931) incompleteness theorem (Theorem 6.5.8) shows that no matter how
one selects a consistent recursive set of axioms, which hold in ùí©, these axioms will be
incomplete, that is, there will always be a true statement that cannot be deduced from
the axioms. G√∂del‚Äôs incompleteness theorem shows that there exists a limitation to the
axiomatic method. In the next section we will explore another limitation that G√∂del dis-
covered.
6.5.2 G√∂del‚Äôs second incompleteness theorem
After proving his first incompleteness theorem, G√∂del pursued the following question:
Can an axiomatic system prove its own consistency? Before we investigate G√∂del‚Äôs an-
swer to this question, we revisit some pertinent topics. Recalling Definition 6.4.21, we let:
(1) ùîªŒì = {[#Œ±1, . . . , #Œ±n] : n ‚â•1 and ‚ü®Œ±1, . . . , Œ±n‚ü©is a deduction from Œì},
(2) ‚ÑôŒì = {‚ü®s, m‚ü©: ùîªŒì(s) and (s)lh(s)‚àí1 = m},
for a set Œì of ‚Ñí-wffs. In Theorem 6.4.22 we showed that if Œì# is (primitive) recursive,
then the relations ùîªŒì(s) and ‚ÑôŒì(s, m) are (primitive) recursive. Thus, if Œì is a set of
‚Ñí-sentences and Œì# is recursive, then for any ‚Ñí-sentence œÉ,

6.5 The incompleteness theorems
‡±™
245
Œì ‚ä¢œÉ
iff
‚àÉs‚ÑôŒì(s, #œÉ).
(6.46)
Therefore, Cn(Œì)# is recursively enumerable. Thus, in particular, Cn(Œ©)# is recursively
enumerable and, by Corollary 6.5.13, Cn(Œ©)# is not recursive. This provides an example
of a recursively enumerable set that is not recursive.
Now let Œì# be recursive, where Œì is a set of ‚Ñí-sentences. Since the relation ‚ÑôŒì is
recursive, it is also representable. So, for any such set Œì, we will let œàŒì(x, y) be the formula
that represents ‚ÑôŒì. If a deduction exists, then can one deduce that it exists?
Lemma 6.5.16. Let Œì be a set of ‚Ñí-sentences such that Œ© ‚äÜŒì and Œì# is recursive. Then, for
any ‚Ñí-sentence œÉ, if Œì ‚ä¢œÉ, then Œì ‚ä¢‚àÉsœàŒì(s, #œÉ).
Proof. Let Œì be as stated and let œÉ be an ‚Ñí-sentence. Assume that Œì ‚ä¢œÉ. Thus, there exists
a deduction of œÉ from Œì. Let d = [#Œ±1, . . . , #Œ±n] be the sequence number that consists of
the G√∂del numbers of the formulas as they appear in the deduction of œÉ from Œì. Hence,
‚ÑôŒì(d, #œÉ). Since œàŒì(x, y) represents ‚ÑôŒì, we conclude that
Œ© ‚ä¢œàŒì(d, #œÉ).
Since d is a term with no variables, Logical axioms 3.3.17(1)(2) imply that
Œ© ‚ä¢œàŒì(d, #œÉ) ‚Üí‚àÉsœàŒì(s, #œÉ).
Therefore, by modus ponens, we have Œì ‚ä¢‚àÉsœàŒì(s, #œÉ).
By Lemma 6.5.1, there is an ‚Ñí-sentence œÉ such that
Œ© ‚ä¢œÉ ‚Üî¬¨‚àÉsœàŒì(s, #œÉ).
(6.47)
The sentence œÉ indirectly asserts that ‚ÄúI am not deducible from Œì.‚Äù If Œì is consistent, then
our next lemma shows that ‚ÄúœÉ is not lying.‚Äù
Lemma 6.5.17. Let Œì be a set of ‚Ñí-sentences such that Œ© ‚äÜŒì and Œì# is recursive. Let œÉ be
as in (6.47). If Œì is consistent, then Œì ‚ä¨œÉ.
Proof. Let Œì and œÉ be as stated above and assume that Œì is consistent. Suppose, for a
contradiction, that Œì ‚ä¢œÉ. Then we conclude that
Œì ‚ä¢œÉ ‚áíŒì ‚ä¢‚àÉsœàŒì(s, #œÉ)
by Lemma 6.5.16,
‚áíŒì ‚ä¢¬¨œÉ
by (6.47) as Œ© ‚äÜŒì.
Hence, Œì is inconsistent, contradicting our assumption. Therefore, Œì ‚ä¨œÉ.
Let Œì and œÉ be as in Lemma 6.5.17. We now show that the conditional in Lemma 6.5.17
‚Äúif Œì is consistent, then Œì ‚ä¨œÉ‚Äù
(6.48)

246
‡±™
6 Undecidability and incompleteness
can be translated into the first-order language ‚Ñí. Note that
Œì is consistent if and only if Œì ‚ä¨Ãá0
Ã∏Ãá= Ãá0.
Let Con(Œì) be the ‚Ñí-sentence ¬¨‚àÉsœàŒì(s, #( Ãá0
Ã∏Ãá= Ãá0)). Thus, our translation of (6.48) is
Con(Œì) ‚Üí¬¨‚àÉsœàŒì(s, #œÉ).
(6.49)
The proof of Lemma 6.5.17 was quite straightforward. Thus, one may suspect that
Œì ‚ä¢(Con(Œì) ‚Üí¬¨‚àÉsœàŒì(s, #œÉ)).
How strong must Œì be so that the above holds?
Definition 6.5.18. Let Œì be a set of ‚Ñí-sentences such that Œ© ‚äÜŒì and Œì contains all the
universal closures of formulas having the form
(œÜ( Ãá0) ‚àß‚àÄx(œÜ(x) ‚ÜíœÜ( ÃáSx))) ‚Üí‚àÄxœÜ(x).
(6.50)
Then Œì is called an extension of Peano arithmetic.
An extension of Peano arithmetic contains all of the ‚Äúinduction axioms‚Äù that have
the form (6.50). These axioms all hold in the standard model ùí©and allow one to deduce
many additional valid properties about the natural numbers.
The proof of our next lemma is quite technical and, as a result, we will not present
the proof here. For a complete proof, see Section 5.3 of [5].
Lemma 6.5.19. Let Œì be a set of ‚Ñí-sentences such that Œì# is recursive and Œì is a consistent
extension of Peano arithmetic. Also, let œÉ be as in (6.47). Then
Œì ‚ä¢(Con(Œì) ‚Üí¬¨‚àÉsœàŒì(s, #œÉ)).
We can now state and prove G√∂del‚Äôs second incompleteness theorem, which shows
that the ‚Ñí-sentence Con(Œì) is not deducible from Œì whenever Œì is a consistent extension
of Peano arithmetic and Œì# is recursive.
G√∂del‚Äôs Second Incompleteness Theorem 6.5.20. Let Œì be a set of ‚Ñí-sentences. If Œì is a
consistent extension of Peano arithmetic and Œì# is recursive, then Œì ‚ä¨Con(Œì).
Proof. Let Œì be a consistent extension of Peano arithmetic such that Œì# is recursive.
Suppose, for a contradiction, that Œì ‚ä¢Con(Œì) and let œÉ be as in (6.47). Therefore, by
Lemma 6.5.19 and modus ponens, we have Œì ‚ä¢¬¨‚àÉsœàŒì(s, #œÉ). Since Œ© ‚äÜŒì, (6.47) implies
that Œì ‚ä¢œÉ, and this contradicts Lemma 6.5.17.

6.5 The incompleteness theorems
‡±™
247
6.5.3 Epilogue
In the early 1920s, the German mathematician David Hilbert (1862‚Äì1943) put forward
a new proposal for the foundation of classical mathematics. This program is referred
to as Hilbert‚Äôs Program. With respect to number theory, David Hilbert proposed that
mathematicians find a single formal system from which one can deduce all of the true
statements in number theory and also prove that the system is consistent.
Kurt G√∂del‚Äôs theorems show that Hilbert‚Äôs program is unattainable. In his first theo-
rem, G√∂del proves that any consistent recursive set of axioms for Peano arithmetic can
never be complete as there will always exist true statements about the natural numbers
that cannot be deduced from the given axioms. In his second incompleteness theorem,
G√∂del shows that such a system cannot prove its own consistency.
Moreover, G√∂del‚Äôs theorems can be extended to other recursive axiomatic systems
in which an extension of Peano arithmetic can be interpreted. In particular, one can
show that the standard axiomatic system for set theory (ZFC) is incomplete and cannot
prove its own consistency, unless it is inconsistent.
G√∂del‚Äôs two incompleteness theorems transformed research in the foundations of
mathematics, both in mathematics and in philosophy. Moreover, these theorems have
also become important in theoretical computer science, as they show that there are lim-
itations on the kinds of problems that can be solved computationally.
Exercises 6.4.
1. Let Œ∏(x) and œà(x) be wffs in which only x occurs free. Show that there is a sentence œÉ
such that Œ© ‚ä¢œÉ ‚ÜíŒ∏(#œÉ) and Œ© ‚ä¢œÉ ‚Üíœà(#œÉ).
2. Let Œ∏(x) be a wff in which only x occurs free. Suppose that Œ© ‚ä¢‚àÄxŒ∏(x).
(a) By Lemma 6.5.1 there is a œÉ‚Ä≤ such that Œ© ‚ä¢œÉ‚Ä≤ ‚ÜîŒ∏(#œÉ‚Ä≤). Show that Œ© ‚ä¢œÉ‚Ä≤.
(b) By Lemma 6.5.1 there is a œÉ such that Œ© ‚ä¢œÉ ‚Üî¬¨Œ∏(#œÉ). Show that Œ© ‚ä¢¬¨œÉ.
3. Prove Corollary 6.5.2.
*4. Let A and B be recursively enumerable sets of natural numbers. Suppose that A‚à™B =
C is recursive and A ‚à©B = ‚åÄ. Prove that A is recursive.
5. Prove Corollary 6.5.9.
6. Show that Th(ùí©) is not finitely axiomatizable.
7. Show that there does not exist a recursive set A ‚äÜ‚Ñïsuch that {#œÜ : Œ© ‚ä¢œÜ} ‚äÜA and
{#œÜ : Œ© ‚ä¢¬¨œÜ} ‚äÜ‚Ñï\ A.
8. Let Œì be a set of ‚Ñí-sentences. Show that if ùí©Û≥ÄÄÛ≥®êŒì, then Cn(Œì)# is not recursive.
9. Prove Corollary 6.5.13.
10. Prove Corollary 6.5.14.
11. Prove Corollary 6.5.15.
12. Let Œì be a set of ‚Ñí-sentences. Suppose that Œ© ‚äÜŒì, Œì# is recursive, and ùí©Û≥ÄÄÛ≥®êŒì. Show
that if Œì ‚ä¢‚àÉsœàŒì(s, #œÉ), then Œì ‚ä¢œÉ.
13. Let ùïébe the set of all logically valid ‚Ñí-wffs. Show that ùïé# is not recursive.

248
‡±™
6 Undecidability and incompleteness
14. Let Œì be a set of ‚Ñí-sentences such that Œ© ‚äÜŒì and Œì# is recursive. Let œàŒì represent
the relation ‚ÑôŒì as defined in Definition 6.4.21 and let œÜ be an ‚Ñí-sentence. Suppose
that ùí©Û≥ÄÄÛ≥®êŒì and ùí©Û≥ÄÄÛ≥®ê‚àÉsœàŒì(s, #œÜ). Show that ùí©Û≥ÄÄÛ≥®êœÜ.
15. Let œàŒ© represent the relation ‚ÑôŒ© as defined in Definition 6.4.21. By Lemma 6.5.1, let
œÉ be a sentence such that Œ© ‚ä¢œÉ ‚Üî¬¨‚àÉsœàŒ©(s, #œÉ). Thus, by Lemma 6.5.17, Œ© ‚ä¨œÉ.
Show that ùí©Û≥ÄÄÛ≥®êœÉ. Conclude that Œ© ‚ä¨¬¨œÉ.
16. Let Œì be a set of ‚Ñí-sentences such that Œ© ‚äÜŒì and Œì# is recursive. Let œàŒì represent the
relation ‚ÑôŒì as defined in Definition 6.4.21. Now, by Lemma 6.5.1, let œÉ be a sentence
such that Œì ‚ä¢œÉ ‚Üî‚àÄs¬¨œàŒì(s, #œÉ). Show that Œì ‚ä¢¬¨œàŒì(n, #œÉ), for every n ‚àà‚Ñï. Also
show that Œì ‚ä¨‚àÄs¬¨œàŒì(s, #œÉ).
17. Let Œì be an extension of Peano arithmetic. Suppose that Œì# is recursive. Show that
if Œì ‚ä¢Con(Œì), then Œì is not consistent.
Exercise Notes: For Exercise 7, use proof by contradiction and Theorem 6.3.24. Then
apply Lemma 6.5.1 with a negation. For Exercise 9, show that Cn(Cn(Œ©)) = Cn(Œ©). For
Exercise 10, note that if Œì‚à™Œ© is consistent, then Cn(Œì)‚à™Œ© is also consistent. For Exercise 12,
see Lemma 6.5.16, its proof, and (6.46). For Exercise 14 and Exercise 15, see Exercise 7 on
page 224. Exercise 16 provides an example of a deduction system in which the ‚Äúœâ-rule‚Äù
does not hold.

Bibliography
[1]
Cunningham DW. A logical introduction to proof. New York, NY: Springer; 2012.
[2]
Enderton HB. A mathematical introduction to logic. 2nd ed. Burlington, MA: Harcourt/Academic Press;
2001.
[3]
Cunningham DW. Set theory. A first course. Camb. Math. Textb. Cambridge: Cambridge University
Press; 2016. Reprinted in 2022.
[4]
G√∂del K. √úber formal unentscheidbare S√§tze der Principia Mathematica und verwandter Systeme.
I. Monatsh Math. 2006;149(1):1‚Äì30. Reprinted from Monatsh. Math. Phys. 1931;3(8):173‚Äì198
[MR1549910], With an introduction by Sy-David Friedman.
[5]
Hinman PG. Fundamentals of mathematical logic. CRC Press; 2018. Available from: https://books.
google.com/books?id=6UBZDwAAQBAJ.
[6]
Chang CC, Keisler HJ. Model theory. 3rd edition. Dover Publications; 2013.
[7]
Enderton HB. Computability theory. An introduction to recursion theory. Amsterdam:
Elsevier/Academic Press; 2011.
[8]
Barwise J (Ed). Handbook of mathematical logic. With the cooperation of Keisler HJ, Kunen K,
Moschovakis YN and Troelstra AS. Reprint. vol. 90 of Stud. Logic Found. Math. Amsterdam: Elsevier;
1982.
[9]
van Dalen D. Logic and structure. 5th ed. Universitext. London: Springer; 2013.
[10] Srivastava SM. A course on mathematical logic. 2nd ed. Universitext. New York, NY: Springer; 2013.
https://doi.org/10.1515/9783110782073-007


Symbol Index
A; t 1
‚à©1
‚à™1
‚Ñï1
‚Ñù1
‚àà1
‚àâ1
\ 1
‚åÄ1
‚Ñö1
‚Ñ§1
‚ãÉ1
‚ãÇ2
‚ü®a, b‚ü©2
ùí´2
‚ü®a1, a2, . . . , an‚ü©2
dom(R) 3
fld(R) 3
ran(R) 3
‚àº3
[a] 4
[a]‚àº4
Û≥®É‚Üí6
ran(f) 6
f: A ‚ÜíB 6
h 9
|X| 13
|A| =c |B| 14
‚Ñµ0 14
‚àß, ‚à®, ¬¨, ‚Üí, ‚Üî16
‚àÄ, ‚àÉ19
‚àÉ! 22, 214
‚áí23
‚áî23
Ai 27
‚Ñ∞‚Üí28
‚Ñ∞‚àß28
‚Ñ∞‚Üî28
‚Ñ∞¬¨ 28
‚Ñ∞‚à®28
ùíÆ29
v 33
Œ£ ‚ä¢œà 48
ÃáSn Ãá0 54
‚Ñ∞f 54
ùíØ54, 82
ùíØ54
‚Ñ∞Qi 58
s 68
sv|d 69
A Û≥ÄÄÛ≥®êœÜ[s] 69
Œì Û≥ÄÄÛ≥®êœÜ 75
œÜ Û≥ÄÄÛ≥®ê
Û≥ÄÄÛ≥®ê
œà 75
A Û≥ÄÄÛ≥®ê‚ü¶a1, a2, . . . , ak‚üß77
Ãá<, Ãá0, ÃáS, Ãá+, Ãá√ó, ÃáE, Ãá= 78
Mod 79
A ‚â°B 79
Th(A) 80
A ‚âÖB 81
Œ±x
t 94
Œõ 97
Œì; œà 104
A ‚â∫B 137
ùí©137
ùí¶141
Th(ùí¶) 141
Cn(Œ£) 142
‚Éóx 152
‚Üì154
‚Üë154
‚ü¶e‚üß154
Ãäf 166
(f ‚àòg) 166
Ik
i
166
S 166
x ‚àò‚àíy 178
[x0, x1, . . . , xk] 190
lh 191
‚ãÅn
i=1 198
‚ãÄn
i=1 198
Œ© 206
n 206
nùí©206
œÑ(x1, x2, . . . , xk) 211
Œ∏(n1, n2, . . . , nk) 211
Œ∏(x1, x2, . . . , xk) 211
# 225
#(œÜ) 225
#(v) 225
T# 225
V# 225
A# 226
Sq 225
W# 226
https://doi.org/10.1515/9783110782073-008

252
‡±™
Symbol Index
#œÑ 227
#œÜ 227
Sb‚Ä≤ 227
Sb 229
ùîª236
‚Ñô236
Con 246
ZFC 247

Subject Index
adjacent primes 221
algorithm 148
alphabetic variant 114
arithmetization 225
assignment 68
Associative Laws 36
atomic formula 58
automorphism 86
axiom of choice (AC) 14
axiomatizable 242
back-and-forth method 144
Barwise, Jon 20
biconditional 16
Biconditional Law 36
Boolean functions 39
bound variable 20
bounded minimization 188
bounded quantifiers 185, 207
bounded search 188
Cantor, Georg 13, 14, 143, 144, 155
cardinal numbers 14
cardinality 14
Cartesian product 2
categorical 141
chain 14
characteristic function 152
Church‚ÄìTuring thesis 171
Church‚Äôs theorem 244
closed
‚Äì under a function 7
‚Äì under modus ponens 102
codomain 6
Commutative Laws 36
Compactness Theorem 44, 134
complete 49
complete theory 141, 242
Completeness Theorem
‚Äì first-order 129
‚Äì propositional 49
composite function 173
composition 167
compound sentence 16, 18
computable 149
concatenation 3, 192
conditional 16
‚Äì conclusion 50
‚Äì hypothesis 50
Conditional Laws 36
conjunction 16
consequences 142, 242
consistent 50, 105
constant function 176, 215
contraposition 104
Contrapositive Law 36
countable 11
countable set 11
course-of-values recursion 194
De Morgan‚Äôs Laws 36
decidable 201
deducible 48
deduction 48, 99
deduction strategies 105
deduction theorem
‚Äì first-order logic 104
‚Äì propositional logic 50
definable over a structure 77
definition
‚Äì by recursion 11
dense linear order 143
denumerable 13
diagonal argument 155
disjoint 1
disjunction 16
disjunctive normal form 42
Distribution Laws 36
distributive laws
‚Äì for quantifiers 25
divides 149
domain 6
‚Äì of a structure 67
Double Negation Law 36
effective procedure 149
effectively computable 152
elementarily closed 79
elementarily equivalent 79
elementarily extension 137
elementary class 79
‚Äì in the wider sense 79
equality axioms 97
https://doi.org/10.1515/9783110782073-009

254
‡±™
Subject Index
equivalence class 4, 133
equivalence relation 3, 132
Etchemendy, John 20
evenly divides 149
existential statement 20
Exportation Law 36
expression
‚Äì in first-order logic 53
‚Äì in propositional logic 28
extension by new constants 125
field of real numbers 138
‚Äì nonstandard 138
finitely axiomatizable 142
finitely satisfiable 93
first-order language 52
‚Äì constant symbols 52
‚Äì function symbols 52
‚Äì logical connectives 52
‚Äì predicate symbols 52
‚Äì variables 52
Fixed Point Lemma 239
formula building function
‚Äì first-order 58
formula building functions
‚Äì propositional 28
free variable 20
freely generated 8
function 5
‚Äì codomain 6
‚Äì domain 6
‚Äì empty 151
‚Äì partial 151
‚Äì range 6
‚Äì total 151
function from A to B 5, 6
functionally representable 214
functionally represents 214
generalization of a formula 94
generated from functions 8
G√∂del, Kurt 124, 247
G√∂del numbering 225
graph 199
graph representable 216
group
‚Äì axioms 67
‚Äì language 53
group homomorphism 80
halting problem 154
halting theorem 155
Henkin, Leon 124
Hilbert, David 205, 247
homomorphism 80
iff 34
incompleteness theorem 242
inconsistent 50, 105
indexed family of sets 2
indexed set 2
induction principle 8
infinitesimal 134, 139
initial functions 166, 173
intersection 1
isomorphic embedding 81
isomorphism 81
Kleene‚Äôs theorem 156, 202
length function 191
‚Ñí-expression 53
‚Ñí-formula 58
linear transformation 80
logical axioms 97
logically equivalent 75
logically implies 75
logically valid 75
≈Åo≈õ‚ÄìVaught Test 141
L√∂wenheim‚ÄìSkolem Theorem
‚Äì downward 140
‚Äì upward 140
‚Ñí-satisfiable 93
‚Ñí-structure 66
‚Ñí-term 54
‚Ñí-truth assignment 92
‚Ñí-wff 58
maximally consistent 135
minimization 169
‚Äì bounded 188
‚Äì unbounded 170
model 52
model of 74
modus ponens 35
Œº-operator 170
negation 16
nonprime 92

Subject Index
‡±™
255
nonstandard analysis 134
nonstandard models 137‚Äì139
n-sequence 2
numerals 206
numeralwise determined 212
Œ©-axioms 206
ordered pair 2
partial recursive 170
partial search 170
partition 4
Peano arithmetic
‚Äì extension of 246
power set 2
predicate 19
prenex formula 145
prime formula 92
primitive recursion 167
primitive recursive function 168
projection function 166, 173, 216
proper initial segment 2
proper subtraction function 178
proposition 16
propositional components 16
propositional logic 27
pseudocode 149
quantifier distribution laws 25
quantifier interchange laws 25
quantifier negation laws 22
quantifiers 19
‚Äì adjacent 23
‚Äì existential 19
‚Äì mixed 23
‚Äì universal 19
quotient structure 132
range 6
recursion theorem 8
recursive function 174
recursive relation 180
recursively enumerable 196
reductio ad absurdum 105
register machine 163
register-machine computable 165
relation
‚Äì domain of 3
‚Äì field of 3
‚Äì n-place 3
‚Äì range of 3
‚Äì reflexive 3
‚Äì single-valued 5
‚Äì symmetric 3
‚Äì transitive 3
relation on a set 3
representability theorem 223
representable 212
represents 212
restriction 191
Robinson, Abraham 134
rule T 104
satisfaction
‚Äì definition 69
‚Äì extended definition 70
satisfiable 34, 123
Schr√∂der‚ÄìBernstein theorem 14
scope 114
search operations
‚Äì bounded search 188
‚Äì partial search 170
‚Äì total search 174
semi-characteristic 153
semi-decidable 153, 201
semi-recursive 196
sentence 62
sequence decoding 190
sequence encoding 190
sequence number 191
set difference 1
sound 49
Soundness Theorem
‚Äì first-order 123
‚Äì propositional 49
standard model of arithmetic 137
string 28
structure 66
‚Äì assignment 68
subformulas 233
substitutable 96
substitution rule 181
substructure 82
successor function 166, 173, 215
suitable 9
Tarski, Alfred 20, 66, 68, 240
‚Äì satisfaction relation 69

256
‡±™
Subject Index
‚Äì undefinability theorem 241
Tarski‚Äôs World 20
tautologically complete 42
tautologically equivalent 36, 93
tautologically implies 35, 93
tautology
‚Äì first-order logic 91
‚Äì propositional logic 35
theorem 48
theory 141
‚Äì of a structure 80
theory of a class of structures 141
total search 174
truth assignment 33, 92
truth function 17, 39
truth functionally complete 41
Turing computable 161
Turing machine 159
union 1
unique readability
‚Äì of propositional wffs 32
‚Äì of terms 57
‚Äì of wffs 60
uniqueness quantifier 22
universal statement 20
universe of discourse 19
vacuous truth 18
valid 75
variable 19
‚Äì bound 20, 61
‚Äì free 20
‚Äì occurs free 61
variable assignment 68
Vaught, Robert 68
well-formed formula 29, 58
0-place function 166, 173, 176‚Äì178
zero function 166, 173, 215
Zorn‚Äôs lemma 14

