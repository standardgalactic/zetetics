UNIVERSIDADE FEDERAL DE PERNAMBUCO
CENTRO DE INFORMÃTICA
PROGRAMA DE PÃ“S-GRADUAÃ‡ÃƒO EM CIÃŠNCIA DA COMPUTAÃ‡ÃƒO
ISRAEL FERRAZ DE ARAUJO
OtimizaÃ§Ã£o de Circuitos para a InicializaÃ§Ã£o de Estados QuÃ¢nticos
Recife
2022

ISRAEL FERRAZ DE ARAUJO
OtimizaÃ§Ã£o de Circuitos para a InicializaÃ§Ã£o de Estados QuÃ¢nticos
Tese de Doutorado apresentada ao Programa de
PÃ³s-GraduaÃ§Ã£o em CiÃªncia da ComputaÃ§Ã£o da Uni-
versidade Federal de Pernambuco, como requisito
parcial para a obtenÃ§Ã£o do tÃ­tulo de Doutor em Ci-
Ãªncia da ComputaÃ§Ã£o. Ãrea de ConcentraÃ§Ã£o: Inte-
ligÃªncia Computacional.
Orientador: Adenilton JosÃ© da Silva
Coorientadora: Teresa Bernarda Ludermir
Recife
2022

CatalogaÃ§Ã£o na fonte
BibliotecÃ¡ria Luiza de Oliveira, CRB4-1316
A658o
Araujo, Israel Ferraz de
OtimizaÃ§Ã£o de circuitos para a inicializaÃ§Ã£o de estados quÃ¢nticos. /Israel Ferraz de AraÃºjo.
â€“ 2022.
128 f.: il., tab.
Orientador: Adenilton JosÃ© da Silva.
Coorientador: Teresa Bernarda Ludermir.
Tese (Doutorado) â€“ Universidade Federal de Pernambuco. CIN, CiÃªncia da ComputaÃ§Ã£o,
Recife, 2022.
Inclui referÃªncias. Inclui apÃªndice.
1. ComputaÃ§Ã£o quÃ¢ntica. 2. PreparaÃ§Ã£o de estados. 3. OtimizaÃ§Ã£o de circuitos. 4.Estados
aproximados. I. Silva, Adenilton jose de (orientador).
II. Ludermir, Teresa Bernarda
(coorientadora). III TÃ­tulo.
006.31
CDD (23. ed.)
UFPE - CCEN 2022-143

Israel Ferraz de Araujo
 â€œOtimizaÃ§Ã£o de Circuitos para a InicializaÃ§Ã£o de Estados QuÃ¢nticosâ€
Tese de Doutorado apresentada ao Programa
de  PÃ³s-GraduaÃ§Ã£o  em  CiÃªncia  da
ComputaÃ§Ã£o  da  Universidade  Federal  de
Pernambuco, como requisito parcial para a
obtenÃ§Ã£o do tÃ­tulo de Doutor em CiÃªncia da
ComputaÃ§Ã£o.  Ãrea  de  ConcentraÃ§Ã£o:
InteligÃªncia Computacional.
Aprovado em: 01/09/2022.
_____________________________________________________
Orientador: Prof. Dr. Adenilton JosÃ© da Silva
BANCA EXAMINADORA
_______________________________________________________
Prof. Dr. Stefan Michael Blawid
Centro de InformÃ¡tica / UFPE
________________________________________________________
Prof. Dr. AntÃ´nio Murilo Santos Macedo
Departamento de FÃ­sica / UFPE
________________________________________________________
Prof. Dr. Wilson Rosa de Oliveira Junior
Departamento de EstatÃ­stica e InformÃ¡tica / UFRPE
________________________________________________________
Prof. Dr. Leon Denis da Silva
Departamento de MatemÃ¡tica / UFRPE
________________________________________________________
Profa. Dra. SamuraÃ­ Gomes de Aguiar Brito
Itau Unibanco, Grupo de Tecnologias Emergentes

Dedico esta tese a toda minha famÃ­lia, amigos e professores. Seu suporte e confianÃ§a sÃ£o
fundamentais.

AGRADECIMENTOS
Aos colegas, pelo companheirismo, amizade e ajuda.
Aos professores, pelo empenho, comprometimento, compreensÃ£o e paciÃªncia.
Ao amigo e compadre Rui Ribeiro, pelo permanente apoio e incentivo.
Ã€ famÃ­lia, por ser presente, sempre.
Ã€ minha esposa Bruna e Ã  minha filha, Ingrid, pelo amor e confianÃ§a incondicionais.
Ao professor Wilson de Oliveira, que influenciou minha vida profissional e pessoal com sua
criatividade inspiradora.
Ã€ professora e coorientadora Teresa Ludermir, que me recebeu de braÃ§os abertos e apoiou em
todos os momentos.
Ao professor e orientador Adenilton da Silva, por quem eu adquiri uma admiraÃ§Ã£o profunda e
cuja atenÃ§Ã£o e crenÃ§a sÃ£o importantes. Obrigado.
Este trabalho foi financiado pela FundaÃ§Ã£o de Amparo Ã  CiÃªncia e Tecnologia de Pernambuco
(FACEPE), pelo Conselho Nacional de Desenvolvimento CientÃ­fico e TecnolÃ³gico (CNPq) e
pela CoordenaÃ§Ã£o de AperfeiÃ§oamento de Pessoal de NÃ­vel Superior (Capes).

No man is an island entire of itself; every man is a piece of the continent,
a part of the main; if a clod be washed away by the sea, Europe is the less,
as well as if a promontory were, as well as any manner of thy friends or of
thine own were; any manâ€™s death diminishes me, because I am involved in
mankind. And therefore never send to know for whom the bell tolls; it tolls
for thee. (DONNE, 1624, p.108).

RESUMO
A teoria dos algoritmos quÃ¢nticos promete benefÃ­cios sem precedentes ao utilizar as leis da
mecÃ¢nica quÃ¢ntica para resolver certos problemas computacionais. Entretanto, alguns desafios
impedem que tais vantagens se apliquem a todos os algoritmos quÃ¢nticos. Entre esses desafios
estÃ¡ o desenvolvimento de uma codificaÃ§Ã£o eficiente de dados clÃ¡ssicos em um estado quÃ¢ntico.
Em aplicaÃ§Ãµes prÃ¡ticas, o custo para carregar a informaÃ§Ã£o clÃ¡ssica em um dispositivo quÃ¢n-
tico pode dominar o custo computacional assintÃ³tico do algoritmo. Foram propostos diversos
mÃ©todos baseados em circuitos para codificar dados clÃ¡ssicos nas amplitudes de probabilidade
de um estado quÃ¢ntico. Entretanto, esses mÃ©todos produzem circuitos com complexidade que
cresce linearmente com o tamanho do dado, anulando o benefÃ­cio da aplicaÃ§Ã£o quÃ¢ntica. O
objetivo principal deste trabalho Ã© reduzir a complexidade computacional dos circuitos para
a inicializaÃ§Ã£o de estados quÃ¢nticos. As duas estratÃ©gias utilizadas para alcanÃ§ar tal objetivo
exploram a troca de complexidade temporal por espacial ou a transferÃªncia de complexidade
computacional para um computador clÃ¡ssico. A primeira estratÃ©gia reinterpreta mÃ©todos al-
gÃ©bricos para a decomposiÃ§Ã£o de estados quÃ¢nticos como caminhadas ao longo de Ã¡rvores
binÃ¡rias. A segunda investiga o grau de emaranhamento de bipartiÃ§Ãµes do estado quÃ¢ntico
atravÃ©s da decomposiÃ§Ã£o de Schmidt. Os mÃ©todos baseados em Ã¡rvore alcanÃ§am uma reduÃ§Ã£o
exponencial na profundidade dos circuitos, em comparaÃ§Ã£o Ã s abordagens existentes. Os base-
ados na decomposiÃ§Ã£o de Schmidt produzem circuitos de complexidade variÃ¡vel, proporcional
ao emaranhamento do estado. A perspectiva Ã© que o resultado desta tese auxilie os profissionais
da computaÃ§Ã£o quÃ¢ntica durante a era dos dispositivos ruidosos de escala intermediÃ¡ria.
Palavras-chave: computaÃ§Ã£o quÃ¢ntica; preparaÃ§Ã£o de estados; otimizaÃ§Ã£o de circuitos; esta-
dos aproximados.

ABSTRACT
The theory of quantum algorithms promises unprecedented benefits by using the laws of
quantum mechanics to solve some computational problems. However, challenges prevent such
advantages from applying to all quantum algorithms. Among these challenges is the develop-
ment of an efficient encoding of classical data into a quantum state. In practical applications,
the cost to load classical information into a quantum device can dominate the asymptotic com-
putational cost of the algorithm. Several circuit-based methods have been proposed to encode
classical data into the probability amplitudes of a quantum state. However, these methods
produce circuits with complexity that grows linearly with data size, negating the quantum
application benefit. The main goal of this work is to reduce the computational complexity
of quantum state initialization circuits. The two strategies to achieve this goal exploit ex-
changing temporal complexity for spatial complexity or transferring computational complexity
to a classical computer. The first strategy reinterprets algebraic methods for quantum state
decomposition as a walk along binary trees. The second investigates the degree of entan-
glement of quantum state bipartitions via Schmidt decomposition. The tree-based methods
achieve an exponential reduction in circuit depth compared to existing approaches. Those
based on Schmidt decomposition produce circuits of varying complexity, proportional to the
entanglement of the state. The perspective is that the result of this thesis will assist quantum
computing practitioners during the noisy intermediate-scale quantum era.
Keywords: quantum computing; state preparation; circuit optimization; approximate states.

LISTA DE FIGURAS
Figura 1 â€“ Processo de preparaÃ§Ã£o de estados quÃ¢nticos. . . . . . . . . . . . . . . . .
16
Figura 2 â€“ ComputaÃ§Ã£o quÃ¢ntica com entrada clÃ¡ssica. . . . . . . . . . . . . . . . . .
17
Figura 3 â€“ Mapeamento do vetor de entrada clÃ¡ssico em um estado quÃ¢ntico. . . . . .
18
Figura 4 â€“ RepresentaÃ§Ã£o de estados quÃ¢nticos uniforme e arbitrÃ¡rio.
. . . . . . . . .
19
Figura 5 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits. . . . . . . . . . . . .
23
Figura 6 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits sem simplificaÃ§Ãµes. . .
24
Figura 7 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits com simplificaÃ§Ãµes. . .
24
Figura 8 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits atÃ© uma diagonal.
. .
25
Figura 9 â€“ Identidades utilizadas para a decomposiÃ§Ã£o cosseno-seno (CSD) de opera-
dores quÃ¢nticos.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
Figura 10 â€“ Circuito para a decomposiÃ§Ã£o cosseno-seno (CSD) de um operador quÃ¢ntico
de trÃªs qubits.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
Figura 11 â€“ Identidade utilizada para a decomposiÃ§Ã£o de Shannon (QSD) de operadores
quÃ¢nticos.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
Figura 12 â€“ Circuito para a decomposiÃ§Ã£o de Shannon (QSD) de um operador quÃ¢ntico
de dois qubits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
Figura 13 â€“ CodificaÃ§Ã£o em Ã¢ngulos de qubits utilizando rotaÃ§Ãµes.
. . . . . . . . . . .
29
Figura 14 â€“ InicializaÃ§Ã£o de um estado quÃ¢ntico de ğ‘›qubits usando rotaÃ§Ãµes para co-
dificar um vetor de entrada complexo de dimensÃ£o ğ‘= 2ğ‘›nas amplitudes
do estado.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
Figura 15 â€“ NÃºmero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib usando a preparaÃ§Ã£o de estados baseada em rotaÃ§Ãµes, em funÃ§Ã£o do
logaritmo do comprimento da entrada ğ‘›= log2(ğ‘).
. . . . . . . . . . . .
31
Figura 16 â€“ InicializaÃ§Ã£o de um estado quÃ¢ntico de ğ‘›qubits usando a decomposiÃ§Ã£o de
Schmidt. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
Figura 17 â€“ ComparaÃ§Ã£o entre o nÃºmero de CNOTs e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando as preparaÃ§Ãµes de estados baseadas
em rotaÃ§Ãµes e na decomposiÃ§Ã£o de Schmidt, em funÃ§Ã£o do logaritmo do
comprimento da entrada ğ‘›= log2(ğ‘).
. . . . . . . . . . . . . . . . . . .
34
Figura 18 â€“ Esquema de Knill para a decomposiÃ§Ã£o de isometrias.
. . . . . . . . . . .
36

Figura 19 â€“ OtimizaÃ§Ã£o para a decomposiÃ§Ã£o cosseno-seno (CSD) de isometrias. . . . .
36
Figura 20 â€“ Esquema coluna-por-coluna para a decomposiÃ§Ã£o de isometrias. . . . . . .
37
Figura 21 â€“ Esquema para a decomposiÃ§Ã£o cosseno-seno (CSD) de isometrias. . . . . .
38
Figura 22 â€“ ComparaÃ§Ã£o entre o nÃºmero de qubits e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando a preparaÃ§Ã£o de estados baseada na
decomposiÃ§Ã£o de Schmidt e o algoritmo DCSP, em funÃ§Ã£o do logaritmo do
comprimento da entrada ğ‘›= log2(ğ‘).
. . . . . . . . . . . . . . . . . . .
42
Figura 23 â€“ Ponto de sublinearidade do algoritmo BDSP para log2(ğ‘) = 15, indicado
pela linha vermelha em ğ‘ = 8. . . . . . . . . . . . . . . . . . . . . . . . .
44
Figura 24 â€“ ComparaÃ§Ã£o entre o nÃºmero de qubits e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando o algoritmo DCSP e o BDSP com
configuraÃ§Ã£o sublinear ğ‘‚(
âˆš
ğ‘), em funÃ§Ã£o do logaritmo do comprimento
da entrada ğ‘›= log2(ğ‘). . . . . . . . . . . . . . . . . . . . . . . . . . . .
44
Figura 25 â€“ Profundidade e nÃºmero de CNOTs do circuito produzido pelo LRSP para
carregar um vetor complexo de dimensÃ£o 2ğ‘›em um estado quÃ¢ntico apro-
ximado com fidelidade ajustada pelo parÃ¢metro ğ‘š. . . . . . . . . . . . . .
45
Figura 26 â€“ Comparativo entre estados de 7 qubits inicializados por circuitos com 21
CNOTs construÃ­dos pelos algoritmos qGAN e BAA. . . . . . . . . . . . . .
48
Figura 27 â€“ ComparaÃ§Ã£o entre o nÃºmero de CNOTs e a profundidade de circuitos produ-
zidos pela biblioteca qclib utilizando o algoritmo de Schmidt e o LRSP para
inicializar estados emaranhados, em funÃ§Ã£o do logaritmo do comprimento
da entrada ğ‘›= log2(ğ‘). . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
Figura 28 â€“ ComparaÃ§Ã£o entre o nÃºmero de CNOTs e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando o algoritmo de Schmidt e o LRSP
para inicializar estados parcialmente emaranhados, em funÃ§Ã£o do logaritmo
do comprimento da entrada ğ‘›= log2(ğ‘). . . . . . . . . . . . . . . . . . .
49
Figura 29 â€“ Experimento para avaliar os limites das ferramentas atuais da biblioteca qclib. 50
Figura 30 â€“ MÃ©todo bidirecional usando BAA. . . . . . . . . . . . . . . . . . . . . . .
55
Figura 31 â€“ DecomposiÃ§Ã£o tensorial do estado em uma sequÃªncia de operadores atuando
em um nÃºmero crescente de qubits. . . . . . . . . . . . . . . . . . . . . .
56

Figura 32 â€“ Abordagem esquemÃ¡tica. a) Um vetor de estado quÃ¢ntico em notaÃ§Ã£o de
rede tensorial Ã© convertido em um MPS atravÃ©s da aplicaÃ§Ã£o de uma de-
composiÃ§Ã£o de Schmidt entre qubit 1 e qubits 2, 3, 4, 6, 7, 8, e depois
qubit 2 vs. 3, 4, 5, 6, 7, 8 e assim por diante. A chamada dimensÃ£o de
ligaÃ§Ã£o Ã© escolhida durante esse procedimento. A largura da barra de liga-
Ã§Ã£o significa a dimensÃ£o efetiva da ligaÃ§Ã£o. b) Reorganizando as qubits Ã©
possÃ­vel encontrar uma bipartiÃ§Ã£o tal que cada partiÃ§Ã£o tenha apenas uma
pequena dimensÃ£o de ligaÃ§Ã£o, o que significa que estas partiÃ§Ãµes nÃ£o estÃ£o
fortemente emaranhadas. . . . . . . . . . . . . . . . . . . . . . . . . . . . 126

LISTA DE TABELAS
Tabela 1 â€“ Artigos sobre preparaÃ§Ã£o de estados.
. . . . . . . . . . . . . . . . . . . .
41
Tabela 2 â€“ Erro Absoluto MÃ©dio entre probabilidades de mediÃ§Ãµes de estados aproxi-
mados (0 â‰¤ğ‘šâ‰¤2) de 7 qubits gerados pelo LRSP e as probabilidades
esperadas para o estado original exato (ğ‘š= 3).
. . . . . . . . . . . . . .
46
Tabela 3 â€“ Erro Absoluto MÃ©dio entre probabilidades de mediÃ§Ãµes de estados apro-
ximados (ğ‘™> 0.00) de 7 qubits gerados pelo BAA e as probabilidades
esperadas para o estado original exato (ğ‘™= 0.00).
. . . . . . . . . . . . .
46
Tabela 4 â€“ NÃºmero de CNOTs para inicializar um estado quÃ¢ntico representando dife-
rentes aproximaÃ§Ãµes da imagem usando o BAA.
. . . . . . . . . . . . . .
50
Tabela 5 â€“ SumÃ¡rio das contribuiÃ§Ãµes com as complexidades temporal e espacial dos
circuitos produzidos pelos algoritmos. . . . . . . . . . . . . . . . . . . . .
52
Tabela 6 â€“ Comparativo numÃ©rico entre nÃºmero de qubits, CNOTs e profundidade de
circuitos construÃ­dos pelas bibliotecas qclib e IBM Qiskit usando diferentes
algoritmos para a codificaÃ§Ã£o de vetores complexos com dimensÃ£o 2ğ‘›. . . .
54

LISTA DE ABREVIATURAS E SIGLAS
BAA
Bounded Approximation error state preparation Algorithm
BDSP
Bidirectional quantum State Preparation
CCD
Columnâ€“byâ€“Column Decomposition
CSD
Cosine-Sine Decomposition
DCSP
Divide-and-Conquer quantum State Preparation
HHL
Aram Harrow, Avinatan Hassidim and Seth Lloyd
HOSVD
High Order Singular Value Decomposition
HTF
Hierarchical Tucker Format
LRSP
Low-Rank quantum State Preparation
MAE
Mean Absolute Error
MPS
Matrix Product State
NISQ
Noisy Intermediate-Scale Quantum
qGAN
Quantum Generative Adversarial Networks
QLA
Quantum Linear Algebra
QMem
Quantum Memory
QML
Quantum Machine Learning
QSD
Quantum Shannon Decomposition
SVD
Singular Value Decomposition
VQC
Variational Quantum Classifier
ZYZ
ZYZ decomposition

SUMÃRIO
1
INTRODUÃ‡ÃƒO
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
1.1
MOTIVAÃ‡ÃƒO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.1.1
Complexidade computacional da preparaÃ§Ã£o de estados quÃ¢nticos . 19
1.1.2
PreparaÃ§Ã£o de estados quÃ¢nticos em dispositivos ruidosos . . . . . . 20
1.2
OBJETIVOS
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2
PRINCIPAIS FUNDAMENTOS E REFERÃŠNCIAS . . . . . . . . . .
22
2.1
DECOMPOSIÃ‡ÃƒO DE UNITÃRIOS . . . . . . . . . . . . . . . . . . . . .
22
2.1.1
UnitÃ¡rios de um qubit . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.1.2
UnitÃ¡rios de dois qubits . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.1.3
DecomposiÃ§Ã£o Cosseno-Seno . . . . . . . . . . . . . . . . . . . . . . . 25
2.1.4
DecomposiÃ§Ã£o de Shannon QuÃ¢ntica
. . . . . . . . . . . . . . . . . . 26
2.2
TIPO DE PREPARAÃ‡ÃƒO DE ESTADOS QUÃ‚NTICOS . . . . . . . . . . .
28
2.2.1
CodificaÃ§Ã£o na base
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.2.2
CodificaÃ§Ã£o nos Ã¢ngulos . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.2.3
CodificaÃ§Ã£o nas amplitudes . . . . . . . . . . . . . . . . . . . . . . . . 30
2.3
EXEMPLO DE PREPARAÃ‡ÃƒO DE ESTADOS QUÃ‚NTICOS . . . . . . . .
30
2.3.1
Baseada em rotaÃ§Ãµes
. . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.3.2
Baseada na decomposiÃ§Ã£o de Schmidt
. . . . . . . . . . . . . . . . . 33
2.4
DECOMPOSIÃ‡ÃƒO DE ISOMETRIAS
. . . . . . . . . . . . . . . . . . . .
35
2.4.1
DecomposiÃ§Ã£o de Knill
. . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.4.2
DecomposiÃ§Ã£o Coluna-por-Coluna . . . . . . . . . . . . . . . . . . . . 36
2.4.3
DecomposiÃ§Ã£o Cosseno-Seno . . . . . . . . . . . . . . . . . . . . . . . 38
3
SOLUÃ‡Ã•ES EXISTENTES PARA A PREPARAÃ‡ÃƒO DE ESTADOS
QUÃ‚NTICOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
4
PRINCIPAIS CONTRIBUIÃ‡Ã•ES . . . . . . . . . . . . . . . . . . . .
42
4.1
A DIVIDE-AND-CONQUER ALGORITHM FOR QUANTUM STATE PRE-
PARATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
4.2
CONFIGURABLE SUBLINEAR CIRCUITS FOR QUANTUM STATE PRE-
PARATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43

4.3
APPROXIMATED QUANTUM-STATE PREPARATION WITH ENTAN-
GLEMENT DEPENDENT COMPLEXITY . . . . . . . . . . . . . . . . . .
45
4.4
QCLIB: A QUANTUM COMPUTING LIBRARY . . . . . . . . . . . . . . .
49
5
CONCLUSÃƒO
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
5.1
PRINCIPAIS RESULTADOS . . . . . . . . . . . . . . . . . . . . . . . . .
51
5.1.1
Algoritmo do tipo divisÃ£o e conquista para a preparaÃ§Ã£o de estados
quÃ¢nticos
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
5.1.2
Algoritmo bidirecional para a preparaÃ§Ã£o de estados quÃ¢nticos . . . 52
5.1.3
Algoritmo baseado na decomposiÃ§Ã£o de Schmidt e na aproximaÃ§Ã£o
de baixo posto para a preparaÃ§Ã£o de estados quÃ¢nticos
. . . . . . . 52
5.1.4
Algoritmo de aproximaÃ§Ã£o com erro limitado para a preparaÃ§Ã£o de
estados quÃ¢nticos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
5.1.5
Biblioteca de cÃ³digo aberto para computaÃ§Ã£o quÃ¢ntica . . . . . . . . 53
5.2
TRABALHOS FUTUROS
. . . . . . . . . . . . . . . . . . . . . . . . . .
54
5.2.1
Big-data state preparation
. . . . . . . . . . . . . . . . . . . . . . . . 54
5.2.2
Tensor based quantum state preparation . . . . . . . . . . . . . . . . 55
5.3
OBSERVAÃ‡Ã•ES FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
REFERÃŠNCIAS
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
APÃŠNDICE A â€“ A DIVIDE-AND-CONQUER ALGORITHM FOR
QUANTUM STATE PREPARATION
. . . . . . .
69
APÃŠNDICE B â€“ CONFIGURABLE SUBLINEAR CIRCUITS FOR
QUANTUM STATE PREPARATION
. . . . . . .
81
APÃŠNDICE C â€“ APPROXIMATED QUANTUM-STATE PREPA-
RATION WITH ENTANGLEMENT DEPENDENT
COMPLEXITY . . . . . . . . . . . . . . . . . . . . 110
APÃŠNDICE D â€“ APPROXIMATED QUANTUM-STATE PREPA-
RATION WITH ENTANGLEMENT DEPENDENT
COMPLEXITY â€“ SUPPLEMENTARY INFORMA-
TION . . . . . . . . . . . . . . . . . . . . . . . . . 122
APÃŠNDICE E â€“ EMARANHAMENTO E A PREPARAÃ‡ÃƒO DE ES-
TADOS QUÃ‚NTICOS . . . . . . . . . . . . . . . . 125

16
1 INTRODUÃ‡ÃƒO
O desenvolvimento dos computadores quÃ¢nticos pode reduzir drasticamente o tempo para
resolver certas tarefas computacionais (ARUTE et al., 2019). O primeiro uso da computaÃ§Ã£o
quÃ¢ntica foi proposto por Feynman (1982), antes mesmo do primeiro modelo formalizado de
computaÃ§Ã£o quÃ¢ntica universal desenvolvido por Deutsch e Penrose (1985). Feynman sugeriu
uma arquitetura computacional baseada em autÃ´matos celulares com recursos quÃ¢nticos e
conjecturou que tal arquitetura poderia acelerar simulaÃ§Ãµes de fÃ­sica e quÃ­mica quÃ¢ntica alÃ©m
da capacidade dos computadores clÃ¡ssicos. AlÃ©m de Feynman, pioneiros como Benioff (1980)
e Manin (1980) promoveram o desenvolvimento da computaÃ§Ã£o quÃ¢ntica. ApÃ³s pouco mais
de uma dÃ©cada, Grover (1996) estabeleceu um algoritmo quÃ¢ntico de busca com aceleraÃ§Ã£o
quadrÃ¡tica em relaÃ§Ã£o ao melhor algoritmo clÃ¡ssico conhecido. Em seguida, Shor (1999) de-
monstrou um algoritmo quÃ¢ntico de fatoraÃ§Ã£o em tempo polinomial que pode ser utilizado
para quebrar o sistema de criptografia RSA (GIDNEY; EKERÃ…, 2021; RIVEST; SHAMIR; ADLEMAN,
1978).
Figura 1 â€“ Processo de preparaÃ§Ã£o de estados quÃ¢nticos.
0100110101101010101010010111
0101101010001001010101110100
0101000010100010110101001010
0101000011110101101010100101
1111011010100111001011110110
0101001000100010110111011110
0101000011110101101010100101
1111011010100111001011110110
1111011010100111001011110110
Dados ClÃ¡ssicos
Circuito QuÃ¢ntico
TraduÃ§Ã£o
Estado QuÃ¢ntico
Fonte: Elaborada pelo autor (2022)
Recentemente, uma nova famÃ­lia de algoritmos quÃ¢nticos promete ganho exponencial so-
bre os algoritmos clÃ¡ssicos equivalentes (AARONSON, 2015). O objetivo de tais algoritmos
sÃ£o problemas prÃ¡ticos como aprendizagem de mÃ¡quina, clustering e soluÃ§Ã£o de sistemas li-
neares (STOUDENMIRE; SCHWAB, 2016; SCHULD; FINGERHUTH; PETRUCCIONE, 2017; SCHULD;
PETRUCCIONE, 2018; BENEDETTI et al., 2019; LEVINE et al., 2019; BLANK et al., 2020; TRUGEN-
BERGER, 2001; TRUGENBERGER, 2002; GIOVANNETTI; LLOYD; MACCONE, 2008b; SILVA; OLI-
VEIRA; LUDERMIR, 2010; de Paula Neto et al., 2019; PARK; PETRUCCIONE; RHEE, 2019; HARROW;
HASSIDIM; LLOYD, 2009; LLOYD; MOHSENI; REBENTROST, 2014; CHILDS; KOTHARI; SOMMA,
2017; WOSSNIG; ZHAO; PRAKASH, 2018; REBENTROST et al., 2018). Vantagens em vÃ¡rios cam-

17
pos de pesquisa e indÃºstria sÃ£o esperadas com o surgimento dessas aplicaÃ§Ãµes quÃ¢nticas.
Mas algumas dificuldades impedem que tais aplicaÃ§Ãµes sejam realizadas (AARONSON, 2015;
BIAMONTE et al., 2017; LEYMANN; BARZEN, 2020).
Figura 2 â€“ ComputaÃ§Ã£o quÃ¢ntica com entrada clÃ¡ssica.
Dados ClÃ¡ssicos
PrÃ©-processamento
InicializaÃ§Ã£o
de Estados
TransformaÃ§Ã£o
UnitÃ¡ria
MediÃ§Ã£o
PÃ³s-processamento
Regime QuÃ¢ntico
PreparaÃ§Ã£o de Estados QuÃ¢nticos
ComputaÃ§Ã£o
QuÃ¢ntica
ExtraÃ§Ã£o de Resultados QuÃ¢nticos
em Dados ClÃ¡ssicos
Fonte: Elaborada pelo autor (2022)
Um dos problemas em aberto que impedem aplicaÃ§Ãµes prÃ¡ticas da computaÃ§Ã£o quÃ¢ntica Ã©
o desenvolvimento de uma codificaÃ§Ã£o eficiente de dados clÃ¡ssicos em um estado quÃ¢ntico (BI-
AMONTE et al., 2017; AARONSON, 2015; LEYMANN; BARZEN, 2020; TANG, 2021). Para efetuar
essa codificaÃ§Ã£o, o dado clÃ¡ssico Ã© convertido para uma forma vetorial e um processo traduz
a informaÃ§Ã£o em operaÃ§Ãµes realizadas em um computador quÃ¢ntico, comumente codificadas
por um circuito quÃ¢ntico (Figura 1) (NIELSEN; CHUANG, 2010). A execuÃ§Ã£o desse circuito cria
o estado inicial pretendido. VÃ¡rios mÃ©todos baseados em circuitos quÃ¢nticos foram propostos
para codificar esses dados como amplitudes de probabilidade de um estado quÃ¢ntico (VEN-
TURA; MARTINEZ, 1999; GROVER, 2000; LONG; SUN, 2001; MOTTONEN et al., 2005; SHENDE;
BULLOCK; MARKOV, 2006; PLESCH; BRUKNER, 2011; CORTESE; BRAJE, 2018). Entretanto, eles
requerem profundidade do circuito quÃ¢ntico â€“ caminho mais longo do circuito, representado
pelo nÃºmero de operadores nesse caminho â€“ que cresce linearmente com o tamanho dos dados.
O HHL, criado por Harrow, Hassidim e Lloyd (2009), Ã© um exemplo de algoritmo quÃ¢ntico
que sofre de tal problema. Seu objetivo Ã© solucionar o sistema linear ğ´x = b. Para isso, o HHL
expressa o vetor b âˆˆCğ‘como o estado quÃ¢ntico |ğ‘âŸ©usando log2(ğ‘) qubits e o vetor x como
o estado quÃ¢ntico |ğ‘¥âŸ©. Dessa maneira, temos a equaÃ§Ã£o ğ´|ğ‘¥âŸ©= |ğ‘âŸ©, que pode ser solucionada
multiplicando ambos os lados pela inversa ğ´âˆ’1. Para encontrar |ğ‘¥âŸ©, o algoritmo HHL produz
um circuito quÃ¢ntico com profundidade ğ‘‚(log2
2(ğ‘)), enquanto o algoritmo clÃ¡ssico precisa
de ğ‘‚(ğ‘log2(ğ‘)) passos, caracterizando a vantagem quÃ¢ntica exponencial. Mas hÃ¡ ressalvas
importantes quanto ao HHL (AARONSON, 2015). Uma delas Ã© que o vetor b precisa ser
codificado rapidamente na memÃ³ria do computador quÃ¢ntico, preparando o estado |ğ‘âŸ©=
âˆ‘ï¸€ğ‘âˆ’1
ğ‘–=0 ğ‘ğ‘–|ğ‘–âŸ©. Preparar esse estado utilizando qualquer mÃ©todo existente requer custo na ordem
de ğ‘passos, anulando a vantagem exponencial do HHL em seu princÃ­pio.
Na computaÃ§Ã£o quÃ¢ntica, a etapa de codificaÃ§Ã£o dos dados clÃ¡ssicos em um estado quÃ¢n-

18
Figura 3 â€“ Mapeamento do vetor de entrada clÃ¡ssico em um estado quÃ¢ntico.
InicializaÃ§Ã£o
de Estados
Regime QuÃ¢ntico
PreparaÃ§Ã£o de Estados QuÃ¢nticos
PrÃ©-processamento
Fonte: Elaborada pelo autor (2022)
tico Ã© chamada de PreparaÃ§Ã£o de Estados QuÃ¢nticos (Figura 2 e Figura 3) (SCHULD; PETRUC-
CIONE, 2018). O foco desta tese Ã© atuar na preparaÃ§Ã£o de estados quÃ¢nticos para produzir
circuitos eficientes para a inicializaÃ§Ã£o de estados. Essa etapa recebe como entrada um ve-
tor de dados clÃ¡ssico e produz como saÃ­da um estado quÃ¢ntico (Figura 3) que serÃ¡ utilizado
pela aplicaÃ§Ã£o quÃ¢ntica na etapa seguinte (ComputaÃ§Ã£o QuÃ¢ntica, Figura 2). A preparaÃ§Ã£o
de estados Ã© dividida em duas fases chamadas PrÃ©-processamento e InicializaÃ§Ã£o de Estados
(Figura 2 e Figura 3). A primeira fase ocorre no regime clÃ¡ssico e tem como objetivo construir
um circuito quÃ¢ntico com a sequÃªncia de instruÃ§Ãµes, na forma de operadores, para a produ-
Ã§Ã£o do estado. A segunda fase ocorre no regime quÃ¢ntico e executa as instruÃ§Ãµes do circuito
criado no passo anterior para produzir efetivamente o estado pretendido. As complexidades
de ambas as fases devem ser consideradas para estimar o esforÃ§o necessÃ¡rio para produzir o
estado quÃ¢ntico.
O restante deste capÃ­tulo estÃ¡ organizado da seguinte forma. A SeÃ§Ã£o 1.1 apresenta a mo-
tivaÃ§Ã£o para a busca de uma preparaÃ§Ã£o eficiente de estados quÃ¢nticos. A SeÃ§Ã£o 1.2 descreve
os objetivos desta tese. O CapÃ­tulo 2 revisa os principais fundamentos utilizados no desenvol-
vimento deste trabalho. O CapÃ­tulo 3 comenta algumas soluÃ§Ãµes existentes para a preparaÃ§Ã£o
de estados quÃ¢nticos. O CapÃ­tulo 4 resume as contribuiÃ§Ãµes desta tese, incluindo a biblioteca
de cÃ³digo aberto qclib (ARAUJO et al., 2022) usada para produzir os grÃ¡ficos e tabelas deste
trabalho. Por fim, o CapÃ­tulo 5 apresenta a conclusÃ£o e os principais resultados. O detalha-
mento de todos os resultados e contribuiÃ§Ãµes estÃ¡ nos apÃªndices A, B, C e D. O ApÃªndice E
discute a relaÃ§Ã£o entre emaranhamento e a preparaÃ§Ã£o de estados quÃ¢nticos.

19
1.1
MOTIVAÃ‡ÃƒO
1.1.1
Complexidade computacional da preparaÃ§Ã£o de estados quÃ¢nticos
O pior caso de complexidade na preparaÃ§Ã£o de um estado quÃ¢ntico arbitrÃ¡rio (dados nÃ£o
estruturados) Ã© exponencial no nÃºmero de qubits (SHENDE; BULLOCK; MARKOV, 2006). Por este
motivo, as vantagens quÃ¢nticas (BIAMONTE et al., 2017) mais significativas ocorrem quando
o algoritmo quÃ¢ntico opera em um estado de entrada que Ã© fÃ¡cil de preparar (DEUTSCH;
JOZSA, 1992; HOGG; HUBERMAN; WILLIAMS, 1996; GROVER, 1996; SIMON, 1997; TERHAL;
SMOLIN, 1998; SHOR, 1999), tais como a superposiÃ§Ã£o uniforme de todos os estados da base
computacional (MOZAFARI et al., 2020; MOZAFARI et al., 2021), os estados esparsos (MALVETTI;
ITEN; COLBECK, 2021; VERAS; SILVA; SILVA, 2022; GLEINIG; HOEFLER, 2021) e as distribuiÃ§Ãµes
de probabilidade (ZOUFAL; LUCCHI; WOERNER, 2019; NAKAJI et al., 2021; MARIN-SANCHEZ;
GONZALEZ-CONDE; SANZ, 2021).
Figura 4 â€“ RepresentaÃ§Ã£o de estados quÃ¢nticos uniforme e arbitrÃ¡rio.
0
5
10
15
20
25
30
computational basis state
0.00
0.02
0.04
0.06
0.08
0.10
probability
0
5
10
15
20
25
30
computational basis state
0.00
0.02
0.04
0.06
0.08
0.10
probability
Fonte: Elaborada pelo autor (2022)
Para algoritmos que dependam do carregamento de dados em um estado quÃ¢ntico arbitrÃ¡-
rio, uma maneira eficiente de preparar os estados de entrada Ã© um prÃ©-requisito fundamental
para a vantagem quÃ¢ntica (RÃ¸NNOW et al., 2014; AARONSON, 2015; BIAMONTE et al., 2017;
HARROW; HASSIDIM; LLOYD, 2009; TANG, 2021). VÃ¡rias pesquisas se concentram no desen-
volvimento de algoritmos que supÃµem uma inicializaÃ§Ã£o eficiente dos dados. Tal suposiÃ§Ã£o Ã©
o que leva Ã s declaraÃ§Ãµes de vantagens exponenciais anunciadas por diversos trabalhos (WI-
EBE; BRAUN; LLOYD, 2012; LLOYD; MOHSENI; REBENTROST, 2014; REBENTROST; MOHSENI;
LLOYD, 2014; WIEBE; KAPOOR; SVORE, 2014; AMIN et al., 2018; DUNJKO; TAYLOR; BRIEGEL,

20
2016; KIEFEROVÃ; WIEBE, 2017; LOW; YODER; CHUANG, 2014; WIEBE; GRANDADE, 2017; WIEBE;
KAPOOR; SVORE, 2016).
1.1.2
PreparaÃ§Ã£o de estados quÃ¢nticos em dispositivos ruidosos
A soluÃ§Ã£o para o problema da complexidade na preparaÃ§Ã£o de estados torna-se ainda mais
relevante sob as limitaÃ§Ãµes do hardware quÃ¢ntico ruidoso de escala intermediÃ¡ria (NISQ, do in-
glÃªs Noisy Intermediate-Scale Quantum) (MOLL et al., 2018; PRESKILL, 2018) como nÃºmero de
qubits limitado, conectividade restrita entre os qubits, erros de portas e decoerÃªncia (WILLSCH
et al., 2017). Tais limitaÃ§Ãµes impedem que tÃ©cnicas de correÃ§Ã£o de erros sejam aplicadas e tam-
bÃ©m restringem o uso de tais dispositivos a aplicaÃ§Ãµes com circuitos de baixa profundidade.
Uma alternativa Ã© a produÃ§Ã£o de soluÃ§Ãµes adaptadas Ã s limitaÃ§Ãµes dos dispositivos NISQ.
Por causa do ruÃ­do e do nÃºmero limitado de qubits, a profundidade de um algoritmo
quÃ¢ntico â€“ correspondente Ã  profundidade do circuito quÃ¢ntico produzido pelo algoritmo â€“ e
tambÃ©m sua largura â€“ nÃºmero de qubits do circuito â€“ precisam ser controladas. A EquaÃ§Ã£o (1.1)
pode ser usada para determinar os limites para a execuÃ§Ã£o de um algoritmo num determinado
dispositivo quÃ¢ntico (LEYMANN; BARZEN, 2020)
ğ‘‘Â· ğ‘¤â‰ª1
ğœ–
(1.1)
onde ğœ–Ã© a taxa de erro do computador quÃ¢ntico, ğ‘‘a profundidade do algoritmo, e ğ‘¤a lar-
gura (WILLSCH et al., 2017). Portanto, se um algoritmo requer profundidade grande, deve usar
apenas poucos qubits e assim pode ser simulado num computador clÃ¡ssico. Mas se um algo-
ritmo requer muitos qubits, precisa ser raso. Isso implica que a vantagem quÃ¢ntica â€“ soluÃ§Ãµes
que nÃ£o podem ser simuladas em computadores clÃ¡ssicos com espaÃ§o/tempo viÃ¡vel (PRES-
KILL, 2012; PRESKILL, 2018) â€“ em dispositivos sem correÃ§Ã£o de erros tem que ser exibida por
algoritmos rasos, que possuam poucas camadas de portas.
1.2
OBJETIVOS
O objetivo principal desta tese Ã© reduzir a complexidade computacional de circuitos â€“
profundidade e largura â€“ para a inicializaÃ§Ã£o de estados quÃ¢nticos. Os objetivos especÃ­ficos
sÃ£o:

21
1. Trocar profundidade do circuito quÃ¢ntico por largura para reduzir a complexidade tempo-
ral da inicializaÃ§Ã£o de estados exatos (Divide-and-Conquer quantum State Preparation,
SeÃ§Ã£o 4.1 e Bidirectional quantum State Preparation, SeÃ§Ã£o 4.2).
2. Utilizar o emaranhamento como recurso computacional para otimizar os circuitos quÃ¢n-
ticos produzidos para a inicializaÃ§Ã£o de estados exatos, reduzindo a quantidade de ope-
raÃ§Ãµes necessÃ¡rias (Low-Rank quantum State Preparation, SeÃ§Ã£o 4.3).
3. Manipular o emaranhamento para produzir estados aproximados de menor complexidade,
otimizados para a inicializaÃ§Ã£o em dispositivos NISQ (Bounded Approximation error state
preparation Algorithm, SeÃ§Ã£o 4.3).

22
2 PRINCIPAIS FUNDAMENTOS E REFERÃŠNCIAS
2.1
DECOMPOSIÃ‡ÃƒO DE UNITÃRIOS
A decomposiÃ§Ã£o de unitÃ¡rios permite que os algoritmos quÃ¢nticos, baseados em circuitos,
especifiquem operadores arbitrÃ¡rios que podem ser executados nos computadores quÃ¢nticos.
Sem essa decomposiÃ§Ã£o, os algoritmos quÃ¢nticos teriam que ser construÃ­dos utilizando apenas
o conjunto universal de portas do dispositivo alvo (DIVINCENZO, 1995; BARENCO, 1995; LLOYD,
1995; DEUTSCH; BARENCO; EKERT, 1995).
2.1.1
UnitÃ¡rios de um qubit
Um operador arbitrÃ¡rio de um qubit pode ser decomposto como uma sequÃªncia de no
mÃ¡ximo trÃªs portas ğ‘…ğ‘¦e ğ‘…ğ‘§(BARENCO et al., 1995; NIELSEN; CHUANG, 2010) usando a de-
composiÃ§Ã£o ZYZ1 (SHENDE; MARKOV; BULLOCK, 2004a). Dada qualquer matriz unitÃ¡ria ğ‘ˆ2Ã—2,
existem Ã¢ngulos ğœ‘, ğ›¼, ğ›½, e ğ›¾que satisfazem a seguinte equaÃ§Ã£o:
ğ‘ˆ= ğ‘’ğ‘–ğœ‘ğ‘…ğ‘§(ğ›¼)ğ‘…ğ‘¦(ğ›½)ğ‘…ğ‘§(ğ›¾).
(2.1)
Tal decomposiÃ§Ã£o Ã© possÃ­vel porque as linhas e colunas de matrizes unitÃ¡rias sÃ£o vetores
ortonormais, portanto toda matriz unitÃ¡ria 2 Ã— 2 pode ser escrita na forma (BARENCO et al.,
1995; NIELSEN; CHUANG, 2010)
â¡
â¢â¢â£
ğ‘’ğ‘–(ğœ‘+ ğ›¼
2 + ğ›¾
2 ) cos ğ›½
2
ğ‘’ğ‘–(ğœ‘+ ğ›¼
2 âˆ’ğ›¾
2 ) sin ğ›½
2
âˆ’ğ‘’ğ‘–(ğœ‘âˆ’ğ›¼
2 + ğ›¾
2 ) sin ğ›½
2
ğ‘’ğ‘–(ğœ‘âˆ’ğ›¼
2 âˆ’ğ›¾
2 ) cos ğ›½
2
â¤
â¥â¥â¦.
(2.2)
A partir da matriz (2.2), a fatoraÃ§Ã£o na forma da expressÃ£o (2.1) Ã© imediata.
Para o caso em que ğ‘ˆ2Ã—2 pertence ao grupo especial unitÃ¡rio ğ‘†ğ‘ˆ(2), a propriedade
det(ğ‘ˆ) = 1 implica que ğ‘’ğ‘–ğœ‘= Â±1. Assim, a expressÃ£o (2.1) pode ser simplificada para:
ğ‘ˆ= ğ‘…ğ‘§(ğ›¼)ğ‘…ğ‘¦(ğ›½)ğ‘…ğ‘§(ğ›¾).
(2.3)
1
A escolha dos eixos ğ‘¦e ğ‘§Ã© arbitrÃ¡ria. Qualquer par de vetores ortogonais pode ser escolhido.

23
2.1.2
UnitÃ¡rios de dois qubits
A sÃ­ntese de operadores de dois qubits Ã© relevante para a otimizaÃ§Ã£o de circuitos maiores.
A tecnologia atual dos dispositivos quÃ¢nticos nÃ£o Ã© capaz de executar operaÃ§Ãµes que atuem
em trÃªs ou mais qubits. Tais operaÃ§Ãµes precisam ser decompostas utilizando portas menores.
Portanto, implementar uma computaÃ§Ã£o quÃ¢ntica como uma sequÃªncia de portas de dois qubits
Ã© de fundamental importÃ¢ncia. Por sua vez, as portas arbitrÃ¡rias de dois qubits precisam ser
decompostas usando a porta padrÃ£o de dois qubits do conjunto de portas nativas do dispositivo
alvo, alÃ©m de portas de um qubit (DIVINCENZO, 2000). O CNOT Ã© utilizado como o operador
padrÃ£o de dois qubits na maioria dos trabalhos teÃ³ricos e prÃ¡ticos (WILLIAMS, 2011), mas sua
implementaÃ§Ã£o Ã© ordens de magnitude (âˆ¼102) mais propensa a erros do que a implementaÃ§Ã£o
das portas de um qubit. Por esse motivo, uma forma de calcular o custo da execuÃ§Ã£o dos
circuitos em dispositivos quÃ¢nticos Ã© em termos do nÃºmero de CNOTs. Sendo assim, o custo
da decomposiÃ§Ã£o de operadores de dois qubits precisa ser minimizado, pois tem impacto direto
no custo das aplicaÃ§Ãµes quÃ¢nticas.
De maneira geral, todo operador de dois qubits pode ser representado pelo circuito da
Figura 5 utilizando dezoito portas elementares â€“ trÃªs CNOTs e quinze rotaÃ§Ãµes de um qu-
bit (SHENDE; MARKOV; BULLOCK, 2004a; SHENDE; MARKOV; BULLOCK, 2004b).
Figura 5 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits.
Râ€ 
z
Râ€ 
y
Ry
Fonte: Elaborada pelo autor (2022)
Para demonstrar que essa decomposiÃ§Ã£o Ã© possÃ­vel, comeÃ§amos reescrevendo ğ‘ˆâˆˆğ‘ˆ(4)
como
ğ‘ˆâ€² = ğ‘’ğ‘–ğœ‹
4 SWAP2
1ğ‘ˆâˆˆğ‘†ğ‘ˆ(4).
(2.4)
A decomposiÃ§Ã£o canÃ´nica de ğ‘†ğ‘ˆ(4) (KHANEJA; BROCKETT; GLASER, 2001) afirma que existe
ğ‘, ğ‘, ğ‘e ğ‘‘âˆˆğ‘†ğ‘ˆ(2) e a diagonal ğ›¿na base mÃ¡gica (HILL; WOOTTERS, 1997; KRAUS; CIRAC,
2001) de maneira que
ğ‘ˆâ€² = (ğ‘âŠ—ğ‘)ğ›¿(ğ‘âŠ—ğ‘‘).
(2.5)
Podemos reescrever a expressÃ£o (2.5) como ğ‘ˆâ€² = (ğ‘âŠ—ğ‘)ğ¸Î”ğ¸â€ (ğ‘âŠ—ğ‘‘), onde Î” Ã© uma
diagonal na base computacional, usando a matriz ğ¸de mudanÃ§a de base (operador de dois

24
qubits que mapeia a base computacional para a base mÃ¡gica) (KHANEJA; BROCKETT; GLASER,
2001) e definindo ğ‘†ğ‘š:= ğ‘…ğ‘š(ğœ‹/2) (ğ‘šâˆˆ{ğ‘¥, ğ‘¦, ğ‘§})
ğ¸=
âˆš
2
2
â¡
â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â£
1
ğ‘–
0
0
0
0
ğ‘–
1
0
0
ğ‘–
âˆ’1
1
âˆ’ğ‘–
0
0
â¤
â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¦
=
Sz
Sâ€ 
x
Sâ€ 
z
(2.6)
Sabendo que toda diagonal ğ‘†ğ‘ˆ(4) pode ser representada como (KHANEJA; BROCKETT; GLA-
SER, 2001)
Î” =
â¡
â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â£
ğ‘’ğ‘–ğœƒ
0
0
0
0
ğ‘’ğ‘–ğœ‘
0
0
0
0
ğ‘’ğ‘–ğœ“
0
0
0
0
ğ‘’âˆ’ğ‘–(ğœƒ+ğœ‘+ğœ“)
â¤
â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¦
=
Râ€ 
z(Î¸ + Ï•)
Râ€ 
z(Î¸ + Ïˆ)
Rz(Ï• + Ïˆ)
(2.7)
construÃ­mos o circuito da Figura 6 para ğ‘ˆâ€²:
Figura 6 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits sem simplificaÃ§Ãµes.
Eâ€ 
âˆ†
E
c
Sâ€ 
z
Râ€ 
z
Sz
a
d
Sz
Sx
Râ€ 
z
Rz
Sâ€ 
x
Sâ€ 
z
b
Fonte: Elaborada pelo autor (2022)
O circuito acima pode ser simplificado fazendo ğ‘‘ğ‘†ğ‘§= ğ‘‘â€², ğ‘†â€ 
ğ‘§ğ‘= ğ‘â€², ğ‘†â€ 
ğ‘§ğ‘…â€ 
ğ‘§ğ‘†ğ‘§= ğ‘…â€ 
ğ‘§, ğ‘†ğ‘¥ğ‘…â€ 
ğ‘§=
ğ‘…â€ 
ğ‘¦ğ‘†ğ‘¥e ğ‘…ğ‘§ğ‘†â€ 
ğ‘¥= ğ‘†â€ 
ğ‘¥ğ‘…ğ‘¦(âƒ—ğ‘›âŠ¥âƒ—ğ‘šâˆ’â†’ğ‘†ğ‘›ğ‘…ğ‘š= ğ‘…ğ‘›Ã—ğ‘šğ‘†ğ‘›), e cancelando ğ‘†ğ‘¥e ğ‘†â€ 
ğ‘¥nas duas Ãºltimas
expressÃµes, como na Figura 7.
Figura 7 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits com simplificaÃ§Ãµes.
c
Râ€ 
z
a
dâ€²
Râ€ 
y
Ry
bâ€²
=
c
Râ€ 
z
bâ€²
dâ€²
Râ€ 
y
Ry
a
Fonte: Elaborada pelo autor (2022)
Ainda na Figura 7, os dois CNOTs adjacentes sÃ£o substituÃ­dos por um CNOT e um SWAP.
O SWAP foi movido para o fim do circuito e serÃ¡ cancelado pelo SWAP da expressÃ£o (2.4).

25
Portanto, o circuito da Figura 5 representa o unitÃ¡rio ğ‘ˆ, com exceÃ§Ã£o apenas da fase global
ğ‘’ğ‘–ğœ‹
4 que precisa ser corrigida.
Ainda Ã© possÃ­vel alcanÃ§ar um circuito mais otimizado que o da Figura 5 para os casos em que
vÃ¡rios operadores adjacentes atuam no mesmo conjunto de qubits. Um operador ğ‘ˆâ€²â€² âˆˆğ‘†ğ‘ˆ(4)
pode ser representado usando apenas dois CNOTs e portas de um qubit ğ‘†ğ‘ˆ(2) arbitrÃ¡rias se
tr [ğ›¾(ğ‘ˆâ€²â€²)] Ã© real (SHENDE; BULLOCK; MARKOV, 2004c), onde ğ›¾(ğ‘ˆâ€²â€²) = (ğ¸â€ ğ‘ˆâ€²â€²ğ¸)(ğ¸â€ ğ‘ˆâ€²â€²ğ¸)ğ‘‡.
Sabendo que o operador arbitrÃ¡rio ğ‘ˆâ€² pode ser decomposto como ğ‘ˆâ€² = ğ·ğ‘ˆâ€²â€², onde ğ·Ã© um
operador diagonal, temos o circuito da Figura 8 (SHENDE; BULLOCK; MARKOV, 2006).
Figura 8 â€“ DecomposiÃ§Ã£o de unitÃ¡rios arbitrÃ¡rios de dois qubits atÃ© uma diagonal.
D
Ry
Ry
Fonte: Elaborada pelo autor (2022)
Dessa maneira, a diagonal pode migrar para o prÃ³ximo operador de dois qubits adjacente. Esse
outro operador Ã© decomposto da mesma forma, continuando o processo de migrar a diagonal
atÃ© restar apenas um operador. Como um CNOT Ã© salvo para cada operador de dois qubits
menos o Ãºltimo, temos uma reduÃ§Ã£o total de ğ‘€âˆ’1 CNOTs em relaÃ§Ã£o Ã  decomposiÃ§Ã£o da
Figura 5, onde ğ‘€Ã© o nÃºmero total de operadores adjacentes.
2.1.3
DecomposiÃ§Ã£o Cosseno-Seno
A decomposiÃ§Ã£o cosseno-seno de unitÃ¡rios (Cosine-Sine Decomposition ou CSD) Ã© baseada
na tÃ©cnica matemÃ¡tica de mesmo nome decomposiÃ§Ã£o cosseno-seno (STEWART; SUN, 1990;
PAIGE; WEI, 1994). Supondo um unitÃ¡rio ğ‘ˆâˆˆCğ‘Ã—ğ‘, onde ğ‘Ã© par, o teorema CSD afirma
que ğ‘ˆsempre pode ser decomposto na seguinte forma
ğ‘ˆ= ğ‘…ğ·ğ‘ğ‘ ğ¿=
â¡
â¢â¢â£
ğ‘…0
0
0
ğ‘…1
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¶
âˆ’ğ‘†
ğ‘†
ğ¶
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¿0
0
0
ğ¿1
â¤
â¥â¥â¦,
(2.8)
composta por unitÃ¡rios ğ¿ğ‘–, ğ‘…ğ‘–âˆˆCğ‘/2Ã—ğ‘/2 e matrizes diagonais reais ğ¶e ğ‘†tais que ğ¶2+ğ‘†2 =
Iğ‘/2, onde ğ¶= diag(cos(ğœƒ0), . . . , cos(ğœƒğ‘/2)) e ğ‘†= diag(sin(ğœƒ0), . . . , sin(ğœƒğ‘/2)).
O algoritmo CSD (TUCCI, 1999; SHENDE; BULLOCK; MARKOV, 2006) aplica a decomposiÃ§Ã£o
cosseno-seno recursivamente. Inicia com o operador ğ‘ˆde dimensÃ£o ğ‘Ã— ğ‘, onde ğ‘= 2ğ‘›e

26
ğ‘›â‰¥1 Ã© o nÃºmero de qubits. ğ‘ˆÃ© decomposto na matriz ğ·ğ‘ğ‘ , dois unitÃ¡rios ğ¿ğ‘–e dois unitÃ¡rios
ğ‘…ğ‘–(EquaÃ§Ã£o 2.8 e Figura 9). Em seguida, os quatro unitÃ¡rios produzidos no passo anterior sÃ£o
decompostos em quatro matrizes centrais e dezesseis unitÃ¡rios, como na EquaÃ§Ã£o (2.9). Os
unitÃ¡rios formam quatro conjuntos ğ‘…ğ‘…0 +ğ‘…ğ‘…1, ğ¿ğ‘…0 +ğ¿ğ‘…1, ğ‘…ğ¿0 +ğ‘…ğ¿1 e ğ¿ğ¿0 +ğ¿ğ¿1 (Figura 10),
cada conjunto com quatro operadores.
ğ‘ˆ=
â¡
â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â£
â¡
â¢â¢â£
ğ‘…ğ‘…0,0
0
0
ğ‘…ğ‘…0,1
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¶ğ‘…0
âˆ’ğ‘†ğ‘…0
ğ‘†ğ‘…0
ğ¶ğ‘…0
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¿ğ‘…0,0
0
0
ğ¿ğ‘…0,1
â¤
â¥â¥â¦
0
0
â¡
â¢â¢â£
ğ‘…ğ‘…1,0
0
0
ğ‘…ğ‘…1,1
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¶ğ‘…1
âˆ’ğ‘†ğ‘…1
ğ‘†ğ‘…1
ğ¶ğ‘…1
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¿ğ‘…1,0
0
0
ğ¿ğ‘…1,1
â¤
â¥â¥â¦
â¤
â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¦
â¡
â¢â¢â£
ğ¶
âˆ’ğ‘†
ğ‘†
ğ¶
â¤
â¥â¥â¦
â¡
â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â¢â£
â¡
â¢â¢â£
ğ‘…ğ¿0,0
0
0
ğ‘…ğ¿0,1
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¶ğ¿0
âˆ’ğ‘†ğ¿0
ğ‘†ğ¿0
ğ¶ğ¿0
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¿ğ¿0,0
0
0
ğ¿ğ¿0,1
â¤
â¥â¥â¦
0
0
â¡
â¢â¢â£
ğ‘…ğ¿1,0
0
0
ğ‘…ğ¿1,1
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¶ğ¿1
âˆ’ğ‘†ğ¿1
ğ‘†ğ¿1
ğ¶ğ¿1
â¤
â¥â¥â¦
â¡
â¢â¢â£
ğ¿ğ¿1,0
0
0
ğ¿ğ¿1,1
â¤
â¥â¥â¦
â¤
â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¥â¦
.
(2.9)
A recursÃ£o continua atÃ© que os unitÃ¡rios possuam dimensÃ£o 2Ã—2 (operadores de um qubit).
No fim, apÃ³s ğ‘›âˆ’1 iteraÃ§Ãµes, haverÃ¡ 2ğ‘›âˆ’1 conjuntos de unitÃ¡rios, cada um com 2ğ‘›âˆ’1 operadores
de um qubit. Cada conjunto corresponde a um operador uniformemente controlado pelos qubits
mais significativos e aplicado ao qubit menos significativo (Figura 9) (SHENDE; BULLOCK;
MARKOV, 2006). Esses conjuntos sÃ£o separados pelos operadores centrais (Figura 10), que
Figura 9 â€“ Identidades utilizadas para a decomposiÃ§Ã£o cosseno-seno (CSD) de operadores quÃ¢nticos.
U
=
â–¡
â–¡
â–¡
Ry
L
R
â–¡
U
=
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
Ry
L
R
Fonte: Elaborada pelo autor (2022)
possuem a mesma estrutura das rotaÃ§Ãµes ğ‘…ğ‘¦uniformemente controladas aplicadas ao qubit
correspondente ao passo da recursÃ£o (SHENDE; BULLOCK; MARKOV, 2006). Essa decomposiÃ§Ã£o
requer um total de 4ğ‘›âˆ’2ğ‘›+1 CNOTs.
2.1.4
DecomposiÃ§Ã£o de Shannon QuÃ¢ntica
O algoritmo para a decomposiÃ§Ã£o de Shannon QuÃ¢ntica (Quantum Shannon Decomposi-
tion ou QSD) Ã© uma variaÃ§Ã£o do algoritmo CSD apresentado na SeÃ§Ã£o 2.1.3. A mudanÃ§a Ã©

27
Figura 10 â€“ Circuito para a decomposiÃ§Ã£o cosseno-seno (CSD) de um operador quÃ¢ntico de trÃªs qubits.
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
â–¡
Ry
Ry
Ry
LL0 + LL1
RL0 + RL1
LR0 + LR1
RR0 + RR1
Fonte: Elaborada pelo autor (2022)
feita na decomposiÃ§Ã£o dos operadores ğ¿e ğ‘…uniformemente controlados na primeira identi-
dade da Figura 9. Sendo ğ‘ˆ= ğ‘ˆ0 âŠ•ğ‘ˆ1 (assim como as matrizes ğ¿e ğ‘…do CSD), podemos
encontrar os unitÃ¡rios ğ‘„e ğ‘Še a diagonal ğ·que satisfazem (SHENDE; BULLOCK; MARKOV,
2006)
ğ‘ˆ= (ğ¼âŠ—ğ‘„)(ğ·âŠ•ğ·â€ )(ğ¼âŠ—ğ‘Š).
(2.10)
A partir da EquaÃ§Ã£o (2.10), temos que ğ‘ˆ0 = ğ‘„ğ·ğ‘Še ğ‘ˆ1 = ğ‘„ğ·â€ ğ‘Š, o que implica ğ‘ˆ0ğ‘ˆâ€ 
1 =
ğ‘„ğ·2ğ‘„â€ . Temos entÃ£o que ğ·e ğ‘„podem ser calculados atravÃ©s de diagonalizaÃ§Ã£o. O unitÃ¡rio
ğ‘Špode ser encontrado usando as relaÃ§Ãµes ğ‘Š= ğ·â€ ğ‘„â€ ğ‘ˆ0 ou ğ‘Š= ğ·ğ‘„â€ ğ‘ˆ1. Sabendo que a
diagonal ğ·Ã© composta pelos autovalores da diagonalizaÃ§Ã£o, a matriz ğ·âŠ•ğ·â€  pode ser repre-
sentada por uma rotaÃ§Ã£o ğ‘…ğ‘§uniformemente controlada aplicada ao qubit mais significativo
(Figura 11) (SHENDE; BULLOCK; MARKOV, 2006).
Figura 11 â€“ Identidade utilizada para a decomposiÃ§Ã£o de Shannon (QSD) de operadores quÃ¢nticos.
â–¡
U
=
â–¡
Rz
W
Q
Fonte: Elaborada pelo autor (2022)
De maneira semelhante ao algoritmo CSD, o QSD aplica as identidades definidas na Fi-
gura 9 e na Figura 11 recursivamente. Inicia aplicando a primeira identidade da Figura 9 para
decompor o operador ğ‘ˆâˆˆCğ‘Ã—ğ‘em uma matriz central ğ·ğ‘ğ‘ e unitÃ¡rios ğ¿ğ‘–e ğ‘…ğ‘–. Em seguida, a
identidade da Figura 11 Ã© aplicada aos operadores ğ¿e ğ‘…, decompondo-os na diagonal ğ·âŠ•ğ·â€ 
e nos unitÃ¡rios ğ‘Še ğ‘„de dimensÃ£o ğ‘/2 Ã— ğ‘/2 (Figura 12). O procedimento Ã© reiniciado a
partir da primeira identidade, atuando sobre os operadores ğ‘Še ğ‘„, e continua atÃ© que esses
operadores possuam dimensÃ£o 2 Ã— 2 representando portas de um qubit. A decomposiÃ§Ã£o ZYZ
utilizada para representar os operadores de um qubit nÃ£o possuem CNOTs, portanto apenas
as rotaÃ§Ãµes uniformemente controladas contribuem para o nÃºmero total de CNOTs no circuito
3
44ğ‘›âˆ’3
22ğ‘›(SHENDE; BULLOCK; MARKOV, 2006).

28
Figura 12 â€“ Circuito para a decomposiÃ§Ã£o de Shannon (QSD) de um operador quÃ¢ntico de dois qubits.
â–¡
â–¡
â–¡
Rz
Ry
Rz
WL
QL
WR
QR
Fonte: Elaborada pelo autor (2022)
Se a recursÃ£o encerrar quando os operadores ğ‘„e ğ‘Šatuarem sobre dois qubits, haverÃ¡
4ğ‘›âˆ’2 operadores desse tipo e menos 3 Ã— 4ğ‘›âˆ’2 rotaÃ§Ãµes uniformemente controladas por um
qubit. Utilizando a decomposiÃ§Ã£o da SeÃ§Ã£o 2.1.2, cada operador de dois qubits contribui com
3 CNOTs. Cada rotaÃ§Ã£o uniformemente controlada atuando sobre dois qubits contribui com
2 CNOTs (ITEN et al., 2016). Portanto, a contagem de CNOTs diminui 3 Ã— 4ğ‘›âˆ’2 e o total Ã©
reduzido para
9
164ğ‘›âˆ’3
22ğ‘›. Essa variante do algoritmo foi chamada de QSD (ğ‘™= 2) por Shende,
Bullock e Markov (2006), onde ğ‘™indica o nÃºmero de qubits em que a recursÃ£o encerra. O caso
anterior, que encerra em operadores de um qubit, chama-se QSD (ğ‘™= 1).
O QSD (ğ‘™= 2) ainda pode ser otimizado de duas maneiras (SHENDE; BULLOCK; MARKOV,
2006). A primeira, quando a recursÃ£o encerra em operadores ğ‘‰e ğ‘Šatuando sobre dois qubits,
aplica a otimizaÃ§Ã£o indicada pela Figura 8 da SeÃ§Ã£o 2.1.2, reduzindo 4ğ‘›âˆ’2 âˆ’1 CNOTs (um
CNOT por operador de dois qubits, com exceÃ§Ã£o do Ãºltimo). A segunda otimizaÃ§Ã£o utiliza
portas CZ (Controlled-Z) no lugar de CNOTs para decompor as matrizes centrais, pois o Ãºltimo
CZ pode ser absorvido pelo multiplexador vizinho, salvando (4ğ‘›âˆ’2 âˆ’1)/3 CNOTs. Com ambas
as otimizaÃ§Ãµes, o nÃºmero total de CNOTs Ã© reduzido para 23
484ğ‘›âˆ’3
22ğ‘›+ 4
3. AtÃ© o momento,
essa Ã© a decomposiÃ§Ã£o mais eficiente para unitÃ¡rios gerais. Shende, Bullock e Markov (2006)
chamou essa decomposiÃ§Ã£o otimizada de QSD (ğ‘™= 2, otimizada).
2.2
TIPO DE PREPARAÃ‡ÃƒO DE ESTADOS QUÃ‚NTICOS
Para codificar um vetor de entrada clÃ¡ssico em um estado quÃ¢ntico Ã© necessÃ¡rio construir
um circuito quÃ¢ntico que prepare tal estado (CORTESE; BRAJE, 2018). Esse circuito Ã© gerado
numa fase de prÃ©-processamento clÃ¡ssico aplicando instruÃ§Ãµes quÃ¢nticas do dispositivo alvo.
As fases de prÃ©-processamento clÃ¡ssico e de inicializaÃ§Ã£o do estado quÃ¢ntico combinadas â€“
chamadas de preparaÃ§Ã£o de estados quÃ¢nticos (Figura 2 e Figura 3) â€“ formam o principal
objeto de estudo desta pesquisa.

29
2.2.1
CodificaÃ§Ã£o na base
Essa codificaÃ§Ã£o transforma o nÃºmero binÃ¡rio ğ‘¥âˆˆ{0, 1}ğ‘›em um estado quÃ¢ntico na base
computacional. O circuito quÃ¢ntico correspondente Ã© gerado pela aplicaÃ§Ã£o de portas ğ‘‹no
qubit ğ‘–quando ğ‘¥ğ‘–= 1. A execuÃ§Ã£o desse circuito produzirÃ¡ o estado quÃ¢ntico representando
o nÃºmero binÃ¡rio ğ‘¥.
O mÃ©todo Ã© utilizado de diversas formas. Por exemplo, um vetor x = (ğ‘¥1, . . . , ğ‘¥ğ‘€), onde
1 â‰¤ğ‘€â‰¤2ğ‘›, pode ser codificado atravÃ©s da transformaÃ§Ã£o de cada componente ğ‘¥ğ‘—em
estados da base e da concatenaÃ§Ã£o das codificaÃ§Ãµes resultantes. De maneira mais sofisticada,
podemos representar o vetor x numa superposiÃ§Ã£o uniforme dos estados dos seus componentes
codificados binariamente (VENTURA; MARTINEZ, 2000; SCHULD; PETRUCCIONE, 2018)
|xâŸ©=
1
âˆš
ğ‘€
ğ‘€
âˆ‘ï¸
ğ‘—=1
|ğ‘¥ğ‘—âŸ©.
(2.11)
2.2.2
CodificaÃ§Ã£o nos Ã¢ngulos
Essa codificaÃ§Ã£o mapeia cada componente ğ‘¥ğ‘—do vetor x âˆˆCğ‘como rotaÃ§Ãµes ğ‘…ğ‘¦e ğ‘…ğ‘§de
qubits individuais (Figura 13). O procedimento consiste em redimensionar o mÃ³dulo de cada
elemento vetorial de dados ğ‘¥ğ‘—dentro da faixa [0, ğœ‹] para depois codificÃ¡-lo em um qubit ğ‘ğ‘—.
Dados ğ›¼ğ‘—= abs(ğ‘¥ğ‘—) e ğœ†ğ‘—= arg(ğ‘¥ğ‘—), temos para cada qubit
|ğ‘ğ‘—âŸ©= cos
(ï¸‚ğ›¼ğ‘—
2
)ï¸‚
|0âŸ©+ ğ‘’ğ‘–ğœ†ğ‘—sin
(ï¸‚ğ›¼ğ‘—
2
)ï¸‚
|1âŸ©.
Ã‰ menos eficiente em termos de espaÃ§o comparado Ã  codificaÃ§Ã£o nas amplitudes, exigindo
ğ‘qubits para codificar um vetor de dados ğ‘-dimensional (STOUDENMIRE; SCHWAB, 2016).
Mas a preparaÃ§Ã£o do estado Ã© simples, pois requer apenas rotaÃ§Ãµes de um qubit.
Figura 13 â€“ CodificaÃ§Ã£o em Ã¢ngulos de qubits utilizando rotaÃ§Ãµes.
|0âŸ©0
Ry(Î±0)
Rz(Î»0)
|0âŸ©1
Ry(Î±1)
Rz(Î»1)
|0âŸ©2
Ry(Î±2)
Rz(Î»2)
Fonte: Elaborada pelo autor (2022)

30
2.2.3
CodificaÃ§Ã£o nas amplitudes
A codificaÃ§Ã£o do vetor x âˆˆCğ‘(|x| = 1) nas amplitudes de um estado quÃ¢ntico Ã© repre-
sentada por |xâŸ©= âˆ‘ï¸€
ğ‘—ğ‘¥ğ‘—|ğ‘—âŸ©. Essa codificaÃ§Ã£o requer ğ‘›= âŒˆlog2(ğ‘)âŒ‰qubits para representar
um dado ğ‘-dimensional.
Nossa pesquisa e as preparaÃ§Ãµes de estados baseadas em rotaÃ§Ãµes (SeÃ§Ã£o 2.3.1) e na
decomposiÃ§Ã£o de Schmidt (SeÃ§Ã£o 2.3.2) fazem parte desta abordagem. CodificaÃ§Ãµes deste
tipo conseguem preparar |xâŸ©a partir do estado |0âŸ©usando ğ‘‚(2ğ‘›) portas (MOTTONEN et al.,
2005; BERGHOLM et al., 2005; SHENDE; BULLOCK; MARKOV, 2006). Portanto, ela Ã© vantajosa
em relaÃ§Ã£o Ã s outras preparaÃ§Ãµes de estados quando o dispositivo quÃ¢ntico consegue executar
circuitos profundos e quando a dimensionalidade do vetor de entrada Ã© muito alta, tornando
impraticÃ¡vel utilizar outro tipo de preparaÃ§Ã£o de estados devido ao nÃºmero de qubits.
2.3
EXEMPLO DE PREPARAÃ‡ÃƒO DE ESTADOS QUÃ‚NTICOS
2.3.1
Baseada em rotaÃ§Ãµes
A preparaÃ§Ã£o de estados proposta por Mottonen et al. (2005) descreve o problema como a
busca por um operador ğ‘ˆque transforma um vetor de estado arbitrÃ¡rio |ğ‘¥âŸ©= âˆ‘ï¸€
ğ‘|ğ‘¥ğ‘|ğ‘’ğ‘–ğ‘¤ğ‘|ğ‘âŸ©
em um vetor fixo |ğ‘ŸâŸ©. Por conveniÃªncia, o vetor fixo Ã© escolhido como o primeiro vetor da base
computacional |ğ‘ŸâŸ©= |0âŸ©. Conhecendo ğ‘ˆde maneira que ğ‘ˆ|ğ‘¥âŸ©= |0âŸ©, sempre podemos efetuar
a operaÃ§Ã£o inversa ğ‘ˆâ€  |0âŸ©= |ğ‘¥âŸ©, que Ã© a preparaÃ§Ã£o de estados. De fato, a transformaÃ§Ã£o
proposta Ã© composta apenas por rotaÃ§Ãµes uniformemente controladas, entÃ£o sua inversa Ã©
simples e podemos construÃ­-la diretamente, nÃ£o sendo necessÃ¡rio efetuar a inversÃ£o. Portanto,
a preparaÃ§Ã£o de estados baseada em rotaÃ§Ãµes pode ser definida como uma transformaÃ§Ã£o
linear consistindo de uma sequÃªncia de rotaÃ§Ãµes uniformemente controladas que transforma o
estado inicial |0âŸ©âŠ—ğ‘›no vetor arbitrÃ¡rio |ğ‘¥âŸ©.
Para explicar o procedimento, sÃ£o introduzidas as expressÃµes (2.12) e (2.13), definidas
pelo vetor x = (|ğ‘¥0|ğ‘’ğ‘–ğ‘¤0, . . . , |ğ‘¥ğ‘âˆ’1|ğ‘’ğ‘–ğ‘¤ğ‘âˆ’1) (MOTTONEN et al., 2005)
ğ›¼ğ‘—,ğ‘˜= 2asin
â›
âœ
â
â¯
â¸
â¸
â·
2ğ‘˜âˆ’1
âˆ‘ï¸
ğ‘™=1
|ğ‘¥(2ğ‘—âˆ’1)2ğ‘˜âˆ’1+ğ‘™|2/
â¯
â¸
â¸
â·
2ğ‘˜
âˆ‘ï¸
ğ‘™=1
|ğ‘¥(ğ‘—âˆ’1)2ğ‘˜+ğ‘™|2
â
âŸ
â 
(2.12)
ğœ†ğ‘—,ğ‘˜=
2ğ‘˜âˆ’1
âˆ‘ï¸
ğ‘™=1
(ğœ”(2ğ‘—âˆ’1)2ğ‘˜âˆ’1+ğ‘™âˆ’ğœ”(2ğ‘—âˆ’2)2ğ‘˜âˆ’1+ğ‘™)/2ğ‘˜âˆ’1
(2.13)

31
Figura 14 â€“ InicializaÃ§Ã£o de um estado quÃ¢ntico de ğ‘›qubits usando rotaÃ§Ãµes para codificar um vetor de
entrada complexo de dimensÃ£o ğ‘= 2ğ‘›nas amplitudes do estado.
step 1
step 2
step n
. . .
. . .
. . .
. . .
. . .
. . .
...
...
...
...
...
...
...
...
. . .
. . .
. . .
. . .
. . .
. . .
|0âŸ©0
Ry(Î±1,n)
Rz(Î»1,n)
|0âŸ©1
Ry(Î±1,nâˆ’1)
Ry(Î±2,nâˆ’1)
Rz(Î»1,nâˆ’1)
Rz(Î»2,nâˆ’1)
|0âŸ©nâˆ’2
|0âŸ©nâˆ’1
Ry(Î±1,1)
Rz(Î»2nâˆ’1,1)
Fonte: Elaborada pelo autor (2022)
onde ğ‘—= 1, 2, . . . , 2ğ‘›âˆ’ğ‘˜, ğ‘˜= 1, 2, . . . , ğ‘›e ğ‘›= log2(ğ‘). Essas expressÃµes determinam Ã¢ngulos
de rotaÃ§Ã£o para a codificaÃ§Ã£o do vetor x. Os argumentos das fases do vetor |ğ‘¥âŸ©sÃ£o codificados
atravÃ©s de rotaÃ§Ãµes ğ‘…ğ‘§de Ã¢ngulos ğœ†ğ‘—,ğ‘˜e as magnitudes atravÃ©s de rotaÃ§Ãµes ğ‘…ğ‘¦de Ã¢ngulos
ğ›¼ğ‘—,ğ‘˜(Figura 14).
Figura 15 â€“ NÃºmero de CNOTs e a profundidade de circuitos produzidos pela biblioteca qclib usando a pre-
paraÃ§Ã£o de estados baseada em rotaÃ§Ãµes, em funÃ§Ã£o do logaritmo do comprimento da entrada
ğ‘›= log2(ğ‘).
2
4
6
8
10
12
14
0
10000
20000
30000
40000
50000
60000
n
(a) NÃºmero de CNOTs
2
4
6
8
10
12
14
0
20000
40000
60000
80000
100000
120000
n
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
O procedimento inicia preparando o seguinte estado para ğ‘˜= ğ‘›(estamos preparando a
inversa da transformaÃ§Ã£o, o que implica que a ordem de ğ‘˜Ã© invertida), onde ğ›½ğ‘—,ğ‘˜= sin(ğ›¼ğ‘—,ğ‘˜)/2
|ğœ“ğ‘›âŸ©= ğ‘’âˆ’ğ‘–
ğœ†1,ğ‘›
2
âˆšï¸
1 âˆ’|ğ›½1,ğ‘›|2 |0âŸ©+ ğ‘’ğ‘–
ğœ†1,ğ‘›
2 ğ›½1,ğ‘›|1âŸ©.
(2.14)
Esse estado pode ser construÃ­do com apenas duas rotaÃ§Ãµes no primeiro qubit (primeiro passo
da Figura 14). Em seguida, o estado da expressÃ£o (2.14) Ã© combinado com os valores do

32
segundo passo
|ğœ“ğ‘›âˆ’1âŸ©= |0âŸ©âŸ¨0|ğœ“ğ‘›âŸ©
(ï¸
ğ‘’âˆ’ğ‘–
ğœ†1,ğ‘›âˆ’1
2
âˆšï¸
1 âˆ’|ğ›½1,ğ‘›âˆ’1|2 |0âŸ©+ ğ‘’ğ‘–
ğœ†1,ğ‘›âˆ’1
2
ğ›½1,ğ‘›âˆ’1 |1âŸ©
)ï¸
+
|1âŸ©âŸ¨1|ğœ“ğ‘›âŸ©
(ï¸
ğ‘’âˆ’ğ‘–
ğœ†2,ğ‘›âˆ’1
2
âˆšï¸
1 âˆ’|ğ›½2,ğ‘›âˆ’1|2 |0âŸ©+ ğ‘’ğ‘–
ğœ†2,ğ‘›âˆ’1
2
ğ›½2,ğ‘›âˆ’1 |1âŸ©
)ï¸
|ğœ“ğ‘›âˆ’1âŸ©= ğ‘’âˆ’ğ‘–
ğœ†1,ğ‘›
2
âˆšï¸
1 âˆ’|ğ›½1,ğ‘›|2
(ï¸
ğ‘’âˆ’ğ‘–
ğœ†1,ğ‘›âˆ’1
2
âˆšï¸
1 âˆ’|ğ›½1,ğ‘›âˆ’1|2 |00âŸ©+ ğ‘’ğ‘–
ğœ†1,ğ‘›âˆ’1
2
ğ›½1,ğ‘›âˆ’1 |01âŸ©
)ï¸
+
ğ‘’ğ‘–
ğœ†1,ğ‘›
2 ğ›½1,ğ‘›
(ï¸
ğ‘’âˆ’ğ‘–
ğœ†2,ğ‘›âˆ’1
2
âˆšï¸
1 âˆ’|ğ›½2,ğ‘›âˆ’1|2 |10âŸ©+ ğ‘’ğ‘–
ğœ†2,ğ‘›âˆ’1
2
ğ›½2,ğ‘›âˆ’1 |11âŸ©
)ï¸
|ğœ“ğ‘›âˆ’1âŸ©= ğ‘’âˆ’ğ‘–
ğœ†1,ğ‘›
2
âˆšï¸
1 âˆ’|ğ›½1,ğ‘›|2
(ï¸
ğ‘’âˆ’ğ‘–
ğœ†1,ğ‘›âˆ’1
2
âˆšï¸
1 âˆ’|ğ›½1,ğ‘›âˆ’1|2 |0âŸ©+ ğ‘’ğ‘–
ğœ†1,ğ‘›âˆ’1
2
ğ›½1,ğ‘›âˆ’1 |1âŸ©
)ï¸
+
ğ‘’ğ‘–
ğœ†1,ğ‘›
2 ğ›½1,ğ‘›
(ï¸
ğ‘’âˆ’ğ‘–
ğœ†2,ğ‘›âˆ’1
2
âˆšï¸
1 âˆ’|ğ›½2,ğ‘›âˆ’1|2 |2âŸ©+ ğ‘’ğ‘–
ğœ†2,ğ‘›âˆ’1
2
ğ›½2,ğ‘›âˆ’1 |3âŸ©
)ï¸
EntÃ£o, os estados continuam a ser combinados com os valores dos passos seguintes
|ğœ“ğ‘˜âŸ©=
2ğ‘›âˆ’ğ‘˜
âˆ‘ï¸
ğ‘—=1
|ğ‘—âˆ’1âŸ©âŸ¨ğ‘—âˆ’1|ğœ“ğ‘˜+1âŸ©
(ï¸
ğ‘’âˆ’ğ‘–
ğœ†ğ‘—,ğ‘˜
2
âˆšï¸
1 âˆ’|ğ›½ğ‘—,ğ‘˜|2 |0âŸ©+ ğ‘’ğ‘–
ğœ†ğ‘—,ğ‘˜
2 ğ›½ğ‘—,ğ‘˜|1âŸ©
)ï¸
(2.15)
A atualizaÃ§Ã£o do estado |ğœ“ğ‘˜âŸ©Ã© repetida para ğ‘˜= (ğ‘›âˆ’1), . . . , 1, obtendo o estado desejado
|ğœ“1âŸ©= |ğ‘¥0|ğ‘’ğ‘–ğœ”0 |0âŸ©+ . . . + |ğ‘¥ğ‘âˆ’1|ğ‘’ğ‘–ğœ”ğ‘âˆ’1 |ğ‘âˆ’1âŸ©.
A combinaÃ§Ã£o dos estados Ã© realizada com rotaÃ§Ãµes multicontroladas. A cada passo, Ã© montada
uma sequÃªncia de rotaÃ§Ãµes sobre um qubit e controladas pelos qubits dos passos anteriores.
Primeiro, rotaÃ§Ãµes ğ‘…ğ‘¦sÃ£o aplicadas para determinar as magnitudes das amplitudes, seguidas
por rotaÃ§Ãµes ğ‘…ğ‘§para determinar as fases. Esses passos estÃ£o representados no Algoritmo 1 e
na Figura 14.
Algoritmo 1: PreparaÃ§Ã£o de estados baseada em rotaÃ§Ãµes
input : Um vetor de estado com 2ğ‘›amplitudes.
output: O circuito para a inicializaÃ§Ã£o do estado quÃ¢ntico.
1 Cria um circuito quÃ¢ntico com ğ‘›qubits (um qubit para cada passo)
2 Aplica uma rotaÃ§Ã£o ğ‘…ğ‘¦e uma rotaÃ§Ã£o ğ‘…ğ‘§no primeiro qubit usando os Ã¢ngulos ğ›¼1,ğ‘›e
ğœ†1,ğ‘£(Eq. 2.14)
3 Faz ğ‘˜= ğ‘›âˆ’1 (segundo passo)
4 Realiza uma RotaÃ§Ã£o Uniformemente Controlada controlada pelos qubits
0, 1, . . . , ğ‘›âˆ’ğ‘˜âˆ’1 (correspondendo aos passos anteriores) com o qubit atual ğ‘›âˆ’ğ‘˜
como alvo, usando ğ›¼ğ‘—,ğ‘˜e ğœ†ğ‘—,ğ‘˜(1 â‰¤ğ‘—â‰¤2ğ‘›âˆ’ğ‘˜) do passo corrente como Ã¢ngulos das
rotaÃ§Ãµes (Eq. 2.15)
5 Se ğ‘˜> 1, faz ğ‘˜= ğ‘˜âˆ’1 e retorna para a linha 3, caso contrÃ¡rio retorna o circuito
quÃ¢ntico para a inicializaÃ§Ã£o do estado.
Fonte: Elaborado pelo autor (2022)

33
2.3.2
Baseada na decomposiÃ§Ã£o de Schmidt
A preparaÃ§Ã£o de estados proposta por Plesch e Brukner (2011) Ã© baseada na decomposiÃ§Ã£o
de Schmidt. Dado um estado quÃ¢ntico |ğœ“âŸ©= âˆ‘ï¸€
ğ‘—ğœ†ğ‘—|ğ‘—âŸ©, o primeiro passo do algoritmo Ã©
executar a decomposiÃ§Ã£o de Schmidt |ğœ“âŸ©=
âˆ‘ï¸€
ğ‘–ğœğ‘–|ğ›¼ğ‘–âŸ©âŠ—|ğ›½ğ‘–âŸ©âˆˆâ„‹= â„‹ğ´âŠ—â„‹ğµonde o
estado Ã© fatorado em dois sistemas quÃ¢nticos â„‹ğ´e â„‹ğµ, ğœğ‘–sÃ£o os coeficientes de Schmidt,
{|ğ›¼ğ‘–âŸ©} âˆˆâ„‹ğ´e {|ğ›½ğ‘–âŸ©} âˆˆâ„‹ğµsÃ£o bases ortonormais, e 1 â‰¤ğ‘–â‰¤min(dim(â„‹ğ´), dim(â„‹ğµ)).
O segundo passo inicializa o estado quÃ¢ntico âˆ‘ï¸€
ğ‘–ğœğ‘–|ğ‘–âŸ©|0âŸ©no primeiro registrador quÃ¢ntico. O
objetivo deste passo Ã© inicializar um estado com os coeficientes de Schmidt codificados nas
amplitudes. O terceiro passo aplica âŒŠğ‘›/2âŒ‹CNOTs para criar o estado âˆ‘ï¸€
ğ‘–ğœğ‘–|ğ‘–âŸ©|ğ‘–âŸ©. Sendo ğ‘ˆ
e ğ‘‰unitÃ¡rios, onde ğ‘ˆ|ğ‘–âŸ©= |ğ›¼ğ‘–âŸ©e ğ‘‰ğ‘‡|ğ‘–âŸ©= |ğ›½ğ‘–âŸ©, o Ãºltimo passo do algoritmo aplica ğ‘ˆno
primeiro registrador e ğ‘‰ğ‘‡no segundo. A Figura 16 e o Algoritmo 2 ilustram essa preparaÃ§Ã£o
de estados.
Figura 16 â€“ InicializaÃ§Ã£o de um estado quÃ¢ntico de ğ‘›qubits usando a decomposiÃ§Ã£o de Schmidt.
phase 1
phase 2
phase 3
phase 4
...
...
|0âŸ©âŠ—âŒŠn/2âŒ‹
Initialization âƒ—Ïƒ
Unitary U
|0âŸ©âŠ—âŒˆn/2âŒ‰
Unitary V T
Fonte: Elaborada pelo autor (2022)
Quando atuando em ğ‘˜qubits, uma preparaÃ§Ã£o de estados requer 2ğ‘˜âˆ’ğ‘˜âˆ’1 CNOTs (BERGHOLM
et al., 2005) e um operador unitÃ¡rio 23
4822ğ‘˜âˆ’3
22ğ‘˜+ 4
3 (SHENDE; BULLOCK; MARKOV, 2006). Sendo
â„‹ğ´um subsistema com ğ‘›ğ´qubits (ğ‘›ğ´= ğ‘›/2 para ğ‘›par e ğ‘›ğ´= (ğ‘›âˆ’1)/2 para ğ‘›Ã­mpar) e
ğ‘›ğµ= ğ‘›âˆ’ğ‘›ğ´o nÃºmero de qubits do subsistema â„‹ğµ(ğ‘›ğµÃ© maior ou igual a ğ‘›ğ´) e conside-
rando o circuito completo para a inicializaÃ§Ã£o de estados, o nÃºmero de CNOTs somando as
contribuiÃ§Ãµes de todas as fases (Figura 16) Ã© representado por

34
ğ‘›par:
2ğ‘›ğ´âˆ’ğ‘›ğ´âˆ’1
âŸ
 â
 
fase 1
+ ğ‘›ğ´
âŸ â 
fase 2
+ 2
(ï¸‚23
482ğ‘›âˆ’3
22ğ‘›ğ´+ 4
3
)ï¸‚
âŸ
 â
 
fases 3 e 4 (unitÃ¡rios)
(2.16)
ğ‘›Ã­mpar:
2ğ‘›ğ´âˆ’ğ‘›ğ´âˆ’1
âŸ
 â
 
fase 1
+ ğ‘›ğ´
âŸ â 
fase 2
+ 23
4822ğ‘›ğ´âˆ’3
22ğ‘›ğ´+ 4
3
âŸ
 â
 
fase 3 (unitÃ¡rio)
+ 23
4822ğ‘›ğµâˆ’3
22ğ‘›ğµ+ 4
3
âŸ
 â
 
fase 4 (unitÃ¡rio)
(2.17)
As chaves nas equaÃ§Ãµes (2.16) e (2.17) indicam a contribuiÃ§Ã£o de cada fase do proce-
dimento de Plesch e Brukner (2011) para o nÃºmero de CNOTs. A fase 1 Ã© uma preparaÃ§Ã£o
de estado, a fase 2 uma sequÃªncia de portas CNOT e as fases 3 e 4 sÃ£o decomposiÃ§Ãµes
de unitÃ¡rios. O nÃºmero total de CNOTs Ã© limitado por
23
242ğ‘›quando ğ‘›Ã© par e por
115
96 2ğ‘›
quando ğ‘›Ã© Ã­mpar. A profundidade do circuito Ã© determinada pelo unitÃ¡rio da fase 4, pois
ğ‘›ğµ= âŒˆğ‘›/2âŒ‰â‰¥ğ‘›ğ´= âŒŠğ‘›/2âŒ‹. A Figura 17 ilustra como a profundidade Ã© afetada pela paridade
do nÃºmero de qubits ğ‘›= log2(ğ‘).
Figura 17 â€“ ComparaÃ§Ã£o entre o nÃºmero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando as preparaÃ§Ãµes de estados baseadas em rotaÃ§Ãµes e na decomposiÃ§Ã£o de Schmidt,
em funÃ§Ã£o do logaritmo do comprimento da entrada ğ‘›= log2(ğ‘).
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
Rotations
Schmidt
(a) NÃºmero de CNOTs
2
4
6
8
10
12
14
n
0
20000
40000
60000
80000
100000
120000
Rotations
Schmidt
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
A decomposiÃ§Ã£o de Schmidt reduz a profundidade do circuito quÃ¢ntico utilizado para a ini-
cializaÃ§Ã£o de estados (comparado com Mottonen et al. (2005)), mas hÃ¡ um aumento no custo
computacional clÃ¡ssico â€“ complexidade do algoritmo na etapa de preprocessamento clÃ¡ssico
(Figura 2). Para calcular a decomposiÃ§Ã£o de Schmidt Ã© necessÃ¡rio realizar a decomposiÃ§Ã£o
SVD (Linha 1 do Algoritmo 2), que possui custo cÃºbico na raiz do comprimento da entrada
ğ‘‚(ğ‘3/2) (VASUDEVAN; RAMAKRISHNA, 2017).

35
Algoritmo 2: PreparaÃ§Ã£o de estados baseada na decomposiÃ§Ã£o de Schmidt
input : Um vetor de estado com 2ğ‘›amplitudes.
input : Uma partiÃ§Ã£o com os primeiros âŒŠğ‘›/2âŒ‹qubits do registrador.
output: O circuito para a inicializaÃ§Ã£o do estado quÃ¢ntico.
1 Decompor o estado usando SVD e a partiÃ§Ã£o (armazena os unitÃ¡rios ğ‘¢e ğ‘£â„, e o
vetor ğ‘ )
2 Cria um circuito quÃ¢ntico com ğ‘›qubits (ğ‘›= log2(len(vetor de estado)))
3 Codifica o vetor normalizado ğ‘ nos qubits ğ‘âˆˆ{partiÃ§Ã£o} usando um algoritmo para a
preparaÃ§Ã£o de estados nas amplitudes. Este passo Ã© chamado de Phase 1
4 Realiza âŒŠğ‘›/2âŒ‹CNOTs entre os qubits de controle ğ‘ğ‘âˆˆ{partiÃ§Ã£o} e os alvos
ğ‘ğ‘¡/âˆˆ{partiÃ§Ã£o}. Este passo Ã© chamado de Phase 2
5 Codifica o unitÃ¡rio ğ‘¢nos qubits ğ‘âˆˆ{partiÃ§Ã£o}. Este passo Ã© chamado de Phase 3
6 Codifica o unitÃ¡rio ğ‘£â„ğ‘‡nos qubits ğ‘/âˆˆ{partiÃ§Ã£o}. Este passo Ã© chamado de Phase 4
7 Retorna o circuito quÃ¢ntico para a inicializaÃ§Ã£o do estado.
Fonte: Elaborado pelo autor (2022)
2.4
DECOMPOSIÃ‡ÃƒO DE ISOMETRIAS
Isometrias sÃ£o generalizaÃ§Ãµes de operadores unitÃ¡rios e de preparaÃ§Ãµes de estados. Uma
isometria ğ‘‰Ã© representada por uma matriz 2ğ‘›Ã— 2ğ‘šsatisfazendo ğ‘‰â€ ğ‘‰= I, onde 0 â‰¤ğ‘šâ‰¤ğ‘›.
Os casos especiais em que ğ‘š= 0 e ğ‘š= ğ‘›sÃ£o equivalentes Ã  preparaÃ§Ã£o de estados e Ã 
decomposiÃ§Ã£o de unitÃ¡rios, respectivamente.
2.4.1
DecomposiÃ§Ã£o de Knill
Essa decomposiÃ§Ã£o foi idealizada por Knill (1995). Sendo ğ‘‰uma isometria de dimensÃ£o
2ğ‘›Ã— 2ğ‘š, podemos estender ğ‘‰combinando-a com o complexo conjugado do seu espaÃ§o nulo
ğ‘= null(ğ‘‰ğ‘‡)â€  de dimensÃ£o (2ğ‘›âˆ’2ğ‘š) Ã— 2ğ‘›para produzir o unitÃ¡rio ğ‘ˆ=
[ï¸
ğ‘‰ğ‘ğ‘‡]ï¸
2ğ‘›Ã—2ğ‘›,
onde null(ğ‘‰ğ‘‡) = {âƒ—ğ‘£âˆˆC2ğ‘›|ğ‘‰ğ‘‡âƒ—ğ‘£= âƒ—0} e ğ‘‰= ğ‘ˆI2ğ‘›Ã—2ğ‘š. O transposto conjugado do espaÃ§o
nulo Ã© necessÃ¡rio para a condiÃ§Ã£o de unitariedade ğ‘ˆğ‘ˆâ€  = I. Esse procedimento estende ğ‘‰
para uma base ortonormal em que as colunas de ğ‘ˆsÃ£o os estados da base e que possui no
mÃ¡ximo 2ğ‘šautovalores com argumento complexo ğœƒğ‘˜diferente de zero, minimizando o nÃºmero
de instÃ¢ncias do circuito da Figura 18.
A Figura 18 mostra o esquema do circuito quÃ¢ntico para a decomposiÃ§Ã£o de uma das 2ğ‘š
colunas da isometria ğ‘‰. O circuito completo tem 2ğ‘šinstÃ¢ncias desse diagrama (0 â‰¤ğ‘˜< 2ğ‘š).
O operador ğ‘†Ã© uma preparaÃ§Ã£o de estado do tipo codificaÃ§Ã£o nas amplitudes (SeÃ§Ã£o 2.2.3),
e ğœƒğ‘˜Ã© o argumento do autovalor ğ‘˜do unitÃ¡rio ğ‘ˆ. Se o argumento for zero, a instÃ¢ncia do

36
Figura 18 â€“ Esquema de Knill para a decomposiÃ§Ã£o de isometrias.
Sâ€ (Vk)
S(Vk)
X
P(Î¸k)
X
Fonte: Elaborada pelo autor (2022)
circuito pode ser ignorada.
Figura 19 â€“ OtimizaÃ§Ã£o para a decomposiÃ§Ã£o cosseno-seno (CSD) de isometrias.
S(Vk)
Sâ€ (Vk+1)
=
S(Vk)
Sâ€ (Vk+1)
S
A
Câ€ 
Sâ€ 
B
Dâ€ 
=
S
Câ€ A
Sâ€ 
Dâ€ B
Fonte: Elaborada pelo autor (2022)
Iten et al. (2016) sugere utilizar a preparaÃ§Ã£o de estados baseada na decomposiÃ§Ã£o de Sch-
midt (SeÃ§Ã£o 2.3.2). Com essa inicializaÃ§Ã£o, Ã© possÃ­vel otimizar a decomposiÃ§Ã£o de isometrias
baseadas no esquema de Knill. A Figura 19 mostra como combinar os operadores das fases
3 e 4 entre instÃ¢ncias consecutivas do diagrama 18. Com essa otimizaÃ§Ã£o, a decomposiÃ§Ã£o
de Knill requer 23
24(2ğ‘š+ğ‘›+ 2ğ‘›) + ğ‘‚(ğ‘›2)2ğ‘šCNOTs para ğ‘›par e 115
96 (2ğ‘š+ğ‘›+ 2ğ‘›) + ğ‘‚(ğ‘›2)2ğ‘š
CNOTs para ğ‘›Ã­mpar (ITEN et al., 2016).
2.4.2
DecomposiÃ§Ã£o Coluna-por-Coluna
O mÃ©todo de decomposiÃ§Ã£o coluna-por-coluna (Columnâ€“byâ€“Column Decomposition ou
CCD) para a decomposiÃ§Ã£o de isometrias foi introduzido por Iten et al. (2016). Cada coluna
ğ‘˜da isometria ğ‘‰Ã© decomposta em um operador ğºğ‘˜(Figura 20 e Algoritmo 3). O operador
ğºğ‘˜Ã© uma variaÃ§Ã£o da codificaÃ§Ã£o nas amplitudes de Mottonen et al. (2005), sendo apenas
ğºâ€ 
0 exatamente a preparaÃ§Ã£o de estados baseada em rotaÃ§Ãµes (SeÃ§Ã£o 2.3.1).
A variaÃ§Ã£o (linhas 4â€“6 do Algoritmo 3) tem como objetivo garantir que a decomposiÃ§Ã£o de
cada nova coluna nÃ£o afete as anteriores. Quando necessÃ¡rio, a variaÃ§Ã£o remove alguns dos uni-
tÃ¡rios ğ‘ˆğ‘™(EquaÃ§Ã£o 2.20) dos operadores uniformemente controlados do algoritmo de Mottonen
et al. (2005) e os substitui por um operador ğ‘ˆmulticontrolado (Linha 5 do Algoritmo 3).

37
Figura 20 â€“ Esquema coluna-por-coluna para a decomposiÃ§Ã£o de isometrias.
D
Gâ€ 
2mâˆ’1(V2mâˆ’1)
. . .
Gâ€ 
0(V0)
Fonte: Elaborada pelo autor (2022)
A Figura 20 e o Algoritmo 3 sumarizam o mÃ©todo. A Figura 20 apresenta o circuito
quÃ¢ntico para a decomposiÃ§Ã£o de 2ğ‘šcolunas da isometria ğ‘‰. No Algoritmo 3, o unitÃ¡rio ğ‘ˆ
e o conjunto de unitÃ¡rios ğ‘ˆğ‘™das linhas 5 e 7 sÃ£o construÃ­dos conforme a EquaÃ§Ã£o (2.19)
e a EquaÃ§Ã£o (2.20) Iten et al. (2016). A funÃ§Ã£o ğ‘ğ‘˜
ğ‘ +1 representa o inteiro composto pelos
ğ‘›âˆ’(ğ‘ + 1) bits mais significativos de ğ‘˜. A funÃ§Ã£o ğ‘ğ‘˜
ğ‘ +1, o inteiro composto pelos ğ‘ + 1 bits
menos significativos de ğ‘˜(ver ApÃªndice A3 de (ITEN et al., 2016)). Na EquaÃ§Ã£o (2.18), o
estado |ğœ“ğ‘™âŸ©Ã© composto pelos dois elementos de Ã­ndices 2ğ‘ (2ğ‘™) + ğ‘ğ‘˜
ğ‘ +1 e 2ğ‘ (2ğ‘™+ 1) + ğ‘ğ‘˜
ğ‘ +1,
normalizados, localizados na coluna ğ‘˜da isometria ğ‘‰, e |ğœ‘ğ‘™âŸ©= âˆ’âŸ¨ğœ“ğ‘™|1âŸ©|0âŸ©+ âŸ¨ğœ“ğ‘™|0âŸ©|1âŸ©(ver
Lemma 2 de (ITEN et al., 2016)). Deve ser percebido que as colunas sÃ£o preparadas atÃ© um
operador diagonal, o que significa que uma correÃ§Ã£o de fase Ã© necessÃ¡ria. Isso Ã© feito pelo
operador ğ·da Figura 20.
ğ‘¢ğ‘™=
â§
âª
âª
â¨
âª
âª
â©
|0âŸ©âŸ¨ğœ“ğ‘™| + |1âŸ©âŸ¨ğœ‘ğ‘™| se ğ‘ = 0
|1âŸ©âŸ¨ğœ“ğ‘™| + |0âŸ©âŸ¨ğœ‘ğ‘™| se ğ‘ Ì¸= 0
(2.18)
ğ‘ˆ=
{ï¸‚
ğ‘¢ğ‘™
para ğ‘™= ğ‘ğ‘˜
ğ‘ +1
(2.19)
ğ‘ˆğ‘™=
â§
âª
âª
âª
âª
âª
âª
âª
âª
âª
âª
âª
â¨
âª
âª
âª
âª
âª
âª
âª
âª
âª
âª
âª
â©
I2Ã—2
para ğ‘™âˆˆ{0, 1, . . . , ğ‘ğ‘˜
ğ‘ +1} se ğ‘ğ‘˜
ğ‘ +1 Ì¸= 0
I2Ã—2
para ğ‘™âˆˆ{0, 1, . . . , ğ‘ğ‘˜
ğ‘ +1 âˆ’1} se ğ‘ğ‘˜
ğ‘ +1 = 0
ğ‘¢ğ‘™
para ğ‘™âˆˆ{ğ‘ğ‘˜
ğ‘ +1 + 1, ğ‘ğ‘˜
ğ‘ +1 + 2, . . . , 2ğ‘›âˆ’1âˆ’ğ‘ âˆ’1} se ğ‘ğ‘˜
ğ‘ +1 Ì¸= 0
ğ‘¢ğ‘™
para ğ‘™âˆˆ{ğ‘ğ‘˜
ğ‘ +1, ğ‘ğ‘˜
ğ‘ +1 + 1, . . . , 2ğ‘›âˆ’1âˆ’ğ‘ âˆ’1} se ğ‘ğ‘˜
ğ‘ +1 = 0
(2.20)
Sabendo que atÃ© a conclusÃ£o do Algoritmo 3 a matriz quadrada ğ‘‰2ğ‘šÃ—2ğ‘š(2ğ‘šÃ© o nÃºmero
de colunas da isometria ğ‘‰) precisa tornar-se igual Ã  identidade, qualquer fase presente na
diagonal da matriz indica uma fase que deve ser corrigida usando o operador ğ·. Portanto, ele
Ã© construÃ­do como um operador diagonal onde as fases sÃ£o aquelas presentes em ğ‘‰2ğ‘šÃ—2ğ‘š.
Esse Ã© o mÃ©todo mais eficiente para a decomposiÃ§Ã£o de isometrias, com exceÃ§Ã£o do caso
2ğ‘›âˆ’1â€“paraâ€“2ğ‘›em que o mÃ©todo CSD Ã© melhor (SeÃ§Ã£o 2.4.3). O nÃºmero de CNOTs requerido

38
pelo CCD Ã© dado por 2ğ‘š+ğ‘›âˆ’1
242ğ‘›+ ğ‘‚(ğ‘›2)2ğ‘š(ITEN et al., 2016).
Algoritmo 3: Monta um operador ğºğ‘˜que realiza a decomposiÃ§Ã£o da coluna ğ‘˜da
isometria ğ‘‰.
input : Uma isometria ğ‘‰, nÃºmero de qubits ğ‘›, e o Ã­ndice ğ‘˜da coluna da isometria.
output: Operador ğºğ‘˜.
1 Cria um circuito quÃ¢ntico com ğ‘›qubits para construir o operador ğºğ‘˜
2 Faz ğ‘ = 0 e ğ‘˜ğ‘ como o bit de Ã­ndice ğ‘ da representaÃ§Ã£o binÃ¡ria de ğ‘˜
3 Faz ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡= ğ‘›âˆ’ğ‘ âˆ’1, ğ‘ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘œğ‘™= {0, . . . , ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡âˆ’1}, e
ğ‘ğ‘›ğ‘ğ‘–ğ‘™ğ‘™ğ‘= {ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡+ 1, . . . , ğ‘›âˆ’1}
4 Se ğ‘˜ğ‘ = 0 e ğ‘ğ‘˜
ğ‘ +1 Ì¸= 0 continue, caso contrÃ¡rio vÃ¡ para 7
5 Aplica uma porta multicontrolada ğ‘€ğ¶ğºcom unitÃ¡rio ğ‘ˆ, controlada por
ğ‘ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘œğ‘™+ ğ‘ğ‘›ğ‘ğ‘–ğ‘™ğ‘™ğ‘e atuando em ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡
6 Atualiza a isometria ğ‘‰= ğ‘€ğ¶ğºÃ— ğ‘‰
7 Aplica uma porta uniformemente controlada ğ‘ˆğ¶ğºcom unitÃ¡rios ğ‘ˆğ‘™, controlada por
ğ‘ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘œğ‘™e atuando em ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡
8 Atualiza a isometria ğ‘‰= ğ‘ˆğ¶ğºÃ— ğ‘‰
9 Se ğ‘ < ğ‘›âˆ’1, faz ğ‘ = ğ‘ + 1 e retorna para 3, caso contrÃ¡rio retorna o operador ğºğ‘˜.
Fonte: Elaborado pelo autor (2022)
2.4.3
DecomposiÃ§Ã£o Cosseno-Seno
Essa decomposiÃ§Ã£o Ã© uma adaptaÃ§Ã£o da decomposiÃ§Ã£o de unitÃ¡rios CSD (SeÃ§Ã£o 2.1.3) ou
de sua otimizaÃ§Ã£o QSD (SeÃ§Ã£o 2.1.4) (ITEN et al., 2016). Assim como na decomposiÃ§Ã£o de Knill
(SeÃ§Ã£o 2.4.1), a isometria Ã© estendida e representada em termos de um unitÃ¡rio ğ‘‰= ğ‘ˆI2ğ‘›Ã—2ğ‘š.
Sendo ğ‘›> ğ‘še aplicando a primeira identidade da decomposiÃ§Ã£o de unitÃ¡rios (Figura 9), o
primeiro qubit do operador ğ¿da decomposiÃ§Ã£o do unitÃ¡rio ğ‘ˆnÃ£o tem efeito sobre as colunas
associadas Ã  isometria (Figura 21), portanto nÃ£o Ã© necessÃ¡rio aplicar o controle sobre ele.
Sendo assim, o operador ğ¿atua sobre ğ‘›âˆ’1 qubits e Ã© uma isometria 2ğ‘šâ€“paraâ€“2ğ‘›âˆ’1 estendida
para unitÃ¡rio, identificada na Figura 21 como ğ‘ˆğ¿. Em seguida, a identidade da decomposiÃ§Ã£o
de unitÃ¡rios QSD (Figura 11) Ã© aplicada apenas ao operador uniformemente controlado ğ‘…,
produzindo os unitÃ¡rios ğ‘„e ğ‘Šseparados pela rotaÃ§Ã£o uniformemente controlada ğ‘…ğ‘§(Fi-
gura 21).
Figura 21 â€“ Esquema para a decomposiÃ§Ã£o cosseno-seno (CSD) de isometrias.
U
=
â–¡
â–¡
Ry
UL
R
=
â–¡
â–¡
Ry
Rz
UL
Q
W
Fonte: Elaborada pelo autor (2022)

39
O procedimento Ã© repetido recursivamente para decompor ğ‘ˆğ¿. Os unitÃ¡rios ğ‘„e ğ‘Špodem
ser decompostos utilizando a identidade da Figura 11 atÃ© produzir operadores de dois qubits,
como explicado na SeÃ§Ã£o 2.1.4.
Esse mÃ©todo produz circuitos com
23
144(4ğ‘š+ 2 Ã— 4ğ‘›) + ğ‘‚(ğ‘š) CNOTs, apropriado apenas
quando ğ‘š= (ğ‘›âˆ’1) (ITEN et al., 2016). Para ğ‘š< (ğ‘›âˆ’1), o mÃ©todo CCD produz circuitos
com nÃºmero menor de CNOTs.

40
3 SOLUÃ‡Ã•ES EXISTENTES PARA A PREPARAÃ‡ÃƒO DE ESTADOS QUÃ‚NTI-
COS
VÃ¡rias soluÃ§Ãµes para o problema da preparaÃ§Ã£o de estados quÃ¢nticos foram propostas (VEN-
TURA; MARTINEZ, 1999; GROVER, 2000; LONG; SUN, 2001; MOTTONEN et al., 2005; SHENDE;
BULLOCK; MARKOV, 2006; PLESCH; BRUKNER, 2011; CORTESE; BRAJE, 2018), mas todas pro-
duzem circuitos com profundidade crescendo pelo menos exponencialmente no nÃºmero de
qubits. Por exemplo, o mÃ©todo proposto por Ventura e Martinez (1999) atinge a compressÃ£o
exponencial ğ‘‚(log2(ğ‘)) na largura do circuito quÃ¢ntico enquanto exige profundidade linear
ğ‘‚(ğ‘) para dados ğ‘-dimensionais. Como hÃ¡ uma sobrecarga adicional de recursos em muitos
algoritmos quÃ¢nticos devido ao postulado da mediÃ§Ã£o quÃ¢ntica (PARK; PETRUCCIONE; RHEE,
2019; PARK et al., 2019), tal custo linear pode impor restriÃ§Ãµes a possÃ­veis vantagens, domi-
nando o custo computacional da aplicaÃ§Ã£o quÃ¢ntica pretendida.
As tentativas de preparar estados quÃ¢nticos de forma mais eficiente incluem abordagens
probabilÃ­sticas (ZHANG; YUNG; YUAN, 2021; PARK; PETRUCCIONE; RHEE, 2019) e estratÃ©gias
para inicializar estados quÃ¢nticos aproximados (ZOUFAL; LUCCHI; WOERNER, 2019; NAKAJI et al.,
2021; MARIN-SANCHEZ; GONZALEZ-CONDE; SANZ, 2021). Mais recentemente, existem trabalhos
que se concentram em classes especÃ­ficas de estados quÃ¢nticos. Por exemplo, como preparar
estados uniformes (MOZAFARI et al., 2021), esparsos (MALVETTI; ITEN; COLBECK, 2021) ou
de distribuiÃ§Ã£o de probabilidade (ZOUFAL; LUCCHI; WOERNER, 2019). Entretanto, nÃ£o hÃ¡ um
entendimento claro de quais classes de estados quÃ¢nticos podem ser criadas de forma eficiente.
O emaranhamento Ã© um dos recursos quÃ¢nticos que tambÃ©m permite o desenvolvimento
de algoritmos e protocolos mais eficientes (ver ApÃªndice E). Sua relaÃ§Ã£o com a complexi-
dade algorÃ­tmica de um estado quÃ¢ntico foi demonstrada em trabalhos anteriores (MORA;
BRIEGEL, 2006; MORA; BRIEGEL, 2005) e desempenha um papel importante em muitas apli-
caÃ§Ãµes quÃ¢nticas, tais como comunicaÃ§Ã£o quÃ¢ntica, correÃ§Ã£o de erros quÃ¢nticos e criptografia
quÃ¢ntica (RAUSSENDORF; BRIEGEL, 2001; BARREIRO et al., 2010; CALDERBANK; SHOR, 1996;
STEANE, 1996; CLEVE; GOTTESMAN; LO, 1999; DÃ¼R; CIRAC, 2000).
Embora esteja claro que o emaranhamento Ã© um recurso importante na computaÃ§Ã£o quÃ¢n-
tica (JOZSA; LINDEN, 2003), ser capaz de codificar estados de baixo emaranhamento, tais
como funÃ§Ãµes de densidade de probabilidade, ainda Ã© Ãºtil, pois os algoritmos podem usar blo-
cos de construÃ§Ã£o de baixo emaranhamento para alcanÃ§ar estruturas de alto emaranhamento.
Um exemplo Ã© a simulaÃ§Ã£o de processos estocÃ¡sticos (BLANK; PARK; PETRUCCIONE, 2021;

41
Tabela 1 â€“ Artigos sobre preparaÃ§Ã£o de estados.
ano
artigo
flip-flop
caixa-preta
variacional
probabilÃ­stico
Ã¡rvore
decomposiÃ§Ã£o
1995
(KNILL, 1995)(â€ )(*)
1999
(VENTURA; MARTINEZ, 1999)(â€ )(*)
x
2000
(GROVER, 2000)
x
2001
(LONG; SUN, 2001)
x
2005
(BERGHOLM et al., 2005)
x
(MOTTONEN et al., 2005)(â€ )(*)
x
2006
(SHENDE; BULLOCK; MARKOV, 2006)(â€ )(*)
x
2008
(GIOVANNETTI; LLOYD; MACCONE, 2008b)
x
(GIOVANNETTI; LLOYD; MACCONE, 2008a)
x
2011
(PLESCH; BRUKNER, 2011)(â€ )(*)
x
2015
(ARUNACHALAM et al., 2015)
2016
(ITEN et al., 2016)(â€ )(*)
x
2018
(CORTESE; BRAJE, 2018)
x
(LOW; KLIUCHNIKOV; SCHAEFFER, 2018)
x
2019
(SANDERS et al., 2019)
x
(ZOUFAL; LUCCHI; WOERNER, 2019)(â€ )
x
(PARK; PETRUCCIONE; RHEE, 2019)
x
2020
(KUZMIN; SILVI, 2020)
x
(MOZAFARI et al., 2020)
x
(CASARES, 2020)
x
(MATTEO; GHEORGHIU; MOSCA, 2020)
x
(PALER; OUMAROU; BASMADJIAN, 2020)
x
2021
(VERAS et al., 2021)(â€ )
x
(VERAS; SILVA; SILVA, 2022)(â€ )
x
(ARAUJO et al., 2021b)(â€ )(*)
x
(ARAUJO et al., 2021a)(â€ )(*)
x
(WANG et al., 2021)
x
(GUO et al., 2021)
x
(ZHANG; YUNG; YUAN, 2021)
x
(ZHAO et al., 2021)
x
(GLEINIG; HOEFLER, 2021)(â€ )
x
(NAKAJI et al., 2021)
x
(MOZAFARI et al., 2021)
x
(MARIN-SANCHEZ; GONZALEZ-CONDE; SANZ, 2021)
x
(MALVETTI; ITEN; COLBECK, 2021)
x
Fonte: Elaborada pelo autor (2022)
STAMATOPOULOS et al., 2020; WOERNER; EGGER, 2019), usando a estimativa de amplitude.
A Tabela 1 mostra uma lista do levantamento bibliogrÃ¡fico feito atÃ© o momento, cate-
gorizando o mÃ©todo proposto em cada artigo para a preparaÃ§Ã£o de estados. HÃ¡ 12 mÃ©todos
implementados no repositÃ³rio qclib, indicados por uma marca (â€ ). Os oito itens em que tra-
balhei diretamente, estÃ£o indicados por (*).

42
4 PRINCIPAIS CONTRIBUIÃ‡Ã•ES
4.1
A DIVIDE-AND-CONQUER ALGORITHM FOR QUANTUM STATE PREPARATION
O trabalho Araujo et al. (2021b) (ApÃªndice A) produziu um algoritmo capaz de carregar
um vetor ğ‘-dimensional com vantagem de tempo exponencial usando um circuito quÃ¢ntico
com profundidade polilogarÃ­tmica e informaÃ§Ã£o emaranhada com qubits auxiliares (Divide-and-
Conquer quantum State Preparation ou DCSP). Os resultados mostram que podemos carregar
dados com eficiÃªncia em dispositivos quÃ¢nticos usando uma estratÃ©gia de divisÃ£o e conquista
para trocar tempo computacional por espaÃ§o.
Figura 22 â€“ ComparaÃ§Ã£o entre o nÃºmero de qubits e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando a preparaÃ§Ã£o de estados baseada na decomposiÃ§Ã£o de Schmidt e o algoritmo
DCSP, em funÃ§Ã£o do logaritmo do comprimento da entrada ğ‘›= log2(ğ‘).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
Schmidt
Dcsp
(a) NÃºmero de qubits
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
70000
Schmidt
Dcsp
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
O mÃ©todo proposto estabelece uma abordagem para a preparaÃ§Ã£o do estado quÃ¢ntico
que pode complementar ou melhorar os mÃ©todos conhecidos, tais como a codificaÃ§Ã£o nos
Ã¢ngulos (SeÃ§Ã£o 2.2.2) e a codificaÃ§Ã£o nas amplitudes (SeÃ§Ã£o 2.2.3). A estratÃ©gia foi baseada
no algoritmo de Mottonen et al. (2005) e em uma abordagem de divisÃ£o e conquista usando
portas swap controladas e qubits auxiliares. Com esta modificaÃ§Ã£o, obtemos uma reduÃ§Ã£o
exponencial no tempo para carregar um vetor ğ‘-dimensional nas amplitudes de um estado
quÃ¢ntico com um circuito de profundidade ğ‘‚(log2
2(ğ‘)) e espaÃ§o ğ‘‚(ğ‘) (Figura 4.1), onde
ğ‘= 2ğ‘›e ğ‘›Ã© o nÃºmero de qubits do registrador de dados. Os qubits de dados estÃ£o associados
aos nÃ³s da vista esquerda da Ã¡rvore de estado (ver ApÃªndice A e ApÃªndice B). O registrador
auxiliar possui ğ‘âˆ’ğ‘›âˆ’1 qubits e estÃ¡ associado ao restante dos nÃ³s da Ã¡rvore de estado.
A reduÃ§Ã£o na profundidade Ã© atingida ao custo do uso de qubits auxiliares emaranhados
com os qubits do registrador de dados. A informaÃ§Ã£o emaranhada significa que, embora os

43
dados sejam codificados nas amplitudes de uma superposiÃ§Ã£o de qubits, os resultados apÃ³s a
observaÃ§Ã£o dos qubits auxiliares deixarÃ¡ o registrador de dados em um estado misto, o que pode
ser uma desvantagem no caso de algoritmos para a soluÃ§Ã£o de sistemas lineares (HARROW;
HASSIDIM; LLOYD, 2009) ou equaÃ§Ãµes diferenciais (XIN et al., 2020). Entretanto, mostramos
que alguns problemas como a aprendizagem de mÃ¡quina quÃ¢ntica supervisionada e a anÃ¡lise
estatÃ­stica podem ser realizados com o estado quÃ¢ntico de entrada dado pelo mÃ©todo.
Foi demonstrada uma prova de conceito utilizando um dispositivo quÃ¢ntico real e apresen-
tadas duas aplicaÃ§Ãµes para a aprendizagem de mÃ¡quina quÃ¢ntica (ver ApÃªndice A). Espera-se
que esta nova estratÃ©gia de carregamento permita a vantagem quÃ¢ntica para tarefas que reque-
rem carregar um volume significativo de informaÃ§Ãµes para os dispositivos quÃ¢nticos. A troca
entre as complexidades de tempo e espaÃ§o Ã© favorÃ¡vel quando aumentar a largura do circuito Ã©
mais barato do que aumentar a profundidade, o que Ã© um cenÃ¡rio provÃ¡vel de ocorrer durante
o desenvolvimento dos dispositivos NISQ (IBM, 2020).
4.2
CONFIGURABLE SUBLINEAR CIRCUITS FOR QUANTUM STATE PREPARATION
A contribuiÃ§Ã£o do trabalho Araujo et al. (2021a) (ApÃªndice B) Ã© um procedimento bidi-
recional configurÃ¡vel que aborda o problema do custo de carregamento de dados clÃ¡ssicos em
um estado quÃ¢ntico (Bidirectional quantum State Preparation ou BDSP), regulando a troca
inicialmente apresentada no DCSP entre a largura e a profundidade do circuito quÃ¢ntico. Em
particular, Ã© apresentada uma configuraÃ§Ã£o que codifica um estado ğ‘-dimensional usando um
circuito quÃ¢ntico com largura e profundidade sublineares ğ‘‚(
âˆš
ğ‘) e informaÃ§Ã£o emaranhada
com qubits auxiliares (Figura 23).
Os mÃ©todos existentes para a preparaÃ§Ã£o de estados requerem pelo menos um recurso
do circuito quÃ¢ntico â€“ profundidade ou largura â€“ crescendo linearmente com o tamanho do
problema. O algoritmo BDSP fornece uma estrutura geral para configurar a troca entre estes
recursos que pode ser Ãºtil para gerenciÃ¡-los em dispositivos NISQ. Olhando para os algoritmos
de preparaÃ§Ã£o de estados como uma caminhada na Ã¡rvore de estado, o BDSP constitui uma
forma sistemÃ¡tica de caminhar em duas direÃ§Ãµes opostas. Os mÃ©todos anteriores sÃ£o baseados
em caminhadas em apenas uma direÃ§Ã£o.
Tanto a complexidade temporal quanto a espacial dependem do nÃºmero de qubits do
registrador de dados ğ‘›e tambÃ©m do parÃ¢metro ğ‘ âˆˆ[1..ğ‘›] que ajusta a troca entre tempo e
espaÃ§o computacional. Dado um vetor de entrada ğ‘-dimensional (ğ‘= 2ğ‘›), a complexidade

44
Figura 23 â€“ Ponto de sublinearidade do algoritmo BDSP para log2(ğ‘) = 15, indicado pela linha vermelha em
ğ‘ = 8.
2
4
6
8
10
12
14
s
0
50000
100000
150000
200000
250000
cnots
depth
qubits
Fonte: Elaborada pelo autor (2022)
Figura 24 â€“ ComparaÃ§Ã£o entre o nÃºmero de qubits e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando o algoritmo DCSP e o BDSP com configuraÃ§Ã£o sublinear ğ‘‚(
âˆš
ğ‘), em funÃ§Ã£o do
logaritmo do comprimento da entrada ğ‘›= log2(ğ‘).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
Dcsp
Bdsp
(a) NÃºmero de qubits
2
4
6
8
10
12
14
n
0
200
400
600
800
1000
1200
1400
1600
Dcsp
Bdsp
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
total do tempo do algoritmo bidirecional Ã© ğ‘‚ğ‘(ğ‘) + ğ‘‚ğ‘‘(2ğ‘ + log2
2(ğ‘) âˆ’ğ‘ 2), onde ğ‘‚ğ‘(ğ‘) Ã© o
tempo de prÃ©-processamento clÃ¡ssico para criar o circuito quÃ¢ntico e ğ‘‚ğ‘‘(2ğ‘ + log2
2(ğ‘) âˆ’ğ‘ 2)
Ã© a profundidade do circuito. Tipicamente o mesmo vetor de entrada Ã© carregado ğ‘™â‰«ğ‘
vezes, portanto o tempo computacional amortizado Ã© ğ‘‚ğ‘‘(2ğ‘ + log2
2(ğ‘) âˆ’ğ‘ 2). Note que o prÃ©-
processamento clÃ¡ssico Ã© comum na computaÃ§Ã£o clÃ¡ssica e tambÃ©m Ã© necessÃ¡rio em outros
mÃ©todos para a preparaÃ§Ã£o de estados quÃ¢nticos. A complexidade espacial (ou seja, a largura)
do circuito Ã© ğ‘‚ğ‘¤((ğ‘ + 1)ğ‘/2ğ‘ ) (Figura 24).
AlÃ©m do custo do circuito sublinear, a capacidade de configurar a troca entre os recursos

45
quÃ¢nticos Ã© vantajosa quando especificaÃ§Ãµes realistas de hardware quÃ¢ntico sÃ£o consideradas,
pois um recurso pode ser mais escalÃ¡vel do que o outro. Por exemplo, Ã© Ãºtil para os futuros
dispositivos NISQ, com a promessa de dispositivos com um grande nÃºmero de qubits fÃ­si-
cos (IBM, 2020), embora o ruÃ­do ainda limite a profundidade dos circuitos (PRESKILL, 2018).
Como prova de conceito, o algoritmo foi aplicado em cinco computadores quÃ¢nticos acessados
atravÃ©s dos serviÃ§os de nuvem quÃ¢ntica da IBM e da IonQ.
4.3
APPROXIMATED QUANTUM-STATE PREPARATION WITH ENTANGLEMENT DE-
PENDENT COMPLEXITY
O artigo Araujo, Blank e Silva (2022) (apÃªndices C e D) resultou em um conjunto de
algoritmos capaz de reduzir a profundidade do circuito de preparaÃ§Ã£o de estados ao transferir
parte da complexidade computacional para um computador clÃ¡ssico, mantendo a compressÃ£o
exponencial na largura do circuito ğ‘‚(log2(ğ‘)). O estado quÃ¢ntico inicializado pode ser exato
ou aproximado. Foi demonstrado que a aproximaÃ§Ã£o Ã© melhor nos processadores quÃ¢nticos
atuais do que a inicializaÃ§Ã£o do estado original. Avaliou-se atravÃ©s de experimentos que o
mÃ©todo proposto permite a inicializaÃ§Ã£o de distribuiÃ§Ãµes de probabilidade em estados quÃ¢nticos
e o carregamento aproximado de imagens para tarefas de aprendizagem de mÃ¡quinas quÃ¢nticas.
De fato, os experimentos com dispositivos IBMQ (IBM, 2021b) mostram que o algoritmo
provavelmente auxiliarÃ¡ os profissionais da computaÃ§Ã£o quÃ¢ntica durante toda a era NISQ.
Figura 25 â€“ Profundidade e nÃºmero de CNOTs do circuito produzido pelo LRSP para carregar um vetor com-
plexo de dimensÃ£o 2ğ‘›em um estado quÃ¢ntico aproximado com fidelidade ajustada pelo parÃ¢metro
ğ‘š.
5
4
3
2
1
0
m
0
500
1000
1500
2000
2500
cnots
depth
(a) ğ‘›= 11
6
5
4
3
2
1
0
m
0
500
1000
1500
2000
2500
3000
3500
cnots
depth
(b) ğ‘›= 12
6
5
4
3
2
1
0
m
0
2000
4000
6000
8000
10000
cnots
depth
(c) ğ‘›= 13
7
6
5
4
3
2
1
0
m
0
2000
4000
6000
8000
10000
12000
14000
16000
cnots
depth
(d) ğ‘›= 14
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(e) ğ‘›= 11
6
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(f) ğ‘›= 12
6
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(g) ğ‘›= 13
7
6
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(h) ğ‘›= 14
Fonte: Elaborada pelo autor (2022)

46
Algoritmos anteriores para a preparaÃ§Ã£o de estados requerem ğ‘‚(2ğ‘›) CNOTs para inici-
alizar um estado quÃ¢ntico arbitrÃ¡rio exato. Entretanto, esses algoritmos nÃ£o consideram a
quantidade de emaranhamento. Este trabalho mostra que a complexidade do circuito para a
preparaÃ§Ã£o do estado estÃ¡ relacionada ao emaranhamento atravÃ©s de medidas numÃ©ricas de
emaranhamento de estados puros baseadas no quadrado dos coeficientes de Schmidt. Essas
medidas estÃ£o diretamente relacionadas ao nÃºmero de CNOTs necessÃ¡rios para a inicializaÃ§Ã£o
exata do estado (ApÃªndice C). A reduÃ§Ã£o da complexidade no regime quÃ¢ntico nÃ£o Ã© gratuita,
pois a anÃ¡lise do emaranhamento na etapa de preprocessamento clÃ¡ssico, que permite que tal
reduÃ§Ã£o seja alcanÃ§ada, tem um custo cÃºbico na raiz do comprimento da entrada, que nÃ£o
pode ser desprezado. Portanto, hÃ¡ uma troca entre as complexidades das etapas nos regimes
clÃ¡ssico e quÃ¢ntico.
Tabela 2 â€“ Erro Absoluto MÃ©dio entre probabilidades de mediÃ§Ãµes de estados aproximados (0 â‰¤ğ‘šâ‰¤2) de 7
qubits gerados pelo LRSP e as probabilidades esperadas para o estado original exato (ğ‘š= 3).
m
CNOTs
profund.
fidelidade
ibmq_qasm_simulator
ibmq_casablanca
ibmq_jakarta
ibm_perth
0
13
11
0.78969
0.003730(0.000080)
0.004384(0.000280)
0.004394(0.000186)
0.004894(0.000467)
1
36
51
0.85460
0.003226(0.000067)
0.004557(0.000160)
0.004848(0.000286)
0.004666(0.000170)
2
84
115
0.95016
0.002068(0.000070)
0.004564(0.000173)
0.004523(0.000192)
0.004581(0.000274)
3
150
243
1.00000
0.000696(0.000049)
0.006293(0.001588)
0.005272(0.001090)
0.005353(0.000780)
Fonte: Elaborada pelo autor (2022)
Tabela 3 â€“ Erro Absoluto MÃ©dio entre probabilidades de mediÃ§Ãµes de estados aproximados (ğ‘™> 0.00) de 7
qubits gerados pelo BAA e as probabilidades esperadas para o estado original exato (ğ‘™= 0.00).
ğ‘™
CNOTs
profund.
fidelidade
ibmq_qasm_simulator
ibmq_casablanca
ibmq_jakarta
ibm_perth
0.00
150
243
1.00000
0.000706(0.000064)
0.005557(0.001640)
0.005175(0.000841)
0.0054878(0.000848)
0.12
54
57
0.88742
0.003046(0.000073)
0.005015(0.000309)
0.004834(0.000212)
0.0052397(0.000347)
0.18
31
53
0.82141
0.003527(0.000101)
0.004653(0.000166)
0.004541(0.000159)
0.0051652(0.000507)
0.19
30
53
0.81630
0.003639(0.000045)
0.004630(0.000132)
0.004801(0.000208)
0.0051723(0.000338)
0.22
10
11
0.78536
0.003748(0.000069)
0.004332(0.000174)
0.004016(0.000219)
0.0048093(0.000333)
0.23
5
9
0.77064
0.003822(0.000065)
0.003976(0.000084)
0.003939(0.000070)
0.0042927(0.000290)
0.24
4
9
0.76403
0.004060(0.000074)
0.004054(0.000106)
0.004126(0.000081)
0.0043133(0.000174)
0.25
1
3
0.75097
0.004043(0.000090)
0.004214(0.000105)
0.004056(0.000079)
0.0040059(0.000068)
0.26
0
1
0.74502
0.004168(0.000059)
0.004369(0.000086)
0.004223(0.000055)
0.0042804(0.000085)
Fonte: Elaborada pelo autor (2022)
A complexidade dos circuitos produzidos pelo Low-Rank quantum State Preparation (LRSP)
pode ser determinada de maneira semelhante Ã  feita para a preparaÃ§Ã£o de estados baseada
na decomposiÃ§Ã£o de Schmidt (SeÃ§Ã£o 2.3.2). Quando atuando em ğ‘˜qubits, uma prepara-
Ã§Ã£o de estados nas amplitudes requer 2ğ‘˜âˆ’ğ‘˜âˆ’1 CNOTs (BERGHOLM et al., 2005), um
operador unitÃ¡rio
23
4822ğ‘˜âˆ’3
22ğ‘˜+ 4
3 (SHENDE; BULLOCK; MARKOV, 2006) e uma isometria
2ğ‘š+ğ‘˜âˆ’1
242ğ‘˜+ğ‘‚(ğ‘˜2)2ğ‘š(ITEN et al., 2016). Sendo |ğœ“âŸ©um estado com decomposiÃ§Ã£o de Schmidt
|ğœ“âŸ©= âˆ‘ï¸€ğ‘˜
ğ‘–=1 ğœğ‘–|ğ‘–ğ´âŸ©|ğ‘–ğµâŸ©, onde o subsistema â„‹ğ´tem ğ‘›ğ´qubits (1 â‰¤ğ‘›ğ´â‰¤âŒŠğ‘›/2âŒ‹), o subsistema

47
â„‹ğµtem ğ‘›ğµ= ğ‘›âˆ’ğ‘›ğ´qubits e ğ‘˜Ã© o rank de Schmidt. Considerando ğ‘š= âŒˆlog2(ğ‘˜)âŒ‰< ğ‘›ğ´a
medida de Schmidt, o nÃºmero de CNOTs (Figura 25 e Tabela 2) Ã© dado por
ğ‘š< ğ‘›ğ´:
2ğ‘šâˆ’ğ‘šâˆ’1
âŸ
 â
 
fase 1
+ ğ‘š
âŸ â 
fase 2
+ 2ğ‘š+ğ‘›ğ´âˆ’1
242ğ‘›ğ´
âŸ
 â
 
fase 3 (isometria)
+ 2ğ‘š+ğ‘›ğµâˆ’1
242ğ‘›ğµ
âŸ
 â
 
fase 4 (isometria)
(4.1)
ğ‘š= ğ‘›ğ´e ğ‘›ğ´< ğ‘›ğµ:
2ğ‘›ğ´âˆ’ğ‘›ğ´âˆ’1
âŸ
 â
 
fase 1
+ ğ‘›ğ´
âŸ â 
fase 2
+ 23
4822ğ‘›ğ´âˆ’3
22ğ‘›ğ´+ 4
3
âŸ
 â
 
fase 3 (unitÃ¡rio)
+ 2ğ‘›âˆ’1
242ğ‘›ğµ
âŸ
 â
 
fase 4 (isometria)
(4.2)
ğ‘š= ğ‘›ğ´e ğ‘›ğ´= ğ‘›ğµ:
2ğ‘›ğ´âˆ’ğ‘›ğ´âˆ’1
âŸ
 â
 
fase 1
+ ğ‘›ğ´
âŸ â 
fase 2
+ 2
(ï¸‚23
482ğ‘›âˆ’3
22ğ‘›ğ´+ 4
3
)ï¸‚
âŸ
 â
 
fases 3 e 4 (unitÃ¡rios)
(4.3)
As contagens acima dependem da escolha das decomposiÃ§Ãµes para as isometrias e os unitÃ¡-
rios. Os mÃ©todos escolhidos sÃ£o o QSD (SeÃ§Ã£o 2.1.4) para os unitÃ¡rios (SHENDE; BULLOCK;
MARKOV, 2006) e o CCD (SeÃ§Ã£o 2.4.2) para as isometrias (ITEN et al., 2016). Ã‰ possÃ­vel
reduzir o nÃºmero de CNOTs das isometrias para 23
6422ğ‘˜quando ğ‘š= ğ‘˜âˆ’1 usando o CSD
(SeÃ§Ã£o 2.4.3) (ITEN et al., 2016).
Quando a bipartiÃ§Ã£o Ã© completamente separÃ¡vel (ğ‘š= 0), as fases 1 e 2 nÃ£o possuem
operaÃ§Ãµes e as fases 3 e 4 sÃ£o isometrias de uma coluna. Sabendo que tais isometrias sÃ£o
equivalentes a uma preparaÃ§Ã£o de estados (SeÃ§Ã£o 2.4), elas podem ser substituÃ­das pelo prÃ³prio
LRSP. Essa operaÃ§Ã£o Ã© executada recursivamente enquanto as bipartiÃ§Ãµes forem separÃ¡veis.
Assim, o custo assintÃ³tico do circuito ğ‘‚(2ğ‘š+ğ‘›ğ‘’) serÃ¡ determinado pela maior partiÃ§Ã£o nÃ£o
separÃ¡vel na recursÃ£o com ğ‘›ğ‘’qubits.
Outro resultado deste trabalho Ã© a aproximaÃ§Ã£o low-rank (ECKART; YOUNG, 1936) para
a inicializaÃ§Ã£o de estados quÃ¢nticos usando o LRSP. Fixando a medida de Schmidt ğ‘še
descartando os valores singulares menos significativos, o algoritmo encontra um estado com
emaranhamento reduzido mais prÃ³ximo possÃ­vel do original. Isto leva a uma reduÃ§Ã£o na com-
plexidade dos circuitos, o que diminui o nÃºmero de operaÃ§Ãµes ruidosas. Mas quÃ£o complexo
o estado aproximado deve ser para alcanÃ§ar o melhor resultado depende das caracterÃ­sticas
do prÃ³prio dispositivo quÃ¢ntico. A partir desta perspectiva, a abordagem tem o potencial de
caracterizar dispositivos quÃ¢nticos quanto Ã  sua capacidade de lidar com a complexidade da
preparaÃ§Ã£o de estados.

48
Figura 26 â€“ Comparativo entre estados de 7 qubits inicializados por circuitos com 21 CNOTs construÃ­dos pelos
algoritmos qGAN e BAA.
0.0
2.5
5.0
7.5   10.0  12.5  15.0  17.5  20.0
0.00
0.02
0.04
0.06
0.08
0.10
0.0
2.5
5.0
7.5 10.0 12.5 15.0 17.5 20.0
qGAN
BAA
fidelity=1.0
fidelity=0.6754
fidelity=1.0
fidelity=0.9967
Fonte: Elaborada pelo autor (2022)
Figura 27 â€“ ComparaÃ§Ã£o entre o nÃºmero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando o algoritmo de Schmidt e o LRSP para inicializar estados emaranhados, em funÃ§Ã£o
do logaritmo do comprimento da entrada ğ‘›= log2(ğ‘).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
35000
40000
Schmidt
Low-rank
(a) NÃºmero de CNOTs
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
70000
Schmidt
Low-rank
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
Uma variante da abordagem LRSP permite um algoritmo de preparaÃ§Ã£o de estados com
erro de aproximaÃ§Ã£o limitada (Bounded Approximation error state preparation Algorithm ou
BAA) sendo Ãºtil se um certo erro de aproximaÃ§Ã£o ğ‘™tiver que ser observado. Os estados de
baixo emaranhamento podem ser geralmente criados como estados separÃ¡veis com um erro de
aproximaÃ§Ã£o baixo e custo constante, enquanto os estados de alto emaranhamento continuam
sendo difÃ­ceis de criar. Mas mesmo para emaranhamento mÃ©dio hÃ¡ melhorias considerÃ¡veis em
portas CNOT salvas, ao custo de um aumento exponencial na complexidade computacional
da etapa de preprocessamento clÃ¡ssico. A Figura 26 mostra um comparativo entre o BAA
e o Quantum Generative Adversarial Networks (qGAN), onde ambos os mÃ©todos codificam
uma distribuiÃ§Ã£o log-normal como um estado de sete qubits usando apenas 21 CNOTs em um
simulador ideal.
As tabelas 2 e 3 mostram a avaliaÃ§Ã£o do Erro Absoluto MÃ©dio (Mean Absolute Error ou

49
Figura 28 â€“ ComparaÃ§Ã£o entre o nÃºmero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando o algoritmo de Schmidt e o LRSP para inicializar estados parcialmente emaranha-
dos, em funÃ§Ã£o do logaritmo do comprimento da entrada ğ‘›= log2(ğ‘).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
35000
40000
Schmidt
Low-rank
(a) NÃºmero de CNOTs
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
70000
Schmidt
Low-rank
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
MAE) entre probabilidades ideais da mediÃ§Ã£o de estados aleatÃ³rios e as probabilidades da
mediÃ§Ã£o dos mesmo estados codificados em trÃªs dispositivos quÃ¢nticos ruidosos. Para cada
configuraÃ§Ã£o, um estado aleatÃ³rio de 7 qubits foi inicializado dez vezes. Para dispositivos rui-
dosos, o menor MAE ocorre quando o emaranhamento Ã© menor que o do estado original. Isso
indica que, em dispositivos ruidosos, Ã© vantajoso usar estados aproximados com emaranha-
mento reduzido porque a perda de fidelidade introduzida pela aproximaÃ§Ã£o Ã© menor que a
perda causada pelo ruÃ­do de circuitos mais complexos.
4.4
QCLIB: A QUANTUM COMPUTING LIBRARY
Todos os mÃ©todos listados acima estÃ£o implementados em um repositÃ³rio de cÃ³digo aberto
disponÃ­vel publicamente no github.com. A biblioteca Ã© chamada qclib (ARAUJO et al., 2022)
e abrange todos os cÃ³digos usados nesta pesquisa, mas tambÃ©m possui outras rotinas de
preparaÃ§Ã£o de estados, unitÃ¡rios e isometrias que estÃ£o disponÃ­veis de forma independente. Ã‰
baseada no Qiskit (ALEKSANDROWICZ; AL., 2021) portanto, amplamente aplicÃ¡vel a muitos
simuladores e dispositivos quÃ¢nticos.
Um dos experimentos feitos para avaliar os limites da biblioteca, e que nÃ£o estÃ¡ presente
nos artigos, Ã© o chamado Experimento Zebra. Testamos a viabilidade de codificar a imagem de
uma zebra em dispositivos quÃ¢nticos atuais. O experimento usou uma imagem preto e branco
8ppp com resoluÃ§Ã£o de 128x128 pÃ­xeis (imagem original de Brand (2019)). Tal imagem possui
16384 pÃ­xeis que podem ser codificados nas amplitudes de um estado quÃ¢ntico de 14 qubits.
A Figura 29a mostra os vetores de entrada aproximados pelo BAA. Os nÃºmeros acima de

50
Figura 29 â€“ Experimento para avaliar os limites das ferramentas atuais da biblioteca qclib.
(a) AproximaÃ§Ãµes da imagem original produzidas pelo algoritmo BAA.
(b) ReconstruÃ§Ã£o das imagens feitas a partir de mediÃ§Ãµes usando um simulador quÃ¢ntico ideal.
(c) ReconstruÃ§Ã£o das imagens a partir de mediÃ§Ãµes usando um simulador quÃ¢ntico ruidoso.
Fonte: Elaborada pelo autor (2022)
cada imagem (as quais representam os vetores) Ã© a perda de fidelidade mÃ¡xima ğ‘™max usada
nas aproximaÃ§Ãµes. As imagens na Figura 29b foram construÃ­das a partir de mediÃ§Ãµes usando
o simulador ideal ibmq_qasm_simulator. Um total de 20 execuÃ§Ãµes com 8192 shots foram
aplicadas para cada vetor de entrada para alcanÃ§ar esse resultado.
Tabela 4 â€“ NÃºmero de CNOTs para inicializar um estado quÃ¢ntico representando diferentes aproximaÃ§Ãµes da
imagem usando o BAA.
ğ‘™max
0.0
0.01
0.02
0.03
0.04
0.05
0.06
0.07
0.08
0.09
0.1
CNOTs
18175
11292
4473
2767
2767
1087
658
251
148
54
8
Fonte: Elaborada pelo autor (2022)
Finalmente, na Figura 29c, temos um experimento similar ao da figura anterior, mas usando
os modelos de ruÃ­do e conectividade do dispositivo ibmq_mumbai. Pode ser visto que o ruÃ­do
eliminou a habilidade de recuperar as imagens atravÃ©s de mediÃ§Ãµes. A exceÃ§Ã£o Ã© a imagem
com a aproximaÃ§Ã£o ğ‘™max = 0.1. Dada essa configuraÃ§Ã£o, o circuito para a inicializaÃ§Ã£o do
estado possui apenas 8 CNOTs (Tabela 4), mas tal reduÃ§Ã£o faz a imagem reconhecÃ­vel apenas
por suas caracterÃ­sticas mais significativas. Em algumas aplicaÃ§Ãµes, como aprendizagem de
mÃ¡quina, isso pode de fato ser suficiente, mas Ã© evidente que o baixo desempenho exibido
aqui limitarÃ¡ a aplicaÃ§Ã£o.
O experimento mostra que os dispositivos atuais conseguem lidar apenas com imagens
simples. E, principalmente, tambÃ©m mostra que o BAA consegue ajustar as imagens conforme
a capacidade do dispositivo utilizado. Nossa expectativa Ã© que os futuros dispositivos NISQ
logo conseguirÃ£o lidar com aplicaÃ§Ãµes de imagens do mundo real.

51
5 CONCLUSÃƒO
Embora os modelos de preparaÃ§Ã£o de estados quÃ¢nticos baseados em orÃ¡culos quÃ¢n-
ticos (GROVER, 2000; SANDERS et al., 2019; WANG et al., 2021) ou memÃ³ria quÃ¢ntica de
acesso aleatÃ³rio (TRUGENBERGER, 2001; GIOVANNETTI; LLOYD; MACCONE, 2008b; GIOVAN-
NETTI; LLOYD; MACCONE, 2008a; VERAS et al., 2021; CASARES, 2020; MATTEO; GHEORGHIU;
MOSCA, 2020) sejam Ãºteis para avaliar os limites inferiores do custo computacional e identificar
a classe de complexidade, as implementaÃ§Ãµes dos mesmos devem ser consideradas na prÃ¡tica.
Em particular, a vantagem quÃ¢ntica pode desaparecer sem uma implementaÃ§Ã£o eficiente da
preparaÃ§Ã£o de estados quando os algoritmos quÃ¢nticos dependem do carregamento de dados
clÃ¡ssicos em uma superposiÃ§Ã£o quÃ¢ntica nÃ£o uniforme (AARONSON, 2015; BIAMONTE et al.,
2017; HARROW; HASSIDIM; LLOYD, 2009; TANG, 2021). Exemplos de tais casos incluem Apren-
dizagem de MÃ¡quina QuÃ¢ntica (QML) (LLOYD; MOHSENI; REBENTROST, 2013; BIAMONTE et
al., 2017; STOUDENMIRE; SCHWAB, 2016; SCHULD; FINGERHUTH; PETRUCCIONE, 2017; SCHULD;
PETRUCCIONE, 2018; BENEDETTI et al., 2019; LEVINE et al., 2019; AARONSON, 2015; BLANK et
al., 2020), MemÃ³rias QuÃ¢nticas (QMem) (TRUGENBERGER, 2001; VENTURA; MARTINEZ, 2000;
TRUGENBERGER, 2002; GIOVANNETTI; LLOYD; MACCONE, 2008b; SILVA; OLIVEIRA; LUDERMIR,
2010; de Paula Neto et al., 2019; PARK; PETRUCCIONE; RHEE, 2019) e Ãlgebra Linear QuÃ¢ntica
(QLA) (HARROW; HASSIDIM; LLOYD, 2009; LLOYD; MOHSENI; REBENTROST, 2014; CHILDS;
KOTHARI; SOMMA, 2017; BIAMONTE et al., 2017; WOSSNIG; ZHAO; PRAKASH, 2018; REBEN-
TROST et al., 2018). Para que essas aplicaÃ§Ãµes quÃ¢nticas tornem-se realidade, Ã© imperativo
alcanÃ§ar uma inicializaÃ§Ã£o de estados quÃ¢nticos de baixa complexidade.
5.1
PRINCIPAIS RESULTADOS
As principais contribuiÃ§Ãµes desta tese resultaram em trÃªs artigos e colaboraram para a
criaÃ§Ã£o de uma biblioteca de computaÃ§Ã£o quÃ¢ntica de cÃ³digo aberto (open-source). O primeiro
artigo estÃ¡ publicado (ARAUJO et al., 2021b) e os dois restantes (ARAUJO et al., 2021a; ARAUJO;
BLANK; SILVA, 2022) foram submetidos a periÃ³dicos internacionais. Cada contribuiÃ§Ã£o busca
aperfeiÃ§oar resultados anteriores. A Tabela 5 resume os resultados das contribuiÃ§Ãµes, listando
as complexidades temporal e espacial dos circuitos produzidos pelos algoritmos apresentados
nesta tese para a inicializaÃ§Ã£o de estados quÃ¢nticos.

52
Tabela 5 â€“ SumÃ¡rio das contribuiÃ§Ãµes com as complexidades temporal e espacial dos circuitos produzidos pelos
algoritmos.
algoritmo
DCSP
BDSP
LRSP+BAA
temporal
ğ‘‚(ğ‘›2)
ğ‘‚(2ğ‘ + ğ‘›2 âˆ’ğ‘ 2)
ğ‘‚(2ğ‘š+ğ‘›ğ‘’)
espacial
ğ‘‚(2ğ‘›)
ğ‘‚((ğ‘ + 1)2ğ‘›âˆ’ğ‘ )
ğ‘‚(ğ‘›)
comentÃ¡rio
Troca entre complexidade
Troca configurÃ¡vel entre
Complexidade depende de
temporal e espacial.
complexidade temporal e
propriedades do estado. Pode
InformaÃ§Ã£o emaranhada
espacial.
ser reduzida arbitrariamente
com qubits auxiliares.
InformaÃ§Ã£o emaranhada
em troca da perda de fidelidade.
com qubits auxiliares.
InformaÃ§Ã£o nÃ£o emaranhada
com qubits auxiliares.
Fonte: Elaborada pelo autor (2022)
5.1.1
Algoritmo do tipo divisÃ£o e conquista para a preparaÃ§Ã£o de estados quÃ¢nticos
A primeira contribuiÃ§Ã£o, um algoritmo do tipo divisÃ£o e conquista para a preparaÃ§Ã£o de
estados (Divide-and-Conquer quantum State Preparation ou DCSP), produz um circuito quÃ¢n-
tico com profundidade polilogarÃ­tmica ğ‘‚(log2
2(ğ‘)), uma reduÃ§Ã£o exponencial em relaÃ§Ã£o a
resultados anteriores (SeÃ§Ã£o 4.1 e ApÃªndice A). Em troca, a largura do circuito Ã© exponencial-
mente maior, ğ‘‚(ğ‘) contra ğ‘‚(log2(ğ‘)), e a informaÃ§Ã£o Ã© emaranhada com qubits auxiliares.
5.1.2
Algoritmo bidirecional para a preparaÃ§Ã£o de estados quÃ¢nticos
O aumento exponencial na largura do circuito causado pelo DCSP Ã© reduzido pela prepa-
raÃ§Ã£o bidirecional de estados quÃ¢nticos (Bidirectional quantum State Preparation ou BDSP),
segunda contribuiÃ§Ã£o da nossa pesquisa (SeÃ§Ã£o 4.2 e ApÃªndice B). Essa estratÃ©gia permite
regular a troca entre tempo ğ‘‚(2ğ‘ + ğ‘›2 âˆ’ğ‘ 2) e espaÃ§o ğ‘‚((ğ‘ + 1)2ğ‘›âˆ’ğ‘ ) atravÃ©s do parÃ¢metro
ğ‘ , alcanÃ§ando complexidade sublinear ğ‘‚(
âˆš
ğ‘) simultÃ¢nea em ambas as dimensÃµes quando
ğ‘ = ğ‘›/2 e ğ‘â‰«1. Embora reduzido, ainda hÃ¡ emaranhamento entre a informaÃ§Ã£o e qubits
auxiliares.
5.1.3
Algoritmo baseado na decomposiÃ§Ã£o de Schmidt e na aproximaÃ§Ã£o de baixo
posto para a preparaÃ§Ã£o de estados quÃ¢nticos
Para solucionar o aumento na complexidade espacial do circuito e o emaranhamento com
qubits auxiliares, a terceira contribuiÃ§Ã£o usa o emaranhamento como um recurso computacional

53
(SeÃ§Ã£o 4.3 e apÃªndices C e D). Ao associar o emaranhamento Ã  complexidade da preparaÃ§Ã£o
de estados quÃ¢nticos, hÃ¡ maior controle sobre o nÃºmero de CNOTs necessÃ¡rios para a iniciali-
zaÃ§Ã£o de estados. Tal controle permite reduzir a complexidade temporal ğ‘‚(2ğ‘š+ğ‘›ğ‘’) mantendo
a largura do circuito ğ‘‚(ğ‘›), sem a necessidade de qubits auxiliares. Por exemplo, um estado
completamente separÃ¡vel (sem emaranhamento, ğ‘š= 0 e ğ‘›ğ‘’= 1) Ã© codificado usando apenas
duas camadas de rotaÃ§Ãµes e nenhum CNOT. Ainda Ã© possÃ­vel impor uma reduÃ§Ã£o de emara-
nhamento para obter um estado aproximado em troca de um erro (Low-Rank quantum State
Preparation ou LRSP).
5.1.4
Algoritmo de aproximaÃ§Ã£o com erro limitado para a preparaÃ§Ã£o de estados
quÃ¢nticos
A abordagem do algoritmo LRSP, em particular sua aproximaÃ§Ã£o, pode ser generalizada
por um algoritmo de busca recursivo que fornece uma aproximaÃ§Ã£o atÃ© um determinado erro
(Bounded Approximation error state preparation Algorithm ou BAA) e assim economiza o uso
dos operadores CNOT, ao mesmo tempo em que fornece uma garantia de proximidade com o
estado original.
O LRSP Ã© baseado na decomposiÃ§Ã£o de Schmidt e seu desempenho pode ser aprimorado
atravÃ©s de uma escolha cuidadosa das bipartiÃ§Ãµes. A funÃ§Ã£o do BAA Ã© encontrar a sequÃªncia
de bipartiÃ§Ãµes que permite ao LRSP produzir o circuito para a inicializaÃ§Ã£o de estados com o
menor nÃºmero de portas CNOT.
5.1.5
Biblioteca de cÃ³digo aberto para computaÃ§Ã£o quÃ¢ntica
Por fim, a pesquisa desta tese contribuiu com uma biblioteca de cÃ³digo aberto (ARAUJO
et al., 2022) que implementa todos os cÃ³digos usados nesta pesquisa, mas nÃ£o limitada a eles
(SeÃ§Ã£o 4.4).
A Tabela 6 compara numericamente os circuitos produzidos por diferentes mÃ©todos para
codificar estados exatos de 14 e 15 qubits. Os mÃ©todos LRSP, BDSP e DCSP sÃ£o contribui-
Ã§Ãµes desta pesquisa e estÃ£o implementadas na biblioteca qclib (ARAUJO et al., 2022). O mÃ©todo
baseado na decomposiÃ§Ã£o de Schmidt (SeÃ§Ã£o 2.3.2) (PLESCH; BRUKNER, 2011) tambÃ©m estÃ¡
implementado na biblioteca qclib. Embora o qclib implemente as preparaÃ§Ãµes de estados ba-
seadas na isometria CCD (SeÃ§Ã£o 2.4.2) (ITEN et al., 2016) e em multiplexadores (SHENDE;

54
Tabela 6 â€“ Comparativo numÃ©rico entre nÃºmero de qubits, CNOTs e profundidade de circuitos construÃ­dos
pelas bibliotecas qclib e IBM Qiskit usando diferentes algoritmos para a codificaÃ§Ã£o de vetores
complexos com dimensÃ£o 2ğ‘›.
ğ‘›= 14
ğ‘›= 15
mÃ©todo
lib
qubits
cnots
profund.
qubits
cnots
profund.
LRSP
qclib
14
15425
17719
15
30999
53643
Schmidt
qclib
14
15454
17821
15
38814
71581
Isometria
Qiskit
14
16369
65479
15
32752
131011
Multiplexador
Qiskit
14
32738
65492
15
65504
131025
BDSP
qclib
1023
38792
1046
1151
72320
1603
DCSP
qclib
16383
130952
783
32767
262016
899
Fonte: Elaborada pelo autor (2022)
BULLOCK; MARKOV, 2006), para esse comparativo decidimos usar a implementaÃ§Ã£o da bibli-
oteca Qiskit da IBM (ALEKSANDROWICZ; AL., 2021). O mÃ©todo Multiplexador implementa o
algoritmo de Mottonen et al. (2005) (SeÃ§Ã£o 2.3.1) otimizado com o uso dos multiplexadores de
Shende, Bullock e Markov (2006). Esse Ãºltimo Ã© a preparaÃ§Ã£o de estados padrÃ£o das bibliotecas
Qiskit (ALEKSANDROWICZ; AL., 2021) e PennyLane (BERGHOLM et al., 2020). A isometria (ITEN
et al., 2016) e o mÃ©todo baseado na decomposiÃ§Ã£o de Schmidt (PLESCH; BRUKNER, 2011), am-
bos com as otimizaÃ§Ãµes sugeridas em (SHENDE; BULLOCK; MARKOV, 2006) (SeÃ§Ã£o 2.1.4), eram
os mÃ©todos mais eficientes para a codificaÃ§Ã£o exata de estados quÃ¢nticos arbitrÃ¡rios (PLESCH;
BRUKNER, 2011; ITEN et al., 2016; MALVETTI; ITEN; COLBECK, 2021).
5.2
TRABALHOS FUTUROS
5.2.1
Big-data state preparation
Todos os mÃ©todos para a preparaÃ§Ã£o de estados quÃ¢nticos apresentados atÃ© o momento
possuem custo de prÃ©-processamento clÃ¡ssico exponencial, limitando seu uso a estados com
poucos qubits. ğ‘›qubits implica armazenar 2ğ‘›amplitudes. Usando uma estimativa simplista
- 16 bytes por amplitude complexa - sÃ£o necessÃ¡rios 2ğ‘›+4 bytes para armazenar um estado
quÃ¢ntico de ğ‘›qubits. Portanto, para 50 qubits sÃ£o necessÃ¡rios 254 â‰ˆ18 Ã— 1015 bytes (18
petabytes), o que Ã© inviÃ¡vel mesmo para os supercomputadores atuais. A normalizaÃ§Ã£o de tal
estado Ã© um desafio ainda maior. Mas Ã© justamente nesta escala que os algoritmos quÃ¢nticos
conseguirÃ£o demonstrar a vantagem quÃ¢ntica (PRESKILL, 2018), quando executarÃ£o soluÃ§Ãµes
impraticÃ¡veis para os computadores clÃ¡ssicos.

55
Figura 30 â€“ MÃ©todo bidirecional usando BAA.
|0âŸ©0
DCSP
|0âŸ©1
BAA1
|0âŸ©3
|0âŸ©2
BAA2
|0âŸ©5
output
input
ancilla
Fonte: Elaborada pelo autor (2022)
Para contornar esse problema podemos aplicar o BDSP (SeÃ§Ã£o 4.2), combinando o BAA
(SeÃ§Ã£o 4.3) com o DCSP (SeÃ§Ã£o 4.1). Dessa maneira, estados muito largos podem ser dividi-
dos em estados menores e combinados no prÃ³prio computador quÃ¢ntico (Figura 30), reduzindo
exponencialmente o teto da memÃ³ria clÃ¡ssica requerida para preparar o estado â€“ 2ğ‘›âˆ’ğ‘ subes-
tados de 2ğ‘ amplitudes, com 1 â‰¤ğ‘ â‰¤ğ‘›(ApÃªndice B). Adicionalmente, a complexidade do
circuito Ã© dominada pela fase do DCSP, que possui custo polilogarÃ­tmico, pois a complexidade
do BAA pode ser reduzida arbitrariamente em troca de uma perda de fidelidade.
Por exemplo, sendo ğ‘›= 50 e ğ‘ = 40, o BDSP gera 210 subestados com 240 amplitudes
(uma reduÃ§Ã£o de 10 qubits em relaÃ§Ã£o ao estado original). Cada subestado ocupa 244 â‰ˆ
16 Ã— 1012 bytes (16 terabytes) de armazenamento (uma reduÃ§Ã£o de aproximadamente 1000
vezes em relaÃ§Ã£o ao teto do armazenamento original). Essa configuraÃ§Ã£o produz um circuito
quÃ¢ntico com (ğ‘ + 1)2ğ‘›âˆ’ğ‘ âˆ’1 = 41 Ã— 210 âˆ’1 = 41983 qubits. A fase DCSP, responsÃ¡vel
por combinar os subestados, tem profundidade de âˆ‘ï¸€ğ‘›
ğ‘–=ğ‘ +1 ğ‘–âˆ’1 = âˆ‘ï¸€50
41 ğ‘–âˆ’1 = 445 camadas
de operadores swap controlados. Espera-se que nos prÃ³ximos anos essa ordem no nÃºmero
de qubits seja alcanÃ§ada (IBM, 2021a). A transferÃªncia de tais circuitos para o computador
quÃ¢ntico ainda Ã© um problema que precisa ser resolvido.
5.2.2
Tensor based quantum state preparation
O algoritmo de Plesch (PLESCH; BRUKNER, 2011) utiliza o SVD para executar uma decom-
posiÃ§Ã£o de Schmidt, dividindo o estado em duas partiÃ§Ãµes iguais e sequenciais (se a dimensÃ£o
do estado for Ã­mpar, uma das partes serÃ¡ maior, pois dim(â„‹1) = âŒŠğ‘›/2âŒ‹e dim(â„‹2) = âŒˆğ‘›/2âŒ‰).
O Low-Rank quantum State Preparation (LRSP) flexibiliza o algoritmo, permitindo que as

56
partiÃ§Ãµes possuam qualquer tamanho (mÃ­nimo de 1 qubit e mÃ¡ximo de n-1 qubits) e sejam
compostas de qubits nÃ£o sequenciais. Mas ainda temos a limitaÃ§Ã£o de apenas duas partiÃ§Ãµes.
O novo mÃ©todo baseado na decomposiÃ§Ã£o tensorial generaliza o LRSP, tornando configurÃ¡vel
o nÃºmero de partiÃ§Ãµes.
Figura 31 â€“ DecomposiÃ§Ã£o tensorial do estado em uma sequÃªncia de operadores atuando em um nÃºmero
crescente de qubits.
|core1âŸ©
A1
A2
A3
(a)
|core2âŸ©
B1
A1
B2,3
A2
A3
(b)
|core3âŸ©
C1,2
B1
A1
B2,3
A2
C3
A3
(c)
|core4âŸ©
D1,3
C1,2
B1
A1
D2
B2,3
A2
D1,3
C3
A3
(d)
|0âŸ©
E1,2,3
D1,3
C1,2
B1
A1
D2
B2,3
A2
D1,3
C3
A3
(e)
Fonte: Elaborada pelo autor (2022)
A principal consequÃªncia do mÃ©todo tensorial Ã© que mais CNOTs poderÃ£o ser manipulados
para gerenciar o emaranhamento do estado, abrindo novas possibilidades para algoritmos de
busca como o BAA. A Figura 31 exibe exemplos dos circuitos produzidos pela nova abordagem.
A decomposiÃ§Ã£o total, calculada atravÃ©s da decomposiÃ§Ã£o recursiva de vetores tipo core,
produz um circuito com operadores atuando em todas as combinaÃ§Ãµes de qubits (Figura 31e).
Um vetor core Ã© construÃ­do pelo redimensionamento de um tensor core. No primeiro passo
do algoritmo (Figura 31a), o vetor |ğ‘ğ‘œğ‘Ÿğ‘’1âŸ©e os operadores ğ´ğ‘—sÃ£o calculados a partir da
decomposiÃ§Ã£o tensorial do vetor de entrada. No segundo passo (Figura-31b), o vetor |ğ‘ğ‘œğ‘Ÿğ‘’2âŸ©
e os operadores ğµğ‘—sÃ£o calculados a partir da decomposiÃ§Ã£o tensorial do |ğ‘ğ‘œğ‘Ÿğ‘’1âŸ©. A recursÃ£o
continua atÃ© o Ãºltimo passo (Figura 31e), onde o vetor core Ã© igual ao primeiro vetor da base
computacional |0âŸ©, encerrando a recursÃ£o. Idealmente, os operadores maiores devem possuir
correlaÃ§Ã£o apenas entre os qubits mais distantes, pois as correlaÃ§Ãµes entre qubits mais prÃ³ximos
sÃ£o estabelecidas pelos operadores menores.
Um algoritmo de busca, como o BAA, pode alcanÃ§ar uma aproximaÃ§Ã£o limitada por um
erro mÃ¡ximo removendo operadores sistematicamente. Outra alternativa Ã© guiar a aproximaÃ§Ã£o

57
segundo o mapa de acoplamento dos qubits do dispositivo alvo, mantendo apenas os operado-
res que atuam em qubits conectados diretamente no mapa ou minimizando as distÃ¢ncias das
conexÃµes. As conexÃµes podem atÃ© mesmo ser priorizadas de acordo com sua qualidade. Ainda
Ã© possÃ­vel selecionar os operadores de acordo com o erro de CNOT entre os qubits, medida
que incorpora a distÃ¢ncia e a qualidade das conexÃµes.
Assim como no LRSP, o mÃ©todo tensorial tambÃ©m permite aproximaÃ§Ãµes tipo low-rank
do estado original. Por exemplo, o low multilinear rank (VANNIEUWENHOVEN; VANDEBRIL;
MEERBERGEN, 2012) modifica o mÃ©todo HOSVD aplicando uma sÃ©rie de aproximaÃ§Ãµes low-
rank (alterando a linha 3 do Algoritmo 4). Como resultado dessa aproximaÃ§Ã£o, os fatores da
decomposiÃ§Ã£o sÃ£o isometrias, reduzindo a complexidade dos circuitos produzidos.
De maneira geral, o rank de um tensor ğ’³de ordem ğ‘Ã© definido como o nÃºmero mÃ­nimo
de tensores rank-1 necessÃ¡rios para produzir ğ’³como sua soma.
ğ’³=
ğ‘…
âˆ‘ï¸
ğ‘Ÿ=1
ğœ†ğ‘Ÿa(1)
ğ‘Ÿ
âŠ—a(2)
ğ‘Ÿ
âŠ—Â· Â· Â· âŠ—a(ğ‘)
ğ‘Ÿ
=
[ï¸
ğœ†; A(1), A(2), . . . , A(ğ‘)]ï¸
Consequentemente, o nÃºmero de partiÃ§Ãµes (portanto, de subespaÃ§os) Ã© dado pelo modo (ou
ordem) do tensor.
Para construirmos algoritmos precisamos de mÃ©todos para elaborar a decomposiÃ§Ã£o tenso-
rial de maneira eficiente. O mÃ©todo pretendido Ã© o HOSVD, tambÃ©m conhecido como Multi-
linear Singular Value Decomposition (LATHAUWER; MOOR; VANDEWALLE, 2000). O HOSVD Ã©
uma decomposiÃ§Ã£o de Tucker ortogonal. A ortogonalidade indica que os fatores A(ğ‘›) obtidos
atravÃ©s desse mÃ©todo sÃ£o matrizes unitÃ¡rias. O Algoritmo 4 descreve seu funcionamento.
Algoritmo 4: DecomposiÃ§Ã£o HOSVD de um tensor ğ’³em um tensor core ğ’¢e seus
fatores A(1), . . . , A(ğ‘).
input : Um tensor ğ’³e uma lista de ranks ğ‘…ğ‘–(1 â‰¤ğ‘–â‰¤ğ‘).
output: Tensor core ğ’¢e os fatores A(1), . . . , A(ğ‘).
1 Faz ğ‘›= 1
2 Faz X(ğ‘›) igual ao unfold de ordem ğ‘›do tensor ğ’³
3 Aplica o SVD Ã  matriz X(ğ‘›) = A(ğ‘›)Î£ğ‘›Vğ‘‡
ğ‘›e armazena o fator A(ğ‘›)
4 Se ğ‘›< ğ‘, faz ğ‘›= ğ‘›+ 1 e retorna para 2, caso contrÃ¡rio continua
5 Calcula o tensor core ğ’¢= ğ’³Ã—1 A(1)â€  Ã—2 Â· Â· Â· Ã—ğ‘A(ğ‘)â€ 
6 Retorna ğ’¢, A(1), . . . , A(ğ‘).
Fonte: Elaborado pelo autor (2022)

58
5.3
OBSERVAÃ‡Ã•ES FINAIS
A maioria dos algoritmos quÃ¢nticos nÃ£o apresenta vantagem no carregamento de dados
clÃ¡ssicos em um estado quÃ¢ntico (BIAMONTE et al., 2017; AARONSON, 2015). Os mÃ©todos
apresentados neste trabalho propÃµem novos paradigmas para a preparaÃ§Ã£o de estados quÃ¢nticos
que podem complementar ou melhorar os mÃ©todos conhecidos, tais como a codificaÃ§Ã£o nos
Ã¢ngulos, codificaÃ§Ã£o na base, e a codificaÃ§Ã£o nas amplitudes (seÃ§Ãµes 2.2.1, 2.2.3 e 2.2.2).
O primeiro conjunto de algoritmos (seÃ§Ãµes 4.1 e 4.2 e apÃªndices A e B), baseados em Mot-
tonen et al. (2005) e na abordagem de divisÃ£o e conquista, alcanÃ§a uma reduÃ§Ã£o exponencial
no tempo para carregar um vetor de dados clÃ¡ssicos em um estado quÃ¢ntico em compara-
Ã§Ã£o a soluÃ§Ãµes anteriores como as baseadas em rotaÃ§Ãµes (SeÃ§Ã£o 2.3.1) e na decomposiÃ§Ã£o de
Schmidt (SeÃ§Ã£o 2.3.2). Tal ganho possui impacto potencial na soluÃ§Ã£o de problemas de apren-
dizagem de mÃ¡quinas quÃ¢ntica e outros algoritmos quÃ¢nticos que precisam carregar dados de
dispositivos clÃ¡ssicos.
Como prova de conceito, a validade e a viabilidade desses mÃ©todos foram verificadas
utilizando a plataforma de nuvem quÃ¢ntica da IBM (IBM, 2021b). AlÃ©m disso, os experimentos
numÃ©ricos mostraram que os novos mÃ©todos de codificaÃ§Ã£o oferecem vantagens, reduzindo a
complexidade e os recursos computacionais quando aplicado em conjunto com os algoritmos
existentes. Espera-se que estas vantagens se estendam a outros casos.
O segundo conjunto de algoritmos (SeÃ§Ã£o 4.3 e apÃªndices C e D) Ã© fundamentado em Plesch
e Brukner (2011) e utiliza a relaÃ§Ã£o entre emaranhamento quÃ¢ntico e preparaÃ§Ã£o de esta-
dos (MORA; BRIEGEL, 2005; MORA; BRIEGEL, 2006) para fornecer uma melhor compreensÃ£o
da complexidade da inicializaÃ§Ã£o de estados. Demonstrou-se que o grau de emaranhamento
do estado estÃ¡ diretamente associado ao nÃºmero de operadores CNOT necessÃ¡rios para a sua
inicializaÃ§Ã£o. Portanto, a manipulaÃ§Ã£o do emaranhamento atravÃ©s da aproximaÃ§Ã£o de low-rank
tem impacto direto na complexidade do circuito.
Experimentos com sete dispositivos quÃ¢nticos (IBM, 2021b) mostram que as mediÃ§Ãµes
do estado gerado pelos circuitos aproximados pelo low-rank sÃ£o mais prÃ³ximas dos resultados
esperados do que as mediÃ§Ãµes usando o circuito exato. Isso ocorre porque o algoritmo encontra
um estado com emaranhamento reduzido o mais prÃ³ximo possÃ­vel do original. Isto leva a uma
reduÃ§Ã£o na complexidade dos circuitos, diminuindo o nÃºmero de operaÃ§Ãµes ruidosas. Uma
aproximaÃ§Ã£o de low-rank do estado pode viabilizar o circuito final em dispositivos ruidosos
para aplicaÃ§Ãµes que dependem do carregamento de dados em um estado quÃ¢ntico arbitrÃ¡rio.

59
Um exemplo de aplicaÃ§Ã£o de aprendizagem de mÃ¡quina quÃ¢ntica do tipo Variational Quan-
tum Classifier (VQC) (HAVLÃ­ÄEK et al., 2019; SCHULD et al., 2020) mostra que o ajuste dos dados
de entrada conforme a capacidade do dispositivo em gerenciar o emaranhamento, melhora o
desempenho do classificador (ApÃªndice C). AlÃ©m disso, as aplicaÃ§Ãµes VQC tÃªm a caracterÃ­stica
de carregar o mesmo vetor de entrada muitas vezes, amortizando o tempo computacional do
prÃ©-processamento clÃ¡ssico.

60
REFERÃŠNCIAS
AARONSON, S. Read the fine print. Nature Physics, v. 11, n. 4, p. 291â€“293, 2015.
ALEKSANDROWICZ, G.; AL. et. Qiskit: An Open-source Framework for Quantum
Computing. 2021.
AMIN, M. H.; ANDRIYASH, E.; ROLFE, J.; KULCHYTSKYY, B.; MELKO, R. Quantum
boltzmann machine. Phys. Rev. X, American Physical Society, v. 8, p. 021050, May 2018.
ARAUJO, I. F.; BLANK, C.; SILVA, A. da; CESAR, I.; SILVA, L. Quantum computing library
(qclib). GitHub, 2022. DisponÃ­vel em: <https://github.com/qclib/qclib>.
ARAUJO, I. F.; BLANK, C.; SILVA, A. J. da. Approximated quantum-state preparation
with entanglement dependent complexity. arXiv:2111.03132 [quant-ph], maio 2022. ArXiv:
2111.03132.
ARAUJO, I. F.; PARK, D. K.; LUDERMIR, T. B.; OLIVEIRA, W. R.; PETRUCCIONE, F.;
SILVA, A. J. da. Configurable sublinear circuits for quantum state preparation. arXiv, 2021.
ARAUJO, I. F.; PARK, D. K.; PETRUCCIONE, F.; SILVA, A. J. da. A divide-and-conquer
algorithm for quantum state preparation. Scientific Reports, v. 11, n. 1, p. 6329, 2021.
ARUNACHALAM, S.; GHEORGHIU, V.; JOCHYM-Oâ€™CONNOR, T.; MOSCA, M.;
SRINIVASAN, P. V. On the robustness of bucket brigade quantum RAM. New Journal of
Physics, IOP Publishing, v. 17, n. 12, p. 123010, 2015.
ARUTE, F.; ARYA, K.; BABBUSH, R.; BACON, D.; BARDIN, J. C.; BARENDS, R.;
BISWAS, R.; BOIXO, S.; BRANDAO, F. G.; BUELL, D. A. et al. Quantum supremacy
using a programmable superconducting processor. Nature, Nature Publishing Group, v. 574,
n. 7779, p. 505â€“510, 2019.
BARENCO, A. A universal two-bit gate for quantum computation. Proceedings of the
Royal Society of London. Series A: Mathematical and Physical Sciences, v. 449, n. 1937, p.
679â€“683, jun. 1995. ISSN 0962-8444, 2053-9177.
BARENCO, A.; BENNETT, C. H.; CLEVE, R.; DIVINCENZO, D. P.; MARGOLUS, N.;
SHOR, P.; SLEATOR, T.; SMOLIN, J. A.; WEINFURTER, H. Elementary gates for quantum
computation. Phys. Rev. A, American Physical Society, v. 52, p. 3457â€“3467, 1995.
BARNUM, H.; LINDEN, N. Monotones and invariants for multi-particle quantum states.
Journal of Physics A: Mathematical and General, v. 34, n. 35, p. 6787, 2001. ISSN 0305-4470.
BARREIRO, J. T.; SCHINDLER, P.; GÃ¼HNE, O.; MONZ, T.; CHWALLA, M.; ROOS, C. F.;
HENNRICH, M.; BLATT, R. Experimental multiparticle entanglement dynamics induced by
decoherence. Nature Physics, v. 6, p. 943â€“946, 2010. ISSN 1745-2473.
BENEDETTI, M.; LLOYD, E.; SACK, S.; FIORENTINI, M. Parameterized quantum circuits
as machine learning models. Quantum Science and Technology, 2019.
BENIOFF, P. The computer as a physical system: A microscopic quantum mechanical
Hamiltonian model of computers as represented by Turing machines. Journal of Statistical
Physics, v. 22, n. 5, p. 563â€“591, maio 1980. ISSN 0022-4715, 1572-9613.

61
BERGHOLM, V.; IZAAC, J.; SCHULD, M.; GOGOLIN, C.; ALAM, M. S.; AHMED, S.;
ARRAZOLA, J. M.; BLANK, C.; DELGADO, A.; JAHANGIRI, S.; MCKIERNAN, K.;
MEYER, J. J.; NIU, Z.; SZÃ¡VA, A.; KILLORAN, N. PennyLane: Automatic differentiation of
hybrid quantum-classical computations. 2020.
BERGHOLM, V.; VARTIAINEN, J. J.; MÃ¶TTÃ¶NEN, M.; SALOMAA, M. M. Quantum
circuits with uniformly controlled one-qubit gates. Physical Review A, v. 71, n. 5, p. 052330,
2005.
BIAMONTE, J.; WITTEK, P.; PANCOTTI, N.; REBENTROST, P.; WIEBE, N.; LLOYD, S.
Quantum machine learning. Nature, v. 549, n. 7671, p. 195â€“202, 2017.
BLANK, C.; PARK, D. K.; PETRUCCIONE, F. Quantum-enhanced analysis of discrete
stochastic processes. npj Quantum Information, Nature Publishing Group, v. 7, n. 1, p. 1â€“9,
2021.
BLANK, C.; PARK, D. K.; RHEE, J.-K. K.; PETRUCCIONE, F. Quantum classifier with
tailored quantum kernel. npj Quantum Information, v. 6, n. 1, p. 1â€“7, 2020.
BRAND, J. 2019. [Online; accessed March 3, 2022]. DisponÃ­vel em: <https://unsplash.com/
photos/dbz3gmdubqw>.
CALDERBANK, A. R.; SHOR, P. W. Good quantum error-correcting codes exist. Phys. Rev.
A, American Physical Society, v. 54, p. 1098â€“1105, 1996.
CASARES, P. A. M. Circuit implementation of bucket brigade qram for quantum state
preparation. arXiv, 2020.
CHILDS, A. M.; KOTHARI, R.; SOMMA, R. D. Quantum algorithm for systems of linear
equations with exponentially improved dependence on precision. SIAM Journal on Computing,
Society for Industrial Applied Mathematics (SIAM), v. 46, n. 6, p. 1920â€“1950, 2017.
CLEVE, R.; GOTTESMAN, D.; LO, H.-K. How to share a quantum secret. Phys. Rev. Lett.,
American Physical Society, v. 83, p. 648â€“651, 1999.
CORTESE, J. A.; BRAJE, T. M. Loading Classical Data into a Quantum Computer. 2018.
de Paula Neto, F. M.; da Silva, A. J.; de Oliveira, W. R.; LUDERMIR, T. B. Quantum
probabilistic associative memory architecture. Neurocomputing, v. 351, p. 101â€“110, 2019.
DEUTSCH, D.; JOZSA, R. Rapid solution of problems by quantum computation. Proceedings
of the Royal Society of London. Series A: Mathematical and Physical Sciences, v. 439,
n. 1907, p. 553â€“558, 1992.
DEUTSCH, D.; PENROSE, R. Quantum theory, the Churchâ€“Turing principle and the
universal quantum computer. Proceedings of the Royal Society of London. A. Mathematical
and Physical Sciences, v. 400, n. 1818, p. 97â€“117, jul. 1985.
DEUTSCH, D. E.; BARENCO, A.; EKERT, A. Universality in quantum computation.
Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences,
v. 449, n. 1937, p. 669â€“677, jun. 1995. ISSN 0962-8444, 2053-9177.
DIVINCENZO, D. P. Two-bit gates are universal for quantum computation. Phys. Rev. A,
American Physical Society, v. 51, p. 1015â€“1022, Feb 1995.

62
DIVINCENZO, D. P. The physical implementation of quantum computation. Fortschritte der
Physik, v. 48, n. 9-11, p. 771â€“783, 2000.
DONNE, J. Devotions upon Emergent Occasions. 2007. ed. London: Project Gutenberg,
1624.
DUNJKO, V.; TAYLOR, J. M.; BRIEGEL, H. J. Quantum-enhanced machine learning. Phys.
Rev. Lett., American Physical Society, v. 117, p. 130501, Sep 2016.
DÃ¼R, W.; CIRAC, J. I. Multiparty teleportation. Journal of Modern Optics, Taylor Francis,
v. 47, n. 2-3, p. 247â€“255, 2000.
ECKART, C.; YOUNG, G. The approximation of one matrix by another of lower rank.
Psychometrika, Springer, v. 1, n. 3, p. 211â€“218, 1936.
ENRÃ­QUEZ, M.; PUCHAÅ‚A, Z.; Å»YCZKOWSKI, K. Minimal rÃ©nyiâ€“ingardenâ€“urbanik entropy
of multipartite quantum states. Entropy, v. 17, n. 7, p. 5063â€“5084, 2015. ISSN 1099-4300.
FEYNMAN, R. P. Simulating physics with computers. International Journal of Theoretical
Physics, v. 21, n. 6-7, p. 467â€“488, jun. 1982. ISSN 0020-7748, 1572-9575.
GIDNEY, C.; EKERÃ…, M. How to factor 2048 bit RSA integers in 8 hours using 20
million noisy qubits. Quantum, Verein zur FÃ¶rderung des Open Access Publizierens in den
Quantenwissenschaften, v. 5, p. 433, abr. 2021. ISSN 2521-327X.
GIOVANNETTI, V.; LLOYD, S.; MACCONE, L. Architectures for a quantum random access
memory. Phys. Rev. A, American Physical Society, v. 78, p. 052310, 2008.
GIOVANNETTI, V.; LLOYD, S.; MACCONE, L. Quantum random access memory. Phys.
Rev. Lett., American Physical Society, v. 100, p. 160501, 2008.
GLEINIG, N.; HOEFLER, T. An Efficient Algorithm for Sparse Quantum State Preparation.
In: 2021 58th ACM/IEEE Design Automation Conference (DAC). San Francisco, CA, USA:
IEEE, 2021. p. 433â€“438. ISBN 9781665432740.
GRASEDYCK, L. Hierarchical singular value decomposition of tensors. SIAM J. Matrix Anal.
Appl., Society for Industrial and Applied Mathematics, USA, v. 31, n. 4, p. 2029â€“2054, 2010.
ISSN 0895-4798.
GROVER, L. K. A fast quantum mechanical algorithm for database search. In: Proceedings
of the twenty-eighth annual ACM symposium on Theory of Computing. Philadelphia,
Pennsylvania, USA: Association for Computing Machinery, 1996. (STOC â€™96), p. 212â€“219.
GROVER, L. K. Synthesis of Quantum Superpositions by Quantum Computation. Physical
Review Letters, v. 85, n. 6, p. 1334â€“1337, 2000.
GUNDLAPALLI, P.; LEE, J. Deterministic, scalable, and entanglement efficient initialization
of arbitrary quantum states. arXiv, 2021.
GUO, S.-F.; CHEN, F.; LIU, Q.; XUE, M.; CHEN, J.-J.; CAO, J.-H.; MAO, T.-W.; TEY,
M. K.; YOU, L. Faster state preparation across quantum phase transition assisted by
reinforcement learning. Phys. Rev. Lett., American Physical Society, v. 126, p. 060401, 2021.
HARROW, A. W.; HASSIDIM, A.; LLOYD, S. Quantum algorithm for linear systems of
equations. Phys. Rev. Lett., American Physical Society, v. 103, p. 150502, 2009.

63
HAVLÃ­ÄEK, V.; CÃ³RCOLES, A. D.; TEMME, K.; HARROW, A. W.; KANDALA, A.; CHOW,
J. M.; GAMBETTA, J. M. Supervised learning with quantum-enhanced feature spaces.
Nature, v. 567, p. 209â€“212, 2019.
HILL, S. A.; WOOTTERS, W. K. Entanglement of a pair of quantum bits. Phys. Rev. Lett.,
American Physical Society, v. 78, p. 5022â€“5025, Jun 1997.
HOGG, T.; HUBERMAN, B. A.; WILLIAMS, C. P. Phase transitions and the search problem.
Artificial Intelligence, v. 81, n. 1, p. 1â€“15, 1996. Frontiers in Problem Solving: Phase
Transitions and Complexity.
IBM. IBMâ€™s Roadmap For Scaling Quantum Technology. 2020. DisponÃ­vel em:
<https://research.ibm.com/blog/ibm-quantum-roadmap>.
IBM. Expanding the IBM Quantum Roadmap to anticipate the future of quantum-
centric supercomputing. 2021. DisponÃ­vel em: <https://research.ibm.com/blog/
ibm-quantum-roadmap-2025>.
IBM. IBM Quantum. 2021. DisponÃ­vel em: <https://quantum-computing.ibm.com/>.
ITEN, R.; COLBECK, R.; KUKULJAN, I.; HOME, J.; CHRISTANDL, M. Quantum circuits
for isometries. Physical Review A, APS, v. 93, n. 3, p. 032318, 2016.
JOZSA, R.; LINDEN, N. On the role of entanglement in quantum-computational speed-up.
Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering
Sciences, The Royal Society, v. 459, n. 2036, p. 2011â€“2032, 2003.
KHANEJA, N.; BROCKETT, R.; GLASER, S. J. Time optimal control in spin systems. Phys.
Rev. A, American Physical Society, v. 63, p. 032308, 2001.
KIEFEROVÃ, M.; WIEBE, N. Tomography and generative training with quantum boltzmann
machines. Phys. Rev. A, American Physical Society, v. 96, p. 062327, Dec 2017.
KNILL, E. Approximation by quantum circuits. arXiv, 1995.
KOLDA, T. G.; BADER, B. W. Tensor Decompositions and Applications. SIAM Review,
v. 51, n. 3, p. 455â€“500, 2009. ISSN 0036-1445.
KRAUS, B.; CIRAC, J. I. Optimal creation of entanglement using a two-qubit gate. Phys.
Rev. A, American Physical Society, v. 63, p. 062309, May 2001.
KUZMIN, V. V.; SILVI, P. Variational quantum state preparation via quantum data buses.
Quantum, Verein zur FÃ¶rderung des Open Access Publizierens in den Quantenwissenschaften,
v. 4, p. 290, 2020. ISSN 2521-327X.
LATHAUWER, L. D.; MOOR, B. D.; VANDEWALLE, J. A multilinear singular value
decomposition. SIAM Journal on Matrix Analysis and Applications, v. 21, n. 4, p. 1253â€“1278,
2000.
LEVINE, Y.; SHARIR, O.; COHEN, N.; SHASHUA, A. Quantum Entanglement in Deep
Learning Architectures. Physical Review Letters, v. 122, n. 6, p. 065301, 2019.
LEYMANN, F.; BARZEN, J. The bitter truth about gate-based quantum algorithms in the
NISQ era. Quantum Science and Technology, IOP Publishing, v. 5, n. 4, p. 044007, 2020.

64
LLOYD, S. Almost any quantum logic gate is universal. Phys. Rev. Lett., American Physical
Society, v. 75, p. 346â€“349, Jul 1995.
LLOYD, S.; MOHSENI, M.; REBENTROST, P. Quantum algorithms for supervised and
unsupervised machine learning. arXiv:1307.0411 [quant-ph], 2013.
LLOYD, S.; MOHSENI, M.; REBENTROST, P. Quantum principal component analysis.
Nature Physics, v. 10, n. 9, p. 631â€“633, set. 2014. ISSN 1745-2481.
LONG, G.-L.; SUN, Y. Efficient scheme for initializing a quantum register with an arbitrary
superposed state. Physical Review A, v. 64, n. 1, p. 014303, 2001.
LOW, G. H.; KLIUCHNIKOV, V.; SCHAEFFER, L. Trading T-gates for dirty qubits in state
preparation and unitary synthesis. 2018.
LOW, G. H.; YODER, T. J.; CHUANG, I. L. Quantum inference on bayesian networks. Phys.
Rev. A, American Physical Society, v. 89, p. 062315, Jun 2014.
MALVETTI, E.; ITEN, R.; COLBECK, R. Quantum circuits for sparse isometries. Quantum,
v. 5, p. 412, 2021.
MANIN, Y. I. Computable and Non-Computable. Sovetskoe Radio, Moscow: [s.n.], 1980.
128 p.
MARIN-SANCHEZ, G.; GONZALEZ-CONDE, J.; SANZ, M. Quantum algorithms for
approximate function loading. arXiv, 2021.
MATTEO, O. D.; GHEORGHIU, V.; MOSCA, M. Fault-tolerant resource estimation of
quantum random-access memories. IEEE Transactions on Quantum Engineering, v. 1, p.
1â€“13, 2020.
MOLL, N.; BARKOUTSOS, P.; BISHOP, L. S.; CHOW, J. M.; CROSS, A.; EGGER,
D. J.; FILIPP, S.; FUHRER, A.; GAMBETTA, J. M.; GANZHORN, M.; KANDALA, A.;
MEZZACAPO, A.; MÃ¼LLER, P.; RIESS, W.; SALIS, G.; SMOLIN, J.; TAVERNELLI, I.;
TEMME, K. Quantum optimization using variational algorithms on near-term quantum
devices. Quantum Science and Technology, IOP Publishing, v. 3, n. 3, p. 030503, 2018.
MORA, C. E.; BRIEGEL, H. J. Algorithmic complexity and entanglement of quantum states.
Phys. Rev. Lett., American Physical Society, v. 95, p. 200503, 2005.
MORA, C. E.; BRIEGEL, H. J. Algorithmic complexity of quantum states. International
Journal of Quantum Information, v. 04, p. 715â€“737, 2006. ISSN 0219-7499.
MOTTONEN, M.; VARTIAINEN, J. J.; BERGHOLM, V.; SALOMAA, M. M. Transformation
of Quantum States Using Uniformly Controlled Rotations. Quantum Info. Comput., v. 5,
n. 6, p. 467â€“473, 2005.
MOZAFARI, F.; RIENER, H.; SOEKEN, M.; MICHELI, G. D. Efficient Boolean Methods for
Preparing Uniform Quantum States. IEEE Transactions on Quantum Engineering, v. 2, p.
1â€“12, 2021. ISSN 2689-1808.
MOZAFARI, F.; SOEKEN, M.; RIENER, H.; MICHELI, G. D. Automatic Uniform Quantum
State Preparation Using Decision Diagrams. In: 2020 IEEE 50th International Symposium
on Multiple-Valued Logic (ISMVL). Miyazaki, Japan: IEEE, 2020. p. 170â€“175. ISBN
9781728154060.

65
NAKAJI, K.; UNO, S.; SUZUKI, Y.; RAYMOND, R.; ONODERA, T.; TANAKA, T.;
TEZUKA, H.; MITSUDA, N.; YAMAMOTO, N. Approximate amplitude encoding in shallow
parameterized quantum circuits and its application to financial market indicator. arXiv, 2021.
NIELSEN, M. A.; CHUANG, I. L. Quantum computation and quantum information.
10th anniversary ed. ed. Cambridge ; New York: Cambridge University Press, 2010. ISBN
9781107002173.
ORÃºS, R. A practical introduction to tensor networks: Matrix product states and projected
entangled pair states. Annals of Physics, v. 349, p. 117â€“158, 2014. ISSN 0003-4916.
PAIGE, C.; WEI, M. History and generality of the cs decomposition. Linear Algebra and its
Applications, v. 208-209, p. 303â€“326, 1994. ISSN 0024-3795.
PALER, A.; OUMAROU, O.; BASMADJIAN, R. Parallelizing the queries in a bucket-brigade
quantum random access memory. Physical Review A, v. 102, n. 3, p. 032608, 2020. ISSN
2469-9926, 2469-9934.
PARK, D. K.; PETRUCCIONE, F.; RHEE, J.-K. K. Circuit-Based Quantum Random Access
Memory for Classical Data. Scientific Reports, v. 9, n. 1, p. 3949, 2019.
PARK, D. K.; SINAYSKIY, I.; FINGERHUTH, M.; PETRUCCIONE, F.; RHEE, J.-K. K.
Parallel quantum trajectories via forking for sampling without redundancy. New Journal of
Physics, IOP Publishing, v. 21, n. 8, p. 083024, 2019.
PEREZ-GARCIA, D.; VERSTRAETE, F.; WOLF, M. M.; CIRAC, J. I. Matrix Product State
Representations. arXiv, 2006.
PLESCH, M.; BRUKNER, C. Quantum-state preparation with universal gate decompositions.
Physical Review A, v. 83, n. 3, p. 032302, 2011.
PRESKILL, J. Quantum computing and the entanglement frontier. arXiv, 2012.
PRESKILL, J. Quantum Computing in the NISQ era and beyond. Quantum, v. 2, p. 79, 2018.
RAUSSENDORF, R.; BRIEGEL, H. J. A one-way quantum computer. Phys. Rev. Lett.,
American Physical Society, v. 86, p. 5188â€“5191, 2001.
REBENTROST, P.; MOHSENI, M.; LLOYD, S. Quantum Support Vector Machine for Big
Data Classification. Physical Review Letters, v. 113, n. 13, p. 130503, 2014.
REBENTROST, P.; STEFFENS, A.; MARVIAN, I.; LLOYD, S. Quantum singular-value
decomposition of nonsparse low-rank matrices. Physical Review A, American Physical Society
(APS), v. 97, n. 1, 2018.
RIVEST, R. L.; SHAMIR, A.; ADLEMAN, L. A method for obtaining digital signatures and
public-key cryptosystems. Commun. ACM, Association for Computing Machinery, New York,
NY, USA, v. 21, n. 2, p. 120â€“126, feb 1978. ISSN 0001-0782.
RÃ¸NNOW, T. F.; WANG, Z.; JOB, J.; BOIXO, S.; ISAKOV, S. V.; WECKER, D.; MARTINIS,
J. M.; LIDAR, D. A.; TROYER, M. Defining and detecting quantum speedup. Science,
v. 345, n. 6195, p. 420â€“424, 2014.

66
SANDERS, Y. R.; LOW, G. H.; SCHERER, A.; BERRY, D. W. Black-box quantum state
preparation without arithmetic. Phys. Rev. Lett., American Physical Society, v. 122, p.
020502, 2019.
SCHULD, M.; BOCHAROV, A.; SVORE, K. M.; WIEBE, N. Circuit-centric quantum
classifiers. Phys. Rev. A, American Physical Society, v. 101, p. 032308, 2020.
SCHULD, M.; FINGERHUTH, M.; PETRUCCIONE, F. Implementing a distance-based
classifier with a quantum interference circuit. EPL (Europhysics Letters), v. 119, n. 6, p.
60002, 2017.
SCHULD, M.; PETRUCCIONE, F. Supervised Learning with Quantum Computers. 1st ed.
2018. ed. Cham: Springer International Publishing : Imprint: Springer, 2018. (Quantum
Science and Technology).
SHENDE, V.; BULLOCK, S.; MARKOV, I. Synthesis of quantum-logic circuits. IEEE
Transactions on Computer-Aided Design of Integrated Circuits and Systems, v. 25, n. 6, p.
1000â€“1010, 2006.
SHENDE, V.; MARKOV, I.; BULLOCK, S. Smaller two-qubit circuits for quantum
communication and computation. In: Proceedings Design, Automation and Test in Europe
Conference and Exhibition. IEEE Xplore: IEEE, 2004b. v. 2, p. 980â€“985.
SHENDE, V. V.; BULLOCK, S. S.; MARKOV, I. L. Recognizing small-circuit structure in
two-qubit operators. Phys. Rev. A, American Physical Society, v. 70, p. 012310, 2004c.
SHENDE, V. V.; MARKOV, I. L.; BULLOCK, S. S. Minimal universal two-qubit controlled-
NOT-based circuits. Physical Review A, American Physical Society (APS), v. 69, n. 6,
2004a.
SHIMONY, A. Degree of Entanglement. Annals of the New York Academy of Sciences,
v. 755, n. 1, p. 675â€“679, 1995. ISSN 1749-6632.
SHOR, P. W. Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms
on a Quantum Computer. SIAM Review, v. 41, n. 2, p. 303â€“332, 1999.
SILVA, A.; OLIVEIRA, W. d.; LUDERMIR, T. A Weightless Neural Node Based on a
Probabilistic Quantum Memory. In: 2010 Eleventh Brazilian Symposium on Neural Networks.
Sao Paulo, Brazil: IEEE, 2010. p. 259â€“264. ISSN: 2375-0235.
SIMON, D. R. On the Power of Quantum Computation. SIAM Journal on Computing, v. 26,
n. 5, p. 1474â€“1483, 1997.
STAMATOPOULOS, N.; EGGER, D. J.; SUN, Y.; ZOUFAL, C.; ITEN, R.; SHEN, N.;
WOERNER, S. Option Pricing using Quantum Computers. Quantum, v. 4, p. 291, 2020.
STEANE, A. Multiple-particle interference and quantum error correction. Proceedings of the
Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences, v. 452,
p. 2551â€“2577, 1996. ISSN 1364-5021.
STEWART, G. W.; SUN, J.-g. Matrix perturbation theory. Boston: Academic Press, 1990.
(Computer science and scientific computing). ISBN 9780126702309.

67
STOUDENMIRE, E.; SCHWAB, D. J. Supervised learning with tensor networks. In: LEE,
D.; SUGIYAMA, M.; LUXBURG, U.; GUYON, I.; GARNETT, R. (Ed.). Advances in Neural
Information Processing Systems. Centre Convencions Internacional Barcelona, Barcelona
Spain: Curran Associates, Inc., 2016. v. 29, p. 9.
TANG, E. Quantum principal component analysis only achieves an exponential speedup
because of its state preparation assumptions. Phys. Rev. Lett., American Physical Society,
v. 127, p. 060503, 2021.
TENG, P. Accurate calculation of the geometric measure of entanglement for multipartite
quantum states. Quantum Information Processing, v. 16, n. 7, p. 181, 2017. ISSN 1570-0755.
TERHAL, B. M.; SMOLIN, J. A. Single quantum querying of a database. Physical Review A,
v. 58, n. 3, p. 1822â€“1826, 1998.
TRUGENBERGER, C. A. Probabilistic quantum memories. Physical Review Letters, v. 87,
n. 6, 2001.
TRUGENBERGER, C. A. Quantum Pattern Recognition. Quantum Information Processing,
v. 1, n. 6, p. 471â€“493, 2002.
TUCCI, R. R. A rudimentary quantum compiler(2cnd ed.). arXiv, 1999.
VANNIEUWENHOVEN, N.; VANDEBRIL, R.; MEERBERGEN, K. A new truncation strategy
for the higher-order singular value decomposition. SIAM Journal on Scientific Computing,
v. 34, n. 2, p. A1027â€“A1052, 2012.
VASUDEVAN, V.; RAMAKRISHNA, M. A hierarchical singular value decomposition algorithm
for low rank matrices. arXiv, 2017.
VENTURA, D.; MARTINEZ, T. Initializing the Amplitude Distribution of a Quantum State.
Foundations of Physics Letters, v. 12, n. 6, p. 547â€“559, 1999.
VENTURA, D.; MARTINEZ, T. Quantum associative memory. Information Sciences, v. 124,
n. 1, p. 273â€“296, 2000.
VERAS, T. L. de; ARAUJO, I. S. de; PARK, D. K.; SILVA, A. J. da. Circuit-based quantum
random access memory for classical data with continuous amplitudes. IEEE Transactions on
Computers, IEEE Computer Society, Los Alamitos, CA, USA, v. 70, n. 12, p. 2125â€“2135, dec
2021. ISSN 1557-9956.
VERAS, T. M. L. de; SILVA, L. D. da; SILVA, A. J. da. Double sparse quantum state
preparation. Quantum Information Processing, v. 21, n. 6, p. 204, jun. 2022. ISSN 1573-1332.
WANG, S.; WANG, Z.; CUI, G.; SHI, S.; SHANG, R.; FAN, L.; LI, W.; WEI, Z.; GU, Y.
Fast black-box quantum state preparation based on linear combination of unitaries. Quantum
Information Processing, v. 20, n. 8, p. 270, 2021. ISSN 1573-1332.
WEI, T.-C.; GOLDBART, P. M. Geometric measure of entanglement and applications to
bipartite and multipartite quantum states. Physical Review A, v. 68, n. 4, p. 042307, 2003.
ISSN 1050-2947.
WIEBE, N.; BRAUN, D.; LLOYD, S. Quantum algorithm for data fitting. Phys. Rev. Lett.,
American Physical Society, v. 109, p. 050505, Aug 2012.

68
WIEBE, N.; GRANDADE, C. Can small quantum systems learn. Quantum Info. Comput.,
Rinton Press, Incorporated, Paramus, NJ, v. 17, n. 7â€“8, p. 568â€“594, jun 2017. ISSN
1533-7146.
WIEBE, N.; KAPOOR, A.; SVORE, K. M. Quantum deep learning. arXiv, 2014.
WIEBE, N.; KAPOOR, A.; SVORE, K. M. Quantum perceptron models. In: Proceedings of
the 30th International Conference on Neural Information Processing Systems. Red Hook, NY,
USA: Curran Associates Inc., 2016. (NIPSâ€™16), p. 4006â€“4014. ISBN 9781510838819.
WILLIAMS, C. P. Quantum gates. In:
. Explorations in Quantum Computing. London:
Springer London, 2011. p. 51â€“122. ISBN 978-1-84628-887-6.
WILLSCH, D.; NOCON, M.; JIN, F.; RAEDT, H. D.; MICHIELSEN, K. Gate-error analysis
in simulations of quantum computers with transmon qubits. Phys. Rev. A, American Physical
Society, v. 96, p. 062302, Dec 2017.
WOERNER, S.; EGGER, D. J. Quantum Risk Analysis. npj Quantum Information, v. 5, n. 1,
p. 15, 2019.
WOSSNIG, L.; ZHAO, Z.; PRAKASH, A. Quantum linear system algorithm for dense
matrices. Phys. Rev. Lett., American Physical Society, v. 120, p. 050502, 2018.
XIN, T.; WEI, S.; CUI, J.; XIAO, J.; ARRAZOLA, I. n.; LAMATA, L.; KONG, X.; LU, D.;
SOLANO, E.; LONG, G. Quantum algorithm for solving linear differential equations: Theory
and experiment. Phys. Rev. A, American Physical Society, v. 101, p. 032307, Mar 2020.
ZHANG, X.-M.; YUNG, M.-H.; YUAN, X. Low-depth quantum state preparation. Phys. Rev.
Research, American Physical Society, v. 3, p. 043200, 2021.
ZHAO, Z.; FITZSIMONS, J. K.; REBENTROST, P.; DUNJKO, V.; FITZSIMONS, J. F.
Smooth input preparation for quantum and quantum-inspired machine learning. Quantum
Machine Intelligence, v. 3, n. 1, p. 14, 2021. ISSN 2524-4914.
ZOUFAL, C.; LUCCHI, A.; WOERNER, S. Quantum generative adversarial networks for
learning and loading random distributions. npj Quantum Information, Nature Publishing
Group, v. 5, n. 1, p. 1â€“9, 2019.

1
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  
| https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports
A divideâ€‘andâ€‘conquer algorithm 
forÂ quantum state preparation
IsraelÂ F.Â Araujo1, DanielÂ K.Â Park2, FrancescoÂ Petruccione3,4,5*Â & AdeniltonÂ J.Â daÂ Silva1â€Š
Advantages in several fields of research and industry are expected with the rise of quantum computers. 
However, the computational cost to load classical data in quantum computers can impose restrictions 
on possible quantum speedups. Known algorithms to create arbitrary quantum states require quantum 
circuits with depth O(N) to load an N-dimensional vector. Here, we show that it is possible to load an 
N-dimensional vector with exponential time advantage using a quantum circuit with polylogarithmic 
depth and entangled information in ancillary qubits. Results show that we can efficiently load data in 
quantum devices using a divide-and-conquer strategy to exchange computational time for space. We 
demonstrate a proof of concept on a real quantum device and present two applications for quantum 
machine learning. We expect that this new loading strategy allows the quantum speedup of tasks that 
require to load a significant volume of information to quantum devices.
The development of quantum computers can dramatically reduce the time to solve certain computational Â­tasks1. 
However, in practical applications, the cost to load the classical information in a quantum device can dominate 
the asymptotic computational cost of the quantum Â­algorithm2,3. Loading information into a device is a common 
task in computer science applications. For instance, deep neural Â­networks4 learning algorithms run in specialized 
Â­hardware5, and the computational cost to transfer the information needs to be considered in the total computa-
tional cost as data loading can dominate the training time on large-scale Â­systems6. In classical devices, we can use 
the loaded information several times while we do not erase it. The situation is not the same in quantum devices 
because of the no-cloning Â­theorem7, noisy quantum Â­operations8, and the decoherence of quantum Â­information9. 
The no-cloning theorem shows that it is not possible to perform a copy of an arbitrary quantum state. When 
a quantum operation is applied, its input is transformed or is destroyed (collapsed). Even if we represent the 
information in a basis state that we can copy, the noisy operations and decoherence will corrupt the stored state, 
and it will be necessary to reload the information from the classical to the quantum device.
Loading an input vector x = (x0, . . . , xNâˆ’1) to the amplitudes of a quantum system corresponds to create the 
state with log2(N) quantum bits described in Eq.Â (1).
Circuits to load an N-dimensional classical unit vector in quantum devices use n = log2(N) qubits and have an 
exponential depth in relation to the number of qubits (or polynomial in the data size)10â€“13.
Here we propose a new format of data encoding. Namely, we load an N-dimensional vector in probability 
amplitudes of computational basis state with entangled information in ancillary qubits as
where |Ïˆj are unit vectors. We propose an algorithm to load an N-dimensional vector in a quantum state as 
shown in Eq.Â (2) using a circuit with O(log2
2(N)) depth and O(N) qubits. The devised method is based on quan-
tum Â­forking13,14 and uses a divide-and-conquer Â­strategy15. The circuit depth is decreased at the cost of increasing 
the circuit width and creating entanglement between data register qubits and an ancillary system. Thus when 
the data register is considered alone (i.e. by tracing out the ancilla qubits), the resulting state is mixed and not 
equal to the pure state shown in Eq.Â (1). However, it is important to note that in Eq.Â (2) the classical data is still 
encoded as probability amplitudes of an orthonormal basis set. Useful applications can be constructed based on 
this, and we provide two example applications in machine learning and statistical analysis.
The divide-and-conquer paradigm is used in efficient algorithms for Â­sorting16, computing the discrete Fourier 
Â­transform17, and Â­others15. The main idea is to divide a problem into subproblems of the same class and combine the 
(1)
x0|0 + Â· Â· Â· + xNâˆ’1|N âˆ’1
(2)
x0|0|Ïˆ0 + Â· Â· Â· + xNâˆ’1|N âˆ’1|ÏˆNâˆ’1,
OPEN
1Centro de InformÃ¡tica, Universidade Federal de Pernambuco, Recife, Pernambuco, Brazil. 2Sungkyunkwan 
University Advanced Institute of Nanotechnology, SuwonÂ 16419, South Korea. 3School of Electrical Engineering, 
KAIST, DaejeonÂ 34141, Republic of Korea. 4Quantum Research Group, School of Chemistry and Physics, University 
of KwaZulu-Natal, Durban, KwaZuluâ€‘NatalÂ 4001, South Africa. 5National Institute for Theoretical Physics (NITheP), 
Durban, KwaZuluâ€‘NatalÂ 4001, South Africa. *email: petruccione@ukzn.ac.za
69
APÃŠNDICE A â€“ A DIVIDE-AND-CONQUER ALGORITHM FOR QUANTUM
STATE PREPARATION

2
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
solutions of the subproblems to obtain the solution of the original problem. The circuit based divide-and-conquer 
state preparation algorithm has computational cost O(N) and the total complexity time is Oc(N) + Oq(log2
2(N))â€Š, 
where Oc(N) is classical pre-computation time to create the quantum circuit that will load the information in the 
quantum device and Oq(log2
2(N)) is the depth of the quantum circuit. With the supposition that we will load the input 
vector m â‰«N times, the amortized computational time to load the real vector is Oq(log2
2(N))â€Š. The modified ver-
sion of the loading problem allows an exponential advantage in the depth of the quantum circuit using O(N) qubits.
The remainder of this paper is organized into 3 sections. â€œTransformation of quantum statesâ€ section reviews 
one of the standard methods for loading information in a quantum device using controlled Â­rotations10, which we 
set out to modify to reduce its quantum circuit depth exponentially. â€œDivide-and-conquer loading dataâ€ section 
shows the main result, a quantum circuit with depth O(log2
2(N))â€Š, and O(N) qubits to load an N-dimensional 
vector in a quantum state with entangled information in the ancillary qubits. â€œDiscussionâ€ section presents the 
conclusion and possible future works.
Transformation ofÂ quantum states
In this section, we review a strategy for loading a real vector into the amplitudes of a quantum state using a sequence 
of controlled one-qubit Â­rotations10. Given an N-dimensional vector x, where n = log2(N) is an integer, we can cre-
ate a circuit to load this vector in a quantum computer using AlgorithmÂ 1. The task of amplitude encoding (Algo-
rithmÂ 1) has two parts: (1) Function gen_angles (LineÂ 1) finds angles to perform rotations that lead |0n â‰¡|0âŠ—n 
to the state in Eq.Â (1), and (2) Function gen_circuit (LineÂ 18) generates a quantum circuit from these rotations.
70

3
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Function gen_anglesÂ (AlgorithmÂ 1, LineÂ 1) divides the 2n-dimensional input vector into 2nâˆ’1 2-dimen-
sional subvectors and creates a 2nâˆ’1-dimensional vector new_x with the norms of the subvectors. While the size 
of new_x is greater than 1, the new_x vector is recursively passed as the input of function gen_anglesÂ . This 
procedure is described in linesÂ 3 to 6 of AlgorithmÂ 1. An example of the inputs in the recursive calls with the 
initial input
is presented in the binary tree named state-tree inÂ Fig.Â 1b.
After the last recursive call of the function gen_anglesÂ , the algorithm starts to compute the vector angles. 
For each k between 0 and the size of vector new_xâ€Š, we append an angle Î¸ such that sin(Î¸/2) = x[2k+1]
new_x[k] and 
cos(Î¸/2) =
x[2k]
new_x[k] to the vector angles. LinesÂ 7 to 16 generate the vector angles in the recursive calls. For the 
input in Fig.Â 1b and using two decimal points the algorithm outputs angles = (1.98,Â 1.91,Â 1.43,Â 1.98,Â 1.05,Â 2.09,Â 
1.23). The angles vector is used as a complete binary tree named angles-tree. For instance, with Î±k = angles[k]â€Š, 
the angles-tree created by gen_anglesÂ with an eight-dimensional input vector is described in Fig.Â 1a. Each call 
of gen_anglesÂ will perform log2(N) recursive calls and the cost of each call for k = 1, . . . , log2(N) is N/2kâˆ’1â€Š. 
The costs of the recursive calls to generate the angles-vector is 1 + 2 + 22 + Â· Â· Â· + 2log2 N = O(N).
Function gen_circuitÂ (AlgorithmÂ 1, LineÂ 18) receives the N âˆ’1 dimensional vector angles, generated by 
the function gen_anglesÂ with input x, and outputs a quantum circuit to load the vector x in the amplitudes 
of a quantum state. The state in level j of the tree-state in Fig.Â 1b can be constructed from the state in the level 
j âˆ’1 of the states-tree and controlled rotations from the level j âˆ’1 in angles-tree. The root of the angles-tree 
defines the first rotation and the algorithm follows a top-down approach where the rotation of angle angle[k] is 
controlled by the qubits in range [0,Â level(k)) and is applied if the qubits q[0], . . . , q[level(k) âˆ’1] are in the state 
|k âˆ’(2level(k) âˆ’1)â€Š. With Î±k = angle[k]â€Š, the circuit to load an eight-dimensional input vector is described in 
Fig.Â 2. The computational cost to compute the angles and to generate the circuit is O(N). The quantum circuit 
uses O(N) multi-controlled gates that are applied sequentially and the circuit depth is O(N). We have a O(N) cost 
in the classical host machine and a O(N) cost in the quantum device and spatial cost O(log2(N))â€Š. An amortized 
computational cost is O(N) if we need to load the vector several times.
Divideâ€‘andâ€‘conquer loading data
The construction of the quantum state in the previous section starts in the root of state-tree |0n and build the 
states in each level of the state-tree in a top-down strategy until to build the state described by the last level of 
the state-tree. In this Section, we propose a divide-and-conquer load strategy, and the desired quantum state is 
built following a bottom-up strategy. First, we divide the input into bidimensional subvectors and load qubits 
corresponding to the normalized bidimensional subvectors. In the next steps, we generate the subvectors of the 
previous levels.
For instance, to load the state in the leafs of the state-tree in Fig.Â 1b, we load four one-qubit states
representing the leafs of the state-tree. To load the two two-qubit states in the previous level, the single-qubit 
states are weighted with the value of their fathers, obtaining the state |Ïˆl representing the state in the half left 
part of the state-tree in Eq.Â (3) and the state |Ïˆr representing the state in the right part of the state-tree in Eq.Â (4).
Combining states |Ïˆl and |Ïˆr weighted with the values of the state in the previous layer generates the desired 
quantum state described in Eq.Â (5).
To load the classical data using this bottom-up approach we need to combine two m-qubits states |Ïˆ, |Ï† 
and one one-qubit state a|0 + b|1 as a|0|Ïˆ + b|1|Ï† with a circuit that does not depend on the input states. 
Using the circuit in Fig.Â 3 with m âˆ’1 controlled-swap (CSWAP) operations, we generate the desired output in 
(
âˆš
0.03,
âˆš
0.07,
âˆš
0.15,
âˆš
0.05,
âˆš
0.1,
âˆš
0.3,
âˆš
0.2,
âˆš
0.1)
âˆš
0.03
âˆš
0.1
|0 +
âˆš
0.07
âˆš
0.1
|1,
âˆš
0.15
âˆš
0.2
|0 +
âˆš
0.05
âˆš
0.2
|1,
âˆš
0.1
âˆš
0.4
|0 +
âˆš
0.3
âˆš
0.4
|1 and
âˆš
0.2
âˆš
0.3
|0 +
âˆš
0.1
âˆš
0.3
|1
(3)
|Ïˆl =
âˆš
0.1
âˆš
0.3
|0
âˆš
0.03
âˆš
0.1
|0 +
âˆš
0.07
âˆš
0.1
|1

+
âˆš
0.2
âˆš
0.3
|1
âˆš
0.15
âˆš
0.2
|0 +
âˆš
0.05
âˆš
0.2
|1

=
âˆš
0.03
âˆš
0.3
|00 +
âˆš
0.07
âˆš
0.3
|01 +
âˆš
0.15
âˆš
0.3
|10 +
âˆš
0.05
âˆš
0.3
|11
(4)
|Ïˆr =
âˆš
0.4
âˆš
0.7
|0
âˆš
0.1
âˆš
0.4
|0 +
âˆš
0.3
âˆš
0.4
|1

+
âˆš
0.3
âˆš
0.7
|1
âˆš
0.2
âˆš
0.3
|0 +
âˆš
0.1
âˆš
0.3
|1

=
âˆš
0.1
âˆš
0.7
|00 +
âˆš
0.3
âˆš
0.7
|01 +
âˆš
0.2
âˆš
0.7
|10 +
âˆš
0.1
âˆš
0.7
|11
(5)
âˆš
0.3|Ïˆl +
âˆš
0.7|Ïˆr =
âˆš
0.03|000 +
âˆš
0.07|001 +
âˆš
0.15|010 +
âˆš
0.05|011
+
âˆš
0.1|100 +
âˆš
0.3|101 +
âˆš
0.2|110 +
âˆš
0.1|111
71

4
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
the first m qubits, but with unit entangled information in the m âˆ’1 ancillary qubits. Namely, for the example 
with Fig.Â 3, the conventional amplitude encoding in the form of Eq.Â (1) would aim to prepare an m-qubit state 
a|0|Ïˆ + b|1|Ï† while our method prepares a|0|Ïˆ|Ï† + b|1|Ï†|Ïˆ.
Loading complex data.â€ƒ
The divide-and-conquer strategy can be generalized to load a complex vector 
(|x0|eiÏ‰0, |x1|eiÏ‰1, . . . , |xNâˆ’1|eiÏ‰Nâˆ’1) into the probability amplitudes of a quantum state as
To explain the process, we introduce two parameters used in Ref.18
where v = 1, 2, . . . , n is the level of the tree in reverse order (i.e. 1 for the leaf nodes and n for the root node) and 
j = 1, 2, . . . , 2nâˆ’v is the qubit index in the layer v. Next, one needs N/2 one-qubit states corresponding to the 
leaf nodes of the state-tree (see Fig.Â 1b for example) to be prepared as
To load the states in the previous levels (represented by v on the expression below), the states of the current 
level (â€Šv âˆ’1â€Š, since v is in reverse order) are weighted with the values of their parents, obtaining the state
After recursively updating the state |Ïˆj,v for v = 2, . . . , n and j = 1, 2, . . . .2nâˆ’vâ€Š, the desired quantum state 
is generated as
Combining two states at children nodes in the state-tree as shown in Eq.Â (8) is done with controlled-swap 
operations as explained in the previous section, and we will need N qubits with entangled auxiliary qubits to 
generate the state in Eq.Â (6). Thus the only modification in the quantum circuit is the introduction of the Rz(j,v) 
rotations to set the phases, following the Ry rotations. The pseudocode for generating the angles for the Rz rota-
tions is given in AlgorithmÂ 2. 
(6)
|x0|eiÏ‰0|0|Ïˆ0 + Â· Â· Â· + |xNâˆ’1|eiÏ‰Nâˆ’1|N âˆ’1|ÏˆNâˆ’1.
j,v =
2vâˆ’1

l=1
(Ï‰(2jâˆ’1)2vâˆ’1+l âˆ’Ï‰(2jâˆ’2)2vâˆ’1+l)/2vâˆ’1 and Î²j,v =




2vâˆ’1

l=1
|a(2jâˆ’1)2vâˆ’1+l|2/




2v

l=1
|a(jâˆ’1)2v+l|2,
(7)
|Ïˆj,1 = eâˆ’i
j,1
2

1 âˆ’|Î²j,1|2|0 + ei
j,1
2 Î²j,1|1.
(8)
|Ïˆj,v = eâˆ’i
j,v
2

1 âˆ’|Î²j,v|2|0|Ïˆ2jâˆ’1,vâˆ’1 + ei
j,v
2 Î²j,v|1|Ïˆ2j,vâˆ’1.
(9)
|Ïˆ1,n = |x0|eiÏ‰0|0 + |x1|eiÏ‰1|1 + Â· Â· Â· + |xNâˆ’1|eiÏ‰Nâˆ’1|N âˆ’1.
FigureÂ 1.â€‚ â€‰Data representation of information in function generate angles.
FigureÂ 2.â€‚ â€‰Circuit to load an 8 dimensional real vector in a quantum device.
72

5
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
AlgorithmÂ 3 presents the complete pseudocode for the divide-and-conquer state preparation algorithm. 
The for loop in lineÂ 2 initializes the qubit q[k] with the value Ry(Î±k)â€Š. After this step, the qubits with index 
k > âŒŠ(N âˆ’1)/2âŒ‹ (in the leaf of the angle tree) are normalized versions of the states in the leafs of the state-tree. 
The next subroutine with Rz rotations (Line 4 to Line 5) is used to encode phase information. Line 6 calculates 
the index of the first angle that has a right children in the angle-tree data structure. The while loop starting at 
line 7 combines the states generated in the subtree rooted in the angle Î±actualâ€Š. To combine the states, we first 
apply a cswap(q[actual], q[left_child], q[right_child]), and then we update the values of left and right child with 
the value of their left child and apply another cswap(q[actual], q[left_child], q[right_child]) while the left_child 
and right_child have valid values. With the input described by the angle-tree in Fig.Â 1a, AlgorithmÂ 3 generates 
the circuit described in Fig.Â 4.
FigureÂ 3.â€‚ â€‰Combining states with controlled-swap operations.
73

6
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
The process to load each state in the same layer of the state tree can be performed in parallel, because the 
control swap gates use different qubits. The controls are qubits in one layer of the angle-tree and targets are 
qubits in their subtrees. Layer with height k contributes to the depth of the circuit with the tree height minus 
height of the layer. The circuit will have a depth of O(1 + 2 + Â· Â· Â· + log2(N) âˆ’1) with an overall depth in order 
O(log2
2(N))â€Š. This result is stated in TheoremÂ 1.
TheoremÂ 1â€‚ AlgorithmÂ 3 generates a quantum circuit with depth O(log2
2(N)).
Orthonormal ancillary.â€ƒ
The ancillary states |Ïˆ0, . . . , |ÏˆNâˆ’1 in Eq.Â (2) are not necessarily orthogonal to 
each other, but we can modify the divide-and-conquer state preparation adding label qubits to ensure orthonor-
mality of the ancillary states with the addition of label quantum register with log2(N) qubits. The label register 
is prepared in |0âŠ—log2(N)â€Š, and log2(N) controlled-NOT (CNOT) gates are applied to the label qubits, each con-
trolled by a data qubit. With this modification, the final state becomes
where {| ËœÏˆk}Nâˆ’1
k=0 = {|Ïˆk|k}Nâˆ’1
k=0  is a set of orthonormal states.
Experiments.â€ƒ
To evaluate the proposed method we perform two sets of experiments. In the first set of 
experiments, we use a quantum computing simulator and a NISQ computer to show as a proof of concept that 
the proposed method can be applied in near future. In the second set of experiments, we compare the depth of 
the circuits generated by the proposed method and other state preparation Â­algorithms10,11 with a random input.
Proof of concept with a NISQ device.â€ƒ In this experiment we load a four-dimensional data into a two qubit state 
|Ïˆ =
âˆš
0.6|00 +
âˆš
0.2|01 +
âˆš
0.1|10 +
âˆš
0.1|11 in a NISQ device as a proof of concept. For this experimen-
tal validation, we chose dimension of data to be small to be compatible with currently available quantum devices, 
although the time advantage of the proposed method will manifest when a large number of qubits are required 
for loading high-dimensional data. We use qubits 1, 2 and 3 of the ibmq_rome device. The CNOT error rates 
were 8.832e-3 (qubits 1 and 2) and 8.911e-3 (qubits 2 and 3). The single-qubit error was in the order of 1e-4.
FigureÂ 5a presents the output of the experiment with 1024 executions using a quantum device simulator and 
the Rome quantum device. The Rome NISQ device has an output very close to the expected result. The circuit 
used to obtain this result is described in Fig.Â 5b, where c is a classical register. We remove the last CNOT of the 
controlled operation because the qubit 2 will be discarded. The resulting circuit has 10 CNOT operators because 
a quantum swap was necessary to run this circuit in the real quantum device with a limited qubit connectivity. 
The circuit used in the quantum device is described in Fig.Â 7.
(10)
x0|0|Ïˆ0|0 + Â· Â· Â· + xNâˆ’1|N âˆ’1|ÏˆNâˆ’1|N âˆ’1 =
Nâˆ’1

k=0
xk|k| ËœÏˆk,
FigureÂ 4.â€‚ â€‰Rotated angle-tree and a circuit generated by the divide-and-conquer strategy described in 
AlgorithmÂ 3. The quantum bit q[k] in the circuit is aligned with the angle Î±[k] in the angle-tree, this 
organization allows to draw the quantum gates in each layer in parallel. In this example, the desired state is 
stored in qubits q[0], q[1] and q[3] to generate the quantum state with entangles ancilla as in Eq.Â (2).
74

7
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Circuit depth.â€ƒ The main difference between the divide-and-conquer state preparation and previous approaches 
is an exchange between circuit depth by circuit width. TableÂ 1 presents the depth of the circuits generated using 
the proposed strategy, implementation of a version Â­of11 available Â­at19 and a non optimized version of the algo-
rithm described Â­in10. The proposed strategy Â­and10 implementation are publicly available. The implementation of 
the proposed method shows its theoretical asymptotic time advantage to load a vector when the dimension is 
larger than 32. The proposed method has two main disadvantages: the linear number of qubits in relation to the 
logarithmic number in other methods, and the information entangled in the ancillary qubits.
The higher depth of circuits using the divide-and-conquer strategy with small vectors occurs because of the 
use of three-qubits gates to combine the vectors. In other works, it is only necessary to use O(n) qubits to load 
a 2n-dimensional vector while requiring sequential applications of O(2n) n-controlled gates. To improve the 
performance of the divide-and-conquer loading strategy and to reduce the number of qubits one can combine 
Â­algorithm11 with the divide-and-conquer strategy. Instead of divide the vector in parts with size 2, we can divide 
the vector in parts with size k (equal to a power of 2), load the normalized k-dimensional vectors using a sequen-
tial algorithm and combine the small vectors with the divide-and-conquer approach.
Example applications.â€ƒ
Hierarchical quantum classifier.â€ƒ This section compares the divide-and-conquer 
algorithm with two other approaches in which input data encoding in a quantum state can be achieved to initial-
ize a quantum circuit, namely qubit encoding and amplitude encoding. In the former, data is encoded in the am-
plitudes of individual qubits in a fully separable state, performed using single-qubit Â­rotations20. In the later, data 
is encoded in the amplitudes of an entangled Â­state11,18, similarly to the divide-and-conquer. We use the accuracy 
of a quantum variational classifier as a metric to evaluate the state preparations. The divide-and-conquer algo-
rithm is expected to produce results similar to the amplitude encoding. The results of the classifier using qubit 
encoding are also presented for completeness, albeit our main objective is to compare the divide-and-conquer 
and amplitude encoding schemes.
The classifier is based on a tree-like circuit known as tree tensor network (TTN)20. This choice is based on 
the fact that tensor networks can represent both neural networks and quantum circuits, acting as a link between 
these Â­fields21,22. Initially, it applies a set of two-qubit unitaries to each pair of qubits from the initial state, dis-
carding one output from each unitary, leaving half the number of qubits left for the next layer. The process is 
repeated until only one qubit remains. Multiple measurements are carried on this last qubit to approximate the 
expectation value.
Following Grant etÂ al.20, we built the circuits using single-qubit rotations around the y-axis of the Bloch 
sphere, denoted by Ry(Î¸)â€Š, and CNOT gates, composing two-qubit unitary blocks CNOT Â· (Ry(Î¸0) âŠ—Ry(Î¸1))â€Š. The 
single-qubit rotation angle Î¸ is subject to training by some optimization procedure. Examples of the resulting 
circuits are represented in Fig.Â 6aâ€“c.
We follow the general classical-quantum hybrid approach in which the optimization procedure is processed 
on a classical computer to determine a set of parameters, i.e. rotation angles for the Ry(Î¸) operation, for the para-
metrized quantum circuit. The quantum device prepares a quantum state as prescribed by the circuit pipeline and 
performs measurements. The measurement outcomes are processed by a classical device to generate a forecast, 
using it to update the model parameters via a learning algorithm. This whole process is repeated towards the goal.
Four datasets were used in this work: Iris, Habermanâ€™s Survival, Banknote Â­Authentication23, and Pima Indians 
Â­Diabetes24. Three binary datasets were extracted from the original Iris dataset (paired combinations of the original 
three classes). Mean test accuracy and one standard deviation are computed on ten random initializations for 
each dataset and encoding. The simulation results are presented in TableÂ 2, where the test accuracy of the qubit 
and amplitude encodings are compared against the results obtained using the divide-and-conquer encoding.
The results show similar classification accuracy for all encodings, favoring qubit encoding due to the greater 
number of circuit parameters for the optimization. The main advantage of divide-and-conquer encoding over 
qubit encoding is the representation of encoded data in a quantum state of a reduced number of qubits, log2(N)â€Š, 
compared to the initial state N âˆ’1â€Š. This also results in a lower depth classifier. Moreover, when the data is given 
by qubit encoding, TTN circuits can be evaluated efficiently using classical Â­techniques20. This is not true when 
the input data is amplitude encoded. The advantage over amplitude encoding is a lower depth encoding circuit 
for N â‰¥64 (TableÂ 1).
To verify that the above comparison of the models is appropriate, a nonparametric statistical test was 
employed. We used the Wilcoxon paired signed-rank Â­test25 with Î± = 0.05 to check whether there exist significant 
differences between the classification performances of compared encoders over the chosen datasets. As expected, 
we verified that amplitude encoding and divide-and-conquer encoding are statistically equivalent for all datasets.
Swap test.â€ƒ Some metric between two data set encoded as 
i xi|i = 
i |Ëœxi and 
j yj|j = 
j |Ëœyj can be 
calculated with the state prepared by the divide-and-conquer state preparation and the swap test. The required 
state is
where 
i |Ëœxi|Ïˆi and 
j |Ëœyi|Ï†j are prepared by the encoding scheme explained in Sec. 3.2 so as to make the 
ancillary states orthonormal.
After applying the swap test circuit to the above state, i.e. the Hadamard on the first (ancilla) qubit, the swap 
operation between the test register and the data register controlled by the ancilla qubit, and the Hamadard on 
the first qubit, one obtains
(11)
|0

ij
|Ëœxi|Ëœyj|Ïˆi|Ï†j,
75

8
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Now, when the Ïƒz measurement is performed on the ancilla qubit, the probability to measure z = Â±1â€Š, i.e. 
z = +1 if the ancilla qubit is |0 and z = âˆ’1 if the ancilla qubit is |1â€Š, is
Therefore, measuring the expectation value of Ïƒz on the ancilla qubit yields
Several measures in statistics can be derived from the above result. First, by setting |xi|2 to be the possible 
values of a discrete random variable X :  â†’R with the probability Pr(X = |xi|2) = |yi|2â€Š, the above equation 
becomes an expectation value of the random variable X. The above equation can be also viewed as the second 
moment of a discrete random variable X, i.e. E(X2)â€Š, with the probability Pr(X = xi) = |yi|2â€Š. This can be used 
to calculate the variance of X given E(X)2â€Š. Alternatively, the above equation can be viewed as E(XY) of two uni-
formly-distributed discrete random variables X and Y that satisfy Pr(X = |xi|2) = Pr(Y = |yi|2) = 1/Nâ€Š. This can 
be used with E(X) = N
i |xi|2/N = E(Y) N
i |yi|2/N = 1/N to calculate the covariance, E(XY) âˆ’E(X)E(Y).
The idea above can be extended for calculating the covariance of two discrete random variables X and 
Y with any known probability distribution. Let possible outcomes of X and Y be (|x0|2, . . . , |xNâˆ’1|2) and 
(12)
1
2
ï£«
ï£­|0

ij

|Ëœxi|Ëœyj + |Ëœyj|Ëœxi

|Ïˆi|Ï†j + |1

ij

|Ëœxi|Ëœyj âˆ’|Ëœyj|Ëœxi

|Ïˆi|Ï†j
ï£¶
ï£¸.
(13)
Pr(z = Â±1) = 1
4

ijkl
2

Ëœxk|ËœxiËœyl|Ëœyj Â± Ëœyl|ËœxiËœxk|Ëœyj

Ïˆk|ÏˆiÏ†l|Ï†j
= 1
2
ï£«
ï£­
ij
Ëœxi|ËœxiËœyj|Ëœyj Â± |Ëœyj|Ëœxi|2
ï£¶
ï£¸
=
1 Â± 
ij |Ëœyj|Ëœxi|2
2
.
(14)

ij
|Ëœyj|Ëœxi|2 =

i
|xiyi|2.
FigureÂ 5.â€‚ â€‰Proof of concept experiment with a IBM quantum device (ibmq_rome) on the cloud platform.
Tableâ€¯1.â€‚ â€‰A comparison between Refs.10,11 and divide-and-conquer strategy to load a n-dimensional real vector 
into a quantum computer.
n
dc depth
dc width
11 depth
11 width
10 depth
10 width
4
12
4
3
3
5
3
8
31
8
17
4
53
4
16
58
16
47
5
277
5
32
93
32
105
6
1237
6
64
136
64
239
7
5205
7
128
187
128
493
8
21333
8
256
246
256
982
9
9
512
313
512
2025
10
10
1024
388
1024
4009
11
11
76

9
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
(|y0|2, . . . , |yNâˆ’1|2)â€Š, respectively, and the probability distribution be (px
0, . . . , px
Nâˆ’1) and (py
0, . . . , py
Nâˆ’1)â€Š, respec-
tively. Then the divide-and-conquer algorithm can be used to prepare a state
where |Ëœpx
i  =

px
i |iâ€Š, |Ëœpy
k =

py
k|kâ€Š, |Ëœxj = xj|jâ€Š, |Ëœyl = yl|lâ€Š, and |Ïˆijkl is the orthonormal ancillary state as 
before. Now, the swap test circuit is applied with a small modification such that 3n controlled-swap gates are 
applied to transform |Ëœpx
i |Ëœxj|Ëœpy
k|Ëœyl to |Ëœxj|Ëœpy
k|Ëœyl|Ëœpx
i  when the ancilla qubit for the swap test is |1â€Š. Measuring 
the expectation value of the Ïƒz observable on the ancilla qubit yields
E(X) and E(Y) can be calculated from the swap test algorithm presented in the beginning of this section, which 
provided Eq.Â (14), by choosing the input vectors appropriately.
The total time complexity for the aforementioned quantum algorithms is still Oq(log2
2(N))â€Š, since the swap 
test only requires additional O(log2(N)) controlled-swap gates. The quantum speedup can be manifested when 
constructing a covariance matrix for two multivariate random variables X and Yâ€Š, each containing m discrete 
random variables of size N. Since there are m2 entries in the matrix, the classical time cost is Oc(Nm2)â€Š, while the 
quantum approach requires Oc(N) + Oq(log2
2(N)m2).
Discussion
One of the major open problems for practical applications of quantum computing is to develop an efficient means 
to encode classical data in a quantum Â­state3. Most quantum algorithms do not present advantages in loading 
Â­data2. The method proposed in this work fills this gap by proposing a new quantum state preparation paradigm, 
which can complement or enhance the known methods, such as qubit encoding and amplitude encoding. Our 
approach was based on the MÃ¶ttÃ¶nen etÂ al. Â­algorithm10 and a divide-and-conquer approach using controlled 
swap gates and ancilla qubits. With this modification, we obtain an exponential quantum speedup in time to load 
a N-dimensional real vector in the amplitude of a quantum state with a quantum circuit of depth O(log2
2(N)) 
(15)
|0

ijkl
|Ëœpx
i |Ëœxj|Ëœpy
k|Ëœyl|Ïˆijkl,
(16)

ijkl
Ëœpx
i |ËœxjËœxj|Ëœpy
kËœpy
k|ËœylËœyl|Ëœpx
i  =

i
px
i py
i |xi|2|yi|2 = E(XY).
FigureÂ 6.â€‚ â€‰TTN classifier with (a) divide-and conquer encoding, (c) amplitude encoding and (b) qubit 
encoding.
77

10
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
and space O(N). The exponential speedup to load data in quantum devices has a potential impact on speeding 
up the solution of problems in quantum machine learning and other quantum algorithms that need to load data 
from classical devices.
The speedup is achieved at the cost of using ancilla qubits that are entangled to the data register qubits. How-
ever, we showed that some interesting problems such as quantum supervised machine learning and statistical 
analysis can be performed with the input quantum state given by our method. The tradeoff between time and 
space complexities that our method provides is favorable when increasing the circuit width is easier than increas-
ing the circuit depth, which is a likely scenario to occur during the development of near-term quantum devices.
We demonstrated the proof-of-principle using the IBM quantum cloud platform to verify the validity and 
the feasibility of our method. Furthermore, the numerical experiments showed that the new encoding method 
offers advantages, reducing complexity and computational resources when applied in conjunction with existing 
algorithms. Our perspective is that these advantages will extend to other cases.
This work leaves some open questions. What are other problems that can be solved with a divide-and-conquer 
quantum strategy? What are the implications to efficiently load a quantum vector with entangled information 
in the ancillary qubits for machine learning? And how to combine sequential with parallel strategies to create a 
robust algorithm with respect to input size? Also, finding an efficient means to uncompute the ancillary informa-
tion remains as an interesting future work that will broaden the applicability of our method.
Methods
We performed the proof of concept experiment with a publicly available IBM quantum device consisting of 
five superconducting qubits, named as ibmq_rome. The quantum circuit used in this experiment is depicted in 
Fig.Â 5b. The circuit in Fig.Â 5b is compiled to the physical qubit layout of ibmq_rome and the resulting circuit is 
depicted in Fig.Â 7 that is executed 1024 times to obtain the data used to generate Fig.Â 5a. We used the quantum 
information science kit (qiskit). Python implementation of gen_anglesÂ and AlgorithmÂ 3 are used to generate 
the quantum circuit in Figs.Â 4 and 5b.
The depth of the quantum circuits for state preparations described in TableÂ 1 is obtained using a python 
implementation of AlgorithmÂ 3, the qiskit implementation Â­of11 and a non-optimized version of the Â­algorithm10 
available at the GitHub repository. For each input size we generated a random vector used for all methods. In 
these first two set of experiments we used qiskit version 0.14.1 and python version 3.7.7.
In â€œHierarchical quantum classifierâ€ section, simulations of the hybrid classification algorithms were per-
formed using Xanaduâ€™s Â­Pennylane26 default qubit plugin state simulator. We used 2/10 of the datasets as a test set, 
2/10 as a validation set, and the remaining as a training set. As preparation for qubit encoding, each data vector 
element of all datasets was re-scaled within the range of [0, Ï€]â€Š. Also, for amplitude encoding and divide-and-
conquer encoding, the data vectors were normalized. Our simulation employs the Adaptative Moment Estimation 
(Adam) for the optimization Â­process27 with a learning rate of 0.1 and a batch size of 1/10 of the training set size. 
Training stops when validation set accuracy does not increase for 30 consecutive tests or 200 iterations is reached.
Tableâ€¯2.â€‚ â€‰Mean test accuracy and one standard deviation for TTN classifiers with ten different random 
parameter initializations. Three binary datasets were extracted from the original Iris dataset.
Dataset
Classes
Encoding
Qubit
Amplitude
Divide-and-conquer
Haberman
0 or 1
60.33 Â± 2.02
59.02 Â± 0.00
59.02 Â± 0.00
Banknote
0 or 1
91.28 Â± 3.11
87.15 Â± 0.74
87.45 Â± 1.12
Pima
0 or 1
77.19 Â± 2.08
70.78 Â± 1.88
71.11 Â± 1.79
Iris
0 or 1
100 Â± 0.00
100 Â± 0.00
100 Â± 0.00
0 or 2
100 Â± 0.00
100 Â± 0.00
100 Â± 0.00
1 or 2
98.50 Â± 2.42
93.00 Â± 2.58
93.00 Â± 2.58
FigureÂ 7.â€‚ â€‰The transpiled circuit of the divide-and-conquer state preparation circuit in Fig.Â 5b in accordance 
with the physical qubit layout of the ibmq_rome device. The gates U1â€Š, U2â€Š, and U3 are physical single-qubit 
gates of IBM Quantum Experience that take in one, two, and three parameters, respectively. The measurement 
outcomes are stored in classical registers denoted by c[0] and c[1].
78

11
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Data availibility
The site https://â€‹www.â€‹cin.â€‹ufpe.â€‹br/â€‹~ajsilâ€‹va/â€‹dcsp/ contains all the data and software generated during the current 
study.
Received: 24 September 2020; Accepted: 2 March 2021
References
	 1.	 Arute, F. et al. Quantum supremacy using a programmable superconducting processor. Nature 574, 505â€“510 (2019).
	 2.	 Biamonte, J. et al. Quantum machine learning. Nature 549, 195â€“202 (2017).
	 3.	 Aaronson, S. Read the fine print. Nat. Phys. 11, 291â€“293. https://â€‹doi.â€‹org/â€‹10.â€‹1038/â€‹nphysâ€‹3272 (2015).
	 4.	 LeCun, Y., Bengio, Y. & Hinton, G. Deep learning. Nature 521, 436â€“444 (2015).
	 5.	 Dong, Y. et al. Stochastic quantization for learning accurate low-bit deep neural networks. Int. J. Comput. Vis. 127, 1629â€“1642 
(2019).
	 6.	 Yang, C.-C. & Cong, G. Accelerating data loading in deep neural network training. In 2019 IEEE 26th International Conference on 
High Performance Computing, Data, and Analytics (HiPC), 235â€“245 (IEEE, 2019).
	 7.	 Wootters, W. K. & Zurek, W. H. A single quantum cannot be cloned. Nature 299, 802â€“803 (1982).
	 8.	 Preskill, J. Quantum computing in the nisq era and beyond. Quantum 2, 79 (2018).
	 9.	 Hughes, R. J., James, D. F., Knill, E. H., Laflamme, R. & Petschek, A. G. Decoherence bounds on quantum computation with trapped 
ions. Phys. Rev. Lett. 77, 3240 (1996).
	10.	 MÃ¶ttÃ¶nen, M., Vartiainen, J. J., Bergholm, V. & Salomaa, M. M. Transformation of quantum states using uniformly controlled 
rotations. Quant. Inf. Comput. 5, 467â€“473 (2005).
	11.	 Shende, V. V., Bullock, S. S. & Markov, I. L. Synthesis of quantum-logic circuits. IEEE Trans. Comput.-Aided Design Integr. Circuits 
Syst. 25, 1000â€“1010 (2006).
	12.	 Iten, R., Colbeck, R., Kukuljan, I., Home, J. & Christandl, M. Quantum circuits for isometries. Phys. Rev. A 93, 032318 (2016).
	13.	 Park, D. K., Petruccione, F. & Rhee, J.-K.K. Circuit-based quantum random access memory for classical data. Sci. Rep. 9, 1â€“8 (2019).
	14.	 Park, D. K., Sinayskiy, I., Fingerhuth, M., Petruccione, F. & Rhee, J.-K.K. Parallel quantum trajectories via forking for sampling 
without redundancy. New J. Phys. 21, 083024. https://â€‹doi.â€‹org/â€‹10.â€‹1088/â€‹1367-â€‹2630/â€‹ab35fb (2019).
	15.	 Cormen, T.Â H., Leiserson, C.Â E., Rivest, R.Â L. & Stein, C. Introduction to algorithms (MIT press, 2009).
	16.	 Hoare, C. A. R. AlgorithmÂ 64: quicksort. Commun. ACM 4, 321 (1961).
	17.	 Gentleman, W.Â M. & Sande, G. Fast fourier transforms: for fun and profit. In Proceedings of the November 7-10, 1966, fall joint 
computer conference, 563â€“578 (1966).
	18.	 Mottonen, M., Vartiainen, J. J., Bergholm, V. & Salomaa, M. M. Transformation of quantum states using uniformly controlled 
rotations. Quant. Inf. Comput. 5, 467â€“473 (2005).
	19.	 Aleksandrowicz, G.Â A. etÂ al. Qiskit: An Open-source Framework for Quantum Computing, https://â€‹doi.â€‹org/â€‹10.â€‹5281/â€‹zenodo.â€‹25621â€‹
11 (2019).
	20.	 Grant, E. etÂ al. Hierarchical quantum classifiers. npj Quant. Inf.4, 65. https://â€‹doi.â€‹org/â€‹10.â€‹1038/â€‹s41534-â€‹018-â€‹0116-9 (2018).
	21.	 Cohen, N. & Shashua, A. Convolutional rectifier networks as generalized tensor decompositions. Int. Conf. Mach. Learn. 955â€“963, 
(2016).
	22.	 Levine, Y., Sharir, O., Cohen, N. & Shashua, A. Quantum entanglement in deep learning architectures. Phys. Rev. Lett. 122, 065301. 
https://â€‹doi.â€‹org/â€‹10.â€‹1103/â€‹PhysRâ€‹evLett.â€‹122.â€‹065301 (2019).
	23.	 Dua, D. & Graff, C. UCI machine learning repository (2017).
	24.	 Rossi, R.Â A. & Ahmed, N.Â K. The network data repository with interactive graph analytics and visualization. In Proceedings of the 
Twenty-Ninth AAAI Conference on Artificial Intelligence, AAAIâ€™15, 4292â€“4293 (AAAI Press, 2015).
	25.	 DemÅ¡ar, J. Statistical comparisons of classifiers over multiple data sets. J. Mach. Learn. Res. 7, 1â€“30 (2006).
	26.	 Bergholm, V. etÂ al. Pennylane: Automatic differentiation of hybrid quantum-classical computations (2020). 1811.04968.
	27.	 Kingma, D. P. & Ba, J, (A method for stochastic optimization, Adam, 2017) ((1412.6980)).
Acknowledgements
This research is supported by CNPq (Grant No. 308730/2018-6), CAPES- Finance Code 001 and FACEPE (Grant 
No. IBPG 0834-1.03/19), the National Research Foundation of Korea (Grant Nos. 2019R1I1A1A01050161 and 
2018K1A3A1A09078001), the Ministry of Science and ICT, Korea, under an ITRC Program, IITP-2019-2018-
0-01402, and the South African Research Chair Initiative of the Department of Science and Innovation and 
National Research Foundation (UID: 64812). We acknowledge use of IBM Q for this work. The views expressed 
are those of the authors and do not reflect the official policy or position of IBM or the IBM Q team.
Author contributions
A.J.S. devised the divide-and-conquer state preparation strategy, performed the proof-of-concept experiments 
and wrote a first version of the manuscript. D.K.P. suggested the way to make ancillary states orthogonal, and 
conceived the combination of swap test with the divide-and-conquer state preparation to calculate metrics 
between two datasets. I.F.A. performed the experiments with the variational quantum circuits and extended the 
algorithm to complex input vectors. All authors reviewed and discussed the analyses and results, and contributed 
towards writing the manuscript.
Competing interestsâ€‚
The authors declare no competing interests.
Additional information
Correspondence and requests for materials should be addressed to F.P.
Reprints and permissions information is available at www.nature.com/reprints.
Publisherâ€™s noteâ€‚ Springer Nature remains neutral with regard to jurisdictional claims in published maps and 
institutional affiliations.
79

12
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Open Accessâ€‚ This article is licensed under a Creative Commons Attribution 4.0 International 
License, which permits use, sharing, adaptation, distribution and reproduction in any medium or 
format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the 
Creative Commons licence, and indicate if changes were made. The images or other third party material in this 
article are included in the articleâ€™s Creative Commons licence, unless indicated otherwise in a credit line to the 
material. If material is not included in the articleâ€™s Creative Commons licence and your intended use is not 
permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from 
the copyright holder. To view a copy of this licence, visit http://â€‹creatâ€‹ivecoâ€‹mmons.â€‹org/â€‹licenâ€‹ses/â€‹by/4.â€‹0/.
Â© The Author(s) 2021
80

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum
state preparation
Israel F. Araujo1*, Daniel K. Park2,3, Teresa B.
Ludermir1, Wilson R. Oliveira4, Francesco Petruccione5,6,7
and Adenilton J. da Silva1
1*Centro de InformÂ´atica, Universidade Federal de Pernambuco,
Recife, 50740-560, Pernambuco, Brazil.
2Department of Applied Statistics, Yonsei University, Seoul,
03722, Republic of Korea.
3Department of Statistics and Data Science, Yonsei University,
Seoul, 03722, Republic of Korea.
4Departamento de EstatÂ´Ä±stica e InformÂ´atica, Universidade
Federal Rural de Pernambuco, Recife, Pernambuco, Brazil.
5School of Data Science and Computational Thinking,
Stellenbosch University, Stellenbosch, 7600, South Africa.
6National Institute for Theoretical and Computational Sciences
(NITheCS), 4001, South Africa.
7Quantum Research Group, University of KwaZulu-Natal,
Durban, 4001, South Africa.
*Corresponding author(s). E-mail(s): ifa@cin.ufpe.br;
Abstract
The theory of quantum algorithms promises unprecedented benefits of
harnessing the laws of quantum mechanics for solving certain com-
putational problems. A prerequisite for applying quantum algorithms
to a wide range of real-world problems is loading classical data to
a quantum state. Several circuit-based methods have been proposed
for encoding classical data as probability amplitudes of a quantum
state. However, in these methods, either quantum circuit depth or
width must grow linearly with the data size, nullifying the advan-
tage of representing exponentially-many classical data in a quantum
1
81
APÃŠNDICE B â€“ CONFIGURABLE SUBLINEAR CIRCUITS FOR QUANTUM
STATE PREPARATION

Springer Nature 2021 LATEX template
2
Configurable sublinear circuits for quantum state preparation
state. In this paper, we present a configurable bidirectional proce-
dure that addresses this problem by tailoring the resource trade-off
between quantum circuit width and depth. In particular, we show a
configuration that encodes an N-dimensional classical data using a quan-
tum circuit whose width and depth both grow sublinearly with N.
We demonstrate proof-of-principle implementations on five quantum
computers accessed through the IBM and IonQ quantum cloud services.
Keywords: quantum computing, state preparation, bidirectional, circuit
optimization
1 Introduction
In 1981, Richard Feynman suggested a computational architecture based on
cellular automata with quantum features and conjectured that it could accel-
erate simulations of quantum physics and chemistry beyond the capability
of classical computers [1]. Since then, algorithms such as Deutsch-Jozsa [2],
Grover [3], Simon [4], and Shor [5] demonstrated quantum advantages. How-
ever, some challenges prevent such advantages from applying to all quantum
algorithms [6â€“8]. Among these challenges is the development of an efficient
encoding of classical data into a quantum state [6â€“9].
Quantum algorithms assume an initial quantum state prepared before the
computation. The worst case complexity of preparing an arbitrary quantum
state is exponential with the number of qubits [10]. For this reason, the most
significant quantum speed-ups occur when the quantum algorithm [2â€“5, 11,
12] operates on an input state that is easy to prepare, such as the uniform
superposition of all computational basis states. For algorithms that rely on
loading data into an arbitrary quantum state, an efficient means to prepare
input states is a prerequisite to quantum speed-ups [6, 7, 9, 13].
While the quantum state preparation models based on quantum ora-
cles [14â€“16] or quantum random access memory [17â€“24] are useful for
evaluating the lower bounds of the computational cost and identifying the
complexity class, implementations of them must be considered in practice. In
particular, the quantum speed-up can vanish without an efficient implemen-
tation of quantum state preparation when quantum algorithms carry classical
data in a non-uniform quantum superposition. Examples of such instances
include Quantum Machine Learning (QML) [6, 7, 25â€“31], Quantum Memories
(QMem) [17â€“24], and Quantum Linear Algebra (QLA) [7, 13, 32â€“35]. Quan-
tum machine learning algorithms try to estimate a target function from a
finite set of example points by unveiling correlations between inputs and out-
puts of the correspondent function [7, 28, 36]. Quantum memories must store
a set of samples from a configuration space as a superposition state before
the information is retrieved using the algorithm [17]. Quantum linear algebra
82

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
3
Î·1,3
Î·1,2
Î·1,1
x0
x1
Î·2,1
x2
x3
Î·2,2
Î·3,1
x4
x5
Î·4,1
x6
x7
(a)
Î±1,3
Î±1,2
Î±1,1
Î±2,1
Î±2,2
Î±3,1
Î±4,1
(b)
Fig. 1: Tree representations of quantum state preparation algorithms. (a)
State decomposition tree generated by Algorithm 1 with an 8-dimensional
input vector x (dashed nodes). The complex argument terms â„¦i,k were omitted
for readability. (b) Angle tree generated by Algorithm 2 with an 8-dimensional
input vector. The correspondent phase angles Î»j,v were omitted for readability.
algorithms operate with a critical assumption that classical data has been effi-
ciently encoded as probability amplitudes of a quantum state without which
the quantum speed-up vanishes [6, 7, 9, 13]. All of the above emphasizes the
importance of developing efficient quantum state preparation algorithms for
broad application of quantum computing techniques on classical data.
Several solutions to the problem of quantum state preparation have been
proposed [10, 14, 37â€“42], but all produce circuits with width or depth grow-
ing at least linearly with the size of the input vector [10]. For example, the
top-down method proposed in Ref. [37] achieves the exponential compression
of the quantum circuit width while requiring O(N) quantum circuit depth
for N-dimensional data. On the other extreme end, the bottom-up method
[42] achieves the exponential compression of the quantum circuit depth while
requiring O(N) quantum circuit width and entangled information in ancillary
qubits. Since there is an extra resource overhead in many quantum algorithms
due to the quantum measurement postulate [23, 43], such linear cost can
impose restrictions on possible speed-ups, dominating the computational cost
of the intended quantum application. Other approaches have reduced circuit
complexity to initialize an approximate quantum state [14, 44â€“46], but this
paper targets the exact state preparation with entangled ancillary qubits.
This work presents a quantum state preparation method that achieves
sublinear scaling on both quantum circuit resources. More specifically, a bidi-
rectional strategy that effectively combines the aforementioned approaches
in a way that the trade-off between computational time and space can be
configured. Both temporal and spatial complexities depend on the parame-
ter s âˆˆ[1..n], which adjusts the trade-off between computational time and
space. Given an N-dimensional input vector, the total time complexity of
the bidirectional algorithm is Oc(N) + Od(2s + log2
2(N) âˆ’s2), where Oc(N)
is the time of the classical preprocessing to create the quantum circuit and
Od(2s + log2
2(N) âˆ’s2) is the quantum circuit depth. Typically the same input
83

Springer Nature 2021 LATEX template
4
Configurable sublinear circuits for quantum state preparation
vector is loaded l â‰«N times, and hence the amortized computational time is
Od(2s+log2
2(N)âˆ’s2). Note that classical preprocessing is also common in clas-
sical computing and is necessary in other quantum state preparation methods
as well. The spatial complexity (i.e. the width) of the circuit is Ow((s+1)N/2s).
Besides the sublinear circuit cost, the ability to customize the exchange
between these quantum resources is advantageous when realistic quantum
hardware specifications are considered as one resource can be cheaper than
the other to scale up. For instance, it is a useful feature for future Noisy
Intermediate-Scale Quantum (NISQ) devices with the promise of computers
with a large number of physical qubits [47], albeit noise limits the depth of the
circuits [48].
This paper is divided into four sections. Section 2 reviews two strategies
for loading classical information into quantum devices, namely top-down [39]
and bottom-up [42] approaches. The former is used by quantum computing
libraries [49, 50] as the method for general quantum amplitude initialization.
These methods are at the two opposite ends of the quantum circuit cost spec-
trum requiring either the maximal circuit depth or width to minimize the
other resource. Section 3 presents the main result, a bidirectional method
that combines the top-down and bottom-up strategies in a configurable man-
ner. Complexity expressions for the bidirectional method are established in
Section 3.1, which shows that the bottom-up and the top-down strategies are
recovered when s = 1 and s = n, respectively, and that sublinear scaling on
both depth and width is possible when s = n/2. Proof-of-principle experiments
performed on superconducting and ion-trap based quantum devices are pre-
sented in Section 3.2. Section 5 presents the conclusion and perspectives for
future work.
2 Quantum state preparation with linear cost
2.1 Tree representation
Quantum state preparation algorithms aim to create a state P
p |xp|eiÏ‰p |pâŸ©
that encodes a normalized vector x = (|x0|eiÏ‰0, . . . , |xNâˆ’1|eiÏ‰Nâˆ’1) as the prob-
ability amplitudes. Several of the existing methods can be understood as a
walk on a binary tree [10, 39, 41, 42, 51]. Each tree node corresponds to a
controlled gate operation and the height increases with the number of qubits
(see Fig. 1a and Fig. 1b). Two edges stemming from each node indicate that
each controlled gate operation splits the Hilbert space into two subspaces.
Therefore, after n layers, there can be 2n subspaces with distinct probabil-
ity amplitudes. Depending on the choice of the walk direction, different state
preparation strategies, such as top-down and bottom-up approaches, can be
constructed.
84

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
5
To explain the procedure, four parameters [39] defined by the target vector
x are introduced as
â„¦i,k =
2kâˆ’1
X
l=0
Ï‰(iâˆ’1)2k+l/2kâˆ’1
(1)
Î·i,k =
v
u
u
t
2kâˆ’1
X
l=0
|x(iâˆ’1)2k+l|2
(2)
Î»j,v = â„¦2j,vâˆ’1 âˆ’â„¦j,v
(3)
Î²j,v = Î·2j,vâˆ’1/Î·j,v
(4)
where j = 1, 2, . . . , 2nâˆ’v, v = 1, 2, . . . , n, and n = log2(N). These parameters
are used to construct the tree representations of the state preparation algo-
rithms, namely the state tree (Fig. 1a) and the angle tree (Fig. 1b). Indices k
and v indicate a tree level in ascending order from the leaf nodes to the root,
i and j are node indices at a given level. The nodes of these trees are complex
values that represent the amplitudes of the quantum state to be encoded and
the rotation angles for the construction of the encoding quantum circuit. The
magnitude and complex argument of the state tree amplitudes are obtained
through Î·i,k and â„¦i,k, respectively. When k = 0, the parameters point to
the input vector x. Equations (3) and (4) determine rotation values of the
angle tree nodes. The phase arguments of the vector |xâŸ©are encoded through
z-rotations of angles Î»j,v, and the magnitudes through y-rotations of angles
Î±j,v = 2 asin(Î²j,v).
Algorithms 1 and 2 describe the construction of a state tree and an angle
tree. Respective pseudocodes 1 and 2 are presented in the appendix.
Algorithm 1: State tree construction
1 Initialize the state tree by the leafs, where each node value is a
complex amplitude from a 2n length state vector
2 Set k = 1
3 Create a new level with 2nâˆ’k nodes, where each node i value is
Î·i,keiâ„¦i,k (Eq. (1) and Eq. (2), i = 1, . . . , 2nâˆ’k)
4 If k < n, set k = k + 1 and return to Step 2, otherwise output the
state tree
2.2 Top-down approach
The top-down amplitude encoding approach to quantum state initialization is
a linear transformation consisting of a sequence of uniformly controlled rota-
tions [39, 51] that takes the initial basis vector |0âŸ©âŠ—n to some arbitrary vector
85

Springer Nature 2021 LATEX template
6
Configurable sublinear circuits for quantum state preparation
Algorithm 2: Angle tree construction
1 Set v = n
2 Create a new level with 2nâˆ’v nodes, where each node j value is
Î±j,veiÎ»j,v (Eq. (4) and Eq. (3), j = 1, . . . , 2nâˆ’v) using data from a
state tree generated by Alg. 1
3 If v > 1, set v = v âˆ’1 and return to Step 1, otherwise output the
angle tree
|0âŸ©0
Ry(Î±1,3)
|0âŸ©1
Ry(Î±1,2)
Ry(Î±2,2)
|0âŸ©2
Ry(Î±1,1)
Ry(Î±2,1)
Ry(Î±3,1)
Ry(Î±4,1)
Fig. 2: Quantum circuit to load an 8-dimensional real vector in a quantum
device using the top-down amplitude encoding strategy [10, 39, 51] (Alg. 3).
The qubit index indicated by the subscript corresponds to the tree level in
Fig. 1b.
|xâŸ©= (|x0|eiÏ‰0, . . . , |xNâˆ’1|eiÏ‰Nâˆ’1)T . This generates a quantum circuit with
complexity of Od(N) and Ow(log2(N)) [10, 39, 51].
The top-down state preparation (TDSP) algorithm begins by preparing the
following state at the root (v = n) of the angle tree (see Fig. 1b for an example)
|ÏˆnâŸ©= eâˆ’i
Î»1,n
2
q
1 âˆ’|Î²1,n|2 |0âŸ©+ ei
Î»1,n
2 Î²1,n |1âŸ©.
(5)
To load states into the next level (indicated by v in Eq. (6)), the current state
(indicated by v + 1 because v is in reverse order, decreasing from n to 1) is
sequentially combined with the values of the next state in Eq. (6).
|ÏˆvâŸ©=
2nâˆ’v
X
j=1
|j âˆ’1âŸ©âŸ¨j âˆ’1|Ïˆv+1âŸ©
 eâˆ’i
Î»j,v
2
q
1 âˆ’|Î²j,v|2 |0âŸ©+ ei
Î»j,v
2 Î²j,v |1âŸ©

(6)
The update of state |ÏˆvâŸ©is repeated for v = (n âˆ’1), . . . , 1, thereby obtaining
the desired state
|Ïˆ1âŸ©= |x0|eiÏ‰0 |0âŸ©+ . . . + |xNâˆ’1|eiÏ‰Nâˆ’1 |N âˆ’1âŸ©.
The summation in Equation (6) expresses the sequential characteristic of the
top-down approach, since the state of each layer of the tree needs to be loaded
on one qubit through a sequence of rotations. Figure 2 presents an example
86

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
7
quantum circuit for encoding 8-dimensional vector using the top-down state
preparation method.
Algorithm 3: Top-down state preparation
1 Generate a state tree from the input vector
2 Generate an angle tree from the state tree
3 Create a quantum circuit with n qubits (one qubit for each angle tree
level)
4 Perform one y-rotation and one z-rotation on the first qubit (qubits
are 0-indexed) using the angle tree root values Î±1,n and Î»1,v (Eq. (5))
5 Set v = n âˆ’1 (starts at the root)
6 Perform a Uniformly Controlled Rotation controlled by qubits
0, 1, . . . , n âˆ’v âˆ’1 (corresponding to the previous levels) with the
current qubit n âˆ’v as target, using the current level nodes values
Î±j,v and Î»j,v (1 â‰¤j â‰¤2nâˆ’v) as rotation angles (Eq. (6))
7 If v > 1, set v = v âˆ’1 and return to Step 5, otherwise output the
encoding quantum circuit
The name top-down comes from the way this approach walks through the
tree from the root to the leaves to build a quantum circuit. The combination
of states is done with multi-controlled rotations, and it takes log2(N) qubits to
generate the complete state. At each level, it assembles a sequence of rotations
targeting one qubit and is controlled by the qubits of the previous levels. First,
y-rotations are applied to set the magnitudes, followed by z-rotations to set
the phases. These steps are presented in Algorithm 3 with its Pseudocode 3
provided in the appendix.
2.3 Bottom-up approach
The bottom-up state preparation algorithm constructs a quantum circuit with
complexity Od(log2
2(N)) and Ow(N) [42]. It starts by preparing N/2 single-
qubit states, corresponding to the leaves of the tree (Fig.1a). Equations (3)
and (4) are used starting from the lowest level of the tree (v = 1), which
corresponds to starting from the initial state
|Ïˆj,1âŸ©= eâˆ’i
Î»j,1
2
q
1 âˆ’|Î²j,1|2 |0âŸ©+ ei
Î»j,1
2 Î²j,1 |1âŸ©.
(7)
Loading the states in the upper levels of the tree is done by recursive updates
of
|Ïˆj,vâŸ©=
eâˆ’i
Î»j,v
2
q
1 âˆ’|Î²j,v|2 |0âŸ©|Ïˆ2jâˆ’1,vâˆ’1âŸ©|Ïˆ2j,vâˆ’1âŸ©+
ei
Î»j,v
2 Î²j,v |1âŸ©|Ïˆ2j,vâˆ’1âŸ©|Ïˆ2jâˆ’1,vâˆ’1âŸ©,
(8)
87

Springer Nature 2021 LATEX template
8
Configurable sublinear circuits for quantum state preparation
one-qubit states
combining states
|0âŸ©0
Ry(Î±1,3)
Rz(Î»1,3)
output
|0âŸ©1
Ry(Î±1,2)
Rz(Î»1,2)
|0âŸ©2
Ry(Î±2,2)
Rz(Î»2,2)
ancilla
|0âŸ©3
Ry(Î±1,1)
Rz(Î»1,1)
output
|0âŸ©4
Ry(Î±2,1)
Rz(Î»2,1)
ancilla
|0âŸ©5
Ry(Î±3,1)
Rz(Î»3,1)
|0âŸ©6
Ry(Î±4,1)
Rz(Î»4,1)
(a)
...
...
...
...
a |0âŸ©+ b |1âŸ©
a |0âŸ©|ÏˆâŸ©|Ï•âŸ©+ b |1âŸ©|Ï•âŸ©|ÏˆâŸ©
|ÏˆâŸ©m
|Ï•âŸ©m
(b)
Fig. 3: Divide-and-conquer bottom-up load strategy. (a) Circuit generated
by the divide-and-conquer [42] bottom-up strategy (Alg. 4) to load an 8-
dimensional complex vector in a quantum device. The indexes of the qubits
correspond to the tree nodes indexes in Fig. 1b. The circuit starts with the
simultaneous preparation of (N âˆ’1) one-qubit states associated with all tree
nodes, followed by the combination of states through CSWAPs. (b) Combin-
ing states with controlled-swap operations.
where v = 2, . . . , n. The desired state, with ancilla |Ï•âŸ©, is obtained when v = n
as
|Ïˆ1,nâŸ©= |x0|eiÏ‰0 |0âŸ©|Ï•0âŸ©+ Â· Â· Â· + |xNâˆ’1|eiÏ‰Nâˆ’1 |N âˆ’1âŸ©|Ï•Nâˆ’1âŸ©.
(9)
Updating the states in Equation (8) requires a method that entangles each
of the two states |Ïˆ2jâˆ’1,vâˆ’1âŸ©and |Ï•2j,vâˆ’1âŸ©to orthonormal subspaces |0âŸ©and
|1âŸ©, respectively, with designated amplitudes. As demonstrated by Araujo et
al. [42], m controlled-swap (CSWAP) operations can combine two m-qubit
states in the form of Equation (8) (see Fig. 3b) to encode the desired set
of amplitudes in the orthonormal subspaces of the first m + 1 qubits. Since
each node of the level is represented by one qubit, multiple loading within a
layer can be performed in parallel. Thus, all states in the given layer can be
loaded simultaneously. This is an advantage in comparison to the top-down
approach which loads each node state sequentially. Since the underlying idea
of the bottom-up approach is recursive combination of single-qubit states that
are easy to prepare, it was named as divide-and-conquer state preparation
(DCSP) when first introduced [42]. An example quantum circuit for encoding
8-dimensional vector using the DCSP method is depicted in Fig. 3a. Algorithm
4 describes these steps and Pseudocode 4 is provided in the appendix.
88

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
9
Algorithm 4: Bottom-up state preparation
1 Generate a state tree from the input vector
2 Generate an angle tree from the state tree
3 Create a quantum circuit with 2n âˆ’1 qubits (one qubit for each angle
tree node)
4 Perform 2nâˆ’1 y-rotations and z-rotations on qubits 2nâˆ’1 + j âˆ’2
(1 â‰¤j â‰¤2nâˆ’1) using the leaf values Î±j,1 and Î»j,1 to prepare 2nâˆ’1
initial single-qubit states (Eq. (7), Fig. 3a)
5 Set v = 2 and j = 1 (starts at the bottom)
6 Perform one y-rotation and one z-rotation on qubit 2nâˆ’v + j âˆ’2 using
the node values Î±j,v and Î»j,v to prepare a single-qubit state to
control CSWAPs operations
7 Perform Controlled SWAPs controlled by qubit 2nâˆ’v + j âˆ’2 to
combine the previous states prepared with the qubits associated to
the sub-tree started by the current node (Eq. (8), Fig. 3b)
8 If j < 2nâˆ’v, set j = j + 1 and return to Step 5, otherwise continue
9 If v < n, set v = v + 1 and return to Step 5, otherwise output the
encoding quantum circuit
3 Bidirectional quantum state preparation
This section presents a bidirectional state preparation (BDSP) method com-
bining both bottom-up and top-down strategies as walking on the tree in both
directions. This new strategy can interchange depth and space cost in a con-
figurable manner, thereby allowing for the sublinear cost in both quantum
circuit depth and width. In particular, the equilibrium point between these
costs achieves the quadratic reduction in both space and time. The algorithm
is depicted in Fig. 4 and the detailed explanation is provided as follows.
The bidirectional state preparation algorithm starts by informing a level
v = s (enumerated from bottom to top, where 1 â‰¤s â‰¤n) at which the
angle tree is split, followed by two stages. In the first stage, it segments the
tree section below s into 2nâˆ’s sub-trees of height s. The 2nâˆ’s nodes at level
s are the roots of these sub-trees. The number of sub-trees determines how
many initial sub-states should be prepared in the first stage of the algorithm.
The amplitude values of these sub-states aj = (aj,1, . . . , aj,2s) (1 â‰¤j â‰¤2nâˆ’s)
are loaded concurrently using a sequential algorithm [10, 39, 51] based on the
TDSP method as
|Ïˆj,sâŸ©=
2s
X
k=1
aj,k |k âˆ’1âŸ©
;
j = 1, 2, . . . , 2nâˆ’s.
(10)
The initial sub-states are the input of the second stage of BDSP. They repro-
duce the state that would be created by the bottom-up steps up to the split
level s. In the second stage, the sub-states are combined to generate the
89

Springer Nature 2021 LATEX template
10
Configurable sublinear circuits for quantum state preparation
Î±0
1,3
s = 3
Î±1
1,2
Î±1
1,1
Î±1
2,1
Î±2
1,2
s = 2
Î±2
1,1
Î±2
2,1
s = 1
(a)
stage 2
stage 1
|0âŸ©0
B
|0âŸ©1
A1
|0âŸ©3
|0âŸ©2
A2
|0âŸ©5
output
input
ancilla
(b)
stage 2
stage 1
|0âŸ©0
Ry(Î±0
1,3)
output
|0âŸ©1
Ry(Î±1
1,2)
|0âŸ©3
Ry(Î±1
1,1)
Ry(Î±1
2,1)
|0âŸ©2
Ry(Î±2
1,2)
ancilla
|0âŸ©5
Ry(Î±2
1,1)
Ry(Î±2
2,1)
(c)
Fig. 4: Schematics of the bidirectional algorithm. (a) Angle tree example with
a split at level s = 2. The blue and red nodes (Î±1 and Î±2) correspond to the
bidirectional procedure first stage. In each of the two sub-trees of the first
stage, 4 of the 8 amplitudes expected as input by stage 2 are encoded using a
top-down method. The green node (Î±0) above the tree split correspond to the
second stage single sub-tree, subject to a partial DCSP bottom-up procedure.
The first stage red nodes (j > 1) are no longer associated with an ancilla
since they are now encoded through a top-down approach. (b) Block diagram
circuit, corresponding to the tree in (a). In stage 1, the Ak operators (the index
k is related to angle vectors Î±k upper index) are responsible for encoding the
amplitudes that will be used as input by stage 2. In this example, each Ak
operator encodes 4 amplitudes from a total of 8. The B operator is the partial
DCSP for 8 amplitudes, which is initialized with the expected state for the
split level 2 and continues with the traditional algorithm. (c) Detailed view of
(b), generated by the bidirectional strategy described in Algorithm 5 for a real
and positive 8-dimensional input vector.
complete state by the divide-and-conquer approach (Fig. 4c). The bottom-up
algorithm takes the state prepared in the first stage as the input, and starts
walking on the tree from the split level (Eq. (8), where v = s + 1, . . . , n).
In other words, the BDSP follows the bottom-up DCSP algorithm starting
from states |Ïˆj,sâŸ©(Eq. (10)) instead of starting from the single-qubit leaf
states (Eq. (7)). The BDSP algorithm is described in Algorithm 5 below with
Pseudocode 5 provided in the appendix.
90

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
11
Algorithm 5: Bidirectional state preparation
1 Generate a state tree from the input vector
2 Generate an angle tree from the state tree
3 Create a quantum circuit with (s + 1)2nâˆ’s âˆ’1 qubits (Eq. (12))
4 Perform Algorithm 3 (top-down approach) starting from step 3 to
prepare 2nâˆ’s states of s-qubits (replacing n by s), using the 2nâˆ’s
sub-trees as input for each state (Eq. (10)). This step is named Stage 1
5 Perform Algorithm 4 (bottom-up approach) starting from step 5 and
v = s + 1 to combine the 2nâˆ’s states prepared in Stage 1 using the
remaining 2nâˆ’s âˆ’1 qubits (Eq. (8)). This step is named Stage 2
6 Output the encoding quantum circuit
3.1 Complexity
In general, the BDSP algorithm builds quantum circuits whose depth and
width are expressed respectively by
N
2log2(N)âˆ’s
|
{z
}
stage 1
+
log2(N)
X
i=s+1
i âˆ’1
|
{z
}
stage 2
= 2s + 1
2(log2
2(N) âˆ’log2(N) âˆ’s2 + s)
(11)
and
sN
2s
|{z}
stage 1
+ N
2s âˆ’1
| {z }
stage 2
= (s + 1)N
2s âˆ’1,
(12)
where N is the number of amplitudes (i.e. the dimension of the data vec-
tor) and s is a parameter indicating the tree splitting level (the tree level in
reverse order). Stage 1 and 2 indicate the contribution from each stage of the
bidirectional procedure to the circuit complexity stated in Theorem 1.
Theorem
1.
Algorithm
5
generates
a
quantum
circuit
with
depth
Od
 2s + log2
2 (N) âˆ’s2
and width Ow
 (s + 1) N
2s

.
In Equation (11), first term (stage 1) is the leading-order approximation of
the quantum circuit depth from existing top-down based algorithms [10, 39]
for sub-states with s qubits. The exact expression depends on which of the two
algorithms is used. The summation of the second term (stage 2) is the divide-
and-conquer circuit depth from split level s + 1 to n. Similarly, the first term
in Equation (12) is the number of qubits occupied by all first stage sub-states
and the second term is the number of qubits used by the second stage.
There are three noteworthy configuration values for the parameter s (see
Table 1). Setting s = log2(
âˆš
N) achieves asymptotic sublinearity, and s = 1
or s = log2(N) recovers bottom-up or top-down approaches.
91

Springer Nature 2021 LATEX template
12
Configurable sublinear circuits for quantum state preparation
bottom-up
s = 1
top-down
s = n
sublinear
s = n/2
Od
n2
2n
2n/2
Ow
2n
n
2n/2
Table 1: Bidirectional quantum circuit complexity for different configurations.
These expressions were obtained from Eq. (11) and Eq. (12).
The condition for quadratic reduction in both depth and width is obtained
through asymptotic analysis of the minimum distance between Eq. (11) and
Eq. (12). The first (second) equation is a monotonically increasing (decreasing)
function âˆ€s âˆˆ{x âˆˆR|4 â‰¤x â‰¤log2(N)} and there is a point s where the
distance is zero when N â†’âˆ. Thus the minimum distance point is given by
finding s that satisfies
lim
Nâ†’âˆOw âˆ’Od = 0.
(13)
Fig. 5: The solution of the system Ow âˆ’Od = 0 approaches k = 1/2 as N
increases.
The asymptotic analysis starts by rewriting Eq. (11) and Eq. (12) using a
more convenient parameterization,
s = f(k) = k log2(N)
where
k âˆˆ

4
log2(N), 1

.
Applying the limit of Eq. (13) results in the following simplified expression
N 2kâˆ’1 = 1.
Solving the above equation for k gives the solution k = 1/2. Therefore, to
achieve sublinear circuit complexity with quadratic reductions in both quan-
tum circuit depth and width, the tree split must occur at s = 1/2 log2(N) = n/2,
which leads to Theorem 2.
Theorem 2. Algorithm 5 with s = n/2 and N â‰«1 generates a quantum circuit
with sublinear depth Od
 âˆš
N

and width Ow
 âˆš
N

.
92

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
13
When dealing with input vectors of small size, s can be calculated by solving
Eq. (13) directly with N being a constant. If s cannot be calculated exactly,
it can be approximated with the asymptotic result s = âŒˆn/2âŒ‰. The reason for
the ceiling function is because s approximates n/2 from upper values (Fig. 5).
Corollary 2.1. When N â‰¤8 a top-down approach (s = log2(N)) should
always be used, since space and depth both decrease as s increases in the interval
s âˆˆ[1..3] (see Table 3 for a numerical example). Circuit depth increases only
when s â‰¥4.
3.2 Experiment
To evaluate the bidirectional method, proof-of-principle experiments were per-
formed on a classical simulator provided by IBM, four superconducting-qubit
based quantum devices provided by IBM, and an ion-trap based quan-
tum device provided by IonQ. These are named as ibmq qasm simulator,
ibmq rome, ibmq santiago, ibmq casablanca, and ibmq jakarta, and IonQ,
respectively. The experiments aim to load the following 8 and 16-dimensional
real input vectors:
(
âˆš
0.03,
âˆš
0.06,
âˆš
0.15,
âˆš
0.05,
âˆš
0.1,
âˆš
0.3,
âˆš
0.2,
âˆš
0.11)
and
(
âˆš
0.01,
âˆš
0.02,
âˆš
0.04,
âˆš
0.02,
âˆš
0.07,
âˆš
0.08,
âˆš
0.04,
âˆš
0.01,
âˆš
0.08,
âˆš
0.02,
âˆš
0.21,
âˆš
0.09,
âˆš
0.12,
âˆš
0.08,
âˆš
0.05,
âˆš
0.06).
Three configurations of the bidirectional method are compared, namely
top-down (s = n), bottom-up (s = 1), and sublinear (s = âŒˆn/2âŒ‰). The first
case uses the least number of qubits Ow(log2(N)) and maximum depth Od(N).
In the second configuration, depth is minimum Od(log2
2(N)) and the number
of qubits is maximum Ow(N). The last configuration uses the best trade-
off between the quantum circuit depth and width and achieves the sublinear
scaling for both. In this case, the quantum circuit depth and width both grow
as O(
âˆš
N).
Table 2 lists the experimental results, presenting the number of runs
per device and dimensionality of the input vector. The ibmq rome and
ibmq santiago devices have only five qubits, and due to this limitation they
are not suitable to encode the 8-dimensional vector with the bottom-up con-
figuration (i.e. s = 1) or to perform sublinear (i.e. s = âŒˆn/2âŒ‰) and bottom-up
experiments to encode the 16-dimensional vector (see Corollary 2.1). None of
the quantum devices used in this work has the capacity to run the bottom-up
configuration for the 16-dimensional input vector, which requires at least 15
qubits (i.e. N âˆ’1 qubits).
Figure 7 presents the average output of the experiments with 8 and 16-
dimensional input vectors. The height of blue and red bars is an average value
obtained from a number of repetitions shown in the runs column in Table 2,
and the error bars represent the standard deviation. The height of the yellow
bar is the experimental result averaged over all quantum devices.
93

Springer Nature 2021 LATEX template
14
Configurable sublinear circuits for quantum state preparation
device
N
s
runs
MAE
ibmq qasm simulator
32 qubits
8
1
5
0.0016
2
5
0.0005
3
5
0.0015
16
2
5
0.0010
4
5
0.0010
ibmq rome
5 qubits
8
2
10
0.0577
3
10
0.0429
16
4
5
0.0409
ibmq santiago
5 qubits
8
2
10
0.0464
3
10
0.0233
16
4
10
0.0225
ibmq casablanca
7 qubits
8
1
10
0.0710
2
10
0.0691
3
10
0.0213
ibmq jakarta
7 qubits
8
1
10
0.0594
2
10
0.0497
3
10
0.0289
IonQ
11 qubits
8
1
5
0.0455
2
5
0.0242
3
5
0.0217
16
2
5
0.0261
4
5
0.0107
Table 2: Results of the BDSP experiments that encode N-dimensional input
vectors in the amplitudes of quantum states using a classical simulator and
quantum devices for N = {8, 16}. The acronym MAE stands for mean absolute
error. The bold font indicates the smallest MAE, and hence the best perfor-
mance, among different configurations of s for each device and input vector.
N = 8
N = 16
N = 32
N = 64
s
CNOTs
depth
qubits
CNOTs
depth
qubits
CNOTs
depth
qubits
CNOTs
depth
qubits
1
28
31
7
77
58
15
182
93
31
399
136
63
2
18
24
5
57
51
11
142
86
23
319
129
47
3
10
20
3
41
48
7
110
83
15
255
126
31
4
26
51
4
80
87
9
195
130
19
5
58
114
5
151
158
11
6
122
241
6
Table 3: Exchange between circuit depth, width (qubits), and number of
CNOTs by adjusting the parameter s (split). s can be interpreted as a hyper-
parameter to fine-tune the encoding circuit to hardware characteristics such
as relaxation time, dephasing time, and the CNOT gate error.
Table 3 and Figure 6 show the trade-off between quantum circuit depth,
width and the number of CNOT gates as s is varied for randomly generated
target vectors of various sizes. As expected through the analysis of the number
of CNOT gates and the circuit depth in Tab. 3, the experimental results in
Table 2 and Figure 7 show performance favoring the top-down configuration
(s = n) for small input sizes (N < 64) due to the smaller number of CNOT
gates and the smaller or approximately equal depth of the circuit. The number
of CNOT gates, circuit depth, and number of qubits all decrease as s progresses
to s = 3. The depth starts to increase when s > 3, as previously implied by
94

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
15
(a) 23 amplitudes.
(b) 26 amplitudes.
(c) 210 amplitudes.
(d) 215 amplitudes.
Fig. 6: Exchange between circuit depth, width (number of qubits), and number
of CNOTs to load a 2n-dimensional complex vector into a quantum computer
by adjusting parameter s. The increasing number of CNOTs at lower depths
is a consequence of exchanging computational time for space, given the combi-
nation of distant states. It also indicates an increase in concurrent operations.
Eq. (11). The comparison employs the mean absolute error (MAE). For each
device and input size, the ranking is established where a smaller MAE indicates
better performance (see Table 2).
Data from Table 3 and Figure 6 were obtained using the transpile method
in the Quantum Information Science Kit (Qiskit [49]) version 0.26.2 to decom-
pose the circuits into physical single-qubit gates and the CNOT gate. These
circuits were generated by the bidirectional algorithm with random complex
input vectors. The Python code used in this work for implementing Algorithm
3 employs functions ucry and ucrz from Qiskit. These functions are called uni-
formly controlled rotations (or multiplexers), and the corresponding code in
Qiskit is based on the work of Shende et al. [10].
Note that algorithms 3 and 4 allocate logical qubits as they are needed
without concerning their assignment to physical qubits of the quantum device.
For NISQ devices with limited quantum device coupling map, the logical to
95

Springer Nature 2021 LATEX template
16
Configurable sublinear circuits for quantum state preparation
(a) N = 8 top-down.
(b) N = 8 sublinear.
(c) N = 8 bottom-up.
(d) N = 16 top-down.
(e) N = 16 sublinear.
Fig. 7: Experimental results with 8- and 16-dimensional input vectors. Blue
and red bars indicate respectively the ideal results and the ibm qasm simulator
results. Yellow bars indicate the output average values from the experiments
on all quantum devices. Error bars are the standard deviation.
physical qubit mapping should be optimized in order to minimize the overhead
in the quantum circuit depth and the number of gates.
4 Sparse bidirectional quantum state
preparation
The previous section explained the bidirectional method for encoding data in
the amplitudes of a quantum state consisting of n qubits, where 2n = N is the
total amount of amplitudes of that state. Like other approaches for loading
data in the amplitudes, the method presented in this paper has a classical
preprocessing complexity O(N). Moreover, such algorithms generate circuits
whose spatial and depth costs also depend on N. This dependence on the total
number of state amplitudes makes these methods inappropriate for encoding
sparse input vectors, where the number of non-zero amplitudes M is much
smaller than 2n.
This section presents a sparse variant of the bidirectional algorithm (Pseu-
docode 6). This variant reduces the classical preprocessing complexity to O(M)
through a modification in the construction of the state tree (Pseudocode 7,
Fig. 8b). Knowing that such a tree is binary, one can see that the value of
each node is a combination of the pair at the lower level (see Eq. 4). If the
zero-valued amplitudes are not present at the leafs of the state tree (Fig. 8a),
the nodes at the levels above, whose children are absent, are not constructed
(Fig. 8b). This eliminates some branches from the tree.
As seen in the previous section (Eq. 10), the size of a top-down sub-state
is defined by the parameter s (split), which indicates the number of qubits of
96

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
17
Î·1,3
0
0
0
0
0
0
0
Î·2,2
Î·3,1
x4
x5
0
0
0
(a)
Î·1,3
Î·2,2
Î·3,1
x4
x5
(b)
Ï€
0
Î±3,1
(c)
Fig. 8: Sparse state preparation. (a) Dense state decomposition of an 8-
dimensional input vector with only data patterns 4 and 5 not equal to zero.
Compare with Figure 1a. (b) Sparse state decomposition generated by Pseu-
docode 7. The information in this sparse decomposition is equal to that
of Figure 8a. (c) Sparse angle tree generated by function angle tree (Pseu-
docode 2) from the sparse state tree shown in Figure 8b. Node Î±1,3 is always
equal to Ï€ because Î·1,3 only has a child on the right (Pseudocode 7, Line 16,
and Pseudocode 2, Line 6). Node Î±2,2 is always zero because Î·2,2 only has a
child on the left (Pseudocode 7, Line 25, and Pseudocode 2, Line 2). Node Î·3,1
has left and right children, so Î±3,1 value depends on nodes x4 and x5 (Pseu-
docode 7, Line 20).
the sub-state and, therefore, the number of amplitudes 2s that it can encode.
The number of sub-states depends on two parameters, s (split) and n (total
number of qubits of the complete state, which also indicates the height of
the state tree). With both parameters, the number of sub-states is 2n/2s =
2nâˆ’s. Therefore, each block of 2s amplitudes from the input vector makes
up a sub-state and that for this sparse version if the block is empty (zero
amplitudes) the sub-state is not necessary for the construction of the complete
state (Fig. 8b). If a sub-state has all nodes eliminated, it is no longer needed
nor represented in the quantum circuit, reducing the necessary space (qubits).
Another consequence of eliminating a sub-state is that the second stage of
the algorithm (bottom-up) will combine a smaller number of states (Eq. 8),
therefore reducing the number of CSWAP operators and the total depth of the
circuit.
The main difference between the dense algorithm (Pseudocode 5) and
the sparse one (Pseudocode 6) is the construction of the state tree. Function
initialize bidirectional differs from function
initialize sparse bidirectional
only
by
Line
3,
replacing
the
state decomposition function call with sparse state decomposition. In
the latter function, the main change that enables sparsity is the introduction
of Line 16 if conditional statement. This statement has three possible out-
comes. The first one (Line 20) occurs when two consecutive nodes of even and
97

Springer Nature 2021 LATEX template
18
Configurable sublinear circuits for quantum state preparation
odd index are present, being identical to the dense case (Pseudocode. 1). The
other two outcomes, first (Line 16) and third (Line 25) conditions, occur when
either of the pair nodes is absent and assumed to have zero amplitude. If the
complete pair is absent, none of the statement outcomes are met, then the
pair is ignored, and the respective parent node is not created. Node indices
are guaranteed to be preserved by Line 12 of Pseudocode 7.
5 Conclusion
Existing state preparation methods, such as top-down and bottom-up
approaches, require at least one quantum circuit resource between depth and
width to grow linearly with the problem size. The BDSP algorithm pre-
sented in this work provides a general framework for configuring the trade-off
between these resources that can be useful to manage them on NISQ devices.
Looking at the state preparation algorithms as a walk on the state tree (see
Section 2.1), the BDSP algorithm constitutes a systematic way to walk in two
opposite directions. Previous methods are based on walking only in one direc-
tion. The bidirectional algorithm comes with a free parameter s âˆˆ[1, n] that
determines the balance between the top-down and the bottom-up approaches.
At two extreme cases of setting s = n and s = 1, the top-down and the
bottom-up approaches are respectively recovered. At the equilibrium point
s = âŒˆn/2âŒ‰, quadratic reduction in both quantum circuit depth and width can
be achieved. The configuration parameter can be viewed as a hyperparameter
that can tune circuit sizes and the number of CNOT gates according to the
compound of application and hardware properties. The BDSP method is vali-
dated and demonstrated through experiments performed on five real quantum
devices. The experiments behaved as expected, according to the asymptotic
and numerical analyses of the circuit complexity.
A possible future work is to investigate whether the quantum circuit cost
of the DCSP part can be futher reduced. Note that the structure of CSWAP
operations in the DCSP step only depends on the dimensionality of the dataset
N. Hence, the CSWAP operations can be interpreted as a single layer of fixed
operation. Decomposing this fixed operation more efficiently than the naive
application of CSWAP gates would achieve further reduction in the quantum
circuit depth.
Acknowledgments.
This work is based upon research supported by
CNPq (Grant No. 308730/2018-6, No. 306727/2017-0, No. 409415/2018-
9
and
No.
421849/2016-9),
CAPES
â€“
Finance
Code
001,
FACEPE
(Grant No. IBPG-0834-1.03/19), National Research Foundation of Korea
(Grant
No.
2019R1I1A1A01050161,
No.
2021M3H3A1038085
and
No.
2022M3E4A1074591), the South African Research Chair Initiative, Grant
No. 64812, of the Department of Science and Innovation and the National
Research Foundation (NRF). Support of the NICIS (National Integrated
Cyberinfrastructure System) e-research grant QICSA is kindly acknowledged.
We acknowledge the use of IBM Quantum services for this work. The views
98

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
19
expressed are those of the authors, and do not reflect the official policy or
position of IBM or the IBM Quantum team.
Competing interests
The authors declare no competing interests.
Data availability
The sites https://github.com/qclib/qclib-papers and https://github.com/
qclib/qclib contain all the data and the software generated during the current
study.
Appendix A
Pseudocode
Pseudocodes 1 to 5 expresses algorithms 1 to 5. Pseudocodes 1 and 2 construct
the tree representations of the state preparation algorithms, namely the state
tree and the angle tree, as described in Section 2.1. Pseudocodes 3 and 4, which
algorithms are explained in sections 2.2 and 2.3, build quantum circuits using
top-down and bottom-up approaches for encoding a complex input vector into
the amplitudes of a quantum state. Pseudocode 5 employs pseudocodes 1 to 4
and expresses the bidirectional state preparation algorithm (Sec. 3, Alg. 5).
Lines 5 and 6 of Pseudocode 5 indicate the two stages of the BDSP
algorithm. Line 5 at function top down tree walk performs the first stage
preparing the sub-states expected by the next stage, equivalent to what would
be generated by bottom-up DCSP up to the tree split, but with the absence of
ancilla due to the top-down approach. Line 6 at function bottom up tree walk
performs the second stage, starting at level s + 1 with the sub-states initial-
ized by the previous stage. Line 3 at function top down tree walk configures
the recurrence so that at split level s it divides the angle tree into 2nâˆ’s
(number of nodes at split level s) sub-trees of height s, loading all these sub-
trees concurrently using the top-down strategy. Lines 11 and 12 of function
bottom up tree walk initialize 2nâˆ’s âˆ’1 qubits exclusive to the second stage
with values Ry(Î±j,v) and Rz(Î»j,v). Then function cswaps combine the states
through CSWAP gates controlled by the nodes above level s. With the tree
described in Fig. 4a and s = 2, the bidirectional procedure (Pseudocode 5)
generates the circuit present in Fig. 4c.
99

Springer Nature 2021 LATEX template
20
Configurable sublinear circuits for quantum state preparation
Pseudocode 1: Generate a state tree by the decomposition of an
amplitude input vector
1 state decomposition(nqubits, data):
input : Number of qubits (nqubits) required to generate a state
with the same length as the data vector (2nqubits).
input : A list (data) representing the state to be decomposed,
with exactly 2nqubits pairs (index, amplitude).
output: Root of the state tree.
// Initialize an auxiliary vector new nodes with data
vector amplitudes
2
new nodes = []
3
for k â†0 to length(data) âˆ’1 do
4
node.index = data[k].index
5
node.level = nqubits
6
node.amplitude = data[k].amplitude
7
new nodes[k] = node
// Build the state tree
8
for level â†nqubits to 1 step âˆ’1 do
9
nodes = new nodes
10
new nodes = []
11
for k â†0 to length(nodes) âˆ’1 step 2 do
12
mag =
q
|nodes[k].amplitude|2 + |nodes[k+1].amplitude|2
13
arg = (âˆ nodes[k].amplitude + âˆ nodes[k+1].amplitude)/2
14
node.index = nodes[k].index // 2
15
node.level = level
16
node.amplitude = mag Ã— exp(1j Ã— arg)
17
node.left = nodes[k]
18
node.right = nodes[k+1]
19
new nodes[k//2] = node
20
return new nodes[0] ;
// return tree root
100

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
21
Pseudocode 2: Generate a angle tree that will be used to perform
the state preparation
1 angle tree(state tree):
input : An output of state decomposition function (state tree).
output: Tree with angles that will be used to perform the state
preparation.
2
angle y, angle z = 0
3
if state tree.right Ì¸= null then
4
amp = 0
5
if state tree.amplitude Ì¸= 0 then
6
amp = state tree.right.amplitude / state tree.amplitude
7
angle y = 2 arcsin(|amp|)
8
angle z = 2âˆ amp
9
node.index = state tree.index
10
node.level = state tree.level
11
node.angle y = angle y
12
node.angle z = angle z
13
if state tree.left Ì¸= null & !is leaf(state tree.left) then
14
node.left = angle tree(state tree.left)
15
if state tree.right Ì¸= null & !is leaf(state tree.right) then
16
node.right = angle tree(state tree.right)
17
return node
101

Springer Nature 2021 LATEX template
22
Configurable sublinear circuits for quantum state preparation
Pseudocode 3: Construct a circuit that perform a top-down state
preparation for the input vector state. The intended quantum state
is encoded on the output qubits.
1 top down tree walk(angle tree, circuit, start level,
control nodes=null, target nodes=null):
input : An output of angle tree function (angle tree).
input : A quantum circuit to apply the top-down encoding
(circuit).
input : The tree level to start the walk (start level).
input : Used in the recursive calls (control nodes).
input : Used in the recursive calls (target nodes).
output: circuit after the application of the top-down encoding.
2
if angle tree Ì¸= null then
3
if angle tree.level < start level then
4
top down tree walk(angle tree.left, circuit, start level)
5
top down tree walk(angle tree.right, circuit, start level)
6
else
7
angle tree.qubit = add qubit(circuit)
8
if target nodes == null then
9
control nodes = [] ;
// initialize the controls
list
10
target nodes[0] = angle tree ;
// start by the
sub-tree root
11
uniformly controlled rotation(circuit, control nodes,
target nodes)
12
append(control nodes, angle tree) ; // add curr. node to
the controls list
13
target nodes = children(target nodes) ;
// all the
nodes in the next level
14
if angle tree.left Ì¸= null then
15
top down tree walk(angle tree.left, circuit, start level,
control nodes, target nodes)
16
else
17
top down tree walk(angle tree.left, circuit, start level,
control nodes, target nodes)
18 initialize top down(circuit, state):
19
nqubits = log2(length(state))
20
state tree = state decomposition(nqubits, state)
21
angle tree = angle tree(state tree)
22
top down tree walk(angle tree, circuit, 0)
23
output nodes = left view(angle tree)
24
for k â†0 to nqubits âˆ’1 do
25
output qubits[k] = output nodes[k].qubit
26
return output qubits
102

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
23
Pseudocode 4: Construct a circuit that perform a bottom-up state
preparation for the input vector state. The intended quantum state
is encoded on the output qubits.
1 cswaps(angle tree, circuit):
input : An output of angle tree function (angle tree).
input : A quantum circuit to apply the cswaps (circuit).
output: circuit after the application of the cswaps.
2
left = angle tree.left
3
right = angle tree.right
4
while left Ì¸= null & right Ì¸= null do
5
circuit.cswap(angle tree.qubit, left.qubit, right.qubit)
6
left = left.left
7
right = right.left
8 bottom up tree walk(state tree, circuit, start level):
input : An output of state decomposition function (state tree).
input : A quantum circuit to apply the bottom-up encoding
(circuit).
input : The tree level to start the bottom-up walk (start level).
output: circuit after the application of the bottom-up encoding.
9
if angle tree Ì¸= null & angle tree.level < start level then
10
angle tree.qubit = add qubit(circuit)
11
circuit.ry(angle tree.angle y, angle tree.qubit)
12
circuit.rz(angle tree.angle z, angle tree.qubit)
13
bottom up tree walk(angle tree.left, circuit, start level)
14
bottom up tree walk(angle tree.right, circuit, start level)
15
cswaps(angle tree, circuit)
16 initialize bottom up(circuit, state):
17
nqubits = log2(length(state))
18
state tree = state decomposition(nqubits, state)
19
angle tree = angle tree(state tree)
20
bottom up tree walk(angle tree, circuit, nqubits)
21
output nodes = left view(angle tree)
22
for k â†0 to nqubits âˆ’1 do
23
output qubits[k] = output nodes[k].qubit
24
return output qubits
103

Springer Nature 2021 LATEX template
24
Configurable sublinear circuits for quantum state preparation
Pseudocode 5: Construct a circuit that perform a bidirectional state
preparation for the input vector state. The intended quantum state
is encoded on the output qubits.
1 initialize bidirectional(circuit, state, split):
2
nqubits = log2(length(state))
3
state tree = state decomposition(nqubits, state)
4
angle tree = angle tree(state tree)
5
top down tree walk(angle tree, circuit, nqubitsâˆ’split) ; // stage
1
6
bottom up tree walk(angle tree, circuit, nqubitsâˆ’split) ;
// stage 2
7
output nodes = left view(angle tree)
8
for k â†0 to nqubits âˆ’1 do
9
output qubits[k] = output nodes[k].qubit
10
return output qubits
Pseudocode 6: Construct a circuit that perform a bidirectional state
preparation for the sparse input vector state. The intended quantum
state is encoded on the output qubits.
1 initialize sparse bidirectional(circuit, state, split):
2
nqubits = log2(length(state))
3
state tree = sparse state decomposition(nqubits, state)
4
angle tree = angle tree(state tree)
5
top down tree walk(angle tree, circuit, nqubitsâˆ’split) ; // stage
1
6
bottom up tree walk(angle tree, circuit, nqubitsâˆ’split) ;
// stage 2
7
output nodes = left view(angle tree)
8
for k â†0 to nqubits âˆ’1 do
9
output qubits[k] = output nodes[k].qubit
10
return output qubits
104

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
25
Pseudocode 7: Generate a sparse state tree by the decomposition
of an sparse amplitude input vector
1 sparse state decomposition(nqubits, data):
input : Number of qubits (nqubits) required to generate a state
with the same length as the data vector (2nqubits).
input : A list (data) representing the state to be decomposed,
with exactly 2nqubits pairs (index, amplitude).
output: Root of the state tree.
// Initialize an auxiliary vector new nodes with data
vector amplitudes
2
new nodes = []
3
for k â†0 to length(data) âˆ’1 do
4
node.index = data[k].index
5
node.level = nqubits
6
node.amplitude = data[k].amplitude
7
new nodes[k] = node
// Build the state tree
8
for level â†nqubits to 1 step âˆ’1 do
9
nodes = new nodes
10
new nodes = []
11
for k â†0 to length(nodes) âˆ’1 step 2 do
12
node.index = nodes[k].index // 2
13
node.level = level
14
mag = |nodes[k].amplitude|
15
arg = (âˆ nodes[k].amplitude)/2
16
if nodes[k].index%2 == 1 then
17
node.left = null
18
node.right = nodes[k]
19
k = k - 1
20
else if (k + 1) < length(nodes) & nodes[k + 1].index ==
nodes[k].index + 1 then
21
mag =
q
|nodes[k].amplitude|2 + |nodes[k+1].amplitude|2
22
arg = (âˆ nodes[k].amplitude+âˆ nodes[k+1].amplitude)/2
23
node.left = nodes[k]
24
node.right = nodes[k+1]
25
else
26
node.left = nodes[k]
27
node.right = null
28
k = k - 1
29
node.amplitude = mag Ã— exp(1j Ã— arg)
30
new nodes.append(node)
31
return new nodes[0] ;
// return tree root
105

Springer Nature 2021 LATEX template
26
Configurable sublinear circuits for quantum state preparation
References
[1] Feynman, R.P.: Simulating physics with computers. International Journal
of Theoretical Physics 21(6-7), 467â€“488 (1982)
[2] Deutsch, D., Jozsa, R.: Rapid solution of problems by quantum computa-
tion. Proceedings of the Royal Society of London. Series A: Mathematical
and Physical Sciences 439(1907), 553â€“558 (1992)
[3] Grover, L.K.: A fast quantum mechanical algorithm for database search.
In: Proceedings of the Twenty-eighth Annual ACM Symposium on The-
ory of Computing. STOC â€™96, pp. 212â€“219. Association for Computing
Machinery, Philadelphia, Pennsylvania, USA (1996)
[4] Simon, D.R.: On the Power of Quantum Computation. SIAM Journal on
Computing 26(5), 1474â€“1483 (1997)
[5] Shor, P.W.: Polynomial-Time Algorithms for Prime Factorization and
Discrete Logarithms on a Quantum Computer. SIAM Review 41(2),
303â€“332 (1999)
[6] Aaronson, S.: Read the fine print. Nature Physics 11(4), 291â€“293 (2015)
[7] Biamonte, J., Wittek, P., Pancotti, N., Rebentrost, P., Wiebe, N., Lloyd,
S.: Quantum machine learning. Nature 549(7671), 195â€“202 (2017)
[8] Leymann, F., Barzen, J.: The bitter truth about gate-based quantum algo-
rithms in the NISQ era. Quantum Science and Technology 5(4), 044007
(2020)
[9] Tang, E.: Quantum principal component analysis only achieves an expo-
nential speedup because of its state preparation assumptions. Phys. Rev.
Lett. 127, 060503 (2021)
[10] Shende, V.V., Bullock, S.S., Markov, I.L.: Synthesis of quantum-logic
circuits. IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems 25(6), 1000â€“1010 (2006)
[11] Hogg, T., Huberman, B.A., Williams, C.P.: Phase transitions and the
search problem. Artificial Intelligence 81(1), 1â€“15 (1996). Frontiers in
Problem Solving: Phase Transitions and Complexity
[12] Terhal, B.M., Smolin, J.A.: Single quantum querying of a database.
Physical Review A 58(3), 1822â€“1826 (1998)
[13] Harrow, A.W., Hassidim, A., Lloyd, S.: Quantum algorithm for linear
systems of equations. Phys. Rev. Lett. 103, 150502 (2009)
106

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
27
[14] Grover, L.K.: Synthesis of Quantum Superpositions by Quantum Com-
putation. Physical Review Letters 85(6), 1334â€“1337 (2000)
[15] Sanders, Y.R., Low, G.H., Scherer, A., Berry, D.W.: Black-box quan-
tum state preparation without arithmetic. Phys. Rev. Lett. 122, 020502
(2019)
[16] Wang, S., Wang, Z., Cui, G., Shi, S., Shang, R., Fan, L., Li, W., Wei,
Z., Gu, Y.: Fast black-box quantum state preparation based on linear
combination of unitaries. Quantum Information Processing 20(8), 270
(2021)
[17] Trugenberger, C.A.: Probabilistic quantum memories. Physical Review
Letters 87(6) (2001)
[18] Ventura, D., Martinez, T.: Quantum associative memory. Information
Sciences 124(1), 273â€“296 (2000)
[19] Trugenberger, C.A.: Quantum Pattern Recognition. Quantum Informa-
tion Processing 1(6), 471â€“493 (2002)
[20] Giovannetti, V., Lloyd, S., Maccone, L.: Quantum random access memory.
Phys. Rev. Lett. 100, 160501 (2008)
[21] Silva, A., Oliveira, W.d., Ludermir, T.: A Weightless Neural Node Based
on a Probabilistic Quantum Memory. In: 2010 Eleventh Brazilian Sympo-
sium on Neural Networks, pp. 259â€“264. IEEE, Sao Paulo, Brazil (2010).
ISSN: 2375-0235
[22] de Paula Neto, F.M., da Silva, A.J., de Oliveira, W.R., Ludermir, T.B.:
Quantum probabilistic associative memory architecture. Neurocomputing
351, 101â€“110 (2019)
[23] Park, D.K., Petruccione, F., Rhee, J.-K.K.: Circuit-Based Quantum Ran-
dom Access Memory for Classical Data. Scientific Reports 9(1), 3949
(2019)
[24] Zidan, M., Abdel-Aty, A.-H., Khalil, A., Abdel-Aty, M., Eleuch, H.: A
novel efficient quantum random access memory. IEEE Access 9, 151775â€“
151780 (2021)
[25] Lloyd, S., Mohseni, M., Rebentrost, P.: Quantum algorithms for super-
vised and unsupervised machine learning. arXiv:1307.0411 [quant-ph]
(2013)
[26] Stoudenmire, E., Schwab, D.J.: Supervised learning with tensor networks.
In: Lee, D., Sugiyama, M., Luxburg, U., Guyon, I., Garnett, R. (eds.)
107

Springer Nature 2021 LATEX template
28
Configurable sublinear circuits for quantum state preparation
Advances in Neural Information Processing Systems, vol. 29, p. 9. Curran
Associates, Inc., Centre Convencions Internacional Barcelona, Barcelona
Spain (2016)
[27] Schuld, M., Fingerhuth, M., Petruccione, F.: Implementing a distance-
based classifier with a quantum interference circuit. EPL (Europhysics
Letters) 119(6), 60002 (2017)
[28] Schuld, M., Petruccione, F.: Supervised Learning with Quantum Comput-
ers, 1st ed. 2018 edn. Quantum Science and Technology. Springer, Cham
(2018)
[29] Benedetti, M., Lloyd, E., Sack, S., Fiorentini, M.: Parameterized quantum
circuits as machine learning models. Quantum Science and Technology
(2019)
[30] Levine, Y., Sharir, O., Cohen, N., Shashua, A.: Quantum Entanglement
in Deep Learning Architectures. Physical Review Letters 122(6), 065301
(2019)
[31] Blank, C., Park, D.K., Rhee, J.-K.K., Petruccione, F.: Quantum classifier
with tailored quantum kernel. npj Quantum Information 6(1), 1â€“7 (2020)
[32] Lloyd, S., Mohseni, M., Rebentrost, P.: Quantum principal component
analysis. Nature Physics 10(9), 631â€“633 (2014)
[33] Childs, A.M., Kothari, R., Somma, R.D.: Quantum algorithm for systems
of linear equations with exponentially improved dependence on precision.
SIAM Journal on Computing 46(6), 1920â€“1950 (2017)
[34] Wossnig, L., Zhao, Z., Prakash, A.: Quantum linear system algorithm for
dense matrices. Phys. Rev. Lett. 120, 050502 (2018)
[35] Rebentrost, P., Steffens, A., Marvian, I., Lloyd, S.: Quantum singular-
value decomposition of nonsparse low-rank matrices. Physical Review A
97(1) (2018)
[36] Mitchell, T.M.: Machine Learning, Nachdr. edn. McGraw-Hill series in
Computer Science. McGraw-Hill, New York (2013)
[37] Ventura, D., Martinez, T.: Initializing the Amplitude Distribution of a
Quantum State. Foundations of Physics Letters 12(6), 547â€“559 (1999)
[38] Long, G.-L., Sun, Y.: Efficient scheme for initializing a quantum register
with an arbitrary superposed state. Physical Review A 64(1), 014303
(2001)
108

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
29
[39] Mottonen, M., Vartiainen, J.J., Bergholm, V., Salomaa, M.M.: Trans-
formation of Quantum States Using Uniformly Controlled Rotations.
Quantum Info. Comput. 5(6), 467â€“473 (2005)
[40] Plesch, M., Brukner, C.: Quantum-state preparation with universal gate
decompositions. Physical Review A 83(3), 032302 (2011)
[41] Cortese, J.A., Braje, T.M.: Loading Classical Data into a Quantum
Computer (2018)
[42] Araujo, I.F., Park, D.K., Petruccione, F., da Silva, A.J.: A divide-and-
conquer algorithm for quantum state preparation. Scientific Reports
11(1), 6329 (2021)
[43] Park, D.K., Sinayskiy, I., Fingerhuth, M., Petruccione, F., Rhee, J.-
K.K.: Parallel quantum trajectories via forking for sampling without
redundancy. New Journal of Physics 21(8), 083024 (2019)
[44] Low, G.H., Kliuchnikov, V., Schaeffer, L.: Trading T-gates for dirty qubits
in state preparation and unitary synthesis (2018)
[45] Zoufal, C., Lucchi, A., Woerner, S.: Quantum generative adversarial
networks for learning and loading random distributions. npj Quantum
Information 5(1), 1â€“9 (2019)
[46] Kuzmin, V.V., Silvi, P.: Variational quantum state preparation via
quantum data buses. Quantum 4, 290 (2020)
[47] IBM: IBMâ€™s Roadmap For Scaling Quantum Technology (2020). https:
//research.ibm.com/blog/ibm-quantum-roadmap
[48] Preskill, J.: Quantum Computing in the NISQ era and beyond. Quantum
2, 79 (2018)
[49] Aleksandrowicz, G., et al.: Qiskit: An Open-source Framework for Quan-
tum Computing (2021)
[50] Bergholm, V., Izaac, J., Schuld, M., Gogolin, C., Alam, M.S., Ahmed,
S., Arrazola, J.M., Blank, C., Delgado, A., Jahangiri, S., McKiernan,
K., Meyer, J.J., Niu, Z., SzÂ´ava, A., Killoran, N.: PennyLane: Automatic
differentiation of hybrid quantum-classical computations (2020)
[51] Bergholm, V., Vartiainen, J.J., MÂ¨ottÂ¨onen, M., Salomaa, M.M.: Quantum
circuits with uniformly controlled one-qubit gates. Physical Review A
71(5), 052330 (2005)
109

Approximated quantum-state preparation with entanglement dependent complexity
Israel F. Araujo,1, âˆ—Carsten Blank,2, â€  Ismael Cesar,1, â€¡ and Adenilton J. da Silva1, Â§
1Centro de InformÃ¡tica, Universidade Federal de Pernambuco, 50740-560, Recife, Pernambuco, Brazil
2data cybernetics, 86899, Landsberg am Lech, Germany
Ubiquitous in quantum computing is the step to encode data into a quantum state. This process
is called quantum state preparation, and its complexity for non-structured data is exponential
on the number of qubits. Several works address this problem, for instance, by using variational
methods that train a fixed depth circuit with manageable complexity. These methods have their
limitations as the lack of a back-propagation technique and barren plateaus. This work proposes
an algorithm to reduce state preparation circuit depth by offloading computational complexity to
a classical computer.
The initialized quantum state can be exact or an approximation, and we
show that the approximation is better on todayâ€™s quantum processors than the initialization of the
original state.
We verified through experimental evaluation that the proposed method allows a
more efficient initialization of distributions in a quantum state and approximate loading images for
quantum machine learning tasks.
I.
INTRODUCTION
Quantum devices can execute information process-
ing tasks that classical computers cannot perform effi-
ciently [1].
In some instances, this leads to exponen-
tial advantages in the solution of systems of linear equa-
tions [2] and principal component analysis [3]. Addition-
ally, there are known advantages in Monte-Carlo sam-
pling [4, 5] in which a squared increase of convergence can
be attained. Furthermore, quantum machine learning ap-
plications [6â€“8] may exhibit heuristic advantages. For all
these applications, the initialization of a n-qubit quan-
tum state, commonly called quantum state preparation
or initialization, see Fig.1, is an important step in quan-
tum information processing. Encoding a N-dimensional
(complex) vector requires n-qubits with N = 2n and
quantum circuits with O(2n) controlled-NOT (CNOT)
gates [9, 10]; these gates are the building blocks of to-
dayâ€™s quantum computers. Therefore, several works fo-
cus on the development of algorithms that supposes data-
efficient initialization, as all above-mentioned quantum
advantages could be undone when the conversion of clas-
sical data to quantum data becomes a bottleneck.
There are several quantum state preparation algo-
rithms [11â€“14] with a lower bound of O(2n) CNOT gates
to prepare an arbitrary quantum state with n qubits.
Attempts to prepare quantum states more efficiently in-
clude a divide-and-conquer strategy that exchanges cir-
cuit depth by circuit width [14, 15], probabilistic ap-
proaches [16, 17], and strategies to initialize approxi-
mated quantum states [18â€“20]. Most recently, there are
methods that focus on specific classes of quantum states.
For instance, how to prepare uniform [21], sparse [13] or
probability distribution [18] states. However, there is no
âˆ—ifa@cin.ufpe.br
â€  blank@data-cybernetics.com
â€¡ icsa@cin.ufpe.br
Â§ ajsilva@cin.ufpe.br
clear understanding of which classes of quantum states
can be created efficiently.
0100110101101010101010010111
0101101010001001010101110100
0101000010100010110101001010
0101000011110101101010100101
1111011010100111001011110110
0101001000100010110111011110
0101000011110101101010100101
1111011010100111001011110110
1111011010100111001011110110
Classical Data
Quantum Circuit
Translation
Quantum State
FIG. 1: The process of state preparation or
initialization. Classical data is converted into vector
form and a translation process encodes the information
in operations performed on the quantum computer,
commonly encoded by a circuit. Executing this circuit
creates the initial state |Î¨0âŸ©.
Entanglement is one of the quantum resources that
allow the development of more efficient algorithms and
protocols. Its relationship to the algorithmic complex-
ity of a quantum state has been demonstrated in previ-
ous work [22, 23] and plays a key role in many quantum
applications, such as quantum communication, quantum
error correction, and quantum secret sharing [24â€“29].
However, the circuit complexity of current algorithms
to create a quantum state do not consider the resource of
entanglement. The main goal of this article is to define
a deterministic state preparation algorithm that creates
circuits with depth as a function of entanglement, and
show that for mapping the classical data into a Noisy
Intermidiate-Scale Quantum (NISQ) device, one indeed
wants to be in the regime of low-entanglement.
Af-
ter finalizing the state preparation, one can increase the
amount of entanglement (exponential in the number of
qubits) by applying unitary evolution. This path could
lead to the solution of the so-called loading problem (LP)
of classical-quantum information processing.
The proposed approachâ€™s advantage is that it can accel-
erate quantum applications that require the initialization
of quantum states, in particular on noisy devices. Using
110
APÃŠNDICE C â€“ APPROXIMATED QUANTUM-STATE PREPARATION WITH
ENTANGLEMENT DEPENDENT COMPLEXITY

2
an approximation of the quantum state, the result is that
the error introduced by the approximation is smaller than
the error to encode the original state. The fundamental
cause of this behavior is the difference in the number
of noisy operations necessary between the circuits to en-
code the original versus the approximate state. But also
apart from this obvious advantages in the NISQ-era, the
proposed approach reduces the complexity to initialize a
low-entangled quantum state into fault-tolerant quantum
devices.
The remainder of this paper is organized into four sec-
tions. The main contributions of this work are described
in sections II and III. Section II introduces the Low-Rank
State Preparation (LRSP) algorithm, a modification of
the so-called Plesch and Brukner (PB) algorithm [12].
LRSP algorithm reduces the computational cost when
the input vector has a low Schmidt coefficient. In this
way, the LRSP can be used to initialize general quantum
states and also low rank quantum states.
Section III
introduces the Bounded Approximation Error Algorithm
(BAA), a search algorithm that reduces the circuit depth
of LRSP circuit given an allowable error. Some numer-
ical tools and the connection to the geometric measure
of entanglement are discussed. Section IV presents ex-
perimental results on how probability distributions can
effectively be created and read out from actual pre-NISQ
processors. Also, it shows how an end-to-end quantum
machine learning approach can be improved through ap-
proximations of the initial quantum state.
Section V
summarizes the work and presents perspectives along
with potential future research.
II.
LOW-RANK STATE PREPARATION
ALGORITHM
The proposed Low-Rank State Preparation algorithm
is based on
Plesch and Brukner (PB) state prepara-
tion algorithm [12]. The PB algorithm connects to the
Schmidt-decomposition, given a quantum state |ÏˆâŸ©=
P
j Î»j |jâŸ©, the first step of the algorithm runs a Schmidt
decomposition
|ÏˆâŸ©=
k
X
i=1
Ïƒi |iAâŸ©|iBâŸ©
(1)
where the state is factored in two quantum subsystems
HA and HB, values Ïƒi are the Schmidt coefficients,
{|iAâŸ©} âˆˆHA and {|iBâŸ©} âˆˆHB are orthonormal ba-
sis, and 1 â‰¤i â‰¤min(dim(HA), dim(HB)).
The sec-
ond step performs the initialization of the quantum state
P
i Ïƒi |iâŸ©|0âŸ©in the first quantum register. The objective
of this step is to initialize a state with the Schmidt coef-
ficients. The third step applies âŒŠn/2âŒ‹CNOTs to create
the state P
i Ïƒi |iâŸ©|iâŸ©. Let U and V be unitaries, where
U |iâŸ©= |iAâŸ©and V T |iâŸ©= |iBâŸ©. The last step of the algo-
rithm applies U in the first register and V T in the second
register. A quick review of the algorithm is schematically
shown in Fig. 2d.
The proposed Low-Rank State Preparation
differs
from PB algorithm when the Schmidt measure m =
âŒˆlog2(k)âŒ‰< âŒŠn/2âŒ‹and also by the use of isometries. The-
orem 1 establishes the CNOT gates count needed when
a low-rank representation of a state can be found using
the Schmidt decomposition, as well as approximating the
state by truncating the Schmidt coefficients.
Theorem
1
(Low-Rank State Preparation). Given
Eqn. (1) with the Schmidt measure m = âŒˆlog2(k)âŒ‰the
low-rank state preparation has a complexity of
condition
CNOT count
0 â‰¤m < nA
O(2m+nB)
m = nA
O(2n)
Proof. Let |ÏˆâŸ©be a n-qubit quantum state with Schmidt
decomposition |ÏˆâŸ©= Pk
i=1 Ïƒi |iAâŸ©|iBâŸ©where subsystem
HA has nA qubits (1 â‰¤nA â‰¤âŒŠn/2âŒ‹), subsystem HB
has nB = n âˆ’nA qubits and k is the Schmidt rank (also
known as Schmidt number).
If the Schmidt measure is m = âŒˆlog2(k)âŒ‰< nA, the
operator S (Fig. 2a) initializes a state with m qubits
in phase 1 (Fig. 2b and Fig 2c), instead of nA qubits
(Fig. 2d). The second phase requires m CNOT gates, as
they are not needed where the control qubit is |0âŸ©. In
this circuit configuration, m is the Schmidt measure and
quantifies the entanglement between subsystems HA and
HB. Finally, in phases 3 and 4, the matrices U and V T
are isometries 2mâ€“toâ€“2nA and 2mâ€“toâ€“2nB which require
O(2m+nA) and O(2m+nB) CNOTs.
The number of CNOTs of the complete LRSP circuit
is O(2m+nB) because the cost of the isometry V T (phase
4) dominates the cost of the algorithm (nB â‰¥nA). The
best-case occurs when the bipartition is not entangled
|ÏˆâŸ©= |ÏˆAâŸ©|ÏˆBâŸ©. Therefore, if rank = 1 (m = 0 e-bits)
there are no operations in phase 1 (to encode singular
values), no entanglement between the two subsystems in
phase 2 (since there is 0 e-bits between the subsystems),
and there are one 1â€“toâ€“2nA and one 1â€“toâ€“2nB isometries
in phases 3 and 4 (Fig. 2b) (which is equivalent to two
parallel sub-state preparations in nA and nB qubits). If
all qubits of the state are separable, applying recursively
the same algorithm to prepare the sub-states in phases
3 and 4 generates a circuit without CNOT gates. If the
state is initially separable but not all sub-states of the
recurrence (some qubits are not separable), the cost of
the state preparation is O(2ne), where ne is the number of
qubits of the higher entangled subsystem. The worst case
occurs when m = nA, recovering the O(2n) complexity
of the original PB circuit (Fig. 2).
In the best case (separable states), the LRSP algo-
rithm creates circuits with a constant depth.
In the
worst case, the LRSP algorithm creates circuits with
depth O(2n) and is a competitive algorithm compared
with the state-of-art deterministic state preparation al-
gorithms for general state preparation without auxiliary
111

3
phase 1
phase 2
phase 3
phase 4
|0âŸ©0
S
T
U
|0âŸ©1
|0âŸ©2
V T
|0âŸ©3
control
target
(a) Block diagram
phase 1
phase 2
phase 3
phase 4
|0âŸ©0
Isometry U4Ã—1
|0âŸ©1
|0âŸ©2
Isometry V T
4Ã—1
|0âŸ©3
(b) m = 0
phase 1
phase 2
phase 3
phase 4
|0âŸ©0
Ry(Î±0)
Isometry U4Ã—2
|0âŸ©1
|0âŸ©2
Isometry V T
4Ã—2
|0âŸ©3
(c) m = 1
phase 1
phase 2
phase 3
phase 4
|0âŸ©0
Ry(Î±0)
Unitary U4Ã—4
|0âŸ©1
Ry(Î±1)
Ry(Î±2)
|0âŸ©2
Unitary V T
4Ã—4
|0âŸ©3
(d) m = 2
FIG. 2: Schematics of the low-rank approximation algorithm (n = 4 and subsystem HA = {0, 1}). (a) Block diagram
circuit. Operator S is responsible for encoding 2nA (nA = n/2) SVD singular values. In this example, operator S
encodes a maximum of four amplitudes (two qubits). Operator T is a sequence of CNOTs, controlled by the first
half of qubits and targeting the second half (one by one). Operators U and V are the two SVD unitaries. For
full-rank (m = nA, in units of e-bits), U and V T are encoded as unitaries of dimension 2nA Ã— 2nA. For a lower rank
(m < nA), the operators are encoded as isometries of dimension 2nA Ã— 2m. When m = 0 (rank = 1), the isometries
of dimension 2nA Ã— 1 are equivalent to amplitude encoding with input vectors of length 2nA. Pleschâ€™s original work
describes the four individual phases. (b)(c)(d) Detailed views of (a) for rank = 1 (m = 0), rank = 2 (m = 1) and
rank = 4 (full-rank, m = 2). In this example, phase 1 uses MÃ¶ttÃ¶nenâ€™s state preparation but could use any
amplitude encoding algorithm, including the low-rank state preparation algorithm.
qubits. Table I compares LRSP circuit depth and number
of CNOTs with previous state preparation algorithms.
Two experiments were performed. Column (Ent.) shows
results for a random 10-qubit quantum state initializa-
tion, and column (Sep.) for a random separable 10-qubit
quantum state. The LRSP results depend on the choice
of unitary and isometry decompositions. The methods
used are Quantum Shannon Decomposition (QSD) for
unitaries [30], Cosineâ€“Sine Decomposition (CSD) [31] for
2nâˆ’1â€“toâ€“2n isometries, and Columnâ€“byâ€“Column Decom-
position (CCD) for other isometries [31].
A.
Low-Rank Approximation
The LRSP algorithm also allows a low-rank approx-
imation limiting the Schmidt rank in exchange for an
error. The fidelity loss can be used to quantify the loss
by the approximation.
Definition 1. Given the low-rank parameter r, the ap-
Method
Script
Ent.
Sep.
CNOTs Depth CNOTs Depth
Low Rank
[32]
915
1047
0
2
PB [12]
[32]
919
1057
919
1058
Isometry [31]
[33]
1013
4055
1013
3871
Multiplexor [30]
[33]
2026
4064
2026
4064
TABLE I: Depth and number of CNOTs comparison
between LRSP and other state preparation algorithms.
Experiments were performed without circuit
optimization.
proximated state is denoted as
Ïˆ(r)E
=
r
X
i=1
Ïƒi |iAâŸ©|iBâŸ©
(2)
with coefficients for 1 â‰¤r â‰¤k, i.e. Ïƒj = 0, r < j â‰¤k.
With the LRSP algorithm, it is possible to partially
(r > 1) or completely (r = 1) disentangle subsets
112

4
2
3
4
5
6
7
8
1
3
4
7
1
5
6
8
2
FIG. 3: Schematic of the logical swap of qubits. By
rearranging the qubits it is possible to find a bipartition
such that the bond dimension between the partitions is
small, which means that these partitions are not
strongly entangled. The indices indicate the position of
the qubit in the quantum circuit.
of qubits while the introduced fidelity loss l(r, |ÏˆâŸ©) :=
(1 âˆ’|âŸ¨Ïˆ, Ïˆ(r)âŸ©|2) = Pk
i=r+1 |Ïƒi|2 scales with the Schmidt
coefficients that are dropped. The possibility of allowing
arbitrary bipartitions â€“ with not-necessarily connected
qubits â€“ is not as readily obvious. By rearranging sites
(Fig. 3) between partitions of any size within the allowed
range (1 â‰¤nA â‰¤âŒŠn/2âŒ‹and nB = n âˆ’nA), one can find
the configuration that exhibit a low bond-dimension at
some boundary. It is then possible to approximate with
lower error, potentially disentangling these bipartitions.
One then can recursively apply this approach on the two
resulting partitions separately; a search algorithm with
a given maximal approximation error can then find the
optimal approximation of an arbitrary quantum state.
This Bounded Approximation error Algorithm (BAA) is
applicable to any quantum state of interest, including,
for example, vector encoding for inverting matrices using
HHL [3], loading data into a quantum machine learning
model [6, 7] or using quantum simulation of stochastic
processes [34].
III.
BOUNDED APPROXIMATION
ALGORITHM
By design, the low-rank approximation only applies to
bipartite systems, yet it can be used hierarchically to en-
able the analysis of multipartite quantum systems [35]
by a recursive algorithm. The proposed search algorithm
allows an approximation up to a given error bound lmax â€“
if possible â€“ and thus saves the use of CNOT gates while
providing a guarantee of proximity to the original state.
It is a bounded approximation error state preparation
algorithm (BAA) that potentially has a classical expo-
nential run-time with respect to the number of qubits
of the state. As it is a branch-and-bound algorithm us-
ing breadth-first search, the complexity usually converges
faster [36, 37]. The full set of pseudocode which describes
the algorithm is printed in the supplementary informa-
tion. In what follows, we want to outline the core prin-
ciples of the algorithm.
The approximate state preparation algorithm works as
follows. Any (pure) n-qubit quantum state |ÏˆâŸ©will allow
for a total of
B(n) =
âŒŠn/2âŒ‹
X
t=1
 
n
t
!
(3)
bipartitions (also called branches), each is written as
b âˆˆ[1 . . B(n)] with the Schmidt number bounded by
k(b) = min{dim(Hb
1), dim(Hb
2)}. By letting the low-rank
parameter 1 â‰¤r â‰¤k(b) be r = 1, each bipartition cre-
ates a disentangled pair of smaller states. Combining this
pair by the tensor-product returns an approximation of
the original state. Additionally, it is possible by the com-
plexity analysis of Theorem 1 to predict the number of
CNOT gates saved.
Starting from |ÏˆâŸ©âˆˆH, the algorithm is branching into
all possible bipartitions, (Hb
1, Hb
2). Recursively, each par-
tition Hb
i can in turn be branched once again, as long as
Hb
i (i = 1, 2) is not one single qubit or the total fidelity
loss has not exceeded the error bound lmax. In order for
the search-algorithm to work, each node needs to be able
to know the total fidelity loss, the total saved number of
CNOT gates and its partitioned Hilbert spaces. Due to
this structure, the algorithm terminates in the worst case
with an exponential number of steps. These mentioned
properties are summarized.
Lemma 1. The fidelity and the saved CNOT gates of
each branch can be recursively calculated.
A small result with an impact is the fact that the fi-
delity/fidelity loss and CNOT gate savings can be recur-
sively calculated from one branch to another. The lemma
is important for the computation of the search tree in the
BAA algorithm, as it is possible to parallelize it.
Proof. One must show that the total fidelity loss over
several steps in the tree can be recursively calculated. Let
lbp and lbc be the fidelity loss of the parent and child node,
respectively. Then the fidelity of both is (1âˆ’lbp)(1âˆ’lbc),
hence ltot = 1 âˆ’(1 âˆ’lbp)(1 âˆ’lbc). More generally, ltot =
1 âˆ’Q
i(1 âˆ’lbi) for a path on the tree b1, . . . , bt.
Proposition 2. The BAA-Algorithmâ€™s search tree has
n levels, and therefore terminates. The time and space
complexity is exponential in n in its worst case.
When spanning the search tree (see Suppl. Informa-
tion Pseudocode 1), each child of a parent node will be
created by choosing exactly one state and doing exactly
one bipartition. The bipartitions of our focus are the t
qubits vs. the rest ones, where t is defined in Eq. (3).
Say, among the k states of the parent node, #1 is se-
lected to be partitioned, with dim(H1) = n1. The split
113

5
node 6
node 5
node 0
0.3
0.1
0.2
3
1
2
fidelity loss
saved CNOT gates
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
node 1
node 2
node 3
node 4
1
2
3
1
2
3
1
2
3
3
2
1
1
2
3
1
2
3
3
2
1
FIG. 4: An example of a three-qubit state that is disentangled into product states (leaves). It starts with one vector
in the root and then all B(3) = 3 bipartitions are branched off, creating each two states. From there, the larger
subspace has two qubits, so it should have B(2) = 2 branches. But in this case, the second branch is equal to the
complement of the first, so it is redundant and omitted. Each node has a fidelity loss (red column) and the number
of CNOT gates saved (blue column) using the proposed algorithm. The sub-indices of the vectors are the qubit
partitions associated with each state. Adding the weights from root to any leaf gives the total fidelity loss of
â‰ˆ0.307, meaning that the reduced product state to its original state have an overlap of â‰ˆ0.693, but with a saving
of 4 CNOT gates. The adaptive approximation algorithm goes to ask if we can save some CNOT gates with an
acceptable fidelity loss. If lmax = 0.1, there is the second bipartition from the root node (node 2) that introduces
only a fidelity loss of â‰ˆ0.058 by simultaneously saving three CNOT gates.
of t qubits vs. rest is done, and in this manner n1 âˆ’1 lev-
els will be traversed until this state has been partitioned
to a tensor product of single qubit states. Meanwhile, all
k âˆ’1 original states were kept as they were. Now the
partition #2 is selected, and in turn takes n2 âˆ’1 steps
to a tensor product of single qubit states. This goes on
with all the remaining k âˆ’2 partitions. So in total, there
are
k
X
l=1
(nl âˆ’1) = n âˆ’k
(4)
steps until all k partitions have been partitioned into
tensor products of single qubit Hilbert spaces. As this
is the longest path possible, the BAA algorithm termi-
nates. Now, we show the runtime complexity of the BAA
algorithm.
Lemma 2. Given a k-fold partitioning of H, denotes as
(H1, . . . , Hk), the number of children of this node is
Bk(n) =
k
X
i=1
B(dim Hi)
(5)
As a special case, we see k = 1, which is directly
B(dim H).
Proof. Given k already partitioned subspaces, the search
algorithm selects one of the partitions (Hi, i = 1, . . . , k)
and carries out all B(dim Hi) branches, while leaving all
the other k âˆ’1 original partitions intact. This is then
repeated, so the total number of children this node has
as claimed.
After each step, the number of partitions thus changes
from k 7â†’k + 1 as one partition is created. Of course,
the sum of all dimensions must be equal to the dimension
of the original Hilbert space n. Thus, each level of the
search tree is identified by the number k of partitions.
The maximum number of levels is therefore always n.
The total number of nodes is then computed as follows.
The
first level
has
exactly
1
node.
The
sec-
ond
level
has
B1(n)
nodes.
The
third
level
has
P
b=1...B1(n) B2(n; b)
and
the
fourth
level
P
b1=1...B1(n)
P
b2=1...B2(n;b1) B3(n; b2)
up
until
the
nth level, we have,
B1(n)
X
b1=1
Â· Â· Â·
Bnâˆ’1(n;bnâˆ’2)
X
bnâˆ’1=1
Bn(n; bnâˆ’1)
(6)
This is clearly exponential in n. A tree of an example
three-qubit state is shown in Fig. 4. With an lmax = 0.1
only one bipartition is possible within this error bound,
and three CNOT gates are saved.
Albeit the fact that the BAA algorithm uses low-rank
approximations with r = 1 to fully disentangle the bipar-
114

6
titions (Fig. 2 and Fig. 4), it is possible to include low-
rank approximations with r > 1 when complete disentan-
glement is no longer within lmax. This allows fine-tuning
the partial disentanglement of states, as each value of
the parameter r may achieve reductions in the number
of CNOTs that would not be possible with the original
approach, producing additional branches from the tree
nodes.
Therefore, this advantage comes with a larger
search space, and increases the cost of the algorithm.
While the proposed approximate state preparation al-
gorithm reduces the quantum circuit complexity, the
BAA has an exponential preprocessing cost. The naive
(â€œbrute-forceâ€ breadth-first) algorithm is already a solu-
tion for those researchers who need to work on small-
qubit experiments and currently have no alternatives to
an efficient quantum initialization on noisy devices. But
a scalable workaround is necessary. One way is to use a
greedy approach [38, 39] that seeks to reduce the compu-
tational cost, making BAA a useful solution for general
problems.
The greedy strategy proposes that branching from a
node is limited to a qubit-by-qubit analysis, selecting
only one representative of the partitions of size k where
1 â‰¤k â‰¤âŒŠn/2âŒ‹. The increment in the partition size is
done by choosing the qubit with the lowest fidelity loss
when removed from the remaining entangled subsystem.
As an example, on a seven qubit state, the best 1 vs. 6,
2 vs. 5 and 3 vs. 4 bipartitions are attempted, and the
best one is selected locally and then propagated in the
recursion. This approach implies an exponential reduc-
tion in the number of bipartition combinations, of which
one is chosen, producing only one path.
The greedy algorithm reduces the search-problem ex-
ponentially, yet this will necessarily reduce its ability to
find a good CNOT reduction. The advantage over the
breadth-first (brute-force) strategy is that it will never
exceed the approximation configured, but the downside is
that the CNOT complexity to attain this approximation
could be far from optimal. We use seven qubit random
circuits [40] of linear depth to generate 1000 quantum
states and apply different strategies and lmax to them. It
is obvious that the greedy strategy performs less well for
low lmax (Fig. 5).
Regarding the approximation quality, both the greedy
and brute-force approaches find approximations that to
each other scatter quite evenly, if lmax is high, this scat-
tering is less pronounced. The search of the best node
will always reject a solution that exceeds the lmax value
and it is always helpful to reduce the fidelity loss, but the
cost of CNOT gates will outgrow the impact on NISQ de-
vices. We can conclude on this survey that the greedy
algorithm will miss optimality for low lmax.
A.
Product State Approximations
In view of treating quantum state approximation, one
could be naturally inclined to ask for the best product
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
brute-force fidelity loss
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
greedy fidelity loss
0
15 30 45 60 75 90 105120135150
brute-force saved CNOTs
0
15
30
45
60
75
90
105
120
135
150
greedy saved CNOTs
0.2
0.4
0.6
0.8
1.0
lmax
0.2
0.4
0.6
0.8
1.0
lmax
FIG. 5: Difference of greedy strategy saved CNOT
gates compared to the brute-force search algorithm
(BAA). The mean difference is an indicator how
effective an approximation really is, and the lower the
difference, the better. The greedy algorithm fares
relatively well when the maximum fidelity is large, but
introduces large inefficiencies when it is low. The most
significant applications are most likely the low loss
regimes, so that the greedy algorithm will need
improvements. The data was created on a simulation
with 1000 randomly initialized states of seven qubits.
state approximation. This is indeed a measure for en-
tanglement, the so-called geometric measure of entangle-
ment. It was first introduced by Shimony [41] and refined
by Barnum & Linden [42]. The definition for this mea-
sure of entanglement is given by
Eg(|ÏˆâŸ©) = min
|Ï•âŸ©âˆ¥|ÏˆâŸ©âˆ’|Ï•âŸ©âˆ¥
(7)
where the minimization is over all states |Ï•âŸ©that are
product states [35], i.e., |Ï•âŸ©= âŠ—n
l=1
Ï•l
with each
Ï•l
being a local state. That this value is a useful measure
of entanglement was shown by Wei et al. [43], it is an
entanglement monotone.
The geometric measure of entanglement is related to
the bounded approximate algorithm (BAA) in the fol-
lowing way. Theoretically, the greatest fidelity loss that
any quantum state can experience under the BAA should
115

7
never be higher than it.
Therefore, the geometric en-
tanglement indicates how far an approximation can get.
This shows that low-entanglement states can be encoded
with little loss as a product state. However, looking at
the BAA algorithm, the sequence of nested SVDs is not
optimal, and there may be resulting product states with
a higher fidelity loss.
The particular case where the BAA partitions are split
in half and only one branch selected is equivalent to the
Hierarchical Tucker Format (HTF) with a binary dimen-
sion tree (called Canonical Dimension Tree) [44].
The
HTF can be used to estimate the maximum possible fi-
delity loss with an error less or equal to âˆš2n âˆ’3âˆ¥A âˆ’
Abestâˆ¥, where Abest is the best approximation of the ten-
sor A, and n is the dimensionality of the problem. The
number of bipartitions performed to estimate the maxi-
mum fidelity loss is linear in the number of qubits. Since
BAA performs the SVD from already truncated tensors,
the cost of HTF is given by Lemma 26 of Ref. [44].
IV.
THE LOADING PROBLEM ON NISQ
DEVICES
The LRSP algorithm (with partitions defined by the
Bounded Approximation Error Algorithm) was designed
to solve a class of problems on NISQ devices, namely
loading data. To solve (or avoid) the loading problem [6],
an approximation of the quantum state that uses less en-
tanglement is created.
In this Section we present two
applications of the LRSP: initialize i) a Probability Dis-
tribution Function ii) images to and end-to-end quantum
machine learning model. In an experimental evaluation,
the approximated circuit created with the LRSP algo-
rithm allows for improvements in both examples.
A.
Experiments on Probability Density Functions
The BAA proves to be efficient when working with
specific classes of quantum states found in the quantum
finance [13, 18, 21]. Indeed, encoding probability distri-
butions on the amplitudes of a 7-qubit quantum state
show that even a modest fidelity loss (â‰¤0.02) results in
a significant reduction in the number of CNOTs.
To encode a continuous probability density function
(PDF) into the amplitudes of a quantum state it is nec-
essary to construct its discrete analog. In general, this
construction is based on preserving one or more proper-
ties of the continuous distribution [45].
There are several methods by which a discrete random
variable can be constructed from a continuous one. Here
we employ Methodology-V described in Ref. [45] where
the cumulative distribution function (CDF) of a discrete
random variable Y maintains the form of the CDF of
a continuous random variable X. The probability mass
function (PMF) of Y is built from the CDF of X FX(x) =
Pr(X â‰¤x) and is given by
P(Y = k) = FX(k + Î´) âˆ’FX(k âˆ’[1 âˆ’Î´])
(8)
where 0 < Î´ < 1 and k = {0, 1, 2, . . . }.
In the experiments, the interval 0 â‰¤x â‰¤20 is divided
into 27 discretization points. Therefore, the distance be-
tween consecutive points is d = 20/(27 âˆ’1). By choosing
Î´ = d/2, the parameters of Eq. (8) are set to
P(Y = k) = FX(k + d/2) âˆ’FX(k âˆ’d/2)
(9)
for k = {0, d, 2d, . . . , (27 âˆ’1)d}.
Equation (9) is used to generate the discrete probabil-
ity distributions analogous to the continuous ones char-
acterized by the normal, log-normal, Laplace and semi-
circular PDFs.
distribution mean variance skewness kurtosis
normal
10.0
4.0
0.0
0.0
log-normal 3.297
18.68
6.185
110.9
Laplace
10.0
8.0
0.0
3.0
semicircular 10.0
16.0
0.0
-1.0
TABLE II: First four moments of the probability
distributions.
Each point of the discretization corresponds to an am-
plitude of the state vector. Note that, given the conser-
vation of probability, each amplitude must be the square
root of the PMF at these points. The result of the dis-
cretization is employed to constructs Figure 6 and Fig-
ure 7.
The state vectors of the distributions were encoded via
BAA and estimated by measurements on actual quantum
devices. All experiments make use of the breadth-first
search (brute force) strategy and partial disentanglement
of states enabled. Each result is an average of 10 runs
with 8192 shots each. The experiments leading to Fig-
ure 6 were performed at points lmax = {0.0, 0.02} using
device ibmq_perth, while those leading to Figure 7 were
performed at points lmax = {0.0, 0.005, 0.01, . . . , 0.055}
using devices ibmq_jakarta and ibmq_casablanca.
When preparing the original states (lmax = 0.0), the
distributions need circuits with 105, 109, 28, and 99
CNOTs, respectively. The difference between the CNOT
numbers is due to the LRSPâ€™s ability to adjust the com-
plexity of the circuit to the degree of state entanglement.
If a maximum fidelity loss of lmax = 0.02 is allowed,
the effective fidelity loss achieved by the BAA to en-
code the approximate state for each distribution is the
closest possible to lmax, i.e., 0.0089, 0.0159, 0.0081, and
0.0158. With such approximation, the BAA can encode
the first three distributions using only six CNOTs and
the semicircular with three CNOTs. This relatively low
introduced error compared to the extreme reduction of
entangling operations leads to better results in terms
of mean-absolute-error (MAE). Indeed, when executing
116

8
log-normal
normal
Laplace
semi-circular
pre-NISQ
Ideal
Original
Approximation
(a)
(b)
(c)
(d)
(e)
(f)
(g)
(h)
FIG. 6: Visualization of probability distributions encoded on the amplitudes of a 7-qubit quantum state. (a)-(d)
Ideal values of the exact (green line) and approximate (blue line) distributions. (e)-(h) Values of the exact and
approximate distributions encoded via BAA and estimated by measurements on ibm_perth device. In the actual
device, the encoding of the approximations performs closer to the ideal (black dotted line) than the exact
distribution encoding. Each result is an average of 10 runs with 8192 shots.
0.0
0.005
0.01
0.015
0.02
0.025
0.03
0.035
0.04
0.045
0.05
0.055
maximum fidelity loss
(a)
(b)
0.00
0.01
0.02 0.03
0.04 0.05
maximum fidelity loss
ibmq_jakarta
ibmq_casablanca
simulation
mean absolute error
ideal
ibmq_jakarta
FIG. 7: BAA experimental results with a 7-qubit log-normal state on two IBM quantum devices (ibmq_jakarta &
ibmq_casablanca), with a geometric entanglement of â‰ˆ0.0534. (a) Several approximations in ascending order show
that the exact state preparation fails. All subsequent approximations decrease the MAE until lmax = 0.035. After
that, it increases until the product-state (at lmax = 0.055) is reached. (b) Comparison between two devices and an
ideal simulation. The highlighted point indicates the lowest MAE achieved by the devices.
an experiment on the ibm_perth, the high number of
CNOTs to initialize the exact state obscure the probabil-
ities whereas the BAA approximation keep distribution
specific features closer to the actual distribution, see Fig-
ures 6(a)â€“6(h).
One can also load an approximate probability distri-
bution into a quantum state using Quantum Generative
Adversarial Networks (qGANs) [18]. A Generative Ad-
versarial Network [46] is a machine learning model com-
posed of a neural network pair often referred to as gener-
ator and discriminator. Discriminator and generator net-
works are trained competitively. The generator network
produces random synthetic data and the discriminator
distinguishes real and synthetic data. A preliminary ex-
periment was conducted to load a log-normal PDF into
a noisy 7-qubit quantum device. However, the frequen-
cies returned by the generator are not as approximate
to the target discretized distribution frequencies as the
117

9
0.0
2.5
5.0
7.5   10.0  12.5  15.0  17.5  20.0
0.00
0.02
0.04
0.06
0.08
0.10
fidelity=1.0
fidelity=0.6754
FIG. 8: Comparison between the ideal values of the
exact frequencies for the log-normal distribution (green
line) and the frequencies produced by qGAN using 21
CNOTs (blue line).
ones produced using the BAA method in terms of state
fidelity (See Fig. 8). The qGAN was also applied to other
distributions â€“ normal, Laplace, and semicircular. It was
found that these approximations are deviating substan-
tially from expectation, noting at this point that each
qGAN learning protocol takes about 4.5 hours on a GPU
based qiskit aer noiseless simulation. Given this context,
the low-rank state preparation method with the BAA
search provides an efficient and competitive method to
load a PDF into a noisy quantum device.
B.
Experiments on VQC
In quantum machine learning, one of the best-known
applications is to train a parameterized quantum circuit
in order to learn a decision hyperplane [47] and thus be
able to classify binary problems. In this setting, the input
data is encoded by a feature map into a quantum state.
Havlicek et al. [47] have hypothesized that their feature
map has quantum advantage properties, yet any feature
map, including a regular state preparation [12, 30, 48], is
a valid option.
These experiments evaluate the BAA using brute-force
strategy and partial disentanglement of states as a quan-
tum feature map [47] to encode data in the amplitudes
of an entangled state [12, 30, 48].
The accuracy of a
quantum variational classifier (VQC) [47, 49] is used as
a metric to evaluate the state preparation.
The classifier model is a hardware efficient param-
eterized circuit divided into two layers that form a
block [47, 50, 51].
The first layer contains parameter-
ized single qubit rotation gates, followed by the second
with two-qubit entangling gates.
Usually, the block is
repeated to achieve better results [49].
The circuit is
completed with an additional layer of rotations. Multi-
ple measurements are carried on any qubit to approxi-
mate an expectation value. The circuit model TwoLocal
from the Qiskit circuit library was chosen for this work.
It is a fully entangled model composed of Ry, Rz, and
controlled-Z gates with no block repetition.
The Optical Recognition of Handwritten Digits Data
Set was used [52]. A binary dataset with 100 samples was
extracted from the original dataset. The two classes of
the new dataset are 0 and 1, each with 50 samples of 64
attributes. Mean test accuracy is computed on a random
initialization for each feature map configuration.
Qiskitâ€™s VQC implementation was modified to accept
the BAA encoding as a feature map and used to carry on
the classical-quantum hybrid approach, in which the op-
timization procedure is processed on a classical computer
to determine a set of parameters for the parameterized
quantum circuit [51, 53]. Simulations of the hybrid clas-
sification algorithms were performed using Qiskitâ€™s Aer
simulator with approximately 4500 circuit executions for
each experiment configuration â€“ 1024 shots per execu-
tion.
For the experiments with noisy simulation, the
noisy model and the coupling map were imported from
ibmq_jakarta device. Ten samples of each class of the bi-
nary dataset were used as a test set and the remaining 80
samples (40 for each class) as a training set. As prepara-
tion for amplitude encoding, each data vector element of
the dataset was standardized for a Gaussian around zero
with unit variance, rescaled within the range [0, 1], and
normalized. Our simulation employs the Simultaneous
Perturbation Stochastic Approximation (SPSA) [50] for
the optimization process with a mini-batch size of 1/10
of the training set size.
Ideally, the accuracy should be at a nominal level,
which can be established with a noiseless simulation.
However, the experiment on a NISQ device introduces
noise, reducing the classification accuracy. Still, the BAA
produces better results on a noisy device due to the lower
circuit complexity. Indeed, the reduction of entangling
gates shows that even strong approximations still result
into higher accuracy (Figure 9). For a small training data
set, one can train a variational quantum circuit with low-
rank images, but we suspect that this method will pre-
serve its value for larger training data.
V.
CONCLUSION
With the help of Low-Rank State Preparation algo-
rithms, significant improvements in the complexity of
two-qubit entangling gates can be attained.
The pro-
posed LRSP algorithm exploit this fact by connect-
ing state preparation complexity with the entanglement
structure of the quantum state. This work highlights that
classical data can be rearranged such that the entangle-
ment structure attains an easier to approximate struc-
ture, as can be seen in Figure 3 and Figure 4. This di-
rectly bestows the data with the topological structure of
qubit systems. In particular, by logically swapping qubits
between partitions, one can find more local behavior.
This makes it easier to simulate classically, but also, by
virtue of the above-mentioned circuit designs, less com-
118

10
Repeat l times
(a)
(b)
(c)
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0
20
40
60
80
100
120
# cnot
depth
0.4
0.5
0.6
0.7
0.8
0.9
1.0
ideal
noisy
multiplexor
classification accuracy
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
FIG. 9: Application of the BAA to machine learning problems helps to increase classification accuracy. (a) The
effect of BAA on the input data (digits) for different maximum fidelity loss parameters. (b) The classifierâ€™s feature
map UÏ• encodes the data in the amplitudes of a quantum state using BAA. (c) The bars show the average number
of CNOT gates and circuit depth produced by the multiplexor algorithm [48] and the BAA. Blue and yellow lines
indicate ideal and noisy simulation accuracy results. The classifier delivers the best accuracy at the maximum
fidelity loss of 0.5.
plex to create on a quantum computer. To showcase the
immediate advantages of this approach, we present exam-
ple applications in loading PDF and quantum machine
learning. The experiments with VQC show that BAA
allows adjustment of the input data according to the de-
viceâ€™s capability to manage entanglement, improving the
classifierâ€™s performance. Additionally, VQC applications
have the characteristic of loading the same input vector
many times, which amortizes the computational time of
the BAA preprocessing.
Recent approaches for approximating quantum states
use variational quantum circuits in which parameterized
single qubit and entangling operations are intertwined
and adjusted according to a gradient descent method
while minimizing/maximizing a loss function, usually
taken from the measurement output of an experiment.
In particular noteworthy is the qGAN method [18] and
the AAS method [19] which have been proposed as a vi-
able alternative to standard state preparation in order to
achieve good results in the NISQ era. These methods try
to emulate local-interaction Hamiltonians, and as such
they in theory must be able to converge to the desired
quantum state. We found in a preliminary comparison
that the BAA performs better for several reasons. How-
ever, we note that an exhaustive study is necessary, yet is
beyond the scope of this work. To summarize, the BAA
is based on purely classical algorithms being very effi-
cient in todayâ€™s hardware with standard methods to ap-
ply for approximations (instead of a full search, we have
greedy and Monte-Carlo as options) and the method does
not suffer from initial conditions failures (such as barren
plateaus).
This work also leaves some open technical questions.
The BAA algorithm needs to disentangle in the first level
of the tree if it is to succeed to the next. This involves
the existence of a bipartition that will break the system
into two uncorrelated parts. For some quantum states,
this may be too much to ask for.
Even though some
gate-complexity reduction can be attained by the low-
rank state preparation, it seems that this approach may
not exploit the quantum stateâ€™s entanglement topology
to its maximum.
Apart from the advantages that this view of state
preparation for classical data can have for the NISQ-
era, and beyond, there is another promising application,
which is to enhance quantum adiabatic state prepara-
tion [54, 55] by preparing a low-entanglement bounded
approximation error state and find its Hamiltonian for
which it is an eigenvalue and then apply the adiabatic
theorem.
The goal would be to potentially skip spec-
tral gap bottlenecks and therefore make either the state
preparation possible or reduce the adiabatic time signifi-
cantly. In fact, a possible way forward could be to reach
high-entanglement states by this approach. It remains
unclear how this could actually be achieved, but the ap-
plications would be obviously beneficial.
ACKNOWLEDGMENTS
This research is supported by Conselho Nacional de
Desenvolvimento CientÃ­fico e TecnolÃ³gico - CNPq, Co-
ordenaÃ§Ã£o de AperfeiÃ§oamento de Pessoal de NÃ­vel Su-
perior (CAPES), and FundaÃ§Ã£o de Amparo Ã  CiÃªncia e
Tecnologia do Estado de Pernambuco - FACEPE. We
acknowledge the use of IBM Quantum services for this
work. The views expressed are those of the authors, and
do not reflect the official policy or position of IBM or the
IBM Quantum team.
119

11
DATA AVAILABILITY
The sites https://github.com/qclib/qclib-papers
and https://github.com/qclib/qclib contain all the
data and the software generated during the current study.
[1] F. Arute, K. Arya, R. Babbush, D. Bacon, J. C. Bardin,
R. Barends, R. Biswas, S. Boixo, F. G. Brandao, D. A.
Buell, et al., Quantum supremacy using a programmable
superconducting processor, Nature 574, 505 (2019).
[2] A. W. Harrow, A. Hassidim, and S. Lloyd, Quantum al-
gorithm for linear systems of equations, Physical review
letters 103, 150502 (2009).
[3] S. Lloyd, M. Mohseni, and P. Rebentrost, Quantum prin-
cipal component analysis, Nature Physics 10, 631 (2014).
[4] A. Montanaro, Quantum speedup of Monte Carlo meth-
ods, Proceedings of the Royal Society A: Mathematical,
Physical and Engineering Sciences 471, 20150301 (2015),
1504.06987.
[5] P. Rebentrost, B. Gupt, and T. R. Bromley, Quantum
computational finance:
Monte Carlo pricing of finan-
cial derivatives, Physical Review A 98, 022321 (2018),
1805.00109.
[6] J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost,
N. Wiebe, and S. Lloyd, Quantum machine learning, Na-
ture 549, 195 (2017).
[7] M. Schuld and F. Petruccione, Supervised Learning with
Quantum Computers, 1st ed. (Springer Publishing Com-
pany, Incorporated, 2018).
[8] C. Blank, D. K. Park, J.-K. K. Rhee, and F. Petruc-
cione, Quantum classifier with tailored quantum kernel,
npj Quantum Information 6, 41 (2020).
[9] S. Aaronson, Read the fine print, Nature Physics 11, 291
(2015).
[10] F. Leymann and J. Barzen, The bitter truth about gate-
based quantum algorithms in the NISQ era, Quantum
Science and Technology 5, 044007 (2020).
[11] V. Bergholm, J. J. Vartiainen, M. MÃ¶ttÃ¶nen, and M. M.
Salomaa, Quantum circuits with uniformly controlled
one-qubit gates, Physical Review A 71, 052330 (2005).
[12] M. Plesch and ÄŒ. Brukner, Quantum-state preparation
with universal gate decompositions, Physical Review A
83, 032302 (2011).
[13] E. Malvetti, R. Iten, and R. Colbeck, Quantum circuits
for sparse isometries, Quantum 5, 412 (2021).
[14] I. F. Araujo, D. K. Park, F. Petruccione, and A. J.
da Silva, A divide-and-conquer algorithm for quantum
state preparation, Scientific Reports 11, 6329 (2021).
[15] I. F. Araujo, D. K. Park, T. B. Ludermir, W. R. Oliveira,
F. Petruccione, and A. J. da Silva, Configurable sublinear
circuits for quantum state preparation, arXiv preprint
arXiv:2108.10182 (2021).
[16] X.-M. Zhang, M.-H. Yung, and X. Yuan, Low-depth
quantum state preparation, Phys. Rev. Research 3,
043200 (2021).
[17] D. K. Park, F. Petruccione, and J.-K. K. Rhee, Circuit-
based quantum random access memory for classical data,
Scientific Reports 9, 3949 (2019).
[18] C. Zoufal, A. Lucchi, and S. Woerner, Quantum genera-
tive adversarial networks for learning and loading random
distributions, npj Quantum Information 5, 103 (2019).
[19] K. Nakaji, S. Uno, Y. Suzuki, R. Raymond, T. Onodera,
T. Tanaka, H. Tezuka, N. Mitsuda, and N. Yamamoto,
Approximate amplitude encoding in shallow parameter-
ized quantum circuits and its application to financial
market indicator (2021).
[20] G. Marin-Sanchez, J. Gonzalez-Conde, and M. Sanz,
Quantum algorithms for approximate function loading
(2021).
[21] F. Mozafari, H. Riener, M. Soeken, and G. De Micheli,
Efficient boolean methods for preparing uniform quan-
tum states, IEEE Transactions on Quantum Engineering
2, 1 (2021).
[22] C. E. Mora and H. J. Briegel, Algorithmic complexity of
quantum states, International Journal of Quantum Infor-
mation 04, 715 (2006).
[23] C. E. Mora and H. J. Briegel, Algorithmic complexity
and entanglement of quantum states, Phys. Rev. Lett.
95, 200503 (2005).
[24] R. Raussendorf and H. J. Briegel, A one-way quantum
computer, Phys. Rev. Lett. 86, 5188 (2001).
[25] J. T. Barreiro,
P. Schindler,
O. GÃ¼hne,
T. Monz,
M. Chwalla, C. F. Roos, M. Hennrich, and R. Blatt, Ex-
perimental multiparticle entanglement dynamics induced
by decoherence, Nature Physics 6, 943 (2010).
[26] A. R. Calderbank and P. W. Shor, Good quantum error-
correcting codes exist, Phys. Rev. A 54, 1098 (1996).
[27] A. Steane, Multiple-particle interference and quantum er-
ror correction, Proceedings of the Royal Society of Lon-
don. Series A: Mathematical, Physical and Engineering
Sciences 452, 2551 (1996).
[28] R. Cleve, D. Gottesman, and H.-K. Lo, How to share a
quantum secret, Phys. Rev. Lett. 83, 648 (1999).
[29] W. DÃ¼r and J. I. Cirac, Multiparty teleportation, Journal
of Modern Optics 47, 247 (2000).
[30] V. V. Shende, S. S. Bullock, and I. L. Markov, Syn-
thesis of quantum-logic circuits, IEEE Transactions on
Computer-Aided Design of Integrated Circuits and Sys-
tems 25, 1000 (2006).
[31] R. Iten, R. Colbeck, I. Kukuljan, J. Home, and M. Chri-
standl, Quantum circuits for isometries, Physical Review
A 93, 032318 (2016).
[32] I. F. Araujo, C. Blank, A. da Silva, I. Cesar, and L. Silva,
Quantum computing library (qclib), https://github.
com/qclib/qclib (2022).
[33] G.
Aleksandrowicz,
T.
Alexander,
P.
Barkoutsos,
L. Bello, et al., Qiskit: An Open-source Framework for
Quantum Computing (2019).
[34] C. Blank, D. K. Park, and F. Petruccione, Quantum-
enhanced analysis of discrete stochastic processes, npj
Quantum Information 7, 1 (2021).
[35] P. Teng, Accurate calculation of the geometric measure of
entanglement for multipartite quantum states, Quantum
Information Processing 16, 181 (2017), 1609.02076.
120

12
[36] K. Mehlhorn and P. Sanders, Algorithms and data struc-
tures: the basic toolbox (Springer, Berlin, 2008).
[37] S. S. Skiena, The algorithm design manual, 2nd ed.
(Springer, London, 2008) oCLC: ocn228582051.
[38] G. L. Nemhauser, L. A. Wolsey, and M. L. Fisher, An
analysis of approximations for maximizing submodular
set functionsâ€”i, Mathematical Programming 14, 265
(1978).
[39] T. H. Cormen, ed., Introduction to algorithms, 3rd
ed.
(MIT
Press,
Cambridge,
Mass,
2009)
oCLC:
ocn311310321.
[40] A. Bouland, B. Fefferman, C. Nirkhe, and U. Vazirani,
On the complexity and verification of quantum ran-
dom circuit sampling, Nature Physics 15, 159 (2019),
1803.04402.
[41] A. Shimony, Degree of Entanglement, Annals of the New
York Academy of Sciences 755, 675 (1995).
[42] H. Barnum and N. Linden, Monotones and invariants
for multi-particle quantum states, Journal of Physics
A: Mathematical and General 34, 6787 (2001), quant-
ph/0103155.
[43] T.-C. Wei and P. M. Goldbart, Geometric measure of en-
tanglement and applications to bipartite and multipartite
quantum states, Physical Review A 68, 042307 (2003),
quant-ph/0307219.
[44] L. Grasedyck, Hierarchical singular value decomposition
of tensors, SIAM J. Matrix Anal. Appl. 31, 2029â€“2054
(2010).
[45] S. Chakraborty, Generating discrete analogues of contin-
uous probability distributions-a survey of methods and
constructions, Journal of Statistical Distributions and
Applications 2, 6 (2015).
[46] I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio,
Generative adversarial nets, Advances in neural informa-
tion processing systems 27 (2014).
[47] V. HavlÃ­Äek, A. D. CÃ³rcoles, K. Temme, A. W. Harrow,
A. Kandala, J. M. Chow, and J. M. Gambetta, Super-
vised learning with quantum-enhanced feature spaces,
Nature 567, 209 (2019).
[48] M. MÃ¶ttÃ¶nen, J. J. Vartiainen, V. Bergholm, and M. M.
Salomaa, Transformation of quantum states using uni-
formly controlled rotations, Quantum Information &
Computation 5, 467 (2005).
[49] M. Schuld, A. Bocharov, K. M. Svore, and N. Wiebe,
Circuit-centric quantum classifiers, Phys. Rev. A 101,
032308 (2020).
[50] A. Kandala, A. Mezzacapo, K. Temme, M. Takita,
M. Brink, J. M. Chow, and J. M. Gambetta, Hardware-
efficient
variational
quantum
eigensolver
for
small
molecules and quantum magnets, Nature 549, 242
(2017).
[51] N. Moll, P. Barkoutsos, L. S. Bishop, J. M. Chow,
A. Cross, D. J. Egger, S. Filipp, A. Fuhrer, J. M.
Gambetta, M. Ganzhorn, A. Kandala, A. Mezzacapo,
P. MÃ¼ller, W. Riess, G. Salis, J. Smolin, I. Tavernelli,
and K. Temme, Quantum optimization using variational
algorithms on near-term quantum devices, Quantum Sci-
ence and Technology 3, 030503 (2018).
[52] E. Alpaydin and C. Kaynak, Cascading classifiers, Ky-
bernetika 34, 369 (1998).
[53] J. R. McClean, J. Romero, R. Babbush, and A. Aspuru-
Guzik,
The
theory
of
variational
hybrid
quantum-
classical algorithms, New Journal of Physics 18, 023023
(2016).
[54] T. Albash and D. A. Lidar, Adiabatic quantum compu-
tation, Reviews of Modern Physics 90, 015002 (2018),
1611.04471.
[55] L. Veis and J. Pittner, Adiabatic state preparation study
of methylene, The Journal of Chemical Physics 140,
214111 (2014), 1401.3186.
121

Approximated quantum-state preparation with entanglement
dependent complexity â€“ Supplementary Information
Israel F. Araujoâˆ—1, Carsten Blankâ€ 2, Ismael Cesarâ€¡1, and Adenilton J. da Silva1
1Centro de InformÂ´atica, Universidade Federal de Pernambuco, 50740-560, Recife,
Pernambuco, Brazil
2data cybernetics, 86899, Landsberg am Lech, Germany
June 2022
1
Low-rank state preparation
1.1
Algorithm
To achieve low-rank approximation, the corresponding input parameter r is introduced to Algorithm 1 and
can assume values between 1 and 2nA. The following conditional statement is introduced between lines 2 and
3: [If r < rank then rank = r]. Setting r = 1 completely disentangles subsystems HA and HB, which implies
a quadratic reduction in the number of CNOT gates in the circuit to prepare a state when nA = âŒŠn/2âŒ‹.
Additionally, the circuit depth is also reduced.
SUPPLEMENTARY Algorithm 1: Low-rank state preparation algorithm
input : A state vector of 2n amplitudes.
input : A partition of nA qubits (1 â‰¤nA â‰¤âŒŠn/2âŒ‹).
output: Encoding quantum circuit.
1 Decompose the state vector using SVD and partition (store unitaries u and vh, and vector s)
2 Set rank equal to the number of non-zero elements of s (rank = count(s Ì¸= 0))
3 Set Schmidt measure m = âŒˆlog2(rank)âŒ‰
4 If m < nA, set the number of columns of u, vhT , and s to 2m, otherwise continue
5 Create a quantum circuit with n qubits (n = log2(length(state vector)))
6 If m > 0, encode the normalized vector s on the first m qubits q âˆˆpartition using an amplitude
encoding state preparation algorithm. This step is named Phase 1
7 Perform m CNOT gates between control qubit qc âˆˆpartition and target qt /âˆˆpartition. This step is
named Phase 2
8 Encode u on qubits q âˆˆpartition using an algorithm according to its dimension (vector, isometry,
and unitary). This step is named Phase 3
9 Encode vhT on qubits q /âˆˆpartition using an algorithm according to its dimension (vector, isometry
or unitary). This step is named Phase 4
10 Output the encoding quantum circuit
âˆ—ifa@cin.ufpe.br
â€ blank@data-cybernetics.com
â€¡icsa@cin.ufpe.br
1
122
APÃŠNDICE D â€“ APPROXIMATED QUANTUM-STATE PREPARATION WITH
ENTANGLEMENT DEPENDENT COMPLEXITY â€“ SUPPLEMENTARY
INFORMATION

2
Bounded Approximation Algorithm
2.1
Pseudocode
Pseudocode 1 constructs the approximation search tree as described in the main document. Pseudocode 2
employs Pseudocode 1 and expresses the bounded approximation algorithm (BAA). Pseudocode 3 builds
quantum circuits using the BAA approach for encoding a complex input vector into the amplitudes of a
quantum state.
Lines 3 of Pseudocode 1 generates all combinations of state partitions from size 1 to âŒŠn/2âŒ‹.
Line 5
separates the indicated partition and creates two new states with a fidelity loss relative to the original state.
Line 7 configures the recurrence so that, if the partitionâ€™s total fidelity loss is less or equal than the maximal
acceptable fidelity loss, a new child node is created. Compared to the previous node, the new one has the
original state replaced by the two separated states.
Line 2 of Pseudocode 2 employs the geometric measure to estimate the maximum possible fidelity loss. If
it is less than the maximal acceptable fidelity loss, the search routine is avoided and the product state used.
Line 3 of Pseudocode 3 initializes each of the state vectors associated to the selected node. Any initializa-
tion algorithm can be used, including the LRSP described in Section 1. The qubits used in each initialization
must follow the previous BAA partitioning. Line 9 of Pseudocode 2 CNOT count must take into account
the algorithm choice.
SUPPLEMENTARY Pseudocode 1: Generate a search tree.
1 build search tree (node, max fidelity loss):
input : Tree node (node) to apply the next search step.
input : The maximal acceptable fidelity loss (max fidelity loss) for the approximation.
// Ignore single-qubit states.
2
for s â†0 to length(node.states) âˆ’1 do
// Combinations taken k âˆˆ[1, âŒŠn/2âŒ‹] at a time without repetition.
// Combinations equal to the complement of previous ones can be
// omitted, as they are redundant.
3
partitions = combinations(node.states[s], k â†1 to âŒŠn/2âŒ‹)
4
for p â†0 to length(partitions) âˆ’1 do
// Computes the two states and the fidelity loss after
// disentangling partitions[p].
5
subsystem1, subsystem2, fidelity loss = separate partition(node.states[s], partitions[p])
6
total fidelity loss = 1 - (1 - fidelity loss) Ã— (node.total fidelity loss)
7
if total fidelity loss â‰¤max fidelity loss then
// Recursion should not continue for this branch if
// total fidelity loss has reached max fidelity loss.
8
new node.total fidelity loss = total fidelity loss
9
new node.states = node.states
10
new node.states.remove(s)
11
new node.states.add(subsystem1)
12
new node.states.add(subsystem2)
13
node.children.add(new node)
// Call build search tree recurrently for each new node.
14
build search tree (new node, max fidelity loss)
2
123

SUPPLEMENTARY Pseudocode 2: Find the node that will be used to perform the state
preparation.
1 baa (state, max fidelity loss):
input : A state vector (state) to be approximate.
input : The maximal acceptable fidelity loss (max fidelity loss) for the approximation.
output: Node with the best approximation.
// Estimate the maximal fidelity loss.
2
entanglement = geometric measure(state)
3
if entanglement â‰¤max fidelity loss then
4
node.vectors = product state(state)
5
return node
// Start with the complete state.
6
root node.vectors = state
7
build search tree (root node, max fidelity loss)
// Leaf nodes are the ones closest to max fidelity loss for each branch.
8
leaves = list leaves(root node)
// Search the node with the greatest reduction in the number of CNOTs.
// The CNOT count depends on the algorithm chosen to encode the states.
9
best node = search best(leaves)
10
return best node
SUPPLEMENTARY Pseudocode 3: Construct a circuit that performs an approximate state
preparation for the input vector state.
input : A state vector (state) to be encoded.
input : The maximal acceptable fidelity loss (max fidelity loss) for the baa approximation.
output: Circuit with the encoded quantum state.
1 node = baa (state, max fidelity loss)
2 for s â†0 to length(node.states) âˆ’1 do
// Use any amplitude encoding algorithm.
3
circuit.initialize(node.states[s])
4 return circuit
3
124

125
APÃŠNDICE E â€“ EMARANHAMENTO E A PREPARAÃ‡ÃƒO DE ESTADOS
QUÃ‚NTICOS
O emaranhamento Ã© um dos recursos quÃ¢nticos que permitem o desenvolvimento de al-
goritmos e protocolos mais eficientes. Sua relaÃ§Ã£o com a complexidade algorÃ­tmica de um
estado quÃ¢ntico jÃ¡ foi demonstrada em trabalhos anteriores (MORA; BRIEGEL, 2006; MORA;
BRIEGEL, 2005) e desempenha um papel fundamental em muitas aplicaÃ§Ãµes quÃ¢nticas, tais
como comunicaÃ§Ã£o quÃ¢ntica, correÃ§Ã£o de erros quÃ¢nticos e compartilhamento de segredos
quÃ¢nticos (RAUSSENDORF; BRIEGEL, 2001; BARREIRO et al., 2010; CALDERBANK; SHOR, 1996;
STEANE, 1996; CLEVE; GOTTESMAN; LO, 1999; DÃ¼R; CIRAC, 2000).
Para entender o significado do emaranhamento na computaÃ§Ã£o quÃ¢ntica, um dos resultados
seminais da fÃ­sica da matÃ©ria condensada Ã© que sistemas de spin de baixo emaranhamento
podem ser computados classicamente de forma eficiente. Como o modelo da computaÃ§Ã£o
quÃ¢ntica de circuitos pode ser representado por tais sistemas de spin, nÃ£o se pode esperar
vantagens quÃ¢nticas quando o baixo emaranhamento estÃ¡ presente. Portanto, deve ser possÃ­vel
inicializar eficientemente um estado quÃ¢ntico com baixo emaranhamento. De fato, para a
inicializaÃ§Ã£o de dados clÃ¡ssicos em um estado quÃ¢ntico, deseja-se estar no regime de sistemas
de spin de baixo emaranhamento e, apÃ³s finalizar a preparaÃ§Ã£o do estado, ter um aumento
de emaranhamento (exponencial no nÃºmero de qubits) aplicando uma evoluÃ§Ã£o unitÃ¡ria para
alcanÃ§ar a vantagem quÃ¢ntica. O argumento Ã© que este caminho poderia levar Ã  soluÃ§Ã£o do
problema do carregamento de informaÃ§Ãµes clÃ¡ssicas em um sistema quÃ¢ntico.
O trabalho Araujo, Blank e Silva (2022) (SeÃ§Ã£o 4.3 e ApÃªndice C) apresenta um algoritmo
para preparaÃ§Ã£o de estados cuja complexidade Ã© uma funÃ§Ã£o do emaranhamento, nÃ£o apenas
do nÃºmero de qubits. Nele argumentamos ser necessÃ¡rio um quadro completo de todos os
emaranhamentos bipartidos em sistemas de spin unidimensionais para descrever a estrutura
topolÃ³gica dos dados. De fato, deve-se reverter o problema e encontrar a disposiÃ§Ã£o do sistema
1D de spin de tal forma que a codificaÃ§Ã£o dos dados clÃ¡ssicos exiba o mÃ¡ximo possÃ­vel de
interaÃ§Ãµes locais. Isto levarÃ¡, entÃ£o, a um baixo emaranhamento e, consequentemente, a uma
reduÃ§Ã£o do custo para a preparaÃ§Ã£o do estado quÃ¢ntico. Como esta reordenaÃ§Ã£o de spin-qubits
Ã© um mapeamento um-para-um (uma troca) no espaÃ§o Hilbert, essa operaÃ§Ã£o, com algum
cuidado, nÃ£o afeta o algoritmo principal. A Figura 32 mostra a ideia principal em notaÃ§Ã£o
tensorial (ORÃºS, 2014), onde conexÃµes vermelhas espessas significam emaranhamento mais

126
Figura 32 â€“ Abordagem esquemÃ¡tica. a) Um vetor de estado quÃ¢ntico em notaÃ§Ã£o de rede tensorial Ã© conver-
tido em um MPS atravÃ©s da aplicaÃ§Ã£o de uma decomposiÃ§Ã£o de Schmidt entre qubit 1 e qubits
2, 3, 4, 6, 7, 8, e depois qubit 2 vs. 3, 4, 5, 6, 7, 8 e assim por diante. A chamada dimensÃ£o de
ligaÃ§Ã£o Ã© escolhida durante esse procedimento. A largura da barra de ligaÃ§Ã£o significa a dimensÃ£o
efetiva da ligaÃ§Ã£o. b) Reorganizando as qubits Ã© possÃ­vel encontrar uma bipartiÃ§Ã£o tal que cada
partiÃ§Ã£o tenha apenas uma pequena dimensÃ£o de ligaÃ§Ã£o, o que significa que estas partiÃ§Ãµes nÃ£o
estÃ£o fortemente emaranhadas.
1
2
3
4
5
6
7
8
MPS
2
3
4
5
6
7
8
1
(a)
2
3
4
5
6
7
8
1
2
3
4
5
6
7
8
1
(b)
Fonte: Elaborada pelo autor (2022)
forte, e conexÃµes finas a quase ausÃªncia de emaranhamento.
O mecanismo principal do algoritmo em Araujo, Blank e Silva (2022) explora o nÃ­vel de
emaranhamento do vetor de entrada, e eleva a capacidade de preparar uma aproximaÃ§Ã£o de
baixo posto (low-rank) (ECKART; YOUNG, 1936) de um estado quÃ¢ntico, usando a decompo-
siÃ§Ã£o de Schmidt. O algoritmo LRSP Ã© usado como um veÃ­culo algorÃ­tmico para conduzir a
preparaÃ§Ã£o de estado low-rank Ã s operaÃ§Ãµes quÃ¢nticas concretas. Um mÃ©todo muito similar ao
acima, por Gundlapalli e Lee (2021), explora a estrutura de ligaÃ§Ã£o do Matrix Product State
(MPS) (PEREZ-GARCIA et al., 2006) para projetar um circuito quÃ¢ntico que prepara um estado
arbitrÃ¡rio de maneira exata ou aproximada. O mÃ©todo MPS Ã© bem conhecido na comunidade
da FÃ­sica, portanto, queremos destacÃ¡-lo neste ponto.
O MPS tambÃ©m Ã© chamado de train-tensor formulation que tem esse nome dada a repre-
sentaÃ§Ã£o
|ğœ“âŸ©=
âˆ‘ï¸
ğ‘–1,...,ğ‘–ğ‘›
ğ´[1]
ğ‘–1 ğ´[2]
ğ‘–2 Â· Â· Â· ğ´[ğ‘›âˆ’1]
ğ‘–ğ‘›âˆ’1 ğ´[ğ‘›]
ğ‘–ğ‘›|ğ‘–1ğ‘–2 Â· Â· Â· ğ‘–ğ‘›âŸ©
onde temos os ğ‘›sites em uma grade 1D de spin-quits, e ğ´[ğ‘š]
ğ‘–ğ‘šâˆˆCğ·ğ‘šÃ—ğ·ğ‘š+1 com ğ·1 = ğ·ğ‘›= 1
na chamada formulaÃ§Ã£o open boundary condition. O ğ·ğ‘šÃ© chamado de dimensÃ£o da ligaÃ§Ã£o
no site ğ‘šao ğ‘š+ 1. Uma aproximaÃ§Ã£o do estado pode ser feita ao permitir apenas uma

127
dada dimensÃ£o de ligaÃ§Ã£o mÃ¡xima no site especÃ­fico ğ‘š. O MPS pode ser facilmente calculado
atravÃ©s da aplicaÃ§Ã£o da decomposiÃ§Ã£o de Schmidt entre a bipartiÃ§Ã£o {1}/{2, . . . , ğ‘›}, e depois
{2}/{3, . . . , ğ‘›}, atÃ© que todos os qubits/sites tenham sido processados.
Usando os algoritmos de Araujo, Blank e Silva (2022) ou Gundlapalli e Lee (2021), Ã©
possÃ­vel desemaranhar completamente subconjuntos de qubits enquanto o erro de fidelidade
introduzido escala com os coeficientes de Schmidt que sÃ£o descartados. Entretanto, uma des-
vantagem da abordagem de Gundlapalli e Lee (2021) reside no fato de que a abordagem MPS
padrÃ£o, por convenÃ§Ã£o, utiliza uma direÃ§Ã£o prÃ©-definida na descomposiÃ§Ã£o de Schmidt. Isto
por si sÃ³ nÃ£o Ã© um inconveniente, mas ao fixar a base computacional do estado, a possibilidade
de permitir bipartiÃ§Ãµes arbitrÃ¡rias â€“ com qubits nÃ£o necessariamente conectados â€“ nÃ£o Ã© pron-
tamente Ã³bvia. O BAA, em conjunto com o LRSP, consegue reorganizar os sites e encontrar
o sistema 1D de spin que exibe uma baixa dimensÃ£o de ligaÃ§Ã£o em alguma fronteira. Ã‰ entÃ£o
possÃ­vel aproximar com um erro menor, potencialmente desemaranhando as bipartiÃ§Ãµes. Pode-
se entÃ£o aplicar recursivamente esta abordagem nas duas partes separadamente; um algoritmo
de busca com um dado erro de aproximaÃ§Ã£o mÃ¡xima, como o BAA, pode entÃ£o encontrar a
aproximaÃ§Ã£o Ã³tima de um estado quÃ¢ntico arbitrÃ¡rio.
Tendo em vista o tratamento para a aproximaÃ§Ã£o do estado quÃ¢ntico, pode-se estar natu-
ralmente inclinado a buscar a melhor aproximaÃ§Ã£o de estado completamente separado. Esta Ã©
de fato uma medida para emaranhamento, a chamada medida geomÃ©trica de emaranhamento.
Foi introduzida pela primeira vez por Shimony (SHIMONY, 1995) e refinada por Barnum &
Linden (BARNUM; LINDEN, 2001). A definiÃ§Ã£o para esta medida de emaranhamento Ã© dada por
ğ¸ğ‘”(|ğœ“âŸ©) = min
|ğœ‘âŸ©â€– |ğœ“âŸ©âˆ’|ğœ‘âŸ©â€–
(E.1)
onde a minimizaÃ§Ã£o estÃ¡ sobre todos os estados |ğœ‘âŸ©que sÃ£o estados completamente sepa-
rÃ¡veis (TENG, 2017), ou seja, |ğœ‘âŸ©= âŠ—ğ‘›
ğ‘™=1
âƒ’âƒ’âƒ’ğœ‘ğ‘™âŸ©
com cada
âƒ’âƒ’âƒ’ğœ‘ğ‘™âŸ©
sendo um estado local. Wei e
Goldbart (2003) mostrou que este valor Ã© uma medida Ãºtil de emaranhamento.
A medida geomÃ©trica do emaranhamento estÃ¡ relacionada ao algoritmo BAA da seguinte
forma. Teoricamente, a maior perda de fidelidade que qualquer estado quÃ¢ntico pode experi-
mentar sob o BAA nunca deve ser superior a ela. Portanto, a medida geomÃ©trica indica quÃ£o
ruim uma aproximaÃ§Ã£o pode ficar. Isto mostra que os estados de baixo emaranhamento podem
ser aproximados como um estado completamente separÃ¡vel com pouca perda de fidelidade.
Naturalmente, estamos interessados em calcular o estado separÃ¡vel que maximiza a fideli-

128
dade na tentativa de calcular a medida geomÃ©trica do emaranhamento. A primeira tentativa
desse tipo publicada na literatura cientÃ­fica calcula a medida com a ajuda de um problema de
valor prÃ³prio nÃ£o linear (WEI; GOLDBART, 2003). Algoritmos mais eficientes foram desenvolvi-
dos nesse Ã­nterim. Como foi apontado por Teng (TENG, 2017), pode-se usar a decomposiÃ§Ã£o
de posto tensorial e a decomposiÃ§Ã£o de Tucker (ENRÃ­QUEZ; PUCHAÅ‚A; Å»YCZKOWSKI, 2015).
O cÃ¡lculo da medida geomÃ©trica do emaranhamento pode ser feito de forma eficiente
e com alta probabilidade aplicando a decomposiÃ§Ã£o de Tucker de um estado quÃ¢ntico |ğœ“âŸ©,
interpretando-o como um tensor com cada modo sendo bidimensional e de rank um. O cha-
mado core (KOLDA; BADER, 2009) Ã© entÃ£o simplesmente um nÃºmero complexo ğœ†e a medida
geomÃ©trica de emaranhamento Ã© ğ¸(ğœ“) = 1 âˆ’|ğœ†|2 (TENG, 2017). Cada fator Ã© um vetor, e
eles constituem os estados de um qubit que podem ser preparados juntos como um estado
separÃ¡vel. O estado criado de tal forma Ã© entÃ£o chamado de |ğœ“â€²âŸ©, e seu overlap com o estado
original Ã© âŸ¨ğœ“|ğœ“â€²âŸ©= ğœ†.
O caso particular onde as partiÃ§Ãµes do BAA sÃ£o divididas ao meio e apenas um ramo
selecionado Ã© equivalente ao Hierarchical Tucker Format (HTF) com uma Ã¡rvore de dimensÃ£o
binÃ¡ria (chamada de Ãrvore de DimensÃ£o CanÃ´nica) (GRASEDYCK, 2010). O HTF pode ser
usado para estimar a mÃ¡xima perda de fidelidade possÃ­vel com um erro menor ou igual a
âˆš2ğ‘›âˆ’3â€–ğ´âˆ’ğ´bestâ€–, onde ğ´best Ã© a melhor aproximaÃ§Ã£o do tensor ğ´, e ğ‘›Ã© a dimensionalidade
do problema. O nÃºmero de bipartiÃ§Ãµes realizadas para estimar a perda mÃ¡xima de fidelidade
Ã© linear no nÃºmero de qubits. Como BAA realiza o SVD a partir de tensores jÃ¡ truncados, o
custo do HTF Ã© dado pelo Lemma 26 de Grasedyck (2010).
O objetivo desta seÃ§Ã£o foi conectar a fÃ­sica da matÃ©ria condensada com a computaÃ§Ã£o
quÃ¢ntica e tambÃ©m conectar a representaÃ§Ã£o hamiltoniana de baixo emaranhamento/interaÃ§Ã£o
local com a preparaÃ§Ã£o de estados de baixa complexidade, enquanto argumenta que os dados
clÃ¡ssicos possuem um grau de liberdade na ordenaÃ§Ã£o dos spin-quits que a fÃ­sica da matÃ©ria
condensada nÃ£o tem. Para ir ainda mais longe, a codificaÃ§Ã£o de dados clÃ¡ssicos que devem ser
usados no processamento de informaÃ§Ãµes quÃ¢nticas podem ser mapeados nas propriedades de
um hamiltoniano, cujas interaÃ§Ãµes dominantes podem ser locais ou nÃ£o-locais.
Esta seÃ§Ã£o deixa como trabalho futuro verificar se a fÃ­sica da matÃ©ria condensada possui
ferramentas para encontrar a melhor ordenaÃ§Ã£o dos spin-quits na grade 1D, de modo que a
localidade seja aumentada. Atualmente, a melhor estratÃ©gia Ã© uma busca exaustiva, com custo
exponencial no nÃºmero de qubits.

