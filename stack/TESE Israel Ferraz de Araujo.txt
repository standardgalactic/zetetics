UNIVERSIDADE FEDERAL DE PERNAMBUCO
CENTRO DE INFORM√ÅTICA
PROGRAMA DE P√ìS-GRADUA√á√ÉO EM CI√äNCIA DA COMPUTA√á√ÉO
ISRAEL FERRAZ DE ARAUJO
Otimiza√ß√£o de Circuitos para a Inicializa√ß√£o de Estados Qu√¢nticos
Recife
2022

ISRAEL FERRAZ DE ARAUJO
Otimiza√ß√£o de Circuitos para a Inicializa√ß√£o de Estados Qu√¢nticos
Tese de Doutorado apresentada ao Programa de
P√≥s-Gradua√ß√£o em Ci√™ncia da Computa√ß√£o da Uni-
versidade Federal de Pernambuco, como requisito
parcial para a obten√ß√£o do t√≠tulo de Doutor em Ci-
√™ncia da Computa√ß√£o. √Årea de Concentra√ß√£o: Inte-
lig√™ncia Computacional.
Orientador: Adenilton Jos√© da Silva
Coorientadora: Teresa Bernarda Ludermir
Recife
2022

Cataloga√ß√£o na fonte
Bibliotec√°ria Luiza de Oliveira, CRB4-1316
A658o
Araujo, Israel Ferraz de
Otimiza√ß√£o de circuitos para a inicializa√ß√£o de estados qu√¢nticos. /Israel Ferraz de Ara√∫jo.
‚Äì 2022.
128 f.: il., tab.
Orientador: Adenilton Jos√© da Silva.
Coorientador: Teresa Bernarda Ludermir.
Tese (Doutorado) ‚Äì Universidade Federal de Pernambuco. CIN, Ci√™ncia da Computa√ß√£o,
Recife, 2022.
Inclui refer√™ncias. Inclui ap√™ndice.
1. Computa√ß√£o qu√¢ntica. 2. Prepara√ß√£o de estados. 3. Otimiza√ß√£o de circuitos. 4.Estados
aproximados. I. Silva, Adenilton jose de (orientador).
II. Ludermir, Teresa Bernarda
(coorientadora). III T√≠tulo.
006.31
CDD (23. ed.)
UFPE - CCEN 2022-143

Israel Ferraz de Araujo
 ‚ÄúOtimiza√ß√£o de Circuitos para a Inicializa√ß√£o de Estados Qu√¢nticos‚Äù
Tese de Doutorado apresentada ao Programa
de  P√≥s-Gradua√ß√£o  em  Ci√™ncia  da
Computa√ß√£o  da  Universidade  Federal  de
Pernambuco, como requisito parcial para a
obten√ß√£o do t√≠tulo de Doutor em Ci√™ncia da
Computa√ß√£o.  √Årea  de  Concentra√ß√£o:
Intelig√™ncia Computacional.
Aprovado em: 01/09/2022.
_____________________________________________________
Orientador: Prof. Dr. Adenilton Jos√© da Silva
BANCA EXAMINADORA
_______________________________________________________
Prof. Dr. Stefan Michael Blawid
Centro de Inform√°tica / UFPE
________________________________________________________
Prof. Dr. Ant√¥nio Murilo Santos Macedo
Departamento de F√≠sica / UFPE
________________________________________________________
Prof. Dr. Wilson Rosa de Oliveira Junior
Departamento de Estat√≠stica e Inform√°tica / UFRPE
________________________________________________________
Prof. Dr. Leon Denis da Silva
Departamento de Matem√°tica / UFRPE
________________________________________________________
Profa. Dra. Samura√≠ Gomes de Aguiar Brito
Itau Unibanco, Grupo de Tecnologias Emergentes

Dedico esta tese a toda minha fam√≠lia, amigos e professores. Seu suporte e confian√ßa s√£o
fundamentais.

AGRADECIMENTOS
Aos colegas, pelo companheirismo, amizade e ajuda.
Aos professores, pelo empenho, comprometimento, compreens√£o e paci√™ncia.
Ao amigo e compadre Rui Ribeiro, pelo permanente apoio e incentivo.
√Ä fam√≠lia, por ser presente, sempre.
√Ä minha esposa Bruna e √† minha filha, Ingrid, pelo amor e confian√ßa incondicionais.
Ao professor Wilson de Oliveira, que influenciou minha vida profissional e pessoal com sua
criatividade inspiradora.
√Ä professora e coorientadora Teresa Ludermir, que me recebeu de bra√ßos abertos e apoiou em
todos os momentos.
Ao professor e orientador Adenilton da Silva, por quem eu adquiri uma admira√ß√£o profunda e
cuja aten√ß√£o e cren√ßa s√£o importantes. Obrigado.
Este trabalho foi financiado pela Funda√ß√£o de Amparo √† Ci√™ncia e Tecnologia de Pernambuco
(FACEPE), pelo Conselho Nacional de Desenvolvimento Cient√≠fico e Tecnol√≥gico (CNPq) e
pela Coordena√ß√£o de Aperfei√ßoamento de Pessoal de N√≠vel Superior (Capes).

No man is an island entire of itself; every man is a piece of the continent,
a part of the main; if a clod be washed away by the sea, Europe is the less,
as well as if a promontory were, as well as any manner of thy friends or of
thine own were; any man‚Äôs death diminishes me, because I am involved in
mankind. And therefore never send to know for whom the bell tolls; it tolls
for thee. (DONNE, 1624, p.108).

RESUMO
A teoria dos algoritmos qu√¢nticos promete benef√≠cios sem precedentes ao utilizar as leis da
mec√¢nica qu√¢ntica para resolver certos problemas computacionais. Entretanto, alguns desafios
impedem que tais vantagens se apliquem a todos os algoritmos qu√¢nticos. Entre esses desafios
est√° o desenvolvimento de uma codifica√ß√£o eficiente de dados cl√°ssicos em um estado qu√¢ntico.
Em aplica√ß√µes pr√°ticas, o custo para carregar a informa√ß√£o cl√°ssica em um dispositivo qu√¢n-
tico pode dominar o custo computacional assint√≥tico do algoritmo. Foram propostos diversos
m√©todos baseados em circuitos para codificar dados cl√°ssicos nas amplitudes de probabilidade
de um estado qu√¢ntico. Entretanto, esses m√©todos produzem circuitos com complexidade que
cresce linearmente com o tamanho do dado, anulando o benef√≠cio da aplica√ß√£o qu√¢ntica. O
objetivo principal deste trabalho √© reduzir a complexidade computacional dos circuitos para
a inicializa√ß√£o de estados qu√¢nticos. As duas estrat√©gias utilizadas para alcan√ßar tal objetivo
exploram a troca de complexidade temporal por espacial ou a transfer√™ncia de complexidade
computacional para um computador cl√°ssico. A primeira estrat√©gia reinterpreta m√©todos al-
g√©bricos para a decomposi√ß√£o de estados qu√¢nticos como caminhadas ao longo de √°rvores
bin√°rias. A segunda investiga o grau de emaranhamento de biparti√ß√µes do estado qu√¢ntico
atrav√©s da decomposi√ß√£o de Schmidt. Os m√©todos baseados em √°rvore alcan√ßam uma redu√ß√£o
exponencial na profundidade dos circuitos, em compara√ß√£o √†s abordagens existentes. Os base-
ados na decomposi√ß√£o de Schmidt produzem circuitos de complexidade vari√°vel, proporcional
ao emaranhamento do estado. A perspectiva √© que o resultado desta tese auxilie os profissionais
da computa√ß√£o qu√¢ntica durante a era dos dispositivos ruidosos de escala intermedi√°ria.
Palavras-chave: computa√ß√£o qu√¢ntica; prepara√ß√£o de estados; otimiza√ß√£o de circuitos; esta-
dos aproximados.

ABSTRACT
The theory of quantum algorithms promises unprecedented benefits by using the laws of
quantum mechanics to solve some computational problems. However, challenges prevent such
advantages from applying to all quantum algorithms. Among these challenges is the develop-
ment of an efficient encoding of classical data into a quantum state. In practical applications,
the cost to load classical information into a quantum device can dominate the asymptotic com-
putational cost of the algorithm. Several circuit-based methods have been proposed to encode
classical data into the probability amplitudes of a quantum state. However, these methods
produce circuits with complexity that grows linearly with data size, negating the quantum
application benefit. The main goal of this work is to reduce the computational complexity
of quantum state initialization circuits. The two strategies to achieve this goal exploit ex-
changing temporal complexity for spatial complexity or transferring computational complexity
to a classical computer. The first strategy reinterprets algebraic methods for quantum state
decomposition as a walk along binary trees. The second investigates the degree of entan-
glement of quantum state bipartitions via Schmidt decomposition. The tree-based methods
achieve an exponential reduction in circuit depth compared to existing approaches. Those
based on Schmidt decomposition produce circuits of varying complexity, proportional to the
entanglement of the state. The perspective is that the result of this thesis will assist quantum
computing practitioners during the noisy intermediate-scale quantum era.
Keywords: quantum computing; state preparation; circuit optimization; approximate states.

LISTA DE FIGURAS
Figura 1 ‚Äì Processo de prepara√ß√£o de estados qu√¢nticos. . . . . . . . . . . . . . . . .
16
Figura 2 ‚Äì Computa√ß√£o qu√¢ntica com entrada cl√°ssica. . . . . . . . . . . . . . . . . .
17
Figura 3 ‚Äì Mapeamento do vetor de entrada cl√°ssico em um estado qu√¢ntico. . . . . .
18
Figura 4 ‚Äì Representa√ß√£o de estados qu√¢nticos uniforme e arbitr√°rio.
. . . . . . . . .
19
Figura 5 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits. . . . . . . . . . . . .
23
Figura 6 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits sem simplifica√ß√µes. . .
24
Figura 7 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits com simplifica√ß√µes. . .
24
Figura 8 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits at√© uma diagonal.
. .
25
Figura 9 ‚Äì Identidades utilizadas para a decomposi√ß√£o cosseno-seno (CSD) de opera-
dores qu√¢nticos.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
Figura 10 ‚Äì Circuito para a decomposi√ß√£o cosseno-seno (CSD) de um operador qu√¢ntico
de tr√™s qubits.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
Figura 11 ‚Äì Identidade utilizada para a decomposi√ß√£o de Shannon (QSD) de operadores
qu√¢nticos.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
Figura 12 ‚Äì Circuito para a decomposi√ß√£o de Shannon (QSD) de um operador qu√¢ntico
de dois qubits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
Figura 13 ‚Äì Codifica√ß√£o em √¢ngulos de qubits utilizando rota√ß√µes.
. . . . . . . . . . .
29
Figura 14 ‚Äì Inicializa√ß√£o de um estado qu√¢ntico de ùëõqubits usando rota√ß√µes para co-
dificar um vetor de entrada complexo de dimens√£o ùëÅ= 2ùëõnas amplitudes
do estado.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
Figura 15 ‚Äì N√∫mero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib usando a prepara√ß√£o de estados baseada em rota√ß√µes, em fun√ß√£o do
logaritmo do comprimento da entrada ùëõ= log2(ùëÅ).
. . . . . . . . . . . .
31
Figura 16 ‚Äì Inicializa√ß√£o de um estado qu√¢ntico de ùëõqubits usando a decomposi√ß√£o de
Schmidt. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
Figura 17 ‚Äì Compara√ß√£o entre o n√∫mero de CNOTs e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando as prepara√ß√µes de estados baseadas
em rota√ß√µes e na decomposi√ß√£o de Schmidt, em fun√ß√£o do logaritmo do
comprimento da entrada ùëõ= log2(ùëÅ).
. . . . . . . . . . . . . . . . . . .
34
Figura 18 ‚Äì Esquema de Knill para a decomposi√ß√£o de isometrias.
. . . . . . . . . . .
36

Figura 19 ‚Äì Otimiza√ß√£o para a decomposi√ß√£o cosseno-seno (CSD) de isometrias. . . . .
36
Figura 20 ‚Äì Esquema coluna-por-coluna para a decomposi√ß√£o de isometrias. . . . . . .
37
Figura 21 ‚Äì Esquema para a decomposi√ß√£o cosseno-seno (CSD) de isometrias. . . . . .
38
Figura 22 ‚Äì Compara√ß√£o entre o n√∫mero de qubits e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando a prepara√ß√£o de estados baseada na
decomposi√ß√£o de Schmidt e o algoritmo DCSP, em fun√ß√£o do logaritmo do
comprimento da entrada ùëõ= log2(ùëÅ).
. . . . . . . . . . . . . . . . . . .
42
Figura 23 ‚Äì Ponto de sublinearidade do algoritmo BDSP para log2(ùëÅ) = 15, indicado
pela linha vermelha em ùë†= 8. . . . . . . . . . . . . . . . . . . . . . . . .
44
Figura 24 ‚Äì Compara√ß√£o entre o n√∫mero de qubits e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando o algoritmo DCSP e o BDSP com
configura√ß√£o sublinear ùëÇ(
‚àö
ùëÅ), em fun√ß√£o do logaritmo do comprimento
da entrada ùëõ= log2(ùëÅ). . . . . . . . . . . . . . . . . . . . . . . . . . . .
44
Figura 25 ‚Äì Profundidade e n√∫mero de CNOTs do circuito produzido pelo LRSP para
carregar um vetor complexo de dimens√£o 2ùëõem um estado qu√¢ntico apro-
ximado com fidelidade ajustada pelo par√¢metro ùëö. . . . . . . . . . . . . .
45
Figura 26 ‚Äì Comparativo entre estados de 7 qubits inicializados por circuitos com 21
CNOTs constru√≠dos pelos algoritmos qGAN e BAA. . . . . . . . . . . . . .
48
Figura 27 ‚Äì Compara√ß√£o entre o n√∫mero de CNOTs e a profundidade de circuitos produ-
zidos pela biblioteca qclib utilizando o algoritmo de Schmidt e o LRSP para
inicializar estados emaranhados, em fun√ß√£o do logaritmo do comprimento
da entrada ùëõ= log2(ùëÅ). . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
Figura 28 ‚Äì Compara√ß√£o entre o n√∫mero de CNOTs e a profundidade de circuitos pro-
duzidos pela biblioteca qclib utilizando o algoritmo de Schmidt e o LRSP
para inicializar estados parcialmente emaranhados, em fun√ß√£o do logaritmo
do comprimento da entrada ùëõ= log2(ùëÅ). . . . . . . . . . . . . . . . . . .
49
Figura 29 ‚Äì Experimento para avaliar os limites das ferramentas atuais da biblioteca qclib. 50
Figura 30 ‚Äì M√©todo bidirecional usando BAA. . . . . . . . . . . . . . . . . . . . . . .
55
Figura 31 ‚Äì Decomposi√ß√£o tensorial do estado em uma sequ√™ncia de operadores atuando
em um n√∫mero crescente de qubits. . . . . . . . . . . . . . . . . . . . . .
56

Figura 32 ‚Äì Abordagem esquem√°tica. a) Um vetor de estado qu√¢ntico em nota√ß√£o de
rede tensorial √© convertido em um MPS atrav√©s da aplica√ß√£o de uma de-
composi√ß√£o de Schmidt entre qubit 1 e qubits 2, 3, 4, 6, 7, 8, e depois
qubit 2 vs. 3, 4, 5, 6, 7, 8 e assim por diante. A chamada dimens√£o de
liga√ß√£o √© escolhida durante esse procedimento. A largura da barra de liga-
√ß√£o significa a dimens√£o efetiva da liga√ß√£o. b) Reorganizando as qubits √©
poss√≠vel encontrar uma biparti√ß√£o tal que cada parti√ß√£o tenha apenas uma
pequena dimens√£o de liga√ß√£o, o que significa que estas parti√ß√µes n√£o est√£o
fortemente emaranhadas. . . . . . . . . . . . . . . . . . . . . . . . . . . . 126

LISTA DE TABELAS
Tabela 1 ‚Äì Artigos sobre prepara√ß√£o de estados.
. . . . . . . . . . . . . . . . . . . .
41
Tabela 2 ‚Äì Erro Absoluto M√©dio entre probabilidades de medi√ß√µes de estados aproxi-
mados (0 ‚â§ùëö‚â§2) de 7 qubits gerados pelo LRSP e as probabilidades
esperadas para o estado original exato (ùëö= 3).
. . . . . . . . . . . . . .
46
Tabela 3 ‚Äì Erro Absoluto M√©dio entre probabilidades de medi√ß√µes de estados apro-
ximados (ùëô> 0.00) de 7 qubits gerados pelo BAA e as probabilidades
esperadas para o estado original exato (ùëô= 0.00).
. . . . . . . . . . . . .
46
Tabela 4 ‚Äì N√∫mero de CNOTs para inicializar um estado qu√¢ntico representando dife-
rentes aproxima√ß√µes da imagem usando o BAA.
. . . . . . . . . . . . . .
50
Tabela 5 ‚Äì Sum√°rio das contribui√ß√µes com as complexidades temporal e espacial dos
circuitos produzidos pelos algoritmos. . . . . . . . . . . . . . . . . . . . .
52
Tabela 6 ‚Äì Comparativo num√©rico entre n√∫mero de qubits, CNOTs e profundidade de
circuitos constru√≠dos pelas bibliotecas qclib e IBM Qiskit usando diferentes
algoritmos para a codifica√ß√£o de vetores complexos com dimens√£o 2ùëõ. . . .
54

LISTA DE ABREVIATURAS E SIGLAS
BAA
Bounded Approximation error state preparation Algorithm
BDSP
Bidirectional quantum State Preparation
CCD
Column‚Äìby‚ÄìColumn Decomposition
CSD
Cosine-Sine Decomposition
DCSP
Divide-and-Conquer quantum State Preparation
HHL
Aram Harrow, Avinatan Hassidim and Seth Lloyd
HOSVD
High Order Singular Value Decomposition
HTF
Hierarchical Tucker Format
LRSP
Low-Rank quantum State Preparation
MAE
Mean Absolute Error
MPS
Matrix Product State
NISQ
Noisy Intermediate-Scale Quantum
qGAN
Quantum Generative Adversarial Networks
QLA
Quantum Linear Algebra
QMem
Quantum Memory
QML
Quantum Machine Learning
QSD
Quantum Shannon Decomposition
SVD
Singular Value Decomposition
VQC
Variational Quantum Classifier
ZYZ
ZYZ decomposition

SUM√ÅRIO
1
INTRODU√á√ÉO
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
1.1
MOTIVA√á√ÉO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.1.1
Complexidade computacional da prepara√ß√£o de estados qu√¢nticos . 19
1.1.2
Prepara√ß√£o de estados qu√¢nticos em dispositivos ruidosos . . . . . . 20
1.2
OBJETIVOS
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2
PRINCIPAIS FUNDAMENTOS E REFER√äNCIAS . . . . . . . . . .
22
2.1
DECOMPOSI√á√ÉO DE UNIT√ÅRIOS . . . . . . . . . . . . . . . . . . . . .
22
2.1.1
Unit√°rios de um qubit . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.1.2
Unit√°rios de dois qubits . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.1.3
Decomposi√ß√£o Cosseno-Seno . . . . . . . . . . . . . . . . . . . . . . . 25
2.1.4
Decomposi√ß√£o de Shannon Qu√¢ntica
. . . . . . . . . . . . . . . . . . 26
2.2
TIPO DE PREPARA√á√ÉO DE ESTADOS QU√ÇNTICOS . . . . . . . . . . .
28
2.2.1
Codifica√ß√£o na base
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.2.2
Codifica√ß√£o nos √¢ngulos . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.2.3
Codifica√ß√£o nas amplitudes . . . . . . . . . . . . . . . . . . . . . . . . 30
2.3
EXEMPLO DE PREPARA√á√ÉO DE ESTADOS QU√ÇNTICOS . . . . . . . .
30
2.3.1
Baseada em rota√ß√µes
. . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.3.2
Baseada na decomposi√ß√£o de Schmidt
. . . . . . . . . . . . . . . . . 33
2.4
DECOMPOSI√á√ÉO DE ISOMETRIAS
. . . . . . . . . . . . . . . . . . . .
35
2.4.1
Decomposi√ß√£o de Knill
. . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.4.2
Decomposi√ß√£o Coluna-por-Coluna . . . . . . . . . . . . . . . . . . . . 36
2.4.3
Decomposi√ß√£o Cosseno-Seno . . . . . . . . . . . . . . . . . . . . . . . 38
3
SOLU√á√ïES EXISTENTES PARA A PREPARA√á√ÉO DE ESTADOS
QU√ÇNTICOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
4
PRINCIPAIS CONTRIBUI√á√ïES . . . . . . . . . . . . . . . . . . . .
42
4.1
A DIVIDE-AND-CONQUER ALGORITHM FOR QUANTUM STATE PRE-
PARATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
4.2
CONFIGURABLE SUBLINEAR CIRCUITS FOR QUANTUM STATE PRE-
PARATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43

4.3
APPROXIMATED QUANTUM-STATE PREPARATION WITH ENTAN-
GLEMENT DEPENDENT COMPLEXITY . . . . . . . . . . . . . . . . . .
45
4.4
QCLIB: A QUANTUM COMPUTING LIBRARY . . . . . . . . . . . . . . .
49
5
CONCLUS√ÉO
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
5.1
PRINCIPAIS RESULTADOS . . . . . . . . . . . . . . . . . . . . . . . . .
51
5.1.1
Algoritmo do tipo divis√£o e conquista para a prepara√ß√£o de estados
qu√¢nticos
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
5.1.2
Algoritmo bidirecional para a prepara√ß√£o de estados qu√¢nticos . . . 52
5.1.3
Algoritmo baseado na decomposi√ß√£o de Schmidt e na aproxima√ß√£o
de baixo posto para a prepara√ß√£o de estados qu√¢nticos
. . . . . . . 52
5.1.4
Algoritmo de aproxima√ß√£o com erro limitado para a prepara√ß√£o de
estados qu√¢nticos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
5.1.5
Biblioteca de c√≥digo aberto para computa√ß√£o qu√¢ntica . . . . . . . . 53
5.2
TRABALHOS FUTUROS
. . . . . . . . . . . . . . . . . . . . . . . . . .
54
5.2.1
Big-data state preparation
. . . . . . . . . . . . . . . . . . . . . . . . 54
5.2.2
Tensor based quantum state preparation . . . . . . . . . . . . . . . . 55
5.3
OBSERVA√á√ïES FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
REFER√äNCIAS
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
AP√äNDICE A ‚Äì A DIVIDE-AND-CONQUER ALGORITHM FOR
QUANTUM STATE PREPARATION
. . . . . . .
69
AP√äNDICE B ‚Äì CONFIGURABLE SUBLINEAR CIRCUITS FOR
QUANTUM STATE PREPARATION
. . . . . . .
81
AP√äNDICE C ‚Äì APPROXIMATED QUANTUM-STATE PREPA-
RATION WITH ENTANGLEMENT DEPENDENT
COMPLEXITY . . . . . . . . . . . . . . . . . . . . 110
AP√äNDICE D ‚Äì APPROXIMATED QUANTUM-STATE PREPA-
RATION WITH ENTANGLEMENT DEPENDENT
COMPLEXITY ‚Äì SUPPLEMENTARY INFORMA-
TION . . . . . . . . . . . . . . . . . . . . . . . . . 122
AP√äNDICE E ‚Äì EMARANHAMENTO E A PREPARA√á√ÉO DE ES-
TADOS QU√ÇNTICOS . . . . . . . . . . . . . . . . 125

16
1 INTRODU√á√ÉO
O desenvolvimento dos computadores qu√¢nticos pode reduzir drasticamente o tempo para
resolver certas tarefas computacionais (ARUTE et al., 2019). O primeiro uso da computa√ß√£o
qu√¢ntica foi proposto por Feynman (1982), antes mesmo do primeiro modelo formalizado de
computa√ß√£o qu√¢ntica universal desenvolvido por Deutsch e Penrose (1985). Feynman sugeriu
uma arquitetura computacional baseada em aut√¥matos celulares com recursos qu√¢nticos e
conjecturou que tal arquitetura poderia acelerar simula√ß√µes de f√≠sica e qu√≠mica qu√¢ntica al√©m
da capacidade dos computadores cl√°ssicos. Al√©m de Feynman, pioneiros como Benioff (1980)
e Manin (1980) promoveram o desenvolvimento da computa√ß√£o qu√¢ntica. Ap√≥s pouco mais
de uma d√©cada, Grover (1996) estabeleceu um algoritmo qu√¢ntico de busca com acelera√ß√£o
quadr√°tica em rela√ß√£o ao melhor algoritmo cl√°ssico conhecido. Em seguida, Shor (1999) de-
monstrou um algoritmo qu√¢ntico de fatora√ß√£o em tempo polinomial que pode ser utilizado
para quebrar o sistema de criptografia RSA (GIDNEY; EKER√Ö, 2021; RIVEST; SHAMIR; ADLEMAN,
1978).
Figura 1 ‚Äì Processo de prepara√ß√£o de estados qu√¢nticos.
0100110101101010101010010111
0101101010001001010101110100
0101000010100010110101001010
0101000011110101101010100101
1111011010100111001011110110
0101001000100010110111011110
0101000011110101101010100101
1111011010100111001011110110
1111011010100111001011110110
Dados Cl√°ssicos
Circuito Qu√¢ntico
Tradu√ß√£o
Estado Qu√¢ntico
Fonte: Elaborada pelo autor (2022)
Recentemente, uma nova fam√≠lia de algoritmos qu√¢nticos promete ganho exponencial so-
bre os algoritmos cl√°ssicos equivalentes (AARONSON, 2015). O objetivo de tais algoritmos
s√£o problemas pr√°ticos como aprendizagem de m√°quina, clustering e solu√ß√£o de sistemas li-
neares (STOUDENMIRE; SCHWAB, 2016; SCHULD; FINGERHUTH; PETRUCCIONE, 2017; SCHULD;
PETRUCCIONE, 2018; BENEDETTI et al., 2019; LEVINE et al., 2019; BLANK et al., 2020; TRUGEN-
BERGER, 2001; TRUGENBERGER, 2002; GIOVANNETTI; LLOYD; MACCONE, 2008b; SILVA; OLI-
VEIRA; LUDERMIR, 2010; de Paula Neto et al., 2019; PARK; PETRUCCIONE; RHEE, 2019; HARROW;
HASSIDIM; LLOYD, 2009; LLOYD; MOHSENI; REBENTROST, 2014; CHILDS; KOTHARI; SOMMA,
2017; WOSSNIG; ZHAO; PRAKASH, 2018; REBENTROST et al., 2018). Vantagens em v√°rios cam-

17
pos de pesquisa e ind√∫stria s√£o esperadas com o surgimento dessas aplica√ß√µes qu√¢nticas.
Mas algumas dificuldades impedem que tais aplica√ß√µes sejam realizadas (AARONSON, 2015;
BIAMONTE et al., 2017; LEYMANN; BARZEN, 2020).
Figura 2 ‚Äì Computa√ß√£o qu√¢ntica com entrada cl√°ssica.
Dados Cl√°ssicos
Pr√©-processamento
Inicializa√ß√£o
de Estados
Transforma√ß√£o
Unit√°ria
Medi√ß√£o
P√≥s-processamento
Regime Qu√¢ntico
Prepara√ß√£o de Estados Qu√¢nticos
Computa√ß√£o
Qu√¢ntica
Extra√ß√£o de Resultados Qu√¢nticos
em Dados Cl√°ssicos
Fonte: Elaborada pelo autor (2022)
Um dos problemas em aberto que impedem aplica√ß√µes pr√°ticas da computa√ß√£o qu√¢ntica √©
o desenvolvimento de uma codifica√ß√£o eficiente de dados cl√°ssicos em um estado qu√¢ntico (BI-
AMONTE et al., 2017; AARONSON, 2015; LEYMANN; BARZEN, 2020; TANG, 2021). Para efetuar
essa codifica√ß√£o, o dado cl√°ssico √© convertido para uma forma vetorial e um processo traduz
a informa√ß√£o em opera√ß√µes realizadas em um computador qu√¢ntico, comumente codificadas
por um circuito qu√¢ntico (Figura 1) (NIELSEN; CHUANG, 2010). A execu√ß√£o desse circuito cria
o estado inicial pretendido. V√°rios m√©todos baseados em circuitos qu√¢nticos foram propostos
para codificar esses dados como amplitudes de probabilidade de um estado qu√¢ntico (VEN-
TURA; MARTINEZ, 1999; GROVER, 2000; LONG; SUN, 2001; MOTTONEN et al., 2005; SHENDE;
BULLOCK; MARKOV, 2006; PLESCH; BRUKNER, 2011; CORTESE; BRAJE, 2018). Entretanto, eles
requerem profundidade do circuito qu√¢ntico ‚Äì caminho mais longo do circuito, representado
pelo n√∫mero de operadores nesse caminho ‚Äì que cresce linearmente com o tamanho dos dados.
O HHL, criado por Harrow, Hassidim e Lloyd (2009), √© um exemplo de algoritmo qu√¢ntico
que sofre de tal problema. Seu objetivo √© solucionar o sistema linear ùê¥x = b. Para isso, o HHL
expressa o vetor b ‚ààCùëÅcomo o estado qu√¢ntico |ùëè‚ü©usando log2(ùëÅ) qubits e o vetor x como
o estado qu√¢ntico |ùë•‚ü©. Dessa maneira, temos a equa√ß√£o ùê¥|ùë•‚ü©= |ùëè‚ü©, que pode ser solucionada
multiplicando ambos os lados pela inversa ùê¥‚àí1. Para encontrar |ùë•‚ü©, o algoritmo HHL produz
um circuito qu√¢ntico com profundidade ùëÇ(log2
2(ùëÅ)), enquanto o algoritmo cl√°ssico precisa
de ùëÇ(ùëÅlog2(ùëÅ)) passos, caracterizando a vantagem qu√¢ntica exponencial. Mas h√° ressalvas
importantes quanto ao HHL (AARONSON, 2015). Uma delas √© que o vetor b precisa ser
codificado rapidamente na mem√≥ria do computador qu√¢ntico, preparando o estado |ùëè‚ü©=
‚àëÔ∏ÄùëÅ‚àí1
ùëñ=0 ùëèùëñ|ùëñ‚ü©. Preparar esse estado utilizando qualquer m√©todo existente requer custo na ordem
de ùëÅpassos, anulando a vantagem exponencial do HHL em seu princ√≠pio.
Na computa√ß√£o qu√¢ntica, a etapa de codifica√ß√£o dos dados cl√°ssicos em um estado qu√¢n-

18
Figura 3 ‚Äì Mapeamento do vetor de entrada cl√°ssico em um estado qu√¢ntico.
Inicializa√ß√£o
de Estados
Regime Qu√¢ntico
Prepara√ß√£o de Estados Qu√¢nticos
Pr√©-processamento
Fonte: Elaborada pelo autor (2022)
tico √© chamada de Prepara√ß√£o de Estados Qu√¢nticos (Figura 2 e Figura 3) (SCHULD; PETRUC-
CIONE, 2018). O foco desta tese √© atuar na prepara√ß√£o de estados qu√¢nticos para produzir
circuitos eficientes para a inicializa√ß√£o de estados. Essa etapa recebe como entrada um ve-
tor de dados cl√°ssico e produz como sa√≠da um estado qu√¢ntico (Figura 3) que ser√° utilizado
pela aplica√ß√£o qu√¢ntica na etapa seguinte (Computa√ß√£o Qu√¢ntica, Figura 2). A prepara√ß√£o
de estados √© dividida em duas fases chamadas Pr√©-processamento e Inicializa√ß√£o de Estados
(Figura 2 e Figura 3). A primeira fase ocorre no regime cl√°ssico e tem como objetivo construir
um circuito qu√¢ntico com a sequ√™ncia de instru√ß√µes, na forma de operadores, para a produ-
√ß√£o do estado. A segunda fase ocorre no regime qu√¢ntico e executa as instru√ß√µes do circuito
criado no passo anterior para produzir efetivamente o estado pretendido. As complexidades
de ambas as fases devem ser consideradas para estimar o esfor√ßo necess√°rio para produzir o
estado qu√¢ntico.
O restante deste cap√≠tulo est√° organizado da seguinte forma. A Se√ß√£o 1.1 apresenta a mo-
tiva√ß√£o para a busca de uma prepara√ß√£o eficiente de estados qu√¢nticos. A Se√ß√£o 1.2 descreve
os objetivos desta tese. O Cap√≠tulo 2 revisa os principais fundamentos utilizados no desenvol-
vimento deste trabalho. O Cap√≠tulo 3 comenta algumas solu√ß√µes existentes para a prepara√ß√£o
de estados qu√¢nticos. O Cap√≠tulo 4 resume as contribui√ß√µes desta tese, incluindo a biblioteca
de c√≥digo aberto qclib (ARAUJO et al., 2022) usada para produzir os gr√°ficos e tabelas deste
trabalho. Por fim, o Cap√≠tulo 5 apresenta a conclus√£o e os principais resultados. O detalha-
mento de todos os resultados e contribui√ß√µes est√° nos ap√™ndices A, B, C e D. O Ap√™ndice E
discute a rela√ß√£o entre emaranhamento e a prepara√ß√£o de estados qu√¢nticos.

19
1.1
MOTIVA√á√ÉO
1.1.1
Complexidade computacional da prepara√ß√£o de estados qu√¢nticos
O pior caso de complexidade na prepara√ß√£o de um estado qu√¢ntico arbitr√°rio (dados n√£o
estruturados) √© exponencial no n√∫mero de qubits (SHENDE; BULLOCK; MARKOV, 2006). Por este
motivo, as vantagens qu√¢nticas (BIAMONTE et al., 2017) mais significativas ocorrem quando
o algoritmo qu√¢ntico opera em um estado de entrada que √© f√°cil de preparar (DEUTSCH;
JOZSA, 1992; HOGG; HUBERMAN; WILLIAMS, 1996; GROVER, 1996; SIMON, 1997; TERHAL;
SMOLIN, 1998; SHOR, 1999), tais como a superposi√ß√£o uniforme de todos os estados da base
computacional (MOZAFARI et al., 2020; MOZAFARI et al., 2021), os estados esparsos (MALVETTI;
ITEN; COLBECK, 2021; VERAS; SILVA; SILVA, 2022; GLEINIG; HOEFLER, 2021) e as distribui√ß√µes
de probabilidade (ZOUFAL; LUCCHI; WOERNER, 2019; NAKAJI et al., 2021; MARIN-SANCHEZ;
GONZALEZ-CONDE; SANZ, 2021).
Figura 4 ‚Äì Representa√ß√£o de estados qu√¢nticos uniforme e arbitr√°rio.
0
5
10
15
20
25
30
computational basis state
0.00
0.02
0.04
0.06
0.08
0.10
probability
0
5
10
15
20
25
30
computational basis state
0.00
0.02
0.04
0.06
0.08
0.10
probability
Fonte: Elaborada pelo autor (2022)
Para algoritmos que dependam do carregamento de dados em um estado qu√¢ntico arbitr√°-
rio, uma maneira eficiente de preparar os estados de entrada √© um pr√©-requisito fundamental
para a vantagem qu√¢ntica (R√∏NNOW et al., 2014; AARONSON, 2015; BIAMONTE et al., 2017;
HARROW; HASSIDIM; LLOYD, 2009; TANG, 2021). V√°rias pesquisas se concentram no desen-
volvimento de algoritmos que sup√µem uma inicializa√ß√£o eficiente dos dados. Tal suposi√ß√£o √©
o que leva √†s declara√ß√µes de vantagens exponenciais anunciadas por diversos trabalhos (WI-
EBE; BRAUN; LLOYD, 2012; LLOYD; MOHSENI; REBENTROST, 2014; REBENTROST; MOHSENI;
LLOYD, 2014; WIEBE; KAPOOR; SVORE, 2014; AMIN et al., 2018; DUNJKO; TAYLOR; BRIEGEL,

20
2016; KIEFEROV√Å; WIEBE, 2017; LOW; YODER; CHUANG, 2014; WIEBE; GRANDADE, 2017; WIEBE;
KAPOOR; SVORE, 2016).
1.1.2
Prepara√ß√£o de estados qu√¢nticos em dispositivos ruidosos
A solu√ß√£o para o problema da complexidade na prepara√ß√£o de estados torna-se ainda mais
relevante sob as limita√ß√µes do hardware qu√¢ntico ruidoso de escala intermedi√°ria (NISQ, do in-
gl√™s Noisy Intermediate-Scale Quantum) (MOLL et al., 2018; PRESKILL, 2018) como n√∫mero de
qubits limitado, conectividade restrita entre os qubits, erros de portas e decoer√™ncia (WILLSCH
et al., 2017). Tais limita√ß√µes impedem que t√©cnicas de corre√ß√£o de erros sejam aplicadas e tam-
b√©m restringem o uso de tais dispositivos a aplica√ß√µes com circuitos de baixa profundidade.
Uma alternativa √© a produ√ß√£o de solu√ß√µes adaptadas √†s limita√ß√µes dos dispositivos NISQ.
Por causa do ru√≠do e do n√∫mero limitado de qubits, a profundidade de um algoritmo
qu√¢ntico ‚Äì correspondente √† profundidade do circuito qu√¢ntico produzido pelo algoritmo ‚Äì e
tamb√©m sua largura ‚Äì n√∫mero de qubits do circuito ‚Äì precisam ser controladas. A Equa√ß√£o (1.1)
pode ser usada para determinar os limites para a execu√ß√£o de um algoritmo num determinado
dispositivo qu√¢ntico (LEYMANN; BARZEN, 2020)
ùëë¬∑ ùë§‚â™1
ùúñ
(1.1)
onde ùúñ√© a taxa de erro do computador qu√¢ntico, ùëëa profundidade do algoritmo, e ùë§a lar-
gura (WILLSCH et al., 2017). Portanto, se um algoritmo requer profundidade grande, deve usar
apenas poucos qubits e assim pode ser simulado num computador cl√°ssico. Mas se um algo-
ritmo requer muitos qubits, precisa ser raso. Isso implica que a vantagem qu√¢ntica ‚Äì solu√ß√µes
que n√£o podem ser simuladas em computadores cl√°ssicos com espa√ßo/tempo vi√°vel (PRES-
KILL, 2012; PRESKILL, 2018) ‚Äì em dispositivos sem corre√ß√£o de erros tem que ser exibida por
algoritmos rasos, que possuam poucas camadas de portas.
1.2
OBJETIVOS
O objetivo principal desta tese √© reduzir a complexidade computacional de circuitos ‚Äì
profundidade e largura ‚Äì para a inicializa√ß√£o de estados qu√¢nticos. Os objetivos espec√≠ficos
s√£o:

21
1. Trocar profundidade do circuito qu√¢ntico por largura para reduzir a complexidade tempo-
ral da inicializa√ß√£o de estados exatos (Divide-and-Conquer quantum State Preparation,
Se√ß√£o 4.1 e Bidirectional quantum State Preparation, Se√ß√£o 4.2).
2. Utilizar o emaranhamento como recurso computacional para otimizar os circuitos qu√¢n-
ticos produzidos para a inicializa√ß√£o de estados exatos, reduzindo a quantidade de ope-
ra√ß√µes necess√°rias (Low-Rank quantum State Preparation, Se√ß√£o 4.3).
3. Manipular o emaranhamento para produzir estados aproximados de menor complexidade,
otimizados para a inicializa√ß√£o em dispositivos NISQ (Bounded Approximation error state
preparation Algorithm, Se√ß√£o 4.3).

22
2 PRINCIPAIS FUNDAMENTOS E REFER√äNCIAS
2.1
DECOMPOSI√á√ÉO DE UNIT√ÅRIOS
A decomposi√ß√£o de unit√°rios permite que os algoritmos qu√¢nticos, baseados em circuitos,
especifiquem operadores arbitr√°rios que podem ser executados nos computadores qu√¢nticos.
Sem essa decomposi√ß√£o, os algoritmos qu√¢nticos teriam que ser constru√≠dos utilizando apenas
o conjunto universal de portas do dispositivo alvo (DIVINCENZO, 1995; BARENCO, 1995; LLOYD,
1995; DEUTSCH; BARENCO; EKERT, 1995).
2.1.1
Unit√°rios de um qubit
Um operador arbitr√°rio de um qubit pode ser decomposto como uma sequ√™ncia de no
m√°ximo tr√™s portas ùëÖùë¶e ùëÖùëß(BARENCO et al., 1995; NIELSEN; CHUANG, 2010) usando a de-
composi√ß√£o ZYZ1 (SHENDE; MARKOV; BULLOCK, 2004a). Dada qualquer matriz unit√°ria ùëà2√ó2,
existem √¢ngulos ùúë, ùõº, ùõΩ, e ùõæque satisfazem a seguinte equa√ß√£o:
ùëà= ùëíùëñùúëùëÖùëß(ùõº)ùëÖùë¶(ùõΩ)ùëÖùëß(ùõæ).
(2.1)
Tal decomposi√ß√£o √© poss√≠vel porque as linhas e colunas de matrizes unit√°rias s√£o vetores
ortonormais, portanto toda matriz unit√°ria 2 √ó 2 pode ser escrita na forma (BARENCO et al.,
1995; NIELSEN; CHUANG, 2010)
‚é°
‚é¢‚é¢‚é£
ùëíùëñ(ùúë+ ùõº
2 + ùõæ
2 ) cos ùõΩ
2
ùëíùëñ(ùúë+ ùõº
2 ‚àíùõæ
2 ) sin ùõΩ
2
‚àíùëíùëñ(ùúë‚àíùõº
2 + ùõæ
2 ) sin ùõΩ
2
ùëíùëñ(ùúë‚àíùõº
2 ‚àíùõæ
2 ) cos ùõΩ
2
‚é§
‚é•‚é•‚é¶.
(2.2)
A partir da matriz (2.2), a fatora√ß√£o na forma da express√£o (2.1) √© imediata.
Para o caso em que ùëà2√ó2 pertence ao grupo especial unit√°rio ùëÜùëà(2), a propriedade
det(ùëà) = 1 implica que ùëíùëñùúë= ¬±1. Assim, a express√£o (2.1) pode ser simplificada para:
ùëà= ùëÖùëß(ùõº)ùëÖùë¶(ùõΩ)ùëÖùëß(ùõæ).
(2.3)
1
A escolha dos eixos ùë¶e ùëß√© arbitr√°ria. Qualquer par de vetores ortogonais pode ser escolhido.

23
2.1.2
Unit√°rios de dois qubits
A s√≠ntese de operadores de dois qubits √© relevante para a otimiza√ß√£o de circuitos maiores.
A tecnologia atual dos dispositivos qu√¢nticos n√£o √© capaz de executar opera√ß√µes que atuem
em tr√™s ou mais qubits. Tais opera√ß√µes precisam ser decompostas utilizando portas menores.
Portanto, implementar uma computa√ß√£o qu√¢ntica como uma sequ√™ncia de portas de dois qubits
√© de fundamental import√¢ncia. Por sua vez, as portas arbitr√°rias de dois qubits precisam ser
decompostas usando a porta padr√£o de dois qubits do conjunto de portas nativas do dispositivo
alvo, al√©m de portas de um qubit (DIVINCENZO, 2000). O CNOT √© utilizado como o operador
padr√£o de dois qubits na maioria dos trabalhos te√≥ricos e pr√°ticos (WILLIAMS, 2011), mas sua
implementa√ß√£o √© ordens de magnitude (‚àº102) mais propensa a erros do que a implementa√ß√£o
das portas de um qubit. Por esse motivo, uma forma de calcular o custo da execu√ß√£o dos
circuitos em dispositivos qu√¢nticos √© em termos do n√∫mero de CNOTs. Sendo assim, o custo
da decomposi√ß√£o de operadores de dois qubits precisa ser minimizado, pois tem impacto direto
no custo das aplica√ß√µes qu√¢nticas.
De maneira geral, todo operador de dois qubits pode ser representado pelo circuito da
Figura 5 utilizando dezoito portas elementares ‚Äì tr√™s CNOTs e quinze rota√ß√µes de um qu-
bit (SHENDE; MARKOV; BULLOCK, 2004a; SHENDE; MARKOV; BULLOCK, 2004b).
Figura 5 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits.
R‚Ä†
z
R‚Ä†
y
Ry
Fonte: Elaborada pelo autor (2022)
Para demonstrar que essa decomposi√ß√£o √© poss√≠vel, come√ßamos reescrevendo ùëà‚ààùëà(4)
como
ùëà‚Ä≤ = ùëíùëñùúã
4 SWAP2
1ùëà‚ààùëÜùëà(4).
(2.4)
A decomposi√ß√£o can√¥nica de ùëÜùëà(4) (KHANEJA; BROCKETT; GLASER, 2001) afirma que existe
ùëé, ùëè, ùëêe ùëë‚ààùëÜùëà(2) e a diagonal ùõøna base m√°gica (HILL; WOOTTERS, 1997; KRAUS; CIRAC,
2001) de maneira que
ùëà‚Ä≤ = (ùëé‚äóùëè)ùõø(ùëê‚äóùëë).
(2.5)
Podemos reescrever a express√£o (2.5) como ùëà‚Ä≤ = (ùëé‚äóùëè)ùê∏Œîùê∏‚Ä†(ùëê‚äóùëë), onde Œî √© uma
diagonal na base computacional, usando a matriz ùê∏de mudan√ßa de base (operador de dois

24
qubits que mapeia a base computacional para a base m√°gica) (KHANEJA; BROCKETT; GLASER,
2001) e definindo ùëÜùëö:= ùëÖùëö(ùúã/2) (ùëö‚àà{ùë•, ùë¶, ùëß})
ùê∏=
‚àö
2
2
‚é°
‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é£
1
ùëñ
0
0
0
0
ùëñ
1
0
0
ùëñ
‚àí1
1
‚àíùëñ
0
0
‚é§
‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é¶
=
Sz
S‚Ä†
x
S‚Ä†
z
(2.6)
Sabendo que toda diagonal ùëÜùëà(4) pode ser representada como (KHANEJA; BROCKETT; GLA-
SER, 2001)
Œî =
‚é°
‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é£
ùëíùëñùúÉ
0
0
0
0
ùëíùëñùúë
0
0
0
0
ùëíùëñùúì
0
0
0
0
ùëí‚àíùëñ(ùúÉ+ùúë+ùúì)
‚é§
‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é¶
=
R‚Ä†
z(Œ∏ + œï)
R‚Ä†
z(Œ∏ + œà)
Rz(œï + œà)
(2.7)
constru√≠mos o circuito da Figura 6 para ùëà‚Ä≤:
Figura 6 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits sem simplifica√ß√µes.
E‚Ä†
‚àÜ
E
c
S‚Ä†
z
R‚Ä†
z
Sz
a
d
Sz
Sx
R‚Ä†
z
Rz
S‚Ä†
x
S‚Ä†
z
b
Fonte: Elaborada pelo autor (2022)
O circuito acima pode ser simplificado fazendo ùëëùëÜùëß= ùëë‚Ä≤, ùëÜ‚Ä†
ùëßùëè= ùëè‚Ä≤, ùëÜ‚Ä†
ùëßùëÖ‚Ä†
ùëßùëÜùëß= ùëÖ‚Ä†
ùëß, ùëÜùë•ùëÖ‚Ä†
ùëß=
ùëÖ‚Ä†
ùë¶ùëÜùë•e ùëÖùëßùëÜ‚Ä†
ùë•= ùëÜ‚Ä†
ùë•ùëÖùë¶(‚Éóùëõ‚ä•‚Éóùëö‚àí‚ÜíùëÜùëõùëÖùëö= ùëÖùëõ√óùëöùëÜùëõ), e cancelando ùëÜùë•e ùëÜ‚Ä†
ùë•nas duas √∫ltimas
express√µes, como na Figura 7.
Figura 7 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits com simplifica√ß√µes.
c
R‚Ä†
z
a
d‚Ä≤
R‚Ä†
y
Ry
b‚Ä≤
=
c
R‚Ä†
z
b‚Ä≤
d‚Ä≤
R‚Ä†
y
Ry
a
Fonte: Elaborada pelo autor (2022)
Ainda na Figura 7, os dois CNOTs adjacentes s√£o substitu√≠dos por um CNOT e um SWAP.
O SWAP foi movido para o fim do circuito e ser√° cancelado pelo SWAP da express√£o (2.4).

25
Portanto, o circuito da Figura 5 representa o unit√°rio ùëà, com exce√ß√£o apenas da fase global
ùëíùëñùúã
4 que precisa ser corrigida.
Ainda √© poss√≠vel alcan√ßar um circuito mais otimizado que o da Figura 5 para os casos em que
v√°rios operadores adjacentes atuam no mesmo conjunto de qubits. Um operador ùëà‚Ä≤‚Ä≤ ‚ààùëÜùëà(4)
pode ser representado usando apenas dois CNOTs e portas de um qubit ùëÜùëà(2) arbitr√°rias se
tr [ùõæ(ùëà‚Ä≤‚Ä≤)] √© real (SHENDE; BULLOCK; MARKOV, 2004c), onde ùõæ(ùëà‚Ä≤‚Ä≤) = (ùê∏‚Ä†ùëà‚Ä≤‚Ä≤ùê∏)(ùê∏‚Ä†ùëà‚Ä≤‚Ä≤ùê∏)ùëá.
Sabendo que o operador arbitr√°rio ùëà‚Ä≤ pode ser decomposto como ùëà‚Ä≤ = ùê∑ùëà‚Ä≤‚Ä≤, onde ùê∑√© um
operador diagonal, temos o circuito da Figura 8 (SHENDE; BULLOCK; MARKOV, 2006).
Figura 8 ‚Äì Decomposi√ß√£o de unit√°rios arbitr√°rios de dois qubits at√© uma diagonal.
D
Ry
Ry
Fonte: Elaborada pelo autor (2022)
Dessa maneira, a diagonal pode migrar para o pr√≥ximo operador de dois qubits adjacente. Esse
outro operador √© decomposto da mesma forma, continuando o processo de migrar a diagonal
at√© restar apenas um operador. Como um CNOT √© salvo para cada operador de dois qubits
menos o √∫ltimo, temos uma redu√ß√£o total de ùëÄ‚àí1 CNOTs em rela√ß√£o √† decomposi√ß√£o da
Figura 5, onde ùëÄ√© o n√∫mero total de operadores adjacentes.
2.1.3
Decomposi√ß√£o Cosseno-Seno
A decomposi√ß√£o cosseno-seno de unit√°rios (Cosine-Sine Decomposition ou CSD) √© baseada
na t√©cnica matem√°tica de mesmo nome decomposi√ß√£o cosseno-seno (STEWART; SUN, 1990;
PAIGE; WEI, 1994). Supondo um unit√°rio ùëà‚ààCùëÅ√óùëÅ, onde ùëÅ√© par, o teorema CSD afirma
que ùëàsempre pode ser decomposto na seguinte forma
ùëà= ùëÖùê∑ùëêùë†ùêø=
‚é°
‚é¢‚é¢‚é£
ùëÖ0
0
0
ùëÖ1
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùê∂
‚àíùëÜ
ùëÜ
ùê∂
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùêø0
0
0
ùêø1
‚é§
‚é•‚é•‚é¶,
(2.8)
composta por unit√°rios ùêøùëñ, ùëÖùëñ‚ààCùëÅ/2√óùëÅ/2 e matrizes diagonais reais ùê∂e ùëÜtais que ùê∂2+ùëÜ2 =
IùëÅ/2, onde ùê∂= diag(cos(ùúÉ0), . . . , cos(ùúÉùëÅ/2)) e ùëÜ= diag(sin(ùúÉ0), . . . , sin(ùúÉùëÅ/2)).
O algoritmo CSD (TUCCI, 1999; SHENDE; BULLOCK; MARKOV, 2006) aplica a decomposi√ß√£o
cosseno-seno recursivamente. Inicia com o operador ùëàde dimens√£o ùëÅ√ó ùëÅ, onde ùëÅ= 2ùëõe

26
ùëõ‚â•1 √© o n√∫mero de qubits. ùëà√© decomposto na matriz ùê∑ùëêùë†, dois unit√°rios ùêøùëñe dois unit√°rios
ùëÖùëñ(Equa√ß√£o 2.8 e Figura 9). Em seguida, os quatro unit√°rios produzidos no passo anterior s√£o
decompostos em quatro matrizes centrais e dezesseis unit√°rios, como na Equa√ß√£o (2.9). Os
unit√°rios formam quatro conjuntos ùëÖùëÖ0 +ùëÖùëÖ1, ùêøùëÖ0 +ùêøùëÖ1, ùëÖùêø0 +ùëÖùêø1 e ùêøùêø0 +ùêøùêø1 (Figura 10),
cada conjunto com quatro operadores.
ùëà=
‚é°
‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é£
‚é°
‚é¢‚é¢‚é£
ùëÖùëÖ0,0
0
0
ùëÖùëÖ0,1
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùê∂ùëÖ0
‚àíùëÜùëÖ0
ùëÜùëÖ0
ùê∂ùëÖ0
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùêøùëÖ0,0
0
0
ùêøùëÖ0,1
‚é§
‚é•‚é•‚é¶
0
0
‚é°
‚é¢‚é¢‚é£
ùëÖùëÖ1,0
0
0
ùëÖùëÖ1,1
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùê∂ùëÖ1
‚àíùëÜùëÖ1
ùëÜùëÖ1
ùê∂ùëÖ1
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùêøùëÖ1,0
0
0
ùêøùëÖ1,1
‚é§
‚é•‚é•‚é¶
‚é§
‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùê∂
‚àíùëÜ
ùëÜ
ùê∂
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é£
‚é°
‚é¢‚é¢‚é£
ùëÖùêø0,0
0
0
ùëÖùêø0,1
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùê∂ùêø0
‚àíùëÜùêø0
ùëÜùêø0
ùê∂ùêø0
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùêøùêø0,0
0
0
ùêøùêø0,1
‚é§
‚é•‚é•‚é¶
0
0
‚é°
‚é¢‚é¢‚é£
ùëÖùêø1,0
0
0
ùëÖùêø1,1
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùê∂ùêø1
‚àíùëÜùêø1
ùëÜùêø1
ùê∂ùêø1
‚é§
‚é•‚é•‚é¶
‚é°
‚é¢‚é¢‚é£
ùêøùêø1,0
0
0
ùêøùêø1,1
‚é§
‚é•‚é•‚é¶
‚é§
‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é¶
.
(2.9)
A recurs√£o continua at√© que os unit√°rios possuam dimens√£o 2√ó2 (operadores de um qubit).
No fim, ap√≥s ùëõ‚àí1 itera√ß√µes, haver√° 2ùëõ‚àí1 conjuntos de unit√°rios, cada um com 2ùëõ‚àí1 operadores
de um qubit. Cada conjunto corresponde a um operador uniformemente controlado pelos qubits
mais significativos e aplicado ao qubit menos significativo (Figura 9) (SHENDE; BULLOCK;
MARKOV, 2006). Esses conjuntos s√£o separados pelos operadores centrais (Figura 10), que
Figura 9 ‚Äì Identidades utilizadas para a decomposi√ß√£o cosseno-seno (CSD) de operadores qu√¢nticos.
U
=
‚ñ°
‚ñ°
‚ñ°
Ry
L
R
‚ñ°
U
=
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
Ry
L
R
Fonte: Elaborada pelo autor (2022)
possuem a mesma estrutura das rota√ß√µes ùëÖùë¶uniformemente controladas aplicadas ao qubit
correspondente ao passo da recurs√£o (SHENDE; BULLOCK; MARKOV, 2006). Essa decomposi√ß√£o
requer um total de 4ùëõ‚àí2ùëõ+1 CNOTs.
2.1.4
Decomposi√ß√£o de Shannon Qu√¢ntica
O algoritmo para a decomposi√ß√£o de Shannon Qu√¢ntica (Quantum Shannon Decomposi-
tion ou QSD) √© uma varia√ß√£o do algoritmo CSD apresentado na Se√ß√£o 2.1.3. A mudan√ßa √©

27
Figura 10 ‚Äì Circuito para a decomposi√ß√£o cosseno-seno (CSD) de um operador qu√¢ntico de tr√™s qubits.
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
‚ñ°
Ry
Ry
Ry
LL0 + LL1
RL0 + RL1
LR0 + LR1
RR0 + RR1
Fonte: Elaborada pelo autor (2022)
feita na decomposi√ß√£o dos operadores ùêøe ùëÖuniformemente controlados na primeira identi-
dade da Figura 9. Sendo ùëà= ùëà0 ‚äïùëà1 (assim como as matrizes ùêøe ùëÖdo CSD), podemos
encontrar os unit√°rios ùëÑe ùëäe a diagonal ùê∑que satisfazem (SHENDE; BULLOCK; MARKOV,
2006)
ùëà= (ùêº‚äóùëÑ)(ùê∑‚äïùê∑‚Ä†)(ùêº‚äóùëä).
(2.10)
A partir da Equa√ß√£o (2.10), temos que ùëà0 = ùëÑùê∑ùëäe ùëà1 = ùëÑùê∑‚Ä†ùëä, o que implica ùëà0ùëà‚Ä†
1 =
ùëÑùê∑2ùëÑ‚Ä†. Temos ent√£o que ùê∑e ùëÑpodem ser calculados atrav√©s de diagonaliza√ß√£o. O unit√°rio
ùëäpode ser encontrado usando as rela√ß√µes ùëä= ùê∑‚Ä†ùëÑ‚Ä†ùëà0 ou ùëä= ùê∑ùëÑ‚Ä†ùëà1. Sabendo que a
diagonal ùê∑√© composta pelos autovalores da diagonaliza√ß√£o, a matriz ùê∑‚äïùê∑‚Ä† pode ser repre-
sentada por uma rota√ß√£o ùëÖùëßuniformemente controlada aplicada ao qubit mais significativo
(Figura 11) (SHENDE; BULLOCK; MARKOV, 2006).
Figura 11 ‚Äì Identidade utilizada para a decomposi√ß√£o de Shannon (QSD) de operadores qu√¢nticos.
‚ñ°
U
=
‚ñ°
Rz
W
Q
Fonte: Elaborada pelo autor (2022)
De maneira semelhante ao algoritmo CSD, o QSD aplica as identidades definidas na Fi-
gura 9 e na Figura 11 recursivamente. Inicia aplicando a primeira identidade da Figura 9 para
decompor o operador ùëà‚ààCùëÅ√óùëÅem uma matriz central ùê∑ùëêùë†e unit√°rios ùêøùëñe ùëÖùëñ. Em seguida, a
identidade da Figura 11 √© aplicada aos operadores ùêøe ùëÖ, decompondo-os na diagonal ùê∑‚äïùê∑‚Ä†
e nos unit√°rios ùëäe ùëÑde dimens√£o ùëÅ/2 √ó ùëÅ/2 (Figura 12). O procedimento √© reiniciado a
partir da primeira identidade, atuando sobre os operadores ùëäe ùëÑ, e continua at√© que esses
operadores possuam dimens√£o 2 √ó 2 representando portas de um qubit. A decomposi√ß√£o ZYZ
utilizada para representar os operadores de um qubit n√£o possuem CNOTs, portanto apenas
as rota√ß√µes uniformemente controladas contribuem para o n√∫mero total de CNOTs no circuito
3
44ùëõ‚àí3
22ùëõ(SHENDE; BULLOCK; MARKOV, 2006).

28
Figura 12 ‚Äì Circuito para a decomposi√ß√£o de Shannon (QSD) de um operador qu√¢ntico de dois qubits.
‚ñ°
‚ñ°
‚ñ°
Rz
Ry
Rz
WL
QL
WR
QR
Fonte: Elaborada pelo autor (2022)
Se a recurs√£o encerrar quando os operadores ùëÑe ùëäatuarem sobre dois qubits, haver√°
4ùëõ‚àí2 operadores desse tipo e menos 3 √ó 4ùëõ‚àí2 rota√ß√µes uniformemente controladas por um
qubit. Utilizando a decomposi√ß√£o da Se√ß√£o 2.1.2, cada operador de dois qubits contribui com
3 CNOTs. Cada rota√ß√£o uniformemente controlada atuando sobre dois qubits contribui com
2 CNOTs (ITEN et al., 2016). Portanto, a contagem de CNOTs diminui 3 √ó 4ùëõ‚àí2 e o total √©
reduzido para
9
164ùëõ‚àí3
22ùëõ. Essa variante do algoritmo foi chamada de QSD (ùëô= 2) por Shende,
Bullock e Markov (2006), onde ùëôindica o n√∫mero de qubits em que a recurs√£o encerra. O caso
anterior, que encerra em operadores de um qubit, chama-se QSD (ùëô= 1).
O QSD (ùëô= 2) ainda pode ser otimizado de duas maneiras (SHENDE; BULLOCK; MARKOV,
2006). A primeira, quando a recurs√£o encerra em operadores ùëâe ùëäatuando sobre dois qubits,
aplica a otimiza√ß√£o indicada pela Figura 8 da Se√ß√£o 2.1.2, reduzindo 4ùëõ‚àí2 ‚àí1 CNOTs (um
CNOT por operador de dois qubits, com exce√ß√£o do √∫ltimo). A segunda otimiza√ß√£o utiliza
portas CZ (Controlled-Z) no lugar de CNOTs para decompor as matrizes centrais, pois o √∫ltimo
CZ pode ser absorvido pelo multiplexador vizinho, salvando (4ùëõ‚àí2 ‚àí1)/3 CNOTs. Com ambas
as otimiza√ß√µes, o n√∫mero total de CNOTs √© reduzido para 23
484ùëõ‚àí3
22ùëõ+ 4
3. At√© o momento,
essa √© a decomposi√ß√£o mais eficiente para unit√°rios gerais. Shende, Bullock e Markov (2006)
chamou essa decomposi√ß√£o otimizada de QSD (ùëô= 2, otimizada).
2.2
TIPO DE PREPARA√á√ÉO DE ESTADOS QU√ÇNTICOS
Para codificar um vetor de entrada cl√°ssico em um estado qu√¢ntico √© necess√°rio construir
um circuito qu√¢ntico que prepare tal estado (CORTESE; BRAJE, 2018). Esse circuito √© gerado
numa fase de pr√©-processamento cl√°ssico aplicando instru√ß√µes qu√¢nticas do dispositivo alvo.
As fases de pr√©-processamento cl√°ssico e de inicializa√ß√£o do estado qu√¢ntico combinadas ‚Äì
chamadas de prepara√ß√£o de estados qu√¢nticos (Figura 2 e Figura 3) ‚Äì formam o principal
objeto de estudo desta pesquisa.

29
2.2.1
Codifica√ß√£o na base
Essa codifica√ß√£o transforma o n√∫mero bin√°rio ùë•‚àà{0, 1}ùëõem um estado qu√¢ntico na base
computacional. O circuito qu√¢ntico correspondente √© gerado pela aplica√ß√£o de portas ùëãno
qubit ùëñquando ùë•ùëñ= 1. A execu√ß√£o desse circuito produzir√° o estado qu√¢ntico representando
o n√∫mero bin√°rio ùë•.
O m√©todo √© utilizado de diversas formas. Por exemplo, um vetor x = (ùë•1, . . . , ùë•ùëÄ), onde
1 ‚â§ùëÄ‚â§2ùëõ, pode ser codificado atrav√©s da transforma√ß√£o de cada componente ùë•ùëóem
estados da base e da concatena√ß√£o das codifica√ß√µes resultantes. De maneira mais sofisticada,
podemos representar o vetor x numa superposi√ß√£o uniforme dos estados dos seus componentes
codificados binariamente (VENTURA; MARTINEZ, 2000; SCHULD; PETRUCCIONE, 2018)
|x‚ü©=
1
‚àö
ùëÄ
ùëÄ
‚àëÔ∏Å
ùëó=1
|ùë•ùëó‚ü©.
(2.11)
2.2.2
Codifica√ß√£o nos √¢ngulos
Essa codifica√ß√£o mapeia cada componente ùë•ùëódo vetor x ‚ààCùëÅcomo rota√ß√µes ùëÖùë¶e ùëÖùëßde
qubits individuais (Figura 13). O procedimento consiste em redimensionar o m√≥dulo de cada
elemento vetorial de dados ùë•ùëódentro da faixa [0, ùúã] para depois codific√°-lo em um qubit ùëûùëó.
Dados ùõºùëó= abs(ùë•ùëó) e ùúÜùëó= arg(ùë•ùëó), temos para cada qubit
|ùëûùëó‚ü©= cos
(Ô∏Çùõºùëó
2
)Ô∏Ç
|0‚ü©+ ùëíùëñùúÜùëósin
(Ô∏Çùõºùëó
2
)Ô∏Ç
|1‚ü©.
√â menos eficiente em termos de espa√ßo comparado √† codifica√ß√£o nas amplitudes, exigindo
ùëÅqubits para codificar um vetor de dados ùëÅ-dimensional (STOUDENMIRE; SCHWAB, 2016).
Mas a prepara√ß√£o do estado √© simples, pois requer apenas rota√ß√µes de um qubit.
Figura 13 ‚Äì Codifica√ß√£o em √¢ngulos de qubits utilizando rota√ß√µes.
|0‚ü©0
Ry(Œ±0)
Rz(Œª0)
|0‚ü©1
Ry(Œ±1)
Rz(Œª1)
|0‚ü©2
Ry(Œ±2)
Rz(Œª2)
Fonte: Elaborada pelo autor (2022)

30
2.2.3
Codifica√ß√£o nas amplitudes
A codifica√ß√£o do vetor x ‚ààCùëÅ(|x| = 1) nas amplitudes de um estado qu√¢ntico √© repre-
sentada por |x‚ü©= ‚àëÔ∏Ä
ùëóùë•ùëó|ùëó‚ü©. Essa codifica√ß√£o requer ùëõ= ‚åàlog2(ùëÅ)‚åâqubits para representar
um dado ùëÅ-dimensional.
Nossa pesquisa e as prepara√ß√µes de estados baseadas em rota√ß√µes (Se√ß√£o 2.3.1) e na
decomposi√ß√£o de Schmidt (Se√ß√£o 2.3.2) fazem parte desta abordagem. Codifica√ß√µes deste
tipo conseguem preparar |x‚ü©a partir do estado |0‚ü©usando ùëÇ(2ùëõ) portas (MOTTONEN et al.,
2005; BERGHOLM et al., 2005; SHENDE; BULLOCK; MARKOV, 2006). Portanto, ela √© vantajosa
em rela√ß√£o √†s outras prepara√ß√µes de estados quando o dispositivo qu√¢ntico consegue executar
circuitos profundos e quando a dimensionalidade do vetor de entrada √© muito alta, tornando
impratic√°vel utilizar outro tipo de prepara√ß√£o de estados devido ao n√∫mero de qubits.
2.3
EXEMPLO DE PREPARA√á√ÉO DE ESTADOS QU√ÇNTICOS
2.3.1
Baseada em rota√ß√µes
A prepara√ß√£o de estados proposta por Mottonen et al. (2005) descreve o problema como a
busca por um operador ùëàque transforma um vetor de estado arbitr√°rio |ùë•‚ü©= ‚àëÔ∏Ä
ùëù|ùë•ùëù|ùëíùëñùë§ùëù|ùëù‚ü©
em um vetor fixo |ùëü‚ü©. Por conveni√™ncia, o vetor fixo √© escolhido como o primeiro vetor da base
computacional |ùëü‚ü©= |0‚ü©. Conhecendo ùëàde maneira que ùëà|ùë•‚ü©= |0‚ü©, sempre podemos efetuar
a opera√ß√£o inversa ùëà‚Ä† |0‚ü©= |ùë•‚ü©, que √© a prepara√ß√£o de estados. De fato, a transforma√ß√£o
proposta √© composta apenas por rota√ß√µes uniformemente controladas, ent√£o sua inversa √©
simples e podemos constru√≠-la diretamente, n√£o sendo necess√°rio efetuar a invers√£o. Portanto,
a prepara√ß√£o de estados baseada em rota√ß√µes pode ser definida como uma transforma√ß√£o
linear consistindo de uma sequ√™ncia de rota√ß√µes uniformemente controladas que transforma o
estado inicial |0‚ü©‚äóùëõno vetor arbitr√°rio |ùë•‚ü©.
Para explicar o procedimento, s√£o introduzidas as express√µes (2.12) e (2.13), definidas
pelo vetor x = (|ùë•0|ùëíùëñùë§0, . . . , |ùë•ùëÅ‚àí1|ùëíùëñùë§ùëÅ‚àí1) (MOTTONEN et al., 2005)
ùõºùëó,ùëò= 2asin
‚éõ
‚éú
‚éù
‚éØ
‚é∏
‚é∏
‚é∑
2ùëò‚àí1
‚àëÔ∏Å
ùëô=1
|ùë•(2ùëó‚àí1)2ùëò‚àí1+ùëô|2/
‚éØ
‚é∏
‚é∏
‚é∑
2ùëò
‚àëÔ∏Å
ùëô=1
|ùë•(ùëó‚àí1)2ùëò+ùëô|2
‚éû
‚éü
‚é†
(2.12)
ùúÜùëó,ùëò=
2ùëò‚àí1
‚àëÔ∏Å
ùëô=1
(ùúî(2ùëó‚àí1)2ùëò‚àí1+ùëô‚àíùúî(2ùëó‚àí2)2ùëò‚àí1+ùëô)/2ùëò‚àí1
(2.13)

31
Figura 14 ‚Äì Inicializa√ß√£o de um estado qu√¢ntico de ùëõqubits usando rota√ß√µes para codificar um vetor de
entrada complexo de dimens√£o ùëÅ= 2ùëõnas amplitudes do estado.
step 1
step 2
step n
. . .
. . .
. . .
. . .
. . .
. . .
...
...
...
...
...
...
...
...
. . .
. . .
. . .
. . .
. . .
. . .
|0‚ü©0
Ry(Œ±1,n)
Rz(Œª1,n)
|0‚ü©1
Ry(Œ±1,n‚àí1)
Ry(Œ±2,n‚àí1)
Rz(Œª1,n‚àí1)
Rz(Œª2,n‚àí1)
|0‚ü©n‚àí2
|0‚ü©n‚àí1
Ry(Œ±1,1)
Rz(Œª2n‚àí1,1)
Fonte: Elaborada pelo autor (2022)
onde ùëó= 1, 2, . . . , 2ùëõ‚àíùëò, ùëò= 1, 2, . . . , ùëõe ùëõ= log2(ùëÅ). Essas express√µes determinam √¢ngulos
de rota√ß√£o para a codifica√ß√£o do vetor x. Os argumentos das fases do vetor |ùë•‚ü©s√£o codificados
atrav√©s de rota√ß√µes ùëÖùëßde √¢ngulos ùúÜùëó,ùëòe as magnitudes atrav√©s de rota√ß√µes ùëÖùë¶de √¢ngulos
ùõºùëó,ùëò(Figura 14).
Figura 15 ‚Äì N√∫mero de CNOTs e a profundidade de circuitos produzidos pela biblioteca qclib usando a pre-
para√ß√£o de estados baseada em rota√ß√µes, em fun√ß√£o do logaritmo do comprimento da entrada
ùëõ= log2(ùëÅ).
2
4
6
8
10
12
14
0
10000
20000
30000
40000
50000
60000
n
(a) N√∫mero de CNOTs
2
4
6
8
10
12
14
0
20000
40000
60000
80000
100000
120000
n
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
O procedimento inicia preparando o seguinte estado para ùëò= ùëõ(estamos preparando a
inversa da transforma√ß√£o, o que implica que a ordem de ùëò√© invertida), onde ùõΩùëó,ùëò= sin(ùõºùëó,ùëò)/2
|ùúìùëõ‚ü©= ùëí‚àíùëñ
ùúÜ1,ùëõ
2
‚àöÔ∏Å
1 ‚àí|ùõΩ1,ùëõ|2 |0‚ü©+ ùëíùëñ
ùúÜ1,ùëõ
2 ùõΩ1,ùëõ|1‚ü©.
(2.14)
Esse estado pode ser constru√≠do com apenas duas rota√ß√µes no primeiro qubit (primeiro passo
da Figura 14). Em seguida, o estado da express√£o (2.14) √© combinado com os valores do

32
segundo passo
|ùúìùëõ‚àí1‚ü©= |0‚ü©‚ü®0|ùúìùëõ‚ü©
(Ô∏Å
ùëí‚àíùëñ
ùúÜ1,ùëõ‚àí1
2
‚àöÔ∏Å
1 ‚àí|ùõΩ1,ùëõ‚àí1|2 |0‚ü©+ ùëíùëñ
ùúÜ1,ùëõ‚àí1
2
ùõΩ1,ùëõ‚àí1 |1‚ü©
)Ô∏Å
+
|1‚ü©‚ü®1|ùúìùëõ‚ü©
(Ô∏Å
ùëí‚àíùëñ
ùúÜ2,ùëõ‚àí1
2
‚àöÔ∏Å
1 ‚àí|ùõΩ2,ùëõ‚àí1|2 |0‚ü©+ ùëíùëñ
ùúÜ2,ùëõ‚àí1
2
ùõΩ2,ùëõ‚àí1 |1‚ü©
)Ô∏Å
|ùúìùëõ‚àí1‚ü©= ùëí‚àíùëñ
ùúÜ1,ùëõ
2
‚àöÔ∏Å
1 ‚àí|ùõΩ1,ùëõ|2
(Ô∏Å
ùëí‚àíùëñ
ùúÜ1,ùëõ‚àí1
2
‚àöÔ∏Å
1 ‚àí|ùõΩ1,ùëõ‚àí1|2 |00‚ü©+ ùëíùëñ
ùúÜ1,ùëõ‚àí1
2
ùõΩ1,ùëõ‚àí1 |01‚ü©
)Ô∏Å
+
ùëíùëñ
ùúÜ1,ùëõ
2 ùõΩ1,ùëõ
(Ô∏Å
ùëí‚àíùëñ
ùúÜ2,ùëõ‚àí1
2
‚àöÔ∏Å
1 ‚àí|ùõΩ2,ùëõ‚àí1|2 |10‚ü©+ ùëíùëñ
ùúÜ2,ùëõ‚àí1
2
ùõΩ2,ùëõ‚àí1 |11‚ü©
)Ô∏Å
|ùúìùëõ‚àí1‚ü©= ùëí‚àíùëñ
ùúÜ1,ùëõ
2
‚àöÔ∏Å
1 ‚àí|ùõΩ1,ùëõ|2
(Ô∏Å
ùëí‚àíùëñ
ùúÜ1,ùëõ‚àí1
2
‚àöÔ∏Å
1 ‚àí|ùõΩ1,ùëõ‚àí1|2 |0‚ü©+ ùëíùëñ
ùúÜ1,ùëõ‚àí1
2
ùõΩ1,ùëõ‚àí1 |1‚ü©
)Ô∏Å
+
ùëíùëñ
ùúÜ1,ùëõ
2 ùõΩ1,ùëõ
(Ô∏Å
ùëí‚àíùëñ
ùúÜ2,ùëõ‚àí1
2
‚àöÔ∏Å
1 ‚àí|ùõΩ2,ùëõ‚àí1|2 |2‚ü©+ ùëíùëñ
ùúÜ2,ùëõ‚àí1
2
ùõΩ2,ùëõ‚àí1 |3‚ü©
)Ô∏Å
Ent√£o, os estados continuam a ser combinados com os valores dos passos seguintes
|ùúìùëò‚ü©=
2ùëõ‚àíùëò
‚àëÔ∏Å
ùëó=1
|ùëó‚àí1‚ü©‚ü®ùëó‚àí1|ùúìùëò+1‚ü©
(Ô∏Å
ùëí‚àíùëñ
ùúÜùëó,ùëò
2
‚àöÔ∏Å
1 ‚àí|ùõΩùëó,ùëò|2 |0‚ü©+ ùëíùëñ
ùúÜùëó,ùëò
2 ùõΩùëó,ùëò|1‚ü©
)Ô∏Å
(2.15)
A atualiza√ß√£o do estado |ùúìùëò‚ü©√© repetida para ùëò= (ùëõ‚àí1), . . . , 1, obtendo o estado desejado
|ùúì1‚ü©= |ùë•0|ùëíùëñùúî0 |0‚ü©+ . . . + |ùë•ùëÅ‚àí1|ùëíùëñùúîùëÅ‚àí1 |ùëÅ‚àí1‚ü©.
A combina√ß√£o dos estados √© realizada com rota√ß√µes multicontroladas. A cada passo, √© montada
uma sequ√™ncia de rota√ß√µes sobre um qubit e controladas pelos qubits dos passos anteriores.
Primeiro, rota√ß√µes ùëÖùë¶s√£o aplicadas para determinar as magnitudes das amplitudes, seguidas
por rota√ß√µes ùëÖùëßpara determinar as fases. Esses passos est√£o representados no Algoritmo 1 e
na Figura 14.
Algoritmo 1: Prepara√ß√£o de estados baseada em rota√ß√µes
input : Um vetor de estado com 2ùëõamplitudes.
output: O circuito para a inicializa√ß√£o do estado qu√¢ntico.
1 Cria um circuito qu√¢ntico com ùëõqubits (um qubit para cada passo)
2 Aplica uma rota√ß√£o ùëÖùë¶e uma rota√ß√£o ùëÖùëßno primeiro qubit usando os √¢ngulos ùõº1,ùëõe
ùúÜ1,ùë£(Eq. 2.14)
3 Faz ùëò= ùëõ‚àí1 (segundo passo)
4 Realiza uma Rota√ß√£o Uniformemente Controlada controlada pelos qubits
0, 1, . . . , ùëõ‚àíùëò‚àí1 (correspondendo aos passos anteriores) com o qubit atual ùëõ‚àíùëò
como alvo, usando ùõºùëó,ùëòe ùúÜùëó,ùëò(1 ‚â§ùëó‚â§2ùëõ‚àíùëò) do passo corrente como √¢ngulos das
rota√ß√µes (Eq. 2.15)
5 Se ùëò> 1, faz ùëò= ùëò‚àí1 e retorna para a linha 3, caso contr√°rio retorna o circuito
qu√¢ntico para a inicializa√ß√£o do estado.
Fonte: Elaborado pelo autor (2022)

33
2.3.2
Baseada na decomposi√ß√£o de Schmidt
A prepara√ß√£o de estados proposta por Plesch e Brukner (2011) √© baseada na decomposi√ß√£o
de Schmidt. Dado um estado qu√¢ntico |ùúì‚ü©= ‚àëÔ∏Ä
ùëóùúÜùëó|ùëó‚ü©, o primeiro passo do algoritmo √©
executar a decomposi√ß√£o de Schmidt |ùúì‚ü©=
‚àëÔ∏Ä
ùëñùúéùëñ|ùõºùëñ‚ü©‚äó|ùõΩùëñ‚ü©‚àà‚Ñã= ‚Ñãùê¥‚äó‚Ñãùêµonde o
estado √© fatorado em dois sistemas qu√¢nticos ‚Ñãùê¥e ‚Ñãùêµ, ùúéùëñs√£o os coeficientes de Schmidt,
{|ùõºùëñ‚ü©} ‚àà‚Ñãùê¥e {|ùõΩùëñ‚ü©} ‚àà‚Ñãùêµs√£o bases ortonormais, e 1 ‚â§ùëñ‚â§min(dim(‚Ñãùê¥), dim(‚Ñãùêµ)).
O segundo passo inicializa o estado qu√¢ntico ‚àëÔ∏Ä
ùëñùúéùëñ|ùëñ‚ü©|0‚ü©no primeiro registrador qu√¢ntico. O
objetivo deste passo √© inicializar um estado com os coeficientes de Schmidt codificados nas
amplitudes. O terceiro passo aplica ‚åäùëõ/2‚åãCNOTs para criar o estado ‚àëÔ∏Ä
ùëñùúéùëñ|ùëñ‚ü©|ùëñ‚ü©. Sendo ùëà
e ùëâunit√°rios, onde ùëà|ùëñ‚ü©= |ùõºùëñ‚ü©e ùëâùëá|ùëñ‚ü©= |ùõΩùëñ‚ü©, o √∫ltimo passo do algoritmo aplica ùëàno
primeiro registrador e ùëâùëáno segundo. A Figura 16 e o Algoritmo 2 ilustram essa prepara√ß√£o
de estados.
Figura 16 ‚Äì Inicializa√ß√£o de um estado qu√¢ntico de ùëõqubits usando a decomposi√ß√£o de Schmidt.
phase 1
phase 2
phase 3
phase 4
...
...
|0‚ü©‚äó‚åän/2‚åã
Initialization ‚ÉóœÉ
Unitary U
|0‚ü©‚äó‚åàn/2‚åâ
Unitary V T
Fonte: Elaborada pelo autor (2022)
Quando atuando em ùëòqubits, uma prepara√ß√£o de estados requer 2ùëò‚àíùëò‚àí1 CNOTs (BERGHOLM
et al., 2005) e um operador unit√°rio 23
4822ùëò‚àí3
22ùëò+ 4
3 (SHENDE; BULLOCK; MARKOV, 2006). Sendo
‚Ñãùê¥um subsistema com ùëõùê¥qubits (ùëõùê¥= ùëõ/2 para ùëõpar e ùëõùê¥= (ùëõ‚àí1)/2 para ùëõ√≠mpar) e
ùëõùêµ= ùëõ‚àíùëõùê¥o n√∫mero de qubits do subsistema ‚Ñãùêµ(ùëõùêµ√© maior ou igual a ùëõùê¥) e conside-
rando o circuito completo para a inicializa√ß√£o de estados, o n√∫mero de CNOTs somando as
contribui√ß√µes de todas as fases (Figura 16) √© representado por

34
ùëõpar:
2ùëõùê¥‚àíùëõùê¥‚àí1
‚èü
 ‚èû
 
fase 1
+ ùëõùê¥
‚èü ‚èû 
fase 2
+ 2
(Ô∏Ç23
482ùëõ‚àí3
22ùëõùê¥+ 4
3
)Ô∏Ç
‚èü
 ‚èû
 
fases 3 e 4 (unit√°rios)
(2.16)
ùëõ√≠mpar:
2ùëõùê¥‚àíùëõùê¥‚àí1
‚èü
 ‚èû
 
fase 1
+ ùëõùê¥
‚èü ‚èû 
fase 2
+ 23
4822ùëõùê¥‚àí3
22ùëõùê¥+ 4
3
‚èü
 ‚èû
 
fase 3 (unit√°rio)
+ 23
4822ùëõùêµ‚àí3
22ùëõùêµ+ 4
3
‚èü
 ‚èû
 
fase 4 (unit√°rio)
(2.17)
As chaves nas equa√ß√µes (2.16) e (2.17) indicam a contribui√ß√£o de cada fase do proce-
dimento de Plesch e Brukner (2011) para o n√∫mero de CNOTs. A fase 1 √© uma prepara√ß√£o
de estado, a fase 2 uma sequ√™ncia de portas CNOT e as fases 3 e 4 s√£o decomposi√ß√µes
de unit√°rios. O n√∫mero total de CNOTs √© limitado por
23
242ùëõquando ùëõ√© par e por
115
96 2ùëõ
quando ùëõ√© √≠mpar. A profundidade do circuito √© determinada pelo unit√°rio da fase 4, pois
ùëõùêµ= ‚åàùëõ/2‚åâ‚â•ùëõùê¥= ‚åäùëõ/2‚åã. A Figura 17 ilustra como a profundidade √© afetada pela paridade
do n√∫mero de qubits ùëõ= log2(ùëÅ).
Figura 17 ‚Äì Compara√ß√£o entre o n√∫mero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando as prepara√ß√µes de estados baseadas em rota√ß√µes e na decomposi√ß√£o de Schmidt,
em fun√ß√£o do logaritmo do comprimento da entrada ùëõ= log2(ùëÅ).
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
Rotations
Schmidt
(a) N√∫mero de CNOTs
2
4
6
8
10
12
14
n
0
20000
40000
60000
80000
100000
120000
Rotations
Schmidt
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
A decomposi√ß√£o de Schmidt reduz a profundidade do circuito qu√¢ntico utilizado para a ini-
cializa√ß√£o de estados (comparado com Mottonen et al. (2005)), mas h√° um aumento no custo
computacional cl√°ssico ‚Äì complexidade do algoritmo na etapa de preprocessamento cl√°ssico
(Figura 2). Para calcular a decomposi√ß√£o de Schmidt √© necess√°rio realizar a decomposi√ß√£o
SVD (Linha 1 do Algoritmo 2), que possui custo c√∫bico na raiz do comprimento da entrada
ùëÇ(ùëÅ3/2) (VASUDEVAN; RAMAKRISHNA, 2017).

35
Algoritmo 2: Prepara√ß√£o de estados baseada na decomposi√ß√£o de Schmidt
input : Um vetor de estado com 2ùëõamplitudes.
input : Uma parti√ß√£o com os primeiros ‚åäùëõ/2‚åãqubits do registrador.
output: O circuito para a inicializa√ß√£o do estado qu√¢ntico.
1 Decompor o estado usando SVD e a parti√ß√£o (armazena os unit√°rios ùë¢e ùë£‚Ñé, e o
vetor ùë†)
2 Cria um circuito qu√¢ntico com ùëõqubits (ùëõ= log2(len(vetor de estado)))
3 Codifica o vetor normalizado ùë†nos qubits ùëû‚àà{parti√ß√£o} usando um algoritmo para a
prepara√ß√£o de estados nas amplitudes. Este passo √© chamado de Phase 1
4 Realiza ‚åäùëõ/2‚åãCNOTs entre os qubits de controle ùëûùëê‚àà{parti√ß√£o} e os alvos
ùëûùë°/‚àà{parti√ß√£o}. Este passo √© chamado de Phase 2
5 Codifica o unit√°rio ùë¢nos qubits ùëû‚àà{parti√ß√£o}. Este passo √© chamado de Phase 3
6 Codifica o unit√°rio ùë£‚Ñéùëános qubits ùëû/‚àà{parti√ß√£o}. Este passo √© chamado de Phase 4
7 Retorna o circuito qu√¢ntico para a inicializa√ß√£o do estado.
Fonte: Elaborado pelo autor (2022)
2.4
DECOMPOSI√á√ÉO DE ISOMETRIAS
Isometrias s√£o generaliza√ß√µes de operadores unit√°rios e de prepara√ß√µes de estados. Uma
isometria ùëâ√© representada por uma matriz 2ùëõ√ó 2ùëösatisfazendo ùëâ‚Ä†ùëâ= I, onde 0 ‚â§ùëö‚â§ùëõ.
Os casos especiais em que ùëö= 0 e ùëö= ùëõs√£o equivalentes √† prepara√ß√£o de estados e √†
decomposi√ß√£o de unit√°rios, respectivamente.
2.4.1
Decomposi√ß√£o de Knill
Essa decomposi√ß√£o foi idealizada por Knill (1995). Sendo ùëâuma isometria de dimens√£o
2ùëõ√ó 2ùëö, podemos estender ùëâcombinando-a com o complexo conjugado do seu espa√ßo nulo
ùëç= null(ùëâùëá)‚Ä† de dimens√£o (2ùëõ‚àí2ùëö) √ó 2ùëõpara produzir o unit√°rio ùëà=
[Ô∏Å
ùëâùëçùëá]Ô∏Å
2ùëõ√ó2ùëõ,
onde null(ùëâùëá) = {‚Éóùë£‚ààC2ùëõ|ùëâùëá‚Éóùë£= ‚Éó0} e ùëâ= ùëàI2ùëõ√ó2ùëö. O transposto conjugado do espa√ßo
nulo √© necess√°rio para a condi√ß√£o de unitariedade ùëàùëà‚Ä† = I. Esse procedimento estende ùëâ
para uma base ortonormal em que as colunas de ùëàs√£o os estados da base e que possui no
m√°ximo 2ùëöautovalores com argumento complexo ùúÉùëòdiferente de zero, minimizando o n√∫mero
de inst√¢ncias do circuito da Figura 18.
A Figura 18 mostra o esquema do circuito qu√¢ntico para a decomposi√ß√£o de uma das 2ùëö
colunas da isometria ùëâ. O circuito completo tem 2ùëöinst√¢ncias desse diagrama (0 ‚â§ùëò< 2ùëö).
O operador ùëÜ√© uma prepara√ß√£o de estado do tipo codifica√ß√£o nas amplitudes (Se√ß√£o 2.2.3),
e ùúÉùëò√© o argumento do autovalor ùëòdo unit√°rio ùëà. Se o argumento for zero, a inst√¢ncia do

36
Figura 18 ‚Äì Esquema de Knill para a decomposi√ß√£o de isometrias.
S‚Ä†(Vk)
S(Vk)
X
P(Œ∏k)
X
Fonte: Elaborada pelo autor (2022)
circuito pode ser ignorada.
Figura 19 ‚Äì Otimiza√ß√£o para a decomposi√ß√£o cosseno-seno (CSD) de isometrias.
S(Vk)
S‚Ä†(Vk+1)
=
S(Vk)
S‚Ä†(Vk+1)
S
A
C‚Ä†
S‚Ä†
B
D‚Ä†
=
S
C‚Ä†A
S‚Ä†
D‚Ä†B
Fonte: Elaborada pelo autor (2022)
Iten et al. (2016) sugere utilizar a prepara√ß√£o de estados baseada na decomposi√ß√£o de Sch-
midt (Se√ß√£o 2.3.2). Com essa inicializa√ß√£o, √© poss√≠vel otimizar a decomposi√ß√£o de isometrias
baseadas no esquema de Knill. A Figura 19 mostra como combinar os operadores das fases
3 e 4 entre inst√¢ncias consecutivas do diagrama 18. Com essa otimiza√ß√£o, a decomposi√ß√£o
de Knill requer 23
24(2ùëö+ùëõ+ 2ùëõ) + ùëÇ(ùëõ2)2ùëöCNOTs para ùëõpar e 115
96 (2ùëö+ùëõ+ 2ùëõ) + ùëÇ(ùëõ2)2ùëö
CNOTs para ùëõ√≠mpar (ITEN et al., 2016).
2.4.2
Decomposi√ß√£o Coluna-por-Coluna
O m√©todo de decomposi√ß√£o coluna-por-coluna (Column‚Äìby‚ÄìColumn Decomposition ou
CCD) para a decomposi√ß√£o de isometrias foi introduzido por Iten et al. (2016). Cada coluna
ùëòda isometria ùëâ√© decomposta em um operador ùê∫ùëò(Figura 20 e Algoritmo 3). O operador
ùê∫ùëò√© uma varia√ß√£o da codifica√ß√£o nas amplitudes de Mottonen et al. (2005), sendo apenas
ùê∫‚Ä†
0 exatamente a prepara√ß√£o de estados baseada em rota√ß√µes (Se√ß√£o 2.3.1).
A varia√ß√£o (linhas 4‚Äì6 do Algoritmo 3) tem como objetivo garantir que a decomposi√ß√£o de
cada nova coluna n√£o afete as anteriores. Quando necess√°rio, a varia√ß√£o remove alguns dos uni-
t√°rios ùëàùëô(Equa√ß√£o 2.20) dos operadores uniformemente controlados do algoritmo de Mottonen
et al. (2005) e os substitui por um operador ùëàmulticontrolado (Linha 5 do Algoritmo 3).

37
Figura 20 ‚Äì Esquema coluna-por-coluna para a decomposi√ß√£o de isometrias.
D
G‚Ä†
2m‚àí1(V2m‚àí1)
. . .
G‚Ä†
0(V0)
Fonte: Elaborada pelo autor (2022)
A Figura 20 e o Algoritmo 3 sumarizam o m√©todo. A Figura 20 apresenta o circuito
qu√¢ntico para a decomposi√ß√£o de 2ùëöcolunas da isometria ùëâ. No Algoritmo 3, o unit√°rio ùëà
e o conjunto de unit√°rios ùëàùëôdas linhas 5 e 7 s√£o constru√≠dos conforme a Equa√ß√£o (2.19)
e a Equa√ß√£o (2.20) Iten et al. (2016). A fun√ß√£o ùëéùëò
ùë†+1 representa o inteiro composto pelos
ùëõ‚àí(ùë†+ 1) bits mais significativos de ùëò. A fun√ß√£o ùëèùëò
ùë†+1, o inteiro composto pelos ùë†+ 1 bits
menos significativos de ùëò(ver Ap√™ndice A3 de (ITEN et al., 2016)). Na Equa√ß√£o (2.18), o
estado |ùúìùëô‚ü©√© composto pelos dois elementos de √≠ndices 2ùë†(2ùëô) + ùëèùëò
ùë†+1 e 2ùë†(2ùëô+ 1) + ùëèùëò
ùë†+1,
normalizados, localizados na coluna ùëòda isometria ùëâ, e |ùúëùëô‚ü©= ‚àí‚ü®ùúìùëô|1‚ü©|0‚ü©+ ‚ü®ùúìùëô|0‚ü©|1‚ü©(ver
Lemma 2 de (ITEN et al., 2016)). Deve ser percebido que as colunas s√£o preparadas at√© um
operador diagonal, o que significa que uma corre√ß√£o de fase √© necess√°ria. Isso √© feito pelo
operador ùê∑da Figura 20.
ùë¢ùëô=
‚éß
‚é™
‚é™
‚é®
‚é™
‚é™
‚é©
|0‚ü©‚ü®ùúìùëô| + |1‚ü©‚ü®ùúëùëô| se ùë†= 0
|1‚ü©‚ü®ùúìùëô| + |0‚ü©‚ü®ùúëùëô| se ùë†Ã∏= 0
(2.18)
ùëà=
{Ô∏Ç
ùë¢ùëô
para ùëô= ùëéùëò
ùë†+1
(2.19)
ùëàùëô=
‚éß
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é®
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é™
‚é©
I2√ó2
para ùëô‚àà{0, 1, . . . , ùëéùëò
ùë†+1} se ùëèùëò
ùë†+1 Ã∏= 0
I2√ó2
para ùëô‚àà{0, 1, . . . , ùëéùëò
ùë†+1 ‚àí1} se ùëèùëò
ùë†+1 = 0
ùë¢ùëô
para ùëô‚àà{ùëéùëò
ùë†+1 + 1, ùëéùëò
ùë†+1 + 2, . . . , 2ùëõ‚àí1‚àíùë†‚àí1} se ùëèùëò
ùë†+1 Ã∏= 0
ùë¢ùëô
para ùëô‚àà{ùëéùëò
ùë†+1, ùëéùëò
ùë†+1 + 1, . . . , 2ùëõ‚àí1‚àíùë†‚àí1} se ùëèùëò
ùë†+1 = 0
(2.20)
Sabendo que at√© a conclus√£o do Algoritmo 3 a matriz quadrada ùëâ2ùëö√ó2ùëö(2ùëö√© o n√∫mero
de colunas da isometria ùëâ) precisa tornar-se igual √† identidade, qualquer fase presente na
diagonal da matriz indica uma fase que deve ser corrigida usando o operador ùê∑. Portanto, ele
√© constru√≠do como um operador diagonal onde as fases s√£o aquelas presentes em ùëâ2ùëö√ó2ùëö.
Esse √© o m√©todo mais eficiente para a decomposi√ß√£o de isometrias, com exce√ß√£o do caso
2ùëõ‚àí1‚Äìpara‚Äì2ùëõem que o m√©todo CSD √© melhor (Se√ß√£o 2.4.3). O n√∫mero de CNOTs requerido

38
pelo CCD √© dado por 2ùëö+ùëõ‚àí1
242ùëõ+ ùëÇ(ùëõ2)2ùëö(ITEN et al., 2016).
Algoritmo 3: Monta um operador ùê∫ùëòque realiza a decomposi√ß√£o da coluna ùëòda
isometria ùëâ.
input : Uma isometria ùëâ, n√∫mero de qubits ùëõ, e o √≠ndice ùëòda coluna da isometria.
output: Operador ùê∫ùëò.
1 Cria um circuito qu√¢ntico com ùëõqubits para construir o operador ùê∫ùëò
2 Faz ùë†= 0 e ùëòùë†como o bit de √≠ndice ùë†da representa√ß√£o bin√°ria de ùëò
3 Faz ùë°ùëéùëüùëîùëíùë°= ùëõ‚àíùë†‚àí1, ùëêùëúùëõùë°ùëüùëúùëô= {0, . . . , ùë°ùëéùëüùëîùëíùë°‚àí1}, e
ùëéùëõùëêùëñùëôùëôùëé= {ùë°ùëéùëüùëîùëíùë°+ 1, . . . , ùëõ‚àí1}
4 Se ùëòùë†= 0 e ùëèùëò
ùë†+1 Ã∏= 0 continue, caso contr√°rio v√° para 7
5 Aplica uma porta multicontrolada ùëÄùê∂ùê∫com unit√°rio ùëà, controlada por
ùëêùëúùëõùë°ùëüùëúùëô+ ùëéùëõùëêùëñùëôùëôùëée atuando em ùë°ùëéùëüùëîùëíùë°
6 Atualiza a isometria ùëâ= ùëÄùê∂ùê∫√ó ùëâ
7 Aplica uma porta uniformemente controlada ùëàùê∂ùê∫com unit√°rios ùëàùëô, controlada por
ùëêùëúùëõùë°ùëüùëúùëôe atuando em ùë°ùëéùëüùëîùëíùë°
8 Atualiza a isometria ùëâ= ùëàùê∂ùê∫√ó ùëâ
9 Se ùë†< ùëõ‚àí1, faz ùë†= ùë†+ 1 e retorna para 3, caso contr√°rio retorna o operador ùê∫ùëò.
Fonte: Elaborado pelo autor (2022)
2.4.3
Decomposi√ß√£o Cosseno-Seno
Essa decomposi√ß√£o √© uma adapta√ß√£o da decomposi√ß√£o de unit√°rios CSD (Se√ß√£o 2.1.3) ou
de sua otimiza√ß√£o QSD (Se√ß√£o 2.1.4) (ITEN et al., 2016). Assim como na decomposi√ß√£o de Knill
(Se√ß√£o 2.4.1), a isometria √© estendida e representada em termos de um unit√°rio ùëâ= ùëàI2ùëõ√ó2ùëö.
Sendo ùëõ> ùëöe aplicando a primeira identidade da decomposi√ß√£o de unit√°rios (Figura 9), o
primeiro qubit do operador ùêøda decomposi√ß√£o do unit√°rio ùëàn√£o tem efeito sobre as colunas
associadas √† isometria (Figura 21), portanto n√£o √© necess√°rio aplicar o controle sobre ele.
Sendo assim, o operador ùêøatua sobre ùëõ‚àí1 qubits e √© uma isometria 2ùëö‚Äìpara‚Äì2ùëõ‚àí1 estendida
para unit√°rio, identificada na Figura 21 como ùëàùêø. Em seguida, a identidade da decomposi√ß√£o
de unit√°rios QSD (Figura 11) √© aplicada apenas ao operador uniformemente controlado ùëÖ,
produzindo os unit√°rios ùëÑe ùëäseparados pela rota√ß√£o uniformemente controlada ùëÖùëß(Fi-
gura 21).
Figura 21 ‚Äì Esquema para a decomposi√ß√£o cosseno-seno (CSD) de isometrias.
U
=
‚ñ°
‚ñ°
Ry
UL
R
=
‚ñ°
‚ñ°
Ry
Rz
UL
Q
W
Fonte: Elaborada pelo autor (2022)

39
O procedimento √© repetido recursivamente para decompor ùëàùêø. Os unit√°rios ùëÑe ùëäpodem
ser decompostos utilizando a identidade da Figura 11 at√© produzir operadores de dois qubits,
como explicado na Se√ß√£o 2.1.4.
Esse m√©todo produz circuitos com
23
144(4ùëö+ 2 √ó 4ùëõ) + ùëÇ(ùëö) CNOTs, apropriado apenas
quando ùëö= (ùëõ‚àí1) (ITEN et al., 2016). Para ùëö< (ùëõ‚àí1), o m√©todo CCD produz circuitos
com n√∫mero menor de CNOTs.

40
3 SOLU√á√ïES EXISTENTES PARA A PREPARA√á√ÉO DE ESTADOS QU√ÇNTI-
COS
V√°rias solu√ß√µes para o problema da prepara√ß√£o de estados qu√¢nticos foram propostas (VEN-
TURA; MARTINEZ, 1999; GROVER, 2000; LONG; SUN, 2001; MOTTONEN et al., 2005; SHENDE;
BULLOCK; MARKOV, 2006; PLESCH; BRUKNER, 2011; CORTESE; BRAJE, 2018), mas todas pro-
duzem circuitos com profundidade crescendo pelo menos exponencialmente no n√∫mero de
qubits. Por exemplo, o m√©todo proposto por Ventura e Martinez (1999) atinge a compress√£o
exponencial ùëÇ(log2(ùëÅ)) na largura do circuito qu√¢ntico enquanto exige profundidade linear
ùëÇ(ùëÅ) para dados ùëÅ-dimensionais. Como h√° uma sobrecarga adicional de recursos em muitos
algoritmos qu√¢nticos devido ao postulado da medi√ß√£o qu√¢ntica (PARK; PETRUCCIONE; RHEE,
2019; PARK et al., 2019), tal custo linear pode impor restri√ß√µes a poss√≠veis vantagens, domi-
nando o custo computacional da aplica√ß√£o qu√¢ntica pretendida.
As tentativas de preparar estados qu√¢nticos de forma mais eficiente incluem abordagens
probabil√≠sticas (ZHANG; YUNG; YUAN, 2021; PARK; PETRUCCIONE; RHEE, 2019) e estrat√©gias
para inicializar estados qu√¢nticos aproximados (ZOUFAL; LUCCHI; WOERNER, 2019; NAKAJI et al.,
2021; MARIN-SANCHEZ; GONZALEZ-CONDE; SANZ, 2021). Mais recentemente, existem trabalhos
que se concentram em classes espec√≠ficas de estados qu√¢nticos. Por exemplo, como preparar
estados uniformes (MOZAFARI et al., 2021), esparsos (MALVETTI; ITEN; COLBECK, 2021) ou
de distribui√ß√£o de probabilidade (ZOUFAL; LUCCHI; WOERNER, 2019). Entretanto, n√£o h√° um
entendimento claro de quais classes de estados qu√¢nticos podem ser criadas de forma eficiente.
O emaranhamento √© um dos recursos qu√¢nticos que tamb√©m permite o desenvolvimento
de algoritmos e protocolos mais eficientes (ver Ap√™ndice E). Sua rela√ß√£o com a complexi-
dade algor√≠tmica de um estado qu√¢ntico foi demonstrada em trabalhos anteriores (MORA;
BRIEGEL, 2006; MORA; BRIEGEL, 2005) e desempenha um papel importante em muitas apli-
ca√ß√µes qu√¢nticas, tais como comunica√ß√£o qu√¢ntica, corre√ß√£o de erros qu√¢nticos e criptografia
qu√¢ntica (RAUSSENDORF; BRIEGEL, 2001; BARREIRO et al., 2010; CALDERBANK; SHOR, 1996;
STEANE, 1996; CLEVE; GOTTESMAN; LO, 1999; D√ºR; CIRAC, 2000).
Embora esteja claro que o emaranhamento √© um recurso importante na computa√ß√£o qu√¢n-
tica (JOZSA; LINDEN, 2003), ser capaz de codificar estados de baixo emaranhamento, tais
como fun√ß√µes de densidade de probabilidade, ainda √© √∫til, pois os algoritmos podem usar blo-
cos de constru√ß√£o de baixo emaranhamento para alcan√ßar estruturas de alto emaranhamento.
Um exemplo √© a simula√ß√£o de processos estoc√°sticos (BLANK; PARK; PETRUCCIONE, 2021;

41
Tabela 1 ‚Äì Artigos sobre prepara√ß√£o de estados.
ano
artigo
flip-flop
caixa-preta
variacional
probabil√≠stico
√°rvore
decomposi√ß√£o
1995
(KNILL, 1995)(‚Ä†)(*)
1999
(VENTURA; MARTINEZ, 1999)(‚Ä†)(*)
x
2000
(GROVER, 2000)
x
2001
(LONG; SUN, 2001)
x
2005
(BERGHOLM et al., 2005)
x
(MOTTONEN et al., 2005)(‚Ä†)(*)
x
2006
(SHENDE; BULLOCK; MARKOV, 2006)(‚Ä†)(*)
x
2008
(GIOVANNETTI; LLOYD; MACCONE, 2008b)
x
(GIOVANNETTI; LLOYD; MACCONE, 2008a)
x
2011
(PLESCH; BRUKNER, 2011)(‚Ä†)(*)
x
2015
(ARUNACHALAM et al., 2015)
2016
(ITEN et al., 2016)(‚Ä†)(*)
x
2018
(CORTESE; BRAJE, 2018)
x
(LOW; KLIUCHNIKOV; SCHAEFFER, 2018)
x
2019
(SANDERS et al., 2019)
x
(ZOUFAL; LUCCHI; WOERNER, 2019)(‚Ä†)
x
(PARK; PETRUCCIONE; RHEE, 2019)
x
2020
(KUZMIN; SILVI, 2020)
x
(MOZAFARI et al., 2020)
x
(CASARES, 2020)
x
(MATTEO; GHEORGHIU; MOSCA, 2020)
x
(PALER; OUMAROU; BASMADJIAN, 2020)
x
2021
(VERAS et al., 2021)(‚Ä†)
x
(VERAS; SILVA; SILVA, 2022)(‚Ä†)
x
(ARAUJO et al., 2021b)(‚Ä†)(*)
x
(ARAUJO et al., 2021a)(‚Ä†)(*)
x
(WANG et al., 2021)
x
(GUO et al., 2021)
x
(ZHANG; YUNG; YUAN, 2021)
x
(ZHAO et al., 2021)
x
(GLEINIG; HOEFLER, 2021)(‚Ä†)
x
(NAKAJI et al., 2021)
x
(MOZAFARI et al., 2021)
x
(MARIN-SANCHEZ; GONZALEZ-CONDE; SANZ, 2021)
x
(MALVETTI; ITEN; COLBECK, 2021)
x
Fonte: Elaborada pelo autor (2022)
STAMATOPOULOS et al., 2020; WOERNER; EGGER, 2019), usando a estimativa de amplitude.
A Tabela 1 mostra uma lista do levantamento bibliogr√°fico feito at√© o momento, cate-
gorizando o m√©todo proposto em cada artigo para a prepara√ß√£o de estados. H√° 12 m√©todos
implementados no reposit√≥rio qclib, indicados por uma marca (‚Ä†). Os oito itens em que tra-
balhei diretamente, est√£o indicados por (*).

42
4 PRINCIPAIS CONTRIBUI√á√ïES
4.1
A DIVIDE-AND-CONQUER ALGORITHM FOR QUANTUM STATE PREPARATION
O trabalho Araujo et al. (2021b) (Ap√™ndice A) produziu um algoritmo capaz de carregar
um vetor ùëÅ-dimensional com vantagem de tempo exponencial usando um circuito qu√¢ntico
com profundidade polilogar√≠tmica e informa√ß√£o emaranhada com qubits auxiliares (Divide-and-
Conquer quantum State Preparation ou DCSP). Os resultados mostram que podemos carregar
dados com efici√™ncia em dispositivos qu√¢nticos usando uma estrat√©gia de divis√£o e conquista
para trocar tempo computacional por espa√ßo.
Figura 22 ‚Äì Compara√ß√£o entre o n√∫mero de qubits e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando a prepara√ß√£o de estados baseada na decomposi√ß√£o de Schmidt e o algoritmo
DCSP, em fun√ß√£o do logaritmo do comprimento da entrada ùëõ= log2(ùëÅ).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
Schmidt
Dcsp
(a) N√∫mero de qubits
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
70000
Schmidt
Dcsp
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
O m√©todo proposto estabelece uma abordagem para a prepara√ß√£o do estado qu√¢ntico
que pode complementar ou melhorar os m√©todos conhecidos, tais como a codifica√ß√£o nos
√¢ngulos (Se√ß√£o 2.2.2) e a codifica√ß√£o nas amplitudes (Se√ß√£o 2.2.3). A estrat√©gia foi baseada
no algoritmo de Mottonen et al. (2005) e em uma abordagem de divis√£o e conquista usando
portas swap controladas e qubits auxiliares. Com esta modifica√ß√£o, obtemos uma redu√ß√£o
exponencial no tempo para carregar um vetor ùëÅ-dimensional nas amplitudes de um estado
qu√¢ntico com um circuito de profundidade ùëÇ(log2
2(ùëÅ)) e espa√ßo ùëÇ(ùëÅ) (Figura 4.1), onde
ùëÅ= 2ùëõe ùëõ√© o n√∫mero de qubits do registrador de dados. Os qubits de dados est√£o associados
aos n√≥s da vista esquerda da √°rvore de estado (ver Ap√™ndice A e Ap√™ndice B). O registrador
auxiliar possui ùëÅ‚àíùëõ‚àí1 qubits e est√° associado ao restante dos n√≥s da √°rvore de estado.
A redu√ß√£o na profundidade √© atingida ao custo do uso de qubits auxiliares emaranhados
com os qubits do registrador de dados. A informa√ß√£o emaranhada significa que, embora os

43
dados sejam codificados nas amplitudes de uma superposi√ß√£o de qubits, os resultados ap√≥s a
observa√ß√£o dos qubits auxiliares deixar√° o registrador de dados em um estado misto, o que pode
ser uma desvantagem no caso de algoritmos para a solu√ß√£o de sistemas lineares (HARROW;
HASSIDIM; LLOYD, 2009) ou equa√ß√µes diferenciais (XIN et al., 2020). Entretanto, mostramos
que alguns problemas como a aprendizagem de m√°quina qu√¢ntica supervisionada e a an√°lise
estat√≠stica podem ser realizados com o estado qu√¢ntico de entrada dado pelo m√©todo.
Foi demonstrada uma prova de conceito utilizando um dispositivo qu√¢ntico real e apresen-
tadas duas aplica√ß√µes para a aprendizagem de m√°quina qu√¢ntica (ver Ap√™ndice A). Espera-se
que esta nova estrat√©gia de carregamento permita a vantagem qu√¢ntica para tarefas que reque-
rem carregar um volume significativo de informa√ß√µes para os dispositivos qu√¢nticos. A troca
entre as complexidades de tempo e espa√ßo √© favor√°vel quando aumentar a largura do circuito √©
mais barato do que aumentar a profundidade, o que √© um cen√°rio prov√°vel de ocorrer durante
o desenvolvimento dos dispositivos NISQ (IBM, 2020).
4.2
CONFIGURABLE SUBLINEAR CIRCUITS FOR QUANTUM STATE PREPARATION
A contribui√ß√£o do trabalho Araujo et al. (2021a) (Ap√™ndice B) √© um procedimento bidi-
recional configur√°vel que aborda o problema do custo de carregamento de dados cl√°ssicos em
um estado qu√¢ntico (Bidirectional quantum State Preparation ou BDSP), regulando a troca
inicialmente apresentada no DCSP entre a largura e a profundidade do circuito qu√¢ntico. Em
particular, √© apresentada uma configura√ß√£o que codifica um estado ùëÅ-dimensional usando um
circuito qu√¢ntico com largura e profundidade sublineares ùëÇ(
‚àö
ùëÅ) e informa√ß√£o emaranhada
com qubits auxiliares (Figura 23).
Os m√©todos existentes para a prepara√ß√£o de estados requerem pelo menos um recurso
do circuito qu√¢ntico ‚Äì profundidade ou largura ‚Äì crescendo linearmente com o tamanho do
problema. O algoritmo BDSP fornece uma estrutura geral para configurar a troca entre estes
recursos que pode ser √∫til para gerenci√°-los em dispositivos NISQ. Olhando para os algoritmos
de prepara√ß√£o de estados como uma caminhada na √°rvore de estado, o BDSP constitui uma
forma sistem√°tica de caminhar em duas dire√ß√µes opostas. Os m√©todos anteriores s√£o baseados
em caminhadas em apenas uma dire√ß√£o.
Tanto a complexidade temporal quanto a espacial dependem do n√∫mero de qubits do
registrador de dados ùëõe tamb√©m do par√¢metro ùë†‚àà[1..ùëõ] que ajusta a troca entre tempo e
espa√ßo computacional. Dado um vetor de entrada ùëÅ-dimensional (ùëÅ= 2ùëõ), a complexidade

44
Figura 23 ‚Äì Ponto de sublinearidade do algoritmo BDSP para log2(ùëÅ) = 15, indicado pela linha vermelha em
ùë†= 8.
2
4
6
8
10
12
14
s
0
50000
100000
150000
200000
250000
cnots
depth
qubits
Fonte: Elaborada pelo autor (2022)
Figura 24 ‚Äì Compara√ß√£o entre o n√∫mero de qubits e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando o algoritmo DCSP e o BDSP com configura√ß√£o sublinear ùëÇ(
‚àö
ùëÅ), em fun√ß√£o do
logaritmo do comprimento da entrada ùëõ= log2(ùëÅ).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
Dcsp
Bdsp
(a) N√∫mero de qubits
2
4
6
8
10
12
14
n
0
200
400
600
800
1000
1200
1400
1600
Dcsp
Bdsp
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
total do tempo do algoritmo bidirecional √© ùëÇùëê(ùëÅ) + ùëÇùëë(2ùë†+ log2
2(ùëÅ) ‚àíùë†2), onde ùëÇùëê(ùëÅ) √© o
tempo de pr√©-processamento cl√°ssico para criar o circuito qu√¢ntico e ùëÇùëë(2ùë†+ log2
2(ùëÅ) ‚àíùë†2)
√© a profundidade do circuito. Tipicamente o mesmo vetor de entrada √© carregado ùëô‚â´ùëÅ
vezes, portanto o tempo computacional amortizado √© ùëÇùëë(2ùë†+ log2
2(ùëÅ) ‚àíùë†2). Note que o pr√©-
processamento cl√°ssico √© comum na computa√ß√£o cl√°ssica e tamb√©m √© necess√°rio em outros
m√©todos para a prepara√ß√£o de estados qu√¢nticos. A complexidade espacial (ou seja, a largura)
do circuito √© ùëÇùë§((ùë†+ 1)ùëÅ/2ùë†) (Figura 24).
Al√©m do custo do circuito sublinear, a capacidade de configurar a troca entre os recursos

45
qu√¢nticos √© vantajosa quando especifica√ß√µes realistas de hardware qu√¢ntico s√£o consideradas,
pois um recurso pode ser mais escal√°vel do que o outro. Por exemplo, √© √∫til para os futuros
dispositivos NISQ, com a promessa de dispositivos com um grande n√∫mero de qubits f√≠si-
cos (IBM, 2020), embora o ru√≠do ainda limite a profundidade dos circuitos (PRESKILL, 2018).
Como prova de conceito, o algoritmo foi aplicado em cinco computadores qu√¢nticos acessados
atrav√©s dos servi√ßos de nuvem qu√¢ntica da IBM e da IonQ.
4.3
APPROXIMATED QUANTUM-STATE PREPARATION WITH ENTANGLEMENT DE-
PENDENT COMPLEXITY
O artigo Araujo, Blank e Silva (2022) (ap√™ndices C e D) resultou em um conjunto de
algoritmos capaz de reduzir a profundidade do circuito de prepara√ß√£o de estados ao transferir
parte da complexidade computacional para um computador cl√°ssico, mantendo a compress√£o
exponencial na largura do circuito ùëÇ(log2(ùëÅ)). O estado qu√¢ntico inicializado pode ser exato
ou aproximado. Foi demonstrado que a aproxima√ß√£o √© melhor nos processadores qu√¢nticos
atuais do que a inicializa√ß√£o do estado original. Avaliou-se atrav√©s de experimentos que o
m√©todo proposto permite a inicializa√ß√£o de distribui√ß√µes de probabilidade em estados qu√¢nticos
e o carregamento aproximado de imagens para tarefas de aprendizagem de m√°quinas qu√¢nticas.
De fato, os experimentos com dispositivos IBMQ (IBM, 2021b) mostram que o algoritmo
provavelmente auxiliar√° os profissionais da computa√ß√£o qu√¢ntica durante toda a era NISQ.
Figura 25 ‚Äì Profundidade e n√∫mero de CNOTs do circuito produzido pelo LRSP para carregar um vetor com-
plexo de dimens√£o 2ùëõem um estado qu√¢ntico aproximado com fidelidade ajustada pelo par√¢metro
ùëö.
5
4
3
2
1
0
m
0
500
1000
1500
2000
2500
cnots
depth
(a) ùëõ= 11
6
5
4
3
2
1
0
m
0
500
1000
1500
2000
2500
3000
3500
cnots
depth
(b) ùëõ= 12
6
5
4
3
2
1
0
m
0
2000
4000
6000
8000
10000
cnots
depth
(c) ùëõ= 13
7
6
5
4
3
2
1
0
m
0
2000
4000
6000
8000
10000
12000
14000
16000
cnots
depth
(d) ùëõ= 14
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(e) ùëõ= 11
6
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(f) ùëõ= 12
6
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(g) ùëõ= 13
7
6
5
4
3
2
1
0
m
0.70
0.75
0.80
0.85
0.90
0.95
1.00
1.05
fidelity
(h) ùëõ= 14
Fonte: Elaborada pelo autor (2022)

46
Algoritmos anteriores para a prepara√ß√£o de estados requerem ùëÇ(2ùëõ) CNOTs para inici-
alizar um estado qu√¢ntico arbitr√°rio exato. Entretanto, esses algoritmos n√£o consideram a
quantidade de emaranhamento. Este trabalho mostra que a complexidade do circuito para a
prepara√ß√£o do estado est√° relacionada ao emaranhamento atrav√©s de medidas num√©ricas de
emaranhamento de estados puros baseadas no quadrado dos coeficientes de Schmidt. Essas
medidas est√£o diretamente relacionadas ao n√∫mero de CNOTs necess√°rios para a inicializa√ß√£o
exata do estado (Ap√™ndice C). A redu√ß√£o da complexidade no regime qu√¢ntico n√£o √© gratuita,
pois a an√°lise do emaranhamento na etapa de preprocessamento cl√°ssico, que permite que tal
redu√ß√£o seja alcan√ßada, tem um custo c√∫bico na raiz do comprimento da entrada, que n√£o
pode ser desprezado. Portanto, h√° uma troca entre as complexidades das etapas nos regimes
cl√°ssico e qu√¢ntico.
Tabela 2 ‚Äì Erro Absoluto M√©dio entre probabilidades de medi√ß√µes de estados aproximados (0 ‚â§ùëö‚â§2) de 7
qubits gerados pelo LRSP e as probabilidades esperadas para o estado original exato (ùëö= 3).
m
CNOTs
profund.
fidelidade
ibmq_qasm_simulator
ibmq_casablanca
ibmq_jakarta
ibm_perth
0
13
11
0.78969
0.003730(0.000080)
0.004384(0.000280)
0.004394(0.000186)
0.004894(0.000467)
1
36
51
0.85460
0.003226(0.000067)
0.004557(0.000160)
0.004848(0.000286)
0.004666(0.000170)
2
84
115
0.95016
0.002068(0.000070)
0.004564(0.000173)
0.004523(0.000192)
0.004581(0.000274)
3
150
243
1.00000
0.000696(0.000049)
0.006293(0.001588)
0.005272(0.001090)
0.005353(0.000780)
Fonte: Elaborada pelo autor (2022)
Tabela 3 ‚Äì Erro Absoluto M√©dio entre probabilidades de medi√ß√µes de estados aproximados (ùëô> 0.00) de 7
qubits gerados pelo BAA e as probabilidades esperadas para o estado original exato (ùëô= 0.00).
ùëô
CNOTs
profund.
fidelidade
ibmq_qasm_simulator
ibmq_casablanca
ibmq_jakarta
ibm_perth
0.00
150
243
1.00000
0.000706(0.000064)
0.005557(0.001640)
0.005175(0.000841)
0.0054878(0.000848)
0.12
54
57
0.88742
0.003046(0.000073)
0.005015(0.000309)
0.004834(0.000212)
0.0052397(0.000347)
0.18
31
53
0.82141
0.003527(0.000101)
0.004653(0.000166)
0.004541(0.000159)
0.0051652(0.000507)
0.19
30
53
0.81630
0.003639(0.000045)
0.004630(0.000132)
0.004801(0.000208)
0.0051723(0.000338)
0.22
10
11
0.78536
0.003748(0.000069)
0.004332(0.000174)
0.004016(0.000219)
0.0048093(0.000333)
0.23
5
9
0.77064
0.003822(0.000065)
0.003976(0.000084)
0.003939(0.000070)
0.0042927(0.000290)
0.24
4
9
0.76403
0.004060(0.000074)
0.004054(0.000106)
0.004126(0.000081)
0.0043133(0.000174)
0.25
1
3
0.75097
0.004043(0.000090)
0.004214(0.000105)
0.004056(0.000079)
0.0040059(0.000068)
0.26
0
1
0.74502
0.004168(0.000059)
0.004369(0.000086)
0.004223(0.000055)
0.0042804(0.000085)
Fonte: Elaborada pelo autor (2022)
A complexidade dos circuitos produzidos pelo Low-Rank quantum State Preparation (LRSP)
pode ser determinada de maneira semelhante √† feita para a prepara√ß√£o de estados baseada
na decomposi√ß√£o de Schmidt (Se√ß√£o 2.3.2). Quando atuando em ùëòqubits, uma prepara-
√ß√£o de estados nas amplitudes requer 2ùëò‚àíùëò‚àí1 CNOTs (BERGHOLM et al., 2005), um
operador unit√°rio
23
4822ùëò‚àí3
22ùëò+ 4
3 (SHENDE; BULLOCK; MARKOV, 2006) e uma isometria
2ùëö+ùëò‚àí1
242ùëò+ùëÇ(ùëò2)2ùëö(ITEN et al., 2016). Sendo |ùúì‚ü©um estado com decomposi√ß√£o de Schmidt
|ùúì‚ü©= ‚àëÔ∏Äùëò
ùëñ=1 ùúéùëñ|ùëñùê¥‚ü©|ùëñùêµ‚ü©, onde o subsistema ‚Ñãùê¥tem ùëõùê¥qubits (1 ‚â§ùëõùê¥‚â§‚åäùëõ/2‚åã), o subsistema

47
‚Ñãùêµtem ùëõùêµ= ùëõ‚àíùëõùê¥qubits e ùëò√© o rank de Schmidt. Considerando ùëö= ‚åàlog2(ùëò)‚åâ< ùëõùê¥a
medida de Schmidt, o n√∫mero de CNOTs (Figura 25 e Tabela 2) √© dado por
ùëö< ùëõùê¥:
2ùëö‚àíùëö‚àí1
‚èü
 ‚èû
 
fase 1
+ ùëö
‚èü ‚èû 
fase 2
+ 2ùëö+ùëõùê¥‚àí1
242ùëõùê¥
‚èü
 ‚èû
 
fase 3 (isometria)
+ 2ùëö+ùëõùêµ‚àí1
242ùëõùêµ
‚èü
 ‚èû
 
fase 4 (isometria)
(4.1)
ùëö= ùëõùê¥e ùëõùê¥< ùëõùêµ:
2ùëõùê¥‚àíùëõùê¥‚àí1
‚èü
 ‚èû
 
fase 1
+ ùëõùê¥
‚èü ‚èû 
fase 2
+ 23
4822ùëõùê¥‚àí3
22ùëõùê¥+ 4
3
‚èü
 ‚èû
 
fase 3 (unit√°rio)
+ 2ùëõ‚àí1
242ùëõùêµ
‚èü
 ‚èû
 
fase 4 (isometria)
(4.2)
ùëö= ùëõùê¥e ùëõùê¥= ùëõùêµ:
2ùëõùê¥‚àíùëõùê¥‚àí1
‚èü
 ‚èû
 
fase 1
+ ùëõùê¥
‚èü ‚èû 
fase 2
+ 2
(Ô∏Ç23
482ùëõ‚àí3
22ùëõùê¥+ 4
3
)Ô∏Ç
‚èü
 ‚èû
 
fases 3 e 4 (unit√°rios)
(4.3)
As contagens acima dependem da escolha das decomposi√ß√µes para as isometrias e os unit√°-
rios. Os m√©todos escolhidos s√£o o QSD (Se√ß√£o 2.1.4) para os unit√°rios (SHENDE; BULLOCK;
MARKOV, 2006) e o CCD (Se√ß√£o 2.4.2) para as isometrias (ITEN et al., 2016). √â poss√≠vel
reduzir o n√∫mero de CNOTs das isometrias para 23
6422ùëòquando ùëö= ùëò‚àí1 usando o CSD
(Se√ß√£o 2.4.3) (ITEN et al., 2016).
Quando a biparti√ß√£o √© completamente separ√°vel (ùëö= 0), as fases 1 e 2 n√£o possuem
opera√ß√µes e as fases 3 e 4 s√£o isometrias de uma coluna. Sabendo que tais isometrias s√£o
equivalentes a uma prepara√ß√£o de estados (Se√ß√£o 2.4), elas podem ser substitu√≠das pelo pr√≥prio
LRSP. Essa opera√ß√£o √© executada recursivamente enquanto as biparti√ß√µes forem separ√°veis.
Assim, o custo assint√≥tico do circuito ùëÇ(2ùëö+ùëõùëí) ser√° determinado pela maior parti√ß√£o n√£o
separ√°vel na recurs√£o com ùëõùëíqubits.
Outro resultado deste trabalho √© a aproxima√ß√£o low-rank (ECKART; YOUNG, 1936) para
a inicializa√ß√£o de estados qu√¢nticos usando o LRSP. Fixando a medida de Schmidt ùëöe
descartando os valores singulares menos significativos, o algoritmo encontra um estado com
emaranhamento reduzido mais pr√≥ximo poss√≠vel do original. Isto leva a uma redu√ß√£o na com-
plexidade dos circuitos, o que diminui o n√∫mero de opera√ß√µes ruidosas. Mas qu√£o complexo
o estado aproximado deve ser para alcan√ßar o melhor resultado depende das caracter√≠sticas
do pr√≥prio dispositivo qu√¢ntico. A partir desta perspectiva, a abordagem tem o potencial de
caracterizar dispositivos qu√¢nticos quanto √† sua capacidade de lidar com a complexidade da
prepara√ß√£o de estados.

48
Figura 26 ‚Äì Comparativo entre estados de 7 qubits inicializados por circuitos com 21 CNOTs constru√≠dos pelos
algoritmos qGAN e BAA.
0.0
2.5
5.0
7.5   10.0  12.5  15.0  17.5  20.0
0.00
0.02
0.04
0.06
0.08
0.10
0.0
2.5
5.0
7.5 10.0 12.5 15.0 17.5 20.0
qGAN
BAA
fidelity=1.0
fidelity=0.6754
fidelity=1.0
fidelity=0.9967
Fonte: Elaborada pelo autor (2022)
Figura 27 ‚Äì Compara√ß√£o entre o n√∫mero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando o algoritmo de Schmidt e o LRSP para inicializar estados emaranhados, em fun√ß√£o
do logaritmo do comprimento da entrada ùëõ= log2(ùëÅ).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
35000
40000
Schmidt
Low-rank
(a) N√∫mero de CNOTs
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
70000
Schmidt
Low-rank
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
Uma variante da abordagem LRSP permite um algoritmo de prepara√ß√£o de estados com
erro de aproxima√ß√£o limitada (Bounded Approximation error state preparation Algorithm ou
BAA) sendo √∫til se um certo erro de aproxima√ß√£o ùëôtiver que ser observado. Os estados de
baixo emaranhamento podem ser geralmente criados como estados separ√°veis com um erro de
aproxima√ß√£o baixo e custo constante, enquanto os estados de alto emaranhamento continuam
sendo dif√≠ceis de criar. Mas mesmo para emaranhamento m√©dio h√° melhorias consider√°veis em
portas CNOT salvas, ao custo de um aumento exponencial na complexidade computacional
da etapa de preprocessamento cl√°ssico. A Figura 26 mostra um comparativo entre o BAA
e o Quantum Generative Adversarial Networks (qGAN), onde ambos os m√©todos codificam
uma distribui√ß√£o log-normal como um estado de sete qubits usando apenas 21 CNOTs em um
simulador ideal.
As tabelas 2 e 3 mostram a avalia√ß√£o do Erro Absoluto M√©dio (Mean Absolute Error ou

49
Figura 28 ‚Äì Compara√ß√£o entre o n√∫mero de CNOTs e a profundidade de circuitos produzidos pela biblioteca
qclib utilizando o algoritmo de Schmidt e o LRSP para inicializar estados parcialmente emaranha-
dos, em fun√ß√£o do logaritmo do comprimento da entrada ùëõ= log2(ùëÅ).
2
4
6
8
10
12
14
n
0
5000
10000
15000
20000
25000
30000
35000
40000
Schmidt
Low-rank
(a) N√∫mero de CNOTs
2
4
6
8
10
12
14
n
0
10000
20000
30000
40000
50000
60000
70000
Schmidt
Low-rank
(b) Profundidade
Fonte: Elaborada pelo autor (2022)
MAE) entre probabilidades ideais da medi√ß√£o de estados aleat√≥rios e as probabilidades da
medi√ß√£o dos mesmo estados codificados em tr√™s dispositivos qu√¢nticos ruidosos. Para cada
configura√ß√£o, um estado aleat√≥rio de 7 qubits foi inicializado dez vezes. Para dispositivos rui-
dosos, o menor MAE ocorre quando o emaranhamento √© menor que o do estado original. Isso
indica que, em dispositivos ruidosos, √© vantajoso usar estados aproximados com emaranha-
mento reduzido porque a perda de fidelidade introduzida pela aproxima√ß√£o √© menor que a
perda causada pelo ru√≠do de circuitos mais complexos.
4.4
QCLIB: A QUANTUM COMPUTING LIBRARY
Todos os m√©todos listados acima est√£o implementados em um reposit√≥rio de c√≥digo aberto
dispon√≠vel publicamente no github.com. A biblioteca √© chamada qclib (ARAUJO et al., 2022)
e abrange todos os c√≥digos usados nesta pesquisa, mas tamb√©m possui outras rotinas de
prepara√ß√£o de estados, unit√°rios e isometrias que est√£o dispon√≠veis de forma independente. √â
baseada no Qiskit (ALEKSANDROWICZ; AL., 2021) portanto, amplamente aplic√°vel a muitos
simuladores e dispositivos qu√¢nticos.
Um dos experimentos feitos para avaliar os limites da biblioteca, e que n√£o est√° presente
nos artigos, √© o chamado Experimento Zebra. Testamos a viabilidade de codificar a imagem de
uma zebra em dispositivos qu√¢nticos atuais. O experimento usou uma imagem preto e branco
8ppp com resolu√ß√£o de 128x128 p√≠xeis (imagem original de Brand (2019)). Tal imagem possui
16384 p√≠xeis que podem ser codificados nas amplitudes de um estado qu√¢ntico de 14 qubits.
A Figura 29a mostra os vetores de entrada aproximados pelo BAA. Os n√∫meros acima de

50
Figura 29 ‚Äì Experimento para avaliar os limites das ferramentas atuais da biblioteca qclib.
(a) Aproxima√ß√µes da imagem original produzidas pelo algoritmo BAA.
(b) Reconstru√ß√£o das imagens feitas a partir de medi√ß√µes usando um simulador qu√¢ntico ideal.
(c) Reconstru√ß√£o das imagens a partir de medi√ß√µes usando um simulador qu√¢ntico ruidoso.
Fonte: Elaborada pelo autor (2022)
cada imagem (as quais representam os vetores) √© a perda de fidelidade m√°xima ùëômax usada
nas aproxima√ß√µes. As imagens na Figura 29b foram constru√≠das a partir de medi√ß√µes usando
o simulador ideal ibmq_qasm_simulator. Um total de 20 execu√ß√µes com 8192 shots foram
aplicadas para cada vetor de entrada para alcan√ßar esse resultado.
Tabela 4 ‚Äì N√∫mero de CNOTs para inicializar um estado qu√¢ntico representando diferentes aproxima√ß√µes da
imagem usando o BAA.
ùëômax
0.0
0.01
0.02
0.03
0.04
0.05
0.06
0.07
0.08
0.09
0.1
CNOTs
18175
11292
4473
2767
2767
1087
658
251
148
54
8
Fonte: Elaborada pelo autor (2022)
Finalmente, na Figura 29c, temos um experimento similar ao da figura anterior, mas usando
os modelos de ru√≠do e conectividade do dispositivo ibmq_mumbai. Pode ser visto que o ru√≠do
eliminou a habilidade de recuperar as imagens atrav√©s de medi√ß√µes. A exce√ß√£o √© a imagem
com a aproxima√ß√£o ùëômax = 0.1. Dada essa configura√ß√£o, o circuito para a inicializa√ß√£o do
estado possui apenas 8 CNOTs (Tabela 4), mas tal redu√ß√£o faz a imagem reconhec√≠vel apenas
por suas caracter√≠sticas mais significativas. Em algumas aplica√ß√µes, como aprendizagem de
m√°quina, isso pode de fato ser suficiente, mas √© evidente que o baixo desempenho exibido
aqui limitar√° a aplica√ß√£o.
O experimento mostra que os dispositivos atuais conseguem lidar apenas com imagens
simples. E, principalmente, tamb√©m mostra que o BAA consegue ajustar as imagens conforme
a capacidade do dispositivo utilizado. Nossa expectativa √© que os futuros dispositivos NISQ
logo conseguir√£o lidar com aplica√ß√µes de imagens do mundo real.

51
5 CONCLUS√ÉO
Embora os modelos de prepara√ß√£o de estados qu√¢nticos baseados em or√°culos qu√¢n-
ticos (GROVER, 2000; SANDERS et al., 2019; WANG et al., 2021) ou mem√≥ria qu√¢ntica de
acesso aleat√≥rio (TRUGENBERGER, 2001; GIOVANNETTI; LLOYD; MACCONE, 2008b; GIOVAN-
NETTI; LLOYD; MACCONE, 2008a; VERAS et al., 2021; CASARES, 2020; MATTEO; GHEORGHIU;
MOSCA, 2020) sejam √∫teis para avaliar os limites inferiores do custo computacional e identificar
a classe de complexidade, as implementa√ß√µes dos mesmos devem ser consideradas na pr√°tica.
Em particular, a vantagem qu√¢ntica pode desaparecer sem uma implementa√ß√£o eficiente da
prepara√ß√£o de estados quando os algoritmos qu√¢nticos dependem do carregamento de dados
cl√°ssicos em uma superposi√ß√£o qu√¢ntica n√£o uniforme (AARONSON, 2015; BIAMONTE et al.,
2017; HARROW; HASSIDIM; LLOYD, 2009; TANG, 2021). Exemplos de tais casos incluem Apren-
dizagem de M√°quina Qu√¢ntica (QML) (LLOYD; MOHSENI; REBENTROST, 2013; BIAMONTE et
al., 2017; STOUDENMIRE; SCHWAB, 2016; SCHULD; FINGERHUTH; PETRUCCIONE, 2017; SCHULD;
PETRUCCIONE, 2018; BENEDETTI et al., 2019; LEVINE et al., 2019; AARONSON, 2015; BLANK et
al., 2020), Mem√≥rias Qu√¢nticas (QMem) (TRUGENBERGER, 2001; VENTURA; MARTINEZ, 2000;
TRUGENBERGER, 2002; GIOVANNETTI; LLOYD; MACCONE, 2008b; SILVA; OLIVEIRA; LUDERMIR,
2010; de Paula Neto et al., 2019; PARK; PETRUCCIONE; RHEE, 2019) e √Ålgebra Linear Qu√¢ntica
(QLA) (HARROW; HASSIDIM; LLOYD, 2009; LLOYD; MOHSENI; REBENTROST, 2014; CHILDS;
KOTHARI; SOMMA, 2017; BIAMONTE et al., 2017; WOSSNIG; ZHAO; PRAKASH, 2018; REBEN-
TROST et al., 2018). Para que essas aplica√ß√µes qu√¢nticas tornem-se realidade, √© imperativo
alcan√ßar uma inicializa√ß√£o de estados qu√¢nticos de baixa complexidade.
5.1
PRINCIPAIS RESULTADOS
As principais contribui√ß√µes desta tese resultaram em tr√™s artigos e colaboraram para a
cria√ß√£o de uma biblioteca de computa√ß√£o qu√¢ntica de c√≥digo aberto (open-source). O primeiro
artigo est√° publicado (ARAUJO et al., 2021b) e os dois restantes (ARAUJO et al., 2021a; ARAUJO;
BLANK; SILVA, 2022) foram submetidos a peri√≥dicos internacionais. Cada contribui√ß√£o busca
aperfei√ßoar resultados anteriores. A Tabela 5 resume os resultados das contribui√ß√µes, listando
as complexidades temporal e espacial dos circuitos produzidos pelos algoritmos apresentados
nesta tese para a inicializa√ß√£o de estados qu√¢nticos.

52
Tabela 5 ‚Äì Sum√°rio das contribui√ß√µes com as complexidades temporal e espacial dos circuitos produzidos pelos
algoritmos.
algoritmo
DCSP
BDSP
LRSP+BAA
temporal
ùëÇ(ùëõ2)
ùëÇ(2ùë†+ ùëõ2 ‚àíùë†2)
ùëÇ(2ùëö+ùëõùëí)
espacial
ùëÇ(2ùëõ)
ùëÇ((ùë†+ 1)2ùëõ‚àíùë†)
ùëÇ(ùëõ)
coment√°rio
Troca entre complexidade
Troca configur√°vel entre
Complexidade depende de
temporal e espacial.
complexidade temporal e
propriedades do estado. Pode
Informa√ß√£o emaranhada
espacial.
ser reduzida arbitrariamente
com qubits auxiliares.
Informa√ß√£o emaranhada
em troca da perda de fidelidade.
com qubits auxiliares.
Informa√ß√£o n√£o emaranhada
com qubits auxiliares.
Fonte: Elaborada pelo autor (2022)
5.1.1
Algoritmo do tipo divis√£o e conquista para a prepara√ß√£o de estados qu√¢nticos
A primeira contribui√ß√£o, um algoritmo do tipo divis√£o e conquista para a prepara√ß√£o de
estados (Divide-and-Conquer quantum State Preparation ou DCSP), produz um circuito qu√¢n-
tico com profundidade polilogar√≠tmica ùëÇ(log2
2(ùëÅ)), uma redu√ß√£o exponencial em rela√ß√£o a
resultados anteriores (Se√ß√£o 4.1 e Ap√™ndice A). Em troca, a largura do circuito √© exponencial-
mente maior, ùëÇ(ùëÅ) contra ùëÇ(log2(ùëÅ)), e a informa√ß√£o √© emaranhada com qubits auxiliares.
5.1.2
Algoritmo bidirecional para a prepara√ß√£o de estados qu√¢nticos
O aumento exponencial na largura do circuito causado pelo DCSP √© reduzido pela prepa-
ra√ß√£o bidirecional de estados qu√¢nticos (Bidirectional quantum State Preparation ou BDSP),
segunda contribui√ß√£o da nossa pesquisa (Se√ß√£o 4.2 e Ap√™ndice B). Essa estrat√©gia permite
regular a troca entre tempo ùëÇ(2ùë†+ ùëõ2 ‚àíùë†2) e espa√ßo ùëÇ((ùë†+ 1)2ùëõ‚àíùë†) atrav√©s do par√¢metro
ùë†, alcan√ßando complexidade sublinear ùëÇ(
‚àö
ùëÅ) simult√¢nea em ambas as dimens√µes quando
ùë†= ùëõ/2 e ùëÅ‚â´1. Embora reduzido, ainda h√° emaranhamento entre a informa√ß√£o e qubits
auxiliares.
5.1.3
Algoritmo baseado na decomposi√ß√£o de Schmidt e na aproxima√ß√£o de baixo
posto para a prepara√ß√£o de estados qu√¢nticos
Para solucionar o aumento na complexidade espacial do circuito e o emaranhamento com
qubits auxiliares, a terceira contribui√ß√£o usa o emaranhamento como um recurso computacional

53
(Se√ß√£o 4.3 e ap√™ndices C e D). Ao associar o emaranhamento √† complexidade da prepara√ß√£o
de estados qu√¢nticos, h√° maior controle sobre o n√∫mero de CNOTs necess√°rios para a iniciali-
za√ß√£o de estados. Tal controle permite reduzir a complexidade temporal ùëÇ(2ùëö+ùëõùëí) mantendo
a largura do circuito ùëÇ(ùëõ), sem a necessidade de qubits auxiliares. Por exemplo, um estado
completamente separ√°vel (sem emaranhamento, ùëö= 0 e ùëõùëí= 1) √© codificado usando apenas
duas camadas de rota√ß√µes e nenhum CNOT. Ainda √© poss√≠vel impor uma redu√ß√£o de emara-
nhamento para obter um estado aproximado em troca de um erro (Low-Rank quantum State
Preparation ou LRSP).
5.1.4
Algoritmo de aproxima√ß√£o com erro limitado para a prepara√ß√£o de estados
qu√¢nticos
A abordagem do algoritmo LRSP, em particular sua aproxima√ß√£o, pode ser generalizada
por um algoritmo de busca recursivo que fornece uma aproxima√ß√£o at√© um determinado erro
(Bounded Approximation error state preparation Algorithm ou BAA) e assim economiza o uso
dos operadores CNOT, ao mesmo tempo em que fornece uma garantia de proximidade com o
estado original.
O LRSP √© baseado na decomposi√ß√£o de Schmidt e seu desempenho pode ser aprimorado
atrav√©s de uma escolha cuidadosa das biparti√ß√µes. A fun√ß√£o do BAA √© encontrar a sequ√™ncia
de biparti√ß√µes que permite ao LRSP produzir o circuito para a inicializa√ß√£o de estados com o
menor n√∫mero de portas CNOT.
5.1.5
Biblioteca de c√≥digo aberto para computa√ß√£o qu√¢ntica
Por fim, a pesquisa desta tese contribuiu com uma biblioteca de c√≥digo aberto (ARAUJO
et al., 2022) que implementa todos os c√≥digos usados nesta pesquisa, mas n√£o limitada a eles
(Se√ß√£o 4.4).
A Tabela 6 compara numericamente os circuitos produzidos por diferentes m√©todos para
codificar estados exatos de 14 e 15 qubits. Os m√©todos LRSP, BDSP e DCSP s√£o contribui-
√ß√µes desta pesquisa e est√£o implementadas na biblioteca qclib (ARAUJO et al., 2022). O m√©todo
baseado na decomposi√ß√£o de Schmidt (Se√ß√£o 2.3.2) (PLESCH; BRUKNER, 2011) tamb√©m est√°
implementado na biblioteca qclib. Embora o qclib implemente as prepara√ß√µes de estados ba-
seadas na isometria CCD (Se√ß√£o 2.4.2) (ITEN et al., 2016) e em multiplexadores (SHENDE;

54
Tabela 6 ‚Äì Comparativo num√©rico entre n√∫mero de qubits, CNOTs e profundidade de circuitos constru√≠dos
pelas bibliotecas qclib e IBM Qiskit usando diferentes algoritmos para a codifica√ß√£o de vetores
complexos com dimens√£o 2ùëõ.
ùëõ= 14
ùëõ= 15
m√©todo
lib
qubits
cnots
profund.
qubits
cnots
profund.
LRSP
qclib
14
15425
17719
15
30999
53643
Schmidt
qclib
14
15454
17821
15
38814
71581
Isometria
Qiskit
14
16369
65479
15
32752
131011
Multiplexador
Qiskit
14
32738
65492
15
65504
131025
BDSP
qclib
1023
38792
1046
1151
72320
1603
DCSP
qclib
16383
130952
783
32767
262016
899
Fonte: Elaborada pelo autor (2022)
BULLOCK; MARKOV, 2006), para esse comparativo decidimos usar a implementa√ß√£o da bibli-
oteca Qiskit da IBM (ALEKSANDROWICZ; AL., 2021). O m√©todo Multiplexador implementa o
algoritmo de Mottonen et al. (2005) (Se√ß√£o 2.3.1) otimizado com o uso dos multiplexadores de
Shende, Bullock e Markov (2006). Esse √∫ltimo √© a prepara√ß√£o de estados padr√£o das bibliotecas
Qiskit (ALEKSANDROWICZ; AL., 2021) e PennyLane (BERGHOLM et al., 2020). A isometria (ITEN
et al., 2016) e o m√©todo baseado na decomposi√ß√£o de Schmidt (PLESCH; BRUKNER, 2011), am-
bos com as otimiza√ß√µes sugeridas em (SHENDE; BULLOCK; MARKOV, 2006) (Se√ß√£o 2.1.4), eram
os m√©todos mais eficientes para a codifica√ß√£o exata de estados qu√¢nticos arbitr√°rios (PLESCH;
BRUKNER, 2011; ITEN et al., 2016; MALVETTI; ITEN; COLBECK, 2021).
5.2
TRABALHOS FUTUROS
5.2.1
Big-data state preparation
Todos os m√©todos para a prepara√ß√£o de estados qu√¢nticos apresentados at√© o momento
possuem custo de pr√©-processamento cl√°ssico exponencial, limitando seu uso a estados com
poucos qubits. ùëõqubits implica armazenar 2ùëõamplitudes. Usando uma estimativa simplista
- 16 bytes por amplitude complexa - s√£o necess√°rios 2ùëõ+4 bytes para armazenar um estado
qu√¢ntico de ùëõqubits. Portanto, para 50 qubits s√£o necess√°rios 254 ‚âà18 √ó 1015 bytes (18
petabytes), o que √© invi√°vel mesmo para os supercomputadores atuais. A normaliza√ß√£o de tal
estado √© um desafio ainda maior. Mas √© justamente nesta escala que os algoritmos qu√¢nticos
conseguir√£o demonstrar a vantagem qu√¢ntica (PRESKILL, 2018), quando executar√£o solu√ß√µes
impratic√°veis para os computadores cl√°ssicos.

55
Figura 30 ‚Äì M√©todo bidirecional usando BAA.
|0‚ü©0
DCSP
|0‚ü©1
BAA1
|0‚ü©3
|0‚ü©2
BAA2
|0‚ü©5
output
input
ancilla
Fonte: Elaborada pelo autor (2022)
Para contornar esse problema podemos aplicar o BDSP (Se√ß√£o 4.2), combinando o BAA
(Se√ß√£o 4.3) com o DCSP (Se√ß√£o 4.1). Dessa maneira, estados muito largos podem ser dividi-
dos em estados menores e combinados no pr√≥prio computador qu√¢ntico (Figura 30), reduzindo
exponencialmente o teto da mem√≥ria cl√°ssica requerida para preparar o estado ‚Äì 2ùëõ‚àíùë†subes-
tados de 2ùë†amplitudes, com 1 ‚â§ùë†‚â§ùëõ(Ap√™ndice B). Adicionalmente, a complexidade do
circuito √© dominada pela fase do DCSP, que possui custo polilogar√≠tmico, pois a complexidade
do BAA pode ser reduzida arbitrariamente em troca de uma perda de fidelidade.
Por exemplo, sendo ùëõ= 50 e ùë†= 40, o BDSP gera 210 subestados com 240 amplitudes
(uma redu√ß√£o de 10 qubits em rela√ß√£o ao estado original). Cada subestado ocupa 244 ‚âà
16 √ó 1012 bytes (16 terabytes) de armazenamento (uma redu√ß√£o de aproximadamente 1000
vezes em rela√ß√£o ao teto do armazenamento original). Essa configura√ß√£o produz um circuito
qu√¢ntico com (ùë†+ 1)2ùëõ‚àíùë†‚àí1 = 41 √ó 210 ‚àí1 = 41983 qubits. A fase DCSP, respons√°vel
por combinar os subestados, tem profundidade de ‚àëÔ∏Äùëõ
ùëñ=ùë†+1 ùëñ‚àí1 = ‚àëÔ∏Ä50
41 ùëñ‚àí1 = 445 camadas
de operadores swap controlados. Espera-se que nos pr√≥ximos anos essa ordem no n√∫mero
de qubits seja alcan√ßada (IBM, 2021a). A transfer√™ncia de tais circuitos para o computador
qu√¢ntico ainda √© um problema que precisa ser resolvido.
5.2.2
Tensor based quantum state preparation
O algoritmo de Plesch (PLESCH; BRUKNER, 2011) utiliza o SVD para executar uma decom-
posi√ß√£o de Schmidt, dividindo o estado em duas parti√ß√µes iguais e sequenciais (se a dimens√£o
do estado for √≠mpar, uma das partes ser√° maior, pois dim(‚Ñã1) = ‚åäùëõ/2‚åãe dim(‚Ñã2) = ‚åàùëõ/2‚åâ).
O Low-Rank quantum State Preparation (LRSP) flexibiliza o algoritmo, permitindo que as

56
parti√ß√µes possuam qualquer tamanho (m√≠nimo de 1 qubit e m√°ximo de n-1 qubits) e sejam
compostas de qubits n√£o sequenciais. Mas ainda temos a limita√ß√£o de apenas duas parti√ß√µes.
O novo m√©todo baseado na decomposi√ß√£o tensorial generaliza o LRSP, tornando configur√°vel
o n√∫mero de parti√ß√µes.
Figura 31 ‚Äì Decomposi√ß√£o tensorial do estado em uma sequ√™ncia de operadores atuando em um n√∫mero
crescente de qubits.
|core1‚ü©
A1
A2
A3
(a)
|core2‚ü©
B1
A1
B2,3
A2
A3
(b)
|core3‚ü©
C1,2
B1
A1
B2,3
A2
C3
A3
(c)
|core4‚ü©
D1,3
C1,2
B1
A1
D2
B2,3
A2
D1,3
C3
A3
(d)
|0‚ü©
E1,2,3
D1,3
C1,2
B1
A1
D2
B2,3
A2
D1,3
C3
A3
(e)
Fonte: Elaborada pelo autor (2022)
A principal consequ√™ncia do m√©todo tensorial √© que mais CNOTs poder√£o ser manipulados
para gerenciar o emaranhamento do estado, abrindo novas possibilidades para algoritmos de
busca como o BAA. A Figura 31 exibe exemplos dos circuitos produzidos pela nova abordagem.
A decomposi√ß√£o total, calculada atrav√©s da decomposi√ß√£o recursiva de vetores tipo core,
produz um circuito com operadores atuando em todas as combina√ß√µes de qubits (Figura 31e).
Um vetor core √© constru√≠do pelo redimensionamento de um tensor core. No primeiro passo
do algoritmo (Figura 31a), o vetor |ùëêùëúùëüùëí1‚ü©e os operadores ùê¥ùëós√£o calculados a partir da
decomposi√ß√£o tensorial do vetor de entrada. No segundo passo (Figura-31b), o vetor |ùëêùëúùëüùëí2‚ü©
e os operadores ùêµùëós√£o calculados a partir da decomposi√ß√£o tensorial do |ùëêùëúùëüùëí1‚ü©. A recurs√£o
continua at√© o √∫ltimo passo (Figura 31e), onde o vetor core √© igual ao primeiro vetor da base
computacional |0‚ü©, encerrando a recurs√£o. Idealmente, os operadores maiores devem possuir
correla√ß√£o apenas entre os qubits mais distantes, pois as correla√ß√µes entre qubits mais pr√≥ximos
s√£o estabelecidas pelos operadores menores.
Um algoritmo de busca, como o BAA, pode alcan√ßar uma aproxima√ß√£o limitada por um
erro m√°ximo removendo operadores sistematicamente. Outra alternativa √© guiar a aproxima√ß√£o

57
segundo o mapa de acoplamento dos qubits do dispositivo alvo, mantendo apenas os operado-
res que atuam em qubits conectados diretamente no mapa ou minimizando as dist√¢ncias das
conex√µes. As conex√µes podem at√© mesmo ser priorizadas de acordo com sua qualidade. Ainda
√© poss√≠vel selecionar os operadores de acordo com o erro de CNOT entre os qubits, medida
que incorpora a dist√¢ncia e a qualidade das conex√µes.
Assim como no LRSP, o m√©todo tensorial tamb√©m permite aproxima√ß√µes tipo low-rank
do estado original. Por exemplo, o low multilinear rank (VANNIEUWENHOVEN; VANDEBRIL;
MEERBERGEN, 2012) modifica o m√©todo HOSVD aplicando uma s√©rie de aproxima√ß√µes low-
rank (alterando a linha 3 do Algoritmo 4). Como resultado dessa aproxima√ß√£o, os fatores da
decomposi√ß√£o s√£o isometrias, reduzindo a complexidade dos circuitos produzidos.
De maneira geral, o rank de um tensor ùí≥de ordem ùëÅ√© definido como o n√∫mero m√≠nimo
de tensores rank-1 necess√°rios para produzir ùí≥como sua soma.
ùí≥=
ùëÖ
‚àëÔ∏Å
ùëü=1
ùúÜùëüa(1)
ùëü
‚äóa(2)
ùëü
‚äó¬∑ ¬∑ ¬∑ ‚äóa(ùëÅ)
ùëü
=
[Ô∏Å
ùúÜ; A(1), A(2), . . . , A(ùëÅ)]Ô∏Å
Consequentemente, o n√∫mero de parti√ß√µes (portanto, de subespa√ßos) √© dado pelo modo (ou
ordem) do tensor.
Para construirmos algoritmos precisamos de m√©todos para elaborar a decomposi√ß√£o tenso-
rial de maneira eficiente. O m√©todo pretendido √© o HOSVD, tamb√©m conhecido como Multi-
linear Singular Value Decomposition (LATHAUWER; MOOR; VANDEWALLE, 2000). O HOSVD √©
uma decomposi√ß√£o de Tucker ortogonal. A ortogonalidade indica que os fatores A(ùëõ) obtidos
atrav√©s desse m√©todo s√£o matrizes unit√°rias. O Algoritmo 4 descreve seu funcionamento.
Algoritmo 4: Decomposi√ß√£o HOSVD de um tensor ùí≥em um tensor core ùí¢e seus
fatores A(1), . . . , A(ùëÅ).
input : Um tensor ùí≥e uma lista de ranks ùëÖùëñ(1 ‚â§ùëñ‚â§ùëÅ).
output: Tensor core ùí¢e os fatores A(1), . . . , A(ùëÅ).
1 Faz ùëõ= 1
2 Faz X(ùëõ) igual ao unfold de ordem ùëõdo tensor ùí≥
3 Aplica o SVD √† matriz X(ùëõ) = A(ùëõ)Œ£ùëõVùëá
ùëõe armazena o fator A(ùëõ)
4 Se ùëõ< ùëÅ, faz ùëõ= ùëõ+ 1 e retorna para 2, caso contr√°rio continua
5 Calcula o tensor core ùí¢= ùí≥√ó1 A(1)‚Ä† √ó2 ¬∑ ¬∑ ¬∑ √óùëÅA(ùëÅ)‚Ä†
6 Retorna ùí¢, A(1), . . . , A(ùëÅ).
Fonte: Elaborado pelo autor (2022)

58
5.3
OBSERVA√á√ïES FINAIS
A maioria dos algoritmos qu√¢nticos n√£o apresenta vantagem no carregamento de dados
cl√°ssicos em um estado qu√¢ntico (BIAMONTE et al., 2017; AARONSON, 2015). Os m√©todos
apresentados neste trabalho prop√µem novos paradigmas para a prepara√ß√£o de estados qu√¢nticos
que podem complementar ou melhorar os m√©todos conhecidos, tais como a codifica√ß√£o nos
√¢ngulos, codifica√ß√£o na base, e a codifica√ß√£o nas amplitudes (se√ß√µes 2.2.1, 2.2.3 e 2.2.2).
O primeiro conjunto de algoritmos (se√ß√µes 4.1 e 4.2 e ap√™ndices A e B), baseados em Mot-
tonen et al. (2005) e na abordagem de divis√£o e conquista, alcan√ßa uma redu√ß√£o exponencial
no tempo para carregar um vetor de dados cl√°ssicos em um estado qu√¢ntico em compara-
√ß√£o a solu√ß√µes anteriores como as baseadas em rota√ß√µes (Se√ß√£o 2.3.1) e na decomposi√ß√£o de
Schmidt (Se√ß√£o 2.3.2). Tal ganho possui impacto potencial na solu√ß√£o de problemas de apren-
dizagem de m√°quinas qu√¢ntica e outros algoritmos qu√¢nticos que precisam carregar dados de
dispositivos cl√°ssicos.
Como prova de conceito, a validade e a viabilidade desses m√©todos foram verificadas
utilizando a plataforma de nuvem qu√¢ntica da IBM (IBM, 2021b). Al√©m disso, os experimentos
num√©ricos mostraram que os novos m√©todos de codifica√ß√£o oferecem vantagens, reduzindo a
complexidade e os recursos computacionais quando aplicado em conjunto com os algoritmos
existentes. Espera-se que estas vantagens se estendam a outros casos.
O segundo conjunto de algoritmos (Se√ß√£o 4.3 e ap√™ndices C e D) √© fundamentado em Plesch
e Brukner (2011) e utiliza a rela√ß√£o entre emaranhamento qu√¢ntico e prepara√ß√£o de esta-
dos (MORA; BRIEGEL, 2005; MORA; BRIEGEL, 2006) para fornecer uma melhor compreens√£o
da complexidade da inicializa√ß√£o de estados. Demonstrou-se que o grau de emaranhamento
do estado est√° diretamente associado ao n√∫mero de operadores CNOT necess√°rios para a sua
inicializa√ß√£o. Portanto, a manipula√ß√£o do emaranhamento atrav√©s da aproxima√ß√£o de low-rank
tem impacto direto na complexidade do circuito.
Experimentos com sete dispositivos qu√¢nticos (IBM, 2021b) mostram que as medi√ß√µes
do estado gerado pelos circuitos aproximados pelo low-rank s√£o mais pr√≥ximas dos resultados
esperados do que as medi√ß√µes usando o circuito exato. Isso ocorre porque o algoritmo encontra
um estado com emaranhamento reduzido o mais pr√≥ximo poss√≠vel do original. Isto leva a uma
redu√ß√£o na complexidade dos circuitos, diminuindo o n√∫mero de opera√ß√µes ruidosas. Uma
aproxima√ß√£o de low-rank do estado pode viabilizar o circuito final em dispositivos ruidosos
para aplica√ß√µes que dependem do carregamento de dados em um estado qu√¢ntico arbitr√°rio.

59
Um exemplo de aplica√ß√£o de aprendizagem de m√°quina qu√¢ntica do tipo Variational Quan-
tum Classifier (VQC) (HAVL√≠ƒçEK et al., 2019; SCHULD et al., 2020) mostra que o ajuste dos dados
de entrada conforme a capacidade do dispositivo em gerenciar o emaranhamento, melhora o
desempenho do classificador (Ap√™ndice C). Al√©m disso, as aplica√ß√µes VQC t√™m a caracter√≠stica
de carregar o mesmo vetor de entrada muitas vezes, amortizando o tempo computacional do
pr√©-processamento cl√°ssico.

60
REFER√äNCIAS
AARONSON, S. Read the fine print. Nature Physics, v. 11, n. 4, p. 291‚Äì293, 2015.
ALEKSANDROWICZ, G.; AL. et. Qiskit: An Open-source Framework for Quantum
Computing. 2021.
AMIN, M. H.; ANDRIYASH, E.; ROLFE, J.; KULCHYTSKYY, B.; MELKO, R. Quantum
boltzmann machine. Phys. Rev. X, American Physical Society, v. 8, p. 021050, May 2018.
ARAUJO, I. F.; BLANK, C.; SILVA, A. da; CESAR, I.; SILVA, L. Quantum computing library
(qclib). GitHub, 2022. Dispon√≠vel em: <https://github.com/qclib/qclib>.
ARAUJO, I. F.; BLANK, C.; SILVA, A. J. da. Approximated quantum-state preparation
with entanglement dependent complexity. arXiv:2111.03132 [quant-ph], maio 2022. ArXiv:
2111.03132.
ARAUJO, I. F.; PARK, D. K.; LUDERMIR, T. B.; OLIVEIRA, W. R.; PETRUCCIONE, F.;
SILVA, A. J. da. Configurable sublinear circuits for quantum state preparation. arXiv, 2021.
ARAUJO, I. F.; PARK, D. K.; PETRUCCIONE, F.; SILVA, A. J. da. A divide-and-conquer
algorithm for quantum state preparation. Scientific Reports, v. 11, n. 1, p. 6329, 2021.
ARUNACHALAM, S.; GHEORGHIU, V.; JOCHYM-O‚ÄôCONNOR, T.; MOSCA, M.;
SRINIVASAN, P. V. On the robustness of bucket brigade quantum RAM. New Journal of
Physics, IOP Publishing, v. 17, n. 12, p. 123010, 2015.
ARUTE, F.; ARYA, K.; BABBUSH, R.; BACON, D.; BARDIN, J. C.; BARENDS, R.;
BISWAS, R.; BOIXO, S.; BRANDAO, F. G.; BUELL, D. A. et al. Quantum supremacy
using a programmable superconducting processor. Nature, Nature Publishing Group, v. 574,
n. 7779, p. 505‚Äì510, 2019.
BARENCO, A. A universal two-bit gate for quantum computation. Proceedings of the
Royal Society of London. Series A: Mathematical and Physical Sciences, v. 449, n. 1937, p.
679‚Äì683, jun. 1995. ISSN 0962-8444, 2053-9177.
BARENCO, A.; BENNETT, C. H.; CLEVE, R.; DIVINCENZO, D. P.; MARGOLUS, N.;
SHOR, P.; SLEATOR, T.; SMOLIN, J. A.; WEINFURTER, H. Elementary gates for quantum
computation. Phys. Rev. A, American Physical Society, v. 52, p. 3457‚Äì3467, 1995.
BARNUM, H.; LINDEN, N. Monotones and invariants for multi-particle quantum states.
Journal of Physics A: Mathematical and General, v. 34, n. 35, p. 6787, 2001. ISSN 0305-4470.
BARREIRO, J. T.; SCHINDLER, P.; G√ºHNE, O.; MONZ, T.; CHWALLA, M.; ROOS, C. F.;
HENNRICH, M.; BLATT, R. Experimental multiparticle entanglement dynamics induced by
decoherence. Nature Physics, v. 6, p. 943‚Äì946, 2010. ISSN 1745-2473.
BENEDETTI, M.; LLOYD, E.; SACK, S.; FIORENTINI, M. Parameterized quantum circuits
as machine learning models. Quantum Science and Technology, 2019.
BENIOFF, P. The computer as a physical system: A microscopic quantum mechanical
Hamiltonian model of computers as represented by Turing machines. Journal of Statistical
Physics, v. 22, n. 5, p. 563‚Äì591, maio 1980. ISSN 0022-4715, 1572-9613.

61
BERGHOLM, V.; IZAAC, J.; SCHULD, M.; GOGOLIN, C.; ALAM, M. S.; AHMED, S.;
ARRAZOLA, J. M.; BLANK, C.; DELGADO, A.; JAHANGIRI, S.; MCKIERNAN, K.;
MEYER, J. J.; NIU, Z.; SZ√°VA, A.; KILLORAN, N. PennyLane: Automatic differentiation of
hybrid quantum-classical computations. 2020.
BERGHOLM, V.; VARTIAINEN, J. J.; M√∂TT√∂NEN, M.; SALOMAA, M. M. Quantum
circuits with uniformly controlled one-qubit gates. Physical Review A, v. 71, n. 5, p. 052330,
2005.
BIAMONTE, J.; WITTEK, P.; PANCOTTI, N.; REBENTROST, P.; WIEBE, N.; LLOYD, S.
Quantum machine learning. Nature, v. 549, n. 7671, p. 195‚Äì202, 2017.
BLANK, C.; PARK, D. K.; PETRUCCIONE, F. Quantum-enhanced analysis of discrete
stochastic processes. npj Quantum Information, Nature Publishing Group, v. 7, n. 1, p. 1‚Äì9,
2021.
BLANK, C.; PARK, D. K.; RHEE, J.-K. K.; PETRUCCIONE, F. Quantum classifier with
tailored quantum kernel. npj Quantum Information, v. 6, n. 1, p. 1‚Äì7, 2020.
BRAND, J. 2019. [Online; accessed March 3, 2022]. Dispon√≠vel em: <https://unsplash.com/
photos/dbz3gmdubqw>.
CALDERBANK, A. R.; SHOR, P. W. Good quantum error-correcting codes exist. Phys. Rev.
A, American Physical Society, v. 54, p. 1098‚Äì1105, 1996.
CASARES, P. A. M. Circuit implementation of bucket brigade qram for quantum state
preparation. arXiv, 2020.
CHILDS, A. M.; KOTHARI, R.; SOMMA, R. D. Quantum algorithm for systems of linear
equations with exponentially improved dependence on precision. SIAM Journal on Computing,
Society for Industrial Applied Mathematics (SIAM), v. 46, n. 6, p. 1920‚Äì1950, 2017.
CLEVE, R.; GOTTESMAN, D.; LO, H.-K. How to share a quantum secret. Phys. Rev. Lett.,
American Physical Society, v. 83, p. 648‚Äì651, 1999.
CORTESE, J. A.; BRAJE, T. M. Loading Classical Data into a Quantum Computer. 2018.
de Paula Neto, F. M.; da Silva, A. J.; de Oliveira, W. R.; LUDERMIR, T. B. Quantum
probabilistic associative memory architecture. Neurocomputing, v. 351, p. 101‚Äì110, 2019.
DEUTSCH, D.; JOZSA, R. Rapid solution of problems by quantum computation. Proceedings
of the Royal Society of London. Series A: Mathematical and Physical Sciences, v. 439,
n. 1907, p. 553‚Äì558, 1992.
DEUTSCH, D.; PENROSE, R. Quantum theory, the Church‚ÄìTuring principle and the
universal quantum computer. Proceedings of the Royal Society of London. A. Mathematical
and Physical Sciences, v. 400, n. 1818, p. 97‚Äì117, jul. 1985.
DEUTSCH, D. E.; BARENCO, A.; EKERT, A. Universality in quantum computation.
Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences,
v. 449, n. 1937, p. 669‚Äì677, jun. 1995. ISSN 0962-8444, 2053-9177.
DIVINCENZO, D. P. Two-bit gates are universal for quantum computation. Phys. Rev. A,
American Physical Society, v. 51, p. 1015‚Äì1022, Feb 1995.

62
DIVINCENZO, D. P. The physical implementation of quantum computation. Fortschritte der
Physik, v. 48, n. 9-11, p. 771‚Äì783, 2000.
DONNE, J. Devotions upon Emergent Occasions. 2007. ed. London: Project Gutenberg,
1624.
DUNJKO, V.; TAYLOR, J. M.; BRIEGEL, H. J. Quantum-enhanced machine learning. Phys.
Rev. Lett., American Physical Society, v. 117, p. 130501, Sep 2016.
D√ºR, W.; CIRAC, J. I. Multiparty teleportation. Journal of Modern Optics, Taylor Francis,
v. 47, n. 2-3, p. 247‚Äì255, 2000.
ECKART, C.; YOUNG, G. The approximation of one matrix by another of lower rank.
Psychometrika, Springer, v. 1, n. 3, p. 211‚Äì218, 1936.
ENR√≠QUEZ, M.; PUCHA≈ÇA, Z.; ≈ªYCZKOWSKI, K. Minimal r√©nyi‚Äìingarden‚Äìurbanik entropy
of multipartite quantum states. Entropy, v. 17, n. 7, p. 5063‚Äì5084, 2015. ISSN 1099-4300.
FEYNMAN, R. P. Simulating physics with computers. International Journal of Theoretical
Physics, v. 21, n. 6-7, p. 467‚Äì488, jun. 1982. ISSN 0020-7748, 1572-9575.
GIDNEY, C.; EKER√Ö, M. How to factor 2048 bit RSA integers in 8 hours using 20
million noisy qubits. Quantum, Verein zur F√∂rderung des Open Access Publizierens in den
Quantenwissenschaften, v. 5, p. 433, abr. 2021. ISSN 2521-327X.
GIOVANNETTI, V.; LLOYD, S.; MACCONE, L. Architectures for a quantum random access
memory. Phys. Rev. A, American Physical Society, v. 78, p. 052310, 2008.
GIOVANNETTI, V.; LLOYD, S.; MACCONE, L. Quantum random access memory. Phys.
Rev. Lett., American Physical Society, v. 100, p. 160501, 2008.
GLEINIG, N.; HOEFLER, T. An Efficient Algorithm for Sparse Quantum State Preparation.
In: 2021 58th ACM/IEEE Design Automation Conference (DAC). San Francisco, CA, USA:
IEEE, 2021. p. 433‚Äì438. ISBN 9781665432740.
GRASEDYCK, L. Hierarchical singular value decomposition of tensors. SIAM J. Matrix Anal.
Appl., Society for Industrial and Applied Mathematics, USA, v. 31, n. 4, p. 2029‚Äì2054, 2010.
ISSN 0895-4798.
GROVER, L. K. A fast quantum mechanical algorithm for database search. In: Proceedings
of the twenty-eighth annual ACM symposium on Theory of Computing. Philadelphia,
Pennsylvania, USA: Association for Computing Machinery, 1996. (STOC ‚Äô96), p. 212‚Äì219.
GROVER, L. K. Synthesis of Quantum Superpositions by Quantum Computation. Physical
Review Letters, v. 85, n. 6, p. 1334‚Äì1337, 2000.
GUNDLAPALLI, P.; LEE, J. Deterministic, scalable, and entanglement efficient initialization
of arbitrary quantum states. arXiv, 2021.
GUO, S.-F.; CHEN, F.; LIU, Q.; XUE, M.; CHEN, J.-J.; CAO, J.-H.; MAO, T.-W.; TEY,
M. K.; YOU, L. Faster state preparation across quantum phase transition assisted by
reinforcement learning. Phys. Rev. Lett., American Physical Society, v. 126, p. 060401, 2021.
HARROW, A. W.; HASSIDIM, A.; LLOYD, S. Quantum algorithm for linear systems of
equations. Phys. Rev. Lett., American Physical Society, v. 103, p. 150502, 2009.

63
HAVL√≠ƒçEK, V.; C√≥RCOLES, A. D.; TEMME, K.; HARROW, A. W.; KANDALA, A.; CHOW,
J. M.; GAMBETTA, J. M. Supervised learning with quantum-enhanced feature spaces.
Nature, v. 567, p. 209‚Äì212, 2019.
HILL, S. A.; WOOTTERS, W. K. Entanglement of a pair of quantum bits. Phys. Rev. Lett.,
American Physical Society, v. 78, p. 5022‚Äì5025, Jun 1997.
HOGG, T.; HUBERMAN, B. A.; WILLIAMS, C. P. Phase transitions and the search problem.
Artificial Intelligence, v. 81, n. 1, p. 1‚Äì15, 1996. Frontiers in Problem Solving: Phase
Transitions and Complexity.
IBM. IBM‚Äôs Roadmap For Scaling Quantum Technology. 2020. Dispon√≠vel em:
<https://research.ibm.com/blog/ibm-quantum-roadmap>.
IBM. Expanding the IBM Quantum Roadmap to anticipate the future of quantum-
centric supercomputing. 2021. Dispon√≠vel em: <https://research.ibm.com/blog/
ibm-quantum-roadmap-2025>.
IBM. IBM Quantum. 2021. Dispon√≠vel em: <https://quantum-computing.ibm.com/>.
ITEN, R.; COLBECK, R.; KUKULJAN, I.; HOME, J.; CHRISTANDL, M. Quantum circuits
for isometries. Physical Review A, APS, v. 93, n. 3, p. 032318, 2016.
JOZSA, R.; LINDEN, N. On the role of entanglement in quantum-computational speed-up.
Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering
Sciences, The Royal Society, v. 459, n. 2036, p. 2011‚Äì2032, 2003.
KHANEJA, N.; BROCKETT, R.; GLASER, S. J. Time optimal control in spin systems. Phys.
Rev. A, American Physical Society, v. 63, p. 032308, 2001.
KIEFEROV√Å, M.; WIEBE, N. Tomography and generative training with quantum boltzmann
machines. Phys. Rev. A, American Physical Society, v. 96, p. 062327, Dec 2017.
KNILL, E. Approximation by quantum circuits. arXiv, 1995.
KOLDA, T. G.; BADER, B. W. Tensor Decompositions and Applications. SIAM Review,
v. 51, n. 3, p. 455‚Äì500, 2009. ISSN 0036-1445.
KRAUS, B.; CIRAC, J. I. Optimal creation of entanglement using a two-qubit gate. Phys.
Rev. A, American Physical Society, v. 63, p. 062309, May 2001.
KUZMIN, V. V.; SILVI, P. Variational quantum state preparation via quantum data buses.
Quantum, Verein zur F√∂rderung des Open Access Publizierens in den Quantenwissenschaften,
v. 4, p. 290, 2020. ISSN 2521-327X.
LATHAUWER, L. D.; MOOR, B. D.; VANDEWALLE, J. A multilinear singular value
decomposition. SIAM Journal on Matrix Analysis and Applications, v. 21, n. 4, p. 1253‚Äì1278,
2000.
LEVINE, Y.; SHARIR, O.; COHEN, N.; SHASHUA, A. Quantum Entanglement in Deep
Learning Architectures. Physical Review Letters, v. 122, n. 6, p. 065301, 2019.
LEYMANN, F.; BARZEN, J. The bitter truth about gate-based quantum algorithms in the
NISQ era. Quantum Science and Technology, IOP Publishing, v. 5, n. 4, p. 044007, 2020.

64
LLOYD, S. Almost any quantum logic gate is universal. Phys. Rev. Lett., American Physical
Society, v. 75, p. 346‚Äì349, Jul 1995.
LLOYD, S.; MOHSENI, M.; REBENTROST, P. Quantum algorithms for supervised and
unsupervised machine learning. arXiv:1307.0411 [quant-ph], 2013.
LLOYD, S.; MOHSENI, M.; REBENTROST, P. Quantum principal component analysis.
Nature Physics, v. 10, n. 9, p. 631‚Äì633, set. 2014. ISSN 1745-2481.
LONG, G.-L.; SUN, Y. Efficient scheme for initializing a quantum register with an arbitrary
superposed state. Physical Review A, v. 64, n. 1, p. 014303, 2001.
LOW, G. H.; KLIUCHNIKOV, V.; SCHAEFFER, L. Trading T-gates for dirty qubits in state
preparation and unitary synthesis. 2018.
LOW, G. H.; YODER, T. J.; CHUANG, I. L. Quantum inference on bayesian networks. Phys.
Rev. A, American Physical Society, v. 89, p. 062315, Jun 2014.
MALVETTI, E.; ITEN, R.; COLBECK, R. Quantum circuits for sparse isometries. Quantum,
v. 5, p. 412, 2021.
MANIN, Y. I. Computable and Non-Computable. Sovetskoe Radio, Moscow: [s.n.], 1980.
128 p.
MARIN-SANCHEZ, G.; GONZALEZ-CONDE, J.; SANZ, M. Quantum algorithms for
approximate function loading. arXiv, 2021.
MATTEO, O. D.; GHEORGHIU, V.; MOSCA, M. Fault-tolerant resource estimation of
quantum random-access memories. IEEE Transactions on Quantum Engineering, v. 1, p.
1‚Äì13, 2020.
MOLL, N.; BARKOUTSOS, P.; BISHOP, L. S.; CHOW, J. M.; CROSS, A.; EGGER,
D. J.; FILIPP, S.; FUHRER, A.; GAMBETTA, J. M.; GANZHORN, M.; KANDALA, A.;
MEZZACAPO, A.; M√ºLLER, P.; RIESS, W.; SALIS, G.; SMOLIN, J.; TAVERNELLI, I.;
TEMME, K. Quantum optimization using variational algorithms on near-term quantum
devices. Quantum Science and Technology, IOP Publishing, v. 3, n. 3, p. 030503, 2018.
MORA, C. E.; BRIEGEL, H. J. Algorithmic complexity and entanglement of quantum states.
Phys. Rev. Lett., American Physical Society, v. 95, p. 200503, 2005.
MORA, C. E.; BRIEGEL, H. J. Algorithmic complexity of quantum states. International
Journal of Quantum Information, v. 04, p. 715‚Äì737, 2006. ISSN 0219-7499.
MOTTONEN, M.; VARTIAINEN, J. J.; BERGHOLM, V.; SALOMAA, M. M. Transformation
of Quantum States Using Uniformly Controlled Rotations. Quantum Info. Comput., v. 5,
n. 6, p. 467‚Äì473, 2005.
MOZAFARI, F.; RIENER, H.; SOEKEN, M.; MICHELI, G. D. Efficient Boolean Methods for
Preparing Uniform Quantum States. IEEE Transactions on Quantum Engineering, v. 2, p.
1‚Äì12, 2021. ISSN 2689-1808.
MOZAFARI, F.; SOEKEN, M.; RIENER, H.; MICHELI, G. D. Automatic Uniform Quantum
State Preparation Using Decision Diagrams. In: 2020 IEEE 50th International Symposium
on Multiple-Valued Logic (ISMVL). Miyazaki, Japan: IEEE, 2020. p. 170‚Äì175. ISBN
9781728154060.

65
NAKAJI, K.; UNO, S.; SUZUKI, Y.; RAYMOND, R.; ONODERA, T.; TANAKA, T.;
TEZUKA, H.; MITSUDA, N.; YAMAMOTO, N. Approximate amplitude encoding in shallow
parameterized quantum circuits and its application to financial market indicator. arXiv, 2021.
NIELSEN, M. A.; CHUANG, I. L. Quantum computation and quantum information.
10th anniversary ed. ed. Cambridge ; New York: Cambridge University Press, 2010. ISBN
9781107002173.
OR√∫S, R. A practical introduction to tensor networks: Matrix product states and projected
entangled pair states. Annals of Physics, v. 349, p. 117‚Äì158, 2014. ISSN 0003-4916.
PAIGE, C.; WEI, M. History and generality of the cs decomposition. Linear Algebra and its
Applications, v. 208-209, p. 303‚Äì326, 1994. ISSN 0024-3795.
PALER, A.; OUMAROU, O.; BASMADJIAN, R. Parallelizing the queries in a bucket-brigade
quantum random access memory. Physical Review A, v. 102, n. 3, p. 032608, 2020. ISSN
2469-9926, 2469-9934.
PARK, D. K.; PETRUCCIONE, F.; RHEE, J.-K. K. Circuit-Based Quantum Random Access
Memory for Classical Data. Scientific Reports, v. 9, n. 1, p. 3949, 2019.
PARK, D. K.; SINAYSKIY, I.; FINGERHUTH, M.; PETRUCCIONE, F.; RHEE, J.-K. K.
Parallel quantum trajectories via forking for sampling without redundancy. New Journal of
Physics, IOP Publishing, v. 21, n. 8, p. 083024, 2019.
PEREZ-GARCIA, D.; VERSTRAETE, F.; WOLF, M. M.; CIRAC, J. I. Matrix Product State
Representations. arXiv, 2006.
PLESCH, M.; BRUKNER, C. Quantum-state preparation with universal gate decompositions.
Physical Review A, v. 83, n. 3, p. 032302, 2011.
PRESKILL, J. Quantum computing and the entanglement frontier. arXiv, 2012.
PRESKILL, J. Quantum Computing in the NISQ era and beyond. Quantum, v. 2, p. 79, 2018.
RAUSSENDORF, R.; BRIEGEL, H. J. A one-way quantum computer. Phys. Rev. Lett.,
American Physical Society, v. 86, p. 5188‚Äì5191, 2001.
REBENTROST, P.; MOHSENI, M.; LLOYD, S. Quantum Support Vector Machine for Big
Data Classification. Physical Review Letters, v. 113, n. 13, p. 130503, 2014.
REBENTROST, P.; STEFFENS, A.; MARVIAN, I.; LLOYD, S. Quantum singular-value
decomposition of nonsparse low-rank matrices. Physical Review A, American Physical Society
(APS), v. 97, n. 1, 2018.
RIVEST, R. L.; SHAMIR, A.; ADLEMAN, L. A method for obtaining digital signatures and
public-key cryptosystems. Commun. ACM, Association for Computing Machinery, New York,
NY, USA, v. 21, n. 2, p. 120‚Äì126, feb 1978. ISSN 0001-0782.
R√∏NNOW, T. F.; WANG, Z.; JOB, J.; BOIXO, S.; ISAKOV, S. V.; WECKER, D.; MARTINIS,
J. M.; LIDAR, D. A.; TROYER, M. Defining and detecting quantum speedup. Science,
v. 345, n. 6195, p. 420‚Äì424, 2014.

66
SANDERS, Y. R.; LOW, G. H.; SCHERER, A.; BERRY, D. W. Black-box quantum state
preparation without arithmetic. Phys. Rev. Lett., American Physical Society, v. 122, p.
020502, 2019.
SCHULD, M.; BOCHAROV, A.; SVORE, K. M.; WIEBE, N. Circuit-centric quantum
classifiers. Phys. Rev. A, American Physical Society, v. 101, p. 032308, 2020.
SCHULD, M.; FINGERHUTH, M.; PETRUCCIONE, F. Implementing a distance-based
classifier with a quantum interference circuit. EPL (Europhysics Letters), v. 119, n. 6, p.
60002, 2017.
SCHULD, M.; PETRUCCIONE, F. Supervised Learning with Quantum Computers. 1st ed.
2018. ed. Cham: Springer International Publishing : Imprint: Springer, 2018. (Quantum
Science and Technology).
SHENDE, V.; BULLOCK, S.; MARKOV, I. Synthesis of quantum-logic circuits. IEEE
Transactions on Computer-Aided Design of Integrated Circuits and Systems, v. 25, n. 6, p.
1000‚Äì1010, 2006.
SHENDE, V.; MARKOV, I.; BULLOCK, S. Smaller two-qubit circuits for quantum
communication and computation. In: Proceedings Design, Automation and Test in Europe
Conference and Exhibition. IEEE Xplore: IEEE, 2004b. v. 2, p. 980‚Äì985.
SHENDE, V. V.; BULLOCK, S. S.; MARKOV, I. L. Recognizing small-circuit structure in
two-qubit operators. Phys. Rev. A, American Physical Society, v. 70, p. 012310, 2004c.
SHENDE, V. V.; MARKOV, I. L.; BULLOCK, S. S. Minimal universal two-qubit controlled-
NOT-based circuits. Physical Review A, American Physical Society (APS), v. 69, n. 6,
2004a.
SHIMONY, A. Degree of Entanglement. Annals of the New York Academy of Sciences,
v. 755, n. 1, p. 675‚Äì679, 1995. ISSN 1749-6632.
SHOR, P. W. Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms
on a Quantum Computer. SIAM Review, v. 41, n. 2, p. 303‚Äì332, 1999.
SILVA, A.; OLIVEIRA, W. d.; LUDERMIR, T. A Weightless Neural Node Based on a
Probabilistic Quantum Memory. In: 2010 Eleventh Brazilian Symposium on Neural Networks.
Sao Paulo, Brazil: IEEE, 2010. p. 259‚Äì264. ISSN: 2375-0235.
SIMON, D. R. On the Power of Quantum Computation. SIAM Journal on Computing, v. 26,
n. 5, p. 1474‚Äì1483, 1997.
STAMATOPOULOS, N.; EGGER, D. J.; SUN, Y.; ZOUFAL, C.; ITEN, R.; SHEN, N.;
WOERNER, S. Option Pricing using Quantum Computers. Quantum, v. 4, p. 291, 2020.
STEANE, A. Multiple-particle interference and quantum error correction. Proceedings of the
Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences, v. 452,
p. 2551‚Äì2577, 1996. ISSN 1364-5021.
STEWART, G. W.; SUN, J.-g. Matrix perturbation theory. Boston: Academic Press, 1990.
(Computer science and scientific computing). ISBN 9780126702309.

67
STOUDENMIRE, E.; SCHWAB, D. J. Supervised learning with tensor networks. In: LEE,
D.; SUGIYAMA, M.; LUXBURG, U.; GUYON, I.; GARNETT, R. (Ed.). Advances in Neural
Information Processing Systems. Centre Convencions Internacional Barcelona, Barcelona
Spain: Curran Associates, Inc., 2016. v. 29, p. 9.
TANG, E. Quantum principal component analysis only achieves an exponential speedup
because of its state preparation assumptions. Phys. Rev. Lett., American Physical Society,
v. 127, p. 060503, 2021.
TENG, P. Accurate calculation of the geometric measure of entanglement for multipartite
quantum states. Quantum Information Processing, v. 16, n. 7, p. 181, 2017. ISSN 1570-0755.
TERHAL, B. M.; SMOLIN, J. A. Single quantum querying of a database. Physical Review A,
v. 58, n. 3, p. 1822‚Äì1826, 1998.
TRUGENBERGER, C. A. Probabilistic quantum memories. Physical Review Letters, v. 87,
n. 6, 2001.
TRUGENBERGER, C. A. Quantum Pattern Recognition. Quantum Information Processing,
v. 1, n. 6, p. 471‚Äì493, 2002.
TUCCI, R. R. A rudimentary quantum compiler(2cnd ed.). arXiv, 1999.
VANNIEUWENHOVEN, N.; VANDEBRIL, R.; MEERBERGEN, K. A new truncation strategy
for the higher-order singular value decomposition. SIAM Journal on Scientific Computing,
v. 34, n. 2, p. A1027‚ÄìA1052, 2012.
VASUDEVAN, V.; RAMAKRISHNA, M. A hierarchical singular value decomposition algorithm
for low rank matrices. arXiv, 2017.
VENTURA, D.; MARTINEZ, T. Initializing the Amplitude Distribution of a Quantum State.
Foundations of Physics Letters, v. 12, n. 6, p. 547‚Äì559, 1999.
VENTURA, D.; MARTINEZ, T. Quantum associative memory. Information Sciences, v. 124,
n. 1, p. 273‚Äì296, 2000.
VERAS, T. L. de; ARAUJO, I. S. de; PARK, D. K.; SILVA, A. J. da. Circuit-based quantum
random access memory for classical data with continuous amplitudes. IEEE Transactions on
Computers, IEEE Computer Society, Los Alamitos, CA, USA, v. 70, n. 12, p. 2125‚Äì2135, dec
2021. ISSN 1557-9956.
VERAS, T. M. L. de; SILVA, L. D. da; SILVA, A. J. da. Double sparse quantum state
preparation. Quantum Information Processing, v. 21, n. 6, p. 204, jun. 2022. ISSN 1573-1332.
WANG, S.; WANG, Z.; CUI, G.; SHI, S.; SHANG, R.; FAN, L.; LI, W.; WEI, Z.; GU, Y.
Fast black-box quantum state preparation based on linear combination of unitaries. Quantum
Information Processing, v. 20, n. 8, p. 270, 2021. ISSN 1573-1332.
WEI, T.-C.; GOLDBART, P. M. Geometric measure of entanglement and applications to
bipartite and multipartite quantum states. Physical Review A, v. 68, n. 4, p. 042307, 2003.
ISSN 1050-2947.
WIEBE, N.; BRAUN, D.; LLOYD, S. Quantum algorithm for data fitting. Phys. Rev. Lett.,
American Physical Society, v. 109, p. 050505, Aug 2012.

68
WIEBE, N.; GRANDADE, C. Can small quantum systems learn. Quantum Info. Comput.,
Rinton Press, Incorporated, Paramus, NJ, v. 17, n. 7‚Äì8, p. 568‚Äì594, jun 2017. ISSN
1533-7146.
WIEBE, N.; KAPOOR, A.; SVORE, K. M. Quantum deep learning. arXiv, 2014.
WIEBE, N.; KAPOOR, A.; SVORE, K. M. Quantum perceptron models. In: Proceedings of
the 30th International Conference on Neural Information Processing Systems. Red Hook, NY,
USA: Curran Associates Inc., 2016. (NIPS‚Äô16), p. 4006‚Äì4014. ISBN 9781510838819.
WILLIAMS, C. P. Quantum gates. In:
. Explorations in Quantum Computing. London:
Springer London, 2011. p. 51‚Äì122. ISBN 978-1-84628-887-6.
WILLSCH, D.; NOCON, M.; JIN, F.; RAEDT, H. D.; MICHIELSEN, K. Gate-error analysis
in simulations of quantum computers with transmon qubits. Phys. Rev. A, American Physical
Society, v. 96, p. 062302, Dec 2017.
WOERNER, S.; EGGER, D. J. Quantum Risk Analysis. npj Quantum Information, v. 5, n. 1,
p. 15, 2019.
WOSSNIG, L.; ZHAO, Z.; PRAKASH, A. Quantum linear system algorithm for dense
matrices. Phys. Rev. Lett., American Physical Society, v. 120, p. 050502, 2018.
XIN, T.; WEI, S.; CUI, J.; XIAO, J.; ARRAZOLA, I. n.; LAMATA, L.; KONG, X.; LU, D.;
SOLANO, E.; LONG, G. Quantum algorithm for solving linear differential equations: Theory
and experiment. Phys. Rev. A, American Physical Society, v. 101, p. 032307, Mar 2020.
ZHANG, X.-M.; YUNG, M.-H.; YUAN, X. Low-depth quantum state preparation. Phys. Rev.
Research, American Physical Society, v. 3, p. 043200, 2021.
ZHAO, Z.; FITZSIMONS, J. K.; REBENTROST, P.; DUNJKO, V.; FITZSIMONS, J. F.
Smooth input preparation for quantum and quantum-inspired machine learning. Quantum
Machine Intelligence, v. 3, n. 1, p. 14, 2021. ISSN 2524-4914.
ZOUFAL, C.; LUCCHI, A.; WOERNER, S. Quantum generative adversarial networks for
learning and loading random distributions. npj Quantum Information, Nature Publishing
Group, v. 5, n. 1, p. 1‚Äì9, 2019.

1
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  
| https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports
A divide‚Äëand‚Äëconquer algorithm 
for¬†quantum state preparation
Israel¬†F.¬†Araujo1, Daniel¬†K.¬†Park2, Francesco¬†Petruccione3,4,5*¬†& Adenilton¬†J.¬†da¬†Silva1‚Ää
Advantages in several fields of research and industry are expected with the rise of quantum computers. 
However, the computational cost to load classical data in quantum computers can impose restrictions 
on possible quantum speedups. Known algorithms to create arbitrary quantum states require quantum 
circuits with depth O(N) to load an N-dimensional vector. Here, we show that it is possible to load an 
N-dimensional vector with exponential time advantage using a quantum circuit with polylogarithmic 
depth and entangled information in ancillary qubits. Results show that we can efficiently load data in 
quantum devices using a divide-and-conquer strategy to exchange computational time for space. We 
demonstrate a proof of concept on a real quantum device and present two applications for quantum 
machine learning. We expect that this new loading strategy allows the quantum speedup of tasks that 
require to load a significant volume of information to quantum devices.
The development of quantum computers can dramatically reduce the time to solve certain computational ¬≠tasks1. 
However, in practical applications, the cost to load the classical information in a quantum device can dominate 
the asymptotic computational cost of the quantum ¬≠algorithm2,3. Loading information into a device is a common 
task in computer science applications. For instance, deep neural ¬≠networks4 learning algorithms run in specialized 
¬≠hardware5, and the computational cost to transfer the information needs to be considered in the total computa-
tional cost as data loading can dominate the training time on large-scale ¬≠systems6. In classical devices, we can use 
the loaded information several times while we do not erase it. The situation is not the same in quantum devices 
because of the no-cloning ¬≠theorem7, noisy quantum ¬≠operations8, and the decoherence of quantum ¬≠information9. 
The no-cloning theorem shows that it is not possible to perform a copy of an arbitrary quantum state. When 
a quantum operation is applied, its input is transformed or is destroyed (collapsed). Even if we represent the 
information in a basis state that we can copy, the noisy operations and decoherence will corrupt the stored state, 
and it will be necessary to reload the information from the classical to the quantum device.
Loading an input vector x = (x0, . . . , xN‚àí1) to the amplitudes of a quantum system corresponds to create the 
state with log2(N) quantum bits described in Eq.¬†(1).
Circuits to load an N-dimensional classical unit vector in quantum devices use n = log2(N) qubits and have an 
exponential depth in relation to the number of qubits (or polynomial in the data size)10‚Äì13.
Here we propose a new format of data encoding. Namely, we load an N-dimensional vector in probability 
amplitudes of computational basis state with entangled information in ancillary qubits as
where |œàj are unit vectors. We propose an algorithm to load an N-dimensional vector in a quantum state as 
shown in Eq.¬†(2) using a circuit with O(log2
2(N)) depth and O(N) qubits. The devised method is based on quan-
tum ¬≠forking13,14 and uses a divide-and-conquer ¬≠strategy15. The circuit depth is decreased at the cost of increasing 
the circuit width and creating entanglement between data register qubits and an ancillary system. Thus when 
the data register is considered alone (i.e. by tracing out the ancilla qubits), the resulting state is mixed and not 
equal to the pure state shown in Eq.¬†(1). However, it is important to note that in Eq.¬†(2) the classical data is still 
encoded as probability amplitudes of an orthonormal basis set. Useful applications can be constructed based on 
this, and we provide two example applications in machine learning and statistical analysis.
The divide-and-conquer paradigm is used in efficient algorithms for ¬≠sorting16, computing the discrete Fourier 
¬≠transform17, and ¬≠others15. The main idea is to divide a problem into subproblems of the same class and combine the 
(1)
x0|0 + ¬∑ ¬∑ ¬∑ + xN‚àí1|N ‚àí1
(2)
x0|0|œà0 + ¬∑ ¬∑ ¬∑ + xN‚àí1|N ‚àí1|œàN‚àí1,
OPEN
1Centro de Inform√°tica, Universidade Federal de Pernambuco, Recife, Pernambuco, Brazil. 2Sungkyunkwan 
University Advanced Institute of Nanotechnology, Suwon¬†16419, South Korea. 3School of Electrical Engineering, 
KAIST, Daejeon¬†34141, Republic of Korea. 4Quantum Research Group, School of Chemistry and Physics, University 
of KwaZulu-Natal, Durban, KwaZulu‚ÄëNatal¬†4001, South Africa. 5National Institute for Theoretical Physics (NITheP), 
Durban, KwaZulu‚ÄëNatal¬†4001, South Africa. *email: petruccione@ukzn.ac.za
69
AP√äNDICE A ‚Äì A DIVIDE-AND-CONQUER ALGORITHM FOR QUANTUM
STATE PREPARATION

2
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
solutions of the subproblems to obtain the solution of the original problem. The circuit based divide-and-conquer 
state preparation algorithm has computational cost O(N) and the total complexity time is Oc(N) + Oq(log2
2(N))‚Ää, 
where Oc(N) is classical pre-computation time to create the quantum circuit that will load the information in the 
quantum device and Oq(log2
2(N)) is the depth of the quantum circuit. With the supposition that we will load the input 
vector m ‚â´N times, the amortized computational time to load the real vector is Oq(log2
2(N))‚Ää. The modified ver-
sion of the loading problem allows an exponential advantage in the depth of the quantum circuit using O(N) qubits.
The remainder of this paper is organized into 3 sections. ‚ÄúTransformation of quantum states‚Äù section reviews 
one of the standard methods for loading information in a quantum device using controlled ¬≠rotations10, which we 
set out to modify to reduce its quantum circuit depth exponentially. ‚ÄúDivide-and-conquer loading data‚Äù section 
shows the main result, a quantum circuit with depth O(log2
2(N))‚Ää, and O(N) qubits to load an N-dimensional 
vector in a quantum state with entangled information in the ancillary qubits. ‚ÄúDiscussion‚Äù section presents the 
conclusion and possible future works.
Transformation of¬†quantum states
In this section, we review a strategy for loading a real vector into the amplitudes of a quantum state using a sequence 
of controlled one-qubit ¬≠rotations10. Given an N-dimensional vector x, where n = log2(N) is an integer, we can cre-
ate a circuit to load this vector in a quantum computer using Algorithm¬†1. The task of amplitude encoding (Algo-
rithm¬†1) has two parts: (1) Function gen_angles (Line¬†1) finds angles to perform rotations that lead |0n ‚â°|0‚äón 
to the state in Eq.¬†(1), and (2) Function gen_circuit (Line¬†18) generates a quantum circuit from these rotations.
70

3
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Function gen_angles¬†(Algorithm¬†1, Line¬†1) divides the 2n-dimensional input vector into 2n‚àí1 2-dimen-
sional subvectors and creates a 2n‚àí1-dimensional vector new_x with the norms of the subvectors. While the size 
of new_x is greater than 1, the new_x vector is recursively passed as the input of function gen_angles¬†. This 
procedure is described in lines¬†3 to 6 of Algorithm¬†1. An example of the inputs in the recursive calls with the 
initial input
is presented in the binary tree named state-tree in¬†Fig.¬†1b.
After the last recursive call of the function gen_angles¬†, the algorithm starts to compute the vector angles. 
For each k between 0 and the size of vector new_x‚Ää, we append an angle Œ∏ such that sin(Œ∏/2) = x[2k+1]
new_x[k] and 
cos(Œ∏/2) =
x[2k]
new_x[k] to the vector angles. Lines¬†7 to 16 generate the vector angles in the recursive calls. For the 
input in Fig.¬†1b and using two decimal points the algorithm outputs angles = (1.98,¬†1.91,¬†1.43,¬†1.98,¬†1.05,¬†2.09,¬†
1.23). The angles vector is used as a complete binary tree named angles-tree. For instance, with Œ±k = angles[k]‚Ää, 
the angles-tree created by gen_angles¬†with an eight-dimensional input vector is described in Fig.¬†1a. Each call 
of gen_angles¬†will perform log2(N) recursive calls and the cost of each call for k = 1, . . . , log2(N) is N/2k‚àí1‚Ää. 
The costs of the recursive calls to generate the angles-vector is 1 + 2 + 22 + ¬∑ ¬∑ ¬∑ + 2log2 N = O(N).
Function gen_circuit¬†(Algorithm¬†1, Line¬†18) receives the N ‚àí1 dimensional vector angles, generated by 
the function gen_angles¬†with input x, and outputs a quantum circuit to load the vector x in the amplitudes 
of a quantum state. The state in level j of the tree-state in Fig.¬†1b can be constructed from the state in the level 
j ‚àí1 of the states-tree and controlled rotations from the level j ‚àí1 in angles-tree. The root of the angles-tree 
defines the first rotation and the algorithm follows a top-down approach where the rotation of angle angle[k] is 
controlled by the qubits in range [0,¬†level(k)) and is applied if the qubits q[0], . . . , q[level(k) ‚àí1] are in the state 
|k ‚àí(2level(k) ‚àí1)‚Ää. With Œ±k = angle[k]‚Ää, the circuit to load an eight-dimensional input vector is described in 
Fig.¬†2. The computational cost to compute the angles and to generate the circuit is O(N). The quantum circuit 
uses O(N) multi-controlled gates that are applied sequentially and the circuit depth is O(N). We have a O(N) cost 
in the classical host machine and a O(N) cost in the quantum device and spatial cost O(log2(N))‚Ää. An amortized 
computational cost is O(N) if we need to load the vector several times.
Divide‚Äëand‚Äëconquer loading data
The construction of the quantum state in the previous section starts in the root of state-tree |0n and build the 
states in each level of the state-tree in a top-down strategy until to build the state described by the last level of 
the state-tree. In this Section, we propose a divide-and-conquer load strategy, and the desired quantum state is 
built following a bottom-up strategy. First, we divide the input into bidimensional subvectors and load qubits 
corresponding to the normalized bidimensional subvectors. In the next steps, we generate the subvectors of the 
previous levels.
For instance, to load the state in the leafs of the state-tree in Fig.¬†1b, we load four one-qubit states
representing the leafs of the state-tree. To load the two two-qubit states in the previous level, the single-qubit 
states are weighted with the value of their fathers, obtaining the state |œàl representing the state in the half left 
part of the state-tree in Eq.¬†(3) and the state |œàr representing the state in the right part of the state-tree in Eq.¬†(4).
Combining states |œàl and |œàr weighted with the values of the state in the previous layer generates the desired 
quantum state described in Eq.¬†(5).
To load the classical data using this bottom-up approach we need to combine two m-qubits states |œà, |œÜ 
and one one-qubit state a|0 + b|1 as a|0|œà + b|1|œÜ with a circuit that does not depend on the input states. 
Using the circuit in Fig.¬†3 with m ‚àí1 controlled-swap (CSWAP) operations, we generate the desired output in 
(
‚àö
0.03,
‚àö
0.07,
‚àö
0.15,
‚àö
0.05,
‚àö
0.1,
‚àö
0.3,
‚àö
0.2,
‚àö
0.1)
‚àö
0.03
‚àö
0.1
|0 +
‚àö
0.07
‚àö
0.1
|1,
‚àö
0.15
‚àö
0.2
|0 +
‚àö
0.05
‚àö
0.2
|1,
‚àö
0.1
‚àö
0.4
|0 +
‚àö
0.3
‚àö
0.4
|1 and
‚àö
0.2
‚àö
0.3
|0 +
‚àö
0.1
‚àö
0.3
|1
(3)
|œàl =
‚àö
0.1
‚àö
0.3
|0
‚àö
0.03
‚àö
0.1
|0 +
‚àö
0.07
‚àö
0.1
|1

+
‚àö
0.2
‚àö
0.3
|1
‚àö
0.15
‚àö
0.2
|0 +
‚àö
0.05
‚àö
0.2
|1

=
‚àö
0.03
‚àö
0.3
|00 +
‚àö
0.07
‚àö
0.3
|01 +
‚àö
0.15
‚àö
0.3
|10 +
‚àö
0.05
‚àö
0.3
|11
(4)
|œàr =
‚àö
0.4
‚àö
0.7
|0
‚àö
0.1
‚àö
0.4
|0 +
‚àö
0.3
‚àö
0.4
|1

+
‚àö
0.3
‚àö
0.7
|1
‚àö
0.2
‚àö
0.3
|0 +
‚àö
0.1
‚àö
0.3
|1

=
‚àö
0.1
‚àö
0.7
|00 +
‚àö
0.3
‚àö
0.7
|01 +
‚àö
0.2
‚àö
0.7
|10 +
‚àö
0.1
‚àö
0.7
|11
(5)
‚àö
0.3|œàl +
‚àö
0.7|œàr =
‚àö
0.03|000 +
‚àö
0.07|001 +
‚àö
0.15|010 +
‚àö
0.05|011
+
‚àö
0.1|100 +
‚àö
0.3|101 +
‚àö
0.2|110 +
‚àö
0.1|111
71

4
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
the first m qubits, but with unit entangled information in the m ‚àí1 ancillary qubits. Namely, for the example 
with Fig.¬†3, the conventional amplitude encoding in the form of Eq.¬†(1) would aim to prepare an m-qubit state 
a|0|œà + b|1|œÜ while our method prepares a|0|œà|œÜ + b|1|œÜ|œà.
Loading complex data.‚ÄÉ
The divide-and-conquer strategy can be generalized to load a complex vector 
(|x0|eiœâ0, |x1|eiœâ1, . . . , |xN‚àí1|eiœâN‚àí1) into the probability amplitudes of a quantum state as
To explain the process, we introduce two parameters used in Ref.18
where v = 1, 2, . . . , n is the level of the tree in reverse order (i.e. 1 for the leaf nodes and n for the root node) and 
j = 1, 2, . . . , 2n‚àív is the qubit index in the layer v. Next, one needs N/2 one-qubit states corresponding to the 
leaf nodes of the state-tree (see Fig.¬†1b for example) to be prepared as
To load the states in the previous levels (represented by v on the expression below), the states of the current 
level (‚Ääv ‚àí1‚Ää, since v is in reverse order) are weighted with the values of their parents, obtaining the state
After recursively updating the state |œàj,v for v = 2, . . . , n and j = 1, 2, . . . .2n‚àív‚Ää, the desired quantum state 
is generated as
Combining two states at children nodes in the state-tree as shown in Eq.¬†(8) is done with controlled-swap 
operations as explained in the previous section, and we will need N qubits with entangled auxiliary qubits to 
generate the state in Eq.¬†(6). Thus the only modification in the quantum circuit is the introduction of the Rz(j,v) 
rotations to set the phases, following the Ry rotations. The pseudocode for generating the angles for the Rz rota-
tions is given in Algorithm¬†2. 
(6)
|x0|eiœâ0|0|œà0 + ¬∑ ¬∑ ¬∑ + |xN‚àí1|eiœâN‚àí1|N ‚àí1|œàN‚àí1.
j,v =
2v‚àí1

l=1
(œâ(2j‚àí1)2v‚àí1+l ‚àíœâ(2j‚àí2)2v‚àí1+l)/2v‚àí1 and Œ≤j,v =




2v‚àí1

l=1
|a(2j‚àí1)2v‚àí1+l|2/




2v

l=1
|a(j‚àí1)2v+l|2,
(7)
|œàj,1 = e‚àíi
j,1
2

1 ‚àí|Œ≤j,1|2|0 + ei
j,1
2 Œ≤j,1|1.
(8)
|œàj,v = e‚àíi
j,v
2

1 ‚àí|Œ≤j,v|2|0|œà2j‚àí1,v‚àí1 + ei
j,v
2 Œ≤j,v|1|œà2j,v‚àí1.
(9)
|œà1,n = |x0|eiœâ0|0 + |x1|eiœâ1|1 + ¬∑ ¬∑ ¬∑ + |xN‚àí1|eiœâN‚àí1|N ‚àí1.
Figure¬†1.‚ÄÇ ‚ÄâData representation of information in function generate angles.
Figure¬†2.‚ÄÇ ‚ÄâCircuit to load an 8 dimensional real vector in a quantum device.
72

5
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Algorithm¬†3 presents the complete pseudocode for the divide-and-conquer state preparation algorithm. 
The for loop in line¬†2 initializes the qubit q[k] with the value Ry(Œ±k)‚Ää. After this step, the qubits with index 
k > ‚åä(N ‚àí1)/2‚åã (in the leaf of the angle tree) are normalized versions of the states in the leafs of the state-tree. 
The next subroutine with Rz rotations (Line 4 to Line 5) is used to encode phase information. Line 6 calculates 
the index of the first angle that has a right children in the angle-tree data structure. The while loop starting at 
line 7 combines the states generated in the subtree rooted in the angle Œ±actual‚Ää. To combine the states, we first 
apply a cswap(q[actual], q[left_child], q[right_child]), and then we update the values of left and right child with 
the value of their left child and apply another cswap(q[actual], q[left_child], q[right_child]) while the left_child 
and right_child have valid values. With the input described by the angle-tree in Fig.¬†1a, Algorithm¬†3 generates 
the circuit described in Fig.¬†4.
Figure¬†3.‚ÄÇ ‚ÄâCombining states with controlled-swap operations.
73

6
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
The process to load each state in the same layer of the state tree can be performed in parallel, because the 
control swap gates use different qubits. The controls are qubits in one layer of the angle-tree and targets are 
qubits in their subtrees. Layer with height k contributes to the depth of the circuit with the tree height minus 
height of the layer. The circuit will have a depth of O(1 + 2 + ¬∑ ¬∑ ¬∑ + log2(N) ‚àí1) with an overall depth in order 
O(log2
2(N))‚Ää. This result is stated in Theorem¬†1.
Theorem¬†1‚ÄÇ Algorithm¬†3 generates a quantum circuit with depth O(log2
2(N)).
Orthonormal ancillary.‚ÄÉ
The ancillary states |œà0, . . . , |œàN‚àí1 in Eq.¬†(2) are not necessarily orthogonal to 
each other, but we can modify the divide-and-conquer state preparation adding label qubits to ensure orthonor-
mality of the ancillary states with the addition of label quantum register with log2(N) qubits. The label register 
is prepared in |0‚äólog2(N)‚Ää, and log2(N) controlled-NOT (CNOT) gates are applied to the label qubits, each con-
trolled by a data qubit. With this modification, the final state becomes
where {| Àúœàk}N‚àí1
k=0 = {|œàk|k}N‚àí1
k=0  is a set of orthonormal states.
Experiments.‚ÄÉ
To evaluate the proposed method we perform two sets of experiments. In the first set of 
experiments, we use a quantum computing simulator and a NISQ computer to show as a proof of concept that 
the proposed method can be applied in near future. In the second set of experiments, we compare the depth of 
the circuits generated by the proposed method and other state preparation ¬≠algorithms10,11 with a random input.
Proof of concept with a NISQ device.‚ÄÉ In this experiment we load a four-dimensional data into a two qubit state 
|œà =
‚àö
0.6|00 +
‚àö
0.2|01 +
‚àö
0.1|10 +
‚àö
0.1|11 in a NISQ device as a proof of concept. For this experimen-
tal validation, we chose dimension of data to be small to be compatible with currently available quantum devices, 
although the time advantage of the proposed method will manifest when a large number of qubits are required 
for loading high-dimensional data. We use qubits 1, 2 and 3 of the ibmq_rome device. The CNOT error rates 
were 8.832e-3 (qubits 1 and 2) and 8.911e-3 (qubits 2 and 3). The single-qubit error was in the order of 1e-4.
Figure¬†5a presents the output of the experiment with 1024 executions using a quantum device simulator and 
the Rome quantum device. The Rome NISQ device has an output very close to the expected result. The circuit 
used to obtain this result is described in Fig.¬†5b, where c is a classical register. We remove the last CNOT of the 
controlled operation because the qubit 2 will be discarded. The resulting circuit has 10 CNOT operators because 
a quantum swap was necessary to run this circuit in the real quantum device with a limited qubit connectivity. 
The circuit used in the quantum device is described in Fig.¬†7.
(10)
x0|0|œà0|0 + ¬∑ ¬∑ ¬∑ + xN‚àí1|N ‚àí1|œàN‚àí1|N ‚àí1 =
N‚àí1

k=0
xk|k| Àúœàk,
Figure¬†4.‚ÄÇ ‚ÄâRotated angle-tree and a circuit generated by the divide-and-conquer strategy described in 
Algorithm¬†3. The quantum bit q[k] in the circuit is aligned with the angle Œ±[k] in the angle-tree, this 
organization allows to draw the quantum gates in each layer in parallel. In this example, the desired state is 
stored in qubits q[0], q[1] and q[3] to generate the quantum state with entangles ancilla as in Eq.¬†(2).
74

7
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Circuit depth.‚ÄÉ The main difference between the divide-and-conquer state preparation and previous approaches 
is an exchange between circuit depth by circuit width. Table¬†1 presents the depth of the circuits generated using 
the proposed strategy, implementation of a version ¬≠of11 available ¬≠at19 and a non optimized version of the algo-
rithm described ¬≠in10. The proposed strategy ¬≠and10 implementation are publicly available. The implementation of 
the proposed method shows its theoretical asymptotic time advantage to load a vector when the dimension is 
larger than 32. The proposed method has two main disadvantages: the linear number of qubits in relation to the 
logarithmic number in other methods, and the information entangled in the ancillary qubits.
The higher depth of circuits using the divide-and-conquer strategy with small vectors occurs because of the 
use of three-qubits gates to combine the vectors. In other works, it is only necessary to use O(n) qubits to load 
a 2n-dimensional vector while requiring sequential applications of O(2n) n-controlled gates. To improve the 
performance of the divide-and-conquer loading strategy and to reduce the number of qubits one can combine 
¬≠algorithm11 with the divide-and-conquer strategy. Instead of divide the vector in parts with size 2, we can divide 
the vector in parts with size k (equal to a power of 2), load the normalized k-dimensional vectors using a sequen-
tial algorithm and combine the small vectors with the divide-and-conquer approach.
Example applications.‚ÄÉ
Hierarchical quantum classifier.‚ÄÉ This section compares the divide-and-conquer 
algorithm with two other approaches in which input data encoding in a quantum state can be achieved to initial-
ize a quantum circuit, namely qubit encoding and amplitude encoding. In the former, data is encoded in the am-
plitudes of individual qubits in a fully separable state, performed using single-qubit ¬≠rotations20. In the later, data 
is encoded in the amplitudes of an entangled ¬≠state11,18, similarly to the divide-and-conquer. We use the accuracy 
of a quantum variational classifier as a metric to evaluate the state preparations. The divide-and-conquer algo-
rithm is expected to produce results similar to the amplitude encoding. The results of the classifier using qubit 
encoding are also presented for completeness, albeit our main objective is to compare the divide-and-conquer 
and amplitude encoding schemes.
The classifier is based on a tree-like circuit known as tree tensor network (TTN)20. This choice is based on 
the fact that tensor networks can represent both neural networks and quantum circuits, acting as a link between 
these ¬≠fields21,22. Initially, it applies a set of two-qubit unitaries to each pair of qubits from the initial state, dis-
carding one output from each unitary, leaving half the number of qubits left for the next layer. The process is 
repeated until only one qubit remains. Multiple measurements are carried on this last qubit to approximate the 
expectation value.
Following Grant et¬†al.20, we built the circuits using single-qubit rotations around the y-axis of the Bloch 
sphere, denoted by Ry(Œ∏)‚Ää, and CNOT gates, composing two-qubit unitary blocks CNOT ¬∑ (Ry(Œ∏0) ‚äóRy(Œ∏1))‚Ää. The 
single-qubit rotation angle Œ∏ is subject to training by some optimization procedure. Examples of the resulting 
circuits are represented in Fig.¬†6a‚Äìc.
We follow the general classical-quantum hybrid approach in which the optimization procedure is processed 
on a classical computer to determine a set of parameters, i.e. rotation angles for the Ry(Œ∏) operation, for the para-
metrized quantum circuit. The quantum device prepares a quantum state as prescribed by the circuit pipeline and 
performs measurements. The measurement outcomes are processed by a classical device to generate a forecast, 
using it to update the model parameters via a learning algorithm. This whole process is repeated towards the goal.
Four datasets were used in this work: Iris, Haberman‚Äôs Survival, Banknote ¬≠Authentication23, and Pima Indians 
¬≠Diabetes24. Three binary datasets were extracted from the original Iris dataset (paired combinations of the original 
three classes). Mean test accuracy and one standard deviation are computed on ten random initializations for 
each dataset and encoding. The simulation results are presented in Table¬†2, where the test accuracy of the qubit 
and amplitude encodings are compared against the results obtained using the divide-and-conquer encoding.
The results show similar classification accuracy for all encodings, favoring qubit encoding due to the greater 
number of circuit parameters for the optimization. The main advantage of divide-and-conquer encoding over 
qubit encoding is the representation of encoded data in a quantum state of a reduced number of qubits, log2(N)‚Ää, 
compared to the initial state N ‚àí1‚Ää. This also results in a lower depth classifier. Moreover, when the data is given 
by qubit encoding, TTN circuits can be evaluated efficiently using classical ¬≠techniques20. This is not true when 
the input data is amplitude encoded. The advantage over amplitude encoding is a lower depth encoding circuit 
for N ‚â•64 (Table¬†1).
To verify that the above comparison of the models is appropriate, a nonparametric statistical test was 
employed. We used the Wilcoxon paired signed-rank ¬≠test25 with Œ± = 0.05 to check whether there exist significant 
differences between the classification performances of compared encoders over the chosen datasets. As expected, 
we verified that amplitude encoding and divide-and-conquer encoding are statistically equivalent for all datasets.
Swap test.‚ÄÉ Some metric between two data set encoded as 
i xi|i = 
i |Àúxi and 
j yj|j = 
j |Àúyj can be 
calculated with the state prepared by the divide-and-conquer state preparation and the swap test. The required 
state is
where 
i |Àúxi|œài and 
j |Àúyi|œÜj are prepared by the encoding scheme explained in Sec. 3.2 so as to make the 
ancillary states orthonormal.
After applying the swap test circuit to the above state, i.e. the Hadamard on the first (ancilla) qubit, the swap 
operation between the test register and the data register controlled by the ancilla qubit, and the Hamadard on 
the first qubit, one obtains
(11)
|0

ij
|Àúxi|Àúyj|œài|œÜj,
75

8
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Now, when the œÉz measurement is performed on the ancilla qubit, the probability to measure z = ¬±1‚Ää, i.e. 
z = +1 if the ancilla qubit is |0 and z = ‚àí1 if the ancilla qubit is |1‚Ää, is
Therefore, measuring the expectation value of œÉz on the ancilla qubit yields
Several measures in statistics can be derived from the above result. First, by setting |xi|2 to be the possible 
values of a discrete random variable X :  ‚ÜíR with the probability Pr(X = |xi|2) = |yi|2‚Ää, the above equation 
becomes an expectation value of the random variable X. The above equation can be also viewed as the second 
moment of a discrete random variable X, i.e. E(X2)‚Ää, with the probability Pr(X = xi) = |yi|2‚Ää. This can be used 
to calculate the variance of X given E(X)2‚Ää. Alternatively, the above equation can be viewed as E(XY) of two uni-
formly-distributed discrete random variables X and Y that satisfy Pr(X = |xi|2) = Pr(Y = |yi|2) = 1/N‚Ää. This can 
be used with E(X) = N
i |xi|2/N = E(Y) N
i |yi|2/N = 1/N to calculate the covariance, E(XY) ‚àíE(X)E(Y).
The idea above can be extended for calculating the covariance of two discrete random variables X and 
Y with any known probability distribution. Let possible outcomes of X and Y be (|x0|2, . . . , |xN‚àí1|2) and 
(12)
1
2
Ô£´
Ô£≠|0

ij

|Àúxi|Àúyj + |Àúyj|Àúxi

|œài|œÜj + |1

ij

|Àúxi|Àúyj ‚àí|Àúyj|Àúxi

|œài|œÜj
Ô£∂
Ô£∏.
(13)
Pr(z = ¬±1) = 1
4

ijkl
2

Àúxk|ÀúxiÀúyl|Àúyj ¬± Àúyl|ÀúxiÀúxk|Àúyj

œàk|œàiœÜl|œÜj
= 1
2
Ô£´
Ô£≠
ij
Àúxi|ÀúxiÀúyj|Àúyj ¬± |Àúyj|Àúxi|2
Ô£∂
Ô£∏
=
1 ¬± 
ij |Àúyj|Àúxi|2
2
.
(14)

ij
|Àúyj|Àúxi|2 =

i
|xiyi|2.
Figure¬†5.‚ÄÇ ‚ÄâProof of concept experiment with a IBM quantum device (ibmq_rome) on the cloud platform.
Table‚ÄØ1.‚ÄÇ ‚ÄâA comparison between Refs.10,11 and divide-and-conquer strategy to load a n-dimensional real vector 
into a quantum computer.
n
dc depth
dc width
11 depth
11 width
10 depth
10 width
4
12
4
3
3
5
3
8
31
8
17
4
53
4
16
58
16
47
5
277
5
32
93
32
105
6
1237
6
64
136
64
239
7
5205
7
128
187
128
493
8
21333
8
256
246
256
982
9
9
512
313
512
2025
10
10
1024
388
1024
4009
11
11
76

9
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
(|y0|2, . . . , |yN‚àí1|2)‚Ää, respectively, and the probability distribution be (px
0, . . . , px
N‚àí1) and (py
0, . . . , py
N‚àí1)‚Ää, respec-
tively. Then the divide-and-conquer algorithm can be used to prepare a state
where |Àúpx
i  =

px
i |i‚Ää, |Àúpy
k =

py
k|k‚Ää, |Àúxj = xj|j‚Ää, |Àúyl = yl|l‚Ää, and |œàijkl is the orthonormal ancillary state as 
before. Now, the swap test circuit is applied with a small modification such that 3n controlled-swap gates are 
applied to transform |Àúpx
i |Àúxj|Àúpy
k|Àúyl to |Àúxj|Àúpy
k|Àúyl|Àúpx
i  when the ancilla qubit for the swap test is |1‚Ää. Measuring 
the expectation value of the œÉz observable on the ancilla qubit yields
E(X) and E(Y) can be calculated from the swap test algorithm presented in the beginning of this section, which 
provided Eq.¬†(14), by choosing the input vectors appropriately.
The total time complexity for the aforementioned quantum algorithms is still Oq(log2
2(N))‚Ää, since the swap 
test only requires additional O(log2(N)) controlled-swap gates. The quantum speedup can be manifested when 
constructing a covariance matrix for two multivariate random variables X and Y‚Ää, each containing m discrete 
random variables of size N. Since there are m2 entries in the matrix, the classical time cost is Oc(Nm2)‚Ää, while the 
quantum approach requires Oc(N) + Oq(log2
2(N)m2).
Discussion
One of the major open problems for practical applications of quantum computing is to develop an efficient means 
to encode classical data in a quantum ¬≠state3. Most quantum algorithms do not present advantages in loading 
¬≠data2. The method proposed in this work fills this gap by proposing a new quantum state preparation paradigm, 
which can complement or enhance the known methods, such as qubit encoding and amplitude encoding. Our 
approach was based on the M√∂tt√∂nen et¬†al. ¬≠algorithm10 and a divide-and-conquer approach using controlled 
swap gates and ancilla qubits. With this modification, we obtain an exponential quantum speedup in time to load 
a N-dimensional real vector in the amplitude of a quantum state with a quantum circuit of depth O(log2
2(N)) 
(15)
|0

ijkl
|Àúpx
i |Àúxj|Àúpy
k|Àúyl|œàijkl,
(16)

ijkl
Àúpx
i |ÀúxjÀúxj|Àúpy
kÀúpy
k|ÀúylÀúyl|Àúpx
i  =

i
px
i py
i |xi|2|yi|2 = E(XY).
Figure¬†6.‚ÄÇ ‚ÄâTTN classifier with (a) divide-and conquer encoding, (c) amplitude encoding and (b) qubit 
encoding.
77

10
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
and space O(N). The exponential speedup to load data in quantum devices has a potential impact on speeding 
up the solution of problems in quantum machine learning and other quantum algorithms that need to load data 
from classical devices.
The speedup is achieved at the cost of using ancilla qubits that are entangled to the data register qubits. How-
ever, we showed that some interesting problems such as quantum supervised machine learning and statistical 
analysis can be performed with the input quantum state given by our method. The tradeoff between time and 
space complexities that our method provides is favorable when increasing the circuit width is easier than increas-
ing the circuit depth, which is a likely scenario to occur during the development of near-term quantum devices.
We demonstrated the proof-of-principle using the IBM quantum cloud platform to verify the validity and 
the feasibility of our method. Furthermore, the numerical experiments showed that the new encoding method 
offers advantages, reducing complexity and computational resources when applied in conjunction with existing 
algorithms. Our perspective is that these advantages will extend to other cases.
This work leaves some open questions. What are other problems that can be solved with a divide-and-conquer 
quantum strategy? What are the implications to efficiently load a quantum vector with entangled information 
in the ancillary qubits for machine learning? And how to combine sequential with parallel strategies to create a 
robust algorithm with respect to input size? Also, finding an efficient means to uncompute the ancillary informa-
tion remains as an interesting future work that will broaden the applicability of our method.
Methods
We performed the proof of concept experiment with a publicly available IBM quantum device consisting of 
five superconducting qubits, named as ibmq_rome. The quantum circuit used in this experiment is depicted in 
Fig.¬†5b. The circuit in Fig.¬†5b is compiled to the physical qubit layout of ibmq_rome and the resulting circuit is 
depicted in Fig.¬†7 that is executed 1024 times to obtain the data used to generate Fig.¬†5a. We used the quantum 
information science kit (qiskit). Python implementation of gen_angles¬†and Algorithm¬†3 are used to generate 
the quantum circuit in Figs.¬†4 and 5b.
The depth of the quantum circuits for state preparations described in Table¬†1 is obtained using a python 
implementation of Algorithm¬†3, the qiskit implementation ¬≠of11 and a non-optimized version of the ¬≠algorithm10 
available at the GitHub repository. For each input size we generated a random vector used for all methods. In 
these first two set of experiments we used qiskit version 0.14.1 and python version 3.7.7.
In ‚ÄúHierarchical quantum classifier‚Äù section, simulations of the hybrid classification algorithms were per-
formed using Xanadu‚Äôs ¬≠Pennylane26 default qubit plugin state simulator. We used 2/10 of the datasets as a test set, 
2/10 as a validation set, and the remaining as a training set. As preparation for qubit encoding, each data vector 
element of all datasets was re-scaled within the range of [0, œÄ]‚Ää. Also, for amplitude encoding and divide-and-
conquer encoding, the data vectors were normalized. Our simulation employs the Adaptative Moment Estimation 
(Adam) for the optimization ¬≠process27 with a learning rate of 0.1 and a batch size of 1/10 of the training set size. 
Training stops when validation set accuracy does not increase for 30 consecutive tests or 200 iterations is reached.
Table‚ÄØ2.‚ÄÇ ‚ÄâMean test accuracy and one standard deviation for TTN classifiers with ten different random 
parameter initializations. Three binary datasets were extracted from the original Iris dataset.
Dataset
Classes
Encoding
Qubit
Amplitude
Divide-and-conquer
Haberman
0 or 1
60.33 ¬± 2.02
59.02 ¬± 0.00
59.02 ¬± 0.00
Banknote
0 or 1
91.28 ¬± 3.11
87.15 ¬± 0.74
87.45 ¬± 1.12
Pima
0 or 1
77.19 ¬± 2.08
70.78 ¬± 1.88
71.11 ¬± 1.79
Iris
0 or 1
100 ¬± 0.00
100 ¬± 0.00
100 ¬± 0.00
0 or 2
100 ¬± 0.00
100 ¬± 0.00
100 ¬± 0.00
1 or 2
98.50 ¬± 2.42
93.00 ¬± 2.58
93.00 ¬± 2.58
Figure¬†7.‚ÄÇ ‚ÄâThe transpiled circuit of the divide-and-conquer state preparation circuit in Fig.¬†5b in accordance 
with the physical qubit layout of the ibmq_rome device. The gates U1‚Ää, U2‚Ää, and U3 are physical single-qubit 
gates of IBM Quantum Experience that take in one, two, and three parameters, respectively. The measurement 
outcomes are stored in classical registers denoted by c[0] and c[1].
78

11
Vol.:(0123456789)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Data availibility
The site https://‚Äãwww.‚Äãcin.‚Äãufpe.‚Äãbr/‚Äã~ajsil‚Äãva/‚Äãdcsp/ contains all the data and software generated during the current 
study.
Received: 24 September 2020; Accepted: 2 March 2021
References
	 1.	 Arute, F. et al. Quantum supremacy using a programmable superconducting processor. Nature 574, 505‚Äì510 (2019).
	 2.	 Biamonte, J. et al. Quantum machine learning. Nature 549, 195‚Äì202 (2017).
	 3.	 Aaronson, S. Read the fine print. Nat. Phys. 11, 291‚Äì293. https://‚Äãdoi.‚Äãorg/‚Äã10.‚Äã1038/‚Äãnphys‚Äã3272 (2015).
	 4.	 LeCun, Y., Bengio, Y. & Hinton, G. Deep learning. Nature 521, 436‚Äì444 (2015).
	 5.	 Dong, Y. et al. Stochastic quantization for learning accurate low-bit deep neural networks. Int. J. Comput. Vis. 127, 1629‚Äì1642 
(2019).
	 6.	 Yang, C.-C. & Cong, G. Accelerating data loading in deep neural network training. In 2019 IEEE 26th International Conference on 
High Performance Computing, Data, and Analytics (HiPC), 235‚Äì245 (IEEE, 2019).
	 7.	 Wootters, W. K. & Zurek, W. H. A single quantum cannot be cloned. Nature 299, 802‚Äì803 (1982).
	 8.	 Preskill, J. Quantum computing in the nisq era and beyond. Quantum 2, 79 (2018).
	 9.	 Hughes, R. J., James, D. F., Knill, E. H., Laflamme, R. & Petschek, A. G. Decoherence bounds on quantum computation with trapped 
ions. Phys. Rev. Lett. 77, 3240 (1996).
	10.	 M√∂tt√∂nen, M., Vartiainen, J. J., Bergholm, V. & Salomaa, M. M. Transformation of quantum states using uniformly controlled 
rotations. Quant. Inf. Comput. 5, 467‚Äì473 (2005).
	11.	 Shende, V. V., Bullock, S. S. & Markov, I. L. Synthesis of quantum-logic circuits. IEEE Trans. Comput.-Aided Design Integr. Circuits 
Syst. 25, 1000‚Äì1010 (2006).
	12.	 Iten, R., Colbeck, R., Kukuljan, I., Home, J. & Christandl, M. Quantum circuits for isometries. Phys. Rev. A 93, 032318 (2016).
	13.	 Park, D. K., Petruccione, F. & Rhee, J.-K.K. Circuit-based quantum random access memory for classical data. Sci. Rep. 9, 1‚Äì8 (2019).
	14.	 Park, D. K., Sinayskiy, I., Fingerhuth, M., Petruccione, F. & Rhee, J.-K.K. Parallel quantum trajectories via forking for sampling 
without redundancy. New J. Phys. 21, 083024. https://‚Äãdoi.‚Äãorg/‚Äã10.‚Äã1088/‚Äã1367-‚Äã2630/‚Äãab35fb (2019).
	15.	 Cormen, T.¬†H., Leiserson, C.¬†E., Rivest, R.¬†L. & Stein, C. Introduction to algorithms (MIT press, 2009).
	16.	 Hoare, C. A. R. Algorithm¬†64: quicksort. Commun. ACM 4, 321 (1961).
	17.	 Gentleman, W.¬†M. & Sande, G. Fast fourier transforms: for fun and profit. In Proceedings of the November 7-10, 1966, fall joint 
computer conference, 563‚Äì578 (1966).
	18.	 Mottonen, M., Vartiainen, J. J., Bergholm, V. & Salomaa, M. M. Transformation of quantum states using uniformly controlled 
rotations. Quant. Inf. Comput. 5, 467‚Äì473 (2005).
	19.	 Aleksandrowicz, G.¬†A. et¬†al. Qiskit: An Open-source Framework for Quantum Computing, https://‚Äãdoi.‚Äãorg/‚Äã10.‚Äã5281/‚Äãzenodo.‚Äã25621‚Äã
11 (2019).
	20.	 Grant, E. et¬†al. Hierarchical quantum classifiers. npj Quant. Inf.4, 65. https://‚Äãdoi.‚Äãorg/‚Äã10.‚Äã1038/‚Äãs41534-‚Äã018-‚Äã0116-9 (2018).
	21.	 Cohen, N. & Shashua, A. Convolutional rectifier networks as generalized tensor decompositions. Int. Conf. Mach. Learn. 955‚Äì963, 
(2016).
	22.	 Levine, Y., Sharir, O., Cohen, N. & Shashua, A. Quantum entanglement in deep learning architectures. Phys. Rev. Lett. 122, 065301. 
https://‚Äãdoi.‚Äãorg/‚Äã10.‚Äã1103/‚ÄãPhysR‚ÄãevLett.‚Äã122.‚Äã065301 (2019).
	23.	 Dua, D. & Graff, C. UCI machine learning repository (2017).
	24.	 Rossi, R.¬†A. & Ahmed, N.¬†K. The network data repository with interactive graph analytics and visualization. In Proceedings of the 
Twenty-Ninth AAAI Conference on Artificial Intelligence, AAAI‚Äô15, 4292‚Äì4293 (AAAI Press, 2015).
	25.	 Dem≈°ar, J. Statistical comparisons of classifiers over multiple data sets. J. Mach. Learn. Res. 7, 1‚Äì30 (2006).
	26.	 Bergholm, V. et¬†al. Pennylane: Automatic differentiation of hybrid quantum-classical computations (2020). 1811.04968.
	27.	 Kingma, D. P. & Ba, J, (A method for stochastic optimization, Adam, 2017) ((1412.6980)).
Acknowledgements
This research is supported by CNPq (Grant No. 308730/2018-6), CAPES- Finance Code 001 and FACEPE (Grant 
No. IBPG 0834-1.03/19), the National Research Foundation of Korea (Grant Nos. 2019R1I1A1A01050161 and 
2018K1A3A1A09078001), the Ministry of Science and ICT, Korea, under an ITRC Program, IITP-2019-2018-
0-01402, and the South African Research Chair Initiative of the Department of Science and Innovation and 
National Research Foundation (UID: 64812). We acknowledge use of IBM Q for this work. The views expressed 
are those of the authors and do not reflect the official policy or position of IBM or the IBM Q team.
Author contributions
A.J.S. devised the divide-and-conquer state preparation strategy, performed the proof-of-concept experiments 
and wrote a first version of the manuscript. D.K.P. suggested the way to make ancillary states orthogonal, and 
conceived the combination of swap test with the divide-and-conquer state preparation to calculate metrics 
between two datasets. I.F.A. performed the experiments with the variational quantum circuits and extended the 
algorithm to complex input vectors. All authors reviewed and discussed the analyses and results, and contributed 
towards writing the manuscript.
Competing interests‚ÄÇ
The authors declare no competing interests.
Additional information
Correspondence and requests for materials should be addressed to F.P.
Reprints and permissions information is available at www.nature.com/reprints.
Publisher‚Äôs note‚ÄÇ Springer Nature remains neutral with regard to jurisdictional claims in published maps and 
institutional affiliations.
79

12
Vol:.(1234567890)
Scientific Reports |         (2021) 11:6329  | 
https://doi.org/10.1038/s41598-021-85474-1
www.nature.com/scientificreports/
Open Access‚ÄÇ This article is licensed under a Creative Commons Attribution 4.0 International 
License, which permits use, sharing, adaptation, distribution and reproduction in any medium or 
format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the 
Creative Commons licence, and indicate if changes were made. The images or other third party material in this 
article are included in the article‚Äôs Creative Commons licence, unless indicated otherwise in a credit line to the 
material. If material is not included in the article‚Äôs Creative Commons licence and your intended use is not 
permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from 
the copyright holder. To view a copy of this licence, visit http://‚Äãcreat‚Äãiveco‚Äãmmons.‚Äãorg/‚Äãlicen‚Äãses/‚Äãby/4.‚Äã0/.
¬© The Author(s) 2021
80

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum
state preparation
Israel F. Araujo1*, Daniel K. Park2,3, Teresa B.
Ludermir1, Wilson R. Oliveira4, Francesco Petruccione5,6,7
and Adenilton J. da Silva1
1*Centro de Inform¬¥atica, Universidade Federal de Pernambuco,
Recife, 50740-560, Pernambuco, Brazil.
2Department of Applied Statistics, Yonsei University, Seoul,
03722, Republic of Korea.
3Department of Statistics and Data Science, Yonsei University,
Seoul, 03722, Republic of Korea.
4Departamento de Estat¬¥ƒ±stica e Inform¬¥atica, Universidade
Federal Rural de Pernambuco, Recife, Pernambuco, Brazil.
5School of Data Science and Computational Thinking,
Stellenbosch University, Stellenbosch, 7600, South Africa.
6National Institute for Theoretical and Computational Sciences
(NITheCS), 4001, South Africa.
7Quantum Research Group, University of KwaZulu-Natal,
Durban, 4001, South Africa.
*Corresponding author(s). E-mail(s): ifa@cin.ufpe.br;
Abstract
The theory of quantum algorithms promises unprecedented benefits of
harnessing the laws of quantum mechanics for solving certain com-
putational problems. A prerequisite for applying quantum algorithms
to a wide range of real-world problems is loading classical data to
a quantum state. Several circuit-based methods have been proposed
for encoding classical data as probability amplitudes of a quantum
state. However, in these methods, either quantum circuit depth or
width must grow linearly with the data size, nullifying the advan-
tage of representing exponentially-many classical data in a quantum
1
81
AP√äNDICE B ‚Äì CONFIGURABLE SUBLINEAR CIRCUITS FOR QUANTUM
STATE PREPARATION

Springer Nature 2021 LATEX template
2
Configurable sublinear circuits for quantum state preparation
state. In this paper, we present a configurable bidirectional proce-
dure that addresses this problem by tailoring the resource trade-off
between quantum circuit width and depth. In particular, we show a
configuration that encodes an N-dimensional classical data using a quan-
tum circuit whose width and depth both grow sublinearly with N.
We demonstrate proof-of-principle implementations on five quantum
computers accessed through the IBM and IonQ quantum cloud services.
Keywords: quantum computing, state preparation, bidirectional, circuit
optimization
1 Introduction
In 1981, Richard Feynman suggested a computational architecture based on
cellular automata with quantum features and conjectured that it could accel-
erate simulations of quantum physics and chemistry beyond the capability
of classical computers [1]. Since then, algorithms such as Deutsch-Jozsa [2],
Grover [3], Simon [4], and Shor [5] demonstrated quantum advantages. How-
ever, some challenges prevent such advantages from applying to all quantum
algorithms [6‚Äì8]. Among these challenges is the development of an efficient
encoding of classical data into a quantum state [6‚Äì9].
Quantum algorithms assume an initial quantum state prepared before the
computation. The worst case complexity of preparing an arbitrary quantum
state is exponential with the number of qubits [10]. For this reason, the most
significant quantum speed-ups occur when the quantum algorithm [2‚Äì5, 11,
12] operates on an input state that is easy to prepare, such as the uniform
superposition of all computational basis states. For algorithms that rely on
loading data into an arbitrary quantum state, an efficient means to prepare
input states is a prerequisite to quantum speed-ups [6, 7, 9, 13].
While the quantum state preparation models based on quantum ora-
cles [14‚Äì16] or quantum random access memory [17‚Äì24] are useful for
evaluating the lower bounds of the computational cost and identifying the
complexity class, implementations of them must be considered in practice. In
particular, the quantum speed-up can vanish without an efficient implemen-
tation of quantum state preparation when quantum algorithms carry classical
data in a non-uniform quantum superposition. Examples of such instances
include Quantum Machine Learning (QML) [6, 7, 25‚Äì31], Quantum Memories
(QMem) [17‚Äì24], and Quantum Linear Algebra (QLA) [7, 13, 32‚Äì35]. Quan-
tum machine learning algorithms try to estimate a target function from a
finite set of example points by unveiling correlations between inputs and out-
puts of the correspondent function [7, 28, 36]. Quantum memories must store
a set of samples from a configuration space as a superposition state before
the information is retrieved using the algorithm [17]. Quantum linear algebra
82

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
3
Œ∑1,3
Œ∑1,2
Œ∑1,1
x0
x1
Œ∑2,1
x2
x3
Œ∑2,2
Œ∑3,1
x4
x5
Œ∑4,1
x6
x7
(a)
Œ±1,3
Œ±1,2
Œ±1,1
Œ±2,1
Œ±2,2
Œ±3,1
Œ±4,1
(b)
Fig. 1: Tree representations of quantum state preparation algorithms. (a)
State decomposition tree generated by Algorithm 1 with an 8-dimensional
input vector x (dashed nodes). The complex argument terms ‚Ñ¶i,k were omitted
for readability. (b) Angle tree generated by Algorithm 2 with an 8-dimensional
input vector. The correspondent phase angles Œªj,v were omitted for readability.
algorithms operate with a critical assumption that classical data has been effi-
ciently encoded as probability amplitudes of a quantum state without which
the quantum speed-up vanishes [6, 7, 9, 13]. All of the above emphasizes the
importance of developing efficient quantum state preparation algorithms for
broad application of quantum computing techniques on classical data.
Several solutions to the problem of quantum state preparation have been
proposed [10, 14, 37‚Äì42], but all produce circuits with width or depth grow-
ing at least linearly with the size of the input vector [10]. For example, the
top-down method proposed in Ref. [37] achieves the exponential compression
of the quantum circuit width while requiring O(N) quantum circuit depth
for N-dimensional data. On the other extreme end, the bottom-up method
[42] achieves the exponential compression of the quantum circuit depth while
requiring O(N) quantum circuit width and entangled information in ancillary
qubits. Since there is an extra resource overhead in many quantum algorithms
due to the quantum measurement postulate [23, 43], such linear cost can
impose restrictions on possible speed-ups, dominating the computational cost
of the intended quantum application. Other approaches have reduced circuit
complexity to initialize an approximate quantum state [14, 44‚Äì46], but this
paper targets the exact state preparation with entangled ancillary qubits.
This work presents a quantum state preparation method that achieves
sublinear scaling on both quantum circuit resources. More specifically, a bidi-
rectional strategy that effectively combines the aforementioned approaches
in a way that the trade-off between computational time and space can be
configured. Both temporal and spatial complexities depend on the parame-
ter s ‚àà[1..n], which adjusts the trade-off between computational time and
space. Given an N-dimensional input vector, the total time complexity of
the bidirectional algorithm is Oc(N) + Od(2s + log2
2(N) ‚àís2), where Oc(N)
is the time of the classical preprocessing to create the quantum circuit and
Od(2s + log2
2(N) ‚àís2) is the quantum circuit depth. Typically the same input
83

Springer Nature 2021 LATEX template
4
Configurable sublinear circuits for quantum state preparation
vector is loaded l ‚â´N times, and hence the amortized computational time is
Od(2s+log2
2(N)‚àís2). Note that classical preprocessing is also common in clas-
sical computing and is necessary in other quantum state preparation methods
as well. The spatial complexity (i.e. the width) of the circuit is Ow((s+1)N/2s).
Besides the sublinear circuit cost, the ability to customize the exchange
between these quantum resources is advantageous when realistic quantum
hardware specifications are considered as one resource can be cheaper than
the other to scale up. For instance, it is a useful feature for future Noisy
Intermediate-Scale Quantum (NISQ) devices with the promise of computers
with a large number of physical qubits [47], albeit noise limits the depth of the
circuits [48].
This paper is divided into four sections. Section 2 reviews two strategies
for loading classical information into quantum devices, namely top-down [39]
and bottom-up [42] approaches. The former is used by quantum computing
libraries [49, 50] as the method for general quantum amplitude initialization.
These methods are at the two opposite ends of the quantum circuit cost spec-
trum requiring either the maximal circuit depth or width to minimize the
other resource. Section 3 presents the main result, a bidirectional method
that combines the top-down and bottom-up strategies in a configurable man-
ner. Complexity expressions for the bidirectional method are established in
Section 3.1, which shows that the bottom-up and the top-down strategies are
recovered when s = 1 and s = n, respectively, and that sublinear scaling on
both depth and width is possible when s = n/2. Proof-of-principle experiments
performed on superconducting and ion-trap based quantum devices are pre-
sented in Section 3.2. Section 5 presents the conclusion and perspectives for
future work.
2 Quantum state preparation with linear cost
2.1 Tree representation
Quantum state preparation algorithms aim to create a state P
p |xp|eiœâp |p‚ü©
that encodes a normalized vector x = (|x0|eiœâ0, . . . , |xN‚àí1|eiœâN‚àí1) as the prob-
ability amplitudes. Several of the existing methods can be understood as a
walk on a binary tree [10, 39, 41, 42, 51]. Each tree node corresponds to a
controlled gate operation and the height increases with the number of qubits
(see Fig. 1a and Fig. 1b). Two edges stemming from each node indicate that
each controlled gate operation splits the Hilbert space into two subspaces.
Therefore, after n layers, there can be 2n subspaces with distinct probabil-
ity amplitudes. Depending on the choice of the walk direction, different state
preparation strategies, such as top-down and bottom-up approaches, can be
constructed.
84

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
5
To explain the procedure, four parameters [39] defined by the target vector
x are introduced as
‚Ñ¶i,k =
2k‚àí1
X
l=0
œâ(i‚àí1)2k+l/2k‚àí1
(1)
Œ∑i,k =
v
u
u
t
2k‚àí1
X
l=0
|x(i‚àí1)2k+l|2
(2)
Œªj,v = ‚Ñ¶2j,v‚àí1 ‚àí‚Ñ¶j,v
(3)
Œ≤j,v = Œ∑2j,v‚àí1/Œ∑j,v
(4)
where j = 1, 2, . . . , 2n‚àív, v = 1, 2, . . . , n, and n = log2(N). These parameters
are used to construct the tree representations of the state preparation algo-
rithms, namely the state tree (Fig. 1a) and the angle tree (Fig. 1b). Indices k
and v indicate a tree level in ascending order from the leaf nodes to the root,
i and j are node indices at a given level. The nodes of these trees are complex
values that represent the amplitudes of the quantum state to be encoded and
the rotation angles for the construction of the encoding quantum circuit. The
magnitude and complex argument of the state tree amplitudes are obtained
through Œ∑i,k and ‚Ñ¶i,k, respectively. When k = 0, the parameters point to
the input vector x. Equations (3) and (4) determine rotation values of the
angle tree nodes. The phase arguments of the vector |x‚ü©are encoded through
z-rotations of angles Œªj,v, and the magnitudes through y-rotations of angles
Œ±j,v = 2 asin(Œ≤j,v).
Algorithms 1 and 2 describe the construction of a state tree and an angle
tree. Respective pseudocodes 1 and 2 are presented in the appendix.
Algorithm 1: State tree construction
1 Initialize the state tree by the leafs, where each node value is a
complex amplitude from a 2n length state vector
2 Set k = 1
3 Create a new level with 2n‚àík nodes, where each node i value is
Œ∑i,kei‚Ñ¶i,k (Eq. (1) and Eq. (2), i = 1, . . . , 2n‚àík)
4 If k < n, set k = k + 1 and return to Step 2, otherwise output the
state tree
2.2 Top-down approach
The top-down amplitude encoding approach to quantum state initialization is
a linear transformation consisting of a sequence of uniformly controlled rota-
tions [39, 51] that takes the initial basis vector |0‚ü©‚äón to some arbitrary vector
85

Springer Nature 2021 LATEX template
6
Configurable sublinear circuits for quantum state preparation
Algorithm 2: Angle tree construction
1 Set v = n
2 Create a new level with 2n‚àív nodes, where each node j value is
Œ±j,veiŒªj,v (Eq. (4) and Eq. (3), j = 1, . . . , 2n‚àív) using data from a
state tree generated by Alg. 1
3 If v > 1, set v = v ‚àí1 and return to Step 1, otherwise output the
angle tree
|0‚ü©0
Ry(Œ±1,3)
|0‚ü©1
Ry(Œ±1,2)
Ry(Œ±2,2)
|0‚ü©2
Ry(Œ±1,1)
Ry(Œ±2,1)
Ry(Œ±3,1)
Ry(Œ±4,1)
Fig. 2: Quantum circuit to load an 8-dimensional real vector in a quantum
device using the top-down amplitude encoding strategy [10, 39, 51] (Alg. 3).
The qubit index indicated by the subscript corresponds to the tree level in
Fig. 1b.
|x‚ü©= (|x0|eiœâ0, . . . , |xN‚àí1|eiœâN‚àí1)T . This generates a quantum circuit with
complexity of Od(N) and Ow(log2(N)) [10, 39, 51].
The top-down state preparation (TDSP) algorithm begins by preparing the
following state at the root (v = n) of the angle tree (see Fig. 1b for an example)
|œàn‚ü©= e‚àíi
Œª1,n
2
q
1 ‚àí|Œ≤1,n|2 |0‚ü©+ ei
Œª1,n
2 Œ≤1,n |1‚ü©.
(5)
To load states into the next level (indicated by v in Eq. (6)), the current state
(indicated by v + 1 because v is in reverse order, decreasing from n to 1) is
sequentially combined with the values of the next state in Eq. (6).
|œàv‚ü©=
2n‚àív
X
j=1
|j ‚àí1‚ü©‚ü®j ‚àí1|œàv+1‚ü©
 e‚àíi
Œªj,v
2
q
1 ‚àí|Œ≤j,v|2 |0‚ü©+ ei
Œªj,v
2 Œ≤j,v |1‚ü©

(6)
The update of state |œàv‚ü©is repeated for v = (n ‚àí1), . . . , 1, thereby obtaining
the desired state
|œà1‚ü©= |x0|eiœâ0 |0‚ü©+ . . . + |xN‚àí1|eiœâN‚àí1 |N ‚àí1‚ü©.
The summation in Equation (6) expresses the sequential characteristic of the
top-down approach, since the state of each layer of the tree needs to be loaded
on one qubit through a sequence of rotations. Figure 2 presents an example
86

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
7
quantum circuit for encoding 8-dimensional vector using the top-down state
preparation method.
Algorithm 3: Top-down state preparation
1 Generate a state tree from the input vector
2 Generate an angle tree from the state tree
3 Create a quantum circuit with n qubits (one qubit for each angle tree
level)
4 Perform one y-rotation and one z-rotation on the first qubit (qubits
are 0-indexed) using the angle tree root values Œ±1,n and Œª1,v (Eq. (5))
5 Set v = n ‚àí1 (starts at the root)
6 Perform a Uniformly Controlled Rotation controlled by qubits
0, 1, . . . , n ‚àív ‚àí1 (corresponding to the previous levels) with the
current qubit n ‚àív as target, using the current level nodes values
Œ±j,v and Œªj,v (1 ‚â§j ‚â§2n‚àív) as rotation angles (Eq. (6))
7 If v > 1, set v = v ‚àí1 and return to Step 5, otherwise output the
encoding quantum circuit
The name top-down comes from the way this approach walks through the
tree from the root to the leaves to build a quantum circuit. The combination
of states is done with multi-controlled rotations, and it takes log2(N) qubits to
generate the complete state. At each level, it assembles a sequence of rotations
targeting one qubit and is controlled by the qubits of the previous levels. First,
y-rotations are applied to set the magnitudes, followed by z-rotations to set
the phases. These steps are presented in Algorithm 3 with its Pseudocode 3
provided in the appendix.
2.3 Bottom-up approach
The bottom-up state preparation algorithm constructs a quantum circuit with
complexity Od(log2
2(N)) and Ow(N) [42]. It starts by preparing N/2 single-
qubit states, corresponding to the leaves of the tree (Fig.1a). Equations (3)
and (4) are used starting from the lowest level of the tree (v = 1), which
corresponds to starting from the initial state
|œàj,1‚ü©= e‚àíi
Œªj,1
2
q
1 ‚àí|Œ≤j,1|2 |0‚ü©+ ei
Œªj,1
2 Œ≤j,1 |1‚ü©.
(7)
Loading the states in the upper levels of the tree is done by recursive updates
of
|œàj,v‚ü©=
e‚àíi
Œªj,v
2
q
1 ‚àí|Œ≤j,v|2 |0‚ü©|œà2j‚àí1,v‚àí1‚ü©|œà2j,v‚àí1‚ü©+
ei
Œªj,v
2 Œ≤j,v |1‚ü©|œà2j,v‚àí1‚ü©|œà2j‚àí1,v‚àí1‚ü©,
(8)
87

Springer Nature 2021 LATEX template
8
Configurable sublinear circuits for quantum state preparation
one-qubit states
combining states
|0‚ü©0
Ry(Œ±1,3)
Rz(Œª1,3)
output
|0‚ü©1
Ry(Œ±1,2)
Rz(Œª1,2)
|0‚ü©2
Ry(Œ±2,2)
Rz(Œª2,2)
ancilla
|0‚ü©3
Ry(Œ±1,1)
Rz(Œª1,1)
output
|0‚ü©4
Ry(Œ±2,1)
Rz(Œª2,1)
ancilla
|0‚ü©5
Ry(Œ±3,1)
Rz(Œª3,1)
|0‚ü©6
Ry(Œ±4,1)
Rz(Œª4,1)
(a)
...
...
...
...
a |0‚ü©+ b |1‚ü©
a |0‚ü©|œà‚ü©|œï‚ü©+ b |1‚ü©|œï‚ü©|œà‚ü©
|œà‚ü©m
|œï‚ü©m
(b)
Fig. 3: Divide-and-conquer bottom-up load strategy. (a) Circuit generated
by the divide-and-conquer [42] bottom-up strategy (Alg. 4) to load an 8-
dimensional complex vector in a quantum device. The indexes of the qubits
correspond to the tree nodes indexes in Fig. 1b. The circuit starts with the
simultaneous preparation of (N ‚àí1) one-qubit states associated with all tree
nodes, followed by the combination of states through CSWAPs. (b) Combin-
ing states with controlled-swap operations.
where v = 2, . . . , n. The desired state, with ancilla |œï‚ü©, is obtained when v = n
as
|œà1,n‚ü©= |x0|eiœâ0 |0‚ü©|œï0‚ü©+ ¬∑ ¬∑ ¬∑ + |xN‚àí1|eiœâN‚àí1 |N ‚àí1‚ü©|œïN‚àí1‚ü©.
(9)
Updating the states in Equation (8) requires a method that entangles each
of the two states |œà2j‚àí1,v‚àí1‚ü©and |œï2j,v‚àí1‚ü©to orthonormal subspaces |0‚ü©and
|1‚ü©, respectively, with designated amplitudes. As demonstrated by Araujo et
al. [42], m controlled-swap (CSWAP) operations can combine two m-qubit
states in the form of Equation (8) (see Fig. 3b) to encode the desired set
of amplitudes in the orthonormal subspaces of the first m + 1 qubits. Since
each node of the level is represented by one qubit, multiple loading within a
layer can be performed in parallel. Thus, all states in the given layer can be
loaded simultaneously. This is an advantage in comparison to the top-down
approach which loads each node state sequentially. Since the underlying idea
of the bottom-up approach is recursive combination of single-qubit states that
are easy to prepare, it was named as divide-and-conquer state preparation
(DCSP) when first introduced [42]. An example quantum circuit for encoding
8-dimensional vector using the DCSP method is depicted in Fig. 3a. Algorithm
4 describes these steps and Pseudocode 4 is provided in the appendix.
88

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
9
Algorithm 4: Bottom-up state preparation
1 Generate a state tree from the input vector
2 Generate an angle tree from the state tree
3 Create a quantum circuit with 2n ‚àí1 qubits (one qubit for each angle
tree node)
4 Perform 2n‚àí1 y-rotations and z-rotations on qubits 2n‚àí1 + j ‚àí2
(1 ‚â§j ‚â§2n‚àí1) using the leaf values Œ±j,1 and Œªj,1 to prepare 2n‚àí1
initial single-qubit states (Eq. (7), Fig. 3a)
5 Set v = 2 and j = 1 (starts at the bottom)
6 Perform one y-rotation and one z-rotation on qubit 2n‚àív + j ‚àí2 using
the node values Œ±j,v and Œªj,v to prepare a single-qubit state to
control CSWAPs operations
7 Perform Controlled SWAPs controlled by qubit 2n‚àív + j ‚àí2 to
combine the previous states prepared with the qubits associated to
the sub-tree started by the current node (Eq. (8), Fig. 3b)
8 If j < 2n‚àív, set j = j + 1 and return to Step 5, otherwise continue
9 If v < n, set v = v + 1 and return to Step 5, otherwise output the
encoding quantum circuit
3 Bidirectional quantum state preparation
This section presents a bidirectional state preparation (BDSP) method com-
bining both bottom-up and top-down strategies as walking on the tree in both
directions. This new strategy can interchange depth and space cost in a con-
figurable manner, thereby allowing for the sublinear cost in both quantum
circuit depth and width. In particular, the equilibrium point between these
costs achieves the quadratic reduction in both space and time. The algorithm
is depicted in Fig. 4 and the detailed explanation is provided as follows.
The bidirectional state preparation algorithm starts by informing a level
v = s (enumerated from bottom to top, where 1 ‚â§s ‚â§n) at which the
angle tree is split, followed by two stages. In the first stage, it segments the
tree section below s into 2n‚àís sub-trees of height s. The 2n‚àís nodes at level
s are the roots of these sub-trees. The number of sub-trees determines how
many initial sub-states should be prepared in the first stage of the algorithm.
The amplitude values of these sub-states aj = (aj,1, . . . , aj,2s) (1 ‚â§j ‚â§2n‚àís)
are loaded concurrently using a sequential algorithm [10, 39, 51] based on the
TDSP method as
|œàj,s‚ü©=
2s
X
k=1
aj,k |k ‚àí1‚ü©
;
j = 1, 2, . . . , 2n‚àís.
(10)
The initial sub-states are the input of the second stage of BDSP. They repro-
duce the state that would be created by the bottom-up steps up to the split
level s. In the second stage, the sub-states are combined to generate the
89

Springer Nature 2021 LATEX template
10
Configurable sublinear circuits for quantum state preparation
Œ±0
1,3
s = 3
Œ±1
1,2
Œ±1
1,1
Œ±1
2,1
Œ±2
1,2
s = 2
Œ±2
1,1
Œ±2
2,1
s = 1
(a)
stage 2
stage 1
|0‚ü©0
B
|0‚ü©1
A1
|0‚ü©3
|0‚ü©2
A2
|0‚ü©5
output
input
ancilla
(b)
stage 2
stage 1
|0‚ü©0
Ry(Œ±0
1,3)
output
|0‚ü©1
Ry(Œ±1
1,2)
|0‚ü©3
Ry(Œ±1
1,1)
Ry(Œ±1
2,1)
|0‚ü©2
Ry(Œ±2
1,2)
ancilla
|0‚ü©5
Ry(Œ±2
1,1)
Ry(Œ±2
2,1)
(c)
Fig. 4: Schematics of the bidirectional algorithm. (a) Angle tree example with
a split at level s = 2. The blue and red nodes (Œ±1 and Œ±2) correspond to the
bidirectional procedure first stage. In each of the two sub-trees of the first
stage, 4 of the 8 amplitudes expected as input by stage 2 are encoded using a
top-down method. The green node (Œ±0) above the tree split correspond to the
second stage single sub-tree, subject to a partial DCSP bottom-up procedure.
The first stage red nodes (j > 1) are no longer associated with an ancilla
since they are now encoded through a top-down approach. (b) Block diagram
circuit, corresponding to the tree in (a). In stage 1, the Ak operators (the index
k is related to angle vectors Œ±k upper index) are responsible for encoding the
amplitudes that will be used as input by stage 2. In this example, each Ak
operator encodes 4 amplitudes from a total of 8. The B operator is the partial
DCSP for 8 amplitudes, which is initialized with the expected state for the
split level 2 and continues with the traditional algorithm. (c) Detailed view of
(b), generated by the bidirectional strategy described in Algorithm 5 for a real
and positive 8-dimensional input vector.
complete state by the divide-and-conquer approach (Fig. 4c). The bottom-up
algorithm takes the state prepared in the first stage as the input, and starts
walking on the tree from the split level (Eq. (8), where v = s + 1, . . . , n).
In other words, the BDSP follows the bottom-up DCSP algorithm starting
from states |œàj,s‚ü©(Eq. (10)) instead of starting from the single-qubit leaf
states (Eq. (7)). The BDSP algorithm is described in Algorithm 5 below with
Pseudocode 5 provided in the appendix.
90

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
11
Algorithm 5: Bidirectional state preparation
1 Generate a state tree from the input vector
2 Generate an angle tree from the state tree
3 Create a quantum circuit with (s + 1)2n‚àís ‚àí1 qubits (Eq. (12))
4 Perform Algorithm 3 (top-down approach) starting from step 3 to
prepare 2n‚àís states of s-qubits (replacing n by s), using the 2n‚àís
sub-trees as input for each state (Eq. (10)). This step is named Stage 1
5 Perform Algorithm 4 (bottom-up approach) starting from step 5 and
v = s + 1 to combine the 2n‚àís states prepared in Stage 1 using the
remaining 2n‚àís ‚àí1 qubits (Eq. (8)). This step is named Stage 2
6 Output the encoding quantum circuit
3.1 Complexity
In general, the BDSP algorithm builds quantum circuits whose depth and
width are expressed respectively by
N
2log2(N)‚àís
|
{z
}
stage 1
+
log2(N)
X
i=s+1
i ‚àí1
|
{z
}
stage 2
= 2s + 1
2(log2
2(N) ‚àílog2(N) ‚àís2 + s)
(11)
and
sN
2s
|{z}
stage 1
+ N
2s ‚àí1
| {z }
stage 2
= (s + 1)N
2s ‚àí1,
(12)
where N is the number of amplitudes (i.e. the dimension of the data vec-
tor) and s is a parameter indicating the tree splitting level (the tree level in
reverse order). Stage 1 and 2 indicate the contribution from each stage of the
bidirectional procedure to the circuit complexity stated in Theorem 1.
Theorem
1.
Algorithm
5
generates
a
quantum
circuit
with
depth
Od
 2s + log2
2 (N) ‚àís2
and width Ow
 (s + 1) N
2s

.
In Equation (11), first term (stage 1) is the leading-order approximation of
the quantum circuit depth from existing top-down based algorithms [10, 39]
for sub-states with s qubits. The exact expression depends on which of the two
algorithms is used. The summation of the second term (stage 2) is the divide-
and-conquer circuit depth from split level s + 1 to n. Similarly, the first term
in Equation (12) is the number of qubits occupied by all first stage sub-states
and the second term is the number of qubits used by the second stage.
There are three noteworthy configuration values for the parameter s (see
Table 1). Setting s = log2(
‚àö
N) achieves asymptotic sublinearity, and s = 1
or s = log2(N) recovers bottom-up or top-down approaches.
91

Springer Nature 2021 LATEX template
12
Configurable sublinear circuits for quantum state preparation
bottom-up
s = 1
top-down
s = n
sublinear
s = n/2
Od
n2
2n
2n/2
Ow
2n
n
2n/2
Table 1: Bidirectional quantum circuit complexity for different configurations.
These expressions were obtained from Eq. (11) and Eq. (12).
The condition for quadratic reduction in both depth and width is obtained
through asymptotic analysis of the minimum distance between Eq. (11) and
Eq. (12). The first (second) equation is a monotonically increasing (decreasing)
function ‚àÄs ‚àà{x ‚ààR|4 ‚â§x ‚â§log2(N)} and there is a point s where the
distance is zero when N ‚Üí‚àû. Thus the minimum distance point is given by
finding s that satisfies
lim
N‚Üí‚àûOw ‚àíOd = 0.
(13)
Fig. 5: The solution of the system Ow ‚àíOd = 0 approaches k = 1/2 as N
increases.
The asymptotic analysis starts by rewriting Eq. (11) and Eq. (12) using a
more convenient parameterization,
s = f(k) = k log2(N)
where
k ‚àà

4
log2(N), 1

.
Applying the limit of Eq. (13) results in the following simplified expression
N 2k‚àí1 = 1.
Solving the above equation for k gives the solution k = 1/2. Therefore, to
achieve sublinear circuit complexity with quadratic reductions in both quan-
tum circuit depth and width, the tree split must occur at s = 1/2 log2(N) = n/2,
which leads to Theorem 2.
Theorem 2. Algorithm 5 with s = n/2 and N ‚â´1 generates a quantum circuit
with sublinear depth Od
 ‚àö
N

and width Ow
 ‚àö
N

.
92

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
13
When dealing with input vectors of small size, s can be calculated by solving
Eq. (13) directly with N being a constant. If s cannot be calculated exactly,
it can be approximated with the asymptotic result s = ‚åàn/2‚åâ. The reason for
the ceiling function is because s approximates n/2 from upper values (Fig. 5).
Corollary 2.1. When N ‚â§8 a top-down approach (s = log2(N)) should
always be used, since space and depth both decrease as s increases in the interval
s ‚àà[1..3] (see Table 3 for a numerical example). Circuit depth increases only
when s ‚â•4.
3.2 Experiment
To evaluate the bidirectional method, proof-of-principle experiments were per-
formed on a classical simulator provided by IBM, four superconducting-qubit
based quantum devices provided by IBM, and an ion-trap based quan-
tum device provided by IonQ. These are named as ibmq qasm simulator,
ibmq rome, ibmq santiago, ibmq casablanca, and ibmq jakarta, and IonQ,
respectively. The experiments aim to load the following 8 and 16-dimensional
real input vectors:
(
‚àö
0.03,
‚àö
0.06,
‚àö
0.15,
‚àö
0.05,
‚àö
0.1,
‚àö
0.3,
‚àö
0.2,
‚àö
0.11)
and
(
‚àö
0.01,
‚àö
0.02,
‚àö
0.04,
‚àö
0.02,
‚àö
0.07,
‚àö
0.08,
‚àö
0.04,
‚àö
0.01,
‚àö
0.08,
‚àö
0.02,
‚àö
0.21,
‚àö
0.09,
‚àö
0.12,
‚àö
0.08,
‚àö
0.05,
‚àö
0.06).
Three configurations of the bidirectional method are compared, namely
top-down (s = n), bottom-up (s = 1), and sublinear (s = ‚åàn/2‚åâ). The first
case uses the least number of qubits Ow(log2(N)) and maximum depth Od(N).
In the second configuration, depth is minimum Od(log2
2(N)) and the number
of qubits is maximum Ow(N). The last configuration uses the best trade-
off between the quantum circuit depth and width and achieves the sublinear
scaling for both. In this case, the quantum circuit depth and width both grow
as O(
‚àö
N).
Table 2 lists the experimental results, presenting the number of runs
per device and dimensionality of the input vector. The ibmq rome and
ibmq santiago devices have only five qubits, and due to this limitation they
are not suitable to encode the 8-dimensional vector with the bottom-up con-
figuration (i.e. s = 1) or to perform sublinear (i.e. s = ‚åàn/2‚åâ) and bottom-up
experiments to encode the 16-dimensional vector (see Corollary 2.1). None of
the quantum devices used in this work has the capacity to run the bottom-up
configuration for the 16-dimensional input vector, which requires at least 15
qubits (i.e. N ‚àí1 qubits).
Figure 7 presents the average output of the experiments with 8 and 16-
dimensional input vectors. The height of blue and red bars is an average value
obtained from a number of repetitions shown in the runs column in Table 2,
and the error bars represent the standard deviation. The height of the yellow
bar is the experimental result averaged over all quantum devices.
93

Springer Nature 2021 LATEX template
14
Configurable sublinear circuits for quantum state preparation
device
N
s
runs
MAE
ibmq qasm simulator
32 qubits
8
1
5
0.0016
2
5
0.0005
3
5
0.0015
16
2
5
0.0010
4
5
0.0010
ibmq rome
5 qubits
8
2
10
0.0577
3
10
0.0429
16
4
5
0.0409
ibmq santiago
5 qubits
8
2
10
0.0464
3
10
0.0233
16
4
10
0.0225
ibmq casablanca
7 qubits
8
1
10
0.0710
2
10
0.0691
3
10
0.0213
ibmq jakarta
7 qubits
8
1
10
0.0594
2
10
0.0497
3
10
0.0289
IonQ
11 qubits
8
1
5
0.0455
2
5
0.0242
3
5
0.0217
16
2
5
0.0261
4
5
0.0107
Table 2: Results of the BDSP experiments that encode N-dimensional input
vectors in the amplitudes of quantum states using a classical simulator and
quantum devices for N = {8, 16}. The acronym MAE stands for mean absolute
error. The bold font indicates the smallest MAE, and hence the best perfor-
mance, among different configurations of s for each device and input vector.
N = 8
N = 16
N = 32
N = 64
s
CNOTs
depth
qubits
CNOTs
depth
qubits
CNOTs
depth
qubits
CNOTs
depth
qubits
1
28
31
7
77
58
15
182
93
31
399
136
63
2
18
24
5
57
51
11
142
86
23
319
129
47
3
10
20
3
41
48
7
110
83
15
255
126
31
4
26
51
4
80
87
9
195
130
19
5
58
114
5
151
158
11
6
122
241
6
Table 3: Exchange between circuit depth, width (qubits), and number of
CNOTs by adjusting the parameter s (split). s can be interpreted as a hyper-
parameter to fine-tune the encoding circuit to hardware characteristics such
as relaxation time, dephasing time, and the CNOT gate error.
Table 3 and Figure 6 show the trade-off between quantum circuit depth,
width and the number of CNOT gates as s is varied for randomly generated
target vectors of various sizes. As expected through the analysis of the number
of CNOT gates and the circuit depth in Tab. 3, the experimental results in
Table 2 and Figure 7 show performance favoring the top-down configuration
(s = n) for small input sizes (N < 64) due to the smaller number of CNOT
gates and the smaller or approximately equal depth of the circuit. The number
of CNOT gates, circuit depth, and number of qubits all decrease as s progresses
to s = 3. The depth starts to increase when s > 3, as previously implied by
94

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
15
(a) 23 amplitudes.
(b) 26 amplitudes.
(c) 210 amplitudes.
(d) 215 amplitudes.
Fig. 6: Exchange between circuit depth, width (number of qubits), and number
of CNOTs to load a 2n-dimensional complex vector into a quantum computer
by adjusting parameter s. The increasing number of CNOTs at lower depths
is a consequence of exchanging computational time for space, given the combi-
nation of distant states. It also indicates an increase in concurrent operations.
Eq. (11). The comparison employs the mean absolute error (MAE). For each
device and input size, the ranking is established where a smaller MAE indicates
better performance (see Table 2).
Data from Table 3 and Figure 6 were obtained using the transpile method
in the Quantum Information Science Kit (Qiskit [49]) version 0.26.2 to decom-
pose the circuits into physical single-qubit gates and the CNOT gate. These
circuits were generated by the bidirectional algorithm with random complex
input vectors. The Python code used in this work for implementing Algorithm
3 employs functions ucry and ucrz from Qiskit. These functions are called uni-
formly controlled rotations (or multiplexers), and the corresponding code in
Qiskit is based on the work of Shende et al. [10].
Note that algorithms 3 and 4 allocate logical qubits as they are needed
without concerning their assignment to physical qubits of the quantum device.
For NISQ devices with limited quantum device coupling map, the logical to
95

Springer Nature 2021 LATEX template
16
Configurable sublinear circuits for quantum state preparation
(a) N = 8 top-down.
(b) N = 8 sublinear.
(c) N = 8 bottom-up.
(d) N = 16 top-down.
(e) N = 16 sublinear.
Fig. 7: Experimental results with 8- and 16-dimensional input vectors. Blue
and red bars indicate respectively the ideal results and the ibm qasm simulator
results. Yellow bars indicate the output average values from the experiments
on all quantum devices. Error bars are the standard deviation.
physical qubit mapping should be optimized in order to minimize the overhead
in the quantum circuit depth and the number of gates.
4 Sparse bidirectional quantum state
preparation
The previous section explained the bidirectional method for encoding data in
the amplitudes of a quantum state consisting of n qubits, where 2n = N is the
total amount of amplitudes of that state. Like other approaches for loading
data in the amplitudes, the method presented in this paper has a classical
preprocessing complexity O(N). Moreover, such algorithms generate circuits
whose spatial and depth costs also depend on N. This dependence on the total
number of state amplitudes makes these methods inappropriate for encoding
sparse input vectors, where the number of non-zero amplitudes M is much
smaller than 2n.
This section presents a sparse variant of the bidirectional algorithm (Pseu-
docode 6). This variant reduces the classical preprocessing complexity to O(M)
through a modification in the construction of the state tree (Pseudocode 7,
Fig. 8b). Knowing that such a tree is binary, one can see that the value of
each node is a combination of the pair at the lower level (see Eq. 4). If the
zero-valued amplitudes are not present at the leafs of the state tree (Fig. 8a),
the nodes at the levels above, whose children are absent, are not constructed
(Fig. 8b). This eliminates some branches from the tree.
As seen in the previous section (Eq. 10), the size of a top-down sub-state
is defined by the parameter s (split), which indicates the number of qubits of
96

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
17
Œ∑1,3
0
0
0
0
0
0
0
Œ∑2,2
Œ∑3,1
x4
x5
0
0
0
(a)
Œ∑1,3
Œ∑2,2
Œ∑3,1
x4
x5
(b)
œÄ
0
Œ±3,1
(c)
Fig. 8: Sparse state preparation. (a) Dense state decomposition of an 8-
dimensional input vector with only data patterns 4 and 5 not equal to zero.
Compare with Figure 1a. (b) Sparse state decomposition generated by Pseu-
docode 7. The information in this sparse decomposition is equal to that
of Figure 8a. (c) Sparse angle tree generated by function angle tree (Pseu-
docode 2) from the sparse state tree shown in Figure 8b. Node Œ±1,3 is always
equal to œÄ because Œ∑1,3 only has a child on the right (Pseudocode 7, Line 16,
and Pseudocode 2, Line 6). Node Œ±2,2 is always zero because Œ∑2,2 only has a
child on the left (Pseudocode 7, Line 25, and Pseudocode 2, Line 2). Node Œ∑3,1
has left and right children, so Œ±3,1 value depends on nodes x4 and x5 (Pseu-
docode 7, Line 20).
the sub-state and, therefore, the number of amplitudes 2s that it can encode.
The number of sub-states depends on two parameters, s (split) and n (total
number of qubits of the complete state, which also indicates the height of
the state tree). With both parameters, the number of sub-states is 2n/2s =
2n‚àís. Therefore, each block of 2s amplitudes from the input vector makes
up a sub-state and that for this sparse version if the block is empty (zero
amplitudes) the sub-state is not necessary for the construction of the complete
state (Fig. 8b). If a sub-state has all nodes eliminated, it is no longer needed
nor represented in the quantum circuit, reducing the necessary space (qubits).
Another consequence of eliminating a sub-state is that the second stage of
the algorithm (bottom-up) will combine a smaller number of states (Eq. 8),
therefore reducing the number of CSWAP operators and the total depth of the
circuit.
The main difference between the dense algorithm (Pseudocode 5) and
the sparse one (Pseudocode 6) is the construction of the state tree. Function
initialize bidirectional differs from function
initialize sparse bidirectional
only
by
Line
3,
replacing
the
state decomposition function call with sparse state decomposition. In
the latter function, the main change that enables sparsity is the introduction
of Line 16 if conditional statement. This statement has three possible out-
comes. The first one (Line 20) occurs when two consecutive nodes of even and
97

Springer Nature 2021 LATEX template
18
Configurable sublinear circuits for quantum state preparation
odd index are present, being identical to the dense case (Pseudocode. 1). The
other two outcomes, first (Line 16) and third (Line 25) conditions, occur when
either of the pair nodes is absent and assumed to have zero amplitude. If the
complete pair is absent, none of the statement outcomes are met, then the
pair is ignored, and the respective parent node is not created. Node indices
are guaranteed to be preserved by Line 12 of Pseudocode 7.
5 Conclusion
Existing state preparation methods, such as top-down and bottom-up
approaches, require at least one quantum circuit resource between depth and
width to grow linearly with the problem size. The BDSP algorithm pre-
sented in this work provides a general framework for configuring the trade-off
between these resources that can be useful to manage them on NISQ devices.
Looking at the state preparation algorithms as a walk on the state tree (see
Section 2.1), the BDSP algorithm constitutes a systematic way to walk in two
opposite directions. Previous methods are based on walking only in one direc-
tion. The bidirectional algorithm comes with a free parameter s ‚àà[1, n] that
determines the balance between the top-down and the bottom-up approaches.
At two extreme cases of setting s = n and s = 1, the top-down and the
bottom-up approaches are respectively recovered. At the equilibrium point
s = ‚åàn/2‚åâ, quadratic reduction in both quantum circuit depth and width can
be achieved. The configuration parameter can be viewed as a hyperparameter
that can tune circuit sizes and the number of CNOT gates according to the
compound of application and hardware properties. The BDSP method is vali-
dated and demonstrated through experiments performed on five real quantum
devices. The experiments behaved as expected, according to the asymptotic
and numerical analyses of the circuit complexity.
A possible future work is to investigate whether the quantum circuit cost
of the DCSP part can be futher reduced. Note that the structure of CSWAP
operations in the DCSP step only depends on the dimensionality of the dataset
N. Hence, the CSWAP operations can be interpreted as a single layer of fixed
operation. Decomposing this fixed operation more efficiently than the naive
application of CSWAP gates would achieve further reduction in the quantum
circuit depth.
Acknowledgments.
This work is based upon research supported by
CNPq (Grant No. 308730/2018-6, No. 306727/2017-0, No. 409415/2018-
9
and
No.
421849/2016-9),
CAPES
‚Äì
Finance
Code
001,
FACEPE
(Grant No. IBPG-0834-1.03/19), National Research Foundation of Korea
(Grant
No.
2019R1I1A1A01050161,
No.
2021M3H3A1038085
and
No.
2022M3E4A1074591), the South African Research Chair Initiative, Grant
No. 64812, of the Department of Science and Innovation and the National
Research Foundation (NRF). Support of the NICIS (National Integrated
Cyberinfrastructure System) e-research grant QICSA is kindly acknowledged.
We acknowledge the use of IBM Quantum services for this work. The views
98

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
19
expressed are those of the authors, and do not reflect the official policy or
position of IBM or the IBM Quantum team.
Competing interests
The authors declare no competing interests.
Data availability
The sites https://github.com/qclib/qclib-papers and https://github.com/
qclib/qclib contain all the data and the software generated during the current
study.
Appendix A
Pseudocode
Pseudocodes 1 to 5 expresses algorithms 1 to 5. Pseudocodes 1 and 2 construct
the tree representations of the state preparation algorithms, namely the state
tree and the angle tree, as described in Section 2.1. Pseudocodes 3 and 4, which
algorithms are explained in sections 2.2 and 2.3, build quantum circuits using
top-down and bottom-up approaches for encoding a complex input vector into
the amplitudes of a quantum state. Pseudocode 5 employs pseudocodes 1 to 4
and expresses the bidirectional state preparation algorithm (Sec. 3, Alg. 5).
Lines 5 and 6 of Pseudocode 5 indicate the two stages of the BDSP
algorithm. Line 5 at function top down tree walk performs the first stage
preparing the sub-states expected by the next stage, equivalent to what would
be generated by bottom-up DCSP up to the tree split, but with the absence of
ancilla due to the top-down approach. Line 6 at function bottom up tree walk
performs the second stage, starting at level s + 1 with the sub-states initial-
ized by the previous stage. Line 3 at function top down tree walk configures
the recurrence so that at split level s it divides the angle tree into 2n‚àís
(number of nodes at split level s) sub-trees of height s, loading all these sub-
trees concurrently using the top-down strategy. Lines 11 and 12 of function
bottom up tree walk initialize 2n‚àís ‚àí1 qubits exclusive to the second stage
with values Ry(Œ±j,v) and Rz(Œªj,v). Then function cswaps combine the states
through CSWAP gates controlled by the nodes above level s. With the tree
described in Fig. 4a and s = 2, the bidirectional procedure (Pseudocode 5)
generates the circuit present in Fig. 4c.
99

Springer Nature 2021 LATEX template
20
Configurable sublinear circuits for quantum state preparation
Pseudocode 1: Generate a state tree by the decomposition of an
amplitude input vector
1 state decomposition(nqubits, data):
input : Number of qubits (nqubits) required to generate a state
with the same length as the data vector (2nqubits).
input : A list (data) representing the state to be decomposed,
with exactly 2nqubits pairs (index, amplitude).
output: Root of the state tree.
// Initialize an auxiliary vector new nodes with data
vector amplitudes
2
new nodes = []
3
for k ‚Üê0 to length(data) ‚àí1 do
4
node.index = data[k].index
5
node.level = nqubits
6
node.amplitude = data[k].amplitude
7
new nodes[k] = node
// Build the state tree
8
for level ‚Üênqubits to 1 step ‚àí1 do
9
nodes = new nodes
10
new nodes = []
11
for k ‚Üê0 to length(nodes) ‚àí1 step 2 do
12
mag =
q
|nodes[k].amplitude|2 + |nodes[k+1].amplitude|2
13
arg = (‚à†nodes[k].amplitude + ‚à†nodes[k+1].amplitude)/2
14
node.index = nodes[k].index // 2
15
node.level = level
16
node.amplitude = mag √ó exp(1j √ó arg)
17
node.left = nodes[k]
18
node.right = nodes[k+1]
19
new nodes[k//2] = node
20
return new nodes[0] ;
// return tree root
100

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
21
Pseudocode 2: Generate a angle tree that will be used to perform
the state preparation
1 angle tree(state tree):
input : An output of state decomposition function (state tree).
output: Tree with angles that will be used to perform the state
preparation.
2
angle y, angle z = 0
3
if state tree.right Ã∏= null then
4
amp = 0
5
if state tree.amplitude Ã∏= 0 then
6
amp = state tree.right.amplitude / state tree.amplitude
7
angle y = 2 arcsin(|amp|)
8
angle z = 2‚à†amp
9
node.index = state tree.index
10
node.level = state tree.level
11
node.angle y = angle y
12
node.angle z = angle z
13
if state tree.left Ã∏= null & !is leaf(state tree.left) then
14
node.left = angle tree(state tree.left)
15
if state tree.right Ã∏= null & !is leaf(state tree.right) then
16
node.right = angle tree(state tree.right)
17
return node
101

Springer Nature 2021 LATEX template
22
Configurable sublinear circuits for quantum state preparation
Pseudocode 3: Construct a circuit that perform a top-down state
preparation for the input vector state. The intended quantum state
is encoded on the output qubits.
1 top down tree walk(angle tree, circuit, start level,
control nodes=null, target nodes=null):
input : An output of angle tree function (angle tree).
input : A quantum circuit to apply the top-down encoding
(circuit).
input : The tree level to start the walk (start level).
input : Used in the recursive calls (control nodes).
input : Used in the recursive calls (target nodes).
output: circuit after the application of the top-down encoding.
2
if angle tree Ã∏= null then
3
if angle tree.level < start level then
4
top down tree walk(angle tree.left, circuit, start level)
5
top down tree walk(angle tree.right, circuit, start level)
6
else
7
angle tree.qubit = add qubit(circuit)
8
if target nodes == null then
9
control nodes = [] ;
// initialize the controls
list
10
target nodes[0] = angle tree ;
// start by the
sub-tree root
11
uniformly controlled rotation(circuit, control nodes,
target nodes)
12
append(control nodes, angle tree) ; // add curr. node to
the controls list
13
target nodes = children(target nodes) ;
// all the
nodes in the next level
14
if angle tree.left Ã∏= null then
15
top down tree walk(angle tree.left, circuit, start level,
control nodes, target nodes)
16
else
17
top down tree walk(angle tree.left, circuit, start level,
control nodes, target nodes)
18 initialize top down(circuit, state):
19
nqubits = log2(length(state))
20
state tree = state decomposition(nqubits, state)
21
angle tree = angle tree(state tree)
22
top down tree walk(angle tree, circuit, 0)
23
output nodes = left view(angle tree)
24
for k ‚Üê0 to nqubits ‚àí1 do
25
output qubits[k] = output nodes[k].qubit
26
return output qubits
102

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
23
Pseudocode 4: Construct a circuit that perform a bottom-up state
preparation for the input vector state. The intended quantum state
is encoded on the output qubits.
1 cswaps(angle tree, circuit):
input : An output of angle tree function (angle tree).
input : A quantum circuit to apply the cswaps (circuit).
output: circuit after the application of the cswaps.
2
left = angle tree.left
3
right = angle tree.right
4
while left Ã∏= null & right Ã∏= null do
5
circuit.cswap(angle tree.qubit, left.qubit, right.qubit)
6
left = left.left
7
right = right.left
8 bottom up tree walk(state tree, circuit, start level):
input : An output of state decomposition function (state tree).
input : A quantum circuit to apply the bottom-up encoding
(circuit).
input : The tree level to start the bottom-up walk (start level).
output: circuit after the application of the bottom-up encoding.
9
if angle tree Ã∏= null & angle tree.level < start level then
10
angle tree.qubit = add qubit(circuit)
11
circuit.ry(angle tree.angle y, angle tree.qubit)
12
circuit.rz(angle tree.angle z, angle tree.qubit)
13
bottom up tree walk(angle tree.left, circuit, start level)
14
bottom up tree walk(angle tree.right, circuit, start level)
15
cswaps(angle tree, circuit)
16 initialize bottom up(circuit, state):
17
nqubits = log2(length(state))
18
state tree = state decomposition(nqubits, state)
19
angle tree = angle tree(state tree)
20
bottom up tree walk(angle tree, circuit, nqubits)
21
output nodes = left view(angle tree)
22
for k ‚Üê0 to nqubits ‚àí1 do
23
output qubits[k] = output nodes[k].qubit
24
return output qubits
103

Springer Nature 2021 LATEX template
24
Configurable sublinear circuits for quantum state preparation
Pseudocode 5: Construct a circuit that perform a bidirectional state
preparation for the input vector state. The intended quantum state
is encoded on the output qubits.
1 initialize bidirectional(circuit, state, split):
2
nqubits = log2(length(state))
3
state tree = state decomposition(nqubits, state)
4
angle tree = angle tree(state tree)
5
top down tree walk(angle tree, circuit, nqubits‚àísplit) ; // stage
1
6
bottom up tree walk(angle tree, circuit, nqubits‚àísplit) ;
// stage 2
7
output nodes = left view(angle tree)
8
for k ‚Üê0 to nqubits ‚àí1 do
9
output qubits[k] = output nodes[k].qubit
10
return output qubits
Pseudocode 6: Construct a circuit that perform a bidirectional state
preparation for the sparse input vector state. The intended quantum
state is encoded on the output qubits.
1 initialize sparse bidirectional(circuit, state, split):
2
nqubits = log2(length(state))
3
state tree = sparse state decomposition(nqubits, state)
4
angle tree = angle tree(state tree)
5
top down tree walk(angle tree, circuit, nqubits‚àísplit) ; // stage
1
6
bottom up tree walk(angle tree, circuit, nqubits‚àísplit) ;
// stage 2
7
output nodes = left view(angle tree)
8
for k ‚Üê0 to nqubits ‚àí1 do
9
output qubits[k] = output nodes[k].qubit
10
return output qubits
104

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
25
Pseudocode 7: Generate a sparse state tree by the decomposition
of an sparse amplitude input vector
1 sparse state decomposition(nqubits, data):
input : Number of qubits (nqubits) required to generate a state
with the same length as the data vector (2nqubits).
input : A list (data) representing the state to be decomposed,
with exactly 2nqubits pairs (index, amplitude).
output: Root of the state tree.
// Initialize an auxiliary vector new nodes with data
vector amplitudes
2
new nodes = []
3
for k ‚Üê0 to length(data) ‚àí1 do
4
node.index = data[k].index
5
node.level = nqubits
6
node.amplitude = data[k].amplitude
7
new nodes[k] = node
// Build the state tree
8
for level ‚Üênqubits to 1 step ‚àí1 do
9
nodes = new nodes
10
new nodes = []
11
for k ‚Üê0 to length(nodes) ‚àí1 step 2 do
12
node.index = nodes[k].index // 2
13
node.level = level
14
mag = |nodes[k].amplitude|
15
arg = (‚à†nodes[k].amplitude)/2
16
if nodes[k].index%2 == 1 then
17
node.left = null
18
node.right = nodes[k]
19
k = k - 1
20
else if (k + 1) < length(nodes) & nodes[k + 1].index ==
nodes[k].index + 1 then
21
mag =
q
|nodes[k].amplitude|2 + |nodes[k+1].amplitude|2
22
arg = (‚à†nodes[k].amplitude+‚à†nodes[k+1].amplitude)/2
23
node.left = nodes[k]
24
node.right = nodes[k+1]
25
else
26
node.left = nodes[k]
27
node.right = null
28
k = k - 1
29
node.amplitude = mag √ó exp(1j √ó arg)
30
new nodes.append(node)
31
return new nodes[0] ;
// return tree root
105

Springer Nature 2021 LATEX template
26
Configurable sublinear circuits for quantum state preparation
References
[1] Feynman, R.P.: Simulating physics with computers. International Journal
of Theoretical Physics 21(6-7), 467‚Äì488 (1982)
[2] Deutsch, D., Jozsa, R.: Rapid solution of problems by quantum computa-
tion. Proceedings of the Royal Society of London. Series A: Mathematical
and Physical Sciences 439(1907), 553‚Äì558 (1992)
[3] Grover, L.K.: A fast quantum mechanical algorithm for database search.
In: Proceedings of the Twenty-eighth Annual ACM Symposium on The-
ory of Computing. STOC ‚Äô96, pp. 212‚Äì219. Association for Computing
Machinery, Philadelphia, Pennsylvania, USA (1996)
[4] Simon, D.R.: On the Power of Quantum Computation. SIAM Journal on
Computing 26(5), 1474‚Äì1483 (1997)
[5] Shor, P.W.: Polynomial-Time Algorithms for Prime Factorization and
Discrete Logarithms on a Quantum Computer. SIAM Review 41(2),
303‚Äì332 (1999)
[6] Aaronson, S.: Read the fine print. Nature Physics 11(4), 291‚Äì293 (2015)
[7] Biamonte, J., Wittek, P., Pancotti, N., Rebentrost, P., Wiebe, N., Lloyd,
S.: Quantum machine learning. Nature 549(7671), 195‚Äì202 (2017)
[8] Leymann, F., Barzen, J.: The bitter truth about gate-based quantum algo-
rithms in the NISQ era. Quantum Science and Technology 5(4), 044007
(2020)
[9] Tang, E.: Quantum principal component analysis only achieves an expo-
nential speedup because of its state preparation assumptions. Phys. Rev.
Lett. 127, 060503 (2021)
[10] Shende, V.V., Bullock, S.S., Markov, I.L.: Synthesis of quantum-logic
circuits. IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems 25(6), 1000‚Äì1010 (2006)
[11] Hogg, T., Huberman, B.A., Williams, C.P.: Phase transitions and the
search problem. Artificial Intelligence 81(1), 1‚Äì15 (1996). Frontiers in
Problem Solving: Phase Transitions and Complexity
[12] Terhal, B.M., Smolin, J.A.: Single quantum querying of a database.
Physical Review A 58(3), 1822‚Äì1826 (1998)
[13] Harrow, A.W., Hassidim, A., Lloyd, S.: Quantum algorithm for linear
systems of equations. Phys. Rev. Lett. 103, 150502 (2009)
106

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
27
[14] Grover, L.K.: Synthesis of Quantum Superpositions by Quantum Com-
putation. Physical Review Letters 85(6), 1334‚Äì1337 (2000)
[15] Sanders, Y.R., Low, G.H., Scherer, A., Berry, D.W.: Black-box quan-
tum state preparation without arithmetic. Phys. Rev. Lett. 122, 020502
(2019)
[16] Wang, S., Wang, Z., Cui, G., Shi, S., Shang, R., Fan, L., Li, W., Wei,
Z., Gu, Y.: Fast black-box quantum state preparation based on linear
combination of unitaries. Quantum Information Processing 20(8), 270
(2021)
[17] Trugenberger, C.A.: Probabilistic quantum memories. Physical Review
Letters 87(6) (2001)
[18] Ventura, D., Martinez, T.: Quantum associative memory. Information
Sciences 124(1), 273‚Äì296 (2000)
[19] Trugenberger, C.A.: Quantum Pattern Recognition. Quantum Informa-
tion Processing 1(6), 471‚Äì493 (2002)
[20] Giovannetti, V., Lloyd, S., Maccone, L.: Quantum random access memory.
Phys. Rev. Lett. 100, 160501 (2008)
[21] Silva, A., Oliveira, W.d., Ludermir, T.: A Weightless Neural Node Based
on a Probabilistic Quantum Memory. In: 2010 Eleventh Brazilian Sympo-
sium on Neural Networks, pp. 259‚Äì264. IEEE, Sao Paulo, Brazil (2010).
ISSN: 2375-0235
[22] de Paula Neto, F.M., da Silva, A.J., de Oliveira, W.R., Ludermir, T.B.:
Quantum probabilistic associative memory architecture. Neurocomputing
351, 101‚Äì110 (2019)
[23] Park, D.K., Petruccione, F., Rhee, J.-K.K.: Circuit-Based Quantum Ran-
dom Access Memory for Classical Data. Scientific Reports 9(1), 3949
(2019)
[24] Zidan, M., Abdel-Aty, A.-H., Khalil, A., Abdel-Aty, M., Eleuch, H.: A
novel efficient quantum random access memory. IEEE Access 9, 151775‚Äì
151780 (2021)
[25] Lloyd, S., Mohseni, M., Rebentrost, P.: Quantum algorithms for super-
vised and unsupervised machine learning. arXiv:1307.0411 [quant-ph]
(2013)
[26] Stoudenmire, E., Schwab, D.J.: Supervised learning with tensor networks.
In: Lee, D., Sugiyama, M., Luxburg, U., Guyon, I., Garnett, R. (eds.)
107

Springer Nature 2021 LATEX template
28
Configurable sublinear circuits for quantum state preparation
Advances in Neural Information Processing Systems, vol. 29, p. 9. Curran
Associates, Inc., Centre Convencions Internacional Barcelona, Barcelona
Spain (2016)
[27] Schuld, M., Fingerhuth, M., Petruccione, F.: Implementing a distance-
based classifier with a quantum interference circuit. EPL (Europhysics
Letters) 119(6), 60002 (2017)
[28] Schuld, M., Petruccione, F.: Supervised Learning with Quantum Comput-
ers, 1st ed. 2018 edn. Quantum Science and Technology. Springer, Cham
(2018)
[29] Benedetti, M., Lloyd, E., Sack, S., Fiorentini, M.: Parameterized quantum
circuits as machine learning models. Quantum Science and Technology
(2019)
[30] Levine, Y., Sharir, O., Cohen, N., Shashua, A.: Quantum Entanglement
in Deep Learning Architectures. Physical Review Letters 122(6), 065301
(2019)
[31] Blank, C., Park, D.K., Rhee, J.-K.K., Petruccione, F.: Quantum classifier
with tailored quantum kernel. npj Quantum Information 6(1), 1‚Äì7 (2020)
[32] Lloyd, S., Mohseni, M., Rebentrost, P.: Quantum principal component
analysis. Nature Physics 10(9), 631‚Äì633 (2014)
[33] Childs, A.M., Kothari, R., Somma, R.D.: Quantum algorithm for systems
of linear equations with exponentially improved dependence on precision.
SIAM Journal on Computing 46(6), 1920‚Äì1950 (2017)
[34] Wossnig, L., Zhao, Z., Prakash, A.: Quantum linear system algorithm for
dense matrices. Phys. Rev. Lett. 120, 050502 (2018)
[35] Rebentrost, P., Steffens, A., Marvian, I., Lloyd, S.: Quantum singular-
value decomposition of nonsparse low-rank matrices. Physical Review A
97(1) (2018)
[36] Mitchell, T.M.: Machine Learning, Nachdr. edn. McGraw-Hill series in
Computer Science. McGraw-Hill, New York (2013)
[37] Ventura, D., Martinez, T.: Initializing the Amplitude Distribution of a
Quantum State. Foundations of Physics Letters 12(6), 547‚Äì559 (1999)
[38] Long, G.-L., Sun, Y.: Efficient scheme for initializing a quantum register
with an arbitrary superposed state. Physical Review A 64(1), 014303
(2001)
108

Springer Nature 2021 LATEX template
Configurable sublinear circuits for quantum state preparation
29
[39] Mottonen, M., Vartiainen, J.J., Bergholm, V., Salomaa, M.M.: Trans-
formation of Quantum States Using Uniformly Controlled Rotations.
Quantum Info. Comput. 5(6), 467‚Äì473 (2005)
[40] Plesch, M., Brukner, C.: Quantum-state preparation with universal gate
decompositions. Physical Review A 83(3), 032302 (2011)
[41] Cortese, J.A., Braje, T.M.: Loading Classical Data into a Quantum
Computer (2018)
[42] Araujo, I.F., Park, D.K., Petruccione, F., da Silva, A.J.: A divide-and-
conquer algorithm for quantum state preparation. Scientific Reports
11(1), 6329 (2021)
[43] Park, D.K., Sinayskiy, I., Fingerhuth, M., Petruccione, F., Rhee, J.-
K.K.: Parallel quantum trajectories via forking for sampling without
redundancy. New Journal of Physics 21(8), 083024 (2019)
[44] Low, G.H., Kliuchnikov, V., Schaeffer, L.: Trading T-gates for dirty qubits
in state preparation and unitary synthesis (2018)
[45] Zoufal, C., Lucchi, A., Woerner, S.: Quantum generative adversarial
networks for learning and loading random distributions. npj Quantum
Information 5(1), 1‚Äì9 (2019)
[46] Kuzmin, V.V., Silvi, P.: Variational quantum state preparation via
quantum data buses. Quantum 4, 290 (2020)
[47] IBM: IBM‚Äôs Roadmap For Scaling Quantum Technology (2020). https:
//research.ibm.com/blog/ibm-quantum-roadmap
[48] Preskill, J.: Quantum Computing in the NISQ era and beyond. Quantum
2, 79 (2018)
[49] Aleksandrowicz, G., et al.: Qiskit: An Open-source Framework for Quan-
tum Computing (2021)
[50] Bergholm, V., Izaac, J., Schuld, M., Gogolin, C., Alam, M.S., Ahmed,
S., Arrazola, J.M., Blank, C., Delgado, A., Jahangiri, S., McKiernan,
K., Meyer, J.J., Niu, Z., Sz¬¥ava, A., Killoran, N.: PennyLane: Automatic
differentiation of hybrid quantum-classical computations (2020)
[51] Bergholm, V., Vartiainen, J.J., M¬®ott¬®onen, M., Salomaa, M.M.: Quantum
circuits with uniformly controlled one-qubit gates. Physical Review A
71(5), 052330 (2005)
109

Approximated quantum-state preparation with entanglement dependent complexity
Israel F. Araujo,1, ‚àóCarsten Blank,2, ‚Ä† Ismael Cesar,1, ‚Ä° and Adenilton J. da Silva1, ¬ß
1Centro de Inform√°tica, Universidade Federal de Pernambuco, 50740-560, Recife, Pernambuco, Brazil
2data cybernetics, 86899, Landsberg am Lech, Germany
Ubiquitous in quantum computing is the step to encode data into a quantum state. This process
is called quantum state preparation, and its complexity for non-structured data is exponential
on the number of qubits. Several works address this problem, for instance, by using variational
methods that train a fixed depth circuit with manageable complexity. These methods have their
limitations as the lack of a back-propagation technique and barren plateaus. This work proposes
an algorithm to reduce state preparation circuit depth by offloading computational complexity to
a classical computer.
The initialized quantum state can be exact or an approximation, and we
show that the approximation is better on today‚Äôs quantum processors than the initialization of the
original state.
We verified through experimental evaluation that the proposed method allows a
more efficient initialization of distributions in a quantum state and approximate loading images for
quantum machine learning tasks.
I.
INTRODUCTION
Quantum devices can execute information process-
ing tasks that classical computers cannot perform effi-
ciently [1].
In some instances, this leads to exponen-
tial advantages in the solution of systems of linear equa-
tions [2] and principal component analysis [3]. Addition-
ally, there are known advantages in Monte-Carlo sam-
pling [4, 5] in which a squared increase of convergence can
be attained. Furthermore, quantum machine learning ap-
plications [6‚Äì8] may exhibit heuristic advantages. For all
these applications, the initialization of a n-qubit quan-
tum state, commonly called quantum state preparation
or initialization, see Fig.1, is an important step in quan-
tum information processing. Encoding a N-dimensional
(complex) vector requires n-qubits with N = 2n and
quantum circuits with O(2n) controlled-NOT (CNOT)
gates [9, 10]; these gates are the building blocks of to-
day‚Äôs quantum computers. Therefore, several works fo-
cus on the development of algorithms that supposes data-
efficient initialization, as all above-mentioned quantum
advantages could be undone when the conversion of clas-
sical data to quantum data becomes a bottleneck.
There are several quantum state preparation algo-
rithms [11‚Äì14] with a lower bound of O(2n) CNOT gates
to prepare an arbitrary quantum state with n qubits.
Attempts to prepare quantum states more efficiently in-
clude a divide-and-conquer strategy that exchanges cir-
cuit depth by circuit width [14, 15], probabilistic ap-
proaches [16, 17], and strategies to initialize approxi-
mated quantum states [18‚Äì20]. Most recently, there are
methods that focus on specific classes of quantum states.
For instance, how to prepare uniform [21], sparse [13] or
probability distribution [18] states. However, there is no
‚àóifa@cin.ufpe.br
‚Ä† blank@data-cybernetics.com
‚Ä° icsa@cin.ufpe.br
¬ß ajsilva@cin.ufpe.br
clear understanding of which classes of quantum states
can be created efficiently.
0100110101101010101010010111
0101101010001001010101110100
0101000010100010110101001010
0101000011110101101010100101
1111011010100111001011110110
0101001000100010110111011110
0101000011110101101010100101
1111011010100111001011110110
1111011010100111001011110110
Classical Data
Quantum Circuit
Translation
Quantum State
FIG. 1: The process of state preparation or
initialization. Classical data is converted into vector
form and a translation process encodes the information
in operations performed on the quantum computer,
commonly encoded by a circuit. Executing this circuit
creates the initial state |Œ®0‚ü©.
Entanglement is one of the quantum resources that
allow the development of more efficient algorithms and
protocols. Its relationship to the algorithmic complex-
ity of a quantum state has been demonstrated in previ-
ous work [22, 23] and plays a key role in many quantum
applications, such as quantum communication, quantum
error correction, and quantum secret sharing [24‚Äì29].
However, the circuit complexity of current algorithms
to create a quantum state do not consider the resource of
entanglement. The main goal of this article is to define
a deterministic state preparation algorithm that creates
circuits with depth as a function of entanglement, and
show that for mapping the classical data into a Noisy
Intermidiate-Scale Quantum (NISQ) device, one indeed
wants to be in the regime of low-entanglement.
Af-
ter finalizing the state preparation, one can increase the
amount of entanglement (exponential in the number of
qubits) by applying unitary evolution. This path could
lead to the solution of the so-called loading problem (LP)
of classical-quantum information processing.
The proposed approach‚Äôs advantage is that it can accel-
erate quantum applications that require the initialization
of quantum states, in particular on noisy devices. Using
110
AP√äNDICE C ‚Äì APPROXIMATED QUANTUM-STATE PREPARATION WITH
ENTANGLEMENT DEPENDENT COMPLEXITY

2
an approximation of the quantum state, the result is that
the error introduced by the approximation is smaller than
the error to encode the original state. The fundamental
cause of this behavior is the difference in the number
of noisy operations necessary between the circuits to en-
code the original versus the approximate state. But also
apart from this obvious advantages in the NISQ-era, the
proposed approach reduces the complexity to initialize a
low-entangled quantum state into fault-tolerant quantum
devices.
The remainder of this paper is organized into four sec-
tions. The main contributions of this work are described
in sections II and III. Section II introduces the Low-Rank
State Preparation (LRSP) algorithm, a modification of
the so-called Plesch and Brukner (PB) algorithm [12].
LRSP algorithm reduces the computational cost when
the input vector has a low Schmidt coefficient. In this
way, the LRSP can be used to initialize general quantum
states and also low rank quantum states.
Section III
introduces the Bounded Approximation Error Algorithm
(BAA), a search algorithm that reduces the circuit depth
of LRSP circuit given an allowable error. Some numer-
ical tools and the connection to the geometric measure
of entanglement are discussed. Section IV presents ex-
perimental results on how probability distributions can
effectively be created and read out from actual pre-NISQ
processors. Also, it shows how an end-to-end quantum
machine learning approach can be improved through ap-
proximations of the initial quantum state.
Section V
summarizes the work and presents perspectives along
with potential future research.
II.
LOW-RANK STATE PREPARATION
ALGORITHM
The proposed Low-Rank State Preparation algorithm
is based on
Plesch and Brukner (PB) state prepara-
tion algorithm [12]. The PB algorithm connects to the
Schmidt-decomposition, given a quantum state |œà‚ü©=
P
j Œªj |j‚ü©, the first step of the algorithm runs a Schmidt
decomposition
|œà‚ü©=
k
X
i=1
œÉi |iA‚ü©|iB‚ü©
(1)
where the state is factored in two quantum subsystems
HA and HB, values œÉi are the Schmidt coefficients,
{|iA‚ü©} ‚ààHA and {|iB‚ü©} ‚ààHB are orthonormal ba-
sis, and 1 ‚â§i ‚â§min(dim(HA), dim(HB)).
The sec-
ond step performs the initialization of the quantum state
P
i œÉi |i‚ü©|0‚ü©in the first quantum register. The objective
of this step is to initialize a state with the Schmidt coef-
ficients. The third step applies ‚åän/2‚åãCNOTs to create
the state P
i œÉi |i‚ü©|i‚ü©. Let U and V be unitaries, where
U |i‚ü©= |iA‚ü©and V T |i‚ü©= |iB‚ü©. The last step of the algo-
rithm applies U in the first register and V T in the second
register. A quick review of the algorithm is schematically
shown in Fig. 2d.
The proposed Low-Rank State Preparation
differs
from PB algorithm when the Schmidt measure m =
‚åàlog2(k)‚åâ< ‚åän/2‚åãand also by the use of isometries. The-
orem 1 establishes the CNOT gates count needed when
a low-rank representation of a state can be found using
the Schmidt decomposition, as well as approximating the
state by truncating the Schmidt coefficients.
Theorem
1
(Low-Rank State Preparation). Given
Eqn. (1) with the Schmidt measure m = ‚åàlog2(k)‚åâthe
low-rank state preparation has a complexity of
condition
CNOT count
0 ‚â§m < nA
O(2m+nB)
m = nA
O(2n)
Proof. Let |œà‚ü©be a n-qubit quantum state with Schmidt
decomposition |œà‚ü©= Pk
i=1 œÉi |iA‚ü©|iB‚ü©where subsystem
HA has nA qubits (1 ‚â§nA ‚â§‚åän/2‚åã), subsystem HB
has nB = n ‚àínA qubits and k is the Schmidt rank (also
known as Schmidt number).
If the Schmidt measure is m = ‚åàlog2(k)‚åâ< nA, the
operator S (Fig. 2a) initializes a state with m qubits
in phase 1 (Fig. 2b and Fig 2c), instead of nA qubits
(Fig. 2d). The second phase requires m CNOT gates, as
they are not needed where the control qubit is |0‚ü©. In
this circuit configuration, m is the Schmidt measure and
quantifies the entanglement between subsystems HA and
HB. Finally, in phases 3 and 4, the matrices U and V T
are isometries 2m‚Äìto‚Äì2nA and 2m‚Äìto‚Äì2nB which require
O(2m+nA) and O(2m+nB) CNOTs.
The number of CNOTs of the complete LRSP circuit
is O(2m+nB) because the cost of the isometry V T (phase
4) dominates the cost of the algorithm (nB ‚â•nA). The
best-case occurs when the bipartition is not entangled
|œà‚ü©= |œàA‚ü©|œàB‚ü©. Therefore, if rank = 1 (m = 0 e-bits)
there are no operations in phase 1 (to encode singular
values), no entanglement between the two subsystems in
phase 2 (since there is 0 e-bits between the subsystems),
and there are one 1‚Äìto‚Äì2nA and one 1‚Äìto‚Äì2nB isometries
in phases 3 and 4 (Fig. 2b) (which is equivalent to two
parallel sub-state preparations in nA and nB qubits). If
all qubits of the state are separable, applying recursively
the same algorithm to prepare the sub-states in phases
3 and 4 generates a circuit without CNOT gates. If the
state is initially separable but not all sub-states of the
recurrence (some qubits are not separable), the cost of
the state preparation is O(2ne), where ne is the number of
qubits of the higher entangled subsystem. The worst case
occurs when m = nA, recovering the O(2n) complexity
of the original PB circuit (Fig. 2).
In the best case (separable states), the LRSP algo-
rithm creates circuits with a constant depth.
In the
worst case, the LRSP algorithm creates circuits with
depth O(2n) and is a competitive algorithm compared
with the state-of-art deterministic state preparation al-
gorithms for general state preparation without auxiliary
111

3
phase 1
phase 2
phase 3
phase 4
|0‚ü©0
S
T
U
|0‚ü©1
|0‚ü©2
V T
|0‚ü©3
control
target
(a) Block diagram
phase 1
phase 2
phase 3
phase 4
|0‚ü©0
Isometry U4√ó1
|0‚ü©1
|0‚ü©2
Isometry V T
4√ó1
|0‚ü©3
(b) m = 0
phase 1
phase 2
phase 3
phase 4
|0‚ü©0
Ry(Œ±0)
Isometry U4√ó2
|0‚ü©1
|0‚ü©2
Isometry V T
4√ó2
|0‚ü©3
(c) m = 1
phase 1
phase 2
phase 3
phase 4
|0‚ü©0
Ry(Œ±0)
Unitary U4√ó4
|0‚ü©1
Ry(Œ±1)
Ry(Œ±2)
|0‚ü©2
Unitary V T
4√ó4
|0‚ü©3
(d) m = 2
FIG. 2: Schematics of the low-rank approximation algorithm (n = 4 and subsystem HA = {0, 1}). (a) Block diagram
circuit. Operator S is responsible for encoding 2nA (nA = n/2) SVD singular values. In this example, operator S
encodes a maximum of four amplitudes (two qubits). Operator T is a sequence of CNOTs, controlled by the first
half of qubits and targeting the second half (one by one). Operators U and V are the two SVD unitaries. For
full-rank (m = nA, in units of e-bits), U and V T are encoded as unitaries of dimension 2nA √ó 2nA. For a lower rank
(m < nA), the operators are encoded as isometries of dimension 2nA √ó 2m. When m = 0 (rank = 1), the isometries
of dimension 2nA √ó 1 are equivalent to amplitude encoding with input vectors of length 2nA. Plesch‚Äôs original work
describes the four individual phases. (b)(c)(d) Detailed views of (a) for rank = 1 (m = 0), rank = 2 (m = 1) and
rank = 4 (full-rank, m = 2). In this example, phase 1 uses M√∂tt√∂nen‚Äôs state preparation but could use any
amplitude encoding algorithm, including the low-rank state preparation algorithm.
qubits. Table I compares LRSP circuit depth and number
of CNOTs with previous state preparation algorithms.
Two experiments were performed. Column (Ent.) shows
results for a random 10-qubit quantum state initializa-
tion, and column (Sep.) for a random separable 10-qubit
quantum state. The LRSP results depend on the choice
of unitary and isometry decompositions. The methods
used are Quantum Shannon Decomposition (QSD) for
unitaries [30], Cosine‚ÄìSine Decomposition (CSD) [31] for
2n‚àí1‚Äìto‚Äì2n isometries, and Column‚Äìby‚ÄìColumn Decom-
position (CCD) for other isometries [31].
A.
Low-Rank Approximation
The LRSP algorithm also allows a low-rank approx-
imation limiting the Schmidt rank in exchange for an
error. The fidelity loss can be used to quantify the loss
by the approximation.
Definition 1. Given the low-rank parameter r, the ap-
Method
Script
Ent.
Sep.
CNOTs Depth CNOTs Depth
Low Rank
[32]
915
1047
0
2
PB [12]
[32]
919
1057
919
1058
Isometry [31]
[33]
1013
4055
1013
3871
Multiplexor [30]
[33]
2026
4064
2026
4064
TABLE I: Depth and number of CNOTs comparison
between LRSP and other state preparation algorithms.
Experiments were performed without circuit
optimization.
proximated state is denoted as
œà(r)E
=
r
X
i=1
œÉi |iA‚ü©|iB‚ü©
(2)
with coefficients for 1 ‚â§r ‚â§k, i.e. œÉj = 0, r < j ‚â§k.
With the LRSP algorithm, it is possible to partially
(r > 1) or completely (r = 1) disentangle subsets
112

4
2
3
4
5
6
7
8
1
3
4
7
1
5
6
8
2
FIG. 3: Schematic of the logical swap of qubits. By
rearranging the qubits it is possible to find a bipartition
such that the bond dimension between the partitions is
small, which means that these partitions are not
strongly entangled. The indices indicate the position of
the qubit in the quantum circuit.
of qubits while the introduced fidelity loss l(r, |œà‚ü©) :=
(1 ‚àí|‚ü®œà, œà(r)‚ü©|2) = Pk
i=r+1 |œÉi|2 scales with the Schmidt
coefficients that are dropped. The possibility of allowing
arbitrary bipartitions ‚Äì with not-necessarily connected
qubits ‚Äì is not as readily obvious. By rearranging sites
(Fig. 3) between partitions of any size within the allowed
range (1 ‚â§nA ‚â§‚åän/2‚åãand nB = n ‚àínA), one can find
the configuration that exhibit a low bond-dimension at
some boundary. It is then possible to approximate with
lower error, potentially disentangling these bipartitions.
One then can recursively apply this approach on the two
resulting partitions separately; a search algorithm with
a given maximal approximation error can then find the
optimal approximation of an arbitrary quantum state.
This Bounded Approximation error Algorithm (BAA) is
applicable to any quantum state of interest, including,
for example, vector encoding for inverting matrices using
HHL [3], loading data into a quantum machine learning
model [6, 7] or using quantum simulation of stochastic
processes [34].
III.
BOUNDED APPROXIMATION
ALGORITHM
By design, the low-rank approximation only applies to
bipartite systems, yet it can be used hierarchically to en-
able the analysis of multipartite quantum systems [35]
by a recursive algorithm. The proposed search algorithm
allows an approximation up to a given error bound lmax ‚Äì
if possible ‚Äì and thus saves the use of CNOT gates while
providing a guarantee of proximity to the original state.
It is a bounded approximation error state preparation
algorithm (BAA) that potentially has a classical expo-
nential run-time with respect to the number of qubits
of the state. As it is a branch-and-bound algorithm us-
ing breadth-first search, the complexity usually converges
faster [36, 37]. The full set of pseudocode which describes
the algorithm is printed in the supplementary informa-
tion. In what follows, we want to outline the core prin-
ciples of the algorithm.
The approximate state preparation algorithm works as
follows. Any (pure) n-qubit quantum state |œà‚ü©will allow
for a total of
B(n) =
‚åän/2‚åã
X
t=1
 
n
t
!
(3)
bipartitions (also called branches), each is written as
b ‚àà[1 . . B(n)] with the Schmidt number bounded by
k(b) = min{dim(Hb
1), dim(Hb
2)}. By letting the low-rank
parameter 1 ‚â§r ‚â§k(b) be r = 1, each bipartition cre-
ates a disentangled pair of smaller states. Combining this
pair by the tensor-product returns an approximation of
the original state. Additionally, it is possible by the com-
plexity analysis of Theorem 1 to predict the number of
CNOT gates saved.
Starting from |œà‚ü©‚ààH, the algorithm is branching into
all possible bipartitions, (Hb
1, Hb
2). Recursively, each par-
tition Hb
i can in turn be branched once again, as long as
Hb
i (i = 1, 2) is not one single qubit or the total fidelity
loss has not exceeded the error bound lmax. In order for
the search-algorithm to work, each node needs to be able
to know the total fidelity loss, the total saved number of
CNOT gates and its partitioned Hilbert spaces. Due to
this structure, the algorithm terminates in the worst case
with an exponential number of steps. These mentioned
properties are summarized.
Lemma 1. The fidelity and the saved CNOT gates of
each branch can be recursively calculated.
A small result with an impact is the fact that the fi-
delity/fidelity loss and CNOT gate savings can be recur-
sively calculated from one branch to another. The lemma
is important for the computation of the search tree in the
BAA algorithm, as it is possible to parallelize it.
Proof. One must show that the total fidelity loss over
several steps in the tree can be recursively calculated. Let
lbp and lbc be the fidelity loss of the parent and child node,
respectively. Then the fidelity of both is (1‚àílbp)(1‚àílbc),
hence ltot = 1 ‚àí(1 ‚àílbp)(1 ‚àílbc). More generally, ltot =
1 ‚àíQ
i(1 ‚àílbi) for a path on the tree b1, . . . , bt.
Proposition 2. The BAA-Algorithm‚Äôs search tree has
n levels, and therefore terminates. The time and space
complexity is exponential in n in its worst case.
When spanning the search tree (see Suppl. Informa-
tion Pseudocode 1), each child of a parent node will be
created by choosing exactly one state and doing exactly
one bipartition. The bipartitions of our focus are the t
qubits vs. the rest ones, where t is defined in Eq. (3).
Say, among the k states of the parent node, #1 is se-
lected to be partitioned, with dim(H1) = n1. The split
113

5
node 6
node 5
node 0
0.3
0.1
0.2
3
1
2
fidelity loss
saved CNOT gates
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
0.3
0.1
0.2
3
1
2
node 1
node 2
node 3
node 4
1
2
3
1
2
3
1
2
3
3
2
1
1
2
3
1
2
3
3
2
1
FIG. 4: An example of a three-qubit state that is disentangled into product states (leaves). It starts with one vector
in the root and then all B(3) = 3 bipartitions are branched off, creating each two states. From there, the larger
subspace has two qubits, so it should have B(2) = 2 branches. But in this case, the second branch is equal to the
complement of the first, so it is redundant and omitted. Each node has a fidelity loss (red column) and the number
of CNOT gates saved (blue column) using the proposed algorithm. The sub-indices of the vectors are the qubit
partitions associated with each state. Adding the weights from root to any leaf gives the total fidelity loss of
‚âà0.307, meaning that the reduced product state to its original state have an overlap of ‚âà0.693, but with a saving
of 4 CNOT gates. The adaptive approximation algorithm goes to ask if we can save some CNOT gates with an
acceptable fidelity loss. If lmax = 0.1, there is the second bipartition from the root node (node 2) that introduces
only a fidelity loss of ‚âà0.058 by simultaneously saving three CNOT gates.
of t qubits vs. rest is done, and in this manner n1 ‚àí1 lev-
els will be traversed until this state has been partitioned
to a tensor product of single qubit states. Meanwhile, all
k ‚àí1 original states were kept as they were. Now the
partition #2 is selected, and in turn takes n2 ‚àí1 steps
to a tensor product of single qubit states. This goes on
with all the remaining k ‚àí2 partitions. So in total, there
are
k
X
l=1
(nl ‚àí1) = n ‚àík
(4)
steps until all k partitions have been partitioned into
tensor products of single qubit Hilbert spaces. As this
is the longest path possible, the BAA algorithm termi-
nates. Now, we show the runtime complexity of the BAA
algorithm.
Lemma 2. Given a k-fold partitioning of H, denotes as
(H1, . . . , Hk), the number of children of this node is
Bk(n) =
k
X
i=1
B(dim Hi)
(5)
As a special case, we see k = 1, which is directly
B(dim H).
Proof. Given k already partitioned subspaces, the search
algorithm selects one of the partitions (Hi, i = 1, . . . , k)
and carries out all B(dim Hi) branches, while leaving all
the other k ‚àí1 original partitions intact. This is then
repeated, so the total number of children this node has
as claimed.
After each step, the number of partitions thus changes
from k 7‚Üík + 1 as one partition is created. Of course,
the sum of all dimensions must be equal to the dimension
of the original Hilbert space n. Thus, each level of the
search tree is identified by the number k of partitions.
The maximum number of levels is therefore always n.
The total number of nodes is then computed as follows.
The
first level
has
exactly
1
node.
The
sec-
ond
level
has
B1(n)
nodes.
The
third
level
has
P
b=1...B1(n) B2(n; b)
and
the
fourth
level
P
b1=1...B1(n)
P
b2=1...B2(n;b1) B3(n; b2)
up
until
the
nth level, we have,
B1(n)
X
b1=1
¬∑ ¬∑ ¬∑
Bn‚àí1(n;bn‚àí2)
X
bn‚àí1=1
Bn(n; bn‚àí1)
(6)
This is clearly exponential in n. A tree of an example
three-qubit state is shown in Fig. 4. With an lmax = 0.1
only one bipartition is possible within this error bound,
and three CNOT gates are saved.
Albeit the fact that the BAA algorithm uses low-rank
approximations with r = 1 to fully disentangle the bipar-
114

6
titions (Fig. 2 and Fig. 4), it is possible to include low-
rank approximations with r > 1 when complete disentan-
glement is no longer within lmax. This allows fine-tuning
the partial disentanglement of states, as each value of
the parameter r may achieve reductions in the number
of CNOTs that would not be possible with the original
approach, producing additional branches from the tree
nodes.
Therefore, this advantage comes with a larger
search space, and increases the cost of the algorithm.
While the proposed approximate state preparation al-
gorithm reduces the quantum circuit complexity, the
BAA has an exponential preprocessing cost. The naive
(‚Äúbrute-force‚Äù breadth-first) algorithm is already a solu-
tion for those researchers who need to work on small-
qubit experiments and currently have no alternatives to
an efficient quantum initialization on noisy devices. But
a scalable workaround is necessary. One way is to use a
greedy approach [38, 39] that seeks to reduce the compu-
tational cost, making BAA a useful solution for general
problems.
The greedy strategy proposes that branching from a
node is limited to a qubit-by-qubit analysis, selecting
only one representative of the partitions of size k where
1 ‚â§k ‚â§‚åän/2‚åã. The increment in the partition size is
done by choosing the qubit with the lowest fidelity loss
when removed from the remaining entangled subsystem.
As an example, on a seven qubit state, the best 1 vs. 6,
2 vs. 5 and 3 vs. 4 bipartitions are attempted, and the
best one is selected locally and then propagated in the
recursion. This approach implies an exponential reduc-
tion in the number of bipartition combinations, of which
one is chosen, producing only one path.
The greedy algorithm reduces the search-problem ex-
ponentially, yet this will necessarily reduce its ability to
find a good CNOT reduction. The advantage over the
breadth-first (brute-force) strategy is that it will never
exceed the approximation configured, but the downside is
that the CNOT complexity to attain this approximation
could be far from optimal. We use seven qubit random
circuits [40] of linear depth to generate 1000 quantum
states and apply different strategies and lmax to them. It
is obvious that the greedy strategy performs less well for
low lmax (Fig. 5).
Regarding the approximation quality, both the greedy
and brute-force approaches find approximations that to
each other scatter quite evenly, if lmax is high, this scat-
tering is less pronounced. The search of the best node
will always reject a solution that exceeds the lmax value
and it is always helpful to reduce the fidelity loss, but the
cost of CNOT gates will outgrow the impact on NISQ de-
vices. We can conclude on this survey that the greedy
algorithm will miss optimality for low lmax.
A.
Product State Approximations
In view of treating quantum state approximation, one
could be naturally inclined to ask for the best product
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
brute-force fidelity loss
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
greedy fidelity loss
0
15 30 45 60 75 90 105120135150
brute-force saved CNOTs
0
15
30
45
60
75
90
105
120
135
150
greedy saved CNOTs
0.2
0.4
0.6
0.8
1.0
lmax
0.2
0.4
0.6
0.8
1.0
lmax
FIG. 5: Difference of greedy strategy saved CNOT
gates compared to the brute-force search algorithm
(BAA). The mean difference is an indicator how
effective an approximation really is, and the lower the
difference, the better. The greedy algorithm fares
relatively well when the maximum fidelity is large, but
introduces large inefficiencies when it is low. The most
significant applications are most likely the low loss
regimes, so that the greedy algorithm will need
improvements. The data was created on a simulation
with 1000 randomly initialized states of seven qubits.
state approximation. This is indeed a measure for en-
tanglement, the so-called geometric measure of entangle-
ment. It was first introduced by Shimony [41] and refined
by Barnum & Linden [42]. The definition for this mea-
sure of entanglement is given by
Eg(|œà‚ü©) = min
|œï‚ü©‚à•|œà‚ü©‚àí|œï‚ü©‚à•
(7)
where the minimization is over all states |œï‚ü©that are
product states [35], i.e., |œï‚ü©= ‚äón
l=1
œïl
with each
œïl
being a local state. That this value is a useful measure
of entanglement was shown by Wei et al. [43], it is an
entanglement monotone.
The geometric measure of entanglement is related to
the bounded approximate algorithm (BAA) in the fol-
lowing way. Theoretically, the greatest fidelity loss that
any quantum state can experience under the BAA should
115

7
never be higher than it.
Therefore, the geometric en-
tanglement indicates how far an approximation can get.
This shows that low-entanglement states can be encoded
with little loss as a product state. However, looking at
the BAA algorithm, the sequence of nested SVDs is not
optimal, and there may be resulting product states with
a higher fidelity loss.
The particular case where the BAA partitions are split
in half and only one branch selected is equivalent to the
Hierarchical Tucker Format (HTF) with a binary dimen-
sion tree (called Canonical Dimension Tree) [44].
The
HTF can be used to estimate the maximum possible fi-
delity loss with an error less or equal to ‚àö2n ‚àí3‚à•A ‚àí
Abest‚à•, where Abest is the best approximation of the ten-
sor A, and n is the dimensionality of the problem. The
number of bipartitions performed to estimate the maxi-
mum fidelity loss is linear in the number of qubits. Since
BAA performs the SVD from already truncated tensors,
the cost of HTF is given by Lemma 26 of Ref. [44].
IV.
THE LOADING PROBLEM ON NISQ
DEVICES
The LRSP algorithm (with partitions defined by the
Bounded Approximation Error Algorithm) was designed
to solve a class of problems on NISQ devices, namely
loading data. To solve (or avoid) the loading problem [6],
an approximation of the quantum state that uses less en-
tanglement is created.
In this Section we present two
applications of the LRSP: initialize i) a Probability Dis-
tribution Function ii) images to and end-to-end quantum
machine learning model. In an experimental evaluation,
the approximated circuit created with the LRSP algo-
rithm allows for improvements in both examples.
A.
Experiments on Probability Density Functions
The BAA proves to be efficient when working with
specific classes of quantum states found in the quantum
finance [13, 18, 21]. Indeed, encoding probability distri-
butions on the amplitudes of a 7-qubit quantum state
show that even a modest fidelity loss (‚â§0.02) results in
a significant reduction in the number of CNOTs.
To encode a continuous probability density function
(PDF) into the amplitudes of a quantum state it is nec-
essary to construct its discrete analog. In general, this
construction is based on preserving one or more proper-
ties of the continuous distribution [45].
There are several methods by which a discrete random
variable can be constructed from a continuous one. Here
we employ Methodology-V described in Ref. [45] where
the cumulative distribution function (CDF) of a discrete
random variable Y maintains the form of the CDF of
a continuous random variable X. The probability mass
function (PMF) of Y is built from the CDF of X FX(x) =
Pr(X ‚â§x) and is given by
P(Y = k) = FX(k + Œ¥) ‚àíFX(k ‚àí[1 ‚àíŒ¥])
(8)
where 0 < Œ¥ < 1 and k = {0, 1, 2, . . . }.
In the experiments, the interval 0 ‚â§x ‚â§20 is divided
into 27 discretization points. Therefore, the distance be-
tween consecutive points is d = 20/(27 ‚àí1). By choosing
Œ¥ = d/2, the parameters of Eq. (8) are set to
P(Y = k) = FX(k + d/2) ‚àíFX(k ‚àíd/2)
(9)
for k = {0, d, 2d, . . . , (27 ‚àí1)d}.
Equation (9) is used to generate the discrete probabil-
ity distributions analogous to the continuous ones char-
acterized by the normal, log-normal, Laplace and semi-
circular PDFs.
distribution mean variance skewness kurtosis
normal
10.0
4.0
0.0
0.0
log-normal 3.297
18.68
6.185
110.9
Laplace
10.0
8.0
0.0
3.0
semicircular 10.0
16.0
0.0
-1.0
TABLE II: First four moments of the probability
distributions.
Each point of the discretization corresponds to an am-
plitude of the state vector. Note that, given the conser-
vation of probability, each amplitude must be the square
root of the PMF at these points. The result of the dis-
cretization is employed to constructs Figure 6 and Fig-
ure 7.
The state vectors of the distributions were encoded via
BAA and estimated by measurements on actual quantum
devices. All experiments make use of the breadth-first
search (brute force) strategy and partial disentanglement
of states enabled. Each result is an average of 10 runs
with 8192 shots each. The experiments leading to Fig-
ure 6 were performed at points lmax = {0.0, 0.02} using
device ibmq_perth, while those leading to Figure 7 were
performed at points lmax = {0.0, 0.005, 0.01, . . . , 0.055}
using devices ibmq_jakarta and ibmq_casablanca.
When preparing the original states (lmax = 0.0), the
distributions need circuits with 105, 109, 28, and 99
CNOTs, respectively. The difference between the CNOT
numbers is due to the LRSP‚Äôs ability to adjust the com-
plexity of the circuit to the degree of state entanglement.
If a maximum fidelity loss of lmax = 0.02 is allowed,
the effective fidelity loss achieved by the BAA to en-
code the approximate state for each distribution is the
closest possible to lmax, i.e., 0.0089, 0.0159, 0.0081, and
0.0158. With such approximation, the BAA can encode
the first three distributions using only six CNOTs and
the semicircular with three CNOTs. This relatively low
introduced error compared to the extreme reduction of
entangling operations leads to better results in terms
of mean-absolute-error (MAE). Indeed, when executing
116

8
log-normal
normal
Laplace
semi-circular
pre-NISQ
Ideal
Original
Approximation
(a)
(b)
(c)
(d)
(e)
(f)
(g)
(h)
FIG. 6: Visualization of probability distributions encoded on the amplitudes of a 7-qubit quantum state. (a)-(d)
Ideal values of the exact (green line) and approximate (blue line) distributions. (e)-(h) Values of the exact and
approximate distributions encoded via BAA and estimated by measurements on ibm_perth device. In the actual
device, the encoding of the approximations performs closer to the ideal (black dotted line) than the exact
distribution encoding. Each result is an average of 10 runs with 8192 shots.
0.0
0.005
0.01
0.015
0.02
0.025
0.03
0.035
0.04
0.045
0.05
0.055
maximum fidelity loss
(a)
(b)
0.00
0.01
0.02 0.03
0.04 0.05
maximum fidelity loss
ibmq_jakarta
ibmq_casablanca
simulation
mean absolute error
ideal
ibmq_jakarta
FIG. 7: BAA experimental results with a 7-qubit log-normal state on two IBM quantum devices (ibmq_jakarta &
ibmq_casablanca), with a geometric entanglement of ‚âà0.0534. (a) Several approximations in ascending order show
that the exact state preparation fails. All subsequent approximations decrease the MAE until lmax = 0.035. After
that, it increases until the product-state (at lmax = 0.055) is reached. (b) Comparison between two devices and an
ideal simulation. The highlighted point indicates the lowest MAE achieved by the devices.
an experiment on the ibm_perth, the high number of
CNOTs to initialize the exact state obscure the probabil-
ities whereas the BAA approximation keep distribution
specific features closer to the actual distribution, see Fig-
ures 6(a)‚Äì6(h).
One can also load an approximate probability distri-
bution into a quantum state using Quantum Generative
Adversarial Networks (qGANs) [18]. A Generative Ad-
versarial Network [46] is a machine learning model com-
posed of a neural network pair often referred to as gener-
ator and discriminator. Discriminator and generator net-
works are trained competitively. The generator network
produces random synthetic data and the discriminator
distinguishes real and synthetic data. A preliminary ex-
periment was conducted to load a log-normal PDF into
a noisy 7-qubit quantum device. However, the frequen-
cies returned by the generator are not as approximate
to the target discretized distribution frequencies as the
117

9
0.0
2.5
5.0
7.5   10.0  12.5  15.0  17.5  20.0
0.00
0.02
0.04
0.06
0.08
0.10
fidelity=1.0
fidelity=0.6754
FIG. 8: Comparison between the ideal values of the
exact frequencies for the log-normal distribution (green
line) and the frequencies produced by qGAN using 21
CNOTs (blue line).
ones produced using the BAA method in terms of state
fidelity (See Fig. 8). The qGAN was also applied to other
distributions ‚Äì normal, Laplace, and semicircular. It was
found that these approximations are deviating substan-
tially from expectation, noting at this point that each
qGAN learning protocol takes about 4.5 hours on a GPU
based qiskit aer noiseless simulation. Given this context,
the low-rank state preparation method with the BAA
search provides an efficient and competitive method to
load a PDF into a noisy quantum device.
B.
Experiments on VQC
In quantum machine learning, one of the best-known
applications is to train a parameterized quantum circuit
in order to learn a decision hyperplane [47] and thus be
able to classify binary problems. In this setting, the input
data is encoded by a feature map into a quantum state.
Havlicek et al. [47] have hypothesized that their feature
map has quantum advantage properties, yet any feature
map, including a regular state preparation [12, 30, 48], is
a valid option.
These experiments evaluate the BAA using brute-force
strategy and partial disentanglement of states as a quan-
tum feature map [47] to encode data in the amplitudes
of an entangled state [12, 30, 48].
The accuracy of a
quantum variational classifier (VQC) [47, 49] is used as
a metric to evaluate the state preparation.
The classifier model is a hardware efficient param-
eterized circuit divided into two layers that form a
block [47, 50, 51].
The first layer contains parameter-
ized single qubit rotation gates, followed by the second
with two-qubit entangling gates.
Usually, the block is
repeated to achieve better results [49].
The circuit is
completed with an additional layer of rotations. Multi-
ple measurements are carried on any qubit to approxi-
mate an expectation value. The circuit model TwoLocal
from the Qiskit circuit library was chosen for this work.
It is a fully entangled model composed of Ry, Rz, and
controlled-Z gates with no block repetition.
The Optical Recognition of Handwritten Digits Data
Set was used [52]. A binary dataset with 100 samples was
extracted from the original dataset. The two classes of
the new dataset are 0 and 1, each with 50 samples of 64
attributes. Mean test accuracy is computed on a random
initialization for each feature map configuration.
Qiskit‚Äôs VQC implementation was modified to accept
the BAA encoding as a feature map and used to carry on
the classical-quantum hybrid approach, in which the op-
timization procedure is processed on a classical computer
to determine a set of parameters for the parameterized
quantum circuit [51, 53]. Simulations of the hybrid clas-
sification algorithms were performed using Qiskit‚Äôs Aer
simulator with approximately 4500 circuit executions for
each experiment configuration ‚Äì 1024 shots per execu-
tion.
For the experiments with noisy simulation, the
noisy model and the coupling map were imported from
ibmq_jakarta device. Ten samples of each class of the bi-
nary dataset were used as a test set and the remaining 80
samples (40 for each class) as a training set. As prepara-
tion for amplitude encoding, each data vector element of
the dataset was standardized for a Gaussian around zero
with unit variance, rescaled within the range [0, 1], and
normalized. Our simulation employs the Simultaneous
Perturbation Stochastic Approximation (SPSA) [50] for
the optimization process with a mini-batch size of 1/10
of the training set size.
Ideally, the accuracy should be at a nominal level,
which can be established with a noiseless simulation.
However, the experiment on a NISQ device introduces
noise, reducing the classification accuracy. Still, the BAA
produces better results on a noisy device due to the lower
circuit complexity. Indeed, the reduction of entangling
gates shows that even strong approximations still result
into higher accuracy (Figure 9). For a small training data
set, one can train a variational quantum circuit with low-
rank images, but we suspect that this method will pre-
serve its value for larger training data.
V.
CONCLUSION
With the help of Low-Rank State Preparation algo-
rithms, significant improvements in the complexity of
two-qubit entangling gates can be attained.
The pro-
posed LRSP algorithm exploit this fact by connect-
ing state preparation complexity with the entanglement
structure of the quantum state. This work highlights that
classical data can be rearranged such that the entangle-
ment structure attains an easier to approximate struc-
ture, as can be seen in Figure 3 and Figure 4. This di-
rectly bestows the data with the topological structure of
qubit systems. In particular, by logically swapping qubits
between partitions, one can find more local behavior.
This makes it easier to simulate classically, but also, by
virtue of the above-mentioned circuit designs, less com-
118

10
Repeat l times
(a)
(b)
(c)
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0
20
40
60
80
100
120
# cnot
depth
0.4
0.5
0.6
0.7
0.8
0.9
1.0
ideal
noisy
multiplexor
classification accuracy
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
FIG. 9: Application of the BAA to machine learning problems helps to increase classification accuracy. (a) The
effect of BAA on the input data (digits) for different maximum fidelity loss parameters. (b) The classifier‚Äôs feature
map Uœï encodes the data in the amplitudes of a quantum state using BAA. (c) The bars show the average number
of CNOT gates and circuit depth produced by the multiplexor algorithm [48] and the BAA. Blue and yellow lines
indicate ideal and noisy simulation accuracy results. The classifier delivers the best accuracy at the maximum
fidelity loss of 0.5.
plex to create on a quantum computer. To showcase the
immediate advantages of this approach, we present exam-
ple applications in loading PDF and quantum machine
learning. The experiments with VQC show that BAA
allows adjustment of the input data according to the de-
vice‚Äôs capability to manage entanglement, improving the
classifier‚Äôs performance. Additionally, VQC applications
have the characteristic of loading the same input vector
many times, which amortizes the computational time of
the BAA preprocessing.
Recent approaches for approximating quantum states
use variational quantum circuits in which parameterized
single qubit and entangling operations are intertwined
and adjusted according to a gradient descent method
while minimizing/maximizing a loss function, usually
taken from the measurement output of an experiment.
In particular noteworthy is the qGAN method [18] and
the AAS method [19] which have been proposed as a vi-
able alternative to standard state preparation in order to
achieve good results in the NISQ era. These methods try
to emulate local-interaction Hamiltonians, and as such
they in theory must be able to converge to the desired
quantum state. We found in a preliminary comparison
that the BAA performs better for several reasons. How-
ever, we note that an exhaustive study is necessary, yet is
beyond the scope of this work. To summarize, the BAA
is based on purely classical algorithms being very effi-
cient in today‚Äôs hardware with standard methods to ap-
ply for approximations (instead of a full search, we have
greedy and Monte-Carlo as options) and the method does
not suffer from initial conditions failures (such as barren
plateaus).
This work also leaves some open technical questions.
The BAA algorithm needs to disentangle in the first level
of the tree if it is to succeed to the next. This involves
the existence of a bipartition that will break the system
into two uncorrelated parts. For some quantum states,
this may be too much to ask for.
Even though some
gate-complexity reduction can be attained by the low-
rank state preparation, it seems that this approach may
not exploit the quantum state‚Äôs entanglement topology
to its maximum.
Apart from the advantages that this view of state
preparation for classical data can have for the NISQ-
era, and beyond, there is another promising application,
which is to enhance quantum adiabatic state prepara-
tion [54, 55] by preparing a low-entanglement bounded
approximation error state and find its Hamiltonian for
which it is an eigenvalue and then apply the adiabatic
theorem.
The goal would be to potentially skip spec-
tral gap bottlenecks and therefore make either the state
preparation possible or reduce the adiabatic time signifi-
cantly. In fact, a possible way forward could be to reach
high-entanglement states by this approach. It remains
unclear how this could actually be achieved, but the ap-
plications would be obviously beneficial.
ACKNOWLEDGMENTS
This research is supported by Conselho Nacional de
Desenvolvimento Cient√≠fico e Tecnol√≥gico - CNPq, Co-
ordena√ß√£o de Aperfei√ßoamento de Pessoal de N√≠vel Su-
perior (CAPES), and Funda√ß√£o de Amparo √† Ci√™ncia e
Tecnologia do Estado de Pernambuco - FACEPE. We
acknowledge the use of IBM Quantum services for this
work. The views expressed are those of the authors, and
do not reflect the official policy or position of IBM or the
IBM Quantum team.
119

11
DATA AVAILABILITY
The sites https://github.com/qclib/qclib-papers
and https://github.com/qclib/qclib contain all the
data and the software generated during the current study.
[1] F. Arute, K. Arya, R. Babbush, D. Bacon, J. C. Bardin,
R. Barends, R. Biswas, S. Boixo, F. G. Brandao, D. A.
Buell, et al., Quantum supremacy using a programmable
superconducting processor, Nature 574, 505 (2019).
[2] A. W. Harrow, A. Hassidim, and S. Lloyd, Quantum al-
gorithm for linear systems of equations, Physical review
letters 103, 150502 (2009).
[3] S. Lloyd, M. Mohseni, and P. Rebentrost, Quantum prin-
cipal component analysis, Nature Physics 10, 631 (2014).
[4] A. Montanaro, Quantum speedup of Monte Carlo meth-
ods, Proceedings of the Royal Society A: Mathematical,
Physical and Engineering Sciences 471, 20150301 (2015),
1504.06987.
[5] P. Rebentrost, B. Gupt, and T. R. Bromley, Quantum
computational finance:
Monte Carlo pricing of finan-
cial derivatives, Physical Review A 98, 022321 (2018),
1805.00109.
[6] J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost,
N. Wiebe, and S. Lloyd, Quantum machine learning, Na-
ture 549, 195 (2017).
[7] M. Schuld and F. Petruccione, Supervised Learning with
Quantum Computers, 1st ed. (Springer Publishing Com-
pany, Incorporated, 2018).
[8] C. Blank, D. K. Park, J.-K. K. Rhee, and F. Petruc-
cione, Quantum classifier with tailored quantum kernel,
npj Quantum Information 6, 41 (2020).
[9] S. Aaronson, Read the fine print, Nature Physics 11, 291
(2015).
[10] F. Leymann and J. Barzen, The bitter truth about gate-
based quantum algorithms in the NISQ era, Quantum
Science and Technology 5, 044007 (2020).
[11] V. Bergholm, J. J. Vartiainen, M. M√∂tt√∂nen, and M. M.
Salomaa, Quantum circuits with uniformly controlled
one-qubit gates, Physical Review A 71, 052330 (2005).
[12] M. Plesch and ƒå. Brukner, Quantum-state preparation
with universal gate decompositions, Physical Review A
83, 032302 (2011).
[13] E. Malvetti, R. Iten, and R. Colbeck, Quantum circuits
for sparse isometries, Quantum 5, 412 (2021).
[14] I. F. Araujo, D. K. Park, F. Petruccione, and A. J.
da Silva, A divide-and-conquer algorithm for quantum
state preparation, Scientific Reports 11, 6329 (2021).
[15] I. F. Araujo, D. K. Park, T. B. Ludermir, W. R. Oliveira,
F. Petruccione, and A. J. da Silva, Configurable sublinear
circuits for quantum state preparation, arXiv preprint
arXiv:2108.10182 (2021).
[16] X.-M. Zhang, M.-H. Yung, and X. Yuan, Low-depth
quantum state preparation, Phys. Rev. Research 3,
043200 (2021).
[17] D. K. Park, F. Petruccione, and J.-K. K. Rhee, Circuit-
based quantum random access memory for classical data,
Scientific Reports 9, 3949 (2019).
[18] C. Zoufal, A. Lucchi, and S. Woerner, Quantum genera-
tive adversarial networks for learning and loading random
distributions, npj Quantum Information 5, 103 (2019).
[19] K. Nakaji, S. Uno, Y. Suzuki, R. Raymond, T. Onodera,
T. Tanaka, H. Tezuka, N. Mitsuda, and N. Yamamoto,
Approximate amplitude encoding in shallow parameter-
ized quantum circuits and its application to financial
market indicator (2021).
[20] G. Marin-Sanchez, J. Gonzalez-Conde, and M. Sanz,
Quantum algorithms for approximate function loading
(2021).
[21] F. Mozafari, H. Riener, M. Soeken, and G. De Micheli,
Efficient boolean methods for preparing uniform quan-
tum states, IEEE Transactions on Quantum Engineering
2, 1 (2021).
[22] C. E. Mora and H. J. Briegel, Algorithmic complexity of
quantum states, International Journal of Quantum Infor-
mation 04, 715 (2006).
[23] C. E. Mora and H. J. Briegel, Algorithmic complexity
and entanglement of quantum states, Phys. Rev. Lett.
95, 200503 (2005).
[24] R. Raussendorf and H. J. Briegel, A one-way quantum
computer, Phys. Rev. Lett. 86, 5188 (2001).
[25] J. T. Barreiro,
P. Schindler,
O. G√ºhne,
T. Monz,
M. Chwalla, C. F. Roos, M. Hennrich, and R. Blatt, Ex-
perimental multiparticle entanglement dynamics induced
by decoherence, Nature Physics 6, 943 (2010).
[26] A. R. Calderbank and P. W. Shor, Good quantum error-
correcting codes exist, Phys. Rev. A 54, 1098 (1996).
[27] A. Steane, Multiple-particle interference and quantum er-
ror correction, Proceedings of the Royal Society of Lon-
don. Series A: Mathematical, Physical and Engineering
Sciences 452, 2551 (1996).
[28] R. Cleve, D. Gottesman, and H.-K. Lo, How to share a
quantum secret, Phys. Rev. Lett. 83, 648 (1999).
[29] W. D√ºr and J. I. Cirac, Multiparty teleportation, Journal
of Modern Optics 47, 247 (2000).
[30] V. V. Shende, S. S. Bullock, and I. L. Markov, Syn-
thesis of quantum-logic circuits, IEEE Transactions on
Computer-Aided Design of Integrated Circuits and Sys-
tems 25, 1000 (2006).
[31] R. Iten, R. Colbeck, I. Kukuljan, J. Home, and M. Chri-
standl, Quantum circuits for isometries, Physical Review
A 93, 032318 (2016).
[32] I. F. Araujo, C. Blank, A. da Silva, I. Cesar, and L. Silva,
Quantum computing library (qclib), https://github.
com/qclib/qclib (2022).
[33] G.
Aleksandrowicz,
T.
Alexander,
P.
Barkoutsos,
L. Bello, et al., Qiskit: An Open-source Framework for
Quantum Computing (2019).
[34] C. Blank, D. K. Park, and F. Petruccione, Quantum-
enhanced analysis of discrete stochastic processes, npj
Quantum Information 7, 1 (2021).
[35] P. Teng, Accurate calculation of the geometric measure of
entanglement for multipartite quantum states, Quantum
Information Processing 16, 181 (2017), 1609.02076.
120

12
[36] K. Mehlhorn and P. Sanders, Algorithms and data struc-
tures: the basic toolbox (Springer, Berlin, 2008).
[37] S. S. Skiena, The algorithm design manual, 2nd ed.
(Springer, London, 2008) oCLC: ocn228582051.
[38] G. L. Nemhauser, L. A. Wolsey, and M. L. Fisher, An
analysis of approximations for maximizing submodular
set functions‚Äîi, Mathematical Programming 14, 265
(1978).
[39] T. H. Cormen, ed., Introduction to algorithms, 3rd
ed.
(MIT
Press,
Cambridge,
Mass,
2009)
oCLC:
ocn311310321.
[40] A. Bouland, B. Fefferman, C. Nirkhe, and U. Vazirani,
On the complexity and verification of quantum ran-
dom circuit sampling, Nature Physics 15, 159 (2019),
1803.04402.
[41] A. Shimony, Degree of Entanglement, Annals of the New
York Academy of Sciences 755, 675 (1995).
[42] H. Barnum and N. Linden, Monotones and invariants
for multi-particle quantum states, Journal of Physics
A: Mathematical and General 34, 6787 (2001), quant-
ph/0103155.
[43] T.-C. Wei and P. M. Goldbart, Geometric measure of en-
tanglement and applications to bipartite and multipartite
quantum states, Physical Review A 68, 042307 (2003),
quant-ph/0307219.
[44] L. Grasedyck, Hierarchical singular value decomposition
of tensors, SIAM J. Matrix Anal. Appl. 31, 2029‚Äì2054
(2010).
[45] S. Chakraborty, Generating discrete analogues of contin-
uous probability distributions-a survey of methods and
constructions, Journal of Statistical Distributions and
Applications 2, 6 (2015).
[46] I. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio,
Generative adversarial nets, Advances in neural informa-
tion processing systems 27 (2014).
[47] V. Havl√≠ƒçek, A. D. C√≥rcoles, K. Temme, A. W. Harrow,
A. Kandala, J. M. Chow, and J. M. Gambetta, Super-
vised learning with quantum-enhanced feature spaces,
Nature 567, 209 (2019).
[48] M. M√∂tt√∂nen, J. J. Vartiainen, V. Bergholm, and M. M.
Salomaa, Transformation of quantum states using uni-
formly controlled rotations, Quantum Information &
Computation 5, 467 (2005).
[49] M. Schuld, A. Bocharov, K. M. Svore, and N. Wiebe,
Circuit-centric quantum classifiers, Phys. Rev. A 101,
032308 (2020).
[50] A. Kandala, A. Mezzacapo, K. Temme, M. Takita,
M. Brink, J. M. Chow, and J. M. Gambetta, Hardware-
efficient
variational
quantum
eigensolver
for
small
molecules and quantum magnets, Nature 549, 242
(2017).
[51] N. Moll, P. Barkoutsos, L. S. Bishop, J. M. Chow,
A. Cross, D. J. Egger, S. Filipp, A. Fuhrer, J. M.
Gambetta, M. Ganzhorn, A. Kandala, A. Mezzacapo,
P. M√ºller, W. Riess, G. Salis, J. Smolin, I. Tavernelli,
and K. Temme, Quantum optimization using variational
algorithms on near-term quantum devices, Quantum Sci-
ence and Technology 3, 030503 (2018).
[52] E. Alpaydin and C. Kaynak, Cascading classifiers, Ky-
bernetika 34, 369 (1998).
[53] J. R. McClean, J. Romero, R. Babbush, and A. Aspuru-
Guzik,
The
theory
of
variational
hybrid
quantum-
classical algorithms, New Journal of Physics 18, 023023
(2016).
[54] T. Albash and D. A. Lidar, Adiabatic quantum compu-
tation, Reviews of Modern Physics 90, 015002 (2018),
1611.04471.
[55] L. Veis and J. Pittner, Adiabatic state preparation study
of methylene, The Journal of Chemical Physics 140,
214111 (2014), 1401.3186.
121

Approximated quantum-state preparation with entanglement
dependent complexity ‚Äì Supplementary Information
Israel F. Araujo‚àó1, Carsten Blank‚Ä†2, Ismael Cesar‚Ä°1, and Adenilton J. da Silva1
1Centro de Inform¬¥atica, Universidade Federal de Pernambuco, 50740-560, Recife,
Pernambuco, Brazil
2data cybernetics, 86899, Landsberg am Lech, Germany
June 2022
1
Low-rank state preparation
1.1
Algorithm
To achieve low-rank approximation, the corresponding input parameter r is introduced to Algorithm 1 and
can assume values between 1 and 2nA. The following conditional statement is introduced between lines 2 and
3: [If r < rank then rank = r]. Setting r = 1 completely disentangles subsystems HA and HB, which implies
a quadratic reduction in the number of CNOT gates in the circuit to prepare a state when nA = ‚åän/2‚åã.
Additionally, the circuit depth is also reduced.
SUPPLEMENTARY Algorithm 1: Low-rank state preparation algorithm
input : A state vector of 2n amplitudes.
input : A partition of nA qubits (1 ‚â§nA ‚â§‚åän/2‚åã).
output: Encoding quantum circuit.
1 Decompose the state vector using SVD and partition (store unitaries u and vh, and vector s)
2 Set rank equal to the number of non-zero elements of s (rank = count(s Ã∏= 0))
3 Set Schmidt measure m = ‚åàlog2(rank)‚åâ
4 If m < nA, set the number of columns of u, vhT , and s to 2m, otherwise continue
5 Create a quantum circuit with n qubits (n = log2(length(state vector)))
6 If m > 0, encode the normalized vector s on the first m qubits q ‚ààpartition using an amplitude
encoding state preparation algorithm. This step is named Phase 1
7 Perform m CNOT gates between control qubit qc ‚ààpartition and target qt /‚ààpartition. This step is
named Phase 2
8 Encode u on qubits q ‚ààpartition using an algorithm according to its dimension (vector, isometry,
and unitary). This step is named Phase 3
9 Encode vhT on qubits q /‚ààpartition using an algorithm according to its dimension (vector, isometry
or unitary). This step is named Phase 4
10 Output the encoding quantum circuit
‚àóifa@cin.ufpe.br
‚Ä†blank@data-cybernetics.com
‚Ä°icsa@cin.ufpe.br
1
122
AP√äNDICE D ‚Äì APPROXIMATED QUANTUM-STATE PREPARATION WITH
ENTANGLEMENT DEPENDENT COMPLEXITY ‚Äì SUPPLEMENTARY
INFORMATION

2
Bounded Approximation Algorithm
2.1
Pseudocode
Pseudocode 1 constructs the approximation search tree as described in the main document. Pseudocode 2
employs Pseudocode 1 and expresses the bounded approximation algorithm (BAA). Pseudocode 3 builds
quantum circuits using the BAA approach for encoding a complex input vector into the amplitudes of a
quantum state.
Lines 3 of Pseudocode 1 generates all combinations of state partitions from size 1 to ‚åän/2‚åã.
Line 5
separates the indicated partition and creates two new states with a fidelity loss relative to the original state.
Line 7 configures the recurrence so that, if the partition‚Äôs total fidelity loss is less or equal than the maximal
acceptable fidelity loss, a new child node is created. Compared to the previous node, the new one has the
original state replaced by the two separated states.
Line 2 of Pseudocode 2 employs the geometric measure to estimate the maximum possible fidelity loss. If
it is less than the maximal acceptable fidelity loss, the search routine is avoided and the product state used.
Line 3 of Pseudocode 3 initializes each of the state vectors associated to the selected node. Any initializa-
tion algorithm can be used, including the LRSP described in Section 1. The qubits used in each initialization
must follow the previous BAA partitioning. Line 9 of Pseudocode 2 CNOT count must take into account
the algorithm choice.
SUPPLEMENTARY Pseudocode 1: Generate a search tree.
1 build search tree (node, max fidelity loss):
input : Tree node (node) to apply the next search step.
input : The maximal acceptable fidelity loss (max fidelity loss) for the approximation.
// Ignore single-qubit states.
2
for s ‚Üê0 to length(node.states) ‚àí1 do
// Combinations taken k ‚àà[1, ‚åän/2‚åã] at a time without repetition.
// Combinations equal to the complement of previous ones can be
// omitted, as they are redundant.
3
partitions = combinations(node.states[s], k ‚Üê1 to ‚åän/2‚åã)
4
for p ‚Üê0 to length(partitions) ‚àí1 do
// Computes the two states and the fidelity loss after
// disentangling partitions[p].
5
subsystem1, subsystem2, fidelity loss = separate partition(node.states[s], partitions[p])
6
total fidelity loss = 1 - (1 - fidelity loss) √ó (node.total fidelity loss)
7
if total fidelity loss ‚â§max fidelity loss then
// Recursion should not continue for this branch if
// total fidelity loss has reached max fidelity loss.
8
new node.total fidelity loss = total fidelity loss
9
new node.states = node.states
10
new node.states.remove(s)
11
new node.states.add(subsystem1)
12
new node.states.add(subsystem2)
13
node.children.add(new node)
// Call build search tree recurrently for each new node.
14
build search tree (new node, max fidelity loss)
2
123

SUPPLEMENTARY Pseudocode 2: Find the node that will be used to perform the state
preparation.
1 baa (state, max fidelity loss):
input : A state vector (state) to be approximate.
input : The maximal acceptable fidelity loss (max fidelity loss) for the approximation.
output: Node with the best approximation.
// Estimate the maximal fidelity loss.
2
entanglement = geometric measure(state)
3
if entanglement ‚â§max fidelity loss then
4
node.vectors = product state(state)
5
return node
// Start with the complete state.
6
root node.vectors = state
7
build search tree (root node, max fidelity loss)
// Leaf nodes are the ones closest to max fidelity loss for each branch.
8
leaves = list leaves(root node)
// Search the node with the greatest reduction in the number of CNOTs.
// The CNOT count depends on the algorithm chosen to encode the states.
9
best node = search best(leaves)
10
return best node
SUPPLEMENTARY Pseudocode 3: Construct a circuit that performs an approximate state
preparation for the input vector state.
input : A state vector (state) to be encoded.
input : The maximal acceptable fidelity loss (max fidelity loss) for the baa approximation.
output: Circuit with the encoded quantum state.
1 node = baa (state, max fidelity loss)
2 for s ‚Üê0 to length(node.states) ‚àí1 do
// Use any amplitude encoding algorithm.
3
circuit.initialize(node.states[s])
4 return circuit
3
124

125
AP√äNDICE E ‚Äì EMARANHAMENTO E A PREPARA√á√ÉO DE ESTADOS
QU√ÇNTICOS
O emaranhamento √© um dos recursos qu√¢nticos que permitem o desenvolvimento de al-
goritmos e protocolos mais eficientes. Sua rela√ß√£o com a complexidade algor√≠tmica de um
estado qu√¢ntico j√° foi demonstrada em trabalhos anteriores (MORA; BRIEGEL, 2006; MORA;
BRIEGEL, 2005) e desempenha um papel fundamental em muitas aplica√ß√µes qu√¢nticas, tais
como comunica√ß√£o qu√¢ntica, corre√ß√£o de erros qu√¢nticos e compartilhamento de segredos
qu√¢nticos (RAUSSENDORF; BRIEGEL, 2001; BARREIRO et al., 2010; CALDERBANK; SHOR, 1996;
STEANE, 1996; CLEVE; GOTTESMAN; LO, 1999; D√ºR; CIRAC, 2000).
Para entender o significado do emaranhamento na computa√ß√£o qu√¢ntica, um dos resultados
seminais da f√≠sica da mat√©ria condensada √© que sistemas de spin de baixo emaranhamento
podem ser computados classicamente de forma eficiente. Como o modelo da computa√ß√£o
qu√¢ntica de circuitos pode ser representado por tais sistemas de spin, n√£o se pode esperar
vantagens qu√¢nticas quando o baixo emaranhamento est√° presente. Portanto, deve ser poss√≠vel
inicializar eficientemente um estado qu√¢ntico com baixo emaranhamento. De fato, para a
inicializa√ß√£o de dados cl√°ssicos em um estado qu√¢ntico, deseja-se estar no regime de sistemas
de spin de baixo emaranhamento e, ap√≥s finalizar a prepara√ß√£o do estado, ter um aumento
de emaranhamento (exponencial no n√∫mero de qubits) aplicando uma evolu√ß√£o unit√°ria para
alcan√ßar a vantagem qu√¢ntica. O argumento √© que este caminho poderia levar √† solu√ß√£o do
problema do carregamento de informa√ß√µes cl√°ssicas em um sistema qu√¢ntico.
O trabalho Araujo, Blank e Silva (2022) (Se√ß√£o 4.3 e Ap√™ndice C) apresenta um algoritmo
para prepara√ß√£o de estados cuja complexidade √© uma fun√ß√£o do emaranhamento, n√£o apenas
do n√∫mero de qubits. Nele argumentamos ser necess√°rio um quadro completo de todos os
emaranhamentos bipartidos em sistemas de spin unidimensionais para descrever a estrutura
topol√≥gica dos dados. De fato, deve-se reverter o problema e encontrar a disposi√ß√£o do sistema
1D de spin de tal forma que a codifica√ß√£o dos dados cl√°ssicos exiba o m√°ximo poss√≠vel de
intera√ß√µes locais. Isto levar√°, ent√£o, a um baixo emaranhamento e, consequentemente, a uma
redu√ß√£o do custo para a prepara√ß√£o do estado qu√¢ntico. Como esta reordena√ß√£o de spin-qubits
√© um mapeamento um-para-um (uma troca) no espa√ßo Hilbert, essa opera√ß√£o, com algum
cuidado, n√£o afeta o algoritmo principal. A Figura 32 mostra a ideia principal em nota√ß√£o
tensorial (OR√∫S, 2014), onde conex√µes vermelhas espessas significam emaranhamento mais

126
Figura 32 ‚Äì Abordagem esquem√°tica. a) Um vetor de estado qu√¢ntico em nota√ß√£o de rede tensorial √© conver-
tido em um MPS atrav√©s da aplica√ß√£o de uma decomposi√ß√£o de Schmidt entre qubit 1 e qubits
2, 3, 4, 6, 7, 8, e depois qubit 2 vs. 3, 4, 5, 6, 7, 8 e assim por diante. A chamada dimens√£o de
liga√ß√£o √© escolhida durante esse procedimento. A largura da barra de liga√ß√£o significa a dimens√£o
efetiva da liga√ß√£o. b) Reorganizando as qubits √© poss√≠vel encontrar uma biparti√ß√£o tal que cada
parti√ß√£o tenha apenas uma pequena dimens√£o de liga√ß√£o, o que significa que estas parti√ß√µes n√£o
est√£o fortemente emaranhadas.
1
2
3
4
5
6
7
8
MPS
2
3
4
5
6
7
8
1
(a)
2
3
4
5
6
7
8
1
2
3
4
5
6
7
8
1
(b)
Fonte: Elaborada pelo autor (2022)
forte, e conex√µes finas a quase aus√™ncia de emaranhamento.
O mecanismo principal do algoritmo em Araujo, Blank e Silva (2022) explora o n√≠vel de
emaranhamento do vetor de entrada, e eleva a capacidade de preparar uma aproxima√ß√£o de
baixo posto (low-rank) (ECKART; YOUNG, 1936) de um estado qu√¢ntico, usando a decompo-
si√ß√£o de Schmidt. O algoritmo LRSP √© usado como um ve√≠culo algor√≠tmico para conduzir a
prepara√ß√£o de estado low-rank √†s opera√ß√µes qu√¢nticas concretas. Um m√©todo muito similar ao
acima, por Gundlapalli e Lee (2021), explora a estrutura de liga√ß√£o do Matrix Product State
(MPS) (PEREZ-GARCIA et al., 2006) para projetar um circuito qu√¢ntico que prepara um estado
arbitr√°rio de maneira exata ou aproximada. O m√©todo MPS √© bem conhecido na comunidade
da F√≠sica, portanto, queremos destac√°-lo neste ponto.
O MPS tamb√©m √© chamado de train-tensor formulation que tem esse nome dada a repre-
senta√ß√£o
|ùúì‚ü©=
‚àëÔ∏Å
ùëñ1,...,ùëñùëõ
ùê¥[1]
ùëñ1 ùê¥[2]
ùëñ2 ¬∑ ¬∑ ¬∑ ùê¥[ùëõ‚àí1]
ùëñùëõ‚àí1 ùê¥[ùëõ]
ùëñùëõ|ùëñ1ùëñ2 ¬∑ ¬∑ ¬∑ ùëñùëõ‚ü©
onde temos os ùëõsites em uma grade 1D de spin-quits, e ùê¥[ùëö]
ùëñùëö‚ààCùê∑ùëö√óùê∑ùëö+1 com ùê∑1 = ùê∑ùëõ= 1
na chamada formula√ß√£o open boundary condition. O ùê∑ùëö√© chamado de dimens√£o da liga√ß√£o
no site ùëöao ùëö+ 1. Uma aproxima√ß√£o do estado pode ser feita ao permitir apenas uma

127
dada dimens√£o de liga√ß√£o m√°xima no site espec√≠fico ùëö. O MPS pode ser facilmente calculado
atrav√©s da aplica√ß√£o da decomposi√ß√£o de Schmidt entre a biparti√ß√£o {1}/{2, . . . , ùëõ}, e depois
{2}/{3, . . . , ùëõ}, at√© que todos os qubits/sites tenham sido processados.
Usando os algoritmos de Araujo, Blank e Silva (2022) ou Gundlapalli e Lee (2021), √©
poss√≠vel desemaranhar completamente subconjuntos de qubits enquanto o erro de fidelidade
introduzido escala com os coeficientes de Schmidt que s√£o descartados. Entretanto, uma des-
vantagem da abordagem de Gundlapalli e Lee (2021) reside no fato de que a abordagem MPS
padr√£o, por conven√ß√£o, utiliza uma dire√ß√£o pr√©-definida na descomposi√ß√£o de Schmidt. Isto
por si s√≥ n√£o √© um inconveniente, mas ao fixar a base computacional do estado, a possibilidade
de permitir biparti√ß√µes arbitr√°rias ‚Äì com qubits n√£o necessariamente conectados ‚Äì n√£o √© pron-
tamente √≥bvia. O BAA, em conjunto com o LRSP, consegue reorganizar os sites e encontrar
o sistema 1D de spin que exibe uma baixa dimens√£o de liga√ß√£o em alguma fronteira. √â ent√£o
poss√≠vel aproximar com um erro menor, potencialmente desemaranhando as biparti√ß√µes. Pode-
se ent√£o aplicar recursivamente esta abordagem nas duas partes separadamente; um algoritmo
de busca com um dado erro de aproxima√ß√£o m√°xima, como o BAA, pode ent√£o encontrar a
aproxima√ß√£o √≥tima de um estado qu√¢ntico arbitr√°rio.
Tendo em vista o tratamento para a aproxima√ß√£o do estado qu√¢ntico, pode-se estar natu-
ralmente inclinado a buscar a melhor aproxima√ß√£o de estado completamente separado. Esta √©
de fato uma medida para emaranhamento, a chamada medida geom√©trica de emaranhamento.
Foi introduzida pela primeira vez por Shimony (SHIMONY, 1995) e refinada por Barnum &
Linden (BARNUM; LINDEN, 2001). A defini√ß√£o para esta medida de emaranhamento √© dada por
ùê∏ùëî(|ùúì‚ü©) = min
|ùúë‚ü©‚Äñ |ùúì‚ü©‚àí|ùúë‚ü©‚Äñ
(E.1)
onde a minimiza√ß√£o est√° sobre todos os estados |ùúë‚ü©que s√£o estados completamente sepa-
r√°veis (TENG, 2017), ou seja, |ùúë‚ü©= ‚äóùëõ
ùëô=1
‚Éí‚Éí‚Éíùúëùëô‚ü©
com cada
‚Éí‚Éí‚Éíùúëùëô‚ü©
sendo um estado local. Wei e
Goldbart (2003) mostrou que este valor √© uma medida √∫til de emaranhamento.
A medida geom√©trica do emaranhamento est√° relacionada ao algoritmo BAA da seguinte
forma. Teoricamente, a maior perda de fidelidade que qualquer estado qu√¢ntico pode experi-
mentar sob o BAA nunca deve ser superior a ela. Portanto, a medida geom√©trica indica qu√£o
ruim uma aproxima√ß√£o pode ficar. Isto mostra que os estados de baixo emaranhamento podem
ser aproximados como um estado completamente separ√°vel com pouca perda de fidelidade.
Naturalmente, estamos interessados em calcular o estado separ√°vel que maximiza a fideli-

128
dade na tentativa de calcular a medida geom√©trica do emaranhamento. A primeira tentativa
desse tipo publicada na literatura cient√≠fica calcula a medida com a ajuda de um problema de
valor pr√≥prio n√£o linear (WEI; GOLDBART, 2003). Algoritmos mais eficientes foram desenvolvi-
dos nesse √≠nterim. Como foi apontado por Teng (TENG, 2017), pode-se usar a decomposi√ß√£o
de posto tensorial e a decomposi√ß√£o de Tucker (ENR√≠QUEZ; PUCHA≈ÇA; ≈ªYCZKOWSKI, 2015).
O c√°lculo da medida geom√©trica do emaranhamento pode ser feito de forma eficiente
e com alta probabilidade aplicando a decomposi√ß√£o de Tucker de um estado qu√¢ntico |ùúì‚ü©,
interpretando-o como um tensor com cada modo sendo bidimensional e de rank um. O cha-
mado core (KOLDA; BADER, 2009) √© ent√£o simplesmente um n√∫mero complexo ùúÜe a medida
geom√©trica de emaranhamento √© ùê∏(ùúì) = 1 ‚àí|ùúÜ|2 (TENG, 2017). Cada fator √© um vetor, e
eles constituem os estados de um qubit que podem ser preparados juntos como um estado
separ√°vel. O estado criado de tal forma √© ent√£o chamado de |ùúì‚Ä≤‚ü©, e seu overlap com o estado
original √© ‚ü®ùúì|ùúì‚Ä≤‚ü©= ùúÜ.
O caso particular onde as parti√ß√µes do BAA s√£o divididas ao meio e apenas um ramo
selecionado √© equivalente ao Hierarchical Tucker Format (HTF) com uma √°rvore de dimens√£o
bin√°ria (chamada de √Årvore de Dimens√£o Can√¥nica) (GRASEDYCK, 2010). O HTF pode ser
usado para estimar a m√°xima perda de fidelidade poss√≠vel com um erro menor ou igual a
‚àö2ùëõ‚àí3‚Äñùê¥‚àíùê¥best‚Äñ, onde ùê¥best √© a melhor aproxima√ß√£o do tensor ùê¥, e ùëõ√© a dimensionalidade
do problema. O n√∫mero de biparti√ß√µes realizadas para estimar a perda m√°xima de fidelidade
√© linear no n√∫mero de qubits. Como BAA realiza o SVD a partir de tensores j√° truncados, o
custo do HTF √© dado pelo Lemma 26 de Grasedyck (2010).
O objetivo desta se√ß√£o foi conectar a f√≠sica da mat√©ria condensada com a computa√ß√£o
qu√¢ntica e tamb√©m conectar a representa√ß√£o hamiltoniana de baixo emaranhamento/intera√ß√£o
local com a prepara√ß√£o de estados de baixa complexidade, enquanto argumenta que os dados
cl√°ssicos possuem um grau de liberdade na ordena√ß√£o dos spin-quits que a f√≠sica da mat√©ria
condensada n√£o tem. Para ir ainda mais longe, a codifica√ß√£o de dados cl√°ssicos que devem ser
usados no processamento de informa√ß√µes qu√¢nticas podem ser mapeados nas propriedades de
um hamiltoniano, cujas intera√ß√µes dominantes podem ser locais ou n√£o-locais.
Esta se√ß√£o deixa como trabalho futuro verificar se a f√≠sica da mat√©ria condensada possui
ferramentas para encontrar a melhor ordena√ß√£o dos spin-quits na grade 1D, de modo que a
localidade seja aumentada. Atualmente, a melhor estrat√©gia √© uma busca exaustiva, com custo
exponencial no n√∫mero de qubits.

