Seven Sketches in Compositionality:
An Invitation to Applied Category Theory
?
Brendan Fong
David I. Spivak
(Last updated: October 16, 2018)
arXiv:1803.05316v3  [math.CT]  12 Oct 2018


Preface
Category theory is becoming a central hub for all of pure mathematics. It is unmatched
in its ability to organize and layer abstractions, to ﬁnd commonalities between struc-
tures of all sorts, and to facilitate communication between diﬀerent mathematical
communities.
But it has also been branching out into science, informatics, and industry. We believe
that it has the potential to be a major cohesive force in the world, building rigorous
bridges between disparate worlds, both theoretical and practical. The motto at MIT is
mens et manus, Latin for mind and hand. We believe that category theory—and pure
math in general—has stayed in the realm of mind for too long; it is ripe to be brought
to hand.
Purpose and audience
The purpose of this book is to oﬀer a self-contained tour of applied category theory.
It is an invitation to discover advanced topics in category theory through concrete
real-world examples.
Rather than try to give a comprehensive treatment of these
topics—which include adjoint functors, enriched categories, proarrow equipments,
toposes, and much more—we merely provide a taste of each. We want to give readers
some insight into how it feels to work with these structures as well as some ideas about
how they might show up in practice.
The audience for this book is quite diverse: anyone who ﬁnds the above description
intriguing. This could include a motivated high school student who hasn’t seen calculus
yet but has loved reading a weird book on mathematical logic they found at the
library. Or a machine-learning researcher who wants to understand what vector spaces,
design theory, and dynamical systems could possibly have in common. Or a pure
mathematician who wants to imagine what sorts of applications their work might
have. Or a recently-retired programmer who’s always had an eerie feeling that category
theory is what they’ve been looking for to tie it all together, but who’s found the usual
books on the subject impenetrable.
iii

iv
For example, we ﬁnd it something of a travesty that in 2018 there is almost no
introductory material available on monoidal categories. Even beautiful modern intro-
ductions to category theory, e.g. by Riehl or Leinster, do not include anything on this
rather central topic. The only exceptions we can think of are [CK17, Chapter 3] and
[CP10], each of which has a very user-friendly introduction to monoidal categories;
however, readers who are not drawn to physics may not think to look there.
The basic idea of monoidal categories is certainly not too abstract; modern human
intuition seems to include a pre-theoretical understanding of monoidal categories that
is just waiting to be formalized. Is there anyone who wouldn’t correctly understand
the basic idea being communicated in the following diagram?
make
lemon
ﬁlling
make
meringue
separate
egg
ﬁll crust
add
meringue
prepare lemon meringue pie
prepared crust
lemon
butter
sugar
egg
sugar
yolk
white
lemon
ﬁlling
unbaked
lemon pie
meringue
unbaked
pie
Many applied category theory topicsseemtotakemonoidalcategoriesastheirjumping-
oﬀpoint. So one aim of this book is to provide a reference—even if unconventional—for
this important topic.
We hope this book inspires both new visions and new questions. We intend it to be
self-contained in the sense that it is approachable with minimal prerequisites, but not
in the sense that the complete story is told here. On the contrary, we hope that readers
use this as an invitation to further reading, to orient themselves in what is becoming a
large literature, and to discover new applications for themselves.
This book is, unashamedly, our take on the subject. While the abstract structures
we explore are important to any category theorist, the speciﬁc topics have simply
been chosen to our personal taste. Our examples are ones that we ﬁnd simple but
powerful, concrete but representative, entertaining but in a way that feels important
and expansive at the same time. We hope our readers will enjoy themselves and learn
a lot in the process.

v
How to read this book
The basic idea of category theory—which threads through every chapter—is that if
one pays careful attention to structures and coherence, the resulting systems will
be extremely reliable and interoperable.
For example, a category involves several
structures: a collection of objects, a collection of morphisms relating objects, and a
formula for combining any chain of morphisms into a morphism. But these structures
need to cohere or work together in a simple commonsense way: a chain of chains is itself
a long chain, so combining a chain of chains should be the same as combining the long
chain. That’s it!
We will see structures and coherence come up in pretty much every deﬁnition we
give: “here are some things and here are how they ﬁt together.” We ask the reader to
be on the lookout for structures and coherence as they read the book, and to realize
that as we layer abstraction upon abstraction, it is the coherence that makes all the parts
work together harmoniously in concert.
Each chapter in this book is motivated by a real-world topic, such as electrical cir-
cuits, control theory, cascade failures, information integration, and hybrid systems.
These motivations lead us into and through various sorts of category-theoretic con-
cepts. We generally have one motivating idea and one category-theoretic purpose per
chapter, and this forms the title of the chapter, e.g. Chapter 4 is “Collaborative design:
profunctors, categoriﬁcation, and monoidal categories.”
In many math books, the diﬃculty is roughly a monotonically-increasing function
of the page number. In this book, this occurs in each chapter, but not so much in the
book as a whole. The chapters start out fairly easy and progress in diﬃculty.
Page number
Diﬃculty
Most math books
Diﬃculty
Ch. 1
Ch. 2
Ch. 3
Ch. 4
Ch. 5
Ch. 6
Ch. 7
End
This book
The upshot is that if you ﬁnd the end of a chapter very diﬃcult, hope is certainly not
lost: you can start on the next one and make good progress. This format lends itself
to giving you a ﬁrst taste now, but also leaving open the opportunity for you to come
back to the book at a later date and get more deeply into it. But by all means, if you
have the gumption to work through each chapter to its end, we very much encourage
that!
We include about 240 exercises throughout the text, with solutions in Appendix A.
Usually these exercises are fairly straightforward; the only thing they demand is that
the reader changes their mental state from passive to active, rereads the previous

vi
paragraphs with intent, and puts the pieces together. A reader becomes a student when
they work the exercises; until then they are more of a tourist, riding on a bus and
listening oﬀand on to the tour guide. Hey, there’s nothing wrong with that, but we do
encourage you to get oﬀthe bus and make direct contact with the native population
and local architecture as often as you can.
Acknowledgments
Thanks to Jared Briskman, James Brock, Ronnie Brown, Thrina Burana, David Chudz-
icki, Jonathan Castello, Margo Crawford, Fred Eisele, David Ellerman, Cam Fulton,
Bruno Gavranović, Sebastian Galkin, John Garvin, Peter Gates, Juan Manuel Gimeno,
Alfredo Gómez, Leo Gorodinski, Jason Grossman, Jason Hooper, Yuxi Liu, Jesús López,
MTM, Nicolò Martini, Martin MacKerel, Pete Morcos, Nelson Niu, James Nolan, Dan
Oneata, Paolo Perrone, Thomas Read, Rif A. Saurous, Dan Schmidt, Samantha Seaman,
Marcello Seri, Robert Smart, Valter Sorana, Adam Theriault-Shay, Emmy Trewartha,
Sergey Tselovalnikov, Andrew Turner, Joan Vazquez, Daniel Wang, Jerry Wedekind for
helpful comments and conversations.
We also thank our sponsors at the AFOSR; this work was supported by grants
FA9550–14–1–0031 and FA9550–17–1–0058.
Finally, we extend a very special thanks to John Baez for running an online course
on this material and generating tons of great feedback.
Personal note
Our motivations to apply categorytheoryoutsideofmathare, perhapsnaively, grounded
in the hope it can help bring humanity together to solve our big problems. But category
theory is a tool for thinking, and like any tool it can be used for purposes we align with
and those we don’t.
In this personal note, we ask that readers try to use what they learn in this book to
do something they would call “good,” in terms of contributing to the society they’d
want to live in. For example, if you’re planning to study this material with others,
consider speciﬁcally inviting someone from an under-represented minority—a group
that is more highly represented in society than in upper-level math classes—to your
study group. As another example, perhaps you can use the material in this book to
design software that helps people relate to and align with each other.
What’s the
mathematics of a well-functioning society?
The way we use our tools aﬀects all our lives. Our society has seen the results—both
the wonders and the waste—resulting from rampant selﬁshness. We would be honored
if readers found ways to use category theory as part of an eﬀort to connect people, to
create common ground, to explore the cross-cutting categories in which life, society,

vii
and environment can be represented, and to end the ignorance entailed by limiting
ourselves to a singular ontological perspective on anything.
If you do something of the sort, please let us and the community know about it.
Brendan Fong and David I. Spivak
Cambridge MA, October 2018

Contents
1
Generative eﬀects: Orders and adjunctions
1
1.1
More than the sum of their parts
. . . . . . . . . . . . . . . . . . . . . . .
1
1.1.1
A ﬁrst look at generative eﬀects . . . . . . . . . . . . . . . . . . . .
2
1.1.2
Ordering systems . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2
What is order? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.2.1
Review of sets, relations, and functions . . . . . . . . . . . . . . .
7
1.2.2
Preorders
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.2.3
Monotone maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.3
Meets and joins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
1.3.1
Deﬁnition and basic examples
. . . . . . . . . . . . . . . . . . . .
23
1.3.2
Back to observations and generative eﬀects . . . . . . . . . . . . .
26
1.4
Galois connections
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
1.4.1
Deﬁnition and examples of Galois connections . . . . . . . . . . .
27
1.4.2
Back to partitions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
1.4.3
Basic theory of Galois connections . . . . . . . . . . . . . . . . . .
30
1.4.4
Closure operators . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
1.4.5
Level shifting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
1.5
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . .
36
2
Resources: monoidal preorders and enrichment
39
2.1
Getting from a to b
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
2.2
Symmetric monoidal preorders . . . . . . . . . . . . . . . . . . . . . . . .
41
2.2.1
Deﬁnition and ﬁrst examples . . . . . . . . . . . . . . . . . . . . .
41
2.2.2
Introducing wiring diagrams . . . . . . . . . . . . . . . . . . . . .
43
2.2.3
Applied examples
. . . . . . . . . . . . . . . . . . . . . . . . . . .
48
2.2.4
Abstract examples
. . . . . . . . . . . . . . . . . . . . . . . . . . .
52
2.2.5
Monoidal monotone maps . . . . . . . . . . . . . . . . . . . . . . .
55
2.3
Enrichment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
2.3.1
V-categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
2.3.2
Preorders as Bool-categories
. . . . . . . . . . . . . . . . . . . . .
58
viii

CONTENTS
ix
2.3.3
Lawvere metric spaces . . . . . . . . . . . . . . . . . . . . . . . . .
59
2.3.4
V-variations on preorders and metric spaces . . . . . . . . . . . .
63
2.4
Constructions on V-categories . . . . . . . . . . . . . . . . . . . . . . . . .
64
2.4.1
Changing the base of enrichment . . . . . . . . . . . . . . . . . . .
64
2.4.2
Enriched functors . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
2.4.3
Product V-categories . . . . . . . . . . . . . . . . . . . . . . . . . .
66
2.5
Computing presented V-categories with matrix mult. . . . . . . . . . . .
68
2.5.1
Monoidal closed preorders
. . . . . . . . . . . . . . . . . . . . . .
69
2.5.2
Quantales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
2.5.3
Matrix multiplication in a quantale . . . . . . . . . . . . . . . . . .
73
2.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . .
75
3
Databases: Categories, functors, and (co)limits
77
3.1
What is a database? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
3.2
Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
3.2.1
Free categories
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
3.2.2
Presenting categories via path equations
. . . . . . . . . . . . . .
84
3.2.3
Preorders and free categories: two ends of a spectrum
. . . . . .
85
3.2.4
Important categories in mathematics . . . . . . . . . . . . . . . . .
86
3.2.5
Isomorphisms in a category . . . . . . . . . . . . . . . . . . . . . .
88
3.3
Functors, natural transformations, and databases . . . . . . . . . . . . . .
89
3.3.1
Sets and functions as databases . . . . . . . . . . . . . . . . . . . .
89
3.3.2
Functors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
3.3.3
Database instances as Set-valued functors . . . . . . . . . . . . . .
93
3.3.4
Natural transformations . . . . . . . . . . . . . . . . . . . . . . . .
95
3.3.5
The category of instances on a schema . . . . . . . . . . . . . . . .
97
3.4
Adjunctions and data migration . . . . . . . . . . . . . . . . . . . . . . . .
99
3.4.1
Pulling back data along a functor . . . . . . . . . . . . . . . . . . . 100
3.4.2
Adjunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
3.4.3
Left and right pushforward functors, Σ and Π . . . . . . . . . . . 104
3.4.4
Single set summaries of databases . . . . . . . . . . . . . . . . . . 106
3.5
Bonus: An introduction to limits and colimits . . . . . . . . . . . . . . . . 107
3.5.1
Terminal objects and products
. . . . . . . . . . . . . . . . . . . . 107
3.5.2
Limits
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
3.5.3
Finite limits in Set
. . . . . . . . . . . . . . . . . . . . . . . . . . . 111
3.5.4
A brief note on colimits
. . . . . . . . . . . . . . . . . . . . . . . . 113
3.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 114
4
Co-design: profunctors and monoidal categories
117
4.1
Can we build it? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
4.2
Enriched profunctors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
4.2.1
Feasibility relationships as Bool-profunctors . . . . . . . . . . . . 119

x
CONTENTS
4.2.2
V-profunctors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.2.3
Back to co-design diagrams . . . . . . . . . . . . . . . . . . . . . . 124
4.3
Categories of profunctors
. . . . . . . . . . . . . . . . . . . . . . . . . . . 125
4.3.1
Composing profunctors . . . . . . . . . . . . . . . . . . . . . . . . 125
4.3.2
The categories V-Prof and Feas . . . . . . . . . . . . . . . . . . . . 127
4.3.3
Fun profunctor facts: companions, conjoints, collages . . . . . . . 130
4.4
Categoriﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
4.4.1
The basic idea of categoriﬁcation . . . . . . . . . . . . . . . . . . . 133
4.4.2
A reﬂection on wiring diagrams
. . . . . . . . . . . . . . . . . . . 134
4.4.3
Monoidal categories . . . . . . . . . . . . . . . . . . . . . . . . . . 136
4.4.4
Categories enriched in a symmetric monoidal category . . . . . . 138
4.5
Profunctors form a compact closed category . . . . . . . . . . . . . . . . . 139
4.5.1
Compact closed categories . . . . . . . . . . . . . . . . . . . . . . . 141
4.5.2
Feas as a compact closed category . . . . . . . . . . . . . . . . . . 143
4.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 145
5
Signal ﬂow graphs: Props, presentations, & proofs
147
5.1
Comparing systems as interacting signal processors . . . . . . . . . . . . 147
5.2
Props and presentations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
5.2.1
Props: deﬁnition and ﬁrst examples . . . . . . . . . . . . . . . . . 149
5.2.2
The prop of port graphs . . . . . . . . . . . . . . . . . . . . . . . . 151
5.2.3
Free constructions and universal properties . . . . . . . . . . . . . 153
5.2.4
The free prop on a signature
. . . . . . . . . . . . . . . . . . . . . 155
5.2.5
Props via presentations
. . . . . . . . . . . . . . . . . . . . . . . . 158
5.3
Simpliﬁed signal ﬂow graphs . . . . . . . . . . . . . . . . . . . . . . . . . 159
5.3.1
Rigs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
5.3.2
The iconography of signal ﬂow graphs
. . . . . . . . . . . . . . . 160
5.3.3
The prop of matrices over a rig . . . . . . . . . . . . . . . . . . . . 164
5.3.4
Turning signal ﬂow graphs into matrices
. . . . . . . . . . . . . . 165
5.3.5
The idea of functorial semantics
. . . . . . . . . . . . . . . . . . . 168
5.4
Graphical linear algebra
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
5.4.1
A presentation of Mat(R)
. . . . . . . . . . . . . . . . . . . . . . . 168
5.4.2
Aside: monoid objects in a monoidal category . . . . . . . . . . . 172
5.4.3
Signal ﬂow graphs: feedback and more . . . . . . . . . . . . . . . 174
5.5
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 178
6
Circuits: hypergraph categories and operads
181
6.1
The ubiquity of network languages . . . . . . . . . . . . . . . . . . . . . . 181
6.2
Colimits and connection . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
6.2.1
Initial objects
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
6.2.2
Coproducts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
6.2.3
Pushouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188

CONTENTS
xi
6.2.4
Finite colimits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
6.2.5
Cospans . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
6.3
Hypergraph categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
6.3.1
Frobenius monoids . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
6.3.2
Wiring diagrams for hypergraph categories . . . . . . . . . . . . . 200
6.3.3
Deﬁnition of hypergraph category . . . . . . . . . . . . . . . . . . 201
6.4
Decorated cospans
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
6.4.1
Symmetric monoidal functors . . . . . . . . . . . . . . . . . . . . . 204
6.4.2
Decorated cospans . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
6.4.3
Electric circuits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
6.5
Operads and their algebras
. . . . . . . . . . . . . . . . . . . . . . . . . . 211
6.5.1
Operads design wiring diagrams . . . . . . . . . . . . . . . . . . . 211
6.5.2
Operads from symmetric monoidal categories . . . . . . . . . . . 214
6.5.3
The operad for hypergraph props
. . . . . . . . . . . . . . . . . . 216
6.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 218
7
Logic of behavior: Sheaves, toposes, languages
221
7.1
How can we prove our machine is safe? . . . . . . . . . . . . . . . . . . . 221
7.2
The category Set as an exemplar topos . . . . . . . . . . . . . . . . . . . . 224
7.2.1
Set-like properties enjoyed by any topos . . . . . . . . . . . . . . . 225
7.2.2
The subobject classiﬁer . . . . . . . . . . . . . . . . . . . . . . . . . 228
7.2.3
Logic in the topos Set
. . . . . . . . . . . . . . . . . . . . . . . . . 230
7.3
Sheaves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
7.3.1
Presheaves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
7.3.2
Topological spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
7.3.3
Sheaves on topological spaces . . . . . . . . . . . . . . . . . . . . . 236
7.4
Toposes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
7.4.1
The subobject classiﬁer Ωin a sheaf topos . . . . . . . . . . . . . . 243
7.4.2
Logic in a sheaf topos
. . . . . . . . . . . . . . . . . . . . . . . . . 245
7.4.3
Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
7.4.4
Quantiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
7.4.5
Modalities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
7.4.6
Type theories and semantics . . . . . . . . . . . . . . . . . . . . . . 251
7.5
A topos of behavior types
. . . . . . . . . . . . . . . . . . . . . . . . . . . 252
7.5.1
The interval domain . . . . . . . . . . . . . . . . . . . . . . . . . . 252
7.5.2
Sheaves on IR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
7.5.3
Safety proofs in temporal logic . . . . . . . . . . . . . . . . . . . . 255
7.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 256
A Exercise solutions
259
A.1 Solutions for Chapter 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
A.2 Solutions for Chapter 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270

xii
CONTENTS
A.3 Solutions for Chapter 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
A.4 Solutions for Chapter 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
A.5 Solutions for Chapter 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
A.6 Solutions for Chapter 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
A.7 Solutions for Chapter 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
Bibliography
323
Index
331

Chapter 1
Generative eﬀects:
Orders and Galois connections
In this book, we explore a wide variety of situations—in the world of science, engineer-
ing, and commerce—where we see something we might call compositionality. These
are cases in which systems or relationships can be combined to form new systems or
relationships. In each case we ﬁnd category-theoretic constructs—developed for their
use in pure math—which beautifully describe the compositionality of the situation.
This chapter, being the ﬁrst of the book, must serve this goal in two capacities.
First, it must provide motivating examples of compositionality, as well as the relevant
categorical formulations. Second, it must provide the mathematical foundation for the
rest of the book. Since we are starting with minimal assumptions about the reader’s
background, we must begin slowly and build up throughout the book. As a result,
examples in the early chapters are necessarily simpliﬁed. However, we hope the reader
will already begin to see the sort of structural approach to modeling that category
theory brings to the fore.
1.1
More than the sum of their parts
We motivate this ﬁrst chapter by noticing that while many real-world structures are
compositional, the results of observing them are often not. The reason is that ob-
servation is inherently “lossy”: in order to extract information from something, one
must drop the details. For example, one stores a real number by rounding it to some
precision. But if the details are actually relevant in a given system operation, then the
observed result of that operation will not be as expected. This is clear in the case of
roundoﬀerror, but it also shows up in non-numerical domains: observing a complex
system is rarely enough to predict its behavior because the observation is lossy.
A central theme in category theoryisthestudyofstructuresandstructure-preserving
maps. A map f : X →Y is a kind of observation of object X via a speciﬁed relationship
it has with another object, Y. For example, think of X as the subject of an experiment
1

2
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
and Y as a meter connected to X, which allows us to extract certain features of X by
looking at the reaction of Y.
Asking which aspects of X one wants to preserve under the observation f becomes
the question “what category are you working in?.” As an example, there are many
functions f from R to R, and we can think of them as observations: rather than view
x “directly”, we only observe f (x). Out of all the functions f : R →R, only some of
them preserve the order of numbers, only some of them preserve the distance between
numbers, only some of them preserve the sum of numbers, etc. Let’s check in with an
exercise; a solution can be found in Chapter 1.
Exercise 1.1.
Some terminology: a function f : R →R is said to be
(a) order-preserving if x ≤y implies f (x) ≤f (y), for all x, y ∈R;1
(b) metric-preserving if |x −y|  | f (x) −f (y)|;
(c) addition-preserving if f (x + y)  f (x) + f (y).
For each of the three properties deﬁned above—call it foo—ﬁnd an f that is foo-
preserving and an example of an f that is not foo-preserving.
♦
In category theory we want to keep control over which aspects of our systems are
being preserved under various observations. As we said above, the less structure is
preserved by our observation of a system, the more “surprises” occur when we observe
its operations. One might call these surprises generative eﬀects.
In using category theory to explore generative eﬀects, we follow the basic ideas
from work by Adam [Ada17]. He goes much more deeply into the issue than we can
here; see Section 1.5. But as mentioned above, we must also use this chapter to give an
order-theoretic warm-up for the full-ﬂedged category theory to come.
1.1.1
A ﬁrst look at generative eﬀects
To explore the notion of a generative eﬀect we need a sort of system, a sort of observa-
tion, and a system-level operation that is not preserved by the observation. Let’s start
with a simple example.
A simple system.
Consider three points; we’ll call them •, ◦and ∗. In this example, a
system will simply be a way of connecting these points together. We might think of our
points as sites on a power grid, with a system describing connection by power lines, or
as people susceptible to some disease, with a system describing interactions that can
lead to contagion. As an abstract example of a system, there is a system where • and ◦
1We are often taught to view functions f : R →R as plots on an (x, y)-axis, where x is the domain
(independent) variable and y is the codomain (dependent) variable. In this book, we do not adhere to
that naming convention; e.g. in Exercise 1.1, both x and y are being “plugged in” as input to f . As an
example consider the function f (x)  x2. Then f being order-preserving would say that for any x, y ∈R,
if x ≤y then x2 ≤y2; is that true?

1.1. MORE THAN THE SUM OF THEIR PARTS
3
are connected, but neither are connected to ∗. We shall draw this like so:
•
∗
◦
Connections are symmetric, so if a is connected to b, then b is connected to a. Connec-
tions are also transitive, meaning that if a is connected to b, and b is connected to c, then
a is connected to c; that is, all a, b, and c are connected. Friendship is not transitive—my
friend’s friend is not necessarily my friend—but possible communication of a concept
or a disease is.
Here we depict two more systems, one in which none of the points are connected,
and one in which all three points are connected.
•
∗
◦
•
∗
◦
There are ﬁve systems in all, and we depict them just below.
Now that we have deﬁned the sort of system we want to discuss, suppose that Alice
is observing this system. Her observation of interest, which we call Φ, extracts a single
feature from a system, namely whether the point • is connected to the point ∗; this
is what she wants to know. Her observation of the system will be an assignment of
either true or false; she assigns true if • is connected to ∗, and false otherwise. So
Φ assigns the value true to the following two systems:
•
∗
◦
•
∗
◦
and Φ assigns the value false to the three remaining systems:
•
∗
◦
•
∗
◦
•
∗
◦
(1.2)
The last piece of setup is to give a sort of operation that Alice wants to perform on
the systems themselves. It’s a very common operation—one that will come up many
times throughout the book—called join. If the reader has been following the story arc,
the expectation here is that Alice’s connectivity observation will not be compositional
with respect to the operation of system joining; that is, there will be generative eﬀects.
Let’s see what this means.

4
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Joining our simple systems.
Joining two systems A and B is performed simply by
combining their connections. That is, we shall say the join of systems A and B, denote
it A ∨B, has a connection between points x and y if there are some points z1, . . . , zn
such that each of the following are true in at least one of A or B: x is connected to z1,
zi is connected to zi+1, and zn is connected to y. In a three-point system, the above
deﬁnition is overkill, but we want to say something that works for systems with any
number of elements. The high-level way to say it is “take the transitive closure of
the union of the connections in A and B.” In our three-element system, it means for
example that
•
∗
◦
∨
•
∗
◦

•
∗
◦
and
•
∗
◦
∨
•
∗
◦

•
∗
◦
(1.3)
Exercise 1.4.
What is the result of joining the following two systems?
11•
12•
13•
21•
22•
23•
11•
12•
13•
21•
22•
23•
∨
♦
We are now ready to see the generative eﬀect. We don’t want to build it up too
much—this example has been made as simple as possible—but we will see that Alice’s
observation fails to preserve the join operation. We’ve been denoting her observation—
measuring whether • and ∗are connected—by the symbol Φ; it returns a boolean result,
either true or false.
We see above in Eq. (1.2) that Φ(
•
∗
◦)  Φ(
•
∗
◦)  false: in both cases • is not connected
to ∗. On the other hand, when we join these two systems as in Eq. (1.3), we see that
Φ(
•
∗
◦∨
•
∗
◦)  Φ(
•
∗
◦)  true: in the joined system, • is connected to ∗. The question that
Alice is interested in, that of Φ, is inherently lossy with respect to join, and there is no
way to ﬁx it without a more detailed observation, one that includes not only ∗and •
but also ◦.
While this was a simple example, it should be noted that whether the potential for
such eﬀects exist—i.e. determining whether an observation is operation-preserving—
can be incredibly important information to know. For example, Alice could be in charge
of putting together the views of two local authorities regarding possible contagion
between an infected person • and a vulnerable person ∗. Alice has noticed that if they

1.1. MORE THAN THE SUM OF THEIR PARTS
5
separately extract information from their raw data and combine the results, it gives a
diﬀerent answer than if they combine their raw data and extract information from it.
1.1.2
Ordering systems
Category theory is all about organizing and layering structures. In this section we
will explain how the operation of joining systems can be derived from a more basic
structure: order. We will see that while joining is not preserved by Alice’s connectivity
observation Φ, order is.
To begin, we note that the systems themselves are ordered in a hierarchy. Given
systems A and B, we say that A ≤B if, whenever x is connected to y in A, then x is
connected to y in B. For example,
•
∗
◦
≤
•
∗
◦
This notion of ≤leads to the following diagram:
•
∗
◦
•
∗
◦
•
∗
◦
•
∗
◦
•
∗
◦
(1.5)
where an arrow from system A to system B means A ≤B. Such diagrams are known
as Hasse diagrams.
As we were saying above, the notion of join is derived from this order. Indeed for
any two systems A and B in the Hasse diagram (1.5), the joined system A ∨B is the
smallest system that is bigger than both A and B. That is, A ≤(A ∨B) and B ≤(A ∨B),
and for any C, if A ≤C and B ≤C then (A ∨B) ≤C. Let’s walk through this with an
exercise.
Exercise 1.6.

6
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
1. Write down all the partitions of a two element set {•, ∗}, order them as above,
and draw the Hasse diagram.
2. Now do the same thing for a four element-set, say {1, 2, 3, 4}. There should be 15
partitions.
Choose any two systems in your 15-element Hasse diagram, call them A and B.
3. What is A ∨B, using the deﬁnition given in the paragraph above Eq. (1.3)?
4. Is it true that A ≤(A ∨B) and B ≤(A ∨B)?
5. What are all the systems C for which both A ≤C and B ≤C.
6. Is it true that in each case, (A ∨B) ≤C?
♦
The set B  {true, false} of booleans also has an order, false ≤true:
true
false
Thus false ≤false, false ≤true, and true ≤true, but true ≰false. In other
words, A ≤B if A implies B.2
For any A, B in B, we can again write A ∨B to mean the least element that is greater
than both A and B.
Exercise 1.7.
Using the order false ≤true on B  {true, false}, what is:
1. true ∨false?
2. false ∨true?
3. true ∨true?
4. false ∨false?
♦
Let’s return to our systems with •, ◦, and ∗, and Alice’s “• is connected to ∗” function,
which we called Φ. It takes any such system and returns either true or false. Note
that the map Φ preserves the ≤order: if A ≤B and there is a connection between • and
∗in A, then there is such a connection in B too. The possibility of a generative eﬀect is
captured in the inequality
Φ(A) ∨Φ(B) ≤Φ(A ∨B).
(1.8)
We saw on page 4 that this can be a strict inequality: we showed two systems A and B
with Φ(A)  Φ(B)  false, so Φ(A) ∨Φ(B)  false, but where Φ(A ∨B)  true. In
this case, a generative eﬀect exists.
These ideas capture the most basic ideas in category theory. Most directly, we have
seen that the map Φ preserves some structure but not others: it preserves order but not
join. In fact, we have seen here hints of more complex notions from category theory,
without making them explicit; these include the notions of category, functor, colimit,
and adjunction. In this chapter we will explore these ideas in the elementary setting of
ordered sets.
2In mathematical logic, false implies true but true does not imply false. That is “P implies Q”
means, “if P is true, then Q is true too, but if P is not true, I’m making no claims.”

1.2. WHAT IS ORDER?
7
1.2
What is order?
Above we informally spoke of two diﬀerent ordered sets: the order on system connec-
tivity and the order on booleans false ≤true. Then we related these two ordered
sets by means of Alice’s observation Φ. Before continuing, we need to make such
ideas more precise. We begin in Section 1.2.1 with a review of sets and relations. In
Section 1.2.2 we will give the deﬁnition of a preorder—short for preordered set—and
a good number of examples.
1.2.1
Review of sets, relations, and functions
We will not give a deﬁnition of set here, but informally we will think of a set as a
collection of things, known as elements. These things could be all the leaves on a
certain tree, or the names of your favorite fruits, or simply some symbols a, b, c. For
example, we write A  {h, 1} to denote the set, called A, that contains exactly two
elements, one called h and one called 1. The set {h, h, 1, h, 1} is exactly the same as A
because they both contain the same elements, h and 1, and repeating an element more
than once in the notation doesn’t change the set.3 For an arbitrary set X, we write x ∈X
if x is element of X; so we have h ∈A and 1 ∈A, but 0 < A.
Example 1.9. Here are some important sets from mathematics—and the notation we
will use—that will appear again in this book.
•  denotes the empty set; it has no elements.
• {1} denotes a set with one element; it has one element, 1.
• B denotes the set of booleans; it has two elements, true and false.
• N denotes the set of natural numbers; it has elements 0, 1, 2, 3, . . . , 90717, . . ..
• n, for any n ∈N, denotes the nth ordinal; it has n elements 1, 2, . . . , n. For example,
0  , 1  {1}, and 5  {1, 2, 3, 4, 5}.
• Z, the set of integers; it has elements . . . , −2, −1, 0, 1, 2, . . . , 90717, . . ..
• R, the set of real numbers; it has elements like π, 3.14, 5∗
√
2, e, e2, −1457, 90717, etc.
Given sets X and Y, we say that X is a subset of Y, and write X ⊆Y, if every element
in X is also in Y. For example {h} ⊆A. Note that the empty set  B {} is a subset
of every other set.4 Given a set Y and a property P that is either true or false for each
element of Y, we write {y ∈Y | P(y)} to mean the subset of those y’s that satisfy P.
Exercise 1.10.
1. Is it true that N  {n ∈Z | n ≥0}?
3If you want a notion where “h, 1” is diﬀerent than “h, h, 1, h, 1”, you can use something called bags,
where the number of times an element is listed matters, or lists, where order also matters. All of these are
important concepts in applied category theory, but sets will come up the most for us.
4When we write Z B foo, it means “assign the meaning foo to variable Z”, whereas Z  foo means
simply that Z is equal to foo, perhaps as discovered via some calculation. In particular, Z B foo implies
Z  foo but not vice versa; indeed it would not be proper to write 3 + 2 B 5 or {} B .

8
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Is it true that N  {n ∈Z | n ≥1}?
3. Is it true that   {n ∈Z | 1 < n < 2}?
♦
If both X1 and X2 are subsets of Y, their union, denoted X1 ∪X2, is also a subset of
Y, namely the one containing the elements in X1 and the elements in X2 but no more.
For example if Y  {1, 2, 3, 4} and X1  {1, 2} and X2  {2, 4}, then X1 ∪X2  {1, 2, 4}.
Note that  ∪X  X for any X ⊆Y.
Similarly, if both X1 and X2 are subsets of Y, then their intersection, denoted X1 ∩X2,
is also a subset of Y, namely the one containing all the elements of Y that are both in
X1 and in X2, and no others. So {1, 2, 3} ∩{2, 5}  {2}.
What if we need to union or intersect a lot of subsets? For example, consider the
sets X0  , X1  {1}, X2  {1, 2}, etc. as subsets of N, and we want to know what the
union of all of them is. This union is written Ð
n∈N Xn, and it is the subset of N that
contains every element of every Xn, but no others. Namely, Ð
n∈N Xn  {n ∈N | n ≥1}.
Similarly one can write Ñ
n∈N Xn for the intersection of all of them, which will be empty
in the above case.
Given two sets X and Y, the product X × Y of X and Y is the set of pairs (x, y), where
x ∈X and y ∈Y.
Finally, we may want to take a disjoint union of two sets, even if they have elements
in common. Given two sets X and Y, their disjoint union X ⊔Y is the set of pairs of the
form (x, 1) or (y, 2), where x ∈X and y ∈Y.
Exercise 1.11.
Let A B {h, 1} and B B {1, 2, 3}.
1. There are eight subsets of B; write them out.
2. Take any two nonempty subsets of B and write out their union.
3. There are six elements in A × B; write them out.
♦
4. There are ﬁve elements of A ⊔B; write them out.
5. If we consider A and B as subsets of the set {h, 1, 2, 3}, there are four elements of
A ∪B; write them out.
Relationships between diﬀerent sets—for example between the set of trees in your
neighborhood and the set of your favorite fruits—are captured using subsets and
product sets.
Deﬁnition 1.12. Let X and Y be sets. A relation between X and Y is a subset R ⊆X × Y.
A binary relation on X is a relation between X and X, i.e. a subset R ⊆X × X.
It is convenient to use something called inﬁx notation for binary relations R ⊆A × A.
This means one picks a symbol, say ⋆, and writes a ⋆b to mean (a, b) ∈R.
Example 1.13. There is a binary relation on R with inﬁx notation ≤. Rather than writing
(5, 6) ∈R, we write 5 ≤6.
Other examples of inﬁx notation for relations are , ≈, <, >. In number theory, they
are interested in whether one number divides without remainder into another number;

1.2. WHAT IS ORDER?
9
this relation is denoted with inﬁx notation |, so 5|10.
Partitions and equivalence relations.
We can now deﬁne partitions more formally.
Deﬁnition 1.14. If A is a set, a partition of A consists of a set P and, for each p ∈P, a
nonempty subset Ap ⊆A, such that
A 
Ø
p∈P
Ap
and
if p , q then Ap ∩Aq  .
(1.15)
We may denote the partition by {Ap}p∈P. We refer to P as the set of part labels and if
p ∈P is a part label, we refer to Ap as the pth part. The condition (1.15) says that each
element a ∈A is in exactly one part.
We consider two diﬀerent partitions {Ap}p∈P and {A′
p′}p′∈P′ of A to be the same if for
each p ∈P there exists a p′ ∈P′ with Ap  A′
p′. In other words, if two ways to divide A
into parts are exactly the same—the only change is in the labels—then we don’t make
a distinction between them.
Exercise 1.16.
Suppose that A is a set and {Ap}p∈P and {A′
p′}p′∈P′ are two partitions of
A such that for each p ∈P there exists a p′ ∈P′ with Ap  A′
p′.
1. Show that for each p ∈P there is at most one p′ ∈P′ such that Ap  A′
p′
2. Show that for each p′ ∈P′ there is a p ∈P such that Ap  A′
p′.
♦
Exercise 1.17.
Consider the partition shown below:
11•
12•
13•
21•
22•
23•
For any two elements a, b ∈{11, 12, 13, 21, 22, 23}, let’s allow ourselves to write a
twiddle symbol a ∼b between them if a and b are both in the same part. Write down
every pair of elements (a, b) that are in the same part. There should be 10.5
♦
We will see in Proposition 1.19 that there is a strong relationship between partitions
and something called equivalence relations, which we deﬁne next.
Deﬁnition 1.18. Let A be a set. An equivalence relation on A is a binary relation, let’s
give it inﬁx notation ∼, satisfying the following three properties:
(a) a ∼a, for all a ∈A,
(b) a ∼b iﬀa b ∼a, for all a, b ∈A, and
(c) if a ∼b and b ∼c then a ∼c, for all a, b, c ∈A.
5Hint: whenever someone speaks of “two elements a, b in a set A”, the two elements may be the same!

10
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
These properties are called reﬂexivity, symmetry, and transitivity, respectively.
a‘Iﬀ’ is short for ‘if and only if’.
Proposition 1.19. Let A be a set. There is a one-to-one correspondence between the
ways to partition A and the equivalence relations on A.
Proof. We ﬁrst show that every partition gives rise to an equivalence relation, and then
that every equivalence relation gives rise to a partition. Our two constructions will be
mutually inverse, proving the proposition.
Suppose we are given a partition {Ap}p∈P; we deﬁne a relation ∼and show it is an
equivalence relation. Deﬁne a ∼b to mean that a and b are in the same part: there is
some p ∈P such that a ∈Ap and b ∈Ap. It is obvious that a is in the same part as
itself. Similarly, it is obvious that if a is in the same part as b then b is in the same part
as a, and that if further b is in the same part as c then a is in the same part as c. Thus
∼is an equivalence relation as deﬁned in Deﬁnition 1.18.
Suppose given an equivalence relation ∼; we will form a partition on A by saying
what the parts are. Say that a subset X ⊆A is (∼)-closed if, for every x ∈X and
x′ ∼x, we have x′ ∈X. Say that a subset X ⊆A is (∼)-connected if it is nonempty and
x ∼y for every x, y ∈X. Then the parts corresponding to ∼are exactly the (∼)-closed,
(∼)-connected subsets. It is not hard to check that these indeed form a partition.
□
Exercise 1.20.
Let’s complete the “it’s not hard to check” part in the proof of Proposi-
tion 1.19. Suppose that ∼is an equivalence relation on a set A, and let P be the set of
(∼)-closed and (∼)-connected subsets {Ap}p∈P.
1. Show that each part Ap is nonempty.
2. Show that if p , q, i.e. if Ap and Aq are not exactly the same set, then Ap ∩Aq  .
3. Show that A  Ð
p∈P Ap.
♦
Deﬁnition 1.21. Given a set A and an equivalence relation ∼on A, we say that the
quotient A/∼of A under ∼is the set of parts of the corresponding partition.
Functions.
The most frequently used sort of relation between sets is that of functions.
Deﬁnition 1.22. Let S and T be sets. A function from S to T is a subset F ⊆S × T such
that for all s ∈S there exists a unique t ∈T with (s, t) ∈F.
The function F is often denoted F : S →T. From now on, we write F(s)  t, or
sometimes s 7→t, to mean (s, t) ∈F. For any t ∈T, the preimage of t along F is the
subset {s ∈S | F(s)  t}.
A function is called surjective, or a surjection, if for all t ∈T there exists s ∈S with
F(s)  t. A function is called injective, or an injection, if for all t ∈T and s1, s2 ∈S

1.2. WHAT IS ORDER?
11
with F(s1)  t and F(s2)  t, we have s1  s2. A function is called bĳective if it is both
surjective and injective.
We use various decorations on arrows, →, ↠, ↣,
−→to denote these special sorts of
functions. Here is a table with the name, arrow decoration, and an example of each
sort of function:
arbitrary function
surjective function
injective function
bĳective function
3 →3
3 ↠2
2 ↣3
3
−→3
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
Example 1.23. An important but very simple sort of function is the identity function on
a set X, denoted idX. It is the bĳective function idX(x)  x.
•
•
•
•
•
•
For notational consistency with Deﬁnition 1.22, the arrows in Example 1.23 might
be drawn as 7→rather than d. The d-style arrows were drawn because we thought it
was prettier, i.e. easier on the eye. Beauty is important too; an imbalanced preference
for strict correctness over beauty becomes pedantry. But outside of pictures, we will be
careful.
Exercise 1.24.
In the following, do not use any examples already drawn above.
1. Find two sets A and B and a function f : A →B that is injective but not surjective.
2. Find two sets A and B and a function f : A →B that is surjective but not injective.
Now consider the four relations shown here:
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
For each relation, answer the following two questions.
3. Is it a function?
4. If not, why not? If so, is it injective, surjective, both (i.e. bĳective), or neither?
♦
Exercise 1.25.
Suppose that A is a set and f : A → is a function to the empty set.
Show that A is empty.
♦

12
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Example 1.26. A partition on a set A can also be understood in terms of surjective
functions out of A. Given a surjective function f : A ↠P, where P is any other set, the
preimages f −1(p) ⊆A, one for each element p ∈P, form a partition of A. Here is an
example.
Consider the partition of S B {11, 12, 13, 21, 22, 23} shown below:
11•
12•
13•
21•
22•
23•
S B
It has been partitioned into four parts, so let P  {a, b, c, d} and let f : S ↠P be given
by
f (11)  a,
f (12)  a,
f (13)  b,
f (21)  c,
f (22)  d,
f (23)  d
Exercise 1.27.
Write down a surjection corresponding to each of the ﬁve partitions in
Eq. (1.5).
♦
Deﬁnition 1.28. If F : X →Y is a function and G: Y →Z is a function, their composite
is the function X →Z deﬁned to be G(F(x)) for any x ∈X. It is often denoted G ◦F, but
we prefer to denote it F # G. It takes any element x ∈X, evaluates F to get an element
F(x) ∈Y and then evaluates G to get an element G(F(x)).
Example 1.29. If X is any set and x ∈X is any element, we can think of x as a function
{1} →X, namely the function sending 1 to x.
For example, the three functions
{1} →{1, 2, 3} shown below correspond to the three elements of {1, 2, 3}:
•
•1
•2
•3
•
•1
•2
•3
•
•1
•2
•3
Suppose given a function F : X →Y and an element of X, thought of as a function
x : {1} →X. Then evaluating F at x is given by the composite, F(x)  x # F.
1.2.2
Preorders
In Section 1.1, we several times used the symbol ≤to denote a sort of order. Here is a
formal deﬁnition of what it means for a set to have an order.

1.2. WHAT IS ORDER?
13
Deﬁnition 1.30. A preorder relation on a set X is a binary relation on X, here denoted
with inﬁx notation ≤, such that
(a) x ≤x; and
(b) if x ≤y and y ≤z, then x ≤z.
The ﬁrst condition is called reﬂexivity and the second is called transitivity. If x ≤y and
y ≤x, we write x  y and say x and y are equivalent. We call a pair (X, ≤) consisting
of a set equipped with a preorder relation a preorder.
Remark 1.31. Observe that reﬂexivity and transitivity are familiar from Deﬁnition 1.18:
preorders are just equivalence relations without the symmetry condition.
Example 1.32 (Discrete preorders). Every set X can be considered as a discrete preorder
(X, ). This means that the only order relations on X are of the form x ≤x; if x , y
then neither x ≤y or y ≤x hold.
We depict discrete preorders as simply a collection of points:
•
•
•
Example 1.33 (Codiscrete preorders). From every set we may also construct its codiscrete
preorder (X, ≤) by equipping it with the total binary relation X × X ⊆X × X. This is a
very trivial structure: it means that for all x and y in X we have x ≤y (and hence also
y ≤x).
Example 1.34 (Booleans). The booleansB  {false, true} form a preorder with false ≤
true.
false
true
Remark 1.35 (Partial orders are skeletal preorders). A preorder is a partial order if we
additionally have that
(c) x  y implies x  y.
In category theory terminology, the requirement that x  y implies x  y is known
as skeletality, so partial orders are skeletal preorders. For short, we also use the term poset,
a contraction of partially ordered set.
The diﬀerence between preorders and partial orders is rather minor. A partial order
already is a preorder, and every preorder can be made into a partial order by equating
any two elements x, y for which x  y, i.e. for which x ≤y and y ≤x.
For example, any discrete preorder is already a partial order, while any codiscrete
preorder simply becomes the unique partial order on a one element set.

14
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
We have already introduced a few examples of preorders using Hasse diagrams. It
will be convenient to continue to do this, so let us be a bit more formal about what we
mean. First, we need to deﬁne a graph.
Deﬁnition 1.36. A graph G  (V, A, s, t) consists of a set V whose elements are called
vertices, a set A whose elements are called arrows, and two functions s, t : A →V known
as the source and target functions respectively. Given a ∈A with s(a)  v and t(a)  w,
we say that a is an arrow from v to w.
By a path in G we mean any sequence of arrows such that the target of one arrow is
the source of the next. This includes sequences of length 1, which are just arrows a ∈A
in G, and sequences of length 0, which just start and end at the same vertex v, without
traversing any arrows.
Example 1.37. Here is a picture of a graph:
G 
1•
2•
3•
4•
a
b
c
e
d
It has V  {1, 2, 3, 4} and A  {a, b, c, d, e}. The source and target functions, s, t : A →
V are given by the following partially-ﬁlled-in tables (see Exercise 1.38):
arrow a
source s(a) ∈V
target t(a) ∈V
a
1
?
b
1
3
c
?
?
d
?
?
e
?
?
There is one path from 2 to 3, namely the arrow e is a path of length 1. There are no
paths from 4 to 3, but there is one path from 4 to 4, namely the path of length 0. There
are inﬁnitely many paths 1 →2 because one can loop and loop and loop through d as
many times as one pleases.
Exercise 1.38.
Fill in the table from Example 1.37.
♦
Remark 1.39. From every graph we can get a preorder. Indeed, a Hasse diagram is a
graph G  (V, A, s, t) that gives a presentation of a preorder (P, ≤). The elements of P
are the vertices V in G, and the order ≤is given by v ≤w iﬀ6 there is a path v →w.
For any vertex v, there is always a path v →v, and this translates into the reﬂexivity
6The word ‘iﬀ’ is a common mathematical shorthand for the phrase “if and only if”, and we use it to
connect two statements that each imply the other, and hence are logically equivalent.

1.2. WHAT IS ORDER?
15
law from Deﬁnition 1.30. The fact that paths u →v and v →w can be concatenated to
a path u →w translates into the transitivity law.
Exercise 1.40. What preorder relation (P, ≤) is depicted by the graph G in Example 1.37?
That is, what are the elements of P and write down every pair (p1, p2) for which p1 ≤p2.
♦
Exercise 1.41.
Does a collection of points, like the one in Example 1.32, count as a
Hasse diagram?
♦
Exercise 1.42.
Let X be the set of partitions of {•, ◦, ∗}; it has ﬁve elements and an order
by coarseness, as shown in the Hasse diagram Eq. (1.5). Write down every pair (x, y)
of elements in X such that x ≤y. There should be 12.
♦
Remark 1.43. In Remark 1.35 we discussed partial orders—preorders with the property
that whenever two elements are equivalent, they are the same—and then said that this
property is fairly inconsequential: any preorder can be converted to a partial order
that’s “equivalent” category-theoretically. A partial order is like a preorder with a
fancy haircut: some mathematicians might not even notice it.
However, there are other types of preorders that are more special and noticeable.
For example, a total order has the following additional property:
(d) for all x, y, either x ≤y or y ≤x.
We say two elements x, y of a preorder are comparable if either x ≤y or y ≤x, so a total
order is a preorder where every two elements are comparable.
Exercise 1.44.
Is it correct to say that a discrete preorder is one where no two elements
are comparable?
♦
Example 1.45 (Natural numbers). The natural numbers N B {0, 1, 2, 3, . . .} are a pre-
order with the order given by the usual size ordering, e.g. 0 ≤1 and 5 ≤100. This is
a total order: either m ≤n or n ≤m for all m, n. One can see that its Hasse diagram
looks like a line:
0•
1•
2•
3•
· · ·
What made Eq. (1.5) not look like a line is that there are non-comparable elements a
and b—namely all those in the middle row—which satisfy neither a ≤b nor b ≤a.
Note that for any set S, there are many diﬀerent ways of assigning an order to S.
Indeed, for the set N, we could also use the discrete ordering: only write n ≤m if
n  m. Another ordering is the reverse ordering, like 5 ≤3 and 3 ≤2, like how golf is
scored (5 is worse than 3).
Yet another ordering on N is given by division: we say that n ≤m if n divides into
m without remainder. In this ordering 2 ≤4, for example, but 2 ≰3, since there is a
remainder when 2 is divided into 3.
Exercise 1.46.
Write down the numbers 1, 2, . . . , 10 and draw an arrow a →b if a
divides perfectly into b. Is it a total order?
♦

16
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Example 1.47 (Real numbers). The real numbers R also form a preorder with the “usual
ordering”, e.g. −500 ≤−499 ≤0 ≤
√
2 ≤100/3.
Exercise 1.48.
Is the usual ≤ordering on the set R of real numbers a total order?
♦
Example 1.49 (Partition from preorder). Given a preorder, i.e. a pre-ordered set (P, ≤),
we deﬁned the notion of equivalence of elements, denoted x  y, to mean x ≤y and
y ≤x. This is an equivalence relation, so it induces a partition on P. (The phrase
“A induces B” means that we have an automatic way to turn an A into a B. In this
case, we’re saying that we have an automatic way to turn equivalence relations into
partitions, which we do; see Proposition 1.19.)
For example, the preorder whose Hasse diagram is drawn on the left corresponds
to the partition drawn on the right.
•
•
•
•
11
21
11
21
•
•
•
•
12
22
12
22
•
•
•
•
13
23
13
23
•
•
•
•
14
24
14
24
Example 1.50 (Power set). Given a set X, the set of subsets of X is known as the power
set of X; we denote it P(X). The power set can naturally be given an order by inclusion
of subsets (and from now on, whenever we speak of the power set as an ordered set,
this is the order we mean).
For example, taking X  {0, 1, 2}, we depict P(X) as
X
{0, 1}
{0, 2}
{1, 2}
{0}
{1}
{2}

See the cube? The Hasse diagram for the power set of a ﬁnite set, say P{1, 2, . . . , n},a
always looks like a cube of dimension n.
aNote that we omit the parentheses here, writing PX instead of P(X); throughout this book we will
omit parentheses if we judge the presentation is cleaner and it is unlikely to cause confusion.
Exercise 1.51.
Draw the Hasse diagrams for P(), P{1}, and P{1, 2}.
♦

1.2. WHAT IS ORDER?
17
Example 1.52 (Partitions). We talked about getting a partition from a preorder; now let’s
think about how we might order the set Prt(A) of all partitions of A, for some set A. In
fact, we have done this before in Eq. (1.5). Namely, we order on partitions by ﬁneness:
a partition P is ﬁner than a partition Q if, for every part p ∈P there is a part q ∈Q such
that Ap ⊆Aq. We could also say that Q is coarser than P.
Recall from Example 1.26 that partitions on A can be thought of as surjective func-
tions out of A. Then f : A ↠P is ﬁner than 1 : A ↠Q if there is a function h : P →Q
such that f # h  1.
Exercise 1.53.
For any set S there is a coarsest partition, having just one part. What
surjective function does it correspond to?
There is also a ﬁnest partition, where everything is in its own partition.
What
surjective function does it correspond to?
♦
Example 1.54 (Upper sets). Given a preorder (P, ≤), an upper set in P is a subset U of P
satisfying the condition that if p ∈U and p ≤q, then q ∈U. “If p is an element then so
is anything bigger.” Write U(P) for the set of upper sets in P. We can give the set U an
order by letting U ≤V if U is contained in V.
For example, if (B, ≤) is the booleans (Example 1.34), then its preorder of uppersets
U(B) is

{true}
{true, false}
The subset {false} ⊆B is not an upper set, because false ≤true and true < {false}.
Exercise 1.55.
Prove that the preorder of upper sets on a discrete preorder (see Exam-
ple 1.32) on a set X is simply the power set P(X).
♦
Example 1.56 (Product preorder). Given preorders (P, ≤) and (Q, ≤), we may deﬁne a
preorder structure on the product set P × Q by setting (p, q) ≤(p′, q′) if and only if
p ≤p′ and q ≤q′. We call this the product preorder. This is a basic example of a more
general construction known as the product of categories.
Exercise 1.57.
Draw the Hasse diagram for the product of the two preorders drawn

18
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
below:
c•
b•
•
a
2•
•
1
For bonus points, compute the upper set preorder on the result.
♦
Example 1.58 (Opposite preorder). Given a preorder (P, ≤), we may deﬁne the opposite
preorder (P, ≤op) to have the same set of elements, but with p ≤op q if and only if q ≤p.
1.2.3
Monotone maps
We have said that the categorical perspective emphasizes relationships between things.
For example, a preorder is a setting—or world—in which we have one sort of relation-
ship, ≤, and any two objects may be, or may not be, so-related. Jumping up a level,
the categorical perspective emphasizes that preorders themselves—each a miniature
world composed of many relationships—can be related to one another.
The most important sort of relationship between preorders is called a monotone map.
These are functions that preserve preorder relations—in some sense mappings that
respect ≤—and are hence considered the right notion of structure-preserving map for
preorders.
Deﬁnition 1.59. A monotone map between preorders (A, ≤A) and (B, ≤B) is a function
f : A →B such that, for all elements x, y ∈A, if x ≤A y then f (x) ≤B f (y).
A monotone map A →B between two preorders associates to each element of
preorder A an element of the preorder B. We depict this by drawing a dotted arrow
from each element x ∈A to its image f (x) ∈B. Note that the order must be preserved
in order to count as a valid monotone map, so if element x is above element y in the
lefthand preorder A, then the image f (x) will be above the image f (y) in the righthand
preorder.
•
•
•
•
•
•
•
•

1.2. WHAT IS ORDER?
19
Example 1.60. Let B and N be the preorders of booleans from Example 1.34 and N the
preorder of natural numbers from Example 1.45. The map B →N sending false to 17
and true to 24 is a monotone map, because it preserves order.
false
true
0
1
· · ·
17
18
· · ·
23
24
· · ·
Example 1.61 (The tree of life). Consider the set of all animal classiﬁcations, for example
‘tiger’, ‘mammal’, ‘sapiens’, ‘carnivore’, etc.. These are ordered by speciﬁcity: since
‘tiger’ is a type of ‘mammal’, we write tiger ≤mammal. The result is a preorder, which
in fact forms a tree, often called the tree of life. At the top of the following diagram we
see a small part of it:
•
sapiens
•
habilis
•
lion
•
tiger
•
homo
•
panthera
•
primate
•
carnivore
•
mammal
•
species
•
genus
•
family
•
order
•
class
•
phylum
•
kingdom
At the bottom we see the hierarchical structure as a preorder. The dashed arrows show
a monotone map, call it F, from the classiﬁcations to the hierarchy. It is monotone
because it preserves order: whenever there is a path x →y upstairs, there is a path
F(x) →F(y) downstairs.
Example 1.62. Given a ﬁnite set X, recall the power set P(X) and its natural order relation
from Example 1.50. The map |·| : P(X) →N sending each subset S to its number of
elements |S|, also called its cardinality, is a monotone map.
Exercise 1.63.
Let X  {0, 1, 2}.
1. Draw the Hasse diagram for P(X).
2. Draw the Hasse diagram for the preorder 0 ≤1 ≤2 ≤3.

20
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
3. Draw the cardinality map |·| from Example 1.62 as dashed lines between them.
♦
Example 1.64. Recall the notion of upper set from Example 1.54. Given a preorder
(P, ≤), the map U(P) →P(P) sending each upper set of (P, ≤) to itself—considered as
a subset of P—is a monotone map.
Exercise 1.65.
Consider the preorder B. The Hasse diagram for U(B) was drawn in
Example 1.54, and you drew the Hasse diagram for P(B) in Exercise 1.51. Now draw
the monotone map between them, as described in Example 1.64.
♦
Exercise 1.66.
Let (P, ≤) be a preorder, and recall the notion of opposite preorder from
Example 1.58.
1. Show that the set ↑p B {p′ ∈P | p ≤p′} is an upper set, for any p ∈P.
2. Show that this construction deﬁnes a monotone map ↑: Pop →U(P).
3. Show that if p ≤p′ in P if and only if ↑(p′) ⊆↑(p).
4. Draw a picture of the map ↑in the case where P is the preorder (b ≥a ≤c) from
Example 1.56.
This is known as the Yoneda lemma for preorders. The if and only if condition proved
in part 3 implies that, up to equivalence, to know an element is the same as knowing
its upper set—that is, knowing its web of relationships with the other elements of
the preorder. The general Yoneda lemma is a powerful tool in category theory, and a
fascinating philosophical idea besides.
♦
Exercise 1.67.
As you yourself well know, a monotone map f : (P, ≤P) →(Q, ≤Q)
consists of a function f : P →Q that satisﬁes a “monotonicity” property. Show that
when (P, ≤P) is a discrete preorder, then every function P →Q satisﬁes the monotonicity
property, regardless of the order ≤Q.
♦
Example 1.68. Recall from Example 1.52 that given a set X we deﬁne Prt(X) to be the
set of partitions on X, and that a partition may be deﬁned using a surjective function
s : X ↠P for some set P.
Any surjective function f : X ↠Y induces a monotone map f ∗: Prt(Y) →Prt(X),
going “backwards.” It is deﬁned by sending a partition s : Y ↠P to the composite
f # s : X ↠P.7
Exercise 1.69.
Choose two sets X and Y with at least three elements each and choose
a surjective, non-identity function f : X ↠Y between them. Write down two diﬀerent
partitions P and Q of Y, and then ﬁnd f ∗(P) and f ∗(Q).
♦
The following proposition, Proposition 1.70, is straightforward to check. Recall the
deﬁnition of the identity function from Example 1.23 and the deﬁnition of composition
from Deﬁnition 1.28.
7We will later see that any function f : X →Y, not necessarily surjective, induces a monotone map
f ∗: Prt(Y) →Prt(X), but it involves an extra step. See Section 1.4.2.

1.2. WHAT IS ORDER?
21
Proposition 1.70. For any preorder (P, ≤P), the identity function is monotone.
If (Q, ≤Q) and (R, ≤R) are preorders and f : P →Q and 1 : Q →R are monotone,
then ( f # 1): P →R is also monotone.
Exercise 1.71.
Check the two claims made in Proposition 1.70.
♦
Example 1.72. Recall again the deﬁnition of opposite preorder from Example 1.58. The
identity function idP : P →P is a monotone map (P, ≤) →(P, ≤op) if and only if for
all p, q ∈P we have q ≤p whenever p ≤q. For historical reasons connected to linear
algebra, when this is true, we call (P, ≤) a dagger preorder.
But in fact, we have seen dagger preorders before in another guise. Indeed, if (P, ≤)
is a dagger preorder, then the relation ≤is symmetric: p ≤q if and only if q ≤p, and it
is also reﬂexive and transitive by deﬁnition of preorder. So in fact ≤is an equivalence
relation (Deﬁnition 1.18).
Exercise 1.73.
Recall the notion of skeletal preorders (Remark 1.35) and discrete
preorders (Example 1.32).
Show that a skeletal dagger preorder is just a discrete
preorder, and hence can be identiﬁed with a set.
♦
Remark 1.74. We say that an A “can be identiﬁed with” a B when any A gives us a
unique B and any B gives us a unique A, and both round-trips—from an A to a B and
back to an A, or from a B to an A and back to a B—return us where we started. For
example, any discrete preorder (P, ≤) has an underlying set P, and any set P can be
made into a discrete preorder (p1 ≤p2 iﬀp1  p2), and the round-trips return us where
we started. So what’s the diﬀerence? It’s like the notion of object-permanence from child
development jargon: we can recognize “the same chair, just moved from one room to
another.” A chair in the room of sets can be moved to a chair in the room of preorders.
The lighting is diﬀerent but the chair is the same.
Eventually, we will be able to understand this notion in terms of equivalence of cate-
gories, which are related to isomorphisms, which we will explore next in Deﬁnition 1.75.
Deﬁnition 1.75. Let (P, ≤P) and (Q, ≤Q) be preorders. A monotone function f : P →Q
is called an isomorphism if there exists a monotone function 1 : Q →P such that
f # 1  idP and 1 # f  idQ. This means that for any p ∈P and q ∈Q, we have
p  1( f (p))
and
q  f (1(q)).
We refer to 1 as the inverse of f , and vice versa: f is the inverse of 1.
If there is an isomorphism P →Q, we say that P and Q are isomorphic.
An isomorphism between preorders is basically just a relabeling of the elements.

22
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Example 1.76. Here are the Hasse diagrams for three preorders P, Q, and R, all of which
are isomorphic:
P B
e•
d•
c•
b•
a•
Q B
z•
x•
y
•
v•
w•
R B
z•
x•
y
•
v•
w•
The map f : P →Q given by f (a)  v, f (b)  w, f (c)  x, f (d)  y, and f (e)  z has
an inverse.
In fact Q and R are the same preorder. One may be confused by the fact that there
is an arrow x →z in the Hasse diagram for R and not one in Q, but in fact this arrow
is superﬂuous. By the transitivity property of preorders (Deﬁnition 1.30), since x ≤y
and y ≤z, we must have x ≤z, whether it is drawn or not. Similarly, we could have
drawn an arrow v →y in either Q or R and it would not have changed the preorder.
Recall the preorder B  {false, true}, where false ≤true. As simple as this
preorder is, it is also one of the most important.
Exercise 1.77.
Show that the map Φ from Section 1.1.1, which was roughly given by ‘Is
• connected to ∗?’ is a monotone map Prt({∗, •, ◦}) →B; see also Eq. (1.5).
♦
Proposition 1.78. Let P be a preorder.
Monotone maps P →B are in one-to-one
correspondence with upper sets of P.
Proof. Let f : P →B be a monotone map. We will show that the subset f −1(true) ⊆P
is an upper set. Suppose p ∈f −1(true) and p ≤q; then true  f (p) ≤f (q). But in
B, if true ≤f (q) then true  f (q). This implies q ∈f −1(true) and thus shows that
f −1(true) is an upper set.
Conversely, if U is an upper set in P, deﬁne fU : P →B such that fU(p)  true when
p ∈U, and fU(p)  false when p < U. This is a monotone map, because if p ≤q, then
either p ∈U, so q ∈U and f (p)  true  f (q), or p < U, so f (p)  false ≤f (q).
These two constructions are mutually inverse, and hence prove the proposition.
□
Exercise 1.79 (Pullback map).
Let P and Q be preorders, and f : P →Q be a monotone
map. Then we can deﬁne a monotone map f ∗: U(Q) →U(P) sending an upper set
U ⊆Q to the upper set f −1(U) ⊆P. We call this the pullback along f .
Viewing upper sets as a monotone maps to B as in Proposition 1.78, the pullback
can be understood in terms of composition. Indeed, show that the f ∗is deﬁned by
taking u : Q →B to ( f # u): P →B.
♦

1.3. MEETS AND JOINS
23
1.3
Meets and joins
As we have said, a preorder is a set P endowed with an order ≤relating the elements.
With respect to this order, certain elements of P may have distinctive characterizations,
either absolutely or in relation to other elements. We have discussed joins before, but
we discuss them again now that we have built up some formalism.
1.3.1
Deﬁnition and basic examples
Consider the preorder (R, ≤) of real numbers ordered in the usual way. The subset
N ⊆R has many lower bounds, namely −1.5 is a lower bound: every element of N is
bigger than −1.5. But within all lower bounds for N ⊆R, one is distinctive: a greatest
lower bound—also called a meet—namely 0. It is a lower bound, and there is no lower
bound for N that is above it. However, the set N ⊆R has no upper bound, and certainly
no least upper bound—which would be called a join. On the other hand, the set

1
n + 1
 n ∈N



1, 1
2, 1
3, 1
4, . . .

⊆R
has both a greatest lower bound (meet), namely 0, and a least upper bound (join),
namely 1.
These notions will have correlates in category theory, called limits and colimits,
which we will discuss in Chapter 3. More generally, we say these distinctive character-
izations are universal properties, since, for example, a greatest lower bound is greatest
among all lower bounds. For now, however, we simply want to make the deﬁnition of
greatest lower bounds and least upper bounds, called meets and joins, precise.
Exercise 1.80.
1. Why is 0 a lower bound for {
1
n+1 | n ∈N} ⊆R?
2. Why is 0 a greatest lower bound (meet)?
♦
Deﬁnition 1.81. Let (P, ≤) be a preorder, and let A ⊆P be a subset. We say that an
element p ∈P is a meet of A if
(a) for all a ∈A, we have p ≤a, and
(b) for all q such that q ≤a for all a ∈A, we have that q ≤p.
We write p  Ó A, p  Ó
a∈A a, or, if the dummy variable a is clear from context, just
p  Ó
A a. If A just consists of two elements, say A  {a, b}, we can denote Ó A simply
by a ∧b.
Similarly, we say that p is a join of A if
(a) for all a ∈A we have a ≤p, and
(b) for all q such that a ≤q for all a ∈A, we have that p ≤q.
We write p  Ô A or p  Ô
a∈A a, or when A  {a, b} we may simply write p  a ∨b.

24
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Remark 1.82. In Deﬁnition 1.81, we committed a seemingly egregious abuse of notation.
We will see next in Example 1.84 that there could be two diﬀerent meets of A ⊆P, say
p  Ó A and q  Ó A with p , q, which does not make sense if p , q!
But in fact, as we use the symbol Ó A, this abuse won’t matter because any two
meets p, q are automatically isomorphic: the very deﬁnition of meet forces both p ≤q
and q ≤p, and thus we have p  q. So for any x ∈P, we have p ≤x iﬀq ≤x and
x ≤p iﬀx ≤q. Thus as long as we are only interested in elements of P based on their
relationships to other elements (and in category theory, this is the case: we should only
care about things based on how they interact with other things, rather than on some
sort of “internal essence”), the distinction between p and q will never matter.
This foreshadows a major theme of—as well as standard abuse of notation in—
category theory, where any two things deﬁned by the same universal property are
automatically equivalent in a way known as ‘unique up to unique isomorphism’; this
means that we generally do not run into trouble if we pretend they are equal. We’ll
pick up this theme of ‘the’ vs ‘a’ again in Remark 3.85.
Example 1.83 (Meets or joins may not exist). Note that, in an arbitrary preorder (P, ≤),
a subset A need not have a meet or a join. Consider the three element set P  {p, q, r}
with the discrete ordering. The set A  {p, q} does not have a join in P because if x
was a join, we would need p ≤x and q ≤x, and there is no such element x.
Example 1.84 (Multiple meets or joins may exist). It may also be the case that a subset
A has more than one meet or join. Here is an example.
a•
b•
c•
d•
Let A be the subset {a, b} in the preorder speciﬁed by this Hasse diagram. Then both
c and d are meets of A: any element less than both a and b is also less than c, and also
less than d. Note that, as in Remark 1.82, c ≤d and d ≤c, so c  d. Such will always
the case when there is more than one meet: any two meets of the same subset will be
isomorphic.
Exercise 1.85.
Let (P, ≤) be a preorder and p ∈P an element. Consider the set A  {p}
with one element.
1. Show that Ó A  p.
2. Show that if P is in fact a partial order, then Ó A  p.
3. Are the analogous facts true when Ó is replaced by Ô?
♦

1.3. MEETS AND JOINS
25
Example 1.86. In any partial order P, we have p ∨p  p ∧p  p. The reason is that our
notation says p ∨p means Ô{p, p}. But {p, p}  {p} (see Section 1.2.1), so p ∨p  p by
Exercise 1.85.
Example 1.87. In a power set P(X), the meet of a collection of subsets, say A, B ⊆X is
their intersection A ∧B  A ∩B, while the join is their union, A ∨B  A ∪B.
A
B
A ∨B
A ∧B
Perhaps this justiﬁes the terminology: the joining of two sets is their union, the meeting
of two sets is their intersection.
Example 1.88. In the booleans B  {false, true} (Example 1.34), the meet of any two
elements is given by AND and the join of any two elements is given by OR (recall
Exercise 1.7).
Example 1.89. In a total order, the meet of a set is its inﬁmum, while the join of a set is
its supremum. Note that B is a total order, and this generalizes Example 1.88.
Exercise 1.90.
Recall the division ordering on N from Example 1.45: we write n|m
if n divides perfectly into m. The meet of any two numbers in this preorder has a
common name, that you may have learned when you were around 10 years old; what
is it? Similarly the join of any two numbers has a common name; what is it?
♦
Proposition 1.91. Suppose (P, ≤) is a preorder and A ⊆B ⊆P are subsets that have
meets. Then Ó B ≤Ó A.
Similarly, if A and B have joins, then Ô A ≤Ô B.
Proof. Let m  Ó A and n  Ó B. Then for any a ∈A we also have a ∈B, so n ≤a
because n is a lower bound for B. Thus n is also a lower bound for A and hence n ≤m,
because m is A’s greatest lower bound. The second claim is proved similarly.
□

26
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
1.3.2
Back to observations and generative eﬀects
In the thesis [Ada17], Adam thinks of monotone maps as observations. A monotone
map Φ: P →Q is a phenomenon (we might say “feature”) of P as observed by Q. He
deﬁnes the generative eﬀect of such a map Φ to be its failure to preserve joins (or more
generally, for categories, its failure to preserve colimits).
Deﬁnition 1.92. We say that a monotone map f : P →Q preserves meets if f (a ∧b) 
f (a) ∧f (b) for all a, b ∈P. We similarly say f preserves joins if f (a ∨b)  f (a) ∨f (b)
for all a, b ∈P.
Deﬁnition 1.93. We say that a monotone map f : P →Q has a generative eﬀect if there
exist elements a, b ∈P such that
f (a) ∨f (b)  f (a ∨b).
In Deﬁnition 1.93, if we think of Φ as a observation or measurement of the systems
a and b, then the left hand side f (a) ∨f (b) may be interpreted as the combination of
the observation of a with the observation of b. On the other hand, the right hand side
f (a ∨b) is the observation of the combined system a ∨b. The inequality implies that
we see something when we observe the combined system that we could not expect
by merely combining our observations of the pieces. That is, that there are generative
eﬀects from the interconnection of the two systems.
Exercise 1.94. In Deﬁnition 1.93, we deﬁned generativity of f as the inequality f (a∨b) ,
f (a) ∨f (b), but in the subsequent text we seemed to imply there would be not just a
diﬀerence, but more stuﬀin f (a ∨b) than in f (a) ∨f (b).
Prove that for any monotone map f : P →Q, if a, b ∈P have a join and f (a), f (b) ∈Q
have a join, then indeed f (a) ∨f (b) ≤f (a ∨b).
♦
In his work on generative eﬀects, Adam restricts his attention to generative maps
that preserve meets (but do not preserve joins). The preservation of meets implies that
the map Φ behaves well when restricting to subsystems, even though it can throw up
surprises when joining systems.
This discussion naturally leads into Galois connections, which are pairs of monotone
maps between preorders, one of which preserves all joins and the other of which
preserves all meets.
1.4
Galois connections
The preservation of meets and joins, and in particular issues concerning generative
eﬀects, is tightly related to the theory of Galois connections, which is a special case of a
more general theory we will discuss later, namely that of adjunctions. We will use some
adjunction terminology when describing Galois connections.

1.4. GALOIS CONNECTIONS
27
1.4.1
Deﬁnition and examples of Galois connections
Galois connections between preorders were ﬁrst considered by Évariste Galois—who
didn’t call them by that name—in the context of a connection he found between “ﬁeld
extensions” and “automorphism groups.” We will not discuss this further, but the idea
is that given two preorders P and Q, a Galois connection is a pair of maps back and
forth—from P to Q and from Q to P—with certain properties, which make it like a
relaxed version of isomorphisms. To be a bit more precise, preorder isomorphisms are
examples of Galois connections, but Galois connections need not be preorder isomor-
phisms.
Deﬁnition 1.95. A Galois connection between preorders P and Q is a pair of monotone
maps f : P →Q and 1 : Q →P such that
f (p) ≤q
if and only if
p ≤1(q).
(1.96)
We say that f is the left adjoint and 1 is the right adjoint of the Galois connection.
Example 1.97. Consider the map (3×−): Z →R which sends x ∈Z to 3x, which we can
consider as a real number 3x ∈Z ⊆R. Let’s ﬁnd a left adjoint for the map (3 × −).
Write ⌈z⌉for the smallest natural number above z ∈R, and write ⌊z⌋for the largest
integer below z ∈R, e.g. ⌈3.14⌉ 4 and ⌊3.14⌋ 3.a As the left adjoint R →Z, let’s see
if ⌈−/3⌉works.
It is easily checked that
⌈x/3⌉≤y if and only if x ≤3y.
Success! Thus we have a Galois connection between ⌈−/3⌉and (3 × −).
aBy “above” and “below,” we mean greater than or equal to or less than or equal to; the latter being a
mouthful. Anyway, ⌊3⌋ 3  ⌈3⌉.
Exercise 1.98. In Example 1.97 we found a left adjoint for the monotone map (3×−): Z →
R. Now ﬁnd a right adjoint for the same map, and show it is correct.
♦
Exercise 1.99.
Consider the preorder P  Q  3.
1. Let f , 1 be the monotone maps shown below:
P
1•
2•
3•
P
Q
•
1
•
2
•
3
Q
f
1
Is it the case that f is left adjoint to 1? Check that for each 1 ≤p, q ≤3, one has
f (p) ≤q iﬀp ≤1(q).

28
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Let f , 1 be the monotone maps shown below:
P
1•
2•
3•
P
Q
•
1
•
2
•
3
Q
f
1
Is it the case that f is left adjoint to 1?
♦
Remark 1.100. The pictures in Exercise 1.99 suggest the following idea. If P and Q are
total orders and f : P →Q and 1 : Q →P are drawn with arrows bending counter-
clockwise, then f is left adjoint to 1 iﬀthe arrows do not cross. With a little bit of
thought, this can be formalised. We think this is a pretty neat way of visualizing Galois
connections between total orders!
Exercise 1.101.
1. Does ⌈−/3⌉have a left adjoint L: Z →R?
2. If not, why? If so, does its left adjoint have a left adjoint?
♦
1.4.2
Back to partitions
Recall from Example 1.52 that we can understand the set Prt(S) of partitions on a set S
in terms of surjective functions out of S.
Suppose we are given any function 1 : S →T. We will show that this function 1
induces a Galois connection 1! : Prt(S) ⇆Prt(T) : 1∗, between preorder of S-partitions
and the preorder of T-partitions. The way you might explain it to a seasoned category
theorist is:
The left adjoint is given by taking any surjection out of S and pushing out
along 1 to get a surjection out of T. The right adjoint is given by taking any
surjection out of T, composing with 1 to get a function out of S, and then
taking the epi-mono factorization to get a surjection out of S.
S
T
P
P ⊔S T
1
c
⌜
S
T
im(1 # c)
P
1
1#c
c
By the end of this book, the reader will understand pushouts and epi-mono factoriza-
tions, so he or she will be able to make sense of the above statement. But for now we
will explain the process in more down-to-earth terms.
Start with 1 : S →T; we ﬁrst want to understand 1! : Prt(S) →Prt(T). So start with
a partition ∼S of S. To begin the process of obtaining a partition ∼T on T, say that two
elements t1, t2 ∈T are in the same part, t1 ∼T t2, if there exist s1, s2 ∈S with such
that s1 ∼S s2 and 1(s1)  t1 and 1(s2)  t2. However, the result of doing so will not

1.4. GALOIS CONNECTIONS
29
necessarily be transitive—you may get t1 ∼T t2 and t2 ∼T t3 without t1 ∼?
T t3—and
partitions must be transitive. So complete the process by just adding in the missing
pieces (take the transitive closure). The result is 1!(∼S) B∼T.
Again starting with 1, we want to get the right adjoint 1∗: Prt(T) →Prt(S). So start
with a partition ∼T of T. Get a partition ∼S on S by saying that s1 ∼S s2 iﬀ1(s1) ∼T 1(s2).
The result is 1∗(∼T) B∼S.
Example 1.102. Let S  {1, 2, 3, 4}, T  {12, 3, 4}, and 1 : S →T by 1(1) B 1(2) B 12,
1(3) B 3, and 1(4) B 4. The partition shown left below is translated by 1! to the
partition shown on the right.
1•
2•
3•
4•
partitioned S
3•
4•
12•
T
3•
4•
12•
partitioned T
{
Exercise 1.103.
There are 15 diﬀerent partitions of a set with four elements. Choose 6
diﬀerent ones and for each one, call it c : S ↠P, ﬁnd 1!(c), where S, T, and 1 : S →T
are the same as they were in Example 1.102.
♦
Example 1.104. Let S, T be as below, and let 1 : S →T be the function shown in blue.
Here is a picture of how 1∗takes a partition on T and “pulls it back” to a partition on S:
•
•
11
21
•
•
11
21
•
•
11
21
•
•
12
22
•
•
12
22
•
•
12
22
•
•
13
23
•
•
13
23
•
•
13
23
•
•
14
24
•
•
14
24
S
Partitioned T
{
Partitioned S
Exercise 1.105.
There are ﬁve partitions possible on a set with three elements, say
T  {12, 3, 4}. Using the same S and 1 : S →T as in Example 1.102, determine the
partition 1∗(c) on S for each of the ﬁve partitions c : T ↠P.
♦
To check that for any function 1 : S →T, the monotone map 1! : Prt(S) →Prt(T)
really is left adjoint to 1∗: Prt(T) →Prt(S) would take too much time for this sketch.
But the following exercise gives some evidence.
Exercise 1.106.
Let S, T, and 1 : S →T be as in Example 1.102.
1. Choose a nontrivial partition c : S ↠P and let 1!(c) be its push forward partition
on T.

30
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Choose any coarser partition d : T ↠P′, i.e. where 1!(c) ≤d.
3. Choose any non-coarser partition e : T ↠Q, i.e. where 1!(c) ≰e. (If you can’t do
this, revise your answer for #1.)
4. Find 1∗(d) and 1∗(e).
5. The adjunction formula Eq. (1.96) in this case says that since 1!(c) ≤d and
1!(c) ≰e, we should have c ≤1∗(d) and c ≰1∗(e). Show that this is true.
♦
1.4.3
Basic theory of Galois connections
Proposition 1.107. Suppose that f : P →Q and 1 : Q →P are monotone maps. The
following are equivalent
(a) f and 1 form a Galois connection where f is left adjoint to 1,
(b) for every p ∈P and q ∈Q we have
p ≤1( f (p))
and
f (1(q)) ≤q.
(1.108)
Proof. Suppose f is left adjoint to 1. Take any p ∈P, and let q B f (p). By reﬂexivity,
we have f (p) ≤q, so by the Deﬁnition 1.95 of Galois connection we have p ≤1(q), but
this means p ≤1( f (p)). The proof that f (1(q)) ≤q is similar.
Now suppose that Eq. (1.108) holds for all p ∈P and q ∈Q. We want show that
f (p) ≤q iﬀp ≤1(q). Suppose f (p) ≤q; then since 1 is monotonic, 1( f (p)) ≤1(q), but
p ≤1( f (p)) so p ≤1(q). The proof that p ≤1(q) implies f (p) ≤q is similar.
□
Exercise 1.109.
Complete the proof of Proposition 1.107 by showing that
1. if f is left adjoint to 1 then for any q ∈Q, we have f (1(q)) ≤q, and
2. if Eq. (1.108) holds, then holds p ≤1(q) iﬀf (p) ≤q holds, for all p ∈P and
q ∈Q.
♦
If we replace ≤with  in Eq. (1.108), we get back the deﬁnition of isomorphism
(Deﬁnition 1.75); this is why we said at the beginning of Section 1.4.1 that Galois
connections are a kind of relaxed version of isomorphisms.
Exercise 1.110.
1. Show that if f : P →Q has a right adjoint 1, then it is unique up to isomorphism.
That means, for any other right adjoint 1′, we have 1(q)  1′(q) for all q ∈Q.
2. Is the same true for left adjoints? That is, if h : P →Q has a left adjoint, is it
necessarily unique up to isomorphism?
♦

1.4. GALOIS CONNECTIONS
31
Proposition 1.111 (Right adjoints preserve meets). Let f : P →Q be left adjoint to
1 : Q →P. Suppose A ⊆Q any subset, and let 1(A) B {1(a) | a ∈A} be its image.
Then if A has a meet Ó A ∈Q then 1(A) has a meet Ó 1(A) in P, and we have
1
Û
A


Û
1(A).
That is, right adjoints preserve meets. Similarly, left adjoints preserve joins: if A ⊆P is
any subset that has a join Ô A ∈P, then f (A) has a join Ô f (A) in Q, and we have
f
Ü
A


Ü
f (A).
Proof. Let f : P →Q and 1 : Q →P be adjoint monotone maps, with 1 right adjoint to
f . Let A ⊆Q be any subset and let m B Ó A be its meet. Then since 1 is monotone
1(m) ≤1(a) for all a ∈A, so 1(m) is a lower bound for the set 1(A). We will be done if
we can show 1(m) is a greatest lower bound.
So take any other lower bound b for 1(A); that is suppose that for all a ∈A, we have
b ≤1(a) and we want to show b ≤1(m). Then by deﬁnition of 1 being a right adjoint
(Deﬁnition 1.95), we also have f (b) ≤a. This means that f (b) is a lower bound for A in
Q. Since the meet m is the greatest lower bound, we have f (b) ≤m. Once again using
the Galois connection, b ≤1(m), proving that 1(m) is indeed the greatest lower bound
for 1(A), as desired.
The second claim is proved similarly; see Exercise 1.112.
□
Exercise 1.112.
Complete the proof of Proposition 1.111 by showing that left adjoints
preserve joins.
♦
Since left adjoints preserve joins, we know that they cannot have generative eﬀects.
In fact, we will see in Theorem 1.115 that a monotone map does not have generative
eﬀects—i.e. it preserves joins—if and only if it is a left adjoint to some other monotone.
Example 1.113. Right adjoints need not preserve joins. Here is an example:
1•
2•
3.9•
4•
P B
1•
2•
4•
: Q
1
f
Let 1 be the map that preserves labels, and let f be the map that preserves labels as far
as possible but with f (3.9) B 4. Both are f and 1 monotonic, and one can check that 1

32
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
is right adjoint to f (see Exercise 1.114). But 1 does not preserve joins because 1 ∨2  4
holds in Q, whereas 1(1) ∨1(2)  1 ∨2  3.9 , 4  1(4) in P.
Exercise 1.114.
To be sure that 1 really is right adjoint to f in Example 1.113, there
are twelve tiny things to check; do so. That is, for every p ∈P and q ∈Q, check that
f (p) ≤q iﬀp ≤1(q).
♦
Theorem 1.115 (Adjoint functor theorem for preorders). Suppose Q is a preorder that
has all meets and let P be any preorder. A monotone map 1 : Q →P preserves meets
if and only if it is a right adjoint.
Similarly, if P has all joins and Q is any preorder, a monotone map f : P →Q
preserves joins if and only if it is a left adjoint.
Proof. We will only prove the claim about meets; the claim about joins follows similarly.
We proved one direction in Proposition 1.111, namely that right adjoints preserve
meets. For the other, suppose that 1 is a monotone map that preserves meets; we shall
construct a left adjoint f . We deﬁne our candidate f : P →Q on any p ∈P by
f (p) B
Û
{q ∈Q | p ≤1(q)};
(1.116)
this meet is well deﬁned because Q has all meets, but for f to really be a candidate, we
need to show it is monotone. So suppose that p ≤p′. Then {q′ ∈Q | p′ ≤1(q′)} ⊆{q ∈
Q | p ≤1(q)}. By Proposition 1.91, this implies f (p) ≤f (p′). Thus f is monotone.
By Proposition 1.111, it suﬃces to show that p0 ≤1( f (p0)) and that f (1(q0)) ≤q0
for all p0 ∈P and q0 ∈Q. For the ﬁrst, we have
p0 ≤
Û
{1(q) ∈P | p0 ≤1(q)}  1
Û
{q ∈Q | p0 ≤1(q)}

 1( f (p0)),
where the ﬁrst inequality follows from the fact that if p0 is below every element of a
set, then it is below their meet, and the isomorphism is by deﬁnition of 1 preserving
meets. For the second, we have
f (1(q0)) 
Û
{q ∈Q | 1(q0) ≤1(q)} ≤
Û
{q0}  q0,
where the ﬁrst inequality follows from Proposition 1.91 since {q0} ⊆{q ∈Q | 1(q0) ≤
1(q)}, and the fact that Ó{q0}  q0.
□
Example 1.117. Let f : A →B be a function between sets. We can imagine A as a set of
apples, B as a set of buckets, and f as putting each apple in a bucket.
Then we have the monotone map f ∗: P(Y) →P(X) that category theorists call
“pullback along f .” This map takes a subset B′ ⊆B to its preimage f −1(B′) ⊆A: that
is, it takes a collection B′ of buckets, and tells you all the apples that they contain in
total. This operation is monotonic (more buckets means more apples) and it has both
a left and a right adjoint.

1.4. GALOIS CONNECTIONS
33
The left adjoint f!(A) is given by the direct image: it maps a subset A′ ⊆A to
f!(A′) B {b ∈B | there exists a ∈A′ such that f (a)  b}
This map takes a set A′ of apples, and tells you all the buckets that contain at least one
of those apples.
The right adjoint f∗maps a subset A′ ⊆A to
f∗(A′) B {b ∈B | for all a such that f (a)  b, we have a ∈A′}
This map takes a set A′ of apples, and tells you all the buckets b that are all-A′: all the
apples in b are from the chosen subset A′. Note that if a bucket doesn’t contain any
apples at all, then vacuously all its apples are from A′, so empty buckets count as far
as f∗is concerned.
Notice that all three of these operations turn out to be interesting: start with a set
B′ of buckets and return all the apples in them, or start with a set A′ of apples and
either ﬁnd the buckets that contain at least one apple from A′, or the buckets whose
only apples are from A′. But we did not invent these mappings f ∗, f!, and f∗: they were
induced by the function f . They were automatic. It is one of the pleasures of category
theory that adjoints so often turn out to have interesting semantic interpretations.
Exercise 1.118.
Choose sets X and Y with between two and four elements each, and
choose a function f : X →Y.
1. Choose two diﬀerent subsets B1, B2 ⊆Y and ﬁnd f ∗(B1) and f ∗(B2).
2. Choose two diﬀerent subsets A1, A2 ⊆X and ﬁnd f!(A1) and f!(A2).
3. With the same A1, A2 ⊆X, ﬁnd f∗(A1) and f∗(A2).
♦
1.4.4
Closure operators
Given a Galois connection with f : P →Q left adjoint to 1 : Q →P, we may compose
f and 1 to arrive at a monotone map f # 1 : P →P from preorder P to itself. This
monotone map has the property that p ≤( f # 1)(p), and that ( f # 1 # f # 1)(p)  ( f # 1)(p)
for any p ∈P. This is an example of a closure operator.8
Exercise 1.119.
Suppose that f is left adjoint to 1. Use Proposition 1.107 to show the
following.
1. p ≤( f # 1)(p).
2. ( f # 1 # f # 1)(p)  ( f # 1)(p). To prove this, show inequalities in both directions,
≤and ≥.
♦
Deﬁnition 1.120. A closure operator j : P →P on a preorder P is a monotone map such
that for all p ∈P we have
8The other composite 1 # f satisﬁes the dual properties: (1 # f )(q) ≤q and (1 # f # 1 # f )(q)  (1 # f )(q)
for all q ∈Q. This is called an interior operator, though we will not discuss this concept further.

34
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
(a) p ≤j(p);
(b) j(j(p))  j(p).
Example 1.121. Here is an example of closure operators from computation, very roughly
presented. Imagine computation as a process of rewriting input expressions to output
expressions. For example, a computer can rewrite the expression 7+2+3 as the expres-
sion 12. The set of arithmetic expressions has a partial order according to whether one
expression can be rewritten as another.
We might think of a computer program, then, as a method of taking an expression
and reducing it to another expression. So it is a map j : exp →exp. It furthermore is
desirable to require that this computer program is a closure operator. Monotonicity
means that if an expression x can be rewritten into expression y, then the reduction j(x)
can be rewritten into j(y). Moreover, the requirement x ≤j(x) implies that j can only
turn one expression into another if doing so is a permissible rewrite. The requirement
j(j(x))  j(x) implies if you try to reduce an expression that has already been reduced,
the computer program leaves it as is. These properties provide useful structure in the
analysis of program semantics.
Example 1.122 (Adjunctions from closure operators). Just as every adjunction gives rise
to a closure operator, from every closure operator we may construct an adjunction.
Let P be a preorder and let j : P →P be a closure operator. We can deﬁne a preorder
ﬁxj to have elements the ﬁxed points of j; that is,
ﬁxj B {p ∈P | j(p)  p}.
This is a subset of P, and inherits an order as a result; hence ﬁxj is a sub-preorder of P.
Note that j(p) is a ﬁxed point for all p ∈P, since j(j(p))  j(p).
We deﬁne an adjunction with left adjoint j : P →ﬁxj sending p to j(p), and right
adjoint 1 : ﬁxj →P simply the inclusion of the sub-preorder.
To see it’s really an
adjunction, we need to see that for any p ∈P and q ∈ﬁxj, we have j(p) ≤q if and
only if p ≤q. Let’s check it. Since p ≤j(p), we have that j(p) ≤q implies p ≤q by
transitivity. Conversely, since q is a ﬁxed point, p ≤q implies j(p) ≤j(q)  q.
Example 1.123. Another example of closure operators comes from logic. This will be
discussed in the ﬁnal chapter of the book, in particular Section 7.4.5, but we will give a
quick overview here. In essence, logic is the study of when one formal statement—or
proposition—implies another. For example, if n is prime then n is not a multiple of
6, or if it is raining then the ground is getting wetter. Here “n is prime”, “n is not a
multiple of 6”, “it is raining”, and “the ground is getting wetter” are propositions, and

1.4. GALOIS CONNECTIONS
35
we gave two implications.
Take the set of all propositions, and order them by p ≤q iﬀp implies q, denoted
p ⇒q. Since p ⇒p and since whenever p ⇒q and q ⇒r, we also have p ⇒r, this is
indeed a preorder.
A closure operator on it is often called a modal operator. It is a function j from
propositions to propositions, for which p ⇒j(p) and j(j(p))  j(p). An example of a
j is “assuming Bob is in San Diego....” Think of this as a proposition B; so “assuming
Bob is in San Diego, p” means B ⇒p. Let’s see why B ⇒−is a closure operator.
If ‘p’ is true then “assuming Bob is in San Diego, p” is still true. Suppose that
“assuming Bob is in San Diego it is the case that, assuming Bob is in San Diego, p’ is
true.” It follows that “assuming Bob is in San Diego, p” is true. So we have seen, at
least informally, that “assuming Bob is in San Diego...” is a closure operator.
1.4.5
Level shifting
The last thing we want to discuss in this chapter is a phenomenon that happens often
in category theory, something we might informally call “level-shifting.” It is easier to
give an example of this than to explain it directly.
Given any set S, there is a set Rel(S) of binary relations on S. An element R ∈Rel(S)
is formally a subset R ⊆S × S. The set Rel(S) can be given an order via the subset
relation, R ⊆R′, i.e. if whenever R(s1, s2) holds then so does R′(s1, s2).
For example, the Hasse diagram for Rel({1}) is:
•
{(1,1)}
•
Exercise 1.124.
Draw the Hasse diagram for the preorder Rel({1, 2}) of all binary
relations on the set {1, 2}.
♦
For any set S, there is also a set Pos(S), consisting of all the preorder relations on S.
In fact there is a preorder structure ⊑on Pos(S), again given by inclusion: ≤is below
≤′ (we’ll write ≤⊑≤′) if a ≤b implies a ≤′ b for every a, b ∈S. A preorder of preorder
structures? That’s what we mean by a level shift.
Every preorder relation is—in particular—a relation, so we have an inclusion
Pos(S) →Rel(S).
This is the right adjoint of a Galois connection.
Its left adjoint
is a monotone map Cl: Rel(S) →Pos(S) given by taking any relation R, writing it in
inﬁx notation using ≤, and taking the reﬂexive and transitive closure, i.e. adding s ≤s
for every s and adding s ≤u whenever s ≤t and t ≤u.
Exercise 1.125.
Let S  {1, 2, 3}. Let’s try to understand the adjunction discussed
above.
1. Come up with any preorder relation ≤on S, and deﬁne U(≤) to be the subset
U(≤) B {(s1, s2) | s1 ≤s2} ⊆S ×S, i.e. U(≤) is the image of ≤under the inclusion
Pos(S) →Rel(S), the relation ‘underlying’ the preorder.

36
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Come up with any two binary relations Q ⊆S × S and Q′ ⊆S × S such that
Q ⊆U(≤) but Q′ ̸⊆U(≤). Note that your choice of Q, Q′ do not have to come
from preorders.
We now want to check that in this case, the closure operation Cl is really left adjoint to
the ‘underlying relation’ map U.
3. Concretely (without using the assertion that there is some sort of adjunction),
show that Cl(Q) ⊑≤, where ⊑is the order on Pos(S), deﬁned immediately above
this exercise.
4. Concretely show that Cl(Q′) @ ≤.
♦
1.5
Summary and further reading
In this ﬁrst chapter, we set the stage for category theory by introducing one of the
simplest interesting sorts of example: preorders. From this seemingly simple structure,
a bunch of further structure emerges: monotone maps, meets, joins, and more. In terms
of modeling real world phenomena, we thought of preorders as the states of a system,
and monotone maps as describing a way to use one system to observe another. From
this point of view, generative eﬀects occur when observations of the whole cannot be
deduced by combining observations of the parts.
In the ﬁnal section we introduced Galois connections.
A Galois connection, or
adjunction, is a pair of maps that are like inverses, but allowed to be more “relaxed” by
getting the orders involved. Perhaps surprisingly, it turns out adjunctions are closely
related to joins and meets: if a preorder P has all joins, then a monotone map out of P
is a left adjoint if and only if it preserves joins; similarly for meets and right adjoints.
The next two chapters build signiﬁcantly on this material, but in two diﬀerent
directions. Chapter 2 adds a new operation on the underlying set: it introduces the
idea of a monoidal structure on preorders. This allows us to construct an element a ⊗b
of a preorder P from any elements a, b ∈P, in a way that respects the order. On the
other hand, Chapter 3 adds new structure on the order itself: it introduces the idea
of a morphism, which describes not only whether a ≤b, but gives a name f for how
a relates to b. This structure is known as a category. These generalizations are both
fundamental to the story of compositionality, and in Chapter 4 we’ll see them meet in
the concept of a monoidal category. The lessons we have learned in this chapter will
illuminate the more highly-structured generalizations in the chapters to come. Indeed,
it is a useful principle in studying category theory to try to understand concepts ﬁrst
in the setting of preorders—where often much of the complexity is stripped away and
one can develop some intuition—before considering the general case.
But perhaps you might be interested in exploring some ideas in this chapter in other
directions. While we won’t return to them in this book, we learned about generative
eﬀects from Elie Adam’s thesis [Ada17], and a much richer treatment of generative

1.5. SUMMARY AND FURTHER READING
37
eﬀect can be found there. In particular, he discusses abelian categories and cohomology,
providing a way to detect generative eﬀects in quite a general setting.
Another important application of preorders, monotone maps, and Galois connec-
tions is to the analysis of programming languages. In this setting, preorders describe
the possible states of a computer, and monotone maps describe the action of programs,
or relationships between diﬀerent ways of modeling computation states. Galois con-
nections are useful for showing how diﬀerent models may be closely related, and for
transporting program analysis from one framework to another. For more detail on this,
see Chapter 4 of the textbook [NNH99].


Chapter 2
Resource theories:
Monoidal preorders and enrichment
2.1
Getting from a to b
You can’t make an omelette without breaking an egg. To obtain the things we want
requires resources, and the process of transforming what we have into what we want
is often an intricate one. In this chapter, we will discuss how monoidal preorders can
help us think about this matter.
Consider the following three questions you might ask yourself:
• Given what I have, is it possible to get what I want?
• Given what I have, what is the minimum cost to get what I want?
• Given what I have, what is the set of ways to get what I want?
These questions are about resources—those you have and those you want—but perhaps
more importantly, they are about moving from have to want: possibility of, cost of, and
ways to.
Such questions come up not only in our lives, but also in science and industry.
In chemistry, one asks whether a certain set of compounds can be transformed into
another set, how much energy such a reaction will require, or what methods exist for
making it happen. In manufacturing, one asks similar questions.
From an external point of view, both a chemist and an industrial ﬁrm might be
regarded as store-houses of information on the above subjects. The chemist knows
which compounds she can make given other ones, and how to do so; the ﬁrm has
stored knowledge of the same sort. The research work of the chemist and the ﬁrm is to
use what they know in order to derive—or discover—new knowledge.
This is roughly the ﬁrst goal of this chapter: to discuss a formalism for expressing
recipes—methods for transforming one set of resources into another—and for deriving
new recipes from old. The idea here is not complicated, neither in life nor in our
mathematical formalism. The value added then is to simply see how it works, so we
39

40
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
can build on it within the book, and so others can build on it in their own work.
We brieﬂy discuss the categorical approach to this idea—namely that of monoidal
preorders—for building new recipes from old. The following wiring diagram shows,
assuming one knows how to implement each of the interior boxes, how to implement
the preparation of a lemon meringue pie:
make
lemon
ﬁlling
make
meringue
separate
egg
ﬁll crust
add
meringue
prepare lemon meringue pie
prepared crust
lemon
butter
sugar
egg
sugar
yolk
white
lemon
ﬁlling
unbaked
lemon pie
meringue
unbaked
pie
(2.1)
The wires show resources: we start with prepared crust, lemon, butter, sugar, and egg
resources, and we end up with an unbaked pie resource. We could take this whole
method and combine it with others, e.g. baking the pie:
prepare lemon meringue pie
bake pie
oven
unbaked
pie
baked pie
oven
In the above example we see that resources are not always consumed when they are
used. For example, we use an oven to convert—or catalyze the transformation of—an
unbaked pie into a baked pie, and we get the oven back after we are done. It’s a nice
feature of ovens! To use economic terms, the oven is a “means of production” for pies.
String diagrams are important mathematical objects that will come up repeatedly
in this book. They were invented in the mathematical context—more speciﬁcally in the
context of monoidal categories—by Joyal and Street [JS93], but they have been used
less formally by engineers and scientists in various contexts for a long time.
As we said above, our ﬁrst goal in this chapter is to use monoidal preorders, and
the corresponding wiring diagrams, as a formal language for recipes from old. Our
second goal is to discuss something called V-categories for various monoidal preorders
V.

2.2. SYMMETRIC MONOIDAL PREORDERS
41
A V-category is a set of objects, which one may think of as points on a map, where
V somehow “structures the question” of getting from point a to point b. The examples
of monoidal preorders V that we will be most interested in are called Bool and Cost.
Roughly speaking, a Bool-category is a set of points where the question of getting from
point a to point b has a true / false answer. A Cost-category is a set of points where
the question of getting from a to b has an answer d ∈[0, ∞], a cost.
This story works in more generality than monoidal preorders. Indeed, in Chapter 4
we will discuss something called a monoidal category, a notion which generalizes
monoidal preorders, and we will generalize the deﬁnition of V-category accordingly.
In this more general setting, V-categories can also address our third question above,
describing methods of getting between points. For example a Set-category is a set of
points where the question of getting from point a to point b has a set of answers
(elements of which might be called methods).
We will begin in Section 2.2 by deﬁning symmetric monoidal preorders, giving a
few preliminary examples, and discussing wiring diagrams. We then give many more
examples of symmetric monoidal preorders, including both some real-world examples,
in the form of resource theories, and some mathematical examples that will come up
again throughout the book. In Section 2.3 we discuss enrichment and V-categories—
how a monoidal preorder V can “structure the question” of getting from a to b—and
then give some important constructions on V-categories (Section 2.4), and analyze them
using a sort of matrix multiplication technique (Section 2.5).
2.2
Symmetric monoidal preorders
In Section 1.2.2 we introduced preorders. The notation for a preorder, namely (X, ≤),
refers to two pieces of structure: a set called X and a relation called ≤that is reﬂexive
and transitive.
We want to add to the concept of preorders a way of combining elements in X, an
operation taking two elements and adding or multiplying them together. However,
the operation does not have to literally be addition or multiplication; it only needs to
satisfy some of the properties one expects from them.
2.2.1
Deﬁnition and ﬁrst examples
We begin with a formal deﬁnition of symmetric monoidal preorders.
Deﬁnition 2.2. A symmetric monoidal structure on a preorder (X, ≤) consists of two
constituents:
(i) an element I ∈X, called the monoidal unit, and
(ii) a function ⊗: X × X →X, called the monoidal product.
These constituents must satisfy the following properties, where we write ⊗(x1, x2) 
x1 ⊗x2:

42
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
(a) for all x1, x2, y1, y2 ∈X, if x1 ≤y1 and x2 ≤y2, then x1 ⊗x2 ≤y1 ⊗y2,
(b) for all x ∈X, the equations I ⊗x  x and x ⊗I  x hold,
(c) for all x, y, z ∈X, the equation (x ⊗y) ⊗z  x ⊗(y ⊗z) holds, and
(d) for all x, y ∈X, the equation x ⊗y  y ⊗x holds.
We call these conditions monotonicity, unitality, associativity, and symmetry respectively.
A preorder equipped with a symmetric monoidal structure, (X, ≤, I, ⊗), is called a
symmetric monoidal preorder.
Anyone can propose a set X, an order ≤on X, an element I in X, and a binary
operation ⊗on X and ask whether (X, ≤, I, ⊗) is a symmetric monoidal preorder. And
it will indeed be one, as long as it satisﬁes rules a, b, c, and d of Deﬁnition 2.2.
Remark 2.3. It is often useful to replace  with  throughout Deﬁnition 2.2. The result is
a perfectly good notion, called a weak monoidal structure. The reason we chose equality
is that it makes equations look simpler, which we hope aids ﬁrst-time readers.
The notation for the monoidal unit and the monoidal product may vary: monoidal
units we have seen include I (as in the deﬁnition), 0, 1, true, false, {∗}, and more.
Monoidal products we have seen include ⊗(as in the deﬁnition), +, ∗, ∧, ∨, and ×. The
preferred notation in a given setting is whatever best helps our brains remember what
we’re trying to do; the names I and ⊗are just defaults.
Example 2.4. There is a well-known preorder structure, denoted ≤, on the set R of real
numbers; e.g. −5 ≤
√
2. We propose 0 as a monoidal unit and +: R × R →R as a
monoidal product. Does (R, ≤, 0, +) satisfy the conditions of Deﬁnition 2.2?
If x1 ≤y1 and x2 ≤y2, it is true that x1 + x2 ≤y1 + y2. It is also true that 0 + x  x
and x + 0  x, that (x + y) + z  x + (y + z), and that x + y  y + x. Thus (R, ≤, 0, +)
satisﬁes the conditions of being a symmetric monoidal preorder.
Exercise 2.5.
Consider again the preorder (R, ≤) from Example 2.4. Someone proposes
1 as a monoidal unit and ∗(usual multiplication) as a monoidal product. But an expert
walks by and says “that won’t work.” Figure out why, or prove the expert wrong!
♦
Example 2.6. A monoid consists of a set M, a function ∗: M × M →M called the monoid
multiplication, and an element e ∈M called the monoid unit, such that, when you write
∗(m, n) as m ∗n, i.e. using inﬁx notation, the equations
m ∗e  m,
e ∗m  m,
(m ∗n) ∗p  m ∗(n ∗p)
(2.7)
hold for all m, n, p ∈M. It is called commutative if also m ∗n  n ∗m.
Every set S determines a discrete preorder DiscS (where m ≤n iﬀm  n; see
Example 1.32), and it is easy to check that if (M, e, ∗) is a commutative monoid then
(DiscM, , e, ∗) is a symmetric monoidal preorder.

2.2. SYMMETRIC MONOIDAL PREORDERS
43
Exercise 2.8.
We said it was easy to check that if (M, ∗, e) is a commutative monoid
then (DiscM, , ∗, e) is a symmetric monoidal preorder. Are we telling the truth?
♦
Example 2.9. Here is a non-example for people who know the game “standard poker.”
Let H be the set of all poker hands, where a hand means a choice of ﬁve cards from the
standard 52-card deck. As an order, put h ≤h′ if h′ beats or equals h in poker.
One could propose a monoidal product ⊗: H × H →H by assigning h1 ⊗h2 to be
“the best hand one can form out of the ten cards in h1 and h2.” If some cards are in
both h1 and h2, just throw the duplicates away. So for example {2♥, 3♥, 4♥, 6♠, 7♠} ⊗
{2♥, 5♥, 6♥, 6♠, 7♠}  {2♥, 3♥, 4♥, 5♥, 6♥}, because the latter is the best hand you
can make with the former two.
This proposal for a monoidal structure will fail the condition (a) of Deﬁnition 2.2: it
could be the case that h1 ≤i1 and h2 ≤i2, and yet not be the case that h1 ⊗h2 ≤i1 ⊗i2.
For example, consider this case:
h1 B {2♥, 3♥, 10♠, J♠, Q♠}
i1 B {4♣, 4♠, 6♥, 6♦, 10♦}
h2 B {2♦, 3♦, 4♦, K♠, A♠}
i2 B {5♠, 5♥, 7♥, J♦, Q♦}.
Here, h1 ≤i1 and h2 ≤i2, but h1 ⊗h2  {10♠, J♠, Q♠, K♠, A♠} is the best possible
hand and beats i1 ⊗i2  {5♠, 5♥, 6♥, 6♦, Q♦}.
Subsections 2.2.3 and 2.2.4 are dedicated to examples of symmetric monoidal pre-
orders. Some are aligned with the notion of resource theories, others come from pure
math. When discussing the former, we will use wiring diagrams, so here is a quick
primer.
2.2.2
Introducing wiring diagrams
Wiring diagrams are visual representations for building new relationships from old. In
a preorder without a monoidal structure, the only sort of relationship between objects
is ≤, and the only way you build a new ≤relationship from old ones is by chaining
them together. We denote the relationship x ≤y by
≤
x
y
(2.10)
We can chain some number of these ≤-relationships—say 0, 1, 2, or 3 of them—together
in series as shown here
≤
x0
≤
x0
x1
≤
≤
x0
x1
x2
≤
≤
≤
x0
x1
x2
x3
· · ·
(2.11)

44
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
If we add a symmetric monoidal structure, we can combine relationships not only
in series but also in parallel. Here is an example:
≤
≤
≤
t
u
v
w
x
y
z
(2.12)
Diﬀerent styles of wiring diagrams
In fact, we will see later that there are many styles
of wiring diagrams. When we are dealing with preorders, the sort of wiring diagram
we can draw is that with single-input, single-output boxes connected in series. When
we are dealing with symmetric monoidal preorders, we can have more complex boxes
and more complex wiring diagrams, including parallel composition. Later we will see
that for other sorts of categorical structures, there are other styles of wiring diagrams:
(2.13)
Wiring diagrams for symmetric monoidal preorders
The style of wiring diagram
that makes sense in any symmetric monoidal preorder is that shown in Eq. (2.12): boxes
can have multiple inputs and outputs, and they may be arranged in series and parallel.
Symmetric monoidal preorders and their wiring diagrams are tightly coupled with
each other. How so?
The answer is that a monoidal preorder (X, ≤, I, ⊗) has some notion of element
(x ∈X), relationship (≤), and combination (using transitivity and ⊗), and so do wiring
diagrams: the wires represent elements, the boxes represent relationships, and the
wiring diagrams themselves show how relationships can be combined. We call boxes
and wires icons; we will encounter several more icons in this chapter, and throughout
the book.
To get a bit more rigorous about the connection, let’s start with a monoidal preorder
(X, ≤, I, ⊗) as in Deﬁnition 2.2. Wiring diagrams have wires on the left and the right.
Each element x ∈X can be made the label of a wire. Note that given two objects x, y,
we can either draw two wires in parallel—one labeled x and one labeled y—or we can
draw one wire labeled x ⊗y.
x
y
x ⊗y
We consider wires in parallel to represent the monoidal product of their labels, so we
consider both cases above to represent the element x ⊗y. Note also that a wire labeled

2.2. SYMMETRIC MONOIDAL PREORDERS
45
I or an absence of wires:
I
nothing
both represent the monoidal unit I; another way of thinking of this is that the unit is
the empty monoidal product.
A wiring diagram runs between a set of parallel wires on the left and a set of parallel
wires on the right. We say that a wiring diagram is valid if the monoidal product of
the elements on the left is less than the monoidal product of those on the right. For
example, if we have the inequality x ≤y, the the diagram that is a box with a wire
labeled x on the left and a wire labeled y on the right is valid; see the ﬁrst box below:
≤
x
y
≤
x1
x2
y1
y2
y3
The validity of the second box corresponds to the inequality x1 ⊗x2 ≤y1 ⊗y2 ⊗y3.
Before going on to the properties from Deﬁnition 2.2, let us pause for an example of
what we’ve discussed so far.
Example 2.14. Recall the symmetric monoidal preorder (R, ≤, 0, +) from Example 2.4.
The wiring diagrams for it allow wires labeled by real numbers. Drawing wires in
parallel corresponds to adding their labels, and the wire labeled 0 is equivalent to no
wires at all.
3.14
−1
3.14
−1
=
2.14
0
=
nothing
And here we express a couple facts about (R, ≤, 0, +) in this language: 4 ≤7 and
2 + 5 ≤−1 + 5 + 3.
≤
4
7
≤
2
5
−1
5
3
We now return to how the properties of symmetric monoidal preorders correspond
to properties of this sort of wiring diagram. Let’s ﬁrst talk about the order structure:
conditions (a)—reﬂexivity—and (b)—transitivity—from Deﬁnition 1.30. Reﬂexivity
says that x ≤x, this means the diagram just consisting of a wire
x
is always valid. Transitivity allows us to connect facts together: it says that if x ≤y
and y ≤z, then x ≤z. This means that if the diagrams
≤
x
y
and
≤
y
z

46
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
are valid, we can put them together and obtain the valid diagram
≤
x
≤
y
z
Next let’s talk about the properties(a)–(d)fromthedeﬁnitionofsymmetricmonoidal
structure (Deﬁnition 2.2). Property (a) says that if x1 ≤y1 and x2 ≤y2 then x1 ⊗x2 ≤
y1 ⊗y2. This corresponds to the idea that stacking any two valid boxes in parallel is
still valid:
≤
≤
≤
{
x1
x2
y1
y2
x1
x2
y1
y2
Condition (b), that I ⊗x  x and x ⊗I  x, says we don’t need to worry about I or
blank space; in particular diagrams such as the following are valid:
x
nothing
x
Condition (c), that (x ⊗y) ⊗z  x ⊗(y ⊗z) says that we don’t have to worry about
whether we build up diagrams from the top or from the bottom
x
y
=
x ⊗y
z
=
x
y ⊗z
=
y
z
But this looks much harder than it is: the associative property should be thought of as
saying that there is no distinction between the stuﬀon the very left above and the stuﬀ
on the very right, i.e.
x
y
z
=
x
y
z
and indeed a diagram that moves from one to the other is valid.
Finally, the symmetry condition (d), that x ⊗y  y ⊗x, says that a diagram is valid
even if its wires cross:
x
y
y
x
y
x
x
y
One may regard the pair of crossing wires as another icon in our iconography, in
addition to the boxes and wires we already have.

2.2. SYMMETRIC MONOIDAL PREORDERS
47
Wiring diagrams as graphical proofs
Given a monoidal preorder X  (X, ≤, I, ⊗), a
wiring diagram is a graphical proof of something about X. Each box in the diagram
has a left side and a right side, say x and y, and represents the assertion that x ≤y.
≤
x
y
A wiring diagram is a bunch of interior boxes connected together inside an exterior
box. It represents a graphical proof that says: if all of the interior assertions are correct,
then so is the exterior assertion.
≤
≤
≤
t
u
v
w
x
y
z
(2.15)
The inner boxes in Eq. (2.15) translate into the assertions:
t ≤v + w
w + u ≤x + z
v + x ≤y
(2.16)
and the outer box translates into the assertion:
t + u ≤y + z.
(2.17)
The whole wiring diagram 2.15 says “if you know that the assertions in 2.16 are true,
then I am a proof that the assertion in 2.17 is also true.” What exactly is the proof that
diagram 2.15 represents? It is the proof
t + u ≤v + w + u ≤v + x + z ≤y + z.
(2.18)
Indeed, each inequality here is a vertical slice of the diagram 2.15, and the transitivity
of these inequalities is expressed by connecting these vertical slices together.
Example 2.19. Recall the lemon meringue pie wiring diagram from Eq. (2.1). It has ﬁve
interior boxes, such as “separate egg” and “ﬁll crust,” and it has one exterior box called
“prepare lemon meringue pie.” Each box is the assertion that, given the collection of
resources on the left, say an egg, you can transform it into the collection of resources on
the right, say an egg white and an egg yolk. The whole string diagram is a proof that
if each of the interior assertions is true—i.e. you really do know how to separate eggs,
make lemon ﬁlling, make meringue, ﬁll crust, and add meringue—then the exterior
assertion is true: you can prepare a lemon meringue pie.
Exercise 2.20.
The string of inequalities in Eq. (2.18) is not quite a proof, because
technically there is no such thing as v + w + u, for example. Instead, there is (v + w) + u
and v + (w + u), and so on.

48
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
1. Formally prove, using only the rules of symmetric monoidal preorders (Deﬁ-
nition 2.2), that given the assertions in Eq. (2.16), the conclusion in Eq. (2.17)
follows.
2. Reﬂexivity and transitivity should show up in your proof. Make sure you are
explicit about where they do.
3. How can you look at the wiring diagram Eq. (2.12) and know that the symmetry
axiom (Deﬁnition 2.2(d)) does not need to be invoked?
♦
We next discuss some examples of symmetric monoidal preorders. We begin in
Section 2.2.3 with some more concrete examples, from science, commerce, and infor-
matics. Then in Section 2.2.4 we discuss some examples arising from pure math, some
of which will get a good deal of use later on, e.g. in Chapter 4.
2.2.3
Applied examples
Resource theories are studies of how resources are exchanged in a given arena. For
example, in social resource theory one studies a marketplace where combinations of
goods can be traded for—as well as converted into—other combinations of goods.
Whereas marketplaces are very dynamic, and an apple might be tradable for an
orange on Sunday but not on Monday, what we mean by resource theory in this
chapter is a static notion: deciding “what buys what,” once and for all.1 This sort of
static notion of conversion might occur in chemistry: the chemical reactions that are
possible one day will quite likely be possible on a diﬀerent day as well. Manufacturing
may be somewhere in between: the set of production techniques—whereby a company
can convert one set of resources into another—do not change much from day to day.
We learned about resource theories from [CFS16; Fri17], who go much further than
we will; see Section 2.6 for more information. In this section we will focus only on
the main idea. While there are many beautiful mathematical examples of symmetric
monoidal preorders, as we will see in Section 2.2.4, there are also ad hoc examples
coming from life experience. In the next chapter, on databases, we will see the same
theme: while there are some beautiful mathematical categories out there, database
schemas are ad hoc organizational patterns of information. Describing something as
“ad hoc” is often considered derogatory, but it just means “formed, arranged, or done
for a particular purpose only.” There is nothing wrong with doing things for a particular
purpose; it’s common outside of pure math and pure art. Let’s get to it.
Chemistry
In high school chemistry, we work with chemical equations, where mate-
rial collections such as
H2O,
NaCl,
2NaOH,
CH4 + 3O2
1Using some sort of temporal theory, e.g. the one presented in Chapter 7, one could take the notion
here and have it change in time.

2.2. SYMMETRIC MONOIDAL PREORDERS
49
are put together in the form of reaction equations, such as
2H2O + 2Na →2NaOH + H2.
The collection on the left, 2H2O + 2Na is called the reactant, and the collection on the
right, 2NaOH + H2 is called the product.
We can consider reaction equations such as the one above as taking place inside a
single symmetric monoidal preorder (Mat, →, 0, +). Here Mat is the set of all collections
of atoms and molecules, sometimes called materials.
So we have NaCl ∈Mat and
4H2O + 6Ne ∈Mat.
The set Mat has a preorder structure denoted by the →symbol, which is the
preferred symbol in the setting of chemistry. To be clear, →is taking the place of
the order relation ≤from Deﬁnition 2.2. The + symbol is the preferred notation for
the monoidal product in the chemistry setting, taking the place of ⊗. While it does not
come up in practice, we use 0 to denote the monoidal unit.
Exercise 2.21.
Here is an exercise for people familiar with reaction equations: check
that conditions (a), (b), (c), and (d) of Deﬁnition 2.2 hold.
♦
An important notion in chemistry is that of catalysis: one compound catalyzes a
certain reaction. For example, one might have the following set of reactions:
y + k →y′ + k′
x + y′ →z′
z′ + k′ →z + k
(2.22)
Using the laws of monoidal preorders, we obtain the composed reaction
x + y + k →x + y′ + k′ →z′ + k′ →z + k.
(2.23)
Here k is the catalyst because it is found both in the reactant and the product of the
reaction. It is said to catalyze the reaction x + y →z. The idea is that the reaction
x+ y →z cannot take place given the reactions in Eq. (2.22). But if k is present, meaning
if we add k to both sides, the resulting reaction can take place.
The wiring diagram for the reaction in Eq. (2.23) is shown in Eq. (2.24). The three
interior boxes correspond to the three reactions given in Eq. (2.22), and the exterior box
corresponds to the composite reaction x + y + k →z + k.
→
→
→
y
k
x
y′
k′
z′
z
k
(2.24)
Manufacturing
Whether we are talking about baking pies, building smart phones,
or following pharmaceutical recipes, manufacturing ﬁrms need to store basic recipes,
and build new recipes by combining simpler recipes in schemes like the one shown in
Eq. (2.1) or Eq. (2.24).

50
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
The basic idea in manufacturing is exactly the same as that for chemistry, except
there is an important assumption we can make in manufacturing that does not hold
for chemical reactions:
You can trash anything you want, and it disappears from view.
This simple assumption has caused the world some signiﬁcant problems, but it is still
in eﬀect. In our meringue pie example, we can ask: “what happened to the egg shell, or
the paper wrapping the stick of butter”? The answer is they were trashed, i.e. thrown
in the garbage bin. It would certainly clutter our diagram and our thinking if we had
to carry these resources through the diagram:
make
lemon
ﬁlling
make
meringue
separate
egg
ﬁll crust
add
meringue
prepare lemon meringue pie, keeping track of waste
crust
lemon
butter
sugar
egg
sugar
yolk
egg shells
white
lemon
ﬁlling
lemon peel
butter wrapper
unbaked
lemon pie
meringue
unbaked
pie
Instead, in our daily lives and in manufacturing, we do not have to hold on to
something if we don’t need it; we can just discard it. In terms of wiring diagrams, this
can be shown using a new icon
, as follows:
•
discard
(2.25)
To model this concept of waste using monoidal categories, one just adds an addi-
tional axiom to (a), (b), (c), and (d) from Deﬁnition 2.2:
(e) x ≤I for all x ∈X.
(discard axiom)
It says that every x can be converted into the monoidal unit I. In the notation of the
chemistry section, we would write instead x →0: any x yields nothing. But this is
certainly not accepted in the chemistry setting. For example,
H2O + NaCl →? H2O

2.2. SYMMETRIC MONOIDAL PREORDERS
51
is certainly not a legal chemical equation. It is easy to throw things away in manufac-
turing, because we assume that we have access to—the ability to grab onto and directly
manipulate—each item produced. In chemistry, when you have 1023 of substance A
dissolved in something else, you cannot just simply discard A. So axiom (e) is valid in
manufacturing but not in chemistry.
Recall that in Section 2.2.2 we said that there were many diﬀerent styles of wiring
diagrams. Now we’re saying that adding the discard axiom changes the wiring diagram
style, in that it adds this new discard icon that allows wires to terminate, as shown in
Eq. (2.25). In informatics, we will change the wiring diagram style yet again.
Informatics
A major diﬀerence between information and a physical object is that
information can be copied. Whereas one cup of butter never becomes two, it is easy for
a single email to be sent to two diﬀerent people. It is much easier to copy a music ﬁle
than it is to copy a CD. Here we do not mean “copy the information from one compact
disc onto another”—of course that’s easy—instead, we mean that it’s quite diﬃcult
to copy the physical disc, thereby forming a second physical disc! In diagrams, the
distinction is between the relation
copy cd
Beyoncé cd
blank cd
Beyoncé cd
Beyoncé cd
and the relation
no, I mean
literally copy cd!
Beyoncé cd
Beyoncé cd
Beyoncé cd
The former is possible, the latter is magic.
Of course material objects can sometimes be copied; cell mitosis is a case in point.
But this is a remarkable biological process, certainly not something that is expected
for ordinary material objects. In the physical world, we would make mitosis a box
transforming one cell into two. But in (classical, not quantum) information, everything
can be copied, so we add a new icon to our repertoire.
Namely, in wiring diagram notation, copying information appears as a new icon,
, allowing us to split wires:
write
•
calendar
maps
email
email
email

52
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Now with two copies of the email, we can send one to Alice and one to Bob.
write
•
send to Alice
send to Bob
calendar
maps
email
email
email
email sent to Alice
email sent to Bob
(2.26)
Information can also be discarded, at least in the conventional way of thinking, so
in addition to axioms (a) to (d) from Deﬁnition 2.2, we can keep axiom (e) from page 50
and add a new copy axiom:
(f) x ≤x + x for all x ∈X.
(copy axiom)
allowing us to make mathematical sense of diagrams like Eq. (2.26).
Now that we have examples of monoidal preorders under our belts, let’s discuss
some nice mathematical examples.
2.2.4
Abstract examples
In this section we discuss several mathematical examples of symmetric monoidal struc-
tures on preorders.
The Booleans
The simplest nontrivial preorder is the booleans: B  {true, false}
with false ≤true. There are two diﬀerent symmetric monoidal structures on it.
Example 2.27 (Booleans with AND). We can deﬁne a monoidal structure on B by letting
the monoidal unit be true and the monoidal product be ∧(AND). If one thinks of
false  0 and true  1, then ∧corresponds to the usual multiplication operation ∗.
That is, with this correspondence, the two tables below match up:
∧
false
true
false
false
false
true
false
true
∗
0
1
0
0
0
1
0
1
(2.28)
One can check that all the properties in Deﬁnition 2.2 hold, so we have a monoidal
preorder which we denote Bool B (B, ≤, true, ∧).
Bool will be important when we get to the notion of enrichment. Enriching in a
monoidal preorder V  (V, ≤, I, ⊗) means “letting V structure the question of getting
from a to b.” All of the structures of a monoidal preorder—i.e. the set V, the ordering
relation ≤, the monoidal unit I, and the monoidal product ⊗—play a role in how
enrichment works.

2.2. SYMMETRIC MONOIDAL PREORDERS
53
For example, let’s look at the case of Bool  (B, ≤, true, ∧).
The fact that its
underlying set is B  {false, true} will translate into saying that “getting from a to b
is a true/false question.” The fact that true is the monoidal unit will translate into
saying “you can always get from a to a.” The fact that ∧is the monoidal product will
translate into saying “if you can get from a to b AND you can get from b to c then you
can get from a to c.” Finally, the “if-then” form of the previous sentence is coming from
the order relation ≤. We will make this more precise in Section 2.3.
We will be able to play the same game with other monoidal preorders, as we will
see after we deﬁne a monoidal preorder called Cost in Example 2.37.
Some other monoidal preorders
It is a bit imprecise to call Bool “the” boolean
monoidal preorder, because there is another monoidal structure on (B, ≤), which we
describe in Exercise 2.29. The ﬁrst structure, however, seems to be more useful in
practice than the second.
Exercise 2.29.
Let (B, ≤) be as above, but now consider the monoidal product to be ∨
(OR).
∨
false
true
false
false
true
true
true
true
max
0
1
0
0
1
1
1
1
What must the monoidal unit be in order to satisfy the conditions of Deﬁnition 2.2?
Does it satisfy the rest of the conditions?
♦
In Example 2.30 and Exercise 2.31 we give two diﬀerent monoidal structures on the
preorder (N, ≤) of natural numbers, where ≤is the usual ordering (0 ≤1 and 5 ≤16).
Example 2.30 (Natural numbers with addition). There is a monoidal structure on (N, ≤)
where the monoidal unit is 0 and the monoidal product is +, i.e. 6 + 4  10. It is easy
to check that x1 ≤y1 and x2 ≤y2 implies x1 + x2 ≤y1 + y2, as well as all the other
conditions of Deﬁnition 2.2.
Exercise 2.31.
Show there is a monoidal structure on (N, ≤) where the monoidal
product is ∗, i.e. 6 ∗4  24. What should the monoidal unit be?
♦
Example 2.32 (Divisibility and multiplication). Recall from Example 1.45 that there is
a “divisibility” order on N: we write m|n to mean that m divides into n without
remainder. So 1|m for all m and 4|12.
There is a monoidal structure on (N, | ), where the monoidal unit is 1 and the
monoidal product is ∗, i.e. 6 ∗4  24. Then if x1|y1 and x2|y2, then (x1 ∗x2)|(y1 ∗y2).
Indeed, if there is some p1, p2 ∈N such that x1 ∗p1  y1 and x2 ∗p2  y2, then
(p1 ∗p2) ∗(x1 ∗x2)  y1 ∗y2.

54
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Exercise 2.33.
Again taking the divisibility order (N, | ). Someone proposes 0 as the
monoidal unit and + as the monoidal product. Does that proposal satisfy the conditions
of Deﬁnition 2.2? Why or why not?
♦
Exercise 2.34.
Consider the preorder (P, ≤) with Hasse diagram no →maybe →yes .
We propose a monoidal structure with yes as the monoidal unit and “min” as the
monoidal product.
1. Make sense of “min” by ﬁlling in the multiplication table with elements of P.
min
no
maybe
yes
no
?
?
?
maybe
?
?
?
yes
?
?
?
2. Check the axioms of Deﬁnition 2.2 hold for NMY B (P, ≤, yes, min), given your
deﬁnition of min. If not, change your deﬁnition of min.
♦
Exercise 2.35.
Let S be a set and let P(S) be its power set, the set of all subsets of
S, including the empty subset,  ⊆S, and the “everything” subset, S ⊆S. We can
give P(S) an order: A ≤B is given by the subset relation A ⊆B, as discussed in
Example 1.50. We propose a symmetric monoidal structure on P(S) with monoidal
unit S and monoidal product given by intersection A ∩B.
Does it satisfy the conditions of Deﬁnition 2.2?
♦
Exercise 2.36.
Let PropN denote the set of all mathematical statements one can make
about a natural number, where we consider two statements to be the same if one is true
if and only if the other is true. For example “n is prime” is an element of PropN, and so
are “n  2” and “n ≥11.” The statements “n + 2  5” and “n is the least odd prime”
are considered the same. Given P, Q ∈PropN, we say P ≤Q if for all n ∈N, whenever
P(n) is true, so is Q(n).
Deﬁne a monoidal unit and a monoidal product on PropN that satisfy the conditions
of Deﬁnition 2.2.
♦
The monoidal preorder Cost
As we said above, when we enrich in monoidal pre-
orders we see them as diﬀerent ways to structure the question of “getting from here
to there.” We will explain this in more detail in Section 2.3. The following monoidal
preorder will eventually structure a notion of distance or cost for getting from here to
there.
Example 2.37 (Lawvere’s monoidal preorder, Cost). Let [0, ∞] denote the set of non-
negative real numbers—such as 0, 1, 15.333, and 2π—together with ∞. Consider the
preorder ([0, ∞], ≥), with the usual notion of ≥, where of course ∞≥x for all x ∈[0, ∞].
There is a monoidal structure on this preorder, where the monoidal unit is 0 and
the monoidal product is +. In particular, x + ∞ ∞for any x ∈[0, ∞]. Let’s call this

2.2. SYMMETRIC MONOIDAL PREORDERS
55
monoidal preorder
Cost B ([0, ∞], ≥, 0, +),
because we can think of the elements of [0, ∞] as costs. In terms of structuring “getting
from here to there,” Cost seems to say “getting from a to b is a question of cost.” The
monoidal unit being 0 will translate into saying that you can always get from a to a at
no cost. The monoidal product being + will translate into saying that the cost of getting
from a to c is at most the cost of getting from a to b plus the cost of getting from b to c.
Finally, the “at most” in the previous sentence is coming from the ≥.
The opposite of a monoidal preorder
One can take the opposite of any preorder, just
ﬂip the order: (X, ≤)op B (X, ≥); see Example 1.58. Proposition 2.38 says that if the
preorder had a symmetric monoidal structure, so does its opposite.
Proposition 2.38. Suppose X  (X, ≤) is a preorder and Xop  (X, ≥) is its opposite. If
(X, ≤, I, ⊗) is a symmetric monoidal preorder then so is its opposite, (X, ≥, I, ⊗).
Proof. Let’s ﬁrst check monotonicity. Suppose x1 ≥y1 and x2 ≥y2 in Xop; we need to
show that x1 ⊗x2 ≥y1 ⊗y2. But by deﬁnition of opposite order, we have y1 ≤x1 and
y2 ≤x2 in X, and thus y1 ⊗y2 ≤x1 ⊗x2 in X. Thus indeed x1 ⊗x2 ≥y1 ⊗y2 in Xop.
The other three conditions are even easier; see Exercise 2.39.
□
Exercise 2.39.
Complete the proof of Proposition 2.38 by proving that the three re-
maining conditions of Deﬁnition 2.2 are satisﬁed.
♦
Exercise 2.40.
Since Cost is a symmetric monoidal preorder, Proposition 2.38 says that
Costop is too.
1. What is Costop as a preorder?
2. What is its monoidal unit?
3. What is its monoidal product?
♦
2.2.5
Monoidal monotone maps
Recall from Example 1.49 that for any preorder (X, ≤), there is an induced equivalence
relation  on X, where x  x′ iﬀboth x ≤x′ and x′ ≤x.
Deﬁnition 2.41. Let P  (P, ≤P, IP, ⊗P) and Q  (Q, ≤Q, IQ, ⊗Q) be monoidal preorders.
A monoidal monotone from P to Q is a monotone map f : (P, ≤P) →(Q, ≤Q), satisfying
two conditions:
(a) IQ ≤Q f (IP), and
(b) f (p1) ⊗Q f (p2) ≤Q f (p1 ⊗P p2)
for all p1, p2 ∈P.
There are strengthenings of these conditions that are also important. If f satisﬁes
the following conditions, it is called a strong monoidal monotone:

56
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
(a’) IQ  f (IP), and
(b’) f (p1) ⊗Q f (p2)  f (p1 ⊗P p2);
and if it satisﬁes the following conditions it is called a strict monoidal monotone:
(a”) IQ  f (IP), and
(b”) f (p1) ⊗Q f (p2)  f (p1 ⊗P p2).
Monoidal monotones are examples of monoidal functors, which we will see various
incarnations of throughout the book; see Deﬁnition 6.68.
What we call monoidal
monotones could also be called lax monoidal monotones, and there is a dual notion of
oplax monoidal monotones, where the inequalities in (a) and (b) are reversed; we will not
use oplaxity in this book.
Example 2.42. There is a monoidal monotone i : (N, ≤, 0, +) →(R, ≤, 0, +), where i(n) 
n for all n ∈N. It is clearly monotonic, m ≤n implies i(m) ≤i(n). It is even strict
monoidal because i(0)  0 and i(m + n)  i(m) + i(n).
There is also a monoidal monotone f : (R, ≤, 0, +) →(N, ≤, 0, +) going the other
way. Here f (x) B ⌊x⌋is the ﬂoor function, e.g. f (3.14)  3. It is monotonic because
x ≤y implies f (x) ≤f (y). Also f (0)  0 and f (x)+ f (y) ≤f (x + y), so it is a monoidal
monotone. But it is not strict or even strong because f (0.5) + f (0.5) , f (0.5 + 0.5).
Recall Bool  (B, ≤, true, ∧) from Example 2.27 and Cost  ([0, ∞], ≥, 0, +) from
Example 2.37. There is a monoidal monotone 1 : Bool →Cost, given by 1(false) B ∞
and 1(true) B 0.
Exercise 2.43.
1. Check that the map 1 : (B, ≤, true, ∧) →([0, ∞], ≥, 0, +) presented above indeed
• is monotonic,
• satisﬁes condition (a) of Deﬁnition 2.41, and
• satisﬁes condition (b) of Deﬁnition 2.41.
2. Is 1 strict?
♦
Exercise 2.44.
Let Bool and Cost be as above, and consider the following quasi-inverse
functions d, u : [0, ∞] →B deﬁned as follows:
d(x) B
(
false
if x > 0
true
if x  0
u(x) B
(
false
if x  ∞
true
if x < ∞
1. Is d monotonic?
2. Does d satisfy conditions (a) and (b) of Deﬁnition 2.41?
3. Is d strict?
4. Is u monotonic?
5. Does u satisfy conditions (a) and (b) of Deﬁnition 2.41?
6. Is u strict?
♦
Exercise 2.45.

2.3. ENRICHMENT
57
1. Is (N, ≤, 1, ∗) a monoidal preorder, where ∗is the usual multiplication of natural
numbers?
2. If not, why not? If so, does there exist a monoidal monotone (N, ≤, 0, +) →(N, ≤
, 1, ∗)? If not; why not? If so, ﬁnd it.
3. Is (Z, ≤, ∗, 1) a monoidal preorder?
♦
2.3
Enrichment
In this section we will introduce V-categories, where V is a symmetric monoidal pre-
order. We will see that Bool-categories are preorders, and that Cost-categories are a
nice generalization of the notion of metric space.
2.3.1
V-categories
While V-categories can be deﬁned even when V is not symmetric, i.e. just obeys con-
ditions (a)–(c) of Deﬁnition 2.2, certain things don’t work quite right. For example,
we will see later in Exercise 2.75 that the symmetry condition is necessary in order for
products of V-categories to exist. Anyway, here’s the deﬁnition.
Deﬁnition 2.46. Let V  (V, ≤, I, ⊗) be a symmetric monoidal preorder. A V-category
X consists of two constituents, satisfying two properties. To specify X,
(i) one speciﬁes a set Ob(X), elements of which are called objects;
(ii) for every two objects x, y, one speciﬁes an element X(x, y) ∈V, called the hom-
object.2
The above constituents are required to satisfy two properties:
(a) for every object x ∈Ob(X) we have I ≤X(x, x), and
(b) for every three objects x, y, z ∈Ob(X), we have X(x, y) ⊗X(y, z) ≤X(x, z).
We call V the base of the enrichment for X or say that X is enriched in V.
Example 2.47. As we shall see in the next subsection, from every preorder we can
construct a Bool-category, and vice versa.
So, to get a feel for V-categories, let us
2The word “hom” is short for homomorphism and reﬂects the origins of this subject. A more descriptive
name for X(x, y) might be mapping object, but we use “hom” mainly because it is an important jargon word
to know in the ﬁeld.

58
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
consider the preorder generated by the Hasse diagram:
t
s
q
r
p
(2.48)
How does this correspond to a Bool-category X? Well, the objects of X are simply
the elements of the preorder, i.e. Ob(X)  {p, q, r, s, t}. Next, for every pair of objects
(x, y) we need an element of B  {false, true}: simply take true if x ≤y, and false
if otherwise.
So for example, since s ≤t and t ≰s, we have X(s, t)  true and
X(t, s)  false. Recalling from Example 2.27 that the monoidal unit I of Bool is true,
it’s straightforward to check that this obeys both (a) and (b), so we have a Bool-category.
In general, it’s sometimes convenient to represent a V-category X with a square
matrix. The rows and columns of the matrix correspond to the objects of X, and the
(x, y)th entry is simply the hom-object X(x, y). So, for example, the above preorder in
Eq. (2.48) can be represented by the matrix
·≤·
p
q
r
s
t
p
true
true
true
true
true
q
false
true
false
true
true
r
false
false
true
true
true
s
false
false
false
true
true
t
false
false
false
false
true
2.3.2
Preorders as Bool-categories
Our colleague Peter Gates has called category theory “a primordial ooze,” because so
much of it can be deﬁned in terms of other parts of it. There is nowhere to rightly call
the beginning, because that beginning can be deﬁned in terms of something else. So
be it; this is part of the fun.
Theorem 2.49. There is a one-to-one correspondence between preorders and Bool-
categories.
Here we ﬁnd ourselves in the ooze, because we are saying that preorders are the
same as Bool-categories, whereas Bool is itself a preorder. “So then Bool is like...
enriched in itself?” Yes, every preorder, including Bool, is enriched in Bool, as we will
now see.

2.3. ENRICHMENT
59
Proof of Theorem 2.49. Let’s check that we can construct a preorder from any Bool-
category. Since B  {false, true}, Deﬁnition 2.46 says a Bool-category consists of two
things:
(i) a set Ob(X), and
(ii) for every x, y ∈Ob(X) an element X(x, y) ∈B, i.e. either X(x, y)  true or
X(x, y)  false.
We will use these two things to begin forming a preorder whose elements are the
objects of X. So let’s call the preorder (X, ≤), and let X B Ob(X). For the ≤relation,
let’s declare x ≤y iﬀX(x, y)  true. We have the makings of a preorder, but for it to
work, the ≤relation must be reﬂexive and transitive. Let’s see if we get these from the
properties guaranteed by Deﬁnition 2.46:
(a) for every element x ∈X we have true ≤X(x, x),
(b) for every three elements x, y, z ∈X we have X(x, y) ∧X(y, z) ≤X(x, z).
For b ∈Bool, if true ≤b then b  true, so the ﬁrst statement says X(x, x)  true,
which means x ≤x.
For the second statement, one can consult Eq. (2.28).
Since
false ≤b for all b ∈B, the only way statement (b) has any force is if X(x, y)  true
and X(y, z)  true, in which case it forces X(x, z)  true. This condition exactly
translates as saying that x ≤y and y ≤z implies x ≤z. Thus we have obtained
reﬂexivity and transitivity from the two axioms of Bool-categories.
In Example 2.47, we constructed a Bool-category from a preorder. We leave it to the
reader to generalize this example and show that the two constructions are inverses; see
Exercise 2.50.
□
Exercise 2.50.
1. Start with a preorder (P, ≤), and use it to deﬁne a Bool-category as we did in
Example 2.47. In the proof of Theorem 2.49 we showed how to turn that Bool-
category back into a preorder. Show that doing so, you get the preorder you
started with.
2. Similarly, show that if you turn a Bool-category into a preorder using the above
proof, and then turn the preorder back into a Bool-category using your method,
you get the Bool-category you started with.
♦
We now discuss a beautiful application of the notion of enriched categories: metric
spaces.
2.3.3
Lawvere metric spaces
Metric spaces oﬀer a precise way to describe spaces of points, each pair of which is
separated by some distance. Here is the usual deﬁnition:
Deﬁnition 2.51. A metric space (X, d) consists of:
(i) a set X, elements of which are called points, and
(ii) a function d : X × X →R≥0, where d(x, y) is called the distance between x and y.

60
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
These constituents must satisfy four properties:
(a) for every x ∈X, we have d(x, x)  0,
(b) for every x, y ∈X, if d(x, y)  0 then x  y,
(c) for every x, y ∈X, we have d(x, y)  d(y, x), and
(d) for every x, y, z ∈X, we have d(x, y) + d(y, z) ≥d(x, z).
The fourth property is called the triangle inequality.
If we ask instead in (ii) for a function d : X × X →[0, ∞]  R≥0 ∪{∞}, we call (X, d)
an extended metric space.
The triangle inequality says that when plotting a route from x to z, the distance is
always at most what you get by choosing an intermediate point y and going x →y →z.
•
•
•
x
y
z
3
5
7.2
It can be invoked three diﬀerent ways in the above picture: 3 + 5 ≥7.2, but also
5 + 7.2 ≥3 and 3 + 7.2 ≥5. Oh yeah, and 5 + 3 ≥7.2, 7.2 + 5 ≥3 and 7.2 + 3 ≥5.
The triangle inequality wonderfully captures something about distance, as does the
fact that d(x, x)  0 for any x. However, the other two conditions are not quite as
general as we would like. Indeed, there are many examples of things that “should” be
metric spaces, but which do not satisfy conditions (b) or (c) of Deﬁnition 2.51.
For example, what if we take X to be places in your neighborhood, but instead of
measuring distance, you want d(x, y) to measure eﬀort to get from x to y. Then if there
are any hills, the symmetry axiom, d(x, y) ? d(y, x), fails: it’s easier to get from x
downhill to y then to go from y uphill to x.
Another way to ﬁnd a model that breaks the symmetry axiom is to imagine that
the elements of X are not points, but whole regions such as the US, Spain, and Boston.
Say that the distance from region A to region B is understood using the setup “I will
put you in an arbitrary part of A and you just have to get anywhere in B; what is the
distance in the worst-case scenario?” So d(US, Spain) is the distance from somewhere
in the western US to the western tip of Spain: you just have to get into Spain, but you
start in the worst possible part of the US for doing so.
Exercise 2.52.
Which distance is bigger under the above description, d(Spain, US) or
d(US, Spain)?
♦
This notion of distance, which is strongly related to something called Hausdorﬀdis-
tance,3 will again satisfy the triangle inequality, but it violates the symmetry condition.
It also violates another condition, because d(Boston, US)  0. No matter where you
3 The Hausdorﬀdistance gives a metric on the set of all subsets U ⊆X of a given metric space (X, d).

2.3. ENRICHMENT
61
are in Boston, the distance to the nearest point of the US is 0. On the other hand,
d(US, Boston) , 0.
Finally, one can imagine a use for distances that are not ﬁnite.
In terms of my
eﬀort, the distance from here to Pluto is ∞, and it would not be any better if Pluto was
still a planet. Similarly, in terms of Hausdorﬀdistance, discussed above, the distance
between two regions is often inﬁnite, e.g. the distance between {r ∈R | r < 0} and {0}
as subsets of (R, d) is inﬁnite.
When we drop conditions (b) and (c) and allow for inﬁnite distances, we get the fol-
lowing relaxed notion of metric space, ﬁrst proposed by Lawvere. Recall the symmetric
monoidal preorder Cost  ([0, ∞], ≥, 0, +) from Example 2.37.
Deﬁnition 2.53. A Lawvere metric space is a Cost-category.
This is a very compact deﬁnition, but it packs a punch. Let’s work out what it means,
by relating it to the usual deﬁnition of metric space. By Deﬁnition 2.46, a Cost-category
X consists of:
(i) a set Ob(X),
(ii) for every x, y ∈Ob(X) an element X(x, y) ∈[0, ∞].
Here the set Ob(X) is playing the role of the set of points, and X(x, y) ∈[0, ∞] is playing
the role of distance, so let’s write a little translator:
X B Ob(X)
d(x, y) B X(x, y).
The properties of a category enriched in Cost are:
(a) 0 ≥d(x, x) for all x ∈X, and
(b) d(x, y) + d(y, z) ≥d(x, z) for all x, y, z ∈X.
Since d(x, x) ∈[0, ∞], if 0 ≥d(x, x) then d(x, x)  0. So the ﬁrst condition is equivalent
to the ﬁrst condition from Deﬁnition 2.51, namely d(x, x)  0. The second condition is
the triangle inequality.
Example 2.54. The set R of real numbers can be given a metric space structure, and
hence a Lawvere metric space structure. Namely d(x, y) B |y −x|, the absolute value
of the diﬀerence. So d(3, 7)  4.
Exercise 2.55.
Consider the symmetric monoidal preorder (R≥0, ≥, 0, +), which is
almost the same as Cost, except it does not include ∞. How would you characterize
the diﬀerence between a Lawvere metric space and a (R≥0, ≥, 0, +)-category in the sense
of Deﬁnition 2.46?
♦
One ﬁrst deﬁnes
dL(U, V) B sup
u∈U
inf
v∈V
d(u, v),
and this is exactly the formula we intend above; the result will be a Lawvere metric space. However, if one
wants the Hausdorﬀdistance to deﬁne a (symmetric) metric, as in Deﬁnition 2.51, one must take the above
formula and symmetrize it: d(U, V) B max(dL(U, V), dL(V, U)). We happen to see the unsymmetrized
notion as more interesting.

62
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Presenting metric spaces with weighted graphs
Just as one can convert a Hasse
diagram into a preorder, one can convert any weighted graph—a graph whose edges
are labeled with numbers w ≥0—into a Lawvere metric space.
In fact, we shall
consider these as graphs labelled with elements of [0, ∞], and more precisely call them
Cost-weighted graphs.4
One might think of a Cost-weighted graph as describing a city with some one-way
roads (a two-way road is modeled as two one-way roads), each having some eﬀort-to-
traverse, which for simplicity we just call length. For example, consider the following
weighted graphs:
A•
B•
•
C
•
D
3
3
6
2
5
X B
x•
•
y
z•
3
4
3
4
: Y
(2.56)
Given a weighted graph, one forms a metric dX on its set X of vertices by setting d(p, q)
to be the length of the shortest path from p to q. For example, here is the the table of
distances for Y
d(↗)
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
(2.57)
Exercise 2.58.
Fill out the following table of distances in the weighted graph X from
Eq. (2.56)
d(↗)
A
B
C
D
A
0
?
?
?
B
2
?
5
?
C
?
?
?
?
D
?
?
?
?
♦
Above we converted a weighted graph G, e.g. as shown in Eq. (2.56), into a table
of distances, but this takes a bit of thinking. There is a more direct construction for
taking G and getting a square matrix MG, whose rows and columns are indexed by the
vertices of G. To do so, set MG to be 0 along the diagonal, to be ∞wherever an edge is
missing, and to be the edge weight if there is an edge.
4This generalizes Hasse diagrams, which we could call Bool-weighted graphs—the edges of a Hasse
diagram are thought of as weighted with true; we simply ignore any edges that are weighted with false,
and neglect to even draw them!

2.3. ENRICHMENT
63
For example, the matrix associated to Y in Eq. (2.56) would be
MY B
↗
x
y
z
x
0
4
3
y
3
0
∞
z
∞
4
0
(2.59)
As soon as you see how we did this, you’ll understand that it takes no thinking to turn
a weighted graph G into a matrix MG in this way. We will see later in Section 2.5.3
that the more diﬃcult “distance matrices” dY, such as Eq. (2.57), can be obtained from
the easy graph matrices MY, such as Eq. (2.59), by repeating a certain sort of “matrix
multiplication.”
Exercise 2.60.
Fill out the matrix MX associated to the graph X in Eq. (2.56):
MX 
↗
A
B
C
D
A
0
?
?
?
B
2
0
∞
?
C
?
?
?
?
D
?
?
?
?
♦
2.3.4
V-variations on preorders and metric spaces
We have told the story of Bool and Cost. But in Section 2.2.4 we gave examples of
many other monoidal preorders, and each one serves as the base of enrichment for a
kind of enriched category. Which of them are useful? Something only becomes useful
when someone ﬁnds a use for it. We will ﬁnd uses for some and not others, though we
encourage readers to think about what it would mean to enrich in the various monoidal
categories discussed above; maybe they can ﬁnd a use we have not explored.
Exercise 2.61.
Recall the monoidal preorder NMY B (P, ≤, yes, min) from Exer-
cise 2.34. Interpret what a NMY-category is.
♦
In the next two exercises, we use V-weighted graphs to construct V-categories. This
is possible because we will use preorders that, like Bool and Cost, have joins.
Exercise 2.62.
Let M be a set and let M B (P(M), ⊆, M, ∩) be the monoidal preorder
whose elements are subsets of M.
Someone gives the following interpretation, “for any set M, imagine it as the set of
modes of transportation (e.g. car, boat, foot). Then an M-category X tells you all the
modes that will get you from a all the way to b, for any two points a, b ∈Ob(X).”
1. Draw a graph with four vertices and four or ﬁve edges, each labeled with a subset
of M  {car, boat, foot}.
2. From this graph is it possible to construct an M-category, where the hom-object
from x to y is computed as follows: for each path p from x to y, take the
intersection of the sets labelling the edges in p. Then, take the union of the these

64
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
sets over all paths p from x to y. Write out the corresponding four-by-four matrix
of hom-objects, and convince yourself that this is indeed an M-category.
3. Does the person’s interpretation look right, or is it subtly mistaken somehow?
♦
Exercise 2.63.
Consider the monoidal preorder W B (N ∪{∞}, ≤, ∞, min).
1. Draw a small graph labeled by elements of N ∪{∞}.
2. Write out the matrix whose rows and columns are indexed by the nodes in the
graph, and whose (x, y)th entry is given by the maximum over all paths p from x
to y of the minimum edge label in p.
3. Prove that this matrix is the matrix of hom-objects for a W-category. This will
give you a feel for how W works.
4. Make up an interpretation, like that in Exercise 2.62, for how to imagine enrich-
ment in W.
♦
2.4
Constructions on V-categories
Now that we have a good intuition for what V-categories are, we give three examples
of what can be done with V-categories. The ﬁrst (Section 2.4.1) is known as change of
base. This allows us to use a monoidal monotone f : V →W to construct W-categories
from V-categories. The second construction (Section 2.4.2), that of V-functors, allows
us to complete the analogy: a preorder is to a Bool-category as a monotone map is to
what? The third construction (Section 2.4.2) is known as a V-product, and gives us a
way of combining two V-categories.
2.4.1
Changing the base of enrichment
Any monoidal monotone V →W between symmetric monoidal preorders lets us
convert V-categories into W-categories.
Construction 2.64. Let f : V →W be a monoidal monotone. Given a V-category C, one
forms the associated W-category, say C f as follows.
(i) We take the same objects: Ob(C f ) B Ob(C).
(ii) For any c, d ∈Ob(C), put C f (c, d) B f (C(c, d)).
This construction C f does indeed obey the deﬁnition of a W-category, as can be seen
by applying Deﬁnition 2.41 (of monoidal monotone) and Deﬁnition 2.46 (of V-category):
(a) for every c ∈C, we have
IW ≤f (IV)
( f is monoidal monotone)
≤f (C(c, c))
(C is V-category)
 C f (c, c)
(deﬁnition of C f )

2.4. CONSTRUCTIONS ON V-CATEGORIES
65
(b) for every c, d, e ∈Ob(C) we have
C f (c, d) ⊗W C f (d, e)  f (C(c, d)) ⊗W f (C(d, e))
(deﬁnition of C f )
≤f  C(c, d) ⊗V C(d, e)
( f is monoidal monotone)
≤f (C(c, e))
(C is V-category)
 C f (c, e)
(deﬁnition of C f )
Example 2.65. As an example, consider the function f : [0, ∞] →{true, false} given
by
f (x) B
(
true
if x  0
false
if x > 0
(2.66)
It is easy to check that f is monotonic and that f preserves the monoidal product
and monoidal unit; that is, it’s easy to show that f is a monoidal monotone. (Recall
Exercise 2.44.)
Thus f lets us convert Lawvere metric spaces into preorders.
Exercise 2.67. Recall the “regions of the world” Lawvere metric space from Exercise 2.52
and the text above it. We just learned that, using the monoidal monotone f in Eq. (2.66),
we can convert it to a preorder. Draw the Hasse diagram for the preorder corresponding
to the regions: US, Spain, and Boston. How could you interpret this preorder relation?
♦
Exercise 2.68.
1. Find another monoidal monotone 1 : Cost →Bool diﬀerent from the one deﬁned
in Eq. (2.66).
2. Using Construction 2.64, both your monoidal monotone 1 and the monoidal
monotone f in Eq. (2.66) can be used to convert a Lawvere metric space into a
preorder. Find a Lawvere metric space X on which they give diﬀerent answers,
X f , X1.
♦
2.4.2
Enriched functors
The notion of functor provides the most important type of relationship between cate-
gories.
Deﬁnition 2.69. Let X and Y be V-categories. A V-functor from X to Y, denoted F : X →Y,
consists of one constituent:
(i) a function F : Ob(X) →Ob(Y)
subject to one constraint
(a) for all x1, x2 ∈Ob(X), one has X(x1, x2) ≤Y(F(x1), F(x2)).

66
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Example 2.70. For example, we have said several times—e.g. in Theorem 2.49—that pre-
orders are Bool-categories, where X(x1, x2)  true is denoted x1 ≤x2. One would hope
that monotone maps between preorders would correspond exactly to Bool-functors,
and that’s true. A monotone map (X, ≤X) →(Y, ≤Y) is a function F : X →Y such that
for every x1, x2 ∈X, if x1 ≤X x2 then F(x1) ≤Y F(x2). In other words, we have
X(x1, x2) ≤Y(F(x1), F(x2)),
where the above ≤takes place in the enriching category V  Bool; this is exactly the
condition from Deﬁnition 2.69.
Remark 2.71. In fact, we have what is called an equivalence of categories between the
category of preorders and the category of Bool-categories. In the next chapter we will
develop the ideas necessary to state what this means precisely (Remark 3.59).
Example 2.72. Lawvere metric spaces are Cost-categories. The deﬁnition of Cost-functor
should hopefully return a nice notion—a “friend”—from the theory of metric spaces,
and it does: it recovers the notion of Lipschitz function. A Lipschitz (or more precisely,
1-Lipschitz) function is one under which the distance between any pair of points
does not increase. That is, given Lawvere metric spaces (X, dX) and (Y, dY), a Cost-
functor between them is a function F : X →Y such that for every x1, x2 ∈X we have
dX(x1, x2) ≥dY(F(x1), F(x2)).
Exercise 2.73.
The concepts of opposite, dagger, and skeleton (see Examples 1.58
and 1.72 and Remark 1.35) extend from preorders to V-categories. The opposite of a
V-category X is denoted Xop and is deﬁned by
(i) Ob(Xop) B Ob(X), and
(ii) for all x, y ∈X, we have Xop(x, y) B X(y, x).
A V-category X is a dagger V-category if the identity function is a V-functor †: X →Xop.
And a skeletal V-category is one in which if I ≤X(x, y) and I ≤X(y, x), then x  y.
Recall that an extended metric space (X, d) is a Lawvere metric space with two extra
properties; see properties (b) and (c) in Deﬁnition 2.51.
1. Show that a skeletal dagger Cost-category is an extended metric space.
2. Use Exercise 1.73 to make sense of the following analogy: “preorders are to sets
as Lawvere metric spaces are to extended metric spaces.”
♦
2.4.3
Product V-categories
If V  (V, ≤, I, ⊗) is a symmetric monoidal preorder and X and Y are V-categories, then
we can deﬁne their V-product, which is a new V-category.

2.4. CONSTRUCTIONS ON V-CATEGORIES
67
Deﬁnition 2.74. Let X and Y be V-categories. Deﬁne their V-product, or simply product,
to be the V-category X × Y with
(i) Ob(X × Y) B Ob(X) × Ob(Y),
(ii) (X × Y) (x, y), (x′, y′) B X(x, x′) ⊗Y(y, y′),
for two objects (x, y) and (x′, y′) in Ob(X × Y).
Product V-categories are indeed V-categories (Deﬁnition 2.46); see Exercise 2.75.
Exercise 2.75.
Let X × Y be the V-product of V-categories as in Deﬁnition 2.74.
1. Check that for every object (x, y) ∈Ob(X × Y) we have I ≤(X × Y) (x, y), (x, y)
.
2. Check that for every three objects (x1, y1), (x2, y2), and (x3, y3), we have
(X × Y) (x1, y1), (x2, y2)
⊗(X × Y) (x2, y2), (x3, y3)
≤(X × Y) (x1, y1), (x3, y3)
.
3. We said at the start of Section 2.3.1 that the symmetry of V (condition (d) of
Deﬁnition 2.2) would be required here. Point out exactly where that condition is
used.
♦
When taking the product of two preorders (P, ≤P) × (Q, ≤Q), as ﬁrst described in
Example 1.56, we say that (p1, q1) ≤(p2, q2) iﬀboth p1 ≤p2 AND q1 ≤q2; the AND is
the monoidal product ⊗from of Bool. Thus the product of preorders is an example of
a Bool-product.
Example 2.76. Let X and Y be the Lawvere metric spaces (i.e. Cost-categories) deﬁned
by the following weighted graphs:
•
A
•
B
•
C
2
3
X B
•q
•
p
5
8
: Y
(2.77)
Their product is deﬁned by taking the product of their sets of objects, so there are six
objects in X × Y. And the distance dX×Y((x, y), (x′, y′)) between any two points is given
by the sum dX(x, x′) + dY(y, y′).
Examine the following graph, and make sure you understand how easy it is to

68
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
derive from the weighted graphs for X and Y in Eq. (2.77):
•
(A, p)
•
(B, p)
•
(C, p)
•
(A, q)
•
(B, q)
•
(C, q)
2
3
2
3
5
8
5
8
5
8
X × Y 
Exercise 2.78.
Consider R as a Lawvere metric space, i.e. as a Cost-category (see
Example 2.54).
Form the Cost-product R × R.
What is the distance from (5, 6) to
(−1, 4)? Hint: apply Deﬁnition 2.74; the answer is not
√
40.
♦
In terms of matrices, V-products are also quite straightforward. They generalize
what is known as the Kronecker product of matrices. The matrices for X and Y in
Eq. (2.77) are shown below
X
A
B
C
A
0
2
5
B
∞
0
3
C
∞
∞
0
Y
p
q
p
0
5
q
8
0
and their product is as follows:
X × Y
(A, p)
(B, p)
(C, p)
(A, q)
(B, q)
(C, q)
(A, p)
0
2
5
5
7
10
(B, p)
∞
0
3
∞
5
8
(C, p)
∞
∞
0
∞
∞
5
(A, q)
8
10
13
0
2
5
(B, q)
∞
8
11
∞
0
3
(C, q)
∞
∞
8
∞
∞
0
We have drawn the product matrix as a block matrix, where there is one block—shaped
like X—for every entry of Y. Make sure you can see each block as the X-matrix shifted
by an entry in Y. This comes directly from the formula from Deﬁnition 2.74 and the
fact that the monoidal product in Cost is +.
2.5
Computing presented V-categories with matrix
multiplication
In Section 2.3.3 we promised a straightforward way to construct the matrix representa-
tion of a Cost-category from a Cost-weighted graph. To do this, we use a generalized
matrix multiplication. We shall show that this works, not just for Cost, but also for
Bool, and many other monoidal preorders. The property required of the preorder is

2.5. COMPUTING PRESENTED V-CATEGORIES WITH MATRIX MULT.
69
that of being a unital, commutative quantale. These are preorders with all joins, plus
one additional ingredient, being monoidal closed, which we deﬁne next, in Section 2.5.1.
The deﬁnition of a quantale will be given in Section 2.5.2.
2.5.1
Monoidal closed preorders
The deﬁnition of V-category makes sense for any symmetric monoidal preorder V. But
that does not mean that any base of enrichment V is as useful as any other. In this
section we deﬁne closed monoidal categories, which in particular enrich themselves!
“Before you can really enrich others, you should really enrich yourself.”
Deﬁnition 2.79. A symmetric monoidal preorder V  (V, ≤, I, ⊗) is called symmetric
monoidal closed (or just closed) if, for every two elements v, w ∈V, there is an element
v ⊸w in V, called the hom-element, with the property
(a ⊗v) ≤w
iﬀ
a ≤(v ⊸w).
(2.80)
for all a, v, w ∈V.
Remark 2.81. The term ‘closed’ refers to the fact that a hom-element can be constructed
for any two elements, so the preorder can be seen as closed under the operation of
“taking homs.” In later chapters we’ll meet the closely-related concepts of compact
closed categories (Deﬁnition 4.58) and cartesian closed categories (Section 7.2.1) that
make this idea more precise. See especially Exercise 7.11.
One can consider the hom-element v ⊸w as a kind of “single-use v-to-w converter.”
So Eq. (2.80) says that a and v are enough to get w if and only if a is enough to get a
single-use v-to-w converter.
Exercise 2.82.
Condition Eq. (2.80) says precisely that there is a Galois connection in the
sense of Deﬁnition 1.95. Let’s prove this fact. In particular, we’ll prove that a monoidal
preorder is monoidal closed iﬀ, given any v ∈V, the map (−⊗v): V →V given by
multiplying with v has a right adjoint. We write this right adjoint (v ⊸−): V →V.
1. Using Deﬁnition 2.2, show that (−⊗v) is monotone.
2. Supposing that V is closed, show that for all v, w ∈V we have  (v ⊸w)⊗v
≤w.
3. Using 2., show that (v ⊸−) is monotone.
4. Conclude that a symmetric monoidal preorder is closed if and only if the mono-
tone map (−⊗v) has a right adjoint.
♦
Example 2.83. The monoidal preorder Cost  ([0, ∞], ≥, 0, +) is monoidal closed. In-
deed, for any x, y ∈[0, ∞], deﬁne x ⊸y B max(0, y−x). Then, for any a, x, y ∈[0, ∞],
we have
a + x ≥y
iﬀ
a ≥y −x
iﬀ
max(0, a) ≥max(0, y −x)
iﬀ
a ≥(x ⊸y)

70
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
so ⊸satisﬁes the condition of Eq. (2.80).
Note that we have not considered subtraction in Cost before; we can in fact use
monoidal closure to deﬁne subtraction in terms of the order and monoidal structure!
Exercise 2.84.
Show that Bool  (B, ≤, true, ∧) is monoidal closed.
♦
Example 2.85. A non-example is (B, ≤, false, ∨). Indeed, suppose we had a ⊸operator
as in Deﬁnition 2.79. Note that false ≤p ⊸q, for any p, q no matter what ⊸is,
because false is less than everything. But using a  false, p  true, and q  false,
we then get a contradiction: (a ∨p) ≰q and yet a ≤(p ⊸q).
Example 2.86. We started this chapter talking about resource theories. What does the
closed structure look like from that perspective? For example, in chemistry it would
say that for every two material collections c, d one can form a material collection c ⊸d
with the property that for any a, one has
a + c →d
if and only if
a →(c ⊸d).
Or more down to earth, since we have the reaction 2H2O + 2Na →2NaOH + H2, we
must also have
2H2O →(2Na ⊸(2NaOH + H2))
So from just two molecules of water, you can form a certain substance, and not many
substances ﬁt the bill—our preorder Mat of chemical materials is not closed.
But it is not so far-fetched: this hypothetical new substance (2Na ⊸(2NaOH + H2))
is not really a substance, but a potential reaction: namely that of converting a sodium
to sodium-hydroxide-plus-hydrogen. Two molecules of water unlock that potential.
Proposition 2.87. Suppose V  (V, ≤, I, ⊗, ⊸) is a symmetric monoidal preorder that
is closed. Then
(a) For every v ∈V, the monotone map −⊗v : (V, ≤) →(V, ≤) is left adjoint to
v ⊸−: (V, ≤) →(V, ≤).
(b) For any element v ∈V and set of elements A ⊆V, if the join Ô
a∈A a exists then
so does Ô
a∈A v ⊗a and we have
 
v ⊗
Ü
a∈A
a
!

Ü
a∈A
(v ⊗a).
(2.88)
(c) For any v, w ∈V, we have v ⊗(v ⊸w) ≤w.
(d) For any v ∈V, we have v  (I ⊸v).
(e) For any u, v, w ∈V, we have (u ⊸v) ⊗(v ⊸w) ≤(u ⊸w).

2.5. COMPUTING PRESENTED V-CATEGORIES WITH MATRIX MULT.
71
Proof. We go through the claims in order.
(a) The deﬁnition of (−⊗v) being left adjoint to (v ⊸−) is exactly the condition
Eq. (2.80); see Deﬁnition 1.95 and Exercise 2.82.
(b) This follows from (a), using the fact that left adjoints preserve joins (Proposi-
tion 1.111).
(c) This follows from (a), using the equivalent characterisation of Galois connection
in Proposition 1.107. More concretely, from reﬂexivity (v ⊸w) ≤(v ⊸w), we
obtain (v ⊸w) ⊗v ≤w Eq. (2.80), and we are done by symmetry, which says
v ⊗(v ⊸w)  (v ⊸w) ⊗v.
(d) Since v ⊗I  v ≤v, Eq. (2.80) says v ≤(I ⊸v). For the other direction, we have
(I ⊸v)  I ⊗(I ⊸v) ≤v by (c).
(e) To obtain this inequality, we just need u ⊗(u ⊸v) ⊗(v ⊸w) ≤w. But this
follows by two applications of (c).
□
One might read (c) as saying “if I have a v and a single-use v-to-w converter, I can
have a w.” One might read (d) as saying “having a v is the same as having a single-use
nothing-to-v converter.” And one might read (e) as saying “if I have a single-use u-to-v
converter and a single-use v-to-w converter, I can get a single-use u-to-w converter.
Remark 2.89. We can consider V to be enriched in itself. That is, for every v, w ∈Ob(V),
we can deﬁne V(v, w) B (v ⊸w) ∈V. For this to really be an enrichment, we just need
to check the two conditions of Deﬁnition 2.46. The ﬁrst condition I ≤X(x, x)  (x ⊸x)
is satisﬁed because I ⊗x ≤x. The second condition is satisﬁed by Proposition 2.87(e).
2.5.2
Quantales
To perform matrix multiplication over a monoidal preorder, we need one more thing:
joins. These were ﬁrst deﬁned in Deﬁnition 1.81.
Deﬁnition 2.90. A unital commutative quantale is a symmetric monoidal closed preorder
V  (V, ≤, I, ⊗, ⊸) that has all joins: Ô A exists for every A ⊆V. In particular, we often
denote the empty join by 0 B Ô .
Whenever we speak of quantales in this book, we mean unital commutative quan-
tales. We will try to remind the reader of that. There are also very interesting applica-
tions of noncommutative quantales; see Section 2.6.
Example 2.91. In Example 2.83, we saw that Cost is monoidal closed. To check whether
Cost is a quantale, we take an arbitrary set of elements A ⊆[0, ∞] and ask if it has a
join Ô A. To be a join, it needs to satisfy two properties:
a. a ≥Ô A for all a ∈A, and
b. if b ∈[0, ∞] is any element such that a ≥b for all a ∈A, then Ô A ≥b.
In fact we can deﬁne such a join: it is typically called the inﬁmum, or greatest lower

72
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
bound, of A.5 For example, if A  {2, 3} then Ô A  2. We have joins for inﬁnite sets
too: if B  {2.5, 2.05, 2.005, . . .}, its inﬁmum is 2. Finally, in order to say that ([0, ∞], ≥)
has all joins, we need a join to exist for the empty set A   too. The ﬁrst condition
becomes vacuous—there are no a’s in A—but the second condition says that for any
b ∈[0, ∞] we have Ô  ≥b; this means Ô   ∞.
Thus indeed ([0, ∞], ≥) has all joins, so Cost is a quantale.
Exercise 2.92.
1. What is Ô , which we generally denote 0, in the case
a. V  Bool  (B, ≤, true, ∧)?
b. V  Cost  ([0, ∞], ≥, 0, +)?
2. What is the join x ∨y in the case
a. V  Bool, and x, y ∈B are booleans?
b. V  Cost, and x, y ∈[0, ∞] are distances?
♦
Exercise 2.93.
Show that Bool  (B, ≤, true, ∧) is a quantale.
♦
Exercise 2.94.
Let S be a set and recall the power set monoidal preorder (P(S), ⊆, S, ∩)
from Exercise 2.35. Is it a quantale?
♦
Remark 2.95. One can personify the notion of unital, commutative quantale as a kind
of navigator. A navigator is someone who understands “getting from one place to an-
other.” Diﬀerent navigators may care about or understand diﬀerent aspects—whether
one can get from A to B, how much time it will take, what modes of travel will work,
etc.—but they certainly have some commonalities. Most importantly, a navigator needs
to be able to read a map: given routes A to B and B to C, they understand how to get
a route A to C. And they know how to search over the space of way-points to get
from A to C. These will correspond to the monoidal product and the join operations,
respectively.
Proposition 2.96. Let P  (P, ≤) be a preorder. It has all joins iﬀit has all meets.
Proof. The joins (resp. meets) in P are the meets (resp. joins) in Pop, so the two claims
are dual: it suﬃces to show that if P has all joins then it has all meets.
Suppose P has all joins and suppose that A ⊆P is a subset for which we want
the meet. Consider the set MA B {p ∈P | p ≤a for all a ∈A} of elements below
everything in A. Let mA B Ô
p∈MA p be their join. We claim that mA is a meet for A.
We ﬁrst need to know that for any a ∈A we have mA ≤a, but this is by deﬁnition of
join: since all p ∈MA satisfy p ≤a, so does their join mA ≤a. We second need to know
that for any m′ ∈P with m′ ≤a for all a ∈A, we have m′ ≤m. But every such m′ is
actually an element of MA and m is their join, so m′ ≤m. This completes the proof.
□
5 Here, by the inﬁmum of a subset A ⊆[0, ∞], we mean inﬁmum in the usual order on [0, ∞]: the
largest number that is ≤everything in A. For example, the inﬁmum of {3.1, 3.01, 3.001, . . .} is 3. But note
that this is the supremum in the reversed, ≥, order of Cost.

2.5. COMPUTING PRESENTED V-CATEGORIES WITH MATRIX MULT.
73
In particular, a quantale has all meets and all joins, even though we only deﬁne it to
have all joins.
Remark 2.97. The notion of Hausdorﬀdistance can be generalized, allowing the role of
Cost to be taken by any quantale V. If X is a V-category with objects X, and U ⊆X
and V ⊆X, we can generalize the usual Hausdorﬀdistance, on the left below, to the
formula on the right:
d(U, V) B sup
u∈U
inf
v∈V
d(u, v)
X(U, V) B
Û
u∈U
Ü
v∈V
X(u, v).
For example, if V  Bool, the Hausdorﬀdistance between sub-preorders U and V
answers the question “can I get into V from every u ∈U,” i.e. ∀u∈U. ∃v∈V. u ≤v. Or
for another example, use V  P(M) with its interpretation as modes of transportation,
as in Exercise 2.62. Then the Hausdorﬀdistance d(U, V) ∈P(M) tells us those modes
of transportation that will get us into V from every point in U.
Proposition 2.98. Suppose V  (V, ≤, I, ⊗) is any symmetric monoidal preorder that
has all joins. Then V is closed—i.e. it has a ⊸operation and hence is a quantale—if
and only if ⊗distributes over joins; i.e. if Eq. (2.88) holds for all v ∈V and A ⊆V.
Proof. We showed one direction in Proposition 2.87(b): if V is monoidal closed then
Eq. (2.88) holds. We need to show that Eq. (2.88) holds then −⊗v : V →V has a right
adjoint v ⊸−. This is just the adjoint functor theorem, Theorem 1.115. It says we can
deﬁne v ⊸w to be
v ⊸w B
Ü
{a∈V|a⊗v≤w}
a.
□
2.5.3
Matrix multiplication in a quantale
A quantale V  (V, ≤, I, ⊗, ⊸), as deﬁned in Deﬁnition 2.79, provides what is necessary
to perform matrix multiplication.6 The usual formula for matrix multiplication is:
(M ∗N)(i, k) 
Õ
j
M(i, j) ∗N(j, k).
(2.99)
We will get a formula where joins stand in for the sum operation Í, and ⊗stands in
for the product operation ∗. Recall our convention of writing 0 B Ô .
Deﬁnition 2.100. Let V  (V, ≤, ⊗, I) be a quantale. Given sets X and Y, a matrix with
entries in V, or simply a V-matrix, is a function M : X × Y →V. For any x ∈X and
y ∈Y, we call M(x, y) the (x, y)-entry.
6This works for noncommutative quantales as well.

74
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Here is how you multiply V-matrices M : X × Y →V and N : Y × Z →V. Their
product is deﬁned to be the matrix (M ∗N): X × Z →V, whose entries are given by
the formula
(M ∗N)(x, z) B
Ü
y∈Y
M(x, y) ⊗N(y, z).
(2.101)
Note how similar this is to Eq. (2.99).
Example 2.102. Let V  Bool. Here is an example of matrix multiplication M ∗N. Here
X  {1, 2, 3}, Y  {1, 2}, and Z  {1, 2, 3}, matrices M : X × Y →B and N : Y × Z →B
are shown to the left below, and their product is shown to the right:
©­­
«
false
false
false
true
true
true
ª®®
¬
∗
 
true
true
false
true
false
true
!

©­­
«
false
false
false
true
false
true
true
true
true
ª®®
¬
The identity V-matrix on a set X is IX : X × X →V given by
IX(x, y) B
(
I
if x  y
0
if x , y.
Exercise 2.103. Write down the 2×2-identity matrix for each of the quantales (N, ≤, 1, ∗),
Bool  (B, ≤, true, ∧), and Cost  ([0, ∞], ≥, 0, +).
♦
Exercise 2.104.
Let V  (V, ≤, I, ⊗, ⊸) be a quantale. Use Eq. (2.101) and Proposi-
tion 2.87 to prove the following.
1. Prove the identity law: for any sets X and Y and V-matrix M : X × Y →V, one
has IX ∗M  M.
2. Prove the associative law: for any matrices M : W × X →V, N : X × Y →V, and
P : Y × Z →V, one has (M ∗N) ∗P  M ∗(N ∗P).
♦
Recall the weighted graph Y from Eq. (2.56). One can read oﬀthe associated matrix
MY, and one can calculate the associated metric dY:
x•
•
y
z•
3
4
3
4
Y B
MY
x
y
z
x
0
4
3
y
3
0
∞
z
∞
4
0
dY
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
Here we fully explain how to compute dY using only MY.
The matrix MY can be thought of as recording the length of paths that traverse either
0 or 1 edges: the diagonals being 0 mean we can get from x to x without traversing any

2.6. SUMMARY AND FURTHER READING
75
edges. When we can get from x to y in one edge we record its length in MY, otherwise
we use ∞.
When we multiply MY by itself using the formula Eq. (2.101), the result M2
Y tells us
the length of the shortest path traversing 2 edges or fewer. Similarly M3
Y tells us about
the shortest path traversing 3 edges or fewer:
M2
Y 
↗
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
M3
Y 
↗
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
One sees that the powers stabilize: M2
Y  M3
Y; as soon as that happens one has the
matrix of distances, dY. Indeed Mn
Y records the lengths of the shortest path traverse n
edges or fewer, and the powers will always stabilize if the set of vertices is ﬁnite, since
the shortest path from one vertex to another will never visit a given vertex more than
once.7
Exercise 2.105.
Recall from Exercise 2.60 the matrix MX, for X as in Eq. (2.56). Cal-
culate M2
X, M3
X, and M4
X. Check that M4
X is what you got for the distance matrix in
Exercise 2.58.
♦
This procedure gives an algorithm for computing the V-category presented by any
V-weighted graph using matrix multiplication.
2.6
Summary and further reading
In this chapter we thought of elements of preorders as describing resources, with the or-
der detailing whether one resource could be obtained from another. This naturally led
to the question of how to describe what could be built from a pair of resources, which
led us to consider monoid structures on preorders. More abstractly, these monoidal
preorders were seen to be examples of enriched categories, or V-categories, over the
symmetric monoidal preorder Bool. Changing Bool to the symmetric monoidal pre-
order Cost, we arrived upon Lawvere metric spaces, a slight generalization of the
usual notion of metric space. In terms of resources, Cost-categories tell us the cost of
obtaining one resource from another.
At this point, we sought to get a better feel for V-categories in two ways. First, we
introduced various important constructions: base change, functors, products. Second,
we looked at how to present V-categories using labelled graphs; here, perhaps surpris-
ingly, we saw that matrix multiplication gives an algorithm to compute the hom-objects
from a labelled graph.
Resource theories are discussed in much more detail in [CFS16; Fri17]. The authors
provide many more examples of resource theories in science, including in thermody-
7The method works even in the inﬁnite case: one takes the inﬁmum of all powers Mn
Y. The result
always deﬁnes a Lawvere metric space.

76
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
namics, Shannon’s theory of communication channels, and quantum entanglement.
They also discuss more of the numerical theory than we did, including calculating the
asymptotic rate of conversion from one resource into another.
Enrichment is a fundamental notion in category theory, and we will we return to it
in Chapter 4, generalizing the deﬁnition so that categories, rather than mere preorders,
can serve as bases of enrichment. In this more general setting we can still perform
the constructions we introduced in Section 2.4—base change, functors, products—and
many others; the authoratitive, but by no means easy, reference on this is the book by
Kelly [Kel05].
While preorders were familiar before category theory came along, Lawvere metric
spaces are a beautiful generalization of the previous notion of (symmetric) metric
space, that is due to, well, Lawvere.
A deeper exploration than the taste we gave
here can be found in his classic paper [Law73], where he also discusses ideas like
Cauchy completeness in category-theoretic terms, and which hence generalize to other
categorical settings.
We observed that while any symmetric monoidal preorder can serve as a base
for enrichment, certain preorders—quantales—are better than others. Quantales are
well known for links to other parts of mathematics too. The word quantale is in fact a
portmanteau of ‘quantum locale’, where quantum refers to quantum physics, and locale
is a fundamental structure in topology. For a book-length introduction of quantales and
their applications, one might check [Ros90]. The notion of cartesian closed categories,
later generalized to monoidal closed categories, is due to Ronnie Brown [Bro61].
Note that while we have only considered commutative quantales, the noncommu-
tative variety also arise naturally. For example, the power set of any monoid forms
a quantale that is commutative iﬀthe monoid is. Another example is the set of all
binary relations on a set X, where multiplication is relational composition; this is
non-commutative. Such noncommutative quantales have application to concurrency
theory, and in particular process semantics and automata; see [AV93] for details.

Chapter 3
Databases:
Categories, functors, and universal
constructions
3.1
What is a database?
Integrating data from disparate sources is a major problem in industry today.
A
study in 2008 [BH08] showed that data integration accounts for 40% of IT (information
technology) budgets, and that the market for data integration software was $2.5 billion
in 2007 and increasing at a rate of more than 8% per year. In other words, it is a major
problem; but what is it?
A database is a system of interlocking tables.
Data becomes information when it is
stored in a given formation. That is, the numbers and letters don’t mean anything until
they are organized, often into a system of interlocking tables. An organized system of
interlocking tables is called a database. Here is a favorite example:
Employee
FName
WorksIn
Mngr
1
Alan
101
2
2
Ruth
101
2
3
Kris
102
3
Department
DName
Secr
101
Sales
1
102
IT
3
(3.1)
These two tables interlock by use of a special left-hand column, demarcated by
a vertical line; it is called the ID column. The ID column of the ﬁrst table is called
‘Employee,’ and the ID column of the second table is called ‘Department.’ The entries
in the ID column—e.g. 1, 2, 3 or 101, 102—are like row labels; they indicate a whole
row of the table they’re in. Thus each row label must be unique (no two rows in a table
can have the same label), so that it can unambiguously specify its row.
77

78
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Each table’s ID column, and the set of unique identiﬁers found therein, is what
allows for the interlocking mentioned above. Indeed, other entries in various tables
can reference rows in a given table by use of its ID column. For example, each entry
in the WorksIn column references a department for each employee; each entry in the
Mngr (manager) column references an employee for each employee, and each entry in
the Secr (secretary) column references an employee for each department. Managing all
this cross-referencing is the purpose of databases.
Looking back at Eq. (3.1), one might notice that every non-ID column, found in either
table, is a reference to a label of some sort. Some of these, namely WorksIn, Mngr, and
Secr, are internal references, often called foreign keys; they refer to rows (keys) in the
ID column of some (foreign) table. Others, namely FName and DName, are external
references; they refer to strings or integers, which can also be thought of as labels, whose
meaning is known more broadly. Internal reference labels can be changed as long as
the change is consistent—1 could be replaced by 1001 everywhere without changing
the meaning—whereas external reference labels certainly cannot! Changing Ruth to
Bruce everywhere would change how people understood the data.
The reference structure for a given database—i.e. how tables interlock via foreign
keys—tells us something about what information was intended to be stored in it. One
may visualize the reference structure for Eq. (3.1) graphically as follows:
easySchema B
Employee
•
Department
•
string
◦
WorksIn
FName
Mngr
Secr
DName
(3.2)
This is a kind of “Hasse diagram for a database,” much like the Hasse diagrams for
preorders in Remark 1.39. How should you read it?
The two tables from Eq. (3.1) are represented in the graph (3.2) by the two black
nodes, which are given the same name as the ID columns: Employee and Department.
There is another node—drawn white rather than black—which represents the external
reference type of strings, like “Alan,” “Alpha,” and “Sales". The arrows in the diagram
represent non-ID columns of the tables; they point in the direction of reference: WorksIn
refers an employee to a department.
Exercise 3.3.
Count the number of non-ID columns in Eq. (3.1). Count the number of
arrows (foreign keys) in Eq. (3.2). They should be the same number in this case; is this
a coincidence?
♦
A Hasse-style diagram like the one in Eq. (3.2) can be called a database schema; it
represents how the information is being organized, the formation in which the data is
kept. One may add rules, sometimes called ‘business rules’ to the schema, in order to
ensure the integrity of the data. If these rules are violated, one knows that data being

3.1. WHAT IS A DATABASE?
79
entered does not conform to the way the database designers intended. For example,
the designers may enforce rules saying
• every department’s secretary must work in that department;
• every employee’s manager must work in the same department as the employee.
Doing so changes the schema, say from ‘easySchema’ (3.2) to ‘mySchema’ below.
mySchema B
Employee
•
Department
•
string
◦
WorksIn
FName
Mngr
Secr
DName
Department.Secr.WorksIn = Department
Employee.Mngr.WorksIn = Employee.WorksIn
(3.4)
In other words, the diﬀerence is that easySchema plus constraints equals mySchema.
We will soon see that database schemas are categories C, that the data itself is given
by a ‘set-valued’ functor C →Set, and that databases can be mapped to each other via
functors C →D. In other words, there is a relatively large overlap between database
theory and category theory. This has been worked out in a number of papers; see
Section 3.6. It has also been implemented in working software, called FQL, which
stands for functorial query language. Here is example FQL code for the schema shown
above:
schema mySchema = {
nodes
Employee, Department;
attributes
DName : Department -> string,
FName : Employee
-> string;
arrows
Mngr
: Employee
-> Employee,
WorksIn : Employee
-> Department,
Secr
: Department -> Employee;
equations
Department.Secr.WorksIn = Department,
Employee.Mngr.WorksIn
= Employee.WorksIn;
}
Communication between databases.
We have said that databases are designed to
store information about something. But diﬀerent people or organizations might view
the same sort of thing in diﬀerent ways. For example, one bank stores its ﬁnancial
records according to European standards and another does so according to Japanese
standards. If these two banks merge into one, they will need to be able to share their
data despite diﬀerences in the shape of their database schemas.

80
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Such problems are huge and intricate in general, because databases often comprise
hundreds or thousands of interlocking tables. Moreover, these problems occur more
frequently than just when companies want to merge. It is quite common that a given
company moves data between databases on a daily basis. The reason is that diﬀerent
ways of organizing information are convenient for diﬀerent purposes. Just like we pack
our clothes in a suitcase when traveling but use a closet at home, there is generally not
one best way to organize anything.
Category theory provides a mathematical approach for translating between these
diﬀerent organizational forms. That is, it formalizes a sort of automated reorganizing
process called data migration, which takes data that ﬁts snugly in one schema and moves
it into another.
Here is a simple case. Imagine an airline company has two diﬀerent databases,
perhaps created at diﬀerent times, that hold roughly the same data.
$◦
Economy
•
First Class
•
string
◦
Price
Position
Price
Position
A B
$◦
Airline Seat
•
string
◦
Price
Position
: B
(3.5)
Schema A has more detail than schema B—an airline seat may be in ﬁrst class or
economy—but they are roughly the same. We will see that they can be connected by a
functor, and that data conforming to A can be migrated through this functor to schema
B and vice versa.
The statistics at the beginning of this section show that this sort of problem—
when occurring at enterprise scale—continues to prove diﬃcult and expensive. If one
attempts to move data from a source schema to a target schema, the migrated data
could fail to ﬁt into the target schema or fail to satisfy some of its constraints. This
happens surprisingly often in the world of business: a night may be spent moving data,
and the next morning it is found to have arrived broken and unsuitable for further use.
In fact, it is believed that over half of database migration projects fail.
In this chapter, we will discuss a category-theoretic method for migrating data.
Using categories and functors, one can prove up front that a given data migration will
not fail, i.e. that the result is guaranteed to ﬁt into the target schema and satisfy all its
constraints.
The material in this chapter gets to the heart of category theory: in particular, we
discuss categories, functors, natural transformations, adjunctions, limits, and colimits.
In fact, many of these ideas have been present in the discussion above:
• The schema pictures, e.g. Eq. (3.4) depict categories C.

3.2. CATEGORIES
81
• The instances, e.g. Eq. (3.1) are functors from C to a certain category called Set.
• The implicit mapping in Eq. (3.5), which takes economy and ﬁrst class seats in A
to airline seats in B, constitutes a functor A →B.
• The notion of data migration for moving data between schemas is formalized by
adjoint functors.
We begin in Section 3.2 with the deﬁnition of categories and a bunch of diﬀerent
sorts of examples. In Section 3.3 we bring back databases, in particular their instances
and the maps between them, by discussing functors and natural transformations. In
Section 3.4 we discuss data migration by way of adjunctions, which generalize the
Galois connections we introduced in Section 1.4. Finally in Section 3.5 we give a bonus
section on limits and colimits.1
3.2
Categories
A category C consists of four pieces of data—objects, morphisms, identities, and a
composition rule—satisfying two properties.
Deﬁnition 3.6. To specify a category C:
(i) one speciﬁes a collection2 Ob(C), elements of which are called objects.
(ii) for every two objects c, d, one speciﬁes a set C(c, d),3 elements of which are called
morphisms from c to d.
(iii) for every object c ∈Ob(C), one speciﬁes a morphism idc ∈C(c, c), called the
identity morphism on c.
(iv) for every three objects c, d, e ∈Ob(C) and morphisms f ∈C(c, d) and 1 ∈C(d, e),
one speciﬁes a morphism f # 1 ∈C(c, e), called the composite of f and 1.
We will sometimes write an object c ∈C, instead of c ∈Ob(C). It will also be convenient
to denote elements f ∈C(c, d) as f : c →d. Here, c is called the domain of f , and d is
called the codomain of f .
These constituents are required to satisfy two conditions:
(a) unitality: for any morphism f : c →d, composing with the identities at c or d
does nothing: idc # f  f and f # idd  f .
(b) associativity: for any three morphisms f : c0 →c1, 1 : c1 →c2, and h : c2 →c3,
the following are equal: ( f # 1) # h  f # (1 # h). We write this composite simply
as f # 1 # h.
1By “bonus,” we mean that although not strictly essential to the understanding of this particular
chapter, limits and colimits will show up throughout the book and throughout one’s interaction with
category theory, and we think the reader will especially beneﬁt from this material in the long run.
2Here, a collection can be thought of as a bunch of things, just like a set, but that may be too large to
formally be a set. An example is the collection of all sets, which would run afoul of Russell’s paradox if it
were itself a set.
3This set C(c, d) is often denoted HomC(c, d), and called the “hom-set from c to d.” The word “hom”
stands for homomorphism, of which the word “morphism” is a shortened version.

82
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Our next goal is to give lots of examples of categories. Our ﬁrst source of examples
is that of free and ﬁnitely-presented categories, which generalize the notion of Hasse
diagram from Remark 1.39.
3.2.1
Free categories
Recall from Deﬁnition 1.36 that a graph consists of two types of thing: vertices and
arrows. From there one can deﬁne paths, which are just head-to-tail sequences of
arrows. Every path p has a start vertex and an end vertex; if p goes from v to w, we
write p : v →w. To every vertex v, there is a trivial path, containing no arrows, starting
and ending at v; we often denote it by idv or simply by v. We may also concatenate
paths: given p : v →w and q : w →x, their concatenation is denoted p # q, and it goes
v →x.
In Chapter 1, we used graphs to depict preorders (V, ≤): the vertices form the
elements of the preorder, and we say that v ≤w if there is a path from v to w in G. We
will now use graphs in a very similar way to depict certain categories, known as free
categories. Then we will explain a strong relationship between preorders and categories
in Section 3.2.3.
Deﬁnition 3.7. For any graph G  (V, A, s, t), we can deﬁne a category Free(G), called
the free category on G, whose objects are the vertices V and whose morphisms from c to
d are the paths from c to d. The identity morphism on an object c is simply the trivial
path at c. Composition is given by concatenation of paths.
For example, we deﬁne 2 to be the free category generated by the graph shown
below:
2 B Free

v1•
v2•
f1

(3.8)
It has two objects v1 and v2, and three morphisms: idv1 : v1 →v1, f1 : v1 →v2, and
idv2 : v2 →v2. Here idv1 is the path of length 0 starting and ending at v1, f1 is the path
of length 1 consisting of just the arrow f1, and idv2 is the length 0 path at v2. As our
notation suggests, idv1 is the identity morphism for the object v1, and similarly idv2
for v2. As composition is given by concatenation, we have, for example idv1 # f1  f1,
idv2 # idv2  idv2, and so on.
From now on, we may elide the diﬀerence between a graph and the corresponding
free category Free(G), at least when the one we mean is clear enough from context.
Exercise 3.9.
For Free(G) to really be a category, we must check that this data we
speciﬁed obeys the unitality and associativity properties. Check that these are obeyed
for any graph G.
♦

3.2. CATEGORIES
83
Exercise 3.10.
The free category on the graph shown here:4
3 B Free

v1•
v2•
v3•
f1
f2

(3.11)
has three objects and six morphisms: the three vertices and six paths in the graph.
Create six names, one for each of the six morphisms in 3. Write down a six-by-six
table, label the rows and columns by the six names you chose.
1. Fill out the table by writing the name of the composite in each cell, when there is
a composite.
2. Where are the identities?
♦
Exercise 3.12.
Let’s make some deﬁnitions, based on the pattern above:
1. What is the category 1? That is, what are its objects and morphisms?
2. What is the category 0?
3. What is the formula for the number of morphisms in n for arbitrary n ∈N?
♦
Example 3.13 (Natural numbers as a free category). Consider the following graph:
•
z
s
(3.14)
It has only one vertex and one arrow, but it has inﬁnitely many paths.
Indeed, it
has a unique path of length n for every natural number n ∈N.
That is, Path 
{z, s, (s # s), (s # s # s), . . .}, where we write z for the length 0 path on z; it represents
the morphism idz. There is a one-to-one correspondence between Path and the natural
numbers, N  {0, 1, 2, 3, . . .}.
This is an example of a category with one object. A category with one object is called
a monoid, a notion we ﬁrst discussed in Example 2.6. There we said that a monoid is
a tuple (M, ∗, e) where ∗: M × M →M is a function and e ∈M is an element, and
m ∗1  m  1 ∗m and (m ∗n) ∗p  m ∗(n ∗p).
The two notions may superﬁcially look diﬀerent, but it is easy to describe the
connection. Given a category C with one object, say •, let M B C(•, •), let e  id•, and
let ∗: C(•, •) × C(•, •) →C(•, •) be the composition operation ∗ #. The associativity
and unitality requirements for the monoid will be satisﬁed because C is a category.
Exercise 3.15.
In Example 3.13 we identiﬁed the paths of the loop graph (3.14) with
numbers n ∈N. Paths can be concatenated. Given numbers m, n ∈N, what number
corresponds to the concatenation of their associated paths?
♦
4As mentioned above, we elide the diﬀerence between the graph and the corresponding free category.

84
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
3.2.2
Presenting categories via path equations
So for any graph G, there is a free category on G. But we don’t have to stop there: we
can add equations between paths in the graph, and still get a category. We are only
allowed to equate two paths p and q when they are parallel, meaning they have the
same source vertex and the same target vertex.
A ﬁnite graph with path equations is called a ﬁnite presentation for a category, and the
category that results is known as a ﬁnitely-presented category. Here are two examples:
Free_square B
A•
B•
•
C
•
D
f
1
h
i
no equations
Comm_square B
A•
B•
•
C
•
D
f
1
h
i
f # h  1 # i
Both of these are presentations of categories: in the left-hand one, there are no equations
so it presents a free category, as discussed in Section 3.2.1. The free square category
has ten morphisms, because every path is a unique morphism.
Exercise 3.16.
1. Write down the ten paths in the free square category above.
2. Name two diﬀerent paths that are parallel.
3. Name two diﬀerent paths that are not parallel.
♦
On the other hand, the category presented on the right has only nine morphisms,
because f #h and 1#i are made equal. This category is called the “commutative square.”
Its morphisms are
{A, B, C, D, f , 1, h, i, f # h}
One might say “the missing one is 1 # i,” but that is not quite right: 1 # i is there too,
because it is equal to f # h. As usual, A denotes idA, etc.
Exercise 3.17. Write down all the morphisms in the category presented by the following
diagram:
A•
B•
•
C
•
D
f
1
j
h
i
f # h  j  1 # i
♦
Example 3.18. We should also be aware that enforcing an equation between two mor-
phisms often implies additional equations. Here are two more examples of presenta-

3.2. CATEGORIES
85
tions, in which this phenomenon occurs:
C B
•
z
s
s # s  z
D B
•
z
s
s # s # s # s  s # s
In C we have the equation s # s  z. But this implies s # s # s  z # s  s! And similarly
we have s # s # s # s  z # z  z. The set of morphisms in C is in fact merely {z, s}, with
composition described by s # s  z # z  z, and z # s  s # z  s. In group theory, one
would speak of a group called Z/2Z.
Exercise 3.19.
Write down all the morphisms in the category D from Example 3.18.
♦
Remark 3.20. We can now see that the schemas in Section 3.1, e.g. Eqs. (3.2) and (3.4)
are ﬁnite presentations of categories. We will come back to this idea in Section 3.3.
3.2.3
Preorders and free categories: two ends of a spectrum
Now that we have used graphs to depict preorders in Chapter 1 and categories above,
one may want to know the relationship between these two uses. The main idea we
want to explain now is that
“A preorder is a category where every two parallel arrows are the same.”
Thus any preorder can be regarded as a category, and any category can be somehow
“crushed down” into a preorder. Let’s discuss these ideas.
Preorders as categories.
Suppose (P, ≤) is a preorder. It speciﬁes a category P as
follows. The objects of P are precisely the elements of P; that is, Ob(P)  P. As for
morphisms, P has exactly one morphism p →q if p ≤q and no morphisms p →q if
p ≰q. The fact that ≤is reﬂexive ensures that every object has an identity, and the fact
that ≤is transitive ensures that morphisms can be composed. We call P the category
corresponding to the preorder (P, ≤).
In fact, a Hasse diagram for a preorder can be thought of a presentation of a category
where, for all vertices p and q, every two paths from p →q are declared equal. For
example, in Eq. (1.5) we saw a Hasse diagram that was like the graph on the left:
•
•
•
•
•
•
•
•
•
•
d
e
f
a
b
c
no equations?
•
•
•
•
•
d
e
f
a
b
c
a # d  b # e  c # f

86
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
The Hasse diagram (left) might look the most like the free category presentation (mid-
dle) which has no equations, but that is not correct.
The free category has three
morphisms (paths) from bottom object to top object, whereas preorders are categories
with at most one morphism between two given objects. Instead, the diagram on the
right, with these paths from bottom to top made equal, is the correct presentation for
the preorder on the left.
Exercise 3.21.
What equations would you need to add to the graphs below in order to
present the associated preorders?
G1 
•
•
f
1
G2 
•
f
G3 
•
•
•
•
f
1
h
i
G4 
•
•
•
•
f
1
h
♦
The preorder reﬂection of a category.
Given any category C, one can obtain a preorder
(C, ≤) from it by destroying the distinction between any two parallel morphisms. That
is, let C B Ob(C), and put c1 ≤c2 iﬀC(c1, c2) , . If there is one, or two, or ﬁfty,
or inﬁnitely many morphisms c1 →c2 in C, the preorder reﬂection does not see the
diﬀerence. But it does see the diﬀerence between some morphisms and no morphisms.
Exercise 3.22.
What is the preorder reﬂection of the category N from Example 3.13?
♦
We have only discussed adjoint functors between preorders, but soon we will discuss
adjoints in general. Here is a statement you might not understand exactly, but it’s true;
you can ask a category theory expert about it and they should be able to explain it to
you:
Considering a preorder as a category is right adjoint to turning a category
into a preorder by preorder reﬂection.
Remark 3.23 (Ends of a spectrum). The main point of this subsection is that both
preorders and free categories are speciﬁed by a graph without path equations, but they
denote opposite ends of a spectrum. In both cases, the vertices of the graph become
the objects of a category and the paths become morphisms. But in the case of free
categories, there are no equations so each path becomes a diﬀerent morphism. In
the case of preorders, all parallel paths become the same morphism. Every category
presentation, i.e. graph with some equations, lies somewhere in between the free
category (no equations) and its preorder reﬂection (all possible equations).
3.2.4
Important categories in mathematics
We have been talking about category presentations, but there are categories that are
best understood directly, not by way of presentations. Recall the deﬁnition of category

3.2. CATEGORIES
87
from Deﬁnition 3.6. The most important category in mathematics is the category of
sets.
Deﬁnition 3.24. The category of sets, denoted Set, is deﬁned as follows.
(i) Ob(Set) is the collection of all sets.
(ii) If S and T are sets, then Set(S, T)  { f : S →T | f is a function}.
(iii) For each set S, the identity morphism is the function idS : S →S given by
idS(s) B s for each s ∈S.
(iv) Given f : S →T and 1 : T →U, their composite is the function f # 1 : S →U
given by ( f # 1)(s) B 1( f (s)).
These deﬁnitions satisfy the unitality and associativity conditions, so Set is indeed a
category.
Closely related is the category FinSet. This is the category whose objects are ﬁnite
sets and whose morphisms are functions between them.
Exercise 3.25.
Let 2  {1, 2} and 3  {1, 2, 3}. These are objects in the category Set
discussed in Deﬁnition 3.24. Write down all the elements of the set Set(2, 3); there
should be nine.
♦
Remark 3.26. You may have wondered what categories have to do with V-categories
(Deﬁnition 2.46); perhaps you think the deﬁnitions hardly look alike. Despite the term
‘enriched category’, V-categories are not categories with extra structure. While some
sorts of V-categories, such as Bool-categories, i.e. preorders, can naturally be seen as
categories, other sorts, such as Cost-categories, cannot.
The reason for the importance of Set is that, if we generalize the deﬁnition of
enriched category (Deﬁnition 2.46), we ﬁnd that categories in the sense of Deﬁnition 3.6
are exactly Set-categories—so categories are V-categories for a very special choice of V.
We’ll come back to this in Section 4.4.4. For now, we simply remark that just like a deep
understanding of the category Cost—for example, knowing that it is a quantale—yields
insight into Lawvere metric spaces, so the study of Set yields insights into categories.
There are many other categories that mathematicians care about:
• Top: the category of topological spaces (neighborhood)
• Grph: the category of graphs (connection)
• Meas: the category of measure spaces (amount)
• Mon: the category of monoids (action)
• Grp: the category of groups (reversible action, symmetry)
• Cat: the category of categories (action in context, structure)
But in fact, this does not at all do justice to the diversity of categories mathematicians
think about. They work with whatever category they ﬁnd ﬁts their purpose at the time,
like ‘the category of connected Riemannian manifolds of dimension at most 4’.
Here is one more source of examples: take any category you already have and
reverse all its morphisms; the result is again a category.

88
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.27. Let C be a category.
Its opposite, denoted Cop, is the category with
the same objects, Ob(Cop) B Ob(C), and for any two objects c, d ∈Ob(C), one has
Cop(c, d) B C(d, c). Identities and composition are as in C.
3.2.5
Isomorphisms in a category
The previous sections have all been about examples of categories: free categories,
presented categories, and important categories in math. In this section, we brieﬂy
switch gears and talk about an important concept in category theory, namely the
concept of isomorphism.
In a category, there is often the idea that two objects are interchangeable.
For
example, in the category Set, one can exchange the set {■, □} for the set {0, 1} and
everything will be the same, other than the names for the elements. Similarly, if one
has a preorder with elements a, b, such that a ≤b and b ≤a, i.e. a  b, then a and b are
essentially the same. How so? Well they act the same, in that for any other object c, we
know that c ≤a iﬀc ≤b, and c ≥a iﬀc ≥b. The notion of isomorphism formalizes
this notion of interchangeability.
Deﬁnition 3.28. An isomorphism is a morphism f : A →B such that there exists a
morphism 1 : B →A satisfying f # 1  idA and 1 # f  idB. In this case we call f and 1
inverses, and we often write 1  f −1, or equivalently f  1−1. We also say that A and B
are isomorphic objects.
Example 3.29. The set A B {a, b, c} and the set 3  {1, 2, 3} are isomorphic; that is,
there exists an isomorphism f : A →3 given by f (a)  2, f (b)  1, f (c)  3. The
isomorphisms in the category Set are the bĳections.
Recall that the cardinality of a ﬁnite set is the number of elements in it. This can be
understood in terms of isomorphisms in FinSet. Namely, for any ﬁnite set A ∈FinSet,
its cardinality is the number n ∈N such that there exists an isomorphism A  n. Georg
Cantor deﬁned the cardinality of any set X to be its isomorphism class, meaning the
equivalence class consisting of all sets that are isomorphic to X.
Exercise 3.30.
1. What is the inverse f −1 : 3 →A of the function f given in Example 3.29?
2. How many distinct isomorphisms are there A →3?
♦
Exercise 3.31. Show that in any given category C, for any given object c ∈C, the identity
idc is an isomorphism.
♦
Exercise 3.32.
Recall Examples 3.13 and 3.18. A monoid in which every morphism is
an isomorphism is known as a group.
1. Is the monoid in Example 3.13 a group?

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
89
2. What about the monoid C in Example 3.18?
♦
Exercise 3.33.
Let G be a graph, and let Free(G) be the corresponding free category.
Somebody tells you that the only isomorphisms in Free(G) are the identity morphisms.
Is that person correct? Why or why not?
♦
Example 3.34. In this example, we will see that it is possible for 1 and f to be almost—but
not quite—inverses, in a certain sense.
Consider the functions f : 2 →3 and 1 : 3 →2 drawn below:
•
1
•
2
•
1
•
2
•
3
•
1
•
2
•
3
•
1
•
2
Then the reader should be able to instantly check that f # 1  id2 but 1 # f , id3. Thus f
and 1 are not inverses and hence not isomorphisms. We won’t need this terminology,
but category theorists would say that f and 1 form a retraction.
3.3
Functors, natural transformations, and databases
In Section 3.1 we showed some database schemas: graphs with path equations. Then in
Section 3.2.2 we said that graphs with path equations correspond to ﬁnitely-presented
categories.
Now we want to explain what the data in a database is, as a way to
introduce functors. To do so, we begin by noticing that sets and functions—the objects
and morphisms in the category Set—can be captured by particularly simple databases.
3.3.1
Sets and functions as databases
The ﬁrst observation is that any set can be understood as a table with only one column:
the ID column.
Planet of Sol
Mercury
Venus
Earth
Mars
Jupiter
Saturn
Uranus
Neptune
Prime number
2
3
5
7
11
13
17
...
Flying pig

90
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Rather than put the elements of the set between braces, e.g. {2, 3, 5, 7, 11, . . .}, we write
them down as rows in a table.
In databases, single-column tables are often called controlled vocabularies, or master
data. Now to be honest, we can only write out every single entry in a table when its
set of rows is ﬁnite. A database practitioner might ﬁnd the idea of our prime number
table a bit unrealistic. But we’re mathematicians, so since the idea makes perfect sense
abstractly, we will continue to think of sets as one-column tables.
The above databases have schemas consisting of just one vertex:
Planet of Sol
•
Prime number
•
Flying pig
•
Obviously, there’s really not much diﬀerence between these schemas, other than the
label of the unique vertex. So we could say “sets are databases whose schema consists
of a single vertex.” Let’s move on to functions.
A function f : A →B can almost be depicted as a two-column table
Beatle
Played
George
Lead guitar
John
Rhythm guitar
Paul
Bass guitar
Ringo
Drums
except it is unclear whether the elements of the right-hand column exhaust all of B.
What if there are rock-and-roll instruments out there that none of the Beatles played?
So a function f : A →B requires two tables, one for A and its f column, and one for B:
Beatle
Played
George
Lead guitar
John
Rhythm guitar
Paul
Bass guitar
Ringo
Drums
Rock-and-roll instrument
Bass guitar
Drums
Keyboard
Lead guitar
Rhythm guitar
Thus the database schema for any function is just a labeled version of 2:
Beatle
•
Rock-and-roll
instrument
•
Played
The lesson is that an instance of a database takes a presentation of a category, and turns
every vertex into a set, and every arrow into a function. As such, it describes a map
from the presented category to the category Set. In Section 2.4.2 we saw that maps of
V-categories are known as V-functors. Similarly, we call maps of plain old categories,
functors.

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
91
3.3.2
Functors
A functor is a mapping between categories. It sends objects to objects and morphisms
to morphisms, all while preserving identities and composition. Here is the formal
deﬁnition.
Deﬁnition 3.35. Let C and D be categories. To specify a functor from C to D, denoted
F : C →D,
(i) for every object c ∈Ob(C), one speciﬁes an object F(c) ∈Ob(D);
(ii) for every morphism f : c1 →c2 in C, one speciﬁes a morphism F( f ): F(c1) →
F(c2) in D.
The above constituents must satisfy two properties:
(a) for every object c ∈Ob(C), we have F(idc)  idF(c).
(b) for every three objects c1, c2, c3 ∈Ob(C) and two morphisms f ∈C(c1, c2), 1 ∈
C(c2, c3), the equation F( f # 1)  F( f ) # F(1) holds in D.
Example 3.36. For example, here we draw three functors F : 2 →3:
m0•
•
m1
f1
n0•
n1•
n2•
11
12
m0•
•
m1
f1
n0•
n1•
n2•
11
12
m0•
•
m1
f1
n0•
n1•
n2•
11
12
In each case, the dotted arrows show what the functor F does to the vertices in 2; once
that information is speciﬁed, it turns out—in this special case—that what F does to
the three paths in 2 is completely determined. In the left-hand diagram, F sends every
path to the trivial path, i.e. the identity on n0. In the middle diagram F(m0)  n0,
F( f1)  11, and F(m1)  n1. In the right-hand diagram, F(m0)  n0, F(m1)  n2, and
F( f1)  11 # 12.
Exercise 3.37.
Above we wrote down three functors 2 →3. Find and write down all
the remaining functors 2 →3.
♦
Example 3.38. Recall the categories presented by Free_square and Comm_square in
Section 3.2.2. Here they are again, with ′ added to the labels in Free_square to help

92
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
distinguish them:
Free_square B
A′
•
B′
•
•
C′
•
D′
f ′
1′
h′
i′
no equations
Comm_square B
A•
B•
•
C
•
D
f
1
h
i
f # h  1 # i
There are lots of functors from the free square category (let’s call it F) to the commutative
square category (let’s call it C).
However, there is exactly one functor F : F →C that sends A′ to A, B′ to B, C′ to C,
and D′ to D. That is, once we have made this decision about how F acts on objects,
each of the ten paths in F is forced to go to a certain path in C: the one with the right
source and target.
Exercise 3.39.
Say where each of the ten morphisms in F is sent under the functor F
from Example 3.38.
♦
All of our example functors so far have been completely determined by what they
do on objects, but this is usually not the case.
Exercise 3.40.
Consider the free categories C  • →• and D  • ⇒• . Give two
functors F, G: C →D that act the same on objects but diﬀerently on morphisms.
♦
Example 3.41. There are also lots of functors from the commutative square category C
to the free square category F, but none that sends A to A′, B to B′, C to C′, and D to D′.
The reason is that if F were such a functor, then since f # h  1 # i in C, we would have
F( f # h)  F(1 # i), but then the rules of functors would let us reason as follows:
f ′ # h′  F( f ) # F(h)  F( f # h)  F(1 # i)  F(1) # F(i)  1′ # i′
The resulting equation, f ′ # h′  1′ # i′ does not hold in F because it is a free category
(there are “no equations”): every two paths are considered diﬀerent morphisms. Thus
our proposed F is not a functor.
Example 3.42 (Functors between preorders are monotone maps). Recall from Sec-
tion 3.2.3 that preorders are categories with at most one morphism between any two
objects. A functor between preorders is exactly a monotone map.
For example, consider the preorder (N, ≤) considered as a category N with objects
Ob(N)  N and a unique morphism m →n iﬀm ≤n. A functor F : N →N sends
each object n ∈N to an object F(n) ∈N. It must send morphisms in N to morphisms
in N. This means if there is a morphism m →n then there had better be a morphism
F(m) →F(n). In other words, if m ≤n, then we had better have F(m) ≤F(n). But as

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
93
long as m ≤n implies F(m) ≤F(n), we have a functor.
Thus a functor F : N →N and a monotone map N →N are the same thing.
Exercise 3.43 (The category of categories).
Back in the primordial ooze, there is a
category Cat in which the objects are themselves categories. Your task here is to construct
this category.
1. Given any category C, show that there exists a functor idC : C →C, known as the
identity functor on C, that maps each object to itself and each morphism to itself.
Note that a functor C →D consists of a function from Ob(C) to Ob(D) and for each
pair of objects c1, c2 ∈C a function from C(c1, c2) to D(F(c1), F(c2)).
2. Show that given F : C →D and G: D →E, we can deﬁne a new functor (F #
G): C →E just by composing functions.
3. Show that there is a category, call it Cat, where the objects are categories, mor-
phisms are functors, and identities and composition are given as above.
♦
3.3.3
Database instances as Set-valued functors
Let C be a category, and recall the category Set from Deﬁnition 3.24. A functor F : C →
Set is known as a set-valued functor on C. Much of database theory (not how to make
them fast, but what they are and what you do with them) can be cast in this light.
Indeed, we already saw in Remark 3.20 that any database schema can be regarded as
(presenting) a category C. The next thing to notice is that the data itself—any instance
of the database—is given by a set-valued functor I : C →Set. The only additional
detail is that for any white node, such as c 
string
◦, we want to force I to map to the set
of strings. We suppress this detail in the following deﬁnition.
Deﬁnition 3.44. Let C be a schema, i.e. a ﬁnitely-presented category. A C-instance is a
functor I : C →Set.5
Exercise 3.45. Let 1 denote the category with one object, called 1, one identity morphism
id1, and no other morphisms. For any functor F : 1 →Set one can extract a set F(1).
Show that for any set S, there is a functor FS : 1 →Set such that FS(1)  S.
♦
The above exercise reaﬃrms that the set of planets, the set of prime numbers, and
the set of ﬂying pigs are all set-valued functors—instances—on the schema 1. Similarly,
set-valued functors on the category 2 are functions. All our examples so far are for the
situation where the schema is a free category (no equations). Let’s try an example of a
category that is not free.
5Warning: a C-instance is a state of the database “at an instant in time.” The term “instance” should
not be confused with its usage in object oriented programming, which would correspond more to what
we call a row r ∈I(c).

94
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.46. Consider the following category:
C B
•
z
s
s # s  s
(3.47)
What is a set-valued functor F : C →Set? It will consist of a set Z B F(z) and a function
S B F(s): Z →Z, subject to the requirement that S # S  S. Here are some examples
• Z is the set of US citizens, and S sends each citizen to her or his president. The
president’s president is her- or him-self.
• Z  N is the set of natural numbers and S sends each number to 0. In particular,
0 goes to itself.
• Z is the set of all well-formed arithmetic expressions, such as 13+(2∗4) or −5, that
one can write using integers and the symbols +, −, ∗, (, ). The function S evaluates
the expression to return an integer, which is itself a well-formed expression. The
evaluation of an integer is itself.
• Z  N≥2, and S sends n to its smallest prime factor. The smallest prime factor of
a prime is itself.
N≥2
smallest prime factor
2
2
3
3
4
2
...
...
49
7
50
2
51
3
...
...
Exercise 3.48.
Above, we thought of the sort of data that would make sense for the
schema (3.47). Give an example of the sort of data that would make sense for the
following schemas:
1.
•
z
s
s # s  z
2.
a•
b•
c•
f
1
h
f # 1  f # h
♦
The main idea is this: a database schema is a category, and an instance on that
schema—the data itself—is a set-valued functor. All the constraints, or business rules,
are ensured by the rules of functors, namely that functors preserve composition.6
6One can put more complex constraints, called embedded dependencies, on a database; these correspond
category theoretically to what are called “lifting problems” in category theory. See [Spi14b] for more on
this.

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
95
3.3.4
Natural transformations
If C is a schema—i.e. a ﬁnitely-presented category—then there are many database
instances on it, which we can organize into a category. But this is part of a larger story,
namely that of natural transformations. An abstract picture to have in mind is this:
C
D.
F
G
α
Deﬁnition 3.49. Let C and D be categories, and let F, G: C →D be functors. To specify
a natural transformation α: F ⇒G,
(i) for each object c ∈C, one speciﬁes a morphism αc : F(c) →G(c) in D, called the
c-component of α.
These components must satisfy the following, called the naturality condition:
(a) for every morphism f : c →d in C, the following equation must hold:
F( f ) # αd  αc # G( f ).
A natural transformation α: F →G is called a natural isomorphism if each component
αc is an isomorphism in D.
The naturality condition can also be written as a so-called commutative diagram. A
diagram in a category is drawn as a graph whose vertices and arrows are labeled by
objects and morphisms in the category. For example, here is a diagram that’s relevant
to the naturality condition in Deﬁnition 3.49:
F(c)
G(c)
F(d)
G(d)
αc
F( f )
G( f )
αd
(3.50)
Deﬁnition 3.51. A diagram D in C is a functor D : J →C from any category J, called
the indexing category of the diagram D. We say that D commutes if D( f )  D( f ′) holds
for every parallel pair of morphisms f , f ′: a →b in J.7
In terms of Eq. (3.50), the only case of two parallel morphisms is that of F(c) ⇒G(d),
so to say that the diagram commutes is to say that F( f ) # αd  αc # G( f ). This is exactly
the naturality condition from Deﬁnition 3.49.
7We could package this formally by saying that D commutes iﬀit factors through the preorder
reﬂection of J.

96
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.52. A representative picture is as follows:
1•
2•
f
C B
u•
v•
w•
x•
y
•
z•
a
b
d
c
e
1
h
k
: D
F
G
We have depicted, in blue and red respectively, two functors F, G: C →D. A natural
transformation α: F ⇒G is given by choosing components α1 : v →x and α2 : w →y.
We have highlighted the only choice for each in green; namely, α1  c and α2  1.
The key point is that the functors F and G are ways of viewing the category C as
lying inside the category D. The natural transformation α, then, is a way of relating
these two views using the morphisms in D. Does this help you to see and appreciate
the notation C
D?
F
G
α⇓
Example 3.53. We said in Exercise 3.45 that a functor 1 →Set can be identiﬁed with
a set. So suppose A and B are sets considered as functors A, B : 1 →Set. A natural
transformation between these functors is just a function between the sets.
Deﬁnition 3.54. Let C and D be categories. We denote by DC the category whose objects
are functors F : C →D and whose morphisms DC(F, G) are the natural transformations
α: F →G. This category DC is called the functor category, or the category of functors from
C to D.
Exercise 3.55.
Let’s look more deeply at how DC is a category.
1. Figure out how to compose natural transformations. (Hint: an expert tells you
“for each object c ∈C, compose the c-components.”)
2. Propose an identity natural transformation on any object F ∈DC, and check that
it is unital (i.e. that it obeys condition (a) of Deﬁnition 3.6).
♦
Example 3.56. In our new language, Example 3.53 says that Set1 is equivalent to Set.
Example 3.57. Let N denote the category associated to the preorder (N, ≤), and recall
from Example 3.42 that we can identify a functor F : N →N with a non-decreasing
sequence (F0, F1, F2, . . .) of natural numbers, i.e. F0 ≤F1 ≤F2 ≤· · · . If G is another
functor, considered as a non-decreasing sequence, then what is a natural transformation

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
97
α: F →G?
Since there is at most one morphism between two objects in a preorder, each com-
ponent αn : Fn →Gn has no data, it just tells us a fact: that Fn ≤Gn. And the naturality
condition is vacuous: every square in a preorder commutes. So a natural transforma-
tion between F and G exists iﬀFn ≤Gn for each n, and any two natural transformations
F ⇒G are the same. In other words, the category NN is itself a preorder; namely the
preorder of monotone maps N →N.
Exercise 3.58.
Let C be an arbitrary category and let P be a preorder, thought of as a
category. Consider the following statements:
1. For any two functors F, G: C →P, there is at most one natural transformation
F →G.
2. For any two functors F, G: P →C, there is at most one natural transformation
F →G.
For each, if it is true, say why; if it is false, give a counterexample.
♦
Remark 3.59. Recall that in Remark 2.71 we said the category of preorders is equivalent to
the category of Bool-categories. We can now state the precise meaning of this sentence.
First, there exists a category PrO in which the objects are preorders and the morphisms
are monotone maps. Second, there exists a category Bool-Cat in which the objects are
Bool-categories and the morphisms are Bool-functors. We call these two categories
equivalent because there exist functors F : PrO →Bool-Cat and G: Bool-Cat →PrO
such that there exist natural isomorphisms F # G  idPrO and G # F  idBool-Cat in the
sense of Deﬁnition 3.49.
3.3.5
The category of instances on a schema
Deﬁnition 3.60. Suppose that C is a database schema and I, J : C →Set are database
instances. An instance homomorphism between them is a natural transformation α: I →
J. Write C-Inst B SetC to denote the functor category as deﬁned in Deﬁnition 3.54.
We saw in Example 3.53 that 1-Inst is equivalent to the category Set.
In this
subsection, we will show that there is a schema whose instances are graphs and whose
instance homomorphisms are graph homomorphisms.
Extended example: the category of graphs as a functor category.
You may ﬁnd
yourself back in the primordial ooze (ﬁrst discussed in Section 2.3.2), because while
previously we have been using graphs to present categories, now we obtain graphs
themselves as database instances on a speciﬁc schema (which is itself a graph):
Gr B
Arrow
•
Vertex
•
source
target
no equations

98
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Here’s an example Gr-instance, i.e. set-valued functor I : Gr →Set, in table form:
Arrow
source
target
a
1
2
b
1
3
c
1
3
d
2
2
e
2
3
Vertex
1
2
3
4
(3.61)
Here I(Arrow)  {a, b, c, d, e}, and I(Vertex)  {1, 2, 3, 4}. One can draw the instance
I as a graph:
I 
1•
2•
3•
4•
a
b
c
e
d
Every row in the Vertex table is drawn as a vertex, and every row in the Arrow table
is drawn as an arrow, connecting its speciﬁed source and target. Every possible graph
can be written as a database instance on the schema Gr, and every possible Gr-instance
can be represented as a graph.
Exercise 3.62.
In Eq. (3.2), a graph is shown (forget the distinction between white and
black nodes). Write down the corresponding Gr-instance, as in Eq. (3.61). (Do not be
concerned that you are in the primordial ooze.)
♦
Thus the objects in the category Gr-Inst are graphs. The morphisms in Gr-Inst
are called graph homomorphisms. Let’s unwind this. Suppose that G, H : Gr →Set
are functors (i.e. Gr-instances); that is, they are objects G, H ∈Gr-Inst. A morphism
G →H is a natural transformation α: G →H between them; what does that entail?
By Deﬁnition 3.49, since Gr has two objects, α consists of two components,
αVertex : G(Vertex) →H(Vertex)
and
αArrow : G(Arrow) →H(Arrow),
both of which are morphisms in Set. In other words, α consists of a function from
vertices of G to vertices of H and a function from arrows of G to arrows of H. For these
functions to constitute a graph homomorphism, they must “respect source and target”
in the precise sense that the naturality condition, Eq. (3.50) holds. That is, for every
morphism in Gr, namely source and target, the following diagrams must commute:
G(Arrow)
H(Arrow)
G(Vertex)
H(Vertex)
αArrow
G(source)
H(source)
αVertex
G(Arrow)
H(Arrow)
G(Vertex)
H(Vertex)
αArrow
G(target)
H(target)
αVertex
These may look complicated, but they say exactly what we want. We want the functions
αVertex and αArrow to respect source and targets in G and H. The left diagram says “start

3.4. ADJUNCTIONS AND DATA MIGRATION
99
with an arrow in G. You can either apply α to the arrow and then take its source in H,
or you can take its source in G and then apply α to that vertex; either way you get the
same answer.” The right-hand diagram says the same thing about targets.
Example 3.63. Consider the graphs G and H shown below
G B
1•
2•
3•
a
b
H B
4•
5•
c
d
e
Here they are, written as database instances—i.e. set-valued functors—on Gr:
G B
Arrow
source
target
a
1
2
b
2
3
Vertex
1
2
3
H B
Arrow
source
target
c
4
5
d
4
5
e
5
5
Vertex
4
5
The top row is G and the bottom row is H. They are oﬀset so you can more easily
complete the following exercise.
Exercise 3.64.
We claim that—with G, H as in Example 3.63—there is exactly one
graph homomorphism α: G →H such that αArrow(a)  d.
1. What is the other value of αArrow, and what are the three values of αVertex?
2. In your own copy of the tables of Example 3.63, draw αArrow as two lines connect-
ing the cells in the ID column of G(Arrow) to those in the ID column of H(Arrow).
Similarly, draw αVertex as connecting lines.
3. Check the source column and target column and make sure that the matches are
natural, i.e. that “alpha-then-source equals source-then-alpha” and similarly for
“target.”
♦
3.4
Adjunctions and data migration
We have talked about how set-valued functors on a schema can be understood as ﬁlling
that schema with data. But there are also functors between schemas. When the two
sorts of functors are composed, data is migrated. This is the simplest form of data
migration; more complex ways to migrate data come from using adjoints. All of the
above is the subject of this section.

100
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
3.4.1
Pulling back data along a functor
To begin, we will migrate data between the graph-indexing schema Gr and the loop
schema, which we call DDS, shown below
Gr B
Arrow
•
Vertex
•
source
target
no equations
DDS B
State
•
next
no equations
We begin by writing down a sample instance I : DDS →Set on this schema:
State
next
1
4
2
4
3
5
4
5
5
5
6
7
7
6
(3.65)
We call the schema DDS to stand for discrete dynamical system. Indeed, we may think
of the data in the DDS-instance of Eq. (3.65) as listing the states and movements of a
deterministic machine: at every point in time the machine is in one of the listed states,
and given the machine in one of the states, in the next instant it moves to a uniquely
determined next state.
Our goal is to migrate the data in Eq. (3.65) to data on Gr; this will give us the data
of a graph and so allow us to visualise our machine.
We will use a functor connecting these schemas in order to move data between
them. The reader can create any functor she likes, but we will use a speciﬁc functor
F : Gr →DDS to migrate data in a way that makes sense to us, the authors. Here we
draw F, using colors to hopefully aid understanding:
Arrow
•
Vertex
•
source
target
Gr
State
•
next
DDS
F
The functor F sends both objects of Gr to the ‘State’ object of DDS (as it must). On
morphisms, it sends the ‘source’ morphism to the identity morphism on ‘State’, and
the ‘target’ morphism to the morphism ‘next’.

3.4. ADJUNCTIONS AND DATA MIGRATION
101
A sample database instance on DDS was given in Eq. (3.65); recall this is a functor
I : DDS →Set. So now we have two functors as follows:
Gr
DDS
Set.
F
I
(3.66)
Objects in Gr are sent by F to objects in DDS, which are sent by I to objects in Set,
which are sets. Morphisms in Gr are sent by F to morphisms in DDS, which are
sent by I to morphisms in Set, which are functions. This deﬁnes a composite functor
F #I : Gr →Set. Both F and I respect identities and composition, so F #I does too. Thus
we have obtained an instance on Gr, i.e. we have converted our discrete dynamical
system from Eq. (3.65) into a graph! What graph is it?
For an instance on Gr, we need to ﬁll an Arrow table and a Vertex table. Both
of these are sent by F to State, so let’s ﬁll both with the rows of State in Eq. (3.65).
Similarly, since F sends ‘source’ to the identity and sends ‘target’ to ‘next’, we obtain
the following tables:
Arrow
source
target
1
1
4
2
2
4
3
3
5
4
4
5
5
5
5
6
6
7
7
7
6
Vertex
1
2
3
4
5
6
7
Now that we have a graph, we can draw it.
1•
2•
3•
4•
6•
7•
•
5
1
2
3
4
6
7
5
Each arrow is labeled by its source vertex, as if to say, “What I do next is determined
by what I am now.”
Exercise 3.67.
Consider the functor G: Gr →DDS given by sending ‘source’ to ‘next’
and sending ‘target’ to the identity on ‘State’.
Migrate the same data, called I in
Eq. (3.65), using the functor G. Write down the tables and draw the corresponding
graph.
♦
We refer to the above procedure—basically just composing functors as in Eq. (3.66)—
as “pulling back data along a functor.” We just now pulled back data I along functor
F.

102
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Deﬁnition 3.68. Let C and D be categories and let F : C →D be a functor. For any
set-valued functor I : D →Set, we refer to the composite functor F # I : C →Set as the
pullback of I along F.
Given a natural transformation α: I ⇒J, there is a natural transformation αF : F#I ⇒
F # J, whose component (F # I)(c) →(F # J)(c) for any c ∈Ob(C) is given by (αF)c B αFc.
C
D
Set
F
I
J
α
{
C
Set
F#I
F#J
αF
This uses the data of F to deﬁne a functor ∆F : D-Inst →C-Inst.
Note that the term pullback is also used for a certain sort of limit, for more details
see Remark 3.100.
3.4.2
Adjunctions
In Section 1.4 we discussed Galois connections, which are adjunctions between pre-
orders. Now that we’ve deﬁned categories and functors, we can discuss adjunctions
in general. The relevance to databases is that the data migration functor ∆from Deﬁ-
nition 3.68 always has two adjoints of its own: a left adjoint which we denote Σ and a
right adjoint which we denote Π.
Recall that an adjunction between preorders P and Q is a pair of monotone maps
f : P →Q and 1 : Q →P that are almost inverses: we have
f (p) ≤q if and only if p ≤1(q).
(3.69)
Recall from Section 3.2.3 that in a preorder P, a hom-set P(a, b) has one element when
a ≤b, and no elements otherwise. We can thus rephrase Eq. (3.69) as an isomorphism
of sets Q( f (p), q)  P(p, 1(q)): either both are one-element sets or both are 0-element
sets. This suggests how to deﬁne adjunctions in the general case.
Deﬁnition 3.70. Let C and D be categories, and L: C →D and R: D →C be functors.
We say that L is left adjoint to R (and that R is right adjoint to L) if, for any c ∈C and
d ∈D, there is an isomorphism of hom-sets
αc,d : C(c, R(d))
−→D(L(c), d)
that is natural in c and d.8
Given a morphism f : c →R(d) in C, its image 1 B αc,d( f ) is called its mate.
Similarly, the mate of 1 : L(c) →d is f .

3.4. ADJUNCTIONS AND DATA MIGRATION
103
To denote an adjunction we write L ⊣R, or in diagrams,
C
D
L
R
with the ⇒in the direction of the left adjoint.
Example 3.71. Recall that every preorder P can be regarded as a category.
Galois
connections between preorders and adjunctions between the corresponding categories
are exactly the same thing.
Example 3.72. Let B ∈Ob(Set) be any set. There is an adjunction called ‘currying B,’
after the logician Haskell Curry:
Set
Set
−×B
(−)B
Set(A × B, C)  Set(A, CB)
Abstractly we write it as on the left, but what this means is that for any sets A, C, there
is a natural isomorphism as on the right.
To explain this, we need to talk about exponential objects in Set. Suppose that B
and C are sets. Then the set of functions B →C is also a set; let’s denote it CB. It’s
written this way because if C has 10 elements and B has 3 elements then CB has 103
elements, and more generally for any two ﬁnite sets |CB|  |C||B|.
The idea of currying is that given sets A, B, and C, there is a one-to-one correspon-
dence between functions (A × B) →C and functions A →CB. Intuitively, if I have a
function f of two variables a, b, I can “put oﬀ” entering the second variable: if you give
me just a, I’ll return a function B →C that’s waiting for the B input. This is the curried
version of f . As one might guess, there is a formal connection between exponential
objects and what we called hom-elements b ⊸c in Deﬁnition 2.79.
Exercise 3.73.
In Example 3.72, we discussed an adjunction between functors −× B
and (−)B. But we only said how these functors worked on objects: for an arbitrary set
X, they return sets X × B and XB respectively.
8This naturality is between functors Cop × D →Set. It says that for any morphisms f : c′ →c in C
and 1 : d →d′ in D, the following diagram commutes:
C(c, Rd)
D(Lc, d)
C(c′, Rd′)
D(Lc′, d′)
C( f ,R1)
αc,d
D(L f ,1)
αc′,d′

104
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
1. Given a morphism f : X →Y, what morphism should −× B : X × B →Y × B
return?
2. Given a morphism f : X →Y, what morphism should (−)B : XB →YB return?
3. Consider the function +: N × N →N, which sends (a, b) 7→a + b. Currying +,
we get a certain function p : N →NN. What is p(3)?
♦
Example 3.74. If you know some abstract algebra or topology, here are some other
examples of adjunctions.
1. Free constructions: given any set you get a free group, free monoid, free ring, free
vector space, etc.; each of these is a left adjoint. The corresponding right adjoint
takes a group, a monoid, a ring, a vector space etc. and forgets the algebraic
structure to return the underlying set.
2. Similarly, given a graph you get a free preorder or a free category, as we discussed
in Section 3.2.3; each is a left adjoint. The corresponding right adjoint is the
underlying graph of a preorder or of a category.
3. Discrete things: given any set you get a discrete preorder, discrete graph, discrete
metric space, discrete category, discrete topological space; each of these is a left
adjoint. The corresponding right adjoint is again underlying set.
4. Codiscrete things: given any set you get a codiscrete preorder, complete graph,
codiscrete category, codiscrete topological space; each of these is a right adjoint.
The corresponding left adjoint is the underlying set.
5. Given a group, you can quotient by its commutator subgroup to get an abelian
group; this is a left adjoint. The right adjoint is the inclusion of abelian groups
into groups.
3.4.3
Left and right pushforward functors, Σ and Π
Given F : C →D, the data migration functor ∆F turns D-instances into C-instances.
This functor has both a left and a right adjoint:
C-Inst
D-Inst
ΣF
ΠF
∆F

3.4. ADJUNCTIONS AND DATA MIGRATION
105
Using the names Σ and Π in this context is fairly standard in category theory. In the
case of databases, they have the following helpful mnemonic:
Migration Functor
Pronounced
Reminiscent of
Database idea
∆
Delta
Duplicate
or destroy
Duplicate or destroy
tables or columns
Σ
Sigma
Sum
Union (sum up) data
Π
Pi
Product
Pair9 and query data
Just like we used ∆F to pull back any discrete dynamical system along F : Gr →DDS
and get a graph, the migration functors ΣF and ΠF can be used to turn any graph into
a discrete dynamical system.
That is, given an instance J : Gr →Set, we can get
instances ΣF(J) and ΠF(J) on DDS. This, however, is quite technical, and we leave it
to the adventurous reader to compute an example, with help perhaps from [Spi14a],
which explores the deﬁnitions of Σ and Π in detail. A less technical shortcut is simply
to code up the computation in the open-source FQL software.
To get the basic idea across without getting mired in technical details, here we shall
instead discuss a very simple example. Recall the schemas from Eq. (3.5). We can set
up a functor between them, the one sending black dots to black dots and white dots to
white dots:
$◦
Economy
•
First Class
•
string
◦
Price
Position
Price
Position
A B
$◦
Airline Seat
•
string
◦
Price
Position
: B
F
With this functor F in hand, we can transform any B-instance into an A-instance using
∆F. Whereas ∆was interesting in the case of turning discrete dynamical systems into
graphs in Section 3.4.1, it is not very interesting in this case. Indeed, it will just copy—∆
for duplicate—the rows in Airline seat into both Economy and First Class.
∆F has two adjoints, ΣF and ΠF, both of which transform any A-instance I into a
B-instance. The functor ΣF does what one would most expect from reading the names
on each object: it will put into Airline Seat the union of Economy and First Class:
ΣF(I)(Airline Seat)  I(Economy) ⊔I(First Class).
The functor ΠF puts into Airline Seat the set of those pairs (e, f ) where e is an
Economy seat, f is a First Class seat, and e and f have the same price and position.
9This is more commonly called “join” by database programmers.

106
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
In this particular example, one imagines that there should be no such seats in a valid
instance I, in which case ΠF(I)(Airline Seat) would be empty. But in other uses of these
same schemas, ΠF can be a useful operation. For example, in the schema A replace
the label ‘Economy’ by ‘Rewards Program’, and in B replace ‘Airline Seat’ by ‘First
Class Seats’. Then the operation ΠF ﬁnds those ﬁrst class seats that are also rewards
program seats. This operation is a kind of database query; querying is the operation
that databases are built for.
The moral is that complex data migrations can be speciﬁed by constructing functors
F between schemas and using the “induced” functors ∆F, ΣF, and ΠF. Indeed, in
practice essentially all useful migrations can be built up from these. Hence the language
of categories provides a framework for specifying and reasoning about data migrations.
3.4.4
Single set summaries of databases
To give a stronger idea of the ﬂavor of Σ and Π, we consider another special case,
namely where the target category D is equal to 1; see Exercise 3.12. In this case, there
is exactly one functor C →1 for any C; let’s denote it
!: C →1.
(3.75)
Exercise 3.76.
Describe the functor !: C →1 from Eq. (3.75). Where does it send each
object? What about each morphism?
♦
We want to consider the data migrationfunctorsΣ! : C-Inst →1-Inst andΠ! : C-Inst →
1-Inst. In Example 3.53, we saw that an instance on 1 is the same thing as a set. So let’s
identify 1-Inst with Set, and hence discuss
Σ! : C-Inst →Set
and
Π! : C-Inst →Set.
Given any schema C and instance I : C →Set, we will get sets Σ!(I) and Π!(I). Thinking
of these sets as database instances, each corresponds to a single one-column table—a
controlled vocabulary—summarizing an entire database instance on the schema C.
Consider the following schema
G B
Email
•
Address
•
sent_by
received_by
no equations
(3.77)
Here’s a sample instance I : G →Set:
Email
sent_by
received_by
Em_1
Bob
Grace
Em_2
Grace
Pat
Em_3
Bob
Emmy
Em_4
Sue
Doug
Em_5
Doug
Sue
Em_6
Bob
Bob
Address
Bob
Doug
Emmy
Grace
Pat
Sue

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
107
Exercise 3.78. Note that G from Eq. (3.77) is isomorphic to theschema Gr. In Section 3.3.5
we saw that instances on Gr are graphs. Draw the above instance I as a graph.
♦
Now we have a unique functor !: G →1, and we want to say what Σ!(I) and Π!(I) give
us as single-set summaries. First, Σ!(I) tells us all the emailing groups—the “connected
components”—in I:
1
Bob-Grace-Pat-Emmy
Sue-Doug
This form of summary, involving identifying entries into common groups, or quotients,
is typical of Σ-operations.
The functor Π!(I) lists the emails from I which were sent from a person to her- or
him-self.
1
Em_6
This is again a sort of query, selecting the entries that ﬁt the criterion of self-to-self
emails. Again, this is typical of Π-operations.
Where do these facts—that Π! and Σ! act the way we said—come from? Everything
follows from the deﬁnition of adjoint functors (3.70): indeed we hope this, together
with the examples given in Example 3.74, give the reader some idea of how general
and useful adjunctions are, both in mathematics and in database theory.
One more point: while we will not spell out the details, we note that these operations
are also examples of constructions known as colimits and limits in Set. We end this
chapter with bonus material, exploring these key category theoretic constructions. The
reader should keep in mind that, in general and not just for functors to 1, Σ-operations
are built from colimits in Set, and Π-operations are built from limits in Set.
3.5
Bonus: An introduction to limits and colimits
What do products of sets, the results of Π!-operations on database instances, and meets
in a preorder all have in common? The answer, as we shall see, is that they are all
examples of limits. Similarly, disjoint unions of sets, the results of Σ!-operations on
database instances, and joins in a preorder are all colimits. Let’s begin with limits.
Recall that Π! takes a database instance I : C →Set and turns it into a set Π!(I).
More generally, a limit turns a functor F : C →D into an object of D.
3.5.1
Terminal objects and products
Terminal objects and products are each a sort of limit. Let’s discuss them in turn.
Terminal objects.
The most basic limit is a terminal object.

108
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Deﬁnition 3.79. Let C be a category. Then an object Z in C is a terminal object if, for
each object C of C, there exists a unique morphism !: C →Z.
Since this unique morphism exists for all objects in C, we say that terminal objects
have a universal property.
Example 3.80. In Set, any set with exactly one element is a terminal object.
Why?
Consider some such set {•}. Then for any other set C we need to check that there is
exactly one function !: C →{•}. This unique function is the one that does the only
thing that can be done: it maps each element c ∈C to the element • ∈{•}.
Exercise 3.81.
Let (P, ≤) be a preorder, let z ∈P be an element, and let P be the
corresponding category (see Section 3.2.3). Show that z is a terminal object in P if and
only if it is a top element in P: that is, if and only if for all c ∈P we have c ≤z.
♦
Exercise 3.82.
Name a terminal object in the category Cat. (Hint: recall Exercise 3.76.)
♦
Exercise 3.83.
Not every category has a terminal object. Find one that doesn’t.
♦
Proposition 3.84. All terminal objects in a category C are isomorphic.
Proof. This is a simple, but powerful standard argument. Suppose Z and Z′ are both
terminal objects in some category C. Then there exist (unique) maps a : Z →Z′ and
b : Z′ →Z. Composing these, we get a map a # b : Z →Z. Now since Z is terminal, this
map Z →Z must be unique. But idZ is also such a map. So we must have a # b  idZ.
Similarly, we ﬁnd that b # a  idZ′. Thus a is an isomorphism, with inverse b.
□
Remark 3.85 (“The limit” vs. “a limit”). Not only are all terminal objects isomorphic,
there is a unique isomorphism between any two. We hence say “terminal objects are
unique up to unique isomorphism.” To a category theorist, this is very nearly the same
thing as saying “all terminal objects are equal.” Thus we often abuse terminology and
talk of ‘the’ terminal object, rather than “a” terminal object. We will do the same for any
sort of limit or colimit, e.g. speak of “the product” of two sets, rather than “a product.”
We saw a similar phenomenon in Deﬁnition 1.81.
Products.
Products are slightly more complicated to formalize than terminal objects,
but they are familiar in practice.
Deﬁnition 3.86. Let C be a category, and let X, Y be objects in C. A product of X and Y is
an object, denoted X ×Y, together with morphisms pX : X ×Y →X and pY : X ×Y →Y
such that for all objects C together with morphisms f : C →X and 1 : C →Y, there
exists a unique morphism C →X ×Y, denoted ⟨f , 1⟩, for which the following diagram

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
109
commutes:
C
X
Y
X × Y
f
1
⟨f ,1⟩
pX
pY
We will try to bring this down to earth in Example 3.87. Before we do, note that
X × Y is an object equipped with morphisms to X and Y. Roughly speaking, it is like
“the best object-equipped-with-morphisms-to-X-and-Y” in all of C, in the sense that
any other object-equipped-with-morphisms-to-X-and-Y maps to it uniquely. This is
called a universal property. It’s customary to use a dotted line to indicate the unique
morphism that exists because of some universal property.
Example 3.87. In Set, a product of two sets X and Y is their usual cartesian product
X × Y B {(x, y) | x ∈X, y ∈Y},
which comes with two projections pX : X × Y →X and pY : X × Y →Y, given by
pX(x, y) B x and pY(x, y) B y.
Given any set C with functions f : C →X and 1 : C →Y, the unique map from C
to X × Y such that the required diagram commutes is given by ⟨f , 1⟩(c) B ( f (c), 1(c)).
Here is a picture of the product 6 × 4 of sets 6 and 4.
(1,1)
•
1•
(1,2)
•
2•
(1,3)
•
3•
(1,4)
•
4•
1•
(2,1)
•
(2,2)
•
(2,3)
•
(2,4)
•
2•
(3,1)
•
(3,2)
•
(3,3)
•
(3,4)
•
3•
(4,1)
•
(4,2)
•
(4,3)
•
(4,4)
•
4•
(5,1)
•
(5,2)
•
(5,3)
•
(5,4)
•
5•
(6,1)
•
(6,2)
•
(6,3)
•
(6,4)
•
6•
C
∀f
∀1
∃!
Exercise 3.88.
Let (P, ≤) be a preorder, let x, y ∈P be elements, and let P be the
corresponding category. Show that the product x × y in P agrees with their meet x ∧y
in P.
♦

110
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.89. Given two categories C and D, their product C × D may be given as
follows. The objects of this category are pairs (c, d), where c is an object of C and d is an
object of D. Similarly, morphisms (c, d) →(c′, d′) are pairs ( f , 1) where f : c →c′ is a
morphism in C and 1 : d →d′ is a morphism in D. Composition of morphisms is simply
given by composing each entry in the pair separately, so ( f , 1) # ( f ′, 1′)  ( f # f ′, 1 # 1′).
Exercise 3.90.
1. What are the identity morphisms in a product category C × D?
2. Why is composition in a product category associative?
3. What is the product category 1 × 2?
4. What is the product category P × Q when P and Q are preorders and P and Q are
the corresponding categories?
♦
These two constructions, terminal objects and products, are subsumed by the notion
of limit.
3.5.2
Limits
We’ll get a little abstract. Consider the deﬁnition of product. This says that given any
pair of maps X
f
←−C
1
−→Y, there exists a unique map C →X × Y such that certain
diagrams commute. This has the ﬂavor of being terminal—there is a unique map to
X × Y—but it seems a bit more complicated. How are the two ideas related?
It turns out that products are terminal objects, but of a diﬀerent category, which
we’ll call Cone(X, Y), the category of cones over X and Y in C. We will see in Exercise 3.91
that X
pX
←−−X × Y
pY
−−→Y is a terminal object in Cone(X, Y).
An object of Cone(X, Y) is simply a pair of maps X
f
←−C
1
−→Y. A morphism from
X
f
←−C
1
−→Y to X
f ′
←−C′
1′
−→Y in Cone(X, Y) is a morphism a : C →C′ in C such that
the following diagram commutes:
C
X
Y
C′
f
1
a
f ′
1′
Exercise 3.91.
Check that a product X
pX
←−−X ×Y
pY
−−→Y is exactly the same as a terminal
object in Cone(X, Y).
♦
We’re now ready for the abstract deﬁnition. Don’t worry if the details are unclear;
the main point is that it is possible to unify terminal objects, maximal elements, and
meets, products of sets, preorders, and categories, and many other familiar friends
under the scope of a single deﬁnition.
In fact, they’re all just terminal objects in
diﬀerent categories.

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
111
Recall from Deﬁnition 3.51 that formally speaking, a diagram in C is just a functor
D : J →C. Here J is called the indexing category of the diagram D.
Deﬁnition 3.92. Let D : J →C be a diagram. A cone (C, c∗) over D consists of
(i) an object C ∈C;
(ii) for each object j ∈J, a morphism cj : C →D(j).
To be a cone, these must satisfy the following property:
(a) for each f : j →k in J, we have ck  cj # D( f ).
A morphism of cones (C, c∗) →(C′, c′
∗) is a morphism a : C →C′ in C such that for all
j ∈J we have cj  a #c′
j. Cones over D, and their morphisms, form a category Cone(D).
The limit of D, denoted lim(D), is the terminal object in the category Cone(D). Say
it is the cone lim(D)  (C, c∗); we refer to C as the limit object and the map cj for any
j ∈J as the jth projection map.
For visualization purposes, if J is the free category on the graph
1
3
2
4
5
with ﬁve objects and ﬁve non-identity morphisms, then we may draw a diagram
D : J →C inside C as on the left below, and a cone on it as on the right:
C
D1
D3
D2
D4
D5
C
D1
D3
D2
D4
D5
c1
c2
c3
c4
c5
Here, any two parallel paths that start at C are considered the same. Note that both
these diagrams depict a collection of objects and morphisms inside the category C.
Example 3.93. Terminal objects are limits where the indexing category is empty, J  .
Example 3.94. Products are limits where the indexing category consists of two objects
v, w and no arrows, J 
v•
w• .
3.5.3
Finite limits in Set
Recall that this discussion was inspired by wanting to understand Π-operations, and
in particular Π!. We can now see that a database instance I : C →Set is a diagram in

112
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Set. The functor Π! takes the limit of this diagram. In this subsection we give a formula
describing the result. This captures all ﬁnite limits in Set.
In database theory, we work with categories C that are presented by a ﬁnite graph
plus equations. We won’t explain the details, but it’s in fact enough just to work with
the graph part: as far as limits are concerned, the equations in C don’t matter. For
consistency with the rest of this section, let’s denote the database schema by J instead
of C.
Theorem 3.95. Let J be a category presented by the ﬁnite graph (V, A, s, t) together with
some equations, and let D : J →Set be a set-valued functor. Write V  {v1, . . . , vn}.
The set
lim
J D B

(d1, . . . , dn) | di ∈D(vi) for all 1 ≤i ≤n and
for all a : vi →vj ∈A, we have D(a)(di)  dj
	
.
together with the projection maps pi : (limJ D) →D(vi) given by pi(d1, . . . , dn) B di,
is a limit of D.
Example 3.96. If J is the empty graph • , then n  0: there are no vertices. There is ex-
actly one empty tuple ( ), which vacuously satisﬁes the properties, so we’ve constructed
the limit as the singleton set {( )} consisting of just the empty tuple. Thus the limit of
the empty diagram, i.e. the terminal object in Set is the singleton set. See Remark 3.85.
Exercise 3.97.
Show that the limit formula in Theorem 3.95 works for products. See
Example 3.94.
♦
Exercise 3.98.
If D : 1 →Set is a functor, what is the limit of D? Compute it using
Theorem 3.95, and check your answer against Deﬁnition 3.92.
♦
Pullbacks.
In particular, the condition that the limit of D : J →Set selects tuples
(d1, . . . , dn) such that D(a)(di)  dj for each morphism a : i →j in J allows us to use
limits to select data that satisﬁes certain equations or constraints. This is what allows
us to express queries in terms of limits. Here is an example.
Example 3.99. If J is presented by the cospan graph
x•
f
−−→
a•
1
←−−
y
• , then its limit is
known as a pullback. Given the diagram X
f
−→A
1
←−Y, the pullback is the cone shown

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
113
on the left below:
C
Y
X
A
cx
cy
ca
1
f
X ×A Y
Y
X
A
cx
cy
1
f
⌟
The fact that the diagram commutes means that the diagonal arrow ca is in some
sense superﬂuous, so one generally denotes pullbacks by dropping the diagonal arrow,
naming the cone point X ×A Y, and adding the ⌟symbol, as shown to the right above.
Here is a picture to help us unpack the deﬁnition in Set. We take X  6, Y  4, and
A to be the set of colors {red, blue, black}.
(1,1)
•
1•
(1,2)
•
2•
(1,3)
•
3•
(1,4)
•
4•
1•
(2,1)
•
(2,2)
•
(2,3)
•
(2,4)
•
2•
(3,1)
•
(3,2)
•
(3,3)
•
(3,4)
•
3•
(4,1)
•
(4,2)
•
(4,3)
•
(4,4)
•
4•
(5,1)
•
(5,2)
•
(5,3)
•
(5,4)
•
5•
(6,1)
•
(6,2)
•
(6,3)
•
(6,4)
•
6•
The functions f : 6 →A and 1 : 4 →A are expressed in the coloring of the dots: for
example, 1(2)  1(4)  red, while f (5)  black. The pullback selects pairs (i, j) ∈6 × 4
such that f (i) and 1(j) have the same color.
Remark 3.100. As mentioned following Deﬁnition 3.68, this deﬁnition of pullback is
not to be confused with the pullback of a set-valued functor along a functor; they are
for now best thought of as diﬀerent concepts which accidentally have the same name.
Due to the power of the primordial ooze, however, the pullback along a functor is a
special case of pullback as the limit of a cospan: it can be understood as the pullback
of a certain cospan in Cat. To unpack this, however, requires the notions of category of
elements and discrete opﬁbration; ask your friendly neighborhood category theorist.
3.5.4
A brief note on colimits
Just like upper bounds have a dual concept—namely that of lower bounds—so limits
have a dual concept: colimits. To expose the reader to this concept, we provide a
succinct deﬁnition of these using opposite categories and opposite functors. The point,
however, is just exposure; we will return to explore colimits in detail in Chapter 6.
Exercise 3.101.
Recall from Example 3.27 that every category C has an opposite Cop.
Let F : C →D be a functor. How should we deﬁne its opposite, Fop : Cop →Dop? That

114
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
is, how should Fop act on objects, and how should it act on morphisms?
♦
Deﬁnition 3.102. Given a category C we say that a cocone in C is a cone in Cop.
Given a diagram D : J →C, we may take the limit of the functor Dop : Jop →Cop.
This is a cone in Cop, and so by deﬁnition a cocone in C. The colimit of D is this cocone.
Deﬁnition 3.102 is like a compressed ﬁle: useful for transmitting quickly, but com-
pletely useless for working with, unless you can successfully unpack it. We will unpack
it later in Chapter 6 when we discuss electric circuits.
3.6
Summary and further reading
Congratulations on making it through one of the longest chapters in the book! We
apologize for the length, but this chapter had a lot of work to do. Namely it introduced
the “big three” of category theory—categories, functors, and natural transformations—
as well as discussed adjunctions, limits, and very brieﬂy colimits.
That’s really quite a bit of material. For more on all these subjects, one can consult
any standard book on category theory, of which there are many.
The bible (old,
important, seminal, and requires a priest to explain it) is [Mac98]; another thorough
introduction is [Bor94]; a logical perspective is given in [Awo10]; a computer science
perspective is given in [BW90] and [Pie91] and [Wal92]; math students should probably
read [Lei14] or [Rie17] or [Gra18]; a general audience might start with [Spi14a].
We presented categories from a database perspective, because data is pretty ubiq-
uitous in our world. A database schema—i.e. a system of interlocking tables—can be
captured by a category C, and ﬁlling it with data corresponds to a functor C →Set. Here
Set is the category of sets, perhaps the most important category to mathematicians.
The perspective of using category theory to model databases has been rediscovered
several times. It seems to have ﬁrst been discussed by various authors around the
mid-90’s [IP94; CD95; PS95; TG96]. Bob Rosebrugh and collaborators took it much
further in a series of papers including [FGR03; JR02; RW92]. Most of these authors
tend to focus on sketches, which are more expressive categories. Spivak rediscovered
the idea again quite a bit later, but focused on categories rather than sketches, so as to
have all three data migration functors ∆, Σ, Π; see [Spi12; SW15b]. The version of this
story presented in the chapter, including the white and black nodes in schemas, is part
of a larger theory of algebraic databases, where a programming language such as Java
or Haskell is attached to a database. The technical details are worked out in [Sch+17],
and its use in database integration projects can be found in [SW15a; Wis+15].
Before we leave this chapter, we want to emphasize two things: coherence conditions
and universal constructions.
Coherence conditions.
In the deﬁnitions of category, functor, and natural transforma-
tions, we have data (indexed by (i)) that is required to satisfy certain properties (indexed

3.6. SUMMARY AND FURTHER READING
115
by (a)). Indeed, for categories it was about associativity and unitality of composition,
for functors it was about respecting composition and identities, and for natural trans-
formations it was the naturality condition. These conditions are often called coherence
conditions: we want the various structures to cohere, to work well together, rather than
to ﬂop around unattached.
Understanding why these particular structures and coherence conditions are “the
right ones” is more science than mathematics: we empirically observe that certain
combinations result in ideas that are both widely applicable and also strongly compo-
sitional. That is, we become satisﬁed with coherence conditions when they result in
beautiful mathematics down the road.
Universal constructions.
Universal constructions are one of the most important
themes of category theory. Roughly speaking, one gives some speciﬁed shape in a
category and says “ﬁnd me the best solution!” And category theory comes back and
says “do you want me to approximate from the left or the right (colimit or limit)?” You
respond, and either there is a best solution or there is not. If there is, it’s called the
(co)limit; if there’s not we say “the (co)limit does not exist.”
Even data migration ﬁts this form. We say “ﬁnd me the closest thing in D that
matches my C-instance using my functor F : C →D.” In fact this approach—known
as Kan extensions—subsumes the others. One of the two founders of category theory,
Saunders Mac Lane, has a section in his book [Mac98] called “All concepts are Kan
extensions,” a big statement, no?


Chapter 4
Collaborative design:
Profunctors, categoriﬁcation, and
monoidal categories
4.1
Can we build it?
When designing a large-scale system, many diﬀerent ﬁelds of expertise are joined
to work on a single project. Thus the whole project team is divided into multiple
sub-teams, each of which is working on a sub-project. And we recurse downward:
the sub-project is again factored into sub-sub-projects, each with their own team. One
could refer to this sort of hierarchical design process as collaborative design, or co-design.
In this chapter, we discuss a mathematical theory of co-design, due to Andrea Censi
[Cen15].
Consider just one level of this hierarchy: a project and a set of teams working on
it. Each team is supposed to provide resources—sometimes called “functionalities”—to
the project, but the team also requires resources in order to do so. Diﬀerent design
teams must be allowed to plan and work independently from one another in order for
progress to be made. Yet the design decisions made by one group aﬀect the design
decisions others can make: if A wants more space in order to provide a better radio
speaker, then B must use less space.
So these teams—though ostensibly working
independently—are dependent on each other after all.
The combination of dependence and independence is crucial for progress to be
made, and yet it can cause major problems. When a team requires more resources than
it originally expected to require, or if it cannot provide the resources that it originally
claimed it could provide, the usual response is for the team to issue a design-change
notice. But these aﬀect neighboring teams: if team A now requires more than originally
claimed, team B may have to change their design, which can in turn aﬀect team C. Thus
these design-change notices can ripple through the system through feedback loops and
117

118
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
can cause whole projects to fail [S+15].
As an example, consider the design problem of creating a robot to carry some load
at some velocity. The top-level planner breaks the problem into three design teams:
chassis team, motor team, and battery team. Each of these teams could break up into
multiple parts and the process repeated, but let’s remain at the top level and consider
the resources produced and the resources required by each of our three teams.
The chassis in some sense provides all the functionality—it carries the load at the
velocity—but it requires some things in order to do so. It requires money to build,
of course, but more to the point it requires a source of torque and speed. These are
supplied by the motor, which in turn needs voltage and current from the battery. Both
the motor and the battery cost money, but more importantly they need to be carried
by the chassis: they become part of the load. A feedback loop is created: the chassis
must carry all the weight, even that of the parts that power the chassis. A heavier
battery might provide more energy to power the chassis, but is the extra power worth
the heavier load?
In the following picture, each part—chassis, motor, battery, and robot—is shown as
a box with ports on the left and right. The functionalities, or resources produced by
the part are shown as ports on the left of the box, and the resources required by the
part are shown as ports on its right.
Σ
Chassis
Motor
Battery
Σ
Robot
≤
≤
≤
≤
≤
≤
≤
Voltage
≤
Current
≤
$
≤
≤
≥
≥
Weight
(as payload)
Velocity
$
Torque
Speed
$
Weight
Weight
$
(4.1)
The boxes marked Σ correspond to summing inputs. These boxes are not to be designed,
but we will see later that they ﬁt easily into the same conceptual framework. Note
also the ≤’s on each wire; they indicate that if box A requires a resource that box B
produces, then A’s requirement must be less-than-or-equal-to B’s production. The
chassis requires torque, and the motor must produce at least that much torque.
To formalize this a bit more, let’s call diagrams like the one above co-design diagrams.
Each of the wires in a co-design diagram represents a preorder of resources.
For
example, in Eq. (4.1) every wire corresponds to a resource type—weights, velocities,
torques, speeds, costs, voltages, and currents—where resources of each type can be
ordered from less useful to more useful. In general, these preorders do not have to be
linear orders, though in the above cases each will likely correspond to a linear order:
$10 ≤$20, 5W ≤6W, and so on.
Each of the boxes in a co-design diagram corresponds to what we call a feasibility

4.2. ENRICHED PROFUNCTORS
119
relation. A feasibility relation matches resource production with requirements. For
every pair (p, r) ∈P × R, where P is the preorder of resources to be produced and R
is the preorder of resources to be required, the box says “true” or “false”—feasible or
infeasible—for that pair. In other words, “yes I can provide p given r” or “no, I cannot
provide p given r.”
Feasibility relations hence deﬁne a function Φ: P × R →Bool.
For a function
Φ: P × R →Bool to make sense as a feasibility relation, however, there are two
conditions:
(a) If Φ(p, r)  true and p′ ≤p, then Φ(p′, r)  true.
(b) If Φ(p, r)  true and r ≤r′ then Φ(p, r′)  true.
These conditions, which we will see again in Deﬁnition 4.2, say that if you can produce
p given resources r, you can (a) also produce less p′ ≤p with the same resources r, and
(b) also produce p given more resources r′ ≥r. We will see that these two conditions
are formalized by requiring Φ to be a monotone map Pop × R →Bool.
A co-design problem, represented by a co-design diagram, asks us to ﬁnd the com-
posite of some feasibility relations. It asks, for example, given these capabilities of the
chassis, motor, and battery teams, can we build a robot together? Indeed, a co-design
diagram factors a problem—for example, that of designing a robot—into intercon-
nected subproblems, as in Eq. (4.1). Once the feasibility relation is worked out for each
of the subproblems, i.e. the inner boxes in the diagram, the mathematics provides an
algorithm producing the feasibility relation of the whole outer box. This process can
be recursed downward, from the largest problem to tiny subproblems.
In this chapter, we will understand co-design problems in terms of enriched pro-
functors, in particular Bool-profunctors. A Bool-profunctor is like a bridge connecting
one preorder to another. We will show how the co-design framework gives rise to a
structure known as a compact closed category, and that any compact closed category
can interpret the sorts of wiring diagrams we see in Eq. (4.1).
4.2
Enriched profunctors
In this section we will understand how co-design problems form a category. Along the
way we will develop some abstract machinery that will allow us to replace preorder
design spaces with other enriched categories.
4.2.1
Feasibility relationships as Bool-profunctors
The theory of co-design is based on preorders: each resource—e.g. velocity, torque, or
$—is structured as a preorder. The order x ≤y represents the availability of x given
y, i.e. that whenever you have y, you also have x. For example, in our preorder of
wattage, if 5W ≤10W, it means that whenever we are provided 10W, we implicitly also
have 5W. Above we referred to this as an order from less useful to more useful: if x is
always available given y, then x is less useful than y.

120
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
We know from Section 2.3.2 that a preorder X can be conceived of as a Bool-category.
Given x, y ∈X, we have X(x, y) ∈B; this value responds to the assertion “x is available
given y,” marking it either true or false.
Our goal is to see feasibility relations as Bool-profunctors, which are a special case
of something called enriched profunctors. Indeed, we hope that this chapter will give
you some intuition for profunctors, arising from the table
Bool-category
preorder
Bool-functor
monotone map
Bool-profunctor
feasibility relation
Because enriched profunctors are a bit abstract, we ﬁrst concretely discuss Bool-
profunctors as feasibility relations. Recall that if X  (X, ≤) is a preorder, then its
opposite Xop  (X, ≥) has x ≥y iﬀy ≤x.
Deﬁnition 4.2. Let X  (X, ≤X) and Y  (Y, ≤Y) be preorders. A feasibility relation for X
given Y is a monotone map
Φ: Xop × Y →Bool.
(4.3)
We denote this by Φ: X
Y.
Given x ∈X and y ∈Y, if Φ(x, y)  true we say x can be obtained given y.
As mentioned in the introduction, the requirement that Φ is monotone says that
if x′ ≤X x and y ≤Y y′ then Φ(x, y) ≤Bool Φ(x′, y′).
In other words, if x can be
obtained given y, and if x′ is available given x, then x′ can be obtained given y. And if
furthermore y is available given y′, then x′ can also be obtained given y′.
Exercise 4.4.
Suppose we have the preorders
category
preorder
monoid
X B
nothing
this book
Y B
1. Draw the Hasse diagram for the preorder Xop × Y.
2. Write down a profunctor Λ: X
Y and, reading Λ(x, y)  true as “my aunt can
explain an x given y,” give an interpretation of the fact that the preimage of true
forms an upper set in Xop × Y.
♦
To generalize the notion of feasibility relation, we must notice that the symmetric
monoidal preorder Bool has more structure than just that of a symmetric monoidal
preorder: as mentioned in Exercise 2.93, Bool is a quantale. That means it has all
joins ∨, and a closure operation, which we’ll write ⇒: B × B →B. By deﬁnition, this
operation satisﬁes the property that for all b, c, d ∈B one has
b ∧c ≤d
iﬀ
b ≤(c ⇒d).
(4.5)

4.2. ENRICHED PROFUNCTORS
121
The operation ⇒is given by the following table:
c
d
c ⇒d
true
true
true
true
false
false
false
true
true
false
false
true
(4.6)
Exercise 4.7.
Show that ⇒as deﬁned in Eq. (4.6) indeed satisﬁes Eq. (4.5).
♦
On an abstract level, it is the fact that Bool is a quantale which makes everything
in this chapter work; any other (unital commutative) quantale also deﬁnes a way to
interpret co-design diagrams. For example, we could use the quantale Cost, which
would describe not whether x is available given y but the cost of obtaining x given y;
see Example 2.37 and Deﬁnition 2.46.
4.2.2
V-profunctors
We are now ready to recast Eq. (4.3) in abstract terms. Recall the notions of enriched
product (Deﬁnition 2.74), enriched functor (Deﬁnition 2.69), and quantale (Deﬁni-
tion 2.79).
Deﬁnition 4.8. Let V  (V, ≤, I, ⊗) be a (unital commutative) quantale,1 and let X and
Y be V-categories. A V-profunctor from X to Y, denoted Φ: X
Y, is a V-functor
Φ: Xop × Y →V.
Note that a V-functor must have V-categories for domain and codomain, so here we
are considering V as enriched in itself; see Remark 2.89.
Exercise 4.9.
Show that a V-profunctor (Deﬁnition 4.8) is the same as a function
Φ: Ob(X) × Ob(Y) →V such that for any x, x′ ∈X and y, y′ ∈Y the following
inequality holds in V:
X(x′, x) ⊗Φ(x, y) ⊗Y(y, y′) ≤Φ(x′, y′).
♦
Exercise 4.10.
Is it true that a Bool-profunctor, as in Deﬁnition 4.8, is exactly the same
as a feasibility relation, as in Deﬁnition 4.2, once you peel back all the jargon? Or is
there some subtle diﬀerence?
♦
We know that Deﬁnition 4.8 is quite abstract. But have no fear, we will take you
through it in pictures.
1From here on, as in Chapter 2, whenever we speak of quantales we mean unital commutative
quantales.

122
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Example 4.11 (Bool-profunctors and their interpretation as bridges). Let’s discuss Deﬁ-
nition 4.8 in the case V  Bool. One way to imagine a Bool-profunctor Φ: X
Y is in
terms of building bridges between two cities. Recall that a preorder (a Bool-category)
can be drawn using a Hasse diagram. We’ll think of the preorder as a city, and each
vertex in it as some point of interest. An arrow A →B in the Hasse diagram means
that there exists a way to get from point A to point B in the city. So what’s a profunctor?
A profunctor is just a bunch of bridges connecting points in one city to points in
another. Let’s see a speciﬁc example. Here is a picture of a Bool-profunctor Φ: X
Y:
N•
W•
E•
•
S
X B
•
a
b•
c•
d•
e•
: Y
Both X and Y are preorders, e.g. with W ≤N and b ≤a. With bridges coming from
the profunctor in blue, one can now use both paths within the cities and the bridges to
get from points in city X to points in city Y. For example, since there is a path from N
to e and E to a, we have Φ(N, e)  true and Φ(E, a)  true. On the other hand, since
there is no path from W to d, we have Φ(W, d)  false.
In fact, one could put a box around this entire picture and see a new preorder with
W ≤N ≤c ≤a, etc. This is called the collage of Φ; we’ll explore this in more detail
later; see Deﬁnition 4.42.
Exercise 4.12.
We can express Φ as a matrix where the (m, n)th entry is the value of
Φ(m, n) ∈B. Fill out the Bool-matrix:
Φ
a
b
c
d
e
N
?
?
?
?
true
E
true
?
?
?
?
W
?
?
?
false
?
S
?
?
?
?
?
♦
We’ll call this the feasibility matrix of Φ.
Example 4.13 (Cost-profunctors and their interpretation as bridges). Let’s now consider
Cost-profunctors. Again we can view these as bridges, but this time our bridges are

4.2. ENRICHED PROFUNCTORS
123
labelled by their length. Recall from Deﬁnition 2.53 and Eq. (2.56) that Cost-categories
are Lawvere metric spaces, and can be depicted using weighted graphs. We’ll think of
such a weighted graph as a chart of distances between points in a city, and generate a
Cost-profunctor by building a few bridges between the cities.
Here is a depiction of a Cost-profunctor Φ: X
Y:
•
A
•
B
•
C
•
D
3
3
4
2
5
X B
x•
•
y
z•
3
4
3
4
: Y
11
9
(4.14)
The distance from a point x in city X to a point y in city Y is given by the shortest path
that runs from x through X, then across one of the bridges, and then through Y to the
destination y. So for example
Φ(B, x)  11,
Φ(A, z)  20,
Φ(C, y)  17.
Exercise 4.15.
Fill out the Cost-matrix:
Φ
x
y
z
A
?
?
20
B
11
?
?
C
?
17
?
D
?
?
?
♦
Remark 4.16 (Computing profunctors via matrix multiplication). We can give an algo-
rithm for computing the above distance matrix using matrix multiplication. First, just
like in Eq. (2.59), we can begin with the labelled graphs in Eq. (4.14) and read oﬀthe
matrices of arrow labels for X, Y, and Φ:
MX
A
B
C
D
A
0
∞
3
∞
B
2
0
∞
5
C
∞
3
0
∞
D
∞
∞
4
0
MΦ
x
y
z
A
∞
∞
∞
B
11
∞
∞
C
∞
∞
∞
D
∞
9
∞
MY
x
y
z
x
0
4
3
y
3
0
∞
z
∞
4
0
Recall from Section 2.5.3 that the matrix of distances dY for Cost-category X can be
obtained by taking the matrix power of MX with smallest entries, and similarly for Y.
The matrix of distances for the profunctor Φ will be equal to dX ∗MΦ ∗dY. In fact, since
X has four elements and Y has three, we also know that Φ  M3
X ∗MΦ ∗M2
Y.
Exercise 4.17.
Calculate M3
X ∗MΦ ∗M2
Y, remembering to do matrix multiplication
according to the (min, +)-formula for matrix multiplication in the quantale Cost; see
Eq. (2.101).

124
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Your answer should agree with what you got in Exercise 4.15; does it?
♦
4.2.3
Back to co-design diagrams
Each box in a co-design diagram has a left-hand and a right-hand side, which in turn
consist of a collection of ports, which in turn are labeled by preorders. For example,
consider the chassis box below:
Chassis
load
velocity
torque
speed
$
Its left side consists of two ports—one for load and one for velocity—and these are
the functionality that the chassis produces.
Its right side consists of three ports—
one for torque, one for speed, and one for $—and these are the resources that the
chassis requires. Each of these resources is to be taken as a preorder. For example,
load might be the preorder ([0, ∞], ≤), where an element x ∈[0, ∞] represents the
idea “I can handle any load up to x.,” while $ might be the two-element preorder
{up_to_$100, more_than_$100}, where the ﬁrst element of this set is less than the
second.
We then multiply—i.e. we take the product preorder—of all preorders on the left,
and similarly for those on the right.
The box then represents a feasibility relation
between the results. For example, the chassis box above represents a feasibility relation
Chassis:  load × velocity
 torque × speed × $
Let’s walk through this a bit more concretely.
Consider the design problem of
ﬁlming a movie, where you must pit the tone and entertainment value against the cost.
A feasibility relation describing this situation details what tone and entertainment
value can be obtained at each cost; as such, it is described by a feasibility relation
Φ: (T × E)
$. We represent this by the box
Φ
T
E
$
where T, E, and $ are the preorders drawn below:
mean-spirited
•
good-natured
•
T B
boring
•
funny
•
E B
$500K
•
$1M
•
$100K
•
$ B

4.3. CATEGORIES OF PROFUNCTORS
125
A possible feasibility relation is then described by the profunctor
(mean, funny)
•
(g/n, boring)
•
(mean, boring)
•
(g/n, funny)
•
T × E 
$100K
•
$500K
•
$1M
•
 $
This says, for example, that a good-natured but boring movie costs $500K to produce
(of course, the producers would also be happy to get $1M).
To elaborate, each arrow in the above diagram is to be interpreted as saying, “I can
provide the source given the target”. For example, there are arrows witnessing each
of “I can provide $500K given $1M”, “I can provide a good-natured but boring movie
given $500K”, and “I can provide a mean and boring movie given a good-natured
but boring movie”. Moreover, this relationship is transitive, so the path from (mean,
boring) to $1M indicates also that “I can provide a mean and boring movie given $1M”.
Note the similarity and diﬀerence with the bridge interpretation of profunctors in
Example 4.11: the arrows still indicate the possibility of moving between source and
target, but in this co-design driven interpretation we understand them as indicating
that it is possible to get to the source from the target.
Exercise 4.18.
In the above diagram, the node (g/n, funny) has no dashed blue arrow
emerging from it. Is this valid? If so, what does it mean?
♦
4.3
Categories of profunctors
There is a category Feas whose objects are preorders and whose morphisms are feasi-
bility relations. In order to describe it, we must give the composition formula and the
identities, and prove that they satisfy the properties of being a category: unitality and
associativity.
4.3.1
Composing profunctors
If feasibility relations are to be morphisms, we need to give a formula for composing
two of them in series. Imagine you have cities P, Q, and R and you have bridges—and

126
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
hence feasibility matrices—connecting these cities, say Φ: P
Q and Ψ: Q
R.
N•
W•
E•
•
S
P
•
a
b•
c•
d•
e•
Q
x•
•
y
R
(4.19)
The feasibility matrices for Φ (in blue) and Ψ (in red) are:
Φ
a
b
c
d
e
N
true
false
true
false
false
E
true
false
true
false
true
W
true
true
true
true
false
S
true
true
true
true
true
Ψ
x
y
a
false
true
b
true
true
c
false
true
d
true
true
e
false
false
As in Remark 2.95, we personify a quantale as a navigator. So imagine a navigator is
trying to give a feasibility matrix Φ # Ψ for getting from P to R. How should this be
done? Basically, for every pair p ∈P and r ∈R, the navigator searches through Q for a
way-point q, somewhere both to which we can get from p AND from which we can get
to r. It is true that we can navigate from p to r iﬀthere is a way-point q through which
to travel; this is a big OR over all possible q. The composition formula is thus:
(Φ # Ψ)(p, r) B
Ü
q∈Q
Φ(p, q) ∧Ψ(q, r).
(4.20)
But as we said in Eq. (2.101), this can be thought of as matrix multiplication. In our
example, the result is
Φ # Ψ
x
y
N
false
true
E
false
true
W
true
true
S
true
true
and one can check that this answers the question, “can you get from here to there” in
Eq. (4.19): you can’t get from N to x but you can get from N to y.
The formula (4.20) is written in terms of the quantale Bool, but it works for arbitrary
(unital commutative) quantales. We give the following deﬁnition.

4.3. CATEGORIES OF PROFUNCTORS
127
Deﬁnition 4.21. Let V be a quantale, let X, Y, and Z be V-categories, and let Φ: X
Y
and Ψ: Y
Z be V-profunctors. We deﬁne their composite, denoted Φ # Ψ: X
Z by
the formula
(Φ # Ψ)(p, r) 
Ü
q∈Q
 Φ(p, q) ⊗Ψ(q, r)
.
Exercise 4.22.
Consider the Cost-profunctors Φ: X
Y and Ψ: Y
Z shown below:
•
A
•
B
•
C
•
D
3
3
4
2
5
X B
•
x
•y
•
z
3
4
3
4
Y B
•
p
•
q
•r
•s
2
2
1
1
Z B
11
9
4
4
0
Fill in the matrix for the composite profunctor:
Φ # Ψ
p
q
r
s
A
?
24
?
?
B
?
?
?
?
C
?
?
?
?
D
?
?
9
?
♦
4.3.2
The categories V-Prof and Feas
A composition rule suggests a category, and there is indeed a category where the
objects are Bool-categories and the morphisms are Bool-profunctors. To make this
work more generally, however, we need to add one technical condition.
Recall from Remark 1.35 that a preorder is a skeletal preorder if whenever x ≤y and
y ≤x, we have x  y. Skeletal preorders are also known as posets. We say a quantale
is skeletal if its underlying preorder is skeletal; Bool and Cost are skeletal quantales.
Theorem 4.23. For any skeletal quantale V, there is a category ProfV whose objects are
V-categories X, whose morphisms are V-profunctors X
Y, and with composition
deﬁned as in Deﬁnition 4.21.
Deﬁnition 4.24. We deﬁne Feas B ProfBool.
At this point perhaps you have two questions in mind.
What are the identity
morphisms? And why did we need to specialize to skeletal quantales? It turns out
these two questions are closely related.

128
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Deﬁne the unit profunctor UX : X
X on a V-category X by the formula
UX(x, y) B X(x, y).
(4.25)
How do we interpret this? Recall that, by Deﬁnition 2.46, X already assigns to each
pair of elements x, y ∈X an hom-object X(x, y) ∈V. The unit profunctor UX just
assigns each pair (x, y) that same object.
In the Bool case the unit profunctor on some preorder X can be drawn like this:
a•
b•
c•
d•
e•
X B
a•
b•
c•
d•
e•
: X
Obviously, composing a feasibility relation with with the unit leaves it unchanged; this
is the content of Lemma 4.27.
Exercise 4.26.
Choose a not-too-simple Cost-category X. Give a bridge-style diagram
for the unit profunctor UX : X
X.
♦
Lemma 4.27. Composing any profunctor Φ: P →Q with either unit profunctor, UP or
UQ, returns Φ:
UP # Φ  Φ  Φ # UQ
Proof. We show that UP # Φ  Φ holds; proving Φ  Φ # UQ is similar. Fix p ∈P and
q ∈Q. Since V is skeletal, to prove the equality it’s enough to show Φ ≤UP # Φ and
UP # Φ ≤Φ. We have one direction:
Φ(p, q)  I ⊗Φ(p, q) ≤P(p, p) ⊗Φ(p, q) ≤
Ü
p1∈P
 P(p, p1) ⊗Φ(p1, q)
 (UP # Φ)(p, q).
(4.28)
For the other direction, we must show Ô
p1∈P
 P(p, p1) ⊗Φ(p1, q)
≤Φ(p, q). But by
deﬁnition of join, this holds iﬀP(p, p1) ⊗Φ(p1, q) ≤Φ(p, q) is true for each p1 ∈P. This
follows from Deﬁnitions 2.46 and 4.8:
P(p, p1) ⊗Φ(p1, q)  P(p, p1) ⊗Φ(p1, q) ⊗I ≤P(p, p1) ⊗Φ(p1, q) ⊗Q(q, q) ≤Φ(p, q).
(4.29)
□
Exercise 4.30.
1. Justify each of the four steps (, ≤, ≤, ) in Eq. (4.28).
2. In the case V  Bool, we can directly show each of the four steps in Eq. (4.28) is
actually an equality. How?

4.3. CATEGORIES OF PROFUNCTORS
129
3. Justify each of the three steps (, ≤, ≤) in Eq. (4.29).
♦
Composition of profunctors is also associative; we leave the proof to you.
Lemma 4.31. Serial composition of profunctors is associative. That is, given profunc-
tors Φ: P →Q, Ψ: Q →R, and Υ: R →S, we have
(Φ # Ψ) # Υ  Φ # (Ψ # Υ).
Exercise 4.32.
Prove Lemma 4.31. (Hint: remember to use the fact that V is skeletal.)
♦
So, feasibility relations form a category.
Since this is the case, we can describe
feasibility relations using wiring diagrams for categories (see also Section 4.4.2), which
are very simple. Indeed, each box can only have one input and one output, and they’re
connected in a line:
f
a
1
h
d
b
c
On the other hand, we have seen that feasibility relations are the building blocks of
co-design problems, and we know that co-design problems can be depicted with a
much richer wiring diagram, for example:
Σ
Chassis
Motor
Battery
Σ
Robot
≤
≤
≤
≤
≤
≤
≤
Voltage
≤
Current
≤
$
≤
≤
≥
≥
Weight
(as payload)
Velocity
$
Torque
Speed
$
Weight
Weight
$
This hints that the category Feas has more structure. We’ve seen wiring diagrams
where boxes can have multiple inputs and outputs before, in Chapter 2; there they
depicted morphisms in a monoidal preorder. On other hand the boxes in the wiring
diagrams of Chapter 2 could not have distinct labels, like the boxes in a co-design
problem: all boxes in a wiring diagram for monoidal preorders indicate the order ≤,
while above we see boxes labelled by “Chassis”, “Motor”, and so on. Similarly, we know
that Feas is a proper category, not just a preorder. To understand these diagrams then,
we must introduce a new structure, called a monoidal category. A monoidal category is
a categoriﬁed monoidal preorder.
Remark 4.33. While we have chosen to deﬁne ProfV only for skeletal quantales in
Theorem 4.23, it is not too hard to work with non-skeletal ones. There are two straight-
forward ways to do this. First, we might let the morphisms of ProfV be isomorphism

130
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
classes of V-profunctors. This is analogous to the trick we will use when deﬁning
the category CospanC in Deﬁnition 6.45. Second, we might relax what we mean by
category, only requiring composition to be unital and associative ‘up to isomorphism’.
This is also a type of categoriﬁcation, known as bicategory theory.
In the next section we’ll discuss categoriﬁcation and introduce monoidal categories.
First though, we ﬁnish this section by discussing why profunctors are called profunc-
tors, and by formally introducing something called the collage of a profunctor.
4.3.3
Fun profunctor facts: companions, conjoints, collages
Companions and conjoints.
Recall that a preorder is a Bool-category and a monotone
map is a Bool-functor. We said above that a profunctor is a generalization of a functor;
how so?
In fact, every V-functor gives rise to two V-profunctors, called the companion and
the conjoint.
Deﬁnition 4.34. Let F : P →Q be a V-functor. The companion of F, denoted bF : P
Q
and the conjoint of F, denoted qF : Q
P are deﬁned to be the following V-profunctors:
bF(p, q) B Q(F(p), q)
and
qF(q, p) B Q(q, F(p))
Let’s consider the Bool case again. One can think of a monotone map F : P →Q as
a bunch of arrows, one coming out of each vertex p ∈P and landing at some vertex
F(p) ∈Q.
•
•
•
•
•
P B
•
•
•
: Q
This looks like the pictures of bridges connecting cities, and if one regards the above
picture in that light, they are seeing the companion bF. But now mentally reverse every
dotted arrow, and the result would be bridges Q to P. This is a profunctor Q
P! We
call it qF.
Example 4.35. For any preorder P, there is an identity functor id: P →P. Its compan-
ion and conjoint agree b
id  qid: P
P. The resulting profunctor is in fact the unit
profunctor, UP, as deﬁned in Eq. (4.25).

4.3. CATEGORIES OF PROFUNCTORS
131
Exercise 4.36.
Check that the companion b
id of id: P →P really has the unit profunctor
formula given in Eq. (4.25).
♦
Example 4.37. Consider the function +: R × R × R →R, sending a triple (a, b, c) of real
numbers to a + b + c ∈R. This function is monotonic, because if (a, b, c) ≤(a′, b′, c′)—
i.e. if a ≤a′ and b ≤b′, and c ≤c′—then obviously a + b + c ≤a′ + b′ + c′. Thus it has
a companion and a conjoint.
Its companion b+: (R × R × R)
R is the function that sends (a, b, c, d) to true if
a + b + c ≤d and to false otherwise.
Exercise 4.38.
Let +: R × R × R →R be as in Example 4.37. What is its conjoint q+?
♦
Remark 4.39 (V-Adjoints). Recall from Deﬁnition 1.95 the deﬁnition of Galois connec-
tion between preorders P and Q. The deﬁnition of adjoint can be extended from the
Bool-enriched setting (of preorders and monotone maps) to the V-enriched setting for
arbitrary monoidal preorders V. In that case, the deﬁnition of a V-adjunction is a pair
of V-functors F : P →Q and G: Q →P such that the following holds for all p ∈P and
q ∈Q.
P(p, G(q))  Q(F(p), q)
(4.40)
Exercise 4.41. Let V be a skeletal quantale, let P and Q be V-categories, and let F : P →Q
and G: Q →P be V-functors.
1. Show that F and G are V-adjoints (as in Eq. (4.40)) if and only if the companion
of the former equals the conjoint of the latter: bF  qG.
2. Use this to prove that b
id  qid, as was stated in Example 4.35.
♦
Collage of a profunctor.
We have been drawing profunctors as bridges connect-
ing cities.
One may get an inkling that given a V-profunctor Φ: X
Y between
V-categories X and Y, we have turned Φ into a some sort of new V-category that has X
on the left and Y on the right. This works for any V and profunctor Φ, and is called the
collage construction.
Deﬁnition 4.42. Let V be a quantale, let X and Y be V-categories, and let Φ: X
Y be
a V-profunctor. The collage of Φ, denoted Col(Φ) is the V-category deﬁned as follows:
(i) Ob(Col(Φ)) B Ob(X) ⊔Ob(Y);
(ii) For any a, b ∈Ob(Col(Φ)), deﬁne Col(Φ)(a, b) ∈V to be
Col(Φ)(a, b) B


X(a, b)
if a, b ∈X
Φ(a, b)
if a ∈X, b ∈Y

if a ∈Y, b ∈X
Y(a, b)
if a, b ∈Y
There are obvious functors iX : X →Col(Φ) and iY : Y →Col(Φ), sending each object

132
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
and morphism to “itself,” called collage inclusions.
Some pictures will help clarify this.
Example 4.43. Consider the following picture of a Cost-profunctor Φ: X
Y:
A•
•
B
2
X B
x•
•
y
3
4 : Y
5
It corresponds to the following matrices
X
A
B
A
0
2
B
∞
0
Φ
x
y
A
5
8
B
∞
∞
Y
x
y
x
0
3
y
4
0
A generalized Hasse diagram of the collage can be obtained by simply taking the
union of the Hasse diagrams for X and Y, and adding in the bridges as arrows. Given
the above profunctor Φ, we draw the Hasse diagram for Col(Φ) below left, and the
Cost-matrix representation of the resulting Cost-category on the right:
A•
•
B
x•
•
y
2
5
3
4
Col(Φ) 
Col(Φ)
A
B
x
y
A
0
2
5
8
B
∞
0
∞
∞
x
0
0
0
3
y
0
0
4
0
Exercise 4.44.
Draw a Hasse diagram for the collage of the profunctor shown here:
•
A
•
B
•
C
•
D
3
3
4
2
5
X B
x•
•
y
z•
3
4
3
4
: Y
11
9
♦
4.4
Categoriﬁcation
Here we switch gears, to discuss a general concept called categoriﬁcation.
We will
begin again with the basics, categorifying several of the notions we’ve encountered

4.4. CATEGORIFICATION
133
already. The goal is to deﬁne compact closed categories and their feedback-style wiring
diagrams. At that point we will return to the story of co-design, and V-profunctors
in general, and show that they do in fact form a compact closed category, and thus
interpret the diagrams we’ve been drawing since Eq. (4.1).
4.4.1
The basic idea of categoriﬁcation
The general idea of categoriﬁcation is that we take a thing we know and add structure
to it, so that what were formerly properties become structures. We do this in such a way
that we can recover the thing we categoriﬁed by forgetting this new structure. This is
rather vague; let’s give an example.
Basic arithmetic concerns properties of the natural numbers N, such as the fact
that 5 + 3  8. One way to categorify N is to use the category FinSet of ﬁnite sets
and functions.
To obtain a categoriﬁcation, we replace the brute 5, 3, and 8 with
sets of that many elements, say 5  {apple, banana, cherry, dragonfruit, elephant},
3  {apple, tomato, cantaloupe}, and 8  {Ali, Bob, Carl, Deb, Eli, Fritz, Gem, Helen}
respectively. We also replace + with disjoint union of sets ⊔, and the brute property of
equality with the structure of an isomorphism. What makes this a good categoriﬁcation
is that, having made these replacements, the analogue of 5+3  8 is still true: 5⊔3  8.
apple
•
banana
•
cherry
•
dragonfruit
•
elephant
•
apple
•
tomato
•
cantaloupe
•
⊔
Ali•
Bob
•
Carl
•
Deb
•
Eli•
Fritz
•
Gem
•
Helen
•

In this categoriﬁed world, we have more structure available to talk about the relation-
ships between objects, so we can be more precise about how they relate to each other.
Thus it’s not the case that 5 ⊔3 is equal to our chosen eight-element set 8, but more
precisely that there exists an invertible function comparing the two, showing that they
are isomorphic in the category FinSet.
Note that in the above construction we made a number of choices; here we must
beware. Choosing a good categoriﬁcation—like designing a good algebraic structure
such as that of preorders or quantales—is part of the art of mathematics. There is

134
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
no prescribed way to categorify, and the success of a chosen categoriﬁcation is often
empirical: its richer structure should allow us more insights into the subject we want
to model.
As another example, an empirically pleasing way to categorify preorders is to cat-
egorify them as, well, categories. In this case, rather than the brute property “there
exists a morphism a →b,” denoted a ≤b or P(a, b)  true, we instead say “here is a set
of morphisms a →b.” We get a hom-set rather than a hom-Boolean. In fact—to state
this in a way straight out of the primordial ooze—just as preorders are Bool-categories,
ordinary categories are actually Set-categories.
4.4.2
A reﬂection on wiring diagrams
Suppose we have a preorder. We introduced a very simple sort of wiring diagram in
Section 2.2.2. These allowed us to draw a box
≤
x0
x1
whenever x0 ≤x1. Chaining these together, we could prove facts in our preorder. For
example
≤
≤
≤
x0
x1
x2
x3
provides a proof that x0 ≤x3 (the exterior box) using three facts (the interior boxes),
x0 ≤x1, x1 ≤x2, and x2 ≤x3.
As categoriﬁed preorders, categories have basically the same sort of wiring diagram
as preorders—namely sequences of boxes inside a box. But since we have replaced the
fact that x0 ≤x1 with the structure of a set of morphisms, we need to be able to label
our boxes with morphism names:
f
A
B
Suppose given additional morphisms 1 : B →C, and h : C →D. Representing these
each as boxes like we did for f , we might be tempted to stick them together to form a
new box:
f
1
h
A
B
C
D
Ideally this would also be a morphism in our category: after all, we have said that we
can represent morphisms with boxes with one input and one output. But wait, you
say! We don’t know which morphism it is. Is it f # (1 # h)? Or ( f # 1) # h? It’s good that
you are so careful. Luckily, we are saved by the properties that a category must have.
Associativity says f # (1 # h)  ( f # 1) # h, so it doesn’t matter which way we chose to try
to decode the box.

4.4. CATEGORIFICATION
135
Similarly, the identity morphism on an object x is drawn as on the left below, but
we will see that it is not harmful to draw idx in any of the following three ways:
≤
x
x
≤
x
x
≤
x
x
By Deﬁnition 3.6 the morphisms in a category satisfy two properties, called the unitality
property and the associativity property. The unitality says that idx # f  f  f # idy for
any f : x →y. In terms of diagrams this would say
f
f
x
x
y
f
f
x
y
y
f
x
y
=
=
This means you can insert or discard any identity morphism you see in a wiring dia-
gram. From this perspective, the coherence laws of a category—that is, the associativity
law and the unitality law—are precisely what are needed to ensure we can lengthen
and shorten wires without ambiguity.
In Section 2.2.2, we also saw wiring diagrams for monoidal preorders. Here we
were allowed to draw boxes which can have multiple typed inputs and outputs, but
with no choice of label (always ≤):
≤
A1
A2
A3
B1
B2
If we combine these ideas, we will obtain a categoriﬁcation of symmetric monoidal
preorders: symmetric monoidal categories.
A symmetric monoidal category is an
algebraic structure in which we have labelled boxes with multiple typed inputs and
outputs:
f
A1
A2
A3
B1
B2
Furthermore, a symmetric monoidal category has a composition rule and a monoidal
product, which permit us to combine these boxes to interpret diagrams like this:
f
1
h
A
B
C
D
E
F
G

136
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Finally, this structure must obey coherence laws, analogous to associativity and uni-
tality in categories, that allow such diagrams to be unambiguously interpreted. In the
next section we will be a bit more formal, but it is useful to keep in mind that, when
we say our data must be “well behaved,” this is all we mean.
4.4.3
Monoidal categories
We deﬁned V-categories, for a symmetric monoidal preorder V in Deﬁnition 2.46. Just
like preorders turned out to be special kinds of categories (see Section 3.2.3), monoidal
preorders are special kinds of monoidal categories. And just like we can consider
V-categories for a monoidal preorder, we can also consider V-categories when V is a
monoidal category. This is another sort of categoriﬁcation.
We will soon meet the monoidal category (Set, {1}, ×). The monoidal product will
take two sets, S and T, and return the set S × T  {(s, t) | s ∈S, t ∈T}. But whereas
for monoidal preorders we had the brute associative property (p ⊗q) ⊗r  p ⊗(q ⊗r),
the corresponding idea in Set is not quite true:
S × (T × U) :
 s, (t, u)  s ∈S, t ∈T, u ∈U
	
?
(S × T) × U :
 (s, t), u  s ∈S, t ∈T, u ∈U
	
.
They are slightly diﬀerent sets: the ﬁrst contains pairs consisting of an elements in S
and an element in T × U, while the second contains pairs consisting of an element in
S × T and an element in U. The sets are not equal, but they are clearly isomorphic,
i.e. the diﬀerence between them is “just a matter of bookkeeping.” We thus need a
structure—a bookkeeping isomorphism—to keep track of the associativity:
αs,t,u : {(s, (t, u)) | s ∈S, t ∈T, u ∈U}
−→{((s, t), u) | s ∈S, t ∈T, u ∈U}.
There are a couple things to mention before we dive into these ideas. First, just
because you replace brute things and properties with structures, it does not mean that
you no longer have brute things and properties: new ones emerge! Not only that, but
second, the new brute stuﬀtends to be more complex than what you started with. For
example, above we replaced the associativity equation with an isomorphism αs,t,u, but
now we need a more complex property to ensure that all these α’s behave reasonably!
The only way out of this morass is to add inﬁnitely much structure, which leads one to
“∞-categories,” but we will not discuss that here.
Instead, we will continue with our categoriﬁcation of monoidal preorders, starting
with a rough deﬁnition of symmetric monoidal categories. It’s rough in the sense that
we suppress the technical bookkeeping, hiding it under the name “well behaved.”
Rough Deﬁnition 4.45. Let C be a category. A symmetric monoidal structure on C consists
of the following constituents:
(i) an object I ∈Ob(C) called the monoidal unit, and

4.4. CATEGORIFICATION
137
(ii) a functor ⊗: C × C →C, called the monoidal product
subject to well-behaved, natural isomorphisms
(a) λc : I ⊗c  c for every c ∈Ob(C),
(b) ρc : c ⊗I  c for every c ∈Ob(C),
(c) αc,d,e : (c ⊗d) ⊗e  c ⊗(d ⊗e) for every c, d, e ∈Ob(C), and
(d) σc,d : c ⊗d  d ⊗c for every c, d ∈Ob(C), called the swap map, such that σ ◦σ  id.
A category equipped with a symmetric monoidal structure is called a symmetric
monoidal category.
Remark 4.46. If the isomorphisms in (a), (b), and (c)—but not (d)—are replaced by
equalities, then we say that the monoidal structure is strict, and this is a complete
(non-rough) deﬁnition of symmetric strict monoidal category. In fact, symmetric strict
monoidal categories are almost the same thing as symmetric monoidal categories, via
a result known as Mac Lane’s coherence theorem. An upshot of this theorem is that we
can, when useful to us, pretend that our monoidal categories are strict: for example,
we implicitly do this when we draw wiring diagrams. Ask your friendly neighborhood
category theorist to explain how!
Remark 4.47. For those yet to ﬁnd a friendly expert category theorist, we make the
following remark. A complete (non-rough) deﬁnition of symmetric monoidal category
is that a symmetric monoidal category is a category equipped with an equivalence
to (the underlying category of) a symmetric strict monoidal category.
This can be
unpacked, using Remark 4.46 and our comment about equivalence of categories in
Remark 3.59, but we don’t expect you to do so. Instead, we hope this gives you more
incentive to ask a friendly expert category theorist!
Exercise 4.48.
Check that monoidal categories indeed generalize monoidal preorders:
a monoidal preorder is a monoidal category (P, I, ⊗) where, for every p, q ∈P, the set
P(p, q) has at most one element.
♦
Example 4.49. As we said above, there is a monoidal structure on Set where the
monoidal unit is some choice of singleton set, say I B {1}, and the monoidal product
is ⊗B ×. What it means that × is a functor is that:
• For any pair of objects, i.e. sets, (S, T) ∈Ob(Set × Set), one obtains a set (S × T) ∈
Ob(Set). We know what it is: the set of pairs {(s, t) | s ∈S, t ∈T}.
• For any pair of morphisms, i.e. functions, f : S →S′ and 1 : T →T′, one obtains a
function ( f ×1): (S×T) →(S′×T′). It works pointwise: ( f ×1)(s, t) B ( f (s), 1(t)).
• These should preserve identities: idS × idT  idS×T for any sets S, T.
• These should preserve composition: for any functions S
f
−→S′
f ′
−→S′′ and T
1
−→
T′ 1′
−→T′′, one has
( f × 1) # ( f ′ × 1′)  ( f # 1) × ( f ′ # 1′).

138
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
The four conditions, (a), (b), (c), and (d) give isomorphisms {1} × S  S, etc. These
maps are obvious in the case of Set, e.g. the function {(1, s) | s ∈S} →S sending (1, s)
to s. We have been calling such things bookkeeping.
Exercise 4.50.
Consider the monoidal category (Set, 1, ×), together with the diagram
f
1
h
A
B
C
D
E
F
G
Suppose that A  B  C  D  F  G  Z and E  B  {true, false}, and
suppose that fC(a)  |a|, fD(a)  a ∗5, 1E(d, b)  “d ≤b,” 1F(d, b)  d −b, and
h(c, e)  if e then c else 1 −c.
1. What are 1E(5, 3) and 1F(5, 3)?
2. What are 1E(3, 5) and 1F(3, 5)?
3. What is h(5, true)?
4. What is h(−5, true)?
5. What is h(−5, false)?
The whole diagram now deﬁnes a function A × B →G × F; call it q.
6. What are qG(−2, 3) and qF(−2, 3)?
7. What are qG(2, 3) and qF(2, 3)?
♦
We will see more monoidal categories throughout the remainder of this book.
4.4.4
Categories enriched in a symmetric monoidal category
We will not need this again, but we once promised to explain why V-categories, where
V is a symmetric monoidal preorder, deserve to be seen as types of categories. The
reason, as we have hinted, is that categories should really be called Set-categories. But
wait, Set is not a preorder! We’ll have to generalize—categorify—V-categories.
We now give a rough deﬁnition of categories enriched in a symmetric monoidal
category V. As in Deﬁnition 4.45, we suppress some technical parts in this sketch,
hiding them under the name “usual associative and unital laws.”
Rough Deﬁnition 4.51. Let V be a symmetric monoidal category, as in Deﬁnition 4.45.
To specify a category enriched in V, or a V-category, denoted X,
(i) one speciﬁes a collection Ob(X), elements of which are called objects;
(ii) for every pair x, y ∈Ob(X), one speciﬁes an object X(x, y) ∈V, called the hom-
object for x, y;
(iii) for every x ∈Ob(X), one speciﬁes a morphism idx : I →X(x, x) in V, called the

4.5. PROFUNCTORS FORM A COMPACT CLOSED CATEGORY
139
identity element;
(iv) for each x, y, z ∈Ob(X), one speciﬁes a morphism #: X(x, y) ⊗X(y, z) →X(x, z),
called the composition morphism.
These constituents are required to satisfy the usual associative and unital laws.
The precise, non-rough, deﬁnition can be found in other sources, e.g. [nLa18],
[Wik18], [Kel05].
Exercise 4.52.
Recall from Example 4.49 that V  (Set, {1}, ×) is a symmetric monoidal
category.
This means we can apply Deﬁnition 4.51.
Does the (rough) deﬁnition
roughly agree with the deﬁnition of category given in Deﬁnition 3.6? Or is there a
subtle diﬀerence?
♦
Remark 4.53. We ﬁrst deﬁned V-categories in Deﬁnition 2.46, where V was required to
be a monoidal preorder. To check we’re not abusing our terms, it’s a good idea to make
sure that V-categories as per Deﬁnition 2.46 are still V-categories as per Deﬁnition 4.51.
The ﬁrst thing to observe is that every symmetric monoidal preorder is a symmetric
monoidal category (Exercise 4.48). So given a symmetric monoidal preorder V, we can
apply Deﬁnition 4.51. The required data (i) and (ii) then get us oﬀto a good start: both
deﬁnitions of V-category require objects and hom-objects, and they are speciﬁed in the
same way. On the other hand, Deﬁnition 4.51 requires two additional pieces of data:
(iii) identity elements and (iv) composition morphisms. Where do these come from?
In the case of preorders, there is at most one morphism between any two objects, so
we do not need to choose an identity element and a composition morphism. Instead,
we just need to make sure that an identity element and a composition morphism exist.
This is exactly what properties (a) and (b) of Deﬁnition 2.46 say.
For example, the requirement (iii) that a V-category X has a chosen identity element
idx : I →X(x, x) for the object x simply becomes the requirement (a) that I ≤X(x, x) is
true in V. This is typical of the story of categoriﬁcation: what were mere properties in
Deﬁnition 2.46 have become structures in Deﬁnition 4.51.
Exercise 4.54.
What are identity elements in Lawvere metric spaces (that is, Cost-
categories)? How do we interpret this in terms of distances?
♦
4.5
Profunctors form a compact closed category
In this section we will deﬁne compact closed categories and show that Feas, and more
generally V-profunctors, form such a thing. Compact-closed categories are monoidal

140
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
categories whose wiring diagrams allow feedback. The wiring diagrams look like this:
f1
f2
f3
f4
f5
(4.55)
It’s been a while since we thought about co-design, but these were the kinds of wiring
diagrams we drew, e.g. connecting the chassis, the motor, and the battery in Eq. (4.1).
Compact closed categories are symmetric monoidal categories, with a bit more struc-
ture that allow us to formally interpret the sorts of feedback that occur in co-design
problems. This same structure shows up in many other ﬁelds, including quantum
mechanics and dynamical systems.
In Eq. (2.13) and Section 2.2.3 we discussed various ﬂavors of wiring diagrams,
including those with icons for splitting and terminating wires. For compact-closed
categories, our additional icons allow us to bend outputs into inputs, and vice versa.
To keep track of this, however, we draw arrows on our wire, which can either point
forwards or backwards. For example, we can draw this
Person 1
Person 2
pain
sound
fury
complaint
(4.56)
We then add icons—called a cap and a cup—allowing any wire to reverse direction
from forwards to backwards and from backwards to forwards.
sound
sound
sound
sound
(4.57)
Thus we can draw the following
Person 1
Person 2
pain
fury
sound
complaint
and its meaning is equivalent to that of Eq. (4.56).
We will begin by giving the axioms for a compact closed category.
Then we
will look again at feasibility relations in co-design—and more generally at enriched
profunctors—and show that they indeed form a compact closed category.

4.5. PROFUNCTORS FORM A COMPACT CLOSED CATEGORY
141
4.5.1
Compact closed categories
As we said, compact closed categories are symmetric monoidal categories (see Deﬁni-
tion 4.45) with extra structure.
Deﬁnition 4.58. Let (C, I, ⊗) be a symmetric monoidal category, and c ∈Ob(C) an
object. A dual for c consists of three constituents
(i) an object c∗∈Ob(C), called the dual of c,
(ii) a morphism ηc : I →c∗⊗c, called the unit for c,
(iii) a morphism ϵc : c ⊗c∗→I, called the counit for c.
These are required to satisfy two equations for every c ∈Ob(C), which we draw as
commutative diagrams:
c
c
c ⊗I
I ⊗c
c ⊗(c∗⊗c)
(c ⊗c∗) ⊗c

c⊗ηc


ϵc⊗c
c∗
c∗
I ⊗c∗
c∗⊗I
(c∗⊗c) ⊗c∗
c∗⊗(c ⊗c∗)

ηc⊗c∗


c∗⊗ϵc
(4.59)
These equations are sometimes called the snake equations.
If for every object c ∈Ob(C) there exists a dual c∗for c, then we say that (C, I, ⊗) is
compact closed.
In a compact closed category, each wire is equipped with a direction. For any object
c, a forward-pointing wire labeled c is considered equivalent to a backward-pointing
wire labeled c∗, i.e.
c−→is the same as
c∗
←−. The cup and cap discussed above are in fact
the unit and counit morphisms; they are drawn as follows.
c
ηc
c
c
ϵc
c
In wiring diagrams, the snake equations (4.59) are then drawn as follows:
c
c
c ⊗ηc
ϵc ⊗c
c
c
ηc ⊗c∗
c∗⊗ϵc
Note that the pictures in Eq. (4.57) correspond to ϵsound and ηsound∗.

142
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Recall the notion of monoidal closed preorder; a monoidal category can also be
monoidal closed. This means that for every pair of objects c, d ∈Ob(C) there is an
object c ⊸d and an isomorphism C(b ⊗c, d)  C(b, c ⊸d), natural in b. While we will
not provide a full proof here, compact closed categories are so-named because they are
a special type of monoidal closed category.
Proposition 4.60. If C is a compact closed category, then
1. C is monoidal closed;
and for any object c ∈Ob(C),
2. if c∗and c′ are both duals to c then there is an isomorphism c∗ c′; and
3. there is an isomorphism between c and its double-dual, c  c∗∗.
To prove 1., the key idea is that for any c and d, the object c ⊸d is given by c∗⊗d,
and the natural isomorphism C(b ⊗c, d)  C(b, c ⊸d) is given by precomposing with
idb ⊗ηc.
Before returning to co-design, we give another example of a compact closed category,
called Corel, which we’ll see again in the chapters to come.
Example 4.61. Recall, from Deﬁnition 1.18, that an equivalence relation on a set A is a
reﬂexive, symmetric, and transitive binary relation on A. Given two ﬁnite sets, A and
B, a corelation A →B is an equivalence relation on A ⊔B.
So, for example, here is a corelation from a set A having ﬁve elements to a set B
having six elements; two elements are equivalent if they are encircled by the same
dashed line.
A
B
There exists a category, denoted Corel, where the objects are ﬁnite sets, and where
a morphism from A →B is a corelation A →B. The composition rule is simpler to
look at than to write down formally.2 If in addition to the corelation α: A →B above
we have another corelation β: B →C
B
C
Then the composite β ◦α of our two corelations is given by

4.5. PROFUNCTORS FORM A COMPACT CLOSED CATEGORY
143
B
A
C

A
C
That is, two elements are equivalent in the composite corelation if we may travel from
one to the other staying within equivalence classes of either α or β.
The category Corel may be equipped with the symmetric monoidal structure
(, ⊔).
This monoidal category is compact closed, with every ﬁnite set its own
dual.
Indeed, note that for any ﬁnite set A there is an equivalence relation on
A ⊔A B {(a, 1), (a, 2) | a ∈A} where each part simply consists of the two elements (a, 1)
and (a, 2) for each a ∈A. The unit on a ﬁnite set A is the corelation ηA :  →A ⊔A
speciﬁed by this equivalence relation; similarly the counit on A is the corelation
ϵA : A ⊔A → specifed by this same equivalence relation.
Exercise 4.62.
Consider the set 3  {1, 2, 3}.
1. Draw a picture of the unit corelation  →3 ⊔3.
2. Draw a picture of the counit corelation 3 ⊔3 →.
3. Check that the snake equations (4.59) hold. (Since every object is its own dual,
you only need to check one of them.)
♦
4.5.2
Feas as a compact closed category
We close the chapter by returning to co-design and showing that Feas has a compact
closed structure. This is what allows us to draw the kinds of wiring diagrams we saw
in Eqs. (4.1), (4.55), and (4.56): it is what puts actual mathematics behind these pictures.
Instead of just detailing this compact closed structure for Feas  ProfBool, it’s no
extra work to prove that for any skeletal (unital, commutative) quantale (V, I, ⊗) the
profunctor category ProfV of Theorem 4.23 is compact closed, so we’ll discuss this
general fact.
2 To compose corelations α: A →B and β: B →C, we need to construct an equivalence relation
α # β on A ⊔C. To do so requires three steps: (i) consider α and β as relations on A ⊔B ⊔C, (ii) take the
transitive closure of their union, and then (iii) restrict to an equivalence relation on A ⊔C. Here is the
formal description. Note that as binary relations, we have α ⊆(A ⊔B)×(A ⊔B), and β ⊆(B ⊔C)×(B ⊔C).
We also have three inclusions: ιA ⊔B : A ⊔B →A ⊔B ⊔C, ιB ⊔C : B ⊔C →A ⊔B ⊔C, and ιA ⊔C : A ⊔C →
A ⊔B ⊔C. Recalling our notation from Section 1.4, we deﬁne
α # β B ι∗
A ⊔C((ιA ⊔B)!(α) ∨(ιB ⊔C)!(β)).

144
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Theorem 4.63. Let V be a skeletal quantale.
The category ProfV can be given the
structure of a compact closed category, with monoidal product given by the product
of V-categories.
Indeed, all we need to do is construct the monoidal structure and duals for objects.
Let’s sketch how this goes.
Monoidal products in ProfV are just product categories.
In terms of wiring diagrams,
the monoidal structure looks like stacking wires or boxes on top of one another, with
no new interaction.
Φ
Ψ
Φ ⊗Ψ
We take our monoidal product on ProfV to be that given by the product of V-categories;
the deﬁnition was given in Deﬁnition 2.74, and we worked out several examples there.
To recall, the formula for the hom-sets in X × Y is given by
(X × Y)((x, y), (x′, y′)) B X(x, x′) ⊗Y(y, y′).
But monoidal products need to be given on morphisms also, and the morphisms in
ProfV are V-profunctors. So given V-profunctors Φ: X1
X2 and Ψ: Y1
Y2, one
deﬁnes a V-profunctor (Φ × Ψ): X1 × Y1
X2 × Y2 by
(Φ × Ψ)((x1, y1), (x2, y2)) B Φ(x1, x2) ⊗Ψ(y1, y2).
Exercise 4.64. Interpret the monoidal products in ProfBool in terms of feasibility. That is,
preorders represent resources ordered by availability (x ≤x′ means that x is available
given x′) and a profunctor is a feasibility relation. Explain why X × Y makes sense as
the monoidal product of resource preorders X and Y and why Φ × Ψ makes sense as
the monoidal product of feasibility relations Φ and Ψ.
♦
The monoidal unit in ProfV is 1.
To deﬁne a monoidal structure on ProfV, we need
not only a monoidal product—as deﬁned above—but also a monoidal unit. Recall the
V-category 1; it has one object, say 1, and (1, 1)  I is the monoidal unit of V. We take
1 to be the monoidal unit of ProfV.
Exercise 4.65.
In order for 1 to be a monoidal unit, there are supposed to be isomor-
phisms X × 1
X and 1 × X
X in ProfV, for any V-category X. What are they?
♦

4.6. SUMMARY AND FURTHER READING
145
Duals in ProfV are just opposite categories.
In order to regard ProfV as a compact
closed category (Deﬁnition 4.58), it remains to specify duals and the corresponding
cup and cap.
Duals are easy: for every V-category X, its dual is its opposite category Xop (see
Exercise 2.73). The unit and counit then look like identities. To elaborate, the unit is a
V-profunctor ηX : 1
Xop × X. By deﬁnition, this is a V-functor
ηX : 1 × Xop × X →V;
we deﬁne it by ηX(1, x, x′) B X(x, x′). Similarly, the counit is the profunctor ϵX : (X ×
Xop)
1, deﬁned by ϵX(x, x′, 1) B X(x, x′).
Exercise 4.66.
Check these proposed units and counits do indeed obey the snake
equations Eq. (4.59).
♦
4.6
Summary and further reading
This chapter introduced three important ideas in category theory: profunctors, cate-
goriﬁcation, and monoidal categories. Let’s talk about them in turn.
Profunctors generalize binary relations. In particular, we saw that the idea of pro-
functor over a monoidal preorder gave us the additional power necessary to formalize
the idea of a feasibility relation between resource preorders. The idea of a feasibility re-
lation is due to Andrea Censi; he called them monotone codesign problems. The basic idea
is explained in [Cen15], where he also gives a programming language to specify and
solve codesign problems. In [Cen17], Censi further discusses how to use estimation to
make solving codesign problems computationally eﬃcient.
We also saw profunctors over the preorder Cost, and how to think of these as bridges
between Lawvere metric space. We referred earlier to Lawvere’s paper [Law73]; plenty
more on Cost-profunctors can be found there.
Profunctors, however are vastly more general than the two examples we have dis-
cussed; V-profunctors can be deﬁned not only when V is a preorder, but for any
symmetric monoidal category. A delightful, detailed exposition of profunctors and
related concepts such as equipments, companions and conjoints, symmetric monoidal
bicategories can be found in [Shu08; Shu10].
We have not deﬁned symmetric monoidal bicategories, but you would be correct if
you guessed this is a sort of categoriﬁcation of symmetric monoidal categories. Baez
and Dolan tell the subtle story of categorifying categories to get ever higher categories
in [BD98]. Crane and Yetter give a number of examples of categoriﬁcation in [CY96].
Finally, we talked about monoidalcategoriesandcompactclosedcategories. Monoidal
categories are a classic, central topic in category theory, and a quick introduction can
be found in [Mac98]. Wiring diagrams play a huge role in this book and in applied
category theory in general; while informally used for years, these were ﬁrst formalized
in the case of monoidal categories. You can ﬁnd the details here [JS93; JSV96].

146
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Compact closed categories are a special type of structured monoidal category; there
are many others. For a broad introduction to the diﬀerent ﬂavors of monoidal category,
detailed through their various styles of wiring diagram, see [Sel10].

Chapter 5
Signal ﬂow graphs:
Props, presentations, and proofs
5.1
Comparing systems as interacting signal processors
Cyber-physical systems are systems that involve tightly interacting physical and com-
putational parts. An example is an autonomous car: sensors inform a decision system
that controls a steering unit that drives a car, whose movement changes the sensory in-
put. While such systems involve complex interactions of many diﬀerent subsystems—
both physical ones, such as the driving of a wheel by a motor, or a voltage placed across
a wire, and computational ones, such as a program that takes a measured velocity and
returns a desired acceleration—it is often useful to model the system behavior as sim-
ply the passing around and processing of signals. For this illustrative sketch, we will
just think of signals as things which we can add and multiply, such as real numbers.
Interaction in cyber-physical systems can often be understood as variable sharing;
i.e. when two systems are linked, certain variables become shared. For example, when
we connect two train carriages by a physical coupling, the train carriages must have
the same velocity, and their positions diﬀer by a constant. Similarly, when we connect
two electrical ports, the electric potentials at these two ports now must be the same,
and the current ﬂowing into one must equal the current ﬂowing out of the other.
Of course, the way the shared variable is actually used may be very diﬀerent for the
diﬀerent subsystems using it, but sharing the variable serves to couple those systems
nonetheless.
Note that both the above examples involve the physical joining of two systems; more
ﬁguratively, we might express the interconnection by drawing a line connecting the
boxes that represent the systems. In its simplest form, this is captured by the formalism
of signal ﬂow graphs, due to Claude Shannon in the 1940s. Here is an example of a
147

148
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
signal ﬂow graph:
7
5
3
2
(5.1)
We consider the dangling wires on the left as inputs, and those on the right as outputs.
In Eq. (5.1) we see three types of signal processing units, which we interpret as follows:
• Each unit labelled by a number a takes an input and multiplies it by a.
• Each black dot takes an input and produces two copies of it.
• Each white dot takes two inputs and produces their sum.
Thus the above signal ﬂow graph takes in two input signals, say x (on the upper left
wire) and y (on the lower left wire), and—going from left to right as described above—
produces two output signals: u  15x (upper right) and v  3x + 21y (lower right).
Let’s show some steps from this computation (leaving others oﬀto avoid clutter):
y
7y
x
x
15x
x + 7y
2x + 14y
3x + 21y
7
5
3
2
In words, the signal ﬂow graph ﬁrst multiplies y by 7, then splits x into two copies,
adds the second copy of x to the lower signal to get x + 7y, and so on.
A signal ﬂow graph might describe an existing system, or it might specify a system
to be built.
In either case, it is important to be able to analyze these diagrams to
understand how the composite system converts inputs to outputs. This is reminiscent
of a co-design problem from Chapter 4, which asks how to evaluate the composite
feasibility relation from a diagram of simpler feasibility relations. We can use this
process of evaluation to determine whether two diﬀerent signal ﬂow graphs in fact
specify the same composite system, and hence to validate that a system meets a given
speciﬁcation.
In this chapter, however, we introducecategoricaltools—propsandtheirpresentations—
for reasoning more directly with the diagrams. Recall from Chapter 2 that symmetric
monoidal preorders are a type of symmetric monoidal category where the morphisms
are constrained to be very simple: there can be at most one morphism between any
two objects. Here shall see that signal ﬂow graphs represent morphisms in a diﬀerent,
complementary simpliﬁcation of the symmetric monoidal category concept, known as
a prop.1 A prop is a symmetric monoidal category where the objects are constrained to
be very simple: they are generated, using the monoidal product, by just a single object.
1 Historically, the word ‘prop’ was written in all caps, ‘PROP,’ standing for ‘products and permutations
category.’ However, we ﬁnd ‘PROP’ a bit loud, so like many modern authors we opt for writing it as
‘prop.’

5.2. PROPS AND PRESENTATIONS
149
Just as the wiring diagrams for symmetric monoidal preorders did not require labels
on the boxes, this means that wiring diagrams for props do not require labels on the
wires. This makes props particularly suited for describing diagrammatic formalisms
such as signal ﬂow graphs, which only have wires of a single type.
Finally, many systems behave in what is called a linear way, and linear systems
form a foundational part of control theory, a branch of engineering that works on
cyber-physical systems.
Similarly, linear algebra is a foundational part of modern
mathematics, both pure and applied, which includes not only control theory, but also
the practice of computing, physics, statistics, and many others. As we analyze signal
ﬂow graphs, we shall see that they are in fact a way of recasting linear algebra—more
speciﬁcally, matrix operations—in graphical terms. More formally, we shall say that
signal ﬂow graphs have functorial semantics as matrices.
5.2
Props and presentations
Signal ﬂow graphs as in Eq. (5.1) are easily seen to be wiring diagrams of some sort.
However they have the property that, unlike for monoidal preorders and monoidal
categories, there is no need to label the wires. This corresponds to a form of symmetric
monoidal category, known as a prop, which has a very particular set of objects.
5.2.1
Props: deﬁnition and ﬁrst examples
Recall the deﬁnition of symmetric strict monoidal category from Deﬁnition 4.45 and Re-
mark 4.46.
Deﬁnition 5.2. A prop is a symmetric strict monoidal category (C, 0, +) for which
Ob(C)  N, the monoidal unit is 0 ∈N, and the monoidal product on objects is
given by addition.
Note that each object n is the n-fold monoidal product of the object 1; we call 1 the
generating object. Since the objects of a prop are always the natural numbers, to specify
a prop P it is enough to specify ﬁve things:
(i) a set C(m, n) of morphisms m →n, for m, n ∈N.
(ii) for all n ∈N, an identity map idn : n →n.
(iii) for all m, n ∈N, a symmetry map σm,n : m + n →n + m.
(iv) a composition rule: given f : m →n and 1 : n →p, a map ( f # 1): m →p.
(v) a monoidal product on morphisms: given f : m →m′ and 1 : n →n′, a map
( f + 1): m + n →m′ + n′.
Once one speciﬁes the above data, he should check that his speciﬁcations satisfy the
rules of symmetric monoidal categories (see Deﬁnition 4.45).2
2We use ‘his’ terminology because this deﬁnition is for boys only. The rest of the book is for girls only.

150
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Example 5.3. There is a prop FinSet where the morphisms f : m →n are functions
from m  {1, . . . m} to n  {1, . . . , n}. (The identities, symmetries, and composition
rule are obvious.) The monoidal product on functions is given by the disjoint union of
functions: that is, given f : m →m′ and 1 : n →n′, we deﬁne f + 1 : m + n −→m′ + n′
by
i 7−→
(
f (i)
if 1 ≤i ≤m;
m′ + 1(i)
if m + 1 ≤i ≤m + n.
(5.4)
Exercise 5.5.
In Example 5.3 we said that the identities, symmetries, and composition
rule in FinSet “are obvious.” In math lingo, this just means “we trust that the reader
can ﬁgure them out, if she spends the time tracking down the deﬁnitions and ﬁtting
them together.”
1. Draw a morphism f : 3 →2 and a morphism 1 : 2 →4 in FinSet.
2. Draw f + 1.
3. What is the composition rule for morphisms f : m →n and 1 : n →p in FinSet?
4. What are the identities in FinSet? Draw some.
5. Choose m, n ∈N, and draw the symmetry map σm,n in FinSet?
♦
Example 5.6. Recall from Deﬁnition 1.22 that a bĳection is a function that is both
surjective and injective.
There is a prop Bij where the morphisms f : m →n are
bĳections m →n. Note that in this case morphisms m →n only exist when m  n;
when m , n the homset Bij(m, n) is empty. Since Bij is a subcategory of FinSet, we
can deﬁne the monoidal product to be as in Eq. (5.4).
Example 5.7. The compact closed category Corel, in which the morphisms f : m →n
are partitions on m ⊔n (see Example 4.61), is a prop.
Example 5.8. There is a prop Rel for which morphisms m →n are relations, R ⊆m × n.
The composition of R with S ⊆n × p is
R # S B {(i, k) ∈m × p | ∃(j ∈n). (i, j) ∈R and (j, k) ∈S}.
The monoidal product is relatively easy to formalize using universal properties,3 but
one might get better intuition from pictures:
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
+
=

5.2. PROPS AND PRESENTATIONS
151
Exercise 5.9.
A posetal prop is a prop that is also a poset. That is, a posetal prop is a
symmetric monoidal preorder of the form (N, ⪯), for some poset relation ⪯on N, where
the monoidal product on objects is addition. We’ve spent a lot of time discussing order
structures on the natural numbers. Give three examples of a posetal prop.
♦
Exercise 5.10.
Choose one of Examples 5.6 to 5.8 and explicitly provide the ﬁve aspects
of props discussed below Deﬁnition 5.2.
♦
Deﬁnition 5.11. Let C and D be props. A functor F : C →D is called a prop functor if
(a) F is identity-on-objects, i.e. F(n)  n for all n ∈Ob(C)  Ob(D)  N, and
(b) for all f : m1 →m2 and 1 : n1 →n2 in C, we have F( f ) + F(1)  F( f + 1) in D.
Example 5.12. The inclusion i : Bij →FinSet is a prop functor. Perhaps more interest-
ingly, there is a prop functor F : FinSet →RelFin. It sends a function f : m →n to the
relation F( f ) B {(i, j) | f (i)  j} ⊆m × n.
5.2.2
The prop of port graphs
An important example of a prop is the one in which morphisms are open, directed,
acyclic port graphs, as we next deﬁne. We will just call them port graphs.
Deﬁnition 5.13. For m, n ∈N, an (m, n)-port graph (V, in, out, ι) is speciﬁed by
(i) a set V, elements of which are called vertices,
(ii) functions in, out: V →N, where in(v) and out(v) are called the in degree and out
degree of each v ∈V, and
(iii) a bĳection ι: m ⊔O
→I ⊔n, where I  {(v, i) | v ∈V, 1 ≤i ≤in(v)} is the set of
vertex inputs, and O  {(v, i) | v ∈V, 1 ≤i ≤out(v)} is the set of vertex outputs.
This data must obey the following acyclicity condition. First, use the bĳection ι to
construct the graph with vertices V and with an arrow eu,i
v,j : u →v for every i, j ∈N
such that ι(u, i)  (v, j); call it the internal ﬂow graph. If the internal ﬂow graph is
acyclic—that is, if the only path from any vertex v to itself is the trivial path—then we
say that (V, in, out, ι) is a port graph.
This seems quite a technical construction, but it’s quite intuitive once you unpack it
a bit. Let’s do this.
3The monoidal product R1 + R2 of relations R1 ⊆m1 × n1 and R2 ⊆m2 × n2 is given by R1 ⊔R2 ⊆
(m1 × n1) ⊔(m2 × n2) ⊆(m1 ⊔m2) × (n1 ⊔n2).

152
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Example 5.14. Here is an example of a (2, 3)-port graph, i.e. with m  2 and n  3:
a
b
c
1
2
1
1
2
3
1
2
1
2
3
1
2
3
1
1
2
3
(5.15)
Since the port graph has type (2, 3), we draw two ports on the left hand side of the
outer box, and three on the right. The vertex set is V  {a, b, c} and, for example
in(a)  1 and out(a)  3, so we draw one port on the left-hand side and three ports on
the right-hand side of the box labelled a. The bĳection ι is what tells us how the ports
are connected by wires:
•
1
•
2
•
(a, 1)
•
(a, 2)
•
(a, 3)
•
(b, 1)
•
(b, 2)
•
(b, 3)
•
(c, 1)
•
(a, 1)
•
(b, 1)
•
(b, 2)
•
(b, 3)
•
(c, 1)
•
(c, 2)
•
1
•
2
•
3
m
O
I
n
The internal ﬂow graph—which one can see is acyclic—is shown below:
a•
c•
b•
ea,1
c,1
ea,2
b,2
ea,3
b,1
eb,1
c,2
As you might guess from (5.15), port graphs are closely related to wiring diagrams
for monoidal categories, and even more closely related to wiring diagrams for props.
A category PG whose morphisms are port graphs.
Given an (m, n)-port graph
(V, in, out, ι) and an (n, p)-port graph (V′, in′, out′, ι′), we may compose them to produce
an (m, p)-port graph (V ⊔V′, [in, in′], [out, out′], ι′′). Here [in, in′] denotes the function
V ⊔V′ →N which maps elements of V according to in, and elements of V′ according
to in′, and similarly for [out, out′]. The bĳection ι′′: m ⊔O ⊔O′ →I ⊔I′ ⊔p is deﬁned

5.2. PROPS AND PRESENTATIONS
153
as follows:
ι′′(x) 


ι(x)
if ι(x) ∈I
ι′(ι(x))
if ι(x) ∈n
ι′(x)
if x ∈O.′
Exercise 5.16.
Describe how port graph composition looks, with respect to the visual
representation of Example 5.14, and give a nontrivial example.
♦
We thus have a category PG, whose objects are natural numbers Ob(PG)  N,
whose morphisms are port graphs PG(m, n)  {(V, in, out, ι) | as in Deﬁnition 5.13}.
Composition of port graphs is as above, and the identity port graph on n is the (n, n)-
port graph (, !, !, idn), where !:  →N is the unique function. The identity on an
object, say 3, is depicted as follows:
1
2
3
1
2
3
The monoidal structure structure on PG.
This category PG is in fact a prop. The
monoidal product of two port graphs G B (V, in, out, ι) and G′ B (V′, in′, out′, ι′) is
given by taking the disjoint union of ι and ι′:
G + G′ B  (V ⊔V′), [in, in′], [out, out′], (ι ⊔ι′)
.
(5.17)
The monoidal unit is (, !, !, !).
Exercise 5.18.
Draw the monoidal product of the morphism shown in Eq. (5.15) with
itself. It will be a (4, 6)-port graph, i.e. a morphism 4 →6 in PG.
♦
5.2.3
Free constructions and universal properties
Given some sort of categorical structure, such as a preorder, a category, or a prop, it
is useful to be able to construct one according to your own speciﬁcation. (This should
not be surprising.) The minimally-constrained structure that contains all the data you
specify is called the free structure on your speciﬁcation: it’s free from unneccessary
constraints! We have already seen some examples of free structures; let’s recall and
explore them.
Example 5.19 (The free preorder on a relation). For preorders, we saw the construction
of taking the reﬂexive, transitive closure of a relation. That is, given a relation R ⊆P×P,
the reﬂexive, transitive closure of R is the called the free preorder on R. Rather than
specify all the inequalities in the preorder (P, ≤), we can specify just a few inequalities
p ≤q, and let our “closure machine” add in the minimum number of other inequalities
necessary to make P a preorder. To obtain a preorder out of a graph, or Hasse diagram,
we consider a graph (V, A, s, t) as deﬁning a relation {(s(a), t(a)) | a ∈A} ⊆V ×V, and

154
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
apply this closure machine.
But in what sense is the reﬂexive, transitive closure of a relation R ⊆P × P really
the minimally-constrained preorder containing R? One way of understanding this is that
the extra equalities impose no further constraints when deﬁning a monotone map out
of P. We are claiming that freeness has something to do with maps out! As strange as
an asymmetry might seem here (one might ask, “why not maps in?”), the reader will
have an opportunity to explore it for herself in Exercises 5.20 and 5.21.
A higher-level justiﬁcation understands freeness as a left adjoint (see Example 3.74),
but we will not discuss that here.
Exercise 5.20. Let P be a set, let R ⊆P×P a relation, let (P, ≤P) be the preorder obtained
by taking the reﬂexive, transitive closure of R, and let (Q, ≤Q) be an arbitrary preorder.
Finally, let f : P →Q be a function, not assumed monotone.
1. Suppose that for every x, y ∈P, if R(x, y) then f (x) ≤f (y). Show that f deﬁnes
a monotone map f : (P, ≤P) →(Q, ≤Q).
2. Suppose that f deﬁnes a monotone map f : (P, ≤P) →(Q, ≤Q). Show that for
every x, y ∈P, if R(x, y) then f (x) ≤Q f (y).
We call this the universal property of the free preorder (P, ≤P).
♦
Exercise 5.21.
Let P, Q, R, etc. be as in Exercise 5.20. We want to see that the universal
property is really about maps out of—and not maps in to—the reﬂexive, transitive
closure (P, ≤). So let 1 : Q →P be a function.
1. Suppose that for every a, b ∈Q, if a ≤b then (1(a), 1(b)) ∈R. Is it automatically
true that 1 deﬁnes a monotone map 1 : (Q, ≤Q) →(P, ≤P)?
2. Suppose that 1 deﬁnes a monotone map 1 : (Q, ≤Q) →(P, ≤P). Is it automatically
true that for every a, b ∈Q, if a ≤b then (1(a), 1(b)) ∈R?
The lesson is that maps between structured objects are deﬁned to preserve con-
straints. This means the domain of a map must be somehow more constrained than
the codomain. Thus having the fewest additional constraints coincides with having the
most maps out—every function that respects our generating constraints should deﬁne
a map.
♦
Example 5.22 (The free category on a graph). There is a similar story for categories.
Indeed, we saw in Deﬁnition 3.7 the construction of the free category Free(G) on a
graph G. The objects of Free(G) and the vertices of G are the same—nothing new
here—but the morphisms of Free(G) are not just the arrows of G because morphisms
in a category have stricter requirements: they must compose and there must be an
identity. Thus morphisms in Free(G) are the closure of the set of arrows in G under
these operations. Luckily (although this happens often in category theory), the result
turns out to already be a relevant graph concept: the morphisms in Free(G) are exactly
the paths in G.
So Free(G) is a category that in a sense contains G and obeys no
equations other than those that categories are forced to obey.

5.2. PROPS AND PRESENTATIONS
155
Exercise 5.23.
Let G  (V, A, s, t) be a graph, and let G be the free category on G. Let C
be another category whose set of morphisms is denoted Mor(C).
1. Someone tells you that thereare“domainandcodomain”functionsdom, cod: Mor(C) →
Ob(C); interpret this statement.
2. Show that the set of functors G →C are in one-to-one correspondence with the
set of pairs of functions ( f , 1), where f : V →Ob(C) and 1 : A →Mor(C) for
which dom(1(a))  f (s(a)) and cod(1(a))  f (t(a)) for all a.
3. Is (Mor(C), Ob(C), dom, cod) a graph? If so, see if you can use the word “adjunc-
tion” in a sentence that describes the statement in part 2. If not, explain why
not.
♦
Exercise 5.24 (The free monoid on a set).
Recall from Example 3.13 that monoids are
one-object categories. For any set A, there is a graph Loop(A) with one vertex and with
one arrow from the vertex to itself for each a ∈A. So if A  {a, b} then Loop(A) looks
like this:
•
a
b
The free category on this graph is a one-object category, and hence a monoid; it’s called
the free monoid on A.
1. What are the elements of the free monoid on the set A  {a}?
2. Can you ﬁnd a well-known monoid that is isomorphic to the free monoid on {a}?
3. What are the elements of the free monoid on the set A  {a, b}?
♦
5.2.4
The free prop on a signature
We have been discussing free constructions, in particular for preorders and categories.
A similar construction exists for props. Since we already know what the objects of
the prop will be—the natural numbers—all we need to specify is a set G of generating
morphisms, together with the arities,4 that we want to be in our prop. This information
will be called a signature. Just as we can generate the free category from a graph, so too
can we generate the free prop from a signature.
We now give an explicit construction of the free prop in terms of port graphs (see
Deﬁnition 5.13).
Deﬁnition 5.25. A prop signature is a tuple (G, s, t), where G is a set and s, t : G →N
are functions; each element 1 ∈G is called a generator and s(1), t(1) ∈N are called its
in-arity and out-arity. We often denote (G, s, t) simply by G, taking s, t to be implicit.
A G-labeling of a port graph Γ  (V, in, out, ι) is a function ℓ: V →G such that the
arities agree: s(ℓ(v))  in(v) and t(ℓ(v))  out(v) for each v ∈V.
Deﬁne the free prop on G, denoted Free(G), to have as morphisms m →n all G-
labeled (m, n)-port graphs. The composition and monoidal structure are just those for
4The arity of a prop morphism is a pair (m, n) ∈N × N, where m is the number of inputs and n is the
number of outputs.

156
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
port graphs PG (see Eq. (5.17)); the labelings (the ℓ’s) are just carried along.
The morphisms in Free(G) are port graphs (V, in, out, ι) as in Deﬁnition 5.13, that
are equipped with a G-labeling. To draw a port graph, just as in Example 5.14, we draw
each vertex v ∈V as a box with in(v)-many ports on the left and out(v)-many ports on
the right. In wiring diagrams, we depict the labeling function ℓ: V →G by using ℓto
add labels (in the usual sense) to our boxes. Note that multiple boxes can be labelled
with the same generator. For example, if G  { f : 1 →1, 1 : 2 →2, h : 2 →1}, then the
following is a morphism 3 →2 in Free(G):
1
1
h
(5.26)
Note that the generator 1 is used twice, while the generator f is not used at all in
Eq. (5.26). This is perfectly ﬁne.
Example 5.27. The free prop on the empty set  is Bij. This is because each morphism
must have a labelling function of the form V →, and hence we must have V  ;
see Exercise 1.25. Thus the only morphisms (n, m) are those given by port graphs
(, !, !, σ), where σ: n →m is a bĳection.
Exercise 5.28.
Consider the following prop signature:
G B {ρm,n | m, n ∈N},
s(ρm,n) B m,
t(ρm,n) B n,
i.e. having one generating morphism for each (m, n) ∈N2. Show that Free(G) is the
prop PG of port graphs from Section 5.2.2.
♦
Just like free preorders and free categories, the free prop is characterized by a
universal property in terms of maps out. The following can be proved in a manner
similar to Exercise 5.23.
Proposition 5.29. The free prop Free(G) on a signature (G, s, t) has the property that,
for any prop C, the prop functors Free(G) →C are in one-to-one correspondence with
functions G →C that send each 1 ∈G to a morphism s(1) →t(1) in C.
An alternate way to describe morphisms in Free(G).
Port graphs provide a conve-
nient formalism of thinking about morphisms in the free prop on a signature G, but
there is another approach which is also useful. It is syntactic, in the sense that we start
with a small stock of basic morphisms, including elements of G, and then we inductively

5.2. PROPS AND PRESENTATIONS
157
build new morphisms from them using the basic operations of props: namely compo-
sition and monoidal product. Sometimes the conditions of monoidal categories—e.g.
associativity, unitality, functoriality, see Deﬁnition 4.45—force two such morphisms to
be equal, and so we dutifully equate them. When we are done, the result is again the
free prop Free(G). Let’s make this more formal.
First, we need the notion of a prop expression. Just as prop signatures are the
analogue of the graphs used to present categories, prop expressions are the analogue
of paths in these graphs.
Deﬁnition 5.30. Suppose we have a set G and functions s, t : G →N. We deﬁne a
G-generated prop expression, or simply expression e : m →n, where m, n ∈N, inductively
as follows:
• The empty morphism id0 : 0 →0, the identity morphism id1 : 1 →1, and the
symmetry σ: 2 →2 are expressions.5
• the generators 1 ∈G are expressions 1 : s(1) →t(1).
• if α: m →n and β: p →q are expressions, then α + β: m + p →n + q is an
expression.
• if α: m →n and β: n →p are expressions, then α # β: m →p is an expression.
We write Expr(G) for the set of expressions in G. If e : m →n is an expression, we refer
to (m, n) as its arity.
Example 5.31. Let G  { f : 1 →1, 1 : 2 →2, h : 2 →1}. Then
• id1 : 1 →1,
• f : 1 →1,
• f # id1 : 1 →1,
• h + id1 : 3 →2, and
• (h + id1) # σ # 1 # σ: 3 →2
are all G-generated prop expressions.
Both G-labeled port graphs and G-generated prop expressions are ways to describe
morphisms in the free prop Free(G). Note, however, that unlike for G-labeled port
graphs, there may be two G-generated prop expressions that represent the same mor-
phism. For example, we want to consider f # id1 and f to be the same morphism,
since the unitality axiom for categories says f # id1  f . Nonetheless, we only consider
two G-generated prop expressions equal when some axiom from the deﬁnition of prop
requires that they be so; again, the free prop is the minimally-constrained way to take G
and obtain a prop.
Since both port graphs and prop expressions describe morphisms in Free(G), you
might be wondering how to translate between them. Here’s how to turn a port graph
into a prop expression: imagine a vertical line moving through the port graph from
5One can think of σ as the “swap” icon
: 2 →2

158
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
left to right. Whenever you see “action”—either a box or wires crossing—write down
the sum (using +) of all the boxes 1, all the symmetries σ, and all the wires id1 in that
column. Finally, compose all of those action columns. For example, in the picture
below we see four action columns:
1
1
h
Here the result is (1 + id1) # (id1 + σ) # (id1 + 1) # (h + id1).
Exercise 5.32.
Consider again the free prop on generators G  { f : 1 →1, 1 : 2 →
2, h : 2 →1}. Draw a picture of ( f +id1 +id1)#(σ +id1)#(id1 + h)# σ # 1, where σ: 2 →2
is the symmetry map.
♦
Another way of describing when we should consider two prop expressions equal is
to say that they are equal if and only if they represent the same port graph. In either
case, these notions induce an equivalence relation on the set of prop expressions. To say
that we consider these certain prop expressions equal is to say that the morphisms of
the free prop on G are the G-generated prop expressions quotiented by this equivalence
relation (see Deﬁnition 1.21).
5.2.5
Props via presentations
In Section 3.2.2 we saw that a presentation for a category, or database schema, consists
of a graph together with imposed equations between paths. Similarly here, sometimes
we want to construct a prop whose morphisms obey speciﬁc equations. But rather than
mere paths, the things we want to equate are prop expressions as in Deﬁnition 5.30.
Rough Deﬁnition 5.33. A presentation (G, s, t, E) for a prop is a set G, functions
s, t : G →N, and a set E ⊆Expr(G)×Expr(G) of pairs of G-generated prop expressions,
such that e1 and e2 have the same arity for each (e1, e2) ∈E. We refer to G as the set of
generators and to E as the set of equations in the presentation.6
The prop G presented by the presentation (G, s, t, E) is the prop whose morphisms
are elements in Expr(G), quotiented by both the equations e1  e2 where (e1, e2) ∈E,
and by the axioms of symmetric strict monoidal categories.
Remark 5.34. Given a presentation (G, s, t, E), it can be shown that the prop G has
a universal property in terms of “maps out.” Namely prop functors from G to any
6Elements of E, which we call equations, are traditionally called “relations.” We think of (e1, e2) ∈E
as standing for the equation e1  e2, as this will be forced soon.

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
159
other prop C are in one-to-one correspondence with functions f from G to the set of
morphisms in C such that
• for all 1 ∈G, f (1) is a morphism s(1) →t(1), and
• for all (e1, e2) ∈E, we have that f (e1)  f (e2) in C, where f (e) denotes the
morphism in C obtained by applying f to each generators in the expression e,
and then composing the result in C.
Exercise 5.35.
Is it the case that the free prop on generators (G, s, t), deﬁned in
Deﬁnition 5.25, is the same thing as the prop presented by (G, s, t, ), having no
relations, as deﬁned in Deﬁnition 5.33? Or is there a subtle diﬀerence somehow?
♦
5.3
Simpliﬁed signal ﬂow graphs
We now return to signal ﬂow graphs, expressing them in terms of props. We will
discuss a simpliﬁed form without feedback (the only sort we have discussed so far),
and then extend to the usual form of signal ﬂow graphs in Section 5.4.3. But before
we can do that, we must say what we mean by signals; this gets us into the algebraic
structure of “rigs.” We will get to signal ﬂow graphs in Section 5.3.2.
5.3.1
Rigs
Signals can be ampliﬁed, and they can be added. Adding and ampliﬁcation interact via
a distributive law, as follows: if we add two signals, and then amplify them by some
amount a, it should be the same as amplifying the two signals separately by a, then
adding the results.
We can think of all the possible ampliﬁcations as forming a structure called a rig,7
deﬁned as follows.
Deﬁnition 5.36. A rig is a tuple (R, 0, +, 1, ∗), where R is a set, 0, 1 ∈R are elements,
and +, ∗: R × R →R are functions, such that
(a) (R, +, 0) is a commutative monoid,
(b) (R, ∗, 1) is a monoid,8 and
(c) a ∗(b + c)  a ∗b + a ∗c and (a + b) ∗c  a ∗c + b ∗c for all a, b, c ∈R.
(d) a ∗0  0  0 ∗a for all a ∈R.
We have already encountered many examples of rigs.
Example 5.37. The natural numbers form a rig (N, 0, +, 1, ∗).
7Rigs are also known as semi-rings.
8 Note that we did not demand that (R, ∗, 1) be commutative; we will see a naturally-arising example
where it is not commutative in Example 5.40.

160
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Example 5.38. The Booleans form a rig (B, false, ∨, true, ∧).
Example 5.39. Any quantale V  (V, ≤, I, ⊗) determines a rig (V, 0, ∨, I, ⊗), where 0 
Ô  is the empty join. See Deﬁnition 2.79.
Example 5.40. If R is a rig and n ∈N is any natural number, then the set Matn(R) of
(n × n)-matrices in R forms a rig. A matrix M ∈Matn(R) is a function M : n × n →
R.
Addition M + N of matrices is given by (M + N)(i, j) B M(i, j) + N(i, j) and
multiplication M ∗N is given by (M ∗N)(i, j) B Í
k∈n M(i, k) ∗N(k, j). The 0-matrix is
0(i, j) B 0 for all i, j ∈n. Note that Matn(R) is generally not commutative.
Exercise 5.41.
1. We said in Example 5.40 that for any rig R, the set Matn(R) forms a rig. What is
its multiplicative identity 1 ∈Matn(R)?
2. We also said that Matn(R) is generally not commutative. Pick an n and show that
that Matn(N) is not commutative, where N is as in Example 5.37.
♦
The following is an example for readers who are familiar with the algebraic structure
known as “rings.”
Example 5.42. Any ring forms a rig. In particular, the real numbers (R, 0, +, 1, ∗) are a
rig. The diﬀerence between a ring and rig is that a ring, in addition to all the properties
of a rig, must also have additive inverses, or negatives. A common mnemonic is that a
rig is a ring without negatives.
5.3.2
The iconography of signal ﬂow graphs
A signal ﬂow graph is supposed to keep track of the ampliﬁcation, by elements of a
rig R, to which signals are subjected. While not strictly necessary,9 we will assume the
signals themselves are elements of the same rig R. We refer to elements of R as signals
for the time being.
Ampliﬁcation of a signal by some value a ∈R is simply depicted like so:
a
(scalar mult.)
We interpret the above icon as a depicting a system where a signal enters on the
left-hand wire, is multiplied by a, and is output on the right-hand wire.
9The necessary requirement for the material below to make sense is that the signals take values in an
R-module M. We will not discuss this here, keeping to the simpler requirement that M  R.

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
161
What is more interesting than just a single signal ampliﬁcation, however, is the
interaction of signals. There are four other important icons in signal ﬂow graphs.
Let’s go through them one by one. The ﬁrst two are old friends from Chapter 2: copy
and discard.
(copy)
We interpret this diagram as taking in an input signal on the left, and outputting
that same value to both wires on the right. It is basically the “copy” operation from
Section 2.2.3.
Next, we have the ability to discard signals.
(discard)
This takes in any signal, and outputs nothing. It is basically the “waste” operation from
Section 2.2.3.
Next, we have the ability to add signals.
(add, +)
This takes the two input signals and adds them, to produce a single output signal.
Finally, we have the zero signal.
(zero, 0)
This has no inputs, but always outputs the 0 element of the rig.
Using these icons, we can build more complex signal ﬂow graphs. To compute the
operation performed by a signal ﬂow graph we simply trace the paths with the above
interpretations, plugging outputs of one icon into the inputs of the next icon.
For example, consider the rig R  N from Example 5.37, where the scalars are the
natural numbers. Recall the signal ﬂow graph from Eq. (5.1) in the introduction:
7
5
3
2
As we explained, this takes in two input signals x and y, and returns two output signals
a  15x and b  3x + 21y.
In addition to tracing the processing of the values as they move forward through
the graph, we can also calculate these values by summing over paths. More explicitly,
to get the contribution of a given input wire to a given output wire, we take the sum,
over all paths p joining the wires, of the total ampliﬁcation along that path.

162
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
So, for example, there is one path from the top input to the top output. On this
path, the signal is ﬁrst copied, which does not aﬀect its value, then ampliﬁed by 5, and
ﬁnally ampliﬁed by 3. Thus, if x is the ﬁrst input signal, then this contributes 15x to the
ﬁrst output. Since there is no path from the bottom input to the top output (one is not
allowed to traverse paths backwards), the signal at the ﬁrst output is exactly 15x. Both
inputs contribute to the bottom output. In fact, each input contributes in two ways, as
there are two paths to it from each input. The top input thus contributes 3x  x + 2x,
whereas the bottom input, passing through an additional ∗7 ampliﬁcation, contributes
21y.
Exercise 5.43.
The following ﬂow graph takes in two natural numbers x and y
3
5
3
and produces two output signals. What are they?
♦
Example 5.44. This example is for those who have some familiarity with diﬀerential
equations. A linear system of diﬀerential equations provides a simple way to specify
the movement of a particle. For example, consider a particle whose position (x, y, z) in
3-dimensional space is determined by the following equations:
Ûx + 3 Üy −2z  0
Üy + 5Ûz  0
Using what is known as the Laplace transform, one can convert this into a linear
system involving a formal variable D, which stands for “diﬀerentiate.”
Then the
system becomes
Dx + 3D2y −2z  0
D2y + 5Dz  0
which can be represented by the signal ﬂow graph
D
−2
D2
5D
3D2
Signal ﬂow graphs as morphisms in a free prop.
We can formally deﬁne simpliﬁed
signal ﬂow graphs using props.

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
163
Deﬁnition 5.45. Let R be a rig (see Deﬁnition 5.36). Consider the set
GR :
n
,
,
,
o
∪
n
a
| a ∈R
o
,
and let s, t : GR →N be given by the number of dangling wires on the left and right of
the generator icon respectively. A simpliﬁed signal ﬂow graph is a morphism in the free
prop Free(GR) on this set GR of generators. We deﬁne SFGR B Free(GR).
For now we’ll drop the term ‘simpliﬁed’, since these are the only sort of signal ﬂow
graph we know. We’ll return to signal ﬂow graphs in their full glory—i.e. including
feedback—in Section 5.4.3.
Example 5.46. To be more in line with our representations of both wiring diagrams and
port graphs, morphisms in Free(GR) should be drawn slightly diﬀerently. For example,
technically the signal ﬂow graph from Exercise 5.43 should be drawn as follows:
3
5
3
because we said we would label boxes with the elements of G. But it is easier on the
eye to draw remove the boxes and just look at the icons inside as in Exercise 5.43, and
so we’ll draw our diagrams in that fashion.
More importantly, props provide language to understand the semantics of sig-
nal ﬂow graphs. Although the signal ﬂow graphs themselves are free props, their
semantics—their meaning in our model of signals ﬂowing—will arise when we add
equations to our props, as in Deﬁnition 5.33. These equations will tell us when two
signal ﬂow graphs act the same way on signals. For example,
and
(5.47)
both express the same behavior: a single input signal is copied twice so that three
identical copies of the input signal are output.
If two signal ﬂow graphs S, T are almost the same, with the one exception being that
somewhere we replace the left-hand side of Eq. (5.47) with the right-hand side, then S
and T have the same behavior. But there are other replacements we could make to a
signal ﬂow graph that do not change its behavior. Our next goal is to ﬁnd a complete
description of these replacements.

164
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
5.3.3
The prop of matrices over a rig
Signal ﬂow graphs are closely related to matrices. In previous chapters we showed
how a matrix with values in a quantale V—a closed monoidal preorder with all joins—
represents a system of interrelated points and connections between them, such as
a profunctor. The quantale gave us the structure and axioms we needed in order for
matrix multiplication to work properly. But we know from Example 5.39 that quantales
are examples of rigs, and in fact matrix multiplication makes sense in any rig R. In
Example 5.40, we explained that the set Matn(R) of (n × n)-matrices in R can naturally
be assembled into a rig, for any ﬁxed choice of n ∈N. But what if we want to do better,
and assemble all matrices into a single algebraic structure? The result is a prop!
An (m × n)-matrix M with values in R is a function M : (m × n) →R. Given an
(m × n)-matrix M and an (n × p)-matrix N, their composite is the (m × p)-matrix M # N
deﬁned as follows for any a ∈m and c ∈p:
M # N(a, c) B
Õ
b∈n
M(a, b) × N(b, c),
(5.48)
Here the Í
b∈n just means repeated addition (using the rig R’s + operation), as usual.
Remark 5.49. Conventionally, one generally considers a matrix A acting on a vector v
by multiplication in the order Av, where v is a column vector. In keeping with our
composition convention, we use the opposite order, v # A, where v is a row vector. See
for example Eq. (5.52) for when this is implicitly used.
Deﬁnition 5.50. Let R be a rig. We deﬁne the prop of R-matrices, denoted Mat(R),
to be the prop whose morphisms m →n are the (m × n)-matrices with values in R.
Composition of morphisms is given by matrix multiplication as in Eq. (5.48).
The
monoidal product is given by the direct sum of matrices: given matrices A: m →n
and b : p →q, we deﬁne A + B : m + p →n + q to be the block matrix
 
A
0
0
B
!
where each 0 represents a matrix of zeros of the appropriate dimension (m × q and
n×p). We refer to any combination of multiplication and direct sum as a interconnection
of matrices.
Exercise 5.51.
Let A and B be the following matrices with values in N:
A 
 
3
3
1
2
0
4
!
B 

2
5
6
1

.
What is the direct sum matrix A + B?
♦

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
165
5.3.4
Turning signal ﬂow graphs into matrices
Let’s now consider more carefully what we mean when we talk about the meaning, or
semantics, of each signal ﬂow graph. We’ll use matrices.
7
5
3
2
In the examples like the above (copied from Eq. (5.1)), the signals emanating from
output wires, say a and b, are given by certain sums of ampliﬁed input values, say x
and y. If we can only measure the input and output signals, and care nothing for what
happens in between, then each signal ﬂow graph may as well be reduced to a matrix of
ampliﬁcations. We can represent the signal ﬂow graph of Eq. (5.1) by either the matrix
on the left (for more detail) or the matrix on the right if the labels are clear from context:
a
b
x
15
3
y
0
21
 
15
3
0
21
!
Every signal ﬂow graph can be interpreted as a matrix.
The generators GR from
Deﬁnition 5.45 are shown again in the table below, where each is interpreted as a
matrix. For example, we interpret ampliﬁcation by a ∈R as the 1×1 matrix (a): 1 →1:
it is an operation that takes an input x ∈R and returns a ∗x. Similarly, we can interpret
as the 2 × 1 matrix   1
1

: it is an operation that takes a row vector consisting of two
inputs, x and y, and returns x + y. Here is a table showing the interpretation of each
generator.
generator
icon
matrix
arity
amplify by a ∈R
a
 a
1 →1
add

1
1

2 →1
zero
()
0 →1
copy
 1
1
1 →2
discard
()
1 →0
(5.52)
Note that both zero and discard are represented by empty matrices, but of diﬀering
dimensions. In linear algebra it is unusual to consider matrices of the form 0×n or n×0
for various n to be diﬀerent, but they can be kept distinct for bookkeeping purposes:
you can multiply a 0 × 3 matrix by a 3 × n matrix for any n, but you can not multiply it
by a 2 × n matrix.
Since signal ﬂow graphs are morphisms in a free prop, the table in (5.52) is enough
to show that we can interpret any signal ﬂow diagram as a matrix.

166
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Theorem 5.53. There is a prop functor S: SFGR →Mat(R) that sends the generators
1 ∈G icons to the matrices as described in Table 5.52.
Proof. This follows immediately from the universal property of free props, Remark 5.34.
□
We have now constructed a matrix S(1) from any signal ﬂow graph 1. But how can
we produce this matrix explicitly? Both for the example signal ﬂow graph in Eq. (5.1)
and for the generators in Deﬁnition 5.45, the associated matrix has dimension m × n,
where m is the number of inputs and n the number of outputs, with (i, j)th entry
describing the ampliﬁcation of the ith input that contributes to the jth output. This
is how one would hope or expect the functor S to work in general; but does it? We
have used a big hammer—the universal property of free constructions—to obtain our
functor S. Our next goal is to check that it works in the expected way. Doing so is a
matter of using induction over the set of prop expressions, as we now see.10
Proposition 5.54. Let 1 be a signal ﬂow graph with m inputs and n outputs. The matrix
S(1) is the (m × n)-matrix whose (i, j)-entry describes the ampliﬁcation of the ith input
that contributes to the jth output.
Proof. Recall from Deﬁnition 5.30 that an arbitrary GR-generated prop expression is
built from the morphisms id0 : 0 →0, id1 : 1 →1, σ: 2 →2, and the generators in GR,
using the following two rules:
• if α: m →n and β: p →q are expressions, then (α + β): (m + p) →(n + q) is an
expression.
• if α: m →n and β: n →p are expressions, then α # β: m →p is an expression.
S is a prop functor by Theorem 5.53, which by Deﬁnition 5.11 must preserve identities,
compositions, monoidal products, and symmetries. We ﬁrst show that the proposition
is true when 1 is equal to id0, id1, and σ.
The empty signal ﬂow graph id0 : 0 →0 must be sent to the unique (empty) matrix
(): 0 →0. The morphisms id1, σ, and a ∈R map to the identity matrix, the swap
matrix, and the scalar matrix (a) respectively:
7→

1

and
7→
 
0
1
1
0
!
and
a
7→

a

In each case, the (i, j)-entry gives the ampliﬁcation of the ith input to the jth output.
It remains to show that if the proposition holds for α: m →n and β: p →q, then it
holds for (i) α # β (when n  p) and for (ii) α + β (in general).
10Mathematical induction is a formal proof technique that can be thought of like a domino rally: if
you knock over all the starting dominoes, and you’re sure that each domino will be knocked down if its
predecessors are, then you’re sure every domino will eventually fall. If you want more rigor, or you want
to understand the proof of Proposition 5.54 as a genuine case of induction, ask a friendly neighborhood
mathematician!

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
167
To prove (i), consider the following picture of α # β:
α
β
...
...
m inputs
...
q outputs
Here α: m →n and β: n →q are signal ﬂow graphs, assumed to obey the proposition.
Consider the ith input and kth output of α # β; we’ll just call these i and k. We want to
show that the ampliﬁcation that i contributes to k is the sum—over all paths from i to
k—of the ampliﬁcation along that path. So let’s also ﬁx some j ∈n, and consider paths
from i to k that run through j. By distributivity of the rig R, the total ampliﬁcation
from i to k through j is the total ampliﬁcation over all paths from i to j times the total
amplication over all paths from j to k. Since all paths from i to k must run through
some jth output of α/input of β, the ampliﬁcation that i contributes to k is
Õ
j∈n
α(i, j) ∗β(j, k).
This is exactly the formula for matrix multiplication, which is composition S(α) # S(β)
in the prop Mat(R); see Deﬁnition 5.50. So α # β obeys the proposition when α and β
do.
Proving (ii) is more straightforward. The monoidal product α + β of signal ﬂow
graphs looks like this:
α
β
...
m inputs
...
n outputs
...
p inputs
...
q outputs
No new paths are created; the only change is to reindex the inputs and outputs. In
particular, the ith input of α is the ith input of α+β, the jth output of α is the jth output
of α + β, the ith input of β is the (m + i)th output of α + β, and the jth output of β is the
(n + j)th output of α + β. This means that the matrix with (i, j)th entry describing the
ampliﬁcation of the ith input that contributes to the jth output is S(α)+S(β)  S(α+β),
as in Deﬁnition 5.50. This proves the proposition.
□
Exercise 5.55.
1. What matrix does the signal ﬂow graph
represent?

168
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
2. What about the signal ﬂow graph
3. Are they equal?
♦
5.3.5
The idea of functorial semantics
Let’s pause for a moment to reﬂect on what we have just learned. First, signal ﬂow
diagrams are the morphisms in a prop. This means we have two special operations we
can do to form new signal ﬂow diagrams from old, namely composition (combining
in series) and monoidal product (combining in parallel). We might think of this as
specifying a ‘grammar’ or ‘syntax’ for signal ﬂow diagrams.
As a language, signal ﬂow graphs have not only syntax but also semantics: each
signal ﬂow diagram can be interpreted as a matrix. Moreover, matrices have the same
grammatical structure: they form a prop, and we can construct new matrices from
old using composition and monoidal product. In Theorem 5.53 we completed this
picture by showing that semantic interpretation is a prop functor between the prop of
signal ﬂow graphs and the prop of matrices. Thus we say that matrices give functorial
semantics for signal ﬂow diagrams.
Functorial semantics is a key manifestation of compositionality. It says that the
matrix meaning S(1) for a big signal ﬂow graph 1 can be computed by:
1. splitting 1 up into little pieces,
2. computing the very simple matrices for each piece, and
3. using matrix multiplication and direct sum to put the pieces back together to
obtain the desired meaning, S(1).
This functoriality is useful in practice, for example in speeding up computation of the
semantics of signal ﬂow graphs: for large signal ﬂow graphs, composing matrices is
much faster than tracing paths.
5.4
Graphical linear algebra
In this section we will begin to develop something called graphical linear algebra, which
extends the ideas above.
This formalism is actually quite powerful.
For example,
with it we can easily and graphically prove certain conjectures from control theory
that, although they were eventually solved, required fairly elaborate matrix algebra
arguments [FSR16].
5.4.1
A presentation of Mat(R)
Let R be a rig, as deﬁned in Deﬁnition 5.36. The main theorem of the previous section,
Theorem 5.53, provided a functor S: SFGR →Mat(R) that converts any signal ﬂow

5.4. GRAPHICAL LINEAR ALGEBRA
169
graph into a matrix. Next we show that S is “full”: that any matrix can be represented
by a signal ﬂow graph.
Proposition 5.56. Given any matrix M ∈Mat(R), there exists a signal ﬂow graph
1 ∈SFGR such that such that S(1)  M.
Proof sketch. Let M ∈Mat(R) be an (m × n)-matrix. We want a signal ﬂow graph 1
such that S(1)  M. In particular, to compute S(1)(i, j), we know that we can simply
compute the ampliﬁcation that the ith input contributes to the jth output. The key idea
then is to construct 1 so that there is exactly one path from ith input to the jth output,
and that this path has exactly one scalar multiplication icon, namely M(i, j).
The general construction is a little technical (see Exercise 5.59), but the idea is clear
from just considering the case of 2 × 2-matrices. Suppose M is the 2 × 2-matrix ( a b
c d ).
Then we deﬁne 1 to be the signal ﬂow graph
a
b
c
d
(5.57)
Tracing paths, it is easy to see that S(1)  M. Note that 1 is the composite of four
layers, each layer respectively a monoidal product of (i) copy and discard maps, (ii)
scalar multiplications, (iii) swaps and identities, (iv) addition and zero maps.
For the general case, see Exercise 5.59.
□
Exercise 5.58.
Draw signal ﬂow graphs that represent the following matrices:
1.
©­­
«
0
1
2
ª®®
¬
2.
 
0
0
0
0
!
3.
 
1
2
3
4
5
6
!
♦
Exercise 5.59.
Write down a detailed proof of Proposition 5.56. Suppose M is an
m × n-matrix.
Follow the idea of the (2 × 2)-case in Eq. (5.57), and construct the
signal ﬂow graph 1—having m inputs and n outputs—as the composite of four layers,
respectively comprising (i) copy and discard maps, (ii) scalars, (iii) swaps and identities,
(iv) addition and zero maps.
♦
We can also use Proposition 5.56 and its proof to give a presentation of Mat(R),
which was deﬁned in Deﬁnition 5.50.

170
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Theorem 5.60. The prop Mat(R) is isomorphic to the prop with the following presen-
tation. The set of generators is the set
GR :
n
,
,
,
o
∪
n
a
| a ∈R
o
,
the same as the set of generators for SFGR; see Deﬁnition 5.45.
We have the following equations for any a, b ∈R:










a
b

ab
a
b

a+b
1

0

a

a
a
a

a
a
a

a

Proof. The key idea is that these equations are suﬃcient to rewrite any GR-generated
prop expression into a normal form—the one used in the proof of Proposition 5.56—
with all the black nodes to the left, all the white nodes to the right, and all the scalars in
the middle. This is enough to show the equality of any two expressions that represent
the same matrix. Details can be found in [BE15] or [BS17].
□
Sound and complete presentation of matrices.
Once you get used to it, Theorem 5.60
provides an intuitive, visual way to reason about matrices. Indeed, the theorem implies
two signal ﬂow graphs represent the same matrix if and only if one can be turned into
the other by local application of the above equations and the prop axioms.
The fact that you can prove two SFGs to be the same by using only graphical rules
can be stated in the jargon of logic: we say that the graphical rules provide a sound and
complete reasoning system. To be more speciﬁc, sound refers to the forward direction of
the above statement: two signal ﬂow graphs represent the same matrix if one can be
turned into the other using the given rules. Complete refers to the reverse direction: if

5.4. GRAPHICAL LINEAR ALGEBRA
171
two signal ﬂow graphs represent the same matrix, then we can convert one into the
other using the equations of Theorem 5.60.
Example 5.61. Both of the signal ﬂow graphs below represent the same matrix,  0
6

:
3
2
and
6
This means that one can be transformed into the other by using only the equations
from Theorem 5.60. Indeed, here
3
2

3
2

3
2

6
Exercise 5.62.
1. For each matrix in Exercise 5.58, draw another signal ﬂow graph that represents
that matrix.
2. Using the above equations and the prop axioms, prove that the two signal ﬂow
graphs represent the same matrix.
♦
Exercise 5.63.
Consider the signal ﬂow graphs
and
3
5
3
3
3
5
3
(5.64)
1. Let R  (N, 0, +, 1, ∗). By examining the presentation of Mat(R) in Theorem 5.60,
and without computing the matrices that the two signal ﬂow graphs in Eq. (5.64)
represent, prove that they do not represent the same matrix.
2. Now suppose the rig is R  N/3N; if you do not know what this means, just
replace all 3’s with 0’s in the right-hand diagram of Eq. (5.64). Find what you
would call a minimal representation of this diagram, using the presentation in
Theorem 5.60.
♦

172
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
5.4.2
Aside: monoid objects in a monoidal category
Various subsets of the equations in Theorem 5.60 encode structures that are familiar
from many other parts of mathematics, e.g. representation theory. For example one
can ﬁnd the axioms for (co)monoids, (co)monoid homomorphisms, Frobenius algebras,
and (with a little rearranging) Hopf algebras, sitting inside this collection. The ﬁrst
example, the notion of monoids, is particularly familiar to us by now, so we brieﬂy
discuss it below, both in algebraic terms (Deﬁnition 5.65) and in diagrammatic terms
(Example 5.68).
Deﬁnition 5.65. A monoid object (M, µ, η) in a symmetric monoidal category (C, I, ⊗) is
an object M of C together with morphisms µ: M ⊗M →M and η: I →M such that
(a) (µ ⊗id) # µ  (id ⊗µ) # µ and
(b) (η ⊗id) # µ  id  (id ⊗η) # µ.
A commutative monoid object is a monoid object that further obeys
(c) σM,M # µ  µ.
where σM,M is the swap map on M in C. We often denote it simply by σ.
Monoid objects are so-named because they are an abstraction of the usual concept
of monoid.
Example 5.66. A monoid object in (Set, 1, ×) is just a regular old monoid, as deﬁned in
Example 2.6; see also Example 3.13. That is, it is a set M, a function µ: M × M →M,
which we denote by inﬁx notation ∗, and an element η(1) ∈M, which we denote by e,
satisfying (a ∗b) ∗c  a ∗(b ∗c) and a ∗e  a  e ∗a.
Exercise 5.67.
Consider the set R of real numbers.
1. Show that if µ: R × R →R is deﬁned by µ(a, b)  a ∗b and if η ∈R is deﬁned to
be η  1, then (R, ∗, 1) satisﬁes all three conditions of Deﬁnition 5.65.
2. Show that if µ: R × R →R is deﬁned by µ(a, b)  a + b and if η ∈R is deﬁned to
be η  0, then (R, +, 0) satisﬁes all three conditions of Deﬁnition 5.65.
♦
Example 5.68. Graphically, we can depict µ 
and η 
. Then axioms (a), (b), and
(c) from Deﬁnition 5.65 become:
(a)

(b)

(c)

All three of these are found in Theorem 5.60. Thus we can immediately conclude the
following: the triple (1,
,
) is a commutative monoid object in the prop Mat(R).

5.4. GRAPHICAL LINEAR ALGEBRA
173
Exercise 5.69.
For any rig R, there is a functor U : Mat(R) →Set, sending the object
n ∈N to the set Rn, and sending a morphism (matrix) M : m →n to the function
Rm →Rn given by vector-matrix multiplication.
Recall that in Mat(R), the monoidal unit is 0 and the monoidal product is +, because
it is a prop. Recall also that in (the usual monoidal structure on) Set, the monoidal unit
is {1}, a set with one element, and the monoidal product is × (see Example 4.49).
1. Check that the functor U : Mat(R) →Set, deﬁned above, preserves the monoidal
unit and the monoidal product.
2. Show that if (M, µ, η) is a monoid object in Mat(R) then (U(M), U(µ), U(η)) is
a monoid object in Set. (This works for any monoidal functor—which we will
deﬁne in Deﬁnition 6.68—not just for U in particular.)
3. In Example 5.68, we said that the triple (1,
,
) is a commutative monoid object
in the prop Mat(R). If R  R is the rig of real numbers, this means that we have
a monoid structure on the set R. But in Exercise 5.67 we gave two such monoid
structures. Which one is it?
♦
Example 5.70. The triple (1,
,
) in Mat(R) forms a commutative monoid object in
Mat(R)op. We hence also say that (1,
,
) forms a co-commutative comonoid object in
Mat(R).
Example 5.71. A symmetric strict monoidal category, is just a commutative monoid object
in (Cat, ×, 1). We will unpack this in Section 6.4.1.
Example 5.72. A symmetric monoidal preorder, which we deﬁned in Deﬁnition 2.2, is
just a commutative monoid object in the symmetric monoidal category (Preord, ×, 1)
of preorders and monotone maps.
Example 5.73. For those who know what tensor products of commutative monoids
are (or can guess): A rig is a monoid object in the symmetric monoidal category
(CMon, ⊗, N) of commutative monoids with tensor product.
Remark 5.74. If we present a prop M using two generators µ: 2 →1 and η: 0 →1,
and the three equations from Deﬁnition 5.65, we could call it ‘the theory of monoids in
monoidal categories.’ This means that in any monoidal category C, the monoid objects
in C correspond to strict monoidal functors M →C. This sort of idea leads to the study
of algebraic theories, due to Bill Lawvere and extended by many others; see Section 5.5.

174
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
5.4.3
Signal ﬂow graphs: feedback and more
At this point in the story, we have seen that every signal ﬂow graph represents a matrix,
and this gives us a new way of reasoning about matrices. This is just the beginning of
a beautiful tale, one not only of graphical matrices, but of graphical linear algebra. We
close this chapter with some brief hints at how the story continues.
The pictoral nature of signal ﬂow graphs invites us to play with them. While we
normally draw the copy icon like so,
, we could just as easily reverse it and draw an
icon
. What might it mean? Let’s think again about the semantics of ﬂow graphs.
The behavioral approach.
A signal ﬂow graph 1 : m →n takes an input x ∈Rm and
gives an output y ∈Rn. In fact, since this is all we care about, we might just think
about representing a signal ﬂow graph 1 as describing a set of input and output pairs
(x, y). We’ll call this set the behavior of 1 and denote it B(1) ⊆Rm × Rn. For example,
the ‘copy’ ﬂow graph
sends the input 1 to the output (1, 1), so we consider (1, (1, 1)) to be an element of
copy-behavior. Similarly, (x, (x, x)) is copy behavior for every x ∈R, thus we have
B(
)  {(x, (x, x)) | x ∈R}.
In the abstract, the signal ﬂow graph 1 : m →n has the behavior
B(1) 
 x, S(1)(x)
| x ∈Rm	
⊆Rm × Rn.
(5.75)
Mirror image of an icon.
The above behavioral perspective provides a clue about
how to interpret the mirror images of the diagrams discussed above. Reversing an icon
1 : m →n exchanges the inputs with the outputs, so if we denote this reversed icon by
1op, we must have 1op : n →m. Thus if B(1) ⊆Rm ×Rn then we need B(1op) ⊆Rn ×Rm.
One simple way to do this is to replace each (a, b) with (b, a), so we would have
B(1op) B
 S(1)(x), x
| x ∈Rm	
⊆Rn × Rm.
(5.76)
This is called the transposed relation.
Exercise 5.77.
1. What is the behavior B(
) of the reversed addition icon
: 1 →2?
2. What is the behavior B(
) of the reversed copy icon,
: 2 →1?
♦
Eqs. (5.75) and (5.76) give us formulas for interpreting signal ﬂow graphs and their
mirror images. But this would easily lead to disappointment, if we couldn’t combine
the two directions behaviorally; luckily we can.

5.4. GRAPHICAL LINEAR ALGEBRA
175
Combining directions.
What should the behavior be for a diagram such as the fol-
lowing:
3
−1
3
Let’s formalize our thoughts a bit and begin by thinking about behaviors. The behavior
of a signal ﬂow graph m →n is a subset B ⊆Rm × Rn, i.e. a relation. Why not try to
construct a prop where the morphisms m →n are relations?
We’ll need to know how to compose and take monoidal products of relations.
And if we want this prop of relations to contain the old prop Mat(R), we need the new
compositions and monoidal products to generalize the old ones in Mat(R). Given signal
ﬂow graphs with matrices M : m →n and N : n →p, we see that their behaviors are
the relations B1 B {(x, Mx) | x ∈Rm} and B2 B {(y, N y) | y ∈Rn}, while the behavior
of M # N is the relation {(x, x # M # N) | x ∈Rm}. This is a case of relation composition.
Given relations B1 ⊆Rm × Rn and B2 ⊆Rn × Rp, their composite B1 # B2 ⊆Rm × Rp is
given by
B1 # B2 B {(x, z) | there exists y ∈Rn such that (x, y) ∈B1 and (y, z) ∈B2}.
(5.78)
We shall use this as the general deﬁnition for composing two behaviors.
Deﬁnition 5.79. Let R be a rig. We deﬁne the prop RelR of R-relations to have subsets
B ⊆Rm × Rn as morphisms.
These are composed by the composition rule from
Eq. (5.78), and we take the product of two sets to form their monoidal product.
Exercise 5.80.
In Deﬁnition 5.79 we went quickly through monoidal products + in the
prop RelR. If B ⊆Rm × Rn and C ⊆Rp × Rq are morphisms in RelR, write down B + C
in set-notation.
♦
(No-longer simpliﬁed) signal ﬂow graphs.
Recall that above, e.g. in Deﬁnition 5.45,
we wrote GR for the set of generators of signal ﬂow graphs. In Section 5.4.3, we wrote
1op for the mirror image of 1, for each 1 ∈GR. So let’s write Gop
R B {1op | 1 ∈GR} for
the set of all the mirror images of generators. We deﬁne a prop
SFG+
R B Free  GR ⊔Gop
R

.
(5.81)
We call a morphism in the prop SFG+
R a (non-simpliﬁed) signal ﬂow graph: these extend
our simpliﬁed signal ﬂow graphs from Deﬁnition 5.45 because now we can also use the
mirrored icons. By the universal property of free props, since we have said what the
behavior of the generators is (the behavior of a reversed icon is the transposed relation;
see Eq. (5.76)), we have speciﬁed the behavior of any signal ﬂow graph.
The following two exercises help us understand what this behavior is.

176
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Exercise 5.82.
Let 1 : m →n, h : ℓ→n be signal ﬂow graphs. Note that hop : n →ℓis
a signal ﬂow graph, and we can form the composite 1 # (hop):
−→
1
←−
hop
...
...
...
Show that the behavior of 1 # (hop) ⊆Rm × Rℓis equal to
B(1 # (hop))  {(x, y) | S(1)(x)  S(h)(y)}.
♦
Exercise 5.83.
Let 1 : m →n, h : m →p be signal ﬂow graphs. Note that (1op): n →m
is a signal ﬂow graph, and we can form the composite 1op # h
←−
1op
−→
h
...
...
...
Show that the behavior of 1op # h is equal to
B((1op) # h)  {(S(1)(x), S(h)(x)) | x ∈Rm}.
♦
Linear algebra via signal ﬂow graphs.
In Eq. (5.75) we see that every matrix, or linear
map, can be represented as the behavior of a signal ﬂow graph, and in Exercise 5.82 we
see that solution sets of linear equations can also be represented. This includes central
concepts in linear algebra, like kernels and images.
Exercise 5.84.
Here is an exercise for those that know linear algebra, in particular
kernels and cokernels. Let R be a ﬁeld, let 1 : m →n be a signal ﬂow graph, and let
S(1) ∈Mat(R) be the associated (m × n)-matrix (see Theorem 5.53).
1. Show that the composite of 1 with 0-reverses, shown here
−→
1
...
...
is equal to the kernel of the matrix S(1).
2. Show that the composite of discard-reverses with 1, shown here
−→
1
...
...
is equal to the image of the matrix S(1).
3. Show that for any signal ﬂow graph 1, the subset B(1) ⊆Rm × Rn is a linear
subspace. That is, if b1, b2 ∈B(1) then so are b1 + b2 and r ∗b1, for any r ∈R.
♦

5.4. GRAPHICAL LINEAR ALGEBRA
177
We have thus seen that signal ﬂow graphs provide a uniform, compositional lan-
guage to talk about many concepts in linear algebra. Moreover, in Exercise 5.84 we
showed that the behavior of a signal ﬂow graph is a linear relation, i.e. a relation whose
elements can be added and multiplied by scalars r ∈R. In fact the converse is true too:
any linear relation B ⊆Rm × Rn can be represented by a signal ﬂow graph.
Exercise 5.85.
One might want to show that linear relations on R form a prop, LinRelR.
That is, one might want to show that there is a sub-prop of the prop RelR from
Deﬁnition 5.79, where the morphisms m →n are the subsets B ⊆Rm × Rn such
that B is linear. In other words, where for any (x, y) ∈B and r ∈R, the element
(r ∗x, r ∗y) ∈Rm × Rn is in B, and for any (x′, y′) ∈B, the element (x + x′, y + y′) is in B.
This is certainly doable, but for this exercise, we only ask that you prove that the
composite of two linear relations is linear.
♦
Just like we gave a sound and complete presentation for the prop of matrices in
Theorem 5.60, it is possible to give a sound and complete presentation for linear
relations on R. Moreover, it is possible to give such a presentation whose generating
set is GR ⊔Gop
R as in Eq. (5.81) and whose equations include those from Theorem 5.60,
plus a few more. This presentation gives a graphical method for doing linear algebra:
an equation between linear subspaces is true if and only if it can be proved using the
equations from the presentation.
Although not diﬃcult, we leave the full presentation to further reading (Section 5.5).
Instead, we’ll conclude our exploration of the prop of linear relations by noting that
some of these ‘few more’ equations state that relations—just like co-design problems
in Chapter 4—form a compact closed category.
Compact closed structure.
Using the icons available to us for signal ﬂow graphs, we
can build morphisms that look like the ‘cup’ and ‘cap’ from Deﬁnition 4.58:
and
(5.86)
The behaviors of these graphs are respectively
{(0, (x, x)) | x ∈R} ⊆R0 × R2
and
{((x, x), 0) | x ∈R} ⊆R2 × R0.
In fact, these show the object 1 in the prop RelR is dual to itself: the morphisms from
Eq. (5.86) serve as the η1 and ϵ1 from Deﬁnition 4.58. Using monoidal products of these
morphisms, one can show that any object in RelR is dual to itself.
Graphically, this means that the three signal ﬂow graphs
all represent the same relation.
Using these relations, it is straightforward to check the following result.

178
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Theorem 5.87. The prop RelR is a compact closed category in which every object n ∈N
is dual to itself, n  n∗.
To make our signal ﬂow graphs simpler, we deﬁne new icons cup and cap by the
equations
B
and
B
Back to control theory.
Let’s close by thinking about how to represent a simple control
theory problem in this setting. Suppose we want to design a system to maintain the
speed of a car at a desired speed u. We’ll work in signal ﬂow diagrams over the rig
R[s, s−1] of polynomials in s and s−1 with coeﬃcients in R and where ss−1  s−1s  1.
This is standard in control theory: we think of s as integration, and s−1 as diﬀerentiation.
There are three factors that contribute to the actual speed v. First, there is the actual
speed v. Second, there are external forces F. Third, we have our control system: this
will take some linear combination a ∗u + b ∗v of the desired speed and actual speed,
amplify it by some factor p to give a (possibly negative) acceleration. We can represent
this system as follows, where m is the mass of the car.
1
m
s
p
s
a
b
F
u
v
This can be read as the following equation, where one notes that v occurs twice:
v 
∫
1
m F(t)dt + u(t) + p
∫
au(t) + bv(t)dt.
Our control problem then asks: how do we choose a and b to make the behavior of
this signal ﬂow graph close to the relation {(F, u, v) | u  v}? By phrasing problems in
this way, we can use extensions of the logic we have discussed above to reason about
such complex, real-world problems.
5.5
Summary and further reading
The goal of this chapter was to explain how props formalize signal ﬂow graphs, and
provide a new perspective on linear algebra. To do this, we examined the idea of free
and presented structures in terms of universal properties. This allowed us to build
props that exactly suited our needs.
Paweł Sobociński’s Graphical Linear Algebra blog is an accessible and fun exploration
of the key themes of this chapter, which goes on to describe how concepts such as
determinants, eigenvectors, and division by zero can be expressed using signal ﬂow

5.5. SUMMARY AND FURTHER READING
179
graphs [Sob]. For the technical details, one could start with Baez and Erbele [BE15],
or Zanasi’s thesis [Zan15] and its related series of papers [BSZ14; BSZ15; BS17]. For
details about applications to control theory, see [FSR16]. From the control theoretic
perspective, the ideas and philosophy of this chapter are heavily inﬂuenced by Willems’
behavioral approach [Wil07].
For the reader that has not studied abstract algebra, we mention that rings, monoids,
and matrices are standard fare in abstract algebra, and can be found in any standard
introduction, such as [Fra67]. Rigs, also known as semirings, are a bit less well known,
but no less interesting; a comprehensive survey of the literature can be found in [Gla13].
Perhaps the most signiﬁcant idea in this chapter is the separation of structure into
syntax and semantics, related by a functor. This is not only present in the running
theme of studying signal ﬂow graphs, but in our aside Section 5.4.2, where we talk,
for example, about monoid objects in monoidal categories.
The idea of functorial
semantics is yet another due to Lawvere, ﬁrst appearing in his thesis [Law04].


Chapter 6
Electric circuits:
Hypergraph categories and operads
6.1
The ubiquity of network languages
Electric circuits, chemical reaction networks, ﬁnite state automata, Markov processes:
these are all models of physical or computational systems that are commonly described
using network diagrams. Here, for example, we draw a diagram that models a ﬂip-ﬂop,
an electric circuit—important in computer memory—that can store a bit of information:
VS
OUTPUT
OUTPUT
SET
RESET
1KΩ
1KΩ
10KΩ
10KΩ
Network diagrams have time-tested utility. In this chapter, we are interested in
understanding the common mathematical structure that they share, for the purposes of
translating between and unifying them; for example certain types of Markov processes
can be simulated and hence solved using circuits of resisters. When we understand
the underlying structures that are shared by network diagram languages, we can make
comparisons between the corresponding mathematical models easily.
At ﬁrst glance network diagrams appear quite diﬀerent from the wiring diagrams we
have seen so far. For example, the wires are undirected in the case above, whereas in a
181

182
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
category—including monoidal categories seen in resource theories or co-design—every
morphism has a domain and codomain, giving it a sense of direction. Nonetheless,
we shall see how to use categorical constructions such as universal properties to create
categorical models that precisely capture the above type of “network” compositionality,
i.e. allowing us to eﬀectively drop directedness when convenient.
In particular we’ll return to the idea of a colimit, which we sketched for you at the
end of Chapter 3, and show how to use colimits in the category of sets to formalize
ideas of connection. Here’s the key idea.
Connections via colimits.
Let’s say we want to install some lights: we want to create
a circuit so that when we ﬂick a switch, a light turns on or oﬀ. To start, we have a bunch
of circuit components: a power source, a switch, and a lamp connected to a resistor:
We want to connect them together, but there are many ways to do so. How should we
describe the particular way that will form a light switch?
First, we claim that circuits should really be thought of as open circuits: each carries
the additional structure of an ‘interface’ exposing it to the rest of the electrical world.
Here by interface we mean a certain set of locations, or ports, at which we are able to
connect them with other components.1 As is so common in category theory, we begin
by making this more-or-less obvious fact explicit. Let’s depict the available ports using
a bold •. If we say that in the each of the three drawings above, the ports are simply
the dangling end points of the wires, they would be redrawn as follows:
Next, we have to describe which ports should be connected. We’ll do this by draw-
ing empty circles ◦connected by arrows to two ports •. Each will be a witness-to-
connection, saying ‘connect these two!’
1If your circuit has no such ports, it still falls within our purview, by taking its interface to be the
empty set.

6.1. THE UBIQUITY OF NETWORK LANGUAGES
183
Looking at this picture, it is clear what we need to do: just identify—i.e. merge or make
equal—the ports as indicated, to get the following circuit:
But mathematics doesn’t have a visual cortex with which to generate the intuitions
we can count on with a human reader such as yourself.2 Thus we need to specify
formally what ‘identifying ports as indicated’ means mathematically. As it turns out,
we can do this using ﬁnite colimits in a given category C.
Colimits are diagrams with certain universal properties, which is kind of an epiphe-
nomenon of the category C. Our goal is to obtain C’s colimits more directly, as a kind
of operation in some context, so that we can think of them as telling us how to connect
circuit parts together. To that end, we produce a certain monoidal category—namely
that of cospans in C, denoted CospanC—that can conveniently package C’s colimits in
terms of its own basic operations: composition and monoidal product.
In summary, the ﬁrst part of this chapter is devoted to the slogan ‘colimits model
interconnection’.
In addition to universal constructions such as colimits, however,
another way to describe interconnection is to use wiring diagrams. We go full circle
when we ﬁnd that these wiring diagrams are strongly connected to cospans, and hence
colimits.
Composition operations and wiring diagrams.
In this book we have seen the utility
of deﬁning syntactic or algebraic structures that describe the sort of composition op-
erations that make sense and can be performed in a given application area. Examples
include monoidal preorders with discarding, props, and compact closed categories.
Each of these has an associated sort of wiring diagram style, so that any wiring dia-
gram of that style represents a composition operation that makes sense in the given
area: the ﬁrst makes sense in manufacturing, the second in signal ﬂow, and the third
in collaborative design. So our second goal is to answer the question, “how do we
describe the compositional structure of network-style wiring diagrams?”
Network-type interconnection can be described using something called a hyper-
graph category. Roughly speaking, these are categories whose wiring diagrams are
those of symmetric monoidal categories together with, for each pair of natural numbers
(m, n), an icon sm,n : m →n. These icons, known as spiders,3 are drawn as follows:
Two spiders can share a leg, and when they do, we can fuse them into one spider. The
intuition is that spiders are connection points for a number of wires, and when two
2Unless the future has arrived since the writing of this book.
3Our spiders have any number of legs.

184
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
connection points are connected, they fuse to form an even more ‘connect-y’ connection
point. Here is an example:

A hypergraph category may have many species of spiders with the rule that spiders
of diﬀerent species cannot share a leg—and hence not fuse—but two spiders of the
same species can share legs and fuse. We add spider diagrams to the iconography of
hypergraph categories.
As we shall see, the ideas of describing network interconnection using colimits and
hypergraph categories come together in the notion of a theory. We ﬁrst introduced the
idea of a theory in Section 5.4.2, but here we explore it more thoroughly, starting with
the idea that, approximately speaking, cospans in the category FinSet form the theory
of hypergraph categories.
We can assemble all cospans in FinSet into something called an ‘operad’. Through-
out this book we have talked about using free structures and presentations to create
instances of algebraic structures such as preorders, categories, and props, tailored
to the needs of a particular situation.
Operads can be used to tailor the algebraic
structures themselves to the needs of a particular situation. We will discuss how this
works, in particular how operads encode various sorts of wiring diagram languages
and corresponding algebraic structures, at the end of the chapter.
6.2
Colimits and connection
Universal constructions are central to category theory. They allow us to deﬁne objects,
at least up to isomorphism, by describing their relationship with other objects. So far
we have seen this theme in a number of diﬀerent forms: meets and joins (Section 1.3),
Galois connections and adjunctions (Sections 1.4 and 3.4), limits (Section 3.5), and free
and presented structures (Section 5.2.3-5.2.5). Here we turn our attention to colimits.
In this section, our main task is to have a concrete understanding of colimits in the
category FinSet of ﬁnite sets and functions. The idea will be to take a bunch of sets—
say two or ﬁfteen or zero—use functions between them to designate that elements in
one set ‘should be considered the same’ as elements in another set, and then merge the
sets together accordingly.
6.2.1
Initial objects
Just as the simplest limit is a terminal object (see Section 3.5.1), the simplest colimit is
an initial object. This is the case where you start with no objects and you merge them
together.

6.2. COLIMITS AND CONNECTION
185
Deﬁnition 6.1. Let C be a category. An initial object in C is an object  ∈C such that for
each object T in C there exists a unique morphism !T :  →T.
The symbol  is just a default name, a notation, intended to evoke the right idea;
see Example 6.4 for the reason why we use the notation , and Exercise 6.7 for a case
when the default name  would probably not be used.
Again, the hallmark of universality is the existence of a unique map to any other
comparable object.
Example 6.2. An initial object of a preorder is a bottom element—that is, an element that
is less than every other element. For example 0 is the initial object in (N, ≤), whereas
(R, ≤) has no initial object.
Exercise 6.3.
Consider the set A  {a, b}. Find a preorder relation ≤on A such that
1. (A, ≤) has no initial object.
2. (A, ≤) has exactly one initial object.
3. (A, ≤) has two initial objects.
♦
Example 6.4. The initial object in FinSet is the empty set. Given any ﬁnite set T, there
is a unique function  →T, since  has no elements.
Example 6.5. As seen in Exercise 6.3, a category C need not have an initial object. As a
diﬀerent sort of example, consider the category shown here:
C B
A•
B•
f
1
If there were to be an initial object , it would either be A or B. Either way, we need to
show that for each object T ∈Ob(C) (i.e. for both T  A and T  B) there is a unique
morphism  →T. Trying the case  ? A this condition fails when T  B: there are
two morphisms A →B, not one. And trying the case  ? B this condition fails when
T  A: there are zero morphisms B →A, not one.
Exercise 6.6.
For each of the graphs below, consider the free category on that graph,
and say whether it has an initial object.
1.
a•
2.
a• →
b• →
c•
3.
a•
b•
4.
a•
♦
Exercise 6.7.
Recall the notion of rig from Chapter 5.
A rig homomorphism from
(R, 0R, +R, 1R, ∗R) to (S, 0S, +S, 1S, ∗S) is a function f : R →S such that f (0R)  0S,
f (r1 +R r2)  f (r1) +S f (r2), etc.
1. We said “etc.” Guess the remaining conditions for f to be a rig homomorphism.

186
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
2. Let Rig denote the category whose objects are rigs and whose morphisms are rig
homomorphisms. We claim Rig has an initial object. What is it?
♦
Exercise 6.8.
Explain the statement “the hallmark of universality is the existence of
a unique map to any other comparable object,” in the context of Deﬁnition 6.1. In
particular, what is being universal in Deﬁnition 6.1, and which is the “comparable
object”?
♦
Remark 6.9. As mentioned in Remark 3.85, we often speak of ‘the’ object that satisﬁes a
universal property, such as ‘the initial object’, even though many diﬀerent objects could
satisfy the initial object condition. Again, the reason is that initial objects are unique
up to unique isomorphism: any two initial objects will have a canonical isomorphism
between them, which one ﬁnds using various applications of the universal property.
Exercise 6.10.
Let C be a category, and suppose that c1 and c2 are initial objects. Find
an isomorphism between them, using the universal property from Deﬁnition 6.1.
♦
6.2.2
Coproducts
Coproducts generalize both joins in a preorder and disjoint unions of sets.
Deﬁnition 6.11. Let A and B be objects in a category C.
A coproduct of A and B
is an object, which we denote A + B, together with a pair of morphisms (ιA : A →
A + B, ιB : B →A + B) such that for all objects T and pairs of morphisms ( f : A →
T, 1 : B →T), there exists a unique morphism [ f , 1]: A+B →T such that the following
diagram commutes:
A
A + B
B
T
ιA
f
[ f ,1]
ιB
1
(6.12)
We call [ f , 1] the copairing of f and 1.
Exercise 6.13.
Explain why, in a preorder, coproducts are the same as joins.
♦
Example 6.14. Coproducts in the categories FinSet and Set are disjoint unions. More
precisely, suppose A and B are sets.
Then the coproduct of A and B is given by
the disjoint union A ⊔B together with the inclusion functions ιA : A −→A ⊔B and

6.2. COLIMITS AND CONNECTION
187
ιB : B →A ⊔B.
apple
•
banana
•
pear
•
cherry
•
orange
•
A
apple
•
tomato
•
mango
•
B
⊔
apple1
•
banana1
•
pear1
•
cherry1
•
orange1
•
apple2
•
tomato2
•
mango2
•
A ⊔B

(6.15)
Suppose we have functions f : A →T and 1 : B →T for some other set T,
unpictured.
The universal property of coproducts says there is a unique function
[ f , 1]: A ⊔B →T such that ιA # [ f , 1]  f and ιB # [ f , 1]  1. What is it? Any element
x ∈A ⊔B is either ‘from A’ or ‘from B’, i.e. either there is some a ∈A with x  ιA(a) or
there is some b ∈B with x  ιB(b). By Eq. (6.12), we must have:
[ f , 1](x) 
(
f (x)
if x  ιA(a) for some a ∈A;
1(x)
if x  ιB(b) for some b ∈B.
Exercise 6.16.
Suppose T  {a, b, c, . . . , z} is the set of letters in the alphabet, and let
A and B be the sets from Eq. (6.15). Consider the function f : A →T sending each
element of A to the ﬁrst letter of its label, e.g. f (apple)  a. Let 1 : B →T be the
function sending each element of B to the last letter of its label, e.g. 1(apple)  e. Write
down the function [ f , 1](x) for all eight elements of A ⊔B.
♦
Exercise 6.17.
Let f : A →C, 1 : B →C, and h : C →D be morphisms in a category C
with coproducts. Show that
1. ιA # [ f , 1]  f .
2. ιB # [ f , 1]  1.
3. [ f , 1] # h  [ f # h, 1 # h].
4. [ιA, ιB]  idA+B.
♦
Exercise 6.18.
Suppose a category C has coproducts, denoted +, and an initial object,
denoted . Then (C, +, ) is a symmetric monoidal category (recall Deﬁnition 4.45). In
this exercise we develop the data relevant to this fact:
1. Show that + extends to a functor C × C →C. In particular, how does it act on
morphisms in C × C?
2. Using the universal properties of the initial object and coproduct, show that there
are isomorphisms A +  →A and  + A →A.
3. Using the universal property of the coproduct, write down morphisms
a) (A + B) + C →A + (B + C).
b) A + B →B + A.

188
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
If you like, check that these are isomorphisms.
It can then be checked that this data obeys the axioms of a symmetric monoidal category,
but we’ll end the exercise here.
♦
6.2.3
Pushouts
Pushouts are a way of combining sets. Like a union of subsets, a pushout can combine
two sets in a non-disjoint way: elements of one set may be identiﬁed with elements of
the other. The pushout construction, however, is much more general: it allows (and
requires) the user to specify exactly which elements will be identiﬁed. We’ll see a
demonstration of this additional generality in Example 6.29.
Deﬁnition 6.19. Let C be a category and let f : A →X and 1 : A →Y be morphisms
in C that have a common domain. The pushout X +A Y is the colimit of the diagram
A
X
Y
f
1
In more detail, a pushout consists of (i) an object X +A Y and (ii) morphisms ιX : X →
X +A Y and ιY : Y →X +A Y satisfying (a) and (b) below.
(a) The diagram
A
X
Y
X +A Y
f
1
ιX
ιY
⌜
(6.20)
commutes. (We will explain the ‘⌜’ symbol below.)
(b) For all objects T and morphisms x : X →T, y : Y →T, if the diagram
A
X
Y
T
f
1
x
y
commutes, then there exists a unique morphism t : X +A Y →T such that
A
X
Y
X +A Y
T
f
1
ιX
x
ιY
y
t
(6.21)
commutes.

6.2. COLIMITS AND CONNECTION
189
If X +A Y is a pushout, we denote that fact by drawing the commutative square
Eq. (6.20), together with the ⌜symbol as shown; we call it a pushout square.
We further call ιX the pushout of 1 along f , and similarly ιY the pushout of f along 1.
Example 6.22. In a preorder, pushouts and coproducts have a lot in common.
The
pushout of a diagram B ←A →C is equal to the coproduct B ⊔C: namely, both are
equal to the join B ∨C.
Example 6.23. Let f : A →X be a morphism in a category C. For any isomorphisms
i : A →A′ and j : X →X′, we can take X′ to be the pushout X +A A′, i.e. the following
is a pushout square:
A
X
A′
X′
f
i
j
f ′
⌜
where f ′ B i−1 # f # j. To see this, observe that if there is any object T such that the
following square commutes:
A
X
A′
T
f
i
x
a
then f # x  i # a, and so we are forced to take x′: X →T to be x′ B j−1 # x. This makes
the following diagram commute:
A
X
A′
X′
T
f
i
j
x
f ′
a
x′
because f ′ # x′  i−1 # f # j # j−1 # x  i−1 # i # a  a.
Exercise 6.24.
For any set S, we have the discrete category DiscS, with S as objects and
only identity morphisms.
1. Show that all pushouts exist in DiscS, for any set S.
2. For what sets S does DiscS have an initial object?
♦
Example 6.25. In the category FinSet, pushouts always exist. The pushout of functions
f : A →X and 1 : A →Y is the set of equivalence classes of X ⊔Y under the equiva-
lence relation generated by—that is, the reﬂexive, transitive, symmetric closure of—the

190
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
relation { f (a) ∼1(a) | a ∈A}.
We can think of this in terms of interconnection too. Each element a ∈A provides
a connection between f (a) in X and 1(a) in Y. The pushout is the set of connected
components of X ⊔Y.
Exercise 6.26.
What is the pushout of the functions f : 4 →5 and 1 : 4 →3 pictured
below?
f : 4 →5
1 : 4 →3
♦
Check your answer using the abstract description from Example 6.25.
Example 6.27. Suppose a category C has an initial object . For any two objects X, Y ∈
Ob C, there is a unique morphism f :  →X and a unique morphism 1 :  →Y; this
is what it means for  to be initial.
The diagram X
f
←−
1
−→Y has a pushout in C iﬀX and Y have a coproduct in C,
and the pushout and the coproduct will be the same. Indeed, suppose X and Y have a
coproduct X + Y; then the diagram to the left

X
Y
X + Y
f
1
ιX
ιY

X
Y
T
f
1
x
y
commutes (why?1), and for any object T and commutative diagram as to the right, there
is a unique map X + Y →T making the diagram as in Eq. (6.21) commute (why?2).
This shows that X + Y is a pushout, X + Y  X + Y.
Similarly, if a pushout X + Y exists, then it satisﬁes the universal property of the
coproduct (why?3).
Exercise 6.28.
In Example 6.27 we asked “why?” three times.
1. Give a justiﬁcation for “why?1”.
2. Give a justiﬁcation for “why?2”.
3. Give a justiﬁcation for “why?3”.
♦
Example 6.29. Let A  X  Y  N. Consider the functions f : A →X and 1 : A →Y

6.2. COLIMITS AND CONNECTION
191
given by the ‘ﬂoor’ functions, f (a) B ⌊a/2⌋and 1(a) B ⌊(a + 1)/2⌋.
X
A
Y
0
0
0
1
1
1
2
2
2
3
3
3
4
4
4
5
5
5
· · ·
· · ·
· · ·
f
1
What is their pushout? Let’s ﬁgure it out using the deﬁnition.
If T is any other set and we have maps x : X →T and y : Y →T that commute with
f and 1, i.e. f  x  1  y, then this commutativity implies that
y(0)  y(1(0))  x( f (0))  x(0).
In other words, Y’s 0 and X’s 0 go to the same place in T, say t. But since f (1)  0
and 1(1)  1, we also have that t  x(0)  x( f (1))  y(1(1))  y(1). This means Y’s 1
goes to t also. But since 1(2)  1 and f (2)  1, we also have that t  1(1)  y(1(2)) 
x( f (2))  x(1), which means that X’s 1 also goes to t. One can keep repeating this
and ﬁnd that every element of Y and every element of X go to t! Using mathematical
induction, one can prove that the pushout is in fact a 1-element set, X ⊔A Y  {1}.
6.2.4
Finite colimits
Initial objects, coproducts, and pushouts are all types of colimits. We gave the general
deﬁnition of colimit in Section 3.5.4.
Just as a limit in C is a terminal object in a
category of cones over a diagram D : J →C, a colimit is an initial object in a category of
cocones over some diagram D : J →C. For our purposes it is enough to discuss ﬁnite
colimits—i.e. when J is a ﬁnite category—which subsume initial objects, coproducts,
and pushouts.4
In Deﬁnition 3.102, cocones in C are deﬁned to be cones in Cop. For visualization
purposes, if D : J →C looks like the diagram to the left, then a cocone on it shown in
the diagram to the right:
D1
D3
D2
D4
D5
C
D1
D3
D2
D4
D5
T
Here, any two parallel paths that end at T are equal in C.
4If a category J has ﬁnitely many morphisms, we say that J is a ﬁnite category. Note that in this case it
must have ﬁnitely many objects too, because each object j ∈Ob J has its own identity morphism idj.

192
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
Deﬁnition 6.30. We say that a category C has ﬁnite colimits if a colimit, colimJ D, exists
whenever J is a ﬁnite category and D : J →C is a diagram.
Example 6.31. The initial object in a category C, if it exists, is the colimit of the functor
!: 0 →C, where 0 is the category with no objects and no morphisms, and ! is the unique
such functor. Indeed, a cocone over ! is just an object of C, and so the initial cocone over
! is just the initial object of C.
Note that 0 has ﬁnitely many objects (none); thus initial objects are ﬁnite colimits.
We often want to know that a category C has all ﬁnite colimits (in which case, we
often drop the ‘all’ and just say ‘C has ﬁnite colimits’). To check that C has (all) ﬁnite
colimits, it’s enough to check it has a few simpler forms of colimit, which generate all
the rest.
Proposition 6.32. Let C be a category. The following are equivalent:
1. C has all ﬁnite colimits.
2. C has an initial object and all pushouts.
3. C has all coequalizers and all ﬁnite coproducts.
Proof. We will not give precise details here, but the key idea is an inductive one: one
can build arbitrary ﬁnite diagrams using some basic building blocks. Full details can
be found in [Bor94, Prop 2.8.2].
□
Example 6.33. Let C be a category with all pushouts, and suppose we want to take the
colimit of the following diagram in C:
B
Z
A
C
D
(6.34)
In it we see two diagrams ready to be pushed out, and we know how to take pushouts.
So suppose we do that; then we see another pushout diagram so we take the pushout
again:
B
Z
A
Y
R
X
Q
⌜
⌜
B
Z
A
Y
R
X
Q
S
⌜
⌜
⌜

6.2. COLIMITS AND CONNECTION
193
is the result—consisting of the object S, together with all the morphisms from the
original diagram to S—the colimit of the original diagram? One can check that it
indeed has the correct universal property and thus is a colimit.
Exercise 6.35.
Check that the pushout of pushouts from Example 6.33 satisﬁes the
universal property of the colimit for the original diagram, Eq. (6.34).
♦
We have already seen that the categories FinSet and Set both have an initial object
and pushouts. We thus have the following corollary.
Corollary 6.36. The categories FinSet and Set have (all) ﬁnite colimits.
In Theorem 3.95 we gave a general formula for computing ﬁnite limits in Set. It is
also possible to give a formula for computing ﬁnite colimits. There is a duality between
products and coproducts and between subobjects and quotient objects, so whereas a
ﬁnite limit is given by a subset of a product, a ﬁnite colimit is given by a quotient of a
coproduct.
Theorem 6.37. Let J be presented by the ﬁnite graph (V, A, s, t) and some equations,
and let D : J →Set be a diagram. Consider the set
colim
J
D B

(v, d) | v ∈V and d ∈D(v)
	
/∼
where this denotes the set of equivalence classes under the equivalence relation ∼
generated by putting (v, d) ∼(w, e) if there is an arrow a : v →w in J such that
D(a)(d)  e. Then this set, together with the functions ιv : D(v) →colimJ D given by
sending d ∈D(v) to its equivalence class, constitutes a colimit of D.
Example 6.38. Recall that an initial object is the colimit on the empty graph. The formula
thus says the initial object in Set is the empty set : there are no v ∈V.
Example 6.39. A coproduct is a colimit on the graph J 
v1•
v2• . A functor D : J →Set
can be identiﬁed with a choice of two sets, X B D(v1) and Y B D(v2). Since there are
no arrows in J, the equivalence relation ∼is vacuous, so the formula in Theorem 6.37
says that a coproduct is given by
{(v, d) | d ∈D(v), where v  v1 or v  v2}.
In other words, the coproduct of sets X and Y is their disjoint union X ⊔Y, as expected.

194
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
Example 6.40. If J is the category 1 
v• , the formula in Theorem 6.37 yields the set
{(v, d) | d ∈D(v)}
This is isomorphic to the set D(v). In other words, if X is a set considered as a diagram
X : 1 →Set, then its colimit (like its limit) is just X again.
Exercise 6.41.
Use the formula in Theorem 6.37 to show that pushouts—colimits on a
diagram X
f
←−N
1
−→Y—agree with the description we gave in Example 6.25.
♦
Example 6.42. Another important type of ﬁnite colimit is the coequalizer. These are
colimits over the graph • ⇒• consisting of two parallel arrows.
Consider some diagram X
Y
f
1
on this graph in Set. The coequalizer of this
diagram is the set of equivalence classes of Y under equivalence relation generated by
declaring y ∼y′ whenever there exists x in X such that f (x)  y and 1(x)  y′.
Let’s return to the example circuit in the introduction to hint at why colimits are
useful for interconnection. Consider the following picture:
We’ve redrawn this picture with one change: some of the arrows are now red, and
others are now blue. If we let X be the set of white circles ◦, and Y be the set of black
circles •, the blue and red arrows respectively deﬁne functions f , 1 : X →Y. Let’s
leave the actual circuit components out of the picture for now; we’re just interested in
the dots. What is the coequalizer?
It is a three element set, consisting of one element for each newly-connected pair of
•’s . Thus the colimit describes the set of terminals after performing the interconnection
operation. In Section 6.4 we’ll see how to keep track of the circuit components too.
6.2.5
Cospans
When a category C has ﬁnite colimits, an extremely useful way to package them is by
considering the category of cospans in C.
Deﬁnition 6.43. Let C be a category. A cospan in C is just a pair of morphisms to a
common object A →N ←B. The common object N is called the apex of the cospan
and the other two objects A and B are called its feet.

6.2. COLIMITS AND CONNECTION
195
If we want to say that cospans form a category, we should begin by saying how
composition would work. So suppose we have two cospans in C
N
A
B
f
1
and
P
B
C
h
k
Since the right foot of the ﬁrst is equal to the left foot of the second, we might stick
them together into a diagram like this:
N
P
A
B
C
f
1
h
k
Then, if a pushout of N
1
←−B
h−→P exists in C, as shown on the left, we can extract a
new cospan in C, as shown on the right:
N +B P
N
P
A
B
C
⌟
ιN
ιP
f
1
h
k
⇝
N +B P
A
C
f #ιN
k#ιP
(6.44)
It might look like we have achieved our goal, but we’re missing some things. First, we
need an identity on every object C ∈Ob C; but that’s not hard: use C →C ←C where
both maps are identities in C. More importantly, we don’t know that C has all pushouts,
so we don’t know that every two sequential morphisms A →B →C can be composed.
And beyond that, there is a technical condition that when we form pushouts, we only
get an answer ‘up to isomorphism’: anything isomorphic to a pushout counts as a
pushout (check the deﬁnition to see why). We want all these diﬀerent choices to count
as the same thing, so we deﬁne two cospans to be equivalent iﬀthere is an isomorphism
between their respective apexes. That is, the cospan A →P ←B and A →P′ ←B
in the diagram shown left below are equivalent iﬀthere is an isomorphism P  P′
making the diagram to the right commute:
P
A
B
P′
P
A
B
P′

Now we are getting somewhere. As long as our category C has pushouts, we are in
business: CospanC will form a category. But in fact, we are very close to getting more.
If we also demand that C has an initial object  as well, then we can upgrade CospanC
to a symmetric monoidal category.
Recall from Proposition 6.32 that a category C has all ﬁnite colimits iﬀit has an
initial object and all pushouts.

196
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
Deﬁnition 6.45. Let C be a category with ﬁnite colimits. Then there exists a category
CospanC with the same objects as C, i.e. Ob(CospanC)  Ob(C), where the morphisms
A →B are the (equivalence classes of) cospans from A to B, and composition is given
by the above pushout construction.
There is a symmetric monoidal structure on this category, denoted (CospanC, , +).
The monoidal unit is the initial object  ∈C and the monoidal product is given by
coproduct. The coherence isomorphisms, e.g. A +   A, can be deﬁned in a similar
way to those in Exercise 6.18.
It is a straightforward but time-consuming exercise to verify that (CospanC, , +)
from Deﬁnition 6.45 really does satisfy all the axioms of a symmetric monoidal category,
but it does.
Example 6.46. The category FinSet has ﬁnite colimits (see 6.36). So, we can deﬁne a
symmetric monoidal category CospanFinSet. What does it look like? It looks a lot like
wires connecting ports.
The objects of CospanFinSet are ﬁnite sets; here let’s draw them as collections of •’s.
The morphisms are cospans of functions. Let A and N be ﬁve element sets, and B be a
six element set. Below are two depictions of a cospan A
f
−→N
1
←−B.
A
B
N
A
B
In the depiction on the left, we simply represent the functions f and 1 by drawing
arrows from each a ∈A to f (a) and each b ∈B to 1(b). In the depiction on the right, we
make this picture resemble wires a bit more, simply drawing a wire where before we
had an arrow, and removing the unnecessary center dots. We also draw a dotted line
around points that are connected, to emphasize an important perspective, that cospans
establish that certain ports are connected, i.e. part of the same equivalence class.
The monoidal category CospanFinSet then provides two operations for combining
cospans: composition and monoidal product.
Composition is given by taking the
pushout of the maps coming from the common foot, as described in Deﬁnition 6.45.
Here is an example of cospan composition, where all the functions are depicted with

6.3. HYPERGRAPH CATEGORIES
197
arrow notation:
A
N
B
P
C
{
A
N +B P
C
(6.47)
The monoidal product is given simply by the disjoint union of two cospans; in pictures
it is simply combining two cospans by stacking one above another.
Exercise 6.48.
In Eq. (6.47) we showed morphisms A →B and B →C in CospanFinSet.
Draw their monoidal product as a morphism A + B →B + C in CospanFinSet.
♦
Exercise 6.49.
Depicting the composite of cospans in Eq. (6.47) with the wire notation
gives

(6.50)
Comparing Eq. (6.47) and Eq. (6.50), describe the composition rule in CospanFinSet in
terms of wires and connected components.
♦
6.3
Hypergraph categories
A hypergraph category is a type of symmetric monoidal category whose wiring di-
agrams are networks. We will soon see that electric circuits can be organized into a
hypergraph category; this is what we’ve been building up to. But to deﬁne hypergraph
categories, it is useful to ﬁrst introduce Frobenius monoids.
6.3.1
Frobenius monoids
The pictures of cospans we saw above, e.g. in Eq. (6.50) look something like icons in
signal ﬂow graphs (see Section 5.3.2): various wires merge and split, initialize and
terminate. And these follow the same rules they did for linear relations, which we
brieﬂy discussed in Exercise 5.84. There’s a lot of potential for confusion, so let’s start
from scratch and build back up.
In any symmetric monoidal category (C, I, ⊗), recall from Section 4.4.2 that objects
can be drawn as wires and morphisms can be drawn as boxes. Particularly noteworthy
morphisms might be iconiﬁed as dots rather than boxes, to indicate that the morphisms

198
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
there are not arbitrary but notation-worthy. One case of this is when there is an object X
with special “abilities”, e.g. the ability to duplicate into two, or disappear into nothing.
To make this precise, recall from Deﬁnition 5.65 that a commutative monoid (X, µ, η)
in symmetric monoidal category (C, I, ⊗) is an object X of C together with (noteworthy)
morphisms
µ: X ⊗X →X
η: I →X
obeying



(associativity)
(unitality)
(commutativity)
(6.51)
where
is the symmetry on X ⊗X. A cocommutative cocomonoid (X, δ, ϵ) is an
object X with maps δ: X →X ⊗X, ϵ: X →I, obeying the mirror images of the laws in
Eq. (6.51).
Suppose X has both the structure of a commutative monoid and cocommutative
comonoid, and consider a wiring diagram built only from the icons µ, η, δ, and ϵ,
where every wire is labeled X. These diagrams have a left and right, and are pictures
of how ports on the left are connected to ports on the right. The commutative monoid
and cocommutative comonoid axioms thus both express when to consider two such
connection pictures should be considered the same. For example, associativity says the
order of connecting ports on the left doesn’t matter; coassociativity (not drawn) says
the same for the right.
If you want to go all the way and say “all I care about is which port is connected to
which; I don’t even care about left and right”, then you need a few more axioms to say
how the morphisms µ and δ, the merger and the splitter, interact.
Deﬁnition 6.52. Let X be an object in a symmetric monoidal category (C, ⊗, I). A Frobe-
nius structure on X consists of a 4-tuple (µ, η, δ, ϵ) such that (X, µ, η) is a commutative
monoid and (X, δ, ϵ) is a cocommutative comonoid, which satisﬁes the six equations
above ((co-)associativity, (co-)unitality, (co-)commutativity), as well as the following
three equations:



(the Frobenius law)
(the special law)
(6.53)
We refer to an object X equipped with a Frobenius structure as a special commutative
Frobenius monoid, or just Frobenius monoid for short.

6.3. HYPERGRAPH CATEGORIES
199
With these two equations, it turns out that two morphisms X⊗m →X⊗n—deﬁned
by composing and tensoring identities on X and the noteworthy morphisms µ, δ, etc.—
are equal if and only if their string diagrams connect the same ports. This link between
connectivity, and Frobenius monoids can be made precise as follows.
Deﬁnition 6.54. Let (X, µ, η, δ, ϵ) be a Frobenius monoid in a monoidal category
(C, I, ⊗). Let m, n ∈N. Deﬁne sm,n : X⊗m →X⊗n to be the following morphism
...
...
m wires
n wires
It can be written formally as (m −1) µ’s followed by (n −1) δ’s, with special cases when
m  0 or n  0.
We call sm,n the spider of type (m, n), and can draw it more simply as the icon
m legs
n legs
So a special commutative Frobenius monoid, aside from being a mouthful, is a
‘spiderable’ wire. You agree that in any monoidal category wiring diagram language,
wires represent objects and boxes represent morphisms? Well in our weird way of
talking, if a wire is spiderable, it means that we have a bunch of morphisms µ, η, δ, ϵ, σ
that we can combine without worrying about the order of doing so: the result is just
“how many in’s, and how many out’s”: a spider. Here’s a formal statement.
Theorem 6.55. Let (X, µ, η, δ, ϵ) be a Frobenius monoid in a monoidal category (C, I, ⊗).
Suppose that we have a map f : X⊗m →X⊗n each constructed from spiders and the
symmetry map σ: X⊗2 →X⊗2 using composition and the monoidal product, and such
that the string diagram of f has only one connected component. Then it is a spider:
f  sm,n.
Example 6.56. As the following two morphisms both (i) have the same number of
inputs and outputs, (ii) are constructed only from spiders, and (iii) are connected,
Theorem 6.55 immediately implies they are equal:

Exercise 6.57.
Let X be an object equipped with a Frobenius structure. Which of the
morphisms X ⊗X →X ⊗X ⊗X in the following list are necessarily equal?
1.

200
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
2.
3.
4.
5.
6.
♦
Back to cospans.
Another way of understanding Frobenius monoids is to relate them
to cospans. Recall the notion of prop presentation from Deﬁnition 5.33.
Theorem 6.58. Consider the four-element set G B {µ, η, δ, ϵ} and deﬁne in, out: G →
N as follows:
in(µ) B 2,
in(η) B 0,
in(δ) B 1,
in(ϵ) B 1,
out(µ) B 1,
out(η) B 1,
out(δ) B 2,
out(ϵ) B 0.
Let E be the set of Frobenius axioms, i.e. the nine equations from Deﬁnition 6.52.
Then the free prop on (G, E) is equivalent, as a symmetric monoidal category,a to
CospanFinSet.
a We will not explain precisely what it means to be equivalent as a symmetric monoidal category, but
you probably have some idea: “they are the same for all category-theoretic intents and purposes.” The
idea is similar to that of equivalence of categories, as explained in Remark 3.59.
Thus we see that ideal wires, connectivity, cospans, and objects with Frobenius
structures are all intimately related. We use Frobenius structures (all that splitting,
merging, initializing, and terminating stuﬀ) as a way to capture the grammar of circuit
diagrams.
6.3.2
Wiring diagrams for hypergraph categories
We introduce hypergraph categories through their wiring diagrams.
Just like for
monoidal categories, the formal deﬁnition is just the structure required to unambigu-
ously interpret these diagrams.

6.3. HYPERGRAPH CATEGORIES
201
Indeed, our interest in hypergraph categories is best seen in their wiring diagrams.
The key idea is that wiring diagrams for hypergraph categories are network diagrams.
This means, in addition to drawing labeled boxes with inputs and outputs, as we can
for monoidal categories, and in addition to bending these wires around as we can for
compact closed categories, we are allowed to split, join, terminate, and initialize wires.
Here is an example of a wiring diagram that represents a composite of morphisms
in a hypergraph category
f
h
h
1
A
B
C
D
D
B
A
We have suppressed some of the object/wire labels for readability, since all types can
be inferred from the labeled ones.
Exercise 6.59.
1. What label should be on the input to h?
2. What label should be on the output of 1?
3. What label should be on the fourth output wire of the composite?
♦
Thus hypergraph categories are general enough to talk about all network-style dia-
grammatic languages, like circuit diagrams.
6.3.3
Deﬁnition of hypergraph category
We are now ready to deﬁne hypergraph categories formally. Since the wiring diagrams
for hypergraph categories are just those for symmetric monoidal categories with a few
additional icons, the deﬁnition is relatively straightforward: we just want a Frobenius
structure on every object. The only coherence condition is that these interact nicely
with the monoidal product.
Deﬁnition 6.60. A hypergraph category is a symmetric monoidal category (C, I, ⊗) in
which each object X is equipped with a Frobenius structure (X, µX, δX, ηX, ϵX) such

202
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
that
X ⊗Y
X ⊗Y
X ⊗Y 
X
X
X
Y
Y
Y
X ⊗Y 
X
Y
X ⊗Y
X ⊗Y
X ⊗Y

X
X
X
Y
Y
Y
X ⊗Y
 X
Y
for all objects X, Y, and such that ηI  idI  ϵI.
A hypergraph prop is a hypergraph category that is also a prop, e.g. Ob(C)  N, etc.
Example 6.61. For any C with ﬁnite colimits, CospanC is a hypergraph category. The
Frobenius morphisms µX, δX, ηX, ϵX for each object X are constructed using the uni-
versal properties of colimits:
µX B
 X + X
[idX,idX]
−−−−−−→X
idX
←−−−−−−−−−−X
ηX B
 
!X
−−−−−−−−−−→X
idX
←−−−−−−−−−−X
δX B
 X
idX
−−−−−−−−−−→X
[idX,idX]
←−−−−−−X + X
ϵX B
 X
idX
−−−−−−−−−−→X
!X
←−−−−−−−−−−
Exercise 6.62. By Example 6.61, the category CospanFinSet is a hypergraph category. (In
fact, it is equivalent to a hypergraph prop.) Draw the Frobenius morphisms for the ob-
ject 1 in CospanFinSet using both the function and wiring depictions as in Example 6.46.
♦
Exercise 6.63.
Using your knowledge of colimits, show that the maps deﬁned in
Example 6.61 do indeed obey the special law (see Deﬁnition 6.52).
♦
Example 6.64. Recall the monoidal category (Corel, , ⊔) from Example 4.61; its objects
are ﬁnite sets and its morphisms are corelations.
Given a ﬁnite set X, deﬁne the
corelation µX : X ⊔X →X such that two elements of X ⊔X ⊔X are equivalent if and
only if they come from the same underlying element of X. Deﬁne δX : X →X ⊔X in
the same way, and deﬁne ηX :  →X and ϵX : X → such that no two elements of
X   ⊔X  X ⊔ are equivalent.
These maps deﬁne a special commutative Frobenius monoid (X, µX, ηX, δX, ϵX),

6.4. DECORATED COSPANS
203
and in fact give Corel the structure of a hypergraph category.
Example 6.65. The prop of linear relations, which we brieﬂy mentioned in Exercise 5.84,
is a hypergraph category. In fact, it is a hypergraph category in two ways, by choosing
either the black ‘copy’ and ‘discard’ generators or the white ‘add’ and ‘zero’ generators
as the Frobenius maps.
We can generalize the construction we gave in Theorem 5.87.
Proposition 6.66. Hypergraph categories are self-dual compact closed categories, if
we deﬁne the cup and cap to be
B
and
B
Proof. The proof is a straightforward application of the Frobenius and unitality axioms:

(deﬁnition)

Exercise 6.67!
(Frobenius)

(unitality)
□
Exercise 6.67.
Fill in the missing diagram in the proof of Proposition 6.66 using the
equations from Eq. (6.51), their opposites, and Eq. (6.53).
♦
6.4
Decorated cospans
The goal of this section is to show how we can construct a hypergraph category
whose morphisms are electric circuits. To do this, we ﬁrst must introduce the no-
tion of structure-preserving map for symmetric monoidal categories, a generalization
of monoidal monotones known as symmetric monoidal functors. Then we introduce
a general method—that of decorated cospans—for producing hypergraph categories.
Doing all this will tie up lots of loose ends: colimits, cospans, circuits, and hypergraph
categories.

204
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
6.4.1
Symmetric monoidal functors
Rough Deﬁnition 6.68. Let (C, IC, ⊗C) and (D, ID, ⊗D) be symmetric monoidal cate-
gories. To specify a symmetric monoidal functor (F, ϕ) between them,
(i) one speciﬁes a functor F : C →D;
(ii) one speciﬁes a morphism ϕI : ID →F(IC).
(iii) for each c1, c2 ∈Ob(C), one speciﬁes a morphism
ϕc1,c2 : F(c1) ⊗D F(c2) →F(c1 ⊗C c2),
natural in c1 and c2.
We call the various maps ϕ coherence maps. We require the coherence maps to obey
bookkeeping axioms that ensure they are well behaved with respect to the symmetric
monoidal structures on C and D. If ϕI and ϕc1,c2 are isomorphisms for all c1, c2, we say
that (F, ϕ) is strong.
Example 6.69. Consider the power set functor P: Set →Set.
It acts on objects by
sending a set S ∈Set to its set of subsets P(S) B {R ⊆S}. It acts on morphisms by
sending a function f : S →T to the image map im f : P(S) →P(T), which maps R ⊆S
to { f (r) | r ∈R} ⊆T.
Now consider the symmetric monoidal structure ({1}, ×) on Set from Example 4.49.
To make P a symmetric monoidal functor, we need to specify a function ϕI : {1} →
P({1}) and for all sets S and T, a functor ϕS,T : P(S)×P(T) →P(S×T). One possibility is
to deﬁne ϕI(1) to be the maximal subset {1} ⊆{1}, and given subsets A ⊆S and B ⊆T,
to deﬁne ϕS,T(A, B) to be the product subset A × B ⊆S × T. With these deﬁnitions,
(P, ϕ) is a symmetric monoidal functor.
Exercise 6.70.
Check that the maps ϕS,T deﬁned in Example 6.69 are natural in S and
T. In other words, given f : S →S′ and 1 : T →T′, show that the diagram below
commutes:
P(S) × P(T)
P(S × T)
P(S′) × P(T′)
P(S′ × T′)
ϕS,T
im f × im1
im f ×1
ϕS′,T′
♦
6.4.2
Decorated cospans
Now that we have brieﬂy introduced symmetric monoidal functors, we return to the
task at hand: constructing a hypergraph category of circuits. To do so, we introduce
the method of decorated cospans.
Circuits have lots of internal structure, but they also have some external ports—also
called ‘terminals’—by which to interconnect them with others. Decorated cospans are
ways of discussing exactly that: things with external ports and internal structure.

6.4. DECORATED COSPANS
205
To see how this works, let us start with the following example circuit:
2Ω
3F
1Ω
1Ω
1H
(6.71)
We might formally consider this as a graph on the set of four ports, where each edge
is labeled by a type of circuit component (for example, the top edge would be labeled
as a resistor of resistance 2Ω). For this circuit to be a morphism in some category, i.e.
in order to allow for interconnection, we must equip the circuit with some notion of
interface. We do this by marking the ports in the interface using functions from ﬁnite
sets:
A
B
N
2Ω
3F
1Ω
1Ω
1H
(6.72)
Let N be the set of nodes of the circuit. Here the ﬁnite sets A, B, and N are sets
consisting of one, two, and four elements respectively, drawn as points, and the values
of the functions A →N and B →N are indicated by the grey arrows. This forms a
cospan in the category of ﬁnite sets, for which the apex set N has been decorated by our
given circuit.
Suppose given another such decorated cospan with input B
B
C
5Ω
8Ω
Since the output of the ﬁrst equals the input of the second (both are B), we can stick

206
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
them together into a single diagram:
A
N
B
2Ω
3F
1Ω
1Ω
1H
M
C
5Ω
8Ω
(6.73)
The composition is given by gluing the circuits along the identiﬁcations speciﬁed by B,
resulting in the decorated cospan
A
N +B M
C
2Ω
3F
1Ω
1Ω
1H
5Ω
8Ω
(6.74)
We’ve seen this sort of gluing before when we deﬁned composition of cospans in
Deﬁnition 6.45. But now there’s this whole ‘decoration’ thing; our goal is to formalize
it.
Deﬁnition 6.75. Let C be a category with ﬁnite colimits, and (F, ϕ): (C, +) −→(Set, ×)
be a symmetric monoidal functor. An F-decorated cospan is a pair consisting of a cospan
A
i→N
o←B in C together with an element s ∈F(N).5 We call (F, ϕ) the decoration
functor and s the decoration.
The intuition here is to use C  FinSet, and, for each object N ∈FinSet, the functor
F assigns the set of all legal decorations on a set N of nodes. When you choose an F-
decorated cospan, you choose a set A of left-hand external ports, a set B of right-hand
external ports, each of which maps to a set N of nodes, and you choose one of the
available decorations on N nodes, taken from the set F(N).
So, in our electrical circuit case, the decoration functor F sends a ﬁnite set N to
the set of circuit diagrams—graphs whose edges are labeled by resistors, capacitors,
etc.—that have N vertices.
Our goal is still to be able to compose such diagrams; so how does that work exactly?
Basically one combines the way cospans are composed with the structures deﬁning our
decoration functor: namely F and ϕ.
Let (A
f
−→N
1
←−B, s) and (B
h−→P
k←−C, t) represent decorated cospans.
Their
composite is represented by the composite of the cospans A
f
−→N
1
←−B and B
h−→P
k←−C,
5Just like in Deﬁnition 6.45, we should technically use equivalence classes of cospans. We will elide
this point to get the bigger idea across. The interested reader should consult Section 6.6.

6.4. DECORATED COSPANS
207
paired with the following element of F(N +B P):
F([ιN, ιP])(ϕN,P(s, t))
(6.76)
That’s rather compact! We’ll unpack it, in a concrete case, in just a second. But let’s
record a theorem ﬁrst.
Theorem 6.77. Given a category C with ﬁnite colimits and a symmetric monoidal func-
tor (F, ϕ): (C, +) −→(Set, ×), there is a hypergraph category CospanF whose objects
are the objects of C, and whose morphisms are equivalence classes of F-decorated
cospans.
The symmetric monoidal and hypergraph structures are derived from those on
CospanC.
Exercise 6.78. Suppose you’re worried that the notation CospanC looks like the notation
CospanF, even though they’re very diﬀerent.
An expert tells you “they’re not so
diﬀerent; one is a special case of the other. Just use the constant functor F(c) B {∗}.”
What does the expert mean?
♦
6.4.3
Electric circuits
In order to work with the above abstractions, we will get a bit more precise about the
circuits example and then have a detailed look at how composition works in decorated
cospan categories.
Let’s build some circuits.
To begin, we’ll need to choose which components we want
in our circuit. This is simply a matter of what’s in our electrical toolbox. Let’s say we’re
carrying some lightbulbs, switches, batteries, and resistors of every possible resistance.
That is, deﬁne a set
C B {light, switch, battery} ⊔{xΩ| x ∈R+}.
To be clear, theΩare just labels; theabovesetisisomorphicto {light, switch, battery}⊔
R+. But we write C this way to remind us that it consists of circuit components. If we
wanted, we could also add inductors, capacitors, and even elements connecting more
than two ports, like transistors, but let’s keep things simple for now.
Given our set C, a C-circuit is just a graph (V, A, s, t), where s, t : A →V are the
source and target functions, together with a function ℓ: A →C labeling each edge with
a certain circuit component from C.
For example, we might have the simple case of V  {1, 2}, A  {e}, s(e)  1,
t(e)  2—so e is an edge from 1 to 2—and ℓ(e)  3Ω. This represents a resistor with
resistance 3Ω:
3Ω
1
2

208
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
Note that in the formalism we have chosen, we have multiple ways to represent any
circuit, as our representations explicitly choose directions for the edges. The above
resistor could also be represented by the ‘reversed graph’, with data V  {1, 2}, A  {e},
s(e)  2, t(e)  1, and ℓ(e)  3F.
Exercise 6.79.
Write a tuple (V, A, s, t, ℓ) that represents the circuit in Eq. (6.71).
♦
A decoration functor for circuits.
We want C-circuits to be our decorations, so let’s
use them to deﬁne a decoration functor as in Deﬁnition 6.75. We’ll call the functor
(Circ, ψ). We start by deﬁning the functor part
Circ: (FinSet, +) −→(Set, ×)
as follows. On objects, simply send a ﬁnite set V to the set of C-circuits:
Circ(V) B {(V, A, s, t, ℓ) | where s, t : A →V, ℓ: E →C}.
On morphisms, Circ sends a function f : V →V′ to the function
Circ( f ): Circ(V) −→Circ(V′);
(V, A, s, t, ℓ) 7−→ V′, A, (s # f ), (t # f ), ℓ
.
This deﬁnes a functor; let’s explore it a bit in an exercise.
Exercise 6.80.
To understand this functor better, let c ∈Circ(4) be the circuit
3Ω
1
2
3
4
and let f : 4 →3 be the function
1
2
3
4
1
2
3
Draw a picture of the circuit Circ( f )(c).
♦
We’re trying to get a decoration functor (Circ, ψ) and so far we have Circ. For the
coherence maps ψV,V′ for ﬁnite sets V, V′, we deﬁne
ψV,V′ : Circ(V) × Circ(V′) −→Circ(V + V′);
 (V, A, s, t, ℓ), (V′, A′, s′, t′, ℓ′)
7−→(V + V′, A + A′, s + s′, t + t′, [ℓ, ℓ′]).
(6.81)
This is simpler than it may look: it takes a circuit on V and a circuit on V′, and just
considers them together as a circuit on the disjoint union of vertices V + V′.
Exercise 6.82.
Suppose we have circuits
b B
and
s B
in Circ(2). Use the deﬁnition of ψV,V′ from (6.81) to ﬁgure out what 4-vertex circuit
ψ2,2(b, s) ∈Circ(2 + 2)  Circ(4) should be, and draw a picture.
♦

6.4. DECORATED COSPANS
209
Open circuits using decorated cospans.
From the above data, just a monoidal functor
(Circ, ψ): (FinSet, +) →(Set, ×), we can construct our promised hypergraph category
of circuits!
Our notation for this category is CospanCirc. Following Theorem 6.77, the objects
of this category are the same as the objects of FinSet, just ﬁnite sets. We’ll reprise
our notation from the introduction and Example 6.42, and draw these ﬁnite sets as
collections of white circles ◦. For example, we’ll represent the object 2 of CospanCirc as
two white circles:
These white circles mark interface points of an open circuit.
More interesting than the objects, however, are the morphisms in CospanCirc. These
are open circuits. By Theorem 6.77, a morphism m →n is a Circ-decorated cospan:
that is, cospan m →p ←n together with an element c of Circ(p). As an example,
consider the cospan 1
i1−→2
i2
←−1 where i1(1)  1 and i2(1)  2, equipped with the
battery element of Circ(2) connecting node 1 and node 2. We’ll depict this as follows:
(6.83)
Exercise 6.84.
Morphisms of CospanCirc are Circ-decorated cospans, as deﬁned in
Deﬁnition 6.75. This means (6.83) depicts a cospan together with a decoration, which is
some C-circuit (V, A, s, t, ℓ) ∈Circ(2). What is it?
♦
Let’s now see how the hypergraph operations in CospanCirc can be used to construct
electric circuits.
Composition in CospanCirc.
First we’ll consider composition. Consider the following
decorated cospan from 1 to 1:
Since this and the circuit in (6.83) are both morphisms 1 →1, we may compose them
to get another morphism 1 →1. How do we do this? There are two parts: to get
the new cospan, we simply compose the cospans of our two circuits, and to get the
new decoration, we use the formula Circ([ιN, ιP])(ψN,P(s, t)) from (6.76). Again, this is
rather compact! Let’s unpack it together.
We’ll start with the cospans. The cospans we wish to compose are
and

210
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
(We simply ignore the decorations for now.) If we pushout over the common set 1  {◦},
we obtain the pushout square
(6.85)
This means the composite cospan is
In the meantime, we already had you start us oﬀunpacking the formula for the
new decoration. You told us what the map ψ2,2 does in Exercise 6.82. It takes the two
decorations, both circuits in Circ(2), and turns them into the single, disjoint circuit
in Circ(4). So this is what the ψN,P(s, t) part means. What does the [ιN, ιP] mean? Recall
this is the copairing of the pushout maps, as described in Examples 6.14 and 6.25. In our
case, the relevant pushout square is given by (6.85), and [ιN, ιP] is in fact the function
f from Exercise 6.80! This means the decoration on the composite cospan is
Putting this all together, the composite circuit is
Exercise 6.86.
Refer back to the example at the beginning of Section 6.4.2. In particular,
consider the composition of circuits in Eq. (6.73).
Express the two circuits in this
diagram as morphisms in CospanCirc, and compute their composite. Does it match the
picture in Eq. (6.74)?
♦
Monoidal products in CospanCirc.
Monoidal products in CospanCirc are much sim-
pler than composition. On objects, we again just work as in FinSet: we take the disjoint
union of ﬁnite sets. Morphisms again have a cospan, and a decoration. For cospans,
we again just work in CospanFinSet: given two cospans A →M ←B and C →N ←D,
we take their coproduct cospan A + C →M + N ←B + D. And for decorations, we
use the map ψM,N : Circ(M) × Circ(N) →Circ(M + N). So, for example, suppose we
want to take the monoidal product of the open circuits

6.5. OPERADS AND THEIR ALGEBRAS
211
and
The result is given by stacking them. In other words, their monoidal product is:
(6.87)
Easy, right?
We leave you to do two compositions of your own.
Exercise 6.88.
Write x for the open circuit in (6.87). Also deﬁne cospans η: 0 →2 and
η: 2 →0 as follows:
η B


: ϵ
where each of these are decorated by the empty circuit (1, , !, !, !) ∈Circ(1).6
Compute the composite η # x # ϵ in CospanCirc. This is a morphism 0 →0; we call
such things closed circuits.
♦
6.5
Operads and their algebras
In Theorem 6.77 we described how decorating cospans builds a hypergraph category
from a symmetric monoidal functor. We then explored how that works in the case that
the decoration functor is somehow “all circuit graphs on a set of nodes”.
In this book, we have devoted a great deal of attention to diﬀerent sorts of composi-
tional theories, from monoidal preorders to compact closed categories to hypergraph
categories. Yet for an application you someday have in mind, it may be the case that
none of these theories suﬃce. You need a diﬀerent structure, customized to a particular
situation. For example in [VSL15] the authors wanted to compose continuous dynam-
ical systems with control-theoretic properties and realized that in order for feedback
to make sense, the wiring diagrams could not involve what they called ‘passing wires’.
So to close our discussion of compositional structures, we want to quickly sketch
something we can use as a sort of meta-compositional structure, known as an operad.
We saw in Section 6.4.3 that we can build electric circuits from a symmetric monoidal
functor FinSet →Set. Similarly we’ll see that we can build examples of new algebraic
structures from operad functors O →Set.
6.5.1
Operads design wiring diagrams
Understanding that circuits are morphisms in a hypergraph category is useful: it means
we can bring the machinery of category theory to bear on understanding electrical

212
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
circuits. For example, we can build functors that express the compositionality of circuit
semantics, i.e. how to derive the functionality of the whole from the functionality and
interaction pattern of the parts. Or we can use the category-theoretic foundation to
relate circuits to other sorts of network systems, such as signal ﬂow graphs. Finally,
the basic coherence theorems for monoidal categories and compact closed categories
tell us that wiring diagrams give sound and complete reasoning in these settings.
However, one perhaps unsatisfying result is that the hypergraph category intro-
duces artifacts like the domain and codomain of a circuit, which are not inherent to the
structure of circuits or their composition. Circuits just have a single boundary inter-
face, not ‘domains’ and ‘codomains’. This is not to say the above model is not useful:
in many applications, a vector space does not have a preferred basis, but it is often
useful to pick one so that we may use matrices (or signal ﬂow graphs!). But it would
be worthwhile to have a category-theoretic model that more directly represents the
compositional structure of circuits. In general, we want the category-theoretic model
to ﬁt our desired application like a glove. Let us quickly sketch how this can be done.
Let’s return to wiring diagrams for a second. We saw that wiring diagrams for
hypergraph categories basically look like this:
f
1
h
k
A
B
C
D
F
E
D
(6.89)
Note that if you had a box with A and B on the left and D on the right, you could plug
the above diagram right inside it, and get a new open circuit. This is the basic move of
operads.
But before we explain this, let’s get where we said we wanted to go: to a model
where there aren’t ports on the left and ports on the right, there are just ports. We want
a more succinct model of composition for circuit diagrams; something that looks more
like this:
f
h
1
k
B
C
A
D
E
F
D
(6.90)

6.5. OPERADS AND THEIR ALGEBRAS
213
Do you see how diagrams Eq. (6.89) and Eq. (6.90) are actually exactly the same in
terms of interconnection pattern? The only diﬀerence is that the latter does not have
left/right distinction: we have lost exactly what we wanted to lose.
The cost is that the ‘boxes’ f , 1, h, k in Eq. (6.90) no longer have a left/right dis-
tinction; they’re just circles now. That wouldn’t be bad except that it means they can
no longer represent morphisms in a category—like they used to above, in Eq. (6.89)—
because morphisms in a category by deﬁnition have a domain and codomain. Our
new circles have no such distinction. So now we need a whole new way to think about
‘boxes’ categorically: if they’re no longer morphisms in a category, what are they? The
answer is found in the theory of operads.
In understanding operads, we will ﬁnd we need to navigate one of the level shifts
that we ﬁrst discussed in Section 1.4.5. Notice that for decorated cospans, we deﬁne
a hypergraph category using a symmetric monoidal functor.
This is reminiscent of
our brief discussion of algebraic theories in Section 5.4.2, where we deﬁned something
called the theory of monoids as a prop M, and deﬁne monoids using functors M →Set;
see Remark 5.74. In the same way, we can view the category CospanFinSet as some sort
of ‘theory of hypergraph categories’, and so deﬁne hypergraph categories as functors
CospanFinSet →Set.
So that’s the idea. An operad O will deﬁne a theory or grammar of composition, and
operad functors O →Set, known as O-algebras, will describe particular applications
that obey that grammar.
Rough Deﬁnition 6.91. To specify an operad O,
(i) one speciﬁes a collection T, whose elements are called types;
(ii) for each tuple (t1, . . . , tn, t) of types, one speciﬁes a set O(t1, . . . , tn; t), whose
elements are called operations of arity (t1, . . . , tn; t);
(iii) for each pair of tuples (s1, . . . , sm, ti) and (t1, . . . , tn, t), one speciﬁes a function
◦i : O(s1, . . . , sm; ti) × O(t1, . . . , tn; t) →O(t1, . . . , ti−1, s1, . . . , sm, ti+1, . . . , tn; t);
called substitution; and
(iv) for each type t, one speciﬁes an operation idt ∈O(t; t) called the identity operation.
These must obey generalized identity and associativity laws.7
Let’s ignore types for a moment and think about what this structure models. The
intuition is that an operad consists of, for each n, a set of operations of arity n—that is,
all the operations that accept n arguments. If we take an operation f of arity m, and
plug the output into the ith argument of an operation 1 of arity n, we should get an
operation of arity m + n −1: we have m arguments to ﬁll in m, and the remaining n −1
6As usual ! denotes the unique function, in this case from the empty set to the relevant codomain.
7Often what we call types are called objects or colors, what we call operations are called morphisms,
what we call substitution is called composition, and what we call operads are called multicategories. A
formal deﬁnition can be found in [Lei04].

214
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
arguments to ﬁll in 1. Which operation of arity m+n−1 do we get? This is described by
the substitution function ◦i, which says we obtain the operation f ◦i 1 ∈O(m + n −1).
The coherence conditions say that these functions ◦i capture the following intuitive
picture:
{
The types then allow us to specify the, well, types of the arguments—inputs—that
each function takes. So making tea is a 2-ary operation, an operation with arity 2,
because it takes in two things. To make tea you need some warm water, and you need
some tea leaves.
Example 6.92. Context-free grammars are to operads as graphs are to categories. Let’s
sketch what this means. First, a context-free grammar is a way of describing a particular
set of ‘syntactic categories’ that can be formed from a set of symbols. For example, in
English we have syntactic categories like nouns, determiners, adjectives, verbs, noun
phrases, prepositional phrases, sentences, etc. The symbols are words, e.g. cat, dog,
the, chases.
To deﬁne a context-free grammar on some alphabet, one speciﬁes some production
rules, which say how to form an entity in some syntactic category from a bunch of
entities in other syntactic categories. For example, we can form a noun phrase from
a determiner (the), an adjective (happy), and a noun (boy). Context free grammars
are important in both linguistics and computer science. In the former, they’re a basic
way to talk about the structure of sentences in natural languages. In the latter, they’re
crucial when designing parsers for programming languages.
So just like graphs present free categories, context-free grammars present free op-
erads. This idea was ﬁrst noticed in [HMP98].
6.5.2
Operads from symmetric monoidal categories
We will see in Deﬁnition 6.97 that a large class of operads come from symmetric
monoidal categories. Before we explain this, we give a couple of examples. Perhaps
the most important operad is that of Set.
Example 6.93. The operad Set of sets has
(i) Sets X as types.
(ii) Functions X1 × · · · × Xn →Y as operations of arity (X1, . . . , Xn; Y).

6.5. OPERADS AND THEIR ALGEBRAS
215
(iii) Substitution deﬁned by
(1 ◦i f )(x1, . . . , xi−1, w1, . . . , wm, xi+1, . . . , xn)
 1 x1, . . . , xi−1, f (w1, . . . , wm), xi+1, . . . , xn

where f ∈Set(W1, . . . , Wm; Xi), 1 ∈Set(X1, . . . , Xn; Y), and hence 1 ◦i f is a
function
(1 ◦i f ): X1 × · · · × Xi−1 × W1 × · · · × Wm × Xi+1 × · · · × Xn −→Y
(iv) Identities idX ∈Set(X; X) are given by the identity function idX : X →X.
Next we give an example that reminds us what all this operad stuﬀwas for: wiring
diagrams.
Example 6.94. The operad Cospan of ﬁnite-set cospans has
(i) Natural numbers a ∈N as types.
(ii) Cospans a1 + · · · + an →p ←b of ﬁnite sets as operations of arity (a1, . . . , an; b).
(iii) Substitution deﬁned by pushout.
(iv) Identities ida ∈Set(a; a) just given by the identity cospan a
ida
−−→a
ida
←−−a.
This is the operadic analogue of the monoidal category (CospanFinSet, 0, +).
We can depict operations in this operad using diagrams like we drew above. For
example, here’s a picture of an operation:
f
h
1
k
(6.95)
This is an operation of arity (3, 3, 4, 2; 3). Why? The circles marked f and 1 have 3
ports, h has 4 ports, k has 2 ports, and the outer circle has 3 ports: 3, 3, 4, 2; 3.
So how exactly is Eq. (6.95) a morphism in this operad? Well a morphism of this
arity is, by (ii), a cospan 3 + 3 + 4 + 2
a−→p
b←−3. In the diagram above, the apex p is the
set 7, because there are 7 nodes • in the diagram. The function a sends each port on
one of the small circles to the node it connects to, and the function b sends each port of
the outer circle to the node it connects to.
We are able to depict each operation in the operad Cospan as a wiring diagram.
It is often helpful to think of operads as describing a wiring diagram grammar. The

216
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
substitution operation of the operad signiﬁes inserting one wiring diagram into a circle
or box in another wiring diagram.
Exercise 6.96.
1. Consider the following cospan f ∈Cospan(2, 2; 2):
Draw it as a wiring diagram with two inner circles, each with two ports, and one
outer circle with two ports.
2. Draw the wiring diagram correspondingtothefollowingcospan 1 ∈Cospan(2, 2, 2; 0):

3. Compute the cospan 1 ◦1 f . What is its arity?
4. Draw the cospan 1 ◦1 f . Do you see it as substitution?
♦
We can turn any symmetric monoidal category into an operad in a way that gener-
alizes the above two examples.
Deﬁnition 6.97. For any symmetric monoidal category (C, I, ⊗), there is an operad OC,
called the operad underlying C, deﬁned as having:
(i) Ob(C) as types.
(ii) morphisms C1 ⊗· · · ⊗Cn →D in C as the operations of arity (C1, . . . , Cn; D).
(iii) substitution is deﬁned by
( f ◦i 1) B f ◦(id, . . . , id, 1, id, . . . , id)
(iv) identities ida ∈OC(a; a) deﬁned by ida.
We can also turn any monoidal functor into what’s called an operad functor.
6.5.3
The operad for hypergraph props
An operad functor takes the types of one operad to the types of another, and then the op-
erations of the ﬁrst to the operations of the second in a way that respects this.

6.5. OPERADS AND THEIR ALGEBRAS
217
Rough Deﬁnition 6.98. Suppose given two operads O and P with type collections T
and U respectively. To specify an operad functor F : O →P,
(i) one speciﬁes a function f : T →U.
(ii) For all arities (t1, . . . , tn; t) in O, one speciﬁes a function
F : O(t1, . . . , tn; t) →P( f (t1), . . . , f (tn); f (t))
such that composition and identities are preserved.
Just as set-valued functors C →Set from any category C are of particular interest—
we saw them as database instances in Chapter 3—so to are Set-valued functors O →Set
from any operad O.
Deﬁnition 6.99. An algebra for an operad O is an operad functor F : O →Set.
We can think of functors O →Set as deﬁning a set of possible ways to ﬁll the boxes in
a wiring diagram. Indeed, each box in a wiring diagram represents a type t of the given
operad O and an algebra F : O →Set will take a type t and return a set F(t) of ﬁllers
for box t. Moreover, given an operation (i.e., a wiring diagram) f ∈O(t1, . . . , tn; t), we
get a function F( f ) that takes an element of each set F(ti), and returns an element of
F(t). For example, it takes n circuits with interface t1, . . . , tn respectively, and returns
a circuit with boundary t.
Example 6.100. For electric circuits, the types are again ﬁnite sets, T  Ob(FinSet),
where each ﬁnite set t ∈T corresponds to a cell with t ports. Just as before, we have a
set Circ(t) of ﬁllers, namely the set of electric circuits with that t-marked terminals. As
an operad algebra, Circ: Cospan →Set transforms wiring diagrams like this one
ϕ B
into formulas that build a new circuit from a bunch of existing ones. In the above-
drawn case, we would get a morphism Circ(ϕ) ∈Set(Circ(2), Circ(2), Circ(2); Circ(0)),
i.e. a function
Circ(ϕ): Circ(2) × Circ(2) × Circ(2) →Circ(0).
We could apply this function to the three elements of Circ(2) shown here

218
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
and the result would be the closed circuit from the beginning of the chapter:
This is reminiscent of the story for decorated cospans: gluing ﬁllers together to form
hypergraph categories. An advantage of the decorated cospan construction is that one
obtains an explicit category (where morphisms have domains and codomains and can
hence be composed associatively), equipped with Frobenius structures that allow us to
get around the strictures of domains and codomains. The operad perspective has other
advantages.
First, whereas decorated cospans can produce only some hypergraph
categories, Cospan-algebras can produce any hypergraph category.
Proposition 6.101. There is an equivalence between Cospan-algebras and hypergraph
props.
Another advantage of using operads is that one can vary the operad itself, from
Cospan to something similar (like the operad of ‘cobordisms’), and get slightly diﬀerent
compositionality rules.
In fact, operads—with the additional complexity in their deﬁnition—can be cus-
tomized even more than all compositional structures deﬁned so far. For example, we
can deﬁne operads of wiring diagrams where the wiring diagrams must obey precise
conditions far more speciﬁc than the constraints of a category, such as requiring that
the diagram itself has no wires that pass straight through it. In fact, operads are strong
enough to deﬁne themselves: roughly speaking, there is an operad for operads: the
category of operads is equivalent to the category of algebras for a certain operad [Lei04,
Example 2.2.23]. While operads can, of course, be generalized again, they conclude
our march through an informal hierarchy of compositional structures, from preorders
to categories to monoidal categories to operads.
6.6
Summary and further reading
This chapter began with a detailed exposition of colimits in the category of sets; as we
saw, these colimits describe ways of joining or interconnecting sets. Our second way
of talking about interconnection was the use of Frobenius monoids and hypergraph
categories; we saw these two themes come together in the idea of a decorated cospans.
The decorated cospan construction uses a certain type of structured functor to construct
a certain type of structured category. More generally, we might be interested in other
types of structured category, or other compositional structure. To address this, we
brieﬂy saw how these ideas ﬁt into the theory of operads.

6.6. SUMMARY AND FURTHER READING
219
Colimits are a fundamental concept in category theory. For more on colimits, one
might refer to any of the introductory category theory textbooks we mentioned in
Section 3.6.
Special commutative Frobenius monoids and hypergraph categories were ﬁrst de-
ﬁned, under the names ‘separable commutative Frobenius algebra’ and ‘well-supported
compact closed category’, by Carboni and Walters [CW87; Car91]. The use of deco-
rated cospans to construct them is detailed in [Fon15; Fon18; Fon16]. The application
to networks of passive linear systems, such as certain electrical circuits, is discussed in
[BF15], while further applications, such as to Markov processes and chemistry can be
found in [BFP16; BP17]. For another interesting application of hypergraph categories,
we recommend the pixel array method for approximating solutions to nonlinear equa-
tions [Spi+16]. The story of this chapter is ﬂeshed out in a couple of recent, more
technical papers [FS18b; FS18a].
Operads were introduced by May to describe compositional structures arising in
algebraic topology [May72]; Leinster has written a great book on the subject [Lei04].
More recently, with collaborators author-David has discussed using operads in applied
mathematics, to model composition of structures in logic, databases, and dynamical
systems [RS13; Spi13; VSL15].


Chapter 7
Logic of behavior:
Sheaves, toposes, and internal
languages
7.1
How can we prove our machine is safe?
Imagine you are trying to design a system of interacting components. You wouldn’t be
doing this if you didn’t have a goal in mind: you want the system to do something, to
behave in a certain way. In other words, you want to restrict its possibilities to a smaller
set: you want the car to remain on the road, you want the temperature to remain in
a particular range, you want the bridge to be safe for trucks to pass. Out of all the
possibilities, your system should only permit some.
Since your system is made of components that interact in speciﬁed ways, the possible
behavior of the whole—in any environment—is determined by the possible behaviors
of each of its components in their local environments, together with the precise way in
which they interact.1 In this chapter, we will discuss a logic wherein one can describe
general types of behavior that occur over time, and prove properties of a larger-scale
system from the properties and interaction patterns of its components.
For example, suppose we want an autonomous vehicle to maintain a distance of
some safe ∈R from other objects. To do so, several components must interact: a
sensor that approximates the real distance by an internal variable S′, a controller that
uses S′ to decide what action A to take, and a motor that moves the vehicle with an
1 The well-known concept of emergence is not about possibilities, it is about prediction. Predicting
the behavior of a system given predictions of its components is notoriously hard. The behavior of a
double pendulum is chaotic—meaning extremely sensitive to initial conditions—whereas those of the two
component pendulums are not. However, the set of possibilities for the double pendulum is completely
understood: it is the set of possible angular positions and velocities of both arms. When we speak of a
machine’s properties in this chapter, we always mean the guarantees on its behaviors, not the probabilities
involved, though the latter would certainly be an interesting thing to contemplate.
221

222
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
acceleration based on A. This in turn aﬀects the real distance S, so there is a feedback
loop.
Consider the following model diagram:
sensor
controller
motor
S′
A
S
S
(7.1)
In the diagram shown, the distance S is exposed by the exterior interface. This just
means we imagine S as being a variable that other components of a larger system may
want to interact with. We could have exposed no variables (making it a closed system)
or we could have exposed A and/or S′ as well.
In order for the system to ensure S ≥safe, we need each of the components to
ensure a property of its own.
But what are these components, ‘sensor, controller,
motor’, and what do they do?
One way to think about any of the components is to open it up and see how it is
put together; with a detailed study we may be able to say what it will do. For example,
just as S was exposed in the diagram above, one could imagine opening up the ‘sensor’
component box in Eq. (7.1) and seeing an interaction between subcomponents
radar
sonar
processor
sensor
S
S′
This ability to zoom in and see a single unit as being composed of others is important
for design. But at the end of the day, you eventually need to stop diving down and
simply use the properties of the components in front of you to prove properties of
the composed system. Have no fear: everything we do in this chapter will be fully
compositional, i.e. compatible with opening up lower-level subsystems and using the
fractal-like nature of composition. However at a given time, your job is to design the
system at a given level, taking the component properties of lower-level systems as
given.
We will think of each component in terms of the relationship it maintains (through
time) between the changing values on its ports. “Whenever I see a ﬂash, I will increase
pressure on the button”: this is a relationship I maintain through time between the
changing values on my eye port and my ﬁnger port. We will make this more precise
soon, but ﬂeshing out the situation in Eq. (7.1) should help. The sensor maintains a
relationship between S and S′, e.g. that the real distance S and its internal representation
S′ diﬀer by no more than 5cm. The controller maintains a relationship between S′ and
the action signal A, e.g. that if at any time S < safe, then within one second it will

7.1. HOW CAN WE PROVE OUR MACHINE IS SAFE?
223
emit the signal A  go. The motor maintains a relationship between A and S, e.g. that
A dictates the second derivative of S by the formula
 (A  go) ⇒ÜS > 1
∧ (A  stop) ⇒ÜS  0
.
(7.2)
If we want to prove properties of the whole interacting system, then the relation-
ships maintained by each component need to be written in a formal logical language,
something like what we saw in Eq. (7.2). From that basis, we can use standard proof
techniques to combine properties of subsystems into properties of the whole. This is
our objective in the present chapter.
We have said how component systems, wired together in some arrangement, create
larger-scale systems. We have also said that, given the wiring arrangement, the be-
havioral properties of the component systems dictate the behavioral properties of the
whole. But what exactly are behavioral properties?
In this chapter, we want to give a formal language and semantics for a very gen-
eral notion of behavior. Mathematics is itself a formal language; the usual style of
mathematical modeling is to use any piece of this vast language at any time and for
any reason. One uses “human understanding” to ensure that the diﬀerent models
are ﬁtting together in an appropriate way when diﬀerent systems are combined. The
present work diﬀers in that we want to ﬁnd a domain-speciﬁc language for modeling
behavior, any sort of behavior, and nothing but behavior. Unlike in the wide world of
math, we want a setting where the only things that can be discussed are behaviors.
For this, we will construct what is called a topos, which is a special kind of category.
Our topos, let’s call it BT, will have behavior types—roughly speaking, sets whose
elements can change through time—as its objects. An amazing fact about toposes2 is
that they come with an internal language that looks very much like the usual formal
language of mathematics itself. Thus one can deﬁne graphs, groups, topological spaces,
etc. in any topos. But in BT, what we call graphs will actually be graphs that change
through time, and similarly what we call groups and spaces will actually be groups
and spaces that change through time.
The topos BT not only has an internal language, but also a mathematical semantics
using the notion of sheaves. Technically, a sheaf is a certain sort of functor, but one can
imagine it as a space of possibilities, varying in a controlled way; in our case it will be
a space of possible behaviors varying in a certain notion of time. Every property we
prove in our logic of behavior types will have meaning in this category of sheaves.
When discussing systems and components—such as sensors, controllers, motors,
etc.—we mentioned behavior types; these will be the objects in the topos BT. Every
wire in the picture below will stand for a behavior type, and every box X will stand for
a behavioral property, a relation that X maintains between the changing values on its
2The plural of topos is often written topoi, rather than toposes. This seems a bit fancy for our taste.
As Johnstone suggests in [Joh77], we might ask those who “persist in talking about topoi whether, when
they go out for a ramble on a cold day, they carry supplies of hot tea with them in thermoi.” It’s all in
good fun; either term is perfectly reasonable and well-accepted.

224
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
ports.
sensor
controller
motor
S′
A
A
S
For example we could imagine that
• S (wire): The behavior of S over a time-interval [a, b] is that of all continuous
real-valued functions [a, b] →R.
• A (wire): The behavior of A over a time-interval [a, b] is all piecewise constant
functions, taking values in the ﬁnite set such as {go, stop}.
• controller (box): the relation {(S′, A) | Eq. (7.2)}, i.e. all behavioral pairs (S′, A)
that conform to what we said our controller is supposed to do in Eq. (7.2).
7.2
The category Set as an exemplar topos
We want to think about a very abstract sort of thing, called a topos, because we will
see that behavior types form a topos. To get started, we begin with one of the easiest
toposes to think about, namely the topos Set of sets. In this section we will discuss
commonalities between sets and every other topos. We will go into some details about
the category of sets, so as to give intuition for other toposes. In particular, we’ll pay
careful attention to the logic of sets, because we eventually want to understand the
logic of behaviors.
Indeed, logic and sets are closely related. For example, the logical statement—more
formally known as a predicate—likes_cats deﬁnes a function from the set P of people
to the set B  {false, true} of truth values, where Brendan ∈P maps to true because
he likes cats whereas Ursula ∈P maps to false because she does not. Alternatively,
likes_cats also deﬁnes a subset of P, consisting of exactly the people that do like cats
{p ∈P | likes_cats(p)}.
In terms of these subsets, logical operations correspond to set operations, e.g. AND
corresponds to intersection: indeed, the set of people for (mapped to true by) the pred-
icate likes_cats_AND_likes_dogs is equal to the intersection of the set for likes_cats
and the set for likes_dogs.
We saw in Chapter 3 that such operations, which are examples of database queries,
can be described in terms of limits and colimits in Set. Indeed, the category Set has
many such structures and properties, which together make logic possible in that setting.
In this section we want to identify these properties, and show how logical operations
can be deﬁned using them.
Why would we want to abstractly ﬁnd such structures and properties? In the next
section, we’ll start our search for other categories that also have them. Such categories,
called toposes, will be Set-like enough to do logic, but have much more complex and

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
225
interesting semantics. Indeed, we will discuss one whose logic allows us to reason not
about properties of sets, but about behavioral properties of very general machines.
7.2.1
Set-like properties enjoyed by any topos
Although we will not prove it in this book, toposes are categories that are similar to
Set in many ways. Here are some facts that are true of any topos E:
1. E has all limits,
2. E has all colimits,
3. E is cartesian closed,
4. E has epi-mono factorizations,
5. E has a subobject classiﬁer 1
true
−−−→Ω.
In particular, since Set is a topos, all of the above facts are true for E  Set. Our ﬁrst
goal is to brieﬂy review these concepts, focusing most on the subobject classiﬁer.
Limits and colimits.
We discussed limits and colimits brieﬂy in Section 3.4.2, but
the basic idea is that one can make new objects from old by taking products, using
equations to deﬁne subobjects, forming disjoint unions, and taking quotients.object
0. One of the most important types of limit (resp. colimit) is that of pullbacks (resp.
pushouts); see Example 3.99 and Deﬁnition 6.19. For our work below, we’ll need to
know a touch more about pullbacks than we have discussed so far, so let’s begin there.
Suppose that C is a category and consider the diagrams below:
A
B
C
D
E
F
⌟
A
B
C
D
E
F
⌟
In the left-hand square, the corner symbol ⌟unambiguously means that the square
(B, C, E, F) is a pullback. But in the right-hand square, does the corner symbol mean
that (A, B, D, E) is a pullback or that (A, C, D, F) is a pullback? It’s ambiguous, but as
we next show, it becomes unambiguous if the right-hand square is a pullback.
Proposition 7.3. In the commutative diagram below, suppose that the (B, C, B′, C′)
square is a pullback:
A
B
C
A′
B′
C′
⌟
⌟
Then the (A, B, A′, B′) square is a pullback iﬀthe (A, C, A′, C′) rectangle is a pullback.
Exercise 7.4.
Prove Proposition 7.3 using the deﬁnition of limit from Section 3.4.2.
♦

226
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Epi-mono factorizations.
The abbreviation ‘epi’ stands for epimorphism, and the ab-
breviation ‘mono’ stands for monomorphism. Epimorphisms are maps that act like
surjections, and monomorphisms are maps that act like injections.3 We can deﬁne
them formally in terms of pushouts and pullbacks.
Deﬁnition 7.5. Let C be a category, and let f : A →B be a morphism. It is called a
monomorphism (resp. epimorphism) if the square to the left is a pullback (resp. the square
to the right is a pushout):
A
A
A
B
A
B
B
B
idA
idA
f
f
f
idB
f
⌟
idB
⌜
Exercise 7.6.
Show that in Set, monomorphisms are just injections:
1. Show that if f is a monomorphism then it is injective.
2. Show that if f : A →B is injective then it is a monomorphism.
♦
Exercise 7.7.
1. Show that the pullback of an isomorphism along any morphism is an isomor-
phism. That is, suppose that i : B′ →B is an isomorphism and f : A →B is any
morphism. Show that i′ is an isomorphism, in the following diagram:
A′
B′
A
B
f ′
i′ 
i

f
⌟
2. Show that for any map f : A →B, the square shown is a pullback:
A
B
A
B
f
f
⌟
♦
Exercise 7.8.
Suppose the following diagram is a pullback in a category C:
A′
A
B′
B
1
f ′
f
h
⌟
Use Proposition 7.3 and Exercise 7.7 to show that if f is a monomorphism, then so is
f ′.
♦
3 Surjections are sometimes called ‘onto’ and injections are sometimes called ‘one-to-one’, hence the
Greek preﬁxes epi and mono.

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
227
Now that we have deﬁned epimorphisms and monomorphisms, we can say what
epi-mono factorizations are. We say that a morphism f : C →D in E has an epi-mono
factorization if it has an ‘image’; that is, there is an object im( f ), an epimorphism
C ↠im( f ), and a monomorphism im( f ) ↣D, whose composite is f .
In Set, epimorphisms are surjections and monomorphisms are injections. Every
function f : C →D may be factored as a surjective function onto its image im( f ) 
{ f (c) | c ∈C}, followed by the inclusion of this image into the codomain D. Moreover,
this factorization is unique up to isomorphism.
Exercise 7.9.
Factor the following function f : 3 →3 as an epimorphism followed by a
monomorphism.
•
•
•
•
•
•
♦
This is the case in any topos E: for any morphism f : c →d, there exists an
epimorphism e and a monomorphism m such that f  (e # m) is their composite.
Cartesian closed.
A category C being cartesian closed means that C has a symmetric
monoidal structure given by products, and it is monoidal closed with respect to this.
(We previously saw monoidal closure in Deﬁnition 2.79 (for preorders) and Proposi-
tion 4.60, as a corollary of compact closure.) Slightly more down-to-earth, cartesian
closure means that for any two objects C, D ∈C, there is a ‘hom-object’ DC ∈C and a
natural isomorphism for any A ∈C:
C(A × C, D)  C(A, DC)
(7.10)
Think of it this way. Suppose you’re A and I’m C, and we’re interacting through
some game f (−, −): A × C →D: for whatever action a ∈A that you take and action
c ∈C that I take, f (a, c) is some value in D. Since you’re self-centered but loving, you
think of this situation as though you’re creating a game experience for me. When you
do a, you make a game f (a, −): C →D for me alone. In the formalism, DC represents
the set of games for me. So now you’ve transformed a two-player game, valued in D,
into a one-player game, you’re the player, valued in... one player games valued in D.
This transformation is invertible—you can switch your point of view at will—and it’s
called currying. This is the content of Example 3.72.
Exercise 7.11.
Let V  (V, ≤, I, ⊗) be a (unital, commutative) quantale—see Deﬁni-
tion 2.90—and suppose it satisﬁes the following for all v, w, x ∈V:
• v ≤I,
• v ⊗w ≤v and v ⊗w ≤w, and
• if x ≤v and x ≤w then x ≤v ⊗w.
1. Show that V is a cartesian closed category, in fact a cartesian closed preorder.
2. Can every cartesian closed preorder be obtained in this way?
♦

228
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Subobject classiﬁer.
The concept of a subobject classiﬁer requires more attention,
because its existence has huge consequences for a category C. In particular, it creates
the setting for a rich system of higher order logic to exist inside C; it does so by providing
some things called ‘truth values’. The higher order logic manifests in its fully glory
when C has ﬁnite limits and is cartesian closed, because these facts give rise to the
logical operations on truth values.4 In particular, the higher order logic exists in any
topos.
We will explain subobject classiﬁers in as much detail as we can; in fact, it will be
our subject for the rest of Section 7.2.
7.2.2
The subobject classiﬁer
Before giving the deﬁnition of subobject classiﬁers, recall that monomorphisms in Set
are injections, and any injection X ↣Y is isomorphic to a subset of Y. This gives
a simple and useful way to conceptualize monomorphisms into Y when reading the
following deﬁnition: it will do no harm to think of them as subobjects of Y.
Deﬁnition 7.12. Let E be a category with ﬁnite limits, i.e. with pullbacks and a ter-
minal object 1. A subobject classiﬁer in E consists of an object Ω∈E, together with a
monomorphism true: 1 →Ω, satisfying the following property: for any objects X and
Y and monomorphism m : X ↣Y in E, there is a unique morphism ⌜m⌝: Y →Ωsuch
that the diagram on the left of Eq. (7.13) is a pullback in E:
X
1
Y
Ω
!
m
true
⌜m⌝
⌟
{Y | p}
1
Y
Ω
!
true
p
⌟
(7.13)
We refer to ⌜m⌝as the characteristic map of m, or we say that ⌜m⌝classiﬁes m. Conversely,
given any map p : Y →Ω, we denote the pullback of true as on the right of Eq. (7.13).
A predicate on Y is a morphism Y →Ω.
Deﬁnition 7.12 is a bit diﬃcult to get one’s mind around, partly because it is hard
to imagine its consequences. It is like a superdense nugget from outer space, and
through scientiﬁc explorations in the latter half of the 20th century, we have found that
it brings super powers to whichever categories possess it. We will explain some of the
consequences below, but very quickly, the idea is the following.
When a category has a subobject classiﬁer, it provides a translator, turning subobjects
of any object Y into maps from that Y to the particular object Ω.
Pullback of the
4A category that has ﬁnite limits, is cartesian closed, and has a subobject classiﬁer is called an elementary
topos. We will not discuss these further, but they are the most general notion of topos in ordinary category
theory. When someone says topos, you might ask “Grothendieck topos or elementary topos?,” because
there does not seem to be widespread agreement on which is the default.

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
229
monomorphism true: 1 →Ωprovides a translator going back, turning maps Y →Ω
into subobjects of Y. We can replace our fantasy of the superdense nugget with a
slightly more reﬁned story: “any object Y understands itself—its parts and the logic of
how they ﬁt together—by asking questions of the oracle Ω, looking for what’s true.”
Or to fully be precise but dry, “subobjects of Y are classiﬁed by predicates on Y.”
Let’s move from stories and slogans to concrete facts.
The subobject classiﬁer in Set.
Since Set is a topos, it has a subobject classiﬁer. It
will be a set with supposedly wonderful properties; what set is it?
The subobject classiﬁer in Set is the set of booleans,
ΩSet B B  {true, false}.
(7.14)
So in Set, the truth values are true and false.
By deﬁnition (Def. 7.12), the subobject classiﬁer comes equipped with a morphism,
generically called true: 1 →Ω; in the case of Set it is played by the function 1 →
{true, false} that sends 1 to true. In other words, the morphism true is aptly named
in this case.
For sets, monomorphism just means injection, as we mentioned above. So Deﬁni-
tion 7.12 says that for any injective function m : X ↣Y between sets, we are supposed
to be able to ﬁnd a characteristic function ⌜m⌝: Y →{true, false} with some sort of
pullback property. We propose the following deﬁnition of ⌜m⌝:
⌜m⌝(y) B
(
true
if m(x)  y for some x ∈X
false
otherwise
In other words, if we think of X as a subobject of Y, then we make ⌜m⌝(y) equal to
true iﬀy ∈X.
In particular, the subobject classiﬁer property turns subsets X ⊆Y into functions
p : Y →B, and vice versa. How it works is encoded in Deﬁnition 7.12, but the basic
idea is that X will be the set of all things in Y that p sends to true:
X  {y ∈Y | p(y)  true}.
(7.15)
This might help explain our abstract notation {Y | p} in Eq. (7.13).
Exercise 7.16.
Let X  N  {0, 1, 2, . . .} and Y  Z  {. . . , −1, 0, 1, 2, . . .}; we have
X ⊆Y, so consider it as a monomorphism m : X ↣Y. It has a characteristic function
⌜m⌝: Y →B, as in Deﬁnition 7.12.
1. What is ⌜m⌝(−5) ∈B?
2. What is ⌜m⌝(0) ∈B?
♦
Exercise 7.17.
1. Consider the identity function idN : N →N. It is an injection, so it has a charac-
teristic function ⌜idN⌝: N →B. Give a concrete description of ⌜idN⌝, i.e. its exact
value for each natural number n ∈N.

230
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
2. Consider the unique function !N :  →N from the empty set. Give a concrete
description of ⌜!N⌝: N →B.
♦
7.2.3
Logic in the topos Set
As we said above, the subobject classiﬁer of any topos E gives the setting in which to
do logic. Before we explain a bit about how topos logic works in general, we continue
to work concretely by focusing on logic in the topos Set.
Obtaining the AND operation.
Consider the function 1 →B × B picking out the
element (true, true). This is a monomorphism, so it deﬁnes a characteristic function
⌜(true, true)⌝: B×B →B. What function is it? By Eq. (7.15) the only element of B×B
that can be sent to true is (true, true). Thus ⌜(true, true)⌝(P, Q) ∈B must be given
by the following truth table
P
Q
⌜(true, true)⌝(P, Q)
true
true
true
true
false
false
false
true
false
false
false
false
This is exactly the truth table for the AND of P and Q, i.e. for P ∧Q. In other words,
⌜(true, true)⌝ ∧. Note that this deﬁnes ∧as a function ∧: B × B →B, and we use
the usual inﬁx notation x ∧y B ∧(x, y).
Obtaining the OR operation.
Let’s go backwards this time. The truth table for the
OR of P and Q, i.e. that of the function ∨: B × B →B deﬁning OR, is:
P
Q
P ∨Q
true
true
true
true
false
true
false
true
true
false
false
false
(7.18)
If we wanted to obtain this function as the characteristic function ⌜m⌝of some subset
m : X ⊆B × B, what subset would X be? By Eq. (7.15), X should be the set of y ∈Y
that are sent to true. Thus m is the characteristic map for the three element subset
X  {(true, true), (true, false), (false, true)} ⊆B × B.
To prepare for later generalization of this idea in any topos, we want a way of thinking
of X only in terms of properties listed at the beginning of Section 7.2.1. In fact, one can
think of X as the union of {true} × B and B × {true}—a colimit of limits involving the
subobject classiﬁer and terminal object. This description will construct an analogous
subobject of Ω× Ω, and hence classify a map Ω× Ω→Ω, in any topos E.

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
231
Exercise 7.19.
Every boolean has a negation, ¬false  true and ¬true  false. The
function ¬: B →B is the characteristic function of some thing, (*?*).
1. What sort of thing should (*?*) be? For example, should ¬ be the characteristic
function of an object? A topos? A morphism? A subobject? A pullback diagram?
2. Now that you know the sort of thing (*?*) is, which thing of that sort is it?
♦
Exercise 7.20.
Given two booleans P, Q, deﬁne P ⇒Q to mean P  (P ∧Q).
1. Write down the truth table for the statement P  (P ∧Q):
P
Q
P ∧Q
P  (P ∧Q)
true
true
?
?
true
false
?
?
false
true
?
?
false
false
?
?
2. If you already have an idea what P ⇒Q should mean, does it agree with the last
column of table above?
3. What is the characteristic function m : B × B →B for P ⇒Q?
4. What subobject does m classify?
♦
Exercise 7.21.
Consider the sets E B {n ∈N | n is even}, P B {n ∈N | n is prime},
and T B {n ∈N | n ≥10}. Each is a subset of N, so deﬁnes a function N →B.
1. What is ⌜E⌝(17)?
2. What is ⌜P⌝(17)?
3. What is ⌜T⌝(17)?
4. Name the smallest three elements in the set classiﬁed by (⌜E⌝∧⌜P⌝) ∨⌜T⌝.
♦
Review.
Let’s take stock of where we are and where we’re going. In Section 7.1, we
set out our goal of proving properties about behavior, and we said that topos theory
is a good mathematical setting for doing that. We are now at the end of Section 7.2,
which was about Set as an examplar topos. What happened?
In Section 7.2.1, we talked about properties of Set that are enjoyed by any topos:
limits and colimits, cartesian closure, epi-mono factorizations, and subobject classiﬁers.
Then in Section 7.2.2 we launched into thinking about the subobject classiﬁer in general
and in the speciﬁc topos Set, where it is the set B of booleans because any subset of
Y is classiﬁed by a speciﬁc predicate p : Y →B. Finally, in Section 7.2.3 we discussed
how to understand logic in terms of Ω: there are various maps ∧, ∨, ⇒: Ω× Ω→Ω
and ¬: Ω→Ωetc., which serve as logical connectives. These are operations on truth
values.
We have talked a lot about toposes, but we’ve only seen one so far: the category of
sets. But we’ve actually seen more without knowing it: the category C-Inst of instances
on any database schema from Deﬁnition 3.60 is a topos. Such toposes are called presheaf
toposes and are fundamental, but we will focus on sheaf toposes, because our topos of
behavior types will be a sheaf topos.

232
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Sheaves are fascinating, but highly abstract mathematical objects. They are not for
the faint of mathematical heart (those who are faint of physical heart are welcome to
proceed).
7.3
Sheaves
Sheaf theory began before category theory, e.g. in the form of something called “local
coeﬃcient systems for homology groups.” However its modern formulation in terms
of functors and sites is due to Grothendieck, who also invented toposes.
The basic idea is that rather than study spaces, we should study what happens on
spaces. A space is merely the ‘site’ at which things happen. For example, if we think
of the plane R2 as a space, we might examine only points and regions in it. But if we
think of R2 as a site where things happen, then we might think of things like weather
systems throughout the plane, or sand dunes, or trajectories and ﬂows of material.
There are many sorts of things that can happen on a space, and these are the sheaves:
a sheaf on a space is roughly “a sort of thing that can happen on the space.” If we want
to think about points or regions from the sheaf perspective, we would consider them
as diﬀerent points of view on what’s happening. That is, it’s all about what happens
on a space: the parts of the space are just perspectives from which to watch the show.
This is reminiscent of databases. The schema of a database is not the interesting
part; the data is what’s interesting. To be clear, the schema of a database is a site—it’s
acting like the space—and the category of all instances on it is a topos. In general, we
can think of any small category C as a site; the corresponding topos is the category of
functors Cop →Set.5 Such functors are called presheaves on C.
Did you notice that we just introduced a huge class of toposes? For any category C,
we said there is a topos of presheaves on it. So before we go on to sheaves, let’s discuss
this preliminary topic of presheaves. We will begin to develop some terminology and
ways of thinking that will later generalize to sheaves.
7.3.1
Presheaves
Recall the deﬁnition of functor and natural transformation from Section 3.3. Presheaves
are just functors, but they have special terminology that leads us to think about them
in a certain geometric way.
Deﬁnition 7.22. Let C be a small category. A presheaf P on C is a functor P : Cop →Set.
To each object c ∈C, we refer to the set P(c) as the set of sections of P over c. To each
morphism f : c′ →c, we refer to the function P( f ): P(c) →P(c′) as the restriction map
along f . For any section s ∈P(c), we may denote P( f )(s) ∈P(c′), i.e. its restriction
along f , by s

f .
5The category of functors C →Set is also a topos: use Cop as the deﬁning site.

7.3. SHEAVES
233
If P and Q are presheaves, a morphism α: P →Q between them is a natural trans-
formation of functors
Cop
Set.
P
Q
α
Example 7.23. Let ArShp be the category shown below:
ArShp B
Vertex
•
Pure Arrow
•
src
tgt
The reason we call our category ArShp is that we can imagine of it as an ‘arrow shape.’
Pure ArrowB
VertexB
src
tgt
(7.24)
A presheaf on ArShp is a functor I : ArShpop →Set, which is a database instance on
ArShpop. Note that ArShpop is what we called Gr in Section 3.3.5; there we showed
that database instances on Gr—i.e. presheaves on ArShp— are just directed graphs,
e.g.
P B
•
•
•
•
•
•
•
•
: ArShpop →Set
Thinking of presheaves on any category C, it often makes sense to imagine the
objects of C as shapes of some sort, and the morphisms of C as continuous maps
between shapes, just like we did for the arrow shape in Eq. (7.24). In that context, one
can think of a presheaf P as a kind of lego construction: P is built out of the shapes in C,
connected together using the morphisms in C. In the case where C is the arrow shape,
a presheaf is a graph. So this would say that a graph is a sort of lego construction,
built out of vertices and arrows connected together using the inclusion of a vertex as
the source or target of an arrow. Can you see it?
This statement can be made pretty precise; though we cannot go through it here, the
above lego idea is summarized by the formal statement that “the category of presheaves
on C is the free colimit completion of C.” Ask a friendly neighborhood category theorist
for details.
However one thinks of presheaves—intermsoflegoassembliesordatabaseinstances—
they’re relatively straightforward. The diﬀerence between presheaves and sheaves is

234
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
that sheaves take into account some sort of ‘covering information.’ The trivial notion
of covering is to say that every object covers itself and nothing more; if one uses this
trivial covering, presheaves and sheaves are the same thing. In our behavioral context
we will need a non-trivial notion of covering, so sheaves and presheaves will be slightly
diﬀerent. Our next goal is to understand sheaves on a topological space.
7.3.2
Topological spaces
We said in Section 7.3 that, rather than study spaces, we consider spaces as mere ‘sites’
on which things happen. We also said the things that can happen on a space are called
sheaves, and always form a type of category called a topos. To deﬁne a topos of sheaves,
we must start with the site on which they exist.
Sites are very abstract mathematical objects, and we will not make them precise in
this book. However, one of the easiest sorts of sites to think about are those coming
from topological spaces: every topological space naturally has the structure of a site.
We’ve talked about spaces for a while without making them precise; let’s do so now.
Deﬁnition 7.25. Let X be a set, and let P(X)  {U ⊆X} denote its set of subsets. A
topology on X is a subset Op ⊆P(X), elements of which we call open sets,6 satisfying the
following conditions:
(a) Whole set: the subset X ⊆X is open, i.e. X ∈Op.
(b) Binary intersections: if U, V ∈Op then (U ∩V) ∈Op.
(c) Arbitrary unions: if I is a set and if we are given an open set Ui ∈Op for each i,
then their union is also open,   Ð
i∈I Ui

∈Op. We interpret the particular case
where I   to mean that the empty set is open:  ∈Op.
If U  Ð
i∈I Ui, we say that (Ui)i∈I covers U.
A pair (X, Op), where X is a set and Op is a topology on X, is called a topological
space.
A continuous function between topological spaces (X, OpX) and (Y, OpY) is a function
f : X →Y such that for every U ∈OpY, the preimage f −1(U) is in OpX.
At the very end of Section 7.3.1 we mentioned how sheaves diﬀer from presheaves
in that they take into account ‘covering information.’ The notion of covering an open
set by a union of other open sets was deﬁned in Deﬁnition 7.25, and it will come into
play when we deﬁne sheaves in Deﬁnition 7.35.
Example 7.26. The usual topology Op on R2 is based on ‘ϵ-balls.’ For any ϵ ∈R with
ϵ > 0, and any point p  (x, y) ∈R2, deﬁne the ϵ-ball centered at p to be:
B(p; ϵ) B {p′ ∈R2 | d(p, p′) < ϵ}7
6In other words, we refer to a subset U ⊆X as open if U ∈Op.

7.3. SHEAVES
235
In other words, B(x, y; ϵ) is the set of all points within ϵ of (x, y).
For an arbitrary subset U ⊆R2, we call it open and put it in Op if, for every (x, y) ∈U
there exists a (small enough) ϵ > 0 such that B(x, y; ϵ) ⊆U.
x
y
(x, y)
ϵ
an ϵ-ball centered at p  (x, y)
U
an open set U ⊆R2, a point p  (x, y) ∈U,
and an ϵ-ball B(x, y; ϵ) ⊆U.
The same idea works if we replace R2 with any other metric space X (Deﬁnition 2.51):
it can be considered as a topological space where the open sets are subsets U such that
for any p ∈U there is an ϵ-ball centered at p and contained in U. So every metric space
can be considered as a topological space.
Exercise 7.27.
Consider the set R. It is a metric space with d(x1, x2) B |x1 −x2|.
1. What is the 1-dimensional analogue of ϵ-balls as found in Example 7.26? That is,
for each x ∈R, deﬁne B(x, ϵ).
2. When is an arbitrary subset U ⊆R called open, in analogy with Example 7.26?
3. Find three open sets U1, U2, and U in R, such that (Ui)i∈{1,2} covers U.
4. Find an open set U and a collection (Ui)i∈I of opens sets where I is inﬁnite, such
that (Ui)i∈I covers U.
♦
Example 7.28. For any set X, there is a ‘coarsest’ topology, having as few open sets as
possible: Opcrse  (, X). There is also a ‘ﬁnest’ topology, having as many open sets as
possible: Opﬁne  P(X). The latter, (X, P(X)) is called the discrete space on the set X.
Exercise 7.29.
1. Verify that for any set X, what we called Opcrse in Example 7.28 really is a topology,
i.e. satisﬁes the conditions of Deﬁnition 7.25.
2. Verify also that Opﬁne really is a topology.
3. Show that if (X, P(X)) is discrete and (Y, OpY) is any topological space, then every
function X →Y is continuous.
♦
Example 7.30. There are four topologies possible on X  {1, 2}. Two are Opcrse and
7Here, d((x, y), (x′, y′)) B
p
(x −x′)2 + (y −y′)2 is the usual ‘Euclidean distance’ between two points.
One can generalize d to any metric.

236
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Opﬁne from Example 7.28. The other two are:
Op1 B {, {1}, X}
and
Op2 B {, {2}, X}
The two topological spaces ({1, 2}, Op1) and ({1, 2}, Op2) are isomorphic; either one
can be called the Sierpinski space.
The open sets of a topological space form a preorder.
Given a topological space
(X, Op), the set Op has the structure of a preorder using the subset relation, (Op, ⊆).
It is reﬂexive because U ⊆U for any U ∈Op, and it is transitive because if U ⊆V and
V ⊆W then U ⊆W.
Recall from Section 3.2.3 that we can regard any preorder, and hence Op, as a
category: its objects are the open sets U and for any U, V the set of morphisms Op(U, V)
is empty if U ̸⊆V and it has one element if U ⊆V.
Exercise 7.31.
Recall the Sierpinski space, say (X, Op1) from Example 7.30.
1. Write down the Hasse diagram for its preorder of opens.
2. Write down all the covers.
♦
Exercise 7.32.
Given any topological space (X, Op), any subset Y ⊆X can be given the
subspace topology, call it Op?∩Y. This topology deﬁnes any A ⊆Y to be open, A ∈Op?∩Y,
if there is an open set B ∈Op such that A  B ∩Y.
1. Find a B ∈Op that shows that the whole set Y is open, i.e. Y ∈Op?∩Y.
2. Show that Op?∩Y is a topology in the sense of Deﬁnition 7.25.8
3. Show that the inclusion function Y ,→X is a continuous function.
♦
Remark 7.33. Suppose (X, Op) is a topological space, and consider the preorder (Op, ⊆)
of open sets.
It turns out that (Op, ⊆, X, ∩) is always a quantale in the sense of
Deﬁnition 2.79. We will not need this fact, but we invite the reader to think about
it a bit in Exercise 7.34.
Exercise 7.34.
In Sections 2.3.2 and 2.3.3 we discussed how Bool-categories are pre-
orders and Cost-categories are Lawvere metric spaces, and in Section 2.3.4 we imagined
interpretations of V-categories for other quantales V.
If (X, Op) is a topological space and V the corresponding quantale as in Remark 7.33,
how might we imagine a V-category?
♦
7.3.3
Sheaves on topological spaces
To summarize where we are, a topological space (X, Op) is a set X together with a bunch
of subsets we call ‘open’; these open subsets form a preorder—and hence category—
denoted Op. Sheaves on X will be presheaves on Op with a special property, aptly
named the ‘sheaf condition.’
8Hint 1: for any set I, collection of sets (Ui)i∈I with Ui ⊆X, and set V ⊆X, one has (Ð
i∈I Ui) ∩V 
Ð
i∈I(Ui ∩V). Hint 2: for any U, V, W ⊆X, one has (U ∩W) ∩(V ∩W)  (U ∩V) ∩W.

7.3. SHEAVES
237
Recall the terminology and notation for presheaves: a presheaf on Op is a functor
P : Opop →Set. Thus to every open set U ∈Op we have a set P(U), called the set
of sections over U, and to every inclusion of open sets V ⊆U we have a function
P(U) →P(V) called the restriction. If s ∈P(U) is a section over U, we may denote its
restriction to V by s

V. Recall that we say a collection of open sets (Ui)i∈I covers an open
set U if U  Ð
i∈I Ui.
We are now ready to give the following deﬁnition, which comes in several waves:
we ﬁrst deﬁne matching families, then gluing, then sheaf condition, then sheaf, and
ﬁnally the category of sheaves.
Deﬁnition 7.35. Let (X, Op) be a topological space, and let P : Opop →Set be a
presheaf on Op.
Let (Ui)i∈I be a collection of open sets Ui ∈Op covering U. A matching family (si)i∈I
of P-sections over (Ui)i∈I consists of a section si ∈P(Ui) for each i ∈I, such that for every
i, j ∈I we have
si

Ui∩Uj  sj

Ui∩Uj.
Given a matching family (si)i∈I for the cover U  Ð
i∈I Ui, we say that s ∈P(U) is a
gluing, or glued section, of the matching family if s

Ui  si holds for all i ∈I.
If there exists a unique gluing s ∈P(U) for every matching family (si)i∈I, we say that
P satisﬁes the sheaf condition for the cover U  Ð
i∈I Ui. If P satisﬁes the sheaf condition
for every cover, we say that P is a sheaf on (X, Op).
Thus a sheaf is just a presheaf satisfying the sheaf condition for every open cover.
If P and Q are sheaves, then a morphism f : P →Q between these sheaves is just a
morphism—that is, a natural transformation—between their underlying presheaves.
We denote by Shv(X, Op) the category of sheaves on X.
The category of sheaves on X is a topos, but we’ll get to that.
Example 7.36. Here is a funny—but very important—special case to which the notion
of matching family applies. We do not give this example for intuition, but because (to
emphasize) it’s an important and easy-to-miss case. Just like the sum of no numbers
is 0 and the product of no numbers is 1, the union of no sets is the empty set. Thus if
we take U   ⊆X and I  , then the empty collection of subsets (one for each i ∈I,
of which there are none) covers U. In this case the empty tuple () counts a matching
family of sections, and it is the only matching family for the empty cover of the empty
set.
In other words, in order for a presheaf P : Opop →Set to be a sheaf, a necessary (but
rarely suﬃcient) condition is that P()  {()}, i.e. P() must be a set with one element.
Extended example: sections of a function.
This example is for intuition, and gives a
case where the ‘section’ and ‘restriction’ terminology are easy to visualize.

238
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Consider the function f : X →Y shown below, where each element of X is sent to
the element of Y immediately below it. For example, f (a1)  f (a2)  a, f (b1)  b, and
so on.
•
a
•
b
•
c
•
d
•
e
Y B
•
a1
•
a2
•
b1
•
b2
•
b3
•
c1
•
e1
•
e2
X B
f
(7.37)
For each point y ∈Y, the preimage set f −1(y) ⊆X above it is often called the ﬁber over
y. Note that diﬀerent f ’s would arrange the eight elements of X diﬀerently over Y:
elements of Y would have diﬀerent ﬁbers.
Exercise 7.38.
Consider the function f : X →Y shown in Eq. (7.37).
1. What is the ﬁber of f over a?
2. What is the ﬁber of f over c?
3. What is the ﬁber of f over d?
4. Gave an example of a function f ′: X →Y for which every ﬁber has either one or
two elements.
♦
Let’s consider X and Y as discrete topological spaces, so every subset is open, and
f is automatically continuous (see Exercise 7.29). We will think of f as an arrangement
of X over Y, in terms of ﬁbers as above, and use it to build a sheaf on Y. To do this,
we begin by building a presheaf—i.e. a functor Sec f : Op(Y)op →Set—and then we’ll
prove it’s a sheaf.
Deﬁne the presheaf Sec f on an arbitrary subset U ⊆Y by:
Sec f (U) B {s : U →X | (s # f )(u)  u for all u ∈U}.
One might describe Sec f (U) as the set of all ways to pick a ‘cross-section’ of the f
arrangement over U. That is, an element s ∈Sec f (U) is a choice of one element per
ﬁber over U.
As an example, let’s say U  {a, b}. How many such s’s are there in Sec f (U)? To

7.3. SHEAVES
239
answer this, let’s clip the picture (7.37) and look only at the relevant part:
•a
•b
•
•
•
•
•
s1
•a
•b
•
•
•
•
•
s2
•a
•b
•
•
•
•
•
s3
•a
•b
•
•
•
•
•
s4
•a
•b
•
•
•
•
•
s5
•a
•b
•
•
•
•
•
s6
(7.39)
Looking at the picture (7.39), do you see how we get all cross-sections of f over U?
Exercise 7.40.
Refer to Eq. (7.37).
1. Let V1  {a, b, c}. Draw all the sections over it, i.e. all elements of Sec f (V1), as
we did in Eq. (7.39).
2. Let V2  {a, b, c, d}. Again draw all the sections, Sec f (V2).
3. Let V3  {a, b, d, e}. How many sections (elements of Sec f (V3)) are there?
♦
By now you should understand the sections of Sec f (U) for various U ⊆X. This is
Sec f on objects, so you are half way to understanding Sec f as a presheaf. That is, as
a presheaf, Sec f also includes a restriction maps for every subset V ⊆U. Luckily, the
restriction maps are easy: if V ⊆U, say V  {a} and U  {a, b}, then given a section s
as in Eq. (7.39), we get a section over V by ‘restricting’ our attention to what s does on
{a}.
•a
•
•
•a
•
•
s1

V  s2

V  s3

V
s4

V  s5

V  s6

V
(7.41)
Exercise 7.42.
1. Write out the sets of sections Sec f ({a, b, c}) and Sec f ({a, c}).
2. Draw lines from the ﬁrst to the second to indicate the restriction map.
♦
Now we have understood Sec f as a presheaf; we next explain how to see that it
is a sheaf, i.e. that it satisﬁes the sheaf condition for every cover. To understand the
sheaf condition, consider the set U1  {a, b} and U2  {b, e}. These cover the set
U  {a, b, e}  U1 ∪U2. By Deﬁnition 7.35, a matching family for this cover consists of
a section over U1 and a section over U2 that agree on the overlap set, U1 ∩U2  {b}.

240
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
So consider s1 ∈Sec f (U1) and s2 ∈Sec f (U2) shown below.
•
a
•
b
•
a1
•
a2
•
b1
•
b2
•
b3
11
•
b
•
e
•
b1
•
b2
•
b3
•
e1
•
e2
12
(7.43)
Since sections 11 and 12 agree on the overlap—they both send b to b2—the two sections
shown in Eq. (7.43) can be glued to form a single section over U  {a, b, e}:
•
a
•
b
•
e
•
a1
•
a2
•
b1
•
b2
•
b3
•
e1
•
e2
glued section
Exercise 7.44.
Again let U1  {a, b} and U2  {b, e}, so the overlap is U1 ∩U2  {b}.
1. Find a section s1 ∈Sec f (U1) and a section s2 ∈Sec f (U2) that do not agree on the
overlap.
2. For your answer (s1, s2) in part 1, can you ﬁnd a section s ∈Sec f (U1 ∪U2) such
that s

U1  s1 and s

U2  s2?
3. Find a section h1 ∈Sec f (U1) and a section h2 ∈Sec f (U2) that do agree on the
overlap, but which are diﬀerent than our choice in Eq. (7.43).
4. Can you ﬁnd a section h ∈Sec f (U1 ∪U2) such that h

U1  h1 and h

U2  h2?
♦
Other examples of sheaves.
The extended example above generalizes to any contin-
uous function f : X →Y between topological spaces.
Example 7.45. Let f : (X, OpX) →(Y, OpY) be a continuous function. Consider the
functor Sec f : Opop
Y →Set given by
Sec f (U) B {1 : U →X | 1 is continuous and (1 # f )(u)  u for all u ∈U},

7.3. SHEAVES
241
The morphisms of OpY are inclusions V ⊆U. Given 1 : U →X and V ⊆U, what we
call the restriction of 1 to V is the usual thing we mean by restriction, the same as it
was in Eq. (7.41). One can again check that Sec f is a sheaf.
Example 7.46. A nice example of a sheaf on a space M is that of vector ﬁelds on M. If
you calculate the wind velocity at every point on Earth, you will have what’s called a
vector ﬁeld on Earth. If you know the wind velocity at every point in Afghanistan and
I know the wind velocity at every point in Pakistan, and our calculations agree around
the border, then we can glue our information together to get the wind velocity over the
union of the two countries. All possible wind velocity ﬁelds over all possible open sets
of the Earth’s surface together form the sheaf of vector ﬁelds.
Let’s say this a bit more formally. A manifold M—you can just imagine a sphere
such as the Earth’s surface—always has something called a tangent bundle. It is a
space TM whose points are pairs (m, v), where m ∈M is a point in the manifold and
v is a tangent vector emanating from it. Here’s a picture of one tangent plane—all the
tangent vectors emanating from some ﬁxed point—on a sphere:
m
v
M B
⊆TM
The tangent bundle TM includes the whole tangent plane shown above—including
the three vectors drawn on it—as well as the tangent plane at every other point on the
sphere.
The tangent bundle TM on a manifold M comes with a continuous map π: TM →
M back down to the manifold, sending (m, v) 7→m. One might say that π “forgets the
tangent vector and just remembers the point it emanated from.” By Example 7.45, π
deﬁnes a sheaf Secπ. It could be called the sheaf of ‘tangent vector sections on M’, but
its usual name is the sheaf of vector ﬁelds on M. This is what we were describing when
we spoke of the sheaf of wind velocities on Earth, above. Given an open subset U ⊆M,
an element v ∈Secπ(U) is called a vector ﬁeld over U because it continuously assigns
a tangent vector v(u) to each point u ∈U. The tangent vector at u tells us the velocity
of the wind at that point.
Here’s a fun digression: in the case of a spherical manifold M like the Earth, it’s
possible to prove that for every open set U, as long as U , M, there is a vector ﬁeld

242
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
v ∈Secπ(U) that is never 0: the wind could be blowing throughout U. However, a
theorem of Poincaré says that if you look at the whole sphere, there is guaranteed to be
a point m ∈M at which the wind is not blowing at all. It’s like the eye of a hurricane or
perhaps a cowlick. A cowlick in someone’s hair occurs when the hair has no direction
to go, so it sticks up! Hair sticking up would not count as a tangent vector: tangent
vectors must start out lying ﬂat along the head. Poincaré proved that if your head
was covered completely with inch-long hair, there would be at least one cowlick. This
diﬀerence between local sections (over arbitrary U ⊆X) and global sections (over X)—
namely that hair can be well combed whenever U , X but cannot be well combed when
U  X—can be thought of as a generative eﬀect, and can be measured by cohomology
(see Section 1.5).
Exercise 7.47.
If M is a sphere as in Example 7.46, we know from Deﬁnition 7.35 that
we can consider the category Shv(M) of sheaves on M; in fact, such categories are
toposes and these are what we’re getting to.
But are the sheaves on M the vector ﬁelds? That is, is there a one-to-one corre-
spondence between sheaves on M and vector ﬁelds on M? If so, why? If not, how are
sheaves on M and vector ﬁelds on M related?
♦
Example 7.48. For every topological space (X, Op), we have the topos of sheaves on it.
The topos of sets, which one can regard as the story of set theory, is the category of
sheaves on the one-point space {∗}. In topos theory, we see the category of sets—an
huge, amazing, and rich category—as corresponding to a single point. Imagine how
much more complex arbitrary toposes are, when they can take place on much more
interesting topological spaces (and in fact even more general ‘sites’).
Exercise 7.49.
Consider the Sierpinski space ({1, 2}, Op1) from Example 7.30.
1. What is the category Op for this space? (You may have already ﬁgured this out
in Exercise 7.31; if not, do so now.)
2. What does a presheaf on Op consist of?
3. What is the sheaf condition for Op?
4. How do we identify a sheaf on Op with a function?
♦
7.4
Toposes
A topos is deﬁned to be a category of sheaves.9 So for any topological space (X, Op),
the category Shv(X, Op) deﬁned in Deﬁnition 7.35 is a topos. In particular, taking the
one-point space X  1 with its unique topology, we ﬁnd that the category Set is a topos,
as we’ve been saying all along and saw again explicitly in Example 7.48. And for any
9This is sometimes called a sheaf topos or a Grothendieck topos. There is a more general sort of topos
called an elementary topos due to Lawvere.

7.4. TOPOSES
243
database schema—i.e. ﬁnitely presented category—C, the category C-Inst of database
instances on C is also a topos.10 Toposes encompass both of these sources of examples,
and many more.
Toposes are incredibly nice structures, for a variety of seemingly disparate reasons.
In this sketch, the reason in focus is that every topos has many of the same structural
properties that the category Set has. Indeed, we discussed in Section 7.2.1 that every
topos has limits and colimits, is cartesian closed, has epi-mono factorizations, and has
a subobject classiﬁer (see Section 7.2.2). Using these properties, one can do logic with
semantics in the topos E. We explained this for sets, but now imagine it for sheaves on a
topological space. There, the same logical symbols ∧, ∨, ¬, ⇒, ∃, ∀become operations
that mean something about sub-sheaves—e.g. vector ﬁelds, sections of continuous
functions, etc.—not just subsets.
To understand this more deeply, weshouldsaywhatthesubobjectclassiﬁertrue: 1 →
Ωis in more generality. We said that, in the topos Set, the subobject classiﬁer is the set
of booleans Ω B. In a sheaf topos E  Shv(X, Op), the object Ω∈E is a sheaf, not
just a set. What sheaf is it?
7.4.1
The subobject classiﬁer Ωin a sheaf topos
In this subsection we aim to understand the subobject classiﬁer Ω, i.e. the object of
truth values, in the sheaf topos Shv(X, Op). Since Ωis a sheaf, let’s understand it
by going through the deﬁnition of sheaf (Deﬁnition 7.35) slowly in this case. A sheaf
Ωis a presheaf that satisﬁes the sheaf condition. As a presheaf it is just a functor
Ω: Opop →Set; it assigns a set Ω(U) to each open U ⊆X and comes with a restriction
map Ω(U) →Ω(V) whenever V ⊆U. So in our quest to understand Ω, we ﬁrst ask the
question: what presheaf is it?
The answer to our question is that Ωis the presheaf that assigns to U ∈Op the set
of open subsets of U:
Ω(U) B {U′ ∈Op | U′ ⊆U}.
(7.50)
That was easy, right? And given the restriction map for V ⊆U is given by
Ω(U) →Ω(V)
(7.51)
U′ 7→U′ ∩V.
One can check that this is functorial—see Exercise 7.53—and after doing so we will still
need to see that it satisﬁes the sheaf condition. But at least we don’t have to struggle to
understand Ω: it’s a lot like Op itself.
10We said that a topos is a category of sheaves, yet database instances are presheaves; so how is C-Inst
a topos? Well, presheaves in fact count as sheaves. We apologize that this couldn’t be clearer. All of this
could be made formal if we were to introduce sites. Unfortunately, that concept is simply too abstract for
the scope of this chapter.

244
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Exercise 7.52.
Let X  {1} be the one point space. We said above that its subobject
classiﬁer is the set B of booleans, but how does that align with the deﬁnition of Ωgiven
in Eq. (7.50)?
♦
Exercise 7.53.
1. Show that the deﬁnition of Ωgiven above in Eqs. (7.50) and (7.51) is functorial, i.e.,
that whenever W ⊆V ⊆U, the restriction map Ω(U) →Ω(V) followed by the
restriction map Ω(V) →Ω(W) is the same as the restriction map Ω(U) →Ω(W).
2. Is that all that’s necessary to conclude that Ωis a presheaf?
♦
To see that Ωas deﬁned in Eq. (7.50) satisﬁes the sheaf condition (see Deﬁnition 7.35),
suppose that we have a cover U  Ð
i∈I Ui, and suppose given an element Vi ∈Ω(Ui),
i.e. an open set Vi ⊆Ui, for each i ∈I. Suppose further that for all i, j ∈I, it is the
case that Vi ∩Uj  Vj ∩Ui, i.e. that the elements form a matching family. Deﬁne
V B Ð
i∈I Vi; it is an open subset of U, so we can consider V as an element of Ω(U).
The following veriﬁes that V is indeed a gluing for the (Vi)i∈I:
V ∩Uj 
 Ø
i∈I
Vi
!
∩Uj 
Ø
i∈I
(Vi ∩Uj) 
Ø
i∈I
(Vj ∩Ui) 
 Ø
i∈I
Ui
!
∩Vj  Vj
In other words V ∩Uj  Vj for any j ∈I. So our Ωhas been upgraded from presheaf
to sheaf!
The eagle-eyed reader will have noticed that we haven’t yet given all the data
needed to deﬁne a subobject classiﬁer. To turn the object Ωinto a subobject classiﬁer
in good standing, we also need to give a sheaf morphism true: {1} →Ω.
Here
{1}: Opop →Set is the terminal sheaf; it maps every open set to the terminal, one
element set {1}. The correct morphism true: {1} →Ωfor the subobject classiﬁer is
the sheaf morphism that assigns, for every U ∈Op the function {1}  {1}(U) →Ω(U)
sending 1 7→U, the largest open set U ⊆U. From now on we denote {1} simply as 1.
Upshot: Truth values are open sets.
The point is that the truth values in the topos
of sheaves on a space (X, Op) are the open sets of that space. When someone says “is
property P true?,” the answer is not yes or no, but “it is true on the open subset U.”
If this U is everything, U  X, then P is really true; if U is nothing, U  , then P is
really false. But in general, it’s just true some places and not others.
Example 7.54. The category Grph of graphs is a presheaf topos, and one can also think
of it as the category of instances for a database schema, as we saw in Example 7.23. The
subobject classiﬁer Ωin the topos Gr is thus a graph, so we can draw it. Here’s what it

7.4. TOPOSES
245
looks like:
ΩGrph 
0
V
(0,0; 0)
(0,V; 0)
(V,V; 0)
(V,V; A)
(V,0; 0)
Finding Ωfor oneself is easiest using something called the Yoneda Lemma, but we
have not introduced it. For a nice, easy introduction to the topos of graphs, see [Vig03].
The terminal graph is a single vertex with a single loop, and the graph homomorphism
true: 1 →Ωsends that loop to (V, V; A).
Given any graph G and subgraph i : H ⊆G, we need to construct a graph homo-
morphism ⌜H⌝: G →Ωclassifying H. The idea is that for each part of G, we decide
“how much of it is in H. A vertex in v in G is either in H or not; if so we send it to V
and if not we send it to 0. But arrows a are more complicated. If a is in H, we send
it (V, V; A). But if it is not in H, the mathematics requires us to ask more questions:
is its source in H? is its target in G”? both? neither? Based on the answers to these
questions we send a to (V, 0; 0), (0, V; 0), (V, V; 0), or (0, 0; 0), respectively.
Exercise 7.55.
Consider the subgraph H ⊆G shown here:
A•
B•
C•
⊆
A•
B•
C•
D•
f
1
h
i
Find the graph homomorphism ⌜H⌝: G →Ωclassifying it. See Example 7.54.
♦
7.4.2
Logic in a sheaf topos
Let’s consider the logical connectives, AND, OR, IMPLIES, and NOT. Suppose we
have a topological space X ∈Op.
Given two open sets U, V, considered as truth
values U, V ∈Ω(X), then their conjunction ‘U AND V’ is their intersection, and their
disjunction ‘U OR V’ is their union;
(U ∧V) B U ∩V
and
(U ∨V) B U ∪V.
(7.56)
These formulas are easy to remember, because ∧looks like ∩and ∨looks like ∪. The
implication U ⇒V is the largest open set R such that R ∩U ⊆V, i.e.
(U ⇒V) B
Ø
{R∈Op|R∩U⊆V}
R.
(7.57)
In general, it is not easy to reduce Eq. (7.57) further, so implication is the hardest logical
connective to think about topologically.
Finally, the negation of U is given by ¬U B (U ⇒false), and this turns out
to be relatively simple. By the formula in Eq. (7.57), it is the union of all R such that
R∩U  , i.e. the union of all open sets in the complement of U. If you know topology,
you might recognize that ¬U is the ‘interior of the complement of U.’

246
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Example 7.58. Consider the real line X  R as a topological space (see Exercise 7.27).
Let U, V ∈Ω(X) be the open sets U  {x ∈R | x < 3} and V  {x ∈R | −4 < x < 4}.
Using interval notation, U  (−∞, 3) and V  (−4, 4). Then
• U ∧V  (−4, 3).
• U ∨V  (−∞, 4).
• ¬U  (3, ∞).
• ¬V  (−∞, −4) ∪(4, ∞).
• (U ⇒V)  (−4, ∞)
• (V ⇒U)  U
Exercise 7.59.
Consider the real line R as a topological space, and consider the open
subset U  R −{0}.
1. What open subset is ¬U?
2. What open subset is ¬¬U?
3. Is it true that U ⊆¬¬U?
4. Is it true that ¬¬U ⊆U?
♦
Above we explained operations on open sets, one corresponding to each logical
connective; there are also open sets corresponding to the the symbols true and false.
We explore this in an exercise.
Exercise 7.60.
Let (X, Op) be a topological space.
1. Suppose the symbol true corresponds to an open set such that for any open set
U ∈Op, we have (true ∧U)  U. Which open set is it?
2. Other things we should expect from true include (true ∨U)  true and (U ⇒
true)  true and (true ⇒U)  U. Do these hold for your answer to 1?
3. The symbol false corresponds to an open set U ∈Op such that for any open set
U ∈Op, we have (false ∨U)  U. Which open set is it?
4. Other things we should expect from false include (false ∧U)  false and
(false ⇒U)  true. Do these hold for your answer to 1?
♦
Example 7.61. For a vector bundle π: E →X over a space X, the corresponding sheaf
is Secπ corresponding to its sections: to each open set iU : U ⊆X, we associate the set
of functions s : U →E for which s # π  iU. For example, in the case of the tangent
bundle π: TM →M (see Example 7.46), the corresponding sheaf, call it VF, associates
to each U the set VF(U) of vector ﬁelds on U.
The internal logic of the topos can then be used to consider properties of vector
ﬁelds. For example, one could have a predicate Grad: VF →Ωthat asks for the largest
subspace Grad(v) on which a given vector ﬁeld v comes from the gradient of some
scalar function. One could also have a predicate that asks for the largest open set on
which a vector ﬁeld is non-zero. Logical operations like ∧and ∨could then be applied
to hone in on precise submanifolds throughout which various desired properties hold,

7.4. TOPOSES
247
and to reason logically about what other properties are forced to hold there.
7.4.3
Predicates
In English, a predicate is the part of the sentence that comes after the subject. For
example “. . . is even” or “. . . likes the weather” are predicates.
Not every subject
makes sense for a given predicate; e.g. the sentence “7 is even” may be false, but it
makes sense. In contrast, the sentence “2.7 is even” does not really make sense, and
“2.7 likes the weather” certainly doesn’t. In computer science, they might say “The
expression ‘2.7 likes the weather’ does not type check.”
The point is that each predicate is associated to a type, namely the type of subject
that makes sense for that predicate. When we apply a predicate to a subject of the
appropriate type, the result has a truth value: “7 is even” is either true or false.
Perhaps “Bob likes the weather” is true some days and false on others. In fact, this
truth value might change by the year (bad weather this year), by the season, by the
hour, etc. In English, we expect truth values of sentences to change over time, which
is exactly the motivation for this chapter. We’re working toward a logic where truth
values change over time.
In a topos E  Shv(X, Op), a predicate is a sheaf morphism p : S →Ωwhere S ∈E is
a sheaf and Ω∈E is the subobject classiﬁer, the sheaf of truth values. By Deﬁnition 7.35
we get a function p(U): S(U) →Ω(U) for any open set U ⊆X. In the above example—
which we will discuss more carefully in Section 7.5—if S is the sheaf of people (people
come and go over time), and Bob ∈S(U) is a person existing over a time U, and p is the
predicate “likes the weather,” then p(Bob) is the set of times during which Bob likes
the weather. So the answer to “Bob likes the weather” is something like “in summers
yes, and also in April 2018 and May 2019 yes, but in all other times no.” That’s p(Bob),
the temporal truth value obtained by applying the predicate p to the subject Bob.
Exercise 7.62.
Just now we described how a predicate p : S →Ω, such as “. . . likes the
weather,” acts on sections s ∈S(U), say s  Bob. But by Deﬁnition 7.12, any predicate
p : S →Ωalso deﬁnes a subobject of {S | p} ⊆S. Describe the sections of this subsheaf.
♦
The poset of subobjects.
For a topos E  Shv(X, Op) and object (sheaf) S ∈E, the
set of S-predicates |ΩE|  E(S, Ω) is naturally given the structure of a poset, which we
denote
(|ΩS|, ≤S)
(7.63)
Given two predicates p, q : S →Ω, we say that p ≤S q if the ﬁrst implies the second.
More precisely, for any U ∈Op and section s ∈S(U) we obtain two open subsets
p(s) ⊆U and q(s) ⊆U. We say that p ≤S q if p(s) ⊆q(s) for all U ∈Op and s ∈S(U).
We often drop the superscript from ≤S and simply write ≤. In formal logic notation,

248
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
one might write p ≤S q using the ⊢symbol, e.g. in one of the following ways:
s : S | p(s) ⊢q(s)
or
p(s) ⊢s:S q(s).
In particular, if S  1 is the terminal object, we denote |ΩS| by |Ω|, and refer to elements
p ∈|Ω| as propositions. They are just morphisms p : 1 →Ω.
This preorder is partially ordered—a poset—meaning that if p ≤q and q ≤p then
p  q. The reason is that for any subsets U, V ⊆X, if U ⊆V and V ⊆U then U  V.
Exercise 7.64.
Give an example of a space X, a sheaf S ∈Shv(X), and two predicates
p, q : S →Ωfor which p(s) ⊢s:S q(s) holds. You do not have to be formal.
♦
All of the logical symbols (true, false, ∧, ∨, ⇒, ¬) from Section 7.4.2 make sense
in any such poset |ΩS|. For any two predicates p, q : S →Ω, we deﬁne (p ∧q): S →Ω
by (p ∧q)(s) B p(s) ∧q(s), and similarly for ∨. Thus one says that these operations
are computed pointwise on S. With these deﬁnitions, the ∧symbol is the meet and the ∨
symbol is the join—in the sense of Deﬁnition 1.81—for the poset |ΩS|.
With all of the logical structure we’ve deﬁned so far, the poset |ΩS| of predicates on S
forms what’s called a Heyting algebra. We will not deﬁne it here, but more information
can be found in Section 7.6. We now move on to quantiﬁcation.
7.4.4
Quantiﬁcation
Quantiﬁcation comes in two ﬂavors: universal and existential, or ‘for all’ and ‘there
exists.’ Each takes in a predicate of n+1 variables and returns a predicate of n variables.
Example 7.65. Suppose we have two sheaves S, T ∈Shv(X, Op) and a predicate p : S ×
T →Ω. Let’s say T represents what’s considered newsworthy and S is again the set
of people. So for a subset of time U, a section t ∈T(U) is something that’s considered
newsworthy throughout the whole of U, and a section s ∈S(U) is a person that lasts
throughout the whole of U. Let’s imagine the predicate p as “s is worried about t.”
Now recall from Section 7.4.3 that a predicate p does not simply return true or false;
given a person s and a news-item t, it returns a truth value corresponding to the subset
of times on which p(s, t) is true.
“For all t in T, . . . is worried about t” is itself a predicate on just one variable, S,
which we denote
∀(t : T). p(s, t).
Applying this predicate to a person s returns the times when that person is worried
about everything in the news. Similarly, “there exists t in T such that s is worried about
t” is also a predicate on S, which we denote ∃(t : T). p(s, t). If we apply this predicate
to a person s, we get the times when person s is worried about at least one thing in the
news.

7.4. TOPOSES
249
Exercise 7.66.
In the topos Set, where Ω B, consider the predicate p : N × Z →B
given by
p(n, z) 
(
true
if n ≤|z|
false
if n > |z|.
1. What is the set of n ∈N for which the predicate ∀(z : Z). p(n, z) holds?
2. What is the set of n ∈N for which the predicate ∃(z : Z). p(n, z) holds?
3. What is the set of z ∈Z for which the predicate ∀(n : N). p(n, z) holds?
4. What is the set of z ∈Z for which the predicate ∃(n : N). p(n, z) holds?
♦
So given p, we have a universally- and an existentially-quantiﬁed predicate ∀(t :
T). p(s, t) and ∃(t : T). p(s, t) on S. How do we formally understand them as sheaf
morphisms S →Ωor, equivalently, as subsheaves of S?
Universal quantiﬁcation.
Given a predicate p : S×T →Ω, the universally-quantiﬁed
predicate ∀(t : T). p(s, t) takes a section s ∈S(U), for any open set U, and returns a
certain open set V ∈Ω(U). Namely, it returns the largest open set V ⊆U for which
p(s

V, t)  V holds for all t ∈T(V).
Exercise 7.67.
Suppose s is a person alive throughout the interval U.
Apply the
above deﬁnition to the example p(s, t)  “person s is worried about news t” from
Example 7.65.
Here, T(V) is the set of items that are in the news throughout the
interval V.
1. What open subset of U is ∀(t : T). p(s, t) for a person s?
2. Does it have the semantic meaning you’d expect, given the less formal description
in Section 7.4.4?
♦
Abstractly speaking, the universally-quantiﬁed predicate corresponds to the sub-
sheaf given by the following pullback:
∀tp
1
S
ΩT
trueT
p′
⌟
where p′: S →ΩT is the currying of S × T →Ωand trueT is the currying of the
composite 1 × T
!−→1
true
−−−→Ω. See Eq. (7.10).
Existential quantiﬁcation.
Given a predicate p : S × T →Ω, the existentially quanti-
ﬁed predicate ∃(t : T). p(s, t) takes a section s ∈S(U), for any open set U, and returns
a certain open set V ∈Ω(U), namely the union V  Ð
i Vi of all the open sets Vi for
which there exists some ti ∈T(Vi) satisfying p(s

Vi, ti)  Vi. If the result is U itself, you
might be tempted to think “ah, so there exists some t ∈T(U) satisfying p(t),” but that
is not necessarily so. There is just a cover of U  Ð Ui and local sections ti ∈T(Ui),
each satisfying p, as explained above. Thus the existential quantiﬁer is doing a lot of

250
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
work “under the hood,” taking coverings into account without displaying that fact in
the notation.
Exercise 7.68.
Apply the above deﬁnition to the “person s is worried about news t”
predicate from Example 7.65.
1. What open set is ∃(t : T). p(s, t) for a person s?
2. Does it have the semantic meaning you’d expect?
♦
Abstractly speaking, the existentially-quantiﬁed predicate is given as follows. Start
with the subobject classiﬁed by p, namely {(s, t) ∈S × T | p(s, t)} ⊆S × T, compose
with the projection πS : S × T →S as on the upper right; then take the epi-mono
factorization of the composite as on the lower left:
{S × T | p}
S × T
∃tp
S
πS
Then the bottom map is the desired subsheaf of S.
7.4.5
Modalities
Back in Example 1.123 we discussed modal operators—also known as modalities—
saying they are closure operators on preorders which arise in logic. The preorders we
were referring to are the ones discussed in Eq. (7.63): for any object S ∈E there is the
poset (|ΩS|, ≤S) of predicates on S, where |ΩS|  E(S, Ω) is just the set of morphisms
S →Ωin the category E.
Deﬁnition 7.69. A modality in Shv(X) is a sheaf morphism j : Ω→Ωsatisfying three
properties for all U ⊆X and p, q ∈Ω(U):
(a) p ≤j(p);
(b) (j # j)(p) ≤j(p); and
(c) j(p ∧q)  j(p) ∧j(q).
Exercise 7.70.
Suppose j : Ω→Ωis a morphism of sheaves on X, such that p ≤j(p)
holds for all U ⊆X and p ∈Ω(U). Show that for all q ∈Ω(U) we have j(j(q)) ≤j(q) iﬀ
j(j(q))  j(q).
♦
In Example 1.123 we informally said that for any proposition p, e.g. “Bob is in San
Diego,” there is a modal operator “assuming p, ....” Now we are in a position to make
that formal.
Proposition 7.71. Fix a proposition p ∈|Ω|. Then
(a) the sheaf morphism Ω→Ωgiven by sending q to p ⇒q is a modality.
(b) the sheaf morphism Ω→Ωgiven by sending q to p ∨q is a modality.
(c) the sheaf morphism Ω→Ωgiven by sending q to (q ⇒p) ⇒p is a modality.

7.4. TOPOSES
251
We cannot prove Proposition 7.71 here, but we give references in Section 7.6.
Exercise 7.72.
Let S be the sheaf of people as in Section 7.4.3, and let j : Ω→Ωbe
“assuming Bob is in San Diego...”
1. Name any predicate p : S →Ω, such as “likes the weather.”
2. Choose a time interval U. For an arbitrary person s ∈S(U), what sort of thing is
p(s), and what does it mean?
3. What sort of thing is j(p(s)) and what does it mean?
4. Is it true that p(s) ≤j(p(s))? Explain brieﬂy.
5. Is it true that j(j(p(s)))  j(p(s))? Explain brieﬂy.
6. Choose another predicate q : S →Ω. Is it true that j(p ∧q)  j(p) ∧j(q)? Explain
brieﬂy.
♦
7.4.6
Type theories and semantics
We have been talking about the logic of a topos in terms of open sets, but this is actually
a conﬂation of two ideas that are really better left unconﬂated. The ﬁrst is logic, or
formal language, and the second is semantics, or meaning. The formal language looks
like this:
∀(t : T). ∃(s : S). f (s)  t
(7.73)
and semantic statements are like “the sheaf morphism f : S →T is an epimorphism.”
In the former, logical world, all statements are linguistic expressions formed according
to strict rules and all proofs are deductions that also follow strict rules. In the latter,
semantic world, statements and proofs are about the sheaves themselves, as mathe-
matical objects. We admit these are rough statements; again, our aim here is only to
give a taste, an invitation to further reading.
To provide semantics for a logical system means to provide a compiler that converts
each logical statement in the formal language into a mathematical statement about
particular sheaves and their relationships. A computer can carry out logical deductions
without knowing what any of them “mean” about sheaves. We say that semantics is
sound if every formal proof is converted into a true fact about the relevant sheaves.
Every topos can be assigned a formal language, often called its internal language,
in which to carry out constructions and formal proofs. This language has a sound
semantics—a sort of logic-to-sheaf compiler—which goes under the name categorical
semantics or Kripke-Joyal semantics.
We gave the basic ideas in Section 7.4; we give
references to the literature in Section 7.6.
Example 7.74. In every topos E, and for every f : S →T in E, the morphism f is
an epimorphism if and only if Eq. (7.73) holds. For example, consider the case of
database instances on a schema C, say with 100 tables (one of which might be denoted
c ∈Ob(C)) and 500 foreign key columns (one of which might be denoted f : c →c′ in
C); see Eq. (3.2).

252
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
If S and T are two instances and f is a natural transformation between them, then
we can ask the question of whether or not Eq. (7.73) holds. This simple formula is
compiled by the Kripke-Joyal semantics into asking:
Is it true that for every table c ∈Ob(C) and every row s ∈S(c) there exists
a row t ∈T(c) such that f (s)  t?
This is exactly what it means for f to be surjective. Maybe this is not too impressive,
but whether one is talking about databases or topological spaces, or complex ideas
from algebraic geometry, Eq. (7.73) always compiles into the question of surjectivity.
For topological spaces it would say something like:
Is it true that for every open set U ⊆X and every section s ∈S(U) of the
bundle S, there exists an open covering of (Ui ⊆U)i∈I of U and a section
ti ∈T(Ui) of the bundle T for each i ∈I, such that f (ti)  s

Ui is the
restriction of s to Ui?
7.5
A topos of behavior types
Now that we have discussed logic in a sheaf topos, we return to our motivating example,
a topos of behavior types. We begin by discussing the topological space on which
behavior types will be sheaves, a space called the interval domain.
Remark 7.75. Note that above, we were thinking very intuitively about time, e.g. when
we discussed people being worried about the news. Now we will be thinking about
time in a diﬀerent way, but there is no need to change your answers or reconsider the
intuitive thinking done above.
7.5.1
The interval domain
The interval domain IR is a speciﬁc topological space, which we will use to model
intervals of time. In other words, we will be interested in the category Shv(IR) of
sheaves on the interval domain.
To give a topological space, one must give a pair (X, Op), where X is a set of ‘points’
and Op is a topology on X; see Deﬁnition 7.25. The set of points for IR is that of all
ﬁnite closed intervals
IR B {[d, u] ⊆R | d ≤u}.
For a < b in R, let o[a,b] denote the set o[a,b] B {[d, u] ∈IR | a < d ≤u < b}; these are
called basic open sets. The topology Op is determined by these basic open sets in that a
subset U is open if it is the union of some collection of basic open sets.
Thus for example, o[0,5] is an open set: it contains every [d, u] contained in the
open interval {x ∈R | 0 < x < 5}.
Similarly o[4,8] is an open set, but note that
o[0,5] ∪o[4,8] , o[0,8]. Indeed, the interval [2, 6] is in the right-hand side but not the left.
Exercise 7.76.

7.5. A TOPOS OF BEHAVIOR TYPES
253
1. Explain why [2, 6] ∈o[0,8].
2. Explain why [2, 6] < o[0,5] ∪o[4,8].
♦
Let Op denote the open sets of IR, as described above, and let BT B Shv(IR, Op)
denote the topos of sheaves on this space. We call it the topos of behavior types.
There is an important subspace of IR, namely the usual space of real numbers R.
We see R as a subspace of IR via the isomorphism
R  {[d, u] ∈IR | d  u}.
We discussed the usual topology on R in Example 7.26, but we also get a topology
on R because it is a subset of IR; i.e. we have the subspace topology as described in
Exercise 7.32. These agree, as the reader can check.
Exercise 7.77.
Show that a subset U ⊆R is open in the subspace topology of R ⊆IR iﬀ
U ∩R is open in the usual topology on R deﬁned in Example 7.26.
♦
7.5.2
Sheaves on IR
We cannot go into much depth about the sheaf topos BT  Shv(IR, Op), for reasons
of space; we refer the interested reader to Section 7.6. In this section we will brieﬂy
discuss what it means to be a sheaf on IR, giving a few examples including that of the
subobject classiﬁer.
What is a sheaf on IR?
A sheaf S on the interval domain (IR, Op) is a functor
S: Opop →Set: it assigns to each open set U a set S(U); how should we interpret this?
An element s ∈S(U) is something that says is an “event that takes place throughout
the interval U.” Given this U-event s together with an open subset of V ⊆U, there is
a V-event s

V that tells us what s is if we regard it as an event taking place throughout
V. If U  Ð
i∈I Ui and we can ﬁnd matching Ui-events (si) for each i ∈I, then the sheaf
condition (Deﬁnition 7.35) says that they have a unique gluing, i.e. a U-event s ∈S(U)
that encompasses all of them: s

Ui  si for each i ∈I.
We said in Section 7.5.1 that every open set U ⊆IR can be written as the union of
basic open sets o[a,b]. This implies that any sheaf S is determined by its values S(o[a,b])
on these basic open sets. The sheaf condition furthermore implies that these vary
continuously in a certain sense, which we can express formally as
S(o[a,b])  lim
ϵ>0 S(o[a−ϵ,b+ϵ]).
However, rather than get into the details, we describe a few sorts of sheaves that may
be of interest.
Example 7.78. For any set A there is a sheaf A ∈Shv(IR) that assigns to each open set U
the set A(U) B A. This allows us to refer to integers, or real numbers, or letters of an
alphabet, as though they were behaviors. What sort of behavior is 7 ∈N? It is the sort

254
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
of behavior that never changes: it’s always seven. Thus A is called the constant sheaf on
A.
Example 7.79. Fix any topological space (X, OpX). Then there is a sheaf FX of local
functions from IR to X. That is, for any open set U ∈OpIR, we assign the set FX(U) B
{ f : U →X | f is continuous}. There is also the sheaf GX of local functions on the
subspace R ⊆IR. That is, for any open set U ∈OpIR, we assign the set GX(U) B
{ f : U ∩R →X | f is continuous}.
Exercise 7.80.
Let’s check that Example 7.78 makes sense. Fix any topological space
(X, OpX) and any subset R ⊆IR of the interval domain. Deﬁne HX(U) B { f : U ∩R →
X | f is continuous}.
1. Is HX a presheaf? If not, why not; if so, what are the restriction maps?
2. Is HX a sheaf? Why or why not?
♦
Example 7.81. Another source of examples comes from the world of open hybrid dy-
namical systems.
These are machines whose behavior is a mixture of continuous
movements—generally imagined as trajectories through a vector ﬁeld—and discrete
jumps. These jumps are imagined as being caused by signals that spontaneously arrive.
Over any interval of time, a hybrid system has certain things that it can do and certain
things that it cannot. Although we will not make this precise here, there is a construc-
tion for converting any hybrid system into a sheaf on IR; we will give references in
Section 7.6.
We refer to sheaves on IR as behavior types because almost any sort of behavior one
can imagine is a behavior type. Of course, a complex behavior type—such as the way
someone acts when they are in love—would be extremely hard to write down. But the
idea is straightforward: for any interval of time, say a three-day interval (d, d + 3), let
L(d, d +3) denote the set of all possible behaviors a person who is in love could possibly
do. Obviously it’s a big, unwieldy set, and no one would want to make precise. But to
the extent that one can imagine that sort of behavior as occurring through time, they
could imagine the corresponding sheaf.
The subobject classiﬁer as a sheaf on IR.
In any sheaf topos, the subobject classiﬁer
Ωis itself a sheaf. It is responsible for the truth values in the topos. As we said in
Section 7.4.1, when it comes to sheaves on a topological space (X, Op), truth values are
open subsets U ∈Op.
BT is the topos of sheaves on the space (IR, Op), as deﬁned in Section 7.5.1. As
always, the subobject classiﬁer Ωassigns to any U ∈Op the set of open subsets of U, so
these are the truth values. But what do they mean? The idea is that every proposition,

7.5. A TOPOS OF BEHAVIOR TYPES
255
such as “Bob likes the weather” returns an open set U, as if to respond that Bob likes
the weather “...throughout time period U.” Let’s explore this just a bit more.
Suppose Bob likes the weather throughout the interval (0, 5) and throughout the
interval (4, 8). We would probably conclude that Bob likes the weather throughout the
interval (0, 8). But what about the more ominous statement “a single pair of eyes has
remained watching position p.” Then just because it’s true on (0, 5) and on (4, 8), does
not imply that it’s been true on (0, 8): there may have been a change of shift, where
one watcher was relieved from their post by another watcher. As another example,
consider the statement “the stock market did not go down by more than 10 points.”
This might be true on (0, 5) and true on (4, 8) but not on (0, 8). In order to capture the
semantics of statements like these—statements that take time to evaluate—we must
use the space IR rather than the space R.
7.5.3
Safety proofs in temporal logic
We now have at least a basic idea of what goes into a proof of safety, say for autonomous
vehicles, or airplanes in the national airspace system. In fact, the underlying ideas of
this chapter came out of a project between MIT, Honeywell Inc., and NASA [SSV18].
The background for the project was that the National Airspace System consists of
many diﬀerent systems interacting: interactions between airplanes, each of which is
an interaction between physics, humans, sensors, and actuators, each of which is an
interaction between still more basic parts. The same sort of story would hold for a ﬂeet
of autonomous vehicles, as in the introduction to this chapter.
Suppose that each of the systems—at any level—is guaranteed to satisfy some
property. For example, perhaps we can assume that an engine is either out of gas, has
a broken fuel line, or is following the orders of a human driver or pilot. If there is
a rupture in the fuel line, the sensors will alert the human within three seconds, etc.
Each of the components interact with a number of diﬀerent variables. In the case of
airplanes, a pilot interacts with the radio, the positions of the dials, the position of
the thruster, and the visual data in front of her. The component—here the pilot—is
guaranteed to keep these variables in some relation: “if I see something, I will say
something” or “if the dials are in position bad_pos, I will engage the thruster within 1
second.” We call these guarantees behavior contracts.
All of the above can be captured in the topos BT of behavior types. The variables
are behavior types: the altimeter is a variable whose value θ ∈R≥0 is changing
continuously with respect to time. The thruster is also a continuously-changing variable
whose value is in the range [0, 1], etc.
The guaranteed relationships—behavior contracts—are given by predicates on vari-
ables. For example, if the pilot will always engage the thruster within one second
of the display dials being in position bad_pos, this can be captured by a predicate
p : dials × thrusters →Ω. While we have not written out a formal language for p,

256
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
one could imagine the predicate p(D, T) for D : dials and T : thrusters as
∀(t : R). @t
 bad_pos(D)
⇒
∃(r : R). (0 < r < 1) ∧∀(r′ : R). 0 ≤r′ ≤5 ⇒@t+r+r′  engaged(T)
.
(7.82)
Here @t is a modality, as we discussed in Deﬁnition 7.69; in fact it turns out to be one
of type 3. from Proposition 7.71, but we cannot go into that. For a proposition q, the
statement @t(q) says that q is true in some small enough neighborhood around t. So
(7.82) says “starting within one second of whenever the dials say that we are in a bad
position, I’ll engage the thrusters for ﬁve seconds.”
Given an actual playing-out-of-events over a time period U, i.e. actual section D ∈
dials(U) and section T ∈thrusters(U), the predicate Eq. (7.82) will hold on certain
parts of U and not others, and this is the truth value of p. Hopefully the pilot upholds
her behavior contract at all times she is ﬂying, in which case the truth value will be true
throughout that interval U. But if the pilot breaks her contract over certain intervals,
then this fact is recorded in Ω.
The logic allows us to record axioms like that shown in Eq. (7.82) and then reason
from them: e.g. if the pilot and the airplane, and at least one of the three radars upholds
its contract then safe separation will be maintained. We cannot give further details here,
but these matters have been worked out in detail in [SS18]; see Section 7.6.
7.6
Summary and further reading
This chapter was about modeling various sorts of behavior using sheaves on a space of
time-intervals. Behavior may seem like it’s something that occurs now in the present,
but in fact our memory of past behavior informs what the current behavior means.
In order to commit to anything, to plan or complete any sort of process, one needs to
be able to reason over time-intervals. The nice thing about temporal sheaves—indeed
sheaves on any site—is that they ﬁt into a categorical structure called a topos, which has
many useful formal properties. In particular, it comes equipped with a higher-order
logic with which we can formally reason about how temporal sheaves work together
when combined in larger systems. A much more detailed version of this story was
presented in [SS18]. But it would have been impossible without the extensive ediﬁce
of topos theory and domain theory that has been developed over the past six decades.
Sheaf toposes were invented by Grothendieck and his school in the 1960s [AGV71]
as an approach to proving conjectures at the intersection of algebraic geometry and
number theory, called the Weil conjectures. Soon after, Lawvere and Tierney recognized
that toposes had all the structure necessary to do logic, and with a whole host of
other category theorists, the subject was developed to an impressive extent in many
directions. For a much more complete history, see [McL90].
There are many sorts of references on topos theory. One that starts by introducing
categories and then moves to toposes, focusing on logic, is [McL92].
Our favorite

7.6. SUMMARY AND FURTHER READING
257
treatment is perhaps [MM92], where the geometric aspects play a central role. Finally,
Johnstone has done the ﬁeld a huge favor by collecting large amounts of the theory
into a single two-volume set [Joh02]; it is very dense, but an essential reference for the
serious student or researcher. For just categorical (Kripke-Joyal) semantics of logic in a
topos, one should see either [MM92], [Jac99], or [LS88].
We did not mention domain theory much in this chapter, aside from referring to
the interval domain. But domains, in the sense of Dana Scott, play an important role
in the deeper aspects of temporal type theory. A good reference is [Gie+03], but for an
introduction we suggest [AJ94].
In some sense our application area has been a very general sort of dynamical system.
Other categorical approaches to this subject include [JNW96], [HTP03], [AS05], and
[Law86], though there are many others.
We hope you have enjoyed the seven sketches in this book. As a next step, consider
running a reading course on applied category theory with some friends or colleagues.
Simultaneously, we hope you begin to search out categorical ways of thinking about
familiar subjects. Perhaps you’ll ﬁnd something you want to contribute to this growing
ﬁeld of applied category theory, or as we sometimes call it, the ﬁeld of compositionality.


Appendix A
Exercise solutions
A.1
Solutions for Chapter 1.
Solution to Exercise 1.1.
For each of the following properties, we need to ﬁnd a function f : R →R that preserves it, and another
function—call it 1—that does not.
order-preserving: Take f (x)  x + 5; if x ≤y then x + 5 ≤y + 5, so f is order-preserving. Take
1(x) B −x; even though 1 ≤2, the required inequality −1 ≤? −2 does not hold, so 1 is not
order-preserving.
metric-preserving: Take f (x) B x + 5; for any x, y we have |x −y|  |(x + 5) −(y + 5)| by the rules of
arithmetic, so |x −y|  | f (x) −f (y)|, meaning f preserves metric. Take 1(x) B 2 ∗x; then with
x  1 and y  2 we have |x −y|  1 but |2x −2y|  2, so 1 does not preserve the metric.
addition-preserving: Take f (x) B 3 ∗x; for any x, y we have 3 ∗(x + y)  (3 ∗x) + (3 ∗y), so f preserves
addition. Take 1(x) B x + 1; then with x  0 and y  0, we have 1(x + y)  1, but 1(x) + 1(y)  2,
so 1 does not preserve addition.
Solution to Exercise 1.4.
Here is the join of the two systems:
11•
12•
13•
21•
22•
23•
11•
12•
13•
21•
22•
23•
∨
11•
12•
13•
21•
22•
23•

Solution to Exercise 1.6.
1. Here is the Hasse diagram for partitions of the two element set {•, ∗}:
•
∗
(12) 
•
∗
(1)(2) 
259

260
APPENDIX A. EXERCISE SOLUTIONS
2. Here is a picture (using text, rather than circles) for partitions of the set 1, 2, 3, 4:
(1)(2)(3)(4)
(12)(3)(4)
(1)(2)(34)
(13)(2)(4)
(1)(24)(3)
(14)(2)(3)
(1)(23)(4)
(12)(34)
(13)(24)
(14)(23)
(123)(4)
(124)(3)
(134)(2)
(1)(234)
(1234)
For the remaining parts, we choose A  (12)(3)(4) and B  (13)(2)(4).
3. A ∨B  (123)(4).
4. Yes, it is true that A ≤(A ∨B) and that B ≤(A ∨B).
5. The systems C with A ≤C and B ≤C are: (123)(4) and (1234).
6. Yes, it is true that in each case (A ∨B) ≤C.
Solution to Exercise 1.7.
1. true ∨false  true.
2. false ∨true  true.
3. true ∨true  true.
4. false ∨false  false.
Solution to Exercise 1.11.
1. The eight subsets of B B {1, 2, 3} are
,
{1},
{2},
{3},
{1, 2},
{1, 3},
{2, 3},
{1, 2, 3}.
2. The union of {1, 2, 3} and {1} is {1, 2, 3} ∪{1}  {1, 2, 3}.
3. The six elements of {h, 1} × {1, 2, 3} are
(h, 1),
(h, 2),
(h, 3),
(1, 1),
(1, 2),
(1, 3).
4. The ﬁve elements of {h, 1} ⊔{1, 2, 3} are
(h, 1),
(1, 1),
(1, 2),
(2, 2),
(3, 2).
5. The four elements of {h, 1} ∪{1, 2, 3} are
h,
1,
2,
3.
Solution to Exercise 1.10.
1. This is true: a natural number is exactly an integer that is at least 0.
2. This is false: 0 ∈N but 0 < {n ∈Z | n ≥1}.
3. This is true: no elements of Z are strictly between 1 and 2.
Solution to Exercise 1.16.
Suppose that A is a set and {Ap}p∈P and {A′
p′}p′∈P′ are two partitions of A such that for each p ∈P
there exists a p′ ∈P′ with Ap  A′
p′.

A.1. SOLUTIONS FOR CHAPTER 1
261
1. Given p ∈P, suppose we had p′
1, p′
2 ∈P′ such that Ap  A′
p′
1 and Ap  A′
p′
2. Well then Ap′
1  Ap′
2,
so in particular Ap′
1 ∩Ap′
2  Ap′
1. By the deﬁnition of partition (1.14), Ap′
1 , , and yet if p1 , p2
then Ap′
1 ∩Ap′
2  . This can’t be, so we must have p′
1  p′
2, as desired.
2. Suppose given p′ ∈P′; we want to show that there is a p ∈P such that Ap  A′
p′. Since A′
p′ , 
is nonempty by deﬁnition, we can pick some a ∈A′
p′; since A′
p′ ⊆A, we have a ∈A. Finally,
since A  Ð
p∈P Ap, there is some p with a ∈Ap. This is our candidate p; now we show that
Ap  A′
p′. By assumption there is some p′′ ∈P′ with Ap  A′
p′′, so now a ∈A′
p′′ and a ∈A′
p′,
so a ∈A′
p′ ∩A′
p′′. Again by deﬁnition, having a nonempty intersection means p′  p′′. So we
conclude that Ap  Ap′.
Solution to Exercise 1.17.
The pairs (a, b) such that a ∼b are:
(11, 11)
(11, 12)
(12, 11)
(12, 12)
(13, 13)
(21, 21)
(22, 22)
(12, 23)
(23, 22)
(23, 23)
Solution to Exercise 1.20.
1. One aspect in the deﬁnition of the parts is that they are connected, and one aspect of that is that
they are nonempty. So each part Ap is nonempty.
2. Suppose p , q, i.e. Ap and Aq are not exactly the same set. To prove Ap ∩Aq  , we suppose
otherwise and derive a contradiction. So suppose there exists a ∈Ap ∩Aq; we will show that
Ap  Aq, which contradicts an earlier hypothesis. To show that these two subsets are equal, it
suﬃces to show that a′ ∈Ap iﬀa′ ∈Aq for all a′ ∈A. Suppose a′ ∈Ap; then because Ap is
connected, we have a ∼a′. And because Aq is closed, a′ ∈Aq. In just the way, if a′ ∈Aq then
because Aq is connected and Ap is closed, a′ ∈Ap, and we are done.
3. To show that A  Ð
p∈P Ap, it suﬃces to show that for each a ∈A, there is some p ∈P such that
a ∈Ap. We said that P was the set of closed and connected subsets of A, so it suﬃces to show that
there is some closed and connected subset containing a. Let X B {a′ ∈A | a′ ∼a}; we claim it is
closed and connected and contains a. To see X is closed, suppose a′ ∈X and b ∼a′; then b ∼a
by transitivity and symmetry of ∼, so b ∈X. To see that X is connected, suppose b, c ∈X; then
b ∼a and c ∼a so b ∼c by the transitivity and symmetry of ∼. Finally, a ∈X by the reﬂexivity
of ∼.
Solution to Exercise 1.24.
1. The unique function  →{1} is injective but not surjective.
2. The unique function {a, b} →{1} is surjective but not injective.
3. The second and third are not functions; the ﬁrst and fourth are functions.
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
✓
?
?
✓
4. Neither the second nor third is ‘total’. Moreover, the second one is not deterministic. The ﬁrst
one is a function which is not injective and not surjective. The fourth one is a function which is
both injective and surjective.
Solution to Exercise 1.25.
By Deﬁnition 1.22, a function f : A → is a subset F ⊆A ×  such that for all a ∈A, there exists a
unique b ∈ with (a, b) ∈F. But there are no elements b ∈? , so if F is to have the above property,
there can be no a ∈A either; i.e. A must be empty.

262
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.27.
Below each partition, we draw a corresponding surjection out of {•, ∗, ◦}:
•
∗
◦
•
∗
◦
•
∗
◦
•
∗
◦
•
∗
◦
•
∗
◦
p1
p2
p3
•
∗
◦
p1
p2
•
∗
◦
p1
p2
•
∗
◦
p1
p2
•
∗
◦
p1
Solution to Exercise 1.38.
G 
1•
2•
3•
4•
a
b
c
e
d
arrow a
source s(a) ∈V
target t(a) ∈V
a
1
2
b
1
3
c
1
3
d
2
2
e
2
3
Solution to Exercise 1.40.
The graph G from Exercise 1.38 is a strange Hasse diagram because it has two arrows 1 →3 and a loop,
both of which are “useless” from a preorder point-of-view. But that does not prevent our formula from
working. The preorder (P, ≤) is given by taking P B V  {1, 2, 3, 4} and writing p ≤q whenever there
exists a path from p to q. So:
1 ≤1,
1 ≤2,
1 ≤3,
2 ≤2,
2 ≤3,
3 ≤3,
4 ≤4
Solution to Exercise 1.41.
A collection of points, e.g. •
•
• is a Hasse diagram, namely for the discrete order, i.e. for the order
where x ≤y iﬀx  y.
Solution to Exercise 1.42.
Let’s write the ﬁve elements of X as
(•)(◦)(∗),
(•◦)(∗),
(•∗)(◦),
(•)(◦∗),
(• ◦∗)
Our job is to write down all 12 pairs of x1, x2 ∈X with x1 ≤x2. Here they are:
(•)(◦)(∗) ≤(•)(◦)(∗)
(•)(◦)(∗) ≤(•◦)(∗)
(•)(◦)(∗) ≤(•∗)(◦)
(•)(◦)(∗) ≤(•)(◦∗)
(•)(◦)(∗) ≤(• ◦∗)
(•◦)(∗) ≤(•◦)(∗)
(•◦)(∗) ≤(• ◦∗)
(•∗)(◦) ≤(•∗)(◦)
(•∗)(◦) ≤(• ◦∗)
(•)(◦∗) ≤(•)(◦∗)
(•)(◦∗) ≤(• ◦∗)
(• ◦∗) ≤(• ◦∗)
Solution to Exercise 1.44.
The statement in the text is almost correct. It is correct to say that a discrete preorder is one where x
and y are comparable if and only if x  y.

A.1. SOLUTIONS FOR CHAPTER 1
263
Solution to Exercise 1.46.
8•
9•
6•
4•
10•
3•
2•
5•
7•
1•
No, it is not a total order; for example 4 ≰6 and 6 ≰4.
Solution to Exercise 1.48.
Yes, the usual ≤ordering is a total order on R: for every a, b ∈R either a ≤b or b ≤a.
Solution to Exercise 1.51.
The Hasse diagrams for P(), P{1}, and P{1, 2} are


{1}

{1}
{2}
{1, 2}
Solution to Exercise 1.53.
The coarsest partition on S corresponds to the unique function !: S →{1}. The ﬁnest partition on S
corresponds to the identity function idS : S →S.
Solution to Exercise 1.55.
If X has the discrete preorder, then every subset U of X is an upper set: indeed, if p ∈U, the only q
such that p ≤q is p itself, so q is deﬁnitely in U! This means that U(X) contains all subsets of X, so it’s
exactly the power set, U(X)  P(X).
Solution to Exercise 1.57.
The product preorder and its upper set preorder are:
(a, 1)
(c, 1)
(a, 2)
(b, 1)
(c, 2)
(b, 2)
{(c, 2)}
{(b, 2)}
{(c, 1), (c, 2)}
{(b, 2), (c, 2)}
{(b, 1), (b, 2)}
{(b, 2), (c, 1), (c, 2)}
{(a, 2), (b, 2), (c, 2)}
{(b, 1), (b, 2), (c, 2)}
{(a, 2), (b, 2), (c, 1), (c, 2)}
{(a, 2), (b, 1), (b, 2), (c, 2)}
{(a, 2), (b, 1), (b, 2), (c, 1), (c, 2)}
{(a, 1), (a, 2), (b, 1), (b, 2), (c, 1), (c, 2)}

264
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.63.
With X  {0, 1, 2}, the Hasse diagram for P(X), the preorder 0 ≤· · · ≤3, and the cardinality map
between them are shown below:
X
{0, 1}
{0, 2}
{1, 2}
{0}
{1}
{2}

3
2
1
0
Solution to Exercise 1.65.

{true}
{true, false}
{true}
{false}

{true, false}
Solution to Exercise 1.66.
1. Let q ∈↑p, and suppose q ≤q′. Since q ∈↑p, we have p ≤q. Thus by transitivity p ≤q′, so
q′ ∈↑p. Thus ↑p is an upper set.
2. Suppose p ≤q in P; this means that q ≤op p in Pop. We must show that ↑q ⊆↑p. Take any
q′ ∈↑q. Then q ≤q′, so by transitivitiy p ≤q′, and hence q′ ∈↑p. Thus ↑q ⊆↑p.
3. Monotonicity of ↑says that p ≤p′ implies ↑(p′) ⊆↑(p). We must prove the other direction, that
if p ≰p′ then ↑(p′) ⊈↑(p). This is straightforward, since by reﬂexivity we always have p′ ∈↑(p′),
but if p ≰p′, then p′ < ↑(p), so ↑(p′) ⊈↑(p).
4. The map ↑: Pop →U(P) can be depicted:
c
b
a
{c}
{b}
{b, c}
{a, b, c}
Solution to Exercise 1.67.
Suppose (P, ≤P) is a discrete preorder and that (Q, ≤Q) is any preorder. We want to show that every
function f : P →Q is monotone, i.e. that if p1 ≤P p2 then f (p1) ≤Q f (p2). But in P we have p1 ≤P p2
iﬀp1  p2; that’s what discrete means. If p1 ≤P p2 then p1  p2, so f (p1)  f (p2), so f (p1) ≤f (p2).
Solution to Exercise 1.69.
Let X  Z  {. . . , −2, −1, 0, 1, . . .} be the set of all integers, and let Y  {n, z, p}; let f : X →Y send
negative numbers to n, zero to z, and positive integers to p. This is surjective because all three elements
of Y are hit.
We consider two partitions of Y, namely P B (nz)(p) and Q B (np)(z). Technically, these are notation
for {{n, z}, {p}} and {{n, p}, {z}} as sets of disjoint subsets whose union is Y.
Their pulled back
partitions are f ∗P  (. . . , −2, −1, 0)(1, 2, . . .) and f ∗Q  (0)(. . . , −2, −1, 1, 2, . . .), or technically
f ∗(P)  {{x ∈Z | x ≤0}, {x ∈Z | x ≥1}}
and
f ∗(Q)  {{0}, {x ∈Z | x , 0}}.

A.1. SOLUTIONS FOR CHAPTER 1
265
Solution to Exercise 1.71.
We have preorders (P, ≤P), (Q, ≤Q), and (R, ≤R), and we have monotone maps f : P →Q and 1 : Q →R.
1. To see that idP is monotone, we need to show that if p1 ≤P p2 then idP(p1) ≤idP(p2). But
idP(p)  p for all p ∈P, so this is clear.
2. We have that p1 ≤P p2 implies f (p1) ≤Q f (p2) and that q1 ≤Q q2 implies 1(q1) ≤R 1(q2). By
substitution, p1 ≤P p2 implies 1( f (p1)) ≤R 1( f (p2)) which is exactly what is required for ( f # 1)
to be monotone.
Solution to Exercise 1.73.
We need to show that if (P, ≤P) is both skeletal and dagger, then it is discrete. So suppose it is skeletal,
i.e. p1 ≤p2 and p2 ≤p1 implies p1  p2. And suppose it is dagger, i.e. p1 ≤p2 implies p2 ≤p1. Well
then p1 ≤p2 implies p1  p2, and this is exactly the deﬁnition of P being discrete.
Solution to Exercise 1.77.
The map Φ from Section 1.1.1 took partitions of {•, ∗, ◦} and returned true or false based on whether or
not • was in the same partition as ∗. We need to see that it’s actually a monotone map Φ: Prt({•, ∗, ◦}) →
B. So suppose P, Q are partitions with P ≤Q; we need to show that if Φ(P)  true then Φ(Q)  true.
By deﬁnition P ≤Q means that P is ﬁner than Q: i.e. P diﬀerentiates more stuﬀ, and Q lumps more
stuﬀtogether. Technically, x ∼P y implies x ∼Q y for all x, y ∈{•, ∗, ◦}. Applying this to •, ∗gives the
result.
Solution to Exercise 1.79.
Given a function f : P →Q, we have f ∗: U(Q) →U(P) given by U 7→f −1(U). But upper sets in Q are
classiﬁed by monotone maps u : Q →B, and similarly for P; our job is to show that f ∗(U) is given by
composing the classiﬁer u with f .
Given an upper set U ⊆Q, let u : Q →B be the corresponding monotone map, which sends q 7→true
iﬀq ∈U.
Then ( f # u): P →B sends p 7→true iﬀf (p) ∈U; it corresponds to the upper set
{p ∈P | f (p) ∈U} which is exactly f −1(U).
Solution to Exercise 1.80.
1. 0 is a lower bound for S  {
1
n+1 | n ∈N} because 0 ≤
1
n+1 for any n ∈N.
2. Suppose that b is a lower bound for S; we want to see that b ≤0. If one believes to the contrary
that 0 < b, then consider 1/b; it is a real number so we can ﬁnd a natural number n that’s bigger
1/b < n < n + 1. This implies 1 < b(n + 1) and hence
1
n+1 < b, but that is a contradiction of b
being a lower bound for S. The false believer is defeated!
Solution to Exercise 1.85.
We have a preorder (P, ≤), an element p ∈P, and a subset A  {p} with one element.
1. To see that Ó A  p, we need to show that p ≤a for all a ∈A and that if q ≤a for all a ∈A then
q ≤p. But the only a ∈A is a  p, so both are obvious.
2. We know p is a meet of A, so if q is also a meet of A then q ≤a for all a ∈A so q ≤p; similarly
p ≤a for all a ∈A, so p ≤q. Then by deﬁnition we have p  q, and since (P, ≤) is a partial order,
p  q.
3. The analogous facts are true when Ó is replaced by Ô; the only change in the argument is to
replace ≤by ≥and ‘meet’ by ‘join’ everywhere.
Solution to Exercise 1.90.
The meet of 4 and 6 is the highest number in the order that divides both of them; the numbers dividing
both are 1 and 2, and 2 is higher, so 4 ∧6  2. Similar reasoning shows that 4 ∨6  12. The meet is the
‘greatest common divisor’ and the join is the ‘least common multiple,’ and this holds up for all pairs
m, n ∈N not just 4, 6.

266
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.94.
Since f is monotone, the facts that a ≤a ∨b and b ≤a ∨b imply that f (a) ≤f (a ∨b) and f (b) ≤f (a ∨b).
But by deﬁnition of join, f (a) ∨f (b) is the largest element with that property, so f (a) ∨f (b) ≤f (a ∨b),
as desired.
Solution to Exercise 1.98.
By analogy with Example 1.97, the right adjoint for (3 × −) should be ⌊−/3⌋. But to prove this is correct,
we must show that for any any r ∈R and z ∈Z we have z ≤⌊r/3⌋iﬀ3 ∗z ≤r.
Suppose the largest integer below r/3 is z′ B ⌊r/3⌋. Then z ≤z′ implies 3∗z ≤3∗z′ ≤3∗r/3  r, giving
one direction. For the other, suppose 3∗z ≤r. Then dividing both sides by 3, we have z  3∗z/3 ≤r/3.
Since z is an integer below r/3 it is below ⌊r/3⌋because ⌊r/3⌋is the greatest integer below r/3, and we
are done.
Solution to Exercise 1.99.
1. We need to check that for all nine pairs {(p, q) | 1 ≤p ≤3 and 1 ≤q ≤3} we have f (p) ≤q iﬀ
p ≤1(q), where f and 1 are the functions shown here:
P
1•
2•
3•
P
Q
•
1
•
2
•
3
Q
f
1
When p  q  1 we have f (p)  1 and 1(q)  2, so both f (p)  1 ≤1  q and p  1 ≤1(q);
it works! Same sort of story happens when (p, q) is (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), and (3, 3). A
diﬀerent story happens for p  3, q  1 and p  3, q  2. In those cases f (p)  3 and 1(q)  2,
and neither inequality holds: f (p) ≰q and p ≰1(q). But that’s ﬁne, we still have f (p) ≤q iﬀ
p ≤1(q) in all nine cases, as desired.
2.
P
1•
2•
3•
P
Q
•
1
•
2
•
3
Q
f
1
Here f is not left adjoint to 1 because f (2) ≰1 but 2 ≤1(1).
Solution to Exercise 1.101.
1. Let’s suppose we have a monotone map L: Z →R that’s left adjoint to ⌈−/3⌉and see what
happens. Writing C(r) B ⌈r/3⌉, then for all z ∈Z and r ∈R we have L(z) ≤r iﬀz ≤C(r)
by deﬁnition of adjunction. So take z  1 and r  .01; then ⌈r/3⌉ 1 so z ≤C(r), and hence
L(z) ≤r, i.e. L(1) ≤0.01. In the same way L(1) ≤r for all r > 0, so L(1) ≤0. By deﬁnition of
adjunction 1 ≤C(0)  ⌈0/3⌉ 0, a contradiction.
2. There’s no left adjoint, because starting with an arbitrary one, we derived a contradiction.
Solution to Exercise 1.103.
We have S  {1, 2, 3, 4}, T  {12, 3, 4}, and 1 : S →T the “obvious” function between them; see
Example 1.102. Take c1, c2, c3, c4 to be the following partitions:
1
2
3
4
1
2
3
4
1
2
3
4
1
2
3
4
•
•
•
•
•
•
•
•
c1 
c2 
c3 
c4 

A.1. SOLUTIONS FOR CHAPTER 1
267
Then the induced partitions 1!(c1), 1!(c2), 1!(c3), and 1!(c4) on T are:
12
3
4
12
3
4
12
3
4
12
3
4
•
•
•
•
•
•
•
1!(c1) 
1!(c2) 
1!(c3) 
1!(c4) 
Solution to Exercise 1.105.
Here are the partitions on S  {1, 2, 3, 4} induced via 1∗by the ﬁve partitions on T  {12, 3, 4}:
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
•
•
•
•
•
•
•
• • •
Solution to Exercise 1.106.
1. We choose the following partition c on S and compute its pushforward 1!(c):
1
2
3
4
•
•
c 
12
3
4
•
•
1!(c) 
2. Let d be the partition as shown, which was chosen to be coarser than 1!(c).
12
3
4
•
d 
3. Let e be the partition as shown, which was chosen to not be coarser than 1!(c).
12
3
4
•
•
e 
4. Here are 1∗(d) and 1∗(e):
1
2
3
4
1
2
3
4
•
•
•
1∗(d) 
1∗(e) 
5. Comparing c, the left-hand partition in part 1., with 1∗(d) and 1∗(e), we indeed have c ≤1∗(d)
but c ≰1∗(e), as desired.
Solution to Exercise 1.109.
Suppose P and Q are preorders, and that f : P ⇆Q :1 are monotone maps.
1. Suppose f is left adjoint to 1. By deﬁnition this means f (p) ≤q iﬀp ≤1(q), for all p ∈P and
q ∈Q. Then starting with the reﬂexivity fact 1(q) ≤1(q), the deﬁnition with p B 1(q) gives
f (1(q)) ≤q for all q.
2. Suppose that p ≤1( f (p)) and f (1(q)) ≤q for all p ∈P and q ∈Q. We ﬁrst want to show that
p ≤1(q) implies f (p) ≤q, so assume p ≤1(q). Then applying the monotone map f to both
sides, we have f (p) ≤f (1(q)), and then by transitivity f (1(q)) ≤q implies f (p) ≤q, as desired.
The other direction is similar.

268
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.110.
1. Suppose that f : P →Q has two right adjoints, 1, 1′: Q →P. We want to show that 1(q)  1′(q)
for all q ∈Q. We will prove 1(q) ≤1′(q); the inequality 1′(q) ≤1(q) is similar. To do this, we use
the fact that p ≤1′( f (p)) and f (1(q)) ≤q for all p, q by Eq. (1.108). Then the trick is to reason as
follows:
1(q) ≤1′( f (1(q))) ≤1′(q).
2. It is the same for left adjoints.
Solution to Exercise 1.112.
Suppose f : P →Q is left adjoint to 1 : Q →P. Let A ⊆P be any subset and let j B Ô A be its join.
Then since f is monotone f (a) ≤f (j) for all a ∈A, so f (j) is an upper bound for the set f (A). We
want to show it is the least upper bound, so take any other upper bound b for f (A), meaning we have
f (a) ≤b for all a ∈A. Then by deﬁnition of adjunction, we also have a ≤1(b) for all a ∈A. By
deﬁnition of join, we have j ≤1(b). Again by deﬁnition of adjunction f (j) ≤b, as desired.
Solution to Exercise 1.114.
We want to show that in the following picture, 1 is really right adjoint to f :
1•
2•
3.9•
4•
P B
1•
2•
4•
: Q
1
f
Here 1 preserves labels and f rounds 3.9 to 4.
There are twelve tiny things to check: for each p ∈P and q ∈Q, we need to see that f (p) ≤q iﬀp ≤1(q).
p
q
f (p)
1(q)
f (p) ≤? q
p ≤? 1(q)
same?
1
1
1
1
yes
yes
yes!
1
2
1
2
no
no
yes!
1
4
1
4
yes
yes
yes!
2
1
2
1
no
no
yes!
2
2
2
2
yes
yes
yes!
2
4
2
4
yes
yes
yes!
3.9
1
4
1
no
no
yes!
3.9
2
4
2
no
no
yes!
3.9
4
4
4
yes
yes
yes!
4
1
4
1
no
no
yes!
4
2
4
2
no
no
yes!
4
4
4
4
yes
yes
yes!
Solution to Exercise 1.118.
Consider the function shown below, which “projects straight down”:
•a
•b
•c
Y B
•
a1
•
c1
•
c2
X B
f

A.1. SOLUTIONS FOR CHAPTER 1
269
1. Let B1 B {a, b} and B2 B {c}. Then f ∗(B1)  {a1} and f ∗(B2)  {c1, c2}.
2. Let A1 B  and A2 B {a1, c1}. Then f!(A1)   and f!(A2)  {a, c}.
3. With the same A1 and A2, we compute f∗(A1)  {b} and f∗(A2)  {a, b}.
Solution to Exercise 1.119.
Assume f : P →Q is left adjoint to 1 : Q →P.
1. It is part of the deﬁnition of adjunction (Proposition 1.107) that p ≤1( f (p)), and of course 1( f (p))
and ( f # 1)(p) mean the same thing.
2. We want to show that 1( f (1( f (p)))) ≤1( f (p)) and 1( f (p)) ≤1( f (1( f (p)))) for all p. The latter
is just the fact that p′ ≤1( f (p′)) for any p′, applied with 1( f (p)) in place of p′. The former uses
that f (1(q)) ≤q, with f (p) substituted for q: this gives f (1( f (p))) ≤f (p), and then we apply 1
to both sides.
Solution to Exercise 1.124.
We denote tuples (a, b) by ab for space reasons. So the relation {(1, 1), (1, 2), (2, 1)} will be denoted
{11, 12, 21}.
{11, 12, 21, 22}
{11, 12, 21}
{11, 12, 22}
{11, 21, 22}
{12, 21, 22}
{11, 12}
{11, 21}
{11, 22}
{12, 21}
{12, 22}
{21, 22}
{11}
{12}
{21}
{22}

Solution to Exercise 1.125.
Let S B {1, 2, 3}.
1. Let ≤be the preorder with 1 ≤2, and of course 1 ≤1, 2 ≤2, and 3 ≤3.
Then U(≤) 
{(1, 1), (1, 2), (2, 2), (3, 3)}.
2. Let Q B {(1, 1)} and Q′ B {(2, 1)}.
3. Theclosure Cl(Q)of Q isthesmallest preorder containing(1, 1), which is Cl(Q)  {(1, 1), (2, 2), (3, 3)}.
Similarly, Cl(Q′)  {(1, 1), (2, 1), (2, 2), (3, 3)}. It is easy to see that Cl(Q) ⊑≤because every or-
dered pair in Cl(Q) is also in ≤.
4. It is easy to see that Cl(Q′) @ ≤because the ordered pair (2, 1) is in Cl(Q′) but is not in ≤.

270
APPENDIX A. EXERCISE SOLUTIONS
A.2
Solutions for Chapter 2.
Solution to Exercise 2.5.
The expert is right! The proposal violates property (a) when x1  −1, x2  0, y1  −1, and y2  1.
Indeed −1 ≤−1 and 0 ≤1, but −1 ∗0  0 ≰−1  −1 ∗1.
Solution to Exercise 2.8.
To check that (Disc(M), , ∗, e) is a symmetric monoidal preorder, we need to check our proposed data
obeys conditions (a)-(d) of Deﬁnition 2.2. Condition (a) just states the tautology that x1 ⊗x2  x1 ⊗x2,
conditions (b) and (c) are precisely the equations Eq. (2.7), and (d) is the commutativity condition. So
we’re done. We leave it to you to decide whether we were telling the truth when we said it was easy.
Solution to Exercise 2.20.
1. Here is a line by line proof, where we write the reason for each step in parentheses on the right.
Recall we call the properties (a) and (c) in Deﬁnition 2.2 monotonicity and associativity respectively.
t + u ≤(v + w) + u
(monotonicity, t ≤v + w, u ≤u)
 v + (w + u)
(associativity)
≤v + (x + z)
(monotonicity, v ≤v, w + u ≤x + v)
 (v + x) + z
(associativitiy)
≤y + z.
(monotonicity, v + x ≤y, z ≤z)
2. We use reﬂexivity when we assert that u ≤u, v ≤v and z ≤z, and use transitivity to assert that
the above sequence of inequalities implies the single inequality t + u ≤y + z.
3. We know that the symmetry axiom is not necessary because no pair of wires cross.
Solution to Exercise 2.21.
Condition (a), monotonicity, says that if x →y and z →w are reactions, then x + z →y + w is a
reaction. Condition (b), unitality, holds as 0 represents having no material, and adding no material to
some other material does not change it. Condition (c), associativity, says that when combining three
collections x, y, and z of molecules it doesn’t matter whether you combine x and y and then z, or
combine x with y already combined with z. Condition (d), symmetry, says that combining x with y is
the same as combining y with x. All these are true in our model of chemistry, so (Mat, →, 0, +) forms
a symmetric monoidal preorder.
Solution to Exercise 2.29.
The monoidal unit must be false. The symmetric monoidal preorder does satisfy the rest of the
conditions; this can be veriﬁed just by checking all cases.
Solution to Exercise 2.31.
The monoidal unit is the natural number 1. Since we know that (N, ≤) is a preorder, we just need to
check that ∗is monotonic, associative, unital with 1, and symmetric. These are all familiar facts from
arithmetic.
Solution to Exercise 2.33.
This proposal is not monotonic: we have 1|1 and 1|2, but (1 + 1) ∤(1 + 2).
Solution to Exercise 2.34.
1.
min
no
maybe
yes
no
no
no
no
maybe
no
maybe
maybe
yes
no
maybe
yes

A.2. SOLUTIONS FOR CHAPTER 2
271
2. We need to show that (a) if x ≤y and z ≤w, then min(x, z) ≤min(y, w), (b) min(x, yes)  x 
min(yes, x), (c) min(min(x, y), z)  min(x, min(y, z)), and (d) min(x, y)  min(y, z). The most
straightforward way is to just check all cases.
Solution to Exercise 2.35.
Yes, (P(S), ≤, S, ∩) is a symmetric monoidal preorder.
Solution to Exercise 2.36.
Depending on your mood, you might come up with either of the following. First, we could take the
monoidal unit to be some statement true that is true for all natural numbers, such as “n is a natural
number.” We can pair this unit with the monoidal product ∧, which takes statements P and Q and
makes the statement P ∧Q, where (P ∧Q)(n) is true if P(n) and Q(n) are true, and false otherwise.
Then (PropN, ≤, true, ∧) forms a symmetric monoidal preorder.
Another option is to take deﬁne false to be some statement that is false for all natural numbers, such
as “n + 10 ≤1” or “n is made of cheese.” We can also deﬁne ∨such that (P ∨Q)(n) is true if and only if
at least one of P(n) and Q(n) is true. Then (PropN, ≤, false, ∨) forms a symmetric monoidal preorder.
Solution to Exercise 2.39.
Unitality and associativity have nothing to do with the order in Xop: they simply state that I ⊗x 
x  x ⊗I, and (x ⊗y) ⊗z  x ⊗(y ⊗z). Since these are true in X, they are true in Xop. Symmetry is
slightly trickier, since in only asks that x ⊗y is equivalent to y ⊗x. Nonetheless, this is still true in Xop
because it is true in X. Indeed the fact that (x ⊗y)  (y ⊗x) in X means that (x ⊗y) ≤(y ⊗x) and
(y ⊗x) ≤(x ⊗y) in X, which respectively imply that (y ⊗x) ≤(x ⊗y) and (x ⊗y) ≤(y ⊗x) in Xop, and
hence that (x ⊗y)  (y ⊗x) in Xop too.
Solution to Exercise 2.40.
1. The preorder Costop has underlying set [0, ∞], and the usual increasing order on real numbers
≤as its order.
2. Its monoidal unit is 0.
3. Its monoidal product is +.
Solution to Exercise 2.43.
1. The map 1 is monotonic as 1(false)  ∞≥0  1(true), satisﬁes condition (a) since 0 ≥0 
1(true), and satisﬁes condition (b) since
1(false) + 1(false)  ∞+ ∞≥∞ 1(false ∧false)
1(false) + 1(true)  ∞+ 0 ≥∞ 1(false ∧true)
1(true) + 1(false)  0 + ∞≥∞ 1(true ∧false)
1(true) + 1(true)  0 + 0 ≥0  1(true ∧true).
2. Since all the inequalities regarding (a) and (b) above are in fact equalities, 1 is a strict monoidal
monotone.
Solution to Exercise 2.44.
The answer to all these questions is yes: d and u are both strict monoidal monotones. Here is one way
to interpret this. The function d asks ‘is x  0?’. This is monotonic, 0 is 0, and the sum of two elements
of [0, ∞] is 0 if and only if they are both 0. The function u asks ‘is x ﬁnite?’. Similarly, this is monotonic,
0 is ﬁnite, and the sum of x and y is ﬁnite if and only if x and y are both ﬁnite.
Solution to Exercise 2.45.
1. Yes, multiplication is monotonic in ≤, unital with respect to 1, associative, and symmetric, so
(N, ≤, 1, ∗) is a monoidal preorder. We also met this preorder in Exercise 2.31.

272
APPENDIX A. EXERCISE SOLUTIONS
2. The map f (n)  1 for all n ∈N deﬁnes a monoidal monotone f : (N, ≤, 0, +) →(N, ≤, 1, ∗). (In
fact, it is unique! Why?)
3. (Z, ≤, ∗, 1) is not a monoidal preorder because ∗is not monotone. Indeed −1 ≤0 but (−1 ∗−1) ≰
(0 ∗0).
Solution to Exercise 2.50.
1. Let (P, ≤) be a preorder. How is this a Bool-category? Following Example 2.47, we can construct
a Bool-category XP with P as its set of objects, and with XP(p, q) B true if p ≤q, and XP(p, q) B
false otherwise. How do we turn this back into a preorder? Following the proof of Theorem 2.49,
we construct a preorder with underlying set Ob(XP)  P, and with p ≤q if and only if XP(p, q) 
true. This is precisely the preorder (P, ≤)!
2. Let X be a Bool-category. By the proof of Theorem 2.49, we construct a preorder (Ob(X), ≤),
where x ≤y if and only if X(x, y)  true. Then, following our generalization of Example 2.47 in
1., we construct a Bool-category X′ whose set of objects is Ob(X), and such that X′(x, y)  true
if and only if x ≤y in (Ob(X), ≤). But by construction, this means X′(x, y)  X(x, y). So we get
back the Bool-category we started with.
Solution to Exercise 2.52.
The distance d(US, Spain) is bigger: the distance from, for example, San Diego to anywhere is Spain is
bigger than the distance from anywhere in Spain to New York City.
Solution to Exercise 2.55.
The diﬀerence between a Lawvere metric space—that is, a category enriched over ([0, ∞], ≥, 0, +)—and
a category enriched over (R≥0, ≥, 0, +) is that in the latter, inﬁnite distances are not allowed between
points. You might thus call the latter a ﬁnite-distance Lawvere metric space.
Solution to Exercise 2.58.
The table of distances for X is
d(↗)
A
B
C
D
A
0
6
3
11
B
2
0
5
5
C
5
3
0
8
D
11
9
6
0
Solution to Exercise 2.60.
The matrix of edge weights of X is
MX 
↗
A
B
C
D
A
0
∞
3
∞
B
2
0
∞
5
C
∞
3
0
∞
D
∞
∞
6
0
Solution to Exercise 2.61.
A NMY-category X is a set X together with, for all pairs of elements x, y in X, a value X(x, y) equal
to no, maybe, or yes. Moreover, we must have X(x, x)  yes and min(X(x, y), X(y, z)) ≤X(x, z) for all
x, y, z. So a NMY-category can be thought of as set of points together with an statement—no, maybe,
or yes—of whether it is possible to get from one point to another. In particular, it’s always possible to
get to a point if you’re already there, and it’s as least as possible to get from x to z as it is to get from x
to y and then y to z.
Solution to Exercise 2.62.
Here is one way to do this task.

A.2. SOLUTIONS FOR CHAPTER 2
273
1.
A•
B•
•
C
•
D
{boat}
{boat}
{foot, boat}
{foot, car}
{foot, car}
2. The corresponding M-category, call it X, has hom-objects:
X(↗)
A
B
C
D
A
M
{boat}

{boat}
B

M

{boat}
C
{foot, boat}
{boat}
M
M
D
{foot}

{foot, car}
M
For example, to compute the hom-object X(C, D), we notice that there are two paths: C →A →
B →D and C →D. For the ﬁrst path, the intersection is the set {boat}. For the second path, the
intersection in the set {foot, car}. Their union, and thus the hom-object X(C, D), is the entire set
M.
This computation contains the key for why X is a M-category: by taking the union over all paths,
we ensure that X(x, y) ∩X(y, z) ⊆X(x, z) for all x, y, z.
3. The person’s interpretation looks right to us.
Solution to Exercise 2.63.
1.
A•
•
B
•
C
5
10
10
6
10
2. The matrix M with (x, y)th entry equal to the maximum, taken over all paths p from x to y, of
the minimum edge label in p is
M(↗)
A
B
C
A
∞
6
10
B
10
∞
10
C
10
6
∞
3. This is a matrix of hom-objects for a W-category since the diagonal values are all equal to the
monoidal unit ∞, and because min(M(x, y), M(y, z)) ≤M(x, y) for all x, y, z ∈{A, B, C}.
4. One interpretation is as a weight limit (not to be confused with ‘weighted limit,’ a more advanced
categorical notion), for example for trucking cargo between cities. The hom-object indexed by
a pair of points (x, y) describes the maximum cargo weight allowed on that route. There is no
weight limit on cargo that remains at some point x, so the hom-object from x to x is always
inﬁnite. The maximum weight that can be trucked from x to z is always at least the minimum of
that that can be trucked from x to y and then y to z. (It is ‘at least’ this much because there may
be some other, better route that does not pass through y.)
Solution to Exercise 2.67.
•
Boston
•
US
•
Spain

274
APPENDIX A. EXERCISE SOLUTIONS
This preorder describes the ‘is a part of’ relation. That is, x ≤y when d(x, y)  0, which happens when
x is a part of y. So Boston is a part of the US, and Spain is a part of Spain, but the US is not a part of
Boston.
Solution to Exercise 2.68.
1. Recall the monoidal monotones d and u from Exercise 2.44. The function f is equal to d; let 1 be
equal to u.
2. Let X be the Lawvere metric space with two objects A and B, such that d(A, B)  d(B, A)  5.
Then we have X f 
A•
B•
while X1 
A•
B• .
Solution to Exercise 2.73.
1. An extended metric space is a Lawvere metric space that obeys in addition the properties (b) if
d(x, y)  0 then x  y, and (c) d(x, y)  d(y, x) of Deﬁnition 2.51. Let’s consider the dagger
condition ﬁrst. It says that the identity function to the opposite Cost-category is a functor, and
so for all x, y we must have d(x, y) ≤d(y, x). But this means also that d(y, x) ≤d(x, y), and so
d(x, y)  d(y, x). This is exactly property (c).
Now let’s consider the skeletality condition. This says that if d(x, y)  0 and d(y, x)  0, then
x  y. Thus when we have property (c), d(x, y)  d(y, x), this is equivalent to property (b). Thus
skeletal dagger Cost-categories are the same as extended metric spaces!
2. Recall from Exercise 1.73 that skeletal dagger preorders are sets. The analogy “preorders are
to sets as Lawvere metric spaces are to extended metric spaces” is thus the observation that
just as extended metric spaces are skeletal dagger Cost-categories, sets are skeletal dagger Bool-
categories.
.
Solution to Exercise 2.75.
1. Let (x, y) ∈X × Y. Since X and Y are V-categories, we have I ≤X(x, x) and I ≤Y(y, y). Thus
I  I ⊗I ≤X(x, x) ⊗Y(y, y)  (X × Y) (x, y), (x, y)
.
2. Using the deﬁnition of product hom-objects, and the symmetry and monotonicity of ⊗we have
(X × Y) (x1, y1), (x2, y2)
⊗(X × Y) (x2, y2), (x3, y3)
 X(x1, x2) ⊗Y(y1, y2) ⊗X(x2, x3) ⊗Y(y2, y3)
 X(x1, x2) ⊗X(x2, x3) ⊗Y(y1, y2) ⊗Y(y2, y3)
≤X(x1, x3) ⊗Y(y1, y3)
 (X × Y) (x1, y1), (x3, y3)
.
3. In particular, we use the symmetry, to conclude that Y(y1, y2) ⊗X(x2, x3)  X(x2, x3) ⊗Y(y1, y2).
Solution to Exercise 2.78.
We just apply Deﬁnition 2.74(ii): (R × R) (5, 6), (−1, 4)
 R(5, −1) + R(6, 4)  6 + 2  8.
Solution to Exercise 2.82.
1. The function −⊗v : V →V is monotone, because if u ≤u′ then u ⊗v ≤u′⊗v by the monotonicity
condition (a) in Deﬁnition 2.2.
2. Let a B (v ⊸w) in Eq. (2.80). The right hand side is thus (v ⊸w) ≤(v ⊸w), which is true by
reﬂexivity. Thus the left hand side is true too. This gives ((v ⊸w) ⊗v) ≤w.
3. Let u ≤u′.
Then, using 2., (v ⊸u) ⊗v ≤u ≤u′.
Applying Eq. (2.80), we thus have
(v ⊸u) ≤(v ⊸u′). This shows that the map (v ⊸−): V →V is monotone.
4. Eq. (2.80) is exactly the adjointness condition from Deﬁnition 1.95, except for the fact that we do
not know (−⊗v) and (v ⊸−) are monotone maps. We proved this, however, in items 1 and 3
above.

A.2. SOLUTIONS FOR CHAPTER 2
275
Solution to Exercise 2.84.
We need to ﬁnd the hom-element. This is given by implication. That is, deﬁne the function x ⇒y by
the table
⇒
false
true
false
true
true
true
false
true
Then (a ∧v) ≤w if and only if a ≤(v ⇒w). Indeed, if v  false then a ∧false  false, and so the
left hand side is always true. But (false ⇒w)  true, so the right hand side is always true too. If
v  true, then a ∧true  a so the left hand side says a ≤w. But (true ⇒w)  w, so the right hand
side is the same. Thus ⇒deﬁnes a hom-element as per Eq. (2.80).
Solution to Exercise 2.93.
We showed in Exercise 2.84 that Bool is symmetric monoidal closed, and in Exercise 1.7 and Exam-
ple 1.88 that the join is given by the OR operation ∨. Thus Bool is a quantale.
Solution to Exercise 2.94.
Yes, the powerset monoidal preorder (P(S), ⊆, S, ∩) is a quantale. The hom-object B ⊸C is given by
B ∪C, where B is the complement of B: it contains all elements of S not contained in B. To see that this
satisﬁes Eq. (2.80), note that if (A ∩B) ⊆C, then
A  (A ∩B) ∪(A ∩B) ⊆B ∪C.
On the other hand, if A ⊆(B ∪C), then
A ∩B ⊆(B ∪C) ∩B  (B ∩B) ∪(C ∩B)  C ∩B ⊆C.
So (P(S), ⊆, S, ∩) is monoidal closed. Furthermore, joins are given by union of subobjects, so it is a
quantale.
Solution to Exercise 2.92.
1a. In Bool, (Ô )  false, the least element.
1b. In Cost, (Ô )  ∞. This is because we use the opposite order ≥on [0, ∞], so Ô  is the greatest
element of [0, ∞]. Note that in this case our convention from Deﬁnition 2.90, where we denote
(Ô )  0, is a bit confusing! Beware!
2a. In Bool, x ∨y is the usual join, OR.
2b. In Cost, x ∨y is the minimum min(x, y). Again because we use the opposite order on [0, ∞], the
join is the greatest number less than or equal to x and y.
Solution to Exercise 2.103.
The 2 × 2-identity matrices for (N, ≤, 1, ∗), Bool, and Cost are respectively
1
0
0
1

,
 true
false
false
true

,
and
 0
∞
∞
0

.
Solution to Exercise 2.104.
1. We ﬁrst use Proposition 2.87 (2) and symmetry to show that for all v ∈V, 0 ⊗v  0.
0 ⊗v  v ⊗0 

v ⊗
Ü
a∈
a


Ü
a∈
(v ⊗a)  0.

276
APPENDIX A. EXERCISE SOLUTIONS
Then we may just follow the deﬁnition in Eq. (2.101):
IX ∗M(x, y) 
Ü
x′∈X
IX(x, x′) ⊗M(x′, y)
  IX(x, x) ⊗M(x, y)
∨©­
«
Ü
x′∈X,x′,x
IX(x, x′) ⊗M(x′, y)ª®
¬
  I ⊗M(x, y)
∨©­
«
Ü
x′∈X,x′,x
0 ⊗M(x′, y)ª®
¬
 M(x, y) ∨0  M(x, y).
2. This again follows from Proposition 2.87 (2) and symmetry, making use also of the associativity
of ⊗:
((M ∗N) ∗P)(w, z) 
Ü
y∈Y
 Ü
x∈X
M(w, x) ⊗N(x, y)

⊗P(y, z)

Ü
y∈Y,x∈X
M(w, x) ⊗N(x, y) ⊗P(y, z)

Ü
x∈X
M(w, x) ⊗
 Ü
y∈Y
N(x, y) ⊗P(y, z)

 (M ∗(N ∗P))(w, z).
Solution to Exercise 2.105.
We have the matrices
MX 
©­­­­
«
0
∞
3
∞
2
0
∞
5
∞
3
0
∞
∞
∞
6
0
ª®®®®
¬
M2
X 
©­­­­
«
0
6
3
∞
2
0
5
5
5
3
0
8
∞
9
6
0
ª®®®®
¬
M3
X  M4
X 
©­­­­
«
0
6
3
11
2
0
5
5
5
3
0
8
11
9
6
0
ª®®®®
¬

A.3. SOLUTIONS FOR CHAPTER 3
277
A.3
Solutions for Chapter 3.
Solution to Exercise 3.3.
There are ﬁve non-ID columns in Eq. (3.1)and ﬁve arrows in Eq. (3.2). This is not a coincidence: there
is always one arrow for every non-ID column.
Solution to Exercise 3.9.
To do this precisely, we should deﬁne concatenation technically. If G  (V, A, s, t) is a graph, deﬁne a
path in G to be a tuple of the form (v, a1, . . . , an) where v ∈V is a vertex, s(a1)  v, and t(ai)  s(ai+1)
for all i ∈{1, . . . , n −1}; the length of this path is n, and this deﬁnition makes sense for any n ∈N. We
say that the source of p is s(p) B v and the target of p is deﬁned to be
t(p) B
(
v if n  0
t(an) if n ≥1
Two paths p  (v, a1, . . . , am) and q  (w, b1, . . . , bn) can be concatenated if t(p)  s(q), in which case
the concatenated path p # q is deﬁned to be
(p # q) B (v, a1, . . . , am, b1, . . . , bn).
We are now ready to check unitality and associativity. A path p is an identity in Free(G) iﬀp  (v)
for some v ∈V. It is easy to see from the above that (v) and (w, b1, . . . , bn) can be concatenated iﬀ
v  w, in which case the result is (w, b1, . . . , bn). Similarly (v, a1, . . . , am) and (w) can be concatenated
iﬀw  t(am), in which case the result is (v, a1, . . . , am). Finally, for associativity with p and q as above
and r  (x, c1, . . . , co), the formula readily reads that whichever way they are concatenated, (p # q) # r
or p # (q # r), the result is
(v, a1, . . . , am, b1, . . . , bn, c1, . . . , co).
Solution to Exercise 3.10.
We often like to name identity morphisms by the objects they’re on, and we do that here: v2 means
idv2. We write ⊠when the composite does not make sense (i.e. when the target of the ﬁrst morphism
does not agree with the source of the second).
↗
v1
f1
f1 # f2
v2
f2
v3
v1
v1
f1
f1 # f2
⊠
⊠
⊠
f1
⊠
⊠
⊠
f1
f1 # f2
⊠
f1 # f2
⊠
⊠
⊠
⊠
⊠
f1 # f2
v2
⊠
⊠
⊠
v2
f2
⊠
f2
⊠
⊠
⊠
⊠
⊠
f2
v3
⊠
⊠
⊠
⊠
⊠
v3
Solution to Exercise 3.12.
1. The category 1 has one object v1 and one morphism, the identity idv1.
2. The category 0 is empty; it has no objects and no morphisms.
3. The pattern for number of morphisms in 0, 1, 2, 3 is 0, 1, 3, 6; does this pattern look familiar?
These are the ﬁrst few ‘triangle numbers,’ so we could guess that the number of morphisms in n,
the free category on the following graph
v1•
v2•
· · ·
vn•
f1
f2
fn−1
is 1 + 2 + · · · + n. This makes sense because (and the proof strategy would be to verify that) the
above graph has n paths of length 0, it has n −1 paths of length 1, and so on: it has n −i paths
of length i for every 0 ≤i ≤n.

278
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 3.15.
The correspondence was given by sending a path to its length. Concatenating a path of length m with
a path of length n results in a path of length m + n.
Solution to Exercise 3.16.
Free_square B
A•
B•
•
C
•
D
f
1
h
i
no equations
1. The ten paths are as follows
A,
A # f ,
A # 1,
A # f # h,
A # 1 # i,
B,
B # h,
C,
C # i,
D
2. A # f # h is parallel to A # 1 # i, in that they both have the same domain and both have the same
codomain.
3. A is not parallel to any of the other nine paths.
Solution to Exercise 3.17.
The morphisms in the given diagram are as follows:
A,
A # f ,
A # 1,
A # j,
B,
B # h,
C,
C # i,
D
Note that A # f # h  j  A # 1 # i.
Solution to Exercise 3.19.
There are four morphisms in D, shown below, namely z, s, s # s, and s # s # s:
D B
•z
s
s # s # s # s  s # s
Solution to Exercise 3.21.
The equations that make the graphs into preorders are shown below
G1 
•
•
f
1
f  1
G2 
•a
f
f  a
G3 
•
•
•
•
f
1
h
i
f # h  1 # i
G4 
•
•
•
•
f
1
h
no equations
Solution to Exercise 3.22.
The preorder reﬂection of a category C has the same objects and either one morphism or none between
two objects, depending on whether or not a morphism between them exists in C. So the preorder
reﬂection of N has one object and one morphism from it to itself, which must be the identity. In other
words, the preorder reﬂection of N is 1.

A.3. SOLUTIONS FOR CHAPTER 3
279
Solution to Exercise 3.25.
A function f : 2 →3 can be described as an ordered pair ( f (1), f (2)). The nine such functions are
given by the following ordered pairs, which we arrange into a 2-dimensional grid with 3 entries in each
dimension, just for “funzies”:1
(1, 1)
(1, 2)
(1, 3)
(2, 1)
(2, 2)
(2, 3)
(3, 1)
(3, 2)
(3, 3)
Solution to Exercise 3.30.
1. The inverse to f (a)  2, f (b)  1, f (c)  3 is given by
f −1(1)  b,
f −1(2)  a,
f −1(3)  c.
2. There are 6 distinct isomorphisms. In general, if A and B are sets, each with n elements, then the
number of isomorphisms between them is n-factorial, often denoted n!. So for example there are
5 ∗4 ∗3 ∗2 ∗1  120 isomorphisms between {1, 2, 3, 4, 5} and {a, b, c, d, e}.
Solution to Exercise 3.31.
We have to show that for any object c ∈C, the identity idc has an inverse, i.e. a morphism f : c →c
such that f # idc  idc and idc # f  idc. Take f  idc; this works.
Solution to Exercise 3.32.
1. The monoid in Example 3.13 is not a group, because the morphism s has no inverse. Indeed each
morphism is of the form sn for some n ∈N and composing it with s gives sn+1, which is never
s0.p
2. C from Example 3.18 is a group: the identity is always an isomorphism, and the other morphism
s has inverse s.
Solution to Exercise 3.33.
You may have found a person whose mathematical claims you can trust! Whenever you compose two
morphisms in Free(G), their lengths add, and the identities are exactly those morphisms whose length
is 0. In order for p to be an isomorphism, there must be some q such that p # q  id and q # p  id, in
which case the length of p (or q) must be 0.
Solution to Exercise 3.37.
The other three functors 2 →3 are shown here:
m0•
•
m1
f1
n0•
n1•
n2•
11
12
m0•
•
m1
f1
n0•
n1•
n2•
11
12
m0•
•
m1
f1
n0•
n1•
n2•
11
12
Solution to Exercise 3.39.
There are nine morphisms in F; as usual we denote identities by the object they’re on. These morphisms
are sent to the following morphisms in C:
A′ 7→A,
f ′ 7→f ,
1′ 7→1,
f ′ # h′ 7→f # h,
1′ # i′ 7→f # h,
B′ 7→B,
h′ 7→h,
C′ 7→C,
i′ 7→i,
D′ 7→D.
1Of course, this is not mere funzies; this is category theory!

280
APPENDIX A. EXERCISE SOLUTIONS
If one of these seems diﬀerent from the rest, it’s probably 1′ # i′ 7→f # h. But note that in fact also
1′ # i′ 7→1 # i because 1 # i  f # h, so it’s not an outlier after all.
Solution to Exercise 3.40.
We need to give two functors F, G from
a•
f
−→
b• to
a′
•
f1
f2
b′
• whose on-objects parts are the same and
whose on-morphisms parts are diﬀerent. There are only two ways to do this, and we choose one of
them:
F(a) B a′,
G(a) B a′,
F(b) B b′,
G(b) B b′,
F( f ) B f1, and G( f ) B f2.
The other way reverses f1 and f2.
Solution to Exercise 3.43.
1. Let C be a category. Then deﬁning idC : C →C by idC(x)  x for every object and morphism in
C is a functor because it preserves identities idC(idc)  idc  ididC(c) for each object c ∈Ob(C),
and it preserves composition idC( f # 1)  f # 1  idC( f ) # idC(1) for each pair of composable
morphisms f , 1 in C.
2. Given functors F : C →D and G: D →E, we need to show that F # G is a functor, i.e. that
it preserves preserves identities and compositions.
If c ∈C is an object then (F # G)(idc) 
G(F(idc))  G(idF(c))  idG(F(c)) because F and G preserve identities. If f , 1 are composable
morphisms in C then
(F # G)( f # 1)  G(F( f ) # F(1))  G(F( f )) # G(F(1))
because F and G preserve composition.
3. We have proposed objects, morphisms, identities, and a composition formula for a category Cat:
they are categories, functors, and the identities and compositions given above. We need to check
that the two properties, unitality and associativity, hold. So suppose F : C →D is a functor
and we pre-compose it as above with idC; it is easy to see that the result will again be F, and
similarly if we post-compose F with idD. This gives unitality, and associativity is just as easy,
though more wordy. Given F as above and G: D →E and H : E →F, we need to show that
(F # G) # H  F # (G # H). It’s a simple application of the deﬁnition: for any x ∈C, be it an object
or morphism, we have
((F # G) # H)(c)  H((F # G)(c))  H(G(F(c)))  (G # H)(F(c))  (F # (G # H))(c).
Solution to Exercise 3.45.
Let S ∈Set be a set. Deﬁne FS : 1 →Set by FS(1)  S and FS(id1)  idS. With this deﬁnition, FS
preserves identities and compositions (the only compositions in 1 is the composite of the identity with
itself), so FS is a functor with FS(1)  S as desired.
Solution to Exercise 3.48.
We are asked what sort of data “makes sense” for the schemas below?
1.
•z
s
s # s  z
2.
a•
b•
c•
f
1
h
f # 1  f # h
This is a subjective question, so we propose an answer for your consideration.
1. Data on this schema, i.e. a set-valued functor, assigns a set D(z) and a function D(s): D(z) →D(z),
such that applying that function twice is the identity. This sort of function is called an involution
of the set Dz:
•
•
•
•
•
•
•
•
•
•

A.3. SOLUTIONS FOR CHAPTER 3
281
It’s a do-si-do, a “partner move,” where everyone picks a partner (possibly themselves) and
exchanges with them. One example one could take D to be the set of pixels in a photograph, and
take s to be the function sending each pixel to its mirror image across the vertical center line of
the photograph.
2. We could make D(c) the set of people at a “secret Santa” Christmas party, where everyone gives
a gift to someone, possibly themselves. Take D(b) to be the set of gifts, 1 the giver function (each
gift is given by a person), and h the receiver function (each gift is received by a person), D(a) is
the set of people who give a gift to themselves, and d( f ): D(a) →D(b) is the inclusion.
Solution to Exercise 3.55.
1. The expert packs so much information in so little space! Suppose given three objects F, G, H ∈DC;
these are functors F, G, H : C →D. Morphisms α: F →G and β: G →H are natural transfor-
mations. Most beginners seem to think about a natural transformation in terms of its naturality
squares, but the main thing to keep in mind is its components; the naturality squares constitute
a check that comes later.
So for each c ∈C, α has a component αc : F(c) →G(c) and β has a component βc : G(c) →H(c)
in D. The expert has told us to deﬁne (α # β)c B (αc # βc), and indeed that is a morphism
F(c) →H(c).
Now we do the check. For any f : c →c′ in C, the inner squares of the following diagram
commute because α and β are natural; hence the outer rectangle does too:
F(c)
G(c)
H(c)
F(c′)
G(c′)
H(c′)
αc
F( f )
βc
G( f )
H( f )
αc
βc
2. We propose that the identity natural transformation idF on a functor F : C →D has as its
c-component the morphism (idF)c B idF(c) in D, for any c. The naturality square
F(c)
F(c)
F(c′)
F(c′)
idF(c)
F( f )
F( f )
idF(c′)
obviously commutes for any f : c →c′. And it is unital: post-composing idF with any β: F →G
(and similarly for precomposing with any α: E →F) results in a natural transformation idF # β
with components (idF)c # βc  (idF(c) # βc)  βc, and this is just β as desired.
Solution to Exercise 3.58.
We have a category C and a preorder P, considered as a category.
1. Suppose that F, G: C →P are functors and α, β: F →G are natural transformations; we need to
show that α  β. It suﬃces to check that αc  βc for each object c ∈Ob(C). But αc and βc are
morphisms F(c) →G(c) in P, which is a preorder, and the deﬁnition of a preorder—considered
as a category—is that it has at most one morphism between any two objects. Thus αc  βc, as
desired.
2. This is false. Let P B 1, let C B
a•
f1
f2
b• , let F(1) B a, let G(1) B b, let α1 B f1, and let β1 B 12.

282
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 3.62.
We need to write down the following
Employee
•
Department
•
string
◦
WorksIn
FName
Mngr
Secr
DName
as a Gr-instance, as in Eq. (3.61). The answer is as follows:
Arrow
source
target
Mngr
Employee
Employee
WorksIn
Employee
Department
Secr
Department
Employee
FName
Employee
string
DName
Department
string
Vertex
Department
Employee
string
Solution to Exercise 3.64.
Let G, H be the following graphs:
G B
1•
2•
3•
a
b
H B
4•
5•
c
d
e
and let’s believe the authors that there is a unique graph homomorphism α: G →H for which
αArrow(a)  d.
1. We have αArrow(b)  e and αVertex(1)  4, αVertex(2)  5, and αVertex(3)  5.
2. We roughly copy the tables and then draw the lines (shown in black; ignore the dashed lines for
now):
a
1
2
1
b
2
3
2
3
c
4
5
4
d
4
5
5
e
5
5
t
t
3. It works! One example of the naturality is shown with the help of dashed blue lines above. See
how both paths starting at a end at 5?
Solution to Exercise 3.67.
We just need to write out the composite of the following functors
Arrow
•
Vertex
•
source
target
Gr
State
•
next
DDS
G
Set
State
next
1
4
2
4
3
5
4
5
5
5
6
7
7
6

A.3. SOLUTIONS FOR CHAPTER 3
283
in the form of a database, and then draw the graph. The results are given below.
Arrow
source
target
1
4
1
2
4
2
3
5
3
4
5
4
5
5
5
6
7
6
7
6
7
Vertex
1
2
3
4
5
6
7
1•
2•
3•
4•
6•
7•
•
5
1
2
3
4
6
7
5
Solution to Exercise 3.73.
We are interested in how the functors −× B and (−)B should act on morphisms for a given set B.
We didn’t specify this in the text—we only speciﬁed −× B and (−)B on objects—so in some sense
this exercise is open: you can make up anything you want, under the condition that it is functorial.
However, the authors cannot think of any such answers except the one we give below.
1. Given an arbitrary function f : X →Y, we need a function X × B →Y × B. We suggest the
function which might be denoted f × B; it sends (x, b) to ( f (x), b). This assignment is functorial:
applied to idX it returns idX×B and it preserves composition.
2. Given a function f : X →Y, we need a function XB →YB. The canonical function would
be denoted f B; it sends a function 1 : B →X to the composite (1 # f ): B →X →Y. This is
functorial: applied to idX it sends 1 to 1, i.e. f B(idX)  idXB, and applied to the composite
( f1 # f2): X →Y →Z, we have
( f1 # f2)B(1)  1 # ( f1 # f2)  (1 # f1) # f2  ( f B
1 # f B
2 )(1)
for any 1 ∈XB.
3. If p : N →NN is the result of currying +: N × N →N, then p(3) is an element of NN, i.e. we have
p(3): N →N; what function is it? It is the function that adds three. That is p(3)(n) B n + 3.
Solution to Exercise 3.76.
The functor !: C →1 from Eq. (3.75) sends each object c ∈C to the unique object 1 ∈1 and sends each
morphism f : c →d in C to the unique morphism id1 : 1 →1 in 1.
Solution to Exercise 3.78.
We want to draw the graph corresponding to the instance I : G →Set shown below:
Email
sent_by
received_by
Em_1
Bob
Grace
Em_2
Grace
Pat
Em_3
Bob
Emory
Em_4
Sue
Doug
Em_5
Doug
Sue
Em_6
Bob
Bob
Address
Bob
Doug
Emory
Grace
Pat
Sue
Here it is, with names and emails shortened (e.g. B=Bob, 3=Em_3):
E
B
G
P
S
D
1
3
6
2
4
5
Solution to Exercise 3.81.
An object z is terminal in some category C if, for every c ∈C there exists a unique morphism c →z.
When C is the category underlying a preorder, there is at most one morphism between any two objects,

284
APPENDIX A. EXERCISE SOLUTIONS
so the condition simpliﬁes: an object z is terminal iﬀ, for every c ∈C there exists a morphism c →z.
The morphisms in a preorder are written with ≤signs, so z is terminal iﬀ, for every c ∈P we have
c ≤z, and this is the deﬁnition of top element.
Solution to Exercise 3.82.
The terminal object in Cat is 1 because by Exercise 3.76 there is a unique morphism (functor) C →1 for
any object (category) C ∈Cat.
Solution to Exercise 3.83.
Consider the graph 2V B
• • with two vertices and no arrows, and let C  Free(2V); it has two
objects and two morphisms (the identities). This category does not have a terminal object because it
does not have any morphisms from one object to the other.
Solution to Exercise 3.88.
A product of x and y in P is an object z ∈P equipped with maps z →x and z →y such that for any
other object z′ and maps z′ →x and z′ →y, there is a unique morphism z′ →z making the evident
triangles commute. But in a preorder, the maps are denoted ≤, they are unique if they exist, and all
diagrams commute. Thus the above becomes: a product of x and y in P is an object z with z ≤x and
z ≤y such that for any other z′, if z′ ≤x and z′ ≤y then z′ ≤z. This is exactly the deﬁnition of meet,
z  x ∧y.
Solution to Exercise 3.90.
1. The identity morphism on the object (c, d) in the product category C × D is (idc, idd).
2. Suppose given three composable morphisms in C × D
(c1, d1)
( f1,11)
−−−−−→(c2, d2)
( f2,12)
−−−−−→(c3, d3)
( f3,13)
−−−−−→(c4, d4).
We want to check that (( f1, 11)#( f2, 12))#( f3, 13)  ( f1, 11)#(( f2, 12)#( f3, 13)). But composition in
a product category is given component-wise. That means the left-hand side is (( f1 # f2) # f3, (11 #
12) # 13), whereas the right-hand side is ( f1 # ( f2 # f3), 11 # (12 # 13)), and these are equal because
both C and D individually have associative composition.
3. The product category 1 × 2 has two objects (1, 1) and (1, 2) and one non-identity morphism
(1, 1) →(1, 2). It is not hard to see that it looks the same as 2. In fact, for any C there is an
isomorphism of categories 1 × C  C.
4. Let P and Q be preorders, let X  P × Q be their product preorder as deﬁned in Example 1.56,
and let P, Q, and X be the corresponding categories. Then X  P × Q.
Solution to Exercise 3.91.
A product of X and Y is an object Z equipped with morphisms X
pX
←−−Z
pY
−−→Y such that for any other
object Z′ equipped with morphisms X
p′
X
←−−Z′ p′
Y
−−→Y, there is a unique morphism f : Z′ →Z making
the triangles commute, f # pX  p′
X and f # pY  p′
Y. But “an object equipped with morphisms to X
and Y” is exactly the deﬁnition of an object in Cone(X, Y), and a morphism f making the triangles
commute is exactly the deﬁnition of a morphism in Cone(X, Y). So the deﬁnition above becomes: a
product of X and Y is an object Z ∈Cone(X, Y) such that for any other object Z′ there is a unique
morphism Z′ →Z in Cone(X, Y). This is exactly the deﬁnition of Z being terminal in Cone(X, Y).
Solution to Exercise 3.97.
Suppose J is the graph
v1•
v2•
and D : J →Set is given by two sets, D(v1)  A and D(v2)  B for sets
A, B. The product of these two sets is A × B. Let’s check that the limit formula in Theorem 3.95 gives
the same answer. It says
lim
J D B

(d1, . . . , dn) | di ∈D(vi) for all 1 ≤i ≤n and
for all a : vi →vj ∈A, we have D(a)(di)  dj
	
.

A.3. SOLUTIONS FOR CHAPTER 3
285
But in our case n  2, there are no arrows in the graph, and D(v1)  A and D(v2)  B. So the formula
reduces to
lim
J D B

(d1, d2) | d1 ∈A and d2 ∈B
	
.
which is exactly the deﬁnition of A × B.
Solution to Exercise 3.101.
Given a functor F : C →D, we deﬁne its opposite Fop : Cop →Dop as follows. For each object c ∈
Ob(Cop)  Ob(C), put Fop(c) B F(c). For each morphism f : c1 →c2 in Cop, we have a corresponding
morphism f ′: c2 →c1 in C and thus a morphism F( f ′): F(c2) →F(c1) in D, and thus a morphism
F( f ′)′: Fop(c1) →Fop(c2). Hence we can deﬁne Fop( f ) B F( f ′)′. Note that the primes (−′) are pretty
meaningless, we only put them there to diﬀerentiate between things that are very closely related.
It is easy to check that our deﬁnition of Fop is functorial: it sends identities to identities and composites
to composites.

286
APPENDIX A. EXERCISE SOLUTIONS
A.4
Solutions for Chapter 4.
Solution to Exercise 4.4.
1. The Hasse diagram for Xop × Y is shown here (ignore the colors):
(category, nothing)
(monoid, nothing)
(preorder, nothing)
(category, this book)
(monoid, this book)
(preorder, nothing)
2. There is a profunctor Λ: X
Y, i.e. a functor Xop × Y →B, such that, in the picture above, blue
is sent to true and black is sent to false, i.e.
Λ(monoid, nothing)  Λ(monoid, this book)
 Λ(preorder, this book)
 Λ(category, this book)  true
Λ(preorder, nothing)  Λ(category, nothing)  false.
The preorder Xop × Y describes tasks in decreasing diﬃculty. For example, (we hope) it is easier for
my aunt to explain a monoid given this book than for her to explain a monoid without this book. The
profunctor Λ describes possible states of knowledge for my aunt: she can describe monoids without
help, categories with help from the book, etc. It is an upper set because we assume that if she can do a
task, she can also do any easier task.
Solution to Exercise 4.7.
We’ve done this one before! We hope you remembered how to do it. If not, see Exercise 2.84.
Solution to Exercise 4.9.
Recall from Deﬁnition 2.41 that a V-functor Φ: Xop × Y →V is a function Φ: Ob(Xop × Y) →Ob(V)
such that for all (x, y) and (x′, y′) in Xop × Y we have
(Xop × Y) (x, y), (x′, y′)
≤V Φ(x, y), Φ(x′, y′)
.
Using the deﬁnitions of product V-category (Deﬁnition 2.74) and opposite V-category (Exercise 2.73)
on the left hand side, and using Remark 2.89, which describes how we are viewing the quantale V as
enriched over itself, on the right hand side, this unpacks to
X(x′, x) ⊗Y(y, y′) ≤Φ(x, y) ⊸Φ(x′, y′)
Using symmetry of ⊗and the deﬁnition of hom-element, Eq. (2.80), we see that Φ is a profunctor if and
only if
X(x′, x) ⊗Φ(x, y) ⊗Y(y, y′) ≤Φ(x′, y′).
Solution to Exercise 4.10.
Yes, since a Bool-functor is exactly the same as a monotone map, the deﬁnition of Bool-profunctor and
that of feasibility relation line up perfectly!
Solution to Exercise 4.12.
The feasibility matrix for Φ is
Φ
a
b
c
d
e
N
true
false
true
false
true
E
true
true
true
true
true
W
true
false
true
false
true
S
true
true
true
true
true

A.4. SOLUTIONS FOR CHAPTER 4
287
Solution to Exercise 4.15.
The Cost-matrix for Φ is
Φ
x
y
z
A
17
20
20
B
11
14
14
C
14
17
17
D
12
9
15
Solution to Exercise 4.17.
Φ  M3
X ∗MΦ ∗M2
Y 
©­­­­
«
0
6
3
11
2
0
5
5
5
3
0
8
11
9
6
0
ª®®®®
¬
©­­­­
«
∞
∞
∞
11
∞
∞
∞
∞
∞
∞
9
∞
ª®®®®
¬
©­­
«
0
4
3
3
0
6
7
4
0
ª®®
¬

©­­­­
«
17
20
∞
11
14
∞
14
17
∞
20
9
∞
ª®®®®
¬
©­­
«
0
4
3
3
0
6
7
4
0
ª®®
¬

©­­­­
«
17
20
20
11
14
14
14
17
17
12
9
15
ª®®®®
¬
Solution to Exercise 4.18.
Yes, this is valid: it just means that the profunctor Φ: (T × E)
$ does not relate (good-natured,
funny) to any element of $. More formally, it means that Φ((good-natured, funny), p)  false for
all p ∈$  {$100K, $500K, $1M}. We can interpret this to mean that it is not feasible to produce a
good-natured, funny movie for any of the cost options presented—so at least not for less than a million
dollars.
Solution to Exercise 4.22.
There are a number of methods that can be used to get the correct answer. One way that works well for
this example is to search for the shortest paths on the diagram: it so happens that all the shortest paths
go through the bridges from D to y and y to r, so in this case (Φ # Ψ)(−, −)  X(−, D) + 9 + Z(r, −). This
gives:
Φ # Ψ
p
q
r
s
A
22
24
20
21
B
16
18
14
15
C
19
21
17
18
D
11
13
9
10

288
APPENDIX A. EXERCISE SOLUTIONS
A more methodical way is to use matrix multiplication. Here’s one way you might do the multiplication,
using a few tricks.
Φ # Ψ  (M3
X ∗MΦ ∗M2
Y) ∗(M2
Y ∗MΨ ∗M3
Z)
 M3
X ∗MΦ ∗M4
Y ∗MΨ ∗M3
Z
 (M3
X ∗MΦ ∗M2
Y) ∗MΨ ∗M3
Z
 Φ ∗MΨ ∗M3
Z

©­­­­
«
17
20
20
11
14
14
14
17
17
12
9
15
ª®®®®
¬
©­­
«
∞
∞
∞
∞
∞
∞
0
∞
4
∞
∞
4
ª®®
¬
©­­­­
«
0
2
4
5
4
0
2
3
2
4
0
1
1
3
5
0
ª®®®®
¬

©­­­­
«
17
20
20
11
14
14
14
17
17
12
9
15
ª®®®®
¬
©­­
«
∞
∞
∞
∞
2
4
0
1
4
6
8
4
ª®®
¬

©­­­­
«
22
24
20
21
16
18
14
15
19
21
17
18
11
13
9
10
ª®®®®
¬
Solution to Exercise 4.26.
We choose the Cost-category X from Eq. (2.56). The unit profunctor UX on X is described by the bridge
diagram
•A
•B
•
C
•
D
3
3
4
2
5
•A
•B
•
C
•
D
3
3
4
2
5
0
0
0
0
Solution to Exercise 4.30.
1. The ﬁrst equality is the unitality of V (Deﬁnition 2.2(b)). The second step uses the monotonicity
of ⊗(Deﬁnition 2.2(a)) applied to the inequalities I ≤P(p, p) (the identity law for P at p,
Deﬁnition 2.46(a)) and Φ(p, q) ≤Φ(p, q) (reﬂexivity of preorder V, Deﬁnition 1.30(a)). The third
step uses the deﬁnition of join: for all x and y, since any x ≤x, we have x ≤x ∨y. The ﬁnal
equality is just the deﬁnition of profunctor composition, Deﬁnition 4.21.
2. Note that in Bool, I  true. Since the identity law at p says true ≤P(p, p), and true is the
largest element of the preorder Bool, we thus have P(p, p)  true for all p. This shows that the
ﬁrst inequality in Eq. (4.28) is an equality.
The second inequality is more involved. Note that by the above, we can assume the left hand
side of the inequality is equal to Φ(p, q). We split into two cases. Suppose Φ(p, q)  true. Then,
again since true is the largest element of B, we must have equality.
Next, suppose Φ(p, q)  false. Note that since Φ is a monotone map Pop × Q →Bool, if p ≤p1
in P, then Φ(p1, q) ≤Φ(p, q) in Bool. Thus if P(p, p1)  true then Φ(p1, q)  Φ(p, q)  false.
This implies that for all p1 ∈P, we have either P(p, p1)  false or Φ(p1, q)  false, and hence
Ô
p1∈P P(p, p1) ∧Φ(p1, q)  Ô
p1∈P false  false.
Thus, in either case, we see that Φ(p, q)  Ô
p1∈P P(p, p1) ∧Φ(p1, q), as required.

A.4. SOLUTIONS FOR CHAPTER 4
289
3. The ﬁrst equation is unitality in monoidal categories, v ⊗I  v for any v ∈V. The second is that
I ≤Q(q, q) by unitality of enriched categories, see Deﬁnition 2.46, together with monotonicity of
monoidal product: v1 ≤v2 implies v ⊗v1 ≤v ⊗v2. The third was shown in Exercise 4.9.
Solution to Exercise 4.32.
This is very similar to Exercise 2.104: we exploit the associativity of ⊗. Note, however, we also require
V to be symmetric monoidal closed, since this implies the distributivity of ⊗over ∨(Proposition 2.87
2), and V to be skeletal, so we can turn equivalences into equalities.
((Φ # Ψ) # Υ)(p, s) 
Ü
r∈R
 Ü
q∈Q
Φ(p, q) ⊗Ψ(q, r)

⊗Υ(r, s)

Ü
r∈R,q∈Q
Φ(p, q) ⊗Ψ(q, r) ⊗Υ(r, s)

Ü
q∈Q
Φ(p, q) ⊗
Ü
r∈R

Ψ(q, r) ⊗Υ(r, s)

 (Φ # (Ψ # Υ))(p, s)
Solution to Exercise 4.36.
This is very straightforward. We wish to check b
id: P
P has the formula b
id(p, q)  P(p, q). By
Deﬁnition 4.34, b
id(p, q) B P(id(p), q)  P(p, q). So they’re the same.
Solution to Exercise 4.38.
The conjoint q+: R
R × R × R sends (a, b, c, d) to R(a, b + c + d), which is true if a ≤b + c + d, and
false otherwise.
Solution to Exercise 4.41.
1. By Deﬁnition 4.34, bF(p, q)  Q(F(p), q) and qG(p, q)  Q(p, G(q)). Since V is skeletal, F and G are
V adjoints if and only if Q(F(p), q)  Q(p, G(q)). Thus F and G are adjoints if and only if bF  qG.
2. Note that id: P →P is V-adjoint to itself, since both sides of Eq. (4.40) then equal P(p, q). Thus
b
id  qid.
Solution to Exercise 4.44.
The Hasse diagram for the collage of the given profunctor is quite simply this:
•A
•B
•
C
•
D
3
3
4
2
5
•x
•y
•z
3
4
3
4
11
9
Solution to Exercise 4.48.
Since we only have a rough deﬁnition, we can only roughly check this: we won’t bother with the notion
of well-behaved. Nonetheless, we can still compare Deﬁnition 2.2 with Deﬁnition 4.45.
First, recall from Section 3.2.3 that a preorder is a category P such that for every p, q ∈P, the set P(p, q)
has at most one element.
On the surface, all looks promising: both deﬁnitions have two constituents and four properties. In
constituent (i), both Deﬁnition 2.2 and Deﬁnition 4.45 call for the same: an element, or object, of the
preorder P. So far so good. Constituent (ii), however, is where it gets interesting: Deﬁnition 2.2 calls
for merely a function ⊗: P × P →P, while Deﬁnition 4.45 calls for a functor.

290
APPENDIX A. EXERCISE SOLUTIONS
Recall from Example 3.42 that functors between preorders are exactly monotone maps. So we need for
the function ⊗in Deﬁnition 2.2 to be a monotone map. This is exactly property (a) of Deﬁnition 2.2: it
says that if (x1, x2) ≤(y1, y2) in P ⊗P, then we must have x1 ⊗x2 ≤y1 ⊗y2 in P. So it is also the case
that in Deﬁnition 2.2 that ⊗is a functor.
The remaining properties compare easily, taking the natural isomorphisms to be equality or equivalence
in P. Indeed, property (b) of Deﬁnition 2.2 corresponds to both properties (a) and (b) of Deﬁnition 4.45,
and then the respective properties (c) and (d) similarly correspond.
Solution to Exercise 4.50.
1. 1E(5, 3)  false, 1F(5, 3)  2.
2. 1E(3, 5)  true, 1F(3, 5)  −2.
3. h(5, true)  5.
4. h(−5, true)  −5.
5. h(−5, false)  6.
6. qG(−2, 3)  2, qF(−2, 3)  −13.
7. qG(2, 3)  −1, qF(2, 3)  7.
Solution to Exercise 4.52.
Yes, the rough deﬁnition roughly agrees: plain old categories are Set-categories! In detail, we need to
compare Deﬁnition 4.51 when V  (Set, {1}, ×) with Deﬁnition 3.6. In both cases, we see that (i) asks for
a collection of objects and (ii) asks for, for all pairs of objects x, y, a set C(x, y) of morphisms. Moreover,
recall that the monoidal unit I is the one element set {1}. This means a morphism idx : I →C(x, x) is a
function idx : {1} →C(x, x). This is the same data as simply an element idx  idx(1) ∈C(x, x); we call
this data the identity morphism on x. Finally, a morphism #: C(x, y) ⊗C(y, z) →C(x, z) is a function
#: C(x, y) × C(y, z) →C(x, z); this is exactly the composite required in Deﬁnition 3.6 (iv).
So in both cases the data agrees. In Deﬁnition 3.6 we also require this data to satify two conditions,
unitality and associativity. This is what is meant by the last sentence of Deﬁnition 4.51.
Solution to Exercise 4.54.
An identity element in a Cost-category X is a morphism I →X(x, x) in Cost  ([0, ∞], ≥, 0, +), and
hence the condition that 0 ≥X(x, x). This implies that X(x, x)  0. In terms of distances, we interpret
this to mean that the distance from any point to itself is equal to 0. We think this is a pretty sensible
condition for a notion of distance to obey.
Solution to Exercise 4.62.
1. Here is a picture of the unit corelation  →3 ⊔3, where we have drawn the empty set with an
empty dotted rectangle on the left:

3 ⊔3

A.4. SOLUTIONS FOR CHAPTER 4
291
2. Here is a picture of the counit corelation 3 ⊔3 →:

3 ⊔3
3. Here is a picture of the snake equation on the left of Eq. (4.59).

Solution to Exercise 4.64.
Given two resource preorders X and Y, the preorder X × Y represents the set of all pairs of resources,
x ∈X and y ∈Y, with (x, y) ≤(x′, y′) iﬀx ≤x′ and y ≤y′. That is, if x is available given x′ and y is
available given y′, then (x, y) is available given (x′, y′).
Given two profunctors Φ: X1
X2 and Ψ: Y1
Y2, the profunctor Φ×Ψ represents their conjunction,
i.e. AND. In other words, if y1 can be obtained given x1 AND y2 can be obtained given x2, then (y1, y2)
can be obtained given (x1, x2).
Solution to Exercise 4.65.
The profunctor X×1
X deﬁned by the functor α: (X×1)op ×X →V that maps α((x, 1), y) B X(x, y)
is an isomorphism. It has inverse α−1 : X
X × 1 deﬁned by α−1(x, (y, 1)) B X(x, y). To see that
α−1 # α  UX, note ﬁrst that the unit law for X at z and the deﬁnition of join imply
X(x, z)  X(x, z) ⊗I ≤X(x, z) ⊗X(z, z) ≤
Ü
y∈X
X(x, y) ⊗X(y, z),
while composition says X(x, y) ⊗X(y, z) ≤X(x, z) and hence
Ü
y∈X
X(x, y) ⊗X(y, z) ≤
Ü
y∈X
X(x, z)  X(x, z).
Thus, unpacking the deﬁnition of composition of profunctor, we have
(α−1 # α)(x, z) 
Ü
(y,1)∈X×1
α(x, (y, 1)) ⊗α−1((y, 1), z) 
Ü
y∈X
X(x, y) ⊗X(y, z)  X(x, z).
Similarly we can show α # α−1  UX×1, and hence that α is an isomorphism X × 1
X.
Moreover, we can similarly show that β((1, x), y) B X(x, y) deﬁnes an isomorphism β: 1 × X
X.
Solution to Exercise 4.66.
We check the ﬁrst snake equation, the one on the left hand side of Eq. (4.59). The proof of the one on
the right hand side is analogous.

292
APPENDIX A. EXERCISE SOLUTIONS
We must show that the composite Φ of profunctors
X
α−1
−−−→X × 1
UX×ηX
−−−−−−−→X × Xop × X
ϵX×UX
−−−−−−→1 × X
α−→X
is itself the identity (ie. the unit profunctor on X), where α and α−1 are the isomorphisms deﬁned in
the solution to Exercise 4.65 above.
Freely using the distributivity of ⊗over ∨, the value Φ(x, y) of this composite at (x, y) ∈Xop × X is
given by
Ü
a,b,c,d,e∈X
α−1(x, (a, 1)) ⊗(UX × ηX)((a, 1), (b, c, d))
⊗(ϵX × UX)((b, c, d), (1, e)) ⊗α((1, e), y)

Ü
a,b,c,d,e∈X
α−1(x, (a, 1)) ⊗UX(a, b) ⊗ηX(1, c, d)
⊗ϵX(b, c, 1) ⊗UX(d, e) ⊗α((1, e), y)

Ü
a,b,c,d,e∈X
X(x, a) ⊗X(a, b) ⊗X(c, d) ⊗X(b, c) ⊗X(d, e) ⊗X(e, y)

X(x, y)
where in the ﬁnal step we repeatedly use the argument the Lemma 4.27 that shows that composing
with the unit profunctor UX(a, b)  X(a, b) is the identity.
This shows that Φ(x, y) is the identity profunctor, and hence shows the ﬁrst snake equation holds.
Again, checking the other snake equation is analogous.

A.5. SOLUTIONS FOR CHAPTER 5
293
A.5
Solutions for Chapter 5.
Solution to Exercise 5.5.
1. Below we draw a morphism f : 3 →2 and a morphism 1 : 2 →4 in FinSet:
•
•
•
3
•
•
2
•
•
•
•
4
•
•
2
f
1
2. Here is a picture of f + 1
•
•
•
•
•
3+2
•
•
•
•
•
•
2+4
f + 1
3. The composite of morphisms f : m →n and 1 : n →p in FinSet is the function ( f # 1): m →p
given by ( f # 1)(i)  1( f (i)) for all 1 ≤i ≤m.
4. The identity idm : m →m is given by idm(i)  i for all 1 ≤i ≤m. Here is a picture of id2 and id8:
•
•
2
•
•
2
•
•
•
•
•
•
•
•
8
•
•
•
•
•
•
•
•
8
id2
id8
5. Here is a picture of the symmetry σ3,5 : 8 →8:
•
•
•
•
•
•
•
•
8
•
•
•
•
•
•
•
•
8
σ3,5
Solution to Exercise 5.9.
We need to give examples posetal props, i.e. each will be a poset whose set of objects is N, whose order is
denoted m ⪯n, and with the property that whenever m1 ⪯n1 and m2 ⪯n2 hold then m1+m2 ⪯n1+n2
does too.
The question only asks for three, but we will additionally give a quasi-example and a non-example.
1. Take ⪯to be the discrete order: m ⪯n iﬀm  n.
2. Take ⪯to be the usual order, m ⪯n iﬀthere exists d ∈N with d + m  n.
3. Take ⪯to be the reverse of the usual order, m ⪯n iﬀthere exists d ∈N with m  n + d.
4. Take ⪯to be the co-discrete order m ⪯n for all m, n. Some may object that this is a preorder, not
a poset, so we call it a quasi-example.
5. (Non-example.) Take ⪯to be the division order, m ⪯n iﬀthere exists q ∈N with m ∗q  d. This
is a perfectly good poset, but it does not satisfy the monotonicity property: we have 2 ⪯4 and
3 ⪯3 but not 5 ⪯? 7.
Solution to Exercise 5.10.
Example 5.6: The prop Bij has
1. Bij(m, n) B { f : m →n | f is a bĳection}. Note that Bij(m, n)   if m , n and it has n!
elements if m  n.
2. The identity map n →n is the bĳection n →n sending i 7→i.

294
APPENDIX A. EXERCISE SOLUTIONS
3. The symmetry map m + n →n + m is the bĳection σm,n : m + n →n + m given by
σm,n(i) B
(
i + n
if i ≤m
i −m
if m + 1 ≤i
4. Composition of bĳections m →n and n →p is just their composition as functions, which
is again a bĳection.
5. Given bĳections f : m →m′ and 1 : n →n′, their monoidal product ( f + 1): (m + n) →
(m′ + n′) is given by
( f + 1)(i) B
(
f (i)
if i ≤m
1(i −m)
if m + 1 ≤i
Example 5.7: The prop Corel has
1. Corel(m, n) is the set of equivalence relations on m + n.
2. The identity map n →n is the smallest equivalence relation, which is the smallest reﬂexive
relation, i.e. where i ∼j iﬀi  j.
3. The symmetry map σm,n, as an equivalence relation on m + n + n + m is “the obvious
thing,” namely “equating corresponding m’s together and also equating corresponding n’s
together.” To be pedantic, i ∼j iﬀeither
• |i −j|  m + n + n, or
• m + 1 ≤i ≤m + n + n and m + 1 ≤j ≤m + n + n and |i −j|  n.
4. Composition of an equivalence relation ∼on m + n and an equivalence relation Û∼on n + p
is the equivalence relation ≃on m + p given by i ≃k iﬀthere exists j ∈n with i ∼j and j Û∼k.
5. Given equivalence relations ∼on m + n and ∼′ on m′ + n′, we need an equivalence relation
(∼+ ∼′) on m + n + m′ + n′. We take it to be “the obvious thing,” namely “using ∼on the
unprimed stuﬀand using ∼′ on the primed stuﬀ, with no other interaction.” To be pedantic,
i ∼j iﬀeither
• i ≤m + n and j ≤m + n and i ∼j, or
• m + n + 1 ≤i and m + n + 1 ≤j and i ∼′ j.
Example 5.8: The prop Rel has
1. Rel(m, n) is the set of relations on the set m × n, i.e. the set of subsets of m × n, i.e. its
powerset.
2. The identity map n →n is the subset {(i, j) ∈n × n | i  j}.
3. The symmetry map m + n →n + m is the subset of pairs (i, j) ∈(m + n) × (n + m) such that
either
• i ≤m and m + 1 ≤j and i + m  j, or
• m + 1 ≤i and j ≤m and j + m  i.
4. Composition of relations is as in Example 5.8.
5. Given a relation R ⊆m × n and a relation R′ ⊆m′ × n′, we need a relation (R + R′) ⊆
m + m′ × n + n′.
As stated in the example (footnote), this can be given by a universal
property: The monoidal product R1 + R2 of relations R1 ⊆m1 × n1 and R2 ⊆m2 × n2 is
given by R1 ⊔R2 ⊆(m1 × n1) ⊔(m2 × n2) ⊆(m1 ⊔m2) × (n1 ⊔n2).
Solution to Exercise 5.16.
Composition of an (m, n)-port graph G and an (n, p)-port graph H looks visually like sticking them
end to end, connecting the wires in order, removing the two outer boxes, and adding a new outer box.
For example, suppose we want to compose the following in the order shown:
a
b
c
d
e
#

A.5. SOLUTIONS FOR CHAPTER 5
295
The result is:
a
b
c
d
e
Solution to Exercise 5.18.
The monoidal product of two morphisms is drawn by stacking the corresponding port graphs. For this
problem, we just stack the left-hand picture on top of itself to obtain the righthand picture:
a
b
c
a
b
c′
a
b′
c′
Solution to Exercise 5.20.
We have a relation R ⊆P × P which generates a preorder ≤P on P, we have an arbitrary preorder
(Q, ≤Q) and a function f : P →Q, not necessarily monotonic.
1. Assume that for every x, y ∈P, if R(x, y) then f (x) ≤f (y); we want to show that f is monotone,
i.e. that for every x ≤P y we have f (x) ≤Q f (y). By deﬁnition of P being the reﬂexive, transitive
closure of R, we have x ≤P y iﬀthere exists n ∈N and x0, . . . , xn in P with x0  x and xn  y and
R(xi, xi+1) for each 0 ≤i ≤n −1. (The case n  0 handles reﬂexivity.) But then by assumption,
R(xi, xi+1) implies f (xi) ≤Q f (xi+1) for each i. By induction on i we show that f (x0) ≤Q f (xi)
for all 0 ≤i ≤n, at which point we are done.
2. Suppose now that f is monotone, and take x, y ∈P for which R(x, y) holds. Then x ≤P y
because ≤P is the smallest preorder relation containing R. (Another way to see this based on the
above description is with n  1, x0  x, and xn  y, which we said implies x ≤P y.) Since f is
monotone, we indeed have f (x) ≤Q f (y).
Solution to Exercise 5.21.
Suppose that P, Q, and R are as in Exercise 5.20 and we have a function 1 : Q →P.
1. If R(1(a), 1(b)) holds for all a ≤Q b then 1 is monotone, because R(x, y) implies x ≤P y.
2. It is possible for 1 : (Q, ≤Q) →(P, ≤P) to be monotone and yet have some a, b ∈Q with a ≤Q b
and (1(a), 1(b)) < R. Indeed, take Q B {1} to be the free preorder on one element, and take
P B {1} with R  . Then the unique function 1 : Q →P is monotone (because ≤P is reﬂexive
even though R is empty), and yet (1(1), 1(1)) < R.
Solution to Exercise 5.23.
Let G  (V, A, s, t) be a graph, let G be the free category on G, and let C be another category, whose set
of morphisms is denoted Mor(C).
1. To give a function Mor(C) →Ob(C) means that for every element Mor(C) we need to give exactly
one element of Ob(C). So for dom we take any q ∈Mor(C), view it as a morphism q : y →z, and
send it to its domain y. Similarly for cod: we put cod(q) B z.
2. Suppose ﬁrst that we are given a functor F : G →C. On objects we have a function Ob(G) →Ob(C),
and this deﬁnes f since Ob(G)  V. On morphisms, ﬁrst note that the arrows of graph G are ex-
actly the length=1 paths in G, whereas Mor(G) is the set of all paths in G, so we have an inclusion
A ⊆Mor(G). The functor F provides a function Mor(G) →Mor(C), which we can restrict to A
to obtain 1 : A →Mor(C). All functors satisfy dom(F(r))  F(dom(r)) and cod(F(r))  F(cod(r))
for any r : w →x. In particular when r ∈A is an arrow we have dom(r)  s(r) and cod(r)  t(r).

296
APPENDIX A. EXERCISE SOLUTIONS
Thus we have found ( f , 1) with the required properties.
Suppose second that we are given a pair of functions ( f , 1) where f : V →Ob(C) and 1 : A →
Mor(C) such that dom(1(a))  f (s(a)) and cod(1(a))  f (t(a)) for all a ∈A. Deﬁne F : G →C on
objects by f . An arbitrary morphism in G is a path p B (v0, a1, a2, . . . , an) in G, where v0 ∈V,
ai ∈A, v0  s(a1), and t(ai)  s(ai+1) for all 1 ≤i ≤n −1. Then 1(ai) is a morphism in C whose
domain is f (v0) and the morphisms 1(ai) and 1(ai+1) are composable for every 1 ≤i ≤n −1.
We then take F(p) B id f (v0) # 1(a1) # · · · # 1(an) to be the composite. It is easy to check that this is
indeed a functor (preserves identities and compositions).
Third, we want to see that the two operations we just gave are mutually inverse. On objects this
is straightforward, and on morphisms it is straightforward to see that, given ( f , 1), if we turn
them into a functor F : G →C and then extract the new pair of functions ( f ′, 1′), then f  f ′ and
1  1′. Finally, given a functor F : G →C, we extract the pair of functions ( f , 1) as above and
then turn them into a new functor F′: G →C. It is clear that F and F′ act the same on objects,
so what about on morphisms. The formula says that F′ acts the same on morphisms of length 1
in G (i.e. on the elements of A). But an arbitrary morphism in G is just a path, i.e. a sequence of
composable arrows, and so by functoriality, both F and F′ must act the same on arbitrary paths.
3. (Mor(C), Ob(C), dom, cod)isagraph; let’s denote it U(C) ∈Grph. We have functorsFree: Grph ⇆
Cat :U, and Free is left adjoint to U.
Solution to Exercise 5.24.
1. The elements of the free monoid on the set {a} are:
a0, a1, a2, a3, . . . , a2019, . . .
with monoid multiplication ∗given by the usual natural number addition on the exponents,
ai ∗a j  ai+j.
2. This is isomorphic to N, by sending ai 7→i.
3. The elements of the free monoid on the set {a, b} are ‘words in a and b,’ each of which we will
represent as a list whose entries are either a or b. Here are some:
[ ],
[a],
[b],
[a, a],
[a, b],
. . . ,
[b, a, b, b, a, b, a, a, a, a],
. . .
Solution to Exercise 5.28.
We have two props: the prop of port graphs and the free prop Free(G, s, t) where
G B {ρm,n : m →n | m, n ∈N},
s(ρm,n) B m,
t(ρm,n) B n;
we want to show they are the same prop. As categories they have the same set of objects (in both cases,
N), so we need to show that for every m, n ∈N, they have the same set of morphisms (and that their
composition formulas and monoidal product formulas agree).
By Deﬁnition 5.25, a morphism m →n in Free(G) is a G-labeled port graph, i.e. a pair (Γ, ℓ), where
Γ  (V, in, out, ι) is an (m, n)-port graph and ℓ: V →G is a function, such that the ‘arities agree.’ What
does this mean? Recall that every vertex v ∈V is drawn as a box with some left-hand ports and some
right-hand ports—an arity—and ℓ(v) ∈G is supposed to have the correct arity; precisely, s(ℓ(v))  in(v)
and t(ℓ(v))  out(v). But G was chosen so that it has exactly one element with any given arity, so the
function ℓhas only one choice, and thus contributes nothing: it neither increases nor decreases the
freedom. In other words, a morphism in our particular Free(G) can be identiﬁed with an (m, n) port
graph Γ, as desired.
Again by deﬁnition Deﬁnition 5.25, the ‘composition and the monoidal structure are just those for port
graphs PG (see Eq. (5.17)); the labelings (the ℓ’s) are just carried along.’ So we are done.

A.5. SOLUTIONS FOR CHAPTER 5
297
Solution to Exercise 5.32.
Here is a picture of ( f + id1 + id1) # (σ + id1) # (id1 + h) # σ # 1, in the free prop on generators G  { f : 1 →
1, 1 : 2 →2, h : 2 →1}:
f
h
1
Solution to Exercise 5.35.
The free prop on generators (G, s, t), deﬁned in Deﬁnition 5.25, is—for all intents and purposes—
the same thing as the prop presented by (G, s, t, ), having no relations. The only possible “subtle
diﬀerence” we might have to admit is if someone said that a set S is “subtly diﬀerent” than its quotient
by the trivial equivalence relation. In the latter, the elements are the singleton subsets of S. So for
example the quotient of S  {1, 2, 3} by the trivial equivalence relation is the set {{1}, {2}, {3}}. It is
subtly diﬀerent than S, but the two are naturally isomorphic, and category-theoretically, the diﬀerence
will never make a diﬀerence.
Solution to Exercise 5.41.
1. If (R, 0, +, 1, ∗) is a rig, then the multiplicative identity 1 ∈Matn(R) is the usual n-by-n identity
matrix: 1’s on the diagonal and 0’s everywhere else (where by ‘1’ and ‘0’, we mean those elements
of R). So for n  4 it is:
©­­­­
«
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
ª®®®®
¬
.
2. We choose n  2 and hence need to ﬁnd two elements A, B ∈Mat2(N) such that A ∗B , B ∗A.
A ∗B 
 0
1
0
0

∗
 0
1
1
0

,
 0
1
1
0

∗
 0
1
0
0

 B ∗A
One can calculate from the multiplication formula (recalled in Example 5.40) says (A ∗B)(1, 1) 
0 ∗0 + 1 ∗1  1 and (B ∗A)(1, 1)  0 ∗0 + 0 ∗0  0, which are not equal.
Solution to Exercise 5.43.
Semantically, if we apply the ﬂow graph below to the input signal (x, y)
3
5
3
the resulting output signal is (16x + 4y, x + 4y).
Solution to Exercise 5.51.
The monoidal product of A 
 3
3
1
2
0
4

and B 

2
5
6
1

is
A + B 
©­­
«
3
3
1
0
0
0
0
2
0
4
0
0
0
0
0
0
0
2
5
6
1
ª®®
¬

298
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 5.55.
1. The signal ﬂow graph on the left represents the matrix on the right:

1
1
1

2. The signal ﬂow graph on the left represents the matrix on the right:

1
1
1

3. They are equal.
Solution to Exercise 5.58.
1.
©­­
«
0
1
2
ª®®
¬
∼
2
2.
0
0
0
0

∼
3.
1
2
3
4
5
6

∼
2
3
4
5
6
Solution to Exercise 5.59.
• For the ﬁrst layer 11, take the monoidal product of m copies of cn,
11 B cn + · · · + cn : m →(m × n),
where cn is the signal ﬂow diagram that makes n copies of a single input:
cn B
# (1 +
) # (1 + 1 +
) # · · · # (1 + · · · + 1 +
): 1 →n
• Next, deﬁne
12 B
sM(1,1) + · · · + sM(1,n)
+ sM(2,1) + · · · + sM(2,n)
+ · · ·
+ sM(m,1) + · · · + sM(m,n) : (m × n) →(m × n),
where sa : 1 →1 is the signal ﬂow graph generator “scalar multiplication by a.” This layer
ampliﬁes each copy of the input signal by the relevant rig element.
• The third layer rearranges wires. We will not write this down explicitly, but simply say it is the
signal ﬂow graph 13 : m × n →m × n, that is the composite and monoidal product of swap and
identity maps, such that the (i −1)m + jth input is sent to the (j −1)n + ith output, for all 1 ≤i ≤n
and 1 ≤j ≤m.
• Finally, the fourth layer is similar to the ﬁrst, but instead adds the ampliﬁed input signals. We
deﬁne
14 B am + · · · + am : (m × n) →n,

A.5. SOLUTIONS FOR CHAPTER 5
299
where am is the signal ﬂow graph that adds m inputs to produce a single output:
am B (1 + · · · + 1 +
) # · · · # (1 + 1 +
) # (1 +
) #
: m →1
Using Proposition 5.54, it is a straightforward but tedious calculation to show that 1  11#12#13#14 : m →
n has the property that S(1)  M.
Solution to Exercise 5.62.
1. The matrices in Exercise 5.58 may also be drawn as the following signal ﬂow graphs:
a)
©­­
«
0
1
2
ª®®
¬
∼
b)
0
0
0
0

∼
0
c)
1
2
3
4
5
6

∼
2
3
5
4
6
2. Here are graphical proofs that the representations we chose in our solution to Exercise 5.58 agree
with those chosen in Part 1 above.
a)

1
1

2
b)
0


c)
2
3
5
4
6

2
3
4
5
6

2
3
4
5
6

2
3
4
5
6
Solution to Exercise 5.63.
1. The signal ﬂow graphs
and
3
5
3
3
3
5
3

300
APPENDIX A. EXERCISE SOLUTIONS
cannot represent the same morphism because one has a path from a vertex on the left to one
on the right, and the other does not. To prove this, observe that the only graphical equation in
Theorem 5.60 that breaks a path from left to right is the equation
0

So a 0 scalar must within a path from left to right before we could rewrite the diagram to break
that path. No such 0 scalar can appear, however, because the diagram does not contain any, and
the sum and product of any two nonzero natural numbers is always nonzero.
2. Replacing each of the 3s with 0 allows us to rewrite the diagram to
Solution to Exercise 5.67.
The three conditions of Deﬁnition 5.65 are
(a) (µ ⊗id) # µ  (id ⊗µ) # µ,
(b) (η ⊗id) # µ  id  (id ⊗η) # µ, and
(c) σM,M # µ  µ.
where σM,M is the swap map on M in C.
1. Suppose µ: R × R →R is deﬁned by µ(a, b)  a ∗b and η ∈R is deﬁned to be η  1. The
conditions, written diagrammatically, say that starting in the upper left of each diagram below,
the result in the lower right is the same regardless of which path you take:
(a, b, c)
(a ∗b, c)
(a, b ∗c)
a ∗b ∗c
(µ⊗id)
(id⊗µ)
µ
µ
a
(1, a)
(a, 1)
a
(η⊗id)
(id⊗η)
ida
µ
µ
(a, b)
(b, a)
a ∗b
σ
µ
µ
and this is true for (R, ∗, 1).
2. The same reasoning works for (R, +, 0), shown below:
(a, b, c)
(a+b, c)
(a, b+c)
a+b+c
(µ⊗id)
(id⊗µ)
µ
µ
a
(0, a)
(a, 0)
a
(η⊗id)
(id⊗η)
ida
µ
µ
(a, b)
(b, a)
a+b
σ
µ
µ
Solution to Exercise 5.69.
The functor U : Mat(R) →Set is given on objects by sending n to the set Rn, and on morphisms by
matrix-vector multiplication. Here Rn means the set of n-tuples or n-dimensional vectors in R. In
particular, R0  {()} consists of a single vector of dimension 0.
1. U preserves the monoidal unit because 0 is the monoidal unit of any prop (Mat(R) is a prop),
{1} is the monoidal unit of Set, and R0 is canonically isomorphic to {1}. U also preserves the
monoidal product because there is a canonical isomorphism Rm × Rn  Rm+n.
2. A monoid object in Mat(R) is a tuple (m, µ, η) where m ∈N, µ: m + m →m, and η: 0 →m
satisfy the properties µ(η, x)  x  µ(x, η) and µ(x, µ(y, z))  µ(µ(x, y), z). Note that there is
only one morphism 0 →m in Mat(R) for any m. It is not hard to show that for any m ∈N there
is only one monoid structure. For example, when m  2, µ must be the following matrix
µ B
©­­­­
«
1
0
0
1
1
0
0
1
ª®®®®
¬

A.5. SOLUTIONS FOR CHAPTER 5
301
Anyway, for any monoid (m, µ, η), the morphism U(η): R0 →Rm is given by U(η)(1) B
(0, . . . , 0), and the morphism U(µ): Rm × Rm →Rm is given by
U(µ)((a1, . . . , am), (b1, . . . , bm)) B (a1 + b1, . . . , am + bm).
These give Rm the structure of a monoid.
3. The triple (1,
,
) corresponds to the additive monoid structure on R, e.g. with (5, 3) 7→8.
Solution to Exercise 5.77.
1. The behavior B(
) of the reversed addition icon
: 1 →2 is the relation {(x, y, z) ∈R3 | x 
y + z}.
2. The behavior B(
) of the reversed copy icon,
: 2 →1 is the relation {(x, y, z) ∈R3 | x  y 
z}.
Solution to Exercise 5.80.
If B ⊆Rm × Rn and C ⊆Rp × Rq are morphisms in RelR, then take B + C ⊆Rm+p × Rn+q to be the set
B + C B {(w, y, x, z) ∈Rm+p × Rn+q | (w, x) ∈B and (y, z) ∈C}.
Solution to Exercise 5.82.
The behavior of 1 : m →n and hop : n →ℓare respectively
B(1)  {(x, z) ∈Rm × Rn | S(1)(x)  z}
B(hop)  {(z, y) ∈Rn × Rℓ| z  S(h)(y)}
and by Eq. (5.78), the composite B(1 # (hop))  B(1) # B(hop) is:
{(x, y) | there exists z ∈Rn such that S(1)(x)  z and z  S(h)(y)}.
Since S(1) and S(h) are functions, the above immediately reduces to the desired formula:
B(1 # (hop))  {(x, y) | S(1)(x)  S(h)(y)}.
Solution to Exercise 5.83.
The behavior of 1op : n →m and h : m →p are respectively
B(1op)  {(y, x) ∈Rn × Rm | y  S(1)(x)}
B(h)  {(x, z) ∈Rm × Rp | S(h)(x)  z}
and by Eq. (5.78), the composite B((1op) # h)  B(1op) # B(h) is:
{(y, z) | there exists x ∈Rm such that y  S(1)(x) and S(h)(x)  z}.
This immediately reduces to the desired formula:
B((1op) # h)  {(S(1)(x), S(h)(x)) | x ∈Rm}.
Solution to Exercise 5.84.
1. The behavior of the 0-reverse
is the subset {y ∈R | y  0}, and its n-fold tensor is similarly
{y ∈Rn | y  0}. Composing this relation with S(1) ⊆Rm × Rn gives {x ∈Rm | S(1)  0},
which is the kernel of S(1).
2. The behavior of the discard-inverse
is the subset {x ∈R}, i.e. the largest subset of R, and
similarly its m-fold tensor is Rn ⊆Rn. Composing this relation with S(1) ⊆Rm × Rn gives
{y ∈Rn | there exists x ∈Rm such that S(1)(x)  y}, which is exactly the image of S(1).

302
APPENDIX A. EXERCISE SOLUTIONS
3. For any 1 : m →n, we ﬁrst claim that the behavior B(1)  {(x, y) | S(1)(x)  y} is linear, i.e. it
is closed under addition and scalar multiplication. Indeed, S(1) is multiplication by a matrix,
so if S(1)(x)  y then S(1)(rx)  ry and S(1)(x1 + x2)  S(1)(x1) + S(1)(x2). Thus we con-
clude that (x, y) ∈B(1) implies (rx, ry) ∈B(1), so it’s closed under scalar multiplication, and
(x1, y1), (x2, y2) ∈B(1) implies (x1 + x2, y1 + y2) ∈B(1) so it’s closed under addition. Similarly,
the behavior B(1op) is also linear; the proof is similar.
Finally, we need to show that the composite of any two linear relations is linear. Suppose that
B ⊆Rm × Rn and C ⊆Rn × Rp are linear.
Take (x1, z1), (x2, z2) ∈B # C and take r ∈R.
By deﬁnition, there exist y1, y2 ∈Rn such that (x1, y1), (x2, y2) ∈B and (y1, z1), (y2, z2) ∈C.
Since B and C are linear, (rx1, ry1) ∈B and (ry1, rz1) ∈C, and also (x1 + x2, y1 + y2) ∈B and
(y1 + y2, z1 + z2) ∈C. Hence (rx1, rz1) ∈(B # C) and (x1 + x2, z1 + z2) ∈(B # C), as desired.
Solution to Exercise 5.85.
Suppose that B ⊆Rm ×Rn and C ⊆Rn ×Rp are linear. Their composite is the relation (B #C) ⊆Rm ×Rp
consisting of all (x, z) for which there exists y ∈Rn with (x, y) ∈B and (y, z) ∈C. We want to show
that the set (B # C) is linear, i.e. closed under scalar multiplication and addition.
For scalar multiplication, take an (x, z) ∈(B #C) and any r ∈R. Since B is linear, we have (r ∗x, r ∗y) ∈B
and since C is linear we have (r ∗y, r ∗z) ∈C, so then (r ∗x, r ∗z) ∈(B # C). For addition, if we also
have (x′, z′) ∈(B # C) then there is some y′ ∈Rn with (x′, y′) ∈B and (y′, z′) ∈C, so since B and C are
linear we have (x + x′, y + y′) ∈B and (y + y′, z + z′) ∈C, hence (x + x′, z + z′) ∈(B # C).

A.6. SOLUTIONS FOR CHAPTER 6
303
A.6
Solutions for Chapter 6.
Solution to Exercise 6.3.
Let A  {a, b}, and consider the preorders shown here:
a•
b• ,
a• →
b• ,
a• ⇆
b• .
1. The left-most (the discrete preorder on A) has no initial object, because a ≰b and b ≰a.
2. The middle one has one initial object, namely a.
3. The right-most (the co-discrete preorder on A) has two initial objects.
Solution to Exercise 6.6.
Recall that the objects of a free category on a graph are the vertices of the graph, and the morphisms
are paths. Thus the free category on a graph G has an initial object if there exists a vertex v that has a
unique path to every object. In 1. and 2., the vertex a has this property, so the free categories on graphs
1. and 2. have initial objects. In graph 3., neither a nor b have a path to each other, and so there is no
initial object. In graph 4., the vertex a has many paths to itself, and hence its free category does not
have an initial object either.
Solution to Exercise 6.7.
1. The remaining conditions are that f (1R)  1S, and that f (r1 ∗R r2)  f (r1) ∗S f (r2).
2. The initial object in the category Rig is the natural numbers rig (N, 0, +, 1, ∗). The fact that is
initial means that for any other rig R  (R, 0R, +R, 1R, ∗R), there is a unique rig homomorphism
f : N →R.
What is this homomorphism? Well, to be a rig homomorphism, f must send 0 to 0R, 1 to 1R.
Furthermore, we must also have f (m + n)  f (m) +R f (n), and hence
f (m)  f (1 + 1 + · · · + 1
|¨¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨¨}
m summands
)  f (1) + f (1) + · · · + f (1)
|¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨}
m summands
 1R + 1R + · · · + 1R
|¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨}
m summands
.
So if there is a rig homomorphism f : N →R, it must be given by the above formula. But does
this formula work correctly for multiplication?
It remains to check f (m ∗n)  f (m) ∗R f (n), and this will follow from distributivity. Noting that
f (m ∗n) is equal to the sum of mn copies of 1R, we have
f (m) ∗R f (n)  (1R + · · · + 1R
|¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨}
m summands
) ∗R (1R + · · · + 1R
|¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨}
n summands
)
 1R ∗(1R + · · · + 1R
|¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨}
n summands
) + · · · + 1R ∗(1R + · · · + 1R
|¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨}
n summands
)
|¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨}
m summands
 1R + · · · + 1R
|¨¨¨¨¨¨¨¨¨¨{z¨¨¨¨¨¨¨¨¨¨}
mn summands
 f (m ∗n).
Thus (N, 0, +, 1, ∗) is the initial object in Rig.
Solution to Exercise 6.8.
In Deﬁnition 6.1, it is the initial object  ∈C that is universal.
In this case, all objects c ∈C are
‘comparable objects’. So the universal property of the initial object is that to any object c ∈C, there is a
unique map  →c coming from the initial object.
Solution to Exercise 6.10.
If c1 is initial then by the universal property, for any c there is a unique morphism c1 →c; in particular,
there is a unique morphism c1 →c2, call it f . Similarly, if c2 is initial then there is a unique morphism
c2 →c1, call it 1. But how do we know that f and 1 are mutually inverse? Well since c1 is initial

304
APPENDIX A. EXERCISE SOLUTIONS
there is a unique morphism c1 →c1. But we can think of two: idc1 and f # 1. Thus they must be
equal. Similarly for c2, so we have f # 1  idc1 and 1 # f  idc2, which is the deﬁnition of f and 1 being
mutually inverse.
Solution to Exercise 6.13.
Let (P, ≤) be a preorder, and p, q ∈P. Recall that a preorder is a category with at most one morphism,
denoted ≤, between any two objects. Also recall that all diagrams in a preorder commute, since this
means any two morphisms with the same domain and codomain are equal.
Translating Deﬁnition 6.11 to this case, a coproduct p + q is P is an element of P such that p ≤p + q and
q ≤p + q, and such that for all elements x ∈P with maps p ≤x and q ≤x, we have p + q ≤x. But this
says exactly that p + q is a join: it is a least element above both p and q. Thus coproducts in preorders
are exactly the same as joins.
Solution to Exercise 6.16.
The function [ f , 1] is deﬁned by
[ f , 1]: A ⊔B −→T
apple1 7−→a
banana1 7−→b
pear1 7−→p
cherry1 7−→c
orange1 7−→o
apple2 7−→e
tomato2 7−→o
mango2 7−→o.
Solution to Exercise 6.17.
1. The equation ιA # [ f , 1]  f is the commutativity of the left hand triangle in the commutative
diagram (6.12) deﬁning [ f , 1].
2. The equation ιB # [ f , 1]  1 is the commutativity of the right hand triangle in the commutative
diagram (6.12) deﬁning [ f , 1].
3. The equation [ f , 1]#h  [ f #h, 1#h] follows from the universal property of the coproduct. Indeed,
the diagram
A
A + B
B
C
D
ιA
f
f #h
[ f ,1]
ιB
1
1#h
h
commutes, and the universal property says there is a unique map [ f # h, 1 # h]: A + B →D for
which this occurs. Hence we must have [ f , 1] # h  [ f # h, 1 # h].
4. Similarly, to show [ιA, ιB]  idA+B, observe that the diagram
A
A + B
B
A + B
ιA
ιA
idA+B
ιB
ιB
trivially commutes. Hence by the uniqueness in (6.12), [ιA, ιB]  idA+B.

A.6. SOLUTIONS FOR CHAPTER 6
305
Solution to Exercise 6.18.
This exercise is about showing that coproducts and an initial object give a symmetric monoidal category.
Since all we have are coproducts and an initial object, and since these are deﬁned by their universal
properties, the solution is to use these universal properties over and over, to prove that all the data of
Deﬁnition 4.45 can be constructed.
1. To deﬁne a functor +: C × C →C we must deﬁne its action on objects and morphisms. In both
cases, we just take the coproduct. If (A, B) is an object of C × C, its image A + B is, as usual, the
coproduct of the two objects of C. If ( f , 1): (A, B) →(C, D) is a morphism, then we can form a
morphism f + 1  [ f # ιC, 1 # ιD]: A + B →C + D, where ιC : C →C + D and ιD : D →C + D
are the canonical morphisms given by the deﬁnition of the coproduct A + B.
Note that this construction sends identity morphisms to identity morphisms, since by Exer-
cise 6.17 4 we have
idA + idB  [idA # ιA, idB # ιB]  [ιA, ιB]  idA+B.
To show that + is a functor, we need to also show it preserves composition. Suppose we also have
a morphism (h, k): (C, D) →(E, F) in C×C. We need to show that ( f + 1)#(h + k)  ( f # h)+(1 # k).
This is a slightly more complicated version of the argument in Exercise 6.17 3. It follows from the
fact the diagram below commutes:
A
A + B
B
C
C + D
D
E + F
ιA
f
f +1
ιB
1
ιC
h#ιE
h+k
ιD
k#ιF
Indeed, we again use the uniqueness of the copairing in (6.12), this time to show that ( f #h)+(1#k) 
[ f # h # ιE, 1 # k # ιF]  ( f + 1) # (h + k), as required.
2. Recall the universal property of the initial object gives a unique map !A :  →A. Then the
copairing [idA, !A] is a map A +  →A. Moreover, it is an isomorphism with inverse ιA : A →
A + . Indeed, using the properties in Exercise 6.17 and the universal property of the initial
object, we have ιA # [idA, !A]  idA, and
[idA, !A] # ιA  [idA # ιA, !A # ιA]  [ιA, !A+]  [ιA, ι]  idA+.
An analogous argument shows [!A, idA]:  + A →A is an isomorphism.
3. We’ll just write down the maps and their inverses; we leave it to you, if you like, to check that
they indeed are inverses.
a) The map [idA + ιB, ιC]  [[ιA, ιB # ιB+C], ιC # ιB+C]: (A + B) + C →A + (B + C) is an
isomorphism, with inverse [ιA, ιB + idC]: A + (B + C) →(A + B) + C.
b) The map [ιA, ιB]: A + B →B + A is an isomorphism. Note our notation here is slightly
confusing: there are two maps named ιA, (i) ιA : A →A + B, and (ii) ιA : A →B + A, and
similarly for ιB. In the above we mean the map (ii). It has inverse [ιA, ιB]: B + A →A + B,
where in this case we mean the map (i).
Solution to Exercise 6.24.
1. Suppose given an arbitrary diagram of the form B ←A →C in DiscS; we need to show that it
has a pushout. The only morphisms in DiscS are identities, so in particular A  B  C, and the
square consisting of all identities is its pushout.
2. Suppose DiscS has an initial object s. Then S cannot be empty! But it also cannot have more
than one object, because if s′ is another object then there is a morphism s →s′, but the only
morphisms in S are identities so s  s′. Hence the set S must consist of exactly one element.

306
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 6.26.
The pushout is the set 4, as depicted in the top right in the diagram below, equipped also with the
depicted functions:
f
1
pushout
(A.1)
We want to see that this checks out with the description from Example 6.25, i.e. that it is the set of
equivalence classes in 5 ⊔3 generated by the relation { f (a) ∼1(a) | a ∈4}. If we denote elements of 5
as {1, . . . , 5} and those of 3 as {1′, 2′, 3′}, we can redraw the functions f , 1:
1
•
1′
2
•
2′
3
•
3′
4
•
5
which says we take the equivalence relation on 5 ⊔3 generated by: 1 ∼1′, , 3 ∼1′, 5 ∼2′, and 5 ∼3′.
The equivalence classes are {1, 1′, 3}, {2}, {4}, and {5, 2′, 3′}. These four are exactly the four elements
in the set labeled ‘pushout’ in Eq. (A.1).
Solution to Exercise 6.28.
1. The diagram to the left commutes because  is initial, and so has a unique map  →X + Y. This
implies we must have f # ιX  1 # ιY.
2. There is a unique map X +Y →T making the diagram in (6.21) commute simply by the universal
property of the coproduct (6.12) applied to the maps x : X →T and y : Y →T.
3. Suppose X + Y exists. By the universal property of , given any pair of arrows x : X →T and
y : Y →T, the diagram

X
Y
T
f
1
x
y
commutes. This means, by the universal property of the pushout X + Y, there exists a unique
map t : X + Y →T such that ιX # t  x and ιY # t  y. Thus X + Y is the coproduct X + Y.
Solution to Exercise 6.35.
We have to check that the colimit of the diagram shown left really is given by taking three pushouts as
shown right:
B
Z
A
C
D
B
Z
A
Y
R
X
Q
S
⌜
⌜
⌜

A.6. SOLUTIONS FOR CHAPTER 6
307
That is, we need to show that S, together with the maps from A, B, X, Y, and Z, has the required
universal property. So suppose given an object T with two commuting diagrams as shown:
B
Z
A
Y
X
T
We need to show there is a unique map S →T making everything commute. Since Q is a pushout of
X ←A →Y, there is a unique map Q →T making a commutative triangle with Y, and since R is the
pushout of Y ←B →Z, there is a unique map R →T making a commutative triangle with Y. This
implies that there is a commuting (Y, Q, R, T) square, and hence a unique map S →T from its pushout
making everything commute. This is what we wanted to show.
Solution to Exercise 6.41.
The formula in Theorem 6.37 says that the pushout X +N Y is given by the set of equivalence classes of
X ⊔N ⊔Y under the equivalence relation generated by x ∼n if x  f (n), and y ∼n if y  1(n), where
x ∈X, y ∈Y, n ∈N. Since for every n ∈N there exists an x ∈X such that x  f (n), this set is equal to
the set of equivalence classes of X ⊔Y under the equivalence relation generated by x ∼y if there exists
n such that x  f (n) and y  1(n). This is exactly the description of Example 6.25.
Solution to Exercise 6.48.
The monoidal product is
A + B
N + P
B + C
Solution to Exercise 6.49.
Let x and y be composable cospans in CospanFinSet. In terms of wires and connected components,
the composition rule in CospanFinSet says that (i) the composite cospan has a unique element in the
apex for every connected component of the concatenation of the wire diagrams x and y, and (ii) in the
wire diagram for x # y, each element of the feet is connected by a wire to the element representing the
connected component to which it belongs.
Solution to Exercise 6.57.
Morphisms 1, 4, and 6 are equal, and morphisms 3 and 5 are equal. Morphism 3 is not equal to any
other depicted morphism. This is an immediate consequence of Theorem 6.55.
Solution to Exercise 6.59.
1. The input to h should be labelled B.

308
APPENDIX A. EXERCISE SOLUTIONS
2. The output of 1 should be labelled D, since we know from the labels in the top right that h is a
morphism B →D ⊗D.
3. The fourth output wire of the composite should be labelled D too!
Solution to Exercise 6.62.
We draw the function depictions above, and the wiring depictions below. Note that we depict the
empty set with blank space.
1 + 1
1
1
multiplication µ1

1
1
unit η1
1
1
1 + 1
comultiplication δ1
1
1

counit ϵ1
Solution to Exercise 6.63.
The special law says that the composite of cospans
 X
id
−→X
[id,id]
←−−−−−X + X
[id,id]
−−−−−→X
id
←−X
is the identity. This comes down to checking that the square
X + X
X
X
X
[id,id]
[id,id]
id
id
(A.2)
is a pushout square. It is trivial to see that the square commutes. Suppose now that we have maps
f : X →Y and 1 : X →Y such that
X + X
X
X
T
[id,id]
[id,id]
f
1
Write ι1 : X →X + X for the map into the ﬁrst copy of X in X + X, given by the deﬁnition of coproduct.
Then, using the fact that ι1 # [id, id]  id from Exercise 6.17 1, and the commutativity of the above
square, we have f  ι1 # [id, id] # f  ι1 # [id, id] # 1  1. This means that f : X →T is the unique map
such that
X
X
X
X
T
[id,id]
[id,id]
id
f
id
1 f
f
commutes, and so (A.2) is a pushout square.
Solution to Exercise 6.67.
The missing diagram is

A.6. SOLUTIONS FOR CHAPTER 6
309
Solution to Exercise 6.70.
Let A ⊆S and B ⊆T. Then
ϕS′,T′

(im f × im1)(A × B)

 ϕS′,T′({ f (a) | a ∈A} × {1(b) | b ∈B})
 {( f (a), 1(b)) | a ∈A, b ∈B}
 im f ×1(A × B)
 im f ×1(ϕS,T(A, B)).
Thus the required square commutes.
Solution to Exercise 6.78.
They mean that every category CospanC is equal to a category CospanF, for some well-chosen F. They
also tell you how to choose this F: take the functor F : C →Set that sends every object of C to the set
{∗}, and every morphism of C to the identity function on {∗}. Of course, you will have to check this
functor is a lax symmetric monoidal functor, but in fact this is not hard to do.
To check that CospanC is equal to CospanF, ﬁrst observe that they have the same objects: the objects of
C. Next, observe that a morphism in CospanF is a cospan X ←N →Y in C together with an element
of FN  {∗}. But FN also has a unique element, ∗! So there’s no choice here, and we can consider
morphisms of CospanF just to be cospans in C. Moreover, composition of morphisms in CospanF is
simply the usual composition of cospans via pushout, so CospanF  CospanC.
(More technically, we might say that CospanC and CospanF are isomorphic, where the isomorphism
is the identity-on-objects functor CospanC →CospanF that simply decorates each cospan with ∗, and
its inverse is the one that forgets this ∗. But this is close enough to equal that many category theorists,
us included, don’t mind saying equal in this case.)
Solution to Exercise 6.79.
We can represent the circuit in Eq. (6.71) by the tuple (V, A, s, t, ℓ) where V  {ul, ur, dl, dr}, A 
{r1, r2, r3, c1, i1}, and s, t, and ℓare deﬁned by the table
r1
r2
r3
c1
i1
s(−)
dl
ul
ur
ul
dl
t(−)
ul
ur
dr
ur
dr
ℓ(−)
1Ω
2Ω
1Ω
3F
1H
Solution to Exercise 6.80.
The circuit Circ( f )(c) is
3Ω
1
2 ∼3
4
Solution to Exercise 6.82.
The circuit ψ2,2(b, s) is the disjoint union of the two labelled graphs b and s:
Solution to Exercise 6.84.
The cospan is the cospan 1
f
−→2
1
←−1, where f (1)  1 and 1(1)  2. The decoration is the C-circuit
(2, {a}, s, t, ℓ), where s(a)  1, t(a)  2 and ℓ(a)  battery.

310
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 6.86.
Recall the circuit C B (V, A, s, t, ℓ) from the solution to Exercise 6.79. Then the ﬁrst decorated cospan
is given by the cospan 1
f
−→V
1
←−2, f (1)  ul, 1(1)  ur, and 1(2)  ur, decorated by circuit C. The
second decorated cospan is given by the cospan 2
f ′
−→V′
1′
←−2 and the circuit C′ B (V′, A′, s′, t′, ℓ′),
where V′  {l, r, d}, A′  {r1′, r2′}, and the functions are given by the tables
1
2
f ′(−)
l
d
1′(−)
r
r
r1’
r2’
s(−)
l
r
t(−)
r
d
ℓ(−)
5Ω
8Ω
To compose these, we ﬁrst take the pushout of V
1
←−2
f ′
−→V′.
This gives the a new apex V′′ 
{ul, dl, dr, m, r} with ﬁve elements, and composite cospan 1
h−→V′′
k←−2 given by h(1)  ul, k(1)  r
and k(2)  m. The new circuit is given by (V,′′ A + A′, s,′′ t,′′ ℓ′′) where the functions are given by
r1
r2
r3
c1
i1
r1’
r2’
s′′(−)
dl
ul
m
ul
dl
m
r
t′′(−)
ul
m
dr
m
dr
r
m
ℓ′′(−)
1Ω
2Ω
1Ω
3F
1H
5Ω
8Ω
This is exactly what is depicted in Eq. (6.74).
Solution to Exercise 6.88.
Composing η and x we have
η # x  
 
and composing the result of ϵ gives
η # x # ϵ  

 

Solution to Exercise 6.96.
1. The cospan shown left corresponds to the wiring diagram shown right:
inner circles’ ports
links
outer circle’s ports

A.6. SOLUTIONS FOR CHAPTER 6
311
It has two inner circles, each with two ports. One port of the ﬁrst is wired to a port of the second.
One port of the ﬁrst is wired to the outside circle, and one port of the second is wired to the
outside circle. This is exactly what the cospan says to do.
2. The cospan shown left corresponds to the wiring diagram shown right:
inner circles’ ports
links
outer circle’s ports
3. The composite 1 ◦1 f has arity (2, 2, 2, 2; 0); there is a depiction on the left:
inner circles’ ports
links
outer circle’s ports
4. The associated wiring diagram is shown on the right above. One can see that one diagram has
been substituted in to a circle of the other.

312
APPENDIX A. EXERCISE SOLUTIONS
A.7
Solutions for Chapter 7.
Solution to Exercise 7.4.
In the commutative diagram below, suppose the (B, C, B′, C′) square is a pullback:
A
B
C
A′
B′
C′
f
h1
1
h2
h3
f ′
1′
⌟
We need to show that the (A, B, A′, B′) square is a pullback iﬀthe (A, C, A′, C′) rectangle is a pullback.
Suppose ﬁrst that (A, B, A′, B′) is a pullback, and take any (X, p, q) as in the following diagram:
X
A
B
C
A′
B′
C′
p
q
f
h1
1
h2
h3
f ′
1′
⌟
where q # f ′ # 1′  p # h3. Then by the universal property of the (B, C, B′, C′) pullback, we get a unique
dotted arrow r making the left-hand diagram below commute:
X
B
C
B′
C′
p
q# f ′
r
1
h2
h3
1′
⌟
X
A
B
C
A′
B′
C′
r
q
r′
f
h1
1
h2
h3
f ′
1′
⌟
In other words r # h2  1 # f ′ and r # 1  p. Then by the universal property of the (A, B, A′, B′) pullback,
we get a unique dotted arrow r′: X →A making the right-hand diagram commute, i.e. r′ # f  r and
r′ # h1  q. This gives the existence of an r with the required property, r′ # f  r and r′ # f # 1  r # 1  p.
To see uniqueness, suppose given another morphisms r0 such that r0 # f # 1  p and r0 # h1  q:
X
A
B
C
A′
B′
C′
r0
p
q
f
h1
1
h2
h3
f ′
1′
⌟
Then by the uniqueness of r, we must have r0 # f  r, and then by the uniqueness of r′, we must have
r0  r′. This proves the ﬁrst result.
The second is similar. Suppose that (A, C, A′, C′) and (B, C, B′, C′) are pullbacks and suppose given a
commutative diagram of the following form:
X
A
B
C
A′
B′
C′
r
q
f
h1
1
h2
h3
f ′
1′
⌟
i.e. where r # h2  q # f ′. Then letting p B r # 1, we have
p # h3  r # 1 # h3  r # h2 # 1′  q # f ′ # 1′

A.7. SOLUTIONS FOR CHAPTER 7
313
so by the universal property of the (A, C, A′, C′) pullback, there is a unique morphism r′: X →A such
that r′ # f # 1  p and r0 # h1  q, as shown:
X
A
B
C
A′
B′
C′
r′
r
p
q
f
h1
1
h2
h3
f ′
1′
⌟
But now let r0 B r′ # f . It satisﬁes r0 # 1  p and r0 # h2  q # f ′, and r satisﬁes the same equations:
r # 1  p and r # h2  q # f ′. Hence by the universal property of the (B, C, B′, C′) pullback r0  r′. It
follows that r′ is a pullback of the (A, B, A′, B′) square, as desired.
Solution to Exercise 7.6.
A function f : A →B is injective iﬀfor all a1, a2 ∈A, if f (a1)  f (a2) then a1  a2. It is a monomorphism
iﬀfor all sets X and functions 11, 12 : X →A, if 11 # f  12 # f then 11  12. Indeed, this comes directly
from the universal property of the pullback from Deﬁnition 7.5,
X
A
A
A
B
11
12
idA
idA
f
f
⌟
because the dashed arrow is forced to equal both 11 and 12, thus forcing 11  12.
1. Suppose f is a monomorphism, let a1, a2 ∈A be elements, and suppose f (a1)  f (a2). Let
X  {∗} be a one element set, and let 11, 12 : X →A be given by 11(∗) B a1 and 12(∗) B a2. Then
11 # f  12 # f , so 11  12, so a1  a2.
2. Suppose that f is an injection, let X be any set, and let 11, 12 : X →A be such that 11 # f  12 # f .
We will have 11  12 if we can show that 11(x)  12(x) for every x ∈X. So take any x ∈X; since
f (11(x))  f (12(x)) and f is injective, we have 11(x)  12(x) as desired.
Solution to Exercise 7.7.
1. Suppose we have a pullback as shown, where i is an isomorphism:
A′
B′
A
B
f ′
i′
i

f
⌟
Let j B i−1 be the inverse of i, and consider 1 B ( f # j): A →B′. Then 1 # i  f , so by the
existence part of the universal property, there is a map j′: A →A′ such that j′ # i′  idA and
j′ # f ′  f # j. We will be done if we can show i′ # j′  idA′. One checks that (i′ # j′) # i′  i′ and
that (i′ # j′) # f ′  i′ # f # j  f ′ # i # j  f ′. But idA′ also satisﬁes those properties: idA′ # i′  i′ and
idA′ # f ′  f ′, so by the uniqueness part of the universal property, (i′ # j′)  idA′.
2. We need to show that the following diagram is a pullback:
A
B
A
B
f
f
⌟
So take any object X and morphisms 1 : X →A and h : X →B such that 1 # f  h # idB. We need
to show there is a unique morphism r : X →A such that r # idA  1 and r # f  h. That’s easy:
the ﬁrst requirement forces r  1 and the second requirement is then fulﬁlled.

314
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 7.8.
Consider the diagram shown left, in which all three squares are pullbacks:
A
A′
A
A′
A
B′
B
1
f
1
f ′
f
f ′
h
A′
A
A′
A
A′
A
B′
B
1
1
f
1
f ′
f
f ′
h
The front and bottom squares are the same—the assumed pullback—and the right-hand square is a
pullback because f is assumed monic. We can complete it to the commutative diagram shown right,
where the back square and top square are pullbacks by Exercise 7.7. Our goal is to show that the
left-hand square is a pullback.
To do this, we use two applications of the pasting lemma, Exercise 7.4. Since the right-hand face is a
pullback and the back face is a pullback, the diagonal rectangle (lightly drawn) is also a pullback. Since
the front face is a pullback, the left-hand face is also a pullback.
Solution to Exercise 7.9.
The following is an epi-mono factorization of f :
•
•
•
•
•
•
•
•
Solution to Exercise 7.11.
1. If V is a quantale with the stated properties, then
• I serves as a top element: v ≤I for all v ∈V.
• v ⊗w serves as a meet operation, i.e. it satisﬁes the same universal property as ∧, namely
v ⊗w is a greatest lower bound for v and w.
Now the ⊸operation satisﬁes the same universal property as exponentiation (hom-object) does,
namely v ≤(w ⊸x) iﬀv ⊗W ≤x. So V is a cartesian closed category, and of course it is a
preorder.
2. Not every cartesian closed preorder comes from a quantale with the stated properties, because
quantales have all joins and cartesian closed preorders need not. Finding a counterexample—a
cartesian closed preorder that is missing some joins—takes some ingenuity, but it can be done.
Here’s one we came up with:
(0, 0)
(0, 1)
(0, 2)
(0, 3)
(1, 0)
(1, 1)
(1, 2)
(2, 0)
(1, 1)
(3, 0)
This is the product preorder Nop × Nop: its objects are pairs (a, b) ∈N × N with (a, b) ≤(a′, b′)
iﬀ, in the usual ordering on N we have a′ ≤a and b′ ≤b. But you can just look at the diagram.
It has a top element, (0, 0), and it has binary meets, (a, b) ∧(a′, b′)  (max(a, a′), max(b, b′)). But
it has no bottom element, so it has no empty join. Thus we will be done if we can show that for

A.7. SOLUTIONS FOR CHAPTER 7
315
each x, y, the hom-object x ⊸y exists. The formula for it is x ⊸y  Ô{w | w ∧x ≤y}, i.e. we
need these particular joins to exist. Since y ∧x ≤y, we have y ≤x ⊸y. So we can replace the
formula with x ⊸y  Ô{w | y ≤w and w ∧x ≤y}. But the set of elements in Nop × Nop that
are bigger than y is ﬁnite and nonempty.2 So this is a ﬁnite nonempty join, and Nop × Nop has all
ﬁnite nonempty joins: they are given by inf.
Solution to Exercise 7.16.
Let m : Z →B be the characteristic function of the inclusion N ⊆Z.
1. ⌜m⌝(−5)  false.
2. ⌜m⌝(0)  true.
Solution to Exercise 7.17.
1. The characteristic function ⌜idN⌝: N →B sends each n ∈N to true.
2. Let !N :  →N be the inclusion of the empty set. The characteristic function ⌜!N⌝: N →B sends
each n ∈N to false.
Solution to Exercise 7.19.
1. The sort of thing (*?*) we’re looking for is a subobject of B, say A ⊆B. This would have a
characteristic function, and we’re trying to ﬁnd the A for which the characteristic function is
¬: B →B.
2. The question now asks “what is A?” The answer is {false} ⊆B.
Solution to Exercise 7.20.
1. Here is the truth table for P  (P ∧Q):
P
Q
P ∧Q
P  (P ∧Q)
true
true
true
true
true
false
false
false
false
true
false
true
false
false
false
true
(A.3)
2. Yes!
3. The characteristic function for P ⇒Q is the function ⌜⇒⌝: B × B →B given by the ﬁrst, second,
and fourth column of Eq. (A.3).
4. It classiﬁes the subset {(true, true), (false, true), (false, false) ⊆B × B.
Solution to Exercise 7.21.
Say that ⌜E⌝, ⌜P⌝, ⌜T⌝: N →B classify respectively the subsets E B {n ∈N | n is even}, P B {n ∈N |
n is prime}, and T B {n ∈N | n ≥10} of N.
1. ⌜E⌝(17)  false because 17 is not even.
2. ⌜P⌝(17)  true because 17 is prime.
3. ⌜T⌝(17)  true because 17 ≥10.
4. The set classiﬁed by (⌜E⌝∧⌜P⌝) ∨⌜T⌝is that of all natural numbers that are either above 10 or
an even prime. The smallest three elements of this set are 2, 10, 11.
Solution to Exercise 7.27.
1. The 1-dimensional analogue of an ϵ-ball around a point x ∈R is B(x, ϵ) B {x′ ∈R | |x −x′| < ϵ},
i.e. the set of all points within ϵ of x.
2. A subset U ⊆R is open if, for every x ∈U there is some ϵ > 0 such that B(x, ϵ) ⊆U.
3. Let U1 B {x ∈R | 0 < x < 2} and U2 B {x ∈R | 1 < x < 3}. Then U B U1 ∪U2  {x ∈R | 0 <
x < 3}.
2If y  (a, b) then there are exactly (a + 1) ∗(b + 1) elements y′ for which y ≤y′.

316
APPENDIX A. EXERCISE SOLUTIONS
4. Let I  {1, 2, 3, 4, . . .} and for each i ∈I let Ui B {x ∈R | 1
i < x < 1}, so we have U1 ⊆U2 ⊆
U3 ⊆· · · . Their union is U B Ð
i∈I Ui  {x ∈R | 0 < x < 1}.
Solution to Exercise 7.29.
1. The coarse topology on X is the one whose only open sets are X ⊆X and  ⊆X. This is a
topology because it contains the top and bottom subsets, it is closed under ﬁnite intersection (the
intersection A ∩B is  iﬀone or the other is ), and it is closed under arbitrary union (the union
Ð
i∈I Ai is X iﬀAi  X for some i ∈I).
2. The ﬁne topology on X is the one where every subset A ⊆X is considered open.
All the
conditions on a topology say “if such-and-such then such-and-such is open,” but these are all
satisﬁed because everything is open!
3. If (X, P(X)) is discrete, (Y, OpY) is any topological space, and f : X →Y is any function then it
is continuous. Indeed, this just means that for any open set U ⊆Y the preimage f −1(U) ⊆X is
open, and everything in X is open.
Solution to Exercise 7.31.
1. The Hasse diagram for the Sierpinsky topology is  →{1} →{1, 2} .
2. A set (Ui)i∈I covers U iﬀeither
• I   and U  ; or
• Ui  U for some i ∈I.
In other words, the only way that some collection of these sets could cover another set U is if that
collection contains U or if U is empty and the collection is also empty.
Solution to Exercise 7.32.
Let (X, Op) be a topological space, suppose that Y ⊆X is a subset, and consider the subspace topology
Op?∩Y.
1. We want to show that Y ∈Op?∩Y. We need to ﬁnd B ∈Op such that Y  B ∩Y; this is easy, you
could take B  Y or B  X, or anything in between.
2. We still need to show that Op?∩Y contains  and is closed under ﬁnite intersection and arbitrary
union.    ∩Y, so according to the formula,  ∈Op?∩Y. Suppose that A1, A2 ∈Op?∩Y. Then
there exist B1, B2 ∈Op with A1  B1∩Y and A2  B2∩Y. But then A1∩A2  (B1∩Y)∩(B2∩Y) 
(B1 ∩B2) ∩Y, so it is in Op?∩Y since B1 ∩B2 ∈Op. The same idea works for arbitrary unions:
given a set I and Ai for each i ∈I, we have Ai  Bi ∩Y for some Bi ∈Op, and
Ø
i∈I
Ai 
Ø
i∈I
(Bi ∩Y) 
 Ø
i∈i
Bi
!
∩Y ∈Op?∩Y.
Solution to Exercise 7.34.
Let’s imagine a V-category C, where V is the quantale corresponding to the open sets of a topological
space (X, Op). Its Hasse diagram would be a set of dots and some arrows between them, each labeled
by an open set U ⊆Op. It might look something like this:
A•
B•
•
C
•
D
U5
U1
U2
U3
U4
C B

A.7. SOLUTIONS FOR CHAPTER 7
317
Recall from Section 2.3 that the ‘distance’ between two points is computed by taking the join, over all
paths between them, of the monoidal product of distances along that path. For example, C(B, C) 
(U3 ∧U1) ∨(U4 ∧U2), because ∧is the monoidal product in V.
In general, we can thus imagine the open set C(a, b) as a kind of ‘size restriction’ for getting from a to b,
like bridges that your truck needs to pass under. The size restriction for getting from a to itself is X: no
restriction. In general, to go on any given route (path) from a to b, you have to ﬁt under every bridge
in the path, so we take their meet. But we can go along any path, so we take the join over all paths.
Solution to Exercise 7.38.
•a
•b
•c
•d
•e
Y B
•
a1
•
a2
•
b1
•
b2
•
b3
•
c1
•
e1
•
e2
X B
f
(A.4)
1. The ﬁber of f over a is {a1, a2}.
2. The ﬁber of f over c is {c1}.
3. The ﬁber of f over d is .
4. A function f ′: X →Y for which every ﬁber has either one or two elements is shown below.
•a
•b
•c
•d
•e
Y B
•
e1
•
a2
•
b1
•
c1
•
b2
•
b3
•
a1
•
e2
X B
f
Solution to Exercise 7.40.
Refer to Eq. (A.4).
1. Here is a drawing of all six sections over V1  {a, b, c}:
•a
•
b
•c
•
•
•
•
•
•
11
•a
•
b
•c
•
•
•
•
•
•
12
•a
•
b
•c
•
•
•
•
•
•
13
•a
•
b
•c
•
•
•
•
•
•
14
•a
•
b
•c
•
•
•
•
•
•
15
•a
•
b
•c
•
•
•
•
•
•
16
2. When V2  {a, b, c, d}, there are no sections: Sec f (V2)  .
3. When V3  {a, b, d, e}, the set Sec f (V3)) has 2 ∗3 ∗1 ∗2  12 elements.

318
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 7.42.
Sec f ({a, b, c}) and Sec f ({a, c}) are drawn as the top row (six-element set) and bottom row (two-element
set) below, and the restriction map is also shown:
(a1, b1, c1)
(a1, b2, c1)
(a1, b3, c1)
(a2, b1, c1)
(a2, b2, c1)
(a2, b3, c1)
(a1, c1)
(a2, c1)
Solution to Exercise 7.44.
1. Let 11 B (a1, b1) and 12 B (b2, e1); these do not agree on the overlap.
2. No, there’s no section 1 ∈Sec f (U1 ∪U2) for which 1

U1  11 and 1

U2  12.
•a
•b
•
a1
•
a2
•
b1
•
b2
•
b3
h1
•b
•e
•
b1
•
b2
•
b3
•
e1
•
e2
h2
3.
•a
•b
•e
•
a1
•
a2
•
b1
•
b2
•
b3
•
e1
•
e2
glued section
4.
Solution to Exercise 7.47.
No, there is not a one-to-one correspondence between sheaves on M and vector ﬁelds on M. The
relationship between sheaves on M and vector ﬁelds on M is that the set of all vector ﬁelds on M
corresponds to one sheaf, namely Secπ, where π: TM →M is the tangent bundle as described in
Example 7.46. There are so many sheaves on M that they don’t even form a set (it’s just a ‘collection’);
again, one member of this gigantic collection is the sheaf Secπ of all possible vector ﬁelds on M.
Solution to Exercise 7.49.
1. The Hasse diagram for the Sierpinsky topology is  →{1} →{1, 2} .
2. A presheaf F on Op consists of any three sets and any two functions F({1, 2}) →F({1}) →F()
between them.
3. Recall from Exercise 7.31 that the only non-trivial covering (a covering of U is non-trivial if it does
not contain U) occurs when U   in which case the empty family over U is a cover.
4. As explained in Example 7.36, F will be a sheaf iﬀF()  {1}. Thus we the category of sheaves
is equivalent to that of just two sets and one function F({1, 2}) →F({1}).
Solution to Exercise 7.52.
The one-point space X  {1} has two open sets,  and {1}, and every sheaf S ∈Shv(X) assigns
S()  {()} by the sheaf condition (see Example 7.36). So the only data in a sheaf S ∈Shv(X) is the set
S({1}). This is how we get the correspondence between sets and sheaves on the one point space.
According to Eq. (7.50), the subobject classiﬁer Ω: Op(X)op →Set in Shv(X) should be the functor
where Ω({1}) is the set of open sets of {1}. So we’re hoping to see that there is a one-to-one correspon-
dence between the set Op({1}) and the set B  {true, false} of booleans. Indeed there is: there are
two open sets of {1}, as we said,  and {1}, and these correspond to false and true respectively.
Solution to Exercise 7.53.
By Eqs. (7.50) and (7.51) the deﬁnition of Ω(U) is Ω(U) B {U′ ∈Op | U′ ⊆U}, and the deﬁnition of
the restriction map for V ⊆U is U′ 7→U′ ∩V.

A.7. SOLUTIONS FOR CHAPTER 7
319
1. It is functorial: given W ⊆V ⊆U and U′ ⊆U, we indeed have (U′ ∩V) ∩W  U′ ∩W, since
W ⊆V. For functoriality, we also need preservation of identities, and this amounts to U′∩U  U′
for all U′ ⊆U.
2. Yes, a presheaf is just a functor; the above check is enough.
Solution to Exercise 7.55.
We need a graph homomorphism of the following form:
A•
B•
C•
D•
f
1
h
i
⌜G′⌝
−−−−−−−−→
0
V
(0,0; 0)
(0,V; 0)
(V,V; 0)
(V,V; A)
(V,0; 0)
There is only one that classiﬁes G′, and here it is. Let’s write γ B ⌜G′⌝.
• Since D is missing from G′, we have γ(D)  0 (vertex: missing).
• Since vertices A, B, C are present in G′ we have γ(A)  γ(B)  γ(C)  V (vertex: present).
• The above forces γ(i)  (V, 0; 0) (arrow from present vertex to missing vertex: missing).
• Since the arrow f is in G′, we have γ( f )  (V, V; A) (arrow from present vertex to present vertex:
present).
• Since the arrows 1 and h are missing in G′, we have γ(1)  γ(h)  (V, V; 0) (arrow from present
vertex to present vertex: missing).
Solution to Exercise 7.59.
With U  R −{0} ⊆R, we have:
1. The complement of U is R −U  {0} and ¬U is its interior, which is ¬U  .
2. The complement of ¬U is R −  R, and this is open, so ¬¬U  R.
3. It is true that U ⊆¬¬U.
4. It is false that ¬¬U ⊆? U.
Solution to Exercise 7.60.
1. If for any V ∈Op we have ⊤∧V  V then when V  X we have ⊤∧X B ⊤∩X  X, but
anything intersected with X is itself, so ⊤ ⊤∩X  X.
2. (⊤∨V) B (X ∪V)  X holds and (V ⇒X)  Ð
{R∈Op|R∩V⊆X} R  X holds because (X ∩V) ⊆X.
3. If for any set V ∈Op we have (⊥∨V)  V, then when V  ∅we have (⊥∨)  (⊥∪)  , but
anything unioned with  is itself, so ⊥ ⊥∪  .
4. (⊥∧V)  ( ∩V)   holds, and (⊥⇒V)  Ð
{R∈Op|R∩⊆V} R  X holds because (X ∩) ⊆V.
Solution to Exercise 7.62.
S is the sheaf of people, the set of which changes over time: a section in S over any interval of time is
a person who is alive throughout that interval. A section in the subobject {S | p} over any interval of
time is a person who is alive and likes the weather throughout that interval of time.
Solution to Exercise 7.64.
We need an example of a space X, a sheaf S ∈Shv(X), and two predicates p, q : S →Ωfor which
p(s) ⊢s:S q(s) holds. Take X to be the one-point space, take S to be the sheaf corresponding to the set
S  N, let p(s) be the predicate “24 ≤s ≤28,” and let q(s) be the predicate “s is not prime.” Then
p(s) ⊢s:S q(s) holds.
As an informal example, take X to be the surface of the earth, take S to be the sheaf of vector ﬁelds
as in Example 7.46 thought of in terms of wind-blowing. Let p be the predicate “the wind is blowing
due east at somewhere between 2 and 5 kilometers per hour” and let q be the predicate “the wind is
blowing at somewhere between 1 and 5 kilometers per hour.” Then p(s) ⊢s:S q(s) holds. This means

320
APPENDIX A. EXERCISE SOLUTIONS
that for any open set U, if the wind is blowing due east at somewhere between 2 and 5 kilometers
per hour throughout U, then the wind is blowing at somewhere between 1 and 5 kilometers per hour
throughout U as well.
Solution to Exercise 7.66.
We have the predicate p : N × Z →B given by p(n, z) iﬀn ≤|z|.
1. The predicate ∀(z : Z). p(n, z) holds for {0} ⊆N.
2. The predicate ∃(z : Z). p(n, z) holds for N ⊆N.
3. The predicate ∀(n : N). p(n, z) holds for  ⊆Z.
4. The predicate ∃(n : N). p(n, z) holds for Z ⊆Z.
Solution to Exercise 7.67.
Suppose s is a person alive throughout the interval U. Apply the above deﬁnition to the example
p(s, t)  “person s is worried about news t” from above.
1. The formula says that ∀(t : T). p(s, t) “returns the largest open set V ⊆U for which p(s

V , t)  V
for all t ∈T(V).” Note that T(V) is the set of items that are in the news throughout the interval
V. Substituting, this becomes “the largest interval of time V ⊆U over which person s is worried
about news t for every item t that is in the news throughout V.” In other words, for V to be
nonempty, the person s would have to be worried about every single item of news throughout V.
My guess is that there’s a festival happening or a happy kitten somewhere that person s is not
worried about, but maybe I’m assuming that person s is suﬃciently mentally “normal.” There
may be people who are sometimes worried about literally everything in the news; we ask you to
please be kind to them.
2. Yes, it is exactly the same description.
Solution to Exercise 7.68.
Suppose s is a person alive throughout the interval U. Apply the above deﬁnition to the example
p(s, t)  “person s is worried about news t” from above.
1. The formula says that ∃(t : T). p(s, t) “returns the union V  Ð
i Vi of all the open sets Vi for
which there exists some ti ∈T(Vi) satisfying p(s

Vi , ti)  Vi.” Substituting, this becomes “the
union of all time intervals Vi for which there is some item ti in the news about which s is worried
throughout Vi.” In other words it is all the time that s is worried about at least one thing in
the news. Perhaps when s is sleeping or concentrating on something, she is not worried about
anything, in which case intervals of sleeping or concentrating would not be subsets of V. But if
s said “there’s been such a string of bad news this past year, it’s like I’m always worried about
something!,” she is saying that it’s like V “this past year.”
2. This seems like a good thing for “there exists a piece of news that worries s” to mean: the news
itself is allowed to change as long as the person’s worry remains. Someone might disagree and
think that the predicate should mean “there is one piece of news that worries s throughout the
whole interval V.” In that case, perhaps this person is working within a diﬀerent topos, e.g. one
where the site has fewer coverings. Indeed, it is the notion of covering that makes existential
quantiﬁcation work the way it does.
Solution to Exercise 7.70.
It is clear that if j(j(q))  j(q) then j(j(q)) ≤j(q) by reﬂexivity.
On the other hand, assume the
hypothesis, that p ≤j(p) for all U ⊆X and p ∈Ω(U). If j(j(q)) ≤j(q), then letting p B j(q) we have
both j(p) ≤p and p ≤j(p). This means p  j(p), but Ωis a poset (not just a preorder) so p  j(p), i.e.
j(j(q))  j(q) as desired.
Solution to Exercise 7.72.
Let S be the sheaf of people and j be “assuming Bob is in San Diego...”
1. Take p(s) to be “s likes the weather.”

A.7. SOLUTIONS FOR CHAPTER 7
321
2. Let U be the interval 2019/01/01 – 2019/02/01. For an arbitrary person s ∈S(U), p(s) is a subset
of U, and it means the subset of U throughout which s likes the weather.
3. Similarly j(p(s)) is a subset of U, and it means the subset of U throughout which, assuming Bob
is in San Diego, s liked the weather. In other words, j(p(s)) is true whenever Bob is not in San
Diego, and it is true whenever s likes the weather.
4. It is true that p(s) ≤j(p(s)), by the ‘in other words’ above.
5. It is true that j(j(p(s))  j(p(s), because suppose given a time during which “if Bob is in San
Diego then if Bob is in San Diego then s likes the weather.” Then if Bob is in San Diego during
this time then s likes the weather. But that is exactly what j(p(s)) means.
6. Take q(s) to be “s is happy.” Suppose “if Bob is in San Diego then both s likes the weather and s
is happy.” Then both “if Bob is in San Diego then s likes the weather” and “if Bob is in San Diego
then s is happy” are true too. The converse is equally clear.
Solution to Exercise 7.76.
We have o[a,b] B {[d, u] ∈IR | a < d ≤u < b}.
1. Since 0 ≤2 ≤6 ≤8, we have [2, 6] ∈o[0,8] by the above formula.
2. In order to have [2, 6] ∈? o[0,5]∪o[4,8], we would need to have either [2, 6] ∈? o[0,5] or [2, 6] ∈? o[4,8].
But the formula does not hold in either case.
Solution to Exercise 7.77.
A subset U ⊆R is open in the subspace topology of R ⊆IR iﬀthere is an open set U′ ⊆IR with
U  U′ ∩R. We want to show that this is the case iﬀU is open in the usual topology.
Suppose that U is open in the subspace topology. Then U  U′∩R, where U′ ⊆IR is the union of some
basic opens, U′  Ð
i∈I o[ai,bi], where o[ai,bi]  {[d, u] ∈IR | ai < d < u < bi}. Since R  {[x, x] ∈IR},
the intersection U′ ∩R will then be
U 
Ø
i∈I
{x ∈R | ai < x < bi}
and this is just the union of open balls B(mi, ri) where mi B ai+bi
2
is the midpoint and ri B bi−ai
2
is
the radius of the interval (ai, bi). The open balls B(mi, ri) are open in the usual topology on R and the
union of opens is open, so U is open in the usual topology.
Suppose that U is open in the usual topology. Then U  Ð
j∈J B(mj, ϵj) for some set J. Let aj B mj −ϵj
and bj B mj + ϵj. Then
U 
Ø
j∈J
{x ∈R | aj < x < bj} 
Ø
j∈J
(o[aj,bj] ∩R)  ©­
«
Ø
j∈J
o[aj,bj]ª®
¬
∩R
which is open in the subspace topology.
Solution to Exercise 7.80.
Fix any topological space (X, OpX) and any subset R ⊆IR of the interval domain. Deﬁne HX(U) B
{ f : U ∩R →X | f is continuous}.
1. HX is a presheaf: given V ⊆U the restriction map sends the continuous function f : U ∩R →X
to its restriction along the subset V ∩R ⊆U ∩R.
2. It is a sheaf: given any family Ui of open sets with U  Ð
i Ui and a continuous function
fi : Ui ∩R →X for each i, agreeing on overlaps, they can be glued together to give a continuous
function on all of U ∩R, since U ∩R  (Ð
i Ui) ∩R  Ð
i(Ui ∩R).


Bibliography
[Ada17]
Elie M. Adam. “Systems, Generativity and Interactional Eﬀects”. Available
online: http://www.mit.edu/~eadam/eadam_PhDThesis.pdf. PhD thesis.
Massachusetts Institute of Technology, July 2017 (cit. on pp. 2, 26, 36).
[AGV71]
Michael Artin, Alexander Grothendieck, and Jean-Louis Verdier. Theorie de
Topos et Cohomologie Etale des Schemas I, II, III. Vol. 269, 270, 305. Lecture
Notes in Mathematics. Springer, 1971 (cit. on p. 256).
[AJ94]
Samson Abramsky and Achim Jung. “Domain theory”. In: Handbook of logic
in computer science. Oxford University Press. 1994 (cit. on p. 257).
[AS05]
Aaron D. Ames and Shankar Sastry. “Characterization of Zeno behavior in
hybrid systems using homological methods”. In: American Control Confer-
ence, 2005. Proceedings of the 2005. IEEE. 2005, pp. 1160–1165 (cit. on p. 257).
[AV93]
Samson Abramsky and Steven Vickers. “Quantales, observational logic
and process semantics”. In: Mathematical Structures in Computer Science 3.2
(1993), pp. 161–227 (cit. on p. 76).
[Awo10]
Steve Awodey. Category theory. Second. Vol. 52. Oxford Logic Guides. Ox-
ford University Press, Oxford, 2010, pp. xvi+311 (cit. on p. 114).
[BD98]
John C Baez and James Dolan. Categoriﬁcation. 1998. eprint: math/9802029
(cit. on p. 145).
[BE15]
John C. Baez and Jason Erbele. “Categories in control”. In: Theory and
Applications of Categories 30 (2015), Paper No. 24, 836–881 (cit. on pp. 170,
179).
[BF15]
John C. Baez and Brendan Fong. “A compositional framework for passive
linear networks”. In: (2015). url: https://arxiv.org/abs/1504.05625
(cit. on p. 219).
[BFP16]
John C. Baez, Brendan Fong, and Blake S Pollard. “A compositional frame-
work for Markov processes”. In: Journal of Mathematical Physics 57.3 (2016)
(cit. on p. 219).
323

324
BIBLIOGRAPHY
[BH08]
Philip A Bernstein and Laura M Haas. “Information integration in the
enterprise”. In: Communications of the ACM 51.9 (2008), pp. 72–79 (cit. on
p. 77).
[Bor94]
Francis Borceux. Handbook of categorical algebra 1. Vol. 50. Encyclopedia of
Mathematics and its Applications. Basic category theory. Cambridge Uni-
versity Press, Cambridge, 1994 (cit. on pp. 114, 192).
[BP17]
John C Baez and Blake S Pollard. “A compositional framework for reaction
networks”. In: Reviews in Mathematical Physics 29.09 (2017) (cit. on p. 219).
[Bro61]
Ronnie Brown. “Some problems of algebraic topology: a study of function
spaces, function complexes, and FD-complexes”. PhD thesis. University of
Oxford, 1961 (cit. on p. 76).
[BS17]
Filippo Bonchi and Fabio Sobociński Pawełand Zanasi. “The calculus of
signal ﬂow diagrams I: Linear relations on streams”. In: Information and
Computation 252 (2017), pp. 2–29 (cit. on pp. 170, 179).
[BSZ14]
Filippo Bonchi, Paweł Sobociński, and Fabio Zanasi. “A categorical seman-
tics of signal ﬂow graphs”. In: International Conference on Concurrency Theory.
2014, pp. 435–450 (cit. on p. 179).
[BSZ15]
Filippo Bonchi, Pawel Sobocinski, and Fabio Zanasi. “Full abstraction for
signal ﬂow graphs”. In: ACM SIGPLAN Notices. Vol. 50. 1. ACM. 2015,
pp. 515–526 (cit. on p. 179).
[BW90]
Michael Barr and Charles Wells. Category theory for computing science. Vol. 49.
Prentice Hall New York, 1990 (cit. on p. 114).
[Car91]
Aurelio Carboni. “Matrices, relations, and group representations”. In: Jour-
nal of Algebra 136.2 (1991), pp. 497–529. url: http://www.sciencedirect.
com/science/article/pii/002186939190057F (cit. on p. 219).
[CD95]
Boris Cadish and Zinovy Diskin. “Algebraic graph-based approach to man-
agement of multibase systems, I: Schema integration via sketches and equa-
tions”. In: proceedings of Next Generation of Information Technologies and Sys-
tems, NGITS. Vol. 95. 1995 (cit. on p. 114).
[Cen15]
Andrea Censi. A mathematical theory of co-design. 2015. eprint: arXiv:1512.
08055 (cit. on pp. 117, 145).
[Cen17]
Andrea Censi. “Uncertainty in Monotone Co-Design Problems”. In: IEEE
Robotics and Automation Letters (Feb. 2017). url: https://arxiv.org/abs/
1609.03103 (cit. on p. 145).
[CFS16]
Bob Coecke, Tobias Fritz, and Robert W. Spekkens. “A mathematical theory
of resources”. In: Information and Computation 250 (2016), pp. 59–86 (cit. on
pp. 48, 75).

BIBLIOGRAPHY
325
[CK17]
Bob Coecke and Aleks Kissinger. Picturing quantum processes. Cambridge
University Press, 2017 (cit. on p. iv).
[CP10]
Bob Coecke and Eric Oliver Paquette. “Categories for the practising physi-
cist”. In: New Structures for Physics. Springer, 2010, pp. 173–286 (cit. on p. iv).
[CW87]
A. Carboni and R.F.C. Walters. “Cartesian bicategories I”. In: Journal of Pure
and Applied Algebra49.1(1987),pp. 11–32. url: http://www.sciencedirect.
com/science/article/pii/0022404987901216 (cit. on p. 219).
[CY96]
Louis Crane and David N Yetter. Examples of categoriﬁcation. 1996. eprint:
q-alg/9607028 (cit. on p. 145).
[FGR03]
Michael Fleming, Ryan Gunther, and Robert Rosebrugh. “A database of
categories”. In: Journal of Symbolic Computation 35 (2003), Paper No. 2, 127–
135 (cit. on p. 114).
[Fon15]
Brendan Fong. “Decorated cospans”. In: Theory and Applications of Categories
30.33 (2015), pp. 1096–1120 (cit. on p. 219).
[Fon16]
Brendan Fong. “The Algebra of Open and Interconnected Systems”. PhD
thesis. University of Oxford, 2016 (cit. on p. 219).
[Fon18]
Brendan Fong. “Decorated corelations”. In: Theory and Applications of Cate-
gories 33.22 (2018), pp. 608–643 (cit. on p. 219).
[Fra67]
John B. Fraleigh. A ﬁrst course in abstract algebra. Addison-Wesley Publishing
Co., Reading, Mass.-London-Don Mills, Ont., 1967, pp. xvi+447 (cit. on
p. 179).
[Fri17]
Tobias Fritz. “Resource convertibility and ordered commutative monoids”.
In: Mathematical Structures in Computer Science 27.6 (2017), pp. 850–938 (cit.
on pp. 48, 75).
[FS18a]
Brendan Fong and Maru Sarazola. A recipe for black box functors. 2018 (cit. on
p. 219).
[FS18b]
Brendan Fong and David I Spivak. Hypergraph Categories. 2018. eprint:
arXiv:1806.08304 (cit. on p. 219).
[FSR16]
Brendan Fong, Paweł Sobociński, and Paolo Rapisarda. “A categorical ap-
proach to open and interconnected dynamical systems”. In: Proceedings of
the 31st Annual ACM/IEEE Symposium on Logic in Computer Science. ACM.
2016, pp. 495–504 (cit. on pp. 168, 179).
[Gie+03]
G. Gierz, K. H. Hofmann, K. Keimel, J. D. Lawson, M. Mislove, and D. S.
Scott. Continuous lattices and domains. Vol. 93. Encyclopedia of Mathemat-
ics and its Applications. Cambridge University Press, Cambridge, 2003,
pp. xxxvi+591 (cit. on p. 257).

326
BIBLIOGRAPHY
[Gla13]
K Glazek. A Guide to the Literature on Semirings and their Applications in
Mathematics and Information Sciences: With Complete Bibliography. Springer
Science & Business Media, 2013 (cit. on p. 179).
[Gra18]
Marco Grandis. Category Theory and Applications. World Scientiﬁc, 2018 (cit.
on p. 114).
[HMP98]
Claudio Hermida, Michael Makkai, and John Power. “Higher-dimensional
multigraphs”. In: Thirteenth Annual IEEE Symposium on Logic in Computer
Science (Indianapolis, IN, 1998). IEEE Computer Soc., Los Alamitos, CA,
1998, pp. 199–206 (cit. on p. 214).
[HTP03]
Esfandiar Haghverdi, Paulo Tabuada, and George Pappas. “Bisimulation
relations for dynamical and control systems”. In: Electronic Notes in Theo-
retical Computer Science 69 (2003), pp. 120–136 (cit. on p. 257).
[IP94]
Amitavo Islam and WesleyPhoa. “Categoricalmodelsofrelationaldatabases
I: Fibrational formulation, schema integration”. In: International Symposium
on Theoretical Aspects of Computer Software. Springer. 1994, pp. 618–641 (cit.
on p. 114).
[Jac99]
Bart Jacobs. Categorical logic and type theory. Vol. 141. Studies in Logic and the
Foundations of Mathematics. North-Holland Publishing Co., Amsterdam,
1999, pp. xviii+760 (cit. on p. 257).
[JNW96]
André Joyal, Mogens Nielsen, and Glynn Winskel. “Bisimulation from open
maps”. In: Information and Computation 127.2 (1996), pp. 164–185 (cit. on
p. 257).
[Joh02]
Peter T. Johnstone. Sketches of an elephant: a topos theory compendium. Vol. 43.
Oxford Logic Guides. New York: The Clarendon Press Oxford University
Press, 2002, pp. xxii+468+71 (cit. on p. 257).
[Joh77]
P. T. Johnstone. Topos theory. London Mathematical Society Monographs,
Vol. 10. Academic Press [Harcourt Brace Jovanovich, Publishers], London-
New York, 1977, pp. xxiii+367 (cit. on p. 223).
[JR02]
Michael Johnson and Robert Rosebrugh. “Sketch Data Models, Relational
Schema and Data Speciﬁcations”. In: Electronic Notes in Theoretical Computer
Science 61 (2002). CATS’02, Computing, pp. 51–63 (cit. on p. 114).
[JS93]
André Joyal and Ross Street. “Braided tensor categories”. In: Advances in
Mathematics 102.1 (1993), pp. 20–78 (cit. on pp. 40, 145).
[JSV96]
André Joyal, Ross Street,and DominicVerity. “Traced monoidalcategories”.
In: Mathematical Proceedings of the Cambridge Philosophical Society 119 (1996),
Paper No. 3, 447–468 (cit. on p. 145).

BIBLIOGRAPHY
327
[Kel05]
G. M. Kelly. “Basic concepts of enriched category theory”. In: Reprints
in Theory and Applications of Categories (2005), Paper No. 10. url: http:
//www.tac.mta.ca/tac/reprints/articles/10/tr10abs.html (cit. on
pp. 76, 139).
[Law04]
F William Lawvere. “Functorial Semantics of Algebraic Theories and Some
Algebraic Problems in the context of Functorial Semantics of Algebraic
Theories”. In: Reprints in Theory and Applications of Categories 5 (2004), pp. 1–
121 (cit. on p. 179).
[Law73]
F William Lawvere. “Metric spaces, generalized logic, and closed cate-
gories”. In: Rendiconti del seminario matématico e ﬁsico di Milano 43.1 (1973),
pp. 135–166 (cit. on pp. 76, 145).
[Law86]
Bill Lawvere. “State categories and response functors”. 1986 (cit. on p. 257).
[Lei04]
Tom Leinster. Higher operads, higher categories. London Mathematical Society
Lecture Note Series 298. Cambridge University Press, Cambridge, 2004 (cit.
on pp. 213, 218, 219).
[Lei14]
Tom Leinster. Basic category theory. Vol. 143. Cambridge University Press,
2014 (cit. on p. 114).
[LS88]
J. Lambek and P. J. Scott. Introduction to higher order categorical logic. Vol. 7.
Cambridge Studies in Advanced Mathematics. Reprint of the 1986 original.
Cambridge University Press, Cambridge, 1988, pp. x+293 (cit. on p. 257).
[Mac98]
Saunders Mac Lane. Categories for the working mathematician. 2nd ed. Gradu-
ate Texts in Mathematics 5. New York: Springer-Verlag, 1998 (cit. on pp. 114,
115, 145).
[May72]
J Peter May. The geometry of iterated loop spaces, volume 271 of Lecture Notes in
Mathematics. 1972 (cit. on p. 219).
[McL90]
Colin McLarty. “The uses and abuses of the history of topos theory”. In:
The British Journal for the Philosophy of Science 41.3 (1990), pp. 351–375 (cit. on
p. 256).
[McL92]
Colin McLarty. Elementary categories, elementary toposes. Clarendon Press,
1992 (cit. on p. 256).
[MM92]
Saunders MacLane and Ieke Moerdĳk. Sheaves in Geometry and Logic: A First
Introduction to Topos Theory. Springer, 1992 (cit. on p. 257).
[nLa18]
Contributors To nLab. Symmetric monoidal category. 2018. url: https://
ncatlab.org/nlab/revision/symmetric+monoidal+category/30 (cit. on
p. 139).
[NNH99]
Flemming Nielson, Hanne R. Nielson, and Chris Hankin. Principles of Pro-
gram Analysis. Secaucus, NJ, USA: Springer-Verlag New York, Inc., 1999 (cit.
on p. 37).

328
BIBLIOGRAPHY
[Pie91]
Benjamin C. Pierce. Basic Category Theory for Computer Scientists. MIT Press,
1991 (cit. on p. 114).
[PS95]
Frank Piessens and Eric Steegmans. “Categorical data speciﬁcations”. In:
Theory and Applications of Categories 1.8 (1995), pp. 156–173 (cit. on p. 114).
[Rie17]
Emily Riehl. Category theory in context. Courier Dover Publications, 2017
(cit. on p. 114).
[Ros90]
Kimmo I Rosenthal. Quantales and their applications. Vol. 234. Longman
Scientiﬁc and Technical, 1990 (cit. on p. 76).
[RS13]
Dylan Rupel and David I. Spivak. The operad of temporal wiring diagrams:
formalizing a graphical language for discrete-time processes. 2013. eprint: arXiv:
1307.6894 (cit. on p. 219).
[RW92]
Robert Rosebrugh and R. J. Wood. “Relational Databases and Indexed Cat-
egories”. In: Canadian Mathematical Society Conference Procedings. Interna-
tional Summer Category Theory Meeting. (June 23–30, 1991). Ed. by R. A. G.
Seely. Vol. 13. American Mathematical Society, 1992, pp. 391–407 (cit. on
p. 114).
[S+15]
Eswaran Subrahmanian, Christopher Lee, Helen Granger, et al. “Managing
and supporting product life cycle through engineering change manage-
ment for a complex product”. In: Research in Engineering Design 26.3 (2015),
pp. 189–217 (cit. on p. 118).
[Sch+17]
Patrick Schultz, David I. Spivak, Christina Vasilakopoulou, and Ryan Wis-
nesky. “Algebraic Databases”. In: Theory and Applications of Categories 32
(2017), Paper No. 16, 547–619 (cit. on p. 114).
[Sel10]
Peter Selinger. “A survey of graphical languages for monoidal categories”.
In: New structures for physics. Springer, 2010, pp. 289–355 (cit. on p. 146).
[Shu08]
Michael Shulman. “Framed bicategories and monoidal ﬁbrations”. In: The-
ory and Applications of Categories 20 (2008), Paper No. 18, 650–738 (cit. on
p. 145).
[Shu10]
Michael Shulman. Constructing symmetric monoidal bicategories. 2010. eprint:
arXiv:1004.0993 (cit. on p. 145).
[Sob]
Graphical Linear Algebra. url: https://graphicallinearalgebra.net/
(visited on 03/11/2018) (cit. on p. 179).
[Spi+16]
David I. Spivak, Magdalen R. C. Dobson, Sapna Kumari, and Lawrence
Wu. Pixel Arrays: A fast and elementary method for solving nonlinear systems.
2016. eprint: arXiv:1609.00061 (cit. on p. 219).
[Spi12]
David I. Spivak. “Functorial data migration”. In: Information and Computa-
tion 217 (2012), pp. 31–51 (cit. on p. 114).

BIBLIOGRAPHY
329
[Spi13]
David I. Spivak. The operad of wiring diagrams: formalizing a graphical language
for databases, recursion, and plug-and-play circuits. 2013. eprint: arXiv:1305.
0297 (cit. on p. 219).
[Spi14a]
David I Spivak. Category theory for the sciences. MIT Press, 2014 (cit. on
pp. 105, 114).
[Spi14b]
David I. Spivak. “Database queries and constraints via lifting problems”.
In: Mathematical Structures in Computer Science 24.6 (2014), e240602, 55. url:
http://dx.doi.org/10.1017/S0960129513000479 (cit. on p. 94).
[SS18]
Patrick Schultz and David I. Spivak. Temporal Type Theory: A topos-theoretic
approach to systems and behavior. Springer, Berkhäuser, To appear, 2018 (cit. on
p. 256).
[SSV18]
Alberto Speranzon, David I. Spivak, and Srivatsan Varadarajan. Abstraction,
Composition and Contracts: A Sheaf Theoretic Approach. 2018. eprint: arXiv:
1802.03080 (cit. on p. 255).
[SVS16]
David I. Spivak, Christina Vasilakopoulou, and Patrick Schultz. Dynamical
Systems and Sheaves. 2016. eprint: arXiv:1609.08086.
[SW15a]
Patrick Schultz and Ryan Wisnesky. Algebraic Data Integration. 2015. eprint:
arXiv:1503.03571 (cit. on p. 114).
[SW15b]
David I. Spivak and Ryan Wisnesky. “Relational Foundations for Functorial
Data Migration”. In: Proceedings of the 15th Symposium on Database Program-
ming Languages. DBPL. Pittsburgh, PA: ACM, 2015, pp. 21–28 (cit. on p. 114).
[TG96]
Chris Tuĳn and Marc Gyssens. “CGOOD, a categorical graph-oriented ob-
ject data model”. In: Theoretical Computer Science 160.1-2 (1996), pp. 217–239
(cit. on p. 114).
[Vig03]
Sebastiano Vigna. A Guided Tour in the Topos of Graphs. 2003. eprint: arXiv:
math/0306394 (cit. on p. 245).
[VSL15]
Dmitry Vagner, David I. Spivak, and Eugene Lerman. “Algebras of open
dynamical systems on the operad of wiring diagrams”. In: Theory and Ap-
plications of Categories 30 (2015), Paper No. 51, 1793–1822 (cit. on pp. 211,
219).
[Wal92]
R. F. C. Walters. Categories and Computer Science. Cambridge University
Press, 1992 (cit. on p. 114).
[Wik18]
Contributors To Wikipedia. Symmetric monoidal category — Wikipedia, The
Free Encyclopedia. [Online; accessed 22-February-2018]. 2018. url: https:
/ / en . wikipedia . org / wiki / Symmetric _ monoidal _ category (cit. on
p. 139).
[Wil07]
Jan C Willems. “The behavioral approach to open and interconnected sys-
tems”. In: IEEE Control Systems 27.6 (2007), pp. 46–99 (cit. on p. 179).

330
BIBLIOGRAPHY
[Wis+15]
Ryan Wisnesky, David I. Spivak, Patrick Schultz, and Eswaran Subrahma-
nian. Functorial Data Migration: From Theory to Practice. Report G2015-1701.
National Institute of Standards and Technology, 2015. arXiv: 1502.05947v2
(cit. on p. 114).
[Zan15]
Fabio Zanasi. “Interacting Hopf Algebras- the Theory of Linear Systems”.
Theses. Ecole normale supérieure de lyon - ENS LYON, Oct. 2015. url:
https://tel.archives-ouvertes.fr/tel-01218015 (cit. on p. 179).

Index
adjoint, see adjunction
adjoint functor theorem, 32, 73
adjunction, 35, 69, 99–107
examples of, 27, 28, 35, 86, 102, 104
from closure operator, 34
Galois connection as, 27
of preorders, 26–36
preservation of meets and joins, 31
relationship to companions andcon-
joints, 131
algebraic theory, 172
AND operation, 230, 245
applied category theory, 1–257
associativity, 82, 83, 125, 135
as coherence condition, 115
in enriched categories, 139
in product category, 110
in wiring diagrams, 46
of composition in an operad, 213
of function composition, 87
of monoid operation, wiring dia-
gram for, 198
of monoidal product, 42
of morphism composition, 81
of profunctor composition, 129
of quantale matrix multiplication,
74
property vs. structure, 136
weak, 130
behavior, 221–225
contract, 255
properties of, 224
topos for, 252
behavioral approach, 174
Beyoncé, 51
bicategory, 130
binary relation, see relation, binary, 150
booleans, 4
alternative monoidal structure, 53
and feasibility, 119
as base of enrichment for preorders,
58, 236
as monoidal closed, 70, 231
as preorder, 13, 22
as quantale, 72
as rig, 160
as set, 6, 7
as subobject classiﬁer, 229, 244
meets and joins in, 25
usual monoidal structure, 52
cardinality, 19
and isomorphisms, 88
categoriﬁcation, 129, 132–134
category, 81–89
as database schema, 89
codiscrete, 104
compact closed, see compact closed
category
composition in, 81
discrete, 104
331

332
INDEX
examples of, 87
ﬁnitely presented, see presentation
of
free, 82, 104, 154
having ﬁnite colimits, 192, 206
hypergraph structure on, 201
identity in, 81
indexing, 95, 111
monoidal structure on, 136
morphism in, 81
object in, 81
of algebras for an operad, 218
of bĳections, 150
of categories, 93
of cocones, 191
of cones, 110
of cospans, 195
of database instances, 232
of ﬁnite sets, 87, 150, 205
of functors, 96
of graphs, 97
of instances on a database schema,
97
of operads, 218
of preorders, 21
of presheaves, 233
of sets, 87, 224
of sheaves, 223, 237
opposite of, 88
preorder reﬂection of, 86
presentation of, 84, 93, 158
category of categories, see category, of
categories
category theory
as central hub of mathematics, iii
books on, iv
ceiling function, 27
change of base, see enrichment, change
of base
chemistry, 39, 70, 219
catalysis, 49
monoidal preorder of, 48
closed category
cartesian, 76, 225, 227
compact, see compact closed cate-
gory
compact implies monoidal, 142
hom object in, see hom object
monoidal, see monoidal closed cat-
egory, 76
closure operator, 33–35, 250
co-design, see also feasibility, 117–146
diagram, 118, 124
problem, 119
cocone, 114
codomain, see morphism, codomain
coequalizer, 194
coherence, v, 114, 204
as bookkeeping, 136
conditions, 136
Mac Lane’s theorem, 137
colimit, 113, 182–194, 224, 225, 231
and interconnection, 194
coequalizer as, 194
coproduct as, 186
ﬁnite, 191–194
formula for ﬁnite colimits in Set,
193
initial object as, 184
presheavesformcolimitcompletion,
233
pushout as, 188
collage, 122, 131–132
collection, 81
commutative diagram, 95
commutative square, 84, 91, 95
comonoid, 198
compact closed category, 139–145, 150,
178
duals in, 141
hypergraph category as, 203
companion profunctor, 130

INDEX
333
comparable, 15
completeness
of proof system, 170
composition
in a category, see category, compo-
sition in
in enriched categories, see enriched
categories, composition in
compositionality, 1, 222, 257
cone, 111
conjoint profunctor, 130
connected, 10
connectedness, 3
connection
as colimit, 183
context free grammar, 214
continuous function, 234
control theory, 149, 178
cooking, iv
coproduct, 186–188
corelation, 142, 150
corelations
hypergraph category of, see hyper-
graph category, of corelations
cospan, 194–197
apex of, 194
decorated, 206
foot of, 194
cospans
as theory of Frobenius monoids, 200
category of, 196
composition of, 195
decorated, 203
hypergraph category of, see hyper-
graph category, of cospans
Cost, 54, 69, 71
counit, 141
cover, 234, 237
empty, 237
cowlick
inevitability of, 242
cross section, see section
currying, 103, 227, 249
cyber-physical system, 147
dagger, 21, 66
data migration, 99, 104
adjoints, 102
left pushforward, 104
pullback, 100, 102
right pushforward, 104
database, 77–81, 224
as interlocking tables, 77
communication between, 79
constraints, 79, 94
data migration, 80
foreign key, 78
ID columns of, 77
instance, 93–94, 97
instance homomorphism, 97
instances form a topos, 232
query, 106, 112
schema, see database schema, 158
database schema, 78, 93
as category presentation, 79, 85
free, 78
mapping between, 80
design, 117
diagram
as functor, 95
commutative, 95
diﬀerential equation, 162
discrete dynamical system, 100
induced graph of, 105
disjoint union, see union, disjoint
divides relation, 8, 25
as preorder, 15
domain, see morphism, domain
dual, see also properties, dual
as opposite, 72
category as opposite, in Prof, 145
double, 142
object, 141

334
INDEX
of lax monoidal monotone, 56
self, 143, 178, 203
dual notions
colimits and limits as, 113
subobjects and quotients, 193
dynamical system, 257
continuous, 211
discrete, 101, see discrete dynamical
system
hybrid, 254
eﬀort
as metric, 60
electric circuit, 181
electrical circuit, 182, 194, 204–211
closed, 211
via cospans, 209
enriched categories, 139
enriched category
composition in, 139
general deﬁnition, 138
identity in, 139
metric space as, 61
preorders as, 57
vs category, 87
enriched functor, 65
enrichment, 57–69
base of, 57
change of base, 64
epi-mono factorization, 28, 225, 227, 243
and existential quantiﬁcation, 250
epimorphism, 225, 226
surjection as, 227
equivalence of categories, 66, 97
equivalence relation, 9, 193, 194
and partition, 8–10, 16
as corelation, 142
as binary relation, 9
as symmetric preorder, 13
generated by a preorder, 13, 55
feasibility relation, 119–125
as Bool-profunctor, 121, 127
compact closed category of, 143–
145
feedback, 174
ﬁber, see preimage
ﬂip-ﬂop, 181
ﬂoor function, 27
foreign key, see database, foreign key
free
category, 82, 89, 154
monoid, 155
preorder, 153
prop, 155
schema, 78
Frobenius
algebra, 172
law, 198
monoid, 198
structure, 197–201
function, 2, 10
as database instance, 90
as relation, 10
bĳective, 10, 150, 156
composite, 12
identity, 11
injective, 10, 226
structure preserving, 2
surjective, 10
functor, 91–93
data migration, see data migration
diagram as, 95
enriched, see enriched functor
operad, 217
presheaf as, 232
prop, 151
Set-valued, 98, 99, 102, 112, 217
functorial query language, FQL, 79
functorial semantics, 168
future
as not yet arrived, 183
Galois connection, 26–36

INDEX
335
generative eﬀect, 2, 4, 6, 26, 37, 242
generators and relations, see presenta-
tion
gluing, 237
graph, 14
arrow, 14
as Set-valued functor, 97
complete, 104
discrete, 104
free category on, 82
homomorphism, 98
paths in, 14
vertex, 14
weighted, 62
graphs
database schema for, 97–102
homomorphism of, 97
topos of, 233
graphs
homomorphism of, 99
greatest common divisor, 25
greatest lower bound, 23
group, 84, 88
commutator subgroup, 104
free, 104
Hasse diagram, 5, 14, 16–18, 35, 54
database schema as, 78
for metric spaces, 62
for preorders, 5
for profunctors, 132
weighted graph as, 62
Hausdorﬀdistance, 60, 73
hom object, 57, 58, 64, 128, 138, 139
matrix of, 64
hom-set, 81
hypergraph category, 197–203
of corelations, 202
of cospans, 202
of linear relations, 203
hypergraph prop
operad for, 216
theory of, 218
icon, 44, 140, 157, 160–163, 183, 197
copy, 51
crossing wires, 46
cup and cap, 140
discard, 50
spider, 184, 199
identity
function, 11, see also function, iden-
tity
functor, 93
in enriched categories, see enriched
category, identity in
in wiring diagrams, 135
matrix, 74, 166
morphism, 81, 82
natural transformation, 96
port graph, 153
profunctor, see also unit
iﬀ, 14
IMPLIES operation, 231, 245
induction, 166, 191
inﬁmum, 25
inﬁx notation, 8, 9, 13, 42, 230
informatics
discarding in, 52
duplication in, 52
monoidal preorder of, 51
initial object, 184–186
as colimit, 192
empty set as, 185
interaction, 221
interconnection, 182
as variable sharing, 147
network-type, 183
via Frobenius structures, 197
interface, 182, 222
intersection, 8, 54, 224
as meet, 25
interval domain, IR, 252–255
involution, 280

336
INDEX
isomorphism, 88–89
adjunction as relaxed version of, 27
as stable under pullback, 226
as stable under pushout, 189
bĳection as, 88
of preorders, 21
join, 4, 23–25, 73
as coproduct, 186
joins
preservation of, 5, 31
required in a quantale, 71
Kan extension, 115
language, 223
internal, 223, 251
Lawvere metric space, 59–65
as Cost-category, 59
of regions, 60
least common multiple, 25
least upper bound, 23
level shift, 18, 35, see also primordial
ooze
lifting problems, 94
limit, 107–113, 224, 225, 231
formula for ﬁnite limits in Set, 112
product as, 108
pullback as, 112
terminal object as, 107
linear relation, 177
linear relations
hypergraph category of, see hyper-
graph category, of linear rela-
tions
logic, 34, 224, 230–232
implication in, 6
in a topos, 243
manufacturing, 39
discard operation in, 50
monoidal preorder of, 49
map
monotone, see also monotone map,
18–22
order-preserving, see map, mono-
tone
structure preserving, 1, 18
mapping object
see hom object, 57
matching family, 237
matrices
multiplication of, 74
rig of, 160
matrix, 63, 73, 123
associated to a signal ﬂow graph,
165–168
feasibility, 122
identity, 74
of distances, 62
meet, 23–25, 109
meets
preservation of, 26, 31
metric space, 66
as Cost-category, 61
as topological space, 235
discrete, 104
extended, 59
ordinary, 59
presentation of, 62
mirror image, see transpose
modal operator, 250
modes of transport, 63
monoid, 42, 83, see also monoidal cate-
gory, monoid object in
as one-object category, 83
free, 104, 155
group as, 88
monoidal category, iv, 136–138
monoid object in, 172–173
monoidal closed category, 69
booleans as, 70
Cost, see Cost
monoidal functor, 173, 204, 206, 209, 213

INDEX
337
monoidal monotone as, 56
monoidal monotone, 55–57
monoidal preorder, 41–57
opposite of, 55
monoidal product, 41
as stacking, 197, 211
monoidal structure, 41
weak, 42
monoidal unit, 41
drawn as nothing, 45
monomorphism, 225, 226
as stable under pullback, 226
injection as, 226
monotone map, see also map, monotone
as Bool-functor, 66
as functor, 92
morphism, v
codomain, 81
domain, 81
identity, 81
in free category, 82
inequality as mere existence of, 86
invertible, 88
natural numbers, 15, 42, 53
as free category, 83
as free monoid, 155
as rig, 159
natural numbers as
as set, 7
natural transformation, 95–97
as presheaf morphism, 233
between monotone maps, 97
component of, 95, 96
graph homomorphism as, 98
identity, 96
naturality condition, 95
navigator, 72, 126
network
diagram, 181
language, 201
NOT operation, 231, 245
notation, see also icon
for classiﬁed subobjects, 229
for common sets, 7
for monoidal structures, 42
inﬁx, see inﬁx
set builder, 7
obvious
conventionalmathematicalmeaning
of, 150
ooze
primordial, see primordial ooze
open set, 234
open system, 182
operad, 184, 211–218
algebra of , 217
as custom compositionality, 184
from monoidal category, 214
of cospans, 215
of sets, 214
of wiring diagrams, 211
operation in, 213
operation, see operad
logical, 224
opposite
V-category, 66
category, see category, opposite
preorder, 18
opposite category
and presheaves, 232
as dual, 145
OR operation, 230, 245
order, see also preorder
preservation of, 5
total, 16
ordinals
as categories, 83
partial order, 13, see also preorder, skele-
tal, 127
partition, 9, 20, 28–30
as surjection, 11

338
INDEX
associated equivalence relation of,
10
from preorder, 16
label irrelevance of, 9
part of, 9
pullback of, 29
pushforward of, 29
pie
lemon meringue, 40, 47
poker, 43
port graph, 151–153, 155
acyclicity condition, 151
as morphism, 152, 156
poset, see partial order
power set, 16, 17, 19, 54, see also pre-
order, of subobjects, 204
predicate, 224, 228, 247, 256
prediction vs. possibility, 221
preimage, 10, 11, 32, 120, 234, 238
preorder, 12–18
as Bool-category, 57, 58
as category, 85
codiscrete, 13, 104, 303
Cost, see Cost
dagger, see dagger
discrete, 13, 20, 104, 303
free, 104
free on a relation, 153
monoidal, see monoidal preorder
of open sets, 236
of partitions, 17
of subobjects, 247
partial order as, 13
presentation of, 14
skeletal, 13, 21
symmetric monoidal, see monoidal
preorder, 137
preorder relation
as binary relation, 12
presentation
of linear algebra, 168
of metric space, 62
of monoid, 85
of preorder, 14
of prop, 158
presheaf, 232–234
as database instance, 233
restriction maps, 232
sections, 232
presheaves
morphism of, 233
topos of, 232
primordial ooze, see also ooze, primor-
dial, 93, 97, 134, 173
product
as limit, 111
in a category, 108
meet as, 109
monoidal, 136
of V-categories, 67
of categories, 110, 144
of preorders, 17
of sets, 8, 109
profunctor, 119–132
Cost, 122, see also Cost
as bridges, 122, 131
Bool, 119
collage of, see collage
enriched, 121, see profunctor
unit, 128, 130
profunctors
category of, 125–130
compact closed category of, 139
composition of, 125, 127
program semantics, 34, 37
prop, 149–179
FinSet, 150
expression in, 157
free, 155
hypergraph, 202
of R-relations, 175
of matrices, 164, 170

INDEX
339
posetal, 151
presentation of, 158
signature of, 155
properties
dual, 33
proposition, 54, see also logic
pullback, 225
along a map, 22, 32, 101
as limit, 112
monomorphism in terms of, 226
of isomorphism, 226
pullbacks
pasting of, 225
pushout, 28, 188–191
along isomorphism, 189
as colimit, 188
epimorphism in terms of, 226
in cospan composition, 195
quantale, 68, 71–76, 121, 123, 160
commutative, 71
Cost as, see Cost
matrix multiplication in, 73
of open sets, 236
quantales
as self-enriched, 71
quantiﬁcation, 248
quotient, 10, 104, 157, 193
as data migration, 107
real numbers, 16, 42, 45, 172
as metric space, 61
as preorder, 23
as set, 7
topology on, 234
recipes, 40
reﬂexivity, 9, 12
as identity in a preorder, 85
relation, 8, 151
binary, 8, 35
divides, see divides relation
equivalence, seeequivalence relation
free preorder on, 35, 153
function as, 10
linear, see linear relation
preorder, see preorder
subset, 54
relations
composition of, 175
resource, 117
theory, 39–52
restriction map, see presheaf, restriction
map
retraction, 89
reverse icon, see transpose
rig, 159–160
matrices as, 160
matrices over, 164
vs. ring, 160
ring
free, 104
safety proof, 255
schema, see dtabase schema89
semantics, 223, 251
sound, 251
semiring, see rig
set, 7–8
nth ordinal as, 7
as sheaf on one-point space, 242
booleans as, 7
empty, 7, 11
integers as, 7
natural numbers as, 7
one element, 7
real numbers as, 7
sets
category of, 87
sheaf, 223, 232–242
condition, 237
constant, 253
of local functions, 254
of sections of a function, 237, 240
of vector ﬁelds, 241

340
INDEX
on IR as semantics of behavior, 253
sheaves
morphism of, 237
topos of, 242
Sierpinski space, 235, 242
signal ﬂow graph, 148–179
and linear algebra, 176
as morphism, 162
general, 175
semantics of, 163
simpliﬁed, 160
site, 232
database schema as, 232
topological space as, 234
skeleton, 13, 66
snake equations, 141
soundness
of proof system, 170
spider, 183, 199
as iconography, 184
spiderable wire
Frobenius structure as, 199
stacking, see monoidal product
subobject classiﬁer, 225, 228–230, 243–
251
and logic, 230
as superdense nugget from outer
space, 228
for behavior types, 254
in Set, 229
subset, 7, see also power set
summaries
limits and colimits as, 106
supremum, 25
symmetry, 9, 13, 42, 149
and dagger, 21
as required for enriched products,
67
in wiring diagrams, 46
lack of for eﬀort, 60
of monoid operation, wiring dia-
gram for, 198
of monoidal product, 42
system
component, 222
property, 223
tangent bundle, 241
vector ﬁelds as sections of, 241
terminal object, 108
as limit, 107
limit as, 111
universal property of, 108
theory
of hypergraph props, 218
of monoids, 173
top element, see terminal object
topological space, 234–240, 252
topology
codiscrete, 104
discrete, 104, 235
subspace, 236
topos, 223, 242–257
as category of sheaves, 237, 242
database instances as, 231
of sets, 224
properties of, 225–230
total order, 15, 28
transitive closure, 29
transitivity, 9, 12
as composition in a preorder, 85
transpose, 174
tree of life, 19
triangle inequality, 60
trivial path, 82, 91, 151
type theory, 251
union, 4, 8, 64
and data migration, 105
as join, 25
disjoint, 8, 107, 133, 186

INDEX
341
unique up to unique isomorphism, 24,
108
unit, 141
monoidal, 41, see also monoidal unit
profunctor, 128
unitality, 81, 83, 125, 135
as coherence condition, 115
in enriched categories, 139
of identity functions, 87
of monoid operation, wiring dia-
gram for, 198
of monoidal product, 42
weak, 130
universal property, 23, 108, 115, 153–
159, 184
upper set, 17, 22
V-category, see enrichment
V-profunctor, see profunctor, enriched
vector, 164, 165, 173
tangent, 241
vector ﬁeld, 241
vector space, 212
free, 104
weighted graph, see graph, weighted
wiring diagram, iv, 40, 43–48, 134–136,
140
as graphical proof, 47
for categories, 134
for hypergraph categories, 200
for monoidal categories, 136
for monoidal preorders, 44
icon of, 44, 46, 51
styles of, 44, 146, 183
Yoneda lemma
for preorders, 20

