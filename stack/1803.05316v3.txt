Seven Sketches in Compositionality:
An Invitation to Applied Category Theory
?
Brendan Fong
David I. Spivak
(Last updated: October 16, 2018)
arXiv:1803.05316v3  [math.CT]  12 Oct 2018


Preface
Category theory is becoming a central hub for all of pure mathematics. It is unmatched
in its ability to organize and layer abstractions, to Ô¨Ånd commonalities between struc-
tures of all sorts, and to facilitate communication between diÔ¨Äerent mathematical
communities.
But it has also been branching out into science, informatics, and industry. We believe
that it has the potential to be a major cohesive force in the world, building rigorous
bridges between disparate worlds, both theoretical and practical. The motto at MIT is
mens et manus, Latin for mind and hand. We believe that category theory‚Äîand pure
math in general‚Äîhas stayed in the realm of mind for too long; it is ripe to be brought
to hand.
Purpose and audience
The purpose of this book is to oÔ¨Äer a self-contained tour of applied category theory.
It is an invitation to discover advanced topics in category theory through concrete
real-world examples.
Rather than try to give a comprehensive treatment of these
topics‚Äîwhich include adjoint functors, enriched categories, proarrow equipments,
toposes, and much more‚Äîwe merely provide a taste of each. We want to give readers
some insight into how it feels to work with these structures as well as some ideas about
how they might show up in practice.
The audience for this book is quite diverse: anyone who Ô¨Ånds the above description
intriguing. This could include a motivated high school student who hasn‚Äôt seen calculus
yet but has loved reading a weird book on mathematical logic they found at the
library. Or a machine-learning researcher who wants to understand what vector spaces,
design theory, and dynamical systems could possibly have in common. Or a pure
mathematician who wants to imagine what sorts of applications their work might
have. Or a recently-retired programmer who‚Äôs always had an eerie feeling that category
theory is what they‚Äôve been looking for to tie it all together, but who‚Äôs found the usual
books on the subject impenetrable.
iii

iv
For example, we Ô¨Ånd it something of a travesty that in 2018 there is almost no
introductory material available on monoidal categories. Even beautiful modern intro-
ductions to category theory, e.g. by Riehl or Leinster, do not include anything on this
rather central topic. The only exceptions we can think of are [CK17, Chapter 3] and
[CP10], each of which has a very user-friendly introduction to monoidal categories;
however, readers who are not drawn to physics may not think to look there.
The basic idea of monoidal categories is certainly not too abstract; modern human
intuition seems to include a pre-theoretical understanding of monoidal categories that
is just waiting to be formalized. Is there anyone who wouldn‚Äôt correctly understand
the basic idea being communicated in the following diagram?
make
lemon
Ô¨Ålling
make
meringue
separate
egg
Ô¨Åll crust
add
meringue
prepare lemon meringue pie
prepared crust
lemon
butter
sugar
egg
sugar
yolk
white
lemon
Ô¨Ålling
unbaked
lemon pie
meringue
unbaked
pie
Many applied category theory topicsseemtotakemonoidalcategoriesastheirjumping-
oÔ¨Äpoint. So one aim of this book is to provide a reference‚Äîeven if unconventional‚Äîfor
this important topic.
We hope this book inspires both new visions and new questions. We intend it to be
self-contained in the sense that it is approachable with minimal prerequisites, but not
in the sense that the complete story is told here. On the contrary, we hope that readers
use this as an invitation to further reading, to orient themselves in what is becoming a
large literature, and to discover new applications for themselves.
This book is, unashamedly, our take on the subject. While the abstract structures
we explore are important to any category theorist, the speciÔ¨Åc topics have simply
been chosen to our personal taste. Our examples are ones that we Ô¨Ånd simple but
powerful, concrete but representative, entertaining but in a way that feels important
and expansive at the same time. We hope our readers will enjoy themselves and learn
a lot in the process.

v
How to read this book
The basic idea of category theory‚Äîwhich threads through every chapter‚Äîis that if
one pays careful attention to structures and coherence, the resulting systems will
be extremely reliable and interoperable.
For example, a category involves several
structures: a collection of objects, a collection of morphisms relating objects, and a
formula for combining any chain of morphisms into a morphism. But these structures
need to cohere or work together in a simple commonsense way: a chain of chains is itself
a long chain, so combining a chain of chains should be the same as combining the long
chain. That‚Äôs it!
We will see structures and coherence come up in pretty much every deÔ¨Ånition we
give: ‚Äúhere are some things and here are how they Ô¨Åt together.‚Äù We ask the reader to
be on the lookout for structures and coherence as they read the book, and to realize
that as we layer abstraction upon abstraction, it is the coherence that makes all the parts
work together harmoniously in concert.
Each chapter in this book is motivated by a real-world topic, such as electrical cir-
cuits, control theory, cascade failures, information integration, and hybrid systems.
These motivations lead us into and through various sorts of category-theoretic con-
cepts. We generally have one motivating idea and one category-theoretic purpose per
chapter, and this forms the title of the chapter, e.g. Chapter 4 is ‚ÄúCollaborative design:
profunctors, categoriÔ¨Åcation, and monoidal categories.‚Äù
In many math books, the diÔ¨Éculty is roughly a monotonically-increasing function
of the page number. In this book, this occurs in each chapter, but not so much in the
book as a whole. The chapters start out fairly easy and progress in diÔ¨Éculty.
Page number
DiÔ¨Éculty
Most math books
DiÔ¨Éculty
Ch. 1
Ch. 2
Ch. 3
Ch. 4
Ch. 5
Ch. 6
Ch. 7
End
This book
The upshot is that if you Ô¨Ånd the end of a chapter very diÔ¨Écult, hope is certainly not
lost: you can start on the next one and make good progress. This format lends itself
to giving you a Ô¨Årst taste now, but also leaving open the opportunity for you to come
back to the book at a later date and get more deeply into it. But by all means, if you
have the gumption to work through each chapter to its end, we very much encourage
that!
We include about 240 exercises throughout the text, with solutions in Appendix A.
Usually these exercises are fairly straightforward; the only thing they demand is that
the reader changes their mental state from passive to active, rereads the previous

vi
paragraphs with intent, and puts the pieces together. A reader becomes a student when
they work the exercises; until then they are more of a tourist, riding on a bus and
listening oÔ¨Äand on to the tour guide. Hey, there‚Äôs nothing wrong with that, but we do
encourage you to get oÔ¨Äthe bus and make direct contact with the native population
and local architecture as often as you can.
Acknowledgments
Thanks to Jared Briskman, James Brock, Ronnie Brown, Thrina Burana, David Chudz-
icki, Jonathan Castello, Margo Crawford, Fred Eisele, David Ellerman, Cam Fulton,
Bruno Gavranoviƒá, Sebastian Galkin, John Garvin, Peter Gates, Juan Manuel Gimeno,
Alfredo G√≥mez, Leo Gorodinski, Jason Grossman, Jason Hooper, Yuxi Liu, Jes√∫s L√≥pez,
MTM, Nicol√≤ Martini, Martin MacKerel, Pete Morcos, Nelson Niu, James Nolan, Dan
Oneata, Paolo Perrone, Thomas Read, Rif A. Saurous, Dan Schmidt, Samantha Seaman,
Marcello Seri, Robert Smart, Valter Sorana, Adam Theriault-Shay, Emmy Trewartha,
Sergey Tselovalnikov, Andrew Turner, Joan Vazquez, Daniel Wang, Jerry Wedekind for
helpful comments and conversations.
We also thank our sponsors at the AFOSR; this work was supported by grants
FA9550‚Äì14‚Äì1‚Äì0031 and FA9550‚Äì17‚Äì1‚Äì0058.
Finally, we extend a very special thanks to John Baez for running an online course
on this material and generating tons of great feedback.
Personal note
Our motivations to apply categorytheoryoutsideofmathare, perhapsnaively, grounded
in the hope it can help bring humanity together to solve our big problems. But category
theory is a tool for thinking, and like any tool it can be used for purposes we align with
and those we don‚Äôt.
In this personal note, we ask that readers try to use what they learn in this book to
do something they would call ‚Äúgood,‚Äù in terms of contributing to the society they‚Äôd
want to live in. For example, if you‚Äôre planning to study this material with others,
consider speciÔ¨Åcally inviting someone from an under-represented minority‚Äîa group
that is more highly represented in society than in upper-level math classes‚Äîto your
study group. As another example, perhaps you can use the material in this book to
design software that helps people relate to and align with each other.
What‚Äôs the
mathematics of a well-functioning society?
The way we use our tools aÔ¨Äects all our lives. Our society has seen the results‚Äîboth
the wonders and the waste‚Äîresulting from rampant selÔ¨Åshness. We would be honored
if readers found ways to use category theory as part of an eÔ¨Äort to connect people, to
create common ground, to explore the cross-cutting categories in which life, society,

vii
and environment can be represented, and to end the ignorance entailed by limiting
ourselves to a singular ontological perspective on anything.
If you do something of the sort, please let us and the community know about it.
Brendan Fong and David I. Spivak
Cambridge MA, October 2018

Contents
1
Generative eÔ¨Äects: Orders and adjunctions
1
1.1
More than the sum of their parts
. . . . . . . . . . . . . . . . . . . . . . .
1
1.1.1
A Ô¨Årst look at generative eÔ¨Äects . . . . . . . . . . . . . . . . . . . .
2
1.1.2
Ordering systems . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2
What is order? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.2.1
Review of sets, relations, and functions . . . . . . . . . . . . . . .
7
1.2.2
Preorders
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.2.3
Monotone maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.3
Meets and joins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
1.3.1
DeÔ¨Ånition and basic examples
. . . . . . . . . . . . . . . . . . . .
23
1.3.2
Back to observations and generative eÔ¨Äects . . . . . . . . . . . . .
26
1.4
Galois connections
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
1.4.1
DeÔ¨Ånition and examples of Galois connections . . . . . . . . . . .
27
1.4.2
Back to partitions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
1.4.3
Basic theory of Galois connections . . . . . . . . . . . . . . . . . .
30
1.4.4
Closure operators . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
1.4.5
Level shifting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
1.5
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . .
36
2
Resources: monoidal preorders and enrichment
39
2.1
Getting from a to b
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
2.2
Symmetric monoidal preorders . . . . . . . . . . . . . . . . . . . . . . . .
41
2.2.1
DeÔ¨Ånition and Ô¨Årst examples . . . . . . . . . . . . . . . . . . . . .
41
2.2.2
Introducing wiring diagrams . . . . . . . . . . . . . . . . . . . . .
43
2.2.3
Applied examples
. . . . . . . . . . . . . . . . . . . . . . . . . . .
48
2.2.4
Abstract examples
. . . . . . . . . . . . . . . . . . . . . . . . . . .
52
2.2.5
Monoidal monotone maps . . . . . . . . . . . . . . . . . . . . . . .
55
2.3
Enrichment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
2.3.1
V-categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
2.3.2
Preorders as Bool-categories
. . . . . . . . . . . . . . . . . . . . .
58
viii

CONTENTS
ix
2.3.3
Lawvere metric spaces . . . . . . . . . . . . . . . . . . . . . . . . .
59
2.3.4
V-variations on preorders and metric spaces . . . . . . . . . . . .
63
2.4
Constructions on V-categories . . . . . . . . . . . . . . . . . . . . . . . . .
64
2.4.1
Changing the base of enrichment . . . . . . . . . . . . . . . . . . .
64
2.4.2
Enriched functors . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
2.4.3
Product V-categories . . . . . . . . . . . . . . . . . . . . . . . . . .
66
2.5
Computing presented V-categories with matrix mult. . . . . . . . . . . .
68
2.5.1
Monoidal closed preorders
. . . . . . . . . . . . . . . . . . . . . .
69
2.5.2
Quantales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
2.5.3
Matrix multiplication in a quantale . . . . . . . . . . . . . . . . . .
73
2.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . .
75
3
Databases: Categories, functors, and (co)limits
77
3.1
What is a database? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
3.2
Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
3.2.1
Free categories
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
3.2.2
Presenting categories via path equations
. . . . . . . . . . . . . .
84
3.2.3
Preorders and free categories: two ends of a spectrum
. . . . . .
85
3.2.4
Important categories in mathematics . . . . . . . . . . . . . . . . .
86
3.2.5
Isomorphisms in a category . . . . . . . . . . . . . . . . . . . . . .
88
3.3
Functors, natural transformations, and databases . . . . . . . . . . . . . .
89
3.3.1
Sets and functions as databases . . . . . . . . . . . . . . . . . . . .
89
3.3.2
Functors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
3.3.3
Database instances as Set-valued functors . . . . . . . . . . . . . .
93
3.3.4
Natural transformations . . . . . . . . . . . . . . . . . . . . . . . .
95
3.3.5
The category of instances on a schema . . . . . . . . . . . . . . . .
97
3.4
Adjunctions and data migration . . . . . . . . . . . . . . . . . . . . . . . .
99
3.4.1
Pulling back data along a functor . . . . . . . . . . . . . . . . . . . 100
3.4.2
Adjunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
3.4.3
Left and right pushforward functors, Œ£ and Œ† . . . . . . . . . . . 104
3.4.4
Single set summaries of databases . . . . . . . . . . . . . . . . . . 106
3.5
Bonus: An introduction to limits and colimits . . . . . . . . . . . . . . . . 107
3.5.1
Terminal objects and products
. . . . . . . . . . . . . . . . . . . . 107
3.5.2
Limits
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
3.5.3
Finite limits in Set
. . . . . . . . . . . . . . . . . . . . . . . . . . . 111
3.5.4
A brief note on colimits
. . . . . . . . . . . . . . . . . . . . . . . . 113
3.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 114
4
Co-design: profunctors and monoidal categories
117
4.1
Can we build it? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
4.2
Enriched profunctors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
4.2.1
Feasibility relationships as Bool-profunctors . . . . . . . . . . . . 119

x
CONTENTS
4.2.2
V-profunctors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.2.3
Back to co-design diagrams . . . . . . . . . . . . . . . . . . . . . . 124
4.3
Categories of profunctors
. . . . . . . . . . . . . . . . . . . . . . . . . . . 125
4.3.1
Composing profunctors . . . . . . . . . . . . . . . . . . . . . . . . 125
4.3.2
The categories V-Prof and Feas . . . . . . . . . . . . . . . . . . . . 127
4.3.3
Fun profunctor facts: companions, conjoints, collages . . . . . . . 130
4.4
CategoriÔ¨Åcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
4.4.1
The basic idea of categoriÔ¨Åcation . . . . . . . . . . . . . . . . . . . 133
4.4.2
A reÔ¨Çection on wiring diagrams
. . . . . . . . . . . . . . . . . . . 134
4.4.3
Monoidal categories . . . . . . . . . . . . . . . . . . . . . . . . . . 136
4.4.4
Categories enriched in a symmetric monoidal category . . . . . . 138
4.5
Profunctors form a compact closed category . . . . . . . . . . . . . . . . . 139
4.5.1
Compact closed categories . . . . . . . . . . . . . . . . . . . . . . . 141
4.5.2
Feas as a compact closed category . . . . . . . . . . . . . . . . . . 143
4.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 145
5
Signal Ô¨Çow graphs: Props, presentations, & proofs
147
5.1
Comparing systems as interacting signal processors . . . . . . . . . . . . 147
5.2
Props and presentations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
5.2.1
Props: deÔ¨Ånition and Ô¨Årst examples . . . . . . . . . . . . . . . . . 149
5.2.2
The prop of port graphs . . . . . . . . . . . . . . . . . . . . . . . . 151
5.2.3
Free constructions and universal properties . . . . . . . . . . . . . 153
5.2.4
The free prop on a signature
. . . . . . . . . . . . . . . . . . . . . 155
5.2.5
Props via presentations
. . . . . . . . . . . . . . . . . . . . . . . . 158
5.3
SimpliÔ¨Åed signal Ô¨Çow graphs . . . . . . . . . . . . . . . . . . . . . . . . . 159
5.3.1
Rigs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
5.3.2
The iconography of signal Ô¨Çow graphs
. . . . . . . . . . . . . . . 160
5.3.3
The prop of matrices over a rig . . . . . . . . . . . . . . . . . . . . 164
5.3.4
Turning signal Ô¨Çow graphs into matrices
. . . . . . . . . . . . . . 165
5.3.5
The idea of functorial semantics
. . . . . . . . . . . . . . . . . . . 168
5.4
Graphical linear algebra
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
5.4.1
A presentation of Mat(R)
. . . . . . . . . . . . . . . . . . . . . . . 168
5.4.2
Aside: monoid objects in a monoidal category . . . . . . . . . . . 172
5.4.3
Signal Ô¨Çow graphs: feedback and more . . . . . . . . . . . . . . . 174
5.5
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 178
6
Circuits: hypergraph categories and operads
181
6.1
The ubiquity of network languages . . . . . . . . . . . . . . . . . . . . . . 181
6.2
Colimits and connection . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
6.2.1
Initial objects
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
6.2.2
Coproducts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
6.2.3
Pushouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188

CONTENTS
xi
6.2.4
Finite colimits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
6.2.5
Cospans . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
6.3
Hypergraph categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
6.3.1
Frobenius monoids . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
6.3.2
Wiring diagrams for hypergraph categories . . . . . . . . . . . . . 200
6.3.3
DeÔ¨Ånition of hypergraph category . . . . . . . . . . . . . . . . . . 201
6.4
Decorated cospans
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
6.4.1
Symmetric monoidal functors . . . . . . . . . . . . . . . . . . . . . 204
6.4.2
Decorated cospans . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
6.4.3
Electric circuits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
6.5
Operads and their algebras
. . . . . . . . . . . . . . . . . . . . . . . . . . 211
6.5.1
Operads design wiring diagrams . . . . . . . . . . . . . . . . . . . 211
6.5.2
Operads from symmetric monoidal categories . . . . . . . . . . . 214
6.5.3
The operad for hypergraph props
. . . . . . . . . . . . . . . . . . 216
6.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 218
7
Logic of behavior: Sheaves, toposes, languages
221
7.1
How can we prove our machine is safe? . . . . . . . . . . . . . . . . . . . 221
7.2
The category Set as an exemplar topos . . . . . . . . . . . . . . . . . . . . 224
7.2.1
Set-like properties enjoyed by any topos . . . . . . . . . . . . . . . 225
7.2.2
The subobject classiÔ¨Åer . . . . . . . . . . . . . . . . . . . . . . . . . 228
7.2.3
Logic in the topos Set
. . . . . . . . . . . . . . . . . . . . . . . . . 230
7.3
Sheaves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
7.3.1
Presheaves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
7.3.2
Topological spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
7.3.3
Sheaves on topological spaces . . . . . . . . . . . . . . . . . . . . . 236
7.4
Toposes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
7.4.1
The subobject classiÔ¨Åer ‚Ñ¶in a sheaf topos . . . . . . . . . . . . . . 243
7.4.2
Logic in a sheaf topos
. . . . . . . . . . . . . . . . . . . . . . . . . 245
7.4.3
Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
7.4.4
QuantiÔ¨Åcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
7.4.5
Modalities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
7.4.6
Type theories and semantics . . . . . . . . . . . . . . . . . . . . . . 251
7.5
A topos of behavior types
. . . . . . . . . . . . . . . . . . . . . . . . . . . 252
7.5.1
The interval domain . . . . . . . . . . . . . . . . . . . . . . . . . . 252
7.5.2
Sheaves on IR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
7.5.3
Safety proofs in temporal logic . . . . . . . . . . . . . . . . . . . . 255
7.6
Summary and further reading . . . . . . . . . . . . . . . . . . . . . . . . . 256
A Exercise solutions
259
A.1 Solutions for Chapter 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
A.2 Solutions for Chapter 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270

xii
CONTENTS
A.3 Solutions for Chapter 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
A.4 Solutions for Chapter 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
A.5 Solutions for Chapter 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
A.6 Solutions for Chapter 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
A.7 Solutions for Chapter 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
Bibliography
323
Index
331

Chapter 1
Generative eÔ¨Äects:
Orders and Galois connections
In this book, we explore a wide variety of situations‚Äîin the world of science, engineer-
ing, and commerce‚Äîwhere we see something we might call compositionality. These
are cases in which systems or relationships can be combined to form new systems or
relationships. In each case we Ô¨Ånd category-theoretic constructs‚Äîdeveloped for their
use in pure math‚Äîwhich beautifully describe the compositionality of the situation.
This chapter, being the Ô¨Årst of the book, must serve this goal in two capacities.
First, it must provide motivating examples of compositionality, as well as the relevant
categorical formulations. Second, it must provide the mathematical foundation for the
rest of the book. Since we are starting with minimal assumptions about the reader‚Äôs
background, we must begin slowly and build up throughout the book. As a result,
examples in the early chapters are necessarily simpliÔ¨Åed. However, we hope the reader
will already begin to see the sort of structural approach to modeling that category
theory brings to the fore.
1.1
More than the sum of their parts
We motivate this Ô¨Årst chapter by noticing that while many real-world structures are
compositional, the results of observing them are often not. The reason is that ob-
servation is inherently ‚Äúlossy‚Äù: in order to extract information from something, one
must drop the details. For example, one stores a real number by rounding it to some
precision. But if the details are actually relevant in a given system operation, then the
observed result of that operation will not be as expected. This is clear in the case of
roundoÔ¨Äerror, but it also shows up in non-numerical domains: observing a complex
system is rarely enough to predict its behavior because the observation is lossy.
A central theme in category theoryisthestudyofstructuresandstructure-preserving
maps. A map f : X ‚ÜíY is a kind of observation of object X via a speciÔ¨Åed relationship
it has with another object, Y. For example, think of X as the subject of an experiment
1

2
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
and Y as a meter connected to X, which allows us to extract certain features of X by
looking at the reaction of Y.
Asking which aspects of X one wants to preserve under the observation f becomes
the question ‚Äúwhat category are you working in?.‚Äù As an example, there are many
functions f from R to R, and we can think of them as observations: rather than view
x ‚Äúdirectly‚Äù, we only observe f (x). Out of all the functions f : R ‚ÜíR, only some of
them preserve the order of numbers, only some of them preserve the distance between
numbers, only some of them preserve the sum of numbers, etc. Let‚Äôs check in with an
exercise; a solution can be found in Chapter 1.
Exercise 1.1.
Some terminology: a function f : R ‚ÜíR is said to be
(a) order-preserving if x ‚â§y implies f (x) ‚â§f (y), for all x, y ‚ààR;1
(b) metric-preserving if |x ‚àíy|  | f (x) ‚àíf (y)|;
(c) addition-preserving if f (x + y)  f (x) + f (y).
For each of the three properties deÔ¨Åned above‚Äîcall it foo‚ÄîÔ¨Ånd an f that is foo-
preserving and an example of an f that is not foo-preserving.
‚ô¶
In category theory we want to keep control over which aspects of our systems are
being preserved under various observations. As we said above, the less structure is
preserved by our observation of a system, the more ‚Äúsurprises‚Äù occur when we observe
its operations. One might call these surprises generative eÔ¨Äects.
In using category theory to explore generative eÔ¨Äects, we follow the basic ideas
from work by Adam [Ada17]. He goes much more deeply into the issue than we can
here; see Section 1.5. But as mentioned above, we must also use this chapter to give an
order-theoretic warm-up for the full-Ô¨Çedged category theory to come.
1.1.1
A Ô¨Årst look at generative eÔ¨Äects
To explore the notion of a generative eÔ¨Äect we need a sort of system, a sort of observa-
tion, and a system-level operation that is not preserved by the observation. Let‚Äôs start
with a simple example.
A simple system.
Consider three points; we‚Äôll call them ‚Ä¢, ‚ó¶and ‚àó. In this example, a
system will simply be a way of connecting these points together. We might think of our
points as sites on a power grid, with a system describing connection by power lines, or
as people susceptible to some disease, with a system describing interactions that can
lead to contagion. As an abstract example of a system, there is a system where ‚Ä¢ and ‚ó¶
1We are often taught to view functions f : R ‚ÜíR as plots on an (x, y)-axis, where x is the domain
(independent) variable and y is the codomain (dependent) variable. In this book, we do not adhere to
that naming convention; e.g. in Exercise 1.1, both x and y are being ‚Äúplugged in‚Äù as input to f . As an
example consider the function f (x)  x2. Then f being order-preserving would say that for any x, y ‚ààR,
if x ‚â§y then x2 ‚â§y2; is that true?

1.1. MORE THAN THE SUM OF THEIR PARTS
3
are connected, but neither are connected to ‚àó. We shall draw this like so:
‚Ä¢
‚àó
‚ó¶
Connections are symmetric, so if a is connected to b, then b is connected to a. Connec-
tions are also transitive, meaning that if a is connected to b, and b is connected to c, then
a is connected to c; that is, all a, b, and c are connected. Friendship is not transitive‚Äîmy
friend‚Äôs friend is not necessarily my friend‚Äîbut possible communication of a concept
or a disease is.
Here we depict two more systems, one in which none of the points are connected,
and one in which all three points are connected.
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
There are Ô¨Åve systems in all, and we depict them just below.
Now that we have deÔ¨Åned the sort of system we want to discuss, suppose that Alice
is observing this system. Her observation of interest, which we call Œ¶, extracts a single
feature from a system, namely whether the point ‚Ä¢ is connected to the point ‚àó; this
is what she wants to know. Her observation of the system will be an assignment of
either true or false; she assigns true if ‚Ä¢ is connected to ‚àó, and false otherwise. So
Œ¶ assigns the value true to the following two systems:
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
and Œ¶ assigns the value false to the three remaining systems:
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
(1.2)
The last piece of setup is to give a sort of operation that Alice wants to perform on
the systems themselves. It‚Äôs a very common operation‚Äîone that will come up many
times throughout the book‚Äîcalled join. If the reader has been following the story arc,
the expectation here is that Alice‚Äôs connectivity observation will not be compositional
with respect to the operation of system joining; that is, there will be generative eÔ¨Äects.
Let‚Äôs see what this means.

4
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Joining our simple systems.
Joining two systems A and B is performed simply by
combining their connections. That is, we shall say the join of systems A and B, denote
it A ‚à®B, has a connection between points x and y if there are some points z1, . . . , zn
such that each of the following are true in at least one of A or B: x is connected to z1,
zi is connected to zi+1, and zn is connected to y. In a three-point system, the above
deÔ¨Ånition is overkill, but we want to say something that works for systems with any
number of elements. The high-level way to say it is ‚Äútake the transitive closure of
the union of the connections in A and B.‚Äù In our three-element system, it means for
example that
‚Ä¢
‚àó
‚ó¶
‚à®
‚Ä¢
‚àó
‚ó¶

‚Ä¢
‚àó
‚ó¶
and
‚Ä¢
‚àó
‚ó¶
‚à®
‚Ä¢
‚àó
‚ó¶

‚Ä¢
‚àó
‚ó¶
(1.3)
Exercise 1.4.
What is the result of joining the following two systems?
11‚Ä¢
12‚Ä¢
13‚Ä¢
21‚Ä¢
22‚Ä¢
23‚Ä¢
11‚Ä¢
12‚Ä¢
13‚Ä¢
21‚Ä¢
22‚Ä¢
23‚Ä¢
‚à®
‚ô¶
We are now ready to see the generative eÔ¨Äect. We don‚Äôt want to build it up too
much‚Äîthis example has been made as simple as possible‚Äîbut we will see that Alice‚Äôs
observation fails to preserve the join operation. We‚Äôve been denoting her observation‚Äî
measuring whether ‚Ä¢ and ‚àóare connected‚Äîby the symbol Œ¶; it returns a boolean result,
either true or false.
We see above in Eq. (1.2) that Œ¶(
‚Ä¢
‚àó
‚ó¶)  Œ¶(
‚Ä¢
‚àó
‚ó¶)  false: in both cases ‚Ä¢ is not connected
to ‚àó. On the other hand, when we join these two systems as in Eq. (1.3), we see that
Œ¶(
‚Ä¢
‚àó
‚ó¶‚à®
‚Ä¢
‚àó
‚ó¶)  Œ¶(
‚Ä¢
‚àó
‚ó¶)  true: in the joined system, ‚Ä¢ is connected to ‚àó. The question that
Alice is interested in, that of Œ¶, is inherently lossy with respect to join, and there is no
way to Ô¨Åx it without a more detailed observation, one that includes not only ‚àóand ‚Ä¢
but also ‚ó¶.
While this was a simple example, it should be noted that whether the potential for
such eÔ¨Äects exist‚Äîi.e. determining whether an observation is operation-preserving‚Äî
can be incredibly important information to know. For example, Alice could be in charge
of putting together the views of two local authorities regarding possible contagion
between an infected person ‚Ä¢ and a vulnerable person ‚àó. Alice has noticed that if they

1.1. MORE THAN THE SUM OF THEIR PARTS
5
separately extract information from their raw data and combine the results, it gives a
diÔ¨Äerent answer than if they combine their raw data and extract information from it.
1.1.2
Ordering systems
Category theory is all about organizing and layering structures. In this section we
will explain how the operation of joining systems can be derived from a more basic
structure: order. We will see that while joining is not preserved by Alice‚Äôs connectivity
observation Œ¶, order is.
To begin, we note that the systems themselves are ordered in a hierarchy. Given
systems A and B, we say that A ‚â§B if, whenever x is connected to y in A, then x is
connected to y in B. For example,
‚Ä¢
‚àó
‚ó¶
‚â§
‚Ä¢
‚àó
‚ó¶
This notion of ‚â§leads to the following diagram:
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
(1.5)
where an arrow from system A to system B means A ‚â§B. Such diagrams are known
as Hasse diagrams.
As we were saying above, the notion of join is derived from this order. Indeed for
any two systems A and B in the Hasse diagram (1.5), the joined system A ‚à®B is the
smallest system that is bigger than both A and B. That is, A ‚â§(A ‚à®B) and B ‚â§(A ‚à®B),
and for any C, if A ‚â§C and B ‚â§C then (A ‚à®B) ‚â§C. Let‚Äôs walk through this with an
exercise.
Exercise 1.6.

6
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
1. Write down all the partitions of a two element set {‚Ä¢, ‚àó}, order them as above,
and draw the Hasse diagram.
2. Now do the same thing for a four element-set, say {1, 2, 3, 4}. There should be 15
partitions.
Choose any two systems in your 15-element Hasse diagram, call them A and B.
3. What is A ‚à®B, using the deÔ¨Ånition given in the paragraph above Eq. (1.3)?
4. Is it true that A ‚â§(A ‚à®B) and B ‚â§(A ‚à®B)?
5. What are all the systems C for which both A ‚â§C and B ‚â§C.
6. Is it true that in each case, (A ‚à®B) ‚â§C?
‚ô¶
The set B  {true, false} of booleans also has an order, false ‚â§true:
true
false
Thus false ‚â§false, false ‚â§true, and true ‚â§true, but true ‚â∞false. In other
words, A ‚â§B if A implies B.2
For any A, B in B, we can again write A ‚à®B to mean the least element that is greater
than both A and B.
Exercise 1.7.
Using the order false ‚â§true on B  {true, false}, what is:
1. true ‚à®false?
2. false ‚à®true?
3. true ‚à®true?
4. false ‚à®false?
‚ô¶
Let‚Äôs return to our systems with ‚Ä¢, ‚ó¶, and ‚àó, and Alice‚Äôs ‚Äú‚Ä¢ is connected to ‚àó‚Äù function,
which we called Œ¶. It takes any such system and returns either true or false. Note
that the map Œ¶ preserves the ‚â§order: if A ‚â§B and there is a connection between ‚Ä¢ and
‚àóin A, then there is such a connection in B too. The possibility of a generative eÔ¨Äect is
captured in the inequality
Œ¶(A) ‚à®Œ¶(B) ‚â§Œ¶(A ‚à®B).
(1.8)
We saw on page 4 that this can be a strict inequality: we showed two systems A and B
with Œ¶(A)  Œ¶(B)  false, so Œ¶(A) ‚à®Œ¶(B)  false, but where Œ¶(A ‚à®B)  true. In
this case, a generative eÔ¨Äect exists.
These ideas capture the most basic ideas in category theory. Most directly, we have
seen that the map Œ¶ preserves some structure but not others: it preserves order but not
join. In fact, we have seen here hints of more complex notions from category theory,
without making them explicit; these include the notions of category, functor, colimit,
and adjunction. In this chapter we will explore these ideas in the elementary setting of
ordered sets.
2In mathematical logic, false implies true but true does not imply false. That is ‚ÄúP implies Q‚Äù
means, ‚Äúif P is true, then Q is true too, but if P is not true, I‚Äôm making no claims.‚Äù

1.2. WHAT IS ORDER?
7
1.2
What is order?
Above we informally spoke of two diÔ¨Äerent ordered sets: the order on system connec-
tivity and the order on booleans false ‚â§true. Then we related these two ordered
sets by means of Alice‚Äôs observation Œ¶. Before continuing, we need to make such
ideas more precise. We begin in Section 1.2.1 with a review of sets and relations. In
Section 1.2.2 we will give the deÔ¨Ånition of a preorder‚Äîshort for preordered set‚Äîand
a good number of examples.
1.2.1
Review of sets, relations, and functions
We will not give a deÔ¨Ånition of set here, but informally we will think of a set as a
collection of things, known as elements. These things could be all the leaves on a
certain tree, or the names of your favorite fruits, or simply some symbols a, b, c. For
example, we write A  {h, 1} to denote the set, called A, that contains exactly two
elements, one called h and one called 1. The set {h, h, 1, h, 1} is exactly the same as A
because they both contain the same elements, h and 1, and repeating an element more
than once in the notation doesn‚Äôt change the set.3 For an arbitrary set X, we write x ‚ààX
if x is element of X; so we have h ‚ààA and 1 ‚ààA, but 0 < A.
Example 1.9. Here are some important sets from mathematics‚Äîand the notation we
will use‚Äîthat will appear again in this book.
‚Ä¢ ¬ú denotes the empty set; it has no elements.
‚Ä¢ {1} denotes a set with one element; it has one element, 1.
‚Ä¢ B denotes the set of booleans; it has two elements, true and false.
‚Ä¢ N denotes the set of natural numbers; it has elements 0, 1, 2, 3, . . . , 90717, . . ..
‚Ä¢ n, for any n ‚ààN, denotes the nth ordinal; it has n elements 1, 2, . . . , n. For example,
0  ¬ú, 1  {1}, and 5  {1, 2, 3, 4, 5}.
‚Ä¢ Z, the set of integers; it has elements . . . , ‚àí2, ‚àí1, 0, 1, 2, . . . , 90717, . . ..
‚Ä¢ R, the set of real numbers; it has elements like œÄ, 3.14, 5‚àó
‚àö
2, e, e2, ‚àí1457, 90717, etc.
Given sets X and Y, we say that X is a subset of Y, and write X ‚äÜY, if every element
in X is also in Y. For example {h} ‚äÜA. Note that the empty set ¬ú B {} is a subset
of every other set.4 Given a set Y and a property P that is either true or false for each
element of Y, we write {y ‚ààY | P(y)} to mean the subset of those y‚Äôs that satisfy P.
Exercise 1.10.
1. Is it true that N  {n ‚ààZ | n ‚â•0}?
3If you want a notion where ‚Äúh, 1‚Äù is diÔ¨Äerent than ‚Äúh, h, 1, h, 1‚Äù, you can use something called bags,
where the number of times an element is listed matters, or lists, where order also matters. All of these are
important concepts in applied category theory, but sets will come up the most for us.
4When we write Z B foo, it means ‚Äúassign the meaning foo to variable Z‚Äù, whereas Z  foo means
simply that Z is equal to foo, perhaps as discovered via some calculation. In particular, Z B foo implies
Z  foo but not vice versa; indeed it would not be proper to write 3 + 2 B 5 or {} B ¬ú.

8
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Is it true that N  {n ‚ààZ | n ‚â•1}?
3. Is it true that ¬ú  {n ‚ààZ | 1 < n < 2}?
‚ô¶
If both X1 and X2 are subsets of Y, their union, denoted X1 ‚à™X2, is also a subset of
Y, namely the one containing the elements in X1 and the elements in X2 but no more.
For example if Y  {1, 2, 3, 4} and X1  {1, 2} and X2  {2, 4}, then X1 ‚à™X2  {1, 2, 4}.
Note that ¬ú ‚à™X  X for any X ‚äÜY.
Similarly, if both X1 and X2 are subsets of Y, then their intersection, denoted X1 ‚à©X2,
is also a subset of Y, namely the one containing all the elements of Y that are both in
X1 and in X2, and no others. So {1, 2, 3} ‚à©{2, 5}  {2}.
What if we need to union or intersect a lot of subsets? For example, consider the
sets X0  ¬ú, X1  {1}, X2  {1, 2}, etc. as subsets of N, and we want to know what the
union of all of them is. This union is written √ê
n‚ààN Xn, and it is the subset of N that
contains every element of every Xn, but no others. Namely, √ê
n‚ààN Xn  {n ‚ààN | n ‚â•1}.
Similarly one can write √ë
n‚ààN Xn for the intersection of all of them, which will be empty
in the above case.
Given two sets X and Y, the product X √ó Y of X and Y is the set of pairs (x, y), where
x ‚ààX and y ‚ààY.
Finally, we may want to take a disjoint union of two sets, even if they have elements
in common. Given two sets X and Y, their disjoint union X ‚äîY is the set of pairs of the
form (x, 1) or (y, 2), where x ‚ààX and y ‚ààY.
Exercise 1.11.
Let A B {h, 1} and B B {1, 2, 3}.
1. There are eight subsets of B; write them out.
2. Take any two nonempty subsets of B and write out their union.
3. There are six elements in A √ó B; write them out.
‚ô¶
4. There are Ô¨Åve elements of A ‚äîB; write them out.
5. If we consider A and B as subsets of the set {h, 1, 2, 3}, there are four elements of
A ‚à™B; write them out.
Relationships between diÔ¨Äerent sets‚Äîfor example between the set of trees in your
neighborhood and the set of your favorite fruits‚Äîare captured using subsets and
product sets.
DeÔ¨Ånition 1.12. Let X and Y be sets. A relation between X and Y is a subset R ‚äÜX √ó Y.
A binary relation on X is a relation between X and X, i.e. a subset R ‚äÜX √ó X.
It is convenient to use something called inÔ¨Åx notation for binary relations R ‚äÜA √ó A.
This means one picks a symbol, say ‚ãÜ, and writes a ‚ãÜb to mean (a, b) ‚ààR.
Example 1.13. There is a binary relation on R with inÔ¨Åx notation ‚â§. Rather than writing
(5, 6) ‚ààR, we write 5 ‚â§6.
Other examples of inÔ¨Åx notation for relations are , ‚âà, <, >. In number theory, they
are interested in whether one number divides without remainder into another number;

1.2. WHAT IS ORDER?
9
this relation is denoted with inÔ¨Åx notation |, so 5|10.
Partitions and equivalence relations.
We can now deÔ¨Åne partitions more formally.
DeÔ¨Ånition 1.14. If A is a set, a partition of A consists of a set P and, for each p ‚ààP, a
nonempty subset Ap ‚äÜA, such that
A 
√ò
p‚ààP
Ap
and
if p , q then Ap ‚à©Aq  ¬ú.
(1.15)
We may denote the partition by {Ap}p‚ààP. We refer to P as the set of part labels and if
p ‚ààP is a part label, we refer to Ap as the pth part. The condition (1.15) says that each
element a ‚ààA is in exactly one part.
We consider two diÔ¨Äerent partitions {Ap}p‚ààP and {A‚Ä≤
p‚Ä≤}p‚Ä≤‚ààP‚Ä≤ of A to be the same if for
each p ‚ààP there exists a p‚Ä≤ ‚ààP‚Ä≤ with Ap  A‚Ä≤
p‚Ä≤. In other words, if two ways to divide A
into parts are exactly the same‚Äîthe only change is in the labels‚Äîthen we don‚Äôt make
a distinction between them.
Exercise 1.16.
Suppose that A is a set and {Ap}p‚ààP and {A‚Ä≤
p‚Ä≤}p‚Ä≤‚ààP‚Ä≤ are two partitions of
A such that for each p ‚ààP there exists a p‚Ä≤ ‚ààP‚Ä≤ with Ap  A‚Ä≤
p‚Ä≤.
1. Show that for each p ‚ààP there is at most one p‚Ä≤ ‚ààP‚Ä≤ such that Ap  A‚Ä≤
p‚Ä≤
2. Show that for each p‚Ä≤ ‚ààP‚Ä≤ there is a p ‚ààP such that Ap  A‚Ä≤
p‚Ä≤.
‚ô¶
Exercise 1.17.
Consider the partition shown below:
11‚Ä¢
12‚Ä¢
13‚Ä¢
21‚Ä¢
22‚Ä¢
23‚Ä¢
For any two elements a, b ‚àà{11, 12, 13, 21, 22, 23}, let‚Äôs allow ourselves to write a
twiddle symbol a ‚àºb between them if a and b are both in the same part. Write down
every pair of elements (a, b) that are in the same part. There should be 10.5
‚ô¶
We will see in Proposition 1.19 that there is a strong relationship between partitions
and something called equivalence relations, which we deÔ¨Åne next.
DeÔ¨Ånition 1.18. Let A be a set. An equivalence relation on A is a binary relation, let‚Äôs
give it inÔ¨Åx notation ‚àº, satisfying the following three properties:
(a) a ‚àºa, for all a ‚ààA,
(b) a ‚àºb iÔ¨Äa b ‚àºa, for all a, b ‚ààA, and
(c) if a ‚àºb and b ‚àºc then a ‚àºc, for all a, b, c ‚ààA.
5Hint: whenever someone speaks of ‚Äútwo elements a, b in a set A‚Äù, the two elements may be the same!

10
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
These properties are called reÔ¨Çexivity, symmetry, and transitivity, respectively.
a‚ÄòIÔ¨Ä‚Äô is short for ‚Äòif and only if‚Äô.
Proposition 1.19. Let A be a set. There is a one-to-one correspondence between the
ways to partition A and the equivalence relations on A.
Proof. We Ô¨Årst show that every partition gives rise to an equivalence relation, and then
that every equivalence relation gives rise to a partition. Our two constructions will be
mutually inverse, proving the proposition.
Suppose we are given a partition {Ap}p‚ààP; we deÔ¨Åne a relation ‚àºand show it is an
equivalence relation. DeÔ¨Åne a ‚àºb to mean that a and b are in the same part: there is
some p ‚ààP such that a ‚ààAp and b ‚ààAp. It is obvious that a is in the same part as
itself. Similarly, it is obvious that if a is in the same part as b then b is in the same part
as a, and that if further b is in the same part as c then a is in the same part as c. Thus
‚àºis an equivalence relation as deÔ¨Åned in DeÔ¨Ånition 1.18.
Suppose given an equivalence relation ‚àº; we will form a partition on A by saying
what the parts are. Say that a subset X ‚äÜA is (‚àº)-closed if, for every x ‚ààX and
x‚Ä≤ ‚àºx, we have x‚Ä≤ ‚ààX. Say that a subset X ‚äÜA is (‚àº)-connected if it is nonempty and
x ‚àºy for every x, y ‚ààX. Then the parts corresponding to ‚àºare exactly the (‚àº)-closed,
(‚àº)-connected subsets. It is not hard to check that these indeed form a partition.
‚ñ°
Exercise 1.20.
Let‚Äôs complete the ‚Äúit‚Äôs not hard to check‚Äù part in the proof of Proposi-
tion 1.19. Suppose that ‚àºis an equivalence relation on a set A, and let P be the set of
(‚àº)-closed and (‚àº)-connected subsets {Ap}p‚ààP.
1. Show that each part Ap is nonempty.
2. Show that if p , q, i.e. if Ap and Aq are not exactly the same set, then Ap ‚à©Aq  ¬ú.
3. Show that A  √ê
p‚ààP Ap.
‚ô¶
DeÔ¨Ånition 1.21. Given a set A and an equivalence relation ‚àºon A, we say that the
quotient A/‚àºof A under ‚àºis the set of parts of the corresponding partition.
Functions.
The most frequently used sort of relation between sets is that of functions.
DeÔ¨Ånition 1.22. Let S and T be sets. A function from S to T is a subset F ‚äÜS √ó T such
that for all s ‚ààS there exists a unique t ‚ààT with (s, t) ‚ààF.
The function F is often denoted F : S ‚ÜíT. From now on, we write F(s)  t, or
sometimes s 7‚Üít, to mean (s, t) ‚ààF. For any t ‚ààT, the preimage of t along F is the
subset {s ‚ààS | F(s)  t}.
A function is called surjective, or a surjection, if for all t ‚ààT there exists s ‚ààS with
F(s)  t. A function is called injective, or an injection, if for all t ‚ààT and s1, s2 ‚ààS

1.2. WHAT IS ORDER?
11
with F(s1)  t and F(s2)  t, we have s1  s2. A function is called bƒ≥ective if it is both
surjective and injective.
We use various decorations on arrows, ‚Üí, ‚Ü†, ‚Ü£,
‚àí‚Üíto denote these special sorts of
functions. Here is a table with the name, arrow decoration, and an example of each
sort of function:
arbitrary function
surjective function
injective function
bƒ≥ective function
3 ‚Üí3
3 ‚Ü†2
2 ‚Ü£3
3
‚àí‚Üí3
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
Example 1.23. An important but very simple sort of function is the identity function on
a set X, denoted idX. It is the bƒ≥ective function idX(x)  x.
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
For notational consistency with DeÔ¨Ånition 1.22, the arrows in Example 1.23 might
be drawn as 7‚Üírather than d. The d-style arrows were drawn because we thought it
was prettier, i.e. easier on the eye. Beauty is important too; an imbalanced preference
for strict correctness over beauty becomes pedantry. But outside of pictures, we will be
careful.
Exercise 1.24.
In the following, do not use any examples already drawn above.
1. Find two sets A and B and a function f : A ‚ÜíB that is injective but not surjective.
2. Find two sets A and B and a function f : A ‚ÜíB that is surjective but not injective.
Now consider the four relations shown here:
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
For each relation, answer the following two questions.
3. Is it a function?
4. If not, why not? If so, is it injective, surjective, both (i.e. bƒ≥ective), or neither?
‚ô¶
Exercise 1.25.
Suppose that A is a set and f : A ‚Üí¬ú is a function to the empty set.
Show that A is empty.
‚ô¶

12
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Example 1.26. A partition on a set A can also be understood in terms of surjective
functions out of A. Given a surjective function f : A ‚Ü†P, where P is any other set, the
preimages f ‚àí1(p) ‚äÜA, one for each element p ‚ààP, form a partition of A. Here is an
example.
Consider the partition of S B {11, 12, 13, 21, 22, 23} shown below:
11‚Ä¢
12‚Ä¢
13‚Ä¢
21‚Ä¢
22‚Ä¢
23‚Ä¢
S B
It has been partitioned into four parts, so let P  {a, b, c, d} and let f : S ‚Ü†P be given
by
f (11)  a,
f (12)  a,
f (13)  b,
f (21)  c,
f (22)  d,
f (23)  d
Exercise 1.27.
Write down a surjection corresponding to each of the Ô¨Åve partitions in
Eq. (1.5).
‚ô¶
DeÔ¨Ånition 1.28. If F : X ‚ÜíY is a function and G: Y ‚ÜíZ is a function, their composite
is the function X ‚ÜíZ deÔ¨Åned to be G(F(x)) for any x ‚ààX. It is often denoted G ‚ó¶F, but
we prefer to denote it F # G. It takes any element x ‚ààX, evaluates F to get an element
F(x) ‚ààY and then evaluates G to get an element G(F(x)).
Example 1.29. If X is any set and x ‚ààX is any element, we can think of x as a function
{1} ‚ÜíX, namely the function sending 1 to x.
For example, the three functions
{1} ‚Üí{1, 2, 3} shown below correspond to the three elements of {1, 2, 3}:
‚Ä¢
‚Ä¢1
‚Ä¢2
‚Ä¢3
‚Ä¢
‚Ä¢1
‚Ä¢2
‚Ä¢3
‚Ä¢
‚Ä¢1
‚Ä¢2
‚Ä¢3
Suppose given a function F : X ‚ÜíY and an element of X, thought of as a function
x : {1} ‚ÜíX. Then evaluating F at x is given by the composite, F(x)  x # F.
1.2.2
Preorders
In Section 1.1, we several times used the symbol ‚â§to denote a sort of order. Here is a
formal deÔ¨Ånition of what it means for a set to have an order.

1.2. WHAT IS ORDER?
13
DeÔ¨Ånition 1.30. A preorder relation on a set X is a binary relation on X, here denoted
with inÔ¨Åx notation ‚â§, such that
(a) x ‚â§x; and
(b) if x ‚â§y and y ‚â§z, then x ‚â§z.
The Ô¨Årst condition is called reÔ¨Çexivity and the second is called transitivity. If x ‚â§y and
y ‚â§x, we write x  y and say x and y are equivalent. We call a pair (X, ‚â§) consisting
of a set equipped with a preorder relation a preorder.
Remark 1.31. Observe that reÔ¨Çexivity and transitivity are familiar from DeÔ¨Ånition 1.18:
preorders are just equivalence relations without the symmetry condition.
Example 1.32 (Discrete preorders). Every set X can be considered as a discrete preorder
(X, ). This means that the only order relations on X are of the form x ‚â§x; if x , y
then neither x ‚â§y or y ‚â§x hold.
We depict discrete preorders as simply a collection of points:
‚Ä¢
‚Ä¢
‚Ä¢
Example 1.33 (Codiscrete preorders). From every set we may also construct its codiscrete
preorder (X, ‚â§) by equipping it with the total binary relation X √ó X ‚äÜX √ó X. This is a
very trivial structure: it means that for all x and y in X we have x ‚â§y (and hence also
y ‚â§x).
Example 1.34 (Booleans). The booleansB  {false, true} form a preorder with false ‚â§
true.
false
true
Remark 1.35 (Partial orders are skeletal preorders). A preorder is a partial order if we
additionally have that
(c) x  y implies x  y.
In category theory terminology, the requirement that x  y implies x  y is known
as skeletality, so partial orders are skeletal preorders. For short, we also use the term poset,
a contraction of partially ordered set.
The diÔ¨Äerence between preorders and partial orders is rather minor. A partial order
already is a preorder, and every preorder can be made into a partial order by equating
any two elements x, y for which x  y, i.e. for which x ‚â§y and y ‚â§x.
For example, any discrete preorder is already a partial order, while any codiscrete
preorder simply becomes the unique partial order on a one element set.

14
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
We have already introduced a few examples of preorders using Hasse diagrams. It
will be convenient to continue to do this, so let us be a bit more formal about what we
mean. First, we need to deÔ¨Åne a graph.
DeÔ¨Ånition 1.36. A graph G  (V, A, s, t) consists of a set V whose elements are called
vertices, a set A whose elements are called arrows, and two functions s, t : A ‚ÜíV known
as the source and target functions respectively. Given a ‚ààA with s(a)  v and t(a)  w,
we say that a is an arrow from v to w.
By a path in G we mean any sequence of arrows such that the target of one arrow is
the source of the next. This includes sequences of length 1, which are just arrows a ‚ààA
in G, and sequences of length 0, which just start and end at the same vertex v, without
traversing any arrows.
Example 1.37. Here is a picture of a graph:
G 
1‚Ä¢
2‚Ä¢
3‚Ä¢
4‚Ä¢
a
b
c
e
d
It has V  {1, 2, 3, 4} and A  {a, b, c, d, e}. The source and target functions, s, t : A ‚Üí
V are given by the following partially-Ô¨Ålled-in tables (see Exercise 1.38):
arrow a
source s(a) ‚ààV
target t(a) ‚ààV
a
1
?
b
1
3
c
?
?
d
?
?
e
?
?
There is one path from 2 to 3, namely the arrow e is a path of length 1. There are no
paths from 4 to 3, but there is one path from 4 to 4, namely the path of length 0. There
are inÔ¨Ånitely many paths 1 ‚Üí2 because one can loop and loop and loop through d as
many times as one pleases.
Exercise 1.38.
Fill in the table from Example 1.37.
‚ô¶
Remark 1.39. From every graph we can get a preorder. Indeed, a Hasse diagram is a
graph G  (V, A, s, t) that gives a presentation of a preorder (P, ‚â§). The elements of P
are the vertices V in G, and the order ‚â§is given by v ‚â§w iÔ¨Ä6 there is a path v ‚Üíw.
For any vertex v, there is always a path v ‚Üív, and this translates into the reÔ¨Çexivity
6The word ‚ÄòiÔ¨Ä‚Äô is a common mathematical shorthand for the phrase ‚Äúif and only if‚Äù, and we use it to
connect two statements that each imply the other, and hence are logically equivalent.

1.2. WHAT IS ORDER?
15
law from DeÔ¨Ånition 1.30. The fact that paths u ‚Üív and v ‚Üíw can be concatenated to
a path u ‚Üíw translates into the transitivity law.
Exercise 1.40. What preorder relation (P, ‚â§) is depicted by the graph G in Example 1.37?
That is, what are the elements of P and write down every pair (p1, p2) for which p1 ‚â§p2.
‚ô¶
Exercise 1.41.
Does a collection of points, like the one in Example 1.32, count as a
Hasse diagram?
‚ô¶
Exercise 1.42.
Let X be the set of partitions of {‚Ä¢, ‚ó¶, ‚àó}; it has Ô¨Åve elements and an order
by coarseness, as shown in the Hasse diagram Eq. (1.5). Write down every pair (x, y)
of elements in X such that x ‚â§y. There should be 12.
‚ô¶
Remark 1.43. In Remark 1.35 we discussed partial orders‚Äîpreorders with the property
that whenever two elements are equivalent, they are the same‚Äîand then said that this
property is fairly inconsequential: any preorder can be converted to a partial order
that‚Äôs ‚Äúequivalent‚Äù category-theoretically. A partial order is like a preorder with a
fancy haircut: some mathematicians might not even notice it.
However, there are other types of preorders that are more special and noticeable.
For example, a total order has the following additional property:
(d) for all x, y, either x ‚â§y or y ‚â§x.
We say two elements x, y of a preorder are comparable if either x ‚â§y or y ‚â§x, so a total
order is a preorder where every two elements are comparable.
Exercise 1.44.
Is it correct to say that a discrete preorder is one where no two elements
are comparable?
‚ô¶
Example 1.45 (Natural numbers). The natural numbers N B {0, 1, 2, 3, . . .} are a pre-
order with the order given by the usual size ordering, e.g. 0 ‚â§1 and 5 ‚â§100. This is
a total order: either m ‚â§n or n ‚â§m for all m, n. One can see that its Hasse diagram
looks like a line:
0‚Ä¢
1‚Ä¢
2‚Ä¢
3‚Ä¢
¬∑ ¬∑ ¬∑
What made Eq. (1.5) not look like a line is that there are non-comparable elements a
and b‚Äînamely all those in the middle row‚Äîwhich satisfy neither a ‚â§b nor b ‚â§a.
Note that for any set S, there are many diÔ¨Äerent ways of assigning an order to S.
Indeed, for the set N, we could also use the discrete ordering: only write n ‚â§m if
n  m. Another ordering is the reverse ordering, like 5 ‚â§3 and 3 ‚â§2, like how golf is
scored (5 is worse than 3).
Yet another ordering on N is given by division: we say that n ‚â§m if n divides into
m without remainder. In this ordering 2 ‚â§4, for example, but 2 ‚â∞3, since there is a
remainder when 2 is divided into 3.
Exercise 1.46.
Write down the numbers 1, 2, . . . , 10 and draw an arrow a ‚Üíb if a
divides perfectly into b. Is it a total order?
‚ô¶

16
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Example 1.47 (Real numbers). The real numbers R also form a preorder with the ‚Äúusual
ordering‚Äù, e.g. ‚àí500 ‚â§‚àí499 ‚â§0 ‚â§
‚àö
2 ‚â§100/3.
Exercise 1.48.
Is the usual ‚â§ordering on the set R of real numbers a total order?
‚ô¶
Example 1.49 (Partition from preorder). Given a preorder, i.e. a pre-ordered set (P, ‚â§),
we deÔ¨Åned the notion of equivalence of elements, denoted x  y, to mean x ‚â§y and
y ‚â§x. This is an equivalence relation, so it induces a partition on P. (The phrase
‚ÄúA induces B‚Äù means that we have an automatic way to turn an A into a B. In this
case, we‚Äôre saying that we have an automatic way to turn equivalence relations into
partitions, which we do; see Proposition 1.19.)
For example, the preorder whose Hasse diagram is drawn on the left corresponds
to the partition drawn on the right.
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
11
21
11
21
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
12
22
12
22
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
13
23
13
23
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
14
24
14
24
Example 1.50 (Power set). Given a set X, the set of subsets of X is known as the power
set of X; we denote it P(X). The power set can naturally be given an order by inclusion
of subsets (and from now on, whenever we speak of the power set as an ordered set,
this is the order we mean).
For example, taking X  {0, 1, 2}, we depict P(X) as
X
{0, 1}
{0, 2}
{1, 2}
{0}
{1}
{2}
¬ú
See the cube? The Hasse diagram for the power set of a Ô¨Ånite set, say P{1, 2, . . . , n},a
always looks like a cube of dimension n.
aNote that we omit the parentheses here, writing PX instead of P(X); throughout this book we will
omit parentheses if we judge the presentation is cleaner and it is unlikely to cause confusion.
Exercise 1.51.
Draw the Hasse diagrams for P(¬ú), P{1}, and P{1, 2}.
‚ô¶

1.2. WHAT IS ORDER?
17
Example 1.52 (Partitions). We talked about getting a partition from a preorder; now let‚Äôs
think about how we might order the set Prt(A) of all partitions of A, for some set A. In
fact, we have done this before in Eq. (1.5). Namely, we order on partitions by Ô¨Åneness:
a partition P is Ô¨Åner than a partition Q if, for every part p ‚ààP there is a part q ‚ààQ such
that Ap ‚äÜAq. We could also say that Q is coarser than P.
Recall from Example 1.26 that partitions on A can be thought of as surjective func-
tions out of A. Then f : A ‚Ü†P is Ô¨Åner than 1 : A ‚Ü†Q if there is a function h : P ‚ÜíQ
such that f # h  1.
Exercise 1.53.
For any set S there is a coarsest partition, having just one part. What
surjective function does it correspond to?
There is also a Ô¨Ånest partition, where everything is in its own partition.
What
surjective function does it correspond to?
‚ô¶
Example 1.54 (Upper sets). Given a preorder (P, ‚â§), an upper set in P is a subset U of P
satisfying the condition that if p ‚ààU and p ‚â§q, then q ‚ààU. ‚ÄúIf p is an element then so
is anything bigger.‚Äù Write U(P) for the set of upper sets in P. We can give the set U an
order by letting U ‚â§V if U is contained in V.
For example, if (B, ‚â§) is the booleans (Example 1.34), then its preorder of uppersets
U(B) is
¬ú
{true}
{true, false}
The subset {false} ‚äÜB is not an upper set, because false ‚â§true and true < {false}.
Exercise 1.55.
Prove that the preorder of upper sets on a discrete preorder (see Exam-
ple 1.32) on a set X is simply the power set P(X).
‚ô¶
Example 1.56 (Product preorder). Given preorders (P, ‚â§) and (Q, ‚â§), we may deÔ¨Åne a
preorder structure on the product set P √ó Q by setting (p, q) ‚â§(p‚Ä≤, q‚Ä≤) if and only if
p ‚â§p‚Ä≤ and q ‚â§q‚Ä≤. We call this the product preorder. This is a basic example of a more
general construction known as the product of categories.
Exercise 1.57.
Draw the Hasse diagram for the product of the two preorders drawn

18
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
below:
c‚Ä¢
b‚Ä¢
‚Ä¢
a
2‚Ä¢
‚Ä¢
1
For bonus points, compute the upper set preorder on the result.
‚ô¶
Example 1.58 (Opposite preorder). Given a preorder (P, ‚â§), we may deÔ¨Åne the opposite
preorder (P, ‚â§op) to have the same set of elements, but with p ‚â§op q if and only if q ‚â§p.
1.2.3
Monotone maps
We have said that the categorical perspective emphasizes relationships between things.
For example, a preorder is a setting‚Äîor world‚Äîin which we have one sort of relation-
ship, ‚â§, and any two objects may be, or may not be, so-related. Jumping up a level,
the categorical perspective emphasizes that preorders themselves‚Äîeach a miniature
world composed of many relationships‚Äîcan be related to one another.
The most important sort of relationship between preorders is called a monotone map.
These are functions that preserve preorder relations‚Äîin some sense mappings that
respect ‚â§‚Äîand are hence considered the right notion of structure-preserving map for
preorders.
DeÔ¨Ånition 1.59. A monotone map between preorders (A, ‚â§A) and (B, ‚â§B) is a function
f : A ‚ÜíB such that, for all elements x, y ‚ààA, if x ‚â§A y then f (x) ‚â§B f (y).
A monotone map A ‚ÜíB between two preorders associates to each element of
preorder A an element of the preorder B. We depict this by drawing a dotted arrow
from each element x ‚ààA to its image f (x) ‚ààB. Note that the order must be preserved
in order to count as a valid monotone map, so if element x is above element y in the
lefthand preorder A, then the image f (x) will be above the image f (y) in the righthand
preorder.
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

1.2. WHAT IS ORDER?
19
Example 1.60. Let B and N be the preorders of booleans from Example 1.34 and N the
preorder of natural numbers from Example 1.45. The map B ‚ÜíN sending false to 17
and true to 24 is a monotone map, because it preserves order.
false
true
0
1
¬∑ ¬∑ ¬∑
17
18
¬∑ ¬∑ ¬∑
23
24
¬∑ ¬∑ ¬∑
Example 1.61 (The tree of life). Consider the set of all animal classiÔ¨Åcations, for example
‚Äòtiger‚Äô, ‚Äòmammal‚Äô, ‚Äòsapiens‚Äô, ‚Äòcarnivore‚Äô, etc.. These are ordered by speciÔ¨Åcity: since
‚Äòtiger‚Äô is a type of ‚Äòmammal‚Äô, we write tiger ‚â§mammal. The result is a preorder, which
in fact forms a tree, often called the tree of life. At the top of the following diagram we
see a small part of it:
‚Ä¢
sapiens
‚Ä¢
habilis
‚Ä¢
lion
‚Ä¢
tiger
‚Ä¢
homo
‚Ä¢
panthera
‚Ä¢
primate
‚Ä¢
carnivore
‚Ä¢
mammal
‚Ä¢
species
‚Ä¢
genus
‚Ä¢
family
‚Ä¢
order
‚Ä¢
class
‚Ä¢
phylum
‚Ä¢
kingdom
At the bottom we see the hierarchical structure as a preorder. The dashed arrows show
a monotone map, call it F, from the classiÔ¨Åcations to the hierarchy. It is monotone
because it preserves order: whenever there is a path x ‚Üíy upstairs, there is a path
F(x) ‚ÜíF(y) downstairs.
Example 1.62. Given a Ô¨Ånite set X, recall the power set P(X) and its natural order relation
from Example 1.50. The map |¬∑| : P(X) ‚ÜíN sending each subset S to its number of
elements |S|, also called its cardinality, is a monotone map.
Exercise 1.63.
Let X  {0, 1, 2}.
1. Draw the Hasse diagram for P(X).
2. Draw the Hasse diagram for the preorder 0 ‚â§1 ‚â§2 ‚â§3.

20
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
3. Draw the cardinality map |¬∑| from Example 1.62 as dashed lines between them.
‚ô¶
Example 1.64. Recall the notion of upper set from Example 1.54. Given a preorder
(P, ‚â§), the map U(P) ‚ÜíP(P) sending each upper set of (P, ‚â§) to itself‚Äîconsidered as
a subset of P‚Äîis a monotone map.
Exercise 1.65.
Consider the preorder B. The Hasse diagram for U(B) was drawn in
Example 1.54, and you drew the Hasse diagram for P(B) in Exercise 1.51. Now draw
the monotone map between them, as described in Example 1.64.
‚ô¶
Exercise 1.66.
Let (P, ‚â§) be a preorder, and recall the notion of opposite preorder from
Example 1.58.
1. Show that the set ‚Üëp B {p‚Ä≤ ‚ààP | p ‚â§p‚Ä≤} is an upper set, for any p ‚ààP.
2. Show that this construction deÔ¨Ånes a monotone map ‚Üë: Pop ‚ÜíU(P).
3. Show that if p ‚â§p‚Ä≤ in P if and only if ‚Üë(p‚Ä≤) ‚äÜ‚Üë(p).
4. Draw a picture of the map ‚Üëin the case where P is the preorder (b ‚â•a ‚â§c) from
Example 1.56.
This is known as the Yoneda lemma for preorders. The if and only if condition proved
in part 3 implies that, up to equivalence, to know an element is the same as knowing
its upper set‚Äîthat is, knowing its web of relationships with the other elements of
the preorder. The general Yoneda lemma is a powerful tool in category theory, and a
fascinating philosophical idea besides.
‚ô¶
Exercise 1.67.
As you yourself well know, a monotone map f : (P, ‚â§P) ‚Üí(Q, ‚â§Q)
consists of a function f : P ‚ÜíQ that satisÔ¨Åes a ‚Äúmonotonicity‚Äù property. Show that
when (P, ‚â§P) is a discrete preorder, then every function P ‚ÜíQ satisÔ¨Åes the monotonicity
property, regardless of the order ‚â§Q.
‚ô¶
Example 1.68. Recall from Example 1.52 that given a set X we deÔ¨Åne Prt(X) to be the
set of partitions on X, and that a partition may be deÔ¨Åned using a surjective function
s : X ‚Ü†P for some set P.
Any surjective function f : X ‚Ü†Y induces a monotone map f ‚àó: Prt(Y) ‚ÜíPrt(X),
going ‚Äúbackwards.‚Äù It is deÔ¨Åned by sending a partition s : Y ‚Ü†P to the composite
f # s : X ‚Ü†P.7
Exercise 1.69.
Choose two sets X and Y with at least three elements each and choose
a surjective, non-identity function f : X ‚Ü†Y between them. Write down two diÔ¨Äerent
partitions P and Q of Y, and then Ô¨Ånd f ‚àó(P) and f ‚àó(Q).
‚ô¶
The following proposition, Proposition 1.70, is straightforward to check. Recall the
deÔ¨Ånition of the identity function from Example 1.23 and the deÔ¨Ånition of composition
from DeÔ¨Ånition 1.28.
7We will later see that any function f : X ‚ÜíY, not necessarily surjective, induces a monotone map
f ‚àó: Prt(Y) ‚ÜíPrt(X), but it involves an extra step. See Section 1.4.2.

1.2. WHAT IS ORDER?
21
Proposition 1.70. For any preorder (P, ‚â§P), the identity function is monotone.
If (Q, ‚â§Q) and (R, ‚â§R) are preorders and f : P ‚ÜíQ and 1 : Q ‚ÜíR are monotone,
then ( f # 1): P ‚ÜíR is also monotone.
Exercise 1.71.
Check the two claims made in Proposition 1.70.
‚ô¶
Example 1.72. Recall again the deÔ¨Ånition of opposite preorder from Example 1.58. The
identity function idP : P ‚ÜíP is a monotone map (P, ‚â§) ‚Üí(P, ‚â§op) if and only if for
all p, q ‚ààP we have q ‚â§p whenever p ‚â§q. For historical reasons connected to linear
algebra, when this is true, we call (P, ‚â§) a dagger preorder.
But in fact, we have seen dagger preorders before in another guise. Indeed, if (P, ‚â§)
is a dagger preorder, then the relation ‚â§is symmetric: p ‚â§q if and only if q ‚â§p, and it
is also reÔ¨Çexive and transitive by deÔ¨Ånition of preorder. So in fact ‚â§is an equivalence
relation (DeÔ¨Ånition 1.18).
Exercise 1.73.
Recall the notion of skeletal preorders (Remark 1.35) and discrete
preorders (Example 1.32).
Show that a skeletal dagger preorder is just a discrete
preorder, and hence can be identiÔ¨Åed with a set.
‚ô¶
Remark 1.74. We say that an A ‚Äúcan be identiÔ¨Åed with‚Äù a B when any A gives us a
unique B and any B gives us a unique A, and both round-trips‚Äîfrom an A to a B and
back to an A, or from a B to an A and back to a B‚Äîreturn us where we started. For
example, any discrete preorder (P, ‚â§) has an underlying set P, and any set P can be
made into a discrete preorder (p1 ‚â§p2 iÔ¨Äp1  p2), and the round-trips return us where
we started. So what‚Äôs the diÔ¨Äerence? It‚Äôs like the notion of object-permanence from child
development jargon: we can recognize ‚Äúthe same chair, just moved from one room to
another.‚Äù A chair in the room of sets can be moved to a chair in the room of preorders.
The lighting is diÔ¨Äerent but the chair is the same.
Eventually, we will be able to understand this notion in terms of equivalence of cate-
gories, which are related to isomorphisms, which we will explore next in DeÔ¨Ånition 1.75.
DeÔ¨Ånition 1.75. Let (P, ‚â§P) and (Q, ‚â§Q) be preorders. A monotone function f : P ‚ÜíQ
is called an isomorphism if there exists a monotone function 1 : Q ‚ÜíP such that
f # 1  idP and 1 # f  idQ. This means that for any p ‚ààP and q ‚ààQ, we have
p  1( f (p))
and
q  f (1(q)).
We refer to 1 as the inverse of f , and vice versa: f is the inverse of 1.
If there is an isomorphism P ‚ÜíQ, we say that P and Q are isomorphic.
An isomorphism between preorders is basically just a relabeling of the elements.

22
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Example 1.76. Here are the Hasse diagrams for three preorders P, Q, and R, all of which
are isomorphic:
P B
e‚Ä¢
d‚Ä¢
c‚Ä¢
b‚Ä¢
a‚Ä¢
Q B
z‚Ä¢
x‚Ä¢
y
‚Ä¢
v‚Ä¢
w‚Ä¢
R B
z‚Ä¢
x‚Ä¢
y
‚Ä¢
v‚Ä¢
w‚Ä¢
The map f : P ‚ÜíQ given by f (a)  v, f (b)  w, f (c)  x, f (d)  y, and f (e)  z has
an inverse.
In fact Q and R are the same preorder. One may be confused by the fact that there
is an arrow x ‚Üíz in the Hasse diagram for R and not one in Q, but in fact this arrow
is superÔ¨Çuous. By the transitivity property of preorders (DeÔ¨Ånition 1.30), since x ‚â§y
and y ‚â§z, we must have x ‚â§z, whether it is drawn or not. Similarly, we could have
drawn an arrow v ‚Üíy in either Q or R and it would not have changed the preorder.
Recall the preorder B  {false, true}, where false ‚â§true. As simple as this
preorder is, it is also one of the most important.
Exercise 1.77.
Show that the map Œ¶ from Section 1.1.1, which was roughly given by ‚ÄòIs
‚Ä¢ connected to ‚àó?‚Äô is a monotone map Prt({‚àó, ‚Ä¢, ‚ó¶}) ‚ÜíB; see also Eq. (1.5).
‚ô¶
Proposition 1.78. Let P be a preorder.
Monotone maps P ‚ÜíB are in one-to-one
correspondence with upper sets of P.
Proof. Let f : P ‚ÜíB be a monotone map. We will show that the subset f ‚àí1(true) ‚äÜP
is an upper set. Suppose p ‚ààf ‚àí1(true) and p ‚â§q; then true  f (p) ‚â§f (q). But in
B, if true ‚â§f (q) then true  f (q). This implies q ‚ààf ‚àí1(true) and thus shows that
f ‚àí1(true) is an upper set.
Conversely, if U is an upper set in P, deÔ¨Åne fU : P ‚ÜíB such that fU(p)  true when
p ‚ààU, and fU(p)  false when p < U. This is a monotone map, because if p ‚â§q, then
either p ‚ààU, so q ‚ààU and f (p)  true  f (q), or p < U, so f (p)  false ‚â§f (q).
These two constructions are mutually inverse, and hence prove the proposition.
‚ñ°
Exercise 1.79 (Pullback map).
Let P and Q be preorders, and f : P ‚ÜíQ be a monotone
map. Then we can deÔ¨Åne a monotone map f ‚àó: U(Q) ‚ÜíU(P) sending an upper set
U ‚äÜQ to the upper set f ‚àí1(U) ‚äÜP. We call this the pullback along f .
Viewing upper sets as a monotone maps to B as in Proposition 1.78, the pullback
can be understood in terms of composition. Indeed, show that the f ‚àóis deÔ¨Åned by
taking u : Q ‚ÜíB to ( f # u): P ‚ÜíB.
‚ô¶

1.3. MEETS AND JOINS
23
1.3
Meets and joins
As we have said, a preorder is a set P endowed with an order ‚â§relating the elements.
With respect to this order, certain elements of P may have distinctive characterizations,
either absolutely or in relation to other elements. We have discussed joins before, but
we discuss them again now that we have built up some formalism.
1.3.1
DeÔ¨Ånition and basic examples
Consider the preorder (R, ‚â§) of real numbers ordered in the usual way. The subset
N ‚äÜR has many lower bounds, namely ‚àí1.5 is a lower bound: every element of N is
bigger than ‚àí1.5. But within all lower bounds for N ‚äÜR, one is distinctive: a greatest
lower bound‚Äîalso called a meet‚Äînamely 0. It is a lower bound, and there is no lower
bound for N that is above it. However, the set N ‚äÜR has no upper bound, and certainly
no least upper bound‚Äîwhich would be called a join. On the other hand, the set

1
n + 1
 n ‚ààN



1, 1
2, 1
3, 1
4, . . .

‚äÜR
has both a greatest lower bound (meet), namely 0, and a least upper bound (join),
namely 1.
These notions will have correlates in category theory, called limits and colimits,
which we will discuss in Chapter 3. More generally, we say these distinctive character-
izations are universal properties, since, for example, a greatest lower bound is greatest
among all lower bounds. For now, however, we simply want to make the deÔ¨Ånition of
greatest lower bounds and least upper bounds, called meets and joins, precise.
Exercise 1.80.
1. Why is 0 a lower bound for {
1
n+1 | n ‚ààN} ‚äÜR?
2. Why is 0 a greatest lower bound (meet)?
‚ô¶
DeÔ¨Ånition 1.81. Let (P, ‚â§) be a preorder, and let A ‚äÜP be a subset. We say that an
element p ‚ààP is a meet of A if
(a) for all a ‚ààA, we have p ‚â§a, and
(b) for all q such that q ‚â§a for all a ‚ààA, we have that q ‚â§p.
We write p  √ì A, p  √ì
a‚ààA a, or, if the dummy variable a is clear from context, just
p  √ì
A a. If A just consists of two elements, say A  {a, b}, we can denote √ì A simply
by a ‚àßb.
Similarly, we say that p is a join of A if
(a) for all a ‚ààA we have a ‚â§p, and
(b) for all q such that a ‚â§q for all a ‚ààA, we have that p ‚â§q.
We write p  √î A or p  √î
a‚ààA a, or when A  {a, b} we may simply write p  a ‚à®b.

24
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
Remark 1.82. In DeÔ¨Ånition 1.81, we committed a seemingly egregious abuse of notation.
We will see next in Example 1.84 that there could be two diÔ¨Äerent meets of A ‚äÜP, say
p  √ì A and q  √ì A with p , q, which does not make sense if p , q!
But in fact, as we use the symbol √ì A, this abuse won‚Äôt matter because any two
meets p, q are automatically isomorphic: the very deÔ¨Ånition of meet forces both p ‚â§q
and q ‚â§p, and thus we have p  q. So for any x ‚ààP, we have p ‚â§x iÔ¨Äq ‚â§x and
x ‚â§p iÔ¨Äx ‚â§q. Thus as long as we are only interested in elements of P based on their
relationships to other elements (and in category theory, this is the case: we should only
care about things based on how they interact with other things, rather than on some
sort of ‚Äúinternal essence‚Äù), the distinction between p and q will never matter.
This foreshadows a major theme of‚Äîas well as standard abuse of notation in‚Äî
category theory, where any two things deÔ¨Åned by the same universal property are
automatically equivalent in a way known as ‚Äòunique up to unique isomorphism‚Äô; this
means that we generally do not run into trouble if we pretend they are equal. We‚Äôll
pick up this theme of ‚Äòthe‚Äô vs ‚Äòa‚Äô again in Remark 3.85.
Example 1.83 (Meets or joins may not exist). Note that, in an arbitrary preorder (P, ‚â§),
a subset A need not have a meet or a join. Consider the three element set P  {p, q, r}
with the discrete ordering. The set A  {p, q} does not have a join in P because if x
was a join, we would need p ‚â§x and q ‚â§x, and there is no such element x.
Example 1.84 (Multiple meets or joins may exist). It may also be the case that a subset
A has more than one meet or join. Here is an example.
a‚Ä¢
b‚Ä¢
c‚Ä¢
d‚Ä¢
Let A be the subset {a, b} in the preorder speciÔ¨Åed by this Hasse diagram. Then both
c and d are meets of A: any element less than both a and b is also less than c, and also
less than d. Note that, as in Remark 1.82, c ‚â§d and d ‚â§c, so c  d. Such will always
the case when there is more than one meet: any two meets of the same subset will be
isomorphic.
Exercise 1.85.
Let (P, ‚â§) be a preorder and p ‚ààP an element. Consider the set A  {p}
with one element.
1. Show that √ì A  p.
2. Show that if P is in fact a partial order, then √ì A  p.
3. Are the analogous facts true when √ì is replaced by √î?
‚ô¶

1.3. MEETS AND JOINS
25
Example 1.86. In any partial order P, we have p ‚à®p  p ‚àßp  p. The reason is that our
notation says p ‚à®p means √î{p, p}. But {p, p}  {p} (see Section 1.2.1), so p ‚à®p  p by
Exercise 1.85.
Example 1.87. In a power set P(X), the meet of a collection of subsets, say A, B ‚äÜX is
their intersection A ‚àßB  A ‚à©B, while the join is their union, A ‚à®B  A ‚à™B.
A
B
A ‚à®B
A ‚àßB
Perhaps this justiÔ¨Åes the terminology: the joining of two sets is their union, the meeting
of two sets is their intersection.
Example 1.88. In the booleans B  {false, true} (Example 1.34), the meet of any two
elements is given by AND and the join of any two elements is given by OR (recall
Exercise 1.7).
Example 1.89. In a total order, the meet of a set is its inÔ¨Åmum, while the join of a set is
its supremum. Note that B is a total order, and this generalizes Example 1.88.
Exercise 1.90.
Recall the division ordering on N from Example 1.45: we write n|m
if n divides perfectly into m. The meet of any two numbers in this preorder has a
common name, that you may have learned when you were around 10 years old; what
is it? Similarly the join of any two numbers has a common name; what is it?
‚ô¶
Proposition 1.91. Suppose (P, ‚â§) is a preorder and A ‚äÜB ‚äÜP are subsets that have
meets. Then √ì B ‚â§√ì A.
Similarly, if A and B have joins, then √î A ‚â§√î B.
Proof. Let m  √ì A and n  √ì B. Then for any a ‚ààA we also have a ‚ààB, so n ‚â§a
because n is a lower bound for B. Thus n is also a lower bound for A and hence n ‚â§m,
because m is A‚Äôs greatest lower bound. The second claim is proved similarly.
‚ñ°

26
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
1.3.2
Back to observations and generative eÔ¨Äects
In the thesis [Ada17], Adam thinks of monotone maps as observations. A monotone
map Œ¶: P ‚ÜíQ is a phenomenon (we might say ‚Äúfeature‚Äù) of P as observed by Q. He
deÔ¨Ånes the generative eÔ¨Äect of such a map Œ¶ to be its failure to preserve joins (or more
generally, for categories, its failure to preserve colimits).
DeÔ¨Ånition 1.92. We say that a monotone map f : P ‚ÜíQ preserves meets if f (a ‚àßb) 
f (a) ‚àßf (b) for all a, b ‚ààP. We similarly say f preserves joins if f (a ‚à®b)  f (a) ‚à®f (b)
for all a, b ‚ààP.
DeÔ¨Ånition 1.93. We say that a monotone map f : P ‚ÜíQ has a generative eÔ¨Äect if there
exist elements a, b ‚ààP such that
f (a) ‚à®f (b)  f (a ‚à®b).
In DeÔ¨Ånition 1.93, if we think of Œ¶ as a observation or measurement of the systems
a and b, then the left hand side f (a) ‚à®f (b) may be interpreted as the combination of
the observation of a with the observation of b. On the other hand, the right hand side
f (a ‚à®b) is the observation of the combined system a ‚à®b. The inequality implies that
we see something when we observe the combined system that we could not expect
by merely combining our observations of the pieces. That is, that there are generative
eÔ¨Äects from the interconnection of the two systems.
Exercise 1.94. In DeÔ¨Ånition 1.93, we deÔ¨Åned generativity of f as the inequality f (a‚à®b) ,
f (a) ‚à®f (b), but in the subsequent text we seemed to imply there would be not just a
diÔ¨Äerence, but more stuÔ¨Äin f (a ‚à®b) than in f (a) ‚à®f (b).
Prove that for any monotone map f : P ‚ÜíQ, if a, b ‚ààP have a join and f (a), f (b) ‚ààQ
have a join, then indeed f (a) ‚à®f (b) ‚â§f (a ‚à®b).
‚ô¶
In his work on generative eÔ¨Äects, Adam restricts his attention to generative maps
that preserve meets (but do not preserve joins). The preservation of meets implies that
the map Œ¶ behaves well when restricting to subsystems, even though it can throw up
surprises when joining systems.
This discussion naturally leads into Galois connections, which are pairs of monotone
maps between preorders, one of which preserves all joins and the other of which
preserves all meets.
1.4
Galois connections
The preservation of meets and joins, and in particular issues concerning generative
eÔ¨Äects, is tightly related to the theory of Galois connections, which is a special case of a
more general theory we will discuss later, namely that of adjunctions. We will use some
adjunction terminology when describing Galois connections.

1.4. GALOIS CONNECTIONS
27
1.4.1
DeÔ¨Ånition and examples of Galois connections
Galois connections between preorders were Ô¨Årst considered by √âvariste Galois‚Äîwho
didn‚Äôt call them by that name‚Äîin the context of a connection he found between ‚ÄúÔ¨Åeld
extensions‚Äù and ‚Äúautomorphism groups.‚Äù We will not discuss this further, but the idea
is that given two preorders P and Q, a Galois connection is a pair of maps back and
forth‚Äîfrom P to Q and from Q to P‚Äîwith certain properties, which make it like a
relaxed version of isomorphisms. To be a bit more precise, preorder isomorphisms are
examples of Galois connections, but Galois connections need not be preorder isomor-
phisms.
DeÔ¨Ånition 1.95. A Galois connection between preorders P and Q is a pair of monotone
maps f : P ‚ÜíQ and 1 : Q ‚ÜíP such that
f (p) ‚â§q
if and only if
p ‚â§1(q).
(1.96)
We say that f is the left adjoint and 1 is the right adjoint of the Galois connection.
Example 1.97. Consider the map (3√ó‚àí): Z ‚ÜíR which sends x ‚ààZ to 3x, which we can
consider as a real number 3x ‚ààZ ‚äÜR. Let‚Äôs Ô¨Ånd a left adjoint for the map (3 √ó ‚àí).
Write ‚åàz‚åâfor the smallest natural number above z ‚ààR, and write ‚åäz‚åãfor the largest
integer below z ‚ààR, e.g. ‚åà3.14‚åâ 4 and ‚åä3.14‚åã 3.a As the left adjoint R ‚ÜíZ, let‚Äôs see
if ‚åà‚àí/3‚åâworks.
It is easily checked that
‚åàx/3‚åâ‚â§y if and only if x ‚â§3y.
Success! Thus we have a Galois connection between ‚åà‚àí/3‚åâand (3 √ó ‚àí).
aBy ‚Äúabove‚Äù and ‚Äúbelow,‚Äù we mean greater than or equal to or less than or equal to; the latter being a
mouthful. Anyway, ‚åä3‚åã 3  ‚åà3‚åâ.
Exercise 1.98. In Example 1.97 we found a left adjoint for the monotone map (3√ó‚àí): Z ‚Üí
R. Now Ô¨Ånd a right adjoint for the same map, and show it is correct.
‚ô¶
Exercise 1.99.
Consider the preorder P  Q  3.
1. Let f , 1 be the monotone maps shown below:
P
1‚Ä¢
2‚Ä¢
3‚Ä¢
P
Q
‚Ä¢
1
‚Ä¢
2
‚Ä¢
3
Q
f
1
Is it the case that f is left adjoint to 1? Check that for each 1 ‚â§p, q ‚â§3, one has
f (p) ‚â§q iÔ¨Äp ‚â§1(q).

28
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Let f , 1 be the monotone maps shown below:
P
1‚Ä¢
2‚Ä¢
3‚Ä¢
P
Q
‚Ä¢
1
‚Ä¢
2
‚Ä¢
3
Q
f
1
Is it the case that f is left adjoint to 1?
‚ô¶
Remark 1.100. The pictures in Exercise 1.99 suggest the following idea. If P and Q are
total orders and f : P ‚ÜíQ and 1 : Q ‚ÜíP are drawn with arrows bending counter-
clockwise, then f is left adjoint to 1 iÔ¨Äthe arrows do not cross. With a little bit of
thought, this can be formalised. We think this is a pretty neat way of visualizing Galois
connections between total orders!
Exercise 1.101.
1. Does ‚åà‚àí/3‚åâhave a left adjoint L: Z ‚ÜíR?
2. If not, why? If so, does its left adjoint have a left adjoint?
‚ô¶
1.4.2
Back to partitions
Recall from Example 1.52 that we can understand the set Prt(S) of partitions on a set S
in terms of surjective functions out of S.
Suppose we are given any function 1 : S ‚ÜíT. We will show that this function 1
induces a Galois connection 1! : Prt(S) ‚áÜPrt(T) : 1‚àó, between preorder of S-partitions
and the preorder of T-partitions. The way you might explain it to a seasoned category
theorist is:
The left adjoint is given by taking any surjection out of S and pushing out
along 1 to get a surjection out of T. The right adjoint is given by taking any
surjection out of T, composing with 1 to get a function out of S, and then
taking the epi-mono factorization to get a surjection out of S.
S
T
P
P ‚äîS T
1
c
‚åú
S
T
im(1 # c)
P
1
1#c
c
By the end of this book, the reader will understand pushouts and epi-mono factoriza-
tions, so he or she will be able to make sense of the above statement. But for now we
will explain the process in more down-to-earth terms.
Start with 1 : S ‚ÜíT; we Ô¨Årst want to understand 1! : Prt(S) ‚ÜíPrt(T). So start with
a partition ‚àºS of S. To begin the process of obtaining a partition ‚àºT on T, say that two
elements t1, t2 ‚ààT are in the same part, t1 ‚àºT t2, if there exist s1, s2 ‚ààS with such
that s1 ‚àºS s2 and 1(s1)  t1 and 1(s2)  t2. However, the result of doing so will not

1.4. GALOIS CONNECTIONS
29
necessarily be transitive‚Äîyou may get t1 ‚àºT t2 and t2 ‚àºT t3 without t1 ‚àº?
T t3‚Äîand
partitions must be transitive. So complete the process by just adding in the missing
pieces (take the transitive closure). The result is 1!(‚àºS) B‚àºT.
Again starting with 1, we want to get the right adjoint 1‚àó: Prt(T) ‚ÜíPrt(S). So start
with a partition ‚àºT of T. Get a partition ‚àºS on S by saying that s1 ‚àºS s2 iÔ¨Ä1(s1) ‚àºT 1(s2).
The result is 1‚àó(‚àºT) B‚àºS.
Example 1.102. Let S  {1, 2, 3, 4}, T  {12, 3, 4}, and 1 : S ‚ÜíT by 1(1) B 1(2) B 12,
1(3) B 3, and 1(4) B 4. The partition shown left below is translated by 1! to the
partition shown on the right.
1‚Ä¢
2‚Ä¢
3‚Ä¢
4‚Ä¢
partitioned S
3‚Ä¢
4‚Ä¢
12‚Ä¢
T
3‚Ä¢
4‚Ä¢
12‚Ä¢
partitioned T
{
Exercise 1.103.
There are 15 diÔ¨Äerent partitions of a set with four elements. Choose 6
diÔ¨Äerent ones and for each one, call it c : S ‚Ü†P, Ô¨Ånd 1!(c), where S, T, and 1 : S ‚ÜíT
are the same as they were in Example 1.102.
‚ô¶
Example 1.104. Let S, T be as below, and let 1 : S ‚ÜíT be the function shown in blue.
Here is a picture of how 1‚àótakes a partition on T and ‚Äúpulls it back‚Äù to a partition on S:
‚Ä¢
‚Ä¢
11
21
‚Ä¢
‚Ä¢
11
21
‚Ä¢
‚Ä¢
11
21
‚Ä¢
‚Ä¢
12
22
‚Ä¢
‚Ä¢
12
22
‚Ä¢
‚Ä¢
12
22
‚Ä¢
‚Ä¢
13
23
‚Ä¢
‚Ä¢
13
23
‚Ä¢
‚Ä¢
13
23
‚Ä¢
‚Ä¢
14
24
‚Ä¢
‚Ä¢
14
24
S
Partitioned T
{
Partitioned S
Exercise 1.105.
There are Ô¨Åve partitions possible on a set with three elements, say
T  {12, 3, 4}. Using the same S and 1 : S ‚ÜíT as in Example 1.102, determine the
partition 1‚àó(c) on S for each of the Ô¨Åve partitions c : T ‚Ü†P.
‚ô¶
To check that for any function 1 : S ‚ÜíT, the monotone map 1! : Prt(S) ‚ÜíPrt(T)
really is left adjoint to 1‚àó: Prt(T) ‚ÜíPrt(S) would take too much time for this sketch.
But the following exercise gives some evidence.
Exercise 1.106.
Let S, T, and 1 : S ‚ÜíT be as in Example 1.102.
1. Choose a nontrivial partition c : S ‚Ü†P and let 1!(c) be its push forward partition
on T.

30
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Choose any coarser partition d : T ‚Ü†P‚Ä≤, i.e. where 1!(c) ‚â§d.
3. Choose any non-coarser partition e : T ‚Ü†Q, i.e. where 1!(c) ‚â∞e. (If you can‚Äôt do
this, revise your answer for #1.)
4. Find 1‚àó(d) and 1‚àó(e).
5. The adjunction formula Eq. (1.96) in this case says that since 1!(c) ‚â§d and
1!(c) ‚â∞e, we should have c ‚â§1‚àó(d) and c ‚â∞1‚àó(e). Show that this is true.
‚ô¶
1.4.3
Basic theory of Galois connections
Proposition 1.107. Suppose that f : P ‚ÜíQ and 1 : Q ‚ÜíP are monotone maps. The
following are equivalent
(a) f and 1 form a Galois connection where f is left adjoint to 1,
(b) for every p ‚ààP and q ‚ààQ we have
p ‚â§1( f (p))
and
f (1(q)) ‚â§q.
(1.108)
Proof. Suppose f is left adjoint to 1. Take any p ‚ààP, and let q B f (p). By reÔ¨Çexivity,
we have f (p) ‚â§q, so by the DeÔ¨Ånition 1.95 of Galois connection we have p ‚â§1(q), but
this means p ‚â§1( f (p)). The proof that f (1(q)) ‚â§q is similar.
Now suppose that Eq. (1.108) holds for all p ‚ààP and q ‚ààQ. We want show that
f (p) ‚â§q iÔ¨Äp ‚â§1(q). Suppose f (p) ‚â§q; then since 1 is monotonic, 1( f (p)) ‚â§1(q), but
p ‚â§1( f (p)) so p ‚â§1(q). The proof that p ‚â§1(q) implies f (p) ‚â§q is similar.
‚ñ°
Exercise 1.109.
Complete the proof of Proposition 1.107 by showing that
1. if f is left adjoint to 1 then for any q ‚ààQ, we have f (1(q)) ‚â§q, and
2. if Eq. (1.108) holds, then holds p ‚â§1(q) iÔ¨Äf (p) ‚â§q holds, for all p ‚ààP and
q ‚ààQ.
‚ô¶
If we replace ‚â§with  in Eq. (1.108), we get back the deÔ¨Ånition of isomorphism
(DeÔ¨Ånition 1.75); this is why we said at the beginning of Section 1.4.1 that Galois
connections are a kind of relaxed version of isomorphisms.
Exercise 1.110.
1. Show that if f : P ‚ÜíQ has a right adjoint 1, then it is unique up to isomorphism.
That means, for any other right adjoint 1‚Ä≤, we have 1(q)  1‚Ä≤(q) for all q ‚ààQ.
2. Is the same true for left adjoints? That is, if h : P ‚ÜíQ has a left adjoint, is it
necessarily unique up to isomorphism?
‚ô¶

1.4. GALOIS CONNECTIONS
31
Proposition 1.111 (Right adjoints preserve meets). Let f : P ‚ÜíQ be left adjoint to
1 : Q ‚ÜíP. Suppose A ‚äÜQ any subset, and let 1(A) B {1(a) | a ‚ààA} be its image.
Then if A has a meet √ì A ‚ààQ then 1(A) has a meet √ì 1(A) in P, and we have
1
√õ
A


√õ
1(A).
That is, right adjoints preserve meets. Similarly, left adjoints preserve joins: if A ‚äÜP is
any subset that has a join √î A ‚ààP, then f (A) has a join √î f (A) in Q, and we have
f
√ú
A


√ú
f (A).
Proof. Let f : P ‚ÜíQ and 1 : Q ‚ÜíP be adjoint monotone maps, with 1 right adjoint to
f . Let A ‚äÜQ be any subset and let m B √ì A be its meet. Then since 1 is monotone
1(m) ‚â§1(a) for all a ‚ààA, so 1(m) is a lower bound for the set 1(A). We will be done if
we can show 1(m) is a greatest lower bound.
So take any other lower bound b for 1(A); that is suppose that for all a ‚ààA, we have
b ‚â§1(a) and we want to show b ‚â§1(m). Then by deÔ¨Ånition of 1 being a right adjoint
(DeÔ¨Ånition 1.95), we also have f (b) ‚â§a. This means that f (b) is a lower bound for A in
Q. Since the meet m is the greatest lower bound, we have f (b) ‚â§m. Once again using
the Galois connection, b ‚â§1(m), proving that 1(m) is indeed the greatest lower bound
for 1(A), as desired.
The second claim is proved similarly; see Exercise 1.112.
‚ñ°
Exercise 1.112.
Complete the proof of Proposition 1.111 by showing that left adjoints
preserve joins.
‚ô¶
Since left adjoints preserve joins, we know that they cannot have generative eÔ¨Äects.
In fact, we will see in Theorem 1.115 that a monotone map does not have generative
eÔ¨Äects‚Äîi.e. it preserves joins‚Äîif and only if it is a left adjoint to some other monotone.
Example 1.113. Right adjoints need not preserve joins. Here is an example:
1‚Ä¢
2‚Ä¢
3.9‚Ä¢
4‚Ä¢
P B
1‚Ä¢
2‚Ä¢
4‚Ä¢
: Q
1
f
Let 1 be the map that preserves labels, and let f be the map that preserves labels as far
as possible but with f (3.9) B 4. Both are f and 1 monotonic, and one can check that 1

32
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
is right adjoint to f (see Exercise 1.114). But 1 does not preserve joins because 1 ‚à®2  4
holds in Q, whereas 1(1) ‚à®1(2)  1 ‚à®2  3.9 , 4  1(4) in P.
Exercise 1.114.
To be sure that 1 really is right adjoint to f in Example 1.113, there
are twelve tiny things to check; do so. That is, for every p ‚ààP and q ‚ààQ, check that
f (p) ‚â§q iÔ¨Äp ‚â§1(q).
‚ô¶
Theorem 1.115 (Adjoint functor theorem for preorders). Suppose Q is a preorder that
has all meets and let P be any preorder. A monotone map 1 : Q ‚ÜíP preserves meets
if and only if it is a right adjoint.
Similarly, if P has all joins and Q is any preorder, a monotone map f : P ‚ÜíQ
preserves joins if and only if it is a left adjoint.
Proof. We will only prove the claim about meets; the claim about joins follows similarly.
We proved one direction in Proposition 1.111, namely that right adjoints preserve
meets. For the other, suppose that 1 is a monotone map that preserves meets; we shall
construct a left adjoint f . We deÔ¨Åne our candidate f : P ‚ÜíQ on any p ‚ààP by
f (p) B
√õ
{q ‚ààQ | p ‚â§1(q)};
(1.116)
this meet is well deÔ¨Åned because Q has all meets, but for f to really be a candidate, we
need to show it is monotone. So suppose that p ‚â§p‚Ä≤. Then {q‚Ä≤ ‚ààQ | p‚Ä≤ ‚â§1(q‚Ä≤)} ‚äÜ{q ‚àà
Q | p ‚â§1(q)}. By Proposition 1.91, this implies f (p) ‚â§f (p‚Ä≤). Thus f is monotone.
By Proposition 1.111, it suÔ¨Éces to show that p0 ‚â§1( f (p0)) and that f (1(q0)) ‚â§q0
for all p0 ‚ààP and q0 ‚ààQ. For the Ô¨Årst, we have
p0 ‚â§
√õ
{1(q) ‚ààP | p0 ‚â§1(q)}  1
√õ
{q ‚ààQ | p0 ‚â§1(q)}

 1( f (p0)),
where the Ô¨Årst inequality follows from the fact that if p0 is below every element of a
set, then it is below their meet, and the isomorphism is by deÔ¨Ånition of 1 preserving
meets. For the second, we have
f (1(q0)) 
√õ
{q ‚ààQ | 1(q0) ‚â§1(q)} ‚â§
√õ
{q0}  q0,
where the Ô¨Årst inequality follows from Proposition 1.91 since {q0} ‚äÜ{q ‚ààQ | 1(q0) ‚â§
1(q)}, and the fact that √ì{q0}  q0.
‚ñ°
Example 1.117. Let f : A ‚ÜíB be a function between sets. We can imagine A as a set of
apples, B as a set of buckets, and f as putting each apple in a bucket.
Then we have the monotone map f ‚àó: P(Y) ‚ÜíP(X) that category theorists call
‚Äúpullback along f .‚Äù This map takes a subset B‚Ä≤ ‚äÜB to its preimage f ‚àí1(B‚Ä≤) ‚äÜA: that
is, it takes a collection B‚Ä≤ of buckets, and tells you all the apples that they contain in
total. This operation is monotonic (more buckets means more apples) and it has both
a left and a right adjoint.

1.4. GALOIS CONNECTIONS
33
The left adjoint f!(A) is given by the direct image: it maps a subset A‚Ä≤ ‚äÜA to
f!(A‚Ä≤) B {b ‚ààB | there exists a ‚ààA‚Ä≤ such that f (a)  b}
This map takes a set A‚Ä≤ of apples, and tells you all the buckets that contain at least one
of those apples.
The right adjoint f‚àómaps a subset A‚Ä≤ ‚äÜA to
f‚àó(A‚Ä≤) B {b ‚ààB | for all a such that f (a)  b, we have a ‚ààA‚Ä≤}
This map takes a set A‚Ä≤ of apples, and tells you all the buckets b that are all-A‚Ä≤: all the
apples in b are from the chosen subset A‚Ä≤. Note that if a bucket doesn‚Äôt contain any
apples at all, then vacuously all its apples are from A‚Ä≤, so empty buckets count as far
as f‚àóis concerned.
Notice that all three of these operations turn out to be interesting: start with a set
B‚Ä≤ of buckets and return all the apples in them, or start with a set A‚Ä≤ of apples and
either Ô¨Ånd the buckets that contain at least one apple from A‚Ä≤, or the buckets whose
only apples are from A‚Ä≤. But we did not invent these mappings f ‚àó, f!, and f‚àó: they were
induced by the function f . They were automatic. It is one of the pleasures of category
theory that adjoints so often turn out to have interesting semantic interpretations.
Exercise 1.118.
Choose sets X and Y with between two and four elements each, and
choose a function f : X ‚ÜíY.
1. Choose two diÔ¨Äerent subsets B1, B2 ‚äÜY and Ô¨Ånd f ‚àó(B1) and f ‚àó(B2).
2. Choose two diÔ¨Äerent subsets A1, A2 ‚äÜX and Ô¨Ånd f!(A1) and f!(A2).
3. With the same A1, A2 ‚äÜX, Ô¨Ånd f‚àó(A1) and f‚àó(A2).
‚ô¶
1.4.4
Closure operators
Given a Galois connection with f : P ‚ÜíQ left adjoint to 1 : Q ‚ÜíP, we may compose
f and 1 to arrive at a monotone map f # 1 : P ‚ÜíP from preorder P to itself. This
monotone map has the property that p ‚â§( f # 1)(p), and that ( f # 1 # f # 1)(p)  ( f # 1)(p)
for any p ‚ààP. This is an example of a closure operator.8
Exercise 1.119.
Suppose that f is left adjoint to 1. Use Proposition 1.107 to show the
following.
1. p ‚â§( f # 1)(p).
2. ( f # 1 # f # 1)(p)  ( f # 1)(p). To prove this, show inequalities in both directions,
‚â§and ‚â•.
‚ô¶
DeÔ¨Ånition 1.120. A closure operator j : P ‚ÜíP on a preorder P is a monotone map such
that for all p ‚ààP we have
8The other composite 1 # f satisÔ¨Åes the dual properties: (1 # f )(q) ‚â§q and (1 # f # 1 # f )(q)  (1 # f )(q)
for all q ‚ààQ. This is called an interior operator, though we will not discuss this concept further.

34
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
(a) p ‚â§j(p);
(b) j(j(p))  j(p).
Example 1.121. Here is an example of closure operators from computation, very roughly
presented. Imagine computation as a process of rewriting input expressions to output
expressions. For example, a computer can rewrite the expression 7+2+3 as the expres-
sion 12. The set of arithmetic expressions has a partial order according to whether one
expression can be rewritten as another.
We might think of a computer program, then, as a method of taking an expression
and reducing it to another expression. So it is a map j : exp ‚Üíexp. It furthermore is
desirable to require that this computer program is a closure operator. Monotonicity
means that if an expression x can be rewritten into expression y, then the reduction j(x)
can be rewritten into j(y). Moreover, the requirement x ‚â§j(x) implies that j can only
turn one expression into another if doing so is a permissible rewrite. The requirement
j(j(x))  j(x) implies if you try to reduce an expression that has already been reduced,
the computer program leaves it as is. These properties provide useful structure in the
analysis of program semantics.
Example 1.122 (Adjunctions from closure operators). Just as every adjunction gives rise
to a closure operator, from every closure operator we may construct an adjunction.
Let P be a preorder and let j : P ‚ÜíP be a closure operator. We can deÔ¨Åne a preorder
Ô¨Åxj to have elements the Ô¨Åxed points of j; that is,
Ô¨Åxj B {p ‚ààP | j(p)  p}.
This is a subset of P, and inherits an order as a result; hence Ô¨Åxj is a sub-preorder of P.
Note that j(p) is a Ô¨Åxed point for all p ‚ààP, since j(j(p))  j(p).
We deÔ¨Åne an adjunction with left adjoint j : P ‚ÜíÔ¨Åxj sending p to j(p), and right
adjoint 1 : Ô¨Åxj ‚ÜíP simply the inclusion of the sub-preorder.
To see it‚Äôs really an
adjunction, we need to see that for any p ‚ààP and q ‚ààÔ¨Åxj, we have j(p) ‚â§q if and
only if p ‚â§q. Let‚Äôs check it. Since p ‚â§j(p), we have that j(p) ‚â§q implies p ‚â§q by
transitivity. Conversely, since q is a Ô¨Åxed point, p ‚â§q implies j(p) ‚â§j(q)  q.
Example 1.123. Another example of closure operators comes from logic. This will be
discussed in the Ô¨Ånal chapter of the book, in particular Section 7.4.5, but we will give a
quick overview here. In essence, logic is the study of when one formal statement‚Äîor
proposition‚Äîimplies another. For example, if n is prime then n is not a multiple of
6, or if it is raining then the ground is getting wetter. Here ‚Äún is prime‚Äù, ‚Äún is not a
multiple of 6‚Äù, ‚Äúit is raining‚Äù, and ‚Äúthe ground is getting wetter‚Äù are propositions, and

1.4. GALOIS CONNECTIONS
35
we gave two implications.
Take the set of all propositions, and order them by p ‚â§q iÔ¨Äp implies q, denoted
p ‚áíq. Since p ‚áíp and since whenever p ‚áíq and q ‚áír, we also have p ‚áír, this is
indeed a preorder.
A closure operator on it is often called a modal operator. It is a function j from
propositions to propositions, for which p ‚áíj(p) and j(j(p))  j(p). An example of a
j is ‚Äúassuming Bob is in San Diego....‚Äù Think of this as a proposition B; so ‚Äúassuming
Bob is in San Diego, p‚Äù means B ‚áíp. Let‚Äôs see why B ‚áí‚àíis a closure operator.
If ‚Äòp‚Äô is true then ‚Äúassuming Bob is in San Diego, p‚Äù is still true. Suppose that
‚Äúassuming Bob is in San Diego it is the case that, assuming Bob is in San Diego, p‚Äô is
true.‚Äù It follows that ‚Äúassuming Bob is in San Diego, p‚Äù is true. So we have seen, at
least informally, that ‚Äúassuming Bob is in San Diego...‚Äù is a closure operator.
1.4.5
Level shifting
The last thing we want to discuss in this chapter is a phenomenon that happens often
in category theory, something we might informally call ‚Äúlevel-shifting.‚Äù It is easier to
give an example of this than to explain it directly.
Given any set S, there is a set Rel(S) of binary relations on S. An element R ‚ààRel(S)
is formally a subset R ‚äÜS √ó S. The set Rel(S) can be given an order via the subset
relation, R ‚äÜR‚Ä≤, i.e. if whenever R(s1, s2) holds then so does R‚Ä≤(s1, s2).
For example, the Hasse diagram for Rel({1}) is:
¬ú‚Ä¢
{(1,1)}
‚Ä¢
Exercise 1.124.
Draw the Hasse diagram for the preorder Rel({1, 2}) of all binary
relations on the set {1, 2}.
‚ô¶
For any set S, there is also a set Pos(S), consisting of all the preorder relations on S.
In fact there is a preorder structure ‚äëon Pos(S), again given by inclusion: ‚â§is below
‚â§‚Ä≤ (we‚Äôll write ‚â§‚äë‚â§‚Ä≤) if a ‚â§b implies a ‚â§‚Ä≤ b for every a, b ‚ààS. A preorder of preorder
structures? That‚Äôs what we mean by a level shift.
Every preorder relation is‚Äîin particular‚Äîa relation, so we have an inclusion
Pos(S) ‚ÜíRel(S).
This is the right adjoint of a Galois connection.
Its left adjoint
is a monotone map Cl: Rel(S) ‚ÜíPos(S) given by taking any relation R, writing it in
inÔ¨Åx notation using ‚â§, and taking the reÔ¨Çexive and transitive closure, i.e. adding s ‚â§s
for every s and adding s ‚â§u whenever s ‚â§t and t ‚â§u.
Exercise 1.125.
Let S  {1, 2, 3}. Let‚Äôs try to understand the adjunction discussed
above.
1. Come up with any preorder relation ‚â§on S, and deÔ¨Åne U(‚â§) to be the subset
U(‚â§) B {(s1, s2) | s1 ‚â§s2} ‚äÜS √óS, i.e. U(‚â§) is the image of ‚â§under the inclusion
Pos(S) ‚ÜíRel(S), the relation ‚Äòunderlying‚Äô the preorder.

36
CHAPTER 1. GENERATIVE EFFECTS: ORDERS AND ADJUNCTIONS
2. Come up with any two binary relations Q ‚äÜS √ó S and Q‚Ä≤ ‚äÜS √ó S such that
Q ‚äÜU(‚â§) but Q‚Ä≤ Ã∏‚äÜU(‚â§). Note that your choice of Q, Q‚Ä≤ do not have to come
from preorders.
We now want to check that in this case, the closure operation Cl is really left adjoint to
the ‚Äòunderlying relation‚Äô map U.
3. Concretely (without using the assertion that there is some sort of adjunction),
show that Cl(Q) ‚äë‚â§, where ‚äëis the order on Pos(S), deÔ¨Åned immediately above
this exercise.
4. Concretely show that Cl(Q‚Ä≤) @ ‚â§.
‚ô¶
1.5
Summary and further reading
In this Ô¨Årst chapter, we set the stage for category theory by introducing one of the
simplest interesting sorts of example: preorders. From this seemingly simple structure,
a bunch of further structure emerges: monotone maps, meets, joins, and more. In terms
of modeling real world phenomena, we thought of preorders as the states of a system,
and monotone maps as describing a way to use one system to observe another. From
this point of view, generative eÔ¨Äects occur when observations of the whole cannot be
deduced by combining observations of the parts.
In the Ô¨Ånal section we introduced Galois connections.
A Galois connection, or
adjunction, is a pair of maps that are like inverses, but allowed to be more ‚Äúrelaxed‚Äù by
getting the orders involved. Perhaps surprisingly, it turns out adjunctions are closely
related to joins and meets: if a preorder P has all joins, then a monotone map out of P
is a left adjoint if and only if it preserves joins; similarly for meets and right adjoints.
The next two chapters build signiÔ¨Åcantly on this material, but in two diÔ¨Äerent
directions. Chapter 2 adds a new operation on the underlying set: it introduces the
idea of a monoidal structure on preorders. This allows us to construct an element a ‚äób
of a preorder P from any elements a, b ‚ààP, in a way that respects the order. On the
other hand, Chapter 3 adds new structure on the order itself: it introduces the idea
of a morphism, which describes not only whether a ‚â§b, but gives a name f for how
a relates to b. This structure is known as a category. These generalizations are both
fundamental to the story of compositionality, and in Chapter 4 we‚Äôll see them meet in
the concept of a monoidal category. The lessons we have learned in this chapter will
illuminate the more highly-structured generalizations in the chapters to come. Indeed,
it is a useful principle in studying category theory to try to understand concepts Ô¨Årst
in the setting of preorders‚Äîwhere often much of the complexity is stripped away and
one can develop some intuition‚Äîbefore considering the general case.
But perhaps you might be interested in exploring some ideas in this chapter in other
directions. While we won‚Äôt return to them in this book, we learned about generative
eÔ¨Äects from Elie Adam‚Äôs thesis [Ada17], and a much richer treatment of generative

1.5. SUMMARY AND FURTHER READING
37
eÔ¨Äect can be found there. In particular, he discusses abelian categories and cohomology,
providing a way to detect generative eÔ¨Äects in quite a general setting.
Another important application of preorders, monotone maps, and Galois connec-
tions is to the analysis of programming languages. In this setting, preorders describe
the possible states of a computer, and monotone maps describe the action of programs,
or relationships between diÔ¨Äerent ways of modeling computation states. Galois con-
nections are useful for showing how diÔ¨Äerent models may be closely related, and for
transporting program analysis from one framework to another. For more detail on this,
see Chapter 4 of the textbook [NNH99].


Chapter 2
Resource theories:
Monoidal preorders and enrichment
2.1
Getting from a to b
You can‚Äôt make an omelette without breaking an egg. To obtain the things we want
requires resources, and the process of transforming what we have into what we want
is often an intricate one. In this chapter, we will discuss how monoidal preorders can
help us think about this matter.
Consider the following three questions you might ask yourself:
‚Ä¢ Given what I have, is it possible to get what I want?
‚Ä¢ Given what I have, what is the minimum cost to get what I want?
‚Ä¢ Given what I have, what is the set of ways to get what I want?
These questions are about resources‚Äîthose you have and those you want‚Äîbut perhaps
more importantly, they are about moving from have to want: possibility of, cost of, and
ways to.
Such questions come up not only in our lives, but also in science and industry.
In chemistry, one asks whether a certain set of compounds can be transformed into
another set, how much energy such a reaction will require, or what methods exist for
making it happen. In manufacturing, one asks similar questions.
From an external point of view, both a chemist and an industrial Ô¨Årm might be
regarded as store-houses of information on the above subjects. The chemist knows
which compounds she can make given other ones, and how to do so; the Ô¨Årm has
stored knowledge of the same sort. The research work of the chemist and the Ô¨Årm is to
use what they know in order to derive‚Äîor discover‚Äînew knowledge.
This is roughly the Ô¨Årst goal of this chapter: to discuss a formalism for expressing
recipes‚Äîmethods for transforming one set of resources into another‚Äîand for deriving
new recipes from old. The idea here is not complicated, neither in life nor in our
mathematical formalism. The value added then is to simply see how it works, so we
39

40
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
can build on it within the book, and so others can build on it in their own work.
We brieÔ¨Çy discuss the categorical approach to this idea‚Äînamely that of monoidal
preorders‚Äîfor building new recipes from old. The following wiring diagram shows,
assuming one knows how to implement each of the interior boxes, how to implement
the preparation of a lemon meringue pie:
make
lemon
Ô¨Ålling
make
meringue
separate
egg
Ô¨Åll crust
add
meringue
prepare lemon meringue pie
prepared crust
lemon
butter
sugar
egg
sugar
yolk
white
lemon
Ô¨Ålling
unbaked
lemon pie
meringue
unbaked
pie
(2.1)
The wires show resources: we start with prepared crust, lemon, butter, sugar, and egg
resources, and we end up with an unbaked pie resource. We could take this whole
method and combine it with others, e.g. baking the pie:
prepare lemon meringue pie
bake pie
oven
unbaked
pie
baked pie
oven
In the above example we see that resources are not always consumed when they are
used. For example, we use an oven to convert‚Äîor catalyze the transformation of‚Äîan
unbaked pie into a baked pie, and we get the oven back after we are done. It‚Äôs a nice
feature of ovens! To use economic terms, the oven is a ‚Äúmeans of production‚Äù for pies.
String diagrams are important mathematical objects that will come up repeatedly
in this book. They were invented in the mathematical context‚Äîmore speciÔ¨Åcally in the
context of monoidal categories‚Äîby Joyal and Street [JS93], but they have been used
less formally by engineers and scientists in various contexts for a long time.
As we said above, our Ô¨Årst goal in this chapter is to use monoidal preorders, and
the corresponding wiring diagrams, as a formal language for recipes from old. Our
second goal is to discuss something called V-categories for various monoidal preorders
V.

2.2. SYMMETRIC MONOIDAL PREORDERS
41
A V-category is a set of objects, which one may think of as points on a map, where
V somehow ‚Äústructures the question‚Äù of getting from point a to point b. The examples
of monoidal preorders V that we will be most interested in are called Bool and Cost.
Roughly speaking, a Bool-category is a set of points where the question of getting from
point a to point b has a true / false answer. A Cost-category is a set of points where
the question of getting from a to b has an answer d ‚àà[0, ‚àû], a cost.
This story works in more generality than monoidal preorders. Indeed, in Chapter 4
we will discuss something called a monoidal category, a notion which generalizes
monoidal preorders, and we will generalize the deÔ¨Ånition of V-category accordingly.
In this more general setting, V-categories can also address our third question above,
describing methods of getting between points. For example a Set-category is a set of
points where the question of getting from point a to point b has a set of answers
(elements of which might be called methods).
We will begin in Section 2.2 by deÔ¨Åning symmetric monoidal preorders, giving a
few preliminary examples, and discussing wiring diagrams. We then give many more
examples of symmetric monoidal preorders, including both some real-world examples,
in the form of resource theories, and some mathematical examples that will come up
again throughout the book. In Section 2.3 we discuss enrichment and V-categories‚Äî
how a monoidal preorder V can ‚Äústructure the question‚Äù of getting from a to b‚Äîand
then give some important constructions on V-categories (Section 2.4), and analyze them
using a sort of matrix multiplication technique (Section 2.5).
2.2
Symmetric monoidal preorders
In Section 1.2.2 we introduced preorders. The notation for a preorder, namely (X, ‚â§),
refers to two pieces of structure: a set called X and a relation called ‚â§that is reÔ¨Çexive
and transitive.
We want to add to the concept of preorders a way of combining elements in X, an
operation taking two elements and adding or multiplying them together. However,
the operation does not have to literally be addition or multiplication; it only needs to
satisfy some of the properties one expects from them.
2.2.1
DeÔ¨Ånition and Ô¨Årst examples
We begin with a formal deÔ¨Ånition of symmetric monoidal preorders.
DeÔ¨Ånition 2.2. A symmetric monoidal structure on a preorder (X, ‚â§) consists of two
constituents:
(i) an element I ‚ààX, called the monoidal unit, and
(ii) a function ‚äó: X √ó X ‚ÜíX, called the monoidal product.
These constituents must satisfy the following properties, where we write ‚äó(x1, x2) 
x1 ‚äóx2:

42
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
(a) for all x1, x2, y1, y2 ‚ààX, if x1 ‚â§y1 and x2 ‚â§y2, then x1 ‚äóx2 ‚â§y1 ‚äóy2,
(b) for all x ‚ààX, the equations I ‚äóx  x and x ‚äóI  x hold,
(c) for all x, y, z ‚ààX, the equation (x ‚äóy) ‚äóz  x ‚äó(y ‚äóz) holds, and
(d) for all x, y ‚ààX, the equation x ‚äóy  y ‚äóx holds.
We call these conditions monotonicity, unitality, associativity, and symmetry respectively.
A preorder equipped with a symmetric monoidal structure, (X, ‚â§, I, ‚äó), is called a
symmetric monoidal preorder.
Anyone can propose a set X, an order ‚â§on X, an element I in X, and a binary
operation ‚äóon X and ask whether (X, ‚â§, I, ‚äó) is a symmetric monoidal preorder. And
it will indeed be one, as long as it satisÔ¨Åes rules a, b, c, and d of DeÔ¨Ånition 2.2.
Remark 2.3. It is often useful to replace  with  throughout DeÔ¨Ånition 2.2. The result is
a perfectly good notion, called a weak monoidal structure. The reason we chose equality
is that it makes equations look simpler, which we hope aids Ô¨Årst-time readers.
The notation for the monoidal unit and the monoidal product may vary: monoidal
units we have seen include I (as in the deÔ¨Ånition), 0, 1, true, false, {‚àó}, and more.
Monoidal products we have seen include ‚äó(as in the deÔ¨Ånition), +, ‚àó, ‚àß, ‚à®, and √ó. The
preferred notation in a given setting is whatever best helps our brains remember what
we‚Äôre trying to do; the names I and ‚äóare just defaults.
Example 2.4. There is a well-known preorder structure, denoted ‚â§, on the set R of real
numbers; e.g. ‚àí5 ‚â§
‚àö
2. We propose 0 as a monoidal unit and +: R √ó R ‚ÜíR as a
monoidal product. Does (R, ‚â§, 0, +) satisfy the conditions of DeÔ¨Ånition 2.2?
If x1 ‚â§y1 and x2 ‚â§y2, it is true that x1 + x2 ‚â§y1 + y2. It is also true that 0 + x  x
and x + 0  x, that (x + y) + z  x + (y + z), and that x + y  y + x. Thus (R, ‚â§, 0, +)
satisÔ¨Åes the conditions of being a symmetric monoidal preorder.
Exercise 2.5.
Consider again the preorder (R, ‚â§) from Example 2.4. Someone proposes
1 as a monoidal unit and ‚àó(usual multiplication) as a monoidal product. But an expert
walks by and says ‚Äúthat won‚Äôt work.‚Äù Figure out why, or prove the expert wrong!
‚ô¶
Example 2.6. A monoid consists of a set M, a function ‚àó: M √ó M ‚ÜíM called the monoid
multiplication, and an element e ‚ààM called the monoid unit, such that, when you write
‚àó(m, n) as m ‚àón, i.e. using inÔ¨Åx notation, the equations
m ‚àóe  m,
e ‚àóm  m,
(m ‚àón) ‚àóp  m ‚àó(n ‚àóp)
(2.7)
hold for all m, n, p ‚ààM. It is called commutative if also m ‚àón  n ‚àóm.
Every set S determines a discrete preorder DiscS (where m ‚â§n iÔ¨Äm  n; see
Example 1.32), and it is easy to check that if (M, e, ‚àó) is a commutative monoid then
(DiscM, , e, ‚àó) is a symmetric monoidal preorder.

2.2. SYMMETRIC MONOIDAL PREORDERS
43
Exercise 2.8.
We said it was easy to check that if (M, ‚àó, e) is a commutative monoid
then (DiscM, , ‚àó, e) is a symmetric monoidal preorder. Are we telling the truth?
‚ô¶
Example 2.9. Here is a non-example for people who know the game ‚Äústandard poker.‚Äù
Let H be the set of all poker hands, where a hand means a choice of Ô¨Åve cards from the
standard 52-card deck. As an order, put h ‚â§h‚Ä≤ if h‚Ä≤ beats or equals h in poker.
One could propose a monoidal product ‚äó: H √ó H ‚ÜíH by assigning h1 ‚äóh2 to be
‚Äúthe best hand one can form out of the ten cards in h1 and h2.‚Äù If some cards are in
both h1 and h2, just throw the duplicates away. So for example {2‚ô•, 3‚ô•, 4‚ô•, 6‚ô†, 7‚ô†} ‚äó
{2‚ô•, 5‚ô•, 6‚ô•, 6‚ô†, 7‚ô†}  {2‚ô•, 3‚ô•, 4‚ô•, 5‚ô•, 6‚ô•}, because the latter is the best hand you
can make with the former two.
This proposal for a monoidal structure will fail the condition (a) of DeÔ¨Ånition 2.2: it
could be the case that h1 ‚â§i1 and h2 ‚â§i2, and yet not be the case that h1 ‚äóh2 ‚â§i1 ‚äói2.
For example, consider this case:
h1 B {2‚ô•, 3‚ô•, 10‚ô†, J‚ô†, Q‚ô†}
i1 B {4‚ô£, 4‚ô†, 6‚ô•, 6‚ô¶, 10‚ô¶}
h2 B {2‚ô¶, 3‚ô¶, 4‚ô¶, K‚ô†, A‚ô†}
i2 B {5‚ô†, 5‚ô•, 7‚ô•, J‚ô¶, Q‚ô¶}.
Here, h1 ‚â§i1 and h2 ‚â§i2, but h1 ‚äóh2  {10‚ô†, J‚ô†, Q‚ô†, K‚ô†, A‚ô†} is the best possible
hand and beats i1 ‚äói2  {5‚ô†, 5‚ô•, 6‚ô•, 6‚ô¶, Q‚ô¶}.
Subsections 2.2.3 and 2.2.4 are dedicated to examples of symmetric monoidal pre-
orders. Some are aligned with the notion of resource theories, others come from pure
math. When discussing the former, we will use wiring diagrams, so here is a quick
primer.
2.2.2
Introducing wiring diagrams
Wiring diagrams are visual representations for building new relationships from old. In
a preorder without a monoidal structure, the only sort of relationship between objects
is ‚â§, and the only way you build a new ‚â§relationship from old ones is by chaining
them together. We denote the relationship x ‚â§y by
‚â§
x
y
(2.10)
We can chain some number of these ‚â§-relationships‚Äîsay 0, 1, 2, or 3 of them‚Äîtogether
in series as shown here
‚â§
x0
‚â§
x0
x1
‚â§
‚â§
x0
x1
x2
‚â§
‚â§
‚â§
x0
x1
x2
x3
¬∑ ¬∑ ¬∑
(2.11)

44
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
If we add a symmetric monoidal structure, we can combine relationships not only
in series but also in parallel. Here is an example:
‚â§
‚â§
‚â§
t
u
v
w
x
y
z
(2.12)
DiÔ¨Äerent styles of wiring diagrams
In fact, we will see later that there are many styles
of wiring diagrams. When we are dealing with preorders, the sort of wiring diagram
we can draw is that with single-input, single-output boxes connected in series. When
we are dealing with symmetric monoidal preorders, we can have more complex boxes
and more complex wiring diagrams, including parallel composition. Later we will see
that for other sorts of categorical structures, there are other styles of wiring diagrams:
(2.13)
Wiring diagrams for symmetric monoidal preorders
The style of wiring diagram
that makes sense in any symmetric monoidal preorder is that shown in Eq. (2.12): boxes
can have multiple inputs and outputs, and they may be arranged in series and parallel.
Symmetric monoidal preorders and their wiring diagrams are tightly coupled with
each other. How so?
The answer is that a monoidal preorder (X, ‚â§, I, ‚äó) has some notion of element
(x ‚ààX), relationship (‚â§), and combination (using transitivity and ‚äó), and so do wiring
diagrams: the wires represent elements, the boxes represent relationships, and the
wiring diagrams themselves show how relationships can be combined. We call boxes
and wires icons; we will encounter several more icons in this chapter, and throughout
the book.
To get a bit more rigorous about the connection, let‚Äôs start with a monoidal preorder
(X, ‚â§, I, ‚äó) as in DeÔ¨Ånition 2.2. Wiring diagrams have wires on the left and the right.
Each element x ‚ààX can be made the label of a wire. Note that given two objects x, y,
we can either draw two wires in parallel‚Äîone labeled x and one labeled y‚Äîor we can
draw one wire labeled x ‚äóy.
x
y
x ‚äóy
We consider wires in parallel to represent the monoidal product of their labels, so we
consider both cases above to represent the element x ‚äóy. Note also that a wire labeled

2.2. SYMMETRIC MONOIDAL PREORDERS
45
I or an absence of wires:
I
nothing
both represent the monoidal unit I; another way of thinking of this is that the unit is
the empty monoidal product.
A wiring diagram runs between a set of parallel wires on the left and a set of parallel
wires on the right. We say that a wiring diagram is valid if the monoidal product of
the elements on the left is less than the monoidal product of those on the right. For
example, if we have the inequality x ‚â§y, the the diagram that is a box with a wire
labeled x on the left and a wire labeled y on the right is valid; see the Ô¨Årst box below:
‚â§
x
y
‚â§
x1
x2
y1
y2
y3
The validity of the second box corresponds to the inequality x1 ‚äóx2 ‚â§y1 ‚äóy2 ‚äóy3.
Before going on to the properties from DeÔ¨Ånition 2.2, let us pause for an example of
what we‚Äôve discussed so far.
Example 2.14. Recall the symmetric monoidal preorder (R, ‚â§, 0, +) from Example 2.4.
The wiring diagrams for it allow wires labeled by real numbers. Drawing wires in
parallel corresponds to adding their labels, and the wire labeled 0 is equivalent to no
wires at all.
3.14
‚àí1
3.14
‚àí1
=
2.14
0
=
nothing
And here we express a couple facts about (R, ‚â§, 0, +) in this language: 4 ‚â§7 and
2 + 5 ‚â§‚àí1 + 5 + 3.
‚â§
4
7
‚â§
2
5
‚àí1
5
3
We now return to how the properties of symmetric monoidal preorders correspond
to properties of this sort of wiring diagram. Let‚Äôs Ô¨Årst talk about the order structure:
conditions (a)‚ÄîreÔ¨Çexivity‚Äîand (b)‚Äîtransitivity‚Äîfrom DeÔ¨Ånition 1.30. ReÔ¨Çexivity
says that x ‚â§x, this means the diagram just consisting of a wire
x
is always valid. Transitivity allows us to connect facts together: it says that if x ‚â§y
and y ‚â§z, then x ‚â§z. This means that if the diagrams
‚â§
x
y
and
‚â§
y
z

46
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
are valid, we can put them together and obtain the valid diagram
‚â§
x
‚â§
y
z
Next let‚Äôs talk about the properties(a)‚Äì(d)fromthedeÔ¨Ånitionofsymmetricmonoidal
structure (DeÔ¨Ånition 2.2). Property (a) says that if x1 ‚â§y1 and x2 ‚â§y2 then x1 ‚äóx2 ‚â§
y1 ‚äóy2. This corresponds to the idea that stacking any two valid boxes in parallel is
still valid:
‚â§
‚â§
‚â§
{
x1
x2
y1
y2
x1
x2
y1
y2
Condition (b), that I ‚äóx  x and x ‚äóI  x, says we don‚Äôt need to worry about I or
blank space; in particular diagrams such as the following are valid:
x
nothing
x
Condition (c), that (x ‚äóy) ‚äóz  x ‚äó(y ‚äóz) says that we don‚Äôt have to worry about
whether we build up diagrams from the top or from the bottom
x
y
=
x ‚äóy
z
=
x
y ‚äóz
=
y
z
But this looks much harder than it is: the associative property should be thought of as
saying that there is no distinction between the stuÔ¨Äon the very left above and the stuÔ¨Ä
on the very right, i.e.
x
y
z
=
x
y
z
and indeed a diagram that moves from one to the other is valid.
Finally, the symmetry condition (d), that x ‚äóy  y ‚äóx, says that a diagram is valid
even if its wires cross:
x
y
y
x
y
x
x
y
One may regard the pair of crossing wires as another icon in our iconography, in
addition to the boxes and wires we already have.

2.2. SYMMETRIC MONOIDAL PREORDERS
47
Wiring diagrams as graphical proofs
Given a monoidal preorder X  (X, ‚â§, I, ‚äó), a
wiring diagram is a graphical proof of something about X. Each box in the diagram
has a left side and a right side, say x and y, and represents the assertion that x ‚â§y.
‚â§
x
y
A wiring diagram is a bunch of interior boxes connected together inside an exterior
box. It represents a graphical proof that says: if all of the interior assertions are correct,
then so is the exterior assertion.
‚â§
‚â§
‚â§
t
u
v
w
x
y
z
(2.15)
The inner boxes in Eq. (2.15) translate into the assertions:
t ‚â§v + w
w + u ‚â§x + z
v + x ‚â§y
(2.16)
and the outer box translates into the assertion:
t + u ‚â§y + z.
(2.17)
The whole wiring diagram 2.15 says ‚Äúif you know that the assertions in 2.16 are true,
then I am a proof that the assertion in 2.17 is also true.‚Äù What exactly is the proof that
diagram 2.15 represents? It is the proof
t + u ‚â§v + w + u ‚â§v + x + z ‚â§y + z.
(2.18)
Indeed, each inequality here is a vertical slice of the diagram 2.15, and the transitivity
of these inequalities is expressed by connecting these vertical slices together.
Example 2.19. Recall the lemon meringue pie wiring diagram from Eq. (2.1). It has Ô¨Åve
interior boxes, such as ‚Äúseparate egg‚Äù and ‚ÄúÔ¨Åll crust,‚Äù and it has one exterior box called
‚Äúprepare lemon meringue pie.‚Äù Each box is the assertion that, given the collection of
resources on the left, say an egg, you can transform it into the collection of resources on
the right, say an egg white and an egg yolk. The whole string diagram is a proof that
if each of the interior assertions is true‚Äîi.e. you really do know how to separate eggs,
make lemon Ô¨Ålling, make meringue, Ô¨Åll crust, and add meringue‚Äîthen the exterior
assertion is true: you can prepare a lemon meringue pie.
Exercise 2.20.
The string of inequalities in Eq. (2.18) is not quite a proof, because
technically there is no such thing as v + w + u, for example. Instead, there is (v + w) + u
and v + (w + u), and so on.

48
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
1. Formally prove, using only the rules of symmetric monoidal preorders (DeÔ¨Å-
nition 2.2), that given the assertions in Eq. (2.16), the conclusion in Eq. (2.17)
follows.
2. ReÔ¨Çexivity and transitivity should show up in your proof. Make sure you are
explicit about where they do.
3. How can you look at the wiring diagram Eq. (2.12) and know that the symmetry
axiom (DeÔ¨Ånition 2.2(d)) does not need to be invoked?
‚ô¶
We next discuss some examples of symmetric monoidal preorders. We begin in
Section 2.2.3 with some more concrete examples, from science, commerce, and infor-
matics. Then in Section 2.2.4 we discuss some examples arising from pure math, some
of which will get a good deal of use later on, e.g. in Chapter 4.
2.2.3
Applied examples
Resource theories are studies of how resources are exchanged in a given arena. For
example, in social resource theory one studies a marketplace where combinations of
goods can be traded for‚Äîas well as converted into‚Äîother combinations of goods.
Whereas marketplaces are very dynamic, and an apple might be tradable for an
orange on Sunday but not on Monday, what we mean by resource theory in this
chapter is a static notion: deciding ‚Äúwhat buys what,‚Äù once and for all.1 This sort of
static notion of conversion might occur in chemistry: the chemical reactions that are
possible one day will quite likely be possible on a diÔ¨Äerent day as well. Manufacturing
may be somewhere in between: the set of production techniques‚Äîwhereby a company
can convert one set of resources into another‚Äîdo not change much from day to day.
We learned about resource theories from [CFS16; Fri17], who go much further than
we will; see Section 2.6 for more information. In this section we will focus only on
the main idea. While there are many beautiful mathematical examples of symmetric
monoidal preorders, as we will see in Section 2.2.4, there are also ad hoc examples
coming from life experience. In the next chapter, on databases, we will see the same
theme: while there are some beautiful mathematical categories out there, database
schemas are ad hoc organizational patterns of information. Describing something as
‚Äúad hoc‚Äù is often considered derogatory, but it just means ‚Äúformed, arranged, or done
for a particular purpose only.‚Äù There is nothing wrong with doing things for a particular
purpose; it‚Äôs common outside of pure math and pure art. Let‚Äôs get to it.
Chemistry
In high school chemistry, we work with chemical equations, where mate-
rial collections such as
H2O,
NaCl,
2NaOH,
CH4 + 3O2
1Using some sort of temporal theory, e.g. the one presented in Chapter 7, one could take the notion
here and have it change in time.

2.2. SYMMETRIC MONOIDAL PREORDERS
49
are put together in the form of reaction equations, such as
2H2O + 2Na ‚Üí2NaOH + H2.
The collection on the left, 2H2O + 2Na is called the reactant, and the collection on the
right, 2NaOH + H2 is called the product.
We can consider reaction equations such as the one above as taking place inside a
single symmetric monoidal preorder (Mat, ‚Üí, 0, +). Here Mat is the set of all collections
of atoms and molecules, sometimes called materials.
So we have NaCl ‚ààMat and
4H2O + 6Ne ‚ààMat.
The set Mat has a preorder structure denoted by the ‚Üísymbol, which is the
preferred symbol in the setting of chemistry. To be clear, ‚Üíis taking the place of
the order relation ‚â§from DeÔ¨Ånition 2.2. The + symbol is the preferred notation for
the monoidal product in the chemistry setting, taking the place of ‚äó. While it does not
come up in practice, we use 0 to denote the monoidal unit.
Exercise 2.21.
Here is an exercise for people familiar with reaction equations: check
that conditions (a), (b), (c), and (d) of DeÔ¨Ånition 2.2 hold.
‚ô¶
An important notion in chemistry is that of catalysis: one compound catalyzes a
certain reaction. For example, one might have the following set of reactions:
y + k ‚Üíy‚Ä≤ + k‚Ä≤
x + y‚Ä≤ ‚Üíz‚Ä≤
z‚Ä≤ + k‚Ä≤ ‚Üíz + k
(2.22)
Using the laws of monoidal preorders, we obtain the composed reaction
x + y + k ‚Üíx + y‚Ä≤ + k‚Ä≤ ‚Üíz‚Ä≤ + k‚Ä≤ ‚Üíz + k.
(2.23)
Here k is the catalyst because it is found both in the reactant and the product of the
reaction. It is said to catalyze the reaction x + y ‚Üíz. The idea is that the reaction
x+ y ‚Üíz cannot take place given the reactions in Eq. (2.22). But if k is present, meaning
if we add k to both sides, the resulting reaction can take place.
The wiring diagram for the reaction in Eq. (2.23) is shown in Eq. (2.24). The three
interior boxes correspond to the three reactions given in Eq. (2.22), and the exterior box
corresponds to the composite reaction x + y + k ‚Üíz + k.
‚Üí
‚Üí
‚Üí
y
k
x
y‚Ä≤
k‚Ä≤
z‚Ä≤
z
k
(2.24)
Manufacturing
Whether we are talking about baking pies, building smart phones,
or following pharmaceutical recipes, manufacturing Ô¨Årms need to store basic recipes,
and build new recipes by combining simpler recipes in schemes like the one shown in
Eq. (2.1) or Eq. (2.24).

50
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
The basic idea in manufacturing is exactly the same as that for chemistry, except
there is an important assumption we can make in manufacturing that does not hold
for chemical reactions:
You can trash anything you want, and it disappears from view.
This simple assumption has caused the world some signiÔ¨Åcant problems, but it is still
in eÔ¨Äect. In our meringue pie example, we can ask: ‚Äúwhat happened to the egg shell, or
the paper wrapping the stick of butter‚Äù? The answer is they were trashed, i.e. thrown
in the garbage bin. It would certainly clutter our diagram and our thinking if we had
to carry these resources through the diagram:
make
lemon
Ô¨Ålling
make
meringue
separate
egg
Ô¨Åll crust
add
meringue
prepare lemon meringue pie, keeping track of waste
crust
lemon
butter
sugar
egg
sugar
yolk
egg shells
white
lemon
Ô¨Ålling
lemon peel
butter wrapper
unbaked
lemon pie
meringue
unbaked
pie
Instead, in our daily lives and in manufacturing, we do not have to hold on to
something if we don‚Äôt need it; we can just discard it. In terms of wiring diagrams, this
can be shown using a new icon
, as follows:
‚Ä¢
discard
(2.25)
To model this concept of waste using monoidal categories, one just adds an addi-
tional axiom to (a), (b), (c), and (d) from DeÔ¨Ånition 2.2:
(e) x ‚â§I for all x ‚ààX.
(discard axiom)
It says that every x can be converted into the monoidal unit I. In the notation of the
chemistry section, we would write instead x ‚Üí0: any x yields nothing. But this is
certainly not accepted in the chemistry setting. For example,
H2O + NaCl ‚Üí? H2O

2.2. SYMMETRIC MONOIDAL PREORDERS
51
is certainly not a legal chemical equation. It is easy to throw things away in manufac-
turing, because we assume that we have access to‚Äîthe ability to grab onto and directly
manipulate‚Äîeach item produced. In chemistry, when you have 1023 of substance A
dissolved in something else, you cannot just simply discard A. So axiom (e) is valid in
manufacturing but not in chemistry.
Recall that in Section 2.2.2 we said that there were many diÔ¨Äerent styles of wiring
diagrams. Now we‚Äôre saying that adding the discard axiom changes the wiring diagram
style, in that it adds this new discard icon that allows wires to terminate, as shown in
Eq. (2.25). In informatics, we will change the wiring diagram style yet again.
Informatics
A major diÔ¨Äerence between information and a physical object is that
information can be copied. Whereas one cup of butter never becomes two, it is easy for
a single email to be sent to two diÔ¨Äerent people. It is much easier to copy a music Ô¨Åle
than it is to copy a CD. Here we do not mean ‚Äúcopy the information from one compact
disc onto another‚Äù‚Äîof course that‚Äôs easy‚Äîinstead, we mean that it‚Äôs quite diÔ¨Écult
to copy the physical disc, thereby forming a second physical disc! In diagrams, the
distinction is between the relation
copy cd
Beyonc√© cd
blank cd
Beyonc√© cd
Beyonc√© cd
and the relation
no, I mean
literally copy cd!
Beyonc√© cd
Beyonc√© cd
Beyonc√© cd
The former is possible, the latter is magic.
Of course material objects can sometimes be copied; cell mitosis is a case in point.
But this is a remarkable biological process, certainly not something that is expected
for ordinary material objects. In the physical world, we would make mitosis a box
transforming one cell into two. But in (classical, not quantum) information, everything
can be copied, so we add a new icon to our repertoire.
Namely, in wiring diagram notation, copying information appears as a new icon,
, allowing us to split wires:
write
‚Ä¢
calendar
maps
email
email
email

52
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Now with two copies of the email, we can send one to Alice and one to Bob.
write
‚Ä¢
send to Alice
send to Bob
calendar
maps
email
email
email
email sent to Alice
email sent to Bob
(2.26)
Information can also be discarded, at least in the conventional way of thinking, so
in addition to axioms (a) to (d) from DeÔ¨Ånition 2.2, we can keep axiom (e) from page 50
and add a new copy axiom:
(f) x ‚â§x + x for all x ‚ààX.
(copy axiom)
allowing us to make mathematical sense of diagrams like Eq. (2.26).
Now that we have examples of monoidal preorders under our belts, let‚Äôs discuss
some nice mathematical examples.
2.2.4
Abstract examples
In this section we discuss several mathematical examples of symmetric monoidal struc-
tures on preorders.
The Booleans
The simplest nontrivial preorder is the booleans: B  {true, false}
with false ‚â§true. There are two diÔ¨Äerent symmetric monoidal structures on it.
Example 2.27 (Booleans with AND). We can deÔ¨Åne a monoidal structure on B by letting
the monoidal unit be true and the monoidal product be ‚àß(AND). If one thinks of
false  0 and true  1, then ‚àßcorresponds to the usual multiplication operation ‚àó.
That is, with this correspondence, the two tables below match up:
‚àß
false
true
false
false
false
true
false
true
‚àó
0
1
0
0
0
1
0
1
(2.28)
One can check that all the properties in DeÔ¨Ånition 2.2 hold, so we have a monoidal
preorder which we denote Bool B (B, ‚â§, true, ‚àß).
Bool will be important when we get to the notion of enrichment. Enriching in a
monoidal preorder V  (V, ‚â§, I, ‚äó) means ‚Äúletting V structure the question of getting
from a to b.‚Äù All of the structures of a monoidal preorder‚Äîi.e. the set V, the ordering
relation ‚â§, the monoidal unit I, and the monoidal product ‚äó‚Äîplay a role in how
enrichment works.

2.2. SYMMETRIC MONOIDAL PREORDERS
53
For example, let‚Äôs look at the case of Bool  (B, ‚â§, true, ‚àß).
The fact that its
underlying set is B  {false, true} will translate into saying that ‚Äúgetting from a to b
is a true/false question.‚Äù The fact that true is the monoidal unit will translate into
saying ‚Äúyou can always get from a to a.‚Äù The fact that ‚àßis the monoidal product will
translate into saying ‚Äúif you can get from a to b AND you can get from b to c then you
can get from a to c.‚Äù Finally, the ‚Äúif-then‚Äù form of the previous sentence is coming from
the order relation ‚â§. We will make this more precise in Section 2.3.
We will be able to play the same game with other monoidal preorders, as we will
see after we deÔ¨Åne a monoidal preorder called Cost in Example 2.37.
Some other monoidal preorders
It is a bit imprecise to call Bool ‚Äúthe‚Äù boolean
monoidal preorder, because there is another monoidal structure on (B, ‚â§), which we
describe in Exercise 2.29. The Ô¨Årst structure, however, seems to be more useful in
practice than the second.
Exercise 2.29.
Let (B, ‚â§) be as above, but now consider the monoidal product to be ‚à®
(OR).
‚à®
false
true
false
false
true
true
true
true
max
0
1
0
0
1
1
1
1
What must the monoidal unit be in order to satisfy the conditions of DeÔ¨Ånition 2.2?
Does it satisfy the rest of the conditions?
‚ô¶
In Example 2.30 and Exercise 2.31 we give two diÔ¨Äerent monoidal structures on the
preorder (N, ‚â§) of natural numbers, where ‚â§is the usual ordering (0 ‚â§1 and 5 ‚â§16).
Example 2.30 (Natural numbers with addition). There is a monoidal structure on (N, ‚â§)
where the monoidal unit is 0 and the monoidal product is +, i.e. 6 + 4  10. It is easy
to check that x1 ‚â§y1 and x2 ‚â§y2 implies x1 + x2 ‚â§y1 + y2, as well as all the other
conditions of DeÔ¨Ånition 2.2.
Exercise 2.31.
Show there is a monoidal structure on (N, ‚â§) where the monoidal
product is ‚àó, i.e. 6 ‚àó4  24. What should the monoidal unit be?
‚ô¶
Example 2.32 (Divisibility and multiplication). Recall from Example 1.45 that there is
a ‚Äúdivisibility‚Äù order on N: we write m|n to mean that m divides into n without
remainder. So 1|m for all m and 4|12.
There is a monoidal structure on (N, | ), where the monoidal unit is 1 and the
monoidal product is ‚àó, i.e. 6 ‚àó4  24. Then if x1|y1 and x2|y2, then (x1 ‚àóx2)|(y1 ‚àóy2).
Indeed, if there is some p1, p2 ‚ààN such that x1 ‚àóp1  y1 and x2 ‚àóp2  y2, then
(p1 ‚àóp2) ‚àó(x1 ‚àóx2)  y1 ‚àóy2.

54
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Exercise 2.33.
Again taking the divisibility order (N, | ). Someone proposes 0 as the
monoidal unit and + as the monoidal product. Does that proposal satisfy the conditions
of DeÔ¨Ånition 2.2? Why or why not?
‚ô¶
Exercise 2.34.
Consider the preorder (P, ‚â§) with Hasse diagram no ‚Üímaybe ‚Üíyes .
We propose a monoidal structure with yes as the monoidal unit and ‚Äúmin‚Äù as the
monoidal product.
1. Make sense of ‚Äúmin‚Äù by Ô¨Ålling in the multiplication table with elements of P.
min
no
maybe
yes
no
?
?
?
maybe
?
?
?
yes
?
?
?
2. Check the axioms of DeÔ¨Ånition 2.2 hold for NMY B (P, ‚â§, yes, min), given your
deÔ¨Ånition of min. If not, change your deÔ¨Ånition of min.
‚ô¶
Exercise 2.35.
Let S be a set and let P(S) be its power set, the set of all subsets of
S, including the empty subset, ¬ú ‚äÜS, and the ‚Äúeverything‚Äù subset, S ‚äÜS. We can
give P(S) an order: A ‚â§B is given by the subset relation A ‚äÜB, as discussed in
Example 1.50. We propose a symmetric monoidal structure on P(S) with monoidal
unit S and monoidal product given by intersection A ‚à©B.
Does it satisfy the conditions of DeÔ¨Ånition 2.2?
‚ô¶
Exercise 2.36.
Let PropN denote the set of all mathematical statements one can make
about a natural number, where we consider two statements to be the same if one is true
if and only if the other is true. For example ‚Äún is prime‚Äù is an element of PropN, and so
are ‚Äún  2‚Äù and ‚Äún ‚â•11.‚Äù The statements ‚Äún + 2  5‚Äù and ‚Äún is the least odd prime‚Äù
are considered the same. Given P, Q ‚ààPropN, we say P ‚â§Q if for all n ‚ààN, whenever
P(n) is true, so is Q(n).
DeÔ¨Åne a monoidal unit and a monoidal product on PropN that satisfy the conditions
of DeÔ¨Ånition 2.2.
‚ô¶
The monoidal preorder Cost
As we said above, when we enrich in monoidal pre-
orders we see them as diÔ¨Äerent ways to structure the question of ‚Äúgetting from here
to there.‚Äù We will explain this in more detail in Section 2.3. The following monoidal
preorder will eventually structure a notion of distance or cost for getting from here to
there.
Example 2.37 (Lawvere‚Äôs monoidal preorder, Cost). Let [0, ‚àû] denote the set of non-
negative real numbers‚Äîsuch as 0, 1, 15.333, and 2œÄ‚Äîtogether with ‚àû. Consider the
preorder ([0, ‚àû], ‚â•), with the usual notion of ‚â•, where of course ‚àû‚â•x for all x ‚àà[0, ‚àû].
There is a monoidal structure on this preorder, where the monoidal unit is 0 and
the monoidal product is +. In particular, x + ‚àû ‚àûfor any x ‚àà[0, ‚àû]. Let‚Äôs call this

2.2. SYMMETRIC MONOIDAL PREORDERS
55
monoidal preorder
Cost B ([0, ‚àû], ‚â•, 0, +),
because we can think of the elements of [0, ‚àû] as costs. In terms of structuring ‚Äúgetting
from here to there,‚Äù Cost seems to say ‚Äúgetting from a to b is a question of cost.‚Äù The
monoidal unit being 0 will translate into saying that you can always get from a to a at
no cost. The monoidal product being + will translate into saying that the cost of getting
from a to c is at most the cost of getting from a to b plus the cost of getting from b to c.
Finally, the ‚Äúat most‚Äù in the previous sentence is coming from the ‚â•.
The opposite of a monoidal preorder
One can take the opposite of any preorder, just
Ô¨Çip the order: (X, ‚â§)op B (X, ‚â•); see Example 1.58. Proposition 2.38 says that if the
preorder had a symmetric monoidal structure, so does its opposite.
Proposition 2.38. Suppose X  (X, ‚â§) is a preorder and Xop  (X, ‚â•) is its opposite. If
(X, ‚â§, I, ‚äó) is a symmetric monoidal preorder then so is its opposite, (X, ‚â•, I, ‚äó).
Proof. Let‚Äôs Ô¨Årst check monotonicity. Suppose x1 ‚â•y1 and x2 ‚â•y2 in Xop; we need to
show that x1 ‚äóx2 ‚â•y1 ‚äóy2. But by deÔ¨Ånition of opposite order, we have y1 ‚â§x1 and
y2 ‚â§x2 in X, and thus y1 ‚äóy2 ‚â§x1 ‚äóx2 in X. Thus indeed x1 ‚äóx2 ‚â•y1 ‚äóy2 in Xop.
The other three conditions are even easier; see Exercise 2.39.
‚ñ°
Exercise 2.39.
Complete the proof of Proposition 2.38 by proving that the three re-
maining conditions of DeÔ¨Ånition 2.2 are satisÔ¨Åed.
‚ô¶
Exercise 2.40.
Since Cost is a symmetric monoidal preorder, Proposition 2.38 says that
Costop is too.
1. What is Costop as a preorder?
2. What is its monoidal unit?
3. What is its monoidal product?
‚ô¶
2.2.5
Monoidal monotone maps
Recall from Example 1.49 that for any preorder (X, ‚â§), there is an induced equivalence
relation  on X, where x  x‚Ä≤ iÔ¨Äboth x ‚â§x‚Ä≤ and x‚Ä≤ ‚â§x.
DeÔ¨Ånition 2.41. Let P  (P, ‚â§P, IP, ‚äóP) and Q  (Q, ‚â§Q, IQ, ‚äóQ) be monoidal preorders.
A monoidal monotone from P to Q is a monotone map f : (P, ‚â§P) ‚Üí(Q, ‚â§Q), satisfying
two conditions:
(a) IQ ‚â§Q f (IP), and
(b) f (p1) ‚äóQ f (p2) ‚â§Q f (p1 ‚äóP p2)
for all p1, p2 ‚ààP.
There are strengthenings of these conditions that are also important. If f satisÔ¨Åes
the following conditions, it is called a strong monoidal monotone:

56
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
(a‚Äô) IQ  f (IP), and
(b‚Äô) f (p1) ‚äóQ f (p2)  f (p1 ‚äóP p2);
and if it satisÔ¨Åes the following conditions it is called a strict monoidal monotone:
(a‚Äù) IQ  f (IP), and
(b‚Äù) f (p1) ‚äóQ f (p2)  f (p1 ‚äóP p2).
Monoidal monotones are examples of monoidal functors, which we will see various
incarnations of throughout the book; see DeÔ¨Ånition 6.68.
What we call monoidal
monotones could also be called lax monoidal monotones, and there is a dual notion of
oplax monoidal monotones, where the inequalities in (a) and (b) are reversed; we will not
use oplaxity in this book.
Example 2.42. There is a monoidal monotone i : (N, ‚â§, 0, +) ‚Üí(R, ‚â§, 0, +), where i(n) 
n for all n ‚ààN. It is clearly monotonic, m ‚â§n implies i(m) ‚â§i(n). It is even strict
monoidal because i(0)  0 and i(m + n)  i(m) + i(n).
There is also a monoidal monotone f : (R, ‚â§, 0, +) ‚Üí(N, ‚â§, 0, +) going the other
way. Here f (x) B ‚åäx‚åãis the Ô¨Çoor function, e.g. f (3.14)  3. It is monotonic because
x ‚â§y implies f (x) ‚â§f (y). Also f (0)  0 and f (x)+ f (y) ‚â§f (x + y), so it is a monoidal
monotone. But it is not strict or even strong because f (0.5) + f (0.5) , f (0.5 + 0.5).
Recall Bool  (B, ‚â§, true, ‚àß) from Example 2.27 and Cost  ([0, ‚àû], ‚â•, 0, +) from
Example 2.37. There is a monoidal monotone 1 : Bool ‚ÜíCost, given by 1(false) B ‚àû
and 1(true) B 0.
Exercise 2.43.
1. Check that the map 1 : (B, ‚â§, true, ‚àß) ‚Üí([0, ‚àû], ‚â•, 0, +) presented above indeed
‚Ä¢ is monotonic,
‚Ä¢ satisÔ¨Åes condition (a) of DeÔ¨Ånition 2.41, and
‚Ä¢ satisÔ¨Åes condition (b) of DeÔ¨Ånition 2.41.
2. Is 1 strict?
‚ô¶
Exercise 2.44.
Let Bool and Cost be as above, and consider the following quasi-inverse
functions d, u : [0, ‚àû] ‚ÜíB deÔ¨Åned as follows:
d(x) B
(
false
if x > 0
true
if x  0
u(x) B
(
false
if x  ‚àû
true
if x < ‚àû
1. Is d monotonic?
2. Does d satisfy conditions (a) and (b) of DeÔ¨Ånition 2.41?
3. Is d strict?
4. Is u monotonic?
5. Does u satisfy conditions (a) and (b) of DeÔ¨Ånition 2.41?
6. Is u strict?
‚ô¶
Exercise 2.45.

2.3. ENRICHMENT
57
1. Is (N, ‚â§, 1, ‚àó) a monoidal preorder, where ‚àóis the usual multiplication of natural
numbers?
2. If not, why not? If so, does there exist a monoidal monotone (N, ‚â§, 0, +) ‚Üí(N, ‚â§
, 1, ‚àó)? If not; why not? If so, Ô¨Ånd it.
3. Is (Z, ‚â§, ‚àó, 1) a monoidal preorder?
‚ô¶
2.3
Enrichment
In this section we will introduce V-categories, where V is a symmetric monoidal pre-
order. We will see that Bool-categories are preorders, and that Cost-categories are a
nice generalization of the notion of metric space.
2.3.1
V-categories
While V-categories can be deÔ¨Åned even when V is not symmetric, i.e. just obeys con-
ditions (a)‚Äì(c) of DeÔ¨Ånition 2.2, certain things don‚Äôt work quite right. For example,
we will see later in Exercise 2.75 that the symmetry condition is necessary in order for
products of V-categories to exist. Anyway, here‚Äôs the deÔ¨Ånition.
DeÔ¨Ånition 2.46. Let V  (V, ‚â§, I, ‚äó) be a symmetric monoidal preorder. A V-category
X consists of two constituents, satisfying two properties. To specify X,
(i) one speciÔ¨Åes a set Ob(X), elements of which are called objects;
(ii) for every two objects x, y, one speciÔ¨Åes an element X(x, y) ‚ààV, called the hom-
object.2
The above constituents are required to satisfy two properties:
(a) for every object x ‚ààOb(X) we have I ‚â§X(x, x), and
(b) for every three objects x, y, z ‚ààOb(X), we have X(x, y) ‚äóX(y, z) ‚â§X(x, z).
We call V the base of the enrichment for X or say that X is enriched in V.
Example 2.47. As we shall see in the next subsection, from every preorder we can
construct a Bool-category, and vice versa.
So, to get a feel for V-categories, let us
2The word ‚Äúhom‚Äù is short for homomorphism and reÔ¨Çects the origins of this subject. A more descriptive
name for X(x, y) might be mapping object, but we use ‚Äúhom‚Äù mainly because it is an important jargon word
to know in the Ô¨Åeld.

58
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
consider the preorder generated by the Hasse diagram:
t
s
q
r
p
(2.48)
How does this correspond to a Bool-category X? Well, the objects of X are simply
the elements of the preorder, i.e. Ob(X)  {p, q, r, s, t}. Next, for every pair of objects
(x, y) we need an element of B  {false, true}: simply take true if x ‚â§y, and false
if otherwise.
So for example, since s ‚â§t and t ‚â∞s, we have X(s, t)  true and
X(t, s)  false. Recalling from Example 2.27 that the monoidal unit I of Bool is true,
it‚Äôs straightforward to check that this obeys both (a) and (b), so we have a Bool-category.
In general, it‚Äôs sometimes convenient to represent a V-category X with a square
matrix. The rows and columns of the matrix correspond to the objects of X, and the
(x, y)th entry is simply the hom-object X(x, y). So, for example, the above preorder in
Eq. (2.48) can be represented by the matrix
¬∑‚â§¬∑
p
q
r
s
t
p
true
true
true
true
true
q
false
true
false
true
true
r
false
false
true
true
true
s
false
false
false
true
true
t
false
false
false
false
true
2.3.2
Preorders as Bool-categories
Our colleague Peter Gates has called category theory ‚Äúa primordial ooze,‚Äù because so
much of it can be deÔ¨Åned in terms of other parts of it. There is nowhere to rightly call
the beginning, because that beginning can be deÔ¨Åned in terms of something else. So
be it; this is part of the fun.
Theorem 2.49. There is a one-to-one correspondence between preorders and Bool-
categories.
Here we Ô¨Ånd ourselves in the ooze, because we are saying that preorders are the
same as Bool-categories, whereas Bool is itself a preorder. ‚ÄúSo then Bool is like...
enriched in itself?‚Äù Yes, every preorder, including Bool, is enriched in Bool, as we will
now see.

2.3. ENRICHMENT
59
Proof of Theorem 2.49. Let‚Äôs check that we can construct a preorder from any Bool-
category. Since B  {false, true}, DeÔ¨Ånition 2.46 says a Bool-category consists of two
things:
(i) a set Ob(X), and
(ii) for every x, y ‚ààOb(X) an element X(x, y) ‚ààB, i.e. either X(x, y)  true or
X(x, y)  false.
We will use these two things to begin forming a preorder whose elements are the
objects of X. So let‚Äôs call the preorder (X, ‚â§), and let X B Ob(X). For the ‚â§relation,
let‚Äôs declare x ‚â§y iÔ¨ÄX(x, y)  true. We have the makings of a preorder, but for it to
work, the ‚â§relation must be reÔ¨Çexive and transitive. Let‚Äôs see if we get these from the
properties guaranteed by DeÔ¨Ånition 2.46:
(a) for every element x ‚ààX we have true ‚â§X(x, x),
(b) for every three elements x, y, z ‚ààX we have X(x, y) ‚àßX(y, z) ‚â§X(x, z).
For b ‚ààBool, if true ‚â§b then b  true, so the Ô¨Årst statement says X(x, x)  true,
which means x ‚â§x.
For the second statement, one can consult Eq. (2.28).
Since
false ‚â§b for all b ‚ààB, the only way statement (b) has any force is if X(x, y)  true
and X(y, z)  true, in which case it forces X(x, z)  true. This condition exactly
translates as saying that x ‚â§y and y ‚â§z implies x ‚â§z. Thus we have obtained
reÔ¨Çexivity and transitivity from the two axioms of Bool-categories.
In Example 2.47, we constructed a Bool-category from a preorder. We leave it to the
reader to generalize this example and show that the two constructions are inverses; see
Exercise 2.50.
‚ñ°
Exercise 2.50.
1. Start with a preorder (P, ‚â§), and use it to deÔ¨Åne a Bool-category as we did in
Example 2.47. In the proof of Theorem 2.49 we showed how to turn that Bool-
category back into a preorder. Show that doing so, you get the preorder you
started with.
2. Similarly, show that if you turn a Bool-category into a preorder using the above
proof, and then turn the preorder back into a Bool-category using your method,
you get the Bool-category you started with.
‚ô¶
We now discuss a beautiful application of the notion of enriched categories: metric
spaces.
2.3.3
Lawvere metric spaces
Metric spaces oÔ¨Äer a precise way to describe spaces of points, each pair of which is
separated by some distance. Here is the usual deÔ¨Ånition:
DeÔ¨Ånition 2.51. A metric space (X, d) consists of:
(i) a set X, elements of which are called points, and
(ii) a function d : X √ó X ‚ÜíR‚â•0, where d(x, y) is called the distance between x and y.

60
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
These constituents must satisfy four properties:
(a) for every x ‚ààX, we have d(x, x)  0,
(b) for every x, y ‚ààX, if d(x, y)  0 then x  y,
(c) for every x, y ‚ààX, we have d(x, y)  d(y, x), and
(d) for every x, y, z ‚ààX, we have d(x, y) + d(y, z) ‚â•d(x, z).
The fourth property is called the triangle inequality.
If we ask instead in (ii) for a function d : X √ó X ‚Üí[0, ‚àû]  R‚â•0 ‚à™{‚àû}, we call (X, d)
an extended metric space.
The triangle inequality says that when plotting a route from x to z, the distance is
always at most what you get by choosing an intermediate point y and going x ‚Üíy ‚Üíz.
‚Ä¢
‚Ä¢
‚Ä¢
x
y
z
3
5
7.2
It can be invoked three diÔ¨Äerent ways in the above picture: 3 + 5 ‚â•7.2, but also
5 + 7.2 ‚â•3 and 3 + 7.2 ‚â•5. Oh yeah, and 5 + 3 ‚â•7.2, 7.2 + 5 ‚â•3 and 7.2 + 3 ‚â•5.
The triangle inequality wonderfully captures something about distance, as does the
fact that d(x, x)  0 for any x. However, the other two conditions are not quite as
general as we would like. Indeed, there are many examples of things that ‚Äúshould‚Äù be
metric spaces, but which do not satisfy conditions (b) or (c) of DeÔ¨Ånition 2.51.
For example, what if we take X to be places in your neighborhood, but instead of
measuring distance, you want d(x, y) to measure eÔ¨Äort to get from x to y. Then if there
are any hills, the symmetry axiom, d(x, y) ? d(y, x), fails: it‚Äôs easier to get from x
downhill to y then to go from y uphill to x.
Another way to Ô¨Ånd a model that breaks the symmetry axiom is to imagine that
the elements of X are not points, but whole regions such as the US, Spain, and Boston.
Say that the distance from region A to region B is understood using the setup ‚ÄúI will
put you in an arbitrary part of A and you just have to get anywhere in B; what is the
distance in the worst-case scenario?‚Äù So d(US, Spain) is the distance from somewhere
in the western US to the western tip of Spain: you just have to get into Spain, but you
start in the worst possible part of the US for doing so.
Exercise 2.52.
Which distance is bigger under the above description, d(Spain, US) or
d(US, Spain)?
‚ô¶
This notion of distance, which is strongly related to something called HausdorÔ¨Ädis-
tance,3 will again satisfy the triangle inequality, but it violates the symmetry condition.
It also violates another condition, because d(Boston, US)  0. No matter where you
3 The HausdorÔ¨Ädistance gives a metric on the set of all subsets U ‚äÜX of a given metric space (X, d).

2.3. ENRICHMENT
61
are in Boston, the distance to the nearest point of the US is 0. On the other hand,
d(US, Boston) , 0.
Finally, one can imagine a use for distances that are not Ô¨Ånite.
In terms of my
eÔ¨Äort, the distance from here to Pluto is ‚àû, and it would not be any better if Pluto was
still a planet. Similarly, in terms of HausdorÔ¨Ädistance, discussed above, the distance
between two regions is often inÔ¨Ånite, e.g. the distance between {r ‚ààR | r < 0} and {0}
as subsets of (R, d) is inÔ¨Ånite.
When we drop conditions (b) and (c) and allow for inÔ¨Ånite distances, we get the fol-
lowing relaxed notion of metric space, Ô¨Årst proposed by Lawvere. Recall the symmetric
monoidal preorder Cost  ([0, ‚àû], ‚â•, 0, +) from Example 2.37.
DeÔ¨Ånition 2.53. A Lawvere metric space is a Cost-category.
This is a very compact deÔ¨Ånition, but it packs a punch. Let‚Äôs work out what it means,
by relating it to the usual deÔ¨Ånition of metric space. By DeÔ¨Ånition 2.46, a Cost-category
X consists of:
(i) a set Ob(X),
(ii) for every x, y ‚ààOb(X) an element X(x, y) ‚àà[0, ‚àû].
Here the set Ob(X) is playing the role of the set of points, and X(x, y) ‚àà[0, ‚àû] is playing
the role of distance, so let‚Äôs write a little translator:
X B Ob(X)
d(x, y) B X(x, y).
The properties of a category enriched in Cost are:
(a) 0 ‚â•d(x, x) for all x ‚ààX, and
(b) d(x, y) + d(y, z) ‚â•d(x, z) for all x, y, z ‚ààX.
Since d(x, x) ‚àà[0, ‚àû], if 0 ‚â•d(x, x) then d(x, x)  0. So the Ô¨Årst condition is equivalent
to the Ô¨Årst condition from DeÔ¨Ånition 2.51, namely d(x, x)  0. The second condition is
the triangle inequality.
Example 2.54. The set R of real numbers can be given a metric space structure, and
hence a Lawvere metric space structure. Namely d(x, y) B |y ‚àíx|, the absolute value
of the diÔ¨Äerence. So d(3, 7)  4.
Exercise 2.55.
Consider the symmetric monoidal preorder (R‚â•0, ‚â•, 0, +), which is
almost the same as Cost, except it does not include ‚àû. How would you characterize
the diÔ¨Äerence between a Lawvere metric space and a (R‚â•0, ‚â•, 0, +)-category in the sense
of DeÔ¨Ånition 2.46?
‚ô¶
One Ô¨Årst deÔ¨Ånes
dL(U, V) B sup
u‚ààU
inf
v‚ààV
d(u, v),
and this is exactly the formula we intend above; the result will be a Lawvere metric space. However, if one
wants the HausdorÔ¨Ädistance to deÔ¨Åne a (symmetric) metric, as in DeÔ¨Ånition 2.51, one must take the above
formula and symmetrize it: d(U, V) B max(dL(U, V), dL(V, U)). We happen to see the unsymmetrized
notion as more interesting.

62
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Presenting metric spaces with weighted graphs
Just as one can convert a Hasse
diagram into a preorder, one can convert any weighted graph‚Äîa graph whose edges
are labeled with numbers w ‚â•0‚Äîinto a Lawvere metric space.
In fact, we shall
consider these as graphs labelled with elements of [0, ‚àû], and more precisely call them
Cost-weighted graphs.4
One might think of a Cost-weighted graph as describing a city with some one-way
roads (a two-way road is modeled as two one-way roads), each having some eÔ¨Äort-to-
traverse, which for simplicity we just call length. For example, consider the following
weighted graphs:
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
3
3
6
2
5
X B
x‚Ä¢
‚Ä¢
y
z‚Ä¢
3
4
3
4
: Y
(2.56)
Given a weighted graph, one forms a metric dX on its set X of vertices by setting d(p, q)
to be the length of the shortest path from p to q. For example, here is the the table of
distances for Y
d(‚Üó)
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
(2.57)
Exercise 2.58.
Fill out the following table of distances in the weighted graph X from
Eq. (2.56)
d(‚Üó)
A
B
C
D
A
0
?
?
?
B
2
?
5
?
C
?
?
?
?
D
?
?
?
?
‚ô¶
Above we converted a weighted graph G, e.g. as shown in Eq. (2.56), into a table
of distances, but this takes a bit of thinking. There is a more direct construction for
taking G and getting a square matrix MG, whose rows and columns are indexed by the
vertices of G. To do so, set MG to be 0 along the diagonal, to be ‚àûwherever an edge is
missing, and to be the edge weight if there is an edge.
4This generalizes Hasse diagrams, which we could call Bool-weighted graphs‚Äîthe edges of a Hasse
diagram are thought of as weighted with true; we simply ignore any edges that are weighted with false,
and neglect to even draw them!

2.3. ENRICHMENT
63
For example, the matrix associated to Y in Eq. (2.56) would be
MY B
‚Üó
x
y
z
x
0
4
3
y
3
0
‚àû
z
‚àû
4
0
(2.59)
As soon as you see how we did this, you‚Äôll understand that it takes no thinking to turn
a weighted graph G into a matrix MG in this way. We will see later in Section 2.5.3
that the more diÔ¨Écult ‚Äúdistance matrices‚Äù dY, such as Eq. (2.57), can be obtained from
the easy graph matrices MY, such as Eq. (2.59), by repeating a certain sort of ‚Äúmatrix
multiplication.‚Äù
Exercise 2.60.
Fill out the matrix MX associated to the graph X in Eq. (2.56):
MX 
‚Üó
A
B
C
D
A
0
?
?
?
B
2
0
‚àû
?
C
?
?
?
?
D
?
?
?
?
‚ô¶
2.3.4
V-variations on preorders and metric spaces
We have told the story of Bool and Cost. But in Section 2.2.4 we gave examples of
many other monoidal preorders, and each one serves as the base of enrichment for a
kind of enriched category. Which of them are useful? Something only becomes useful
when someone Ô¨Ånds a use for it. We will Ô¨Ånd uses for some and not others, though we
encourage readers to think about what it would mean to enrich in the various monoidal
categories discussed above; maybe they can Ô¨Ånd a use we have not explored.
Exercise 2.61.
Recall the monoidal preorder NMY B (P, ‚â§, yes, min) from Exer-
cise 2.34. Interpret what a NMY-category is.
‚ô¶
In the next two exercises, we use V-weighted graphs to construct V-categories. This
is possible because we will use preorders that, like Bool and Cost, have joins.
Exercise 2.62.
Let M be a set and let M B (P(M), ‚äÜ, M, ‚à©) be the monoidal preorder
whose elements are subsets of M.
Someone gives the following interpretation, ‚Äúfor any set M, imagine it as the set of
modes of transportation (e.g. car, boat, foot). Then an M-category X tells you all the
modes that will get you from a all the way to b, for any two points a, b ‚ààOb(X).‚Äù
1. Draw a graph with four vertices and four or Ô¨Åve edges, each labeled with a subset
of M  {car, boat, foot}.
2. From this graph is it possible to construct an M-category, where the hom-object
from x to y is computed as follows: for each path p from x to y, take the
intersection of the sets labelling the edges in p. Then, take the union of the these

64
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
sets over all paths p from x to y. Write out the corresponding four-by-four matrix
of hom-objects, and convince yourself that this is indeed an M-category.
3. Does the person‚Äôs interpretation look right, or is it subtly mistaken somehow?
‚ô¶
Exercise 2.63.
Consider the monoidal preorder W B (N ‚à™{‚àû}, ‚â§, ‚àû, min).
1. Draw a small graph labeled by elements of N ‚à™{‚àû}.
2. Write out the matrix whose rows and columns are indexed by the nodes in the
graph, and whose (x, y)th entry is given by the maximum over all paths p from x
to y of the minimum edge label in p.
3. Prove that this matrix is the matrix of hom-objects for a W-category. This will
give you a feel for how W works.
4. Make up an interpretation, like that in Exercise 2.62, for how to imagine enrich-
ment in W.
‚ô¶
2.4
Constructions on V-categories
Now that we have a good intuition for what V-categories are, we give three examples
of what can be done with V-categories. The Ô¨Årst (Section 2.4.1) is known as change of
base. This allows us to use a monoidal monotone f : V ‚ÜíW to construct W-categories
from V-categories. The second construction (Section 2.4.2), that of V-functors, allows
us to complete the analogy: a preorder is to a Bool-category as a monotone map is to
what? The third construction (Section 2.4.2) is known as a V-product, and gives us a
way of combining two V-categories.
2.4.1
Changing the base of enrichment
Any monoidal monotone V ‚ÜíW between symmetric monoidal preorders lets us
convert V-categories into W-categories.
Construction 2.64. Let f : V ‚ÜíW be a monoidal monotone. Given a V-category C, one
forms the associated W-category, say C f as follows.
(i) We take the same objects: Ob(C f ) B Ob(C).
(ii) For any c, d ‚ààOb(C), put C f (c, d) B f (C(c, d)).
This construction C f does indeed obey the deÔ¨Ånition of a W-category, as can be seen
by applying DeÔ¨Ånition 2.41 (of monoidal monotone) and DeÔ¨Ånition 2.46 (of V-category):
(a) for every c ‚ààC, we have
IW ‚â§f (IV)
( f is monoidal monotone)
‚â§f (C(c, c))
(C is V-category)
 C f (c, c)
(deÔ¨Ånition of C f )

2.4. CONSTRUCTIONS ON V-CATEGORIES
65
(b) for every c, d, e ‚ààOb(C) we have
C f (c, d) ‚äóW C f (d, e)  f (C(c, d)) ‚äóW f (C(d, e))
(deÔ¨Ånition of C f )
‚â§f  C(c, d) ‚äóV C(d, e)
( f is monoidal monotone)
‚â§f (C(c, e))
(C is V-category)
 C f (c, e)
(deÔ¨Ånition of C f )
Example 2.65. As an example, consider the function f : [0, ‚àû] ‚Üí{true, false} given
by
f (x) B
(
true
if x  0
false
if x > 0
(2.66)
It is easy to check that f is monotonic and that f preserves the monoidal product
and monoidal unit; that is, it‚Äôs easy to show that f is a monoidal monotone. (Recall
Exercise 2.44.)
Thus f lets us convert Lawvere metric spaces into preorders.
Exercise 2.67. Recall the ‚Äúregions of the world‚Äù Lawvere metric space from Exercise 2.52
and the text above it. We just learned that, using the monoidal monotone f in Eq. (2.66),
we can convert it to a preorder. Draw the Hasse diagram for the preorder corresponding
to the regions: US, Spain, and Boston. How could you interpret this preorder relation?
‚ô¶
Exercise 2.68.
1. Find another monoidal monotone 1 : Cost ‚ÜíBool diÔ¨Äerent from the one deÔ¨Åned
in Eq. (2.66).
2. Using Construction 2.64, both your monoidal monotone 1 and the monoidal
monotone f in Eq. (2.66) can be used to convert a Lawvere metric space into a
preorder. Find a Lawvere metric space X on which they give diÔ¨Äerent answers,
X f , X1.
‚ô¶
2.4.2
Enriched functors
The notion of functor provides the most important type of relationship between cate-
gories.
DeÔ¨Ånition 2.69. Let X and Y be V-categories. A V-functor from X to Y, denoted F : X ‚ÜíY,
consists of one constituent:
(i) a function F : Ob(X) ‚ÜíOb(Y)
subject to one constraint
(a) for all x1, x2 ‚ààOb(X), one has X(x1, x2) ‚â§Y(F(x1), F(x2)).

66
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Example 2.70. For example, we have said several times‚Äîe.g. in Theorem 2.49‚Äîthat pre-
orders are Bool-categories, where X(x1, x2)  true is denoted x1 ‚â§x2. One would hope
that monotone maps between preorders would correspond exactly to Bool-functors,
and that‚Äôs true. A monotone map (X, ‚â§X) ‚Üí(Y, ‚â§Y) is a function F : X ‚ÜíY such that
for every x1, x2 ‚ààX, if x1 ‚â§X x2 then F(x1) ‚â§Y F(x2). In other words, we have
X(x1, x2) ‚â§Y(F(x1), F(x2)),
where the above ‚â§takes place in the enriching category V  Bool; this is exactly the
condition from DeÔ¨Ånition 2.69.
Remark 2.71. In fact, we have what is called an equivalence of categories between the
category of preorders and the category of Bool-categories. In the next chapter we will
develop the ideas necessary to state what this means precisely (Remark 3.59).
Example 2.72. Lawvere metric spaces are Cost-categories. The deÔ¨Ånition of Cost-functor
should hopefully return a nice notion‚Äîa ‚Äúfriend‚Äù‚Äîfrom the theory of metric spaces,
and it does: it recovers the notion of Lipschitz function. A Lipschitz (or more precisely,
1-Lipschitz) function is one under which the distance between any pair of points
does not increase. That is, given Lawvere metric spaces (X, dX) and (Y, dY), a Cost-
functor between them is a function F : X ‚ÜíY such that for every x1, x2 ‚ààX we have
dX(x1, x2) ‚â•dY(F(x1), F(x2)).
Exercise 2.73.
The concepts of opposite, dagger, and skeleton (see Examples 1.58
and 1.72 and Remark 1.35) extend from preorders to V-categories. The opposite of a
V-category X is denoted Xop and is deÔ¨Åned by
(i) Ob(Xop) B Ob(X), and
(ii) for all x, y ‚ààX, we have Xop(x, y) B X(y, x).
A V-category X is a dagger V-category if the identity function is a V-functor ‚Ä†: X ‚ÜíXop.
And a skeletal V-category is one in which if I ‚â§X(x, y) and I ‚â§X(y, x), then x  y.
Recall that an extended metric space (X, d) is a Lawvere metric space with two extra
properties; see properties (b) and (c) in DeÔ¨Ånition 2.51.
1. Show that a skeletal dagger Cost-category is an extended metric space.
2. Use Exercise 1.73 to make sense of the following analogy: ‚Äúpreorders are to sets
as Lawvere metric spaces are to extended metric spaces.‚Äù
‚ô¶
2.4.3
Product V-categories
If V  (V, ‚â§, I, ‚äó) is a symmetric monoidal preorder and X and Y are V-categories, then
we can deÔ¨Åne their V-product, which is a new V-category.

2.4. CONSTRUCTIONS ON V-CATEGORIES
67
DeÔ¨Ånition 2.74. Let X and Y be V-categories. DeÔ¨Åne their V-product, or simply product,
to be the V-category X √ó Y with
(i) Ob(X √ó Y) B Ob(X) √ó Ob(Y),
(ii) (X √ó Y) (x, y), (x‚Ä≤, y‚Ä≤) B X(x, x‚Ä≤) ‚äóY(y, y‚Ä≤),
for two objects (x, y) and (x‚Ä≤, y‚Ä≤) in Ob(X √ó Y).
Product V-categories are indeed V-categories (DeÔ¨Ånition 2.46); see Exercise 2.75.
Exercise 2.75.
Let X √ó Y be the V-product of V-categories as in DeÔ¨Ånition 2.74.
1. Check that for every object (x, y) ‚ààOb(X √ó Y) we have I ‚â§(X √ó Y) (x, y), (x, y)
.
2. Check that for every three objects (x1, y1), (x2, y2), and (x3, y3), we have
(X √ó Y) (x1, y1), (x2, y2)
‚äó(X √ó Y) (x2, y2), (x3, y3)
‚â§(X √ó Y) (x1, y1), (x3, y3)
.
3. We said at the start of Section 2.3.1 that the symmetry of V (condition (d) of
DeÔ¨Ånition 2.2) would be required here. Point out exactly where that condition is
used.
‚ô¶
When taking the product of two preorders (P, ‚â§P) √ó (Q, ‚â§Q), as Ô¨Årst described in
Example 1.56, we say that (p1, q1) ‚â§(p2, q2) iÔ¨Äboth p1 ‚â§p2 AND q1 ‚â§q2; the AND is
the monoidal product ‚äófrom of Bool. Thus the product of preorders is an example of
a Bool-product.
Example 2.76. Let X and Y be the Lawvere metric spaces (i.e. Cost-categories) deÔ¨Åned
by the following weighted graphs:
‚Ä¢
A
‚Ä¢
B
‚Ä¢
C
2
3
X B
‚Ä¢q
‚Ä¢
p
5
8
: Y
(2.77)
Their product is deÔ¨Åned by taking the product of their sets of objects, so there are six
objects in X √ó Y. And the distance dX√óY((x, y), (x‚Ä≤, y‚Ä≤)) between any two points is given
by the sum dX(x, x‚Ä≤) + dY(y, y‚Ä≤).
Examine the following graph, and make sure you understand how easy it is to

68
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
derive from the weighted graphs for X and Y in Eq. (2.77):
‚Ä¢
(A, p)
‚Ä¢
(B, p)
‚Ä¢
(C, p)
‚Ä¢
(A, q)
‚Ä¢
(B, q)
‚Ä¢
(C, q)
2
3
2
3
5
8
5
8
5
8
X √ó Y 
Exercise 2.78.
Consider R as a Lawvere metric space, i.e. as a Cost-category (see
Example 2.54).
Form the Cost-product R √ó R.
What is the distance from (5, 6) to
(‚àí1, 4)? Hint: apply DeÔ¨Ånition 2.74; the answer is not
‚àö
40.
‚ô¶
In terms of matrices, V-products are also quite straightforward. They generalize
what is known as the Kronecker product of matrices. The matrices for X and Y in
Eq. (2.77) are shown below
X
A
B
C
A
0
2
5
B
‚àû
0
3
C
‚àû
‚àû
0
Y
p
q
p
0
5
q
8
0
and their product is as follows:
X √ó Y
(A, p)
(B, p)
(C, p)
(A, q)
(B, q)
(C, q)
(A, p)
0
2
5
5
7
10
(B, p)
‚àû
0
3
‚àû
5
8
(C, p)
‚àû
‚àû
0
‚àû
‚àû
5
(A, q)
8
10
13
0
2
5
(B, q)
‚àû
8
11
‚àû
0
3
(C, q)
‚àû
‚àû
8
‚àû
‚àû
0
We have drawn the product matrix as a block matrix, where there is one block‚Äîshaped
like X‚Äîfor every entry of Y. Make sure you can see each block as the X-matrix shifted
by an entry in Y. This comes directly from the formula from DeÔ¨Ånition 2.74 and the
fact that the monoidal product in Cost is +.
2.5
Computing presented V-categories with matrix
multiplication
In Section 2.3.3 we promised a straightforward way to construct the matrix representa-
tion of a Cost-category from a Cost-weighted graph. To do this, we use a generalized
matrix multiplication. We shall show that this works, not just for Cost, but also for
Bool, and many other monoidal preorders. The property required of the preorder is

2.5. COMPUTING PRESENTED V-CATEGORIES WITH MATRIX MULT.
69
that of being a unital, commutative quantale. These are preorders with all joins, plus
one additional ingredient, being monoidal closed, which we deÔ¨Åne next, in Section 2.5.1.
The deÔ¨Ånition of a quantale will be given in Section 2.5.2.
2.5.1
Monoidal closed preorders
The deÔ¨Ånition of V-category makes sense for any symmetric monoidal preorder V. But
that does not mean that any base of enrichment V is as useful as any other. In this
section we deÔ¨Åne closed monoidal categories, which in particular enrich themselves!
‚ÄúBefore you can really enrich others, you should really enrich yourself.‚Äù
DeÔ¨Ånition 2.79. A symmetric monoidal preorder V  (V, ‚â§, I, ‚äó) is called symmetric
monoidal closed (or just closed) if, for every two elements v, w ‚ààV, there is an element
v ‚ä∏w in V, called the hom-element, with the property
(a ‚äóv) ‚â§w
iÔ¨Ä
a ‚â§(v ‚ä∏w).
(2.80)
for all a, v, w ‚ààV.
Remark 2.81. The term ‚Äòclosed‚Äô refers to the fact that a hom-element can be constructed
for any two elements, so the preorder can be seen as closed under the operation of
‚Äútaking homs.‚Äù In later chapters we‚Äôll meet the closely-related concepts of compact
closed categories (DeÔ¨Ånition 4.58) and cartesian closed categories (Section 7.2.1) that
make this idea more precise. See especially Exercise 7.11.
One can consider the hom-element v ‚ä∏w as a kind of ‚Äúsingle-use v-to-w converter.‚Äù
So Eq. (2.80) says that a and v are enough to get w if and only if a is enough to get a
single-use v-to-w converter.
Exercise 2.82.
Condition Eq. (2.80) says precisely that there is a Galois connection in the
sense of DeÔ¨Ånition 1.95. Let‚Äôs prove this fact. In particular, we‚Äôll prove that a monoidal
preorder is monoidal closed iÔ¨Ä, given any v ‚ààV, the map (‚àí‚äóv): V ‚ÜíV given by
multiplying with v has a right adjoint. We write this right adjoint (v ‚ä∏‚àí): V ‚ÜíV.
1. Using DeÔ¨Ånition 2.2, show that (‚àí‚äóv) is monotone.
2. Supposing that V is closed, show that for all v, w ‚ààV we have  (v ‚ä∏w)‚äóv
‚â§w.
3. Using 2., show that (v ‚ä∏‚àí) is monotone.
4. Conclude that a symmetric monoidal preorder is closed if and only if the mono-
tone map (‚àí‚äóv) has a right adjoint.
‚ô¶
Example 2.83. The monoidal preorder Cost  ([0, ‚àû], ‚â•, 0, +) is monoidal closed. In-
deed, for any x, y ‚àà[0, ‚àû], deÔ¨Åne x ‚ä∏y B max(0, y‚àíx). Then, for any a, x, y ‚àà[0, ‚àû],
we have
a + x ‚â•y
iÔ¨Ä
a ‚â•y ‚àíx
iÔ¨Ä
max(0, a) ‚â•max(0, y ‚àíx)
iÔ¨Ä
a ‚â•(x ‚ä∏y)

70
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
so ‚ä∏satisÔ¨Åes the condition of Eq. (2.80).
Note that we have not considered subtraction in Cost before; we can in fact use
monoidal closure to deÔ¨Åne subtraction in terms of the order and monoidal structure!
Exercise 2.84.
Show that Bool  (B, ‚â§, true, ‚àß) is monoidal closed.
‚ô¶
Example 2.85. A non-example is (B, ‚â§, false, ‚à®). Indeed, suppose we had a ‚ä∏operator
as in DeÔ¨Ånition 2.79. Note that false ‚â§p ‚ä∏q, for any p, q no matter what ‚ä∏is,
because false is less than everything. But using a  false, p  true, and q  false,
we then get a contradiction: (a ‚à®p) ‚â∞q and yet a ‚â§(p ‚ä∏q).
Example 2.86. We started this chapter talking about resource theories. What does the
closed structure look like from that perspective? For example, in chemistry it would
say that for every two material collections c, d one can form a material collection c ‚ä∏d
with the property that for any a, one has
a + c ‚Üíd
if and only if
a ‚Üí(c ‚ä∏d).
Or more down to earth, since we have the reaction 2H2O + 2Na ‚Üí2NaOH + H2, we
must also have
2H2O ‚Üí(2Na ‚ä∏(2NaOH + H2))
So from just two molecules of water, you can form a certain substance, and not many
substances Ô¨Åt the bill‚Äîour preorder Mat of chemical materials is not closed.
But it is not so far-fetched: this hypothetical new substance (2Na ‚ä∏(2NaOH + H2))
is not really a substance, but a potential reaction: namely that of converting a sodium
to sodium-hydroxide-plus-hydrogen. Two molecules of water unlock that potential.
Proposition 2.87. Suppose V  (V, ‚â§, I, ‚äó, ‚ä∏) is a symmetric monoidal preorder that
is closed. Then
(a) For every v ‚ààV, the monotone map ‚àí‚äóv : (V, ‚â§) ‚Üí(V, ‚â§) is left adjoint to
v ‚ä∏‚àí: (V, ‚â§) ‚Üí(V, ‚â§).
(b) For any element v ‚ààV and set of elements A ‚äÜV, if the join √î
a‚ààA a exists then
so does √î
a‚ààA v ‚äóa and we have
 
v ‚äó
√ú
a‚ààA
a
!

√ú
a‚ààA
(v ‚äóa).
(2.88)
(c) For any v, w ‚ààV, we have v ‚äó(v ‚ä∏w) ‚â§w.
(d) For any v ‚ààV, we have v  (I ‚ä∏v).
(e) For any u, v, w ‚ààV, we have (u ‚ä∏v) ‚äó(v ‚ä∏w) ‚â§(u ‚ä∏w).

2.5. COMPUTING PRESENTED V-CATEGORIES WITH MATRIX MULT.
71
Proof. We go through the claims in order.
(a) The deÔ¨Ånition of (‚àí‚äóv) being left adjoint to (v ‚ä∏‚àí) is exactly the condition
Eq. (2.80); see DeÔ¨Ånition 1.95 and Exercise 2.82.
(b) This follows from (a), using the fact that left adjoints preserve joins (Proposi-
tion 1.111).
(c) This follows from (a), using the equivalent characterisation of Galois connection
in Proposition 1.107. More concretely, from reÔ¨Çexivity (v ‚ä∏w) ‚â§(v ‚ä∏w), we
obtain (v ‚ä∏w) ‚äóv ‚â§w Eq. (2.80), and we are done by symmetry, which says
v ‚äó(v ‚ä∏w)  (v ‚ä∏w) ‚äóv.
(d) Since v ‚äóI  v ‚â§v, Eq. (2.80) says v ‚â§(I ‚ä∏v). For the other direction, we have
(I ‚ä∏v)  I ‚äó(I ‚ä∏v) ‚â§v by (c).
(e) To obtain this inequality, we just need u ‚äó(u ‚ä∏v) ‚äó(v ‚ä∏w) ‚â§w. But this
follows by two applications of (c).
‚ñ°
One might read (c) as saying ‚Äúif I have a v and a single-use v-to-w converter, I can
have a w.‚Äù One might read (d) as saying ‚Äúhaving a v is the same as having a single-use
nothing-to-v converter.‚Äù And one might read (e) as saying ‚Äúif I have a single-use u-to-v
converter and a single-use v-to-w converter, I can get a single-use u-to-w converter.
Remark 2.89. We can consider V to be enriched in itself. That is, for every v, w ‚ààOb(V),
we can deÔ¨Åne V(v, w) B (v ‚ä∏w) ‚ààV. For this to really be an enrichment, we just need
to check the two conditions of DeÔ¨Ånition 2.46. The Ô¨Årst condition I ‚â§X(x, x)  (x ‚ä∏x)
is satisÔ¨Åed because I ‚äóx ‚â§x. The second condition is satisÔ¨Åed by Proposition 2.87(e).
2.5.2
Quantales
To perform matrix multiplication over a monoidal preorder, we need one more thing:
joins. These were Ô¨Årst deÔ¨Åned in DeÔ¨Ånition 1.81.
DeÔ¨Ånition 2.90. A unital commutative quantale is a symmetric monoidal closed preorder
V  (V, ‚â§, I, ‚äó, ‚ä∏) that has all joins: √î A exists for every A ‚äÜV. In particular, we often
denote the empty join by 0 B √î ¬ú.
Whenever we speak of quantales in this book, we mean unital commutative quan-
tales. We will try to remind the reader of that. There are also very interesting applica-
tions of noncommutative quantales; see Section 2.6.
Example 2.91. In Example 2.83, we saw that Cost is monoidal closed. To check whether
Cost is a quantale, we take an arbitrary set of elements A ‚äÜ[0, ‚àû] and ask if it has a
join √î A. To be a join, it needs to satisfy two properties:
a. a ‚â•√î A for all a ‚ààA, and
b. if b ‚àà[0, ‚àû] is any element such that a ‚â•b for all a ‚ààA, then √î A ‚â•b.
In fact we can deÔ¨Åne such a join: it is typically called the inÔ¨Åmum, or greatest lower

72
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
bound, of A.5 For example, if A  {2, 3} then √î A  2. We have joins for inÔ¨Ånite sets
too: if B  {2.5, 2.05, 2.005, . . .}, its inÔ¨Åmum is 2. Finally, in order to say that ([0, ‚àû], ‚â•)
has all joins, we need a join to exist for the empty set A  ¬ú too. The Ô¨Årst condition
becomes vacuous‚Äîthere are no a‚Äôs in A‚Äîbut the second condition says that for any
b ‚àà[0, ‚àû] we have √î ¬ú ‚â•b; this means √î ¬ú  ‚àû.
Thus indeed ([0, ‚àû], ‚â•) has all joins, so Cost is a quantale.
Exercise 2.92.
1. What is √î ¬ú, which we generally denote 0, in the case
a. V  Bool  (B, ‚â§, true, ‚àß)?
b. V  Cost  ([0, ‚àû], ‚â•, 0, +)?
2. What is the join x ‚à®y in the case
a. V  Bool, and x, y ‚ààB are booleans?
b. V  Cost, and x, y ‚àà[0, ‚àû] are distances?
‚ô¶
Exercise 2.93.
Show that Bool  (B, ‚â§, true, ‚àß) is a quantale.
‚ô¶
Exercise 2.94.
Let S be a set and recall the power set monoidal preorder (P(S), ‚äÜ, S, ‚à©)
from Exercise 2.35. Is it a quantale?
‚ô¶
Remark 2.95. One can personify the notion of unital, commutative quantale as a kind
of navigator. A navigator is someone who understands ‚Äúgetting from one place to an-
other.‚Äù DiÔ¨Äerent navigators may care about or understand diÔ¨Äerent aspects‚Äîwhether
one can get from A to B, how much time it will take, what modes of travel will work,
etc.‚Äîbut they certainly have some commonalities. Most importantly, a navigator needs
to be able to read a map: given routes A to B and B to C, they understand how to get
a route A to C. And they know how to search over the space of way-points to get
from A to C. These will correspond to the monoidal product and the join operations,
respectively.
Proposition 2.96. Let P  (P, ‚â§) be a preorder. It has all joins iÔ¨Äit has all meets.
Proof. The joins (resp. meets) in P are the meets (resp. joins) in Pop, so the two claims
are dual: it suÔ¨Éces to show that if P has all joins then it has all meets.
Suppose P has all joins and suppose that A ‚äÜP is a subset for which we want
the meet. Consider the set MA B {p ‚ààP | p ‚â§a for all a ‚ààA} of elements below
everything in A. Let mA B √î
p‚ààMA p be their join. We claim that mA is a meet for A.
We Ô¨Årst need to know that for any a ‚ààA we have mA ‚â§a, but this is by deÔ¨Ånition of
join: since all p ‚ààMA satisfy p ‚â§a, so does their join mA ‚â§a. We second need to know
that for any m‚Ä≤ ‚ààP with m‚Ä≤ ‚â§a for all a ‚ààA, we have m‚Ä≤ ‚â§m. But every such m‚Ä≤ is
actually an element of MA and m is their join, so m‚Ä≤ ‚â§m. This completes the proof.
‚ñ°
5 Here, by the inÔ¨Åmum of a subset A ‚äÜ[0, ‚àû], we mean inÔ¨Åmum in the usual order on [0, ‚àû]: the
largest number that is ‚â§everything in A. For example, the inÔ¨Åmum of {3.1, 3.01, 3.001, . . .} is 3. But note
that this is the supremum in the reversed, ‚â•, order of Cost.

2.5. COMPUTING PRESENTED V-CATEGORIES WITH MATRIX MULT.
73
In particular, a quantale has all meets and all joins, even though we only deÔ¨Åne it to
have all joins.
Remark 2.97. The notion of HausdorÔ¨Ädistance can be generalized, allowing the role of
Cost to be taken by any quantale V. If X is a V-category with objects X, and U ‚äÜX
and V ‚äÜX, we can generalize the usual HausdorÔ¨Ädistance, on the left below, to the
formula on the right:
d(U, V) B sup
u‚ààU
inf
v‚ààV
d(u, v)
X(U, V) B
√õ
u‚ààU
√ú
v‚ààV
X(u, v).
For example, if V  Bool, the HausdorÔ¨Ädistance between sub-preorders U and V
answers the question ‚Äúcan I get into V from every u ‚ààU,‚Äù i.e. ‚àÄu‚ààU. ‚àÉv‚ààV. u ‚â§v. Or
for another example, use V  P(M) with its interpretation as modes of transportation,
as in Exercise 2.62. Then the HausdorÔ¨Ädistance d(U, V) ‚ààP(M) tells us those modes
of transportation that will get us into V from every point in U.
Proposition 2.98. Suppose V  (V, ‚â§, I, ‚äó) is any symmetric monoidal preorder that
has all joins. Then V is closed‚Äîi.e. it has a ‚ä∏operation and hence is a quantale‚Äîif
and only if ‚äódistributes over joins; i.e. if Eq. (2.88) holds for all v ‚ààV and A ‚äÜV.
Proof. We showed one direction in Proposition 2.87(b): if V is monoidal closed then
Eq. (2.88) holds. We need to show that Eq. (2.88) holds then ‚àí‚äóv : V ‚ÜíV has a right
adjoint v ‚ä∏‚àí. This is just the adjoint functor theorem, Theorem 1.115. It says we can
deÔ¨Åne v ‚ä∏w to be
v ‚ä∏w B
√ú
{a‚ààV|a‚äóv‚â§w}
a.
‚ñ°
2.5.3
Matrix multiplication in a quantale
A quantale V  (V, ‚â§, I, ‚äó, ‚ä∏), as deÔ¨Åned in DeÔ¨Ånition 2.79, provides what is necessary
to perform matrix multiplication.6 The usual formula for matrix multiplication is:
(M ‚àóN)(i, k) 
√ï
j
M(i, j) ‚àóN(j, k).
(2.99)
We will get a formula where joins stand in for the sum operation √ç, and ‚äóstands in
for the product operation ‚àó. Recall our convention of writing 0 B √î ¬ú.
DeÔ¨Ånition 2.100. Let V  (V, ‚â§, ‚äó, I) be a quantale. Given sets X and Y, a matrix with
entries in V, or simply a V-matrix, is a function M : X √ó Y ‚ÜíV. For any x ‚ààX and
y ‚ààY, we call M(x, y) the (x, y)-entry.
6This works for noncommutative quantales as well.

74
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
Here is how you multiply V-matrices M : X √ó Y ‚ÜíV and N : Y √ó Z ‚ÜíV. Their
product is deÔ¨Åned to be the matrix (M ‚àóN): X √ó Z ‚ÜíV, whose entries are given by
the formula
(M ‚àóN)(x, z) B
√ú
y‚ààY
M(x, y) ‚äóN(y, z).
(2.101)
Note how similar this is to Eq. (2.99).
Example 2.102. Let V  Bool. Here is an example of matrix multiplication M ‚àóN. Here
X  {1, 2, 3}, Y  {1, 2}, and Z  {1, 2, 3}, matrices M : X √ó Y ‚ÜíB and N : Y √ó Z ‚ÜíB
are shown to the left below, and their product is shown to the right:
¬©¬≠¬≠
¬´
false
false
false
true
true
true
¬™¬Æ¬Æ
¬¨
‚àó
 
true
true
false
true
false
true
!

¬©¬≠¬≠
¬´
false
false
false
true
false
true
true
true
true
¬™¬Æ¬Æ
¬¨
The identity V-matrix on a set X is IX : X √ó X ‚ÜíV given by
IX(x, y) B
(
I
if x  y
0
if x , y.
Exercise 2.103. Write down the 2√ó2-identity matrix for each of the quantales (N, ‚â§, 1, ‚àó),
Bool  (B, ‚â§, true, ‚àß), and Cost  ([0, ‚àû], ‚â•, 0, +).
‚ô¶
Exercise 2.104.
Let V  (V, ‚â§, I, ‚äó, ‚ä∏) be a quantale. Use Eq. (2.101) and Proposi-
tion 2.87 to prove the following.
1. Prove the identity law: for any sets X and Y and V-matrix M : X √ó Y ‚ÜíV, one
has IX ‚àóM  M.
2. Prove the associative law: for any matrices M : W √ó X ‚ÜíV, N : X √ó Y ‚ÜíV, and
P : Y √ó Z ‚ÜíV, one has (M ‚àóN) ‚àóP  M ‚àó(N ‚àóP).
‚ô¶
Recall the weighted graph Y from Eq. (2.56). One can read oÔ¨Äthe associated matrix
MY, and one can calculate the associated metric dY:
x‚Ä¢
‚Ä¢
y
z‚Ä¢
3
4
3
4
Y B
MY
x
y
z
x
0
4
3
y
3
0
‚àû
z
‚àû
4
0
dY
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
Here we fully explain how to compute dY using only MY.
The matrix MY can be thought of as recording the length of paths that traverse either
0 or 1 edges: the diagonals being 0 mean we can get from x to x without traversing any

2.6. SUMMARY AND FURTHER READING
75
edges. When we can get from x to y in one edge we record its length in MY, otherwise
we use ‚àû.
When we multiply MY by itself using the formula Eq. (2.101), the result M2
Y tells us
the length of the shortest path traversing 2 edges or fewer. Similarly M3
Y tells us about
the shortest path traversing 3 edges or fewer:
M2
Y 
‚Üó
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
M3
Y 
‚Üó
x
y
z
x
0
4
3
y
3
0
6
z
7
4
0
One sees that the powers stabilize: M2
Y  M3
Y; as soon as that happens one has the
matrix of distances, dY. Indeed Mn
Y records the lengths of the shortest path traverse n
edges or fewer, and the powers will always stabilize if the set of vertices is Ô¨Ånite, since
the shortest path from one vertex to another will never visit a given vertex more than
once.7
Exercise 2.105.
Recall from Exercise 2.60 the matrix MX, for X as in Eq. (2.56). Cal-
culate M2
X, M3
X, and M4
X. Check that M4
X is what you got for the distance matrix in
Exercise 2.58.
‚ô¶
This procedure gives an algorithm for computing the V-category presented by any
V-weighted graph using matrix multiplication.
2.6
Summary and further reading
In this chapter we thought of elements of preorders as describing resources, with the or-
der detailing whether one resource could be obtained from another. This naturally led
to the question of how to describe what could be built from a pair of resources, which
led us to consider monoid structures on preorders. More abstractly, these monoidal
preorders were seen to be examples of enriched categories, or V-categories, over the
symmetric monoidal preorder Bool. Changing Bool to the symmetric monoidal pre-
order Cost, we arrived upon Lawvere metric spaces, a slight generalization of the
usual notion of metric space. In terms of resources, Cost-categories tell us the cost of
obtaining one resource from another.
At this point, we sought to get a better feel for V-categories in two ways. First, we
introduced various important constructions: base change, functors, products. Second,
we looked at how to present V-categories using labelled graphs; here, perhaps surpris-
ingly, we saw that matrix multiplication gives an algorithm to compute the hom-objects
from a labelled graph.
Resource theories are discussed in much more detail in [CFS16; Fri17]. The authors
provide many more examples of resource theories in science, including in thermody-
7The method works even in the inÔ¨Ånite case: one takes the inÔ¨Åmum of all powers Mn
Y. The result
always deÔ¨Ånes a Lawvere metric space.

76
CHAPTER 2. RESOURCES: MONOIDAL PREORDERS AND ENRICHMENT
namics, Shannon‚Äôs theory of communication channels, and quantum entanglement.
They also discuss more of the numerical theory than we did, including calculating the
asymptotic rate of conversion from one resource into another.
Enrichment is a fundamental notion in category theory, and we will we return to it
in Chapter 4, generalizing the deÔ¨Ånition so that categories, rather than mere preorders,
can serve as bases of enrichment. In this more general setting we can still perform
the constructions we introduced in Section 2.4‚Äîbase change, functors, products‚Äîand
many others; the authoratitive, but by no means easy, reference on this is the book by
Kelly [Kel05].
While preorders were familiar before category theory came along, Lawvere metric
spaces are a beautiful generalization of the previous notion of (symmetric) metric
space, that is due to, well, Lawvere.
A deeper exploration than the taste we gave
here can be found in his classic paper [Law73], where he also discusses ideas like
Cauchy completeness in category-theoretic terms, and which hence generalize to other
categorical settings.
We observed that while any symmetric monoidal preorder can serve as a base
for enrichment, certain preorders‚Äîquantales‚Äîare better than others. Quantales are
well known for links to other parts of mathematics too. The word quantale is in fact a
portmanteau of ‚Äòquantum locale‚Äô, where quantum refers to quantum physics, and locale
is a fundamental structure in topology. For a book-length introduction of quantales and
their applications, one might check [Ros90]. The notion of cartesian closed categories,
later generalized to monoidal closed categories, is due to Ronnie Brown [Bro61].
Note that while we have only considered commutative quantales, the noncommu-
tative variety also arise naturally. For example, the power set of any monoid forms
a quantale that is commutative iÔ¨Äthe monoid is. Another example is the set of all
binary relations on a set X, where multiplication is relational composition; this is
non-commutative. Such noncommutative quantales have application to concurrency
theory, and in particular process semantics and automata; see [AV93] for details.

Chapter 3
Databases:
Categories, functors, and universal
constructions
3.1
What is a database?
Integrating data from disparate sources is a major problem in industry today.
A
study in 2008 [BH08] showed that data integration accounts for 40% of IT (information
technology) budgets, and that the market for data integration software was $2.5 billion
in 2007 and increasing at a rate of more than 8% per year. In other words, it is a major
problem; but what is it?
A database is a system of interlocking tables.
Data becomes information when it is
stored in a given formation. That is, the numbers and letters don‚Äôt mean anything until
they are organized, often into a system of interlocking tables. An organized system of
interlocking tables is called a database. Here is a favorite example:
Employee
FName
WorksIn
Mngr
1
Alan
101
2
2
Ruth
101
2
3
Kris
102
3
Department
DName
Secr
101
Sales
1
102
IT
3
(3.1)
These two tables interlock by use of a special left-hand column, demarcated by
a vertical line; it is called the ID column. The ID column of the Ô¨Årst table is called
‚ÄòEmployee,‚Äô and the ID column of the second table is called ‚ÄòDepartment.‚Äô The entries
in the ID column‚Äîe.g. 1, 2, 3 or 101, 102‚Äîare like row labels; they indicate a whole
row of the table they‚Äôre in. Thus each row label must be unique (no two rows in a table
can have the same label), so that it can unambiguously specify its row.
77

78
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Each table‚Äôs ID column, and the set of unique identiÔ¨Åers found therein, is what
allows for the interlocking mentioned above. Indeed, other entries in various tables
can reference rows in a given table by use of its ID column. For example, each entry
in the WorksIn column references a department for each employee; each entry in the
Mngr (manager) column references an employee for each employee, and each entry in
the Secr (secretary) column references an employee for each department. Managing all
this cross-referencing is the purpose of databases.
Looking back at Eq. (3.1), one might notice that every non-ID column, found in either
table, is a reference to a label of some sort. Some of these, namely WorksIn, Mngr, and
Secr, are internal references, often called foreign keys; they refer to rows (keys) in the
ID column of some (foreign) table. Others, namely FName and DName, are external
references; they refer to strings or integers, which can also be thought of as labels, whose
meaning is known more broadly. Internal reference labels can be changed as long as
the change is consistent‚Äî1 could be replaced by 1001 everywhere without changing
the meaning‚Äîwhereas external reference labels certainly cannot! Changing Ruth to
Bruce everywhere would change how people understood the data.
The reference structure for a given database‚Äîi.e. how tables interlock via foreign
keys‚Äîtells us something about what information was intended to be stored in it. One
may visualize the reference structure for Eq. (3.1) graphically as follows:
easySchema B
Employee
‚Ä¢
Department
‚Ä¢
string
‚ó¶
WorksIn
FName
Mngr
Secr
DName
(3.2)
This is a kind of ‚ÄúHasse diagram for a database,‚Äù much like the Hasse diagrams for
preorders in Remark 1.39. How should you read it?
The two tables from Eq. (3.1) are represented in the graph (3.2) by the two black
nodes, which are given the same name as the ID columns: Employee and Department.
There is another node‚Äîdrawn white rather than black‚Äîwhich represents the external
reference type of strings, like ‚ÄúAlan,‚Äù ‚ÄúAlpha,‚Äù and ‚ÄúSales". The arrows in the diagram
represent non-ID columns of the tables; they point in the direction of reference: WorksIn
refers an employee to a department.
Exercise 3.3.
Count the number of non-ID columns in Eq. (3.1). Count the number of
arrows (foreign keys) in Eq. (3.2). They should be the same number in this case; is this
a coincidence?
‚ô¶
A Hasse-style diagram like the one in Eq. (3.2) can be called a database schema; it
represents how the information is being organized, the formation in which the data is
kept. One may add rules, sometimes called ‚Äòbusiness rules‚Äô to the schema, in order to
ensure the integrity of the data. If these rules are violated, one knows that data being

3.1. WHAT IS A DATABASE?
79
entered does not conform to the way the database designers intended. For example,
the designers may enforce rules saying
‚Ä¢ every department‚Äôs secretary must work in that department;
‚Ä¢ every employee‚Äôs manager must work in the same department as the employee.
Doing so changes the schema, say from ‚ÄòeasySchema‚Äô (3.2) to ‚ÄòmySchema‚Äô below.
mySchema B
Employee
‚Ä¢
Department
‚Ä¢
string
‚ó¶
WorksIn
FName
Mngr
Secr
DName
Department.Secr.WorksIn = Department
Employee.Mngr.WorksIn = Employee.WorksIn
(3.4)
In other words, the diÔ¨Äerence is that easySchema plus constraints equals mySchema.
We will soon see that database schemas are categories C, that the data itself is given
by a ‚Äòset-valued‚Äô functor C ‚ÜíSet, and that databases can be mapped to each other via
functors C ‚ÜíD. In other words, there is a relatively large overlap between database
theory and category theory. This has been worked out in a number of papers; see
Section 3.6. It has also been implemented in working software, called FQL, which
stands for functorial query language. Here is example FQL code for the schema shown
above:
schema mySchema = {
nodes
Employee, Department;
attributes
DName : Department -> string,
FName : Employee
-> string;
arrows
Mngr
: Employee
-> Employee,
WorksIn : Employee
-> Department,
Secr
: Department -> Employee;
equations
Department.Secr.WorksIn = Department,
Employee.Mngr.WorksIn
= Employee.WorksIn;
}
Communication between databases.
We have said that databases are designed to
store information about something. But diÔ¨Äerent people or organizations might view
the same sort of thing in diÔ¨Äerent ways. For example, one bank stores its Ô¨Ånancial
records according to European standards and another does so according to Japanese
standards. If these two banks merge into one, they will need to be able to share their
data despite diÔ¨Äerences in the shape of their database schemas.

80
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Such problems are huge and intricate in general, because databases often comprise
hundreds or thousands of interlocking tables. Moreover, these problems occur more
frequently than just when companies want to merge. It is quite common that a given
company moves data between databases on a daily basis. The reason is that diÔ¨Äerent
ways of organizing information are convenient for diÔ¨Äerent purposes. Just like we pack
our clothes in a suitcase when traveling but use a closet at home, there is generally not
one best way to organize anything.
Category theory provides a mathematical approach for translating between these
diÔ¨Äerent organizational forms. That is, it formalizes a sort of automated reorganizing
process called data migration, which takes data that Ô¨Åts snugly in one schema and moves
it into another.
Here is a simple case. Imagine an airline company has two diÔ¨Äerent databases,
perhaps created at diÔ¨Äerent times, that hold roughly the same data.
$‚ó¶
Economy
‚Ä¢
First Class
‚Ä¢
string
‚ó¶
Price
Position
Price
Position
A B
$‚ó¶
Airline Seat
‚Ä¢
string
‚ó¶
Price
Position
: B
(3.5)
Schema A has more detail than schema B‚Äîan airline seat may be in Ô¨Årst class or
economy‚Äîbut they are roughly the same. We will see that they can be connected by a
functor, and that data conforming to A can be migrated through this functor to schema
B and vice versa.
The statistics at the beginning of this section show that this sort of problem‚Äî
when occurring at enterprise scale‚Äîcontinues to prove diÔ¨Écult and expensive. If one
attempts to move data from a source schema to a target schema, the migrated data
could fail to Ô¨Åt into the target schema or fail to satisfy some of its constraints. This
happens surprisingly often in the world of business: a night may be spent moving data,
and the next morning it is found to have arrived broken and unsuitable for further use.
In fact, it is believed that over half of database migration projects fail.
In this chapter, we will discuss a category-theoretic method for migrating data.
Using categories and functors, one can prove up front that a given data migration will
not fail, i.e. that the result is guaranteed to Ô¨Åt into the target schema and satisfy all its
constraints.
The material in this chapter gets to the heart of category theory: in particular, we
discuss categories, functors, natural transformations, adjunctions, limits, and colimits.
In fact, many of these ideas have been present in the discussion above:
‚Ä¢ The schema pictures, e.g. Eq. (3.4) depict categories C.

3.2. CATEGORIES
81
‚Ä¢ The instances, e.g. Eq. (3.1) are functors from C to a certain category called Set.
‚Ä¢ The implicit mapping in Eq. (3.5), which takes economy and Ô¨Årst class seats in A
to airline seats in B, constitutes a functor A ‚ÜíB.
‚Ä¢ The notion of data migration for moving data between schemas is formalized by
adjoint functors.
We begin in Section 3.2 with the deÔ¨Ånition of categories and a bunch of diÔ¨Äerent
sorts of examples. In Section 3.3 we bring back databases, in particular their instances
and the maps between them, by discussing functors and natural transformations. In
Section 3.4 we discuss data migration by way of adjunctions, which generalize the
Galois connections we introduced in Section 1.4. Finally in Section 3.5 we give a bonus
section on limits and colimits.1
3.2
Categories
A category C consists of four pieces of data‚Äîobjects, morphisms, identities, and a
composition rule‚Äîsatisfying two properties.
DeÔ¨Ånition 3.6. To specify a category C:
(i) one speciÔ¨Åes a collection2 Ob(C), elements of which are called objects.
(ii) for every two objects c, d, one speciÔ¨Åes a set C(c, d),3 elements of which are called
morphisms from c to d.
(iii) for every object c ‚ààOb(C), one speciÔ¨Åes a morphism idc ‚ààC(c, c), called the
identity morphism on c.
(iv) for every three objects c, d, e ‚ààOb(C) and morphisms f ‚ààC(c, d) and 1 ‚ààC(d, e),
one speciÔ¨Åes a morphism f # 1 ‚ààC(c, e), called the composite of f and 1.
We will sometimes write an object c ‚ààC, instead of c ‚ààOb(C). It will also be convenient
to denote elements f ‚ààC(c, d) as f : c ‚Üíd. Here, c is called the domain of f , and d is
called the codomain of f .
These constituents are required to satisfy two conditions:
(a) unitality: for any morphism f : c ‚Üíd, composing with the identities at c or d
does nothing: idc # f  f and f # idd  f .
(b) associativity: for any three morphisms f : c0 ‚Üíc1, 1 : c1 ‚Üíc2, and h : c2 ‚Üíc3,
the following are equal: ( f # 1) # h  f # (1 # h). We write this composite simply
as f # 1 # h.
1By ‚Äúbonus,‚Äù we mean that although not strictly essential to the understanding of this particular
chapter, limits and colimits will show up throughout the book and throughout one‚Äôs interaction with
category theory, and we think the reader will especially beneÔ¨Åt from this material in the long run.
2Here, a collection can be thought of as a bunch of things, just like a set, but that may be too large to
formally be a set. An example is the collection of all sets, which would run afoul of Russell‚Äôs paradox if it
were itself a set.
3This set C(c, d) is often denoted HomC(c, d), and called the ‚Äúhom-set from c to d.‚Äù The word ‚Äúhom‚Äù
stands for homomorphism, of which the word ‚Äúmorphism‚Äù is a shortened version.

82
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Our next goal is to give lots of examples of categories. Our Ô¨Årst source of examples
is that of free and Ô¨Ånitely-presented categories, which generalize the notion of Hasse
diagram from Remark 1.39.
3.2.1
Free categories
Recall from DeÔ¨Ånition 1.36 that a graph consists of two types of thing: vertices and
arrows. From there one can deÔ¨Åne paths, which are just head-to-tail sequences of
arrows. Every path p has a start vertex and an end vertex; if p goes from v to w, we
write p : v ‚Üíw. To every vertex v, there is a trivial path, containing no arrows, starting
and ending at v; we often denote it by idv or simply by v. We may also concatenate
paths: given p : v ‚Üíw and q : w ‚Üíx, their concatenation is denoted p # q, and it goes
v ‚Üíx.
In Chapter 1, we used graphs to depict preorders (V, ‚â§): the vertices form the
elements of the preorder, and we say that v ‚â§w if there is a path from v to w in G. We
will now use graphs in a very similar way to depict certain categories, known as free
categories. Then we will explain a strong relationship between preorders and categories
in Section 3.2.3.
DeÔ¨Ånition 3.7. For any graph G  (V, A, s, t), we can deÔ¨Åne a category Free(G), called
the free category on G, whose objects are the vertices V and whose morphisms from c to
d are the paths from c to d. The identity morphism on an object c is simply the trivial
path at c. Composition is given by concatenation of paths.
For example, we deÔ¨Åne 2 to be the free category generated by the graph shown
below:
2 B Free

v1‚Ä¢
v2‚Ä¢
f1

(3.8)
It has two objects v1 and v2, and three morphisms: idv1 : v1 ‚Üív1, f1 : v1 ‚Üív2, and
idv2 : v2 ‚Üív2. Here idv1 is the path of length 0 starting and ending at v1, f1 is the path
of length 1 consisting of just the arrow f1, and idv2 is the length 0 path at v2. As our
notation suggests, idv1 is the identity morphism for the object v1, and similarly idv2
for v2. As composition is given by concatenation, we have, for example idv1 # f1  f1,
idv2 # idv2  idv2, and so on.
From now on, we may elide the diÔ¨Äerence between a graph and the corresponding
free category Free(G), at least when the one we mean is clear enough from context.
Exercise 3.9.
For Free(G) to really be a category, we must check that this data we
speciÔ¨Åed obeys the unitality and associativity properties. Check that these are obeyed
for any graph G.
‚ô¶

3.2. CATEGORIES
83
Exercise 3.10.
The free category on the graph shown here:4
3 B Free

v1‚Ä¢
v2‚Ä¢
v3‚Ä¢
f1
f2

(3.11)
has three objects and six morphisms: the three vertices and six paths in the graph.
Create six names, one for each of the six morphisms in 3. Write down a six-by-six
table, label the rows and columns by the six names you chose.
1. Fill out the table by writing the name of the composite in each cell, when there is
a composite.
2. Where are the identities?
‚ô¶
Exercise 3.12.
Let‚Äôs make some deÔ¨Ånitions, based on the pattern above:
1. What is the category 1? That is, what are its objects and morphisms?
2. What is the category 0?
3. What is the formula for the number of morphisms in n for arbitrary n ‚ààN?
‚ô¶
Example 3.13 (Natural numbers as a free category). Consider the following graph:
‚Ä¢
z
s
(3.14)
It has only one vertex and one arrow, but it has inÔ¨Ånitely many paths.
Indeed, it
has a unique path of length n for every natural number n ‚ààN.
That is, Path 
{z, s, (s # s), (s # s # s), . . .}, where we write z for the length 0 path on z; it represents
the morphism idz. There is a one-to-one correspondence between Path and the natural
numbers, N  {0, 1, 2, 3, . . .}.
This is an example of a category with one object. A category with one object is called
a monoid, a notion we Ô¨Årst discussed in Example 2.6. There we said that a monoid is
a tuple (M, ‚àó, e) where ‚àó: M √ó M ‚ÜíM is a function and e ‚ààM is an element, and
m ‚àó1  m  1 ‚àóm and (m ‚àón) ‚àóp  m ‚àó(n ‚àóp).
The two notions may superÔ¨Åcially look diÔ¨Äerent, but it is easy to describe the
connection. Given a category C with one object, say ‚Ä¢, let M B C(‚Ä¢, ‚Ä¢), let e  id‚Ä¢, and
let ‚àó: C(‚Ä¢, ‚Ä¢) √ó C(‚Ä¢, ‚Ä¢) ‚ÜíC(‚Ä¢, ‚Ä¢) be the composition operation ‚àó #. The associativity
and unitality requirements for the monoid will be satisÔ¨Åed because C is a category.
Exercise 3.15.
In Example 3.13 we identiÔ¨Åed the paths of the loop graph (3.14) with
numbers n ‚ààN. Paths can be concatenated. Given numbers m, n ‚ààN, what number
corresponds to the concatenation of their associated paths?
‚ô¶
4As mentioned above, we elide the diÔ¨Äerence between the graph and the corresponding free category.

84
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
3.2.2
Presenting categories via path equations
So for any graph G, there is a free category on G. But we don‚Äôt have to stop there: we
can add equations between paths in the graph, and still get a category. We are only
allowed to equate two paths p and q when they are parallel, meaning they have the
same source vertex and the same target vertex.
A Ô¨Ånite graph with path equations is called a Ô¨Ånite presentation for a category, and the
category that results is known as a Ô¨Ånitely-presented category. Here are two examples:
Free_square B
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
f
1
h
i
no equations
Comm_square B
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
f
1
h
i
f # h  1 # i
Both of these are presentations of categories: in the left-hand one, there are no equations
so it presents a free category, as discussed in Section 3.2.1. The free square category
has ten morphisms, because every path is a unique morphism.
Exercise 3.16.
1. Write down the ten paths in the free square category above.
2. Name two diÔ¨Äerent paths that are parallel.
3. Name two diÔ¨Äerent paths that are not parallel.
‚ô¶
On the other hand, the category presented on the right has only nine morphisms,
because f #h and 1#i are made equal. This category is called the ‚Äúcommutative square.‚Äù
Its morphisms are
{A, B, C, D, f , 1, h, i, f # h}
One might say ‚Äúthe missing one is 1 # i,‚Äù but that is not quite right: 1 # i is there too,
because it is equal to f # h. As usual, A denotes idA, etc.
Exercise 3.17. Write down all the morphisms in the category presented by the following
diagram:
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
f
1
j
h
i
f # h  j  1 # i
‚ô¶
Example 3.18. We should also be aware that enforcing an equation between two mor-
phisms often implies additional equations. Here are two more examples of presenta-

3.2. CATEGORIES
85
tions, in which this phenomenon occurs:
C B
‚Ä¢
z
s
s # s  z
D B
‚Ä¢
z
s
s # s # s # s  s # s
In C we have the equation s # s  z. But this implies s # s # s  z # s  s! And similarly
we have s # s # s # s  z # z  z. The set of morphisms in C is in fact merely {z, s}, with
composition described by s # s  z # z  z, and z # s  s # z  s. In group theory, one
would speak of a group called Z/2Z.
Exercise 3.19.
Write down all the morphisms in the category D from Example 3.18.
‚ô¶
Remark 3.20. We can now see that the schemas in Section 3.1, e.g. Eqs. (3.2) and (3.4)
are Ô¨Ånite presentations of categories. We will come back to this idea in Section 3.3.
3.2.3
Preorders and free categories: two ends of a spectrum
Now that we have used graphs to depict preorders in Chapter 1 and categories above,
one may want to know the relationship between these two uses. The main idea we
want to explain now is that
‚ÄúA preorder is a category where every two parallel arrows are the same.‚Äù
Thus any preorder can be regarded as a category, and any category can be somehow
‚Äúcrushed down‚Äù into a preorder. Let‚Äôs discuss these ideas.
Preorders as categories.
Suppose (P, ‚â§) is a preorder. It speciÔ¨Åes a category P as
follows. The objects of P are precisely the elements of P; that is, Ob(P)  P. As for
morphisms, P has exactly one morphism p ‚Üíq if p ‚â§q and no morphisms p ‚Üíq if
p ‚â∞q. The fact that ‚â§is reÔ¨Çexive ensures that every object has an identity, and the fact
that ‚â§is transitive ensures that morphisms can be composed. We call P the category
corresponding to the preorder (P, ‚â§).
In fact, a Hasse diagram for a preorder can be thought of a presentation of a category
where, for all vertices p and q, every two paths from p ‚Üíq are declared equal. For
example, in Eq. (1.5) we saw a Hasse diagram that was like the graph on the left:
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
d
e
f
a
b
c
no equations?
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
d
e
f
a
b
c
a # d  b # e  c # f

86
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
The Hasse diagram (left) might look the most like the free category presentation (mid-
dle) which has no equations, but that is not correct.
The free category has three
morphisms (paths) from bottom object to top object, whereas preorders are categories
with at most one morphism between two given objects. Instead, the diagram on the
right, with these paths from bottom to top made equal, is the correct presentation for
the preorder on the left.
Exercise 3.21.
What equations would you need to add to the graphs below in order to
present the associated preorders?
G1 
‚Ä¢
‚Ä¢
f
1
G2 
‚Ä¢
f
G3 
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
f
1
h
i
G4 
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
f
1
h
‚ô¶
The preorder reÔ¨Çection of a category.
Given any category C, one can obtain a preorder
(C, ‚â§) from it by destroying the distinction between any two parallel morphisms. That
is, let C B Ob(C), and put c1 ‚â§c2 iÔ¨ÄC(c1, c2) , ¬ú. If there is one, or two, or Ô¨Åfty,
or inÔ¨Ånitely many morphisms c1 ‚Üíc2 in C, the preorder reÔ¨Çection does not see the
diÔ¨Äerence. But it does see the diÔ¨Äerence between some morphisms and no morphisms.
Exercise 3.22.
What is the preorder reÔ¨Çection of the category N from Example 3.13?
‚ô¶
We have only discussed adjoint functors between preorders, but soon we will discuss
adjoints in general. Here is a statement you might not understand exactly, but it‚Äôs true;
you can ask a category theory expert about it and they should be able to explain it to
you:
Considering a preorder as a category is right adjoint to turning a category
into a preorder by preorder reÔ¨Çection.
Remark 3.23 (Ends of a spectrum). The main point of this subsection is that both
preorders and free categories are speciÔ¨Åed by a graph without path equations, but they
denote opposite ends of a spectrum. In both cases, the vertices of the graph become
the objects of a category and the paths become morphisms. But in the case of free
categories, there are no equations so each path becomes a diÔ¨Äerent morphism. In
the case of preorders, all parallel paths become the same morphism. Every category
presentation, i.e. graph with some equations, lies somewhere in between the free
category (no equations) and its preorder reÔ¨Çection (all possible equations).
3.2.4
Important categories in mathematics
We have been talking about category presentations, but there are categories that are
best understood directly, not by way of presentations. Recall the deÔ¨Ånition of category

3.2. CATEGORIES
87
from DeÔ¨Ånition 3.6. The most important category in mathematics is the category of
sets.
DeÔ¨Ånition 3.24. The category of sets, denoted Set, is deÔ¨Åned as follows.
(i) Ob(Set) is the collection of all sets.
(ii) If S and T are sets, then Set(S, T)  { f : S ‚ÜíT | f is a function}.
(iii) For each set S, the identity morphism is the function idS : S ‚ÜíS given by
idS(s) B s for each s ‚ààS.
(iv) Given f : S ‚ÜíT and 1 : T ‚ÜíU, their composite is the function f # 1 : S ‚ÜíU
given by ( f # 1)(s) B 1( f (s)).
These deÔ¨Ånitions satisfy the unitality and associativity conditions, so Set is indeed a
category.
Closely related is the category FinSet. This is the category whose objects are Ô¨Ånite
sets and whose morphisms are functions between them.
Exercise 3.25.
Let 2  {1, 2} and 3  {1, 2, 3}. These are objects in the category Set
discussed in DeÔ¨Ånition 3.24. Write down all the elements of the set Set(2, 3); there
should be nine.
‚ô¶
Remark 3.26. You may have wondered what categories have to do with V-categories
(DeÔ¨Ånition 2.46); perhaps you think the deÔ¨Ånitions hardly look alike. Despite the term
‚Äòenriched category‚Äô, V-categories are not categories with extra structure. While some
sorts of V-categories, such as Bool-categories, i.e. preorders, can naturally be seen as
categories, other sorts, such as Cost-categories, cannot.
The reason for the importance of Set is that, if we generalize the deÔ¨Ånition of
enriched category (DeÔ¨Ånition 2.46), we Ô¨Ånd that categories in the sense of DeÔ¨Ånition 3.6
are exactly Set-categories‚Äîso categories are V-categories for a very special choice of V.
We‚Äôll come back to this in Section 4.4.4. For now, we simply remark that just like a deep
understanding of the category Cost‚Äîfor example, knowing that it is a quantale‚Äîyields
insight into Lawvere metric spaces, so the study of Set yields insights into categories.
There are many other categories that mathematicians care about:
‚Ä¢ Top: the category of topological spaces (neighborhood)
‚Ä¢ Grph: the category of graphs (connection)
‚Ä¢ Meas: the category of measure spaces (amount)
‚Ä¢ Mon: the category of monoids (action)
‚Ä¢ Grp: the category of groups (reversible action, symmetry)
‚Ä¢ Cat: the category of categories (action in context, structure)
But in fact, this does not at all do justice to the diversity of categories mathematicians
think about. They work with whatever category they Ô¨Ånd Ô¨Åts their purpose at the time,
like ‚Äòthe category of connected Riemannian manifolds of dimension at most 4‚Äô.
Here is one more source of examples: take any category you already have and
reverse all its morphisms; the result is again a category.

88
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.27. Let C be a category.
Its opposite, denoted Cop, is the category with
the same objects, Ob(Cop) B Ob(C), and for any two objects c, d ‚ààOb(C), one has
Cop(c, d) B C(d, c). Identities and composition are as in C.
3.2.5
Isomorphisms in a category
The previous sections have all been about examples of categories: free categories,
presented categories, and important categories in math. In this section, we brieÔ¨Çy
switch gears and talk about an important concept in category theory, namely the
concept of isomorphism.
In a category, there is often the idea that two objects are interchangeable.
For
example, in the category Set, one can exchange the set {‚ñ†, ‚ñ°} for the set {0, 1} and
everything will be the same, other than the names for the elements. Similarly, if one
has a preorder with elements a, b, such that a ‚â§b and b ‚â§a, i.e. a  b, then a and b are
essentially the same. How so? Well they act the same, in that for any other object c, we
know that c ‚â§a iÔ¨Äc ‚â§b, and c ‚â•a iÔ¨Äc ‚â•b. The notion of isomorphism formalizes
this notion of interchangeability.
DeÔ¨Ånition 3.28. An isomorphism is a morphism f : A ‚ÜíB such that there exists a
morphism 1 : B ‚ÜíA satisfying f # 1  idA and 1 # f  idB. In this case we call f and 1
inverses, and we often write 1  f ‚àí1, or equivalently f  1‚àí1. We also say that A and B
are isomorphic objects.
Example 3.29. The set A B {a, b, c} and the set 3  {1, 2, 3} are isomorphic; that is,
there exists an isomorphism f : A ‚Üí3 given by f (a)  2, f (b)  1, f (c)  3. The
isomorphisms in the category Set are the bƒ≥ections.
Recall that the cardinality of a Ô¨Ånite set is the number of elements in it. This can be
understood in terms of isomorphisms in FinSet. Namely, for any Ô¨Ånite set A ‚ààFinSet,
its cardinality is the number n ‚ààN such that there exists an isomorphism A  n. Georg
Cantor deÔ¨Åned the cardinality of any set X to be its isomorphism class, meaning the
equivalence class consisting of all sets that are isomorphic to X.
Exercise 3.30.
1. What is the inverse f ‚àí1 : 3 ‚ÜíA of the function f given in Example 3.29?
2. How many distinct isomorphisms are there A ‚Üí3?
‚ô¶
Exercise 3.31. Show that in any given category C, for any given object c ‚ààC, the identity
idc is an isomorphism.
‚ô¶
Exercise 3.32.
Recall Examples 3.13 and 3.18. A monoid in which every morphism is
an isomorphism is known as a group.
1. Is the monoid in Example 3.13 a group?

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
89
2. What about the monoid C in Example 3.18?
‚ô¶
Exercise 3.33.
Let G be a graph, and let Free(G) be the corresponding free category.
Somebody tells you that the only isomorphisms in Free(G) are the identity morphisms.
Is that person correct? Why or why not?
‚ô¶
Example 3.34. In this example, we will see that it is possible for 1 and f to be almost‚Äîbut
not quite‚Äîinverses, in a certain sense.
Consider the functions f : 2 ‚Üí3 and 1 : 3 ‚Üí2 drawn below:
‚Ä¢
1
‚Ä¢
2
‚Ä¢
1
‚Ä¢
2
‚Ä¢
3
‚Ä¢
1
‚Ä¢
2
‚Ä¢
3
‚Ä¢
1
‚Ä¢
2
Then the reader should be able to instantly check that f # 1  id2 but 1 # f , id3. Thus f
and 1 are not inverses and hence not isomorphisms. We won‚Äôt need this terminology,
but category theorists would say that f and 1 form a retraction.
3.3
Functors, natural transformations, and databases
In Section 3.1 we showed some database schemas: graphs with path equations. Then in
Section 3.2.2 we said that graphs with path equations correspond to Ô¨Ånitely-presented
categories.
Now we want to explain what the data in a database is, as a way to
introduce functors. To do so, we begin by noticing that sets and functions‚Äîthe objects
and morphisms in the category Set‚Äîcan be captured by particularly simple databases.
3.3.1
Sets and functions as databases
The Ô¨Årst observation is that any set can be understood as a table with only one column:
the ID column.
Planet of Sol
Mercury
Venus
Earth
Mars
Jupiter
Saturn
Uranus
Neptune
Prime number
2
3
5
7
11
13
17
...
Flying pig

90
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Rather than put the elements of the set between braces, e.g. {2, 3, 5, 7, 11, . . .}, we write
them down as rows in a table.
In databases, single-column tables are often called controlled vocabularies, or master
data. Now to be honest, we can only write out every single entry in a table when its
set of rows is Ô¨Ånite. A database practitioner might Ô¨Ånd the idea of our prime number
table a bit unrealistic. But we‚Äôre mathematicians, so since the idea makes perfect sense
abstractly, we will continue to think of sets as one-column tables.
The above databases have schemas consisting of just one vertex:
Planet of Sol
‚Ä¢
Prime number
‚Ä¢
Flying pig
‚Ä¢
Obviously, there‚Äôs really not much diÔ¨Äerence between these schemas, other than the
label of the unique vertex. So we could say ‚Äúsets are databases whose schema consists
of a single vertex.‚Äù Let‚Äôs move on to functions.
A function f : A ‚ÜíB can almost be depicted as a two-column table
Beatle
Played
George
Lead guitar
John
Rhythm guitar
Paul
Bass guitar
Ringo
Drums
except it is unclear whether the elements of the right-hand column exhaust all of B.
What if there are rock-and-roll instruments out there that none of the Beatles played?
So a function f : A ‚ÜíB requires two tables, one for A and its f column, and one for B:
Beatle
Played
George
Lead guitar
John
Rhythm guitar
Paul
Bass guitar
Ringo
Drums
Rock-and-roll instrument
Bass guitar
Drums
Keyboard
Lead guitar
Rhythm guitar
Thus the database schema for any function is just a labeled version of 2:
Beatle
‚Ä¢
Rock-and-roll
instrument
‚Ä¢
Played
The lesson is that an instance of a database takes a presentation of a category, and turns
every vertex into a set, and every arrow into a function. As such, it describes a map
from the presented category to the category Set. In Section 2.4.2 we saw that maps of
V-categories are known as V-functors. Similarly, we call maps of plain old categories,
functors.

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
91
3.3.2
Functors
A functor is a mapping between categories. It sends objects to objects and morphisms
to morphisms, all while preserving identities and composition. Here is the formal
deÔ¨Ånition.
DeÔ¨Ånition 3.35. Let C and D be categories. To specify a functor from C to D, denoted
F : C ‚ÜíD,
(i) for every object c ‚ààOb(C), one speciÔ¨Åes an object F(c) ‚ààOb(D);
(ii) for every morphism f : c1 ‚Üíc2 in C, one speciÔ¨Åes a morphism F( f ): F(c1) ‚Üí
F(c2) in D.
The above constituents must satisfy two properties:
(a) for every object c ‚ààOb(C), we have F(idc)  idF(c).
(b) for every three objects c1, c2, c3 ‚ààOb(C) and two morphisms f ‚ààC(c1, c2), 1 ‚àà
C(c2, c3), the equation F( f # 1)  F( f ) # F(1) holds in D.
Example 3.36. For example, here we draw three functors F : 2 ‚Üí3:
m0‚Ä¢
‚Ä¢
m1
f1
n0‚Ä¢
n1‚Ä¢
n2‚Ä¢
11
12
m0‚Ä¢
‚Ä¢
m1
f1
n0‚Ä¢
n1‚Ä¢
n2‚Ä¢
11
12
m0‚Ä¢
‚Ä¢
m1
f1
n0‚Ä¢
n1‚Ä¢
n2‚Ä¢
11
12
In each case, the dotted arrows show what the functor F does to the vertices in 2; once
that information is speciÔ¨Åed, it turns out‚Äîin this special case‚Äîthat what F does to
the three paths in 2 is completely determined. In the left-hand diagram, F sends every
path to the trivial path, i.e. the identity on n0. In the middle diagram F(m0)  n0,
F( f1)  11, and F(m1)  n1. In the right-hand diagram, F(m0)  n0, F(m1)  n2, and
F( f1)  11 # 12.
Exercise 3.37.
Above we wrote down three functors 2 ‚Üí3. Find and write down all
the remaining functors 2 ‚Üí3.
‚ô¶
Example 3.38. Recall the categories presented by Free_square and Comm_square in
Section 3.2.2. Here they are again, with ‚Ä≤ added to the labels in Free_square to help

92
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
distinguish them:
Free_square B
A‚Ä≤
‚Ä¢
B‚Ä≤
‚Ä¢
‚Ä¢
C‚Ä≤
‚Ä¢
D‚Ä≤
f ‚Ä≤
1‚Ä≤
h‚Ä≤
i‚Ä≤
no equations
Comm_square B
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
f
1
h
i
f # h  1 # i
There are lots of functors from the free square category (let‚Äôs call it F) to the commutative
square category (let‚Äôs call it C).
However, there is exactly one functor F : F ‚ÜíC that sends A‚Ä≤ to A, B‚Ä≤ to B, C‚Ä≤ to C,
and D‚Ä≤ to D. That is, once we have made this decision about how F acts on objects,
each of the ten paths in F is forced to go to a certain path in C: the one with the right
source and target.
Exercise 3.39.
Say where each of the ten morphisms in F is sent under the functor F
from Example 3.38.
‚ô¶
All of our example functors so far have been completely determined by what they
do on objects, but this is usually not the case.
Exercise 3.40.
Consider the free categories C  ‚Ä¢ ‚Üí‚Ä¢ and D  ‚Ä¢ ‚áí‚Ä¢ . Give two
functors F, G: C ‚ÜíD that act the same on objects but diÔ¨Äerently on morphisms.
‚ô¶
Example 3.41. There are also lots of functors from the commutative square category C
to the free square category F, but none that sends A to A‚Ä≤, B to B‚Ä≤, C to C‚Ä≤, and D to D‚Ä≤.
The reason is that if F were such a functor, then since f # h  1 # i in C, we would have
F( f # h)  F(1 # i), but then the rules of functors would let us reason as follows:
f ‚Ä≤ # h‚Ä≤  F( f ) # F(h)  F( f # h)  F(1 # i)  F(1) # F(i)  1‚Ä≤ # i‚Ä≤
The resulting equation, f ‚Ä≤ # h‚Ä≤  1‚Ä≤ # i‚Ä≤ does not hold in F because it is a free category
(there are ‚Äúno equations‚Äù): every two paths are considered diÔ¨Äerent morphisms. Thus
our proposed F is not a functor.
Example 3.42 (Functors between preorders are monotone maps). Recall from Sec-
tion 3.2.3 that preorders are categories with at most one morphism between any two
objects. A functor between preorders is exactly a monotone map.
For example, consider the preorder (N, ‚â§) considered as a category N with objects
Ob(N)  N and a unique morphism m ‚Üín iÔ¨Äm ‚â§n. A functor F : N ‚ÜíN sends
each object n ‚ààN to an object F(n) ‚ààN. It must send morphisms in N to morphisms
in N. This means if there is a morphism m ‚Üín then there had better be a morphism
F(m) ‚ÜíF(n). In other words, if m ‚â§n, then we had better have F(m) ‚â§F(n). But as

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
93
long as m ‚â§n implies F(m) ‚â§F(n), we have a functor.
Thus a functor F : N ‚ÜíN and a monotone map N ‚ÜíN are the same thing.
Exercise 3.43 (The category of categories).
Back in the primordial ooze, there is a
category Cat in which the objects are themselves categories. Your task here is to construct
this category.
1. Given any category C, show that there exists a functor idC : C ‚ÜíC, known as the
identity functor on C, that maps each object to itself and each morphism to itself.
Note that a functor C ‚ÜíD consists of a function from Ob(C) to Ob(D) and for each
pair of objects c1, c2 ‚ààC a function from C(c1, c2) to D(F(c1), F(c2)).
2. Show that given F : C ‚ÜíD and G: D ‚ÜíE, we can deÔ¨Åne a new functor (F #
G): C ‚ÜíE just by composing functions.
3. Show that there is a category, call it Cat, where the objects are categories, mor-
phisms are functors, and identities and composition are given as above.
‚ô¶
3.3.3
Database instances as Set-valued functors
Let C be a category, and recall the category Set from DeÔ¨Ånition 3.24. A functor F : C ‚Üí
Set is known as a set-valued functor on C. Much of database theory (not how to make
them fast, but what they are and what you do with them) can be cast in this light.
Indeed, we already saw in Remark 3.20 that any database schema can be regarded as
(presenting) a category C. The next thing to notice is that the data itself‚Äîany instance
of the database‚Äîis given by a set-valued functor I : C ‚ÜíSet. The only additional
detail is that for any white node, such as c 
string
‚ó¶, we want to force I to map to the set
of strings. We suppress this detail in the following deÔ¨Ånition.
DeÔ¨Ånition 3.44. Let C be a schema, i.e. a Ô¨Ånitely-presented category. A C-instance is a
functor I : C ‚ÜíSet.5
Exercise 3.45. Let 1 denote the category with one object, called 1, one identity morphism
id1, and no other morphisms. For any functor F : 1 ‚ÜíSet one can extract a set F(1).
Show that for any set S, there is a functor FS : 1 ‚ÜíSet such that FS(1)  S.
‚ô¶
The above exercise reaÔ¨Érms that the set of planets, the set of prime numbers, and
the set of Ô¨Çying pigs are all set-valued functors‚Äîinstances‚Äîon the schema 1. Similarly,
set-valued functors on the category 2 are functions. All our examples so far are for the
situation where the schema is a free category (no equations). Let‚Äôs try an example of a
category that is not free.
5Warning: a C-instance is a state of the database ‚Äúat an instant in time.‚Äù The term ‚Äúinstance‚Äù should
not be confused with its usage in object oriented programming, which would correspond more to what
we call a row r ‚ààI(c).

94
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.46. Consider the following category:
C B
‚Ä¢
z
s
s # s  s
(3.47)
What is a set-valued functor F : C ‚ÜíSet? It will consist of a set Z B F(z) and a function
S B F(s): Z ‚ÜíZ, subject to the requirement that S # S  S. Here are some examples
‚Ä¢ Z is the set of US citizens, and S sends each citizen to her or his president. The
president‚Äôs president is her- or him-self.
‚Ä¢ Z  N is the set of natural numbers and S sends each number to 0. In particular,
0 goes to itself.
‚Ä¢ Z is the set of all well-formed arithmetic expressions, such as 13+(2‚àó4) or ‚àí5, that
one can write using integers and the symbols +, ‚àí, ‚àó, (, ). The function S evaluates
the expression to return an integer, which is itself a well-formed expression. The
evaluation of an integer is itself.
‚Ä¢ Z  N‚â•2, and S sends n to its smallest prime factor. The smallest prime factor of
a prime is itself.
N‚â•2
smallest prime factor
2
2
3
3
4
2
...
...
49
7
50
2
51
3
...
...
Exercise 3.48.
Above, we thought of the sort of data that would make sense for the
schema (3.47). Give an example of the sort of data that would make sense for the
following schemas:
1.
‚Ä¢
z
s
s # s  z
2.
a‚Ä¢
b‚Ä¢
c‚Ä¢
f
1
h
f # 1  f # h
‚ô¶
The main idea is this: a database schema is a category, and an instance on that
schema‚Äîthe data itself‚Äîis a set-valued functor. All the constraints, or business rules,
are ensured by the rules of functors, namely that functors preserve composition.6
6One can put more complex constraints, called embedded dependencies, on a database; these correspond
category theoretically to what are called ‚Äúlifting problems‚Äù in category theory. See [Spi14b] for more on
this.

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
95
3.3.4
Natural transformations
If C is a schema‚Äîi.e. a Ô¨Ånitely-presented category‚Äîthen there are many database
instances on it, which we can organize into a category. But this is part of a larger story,
namely that of natural transformations. An abstract picture to have in mind is this:
C
D.
F
G
Œ±
DeÔ¨Ånition 3.49. Let C and D be categories, and let F, G: C ‚ÜíD be functors. To specify
a natural transformation Œ±: F ‚áíG,
(i) for each object c ‚ààC, one speciÔ¨Åes a morphism Œ±c : F(c) ‚ÜíG(c) in D, called the
c-component of Œ±.
These components must satisfy the following, called the naturality condition:
(a) for every morphism f : c ‚Üíd in C, the following equation must hold:
F( f ) # Œ±d  Œ±c # G( f ).
A natural transformation Œ±: F ‚ÜíG is called a natural isomorphism if each component
Œ±c is an isomorphism in D.
The naturality condition can also be written as a so-called commutative diagram. A
diagram in a category is drawn as a graph whose vertices and arrows are labeled by
objects and morphisms in the category. For example, here is a diagram that‚Äôs relevant
to the naturality condition in DeÔ¨Ånition 3.49:
F(c)
G(c)
F(d)
G(d)
Œ±c
F( f )
G( f )
Œ±d
(3.50)
DeÔ¨Ånition 3.51. A diagram D in C is a functor D : J ‚ÜíC from any category J, called
the indexing category of the diagram D. We say that D commutes if D( f )  D( f ‚Ä≤) holds
for every parallel pair of morphisms f , f ‚Ä≤: a ‚Üíb in J.7
In terms of Eq. (3.50), the only case of two parallel morphisms is that of F(c) ‚áíG(d),
so to say that the diagram commutes is to say that F( f ) # Œ±d  Œ±c # G( f ). This is exactly
the naturality condition from DeÔ¨Ånition 3.49.
7We could package this formally by saying that D commutes iÔ¨Äit factors through the preorder
reÔ¨Çection of J.

96
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.52. A representative picture is as follows:
1‚Ä¢
2‚Ä¢
f
C B
u‚Ä¢
v‚Ä¢
w‚Ä¢
x‚Ä¢
y
‚Ä¢
z‚Ä¢
a
b
d
c
e
1
h
k
: D
F
G
We have depicted, in blue and red respectively, two functors F, G: C ‚ÜíD. A natural
transformation Œ±: F ‚áíG is given by choosing components Œ±1 : v ‚Üíx and Œ±2 : w ‚Üíy.
We have highlighted the only choice for each in green; namely, Œ±1  c and Œ±2  1.
The key point is that the functors F and G are ways of viewing the category C as
lying inside the category D. The natural transformation Œ±, then, is a way of relating
these two views using the morphisms in D. Does this help you to see and appreciate
the notation C
D?
F
G
Œ±‚áì
Example 3.53. We said in Exercise 3.45 that a functor 1 ‚ÜíSet can be identiÔ¨Åed with
a set. So suppose A and B are sets considered as functors A, B : 1 ‚ÜíSet. A natural
transformation between these functors is just a function between the sets.
DeÔ¨Ånition 3.54. Let C and D be categories. We denote by DC the category whose objects
are functors F : C ‚ÜíD and whose morphisms DC(F, G) are the natural transformations
Œ±: F ‚ÜíG. This category DC is called the functor category, or the category of functors from
C to D.
Exercise 3.55.
Let‚Äôs look more deeply at how DC is a category.
1. Figure out how to compose natural transformations. (Hint: an expert tells you
‚Äúfor each object c ‚ààC, compose the c-components.‚Äù)
2. Propose an identity natural transformation on any object F ‚ààDC, and check that
it is unital (i.e. that it obeys condition (a) of DeÔ¨Ånition 3.6).
‚ô¶
Example 3.56. In our new language, Example 3.53 says that Set1 is equivalent to Set.
Example 3.57. Let N denote the category associated to the preorder (N, ‚â§), and recall
from Example 3.42 that we can identify a functor F : N ‚ÜíN with a non-decreasing
sequence (F0, F1, F2, . . .) of natural numbers, i.e. F0 ‚â§F1 ‚â§F2 ‚â§¬∑ ¬∑ ¬∑ . If G is another
functor, considered as a non-decreasing sequence, then what is a natural transformation

3.3. FUNCTORS, NATURAL TRANSFORMATIONS, AND DATABASES
97
Œ±: F ‚ÜíG?
Since there is at most one morphism between two objects in a preorder, each com-
ponent Œ±n : Fn ‚ÜíGn has no data, it just tells us a fact: that Fn ‚â§Gn. And the naturality
condition is vacuous: every square in a preorder commutes. So a natural transforma-
tion between F and G exists iÔ¨ÄFn ‚â§Gn for each n, and any two natural transformations
F ‚áíG are the same. In other words, the category NN is itself a preorder; namely the
preorder of monotone maps N ‚ÜíN.
Exercise 3.58.
Let C be an arbitrary category and let P be a preorder, thought of as a
category. Consider the following statements:
1. For any two functors F, G: C ‚ÜíP, there is at most one natural transformation
F ‚ÜíG.
2. For any two functors F, G: P ‚ÜíC, there is at most one natural transformation
F ‚ÜíG.
For each, if it is true, say why; if it is false, give a counterexample.
‚ô¶
Remark 3.59. Recall that in Remark 2.71 we said the category of preorders is equivalent to
the category of Bool-categories. We can now state the precise meaning of this sentence.
First, there exists a category PrO in which the objects are preorders and the morphisms
are monotone maps. Second, there exists a category Bool-Cat in which the objects are
Bool-categories and the morphisms are Bool-functors. We call these two categories
equivalent because there exist functors F : PrO ‚ÜíBool-Cat and G: Bool-Cat ‚ÜíPrO
such that there exist natural isomorphisms F # G  idPrO and G # F  idBool-Cat in the
sense of DeÔ¨Ånition 3.49.
3.3.5
The category of instances on a schema
DeÔ¨Ånition 3.60. Suppose that C is a database schema and I, J : C ‚ÜíSet are database
instances. An instance homomorphism between them is a natural transformation Œ±: I ‚Üí
J. Write C-Inst B SetC to denote the functor category as deÔ¨Åned in DeÔ¨Ånition 3.54.
We saw in Example 3.53 that 1-Inst is equivalent to the category Set.
In this
subsection, we will show that there is a schema whose instances are graphs and whose
instance homomorphisms are graph homomorphisms.
Extended example: the category of graphs as a functor category.
You may Ô¨Ånd
yourself back in the primordial ooze (Ô¨Årst discussed in Section 2.3.2), because while
previously we have been using graphs to present categories, now we obtain graphs
themselves as database instances on a speciÔ¨Åc schema (which is itself a graph):
Gr B
Arrow
‚Ä¢
Vertex
‚Ä¢
source
target
no equations

98
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Here‚Äôs an example Gr-instance, i.e. set-valued functor I : Gr ‚ÜíSet, in table form:
Arrow
source
target
a
1
2
b
1
3
c
1
3
d
2
2
e
2
3
Vertex
1
2
3
4
(3.61)
Here I(Arrow)  {a, b, c, d, e}, and I(Vertex)  {1, 2, 3, 4}. One can draw the instance
I as a graph:
I 
1‚Ä¢
2‚Ä¢
3‚Ä¢
4‚Ä¢
a
b
c
e
d
Every row in the Vertex table is drawn as a vertex, and every row in the Arrow table
is drawn as an arrow, connecting its speciÔ¨Åed source and target. Every possible graph
can be written as a database instance on the schema Gr, and every possible Gr-instance
can be represented as a graph.
Exercise 3.62.
In Eq. (3.2), a graph is shown (forget the distinction between white and
black nodes). Write down the corresponding Gr-instance, as in Eq. (3.61). (Do not be
concerned that you are in the primordial ooze.)
‚ô¶
Thus the objects in the category Gr-Inst are graphs. The morphisms in Gr-Inst
are called graph homomorphisms. Let‚Äôs unwind this. Suppose that G, H : Gr ‚ÜíSet
are functors (i.e. Gr-instances); that is, they are objects G, H ‚ààGr-Inst. A morphism
G ‚ÜíH is a natural transformation Œ±: G ‚ÜíH between them; what does that entail?
By DeÔ¨Ånition 3.49, since Gr has two objects, Œ± consists of two components,
Œ±Vertex : G(Vertex) ‚ÜíH(Vertex)
and
Œ±Arrow : G(Arrow) ‚ÜíH(Arrow),
both of which are morphisms in Set. In other words, Œ± consists of a function from
vertices of G to vertices of H and a function from arrows of G to arrows of H. For these
functions to constitute a graph homomorphism, they must ‚Äúrespect source and target‚Äù
in the precise sense that the naturality condition, Eq. (3.50) holds. That is, for every
morphism in Gr, namely source and target, the following diagrams must commute:
G(Arrow)
H(Arrow)
G(Vertex)
H(Vertex)
Œ±Arrow
G(source)
H(source)
Œ±Vertex
G(Arrow)
H(Arrow)
G(Vertex)
H(Vertex)
Œ±Arrow
G(target)
H(target)
Œ±Vertex
These may look complicated, but they say exactly what we want. We want the functions
Œ±Vertex and Œ±Arrow to respect source and targets in G and H. The left diagram says ‚Äústart

3.4. ADJUNCTIONS AND DATA MIGRATION
99
with an arrow in G. You can either apply Œ± to the arrow and then take its source in H,
or you can take its source in G and then apply Œ± to that vertex; either way you get the
same answer.‚Äù The right-hand diagram says the same thing about targets.
Example 3.63. Consider the graphs G and H shown below
G B
1‚Ä¢
2‚Ä¢
3‚Ä¢
a
b
H B
4‚Ä¢
5‚Ä¢
c
d
e
Here they are, written as database instances‚Äîi.e. set-valued functors‚Äîon Gr:
G B
Arrow
source
target
a
1
2
b
2
3
Vertex
1
2
3
H B
Arrow
source
target
c
4
5
d
4
5
e
5
5
Vertex
4
5
The top row is G and the bottom row is H. They are oÔ¨Äset so you can more easily
complete the following exercise.
Exercise 3.64.
We claim that‚Äîwith G, H as in Example 3.63‚Äîthere is exactly one
graph homomorphism Œ±: G ‚ÜíH such that Œ±Arrow(a)  d.
1. What is the other value of Œ±Arrow, and what are the three values of Œ±Vertex?
2. In your own copy of the tables of Example 3.63, draw Œ±Arrow as two lines connect-
ing the cells in the ID column of G(Arrow) to those in the ID column of H(Arrow).
Similarly, draw Œ±Vertex as connecting lines.
3. Check the source column and target column and make sure that the matches are
natural, i.e. that ‚Äúalpha-then-source equals source-then-alpha‚Äù and similarly for
‚Äútarget.‚Äù
‚ô¶
3.4
Adjunctions and data migration
We have talked about how set-valued functors on a schema can be understood as Ô¨Ålling
that schema with data. But there are also functors between schemas. When the two
sorts of functors are composed, data is migrated. This is the simplest form of data
migration; more complex ways to migrate data come from using adjoints. All of the
above is the subject of this section.

100
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
3.4.1
Pulling back data along a functor
To begin, we will migrate data between the graph-indexing schema Gr and the loop
schema, which we call DDS, shown below
Gr B
Arrow
‚Ä¢
Vertex
‚Ä¢
source
target
no equations
DDS B
State
‚Ä¢
next
no equations
We begin by writing down a sample instance I : DDS ‚ÜíSet on this schema:
State
next
1
4
2
4
3
5
4
5
5
5
6
7
7
6
(3.65)
We call the schema DDS to stand for discrete dynamical system. Indeed, we may think
of the data in the DDS-instance of Eq. (3.65) as listing the states and movements of a
deterministic machine: at every point in time the machine is in one of the listed states,
and given the machine in one of the states, in the next instant it moves to a uniquely
determined next state.
Our goal is to migrate the data in Eq. (3.65) to data on Gr; this will give us the data
of a graph and so allow us to visualise our machine.
We will use a functor connecting these schemas in order to move data between
them. The reader can create any functor she likes, but we will use a speciÔ¨Åc functor
F : Gr ‚ÜíDDS to migrate data in a way that makes sense to us, the authors. Here we
draw F, using colors to hopefully aid understanding:
Arrow
‚Ä¢
Vertex
‚Ä¢
source
target
Gr
State
‚Ä¢
next
DDS
F
The functor F sends both objects of Gr to the ‚ÄòState‚Äô object of DDS (as it must). On
morphisms, it sends the ‚Äòsource‚Äô morphism to the identity morphism on ‚ÄòState‚Äô, and
the ‚Äòtarget‚Äô morphism to the morphism ‚Äònext‚Äô.

3.4. ADJUNCTIONS AND DATA MIGRATION
101
A sample database instance on DDS was given in Eq. (3.65); recall this is a functor
I : DDS ‚ÜíSet. So now we have two functors as follows:
Gr
DDS
Set.
F
I
(3.66)
Objects in Gr are sent by F to objects in DDS, which are sent by I to objects in Set,
which are sets. Morphisms in Gr are sent by F to morphisms in DDS, which are
sent by I to morphisms in Set, which are functions. This deÔ¨Ånes a composite functor
F #I : Gr ‚ÜíSet. Both F and I respect identities and composition, so F #I does too. Thus
we have obtained an instance on Gr, i.e. we have converted our discrete dynamical
system from Eq. (3.65) into a graph! What graph is it?
For an instance on Gr, we need to Ô¨Åll an Arrow table and a Vertex table. Both
of these are sent by F to State, so let‚Äôs Ô¨Åll both with the rows of State in Eq. (3.65).
Similarly, since F sends ‚Äòsource‚Äô to the identity and sends ‚Äòtarget‚Äô to ‚Äònext‚Äô, we obtain
the following tables:
Arrow
source
target
1
1
4
2
2
4
3
3
5
4
4
5
5
5
5
6
6
7
7
7
6
Vertex
1
2
3
4
5
6
7
Now that we have a graph, we can draw it.
1‚Ä¢
2‚Ä¢
3‚Ä¢
4‚Ä¢
6‚Ä¢
7‚Ä¢
‚Ä¢
5
1
2
3
4
6
7
5
Each arrow is labeled by its source vertex, as if to say, ‚ÄúWhat I do next is determined
by what I am now.‚Äù
Exercise 3.67.
Consider the functor G: Gr ‚ÜíDDS given by sending ‚Äòsource‚Äô to ‚Äònext‚Äô
and sending ‚Äòtarget‚Äô to the identity on ‚ÄòState‚Äô.
Migrate the same data, called I in
Eq. (3.65), using the functor G. Write down the tables and draw the corresponding
graph.
‚ô¶
We refer to the above procedure‚Äîbasically just composing functors as in Eq. (3.66)‚Äî
as ‚Äúpulling back data along a functor.‚Äù We just now pulled back data I along functor
F.

102
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
DeÔ¨Ånition 3.68. Let C and D be categories and let F : C ‚ÜíD be a functor. For any
set-valued functor I : D ‚ÜíSet, we refer to the composite functor F # I : C ‚ÜíSet as the
pullback of I along F.
Given a natural transformation Œ±: I ‚áíJ, there is a natural transformation Œ±F : F#I ‚áí
F # J, whose component (F # I)(c) ‚Üí(F # J)(c) for any c ‚ààOb(C) is given by (Œ±F)c B Œ±Fc.
C
D
Set
F
I
J
Œ±
{
C
Set
F#I
F#J
Œ±F
This uses the data of F to deÔ¨Åne a functor ‚àÜF : D-Inst ‚ÜíC-Inst.
Note that the term pullback is also used for a certain sort of limit, for more details
see Remark 3.100.
3.4.2
Adjunctions
In Section 1.4 we discussed Galois connections, which are adjunctions between pre-
orders. Now that we‚Äôve deÔ¨Åned categories and functors, we can discuss adjunctions
in general. The relevance to databases is that the data migration functor ‚àÜfrom DeÔ¨Å-
nition 3.68 always has two adjoints of its own: a left adjoint which we denote Œ£ and a
right adjoint which we denote Œ†.
Recall that an adjunction between preorders P and Q is a pair of monotone maps
f : P ‚ÜíQ and 1 : Q ‚ÜíP that are almost inverses: we have
f (p) ‚â§q if and only if p ‚â§1(q).
(3.69)
Recall from Section 3.2.3 that in a preorder P, a hom-set P(a, b) has one element when
a ‚â§b, and no elements otherwise. We can thus rephrase Eq. (3.69) as an isomorphism
of sets Q( f (p), q)  P(p, 1(q)): either both are one-element sets or both are 0-element
sets. This suggests how to deÔ¨Åne adjunctions in the general case.
DeÔ¨Ånition 3.70. Let C and D be categories, and L: C ‚ÜíD and R: D ‚ÜíC be functors.
We say that L is left adjoint to R (and that R is right adjoint to L) if, for any c ‚ààC and
d ‚ààD, there is an isomorphism of hom-sets
Œ±c,d : C(c, R(d))
‚àí‚ÜíD(L(c), d)
that is natural in c and d.8
Given a morphism f : c ‚ÜíR(d) in C, its image 1 B Œ±c,d( f ) is called its mate.
Similarly, the mate of 1 : L(c) ‚Üíd is f .

3.4. ADJUNCTIONS AND DATA MIGRATION
103
To denote an adjunction we write L ‚ä£R, or in diagrams,
C
D
L
R
with the ‚áíin the direction of the left adjoint.
Example 3.71. Recall that every preorder P can be regarded as a category.
Galois
connections between preorders and adjunctions between the corresponding categories
are exactly the same thing.
Example 3.72. Let B ‚ààOb(Set) be any set. There is an adjunction called ‚Äòcurrying B,‚Äô
after the logician Haskell Curry:
Set
Set
‚àí√óB
(‚àí)B
Set(A √ó B, C)  Set(A, CB)
Abstractly we write it as on the left, but what this means is that for any sets A, C, there
is a natural isomorphism as on the right.
To explain this, we need to talk about exponential objects in Set. Suppose that B
and C are sets. Then the set of functions B ‚ÜíC is also a set; let‚Äôs denote it CB. It‚Äôs
written this way because if C has 10 elements and B has 3 elements then CB has 103
elements, and more generally for any two Ô¨Ånite sets |CB|  |C||B|.
The idea of currying is that given sets A, B, and C, there is a one-to-one correspon-
dence between functions (A √ó B) ‚ÜíC and functions A ‚ÜíCB. Intuitively, if I have a
function f of two variables a, b, I can ‚Äúput oÔ¨Ä‚Äù entering the second variable: if you give
me just a, I‚Äôll return a function B ‚ÜíC that‚Äôs waiting for the B input. This is the curried
version of f . As one might guess, there is a formal connection between exponential
objects and what we called hom-elements b ‚ä∏c in DeÔ¨Ånition 2.79.
Exercise 3.73.
In Example 3.72, we discussed an adjunction between functors ‚àí√ó B
and (‚àí)B. But we only said how these functors worked on objects: for an arbitrary set
X, they return sets X √ó B and XB respectively.
8This naturality is between functors Cop √ó D ‚ÜíSet. It says that for any morphisms f : c‚Ä≤ ‚Üíc in C
and 1 : d ‚Üíd‚Ä≤ in D, the following diagram commutes:
C(c, Rd)
D(Lc, d)
C(c‚Ä≤, Rd‚Ä≤)
D(Lc‚Ä≤, d‚Ä≤)
C( f ,R1)
Œ±c,d
D(L f ,1)
Œ±c‚Ä≤,d‚Ä≤

104
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
1. Given a morphism f : X ‚ÜíY, what morphism should ‚àí√ó B : X √ó B ‚ÜíY √ó B
return?
2. Given a morphism f : X ‚ÜíY, what morphism should (‚àí)B : XB ‚ÜíYB return?
3. Consider the function +: N √ó N ‚ÜíN, which sends (a, b) 7‚Üía + b. Currying +,
we get a certain function p : N ‚ÜíNN. What is p(3)?
‚ô¶
Example 3.74. If you know some abstract algebra or topology, here are some other
examples of adjunctions.
1. Free constructions: given any set you get a free group, free monoid, free ring, free
vector space, etc.; each of these is a left adjoint. The corresponding right adjoint
takes a group, a monoid, a ring, a vector space etc. and forgets the algebraic
structure to return the underlying set.
2. Similarly, given a graph you get a free preorder or a free category, as we discussed
in Section 3.2.3; each is a left adjoint. The corresponding right adjoint is the
underlying graph of a preorder or of a category.
3. Discrete things: given any set you get a discrete preorder, discrete graph, discrete
metric space, discrete category, discrete topological space; each of these is a left
adjoint. The corresponding right adjoint is again underlying set.
4. Codiscrete things: given any set you get a codiscrete preorder, complete graph,
codiscrete category, codiscrete topological space; each of these is a right adjoint.
The corresponding left adjoint is the underlying set.
5. Given a group, you can quotient by its commutator subgroup to get an abelian
group; this is a left adjoint. The right adjoint is the inclusion of abelian groups
into groups.
3.4.3
Left and right pushforward functors, Œ£ and Œ†
Given F : C ‚ÜíD, the data migration functor ‚àÜF turns D-instances into C-instances.
This functor has both a left and a right adjoint:
C-Inst
D-Inst
Œ£F
Œ†F
‚àÜF

3.4. ADJUNCTIONS AND DATA MIGRATION
105
Using the names Œ£ and Œ† in this context is fairly standard in category theory. In the
case of databases, they have the following helpful mnemonic:
Migration Functor
Pronounced
Reminiscent of
Database idea
‚àÜ
Delta
Duplicate
or destroy
Duplicate or destroy
tables or columns
Œ£
Sigma
Sum
Union (sum up) data
Œ†
Pi
Product
Pair9 and query data
Just like we used ‚àÜF to pull back any discrete dynamical system along F : Gr ‚ÜíDDS
and get a graph, the migration functors Œ£F and Œ†F can be used to turn any graph into
a discrete dynamical system.
That is, given an instance J : Gr ‚ÜíSet, we can get
instances Œ£F(J) and Œ†F(J) on DDS. This, however, is quite technical, and we leave it
to the adventurous reader to compute an example, with help perhaps from [Spi14a],
which explores the deÔ¨Ånitions of Œ£ and Œ† in detail. A less technical shortcut is simply
to code up the computation in the open-source FQL software.
To get the basic idea across without getting mired in technical details, here we shall
instead discuss a very simple example. Recall the schemas from Eq. (3.5). We can set
up a functor between them, the one sending black dots to black dots and white dots to
white dots:
$‚ó¶
Economy
‚Ä¢
First Class
‚Ä¢
string
‚ó¶
Price
Position
Price
Position
A B
$‚ó¶
Airline Seat
‚Ä¢
string
‚ó¶
Price
Position
: B
F
With this functor F in hand, we can transform any B-instance into an A-instance using
‚àÜF. Whereas ‚àÜwas interesting in the case of turning discrete dynamical systems into
graphs in Section 3.4.1, it is not very interesting in this case. Indeed, it will just copy‚Äî‚àÜ
for duplicate‚Äîthe rows in Airline seat into both Economy and First Class.
‚àÜF has two adjoints, Œ£F and Œ†F, both of which transform any A-instance I into a
B-instance. The functor Œ£F does what one would most expect from reading the names
on each object: it will put into Airline Seat the union of Economy and First Class:
Œ£F(I)(Airline Seat)  I(Economy) ‚äîI(First Class).
The functor Œ†F puts into Airline Seat the set of those pairs (e, f ) where e is an
Economy seat, f is a First Class seat, and e and f have the same price and position.
9This is more commonly called ‚Äújoin‚Äù by database programmers.

106
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
In this particular example, one imagines that there should be no such seats in a valid
instance I, in which case Œ†F(I)(Airline Seat) would be empty. But in other uses of these
same schemas, Œ†F can be a useful operation. For example, in the schema A replace
the label ‚ÄòEconomy‚Äô by ‚ÄòRewards Program‚Äô, and in B replace ‚ÄòAirline Seat‚Äô by ‚ÄòFirst
Class Seats‚Äô. Then the operation Œ†F Ô¨Ånds those Ô¨Årst class seats that are also rewards
program seats. This operation is a kind of database query; querying is the operation
that databases are built for.
The moral is that complex data migrations can be speciÔ¨Åed by constructing functors
F between schemas and using the ‚Äúinduced‚Äù functors ‚àÜF, Œ£F, and Œ†F. Indeed, in
practice essentially all useful migrations can be built up from these. Hence the language
of categories provides a framework for specifying and reasoning about data migrations.
3.4.4
Single set summaries of databases
To give a stronger idea of the Ô¨Çavor of Œ£ and Œ†, we consider another special case,
namely where the target category D is equal to 1; see Exercise 3.12. In this case, there
is exactly one functor C ‚Üí1 for any C; let‚Äôs denote it
!: C ‚Üí1.
(3.75)
Exercise 3.76.
Describe the functor !: C ‚Üí1 from Eq. (3.75). Where does it send each
object? What about each morphism?
‚ô¶
We want to consider the data migrationfunctorsŒ£! : C-Inst ‚Üí1-Inst andŒ†! : C-Inst ‚Üí
1-Inst. In Example 3.53, we saw that an instance on 1 is the same thing as a set. So let‚Äôs
identify 1-Inst with Set, and hence discuss
Œ£! : C-Inst ‚ÜíSet
and
Œ†! : C-Inst ‚ÜíSet.
Given any schema C and instance I : C ‚ÜíSet, we will get sets Œ£!(I) and Œ†!(I). Thinking
of these sets as database instances, each corresponds to a single one-column table‚Äîa
controlled vocabulary‚Äîsummarizing an entire database instance on the schema C.
Consider the following schema
G B
Email
‚Ä¢
Address
‚Ä¢
sent_by
received_by
no equations
(3.77)
Here‚Äôs a sample instance I : G ‚ÜíSet:
Email
sent_by
received_by
Em_1
Bob
Grace
Em_2
Grace
Pat
Em_3
Bob
Emmy
Em_4
Sue
Doug
Em_5
Doug
Sue
Em_6
Bob
Bob
Address
Bob
Doug
Emmy
Grace
Pat
Sue

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
107
Exercise 3.78. Note that G from Eq. (3.77) is isomorphic to theschema Gr. In Section 3.3.5
we saw that instances on Gr are graphs. Draw the above instance I as a graph.
‚ô¶
Now we have a unique functor !: G ‚Üí1, and we want to say what Œ£!(I) and Œ†!(I) give
us as single-set summaries. First, Œ£!(I) tells us all the emailing groups‚Äîthe ‚Äúconnected
components‚Äù‚Äîin I:
1
Bob-Grace-Pat-Emmy
Sue-Doug
This form of summary, involving identifying entries into common groups, or quotients,
is typical of Œ£-operations.
The functor Œ†!(I) lists the emails from I which were sent from a person to her- or
him-self.
1
Em_6
This is again a sort of query, selecting the entries that Ô¨Åt the criterion of self-to-self
emails. Again, this is typical of Œ†-operations.
Where do these facts‚Äîthat Œ†! and Œ£! act the way we said‚Äîcome from? Everything
follows from the deÔ¨Ånition of adjoint functors (3.70): indeed we hope this, together
with the examples given in Example 3.74, give the reader some idea of how general
and useful adjunctions are, both in mathematics and in database theory.
One more point: while we will not spell out the details, we note that these operations
are also examples of constructions known as colimits and limits in Set. We end this
chapter with bonus material, exploring these key category theoretic constructions. The
reader should keep in mind that, in general and not just for functors to 1, Œ£-operations
are built from colimits in Set, and Œ†-operations are built from limits in Set.
3.5
Bonus: An introduction to limits and colimits
What do products of sets, the results of Œ†!-operations on database instances, and meets
in a preorder all have in common? The answer, as we shall see, is that they are all
examples of limits. Similarly, disjoint unions of sets, the results of Œ£!-operations on
database instances, and joins in a preorder are all colimits. Let‚Äôs begin with limits.
Recall that Œ†! takes a database instance I : C ‚ÜíSet and turns it into a set Œ†!(I).
More generally, a limit turns a functor F : C ‚ÜíD into an object of D.
3.5.1
Terminal objects and products
Terminal objects and products are each a sort of limit. Let‚Äôs discuss them in turn.
Terminal objects.
The most basic limit is a terminal object.

108
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
DeÔ¨Ånition 3.79. Let C be a category. Then an object Z in C is a terminal object if, for
each object C of C, there exists a unique morphism !: C ‚ÜíZ.
Since this unique morphism exists for all objects in C, we say that terminal objects
have a universal property.
Example 3.80. In Set, any set with exactly one element is a terminal object.
Why?
Consider some such set {‚Ä¢}. Then for any other set C we need to check that there is
exactly one function !: C ‚Üí{‚Ä¢}. This unique function is the one that does the only
thing that can be done: it maps each element c ‚ààC to the element ‚Ä¢ ‚àà{‚Ä¢}.
Exercise 3.81.
Let (P, ‚â§) be a preorder, let z ‚ààP be an element, and let P be the
corresponding category (see Section 3.2.3). Show that z is a terminal object in P if and
only if it is a top element in P: that is, if and only if for all c ‚ààP we have c ‚â§z.
‚ô¶
Exercise 3.82.
Name a terminal object in the category Cat. (Hint: recall Exercise 3.76.)
‚ô¶
Exercise 3.83.
Not every category has a terminal object. Find one that doesn‚Äôt.
‚ô¶
Proposition 3.84. All terminal objects in a category C are isomorphic.
Proof. This is a simple, but powerful standard argument. Suppose Z and Z‚Ä≤ are both
terminal objects in some category C. Then there exist (unique) maps a : Z ‚ÜíZ‚Ä≤ and
b : Z‚Ä≤ ‚ÜíZ. Composing these, we get a map a # b : Z ‚ÜíZ. Now since Z is terminal, this
map Z ‚ÜíZ must be unique. But idZ is also such a map. So we must have a # b  idZ.
Similarly, we Ô¨Ånd that b # a  idZ‚Ä≤. Thus a is an isomorphism, with inverse b.
‚ñ°
Remark 3.85 (‚ÄúThe limit‚Äù vs. ‚Äúa limit‚Äù). Not only are all terminal objects isomorphic,
there is a unique isomorphism between any two. We hence say ‚Äúterminal objects are
unique up to unique isomorphism.‚Äù To a category theorist, this is very nearly the same
thing as saying ‚Äúall terminal objects are equal.‚Äù Thus we often abuse terminology and
talk of ‚Äòthe‚Äô terminal object, rather than ‚Äúa‚Äù terminal object. We will do the same for any
sort of limit or colimit, e.g. speak of ‚Äúthe product‚Äù of two sets, rather than ‚Äúa product.‚Äù
We saw a similar phenomenon in DeÔ¨Ånition 1.81.
Products.
Products are slightly more complicated to formalize than terminal objects,
but they are familiar in practice.
DeÔ¨Ånition 3.86. Let C be a category, and let X, Y be objects in C. A product of X and Y is
an object, denoted X √óY, together with morphisms pX : X √óY ‚ÜíX and pY : X √óY ‚ÜíY
such that for all objects C together with morphisms f : C ‚ÜíX and 1 : C ‚ÜíY, there
exists a unique morphism C ‚ÜíX √óY, denoted ‚ü®f , 1‚ü©, for which the following diagram

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
109
commutes:
C
X
Y
X √ó Y
f
1
‚ü®f ,1‚ü©
pX
pY
We will try to bring this down to earth in Example 3.87. Before we do, note that
X √ó Y is an object equipped with morphisms to X and Y. Roughly speaking, it is like
‚Äúthe best object-equipped-with-morphisms-to-X-and-Y‚Äù in all of C, in the sense that
any other object-equipped-with-morphisms-to-X-and-Y maps to it uniquely. This is
called a universal property. It‚Äôs customary to use a dotted line to indicate the unique
morphism that exists because of some universal property.
Example 3.87. In Set, a product of two sets X and Y is their usual cartesian product
X √ó Y B {(x, y) | x ‚ààX, y ‚ààY},
which comes with two projections pX : X √ó Y ‚ÜíX and pY : X √ó Y ‚ÜíY, given by
pX(x, y) B x and pY(x, y) B y.
Given any set C with functions f : C ‚ÜíX and 1 : C ‚ÜíY, the unique map from C
to X √ó Y such that the required diagram commutes is given by ‚ü®f , 1‚ü©(c) B ( f (c), 1(c)).
Here is a picture of the product 6 √ó 4 of sets 6 and 4.
(1,1)
‚Ä¢
1‚Ä¢
(1,2)
‚Ä¢
2‚Ä¢
(1,3)
‚Ä¢
3‚Ä¢
(1,4)
‚Ä¢
4‚Ä¢
1‚Ä¢
(2,1)
‚Ä¢
(2,2)
‚Ä¢
(2,3)
‚Ä¢
(2,4)
‚Ä¢
2‚Ä¢
(3,1)
‚Ä¢
(3,2)
‚Ä¢
(3,3)
‚Ä¢
(3,4)
‚Ä¢
3‚Ä¢
(4,1)
‚Ä¢
(4,2)
‚Ä¢
(4,3)
‚Ä¢
(4,4)
‚Ä¢
4‚Ä¢
(5,1)
‚Ä¢
(5,2)
‚Ä¢
(5,3)
‚Ä¢
(5,4)
‚Ä¢
5‚Ä¢
(6,1)
‚Ä¢
(6,2)
‚Ä¢
(6,3)
‚Ä¢
(6,4)
‚Ä¢
6‚Ä¢
C
‚àÄf
‚àÄ1
‚àÉ!
Exercise 3.88.
Let (P, ‚â§) be a preorder, let x, y ‚ààP be elements, and let P be the
corresponding category. Show that the product x √ó y in P agrees with their meet x ‚àßy
in P.
‚ô¶

110
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Example 3.89. Given two categories C and D, their product C √ó D may be given as
follows. The objects of this category are pairs (c, d), where c is an object of C and d is an
object of D. Similarly, morphisms (c, d) ‚Üí(c‚Ä≤, d‚Ä≤) are pairs ( f , 1) where f : c ‚Üíc‚Ä≤ is a
morphism in C and 1 : d ‚Üíd‚Ä≤ is a morphism in D. Composition of morphisms is simply
given by composing each entry in the pair separately, so ( f , 1) # ( f ‚Ä≤, 1‚Ä≤)  ( f # f ‚Ä≤, 1 # 1‚Ä≤).
Exercise 3.90.
1. What are the identity morphisms in a product category C √ó D?
2. Why is composition in a product category associative?
3. What is the product category 1 √ó 2?
4. What is the product category P √ó Q when P and Q are preorders and P and Q are
the corresponding categories?
‚ô¶
These two constructions, terminal objects and products, are subsumed by the notion
of limit.
3.5.2
Limits
We‚Äôll get a little abstract. Consider the deÔ¨Ånition of product. This says that given any
pair of maps X
f
‚Üê‚àíC
1
‚àí‚ÜíY, there exists a unique map C ‚ÜíX √ó Y such that certain
diagrams commute. This has the Ô¨Çavor of being terminal‚Äîthere is a unique map to
X √ó Y‚Äîbut it seems a bit more complicated. How are the two ideas related?
It turns out that products are terminal objects, but of a diÔ¨Äerent category, which
we‚Äôll call Cone(X, Y), the category of cones over X and Y in C. We will see in Exercise 3.91
that X
pX
‚Üê‚àí‚àíX √ó Y
pY
‚àí‚àí‚ÜíY is a terminal object in Cone(X, Y).
An object of Cone(X, Y) is simply a pair of maps X
f
‚Üê‚àíC
1
‚àí‚ÜíY. A morphism from
X
f
‚Üê‚àíC
1
‚àí‚ÜíY to X
f ‚Ä≤
‚Üê‚àíC‚Ä≤
1‚Ä≤
‚àí‚ÜíY in Cone(X, Y) is a morphism a : C ‚ÜíC‚Ä≤ in C such that
the following diagram commutes:
C
X
Y
C‚Ä≤
f
1
a
f ‚Ä≤
1‚Ä≤
Exercise 3.91.
Check that a product X
pX
‚Üê‚àí‚àíX √óY
pY
‚àí‚àí‚ÜíY is exactly the same as a terminal
object in Cone(X, Y).
‚ô¶
We‚Äôre now ready for the abstract deÔ¨Ånition. Don‚Äôt worry if the details are unclear;
the main point is that it is possible to unify terminal objects, maximal elements, and
meets, products of sets, preorders, and categories, and many other familiar friends
under the scope of a single deÔ¨Ånition.
In fact, they‚Äôre all just terminal objects in
diÔ¨Äerent categories.

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
111
Recall from DeÔ¨Ånition 3.51 that formally speaking, a diagram in C is just a functor
D : J ‚ÜíC. Here J is called the indexing category of the diagram D.
DeÔ¨Ånition 3.92. Let D : J ‚ÜíC be a diagram. A cone (C, c‚àó) over D consists of
(i) an object C ‚ààC;
(ii) for each object j ‚ààJ, a morphism cj : C ‚ÜíD(j).
To be a cone, these must satisfy the following property:
(a) for each f : j ‚Üík in J, we have ck  cj # D( f ).
A morphism of cones (C, c‚àó) ‚Üí(C‚Ä≤, c‚Ä≤
‚àó) is a morphism a : C ‚ÜíC‚Ä≤ in C such that for all
j ‚ààJ we have cj  a #c‚Ä≤
j. Cones over D, and their morphisms, form a category Cone(D).
The limit of D, denoted lim(D), is the terminal object in the category Cone(D). Say
it is the cone lim(D)  (C, c‚àó); we refer to C as the limit object and the map cj for any
j ‚ààJ as the jth projection map.
For visualization purposes, if J is the free category on the graph
1
3
2
4
5
with Ô¨Åve objects and Ô¨Åve non-identity morphisms, then we may draw a diagram
D : J ‚ÜíC inside C as on the left below, and a cone on it as on the right:
C
D1
D3
D2
D4
D5
C
D1
D3
D2
D4
D5
c1
c2
c3
c4
c5
Here, any two parallel paths that start at C are considered the same. Note that both
these diagrams depict a collection of objects and morphisms inside the category C.
Example 3.93. Terminal objects are limits where the indexing category is empty, J  ¬ú.
Example 3.94. Products are limits where the indexing category consists of two objects
v, w and no arrows, J 
v‚Ä¢
w‚Ä¢ .
3.5.3
Finite limits in Set
Recall that this discussion was inspired by wanting to understand Œ†-operations, and
in particular Œ†!. We can now see that a database instance I : C ‚ÜíSet is a diagram in

112
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
Set. The functor Œ†! takes the limit of this diagram. In this subsection we give a formula
describing the result. This captures all Ô¨Ånite limits in Set.
In database theory, we work with categories C that are presented by a Ô¨Ånite graph
plus equations. We won‚Äôt explain the details, but it‚Äôs in fact enough just to work with
the graph part: as far as limits are concerned, the equations in C don‚Äôt matter. For
consistency with the rest of this section, let‚Äôs denote the database schema by J instead
of C.
Theorem 3.95. Let J be a category presented by the Ô¨Ånite graph (V, A, s, t) together with
some equations, and let D : J ‚ÜíSet be a set-valued functor. Write V  {v1, . . . , vn}.
The set
lim
J D B

(d1, . . . , dn) | di ‚ààD(vi) for all 1 ‚â§i ‚â§n and
for all a : vi ‚Üívj ‚ààA, we have D(a)(di)  dj
	
.
together with the projection maps pi : (limJ D) ‚ÜíD(vi) given by pi(d1, . . . , dn) B di,
is a limit of D.
Example 3.96. If J is the empty graph ‚Ä¢ , then n  0: there are no vertices. There is ex-
actly one empty tuple ( ), which vacuously satisÔ¨Åes the properties, so we‚Äôve constructed
the limit as the singleton set {( )} consisting of just the empty tuple. Thus the limit of
the empty diagram, i.e. the terminal object in Set is the singleton set. See Remark 3.85.
Exercise 3.97.
Show that the limit formula in Theorem 3.95 works for products. See
Example 3.94.
‚ô¶
Exercise 3.98.
If D : 1 ‚ÜíSet is a functor, what is the limit of D? Compute it using
Theorem 3.95, and check your answer against DeÔ¨Ånition 3.92.
‚ô¶
Pullbacks.
In particular, the condition that the limit of D : J ‚ÜíSet selects tuples
(d1, . . . , dn) such that D(a)(di)  dj for each morphism a : i ‚Üíj in J allows us to use
limits to select data that satisÔ¨Åes certain equations or constraints. This is what allows
us to express queries in terms of limits. Here is an example.
Example 3.99. If J is presented by the cospan graph
x‚Ä¢
f
‚àí‚àí‚Üí
a‚Ä¢
1
‚Üê‚àí‚àí
y
‚Ä¢ , then its limit is
known as a pullback. Given the diagram X
f
‚àí‚ÜíA
1
‚Üê‚àíY, the pullback is the cone shown

3.5. BONUS: AN INTRODUCTION TO LIMITS AND COLIMITS
113
on the left below:
C
Y
X
A
cx
cy
ca
1
f
X √óA Y
Y
X
A
cx
cy
1
f
‚åü
The fact that the diagram commutes means that the diagonal arrow ca is in some
sense superÔ¨Çuous, so one generally denotes pullbacks by dropping the diagonal arrow,
naming the cone point X √óA Y, and adding the ‚åüsymbol, as shown to the right above.
Here is a picture to help us unpack the deÔ¨Ånition in Set. We take X  6, Y  4, and
A to be the set of colors {red, blue, black}.
(1,1)
‚Ä¢
1‚Ä¢
(1,2)
‚Ä¢
2‚Ä¢
(1,3)
‚Ä¢
3‚Ä¢
(1,4)
‚Ä¢
4‚Ä¢
1‚Ä¢
(2,1)
‚Ä¢
(2,2)
‚Ä¢
(2,3)
‚Ä¢
(2,4)
‚Ä¢
2‚Ä¢
(3,1)
‚Ä¢
(3,2)
‚Ä¢
(3,3)
‚Ä¢
(3,4)
‚Ä¢
3‚Ä¢
(4,1)
‚Ä¢
(4,2)
‚Ä¢
(4,3)
‚Ä¢
(4,4)
‚Ä¢
4‚Ä¢
(5,1)
‚Ä¢
(5,2)
‚Ä¢
(5,3)
‚Ä¢
(5,4)
‚Ä¢
5‚Ä¢
(6,1)
‚Ä¢
(6,2)
‚Ä¢
(6,3)
‚Ä¢
(6,4)
‚Ä¢
6‚Ä¢
The functions f : 6 ‚ÜíA and 1 : 4 ‚ÜíA are expressed in the coloring of the dots: for
example, 1(2)  1(4)  red, while f (5)  black. The pullback selects pairs (i, j) ‚àà6 √ó 4
such that f (i) and 1(j) have the same color.
Remark 3.100. As mentioned following DeÔ¨Ånition 3.68, this deÔ¨Ånition of pullback is
not to be confused with the pullback of a set-valued functor along a functor; they are
for now best thought of as diÔ¨Äerent concepts which accidentally have the same name.
Due to the power of the primordial ooze, however, the pullback along a functor is a
special case of pullback as the limit of a cospan: it can be understood as the pullback
of a certain cospan in Cat. To unpack this, however, requires the notions of category of
elements and discrete opÔ¨Åbration; ask your friendly neighborhood category theorist.
3.5.4
A brief note on colimits
Just like upper bounds have a dual concept‚Äînamely that of lower bounds‚Äîso limits
have a dual concept: colimits. To expose the reader to this concept, we provide a
succinct deÔ¨Ånition of these using opposite categories and opposite functors. The point,
however, is just exposure; we will return to explore colimits in detail in Chapter 6.
Exercise 3.101.
Recall from Example 3.27 that every category C has an opposite Cop.
Let F : C ‚ÜíD be a functor. How should we deÔ¨Åne its opposite, Fop : Cop ‚ÜíDop? That

114
CHAPTER 3. DATABASES: CATEGORIES, FUNCTORS, AND (CO)LIMITS
is, how should Fop act on objects, and how should it act on morphisms?
‚ô¶
DeÔ¨Ånition 3.102. Given a category C we say that a cocone in C is a cone in Cop.
Given a diagram D : J ‚ÜíC, we may take the limit of the functor Dop : Jop ‚ÜíCop.
This is a cone in Cop, and so by deÔ¨Ånition a cocone in C. The colimit of D is this cocone.
DeÔ¨Ånition 3.102 is like a compressed Ô¨Åle: useful for transmitting quickly, but com-
pletely useless for working with, unless you can successfully unpack it. We will unpack
it later in Chapter 6 when we discuss electric circuits.
3.6
Summary and further reading
Congratulations on making it through one of the longest chapters in the book! We
apologize for the length, but this chapter had a lot of work to do. Namely it introduced
the ‚Äúbig three‚Äù of category theory‚Äîcategories, functors, and natural transformations‚Äî
as well as discussed adjunctions, limits, and very brieÔ¨Çy colimits.
That‚Äôs really quite a bit of material. For more on all these subjects, one can consult
any standard book on category theory, of which there are many.
The bible (old,
important, seminal, and requires a priest to explain it) is [Mac98]; another thorough
introduction is [Bor94]; a logical perspective is given in [Awo10]; a computer science
perspective is given in [BW90] and [Pie91] and [Wal92]; math students should probably
read [Lei14] or [Rie17] or [Gra18]; a general audience might start with [Spi14a].
We presented categories from a database perspective, because data is pretty ubiq-
uitous in our world. A database schema‚Äîi.e. a system of interlocking tables‚Äîcan be
captured by a category C, and Ô¨Ålling it with data corresponds to a functor C ‚ÜíSet. Here
Set is the category of sets, perhaps the most important category to mathematicians.
The perspective of using category theory to model databases has been rediscovered
several times. It seems to have Ô¨Årst been discussed by various authors around the
mid-90‚Äôs [IP94; CD95; PS95; TG96]. Bob Rosebrugh and collaborators took it much
further in a series of papers including [FGR03; JR02; RW92]. Most of these authors
tend to focus on sketches, which are more expressive categories. Spivak rediscovered
the idea again quite a bit later, but focused on categories rather than sketches, so as to
have all three data migration functors ‚àÜ, Œ£, Œ†; see [Spi12; SW15b]. The version of this
story presented in the chapter, including the white and black nodes in schemas, is part
of a larger theory of algebraic databases, where a programming language such as Java
or Haskell is attached to a database. The technical details are worked out in [Sch+17],
and its use in database integration projects can be found in [SW15a; Wis+15].
Before we leave this chapter, we want to emphasize two things: coherence conditions
and universal constructions.
Coherence conditions.
In the deÔ¨Ånitions of category, functor, and natural transforma-
tions, we have data (indexed by (i)) that is required to satisfy certain properties (indexed

3.6. SUMMARY AND FURTHER READING
115
by (a)). Indeed, for categories it was about associativity and unitality of composition,
for functors it was about respecting composition and identities, and for natural trans-
formations it was the naturality condition. These conditions are often called coherence
conditions: we want the various structures to cohere, to work well together, rather than
to Ô¨Çop around unattached.
Understanding why these particular structures and coherence conditions are ‚Äúthe
right ones‚Äù is more science than mathematics: we empirically observe that certain
combinations result in ideas that are both widely applicable and also strongly compo-
sitional. That is, we become satisÔ¨Åed with coherence conditions when they result in
beautiful mathematics down the road.
Universal constructions.
Universal constructions are one of the most important
themes of category theory. Roughly speaking, one gives some speciÔ¨Åed shape in a
category and says ‚ÄúÔ¨Ånd me the best solution!‚Äù And category theory comes back and
says ‚Äúdo you want me to approximate from the left or the right (colimit or limit)?‚Äù You
respond, and either there is a best solution or there is not. If there is, it‚Äôs called the
(co)limit; if there‚Äôs not we say ‚Äúthe (co)limit does not exist.‚Äù
Even data migration Ô¨Åts this form. We say ‚ÄúÔ¨Ånd me the closest thing in D that
matches my C-instance using my functor F : C ‚ÜíD.‚Äù In fact this approach‚Äîknown
as Kan extensions‚Äîsubsumes the others. One of the two founders of category theory,
Saunders Mac Lane, has a section in his book [Mac98] called ‚ÄúAll concepts are Kan
extensions,‚Äù a big statement, no?


Chapter 4
Collaborative design:
Profunctors, categoriÔ¨Åcation, and
monoidal categories
4.1
Can we build it?
When designing a large-scale system, many diÔ¨Äerent Ô¨Åelds of expertise are joined
to work on a single project. Thus the whole project team is divided into multiple
sub-teams, each of which is working on a sub-project. And we recurse downward:
the sub-project is again factored into sub-sub-projects, each with their own team. One
could refer to this sort of hierarchical design process as collaborative design, or co-design.
In this chapter, we discuss a mathematical theory of co-design, due to Andrea Censi
[Cen15].
Consider just one level of this hierarchy: a project and a set of teams working on
it. Each team is supposed to provide resources‚Äîsometimes called ‚Äúfunctionalities‚Äù‚Äîto
the project, but the team also requires resources in order to do so. DiÔ¨Äerent design
teams must be allowed to plan and work independently from one another in order for
progress to be made. Yet the design decisions made by one group aÔ¨Äect the design
decisions others can make: if A wants more space in order to provide a better radio
speaker, then B must use less space.
So these teams‚Äîthough ostensibly working
independently‚Äîare dependent on each other after all.
The combination of dependence and independence is crucial for progress to be
made, and yet it can cause major problems. When a team requires more resources than
it originally expected to require, or if it cannot provide the resources that it originally
claimed it could provide, the usual response is for the team to issue a design-change
notice. But these aÔ¨Äect neighboring teams: if team A now requires more than originally
claimed, team B may have to change their design, which can in turn aÔ¨Äect team C. Thus
these design-change notices can ripple through the system through feedback loops and
117

118
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
can cause whole projects to fail [S+15].
As an example, consider the design problem of creating a robot to carry some load
at some velocity. The top-level planner breaks the problem into three design teams:
chassis team, motor team, and battery team. Each of these teams could break up into
multiple parts and the process repeated, but let‚Äôs remain at the top level and consider
the resources produced and the resources required by each of our three teams.
The chassis in some sense provides all the functionality‚Äîit carries the load at the
velocity‚Äîbut it requires some things in order to do so. It requires money to build,
of course, but more to the point it requires a source of torque and speed. These are
supplied by the motor, which in turn needs voltage and current from the battery. Both
the motor and the battery cost money, but more importantly they need to be carried
by the chassis: they become part of the load. A feedback loop is created: the chassis
must carry all the weight, even that of the parts that power the chassis. A heavier
battery might provide more energy to power the chassis, but is the extra power worth
the heavier load?
In the following picture, each part‚Äîchassis, motor, battery, and robot‚Äîis shown as
a box with ports on the left and right. The functionalities, or resources produced by
the part are shown as ports on the left of the box, and the resources required by the
part are shown as ports on its right.
Œ£
Chassis
Motor
Battery
Œ£
Robot
‚â§
‚â§
‚â§
‚â§
‚â§
‚â§
‚â§
Voltage
‚â§
Current
‚â§
$
‚â§
‚â§
‚â•
‚â•
Weight
(as payload)
Velocity
$
Torque
Speed
$
Weight
Weight
$
(4.1)
The boxes marked Œ£ correspond to summing inputs. These boxes are not to be designed,
but we will see later that they Ô¨Åt easily into the same conceptual framework. Note
also the ‚â§‚Äôs on each wire; they indicate that if box A requires a resource that box B
produces, then A‚Äôs requirement must be less-than-or-equal-to B‚Äôs production. The
chassis requires torque, and the motor must produce at least that much torque.
To formalize this a bit more, let‚Äôs call diagrams like the one above co-design diagrams.
Each of the wires in a co-design diagram represents a preorder of resources.
For
example, in Eq. (4.1) every wire corresponds to a resource type‚Äîweights, velocities,
torques, speeds, costs, voltages, and currents‚Äîwhere resources of each type can be
ordered from less useful to more useful. In general, these preorders do not have to be
linear orders, though in the above cases each will likely correspond to a linear order:
$10 ‚â§$20, 5W ‚â§6W, and so on.
Each of the boxes in a co-design diagram corresponds to what we call a feasibility

4.2. ENRICHED PROFUNCTORS
119
relation. A feasibility relation matches resource production with requirements. For
every pair (p, r) ‚ààP √ó R, where P is the preorder of resources to be produced and R
is the preorder of resources to be required, the box says ‚Äútrue‚Äù or ‚Äúfalse‚Äù‚Äîfeasible or
infeasible‚Äîfor that pair. In other words, ‚Äúyes I can provide p given r‚Äù or ‚Äúno, I cannot
provide p given r.‚Äù
Feasibility relations hence deÔ¨Åne a function Œ¶: P √ó R ‚ÜíBool.
For a function
Œ¶: P √ó R ‚ÜíBool to make sense as a feasibility relation, however, there are two
conditions:
(a) If Œ¶(p, r)  true and p‚Ä≤ ‚â§p, then Œ¶(p‚Ä≤, r)  true.
(b) If Œ¶(p, r)  true and r ‚â§r‚Ä≤ then Œ¶(p, r‚Ä≤)  true.
These conditions, which we will see again in DeÔ¨Ånition 4.2, say that if you can produce
p given resources r, you can (a) also produce less p‚Ä≤ ‚â§p with the same resources r, and
(b) also produce p given more resources r‚Ä≤ ‚â•r. We will see that these two conditions
are formalized by requiring Œ¶ to be a monotone map Pop √ó R ‚ÜíBool.
A co-design problem, represented by a co-design diagram, asks us to Ô¨Ånd the com-
posite of some feasibility relations. It asks, for example, given these capabilities of the
chassis, motor, and battery teams, can we build a robot together? Indeed, a co-design
diagram factors a problem‚Äîfor example, that of designing a robot‚Äîinto intercon-
nected subproblems, as in Eq. (4.1). Once the feasibility relation is worked out for each
of the subproblems, i.e. the inner boxes in the diagram, the mathematics provides an
algorithm producing the feasibility relation of the whole outer box. This process can
be recursed downward, from the largest problem to tiny subproblems.
In this chapter, we will understand co-design problems in terms of enriched pro-
functors, in particular Bool-profunctors. A Bool-profunctor is like a bridge connecting
one preorder to another. We will show how the co-design framework gives rise to a
structure known as a compact closed category, and that any compact closed category
can interpret the sorts of wiring diagrams we see in Eq. (4.1).
4.2
Enriched profunctors
In this section we will understand how co-design problems form a category. Along the
way we will develop some abstract machinery that will allow us to replace preorder
design spaces with other enriched categories.
4.2.1
Feasibility relationships as Bool-profunctors
The theory of co-design is based on preorders: each resource‚Äîe.g. velocity, torque, or
$‚Äîis structured as a preorder. The order x ‚â§y represents the availability of x given
y, i.e. that whenever you have y, you also have x. For example, in our preorder of
wattage, if 5W ‚â§10W, it means that whenever we are provided 10W, we implicitly also
have 5W. Above we referred to this as an order from less useful to more useful: if x is
always available given y, then x is less useful than y.

120
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
We know from Section 2.3.2 that a preorder X can be conceived of as a Bool-category.
Given x, y ‚ààX, we have X(x, y) ‚ààB; this value responds to the assertion ‚Äúx is available
given y,‚Äù marking it either true or false.
Our goal is to see feasibility relations as Bool-profunctors, which are a special case
of something called enriched profunctors. Indeed, we hope that this chapter will give
you some intuition for profunctors, arising from the table
Bool-category
preorder
Bool-functor
monotone map
Bool-profunctor
feasibility relation
Because enriched profunctors are a bit abstract, we Ô¨Årst concretely discuss Bool-
profunctors as feasibility relations. Recall that if X  (X, ‚â§) is a preorder, then its
opposite Xop  (X, ‚â•) has x ‚â•y iÔ¨Äy ‚â§x.
DeÔ¨Ånition 4.2. Let X  (X, ‚â§X) and Y  (Y, ‚â§Y) be preorders. A feasibility relation for X
given Y is a monotone map
Œ¶: Xop √ó Y ‚ÜíBool.
(4.3)
We denote this by Œ¶: X
Y.
Given x ‚ààX and y ‚ààY, if Œ¶(x, y)  true we say x can be obtained given y.
As mentioned in the introduction, the requirement that Œ¶ is monotone says that
if x‚Ä≤ ‚â§X x and y ‚â§Y y‚Ä≤ then Œ¶(x, y) ‚â§Bool Œ¶(x‚Ä≤, y‚Ä≤).
In other words, if x can be
obtained given y, and if x‚Ä≤ is available given x, then x‚Ä≤ can be obtained given y. And if
furthermore y is available given y‚Ä≤, then x‚Ä≤ can also be obtained given y‚Ä≤.
Exercise 4.4.
Suppose we have the preorders
category
preorder
monoid
X B
nothing
this book
Y B
1. Draw the Hasse diagram for the preorder Xop √ó Y.
2. Write down a profunctor Œõ: X
Y and, reading Œõ(x, y)  true as ‚Äúmy aunt can
explain an x given y,‚Äù give an interpretation of the fact that the preimage of true
forms an upper set in Xop √ó Y.
‚ô¶
To generalize the notion of feasibility relation, we must notice that the symmetric
monoidal preorder Bool has more structure than just that of a symmetric monoidal
preorder: as mentioned in Exercise 2.93, Bool is a quantale. That means it has all
joins ‚à®, and a closure operation, which we‚Äôll write ‚áí: B √ó B ‚ÜíB. By deÔ¨Ånition, this
operation satisÔ¨Åes the property that for all b, c, d ‚ààB one has
b ‚àßc ‚â§d
iÔ¨Ä
b ‚â§(c ‚áíd).
(4.5)

4.2. ENRICHED PROFUNCTORS
121
The operation ‚áíis given by the following table:
c
d
c ‚áíd
true
true
true
true
false
false
false
true
true
false
false
true
(4.6)
Exercise 4.7.
Show that ‚áías deÔ¨Åned in Eq. (4.6) indeed satisÔ¨Åes Eq. (4.5).
‚ô¶
On an abstract level, it is the fact that Bool is a quantale which makes everything
in this chapter work; any other (unital commutative) quantale also deÔ¨Ånes a way to
interpret co-design diagrams. For example, we could use the quantale Cost, which
would describe not whether x is available given y but the cost of obtaining x given y;
see Example 2.37 and DeÔ¨Ånition 2.46.
4.2.2
V-profunctors
We are now ready to recast Eq. (4.3) in abstract terms. Recall the notions of enriched
product (DeÔ¨Ånition 2.74), enriched functor (DeÔ¨Ånition 2.69), and quantale (DeÔ¨Åni-
tion 2.79).
DeÔ¨Ånition 4.8. Let V  (V, ‚â§, I, ‚äó) be a (unital commutative) quantale,1 and let X and
Y be V-categories. A V-profunctor from X to Y, denoted Œ¶: X
Y, is a V-functor
Œ¶: Xop √ó Y ‚ÜíV.
Note that a V-functor must have V-categories for domain and codomain, so here we
are considering V as enriched in itself; see Remark 2.89.
Exercise 4.9.
Show that a V-profunctor (DeÔ¨Ånition 4.8) is the same as a function
Œ¶: Ob(X) √ó Ob(Y) ‚ÜíV such that for any x, x‚Ä≤ ‚ààX and y, y‚Ä≤ ‚ààY the following
inequality holds in V:
X(x‚Ä≤, x) ‚äóŒ¶(x, y) ‚äóY(y, y‚Ä≤) ‚â§Œ¶(x‚Ä≤, y‚Ä≤).
‚ô¶
Exercise 4.10.
Is it true that a Bool-profunctor, as in DeÔ¨Ånition 4.8, is exactly the same
as a feasibility relation, as in DeÔ¨Ånition 4.2, once you peel back all the jargon? Or is
there some subtle diÔ¨Äerence?
‚ô¶
We know that DeÔ¨Ånition 4.8 is quite abstract. But have no fear, we will take you
through it in pictures.
1From here on, as in Chapter 2, whenever we speak of quantales we mean unital commutative
quantales.

122
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Example 4.11 (Bool-profunctors and their interpretation as bridges). Let‚Äôs discuss DeÔ¨Å-
nition 4.8 in the case V  Bool. One way to imagine a Bool-profunctor Œ¶: X
Y is in
terms of building bridges between two cities. Recall that a preorder (a Bool-category)
can be drawn using a Hasse diagram. We‚Äôll think of the preorder as a city, and each
vertex in it as some point of interest. An arrow A ‚ÜíB in the Hasse diagram means
that there exists a way to get from point A to point B in the city. So what‚Äôs a profunctor?
A profunctor is just a bunch of bridges connecting points in one city to points in
another. Let‚Äôs see a speciÔ¨Åc example. Here is a picture of a Bool-profunctor Œ¶: X
Y:
N‚Ä¢
W‚Ä¢
E‚Ä¢
‚Ä¢
S
X B
‚Ä¢
a
b‚Ä¢
c‚Ä¢
d‚Ä¢
e‚Ä¢
: Y
Both X and Y are preorders, e.g. with W ‚â§N and b ‚â§a. With bridges coming from
the profunctor in blue, one can now use both paths within the cities and the bridges to
get from points in city X to points in city Y. For example, since there is a path from N
to e and E to a, we have Œ¶(N, e)  true and Œ¶(E, a)  true. On the other hand, since
there is no path from W to d, we have Œ¶(W, d)  false.
In fact, one could put a box around this entire picture and see a new preorder with
W ‚â§N ‚â§c ‚â§a, etc. This is called the collage of Œ¶; we‚Äôll explore this in more detail
later; see DeÔ¨Ånition 4.42.
Exercise 4.12.
We can express Œ¶ as a matrix where the (m, n)th entry is the value of
Œ¶(m, n) ‚ààB. Fill out the Bool-matrix:
Œ¶
a
b
c
d
e
N
?
?
?
?
true
E
true
?
?
?
?
W
?
?
?
false
?
S
?
?
?
?
?
‚ô¶
We‚Äôll call this the feasibility matrix of Œ¶.
Example 4.13 (Cost-profunctors and their interpretation as bridges). Let‚Äôs now consider
Cost-profunctors. Again we can view these as bridges, but this time our bridges are

4.2. ENRICHED PROFUNCTORS
123
labelled by their length. Recall from DeÔ¨Ånition 2.53 and Eq. (2.56) that Cost-categories
are Lawvere metric spaces, and can be depicted using weighted graphs. We‚Äôll think of
such a weighted graph as a chart of distances between points in a city, and generate a
Cost-profunctor by building a few bridges between the cities.
Here is a depiction of a Cost-profunctor Œ¶: X
Y:
‚Ä¢
A
‚Ä¢
B
‚Ä¢
C
‚Ä¢
D
3
3
4
2
5
X B
x‚Ä¢
‚Ä¢
y
z‚Ä¢
3
4
3
4
: Y
11
9
(4.14)
The distance from a point x in city X to a point y in city Y is given by the shortest path
that runs from x through X, then across one of the bridges, and then through Y to the
destination y. So for example
Œ¶(B, x)  11,
Œ¶(A, z)  20,
Œ¶(C, y)  17.
Exercise 4.15.
Fill out the Cost-matrix:
Œ¶
x
y
z
A
?
?
20
B
11
?
?
C
?
17
?
D
?
?
?
‚ô¶
Remark 4.16 (Computing profunctors via matrix multiplication). We can give an algo-
rithm for computing the above distance matrix using matrix multiplication. First, just
like in Eq. (2.59), we can begin with the labelled graphs in Eq. (4.14) and read oÔ¨Äthe
matrices of arrow labels for X, Y, and Œ¶:
MX
A
B
C
D
A
0
‚àû
3
‚àû
B
2
0
‚àû
5
C
‚àû
3
0
‚àû
D
‚àû
‚àû
4
0
MŒ¶
x
y
z
A
‚àû
‚àû
‚àû
B
11
‚àû
‚àû
C
‚àû
‚àû
‚àû
D
‚àû
9
‚àû
MY
x
y
z
x
0
4
3
y
3
0
‚àû
z
‚àû
4
0
Recall from Section 2.5.3 that the matrix of distances dY for Cost-category X can be
obtained by taking the matrix power of MX with smallest entries, and similarly for Y.
The matrix of distances for the profunctor Œ¶ will be equal to dX ‚àóMŒ¶ ‚àódY. In fact, since
X has four elements and Y has three, we also know that Œ¶  M3
X ‚àóMŒ¶ ‚àóM2
Y.
Exercise 4.17.
Calculate M3
X ‚àóMŒ¶ ‚àóM2
Y, remembering to do matrix multiplication
according to the (min, +)-formula for matrix multiplication in the quantale Cost; see
Eq. (2.101).

124
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Your answer should agree with what you got in Exercise 4.15; does it?
‚ô¶
4.2.3
Back to co-design diagrams
Each box in a co-design diagram has a left-hand and a right-hand side, which in turn
consist of a collection of ports, which in turn are labeled by preorders. For example,
consider the chassis box below:
Chassis
load
velocity
torque
speed
$
Its left side consists of two ports‚Äîone for load and one for velocity‚Äîand these are
the functionality that the chassis produces.
Its right side consists of three ports‚Äî
one for torque, one for speed, and one for $‚Äîand these are the resources that the
chassis requires. Each of these resources is to be taken as a preorder. For example,
load might be the preorder ([0, ‚àû], ‚â§), where an element x ‚àà[0, ‚àû] represents the
idea ‚ÄúI can handle any load up to x.,‚Äù while $ might be the two-element preorder
{up_to_$100, more_than_$100}, where the Ô¨Årst element of this set is less than the
second.
We then multiply‚Äîi.e. we take the product preorder‚Äîof all preorders on the left,
and similarly for those on the right.
The box then represents a feasibility relation
between the results. For example, the chassis box above represents a feasibility relation
Chassis:  load √ó velocity
 torque √ó speed √ó $
Let‚Äôs walk through this a bit more concretely.
Consider the design problem of
Ô¨Ålming a movie, where you must pit the tone and entertainment value against the cost.
A feasibility relation describing this situation details what tone and entertainment
value can be obtained at each cost; as such, it is described by a feasibility relation
Œ¶: (T √ó E)
$. We represent this by the box
Œ¶
T
E
$
where T, E, and $ are the preorders drawn below:
mean-spirited
‚Ä¢
good-natured
‚Ä¢
T B
boring
‚Ä¢
funny
‚Ä¢
E B
$500K
‚Ä¢
$1M
‚Ä¢
$100K
‚Ä¢
$ B

4.3. CATEGORIES OF PROFUNCTORS
125
A possible feasibility relation is then described by the profunctor
(mean, funny)
‚Ä¢
(g/n, boring)
‚Ä¢
(mean, boring)
‚Ä¢
(g/n, funny)
‚Ä¢
T √ó E 
$100K
‚Ä¢
$500K
‚Ä¢
$1M
‚Ä¢
 $
This says, for example, that a good-natured but boring movie costs $500K to produce
(of course, the producers would also be happy to get $1M).
To elaborate, each arrow in the above diagram is to be interpreted as saying, ‚ÄúI can
provide the source given the target‚Äù. For example, there are arrows witnessing each
of ‚ÄúI can provide $500K given $1M‚Äù, ‚ÄúI can provide a good-natured but boring movie
given $500K‚Äù, and ‚ÄúI can provide a mean and boring movie given a good-natured
but boring movie‚Äù. Moreover, this relationship is transitive, so the path from (mean,
boring) to $1M indicates also that ‚ÄúI can provide a mean and boring movie given $1M‚Äù.
Note the similarity and diÔ¨Äerence with the bridge interpretation of profunctors in
Example 4.11: the arrows still indicate the possibility of moving between source and
target, but in this co-design driven interpretation we understand them as indicating
that it is possible to get to the source from the target.
Exercise 4.18.
In the above diagram, the node (g/n, funny) has no dashed blue arrow
emerging from it. Is this valid? If so, what does it mean?
‚ô¶
4.3
Categories of profunctors
There is a category Feas whose objects are preorders and whose morphisms are feasi-
bility relations. In order to describe it, we must give the composition formula and the
identities, and prove that they satisfy the properties of being a category: unitality and
associativity.
4.3.1
Composing profunctors
If feasibility relations are to be morphisms, we need to give a formula for composing
two of them in series. Imagine you have cities P, Q, and R and you have bridges‚Äîand

126
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
hence feasibility matrices‚Äîconnecting these cities, say Œ¶: P
Q and Œ®: Q
R.
N‚Ä¢
W‚Ä¢
E‚Ä¢
‚Ä¢
S
P
‚Ä¢
a
b‚Ä¢
c‚Ä¢
d‚Ä¢
e‚Ä¢
Q
x‚Ä¢
‚Ä¢
y
R
(4.19)
The feasibility matrices for Œ¶ (in blue) and Œ® (in red) are:
Œ¶
a
b
c
d
e
N
true
false
true
false
false
E
true
false
true
false
true
W
true
true
true
true
false
S
true
true
true
true
true
Œ®
x
y
a
false
true
b
true
true
c
false
true
d
true
true
e
false
false
As in Remark 2.95, we personify a quantale as a navigator. So imagine a navigator is
trying to give a feasibility matrix Œ¶ # Œ® for getting from P to R. How should this be
done? Basically, for every pair p ‚ààP and r ‚ààR, the navigator searches through Q for a
way-point q, somewhere both to which we can get from p AND from which we can get
to r. It is true that we can navigate from p to r iÔ¨Äthere is a way-point q through which
to travel; this is a big OR over all possible q. The composition formula is thus:
(Œ¶ # Œ®)(p, r) B
√ú
q‚ààQ
Œ¶(p, q) ‚àßŒ®(q, r).
(4.20)
But as we said in Eq. (2.101), this can be thought of as matrix multiplication. In our
example, the result is
Œ¶ # Œ®
x
y
N
false
true
E
false
true
W
true
true
S
true
true
and one can check that this answers the question, ‚Äúcan you get from here to there‚Äù in
Eq. (4.19): you can‚Äôt get from N to x but you can get from N to y.
The formula (4.20) is written in terms of the quantale Bool, but it works for arbitrary
(unital commutative) quantales. We give the following deÔ¨Ånition.

4.3. CATEGORIES OF PROFUNCTORS
127
DeÔ¨Ånition 4.21. Let V be a quantale, let X, Y, and Z be V-categories, and let Œ¶: X
Y
and Œ®: Y
Z be V-profunctors. We deÔ¨Åne their composite, denoted Œ¶ # Œ®: X
Z by
the formula
(Œ¶ # Œ®)(p, r) 
√ú
q‚ààQ
 Œ¶(p, q) ‚äóŒ®(q, r)
.
Exercise 4.22.
Consider the Cost-profunctors Œ¶: X
Y and Œ®: Y
Z shown below:
‚Ä¢
A
‚Ä¢
B
‚Ä¢
C
‚Ä¢
D
3
3
4
2
5
X B
‚Ä¢
x
‚Ä¢y
‚Ä¢
z
3
4
3
4
Y B
‚Ä¢
p
‚Ä¢
q
‚Ä¢r
‚Ä¢s
2
2
1
1
Z B
11
9
4
4
0
Fill in the matrix for the composite profunctor:
Œ¶ # Œ®
p
q
r
s
A
?
24
?
?
B
?
?
?
?
C
?
?
?
?
D
?
?
9
?
‚ô¶
4.3.2
The categories V-Prof and Feas
A composition rule suggests a category, and there is indeed a category where the
objects are Bool-categories and the morphisms are Bool-profunctors. To make this
work more generally, however, we need to add one technical condition.
Recall from Remark 1.35 that a preorder is a skeletal preorder if whenever x ‚â§y and
y ‚â§x, we have x  y. Skeletal preorders are also known as posets. We say a quantale
is skeletal if its underlying preorder is skeletal; Bool and Cost are skeletal quantales.
Theorem 4.23. For any skeletal quantale V, there is a category ProfV whose objects are
V-categories X, whose morphisms are V-profunctors X
Y, and with composition
deÔ¨Åned as in DeÔ¨Ånition 4.21.
DeÔ¨Ånition 4.24. We deÔ¨Åne Feas B ProfBool.
At this point perhaps you have two questions in mind.
What are the identity
morphisms? And why did we need to specialize to skeletal quantales? It turns out
these two questions are closely related.

128
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
DeÔ¨Åne the unit profunctor UX : X
X on a V-category X by the formula
UX(x, y) B X(x, y).
(4.25)
How do we interpret this? Recall that, by DeÔ¨Ånition 2.46, X already assigns to each
pair of elements x, y ‚ààX an hom-object X(x, y) ‚ààV. The unit profunctor UX just
assigns each pair (x, y) that same object.
In the Bool case the unit profunctor on some preorder X can be drawn like this:
a‚Ä¢
b‚Ä¢
c‚Ä¢
d‚Ä¢
e‚Ä¢
X B
a‚Ä¢
b‚Ä¢
c‚Ä¢
d‚Ä¢
e‚Ä¢
: X
Obviously, composing a feasibility relation with with the unit leaves it unchanged; this
is the content of Lemma 4.27.
Exercise 4.26.
Choose a not-too-simple Cost-category X. Give a bridge-style diagram
for the unit profunctor UX : X
X.
‚ô¶
Lemma 4.27. Composing any profunctor Œ¶: P ‚ÜíQ with either unit profunctor, UP or
UQ, returns Œ¶:
UP # Œ¶  Œ¶  Œ¶ # UQ
Proof. We show that UP # Œ¶  Œ¶ holds; proving Œ¶  Œ¶ # UQ is similar. Fix p ‚ààP and
q ‚ààQ. Since V is skeletal, to prove the equality it‚Äôs enough to show Œ¶ ‚â§UP # Œ¶ and
UP # Œ¶ ‚â§Œ¶. We have one direction:
Œ¶(p, q)  I ‚äóŒ¶(p, q) ‚â§P(p, p) ‚äóŒ¶(p, q) ‚â§
√ú
p1‚ààP
 P(p, p1) ‚äóŒ¶(p1, q)
 (UP # Œ¶)(p, q).
(4.28)
For the other direction, we must show √î
p1‚ààP
 P(p, p1) ‚äóŒ¶(p1, q)
‚â§Œ¶(p, q). But by
deÔ¨Ånition of join, this holds iÔ¨ÄP(p, p1) ‚äóŒ¶(p1, q) ‚â§Œ¶(p, q) is true for each p1 ‚ààP. This
follows from DeÔ¨Ånitions 2.46 and 4.8:
P(p, p1) ‚äóŒ¶(p1, q)  P(p, p1) ‚äóŒ¶(p1, q) ‚äóI ‚â§P(p, p1) ‚äóŒ¶(p1, q) ‚äóQ(q, q) ‚â§Œ¶(p, q).
(4.29)
‚ñ°
Exercise 4.30.
1. Justify each of the four steps (, ‚â§, ‚â§, ) in Eq. (4.28).
2. In the case V  Bool, we can directly show each of the four steps in Eq. (4.28) is
actually an equality. How?

4.3. CATEGORIES OF PROFUNCTORS
129
3. Justify each of the three steps (, ‚â§, ‚â§) in Eq. (4.29).
‚ô¶
Composition of profunctors is also associative; we leave the proof to you.
Lemma 4.31. Serial composition of profunctors is associative. That is, given profunc-
tors Œ¶: P ‚ÜíQ, Œ®: Q ‚ÜíR, and Œ•: R ‚ÜíS, we have
(Œ¶ # Œ®) # Œ•  Œ¶ # (Œ® # Œ•).
Exercise 4.32.
Prove Lemma 4.31. (Hint: remember to use the fact that V is skeletal.)
‚ô¶
So, feasibility relations form a category.
Since this is the case, we can describe
feasibility relations using wiring diagrams for categories (see also Section 4.4.2), which
are very simple. Indeed, each box can only have one input and one output, and they‚Äôre
connected in a line:
f
a
1
h
d
b
c
On the other hand, we have seen that feasibility relations are the building blocks of
co-design problems, and we know that co-design problems can be depicted with a
much richer wiring diagram, for example:
Œ£
Chassis
Motor
Battery
Œ£
Robot
‚â§
‚â§
‚â§
‚â§
‚â§
‚â§
‚â§
Voltage
‚â§
Current
‚â§
$
‚â§
‚â§
‚â•
‚â•
Weight
(as payload)
Velocity
$
Torque
Speed
$
Weight
Weight
$
This hints that the category Feas has more structure. We‚Äôve seen wiring diagrams
where boxes can have multiple inputs and outputs before, in Chapter 2; there they
depicted morphisms in a monoidal preorder. On other hand the boxes in the wiring
diagrams of Chapter 2 could not have distinct labels, like the boxes in a co-design
problem: all boxes in a wiring diagram for monoidal preorders indicate the order ‚â§,
while above we see boxes labelled by ‚ÄúChassis‚Äù, ‚ÄúMotor‚Äù, and so on. Similarly, we know
that Feas is a proper category, not just a preorder. To understand these diagrams then,
we must introduce a new structure, called a monoidal category. A monoidal category is
a categoriÔ¨Åed monoidal preorder.
Remark 4.33. While we have chosen to deÔ¨Åne ProfV only for skeletal quantales in
Theorem 4.23, it is not too hard to work with non-skeletal ones. There are two straight-
forward ways to do this. First, we might let the morphisms of ProfV be isomorphism

130
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
classes of V-profunctors. This is analogous to the trick we will use when deÔ¨Åning
the category CospanC in DeÔ¨Ånition 6.45. Second, we might relax what we mean by
category, only requiring composition to be unital and associative ‚Äòup to isomorphism‚Äô.
This is also a type of categoriÔ¨Åcation, known as bicategory theory.
In the next section we‚Äôll discuss categoriÔ¨Åcation and introduce monoidal categories.
First though, we Ô¨Ånish this section by discussing why profunctors are called profunc-
tors, and by formally introducing something called the collage of a profunctor.
4.3.3
Fun profunctor facts: companions, conjoints, collages
Companions and conjoints.
Recall that a preorder is a Bool-category and a monotone
map is a Bool-functor. We said above that a profunctor is a generalization of a functor;
how so?
In fact, every V-functor gives rise to two V-profunctors, called the companion and
the conjoint.
DeÔ¨Ånition 4.34. Let F : P ‚ÜíQ be a V-functor. The companion of F, denoted bF : P
Q
and the conjoint of F, denoted qF : Q
P are deÔ¨Åned to be the following V-profunctors:
bF(p, q) B Q(F(p), q)
and
qF(q, p) B Q(q, F(p))
Let‚Äôs consider the Bool case again. One can think of a monotone map F : P ‚ÜíQ as
a bunch of arrows, one coming out of each vertex p ‚ààP and landing at some vertex
F(p) ‚ààQ.
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
P B
‚Ä¢
‚Ä¢
‚Ä¢
: Q
This looks like the pictures of bridges connecting cities, and if one regards the above
picture in that light, they are seeing the companion bF. But now mentally reverse every
dotted arrow, and the result would be bridges Q to P. This is a profunctor Q
P! We
call it qF.
Example 4.35. For any preorder P, there is an identity functor id: P ‚ÜíP. Its compan-
ion and conjoint agree b
id  qid: P
P. The resulting profunctor is in fact the unit
profunctor, UP, as deÔ¨Åned in Eq. (4.25).

4.3. CATEGORIES OF PROFUNCTORS
131
Exercise 4.36.
Check that the companion b
id of id: P ‚ÜíP really has the unit profunctor
formula given in Eq. (4.25).
‚ô¶
Example 4.37. Consider the function +: R √ó R √ó R ‚ÜíR, sending a triple (a, b, c) of real
numbers to a + b + c ‚ààR. This function is monotonic, because if (a, b, c) ‚â§(a‚Ä≤, b‚Ä≤, c‚Ä≤)‚Äî
i.e. if a ‚â§a‚Ä≤ and b ‚â§b‚Ä≤, and c ‚â§c‚Ä≤‚Äîthen obviously a + b + c ‚â§a‚Ä≤ + b‚Ä≤ + c‚Ä≤. Thus it has
a companion and a conjoint.
Its companion b+: (R √ó R √ó R)
R is the function that sends (a, b, c, d) to true if
a + b + c ‚â§d and to false otherwise.
Exercise 4.38.
Let +: R √ó R √ó R ‚ÜíR be as in Example 4.37. What is its conjoint q+?
‚ô¶
Remark 4.39 (V-Adjoints). Recall from DeÔ¨Ånition 1.95 the deÔ¨Ånition of Galois connec-
tion between preorders P and Q. The deÔ¨Ånition of adjoint can be extended from the
Bool-enriched setting (of preorders and monotone maps) to the V-enriched setting for
arbitrary monoidal preorders V. In that case, the deÔ¨Ånition of a V-adjunction is a pair
of V-functors F : P ‚ÜíQ and G: Q ‚ÜíP such that the following holds for all p ‚ààP and
q ‚ààQ.
P(p, G(q))  Q(F(p), q)
(4.40)
Exercise 4.41. Let V be a skeletal quantale, let P and Q be V-categories, and let F : P ‚ÜíQ
and G: Q ‚ÜíP be V-functors.
1. Show that F and G are V-adjoints (as in Eq. (4.40)) if and only if the companion
of the former equals the conjoint of the latter: bF  qG.
2. Use this to prove that b
id  qid, as was stated in Example 4.35.
‚ô¶
Collage of a profunctor.
We have been drawing profunctors as bridges connect-
ing cities.
One may get an inkling that given a V-profunctor Œ¶: X
Y between
V-categories X and Y, we have turned Œ¶ into a some sort of new V-category that has X
on the left and Y on the right. This works for any V and profunctor Œ¶, and is called the
collage construction.
DeÔ¨Ånition 4.42. Let V be a quantale, let X and Y be V-categories, and let Œ¶: X
Y be
a V-profunctor. The collage of Œ¶, denoted Col(Œ¶) is the V-category deÔ¨Åned as follows:
(i) Ob(Col(Œ¶)) B Ob(X) ‚äîOb(Y);
(ii) For any a, b ‚ààOb(Col(Œ¶)), deÔ¨Åne Col(Œ¶)(a, b) ‚ààV to be
Col(Œ¶)(a, b) B
Ô£±Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
X(a, b)
if a, b ‚ààX
Œ¶(a, b)
if a ‚ààX, b ‚ààY
¬ú
if a ‚ààY, b ‚ààX
Y(a, b)
if a, b ‚ààY
There are obvious functors iX : X ‚ÜíCol(Œ¶) and iY : Y ‚ÜíCol(Œ¶), sending each object

132
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
and morphism to ‚Äúitself,‚Äù called collage inclusions.
Some pictures will help clarify this.
Example 4.43. Consider the following picture of a Cost-profunctor Œ¶: X
Y:
A‚Ä¢
‚Ä¢
B
2
X B
x‚Ä¢
‚Ä¢
y
3
4 : Y
5
It corresponds to the following matrices
X
A
B
A
0
2
B
‚àû
0
Œ¶
x
y
A
5
8
B
‚àû
‚àû
Y
x
y
x
0
3
y
4
0
A generalized Hasse diagram of the collage can be obtained by simply taking the
union of the Hasse diagrams for X and Y, and adding in the bridges as arrows. Given
the above profunctor Œ¶, we draw the Hasse diagram for Col(Œ¶) below left, and the
Cost-matrix representation of the resulting Cost-category on the right:
A‚Ä¢
‚Ä¢
B
x‚Ä¢
‚Ä¢
y
2
5
3
4
Col(Œ¶) 
Col(Œ¶)
A
B
x
y
A
0
2
5
8
B
‚àû
0
‚àû
‚àû
x
0
0
0
3
y
0
0
4
0
Exercise 4.44.
Draw a Hasse diagram for the collage of the profunctor shown here:
‚Ä¢
A
‚Ä¢
B
‚Ä¢
C
‚Ä¢
D
3
3
4
2
5
X B
x‚Ä¢
‚Ä¢
y
z‚Ä¢
3
4
3
4
: Y
11
9
‚ô¶
4.4
CategoriÔ¨Åcation
Here we switch gears, to discuss a general concept called categoriÔ¨Åcation.
We will
begin again with the basics, categorifying several of the notions we‚Äôve encountered

4.4. CATEGORIFICATION
133
already. The goal is to deÔ¨Åne compact closed categories and their feedback-style wiring
diagrams. At that point we will return to the story of co-design, and V-profunctors
in general, and show that they do in fact form a compact closed category, and thus
interpret the diagrams we‚Äôve been drawing since Eq. (4.1).
4.4.1
The basic idea of categoriÔ¨Åcation
The general idea of categoriÔ¨Åcation is that we take a thing we know and add structure
to it, so that what were formerly properties become structures. We do this in such a way
that we can recover the thing we categoriÔ¨Åed by forgetting this new structure. This is
rather vague; let‚Äôs give an example.
Basic arithmetic concerns properties of the natural numbers N, such as the fact
that 5 + 3  8. One way to categorify N is to use the category FinSet of Ô¨Ånite sets
and functions.
To obtain a categoriÔ¨Åcation, we replace the brute 5, 3, and 8 with
sets of that many elements, say 5  {apple, banana, cherry, dragonfruit, elephant},
3  {apple, tomato, cantaloupe}, and 8  {Ali, Bob, Carl, Deb, Eli, Fritz, Gem, Helen}
respectively. We also replace + with disjoint union of sets ‚äî, and the brute property of
equality with the structure of an isomorphism. What makes this a good categoriÔ¨Åcation
is that, having made these replacements, the analogue of 5+3  8 is still true: 5‚äî3  8.
apple
‚Ä¢
banana
‚Ä¢
cherry
‚Ä¢
dragonfruit
‚Ä¢
elephant
‚Ä¢
apple
‚Ä¢
tomato
‚Ä¢
cantaloupe
‚Ä¢
‚äî
Ali‚Ä¢
Bob
‚Ä¢
Carl
‚Ä¢
Deb
‚Ä¢
Eli‚Ä¢
Fritz
‚Ä¢
Gem
‚Ä¢
Helen
‚Ä¢

In this categoriÔ¨Åed world, we have more structure available to talk about the relation-
ships between objects, so we can be more precise about how they relate to each other.
Thus it‚Äôs not the case that 5 ‚äî3 is equal to our chosen eight-element set 8, but more
precisely that there exists an invertible function comparing the two, showing that they
are isomorphic in the category FinSet.
Note that in the above construction we made a number of choices; here we must
beware. Choosing a good categoriÔ¨Åcation‚Äîlike designing a good algebraic structure
such as that of preorders or quantales‚Äîis part of the art of mathematics. There is

134
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
no prescribed way to categorify, and the success of a chosen categoriÔ¨Åcation is often
empirical: its richer structure should allow us more insights into the subject we want
to model.
As another example, an empirically pleasing way to categorify preorders is to cat-
egorify them as, well, categories. In this case, rather than the brute property ‚Äúthere
exists a morphism a ‚Üíb,‚Äù denoted a ‚â§b or P(a, b)  true, we instead say ‚Äúhere is a set
of morphisms a ‚Üíb.‚Äù We get a hom-set rather than a hom-Boolean. In fact‚Äîto state
this in a way straight out of the primordial ooze‚Äîjust as preorders are Bool-categories,
ordinary categories are actually Set-categories.
4.4.2
A reÔ¨Çection on wiring diagrams
Suppose we have a preorder. We introduced a very simple sort of wiring diagram in
Section 2.2.2. These allowed us to draw a box
‚â§
x0
x1
whenever x0 ‚â§x1. Chaining these together, we could prove facts in our preorder. For
example
‚â§
‚â§
‚â§
x0
x1
x2
x3
provides a proof that x0 ‚â§x3 (the exterior box) using three facts (the interior boxes),
x0 ‚â§x1, x1 ‚â§x2, and x2 ‚â§x3.
As categoriÔ¨Åed preorders, categories have basically the same sort of wiring diagram
as preorders‚Äînamely sequences of boxes inside a box. But since we have replaced the
fact that x0 ‚â§x1 with the structure of a set of morphisms, we need to be able to label
our boxes with morphism names:
f
A
B
Suppose given additional morphisms 1 : B ‚ÜíC, and h : C ‚ÜíD. Representing these
each as boxes like we did for f , we might be tempted to stick them together to form a
new box:
f
1
h
A
B
C
D
Ideally this would also be a morphism in our category: after all, we have said that we
can represent morphisms with boxes with one input and one output. But wait, you
say! We don‚Äôt know which morphism it is. Is it f # (1 # h)? Or ( f # 1) # h? It‚Äôs good that
you are so careful. Luckily, we are saved by the properties that a category must have.
Associativity says f # (1 # h)  ( f # 1) # h, so it doesn‚Äôt matter which way we chose to try
to decode the box.

4.4. CATEGORIFICATION
135
Similarly, the identity morphism on an object x is drawn as on the left below, but
we will see that it is not harmful to draw idx in any of the following three ways:
‚â§
x
x
‚â§
x
x
‚â§
x
x
By DeÔ¨Ånition 3.6 the morphisms in a category satisfy two properties, called the unitality
property and the associativity property. The unitality says that idx # f  f  f # idy for
any f : x ‚Üíy. In terms of diagrams this would say
f
f
x
x
y
f
f
x
y
y
f
x
y
=
=
This means you can insert or discard any identity morphism you see in a wiring dia-
gram. From this perspective, the coherence laws of a category‚Äîthat is, the associativity
law and the unitality law‚Äîare precisely what are needed to ensure we can lengthen
and shorten wires without ambiguity.
In Section 2.2.2, we also saw wiring diagrams for monoidal preorders. Here we
were allowed to draw boxes which can have multiple typed inputs and outputs, but
with no choice of label (always ‚â§):
‚â§
A1
A2
A3
B1
B2
If we combine these ideas, we will obtain a categoriÔ¨Åcation of symmetric monoidal
preorders: symmetric monoidal categories.
A symmetric monoidal category is an
algebraic structure in which we have labelled boxes with multiple typed inputs and
outputs:
f
A1
A2
A3
B1
B2
Furthermore, a symmetric monoidal category has a composition rule and a monoidal
product, which permit us to combine these boxes to interpret diagrams like this:
f
1
h
A
B
C
D
E
F
G

136
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Finally, this structure must obey coherence laws, analogous to associativity and uni-
tality in categories, that allow such diagrams to be unambiguously interpreted. In the
next section we will be a bit more formal, but it is useful to keep in mind that, when
we say our data must be ‚Äúwell behaved,‚Äù this is all we mean.
4.4.3
Monoidal categories
We deÔ¨Åned V-categories, for a symmetric monoidal preorder V in DeÔ¨Ånition 2.46. Just
like preorders turned out to be special kinds of categories (see Section 3.2.3), monoidal
preorders are special kinds of monoidal categories. And just like we can consider
V-categories for a monoidal preorder, we can also consider V-categories when V is a
monoidal category. This is another sort of categoriÔ¨Åcation.
We will soon meet the monoidal category (Set, {1}, √ó). The monoidal product will
take two sets, S and T, and return the set S √ó T  {(s, t) | s ‚ààS, t ‚ààT}. But whereas
for monoidal preorders we had the brute associative property (p ‚äóq) ‚äór  p ‚äó(q ‚äór),
the corresponding idea in Set is not quite true:
S √ó (T √ó U) :
 s, (t, u)  s ‚ààS, t ‚ààT, u ‚ààU
	
?
(S √ó T) √ó U :
 (s, t), u  s ‚ààS, t ‚ààT, u ‚ààU
	
.
They are slightly diÔ¨Äerent sets: the Ô¨Årst contains pairs consisting of an elements in S
and an element in T √ó U, while the second contains pairs consisting of an element in
S √ó T and an element in U. The sets are not equal, but they are clearly isomorphic,
i.e. the diÔ¨Äerence between them is ‚Äújust a matter of bookkeeping.‚Äù We thus need a
structure‚Äîa bookkeeping isomorphism‚Äîto keep track of the associativity:
Œ±s,t,u : {(s, (t, u)) | s ‚ààS, t ‚ààT, u ‚ààU}
‚àí‚Üí{((s, t), u) | s ‚ààS, t ‚ààT, u ‚ààU}.
There are a couple things to mention before we dive into these ideas. First, just
because you replace brute things and properties with structures, it does not mean that
you no longer have brute things and properties: new ones emerge! Not only that, but
second, the new brute stuÔ¨Ätends to be more complex than what you started with. For
example, above we replaced the associativity equation with an isomorphism Œ±s,t,u, but
now we need a more complex property to ensure that all these Œ±‚Äôs behave reasonably!
The only way out of this morass is to add inÔ¨Ånitely much structure, which leads one to
‚Äú‚àû-categories,‚Äù but we will not discuss that here.
Instead, we will continue with our categoriÔ¨Åcation of monoidal preorders, starting
with a rough deÔ¨Ånition of symmetric monoidal categories. It‚Äôs rough in the sense that
we suppress the technical bookkeeping, hiding it under the name ‚Äúwell behaved.‚Äù
Rough DeÔ¨Ånition 4.45. Let C be a category. A symmetric monoidal structure on C consists
of the following constituents:
(i) an object I ‚ààOb(C) called the monoidal unit, and

4.4. CATEGORIFICATION
137
(ii) a functor ‚äó: C √ó C ‚ÜíC, called the monoidal product
subject to well-behaved, natural isomorphisms
(a) Œªc : I ‚äóc  c for every c ‚ààOb(C),
(b) œÅc : c ‚äóI  c for every c ‚ààOb(C),
(c) Œ±c,d,e : (c ‚äód) ‚äóe  c ‚äó(d ‚äóe) for every c, d, e ‚ààOb(C), and
(d) œÉc,d : c ‚äód  d ‚äóc for every c, d ‚ààOb(C), called the swap map, such that œÉ ‚ó¶œÉ  id.
A category equipped with a symmetric monoidal structure is called a symmetric
monoidal category.
Remark 4.46. If the isomorphisms in (a), (b), and (c)‚Äîbut not (d)‚Äîare replaced by
equalities, then we say that the monoidal structure is strict, and this is a complete
(non-rough) deÔ¨Ånition of symmetric strict monoidal category. In fact, symmetric strict
monoidal categories are almost the same thing as symmetric monoidal categories, via
a result known as Mac Lane‚Äôs coherence theorem. An upshot of this theorem is that we
can, when useful to us, pretend that our monoidal categories are strict: for example,
we implicitly do this when we draw wiring diagrams. Ask your friendly neighborhood
category theorist to explain how!
Remark 4.47. For those yet to Ô¨Ånd a friendly expert category theorist, we make the
following remark. A complete (non-rough) deÔ¨Ånition of symmetric monoidal category
is that a symmetric monoidal category is a category equipped with an equivalence
to (the underlying category of) a symmetric strict monoidal category.
This can be
unpacked, using Remark 4.46 and our comment about equivalence of categories in
Remark 3.59, but we don‚Äôt expect you to do so. Instead, we hope this gives you more
incentive to ask a friendly expert category theorist!
Exercise 4.48.
Check that monoidal categories indeed generalize monoidal preorders:
a monoidal preorder is a monoidal category (P, I, ‚äó) where, for every p, q ‚ààP, the set
P(p, q) has at most one element.
‚ô¶
Example 4.49. As we said above, there is a monoidal structure on Set where the
monoidal unit is some choice of singleton set, say I B {1}, and the monoidal product
is ‚äóB √ó. What it means that √ó is a functor is that:
‚Ä¢ For any pair of objects, i.e. sets, (S, T) ‚ààOb(Set √ó Set), one obtains a set (S √ó T) ‚àà
Ob(Set). We know what it is: the set of pairs {(s, t) | s ‚ààS, t ‚ààT}.
‚Ä¢ For any pair of morphisms, i.e. functions, f : S ‚ÜíS‚Ä≤ and 1 : T ‚ÜíT‚Ä≤, one obtains a
function ( f √ó1): (S√óT) ‚Üí(S‚Ä≤√óT‚Ä≤). It works pointwise: ( f √ó1)(s, t) B ( f (s), 1(t)).
‚Ä¢ These should preserve identities: idS √ó idT  idS√óT for any sets S, T.
‚Ä¢ These should preserve composition: for any functions S
f
‚àí‚ÜíS‚Ä≤
f ‚Ä≤
‚àí‚ÜíS‚Ä≤‚Ä≤ and T
1
‚àí‚Üí
T‚Ä≤ 1‚Ä≤
‚àí‚ÜíT‚Ä≤‚Ä≤, one has
( f √ó 1) # ( f ‚Ä≤ √ó 1‚Ä≤)  ( f # 1) √ó ( f ‚Ä≤ # 1‚Ä≤).

138
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
The four conditions, (a), (b), (c), and (d) give isomorphisms {1} √ó S  S, etc. These
maps are obvious in the case of Set, e.g. the function {(1, s) | s ‚ààS} ‚ÜíS sending (1, s)
to s. We have been calling such things bookkeeping.
Exercise 4.50.
Consider the monoidal category (Set, 1, √ó), together with the diagram
f
1
h
A
B
C
D
E
F
G
Suppose that A  B  C  D  F  G  Z and E  B  {true, false}, and
suppose that fC(a)  |a|, fD(a)  a ‚àó5, 1E(d, b)  ‚Äúd ‚â§b,‚Äù 1F(d, b)  d ‚àíb, and
h(c, e)  if e then c else 1 ‚àíc.
1. What are 1E(5, 3) and 1F(5, 3)?
2. What are 1E(3, 5) and 1F(3, 5)?
3. What is h(5, true)?
4. What is h(‚àí5, true)?
5. What is h(‚àí5, false)?
The whole diagram now deÔ¨Ånes a function A √ó B ‚ÜíG √ó F; call it q.
6. What are qG(‚àí2, 3) and qF(‚àí2, 3)?
7. What are qG(2, 3) and qF(2, 3)?
‚ô¶
We will see more monoidal categories throughout the remainder of this book.
4.4.4
Categories enriched in a symmetric monoidal category
We will not need this again, but we once promised to explain why V-categories, where
V is a symmetric monoidal preorder, deserve to be seen as types of categories. The
reason, as we have hinted, is that categories should really be called Set-categories. But
wait, Set is not a preorder! We‚Äôll have to generalize‚Äîcategorify‚ÄîV-categories.
We now give a rough deÔ¨Ånition of categories enriched in a symmetric monoidal
category V. As in DeÔ¨Ånition 4.45, we suppress some technical parts in this sketch,
hiding them under the name ‚Äúusual associative and unital laws.‚Äù
Rough DeÔ¨Ånition 4.51. Let V be a symmetric monoidal category, as in DeÔ¨Ånition 4.45.
To specify a category enriched in V, or a V-category, denoted X,
(i) one speciÔ¨Åes a collection Ob(X), elements of which are called objects;
(ii) for every pair x, y ‚ààOb(X), one speciÔ¨Åes an object X(x, y) ‚ààV, called the hom-
object for x, y;
(iii) for every x ‚ààOb(X), one speciÔ¨Åes a morphism idx : I ‚ÜíX(x, x) in V, called the

4.5. PROFUNCTORS FORM A COMPACT CLOSED CATEGORY
139
identity element;
(iv) for each x, y, z ‚ààOb(X), one speciÔ¨Åes a morphism #: X(x, y) ‚äóX(y, z) ‚ÜíX(x, z),
called the composition morphism.
These constituents are required to satisfy the usual associative and unital laws.
The precise, non-rough, deÔ¨Ånition can be found in other sources, e.g. [nLa18],
[Wik18], [Kel05].
Exercise 4.52.
Recall from Example 4.49 that V  (Set, {1}, √ó) is a symmetric monoidal
category.
This means we can apply DeÔ¨Ånition 4.51.
Does the (rough) deÔ¨Ånition
roughly agree with the deÔ¨Ånition of category given in DeÔ¨Ånition 3.6? Or is there a
subtle diÔ¨Äerence?
‚ô¶
Remark 4.53. We Ô¨Årst deÔ¨Åned V-categories in DeÔ¨Ånition 2.46, where V was required to
be a monoidal preorder. To check we‚Äôre not abusing our terms, it‚Äôs a good idea to make
sure that V-categories as per DeÔ¨Ånition 2.46 are still V-categories as per DeÔ¨Ånition 4.51.
The Ô¨Årst thing to observe is that every symmetric monoidal preorder is a symmetric
monoidal category (Exercise 4.48). So given a symmetric monoidal preorder V, we can
apply DeÔ¨Ånition 4.51. The required data (i) and (ii) then get us oÔ¨Äto a good start: both
deÔ¨Ånitions of V-category require objects and hom-objects, and they are speciÔ¨Åed in the
same way. On the other hand, DeÔ¨Ånition 4.51 requires two additional pieces of data:
(iii) identity elements and (iv) composition morphisms. Where do these come from?
In the case of preorders, there is at most one morphism between any two objects, so
we do not need to choose an identity element and a composition morphism. Instead,
we just need to make sure that an identity element and a composition morphism exist.
This is exactly what properties (a) and (b) of DeÔ¨Ånition 2.46 say.
For example, the requirement (iii) that a V-category X has a chosen identity element
idx : I ‚ÜíX(x, x) for the object x simply becomes the requirement (a) that I ‚â§X(x, x) is
true in V. This is typical of the story of categoriÔ¨Åcation: what were mere properties in
DeÔ¨Ånition 2.46 have become structures in DeÔ¨Ånition 4.51.
Exercise 4.54.
What are identity elements in Lawvere metric spaces (that is, Cost-
categories)? How do we interpret this in terms of distances?
‚ô¶
4.5
Profunctors form a compact closed category
In this section we will deÔ¨Åne compact closed categories and show that Feas, and more
generally V-profunctors, form such a thing. Compact-closed categories are monoidal

140
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
categories whose wiring diagrams allow feedback. The wiring diagrams look like this:
f1
f2
f3
f4
f5
(4.55)
It‚Äôs been a while since we thought about co-design, but these were the kinds of wiring
diagrams we drew, e.g. connecting the chassis, the motor, and the battery in Eq. (4.1).
Compact closed categories are symmetric monoidal categories, with a bit more struc-
ture that allow us to formally interpret the sorts of feedback that occur in co-design
problems. This same structure shows up in many other Ô¨Åelds, including quantum
mechanics and dynamical systems.
In Eq. (2.13) and Section 2.2.3 we discussed various Ô¨Çavors of wiring diagrams,
including those with icons for splitting and terminating wires. For compact-closed
categories, our additional icons allow us to bend outputs into inputs, and vice versa.
To keep track of this, however, we draw arrows on our wire, which can either point
forwards or backwards. For example, we can draw this
Person 1
Person 2
pain
sound
fury
complaint
(4.56)
We then add icons‚Äîcalled a cap and a cup‚Äîallowing any wire to reverse direction
from forwards to backwards and from backwards to forwards.
sound
sound
sound
sound
(4.57)
Thus we can draw the following
Person 1
Person 2
pain
fury
sound
complaint
and its meaning is equivalent to that of Eq. (4.56).
We will begin by giving the axioms for a compact closed category.
Then we
will look again at feasibility relations in co-design‚Äîand more generally at enriched
profunctors‚Äîand show that they indeed form a compact closed category.

4.5. PROFUNCTORS FORM A COMPACT CLOSED CATEGORY
141
4.5.1
Compact closed categories
As we said, compact closed categories are symmetric monoidal categories (see DeÔ¨Åni-
tion 4.45) with extra structure.
DeÔ¨Ånition 4.58. Let (C, I, ‚äó) be a symmetric monoidal category, and c ‚ààOb(C) an
object. A dual for c consists of three constituents
(i) an object c‚àó‚ààOb(C), called the dual of c,
(ii) a morphism Œ∑c : I ‚Üíc‚àó‚äóc, called the unit for c,
(iii) a morphism œµc : c ‚äóc‚àó‚ÜíI, called the counit for c.
These are required to satisfy two equations for every c ‚ààOb(C), which we draw as
commutative diagrams:
c
c
c ‚äóI
I ‚äóc
c ‚äó(c‚àó‚äóc)
(c ‚äóc‚àó) ‚äóc

c‚äóŒ∑c


œµc‚äóc
c‚àó
c‚àó
I ‚äóc‚àó
c‚àó‚äóI
(c‚àó‚äóc) ‚äóc‚àó
c‚àó‚äó(c ‚äóc‚àó)

Œ∑c‚äóc‚àó


c‚àó‚äóœµc
(4.59)
These equations are sometimes called the snake equations.
If for every object c ‚ààOb(C) there exists a dual c‚àófor c, then we say that (C, I, ‚äó) is
compact closed.
In a compact closed category, each wire is equipped with a direction. For any object
c, a forward-pointing wire labeled c is considered equivalent to a backward-pointing
wire labeled c‚àó, i.e.
c‚àí‚Üíis the same as
c‚àó
‚Üê‚àí. The cup and cap discussed above are in fact
the unit and counit morphisms; they are drawn as follows.
c
Œ∑c
c
c
œµc
c
In wiring diagrams, the snake equations (4.59) are then drawn as follows:
c
c
c ‚äóŒ∑c
œµc ‚äóc
c
c
Œ∑c ‚äóc‚àó
c‚àó‚äóœµc
Note that the pictures in Eq. (4.57) correspond to œµsound and Œ∑sound‚àó.

142
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Recall the notion of monoidal closed preorder; a monoidal category can also be
monoidal closed. This means that for every pair of objects c, d ‚ààOb(C) there is an
object c ‚ä∏d and an isomorphism C(b ‚äóc, d)  C(b, c ‚ä∏d), natural in b. While we will
not provide a full proof here, compact closed categories are so-named because they are
a special type of monoidal closed category.
Proposition 4.60. If C is a compact closed category, then
1. C is monoidal closed;
and for any object c ‚ààOb(C),
2. if c‚àóand c‚Ä≤ are both duals to c then there is an isomorphism c‚àó c‚Ä≤; and
3. there is an isomorphism between c and its double-dual, c  c‚àó‚àó.
To prove 1., the key idea is that for any c and d, the object c ‚ä∏d is given by c‚àó‚äód,
and the natural isomorphism C(b ‚äóc, d)  C(b, c ‚ä∏d) is given by precomposing with
idb ‚äóŒ∑c.
Before returning to co-design, we give another example of a compact closed category,
called Corel, which we‚Äôll see again in the chapters to come.
Example 4.61. Recall, from DeÔ¨Ånition 1.18, that an equivalence relation on a set A is a
reÔ¨Çexive, symmetric, and transitive binary relation on A. Given two Ô¨Ånite sets, A and
B, a corelation A ‚ÜíB is an equivalence relation on A ‚äîB.
So, for example, here is a corelation from a set A having Ô¨Åve elements to a set B
having six elements; two elements are equivalent if they are encircled by the same
dashed line.
A
B
There exists a category, denoted Corel, where the objects are Ô¨Ånite sets, and where
a morphism from A ‚ÜíB is a corelation A ‚ÜíB. The composition rule is simpler to
look at than to write down formally.2 If in addition to the corelation Œ±: A ‚ÜíB above
we have another corelation Œ≤: B ‚ÜíC
B
C
Then the composite Œ≤ ‚ó¶Œ± of our two corelations is given by

4.5. PROFUNCTORS FORM A COMPACT CLOSED CATEGORY
143
B
A
C

A
C
That is, two elements are equivalent in the composite corelation if we may travel from
one to the other staying within equivalence classes of either Œ± or Œ≤.
The category Corel may be equipped with the symmetric monoidal structure
(¬ú, ‚äî).
This monoidal category is compact closed, with every Ô¨Ånite set its own
dual.
Indeed, note that for any Ô¨Ånite set A there is an equivalence relation on
A ‚äîA B {(a, 1), (a, 2) | a ‚ààA} where each part simply consists of the two elements (a, 1)
and (a, 2) for each a ‚ààA. The unit on a Ô¨Ånite set A is the corelation Œ∑A : ¬ú ‚ÜíA ‚äîA
speciÔ¨Åed by this equivalence relation; similarly the counit on A is the corelation
œµA : A ‚äîA ‚Üí¬ú specifed by this same equivalence relation.
Exercise 4.62.
Consider the set 3  {1, 2, 3}.
1. Draw a picture of the unit corelation ¬ú ‚Üí3 ‚äî3.
2. Draw a picture of the counit corelation 3 ‚äî3 ‚Üí¬ú.
3. Check that the snake equations (4.59) hold. (Since every object is its own dual,
you only need to check one of them.)
‚ô¶
4.5.2
Feas as a compact closed category
We close the chapter by returning to co-design and showing that Feas has a compact
closed structure. This is what allows us to draw the kinds of wiring diagrams we saw
in Eqs. (4.1), (4.55), and (4.56): it is what puts actual mathematics behind these pictures.
Instead of just detailing this compact closed structure for Feas  ProfBool, it‚Äôs no
extra work to prove that for any skeletal (unital, commutative) quantale (V, I, ‚äó) the
profunctor category ProfV of Theorem 4.23 is compact closed, so we‚Äôll discuss this
general fact.
2 To compose corelations Œ±: A ‚ÜíB and Œ≤: B ‚ÜíC, we need to construct an equivalence relation
Œ± # Œ≤ on A ‚äîC. To do so requires three steps: (i) consider Œ± and Œ≤ as relations on A ‚äîB ‚äîC, (ii) take the
transitive closure of their union, and then (iii) restrict to an equivalence relation on A ‚äîC. Here is the
formal description. Note that as binary relations, we have Œ± ‚äÜ(A ‚äîB)√ó(A ‚äîB), and Œ≤ ‚äÜ(B ‚äîC)√ó(B ‚äîC).
We also have three inclusions: ŒπA ‚äîB : A ‚äîB ‚ÜíA ‚äîB ‚äîC, ŒπB ‚äîC : B ‚äîC ‚ÜíA ‚äîB ‚äîC, and ŒπA ‚äîC : A ‚äîC ‚Üí
A ‚äîB ‚äîC. Recalling our notation from Section 1.4, we deÔ¨Åne
Œ± # Œ≤ B Œπ‚àó
A ‚äîC((ŒπA ‚äîB)!(Œ±) ‚à®(ŒπB ‚äîC)!(Œ≤)).

144
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Theorem 4.63. Let V be a skeletal quantale.
The category ProfV can be given the
structure of a compact closed category, with monoidal product given by the product
of V-categories.
Indeed, all we need to do is construct the monoidal structure and duals for objects.
Let‚Äôs sketch how this goes.
Monoidal products in ProfV are just product categories.
In terms of wiring diagrams,
the monoidal structure looks like stacking wires or boxes on top of one another, with
no new interaction.
Œ¶
Œ®
Œ¶ ‚äóŒ®
We take our monoidal product on ProfV to be that given by the product of V-categories;
the deÔ¨Ånition was given in DeÔ¨Ånition 2.74, and we worked out several examples there.
To recall, the formula for the hom-sets in X √ó Y is given by
(X √ó Y)((x, y), (x‚Ä≤, y‚Ä≤)) B X(x, x‚Ä≤) ‚äóY(y, y‚Ä≤).
But monoidal products need to be given on morphisms also, and the morphisms in
ProfV are V-profunctors. So given V-profunctors Œ¶: X1
X2 and Œ®: Y1
Y2, one
deÔ¨Ånes a V-profunctor (Œ¶ √ó Œ®): X1 √ó Y1
X2 √ó Y2 by
(Œ¶ √ó Œ®)((x1, y1), (x2, y2)) B Œ¶(x1, x2) ‚äóŒ®(y1, y2).
Exercise 4.64. Interpret the monoidal products in ProfBool in terms of feasibility. That is,
preorders represent resources ordered by availability (x ‚â§x‚Ä≤ means that x is available
given x‚Ä≤) and a profunctor is a feasibility relation. Explain why X √ó Y makes sense as
the monoidal product of resource preorders X and Y and why Œ¶ √ó Œ® makes sense as
the monoidal product of feasibility relations Œ¶ and Œ®.
‚ô¶
The monoidal unit in ProfV is 1.
To deÔ¨Åne a monoidal structure on ProfV, we need
not only a monoidal product‚Äîas deÔ¨Åned above‚Äîbut also a monoidal unit. Recall the
V-category 1; it has one object, say 1, and (1, 1)  I is the monoidal unit of V. We take
1 to be the monoidal unit of ProfV.
Exercise 4.65.
In order for 1 to be a monoidal unit, there are supposed to be isomor-
phisms X √ó 1
X and 1 √ó X
X in ProfV, for any V-category X. What are they?
‚ô¶

4.6. SUMMARY AND FURTHER READING
145
Duals in ProfV are just opposite categories.
In order to regard ProfV as a compact
closed category (DeÔ¨Ånition 4.58), it remains to specify duals and the corresponding
cup and cap.
Duals are easy: for every V-category X, its dual is its opposite category Xop (see
Exercise 2.73). The unit and counit then look like identities. To elaborate, the unit is a
V-profunctor Œ∑X : 1
Xop √ó X. By deÔ¨Ånition, this is a V-functor
Œ∑X : 1 √ó Xop √ó X ‚ÜíV;
we deÔ¨Åne it by Œ∑X(1, x, x‚Ä≤) B X(x, x‚Ä≤). Similarly, the counit is the profunctor œµX : (X √ó
Xop)
1, deÔ¨Åned by œµX(x, x‚Ä≤, 1) B X(x, x‚Ä≤).
Exercise 4.66.
Check these proposed units and counits do indeed obey the snake
equations Eq. (4.59).
‚ô¶
4.6
Summary and further reading
This chapter introduced three important ideas in category theory: profunctors, cate-
goriÔ¨Åcation, and monoidal categories. Let‚Äôs talk about them in turn.
Profunctors generalize binary relations. In particular, we saw that the idea of pro-
functor over a monoidal preorder gave us the additional power necessary to formalize
the idea of a feasibility relation between resource preorders. The idea of a feasibility re-
lation is due to Andrea Censi; he called them monotone codesign problems. The basic idea
is explained in [Cen15], where he also gives a programming language to specify and
solve codesign problems. In [Cen17], Censi further discusses how to use estimation to
make solving codesign problems computationally eÔ¨Écient.
We also saw profunctors over the preorder Cost, and how to think of these as bridges
between Lawvere metric space. We referred earlier to Lawvere‚Äôs paper [Law73]; plenty
more on Cost-profunctors can be found there.
Profunctors, however are vastly more general than the two examples we have dis-
cussed; V-profunctors can be deÔ¨Åned not only when V is a preorder, but for any
symmetric monoidal category. A delightful, detailed exposition of profunctors and
related concepts such as equipments, companions and conjoints, symmetric monoidal
bicategories can be found in [Shu08; Shu10].
We have not deÔ¨Åned symmetric monoidal bicategories, but you would be correct if
you guessed this is a sort of categoriÔ¨Åcation of symmetric monoidal categories. Baez
and Dolan tell the subtle story of categorifying categories to get ever higher categories
in [BD98]. Crane and Yetter give a number of examples of categoriÔ¨Åcation in [CY96].
Finally, we talked about monoidalcategoriesandcompactclosedcategories. Monoidal
categories are a classic, central topic in category theory, and a quick introduction can
be found in [Mac98]. Wiring diagrams play a huge role in this book and in applied
category theory in general; while informally used for years, these were Ô¨Årst formalized
in the case of monoidal categories. You can Ô¨Ånd the details here [JS93; JSV96].

146
CHAPTER 4. CO-DESIGN: PROFUNCTORS AND MONOIDAL CATEGORIES
Compact closed categories are a special type of structured monoidal category; there
are many others. For a broad introduction to the diÔ¨Äerent Ô¨Çavors of monoidal category,
detailed through their various styles of wiring diagram, see [Sel10].

Chapter 5
Signal Ô¨Çow graphs:
Props, presentations, and proofs
5.1
Comparing systems as interacting signal processors
Cyber-physical systems are systems that involve tightly interacting physical and com-
putational parts. An example is an autonomous car: sensors inform a decision system
that controls a steering unit that drives a car, whose movement changes the sensory in-
put. While such systems involve complex interactions of many diÔ¨Äerent subsystems‚Äî
both physical ones, such as the driving of a wheel by a motor, or a voltage placed across
a wire, and computational ones, such as a program that takes a measured velocity and
returns a desired acceleration‚Äîit is often useful to model the system behavior as sim-
ply the passing around and processing of signals. For this illustrative sketch, we will
just think of signals as things which we can add and multiply, such as real numbers.
Interaction in cyber-physical systems can often be understood as variable sharing;
i.e. when two systems are linked, certain variables become shared. For example, when
we connect two train carriages by a physical coupling, the train carriages must have
the same velocity, and their positions diÔ¨Äer by a constant. Similarly, when we connect
two electrical ports, the electric potentials at these two ports now must be the same,
and the current Ô¨Çowing into one must equal the current Ô¨Çowing out of the other.
Of course, the way the shared variable is actually used may be very diÔ¨Äerent for the
diÔ¨Äerent subsystems using it, but sharing the variable serves to couple those systems
nonetheless.
Note that both the above examples involve the physical joining of two systems; more
Ô¨Åguratively, we might express the interconnection by drawing a line connecting the
boxes that represent the systems. In its simplest form, this is captured by the formalism
of signal Ô¨Çow graphs, due to Claude Shannon in the 1940s. Here is an example of a
147

148
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
signal Ô¨Çow graph:
7
5
3
2
(5.1)
We consider the dangling wires on the left as inputs, and those on the right as outputs.
In Eq. (5.1) we see three types of signal processing units, which we interpret as follows:
‚Ä¢ Each unit labelled by a number a takes an input and multiplies it by a.
‚Ä¢ Each black dot takes an input and produces two copies of it.
‚Ä¢ Each white dot takes two inputs and produces their sum.
Thus the above signal Ô¨Çow graph takes in two input signals, say x (on the upper left
wire) and y (on the lower left wire), and‚Äîgoing from left to right as described above‚Äî
produces two output signals: u  15x (upper right) and v  3x + 21y (lower right).
Let‚Äôs show some steps from this computation (leaving others oÔ¨Äto avoid clutter):
y
7y
x
x
15x
x + 7y
2x + 14y
3x + 21y
7
5
3
2
In words, the signal Ô¨Çow graph Ô¨Årst multiplies y by 7, then splits x into two copies,
adds the second copy of x to the lower signal to get x + 7y, and so on.
A signal Ô¨Çow graph might describe an existing system, or it might specify a system
to be built.
In either case, it is important to be able to analyze these diagrams to
understand how the composite system converts inputs to outputs. This is reminiscent
of a co-design problem from Chapter 4, which asks how to evaluate the composite
feasibility relation from a diagram of simpler feasibility relations. We can use this
process of evaluation to determine whether two diÔ¨Äerent signal Ô¨Çow graphs in fact
specify the same composite system, and hence to validate that a system meets a given
speciÔ¨Åcation.
In this chapter, however, we introducecategoricaltools‚Äîpropsandtheirpresentations‚Äî
for reasoning more directly with the diagrams. Recall from Chapter 2 that symmetric
monoidal preorders are a type of symmetric monoidal category where the morphisms
are constrained to be very simple: there can be at most one morphism between any
two objects. Here shall see that signal Ô¨Çow graphs represent morphisms in a diÔ¨Äerent,
complementary simpliÔ¨Åcation of the symmetric monoidal category concept, known as
a prop.1 A prop is a symmetric monoidal category where the objects are constrained to
be very simple: they are generated, using the monoidal product, by just a single object.
1 Historically, the word ‚Äòprop‚Äô was written in all caps, ‚ÄòPROP,‚Äô standing for ‚Äòproducts and permutations
category.‚Äô However, we Ô¨Ånd ‚ÄòPROP‚Äô a bit loud, so like many modern authors we opt for writing it as
‚Äòprop.‚Äô

5.2. PROPS AND PRESENTATIONS
149
Just as the wiring diagrams for symmetric monoidal preorders did not require labels
on the boxes, this means that wiring diagrams for props do not require labels on the
wires. This makes props particularly suited for describing diagrammatic formalisms
such as signal Ô¨Çow graphs, which only have wires of a single type.
Finally, many systems behave in what is called a linear way, and linear systems
form a foundational part of control theory, a branch of engineering that works on
cyber-physical systems.
Similarly, linear algebra is a foundational part of modern
mathematics, both pure and applied, which includes not only control theory, but also
the practice of computing, physics, statistics, and many others. As we analyze signal
Ô¨Çow graphs, we shall see that they are in fact a way of recasting linear algebra‚Äîmore
speciÔ¨Åcally, matrix operations‚Äîin graphical terms. More formally, we shall say that
signal Ô¨Çow graphs have functorial semantics as matrices.
5.2
Props and presentations
Signal Ô¨Çow graphs as in Eq. (5.1) are easily seen to be wiring diagrams of some sort.
However they have the property that, unlike for monoidal preorders and monoidal
categories, there is no need to label the wires. This corresponds to a form of symmetric
monoidal category, known as a prop, which has a very particular set of objects.
5.2.1
Props: deÔ¨Ånition and Ô¨Årst examples
Recall the deÔ¨Ånition of symmetric strict monoidal category from DeÔ¨Ånition 4.45 and Re-
mark 4.46.
DeÔ¨Ånition 5.2. A prop is a symmetric strict monoidal category (C, 0, +) for which
Ob(C)  N, the monoidal unit is 0 ‚ààN, and the monoidal product on objects is
given by addition.
Note that each object n is the n-fold monoidal product of the object 1; we call 1 the
generating object. Since the objects of a prop are always the natural numbers, to specify
a prop P it is enough to specify Ô¨Åve things:
(i) a set C(m, n) of morphisms m ‚Üín, for m, n ‚ààN.
(ii) for all n ‚ààN, an identity map idn : n ‚Üín.
(iii) for all m, n ‚ààN, a symmetry map œÉm,n : m + n ‚Üín + m.
(iv) a composition rule: given f : m ‚Üín and 1 : n ‚Üíp, a map ( f # 1): m ‚Üíp.
(v) a monoidal product on morphisms: given f : m ‚Üím‚Ä≤ and 1 : n ‚Üín‚Ä≤, a map
( f + 1): m + n ‚Üím‚Ä≤ + n‚Ä≤.
Once one speciÔ¨Åes the above data, he should check that his speciÔ¨Åcations satisfy the
rules of symmetric monoidal categories (see DeÔ¨Ånition 4.45).2
2We use ‚Äòhis‚Äô terminology because this deÔ¨Ånition is for boys only. The rest of the book is for girls only.

150
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Example 5.3. There is a prop FinSet where the morphisms f : m ‚Üín are functions
from m  {1, . . . m} to n  {1, . . . , n}. (The identities, symmetries, and composition
rule are obvious.) The monoidal product on functions is given by the disjoint union of
functions: that is, given f : m ‚Üím‚Ä≤ and 1 : n ‚Üín‚Ä≤, we deÔ¨Åne f + 1 : m + n ‚àí‚Üím‚Ä≤ + n‚Ä≤
by
i 7‚àí‚Üí
(
f (i)
if 1 ‚â§i ‚â§m;
m‚Ä≤ + 1(i)
if m + 1 ‚â§i ‚â§m + n.
(5.4)
Exercise 5.5.
In Example 5.3 we said that the identities, symmetries, and composition
rule in FinSet ‚Äúare obvious.‚Äù In math lingo, this just means ‚Äúwe trust that the reader
can Ô¨Ågure them out, if she spends the time tracking down the deÔ¨Ånitions and Ô¨Åtting
them together.‚Äù
1. Draw a morphism f : 3 ‚Üí2 and a morphism 1 : 2 ‚Üí4 in FinSet.
2. Draw f + 1.
3. What is the composition rule for morphisms f : m ‚Üín and 1 : n ‚Üíp in FinSet?
4. What are the identities in FinSet? Draw some.
5. Choose m, n ‚ààN, and draw the symmetry map œÉm,n in FinSet?
‚ô¶
Example 5.6. Recall from DeÔ¨Ånition 1.22 that a bƒ≥ection is a function that is both
surjective and injective.
There is a prop Bij where the morphisms f : m ‚Üín are
bƒ≥ections m ‚Üín. Note that in this case morphisms m ‚Üín only exist when m  n;
when m , n the homset Bij(m, n) is empty. Since Bij is a subcategory of FinSet, we
can deÔ¨Åne the monoidal product to be as in Eq. (5.4).
Example 5.7. The compact closed category Corel, in which the morphisms f : m ‚Üín
are partitions on m ‚äîn (see Example 4.61), is a prop.
Example 5.8. There is a prop Rel for which morphisms m ‚Üín are relations, R ‚äÜm √ó n.
The composition of R with S ‚äÜn √ó p is
R # S B {(i, k) ‚ààm √ó p | ‚àÉ(j ‚ààn). (i, j) ‚ààR and (j, k) ‚ààS}.
The monoidal product is relatively easy to formalize using universal properties,3 but
one might get better intuition from pictures:
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
+
=

5.2. PROPS AND PRESENTATIONS
151
Exercise 5.9.
A posetal prop is a prop that is also a poset. That is, a posetal prop is a
symmetric monoidal preorder of the form (N, ‚™Ø), for some poset relation ‚™Øon N, where
the monoidal product on objects is addition. We‚Äôve spent a lot of time discussing order
structures on the natural numbers. Give three examples of a posetal prop.
‚ô¶
Exercise 5.10.
Choose one of Examples 5.6 to 5.8 and explicitly provide the Ô¨Åve aspects
of props discussed below DeÔ¨Ånition 5.2.
‚ô¶
DeÔ¨Ånition 5.11. Let C and D be props. A functor F : C ‚ÜíD is called a prop functor if
(a) F is identity-on-objects, i.e. F(n)  n for all n ‚ààOb(C)  Ob(D)  N, and
(b) for all f : m1 ‚Üím2 and 1 : n1 ‚Üín2 in C, we have F( f ) + F(1)  F( f + 1) in D.
Example 5.12. The inclusion i : Bij ‚ÜíFinSet is a prop functor. Perhaps more interest-
ingly, there is a prop functor F : FinSet ‚ÜíRelFin. It sends a function f : m ‚Üín to the
relation F( f ) B {(i, j) | f (i)  j} ‚äÜm √ó n.
5.2.2
The prop of port graphs
An important example of a prop is the one in which morphisms are open, directed,
acyclic port graphs, as we next deÔ¨Åne. We will just call them port graphs.
DeÔ¨Ånition 5.13. For m, n ‚ààN, an (m, n)-port graph (V, in, out, Œπ) is speciÔ¨Åed by
(i) a set V, elements of which are called vertices,
(ii) functions in, out: V ‚ÜíN, where in(v) and out(v) are called the in degree and out
degree of each v ‚ààV, and
(iii) a bƒ≥ection Œπ: m ‚äîO
‚ÜíI ‚äîn, where I  {(v, i) | v ‚ààV, 1 ‚â§i ‚â§in(v)} is the set of
vertex inputs, and O  {(v, i) | v ‚ààV, 1 ‚â§i ‚â§out(v)} is the set of vertex outputs.
This data must obey the following acyclicity condition. First, use the bƒ≥ection Œπ to
construct the graph with vertices V and with an arrow eu,i
v,j : u ‚Üív for every i, j ‚ààN
such that Œπ(u, i)  (v, j); call it the internal Ô¨Çow graph. If the internal Ô¨Çow graph is
acyclic‚Äîthat is, if the only path from any vertex v to itself is the trivial path‚Äîthen we
say that (V, in, out, Œπ) is a port graph.
This seems quite a technical construction, but it‚Äôs quite intuitive once you unpack it
a bit. Let‚Äôs do this.
3The monoidal product R1 + R2 of relations R1 ‚äÜm1 √ó n1 and R2 ‚äÜm2 √ó n2 is given by R1 ‚äîR2 ‚äÜ
(m1 √ó n1) ‚äî(m2 √ó n2) ‚äÜ(m1 ‚äîm2) √ó (n1 ‚äîn2).

152
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Example 5.14. Here is an example of a (2, 3)-port graph, i.e. with m  2 and n  3:
a
b
c
1
2
1
1
2
3
1
2
1
2
3
1
2
3
1
1
2
3
(5.15)
Since the port graph has type (2, 3), we draw two ports on the left hand side of the
outer box, and three on the right. The vertex set is V  {a, b, c} and, for example
in(a)  1 and out(a)  3, so we draw one port on the left-hand side and three ports on
the right-hand side of the box labelled a. The bƒ≥ection Œπ is what tells us how the ports
are connected by wires:
‚Ä¢
1
‚Ä¢
2
‚Ä¢
(a, 1)
‚Ä¢
(a, 2)
‚Ä¢
(a, 3)
‚Ä¢
(b, 1)
‚Ä¢
(b, 2)
‚Ä¢
(b, 3)
‚Ä¢
(c, 1)
‚Ä¢
(a, 1)
‚Ä¢
(b, 1)
‚Ä¢
(b, 2)
‚Ä¢
(b, 3)
‚Ä¢
(c, 1)
‚Ä¢
(c, 2)
‚Ä¢
1
‚Ä¢
2
‚Ä¢
3
m
O
I
n
The internal Ô¨Çow graph‚Äîwhich one can see is acyclic‚Äîis shown below:
a‚Ä¢
c‚Ä¢
b‚Ä¢
ea,1
c,1
ea,2
b,2
ea,3
b,1
eb,1
c,2
As you might guess from (5.15), port graphs are closely related to wiring diagrams
for monoidal categories, and even more closely related to wiring diagrams for props.
A category PG whose morphisms are port graphs.
Given an (m, n)-port graph
(V, in, out, Œπ) and an (n, p)-port graph (V‚Ä≤, in‚Ä≤, out‚Ä≤, Œπ‚Ä≤), we may compose them to produce
an (m, p)-port graph (V ‚äîV‚Ä≤, [in, in‚Ä≤], [out, out‚Ä≤], Œπ‚Ä≤‚Ä≤). Here [in, in‚Ä≤] denotes the function
V ‚äîV‚Ä≤ ‚ÜíN which maps elements of V according to in, and elements of V‚Ä≤ according
to in‚Ä≤, and similarly for [out, out‚Ä≤]. The bƒ≥ection Œπ‚Ä≤‚Ä≤: m ‚äîO ‚äîO‚Ä≤ ‚ÜíI ‚äîI‚Ä≤ ‚äîp is deÔ¨Åned

5.2. PROPS AND PRESENTATIONS
153
as follows:
Œπ‚Ä≤‚Ä≤(x) 
Ô£±Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
Œπ(x)
if Œπ(x) ‚ààI
Œπ‚Ä≤(Œπ(x))
if Œπ(x) ‚ààn
Œπ‚Ä≤(x)
if x ‚ààO.‚Ä≤
Exercise 5.16.
Describe how port graph composition looks, with respect to the visual
representation of Example 5.14, and give a nontrivial example.
‚ô¶
We thus have a category PG, whose objects are natural numbers Ob(PG)  N,
whose morphisms are port graphs PG(m, n)  {(V, in, out, Œπ) | as in DeÔ¨Ånition 5.13}.
Composition of port graphs is as above, and the identity port graph on n is the (n, n)-
port graph (¬ú, !, !, idn), where !: ¬ú ‚ÜíN is the unique function. The identity on an
object, say 3, is depicted as follows:
1
2
3
1
2
3
The monoidal structure structure on PG.
This category PG is in fact a prop. The
monoidal product of two port graphs G B (V, in, out, Œπ) and G‚Ä≤ B (V‚Ä≤, in‚Ä≤, out‚Ä≤, Œπ‚Ä≤) is
given by taking the disjoint union of Œπ and Œπ‚Ä≤:
G + G‚Ä≤ B  (V ‚äîV‚Ä≤), [in, in‚Ä≤], [out, out‚Ä≤], (Œπ ‚äîŒπ‚Ä≤)
.
(5.17)
The monoidal unit is (¬ú, !, !, !).
Exercise 5.18.
Draw the monoidal product of the morphism shown in Eq. (5.15) with
itself. It will be a (4, 6)-port graph, i.e. a morphism 4 ‚Üí6 in PG.
‚ô¶
5.2.3
Free constructions and universal properties
Given some sort of categorical structure, such as a preorder, a category, or a prop, it
is useful to be able to construct one according to your own speciÔ¨Åcation. (This should
not be surprising.) The minimally-constrained structure that contains all the data you
specify is called the free structure on your speciÔ¨Åcation: it‚Äôs free from unneccessary
constraints! We have already seen some examples of free structures; let‚Äôs recall and
explore them.
Example 5.19 (The free preorder on a relation). For preorders, we saw the construction
of taking the reÔ¨Çexive, transitive closure of a relation. That is, given a relation R ‚äÜP√óP,
the reÔ¨Çexive, transitive closure of R is the called the free preorder on R. Rather than
specify all the inequalities in the preorder (P, ‚â§), we can specify just a few inequalities
p ‚â§q, and let our ‚Äúclosure machine‚Äù add in the minimum number of other inequalities
necessary to make P a preorder. To obtain a preorder out of a graph, or Hasse diagram,
we consider a graph (V, A, s, t) as deÔ¨Åning a relation {(s(a), t(a)) | a ‚ààA} ‚äÜV √óV, and

154
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
apply this closure machine.
But in what sense is the reÔ¨Çexive, transitive closure of a relation R ‚äÜP √ó P really
the minimally-constrained preorder containing R? One way of understanding this is that
the extra equalities impose no further constraints when deÔ¨Åning a monotone map out
of P. We are claiming that freeness has something to do with maps out! As strange as
an asymmetry might seem here (one might ask, ‚Äúwhy not maps in?‚Äù), the reader will
have an opportunity to explore it for herself in Exercises 5.20 and 5.21.
A higher-level justiÔ¨Åcation understands freeness as a left adjoint (see Example 3.74),
but we will not discuss that here.
Exercise 5.20. Let P be a set, let R ‚äÜP√óP a relation, let (P, ‚â§P) be the preorder obtained
by taking the reÔ¨Çexive, transitive closure of R, and let (Q, ‚â§Q) be an arbitrary preorder.
Finally, let f : P ‚ÜíQ be a function, not assumed monotone.
1. Suppose that for every x, y ‚ààP, if R(x, y) then f (x) ‚â§f (y). Show that f deÔ¨Ånes
a monotone map f : (P, ‚â§P) ‚Üí(Q, ‚â§Q).
2. Suppose that f deÔ¨Ånes a monotone map f : (P, ‚â§P) ‚Üí(Q, ‚â§Q). Show that for
every x, y ‚ààP, if R(x, y) then f (x) ‚â§Q f (y).
We call this the universal property of the free preorder (P, ‚â§P).
‚ô¶
Exercise 5.21.
Let P, Q, R, etc. be as in Exercise 5.20. We want to see that the universal
property is really about maps out of‚Äîand not maps in to‚Äîthe reÔ¨Çexive, transitive
closure (P, ‚â§). So let 1 : Q ‚ÜíP be a function.
1. Suppose that for every a, b ‚ààQ, if a ‚â§b then (1(a), 1(b)) ‚ààR. Is it automatically
true that 1 deÔ¨Ånes a monotone map 1 : (Q, ‚â§Q) ‚Üí(P, ‚â§P)?
2. Suppose that 1 deÔ¨Ånes a monotone map 1 : (Q, ‚â§Q) ‚Üí(P, ‚â§P). Is it automatically
true that for every a, b ‚ààQ, if a ‚â§b then (1(a), 1(b)) ‚ààR?
The lesson is that maps between structured objects are deÔ¨Åned to preserve con-
straints. This means the domain of a map must be somehow more constrained than
the codomain. Thus having the fewest additional constraints coincides with having the
most maps out‚Äîevery function that respects our generating constraints should deÔ¨Åne
a map.
‚ô¶
Example 5.22 (The free category on a graph). There is a similar story for categories.
Indeed, we saw in DeÔ¨Ånition 3.7 the construction of the free category Free(G) on a
graph G. The objects of Free(G) and the vertices of G are the same‚Äînothing new
here‚Äîbut the morphisms of Free(G) are not just the arrows of G because morphisms
in a category have stricter requirements: they must compose and there must be an
identity. Thus morphisms in Free(G) are the closure of the set of arrows in G under
these operations. Luckily (although this happens often in category theory), the result
turns out to already be a relevant graph concept: the morphisms in Free(G) are exactly
the paths in G.
So Free(G) is a category that in a sense contains G and obeys no
equations other than those that categories are forced to obey.

5.2. PROPS AND PRESENTATIONS
155
Exercise 5.23.
Let G  (V, A, s, t) be a graph, and let G be the free category on G. Let C
be another category whose set of morphisms is denoted Mor(C).
1. Someone tells you that thereare‚Äúdomainandcodomain‚Äùfunctionsdom, cod: Mor(C) ‚Üí
Ob(C); interpret this statement.
2. Show that the set of functors G ‚ÜíC are in one-to-one correspondence with the
set of pairs of functions ( f , 1), where f : V ‚ÜíOb(C) and 1 : A ‚ÜíMor(C) for
which dom(1(a))  f (s(a)) and cod(1(a))  f (t(a)) for all a.
3. Is (Mor(C), Ob(C), dom, cod) a graph? If so, see if you can use the word ‚Äúadjunc-
tion‚Äù in a sentence that describes the statement in part 2. If not, explain why
not.
‚ô¶
Exercise 5.24 (The free monoid on a set).
Recall from Example 3.13 that monoids are
one-object categories. For any set A, there is a graph Loop(A) with one vertex and with
one arrow from the vertex to itself for each a ‚ààA. So if A  {a, b} then Loop(A) looks
like this:
‚Ä¢
a
b
The free category on this graph is a one-object category, and hence a monoid; it‚Äôs called
the free monoid on A.
1. What are the elements of the free monoid on the set A  {a}?
2. Can you Ô¨Ånd a well-known monoid that is isomorphic to the free monoid on {a}?
3. What are the elements of the free monoid on the set A  {a, b}?
‚ô¶
5.2.4
The free prop on a signature
We have been discussing free constructions, in particular for preorders and categories.
A similar construction exists for props. Since we already know what the objects of
the prop will be‚Äîthe natural numbers‚Äîall we need to specify is a set G of generating
morphisms, together with the arities,4 that we want to be in our prop. This information
will be called a signature. Just as we can generate the free category from a graph, so too
can we generate the free prop from a signature.
We now give an explicit construction of the free prop in terms of port graphs (see
DeÔ¨Ånition 5.13).
DeÔ¨Ånition 5.25. A prop signature is a tuple (G, s, t), where G is a set and s, t : G ‚ÜíN
are functions; each element 1 ‚ààG is called a generator and s(1), t(1) ‚ààN are called its
in-arity and out-arity. We often denote (G, s, t) simply by G, taking s, t to be implicit.
A G-labeling of a port graph Œì  (V, in, out, Œπ) is a function ‚Ñì: V ‚ÜíG such that the
arities agree: s(‚Ñì(v))  in(v) and t(‚Ñì(v))  out(v) for each v ‚ààV.
DeÔ¨Åne the free prop on G, denoted Free(G), to have as morphisms m ‚Üín all G-
labeled (m, n)-port graphs. The composition and monoidal structure are just those for
4The arity of a prop morphism is a pair (m, n) ‚ààN √ó N, where m is the number of inputs and n is the
number of outputs.

156
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
port graphs PG (see Eq. (5.17)); the labelings (the ‚Ñì‚Äôs) are just carried along.
The morphisms in Free(G) are port graphs (V, in, out, Œπ) as in DeÔ¨Ånition 5.13, that
are equipped with a G-labeling. To draw a port graph, just as in Example 5.14, we draw
each vertex v ‚ààV as a box with in(v)-many ports on the left and out(v)-many ports on
the right. In wiring diagrams, we depict the labeling function ‚Ñì: V ‚ÜíG by using ‚Ñìto
add labels (in the usual sense) to our boxes. Note that multiple boxes can be labelled
with the same generator. For example, if G  { f : 1 ‚Üí1, 1 : 2 ‚Üí2, h : 2 ‚Üí1}, then the
following is a morphism 3 ‚Üí2 in Free(G):
1
1
h
(5.26)
Note that the generator 1 is used twice, while the generator f is not used at all in
Eq. (5.26). This is perfectly Ô¨Åne.
Example 5.27. The free prop on the empty set ¬ú is Bij. This is because each morphism
must have a labelling function of the form V ‚Üí¬ú, and hence we must have V  ¬ú;
see Exercise 1.25. Thus the only morphisms (n, m) are those given by port graphs
(¬ú, !, !, œÉ), where œÉ: n ‚Üím is a bƒ≥ection.
Exercise 5.28.
Consider the following prop signature:
G B {œÅm,n | m, n ‚ààN},
s(œÅm,n) B m,
t(œÅm,n) B n,
i.e. having one generating morphism for each (m, n) ‚ààN2. Show that Free(G) is the
prop PG of port graphs from Section 5.2.2.
‚ô¶
Just like free preorders and free categories, the free prop is characterized by a
universal property in terms of maps out. The following can be proved in a manner
similar to Exercise 5.23.
Proposition 5.29. The free prop Free(G) on a signature (G, s, t) has the property that,
for any prop C, the prop functors Free(G) ‚ÜíC are in one-to-one correspondence with
functions G ‚ÜíC that send each 1 ‚ààG to a morphism s(1) ‚Üít(1) in C.
An alternate way to describe morphisms in Free(G).
Port graphs provide a conve-
nient formalism of thinking about morphisms in the free prop on a signature G, but
there is another approach which is also useful. It is syntactic, in the sense that we start
with a small stock of basic morphisms, including elements of G, and then we inductively

5.2. PROPS AND PRESENTATIONS
157
build new morphisms from them using the basic operations of props: namely compo-
sition and monoidal product. Sometimes the conditions of monoidal categories‚Äîe.g.
associativity, unitality, functoriality, see DeÔ¨Ånition 4.45‚Äîforce two such morphisms to
be equal, and so we dutifully equate them. When we are done, the result is again the
free prop Free(G). Let‚Äôs make this more formal.
First, we need the notion of a prop expression. Just as prop signatures are the
analogue of the graphs used to present categories, prop expressions are the analogue
of paths in these graphs.
DeÔ¨Ånition 5.30. Suppose we have a set G and functions s, t : G ‚ÜíN. We deÔ¨Åne a
G-generated prop expression, or simply expression e : m ‚Üín, where m, n ‚ààN, inductively
as follows:
‚Ä¢ The empty morphism id0 : 0 ‚Üí0, the identity morphism id1 : 1 ‚Üí1, and the
symmetry œÉ: 2 ‚Üí2 are expressions.5
‚Ä¢ the generators 1 ‚ààG are expressions 1 : s(1) ‚Üít(1).
‚Ä¢ if Œ±: m ‚Üín and Œ≤: p ‚Üíq are expressions, then Œ± + Œ≤: m + p ‚Üín + q is an
expression.
‚Ä¢ if Œ±: m ‚Üín and Œ≤: n ‚Üíp are expressions, then Œ± # Œ≤: m ‚Üíp is an expression.
We write Expr(G) for the set of expressions in G. If e : m ‚Üín is an expression, we refer
to (m, n) as its arity.
Example 5.31. Let G  { f : 1 ‚Üí1, 1 : 2 ‚Üí2, h : 2 ‚Üí1}. Then
‚Ä¢ id1 : 1 ‚Üí1,
‚Ä¢ f : 1 ‚Üí1,
‚Ä¢ f # id1 : 1 ‚Üí1,
‚Ä¢ h + id1 : 3 ‚Üí2, and
‚Ä¢ (h + id1) # œÉ # 1 # œÉ: 3 ‚Üí2
are all G-generated prop expressions.
Both G-labeled port graphs and G-generated prop expressions are ways to describe
morphisms in the free prop Free(G). Note, however, that unlike for G-labeled port
graphs, there may be two G-generated prop expressions that represent the same mor-
phism. For example, we want to consider f # id1 and f to be the same morphism,
since the unitality axiom for categories says f # id1  f . Nonetheless, we only consider
two G-generated prop expressions equal when some axiom from the deÔ¨Ånition of prop
requires that they be so; again, the free prop is the minimally-constrained way to take G
and obtain a prop.
Since both port graphs and prop expressions describe morphisms in Free(G), you
might be wondering how to translate between them. Here‚Äôs how to turn a port graph
into a prop expression: imagine a vertical line moving through the port graph from
5One can think of œÉ as the ‚Äúswap‚Äù icon
: 2 ‚Üí2

158
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
left to right. Whenever you see ‚Äúaction‚Äù‚Äîeither a box or wires crossing‚Äîwrite down
the sum (using +) of all the boxes 1, all the symmetries œÉ, and all the wires id1 in that
column. Finally, compose all of those action columns. For example, in the picture
below we see four action columns:
1
1
h
Here the result is (1 + id1) # (id1 + œÉ) # (id1 + 1) # (h + id1).
Exercise 5.32.
Consider again the free prop on generators G  { f : 1 ‚Üí1, 1 : 2 ‚Üí
2, h : 2 ‚Üí1}. Draw a picture of ( f +id1 +id1)#(œÉ +id1)#(id1 + h)# œÉ # 1, where œÉ: 2 ‚Üí2
is the symmetry map.
‚ô¶
Another way of describing when we should consider two prop expressions equal is
to say that they are equal if and only if they represent the same port graph. In either
case, these notions induce an equivalence relation on the set of prop expressions. To say
that we consider these certain prop expressions equal is to say that the morphisms of
the free prop on G are the G-generated prop expressions quotiented by this equivalence
relation (see DeÔ¨Ånition 1.21).
5.2.5
Props via presentations
In Section 3.2.2 we saw that a presentation for a category, or database schema, consists
of a graph together with imposed equations between paths. Similarly here, sometimes
we want to construct a prop whose morphisms obey speciÔ¨Åc equations. But rather than
mere paths, the things we want to equate are prop expressions as in DeÔ¨Ånition 5.30.
Rough DeÔ¨Ånition 5.33. A presentation (G, s, t, E) for a prop is a set G, functions
s, t : G ‚ÜíN, and a set E ‚äÜExpr(G)√óExpr(G) of pairs of G-generated prop expressions,
such that e1 and e2 have the same arity for each (e1, e2) ‚ààE. We refer to G as the set of
generators and to E as the set of equations in the presentation.6
The prop G presented by the presentation (G, s, t, E) is the prop whose morphisms
are elements in Expr(G), quotiented by both the equations e1  e2 where (e1, e2) ‚ààE,
and by the axioms of symmetric strict monoidal categories.
Remark 5.34. Given a presentation (G, s, t, E), it can be shown that the prop G has
a universal property in terms of ‚Äúmaps out.‚Äù Namely prop functors from G to any
6Elements of E, which we call equations, are traditionally called ‚Äúrelations.‚Äù We think of (e1, e2) ‚ààE
as standing for the equation e1  e2, as this will be forced soon.

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
159
other prop C are in one-to-one correspondence with functions f from G to the set of
morphisms in C such that
‚Ä¢ for all 1 ‚ààG, f (1) is a morphism s(1) ‚Üít(1), and
‚Ä¢ for all (e1, e2) ‚ààE, we have that f (e1)  f (e2) in C, where f (e) denotes the
morphism in C obtained by applying f to each generators in the expression e,
and then composing the result in C.
Exercise 5.35.
Is it the case that the free prop on generators (G, s, t), deÔ¨Åned in
DeÔ¨Ånition 5.25, is the same thing as the prop presented by (G, s, t, ¬ú), having no
relations, as deÔ¨Åned in DeÔ¨Ånition 5.33? Or is there a subtle diÔ¨Äerence somehow?
‚ô¶
5.3
SimpliÔ¨Åed signal Ô¨Çow graphs
We now return to signal Ô¨Çow graphs, expressing them in terms of props. We will
discuss a simpliÔ¨Åed form without feedback (the only sort we have discussed so far),
and then extend to the usual form of signal Ô¨Çow graphs in Section 5.4.3. But before
we can do that, we must say what we mean by signals; this gets us into the algebraic
structure of ‚Äúrigs.‚Äù We will get to signal Ô¨Çow graphs in Section 5.3.2.
5.3.1
Rigs
Signals can be ampliÔ¨Åed, and they can be added. Adding and ampliÔ¨Åcation interact via
a distributive law, as follows: if we add two signals, and then amplify them by some
amount a, it should be the same as amplifying the two signals separately by a, then
adding the results.
We can think of all the possible ampliÔ¨Åcations as forming a structure called a rig,7
deÔ¨Åned as follows.
DeÔ¨Ånition 5.36. A rig is a tuple (R, 0, +, 1, ‚àó), where R is a set, 0, 1 ‚ààR are elements,
and +, ‚àó: R √ó R ‚ÜíR are functions, such that
(a) (R, +, 0) is a commutative monoid,
(b) (R, ‚àó, 1) is a monoid,8 and
(c) a ‚àó(b + c)  a ‚àób + a ‚àóc and (a + b) ‚àóc  a ‚àóc + b ‚àóc for all a, b, c ‚ààR.
(d) a ‚àó0  0  0 ‚àóa for all a ‚ààR.
We have already encountered many examples of rigs.
Example 5.37. The natural numbers form a rig (N, 0, +, 1, ‚àó).
7Rigs are also known as semi-rings.
8 Note that we did not demand that (R, ‚àó, 1) be commutative; we will see a naturally-arising example
where it is not commutative in Example 5.40.

160
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Example 5.38. The Booleans form a rig (B, false, ‚à®, true, ‚àß).
Example 5.39. Any quantale V  (V, ‚â§, I, ‚äó) determines a rig (V, 0, ‚à®, I, ‚äó), where 0 
√î ¬ú is the empty join. See DeÔ¨Ånition 2.79.
Example 5.40. If R is a rig and n ‚ààN is any natural number, then the set Matn(R) of
(n √ó n)-matrices in R forms a rig. A matrix M ‚ààMatn(R) is a function M : n √ó n ‚Üí
R.
Addition M + N of matrices is given by (M + N)(i, j) B M(i, j) + N(i, j) and
multiplication M ‚àóN is given by (M ‚àóN)(i, j) B √ç
k‚ààn M(i, k) ‚àóN(k, j). The 0-matrix is
0(i, j) B 0 for all i, j ‚ààn. Note that Matn(R) is generally not commutative.
Exercise 5.41.
1. We said in Example 5.40 that for any rig R, the set Matn(R) forms a rig. What is
its multiplicative identity 1 ‚ààMatn(R)?
2. We also said that Matn(R) is generally not commutative. Pick an n and show that
that Matn(N) is not commutative, where N is as in Example 5.37.
‚ô¶
The following is an example for readers who are familiar with the algebraic structure
known as ‚Äúrings.‚Äù
Example 5.42. Any ring forms a rig. In particular, the real numbers (R, 0, +, 1, ‚àó) are a
rig. The diÔ¨Äerence between a ring and rig is that a ring, in addition to all the properties
of a rig, must also have additive inverses, or negatives. A common mnemonic is that a
rig is a ring without negatives.
5.3.2
The iconography of signal Ô¨Çow graphs
A signal Ô¨Çow graph is supposed to keep track of the ampliÔ¨Åcation, by elements of a
rig R, to which signals are subjected. While not strictly necessary,9 we will assume the
signals themselves are elements of the same rig R. We refer to elements of R as signals
for the time being.
AmpliÔ¨Åcation of a signal by some value a ‚ààR is simply depicted like so:
a
(scalar mult.)
We interpret the above icon as a depicting a system where a signal enters on the
left-hand wire, is multiplied by a, and is output on the right-hand wire.
9The necessary requirement for the material below to make sense is that the signals take values in an
R-module M. We will not discuss this here, keeping to the simpler requirement that M  R.

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
161
What is more interesting than just a single signal ampliÔ¨Åcation, however, is the
interaction of signals. There are four other important icons in signal Ô¨Çow graphs.
Let‚Äôs go through them one by one. The Ô¨Årst two are old friends from Chapter 2: copy
and discard.
(copy)
We interpret this diagram as taking in an input signal on the left, and outputting
that same value to both wires on the right. It is basically the ‚Äúcopy‚Äù operation from
Section 2.2.3.
Next, we have the ability to discard signals.
(discard)
This takes in any signal, and outputs nothing. It is basically the ‚Äúwaste‚Äù operation from
Section 2.2.3.
Next, we have the ability to add signals.
(add, +)
This takes the two input signals and adds them, to produce a single output signal.
Finally, we have the zero signal.
(zero, 0)
This has no inputs, but always outputs the 0 element of the rig.
Using these icons, we can build more complex signal Ô¨Çow graphs. To compute the
operation performed by a signal Ô¨Çow graph we simply trace the paths with the above
interpretations, plugging outputs of one icon into the inputs of the next icon.
For example, consider the rig R  N from Example 5.37, where the scalars are the
natural numbers. Recall the signal Ô¨Çow graph from Eq. (5.1) in the introduction:
7
5
3
2
As we explained, this takes in two input signals x and y, and returns two output signals
a  15x and b  3x + 21y.
In addition to tracing the processing of the values as they move forward through
the graph, we can also calculate these values by summing over paths. More explicitly,
to get the contribution of a given input wire to a given output wire, we take the sum,
over all paths p joining the wires, of the total ampliÔ¨Åcation along that path.

162
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
So, for example, there is one path from the top input to the top output. On this
path, the signal is Ô¨Årst copied, which does not aÔ¨Äect its value, then ampliÔ¨Åed by 5, and
Ô¨Ånally ampliÔ¨Åed by 3. Thus, if x is the Ô¨Årst input signal, then this contributes 15x to the
Ô¨Årst output. Since there is no path from the bottom input to the top output (one is not
allowed to traverse paths backwards), the signal at the Ô¨Årst output is exactly 15x. Both
inputs contribute to the bottom output. In fact, each input contributes in two ways, as
there are two paths to it from each input. The top input thus contributes 3x  x + 2x,
whereas the bottom input, passing through an additional ‚àó7 ampliÔ¨Åcation, contributes
21y.
Exercise 5.43.
The following Ô¨Çow graph takes in two natural numbers x and y
3
5
3
and produces two output signals. What are they?
‚ô¶
Example 5.44. This example is for those who have some familiarity with diÔ¨Äerential
equations. A linear system of diÔ¨Äerential equations provides a simple way to specify
the movement of a particle. For example, consider a particle whose position (x, y, z) in
3-dimensional space is determined by the following equations:
√õx + 3 √úy ‚àí2z  0
√úy + 5√õz  0
Using what is known as the Laplace transform, one can convert this into a linear
system involving a formal variable D, which stands for ‚ÄúdiÔ¨Äerentiate.‚Äù
Then the
system becomes
Dx + 3D2y ‚àí2z  0
D2y + 5Dz  0
which can be represented by the signal Ô¨Çow graph
D
‚àí2
D2
5D
3D2
Signal Ô¨Çow graphs as morphisms in a free prop.
We can formally deÔ¨Åne simpliÔ¨Åed
signal Ô¨Çow graphs using props.

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
163
DeÔ¨Ånition 5.45. Let R be a rig (see DeÔ¨Ånition 5.36). Consider the set
GR :
n
,
,
,
o
‚à™
n
a
| a ‚ààR
o
,
and let s, t : GR ‚ÜíN be given by the number of dangling wires on the left and right of
the generator icon respectively. A simpliÔ¨Åed signal Ô¨Çow graph is a morphism in the free
prop Free(GR) on this set GR of generators. We deÔ¨Åne SFGR B Free(GR).
For now we‚Äôll drop the term ‚ÄòsimpliÔ¨Åed‚Äô, since these are the only sort of signal Ô¨Çow
graph we know. We‚Äôll return to signal Ô¨Çow graphs in their full glory‚Äîi.e. including
feedback‚Äîin Section 5.4.3.
Example 5.46. To be more in line with our representations of both wiring diagrams and
port graphs, morphisms in Free(GR) should be drawn slightly diÔ¨Äerently. For example,
technically the signal Ô¨Çow graph from Exercise 5.43 should be drawn as follows:
3
5
3
because we said we would label boxes with the elements of G. But it is easier on the
eye to draw remove the boxes and just look at the icons inside as in Exercise 5.43, and
so we‚Äôll draw our diagrams in that fashion.
More importantly, props provide language to understand the semantics of sig-
nal Ô¨Çow graphs. Although the signal Ô¨Çow graphs themselves are free props, their
semantics‚Äîtheir meaning in our model of signals Ô¨Çowing‚Äîwill arise when we add
equations to our props, as in DeÔ¨Ånition 5.33. These equations will tell us when two
signal Ô¨Çow graphs act the same way on signals. For example,
and
(5.47)
both express the same behavior: a single input signal is copied twice so that three
identical copies of the input signal are output.
If two signal Ô¨Çow graphs S, T are almost the same, with the one exception being that
somewhere we replace the left-hand side of Eq. (5.47) with the right-hand side, then S
and T have the same behavior. But there are other replacements we could make to a
signal Ô¨Çow graph that do not change its behavior. Our next goal is to Ô¨Ånd a complete
description of these replacements.

164
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
5.3.3
The prop of matrices over a rig
Signal Ô¨Çow graphs are closely related to matrices. In previous chapters we showed
how a matrix with values in a quantale V‚Äîa closed monoidal preorder with all joins‚Äî
represents a system of interrelated points and connections between them, such as
a profunctor. The quantale gave us the structure and axioms we needed in order for
matrix multiplication to work properly. But we know from Example 5.39 that quantales
are examples of rigs, and in fact matrix multiplication makes sense in any rig R. In
Example 5.40, we explained that the set Matn(R) of (n √ó n)-matrices in R can naturally
be assembled into a rig, for any Ô¨Åxed choice of n ‚ààN. But what if we want to do better,
and assemble all matrices into a single algebraic structure? The result is a prop!
An (m √ó n)-matrix M with values in R is a function M : (m √ó n) ‚ÜíR. Given an
(m √ó n)-matrix M and an (n √ó p)-matrix N, their composite is the (m √ó p)-matrix M # N
deÔ¨Åned as follows for any a ‚ààm and c ‚ààp:
M # N(a, c) B
√ï
b‚ààn
M(a, b) √ó N(b, c),
(5.48)
Here the √ç
b‚ààn just means repeated addition (using the rig R‚Äôs + operation), as usual.
Remark 5.49. Conventionally, one generally considers a matrix A acting on a vector v
by multiplication in the order Av, where v is a column vector. In keeping with our
composition convention, we use the opposite order, v # A, where v is a row vector. See
for example Eq. (5.52) for when this is implicitly used.
DeÔ¨Ånition 5.50. Let R be a rig. We deÔ¨Åne the prop of R-matrices, denoted Mat(R),
to be the prop whose morphisms m ‚Üín are the (m √ó n)-matrices with values in R.
Composition of morphisms is given by matrix multiplication as in Eq. (5.48).
The
monoidal product is given by the direct sum of matrices: given matrices A: m ‚Üín
and b : p ‚Üíq, we deÔ¨Åne A + B : m + p ‚Üín + q to be the block matrix
 
A
0
0
B
!
where each 0 represents a matrix of zeros of the appropriate dimension (m √ó q and
n√óp). We refer to any combination of multiplication and direct sum as a interconnection
of matrices.
Exercise 5.51.
Let A and B be the following matrices with values in N:
A 
 
3
3
1
2
0
4
!
B 

2
5
6
1

.
What is the direct sum matrix A + B?
‚ô¶

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
165
5.3.4
Turning signal Ô¨Çow graphs into matrices
Let‚Äôs now consider more carefully what we mean when we talk about the meaning, or
semantics, of each signal Ô¨Çow graph. We‚Äôll use matrices.
7
5
3
2
In the examples like the above (copied from Eq. (5.1)), the signals emanating from
output wires, say a and b, are given by certain sums of ampliÔ¨Åed input values, say x
and y. If we can only measure the input and output signals, and care nothing for what
happens in between, then each signal Ô¨Çow graph may as well be reduced to a matrix of
ampliÔ¨Åcations. We can represent the signal Ô¨Çow graph of Eq. (5.1) by either the matrix
on the left (for more detail) or the matrix on the right if the labels are clear from context:
a
b
x
15
3
y
0
21
 
15
3
0
21
!
Every signal Ô¨Çow graph can be interpreted as a matrix.
The generators GR from
DeÔ¨Ånition 5.45 are shown again in the table below, where each is interpreted as a
matrix. For example, we interpret ampliÔ¨Åcation by a ‚ààR as the 1√ó1 matrix (a): 1 ‚Üí1:
it is an operation that takes an input x ‚ààR and returns a ‚àóx. Similarly, we can interpret
as the 2 √ó 1 matrix   1
1

: it is an operation that takes a row vector consisting of two
inputs, x and y, and returns x + y. Here is a table showing the interpretation of each
generator.
generator
icon
matrix
arity
amplify by a ‚ààR
a
 a
1 ‚Üí1
add

1
1

2 ‚Üí1
zero
()
0 ‚Üí1
copy
 1
1
1 ‚Üí2
discard
()
1 ‚Üí0
(5.52)
Note that both zero and discard are represented by empty matrices, but of diÔ¨Äering
dimensions. In linear algebra it is unusual to consider matrices of the form 0√ón or n√ó0
for various n to be diÔ¨Äerent, but they can be kept distinct for bookkeeping purposes:
you can multiply a 0 √ó 3 matrix by a 3 √ó n matrix for any n, but you can not multiply it
by a 2 √ó n matrix.
Since signal Ô¨Çow graphs are morphisms in a free prop, the table in (5.52) is enough
to show that we can interpret any signal Ô¨Çow diagram as a matrix.

166
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Theorem 5.53. There is a prop functor S: SFGR ‚ÜíMat(R) that sends the generators
1 ‚ààG icons to the matrices as described in Table 5.52.
Proof. This follows immediately from the universal property of free props, Remark 5.34.
‚ñ°
We have now constructed a matrix S(1) from any signal Ô¨Çow graph 1. But how can
we produce this matrix explicitly? Both for the example signal Ô¨Çow graph in Eq. (5.1)
and for the generators in DeÔ¨Ånition 5.45, the associated matrix has dimension m √ó n,
where m is the number of inputs and n the number of outputs, with (i, j)th entry
describing the ampliÔ¨Åcation of the ith input that contributes to the jth output. This
is how one would hope or expect the functor S to work in general; but does it? We
have used a big hammer‚Äîthe universal property of free constructions‚Äîto obtain our
functor S. Our next goal is to check that it works in the expected way. Doing so is a
matter of using induction over the set of prop expressions, as we now see.10
Proposition 5.54. Let 1 be a signal Ô¨Çow graph with m inputs and n outputs. The matrix
S(1) is the (m √ó n)-matrix whose (i, j)-entry describes the ampliÔ¨Åcation of the ith input
that contributes to the jth output.
Proof. Recall from DeÔ¨Ånition 5.30 that an arbitrary GR-generated prop expression is
built from the morphisms id0 : 0 ‚Üí0, id1 : 1 ‚Üí1, œÉ: 2 ‚Üí2, and the generators in GR,
using the following two rules:
‚Ä¢ if Œ±: m ‚Üín and Œ≤: p ‚Üíq are expressions, then (Œ± + Œ≤): (m + p) ‚Üí(n + q) is an
expression.
‚Ä¢ if Œ±: m ‚Üín and Œ≤: n ‚Üíp are expressions, then Œ± # Œ≤: m ‚Üíp is an expression.
S is a prop functor by Theorem 5.53, which by DeÔ¨Ånition 5.11 must preserve identities,
compositions, monoidal products, and symmetries. We Ô¨Årst show that the proposition
is true when 1 is equal to id0, id1, and œÉ.
The empty signal Ô¨Çow graph id0 : 0 ‚Üí0 must be sent to the unique (empty) matrix
(): 0 ‚Üí0. The morphisms id1, œÉ, and a ‚ààR map to the identity matrix, the swap
matrix, and the scalar matrix (a) respectively:
7‚Üí

1

and
7‚Üí
 
0
1
1
0
!
and
a
7‚Üí

a

In each case, the (i, j)-entry gives the ampliÔ¨Åcation of the ith input to the jth output.
It remains to show that if the proposition holds for Œ±: m ‚Üín and Œ≤: p ‚Üíq, then it
holds for (i) Œ± # Œ≤ (when n  p) and for (ii) Œ± + Œ≤ (in general).
10Mathematical induction is a formal proof technique that can be thought of like a domino rally: if
you knock over all the starting dominoes, and you‚Äôre sure that each domino will be knocked down if its
predecessors are, then you‚Äôre sure every domino will eventually fall. If you want more rigor, or you want
to understand the proof of Proposition 5.54 as a genuine case of induction, ask a friendly neighborhood
mathematician!

5.3. SIMPLIFIED SIGNAL FLOW GRAPHS
167
To prove (i), consider the following picture of Œ± # Œ≤:
Œ±
Œ≤
...
...
m inputs
...
q outputs
Here Œ±: m ‚Üín and Œ≤: n ‚Üíq are signal Ô¨Çow graphs, assumed to obey the proposition.
Consider the ith input and kth output of Œ± # Œ≤; we‚Äôll just call these i and k. We want to
show that the ampliÔ¨Åcation that i contributes to k is the sum‚Äîover all paths from i to
k‚Äîof the ampliÔ¨Åcation along that path. So let‚Äôs also Ô¨Åx some j ‚ààn, and consider paths
from i to k that run through j. By distributivity of the rig R, the total ampliÔ¨Åcation
from i to k through j is the total ampliÔ¨Åcation over all paths from i to j times the total
amplication over all paths from j to k. Since all paths from i to k must run through
some jth output of Œ±/input of Œ≤, the ampliÔ¨Åcation that i contributes to k is
√ï
j‚ààn
Œ±(i, j) ‚àóŒ≤(j, k).
This is exactly the formula for matrix multiplication, which is composition S(Œ±) # S(Œ≤)
in the prop Mat(R); see DeÔ¨Ånition 5.50. So Œ± # Œ≤ obeys the proposition when Œ± and Œ≤
do.
Proving (ii) is more straightforward. The monoidal product Œ± + Œ≤ of signal Ô¨Çow
graphs looks like this:
Œ±
Œ≤
...
m inputs
...
n outputs
...
p inputs
...
q outputs
No new paths are created; the only change is to reindex the inputs and outputs. In
particular, the ith input of Œ± is the ith input of Œ±+Œ≤, the jth output of Œ± is the jth output
of Œ± + Œ≤, the ith input of Œ≤ is the (m + i)th output of Œ± + Œ≤, and the jth output of Œ≤ is the
(n + j)th output of Œ± + Œ≤. This means that the matrix with (i, j)th entry describing the
ampliÔ¨Åcation of the ith input that contributes to the jth output is S(Œ±)+S(Œ≤)  S(Œ±+Œ≤),
as in DeÔ¨Ånition 5.50. This proves the proposition.
‚ñ°
Exercise 5.55.
1. What matrix does the signal Ô¨Çow graph
represent?

168
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
2. What about the signal Ô¨Çow graph
3. Are they equal?
‚ô¶
5.3.5
The idea of functorial semantics
Let‚Äôs pause for a moment to reÔ¨Çect on what we have just learned. First, signal Ô¨Çow
diagrams are the morphisms in a prop. This means we have two special operations we
can do to form new signal Ô¨Çow diagrams from old, namely composition (combining
in series) and monoidal product (combining in parallel). We might think of this as
specifying a ‚Äògrammar‚Äô or ‚Äòsyntax‚Äô for signal Ô¨Çow diagrams.
As a language, signal Ô¨Çow graphs have not only syntax but also semantics: each
signal Ô¨Çow diagram can be interpreted as a matrix. Moreover, matrices have the same
grammatical structure: they form a prop, and we can construct new matrices from
old using composition and monoidal product. In Theorem 5.53 we completed this
picture by showing that semantic interpretation is a prop functor between the prop of
signal Ô¨Çow graphs and the prop of matrices. Thus we say that matrices give functorial
semantics for signal Ô¨Çow diagrams.
Functorial semantics is a key manifestation of compositionality. It says that the
matrix meaning S(1) for a big signal Ô¨Çow graph 1 can be computed by:
1. splitting 1 up into little pieces,
2. computing the very simple matrices for each piece, and
3. using matrix multiplication and direct sum to put the pieces back together to
obtain the desired meaning, S(1).
This functoriality is useful in practice, for example in speeding up computation of the
semantics of signal Ô¨Çow graphs: for large signal Ô¨Çow graphs, composing matrices is
much faster than tracing paths.
5.4
Graphical linear algebra
In this section we will begin to develop something called graphical linear algebra, which
extends the ideas above.
This formalism is actually quite powerful.
For example,
with it we can easily and graphically prove certain conjectures from control theory
that, although they were eventually solved, required fairly elaborate matrix algebra
arguments [FSR16].
5.4.1
A presentation of Mat(R)
Let R be a rig, as deÔ¨Åned in DeÔ¨Ånition 5.36. The main theorem of the previous section,
Theorem 5.53, provided a functor S: SFGR ‚ÜíMat(R) that converts any signal Ô¨Çow

5.4. GRAPHICAL LINEAR ALGEBRA
169
graph into a matrix. Next we show that S is ‚Äúfull‚Äù: that any matrix can be represented
by a signal Ô¨Çow graph.
Proposition 5.56. Given any matrix M ‚ààMat(R), there exists a signal Ô¨Çow graph
1 ‚ààSFGR such that such that S(1)  M.
Proof sketch. Let M ‚ààMat(R) be an (m √ó n)-matrix. We want a signal Ô¨Çow graph 1
such that S(1)  M. In particular, to compute S(1)(i, j), we know that we can simply
compute the ampliÔ¨Åcation that the ith input contributes to the jth output. The key idea
then is to construct 1 so that there is exactly one path from ith input to the jth output,
and that this path has exactly one scalar multiplication icon, namely M(i, j).
The general construction is a little technical (see Exercise 5.59), but the idea is clear
from just considering the case of 2 √ó 2-matrices. Suppose M is the 2 √ó 2-matrix ( a b
c d ).
Then we deÔ¨Åne 1 to be the signal Ô¨Çow graph
a
b
c
d
(5.57)
Tracing paths, it is easy to see that S(1)  M. Note that 1 is the composite of four
layers, each layer respectively a monoidal product of (i) copy and discard maps, (ii)
scalar multiplications, (iii) swaps and identities, (iv) addition and zero maps.
For the general case, see Exercise 5.59.
‚ñ°
Exercise 5.58.
Draw signal Ô¨Çow graphs that represent the following matrices:
1.
¬©¬≠¬≠
¬´
0
1
2
¬™¬Æ¬Æ
¬¨
2.
 
0
0
0
0
!
3.
 
1
2
3
4
5
6
!
‚ô¶
Exercise 5.59.
Write down a detailed proof of Proposition 5.56. Suppose M is an
m √ó n-matrix.
Follow the idea of the (2 √ó 2)-case in Eq. (5.57), and construct the
signal Ô¨Çow graph 1‚Äîhaving m inputs and n outputs‚Äîas the composite of four layers,
respectively comprising (i) copy and discard maps, (ii) scalars, (iii) swaps and identities,
(iv) addition and zero maps.
‚ô¶
We can also use Proposition 5.56 and its proof to give a presentation of Mat(R),
which was deÔ¨Åned in DeÔ¨Ånition 5.50.

170
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Theorem 5.60. The prop Mat(R) is isomorphic to the prop with the following presen-
tation. The set of generators is the set
GR :
n
,
,
,
o
‚à™
n
a
| a ‚ààR
o
,
the same as the set of generators for SFGR; see DeÔ¨Ånition 5.45.
We have the following equations for any a, b ‚ààR:










a
b

ab
a
b

a+b
1

0

a

a
a
a

a
a
a

a

Proof. The key idea is that these equations are suÔ¨Écient to rewrite any GR-generated
prop expression into a normal form‚Äîthe one used in the proof of Proposition 5.56‚Äî
with all the black nodes to the left, all the white nodes to the right, and all the scalars in
the middle. This is enough to show the equality of any two expressions that represent
the same matrix. Details can be found in [BE15] or [BS17].
‚ñ°
Sound and complete presentation of matrices.
Once you get used to it, Theorem 5.60
provides an intuitive, visual way to reason about matrices. Indeed, the theorem implies
two signal Ô¨Çow graphs represent the same matrix if and only if one can be turned into
the other by local application of the above equations and the prop axioms.
The fact that you can prove two SFGs to be the same by using only graphical rules
can be stated in the jargon of logic: we say that the graphical rules provide a sound and
complete reasoning system. To be more speciÔ¨Åc, sound refers to the forward direction of
the above statement: two signal Ô¨Çow graphs represent the same matrix if one can be
turned into the other using the given rules. Complete refers to the reverse direction: if

5.4. GRAPHICAL LINEAR ALGEBRA
171
two signal Ô¨Çow graphs represent the same matrix, then we can convert one into the
other using the equations of Theorem 5.60.
Example 5.61. Both of the signal Ô¨Çow graphs below represent the same matrix,  0
6

:
3
2
and
6
This means that one can be transformed into the other by using only the equations
from Theorem 5.60. Indeed, here
3
2

3
2

3
2

6
Exercise 5.62.
1. For each matrix in Exercise 5.58, draw another signal Ô¨Çow graph that represents
that matrix.
2. Using the above equations and the prop axioms, prove that the two signal Ô¨Çow
graphs represent the same matrix.
‚ô¶
Exercise 5.63.
Consider the signal Ô¨Çow graphs
and
3
5
3
3
3
5
3
(5.64)
1. Let R  (N, 0, +, 1, ‚àó). By examining the presentation of Mat(R) in Theorem 5.60,
and without computing the matrices that the two signal Ô¨Çow graphs in Eq. (5.64)
represent, prove that they do not represent the same matrix.
2. Now suppose the rig is R  N/3N; if you do not know what this means, just
replace all 3‚Äôs with 0‚Äôs in the right-hand diagram of Eq. (5.64). Find what you
would call a minimal representation of this diagram, using the presentation in
Theorem 5.60.
‚ô¶

172
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
5.4.2
Aside: monoid objects in a monoidal category
Various subsets of the equations in Theorem 5.60 encode structures that are familiar
from many other parts of mathematics, e.g. representation theory. For example one
can Ô¨Ånd the axioms for (co)monoids, (co)monoid homomorphisms, Frobenius algebras,
and (with a little rearranging) Hopf algebras, sitting inside this collection. The Ô¨Årst
example, the notion of monoids, is particularly familiar to us by now, so we brieÔ¨Çy
discuss it below, both in algebraic terms (DeÔ¨Ånition 5.65) and in diagrammatic terms
(Example 5.68).
DeÔ¨Ånition 5.65. A monoid object (M, ¬µ, Œ∑) in a symmetric monoidal category (C, I, ‚äó) is
an object M of C together with morphisms ¬µ: M ‚äóM ‚ÜíM and Œ∑: I ‚ÜíM such that
(a) (¬µ ‚äóid) # ¬µ  (id ‚äó¬µ) # ¬µ and
(b) (Œ∑ ‚äóid) # ¬µ  id  (id ‚äóŒ∑) # ¬µ.
A commutative monoid object is a monoid object that further obeys
(c) œÉM,M # ¬µ  ¬µ.
where œÉM,M is the swap map on M in C. We often denote it simply by œÉ.
Monoid objects are so-named because they are an abstraction of the usual concept
of monoid.
Example 5.66. A monoid object in (Set, 1, √ó) is just a regular old monoid, as deÔ¨Åned in
Example 2.6; see also Example 3.13. That is, it is a set M, a function ¬µ: M √ó M ‚ÜíM,
which we denote by inÔ¨Åx notation ‚àó, and an element Œ∑(1) ‚ààM, which we denote by e,
satisfying (a ‚àób) ‚àóc  a ‚àó(b ‚àóc) and a ‚àóe  a  e ‚àóa.
Exercise 5.67.
Consider the set R of real numbers.
1. Show that if ¬µ: R √ó R ‚ÜíR is deÔ¨Åned by ¬µ(a, b)  a ‚àób and if Œ∑ ‚ààR is deÔ¨Åned to
be Œ∑  1, then (R, ‚àó, 1) satisÔ¨Åes all three conditions of DeÔ¨Ånition 5.65.
2. Show that if ¬µ: R √ó R ‚ÜíR is deÔ¨Åned by ¬µ(a, b)  a + b and if Œ∑ ‚ààR is deÔ¨Åned to
be Œ∑  0, then (R, +, 0) satisÔ¨Åes all three conditions of DeÔ¨Ånition 5.65.
‚ô¶
Example 5.68. Graphically, we can depict ¬µ 
and Œ∑ 
. Then axioms (a), (b), and
(c) from DeÔ¨Ånition 5.65 become:
(a)

(b)

(c)

All three of these are found in Theorem 5.60. Thus we can immediately conclude the
following: the triple (1,
,
) is a commutative monoid object in the prop Mat(R).

5.4. GRAPHICAL LINEAR ALGEBRA
173
Exercise 5.69.
For any rig R, there is a functor U : Mat(R) ‚ÜíSet, sending the object
n ‚ààN to the set Rn, and sending a morphism (matrix) M : m ‚Üín to the function
Rm ‚ÜíRn given by vector-matrix multiplication.
Recall that in Mat(R), the monoidal unit is 0 and the monoidal product is +, because
it is a prop. Recall also that in (the usual monoidal structure on) Set, the monoidal unit
is {1}, a set with one element, and the monoidal product is √ó (see Example 4.49).
1. Check that the functor U : Mat(R) ‚ÜíSet, deÔ¨Åned above, preserves the monoidal
unit and the monoidal product.
2. Show that if (M, ¬µ, Œ∑) is a monoid object in Mat(R) then (U(M), U(¬µ), U(Œ∑)) is
a monoid object in Set. (This works for any monoidal functor‚Äîwhich we will
deÔ¨Åne in DeÔ¨Ånition 6.68‚Äînot just for U in particular.)
3. In Example 5.68, we said that the triple (1,
,
) is a commutative monoid object
in the prop Mat(R). If R  R is the rig of real numbers, this means that we have
a monoid structure on the set R. But in Exercise 5.67 we gave two such monoid
structures. Which one is it?
‚ô¶
Example 5.70. The triple (1,
,
) in Mat(R) forms a commutative monoid object in
Mat(R)op. We hence also say that (1,
,
) forms a co-commutative comonoid object in
Mat(R).
Example 5.71. A symmetric strict monoidal category, is just a commutative monoid object
in (Cat, √ó, 1). We will unpack this in Section 6.4.1.
Example 5.72. A symmetric monoidal preorder, which we deÔ¨Åned in DeÔ¨Ånition 2.2, is
just a commutative monoid object in the symmetric monoidal category (Preord, √ó, 1)
of preorders and monotone maps.
Example 5.73. For those who know what tensor products of commutative monoids
are (or can guess): A rig is a monoid object in the symmetric monoidal category
(CMon, ‚äó, N) of commutative monoids with tensor product.
Remark 5.74. If we present a prop M using two generators ¬µ: 2 ‚Üí1 and Œ∑: 0 ‚Üí1,
and the three equations from DeÔ¨Ånition 5.65, we could call it ‚Äòthe theory of monoids in
monoidal categories.‚Äô This means that in any monoidal category C, the monoid objects
in C correspond to strict monoidal functors M ‚ÜíC. This sort of idea leads to the study
of algebraic theories, due to Bill Lawvere and extended by many others; see Section 5.5.

174
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
5.4.3
Signal Ô¨Çow graphs: feedback and more
At this point in the story, we have seen that every signal Ô¨Çow graph represents a matrix,
and this gives us a new way of reasoning about matrices. This is just the beginning of
a beautiful tale, one not only of graphical matrices, but of graphical linear algebra. We
close this chapter with some brief hints at how the story continues.
The pictoral nature of signal Ô¨Çow graphs invites us to play with them. While we
normally draw the copy icon like so,
, we could just as easily reverse it and draw an
icon
. What might it mean? Let‚Äôs think again about the semantics of Ô¨Çow graphs.
The behavioral approach.
A signal Ô¨Çow graph 1 : m ‚Üín takes an input x ‚ààRm and
gives an output y ‚ààRn. In fact, since this is all we care about, we might just think
about representing a signal Ô¨Çow graph 1 as describing a set of input and output pairs
(x, y). We‚Äôll call this set the behavior of 1 and denote it B(1) ‚äÜRm √ó Rn. For example,
the ‚Äòcopy‚Äô Ô¨Çow graph
sends the input 1 to the output (1, 1), so we consider (1, (1, 1)) to be an element of
copy-behavior. Similarly, (x, (x, x)) is copy behavior for every x ‚ààR, thus we have
B(
)  {(x, (x, x)) | x ‚ààR}.
In the abstract, the signal Ô¨Çow graph 1 : m ‚Üín has the behavior
B(1) 
 x, S(1)(x)
| x ‚ààRm	
‚äÜRm √ó Rn.
(5.75)
Mirror image of an icon.
The above behavioral perspective provides a clue about
how to interpret the mirror images of the diagrams discussed above. Reversing an icon
1 : m ‚Üín exchanges the inputs with the outputs, so if we denote this reversed icon by
1op, we must have 1op : n ‚Üím. Thus if B(1) ‚äÜRm √óRn then we need B(1op) ‚äÜRn √óRm.
One simple way to do this is to replace each (a, b) with (b, a), so we would have
B(1op) B
 S(1)(x), x
| x ‚ààRm	
‚äÜRn √ó Rm.
(5.76)
This is called the transposed relation.
Exercise 5.77.
1. What is the behavior B(
) of the reversed addition icon
: 1 ‚Üí2?
2. What is the behavior B(
) of the reversed copy icon,
: 2 ‚Üí1?
‚ô¶
Eqs. (5.75) and (5.76) give us formulas for interpreting signal Ô¨Çow graphs and their
mirror images. But this would easily lead to disappointment, if we couldn‚Äôt combine
the two directions behaviorally; luckily we can.

5.4. GRAPHICAL LINEAR ALGEBRA
175
Combining directions.
What should the behavior be for a diagram such as the fol-
lowing:
3
‚àí1
3
Let‚Äôs formalize our thoughts a bit and begin by thinking about behaviors. The behavior
of a signal Ô¨Çow graph m ‚Üín is a subset B ‚äÜRm √ó Rn, i.e. a relation. Why not try to
construct a prop where the morphisms m ‚Üín are relations?
We‚Äôll need to know how to compose and take monoidal products of relations.
And if we want this prop of relations to contain the old prop Mat(R), we need the new
compositions and monoidal products to generalize the old ones in Mat(R). Given signal
Ô¨Çow graphs with matrices M : m ‚Üín and N : n ‚Üíp, we see that their behaviors are
the relations B1 B {(x, Mx) | x ‚ààRm} and B2 B {(y, N y) | y ‚ààRn}, while the behavior
of M # N is the relation {(x, x # M # N) | x ‚ààRm}. This is a case of relation composition.
Given relations B1 ‚äÜRm √ó Rn and B2 ‚äÜRn √ó Rp, their composite B1 # B2 ‚äÜRm √ó Rp is
given by
B1 # B2 B {(x, z) | there exists y ‚ààRn such that (x, y) ‚ààB1 and (y, z) ‚ààB2}.
(5.78)
We shall use this as the general deÔ¨Ånition for composing two behaviors.
DeÔ¨Ånition 5.79. Let R be a rig. We deÔ¨Åne the prop RelR of R-relations to have subsets
B ‚äÜRm √ó Rn as morphisms.
These are composed by the composition rule from
Eq. (5.78), and we take the product of two sets to form their monoidal product.
Exercise 5.80.
In DeÔ¨Ånition 5.79 we went quickly through monoidal products + in the
prop RelR. If B ‚äÜRm √ó Rn and C ‚äÜRp √ó Rq are morphisms in RelR, write down B + C
in set-notation.
‚ô¶
(No-longer simpliÔ¨Åed) signal Ô¨Çow graphs.
Recall that above, e.g. in DeÔ¨Ånition 5.45,
we wrote GR for the set of generators of signal Ô¨Çow graphs. In Section 5.4.3, we wrote
1op for the mirror image of 1, for each 1 ‚ààGR. So let‚Äôs write Gop
R B {1op | 1 ‚ààGR} for
the set of all the mirror images of generators. We deÔ¨Åne a prop
SFG+
R B Free  GR ‚äîGop
R

.
(5.81)
We call a morphism in the prop SFG+
R a (non-simpliÔ¨Åed) signal Ô¨Çow graph: these extend
our simpliÔ¨Åed signal Ô¨Çow graphs from DeÔ¨Ånition 5.45 because now we can also use the
mirrored icons. By the universal property of free props, since we have said what the
behavior of the generators is (the behavior of a reversed icon is the transposed relation;
see Eq. (5.76)), we have speciÔ¨Åed the behavior of any signal Ô¨Çow graph.
The following two exercises help us understand what this behavior is.

176
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Exercise 5.82.
Let 1 : m ‚Üín, h : ‚Ñì‚Üín be signal Ô¨Çow graphs. Note that hop : n ‚Üí‚Ñìis
a signal Ô¨Çow graph, and we can form the composite 1 # (hop):
‚àí‚Üí
1
‚Üê‚àí
hop
...
...
...
Show that the behavior of 1 # (hop) ‚äÜRm √ó R‚Ñìis equal to
B(1 # (hop))  {(x, y) | S(1)(x)  S(h)(y)}.
‚ô¶
Exercise 5.83.
Let 1 : m ‚Üín, h : m ‚Üíp be signal Ô¨Çow graphs. Note that (1op): n ‚Üím
is a signal Ô¨Çow graph, and we can form the composite 1op # h
‚Üê‚àí
1op
‚àí‚Üí
h
...
...
...
Show that the behavior of 1op # h is equal to
B((1op) # h)  {(S(1)(x), S(h)(x)) | x ‚ààRm}.
‚ô¶
Linear algebra via signal Ô¨Çow graphs.
In Eq. (5.75) we see that every matrix, or linear
map, can be represented as the behavior of a signal Ô¨Çow graph, and in Exercise 5.82 we
see that solution sets of linear equations can also be represented. This includes central
concepts in linear algebra, like kernels and images.
Exercise 5.84.
Here is an exercise for those that know linear algebra, in particular
kernels and cokernels. Let R be a Ô¨Åeld, let 1 : m ‚Üín be a signal Ô¨Çow graph, and let
S(1) ‚ààMat(R) be the associated (m √ó n)-matrix (see Theorem 5.53).
1. Show that the composite of 1 with 0-reverses, shown here
‚àí‚Üí
1
...
...
is equal to the kernel of the matrix S(1).
2. Show that the composite of discard-reverses with 1, shown here
‚àí‚Üí
1
...
...
is equal to the image of the matrix S(1).
3. Show that for any signal Ô¨Çow graph 1, the subset B(1) ‚äÜRm √ó Rn is a linear
subspace. That is, if b1, b2 ‚ààB(1) then so are b1 + b2 and r ‚àób1, for any r ‚ààR.
‚ô¶

5.4. GRAPHICAL LINEAR ALGEBRA
177
We have thus seen that signal Ô¨Çow graphs provide a uniform, compositional lan-
guage to talk about many concepts in linear algebra. Moreover, in Exercise 5.84 we
showed that the behavior of a signal Ô¨Çow graph is a linear relation, i.e. a relation whose
elements can be added and multiplied by scalars r ‚ààR. In fact the converse is true too:
any linear relation B ‚äÜRm √ó Rn can be represented by a signal Ô¨Çow graph.
Exercise 5.85.
One might want to show that linear relations on R form a prop, LinRelR.
That is, one might want to show that there is a sub-prop of the prop RelR from
DeÔ¨Ånition 5.79, where the morphisms m ‚Üín are the subsets B ‚äÜRm √ó Rn such
that B is linear. In other words, where for any (x, y) ‚ààB and r ‚ààR, the element
(r ‚àóx, r ‚àóy) ‚ààRm √ó Rn is in B, and for any (x‚Ä≤, y‚Ä≤) ‚ààB, the element (x + x‚Ä≤, y + y‚Ä≤) is in B.
This is certainly doable, but for this exercise, we only ask that you prove that the
composite of two linear relations is linear.
‚ô¶
Just like we gave a sound and complete presentation for the prop of matrices in
Theorem 5.60, it is possible to give a sound and complete presentation for linear
relations on R. Moreover, it is possible to give such a presentation whose generating
set is GR ‚äîGop
R as in Eq. (5.81) and whose equations include those from Theorem 5.60,
plus a few more. This presentation gives a graphical method for doing linear algebra:
an equation between linear subspaces is true if and only if it can be proved using the
equations from the presentation.
Although not diÔ¨Écult, we leave the full presentation to further reading (Section 5.5).
Instead, we‚Äôll conclude our exploration of the prop of linear relations by noting that
some of these ‚Äòfew more‚Äô equations state that relations‚Äîjust like co-design problems
in Chapter 4‚Äîform a compact closed category.
Compact closed structure.
Using the icons available to us for signal Ô¨Çow graphs, we
can build morphisms that look like the ‚Äòcup‚Äô and ‚Äòcap‚Äô from DeÔ¨Ånition 4.58:
and
(5.86)
The behaviors of these graphs are respectively
{(0, (x, x)) | x ‚ààR} ‚äÜR0 √ó R2
and
{((x, x), 0) | x ‚ààR} ‚äÜR2 √ó R0.
In fact, these show the object 1 in the prop RelR is dual to itself: the morphisms from
Eq. (5.86) serve as the Œ∑1 and œµ1 from DeÔ¨Ånition 4.58. Using monoidal products of these
morphisms, one can show that any object in RelR is dual to itself.
Graphically, this means that the three signal Ô¨Çow graphs
all represent the same relation.
Using these relations, it is straightforward to check the following result.

178
CHAPTER 5. SIGNAL FLOW GRAPHS: PROPS, PRESENTATIONS, & PROOFS
Theorem 5.87. The prop RelR is a compact closed category in which every object n ‚ààN
is dual to itself, n  n‚àó.
To make our signal Ô¨Çow graphs simpler, we deÔ¨Åne new icons cup and cap by the
equations
B
and
B
Back to control theory.
Let‚Äôs close by thinking about how to represent a simple control
theory problem in this setting. Suppose we want to design a system to maintain the
speed of a car at a desired speed u. We‚Äôll work in signal Ô¨Çow diagrams over the rig
R[s, s‚àí1] of polynomials in s and s‚àí1 with coeÔ¨Écients in R and where ss‚àí1  s‚àí1s  1.
This is standard in control theory: we think of s as integration, and s‚àí1 as diÔ¨Äerentiation.
There are three factors that contribute to the actual speed v. First, there is the actual
speed v. Second, there are external forces F. Third, we have our control system: this
will take some linear combination a ‚àóu + b ‚àóv of the desired speed and actual speed,
amplify it by some factor p to give a (possibly negative) acceleration. We can represent
this system as follows, where m is the mass of the car.
1
m
s
p
s
a
b
F
u
v
This can be read as the following equation, where one notes that v occurs twice:
v 
‚à´
1
m F(t)dt + u(t) + p
‚à´
au(t) + bv(t)dt.
Our control problem then asks: how do we choose a and b to make the behavior of
this signal Ô¨Çow graph close to the relation {(F, u, v) | u  v}? By phrasing problems in
this way, we can use extensions of the logic we have discussed above to reason about
such complex, real-world problems.
5.5
Summary and further reading
The goal of this chapter was to explain how props formalize signal Ô¨Çow graphs, and
provide a new perspective on linear algebra. To do this, we examined the idea of free
and presented structures in terms of universal properties. This allowed us to build
props that exactly suited our needs.
Pawe≈Ç Soboci≈Ñski‚Äôs Graphical Linear Algebra blog is an accessible and fun exploration
of the key themes of this chapter, which goes on to describe how concepts such as
determinants, eigenvectors, and division by zero can be expressed using signal Ô¨Çow

5.5. SUMMARY AND FURTHER READING
179
graphs [Sob]. For the technical details, one could start with Baez and Erbele [BE15],
or Zanasi‚Äôs thesis [Zan15] and its related series of papers [BSZ14; BSZ15; BS17]. For
details about applications to control theory, see [FSR16]. From the control theoretic
perspective, the ideas and philosophy of this chapter are heavily inÔ¨Çuenced by Willems‚Äô
behavioral approach [Wil07].
For the reader that has not studied abstract algebra, we mention that rings, monoids,
and matrices are standard fare in abstract algebra, and can be found in any standard
introduction, such as [Fra67]. Rigs, also known as semirings, are a bit less well known,
but no less interesting; a comprehensive survey of the literature can be found in [Gla13].
Perhaps the most signiÔ¨Åcant idea in this chapter is the separation of structure into
syntax and semantics, related by a functor. This is not only present in the running
theme of studying signal Ô¨Çow graphs, but in our aside Section 5.4.2, where we talk,
for example, about monoid objects in monoidal categories.
The idea of functorial
semantics is yet another due to Lawvere, Ô¨Årst appearing in his thesis [Law04].


Chapter 6
Electric circuits:
Hypergraph categories and operads
6.1
The ubiquity of network languages
Electric circuits, chemical reaction networks, Ô¨Ånite state automata, Markov processes:
these are all models of physical or computational systems that are commonly described
using network diagrams. Here, for example, we draw a diagram that models a Ô¨Çip-Ô¨Çop,
an electric circuit‚Äîimportant in computer memory‚Äîthat can store a bit of information:
VS
OUTPUT
OUTPUT
SET
RESET
1K‚Ñ¶
1K‚Ñ¶
10K‚Ñ¶
10K‚Ñ¶
Network diagrams have time-tested utility. In this chapter, we are interested in
understanding the common mathematical structure that they share, for the purposes of
translating between and unifying them; for example certain types of Markov processes
can be simulated and hence solved using circuits of resisters. When we understand
the underlying structures that are shared by network diagram languages, we can make
comparisons between the corresponding mathematical models easily.
At Ô¨Årst glance network diagrams appear quite diÔ¨Äerent from the wiring diagrams we
have seen so far. For example, the wires are undirected in the case above, whereas in a
181

182
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
category‚Äîincluding monoidal categories seen in resource theories or co-design‚Äîevery
morphism has a domain and codomain, giving it a sense of direction. Nonetheless,
we shall see how to use categorical constructions such as universal properties to create
categorical models that precisely capture the above type of ‚Äúnetwork‚Äù compositionality,
i.e. allowing us to eÔ¨Äectively drop directedness when convenient.
In particular we‚Äôll return to the idea of a colimit, which we sketched for you at the
end of Chapter 3, and show how to use colimits in the category of sets to formalize
ideas of connection. Here‚Äôs the key idea.
Connections via colimits.
Let‚Äôs say we want to install some lights: we want to create
a circuit so that when we Ô¨Çick a switch, a light turns on or oÔ¨Ä. To start, we have a bunch
of circuit components: a power source, a switch, and a lamp connected to a resistor:
We want to connect them together, but there are many ways to do so. How should we
describe the particular way that will form a light switch?
First, we claim that circuits should really be thought of as open circuits: each carries
the additional structure of an ‚Äòinterface‚Äô exposing it to the rest of the electrical world.
Here by interface we mean a certain set of locations, or ports, at which we are able to
connect them with other components.1 As is so common in category theory, we begin
by making this more-or-less obvious fact explicit. Let‚Äôs depict the available ports using
a bold ‚Ä¢. If we say that in the each of the three drawings above, the ports are simply
the dangling end points of the wires, they would be redrawn as follows:
Next, we have to describe which ports should be connected. We‚Äôll do this by draw-
ing empty circles ‚ó¶connected by arrows to two ports ‚Ä¢. Each will be a witness-to-
connection, saying ‚Äòconnect these two!‚Äô
1If your circuit has no such ports, it still falls within our purview, by taking its interface to be the
empty set.

6.1. THE UBIQUITY OF NETWORK LANGUAGES
183
Looking at this picture, it is clear what we need to do: just identify‚Äîi.e. merge or make
equal‚Äîthe ports as indicated, to get the following circuit:
But mathematics doesn‚Äôt have a visual cortex with which to generate the intuitions
we can count on with a human reader such as yourself.2 Thus we need to specify
formally what ‚Äòidentifying ports as indicated‚Äô means mathematically. As it turns out,
we can do this using Ô¨Ånite colimits in a given category C.
Colimits are diagrams with certain universal properties, which is kind of an epiphe-
nomenon of the category C. Our goal is to obtain C‚Äôs colimits more directly, as a kind
of operation in some context, so that we can think of them as telling us how to connect
circuit parts together. To that end, we produce a certain monoidal category‚Äînamely
that of cospans in C, denoted CospanC‚Äîthat can conveniently package C‚Äôs colimits in
terms of its own basic operations: composition and monoidal product.
In summary, the Ô¨Årst part of this chapter is devoted to the slogan ‚Äòcolimits model
interconnection‚Äô.
In addition to universal constructions such as colimits, however,
another way to describe interconnection is to use wiring diagrams. We go full circle
when we Ô¨Ånd that these wiring diagrams are strongly connected to cospans, and hence
colimits.
Composition operations and wiring diagrams.
In this book we have seen the utility
of deÔ¨Åning syntactic or algebraic structures that describe the sort of composition op-
erations that make sense and can be performed in a given application area. Examples
include monoidal preorders with discarding, props, and compact closed categories.
Each of these has an associated sort of wiring diagram style, so that any wiring dia-
gram of that style represents a composition operation that makes sense in the given
area: the Ô¨Årst makes sense in manufacturing, the second in signal Ô¨Çow, and the third
in collaborative design. So our second goal is to answer the question, ‚Äúhow do we
describe the compositional structure of network-style wiring diagrams?‚Äù
Network-type interconnection can be described using something called a hyper-
graph category. Roughly speaking, these are categories whose wiring diagrams are
those of symmetric monoidal categories together with, for each pair of natural numbers
(m, n), an icon sm,n : m ‚Üín. These icons, known as spiders,3 are drawn as follows:
Two spiders can share a leg, and when they do, we can fuse them into one spider. The
intuition is that spiders are connection points for a number of wires, and when two
2Unless the future has arrived since the writing of this book.
3Our spiders have any number of legs.

184
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
connection points are connected, they fuse to form an even more ‚Äòconnect-y‚Äô connection
point. Here is an example:

A hypergraph category may have many species of spiders with the rule that spiders
of diÔ¨Äerent species cannot share a leg‚Äîand hence not fuse‚Äîbut two spiders of the
same species can share legs and fuse. We add spider diagrams to the iconography of
hypergraph categories.
As we shall see, the ideas of describing network interconnection using colimits and
hypergraph categories come together in the notion of a theory. We Ô¨Årst introduced the
idea of a theory in Section 5.4.2, but here we explore it more thoroughly, starting with
the idea that, approximately speaking, cospans in the category FinSet form the theory
of hypergraph categories.
We can assemble all cospans in FinSet into something called an ‚Äòoperad‚Äô. Through-
out this book we have talked about using free structures and presentations to create
instances of algebraic structures such as preorders, categories, and props, tailored
to the needs of a particular situation.
Operads can be used to tailor the algebraic
structures themselves to the needs of a particular situation. We will discuss how this
works, in particular how operads encode various sorts of wiring diagram languages
and corresponding algebraic structures, at the end of the chapter.
6.2
Colimits and connection
Universal constructions are central to category theory. They allow us to deÔ¨Åne objects,
at least up to isomorphism, by describing their relationship with other objects. So far
we have seen this theme in a number of diÔ¨Äerent forms: meets and joins (Section 1.3),
Galois connections and adjunctions (Sections 1.4 and 3.4), limits (Section 3.5), and free
and presented structures (Section 5.2.3-5.2.5). Here we turn our attention to colimits.
In this section, our main task is to have a concrete understanding of colimits in the
category FinSet of Ô¨Ånite sets and functions. The idea will be to take a bunch of sets‚Äî
say two or Ô¨Åfteen or zero‚Äîuse functions between them to designate that elements in
one set ‚Äòshould be considered the same‚Äô as elements in another set, and then merge the
sets together accordingly.
6.2.1
Initial objects
Just as the simplest limit is a terminal object (see Section 3.5.1), the simplest colimit is
an initial object. This is the case where you start with no objects and you merge them
together.

6.2. COLIMITS AND CONNECTION
185
DeÔ¨Ånition 6.1. Let C be a category. An initial object in C is an object ¬ú ‚ààC such that for
each object T in C there exists a unique morphism !T : ¬ú ‚ÜíT.
The symbol ¬ú is just a default name, a notation, intended to evoke the right idea;
see Example 6.4 for the reason why we use the notation ¬ú, and Exercise 6.7 for a case
when the default name ¬ú would probably not be used.
Again, the hallmark of universality is the existence of a unique map to any other
comparable object.
Example 6.2. An initial object of a preorder is a bottom element‚Äîthat is, an element that
is less than every other element. For example 0 is the initial object in (N, ‚â§), whereas
(R, ‚â§) has no initial object.
Exercise 6.3.
Consider the set A  {a, b}. Find a preorder relation ‚â§on A such that
1. (A, ‚â§) has no initial object.
2. (A, ‚â§) has exactly one initial object.
3. (A, ‚â§) has two initial objects.
‚ô¶
Example 6.4. The initial object in FinSet is the empty set. Given any Ô¨Ånite set T, there
is a unique function ¬ú ‚ÜíT, since ¬ú has no elements.
Example 6.5. As seen in Exercise 6.3, a category C need not have an initial object. As a
diÔ¨Äerent sort of example, consider the category shown here:
C B
A‚Ä¢
B‚Ä¢
f
1
If there were to be an initial object ¬ú, it would either be A or B. Either way, we need to
show that for each object T ‚ààOb(C) (i.e. for both T  A and T  B) there is a unique
morphism ¬ú ‚ÜíT. Trying the case ¬ú ? A this condition fails when T  B: there are
two morphisms A ‚ÜíB, not one. And trying the case ¬ú ? B this condition fails when
T  A: there are zero morphisms B ‚ÜíA, not one.
Exercise 6.6.
For each of the graphs below, consider the free category on that graph,
and say whether it has an initial object.
1.
a‚Ä¢
2.
a‚Ä¢ ‚Üí
b‚Ä¢ ‚Üí
c‚Ä¢
3.
a‚Ä¢
b‚Ä¢
4.
a‚Ä¢
‚ô¶
Exercise 6.7.
Recall the notion of rig from Chapter 5.
A rig homomorphism from
(R, 0R, +R, 1R, ‚àóR) to (S, 0S, +S, 1S, ‚àóS) is a function f : R ‚ÜíS such that f (0R)  0S,
f (r1 +R r2)  f (r1) +S f (r2), etc.
1. We said ‚Äúetc.‚Äù Guess the remaining conditions for f to be a rig homomorphism.

186
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
2. Let Rig denote the category whose objects are rigs and whose morphisms are rig
homomorphisms. We claim Rig has an initial object. What is it?
‚ô¶
Exercise 6.8.
Explain the statement ‚Äúthe hallmark of universality is the existence of
a unique map to any other comparable object,‚Äù in the context of DeÔ¨Ånition 6.1. In
particular, what is being universal in DeÔ¨Ånition 6.1, and which is the ‚Äúcomparable
object‚Äù?
‚ô¶
Remark 6.9. As mentioned in Remark 3.85, we often speak of ‚Äòthe‚Äô object that satisÔ¨Åes a
universal property, such as ‚Äòthe initial object‚Äô, even though many diÔ¨Äerent objects could
satisfy the initial object condition. Again, the reason is that initial objects are unique
up to unique isomorphism: any two initial objects will have a canonical isomorphism
between them, which one Ô¨Ånds using various applications of the universal property.
Exercise 6.10.
Let C be a category, and suppose that c1 and c2 are initial objects. Find
an isomorphism between them, using the universal property from DeÔ¨Ånition 6.1.
‚ô¶
6.2.2
Coproducts
Coproducts generalize both joins in a preorder and disjoint unions of sets.
DeÔ¨Ånition 6.11. Let A and B be objects in a category C.
A coproduct of A and B
is an object, which we denote A + B, together with a pair of morphisms (ŒπA : A ‚Üí
A + B, ŒπB : B ‚ÜíA + B) such that for all objects T and pairs of morphisms ( f : A ‚Üí
T, 1 : B ‚ÜíT), there exists a unique morphism [ f , 1]: A+B ‚ÜíT such that the following
diagram commutes:
A
A + B
B
T
ŒπA
f
[ f ,1]
ŒπB
1
(6.12)
We call [ f , 1] the copairing of f and 1.
Exercise 6.13.
Explain why, in a preorder, coproducts are the same as joins.
‚ô¶
Example 6.14. Coproducts in the categories FinSet and Set are disjoint unions. More
precisely, suppose A and B are sets.
Then the coproduct of A and B is given by
the disjoint union A ‚äîB together with the inclusion functions ŒπA : A ‚àí‚ÜíA ‚äîB and

6.2. COLIMITS AND CONNECTION
187
ŒπB : B ‚ÜíA ‚äîB.
apple
‚Ä¢
banana
‚Ä¢
pear
‚Ä¢
cherry
‚Ä¢
orange
‚Ä¢
A
apple
‚Ä¢
tomato
‚Ä¢
mango
‚Ä¢
B
‚äî
apple1
‚Ä¢
banana1
‚Ä¢
pear1
‚Ä¢
cherry1
‚Ä¢
orange1
‚Ä¢
apple2
‚Ä¢
tomato2
‚Ä¢
mango2
‚Ä¢
A ‚äîB

(6.15)
Suppose we have functions f : A ‚ÜíT and 1 : B ‚ÜíT for some other set T,
unpictured.
The universal property of coproducts says there is a unique function
[ f , 1]: A ‚äîB ‚ÜíT such that ŒπA # [ f , 1]  f and ŒπB # [ f , 1]  1. What is it? Any element
x ‚ààA ‚äîB is either ‚Äòfrom A‚Äô or ‚Äòfrom B‚Äô, i.e. either there is some a ‚ààA with x  ŒπA(a) or
there is some b ‚ààB with x  ŒπB(b). By Eq. (6.12), we must have:
[ f , 1](x) 
(
f (x)
if x  ŒπA(a) for some a ‚ààA;
1(x)
if x  ŒπB(b) for some b ‚ààB.
Exercise 6.16.
Suppose T  {a, b, c, . . . , z} is the set of letters in the alphabet, and let
A and B be the sets from Eq. (6.15). Consider the function f : A ‚ÜíT sending each
element of A to the Ô¨Årst letter of its label, e.g. f (apple)  a. Let 1 : B ‚ÜíT be the
function sending each element of B to the last letter of its label, e.g. 1(apple)  e. Write
down the function [ f , 1](x) for all eight elements of A ‚äîB.
‚ô¶
Exercise 6.17.
Let f : A ‚ÜíC, 1 : B ‚ÜíC, and h : C ‚ÜíD be morphisms in a category C
with coproducts. Show that
1. ŒπA # [ f , 1]  f .
2. ŒπB # [ f , 1]  1.
3. [ f , 1] # h  [ f # h, 1 # h].
4. [ŒπA, ŒπB]  idA+B.
‚ô¶
Exercise 6.18.
Suppose a category C has coproducts, denoted +, and an initial object,
denoted ¬ú. Then (C, +, ¬ú) is a symmetric monoidal category (recall DeÔ¨Ånition 4.45). In
this exercise we develop the data relevant to this fact:
1. Show that + extends to a functor C √ó C ‚ÜíC. In particular, how does it act on
morphisms in C √ó C?
2. Using the universal properties of the initial object and coproduct, show that there
are isomorphisms A + ¬ú ‚ÜíA and ¬ú + A ‚ÜíA.
3. Using the universal property of the coproduct, write down morphisms
a) (A + B) + C ‚ÜíA + (B + C).
b) A + B ‚ÜíB + A.

188
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
If you like, check that these are isomorphisms.
It can then be checked that this data obeys the axioms of a symmetric monoidal category,
but we‚Äôll end the exercise here.
‚ô¶
6.2.3
Pushouts
Pushouts are a way of combining sets. Like a union of subsets, a pushout can combine
two sets in a non-disjoint way: elements of one set may be identiÔ¨Åed with elements of
the other. The pushout construction, however, is much more general: it allows (and
requires) the user to specify exactly which elements will be identiÔ¨Åed. We‚Äôll see a
demonstration of this additional generality in Example 6.29.
DeÔ¨Ånition 6.19. Let C be a category and let f : A ‚ÜíX and 1 : A ‚ÜíY be morphisms
in C that have a common domain. The pushout X +A Y is the colimit of the diagram
A
X
Y
f
1
In more detail, a pushout consists of (i) an object X +A Y and (ii) morphisms ŒπX : X ‚Üí
X +A Y and ŒπY : Y ‚ÜíX +A Y satisfying (a) and (b) below.
(a) The diagram
A
X
Y
X +A Y
f
1
ŒπX
ŒπY
‚åú
(6.20)
commutes. (We will explain the ‚Äò‚åú‚Äô symbol below.)
(b) For all objects T and morphisms x : X ‚ÜíT, y : Y ‚ÜíT, if the diagram
A
X
Y
T
f
1
x
y
commutes, then there exists a unique morphism t : X +A Y ‚ÜíT such that
A
X
Y
X +A Y
T
f
1
ŒπX
x
ŒπY
y
t
(6.21)
commutes.

6.2. COLIMITS AND CONNECTION
189
If X +A Y is a pushout, we denote that fact by drawing the commutative square
Eq. (6.20), together with the ‚åúsymbol as shown; we call it a pushout square.
We further call ŒπX the pushout of 1 along f , and similarly ŒπY the pushout of f along 1.
Example 6.22. In a preorder, pushouts and coproducts have a lot in common.
The
pushout of a diagram B ‚ÜêA ‚ÜíC is equal to the coproduct B ‚äîC: namely, both are
equal to the join B ‚à®C.
Example 6.23. Let f : A ‚ÜíX be a morphism in a category C. For any isomorphisms
i : A ‚ÜíA‚Ä≤ and j : X ‚ÜíX‚Ä≤, we can take X‚Ä≤ to be the pushout X +A A‚Ä≤, i.e. the following
is a pushout square:
A
X
A‚Ä≤
X‚Ä≤
f
i
j
f ‚Ä≤
‚åú
where f ‚Ä≤ B i‚àí1 # f # j. To see this, observe that if there is any object T such that the
following square commutes:
A
X
A‚Ä≤
T
f
i
x
a
then f # x  i # a, and so we are forced to take x‚Ä≤: X ‚ÜíT to be x‚Ä≤ B j‚àí1 # x. This makes
the following diagram commute:
A
X
A‚Ä≤
X‚Ä≤
T
f
i
j
x
f ‚Ä≤
a
x‚Ä≤
because f ‚Ä≤ # x‚Ä≤  i‚àí1 # f # j # j‚àí1 # x  i‚àí1 # i # a  a.
Exercise 6.24.
For any set S, we have the discrete category DiscS, with S as objects and
only identity morphisms.
1. Show that all pushouts exist in DiscS, for any set S.
2. For what sets S does DiscS have an initial object?
‚ô¶
Example 6.25. In the category FinSet, pushouts always exist. The pushout of functions
f : A ‚ÜíX and 1 : A ‚ÜíY is the set of equivalence classes of X ‚äîY under the equiva-
lence relation generated by‚Äîthat is, the reÔ¨Çexive, transitive, symmetric closure of‚Äîthe

190
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
relation { f (a) ‚àº1(a) | a ‚ààA}.
We can think of this in terms of interconnection too. Each element a ‚ààA provides
a connection between f (a) in X and 1(a) in Y. The pushout is the set of connected
components of X ‚äîY.
Exercise 6.26.
What is the pushout of the functions f : 4 ‚Üí5 and 1 : 4 ‚Üí3 pictured
below?
f : 4 ‚Üí5
1 : 4 ‚Üí3
‚ô¶
Check your answer using the abstract description from Example 6.25.
Example 6.27. Suppose a category C has an initial object ¬ú. For any two objects X, Y ‚àà
Ob C, there is a unique morphism f : ¬ú ‚ÜíX and a unique morphism 1 : ¬ú ‚ÜíY; this
is what it means for ¬ú to be initial.
The diagram X
f
‚Üê‚àí¬ú
1
‚àí‚ÜíY has a pushout in C iÔ¨ÄX and Y have a coproduct in C,
and the pushout and the coproduct will be the same. Indeed, suppose X and Y have a
coproduct X + Y; then the diagram to the left
¬ú
X
Y
X + Y
f
1
ŒπX
ŒπY
¬ú
X
Y
T
f
1
x
y
commutes (why?1), and for any object T and commutative diagram as to the right, there
is a unique map X + Y ‚ÜíT making the diagram as in Eq. (6.21) commute (why?2).
This shows that X + Y is a pushout, X +¬ú Y  X + Y.
Similarly, if a pushout X +¬ú Y exists, then it satisÔ¨Åes the universal property of the
coproduct (why?3).
Exercise 6.28.
In Example 6.27 we asked ‚Äúwhy?‚Äù three times.
1. Give a justiÔ¨Åcation for ‚Äúwhy?1‚Äù.
2. Give a justiÔ¨Åcation for ‚Äúwhy?2‚Äù.
3. Give a justiÔ¨Åcation for ‚Äúwhy?3‚Äù.
‚ô¶
Example 6.29. Let A  X  Y  N. Consider the functions f : A ‚ÜíX and 1 : A ‚ÜíY

6.2. COLIMITS AND CONNECTION
191
given by the ‚ÄòÔ¨Çoor‚Äô functions, f (a) B ‚åäa/2‚åãand 1(a) B ‚åä(a + 1)/2‚åã.
X
A
Y
0
0
0
1
1
1
2
2
2
3
3
3
4
4
4
5
5
5
¬∑ ¬∑ ¬∑
¬∑ ¬∑ ¬∑
¬∑ ¬∑ ¬∑
f
1
What is their pushout? Let‚Äôs Ô¨Ågure it out using the deÔ¨Ånition.
If T is any other set and we have maps x : X ‚ÜíT and y : Y ‚ÜíT that commute with
f and 1, i.e. f  x  1  y, then this commutativity implies that
y(0)  y(1(0))  x( f (0))  x(0).
In other words, Y‚Äôs 0 and X‚Äôs 0 go to the same place in T, say t. But since f (1)  0
and 1(1)  1, we also have that t  x(0)  x( f (1))  y(1(1))  y(1). This means Y‚Äôs 1
goes to t also. But since 1(2)  1 and f (2)  1, we also have that t  1(1)  y(1(2)) 
x( f (2))  x(1), which means that X‚Äôs 1 also goes to t. One can keep repeating this
and Ô¨Ånd that every element of Y and every element of X go to t! Using mathematical
induction, one can prove that the pushout is in fact a 1-element set, X ‚äîA Y  {1}.
6.2.4
Finite colimits
Initial objects, coproducts, and pushouts are all types of colimits. We gave the general
deÔ¨Ånition of colimit in Section 3.5.4.
Just as a limit in C is a terminal object in a
category of cones over a diagram D : J ‚ÜíC, a colimit is an initial object in a category of
cocones over some diagram D : J ‚ÜíC. For our purposes it is enough to discuss Ô¨Ånite
colimits‚Äîi.e. when J is a Ô¨Ånite category‚Äîwhich subsume initial objects, coproducts,
and pushouts.4
In DeÔ¨Ånition 3.102, cocones in C are deÔ¨Åned to be cones in Cop. For visualization
purposes, if D : J ‚ÜíC looks like the diagram to the left, then a cocone on it shown in
the diagram to the right:
D1
D3
D2
D4
D5
C
D1
D3
D2
D4
D5
T
Here, any two parallel paths that end at T are equal in C.
4If a category J has Ô¨Ånitely many morphisms, we say that J is a Ô¨Ånite category. Note that in this case it
must have Ô¨Ånitely many objects too, because each object j ‚ààOb J has its own identity morphism idj.

192
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
DeÔ¨Ånition 6.30. We say that a category C has Ô¨Ånite colimits if a colimit, colimJ D, exists
whenever J is a Ô¨Ånite category and D : J ‚ÜíC is a diagram.
Example 6.31. The initial object in a category C, if it exists, is the colimit of the functor
!: 0 ‚ÜíC, where 0 is the category with no objects and no morphisms, and ! is the unique
such functor. Indeed, a cocone over ! is just an object of C, and so the initial cocone over
! is just the initial object of C.
Note that 0 has Ô¨Ånitely many objects (none); thus initial objects are Ô¨Ånite colimits.
We often want to know that a category C has all Ô¨Ånite colimits (in which case, we
often drop the ‚Äòall‚Äô and just say ‚ÄòC has Ô¨Ånite colimits‚Äô). To check that C has (all) Ô¨Ånite
colimits, it‚Äôs enough to check it has a few simpler forms of colimit, which generate all
the rest.
Proposition 6.32. Let C be a category. The following are equivalent:
1. C has all Ô¨Ånite colimits.
2. C has an initial object and all pushouts.
3. C has all coequalizers and all Ô¨Ånite coproducts.
Proof. We will not give precise details here, but the key idea is an inductive one: one
can build arbitrary Ô¨Ånite diagrams using some basic building blocks. Full details can
be found in [Bor94, Prop 2.8.2].
‚ñ°
Example 6.33. Let C be a category with all pushouts, and suppose we want to take the
colimit of the following diagram in C:
B
Z
A
C
D
(6.34)
In it we see two diagrams ready to be pushed out, and we know how to take pushouts.
So suppose we do that; then we see another pushout diagram so we take the pushout
again:
B
Z
A
Y
R
X
Q
‚åú
‚åú
B
Z
A
Y
R
X
Q
S
‚åú
‚åú
‚åú

6.2. COLIMITS AND CONNECTION
193
is the result‚Äîconsisting of the object S, together with all the morphisms from the
original diagram to S‚Äîthe colimit of the original diagram? One can check that it
indeed has the correct universal property and thus is a colimit.
Exercise 6.35.
Check that the pushout of pushouts from Example 6.33 satisÔ¨Åes the
universal property of the colimit for the original diagram, Eq. (6.34).
‚ô¶
We have already seen that the categories FinSet and Set both have an initial object
and pushouts. We thus have the following corollary.
Corollary 6.36. The categories FinSet and Set have (all) Ô¨Ånite colimits.
In Theorem 3.95 we gave a general formula for computing Ô¨Ånite limits in Set. It is
also possible to give a formula for computing Ô¨Ånite colimits. There is a duality between
products and coproducts and between subobjects and quotient objects, so whereas a
Ô¨Ånite limit is given by a subset of a product, a Ô¨Ånite colimit is given by a quotient of a
coproduct.
Theorem 6.37. Let J be presented by the Ô¨Ånite graph (V, A, s, t) and some equations,
and let D : J ‚ÜíSet be a diagram. Consider the set
colim
J
D B

(v, d) | v ‚ààV and d ‚ààD(v)
	
/‚àº
where this denotes the set of equivalence classes under the equivalence relation ‚àº
generated by putting (v, d) ‚àº(w, e) if there is an arrow a : v ‚Üíw in J such that
D(a)(d)  e. Then this set, together with the functions Œπv : D(v) ‚ÜícolimJ D given by
sending d ‚ààD(v) to its equivalence class, constitutes a colimit of D.
Example 6.38. Recall that an initial object is the colimit on the empty graph. The formula
thus says the initial object in Set is the empty set ¬ú: there are no v ‚ààV.
Example 6.39. A coproduct is a colimit on the graph J 
v1‚Ä¢
v2‚Ä¢ . A functor D : J ‚ÜíSet
can be identiÔ¨Åed with a choice of two sets, X B D(v1) and Y B D(v2). Since there are
no arrows in J, the equivalence relation ‚àºis vacuous, so the formula in Theorem 6.37
says that a coproduct is given by
{(v, d) | d ‚ààD(v), where v  v1 or v  v2}.
In other words, the coproduct of sets X and Y is their disjoint union X ‚äîY, as expected.

194
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
Example 6.40. If J is the category 1 
v‚Ä¢ , the formula in Theorem 6.37 yields the set
{(v, d) | d ‚ààD(v)}
This is isomorphic to the set D(v). In other words, if X is a set considered as a diagram
X : 1 ‚ÜíSet, then its colimit (like its limit) is just X again.
Exercise 6.41.
Use the formula in Theorem 6.37 to show that pushouts‚Äîcolimits on a
diagram X
f
‚Üê‚àíN
1
‚àí‚ÜíY‚Äîagree with the description we gave in Example 6.25.
‚ô¶
Example 6.42. Another important type of Ô¨Ånite colimit is the coequalizer. These are
colimits over the graph ‚Ä¢ ‚áí‚Ä¢ consisting of two parallel arrows.
Consider some diagram X
Y
f
1
on this graph in Set. The coequalizer of this
diagram is the set of equivalence classes of Y under equivalence relation generated by
declaring y ‚àºy‚Ä≤ whenever there exists x in X such that f (x)  y and 1(x)  y‚Ä≤.
Let‚Äôs return to the example circuit in the introduction to hint at why colimits are
useful for interconnection. Consider the following picture:
We‚Äôve redrawn this picture with one change: some of the arrows are now red, and
others are now blue. If we let X be the set of white circles ‚ó¶, and Y be the set of black
circles ‚Ä¢, the blue and red arrows respectively deÔ¨Åne functions f , 1 : X ‚ÜíY. Let‚Äôs
leave the actual circuit components out of the picture for now; we‚Äôre just interested in
the dots. What is the coequalizer?
It is a three element set, consisting of one element for each newly-connected pair of
‚Ä¢‚Äôs . Thus the colimit describes the set of terminals after performing the interconnection
operation. In Section 6.4 we‚Äôll see how to keep track of the circuit components too.
6.2.5
Cospans
When a category C has Ô¨Ånite colimits, an extremely useful way to package them is by
considering the category of cospans in C.
DeÔ¨Ånition 6.43. Let C be a category. A cospan in C is just a pair of morphisms to a
common object A ‚ÜíN ‚ÜêB. The common object N is called the apex of the cospan
and the other two objects A and B are called its feet.

6.2. COLIMITS AND CONNECTION
195
If we want to say that cospans form a category, we should begin by saying how
composition would work. So suppose we have two cospans in C
N
A
B
f
1
and
P
B
C
h
k
Since the right foot of the Ô¨Årst is equal to the left foot of the second, we might stick
them together into a diagram like this:
N
P
A
B
C
f
1
h
k
Then, if a pushout of N
1
‚Üê‚àíB
h‚àí‚ÜíP exists in C, as shown on the left, we can extract a
new cospan in C, as shown on the right:
N +B P
N
P
A
B
C
‚åü
ŒπN
ŒπP
f
1
h
k
‚áù
N +B P
A
C
f #ŒπN
k#ŒπP
(6.44)
It might look like we have achieved our goal, but we‚Äôre missing some things. First, we
need an identity on every object C ‚ààOb C; but that‚Äôs not hard: use C ‚ÜíC ‚ÜêC where
both maps are identities in C. More importantly, we don‚Äôt know that C has all pushouts,
so we don‚Äôt know that every two sequential morphisms A ‚ÜíB ‚ÜíC can be composed.
And beyond that, there is a technical condition that when we form pushouts, we only
get an answer ‚Äòup to isomorphism‚Äô: anything isomorphic to a pushout counts as a
pushout (check the deÔ¨Ånition to see why). We want all these diÔ¨Äerent choices to count
as the same thing, so we deÔ¨Åne two cospans to be equivalent iÔ¨Äthere is an isomorphism
between their respective apexes. That is, the cospan A ‚ÜíP ‚ÜêB and A ‚ÜíP‚Ä≤ ‚ÜêB
in the diagram shown left below are equivalent iÔ¨Äthere is an isomorphism P  P‚Ä≤
making the diagram to the right commute:
P
A
B
P‚Ä≤
P
A
B
P‚Ä≤

Now we are getting somewhere. As long as our category C has pushouts, we are in
business: CospanC will form a category. But in fact, we are very close to getting more.
If we also demand that C has an initial object ¬ú as well, then we can upgrade CospanC
to a symmetric monoidal category.
Recall from Proposition 6.32 that a category C has all Ô¨Ånite colimits iÔ¨Äit has an
initial object and all pushouts.

196
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
DeÔ¨Ånition 6.45. Let C be a category with Ô¨Ånite colimits. Then there exists a category
CospanC with the same objects as C, i.e. Ob(CospanC)  Ob(C), where the morphisms
A ‚ÜíB are the (equivalence classes of) cospans from A to B, and composition is given
by the above pushout construction.
There is a symmetric monoidal structure on this category, denoted (CospanC, ¬ú, +).
The monoidal unit is the initial object ¬ú ‚ààC and the monoidal product is given by
coproduct. The coherence isomorphisms, e.g. A + ¬ú  A, can be deÔ¨Åned in a similar
way to those in Exercise 6.18.
It is a straightforward but time-consuming exercise to verify that (CospanC, ¬ú, +)
from DeÔ¨Ånition 6.45 really does satisfy all the axioms of a symmetric monoidal category,
but it does.
Example 6.46. The category FinSet has Ô¨Ånite colimits (see 6.36). So, we can deÔ¨Åne a
symmetric monoidal category CospanFinSet. What does it look like? It looks a lot like
wires connecting ports.
The objects of CospanFinSet are Ô¨Ånite sets; here let‚Äôs draw them as collections of ‚Ä¢‚Äôs.
The morphisms are cospans of functions. Let A and N be Ô¨Åve element sets, and B be a
six element set. Below are two depictions of a cospan A
f
‚àí‚ÜíN
1
‚Üê‚àíB.
A
B
N
A
B
In the depiction on the left, we simply represent the functions f and 1 by drawing
arrows from each a ‚ààA to f (a) and each b ‚ààB to 1(b). In the depiction on the right, we
make this picture resemble wires a bit more, simply drawing a wire where before we
had an arrow, and removing the unnecessary center dots. We also draw a dotted line
around points that are connected, to emphasize an important perspective, that cospans
establish that certain ports are connected, i.e. part of the same equivalence class.
The monoidal category CospanFinSet then provides two operations for combining
cospans: composition and monoidal product.
Composition is given by taking the
pushout of the maps coming from the common foot, as described in DeÔ¨Ånition 6.45.
Here is an example of cospan composition, where all the functions are depicted with

6.3. HYPERGRAPH CATEGORIES
197
arrow notation:
A
N
B
P
C
{
A
N +B P
C
(6.47)
The monoidal product is given simply by the disjoint union of two cospans; in pictures
it is simply combining two cospans by stacking one above another.
Exercise 6.48.
In Eq. (6.47) we showed morphisms A ‚ÜíB and B ‚ÜíC in CospanFinSet.
Draw their monoidal product as a morphism A + B ‚ÜíB + C in CospanFinSet.
‚ô¶
Exercise 6.49.
Depicting the composite of cospans in Eq. (6.47) with the wire notation
gives

(6.50)
Comparing Eq. (6.47) and Eq. (6.50), describe the composition rule in CospanFinSet in
terms of wires and connected components.
‚ô¶
6.3
Hypergraph categories
A hypergraph category is a type of symmetric monoidal category whose wiring di-
agrams are networks. We will soon see that electric circuits can be organized into a
hypergraph category; this is what we‚Äôve been building up to. But to deÔ¨Åne hypergraph
categories, it is useful to Ô¨Årst introduce Frobenius monoids.
6.3.1
Frobenius monoids
The pictures of cospans we saw above, e.g. in Eq. (6.50) look something like icons in
signal Ô¨Çow graphs (see Section 5.3.2): various wires merge and split, initialize and
terminate. And these follow the same rules they did for linear relations, which we
brieÔ¨Çy discussed in Exercise 5.84. There‚Äôs a lot of potential for confusion, so let‚Äôs start
from scratch and build back up.
In any symmetric monoidal category (C, I, ‚äó), recall from Section 4.4.2 that objects
can be drawn as wires and morphisms can be drawn as boxes. Particularly noteworthy
morphisms might be iconiÔ¨Åed as dots rather than boxes, to indicate that the morphisms

198
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
there are not arbitrary but notation-worthy. One case of this is when there is an object X
with special ‚Äúabilities‚Äù, e.g. the ability to duplicate into two, or disappear into nothing.
To make this precise, recall from DeÔ¨Ånition 5.65 that a commutative monoid (X, ¬µ, Œ∑)
in symmetric monoidal category (C, I, ‚äó) is an object X of C together with (noteworthy)
morphisms
¬µ: X ‚äóX ‚ÜíX
Œ∑: I ‚ÜíX
obeying



(associativity)
(unitality)
(commutativity)
(6.51)
where
is the symmetry on X ‚äóX. A cocommutative cocomonoid (X, Œ¥, œµ) is an
object X with maps Œ¥: X ‚ÜíX ‚äóX, œµ: X ‚ÜíI, obeying the mirror images of the laws in
Eq. (6.51).
Suppose X has both the structure of a commutative monoid and cocommutative
comonoid, and consider a wiring diagram built only from the icons ¬µ, Œ∑, Œ¥, and œµ,
where every wire is labeled X. These diagrams have a left and right, and are pictures
of how ports on the left are connected to ports on the right. The commutative monoid
and cocommutative comonoid axioms thus both express when to consider two such
connection pictures should be considered the same. For example, associativity says the
order of connecting ports on the left doesn‚Äôt matter; coassociativity (not drawn) says
the same for the right.
If you want to go all the way and say ‚Äúall I care about is which port is connected to
which; I don‚Äôt even care about left and right‚Äù, then you need a few more axioms to say
how the morphisms ¬µ and Œ¥, the merger and the splitter, interact.
DeÔ¨Ånition 6.52. Let X be an object in a symmetric monoidal category (C, ‚äó, I). A Frobe-
nius structure on X consists of a 4-tuple (¬µ, Œ∑, Œ¥, œµ) such that (X, ¬µ, Œ∑) is a commutative
monoid and (X, Œ¥, œµ) is a cocommutative comonoid, which satisÔ¨Åes the six equations
above ((co-)associativity, (co-)unitality, (co-)commutativity), as well as the following
three equations:



(the Frobenius law)
(the special law)
(6.53)
We refer to an object X equipped with a Frobenius structure as a special commutative
Frobenius monoid, or just Frobenius monoid for short.

6.3. HYPERGRAPH CATEGORIES
199
With these two equations, it turns out that two morphisms X‚äóm ‚ÜíX‚äón‚ÄîdeÔ¨Åned
by composing and tensoring identities on X and the noteworthy morphisms ¬µ, Œ¥, etc.‚Äî
are equal if and only if their string diagrams connect the same ports. This link between
connectivity, and Frobenius monoids can be made precise as follows.
DeÔ¨Ånition 6.54. Let (X, ¬µ, Œ∑, Œ¥, œµ) be a Frobenius monoid in a monoidal category
(C, I, ‚äó). Let m, n ‚ààN. DeÔ¨Åne sm,n : X‚äóm ‚ÜíX‚äón to be the following morphism
...
...
m wires
n wires
It can be written formally as (m ‚àí1) ¬µ‚Äôs followed by (n ‚àí1) Œ¥‚Äôs, with special cases when
m  0 or n  0.
We call sm,n the spider of type (m, n), and can draw it more simply as the icon
m legs
n legs
So a special commutative Frobenius monoid, aside from being a mouthful, is a
‚Äòspiderable‚Äô wire. You agree that in any monoidal category wiring diagram language,
wires represent objects and boxes represent morphisms? Well in our weird way of
talking, if a wire is spiderable, it means that we have a bunch of morphisms ¬µ, Œ∑, Œ¥, œµ, œÉ
that we can combine without worrying about the order of doing so: the result is just
‚Äúhow many in‚Äôs, and how many out‚Äôs‚Äù: a spider. Here‚Äôs a formal statement.
Theorem 6.55. Let (X, ¬µ, Œ∑, Œ¥, œµ) be a Frobenius monoid in a monoidal category (C, I, ‚äó).
Suppose that we have a map f : X‚äóm ‚ÜíX‚äón each constructed from spiders and the
symmetry map œÉ: X‚äó2 ‚ÜíX‚äó2 using composition and the monoidal product, and such
that the string diagram of f has only one connected component. Then it is a spider:
f  sm,n.
Example 6.56. As the following two morphisms both (i) have the same number of
inputs and outputs, (ii) are constructed only from spiders, and (iii) are connected,
Theorem 6.55 immediately implies they are equal:

Exercise 6.57.
Let X be an object equipped with a Frobenius structure. Which of the
morphisms X ‚äóX ‚ÜíX ‚äóX ‚äóX in the following list are necessarily equal?
1.

200
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
2.
3.
4.
5.
6.
‚ô¶
Back to cospans.
Another way of understanding Frobenius monoids is to relate them
to cospans. Recall the notion of prop presentation from DeÔ¨Ånition 5.33.
Theorem 6.58. Consider the four-element set G B {¬µ, Œ∑, Œ¥, œµ} and deÔ¨Åne in, out: G ‚Üí
N as follows:
in(¬µ) B 2,
in(Œ∑) B 0,
in(Œ¥) B 1,
in(œµ) B 1,
out(¬µ) B 1,
out(Œ∑) B 1,
out(Œ¥) B 2,
out(œµ) B 0.
Let E be the set of Frobenius axioms, i.e. the nine equations from DeÔ¨Ånition 6.52.
Then the free prop on (G, E) is equivalent, as a symmetric monoidal category,a to
CospanFinSet.
a We will not explain precisely what it means to be equivalent as a symmetric monoidal category, but
you probably have some idea: ‚Äúthey are the same for all category-theoretic intents and purposes.‚Äù The
idea is similar to that of equivalence of categories, as explained in Remark 3.59.
Thus we see that ideal wires, connectivity, cospans, and objects with Frobenius
structures are all intimately related. We use Frobenius structures (all that splitting,
merging, initializing, and terminating stuÔ¨Ä) as a way to capture the grammar of circuit
diagrams.
6.3.2
Wiring diagrams for hypergraph categories
We introduce hypergraph categories through their wiring diagrams.
Just like for
monoidal categories, the formal deÔ¨Ånition is just the structure required to unambigu-
ously interpret these diagrams.

6.3. HYPERGRAPH CATEGORIES
201
Indeed, our interest in hypergraph categories is best seen in their wiring diagrams.
The key idea is that wiring diagrams for hypergraph categories are network diagrams.
This means, in addition to drawing labeled boxes with inputs and outputs, as we can
for monoidal categories, and in addition to bending these wires around as we can for
compact closed categories, we are allowed to split, join, terminate, and initialize wires.
Here is an example of a wiring diagram that represents a composite of morphisms
in a hypergraph category
f
h
h
1
A
B
C
D
D
B
A
We have suppressed some of the object/wire labels for readability, since all types can
be inferred from the labeled ones.
Exercise 6.59.
1. What label should be on the input to h?
2. What label should be on the output of 1?
3. What label should be on the fourth output wire of the composite?
‚ô¶
Thus hypergraph categories are general enough to talk about all network-style dia-
grammatic languages, like circuit diagrams.
6.3.3
DeÔ¨Ånition of hypergraph category
We are now ready to deÔ¨Åne hypergraph categories formally. Since the wiring diagrams
for hypergraph categories are just those for symmetric monoidal categories with a few
additional icons, the deÔ¨Ånition is relatively straightforward: we just want a Frobenius
structure on every object. The only coherence condition is that these interact nicely
with the monoidal product.
DeÔ¨Ånition 6.60. A hypergraph category is a symmetric monoidal category (C, I, ‚äó) in
which each object X is equipped with a Frobenius structure (X, ¬µX, Œ¥X, Œ∑X, œµX) such

202
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
that
X ‚äóY
X ‚äóY
X ‚äóY 
X
X
X
Y
Y
Y
X ‚äóY 
X
Y
X ‚äóY
X ‚äóY
X ‚äóY

X
X
X
Y
Y
Y
X ‚äóY
 X
Y
for all objects X, Y, and such that Œ∑I  idI  œµI.
A hypergraph prop is a hypergraph category that is also a prop, e.g. Ob(C)  N, etc.
Example 6.61. For any C with Ô¨Ånite colimits, CospanC is a hypergraph category. The
Frobenius morphisms ¬µX, Œ¥X, Œ∑X, œµX for each object X are constructed using the uni-
versal properties of colimits:
¬µX B
 X + X
[idX,idX]
‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíX
idX
‚Üê‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àíX
Œ∑X B
 ¬ú
!X
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíX
idX
‚Üê‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àíX
Œ¥X B
 X
idX
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíX
[idX,idX]
‚Üê‚àí‚àí‚àí‚àí‚àí‚àíX + X
œµX B
 X
idX
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíX
!X
‚Üê‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí¬ú
Exercise 6.62. By Example 6.61, the category CospanFinSet is a hypergraph category. (In
fact, it is equivalent to a hypergraph prop.) Draw the Frobenius morphisms for the ob-
ject 1 in CospanFinSet using both the function and wiring depictions as in Example 6.46.
‚ô¶
Exercise 6.63.
Using your knowledge of colimits, show that the maps deÔ¨Åned in
Example 6.61 do indeed obey the special law (see DeÔ¨Ånition 6.52).
‚ô¶
Example 6.64. Recall the monoidal category (Corel, ¬ú, ‚äî) from Example 4.61; its objects
are Ô¨Ånite sets and its morphisms are corelations.
Given a Ô¨Ånite set X, deÔ¨Åne the
corelation ¬µX : X ‚äîX ‚ÜíX such that two elements of X ‚äîX ‚äîX are equivalent if and
only if they come from the same underlying element of X. DeÔ¨Åne Œ¥X : X ‚ÜíX ‚äîX in
the same way, and deÔ¨Åne Œ∑X : ¬ú ‚ÜíX and œµX : X ‚Üí¬ú such that no two elements of
X  ¬ú ‚äîX  X ‚äî¬ú are equivalent.
These maps deÔ¨Åne a special commutative Frobenius monoid (X, ¬µX, Œ∑X, Œ¥X, œµX),

6.4. DECORATED COSPANS
203
and in fact give Corel the structure of a hypergraph category.
Example 6.65. The prop of linear relations, which we brieÔ¨Çy mentioned in Exercise 5.84,
is a hypergraph category. In fact, it is a hypergraph category in two ways, by choosing
either the black ‚Äòcopy‚Äô and ‚Äòdiscard‚Äô generators or the white ‚Äòadd‚Äô and ‚Äòzero‚Äô generators
as the Frobenius maps.
We can generalize the construction we gave in Theorem 5.87.
Proposition 6.66. Hypergraph categories are self-dual compact closed categories, if
we deÔ¨Åne the cup and cap to be
B
and
B
Proof. The proof is a straightforward application of the Frobenius and unitality axioms:

(deÔ¨Ånition)

Exercise 6.67!
(Frobenius)

(unitality)
‚ñ°
Exercise 6.67.
Fill in the missing diagram in the proof of Proposition 6.66 using the
equations from Eq. (6.51), their opposites, and Eq. (6.53).
‚ô¶
6.4
Decorated cospans
The goal of this section is to show how we can construct a hypergraph category
whose morphisms are electric circuits. To do this, we Ô¨Årst must introduce the no-
tion of structure-preserving map for symmetric monoidal categories, a generalization
of monoidal monotones known as symmetric monoidal functors. Then we introduce
a general method‚Äîthat of decorated cospans‚Äîfor producing hypergraph categories.
Doing all this will tie up lots of loose ends: colimits, cospans, circuits, and hypergraph
categories.

204
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
6.4.1
Symmetric monoidal functors
Rough DeÔ¨Ånition 6.68. Let (C, IC, ‚äóC) and (D, ID, ‚äóD) be symmetric monoidal cate-
gories. To specify a symmetric monoidal functor (F, œï) between them,
(i) one speciÔ¨Åes a functor F : C ‚ÜíD;
(ii) one speciÔ¨Åes a morphism œïI : ID ‚ÜíF(IC).
(iii) for each c1, c2 ‚ààOb(C), one speciÔ¨Åes a morphism
œïc1,c2 : F(c1) ‚äóD F(c2) ‚ÜíF(c1 ‚äóC c2),
natural in c1 and c2.
We call the various maps œï coherence maps. We require the coherence maps to obey
bookkeeping axioms that ensure they are well behaved with respect to the symmetric
monoidal structures on C and D. If œïI and œïc1,c2 are isomorphisms for all c1, c2, we say
that (F, œï) is strong.
Example 6.69. Consider the power set functor P: Set ‚ÜíSet.
It acts on objects by
sending a set S ‚ààSet to its set of subsets P(S) B {R ‚äÜS}. It acts on morphisms by
sending a function f : S ‚ÜíT to the image map im f : P(S) ‚ÜíP(T), which maps R ‚äÜS
to { f (r) | r ‚ààR} ‚äÜT.
Now consider the symmetric monoidal structure ({1}, √ó) on Set from Example 4.49.
To make P a symmetric monoidal functor, we need to specify a function œïI : {1} ‚Üí
P({1}) and for all sets S and T, a functor œïS,T : P(S)√óP(T) ‚ÜíP(S√óT). One possibility is
to deÔ¨Åne œïI(1) to be the maximal subset {1} ‚äÜ{1}, and given subsets A ‚äÜS and B ‚äÜT,
to deÔ¨Åne œïS,T(A, B) to be the product subset A √ó B ‚äÜS √ó T. With these deÔ¨Ånitions,
(P, œï) is a symmetric monoidal functor.
Exercise 6.70.
Check that the maps œïS,T deÔ¨Åned in Example 6.69 are natural in S and
T. In other words, given f : S ‚ÜíS‚Ä≤ and 1 : T ‚ÜíT‚Ä≤, show that the diagram below
commutes:
P(S) √ó P(T)
P(S √ó T)
P(S‚Ä≤) √ó P(T‚Ä≤)
P(S‚Ä≤ √ó T‚Ä≤)
œïS,T
im f √ó im1
im f √ó1
œïS‚Ä≤,T‚Ä≤
‚ô¶
6.4.2
Decorated cospans
Now that we have brieÔ¨Çy introduced symmetric monoidal functors, we return to the
task at hand: constructing a hypergraph category of circuits. To do so, we introduce
the method of decorated cospans.
Circuits have lots of internal structure, but they also have some external ports‚Äîalso
called ‚Äòterminals‚Äô‚Äîby which to interconnect them with others. Decorated cospans are
ways of discussing exactly that: things with external ports and internal structure.

6.4. DECORATED COSPANS
205
To see how this works, let us start with the following example circuit:
2‚Ñ¶
3F
1‚Ñ¶
1‚Ñ¶
1H
(6.71)
We might formally consider this as a graph on the set of four ports, where each edge
is labeled by a type of circuit component (for example, the top edge would be labeled
as a resistor of resistance 2‚Ñ¶). For this circuit to be a morphism in some category, i.e.
in order to allow for interconnection, we must equip the circuit with some notion of
interface. We do this by marking the ports in the interface using functions from Ô¨Ånite
sets:
A
B
N
2‚Ñ¶
3F
1‚Ñ¶
1‚Ñ¶
1H
(6.72)
Let N be the set of nodes of the circuit. Here the Ô¨Ånite sets A, B, and N are sets
consisting of one, two, and four elements respectively, drawn as points, and the values
of the functions A ‚ÜíN and B ‚ÜíN are indicated by the grey arrows. This forms a
cospan in the category of Ô¨Ånite sets, for which the apex set N has been decorated by our
given circuit.
Suppose given another such decorated cospan with input B
B
C
5‚Ñ¶
8‚Ñ¶
Since the output of the Ô¨Årst equals the input of the second (both are B), we can stick

206
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
them together into a single diagram:
A
N
B
2‚Ñ¶
3F
1‚Ñ¶
1‚Ñ¶
1H
M
C
5‚Ñ¶
8‚Ñ¶
(6.73)
The composition is given by gluing the circuits along the identiÔ¨Åcations speciÔ¨Åed by B,
resulting in the decorated cospan
A
N +B M
C
2‚Ñ¶
3F
1‚Ñ¶
1‚Ñ¶
1H
5‚Ñ¶
8‚Ñ¶
(6.74)
We‚Äôve seen this sort of gluing before when we deÔ¨Åned composition of cospans in
DeÔ¨Ånition 6.45. But now there‚Äôs this whole ‚Äòdecoration‚Äô thing; our goal is to formalize
it.
DeÔ¨Ånition 6.75. Let C be a category with Ô¨Ånite colimits, and (F, œï): (C, +) ‚àí‚Üí(Set, √ó)
be a symmetric monoidal functor. An F-decorated cospan is a pair consisting of a cospan
A
i‚ÜíN
o‚ÜêB in C together with an element s ‚ààF(N).5 We call (F, œï) the decoration
functor and s the decoration.
The intuition here is to use C  FinSet, and, for each object N ‚ààFinSet, the functor
F assigns the set of all legal decorations on a set N of nodes. When you choose an F-
decorated cospan, you choose a set A of left-hand external ports, a set B of right-hand
external ports, each of which maps to a set N of nodes, and you choose one of the
available decorations on N nodes, taken from the set F(N).
So, in our electrical circuit case, the decoration functor F sends a Ô¨Ånite set N to
the set of circuit diagrams‚Äîgraphs whose edges are labeled by resistors, capacitors,
etc.‚Äîthat have N vertices.
Our goal is still to be able to compose such diagrams; so how does that work exactly?
Basically one combines the way cospans are composed with the structures deÔ¨Åning our
decoration functor: namely F and œï.
Let (A
f
‚àí‚ÜíN
1
‚Üê‚àíB, s) and (B
h‚àí‚ÜíP
k‚Üê‚àíC, t) represent decorated cospans.
Their
composite is represented by the composite of the cospans A
f
‚àí‚ÜíN
1
‚Üê‚àíB and B
h‚àí‚ÜíP
k‚Üê‚àíC,
5Just like in DeÔ¨Ånition 6.45, we should technically use equivalence classes of cospans. We will elide
this point to get the bigger idea across. The interested reader should consult Section 6.6.

6.4. DECORATED COSPANS
207
paired with the following element of F(N +B P):
F([ŒπN, ŒπP])(œïN,P(s, t))
(6.76)
That‚Äôs rather compact! We‚Äôll unpack it, in a concrete case, in just a second. But let‚Äôs
record a theorem Ô¨Årst.
Theorem 6.77. Given a category C with Ô¨Ånite colimits and a symmetric monoidal func-
tor (F, œï): (C, +) ‚àí‚Üí(Set, √ó), there is a hypergraph category CospanF whose objects
are the objects of C, and whose morphisms are equivalence classes of F-decorated
cospans.
The symmetric monoidal and hypergraph structures are derived from those on
CospanC.
Exercise 6.78. Suppose you‚Äôre worried that the notation CospanC looks like the notation
CospanF, even though they‚Äôre very diÔ¨Äerent.
An expert tells you ‚Äúthey‚Äôre not so
diÔ¨Äerent; one is a special case of the other. Just use the constant functor F(c) B {‚àó}.‚Äù
What does the expert mean?
‚ô¶
6.4.3
Electric circuits
In order to work with the above abstractions, we will get a bit more precise about the
circuits example and then have a detailed look at how composition works in decorated
cospan categories.
Let‚Äôs build some circuits.
To begin, we‚Äôll need to choose which components we want
in our circuit. This is simply a matter of what‚Äôs in our electrical toolbox. Let‚Äôs say we‚Äôre
carrying some lightbulbs, switches, batteries, and resistors of every possible resistance.
That is, deÔ¨Åne a set
C B {light, switch, battery} ‚äî{x‚Ñ¶| x ‚ààR+}.
To be clear, the‚Ñ¶are just labels; theabovesetisisomorphicto {light, switch, battery}‚äî
R+. But we write C this way to remind us that it consists of circuit components. If we
wanted, we could also add inductors, capacitors, and even elements connecting more
than two ports, like transistors, but let‚Äôs keep things simple for now.
Given our set C, a C-circuit is just a graph (V, A, s, t), where s, t : A ‚ÜíV are the
source and target functions, together with a function ‚Ñì: A ‚ÜíC labeling each edge with
a certain circuit component from C.
For example, we might have the simple case of V  {1, 2}, A  {e}, s(e)  1,
t(e)  2‚Äîso e is an edge from 1 to 2‚Äîand ‚Ñì(e)  3‚Ñ¶. This represents a resistor with
resistance 3‚Ñ¶:
3‚Ñ¶
1
2

208
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
Note that in the formalism we have chosen, we have multiple ways to represent any
circuit, as our representations explicitly choose directions for the edges. The above
resistor could also be represented by the ‚Äòreversed graph‚Äô, with data V  {1, 2}, A  {e},
s(e)  2, t(e)  1, and ‚Ñì(e)  3F.
Exercise 6.79.
Write a tuple (V, A, s, t, ‚Ñì) that represents the circuit in Eq. (6.71).
‚ô¶
A decoration functor for circuits.
We want C-circuits to be our decorations, so let‚Äôs
use them to deÔ¨Åne a decoration functor as in DeÔ¨Ånition 6.75. We‚Äôll call the functor
(Circ, œà). We start by deÔ¨Åning the functor part
Circ: (FinSet, +) ‚àí‚Üí(Set, √ó)
as follows. On objects, simply send a Ô¨Ånite set V to the set of C-circuits:
Circ(V) B {(V, A, s, t, ‚Ñì) | where s, t : A ‚ÜíV, ‚Ñì: E ‚ÜíC}.
On morphisms, Circ sends a function f : V ‚ÜíV‚Ä≤ to the function
Circ( f ): Circ(V) ‚àí‚ÜíCirc(V‚Ä≤);
(V, A, s, t, ‚Ñì) 7‚àí‚Üí V‚Ä≤, A, (s # f ), (t # f ), ‚Ñì
.
This deÔ¨Ånes a functor; let‚Äôs explore it a bit in an exercise.
Exercise 6.80.
To understand this functor better, let c ‚ààCirc(4) be the circuit
3‚Ñ¶
1
2
3
4
and let f : 4 ‚Üí3 be the function
1
2
3
4
1
2
3
Draw a picture of the circuit Circ( f )(c).
‚ô¶
We‚Äôre trying to get a decoration functor (Circ, œà) and so far we have Circ. For the
coherence maps œàV,V‚Ä≤ for Ô¨Ånite sets V, V‚Ä≤, we deÔ¨Åne
œàV,V‚Ä≤ : Circ(V) √ó Circ(V‚Ä≤) ‚àí‚ÜíCirc(V + V‚Ä≤);
 (V, A, s, t, ‚Ñì), (V‚Ä≤, A‚Ä≤, s‚Ä≤, t‚Ä≤, ‚Ñì‚Ä≤)
7‚àí‚Üí(V + V‚Ä≤, A + A‚Ä≤, s + s‚Ä≤, t + t‚Ä≤, [‚Ñì, ‚Ñì‚Ä≤]).
(6.81)
This is simpler than it may look: it takes a circuit on V and a circuit on V‚Ä≤, and just
considers them together as a circuit on the disjoint union of vertices V + V‚Ä≤.
Exercise 6.82.
Suppose we have circuits
b B
and
s B
in Circ(2). Use the deÔ¨Ånition of œàV,V‚Ä≤ from (6.81) to Ô¨Ågure out what 4-vertex circuit
œà2,2(b, s) ‚ààCirc(2 + 2)  Circ(4) should be, and draw a picture.
‚ô¶

6.4. DECORATED COSPANS
209
Open circuits using decorated cospans.
From the above data, just a monoidal functor
(Circ, œà): (FinSet, +) ‚Üí(Set, √ó), we can construct our promised hypergraph category
of circuits!
Our notation for this category is CospanCirc. Following Theorem 6.77, the objects
of this category are the same as the objects of FinSet, just Ô¨Ånite sets. We‚Äôll reprise
our notation from the introduction and Example 6.42, and draw these Ô¨Ånite sets as
collections of white circles ‚ó¶. For example, we‚Äôll represent the object 2 of CospanCirc as
two white circles:
These white circles mark interface points of an open circuit.
More interesting than the objects, however, are the morphisms in CospanCirc. These
are open circuits. By Theorem 6.77, a morphism m ‚Üín is a Circ-decorated cospan:
that is, cospan m ‚Üíp ‚Üên together with an element c of Circ(p). As an example,
consider the cospan 1
i1‚àí‚Üí2
i2
‚Üê‚àí1 where i1(1)  1 and i2(1)  2, equipped with the
battery element of Circ(2) connecting node 1 and node 2. We‚Äôll depict this as follows:
(6.83)
Exercise 6.84.
Morphisms of CospanCirc are Circ-decorated cospans, as deÔ¨Åned in
DeÔ¨Ånition 6.75. This means (6.83) depicts a cospan together with a decoration, which is
some C-circuit (V, A, s, t, ‚Ñì) ‚ààCirc(2). What is it?
‚ô¶
Let‚Äôs now see how the hypergraph operations in CospanCirc can be used to construct
electric circuits.
Composition in CospanCirc.
First we‚Äôll consider composition. Consider the following
decorated cospan from 1 to 1:
Since this and the circuit in (6.83) are both morphisms 1 ‚Üí1, we may compose them
to get another morphism 1 ‚Üí1. How do we do this? There are two parts: to get
the new cospan, we simply compose the cospans of our two circuits, and to get the
new decoration, we use the formula Circ([ŒπN, ŒπP])(œàN,P(s, t)) from (6.76). Again, this is
rather compact! Let‚Äôs unpack it together.
We‚Äôll start with the cospans. The cospans we wish to compose are
and

210
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
(We simply ignore the decorations for now.) If we pushout over the common set 1  {‚ó¶},
we obtain the pushout square
(6.85)
This means the composite cospan is
In the meantime, we already had you start us oÔ¨Äunpacking the formula for the
new decoration. You told us what the map œà2,2 does in Exercise 6.82. It takes the two
decorations, both circuits in Circ(2), and turns them into the single, disjoint circuit
in Circ(4). So this is what the œàN,P(s, t) part means. What does the [ŒπN, ŒπP] mean? Recall
this is the copairing of the pushout maps, as described in Examples 6.14 and 6.25. In our
case, the relevant pushout square is given by (6.85), and [ŒπN, ŒπP] is in fact the function
f from Exercise 6.80! This means the decoration on the composite cospan is
Putting this all together, the composite circuit is
Exercise 6.86.
Refer back to the example at the beginning of Section 6.4.2. In particular,
consider the composition of circuits in Eq. (6.73).
Express the two circuits in this
diagram as morphisms in CospanCirc, and compute their composite. Does it match the
picture in Eq. (6.74)?
‚ô¶
Monoidal products in CospanCirc.
Monoidal products in CospanCirc are much sim-
pler than composition. On objects, we again just work as in FinSet: we take the disjoint
union of Ô¨Ånite sets. Morphisms again have a cospan, and a decoration. For cospans,
we again just work in CospanFinSet: given two cospans A ‚ÜíM ‚ÜêB and C ‚ÜíN ‚ÜêD,
we take their coproduct cospan A + C ‚ÜíM + N ‚ÜêB + D. And for decorations, we
use the map œàM,N : Circ(M) √ó Circ(N) ‚ÜíCirc(M + N). So, for example, suppose we
want to take the monoidal product of the open circuits

6.5. OPERADS AND THEIR ALGEBRAS
211
and
The result is given by stacking them. In other words, their monoidal product is:
(6.87)
Easy, right?
We leave you to do two compositions of your own.
Exercise 6.88.
Write x for the open circuit in (6.87). Also deÔ¨Åne cospans Œ∑: 0 ‚Üí2 and
Œ∑: 2 ‚Üí0 as follows:
Œ∑ B
¬ú
¬ú
: œµ
where each of these are decorated by the empty circuit (1, ¬ú, !, !, !) ‚ààCirc(1).6
Compute the composite Œ∑ # x # œµ in CospanCirc. This is a morphism 0 ‚Üí0; we call
such things closed circuits.
‚ô¶
6.5
Operads and their algebras
In Theorem 6.77 we described how decorating cospans builds a hypergraph category
from a symmetric monoidal functor. We then explored how that works in the case that
the decoration functor is somehow ‚Äúall circuit graphs on a set of nodes‚Äù.
In this book, we have devoted a great deal of attention to diÔ¨Äerent sorts of composi-
tional theories, from monoidal preorders to compact closed categories to hypergraph
categories. Yet for an application you someday have in mind, it may be the case that
none of these theories suÔ¨Éce. You need a diÔ¨Äerent structure, customized to a particular
situation. For example in [VSL15] the authors wanted to compose continuous dynam-
ical systems with control-theoretic properties and realized that in order for feedback
to make sense, the wiring diagrams could not involve what they called ‚Äòpassing wires‚Äô.
So to close our discussion of compositional structures, we want to quickly sketch
something we can use as a sort of meta-compositional structure, known as an operad.
We saw in Section 6.4.3 that we can build electric circuits from a symmetric monoidal
functor FinSet ‚ÜíSet. Similarly we‚Äôll see that we can build examples of new algebraic
structures from operad functors O ‚ÜíSet.
6.5.1
Operads design wiring diagrams
Understanding that circuits are morphisms in a hypergraph category is useful: it means
we can bring the machinery of category theory to bear on understanding electrical

212
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
circuits. For example, we can build functors that express the compositionality of circuit
semantics, i.e. how to derive the functionality of the whole from the functionality and
interaction pattern of the parts. Or we can use the category-theoretic foundation to
relate circuits to other sorts of network systems, such as signal Ô¨Çow graphs. Finally,
the basic coherence theorems for monoidal categories and compact closed categories
tell us that wiring diagrams give sound and complete reasoning in these settings.
However, one perhaps unsatisfying result is that the hypergraph category intro-
duces artifacts like the domain and codomain of a circuit, which are not inherent to the
structure of circuits or their composition. Circuits just have a single boundary inter-
face, not ‚Äòdomains‚Äô and ‚Äòcodomains‚Äô. This is not to say the above model is not useful:
in many applications, a vector space does not have a preferred basis, but it is often
useful to pick one so that we may use matrices (or signal Ô¨Çow graphs!). But it would
be worthwhile to have a category-theoretic model that more directly represents the
compositional structure of circuits. In general, we want the category-theoretic model
to Ô¨Åt our desired application like a glove. Let us quickly sketch how this can be done.
Let‚Äôs return to wiring diagrams for a second. We saw that wiring diagrams for
hypergraph categories basically look like this:
f
1
h
k
A
B
C
D
F
E
D
(6.89)
Note that if you had a box with A and B on the left and D on the right, you could plug
the above diagram right inside it, and get a new open circuit. This is the basic move of
operads.
But before we explain this, let‚Äôs get where we said we wanted to go: to a model
where there aren‚Äôt ports on the left and ports on the right, there are just ports. We want
a more succinct model of composition for circuit diagrams; something that looks more
like this:
f
h
1
k
B
C
A
D
E
F
D
(6.90)

6.5. OPERADS AND THEIR ALGEBRAS
213
Do you see how diagrams Eq. (6.89) and Eq. (6.90) are actually exactly the same in
terms of interconnection pattern? The only diÔ¨Äerence is that the latter does not have
left/right distinction: we have lost exactly what we wanted to lose.
The cost is that the ‚Äòboxes‚Äô f , 1, h, k in Eq. (6.90) no longer have a left/right dis-
tinction; they‚Äôre just circles now. That wouldn‚Äôt be bad except that it means they can
no longer represent morphisms in a category‚Äîlike they used to above, in Eq. (6.89)‚Äî
because morphisms in a category by deÔ¨Ånition have a domain and codomain. Our
new circles have no such distinction. So now we need a whole new way to think about
‚Äòboxes‚Äô categorically: if they‚Äôre no longer morphisms in a category, what are they? The
answer is found in the theory of operads.
In understanding operads, we will Ô¨Ånd we need to navigate one of the level shifts
that we Ô¨Årst discussed in Section 1.4.5. Notice that for decorated cospans, we deÔ¨Åne
a hypergraph category using a symmetric monoidal functor.
This is reminiscent of
our brief discussion of algebraic theories in Section 5.4.2, where we deÔ¨Åned something
called the theory of monoids as a prop M, and deÔ¨Åne monoids using functors M ‚ÜíSet;
see Remark 5.74. In the same way, we can view the category CospanFinSet as some sort
of ‚Äòtheory of hypergraph categories‚Äô, and so deÔ¨Åne hypergraph categories as functors
CospanFinSet ‚ÜíSet.
So that‚Äôs the idea. An operad O will deÔ¨Åne a theory or grammar of composition, and
operad functors O ‚ÜíSet, known as O-algebras, will describe particular applications
that obey that grammar.
Rough DeÔ¨Ånition 6.91. To specify an operad O,
(i) one speciÔ¨Åes a collection T, whose elements are called types;
(ii) for each tuple (t1, . . . , tn, t) of types, one speciÔ¨Åes a set O(t1, . . . , tn; t), whose
elements are called operations of arity (t1, . . . , tn; t);
(iii) for each pair of tuples (s1, . . . , sm, ti) and (t1, . . . , tn, t), one speciÔ¨Åes a function
‚ó¶i : O(s1, . . . , sm; ti) √ó O(t1, . . . , tn; t) ‚ÜíO(t1, . . . , ti‚àí1, s1, . . . , sm, ti+1, . . . , tn; t);
called substitution; and
(iv) for each type t, one speciÔ¨Åes an operation idt ‚ààO(t; t) called the identity operation.
These must obey generalized identity and associativity laws.7
Let‚Äôs ignore types for a moment and think about what this structure models. The
intuition is that an operad consists of, for each n, a set of operations of arity n‚Äîthat is,
all the operations that accept n arguments. If we take an operation f of arity m, and
plug the output into the ith argument of an operation 1 of arity n, we should get an
operation of arity m + n ‚àí1: we have m arguments to Ô¨Åll in m, and the remaining n ‚àí1
6As usual ! denotes the unique function, in this case from the empty set to the relevant codomain.
7Often what we call types are called objects or colors, what we call operations are called morphisms,
what we call substitution is called composition, and what we call operads are called multicategories. A
formal deÔ¨Ånition can be found in [Lei04].

214
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
arguments to Ô¨Åll in 1. Which operation of arity m+n‚àí1 do we get? This is described by
the substitution function ‚ó¶i, which says we obtain the operation f ‚ó¶i 1 ‚ààO(m + n ‚àí1).
The coherence conditions say that these functions ‚ó¶i capture the following intuitive
picture:
{
The types then allow us to specify the, well, types of the arguments‚Äîinputs‚Äîthat
each function takes. So making tea is a 2-ary operation, an operation with arity 2,
because it takes in two things. To make tea you need some warm water, and you need
some tea leaves.
Example 6.92. Context-free grammars are to operads as graphs are to categories. Let‚Äôs
sketch what this means. First, a context-free grammar is a way of describing a particular
set of ‚Äòsyntactic categories‚Äô that can be formed from a set of symbols. For example, in
English we have syntactic categories like nouns, determiners, adjectives, verbs, noun
phrases, prepositional phrases, sentences, etc. The symbols are words, e.g. cat, dog,
the, chases.
To deÔ¨Åne a context-free grammar on some alphabet, one speciÔ¨Åes some production
rules, which say how to form an entity in some syntactic category from a bunch of
entities in other syntactic categories. For example, we can form a noun phrase from
a determiner (the), an adjective (happy), and a noun (boy). Context free grammars
are important in both linguistics and computer science. In the former, they‚Äôre a basic
way to talk about the structure of sentences in natural languages. In the latter, they‚Äôre
crucial when designing parsers for programming languages.
So just like graphs present free categories, context-free grammars present free op-
erads. This idea was Ô¨Årst noticed in [HMP98].
6.5.2
Operads from symmetric monoidal categories
We will see in DeÔ¨Ånition 6.97 that a large class of operads come from symmetric
monoidal categories. Before we explain this, we give a couple of examples. Perhaps
the most important operad is that of Set.
Example 6.93. The operad Set of sets has
(i) Sets X as types.
(ii) Functions X1 √ó ¬∑ ¬∑ ¬∑ √ó Xn ‚ÜíY as operations of arity (X1, . . . , Xn; Y).

6.5. OPERADS AND THEIR ALGEBRAS
215
(iii) Substitution deÔ¨Åned by
(1 ‚ó¶i f )(x1, . . . , xi‚àí1, w1, . . . , wm, xi+1, . . . , xn)
 1 x1, . . . , xi‚àí1, f (w1, . . . , wm), xi+1, . . . , xn

where f ‚ààSet(W1, . . . , Wm; Xi), 1 ‚ààSet(X1, . . . , Xn; Y), and hence 1 ‚ó¶i f is a
function
(1 ‚ó¶i f ): X1 √ó ¬∑ ¬∑ ¬∑ √ó Xi‚àí1 √ó W1 √ó ¬∑ ¬∑ ¬∑ √ó Wm √ó Xi+1 √ó ¬∑ ¬∑ ¬∑ √ó Xn ‚àí‚ÜíY
(iv) Identities idX ‚ààSet(X; X) are given by the identity function idX : X ‚ÜíX.
Next we give an example that reminds us what all this operad stuÔ¨Äwas for: wiring
diagrams.
Example 6.94. The operad Cospan of Ô¨Ånite-set cospans has
(i) Natural numbers a ‚ààN as types.
(ii) Cospans a1 + ¬∑ ¬∑ ¬∑ + an ‚Üíp ‚Üêb of Ô¨Ånite sets as operations of arity (a1, . . . , an; b).
(iii) Substitution deÔ¨Åned by pushout.
(iv) Identities ida ‚ààSet(a; a) just given by the identity cospan a
ida
‚àí‚àí‚Üía
ida
‚Üê‚àí‚àía.
This is the operadic analogue of the monoidal category (CospanFinSet, 0, +).
We can depict operations in this operad using diagrams like we drew above. For
example, here‚Äôs a picture of an operation:
f
h
1
k
(6.95)
This is an operation of arity (3, 3, 4, 2; 3). Why? The circles marked f and 1 have 3
ports, h has 4 ports, k has 2 ports, and the outer circle has 3 ports: 3, 3, 4, 2; 3.
So how exactly is Eq. (6.95) a morphism in this operad? Well a morphism of this
arity is, by (ii), a cospan 3 + 3 + 4 + 2
a‚àí‚Üíp
b‚Üê‚àí3. In the diagram above, the apex p is the
set 7, because there are 7 nodes ‚Ä¢ in the diagram. The function a sends each port on
one of the small circles to the node it connects to, and the function b sends each port of
the outer circle to the node it connects to.
We are able to depict each operation in the operad Cospan as a wiring diagram.
It is often helpful to think of operads as describing a wiring diagram grammar. The

216
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
substitution operation of the operad signiÔ¨Åes inserting one wiring diagram into a circle
or box in another wiring diagram.
Exercise 6.96.
1. Consider the following cospan f ‚ààCospan(2, 2; 2):
Draw it as a wiring diagram with two inner circles, each with two ports, and one
outer circle with two ports.
2. Draw the wiring diagram correspondingtothefollowingcospan 1 ‚ààCospan(2, 2, 2; 0):
¬ú
3. Compute the cospan 1 ‚ó¶1 f . What is its arity?
4. Draw the cospan 1 ‚ó¶1 f . Do you see it as substitution?
‚ô¶
We can turn any symmetric monoidal category into an operad in a way that gener-
alizes the above two examples.
DeÔ¨Ånition 6.97. For any symmetric monoidal category (C, I, ‚äó), there is an operad OC,
called the operad underlying C, deÔ¨Åned as having:
(i) Ob(C) as types.
(ii) morphisms C1 ‚äó¬∑ ¬∑ ¬∑ ‚äóCn ‚ÜíD in C as the operations of arity (C1, . . . , Cn; D).
(iii) substitution is deÔ¨Åned by
( f ‚ó¶i 1) B f ‚ó¶(id, . . . , id, 1, id, . . . , id)
(iv) identities ida ‚ààOC(a; a) deÔ¨Åned by ida.
We can also turn any monoidal functor into what‚Äôs called an operad functor.
6.5.3
The operad for hypergraph props
An operad functor takes the types of one operad to the types of another, and then the op-
erations of the Ô¨Årst to the operations of the second in a way that respects this.

6.5. OPERADS AND THEIR ALGEBRAS
217
Rough DeÔ¨Ånition 6.98. Suppose given two operads O and P with type collections T
and U respectively. To specify an operad functor F : O ‚ÜíP,
(i) one speciÔ¨Åes a function f : T ‚ÜíU.
(ii) For all arities (t1, . . . , tn; t) in O, one speciÔ¨Åes a function
F : O(t1, . . . , tn; t) ‚ÜíP( f (t1), . . . , f (tn); f (t))
such that composition and identities are preserved.
Just as set-valued functors C ‚ÜíSet from any category C are of particular interest‚Äî
we saw them as database instances in Chapter 3‚Äîso to are Set-valued functors O ‚ÜíSet
from any operad O.
DeÔ¨Ånition 6.99. An algebra for an operad O is an operad functor F : O ‚ÜíSet.
We can think of functors O ‚ÜíSet as deÔ¨Åning a set of possible ways to Ô¨Åll the boxes in
a wiring diagram. Indeed, each box in a wiring diagram represents a type t of the given
operad O and an algebra F : O ‚ÜíSet will take a type t and return a set F(t) of Ô¨Ållers
for box t. Moreover, given an operation (i.e., a wiring diagram) f ‚ààO(t1, . . . , tn; t), we
get a function F( f ) that takes an element of each set F(ti), and returns an element of
F(t). For example, it takes n circuits with interface t1, . . . , tn respectively, and returns
a circuit with boundary t.
Example 6.100. For electric circuits, the types are again Ô¨Ånite sets, T  Ob(FinSet),
where each Ô¨Ånite set t ‚ààT corresponds to a cell with t ports. Just as before, we have a
set Circ(t) of Ô¨Ållers, namely the set of electric circuits with that t-marked terminals. As
an operad algebra, Circ: Cospan ‚ÜíSet transforms wiring diagrams like this one
œï B
into formulas that build a new circuit from a bunch of existing ones. In the above-
drawn case, we would get a morphism Circ(œï) ‚ààSet(Circ(2), Circ(2), Circ(2); Circ(0)),
i.e. a function
Circ(œï): Circ(2) √ó Circ(2) √ó Circ(2) ‚ÜíCirc(0).
We could apply this function to the three elements of Circ(2) shown here

218
CHAPTER 6. CIRCUITS: HYPERGRAPH CATEGORIES AND OPERADS
and the result would be the closed circuit from the beginning of the chapter:
This is reminiscent of the story for decorated cospans: gluing Ô¨Ållers together to form
hypergraph categories. An advantage of the decorated cospan construction is that one
obtains an explicit category (where morphisms have domains and codomains and can
hence be composed associatively), equipped with Frobenius structures that allow us to
get around the strictures of domains and codomains. The operad perspective has other
advantages.
First, whereas decorated cospans can produce only some hypergraph
categories, Cospan-algebras can produce any hypergraph category.
Proposition 6.101. There is an equivalence between Cospan-algebras and hypergraph
props.
Another advantage of using operads is that one can vary the operad itself, from
Cospan to something similar (like the operad of ‚Äòcobordisms‚Äô), and get slightly diÔ¨Äerent
compositionality rules.
In fact, operads‚Äîwith the additional complexity in their deÔ¨Ånition‚Äîcan be cus-
tomized even more than all compositional structures deÔ¨Åned so far. For example, we
can deÔ¨Åne operads of wiring diagrams where the wiring diagrams must obey precise
conditions far more speciÔ¨Åc than the constraints of a category, such as requiring that
the diagram itself has no wires that pass straight through it. In fact, operads are strong
enough to deÔ¨Åne themselves: roughly speaking, there is an operad for operads: the
category of operads is equivalent to the category of algebras for a certain operad [Lei04,
Example 2.2.23]. While operads can, of course, be generalized again, they conclude
our march through an informal hierarchy of compositional structures, from preorders
to categories to monoidal categories to operads.
6.6
Summary and further reading
This chapter began with a detailed exposition of colimits in the category of sets; as we
saw, these colimits describe ways of joining or interconnecting sets. Our second way
of talking about interconnection was the use of Frobenius monoids and hypergraph
categories; we saw these two themes come together in the idea of a decorated cospans.
The decorated cospan construction uses a certain type of structured functor to construct
a certain type of structured category. More generally, we might be interested in other
types of structured category, or other compositional structure. To address this, we
brieÔ¨Çy saw how these ideas Ô¨Åt into the theory of operads.

6.6. SUMMARY AND FURTHER READING
219
Colimits are a fundamental concept in category theory. For more on colimits, one
might refer to any of the introductory category theory textbooks we mentioned in
Section 3.6.
Special commutative Frobenius monoids and hypergraph categories were Ô¨Årst de-
Ô¨Åned, under the names ‚Äòseparable commutative Frobenius algebra‚Äô and ‚Äòwell-supported
compact closed category‚Äô, by Carboni and Walters [CW87; Car91]. The use of deco-
rated cospans to construct them is detailed in [Fon15; Fon18; Fon16]. The application
to networks of passive linear systems, such as certain electrical circuits, is discussed in
[BF15], while further applications, such as to Markov processes and chemistry can be
found in [BFP16; BP17]. For another interesting application of hypergraph categories,
we recommend the pixel array method for approximating solutions to nonlinear equa-
tions [Spi+16]. The story of this chapter is Ô¨Çeshed out in a couple of recent, more
technical papers [FS18b; FS18a].
Operads were introduced by May to describe compositional structures arising in
algebraic topology [May72]; Leinster has written a great book on the subject [Lei04].
More recently, with collaborators author-David has discussed using operads in applied
mathematics, to model composition of structures in logic, databases, and dynamical
systems [RS13; Spi13; VSL15].


Chapter 7
Logic of behavior:
Sheaves, toposes, and internal
languages
7.1
How can we prove our machine is safe?
Imagine you are trying to design a system of interacting components. You wouldn‚Äôt be
doing this if you didn‚Äôt have a goal in mind: you want the system to do something, to
behave in a certain way. In other words, you want to restrict its possibilities to a smaller
set: you want the car to remain on the road, you want the temperature to remain in
a particular range, you want the bridge to be safe for trucks to pass. Out of all the
possibilities, your system should only permit some.
Since your system is made of components that interact in speciÔ¨Åed ways, the possible
behavior of the whole‚Äîin any environment‚Äîis determined by the possible behaviors
of each of its components in their local environments, together with the precise way in
which they interact.1 In this chapter, we will discuss a logic wherein one can describe
general types of behavior that occur over time, and prove properties of a larger-scale
system from the properties and interaction patterns of its components.
For example, suppose we want an autonomous vehicle to maintain a distance of
some safe ‚ààR from other objects. To do so, several components must interact: a
sensor that approximates the real distance by an internal variable S‚Ä≤, a controller that
uses S‚Ä≤ to decide what action A to take, and a motor that moves the vehicle with an
1 The well-known concept of emergence is not about possibilities, it is about prediction. Predicting
the behavior of a system given predictions of its components is notoriously hard. The behavior of a
double pendulum is chaotic‚Äîmeaning extremely sensitive to initial conditions‚Äîwhereas those of the two
component pendulums are not. However, the set of possibilities for the double pendulum is completely
understood: it is the set of possible angular positions and velocities of both arms. When we speak of a
machine‚Äôs properties in this chapter, we always mean the guarantees on its behaviors, not the probabilities
involved, though the latter would certainly be an interesting thing to contemplate.
221

222
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
acceleration based on A. This in turn aÔ¨Äects the real distance S, so there is a feedback
loop.
Consider the following model diagram:
sensor
controller
motor
S‚Ä≤
A
S
S
(7.1)
In the diagram shown, the distance S is exposed by the exterior interface. This just
means we imagine S as being a variable that other components of a larger system may
want to interact with. We could have exposed no variables (making it a closed system)
or we could have exposed A and/or S‚Ä≤ as well.
In order for the system to ensure S ‚â•safe, we need each of the components to
ensure a property of its own.
But what are these components, ‚Äòsensor, controller,
motor‚Äô, and what do they do?
One way to think about any of the components is to open it up and see how it is
put together; with a detailed study we may be able to say what it will do. For example,
just as S was exposed in the diagram above, one could imagine opening up the ‚Äòsensor‚Äô
component box in Eq. (7.1) and seeing an interaction between subcomponents
radar
sonar
processor
sensor
S
S‚Ä≤
This ability to zoom in and see a single unit as being composed of others is important
for design. But at the end of the day, you eventually need to stop diving down and
simply use the properties of the components in front of you to prove properties of
the composed system. Have no fear: everything we do in this chapter will be fully
compositional, i.e. compatible with opening up lower-level subsystems and using the
fractal-like nature of composition. However at a given time, your job is to design the
system at a given level, taking the component properties of lower-level systems as
given.
We will think of each component in terms of the relationship it maintains (through
time) between the changing values on its ports. ‚ÄúWhenever I see a Ô¨Çash, I will increase
pressure on the button‚Äù: this is a relationship I maintain through time between the
changing values on my eye port and my Ô¨Ånger port. We will make this more precise
soon, but Ô¨Çeshing out the situation in Eq. (7.1) should help. The sensor maintains a
relationship between S and S‚Ä≤, e.g. that the real distance S and its internal representation
S‚Ä≤ diÔ¨Äer by no more than 5cm. The controller maintains a relationship between S‚Ä≤ and
the action signal A, e.g. that if at any time S < safe, then within one second it will

7.1. HOW CAN WE PROVE OUR MACHINE IS SAFE?
223
emit the signal A  go. The motor maintains a relationship between A and S, e.g. that
A dictates the second derivative of S by the formula
 (A  go) ‚áí√úS > 1
‚àß (A  stop) ‚áí√úS  0
.
(7.2)
If we want to prove properties of the whole interacting system, then the relation-
ships maintained by each component need to be written in a formal logical language,
something like what we saw in Eq. (7.2). From that basis, we can use standard proof
techniques to combine properties of subsystems into properties of the whole. This is
our objective in the present chapter.
We have said how component systems, wired together in some arrangement, create
larger-scale systems. We have also said that, given the wiring arrangement, the be-
havioral properties of the component systems dictate the behavioral properties of the
whole. But what exactly are behavioral properties?
In this chapter, we want to give a formal language and semantics for a very gen-
eral notion of behavior. Mathematics is itself a formal language; the usual style of
mathematical modeling is to use any piece of this vast language at any time and for
any reason. One uses ‚Äúhuman understanding‚Äù to ensure that the diÔ¨Äerent models
are Ô¨Åtting together in an appropriate way when diÔ¨Äerent systems are combined. The
present work diÔ¨Äers in that we want to Ô¨Ånd a domain-speciÔ¨Åc language for modeling
behavior, any sort of behavior, and nothing but behavior. Unlike in the wide world of
math, we want a setting where the only things that can be discussed are behaviors.
For this, we will construct what is called a topos, which is a special kind of category.
Our topos, let‚Äôs call it BT, will have behavior types‚Äîroughly speaking, sets whose
elements can change through time‚Äîas its objects. An amazing fact about toposes2 is
that they come with an internal language that looks very much like the usual formal
language of mathematics itself. Thus one can deÔ¨Åne graphs, groups, topological spaces,
etc. in any topos. But in BT, what we call graphs will actually be graphs that change
through time, and similarly what we call groups and spaces will actually be groups
and spaces that change through time.
The topos BT not only has an internal language, but also a mathematical semantics
using the notion of sheaves. Technically, a sheaf is a certain sort of functor, but one can
imagine it as a space of possibilities, varying in a controlled way; in our case it will be
a space of possible behaviors varying in a certain notion of time. Every property we
prove in our logic of behavior types will have meaning in this category of sheaves.
When discussing systems and components‚Äîsuch as sensors, controllers, motors,
etc.‚Äîwe mentioned behavior types; these will be the objects in the topos BT. Every
wire in the picture below will stand for a behavior type, and every box X will stand for
a behavioral property, a relation that X maintains between the changing values on its
2The plural of topos is often written topoi, rather than toposes. This seems a bit fancy for our taste.
As Johnstone suggests in [Joh77], we might ask those who ‚Äúpersist in talking about topoi whether, when
they go out for a ramble on a cold day, they carry supplies of hot tea with them in thermoi.‚Äù It‚Äôs all in
good fun; either term is perfectly reasonable and well-accepted.

224
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
ports.
sensor
controller
motor
S‚Ä≤
A
A
S
For example we could imagine that
‚Ä¢ S (wire): The behavior of S over a time-interval [a, b] is that of all continuous
real-valued functions [a, b] ‚ÜíR.
‚Ä¢ A (wire): The behavior of A over a time-interval [a, b] is all piecewise constant
functions, taking values in the Ô¨Ånite set such as {go, stop}.
‚Ä¢ controller (box): the relation {(S‚Ä≤, A) | Eq. (7.2)}, i.e. all behavioral pairs (S‚Ä≤, A)
that conform to what we said our controller is supposed to do in Eq. (7.2).
7.2
The category Set as an exemplar topos
We want to think about a very abstract sort of thing, called a topos, because we will
see that behavior types form a topos. To get started, we begin with one of the easiest
toposes to think about, namely the topos Set of sets. In this section we will discuss
commonalities between sets and every other topos. We will go into some details about
the category of sets, so as to give intuition for other toposes. In particular, we‚Äôll pay
careful attention to the logic of sets, because we eventually want to understand the
logic of behaviors.
Indeed, logic and sets are closely related. For example, the logical statement‚Äîmore
formally known as a predicate‚Äîlikes_cats deÔ¨Ånes a function from the set P of people
to the set B  {false, true} of truth values, where Brendan ‚ààP maps to true because
he likes cats whereas Ursula ‚ààP maps to false because she does not. Alternatively,
likes_cats also deÔ¨Ånes a subset of P, consisting of exactly the people that do like cats
{p ‚ààP | likes_cats(p)}.
In terms of these subsets, logical operations correspond to set operations, e.g. AND
corresponds to intersection: indeed, the set of people for (mapped to true by) the pred-
icate likes_cats_AND_likes_dogs is equal to the intersection of the set for likes_cats
and the set for likes_dogs.
We saw in Chapter 3 that such operations, which are examples of database queries,
can be described in terms of limits and colimits in Set. Indeed, the category Set has
many such structures and properties, which together make logic possible in that setting.
In this section we want to identify these properties, and show how logical operations
can be deÔ¨Åned using them.
Why would we want to abstractly Ô¨Ånd such structures and properties? In the next
section, we‚Äôll start our search for other categories that also have them. Such categories,
called toposes, will be Set-like enough to do logic, but have much more complex and

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
225
interesting semantics. Indeed, we will discuss one whose logic allows us to reason not
about properties of sets, but about behavioral properties of very general machines.
7.2.1
Set-like properties enjoyed by any topos
Although we will not prove it in this book, toposes are categories that are similar to
Set in many ways. Here are some facts that are true of any topos E:
1. E has all limits,
2. E has all colimits,
3. E is cartesian closed,
4. E has epi-mono factorizations,
5. E has a subobject classiÔ¨Åer 1
true
‚àí‚àí‚àí‚Üí‚Ñ¶.
In particular, since Set is a topos, all of the above facts are true for E  Set. Our Ô¨Årst
goal is to brieÔ¨Çy review these concepts, focusing most on the subobject classiÔ¨Åer.
Limits and colimits.
We discussed limits and colimits brieÔ¨Çy in Section 3.4.2, but
the basic idea is that one can make new objects from old by taking products, using
equations to deÔ¨Åne subobjects, forming disjoint unions, and taking quotients.object
0. One of the most important types of limit (resp. colimit) is that of pullbacks (resp.
pushouts); see Example 3.99 and DeÔ¨Ånition 6.19. For our work below, we‚Äôll need to
know a touch more about pullbacks than we have discussed so far, so let‚Äôs begin there.
Suppose that C is a category and consider the diagrams below:
A
B
C
D
E
F
‚åü
A
B
C
D
E
F
‚åü
In the left-hand square, the corner symbol ‚åüunambiguously means that the square
(B, C, E, F) is a pullback. But in the right-hand square, does the corner symbol mean
that (A, B, D, E) is a pullback or that (A, C, D, F) is a pullback? It‚Äôs ambiguous, but as
we next show, it becomes unambiguous if the right-hand square is a pullback.
Proposition 7.3. In the commutative diagram below, suppose that the (B, C, B‚Ä≤, C‚Ä≤)
square is a pullback:
A
B
C
A‚Ä≤
B‚Ä≤
C‚Ä≤
‚åü
‚åü
Then the (A, B, A‚Ä≤, B‚Ä≤) square is a pullback iÔ¨Äthe (A, C, A‚Ä≤, C‚Ä≤) rectangle is a pullback.
Exercise 7.4.
Prove Proposition 7.3 using the deÔ¨Ånition of limit from Section 3.4.2.
‚ô¶

226
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Epi-mono factorizations.
The abbreviation ‚Äòepi‚Äô stands for epimorphism, and the ab-
breviation ‚Äòmono‚Äô stands for monomorphism. Epimorphisms are maps that act like
surjections, and monomorphisms are maps that act like injections.3 We can deÔ¨Åne
them formally in terms of pushouts and pullbacks.
DeÔ¨Ånition 7.5. Let C be a category, and let f : A ‚ÜíB be a morphism. It is called a
monomorphism (resp. epimorphism) if the square to the left is a pullback (resp. the square
to the right is a pushout):
A
A
A
B
A
B
B
B
idA
idA
f
f
f
idB
f
‚åü
idB
‚åú
Exercise 7.6.
Show that in Set, monomorphisms are just injections:
1. Show that if f is a monomorphism then it is injective.
2. Show that if f : A ‚ÜíB is injective then it is a monomorphism.
‚ô¶
Exercise 7.7.
1. Show that the pullback of an isomorphism along any morphism is an isomor-
phism. That is, suppose that i : B‚Ä≤ ‚ÜíB is an isomorphism and f : A ‚ÜíB is any
morphism. Show that i‚Ä≤ is an isomorphism, in the following diagram:
A‚Ä≤
B‚Ä≤
A
B
f ‚Ä≤
i‚Ä≤ 
i

f
‚åü
2. Show that for any map f : A ‚ÜíB, the square shown is a pullback:
A
B
A
B
f
f
‚åü
‚ô¶
Exercise 7.8.
Suppose the following diagram is a pullback in a category C:
A‚Ä≤
A
B‚Ä≤
B
1
f ‚Ä≤
f
h
‚åü
Use Proposition 7.3 and Exercise 7.7 to show that if f is a monomorphism, then so is
f ‚Ä≤.
‚ô¶
3 Surjections are sometimes called ‚Äòonto‚Äô and injections are sometimes called ‚Äòone-to-one‚Äô, hence the
Greek preÔ¨Åxes epi and mono.

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
227
Now that we have deÔ¨Åned epimorphisms and monomorphisms, we can say what
epi-mono factorizations are. We say that a morphism f : C ‚ÜíD in E has an epi-mono
factorization if it has an ‚Äòimage‚Äô; that is, there is an object im( f ), an epimorphism
C ‚Ü†im( f ), and a monomorphism im( f ) ‚Ü£D, whose composite is f .
In Set, epimorphisms are surjections and monomorphisms are injections. Every
function f : C ‚ÜíD may be factored as a surjective function onto its image im( f ) 
{ f (c) | c ‚ààC}, followed by the inclusion of this image into the codomain D. Moreover,
this factorization is unique up to isomorphism.
Exercise 7.9.
Factor the following function f : 3 ‚Üí3 as an epimorphism followed by a
monomorphism.
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚ô¶
This is the case in any topos E: for any morphism f : c ‚Üíd, there exists an
epimorphism e and a monomorphism m such that f  (e # m) is their composite.
Cartesian closed.
A category C being cartesian closed means that C has a symmetric
monoidal structure given by products, and it is monoidal closed with respect to this.
(We previously saw monoidal closure in DeÔ¨Ånition 2.79 (for preorders) and Proposi-
tion 4.60, as a corollary of compact closure.) Slightly more down-to-earth, cartesian
closure means that for any two objects C, D ‚ààC, there is a ‚Äòhom-object‚Äô DC ‚ààC and a
natural isomorphism for any A ‚ààC:
C(A √ó C, D)  C(A, DC)
(7.10)
Think of it this way. Suppose you‚Äôre A and I‚Äôm C, and we‚Äôre interacting through
some game f (‚àí, ‚àí): A √ó C ‚ÜíD: for whatever action a ‚ààA that you take and action
c ‚ààC that I take, f (a, c) is some value in D. Since you‚Äôre self-centered but loving, you
think of this situation as though you‚Äôre creating a game experience for me. When you
do a, you make a game f (a, ‚àí): C ‚ÜíD for me alone. In the formalism, DC represents
the set of games for me. So now you‚Äôve transformed a two-player game, valued in D,
into a one-player game, you‚Äôre the player, valued in... one player games valued in D.
This transformation is invertible‚Äîyou can switch your point of view at will‚Äîand it‚Äôs
called currying. This is the content of Example 3.72.
Exercise 7.11.
Let V  (V, ‚â§, I, ‚äó) be a (unital, commutative) quantale‚Äîsee DeÔ¨Åni-
tion 2.90‚Äîand suppose it satisÔ¨Åes the following for all v, w, x ‚ààV:
‚Ä¢ v ‚â§I,
‚Ä¢ v ‚äów ‚â§v and v ‚äów ‚â§w, and
‚Ä¢ if x ‚â§v and x ‚â§w then x ‚â§v ‚äów.
1. Show that V is a cartesian closed category, in fact a cartesian closed preorder.
2. Can every cartesian closed preorder be obtained in this way?
‚ô¶

228
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Subobject classiÔ¨Åer.
The concept of a subobject classiÔ¨Åer requires more attention,
because its existence has huge consequences for a category C. In particular, it creates
the setting for a rich system of higher order logic to exist inside C; it does so by providing
some things called ‚Äòtruth values‚Äô. The higher order logic manifests in its fully glory
when C has Ô¨Ånite limits and is cartesian closed, because these facts give rise to the
logical operations on truth values.4 In particular, the higher order logic exists in any
topos.
We will explain subobject classiÔ¨Åers in as much detail as we can; in fact, it will be
our subject for the rest of Section 7.2.
7.2.2
The subobject classiÔ¨Åer
Before giving the deÔ¨Ånition of subobject classiÔ¨Åers, recall that monomorphisms in Set
are injections, and any injection X ‚Ü£Y is isomorphic to a subset of Y. This gives
a simple and useful way to conceptualize monomorphisms into Y when reading the
following deÔ¨Ånition: it will do no harm to think of them as subobjects of Y.
DeÔ¨Ånition 7.12. Let E be a category with Ô¨Ånite limits, i.e. with pullbacks and a ter-
minal object 1. A subobject classiÔ¨Åer in E consists of an object ‚Ñ¶‚ààE, together with a
monomorphism true: 1 ‚Üí‚Ñ¶, satisfying the following property: for any objects X and
Y and monomorphism m : X ‚Ü£Y in E, there is a unique morphism ‚åúm‚åù: Y ‚Üí‚Ñ¶such
that the diagram on the left of Eq. (7.13) is a pullback in E:
X
1
Y
‚Ñ¶
!
m
true
‚åúm‚åù
‚åü
{Y | p}
1
Y
‚Ñ¶
!
true
p
‚åü
(7.13)
We refer to ‚åúm‚åùas the characteristic map of m, or we say that ‚åúm‚åùclassiÔ¨Åes m. Conversely,
given any map p : Y ‚Üí‚Ñ¶, we denote the pullback of true as on the right of Eq. (7.13).
A predicate on Y is a morphism Y ‚Üí‚Ñ¶.
DeÔ¨Ånition 7.12 is a bit diÔ¨Écult to get one‚Äôs mind around, partly because it is hard
to imagine its consequences. It is like a superdense nugget from outer space, and
through scientiÔ¨Åc explorations in the latter half of the 20th century, we have found that
it brings super powers to whichever categories possess it. We will explain some of the
consequences below, but very quickly, the idea is the following.
When a category has a subobject classiÔ¨Åer, it provides a translator, turning subobjects
of any object Y into maps from that Y to the particular object ‚Ñ¶.
Pullback of the
4A category that has Ô¨Ånite limits, is cartesian closed, and has a subobject classiÔ¨Åer is called an elementary
topos. We will not discuss these further, but they are the most general notion of topos in ordinary category
theory. When someone says topos, you might ask ‚ÄúGrothendieck topos or elementary topos?,‚Äù because
there does not seem to be widespread agreement on which is the default.

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
229
monomorphism true: 1 ‚Üí‚Ñ¶provides a translator going back, turning maps Y ‚Üí‚Ñ¶
into subobjects of Y. We can replace our fantasy of the superdense nugget with a
slightly more reÔ¨Åned story: ‚Äúany object Y understands itself‚Äîits parts and the logic of
how they Ô¨Åt together‚Äîby asking questions of the oracle ‚Ñ¶, looking for what‚Äôs true.‚Äù
Or to fully be precise but dry, ‚Äúsubobjects of Y are classiÔ¨Åed by predicates on Y.‚Äù
Let‚Äôs move from stories and slogans to concrete facts.
The subobject classiÔ¨Åer in Set.
Since Set is a topos, it has a subobject classiÔ¨Åer. It
will be a set with supposedly wonderful properties; what set is it?
The subobject classiÔ¨Åer in Set is the set of booleans,
‚Ñ¶Set B B  {true, false}.
(7.14)
So in Set, the truth values are true and false.
By deÔ¨Ånition (Def. 7.12), the subobject classiÔ¨Åer comes equipped with a morphism,
generically called true: 1 ‚Üí‚Ñ¶; in the case of Set it is played by the function 1 ‚Üí
{true, false} that sends 1 to true. In other words, the morphism true is aptly named
in this case.
For sets, monomorphism just means injection, as we mentioned above. So DeÔ¨Åni-
tion 7.12 says that for any injective function m : X ‚Ü£Y between sets, we are supposed
to be able to Ô¨Ånd a characteristic function ‚åúm‚åù: Y ‚Üí{true, false} with some sort of
pullback property. We propose the following deÔ¨Ånition of ‚åúm‚åù:
‚åúm‚åù(y) B
(
true
if m(x)  y for some x ‚ààX
false
otherwise
In other words, if we think of X as a subobject of Y, then we make ‚åúm‚åù(y) equal to
true iÔ¨Äy ‚ààX.
In particular, the subobject classiÔ¨Åer property turns subsets X ‚äÜY into functions
p : Y ‚ÜíB, and vice versa. How it works is encoded in DeÔ¨Ånition 7.12, but the basic
idea is that X will be the set of all things in Y that p sends to true:
X  {y ‚ààY | p(y)  true}.
(7.15)
This might help explain our abstract notation {Y | p} in Eq. (7.13).
Exercise 7.16.
Let X  N  {0, 1, 2, . . .} and Y  Z  {. . . , ‚àí1, 0, 1, 2, . . .}; we have
X ‚äÜY, so consider it as a monomorphism m : X ‚Ü£Y. It has a characteristic function
‚åúm‚åù: Y ‚ÜíB, as in DeÔ¨Ånition 7.12.
1. What is ‚åúm‚åù(‚àí5) ‚ààB?
2. What is ‚åúm‚åù(0) ‚ààB?
‚ô¶
Exercise 7.17.
1. Consider the identity function idN : N ‚ÜíN. It is an injection, so it has a charac-
teristic function ‚åúidN‚åù: N ‚ÜíB. Give a concrete description of ‚åúidN‚åù, i.e. its exact
value for each natural number n ‚ààN.

230
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
2. Consider the unique function !N : ¬ú ‚ÜíN from the empty set. Give a concrete
description of ‚åú!N‚åù: N ‚ÜíB.
‚ô¶
7.2.3
Logic in the topos Set
As we said above, the subobject classiÔ¨Åer of any topos E gives the setting in which to
do logic. Before we explain a bit about how topos logic works in general, we continue
to work concretely by focusing on logic in the topos Set.
Obtaining the AND operation.
Consider the function 1 ‚ÜíB √ó B picking out the
element (true, true). This is a monomorphism, so it deÔ¨Ånes a characteristic function
‚åú(true, true)‚åù: B√óB ‚ÜíB. What function is it? By Eq. (7.15) the only element of B√óB
that can be sent to true is (true, true). Thus ‚åú(true, true)‚åù(P, Q) ‚ààB must be given
by the following truth table
P
Q
‚åú(true, true)‚åù(P, Q)
true
true
true
true
false
false
false
true
false
false
false
false
This is exactly the truth table for the AND of P and Q, i.e. for P ‚àßQ. In other words,
‚åú(true, true)‚åù ‚àß. Note that this deÔ¨Ånes ‚àßas a function ‚àß: B √ó B ‚ÜíB, and we use
the usual inÔ¨Åx notation x ‚àßy B ‚àß(x, y).
Obtaining the OR operation.
Let‚Äôs go backwards this time. The truth table for the
OR of P and Q, i.e. that of the function ‚à®: B √ó B ‚ÜíB deÔ¨Åning OR, is:
P
Q
P ‚à®Q
true
true
true
true
false
true
false
true
true
false
false
false
(7.18)
If we wanted to obtain this function as the characteristic function ‚åúm‚åùof some subset
m : X ‚äÜB √ó B, what subset would X be? By Eq. (7.15), X should be the set of y ‚ààY
that are sent to true. Thus m is the characteristic map for the three element subset
X  {(true, true), (true, false), (false, true)} ‚äÜB √ó B.
To prepare for later generalization of this idea in any topos, we want a way of thinking
of X only in terms of properties listed at the beginning of Section 7.2.1. In fact, one can
think of X as the union of {true} √ó B and B √ó {true}‚Äîa colimit of limits involving the
subobject classiÔ¨Åer and terminal object. This description will construct an analogous
subobject of ‚Ñ¶√ó ‚Ñ¶, and hence classify a map ‚Ñ¶√ó ‚Ñ¶‚Üí‚Ñ¶, in any topos E.

7.2. THE CATEGORY Set AS AN EXEMPLAR TOPOS
231
Exercise 7.19.
Every boolean has a negation, ¬¨false  true and ¬¨true  false. The
function ¬¨: B ‚ÜíB is the characteristic function of some thing, (*?*).
1. What sort of thing should (*?*) be? For example, should ¬¨ be the characteristic
function of an object? A topos? A morphism? A subobject? A pullback diagram?
2. Now that you know the sort of thing (*?*) is, which thing of that sort is it?
‚ô¶
Exercise 7.20.
Given two booleans P, Q, deÔ¨Åne P ‚áíQ to mean P  (P ‚àßQ).
1. Write down the truth table for the statement P  (P ‚àßQ):
P
Q
P ‚àßQ
P  (P ‚àßQ)
true
true
?
?
true
false
?
?
false
true
?
?
false
false
?
?
2. If you already have an idea what P ‚áíQ should mean, does it agree with the last
column of table above?
3. What is the characteristic function m : B √ó B ‚ÜíB for P ‚áíQ?
4. What subobject does m classify?
‚ô¶
Exercise 7.21.
Consider the sets E B {n ‚ààN | n is even}, P B {n ‚ààN | n is prime},
and T B {n ‚ààN | n ‚â•10}. Each is a subset of N, so deÔ¨Ånes a function N ‚ÜíB.
1. What is ‚åúE‚åù(17)?
2. What is ‚åúP‚åù(17)?
3. What is ‚åúT‚åù(17)?
4. Name the smallest three elements in the set classiÔ¨Åed by (‚åúE‚åù‚àß‚åúP‚åù) ‚à®‚åúT‚åù.
‚ô¶
Review.
Let‚Äôs take stock of where we are and where we‚Äôre going. In Section 7.1, we
set out our goal of proving properties about behavior, and we said that topos theory
is a good mathematical setting for doing that. We are now at the end of Section 7.2,
which was about Set as an examplar topos. What happened?
In Section 7.2.1, we talked about properties of Set that are enjoyed by any topos:
limits and colimits, cartesian closure, epi-mono factorizations, and subobject classiÔ¨Åers.
Then in Section 7.2.2 we launched into thinking about the subobject classiÔ¨Åer in general
and in the speciÔ¨Åc topos Set, where it is the set B of booleans because any subset of
Y is classiÔ¨Åed by a speciÔ¨Åc predicate p : Y ‚ÜíB. Finally, in Section 7.2.3 we discussed
how to understand logic in terms of ‚Ñ¶: there are various maps ‚àß, ‚à®, ‚áí: ‚Ñ¶√ó ‚Ñ¶‚Üí‚Ñ¶
and ¬¨: ‚Ñ¶‚Üí‚Ñ¶etc., which serve as logical connectives. These are operations on truth
values.
We have talked a lot about toposes, but we‚Äôve only seen one so far: the category of
sets. But we‚Äôve actually seen more without knowing it: the category C-Inst of instances
on any database schema from DeÔ¨Ånition 3.60 is a topos. Such toposes are called presheaf
toposes and are fundamental, but we will focus on sheaf toposes, because our topos of
behavior types will be a sheaf topos.

232
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Sheaves are fascinating, but highly abstract mathematical objects. They are not for
the faint of mathematical heart (those who are faint of physical heart are welcome to
proceed).
7.3
Sheaves
Sheaf theory began before category theory, e.g. in the form of something called ‚Äúlocal
coeÔ¨Écient systems for homology groups.‚Äù However its modern formulation in terms
of functors and sites is due to Grothendieck, who also invented toposes.
The basic idea is that rather than study spaces, we should study what happens on
spaces. A space is merely the ‚Äòsite‚Äô at which things happen. For example, if we think
of the plane R2 as a space, we might examine only points and regions in it. But if we
think of R2 as a site where things happen, then we might think of things like weather
systems throughout the plane, or sand dunes, or trajectories and Ô¨Çows of material.
There are many sorts of things that can happen on a space, and these are the sheaves:
a sheaf on a space is roughly ‚Äúa sort of thing that can happen on the space.‚Äù If we want
to think about points or regions from the sheaf perspective, we would consider them
as diÔ¨Äerent points of view on what‚Äôs happening. That is, it‚Äôs all about what happens
on a space: the parts of the space are just perspectives from which to watch the show.
This is reminiscent of databases. The schema of a database is not the interesting
part; the data is what‚Äôs interesting. To be clear, the schema of a database is a site‚Äîit‚Äôs
acting like the space‚Äîand the category of all instances on it is a topos. In general, we
can think of any small category C as a site; the corresponding topos is the category of
functors Cop ‚ÜíSet.5 Such functors are called presheaves on C.
Did you notice that we just introduced a huge class of toposes? For any category C,
we said there is a topos of presheaves on it. So before we go on to sheaves, let‚Äôs discuss
this preliminary topic of presheaves. We will begin to develop some terminology and
ways of thinking that will later generalize to sheaves.
7.3.1
Presheaves
Recall the deÔ¨Ånition of functor and natural transformation from Section 3.3. Presheaves
are just functors, but they have special terminology that leads us to think about them
in a certain geometric way.
DeÔ¨Ånition 7.22. Let C be a small category. A presheaf P on C is a functor P : Cop ‚ÜíSet.
To each object c ‚ààC, we refer to the set P(c) as the set of sections of P over c. To each
morphism f : c‚Ä≤ ‚Üíc, we refer to the function P( f ): P(c) ‚ÜíP(c‚Ä≤) as the restriction map
along f . For any section s ‚ààP(c), we may denote P( f )(s) ‚ààP(c‚Ä≤), i.e. its restriction
along f , by s

f .
5The category of functors C ‚ÜíSet is also a topos: use Cop as the deÔ¨Åning site.

7.3. SHEAVES
233
If P and Q are presheaves, a morphism Œ±: P ‚ÜíQ between them is a natural trans-
formation of functors
Cop
Set.
P
Q
Œ±
Example 7.23. Let ArShp be the category shown below:
ArShp B
Vertex
‚Ä¢
Pure Arrow
‚Ä¢
src
tgt
The reason we call our category ArShp is that we can imagine of it as an ‚Äòarrow shape.‚Äô
Pure ArrowB
VertexB
src
tgt
(7.24)
A presheaf on ArShp is a functor I : ArShpop ‚ÜíSet, which is a database instance on
ArShpop. Note that ArShpop is what we called Gr in Section 3.3.5; there we showed
that database instances on Gr‚Äîi.e. presheaves on ArShp‚Äî are just directed graphs,
e.g.
P B
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
: ArShpop ‚ÜíSet
Thinking of presheaves on any category C, it often makes sense to imagine the
objects of C as shapes of some sort, and the morphisms of C as continuous maps
between shapes, just like we did for the arrow shape in Eq. (7.24). In that context, one
can think of a presheaf P as a kind of lego construction: P is built out of the shapes in C,
connected together using the morphisms in C. In the case where C is the arrow shape,
a presheaf is a graph. So this would say that a graph is a sort of lego construction,
built out of vertices and arrows connected together using the inclusion of a vertex as
the source or target of an arrow. Can you see it?
This statement can be made pretty precise; though we cannot go through it here, the
above lego idea is summarized by the formal statement that ‚Äúthe category of presheaves
on C is the free colimit completion of C.‚Äù Ask a friendly neighborhood category theorist
for details.
However one thinks of presheaves‚Äîintermsoflegoassembliesordatabaseinstances‚Äî
they‚Äôre relatively straightforward. The diÔ¨Äerence between presheaves and sheaves is

234
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
that sheaves take into account some sort of ‚Äòcovering information.‚Äô The trivial notion
of covering is to say that every object covers itself and nothing more; if one uses this
trivial covering, presheaves and sheaves are the same thing. In our behavioral context
we will need a non-trivial notion of covering, so sheaves and presheaves will be slightly
diÔ¨Äerent. Our next goal is to understand sheaves on a topological space.
7.3.2
Topological spaces
We said in Section 7.3 that, rather than study spaces, we consider spaces as mere ‚Äòsites‚Äô
on which things happen. We also said the things that can happen on a space are called
sheaves, and always form a type of category called a topos. To deÔ¨Åne a topos of sheaves,
we must start with the site on which they exist.
Sites are very abstract mathematical objects, and we will not make them precise in
this book. However, one of the easiest sorts of sites to think about are those coming
from topological spaces: every topological space naturally has the structure of a site.
We‚Äôve talked about spaces for a while without making them precise; let‚Äôs do so now.
DeÔ¨Ånition 7.25. Let X be a set, and let P(X)  {U ‚äÜX} denote its set of subsets. A
topology on X is a subset Op ‚äÜP(X), elements of which we call open sets,6 satisfying the
following conditions:
(a) Whole set: the subset X ‚äÜX is open, i.e. X ‚ààOp.
(b) Binary intersections: if U, V ‚ààOp then (U ‚à©V) ‚ààOp.
(c) Arbitrary unions: if I is a set and if we are given an open set Ui ‚ààOp for each i,
then their union is also open,   √ê
i‚ààI Ui

‚ààOp. We interpret the particular case
where I  ¬ú to mean that the empty set is open: ¬ú ‚ààOp.
If U  √ê
i‚ààI Ui, we say that (Ui)i‚ààI covers U.
A pair (X, Op), where X is a set and Op is a topology on X, is called a topological
space.
A continuous function between topological spaces (X, OpX) and (Y, OpY) is a function
f : X ‚ÜíY such that for every U ‚ààOpY, the preimage f ‚àí1(U) is in OpX.
At the very end of Section 7.3.1 we mentioned how sheaves diÔ¨Äer from presheaves
in that they take into account ‚Äòcovering information.‚Äô The notion of covering an open
set by a union of other open sets was deÔ¨Åned in DeÔ¨Ånition 7.25, and it will come into
play when we deÔ¨Åne sheaves in DeÔ¨Ånition 7.35.
Example 7.26. The usual topology Op on R2 is based on ‚Äòœµ-balls.‚Äô For any œµ ‚ààR with
œµ > 0, and any point p  (x, y) ‚ààR2, deÔ¨Åne the œµ-ball centered at p to be:
B(p; œµ) B {p‚Ä≤ ‚ààR2 | d(p, p‚Ä≤) < œµ}7
6In other words, we refer to a subset U ‚äÜX as open if U ‚ààOp.

7.3. SHEAVES
235
In other words, B(x, y; œµ) is the set of all points within œµ of (x, y).
For an arbitrary subset U ‚äÜR2, we call it open and put it in Op if, for every (x, y) ‚ààU
there exists a (small enough) œµ > 0 such that B(x, y; œµ) ‚äÜU.
x
y
(x, y)
œµ
an œµ-ball centered at p  (x, y)
U
an open set U ‚äÜR2, a point p  (x, y) ‚ààU,
and an œµ-ball B(x, y; œµ) ‚äÜU.
The same idea works if we replace R2 with any other metric space X (DeÔ¨Ånition 2.51):
it can be considered as a topological space where the open sets are subsets U such that
for any p ‚ààU there is an œµ-ball centered at p and contained in U. So every metric space
can be considered as a topological space.
Exercise 7.27.
Consider the set R. It is a metric space with d(x1, x2) B |x1 ‚àíx2|.
1. What is the 1-dimensional analogue of œµ-balls as found in Example 7.26? That is,
for each x ‚ààR, deÔ¨Åne B(x, œµ).
2. When is an arbitrary subset U ‚äÜR called open, in analogy with Example 7.26?
3. Find three open sets U1, U2, and U in R, such that (Ui)i‚àà{1,2} covers U.
4. Find an open set U and a collection (Ui)i‚ààI of opens sets where I is inÔ¨Ånite, such
that (Ui)i‚ààI covers U.
‚ô¶
Example 7.28. For any set X, there is a ‚Äòcoarsest‚Äô topology, having as few open sets as
possible: Opcrse  (¬ú, X). There is also a ‚ÄòÔ¨Ånest‚Äô topology, having as many open sets as
possible: OpÔ¨Åne  P(X). The latter, (X, P(X)) is called the discrete space on the set X.
Exercise 7.29.
1. Verify that for any set X, what we called Opcrse in Example 7.28 really is a topology,
i.e. satisÔ¨Åes the conditions of DeÔ¨Ånition 7.25.
2. Verify also that OpÔ¨Åne really is a topology.
3. Show that if (X, P(X)) is discrete and (Y, OpY) is any topological space, then every
function X ‚ÜíY is continuous.
‚ô¶
Example 7.30. There are four topologies possible on X  {1, 2}. Two are Opcrse and
7Here, d((x, y), (x‚Ä≤, y‚Ä≤)) B
p
(x ‚àíx‚Ä≤)2 + (y ‚àíy‚Ä≤)2 is the usual ‚ÄòEuclidean distance‚Äô between two points.
One can generalize d to any metric.

236
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
OpÔ¨Åne from Example 7.28. The other two are:
Op1 B {¬ú, {1}, X}
and
Op2 B {¬ú, {2}, X}
The two topological spaces ({1, 2}, Op1) and ({1, 2}, Op2) are isomorphic; either one
can be called the Sierpinski space.
The open sets of a topological space form a preorder.
Given a topological space
(X, Op), the set Op has the structure of a preorder using the subset relation, (Op, ‚äÜ).
It is reÔ¨Çexive because U ‚äÜU for any U ‚ààOp, and it is transitive because if U ‚äÜV and
V ‚äÜW then U ‚äÜW.
Recall from Section 3.2.3 that we can regard any preorder, and hence Op, as a
category: its objects are the open sets U and for any U, V the set of morphisms Op(U, V)
is empty if U Ã∏‚äÜV and it has one element if U ‚äÜV.
Exercise 7.31.
Recall the Sierpinski space, say (X, Op1) from Example 7.30.
1. Write down the Hasse diagram for its preorder of opens.
2. Write down all the covers.
‚ô¶
Exercise 7.32.
Given any topological space (X, Op), any subset Y ‚äÜX can be given the
subspace topology, call it Op?‚à©Y. This topology deÔ¨Ånes any A ‚äÜY to be open, A ‚ààOp?‚à©Y,
if there is an open set B ‚ààOp such that A  B ‚à©Y.
1. Find a B ‚ààOp that shows that the whole set Y is open, i.e. Y ‚ààOp?‚à©Y.
2. Show that Op?‚à©Y is a topology in the sense of DeÔ¨Ånition 7.25.8
3. Show that the inclusion function Y ,‚ÜíX is a continuous function.
‚ô¶
Remark 7.33. Suppose (X, Op) is a topological space, and consider the preorder (Op, ‚äÜ)
of open sets.
It turns out that (Op, ‚äÜ, X, ‚à©) is always a quantale in the sense of
DeÔ¨Ånition 2.79. We will not need this fact, but we invite the reader to think about
it a bit in Exercise 7.34.
Exercise 7.34.
In Sections 2.3.2 and 2.3.3 we discussed how Bool-categories are pre-
orders and Cost-categories are Lawvere metric spaces, and in Section 2.3.4 we imagined
interpretations of V-categories for other quantales V.
If (X, Op) is a topological space and V the corresponding quantale as in Remark 7.33,
how might we imagine a V-category?
‚ô¶
7.3.3
Sheaves on topological spaces
To summarize where we are, a topological space (X, Op) is a set X together with a bunch
of subsets we call ‚Äòopen‚Äô; these open subsets form a preorder‚Äîand hence category‚Äî
denoted Op. Sheaves on X will be presheaves on Op with a special property, aptly
named the ‚Äòsheaf condition.‚Äô
8Hint 1: for any set I, collection of sets (Ui)i‚ààI with Ui ‚äÜX, and set V ‚äÜX, one has (√ê
i‚ààI Ui) ‚à©V 
√ê
i‚ààI(Ui ‚à©V). Hint 2: for any U, V, W ‚äÜX, one has (U ‚à©W) ‚à©(V ‚à©W)  (U ‚à©V) ‚à©W.

7.3. SHEAVES
237
Recall the terminology and notation for presheaves: a presheaf on Op is a functor
P : Opop ‚ÜíSet. Thus to every open set U ‚ààOp we have a set P(U), called the set
of sections over U, and to every inclusion of open sets V ‚äÜU we have a function
P(U) ‚ÜíP(V) called the restriction. If s ‚ààP(U) is a section over U, we may denote its
restriction to V by s

V. Recall that we say a collection of open sets (Ui)i‚ààI covers an open
set U if U  √ê
i‚ààI Ui.
We are now ready to give the following deÔ¨Ånition, which comes in several waves:
we Ô¨Årst deÔ¨Åne matching families, then gluing, then sheaf condition, then sheaf, and
Ô¨Ånally the category of sheaves.
DeÔ¨Ånition 7.35. Let (X, Op) be a topological space, and let P : Opop ‚ÜíSet be a
presheaf on Op.
Let (Ui)i‚ààI be a collection of open sets Ui ‚ààOp covering U. A matching family (si)i‚ààI
of P-sections over (Ui)i‚ààI consists of a section si ‚ààP(Ui) for each i ‚ààI, such that for every
i, j ‚ààI we have
si

Ui‚à©Uj  sj

Ui‚à©Uj.
Given a matching family (si)i‚ààI for the cover U  √ê
i‚ààI Ui, we say that s ‚ààP(U) is a
gluing, or glued section, of the matching family if s

Ui  si holds for all i ‚ààI.
If there exists a unique gluing s ‚ààP(U) for every matching family (si)i‚ààI, we say that
P satisÔ¨Åes the sheaf condition for the cover U  √ê
i‚ààI Ui. If P satisÔ¨Åes the sheaf condition
for every cover, we say that P is a sheaf on (X, Op).
Thus a sheaf is just a presheaf satisfying the sheaf condition for every open cover.
If P and Q are sheaves, then a morphism f : P ‚ÜíQ between these sheaves is just a
morphism‚Äîthat is, a natural transformation‚Äîbetween their underlying presheaves.
We denote by Shv(X, Op) the category of sheaves on X.
The category of sheaves on X is a topos, but we‚Äôll get to that.
Example 7.36. Here is a funny‚Äîbut very important‚Äîspecial case to which the notion
of matching family applies. We do not give this example for intuition, but because (to
emphasize) it‚Äôs an important and easy-to-miss case. Just like the sum of no numbers
is 0 and the product of no numbers is 1, the union of no sets is the empty set. Thus if
we take U  ¬ú ‚äÜX and I  ¬ú, then the empty collection of subsets (one for each i ‚ààI,
of which there are none) covers U. In this case the empty tuple () counts a matching
family of sections, and it is the only matching family for the empty cover of the empty
set.
In other words, in order for a presheaf P : Opop ‚ÜíSet to be a sheaf, a necessary (but
rarely suÔ¨Écient) condition is that P(¬ú)  {()}, i.e. P(¬ú) must be a set with one element.
Extended example: sections of a function.
This example is for intuition, and gives a
case where the ‚Äòsection‚Äô and ‚Äòrestriction‚Äô terminology are easy to visualize.

238
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Consider the function f : X ‚ÜíY shown below, where each element of X is sent to
the element of Y immediately below it. For example, f (a1)  f (a2)  a, f (b1)  b, and
so on.
‚Ä¢
a
‚Ä¢
b
‚Ä¢
c
‚Ä¢
d
‚Ä¢
e
Y B
‚Ä¢
a1
‚Ä¢
a2
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
‚Ä¢
c1
‚Ä¢
e1
‚Ä¢
e2
X B
f
(7.37)
For each point y ‚ààY, the preimage set f ‚àí1(y) ‚äÜX above it is often called the Ô¨Åber over
y. Note that diÔ¨Äerent f ‚Äôs would arrange the eight elements of X diÔ¨Äerently over Y:
elements of Y would have diÔ¨Äerent Ô¨Åbers.
Exercise 7.38.
Consider the function f : X ‚ÜíY shown in Eq. (7.37).
1. What is the Ô¨Åber of f over a?
2. What is the Ô¨Åber of f over c?
3. What is the Ô¨Åber of f over d?
4. Gave an example of a function f ‚Ä≤: X ‚ÜíY for which every Ô¨Åber has either one or
two elements.
‚ô¶
Let‚Äôs consider X and Y as discrete topological spaces, so every subset is open, and
f is automatically continuous (see Exercise 7.29). We will think of f as an arrangement
of X over Y, in terms of Ô¨Åbers as above, and use it to build a sheaf on Y. To do this,
we begin by building a presheaf‚Äîi.e. a functor Sec f : Op(Y)op ‚ÜíSet‚Äîand then we‚Äôll
prove it‚Äôs a sheaf.
DeÔ¨Åne the presheaf Sec f on an arbitrary subset U ‚äÜY by:
Sec f (U) B {s : U ‚ÜíX | (s # f )(u)  u for all u ‚ààU}.
One might describe Sec f (U) as the set of all ways to pick a ‚Äòcross-section‚Äô of the f
arrangement over U. That is, an element s ‚ààSec f (U) is a choice of one element per
Ô¨Åber over U.
As an example, let‚Äôs say U  {a, b}. How many such s‚Äôs are there in Sec f (U)? To

7.3. SHEAVES
239
answer this, let‚Äôs clip the picture (7.37) and look only at the relevant part:
‚Ä¢a
‚Ä¢b
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
s1
‚Ä¢a
‚Ä¢b
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
s2
‚Ä¢a
‚Ä¢b
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
s3
‚Ä¢a
‚Ä¢b
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
s4
‚Ä¢a
‚Ä¢b
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
s5
‚Ä¢a
‚Ä¢b
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
s6
(7.39)
Looking at the picture (7.39), do you see how we get all cross-sections of f over U?
Exercise 7.40.
Refer to Eq. (7.37).
1. Let V1  {a, b, c}. Draw all the sections over it, i.e. all elements of Sec f (V1), as
we did in Eq. (7.39).
2. Let V2  {a, b, c, d}. Again draw all the sections, Sec f (V2).
3. Let V3  {a, b, d, e}. How many sections (elements of Sec f (V3)) are there?
‚ô¶
By now you should understand the sections of Sec f (U) for various U ‚äÜX. This is
Sec f on objects, so you are half way to understanding Sec f as a presheaf. That is, as
a presheaf, Sec f also includes a restriction maps for every subset V ‚äÜU. Luckily, the
restriction maps are easy: if V ‚äÜU, say V  {a} and U  {a, b}, then given a section s
as in Eq. (7.39), we get a section over V by ‚Äòrestricting‚Äô our attention to what s does on
{a}.
‚Ä¢a
‚Ä¢
‚Ä¢
‚Ä¢a
‚Ä¢
‚Ä¢
s1

V  s2

V  s3

V
s4

V  s5

V  s6

V
(7.41)
Exercise 7.42.
1. Write out the sets of sections Sec f ({a, b, c}) and Sec f ({a, c}).
2. Draw lines from the Ô¨Årst to the second to indicate the restriction map.
‚ô¶
Now we have understood Sec f as a presheaf; we next explain how to see that it
is a sheaf, i.e. that it satisÔ¨Åes the sheaf condition for every cover. To understand the
sheaf condition, consider the set U1  {a, b} and U2  {b, e}. These cover the set
U  {a, b, e}  U1 ‚à™U2. By DeÔ¨Ånition 7.35, a matching family for this cover consists of
a section over U1 and a section over U2 that agree on the overlap set, U1 ‚à©U2  {b}.

240
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
So consider s1 ‚ààSec f (U1) and s2 ‚ààSec f (U2) shown below.
‚Ä¢
a
‚Ä¢
b
‚Ä¢
a1
‚Ä¢
a2
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
11
‚Ä¢
b
‚Ä¢
e
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
‚Ä¢
e1
‚Ä¢
e2
12
(7.43)
Since sections 11 and 12 agree on the overlap‚Äîthey both send b to b2‚Äîthe two sections
shown in Eq. (7.43) can be glued to form a single section over U  {a, b, e}:
‚Ä¢
a
‚Ä¢
b
‚Ä¢
e
‚Ä¢
a1
‚Ä¢
a2
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
‚Ä¢
e1
‚Ä¢
e2
glued section
Exercise 7.44.
Again let U1  {a, b} and U2  {b, e}, so the overlap is U1 ‚à©U2  {b}.
1. Find a section s1 ‚ààSec f (U1) and a section s2 ‚ààSec f (U2) that do not agree on the
overlap.
2. For your answer (s1, s2) in part 1, can you Ô¨Ånd a section s ‚ààSec f (U1 ‚à™U2) such
that s

U1  s1 and s

U2  s2?
3. Find a section h1 ‚ààSec f (U1) and a section h2 ‚ààSec f (U2) that do agree on the
overlap, but which are diÔ¨Äerent than our choice in Eq. (7.43).
4. Can you Ô¨Ånd a section h ‚ààSec f (U1 ‚à™U2) such that h

U1  h1 and h

U2  h2?
‚ô¶
Other examples of sheaves.
The extended example above generalizes to any contin-
uous function f : X ‚ÜíY between topological spaces.
Example 7.45. Let f : (X, OpX) ‚Üí(Y, OpY) be a continuous function. Consider the
functor Sec f : Opop
Y ‚ÜíSet given by
Sec f (U) B {1 : U ‚ÜíX | 1 is continuous and (1 # f )(u)  u for all u ‚ààU},

7.3. SHEAVES
241
The morphisms of OpY are inclusions V ‚äÜU. Given 1 : U ‚ÜíX and V ‚äÜU, what we
call the restriction of 1 to V is the usual thing we mean by restriction, the same as it
was in Eq. (7.41). One can again check that Sec f is a sheaf.
Example 7.46. A nice example of a sheaf on a space M is that of vector Ô¨Åelds on M. If
you calculate the wind velocity at every point on Earth, you will have what‚Äôs called a
vector Ô¨Åeld on Earth. If you know the wind velocity at every point in Afghanistan and
I know the wind velocity at every point in Pakistan, and our calculations agree around
the border, then we can glue our information together to get the wind velocity over the
union of the two countries. All possible wind velocity Ô¨Åelds over all possible open sets
of the Earth‚Äôs surface together form the sheaf of vector Ô¨Åelds.
Let‚Äôs say this a bit more formally. A manifold M‚Äîyou can just imagine a sphere
such as the Earth‚Äôs surface‚Äîalways has something called a tangent bundle. It is a
space TM whose points are pairs (m, v), where m ‚ààM is a point in the manifold and
v is a tangent vector emanating from it. Here‚Äôs a picture of one tangent plane‚Äîall the
tangent vectors emanating from some Ô¨Åxed point‚Äîon a sphere:
m
v
M B
‚äÜTM
The tangent bundle TM includes the whole tangent plane shown above‚Äîincluding
the three vectors drawn on it‚Äîas well as the tangent plane at every other point on the
sphere.
The tangent bundle TM on a manifold M comes with a continuous map œÄ: TM ‚Üí
M back down to the manifold, sending (m, v) 7‚Üím. One might say that œÄ ‚Äúforgets the
tangent vector and just remembers the point it emanated from.‚Äù By Example 7.45, œÄ
deÔ¨Ånes a sheaf SecœÄ. It could be called the sheaf of ‚Äòtangent vector sections on M‚Äô, but
its usual name is the sheaf of vector Ô¨Åelds on M. This is what we were describing when
we spoke of the sheaf of wind velocities on Earth, above. Given an open subset U ‚äÜM,
an element v ‚ààSecœÄ(U) is called a vector Ô¨Åeld over U because it continuously assigns
a tangent vector v(u) to each point u ‚ààU. The tangent vector at u tells us the velocity
of the wind at that point.
Here‚Äôs a fun digression: in the case of a spherical manifold M like the Earth, it‚Äôs
possible to prove that for every open set U, as long as U , M, there is a vector Ô¨Åeld

242
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
v ‚ààSecœÄ(U) that is never 0: the wind could be blowing throughout U. However, a
theorem of Poincar√© says that if you look at the whole sphere, there is guaranteed to be
a point m ‚ààM at which the wind is not blowing at all. It‚Äôs like the eye of a hurricane or
perhaps a cowlick. A cowlick in someone‚Äôs hair occurs when the hair has no direction
to go, so it sticks up! Hair sticking up would not count as a tangent vector: tangent
vectors must start out lying Ô¨Çat along the head. Poincar√© proved that if your head
was covered completely with inch-long hair, there would be at least one cowlick. This
diÔ¨Äerence between local sections (over arbitrary U ‚äÜX) and global sections (over X)‚Äî
namely that hair can be well combed whenever U , X but cannot be well combed when
U  X‚Äîcan be thought of as a generative eÔ¨Äect, and can be measured by cohomology
(see Section 1.5).
Exercise 7.47.
If M is a sphere as in Example 7.46, we know from DeÔ¨Ånition 7.35 that
we can consider the category Shv(M) of sheaves on M; in fact, such categories are
toposes and these are what we‚Äôre getting to.
But are the sheaves on M the vector Ô¨Åelds? That is, is there a one-to-one corre-
spondence between sheaves on M and vector Ô¨Åelds on M? If so, why? If not, how are
sheaves on M and vector Ô¨Åelds on M related?
‚ô¶
Example 7.48. For every topological space (X, Op), we have the topos of sheaves on it.
The topos of sets, which one can regard as the story of set theory, is the category of
sheaves on the one-point space {‚àó}. In topos theory, we see the category of sets‚Äîan
huge, amazing, and rich category‚Äîas corresponding to a single point. Imagine how
much more complex arbitrary toposes are, when they can take place on much more
interesting topological spaces (and in fact even more general ‚Äòsites‚Äô).
Exercise 7.49.
Consider the Sierpinski space ({1, 2}, Op1) from Example 7.30.
1. What is the category Op for this space? (You may have already Ô¨Ågured this out
in Exercise 7.31; if not, do so now.)
2. What does a presheaf on Op consist of?
3. What is the sheaf condition for Op?
4. How do we identify a sheaf on Op with a function?
‚ô¶
7.4
Toposes
A topos is deÔ¨Åned to be a category of sheaves.9 So for any topological space (X, Op),
the category Shv(X, Op) deÔ¨Åned in DeÔ¨Ånition 7.35 is a topos. In particular, taking the
one-point space X  1 with its unique topology, we Ô¨Ånd that the category Set is a topos,
as we‚Äôve been saying all along and saw again explicitly in Example 7.48. And for any
9This is sometimes called a sheaf topos or a Grothendieck topos. There is a more general sort of topos
called an elementary topos due to Lawvere.

7.4. TOPOSES
243
database schema‚Äîi.e. Ô¨Ånitely presented category‚ÄîC, the category C-Inst of database
instances on C is also a topos.10 Toposes encompass both of these sources of examples,
and many more.
Toposes are incredibly nice structures, for a variety of seemingly disparate reasons.
In this sketch, the reason in focus is that every topos has many of the same structural
properties that the category Set has. Indeed, we discussed in Section 7.2.1 that every
topos has limits and colimits, is cartesian closed, has epi-mono factorizations, and has
a subobject classiÔ¨Åer (see Section 7.2.2). Using these properties, one can do logic with
semantics in the topos E. We explained this for sets, but now imagine it for sheaves on a
topological space. There, the same logical symbols ‚àß, ‚à®, ¬¨, ‚áí, ‚àÉ, ‚àÄbecome operations
that mean something about sub-sheaves‚Äîe.g. vector Ô¨Åelds, sections of continuous
functions, etc.‚Äînot just subsets.
To understand this more deeply, weshouldsaywhatthesubobjectclassiÔ¨Åertrue: 1 ‚Üí
‚Ñ¶is in more generality. We said that, in the topos Set, the subobject classiÔ¨Åer is the set
of booleans ‚Ñ¶ B. In a sheaf topos E  Shv(X, Op), the object ‚Ñ¶‚ààE is a sheaf, not
just a set. What sheaf is it?
7.4.1
The subobject classiÔ¨Åer ‚Ñ¶in a sheaf topos
In this subsection we aim to understand the subobject classiÔ¨Åer ‚Ñ¶, i.e. the object of
truth values, in the sheaf topos Shv(X, Op). Since ‚Ñ¶is a sheaf, let‚Äôs understand it
by going through the deÔ¨Ånition of sheaf (DeÔ¨Ånition 7.35) slowly in this case. A sheaf
‚Ñ¶is a presheaf that satisÔ¨Åes the sheaf condition. As a presheaf it is just a functor
‚Ñ¶: Opop ‚ÜíSet; it assigns a set ‚Ñ¶(U) to each open U ‚äÜX and comes with a restriction
map ‚Ñ¶(U) ‚Üí‚Ñ¶(V) whenever V ‚äÜU. So in our quest to understand ‚Ñ¶, we Ô¨Årst ask the
question: what presheaf is it?
The answer to our question is that ‚Ñ¶is the presheaf that assigns to U ‚ààOp the set
of open subsets of U:
‚Ñ¶(U) B {U‚Ä≤ ‚ààOp | U‚Ä≤ ‚äÜU}.
(7.50)
That was easy, right? And given the restriction map for V ‚äÜU is given by
‚Ñ¶(U) ‚Üí‚Ñ¶(V)
(7.51)
U‚Ä≤ 7‚ÜíU‚Ä≤ ‚à©V.
One can check that this is functorial‚Äîsee Exercise 7.53‚Äîand after doing so we will still
need to see that it satisÔ¨Åes the sheaf condition. But at least we don‚Äôt have to struggle to
understand ‚Ñ¶: it‚Äôs a lot like Op itself.
10We said that a topos is a category of sheaves, yet database instances are presheaves; so how is C-Inst
a topos? Well, presheaves in fact count as sheaves. We apologize that this couldn‚Äôt be clearer. All of this
could be made formal if we were to introduce sites. Unfortunately, that concept is simply too abstract for
the scope of this chapter.

244
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Exercise 7.52.
Let X  {1} be the one point space. We said above that its subobject
classiÔ¨Åer is the set B of booleans, but how does that align with the deÔ¨Ånition of ‚Ñ¶given
in Eq. (7.50)?
‚ô¶
Exercise 7.53.
1. Show that the deÔ¨Ånition of ‚Ñ¶given above in Eqs. (7.50) and (7.51) is functorial, i.e.,
that whenever W ‚äÜV ‚äÜU, the restriction map ‚Ñ¶(U) ‚Üí‚Ñ¶(V) followed by the
restriction map ‚Ñ¶(V) ‚Üí‚Ñ¶(W) is the same as the restriction map ‚Ñ¶(U) ‚Üí‚Ñ¶(W).
2. Is that all that‚Äôs necessary to conclude that ‚Ñ¶is a presheaf?
‚ô¶
To see that ‚Ñ¶as deÔ¨Åned in Eq. (7.50) satisÔ¨Åes the sheaf condition (see DeÔ¨Ånition 7.35),
suppose that we have a cover U  √ê
i‚ààI Ui, and suppose given an element Vi ‚àà‚Ñ¶(Ui),
i.e. an open set Vi ‚äÜUi, for each i ‚ààI. Suppose further that for all i, j ‚ààI, it is the
case that Vi ‚à©Uj  Vj ‚à©Ui, i.e. that the elements form a matching family. DeÔ¨Åne
V B √ê
i‚ààI Vi; it is an open subset of U, so we can consider V as an element of ‚Ñ¶(U).
The following veriÔ¨Åes that V is indeed a gluing for the (Vi)i‚ààI:
V ‚à©Uj 
 √ò
i‚ààI
Vi
!
‚à©Uj 
√ò
i‚ààI
(Vi ‚à©Uj) 
√ò
i‚ààI
(Vj ‚à©Ui) 
 √ò
i‚ààI
Ui
!
‚à©Vj  Vj
In other words V ‚à©Uj  Vj for any j ‚ààI. So our ‚Ñ¶has been upgraded from presheaf
to sheaf!
The eagle-eyed reader will have noticed that we haven‚Äôt yet given all the data
needed to deÔ¨Åne a subobject classiÔ¨Åer. To turn the object ‚Ñ¶into a subobject classiÔ¨Åer
in good standing, we also need to give a sheaf morphism true: {1} ‚Üí‚Ñ¶.
Here
{1}: Opop ‚ÜíSet is the terminal sheaf; it maps every open set to the terminal, one
element set {1}. The correct morphism true: {1} ‚Üí‚Ñ¶for the subobject classiÔ¨Åer is
the sheaf morphism that assigns, for every U ‚ààOp the function {1}  {1}(U) ‚Üí‚Ñ¶(U)
sending 1 7‚ÜíU, the largest open set U ‚äÜU. From now on we denote {1} simply as 1.
Upshot: Truth values are open sets.
The point is that the truth values in the topos
of sheaves on a space (X, Op) are the open sets of that space. When someone says ‚Äúis
property P true?,‚Äù the answer is not yes or no, but ‚Äúit is true on the open subset U.‚Äù
If this U is everything, U  X, then P is really true; if U is nothing, U  ¬ú, then P is
really false. But in general, it‚Äôs just true some places and not others.
Example 7.54. The category Grph of graphs is a presheaf topos, and one can also think
of it as the category of instances for a database schema, as we saw in Example 7.23. The
subobject classiÔ¨Åer ‚Ñ¶in the topos Gr is thus a graph, so we can draw it. Here‚Äôs what it

7.4. TOPOSES
245
looks like:
‚Ñ¶Grph 
0
V
(0,0; 0)
(0,V; 0)
(V,V; 0)
(V,V; A)
(V,0; 0)
Finding ‚Ñ¶for oneself is easiest using something called the Yoneda Lemma, but we
have not introduced it. For a nice, easy introduction to the topos of graphs, see [Vig03].
The terminal graph is a single vertex with a single loop, and the graph homomorphism
true: 1 ‚Üí‚Ñ¶sends that loop to (V, V; A).
Given any graph G and subgraph i : H ‚äÜG, we need to construct a graph homo-
morphism ‚åúH‚åù: G ‚Üí‚Ñ¶classifying H. The idea is that for each part of G, we decide
‚Äúhow much of it is in H. A vertex in v in G is either in H or not; if so we send it to V
and if not we send it to 0. But arrows a are more complicated. If a is in H, we send
it (V, V; A). But if it is not in H, the mathematics requires us to ask more questions:
is its source in H? is its target in G‚Äù? both? neither? Based on the answers to these
questions we send a to (V, 0; 0), (0, V; 0), (V, V; 0), or (0, 0; 0), respectively.
Exercise 7.55.
Consider the subgraph H ‚äÜG shown here:
A‚Ä¢
B‚Ä¢
C‚Ä¢
‚äÜ
A‚Ä¢
B‚Ä¢
C‚Ä¢
D‚Ä¢
f
1
h
i
Find the graph homomorphism ‚åúH‚åù: G ‚Üí‚Ñ¶classifying it. See Example 7.54.
‚ô¶
7.4.2
Logic in a sheaf topos
Let‚Äôs consider the logical connectives, AND, OR, IMPLIES, and NOT. Suppose we
have a topological space X ‚ààOp.
Given two open sets U, V, considered as truth
values U, V ‚àà‚Ñ¶(X), then their conjunction ‚ÄòU AND V‚Äô is their intersection, and their
disjunction ‚ÄòU OR V‚Äô is their union;
(U ‚àßV) B U ‚à©V
and
(U ‚à®V) B U ‚à™V.
(7.56)
These formulas are easy to remember, because ‚àßlooks like ‚à©and ‚à®looks like ‚à™. The
implication U ‚áíV is the largest open set R such that R ‚à©U ‚äÜV, i.e.
(U ‚áíV) B
√ò
{R‚ààOp|R‚à©U‚äÜV}
R.
(7.57)
In general, it is not easy to reduce Eq. (7.57) further, so implication is the hardest logical
connective to think about topologically.
Finally, the negation of U is given by ¬¨U B (U ‚áífalse), and this turns out
to be relatively simple. By the formula in Eq. (7.57), it is the union of all R such that
R‚à©U  ¬ú, i.e. the union of all open sets in the complement of U. If you know topology,
you might recognize that ¬¨U is the ‚Äòinterior of the complement of U.‚Äô

246
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
Example 7.58. Consider the real line X  R as a topological space (see Exercise 7.27).
Let U, V ‚àà‚Ñ¶(X) be the open sets U  {x ‚ààR | x < 3} and V  {x ‚ààR | ‚àí4 < x < 4}.
Using interval notation, U  (‚àí‚àû, 3) and V  (‚àí4, 4). Then
‚Ä¢ U ‚àßV  (‚àí4, 3).
‚Ä¢ U ‚à®V  (‚àí‚àû, 4).
‚Ä¢ ¬¨U  (3, ‚àû).
‚Ä¢ ¬¨V  (‚àí‚àû, ‚àí4) ‚à™(4, ‚àû).
‚Ä¢ (U ‚áíV)  (‚àí4, ‚àû)
‚Ä¢ (V ‚áíU)  U
Exercise 7.59.
Consider the real line R as a topological space, and consider the open
subset U  R ‚àí{0}.
1. What open subset is ¬¨U?
2. What open subset is ¬¨¬¨U?
3. Is it true that U ‚äÜ¬¨¬¨U?
4. Is it true that ¬¨¬¨U ‚äÜU?
‚ô¶
Above we explained operations on open sets, one corresponding to each logical
connective; there are also open sets corresponding to the the symbols true and false.
We explore this in an exercise.
Exercise 7.60.
Let (X, Op) be a topological space.
1. Suppose the symbol true corresponds to an open set such that for any open set
U ‚ààOp, we have (true ‚àßU)  U. Which open set is it?
2. Other things we should expect from true include (true ‚à®U)  true and (U ‚áí
true)  true and (true ‚áíU)  U. Do these hold for your answer to 1?
3. The symbol false corresponds to an open set U ‚ààOp such that for any open set
U ‚ààOp, we have (false ‚à®U)  U. Which open set is it?
4. Other things we should expect from false include (false ‚àßU)  false and
(false ‚áíU)  true. Do these hold for your answer to 1?
‚ô¶
Example 7.61. For a vector bundle œÄ: E ‚ÜíX over a space X, the corresponding sheaf
is SecœÄ corresponding to its sections: to each open set iU : U ‚äÜX, we associate the set
of functions s : U ‚ÜíE for which s # œÄ  iU. For example, in the case of the tangent
bundle œÄ: TM ‚ÜíM (see Example 7.46), the corresponding sheaf, call it VF, associates
to each U the set VF(U) of vector Ô¨Åelds on U.
The internal logic of the topos can then be used to consider properties of vector
Ô¨Åelds. For example, one could have a predicate Grad: VF ‚Üí‚Ñ¶that asks for the largest
subspace Grad(v) on which a given vector Ô¨Åeld v comes from the gradient of some
scalar function. One could also have a predicate that asks for the largest open set on
which a vector Ô¨Åeld is non-zero. Logical operations like ‚àßand ‚à®could then be applied
to hone in on precise submanifolds throughout which various desired properties hold,

7.4. TOPOSES
247
and to reason logically about what other properties are forced to hold there.
7.4.3
Predicates
In English, a predicate is the part of the sentence that comes after the subject. For
example ‚Äú. . . is even‚Äù or ‚Äú. . . likes the weather‚Äù are predicates.
Not every subject
makes sense for a given predicate; e.g. the sentence ‚Äú7 is even‚Äù may be false, but it
makes sense. In contrast, the sentence ‚Äú2.7 is even‚Äù does not really make sense, and
‚Äú2.7 likes the weather‚Äù certainly doesn‚Äôt. In computer science, they might say ‚ÄúThe
expression ‚Äò2.7 likes the weather‚Äô does not type check.‚Äù
The point is that each predicate is associated to a type, namely the type of subject
that makes sense for that predicate. When we apply a predicate to a subject of the
appropriate type, the result has a truth value: ‚Äú7 is even‚Äù is either true or false.
Perhaps ‚ÄúBob likes the weather‚Äù is true some days and false on others. In fact, this
truth value might change by the year (bad weather this year), by the season, by the
hour, etc. In English, we expect truth values of sentences to change over time, which
is exactly the motivation for this chapter. We‚Äôre working toward a logic where truth
values change over time.
In a topos E  Shv(X, Op), a predicate is a sheaf morphism p : S ‚Üí‚Ñ¶where S ‚ààE is
a sheaf and ‚Ñ¶‚ààE is the subobject classiÔ¨Åer, the sheaf of truth values. By DeÔ¨Ånition 7.35
we get a function p(U): S(U) ‚Üí‚Ñ¶(U) for any open set U ‚äÜX. In the above example‚Äî
which we will discuss more carefully in Section 7.5‚Äîif S is the sheaf of people (people
come and go over time), and Bob ‚ààS(U) is a person existing over a time U, and p is the
predicate ‚Äúlikes the weather,‚Äù then p(Bob) is the set of times during which Bob likes
the weather. So the answer to ‚ÄúBob likes the weather‚Äù is something like ‚Äúin summers
yes, and also in April 2018 and May 2019 yes, but in all other times no.‚Äù That‚Äôs p(Bob),
the temporal truth value obtained by applying the predicate p to the subject Bob.
Exercise 7.62.
Just now we described how a predicate p : S ‚Üí‚Ñ¶, such as ‚Äú. . . likes the
weather,‚Äù acts on sections s ‚ààS(U), say s  Bob. But by DeÔ¨Ånition 7.12, any predicate
p : S ‚Üí‚Ñ¶also deÔ¨Ånes a subobject of {S | p} ‚äÜS. Describe the sections of this subsheaf.
‚ô¶
The poset of subobjects.
For a topos E  Shv(X, Op) and object (sheaf) S ‚ààE, the
set of S-predicates |‚Ñ¶E|  E(S, ‚Ñ¶) is naturally given the structure of a poset, which we
denote
(|‚Ñ¶S|, ‚â§S)
(7.63)
Given two predicates p, q : S ‚Üí‚Ñ¶, we say that p ‚â§S q if the Ô¨Årst implies the second.
More precisely, for any U ‚ààOp and section s ‚ààS(U) we obtain two open subsets
p(s) ‚äÜU and q(s) ‚äÜU. We say that p ‚â§S q if p(s) ‚äÜq(s) for all U ‚ààOp and s ‚ààS(U).
We often drop the superscript from ‚â§S and simply write ‚â§. In formal logic notation,

248
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
one might write p ‚â§S q using the ‚ä¢symbol, e.g. in one of the following ways:
s : S | p(s) ‚ä¢q(s)
or
p(s) ‚ä¢s:S q(s).
In particular, if S  1 is the terminal object, we denote |‚Ñ¶S| by |‚Ñ¶|, and refer to elements
p ‚àà|‚Ñ¶| as propositions. They are just morphisms p : 1 ‚Üí‚Ñ¶.
This preorder is partially ordered‚Äîa poset‚Äîmeaning that if p ‚â§q and q ‚â§p then
p  q. The reason is that for any subsets U, V ‚äÜX, if U ‚äÜV and V ‚äÜU then U  V.
Exercise 7.64.
Give an example of a space X, a sheaf S ‚ààShv(X), and two predicates
p, q : S ‚Üí‚Ñ¶for which p(s) ‚ä¢s:S q(s) holds. You do not have to be formal.
‚ô¶
All of the logical symbols (true, false, ‚àß, ‚à®, ‚áí, ¬¨) from Section 7.4.2 make sense
in any such poset |‚Ñ¶S|. For any two predicates p, q : S ‚Üí‚Ñ¶, we deÔ¨Åne (p ‚àßq): S ‚Üí‚Ñ¶
by (p ‚àßq)(s) B p(s) ‚àßq(s), and similarly for ‚à®. Thus one says that these operations
are computed pointwise on S. With these deÔ¨Ånitions, the ‚àßsymbol is the meet and the ‚à®
symbol is the join‚Äîin the sense of DeÔ¨Ånition 1.81‚Äîfor the poset |‚Ñ¶S|.
With all of the logical structure we‚Äôve deÔ¨Åned so far, the poset |‚Ñ¶S| of predicates on S
forms what‚Äôs called a Heyting algebra. We will not deÔ¨Åne it here, but more information
can be found in Section 7.6. We now move on to quantiÔ¨Åcation.
7.4.4
QuantiÔ¨Åcation
QuantiÔ¨Åcation comes in two Ô¨Çavors: universal and existential, or ‚Äòfor all‚Äô and ‚Äòthere
exists.‚Äô Each takes in a predicate of n+1 variables and returns a predicate of n variables.
Example 7.65. Suppose we have two sheaves S, T ‚ààShv(X, Op) and a predicate p : S √ó
T ‚Üí‚Ñ¶. Let‚Äôs say T represents what‚Äôs considered newsworthy and S is again the set
of people. So for a subset of time U, a section t ‚ààT(U) is something that‚Äôs considered
newsworthy throughout the whole of U, and a section s ‚ààS(U) is a person that lasts
throughout the whole of U. Let‚Äôs imagine the predicate p as ‚Äús is worried about t.‚Äù
Now recall from Section 7.4.3 that a predicate p does not simply return true or false;
given a person s and a news-item t, it returns a truth value corresponding to the subset
of times on which p(s, t) is true.
‚ÄúFor all t in T, . . . is worried about t‚Äù is itself a predicate on just one variable, S,
which we denote
‚àÄ(t : T). p(s, t).
Applying this predicate to a person s returns the times when that person is worried
about everything in the news. Similarly, ‚Äúthere exists t in T such that s is worried about
t‚Äù is also a predicate on S, which we denote ‚àÉ(t : T). p(s, t). If we apply this predicate
to a person s, we get the times when person s is worried about at least one thing in the
news.

7.4. TOPOSES
249
Exercise 7.66.
In the topos Set, where ‚Ñ¶ B, consider the predicate p : N √ó Z ‚ÜíB
given by
p(n, z) 
(
true
if n ‚â§|z|
false
if n > |z|.
1. What is the set of n ‚ààN for which the predicate ‚àÄ(z : Z). p(n, z) holds?
2. What is the set of n ‚ààN for which the predicate ‚àÉ(z : Z). p(n, z) holds?
3. What is the set of z ‚ààZ for which the predicate ‚àÄ(n : N). p(n, z) holds?
4. What is the set of z ‚ààZ for which the predicate ‚àÉ(n : N). p(n, z) holds?
‚ô¶
So given p, we have a universally- and an existentially-quantiÔ¨Åed predicate ‚àÄ(t :
T). p(s, t) and ‚àÉ(t : T). p(s, t) on S. How do we formally understand them as sheaf
morphisms S ‚Üí‚Ñ¶or, equivalently, as subsheaves of S?
Universal quantiÔ¨Åcation.
Given a predicate p : S√óT ‚Üí‚Ñ¶, the universally-quantiÔ¨Åed
predicate ‚àÄ(t : T). p(s, t) takes a section s ‚ààS(U), for any open set U, and returns a
certain open set V ‚àà‚Ñ¶(U). Namely, it returns the largest open set V ‚äÜU for which
p(s

V, t)  V holds for all t ‚ààT(V).
Exercise 7.67.
Suppose s is a person alive throughout the interval U.
Apply the
above deÔ¨Ånition to the example p(s, t)  ‚Äúperson s is worried about news t‚Äù from
Example 7.65.
Here, T(V) is the set of items that are in the news throughout the
interval V.
1. What open subset of U is ‚àÄ(t : T). p(s, t) for a person s?
2. Does it have the semantic meaning you‚Äôd expect, given the less formal description
in Section 7.4.4?
‚ô¶
Abstractly speaking, the universally-quantiÔ¨Åed predicate corresponds to the sub-
sheaf given by the following pullback:
‚àÄtp
1
S
‚Ñ¶T
trueT
p‚Ä≤
‚åü
where p‚Ä≤: S ‚Üí‚Ñ¶T is the currying of S √ó T ‚Üí‚Ñ¶and trueT is the currying of the
composite 1 √ó T
!‚àí‚Üí1
true
‚àí‚àí‚àí‚Üí‚Ñ¶. See Eq. (7.10).
Existential quantiÔ¨Åcation.
Given a predicate p : S √ó T ‚Üí‚Ñ¶, the existentially quanti-
Ô¨Åed predicate ‚àÉ(t : T). p(s, t) takes a section s ‚ààS(U), for any open set U, and returns
a certain open set V ‚àà‚Ñ¶(U), namely the union V  √ê
i Vi of all the open sets Vi for
which there exists some ti ‚ààT(Vi) satisfying p(s

Vi, ti)  Vi. If the result is U itself, you
might be tempted to think ‚Äúah, so there exists some t ‚ààT(U) satisfying p(t),‚Äù but that
is not necessarily so. There is just a cover of U  √ê Ui and local sections ti ‚ààT(Ui),
each satisfying p, as explained above. Thus the existential quantiÔ¨Åer is doing a lot of

250
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
work ‚Äúunder the hood,‚Äù taking coverings into account without displaying that fact in
the notation.
Exercise 7.68.
Apply the above deÔ¨Ånition to the ‚Äúperson s is worried about news t‚Äù
predicate from Example 7.65.
1. What open set is ‚àÉ(t : T). p(s, t) for a person s?
2. Does it have the semantic meaning you‚Äôd expect?
‚ô¶
Abstractly speaking, the existentially-quantiÔ¨Åed predicate is given as follows. Start
with the subobject classiÔ¨Åed by p, namely {(s, t) ‚ààS √ó T | p(s, t)} ‚äÜS √ó T, compose
with the projection œÄS : S √ó T ‚ÜíS as on the upper right; then take the epi-mono
factorization of the composite as on the lower left:
{S √ó T | p}
S √ó T
‚àÉtp
S
œÄS
Then the bottom map is the desired subsheaf of S.
7.4.5
Modalities
Back in Example 1.123 we discussed modal operators‚Äîalso known as modalities‚Äî
saying they are closure operators on preorders which arise in logic. The preorders we
were referring to are the ones discussed in Eq. (7.63): for any object S ‚ààE there is the
poset (|‚Ñ¶S|, ‚â§S) of predicates on S, where |‚Ñ¶S|  E(S, ‚Ñ¶) is just the set of morphisms
S ‚Üí‚Ñ¶in the category E.
DeÔ¨Ånition 7.69. A modality in Shv(X) is a sheaf morphism j : ‚Ñ¶‚Üí‚Ñ¶satisfying three
properties for all U ‚äÜX and p, q ‚àà‚Ñ¶(U):
(a) p ‚â§j(p);
(b) (j # j)(p) ‚â§j(p); and
(c) j(p ‚àßq)  j(p) ‚àßj(q).
Exercise 7.70.
Suppose j : ‚Ñ¶‚Üí‚Ñ¶is a morphism of sheaves on X, such that p ‚â§j(p)
holds for all U ‚äÜX and p ‚àà‚Ñ¶(U). Show that for all q ‚àà‚Ñ¶(U) we have j(j(q)) ‚â§j(q) iÔ¨Ä
j(j(q))  j(q).
‚ô¶
In Example 1.123 we informally said that for any proposition p, e.g. ‚ÄúBob is in San
Diego,‚Äù there is a modal operator ‚Äúassuming p, ....‚Äù Now we are in a position to make
that formal.
Proposition 7.71. Fix a proposition p ‚àà|‚Ñ¶|. Then
(a) the sheaf morphism ‚Ñ¶‚Üí‚Ñ¶given by sending q to p ‚áíq is a modality.
(b) the sheaf morphism ‚Ñ¶‚Üí‚Ñ¶given by sending q to p ‚à®q is a modality.
(c) the sheaf morphism ‚Ñ¶‚Üí‚Ñ¶given by sending q to (q ‚áíp) ‚áíp is a modality.

7.4. TOPOSES
251
We cannot prove Proposition 7.71 here, but we give references in Section 7.6.
Exercise 7.72.
Let S be the sheaf of people as in Section 7.4.3, and let j : ‚Ñ¶‚Üí‚Ñ¶be
‚Äúassuming Bob is in San Diego...‚Äù
1. Name any predicate p : S ‚Üí‚Ñ¶, such as ‚Äúlikes the weather.‚Äù
2. Choose a time interval U. For an arbitrary person s ‚ààS(U), what sort of thing is
p(s), and what does it mean?
3. What sort of thing is j(p(s)) and what does it mean?
4. Is it true that p(s) ‚â§j(p(s))? Explain brieÔ¨Çy.
5. Is it true that j(j(p(s)))  j(p(s))? Explain brieÔ¨Çy.
6. Choose another predicate q : S ‚Üí‚Ñ¶. Is it true that j(p ‚àßq)  j(p) ‚àßj(q)? Explain
brieÔ¨Çy.
‚ô¶
7.4.6
Type theories and semantics
We have been talking about the logic of a topos in terms of open sets, but this is actually
a conÔ¨Çation of two ideas that are really better left unconÔ¨Çated. The Ô¨Årst is logic, or
formal language, and the second is semantics, or meaning. The formal language looks
like this:
‚àÄ(t : T). ‚àÉ(s : S). f (s)  t
(7.73)
and semantic statements are like ‚Äúthe sheaf morphism f : S ‚ÜíT is an epimorphism.‚Äù
In the former, logical world, all statements are linguistic expressions formed according
to strict rules and all proofs are deductions that also follow strict rules. In the latter,
semantic world, statements and proofs are about the sheaves themselves, as mathe-
matical objects. We admit these are rough statements; again, our aim here is only to
give a taste, an invitation to further reading.
To provide semantics for a logical system means to provide a compiler that converts
each logical statement in the formal language into a mathematical statement about
particular sheaves and their relationships. A computer can carry out logical deductions
without knowing what any of them ‚Äúmean‚Äù about sheaves. We say that semantics is
sound if every formal proof is converted into a true fact about the relevant sheaves.
Every topos can be assigned a formal language, often called its internal language,
in which to carry out constructions and formal proofs. This language has a sound
semantics‚Äîa sort of logic-to-sheaf compiler‚Äîwhich goes under the name categorical
semantics or Kripke-Joyal semantics.
We gave the basic ideas in Section 7.4; we give
references to the literature in Section 7.6.
Example 7.74. In every topos E, and for every f : S ‚ÜíT in E, the morphism f is
an epimorphism if and only if Eq. (7.73) holds. For example, consider the case of
database instances on a schema C, say with 100 tables (one of which might be denoted
c ‚ààOb(C)) and 500 foreign key columns (one of which might be denoted f : c ‚Üíc‚Ä≤ in
C); see Eq. (3.2).

252
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
If S and T are two instances and f is a natural transformation between them, then
we can ask the question of whether or not Eq. (7.73) holds. This simple formula is
compiled by the Kripke-Joyal semantics into asking:
Is it true that for every table c ‚ààOb(C) and every row s ‚ààS(c) there exists
a row t ‚ààT(c) such that f (s)  t?
This is exactly what it means for f to be surjective. Maybe this is not too impressive,
but whether one is talking about databases or topological spaces, or complex ideas
from algebraic geometry, Eq. (7.73) always compiles into the question of surjectivity.
For topological spaces it would say something like:
Is it true that for every open set U ‚äÜX and every section s ‚ààS(U) of the
bundle S, there exists an open covering of (Ui ‚äÜU)i‚ààI of U and a section
ti ‚ààT(Ui) of the bundle T for each i ‚ààI, such that f (ti)  s

Ui is the
restriction of s to Ui?
7.5
A topos of behavior types
Now that we have discussed logic in a sheaf topos, we return to our motivating example,
a topos of behavior types. We begin by discussing the topological space on which
behavior types will be sheaves, a space called the interval domain.
Remark 7.75. Note that above, we were thinking very intuitively about time, e.g. when
we discussed people being worried about the news. Now we will be thinking about
time in a diÔ¨Äerent way, but there is no need to change your answers or reconsider the
intuitive thinking done above.
7.5.1
The interval domain
The interval domain IR is a speciÔ¨Åc topological space, which we will use to model
intervals of time. In other words, we will be interested in the category Shv(IR) of
sheaves on the interval domain.
To give a topological space, one must give a pair (X, Op), where X is a set of ‚Äòpoints‚Äô
and Op is a topology on X; see DeÔ¨Ånition 7.25. The set of points for IR is that of all
Ô¨Ånite closed intervals
IR B {[d, u] ‚äÜR | d ‚â§u}.
For a < b in R, let o[a,b] denote the set o[a,b] B {[d, u] ‚ààIR | a < d ‚â§u < b}; these are
called basic open sets. The topology Op is determined by these basic open sets in that a
subset U is open if it is the union of some collection of basic open sets.
Thus for example, o[0,5] is an open set: it contains every [d, u] contained in the
open interval {x ‚ààR | 0 < x < 5}.
Similarly o[4,8] is an open set, but note that
o[0,5] ‚à™o[4,8] , o[0,8]. Indeed, the interval [2, 6] is in the right-hand side but not the left.
Exercise 7.76.

7.5. A TOPOS OF BEHAVIOR TYPES
253
1. Explain why [2, 6] ‚àào[0,8].
2. Explain why [2, 6] < o[0,5] ‚à™o[4,8].
‚ô¶
Let Op denote the open sets of IR, as described above, and let BT B Shv(IR, Op)
denote the topos of sheaves on this space. We call it the topos of behavior types.
There is an important subspace of IR, namely the usual space of real numbers R.
We see R as a subspace of IR via the isomorphism
R  {[d, u] ‚ààIR | d  u}.
We discussed the usual topology on R in Example 7.26, but we also get a topology
on R because it is a subset of IR; i.e. we have the subspace topology as described in
Exercise 7.32. These agree, as the reader can check.
Exercise 7.77.
Show that a subset U ‚äÜR is open in the subspace topology of R ‚äÜIR iÔ¨Ä
U ‚à©R is open in the usual topology on R deÔ¨Åned in Example 7.26.
‚ô¶
7.5.2
Sheaves on IR
We cannot go into much depth about the sheaf topos BT  Shv(IR, Op), for reasons
of space; we refer the interested reader to Section 7.6. In this section we will brieÔ¨Çy
discuss what it means to be a sheaf on IR, giving a few examples including that of the
subobject classiÔ¨Åer.
What is a sheaf on IR?
A sheaf S on the interval domain (IR, Op) is a functor
S: Opop ‚ÜíSet: it assigns to each open set U a set S(U); how should we interpret this?
An element s ‚ààS(U) is something that says is an ‚Äúevent that takes place throughout
the interval U.‚Äù Given this U-event s together with an open subset of V ‚äÜU, there is
a V-event s

V that tells us what s is if we regard it as an event taking place throughout
V. If U  √ê
i‚ààI Ui and we can Ô¨Ånd matching Ui-events (si) for each i ‚ààI, then the sheaf
condition (DeÔ¨Ånition 7.35) says that they have a unique gluing, i.e. a U-event s ‚ààS(U)
that encompasses all of them: s

Ui  si for each i ‚ààI.
We said in Section 7.5.1 that every open set U ‚äÜIR can be written as the union of
basic open sets o[a,b]. This implies that any sheaf S is determined by its values S(o[a,b])
on these basic open sets. The sheaf condition furthermore implies that these vary
continuously in a certain sense, which we can express formally as
S(o[a,b])  lim
œµ>0 S(o[a‚àíœµ,b+œµ]).
However, rather than get into the details, we describe a few sorts of sheaves that may
be of interest.
Example 7.78. For any set A there is a sheaf A ‚ààShv(IR) that assigns to each open set U
the set A(U) B A. This allows us to refer to integers, or real numbers, or letters of an
alphabet, as though they were behaviors. What sort of behavior is 7 ‚ààN? It is the sort

254
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
of behavior that never changes: it‚Äôs always seven. Thus A is called the constant sheaf on
A.
Example 7.79. Fix any topological space (X, OpX). Then there is a sheaf FX of local
functions from IR to X. That is, for any open set U ‚ààOpIR, we assign the set FX(U) B
{ f : U ‚ÜíX | f is continuous}. There is also the sheaf GX of local functions on the
subspace R ‚äÜIR. That is, for any open set U ‚ààOpIR, we assign the set GX(U) B
{ f : U ‚à©R ‚ÜíX | f is continuous}.
Exercise 7.80.
Let‚Äôs check that Example 7.78 makes sense. Fix any topological space
(X, OpX) and any subset R ‚äÜIR of the interval domain. DeÔ¨Åne HX(U) B { f : U ‚à©R ‚Üí
X | f is continuous}.
1. Is HX a presheaf? If not, why not; if so, what are the restriction maps?
2. Is HX a sheaf? Why or why not?
‚ô¶
Example 7.81. Another source of examples comes from the world of open hybrid dy-
namical systems.
These are machines whose behavior is a mixture of continuous
movements‚Äîgenerally imagined as trajectories through a vector Ô¨Åeld‚Äîand discrete
jumps. These jumps are imagined as being caused by signals that spontaneously arrive.
Over any interval of time, a hybrid system has certain things that it can do and certain
things that it cannot. Although we will not make this precise here, there is a construc-
tion for converting any hybrid system into a sheaf on IR; we will give references in
Section 7.6.
We refer to sheaves on IR as behavior types because almost any sort of behavior one
can imagine is a behavior type. Of course, a complex behavior type‚Äîsuch as the way
someone acts when they are in love‚Äîwould be extremely hard to write down. But the
idea is straightforward: for any interval of time, say a three-day interval (d, d + 3), let
L(d, d +3) denote the set of all possible behaviors a person who is in love could possibly
do. Obviously it‚Äôs a big, unwieldy set, and no one would want to make precise. But to
the extent that one can imagine that sort of behavior as occurring through time, they
could imagine the corresponding sheaf.
The subobject classiÔ¨Åer as a sheaf on IR.
In any sheaf topos, the subobject classiÔ¨Åer
‚Ñ¶is itself a sheaf. It is responsible for the truth values in the topos. As we said in
Section 7.4.1, when it comes to sheaves on a topological space (X, Op), truth values are
open subsets U ‚ààOp.
BT is the topos of sheaves on the space (IR, Op), as deÔ¨Åned in Section 7.5.1. As
always, the subobject classiÔ¨Åer ‚Ñ¶assigns to any U ‚ààOp the set of open subsets of U, so
these are the truth values. But what do they mean? The idea is that every proposition,

7.5. A TOPOS OF BEHAVIOR TYPES
255
such as ‚ÄúBob likes the weather‚Äù returns an open set U, as if to respond that Bob likes
the weather ‚Äú...throughout time period U.‚Äù Let‚Äôs explore this just a bit more.
Suppose Bob likes the weather throughout the interval (0, 5) and throughout the
interval (4, 8). We would probably conclude that Bob likes the weather throughout the
interval (0, 8). But what about the more ominous statement ‚Äúa single pair of eyes has
remained watching position p.‚Äù Then just because it‚Äôs true on (0, 5) and on (4, 8), does
not imply that it‚Äôs been true on (0, 8): there may have been a change of shift, where
one watcher was relieved from their post by another watcher. As another example,
consider the statement ‚Äúthe stock market did not go down by more than 10 points.‚Äù
This might be true on (0, 5) and true on (4, 8) but not on (0, 8). In order to capture the
semantics of statements like these‚Äîstatements that take time to evaluate‚Äîwe must
use the space IR rather than the space R.
7.5.3
Safety proofs in temporal logic
We now have at least a basic idea of what goes into a proof of safety, say for autonomous
vehicles, or airplanes in the national airspace system. In fact, the underlying ideas of
this chapter came out of a project between MIT, Honeywell Inc., and NASA [SSV18].
The background for the project was that the National Airspace System consists of
many diÔ¨Äerent systems interacting: interactions between airplanes, each of which is
an interaction between physics, humans, sensors, and actuators, each of which is an
interaction between still more basic parts. The same sort of story would hold for a Ô¨Çeet
of autonomous vehicles, as in the introduction to this chapter.
Suppose that each of the systems‚Äîat any level‚Äîis guaranteed to satisfy some
property. For example, perhaps we can assume that an engine is either out of gas, has
a broken fuel line, or is following the orders of a human driver or pilot. If there is
a rupture in the fuel line, the sensors will alert the human within three seconds, etc.
Each of the components interact with a number of diÔ¨Äerent variables. In the case of
airplanes, a pilot interacts with the radio, the positions of the dials, the position of
the thruster, and the visual data in front of her. The component‚Äîhere the pilot‚Äîis
guaranteed to keep these variables in some relation: ‚Äúif I see something, I will say
something‚Äù or ‚Äúif the dials are in position bad_pos, I will engage the thruster within 1
second.‚Äù We call these guarantees behavior contracts.
All of the above can be captured in the topos BT of behavior types. The variables
are behavior types: the altimeter is a variable whose value Œ∏ ‚ààR‚â•0 is changing
continuously with respect to time. The thruster is also a continuously-changing variable
whose value is in the range [0, 1], etc.
The guaranteed relationships‚Äîbehavior contracts‚Äîare given by predicates on vari-
ables. For example, if the pilot will always engage the thruster within one second
of the display dials being in position bad_pos, this can be captured by a predicate
p : dials √ó thrusters ‚Üí‚Ñ¶. While we have not written out a formal language for p,

256
CHAPTER 7. LOGIC OF BEHAVIOR: SHEAVES, TOPOSES, LANGUAGES
one could imagine the predicate p(D, T) for D : dials and T : thrusters as
‚àÄ(t : R). @t
 bad_pos(D)
‚áí
‚àÉ(r : R). (0 < r < 1) ‚àß‚àÄ(r‚Ä≤ : R). 0 ‚â§r‚Ä≤ ‚â§5 ‚áí@t+r+r‚Ä≤  engaged(T)
.
(7.82)
Here @t is a modality, as we discussed in DeÔ¨Ånition 7.69; in fact it turns out to be one
of type 3. from Proposition 7.71, but we cannot go into that. For a proposition q, the
statement @t(q) says that q is true in some small enough neighborhood around t. So
(7.82) says ‚Äústarting within one second of whenever the dials say that we are in a bad
position, I‚Äôll engage the thrusters for Ô¨Åve seconds.‚Äù
Given an actual playing-out-of-events over a time period U, i.e. actual section D ‚àà
dials(U) and section T ‚ààthrusters(U), the predicate Eq. (7.82) will hold on certain
parts of U and not others, and this is the truth value of p. Hopefully the pilot upholds
her behavior contract at all times she is Ô¨Çying, in which case the truth value will be true
throughout that interval U. But if the pilot breaks her contract over certain intervals,
then this fact is recorded in ‚Ñ¶.
The logic allows us to record axioms like that shown in Eq. (7.82) and then reason
from them: e.g. if the pilot and the airplane, and at least one of the three radars upholds
its contract then safe separation will be maintained. We cannot give further details here,
but these matters have been worked out in detail in [SS18]; see Section 7.6.
7.6
Summary and further reading
This chapter was about modeling various sorts of behavior using sheaves on a space of
time-intervals. Behavior may seem like it‚Äôs something that occurs now in the present,
but in fact our memory of past behavior informs what the current behavior means.
In order to commit to anything, to plan or complete any sort of process, one needs to
be able to reason over time-intervals. The nice thing about temporal sheaves‚Äîindeed
sheaves on any site‚Äîis that they Ô¨Åt into a categorical structure called a topos, which has
many useful formal properties. In particular, it comes equipped with a higher-order
logic with which we can formally reason about how temporal sheaves work together
when combined in larger systems. A much more detailed version of this story was
presented in [SS18]. But it would have been impossible without the extensive ediÔ¨Åce
of topos theory and domain theory that has been developed over the past six decades.
Sheaf toposes were invented by Grothendieck and his school in the 1960s [AGV71]
as an approach to proving conjectures at the intersection of algebraic geometry and
number theory, called the Weil conjectures. Soon after, Lawvere and Tierney recognized
that toposes had all the structure necessary to do logic, and with a whole host of
other category theorists, the subject was developed to an impressive extent in many
directions. For a much more complete history, see [McL90].
There are many sorts of references on topos theory. One that starts by introducing
categories and then moves to toposes, focusing on logic, is [McL92].
Our favorite

7.6. SUMMARY AND FURTHER READING
257
treatment is perhaps [MM92], where the geometric aspects play a central role. Finally,
Johnstone has done the Ô¨Åeld a huge favor by collecting large amounts of the theory
into a single two-volume set [Joh02]; it is very dense, but an essential reference for the
serious student or researcher. For just categorical (Kripke-Joyal) semantics of logic in a
topos, one should see either [MM92], [Jac99], or [LS88].
We did not mention domain theory much in this chapter, aside from referring to
the interval domain. But domains, in the sense of Dana Scott, play an important role
in the deeper aspects of temporal type theory. A good reference is [Gie+03], but for an
introduction we suggest [AJ94].
In some sense our application area has been a very general sort of dynamical system.
Other categorical approaches to this subject include [JNW96], [HTP03], [AS05], and
[Law86], though there are many others.
We hope you have enjoyed the seven sketches in this book. As a next step, consider
running a reading course on applied category theory with some friends or colleagues.
Simultaneously, we hope you begin to search out categorical ways of thinking about
familiar subjects. Perhaps you‚Äôll Ô¨Ånd something you want to contribute to this growing
Ô¨Åeld of applied category theory, or as we sometimes call it, the Ô¨Åeld of compositionality.


Appendix A
Exercise solutions
A.1
Solutions for Chapter 1.
Solution to Exercise 1.1.
For each of the following properties, we need to Ô¨Ånd a function f : R ‚ÜíR that preserves it, and another
function‚Äîcall it 1‚Äîthat does not.
order-preserving: Take f (x)  x + 5; if x ‚â§y then x + 5 ‚â§y + 5, so f is order-preserving. Take
1(x) B ‚àíx; even though 1 ‚â§2, the required inequality ‚àí1 ‚â§? ‚àí2 does not hold, so 1 is not
order-preserving.
metric-preserving: Take f (x) B x + 5; for any x, y we have |x ‚àíy|  |(x + 5) ‚àí(y + 5)| by the rules of
arithmetic, so |x ‚àíy|  | f (x) ‚àíf (y)|, meaning f preserves metric. Take 1(x) B 2 ‚àóx; then with
x  1 and y  2 we have |x ‚àíy|  1 but |2x ‚àí2y|  2, so 1 does not preserve the metric.
addition-preserving: Take f (x) B 3 ‚àóx; for any x, y we have 3 ‚àó(x + y)  (3 ‚àóx) + (3 ‚àóy), so f preserves
addition. Take 1(x) B x + 1; then with x  0 and y  0, we have 1(x + y)  1, but 1(x) + 1(y)  2,
so 1 does not preserve addition.
Solution to Exercise 1.4.
Here is the join of the two systems:
11‚Ä¢
12‚Ä¢
13‚Ä¢
21‚Ä¢
22‚Ä¢
23‚Ä¢
11‚Ä¢
12‚Ä¢
13‚Ä¢
21‚Ä¢
22‚Ä¢
23‚Ä¢
‚à®
11‚Ä¢
12‚Ä¢
13‚Ä¢
21‚Ä¢
22‚Ä¢
23‚Ä¢

Solution to Exercise 1.6.
1. Here is the Hasse diagram for partitions of the two element set {‚Ä¢, ‚àó}:
‚Ä¢
‚àó
(12) 
‚Ä¢
‚àó
(1)(2) 
259

260
APPENDIX A. EXERCISE SOLUTIONS
2. Here is a picture (using text, rather than circles) for partitions of the set 1, 2, 3, 4:
(1)(2)(3)(4)
(12)(3)(4)
(1)(2)(34)
(13)(2)(4)
(1)(24)(3)
(14)(2)(3)
(1)(23)(4)
(12)(34)
(13)(24)
(14)(23)
(123)(4)
(124)(3)
(134)(2)
(1)(234)
(1234)
For the remaining parts, we choose A  (12)(3)(4) and B  (13)(2)(4).
3. A ‚à®B  (123)(4).
4. Yes, it is true that A ‚â§(A ‚à®B) and that B ‚â§(A ‚à®B).
5. The systems C with A ‚â§C and B ‚â§C are: (123)(4) and (1234).
6. Yes, it is true that in each case (A ‚à®B) ‚â§C.
Solution to Exercise 1.7.
1. true ‚à®false  true.
2. false ‚à®true  true.
3. true ‚à®true  true.
4. false ‚à®false  false.
Solution to Exercise 1.11.
1. The eight subsets of B B {1, 2, 3} are
¬ú,
{1},
{2},
{3},
{1, 2},
{1, 3},
{2, 3},
{1, 2, 3}.
2. The union of {1, 2, 3} and {1} is {1, 2, 3} ‚à™{1}  {1, 2, 3}.
3. The six elements of {h, 1} √ó {1, 2, 3} are
(h, 1),
(h, 2),
(h, 3),
(1, 1),
(1, 2),
(1, 3).
4. The Ô¨Åve elements of {h, 1} ‚äî{1, 2, 3} are
(h, 1),
(1, 1),
(1, 2),
(2, 2),
(3, 2).
5. The four elements of {h, 1} ‚à™{1, 2, 3} are
h,
1,
2,
3.
Solution to Exercise 1.10.
1. This is true: a natural number is exactly an integer that is at least 0.
2. This is false: 0 ‚ààN but 0 < {n ‚ààZ | n ‚â•1}.
3. This is true: no elements of Z are strictly between 1 and 2.
Solution to Exercise 1.16.
Suppose that A is a set and {Ap}p‚ààP and {A‚Ä≤
p‚Ä≤}p‚Ä≤‚ààP‚Ä≤ are two partitions of A such that for each p ‚ààP
there exists a p‚Ä≤ ‚ààP‚Ä≤ with Ap  A‚Ä≤
p‚Ä≤.

A.1. SOLUTIONS FOR CHAPTER 1
261
1. Given p ‚ààP, suppose we had p‚Ä≤
1, p‚Ä≤
2 ‚ààP‚Ä≤ such that Ap  A‚Ä≤
p‚Ä≤
1 and Ap  A‚Ä≤
p‚Ä≤
2. Well then Ap‚Ä≤
1  Ap‚Ä≤
2,
so in particular Ap‚Ä≤
1 ‚à©Ap‚Ä≤
2  Ap‚Ä≤
1. By the deÔ¨Ånition of partition (1.14), Ap‚Ä≤
1 , ¬ú, and yet if p1 , p2
then Ap‚Ä≤
1 ‚à©Ap‚Ä≤
2  ¬ú. This can‚Äôt be, so we must have p‚Ä≤
1  p‚Ä≤
2, as desired.
2. Suppose given p‚Ä≤ ‚ààP‚Ä≤; we want to show that there is a p ‚ààP such that Ap  A‚Ä≤
p‚Ä≤. Since A‚Ä≤
p‚Ä≤ , ¬ú
is nonempty by deÔ¨Ånition, we can pick some a ‚ààA‚Ä≤
p‚Ä≤; since A‚Ä≤
p‚Ä≤ ‚äÜA, we have a ‚ààA. Finally,
since A  √ê
p‚ààP Ap, there is some p with a ‚ààAp. This is our candidate p; now we show that
Ap  A‚Ä≤
p‚Ä≤. By assumption there is some p‚Ä≤‚Ä≤ ‚ààP‚Ä≤ with Ap  A‚Ä≤
p‚Ä≤‚Ä≤, so now a ‚ààA‚Ä≤
p‚Ä≤‚Ä≤ and a ‚ààA‚Ä≤
p‚Ä≤,
so a ‚ààA‚Ä≤
p‚Ä≤ ‚à©A‚Ä≤
p‚Ä≤‚Ä≤. Again by deÔ¨Ånition, having a nonempty intersection means p‚Ä≤  p‚Ä≤‚Ä≤. So we
conclude that Ap  Ap‚Ä≤.
Solution to Exercise 1.17.
The pairs (a, b) such that a ‚àºb are:
(11, 11)
(11, 12)
(12, 11)
(12, 12)
(13, 13)
(21, 21)
(22, 22)
(12, 23)
(23, 22)
(23, 23)
Solution to Exercise 1.20.
1. One aspect in the deÔ¨Ånition of the parts is that they are connected, and one aspect of that is that
they are nonempty. So each part Ap is nonempty.
2. Suppose p , q, i.e. Ap and Aq are not exactly the same set. To prove Ap ‚à©Aq  ¬ú, we suppose
otherwise and derive a contradiction. So suppose there exists a ‚ààAp ‚à©Aq; we will show that
Ap  Aq, which contradicts an earlier hypothesis. To show that these two subsets are equal, it
suÔ¨Éces to show that a‚Ä≤ ‚ààAp iÔ¨Äa‚Ä≤ ‚ààAq for all a‚Ä≤ ‚ààA. Suppose a‚Ä≤ ‚ààAp; then because Ap is
connected, we have a ‚àºa‚Ä≤. And because Aq is closed, a‚Ä≤ ‚ààAq. In just the way, if a‚Ä≤ ‚ààAq then
because Aq is connected and Ap is closed, a‚Ä≤ ‚ààAp, and we are done.
3. To show that A  √ê
p‚ààP Ap, it suÔ¨Éces to show that for each a ‚ààA, there is some p ‚ààP such that
a ‚ààAp. We said that P was the set of closed and connected subsets of A, so it suÔ¨Éces to show that
there is some closed and connected subset containing a. Let X B {a‚Ä≤ ‚ààA | a‚Ä≤ ‚àºa}; we claim it is
closed and connected and contains a. To see X is closed, suppose a‚Ä≤ ‚ààX and b ‚àºa‚Ä≤; then b ‚àºa
by transitivity and symmetry of ‚àº, so b ‚ààX. To see that X is connected, suppose b, c ‚ààX; then
b ‚àºa and c ‚àºa so b ‚àºc by the transitivity and symmetry of ‚àº. Finally, a ‚ààX by the reÔ¨Çexivity
of ‚àº.
Solution to Exercise 1.24.
1. The unique function ¬ú ‚Üí{1} is injective but not surjective.
2. The unique function {a, b} ‚Üí{1} is surjective but not injective.
3. The second and third are not functions; the Ô¨Årst and fourth are functions.
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚úì
?
?
‚úì
4. Neither the second nor third is ‚Äòtotal‚Äô. Moreover, the second one is not deterministic. The Ô¨Årst
one is a function which is not injective and not surjective. The fourth one is a function which is
both injective and surjective.
Solution to Exercise 1.25.
By DeÔ¨Ånition 1.22, a function f : A ‚Üí¬ú is a subset F ‚äÜA √ó ¬ú such that for all a ‚ààA, there exists a
unique b ‚àà¬ú with (a, b) ‚ààF. But there are no elements b ‚àà? ¬ú, so if F is to have the above property,
there can be no a ‚ààA either; i.e. A must be empty.

262
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.27.
Below each partition, we draw a corresponding surjection out of {‚Ä¢, ‚àó, ‚ó¶}:
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
‚Ä¢
‚àó
‚ó¶
p1
p2
p3
‚Ä¢
‚àó
‚ó¶
p1
p2
‚Ä¢
‚àó
‚ó¶
p1
p2
‚Ä¢
‚àó
‚ó¶
p1
p2
‚Ä¢
‚àó
‚ó¶
p1
Solution to Exercise 1.38.
G 
1‚Ä¢
2‚Ä¢
3‚Ä¢
4‚Ä¢
a
b
c
e
d
arrow a
source s(a) ‚ààV
target t(a) ‚ààV
a
1
2
b
1
3
c
1
3
d
2
2
e
2
3
Solution to Exercise 1.40.
The graph G from Exercise 1.38 is a strange Hasse diagram because it has two arrows 1 ‚Üí3 and a loop,
both of which are ‚Äúuseless‚Äù from a preorder point-of-view. But that does not prevent our formula from
working. The preorder (P, ‚â§) is given by taking P B V  {1, 2, 3, 4} and writing p ‚â§q whenever there
exists a path from p to q. So:
1 ‚â§1,
1 ‚â§2,
1 ‚â§3,
2 ‚â§2,
2 ‚â§3,
3 ‚â§3,
4 ‚â§4
Solution to Exercise 1.41.
A collection of points, e.g. ‚Ä¢
‚Ä¢
‚Ä¢ is a Hasse diagram, namely for the discrete order, i.e. for the order
where x ‚â§y iÔ¨Äx  y.
Solution to Exercise 1.42.
Let‚Äôs write the Ô¨Åve elements of X as
(‚Ä¢)(‚ó¶)(‚àó),
(‚Ä¢‚ó¶)(‚àó),
(‚Ä¢‚àó)(‚ó¶),
(‚Ä¢)(‚ó¶‚àó),
(‚Ä¢ ‚ó¶‚àó)
Our job is to write down all 12 pairs of x1, x2 ‚ààX with x1 ‚â§x2. Here they are:
(‚Ä¢)(‚ó¶)(‚àó) ‚â§(‚Ä¢)(‚ó¶)(‚àó)
(‚Ä¢)(‚ó¶)(‚àó) ‚â§(‚Ä¢‚ó¶)(‚àó)
(‚Ä¢)(‚ó¶)(‚àó) ‚â§(‚Ä¢‚àó)(‚ó¶)
(‚Ä¢)(‚ó¶)(‚àó) ‚â§(‚Ä¢)(‚ó¶‚àó)
(‚Ä¢)(‚ó¶)(‚àó) ‚â§(‚Ä¢ ‚ó¶‚àó)
(‚Ä¢‚ó¶)(‚àó) ‚â§(‚Ä¢‚ó¶)(‚àó)
(‚Ä¢‚ó¶)(‚àó) ‚â§(‚Ä¢ ‚ó¶‚àó)
(‚Ä¢‚àó)(‚ó¶) ‚â§(‚Ä¢‚àó)(‚ó¶)
(‚Ä¢‚àó)(‚ó¶) ‚â§(‚Ä¢ ‚ó¶‚àó)
(‚Ä¢)(‚ó¶‚àó) ‚â§(‚Ä¢)(‚ó¶‚àó)
(‚Ä¢)(‚ó¶‚àó) ‚â§(‚Ä¢ ‚ó¶‚àó)
(‚Ä¢ ‚ó¶‚àó) ‚â§(‚Ä¢ ‚ó¶‚àó)
Solution to Exercise 1.44.
The statement in the text is almost correct. It is correct to say that a discrete preorder is one where x
and y are comparable if and only if x  y.

A.1. SOLUTIONS FOR CHAPTER 1
263
Solution to Exercise 1.46.
8‚Ä¢
9‚Ä¢
6‚Ä¢
4‚Ä¢
10‚Ä¢
3‚Ä¢
2‚Ä¢
5‚Ä¢
7‚Ä¢
1‚Ä¢
No, it is not a total order; for example 4 ‚â∞6 and 6 ‚â∞4.
Solution to Exercise 1.48.
Yes, the usual ‚â§ordering is a total order on R: for every a, b ‚ààR either a ‚â§b or b ‚â§a.
Solution to Exercise 1.51.
The Hasse diagrams for P(¬ú), P{1}, and P{1, 2} are
¬ú
¬ú
{1}
¬ú
{1}
{2}
{1, 2}
Solution to Exercise 1.53.
The coarsest partition on S corresponds to the unique function !: S ‚Üí{1}. The Ô¨Ånest partition on S
corresponds to the identity function idS : S ‚ÜíS.
Solution to Exercise 1.55.
If X has the discrete preorder, then every subset U of X is an upper set: indeed, if p ‚ààU, the only q
such that p ‚â§q is p itself, so q is deÔ¨Ånitely in U! This means that U(X) contains all subsets of X, so it‚Äôs
exactly the power set, U(X)  P(X).
Solution to Exercise 1.57.
The product preorder and its upper set preorder are:
(a, 1)
(c, 1)
(a, 2)
(b, 1)
(c, 2)
(b, 2)
{(c, 2)}
{(b, 2)}
{(c, 1), (c, 2)}
{(b, 2), (c, 2)}
{(b, 1), (b, 2)}
{(b, 2), (c, 1), (c, 2)}
{(a, 2), (b, 2), (c, 2)}
{(b, 1), (b, 2), (c, 2)}
{(a, 2), (b, 2), (c, 1), (c, 2)}
{(a, 2), (b, 1), (b, 2), (c, 2)}
{(a, 2), (b, 1), (b, 2), (c, 1), (c, 2)}
{(a, 1), (a, 2), (b, 1), (b, 2), (c, 1), (c, 2)}

264
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.63.
With X  {0, 1, 2}, the Hasse diagram for P(X), the preorder 0 ‚â§¬∑ ¬∑ ¬∑ ‚â§3, and the cardinality map
between them are shown below:
X
{0, 1}
{0, 2}
{1, 2}
{0}
{1}
{2}
¬ú
3
2
1
0
Solution to Exercise 1.65.
¬ú
{true}
{true, false}
{true}
{false}
¬ú
{true, false}
Solution to Exercise 1.66.
1. Let q ‚àà‚Üëp, and suppose q ‚â§q‚Ä≤. Since q ‚àà‚Üëp, we have p ‚â§q. Thus by transitivity p ‚â§q‚Ä≤, so
q‚Ä≤ ‚àà‚Üëp. Thus ‚Üëp is an upper set.
2. Suppose p ‚â§q in P; this means that q ‚â§op p in Pop. We must show that ‚Üëq ‚äÜ‚Üëp. Take any
q‚Ä≤ ‚àà‚Üëq. Then q ‚â§q‚Ä≤, so by transitivitiy p ‚â§q‚Ä≤, and hence q‚Ä≤ ‚àà‚Üëp. Thus ‚Üëq ‚äÜ‚Üëp.
3. Monotonicity of ‚Üësays that p ‚â§p‚Ä≤ implies ‚Üë(p‚Ä≤) ‚äÜ‚Üë(p). We must prove the other direction, that
if p ‚â∞p‚Ä≤ then ‚Üë(p‚Ä≤) ‚äà‚Üë(p). This is straightforward, since by reÔ¨Çexivity we always have p‚Ä≤ ‚àà‚Üë(p‚Ä≤),
but if p ‚â∞p‚Ä≤, then p‚Ä≤ < ‚Üë(p), so ‚Üë(p‚Ä≤) ‚äà‚Üë(p).
4. The map ‚Üë: Pop ‚ÜíU(P) can be depicted:
c
b
a
{c}
{b}
{b, c}
{a, b, c}
Solution to Exercise 1.67.
Suppose (P, ‚â§P) is a discrete preorder and that (Q, ‚â§Q) is any preorder. We want to show that every
function f : P ‚ÜíQ is monotone, i.e. that if p1 ‚â§P p2 then f (p1) ‚â§Q f (p2). But in P we have p1 ‚â§P p2
iÔ¨Äp1  p2; that‚Äôs what discrete means. If p1 ‚â§P p2 then p1  p2, so f (p1)  f (p2), so f (p1) ‚â§f (p2).
Solution to Exercise 1.69.
Let X  Z  {. . . , ‚àí2, ‚àí1, 0, 1, . . .} be the set of all integers, and let Y  {n, z, p}; let f : X ‚ÜíY send
negative numbers to n, zero to z, and positive integers to p. This is surjective because all three elements
of Y are hit.
We consider two partitions of Y, namely P B (nz)(p) and Q B (np)(z). Technically, these are notation
for {{n, z}, {p}} and {{n, p}, {z}} as sets of disjoint subsets whose union is Y.
Their pulled back
partitions are f ‚àóP  (. . . , ‚àí2, ‚àí1, 0)(1, 2, . . .) and f ‚àóQ  (0)(. . . , ‚àí2, ‚àí1, 1, 2, . . .), or technically
f ‚àó(P)  {{x ‚ààZ | x ‚â§0}, {x ‚ààZ | x ‚â•1}}
and
f ‚àó(Q)  {{0}, {x ‚ààZ | x , 0}}.

A.1. SOLUTIONS FOR CHAPTER 1
265
Solution to Exercise 1.71.
We have preorders (P, ‚â§P), (Q, ‚â§Q), and (R, ‚â§R), and we have monotone maps f : P ‚ÜíQ and 1 : Q ‚ÜíR.
1. To see that idP is monotone, we need to show that if p1 ‚â§P p2 then idP(p1) ‚â§idP(p2). But
idP(p)  p for all p ‚ààP, so this is clear.
2. We have that p1 ‚â§P p2 implies f (p1) ‚â§Q f (p2) and that q1 ‚â§Q q2 implies 1(q1) ‚â§R 1(q2). By
substitution, p1 ‚â§P p2 implies 1( f (p1)) ‚â§R 1( f (p2)) which is exactly what is required for ( f # 1)
to be monotone.
Solution to Exercise 1.73.
We need to show that if (P, ‚â§P) is both skeletal and dagger, then it is discrete. So suppose it is skeletal,
i.e. p1 ‚â§p2 and p2 ‚â§p1 implies p1  p2. And suppose it is dagger, i.e. p1 ‚â§p2 implies p2 ‚â§p1. Well
then p1 ‚â§p2 implies p1  p2, and this is exactly the deÔ¨Ånition of P being discrete.
Solution to Exercise 1.77.
The map Œ¶ from Section 1.1.1 took partitions of {‚Ä¢, ‚àó, ‚ó¶} and returned true or false based on whether or
not ‚Ä¢ was in the same partition as ‚àó. We need to see that it‚Äôs actually a monotone map Œ¶: Prt({‚Ä¢, ‚àó, ‚ó¶}) ‚Üí
B. So suppose P, Q are partitions with P ‚â§Q; we need to show that if Œ¶(P)  true then Œ¶(Q)  true.
By deÔ¨Ånition P ‚â§Q means that P is Ô¨Åner than Q: i.e. P diÔ¨Äerentiates more stuÔ¨Ä, and Q lumps more
stuÔ¨Ätogether. Technically, x ‚àºP y implies x ‚àºQ y for all x, y ‚àà{‚Ä¢, ‚àó, ‚ó¶}. Applying this to ‚Ä¢, ‚àógives the
result.
Solution to Exercise 1.79.
Given a function f : P ‚ÜíQ, we have f ‚àó: U(Q) ‚ÜíU(P) given by U 7‚Üíf ‚àí1(U). But upper sets in Q are
classiÔ¨Åed by monotone maps u : Q ‚ÜíB, and similarly for P; our job is to show that f ‚àó(U) is given by
composing the classiÔ¨Åer u with f .
Given an upper set U ‚äÜQ, let u : Q ‚ÜíB be the corresponding monotone map, which sends q 7‚Üítrue
iÔ¨Äq ‚ààU.
Then ( f # u): P ‚ÜíB sends p 7‚Üítrue iÔ¨Äf (p) ‚ààU; it corresponds to the upper set
{p ‚ààP | f (p) ‚ààU} which is exactly f ‚àí1(U).
Solution to Exercise 1.80.
1. 0 is a lower bound for S  {
1
n+1 | n ‚ààN} because 0 ‚â§
1
n+1 for any n ‚ààN.
2. Suppose that b is a lower bound for S; we want to see that b ‚â§0. If one believes to the contrary
that 0 < b, then consider 1/b; it is a real number so we can Ô¨Ånd a natural number n that‚Äôs bigger
1/b < n < n + 1. This implies 1 < b(n + 1) and hence
1
n+1 < b, but that is a contradiction of b
being a lower bound for S. The false believer is defeated!
Solution to Exercise 1.85.
We have a preorder (P, ‚â§), an element p ‚ààP, and a subset A  {p} with one element.
1. To see that √ì A  p, we need to show that p ‚â§a for all a ‚ààA and that if q ‚â§a for all a ‚ààA then
q ‚â§p. But the only a ‚ààA is a  p, so both are obvious.
2. We know p is a meet of A, so if q is also a meet of A then q ‚â§a for all a ‚ààA so q ‚â§p; similarly
p ‚â§a for all a ‚ààA, so p ‚â§q. Then by deÔ¨Ånition we have p  q, and since (P, ‚â§) is a partial order,
p  q.
3. The analogous facts are true when √ì is replaced by √î; the only change in the argument is to
replace ‚â§by ‚â•and ‚Äòmeet‚Äô by ‚Äòjoin‚Äô everywhere.
Solution to Exercise 1.90.
The meet of 4 and 6 is the highest number in the order that divides both of them; the numbers dividing
both are 1 and 2, and 2 is higher, so 4 ‚àß6  2. Similar reasoning shows that 4 ‚à®6  12. The meet is the
‚Äògreatest common divisor‚Äô and the join is the ‚Äòleast common multiple,‚Äô and this holds up for all pairs
m, n ‚ààN not just 4, 6.

266
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.94.
Since f is monotone, the facts that a ‚â§a ‚à®b and b ‚â§a ‚à®b imply that f (a) ‚â§f (a ‚à®b) and f (b) ‚â§f (a ‚à®b).
But by deÔ¨Ånition of join, f (a) ‚à®f (b) is the largest element with that property, so f (a) ‚à®f (b) ‚â§f (a ‚à®b),
as desired.
Solution to Exercise 1.98.
By analogy with Example 1.97, the right adjoint for (3 √ó ‚àí) should be ‚åä‚àí/3‚åã. But to prove this is correct,
we must show that for any any r ‚ààR and z ‚ààZ we have z ‚â§‚åär/3‚åãiÔ¨Ä3 ‚àóz ‚â§r.
Suppose the largest integer below r/3 is z‚Ä≤ B ‚åär/3‚åã. Then z ‚â§z‚Ä≤ implies 3‚àóz ‚â§3‚àóz‚Ä≤ ‚â§3‚àór/3  r, giving
one direction. For the other, suppose 3‚àóz ‚â§r. Then dividing both sides by 3, we have z  3‚àóz/3 ‚â§r/3.
Since z is an integer below r/3 it is below ‚åär/3‚åãbecause ‚åär/3‚åãis the greatest integer below r/3, and we
are done.
Solution to Exercise 1.99.
1. We need to check that for all nine pairs {(p, q) | 1 ‚â§p ‚â§3 and 1 ‚â§q ‚â§3} we have f (p) ‚â§q iÔ¨Ä
p ‚â§1(q), where f and 1 are the functions shown here:
P
1‚Ä¢
2‚Ä¢
3‚Ä¢
P
Q
‚Ä¢
1
‚Ä¢
2
‚Ä¢
3
Q
f
1
When p  q  1 we have f (p)  1 and 1(q)  2, so both f (p)  1 ‚â§1  q and p  1 ‚â§1(q);
it works! Same sort of story happens when (p, q) is (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), and (3, 3). A
diÔ¨Äerent story happens for p  3, q  1 and p  3, q  2. In those cases f (p)  3 and 1(q)  2,
and neither inequality holds: f (p) ‚â∞q and p ‚â∞1(q). But that‚Äôs Ô¨Åne, we still have f (p) ‚â§q iÔ¨Ä
p ‚â§1(q) in all nine cases, as desired.
2.
P
1‚Ä¢
2‚Ä¢
3‚Ä¢
P
Q
‚Ä¢
1
‚Ä¢
2
‚Ä¢
3
Q
f
1
Here f is not left adjoint to 1 because f (2) ‚â∞1 but 2 ‚â§1(1).
Solution to Exercise 1.101.
1. Let‚Äôs suppose we have a monotone map L: Z ‚ÜíR that‚Äôs left adjoint to ‚åà‚àí/3‚åâand see what
happens. Writing C(r) B ‚åàr/3‚åâ, then for all z ‚ààZ and r ‚ààR we have L(z) ‚â§r iÔ¨Äz ‚â§C(r)
by deÔ¨Ånition of adjunction. So take z  1 and r  .01; then ‚åàr/3‚åâ 1 so z ‚â§C(r), and hence
L(z) ‚â§r, i.e. L(1) ‚â§0.01. In the same way L(1) ‚â§r for all r > 0, so L(1) ‚â§0. By deÔ¨Ånition of
adjunction 1 ‚â§C(0)  ‚åà0/3‚åâ 0, a contradiction.
2. There‚Äôs no left adjoint, because starting with an arbitrary one, we derived a contradiction.
Solution to Exercise 1.103.
We have S  {1, 2, 3, 4}, T  {12, 3, 4}, and 1 : S ‚ÜíT the ‚Äúobvious‚Äù function between them; see
Example 1.102. Take c1, c2, c3, c4 to be the following partitions:
1
2
3
4
1
2
3
4
1
2
3
4
1
2
3
4
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
c1 
c2 
c3 
c4 

A.1. SOLUTIONS FOR CHAPTER 1
267
Then the induced partitions 1!(c1), 1!(c2), 1!(c3), and 1!(c4) on T are:
12
3
4
12
3
4
12
3
4
12
3
4
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
1!(c1) 
1!(c2) 
1!(c3) 
1!(c4) 
Solution to Exercise 1.105.
Here are the partitions on S  {1, 2, 3, 4} induced via 1‚àóby the Ô¨Åve partitions on T  {12, 3, 4}:
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢ ‚Ä¢ ‚Ä¢
Solution to Exercise 1.106.
1. We choose the following partition c on S and compute its pushforward 1!(c):
1
2
3
4
‚Ä¢
‚Ä¢
c 
12
3
4
‚Ä¢
‚Ä¢
1!(c) 
2. Let d be the partition as shown, which was chosen to be coarser than 1!(c).
12
3
4
‚Ä¢
d 
3. Let e be the partition as shown, which was chosen to not be coarser than 1!(c).
12
3
4
‚Ä¢
‚Ä¢
e 
4. Here are 1‚àó(d) and 1‚àó(e):
1
2
3
4
1
2
3
4
‚Ä¢
‚Ä¢
‚Ä¢
1‚àó(d) 
1‚àó(e) 
5. Comparing c, the left-hand partition in part 1., with 1‚àó(d) and 1‚àó(e), we indeed have c ‚â§1‚àó(d)
but c ‚â∞1‚àó(e), as desired.
Solution to Exercise 1.109.
Suppose P and Q are preorders, and that f : P ‚áÜQ :1 are monotone maps.
1. Suppose f is left adjoint to 1. By deÔ¨Ånition this means f (p) ‚â§q iÔ¨Äp ‚â§1(q), for all p ‚ààP and
q ‚ààQ. Then starting with the reÔ¨Çexivity fact 1(q) ‚â§1(q), the deÔ¨Ånition with p B 1(q) gives
f (1(q)) ‚â§q for all q.
2. Suppose that p ‚â§1( f (p)) and f (1(q)) ‚â§q for all p ‚ààP and q ‚ààQ. We Ô¨Årst want to show that
p ‚â§1(q) implies f (p) ‚â§q, so assume p ‚â§1(q). Then applying the monotone map f to both
sides, we have f (p) ‚â§f (1(q)), and then by transitivity f (1(q)) ‚â§q implies f (p) ‚â§q, as desired.
The other direction is similar.

268
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 1.110.
1. Suppose that f : P ‚ÜíQ has two right adjoints, 1, 1‚Ä≤: Q ‚ÜíP. We want to show that 1(q)  1‚Ä≤(q)
for all q ‚ààQ. We will prove 1(q) ‚â§1‚Ä≤(q); the inequality 1‚Ä≤(q) ‚â§1(q) is similar. To do this, we use
the fact that p ‚â§1‚Ä≤( f (p)) and f (1(q)) ‚â§q for all p, q by Eq. (1.108). Then the trick is to reason as
follows:
1(q) ‚â§1‚Ä≤( f (1(q))) ‚â§1‚Ä≤(q).
2. It is the same for left adjoints.
Solution to Exercise 1.112.
Suppose f : P ‚ÜíQ is left adjoint to 1 : Q ‚ÜíP. Let A ‚äÜP be any subset and let j B √î A be its join.
Then since f is monotone f (a) ‚â§f (j) for all a ‚ààA, so f (j) is an upper bound for the set f (A). We
want to show it is the least upper bound, so take any other upper bound b for f (A), meaning we have
f (a) ‚â§b for all a ‚ààA. Then by deÔ¨Ånition of adjunction, we also have a ‚â§1(b) for all a ‚ààA. By
deÔ¨Ånition of join, we have j ‚â§1(b). Again by deÔ¨Ånition of adjunction f (j) ‚â§b, as desired.
Solution to Exercise 1.114.
We want to show that in the following picture, 1 is really right adjoint to f :
1‚Ä¢
2‚Ä¢
3.9‚Ä¢
4‚Ä¢
P B
1‚Ä¢
2‚Ä¢
4‚Ä¢
: Q
1
f
Here 1 preserves labels and f rounds 3.9 to 4.
There are twelve tiny things to check: for each p ‚ààP and q ‚ààQ, we need to see that f (p) ‚â§q iÔ¨Äp ‚â§1(q).
p
q
f (p)
1(q)
f (p) ‚â§? q
p ‚â§? 1(q)
same?
1
1
1
1
yes
yes
yes!
1
2
1
2
no
no
yes!
1
4
1
4
yes
yes
yes!
2
1
2
1
no
no
yes!
2
2
2
2
yes
yes
yes!
2
4
2
4
yes
yes
yes!
3.9
1
4
1
no
no
yes!
3.9
2
4
2
no
no
yes!
3.9
4
4
4
yes
yes
yes!
4
1
4
1
no
no
yes!
4
2
4
2
no
no
yes!
4
4
4
4
yes
yes
yes!
Solution to Exercise 1.118.
Consider the function shown below, which ‚Äúprojects straight down‚Äù:
‚Ä¢a
‚Ä¢b
‚Ä¢c
Y B
‚Ä¢
a1
‚Ä¢
c1
‚Ä¢
c2
X B
f

A.1. SOLUTIONS FOR CHAPTER 1
269
1. Let B1 B {a, b} and B2 B {c}. Then f ‚àó(B1)  {a1} and f ‚àó(B2)  {c1, c2}.
2. Let A1 B ¬ú and A2 B {a1, c1}. Then f!(A1)  ¬ú and f!(A2)  {a, c}.
3. With the same A1 and A2, we compute f‚àó(A1)  {b} and f‚àó(A2)  {a, b}.
Solution to Exercise 1.119.
Assume f : P ‚ÜíQ is left adjoint to 1 : Q ‚ÜíP.
1. It is part of the deÔ¨Ånition of adjunction (Proposition 1.107) that p ‚â§1( f (p)), and of course 1( f (p))
and ( f # 1)(p) mean the same thing.
2. We want to show that 1( f (1( f (p)))) ‚â§1( f (p)) and 1( f (p)) ‚â§1( f (1( f (p)))) for all p. The latter
is just the fact that p‚Ä≤ ‚â§1( f (p‚Ä≤)) for any p‚Ä≤, applied with 1( f (p)) in place of p‚Ä≤. The former uses
that f (1(q)) ‚â§q, with f (p) substituted for q: this gives f (1( f (p))) ‚â§f (p), and then we apply 1
to both sides.
Solution to Exercise 1.124.
We denote tuples (a, b) by ab for space reasons. So the relation {(1, 1), (1, 2), (2, 1)} will be denoted
{11, 12, 21}.
{11, 12, 21, 22}
{11, 12, 21}
{11, 12, 22}
{11, 21, 22}
{12, 21, 22}
{11, 12}
{11, 21}
{11, 22}
{12, 21}
{12, 22}
{21, 22}
{11}
{12}
{21}
{22}
¬ú
Solution to Exercise 1.125.
Let S B {1, 2, 3}.
1. Let ‚â§be the preorder with 1 ‚â§2, and of course 1 ‚â§1, 2 ‚â§2, and 3 ‚â§3.
Then U(‚â§) 
{(1, 1), (1, 2), (2, 2), (3, 3)}.
2. Let Q B {(1, 1)} and Q‚Ä≤ B {(2, 1)}.
3. Theclosure Cl(Q)of Q isthesmallest preorder containing(1, 1), which is Cl(Q)  {(1, 1), (2, 2), (3, 3)}.
Similarly, Cl(Q‚Ä≤)  {(1, 1), (2, 1), (2, 2), (3, 3)}. It is easy to see that Cl(Q) ‚äë‚â§because every or-
dered pair in Cl(Q) is also in ‚â§.
4. It is easy to see that Cl(Q‚Ä≤) @ ‚â§because the ordered pair (2, 1) is in Cl(Q‚Ä≤) but is not in ‚â§.

270
APPENDIX A. EXERCISE SOLUTIONS
A.2
Solutions for Chapter 2.
Solution to Exercise 2.5.
The expert is right! The proposal violates property (a) when x1  ‚àí1, x2  0, y1  ‚àí1, and y2  1.
Indeed ‚àí1 ‚â§‚àí1 and 0 ‚â§1, but ‚àí1 ‚àó0  0 ‚â∞‚àí1  ‚àí1 ‚àó1.
Solution to Exercise 2.8.
To check that (Disc(M), , ‚àó, e) is a symmetric monoidal preorder, we need to check our proposed data
obeys conditions (a)-(d) of DeÔ¨Ånition 2.2. Condition (a) just states the tautology that x1 ‚äóx2  x1 ‚äóx2,
conditions (b) and (c) are precisely the equations Eq. (2.7), and (d) is the commutativity condition. So
we‚Äôre done. We leave it to you to decide whether we were telling the truth when we said it was easy.
Solution to Exercise 2.20.
1. Here is a line by line proof, where we write the reason for each step in parentheses on the right.
Recall we call the properties (a) and (c) in DeÔ¨Ånition 2.2 monotonicity and associativity respectively.
t + u ‚â§(v + w) + u
(monotonicity, t ‚â§v + w, u ‚â§u)
 v + (w + u)
(associativity)
‚â§v + (x + z)
(monotonicity, v ‚â§v, w + u ‚â§x + v)
 (v + x) + z
(associativitiy)
‚â§y + z.
(monotonicity, v + x ‚â§y, z ‚â§z)
2. We use reÔ¨Çexivity when we assert that u ‚â§u, v ‚â§v and z ‚â§z, and use transitivity to assert that
the above sequence of inequalities implies the single inequality t + u ‚â§y + z.
3. We know that the symmetry axiom is not necessary because no pair of wires cross.
Solution to Exercise 2.21.
Condition (a), monotonicity, says that if x ‚Üíy and z ‚Üíw are reactions, then x + z ‚Üíy + w is a
reaction. Condition (b), unitality, holds as 0 represents having no material, and adding no material to
some other material does not change it. Condition (c), associativity, says that when combining three
collections x, y, and z of molecules it doesn‚Äôt matter whether you combine x and y and then z, or
combine x with y already combined with z. Condition (d), symmetry, says that combining x with y is
the same as combining y with x. All these are true in our model of chemistry, so (Mat, ‚Üí, 0, +) forms
a symmetric monoidal preorder.
Solution to Exercise 2.29.
The monoidal unit must be false. The symmetric monoidal preorder does satisfy the rest of the
conditions; this can be veriÔ¨Åed just by checking all cases.
Solution to Exercise 2.31.
The monoidal unit is the natural number 1. Since we know that (N, ‚â§) is a preorder, we just need to
check that ‚àóis monotonic, associative, unital with 1, and symmetric. These are all familiar facts from
arithmetic.
Solution to Exercise 2.33.
This proposal is not monotonic: we have 1|1 and 1|2, but (1 + 1) ‚à§(1 + 2).
Solution to Exercise 2.34.
1.
min
no
maybe
yes
no
no
no
no
maybe
no
maybe
maybe
yes
no
maybe
yes

A.2. SOLUTIONS FOR CHAPTER 2
271
2. We need to show that (a) if x ‚â§y and z ‚â§w, then min(x, z) ‚â§min(y, w), (b) min(x, yes)  x 
min(yes, x), (c) min(min(x, y), z)  min(x, min(y, z)), and (d) min(x, y)  min(y, z). The most
straightforward way is to just check all cases.
Solution to Exercise 2.35.
Yes, (P(S), ‚â§, S, ‚à©) is a symmetric monoidal preorder.
Solution to Exercise 2.36.
Depending on your mood, you might come up with either of the following. First, we could take the
monoidal unit to be some statement true that is true for all natural numbers, such as ‚Äún is a natural
number.‚Äù We can pair this unit with the monoidal product ‚àß, which takes statements P and Q and
makes the statement P ‚àßQ, where (P ‚àßQ)(n) is true if P(n) and Q(n) are true, and false otherwise.
Then (PropN, ‚â§, true, ‚àß) forms a symmetric monoidal preorder.
Another option is to take deÔ¨Åne false to be some statement that is false for all natural numbers, such
as ‚Äún + 10 ‚â§1‚Äù or ‚Äún is made of cheese.‚Äù We can also deÔ¨Åne ‚à®such that (P ‚à®Q)(n) is true if and only if
at least one of P(n) and Q(n) is true. Then (PropN, ‚â§, false, ‚à®) forms a symmetric monoidal preorder.
Solution to Exercise 2.39.
Unitality and associativity have nothing to do with the order in Xop: they simply state that I ‚äóx 
x  x ‚äóI, and (x ‚äóy) ‚äóz  x ‚äó(y ‚äóz). Since these are true in X, they are true in Xop. Symmetry is
slightly trickier, since in only asks that x ‚äóy is equivalent to y ‚äóx. Nonetheless, this is still true in Xop
because it is true in X. Indeed the fact that (x ‚äóy)  (y ‚äóx) in X means that (x ‚äóy) ‚â§(y ‚äóx) and
(y ‚äóx) ‚â§(x ‚äóy) in X, which respectively imply that (y ‚äóx) ‚â§(x ‚äóy) and (x ‚äóy) ‚â§(y ‚äóx) in Xop, and
hence that (x ‚äóy)  (y ‚äóx) in Xop too.
Solution to Exercise 2.40.
1. The preorder Costop has underlying set [0, ‚àû], and the usual increasing order on real numbers
‚â§as its order.
2. Its monoidal unit is 0.
3. Its monoidal product is +.
Solution to Exercise 2.43.
1. The map 1 is monotonic as 1(false)  ‚àû‚â•0  1(true), satisÔ¨Åes condition (a) since 0 ‚â•0 
1(true), and satisÔ¨Åes condition (b) since
1(false) + 1(false)  ‚àû+ ‚àû‚â•‚àû 1(false ‚àßfalse)
1(false) + 1(true)  ‚àû+ 0 ‚â•‚àû 1(false ‚àßtrue)
1(true) + 1(false)  0 + ‚àû‚â•‚àû 1(true ‚àßfalse)
1(true) + 1(true)  0 + 0 ‚â•0  1(true ‚àßtrue).
2. Since all the inequalities regarding (a) and (b) above are in fact equalities, 1 is a strict monoidal
monotone.
Solution to Exercise 2.44.
The answer to all these questions is yes: d and u are both strict monoidal monotones. Here is one way
to interpret this. The function d asks ‚Äòis x  0?‚Äô. This is monotonic, 0 is 0, and the sum of two elements
of [0, ‚àû] is 0 if and only if they are both 0. The function u asks ‚Äòis x Ô¨Ånite?‚Äô. Similarly, this is monotonic,
0 is Ô¨Ånite, and the sum of x and y is Ô¨Ånite if and only if x and y are both Ô¨Ånite.
Solution to Exercise 2.45.
1. Yes, multiplication is monotonic in ‚â§, unital with respect to 1, associative, and symmetric, so
(N, ‚â§, 1, ‚àó) is a monoidal preorder. We also met this preorder in Exercise 2.31.

272
APPENDIX A. EXERCISE SOLUTIONS
2. The map f (n)  1 for all n ‚ààN deÔ¨Ånes a monoidal monotone f : (N, ‚â§, 0, +) ‚Üí(N, ‚â§, 1, ‚àó). (In
fact, it is unique! Why?)
3. (Z, ‚â§, ‚àó, 1) is not a monoidal preorder because ‚àóis not monotone. Indeed ‚àí1 ‚â§0 but (‚àí1 ‚àó‚àí1) ‚â∞
(0 ‚àó0).
Solution to Exercise 2.50.
1. Let (P, ‚â§) be a preorder. How is this a Bool-category? Following Example 2.47, we can construct
a Bool-category XP with P as its set of objects, and with XP(p, q) B true if p ‚â§q, and XP(p, q) B
false otherwise. How do we turn this back into a preorder? Following the proof of Theorem 2.49,
we construct a preorder with underlying set Ob(XP)  P, and with p ‚â§q if and only if XP(p, q) 
true. This is precisely the preorder (P, ‚â§)!
2. Let X be a Bool-category. By the proof of Theorem 2.49, we construct a preorder (Ob(X), ‚â§),
where x ‚â§y if and only if X(x, y)  true. Then, following our generalization of Example 2.47 in
1., we construct a Bool-category X‚Ä≤ whose set of objects is Ob(X), and such that X‚Ä≤(x, y)  true
if and only if x ‚â§y in (Ob(X), ‚â§). But by construction, this means X‚Ä≤(x, y)  X(x, y). So we get
back the Bool-category we started with.
Solution to Exercise 2.52.
The distance d(US, Spain) is bigger: the distance from, for example, San Diego to anywhere is Spain is
bigger than the distance from anywhere in Spain to New York City.
Solution to Exercise 2.55.
The diÔ¨Äerence between a Lawvere metric space‚Äîthat is, a category enriched over ([0, ‚àû], ‚â•, 0, +)‚Äîand
a category enriched over (R‚â•0, ‚â•, 0, +) is that in the latter, inÔ¨Ånite distances are not allowed between
points. You might thus call the latter a Ô¨Ånite-distance Lawvere metric space.
Solution to Exercise 2.58.
The table of distances for X is
d(‚Üó)
A
B
C
D
A
0
6
3
11
B
2
0
5
5
C
5
3
0
8
D
11
9
6
0
Solution to Exercise 2.60.
The matrix of edge weights of X is
MX 
‚Üó
A
B
C
D
A
0
‚àû
3
‚àû
B
2
0
‚àû
5
C
‚àû
3
0
‚àû
D
‚àû
‚àû
6
0
Solution to Exercise 2.61.
A NMY-category X is a set X together with, for all pairs of elements x, y in X, a value X(x, y) equal
to no, maybe, or yes. Moreover, we must have X(x, x)  yes and min(X(x, y), X(y, z)) ‚â§X(x, z) for all
x, y, z. So a NMY-category can be thought of as set of points together with an statement‚Äîno, maybe,
or yes‚Äîof whether it is possible to get from one point to another. In particular, it‚Äôs always possible to
get to a point if you‚Äôre already there, and it‚Äôs as least as possible to get from x to z as it is to get from x
to y and then y to z.
Solution to Exercise 2.62.
Here is one way to do this task.

A.2. SOLUTIONS FOR CHAPTER 2
273
1.
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
{boat}
{boat}
{foot, boat}
{foot, car}
{foot, car}
2. The corresponding M-category, call it X, has hom-objects:
X(‚Üó)
A
B
C
D
A
M
{boat}
¬ú
{boat}
B
¬ú
M
¬ú
{boat}
C
{foot, boat}
{boat}
M
M
D
{foot}
¬ú
{foot, car}
M
For example, to compute the hom-object X(C, D), we notice that there are two paths: C ‚ÜíA ‚Üí
B ‚ÜíD and C ‚ÜíD. For the Ô¨Årst path, the intersection is the set {boat}. For the second path, the
intersection in the set {foot, car}. Their union, and thus the hom-object X(C, D), is the entire set
M.
This computation contains the key for why X is a M-category: by taking the union over all paths,
we ensure that X(x, y) ‚à©X(y, z) ‚äÜX(x, z) for all x, y, z.
3. The person‚Äôs interpretation looks right to us.
Solution to Exercise 2.63.
1.
A‚Ä¢
‚Ä¢
B
‚Ä¢
C
5
10
10
6
10
2. The matrix M with (x, y)th entry equal to the maximum, taken over all paths p from x to y, of
the minimum edge label in p is
M(‚Üó)
A
B
C
A
‚àû
6
10
B
10
‚àû
10
C
10
6
‚àû
3. This is a matrix of hom-objects for a W-category since the diagonal values are all equal to the
monoidal unit ‚àû, and because min(M(x, y), M(y, z)) ‚â§M(x, y) for all x, y, z ‚àà{A, B, C}.
4. One interpretation is as a weight limit (not to be confused with ‚Äòweighted limit,‚Äô a more advanced
categorical notion), for example for trucking cargo between cities. The hom-object indexed by
a pair of points (x, y) describes the maximum cargo weight allowed on that route. There is no
weight limit on cargo that remains at some point x, so the hom-object from x to x is always
inÔ¨Ånite. The maximum weight that can be trucked from x to z is always at least the minimum of
that that can be trucked from x to y and then y to z. (It is ‚Äòat least‚Äô this much because there may
be some other, better route that does not pass through y.)
Solution to Exercise 2.67.
‚Ä¢
Boston
‚Ä¢
US
‚Ä¢
Spain

274
APPENDIX A. EXERCISE SOLUTIONS
This preorder describes the ‚Äòis a part of‚Äô relation. That is, x ‚â§y when d(x, y)  0, which happens when
x is a part of y. So Boston is a part of the US, and Spain is a part of Spain, but the US is not a part of
Boston.
Solution to Exercise 2.68.
1. Recall the monoidal monotones d and u from Exercise 2.44. The function f is equal to d; let 1 be
equal to u.
2. Let X be the Lawvere metric space with two objects A and B, such that d(A, B)  d(B, A)  5.
Then we have X f 
A‚Ä¢
B‚Ä¢
while X1 
A‚Ä¢
B‚Ä¢ .
Solution to Exercise 2.73.
1. An extended metric space is a Lawvere metric space that obeys in addition the properties (b) if
d(x, y)  0 then x  y, and (c) d(x, y)  d(y, x) of DeÔ¨Ånition 2.51. Let‚Äôs consider the dagger
condition Ô¨Årst. It says that the identity function to the opposite Cost-category is a functor, and
so for all x, y we must have d(x, y) ‚â§d(y, x). But this means also that d(y, x) ‚â§d(x, y), and so
d(x, y)  d(y, x). This is exactly property (c).
Now let‚Äôs consider the skeletality condition. This says that if d(x, y)  0 and d(y, x)  0, then
x  y. Thus when we have property (c), d(x, y)  d(y, x), this is equivalent to property (b). Thus
skeletal dagger Cost-categories are the same as extended metric spaces!
2. Recall from Exercise 1.73 that skeletal dagger preorders are sets. The analogy ‚Äúpreorders are
to sets as Lawvere metric spaces are to extended metric spaces‚Äù is thus the observation that
just as extended metric spaces are skeletal dagger Cost-categories, sets are skeletal dagger Bool-
categories.
.
Solution to Exercise 2.75.
1. Let (x, y) ‚ààX √ó Y. Since X and Y are V-categories, we have I ‚â§X(x, x) and I ‚â§Y(y, y). Thus
I  I ‚äóI ‚â§X(x, x) ‚äóY(y, y)  (X √ó Y) (x, y), (x, y)
.
2. Using the deÔ¨Ånition of product hom-objects, and the symmetry and monotonicity of ‚äówe have
(X √ó Y) (x1, y1), (x2, y2)
‚äó(X √ó Y) (x2, y2), (x3, y3)
 X(x1, x2) ‚äóY(y1, y2) ‚äóX(x2, x3) ‚äóY(y2, y3)
 X(x1, x2) ‚äóX(x2, x3) ‚äóY(y1, y2) ‚äóY(y2, y3)
‚â§X(x1, x3) ‚äóY(y1, y3)
 (X √ó Y) (x1, y1), (x3, y3)
.
3. In particular, we use the symmetry, to conclude that Y(y1, y2) ‚äóX(x2, x3)  X(x2, x3) ‚äóY(y1, y2).
Solution to Exercise 2.78.
We just apply DeÔ¨Ånition 2.74(ii): (R √ó R) (5, 6), (‚àí1, 4)
 R(5, ‚àí1) + R(6, 4)  6 + 2  8.
Solution to Exercise 2.82.
1. The function ‚àí‚äóv : V ‚ÜíV is monotone, because if u ‚â§u‚Ä≤ then u ‚äóv ‚â§u‚Ä≤‚äóv by the monotonicity
condition (a) in DeÔ¨Ånition 2.2.
2. Let a B (v ‚ä∏w) in Eq. (2.80). The right hand side is thus (v ‚ä∏w) ‚â§(v ‚ä∏w), which is true by
reÔ¨Çexivity. Thus the left hand side is true too. This gives ((v ‚ä∏w) ‚äóv) ‚â§w.
3. Let u ‚â§u‚Ä≤.
Then, using 2., (v ‚ä∏u) ‚äóv ‚â§u ‚â§u‚Ä≤.
Applying Eq. (2.80), we thus have
(v ‚ä∏u) ‚â§(v ‚ä∏u‚Ä≤). This shows that the map (v ‚ä∏‚àí): V ‚ÜíV is monotone.
4. Eq. (2.80) is exactly the adjointness condition from DeÔ¨Ånition 1.95, except for the fact that we do
not know (‚àí‚äóv) and (v ‚ä∏‚àí) are monotone maps. We proved this, however, in items 1 and 3
above.

A.2. SOLUTIONS FOR CHAPTER 2
275
Solution to Exercise 2.84.
We need to Ô¨Ånd the hom-element. This is given by implication. That is, deÔ¨Åne the function x ‚áíy by
the table
‚áí
false
true
false
true
true
true
false
true
Then (a ‚àßv) ‚â§w if and only if a ‚â§(v ‚áíw). Indeed, if v  false then a ‚àßfalse  false, and so the
left hand side is always true. But (false ‚áíw)  true, so the right hand side is always true too. If
v  true, then a ‚àßtrue  a so the left hand side says a ‚â§w. But (true ‚áíw)  w, so the right hand
side is the same. Thus ‚áídeÔ¨Ånes a hom-element as per Eq. (2.80).
Solution to Exercise 2.93.
We showed in Exercise 2.84 that Bool is symmetric monoidal closed, and in Exercise 1.7 and Exam-
ple 1.88 that the join is given by the OR operation ‚à®. Thus Bool is a quantale.
Solution to Exercise 2.94.
Yes, the powerset monoidal preorder (P(S), ‚äÜ, S, ‚à©) is a quantale. The hom-object B ‚ä∏C is given by
B ‚à™C, where B is the complement of B: it contains all elements of S not contained in B. To see that this
satisÔ¨Åes Eq. (2.80), note that if (A ‚à©B) ‚äÜC, then
A  (A ‚à©B) ‚à™(A ‚à©B) ‚äÜB ‚à™C.
On the other hand, if A ‚äÜ(B ‚à™C), then
A ‚à©B ‚äÜ(B ‚à™C) ‚à©B  (B ‚à©B) ‚à™(C ‚à©B)  C ‚à©B ‚äÜC.
So (P(S), ‚äÜ, S, ‚à©) is monoidal closed. Furthermore, joins are given by union of subobjects, so it is a
quantale.
Solution to Exercise 2.92.
1a. In Bool, (√î ¬ú)  false, the least element.
1b. In Cost, (√î ¬ú)  ‚àû. This is because we use the opposite order ‚â•on [0, ‚àû], so √î ¬ú is the greatest
element of [0, ‚àû]. Note that in this case our convention from DeÔ¨Ånition 2.90, where we denote
(√î ¬ú)  0, is a bit confusing! Beware!
2a. In Bool, x ‚à®y is the usual join, OR.
2b. In Cost, x ‚à®y is the minimum min(x, y). Again because we use the opposite order on [0, ‚àû], the
join is the greatest number less than or equal to x and y.
Solution to Exercise 2.103.
The 2 √ó 2-identity matrices for (N, ‚â§, 1, ‚àó), Bool, and Cost are respectively
1
0
0
1

,
 true
false
false
true

,
and
 0
‚àû
‚àû
0

.
Solution to Exercise 2.104.
1. We Ô¨Årst use Proposition 2.87 (2) and symmetry to show that for all v ‚ààV, 0 ‚äóv  0.
0 ‚äóv  v ‚äó0 

v ‚äó
√ú
a‚àà¬ú
a


√ú
a‚àà¬ú
(v ‚äóa)  0.

276
APPENDIX A. EXERCISE SOLUTIONS
Then we may just follow the deÔ¨Ånition in Eq. (2.101):
IX ‚àóM(x, y) 
√ú
x‚Ä≤‚ààX
IX(x, x‚Ä≤) ‚äóM(x‚Ä≤, y)
  IX(x, x) ‚äóM(x, y)
‚à®¬©¬≠
¬´
√ú
x‚Ä≤‚ààX,x‚Ä≤,x
IX(x, x‚Ä≤) ‚äóM(x‚Ä≤, y)¬™¬Æ
¬¨
  I ‚äóM(x, y)
‚à®¬©¬≠
¬´
√ú
x‚Ä≤‚ààX,x‚Ä≤,x
0 ‚äóM(x‚Ä≤, y)¬™¬Æ
¬¨
 M(x, y) ‚à®0  M(x, y).
2. This again follows from Proposition 2.87 (2) and symmetry, making use also of the associativity
of ‚äó:
((M ‚àóN) ‚àóP)(w, z) 
√ú
y‚ààY
 √ú
x‚ààX
M(w, x) ‚äóN(x, y)

‚äóP(y, z)

√ú
y‚ààY,x‚ààX
M(w, x) ‚äóN(x, y) ‚äóP(y, z)

√ú
x‚ààX
M(w, x) ‚äó
 √ú
y‚ààY
N(x, y) ‚äóP(y, z)

 (M ‚àó(N ‚àóP))(w, z).
Solution to Exercise 2.105.
We have the matrices
MX 
¬©¬≠¬≠¬≠¬≠
¬´
0
‚àû
3
‚àû
2
0
‚àû
5
‚àû
3
0
‚àû
‚àû
‚àû
6
0
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
M2
X 
¬©¬≠¬≠¬≠¬≠
¬´
0
6
3
‚àû
2
0
5
5
5
3
0
8
‚àû
9
6
0
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
M3
X  M4
X 
¬©¬≠¬≠¬≠¬≠
¬´
0
6
3
11
2
0
5
5
5
3
0
8
11
9
6
0
¬™¬Æ¬Æ¬Æ¬Æ
¬¨

A.3. SOLUTIONS FOR CHAPTER 3
277
A.3
Solutions for Chapter 3.
Solution to Exercise 3.3.
There are Ô¨Åve non-ID columns in Eq. (3.1)and Ô¨Åve arrows in Eq. (3.2). This is not a coincidence: there
is always one arrow for every non-ID column.
Solution to Exercise 3.9.
To do this precisely, we should deÔ¨Åne concatenation technically. If G  (V, A, s, t) is a graph, deÔ¨Åne a
path in G to be a tuple of the form (v, a1, . . . , an) where v ‚ààV is a vertex, s(a1)  v, and t(ai)  s(ai+1)
for all i ‚àà{1, . . . , n ‚àí1}; the length of this path is n, and this deÔ¨Ånition makes sense for any n ‚ààN. We
say that the source of p is s(p) B v and the target of p is deÔ¨Åned to be
t(p) B
(
v if n  0
t(an) if n ‚â•1
Two paths p  (v, a1, . . . , am) and q  (w, b1, . . . , bn) can be concatenated if t(p)  s(q), in which case
the concatenated path p # q is deÔ¨Åned to be
(p # q) B (v, a1, . . . , am, b1, . . . , bn).
We are now ready to check unitality and associativity. A path p is an identity in Free(G) iÔ¨Äp  (v)
for some v ‚ààV. It is easy to see from the above that (v) and (w, b1, . . . , bn) can be concatenated iÔ¨Ä
v  w, in which case the result is (w, b1, . . . , bn). Similarly (v, a1, . . . , am) and (w) can be concatenated
iÔ¨Äw  t(am), in which case the result is (v, a1, . . . , am). Finally, for associativity with p and q as above
and r  (x, c1, . . . , co), the formula readily reads that whichever way they are concatenated, (p # q) # r
or p # (q # r), the result is
(v, a1, . . . , am, b1, . . . , bn, c1, . . . , co).
Solution to Exercise 3.10.
We often like to name identity morphisms by the objects they‚Äôre on, and we do that here: v2 means
idv2. We write ‚ä†when the composite does not make sense (i.e. when the target of the Ô¨Årst morphism
does not agree with the source of the second).
‚Üó
v1
f1
f1 # f2
v2
f2
v3
v1
v1
f1
f1 # f2
‚ä†
‚ä†
‚ä†
f1
‚ä†
‚ä†
‚ä†
f1
f1 # f2
‚ä†
f1 # f2
‚ä†
‚ä†
‚ä†
‚ä†
‚ä†
f1 # f2
v2
‚ä†
‚ä†
‚ä†
v2
f2
‚ä†
f2
‚ä†
‚ä†
‚ä†
‚ä†
‚ä†
f2
v3
‚ä†
‚ä†
‚ä†
‚ä†
‚ä†
v3
Solution to Exercise 3.12.
1. The category 1 has one object v1 and one morphism, the identity idv1.
2. The category 0 is empty; it has no objects and no morphisms.
3. The pattern for number of morphisms in 0, 1, 2, 3 is 0, 1, 3, 6; does this pattern look familiar?
These are the Ô¨Årst few ‚Äòtriangle numbers,‚Äô so we could guess that the number of morphisms in n,
the free category on the following graph
v1‚Ä¢
v2‚Ä¢
¬∑ ¬∑ ¬∑
vn‚Ä¢
f1
f2
fn‚àí1
is 1 + 2 + ¬∑ ¬∑ ¬∑ + n. This makes sense because (and the proof strategy would be to verify that) the
above graph has n paths of length 0, it has n ‚àí1 paths of length 1, and so on: it has n ‚àíi paths
of length i for every 0 ‚â§i ‚â§n.

278
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 3.15.
The correspondence was given by sending a path to its length. Concatenating a path of length m with
a path of length n results in a path of length m + n.
Solution to Exercise 3.16.
Free_square B
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
f
1
h
i
no equations
1. The ten paths are as follows
A,
A # f ,
A # 1,
A # f # h,
A # 1 # i,
B,
B # h,
C,
C # i,
D
2. A # f # h is parallel to A # 1 # i, in that they both have the same domain and both have the same
codomain.
3. A is not parallel to any of the other nine paths.
Solution to Exercise 3.17.
The morphisms in the given diagram are as follows:
A,
A # f ,
A # 1,
A # j,
B,
B # h,
C,
C # i,
D
Note that A # f # h  j  A # 1 # i.
Solution to Exercise 3.19.
There are four morphisms in D, shown below, namely z, s, s # s, and s # s # s:
D B
‚Ä¢z
s
s # s # s # s  s # s
Solution to Exercise 3.21.
The equations that make the graphs into preorders are shown below
G1 
‚Ä¢
‚Ä¢
f
1
f  1
G2 
‚Ä¢a
f
f  a
G3 
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
f
1
h
i
f # h  1 # i
G4 
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
f
1
h
no equations
Solution to Exercise 3.22.
The preorder reÔ¨Çection of a category C has the same objects and either one morphism or none between
two objects, depending on whether or not a morphism between them exists in C. So the preorder
reÔ¨Çection of N has one object and one morphism from it to itself, which must be the identity. In other
words, the preorder reÔ¨Çection of N is 1.

A.3. SOLUTIONS FOR CHAPTER 3
279
Solution to Exercise 3.25.
A function f : 2 ‚Üí3 can be described as an ordered pair ( f (1), f (2)). The nine such functions are
given by the following ordered pairs, which we arrange into a 2-dimensional grid with 3 entries in each
dimension, just for ‚Äúfunzies‚Äù:1
(1, 1)
(1, 2)
(1, 3)
(2, 1)
(2, 2)
(2, 3)
(3, 1)
(3, 2)
(3, 3)
Solution to Exercise 3.30.
1. The inverse to f (a)  2, f (b)  1, f (c)  3 is given by
f ‚àí1(1)  b,
f ‚àí1(2)  a,
f ‚àí1(3)  c.
2. There are 6 distinct isomorphisms. In general, if A and B are sets, each with n elements, then the
number of isomorphisms between them is n-factorial, often denoted n!. So for example there are
5 ‚àó4 ‚àó3 ‚àó2 ‚àó1  120 isomorphisms between {1, 2, 3, 4, 5} and {a, b, c, d, e}.
Solution to Exercise 3.31.
We have to show that for any object c ‚ààC, the identity idc has an inverse, i.e. a morphism f : c ‚Üíc
such that f # idc  idc and idc # f  idc. Take f  idc; this works.
Solution to Exercise 3.32.
1. The monoid in Example 3.13 is not a group, because the morphism s has no inverse. Indeed each
morphism is of the form sn for some n ‚ààN and composing it with s gives sn+1, which is never
s0.p
2. C from Example 3.18 is a group: the identity is always an isomorphism, and the other morphism
s has inverse s.
Solution to Exercise 3.33.
You may have found a person whose mathematical claims you can trust! Whenever you compose two
morphisms in Free(G), their lengths add, and the identities are exactly those morphisms whose length
is 0. In order for p to be an isomorphism, there must be some q such that p # q  id and q # p  id, in
which case the length of p (or q) must be 0.
Solution to Exercise 3.37.
The other three functors 2 ‚Üí3 are shown here:
m0‚Ä¢
‚Ä¢
m1
f1
n0‚Ä¢
n1‚Ä¢
n2‚Ä¢
11
12
m0‚Ä¢
‚Ä¢
m1
f1
n0‚Ä¢
n1‚Ä¢
n2‚Ä¢
11
12
m0‚Ä¢
‚Ä¢
m1
f1
n0‚Ä¢
n1‚Ä¢
n2‚Ä¢
11
12
Solution to Exercise 3.39.
There are nine morphisms in F; as usual we denote identities by the object they‚Äôre on. These morphisms
are sent to the following morphisms in C:
A‚Ä≤ 7‚ÜíA,
f ‚Ä≤ 7‚Üíf ,
1‚Ä≤ 7‚Üí1,
f ‚Ä≤ # h‚Ä≤ 7‚Üíf # h,
1‚Ä≤ # i‚Ä≤ 7‚Üíf # h,
B‚Ä≤ 7‚ÜíB,
h‚Ä≤ 7‚Üíh,
C‚Ä≤ 7‚ÜíC,
i‚Ä≤ 7‚Üíi,
D‚Ä≤ 7‚ÜíD.
1Of course, this is not mere funzies; this is category theory!

280
APPENDIX A. EXERCISE SOLUTIONS
If one of these seems diÔ¨Äerent from the rest, it‚Äôs probably 1‚Ä≤ # i‚Ä≤ 7‚Üíf # h. But note that in fact also
1‚Ä≤ # i‚Ä≤ 7‚Üí1 # i because 1 # i  f # h, so it‚Äôs not an outlier after all.
Solution to Exercise 3.40.
We need to give two functors F, G from
a‚Ä¢
f
‚àí‚Üí
b‚Ä¢ to
a‚Ä≤
‚Ä¢
f1
f2
b‚Ä≤
‚Ä¢ whose on-objects parts are the same and
whose on-morphisms parts are diÔ¨Äerent. There are only two ways to do this, and we choose one of
them:
F(a) B a‚Ä≤,
G(a) B a‚Ä≤,
F(b) B b‚Ä≤,
G(b) B b‚Ä≤,
F( f ) B f1, and G( f ) B f2.
The other way reverses f1 and f2.
Solution to Exercise 3.43.
1. Let C be a category. Then deÔ¨Åning idC : C ‚ÜíC by idC(x)  x for every object and morphism in
C is a functor because it preserves identities idC(idc)  idc  ididC(c) for each object c ‚ààOb(C),
and it preserves composition idC( f # 1)  f # 1  idC( f ) # idC(1) for each pair of composable
morphisms f , 1 in C.
2. Given functors F : C ‚ÜíD and G: D ‚ÜíE, we need to show that F # G is a functor, i.e. that
it preserves preserves identities and compositions.
If c ‚ààC is an object then (F # G)(idc) 
G(F(idc))  G(idF(c))  idG(F(c)) because F and G preserve identities. If f , 1 are composable
morphisms in C then
(F # G)( f # 1)  G(F( f ) # F(1))  G(F( f )) # G(F(1))
because F and G preserve composition.
3. We have proposed objects, morphisms, identities, and a composition formula for a category Cat:
they are categories, functors, and the identities and compositions given above. We need to check
that the two properties, unitality and associativity, hold. So suppose F : C ‚ÜíD is a functor
and we pre-compose it as above with idC; it is easy to see that the result will again be F, and
similarly if we post-compose F with idD. This gives unitality, and associativity is just as easy,
though more wordy. Given F as above and G: D ‚ÜíE and H : E ‚ÜíF, we need to show that
(F # G) # H  F # (G # H). It‚Äôs a simple application of the deÔ¨Ånition: for any x ‚ààC, be it an object
or morphism, we have
((F # G) # H)(c)  H((F # G)(c))  H(G(F(c)))  (G # H)(F(c))  (F # (G # H))(c).
Solution to Exercise 3.45.
Let S ‚ààSet be a set. DeÔ¨Åne FS : 1 ‚ÜíSet by FS(1)  S and FS(id1)  idS. With this deÔ¨Ånition, FS
preserves identities and compositions (the only compositions in 1 is the composite of the identity with
itself), so FS is a functor with FS(1)  S as desired.
Solution to Exercise 3.48.
We are asked what sort of data ‚Äúmakes sense‚Äù for the schemas below?
1.
‚Ä¢z
s
s # s  z
2.
a‚Ä¢
b‚Ä¢
c‚Ä¢
f
1
h
f # 1  f # h
This is a subjective question, so we propose an answer for your consideration.
1. Data on this schema, i.e. a set-valued functor, assigns a set D(z) and a function D(s): D(z) ‚ÜíD(z),
such that applying that function twice is the identity. This sort of function is called an involution
of the set Dz:
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

A.3. SOLUTIONS FOR CHAPTER 3
281
It‚Äôs a do-si-do, a ‚Äúpartner move,‚Äù where everyone picks a partner (possibly themselves) and
exchanges with them. One example one could take D to be the set of pixels in a photograph, and
take s to be the function sending each pixel to its mirror image across the vertical center line of
the photograph.
2. We could make D(c) the set of people at a ‚Äúsecret Santa‚Äù Christmas party, where everyone gives
a gift to someone, possibly themselves. Take D(b) to be the set of gifts, 1 the giver function (each
gift is given by a person), and h the receiver function (each gift is received by a person), D(a) is
the set of people who give a gift to themselves, and d( f ): D(a) ‚ÜíD(b) is the inclusion.
Solution to Exercise 3.55.
1. The expert packs so much information in so little space! Suppose given three objects F, G, H ‚ààDC;
these are functors F, G, H : C ‚ÜíD. Morphisms Œ±: F ‚ÜíG and Œ≤: G ‚ÜíH are natural transfor-
mations. Most beginners seem to think about a natural transformation in terms of its naturality
squares, but the main thing to keep in mind is its components; the naturality squares constitute
a check that comes later.
So for each c ‚ààC, Œ± has a component Œ±c : F(c) ‚ÜíG(c) and Œ≤ has a component Œ≤c : G(c) ‚ÜíH(c)
in D. The expert has told us to deÔ¨Åne (Œ± # Œ≤)c B (Œ±c # Œ≤c), and indeed that is a morphism
F(c) ‚ÜíH(c).
Now we do the check. For any f : c ‚Üíc‚Ä≤ in C, the inner squares of the following diagram
commute because Œ± and Œ≤ are natural; hence the outer rectangle does too:
F(c)
G(c)
H(c)
F(c‚Ä≤)
G(c‚Ä≤)
H(c‚Ä≤)
Œ±c
F( f )
Œ≤c
G( f )
H( f )
Œ±c
Œ≤c
2. We propose that the identity natural transformation idF on a functor F : C ‚ÜíD has as its
c-component the morphism (idF)c B idF(c) in D, for any c. The naturality square
F(c)
F(c)
F(c‚Ä≤)
F(c‚Ä≤)
idF(c)
F( f )
F( f )
idF(c‚Ä≤)
obviously commutes for any f : c ‚Üíc‚Ä≤. And it is unital: post-composing idF with any Œ≤: F ‚ÜíG
(and similarly for precomposing with any Œ±: E ‚ÜíF) results in a natural transformation idF # Œ≤
with components (idF)c # Œ≤c  (idF(c) # Œ≤c)  Œ≤c, and this is just Œ≤ as desired.
Solution to Exercise 3.58.
We have a category C and a preorder P, considered as a category.
1. Suppose that F, G: C ‚ÜíP are functors and Œ±, Œ≤: F ‚ÜíG are natural transformations; we need to
show that Œ±  Œ≤. It suÔ¨Éces to check that Œ±c  Œ≤c for each object c ‚ààOb(C). But Œ±c and Œ≤c are
morphisms F(c) ‚ÜíG(c) in P, which is a preorder, and the deÔ¨Ånition of a preorder‚Äîconsidered
as a category‚Äîis that it has at most one morphism between any two objects. Thus Œ±c  Œ≤c, as
desired.
2. This is false. Let P B 1, let C B
a‚Ä¢
f1
f2
b‚Ä¢ , let F(1) B a, let G(1) B b, let Œ±1 B f1, and let Œ≤1 B 12.

282
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 3.62.
We need to write down the following
Employee
‚Ä¢
Department
‚Ä¢
string
‚ó¶
WorksIn
FName
Mngr
Secr
DName
as a Gr-instance, as in Eq. (3.61). The answer is as follows:
Arrow
source
target
Mngr
Employee
Employee
WorksIn
Employee
Department
Secr
Department
Employee
FName
Employee
string
DName
Department
string
Vertex
Department
Employee
string
Solution to Exercise 3.64.
Let G, H be the following graphs:
G B
1‚Ä¢
2‚Ä¢
3‚Ä¢
a
b
H B
4‚Ä¢
5‚Ä¢
c
d
e
and let‚Äôs believe the authors that there is a unique graph homomorphism Œ±: G ‚ÜíH for which
Œ±Arrow(a)  d.
1. We have Œ±Arrow(b)  e and Œ±Vertex(1)  4, Œ±Vertex(2)  5, and Œ±Vertex(3)  5.
2. We roughly copy the tables and then draw the lines (shown in black; ignore the dashed lines for
now):
a
1
2
1
b
2
3
2
3
c
4
5
4
d
4
5
5
e
5
5
t
t
3. It works! One example of the naturality is shown with the help of dashed blue lines above. See
how both paths starting at a end at 5?
Solution to Exercise 3.67.
We just need to write out the composite of the following functors
Arrow
‚Ä¢
Vertex
‚Ä¢
source
target
Gr
State
‚Ä¢
next
DDS
G
Set
State
next
1
4
2
4
3
5
4
5
5
5
6
7
7
6

A.3. SOLUTIONS FOR CHAPTER 3
283
in the form of a database, and then draw the graph. The results are given below.
Arrow
source
target
1
4
1
2
4
2
3
5
3
4
5
4
5
5
5
6
7
6
7
6
7
Vertex
1
2
3
4
5
6
7
1‚Ä¢
2‚Ä¢
3‚Ä¢
4‚Ä¢
6‚Ä¢
7‚Ä¢
‚Ä¢
5
1
2
3
4
6
7
5
Solution to Exercise 3.73.
We are interested in how the functors ‚àí√ó B and (‚àí)B should act on morphisms for a given set B.
We didn‚Äôt specify this in the text‚Äîwe only speciÔ¨Åed ‚àí√ó B and (‚àí)B on objects‚Äîso in some sense
this exercise is open: you can make up anything you want, under the condition that it is functorial.
However, the authors cannot think of any such answers except the one we give below.
1. Given an arbitrary function f : X ‚ÜíY, we need a function X √ó B ‚ÜíY √ó B. We suggest the
function which might be denoted f √ó B; it sends (x, b) to ( f (x), b). This assignment is functorial:
applied to idX it returns idX√óB and it preserves composition.
2. Given a function f : X ‚ÜíY, we need a function XB ‚ÜíYB. The canonical function would
be denoted f B; it sends a function 1 : B ‚ÜíX to the composite (1 # f ): B ‚ÜíX ‚ÜíY. This is
functorial: applied to idX it sends 1 to 1, i.e. f B(idX)  idXB, and applied to the composite
( f1 # f2): X ‚ÜíY ‚ÜíZ, we have
( f1 # f2)B(1)  1 # ( f1 # f2)  (1 # f1) # f2  ( f B
1 # f B
2 )(1)
for any 1 ‚ààXB.
3. If p : N ‚ÜíNN is the result of currying +: N √ó N ‚ÜíN, then p(3) is an element of NN, i.e. we have
p(3): N ‚ÜíN; what function is it? It is the function that adds three. That is p(3)(n) B n + 3.
Solution to Exercise 3.76.
The functor !: C ‚Üí1 from Eq. (3.75) sends each object c ‚ààC to the unique object 1 ‚àà1 and sends each
morphism f : c ‚Üíd in C to the unique morphism id1 : 1 ‚Üí1 in 1.
Solution to Exercise 3.78.
We want to draw the graph corresponding to the instance I : G ‚ÜíSet shown below:
Email
sent_by
received_by
Em_1
Bob
Grace
Em_2
Grace
Pat
Em_3
Bob
Emory
Em_4
Sue
Doug
Em_5
Doug
Sue
Em_6
Bob
Bob
Address
Bob
Doug
Emory
Grace
Pat
Sue
Here it is, with names and emails shortened (e.g. B=Bob, 3=Em_3):
E
B
G
P
S
D
1
3
6
2
4
5
Solution to Exercise 3.81.
An object z is terminal in some category C if, for every c ‚ààC there exists a unique morphism c ‚Üíz.
When C is the category underlying a preorder, there is at most one morphism between any two objects,

284
APPENDIX A. EXERCISE SOLUTIONS
so the condition simpliÔ¨Åes: an object z is terminal iÔ¨Ä, for every c ‚ààC there exists a morphism c ‚Üíz.
The morphisms in a preorder are written with ‚â§signs, so z is terminal iÔ¨Ä, for every c ‚ààP we have
c ‚â§z, and this is the deÔ¨Ånition of top element.
Solution to Exercise 3.82.
The terminal object in Cat is 1 because by Exercise 3.76 there is a unique morphism (functor) C ‚Üí1 for
any object (category) C ‚ààCat.
Solution to Exercise 3.83.
Consider the graph 2V B
‚Ä¢ ‚Ä¢ with two vertices and no arrows, and let C  Free(2V); it has two
objects and two morphisms (the identities). This category does not have a terminal object because it
does not have any morphisms from one object to the other.
Solution to Exercise 3.88.
A product of x and y in P is an object z ‚ààP equipped with maps z ‚Üíx and z ‚Üíy such that for any
other object z‚Ä≤ and maps z‚Ä≤ ‚Üíx and z‚Ä≤ ‚Üíy, there is a unique morphism z‚Ä≤ ‚Üíz making the evident
triangles commute. But in a preorder, the maps are denoted ‚â§, they are unique if they exist, and all
diagrams commute. Thus the above becomes: a product of x and y in P is an object z with z ‚â§x and
z ‚â§y such that for any other z‚Ä≤, if z‚Ä≤ ‚â§x and z‚Ä≤ ‚â§y then z‚Ä≤ ‚â§z. This is exactly the deÔ¨Ånition of meet,
z  x ‚àßy.
Solution to Exercise 3.90.
1. The identity morphism on the object (c, d) in the product category C √ó D is (idc, idd).
2. Suppose given three composable morphisms in C √ó D
(c1, d1)
( f1,11)
‚àí‚àí‚àí‚àí‚àí‚Üí(c2, d2)
( f2,12)
‚àí‚àí‚àí‚àí‚àí‚Üí(c3, d3)
( f3,13)
‚àí‚àí‚àí‚àí‚àí‚Üí(c4, d4).
We want to check that (( f1, 11)#( f2, 12))#( f3, 13)  ( f1, 11)#(( f2, 12)#( f3, 13)). But composition in
a product category is given component-wise. That means the left-hand side is (( f1 # f2) # f3, (11 #
12) # 13), whereas the right-hand side is ( f1 # ( f2 # f3), 11 # (12 # 13)), and these are equal because
both C and D individually have associative composition.
3. The product category 1 √ó 2 has two objects (1, 1) and (1, 2) and one non-identity morphism
(1, 1) ‚Üí(1, 2). It is not hard to see that it looks the same as 2. In fact, for any C there is an
isomorphism of categories 1 √ó C  C.
4. Let P and Q be preorders, let X  P √ó Q be their product preorder as deÔ¨Åned in Example 1.56,
and let P, Q, and X be the corresponding categories. Then X  P √ó Q.
Solution to Exercise 3.91.
A product of X and Y is an object Z equipped with morphisms X
pX
‚Üê‚àí‚àíZ
pY
‚àí‚àí‚ÜíY such that for any other
object Z‚Ä≤ equipped with morphisms X
p‚Ä≤
X
‚Üê‚àí‚àíZ‚Ä≤ p‚Ä≤
Y
‚àí‚àí‚ÜíY, there is a unique morphism f : Z‚Ä≤ ‚ÜíZ making
the triangles commute, f # pX  p‚Ä≤
X and f # pY  p‚Ä≤
Y. But ‚Äúan object equipped with morphisms to X
and Y‚Äù is exactly the deÔ¨Ånition of an object in Cone(X, Y), and a morphism f making the triangles
commute is exactly the deÔ¨Ånition of a morphism in Cone(X, Y). So the deÔ¨Ånition above becomes: a
product of X and Y is an object Z ‚ààCone(X, Y) such that for any other object Z‚Ä≤ there is a unique
morphism Z‚Ä≤ ‚ÜíZ in Cone(X, Y). This is exactly the deÔ¨Ånition of Z being terminal in Cone(X, Y).
Solution to Exercise 3.97.
Suppose J is the graph
v1‚Ä¢
v2‚Ä¢
and D : J ‚ÜíSet is given by two sets, D(v1)  A and D(v2)  B for sets
A, B. The product of these two sets is A √ó B. Let‚Äôs check that the limit formula in Theorem 3.95 gives
the same answer. It says
lim
J D B

(d1, . . . , dn) | di ‚ààD(vi) for all 1 ‚â§i ‚â§n and
for all a : vi ‚Üívj ‚ààA, we have D(a)(di)  dj
	
.

A.3. SOLUTIONS FOR CHAPTER 3
285
But in our case n  2, there are no arrows in the graph, and D(v1)  A and D(v2)  B. So the formula
reduces to
lim
J D B

(d1, d2) | d1 ‚ààA and d2 ‚ààB
	
.
which is exactly the deÔ¨Ånition of A √ó B.
Solution to Exercise 3.101.
Given a functor F : C ‚ÜíD, we deÔ¨Åne its opposite Fop : Cop ‚ÜíDop as follows. For each object c ‚àà
Ob(Cop)  Ob(C), put Fop(c) B F(c). For each morphism f : c1 ‚Üíc2 in Cop, we have a corresponding
morphism f ‚Ä≤: c2 ‚Üíc1 in C and thus a morphism F( f ‚Ä≤): F(c2) ‚ÜíF(c1) in D, and thus a morphism
F( f ‚Ä≤)‚Ä≤: Fop(c1) ‚ÜíFop(c2). Hence we can deÔ¨Åne Fop( f ) B F( f ‚Ä≤)‚Ä≤. Note that the primes (‚àí‚Ä≤) are pretty
meaningless, we only put them there to diÔ¨Äerentiate between things that are very closely related.
It is easy to check that our deÔ¨Ånition of Fop is functorial: it sends identities to identities and composites
to composites.

286
APPENDIX A. EXERCISE SOLUTIONS
A.4
Solutions for Chapter 4.
Solution to Exercise 4.4.
1. The Hasse diagram for Xop √ó Y is shown here (ignore the colors):
(category, nothing)
(monoid, nothing)
(preorder, nothing)
(category, this book)
(monoid, this book)
(preorder, nothing)
2. There is a profunctor Œõ: X
Y, i.e. a functor Xop √ó Y ‚ÜíB, such that, in the picture above, blue
is sent to true and black is sent to false, i.e.
Œõ(monoid, nothing)  Œõ(monoid, this book)
 Œõ(preorder, this book)
 Œõ(category, this book)  true
Œõ(preorder, nothing)  Œõ(category, nothing)  false.
The preorder Xop √ó Y describes tasks in decreasing diÔ¨Éculty. For example, (we hope) it is easier for
my aunt to explain a monoid given this book than for her to explain a monoid without this book. The
profunctor Œõ describes possible states of knowledge for my aunt: she can describe monoids without
help, categories with help from the book, etc. It is an upper set because we assume that if she can do a
task, she can also do any easier task.
Solution to Exercise 4.7.
We‚Äôve done this one before! We hope you remembered how to do it. If not, see Exercise 2.84.
Solution to Exercise 4.9.
Recall from DeÔ¨Ånition 2.41 that a V-functor Œ¶: Xop √ó Y ‚ÜíV is a function Œ¶: Ob(Xop √ó Y) ‚ÜíOb(V)
such that for all (x, y) and (x‚Ä≤, y‚Ä≤) in Xop √ó Y we have
(Xop √ó Y) (x, y), (x‚Ä≤, y‚Ä≤)
‚â§V Œ¶(x, y), Œ¶(x‚Ä≤, y‚Ä≤)
.
Using the deÔ¨Ånitions of product V-category (DeÔ¨Ånition 2.74) and opposite V-category (Exercise 2.73)
on the left hand side, and using Remark 2.89, which describes how we are viewing the quantale V as
enriched over itself, on the right hand side, this unpacks to
X(x‚Ä≤, x) ‚äóY(y, y‚Ä≤) ‚â§Œ¶(x, y) ‚ä∏Œ¶(x‚Ä≤, y‚Ä≤)
Using symmetry of ‚äóand the deÔ¨Ånition of hom-element, Eq. (2.80), we see that Œ¶ is a profunctor if and
only if
X(x‚Ä≤, x) ‚äóŒ¶(x, y) ‚äóY(y, y‚Ä≤) ‚â§Œ¶(x‚Ä≤, y‚Ä≤).
Solution to Exercise 4.10.
Yes, since a Bool-functor is exactly the same as a monotone map, the deÔ¨Ånition of Bool-profunctor and
that of feasibility relation line up perfectly!
Solution to Exercise 4.12.
The feasibility matrix for Œ¶ is
Œ¶
a
b
c
d
e
N
true
false
true
false
true
E
true
true
true
true
true
W
true
false
true
false
true
S
true
true
true
true
true

A.4. SOLUTIONS FOR CHAPTER 4
287
Solution to Exercise 4.15.
The Cost-matrix for Œ¶ is
Œ¶
x
y
z
A
17
20
20
B
11
14
14
C
14
17
17
D
12
9
15
Solution to Exercise 4.17.
Œ¶  M3
X ‚àóMŒ¶ ‚àóM2
Y 
¬©¬≠¬≠¬≠¬≠
¬´
0
6
3
11
2
0
5
5
5
3
0
8
11
9
6
0
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
¬©¬≠¬≠¬≠¬≠
¬´
‚àû
‚àû
‚àû
11
‚àû
‚àû
‚àû
‚àû
‚àû
‚àû
9
‚àû
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
¬©¬≠¬≠
¬´
0
4
3
3
0
6
7
4
0
¬™¬Æ¬Æ
¬¨

¬©¬≠¬≠¬≠¬≠
¬´
17
20
‚àû
11
14
‚àû
14
17
‚àû
20
9
‚àû
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
¬©¬≠¬≠
¬´
0
4
3
3
0
6
7
4
0
¬™¬Æ¬Æ
¬¨

¬©¬≠¬≠¬≠¬≠
¬´
17
20
20
11
14
14
14
17
17
12
9
15
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
Solution to Exercise 4.18.
Yes, this is valid: it just means that the profunctor Œ¶: (T √ó E)
$ does not relate (good-natured,
funny) to any element of $. More formally, it means that Œ¶((good-natured, funny), p)  false for
all p ‚àà$  {$100K, $500K, $1M}. We can interpret this to mean that it is not feasible to produce a
good-natured, funny movie for any of the cost options presented‚Äîso at least not for less than a million
dollars.
Solution to Exercise 4.22.
There are a number of methods that can be used to get the correct answer. One way that works well for
this example is to search for the shortest paths on the diagram: it so happens that all the shortest paths
go through the bridges from D to y and y to r, so in this case (Œ¶ # Œ®)(‚àí, ‚àí)  X(‚àí, D) + 9 + Z(r, ‚àí). This
gives:
Œ¶ # Œ®
p
q
r
s
A
22
24
20
21
B
16
18
14
15
C
19
21
17
18
D
11
13
9
10

288
APPENDIX A. EXERCISE SOLUTIONS
A more methodical way is to use matrix multiplication. Here‚Äôs one way you might do the multiplication,
using a few tricks.
Œ¶ # Œ®  (M3
X ‚àóMŒ¶ ‚àóM2
Y) ‚àó(M2
Y ‚àóMŒ® ‚àóM3
Z)
 M3
X ‚àóMŒ¶ ‚àóM4
Y ‚àóMŒ® ‚àóM3
Z
 (M3
X ‚àóMŒ¶ ‚àóM2
Y) ‚àóMŒ® ‚àóM3
Z
 Œ¶ ‚àóMŒ® ‚àóM3
Z

¬©¬≠¬≠¬≠¬≠
¬´
17
20
20
11
14
14
14
17
17
12
9
15
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
¬©¬≠¬≠
¬´
‚àû
‚àû
‚àû
‚àû
‚àû
‚àû
0
‚àû
4
‚àû
‚àû
4
¬™¬Æ¬Æ
¬¨
¬©¬≠¬≠¬≠¬≠
¬´
0
2
4
5
4
0
2
3
2
4
0
1
1
3
5
0
¬™¬Æ¬Æ¬Æ¬Æ
¬¨

¬©¬≠¬≠¬≠¬≠
¬´
17
20
20
11
14
14
14
17
17
12
9
15
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
¬©¬≠¬≠
¬´
‚àû
‚àû
‚àû
‚àû
2
4
0
1
4
6
8
4
¬™¬Æ¬Æ
¬¨

¬©¬≠¬≠¬≠¬≠
¬´
22
24
20
21
16
18
14
15
19
21
17
18
11
13
9
10
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
Solution to Exercise 4.26.
We choose the Cost-category X from Eq. (2.56). The unit profunctor UX on X is described by the bridge
diagram
‚Ä¢A
‚Ä¢B
‚Ä¢
C
‚Ä¢
D
3
3
4
2
5
‚Ä¢A
‚Ä¢B
‚Ä¢
C
‚Ä¢
D
3
3
4
2
5
0
0
0
0
Solution to Exercise 4.30.
1. The Ô¨Årst equality is the unitality of V (DeÔ¨Ånition 2.2(b)). The second step uses the monotonicity
of ‚äó(DeÔ¨Ånition 2.2(a)) applied to the inequalities I ‚â§P(p, p) (the identity law for P at p,
DeÔ¨Ånition 2.46(a)) and Œ¶(p, q) ‚â§Œ¶(p, q) (reÔ¨Çexivity of preorder V, DeÔ¨Ånition 1.30(a)). The third
step uses the deÔ¨Ånition of join: for all x and y, since any x ‚â§x, we have x ‚â§x ‚à®y. The Ô¨Ånal
equality is just the deÔ¨Ånition of profunctor composition, DeÔ¨Ånition 4.21.
2. Note that in Bool, I  true. Since the identity law at p says true ‚â§P(p, p), and true is the
largest element of the preorder Bool, we thus have P(p, p)  true for all p. This shows that the
Ô¨Årst inequality in Eq. (4.28) is an equality.
The second inequality is more involved. Note that by the above, we can assume the left hand
side of the inequality is equal to Œ¶(p, q). We split into two cases. Suppose Œ¶(p, q)  true. Then,
again since true is the largest element of B, we must have equality.
Next, suppose Œ¶(p, q)  false. Note that since Œ¶ is a monotone map Pop √ó Q ‚ÜíBool, if p ‚â§p1
in P, then Œ¶(p1, q) ‚â§Œ¶(p, q) in Bool. Thus if P(p, p1)  true then Œ¶(p1, q)  Œ¶(p, q)  false.
This implies that for all p1 ‚ààP, we have either P(p, p1)  false or Œ¶(p1, q)  false, and hence
√î
p1‚ààP P(p, p1) ‚àßŒ¶(p1, q)  √î
p1‚ààP false  false.
Thus, in either case, we see that Œ¶(p, q)  √î
p1‚ààP P(p, p1) ‚àßŒ¶(p1, q), as required.

A.4. SOLUTIONS FOR CHAPTER 4
289
3. The Ô¨Årst equation is unitality in monoidal categories, v ‚äóI  v for any v ‚ààV. The second is that
I ‚â§Q(q, q) by unitality of enriched categories, see DeÔ¨Ånition 2.46, together with monotonicity of
monoidal product: v1 ‚â§v2 implies v ‚äóv1 ‚â§v ‚äóv2. The third was shown in Exercise 4.9.
Solution to Exercise 4.32.
This is very similar to Exercise 2.104: we exploit the associativity of ‚äó. Note, however, we also require
V to be symmetric monoidal closed, since this implies the distributivity of ‚äóover ‚à®(Proposition 2.87
2), and V to be skeletal, so we can turn equivalences into equalities.
((Œ¶ # Œ®) # Œ•)(p, s) 
√ú
r‚ààR
 √ú
q‚ààQ
Œ¶(p, q) ‚äóŒ®(q, r)

‚äóŒ•(r, s)

√ú
r‚ààR,q‚ààQ
Œ¶(p, q) ‚äóŒ®(q, r) ‚äóŒ•(r, s)

√ú
q‚ààQ
Œ¶(p, q) ‚äó
√ú
r‚ààR

Œ®(q, r) ‚äóŒ•(r, s)

 (Œ¶ # (Œ® # Œ•))(p, s)
Solution to Exercise 4.36.
This is very straightforward. We wish to check b
id: P
P has the formula b
id(p, q)  P(p, q). By
DeÔ¨Ånition 4.34, b
id(p, q) B P(id(p), q)  P(p, q). So they‚Äôre the same.
Solution to Exercise 4.38.
The conjoint q+: R
R √ó R √ó R sends (a, b, c, d) to R(a, b + c + d), which is true if a ‚â§b + c + d, and
false otherwise.
Solution to Exercise 4.41.
1. By DeÔ¨Ånition 4.34, bF(p, q)  Q(F(p), q) and qG(p, q)  Q(p, G(q)). Since V is skeletal, F and G are
V adjoints if and only if Q(F(p), q)  Q(p, G(q)). Thus F and G are adjoints if and only if bF  qG.
2. Note that id: P ‚ÜíP is V-adjoint to itself, since both sides of Eq. (4.40) then equal P(p, q). Thus
b
id  qid.
Solution to Exercise 4.44.
The Hasse diagram for the collage of the given profunctor is quite simply this:
‚Ä¢A
‚Ä¢B
‚Ä¢
C
‚Ä¢
D
3
3
4
2
5
‚Ä¢x
‚Ä¢y
‚Ä¢z
3
4
3
4
11
9
Solution to Exercise 4.48.
Since we only have a rough deÔ¨Ånition, we can only roughly check this: we won‚Äôt bother with the notion
of well-behaved. Nonetheless, we can still compare DeÔ¨Ånition 2.2 with DeÔ¨Ånition 4.45.
First, recall from Section 3.2.3 that a preorder is a category P such that for every p, q ‚ààP, the set P(p, q)
has at most one element.
On the surface, all looks promising: both deÔ¨Ånitions have two constituents and four properties. In
constituent (i), both DeÔ¨Ånition 2.2 and DeÔ¨Ånition 4.45 call for the same: an element, or object, of the
preorder P. So far so good. Constituent (ii), however, is where it gets interesting: DeÔ¨Ånition 2.2 calls
for merely a function ‚äó: P √ó P ‚ÜíP, while DeÔ¨Ånition 4.45 calls for a functor.

290
APPENDIX A. EXERCISE SOLUTIONS
Recall from Example 3.42 that functors between preorders are exactly monotone maps. So we need for
the function ‚äóin DeÔ¨Ånition 2.2 to be a monotone map. This is exactly property (a) of DeÔ¨Ånition 2.2: it
says that if (x1, x2) ‚â§(y1, y2) in P ‚äóP, then we must have x1 ‚äóx2 ‚â§y1 ‚äóy2 in P. So it is also the case
that in DeÔ¨Ånition 2.2 that ‚äóis a functor.
The remaining properties compare easily, taking the natural isomorphisms to be equality or equivalence
in P. Indeed, property (b) of DeÔ¨Ånition 2.2 corresponds to both properties (a) and (b) of DeÔ¨Ånition 4.45,
and then the respective properties (c) and (d) similarly correspond.
Solution to Exercise 4.50.
1. 1E(5, 3)  false, 1F(5, 3)  2.
2. 1E(3, 5)  true, 1F(3, 5)  ‚àí2.
3. h(5, true)  5.
4. h(‚àí5, true)  ‚àí5.
5. h(‚àí5, false)  6.
6. qG(‚àí2, 3)  2, qF(‚àí2, 3)  ‚àí13.
7. qG(2, 3)  ‚àí1, qF(2, 3)  7.
Solution to Exercise 4.52.
Yes, the rough deÔ¨Ånition roughly agrees: plain old categories are Set-categories! In detail, we need to
compare DeÔ¨Ånition 4.51 when V  (Set, {1}, √ó) with DeÔ¨Ånition 3.6. In both cases, we see that (i) asks for
a collection of objects and (ii) asks for, for all pairs of objects x, y, a set C(x, y) of morphisms. Moreover,
recall that the monoidal unit I is the one element set {1}. This means a morphism idx : I ‚ÜíC(x, x) is a
function idx : {1} ‚ÜíC(x, x). This is the same data as simply an element idx  idx(1) ‚ààC(x, x); we call
this data the identity morphism on x. Finally, a morphism #: C(x, y) ‚äóC(y, z) ‚ÜíC(x, z) is a function
#: C(x, y) √ó C(y, z) ‚ÜíC(x, z); this is exactly the composite required in DeÔ¨Ånition 3.6 (iv).
So in both cases the data agrees. In DeÔ¨Ånition 3.6 we also require this data to satify two conditions,
unitality and associativity. This is what is meant by the last sentence of DeÔ¨Ånition 4.51.
Solution to Exercise 4.54.
An identity element in a Cost-category X is a morphism I ‚ÜíX(x, x) in Cost  ([0, ‚àû], ‚â•, 0, +), and
hence the condition that 0 ‚â•X(x, x). This implies that X(x, x)  0. In terms of distances, we interpret
this to mean that the distance from any point to itself is equal to 0. We think this is a pretty sensible
condition for a notion of distance to obey.
Solution to Exercise 4.62.
1. Here is a picture of the unit corelation ¬ú ‚Üí3 ‚äî3, where we have drawn the empty set with an
empty dotted rectangle on the left:
¬ú
3 ‚äî3

A.4. SOLUTIONS FOR CHAPTER 4
291
2. Here is a picture of the counit corelation 3 ‚äî3 ‚Üí¬ú:
¬ú
3 ‚äî3
3. Here is a picture of the snake equation on the left of Eq. (4.59).

Solution to Exercise 4.64.
Given two resource preorders X and Y, the preorder X √ó Y represents the set of all pairs of resources,
x ‚ààX and y ‚ààY, with (x, y) ‚â§(x‚Ä≤, y‚Ä≤) iÔ¨Äx ‚â§x‚Ä≤ and y ‚â§y‚Ä≤. That is, if x is available given x‚Ä≤ and y is
available given y‚Ä≤, then (x, y) is available given (x‚Ä≤, y‚Ä≤).
Given two profunctors Œ¶: X1
X2 and Œ®: Y1
Y2, the profunctor Œ¶√óŒ® represents their conjunction,
i.e. AND. In other words, if y1 can be obtained given x1 AND y2 can be obtained given x2, then (y1, y2)
can be obtained given (x1, x2).
Solution to Exercise 4.65.
The profunctor X√ó1
X deÔ¨Åned by the functor Œ±: (X√ó1)op √óX ‚ÜíV that maps Œ±((x, 1), y) B X(x, y)
is an isomorphism. It has inverse Œ±‚àí1 : X
X √ó 1 deÔ¨Åned by Œ±‚àí1(x, (y, 1)) B X(x, y). To see that
Œ±‚àí1 # Œ±  UX, note Ô¨Årst that the unit law for X at z and the deÔ¨Ånition of join imply
X(x, z)  X(x, z) ‚äóI ‚â§X(x, z) ‚äóX(z, z) ‚â§
√ú
y‚ààX
X(x, y) ‚äóX(y, z),
while composition says X(x, y) ‚äóX(y, z) ‚â§X(x, z) and hence
√ú
y‚ààX
X(x, y) ‚äóX(y, z) ‚â§
√ú
y‚ààX
X(x, z)  X(x, z).
Thus, unpacking the deÔ¨Ånition of composition of profunctor, we have
(Œ±‚àí1 # Œ±)(x, z) 
√ú
(y,1)‚ààX√ó1
Œ±(x, (y, 1)) ‚äóŒ±‚àí1((y, 1), z) 
√ú
y‚ààX
X(x, y) ‚äóX(y, z)  X(x, z).
Similarly we can show Œ± # Œ±‚àí1  UX√ó1, and hence that Œ± is an isomorphism X √ó 1
X.
Moreover, we can similarly show that Œ≤((1, x), y) B X(x, y) deÔ¨Ånes an isomorphism Œ≤: 1 √ó X
X.
Solution to Exercise 4.66.
We check the Ô¨Årst snake equation, the one on the left hand side of Eq. (4.59). The proof of the one on
the right hand side is analogous.

292
APPENDIX A. EXERCISE SOLUTIONS
We must show that the composite Œ¶ of profunctors
X
Œ±‚àí1
‚àí‚àí‚àí‚ÜíX √ó 1
UX√óŒ∑X
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíX √ó Xop √ó X
œµX√óUX
‚àí‚àí‚àí‚àí‚àí‚àí‚Üí1 √ó X
Œ±‚àí‚ÜíX
is itself the identity (ie. the unit profunctor on X), where Œ± and Œ±‚àí1 are the isomorphisms deÔ¨Åned in
the solution to Exercise 4.65 above.
Freely using the distributivity of ‚äóover ‚à®, the value Œ¶(x, y) of this composite at (x, y) ‚ààXop √ó X is
given by
√ú
a,b,c,d,e‚ààX
Œ±‚àí1(x, (a, 1)) ‚äó(UX √ó Œ∑X)((a, 1), (b, c, d))
‚äó(œµX √ó UX)((b, c, d), (1, e)) ‚äóŒ±((1, e), y)

√ú
a,b,c,d,e‚ààX
Œ±‚àí1(x, (a, 1)) ‚äóUX(a, b) ‚äóŒ∑X(1, c, d)
‚äóœµX(b, c, 1) ‚äóUX(d, e) ‚äóŒ±((1, e), y)

√ú
a,b,c,d,e‚ààX
X(x, a) ‚äóX(a, b) ‚äóX(c, d) ‚äóX(b, c) ‚äóX(d, e) ‚äóX(e, y)

X(x, y)
where in the Ô¨Ånal step we repeatedly use the argument the Lemma 4.27 that shows that composing
with the unit profunctor UX(a, b)  X(a, b) is the identity.
This shows that Œ¶(x, y) is the identity profunctor, and hence shows the Ô¨Årst snake equation holds.
Again, checking the other snake equation is analogous.

A.5. SOLUTIONS FOR CHAPTER 5
293
A.5
Solutions for Chapter 5.
Solution to Exercise 5.5.
1. Below we draw a morphism f : 3 ‚Üí2 and a morphism 1 : 2 ‚Üí4 in FinSet:
‚Ä¢
‚Ä¢
‚Ä¢
3
‚Ä¢
‚Ä¢
2
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
4
‚Ä¢
‚Ä¢
2
f
1
2. Here is a picture of f + 1
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
3+2
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
2+4
f + 1
3. The composite of morphisms f : m ‚Üín and 1 : n ‚Üíp in FinSet is the function ( f # 1): m ‚Üíp
given by ( f # 1)(i)  1( f (i)) for all 1 ‚â§i ‚â§m.
4. The identity idm : m ‚Üím is given by idm(i)  i for all 1 ‚â§i ‚â§m. Here is a picture of id2 and id8:
‚Ä¢
‚Ä¢
2
‚Ä¢
‚Ä¢
2
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
8
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
8
id2
id8
5. Here is a picture of the symmetry œÉ3,5 : 8 ‚Üí8:
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
8
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
8
œÉ3,5
Solution to Exercise 5.9.
We need to give examples posetal props, i.e. each will be a poset whose set of objects is N, whose order is
denoted m ‚™Øn, and with the property that whenever m1 ‚™Øn1 and m2 ‚™Øn2 hold then m1+m2 ‚™Øn1+n2
does too.
The question only asks for three, but we will additionally give a quasi-example and a non-example.
1. Take ‚™Øto be the discrete order: m ‚™Øn iÔ¨Äm  n.
2. Take ‚™Øto be the usual order, m ‚™Øn iÔ¨Äthere exists d ‚ààN with d + m  n.
3. Take ‚™Øto be the reverse of the usual order, m ‚™Øn iÔ¨Äthere exists d ‚ààN with m  n + d.
4. Take ‚™Øto be the co-discrete order m ‚™Øn for all m, n. Some may object that this is a preorder, not
a poset, so we call it a quasi-example.
5. (Non-example.) Take ‚™Øto be the division order, m ‚™Øn iÔ¨Äthere exists q ‚ààN with m ‚àóq  d. This
is a perfectly good poset, but it does not satisfy the monotonicity property: we have 2 ‚™Ø4 and
3 ‚™Ø3 but not 5 ‚™Ø? 7.
Solution to Exercise 5.10.
Example 5.6: The prop Bij has
1. Bij(m, n) B { f : m ‚Üín | f is a bƒ≥ection}. Note that Bij(m, n)  ¬ú if m , n and it has n!
elements if m  n.
2. The identity map n ‚Üín is the bƒ≥ection n ‚Üín sending i 7‚Üíi.

294
APPENDIX A. EXERCISE SOLUTIONS
3. The symmetry map m + n ‚Üín + m is the bƒ≥ection œÉm,n : m + n ‚Üín + m given by
œÉm,n(i) B
(
i + n
if i ‚â§m
i ‚àím
if m + 1 ‚â§i
4. Composition of bƒ≥ections m ‚Üín and n ‚Üíp is just their composition as functions, which
is again a bƒ≥ection.
5. Given bƒ≥ections f : m ‚Üím‚Ä≤ and 1 : n ‚Üín‚Ä≤, their monoidal product ( f + 1): (m + n) ‚Üí
(m‚Ä≤ + n‚Ä≤) is given by
( f + 1)(i) B
(
f (i)
if i ‚â§m
1(i ‚àím)
if m + 1 ‚â§i
Example 5.7: The prop Corel has
1. Corel(m, n) is the set of equivalence relations on m + n.
2. The identity map n ‚Üín is the smallest equivalence relation, which is the smallest reÔ¨Çexive
relation, i.e. where i ‚àºj iÔ¨Äi  j.
3. The symmetry map œÉm,n, as an equivalence relation on m + n + n + m is ‚Äúthe obvious
thing,‚Äù namely ‚Äúequating corresponding m‚Äôs together and also equating corresponding n‚Äôs
together.‚Äù To be pedantic, i ‚àºj iÔ¨Äeither
‚Ä¢ |i ‚àíj|  m + n + n, or
‚Ä¢ m + 1 ‚â§i ‚â§m + n + n and m + 1 ‚â§j ‚â§m + n + n and |i ‚àíj|  n.
4. Composition of an equivalence relation ‚àºon m + n and an equivalence relation √õ‚àºon n + p
is the equivalence relation ‚âÉon m + p given by i ‚âÉk iÔ¨Äthere exists j ‚ààn with i ‚àºj and j √õ‚àºk.
5. Given equivalence relations ‚àºon m + n and ‚àº‚Ä≤ on m‚Ä≤ + n‚Ä≤, we need an equivalence relation
(‚àº+ ‚àº‚Ä≤) on m + n + m‚Ä≤ + n‚Ä≤. We take it to be ‚Äúthe obvious thing,‚Äù namely ‚Äúusing ‚àºon the
unprimed stuÔ¨Äand using ‚àº‚Ä≤ on the primed stuÔ¨Ä, with no other interaction.‚Äù To be pedantic,
i ‚àºj iÔ¨Äeither
‚Ä¢ i ‚â§m + n and j ‚â§m + n and i ‚àºj, or
‚Ä¢ m + n + 1 ‚â§i and m + n + 1 ‚â§j and i ‚àº‚Ä≤ j.
Example 5.8: The prop Rel has
1. Rel(m, n) is the set of relations on the set m √ó n, i.e. the set of subsets of m √ó n, i.e. its
powerset.
2. The identity map n ‚Üín is the subset {(i, j) ‚ààn √ó n | i  j}.
3. The symmetry map m + n ‚Üín + m is the subset of pairs (i, j) ‚àà(m + n) √ó (n + m) such that
either
‚Ä¢ i ‚â§m and m + 1 ‚â§j and i + m  j, or
‚Ä¢ m + 1 ‚â§i and j ‚â§m and j + m  i.
4. Composition of relations is as in Example 5.8.
5. Given a relation R ‚äÜm √ó n and a relation R‚Ä≤ ‚äÜm‚Ä≤ √ó n‚Ä≤, we need a relation (R + R‚Ä≤) ‚äÜ
m + m‚Ä≤ √ó n + n‚Ä≤.
As stated in the example (footnote), this can be given by a universal
property: The monoidal product R1 + R2 of relations R1 ‚äÜm1 √ó n1 and R2 ‚äÜm2 √ó n2 is
given by R1 ‚äîR2 ‚äÜ(m1 √ó n1) ‚äî(m2 √ó n2) ‚äÜ(m1 ‚äîm2) √ó (n1 ‚äîn2).
Solution to Exercise 5.16.
Composition of an (m, n)-port graph G and an (n, p)-port graph H looks visually like sticking them
end to end, connecting the wires in order, removing the two outer boxes, and adding a new outer box.
For example, suppose we want to compose the following in the order shown:
a
b
c
d
e
#

A.5. SOLUTIONS FOR CHAPTER 5
295
The result is:
a
b
c
d
e
Solution to Exercise 5.18.
The monoidal product of two morphisms is drawn by stacking the corresponding port graphs. For this
problem, we just stack the left-hand picture on top of itself to obtain the righthand picture:
a
b
c
a
b
c‚Ä≤
a
b‚Ä≤
c‚Ä≤
Solution to Exercise 5.20.
We have a relation R ‚äÜP √ó P which generates a preorder ‚â§P on P, we have an arbitrary preorder
(Q, ‚â§Q) and a function f : P ‚ÜíQ, not necessarily monotonic.
1. Assume that for every x, y ‚ààP, if R(x, y) then f (x) ‚â§f (y); we want to show that f is monotone,
i.e. that for every x ‚â§P y we have f (x) ‚â§Q f (y). By deÔ¨Ånition of P being the reÔ¨Çexive, transitive
closure of R, we have x ‚â§P y iÔ¨Äthere exists n ‚ààN and x0, . . . , xn in P with x0  x and xn  y and
R(xi, xi+1) for each 0 ‚â§i ‚â§n ‚àí1. (The case n  0 handles reÔ¨Çexivity.) But then by assumption,
R(xi, xi+1) implies f (xi) ‚â§Q f (xi+1) for each i. By induction on i we show that f (x0) ‚â§Q f (xi)
for all 0 ‚â§i ‚â§n, at which point we are done.
2. Suppose now that f is monotone, and take x, y ‚ààP for which R(x, y) holds. Then x ‚â§P y
because ‚â§P is the smallest preorder relation containing R. (Another way to see this based on the
above description is with n  1, x0  x, and xn  y, which we said implies x ‚â§P y.) Since f is
monotone, we indeed have f (x) ‚â§Q f (y).
Solution to Exercise 5.21.
Suppose that P, Q, and R are as in Exercise 5.20 and we have a function 1 : Q ‚ÜíP.
1. If R(1(a), 1(b)) holds for all a ‚â§Q b then 1 is monotone, because R(x, y) implies x ‚â§P y.
2. It is possible for 1 : (Q, ‚â§Q) ‚Üí(P, ‚â§P) to be monotone and yet have some a, b ‚ààQ with a ‚â§Q b
and (1(a), 1(b)) < R. Indeed, take Q B {1} to be the free preorder on one element, and take
P B {1} with R  ¬ú. Then the unique function 1 : Q ‚ÜíP is monotone (because ‚â§P is reÔ¨Çexive
even though R is empty), and yet (1(1), 1(1)) < R.
Solution to Exercise 5.23.
Let G  (V, A, s, t) be a graph, let G be the free category on G, and let C be another category, whose set
of morphisms is denoted Mor(C).
1. To give a function Mor(C) ‚ÜíOb(C) means that for every element Mor(C) we need to give exactly
one element of Ob(C). So for dom we take any q ‚ààMor(C), view it as a morphism q : y ‚Üíz, and
send it to its domain y. Similarly for cod: we put cod(q) B z.
2. Suppose Ô¨Årst that we are given a functor F : G ‚ÜíC. On objects we have a function Ob(G) ‚ÜíOb(C),
and this deÔ¨Ånes f since Ob(G)  V. On morphisms, Ô¨Årst note that the arrows of graph G are ex-
actly the length=1 paths in G, whereas Mor(G) is the set of all paths in G, so we have an inclusion
A ‚äÜMor(G). The functor F provides a function Mor(G) ‚ÜíMor(C), which we can restrict to A
to obtain 1 : A ‚ÜíMor(C). All functors satisfy dom(F(r))  F(dom(r)) and cod(F(r))  F(cod(r))
for any r : w ‚Üíx. In particular when r ‚ààA is an arrow we have dom(r)  s(r) and cod(r)  t(r).

296
APPENDIX A. EXERCISE SOLUTIONS
Thus we have found ( f , 1) with the required properties.
Suppose second that we are given a pair of functions ( f , 1) where f : V ‚ÜíOb(C) and 1 : A ‚Üí
Mor(C) such that dom(1(a))  f (s(a)) and cod(1(a))  f (t(a)) for all a ‚ààA. DeÔ¨Åne F : G ‚ÜíC on
objects by f . An arbitrary morphism in G is a path p B (v0, a1, a2, . . . , an) in G, where v0 ‚ààV,
ai ‚ààA, v0  s(a1), and t(ai)  s(ai+1) for all 1 ‚â§i ‚â§n ‚àí1. Then 1(ai) is a morphism in C whose
domain is f (v0) and the morphisms 1(ai) and 1(ai+1) are composable for every 1 ‚â§i ‚â§n ‚àí1.
We then take F(p) B id f (v0) # 1(a1) # ¬∑ ¬∑ ¬∑ # 1(an) to be the composite. It is easy to check that this is
indeed a functor (preserves identities and compositions).
Third, we want to see that the two operations we just gave are mutually inverse. On objects this
is straightforward, and on morphisms it is straightforward to see that, given ( f , 1), if we turn
them into a functor F : G ‚ÜíC and then extract the new pair of functions ( f ‚Ä≤, 1‚Ä≤), then f  f ‚Ä≤ and
1  1‚Ä≤. Finally, given a functor F : G ‚ÜíC, we extract the pair of functions ( f , 1) as above and
then turn them into a new functor F‚Ä≤: G ‚ÜíC. It is clear that F and F‚Ä≤ act the same on objects,
so what about on morphisms. The formula says that F‚Ä≤ acts the same on morphisms of length 1
in G (i.e. on the elements of A). But an arbitrary morphism in G is just a path, i.e. a sequence of
composable arrows, and so by functoriality, both F and F‚Ä≤ must act the same on arbitrary paths.
3. (Mor(C), Ob(C), dom, cod)isagraph; let‚Äôs denote it U(C) ‚ààGrph. We have functorsFree: Grph ‚áÜ
Cat :U, and Free is left adjoint to U.
Solution to Exercise 5.24.
1. The elements of the free monoid on the set {a} are:
a0, a1, a2, a3, . . . , a2019, . . .
with monoid multiplication ‚àógiven by the usual natural number addition on the exponents,
ai ‚àóa j  ai+j.
2. This is isomorphic to N, by sending ai 7‚Üíi.
3. The elements of the free monoid on the set {a, b} are ‚Äòwords in a and b,‚Äô each of which we will
represent as a list whose entries are either a or b. Here are some:
[ ],
[a],
[b],
[a, a],
[a, b],
. . . ,
[b, a, b, b, a, b, a, a, a, a],
. . .
Solution to Exercise 5.28.
We have two props: the prop of port graphs and the free prop Free(G, s, t) where
G B {œÅm,n : m ‚Üín | m, n ‚ààN},
s(œÅm,n) B m,
t(œÅm,n) B n;
we want to show they are the same prop. As categories they have the same set of objects (in both cases,
N), so we need to show that for every m, n ‚ààN, they have the same set of morphisms (and that their
composition formulas and monoidal product formulas agree).
By DeÔ¨Ånition 5.25, a morphism m ‚Üín in Free(G) is a G-labeled port graph, i.e. a pair (Œì, ‚Ñì), where
Œì  (V, in, out, Œπ) is an (m, n)-port graph and ‚Ñì: V ‚ÜíG is a function, such that the ‚Äòarities agree.‚Äô What
does this mean? Recall that every vertex v ‚ààV is drawn as a box with some left-hand ports and some
right-hand ports‚Äîan arity‚Äîand ‚Ñì(v) ‚ààG is supposed to have the correct arity; precisely, s(‚Ñì(v))  in(v)
and t(‚Ñì(v))  out(v). But G was chosen so that it has exactly one element with any given arity, so the
function ‚Ñìhas only one choice, and thus contributes nothing: it neither increases nor decreases the
freedom. In other words, a morphism in our particular Free(G) can be identiÔ¨Åed with an (m, n) port
graph Œì, as desired.
Again by deÔ¨Ånition DeÔ¨Ånition 5.25, the ‚Äòcomposition and the monoidal structure are just those for port
graphs PG (see Eq. (5.17)); the labelings (the ‚Ñì‚Äôs) are just carried along.‚Äô So we are done.

A.5. SOLUTIONS FOR CHAPTER 5
297
Solution to Exercise 5.32.
Here is a picture of ( f + id1 + id1) # (œÉ + id1) # (id1 + h) # œÉ # 1, in the free prop on generators G  { f : 1 ‚Üí
1, 1 : 2 ‚Üí2, h : 2 ‚Üí1}:
f
h
1
Solution to Exercise 5.35.
The free prop on generators (G, s, t), deÔ¨Åned in DeÔ¨Ånition 5.25, is‚Äîfor all intents and purposes‚Äî
the same thing as the prop presented by (G, s, t, ¬ú), having no relations. The only possible ‚Äúsubtle
diÔ¨Äerence‚Äù we might have to admit is if someone said that a set S is ‚Äúsubtly diÔ¨Äerent‚Äù than its quotient
by the trivial equivalence relation. In the latter, the elements are the singleton subsets of S. So for
example the quotient of S  {1, 2, 3} by the trivial equivalence relation is the set {{1}, {2}, {3}}. It is
subtly diÔ¨Äerent than S, but the two are naturally isomorphic, and category-theoretically, the diÔ¨Äerence
will never make a diÔ¨Äerence.
Solution to Exercise 5.41.
1. If (R, 0, +, 1, ‚àó) is a rig, then the multiplicative identity 1 ‚ààMatn(R) is the usual n-by-n identity
matrix: 1‚Äôs on the diagonal and 0‚Äôs everywhere else (where by ‚Äò1‚Äô and ‚Äò0‚Äô, we mean those elements
of R). So for n  4 it is:
¬©¬≠¬≠¬≠¬≠
¬´
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
¬™¬Æ¬Æ¬Æ¬Æ
¬¨
.
2. We choose n  2 and hence need to Ô¨Ånd two elements A, B ‚ààMat2(N) such that A ‚àóB , B ‚àóA.
A ‚àóB 
 0
1
0
0

‚àó
 0
1
1
0

,
 0
1
1
0

‚àó
 0
1
0
0

 B ‚àóA
One can calculate from the multiplication formula (recalled in Example 5.40) says (A ‚àóB)(1, 1) 
0 ‚àó0 + 1 ‚àó1  1 and (B ‚àóA)(1, 1)  0 ‚àó0 + 0 ‚àó0  0, which are not equal.
Solution to Exercise 5.43.
Semantically, if we apply the Ô¨Çow graph below to the input signal (x, y)
3
5
3
the resulting output signal is (16x + 4y, x + 4y).
Solution to Exercise 5.51.
The monoidal product of A 
 3
3
1
2
0
4

and B 

2
5
6
1

is
A + B 
¬©¬≠¬≠
¬´
3
3
1
0
0
0
0
2
0
4
0
0
0
0
0
0
0
2
5
6
1
¬™¬Æ¬Æ
¬¨

298
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 5.55.
1. The signal Ô¨Çow graph on the left represents the matrix on the right:

1
1
1

2. The signal Ô¨Çow graph on the left represents the matrix on the right:

1
1
1

3. They are equal.
Solution to Exercise 5.58.
1.
¬©¬≠¬≠
¬´
0
1
2
¬™¬Æ¬Æ
¬¨
‚àº
2
2.
0
0
0
0

‚àº
3.
1
2
3
4
5
6

‚àº
2
3
4
5
6
Solution to Exercise 5.59.
‚Ä¢ For the Ô¨Årst layer 11, take the monoidal product of m copies of cn,
11 B cn + ¬∑ ¬∑ ¬∑ + cn : m ‚Üí(m √ó n),
where cn is the signal Ô¨Çow diagram that makes n copies of a single input:
cn B
# (1 +
) # (1 + 1 +
) # ¬∑ ¬∑ ¬∑ # (1 + ¬∑ ¬∑ ¬∑ + 1 +
): 1 ‚Üín
‚Ä¢ Next, deÔ¨Åne
12 B
sM(1,1) + ¬∑ ¬∑ ¬∑ + sM(1,n)
+ sM(2,1) + ¬∑ ¬∑ ¬∑ + sM(2,n)
+ ¬∑ ¬∑ ¬∑
+ sM(m,1) + ¬∑ ¬∑ ¬∑ + sM(m,n) : (m √ó n) ‚Üí(m √ó n),
where sa : 1 ‚Üí1 is the signal Ô¨Çow graph generator ‚Äúscalar multiplication by a.‚Äù This layer
ampliÔ¨Åes each copy of the input signal by the relevant rig element.
‚Ä¢ The third layer rearranges wires. We will not write this down explicitly, but simply say it is the
signal Ô¨Çow graph 13 : m √ó n ‚Üím √ó n, that is the composite and monoidal product of swap and
identity maps, such that the (i ‚àí1)m + jth input is sent to the (j ‚àí1)n + ith output, for all 1 ‚â§i ‚â§n
and 1 ‚â§j ‚â§m.
‚Ä¢ Finally, the fourth layer is similar to the Ô¨Årst, but instead adds the ampliÔ¨Åed input signals. We
deÔ¨Åne
14 B am + ¬∑ ¬∑ ¬∑ + am : (m √ó n) ‚Üín,

A.5. SOLUTIONS FOR CHAPTER 5
299
where am is the signal Ô¨Çow graph that adds m inputs to produce a single output:
am B (1 + ¬∑ ¬∑ ¬∑ + 1 +
) # ¬∑ ¬∑ ¬∑ # (1 + 1 +
) # (1 +
) #
: m ‚Üí1
Using Proposition 5.54, it is a straightforward but tedious calculation to show that 1  11#12#13#14 : m ‚Üí
n has the property that S(1)  M.
Solution to Exercise 5.62.
1. The matrices in Exercise 5.58 may also be drawn as the following signal Ô¨Çow graphs:
a)
¬©¬≠¬≠
¬´
0
1
2
¬™¬Æ¬Æ
¬¨
‚àº
b)
0
0
0
0

‚àº
0
c)
1
2
3
4
5
6

‚àº
2
3
5
4
6
2. Here are graphical proofs that the representations we chose in our solution to Exercise 5.58 agree
with those chosen in Part 1 above.
a)

1
1

2
b)
0


c)
2
3
5
4
6

2
3
4
5
6

2
3
4
5
6

2
3
4
5
6
Solution to Exercise 5.63.
1. The signal Ô¨Çow graphs
and
3
5
3
3
3
5
3

300
APPENDIX A. EXERCISE SOLUTIONS
cannot represent the same morphism because one has a path from a vertex on the left to one
on the right, and the other does not. To prove this, observe that the only graphical equation in
Theorem 5.60 that breaks a path from left to right is the equation
0

So a 0 scalar must within a path from left to right before we could rewrite the diagram to break
that path. No such 0 scalar can appear, however, because the diagram does not contain any, and
the sum and product of any two nonzero natural numbers is always nonzero.
2. Replacing each of the 3s with 0 allows us to rewrite the diagram to
Solution to Exercise 5.67.
The three conditions of DeÔ¨Ånition 5.65 are
(a) (¬µ ‚äóid) # ¬µ  (id ‚äó¬µ) # ¬µ,
(b) (Œ∑ ‚äóid) # ¬µ  id  (id ‚äóŒ∑) # ¬µ, and
(c) œÉM,M # ¬µ  ¬µ.
where œÉM,M is the swap map on M in C.
1. Suppose ¬µ: R √ó R ‚ÜíR is deÔ¨Åned by ¬µ(a, b)  a ‚àób and Œ∑ ‚ààR is deÔ¨Åned to be Œ∑  1. The
conditions, written diagrammatically, say that starting in the upper left of each diagram below,
the result in the lower right is the same regardless of which path you take:
(a, b, c)
(a ‚àób, c)
(a, b ‚àóc)
a ‚àób ‚àóc
(¬µ‚äóid)
(id‚äó¬µ)
¬µ
¬µ
a
(1, a)
(a, 1)
a
(Œ∑‚äóid)
(id‚äóŒ∑)
ida
¬µ
¬µ
(a, b)
(b, a)
a ‚àób
œÉ
¬µ
¬µ
and this is true for (R, ‚àó, 1).
2. The same reasoning works for (R, +, 0), shown below:
(a, b, c)
(a+b, c)
(a, b+c)
a+b+c
(¬µ‚äóid)
(id‚äó¬µ)
¬µ
¬µ
a
(0, a)
(a, 0)
a
(Œ∑‚äóid)
(id‚äóŒ∑)
ida
¬µ
¬µ
(a, b)
(b, a)
a+b
œÉ
¬µ
¬µ
Solution to Exercise 5.69.
The functor U : Mat(R) ‚ÜíSet is given on objects by sending n to the set Rn, and on morphisms by
matrix-vector multiplication. Here Rn means the set of n-tuples or n-dimensional vectors in R. In
particular, R0  {()} consists of a single vector of dimension 0.
1. U preserves the monoidal unit because 0 is the monoidal unit of any prop (Mat(R) is a prop),
{1} is the monoidal unit of Set, and R0 is canonically isomorphic to {1}. U also preserves the
monoidal product because there is a canonical isomorphism Rm √ó Rn  Rm+n.
2. A monoid object in Mat(R) is a tuple (m, ¬µ, Œ∑) where m ‚ààN, ¬µ: m + m ‚Üím, and Œ∑: 0 ‚Üím
satisfy the properties ¬µ(Œ∑, x)  x  ¬µ(x, Œ∑) and ¬µ(x, ¬µ(y, z))  ¬µ(¬µ(x, y), z). Note that there is
only one morphism 0 ‚Üím in Mat(R) for any m. It is not hard to show that for any m ‚ààN there
is only one monoid structure. For example, when m  2, ¬µ must be the following matrix
¬µ B
¬©¬≠¬≠¬≠¬≠
¬´
1
0
0
1
1
0
0
1
¬™¬Æ¬Æ¬Æ¬Æ
¬¨

A.5. SOLUTIONS FOR CHAPTER 5
301
Anyway, for any monoid (m, ¬µ, Œ∑), the morphism U(Œ∑): R0 ‚ÜíRm is given by U(Œ∑)(1) B
(0, . . . , 0), and the morphism U(¬µ): Rm √ó Rm ‚ÜíRm is given by
U(¬µ)((a1, . . . , am), (b1, . . . , bm)) B (a1 + b1, . . . , am + bm).
These give Rm the structure of a monoid.
3. The triple (1,
,
) corresponds to the additive monoid structure on R, e.g. with (5, 3) 7‚Üí8.
Solution to Exercise 5.77.
1. The behavior B(
) of the reversed addition icon
: 1 ‚Üí2 is the relation {(x, y, z) ‚ààR3 | x 
y + z}.
2. The behavior B(
) of the reversed copy icon,
: 2 ‚Üí1 is the relation {(x, y, z) ‚ààR3 | x  y 
z}.
Solution to Exercise 5.80.
If B ‚äÜRm √ó Rn and C ‚äÜRp √ó Rq are morphisms in RelR, then take B + C ‚äÜRm+p √ó Rn+q to be the set
B + C B {(w, y, x, z) ‚ààRm+p √ó Rn+q | (w, x) ‚ààB and (y, z) ‚ààC}.
Solution to Exercise 5.82.
The behavior of 1 : m ‚Üín and hop : n ‚Üí‚Ñìare respectively
B(1)  {(x, z) ‚ààRm √ó Rn | S(1)(x)  z}
B(hop)  {(z, y) ‚ààRn √ó R‚Ñì| z  S(h)(y)}
and by Eq. (5.78), the composite B(1 # (hop))  B(1) # B(hop) is:
{(x, y) | there exists z ‚ààRn such that S(1)(x)  z and z  S(h)(y)}.
Since S(1) and S(h) are functions, the above immediately reduces to the desired formula:
B(1 # (hop))  {(x, y) | S(1)(x)  S(h)(y)}.
Solution to Exercise 5.83.
The behavior of 1op : n ‚Üím and h : m ‚Üíp are respectively
B(1op)  {(y, x) ‚ààRn √ó Rm | y  S(1)(x)}
B(h)  {(x, z) ‚ààRm √ó Rp | S(h)(x)  z}
and by Eq. (5.78), the composite B((1op) # h)  B(1op) # B(h) is:
{(y, z) | there exists x ‚ààRm such that y  S(1)(x) and S(h)(x)  z}.
This immediately reduces to the desired formula:
B((1op) # h)  {(S(1)(x), S(h)(x)) | x ‚ààRm}.
Solution to Exercise 5.84.
1. The behavior of the 0-reverse
is the subset {y ‚ààR | y  0}, and its n-fold tensor is similarly
{y ‚ààRn | y  0}. Composing this relation with S(1) ‚äÜRm √ó Rn gives {x ‚ààRm | S(1)  0},
which is the kernel of S(1).
2. The behavior of the discard-inverse
is the subset {x ‚ààR}, i.e. the largest subset of R, and
similarly its m-fold tensor is Rn ‚äÜRn. Composing this relation with S(1) ‚äÜRm √ó Rn gives
{y ‚ààRn | there exists x ‚ààRm such that S(1)(x)  y}, which is exactly the image of S(1).

302
APPENDIX A. EXERCISE SOLUTIONS
3. For any 1 : m ‚Üín, we Ô¨Årst claim that the behavior B(1)  {(x, y) | S(1)(x)  y} is linear, i.e. it
is closed under addition and scalar multiplication. Indeed, S(1) is multiplication by a matrix,
so if S(1)(x)  y then S(1)(rx)  ry and S(1)(x1 + x2)  S(1)(x1) + S(1)(x2). Thus we con-
clude that (x, y) ‚ààB(1) implies (rx, ry) ‚ààB(1), so it‚Äôs closed under scalar multiplication, and
(x1, y1), (x2, y2) ‚ààB(1) implies (x1 + x2, y1 + y2) ‚ààB(1) so it‚Äôs closed under addition. Similarly,
the behavior B(1op) is also linear; the proof is similar.
Finally, we need to show that the composite of any two linear relations is linear. Suppose that
B ‚äÜRm √ó Rn and C ‚äÜRn √ó Rp are linear.
Take (x1, z1), (x2, z2) ‚ààB # C and take r ‚ààR.
By deÔ¨Ånition, there exist y1, y2 ‚ààRn such that (x1, y1), (x2, y2) ‚ààB and (y1, z1), (y2, z2) ‚ààC.
Since B and C are linear, (rx1, ry1) ‚ààB and (ry1, rz1) ‚ààC, and also (x1 + x2, y1 + y2) ‚ààB and
(y1 + y2, z1 + z2) ‚ààC. Hence (rx1, rz1) ‚àà(B # C) and (x1 + x2, z1 + z2) ‚àà(B # C), as desired.
Solution to Exercise 5.85.
Suppose that B ‚äÜRm √óRn and C ‚äÜRn √óRp are linear. Their composite is the relation (B #C) ‚äÜRm √óRp
consisting of all (x, z) for which there exists y ‚ààRn with (x, y) ‚ààB and (y, z) ‚ààC. We want to show
that the set (B # C) is linear, i.e. closed under scalar multiplication and addition.
For scalar multiplication, take an (x, z) ‚àà(B #C) and any r ‚ààR. Since B is linear, we have (r ‚àóx, r ‚àóy) ‚ààB
and since C is linear we have (r ‚àóy, r ‚àóz) ‚ààC, so then (r ‚àóx, r ‚àóz) ‚àà(B # C). For addition, if we also
have (x‚Ä≤, z‚Ä≤) ‚àà(B # C) then there is some y‚Ä≤ ‚ààRn with (x‚Ä≤, y‚Ä≤) ‚ààB and (y‚Ä≤, z‚Ä≤) ‚ààC, so since B and C are
linear we have (x + x‚Ä≤, y + y‚Ä≤) ‚ààB and (y + y‚Ä≤, z + z‚Ä≤) ‚ààC, hence (x + x‚Ä≤, z + z‚Ä≤) ‚àà(B # C).

A.6. SOLUTIONS FOR CHAPTER 6
303
A.6
Solutions for Chapter 6.
Solution to Exercise 6.3.
Let A  {a, b}, and consider the preorders shown here:
a‚Ä¢
b‚Ä¢ ,
a‚Ä¢ ‚Üí
b‚Ä¢ ,
a‚Ä¢ ‚áÜ
b‚Ä¢ .
1. The left-most (the discrete preorder on A) has no initial object, because a ‚â∞b and b ‚â∞a.
2. The middle one has one initial object, namely a.
3. The right-most (the co-discrete preorder on A) has two initial objects.
Solution to Exercise 6.6.
Recall that the objects of a free category on a graph are the vertices of the graph, and the morphisms
are paths. Thus the free category on a graph G has an initial object if there exists a vertex v that has a
unique path to every object. In 1. and 2., the vertex a has this property, so the free categories on graphs
1. and 2. have initial objects. In graph 3., neither a nor b have a path to each other, and so there is no
initial object. In graph 4., the vertex a has many paths to itself, and hence its free category does not
have an initial object either.
Solution to Exercise 6.7.
1. The remaining conditions are that f (1R)  1S, and that f (r1 ‚àóR r2)  f (r1) ‚àóS f (r2).
2. The initial object in the category Rig is the natural numbers rig (N, 0, +, 1, ‚àó). The fact that is
initial means that for any other rig R  (R, 0R, +R, 1R, ‚àóR), there is a unique rig homomorphism
f : N ‚ÜíR.
What is this homomorphism? Well, to be a rig homomorphism, f must send 0 to 0R, 1 to 1R.
Furthermore, we must also have f (m + n)  f (m) +R f (n), and hence
f (m)  f (1 + 1 + ¬∑ ¬∑ ¬∑ + 1
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
m summands
)  f (1) + f (1) + ¬∑ ¬∑ ¬∑ + f (1)
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
m summands
 1R + 1R + ¬∑ ¬∑ ¬∑ + 1R
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
m summands
.
So if there is a rig homomorphism f : N ‚ÜíR, it must be given by the above formula. But does
this formula work correctly for multiplication?
It remains to check f (m ‚àón)  f (m) ‚àóR f (n), and this will follow from distributivity. Noting that
f (m ‚àón) is equal to the sum of mn copies of 1R, we have
f (m) ‚àóR f (n)  (1R + ¬∑ ¬∑ ¬∑ + 1R
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
m summands
) ‚àóR (1R + ¬∑ ¬∑ ¬∑ + 1R
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
n summands
)
 1R ‚àó(1R + ¬∑ ¬∑ ¬∑ + 1R
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
n summands
) + ¬∑ ¬∑ ¬∑ + 1R ‚àó(1R + ¬∑ ¬∑ ¬∑ + 1R
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
n summands
)
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
m summands
 1R + ¬∑ ¬∑ ¬∑ + 1R
|¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®{z¬®¬®¬®¬®¬®¬®¬®¬®¬®¬®}
mn summands
 f (m ‚àón).
Thus (N, 0, +, 1, ‚àó) is the initial object in Rig.
Solution to Exercise 6.8.
In DeÔ¨Ånition 6.1, it is the initial object ¬ú ‚ààC that is universal.
In this case, all objects c ‚ààC are
‚Äòcomparable objects‚Äô. So the universal property of the initial object is that to any object c ‚ààC, there is a
unique map ¬ú ‚Üíc coming from the initial object.
Solution to Exercise 6.10.
If c1 is initial then by the universal property, for any c there is a unique morphism c1 ‚Üíc; in particular,
there is a unique morphism c1 ‚Üíc2, call it f . Similarly, if c2 is initial then there is a unique morphism
c2 ‚Üíc1, call it 1. But how do we know that f and 1 are mutually inverse? Well since c1 is initial

304
APPENDIX A. EXERCISE SOLUTIONS
there is a unique morphism c1 ‚Üíc1. But we can think of two: idc1 and f # 1. Thus they must be
equal. Similarly for c2, so we have f # 1  idc1 and 1 # f  idc2, which is the deÔ¨Ånition of f and 1 being
mutually inverse.
Solution to Exercise 6.13.
Let (P, ‚â§) be a preorder, and p, q ‚ààP. Recall that a preorder is a category with at most one morphism,
denoted ‚â§, between any two objects. Also recall that all diagrams in a preorder commute, since this
means any two morphisms with the same domain and codomain are equal.
Translating DeÔ¨Ånition 6.11 to this case, a coproduct p + q is P is an element of P such that p ‚â§p + q and
q ‚â§p + q, and such that for all elements x ‚ààP with maps p ‚â§x and q ‚â§x, we have p + q ‚â§x. But this
says exactly that p + q is a join: it is a least element above both p and q. Thus coproducts in preorders
are exactly the same as joins.
Solution to Exercise 6.16.
The function [ f , 1] is deÔ¨Åned by
[ f , 1]: A ‚äîB ‚àí‚ÜíT
apple1 7‚àí‚Üía
banana1 7‚àí‚Üíb
pear1 7‚àí‚Üíp
cherry1 7‚àí‚Üíc
orange1 7‚àí‚Üío
apple2 7‚àí‚Üíe
tomato2 7‚àí‚Üío
mango2 7‚àí‚Üío.
Solution to Exercise 6.17.
1. The equation ŒπA # [ f , 1]  f is the commutativity of the left hand triangle in the commutative
diagram (6.12) deÔ¨Åning [ f , 1].
2. The equation ŒπB # [ f , 1]  1 is the commutativity of the right hand triangle in the commutative
diagram (6.12) deÔ¨Åning [ f , 1].
3. The equation [ f , 1]#h  [ f #h, 1#h] follows from the universal property of the coproduct. Indeed,
the diagram
A
A + B
B
C
D
ŒπA
f
f #h
[ f ,1]
ŒπB
1
1#h
h
commutes, and the universal property says there is a unique map [ f # h, 1 # h]: A + B ‚ÜíD for
which this occurs. Hence we must have [ f , 1] # h  [ f # h, 1 # h].
4. Similarly, to show [ŒπA, ŒπB]  idA+B, observe that the diagram
A
A + B
B
A + B
ŒπA
ŒπA
idA+B
ŒπB
ŒπB
trivially commutes. Hence by the uniqueness in (6.12), [ŒπA, ŒπB]  idA+B.

A.6. SOLUTIONS FOR CHAPTER 6
305
Solution to Exercise 6.18.
This exercise is about showing that coproducts and an initial object give a symmetric monoidal category.
Since all we have are coproducts and an initial object, and since these are deÔ¨Åned by their universal
properties, the solution is to use these universal properties over and over, to prove that all the data of
DeÔ¨Ånition 4.45 can be constructed.
1. To deÔ¨Åne a functor +: C √ó C ‚ÜíC we must deÔ¨Åne its action on objects and morphisms. In both
cases, we just take the coproduct. If (A, B) is an object of C √ó C, its image A + B is, as usual, the
coproduct of the two objects of C. If ( f , 1): (A, B) ‚Üí(C, D) is a morphism, then we can form a
morphism f + 1  [ f # ŒπC, 1 # ŒπD]: A + B ‚ÜíC + D, where ŒπC : C ‚ÜíC + D and ŒπD : D ‚ÜíC + D
are the canonical morphisms given by the deÔ¨Ånition of the coproduct A + B.
Note that this construction sends identity morphisms to identity morphisms, since by Exer-
cise 6.17 4 we have
idA + idB  [idA # ŒπA, idB # ŒπB]  [ŒπA, ŒπB]  idA+B.
To show that + is a functor, we need to also show it preserves composition. Suppose we also have
a morphism (h, k): (C, D) ‚Üí(E, F) in C√óC. We need to show that ( f + 1)#(h + k)  ( f # h)+(1 # k).
This is a slightly more complicated version of the argument in Exercise 6.17 3. It follows from the
fact the diagram below commutes:
A
A + B
B
C
C + D
D
E + F
ŒπA
f
f +1
ŒπB
1
ŒπC
h#ŒπE
h+k
ŒπD
k#ŒπF
Indeed, we again use the uniqueness of the copairing in (6.12), this time to show that ( f #h)+(1#k) 
[ f # h # ŒπE, 1 # k # ŒπF]  ( f + 1) # (h + k), as required.
2. Recall the universal property of the initial object gives a unique map !A : ¬ú ‚ÜíA. Then the
copairing [idA, !A] is a map A + ¬ú ‚ÜíA. Moreover, it is an isomorphism with inverse ŒπA : A ‚Üí
A + ¬ú. Indeed, using the properties in Exercise 6.17 and the universal property of the initial
object, we have ŒπA # [idA, !A]  idA, and
[idA, !A] # ŒπA  [idA # ŒπA, !A # ŒπA]  [ŒπA, !A+¬ú]  [ŒπA, Œπ¬ú]  idA+¬ú.
An analogous argument shows [!A, idA]: ¬ú + A ‚ÜíA is an isomorphism.
3. We‚Äôll just write down the maps and their inverses; we leave it to you, if you like, to check that
they indeed are inverses.
a) The map [idA + ŒπB, ŒπC]  [[ŒπA, ŒπB # ŒπB+C], ŒπC # ŒπB+C]: (A + B) + C ‚ÜíA + (B + C) is an
isomorphism, with inverse [ŒπA, ŒπB + idC]: A + (B + C) ‚Üí(A + B) + C.
b) The map [ŒπA, ŒπB]: A + B ‚ÜíB + A is an isomorphism. Note our notation here is slightly
confusing: there are two maps named ŒπA, (i) ŒπA : A ‚ÜíA + B, and (ii) ŒπA : A ‚ÜíB + A, and
similarly for ŒπB. In the above we mean the map (ii). It has inverse [ŒπA, ŒπB]: B + A ‚ÜíA + B,
where in this case we mean the map (i).
Solution to Exercise 6.24.
1. Suppose given an arbitrary diagram of the form B ‚ÜêA ‚ÜíC in DiscS; we need to show that it
has a pushout. The only morphisms in DiscS are identities, so in particular A  B  C, and the
square consisting of all identities is its pushout.
2. Suppose DiscS has an initial object s. Then S cannot be empty! But it also cannot have more
than one object, because if s‚Ä≤ is another object then there is a morphism s ‚Üís‚Ä≤, but the only
morphisms in S are identities so s  s‚Ä≤. Hence the set S must consist of exactly one element.

306
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 6.26.
The pushout is the set 4, as depicted in the top right in the diagram below, equipped also with the
depicted functions:
f
1
pushout
(A.1)
We want to see that this checks out with the description from Example 6.25, i.e. that it is the set of
equivalence classes in 5 ‚äî3 generated by the relation { f (a) ‚àº1(a) | a ‚àà4}. If we denote elements of 5
as {1, . . . , 5} and those of 3 as {1‚Ä≤, 2‚Ä≤, 3‚Ä≤}, we can redraw the functions f , 1:
1
‚Ä¢
1‚Ä≤
2
‚Ä¢
2‚Ä≤
3
‚Ä¢
3‚Ä≤
4
‚Ä¢
5
which says we take the equivalence relation on 5 ‚äî3 generated by: 1 ‚àº1‚Ä≤, , 3 ‚àº1‚Ä≤, 5 ‚àº2‚Ä≤, and 5 ‚àº3‚Ä≤.
The equivalence classes are {1, 1‚Ä≤, 3}, {2}, {4}, and {5, 2‚Ä≤, 3‚Ä≤}. These four are exactly the four elements
in the set labeled ‚Äòpushout‚Äô in Eq. (A.1).
Solution to Exercise 6.28.
1. The diagram to the left commutes because ¬ú is initial, and so has a unique map ¬ú ‚ÜíX + Y. This
implies we must have f # ŒπX  1 # ŒπY.
2. There is a unique map X +Y ‚ÜíT making the diagram in (6.21) commute simply by the universal
property of the coproduct (6.12) applied to the maps x : X ‚ÜíT and y : Y ‚ÜíT.
3. Suppose X +¬ú Y exists. By the universal property of ¬ú, given any pair of arrows x : X ‚ÜíT and
y : Y ‚ÜíT, the diagram
¬ú
X
Y
T
f
1
x
y
commutes. This means, by the universal property of the pushout X +¬ú Y, there exists a unique
map t : X +¬ú Y ‚ÜíT such that ŒπX # t  x and ŒπY # t  y. Thus X +¬ú Y is the coproduct X + Y.
Solution to Exercise 6.35.
We have to check that the colimit of the diagram shown left really is given by taking three pushouts as
shown right:
B
Z
A
C
D
B
Z
A
Y
R
X
Q
S
‚åú
‚åú
‚åú

A.6. SOLUTIONS FOR CHAPTER 6
307
That is, we need to show that S, together with the maps from A, B, X, Y, and Z, has the required
universal property. So suppose given an object T with two commuting diagrams as shown:
B
Z
A
Y
X
T
We need to show there is a unique map S ‚ÜíT making everything commute. Since Q is a pushout of
X ‚ÜêA ‚ÜíY, there is a unique map Q ‚ÜíT making a commutative triangle with Y, and since R is the
pushout of Y ‚ÜêB ‚ÜíZ, there is a unique map R ‚ÜíT making a commutative triangle with Y. This
implies that there is a commuting (Y, Q, R, T) square, and hence a unique map S ‚ÜíT from its pushout
making everything commute. This is what we wanted to show.
Solution to Exercise 6.41.
The formula in Theorem 6.37 says that the pushout X +N Y is given by the set of equivalence classes of
X ‚äîN ‚äîY under the equivalence relation generated by x ‚àºn if x  f (n), and y ‚àºn if y  1(n), where
x ‚ààX, y ‚ààY, n ‚ààN. Since for every n ‚ààN there exists an x ‚ààX such that x  f (n), this set is equal to
the set of equivalence classes of X ‚äîY under the equivalence relation generated by x ‚àºy if there exists
n such that x  f (n) and y  1(n). This is exactly the description of Example 6.25.
Solution to Exercise 6.48.
The monoidal product is
A + B
N + P
B + C
Solution to Exercise 6.49.
Let x and y be composable cospans in CospanFinSet. In terms of wires and connected components,
the composition rule in CospanFinSet says that (i) the composite cospan has a unique element in the
apex for every connected component of the concatenation of the wire diagrams x and y, and (ii) in the
wire diagram for x # y, each element of the feet is connected by a wire to the element representing the
connected component to which it belongs.
Solution to Exercise 6.57.
Morphisms 1, 4, and 6 are equal, and morphisms 3 and 5 are equal. Morphism 3 is not equal to any
other depicted morphism. This is an immediate consequence of Theorem 6.55.
Solution to Exercise 6.59.
1. The input to h should be labelled B.

308
APPENDIX A. EXERCISE SOLUTIONS
2. The output of 1 should be labelled D, since we know from the labels in the top right that h is a
morphism B ‚ÜíD ‚äóD.
3. The fourth output wire of the composite should be labelled D too!
Solution to Exercise 6.62.
We draw the function depictions above, and the wiring depictions below. Note that we depict the
empty set with blank space.
1 + 1
1
1
multiplication ¬µ1
¬ú
1
1
unit Œ∑1
1
1
1 + 1
comultiplication Œ¥1
1
1
¬ú
counit œµ1
Solution to Exercise 6.63.
The special law says that the composite of cospans
 X
id
‚àí‚ÜíX
[id,id]
‚Üê‚àí‚àí‚àí‚àí‚àíX + X
[id,id]
‚àí‚àí‚àí‚àí‚àí‚ÜíX
id
‚Üê‚àíX
is the identity. This comes down to checking that the square
X + X
X
X
X
[id,id]
[id,id]
id
id
(A.2)
is a pushout square. It is trivial to see that the square commutes. Suppose now that we have maps
f : X ‚ÜíY and 1 : X ‚ÜíY such that
X + X
X
X
T
[id,id]
[id,id]
f
1
Write Œπ1 : X ‚ÜíX + X for the map into the Ô¨Årst copy of X in X + X, given by the deÔ¨Ånition of coproduct.
Then, using the fact that Œπ1 # [id, id]  id from Exercise 6.17 1, and the commutativity of the above
square, we have f  Œπ1 # [id, id] # f  Œπ1 # [id, id] # 1  1. This means that f : X ‚ÜíT is the unique map
such that
X
X
X
X
T
[id,id]
[id,id]
id
f
id
1 f
f
commutes, and so (A.2) is a pushout square.
Solution to Exercise 6.67.
The missing diagram is

A.6. SOLUTIONS FOR CHAPTER 6
309
Solution to Exercise 6.70.
Let A ‚äÜS and B ‚äÜT. Then
œïS‚Ä≤,T‚Ä≤

(im f √ó im1)(A √ó B)

 œïS‚Ä≤,T‚Ä≤({ f (a) | a ‚ààA} √ó {1(b) | b ‚ààB})
 {( f (a), 1(b)) | a ‚ààA, b ‚ààB}
 im f √ó1(A √ó B)
 im f √ó1(œïS,T(A, B)).
Thus the required square commutes.
Solution to Exercise 6.78.
They mean that every category CospanC is equal to a category CospanF, for some well-chosen F. They
also tell you how to choose this F: take the functor F : C ‚ÜíSet that sends every object of C to the set
{‚àó}, and every morphism of C to the identity function on {‚àó}. Of course, you will have to check this
functor is a lax symmetric monoidal functor, but in fact this is not hard to do.
To check that CospanC is equal to CospanF, Ô¨Årst observe that they have the same objects: the objects of
C. Next, observe that a morphism in CospanF is a cospan X ‚ÜêN ‚ÜíY in C together with an element
of FN  {‚àó}. But FN also has a unique element, ‚àó! So there‚Äôs no choice here, and we can consider
morphisms of CospanF just to be cospans in C. Moreover, composition of morphisms in CospanF is
simply the usual composition of cospans via pushout, so CospanF  CospanC.
(More technically, we might say that CospanC and CospanF are isomorphic, where the isomorphism
is the identity-on-objects functor CospanC ‚ÜíCospanF that simply decorates each cospan with ‚àó, and
its inverse is the one that forgets this ‚àó. But this is close enough to equal that many category theorists,
us included, don‚Äôt mind saying equal in this case.)
Solution to Exercise 6.79.
We can represent the circuit in Eq. (6.71) by the tuple (V, A, s, t, ‚Ñì) where V  {ul, ur, dl, dr}, A 
{r1, r2, r3, c1, i1}, and s, t, and ‚Ñìare deÔ¨Åned by the table
r1
r2
r3
c1
i1
s(‚àí)
dl
ul
ur
ul
dl
t(‚àí)
ul
ur
dr
ur
dr
‚Ñì(‚àí)
1‚Ñ¶
2‚Ñ¶
1‚Ñ¶
3F
1H
Solution to Exercise 6.80.
The circuit Circ( f )(c) is
3‚Ñ¶
1
2 ‚àº3
4
Solution to Exercise 6.82.
The circuit œà2,2(b, s) is the disjoint union of the two labelled graphs b and s:
Solution to Exercise 6.84.
The cospan is the cospan 1
f
‚àí‚Üí2
1
‚Üê‚àí1, where f (1)  1 and 1(1)  2. The decoration is the C-circuit
(2, {a}, s, t, ‚Ñì), where s(a)  1, t(a)  2 and ‚Ñì(a)  battery.

310
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 6.86.
Recall the circuit C B (V, A, s, t, ‚Ñì) from the solution to Exercise 6.79. Then the Ô¨Årst decorated cospan
is given by the cospan 1
f
‚àí‚ÜíV
1
‚Üê‚àí2, f (1)  ul, 1(1)  ur, and 1(2)  ur, decorated by circuit C. The
second decorated cospan is given by the cospan 2
f ‚Ä≤
‚àí‚ÜíV‚Ä≤
1‚Ä≤
‚Üê‚àí2 and the circuit C‚Ä≤ B (V‚Ä≤, A‚Ä≤, s‚Ä≤, t‚Ä≤, ‚Ñì‚Ä≤),
where V‚Ä≤  {l, r, d}, A‚Ä≤  {r1‚Ä≤, r2‚Ä≤}, and the functions are given by the tables
1
2
f ‚Ä≤(‚àí)
l
d
1‚Ä≤(‚àí)
r
r
r1‚Äô
r2‚Äô
s(‚àí)
l
r
t(‚àí)
r
d
‚Ñì(‚àí)
5‚Ñ¶
8‚Ñ¶
To compose these, we Ô¨Årst take the pushout of V
1
‚Üê‚àí2
f ‚Ä≤
‚àí‚ÜíV‚Ä≤.
This gives the a new apex V‚Ä≤‚Ä≤ 
{ul, dl, dr, m, r} with Ô¨Åve elements, and composite cospan 1
h‚àí‚ÜíV‚Ä≤‚Ä≤
k‚Üê‚àí2 given by h(1)  ul, k(1)  r
and k(2)  m. The new circuit is given by (V,‚Ä≤‚Ä≤ A + A‚Ä≤, s,‚Ä≤‚Ä≤ t,‚Ä≤‚Ä≤ ‚Ñì‚Ä≤‚Ä≤) where the functions are given by
r1
r2
r3
c1
i1
r1‚Äô
r2‚Äô
s‚Ä≤‚Ä≤(‚àí)
dl
ul
m
ul
dl
m
r
t‚Ä≤‚Ä≤(‚àí)
ul
m
dr
m
dr
r
m
‚Ñì‚Ä≤‚Ä≤(‚àí)
1‚Ñ¶
2‚Ñ¶
1‚Ñ¶
3F
1H
5‚Ñ¶
8‚Ñ¶
This is exactly what is depicted in Eq. (6.74).
Solution to Exercise 6.88.
Composing Œ∑ and x we have
Œ∑ # x  ¬ú
 ¬ú
and composing the result of œµ gives
Œ∑ # x # œµ  ¬ú
¬ú
 ¬ú
¬ú
Solution to Exercise 6.96.
1. The cospan shown left corresponds to the wiring diagram shown right:
inner circles‚Äô ports
links
outer circle‚Äôs ports

A.6. SOLUTIONS FOR CHAPTER 6
311
It has two inner circles, each with two ports. One port of the Ô¨Årst is wired to a port of the second.
One port of the Ô¨Årst is wired to the outside circle, and one port of the second is wired to the
outside circle. This is exactly what the cospan says to do.
2. The cospan shown left corresponds to the wiring diagram shown right:
inner circles‚Äô ports
links
outer circle‚Äôs ports
3. The composite 1 ‚ó¶1 f has arity (2, 2, 2, 2; 0); there is a depiction on the left:
inner circles‚Äô ports
links
outer circle‚Äôs ports
4. The associated wiring diagram is shown on the right above. One can see that one diagram has
been substituted in to a circle of the other.

312
APPENDIX A. EXERCISE SOLUTIONS
A.7
Solutions for Chapter 7.
Solution to Exercise 7.4.
In the commutative diagram below, suppose the (B, C, B‚Ä≤, C‚Ä≤) square is a pullback:
A
B
C
A‚Ä≤
B‚Ä≤
C‚Ä≤
f
h1
1
h2
h3
f ‚Ä≤
1‚Ä≤
‚åü
We need to show that the (A, B, A‚Ä≤, B‚Ä≤) square is a pullback iÔ¨Äthe (A, C, A‚Ä≤, C‚Ä≤) rectangle is a pullback.
Suppose Ô¨Årst that (A, B, A‚Ä≤, B‚Ä≤) is a pullback, and take any (X, p, q) as in the following diagram:
X
A
B
C
A‚Ä≤
B‚Ä≤
C‚Ä≤
p
q
f
h1
1
h2
h3
f ‚Ä≤
1‚Ä≤
‚åü
where q # f ‚Ä≤ # 1‚Ä≤  p # h3. Then by the universal property of the (B, C, B‚Ä≤, C‚Ä≤) pullback, we get a unique
dotted arrow r making the left-hand diagram below commute:
X
B
C
B‚Ä≤
C‚Ä≤
p
q# f ‚Ä≤
r
1
h2
h3
1‚Ä≤
‚åü
X
A
B
C
A‚Ä≤
B‚Ä≤
C‚Ä≤
r
q
r‚Ä≤
f
h1
1
h2
h3
f ‚Ä≤
1‚Ä≤
‚åü
In other words r # h2  1 # f ‚Ä≤ and r # 1  p. Then by the universal property of the (A, B, A‚Ä≤, B‚Ä≤) pullback,
we get a unique dotted arrow r‚Ä≤: X ‚ÜíA making the right-hand diagram commute, i.e. r‚Ä≤ # f  r and
r‚Ä≤ # h1  q. This gives the existence of an r with the required property, r‚Ä≤ # f  r and r‚Ä≤ # f # 1  r # 1  p.
To see uniqueness, suppose given another morphisms r0 such that r0 # f # 1  p and r0 # h1  q:
X
A
B
C
A‚Ä≤
B‚Ä≤
C‚Ä≤
r0
p
q
f
h1
1
h2
h3
f ‚Ä≤
1‚Ä≤
‚åü
Then by the uniqueness of r, we must have r0 # f  r, and then by the uniqueness of r‚Ä≤, we must have
r0  r‚Ä≤. This proves the Ô¨Årst result.
The second is similar. Suppose that (A, C, A‚Ä≤, C‚Ä≤) and (B, C, B‚Ä≤, C‚Ä≤) are pullbacks and suppose given a
commutative diagram of the following form:
X
A
B
C
A‚Ä≤
B‚Ä≤
C‚Ä≤
r
q
f
h1
1
h2
h3
f ‚Ä≤
1‚Ä≤
‚åü
i.e. where r # h2  q # f ‚Ä≤. Then letting p B r # 1, we have
p # h3  r # 1 # h3  r # h2 # 1‚Ä≤  q # f ‚Ä≤ # 1‚Ä≤

A.7. SOLUTIONS FOR CHAPTER 7
313
so by the universal property of the (A, C, A‚Ä≤, C‚Ä≤) pullback, there is a unique morphism r‚Ä≤: X ‚ÜíA such
that r‚Ä≤ # f # 1  p and r0 # h1  q, as shown:
X
A
B
C
A‚Ä≤
B‚Ä≤
C‚Ä≤
r‚Ä≤
r
p
q
f
h1
1
h2
h3
f ‚Ä≤
1‚Ä≤
‚åü
But now let r0 B r‚Ä≤ # f . It satisÔ¨Åes r0 # 1  p and r0 # h2  q # f ‚Ä≤, and r satisÔ¨Åes the same equations:
r # 1  p and r # h2  q # f ‚Ä≤. Hence by the universal property of the (B, C, B‚Ä≤, C‚Ä≤) pullback r0  r‚Ä≤. It
follows that r‚Ä≤ is a pullback of the (A, B, A‚Ä≤, B‚Ä≤) square, as desired.
Solution to Exercise 7.6.
A function f : A ‚ÜíB is injective iÔ¨Äfor all a1, a2 ‚ààA, if f (a1)  f (a2) then a1  a2. It is a monomorphism
iÔ¨Äfor all sets X and functions 11, 12 : X ‚ÜíA, if 11 # f  12 # f then 11  12. Indeed, this comes directly
from the universal property of the pullback from DeÔ¨Ånition 7.5,
X
A
A
A
B
11
12
idA
idA
f
f
‚åü
because the dashed arrow is forced to equal both 11 and 12, thus forcing 11  12.
1. Suppose f is a monomorphism, let a1, a2 ‚ààA be elements, and suppose f (a1)  f (a2). Let
X  {‚àó} be a one element set, and let 11, 12 : X ‚ÜíA be given by 11(‚àó) B a1 and 12(‚àó) B a2. Then
11 # f  12 # f , so 11  12, so a1  a2.
2. Suppose that f is an injection, let X be any set, and let 11, 12 : X ‚ÜíA be such that 11 # f  12 # f .
We will have 11  12 if we can show that 11(x)  12(x) for every x ‚ààX. So take any x ‚ààX; since
f (11(x))  f (12(x)) and f is injective, we have 11(x)  12(x) as desired.
Solution to Exercise 7.7.
1. Suppose we have a pullback as shown, where i is an isomorphism:
A‚Ä≤
B‚Ä≤
A
B
f ‚Ä≤
i‚Ä≤
i

f
‚åü
Let j B i‚àí1 be the inverse of i, and consider 1 B ( f # j): A ‚ÜíB‚Ä≤. Then 1 # i  f , so by the
existence part of the universal property, there is a map j‚Ä≤: A ‚ÜíA‚Ä≤ such that j‚Ä≤ # i‚Ä≤  idA and
j‚Ä≤ # f ‚Ä≤  f # j. We will be done if we can show i‚Ä≤ # j‚Ä≤  idA‚Ä≤. One checks that (i‚Ä≤ # j‚Ä≤) # i‚Ä≤  i‚Ä≤ and
that (i‚Ä≤ # j‚Ä≤) # f ‚Ä≤  i‚Ä≤ # f # j  f ‚Ä≤ # i # j  f ‚Ä≤. But idA‚Ä≤ also satisÔ¨Åes those properties: idA‚Ä≤ # i‚Ä≤  i‚Ä≤ and
idA‚Ä≤ # f ‚Ä≤  f ‚Ä≤, so by the uniqueness part of the universal property, (i‚Ä≤ # j‚Ä≤)  idA‚Ä≤.
2. We need to show that the following diagram is a pullback:
A
B
A
B
f
f
‚åü
So take any object X and morphisms 1 : X ‚ÜíA and h : X ‚ÜíB such that 1 # f  h # idB. We need
to show there is a unique morphism r : X ‚ÜíA such that r # idA  1 and r # f  h. That‚Äôs easy:
the Ô¨Årst requirement forces r  1 and the second requirement is then fulÔ¨Ålled.

314
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 7.8.
Consider the diagram shown left, in which all three squares are pullbacks:
A
A‚Ä≤
A
A‚Ä≤
A
B‚Ä≤
B
1
f
1
f ‚Ä≤
f
f ‚Ä≤
h
A‚Ä≤
A
A‚Ä≤
A
A‚Ä≤
A
B‚Ä≤
B
1
1
f
1
f ‚Ä≤
f
f ‚Ä≤
h
The front and bottom squares are the same‚Äîthe assumed pullback‚Äîand the right-hand square is a
pullback because f is assumed monic. We can complete it to the commutative diagram shown right,
where the back square and top square are pullbacks by Exercise 7.7. Our goal is to show that the
left-hand square is a pullback.
To do this, we use two applications of the pasting lemma, Exercise 7.4. Since the right-hand face is a
pullback and the back face is a pullback, the diagonal rectangle (lightly drawn) is also a pullback. Since
the front face is a pullback, the left-hand face is also a pullback.
Solution to Exercise 7.9.
The following is an epi-mono factorization of f :
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
Solution to Exercise 7.11.
1. If V is a quantale with the stated properties, then
‚Ä¢ I serves as a top element: v ‚â§I for all v ‚ààV.
‚Ä¢ v ‚äów serves as a meet operation, i.e. it satisÔ¨Åes the same universal property as ‚àß, namely
v ‚äów is a greatest lower bound for v and w.
Now the ‚ä∏operation satisÔ¨Åes the same universal property as exponentiation (hom-object) does,
namely v ‚â§(w ‚ä∏x) iÔ¨Äv ‚äóW ‚â§x. So V is a cartesian closed category, and of course it is a
preorder.
2. Not every cartesian closed preorder comes from a quantale with the stated properties, because
quantales have all joins and cartesian closed preorders need not. Finding a counterexample‚Äîa
cartesian closed preorder that is missing some joins‚Äîtakes some ingenuity, but it can be done.
Here‚Äôs one we came up with:
(0, 0)
(0, 1)
(0, 2)
(0, 3)
(1, 0)
(1, 1)
(1, 2)
(2, 0)
(1, 1)
(3, 0)
This is the product preorder Nop √ó Nop: its objects are pairs (a, b) ‚ààN √ó N with (a, b) ‚â§(a‚Ä≤, b‚Ä≤)
iÔ¨Ä, in the usual ordering on N we have a‚Ä≤ ‚â§a and b‚Ä≤ ‚â§b. But you can just look at the diagram.
It has a top element, (0, 0), and it has binary meets, (a, b) ‚àß(a‚Ä≤, b‚Ä≤)  (max(a, a‚Ä≤), max(b, b‚Ä≤)). But
it has no bottom element, so it has no empty join. Thus we will be done if we can show that for

A.7. SOLUTIONS FOR CHAPTER 7
315
each x, y, the hom-object x ‚ä∏y exists. The formula for it is x ‚ä∏y  √î{w | w ‚àßx ‚â§y}, i.e. we
need these particular joins to exist. Since y ‚àßx ‚â§y, we have y ‚â§x ‚ä∏y. So we can replace the
formula with x ‚ä∏y  √î{w | y ‚â§w and w ‚àßx ‚â§y}. But the set of elements in Nop √ó Nop that
are bigger than y is Ô¨Ånite and nonempty.2 So this is a Ô¨Ånite nonempty join, and Nop √ó Nop has all
Ô¨Ånite nonempty joins: they are given by inf.
Solution to Exercise 7.16.
Let m : Z ‚ÜíB be the characteristic function of the inclusion N ‚äÜZ.
1. ‚åúm‚åù(‚àí5)  false.
2. ‚åúm‚åù(0)  true.
Solution to Exercise 7.17.
1. The characteristic function ‚åúidN‚åù: N ‚ÜíB sends each n ‚ààN to true.
2. Let !N : ¬ú ‚ÜíN be the inclusion of the empty set. The characteristic function ‚åú!N‚åù: N ‚ÜíB sends
each n ‚ààN to false.
Solution to Exercise 7.19.
1. The sort of thing (*?*) we‚Äôre looking for is a subobject of B, say A ‚äÜB. This would have a
characteristic function, and we‚Äôre trying to Ô¨Ånd the A for which the characteristic function is
¬¨: B ‚ÜíB.
2. The question now asks ‚Äúwhat is A?‚Äù The answer is {false} ‚äÜB.
Solution to Exercise 7.20.
1. Here is the truth table for P  (P ‚àßQ):
P
Q
P ‚àßQ
P  (P ‚àßQ)
true
true
true
true
true
false
false
false
false
true
false
true
false
false
false
true
(A.3)
2. Yes!
3. The characteristic function for P ‚áíQ is the function ‚åú‚áí‚åù: B √ó B ‚ÜíB given by the Ô¨Årst, second,
and fourth column of Eq. (A.3).
4. It classiÔ¨Åes the subset {(true, true), (false, true), (false, false) ‚äÜB √ó B.
Solution to Exercise 7.21.
Say that ‚åúE‚åù, ‚åúP‚åù, ‚åúT‚åù: N ‚ÜíB classify respectively the subsets E B {n ‚ààN | n is even}, P B {n ‚ààN |
n is prime}, and T B {n ‚ààN | n ‚â•10} of N.
1. ‚åúE‚åù(17)  false because 17 is not even.
2. ‚åúP‚åù(17)  true because 17 is prime.
3. ‚åúT‚åù(17)  true because 17 ‚â•10.
4. The set classiÔ¨Åed by (‚åúE‚åù‚àß‚åúP‚åù) ‚à®‚åúT‚åùis that of all natural numbers that are either above 10 or
an even prime. The smallest three elements of this set are 2, 10, 11.
Solution to Exercise 7.27.
1. The 1-dimensional analogue of an œµ-ball around a point x ‚ààR is B(x, œµ) B {x‚Ä≤ ‚ààR | |x ‚àíx‚Ä≤| < œµ},
i.e. the set of all points within œµ of x.
2. A subset U ‚äÜR is open if, for every x ‚ààU there is some œµ > 0 such that B(x, œµ) ‚äÜU.
3. Let U1 B {x ‚ààR | 0 < x < 2} and U2 B {x ‚ààR | 1 < x < 3}. Then U B U1 ‚à™U2  {x ‚ààR | 0 <
x < 3}.
2If y  (a, b) then there are exactly (a + 1) ‚àó(b + 1) elements y‚Ä≤ for which y ‚â§y‚Ä≤.

316
APPENDIX A. EXERCISE SOLUTIONS
4. Let I  {1, 2, 3, 4, . . .} and for each i ‚ààI let Ui B {x ‚ààR | 1
i < x < 1}, so we have U1 ‚äÜU2 ‚äÜ
U3 ‚äÜ¬∑ ¬∑ ¬∑ . Their union is U B √ê
i‚ààI Ui  {x ‚ààR | 0 < x < 1}.
Solution to Exercise 7.29.
1. The coarse topology on X is the one whose only open sets are X ‚äÜX and ¬ú ‚äÜX. This is a
topology because it contains the top and bottom subsets, it is closed under Ô¨Ånite intersection (the
intersection A ‚à©B is ¬ú iÔ¨Äone or the other is ¬ú), and it is closed under arbitrary union (the union
√ê
i‚ààI Ai is X iÔ¨ÄAi  X for some i ‚ààI).
2. The Ô¨Åne topology on X is the one where every subset A ‚äÜX is considered open.
All the
conditions on a topology say ‚Äúif such-and-such then such-and-such is open,‚Äù but these are all
satisÔ¨Åed because everything is open!
3. If (X, P(X)) is discrete, (Y, OpY) is any topological space, and f : X ‚ÜíY is any function then it
is continuous. Indeed, this just means that for any open set U ‚äÜY the preimage f ‚àí1(U) ‚äÜX is
open, and everything in X is open.
Solution to Exercise 7.31.
1. The Hasse diagram for the Sierpinsky topology is ¬ú ‚Üí{1} ‚Üí{1, 2} .
2. A set (Ui)i‚ààI covers U iÔ¨Äeither
‚Ä¢ I  ¬ú and U  ¬ú; or
‚Ä¢ Ui  U for some i ‚ààI.
In other words, the only way that some collection of these sets could cover another set U is if that
collection contains U or if U is empty and the collection is also empty.
Solution to Exercise 7.32.
Let (X, Op) be a topological space, suppose that Y ‚äÜX is a subset, and consider the subspace topology
Op?‚à©Y.
1. We want to show that Y ‚ààOp?‚à©Y. We need to Ô¨Ånd B ‚ààOp such that Y  B ‚à©Y; this is easy, you
could take B  Y or B  X, or anything in between.
2. We still need to show that Op?‚à©Y contains ¬ú and is closed under Ô¨Ånite intersection and arbitrary
union. ¬ú  ¬ú ‚à©Y, so according to the formula, ¬ú ‚ààOp?‚à©Y. Suppose that A1, A2 ‚ààOp?‚à©Y. Then
there exist B1, B2 ‚ààOp with A1  B1‚à©Y and A2  B2‚à©Y. But then A1‚à©A2  (B1‚à©Y)‚à©(B2‚à©Y) 
(B1 ‚à©B2) ‚à©Y, so it is in Op?‚à©Y since B1 ‚à©B2 ‚ààOp. The same idea works for arbitrary unions:
given a set I and Ai for each i ‚ààI, we have Ai  Bi ‚à©Y for some Bi ‚ààOp, and
√ò
i‚ààI
Ai 
√ò
i‚ààI
(Bi ‚à©Y) 
 √ò
i‚àài
Bi
!
‚à©Y ‚ààOp?‚à©Y.
Solution to Exercise 7.34.
Let‚Äôs imagine a V-category C, where V is the quantale corresponding to the open sets of a topological
space (X, Op). Its Hasse diagram would be a set of dots and some arrows between them, each labeled
by an open set U ‚äÜOp. It might look something like this:
A‚Ä¢
B‚Ä¢
‚Ä¢
C
‚Ä¢
D
U5
U1
U2
U3
U4
C B

A.7. SOLUTIONS FOR CHAPTER 7
317
Recall from Section 2.3 that the ‚Äòdistance‚Äô between two points is computed by taking the join, over all
paths between them, of the monoidal product of distances along that path. For example, C(B, C) 
(U3 ‚àßU1) ‚à®(U4 ‚àßU2), because ‚àßis the monoidal product in V.
In general, we can thus imagine the open set C(a, b) as a kind of ‚Äòsize restriction‚Äô for getting from a to b,
like bridges that your truck needs to pass under. The size restriction for getting from a to itself is X: no
restriction. In general, to go on any given route (path) from a to b, you have to Ô¨Åt under every bridge
in the path, so we take their meet. But we can go along any path, so we take the join over all paths.
Solution to Exercise 7.38.
‚Ä¢a
‚Ä¢b
‚Ä¢c
‚Ä¢d
‚Ä¢e
Y B
‚Ä¢
a1
‚Ä¢
a2
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
‚Ä¢
c1
‚Ä¢
e1
‚Ä¢
e2
X B
f
(A.4)
1. The Ô¨Åber of f over a is {a1, a2}.
2. The Ô¨Åber of f over c is {c1}.
3. The Ô¨Åber of f over d is ¬ú.
4. A function f ‚Ä≤: X ‚ÜíY for which every Ô¨Åber has either one or two elements is shown below.
‚Ä¢a
‚Ä¢b
‚Ä¢c
‚Ä¢d
‚Ä¢e
Y B
‚Ä¢
e1
‚Ä¢
a2
‚Ä¢
b1
‚Ä¢
c1
‚Ä¢
b2
‚Ä¢
b3
‚Ä¢
a1
‚Ä¢
e2
X B
f
Solution to Exercise 7.40.
Refer to Eq. (A.4).
1. Here is a drawing of all six sections over V1  {a, b, c}:
‚Ä¢a
‚Ä¢
b
‚Ä¢c
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
11
‚Ä¢a
‚Ä¢
b
‚Ä¢c
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
12
‚Ä¢a
‚Ä¢
b
‚Ä¢c
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
13
‚Ä¢a
‚Ä¢
b
‚Ä¢c
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
14
‚Ä¢a
‚Ä¢
b
‚Ä¢c
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
15
‚Ä¢a
‚Ä¢
b
‚Ä¢c
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
16
2. When V2  {a, b, c, d}, there are no sections: Sec f (V2)  ¬ú.
3. When V3  {a, b, d, e}, the set Sec f (V3)) has 2 ‚àó3 ‚àó1 ‚àó2  12 elements.

318
APPENDIX A. EXERCISE SOLUTIONS
Solution to Exercise 7.42.
Sec f ({a, b, c}) and Sec f ({a, c}) are drawn as the top row (six-element set) and bottom row (two-element
set) below, and the restriction map is also shown:
(a1, b1, c1)
(a1, b2, c1)
(a1, b3, c1)
(a2, b1, c1)
(a2, b2, c1)
(a2, b3, c1)
(a1, c1)
(a2, c1)
Solution to Exercise 7.44.
1. Let 11 B (a1, b1) and 12 B (b2, e1); these do not agree on the overlap.
2. No, there‚Äôs no section 1 ‚ààSec f (U1 ‚à™U2) for which 1

U1  11 and 1

U2  12.
‚Ä¢a
‚Ä¢b
‚Ä¢
a1
‚Ä¢
a2
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
h1
‚Ä¢b
‚Ä¢e
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
‚Ä¢
e1
‚Ä¢
e2
h2
3.
‚Ä¢a
‚Ä¢b
‚Ä¢e
‚Ä¢
a1
‚Ä¢
a2
‚Ä¢
b1
‚Ä¢
b2
‚Ä¢
b3
‚Ä¢
e1
‚Ä¢
e2
glued section
4.
Solution to Exercise 7.47.
No, there is not a one-to-one correspondence between sheaves on M and vector Ô¨Åelds on M. The
relationship between sheaves on M and vector Ô¨Åelds on M is that the set of all vector Ô¨Åelds on M
corresponds to one sheaf, namely SecœÄ, where œÄ: TM ‚ÜíM is the tangent bundle as described in
Example 7.46. There are so many sheaves on M that they don‚Äôt even form a set (it‚Äôs just a ‚Äòcollection‚Äô);
again, one member of this gigantic collection is the sheaf SecœÄ of all possible vector Ô¨Åelds on M.
Solution to Exercise 7.49.
1. The Hasse diagram for the Sierpinsky topology is ¬ú ‚Üí{1} ‚Üí{1, 2} .
2. A presheaf F on Op consists of any three sets and any two functions F({1, 2}) ‚ÜíF({1}) ‚ÜíF(¬ú)
between them.
3. Recall from Exercise 7.31 that the only non-trivial covering (a covering of U is non-trivial if it does
not contain U) occurs when U  ¬ú in which case the empty family over U is a cover.
4. As explained in Example 7.36, F will be a sheaf iÔ¨ÄF(¬ú)  {1}. Thus we the category of sheaves
is equivalent to that of just two sets and one function F({1, 2}) ‚ÜíF({1}).
Solution to Exercise 7.52.
The one-point space X  {1} has two open sets, ¬ú and {1}, and every sheaf S ‚ààShv(X) assigns
S(¬ú)  {()} by the sheaf condition (see Example 7.36). So the only data in a sheaf S ‚ààShv(X) is the set
S({1}). This is how we get the correspondence between sets and sheaves on the one point space.
According to Eq. (7.50), the subobject classiÔ¨Åer ‚Ñ¶: Op(X)op ‚ÜíSet in Shv(X) should be the functor
where ‚Ñ¶({1}) is the set of open sets of {1}. So we‚Äôre hoping to see that there is a one-to-one correspon-
dence between the set Op({1}) and the set B  {true, false} of booleans. Indeed there is: there are
two open sets of {1}, as we said, ¬ú and {1}, and these correspond to false and true respectively.
Solution to Exercise 7.53.
By Eqs. (7.50) and (7.51) the deÔ¨Ånition of ‚Ñ¶(U) is ‚Ñ¶(U) B {U‚Ä≤ ‚ààOp | U‚Ä≤ ‚äÜU}, and the deÔ¨Ånition of
the restriction map for V ‚äÜU is U‚Ä≤ 7‚ÜíU‚Ä≤ ‚à©V.

A.7. SOLUTIONS FOR CHAPTER 7
319
1. It is functorial: given W ‚äÜV ‚äÜU and U‚Ä≤ ‚äÜU, we indeed have (U‚Ä≤ ‚à©V) ‚à©W  U‚Ä≤ ‚à©W, since
W ‚äÜV. For functoriality, we also need preservation of identities, and this amounts to U‚Ä≤‚à©U  U‚Ä≤
for all U‚Ä≤ ‚äÜU.
2. Yes, a presheaf is just a functor; the above check is enough.
Solution to Exercise 7.55.
We need a graph homomorphism of the following form:
A‚Ä¢
B‚Ä¢
C‚Ä¢
D‚Ä¢
f
1
h
i
‚åúG‚Ä≤‚åù
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí
0
V
(0,0; 0)
(0,V; 0)
(V,V; 0)
(V,V; A)
(V,0; 0)
There is only one that classiÔ¨Åes G‚Ä≤, and here it is. Let‚Äôs write Œ≥ B ‚åúG‚Ä≤‚åù.
‚Ä¢ Since D is missing from G‚Ä≤, we have Œ≥(D)  0 (vertex: missing).
‚Ä¢ Since vertices A, B, C are present in G‚Ä≤ we have Œ≥(A)  Œ≥(B)  Œ≥(C)  V (vertex: present).
‚Ä¢ The above forces Œ≥(i)  (V, 0; 0) (arrow from present vertex to missing vertex: missing).
‚Ä¢ Since the arrow f is in G‚Ä≤, we have Œ≥( f )  (V, V; A) (arrow from present vertex to present vertex:
present).
‚Ä¢ Since the arrows 1 and h are missing in G‚Ä≤, we have Œ≥(1)  Œ≥(h)  (V, V; 0) (arrow from present
vertex to present vertex: missing).
Solution to Exercise 7.59.
With U  R ‚àí{0} ‚äÜR, we have:
1. The complement of U is R ‚àíU  {0} and ¬¨U is its interior, which is ¬¨U  ¬ú.
2. The complement of ¬¨U is R ‚àí¬ú  R, and this is open, so ¬¨¬¨U  R.
3. It is true that U ‚äÜ¬¨¬¨U.
4. It is false that ¬¨¬¨U ‚äÜ? U.
Solution to Exercise 7.60.
1. If for any V ‚ààOp we have ‚ä§‚àßV  V then when V  X we have ‚ä§‚àßX B ‚ä§‚à©X  X, but
anything intersected with X is itself, so ‚ä§ ‚ä§‚à©X  X.
2. (‚ä§‚à®V) B (X ‚à™V)  X holds and (V ‚áíX)  √ê
{R‚ààOp|R‚à©V‚äÜX} R  X holds because (X ‚à©V) ‚äÜX.
3. If for any set V ‚ààOp we have (‚ä•‚à®V)  V, then when V  ‚àÖwe have (‚ä•‚à®¬ú)  (‚ä•‚à™¬ú)  ¬ú, but
anything unioned with ¬ú is itself, so ‚ä• ‚ä•‚à™¬ú  ¬ú.
4. (‚ä•‚àßV)  (¬ú ‚à©V)  ¬ú holds, and (‚ä•‚áíV)  √ê
{R‚ààOp|R‚à©¬ú‚äÜV} R  X holds because (X ‚à©¬ú) ‚äÜV.
Solution to Exercise 7.62.
S is the sheaf of people, the set of which changes over time: a section in S over any interval of time is
a person who is alive throughout that interval. A section in the subobject {S | p} over any interval of
time is a person who is alive and likes the weather throughout that interval of time.
Solution to Exercise 7.64.
We need an example of a space X, a sheaf S ‚ààShv(X), and two predicates p, q : S ‚Üí‚Ñ¶for which
p(s) ‚ä¢s:S q(s) holds. Take X to be the one-point space, take S to be the sheaf corresponding to the set
S  N, let p(s) be the predicate ‚Äú24 ‚â§s ‚â§28,‚Äù and let q(s) be the predicate ‚Äús is not prime.‚Äù Then
p(s) ‚ä¢s:S q(s) holds.
As an informal example, take X to be the surface of the earth, take S to be the sheaf of vector Ô¨Åelds
as in Example 7.46 thought of in terms of wind-blowing. Let p be the predicate ‚Äúthe wind is blowing
due east at somewhere between 2 and 5 kilometers per hour‚Äù and let q be the predicate ‚Äúthe wind is
blowing at somewhere between 1 and 5 kilometers per hour.‚Äù Then p(s) ‚ä¢s:S q(s) holds. This means

320
APPENDIX A. EXERCISE SOLUTIONS
that for any open set U, if the wind is blowing due east at somewhere between 2 and 5 kilometers
per hour throughout U, then the wind is blowing at somewhere between 1 and 5 kilometers per hour
throughout U as well.
Solution to Exercise 7.66.
We have the predicate p : N √ó Z ‚ÜíB given by p(n, z) iÔ¨Än ‚â§|z|.
1. The predicate ‚àÄ(z : Z). p(n, z) holds for {0} ‚äÜN.
2. The predicate ‚àÉ(z : Z). p(n, z) holds for N ‚äÜN.
3. The predicate ‚àÄ(n : N). p(n, z) holds for ¬ú ‚äÜZ.
4. The predicate ‚àÉ(n : N). p(n, z) holds for Z ‚äÜZ.
Solution to Exercise 7.67.
Suppose s is a person alive throughout the interval U. Apply the above deÔ¨Ånition to the example
p(s, t)  ‚Äúperson s is worried about news t‚Äù from above.
1. The formula says that ‚àÄ(t : T). p(s, t) ‚Äúreturns the largest open set V ‚äÜU for which p(s

V , t)  V
for all t ‚ààT(V).‚Äù Note that T(V) is the set of items that are in the news throughout the interval
V. Substituting, this becomes ‚Äúthe largest interval of time V ‚äÜU over which person s is worried
about news t for every item t that is in the news throughout V.‚Äù In other words, for V to be
nonempty, the person s would have to be worried about every single item of news throughout V.
My guess is that there‚Äôs a festival happening or a happy kitten somewhere that person s is not
worried about, but maybe I‚Äôm assuming that person s is suÔ¨Éciently mentally ‚Äúnormal.‚Äù There
may be people who are sometimes worried about literally everything in the news; we ask you to
please be kind to them.
2. Yes, it is exactly the same description.
Solution to Exercise 7.68.
Suppose s is a person alive throughout the interval U. Apply the above deÔ¨Ånition to the example
p(s, t)  ‚Äúperson s is worried about news t‚Äù from above.
1. The formula says that ‚àÉ(t : T). p(s, t) ‚Äúreturns the union V  √ê
i Vi of all the open sets Vi for
which there exists some ti ‚ààT(Vi) satisfying p(s

Vi , ti)  Vi.‚Äù Substituting, this becomes ‚Äúthe
union of all time intervals Vi for which there is some item ti in the news about which s is worried
throughout Vi.‚Äù In other words it is all the time that s is worried about at least one thing in
the news. Perhaps when s is sleeping or concentrating on something, she is not worried about
anything, in which case intervals of sleeping or concentrating would not be subsets of V. But if
s said ‚Äúthere‚Äôs been such a string of bad news this past year, it‚Äôs like I‚Äôm always worried about
something!,‚Äù she is saying that it‚Äôs like V ‚Äúthis past year.‚Äù
2. This seems like a good thing for ‚Äúthere exists a piece of news that worries s‚Äù to mean: the news
itself is allowed to change as long as the person‚Äôs worry remains. Someone might disagree and
think that the predicate should mean ‚Äúthere is one piece of news that worries s throughout the
whole interval V.‚Äù In that case, perhaps this person is working within a diÔ¨Äerent topos, e.g. one
where the site has fewer coverings. Indeed, it is the notion of covering that makes existential
quantiÔ¨Åcation work the way it does.
Solution to Exercise 7.70.
It is clear that if j(j(q))  j(q) then j(j(q)) ‚â§j(q) by reÔ¨Çexivity.
On the other hand, assume the
hypothesis, that p ‚â§j(p) for all U ‚äÜX and p ‚àà‚Ñ¶(U). If j(j(q)) ‚â§j(q), then letting p B j(q) we have
both j(p) ‚â§p and p ‚â§j(p). This means p  j(p), but ‚Ñ¶is a poset (not just a preorder) so p  j(p), i.e.
j(j(q))  j(q) as desired.
Solution to Exercise 7.72.
Let S be the sheaf of people and j be ‚Äúassuming Bob is in San Diego...‚Äù
1. Take p(s) to be ‚Äús likes the weather.‚Äù

A.7. SOLUTIONS FOR CHAPTER 7
321
2. Let U be the interval 2019/01/01 ‚Äì 2019/02/01. For an arbitrary person s ‚ààS(U), p(s) is a subset
of U, and it means the subset of U throughout which s likes the weather.
3. Similarly j(p(s)) is a subset of U, and it means the subset of U throughout which, assuming Bob
is in San Diego, s liked the weather. In other words, j(p(s)) is true whenever Bob is not in San
Diego, and it is true whenever s likes the weather.
4. It is true that p(s) ‚â§j(p(s)), by the ‚Äòin other words‚Äô above.
5. It is true that j(j(p(s))  j(p(s), because suppose given a time during which ‚Äúif Bob is in San
Diego then if Bob is in San Diego then s likes the weather.‚Äù Then if Bob is in San Diego during
this time then s likes the weather. But that is exactly what j(p(s)) means.
6. Take q(s) to be ‚Äús is happy.‚Äù Suppose ‚Äúif Bob is in San Diego then both s likes the weather and s
is happy.‚Äù Then both ‚Äúif Bob is in San Diego then s likes the weather‚Äù and ‚Äúif Bob is in San Diego
then s is happy‚Äù are true too. The converse is equally clear.
Solution to Exercise 7.76.
We have o[a,b] B {[d, u] ‚ààIR | a < d ‚â§u < b}.
1. Since 0 ‚â§2 ‚â§6 ‚â§8, we have [2, 6] ‚àào[0,8] by the above formula.
2. In order to have [2, 6] ‚àà? o[0,5]‚à™o[4,8], we would need to have either [2, 6] ‚àà? o[0,5] or [2, 6] ‚àà? o[4,8].
But the formula does not hold in either case.
Solution to Exercise 7.77.
A subset U ‚äÜR is open in the subspace topology of R ‚äÜIR iÔ¨Äthere is an open set U‚Ä≤ ‚äÜIR with
U  U‚Ä≤ ‚à©R. We want to show that this is the case iÔ¨ÄU is open in the usual topology.
Suppose that U is open in the subspace topology. Then U  U‚Ä≤‚à©R, where U‚Ä≤ ‚äÜIR is the union of some
basic opens, U‚Ä≤  √ê
i‚ààI o[ai,bi], where o[ai,bi]  {[d, u] ‚ààIR | ai < d < u < bi}. Since R  {[x, x] ‚ààIR},
the intersection U‚Ä≤ ‚à©R will then be
U 
√ò
i‚ààI
{x ‚ààR | ai < x < bi}
and this is just the union of open balls B(mi, ri) where mi B ai+bi
2
is the midpoint and ri B bi‚àíai
2
is
the radius of the interval (ai, bi). The open balls B(mi, ri) are open in the usual topology on R and the
union of opens is open, so U is open in the usual topology.
Suppose that U is open in the usual topology. Then U  √ê
j‚ààJ B(mj, œµj) for some set J. Let aj B mj ‚àíœµj
and bj B mj + œµj. Then
U 
√ò
j‚ààJ
{x ‚ààR | aj < x < bj} 
√ò
j‚ààJ
(o[aj,bj] ‚à©R)  ¬©¬≠
¬´
√ò
j‚ààJ
o[aj,bj]¬™¬Æ
¬¨
‚à©R
which is open in the subspace topology.
Solution to Exercise 7.80.
Fix any topological space (X, OpX) and any subset R ‚äÜIR of the interval domain. DeÔ¨Åne HX(U) B
{ f : U ‚à©R ‚ÜíX | f is continuous}.
1. HX is a presheaf: given V ‚äÜU the restriction map sends the continuous function f : U ‚à©R ‚ÜíX
to its restriction along the subset V ‚à©R ‚äÜU ‚à©R.
2. It is a sheaf: given any family Ui of open sets with U  √ê
i Ui and a continuous function
fi : Ui ‚à©R ‚ÜíX for each i, agreeing on overlaps, they can be glued together to give a continuous
function on all of U ‚à©R, since U ‚à©R  (√ê
i Ui) ‚à©R  √ê
i(Ui ‚à©R).


Bibliography
[Ada17]
Elie M. Adam. ‚ÄúSystems, Generativity and Interactional EÔ¨Äects‚Äù. Available
online: http://www.mit.edu/~eadam/eadam_PhDThesis.pdf. PhD thesis.
Massachusetts Institute of Technology, July 2017 (cit. on pp. 2, 26, 36).
[AGV71]
Michael Artin, Alexander Grothendieck, and Jean-Louis Verdier. Theorie de
Topos et Cohomologie Etale des Schemas I, II, III. Vol. 269, 270, 305. Lecture
Notes in Mathematics. Springer, 1971 (cit. on p. 256).
[AJ94]
Samson Abramsky and Achim Jung. ‚ÄúDomain theory‚Äù. In: Handbook of logic
in computer science. Oxford University Press. 1994 (cit. on p. 257).
[AS05]
Aaron D. Ames and Shankar Sastry. ‚ÄúCharacterization of Zeno behavior in
hybrid systems using homological methods‚Äù. In: American Control Confer-
ence, 2005. Proceedings of the 2005. IEEE. 2005, pp. 1160‚Äì1165 (cit. on p. 257).
[AV93]
Samson Abramsky and Steven Vickers. ‚ÄúQuantales, observational logic
and process semantics‚Äù. In: Mathematical Structures in Computer Science 3.2
(1993), pp. 161‚Äì227 (cit. on p. 76).
[Awo10]
Steve Awodey. Category theory. Second. Vol. 52. Oxford Logic Guides. Ox-
ford University Press, Oxford, 2010, pp. xvi+311 (cit. on p. 114).
[BD98]
John C Baez and James Dolan. CategoriÔ¨Åcation. 1998. eprint: math/9802029
(cit. on p. 145).
[BE15]
John C. Baez and Jason Erbele. ‚ÄúCategories in control‚Äù. In: Theory and
Applications of Categories 30 (2015), Paper No. 24, 836‚Äì881 (cit. on pp. 170,
179).
[BF15]
John C. Baez and Brendan Fong. ‚ÄúA compositional framework for passive
linear networks‚Äù. In: (2015). url: https://arxiv.org/abs/1504.05625
(cit. on p. 219).
[BFP16]
John C. Baez, Brendan Fong, and Blake S Pollard. ‚ÄúA compositional frame-
work for Markov processes‚Äù. In: Journal of Mathematical Physics 57.3 (2016)
(cit. on p. 219).
323

324
BIBLIOGRAPHY
[BH08]
Philip A Bernstein and Laura M Haas. ‚ÄúInformation integration in the
enterprise‚Äù. In: Communications of the ACM 51.9 (2008), pp. 72‚Äì79 (cit. on
p. 77).
[Bor94]
Francis Borceux. Handbook of categorical algebra 1. Vol. 50. Encyclopedia of
Mathematics and its Applications. Basic category theory. Cambridge Uni-
versity Press, Cambridge, 1994 (cit. on pp. 114, 192).
[BP17]
John C Baez and Blake S Pollard. ‚ÄúA compositional framework for reaction
networks‚Äù. In: Reviews in Mathematical Physics 29.09 (2017) (cit. on p. 219).
[Bro61]
Ronnie Brown. ‚ÄúSome problems of algebraic topology: a study of function
spaces, function complexes, and FD-complexes‚Äù. PhD thesis. University of
Oxford, 1961 (cit. on p. 76).
[BS17]
Filippo Bonchi and Fabio Soboci≈Ñski Pawe≈Çand Zanasi. ‚ÄúThe calculus of
signal Ô¨Çow diagrams I: Linear relations on streams‚Äù. In: Information and
Computation 252 (2017), pp. 2‚Äì29 (cit. on pp. 170, 179).
[BSZ14]
Filippo Bonchi, Pawe≈Ç Soboci≈Ñski, and Fabio Zanasi. ‚ÄúA categorical seman-
tics of signal Ô¨Çow graphs‚Äù. In: International Conference on Concurrency Theory.
2014, pp. 435‚Äì450 (cit. on p. 179).
[BSZ15]
Filippo Bonchi, Pawel Sobocinski, and Fabio Zanasi. ‚ÄúFull abstraction for
signal Ô¨Çow graphs‚Äù. In: ACM SIGPLAN Notices. Vol. 50. 1. ACM. 2015,
pp. 515‚Äì526 (cit. on p. 179).
[BW90]
Michael Barr and Charles Wells. Category theory for computing science. Vol. 49.
Prentice Hall New York, 1990 (cit. on p. 114).
[Car91]
Aurelio Carboni. ‚ÄúMatrices, relations, and group representations‚Äù. In: Jour-
nal of Algebra 136.2 (1991), pp. 497‚Äì529. url: http://www.sciencedirect.
com/science/article/pii/002186939190057F (cit. on p. 219).
[CD95]
Boris Cadish and Zinovy Diskin. ‚ÄúAlgebraic graph-based approach to man-
agement of multibase systems, I: Schema integration via sketches and equa-
tions‚Äù. In: proceedings of Next Generation of Information Technologies and Sys-
tems, NGITS. Vol. 95. 1995 (cit. on p. 114).
[Cen15]
Andrea Censi. A mathematical theory of co-design. 2015. eprint: arXiv:1512.
08055 (cit. on pp. 117, 145).
[Cen17]
Andrea Censi. ‚ÄúUncertainty in Monotone Co-Design Problems‚Äù. In: IEEE
Robotics and Automation Letters (Feb. 2017). url: https://arxiv.org/abs/
1609.03103 (cit. on p. 145).
[CFS16]
Bob Coecke, Tobias Fritz, and Robert W. Spekkens. ‚ÄúA mathematical theory
of resources‚Äù. In: Information and Computation 250 (2016), pp. 59‚Äì86 (cit. on
pp. 48, 75).

BIBLIOGRAPHY
325
[CK17]
Bob Coecke and Aleks Kissinger. Picturing quantum processes. Cambridge
University Press, 2017 (cit. on p. iv).
[CP10]
Bob Coecke and Eric Oliver Paquette. ‚ÄúCategories for the practising physi-
cist‚Äù. In: New Structures for Physics. Springer, 2010, pp. 173‚Äì286 (cit. on p. iv).
[CW87]
A. Carboni and R.F.C. Walters. ‚ÄúCartesian bicategories I‚Äù. In: Journal of Pure
and Applied Algebra49.1(1987),pp. 11‚Äì32. url: http://www.sciencedirect.
com/science/article/pii/0022404987901216 (cit. on p. 219).
[CY96]
Louis Crane and David N Yetter. Examples of categoriÔ¨Åcation. 1996. eprint:
q-alg/9607028 (cit. on p. 145).
[FGR03]
Michael Fleming, Ryan Gunther, and Robert Rosebrugh. ‚ÄúA database of
categories‚Äù. In: Journal of Symbolic Computation 35 (2003), Paper No. 2, 127‚Äì
135 (cit. on p. 114).
[Fon15]
Brendan Fong. ‚ÄúDecorated cospans‚Äù. In: Theory and Applications of Categories
30.33 (2015), pp. 1096‚Äì1120 (cit. on p. 219).
[Fon16]
Brendan Fong. ‚ÄúThe Algebra of Open and Interconnected Systems‚Äù. PhD
thesis. University of Oxford, 2016 (cit. on p. 219).
[Fon18]
Brendan Fong. ‚ÄúDecorated corelations‚Äù. In: Theory and Applications of Cate-
gories 33.22 (2018), pp. 608‚Äì643 (cit. on p. 219).
[Fra67]
John B. Fraleigh. A Ô¨Årst course in abstract algebra. Addison-Wesley Publishing
Co., Reading, Mass.-London-Don Mills, Ont., 1967, pp. xvi+447 (cit. on
p. 179).
[Fri17]
Tobias Fritz. ‚ÄúResource convertibility and ordered commutative monoids‚Äù.
In: Mathematical Structures in Computer Science 27.6 (2017), pp. 850‚Äì938 (cit.
on pp. 48, 75).
[FS18a]
Brendan Fong and Maru Sarazola. A recipe for black box functors. 2018 (cit. on
p. 219).
[FS18b]
Brendan Fong and David I Spivak. Hypergraph Categories. 2018. eprint:
arXiv:1806.08304 (cit. on p. 219).
[FSR16]
Brendan Fong, Pawe≈Ç Soboci≈Ñski, and Paolo Rapisarda. ‚ÄúA categorical ap-
proach to open and interconnected dynamical systems‚Äù. In: Proceedings of
the 31st Annual ACM/IEEE Symposium on Logic in Computer Science. ACM.
2016, pp. 495‚Äì504 (cit. on pp. 168, 179).
[Gie+03]
G. Gierz, K. H. Hofmann, K. Keimel, J. D. Lawson, M. Mislove, and D. S.
Scott. Continuous lattices and domains. Vol. 93. Encyclopedia of Mathemat-
ics and its Applications. Cambridge University Press, Cambridge, 2003,
pp. xxxvi+591 (cit. on p. 257).

326
BIBLIOGRAPHY
[Gla13]
K Glazek. A Guide to the Literature on Semirings and their Applications in
Mathematics and Information Sciences: With Complete Bibliography. Springer
Science & Business Media, 2013 (cit. on p. 179).
[Gra18]
Marco Grandis. Category Theory and Applications. World ScientiÔ¨Åc, 2018 (cit.
on p. 114).
[HMP98]
Claudio Hermida, Michael Makkai, and John Power. ‚ÄúHigher-dimensional
multigraphs‚Äù. In: Thirteenth Annual IEEE Symposium on Logic in Computer
Science (Indianapolis, IN, 1998). IEEE Computer Soc., Los Alamitos, CA,
1998, pp. 199‚Äì206 (cit. on p. 214).
[HTP03]
Esfandiar Haghverdi, Paulo Tabuada, and George Pappas. ‚ÄúBisimulation
relations for dynamical and control systems‚Äù. In: Electronic Notes in Theo-
retical Computer Science 69 (2003), pp. 120‚Äì136 (cit. on p. 257).
[IP94]
Amitavo Islam and WesleyPhoa. ‚ÄúCategoricalmodelsofrelationaldatabases
I: Fibrational formulation, schema integration‚Äù. In: International Symposium
on Theoretical Aspects of Computer Software. Springer. 1994, pp. 618‚Äì641 (cit.
on p. 114).
[Jac99]
Bart Jacobs. Categorical logic and type theory. Vol. 141. Studies in Logic and the
Foundations of Mathematics. North-Holland Publishing Co., Amsterdam,
1999, pp. xviii+760 (cit. on p. 257).
[JNW96]
Andr√© Joyal, Mogens Nielsen, and Glynn Winskel. ‚ÄúBisimulation from open
maps‚Äù. In: Information and Computation 127.2 (1996), pp. 164‚Äì185 (cit. on
p. 257).
[Joh02]
Peter T. Johnstone. Sketches of an elephant: a topos theory compendium. Vol. 43.
Oxford Logic Guides. New York: The Clarendon Press Oxford University
Press, 2002, pp. xxii+468+71 (cit. on p. 257).
[Joh77]
P. T. Johnstone. Topos theory. London Mathematical Society Monographs,
Vol. 10. Academic Press [Harcourt Brace Jovanovich, Publishers], London-
New York, 1977, pp. xxiii+367 (cit. on p. 223).
[JR02]
Michael Johnson and Robert Rosebrugh. ‚ÄúSketch Data Models, Relational
Schema and Data SpeciÔ¨Åcations‚Äù. In: Electronic Notes in Theoretical Computer
Science 61 (2002). CATS‚Äô02, Computing, pp. 51‚Äì63 (cit. on p. 114).
[JS93]
Andr√© Joyal and Ross Street. ‚ÄúBraided tensor categories‚Äù. In: Advances in
Mathematics 102.1 (1993), pp. 20‚Äì78 (cit. on pp. 40, 145).
[JSV96]
Andr√© Joyal, Ross Street,and DominicVerity. ‚ÄúTraced monoidalcategories‚Äù.
In: Mathematical Proceedings of the Cambridge Philosophical Society 119 (1996),
Paper No. 3, 447‚Äì468 (cit. on p. 145).

BIBLIOGRAPHY
327
[Kel05]
G. M. Kelly. ‚ÄúBasic concepts of enriched category theory‚Äù. In: Reprints
in Theory and Applications of Categories (2005), Paper No. 10. url: http:
//www.tac.mta.ca/tac/reprints/articles/10/tr10abs.html (cit. on
pp. 76, 139).
[Law04]
F William Lawvere. ‚ÄúFunctorial Semantics of Algebraic Theories and Some
Algebraic Problems in the context of Functorial Semantics of Algebraic
Theories‚Äù. In: Reprints in Theory and Applications of Categories 5 (2004), pp. 1‚Äì
121 (cit. on p. 179).
[Law73]
F William Lawvere. ‚ÄúMetric spaces, generalized logic, and closed cate-
gories‚Äù. In: Rendiconti del seminario mat√©matico e Ô¨Åsico di Milano 43.1 (1973),
pp. 135‚Äì166 (cit. on pp. 76, 145).
[Law86]
Bill Lawvere. ‚ÄúState categories and response functors‚Äù. 1986 (cit. on p. 257).
[Lei04]
Tom Leinster. Higher operads, higher categories. London Mathematical Society
Lecture Note Series 298. Cambridge University Press, Cambridge, 2004 (cit.
on pp. 213, 218, 219).
[Lei14]
Tom Leinster. Basic category theory. Vol. 143. Cambridge University Press,
2014 (cit. on p. 114).
[LS88]
J. Lambek and P. J. Scott. Introduction to higher order categorical logic. Vol. 7.
Cambridge Studies in Advanced Mathematics. Reprint of the 1986 original.
Cambridge University Press, Cambridge, 1988, pp. x+293 (cit. on p. 257).
[Mac98]
Saunders Mac Lane. Categories for the working mathematician. 2nd ed. Gradu-
ate Texts in Mathematics 5. New York: Springer-Verlag, 1998 (cit. on pp. 114,
115, 145).
[May72]
J Peter May. The geometry of iterated loop spaces, volume 271 of Lecture Notes in
Mathematics. 1972 (cit. on p. 219).
[McL90]
Colin McLarty. ‚ÄúThe uses and abuses of the history of topos theory‚Äù. In:
The British Journal for the Philosophy of Science 41.3 (1990), pp. 351‚Äì375 (cit. on
p. 256).
[McL92]
Colin McLarty. Elementary categories, elementary toposes. Clarendon Press,
1992 (cit. on p. 256).
[MM92]
Saunders MacLane and Ieke Moerdƒ≥k. Sheaves in Geometry and Logic: A First
Introduction to Topos Theory. Springer, 1992 (cit. on p. 257).
[nLa18]
Contributors To nLab. Symmetric monoidal category. 2018. url: https://
ncatlab.org/nlab/revision/symmetric+monoidal+category/30 (cit. on
p. 139).
[NNH99]
Flemming Nielson, Hanne R. Nielson, and Chris Hankin. Principles of Pro-
gram Analysis. Secaucus, NJ, USA: Springer-Verlag New York, Inc., 1999 (cit.
on p. 37).

328
BIBLIOGRAPHY
[Pie91]
Benjamin C. Pierce. Basic Category Theory for Computer Scientists. MIT Press,
1991 (cit. on p. 114).
[PS95]
Frank Piessens and Eric Steegmans. ‚ÄúCategorical data speciÔ¨Åcations‚Äù. In:
Theory and Applications of Categories 1.8 (1995), pp. 156‚Äì173 (cit. on p. 114).
[Rie17]
Emily Riehl. Category theory in context. Courier Dover Publications, 2017
(cit. on p. 114).
[Ros90]
Kimmo I Rosenthal. Quantales and their applications. Vol. 234. Longman
ScientiÔ¨Åc and Technical, 1990 (cit. on p. 76).
[RS13]
Dylan Rupel and David I. Spivak. The operad of temporal wiring diagrams:
formalizing a graphical language for discrete-time processes. 2013. eprint: arXiv:
1307.6894 (cit. on p. 219).
[RW92]
Robert Rosebrugh and R. J. Wood. ‚ÄúRelational Databases and Indexed Cat-
egories‚Äù. In: Canadian Mathematical Society Conference Procedings. Interna-
tional Summer Category Theory Meeting. (June 23‚Äì30, 1991). Ed. by R. A. G.
Seely. Vol. 13. American Mathematical Society, 1992, pp. 391‚Äì407 (cit. on
p. 114).
[S+15]
Eswaran Subrahmanian, Christopher Lee, Helen Granger, et al. ‚ÄúManaging
and supporting product life cycle through engineering change manage-
ment for a complex product‚Äù. In: Research in Engineering Design 26.3 (2015),
pp. 189‚Äì217 (cit. on p. 118).
[Sch+17]
Patrick Schultz, David I. Spivak, Christina Vasilakopoulou, and Ryan Wis-
nesky. ‚ÄúAlgebraic Databases‚Äù. In: Theory and Applications of Categories 32
(2017), Paper No. 16, 547‚Äì619 (cit. on p. 114).
[Sel10]
Peter Selinger. ‚ÄúA survey of graphical languages for monoidal categories‚Äù.
In: New structures for physics. Springer, 2010, pp. 289‚Äì355 (cit. on p. 146).
[Shu08]
Michael Shulman. ‚ÄúFramed bicategories and monoidal Ô¨Åbrations‚Äù. In: The-
ory and Applications of Categories 20 (2008), Paper No. 18, 650‚Äì738 (cit. on
p. 145).
[Shu10]
Michael Shulman. Constructing symmetric monoidal bicategories. 2010. eprint:
arXiv:1004.0993 (cit. on p. 145).
[Sob]
Graphical Linear Algebra. url: https://graphicallinearalgebra.net/
(visited on 03/11/2018) (cit. on p. 179).
[Spi+16]
David I. Spivak, Magdalen R. C. Dobson, Sapna Kumari, and Lawrence
Wu. Pixel Arrays: A fast and elementary method for solving nonlinear systems.
2016. eprint: arXiv:1609.00061 (cit. on p. 219).
[Spi12]
David I. Spivak. ‚ÄúFunctorial data migration‚Äù. In: Information and Computa-
tion 217 (2012), pp. 31‚Äì51 (cit. on p. 114).

BIBLIOGRAPHY
329
[Spi13]
David I. Spivak. The operad of wiring diagrams: formalizing a graphical language
for databases, recursion, and plug-and-play circuits. 2013. eprint: arXiv:1305.
0297 (cit. on p. 219).
[Spi14a]
David I Spivak. Category theory for the sciences. MIT Press, 2014 (cit. on
pp. 105, 114).
[Spi14b]
David I. Spivak. ‚ÄúDatabase queries and constraints via lifting problems‚Äù.
In: Mathematical Structures in Computer Science 24.6 (2014), e240602, 55. url:
http://dx.doi.org/10.1017/S0960129513000479 (cit. on p. 94).
[SS18]
Patrick Schultz and David I. Spivak. Temporal Type Theory: A topos-theoretic
approach to systems and behavior. Springer, Berkh√§user, To appear, 2018 (cit. on
p. 256).
[SSV18]
Alberto Speranzon, David I. Spivak, and Srivatsan Varadarajan. Abstraction,
Composition and Contracts: A Sheaf Theoretic Approach. 2018. eprint: arXiv:
1802.03080 (cit. on p. 255).
[SVS16]
David I. Spivak, Christina Vasilakopoulou, and Patrick Schultz. Dynamical
Systems and Sheaves. 2016. eprint: arXiv:1609.08086.
[SW15a]
Patrick Schultz and Ryan Wisnesky. Algebraic Data Integration. 2015. eprint:
arXiv:1503.03571 (cit. on p. 114).
[SW15b]
David I. Spivak and Ryan Wisnesky. ‚ÄúRelational Foundations for Functorial
Data Migration‚Äù. In: Proceedings of the 15th Symposium on Database Program-
ming Languages. DBPL. Pittsburgh, PA: ACM, 2015, pp. 21‚Äì28 (cit. on p. 114).
[TG96]
Chris Tuƒ≥n and Marc Gyssens. ‚ÄúCGOOD, a categorical graph-oriented ob-
ject data model‚Äù. In: Theoretical Computer Science 160.1-2 (1996), pp. 217‚Äì239
(cit. on p. 114).
[Vig03]
Sebastiano Vigna. A Guided Tour in the Topos of Graphs. 2003. eprint: arXiv:
math/0306394 (cit. on p. 245).
[VSL15]
Dmitry Vagner, David I. Spivak, and Eugene Lerman. ‚ÄúAlgebras of open
dynamical systems on the operad of wiring diagrams‚Äù. In: Theory and Ap-
plications of Categories 30 (2015), Paper No. 51, 1793‚Äì1822 (cit. on pp. 211,
219).
[Wal92]
R. F. C. Walters. Categories and Computer Science. Cambridge University
Press, 1992 (cit. on p. 114).
[Wik18]
Contributors To Wikipedia. Symmetric monoidal category ‚Äî Wikipedia, The
Free Encyclopedia. [Online; accessed 22-February-2018]. 2018. url: https:
/ / en . wikipedia . org / wiki / Symmetric _ monoidal _ category (cit. on
p. 139).
[Wil07]
Jan C Willems. ‚ÄúThe behavioral approach to open and interconnected sys-
tems‚Äù. In: IEEE Control Systems 27.6 (2007), pp. 46‚Äì99 (cit. on p. 179).

330
BIBLIOGRAPHY
[Wis+15]
Ryan Wisnesky, David I. Spivak, Patrick Schultz, and Eswaran Subrahma-
nian. Functorial Data Migration: From Theory to Practice. Report G2015-1701.
National Institute of Standards and Technology, 2015. arXiv: 1502.05947v2
(cit. on p. 114).
[Zan15]
Fabio Zanasi. ‚ÄúInteracting Hopf Algebras- the Theory of Linear Systems‚Äù.
Theses. Ecole normale sup√©rieure de lyon - ENS LYON, Oct. 2015. url:
https://tel.archives-ouvertes.fr/tel-01218015 (cit. on p. 179).

Index
adjoint, see adjunction
adjoint functor theorem, 32, 73
adjunction, 35, 69, 99‚Äì107
examples of, 27, 28, 35, 86, 102, 104
from closure operator, 34
Galois connection as, 27
of preorders, 26‚Äì36
preservation of meets and joins, 31
relationship to companions andcon-
joints, 131
algebraic theory, 172
AND operation, 230, 245
applied category theory, 1‚Äì257
associativity, 82, 83, 125, 135
as coherence condition, 115
in enriched categories, 139
in product category, 110
in wiring diagrams, 46
of composition in an operad, 213
of function composition, 87
of monoid operation, wiring dia-
gram for, 198
of monoidal product, 42
of morphism composition, 81
of profunctor composition, 129
of quantale matrix multiplication,
74
property vs. structure, 136
weak, 130
behavior, 221‚Äì225
contract, 255
properties of, 224
topos for, 252
behavioral approach, 174
Beyonc√©, 51
bicategory, 130
binary relation, see relation, binary, 150
booleans, 4
alternative monoidal structure, 53
and feasibility, 119
as base of enrichment for preorders,
58, 236
as monoidal closed, 70, 231
as preorder, 13, 22
as quantale, 72
as rig, 160
as set, 6, 7
as subobject classiÔ¨Åer, 229, 244
meets and joins in, 25
usual monoidal structure, 52
cardinality, 19
and isomorphisms, 88
categoriÔ¨Åcation, 129, 132‚Äì134
category, 81‚Äì89
as database schema, 89
codiscrete, 104
compact closed, see compact closed
category
composition in, 81
discrete, 104
331

332
INDEX
examples of, 87
Ô¨Ånitely presented, see presentation
of
free, 82, 104, 154
having Ô¨Ånite colimits, 192, 206
hypergraph structure on, 201
identity in, 81
indexing, 95, 111
monoidal structure on, 136
morphism in, 81
object in, 81
of algebras for an operad, 218
of bƒ≥ections, 150
of categories, 93
of cocones, 191
of cones, 110
of cospans, 195
of database instances, 232
of Ô¨Ånite sets, 87, 150, 205
of functors, 96
of graphs, 97
of instances on a database schema,
97
of operads, 218
of preorders, 21
of presheaves, 233
of sets, 87, 224
of sheaves, 223, 237
opposite of, 88
preorder reÔ¨Çection of, 86
presentation of, 84, 93, 158
category of categories, see category, of
categories
category theory
as central hub of mathematics, iii
books on, iv
ceiling function, 27
change of base, see enrichment, change
of base
chemistry, 39, 70, 219
catalysis, 49
monoidal preorder of, 48
closed category
cartesian, 76, 225, 227
compact, see compact closed cate-
gory
compact implies monoidal, 142
hom object in, see hom object
monoidal, see monoidal closed cat-
egory, 76
closure operator, 33‚Äì35, 250
co-design, see also feasibility, 117‚Äì146
diagram, 118, 124
problem, 119
cocone, 114
codomain, see morphism, codomain
coequalizer, 194
coherence, v, 114, 204
as bookkeeping, 136
conditions, 136
Mac Lane‚Äôs theorem, 137
colimit, 113, 182‚Äì194, 224, 225, 231
and interconnection, 194
coequalizer as, 194
coproduct as, 186
Ô¨Ånite, 191‚Äì194
formula for Ô¨Ånite colimits in Set,
193
initial object as, 184
presheavesformcolimitcompletion,
233
pushout as, 188
collage, 122, 131‚Äì132
collection, 81
commutative diagram, 95
commutative square, 84, 91, 95
comonoid, 198
compact closed category, 139‚Äì145, 150,
178
duals in, 141
hypergraph category as, 203
companion profunctor, 130

INDEX
333
comparable, 15
completeness
of proof system, 170
composition
in a category, see category, compo-
sition in
in enriched categories, see enriched
categories, composition in
compositionality, 1, 222, 257
cone, 111
conjoint profunctor, 130
connected, 10
connectedness, 3
connection
as colimit, 183
context free grammar, 214
continuous function, 234
control theory, 149, 178
cooking, iv
coproduct, 186‚Äì188
corelation, 142, 150
corelations
hypergraph category of, see hyper-
graph category, of corelations
cospan, 194‚Äì197
apex of, 194
decorated, 206
foot of, 194
cospans
as theory of Frobenius monoids, 200
category of, 196
composition of, 195
decorated, 203
hypergraph category of, see hyper-
graph category, of cospans
Cost, 54, 69, 71
counit, 141
cover, 234, 237
empty, 237
cowlick
inevitability of, 242
cross section, see section
currying, 103, 227, 249
cyber-physical system, 147
dagger, 21, 66
data migration, 99, 104
adjoints, 102
left pushforward, 104
pullback, 100, 102
right pushforward, 104
database, 77‚Äì81, 224
as interlocking tables, 77
communication between, 79
constraints, 79, 94
data migration, 80
foreign key, 78
ID columns of, 77
instance, 93‚Äì94, 97
instance homomorphism, 97
instances form a topos, 232
query, 106, 112
schema, see database schema, 158
database schema, 78, 93
as category presentation, 79, 85
free, 78
mapping between, 80
design, 117
diagram
as functor, 95
commutative, 95
diÔ¨Äerential equation, 162
discrete dynamical system, 100
induced graph of, 105
disjoint union, see union, disjoint
divides relation, 8, 25
as preorder, 15
domain, see morphism, domain
dual, see also properties, dual
as opposite, 72
category as opposite, in Prof, 145
double, 142
object, 141

334
INDEX
of lax monoidal monotone, 56
self, 143, 178, 203
dual notions
colimits and limits as, 113
subobjects and quotients, 193
dynamical system, 257
continuous, 211
discrete, 101, see discrete dynamical
system
hybrid, 254
eÔ¨Äort
as metric, 60
electric circuit, 181
electrical circuit, 182, 194, 204‚Äì211
closed, 211
via cospans, 209
enriched categories, 139
enriched category
composition in, 139
general deÔ¨Ånition, 138
identity in, 139
metric space as, 61
preorders as, 57
vs category, 87
enriched functor, 65
enrichment, 57‚Äì69
base of, 57
change of base, 64
epi-mono factorization, 28, 225, 227, 243
and existential quantiÔ¨Åcation, 250
epimorphism, 225, 226
surjection as, 227
equivalence of categories, 66, 97
equivalence relation, 9, 193, 194
and partition, 8‚Äì10, 16
as corelation, 142
as binary relation, 9
as symmetric preorder, 13
generated by a preorder, 13, 55
feasibility relation, 119‚Äì125
as Bool-profunctor, 121, 127
compact closed category of, 143‚Äì
145
feedback, 174
Ô¨Åber, see preimage
Ô¨Çip-Ô¨Çop, 181
Ô¨Çoor function, 27
foreign key, see database, foreign key
free
category, 82, 89, 154
monoid, 155
preorder, 153
prop, 155
schema, 78
Frobenius
algebra, 172
law, 198
monoid, 198
structure, 197‚Äì201
function, 2, 10
as database instance, 90
as relation, 10
bƒ≥ective, 10, 150, 156
composite, 12
identity, 11
injective, 10, 226
structure preserving, 2
surjective, 10
functor, 91‚Äì93
data migration, see data migration
diagram as, 95
enriched, see enriched functor
operad, 217
presheaf as, 232
prop, 151
Set-valued, 98, 99, 102, 112, 217
functorial query language, FQL, 79
functorial semantics, 168
future
as not yet arrived, 183
Galois connection, 26‚Äì36

INDEX
335
generative eÔ¨Äect, 2, 4, 6, 26, 37, 242
generators and relations, see presenta-
tion
gluing, 237
graph, 14
arrow, 14
as Set-valued functor, 97
complete, 104
discrete, 104
free category on, 82
homomorphism, 98
paths in, 14
vertex, 14
weighted, 62
graphs
database schema for, 97‚Äì102
homomorphism of, 97
topos of, 233
graphs
homomorphism of, 99
greatest common divisor, 25
greatest lower bound, 23
group, 84, 88
commutator subgroup, 104
free, 104
Hasse diagram, 5, 14, 16‚Äì18, 35, 54
database schema as, 78
for metric spaces, 62
for preorders, 5
for profunctors, 132
weighted graph as, 62
HausdorÔ¨Ädistance, 60, 73
hom object, 57, 58, 64, 128, 138, 139
matrix of, 64
hom-set, 81
hypergraph category, 197‚Äì203
of corelations, 202
of cospans, 202
of linear relations, 203
hypergraph prop
operad for, 216
theory of, 218
icon, 44, 140, 157, 160‚Äì163, 183, 197
copy, 51
crossing wires, 46
cup and cap, 140
discard, 50
spider, 184, 199
identity
function, 11, see also function, iden-
tity
functor, 93
in enriched categories, see enriched
category, identity in
in wiring diagrams, 135
matrix, 74, 166
morphism, 81, 82
natural transformation, 96
port graph, 153
profunctor, see also unit
iÔ¨Ä, 14
IMPLIES operation, 231, 245
induction, 166, 191
inÔ¨Åmum, 25
inÔ¨Åx notation, 8, 9, 13, 42, 230
informatics
discarding in, 52
duplication in, 52
monoidal preorder of, 51
initial object, 184‚Äì186
as colimit, 192
empty set as, 185
interaction, 221
interconnection, 182
as variable sharing, 147
network-type, 183
via Frobenius structures, 197
interface, 182, 222
intersection, 8, 54, 224
as meet, 25
interval domain, IR, 252‚Äì255
involution, 280

336
INDEX
isomorphism, 88‚Äì89
adjunction as relaxed version of, 27
as stable under pullback, 226
as stable under pushout, 189
bƒ≥ection as, 88
of preorders, 21
join, 4, 23‚Äì25, 73
as coproduct, 186
joins
preservation of, 5, 31
required in a quantale, 71
Kan extension, 115
language, 223
internal, 223, 251
Lawvere metric space, 59‚Äì65
as Cost-category, 59
of regions, 60
least common multiple, 25
least upper bound, 23
level shift, 18, 35, see also primordial
ooze
lifting problems, 94
limit, 107‚Äì113, 224, 225, 231
formula for Ô¨Ånite limits in Set, 112
product as, 108
pullback as, 112
terminal object as, 107
linear relation, 177
linear relations
hypergraph category of, see hyper-
graph category, of linear rela-
tions
logic, 34, 224, 230‚Äì232
implication in, 6
in a topos, 243
manufacturing, 39
discard operation in, 50
monoidal preorder of, 49
map
monotone, see also monotone map,
18‚Äì22
order-preserving, see map, mono-
tone
structure preserving, 1, 18
mapping object
see hom object, 57
matching family, 237
matrices
multiplication of, 74
rig of, 160
matrix, 63, 73, 123
associated to a signal Ô¨Çow graph,
165‚Äì168
feasibility, 122
identity, 74
of distances, 62
meet, 23‚Äì25, 109
meets
preservation of, 26, 31
metric space, 66
as Cost-category, 61
as topological space, 235
discrete, 104
extended, 59
ordinary, 59
presentation of, 62
mirror image, see transpose
modal operator, 250
modes of transport, 63
monoid, 42, 83, see also monoidal cate-
gory, monoid object in
as one-object category, 83
free, 104, 155
group as, 88
monoidal category, iv, 136‚Äì138
monoid object in, 172‚Äì173
monoidal closed category, 69
booleans as, 70
Cost, see Cost
monoidal functor, 173, 204, 206, 209, 213

INDEX
337
monoidal monotone as, 56
monoidal monotone, 55‚Äì57
monoidal preorder, 41‚Äì57
opposite of, 55
monoidal product, 41
as stacking, 197, 211
monoidal structure, 41
weak, 42
monoidal unit, 41
drawn as nothing, 45
monomorphism, 225, 226
as stable under pullback, 226
injection as, 226
monotone map, see also map, monotone
as Bool-functor, 66
as functor, 92
morphism, v
codomain, 81
domain, 81
identity, 81
in free category, 82
inequality as mere existence of, 86
invertible, 88
natural numbers, 15, 42, 53
as free category, 83
as free monoid, 155
as rig, 159
natural numbers as
as set, 7
natural transformation, 95‚Äì97
as presheaf morphism, 233
between monotone maps, 97
component of, 95, 96
graph homomorphism as, 98
identity, 96
naturality condition, 95
navigator, 72, 126
network
diagram, 181
language, 201
NOT operation, 231, 245
notation, see also icon
for classiÔ¨Åed subobjects, 229
for common sets, 7
for monoidal structures, 42
inÔ¨Åx, see inÔ¨Åx
set builder, 7
obvious
conventionalmathematicalmeaning
of, 150
ooze
primordial, see primordial ooze
open set, 234
open system, 182
operad, 184, 211‚Äì218
algebra of , 217
as custom compositionality, 184
from monoidal category, 214
of cospans, 215
of sets, 214
of wiring diagrams, 211
operation in, 213
operation, see operad
logical, 224
opposite
V-category, 66
category, see category, opposite
preorder, 18
opposite category
and presheaves, 232
as dual, 145
OR operation, 230, 245
order, see also preorder
preservation of, 5
total, 16
ordinals
as categories, 83
partial order, 13, see also preorder, skele-
tal, 127
partition, 9, 20, 28‚Äì30
as surjection, 11

338
INDEX
associated equivalence relation of,
10
from preorder, 16
label irrelevance of, 9
part of, 9
pullback of, 29
pushforward of, 29
pie
lemon meringue, 40, 47
poker, 43
port graph, 151‚Äì153, 155
acyclicity condition, 151
as morphism, 152, 156
poset, see partial order
power set, 16, 17, 19, 54, see also pre-
order, of subobjects, 204
predicate, 224, 228, 247, 256
prediction vs. possibility, 221
preimage, 10, 11, 32, 120, 234, 238
preorder, 12‚Äì18
as Bool-category, 57, 58
as category, 85
codiscrete, 13, 104, 303
Cost, see Cost
dagger, see dagger
discrete, 13, 20, 104, 303
free, 104
free on a relation, 153
monoidal, see monoidal preorder
of open sets, 236
of partitions, 17
of subobjects, 247
partial order as, 13
presentation of, 14
skeletal, 13, 21
symmetric monoidal, see monoidal
preorder, 137
preorder relation
as binary relation, 12
presentation
of linear algebra, 168
of metric space, 62
of monoid, 85
of preorder, 14
of prop, 158
presheaf, 232‚Äì234
as database instance, 233
restriction maps, 232
sections, 232
presheaves
morphism of, 233
topos of, 232
primordial ooze, see also ooze, primor-
dial, 93, 97, 134, 173
product
as limit, 111
in a category, 108
meet as, 109
monoidal, 136
of V-categories, 67
of categories, 110, 144
of preorders, 17
of sets, 8, 109
profunctor, 119‚Äì132
Cost, 122, see also Cost
as bridges, 122, 131
Bool, 119
collage of, see collage
enriched, 121, see profunctor
unit, 128, 130
profunctors
category of, 125‚Äì130
compact closed category of, 139
composition of, 125, 127
program semantics, 34, 37
prop, 149‚Äì179
FinSet, 150
expression in, 157
free, 155
hypergraph, 202
of R-relations, 175
of matrices, 164, 170

INDEX
339
posetal, 151
presentation of, 158
signature of, 155
properties
dual, 33
proposition, 54, see also logic
pullback, 225
along a map, 22, 32, 101
as limit, 112
monomorphism in terms of, 226
of isomorphism, 226
pullbacks
pasting of, 225
pushout, 28, 188‚Äì191
along isomorphism, 189
as colimit, 188
epimorphism in terms of, 226
in cospan composition, 195
quantale, 68, 71‚Äì76, 121, 123, 160
commutative, 71
Cost as, see Cost
matrix multiplication in, 73
of open sets, 236
quantales
as self-enriched, 71
quantiÔ¨Åcation, 248
quotient, 10, 104, 157, 193
as data migration, 107
real numbers, 16, 42, 45, 172
as metric space, 61
as preorder, 23
as set, 7
topology on, 234
recipes, 40
reÔ¨Çexivity, 9, 12
as identity in a preorder, 85
relation, 8, 151
binary, 8, 35
divides, see divides relation
equivalence, seeequivalence relation
free preorder on, 35, 153
function as, 10
linear, see linear relation
preorder, see preorder
subset, 54
relations
composition of, 175
resource, 117
theory, 39‚Äì52
restriction map, see presheaf, restriction
map
retraction, 89
reverse icon, see transpose
rig, 159‚Äì160
matrices as, 160
matrices over, 164
vs. ring, 160
ring
free, 104
safety proof, 255
schema, see dtabase schema89
semantics, 223, 251
sound, 251
semiring, see rig
set, 7‚Äì8
nth ordinal as, 7
as sheaf on one-point space, 242
booleans as, 7
empty, 7, 11
integers as, 7
natural numbers as, 7
one element, 7
real numbers as, 7
sets
category of, 87
sheaf, 223, 232‚Äì242
condition, 237
constant, 253
of local functions, 254
of sections of a function, 237, 240
of vector Ô¨Åelds, 241

340
INDEX
on IR as semantics of behavior, 253
sheaves
morphism of, 237
topos of, 242
Sierpinski space, 235, 242
signal Ô¨Çow graph, 148‚Äì179
and linear algebra, 176
as morphism, 162
general, 175
semantics of, 163
simpliÔ¨Åed, 160
site, 232
database schema as, 232
topological space as, 234
skeleton, 13, 66
snake equations, 141
soundness
of proof system, 170
spider, 183, 199
as iconography, 184
spiderable wire
Frobenius structure as, 199
stacking, see monoidal product
subobject classiÔ¨Åer, 225, 228‚Äì230, 243‚Äì
251
and logic, 230
as superdense nugget from outer
space, 228
for behavior types, 254
in Set, 229
subset, 7, see also power set
summaries
limits and colimits as, 106
supremum, 25
symmetry, 9, 13, 42, 149
and dagger, 21
as required for enriched products,
67
in wiring diagrams, 46
lack of for eÔ¨Äort, 60
of monoid operation, wiring dia-
gram for, 198
of monoidal product, 42
system
component, 222
property, 223
tangent bundle, 241
vector Ô¨Åelds as sections of, 241
terminal object, 108
as limit, 107
limit as, 111
universal property of, 108
theory
of hypergraph props, 218
of monoids, 173
top element, see terminal object
topological space, 234‚Äì240, 252
topology
codiscrete, 104
discrete, 104, 235
subspace, 236
topos, 223, 242‚Äì257
as category of sheaves, 237, 242
database instances as, 231
of sets, 224
properties of, 225‚Äì230
total order, 15, 28
transitive closure, 29
transitivity, 9, 12
as composition in a preorder, 85
transpose, 174
tree of life, 19
triangle inequality, 60
trivial path, 82, 91, 151
type theory, 251
union, 4, 8, 64
and data migration, 105
as join, 25
disjoint, 8, 107, 133, 186

INDEX
341
unique up to unique isomorphism, 24,
108
unit, 141
monoidal, 41, see also monoidal unit
profunctor, 128
unitality, 81, 83, 125, 135
as coherence condition, 115
in enriched categories, 139
of identity functions, 87
of monoid operation, wiring dia-
gram for, 198
of monoidal product, 42
weak, 130
universal property, 23, 108, 115, 153‚Äì
159, 184
upper set, 17, 22
V-category, see enrichment
V-profunctor, see profunctor, enriched
vector, 164, 165, 173
tangent, 241
vector Ô¨Åeld, 241
vector space, 212
free, 104
weighted graph, see graph, weighted
wiring diagram, iv, 40, 43‚Äì48, 134‚Äì136,
140
as graphical proof, 47
for categories, 134
for hypergraph categories, 200
for monoidal categories, 136
for monoidal preorders, 44
icon of, 44, 46, 51
styles of, 44, 146, 183
Yoneda lemma
for preorders, 20

