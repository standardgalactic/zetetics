KITT PEAK NATIONAL OBSERVATORY 
MEMORANDUM 
TO ___ D_i_s_t_r_l_·b_u_t_l_·o_n ________________________________________ ~~ October 1979 
FROM ___ 
R_. __ 
S....::.t_e_v....::.e_n....::.s~ _______________ SUBJECf Forth Primer - Update 3 
~ 
Attached is Update 3 of the Forth Primer. 
This update is 
a complete reprinting of this manual. 
please discard any old 
copies of the Primer that you may have. 
The major changes to the Primer are: 
- Correspondence with KPNO Forth, Versions 3.0 
and later. 
This level of KPNO Forth conforms 
(in general) to the 1978 Forth International 
Standard; 
- Description of the file system (Section 13.2). 
This section corresponds to KPNO Forth, Versions 
3.3 and later; 
- Description of overlays (Section 13.3); 
- Description of vocabularies (Section 11.4). 
As usual, any comments or suggestions concerning any aspect 
of the primer are welcome. 

" KITT PEAK NATIONAL OBSERVATORY. 
TUcson, Arizona 85726 
A 
EU S ARMY 
PROPERTY OF C~!ORMA;lor: CENTER 
REDSTONE SCIENT~S£NAJ.. ALABAMA .., 
, REDSr.ONi 
W. Richard Stevens 
October 1979 
(Update 3) 
*Kitt Peak Nationa' Observatory is operated by the AssoCiation of 
~iversities ~r ResearCh in Astronomy, Inc., under Contract with 
the National Science Foundation. 

TABLE 
OF 
CONTENTS 
1. 
I nt roduct ion . . . . . . . . . . . . . . . . . . . • . . 
. 1-1 
2. 
Obtaining a copy of the current FORTH system ...••.•.•. 2-1 
3. 
4. 
5. 
Loading 
3. 1 
3.2 
3.3 
3.4 
FORTH into the computer. 
Running from disc .. 
Running from tape .•.•• 
Restarting from disc ... 
Saving your program modifications. 
Executing FORTH utility words. 
4.1 
Terminal Interaction. 
4.2 
Re-formatting the disc 
4.3 
Listing FORTH blocks •. 
Arithmetic Expressions ••.. 
5.1 
The FORTH Stack •..•• 
5.2 
Infix/Polish Notation •. 
.. 3-1 
.3-1 
.3-2 
... 3-3 
.3-6 
.4-1 
. .4-1 
.4-3 
.4-4 
.5-1 
.5-1 
.5-4 
6. 
The FORTH Dictionary .....••••.•.•.••.••..• 6-1 
7. 
8. 
Data 
7. 1 
7.2 
7.3 
7.4 
7.5 
7.6 
7.7 
Structures ...•...• 
Integers .•.•..• 
Double-word Integers 
Floating-point Numbers •. 
Conversions between Data Structures •. 
Logical Values and Logical Expressions 
Additional Numeric Conversions .. 
Vectors. 
Stack Operations 
8.1 
Manipulation Words 
8.2 
Comparison Words. 
.7-1 
.7-1 
.7-6 
.7-11 
.7-18 
.7-20 
.7-22 
.7-25 
• .8-1 
.8-1 
.8-9 
9. 
The Colon Definition ...•...•..••...•••••.• 9-1 

10. 
Program 
10. I 
10-2 
10-3 
10-4 
Control . . . . . 
DO LOOPS . . . . . 
BEGIN-END Loops .. 
BEGIN-WHILE-REPEAT Loops 
IF-THEN-ELSE Statement Selection 
10-1 
10-1 
10-7 
. 10-9 
10-10 
1 I . 
Bloc k I /0 . • . . . . . . . . . . . . . . . . . . . . . . . . . 1 1 - 1 
12. 
13. 
14. 
15. 
16. 
Text Editor 
. . . · · · · · · . . . . . 
12. 1 
Special Characters and Terminology 
12.2 
12.3 
Program 
13. 1 
13.2 
13.3 
13.4 
Terminal 
14. 1 
14.2 
14.3 
Advanced 
15. I 
15.2 
15.3 
15.4 
Command Descriptions 
Block Editor · . · · · · 
Structure 
· . · · · · 
Block Oriented Programs. 
File System. · 
Overlays. · · 
Vocabularies 
I/O ...... . 
Character Output 
Numeric Input. 
Numeric Output. 
. 
Arithmetic .......• 
Numerical Functions ..•. 
Mixed Precision Operators. 
Arithmetic Range Errors .. 
Combined Words ..... . 
Real-Time I/O . . . 
16. 1 
Interrupts 
16.2 
CAMAC I/O. · 
16.3 
FORTH CAMAC Words. 
16.4 
FORTH Interrupt Words. 
. . . . 
Appendices 
A. 
B. 
C. 
D. 
ASCI I Character Set. 
FORTH Error Codes . . 
Answers to Exercises. 
FORTH Glossary .... 
12-1 
12-1 
12-2 
12-13 
13-1 
13-1 
13-11 
13-18 
13-22 
14-1 
14-1 
14-2 
14-3 
15-1 
15-1 
15-7 
15-9 
15-10 
16-1 
16-1 
16-2 
16-5 
16-10 
. A-I 
B-1 
C-I 
. D-I 

1. I NTRODUCT ION 
FORTH is a programming system whose main function is to simplify the program-
ming of minicomputers that are used for on-line data acquisition. 
This 
primer is intended as an introduction to FORTH. 
The only assumption made 
is that the reader has some experience and acquaintance with computers in 
general (probably through the FORTRAN language) and is capable of pursuing 
a self study course. 
The organization of this primer Is to present the features of FORTH in an 
orderly and stepwise fashion. 
This primer should be read in the order presented 
as each chapter builds on the points covered in the previous chapter. 
Computer Science is a field in which "hands on" experience is a requisite; 
that is, one can read a plethora of programming manuals and obtain some 
information, however one must write and debug some programs using a given 
programming tool in order to really understand and appreciate the tool being 
used. 
FORTH is a classical example of this principle and a perusal of this 
primer without trying to work or understand the examples and exercises wi 11 
yield very little knowledge of FORTH. 
This requisite for "hands on l ' 
experience is especially true with FORTH since it is an interactive, terminal-
oriented, minicomputer system quite different from the batch-oriented FORTRAN 
systems you are probably familiar with. 
This manual is intended to be used as a self study tool and therefore 
exercises to be worked, along with complete solutions are provided. 
It 
must be clearly stated that the provided solutions are not to be considered 
the only solution to an exercise. 
Programming is an art and therefore 
there will usually exist more than one solution to a given problem. 
The 
analysis of all possible solutions, in order to determine the "best" 
solution, is not a clearly defined task, mainly due to the variable 
criteria avai lable to specify which solution is 'Ibest". 
The reader should 
not be disturbed if he arrives at a solution that is not identical with the 
provided solution but should try to understand the provided solution (and 
possibly compare the two solutions to determine which, if either, is "better"). 
Feb. 1977 
I - I 

As with any self study course, referral to the solution for an exercise, 
before making an honest attempt to solve the exercise on your own, defeats 
the purpose of this primer. 
Although an occasional reference is made to the version of FORTH used at 
Kitt Peak (for its Varian 620 minicomputers) this primer is largely 
independent of any specific FORTH implementation. 
In fact, until the final 
chapter no mention is made of 
the computer being binary or decimal and 
no specification of the number of bits in a computer word is needed. 
This manual is a primer and as such does not describe FORTH in its entirety. 
All of the nitty gritty details of the implementation of FORTH are ignored, 
instead this primer tries to give the reader an appreciation of what FORTH 
is and how to use it to solve a large class of problems on a minicomputer. 
The most notable exclusion from this primer is a description of machine 
language programming in FORTH, this topic being so dependent on the specific 
computer being used. 
This topic along with an advanced description of the 
implementation of FORTH is covered in "FORTH - Systems Reference Manual" 
which is available from the author at Kitt Peak National Observatory, Tucson, 
Ar i zona 85726. 
Comments and suggestions concerning any portion of this manual are solicited. 
Please try to be as specific as possible (reference the page number and 
revision level). 
Direct all comments to the author. 
1-2 
"Explain all that," said the Mock Turtle. 
"No, no, the adventures first," said the gryphon in an 
impatient tone: 
"Explanations take such a dreadful time." 
LEWIS CARROLL 
Alice's Adventures in Wonderland 
Feb. 1977 

NOTE: 
The version of FORTH used throughout this manual is Kitt Peak FORTH, 
Versions 3.0 and later, which runs on a Varian 620 minicomputer. 
This version 
of FORTH corresponds to the basic system defined by the FORTH International 
Standards Team along with many Kitt Peak extensions. 
Oct. 1979 
1-3 

2. 
OBTAINING A COPY OF THE CURRENT FORTH SYSTEM 
The first thing one must do is obtain a copy of the current version of the 
KPNO Varian FORTH system on a magnetic tape. 
This tape may then be taken 
to any of the KPNO Varian systems, loaded into the system and executed. 
The current version of FORTH will always reside on the Kitt Peak CDC 6400 and 
the following job will copy the system onto your magnetic tape (a 600 foot 
tape is sufficient). 
jobname,account#,MT1. 
VSN ( TAPE 9= tape# ) 
REQUEST(TAPE9.HI.S.RING) 
jobname and account# are parameters required 
by the 6400 SCOPE operating system. 
tape# is the volume serial number or volume 
serial name on the magnetic tape. 
causes the mag tape to be mounted on a tape 
drive with a write ring and directs the 
system to write the tape at 556 bpi. 
ATTACH(TAPE5.DOFORTH,CY=5) 
attaches the current version of FORTH to 
tapeS. 
ATTACH(DOFORTH.DOFORTH) 
DOFORTH. 
end-of-record card 
end-of-record card 
attaches the public file DOFORTH which is the 
FORTH utility program used to manipulate 
FORTH tapes. 
execute DOFORTH. 
terminates the SCOPE commands. 
termi nates the 
$ I NTYPE cards. 
$OUTTYPE 
TAPE=.TRUE •• 
IBLK1=l, 
t cOl . 2 of card 
IBLK2=199 
$ 
end-of-fi Ie card 
Feb. 1977 
termi nates the a;OUTTYPE cards and 
termi nates the program. 
2-1 

Upon successful execution of this job the user should remove the write 
ring from the magnetic tape. 
The contents of the tape (which will 
automatically be printed by the above job) are blocks 1-199 of the 
current FORTH system (blocks 1-7 are not printed). 
If the user has a FORTH tape that he wants listed on the CDC 6400 (Section 
3.4 describes the procedure for creating a FORTH tape on the minicomputer) 
the following job may be used: 
jobname,account#,MT1. 
VSN(TAPEB= tape#) 
REQUEST(TAPEB,HI,S) 
ATTACH(DOFORTH,DOFORTH) 
DOFORTH. 
2-2 
jobname and account# are parameters 
required by the 6400 SCOPE operating 
system. 
tape# is the volume serial number or 
volume serial name on the magnetic 
tape to be listed. 
causes the mag tape to be mounted on 
a tape drive without a write ring 
and directs the system to read the 
tape at 556 bpi. 
attaches the public file DOFORTH which 
is the FORTH utility program used to 
manipulate FORTH tapes. 
execute DOFORTH. 
Feb. 1977 

end-of-record card 
terminates the SCOPE commands. 
$INTYPE 
TAPE=.TRUE. 
$ 
~ 
column 2 of card 
end-of-record card 
terminates the $INTYPE commands. 
$OUTTYPE 
TAPE=.FALSE. 
$ 
~ 
column 2 of card 
end-of-file card 
terminates the $OUTTYPE commands 
and terminates the program. 
This job will read in blocks 1-511 from the user's FORTH tape and then 
produce a line printer listing of these blocks. 
Feb. 1977 
2-3 

3. 
LOADING FORTH INTO THE COMPUTER 
Now that you have a copy of FORTH on tape the steps required to load the 
tape into a computer and then execute the FORTH system must be described. 
FORTH is somewhat unique in that the system will run from either a disc 
or a tape and each process is described separately below. 
3.1 
RUNNING FROM DISC 
I} Power on the computer and all associated peripherals. 
2} Mount your FORTH tape on the magnetic tape drive and check that the 
switches on the magnetic tape controller (located immediately above the 
tape drive) are set as follows: 
Density 
Mode 
Parity 
HI/LOW 
-> 
LOW 
REMOTE/MANUAL -> MANUAL 
EVEN/ODD 
-> 
ODD 
Position the tape to the load point (push the load button twice) then place 
the drive on-line. 
At this point the LOAD and ONLINE buttons should be 
lighted. 
3} Place the disc STOP/READY switch to the READY position and wait approximately 
40 seconds for the READY light to come on. 
4} Set the Sense Switches on the CPU as follows: 
Sense Swi tch 
-> DOWN 
(load from tape) 
Sense Swi tch 2 -> UP 
{see note below} 
Sense Swi tch 3 -> UP 
{run from disc} 
5} Press the following swi tches on the CPU: 
STEP/RUN 
-> 
STEP 
RESET 
-> 
Press down 
STEP/RUN 
-> 
RUN 
BOOTSTRAP 
-> 
Press down 
Note: 
Sense Switch 2 is looked at only if you are loading from tape onto disc. 
In this case, if Sense Switch 2 is DOWN, then the region of disc that will be 
copiad from the tape is zeroed before the tape is copied onto di.sc, 
If Sense 
Switch 2 is up, the disc region is not zeroed. 
tf you plan to make modifica p 
tions to some program blocks and then save a copy of the new program (Section 
3.4), Sense Switch 2 should be DOWN. 
Oct. 1979 
3-1 

At this point the tape will be copied onto the disc and at completion the 
tape will automatically rewind. 
The RUN light and the OVFL light on the 
CPU should be lighted. 
In order to load the basic FORTH system into core from the disc press 
any key on the terminal (such as the RETURN key) and FORTH will respond 
by ringing the terminal bell. 
Basic FORTH will automatically 
be loaded into cQre and the following message will be output to 
the terminal: 
FORTH x.y date 
comment 
620/F AND DISK 
(x.y denotes the version of the FORTH system, date specifies the creation 
date of the FORTH system and comment is an operator specified comment that 
describes the contents of the tape (refer to Section 3.4)). 
3.2 RUNNING FROM TAPE 
1) Power on the computer and all associated peripherals. 
2) Mount your FORTH tape on the magnetic tape drive and check that the switches 
on the magnetic tape controller (located immediately above the tape 
drive) are set as follows: 
Density 
Mode 
Par i ty 
HI/LOW 
-> 
REMOTE/MANUAL -> 
EVEN/ODD 
-> 
LOW 
MANUAL 
ODD 
Position the tape to the load point (push the load button twice) then place 
the drive on-line. 
At this point the LOAD and ONLINE buttons should be 
1 ighted. 
3) Set the sense switches on the CPU as follows: 
3-2 
Sense Switch 
-> DOWN 
Sense Swi tch 2 -> UP 
Sense Swi tch 3 -> DOWN 
(load from tape) 
(run f rom tape) 
act. 1979 

4} Press the following switches on the CPU: 
STEP /RUN 
-> 
STEP 
RESET 
-> 
press down 
STEP /RUN 
-> 
RUN 
BOOTSTRAP -> 
press down 
At this point the tape will briefly (2seconds) move and then the RUN light 
and the OVFL light on the CPU will be lighted. 
In order to load the basic FORTH system into core from the tape press any 
key on the terminal (such as the RETURN key) and FORTH will respond by rin~ing 
the terminal bell. 
Basic FORTH will automatically be 
lo~ded into core 
and the fo 11 owi ng message -wrl 1 be output to the term i na 1 • 
FORTH x.y date 
aomment 
620/F AND TAPE 
(x.y 
denotes the version of the FORTH system, date specifies the creation 
date of the FORTH system and aomment is an operator specified comment that 
describes the contents of the tape (refer to Section 3.4}). 
3.3 
RESTARTING FROM DISC 
The two procedures described above are referred to as "cold-start" procedures 
since they make no assumptions concerning the contents of the disc or core, 
instead basic FORTH is reloaded from magnetic tape. 
Obviously this procedure 
takes some time (depending on how many programs and/or data are contained on 
the tape) therefore if we are certain that the FORTH system contained on 
the disc is usable (i.e., the disc has not been erased or overwritten since 
FORTH was last loaded from tape onto disc) we may save time by loading FORTH 
from the disc and not reading in the magnetic tape version. 
This procedure 
is referred to as a "warm-start" and may be performed whenever the user 
has clobbered the FORTH system in core (but not the system on disc): 
Oct. 1979 
3-3 

3-4 
1 ) 
Set the Sense Switches on the CPU as follows: 
Sense Swi tch 
~--> 
UP 
(load from disc) 
Sense Swi tch 2 
---> 
UP 
Sense Swi tch 3 ---> 
UP 
(run from disc) 
2) 
Press the following switches on the CPU: 
STEP/RUN 
---> 
STEP 
RESET 
---> press down 
STEP/RUN 
---> 
RUN 
BOOTSTRAP 
---> press down 
The RUN light and the OVFL light on the CPU will be lighted. 
To load the 
basic FORTH system into core from the disc press any key on the terminal 
(such as the RETURN key) and FORTH will respond by ringing the terminal 
bell. 
Basic FORTH will automatically be loaded into core. 
It should be obvious that this "warm-start" procedure is appl icable only 
if FORTH was originally loaded from tape onto the disc. 
If you are 
running from tape and wish to reload FORTH you must go through the entire 
tape load procedure again (Section 3.2). 
One additional "wann-start" procedure is available, namely keying in the 
word 
ZAP 
terminated by a carriage-return. 
FORTH will respond 
by 
ringing the terminCll bell and Basic FORTH will automatically be loaded 
into core. 
This procedure has the advantage that the entire reloading process is 
done through the terminal and you do not have to set any switches on the 
CPU - an obvious benefit if the CPU is separated from the terminal by 
some distance. 
The disadvantage of this procedure is that FORTH must be 
responding to terminal input in order for you to enter and execute the 
word 
ZAP. 
If you have somehow destroyed the FORTH system in core to 
the point that it is not accepting terminal input then you have to resort 
to either a disc "warm-start" or a "cold-start". 
Oct. 1979 

o 
() 
rt 
\.D 
-....J 
\.D 
Vol 
I 
Vl 
Load from Tape 
Run from Disc 
Power-on all computer 
equ i pment. 
Mount system tape. 
Sense Swi tch 1 -
DOWN 
Sense Switch 2 - UP 
Sense Switch 3 - UP 
STEP/RUN 
-to 
STEP 
RESET 
-to 
press down 
STEP/RUN 
-to 
RUN 
BOOTSTRAP 
-to 
press down 
Entire tape reads in. 
Press 9ny terminal key 
to load basic FORTH. 
Load from Tape 
Run from Jape 
Power-on all computer 
equipment. 
Mount system tape. 
Sense Switch 1 -
DOWN 
Sense Switch 2 - UP 
Sense Switch 3 -
DOWN 
STEP/RUN 
-to 
STEP 
RESET 
-to 
press down 
STEP/RUN 
-to 
RUN 
BOOTSTRAP 
-to 
press down 
First few records on tape 
read in. 
Press any terminal key to 
load ba~ic FORTH. 
Table 3.1 
Loading FORTH into the Computer 
Load from 0 i sc 
Run from Disc 
Power-on all computer 
equipment. 
Sense Switch 1 -
UP 
Sense Switch 2 - UP 
Sense Switch 3 - UP 
STEP/RUN 
-to 
STEP 
RESET 
-to 
press down 
STEP/RUN 
-to 
RUN 
BOOTSTRAP 
-to 
press down 
Press any terminal key to 
load basic FORTH. 

3.4 
SAVING YOUR PROGRAM MODIFICATIONS 
3-6 
If, after loading FORTH onto the disc, you make modifications and 
changes to your program(s) you will want to save a copy of these 
changes on magnetic tape (since the next person who uses the disc 
may erase or overwrite your program blocks). 
The procedure to do 
this is as follows: 
1) 
Mount a scratch tape on the tape drive with a write ring. 
2) 
Execute the word 
SAVEDISK 
and the following will be output 
to the terminal: 
ENTER 
NEW 
COMMENT 
OR 
RETURN, 
TO 
SAVE 
BLOCKS 1-511 
OLD 
COMMENT l 
(old comment ) 
Old corronent is the comment line that was printed after loading 
basic FORTH. 
This comment serves no 
purpose except to provide the operator with a message identifying 
the FORTH system and program(s) that were loaded. 
Each time the 
disk is saved the operator has the option of changing this comment 
and if you so desire you may key in a new comment at this point 
(up to 63 characters, terminated by a carriage-return). 
If you 
wish to retain the old comment then simply enter a carriage-return. 
3) 
After you have either keyed in a new comment or entered a carriage 
return one of the following messages will be output to the terminal: 
TAPE ON LINE. 
** NO MAP READ ** 
01" 
TAPE DOES NOT RESPOND. 
(If the second message is printed then the tape drive is not on 
1 i nee ) 
Oct. 1979 

4) 
Blocks 1 through 511 will be copied from disc onto tape and then 
the tape will be rewound. 
The following message will be output 
to the terminal: 
Feb. 1977 
*** BLOCKS 1-511 SAVED *** 
This tape may now be taken to any of the mini-computer systems 
and loaded into core using the methods described in Sections 3.1 
and 3.2. Additionally this tape may be taken to the CDC 6400 
and listed on the line printer using the method described in 
Chapter 2. 
3-7 

3-8 
EXERCISES - CHAPTER 3 
1) 
Perform a cold-start and run FORTH from disc. 
How long does the 
procedure take? 
Now that FORTH resides on disc perform a warm-start 
from the disc. 
Perform a ZAP. 
2) 
Perform a cold-start and run FORTH from tape. 
How long does the 
procedure take? 
Oct. 1979 

4. 
EXECUTING FORTH UTILITY WORDS 
After having learned the procedures required to load FORTH into the 
computer, the purpose of this chapter is to have you execute and use 
some system defined routines thereby gaining some feeling for the 
operator-machine interaction provided by an interactive system such 
as FORTH. 
4.1 
TERMINAL 
INTERACTIO~ 
The first concept to understand is the entering and execution of words 
through the terminal. 
You are already familiar with this from executing 
the word 
ZAP from the previous chapter. 
The general rules are: 
FORTH does not interpret a line of operator insert until 
the operator terminates the line by entering a carriage-return. 
The operator may delete the previous character by entering 
a rubout. 
FORTH responds by backspacing one character. 
The operator may delete an entire line by entering a Control-U. 
FORTH respohds by printing "\11. 
After entering a carriage·return to terminate a line of input, FORTH 
will go through the line and execute every word in the input line. 
The definition of a FORTH word is very simple: 
A FORTH word is a sequence of up to 64 characters, preceded 
by a space and terminated by a space. 
The sequence of 
characters may contain any character in the ASCll character-se~ 
(Appendix A) except carriage-return, rubout, ControZ-U or space. 
For example, entering the line 
1 
HELLO? 
RESIDENT§ 
ZAP-ZAP 
(terminated by a carriage-return) will cause FORTH to execute the four 
words 
Oct. 1979 
4-1 

1 
HELLO? 
RESIDENTN 
ZAP-ZAP 
(The actual execution of each word will be discussed later, presently 
we are just interested in the entering of words in an input line 
through the terminal.) 
The words are executed in the order in which 
they are entered. 
If all goes well and FORTH successfully executes each word in the input 
string then FORTH responds with a carriage-return, 
line-feed (i.e. - moves to the beginning of the next line), outputs 
an asterisk and waits for the operator to enter another line of 
input. 
This loop (enter a line of input, execute each word in the 
input line, •.• ) is the heart of the FORTH system. 
If FORTH detects an error of any sort while executing a word in the 
input string, FORTH wi I r output the 
name of the word it was executing when the error was detected, 
followed by a question-mark and a single character identifying the 
type of error. 
(A listing of the single character error codes and 
a description of each is found in Appendix B). 
For example, if the 
operator entered the four words as shown above and for some reason 
a Q error occurred whi Ie executing the word 
HELLO? 
then FORTH 
will output 
HELLO ?Q 
Similarly, if a U error occurred while executing the word 
ZAP-ZAP 
FORTH will respond with 
.ZAP,-ZAP 
?U 
4-2 
Oct. 1979 

4.2 
RE-FORMATTING THE DISC 
This exercise is a good example of an interactive program. 
For reasons 
that are not important here, it occasionally becomes necessary to 
re-format the disc (this involves the updating of certain timing tracks 
used by the hardware to access the data on the disc). 
The disc consists 
of two platters, a removable platter and a fixed platter, either of 
which may be re-formatted. 
After having loaded basic FORTH into core execute 
UTIL FORMATTER 
and a list of instructions should be output on the terminal. 
Execute 
R-CHECK 
and note any format errors on the removable platters (hopefully there 
should not be any). 
Similarly execute 
F-CHECK 
to check the fixed platter. 
Then re-format both platters by executing 
R-FMT 
and subsequently 
F-FMT 
Both platters may be zero'ed (i.e. - erased) by executing 
R-ZERO 
F-ZERO 
Note that this final step (zero'ing the entire disc) erases the FORTH 
system stored on the disc, necessitating a cold-start from tape the 
next time you wish to re-load the system. 
After completing this little exercise, execute the word 
DISCARD 
Oct. 1979 
4-3 

which effectively throws away the last program loaded (the disc 
re-formatter) so that you may re-use the core that it took up. 
4.3 
LISTING FORTH BLOCKS 
4-4 
As will be discussed later, FORTH requires the user to break up his 
programs and data into chunks of storage referred to as "blocks". 
Each block is identified by a unique number between 0-4895. 
One may 
list a FORTH block to see what its contents are: 
to list block 80 
on the terminal, execute 
80 
LIST 
This may be done for any block. 
If the FORTH system that you are using has a Centronix line printer attached 
to it then execute 
UTIL PRINTERS CEN 
180 
LOAD 
80 
86 
BLOCKPRINT 
to list blocks 80 through 86 on the line printer. 
Oct. 1979 

5. 
ARITHMETIC EXPRESSIONS 
5.1 
THE FORTH STACK 
One of the most unique features of FORTH is its use of a pushdown stack 
(referred to simply as the stack) to hOld operands and parameters. 
Some examples are the easiest way to describe the use of the stack: 
Consider the input line 
4 
3 
+ 
5 
Recall that FORTH will execute each word in the input string, one word 
at a time, from left to right (refer to Section 4.1). 
The following 
actions will take place as FORTH executes each of the six words: 
WORD FROM 
INPUT 
4 
3 
+ 
5 
Feb. 1977 
ACTION 
FORTH interprets this word as a number 
and pushes its value onto the stack 
-----> 
FORTH interprets this word as a 
number and pushes its value onto 
the stack 
-----> 
This word is the arithmetic "addition" 
operator - it expects two numbers to 
be in the top two positions on the 
stack and these two numbers are added 
together. 
The two operands are then 
replaced on the stack by the result 
-----> 
FORTH interprests this word as a number 
and pushes its value onto the stack 
-----> 
CONTENTS OF 
STACK 
3 
4 
5 
7 
5-1 

5-2 
WORD FROM 
INPUT 
ACTION 
CONTENTS OF 
STACK 
This word is the arithmetic "subtraction" 
operator - it expects two numbers to be 
in the top two positions on the stack and 
the number on top is subtracted from the 
number below. 
The two operands are then 
replaced on the stack by the result 
-----> 
This word simply removes the top number 
from the stack and prints the number 
on the terminal 
-----> 
stack empty 
Two terms were introduced in the above example: 
push and pop. 
To push 
a number onto the stack is to place the number at the top of the stack. 
To pop a number from the stack is to remove the top number from the stack. 
The general rules of FORTH's stack manipulation are: 
1) 
Any number to be placed on the stack must be pushed onto the top 
position on the stack. 
Any number to be removed from the stack 
must reside at the top of the stack. 
2) 
Arithmetic operators expect their operands to be in the top positi0ns 
of the stack. 
After completion of the arithmetic operation the 
operands are popped from the stack and the result is pushed onto 
the stack. 
3) 
General words that operate on numbers residing on the stack (such as 
the word 
in the above example to print the top number on the 
stack) 
remove from the stack the number operated on. 
This means, 
Feb. 1977 

for example, that the number printed is removed from the stack 
(as occurred in the above example). 
It should be obvious that the size of the stack is dynamic, that is, it 
changes continually. 
One of the easiest ways to understand what operation 
a sequence of numbers and operators performs is to keep track of the 
contents of the stack. 
For example, the result of the input line 
64* 53* 
is seen to be 9, from the following stack diagrams: 
* 
empty 
6 
4 
15 
r-----f 
&..-_2_4_LU 
Feb. 1977 
4 
5 
6 
24 
* 
5 
empty 
3 
5 
24 
3 
5-3 

5.2 
INFIX/POLISH NOTATION 
5-4 
The standard representation of a mathematical expression that one is 
accustomed to (from programming languages such as Fortran, Algol, etc.) 
is referred to as infix notation. 
Infix notation requires that an 
operator be preceded and followed by the two operands that it is to 
process (assume we are dealing only with binary operators such as 
+, -, * and I). 
One limitation of infix notation is that one must 
specify a heirarchy of precedence among the operators in order to 
unambiguously handle expressions such as: 
2 
+ 3 * 4 
Does th i s denote "2 plus the product of 3 and 4" or 114 times the sum of 
2 plus 3"7 
(Fortran would use the first interpretation). 
One can 
further complicate the translator of these mathematical expressions by 
introducing parentheses to explicitly denote the desired ordering of 
an expression. 
One could then write the above example as either 
2 
+ 
(3 
,~ 
4) 
---> 
14 
(2 
+ 3) * 4 
---> 
20 
depending on the desired meaning. 
A completely unambiguous representation of the above example may be 
written in Polish-postfix notation (also referred to as parentheses-free 
notation): 
Here the operators follow the operand (hence the adjective "postfix") 
and the expression may be easily evaluated from left-to-right with the 
aid of FORTHls stack as follows: 
Feb. 1977 

WORD 
2 
3 
+ 
* 
Feb. 1977 
ACTION REQUIRED 
number, push it onto the stack. 
number, push it onto the stack. 
operator, take two numbers on 
top of stack, add them together, 
delete the top two numbers on 
stack and replace with the 
result. 
number, push it onto the stack. 
operator, take two numbers on 
top of stack, mUltiply them 
together, delete the top two 
numbers on stack and replace 
with result. 
CONTENTS OF STAC K 
2 
3 
2 
5 
5 
20 
5-5 

5-6 
For completeness it should be noted in passing that one may find references 
to Polish-prefix notation. 
In this case the operators precede the 
operands and the notation is then evaluated from right-to-left. 
Polish-
prefix and Polish-postfix are basically identical and it is usually a 
matter of preference if the expression is to be evaluated left-to-right 
or right-to-left, however Polish-postfix is the more prevalent. 
The 
above example in Polish-prefix would be 
* 5 + 
2 3 
For the trivia minded it is mentioned that these notations were originally 
developed by the Polish mathematician Lukasiewicz. 
The main advantage of Polish notation over infix notation is the 
unambiguity in the representation of an expression. 
The conversion of 
an expression from infix to Polish (as done, for example, by a Fortran 
compiler) requires some additional processing. 
The Polish-postfix 
notation employed by FORTH transfers this conversion process from the 
FORTH system to the user. 
Another reason for the use of Polish notation 
in FORTH is that the stack (which is basic to all FORTH operations) is a 
natural way to interpret a Polish expression. 
Note that the non-commutative operators (subtraction and division) are 
evaluated in a manner such that the first number (the one preceding the 
operator) is the second number on the stack and the second number (the 
one following the operator) is the top number on the stack. 
This allows 
one to write the expression from left-to-right in the natural manner. 
For example: 
5 2 
94/ 
denotes 
denotes 
(5-2) 
(9/4) 
Feb. 1977 

EXERCISES - CHAPTER 5 
1) 
Evaluate the following expression at a FORTH terminal and print the 
result using the 
word (this use of a FORTH terminal could be 
referred to as the desk-calculator mode): 
1 + 2*(3 + 4*(5 + 6*(7») 
Diagram the contents of the stack after each word is executed. 
2) 
Evaluate the following expression at a FORTH terminal and print 
the result: 
Feb. 1977 
(1 + 2) 
+ 
(3 * 4) 
(9 / 3) 
(7 ,'t 8) 
Diagram the contents of the stack after each word is executed. 
5-7 

6. 
THE FORTH DICTIONARY 
Whenever you define a word in FORTH, regardless of the purpose of the 
word (whether the word is a variable that contains integer values, 
whether the word is a sequence of instructions to execute, etc.) the 
word is entered into the dictionary. 
Loading a program into core simply 
consists of entering all the words defined in the program (to perform 
whatever functions the program is to perform) into the dictionary. 
The 
loading of basic FORTH into core (Chapter 3) 
is simply entering the words provided by basic FORTH into the dictionary. 
Every word in the dictionary is identified by the first three characters 
of the word along with the count of the total number of characters in 
the word. 
Consider 
WORD 
THt::'''tAl 
X 
+ 
§z 
THE'TA2 
lSUM 
2S1MJ1 
the following examples: 
FIRST THREE CHARACTERS 
LENGTH 
THE 
6 
X 
t 
+ 
§ Z 
2 
T H E 
6 
1 S U 
4 
2 S U 
4 
Note that the words 
THETAl and 
THETA2 have the same count and fi rst 
three characters - this means these two words are indistinguishable :n 
the dictionary. 
FORTH does not consider this form of redefinition an 
error and in fact won't even tell you about it. 
To avoid redefinItions 
of this sort you should make your variable names unique in the first 
three character pos i t ions (note that 
lSU'M and 
2SUM wi 11 be 
distinguishable in the dictionary since the first three characters of 
both words are different). 
Oct. 1979 
6-1 

6-2 
There is no fixed size for an entry in the dictionary, however each 
entry does require a minimum of 5 words. 
In order for FORTH to be able 
to find its way through the dictionary, a dictionary chain is built 
with each entry pointing to the previous entry. 
Assume that basic FORTH 
has been loaded into core and the user then enters each word in the 
above example into the dictionary. 
After entering the word 
THETAl 
the dictionary would appear as: 
dictionary pointer 
(Ill ink ") po i n tin g 
from the entry for 
THET A 1 
to the 
previous entry 
in the dictionary. 
basic 
FORTH 
} 
dictionary entry 
for 
THETA 1 
dictionary entries 
comprising basic 
FORTH 
Similarly, if the words are entered in the sequence shown we will 
obtain a dictionary structure of the form: 
Feb. 1977 

Start of dictionary ~ 
) 
\ 
basic 
FORTH 
Feb. 1977 
dictionary entry for 
2SUM 
dictionary entry for 
lSUM 
dictionary entry for 
THETA2 
dictionary entry for 
liZ 
dictionary entry for 
+ 
dictionary entry for 
X 
dictionary entry for 
THETAl 
dictionary entries comprising 
basic FORTH 
6-3 

6-4 
Note that in this discussion of the dictionary we do not care what 
function each word' performs or how the word was entered into the 
dictionary (whether it is a variable, a sequence of instructions, 
etc.) but simply in the structure of the dictionary. 
It is very 
important to note that each word is identified in the dictionary 
simply by its first three characters and count. 
When the dictionary 
is being searched for a specific word (say for example that you enter 
the word 
THETA5 on the terminal and FORTH must then search the 
dictionary to locate the entry for THETA5 in order for the word 
to be executed) the search starts with the last word entered and 
proceeds down the dictionary chain. 
When searching for 
THETA5, 
FORTH starts with the entry for 
2SUM. then proceeds to the entry 
for lSUM, then proceeds to the entry for THETA2 and this entry 
is a match since the first three characters and count are identical 
wi th the first three characters and count of 
THETA5. 
Hopefu11 y 
this is what the user wanted! 
It should be obvious that after 
THETA2 is entered into the dictionary the entry for THETAl is 
inaccessible. 
Feb. 1977 

EXERCISES - CHAPTER 6 
1) 
Assume that the words below are entered into the dictionary in 
the following order: 
a) 
b) 
c) 
d) 
e) 
f) 
Feb. 1977 
Y+X 
X+Y 
XANG 
X+Y2 
SINX 
YANG 
SINY 
SlN~ 
XANT 
X+Y/l. 
Which entry 
Which entry 
Which entry 
Which entry 
Which entry 
Which entry 
is executE'd 
is executed 
is executed 
is executed 
is executed 
is executed 
if 
SINX 
is entered? 
if 
X+Y 
is entered? 
if 
XANT 
is entered? 
if 
XANG 
is entered? 
if 
SINo 
is entered? 
if 
y+xx 
is entered? 
6-5 

7. 
DATA STRUCTURES 
All of the examples in the previous chapters have dealt with numbers 
(not variables) and only with integer values. 
This chapter describes 
the facilities provided to define and use variables along with the 
different data structures provided by FORTH. 
7. 1 
INTEGERS 
An integer in Varian FORTH must be in the range 
-32,768 
< 
integer < 32,767 
and occupies a single computer word. 
Integers are also referred to as 
"single-word integers" and any use of the unqualified term "integer" 
implies a single-word integer. 
There are two declarations that are available to declare either an 
integer variable or an integer constant: 
<initial-value> VARIABLE <:name> 
<initial-value> 
CON5T~NT <name> 
Using either of the above declarations causes a new dictionary entry to 
be created and the entry is identified by the first three characters and 
count of <name>. 
The difference in the above two declarations comes 
when the word (identified by <name» 
is executed: 
when a word defined 
as a CON'STl6:NT is executed the vaZue of the constant is pushed ont0 the 
stack; when a word defined as a VARIABLE is executed the address of 
the vaZue of the integer is pushed onto the stack. 
Once the address of 
the value of an integer Is on the stack the value may be pushed onto the 
stack or a new value may be stored by using the load operator (the 
at-sign w ) or the store operator (the exclamation-point, !). As 
confusing as this appears some examples should hopefully make it clear: 
Oct. 1975 
7-1 

7-2 
5 
CONSTANT 
X 
180 
CONSTANT 
REV 
Executing the word 
X pushes the number 5 onto the stack. 
Similarly, 
executing the word REV 
pushes the number 180 onto the stack. 
o 
VARIABLE 
ZERO 
-2 
VARIABLE 
DELTAX 
Executing the word 
ZERO pushes the address of the integer's value onto 
the stack and if the word 
@ is then executed the number 0 is pushed 
onto the stack (replacing the address). 
That is 
ZERO 
@ 
DELTAX 
@ 
pushes 
0 onto the 
pushes -2 onto the 
stack, 
stack. 
In order to change the value of ZERO to -1 the sequence: 
-1 
ZE~O 
stores -1 as the va 1 ue of ZERO. 
Similarly to change the value of DEL-TAX to +2: 
+2 
DEL TAX 
stores +2 as the value of DELTAX. 
To store a new value in a word defined as a 
CONSTANT 
the sequence 
4 
REV 
stores 4 as the value of REN. 
Simi larly, 
-99 
X 
stores -99 as the value of X. 
Subsequent execut i on of the word REV 
woul d push the number 4 onto the 
stack and similarly executing 
X would push -99 onto the stack. 
Oct. 1979 

Thus we have two methods to define a word that is to contain an integer 
value and for each method the integer value may be pushed onto the stack 
or a new value may be stored as its value. 
This may be summarized as: 
to push current 
to store top of 
value onto stack 
stack as new value 
CONSTANT 
<name> 
• <name> 
• 
• 
<name> 
@ 
<name> 
• · 
VARIABLE 
These two fairly similar definitions may seem somewhat superfluous since 
each can perform the same function, namely pushing the value of an 
integer variable onto the stack and storing the top number on the stack 
as the variable's new value. 
The usefulness of each will become more 
apparent when colon definitions are introduced, however you can still 
note the fact that if the value of an integer variable will be 
referenc~d 
(i.e. - its value pushed onto the stack) many more times than a new value 
is to be stored in the variable, then it requires fewer words to push the 
value onto the stack for a CONSTANT than for a VARIABLE. 
This is so 
because to push the value of a 
CONSTANT onto the stack you simply 
execute the word itself. 
To push the value of a VARIABLE onto the 
stack you must execute both the word and then the load operator, 
@. 
It is worthwhile now to consider the interaction of the stack in 
executing a sequence of loads and stores. 
Consider the following four 
1 i nes of input: 
1 
VARIABLE 
X 
8 
CONSTANT 
Y 
X 
@ 
Y 
+ 
Y. 
Y 
Oct. 1979 
7-3 

WORD FROM 
INPUT 
1 
VARIABLE 
8 
CONSTANT 
ACTION 
FORTH interprets this word as a number and pushes 
its value onto the stack 
-----> 
50RTH looks this word up in the dictionary and 
then executes the word. 
When this word is 
executed it will take the next word of input 
(X) 
and enter it into the dictionary. 
The to~ number 
on the stack (1) is used as the initial value for 
the dictionary entry for 
X. 
After popping the 1 
from the stack, the stack will be empty 
-----> 
FORTH interprets this word as a number and pushes 
its value onto the stack 
-----> 
FORTH looks this word up in the dictionary and 
then executes the word. 
When this word is 
executed it will take the next word of input 
(Y) 
and enter it tnto the dictionary. 
The 
top number on the stack (8) is used as the 
initial value for the dictionary entry for 
Y. 
After popping the 8 from the stack, the stack 
will be empty 
-----> 
X 
FORTH looks this word up in the dictionary and 
then executes the word. 
When this word is 
executed, since it was defined as a 
VARIABLE. 
the address of the value of X is pushed onto 
the stack 
-----> 
CONTENTS 
OF STACK 
empty 
empty 
7-4 
Oc t. 1979 

WORD FROM 
INPUT 
y 
+ 
Feb. 1977 
ACTION 
FORTH looks this word up in the dictionary and then 
executes the word. 
When this word is executed it 
takes the the top value on the stack (which must be 
the address of a variable's value) and uses this 
address to push onto the stack the current value 
of the variable 
-----> 
FORTH looks this word up in the dictionary and then 
executes the word. 
When this word is executed, 
since it was defined as a CONSTANT, 
the value 
of the variable is pushed onto the stack 
-----> 
CONTENTS 
OF STACK 
8 
FORTH looks this word up in the dictionary and then 
executes the word. 
When this word is executed it 
will add together the to~ two numbers on the stack __ >1 
and then replace these two numbers with their sum 
9 
'--------' 
FORTH looks this word up in the dictionary and then 
executes the word. 
When this word is executed it 
will take the next word of input 
(Y) and look 
this new word up in the dictionary. 
The address 
of the value of this new word is then pushed onto 
the stack 
-----> 
FORTH looks this word up in the dictionary and then 
executes the word. 
When this word is executed it 
expects an address of a variables value to be on top 
of the stack and a number to be below on the stack. 
The value of the variable is set to the number and 
then both the address and the number are popped 
from the stack 
-----> 
address of 
value of Y 
9 
empty 
7-5 

WORD FROM 
INPUT 
ACTION 
CONTENTS 
OF STACK 
y 
FORTH looks this word up in the dictionary and 
then executes the word. 
When this word is 
executed, since it was defined as a 
CONSTANT, 
the value of the variable is pushed onto the 
stack 
-----> 
FORTH looks this word up in the dictionary and then 
executes the word. 
When this word is executed it 
prints the top number on the stack and then pops 
the number from the stack 
-----> 
empty 
The concepts presented in this section are fundamental to understanding 
the remainder of the chapter and the reader is advised to work the 
first two exercises at the end of the chapter before preceding on. 
7.2 
DOUBLE-WORD INTEGERS 
7-6 
There are occasions when the single-word integer (described in the 
previous section) does not contain enough precision for a certain 
application. 
In these cases a double-word integer may be used. 
In Varian FORTH the range is 
-1,073,741,824 < double-word integer < 1,073,741,823 
and each double-word integer occupies two consecutive words of memory 
and will occupy two words on the stack. 
There are two words that are available to declare either a double-word 
integer variable or a double-word integer constant: 
<initial-value> 
2VARIABLE 
<name> 
<initial-value> 
2CONSTANT 
<name> 
Oct. 1979 

Using either of the above declarations causes a new dictionary entry to 
be created and the entry is identified by the first three characters and 
count of <name>. 
The difference in the above declarations comes when 
the word (identified by <name» 
is executed - when a word defined as a 
aCONSTANT 
is executed the 2-word va'lue of the double-word constant is 
pushed onto the top two words of the stack; when a word defined as a 
2VAR I ABLE 
is executed the address _of the val;ue of the 
double-word integer is pushed onto the stack. 
Once the address of the 
value of a double-word integer is on the stack the 2-word value may be 
pushed onto the top two words of the stack by using the double-word 
load operator 
(D@). 
Similarly the double-word store operator 
(0:) 
may be used to store a new 2-word value in a double-word integer. 
Before giving examples of the above declarations it must be noted that 
a number must be appended by a comma with no numbers appearing-
to the right of the comma if the number is to be interpreted by 
FORTH as a double-word integer value. 
For example, the sequence 
o , 
25 , 
100000 , 
correctly enters three double-word integers whose values are 0, 25 and 
100,000. The following is an error 
DPREC 
10,0 
Oct. 1979 
7-7 

7-8 
Since the digit zero appears to the right of the comma, the 
number is not interpreted as 10 but rather as lOa! 
This required usage 
of the comma probablY seems, unnecessartly complex, however, FORTH. 
must have a way of uniquely separating single-word integers from double-
word integers and the comma convention is the method used. 
Consider the declaration 
99. 
2VARIABLE 
XX 
which defines a double-word integer variable named 
XX, with an 
initial value of 99. 
The sequence 
XX 
DOl 
pushes the current 2-word value of 
XX 
onto the top two words of the 
stack. 
The sequence 
500001, 
XX 
D! 
stores 500001 as the new value of 
XX. 
Now consider the declaration 
1, 
2CONST ANT 
D 1 
which defines a double-word integer constant named 
D1, 
with an initial 
value of 1. 
The sequence 
D1 
pushes the 2-word va I ue of 
D 1 
onto the top two words of the stack. 
To store 100 as the new va I ue of 
D 1 
the sequence 
100 , 
D1 
D! 
is required. 
Summarizing the results of the previous section and the 
results of this sections yields the table: 
Oct. 1979 

VARIABLE 
CONSTANT 
2VARIABLE 
2 CONSTANT 
to push current 
value onto stack 
<name> 
@ 
<name> 
<name> 
D@ 
<name> 
to store top value 
on stack as varlable1s 
new value 
<name> 
I . 
, <name> , . 
<name> D: 
, <name> D: 
va 1 ue OCCUp i es 
one word 
on stack 
va 1 ue OCCup i es 
two words 
on stack 
Now consider the interaction of the stack in executing a sequence of 
doub 1 e-word loads and stores, us i ng the va r i ab 1 es 
xx 
and 
D 1 dec 1 a red 
above. 
Assume the line of input is as follows: 
XX 
D@ 
D 1 
D+ 
D1 
D. 
D1 
D! 
(The word 
D+ 
is the double-word addition operator, which adds together 
two double-word integer values, similar to the single-word addition 
operator +. 
We also have the double-word subtraction operator D- ). 
Oct. 1979 
7-9 

WORD FROM 
INPUT 
xx 
O&'l 
01 
0+ 
O! 
01 
o. 
7-10 
ACTION 
Push address of 2-word value 
onto stack 
----> 
Take address on top of stack and 
replace it with 2-word value 
Push the 2-word value onto 
stack 
----> 
----> 
Add together the two ~ouble-word 
integer values on top of the 
stack and then push the result ----> 
onto the stack 
Take the next word of input 
(01) 
and push the address of its value 
onto the stack 
----> 
Take the address on top of the stack 
and store the 2-word integer value 
beneath the address at the address, 
then pop the address and the 2-word 
value off the stack 
-----> 
Push the 2-word value onto the 
stack 
----> 
Print the 2-word integer value on 
top of the stack, then pop the 
2-word value off the stack 
----> 
CONTENTS 
OF STACK 
address of 
value of xx 
99 
-
-
99 
-
100 
-
address of 
value of 01 
I-
100 -
empty 
~ 
100 -
empty 
Feb. 1977 

The words in FORTH to operate on single-word integers (the words 
VARIABLE 
CONSTANT 
+ 
* 
/ 
etc.) 
are all defined 
within basic FORTH and therefore will be in the dictionary after the 
user loads bas i c FORTH 
(Chapter 3). 
These words are cons i dered essent i a 1 
to any FORTH program and are therefore always available. 
The words used 
to operate on doub Ie-word integers (the words 
2VAR I ABLE 
2CONSTANT 
D+ 
D-
D. 
etc.) are considered optional and are not automatically 
entered into the dictionary with basic FORTH. 
Instead, if you wish to 
use double-word integers you must specifically load the appropriate 
words into the dictionary by executing the word 
USER. 
This will load into core (i .e. - enter into the dictionary) 
the double-word integer routines, the floating-point routines and other 
miscellaneous routines to be described later. 
7.3 
FLOATING-POINT NUMBERS 
The data structures presented in the previous sections (single-word 
integer and double-word integer) are exact representations of integer 
values. 
This means that arithmetic performed on single-word integers 
or double-word integers yields exact answers: 
2 * 3 is exactly 6, 
not 5.999··· ; 5 + 9 is exactly 14, not 14.000001. 
As long as the 
user stays within the range of the data structure (which for a double-
word integer is -1,073,741,824 to +1,073,741,823) this guarantee of 
exactness for integer arithmetic holds. 
The obvious drawback in using 
integers is the limited range that is available - in Varian FORTH a 
double-word integer corresponds to just over 9 digits of precision. 
For some applications (noteably financial programming with the COBOL 
language) the exactness of integer arithmetic is a requisite and the 
data structures being represented will never exceed approximately 
15-20 digits, hence exact arithmetic is used (using a slight variation 
of integer representation). 
Oct. 1979 
7-11 

7-12 
Scientific programming, on the other hand, requires a data structure 
that provides a far greater range of values so that very large numbers 
(for example, Avagadrols number N = 6.02250 x 1023) and very small 
numbers (for example, Planck1s constant h = 1.0545 x 10-27 ) can both 
be stored. 
Additionally, scientific programming does not require that 
these numbers be represented exactly but only that a specified number 
of digits of accuracy be maintained. 
The data structure provided by 
most programming languages (and by FORTH) for scientific computation 
is floating-point. 
A floating-point number is stored in the computer 
as a fraction times an exponent, similar to standard scientific 
notation. 
In Varian FORTH a floating-point number is stored in three 
consecutive words of memory and each floating-point number requires 
three words on the stack. 
The fraction will be in the range 
0.0 
< 
lfractionl 
< 
1.0 
and provides approximately 9 digits of accuracy. 
The exponent will be 
in the range 
-32,768 
< exponent 
< 32,767 
and denotes the power of 2 that the fraction is raised to, that is 
fl
· 
. 
b 
fract·lon * 2exponent 
oatlng-polnt num er = 
. 
In using floating-point numbers one is sacrificing exactness for 
greater range. 
(If one were to store both Avagadrols number and 
Plank1s constant exactly, a computer word of approximately 100 bits 
would be required!) 
Feb. 1977 

There are two words that are available to declare either a floating-
point variable or a floating-point constant: 
< in i t i a l-va 1 ue> 
REAL 
< name> 
<initial-value> 
FCONSTANT 
<name> 
Using either of the above declarations causes a new dictionary entry to 
be created and the entry is identified by the first three characters 
and count of <name>. 
The difference in the above two declarations comes 
when the word (identified by <name» 
is executed - when a word defined 
as an 
FCONSTANT 
is executed the 3-word value of the floating-point 
constant is pushed onto the stack; when a word defined as a 
REAL 
is 
executed the address of the 3-word value of the floating-point variable 
is pushed onto the stack. 
Once the address of the 3-word value of a 
floating-point variable is on the stack the floating-point load operator 
(F@) 
or the floating-point store operator 
(F!) 
may be used. 
A floating-point number must contain a decimal point and may optionally 
contain digits to the right of the decimal point. 
O:ct. 1979 
7-13 

7-14 
Consider the following examples: 
3.14159 
-+ 
.314159 * 
1 0 1 
200. 1 
-+ 
.2001 * 
10 3 
fl oat i ng-po i nt 
1.000 
...-
. 1 * 
10 1 
numbers 
.27 
...-
.27 * 
10° 
1 , 
-+ 
} 
1 ,0 
-+ 
10 
double-word 
1,50 
...-
150 
integers 
1.0000 
• 1 * 
10 1 
} 
float i ng-po i nt 
number 
Consider the declaration 
180.0 
REAL 
THETA 
which defines a floating-point variable named 
THETA, 
with an initial 
value of 180.0. 
The sequence 
THETA 
Fiil 
Oct. 1979 

pushes the current 3-word value of 
of the stack. 
The sequence 
THETA 
onto the top three words 
90.000 
THETA 
F! 
stores 90. as the new value of 
THETA. 
Now consider the declaration 
3.14 
FCONSTANT 
PI 
which defines a floating point constant named 
value of 3.14. 
The sequence 
PI 
with an initial 
PI 
pushes the 3-word value of 
PI 
onto the top three words of the stack. 
To store 3.14159265 as the new value of 
PI 
(note that this new value 
uses the full 9-digits of accuracy provided by FORTH for a floating-
point number) the sequence 
3.14159265 
PI 
F! 
is required. 
Summarizing the results of the previous two sections and 
the results of this section yields the table: 
VARIABLE 
CONSTANT 
2VARIABLE 
ZCONSTANT 
REAL 
FCONSTANT 
Oct. 1979 
to push current 
value onto stack 
<name> 
W 
<name> 
<name> 
Ow 
<name> 
<name> 
Fw 
<name> 
to store top value 
on stack as variable's 
new value 
<name> 
• · 
• <name> 
• · 
<name> o! 
I 
<name> o! 
<name> F! 
I 
<name> F! 
7-15 

Now consider the input line 
PI 
THETA Flil 
F* 
THETA F: 
THETA Flil 
F. 
and the interaction of the stack. 
(The word 
F* 
is the floating-point 
multipl ication operator, simi lar to the word * 
We also have the words 
F+ 
F-
and 
FI 
for floating-point addition, subtraction and 
division. 
The word 
F. 
the stack.) 
prints the floating_point number on top of 
WORD FROM 
INPUT 
PI 
THETA 
ACTION 
Push the 3-word value onto the stack 
Push the address of the 3-word value 
onto the stack 
Flil 
Take the address on top of the stack 
and replace it with the 3-word 
value 
7-16 
-----> 
-----> 
-----> 
CONTENTS 
OF STACK 
-
-
3.14 
,..-
-
address of 
va 1 ue of THETA 
-
-
3. 14 
-
-
-
180.0 
-
-
-
3.14 
-
-
Feb. 1977 

WORD FROM 
INPUT 
F* 
THETA 
F~ 
THETA 
F@ 
F. 
Feb. 1977 
ACTION 
CONTENTS 
OF STAC K 
I-
-
Multiply together the top two floatlng-
point numbers on the stack and then 
push the result onto the stack 
-----> 
565.2 
Push the address of the 3-word value 
onto the stack 
-----> 
Take the address on top of the stack and 
store the 3-word value beneath the 
address at the address, then pop the 
address and the 3-word value off the stack 
the stack 
Push the address of the 3-word value 
onto the stack 
Take the address on top of the stack and 
replace it with the 3-word value 
Print the floating-point number on top 
of the stack, then pop the 3-word value 
off the stack 
-----> 
-----> 
-----> 
-----> 
f-
-
address of 
Iva I ue of THETA 
..... 
-
565.2 
f-
-
empty 
address of 
Iva I ue of THETA 
-
565.2 
-
empty 
7-17 

Floating-point numbers may optionally be entered as a fraction times a 
power of ten (similar to the Fortran E format). 
The number 0.25 could 
be entered as any of the following; 
0.25 
0.25EO 
25.E-2 
2500.0E-4 
.0000250E4 
7.4 
CONVERSIONS BETWEEN DATA STRUCTURES 
7-18 
Frequently the need arises to convert a number that is on the stack to 
another data type. 
For example, you may want to convert a single-word 
integer to a floating-point number, a floating-point number to a 
double-word integer and so on. 
The following table summarizes the 
words available to perform this conversion: 
name of 
word 
SFLOAT 
DFLOAT 
SFIX 
DFIX 
converts 
from 
-----> 
to 
single-word integer 
floating-point 
double-word integer 
floating-point 
floating-point 
single-word integer 
floating-point 
double-word integer 
notes 
(truncates) 
(truncates) 
Oct. 1979 

Consider the following examples: 
5 
SFLOAT 
F. 
will print 5.0 
765. 
DFLOAT 
F. 
wi 11 print 
765.0 
3.14159 
SFIX 
will print 
3 
1.999 
DFIX 
D. 
will print 1 
It is very important to remember that every conversion involves a 
change in the number of words of the stack used by the number. 
SFLOAT 
converts a single-word integer to a 3-word floating-point number: 
sing Ie-word {I 
i n tege r 
1.. _____ 
---' 
-
5 
-
5.0 
-
3-word floating-
point number 
Simi larly 
DFIX 
converts a 3-word floating-point number to a 
double-word integer: 
3-word 
floating-
point 
number 
I-
-
3.14159 
i-
-
-
3 
-
} 
doub Ie-word 
integer 
There are no specific words provided to convert a single-word integer to 
a double-word integer or vice-versa and since these two conversions are 
somewhat tricky (requiring a knowledge of the internal storage represen-
tation of the data types) their discussion is deferred until later. 
Oct. 1979 
7-19 

7.5 
LOGICAL VALUES AND LOGICAL EXPRESSIONS 
7-20 
There is no specific data type named logical in FORTH, instead one uses 
a single-word integer as a logical value and interprets the value as 
follows: 
zero valued integer 
---> 
FALSE 
non-zero valued integer 
---> 
TRUE 
Thus whenever FORTH calls for a <logical-condition> one must provide a 
single-word integer value. 
The use of these logical conditions should 
become clear in the ensuing chapters. 
Additionally, one may combine more than one <logical-condition> to form 
a logical expression using the following words: 
AND 
Forms the logical-AND of the two single-word 
integer values (i .e. - logical values) on 
top of the stack. 
The logical-AND is 
defined as follows: 
true 
true 
AND 
true 
false 
AND 
false true 
AND 
false false 
AND 
---> 
---> 
---> 
---> 
true 
fa 1 se 
fal se 
false 
(the result is true if both of the operands are true). 
OR 
Forms the inclusive-OR of the two single-word integer 
values (i .e. - logical values) on top of the stack. 
The inclusive-OR is defined as follows: 
true 
true 
OR 
---> 
true 
true 
false 
OR 
---> 
true 
false 
true 
OR 
---> 
true 
false 
false 
OR 
---> 
false 
(the result is true if either of the operands is true) . 
Feb. 1977 

Oct. 1979 
XOR 
Forms the exclusive-OR of the two single-word integer 
values (i.e. - logical values) on top of the stack. 
The exclusive-OR is defined as follows: 
true 
true 
XOR 
---> 
fa1 se 
true 
false 
XOR 
---> 
true 
false 
true 
XOR 
---> 
true 
false 
false 
XOR 
---> 
false 
(the result is true if onZy one of the operands is true). 
7-21 

7.6 
ADDITIONAL NUMERIC CONVERSIONS 
All of the examples in this primer have presented the numbers in base 
ten, decimal. 
Any base may be used for numeric input and the VARIABLE 
BASE 
specifies the current base to be used for number conversion. 
Three 
W'Ords are predefined, 
DECIMAL 
OCTAL and 
HEX which set base to 10, 
8 and 16 respectively. 
Furthermore, if the current base is less than or 
equal to ten (decimal or octal) and the last character of a number is 
a 
B 
then the number is converted as an octal number. 
For example, 
20B 
equals 16 10 
Since B is a legal hexadecimal digit, if the base is greater than ten 
a trailing B will not force octal conversion. 
If one wishes to force 
octal conversion of a double-word integer then the B must follow the 
comma: 
20,8 
is a double-word integer 1610 . 
7-22 
Oct. 1979 

One of FORTHls truly unique features is its acceptance of sexagesimal 
(base sixty) input. 
This facilitates the input of angles (in degrees, 
minutes, seconds - such as 8:58:05) and times (in hours, minutes, 
seconds - such as 9:01:09). 
FORTH accomplishes this by allowing a 
colon to appear within any number and then converting the digit 
immediately following the colon using base 6. 
All digits following this- first-digit 
after the colon are converted according to the current base (i.e. -
decimal or octal, as explained above). 
For example, the 
number 
000100 
is interpreted as 100, while the number 
00:01 :00 
is interpreted as 60. 
This latter number could represent, 
for example, the time-of-day of one minute past midnight which equals 
60 seconds past midnight. 
Similarly, 
00:03:00 
is interpreted 
as 180. 
Hence, if the quantity being entered is a time, then the 
resulting value will represent the number of seconds past midnight. 
If the quantity is an angle, then the resulting value represents the 
number of seconds of angle. 
Additionally, if a floating-point number 
is used then a time may be specified as fractions of a second or an 
angle may be specified as fractions of a second. 
For example: 
12:00:01.5 
could represent the time of one and 
a half seconds past noon; also it 
could represent the angle 12° 00 1 01.5 11 • 
Note that since the digit following the colon is interpreted as base 6, 
this digit can only be 0 through 5. 
The number 
6:80 , for example, 
is illegal. 
This also means that the minutes and seconds of either an 
angle or a time must be entered as exactly two digits. 
The time of one 
minute past eight must be entered as either 
8:01:00 
or 
08:01;00 
and not as 
8:001:00 
or 
8:1:00 
Oct. 1979 
7-23 

The use of sexagesimal rotation in a number forces the number to be interpreted 
as a double-word integer unless the number contains a decimal point. 
For 
example 
7-24 
01:00 
01:00. 
01: 00 • 
double-word integer 
60 
double-word integer 60 
floating-point 
60.0 
Oct. 1979 

7.7 
VECTORS 
FORTH provides the ability to declare a vector of either integers, 
double-word integers or floating-point numbers. 
This data structure 
is similar to a one-dimensional array in Fortran. 
FORTH does not 
provide any multi-dimensional arrays. 
(However, given the structure 
of FORTH one could define new words to declare and access multi-
dimensional arrays. 
Unfortunately, this is beyond the scope of 
t his p rime r . ) 
To declare a vector of single-word integers one would execute 
<maximum-subscript> 
( ) D1 M 
<name> 
For example, the following defines a four element vector named 
X 
3 
()D1M 
X 
The four elements would be accessed by using the subscripts 0, 1, 2 
and 3 and a memory diagram might be 
element 
3 
element 
2 
element 
element 
0 
Note that the subscript starts at 0, therefore the number of elements 
equals <maximum-subscript> + 1. 
In order to access a single element one executes 
<subscript-value> 
<name> 
and, for example, the sequence 
3 
X 
Oct. 1979 
7-2 S 

7-26 
calculates the address of element 3. 
This address may be used just 
like the address of any integer value, for example 
1 
X 
(j) 
pushes the value of element 1 onto the stack. 
The sequence 
o 
X 
(j) 
3 
X 
takes the value of element 0 and puts it in element 3. 
Finally the 
sequence 
o X (j) 
1 X (j) 
+ 
2 X (j) 
+ 
3 X (j) 
+ 
forms the sum of all elements in the vector 
X. 
Similarly we may declare a vector of double-word integers 
<maximum-subscript> 
2( )DIM 
<name> 
and a vector of floating-point numbers 
<maximum-subscript> 
3( )DIM 
<name> 
The two sequences 
4 
2()DIM 
Y 
2 
3()DIM 
Z 
would declare a 5 element vector of double-word integers and a 
3 element vector of floating-point numbers. 
Their memory represen-
tation could be 
O~t. 1979 

~ 
-
element 4 
I-
-
element 2 
-
-
~ 
-
element 3 
-
-
element 1 
I-
-
element 2 
-
-
I-
-
element 1 
~ 
-
element 0 
i-
-
I-
-
element 0 
To obtain the address of a specific element one executes 
<subscript-value> 
<name> 
For example 
4 
Y 
O@ 
DFLOAT 
2 
Z 
F! 
will push element 4 of the vector 
Y onto the stack, convert it 
from a double-word integer to a floating-point number and store this 
floating-point value in element 2 of Z. 
Naturally there is no 
requirement that the <subscript-value> be a numeric constant and 
the following is perfectly valid: 
o VARIABLE 
INDEX 
2 
INDEX 
INDEX 
@ 
X 
@ 
Oct. 1979 
7-27 

EXERCISES - CHAPTER 7 
1) 
Define a VARIABLE 
I 
(with initial value 5) and a 
CONSTANT J 
(with initial value 100) and calculate the following series of 
expressions: 
I = I + 1 
J = I * 5 
PR I NT 
I, J 
I = (J * J) -
10 
J = (I / 
J) + 2 
PRINT 
I, J 
2) 
Define a VARIABLE 
A. 
(with initial value 20) and a 
CONSTANT B 
(with initial value 32) then calculate the following expression: 
B = A + 
B 
A 
+_.a.:.B_ 
+ 8. 
A -
1 
B 
Then pr i nt the va I ue that was stored in 
B. 
3) 
Define a 
2'>VARIABLE 
II 
(with initial value 10) and 
a 
DCONSTANT JJ 
(with initial value 30) and calculate the 
following expressions: 
I I = JJ + 1 
JJ = JJ -
I I 
PRINT 
I I , JJ 
I I = I I 
+ JJ + 101 
JJ = JJ + II 
PRINT 
I I , JJ 
7-28 
Oct. 1979 

4) 
Code the expression 
A = B * (C + D) 
in two ways, using the fact that addition is a distributive operator 
(f.e. -
b * (c + d) = b * c + b * d). 
Assume that 
A 
is a 
CONSTANT, initial value 
B 
is a 
VARIABLE, 
initial value 5 
C 
is a 
CONSTANT, initial value 8 
D 
is a 
VARIABLE, 
initial value 25. 
Confirm that both methods generate the same answer. 
5) 
Code the expression 
A = B + C + D + E 
in two ways, using the fact that addition is a commutative operator 
(i • e. -b+c+d + e = e + d + C + b). 
Assume that 
A 
is a 
2CONSTANT, 
initial value 3 
B 
is a 
Z VARIABLE 
in it i a I value 5 
C 
is a 
2CONSTANT, 
initial value 
7 
D 
is a 
2 VARIABLE 
in it i a 1 value 11 
E 
is a 
2CONSTANT, 
ini t i al value 17. 
Confirm that both methods generate the same result. 
6) 
What expression do the following lines of FORTH code correspond to? 
7.0 
REAL 
A 
8.0 
REAL 
B 
1.0 
REAL 
C 
B Fm 
B Fm 
F* 
4.0 
A Fm 
F* 
C Fm 
F* 
F-
What value is obtained when the expression is evaluated7 
Where is this value stored7 
Oct. 1979 
7-29 

7) 
What is the largest time-of-day (counted in seconds) that may be 
stored in a single-word integer? 
In a double-word integer? 
8) 
Using the definitions 
9) 
5 VARIABLE 
I 
12 
CONSTANT 
J 
280. 2VARIABLE 
A 
257. 
2CONSTANT 
B 
1.325 
REAL 
X 
5.0 
FCONSTANT 
Y 
Calculate and print the value of the expression 
Y = 
Wi 11 the 
a) 
1 2 
b) 
1 0 
c) 
1 1 
d) 
0 0 
e) 
5 8 
f) 
1 2 
(I * X) /(J/Y) 
(A -
B) 
fo 110wi ng FORTH expressions 
+ 4 I 
AND 
AND 
OR 
I 
2 1 -
XOR 
2 -
OR 
be interpreted 
10) 
What will the following FORTH expression print? 
DECIMAL 
10 
OCTAL 
10 
DECIMAL 
7-30 
as true or false? 
Oct. 1979 

8. 
STACK OPERATIONS 
All of the stack operations up to this point have involved pushing a 
number onto the top of the stack, popping a number off the top of the 
stack and performing arithmetic on the top two numbers on the stack. 
This chapter describes some additional operations that may be performed 
on the stack. 
8.1 
MANIPULATION WORDS 
Frequently one can "optimize" the evaluation of an arithmetic expression 
by intelligently using the stack to hold temporary results, rather than 
storing every temporary result in a variable. 
For example consider the 
declarations: 
4 
VARIABLE 
A 
18 VARIABLE 
B 
0 
VARIABLE 
X 
0 
VARIABLE 
Y 
and the subsequent evaluation of the expressions 
X = A + B 
Y = X + 1 
Using the methods described in this manual up to this point one would 
code this in FORTH as 
A @ 
B @ 
+ 
X 
X @ 
1 
+ 
Y 
which is perfectly correct and acceptable. 
Now assume we have available 
to use the word 
DUP 
which simply duplicates the single-word quantity 
on top of the stack. 
For example 
5 DUP 
Oct. 1979 
8-1 

8-2 
performs the following stack operations: 
5 
5 
5 
Similarly we have 
2DUP 
and 
3DUP 
which duplicate 2-word stack 
entities and 3-word stack entities: 
I-
25 
-
-
25 
-
I-
25 
-
25, 
2DUP 
-
-
2.718 
-
-
~ 
~ 
-
~ 
-
2.718 
2.718 
f-
-
r-
-
2.718 
3DUP 
Oct. 1979 

Note that the terms "single-word quantity", 112-word entity" and 
Ill"word entit/ I are used instead of "s ingle-word integer", "double-word 
integer" and "floating-point number ll to describe the stack entries 
being manipulated. 
This is because unlike the arithmetic operators, 
which expect the top entries on the stack to be a specific type of 
number, the stack manipulation words being described in this chapter 
do not care what internal form of data they are working on. 
The word 
DUP 
will gladly duplicate a single-word integer or a 1-word address. 
Simi larly the word 
2DUP 
could be used to duplicate either a 
double-word integer or two single-word integers, as follows: 
5 
2 
5 
5 
2 
2 
2 
5 
2DUP 
The stack is a general purpose IItool ll and as such a variety of different 
entities may reside on the stack for totally different purposes. 
It is 
important to always know, when writing a program, what quantities are on 
the stack and what format these quantities are in (number, address, etc.). 
FORTH will gladly allow you to perform erroneous operations on the wrong 
type of data structure (such as taking the square root of a single-~Jord 
address, thinking the address was really a single-word integer) although 
the results are usually disastrous (and sometimes hard to find). 
Getting back to the original example we may alternately code 
Feb. 1977 
x = A + 8 
Y = X + 1 
8-3 

A 
X 
as 
A @ 
B @ 
+ 
DUP 
X 
1 
+ 
y 
What we have done is duplicate the quantity being stored in 
X 
(namely 
A + S) 
and then after storing one copy of this result in 
X we use 
the second copy to compute 
Y = X + 1. 
Th is saves hav ing to load 
X 
from core back onto the stack in order to calculate 
Y = X + 1. 
The sequence of stack operations is as follows: 
add ress of 
18 
22 
value of B 
address of ~ 
4 
4 ~ 
22 
value of A 
@ 
B 
+ 
DUP 
address of 
value of X 
8-4 
22 
address of 
~ 
value of Y 
22 
22 
23 
empty 
22 
1 
+ 
Y 
Although this example may seem somewhat trivial (so what if we save a 
single load?) on some computers stack manipulations may be many times 
faster than core-to-stack or stack-to-core operations so that it can 
really be beneficial to retain values on the stack whenever possible. 
One must not go overboard and try to keep everything on the stack at 
all times or you will soon lose track of just what is on the stack. 
Feb. 1977 

A summary of the available stack operations is provided in table 8.1 
and examples of the important operators are given below. 
All examples 
will be given using numbers as the stack entries although as mentioned 
previously, the use of these operators is not restricted to numbers. 
I-
-
6.0 
..:.... 
-
...... 
7 -
"'-
-
I-
-
8 
6.0 
6.0 
~ 
-
7 -
-
7 -
,..... 
-
,-
-
8 
DUP 
2DUP 
3DUP 
-
-
-
-
4.0 
2.0 
-
-
I-
-
I-
5 
-
~ 
-
r-
-
-
3 
2.0 
4.0 
I-
-
5 
-
-
-: 
I-
-
3 
SWAP 
2SWAP 
3SWAP 
Feb. 1977 
8-5 

f-
-
12.0 
t-
-
I-
3 -
f-
-
I-
-
6 
9.0 
9.0 
~ 
!-
-
I-
1 -
I--
-
I-
-
5 
DROP 
2DROP 
3DROP 
I-
-
6.0 
r-
-
r-
5 -
r-
-
r-
-
2.0 
2.0 
I-
-
I-
-
~ 
3 
I-
3 -
7 
f-
-
I-
-
4 
4 
f-
5 
-
f-
5 -
6.0 
I-
-
6.0 
I-
-
7 
7 
OVER 
20VER 
30VER 
8-6 
Feb. 1977 

3 
2 
1 
2 
1 
r--
-
I-
-
3 
5.1 
5.1 
r--
-
r-
-
2 
ROT 
2 
2 
2 
5. 1 
4 
PICK 
One error that will be detected by FORTH is stack underflow. 
This 
occurs when the stack is empty and the program attempts to operate on 
the stack. 
(The only valid operation to perform on an empty stack is 
to push a number onto the stack.) 
For example, the sequence 
1 
+ 
will generate the response 
+?u 
since the single-word addition 
operator expects two single-word integers on the stack. 
(This example 
assumes the stack was empty prior to entering the sequence 
1 + ). 
Qct. 1979 
8-7 

o 
(") 
rt 
I.D " 
\.D 
00 
I 
00 
l-Word 
2-Word 
3-Word 
Operators 
Operators 
Operators 
Description 
DUP 
2DUP 
3DUP 
Duplicates the top entry on the stack. 
SWAP 
2SWAP 
3SWAP 
Interchanges the top two entries on/ the stack. 
DROP 
2DROP 
3DROP 
Deletes the top entry from the stack. 
OVER 
20VER 
30VER 
Takes a copy of the second entry on the stack and 
pushes this copy onto the top of the stack. 
ROT 
2ROT 
I 
3ROT 
Rotates the top three words on the stack, moving 
the third to the top, the second to the third 
and the top to the second. 
I 
I 
I 
I 
Takes a copy of the nth word on the stack and 
PICK 
2PICK 
3PICK 
• 
pushes this copy onto the top of the stack, where 
n is the top word on the stack. 
1 PICK 
is 
Identical to 
DUP 
and 
2 PICK 
i.s identitClI 
to OVER. 
AND 
I 
Replaces the top two words with their logical AND. 
OR 
Replaces the top two words with their inclusive OR 
XOR 
I 
Replaces the top two words with their exclusive OR 
---
-
I-- --
-
---
--
- --
--
---- --
TABLE 8.1 - Manipulation Words 

8.2 
COMPARISON WORDS 
8 
These words numerically compare the top one or two numbers on the stack 
leaving a logical value (true or false, as described in Section 7.5) as 
the result. 
These words operate on either single-word integers or 
floating-point numbers as shown in Table 8.2. 
Examples of these words 
are given below. 
-
-
-8.5 
-
-
-
-
~ 
-
9 
2. 1 
2. 1 
t:j 
.... 
-
~ 
-
8 
9 
MAX 
2. 1 
-8.5 
FMAX 
I-
-
-8.5 
i--
-
-
~ 
-
-3 
2. 1 
-8. 5 
-
-
i--
-
9 
9 
-3 
MIN 
2.1 
-8.5 
FMIN 
Oct. 1979 
8-9 

-
-
1.1 
I-
-
t-
-
25 Cj 
1.0 W 
t-
-
25 
(TRUE) 
(FALSE) 
25 
25 
= 
1.0 
1.1 
F= 
t-
-
3.5 -
~ 
-
2 
3.0 
t=j 
I-
-
~(FALSE) 
5 
(TRUE) 
5 
2 
> 
3.0 
3.5 
F> 
8-10 
Oct. 1979 

I-
-
8.2 
i-
-
!-
-
2 
3. 1 
~ 
(FALSE) 
-
-
Lj(TRUE) 
5 
5 
2 
< 
3. 1 
8.2 
F< 
I-
-
Lj 
Lj(TRUE) 
~(FALSE) 
0.05 
I-
-
o 
0= 
0.05 
FO= 
I--
-
-5.2 
~ 
~(FALSE) 
-
- Lj 
(TRUE) 
28 
0< 
-5.2 
FO< 
Oct. 1979 
8-11 

00 
I 
N 
o 
n 
rt 
~ 
-...J 
~ 
Single-word 
Double-word 
Integer 
Integer 
MAX 
DMAX 
MIN 
DMIN 
= 
D= 
< 
D< 
> 
D> 
<> 
>= 
<= 
I 
0= 
DO= 
0< 
DO< 
0> 
0<> 
0>= 
0<= 
I 
TABLE 8.2 - Comparison Words 
Floating 
Description 
Point 
FMAX 
Replaces the top two numbers with the 
number having the greater magnitude. 
FMIN 
Replaces the top two numbers with the 
number having the lesser magnitude. 
F= 
Replaces the top two numbers with the 
10g1cdl value TRUE (non-zero) or FALSE 
F< 
(zero) depending on their relationship. 
F> 
i 
FO= 
Replaces the top number with the logical 
FO< 
va 1 ue TRUE (non-zero) or FALSE (zero) 
depending on the relationship between the 
number and zero. 
~-
-
--
-

EXERCISES - CHAPTER 8 
1) 
Given the definitions 
5. 2VARIABLE 
X 
9. 
2CONSTANT 
Y 
O. 
2CONSTANT 
Z 
evaluate the expression 
Z 
= 
2 * (X -
Y) 
in two ways. 
Print the result that is stored in 
z. 
Note that 
there is not a double-word integer multiply. 
2) 
Using the definitions in question 1, evaluate the expression 
3) 
Z = 
(X -
Y) + (X + Y) 
loading the value of X onto the stack only once. 
Print the 
result that is stored in z. 
Using the definitions in question 1, evaluate the expression 
Z = 
(X + Y) + (X -
y) 
loading the value of X onto the stack only once and loading 
value of Y onto the stack only once. 
Print the result that 
stored in 
Z. 
the 
is 
4) 
What is the final contents of the stack after each of the folluwing 
sequences is executed? 
a) 
5 
DUP 
4 
+ 
b) 
12 
3 
OVER 
SWAP 
DROP 
+ 
c) 
1 
DUP 
2 
OVER 
+ 
ROT 
3DUP 
2DROP 
+ * 
()c t. 1979 
8-13 

8-14 
5) 
Are the two following sequences identical (i .e. - wi 11 the 
contents of the stack be identical upon completion of each 
sequence)? 
7 
4 
OVER 
7 
4 
SWAP 
DUP 
ROT 
ROT 
6) 
The word 
P]CK copies a single-word integer from a location 
within the stack onto the top of the stack. 
Define two words 
2PICK 
and 
3PICK 
which copy a 2-word entity and a 3-word 
entity (respectively) from the nth word on the stack onto 
the top of the stack, where 
n 
is the top word on the stack. 
For example: 
t-
27 
-
5 
5 
I-
27 
-
I-
27 
-
27, 
5 
3 
2PICK 
Oct. 1979 

6) 
Continued 
I-
-
5.8 
I-
-
9 
9 
3 
3 
r-
-
f-
-
5.8 
5.8 
~ 
-
I-
-
5.8 
3 
9 
5 
3PICK 
Oct. 1979 
8-15 

9. 
THE COLON DEFINITION 
All examples and problems up to this point have involved typing in words 
and numbers on the terminal keyboard and getting the answer printed out 
immediately. 
What if we have a sequence of words, such as given in 
exercise 6 of Chapter 7, to evaluate a given mathematical formula and 
we want to execute the words many times, each time changing the value 
of the input variable(s)? 
Up to this point our only option is to key 
in the entire sequence of FORTH words comprising the formula each time. 
Obviously this is unacceptable and it is the purpose of this chapter to 
introduce the technique whereby a given sequence of words can be 
"remembered" in the dictionary. 
As a simple example say that we want to increment the value of an 
integer variable (named 
J) by one. 
The following sequence performs 
this task: 
J 
lil 
1 
+ J: 
Now after keying this in on the terminal a half dozen times we become 
tired and decide to enter this sequence into the dictionary. 
First we 
must assign the sequence a name, since all dictionary entries are 
identified by the first three characters and count of a user assigned 
name. 
If we decide to name it 
INCJ 
then we may write the colon 
definition 
INCJ 
J 
@ 
1 
+ 
J 
t name 
the colon starts 
the definition 
t 
the semi-colon terminates 
the definition 
First note that the colon starts the definttion and the semi-colon 
terminates the definition. 
Following the colon is the name that 
identifies the definition in the dictionary (in this case the first 
three characters are INC 
and the count is 4). 
Everytliing following 
Feb. 1977 
9-1 

9-2 
the name, up to the semi-colon, comprises the definition. 
When 
the word 
INCJ 
is executed then the six-word sequence 
J 
dl 
1 
+ 
J: 
will be executed. 
Consider the following lines of code as an example: 
8 
J 
INCJ 
J 
dl 
INCJ 
INCJ 
J 
dl 
[set the current value of 
[increment the value of 
[will print 9] 
[increment the value of 
[increment the value of 
[will print 11] 
J 
to 8J 
J 
by 1] 
J 
by 1] 
J 
by 1] 
Perhaps the analogy to keep in mind is the two step compilation/execution 
sequence of a Fortran program - first you compile the program, 
subroutine and functions and then you execute the program (which may 
execute the subroutines or functions, which may execute other subroutines 
or functions, etc.). 
In FORTH you may consider keying the colon 
definition as similar to compilation - the word is entered into the 
dictionary. 
After the word has been entered into the dictionary you 
may then execute the word whenever you wish. 
Similar to the concept of one subprogram calling another subprogram, one 
word in FORTH can execute another word. 
If we wanted to increment the 
va 1 ue of 
J 
by three then we could define another word named 3INCJ 
to perform this: 
I 
3INCJ 
INCJ 
INCJ 
INCJ 
Note however that the above definition will perform the same function 
as the following definition 
3INCJ 
J 
dl 
3 
+ 
j 
that is, increment the value of 
J 
by 3. 
Feb. 1977 

Going back to the Fortran compilation/execution analogy you know that 
there are two types of errors that may be detected in a Fortran 
program - compilation errors (missing statement number, invalid syntax, 
etc.) and execution errors (exponent overflow/underflow, trying to take 
the square root of a negative number, etc.). 
Similarly in FORTH, some 
errors will be detected when the colon definition is entered into the 
dictionary and some errors will not be detected until the newly defined 
word is executed. 
As an example of the first type of error, if we 
mistakedly would have keyed in 
z 3INCJ 
XNCJ 
INCJ 
INCJ 
1- error 
FORTH will immediately respond with 
XNCJ 
?Q 
Since it will not locate the word 
XNCJ 
in the dictionary (assuming 
you have not previously defined a word named 
XNCJ). 
This brings up 
the very important rule: 
All words appearing in a colon definition (folZowing the name 
of the definition and up to the semi-colon) must be either 
previously defined words or numbers. 
This rule is dictated by the fact that the FORTH compiler is a one-pass 
compiler. 
As an example of an execution error assume that we had mistakedly entered 
: INCJ 
1 
+ J! 
as the original definition of 
INCJ 
(we forgot to load the original 
value of 
J 
onto the stack for the addition). 
FORTH will gladly enter 
this word into the dictionary however the first time the word 
INCJ 
is executed FORTH will respond with 
INCJ 
?U 
Feb. 1977 
9-3 

9-4 
since the addition operator expects two numbers on the stack. 
Returning to the one-pass restriction, it means that the sequence 
o 
VARIABLE 
INCJ 
J 
@ 
J 
1 
+ 
J 
I 
3INCJ 
INCJ 
INCJ 
INCJ 
is valid, however the sequence 
INCJ 
J 
@ 
1 
+ 
J ! 
o 
VARIABLE J 
I 
3INCJ 
INCJ 
INCJ 
INCJ 
is invalid (the definition of 
J 
must precede the reference to 
J 
in 
the definition of 
INCJ). 
Also, the sequence 
o 
VARIABLE J 
I 
3INCJ 
INCJ 
I 
INCJ 
J 
@ 
1 
INCJ 
INCJ 
+ 
J 
is invalid since the reference to 
precedes the definition of 
INCJ. 
INCJ 
in the defintion of 
3INCJ 
Although the one-pass feature of 
FORTH somewhat restricts the appearance of definitions it greatly 
speeds up the compilation. 
The stack turns out to be the most natural way to pass parameters to a 
word which is to be executed. 
Consider the definition of a word weill 
call 
FSQ 
which forms the square of a floating-point number. 
If we 
enter 
8.0 
FSQ 
F. 
we expect 
to 
FSQ 
64.0 
to be printed. 
Here the number 8.0 is the "parameter" 
and the "result" is left on the stack. 
The definition of 
FSQ 
could be 
I 
FSQ 
3DUP 
F* 
Oct. 1979 

and this performs the desired operation. 
Given this defintion of 
Fsa 
and the variable declarations 
7.0 
REAL 
A 
B.O 
REAL 
8 
1.0 
REAL 
C 
we can code the expression 
: OISCR 
8 F@ 
FSQ 
(8 2 -
4AC) 
as 
4.0 
A F@ 
F* 
C F@ 
F* 
F-
where we have chosen the name 
OISCR 
Enter i ng 
to identify this calculation. 
OISCR 
F. 
will print 36.0 
as the value of the expression (using the initial 
values of A, Band C given above). 
Simi larly, if we enter 
4.0 
A 
F! 
9.0 
8 
F! 
2.0 
C 
F! 
OISCR 
F. 
we should have the value 
49.0 
printed. 
We can now use the word 
OISR 
that we have defined and write a word to solve the old faithful 
quadratic equation 
-8 + 18 2 
-
4A~ 
2A 
(Assume at this point that we are dealing only with strictly positive 
discriminants to avoid worrying about a single root or two imaginary 
roots.) 
Oct. 1979 
9-5 

I 
lROOT 
B F@ 
FMINUS 
DISCR 
FSQRT 
F+ 
A F@ 
2.0 
F* 
F/ 
: 2ROOT 
B F@ 
FMINUS 
DISCR 
FSQRT 
F-
A F@ 
2.0 
F* 
F/ 
I 
QUAD 
lROOT 
F. 
2ROOT 
F. 
9-6 
Execut i ng 
QUAD 
print 
(with A = 4.0, B = 9.0, C = 2.0 from above) should 
-0.25 
-2.0 
as the roots of the equation. 
The new words introduced in the above are 
FMINUS 
(which negates a floating-point number) and 
FSQRT 
(which 
evaluates the square root of a floating-point number). 
A useful word that deserves mentioning here is the 
SET word which 
can often times be used instead of a colon definition to set a flag. 
Consider the definition 
o 
VARIABLE ?PLOT 
which we use as a logical flag (Section 7.5) to indicate whether or 
not we want to plot some points. A simple way to set or reset this 
flag would be 
PLOTON 
1 
?PLOT 
PLOTOFF 
0 
?PLOT 
However a faster and more efficient method of setting the integer 
?PLOT 
to a specific value is to enter the definitions 
1 
?PLOT 
o 
?PLOT 
SET 
SET 
PLOTON 
PLOTOFF 
Executing the word 
PLOTON 
wi 11 set the value of 
regardless which definition is used. 
The gene ra 1 form for the 
SET 
def in it ions is 
?PLOT 
<integer-value> 
<address> 
SET 
<name> 
to 1, 
and then executing the word 
<name> 
will store the <integer-value> 
Oct. 1979 

at the specified <address>. 
(Recall from Section 7.1 that executing 
the word 
?PLOT 
wi 11 push onto the stack the address of the 
variable). 
If we had a definition 
o 
CONSTANT 
FLAG 
then we could define the words 
o 
I 
FLAG 
1 
I 
FLAG 
to turn the flag on and off. 
SET 
SET 
FLAGON 
FLAGOFF 
If one wanted to turn on two flags at the same time then the word 
2SET 
may be used. 
Its form is 
<valuel> 
<addressl> 
<value2> 
<address2> 
2SET 
<name> 
and then executing the word <name> will store <value1> at <address1> 
and <value2> at <address2>. 
For example, using the previous defini-
tions of 
?PLOT 
and 
FLAG 
we could write the definitions 
,BON 
1 ?PLOT 
BOFF 
0 ?PLOT 
or equivalently, 
1 ?PLOT 1 
I 
FLAG 
o ?PLOT 0 
I 
FLAG 
EXERCISES - CHAPTER 9 
1 
I 
FLAG 
o 
I 
FLAG 
2SET 
BON 
2SET 
BOFF 
1) 
Define a word named 
1**4 
that will raise the single-word 
integer on top of the stack to its 4th power. 
There are 
two obvious ways to code this word. 
Verify that 
May 1978 
24 = 16, 34 = 81, 44 = 256, 54 = 625, etc. 
Which method 
is preferab I e? 
9-7 

10. 
PROGRAM CONTROL 
In the discussion of the colon definition in the previous chapter the 
words comprising the definition were executed sequentially. 
For 
example, in the definition 
I 
QUAD 
lROOT 
F. 
2ROOT 
F. 
first the word 
lROOT 
is executed, then the word F. 
is executed, 
then the word 
2ROOT 
is executed and f ina II y the word 
F. 
is 
executed. 
Often times we want to be able to control the flow of execution through 
a colon definition based on certain programmatic decisions. 
In Fortran 
you may use DO loops and IF statements to control the flow of execution 
through a program and FORTH contains similar control structures, 
described in this chapter. 
10. 1 
DO LOOPS 
The FORTH 
DO 
loop may be used within a colon definition to repeatedly 
execute a sequence of words. 
There are two forms provided, depending 
whether the loop index is to increment by +1 each time through or 
whether the loop index is to change by a programmer specified value: 
< Ii mi t-va I ue> 
<start i ng-va I ue> 
DO 
<limit-value> <starting-value> 
DO 
<words> 
<words> 
LOOP 
< increment-va I ue> 
+LOOP 
<starting-value> 
is a single-word integer value specifying the value· 
of the loop index the first time through the loop. 
<limit-value> 
is a single-word integer value specifying the upper 
limit of the loop index. 
If the loop index is 
increasing, the loop will terminate when the loop 
Feb. 1977 
10-1 

10-2 
<words> 
index reaches this <1 imit-value>. 
When the loop index 
is decreasing, the loop will terminate when the loop 
index passes this <limit-value>. 
are the words to be executed each time through the 
loop. 
<increment-value> is a single-word integer value specifying the value 
by which the loop index is to be incremented or 
decremented each time through the loop. 
If this 
<increment-value> iss peci f i ed then the word 
+LOOP 
must terminate the 
DO 
loop. 
As in Fortran, a 
DO 
loop in FORTH wi 11 always be executed at least 
once. 
Some examples should help clarify the above descriptions. 
LOOP SPECIFICATION 
LOOP I NDEX VALUES 
5 
1 
DO 
<words> 
LOOP 
1 , 2, 3, :} identical 
5 
1 
DO 
<words> 
1 
+LOOP 
1 , 2, 3, 
loops 
1 
5 
DO 
<words> -1 
+LOOP 
5, 4, 3, 2, 
-8 
-6 
DO 
<words> -1 
+LOOP 
-6, -7, -8 
1 1 
3 
DO 
<words> 
2 
+LOOP 
3, 5, 7, 9 
-3 
-11 
DO 
<words> 
+2 
+LOOP 
-11 , -9, -7, -5 
50 
25 
DO 
<words> 
5 
+LOOP 
25, 30, 35, 40, 45 
0 
1000 
DO 
<words> 
LOOP 
1000 
-99 
-99 
DO 
<words> -1 
+LOOP 
-99 
Feb. 1977 

Before continuing on make certain that you understand these examples and 
proceed to the exercises at the end of the chapter and work the first 
exercise. 
In order to access the loop index while executing a 
DO 
loop the word 
I 
must be executed. 
Executing this word pushes onto the stack the 
current single-word integer value of the loop index. 
In this respect 
the word 
I 
acts 1 ike a 
CONSTANT 
and not a 
VAR I ABLE. 
For 
example we can define a word named 
PRNT 
z PRNT 
5 
1 
DO 
I 
LOOP 
and execut i ng the word 
PRNT 
wi 11 pr i nt 
1 
2 
3 
4 
on the 
termi na 1. 
I f we wanted to form the sum of the integers from 50 th rough 
100 (inclusive) and then print the result we could define a word named 
SUM 
: SUM 
0 
101 
50 
DO 
I 
+ 
LOOP 
and executing the word 
SUM 
will print 3825. 
Note 
that in this example we initially push 0 onto the stack to initial ize 
the sum. 
We then add each value of the loop index to the top number on 
the stack, leaving the result on top of the stack for the next time 
through the loop. 
When the loop terminates, the top number on the 
stack is the sum and we may then print this value. 
This is a good 
example of the usefulness of keeping a temporary result on the stack 
instead of storing and loading the value in a temporary variable. 
Convince yourself that the following word performs the identical 
function as 
SUM 
z SUM1 
0 
50 
100 
DO 
I 
+ 
-1 
+LOOP 
Oct. 1979 
10-3 

10-4 
The stack operations involved when the word 
SUM 
as follows: 
50 
101 
101 
o 
o 
o 
101 
50 
DO 
I 
LOOP 
I 
+ 
LOOP 
I 
100 
• • • 
• • • 
3725 
LOOP 
I 
+ 
empty 
LOOP 
is executed are 
50 
o 
+ 
52 
101 
+ 
Note that the <starting-value> and <limit-value> are popped off the 
stack by the word 
DO 
and are then stored internally within FORTH. 
Note also that the word 
LOOP 
does not manipulate the stack (and 
is shown in the above simply for clarity). 
Feb. 1977 

To show the stack operations involved when using the word 
+LOOP 
to 
terminate a 
DO 
loop consider the word 
SUM1 
defined above 
100 
50 
50 
100 
o 
o 
o 
o 
50 
100 
DO 
I 
+ 
-1 
99 
';';1 
100 
100 
199 
-1 
+LOOP 
I 
+ 
-1 
+LOOP 
98 
-1 
50 
••• 
199 
3775 
I 
+ 
-1 
+LOOP 
I 
-1 
3825 
empty 
+ 
-1 
+LOOP 
The word 
+LOOP 
pops the < increment-va I ue> off the s tack each time 
it is executed. 
Feb. 1977 
10-5 

10-6 
DD 
loops in FORTH may be nested and in order to access the loop 
index from within a nested loop the words 
I. J 
and 
K 
follows: 
are used as 
I 
accesses the loop index from the innermost loop, 
J 
accesses the loop index from the loop outside of the 
innermost loop, 
K 
accesses the loop index from the loop two levels outside 
of the innermost loop. 
The words 
I 
J 
K 
act as 
CONSTANTS 
in that one simply 
executes the word in order to push the value of the appropriate 
loop index onto the stack. 
However, it is not possible to store 
new values in these words by executing, for example, 
I 
In other words, the current value of the loop index may be read 
only. 
DO 
loops in FORTH are not limited to a maximum nesting of three, as 
might be indicated from the discussion above, however the gory details 
of further nesting is beyond the scope of this primer. 
I f the word LEAVE 
is executed wi th in the range of a 
DO 
loop this 
wi 11 force the loop to termi nate when the next 
LOOP 
or +LOOP 
is 
executed. 
This provides a handy method of terminating a loop before 
the specified <limit-value> is reached. 
The current value of a loop index i~ qccessible onZy withJn the colon 
definition which contains the words 
DO 
and 
LOOP. 
: ISa 
I 
DUP 
* 
ILOOP 
10 
Q 
DO 
Isa 
LOOP; 
For example 
is not allowed since 
I 
(the current value of the loop index) is 
available only within the word ILOOP 
by 
I LOOP 
(such as the word 
I sa) . 
and not within words called 
Oct. 1979 

10.2 
BEGIN-END LOOPS 
This control structure may be used within a colon definition to 
repetitively execute a sequence of words until a specified logical 
condition is true. 
The format of the loop is 
BEGIN 
<words> 
<logical-condition> 
END 
The most frequent use of this structure is to "wait" for a certain 
condition to occur. 
For example, basic FORTH provides a word named 
?TER 
and when executed it pushes a value of true onto the stack 
(a non-zero integer value) only if the operator has entered a character 
on the terminal, otherwise a value of false (zero) is pushed onto the 
stack. 
If, at some point of a program, you wish to wait for the 
operator to enter a character, you could write 
<name> ... 
BEGIN 
?TER 
END 
,~----~ ________ ~I 
y-
this loop is executed continually 
until a character is entered on 
the terminal. 
As another example assume that we want to terminate a loop only when 
the value of a floating-point variable named 
DELTAX 
is less 
than 0.01: 
FLOATING 
0.0 
REAL 
DELTAX 
<name> 
... 
BEGIN 
<words> 
DELTAX F@ 
0.01 
F< 
END 
This example is typical of many numerical iterations where one is 
waiting for a value to converge to some limiting value. 
As another example let us code the word 
without using the 
DO 
loop: 
SUM 
from the previ ous sect i on 
Feb. 1977 
10-7 

o 
CONSTANT 
INDEX 
: INCINDEX 
INDEX 
1 
+ 
• INDEX 
I 
SUM2 
50 
'INDEX 
o 
BEGIN 
INDEX 
+ 
INCINDEX 
INDEX 
100 
> 
END 
Execut i ng the word 
SUM2 
results in 3825 being printed, identical 
with the execution of the word 
SUM, 
however note how much more work 
is involved by not using the 
DO 
loop. 
Note that the <logical-
condition> is popped from the stack by 
END. 
Finally, consider a word named 
STKPRNT 
which proceeds down the 
stack, printing each number, until a zero is encountered. 
STKPRNT 
BEGIN 
DUP 
0= 
END 
DROP 
Executing 
0 
5 
9 
STKPRNT 
would result in 
9 
5 
printed and the following stack operations: 
9 
9 
5 
o 
5 
5 
5 
5 
5 
o 
o 
o 
o 
o 
being 
5 
o 
o 5 9 STKPRNT 
BEGIN 
DUP 
0= 
END 
10-8 
o 
o 
DUP 
(The word 
BEG I N 
simply for clarity). 
1 
o 
empty 
0= 
END 
DROP 
does not manipulate the stack and is shown above 
Feb. 1977 

10.3 
BEGIN-WHILE-REPEAT LOOPS 
Often it is desirable to terminate a loop at some point within the loop 
and not at the end (as 
BEGIN-END 
does). 
The control structure 
provided for this is 
BEGIN 
<words-l> 
< 1 og i ca 1-cond it ion> 
WH I LE 
<words-2> 
REPEAT 
First <words-1> are executed and the <logical-condition> is then evaluated. 
I f true (non-zero) then <words-2> are executed and REPEAT 
wi 11 tran3fer 
control back to BEGIN 
and <words-1> are evaluated. 
If false (zero) 
then 
WHILE 
transfers control to the words following 
REPEAT. 
As 
long as the <logical-condition> is true, <words-1> and <words-2> are executed. 
However, as soon as the <logical-condition> is false, the loop is executed 
immediately «words-2> are not executed after 
WHILE 
encounters a false). 
Graphically, this structure appears as 
unconditional branch back 
+ 
true 
• BEGIN--........ JHILE+----I 
....... REPEATt, 
I faTse 
. 
After reading the next section, one should understand that the BEGIN-WHILE-
REPEAT 
structure could be implemented as 
BEGIN 
<words-1> 
<logical-condition> 
IF 
<words-2> 
ELSE 
0 
THEN 
END 
where 
the 1 and 0 left on the stack by the 
IF-THEN-ELSE 
are simply 
flags for 
END 
to either terminate or continue looping. 
Oct. 1979 
10-9 

10.4 
IF -
THEN - ELSE STATEMENT SELECTION 
This control structure allows the program flow to branch in one or two 
directions depending on the value of a logical condition. 
This version 
of the 
IF 
statement is more powerful than either the arithmetic IF 
or the logical IF in Fortran since an 
ELSE 
clause is provided. 
The format of the 
I F 
statement is either 
<logical-condition> 
IF <true-part> 
THEN 
<logical-condition> 
IF <true-part> 
ELSE 
<fa I se-part> 
THEN 
where the words comprising the <true-part> will be executed only if the 
<logical-condition> is true (non-zero), otherwise the words comprising 
the <false-part> will be executed (if the 
ELSE 
<false-part> clause 
is specified). 
10-10 
As an example of a word using the ELSE 
clause consider a word named 
SIGN 
which prints "POS" or "NEG" on the terminal depending whether 
the integer on top of the stack is positive or negative: 
: SIGN 
0 < IF." 
NEG" 
ELSE." 
POS" 
THEN 
(character output is described in Section 14.1). 
As another example consider the following definition of the word 
MAX 
(which was described in Chapter 8): 
MAX 
OVER 
OVER 
< 
IF 
SWAP 
THEN 
DROP 
The stack operations involved in executing 
2 
6 
MAX 
are: 
Oct. 1979 

6 
2 
2 
1 
6 
6 
6 
6 
6 
2 
2 
2 
2 
2 
2 
6 
MAX 
OVER 
OVER 
< 
IF 
2 
2 
6 
6 
SWAP 
THEN 
DROP 
The word 
> 
generates the <logical-condition> of 1 (true) and 
therefore the <true-part> is executed (the word 
IF 
pops the 1 
off the stack). 
The word 
THEN 
does not manipulate the stack 
and is shown above simply for clarity. 
Oct. 1979 
10-1 1 

If we were to execute 
5 
3 
MAX 
the stack operations would be: 
3 
5 
5 
o 
3 
3 
3 
3 
3 
5 
5 
5 
5 
5 
5 
3 
MAX 
OVER 
OVER 
< 
IF 
3 
5 
THEN 
DROP 
Since the <logical-condition> is 0 (false) and since an 
ELSE 
clause is not specified the word 
THEN 
is executed immediately 
after the word 
IF. 
It is important to note that the 
IF 
statement pops the <logical-
condition> off the stack. 
If you want to preserve the <logical-
condition> for later use then you must 
DUP 
it prior to executing 
the 
IF. 
Another important point to note is that the stack must 
be the same (i.e. - contain the same number of words) after executing 
either the <true-part> or the <false-part>. 
Exercise 6 at the end 
of this chapter illustrates this point. 
10-12 
Oct. 1979 

EXERCISES - CHAPTER 10 
1) 
What values wi 11 the loop index take on in each of the following 
DO 
loops? 
a) 
2900 
2898 
DO 
<words> 
LOOP 
b) 
-5 
-4 
DO 
<words> 
-1 
+LOOP 
c) 
-6 
-2 
DO 
<words> 
-2 
+LOOP 
d) 
-2 
-3 
DO 
<words> 
LOOP 
e) 
-2 
-3 
DO 
<words> 
-1 
+LOOP 
f) 
6 
18 
DO 
<words> 
-6 
+LOOP 
g) 
18 
6 
DO 
<words> 
6 
+LOOP 
h) 
0 
-1 
DO 
<words> 
LOOP 
2) 
Write a word to form the product of the even numbers from 2 to 10 
(inclusive) and print the result. 
Use a 
DO 
increment. 
loop wi th a pos i t i ve 
3) 
Redo exercise 2, this time using a 
DO 
increment. 
loop with a negative 
4) 
Recode the words 
INCINDEX 
and 
SUM2 
in Section 10.2 using 
the definition 
o VARIABLE 
INDEX 
5) 
Use the colon defbiition to define the words I 
DMAX 
DMIN 
D= 
D< 
D> 
DO= 
DO< 
Oct. 1975' 
10-13 

6) 
Extend the word 
SIGN 
given in Section 10.3 to print 
II P ", 
II Nil 
or 
IIZII depending whether the integer on top of the 
stack is positive, negative or zero. 
7) 
Define a word named 
EX 
which prints the top 
n words of the 
stack, non-destructively -- that is, the contents of the stack 
must not be destroyed (the printing word 
destroys the number 
that it prints). 
For example 
88 
23 
2 EX 
should print 
23 
88 
65 
8) 
Define a word named 
VINIT 
in the vector 
that will initialize each element 
19 
( ) DIM 
VEe 
to its subscript value. 
That is, element 0 should be set to 0, 
element 1 should be set to 1, ... , element 19 should be set to 19. 
9) 
Defi ne three words named (). 
2 ( ) • 
3 ( ) • 
that wi 11 pri nt out 
the first n values of a single-word integer vector, a doub1e-
word integer vector and a floating-point vector, respectively 
(n 
is the top word on the stack, the starting address of the 
vector is the second word on the stack). 
Test the word 
(). 
on the vector in the previous problem. 
10) 
Define a word named 
3VBUBSORT 
that will sort a vector of 
floating-paint numbers into ascending order using the bubble 
sort algorithm. 
This algorithm is one of the simplest (and 
least efficient) techniques for sorting a string of numbers 
into order and is defined as follows: 
10-14 
Oct. 1979 

Oct. 1979 
To sort the N values 
X(O), X(l), .•• , X(N-1) 
For 
L = 1, 2, •.. , N-1 
For 
M = N-1, N-2, ... , L 
If X(M-l) 
> X(M) 
Then Swap X(M) and X(M-l) 
Note that this algorithm uses two (nested) 
DO 
loops, one 
with an increasing loop index and one with a decreasing loop 
index. 
Assume that the top word on the stack is 
N. 
Use the definitions 
5 
3( )DIM 
VC 
29.7 
0 
VC 
F: 
-8.2 
1 
VC 
F: 
-1.9 
2 
VC 
F: 
4.5 
3 
VC 
F: 
0.52 
4 
VC 
F: 
-8.3 
5 
VC 
F: 
and then execute 
6 
3VBUBSORT 
Use the word 3(). 
from the previous problem to print the 
sorted vector. 
10-15 

11 . 
BLOCK I/O 
Using the methods introduced up to this point, to enter a word into the 
dictionary we type in the definition through the terminal and the word 
is immediately entered into the dictionary. 
This method 
has two obvious 
disadvantages: 
(a) 
we are restricted to one line of terminal input 
(72 characters) per definition; (b) 
if we do not have a hard copy 
printout of our terminal input/output and we forget a previously entered 
definition we are out of luck as far as recalling the 1 isting of the 
definition. 
Both of these restrictions are overcome by using "blocks" 
as described in this chapter. 
FORTH divides the secondary storage (disc or tape) into separate 
distinguishable units called blocks. 
In KPNO Varian FORTH systems (with 
a 5 Megabyte disc) each block is identified by its block number, an 
integer between 0 and 4895 (inclusive). 
Each block contains 1024 
characters. 
(Blocks may contain data other than characters however in 
this primer we will be interested in blocks of characters only). 
Certain blocks are permanently allocated, as shown below: 
Block # 
o -
7 
8 -
199 
200 
201 - 4895 
Additionally, executing 
130 
LOAD 
Usage 
Bootstrap & binary loaders 
FORTH 
Resi~ent Loader Block, to be set by the user. 
Available for the user. 
will list on the terminal the block allocation within blocks 8-199. 
From the block allocation scheme 1 isted above, the user is allowed to do 
anything he wants with blocks 200-4895 (but must not modify any of 
blocks 0-199). 
Oct. 1979 
11-1 

11-2 
Even though a block is nothing more than 1024 consecutive characters, 
certain routines (the text editor and the block lister) divide these 
1024 characters into 16 lines of 64 characters/line. 
The purpose of 
this arbitrary division Is simply to facilitate the reading and printing 
of the characters in a block. 
This division of a block into lines in 
no way affects the format of the data on magnetic tape or disc. 
The 
16 lines in a block are referenced as line 1, line 2, .•• , line 16. 
One common error made by newcomers to FORTH is to assume that there is 
a blank between the last column of a given line and the first column 
of the next line. 
This is false as the block consists of 1024 
consecutive characters - no special characters are inserted before or 
after each line, as the breakdown of a block into lines is for reading 
and printing only. 
Feb. 1977 

~-
12. 
TEXT EDITOR 
Knowing that a block of secondary storage can contain 1024 characters 
of FORTH code we now need a way to efficiently manipulate a block of 
characters. 
This manipulation is the function of the text editor. 
Facility in using the editor is a must in order to proceed onward in 
this primer as all examples and exercises from this point on will require 
the use of blocks to contain your program code. 
12.1 
SPECIAL CHARACTERS AND TERMINOLOGY 
The following special characters will be referred to in the descriptions 
that follow: 
spaae 
aarTiage-return 
line-feed 
rubout 
tab 
break 
esaape 
aontroZ-N 
The following symbols 
<block#> 
<line#> 
text buffer 
Feb. 1977 
press the space bar on keyboard. 
press the "RETURN" key on keyboard. 
press the "LINE-FEED" key on keyboard. 
press the IIRUBOUT" key or the "DELETE" key 
on keyboard. 
press the "CNTL" key and the IIIII key simultaneously. 
press the IIBREAK" key on keyboard. 
press the "ESC" key or the "ALT MODE" key on 
the keyboard. 
press the "CNTLII key and the "Ni l key simultaneously. 
will be used to denote frequently used entities: 
refers to a block number, which is a single-word 
integer in the range 0 through 4895 (inclusive). 
refers to a line number, which is a single-word 
integer in the range 0 through 16 (inclusive). 
is a 64 character buffer used to hold a single line. 
Certain editor commands will move a line into 
the text buffer and other editor commands may 
move the contents of the text buffer into a 
certain line of the block. 
12-1 

12.2 
COMMAND DESCRIPTIONS 
Describing the editor is a somewhat boring task since all one can do 
is verbally define each command - examples are generally impossible to 
provide since the editor is such an interactive, terminal-oriented 
program. 
The only way to appreciate this interactiveness and to under-
stand each of the commands below is to try executing each command after 
reading its description. 
This chapter may also be used later as a 
reference when using the editor. 
<b 1 ock#> 
EDIT 
A 
12-2 
will load the editor program into the dictionary, 
if it is not already in the dictionary. 
The 
specified block is then read into a core buffer 
from secondary storage {tape or disc} and is 
I isted on the terminal. 
You may stop this list ing 
by pressing any terminal key. 
NOTE: 
When using the 
file system (Section 13.2) the first invocation of 
the editor must not be preceded by a <block#>. 
This 
is because after the ed i tor is loaded but befo re any 
block number may be specified, one must first execute 
a FILE 
command to designate which file is to be 
edited. 
A typical invocation of the editor with the 
file system would be 
EDIT 
(load the editor) 
FILE 
<f i 1 e-name> 
<block#> 
EDIT 
(spec i fy wh i ch :f i I e) 
(edit a block wi thin the 
f i 1 e) 
will edit the Alternate block. 
FORTH has two block 
buffers in memory and if one wants to transfer some 1 ines 
between two blocks, execute 
<block#l> 
EDIT 
(read block#l into memory) 
<block#2> 
EDIT 
(read block#2 into memory) 
HL 
(hold lines from block#2) 
A 
(swi tch to block#1) 
IL 
(i nsert I ines into block# 1) 
A 
(swi tch to block#2) 
Oct. 
I 979 

B 
<1 i ne#> 
BI 
Oct. 1979 
will !egin entering lines from the keyboard into 
the block being edited, starting at the line 
specified by <line#>. 
FORTH will print each 1 ine 
number and then wait for you to key in the contents 
of the 1 ine, terminating each line with a 
carriage-return. 
This process continues until 
either 1 ine 16 (the last line in the block) is 
entered or until you key in a break as the first 
character of a line. 
While keying in each line 
the following special characters may be used: 
rubout - deletes the preceding character 
(backspaces). 
break -erases the entire 1 ine allowing 
you to start the line over again 
(this assumes that the break was 
keyed in other than as the first 
character of ali ne - when a break 
is keyed in as the first characte r 
the Begin mode is terminated, as 
mentioned above). 
tab 
- enters 5 spaces into the 1 ine. 
Note that each 1 ine entered by using the Begin 
command replaces the previous contents of that line. 
Example: 
2 
B 
wi 11 start replacing at 1 ine 2 
of the block. 
If 4 lines are 
entered by the operator then 
lines 2,3,4, & 5 are replaced. 
Lines 1 and 6-16 will not be 
modified. 
will !egin ~serting 1 ines from the keyboard into 
the block being edited, starting after the 1 ine 
specified by <line#>. 
This command is similar to 
the 
B command with the following exception: 
entering 3 1 ines wi th the command 
'8 
B' 
wi 11 
replace 1 ines 8, 9 & 10 with the new 1 ines entered 
by the operator - lines 1-7 and lines 11-16 
are not modified and remain intact; entering 3 
12-3 

lines with the command 
'8 
BI' will replace 
lines 9, 10 & 11 with the new lines entered by the 
operator - 1 ines 1-8 are not modified, however, 
the contents of old 1 i ne 9 are now in 1 i ne 12, the 
contents of old 1 i ne 10 are now in 1 i ne 13, the 
contents of old 1 ine 11 are now in 1 ine 14, 
II ... , 
the contents of old 1 i ne 13 are now in 1 i ne 16 and 
1 ines 14, 15 & 16 have been discarded. 
Thus the 
B command repZaces lines in a block, overwriting 
the previous contents of each line; the BI 
command inserts new lines into a block. 
Since 
each block contains exactly 16 lines, when you 
insert a new line one of the old lines has to be 
removed - the algorithm used by 
BI 
is to push 
each succeeding line down one line, effectively 
pushing line 16 out of the block. 
<source-b1ock#> <destination-block#> 
B-MOVE 
<block#> 
CHANGE 
CLEAR 
12-4 
Moves the block specified by <source-block#> 
This 
action is identical to the MOVEBLOCKS 
command 
(described in the next section) with <#-of-blocks> 
Example: 
500 
509 
B-MOVE 
} 
500 
509 
L 
MOVEBLOCKS 
both commands move block 500 
to block 509. 
Changes the block number of the block currently 
being edited to <block#>. 
Example: 
292 
EDIT 
) 
208 
CHANGE 
effectively moves block 
292 to block 208. 
will initialize the block being edited to blanks 
(i.e. - the entire block is erased). 
This command 
is used to clear a block prior to entering new 
code into the block. 
A block of all blanks is 
considered in use and will be printed on a 
DOFORTH 
1 is t i ng. 
Oct. 1979 

<1 ine#> 
D 
Q.eletes the 1 ine specified by <1 ine#>. 
The original 
contents of the 1 ine are placed in the text buffer 
and may therefore be moved to another line wi th 
the 
I 
or 
R 
commands. 
All lines following <line#> 
are moved up one line and line 16 is filled with blanks. 
Examples: 
9 
D 
9 
4 
wi 11 de 1 ete 1 i ne 9, mov i ng 
lines 10-16 into lines 9-15 
and 1 i ne 16 then is f ill ed 
with spaces. 
wi 11 delete 1 ine 9 and then 
insert the original contents 
of line 9 between lines 4 & 5. 
The net effect of these two 
commands is that 1 i nes 1-4 
are unmodified, line 5 contains 
the original contents of line 
9, lines 6-9 contain the 
original lines 5-8 and 1 ines 
10-16 are unmodified. 
<line#l> 
<line#2> 
DL 
Deletes the !:..ines <line#l> through <line#2> 
<1 ine#> 
E 
Oct. 1979 
(inclusive) of the current block being edited. 
This command is identical to a string of D 
commands. 
At the completion of this command the 
first line in the sequence will be in the text buffer. 
Examp Ie' : 
~ D: D 5 D} 
these two command strings perform the 
same function, namely deleting 1 ines 
5 through 7 of the current block. 
Erases the line specified by <line#>, filling the 
1 ine with blanks. 
The original contents of the 
line are first placed in the text buffer and may 
therefore be moved to another 1 ine with the 
I 
or 
R 
commands. 
12-5 

ERASE-CORE 
FLUSH 
12-6 
Examp le: 
5 
9 
erases line 5 and then inserts 
the original contents of line 
5 between lines 9 & 10, moving 
lines 10-15 down into lines 
11-16. 
The original contents 
of line 16 are lost. 
Prevents the block currently being edited from 
being written onto secondary storage (disc or tape) 
by marking both of FORTHs block buffers empty. 
This allows you to change your mind after editing 
a block, provided you have not specifically 
FLUSHed the block onto secondary storage or edited 
other blocks since making the changes. 
Example: 
250 
EDIT 
edits block 250 with the 
(changes to 
block 250) 
ERASE-CORE 
specified changes and 
then effectively ignores 
these changes. 
After 
execut i ng the 
ERASE-
CORE 
the contents of 
block 250 will be the 
same as prior to executing 
the 250 
EDIT. 
Forces the writing onto secondary storage (disc or 
tape) of both of FORTHs block buffers. 
Once a 
block is written onto secondary storage the 
previous contents of the block are lost. 
Normally 
FORTH does not write a block buffer onto secondary 
storage until the buffer space is needed for 
another purpose, however this command is a way of 
guaranteeing that an edited block replaces the 
previous contents of the block (in case the system 
were to fail between the editing of the block and 
FORTHs normal buffer output). 
Feb. 1977 

<1 i ne#> 
H 
<line#l> <line#2> 
HL 
Feb. 1977 
!!olds the line specified by <line#> in the text 
buffe r. 
A copy of -th is 1 i ne may then be moved to 
another line with the 
I 
or 
R commands. 
Unlike 
the 
D 
command, 
the 
H 
command does not de 1 ete 
the 1 ine when it is placed in the text buffer. 
Examp les: 
2 H} 
wi 11 hold 1 ine 2 in the text 
buffer. 
2 :} 
wi 11 hold 1 i ne 2 in the text 
8 
buffer and then replace 1 i ne 8 
with this copy of line 2. 
Effectively we have copi ed 
1 ine 2 into 1 ine 8. 
Holds Lines <line#l> through <line#2> (inclus ive) 
of the current block being edited. 
These lines 
may then be moved to anothe r block with the 
I L 
command. 
Th i s ho 1 dis not a true ho 1 d as on 1 y the 
1 ine numbers are remembered and no text buffers 
are used. 
After executing an 
HL 
command the 
user must not issue the B, 
BI 
or 
M commands 
prior to executing the 
IL 
command. 
Also, the 
HL, 
I L 
within a 
Examp le: 
commands may not be used to move 1 ines 
single block. 
258 
EDI 
5 
7 
HL 
261 
EDIT 
12 
D 
1 1 
D 
10 
D 
9 
IL 
will move lines 5, F-
& 7 
of block 258 into 1 i nes 
10, 11 & 12 of block 261. 
Note that the previ ous 
contents of 1 ines 10, 11 
& 12 are deleted pri or to 
entering the new 1 in es. 
Also note that lines 5, 6 
& 7 of block 258 have not 
been deleted from block 258. 
12-7 

<1 ine#> 
I 
<1 i ne#> 
I L 
12-8 
Inserts the contents of the text buffer after the 
line specified by <line#>. 
The lines following 
<line#> are each moved down one line and hence 
line 16 is lost. 
<line#> may be 0 in which case 
the new line becomes 
Examples: 
12 
12 
12 
I} 
1 i ne 1. 
wi 11 insert the contents of 
the text buffer after line 
12. 
The new line becomes 
1 ine 13 and the original 
lines 13-15 become lines 
14-16. 
Li ne 1 6 i s los t. 
effectively swaps lines 12 
and 13. 
This is so because 
the delete places the original 
line 12 in the text buffer and 
moves lines 13-16 into lines 
12-15. 
The insert then places 
the original line 12 from the 
text buffer into line 13, 
moving lines 13-15 into lines 
14-16. 
Hence the original 
1 i ne 1 3 is now in 1 i ne 12 
{from the delete} and the 
original line 12 is now in 
line 13 {from the insert}. 
Inserts the Lines that were held by the most recent 
HL 
command into the current block being edited, 
effectively moving a copy of the lines from the 
prior block into the current block. 
The lines in 
the current block, following <line#>, are moved 
down as required to make room for the new lines. 
Feb. 1977 

L 
<1 ine#> 
M 
Feb. 1977 
As usual, extra lines will be lost when moved down 
from line 16. 
After executing an 
HL 
command 
the user must not issue the 
B, 
B1 
or 
M 
commands prior to executing the 
1L 
command. 
A 1 so, the 
HL, 
I L 
commands may not be used to 
move lines within a single block. 
List the block being edited. 
On a CRT terminal 
the screen wi 11 be erased prior to listing the 
block. 
You may stop the listing by pressing 
any terminal key. 
Modifies the line specified by <line#>. 
This 
command is probably the most frequently used editor 
command therefore acquaintance with this command is 
a necessl.ty. 
Since this command only modifies the 
specified line no other lines in the block are 
affected. 
The following buffers are used by the 
editor to execute this command: 
(note: 
this 
command is in no way as complicated to use as it is 
to describe). 
Reference Line 
A copy of the original contents 
of the specified line. 
It is listed when this 
command is executed. 
Control Line 
This line is used to enter the 
special input character codes into. 
On 
d CRT 
terminal this line is directly beneath the 
Reference Line, while on a printing terminal 
(such as a teletype) this line is coincident 
with the Output Line. 
Output Line 
A copy of the final contents 
of the modified line being constructed. 
This 
line is built up as you proceed, character by 
12-9 

12-10 
character, through the Reference Line and 
after normal termination of the 
M command 
this line replaces the original contents of 
the specified line. 
The 
M command functions by proceeding character 
by character through the line, adding, deleting 
or replacing characters, building a new copy of 
the line. 
The following characters have special 
meanings when executing the M command. 
Any 
character not defined below, when keyed in, will 
be transferred into the output line. 
space 
Transfers the next character from the 
Reference Line into the Output Line (i .e. -
copies one character from the old version of 
the line into the new version being constructed) 
and then moves to the next character position 
in the Reference Line. 
tab 
Transfers the next 5 characters from 
the Reference Line into the Output Line 
(equivalent to typing in 5 spaces). 
carriage-return 
Transfers the remainder of 
the Reference Line into the Output Line. 
This 
terminates the 
M command and the contents of 
the Output Line are then moved into the 
specified line of the block. 
rubout 
Skips over the next character in the 
Reference Line, effectively "deleting" the 
character from the new version of the line. 
Contro"t-N 
Transfers one blank into the Output 
Line without advancing in the Reference Line, 
effectively "adding" a blank into the new 
version of the line. 
Feb. 1977 

L - (a Control-L followed by a single character). 
Transfers characters from the Reference Li ne into 
the Output Line up to but not including the 
character c. 
This action is a handy way to leave-
in all characters up to specific character without 
having to continually enter spaces or tabs. 
Kc 
-
(a Control-K followed by a 5ingle character). 
Skips through the Reference Line until the 
character c is reached. 
No characters are 
transferred into the Output Line. 
This action 
effectively kills all characters, up to the 
character c, from the new version of the line. 
Control-S - Skips to the next word, transferring the 
characters that are skipped into the output 1 ine. 
Cpntrol-D - Deletes to the next word. 
No characters are 
transferred into the Output Line. 
break - Aborts the current M command leaving the 
original contents of the specified 1 ine intact. 
The 
"?S" abort message is printed (Appendex B). 
line-feed 
Starts transferring characters from the key-
board into the Output Line, effectively "adding" 
characters into the new line being formed. 
Every 
character keyed in is moved to the output with the 
exception of the following special characters: 
rubout - Deletes the previous character in 
the Output Line, effectively "backspacing" 
one character. 
break - Deletes the entire accumulated output 
1 i ne. 
Add it i ona 11 y, if a 
Oct. 1979 
12-11 

12-12 
break is entered as the first 
character of the output line then 
the M command is aborted, 
leaving the original contents of 
the specified line intact. 
tab 
Transfers 5 spaces into the Output 
Line (equivalent to typing in 
5 spaces). 
carriage-return 
Terminates the M command 
escape 
and the contents of the Output Line 
are transferred into the specified 
I ine of the block. 
I'bte that all 
remaining characters in the 
Reference Line, fol lowing where the 
line-feed was keyed in, are effec-
tively deleted. 
Termi nates the "add character" 
mode that was initiated by the 
line-feed, returning "control" 
to the Reference Line. 
Whenever characters are added or deleted, within a line, by using the 
M command, the characters that follow in the line will be shifted left 
or right. 
If characters are added to a line then the remaining characters 
are shifted right and any characters beyond the 64th character position 
are lost (they do not get moved into the next line). 
If characters are 
deleted from a line then the remaining characters are shifted left and 
spaces are added through the 64th character position. 
This action is 
similar to what happens with line 16 when entire lines are added or 
deleted from a block. 
On CRT terminals (as opposed to printing terminals) 
a cursor is displayed to help you visualize where you are in either the 
Reference Line or the Output Line as you move through a line. 
Feb. 1977 

N 
<line#l> 
<1 ine#2> 
0 
p 
<1 ine#> 
R 
<1 ine#> 
T 
ZERO 
Oct. 1979 
will edit the Next block. 
will perform a character by character logica1-
OR of the two lines, printing the result and 
leaving it in the text buffer. 
The logical-OR 
of any character with a blank is the character 
itself. 
will edit the Previous block. 
~ep1aces the line specified by <line#> with the 
contents of the line buffer. 
Example: 
2 
14 R
T\ wi 11 type 1 i ne 2 and then 
V move the copy of 1 i ne 2 into 
1 i ne 14. 
Li nes 2, 15 and 16 
are not modified. 
Iypes the line specified by <line#> and places the 
line in the 
Example: 
2 
14 
text 
:} 
buffer. 
will type 1 ine 2 
the copy of 1 ine 
15. 
The original 
1 i ne 15 are moved 
and the original 
1 i ne 16 are lost. 
and t hen move 
2 into 1 ine 
con tents of 
to 1 i ne 16 
contents of 
will initialize the block being edited to zeros 
(i.e. - the entire block is erased). 
A block of 
all zeroes is considered an unused block and will 
not be printed on a DOFORTH listing. This command 
is often used to clear a block that was in use but 
is no longer needed. 
12-13 

12.3 
BLOCK EDITOR 
The text editor described in the preceding section operates on lines of 
text and manipulates these lines within a given block or between two 
different blocks. 
This section describes an additional editor, referred 
to as the Block Editor, which manipulates entire blocks or groups of 
blocks, regardless what is contained within the block, be it characters 
or data. 
Our usage of the block editor will assume that the blocks 
contain character data, however, the block editor commands will also 
operate on blocks of data. 
In order to load the block editor into the dictionary the text editor 
must first be loaded into the dictionary. 
The text editor is loaded by 
executing the sequence (refer to Section 12.2) 
<block#> 
EDIT 
Following this, one loads the block editor by executing the sequence 
199 
LOAD 
The following commands are then available to manipUlate groups of blocks: 
<start i ng-b 1 ock#> 
<end ing-b 1 ock#> 
CLEARBLOCKS 
will fill each block from <starting-block#> through <ending-block#> 
(inclusive) with blanks. 
This command is similar to the text 
ed i tor 
CLEAR 
command. 
Example: 
281 
294 
CLEARBLOCKS 
will fill block 281 through 294 with blanks. 
<b 1 ock#l > <b lock#2> 
<#-of-b locks> 
EXCHANGE 
will exchange (swap) the number of blocks specified by <#-of-
blocks> between the blocks specified by <block#l> and <block#2>. 
Example: 
500 
600 
3 
EXCHANGE 
will exchange blocks 500 and 600, blocks 501 and 
601 and blocks 502 and 602. 
<source-block#> <destination-block#> INSERT 
12-14 
will insert the block specified by <source-block#> immediately 
following the block specified by <destination-block#>. 
The blocks 
starting with <destination-block#> are all moved down one block, 
until the first empty block is encountered. 
(A block is considered 
empty if it contains all zeros). 
If there are no empty blocks 
within 50 blocks of <destination-block#> then no block movement 
Oct. 1979 

takes place and a message is printed. 
If an empty block is located 
then the block number of this empty block i·s printed. 
Example: 
325 
408 
INSERT 
will move the contents of block 325 into block 
408. 
Assuming that block 412 is the first empty 
block following block 408, then the following 
block movement wi 11 take place: 
411 
--> 
412 
410 
--> 411 
409 
--> 410 
408 
--> 
409 
325 
--> 
408 
Additionally, the message 
BLK USED: 412 
wi 11 be output. 
<source-block#> 
<destination-block#> <#-of-blocks> 
MOVEBLOCKS 
Oct. 1979 
will move the number of blocks specified by <#-of-blocks> starting 
from the block specified by <source-block#> into the blocks 
starting at the block specified by <destination-block#>. 
The 
original contents of the destination blocks are overwritten by 
the new contents. 
The blocks are moved from first to last, 
therefore no overlap is allowed. 
This means that if <destination-
block#> minus <source-block#> is less than <#-of-blocks>, 
information will be destroyed. 
Example: 
380 
385 
3 
MOVEBLOCKS 
will move block 380 into block 385, block 38 1 into 
block 386, and block 382 into block 387. 
The 
original contents of blocks 380, 381 and 382 are 
not modified. 
12-15 

12-16 
<startlng-block#> 
<endlng-block#> 
ZEROBLOCKS 
will fill each block from <starting-block#> through <endlng-
block#> (inclusive) with zeros. 
This command is similar to the 
text editor 
ZERO 
command. 
Note that a block containing all 
zeros is considered an empty block. 
Examp Ie: 
220 
290 
ZEROBLOCKS 
will fill blocks 220 through 290 with zeros. 
Feb. 1977 

A 
Swi tches to the Alternate blo,ck. 
-
--
<I ine#> 
8 
Begins entering 1 i nes. 
-
-
-_. ~----
<line#> 
81 
Begins .!..nsertlng lines . 
......... ,. 
-
<source-block#> <destination-block#> 8-MOVE 
Moves the specified block. 
-
.. 
_. 
<block#> 
CHANGE 
Changes the block#. 
. . 
Q 
r • .........-. 
CLEAR 
C 1 ea rs the entire block, 
'rilling it with blanks. 
._--
< 1 ine#> 
D 
Deletes the 1 i ne. 
-
-
. 
<starting-line#> <ending-line#> 
DL 
Deletes Li nes. 
-
<line#> 
E 
Erases 
-
the line, fi 11 i ng 
it wi th blanks. 
-
... -
. 
--
<block#> 
EDIT 
Edits the specified block. 
ERASE-CORE 
Marks both core buffers 
as being empty. 
--
....... 
. 
FLUSH 
Forces the writing onto secondary 
storage of both core buffers. 
-
-.-
--
<1 ine#> 
H 
Holds the 1 i ne in the text buffer. 
-
-
.----... -.. -.. --'" _._----. ---
<startlng-line#> <endlng-line#> 
HL 
Holds Lines (for subsequent 
I L) . 
-- .. 
---
-----
<line#> 
I 
I nserts a 1 i ne. 
-
.",,,,-
--'--'--' .. -
<line#> 
IL 
Inserts Lines held by 
-
-
previous 
HL 
-
L 
Lists the block. 
-_ ... =1 
<line#> 
M 
Modifies the 1 i nee 
1----
N 
SWitches to the Next block. 
'. 
.~ 
<llne#l> <1 i ne#2> 
0 
Qrs the two 1 i nes. 
I 
P 
Switches to the Previous block. 
J 
./ 
<1 i ne#> 
. 
R 
~eplaces the 1 i ne. 
1 
<line#> 
T 
Types the 1 ine. 
-; 
i 
Zeroes the entire block, 
ZERO 
fill i ng I t with zeroes. 
1 
Table 12.1 - Editor Commands 
Oct. 1979 
12-17 

N 
I 
00 
" 
CD 
C'" 
\.0 
........ 
........ 
199 
LOAD 
<starting-block#> 
<ending-block#> 
CLEARBLOCKS 
<block#l> 
<block#2> 
<#-of-blocks> 
EXCHANGE 
<source-block#> 
<destination-block#> 
INSERT 
<source-block#> 
<destination-block#> <#-of-blocks> 
<starting-block#> 
<ending-block#> 
ZEROBLOCKS 
-~-
----
----
--- -- -------
------
Table 
12.1 
Block Editor Commands 
Loads the block editor words. 
Clears the blocks, filling each 
one with blanks. 
Exchanges (swaps) the specified 
blocks. 
Inserts the specified block. 
MOVEBLOCKS 
Moves the specified blocks. 
Zeroes the blocks, filling each 
one with zeroes. 
-
~ 
-
----_ .. -
---------~-.---

13. 
PROGRAM STRUCTURE 
Knowing that we may store our program code in a block on secondary 
storage, we are now ready to write some longer programs, utilizing 
this feature. 
13.1 
BLOCK ORIENTED PROGRAMS 
If you have a group of definitions in a disc block you must 
LOAD 
the 
block in order to enter the definitions into the dictionary. 
This is 
accomplished by executing the sequence 
<block#> 
LOAD 
where <block#> is a single-word integer value specifying which block of 
secondary storage is to be loaded. 
The loading sequence starts with the 
first character in the specified block and continues through the block 
until either of the following words is encountered: 
;S 
CONTINUED -
--> 
terminates loading of the current block and all 
characters that follow the 
;S 
in the block 
are ignored. 
terminates loading of the current block but 
continues on to load the block whose block # 
is on top of the stack. 
All characters that 
follow the 
CONTINUED 
in the block are 
ignored. 
terminates loadin9 Jf the current block and 
continues on to load the next block. 
All 
characters that follow 
--> 
in the block are 
ignored. 
Refer to the end of this section for 
more detail converning the use of --> 
Once again, some examples are the easiest way to see what is happening. 
Oct. 1979 
13-1 

I NPUT SEQUENCE 
BLOCK CONTENTS 
BLOCKS LOADED 
Block 
250 
250 
LOAD 
250 
STOP 
; S 
L-,;.. ____ 
---' 
Block 
300 
STOP 
; S 
Block 
301 
300 
LOAD 
300, 
301 
LOAD 
301 , 
302 
LOAD 
STOP 
; S 
302 
Block 
302 
STOP 
L;~S~ ______ ~ 
Block 
300 
301 CONTI NUED 
Block 
301 
300, 
300 
LOAD 
301 , 
( 
302 CONTI NUED 
302 
Block 
302 
STOP 
;S 
....... _--_ .... 
13-2 
Feb. 1977 

Notice how the last two examples perform Identical functions, that is 
to load blocks 300, 301 and 302. 
The final example (using 
CONTINUED) 
is preferable since it requires only one 
LOAD 
to be keyed in and 
executed. 
Now assume in the final example you wish to insert some code between 
blocks 300 and 301 (that is, the words to be entered into the dictionary 
must logically be loaded after block 300 has been loaded but before 
block 301 is loaded), 
One method to accomplish this is as follows: 
Block 
300 
CONTINUED 
Block 
301 
302 CONTINUED 
(,........B;..;.I..:::.OC;;.:.k ___ 3~,'0~2..., 
;S 
new block of code 
301 CONTINUED 
Feb, 1977 
13-3 

13-4 
This method will work perfectly well, however the problem now is that 
the new code in block 303 is logically out of sequence since it should 
really appear between blocks 300 and 301. 
A few additions of this form 
and the program quickly becomes a mess! 
To avoid this problem lets move the contents of block 302 to block 303 
and then move the contents of block 301 to block 302. 
This then frees 
block 301 for the new code. 
We can use the block editor to move blocks 
301 and 302 by executing 
302 
303 
B-MOVE 
301 
302 
-B-MOVE 
which will move the two blocks as desired. 
What we now have is: 
Block 
300 
301 CONTINUED 
Block 
301 
available for new block of code 
Block 
302 
previous contents of block 301 
302 CONTINUED 
Block 
303 
previous contents of block 302 
;5 
Oct. 1979 

Note however, that in addition to entering the new code into 
block 301, we must also edit the 
'302 
CONTINUED' 
in block 302 
to 
'301 
CONTINUED' 
since we moved block 301 into block 302. 
Finally, as a solution to this problem (the problem of having to edi t 
the b I ock# preced i ng 
CONT I NUED) , we can descr i be a word named 
+BLOCK 
which calculates an absolute block number given a relative 
block number: 
In block# 
300 
420 
500 
300 
The sequence 
1 
+ BLOCK 
CONT I NUED 
2 
-f' BLOCK 
CONT I NUED 
-3 
+ BLOCK 
CONTINUED 
-1 
+BLOCK 
CONTINUED 
Is identical to 
301 
CONT I NUED 
422 
CONTINUED 
497 
CONTINUED 
299 
CONTINUED 
As the examples show, the single-word integer vaLue preceding the word 
+BLOCK 
is added to the current block number yielding a single-word 
integer value absolute block number. 
(A block number such as 300, 420, 
etc. is called absoZute since it refers to a specific block - a block 
number is called reZative if it refers to a block in a specific location 
relative to the current block). 
The sequence 
301 
CONTINUED 
is an absolute block reference since it refers to block 301 specifically. 
The sequence 
1 
+BLOCK 
CONTINUED 
is a relative block reference since the block referred to depends on 
which block the sequence 
'1 
+BLOCK 
CONTINUED' 
appears. 
The 
sequence 
'1 
+BLOCK 
CONTINUED', 
if found in block 350, refers 
to absolute block 351; however if found in block 407, refers to absolute 
block 408. 
Oct. 1979 
13-5 

13-6 
Had a relative block reference been used in blocks 300 and 301 of the 
example we would not have to edit the 
'302 
CONTINUED' 
as 
mentioned previously. 
Thus, the original appearance of the example 
should have been 
Block 
300 
( 
r-
1---=+:;..:B~LO~C~K.-C O~N~T_I_N_U _ED-.. 
Block 
~Ol 
C
_1--..;"*;..,;BL..;;,0.;;.,C;.;,.K_C..;:,0.;;.,N;;,.T_1 N_U_E_D ... 
r-
Block 
302 
; S 
After moving block 302 into 303 and block 301 into 302 we need only edit 
in the new code into block 301 and then terminate block 301 with 
1 
~BLOCK CONTINUED 
and we1re all set. 
No other blocks need be modified. 
The purpose of this lengthy discussion has been to explain the logic and 
usefulness behind the provided block structure. 
It would have been 
shorter to simply describe the 
+BLOCK 
word at the beginning, however 
it is more instructtve to first examine the alternatives and see just 
why the final technique is the best. 
This discovery, examination and 
comparison of alternative techniques is the essence of programming. 
Oct. 1979 

The stack interactions of the word 
+BLOCK 
are very simple. 
Again 
consider the sequence 
1 
+BLOCK 
CONTINUED 
being executed in block 420: 
empty 
1 
+ BLOCK 
CONTINUED 
The word 
+BLOCK 
simply adds the single-word integer on top of the 
stack to the current block number, leaving the result on top of the stack. 
Now that we know how to link together a sequence of blocks into a program 
what are the contents of the blocks? 
The format of each program block 
is largely (if not entirely) a matter of individual preference. 
The 
following format is used by the author and should be regarded as one 
possible format: 
1) 
Line 1 contains the base in which all numeric quantities are 
specified (decimal or octal, specified by the FORTH words 
DECIMAL 
or 
OCTAL). 
Nevel' assume that the base is set to what you wan t! 
2) 
Following the base specification, the remainder of Line 1 is used to 
contain a comment which briefly describes the function of the code 
appearing in the block. 
A comment in FORTH is denoted by a left 
paren, followed by one or more spaces, followed by the comment, 
terminated by a right paren (this closing paren need not be preceded 
by a space). 
Thus to comment that a block contains hour angle 
calculations, the FORTH sequence would be 
( HOUR ANGLE CALCULATIONS 
3) 
Lines 2 through 15 contain the code. 
Oct. 1979 
13-7 

13-8 
4) 
Line 16 contains the sequence 
1 
+8LOCK 
CONTINUED 
if there are more program blocks to follow, otherwise it contains 
the word 
;S 
to terminate the loading. 
5) 
At the right margin of Line 16 one should put the date on which the 
block was last modified and the initials of the person making the 
modifications. 
This allows another person to see when the block was 
last changed and by whom. 
Note that since these characters appear 
af te r the 
CONT I NUED 
or the 
; S 
they are ignored du ring 
loading and therefore are effectively comments. 
For example, if the 
block was last modified by the author on February 30, 1976 one 
could write 
30FEB76 WRS 
to specify the date and the person. 
Now consider a sample block, say block 503, as listed by the editor: 
1. 
DECI MAL 
2. 
3. 
15. 
16. 
1 
+BLOCK 
CONTINUED 
( HOUR ANGLE CALCULATIONS ) 
30FEB76 WRS 
(Lines 2 through 15 would contain the program code.) 
Oct. 1979 

Summing up the recommended program structure: 
1) 
Have each block load its successor with a relative 
CONTINUED, 
that is, for example 
2) 
3) 
1 
+BLOCK 
CONTINUED 
Terminate the final block only with 
;5 
The entire program is then loaded by executing 
<starting-block#> 
LOAD 
where <starting-block#> is the absolute block number of the first 
program block. 
As an alternative to specifying the absolute block number of the fi rst 
block in a program, one can define a new word to be entered into the 
dictionary such that when this word is executed a specified block will 
be loaded. 
The word 
LOADER 
is used to define the new word and the 
format of this definition is 
<block#> 
LOADER 
<name> 
where <name> is the user assigned name (recognized as usual, by its first 
three characters and count). 
For example, instead of executing 
300 
LOAD 
in the previous example, to load blocks 300, 301, 302 and 303 we can 
define the word 
PROG 
as follows 
300 
LOADER 
PROG 
and then simply execute the word 
PROG 
to load the four blocks. 
This 
technique has the advantage that one now remembers a user defined name, 
instead of a (possibly meaningless) block number. 
Oct. 1979 
13-9 

The word 
LOAD 
starts loading with the first character of line 1 of 
a block and if one wishes to start loading with the first character of any 
line of a block, the word 
LINELOAD 
is available: 
<line#> <block#> LINELOAD 
As wi th the word 
LOAD, 
when ,S 
CONTINUED 
the loading of a block with LINELOAD 
or 
--> 
is encountered. 
terminates 
One should understand that the word 
--> 
is equivalent to the sequence 
+BLOCK 
CONTINUED 
The difference is that 
--> 
is a compiler directive which will be executed 
during the compilation of a colon definition. 
This means that one is able to 
extend a colon definition from one block to the next by placing the word 
--> 
as the final word in a block. 
This is not too frequent a requirement 
(if you write a colon definition that extends over a block, perhaps the 
definition should be broken into two or more words) however the facility is 
provided. 
In general, --> 
is preferred to 
'1 
+BLOCK 
CONTINUED' 
because it is a single word (the latter is three words, each which must be 
executed) plus it requires fewer characters to be keyed in (hence less chance 
for typing mistakes). 
The sequence '<value> 
+BLOCK 
CONTINUED' 
should be used mainly when <value> is not equal to one. 
13-10 
Oct. 1979 

13.2 
FILE SYSTEM 
A rudimentary file system is provided by KPNO Varian FORTH which allows 
one to allocate disc blocks into files. 
Use of the file system simpl i-
fies the combining of separate programs into a larger program by not 
forcing one to think in terms of absolute disc blocks. 
A file is a sequential group of one or more disc blocks and every file 
has a name which is identified by its first three characters and count. 
A directory of all files is maintained on disc and for every file on disc, 
the directory contains the file name, absolute starting block number, and 
absolute ending block number (actually the ending block number plus one). 
As in FORTH, the file directory is searched backwards, therefore, if two 
files having the same name are both in the directory, only the newer file 
is accessible. 
A group of commands to manipulate files are provided by 
a fi Ie called FILEMAN 
(the fi Ie manager). 
To load a file, one executes: 
LOADF I LE 
<name> 
which 
LOADS 
the fi rst block of the fi Ie. 
A fi Ie may 
LOADFILE other 
files and this nesting may go to a level of ten. 
All blocks within a file 
are numbered relative to the first block of a file, starting with zero. 
For example, a 4 block file would consist of blocks 0, 1, 2, and 3. 
In order 
to load block 3 from block lone could use 
2 
+BLOCK 
LOAD 
Absolute block numbers must never be used in a file (unless one is refer-
encing basic FORTH which will always reside in absolute blocks 8-199). 
The last 1 ine of block 0 of every file should contain a comment descrioing 
the file and the first 40 characters of this comment are printed by vari-
ous file manager util ities in order to provide more information on the 
contents of a file than the file name alone provides. 
Oct. 1979 
13-11 

In order to edit a file, one first executes 
EDIT 
which loads the editor words into the dictionary, followed by 
FILE 
< name> 
to specify which file is to be edited. 
Finally 
<relative-block#> 
EDIT 
will edit any block within the file. 
If one then wishes to edit some 
other file simply execute 
FILE 
<name> 
<relative-block#> 
EDIT 
In order to print a file on the lineprinter, one first executes 
LDADFILE 
FPRINT 
which loads the lineprinter words and a modified BLOCKPRINT utility 
into the dictionary. 
-FPR I NT discards these words. 
To print all non-zero blocks of a file, one executes 
FPR 
< name> 
To specify only certain blocks of a file to be printed, one executes 
FILE 
m 
n 
< name> 
BLOCKPRINT 
which will print the relative blocks m through n inclusive of the specified 
fi Ie. 
To print another file, simply re-execute either the 
FPR 
command or the 
FILE 
and 
BLOCKPRINT commands with the new filename. 
The file manager is loaded by executing 
LOADFILE 
FILEMAN 
and may be discarded by executing 
-FILEMAN. 
The following file handling 
words are available after loading 
FILEMAN 
13-12 
Oct. 1979 

FCHANGE 
<namel> 
<name2> 
FCOMPARE 
~ame> 
FCOPY 
<name> 
<#b locks> 
FCREATE 
<name> 
FDELETE 
<name> 
Oct. 1979 
Rename the file <namel> as <name2>. 
<name> specifies an existing disc file 
and any file on a file storage tape is 
compared with the disc file. 
The oper-
ator is asked which file on tape is to 
be compared. 
The relative block numbers 
of any non-equal blocks are printed. 
Copy a sequence of blocks between the 
specified file and a standard FORTH tape. 
The operator is asked whether the sou rce 
is tape or disc and the absolute starting 
block number on tape. 
The number of 
blocks transferred equals the length of 
the file. 
If the destination is disc, 
then the disc file is zeroed before the 
transfer starts. 
Create a new file of the specified 
length. 
There is no check made to see if 
a file of the same name (first three 
characters and count) already exists. 
The 
disc area assigned to the file is neither 
cleared nor zeroed, hence one must assume 
the initial contents to be garbage. 
Delete the specified file from the direc-
tory. 
The disc space used by the f i I e may 
be reused I ater by another f i I e of the same 
or smaller size. 
If the files on either side 
of this file are empty (i.e. - were previously 
FDELETED) then the areas are comb i ned in 
order to give the largest possible empty 
region. 
13-13 

FDUMP 
< name> 
<n> 
FEXTEND 
<name> 
FFREE 
FINITIALIZE 
13-14 
Dump the specified file from disc onto a 
file storage tape. 
The f i 1 e is appended onto 
the end of the file storage tape. 
Preced i ng 
the file on tape is a header block spec i fy i ng 
the name and size of the fi Ie. 
The fi 1 e 
may later be loaded onto disc by FLOAD 
or LOADALL. 
Extend the length of the specified file by 
n blocks. 
A new file is created with the 
following characteristics: 
it retains the 
original filename, its length equals the sum 
of its original length plus n, all blocks 
are zeroed, all blocks from the original 
file are then transferred to this new file. 
The original file is then designated as 
EMPTY. 
I f there is i nsuff i c i ent space 
available for the new extended file, the 
message 
NO SPACE will be printed. 
Print the number of free unused blocks 
located after the directory. 
Initial ize a file directory. 
All files except 
the file manager are deleted. 
Oct. 1979 

FLIMIT 
FLIST 
FLOAD 
< name> 
FMOVE 
< name> 
Oct. 1979 
Set the upper limit block number for file 
storage. 
The operator is asked for the 
upper block number. 
List the entire disc directory on the 
terminal. 
For each file in the directory 
the file name, starting and ending absolute 
block numbers, length (in blocks), and the 
first 40 characters of the 1 ast 1 i ne of 
block 0 of the fi Ie are 1 isted. 
Any unused 
regions (where one or more fi les have been 
FDELETEd) are 1 i sted wi th a name of EMPTY. 
In order to stop the 1 isting before the 
terminal screen fills up type Control-S 
type Control-Q to resume 1 isting. 
<name> specifies an existing disc fi le, and 
any file on a file storage tape may be loaded 
from tape into the disc file. 
The operator 
is asked which file on tape is to be loaded. 
If the lengths of the files on disc and tape 
are not equal, the number of blocks moved 
equals the shorter length. 
Move a sequence of blocks from an absolute 
location on disc into the specified file. 
The start i ng absolute block number of the 
source blocks on disc is requested and the 
number of blocks transferred equals the 
length of the file. 
13-]5 

FSQUEEZE 
FWHERE 
<name> 
FZERO 
< name> 
DUMP ALL 
LOADALL 
FI LE 
< name> 
<relative block#> 
LIST 
13-16 
Eliminate all imbedded empty files within 
the directory, if any occur, by squeezing 
user-filled files into consecutive block 
locations. 
All free unused blocks now re-
side in contiguous locations following the 
user-filled files. 
Print the absolute starting and ending 
block numbers of the specified file. 
Zero all blocks contained in the specified 
f i 1 e. 
Dump all non-empty files from disc onto 
a file storage tape, and then compare each 
block on tape to its corresponding block on 
disc. 
Load all files from a file storage tape 
onto disc. 
Each file header on tape is 
examined and if a file of the same name 
exists on the disc, the file is loaded 
from tape onto disc (overwriting the previ-
ous contents of the disc file). 
If a file 
of the same name does not exist on disc, 
the file is created and loaded from tape. 
If there is insufficient room on disc for a 
file, the file is skipped on the tape. 
Specify a file to be listed and 1 ist the con-
tents of the specified block on the terminal. 
Oct. 1979 

NEWTAPE 
SAVEFILES 
TLIST 
Oct. 1979 
Initialize a new magnetic tape which is 
to be used for file storage. 
Write all blocks,from block 0 to the 
last block of the last directory file, to 
a tape and compare these blocks with their 
correspond i ng blocks on disc. 
I tallows one 
to change the comment in the tape header, and 
it prints the final record number and final 
block number written to the tape. 
A tape 
generated by th is word is a "boot tape'l 
which may be loaded onto any system and run 
(Chapter 3). 
Read a file storage tape from beginning to 
end, 1 isting in order every file that is on 
the tape (simi lar format to FLIST). 
In 
order to stop the 1 isting before the terminal 
screen fills u~ type Control-S type Control-Q 
to resume 1 isting. 
13-17 

13.3 
OVERLAYS 
FORTH applications for which core-memory space is at a premium and run-
time reloading exacts prohibitive time overhead will benefit from the 
use of disc overlays. 
An overlay is a section of pre-compiled diction-
ary stored on disc, which may be loaded directly into a reserved section 
of dictionary (an "overlay-areall) in memory. 
Any number of overlays may 
be prepared for loading into a given overlay-area. 
Also, any number of 
overlay-areas may be defined, subject to memory limitation. 
Optional 
paging is available for overlays containing data to be modified and 
retained throughout overlay operations. 
To establ ish an overlay-area, 
use the sequence 
<size> 
O-DEFINE 
<area-name> 
The total length in words of the overlay-area is specified by <size>. 
<area-name> 
becomes the identifier of the overlay-area, and is compiled 
as the first wor.d in the overlay-area. 
As usual, only the first three 
characters and count identify <area-name>. 
At this point the dictionary 
pointer is advanced to the end of the overlay-area. 
Usual dictionary 
operations may proceed, however, words defined after this point will not 
be accessible from overlays compiled into the preceeding area. 
To create a new overlay for any given overlay-area, simply enter the name 
of the area. 
Use of the user defined word 
<area-name> 
causes dictionary linkages to be switched into the named overlay-area. 
Words subsequently defined become part of the new overlay. 
The only 
definitions accessible within an overlay are those made within the overlay 
itself and those made prior to definition of the overlay-area. 
These may 
include words within previously defined overlay-areas. 
To assist one in 
adjusting the lengths of overlays to fall within the defined area, the word 
? LEFT 
will push onto the stack the number of memory cells still available in the 
overlay-area. 
13-18 
Oct. 1979 

When the overlay is complete it must be transferred to disc. 
The sequence 
<block#>' 
O-SAVE 
< overlay-name> 
accompl ishes this, while also resetting linkages into the common dictionary. 
The <overlay-name> becomes an entry in the common dictionary which is used 
in a special manner to access the overlay. 
The <block#> is the first block 
at which the overlay will be stored. 
Overlays greater than 512 words in 
length will be written into sequential blocks as required, 512 words per 
block. 
Partial blocks are zero-filled. Alternatively, an overlay may be 
saved without specifying a particular block number for each overlay. 
The 
VARIABLE 
O-BLK 
may be set to the starting block of a general disk area 
for overlay storage. 
The sequence 
A-SAVE 
<overlay-name> 
works 1 ike O-SAVE, 
except that the block number is taken from the 
variable 
O-BLK. 
After the overlay is transferred to disc, 
o-BLK 
is updated to the next available block number automatically. 
If the 
allotted size of an overlay is exceeded, attempts to save it will result in the 
message 
nO-FLOW <over 1 ay-name> 
?Q 
where n is the number of words remaining. 
The overlay-area itself and all 
subsequent dictionary entries are deleted. 
The words defined within an overlay are accessible only when that overlay 
is in memory. 
An overlay may be explicitly loaded into core with the 
structure: 
<overl ay-name> O-LOAD 
However, for operations making extensive use of words defined within 
overlays, it may be easier to use implicit overlay-loading. 
The sequence 
<overlay-name> 
INCLUDES 
<word> 
creates an external entry which automatically insures that <word> is available 
when required. 
<word> must be the identifier of a word already defined in the 
named overlay. 
Except for timing considerations and recognition that the 
originally defined <word> is no longer directly accessible, subsequent 
references to <word> may be made as if it was part of the common dictionary 
in core memory. 
Note that the word 
O-LOAD 
is superfluous to this scheme; 
it need never be used. 
The word 
INCLUDES 
insures that the proper overlay 
is loaded for compilation as well as for execution. 
Oct. 1979 
13-19 

A typical usage of the overlays would be as follows: 
- definitions for the common dictionary -
1024 O-DEFINE 
OVAREA 
(1024 words = 2 blocks/overlay) 
20 
+BLOCK 
O-BLK ! 
OVAREA 
(starting block# on disc) 
- definitions to go into overlay #1 -
A-SAVE 
lOV 
OVAREA 
- definitions to go into overlay #2 -
A-SAVE 
2,OV 
OVAREA 
- definitions to go into overlay #3 -
A-SAVE 
30V 
- defiflitions for the common dictionary -
In this example the overlay 
10V will be stored in the first two blocks of 
the overlay region on disc, 
20V 
in the next two blocks and 
30V 
in the 
next two. 
In order to execute some words defined within 
20V 
one must 
first execute 
20V 
O-LOAD 
Normally, variables or data defined within an overlay are reset to their 
initial states each time the overlay is reloaded into core memory. 
However, 
a simple scheme has been implemented which allows variables to survive the 
overlay reloading process. 
After an overlay has been defined and saved, 
setting the precedence bit of its area-name using the sequence 
I MP 
<area-name> 
will define it as a variable overlay. 
The precedence bit for a variable 
overlay can be properly set only when the following three conditions are 
met: 
I. 
The overlay has already been placed on disc via 
O-SAVE or A-SAVE. 
2. The designated overlay is currently loaded into its core overlay-
area. 
3. 
Subsequent use of the overlay-area causes a different overlay to 
be loaded before any any dictionary is compiled into the area. 
A brief description of the action of the overlay precedence bit may prove 
helpful: 
This bit is examined before a new overlay is brought into memory; 
if set, the current overlay is first re-written on disc. 
The precedence 
13-20 
Oct. 1979 

bit is not examined before new dictionary is compiled into an overlay~ 
consequently a variable overlay that happens to be loaded prior to compi-
lation is not re-written on disc. 
The precedence bit of an overlay-area 
is cleared by either 
SAVE 
operation and so cannot be set during com-
pilation. 
Although the <area-name> not the <overlay-name> is used to de-
fine a variable overlay, only the specifically designated overlay is affected. 
Remember, 
IMP 
is a toggle function. 
Once set the precedence bit wi 11 
remain set until expl icitly reset by another 
IMP. 
Some helpful hints concerning the use of overlays: 
The useful length of an overlay area is 9 words less than the total size 
of the area. 
Do not attempt to write overlays past absolute block 2447. 
Exceedingly long names or numeric strings (greater than 15 characters) 
entered at or near the end of the overlay-area could (conceivably, but 
unlikely) extend into the common dictionary during compilation and result 
in an 
O-FLOW 
error. 
Do not attempt to 
FORGET 
an over 1 ay-area name! 
The FORGET 
word 
does not handle overlay linkages properly. 
You may, however, 
FORGET 
any word ahead of an overlay-area and so delete the overlay-area as well. 
Names of words which are not executed from outside an overlay may be freely 
duplicated in other overlays. 
However, it is inadvisable to dupl icate names 
which are to be externally referenced. 
Words defined in one overlay may be referenced from within a subsequently 
defined overlay. 
This could be a powerful tool, but must be used with 
care: 
If an overlay contains any words referenced by subsequent overlays, 
any modifications of it must be followed by re-compilation of the referencing 
overlays. 
Don't forget that a small overlay defined for a large overlay-area requires 
the full disc space of the larger area. 
Explicit or impl icit loading of an overlay from disc does not actually result 
in a disc transfer if the requested overlay is already core-resident. 
Oct. 1979 
13-21 

13.4 
VOCABULARIES 
A vocabulary is a logical subset of the dictionary. 
Basic FORTH includes 
three vocabularies: 
FORTH 
the set of words compr i sing bas i c FORTH; 
ASSEMBLER 
-
the set of words which create machine code; 
EDITOR 
the set of words which create and modify source blocks. 
A vocabulary may be used in two distinct ways: 
1) 
A place to look for existing words in the dictionary 
- dictionary searches begin in the 
CONTEXT vocabulary. 
2) 
A place to put new words into the dictionary - new words are 
placed in the CURRENT 
vocabulary. 
The end of one vocabulary may point to another vocabulary and this is 
referred to a "chaining". 
Normally, both the 
ASSEMBLER 
vocabulary and 
the 
ED I TOR 
vocabulary are chained to the FORTH vocabulary. 
The logical 
structure is then 
end of FORTH 
) 
head of FORTH 
/end of the ASSEMBLER 
(cc~ head of t~e ASSEMBLER) 
S M 
R 
vocabu ar JI' 
vocabular 
j 
head of the ED I TOR 
of the 
ED I TOR 
direction of dictionary searches 
The head of a vocabulary is the Zast word entered into that vocabulary and 
the end is the first word entered (recall that all dictionary searches in 
FORTH start at the most recent word and proceed backwards). 
It is important 
to note that the structure shown above is the "logical" structure of the 
dictionary - the words that comprise any given vocabulary need not reside 
in sequential dictionary locations. 
Every dictionary entry has a 1 ink 
that points to the previous word in the vocabulary and this 1 ink field 
converts the physical dictionary structure into its logical vocabulary tree. 
13-22 
Oct. 1979 

To specify which vocabulary is to be searched for existing entries 
(the 
CONTEXT 
vocabulary) simply execute the name of the vocabulary. 
Executing 
FORTH 
will cause only the FORTH vocabulary to be searched. 
Execut I ng 
ASSEMBLER 
causes the ASSEMBLER vocabu 1 ary to be searched 
first and if the word is not found then the search automatically continues 
on to the FORTH vocabulary (since ASSEMBLER is cha.i.ned to FORTH). 
In 
this case the EDITOR vocabulary is not searched. 
Similarly, if 
EDITOR 
is executed then the EDITOR vocabulary followed by the FORTH vocabulary 
will be searched. 
The ASSEMBLER vocabulary is not searched. 
o specify whith vocabulary is to receive new definitions (the CURRENT 
~abulary) execute 
<name> DEFINITIONS 
where <name> is the name of a previously defined vocabulary. 
A new 
vocabulary is defined by executing 
VOCABULARY 
<name> 
The dictionary entry for <name> is entered into whatever vocabulary is 
currently receiving definitions, not into the new vocabulary being 
created. 
Therefore, to keep newly defined vocabularies generally 
accessible, the sequence 
FORTH 
DEFINITIONS 
should precede any new vocabulary definition. 
To facil itate vocabulary control in basic FORTH, automatic context switching 
has been built into some basic words. 
The EDITOR vocabulary is automatically 
selected by the sequence '<block#> EDIT'. 
The words that begin machine 
code definitions (CODE. 
SUBROUTINE. 
;CODE. 
ORc.x 
and 
!CODE) 
automatically execute 
ASS:=:MBLER 
to start dictionary searching in the 
ASSEMBLER vocabulary. 
The words that begin a colon definition (z 
:ORX 
and 
!:) automatically force dictionary searching to begin in the same 
~bulary that will receive the new definition. 
The sequence 
<name> 
VL I ST 
may be executed to 1 ist all the entries in a given vocabulary. 
Note that 
if the vocabulary is chained to another vocabulary then the listing will 
automatically continue with the chained vocabulary. 
Oct. 1979 
13-23 

Each Vocabulary name is a compiler directive; that is, a word which is 
automatically executed when it appears within a colon-definition. 
This 
feature allows access to special ized vocabularies by simply including the 
Vocabulary-name within a definition. 
For example, a colon-definition 
being compiled into Vocabulary V3 needs a word that was defined in V2. 
Within the definition, the sequence, 
z • • • 
V2 
<word> 
V3 
• 
performs the requisite switching. then returns to the cur~ent vocabulary. 
Only the address of <word> is actually compiled. 
A unique variable must be provided to keep track of the last word in each 
vocabulary. 
This special "head" is created as part of each Vocabulary-name 
and is updated as new words are added to the Vocabulary. 
It is accessed 
(indirectly) through the 
VARIABLES 
CURRENT and 
CONTEXT: 
Dictionary searches begin in the "context" vocabulary: 
Executing a Vocabu-
lary-name makes 
CONTEXT 
point to the unique "head" for that Vocabulary. 
New words are placed in the "current" vocabulary: 
Executing the word 
DEFINITIONS 
sets 
CURRENT, 
making new words go into the last-named 
Vocabu 1 ary. 
A vocabulary normally has access only to those words available when it was 
defined. 
By way of example, consider the sequence: 
FORTH DEFINITIONS 
VOCABULARY VI 
VI DEFINITIONS 
VOCABULARY V2 
V2 DEFINITIONS 
which results in a logical structure like: 
• 
FORTH 
o 
\ 
Vl 
o 
' ____ V_2 __ 0 
and a physical dictionary structure: 
IFORTH~ 
<words for Vl> 
<words for V2> 
Definitions subsequently added to 
Vl 
are inaccessable to subsequent 
additions in 
V2. 
A continuation of the above sequence: 
VI 
DEFINITIONS <words for V11> 
V2 
DEFINITIONS 
<words for V21> 
creates extensions to the original vocabularies that we shall refer to as 
lid i alec t s II • 
13-24 
Oct. 1979 

• 
FORTH ,0 
\ VI 
\\ 
VII 
0 
V2 
0411 
V2 1 
0 
I FORTH~ 
V2 ~ VI' 1'1 V2' 
As illustrated in the diagram of the resulting structures, Dialect V2 1 
does not have access to Dialect Vl I. 
The word 
CHAIN 
may be used to couple one vocabulary to future extensions 
of another. 
I n the examp 1 e, the sequence: 
V2 
DEFINITIONS 
CHAIN 
Vl 
will modify the 1 inks between vocabularies such that all words subsequently 
defined in VI will be available to V2. 
Note that since VI is not chained to FORTH, if we subsequently create 
more 
FORTH 
DEFINITIONS 
the resultant structure: 
FORTH 
FORTH 
• 
~~ ___ V~I ____ O~~~V_l_I __ ~O 
\ 
V2 
V2 1 
~ ___________ 
,o~.~ ________ 
~o 
FORTH ~ 
VI 
V2~ VI' lOll) V2' ) 
FORTH 
does not allow either dialect of VI or V2 to access the new FORTH I definitions. 
Oct. 1979 
13-25 

A variation on the preceeding vocabulary-creation sequences illustrates the 
flexibility of chaining techniques. 
We create new vocabularies as before, 
but with the first one chained to FORTH, thusly: 
FORTH 
DEFINITIONS 
VOCABULARY 
V3 
V3 
DEFINITIONS 
CHAIN 
FORTH 
<words for V3> 
VOCABULARY 
V4 
V4 
DEF I NIT IONS 
<words for v4> 
We then define additional dialects: 
FORTH DEFINITIONS 
<words for FORTH ' > 
V3 
DEFINITIONS 
<words for V3 1 > 
V4 
DEFINITIONS 
<words for v41> 
thereby creating a vocabulary structure: 
• FORTH 
FORTH 
()l'II .. 
__ 
....;.....;..;.;~-O 
"~ 
____ V~3 ___ 0~4.-_V~3~1 ___ O 
\~ 
____ V_4 ____ --(Oi'lll ... ~V;....4;....1_-<O 
which allows all V3 and v4 dialects access to all of FORTH while isolating 
the words in dialect V3 1 from vocabulary v4. 
13-26 
Qct. 1979 

14. 
TERMINAL I/O 
Terminal I/O involves the input and output of both numbers and 
character strings between the program and the operator. 
The output of 
character strings, the input of numbers and the output of numbers are 
each described separately. 
The input of character strings is somewhat 
complicated and is not discussed in this primer. 
14.1 
CHARACTER OUTPUT 
The output of a character string is accomplished by preceding the string 
with the two character sequence 
II 
wi th a quote mark. 
The sequence 
II 
must therefore be followed by a space. 
and then terminating the string 
is a FORTH word (Section 4.1) and 
The final quote need not be preceded 
by a space. 
Consider the following examples: 
FORTH Character String 
Wi 11 be Printed as 
# of Characters 
II 
HELLO II 
HELLO 
5 
II 
HELLO II 
HELLO 
6 
II 
START MOTOR II 
START MOTOR 
11 
II 
Xii 
II Y II 
Xy 
1 , 
II 
Xii 
II 
yll 
X y 
1 , 2 
The important point to note in these examples is that any spaces in 
addition to the one required space (that follows the .11) are considered 
as part of the character string. 
Special characters (i.e. - the non-printing characters such as carriage-
return, line-feed, bell, etc.) may also be included in the character 
string. 
A list of all special characters available in the ASCII 
character set is given in Appendix A. 
One frequent use of these special 
characters is to include a BELL character (Control-G) in a string that 
is to be printed on a CRT terminal to alert the operator that a message 
has been printed. 
Oct. 1979 
14-1 

To assist in the formatting of character strings for output three 
additional words are defined in FORTH: 
SPACE 
- wi 11 
< spaces> 
SPACES - wi 11 
CR 
will 
For example, the sequence 
CR 
II Xy = 2"' 
CR 
wi 11 print 
XY = 2 
Z = 5 
print a single space. 
print a strlng of spaces. 
print a carriage-return. 
SPACE 
II 
Z = 5 11 
l column 1 of terminal 
All character output described in this Section can be executed as shown 
or placed within a colon definition. 
For example, the word 
PRN, 
defined as 
: PRN 
CR 
. II XY = 2" 
CR 
SPACE 
.11 Z = 5 11 
and when executed will produce the same output as shown above. 
14.2 
NUMERIC INPUT 
14-2 
Numeric input involves the reading in of numbers and the conversion into 
the appropriate data type (single-word integer, double-word integer or 
floating-point number). 
FORTH provides three words to accomplish this 
input: 
SASK 
DASK 
FASK 
Reads a single-word integer and pushes its value onto 
the stack. 
The number must not contain a decimal point. 
Reads a double-word integer and pushes its value onto 
the stack. 
The number must contain a comma. 
Reads a float~ng-point number atild pushes its value onto 
the stack. 
The number must contain a decimal point. 
Oet. 1979 

If there is an error in the number entered (for example a non-digit 
detected) the message 
? 
RETRY 
II 
will be output and FORTH will wait for the number to be re-entered. 
Addi-
tionally, if the error is due to either a single-word integer being entered 
with a decimal point or a double-word integer or floating-point number being 
entered without a decimal point, one of the following messages will be out-
put: 
NO 
ALLOWED 
II 
MUST CONTAIN 
These three asking words do not inform the operator that they are waiting 
for a number to be input - this must be done by the program. 
For example, 
consider the word 
?TEMP 
that inputs a temperature: 
o 
VARIABLE 
TEMP 
?TEMP 
II 
ENTER 
TEMP 
(DEG. 
C) II 
SASK 
TEMP 
CR 
There must be no digits to the right of the comma in a double-word integer 
while a floating-point number will usually contain digits to the right of 
the decimal point. 
Floating-point numbers input by the work 
FASK 
may 
be entered as a fraction to a given power, for example 
0.5E2 
i5 the same 
as 
50.0. 
Oct. 1979 
14.3 

14.3 
NUMERIC OUTPUT 
i 
Numeric output involves the printing of a number on the stack in some 
specified format. 
We have already encountered three words used for this 
purpose: 
integers) and 
(to print single-word integers), 
D. 
{to print double-word 
F. 
(to print floating-point numbers). 
This section will 
expand on these words to provide additional output capabil ities. 
To summarize the words that we will describe in this section: 
sequence 
<value> 
<value> 
<value> 
<field> <#places> 
N. 
outputs 
single-word 
single-word 
single-word 
double-word 
single-word 
sing 1 e-word 
single-word 
integer, 
integer, 
integer, 
integer 
integer, 
integer 
integer 
free format 
free format 
16 binary digits 
single-word integer, 
<value> 
o. 
6 octal digits 
<value> 
s. 
single-word integer 
<value> 
u. 
single-word integer, unsigned 
Note - as with all FORTH words, these words, after printing the number on top 
of the stack, will pop the number from the stack. 
The word 
is the simplest - the single-word integer value on top of the 
stack is printed using the minimum field width req~ired. The number is first 
preceded by a space. 
For example, the integer 25 requires a field width of two 
positions and the integer -25 requires a field width of three positions. 
14-4 
Oct. 1979 

In order to gain more control over the printing of single-word integers, the 
word 
S. 
must be used. 
The user must set the 
VARIABLE 
FLD 
to the 
minimum field width desired. 
If the number requires more positions than 
specified, then the number will exceed the specified field width. 
There is 
no preceding space printed by this word. 
If 
FLD 
is set to 0 then free 
format is used (minimum field width). 
Additionally, the 
VARIABLE DPL 
controls the number of digits to be printed to the right of the decimal point. 
A value of -1 specifies that the decimal point is not to be printed. 
Executing 
the word 
FREE 
wi 11 set 
FLD 
to 0 and DPL 
to -1 (minimum field width and 
no decimal point). 
The word 
FREE 
is defined as 
o 
FLD 
-1 
DPL 
2SET 
FREE 
and the definition of 
then becomes 
FREE 
SPACE 
S. 
The sequence 
3 
FLD 
(SET FIELD WIDTH TO 3) 
-1 
DPL 
CR 
5 
S. 
wi 11 output 
5 
29 
-58 
2109 
CR 
29 
S. 
CR 
'-- column 1 of terminal 
Also, the sequence 
2 FLD 
5 
S. 
-1 
DPL 
1 
S. 
28 
S. 
-58 S. 
CR 
2.09 
S. 
CR 
wi 11 output 
The sequence 
5 
:1 2 8· 
since there is no space preced i ng each number. 
5 
1 
28 
will output 
5 
1 28 
since each number is preceded by a space. 
Note that when outputt i ng a sequence of numbers 
FLD 
and 
DPL 
need on 1 y be 
set once and will remain in effect until modified again. 
The words. 
O. 
B. 
and 
H. 
are used to pr i nt a sing 1 e-word integer in acta 1, 
binary and hexadecimal respectively. 
The sequence 
Oct. 1979 
14-5 

<value> 
<field-width> 
I. 
allows one to print a single-word integer and specify the <field-width> on 
the stack. 
If one wishes to print a single-word integer with a decimal point, 
the sequence 
<value> 
<field-width> 
<#places> 
N. 
may be used, where <#places> is the number of digits to be printed to the right 
of the decimal point. 
The words 
I. 
and 
N. 
are defined in FORTH as 
N. 
DPL 
FLD 
S. 
1. 
-1 
N. 
The word u. 
is used to print a single-word integer as an unsigned 16-bit 
number. 
The word 
D. 
is similar to S. 
and is used to output double-word integers. 
The user must set the 
VARIABLE FLD 
to the minimum field width desired and 
if the number requires more positions than specified then it will exceed the 
field width. 
There is no preceding space printed by this word. 
As with 
S. 
the 
VARIABLE 
DPL 
specifies the number of digits to be printed to the right 
of the decimal point (a value of -1 specifies no decimal point). 
The sequence 
7 
FLD 
SET 
FIELD 
WIDTH 
TD 
7 
o 
DPL 
CR 
32768. 
D. 
CR 
-65000. 
D. 
CR 
1234567, 
D. 
CR 
wi 11 output 
32768. 
-65000. 
1234567. 
Lcolumn 1 of terminal 
The decimal point that may be printed must be included in the specified field 
width (i.e. - the double-word integer -1, requires a minimum field width of 3). 
25, 
DOUBLE 
X 
4 
FLO 
o 
DPL 
CR 
X 
O@ 
D. 
1 
OPL 
CR 
X 
O@ 
D. 
wi 11 output 
25. 
2.5 
L col umn 1 of terminal 
14-6 
Oct. 1979 

Floating-point numbers may be printed in one of two ways: 
with or without 
an exponent. 
The word 
F. 
prints a floating-point number without an exponent 
and the sequence 
<field-width> 
<#digits-to-right-of-decimal-point> 
w.o 
must be executed to set both the total field width (including decimal point) 
and the number of digits to be printed to the right of the decimal point. 
For example, the sequence 
8 
3 
w.o 
specifies a field width of 8 with three digits to the right of the decimal point 
(similar to the Fortran F8.3 format). 
The sequence 
8 
3 
W.O 
CR 
25.1 
F. 
CR 
3.14159 
F. 
wi 11 output 
25.100 
3. 142 
tcolumn 1 of terminal 
(Note the rounding that is automatically performed.) 
As with the words 
F. 
and 
o. 
the format control (by executing w.o) need only be specified once for a 
sequence of numbers. 
The word 
E. 
is used to print floating-point numbers with an explicit exponent. 
The word 
w.o 
is used as above to control the printing of the fraction which is 
then followed by 
'E', 
followed by a 3-digit exponent. 
For example, 
3.14159 E. 
.314159 E. 
314L5.9 E. 
8 
3 
W.O 
wi 11 output 
will output 
wi 11 output 
3.142EO 
3.142E-1 
3.142E4 
In floating-point output using either E. 
or 
F. 
the user must be careful 
not to print more than 9 significant digits -- doing so will cause an asterisk 
to be printed preceding the number, indicating overflow on conversion. 
This 
means that very small numbers and very large numbers must be output with 
E. 
and not with 
F •• 
Oct. 1979 
14-7 

The word G. 
will print a floating-point number using either E. 
or 
F., depending on the size of the number. 
If the number is either too large 
or too small for 
F. 
then 
E. 
will be used. 
Note that the words? 
E? 
F? 
and G? 
do not pr i nt the top number on 
the stock, rather they require the address of the number to be printed to 
be on top of the stack. 
For example, given the definition 
0 
VARIABLE 
A 
o. 
REAL 
B 
then 
A iil 
B Fiil 
F. 
are equivalent to 
A 
? 
B 
F? 
One is simply combining the two words 
iil 
and 
into the word 
? 
This 
combining of two or more words into a single word is discussed more thoroughly 
in Section 15.4. 
14-8 
Oct. 1979 

EXERCISES -
CHAPTER 14 
1) 
Define a word named 
IMIN 
that reads a sequence of non-negative 
integers from the operator and prints the minimum value. 
The end 
of the input is signalled by a negative number being entered, at 
which point the minimum should be printed. 
2) 
A Fibonacci number is a number in the infinite sequence 
0,1,1,2,3,5,8,13,21,34 
where the first two terms are ° and 1 and each successive term is 
the sum of the two preceding terms. 
Define a word named 
FIB 
that calculates and prints all Fibonacci numbers < N where N is the 
integer on top of the stack. 
For example 
20 FIB 
should print 
0 
1 
1 
2 
3 
5 
8 
13 
Oct. 1979 
14-9 

15. 
ADVANCED ARITHMETIC 
This chapter complements Chapters 5 and 7 by completing the description 
of the arithmetic words available in FORTH. 
15.1 
~MERICAL FUNCTIONS 
A table of the standard numerical functions provided by FORTH Is given 
in Table 15.1. 
The operation of all these words is similar in that they 
all expect one or more parameters on the stack and then after popping 
the parameter(s) from the stack the result(s) are pushed onto the stack. 
The naming convention of these arithmetic words is to prefix the name 
wi th a 
liD II 
if the word operates on a double-word integer 
or a floating point number, respectively. 
The second character of a 
trigonometric word wi 11 be 
liD II 
if the mode is degrees or 
IIRII 
if 
the mode is radians. 
Feb. 1977 
15-1 

\on 
I 
N 
o 
(') 
rt 
\.D 
-.....J 
\.D 
I 
S I NGL-E-WORD 
INTEGER 
*/ 
MOD 
/MOD 
MINUS 
ABS 
MAX 
MIN 
SQRT 
DOUBLE-WORD 
FLOATI NG 
INTEGER 
POINT 
D*/ 
DMINUS 
FMINUS 
DABS 
FABS 
DMAX 
FMAX 
DMIN 
FMIN 
FSQRT 
FDSIN 
FDCOS 
FDTAN 
~--
---
-
DESCRIPTION 
Multiplies the second number on the stack by the third 
number on the stack, forming a double-word integer 
temporary result. 
This temporary result is then 
divided by the top number on the stack leaving a 
single-word integer result on top of the stack. 
Divides the second number on the stack by the top 
number on the stack, leaving the remainder on top 
of the stack. 
(See note 1) 
Divides the second number on the stack by the top 
number on the stack, leaving the quotient on top of 
the stack and the remainder below. 
(See note 1) 
Changes the sign of the top number on the stack. 
Replaces the top number on the stack with its absolute 
value. 
Replaces the top two numbers on the stack with the 
larger of the two numbers. 
Replaces the top two numbers on the stack with the 
smaller of the two numbers. 
Replaces the top number on the stack with its square 
root (SQRT calculates the single-word integer 
truncated square root of a double-word integer). 
Replaces the top number on the stack (an angle in 
degrees) with either is sine, cosine or tangent. 

3: 
!lJ 
-< 
1.0 
""-J 
00 
-' 
V1 
I 
W 
SINGLE-WORD 
DOUBLE-WORD 
FLOATING 
DESCRIPTION 
INTEGER 
INTEGER 
POINT 
FDA TN 
Divides the second number on the stack by the top 
number on the stack and then interprets the result 
as an angle (in degrees) and leaves its arctangent 
on top of the stack. 
(See note 2) 
F2XP 
Replaces 
x 
by 
2x 
(where 
x 
is the top number on 
the stack). 
FEXP 
Replaces 
x 
by 
eX. 
FEXP10 
Replaces 
x 
by 
lOx. 
FLN 
Replaces 
x 
by 
tn(x). 
F2LOG 
Replaces 
x 
by 
1092(X). 
FLOG 
Replaces 
x 
by 
I ogl 0 (x) . 
~-~ 
Notes: 
1. 
The sign of the remainder will be the sign of the dividend. 
2. 
The result will be in the range [0,360). 
Table 5.1 
ARITHMETIC FUNCTIONS 

The following examples should elucidate some of the descriptions given 
in Tab 1 e 5. 1 . 
80 
20000 
2 
2 
20000 
80 
*/ 
3 
7 
7 
3 
MOD 
3 
5 
16 
16 
3 
/MOD 
5 
MINUS 
15-4 
(note that the intermediate product 
= 40,000 which requires the 
double-word intermediate result) 
3 
5 
5 
3 
MOD 
5 
9 
45 
o 
45 
5 
/MOD 
-
-28 
-
-
28 -
-28 , 
DMINUS 
Oct. 1979 

-
I-
-
-90.5 
90.5 
r-
-
r--
-
-90.5 
FMINUS 
-100 
ABS 
I-
-
-1.5 
1.5 
r-
124 -
f-
124 -
-
124 , 
DABS 
-1.5 
FABS 
-
-
-8.9 -
,-
-
r-
-
-4 
10.5 
10.5 
W 
--
-
r-
-
-5 
-5 
-4 
MAX 
10.5 
-8.9 
FMAX 
Oct. 1979 
15-5 

3 
6 
~ 20000 -
I-
40000 
20000, 
6 
3 
D*/ 
-
-" 
1.4 -
f-
-
..-
-
-4 t=j 
1.5 
1.4 
-
-
I-
-
-5 
-5 
-4 
MIN 
1.5 
1.4 
FMIN 
-
- -
-
2.0 
1 .41421 
8. 
-
-
-
I-
-
8, " 
SQRT 
2.0 
FSQRT 
15-6 
Oct. 1979 

15.2 
MIXED PRECISION OPERATORS 
Mixed precision arithmetic operators perform arithmetic on numbers of 
different modes. 
In FORTH the mixed precision words usually operate on 
a single-word integer and a double-word integer. 
For example, the word 
+ 
adds together two single-word integers, the word 
D+ 
adds together 
two double-word integers and finally the mixed precision word 
M+ 
adds 
a single-word integer to a double-word integer, leaving of course, a 
double-word result. 
Similar to the prefixing of double-word operators 
and floating point operators with 
the mixed precision 
operators are prefi xed wi th an 
11M II • 
M+ 
Adds a single-word integer on top of the stack to the double-word 
integer below, leaving the double-word integer sum on top of the 
stack. 
2 
~ 59 
-
r-
61 
-
59, 
2 
M+ 
M* 
Multiplies the single-word integer on top of the stack by the 
single-word integer below, leaving the double-word integer product 
on top of the stack. 
(This word differs from the word * in that 
* calculates only a single-word integer product while 
M* 
calculates the full double-word integer product.) 
8 
I- 80000 -
10000 
10000 
8 
M* 
Oct. 1979 
15-7 

15-8 
2M* 
Multiplies the single-word integer on top of the stack by the 
double-word integer below, giving a double-word integer result. 
8 
r- 10000 -
~ 80000 -
10000, 
8 
2M* 
M/ 
Divides the double-word integer in the second position on the 
stack by the single-word integer on top of the stack, leaving 
the single-word integer' quotient on top of the stack. 
M/MOD 
10 
I- 60002 -
60002, 
10 
M/ 
Divides the double-word integer in the second position of the 
stack by the single-word integer on top of the stack, leaving 
the single-word integer quotient on top of the stack and the 
single-word integer remainder below. 
10 
6000 
I- 60002 -
2 
60002, 
10 
M/MOD 
Oct. 1979 

15.3 
ARITHMETIC RANGE ERRORS 
In the implementation of KPNO Varian FORTH it was decided to ignore all 
arithmetic range errors, that is overflow and underflow. 
Overflow 
occurs when the result of an operation requires more precision than is 
provided. 
For example, the largest positive single-word integer that 
may be represented is 32,767 (Section 7.1) hence the sequence 
20000 
20000 
+ 
will generate an erroneous result since the result (40,000) is larger 
than 32,767. 
Similarly, the sequence 
40000, 
SFIX 
will also produce an erroneous result. 
Overflow can also occur in 
floating-point operations if the range of the exponent exceeds the 
largest possible exponent. 
Underflow can also occur in floating point 
operations if the exponent is smaller than the smallest possible 
exponent. 
Fortunately in Varian FORTH the range of the exponent in a 
floating-point number is large enough so that exponent overflow and 
exponent underflow are extremely unlikely. 
However, standard arithmetic 
overflow is a likely possibility and it is up to the user to determine 
the probable range of his variables when writing a program and use the 
appropriate data structures so as to avoid overflow. 
O~t. 1979 
15-9 

15.4 
COMBINED WORDS 
In the interest of core efficiency and execution speed, there exist 
many "combined" words which take two or more commonly used words (which 
are executed in sequence) and combine them into a single FORTH word. 
For example, in Chapter 14 we saw where the sequence 
a 
was combined into the word 
1. 
If the original sequence (a 
in 
this example) appears more than 5 times in one's program then the defini-
tion of the word 
1 
and its use will reduce the amount of memory used by 
the program. 
This technique is the essence of FORTH - combining primitive 
operators into more general and useful words. 
Some additional words which one is bound to encounter are: 
'1+ 
eguivalent to 
1 
+ 
I-
I 
2+ 
2 
+ 
2* 
2 
* 
2/ 
2 
/ 
02* 
2 
1 
0*/ 
02/ 
1 
2 
0*/ 
F2* 
2.0 
F'* 
F2/ 
2.0 F/ 
+! 
+ 
F+! 
F+ 
F! 
FSQ 
30UP 
F* 
1+: 
,1+ 
1-: 
1-
One could define these words as one would expect, for example 
1+ 
1 
+ 
and this wi 11 work fine, however, many of the commonly used words 1 isted 
above are coded directly in machine language thereby providing a decrease 
in execution time in addition to a decrease in memory requirements. 
One should always use these combined words, rather than the original 
sequence, as the implementation of a particular FORTH system may take 
advantage of certain machine features in order to optimize the combined 
word. 
For example, in KPNO Varian FORTH the words 
2* 
2/ 02* 
and 
02/ 
15-10 
Oct. 1979 

are all implemented as arithmetic shifts. 
The words 
F2* and 
F2/ are implemented as an increment or decrement by one of the 
floating-point number's exponent. 
The word 
1+! 
is implemented 
by a single machine instruction. 
Oct. 1979 
15-11 

EXERCISES - CHAPTER 15 
1) 
Define a word named 
?ODD/EVEN 
that will test the integer on top 
of the stack and then print either 
"000" 
or 
"EVEN". 
2) 
If the top word on the stack is a double-word integer representing 
the number of seconds past midnight, define a word named 
?TIME 
that takes this value and prints the hour, minute and second. 
Sample values are: 
1 , 
---> 
0 
(hours) 
0 
(minutes) 
1 
(seconds) 
60. 
---> 
0 
1 
0 
3600, 
---> 
1 
0 
0 
14399, 
---> 
3 
59 
59 
30332, 
---> 
8 
25 
32 
3) 
Define a word named 
QUAD 
that solves the quadratic equation 
15-12 
using the formula 
ax2 + bx. + C = 0 
-b ± Ib~ - 4ac 
2 iii 
The parameters a, b & c will be the top three floating-point numbers 
on the stack, (c on top, b below c and a below b). 
The output should 
indicate the type of solution (one real root, two real roots or two 
complex conjugate roots). 
For example 
1.0 
5.5 
-10.5 
QUAD 
should print 
TWO REAL ROOTS: 1.5 -7.0 
4.0 
-292.0 
5329.0 
QUAD 
should print 
ONE REAL ROOTz 36.5 
Oct. 1979 

Oct. 
3.0 
1.0 
5.0 
QUAD 
should print 
TWO COMPLEX ROOTS (REAL & 
COMPLEX PARTS): 
-.16667 1.28019 
4) 
Define a word named 
FDASINE 
that calculates the angle (in 
degrees) whose sine is the floating-point number on top of the 
stack. 
Use the equation 
arcsin(x) 
For example 
0.0 
FDASINE 
F. 
1.0 
FDASINE 
F. 
-0.5 
FDASINE 
F. 
= 
= 
= 
arctan [~1 
90
0 
-90
0 
should print 
should print 
should print 
Be sure to handle the case of x = ± 1 . 
I x I 
x 
x 
< 
= 
= -1 
0.0 
90.0 
-30.0 
5) 
Define a word named 
FDACOS 
that calculates the angle (in degrees) 
whose cosine is the floating-point number on top of the stack. 
Use the equation 
arccos (x) 
= 
180 - arcsin (A - x2 ) 
-1 < 
x 
< 
0 
= arcs in (/1 - x2 ) 
o < 
x 
< 
For example 
0.0 
FDACOS 
F. 
should print 
90.0 
1.0 
FDACOS 
F. 
should print 
0.0 
'-0.5 
FDACOS 
F. 
should print 
120.0 
1979 
15-13 

15-14 
6) 
Define a word named 
x**y 
that raises a floating-point number 
x 
(second number on the stack) to the floating-point power 
y 
(top number on the stack). 
Use the formula 
= 
y(R-n x) 
e 
(where 
e = 2.71828182). 
Print an error message if 
x < 0 
(since ~n x is undefined for negative arguments). 
For example 
5.0 
2.0 
X**Y 
F. 
2.0 
12.0 
X**Y 
F. 
should print 
should print 
25.0 
4095.99922 
Using the word 
named 
FCUBERT 
X**y 
from the previous exercise, define a word 
that calculates the cube root of the floating-
point number on top of the stack. 
The argument may be negative in 
which case the final answer must then be negated (to avoid the error 
message from 
x**y). 
For example 
64.0 
FCUBERT 
F. 
-8.0 
FCUBERT 
F. 
should print 
should print 
4.0 
-2.0 
8) 
Define a word named 
FROUND 
that will round a floating-point 
number prior to the floating-point number peing truncated by 
either SFIX 
or DFIX. 
4.4 
FROUND 
SFIX 
4.5 
FROUND 
SFIX 
For example 
should print 
should print 
4 
5 
Oct. 1979 

9) 
Define a word named 
I **J 
that raises a single-word integer, 
(second number on the stack) to a single-word integer power, 
j 
(top number on the stack). 
Use the formula given in exercise 6 
above. 
For example 
10 
3 
I**J 
7 
5 
I**J 
should print 
should print 
1000 
16807 
10) 
Defi ne a word named 
CUBE 
that cubes the sing 1 e-word i ntege r on 
top of the stack •. For example 
1 
CUBE 
-5 
CUBE 
Use the word 
I**J 
should print 
should print 
1 
-125 
from the previous exercise. 
11) 
Instead of using the word 
I**J 
in forming the cube of a single-
word integer (previous exercise) one could define 
CUBE 
as 
: CUBE 
DUP 
DUP 
* * 
Which definition do you think is preferable and why? 
12) 
An iterative algorithm is one that repeats itself (iterates) until 
a certain value is within a specified range. 
For example, an 
Oct. 19.7-9 
iterative algorithm to determine the square root (y) of a number (x) is 
= 
.5903 x 
+ 
.4173 
= l(y. + L ) 
2 
I 
y. 
= 0,1,2, •.. 
I 
In this example the initial approximation (Yo) is calculated and 
then used to calculate y 1· 
Y1 is then used to calculate Y2' Y2 is 
then used to calculate Y3' etc. 
The algorithm termi nates when the 
value y converges to its 1 i mit i ng va 1 ue. 
This is determined by 
15-15 

15-16 
\Yi+l - Yi \ 
r yij 
< E: 
where 
£ 
is some predefined constant. 
If you want the square root 
to be accurate to five decimal places then 
E = 0.00001. 
Define a 
word named 
SQROOT 
that calculates the floating-point square 
root of the floating-point number on top of the stack, using the 
iterative technique described above. 
Be sure to handle negative 
arguments! 
For example 
81.0 
SQROOT 
F. 
2.0 
SQROOT 
F. 
13) 
Def i ne a word named 
ECALC 
should print 
should print 
9.0 
1.41421 
that calculates e 
(the base of the 
natural logarithms, 2.718281828459045) using the infinite series 
e = 
1 
+ 
1 
+ 
1-2-3 
1-2-3-4 
There should be no storing of intermediate results in memory 
locations (use the stack!). 
This is another example of an 
iterative algorithm. 
14) 
Using the formula 
n! 
= 
factorial (n) 
= 
1 *2*3";" 
define a word named 
FACT 
that calculates and prints the single-
word integer factorial of the single-word integer value{n) on top 
of the stack. 
If 
n 
is not in the range 
o < 
n 
< 7 
output an error message instead of calculating the factorial. 
(Note: 
factorial (0) = 1 by definition). 
Oct. 1979 

15) 
Why is 7 used as the upper limit of n in the previous example? 
16) 
As you can see from the previous examples the value of factorial {n} 
grows very rapidly as n increases. 
If we are interested only in an 
approximation to factorial {n}, instead of its exact integer value, 
we can use Stirling's approximation to n! 
n 
/inn (!!.) 
e 
< 
n! 
< 
n 
r.:-- (_n) 
v'2nn 
e 
(1 + 
) 
12n-1 
(where e = 2.71828182 
and 
n = 3.14159265). 
Define a word named 
N! 
which calculates the upper and lower bounds of n! where n is 
the single-word integer on top of the stack. 
Use the E format for 
printing the values. 
Note that the word 
x**y 
from exercise 6 
above must also be used here. 
For example 
3 
N! 
should print 
5.8362 E 0 
< 
3! 
< 6.0030 
4 
N: 
should print 
2.3506 E 1 
< 
4: 
< 2.4006 
5 
N: 
should print 
1.1802 E 2 
< 
5 ! 
< 1.2002 
100 
N! 
should print 
9.3248 E 157 
< 
100! 
< 9.3326 E 
157 
17) 
Define a word named 
STAT 
which inputs a series of numbers and 
O~t. 1979 
calculates their mean and standard deviation. 
When the word is 
executed it should first ask the operator how many numbers are to 
be input (a single-word integer) and then input each (floating-
point) number. 
After the last number has been entered the mean and 
standard deviation should be calculated using the formulas below, 
and then output. 
mean 
= 
n 
std. dev. 
= 
nE(X i )2 -
(EX i)2 
n (n-l) 
15-17 
E 0 
E 1 
E 2 

15-18 
where 
n is the number of items input and 
X. 
I 
is each separate 
number that is input. 
For example 
STAT 
HOW MANY NUMBERS? 
4 
?4.0 
?6.0 
?4.0 
?6.0 
MEAN 
= 5.0 
STD DEV 
= 
1. 1547 
18) 
The greatest common division (GCD) of two integers a & b is the 
largest integer that evenly divides both a and b. 
For example, 
GCD(20,25) = 5; GCD(20,40) = 20. 
A classical algorithm found in 
computer science texts is Euclid's algorithm for finding the GCD. 
This algorithm may be stated as: 
For 
r = (a mod b) 
(i .e. - r equals the remainder 
of a divided by b) 
If (r=O) then the answer is b, stop. 
a 
= 
b 
b = r 
loop around 
example, we find 
a 
= 
27 
21 
b 
= 
21 
6 
r 
= 
6 
3 
that GCD(27,2l) = 3 as follows 
6 @.-
answer 
0 
(Note that this algorithm works regardless whether a>b or b>a 
initially.) 
Oct. 1979 

Write a word in FORTH named 
GCD 
that expects two single-word 
integers on the stack and then calculates and prints their 
greatest common divisor. 
For example, entering 
27 
21 
GCD 
should print 
3. 
Calculate GCD(2166, 6099). 
19) 
Frequently one encounters the problem of calculating the mean of 
a large group of single-word integers. 
These values could, for 
example, be a sequence of integer data points read in by the 
program from some data collection instrument. 
Assume that we 
have a vector defined as 
Oct. 1979 
2047 
()DIM 
DATA 
containing 20.48 points. 
Define a word named 
M+RMS 
that 
calculates and prints both the mean and the rms (root mean 
squared) of the data vector. 
The rms is defined as the square 
root of the average of the squares of each point. 
One would 
like to avoid the use of floating-point arithmetic as on a 
mini-computer without floating-point hardware these operations 
take considerable time to execute. 
This additional time is 
even more noticeable when a large vector of numbers is being 
operated on. 
However, single-word integer arithmetic is 
definitely unacceptable for both the mean and the rms as there 
is an almost definite probability that the sum of a couple of 
numbers will overflow a single-word value. 
If we think of usinq 
double-word integer arithmetic then consider the square of the 
largest data point (32,767)--its value is 1,073,676,289 which 
is almost the largest value that may be stored in a double-word 
integer (Section 7.2). 
We then see that forming the sum of 
the squares of a vector of integers could possibly overflow a 
double-word sum. 
We could probably form the sum of all the 
numbers (for the average) as a double-word sum as it would 
take 32,768 numbers, each having the largest possible value 
(32,767) to overflow a double-word sum. 
To do this and perform 
15-19 

t5-20 
only one pass over the data would require that we keep both a 
floating-point sum and a double-word integer sum on the stack 
together. 
Manipulating these two sums in an alternate manner 
is very clumsy in FORTH so we resign ourselves to using only 
floating-point arithmetic. 
In order to make this word as general as possible define the word 
o 
CONSTANT 
NOP 
to contain the number of points (1-2048) in the vector DATA. 
Set NOP to 5 and calculate both the mean and rms of the data 
points 
16~ 105 
18~291 
14,333 
17,015 
15,280 
20) 
The algorithm used in the previous problem to calculate the 
mean of a group of integers (forming the sum of all the 
numbers and then dividing by the number of points) is not 
always satisfactory. 
One can conceivably imagine a very large 
set of data points (say on the order of one million points) in 
which case neither a double-word sum nor a floating-point sum 
would suffice. 
The double-word sum would overflow and the 
floating-point sum would get so large that the data points 
being added to it would be equivalent to zero (a floating-point 
number has only a finite precision). 
One solution to this 
problem is the stable running mean algorithm. 
If we have a 
sequence of data points 
X. 
we calculate the new mean of 
I 
the sequence Xl' X2, ... as 
+ 
(
X'I - °ildmean) 
newmean = oldmean 
Oet. t979 

Initially we must set oldmean = O. 
For example if we use the 
data points given in the previous problem we obtain 
newmean = o + (1610~ - 0) = 16105 
\ 
I 
newmean = 16105 + 18291 - 16105 
= 17198 
2 
~ 
~ 
newmean 
= 
17198 + 14333 - 17198 
= 
16243 
\ 
3 
I 
and so on. 
If we calculate the average of these three data 
points it also equals 16243, as we would expect. 
This 
algorithm is termed a "running mean" since we maintain the 
current mean at each interation. 
Here we do not have to worry 
about overflow as long as our data points are single-word 
integers. 
(One problem that may be encountered here is a 
sequential loss of precision in the integer divisions. 
This 
effect may be lessened by use of floating-point arithmetic.) 
Refine a word named 
RMEAN 
that calculates the mean of 
NQP 
number of points in the vector named 
DATA 
(see previous 
problem). 
Test this word using the five data points from the 
previous problem. 
Keep the values of newmean and oldmean 
on the stack! 
21) 
The following algorithm calculates the date of Easter for any 
year after 1582 
[Knuth, Donald E., The Art of Computer 
Programming, Vol. 1, Addison-Wesley, 1973]. 
Define a word 
named 
EASTER 
which prints the date of Easter, given the 
integer year on top of the stack. 
For example 
1977 
EASTER 
1978 
EASTER 
should print 
should print 
APRIL 10. 1977 
MARCH 26. 1978 
(All division in the algorithm is integer division). 
Oct. 1979 
15-21 

15-22' 
G = (YEAR mod 19) + 1 
(G is the golden number of the year 
in the 19- year Metonic cycle) 
C = (YEAR / 100) + 1 
(C is the century) 
X = «(3*C) / 4) - 12 
(correct i on for number of years in 
which leap year was dropped) 
Z = «(8*C) + 5) / 25) - 5 
(correction to synchron i ze Easter 
wi th the moon IS orbit) 
D = «5*YEAR) / 4) - X - 10 
(find Sunday) 
E = «ll*G) + 20 + Z -
X) mod 30 
IF (E < 0) E = E + 30 
IF «(E = 25) AND (G > 11)) OR (E = 24)) 
E = E + 1 
N = 44 - E 
IF (N < 21) 
N = N + 30 
N = N + 7 - «D + N) mod 
If (N > 31) then the date 
else the date 
7) 
is 
is 
(E is the epact which specifies 
when a full moon occurs) 
(The 
Nth 
of March is a full moon) 
(Advance to Sunday) 
Apri I (N-31 ) 
March 
N 
Define the necessary variables to be used as intermediate results 
and also try to use the stack as efficiently as possible. 
Oct. t 979 

16. 
REAL-TIME 1/0 
This chapter is the essence of what FORTH was originally designed 
for - the control of real-time data acquisition devices. 
The definition 
of the word IIreal-time" is itself quite obscure in the development of 
computing technology and is a frequently misused adjective. 
In this 
author's opinion a real-time device is one which, when it presents data 
to the computer, must be acknowledged by the computer within a certain 
limited time frame or else the original data is lost. 
This loss of 
data generally occurs because the device has already accumulated new 
data for the program. 
The speeds of real-time devices vary considerably 
and it is the speed of the computer along with the speed of the real 
time device(s) that determines the maximum data acquisition rate of a 
particular system. 
16. 1 
INTERRUPTS 
An interrupt is the facility whereby a device notifies the computer that 
the device requires service of some sort. 
Typical reasons for a device 
generating an interrupt are: 
the device has some data for the computer to input, 
the device has completed the output of the previous 
data and is ready to accept some additional data to output, 
the device has detected an error of some sort during 
an I/O operation. 
Once the computer is notified that a device requires service, the 
computer can start a program to handle the device. 
From a programming standpoint it is one's job to write a program that 
will service a specific device's interrupt. 
In reality the program 
that services a device's interrupt is generally only a small portion 
of a larger program and is therefore called an interrupt routine. 
Feb. 1977 
16-1 

The nitty gritty details of exactly how a device generates an interrupt 
followed by how the computer determines exactly which device is 
requesting the service are vastly different for each computer and 
beyond the scope of this primer. 
Suffice it to say that with KPNO 
Varian FORTH one writes a word to process a specific devicels interrupt 
and FORTH will then perform the required linkage to insure that this 
word will get control every time the specified device generates an 
interrupt. 
The actual definition of this word will be discussed in 
greater detail in the next section. 
A CAMAC interrupt (CAMAC is described in the next section) is referred 
to as a LAM which means that the device is telling the computer 
"Look At Mell . 
16.2 
CAMAC I/O 
16-2 
One problem that has plagued the users of mini-computers ever since 
their introduction has been the interfacing (i .e. - the electronic 
connection) of devices to a specific computer. 
Typical problems in 
this area are 
(a) 
a particular type of device requires a different interface 
for every different computer, 
(b) 
when you switch computers you must buy~ill .Qew interfaces for 
your devices (a favorite technique of mini-computer manufacturers 
to "lock" a customer into their series of computers). 
As a way around these problems the CAMAC standards were developed by 
the European Standards on Nuclear Electronics Committee (ESONE) in 1969. 
These standards have since been updated and recently adopted by the IEEE. 
CAMAC is a hardware system designed to provide simple, computer-
independent input and output. 
Standardized electronic components 
(modules) are joined together in one or more machine-independent 
Feb. 1977 

housings (crates) which are then connected to a specific computer via 
a single machine-dependent interface (the Branch Driver). 
The advantage 
in using CAMAC is that over 100 different devices may be connected to 
the computer through a single interface, thus simplifying the possible 
transition to a new computer. 
Additionally, there are over 70 companies 
worldwide producing CAMAC hardware thereby relieving the user from 
having to design and build his own specialized devices. 
Unfortunately in discussing any type of input/output, one must become 
more familiar with the specifics of the computer being utilized. 
In 
the case of this primer it requires that one understand that the 
computers in use at KPNO are Varian 620·s with a word size of 16-bits. 
Thus the previous references to a single-word integer are references 
to a 16-bit integer and the double-word integer is really a 32-bit 
integer. 
All data transfers between the Varian and CAMAC involve 24-bits. 
The CAMAC Module is the device that the program wishes to control -
it 
is the module that we must initialize when an I/O operation is to 
commence and it will be the module that will generate the interrupt 
when the I/O operation is finished. 
At a lower level, each module may 
be sub-addressed, to facilitate the control of multi-channel modules. 
As an example, the KPNO Timer II is a dual channel, high resolution 
timer and both channels are completely independent of each other (but 
both channels are packaged in a single module). 
To specify which 
channel you wish to control you must specify both the module and the 
sub-address; likewise when processing an interrupt from the timer you 
must determine which channel (i .e., sub-address) generated the interrupt. 
When addressing a CAMAC module a sub-address value between 0-15 (decimal) 
will be specified. 
In the programming of modules which do not require 
a sub-address, zero is commonly used. 
It should be noted that the 
sub-address does not always address separate channels in a multi-channel 
Feb. 1977 
16-3 

16-4 
module, instead in some modules the sub-address specifies additional 
functions for the module to perform (the KPNO Input/Output Register 
is a good example). 
Modules are housed together in CAMAC Crates with up to 23 modules per 
crate. 
Each module in a specific crate is addressed by specifying the 
slot number in the crate of the module. 
These slot numbers are also 
referred to as station numbers and have a value between 1-23 (decimal). 
Some modules physically require more than one slot in a crate (due to 
the width of the module) and the KPNO Display Panel Controller Module 
is an example of a module requiring two slots. 
These multi-slot modules 
are addressed by specifying only the lowest slot number of the module 
(for example the Display Panel usually occupies slots 20 and 21 and is 
addressed through slot 20). 
There may be up to seven crates in a CAMAC system and these crates are 
addressed as 1-7. 
The addressing required to select a specific module is therefore: 
C = Crate 
( I - ]) 
N = Station Number 
( 1 - 23) 
A = Sub-Address 
(0 -
15) 
F = Function Code 
(0 - 31) 
This sequence is generally referred to as CNAF. 
The Function Code is the method whereby you tell the selected module 
exactly what function it is to perform. 
There may be up to 32 (decimal) 
different Function Codes for a module (specified as 0-31) and although 
the codes will differ from one module to another, the general convention 
that is followed is: 
Feb. 1977 

Function 0 
8 
16 
24 
16.3 
FORTH CAMAC WORDS 
7 
-+ 
read 
15 
-+ 
control 
23 
31 
-+ 
wri te 
-+ 
control 
The programming of CAMAC input and output is actually much simpler than 
would appear from the previous section since FORTH handles most of the 
complicated details. 
The programming of a module from a colon 
definition is the subject of this section. 
Each specific CAMAC module is identified in FORTH as a word which 
identifies that specific module. 
In order to define a <module-ID> 
one wri tes 
<s lot-number> 
$CN; 
<module-ID> 
where <slot-number> is a single-word integer value between 1 and 23 
specifying the slot number in the crate. 
<module-ID> is the name 
assigned by the programmer to the module. 
For example, the following 
are from block 54: 
13 
$CN; 
$lIO 
14 
$CN; 
$210 
18 
SCN; 
$TM 
19 
$CN; 
$00 
I/O REGISTER 1 
I/O REGISTER 2 
TIMER MARK 11 
DIGITAL OSCILLATOR 
One should note that the convention used at KPNO is to prefix all CAMAC 
words with a dollar sign. 
Before executing the above definition one 
must store in the integer 
CRATE 
the crate number of the <module-ID> 
being defined. 
The definition of 
CRATE 
is 
1 
VARIABLE 
CRATE 
and this word is defined in block 50 (and will therefore be entered into 
the dictionary when the CAMAC blocks, 50 thru 53, are loaded when the 
word 
USER 
is executed). 
Oct. 1979 
16-5 

16-6 
Consider the example definition 
5 
CRATE 
19 
$CN; 
$5DO 
which defines the word 
$5DO 
as the device in slot 19 of crate 5. 
Now that we know how to identify each module we need a way to have a 
specific module execute a specific function. 
As would be expected, one 
defines a word in FORTH which when executed will perform the specified 
CAMAC I/O function. 
The general format of the definition is 
<F-code> 
<sub-address> 
<module-ID> 
<operation-type> 
<name> 
<F-code> 
<sub-address> 
<module-ID> 
Is a single-word integer value (between 0 and 31) 
that specifies the function code. 
Is a single-word integer value (between 0 and 15) 
that specifies the sub-address. 
Is a previously defined word which specifies both 
the crate and the station number of the module 
(described above). 
<operation-type> 
Is a system defined word (refer to the 1 ist below) 
which specifies what parameters are expected to be 
on the stack (prior to an output operation) or what 
parameters will be left on the stack (following an 
input operation). 
This word processes all the 
previous parameters «F-code>, etc.) and creates 
the appropriate dictionary entry for <name>. 
<name> 
Is the user specified identifier which will identify 
this specific I/O operation. 
When the word <name> 
is executed the I/O operation will be performed. 
Feb. 1977 

The following words are defined as <operation-types>: 
$COMMAND; 
$ACOMMAND; 
$READ; 
$AREAD; 
$2READ; 
$2AREAD; 
$WRITE; 
$AWRITE; 
$2WRITE; 
$2AWRITE; 
Feb. 1977 
Transmits a command to the module - no stack 
operations performed. 
Expects a single-word integer sub-address on top of 
the stack, then transmits a command to the module. 
Reads the low-order 16-bits of CAMAC data onto the 
top word of the stack. 
Expects a single-word integer sub-address on top of 
the stack, then reads the low-order 16-bits of CAMAC 
data onto the top word of the stack. 
Reads the full 24-bits of CAMAC data onto the top two 
words of the stack (see below for format). 
Expects a single-word integer sub-address on top of 
the stack, then reads the full 24-bits of CAMAC data 
onto the top two words of the stack (see below for 
format). 
Writes the word on top of the stack as the low-order 
16-bits of CAMAC data. 
Expects a single-word integer sub-address on top of 
the stack, then writes the next word on the stack as 
the low-order 16-bits of CAMAC data. 
Wr i te the two wo.rdson top of the stack as the fu 1 1 
24-bits of CAMAC data (see below for format). 
Expects a single-word integer sub-address on top of 
the stack, then writes the next two words on the stack 
as the full 24-bits of CAMAC data (see below for 
format). 
16-7 

16-8 
Note that the A-command format for each <operation-type> allows the 
specification of the sub-address when the word is executed, whereas the 
other format requires the sub-address to be specified when the word is 
defined. 
When defining a word with the A-command format the <sub-
address> in the definition must be specified as zero. 
Unfortunately, due to a peculiarity of the Varian hardware in processing 
double-word integers, the format of the 24-bit CAMAC data does not 
correspond to the format of FORTHls double-word integers. 
In order to 
convert between the two formats, the words 
PACK 
and 
UNPK 
are 
provided: 
PACK 
> 
FORTH double-word integer 
24-bit CAMAC data 
<----
UNPK 
Whenever 16-bits of CAMAC data are transferred a single-word integer 
is used. 
The following examples of some CAMAC definitions assume that the reader 
has available the write-ups on the specific module (which describes the 
interpretation of the <F-code> and <sub-address> for the specific 
module in question). 
8 
0 
$TM 
$ACOMMAND; 
+MOVE 
Defines the word 
+MOVE 
for the timer module as 
F(8) (i .e. - the <F-code> 8). 
This F-code will set 
the sign line to plus. 
Note that this word, when 
executed, expects the top of the stack to specify 
the sub-address, hence this word may be used for 
either channel of the timer. 
Feb. 1977 

1 
+MOVE 
2 
+MOVE 
3 
+MOVE 
Sets the sign of the timer Channel 
to plus. 
Sets the sign of the timer Channel 2 to plus. 
Sets the sign of both Channel 1 and Channel 2 of 
the timer to plus. 
16 
15 
$UD 
$2WRITE; 
UDCWRITE 
Defi nes the word 
UDCWR I TE 
for the up/down cou nter 
as F(16). 
This F-code writes 24-bits of data to the 
up/down counter. 
Note that the sub-address is 
specified as 15 (which equals 8 + 4 + 2 + 1) therefore 
this command will write to channels 1, 2, 3 and 4. 
50000, 
PACK 
UDCWRITE 
Writes 50,000 to channels 1, 2, 3 and 4 of the 
up/down counter. 
Note that the doub 1 e-word i ntege r 
must be 
PACKed 
prior to the I/O operation in 
order to convert it to the 24-bit CAMAC data format. 
2 
a 
$UD 
$2AREAD; 
UDCREAD 
Defi nes the word 
UDCREAD 
for the up/down coun ter 
as F(2). 
This F-code reads 24-bits of data from the 
specified channel (s) of the up/down counter onto the 
stack. 
8 
UDCREAD 
UNPK 
D. 
Reads the contents of the up/down counter's channel 4 
counter onto the stack, converts the 24-bit CAMAC 
word into a double-word integer and then prints 
the result. 
16 
2 
$DO 
$WRITE; 
DDOK2 
Oct. 1979 
Defines the word 
DDOK2 
for the DDO module as F (16). 
Th i sF-code wr i tes 16-b its of data to channe 1 2 of 
the DDO as the K-factor. 
16-9 

256 
DDOK2 
Wr i tes 256 as the K-factor for channe 1 2 of the DDO. 
Note that no conversion is required when reading or 
writing a single-word integer as 16-bits of CAMAC data. 
16.4 
FORTH INTERRUPT WORDS 
16-10 
The method of writing a sequence of FORTH words to process interrupts 
from a specific device is to use the words !: and ;!C to begin and 
terminate the definition, as follows: 
<mod u 1 e - I D> 
$ : 
! : 
<name> 
<words> 
<module-ID> 
$! 
: I 
<name> 
<words> 
; : 
; : c 
Identifies the device whose interrupts are to be 
processed. 
«module-ID> was described in Section 
16.2) . 
Starts the interrupt colon definition, similar to 
the standard 
Is the user specified identifier that identifies the 
dictionary entry for this definition. 
Are the names of previously defined FORTH words that 
will be executed when an interrupt occurs from the 
specified device. 
Terminates the interrupt colon definition, similar 
to the standard 
Terminates the interrupt colon definition, identical 
with ;! however, 
; ! c 
wi 11 cause a Branch Dr i ver 
stack "pOpll to be executed before returning to the 
interrupted routine. 
(This is the normal way to 
terminate an interrupt routine as the Branch Driver 
stack is automically "pushed" when an interrupt is 
acknowledged.) 
May 1978 

Once this definition is entered into the dictionary, all interrupts 
from the specified device will cause the specified sequence of <words> 
to be executed. 
The following example should elucidate many of the techniques in this 
chapter. 
We want to wr i te a word that keeps the t i me-of-day and will 
pri nt out the current t i me-of-day on demand. 
In order to "count" the 
time we will use the KPNO timer module to generate an interrupt every 
hundreth of a second (0.01 second). 
This interrupt routine will 
increment a double-word integer once every 0.01 seconds and the word 
WHATTIME 
will print the contents of this counter when executed. 
Additionally we need a word 
SETTIME 
which initializes the counter 
to a specified time. 
First the CAMAC function words: 
° 
1 
$TM 
$READ; 
TMRECLAM 
11 
1 
$TM 
$COMMAND; 
TMGO 
16 
1 
$TM 
$2WRITE; 
TMLOADPERIOD 
17 
1 
$TM 
$2WRITE; 
TMLOADN 
25 
1 
$TM 
$COMMAND; 
TMCLEAR 
27 
1 
$TM 
$COMMAND; 
TMENABLELAM 
The double-word integer counter: 
DPREC 
0, 
2VARIABLE 
COUNTER 
The interrupt processing routine, named 
TODINT: 
$TM 
$: 
:: 
TODINT 
TMRECLAM 
DROP 
COUNTER D@ 
:1. 
M+ 
COUNTER D: 
; : C 
Oct. 1979 
16-11 

16-12 
The word to output the current time-of-day: 
I 
WHATTIME 
2 
F 
( field width of 2 for numeric output ) 
COUNTER DOl 
1 
100 
0*/ 
( convert 0.01 sec. to sec. ) 
60 M/MOO 
60 /MOO 
(hours~ min.~ sec. ) 
S. 
II 
II 
S. 
II 
II 
S. 
The word to initialize the timer and input the current time-of-day 
from the operator: 
I 
SETTIME" I 
ENTER TIME (HH:MM:SS.) 
II 
OASK 
100 
1 
0*/ 
( convert sec. to 0.01 sec. ) 
COUNTER 0: 
( initialize counter ) 
10000, 
PACK 
TMLOAOPERIOO 
( 10~000 micro-sec. = 0.01 sec. ) 
999999, 
PACK 
TMLOAON 
( run for a long time ) 
TMENABLELAM 
( one interrupt on every pulse ) 
TMGO 
( start the timer ) 
Before executing these words one must execute 
$SETUP 
which initializes the CAMAC system. 
Oct. 1919 

The fol lowing points should be noted in the example: 
Channell of the timer is arbitrarily used (channel 2 could 
just as easily have been used). 
The double-word integer 
COUNTER 
is effectively counting the 
number of 0.01 seconds past midnight. 
The interrupt routine simply clears each LAM and increments 
the double-word counter. 
Since there are no double-word integer mUltiply and divide words 
(corresponding to 
* 
and 
F*, 
/ 
and 
F/) the word 
D*/ 
is used to mUltiply and divide double-word integers. 
The word 
SETTIME 
initializes the timer rate to 0.01 seconds 
(note the output to the timer must be specified in micro-seconds 
= 10-6 seconds) and sets the number of interrupts to 999,999. 
This latter number has no particular meaning in this example 
except to insure a sufficient number of interrupts (999,999 
interrupts divided by 100 interrupts per seconds = 9999 seconds 
a. 3 hours). 
The reader should enter these words into a block and then execute them 
to confirm that they perform as claimed. 
Furthermore you should 
thoroughly understand the example since many various techniques are used. 
Feb. 1977 
16-13 

"Would you tell me, please, which way I ought to go from here?" 
IIThat depends a good deal on where you want to get to," said the Cat. 
"I donlt much care where-- II said Alice. 
"Then it doesnlt matter which way you go," said the Cat. 
"_-so long as I get somewhere, II A lice added as an exp I anat i on. 
"Oh, youlre sure to do that," said the Cat, "if you only walk long enough. 11 
16-14 
LEW I S CARROLL 
Alicels Adventures in Wonderland 
Feb. 1977 

APPENDIX A - ASCI I CHARACTER SET 
a-Bit Octal 
8-Bit Octal 
7-B it 
with Paritl: 
7-Bit 
with Parit:t 
Octal 
Cha rac te r 
Even 
Odd 
Octal 
Character 
Even 
Odd 
000 
NUL (null) 
Cont ro I ISh i ft-P 
000 
200 
100 
@ (at sign) 
300 
100 
001 
SOH (start of header) 
Cont ro I-A 
201 
001 
101 
A (upper case alphabetlcs) 
101 
301 
002 
STX (start of text) 
Control-B 
202 
002 
102 
B 
102 
302 
003 
ETX (end of text) 
Control-C 
003 
203 
103 
C 
303 
103 
004 
EOT (end of transmission) 
Control-D 
204 
004 
104 
0 
104 
304 
005 
ENQ (enquiry) 
Control-E 
005 
205 
105 
E 
305 
105 
006 
ACK (acknowledge) 
Control-F 
006 
206 
106 
F 
306 
106 
007 
BEL (ring bell) 
Control-G 
207 
007 
107 
G 
107 
307 
... 
---
010 
BS (backspace) 
Cont ro I-H 
210 
010 
110 
H 
110 
310 
011 
HT (horizontal tab) 
Control-I 
011 
211 
111 
I 
311 
III 
012 
LF (line feed) 
Control-J 
012 
212 
112 
J 
312 
112 
013 
VT (vertical tab) 
Control-K 
213 
013 
113 
K 
113 
313 
014 
FF (form feed, top of page) 
Contro1-L 
014 
214 
114 
L 
314 
114 
015 
CR (carriage return) 
Contro1-M 
215 
015 
115 
M 
115 
315 
016 
SO (shift out) 
Cont ro 1 -N 
216 
016 
116 
N 
116 
316 
017 
SI (shift in) 
Contro1-0 
017 
217 
117 
0 
317 
117 
020 
OLE (data 1 ink escape) 
Contro1-P 
220 
020 
120 
P 
120 
320 
021 
DCI (device control l) 
Cont ro 1-Q 
021 
221 
121 
Q 
321 
121 
022 
DC2 (device control 2) 
Contro1-R 
022 
222 
122 
R 
322 
122 
023 
DC3 (device control 3) 
Cont ro 1-S 
223 
023 
123 
S 
123 
323 
024 
DC4 (device control 4) 
ContrOI-T 
024 
224 
124 
T 
324 
124 
025 
NAK (negative acknowledgment) 
C~ntro 1-U 
225 
025 
125 
U 
125 
325 
026 
SYN (synchronize) 
Control-V 
226 
026 
126 
V 
126 
326 
027 
ETB (end of transmission b1k) Contro1-W 
027 
227 
127 
W 
327 
127 
030 
CAN (canc"" I) 
Contro1-X 
030 
230 
130 
X 
330 
130 
031 
EM (end of medium) 
Contro1-Y 
231 
031 
131 
Y 
131 
331 
032 
SUB (substi tute) 
Contro1-Z 
232 
032 
132 
Z 
132 
332 
033 
ESC (escape) 
Contro1/Shift-K 
033 
233 
133 
[ 
(left bracket) 
333 
133 
034 
FS (fi Ie separator) 
Contro1/Shift-L 
234 
034 
134 
\ 
(back slash) 
134 
334 
035 
GS (group separator) 
C~nt ro 1 ISh i ft-M 
035 
235 
135 
] 
(right bracket) 
335 
135 
036 
RS (record separator) 
Control/Shift-N 
036 
236 
136 
t 
(up arrow) 
336 
136 
037 
US (un i t sepa rator) 
Contro1/Shift-0 
237 
037 
137 
<-
(back arrow) 
137 
337 
.--
040 
(space) 
240 
040 
140 
, 
(accent grave) 
140 
340 
041 
! 
(exclamation point) 
041 
241 
141 
a 
(lower case a1phabetics) 
341 
141 
042 
" 
(quote) 
042 
242 
142 
b 
342 
142 
043 
# 
(pound sign) 
243 
043 
143 
c 
143 
343 
044 
$ 
(dollar sign) 
044 
244 
144 
d 
344 
144 
045 
% (percent sign) 
245 
045 
145 
e 
145 
345 
046 
& 
(ampersand) 
246 
046 
146 
f 
146 
346 
047 
I 
(prime) 
047 
247 
147 
g 
347 
147 
----_._--------_. --.. __ ._--_ .. 
.-
050 
{ (left paren) 
050 
250 
150 
h 
350 
150 
051 
) 
(right paren) 
251 
051 
151 
i 
151 
351 
052 
* (asterisk) 
252 
052 
152 
j 
152 
352 
053 
+ 
(plus sign) 
053 
253 
153 
k 
353 
153 
054 
, 
(comma) 
254 
054 
154 
1 
154 
354 
055 
-
(minus sign, hyphen) 
055 
255 
155 
m 
355 
155 
056 
(period) 
056 
256 
156 
n 
356 
156 
057 
I 
(slash) 
257 
057 
157 
0 
157 
357 
-.. ------
060 
0 
(numer i cs) 
060 
260 
160 
p 
360 
160 
061 
1 
261 
061 
161 
q 
161 
361 
062 
2 
262 
062 
162 
r 
162 
362 
063 
3 
063 
263 
163 
s 
363 
163 
064 
4 
264 
064 
164 
t 
164 
364 
065 
5 
065 
265 
165 
u 
365 
165 
066 
6 
066 
266 
166 
v 
366 
166 
067 
7 
267 
067 
167 
w 
167 
367 
070 
a 
270 
070 
170 
x 
170 
370 
071 
9 
071 
271 
171 
y 
371 
171 
072 
: 
(colon) 
072 
272 
172 
z 
372 
172 
073 
; 
(semi-colon) 
273 
073 
173 
{ 
(left brace) 
173 
373 
074 
< 
(less than) 
074 
274 
174 
I (vertical bar/logical OR) 
374 
174 
075 
= 
(equals sign) 
275 
075 
175 
} 
(right brace) 
175 
375 
076 
> (greater than) 
276 
076 
176 
'V 
(t i Ide) 
176 
376 
077 
? 
(question mark) 
077 
277 
177 
DEL (delete, rub out) 
377 
177 
Feb. 1977 
A-l 

APPENDIX B -
FORTH ERROR CODES 
Whenever FORTH detects an error, a message is output to ~e terminal consisting 
of a question mark followed by a single character. 
This appendix describes the 
error associated with each single character code. 
?Q 
The word could not be found in the dictionary. 
Check for a possible 
typing error or a spelling error. 
?R 
Line printer off-l ine or disc error. 
In the case of a disc error, the 
sequence 
N 6 + @ 0 
will print the disc status word. 
?s 
Program abort (the word 
ABORT 
was executed by someone to ex it some 
piece of code). 
?T 
Magnetic tape error detected by the FORTH Block I/O drivers (probably 
the tape drive is off-line or there is no write-ring on a write opera-
t ion) . 
?U 
Stack underflow. 
A word or words were expected on the stack but the 
stack was empty. 
?v 
Dictionary and stack overflow. 
The combined size of the dictionary and 
the stack exceeds the total al located core area. 
This error indicates 
either too many words have been entered into the dictionary or else 
someone is pushing too many words onto the stack. 
?W 
Illegal disc block access. 
The block number of the requested disc block 
or tape block is illegal (i.e., - not in the range 0-4895). 
?x 
Input error following an asking-word request for a number or an unexpected 
interrupt from some device. 
?Y 
A magnetic tape error of some sort (tape drive off line, parity error, 
missing write ring on write, etc.) has been detected by the direct 
magnetic tape drivers. 
?Z 
Indicates a console interrupt (operator pressed Control-X key), a di splay 
panel interrupt (operator pushed the rightmost bottom pushbottom) or power-
fail recovery. 
Oct. 1979 
B-1 

APPENDIX C 
ANSWERS TO EXERCISES 
CHAPTER 5 
6 
7 
* 
5 
+ 
4 
* 
3 
+ 
2 
* 
1 
+ 
yields 
383 
empty ~ 
7 
5 
4 
6 t;j 
42 W 
47 
6 
7 
-* 
5 
+ 
4 
3 
2 
W 
188 W 
191 W 
382 t;j 
* 
3 
+ 
2 
* 
+ 
empty 
2) 
1 
2 
+ 
3 
4 
* 
+ 
9 
3 
/ 
/ 
7 
8 
* 
yields 
-51 
Feb. 1977 
C-l 

CHAPTER 5 
2) 
Continued 
4 
2 
3 
3 
12 
empty 
3 
3 
3 
2 
+ 
3 
4 
3 
8 
9 
9 
3 
7 
7 
15 
15 
15 
5 
5 
+ 
9 
3 
/ 
/ 
7 
8 
56 
5 t;j empty 
* 
C-2 
Feb. 1977 

CHAPTER 6 
1) 
a) 
SINY 
b) 
X+Y 
c) 
XANT 
d) 
XANT 
e) 
SINY 
f) 
none, wi 11 generate 
Y+XX 
?Q 
Feb. 1977 
C-3 

CHAPTER 7 
1) 
5 VARIABLE 
I 
100 
CONSTANT 
J 
I 
iii 
1 
+ 
I 
I 
iii 
5 
* 
t 
J 
I 
iii 
wi 11 pri nt 
6 
J 
wi 11 print 
30 
J 
J 
* 
10 
I , . 
I 
iii 
J 
/ 
2 
+ 
, J 
I 
iii 
wi 11 print 
890 
J 
wi 11 print 
31 
C-4 
Oct. 1979 

o 
C":\ 
rt 
U) 
........ 
\.0 
n 
I 
V1 
CHAPTER 7 
2) 
20 
VARIABLE 
A 
32 
CONSTANT 
B 
A @ 
B 
A @ lB ~ 
/ J + 
A-I 
v-
B 
v 
B 
A + A-1 
A + 
A 
+ 
A + 
A 
+ 
B 
A-l 
v 
B 
A 
A-l 
+ 
B 
B 
B 
A 
A-l 
B 
B 
A-l 
+ 
+ 
B 
A 
B 
will print the value 
21 
A @ 
v-
A 
B 
B 
/ 
+ 
/ 
+ 
B 

CHAPTER 7 
3) 
10 , 2VARIABLE 
I I 
30 , 
2 CONSTANT 
JJ 
JJ 
1 , 
D+ 
II D! 
JJ 
I I D@ 
D-
, JJ D! 
I I D@ 
D. 
wi 11 p r i nt 
31-
JJ 
D. 
wi 11 print 
-1. 
II D@ 
JJ 
D+ 
101, 
D+ 
I I D! 
JJ 
I I D@ 
D+ 
I 
JJ D! 
I I D@ 
D. 
wi 11 print 
131-
JJ 
D. 
wi 11 print 
130. 
4) 
1 
CONSTANT 
A 
5 
VARIA8L.E 
B 
8 
CONSTANT 
C 
25 
VARIABLE 
D 
B 
@ 
C D 
@ 
+ 
* 
I 
A 
A 
wi 11 print 
165 
B @ 
C 
* 
B 
@ 
D 
@ 
* 
+ 
, A 
A 
wi 11 print 
165 
C-6 
Oct. 1979 

CHAPTER 7 
5) 
3 , 
2CONSTANT 
A 
5 , 
2VARIABLE 
B 
7 , 
2CONSTANT 
C 
11 
2V)!llRl.ABLE 
D 
17 , 
2CONSTANT 
E 
B D@ 
C 
D+ 
D D@ 
D+ 
E 
D+ 
, A D: 
A 
D. 
wi 11 pri nt 
40 • 
B D@ 
C 
D D@ 
E 
D+ 
D+ 
D+ 
, A D: 
A 
D. 
wi 11 print 
40 • 
6) 
(B2 - 4AC) 
whose value wi 11 be 36.0. 
This value is left on the stack 
(since it is not specifically stored in a variable). 
n 
For a single-word integer the largest value is 32,767 which corresponds 
to 9:06:07. 
For a double-word integer the largest value is 1,073,741,823 
which corresponds to approximately 298,261 hours! 
Hence if you are 
counting the number of seconds past midnight you must use a double-word 
integer since a single-word integer does not provide sufficient precision. 
Octr .. 1979 
C-7 

CHAPTER 7 
8) 
9) 
10) 
C-8 
I 
@ SFLOAT 
X F@ 
F* 
A D@ 
B 
D-
DFLOAT 
F/ 
J 
SFLOAT 
Y 
FI 
FI 
t 
Y F! 
Y 
F. 
wi 11 print 
0.12002 
Note how the maximum accuracy (floating-point) is maintained throughout 
the calculation. 
There is no truncation performed unti 1 required 
(when the new value of B 
is stored). 
a) 
false, since its value is O. 
b) 
false, since 
(true 
false 
AND) 
---> false. 
c) 
true, 
since 
(true 
true 
AND) 
---> true. 
d) 
false, since 
(false false 
OR ) 
---> false. 
e) 
true, 
since 
(false true 
XOR) 
---> true. 
f) 
true, 
since 
(true 
true 
OR 
) 
---> true. 
2 
since 
= 
2. 
Feb. 1977 

CHAPTER 8 
1) 
Use the formula 
z = (X -
y) + (X - v). 
X D@ 
Y 
D-
X D@ 
Y 
D-
D+ 
• Z D! 
z 
D. 
wi 11 print 
-8. 
X D@ 
Y 
D-
2DUP 
D+ 
• Z D! 
z 
D. 
wi 11 print 
-8. 
2) 
X D@ 
2DUP 
Y 
D-
2SWAP 
Y 
D+ 
D+ 
• Z D! 
Z 
D. 
will print 
10. 
3) 
X D@ 
Y 
20VER 
20VER 
D-
D+ 
D+ 
• Z D! 
Z 
D. 
will print 
10. 
4) 
a) 
4 
5 
5 
9 
5 
5 
5 
5 
DUP 
4 
+ 
Feb. 1977 
C-9 

CHAPTER 8 
4) 
b) 
12 
3 
3 
3 
12 
12 
12 
12 
12 
12 
12 
3 
OVER 
SWAP 
DROP 
+ 
4) 
c) 
1 
2 
2 
3 
1 
Lj 
1 
1 
1 
3 
1 
1 
1 
1 
1 
DUP 
2 
OVER 
+ 
ROT 
1 
3 
1 
1 
2 
3 
3 
3 
6 
1 
3DUP 
2DROP 
+ 
* 
C-10 
Feb. 1977 

CHAPTER 8 
5) 
Yes, they are identical, as shown below: 
7 
4 
4 
7 
7 
7 
4 
OVER 
7 
4 
7 
7 
7 
4 
4 
7 
4 
SWAP 
DUP 
6) 
2PICK 
DUP 
1 
+ 
PICK 
SWAP 
PICK 
3PICK 
DUP 
DUP 
2 
+ 
PICK 
SWAP 
1 
+ PICK 
ROT 
PICK 
Det. 1979 
4 
7 
7 
4 
7 
7 
ROT 
ROT 
C-11 

CHAPTER 9 
1) 
I 1**4 
DUP 
DUP 
DUP 
* 
* 
* 
C-12 
, 1**4 
DUP 
* 
DUP 
* 
The second method is preferable since it requires one less 
mUltiplication than the first method. 
Feb. 1977 

CHAPTER 10 
1) 
a) 
2898, 
2899 
b) 
-4, 
-5 
c) 
-2, 
-4, 
-6 
d) 
-3 
e) 
-3 
f) 
18, 
12, 
6 
g) 
6. 
12 
h) 
-1 
2) 
: 1PROD 
1 
.11 
2 
DO 
I 
* 
2 
+LOOP 
3840 
will be printed. 
Also the following word will work (why?) 
I 
2PROD 
1 
12 
2 
DO 
I 
* 
2 
+LOOP 
3) 
I 
3PROD 
1 
2 
10 
DO 
I 
* 
-2 
+LOOP 
3840 
wi 11 be printed. 
4) 
o 
VARIABLE 
INDEX 
INCINDEX 
INDEX @ 
1 
+ 
INDEX! 
SUM3 
50 
INDEX 
o 
BEGIN 
INDEX 
@ 
+ 
INCINDEX 
INDEX 
@ 
100 
> 
END 
5) 
: DO= 
OR 
0= 
D= 
D-
DO= 
DO< 
SWAP 
DROP 
0< 
D> 
2SWAP 
D-
DO< 
I 
D< 
D-
DO< 
I 
DMAX 
20VER 
20VER 
D< 
IF 
2SWAP 
THEN 
2DROP 
: DMIN 
20VER 
20VER 
D> 
IF 
2SWAP 
THEN 
2DROP 
Oct. 
1979 
C-13 

CHAPTER 10 
6) 
7) 
8) 
9) 
10) 
C-14 
Note the order in which these words are defined, so that each word may 
use a previously defined word. 
The word 
DO= 
uses the fact that a 
double-word integer Is zero if and only If both single-word halves of 
the double-word are zero. 
Thus the 
OR 
of these two halves of the 
double-word will be zero if and only if both halves are zero. 
The word 
DO< 
uses the fact that the sign of a double-word integer is contained 
in the top half of the double~word and therefore the bottom half may be 
ignored for this comparison. 
I 
SIGN DUP 0= IF 
II Zll 
DROP 
ELSE 
0 
< 
IF 
II Nil 
ELSE • II p" 
THEN 
THEN 
EX 
1 
+ 
1 
DO 
I PICK 
LOOP 
19 
()DIM 
VEC 
· VINIT 
20 
0 
DO 
1 
I 
VEC 
LtJOP 
; 
• 
: 
( ). 
0 
DO 
CR 
DU? 
@ 
• 
1 
+ 
LOOP 
ORO? 
; 
2(). 
0 
DO 
CR 
DU? 
D@ 
D. 
2 
+ 
LOO? 
DHOP . 
• 
, 
• 3(). 
0 
DO 
CR 
DU? 
F8 
F. 
3 
+ 
LOOP 
DROP 
; 
5 
3 ( )DIM 
VC 
0 
CONSTANT 
N 
29.7 
0 VC F! 
-8.2 
1 VC F! 
-1.9 
2 
VC F! 
4.5 
3 VC F! 
0.52 
4 VC F! 
-8.3 
5 vC F! 
• 3VBUBSORf 
• N ! 
N 
1 
( 
1 , 2, • • • , N-l 
) 
• 
DO 
I 
N 1 -
( N-1, N-2, ••• , I 
) 
DO 
I 1 - VC F@ 
I VC F@ 
30VER 
30VEH 
F> 
IF 
3SIIIAP 
I VC F! 
I 
1 - VC F! 
EL.SE 
3DRO? 
3DRO? 
fHEN 
-1 +L.OOP 
L.OOP 
; 
Oct. 1979 

CHAPTER 14 
I 
IMIN 
SASK 
PUSH FIRST NUMBER ) 
BEGIN 
SASK 
DUP 
0 
< 
IF 
. II MIN VALVE 
=11 
SWAP 
ELSE 
MIN 
0 
THEN 
END 
DROP 
1 
Note how both halves of the 
IF 
branch leave a number on the 
stack -
1 (if the terminating negative number is encountered) or 
o (if another number was compared). 
< This 0 or 1 is then the 
<logical-condition> for the 
END 
word and only if the terminating 
2) 
negative number was entered does the 
BEGIN -
END 
loop stop. 
This is a common programming practice in FORTH and the stack is a 
convenient place to put the Ilflag il value. 
I FIB 
DUP 
3 
< 
IF 
II N MUST BE GREATER THAN 3 11 
DROP 
ELSE 
0 
1 
FIRST TWO FIB NUM 
) 
0 
BEGIN 
DUP 
( PRINT CURRENT 
OVER 
OVER 
+ 
ROT 
DROP 
COMPUTE NEXT IN SEQ. 
DUP 
4 
PICK 
> 
END 
3DROP 
THEN 
~1. 1979 
) 
C-15 

CHAPTER 15 
1) 
a ?ODD/EVEN 
2 
MOD 
IF. II ODD II 
ELSE 
II EVEN" 
THEN 
2) 
I 
?TIME 
60 M/MOD 
60 IMOD 
3) 
0.0 
REAL 
A 
0.0 
REAL 
B 
0.0 
REAL 
C 
: DISCR 
B F@ 
3DUP 
F* 
4.0 
A F@ 
F* 
C FCil 
F* 
F-
a QUAD 
C F: 
B F: 
A F: 
CR 
DISCR 
3DUP 
FO= 
IF 
3DROP 
II ONE REAL ROOT I II 
. 
B F@ 
FMINUS 
2.0 
A F@ 
F* 
F/ 
F. 
ELSE 
3DUP 
FO< 
IF 
II TWO 
COMPLEX 
ROOTS 
II 
II (REAL 
AND 
COMPLEX 
PARTS) all 
B F@ 
FMINUS 
2.0 
A F@ 
F* 
FI 
F. 
FMINUS 
FSQRT 2.0 
A F@ 
F* 
FI 
F. 
ELSE 
II TWO 
REAL 
ROOTS a II 
FSQRT 
3DUP 
. 
B F@ 
FMINUS 
3SWAP 
F+ 
2.0 
A F@ 
F* 
FI 
F. 
B F@ 
FMINUS 
3SWAP 
F-
2.0 
A F@ 
F* 
FI 
F. 
THEN 
THEN 
4) 
a FDASINE 
3DUP 
FABS 
1.0 
F= 
IF 
90.0 
F* 
ELSE 
3DUP 
3DUP 
3DUP 
F* 
1.0 
3SWAP 
F-
FSQRT 
FDATN 
3SWAP 
FO< 
IF 
360.0 
F-
THEN 
THEN 
c-16 
Oct. 1979 

CHAPTER 15 
5) 
; FDACOS 
3DUP 
3DUP 
F* 
1.0 
3SWAP 
F-
FSQRT 
FDASINE 
3SWAP 
FO< 
IF 
180.0 
3SWAP 
F-
THEN 
6) 
x**y 
30VER 
0.0 
F< 
7) 
IF." NEGAT I VE 
NUMBER 
ERROR" 
3DROP 
3DROP 
ELSE 
3SWAP 
FLN 
F* 
FEXP 
THEN 
Note that when using this algorithm 212 = 4095.99922 and not 4096! 
This is due to the inexactness of both floating-point numbers and the 
exponential/logarithm functions. 
If one knew that the exponent were 
an integer then a combination of mUltiplies would generate the exact 
answer. 
1.0 
3.0 
F/ 
FCONSTANT 
1/3 
: FCUBERT 
3DUP 
0.0 
F< 
IF 
FMINUS 
1/3 
X**Y 
FMINUS 
ELSE 
1/3 
X**Y 
THEN 
Note the technique used to obtain the maximum precision available for 
the infinite constant 0.333'" 
By dividing 1.0 by 3.0 in the definition 
you obtain the maximum precision available, regardless which computer 
you are running on. 
If, however, you were to enter 
0.33333 
FCONSTANT 
1/3 
you would not be obtaining the maximum precision on any computer with 
more than 5 digits of precision. 
To a computer the numbers 0.3 and 0.33 
are not equal! 
Oct. 1979 
C-17 

CHAPTER 15 
8) 
z FROUND 
0.5 
F+ 
9) 
& I**J 
2DUP 
SWAP 
SFLOAT 
FLN 
4 
PICK 
SFLOAT 
10) 
F* 
FEXP 
3SWAP 
3DROP 
FROUND 
SFIX 
Note the complications that arise in converting two single-word integers 
on the stack to floating-point, without storing either one in a 
temporary location. 
Of course, if this were a frequent operation 
one could define a new word to do it. 
& CUBE 
DUP 
0< 
IF 
MINUS 
3 
I**J 
MINUS 
ELSE 
3 
I**J 
THEN 
11) 
The second definition is almost certainly preferable in all cases since 
it requires only two mUltiplications and no conversion back and forth 
to floating-point. 
Note also that one need not worry about the sign 
with the second definItion. 
Finally, the first definition will take 
longer to ~xecute and will be less precise since the exponential and 
logarithm functions require time to execute and neither of these are 
perfectly "exact" (integer mUltiply wi 11 always be exact). 
12) 
0.00001 
FCONSTANT 
EPSILON 
& SQROOT 
3DUP 
FO< 
IF 
II NEGATIVE ARGUMENT II 3DROP 
ELSE 
3DUP 
0.5903 
F* 
0.4173 
F+ 
BEGIN 
30VER 
30VER 
F/ 
30VER 
F+ 
0.5 
F* 
3SWAP 
30VER 
F-
FABS 
EPSILON 
F< 
END 
3SWAP 
3DROP 
THEN 
c-18 
Oct. 1979 

CHAPTER 15 
13) 
0.000001 
FCONSTANT 
EPSILON 
z ECALC 
2.0 
2.0 
32767 
3 
DO 
30VER 
1.0 
3SWAP 
F/ 
30VER 
F+ 
3SWAP 
30VER 
F-
FABS 
EPSILON 
F< 
IF 
3DUP 
10 
8 
W.D. 
F . 
• II IN" 
I 
. ," ITERATIONS·· 
EXIT 
THEN 
3SWAP 
I 
SFLOAT 
F* 
LOOP 
3DROP 
3DROP 
3SWAP 
The algorithm used is: 
Prod 
= 2.0 
Oldsum = 2.0 
Do 
I = 3, 32767 
Newsum = Oldsum + (l/Prod) 
If (INewsum - Oldsuml 
.~ Epsilon) 
EXIT 
Oldsum = Newsum 
Prod 
= Prod * 
Continue 
The upper limit on the 
DO 
loop (32,767) is set to the largest integer 
value to guarantee that the loop is executed many times. 
In actual ity, 
the loop will terminate when the word 
EXIT 
is executed (when the 
newsum has satisfactorily converged to the oldsum). 
This exercise is 
a good example of stack manipulation and how it is hard to display in 
an algorithm the true efficient use of the stack. 
Oct, 1979 
C-19 

CHAPTER 15 
14) 
& FACT 
DUP 
0< 
OVER 
7 
> 
OR 
IF 
II N IS OUT OF RANGEl! 
DROP 
ELSE 
DUP 
2 
< 
IF 
1 
SWAP 
VALUE OF o! AND 
ELSE 
DUP 
BEGIN 
1-
DUP 
ROT 
* 
SWAP 
DUP 
3 
< 
END 
THEN 
DROP 
II FACTORIAL 
=11 
THEN 
15) 
Because 8! = 40,320 which exceeds the range of a single-word integer. 
16) 
2.71828182 
FCONSTANT 
E 
3.14159265 
FCONSTANT 
PI 
& N! 
SFLOAT 
3DUP 
2.0 
F* 
PI 
F* 
FSQRT 
30VER 
3DUP 
E 
F/ 
3SWAP 
X**Y 
F* 
6 
4 
W.D 
3DUP 
E. 
\I 
< 
\I 
30VER 
SFIX 
\I • 
< 
II 
. 
30VER 
12.0 
F* 
1.0 
F-
LO 
3SWAP 
F/ 
1.0 
F+ 
F* 
E. 
3DROP 
Compare the definitions of E and 
PI 
with the definition of 
1/3 
in exercise 7 of this chapter. 
Since there are no rational formulas 
for e and ~ we must specify each constant using as many digits of 
precision (9 decimal digits for KPNO FORTH, Section 7.3) as provided 
by the floating-point data structure. 
If this definition were used 
on a computer with a different number of digits of precision then 
the definitions for e and 
TI should be changed accordingly. 
1 ! 
C-20 
Oct. 1979 

CHAPTER 15 
17) 
0.0 
REAL 
lSUM 
SUM OF X[ IJ 
) 
0.0 
REAL 
2SUM 
SUM OF X[I]**2 
STAT 
0.0 
lSUM F: 
0.0 
2SUM F: 
II HOW MANY NUMBERS? " 
SASK 
0 
DO 
CR 
" ?" 
FASK 
3DUP 
. 
lSUM Fa> 
F+ 
lSUM F: 
3DUP 
F* 
2SUM Fa> 
F+ 
LOOP 
DUP 
SFLOAT 
lSUM Fa> 
3SWAP 
CR ." MEAN =" 
F. 
SFLOAT 
3DUP 
2SUM 
F~ F* 
lSUM Fa> 
3DUP 
F* 
F-
DUP 
2SUM F: 
F/ 
3SWAP 
3DUP 
1.0 
F-
F* 
F/ 
FSQRT 
CR ." STD DEV =" 
F. 
18) 
The shortest and most elegant (and possibly least obvious) solution is to 
rearrange the algorithm as follows: 
r = a 
a = b 
b = r 
r = (a mod b) 
If (r = 0) then the answer is b, stop. 
Loop around 
This is coded as 
Oct. 1979 
: GCD 
BEGIN 
SWAP 
OVER 
MOD 
DUP 
0= 
END 
DROP 
C-21 

CHAPTER 15 
18) 
Continued 
The rearranging of the algori'thm places the test for r = 0 at the end 
of the loop which allows the use of the BEGIN -
END 
loop. 
You 
should confirm to yourself that rearranging the algorithm this way 
does not affect the algorithm (i .e. - it still produces the right 
answer) . 
GCD(2166,6099) = 57 
19) 
2047 
()DIM 
D~'r~ 
o 
CONSr~NT 
NOP 
16105 
0 D~rA 
18291 
1 D~rA 
14333 
2 
D~r~ 
17015 
3 
DAT~ 
15280 
4 DATA 
5 
• NO~ 
M+RMS 
0.0 
( 
RMS SuM 
) 
0.0 
( 
ME~N SUM 
) 
NLJ~ 
0 
DO 
I 
DATA @ 
SFLO~T 
F+ 
( 
UPDATE ME~N ) 
3SIl;~P 
I 
DATA @ 
SFLOAT 
3DLJP 
F* 
F+ 
( 
HMS 
) 
3 Sw~;J 
LOOP 
NOP 
SF'LOAT 
F'I 
FROUND 
SF'IX 
II 
l~E~N =" 
• 
. 
NOP 
SF'LOAT 
FI 
FSQRT 
FHOUND 
SFIX • II 
~ HMS ,.. .. 
• 
20) 
: RMEAN 
0 
(IN IT IAL ME~N) 
NO? 
0 
DO 
DUP 
I 
D~TA @ 
SWAP 
I 
1 
+ 
I 
+ 
LOOP 
" 
ME~N =" 
• 
; 
C-22 
Oct. 1979 
; 

21) 
0 VARIABLE 
C 
0 VARIABLE 
D 
0 VARIABLE 
E 
0 VARIABLE 
G 
0 VARI:t\BLE 
N 
0 VARIABLE 
X 
0 VARIABLE 
Z! 
0 VARIABLE 
YEAR 
• NEASTEH 
DU? 
DU? 
YEAR ! 
. 
19 
MOD 
1 
+ 
G ! 
100 
/ 
1 
+ 
DU? 
DU? 
C ! 
3 * 
4 
/ 
12 
X ! 
8 * 
5 
+ 
25 
/ 
5 
C 
YEAR 
@ 
5 * 
4 
/ 
X @ 
10 
G @ 
1 1 * 
20 
+ 
e @ 
+ 
X @ 
0< 
IF 
30 
+ 
THEN 
DU? 
DU? 
E 
25 = G @ 
1 
> 
AND 
SWAP 
24 
IF 
E @ 
1 
+ 
E 
THEN 
44 
E @ 
DUP 
N ! 
21 
< 
IF 
N @ 
30 
+ 
N ! 
THEN 
N @ 
DU? 
7 
+ 
SWAP 
D @ 
+ 
1 
DU? 
DUP 
N ! 
; 
( RETURN 
EASTER 
NEASTER 
31 
> 
IF 
.. 
APRIL" 
ELSE 
.. 
MARCH" 
"," YEAR @ 
• 
31 
• 
• 
THEN 
Oct. J 979 
D ! 
30 
MOD 
DU? 
= 
OR 
MUD 
2 COPIES OF N ON SCACr{ 
) 
C-23 

APPENDIX D - FORTH GLOSSARY 
This glossary is an alphabetically ordered list of all standard KPNO 
FORTH words along with a brief description of the word. 
The alphabetical 
ordering corresponds to the ordering of the ASC11 character set (Appendix A). 
Additionally, a listing of the ASC11 ordering is given at the top of each 
page for quick reference (since FORTH uses so many non-alphabetic characters). 
Immediately following the name of a word, certain descriptor characters 
may appear within parentheses. 
These denote some special action or charac-
teristics: 
A 
The word belongs to the assembler vocabulary. 
A thorough des-
cription of the machine instructions is not given, instead the 
reader should refer to the Varian 620/f Computer Handbook. 
C 
The word may be used only within a colon-definition. 
A following 
digit (CO or C2) indicates the number of memory cells used when 
the word is compiled if other than one. 
A following + or - sign 
indicates that the word either pushes a value onto the stack or 
removes one from the stack during compilation. 
(This action is 
not related to its action during execution and may be implementa-
tion dependent.) 
E 
The word may not normally be compiled within a colon-definition. 
P 
The word has its precedence bit set; it is executed directly, 
even when encountered during compile mode. 
OLD 
The word exists in KPNO FORTH versions 2.3 and earlier. 
Following the optional descriptor characters, a symbol ic execution of 
the word is given, showing the parameters expected on the stack by the word 
and the result left on the stack (if any). 
The following notation is used: 
<ADDRESS> 
denotes a 15-bit machine address; 
<BLOCK#> 
denotes a FORTH block number; 
Feb. 1979 
0-1 

<BYTE-ADDRESS> 
<CHAR-CODE> 
<OW-VALUE> 
<FP-VALUE> 
<LINE#> 
<LOGICAL-VALUE> 
<NAME> 
<VALUE> 
denotes a 16-bit byte address; 
denotes a 7-bit integer value for a ASC11 character 
(see Appendix A) j 
denotes a double-word integer value; 
denotes a floating-point value; 
denotes a I ine number of a FORTH block; 
denotes a logical flag whereby a non-zero value 
specifies true and a zero value specifies false; 
denotes a FORTH name, that is, a sequence of ASC11 
characters whose first three characters and length 
will be used to identify an entry in the dictionary; 
denotes a single-word integer value. 
Any symbol that does not appear in the above I ist is a single-word integer 
value, unless the first two characters are OW (denoting a double-word integer 
value) or FP (denoting a floating-point value). 
This I ist is purposely not broken down into vocabularies (basic FORTH, 
Utility words, etc.) in order that one be able to locate a word quickly, 
without having to search many different 1 ists. 
It is expected that the 
greatest use of this list will be to aid someone who is going through a FORTH 
I isting, in being able to quickly locate a description of a word they are not 
familiar with. 
Numerous lists are provided at the end of the glossary to 
provide a logical grouping of words with similar functions. 
Since this list is not broken down by vocabularies, one should not ex-
pect to find all of these words defined in basic FORTH! 
In fact, only a 
small percentage of the words are defined in the basic FORTH system. 
In 
order to find just where on a FORTH tape a particular word is defined, simply 
obtain a cross reference of the tape (as with the XFORTH program, described 
in Append ix B of the "FORTH Systems Reference Manua 1") and from the cross 
reference find the block in which the word is defined. 
One is then able to 
0-2 
Feb. 1979 

exp1 icit1y load the word into the dictionary. 
Naturally, this procedure 
may have to be gone through more than once if the desired word requires other 
words to be in the dictionary. 
Feb. 1979 
D-3 
NOTE: D-4 blank in original.

FORTH GLOSSARY 
!"#$£'().+,-.10123456789:;<=>?@AZ[\]A_ 
, . . . 
!BLOCK 
!I/O 
# 
#D 
<VALUE> 
<ADDRESS> 
STORE <VALUE> AT MEMORY LOCATION <ADDRESS>. 
<ADDRESS> 
1: 
<NAME> 
••• 
;!C 
<ADDRESS> 
!: 
<NAME> 
••• 
;! 
START 
AN INTERRUPT PROCESSING COLON DEFINITION 
(SIMILA~ TO I). 
<ADDRESS> SPECIFIES 
THE 
LOW-CORE 
INTERRUPT 
VECTOR 
AODRESS, 
DESIGNATING 
WHICH 
DEVICE'S 
INTERRUPTS ARE TO BE PROCESSED BY 
THIS WORD. 
THE DEFINITION IS TERMINATED BY EITHER 
;!C 
OR 
;! 
(SIMILAR 
TO 
;). 
;!C WILL POP THE CAMAC BRANCH DRIVER BEFORE 
RETURNING FROM THE INTERRUPT. SEE $! AND CHAPTER 16. 
(OLD) 
RENAMED BUFFER. 
SAVES ALL THE SYSTEM FLAGS AND PARAMETERS THAT 
MUST 
BE 
SAVED 
PRIOR 
TO 
PERFORMING 
110 
FROM 
AN INTERRUPT WORD. 
THIS WORD 
INCLUDES THE EXECUTION OF FSAVE. 
AFTER PERFORMING THE 110 
THE 
INTERRUPT 
WORD 
MUST 
EXECUTE 
@I/O TO RESTORE THESE FLAGS AND 
PARAMETERS. 
( A ) 
SETS THE VARIABLE MODE TO 1, 
SPECIFYING AN 
IMMEDIATE 
OPERAND 
FOR THE NEXT MEMORY REFERENCE INSTRUCTION. 
A VARIABLE INDICATING THE NUMBER OF DIGITS APPEARING AFTER THE 
COMMA OR PERIOD, FOLLOWING AN INPUT NUMBER CONVERSION. 
#DEV 
(OLD) 
#MDEV 
#TER 
Feb. 1979 
RENAMED #MDEV. 
A CONSTANT WHOSE 
VALUE 
INDICATES 
THE 
PRIMARY 
MASS 
STORAGE 
DEVICE THAT FORTH IS RUNNING FROM: 
o = DISC 
1 = TAPE 
A CONSTANT WHOSE VALUE INDICATES WHAT TYPE OF TERMINAL IS BEING 
USED: 
1 
a TELETYPE 
2 
a TEKTRONIX 4010 
4 = TEe 
6 = LEAR-SIEGLER ADM-3A 
7 = TEXAS INSTRUMENTS TI-700 
D-5 

FORTH GLOSSARY 
!"#$&,()*+,-./0123456789:;<.>?@AZ[\]~_ 
$! 
<MODULE-ID> 
$! 
<ADDRESS> 
$2AREAD; 
$2AWRITE; 
$2READ; 
$2WRITE; 
CONVERTS 
THE 
CAMAC 
<MODULE-IO> 
INTO 
THE lOW-CORE INTERRUPT 
VECTOR <ADDRESS> FOR THAT MODULE 
(REFER 
TO 
BLOCK 
54 
FOR 
A 
LISTING 
OF 
THE STANDARD KPNO MODULE IDENTIFIERS). 
SEE!: AND 
CHAPTER 16. 
DE FI NE A CAMAC 110 WORD. SEE CHAPTER 16. 
DE FINE A CAMAC 1/0 WORD. SEE CHAPTER 16. 
DE FINE 
A C AMAC 110 WORD. SEE CHAP TER 16. 
DEFINE A CAMAC 110 WORD. SEE CHAPTER 16. 
$ACOMMANDj 
$AREAD; 
$AWRITEj 
$C 
$CNi 
$C OMMAND; 
$DBD 
$OIR 
$EBD 
$EIR 
D-6 
DEFINE A CAMAC 110 WORD. SEE CHAPTER 16. 
DEFINE A CAMAC 110 WORD. SEE CHAPTER 16. 
DEfINE A CAMAC 110 WORD. SEE CHAPTER 16. 
A CAMAC WORD TO SEND A CLEAR COMMAND TO THE MODULES IN CRATE 1. 
<VALUE> 
$CNj 
<NAME> 
DE FI NE <NA.ME> AS A CAMAC <MODULE-tO>. SEE CHAPTER 16. 
DE FINE A CAMAC 1/0 WORD. SEE CHAPTER 16. 
A CAMAC WORD TO DISABLE BRANCH DEMANDS AT THE CRATE 
CONTROLLER 
LEVEL. SEE $EBD. 
A 
CAMAC WORD TO DISABLE INTERRUPTS AT THE BRANCH DRIVER LEVEL. 
SEE $EIR. 
A CAMAC WORD TO ENABLE BRANCH DEMANDS AT THE 
CRATE 
CONTROLLER 
LEVEL. SEE $DBD. 
A 
CAMAC 
WORD 
TO ENABLE CAMAC INTERRUPTS AT THE BRANCH DRIVER 
LEVEL. 
SEE $DIR. 
Feb. 1979 

FORTH GLOSSARY 
! U#$£' ()*+,-.10123456789: ;<=>?@AZ[\J"_ 
$FX 
<VALUE> 
$FX 
<RESULT> 
<VALUE> MUST BE A CAMAC F CODF IN THE RANGE 0 
THROUGH 
31 
AND 
THIS 
VALUE IS THEN CONVERTED TO THE APPROPIATE EXC INSTRUCTION 
(FOR USE IN A SEQUENCE OF MACHINE INSTRUCTIONS). 
THE WORD 
$FX 
IS 
USUALLY 
FOLLOWED 
BY 
THE WORD, 
WHICH WILL PLACE 
THF-
EXC 
INSTRUCTION INTO THE NEXT AVAILABLE DICTIONARY LOCATION. 
$INITIALIZE 
$NOI 
$READ; 
A CAMAC WORD TO INITIALIZE THE BRANCH DRIVER. 
A CAMAC WORD TO 
CLEAR 
THE 
INHIBIT 
FLIP-FLOP 
IN 
THE 
CRATE 
CONTROLLER. 
DEfINE A CAMAC 110 WORD. SEE CHAPTER 16. 
$REPLACE 
$REPLACE 
<WORD1> 
<CHAR-STRING>$ 
$SETUP 
$\!iRITE; 
$Z 
Feb. 1979 
REPLACE 
ALL 
OCCURENCES 
OF 
<WORDl> 
BY 
THE 
SPECIFIED 
<CHAR-STRING> WHEN THE WORD FIX IS EXECUTED. 
<WORD1> 
MAY 
NOT 
CONTAIN 
ANY 
SPACES. 
<CHAR-STRING> 
STARTS 
WITH 
THE 
SECOND 
CHARACTER FOLLOWING 
<WORD1> 
(THE 
FIRST 
CHARACTER 
FOLLOWING 
<WORD1> MUST BE THE SPACE THAT TERMINATES <WORDl» 
AND INCLUDES 
ALL CHARACTERS, 
INCLUDING SPACES, 
UP TO BUT NOT INCLUDING THE 
DOLLAR SIGN. SEE REPLACE, WINIT AND FIX. 
A CAMAC WORD TO INITIALIZE AND RESET THE (AMAC SYSTEM. 
DEFINE A CAMAC 1/0 WORD. SEE CHAPTER 16. 
A CAMAC WORD TO SEND AN INITIALIZE COMMAND TO CRATE 1. 
~<CHARACTER> 
<CHAR-COof.> 
THE AMPERSAND CONVERTS THE <CHARACTER> IMMEDIATELY FOLLOWING IT 
TO ITS 7-BIT, 
ASCII CODE (AN INTEGER VALUE IN THE RANGE 0 THRU 
127). FOR EXAMPLE, THE SEQUENCE "£A" Will LEAVE THE OCTAl 
VALUE 
101 ON THE STACK. REFER TO 
A~PENDIX A FOR A COMPLETE LISTING OF 
ALL ASCII CODES. 
(P) 
<NAME> 
<ADDRESS> 
PUSH 
THE 
ADDRESS 
OF 
THE 
PARAMETER FIELD OF <NAME> ONTO THE 
STACK. 
A COMPILER DIRECTIVE, , IS EXECUTED WHEN ENCOUNTERED IN 
A COLON DEFINITION: THE 
ADDRESS 
OF 
THE 
PARAMETER 
FIELD 
OF 
<NAME> 
IS FOUND IMMEDIATELY (AT COMPILATION) AND STORED 
IN THE 
DICTIONARY (AFTER THE ADDRESS OF IlIT/) 
AS 
A LITERAL 
TO 
BE 
PLACED 
ON 
THE 
STACK 
AT 
EXECUTION 
TIME. 
WITHIN 
A 
COLON 
DEFINITION, 
THE 
SEQUENCE 
It, 
<NAME>" 
IS 
IDENTICAL 
TO 
THE 
SEQUENCE "/LITI [ 
• <NAME> , llf. 
D-7 

()DIM 
* 
** 
*1 
*10** 
*BLOCK 
D-8 
FORTH GLOSSARY 
(P) 
«STRING» 
THE 
LEFT 
PA~EN 
DESIGNATES 
THE 
START 
OF 
A COMMENT AND ALL 
CHARACTERS UP TO THE RIGHT PAREN ARE IGNORED. 
SINCE 
( 
IS 
A 
FQRTH 
WORD 
IT 
MUST 
BE TERMINATED BY A SPACE, 
HOWEVER, 
THE 
CLOSING PAREN NEED NOT 
BE PRECEDED BY 
A SPACE. 
UP 
TO 
1023 
CHARACTERS MAY COMPRISE THE COMMENT. 
<VALUE> 
()DIM 
<NAME> 
DEFINES 
A VECTOR 
OF SINGLE-WORD INTEGER VALUES. 
<VALUE> + 1 
CELLS OF MEMORY ARE ALLOCATED TO 
THE 
NAMED 
VECTOR 
AND 
THEN 
LEGITIMATE 
INDICES 
WILL 
BE 
IN 
THE RANGE a THROUGH <VALUE>, 
INCLUSIVE. 
EXECUTING THE SEQUENCE "<INDEX> <NAME>" 
WILL 
PUSH 
ONTO 
THE 
STACK 
THE 
ADDRESS 
OF 
THE 
SPECIFIED ENTRY IN THE 
VECTOR. 
<VALUE1> 
<VALUE2> 
* 
<RESULT> 
16-BIT, 
SIGNED, 
INTEGER MULTIPLY, 
LEAVING 
THE 
SINGLE-WORD 
RESULT ON THE STACK. 
<VALUE> 
<POWER> 
** 
<RESULT> 
INTEGER EXPONENTIATION. 
RAISE <VALUE> TO THE SPECIFIED <POWER> 
AND LEAVE THE SINGLE-WORD INTEGER RESULT ON THE STACK. 
<VALUEl> 
<VALUE2> 
*, 
<RESULT> 
MULTIPLY 14-BIT FRACTIONS. 
IF <VALUE1> AND <VALUE2> ARE 14-BIT 
FRACTIONS 
IN 
THE 
RANGE -2.000 TO 1.9999 THEN THE RESULT WILL 
ALSO BE A 14-8IT FRACTION IN THIS RANGE. 
<VALUE1> 
<VALUE2> 
<VALUE3> 
*1 
<RESULT> 
CALCULATE <VALUE1> * <VALUE2> I <VALUE3> AND LEAVE 
THE 
RESULT 
ON 
THE STACK. 
THE INTERMEDIATE RESULT FROM THE MULTIPLICATION 
IS 31-B1TS AND THIS WORD THEREFORE 
PROVIDES 
GREATER 
ACCURACY 
THAN 
THE SEQUENCE "<VALUE1> <VALUE2> * <VALUE3> I". 
NOTE THAT 
THE DIVISION IS AN INTEGER DIVISION 
WITH 
TRUNCATION 
AND 
ANY 
REMAINDER IS LOST. 
<FP-VALUE> 
<POWER> 
*10** 
<FP-RESULT> 
MULTIPLY 
THE <FP-VALUE> BY THE SPECIFIFED INTEGER POWER OF 10, 
LEAVING THE FLOATING-POINT RESULT ON THE STACK. 
(OLD) 
RENAMED +BLOCK. 
Feb. 1979 

FORTH GLOSSARY 
! "If $ (. I ( ) * +, -. 10123456789: ; < = > ?@A Z [ \ ] " _ 
+ 
<VALUEl> 
<VALUE2> 
+ 
<RESULT> 
16-B1T 
SIG~ED INTEGER ADDITION, 
LEAVING 
THE 
RESULT 
ON 
THE 
STACK. 
+! 
<VALUE> 
<ADDRESS> 
+! 
ADD 
<VALUE> 
TO 
THE 
CURRENT 
CONTENTS OF THE MEMORY LOCATION 
POINTED TO BY <ADDRESS>. 
<VALUE> MAY BE A POSITIVE OR NEGATIVE 
NUMBER. 
IDENTICAL TO THE 
SEQUENCE: 
"<ADDRESS> 
@ 
<VALUE> 
+ 
<ADDRESS> I". 
+BLOCK 
<VALUE> 
+BLOCK 
<BLOCK#> 
ADD 
<VALUE> 
TO 
THE 
NUMBER 
OF 
THE 
CURRENT 
BLOCK 
BEING 
INTERPRETED AND LEAVE THE RESULT ON THE STACK. 
FOR EXAMPLE, IN 
BLOCK 350 THE SEQUENCE "2 +BLOCK" WILL LEAVE THE NUMBER 
352 
ON 
THE STACK. 
+CONVERT 
<VALUE> 
<OW-VALUE> 
+CONVERT 
<COUNT> 
CONVERTS 
THE 
<OW-VALUE> INTO ITS SEQUENCE OF ASCII CHARACTERS 
FOR OUTPUT BY THE WORDS WRITE 
OR 
TYPE. 
THE 
CURRENT 
NUMBER 
CONVERSION 
BASE IS USED. 
<OW-VALUE> MUST BE A POSITIVE NUMBER 
AND <VALUE> IS THEN USED TO SPECIFY THE 
SIGN: 
IF 
<VALUE> 
IS 
NEGATIVE 
A 
MINUS SIGN WILL PRECEDE THE NUMBER. 
ON RETURN THE 
BYTE ADDRESS OF THE CHARACTER STRING IS CONTAINED IN IP 
AND THE 
CHARACTER COUNT IS ON TOP OF THE STACK. 
THE VARIABLES FLO 
AND 
DPL 
ARE 
USED 
TO 
SPECIFY THE TOTAL FIELD WIDTH AND NUMBER OF 
DIGITS TO THE RIGHT OF THE RADIX POINT. 
+LOOP 
(C) 
<VALUE> 
+LOOP 
, 
Feb. 1979 
ADD <VALUE> TO THE CURRENT LOOP INDEX (REFER TO 
THE 
WORDS 
DO 
AND LOOP). 
EXIT FROM THE LOOP IS MADE WHEN THE RESULTANT INDEX 
REACHES QR PASSES THE LIMIT IF <VALUE> IS POSITIVE, OR WHEN THE 
INDEX IS LESS THAN THE LIMIT IF <VALUE> IS NEGATIVE. 
<VALUE> 
, 
STORE 
<VALUE> 
INTO 
THE 
NEXT 
AVAILABlE 
DICTIONARY 
CELL, 
ADVANCING THE DICTIONARY POINTER. 
0-9 

FORTH GLOSSARY 
!It#$E;.1 ()*+,-./0123456789: ;<=>?@AZ[\]"'_ 
<VALUEl> 
<VALUE2> 
<RESULT> 
16-BIT SIGNED INTEGER SUBTRACTION LEAVING THE RESULT, 
<VALUEl> 
-
<VALUE2>, ON THE STACK. 
--> 
(P) 
--> 
CONTINUE INTERPRETATION WITH THE 
NEXT 
BLOCK. 
THIS 
WOkD 
IS 
SIMILAR TO THE SEQUENCE "1 +BLOCK CONTINUED", 
HOWEVER --> IS A 
COMPILER 
DIRECTIVE 
AND 
IS 
THEREFORE 
ESPECIALLY USEFUL WHEN 
EXTENDING A COLON DEFINITION FROM ONE BLOCK TO THE NEXT. 
-CONVERT (OLD) 
-INR, 
• 
.ft 
.FIX 
.FLoAT 
.STRING 
D-10 
CLEANS UP 
THE 
STACK 
AFTER 
EXECUTING 
THE 
OLD 
VERSIONS 
OF 
+CoNVE~T AND WRITE. 
CA) 
<ADDRESS> 
-INR, 
AN 
ASSEMBLER 
MACRO 
WHICH 
GENERATES 
INSTRUCTIONS TO DECREMENT THE CONTENTS 
ADDRESS. 
THE SEQUENCE OF INSTRUCTIONS 
AND STA. 
A 
SEQUENCE 
OF MACHINE 
OF THE SPECIFIED 
MEMORY 
GENERATED IS AN LOA, DAR 
<VALUE> 
• 
PRINT 
<VALUE> 
ON 
THE 
CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S TERMINAL), 
FREE FORMAT, 
CONVERTED ACCORDING TO THE 
CURRENT NUMBER BASE • 
• " 
<STRING>" 
OUTPUT THE 
CHARACTER 
STRING 
TO 
THE 
CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAL). 
<STRING> STARTS WITH THE 
SECOND CHARACTER FOLLOWING .It (THE FIRST CHARACTER FOLLOWING .It 
MUST BE A SPACE). 
THE MAXIMUM NUMBER OF 
CHARACTERS 
THAT 
MAY 
COMPRISE <STRING> IS 127. 
<FP-VALUE> 
.FIX 
<DW-FRACTION-RESULT> 
CONVERT 
THE 
<FP-VALUE> TO A DOUBLE-WORD FRACTION. 
TRUNCATION 
WILL OCCUR IF THE ABSOLUTE VALUE OF <FP-VALUE> IS GREATER 
THAN 
OR 
EOUAL 
TO 
1.0 AND A RESULT OF ZERO WILL BE RETURNED IF THE 
ABSOLUTE VALUE OF <FP-VALUE> IS TOO SMALL 
« 
2**-31). 
<OW-FRACTION> 
.FLOAT 
<FP-RESULT> 
<OW-FRACTION> is CONVERTED TO A FLOATING-POINT VALUE. 
<ADDRESS> 
.STRING 
EQUIVALENT TO THE SEQUENCE "COUNT WRITE", 
BE EXECUTED FROM THE TERMINAL TO OUTPUT A 
SEQUENCE 
"COUNT 
WRITE" 
MAY 
NOT 
(SINCE 
COUNT, 
MUST REMAIN INTACT FOR WRITE, 
AND 
TIME A WORD IN A LINE OF TERMINAL INPUT IS 
HOWEVER, .STRING MAY 
STRING 
WHEREAS 
THE 
IP, 
WHICH IS SET BY 
IP IS 
CHANGED 
EACH 
PROCESSED). 
Feb. 1979 

FORTH GLOSSARY 
! "# $ f.. • ( ) *+ ,- • 10123456789 : ; <. > ?@A Z [ \ ]" _ 
I 
<VALUE1> 
<VALUE2> 
I 
<RESULT> 
16-BIT SIGNED INTEGER DIVIDE. 
THE RESULT, 
<VALUEl> I <VALUE?> 
IS 
LEFT ON THE STACK. 
NOTE THAT THE QUOTIENT IS TRUNCATED AND 
A~Y REMAINDER IS lOST. SEE IMOD. 
I, 
<VALUEl> 
<VAlUE2> 
I, 
<RESULT> 
14010 
ICURSE 
ILITI 
DIVIDE <VAlUE1> BY <VALUE2> LEAVING THE RESULT ON THE STACK. IF 
BOTH DIVIDEND AND DIVISOR ARE 14-BIT 
FRACTIONS 
IN 
THE 
RANGE 
-2.000 
TO 
1.9999 
THEN 
THE 
QUOTIENT 
WILL 
ALSO BE A 14-BIT 
FRACTION IN THE SAME RANGE. SEE *,. 
A 2VARIABLE WHOSE VALUE INDICATES THE CURRENT PHYSICAL POSITION 
OF THE 4010. 
A 2VARIABLE WHOSE VALUE INDICATES THE CURRENT PHYSICAL POSITION 
OF THE 4010 CROSS HAIR CURSORS. 
(C) 
ILITI 
A REFERENCE TO ILITI 
IS 
AUTOMATICALLY 
COMPILED 
BEFORE 
EACH 
LITERAL 
ENCOUNTERED IN A COLON DEFINITION. 
EXECUTION OF ILITI 
CAUSES THE CONTENTS OF THE NEXT DICTIONARY CELL 
TO 
BE 
PUSHED 
ONTO THE S T A C K • 
IMOD 
<VALUEl> 
<VALUE2> 
IMOD 
<REMAINDER> 
<OUOTIENT> 
16-BIT 
SIGNED INTEGER DIVIDE. 
THE QUOTIENT FROM THE DIVISION, 
<VALUE1> I <VALUE2>, 
IS lEFT ON 
TOP 
OF 
THE 
STACK 
AND 
THE 
REMAINDER 
IS 
lEFT 
BELOW. 
THE REMAINDER HAS THE SIGN OF THE 
DIVIDEND. 
Feb. 1979 
0-11 

o ) 
FORTH GLOSSARY 
(A) 
<ADDRESS> 
0) 
<RESULT> 
THE MOST SIGNIFICANT BIT OF <ADDRESS> 
ADDRESS TO AN INDIRECT ADDRESS. 
NOTE 
AN 
ADDRESS 
AS 
INDIRECT 
WHILE 
THE 
INSTRUCTION AS INDIRECT. 
IS SET TO 1, CHANGING THE 
THAT THIS WORD DESIGNATES 
WORD 
I) 
DESIGNATES 
AN 
0)$ 
O)S 
<ADDRESS> 
O)S 
IS 
THE 
STARTING 
ADDRESS 
OF 
A 
VECTOR OF ADDRESSES 
A~D 
INTERNAL VALUES USED BY FORTH. 
THE SEQUENCE 
"0)$ 
<VALUE> 
+" 
FORMS 
THE 
ADDRESS 
OF 
A SPECIFIC ELEMENT IN THE VECTOR WITH 
<VALUE> CORRESPONDING TO: 
o 
THE ADDRESS OF THE CHARACTER OUTPUT SUBROUTINE. THIS 
SUBROUTINE MUST BE CALLED USING AN IJMP 
INSTRUCTIO~. 
1 
THE ADDRESS OF THE CHARACTER INPUT SUBROUTINE. 
THIS 
SUBROUTINE MUST BE CALLED USING AN IJMP INSTRUCTION. 
2 
THE 
ADDRESS 
OF 
THE 
TERMINAL 
INTERROGATION 
SUBROUTINE. 
THIS SUBROUTINE MUST BE CALLED USING AN 
IJMP INSTRUCTION. 
3 
THE 
ADDRESS 
OF THE ROUTINE FETCH. 
THIS SUBROUTINE 
MUST BE CALLED USING 
AN 
IJMP 
INSTRUCTION 
AND 
ON 
RETURN 
THE 
A REGISTER CONTAINS THE CHARACTER WHICH 
WAS POINTED TO BY THE BYTE-ADDRESS 
IN 
IP. 
IP 
IS 
INCREMENTED. 
4 
THE 
ADDRESS 
OF 
THE 
SUBROUTINE 
DEPOSIT. 
THIS 
SUBROUTINE MUST BE CALLED USING AN IJMP INSTRUCTION. 
ON ENTRY THE A REGISTER MUST CUNTAIN 
THE 
CHARACTER 
TO 
BE STORED IN THE LOCATION POINTED TO BY THE BYTt 
ADDRESS IN OPe OP IS INCREMENTED. 
5 
THE CURRENT CORE-SIZE USED BY 
FORTH. 
THE 
INITIAL 
VALUE 
OF 
8192 
(20000B) SPECIFIES 8K WORDS OF CORE 
(ADDRESSES 0 THRU 8191). 
6 
A BLOCK NUMBER OFFSET THAT IS ADDED TO 
EVERY 
BLOCK 
NUMBER WHEN REFERENCING A DISC BLOCK. NORMALLY ZERO. 
7 
A POINTER TO THE PSEUDO-WORD USED FOR FLOATING-POINT 
NUMBER 
CONVERSIONS. 
IT 
MUST 
BE 
ZERO 
IF 
THE 
FLOATING-POINT CODE IS NOT IN THE DICTIONARY. 
8 
THE WORD COUNT USED FOR DATA TRANSFERS TO THE 
DISC, 
NORMALLY 512. 
0< 
<VALUE> 
0< 
<LOGICAL-VALUE> 
0<-
<VALUE> 
0<= <LOGICAL-VALUE> 
0<> 
<VALUE> 
0<> <LOGICAL-VALUE> 
0-
<VALUE> 
Os 
<LOGICAL-VALUE> 
0> 
<VALUE> 
0> 
<LOGICAL-VALUE> 
0>-
<VALUE> 
0>· <LOGICAL-VALUE> 
COMPARE 
<VALUE> 
AGAINST 
ZERO 
AND LEAVE A <LOGICAL-VALUE> OF 
TRUE QN THE STACK IF THE INDICATED RELATION IS TRUE, 
OTHEQWISE 
A <LOGICAL-VALUE> OF FALSE IS LEFT ON THE STACK. 
THE WORD 
0<> 
TESTS FOR NOT EQUAL TO ZERO. 
D-12 
Feb. 1979 

FORTH GLOSSARY 
! ""It $ € ' ( ) *+, -. /01234,6789: ; < = > ?@AZ [ \ ] A _ 
1+ 
<VALUE> 
1+ 
<RESULT> 
EQUIVALENT TO THE SEQUENCE "1 +". 
1+1 
<ADDRESS> 
l+! 
ADD 
1 
TO 
THE 
CONTENTS 
OF 
THE 
MEMORY 
LOCATION <ADOR6SS>. 
EQUIVAL~NT TO THE SEQUENCE "<ADDRESS> @ 1+ <ADDRESS> 
~II. 
1-
<VALUE> 
1-
<RESULT> 
l-! 
EQUIVALENT TO THE SEQUENCE "1 -". 
<ADDRESS> 
l-! 
SUBTRACT 1 FROM THE 
CONTENTS 
OF 
MEMORY 
LOCATION 
EQUIVALENT TO THE SEQUENCE "<ADDRESS> @ 1-
<ADDRESS> 
<ADDRESS>. 
I " 
• • 
lLRL 
(OLD) 
RENAMED BYTE. 
2()DIM 
<VALUE> 
2()DIM 
<NAME> 
DEFINES A VECTOR OF DOUBLE-WORD VALUES. <VALUE> + 1 DOUBLE-WORD 
CELLS 
OF 
MEMORY 
ARE 
ALLOCATED 
TO THE NAMED VECTOR AND THEN 
LEGITIMATE INDICES WILL BE IN 
THE 
RANGE 
0 
THROLGH 
<VALUE>, 
INCLUSIVE. 
EXECUTING 
THE SEQUENCE "<INDEX> <NAME>" WILL PUSH 
ONTO THE STACK THE 
ADDRESS 
OF 
THE 
SPECIFIED 
ENTRY 
IN 
THE 
VECTOR. 
2* 
<VALUE> 
2* 
<RESULT> 
EQUIVALENT TO THE SEQUENCE "2 *". 
2/ 
<VALUE> 
2/ 
<RESULT> 
EQUIVALENT TO THE SEQUENCE "2 I". 
2CONSTANT 
<OW-VALUE> 
2CONSTANT 
<NAME> 
DEFINE 
THE 
WORD <NAME> WHICH WHEN EXECUTED WILL PUSH ONTO THE 
STACK. ITS DOUBLE-WORD VALUE. THE VALUE OF <NAME> IS INITIALIZED 
TO <OW-VALUE>. 
THE VALUE OF <NAME> MAY 
BE CHANGED BY EXECUTING 
THE SEOUENCE "<OW-VALUE> , <NAME> D!". 
20ROP 
<OW-VALUE> 
2DROP 
DROP THE TOP TWO VALUES FROM THE STACK. 
THE TOP TWO VAL'JES MAY 
BE TWO SINGLE-WORD VALUES OR (USUALLY) A DOUBLE-WORD VALUE. 
2DUP 
<OW-VALUE> 
2DUP 
<OW-VALUE> 
<OW-VALUE> 
DUPLICATE THE TOP TWO VALUES ON THE STACK. 
THE TOP TWO 
VALUES 
MAY BE 
TWO SINGLE-WORD VALUES OR (USUALLY) A DOUBLE-WORD 
VALUE. 
2LS 
<OW-VALUE> 
<SHIFT-COUNT> 
2LS 
<OW-RESULT> 
ROTATE 
THE 
<OW-VALUE> LEFT OR RIGHT. 
IF THE <SHIFT-COUNT> IS 
POSIVIVE THE SHIFT IS 
A LOGICAL 
ROTATE 
LEFT 
WHILE 
IF 
THE 
<SHIFT-CDUNT> 
IS 
NEGATIVE 
THEN THE SHIFT IS A LOGICAL 
ROTATE 
RIGHT. 
Feb. 1979 
D-13 

FORTH GLOSSARY 
2M* 
<DW-VALUE> 
<VALUE> 
2M* 
<OW-RESULT> 
cOVER 
2PICK 
2ROLL 
2ROT 
MULTIPLY THE SINGLE-WORD VALUE ON 
TOP 
OF 
THE 
STACK 
BY 
THE 
DOUBLE-WORD VALUE BELOW, 
LEAVING THE DOUBLE-WORD RESULT ON TOP 
OF THE STACK. SEE M*. 
<DW-VALUEl> 
<DW-VALUE2> 
20VER 
<DW-VALUEl> 
<DW-VALUE2> 
<OW-VALUEl> 
PUSH 
A COpy OF <DW-VALUEl> ONTO THE TOP OF THE STACK, 
WITHOUT 
REMOVING ANY WORDS FROM THE STACK. 
<INDEX> 
2PICK 
<DW-VALUE> 
<INDEX> SPECIFIES A LOCATION ON THE STACK 
(1 SPECIFIES 
TH~ 
TOP 
OF THE STACK, 
2 IS THE NEXT CELL ON THE STACK, ETC) 
AND A COpy 
OF 
THE 
DOUBLE-WORD 
VALUE STARTING AT THIS LOCATION IS PUSHED 
ONTO THE TOP OF THE STACK. THE SEQUENCE "3 2PICK" IS EQUIVALENT 
TO 20VER. 
<INDEX> 
2ROLL 
<INDEX> SPECIFIES 
A DOUBLE-WORD 
POSITION 
ON 
THE 
STACK 
(1 
SPECIFIES 
THE 
DOUBLE-WORD INTEGER ON TOP OF THE STACK, 
2 THE 
DOUBLE-WORD INTEGER BELOW, 
ETC) 
AND THIS DOUBLE-WORD VALUE 
IS 
MOVED 
TO 
THE 
TOP OF THE STACK WITH ALL DOUBLE-WORD VALUES IN 
BETWEEN BEING MOVED DOWN ONE POSITION. 
<DW-VALUEl> 
<DW-VALUE2> 
<DW-VAlUE3> 
2ROT 
<OW-VALUE2> 
<DW-VALUE3> 
<OW-VALUE1> 
ROTATE 
THE 
TOP 
THREE 
DOUBLE-WORD 
VALUES 
ON 
THE 
STACK. 
<DW-VALUE1> IS MOVED TO THE TOP OF THE STACK, <DW-VALUE3> MOVES 
FROM 
THE TOP TO THE SECOND POSITION AND <Dw-VALUE2> MOVES FROM 
THE SECOND POSITION TO THE THIRD. 
2SET 
<VALUE1> 
<ADDRESS1> 
<VALUE2> 
<ADORESS2> 
2SET 
<NAME> 
2SWAP 
DEFINES THE WORD <NAME> 
WHICH, 
WHEN 
EXECUTED, 
WILL 
STORE 
<VALUEl> AT 
<AODRE~Sl> AND <VALUE2> AT <ADORESS2>. 
<DW-VALUE1> 
<DW-VALUE2> 
2SWAP 
<DW-VALUE2> 
<OW-VAlUE1> 
SWAP THE TWO DOUBLE-WORD VALUES ON TOP OF THE STACK. 
2VARIABLE 
<OW-VALUE> 
2VARIABLE 
<NAME> 
D-14 
DEFINE THE 
~ORD <NAME> WHICH, WHEN EXECUTED, WILL PUSH ONTO THE 
STACK THE ADDRESS OF <NAME>'S VALUE. 
THE VALUE OF THE VARIABLE 
IS 
INITIALIZED 
TO 
<OW-VALUE>. 
THE SEQUENCE "<NAME> 
D~" WILL 
PUSH THE VALUE OF THE VARIABLE ONTO THE STACK AND THE 
SEQUENCE 
"<OW-VALUE> 
<NAME> 01" WILL STORE <OW-VALUE> AS THE VARIABLE'S 
NEW VALUE. 
Feb. 1979 

FORTH GLOSSARY 
3( )DIM 
<VALUE> 
3( )DIM 
<NAME> 
DEFINES 
A VECTOR 
OF 
FLOATING-POINT 
VALUES. 
<VALUE> 
+ 
1 
FLOATING-POINT 
CELLS 
OF 
MEMORY 
ARE 
ALLOCATED 
TO THE NAMED 
VECTOR AND THEN LEGITIMATE INDICES 
WILL 
BE 
IN 
THE 
RANGE 
0 
THROUGH 
<VALUE>, 
INCLUSIVE. 
EXECUTING THE SEQUENCE "<INDEX> 
<NAME>" WILL PUSH ONTO THE STACK THE ADDRESS OF 
THE 
S~ECIFIED 
ENTRY IN THE VECTOR. 
3DROP 
<FP-VALUE> 
3DROP 
DELETE 
THE 
TOP 
THREE 
VALUES 
FROM THE STACK. 
THE TOP THREE 
VALUES USUALLY COMPRISE A SINGLE FLOATING-POINT NUMBER BUT 
MAY 
ALSO CONSIST OF THREE SINGLE-WORD VALUES OR A DOUBLE-WORD VALUE 
AND A SINGLE-WORD VALUE. 
3DUP 
<FP-VAlUE> 
30UP 
<FP-VAlUE> 
<FP-VAlUE> 
DUPLICATE 
THE 
TOP 
THREE 
VALUES ON THE STACK. 
THE TOP THREE 
VALUES 
USU~lLY COMPRISE A SINGLE FLOATING-POINT NUMBER BUT 
MAY 
ALSO CONSIST OF THREE SINGLE-WORD VALUES OR A DOUBLE-WORD VALUE 
AND A SINGLE-WORD VALUE. 
30VER 
<FP-VALUE1> 
<FP-VALUE2> 
30VER 
<FP-VALUE1> 
<FP-VALUE2> 
<FP-VALUE1> 
PUSH 
A COpy OF <FP-VALUE1> ONTO THE TOP OF THE STACK, 
WITHOUT 
REMOVING ANY WORDS FROM THE STACK. 
3PICK 
<INDEX> 
3PICK 
<FP-VALUE> 
<INDEX> SPECIFIES A LOCATION ON THE SlACK (1 SPECIFIES THE 
TOP 
OF THE STACK, 
2 IS THE NEXT CELL ON THE STACK, ETC) AND A COpy 
OF THE FLOATING-POINT VALUE STARTING AT THIS LOCATIQN IS PUSHED 
ONTO THE TOP OF THE STACK. THE SEQUENCE "4 3PICK" IS ECUIVALENT 
TO 30VER. 
3ROLL 
<INDEX> 
3ROLL 
<INDEX> 
SPECIFIES 
A FLOATING-POINT 
POSITION ON THE STACK (1 
SPECIFIES THE FLOATING-POINT VALUE ON TOP OF THE STACK, 
2 
THE 
FLOATING-POINT VALUE BELOW, 
ETC) AND THIS FLOATING-POINT VALUE 
IS MOVED TO THE TOP OF THE STACK WITH ALL FLOATING-POINT VALUES 
IN BETWEEN BEING MOVED DOWN ONE POSITION. 
3ROT 
<FP-VALUEl> 
<FP-VALUE2> 
<FP-VALUE3> 
3ROT 
<FP-VALUE2> 
<FP-VALUE3> 
<FP-VALUEl> 
ROTATE 
THE 
TOP 
THREE 
FLOATING-POINT 
VALUES 
ON 
THE STACK. 
<FP-VALUEl> IS MOVED TO THE TOP OF THE STACK, <FP-VALUE3> MOVES 
FROM THE TOP TO THE SECOND POSITION AND <FP-VALUE2> MOVES 
FROM 
THE SECOND POSITION TO THE THIRD. 
3SWAP 
<FP-VALUE1> 
<FP-VAlUE2> 
3SWAP 
<FP-VAlUE2> 
<FP-VALUEl> 
SWAP THE TWO FLOATING-POINT VALUES ON TOP OF THE STACK. 
Feb. 1979 
D-15 

FORTH GLOSSARY 
! n# $ & I ( ) * +, -./0123456789: ; <. >? cil A Z [\ ]"_ 
<NAME> 
••• 
; 
START 
A 
COLON 
DEFINITION, 
THAT IS CREATE A DICTIONARY ENTRY 
THAT WILL DEFINE <NAME> AS EQUIVALENT TO THE SEQUENCE OF 
WORDS 
BETWEEN <NAME> AND THE SEMICOLON. 
THE COMPILATION MODE FLAG IS 
SET 
AND 
THE 
CONTEXT 
VOCABULARY 
IS 
SET 
TO 
THE 
CURRENT 
VOCABULARY. 
THE 
COLON 
DEFINITION 
IS 
TERMINATED 
BY 
THE 
SEMICOLON. 
:ORX 
:ORX 
••• 
; 
. , 
. . 
, . 
; ; S 
;CODE 
; S 
D-16 
INITIATES 
AN ANONYMOUS (ORPHAN) COLON DEFINITION, 
PLACING ITS 
ADDRESS IN PSEUDO-VECTOR ENTRY X, 
FOR 
SUBSE~UENT 
ADOPTION 
dY 
THE 
WORD 
ADOX. 
AN ANONYMOUS COLON DEFINITION IS SIMILAR TO A 
STANDARD COLON DEFINITION, 
HOWEVER, 
IT MAY BE 
EXECUTED 
ONLY 
FROM 
A COLON DEFINITION (USING ADOX) NOT FROM THE TERMINAL AND 
THREE MEMORY CELLS ARE SAVED SINCE THE ANONYMOUS DEFINITION HAS 
NO NAME. SEE ADOX AND P-VX. 
(C ,P ) 
TERMINATE A COLON DEFINITION AND 
RESET 
THE 
COMPILATION 
MODE 
FLAG. 
(C,P) 
<NAME1> 
••• 
;: 
••• 
TERMINATE 
A DEFINING WORD <NAME!>. 
THE DEFINING WORD <NAMEl> 
CAN SUBSEQUENTLY BE EXECUTED TO DEFINE A 
NEW 
wORD, 
<NAME2>. 
WHEN 
<~AME2> IS EXECUTED IT WILL CAUSE THE WORDS BETWEEN ;: 
A~D 
; 
TO 
BE 
EXECUTED WITH THE CONTENTS OF THE FIRST PARAMETER OF 
<NAME2> ON THE STACK. 
ec) 
;;S 
THIS WORD MAY BE USED TO TERMINATE A COLON DEFINITION IN 
PLACE 
OF 
;. 
WHEN 
THE COLON DEFINITION TERMINATED BY ;;5 COMPLETES 
EXECUTION (I.E. 
-
THE WORD ;;S IS EXECUTED) THE LOADING OF THE 
CURRENT BLOCK WILL TERMINATE AS IF THE WORD;S 
WERe 
EXECUTED. 
THIS 
WORD 
IS NOT, 
IN GENERAL, 
EQUIVALENT TO THE SEQUENCE "i 
is". 
(e,?) 
<NAMEl> 
••• 
;CODE 
••• 
STOP COMPILATION AND TERMINATE A DEFH!ING WORD, 
<NAME1>. 
THE 
CONTEXT 
VOCABULARY 
IS 
SET TO THE ASSEMBLER VOCABULARY. 
WHEN 
<NAMEl> IS EXECUTED TO DEFINE A NEW WORD <NAME2>, THE EXECUTION 
ADDRESS OF <NAME2> WILL POINT TO THE 
ASSEMBLER 
CODE 
SEQUENCE 
FOLLOWING THE ;CODE OF <NAME!>. SUBSEQUENT EXECUTION OF 
<NAME~> 
WILL CAUSE THIS MACHINE CODE SEQUENCE TO BE EXECUTED. 
( E ) 
STOP INTERPRETATION OF A SYMBOLIC BLOCK. 
Feb. 1979 

FORTH GLOSSARY 
< 
<VALUE1> 
<VALUE2> 
< 
<LOGICAL-VALUE> 
<-
<VALUEl> 
<VALUE2> 
<. 
<LOGICAL-VALUE> 
<> 
<VAlUEl> 
<VAlUE2> 
<> 
<LOGICAL-VALUE> 
• 
<VAlUEl> 
<VALUE2> 
-
<LOGICAL-VALUE> 
> 
<VALUEl> 
<VALUE2> 
> 
<LOGICAL-VALUE> 
>. 
<VAlUEl> 
<VALUE2> 
>-
<LOGICAL-VALUE> 
COMPARE 
<VALUE1> 
AND 
<VALUE2> ANQ LEAVE A <lOGICAL-VALUE> OF 
TRUE 
ON THE STACK IF THE INDICATED RELATION IS TRUE, 
OTHERWISE 
LEAVE A <LOGICAL-VALUE> OF FALSE ON THE 
STACK. 
THE 
WORD 
<> 
TESTS FOR NOT EQUAL. 
«LX 
(A) 
<ADDRESS> 
«LX 
FIX 
A 
MEMORY 
REFERENCE 
INSTRUCTION'S RELATIVE ADDRESS. 
SEE 
»l X. 
<T> 
(A) 
A CONSTANT WHOSE VALUE 
IS 
THE 
ADDRESS 
OF 
A CORE 
LOCATION 
AVAILABLE 
FOR 
TEMPORARY 
STORAGE. 
THE CONTENTS OF THIS CORE 
LOCATION WILL BE SAVED DURING INTERRUPT PROCESSING. 
-2 
(A) 
=2 
<ADDRESS> 
PUSHES QNTO THE STACK THE 
STARTING 
ADDRESS 
OF 
A VECTOR 
OF 
BINARY CONSTANTS USED INTERNAllY BY FORTH. 
DO NOT CHANGE THESE 
VALUES. 
THESE 
VALUES 
ARE 
ALL IN LOW CORE AND ARE THEREFORE 
USEFUL IN MACHINE LANGUAGE WORDS WHEN THE GIVEN CONSTANT 
NEEDS 
TO 
BE 
REFERENCED BY A SINGLE WORD INSTRUCTION. 
THE CONSTANTS 
AND HOW TO ACCESS THEM IS AS FOLLOWS: 
-2 
2 
@ 
LEAVES 100000B ON THE 
STACK 
-2 
1-
@ 
LEAVES 077777B ON THE STACK 
=2 
~ 
LEAVES 2 ON THE STACK 
-2 
1+ 
~ 
LEAVES 3 ON THE STACK 
=2 
2 
+ 
@ 
LEAVES 4 ON THE STACK 
=2 
3 
+ 
@ 
LEAVES 5 ON THE STACK 
=2 
4 
+ 
@ 
lEAVES 6 ON THE STACK 
-2 
5 
+ 
@ 
LEAVES 7 ON THE STACK 
Feb. 1979 
D-17 

FORTH GLOSSARY 
!"#$&' ()*+,-./0123456789: ;<:O>?Q)AZC\]"_ 
»LX 
(A) 
>BC(J 
A WORD USED IN GENERATING MACHINE LANGUAGE FORWARD 
REFERENCES. 
THE 
CURRENT 
VALUE 
OF THE DICTIONARY POINTER IS STORED IN THE 
CORRESPONDING PSEUDO-VECTOR TABLE ENTRY (SEE P-VX) AND A 
VALUE 
OF ZERO IS PUSHED ONTO THE STACK. 
THE ADDRESS THAT IS SAVED IN 
THE 
PSEUDO-VECTOR TABLE IS ASSUMED TO POINT TO A VARIAN 
~EMORY 
REFERENCE INSTRUCTION. 
THE VALUE OF ZERO THAT IS 
PUSHED 
ONTO 
THE STACK WILL THEN BE USED AS THE MEMORY ADDRESS OF THE MEMORY 
REFERENCE 
INSTRUCTION, 
GUARANTEEING 
THAT 
THf 
SINGLE-WORD 
VERSION OF THE INSTRUCTION WILL BE GENERATED. 
THE 
WORD 
«LX 
MUST 
THEN 
BE 
EXECUTED LATER IN THE COMPILATION TO CHANGE THE 
MEMORY 
REFERENCE 
INSTRUCTION 
TO 
AN 
ADDRESSING 
MODE 
OF 
4 
(RELATIVE TO THE P REGISTER) AND TO SET THE RELATIVE ADDRESS OF 
THE INSTRUCTION TO THE DIFFERENCE OF THE SPECIFIED ADDRESS (THE 
<ADDRESS> 
PUSHED 
ONTO 
THE STACK BEFORE «lX IS EXECUTED) AND 
THE MEMORY ADDRESS THAT »LX STORED IN THE PSEUDO VECTOR TABLE. 
THIS 
lENGTHY 
PROCEDURE 
IS 
REQUIRED 
TO 
GENERATE 
FORWARD 
REFERENCES 
USING 
FORTH'S SINGLE PASS STRUCTURE AND THE VARIAN 
MACHINE INSTRUCTIONS. 
A VARIABLE WHOSE VALUE SPECIFIES WHETHER THE 7-TRACK 
MAG 
TAPE 
INPUT 
AND 
OUTPUT 
IS 
TO 
BE 
BINARY OR BCD. 
A VALUE OF ZERO 
SPECIFIES BINARY (3 TAPE FRAMES PER WORD, 
ALL 16-BITS OF EVERY 
WORD WITH TWO HIGH ORDER BITS OF ZERO) WHILE A 
NON-ZERO 
VALUE 
SPECIFIES 
BCD 
(2 
TAPE 
FRAMES 
PER 
WORD, 
LEAST SIGNIFICANT 
12-BITS OF EVERY WORD). 
THE DEFAULT VALUE OF >BCO IS ZERO 
AND 
AFTER 
EVERY 
INPUT 
OR OUTPUT THE VALUE IS RESET TO ZERO. 
SEE 
MTR, MTREAD, 
MTW AND MTWRITE. 
>R 
eC) 
<VALUE> 
>R 
? 
PUSH <VALUE> ONTO THE RETURN STACK. SEE I AND R>. 
<ADDRESS> 
? 
PRINT THE VALUE CONTAINED AT <ADDRESS> ON 
THE 
DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAL), 
CONVERTED ACCORDING TO THE CURRENT NUMBER BASE. 
THE SEQUENCE n<ADDRESS> @ .". 
CURRENT 
OUTPUT 
FREE 
FORMAT, 
EQUIVALENT 
TO 
?DEF 
(OLD) 
?DEF 
<NAME> 
<LOGICAL-VALUE> 
RENAMED FIND. 
?DUP 
<VALUE> 
?DUP 
IF 
••• 
THEN 
IF 
<VALUE> IS NON-ZERO (wHICH WILL BE INTERPRETED AS A LOGICAL 
VALUE OF 
TRUE) 
THEN 
<VALUE> 
IS 
DUPLICATED 
ON 
THE 
STACK, 
OTHERWISE 
<VALUE> 
IS NOT DUPLICATED. 
USE OF THIS WORD ALLOWS 
ONE TO OMIT THE "ELSE DROP" CLAUSE FORM THE IF STATEMENT, 
WHEN 
IT IS DESIRED TO EXECUTE THE IF STATEMENT ONLY 
IF 
<VALUE> 
IS 
NON- ZE RO. 
D-18 
Feb. 1979 

FORTH GLOSSARY 
?EOF 
?EOF 
<LOGICAL-VALUE> 
?LEFT 
TESTS THE MAG TAPE AND RETURNS A <LOGICAL-VALUE> OF TRUE IF THE 
TAPE IS CURRENTLY POSITIONED AT AN END-OF-FILE MARK. 
?LEFT 
<CELLS> 
CALCULATES 
THE 
NUMBER 
OF 
MEMORY 
CELLS 
LEFT 
IN THE 
MEMORY 
OVERLAY REGION. 
?MTREADY 
?MTREADY 
<LOGICAL-VALUE> 
TESTS THE MAG TAPE FOR READY AND ONLINE ,hND IF THE 
TAPE 
DRIVE 
IS NOT READY THE MESSAGE "TAPE NOT READY" WILL BE OUTPUT TO THE 
TERMINAL 
AND 
THE 
WORD 
wAITS FOR THE TAPE DRIVE TO BE PLACED 
ONLINE. 
?ON 
?ON 
<LOGICAL-RESULT> 
PUSH A <LOGICAL-RESUL T> OF TRUE ONTO 
THE 
STACK 
IF 
THE 
LAST 
TOGGLE 
OF 
ANY 
CAMAC 
DISPLAY 
PANEL 
PUSHBUTTON'S STATUS BIT 
TURNED THE STATUS BIT ON, OTHERWISE A <LOGICAL-RESULT> OF FALSE 
IS PUSHED ONTO THE STACK. 
SEE 
PBARRAY, 
PLARRAY, 
PL TOGGLE, 
PSTOGGLE, PTOGGLE, ON! 
AND OFF!. 
?PB 
<PUSHBUTTON#> 
?PB 
<LOGICAL-RESULT> 
PUSH A <LOGICAL-RESULT> OF TRUE ONTO THE STACK IF THE SPECIFIED 
CAMAC DISPLAY PANEL PUSHBUTTON'S STATUS BIT IS SET, OTHERWISE A 
<LOGICAL-RESULT> 
OF 
FALSE 
IS 
PUSHED 
ONTO 
THE 
STACK. 
<PUSHBUTTON> IS AN INTEGER VALUE IN THE RANGE 0 THROUGH 
31. SEE 
PBARRAY, ON!, OfF!, PSTOGGLE AND PTOGGLE. 
1Q 
1Q 
<LOGICAL-VALUE> 
A CAMAC WORD TO TEST THE Q-RESPONSE. THE <LOGICAL-VALUE> PUT ON 
THE STACK 
CO~RESPONDS TO WHETHER 
THE 
Q-RESPONSE 
IS 
TRUE 
OR 
FALSE. 
?TER 
?TER 
<CHAR-CODE> 
PUSHES 
ONTO 
THE 
STACK 
THE 7-8IT ASCII CHARACTER CODE OF THE 
LAST CHARACTER ENTERED AT THE TERMINAL, 
OR 
ZERO IF NO CHARACTER 
HAS BEEN ENTERED. 
SEE APPENDIX A FOR A LISTING 
OF 
THE 
ASCII 
CODES. 
@ 
<ADDRESS> 
@ 
<VALUE> 
@I10 
FETCH THE CONTENTS OF THE MEMORY LOCATION <ADDRESS> AND 
PUSH IT 
ONTO THE STACK. 
RESTORES 
THE 
SYSTEM 
FLAGS 
AND PARAMETERS THAT WERE 
SAVED BY 
!I/O, 
PRIOR TO PERFORMING 110 FROM AN INTERRUPT HANDLING WORD. 
@I/O INCLUDES THE EXECUTION OF FRESTORE. SEE !I/O. 
@STATE 
~STATE 
<LOGICAL-VALUE> 
PUSHES ONTO THE STACK A LOGICAL-VALUE WHICH 
IS 
TRUE 
ONLY 
IF 
FORTH 
IS 
IN 
COMPILATION 
MODE. 
THIS WORD IS USEFUL 
O~LY IN 
COMPILER DIRECTIVE WORDS. 
Feb. 1979 
D-19 

A+ 
A-
A-SAVE 
AO 
ABORT 
FORTH GL(]SSARY 
!"It$&' ()*+,-./0123456789: j<->?@AZ(\)"_ 
( A) 
A CONSTANT WHOSE VALUE SPECIFIES THE JUMP CONDITION FOR THE 
"A 
REGISTER >. 0" TEST. USUALLY FOLLOWED BY IF, END, JIF, JIFM, OR 
XIF,. REFER TO PAGE 20-18 OF THE VARIAN HANDBOOI<. SEE NOT. 
( A ) 
A 
CONSTANT WHOSE VALUE SPECIFIES THE JUMP-CONDITION FOR THE "A 
REGISTER < 0" TEST. 
USUALLY FOLLOWED BY IF, END, JIF, JIFM, OR 
XIF,. REFER TO PAGE 20-18 OF THE VARIAN HANDBOOK. SEE NOT. 
A-SAVE 
<NAME> 
WRITES THE CURRENT OVERLAY TO 
DISC, 
STARTING 
AT 
THE 
BLOCK 
NUMBER 
CONTAINED IN THE VARIABLE O-BLK. 
O-BLK IS THEN UPDATED 
ACCORDINGLY. 
<NAME> IS ENTERED INTO THE DICTIONARY 
SUCH 
THAT 
SUBSEQUENT 
EXECUTION 
OF 
<NAME> 
WILL PUSH THE STARTING BLOCK 
NUMBER OF THE OVERLAY ONTO THE STACK (SEE O-LOAD). SEE O-SAVE. 
( A) 
A CONSTANT WHOSE VALUE SPECIFIES THE JUMP-CONDITION FOR THE 
"A 
REGISTER" Oft TEST. 
USUALLY FOLLOWED BY IF, END, JIF, JIFM, OR 
X IF,. REF E R TOP AGE 20-18 0 F THE V A R I AN HAN DBa OK. SEE NO T • 
ENTF.R 
THE 
ABORT 
SEQUENCE WHICH WILL CLEAR BOTH THE STACK AND 
THE RETURN STACK, 
PRINT THE 
ABORT 
MESSAGE 
"?S" 
AND 
RETURN 
CONTROL TO THE OPERATOR'S TERMINAL. SEE OUIT. 
ABORT 
(A) 
A CONSTANT WHOSE VALUE IS THE MEMORY ADDRESS OF THE INTERPRETER 
ROUTINE TO PRODUCE A "?O" ABORT MESSAGE. THE NORMAL SEQUENCE IS 
"ABORT JMP,", HOWEVER, THE FOLLOWING SEOUENCES WILL PRODUCE THE 
SPECIFIED ABORT: 
ABORT 1-
JMP, 
WILL PRODUCE 
?R 
ABORT 
ABORT 2 -
JMP, 
WILL PRODUCE 
1S 
ABORT 
ABORT 3 -
JMP, 
WILL PRODUCE 
?T 
ABORT 
ABORT 4 -
JMP, 
WILL PRODUCE 
?U 
ABORT 
ABORT 5 -
JMP, 
WILL PRODUCE 
?V 
ABORT 
ABORT 6 -
JMP, 
WILL PRODUCE 
?W 
ABORT 
ABORT 7 -
JMP, 
WILL PRODUCE 
?X 
ABORT 
ABORT 10 -
JMP, 
WILL PRODUCE 
?Y 
ABORT 
ABORT 11 -
JMP, 
WILL PRODUCE 
?Z 
ABORT 
ABS 
<VALUE> 
ASS 
<RESULT> 
FORM THE ABSOLUTE VALUE OF <VALUE> AND LEAVE IT ON THE STACK. 
ACURSOR 
ACURSOR 
<STATUS> 
<Y-POSN> 
<X-POSN> 
TURNS ON THE 4010 CROSS HAIR CURSORS AND WAITS FOR THE OPERATOR 
TO 
ENTER 
ANY 
CHARACTER. 
THREE 
SINGLE-WORD 
INTEGERS 
ARE 
RETURNED, 
THE X AND Y POSITIONS OF THE CURSORS 
AND 
THE 
4010 
STATUS WORD. 
ADD, 
(A) 
<ADDRESS> 
ADO, 
D-20 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN ADO lNSTRUCTION (ADD 
MEMORY TO THE A REGISTER). 
Feb. 1979 

FORTH GLOSSARY 
ADOPT 
ADOX 
(A) 
<ADDRESS> 
ADM, 
AN ASSEMBLE? 
MACRO 
WHICH 
GENERATES 
A 
SEQUENCE 
OF 
MACHINE 
INSTRUCTIOt\lS 
TO 
ADD 
THE 
CONTENTS 
OF 
THE 
A REGISTER 
TO THE 
CONTENTS OF THE SPECIFIED MEMORY 
LOCATION. 
THE 
SEQUENCE 
OF 
INSTRUCTIONS GENERATE IS ADD AND STA. 
(OLD) 
ADOPT 
SAME AS , EXECPT THAT ADOPT IS A COMPILER DIRECTIVE. 
(C) 
ADoX 
ADOPT 
AN 
ANONYMOUS 
COLON 
DEFINITION 
OR 
CODE DEFINITION OY 
PLACING THE ADDRESS CONTAINED IN PSEUDO-VECTOR ENTRY X INTO THE 
DICTIONARY. SEE P-VX, :ORX AND ORCX. 
ANA, 
(A) 
<ADDRESS> 
ANA, 
AND 
ASH 1FT 
ASLB, 
ASR, 
ASRB, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN ANA INSTRUCTION 
(LOGICAL 
AND MEMORY WITH THE A REGISTER). 
<VALUE1> 
<VAlUE2> 
AND 
<RESULT> 
CALCULATE 
THE 
BITWISE 
LOGICAL-AND 
OF <VAlUE1> AND <VAlUE2>, 
LEAVING THE RESULT ON THE STACK. 
<OW-VALUE> 
<SHIFT-COUNT> 
ASHIFT 
<DW-RESULT> 
ARITHMETIC 
SHIFT 
THE 
<Ow-VALUE>, 
LEFT 
FOR 
A 
POSITIVE 
<SHIFT-COUNT> AND RIGHT FOR A NEGATIVE <SHIfT-COUNT>. THIS WORD 
MAY 
BE 
USED 
TO 
MUL TIPL Y AND DIVIDE A DOUBLE-WORD VALUE 
BY A 
POWER OF 2. 
(A) 
<SHIFT-COUNT> 
ASL, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
ASLA 
INSTRUCTION 
(ARITHMETIC SHIFT LEFT THE A REGISTER). 
(A) 
<SHIFT-COUNT> 
ASLB, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
ASLB 
INSTRUCTION 
(ARITHMETIC SHIFT LEFT THE B REGISTER). 
(A) 
<SHIFT-COUNT> 
ASR, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
ASRA 
INSTRUCTION 
(ARITHMETIC SHIFT RIGHT THE A REGISTER). 
(A) 
<SHIFT-COUNT> 
ASRB, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
ASRB 
INSTRUCTION 
(ARITHMETIC SHIFT RIGHT THE B REGISTER). 
ASK 
(OLD) 
ASK 
<VALUE> 
REQUEST THE INPUT OF A NUMBER FROM THE TERMINAL. 
ASSEMBLER (P) 
SWITCH THE CONTEXT POINTER SO 
THAT 
DICTIONARY 
SEARCHES 
WILL 
BEGIN IN THE ASSEMBLER VOCABULARY. 
THE ASSEMBLER VOCABULARY IS 
ALWAYS CHAINED TO THE CURRENT VOCABULARY. 
Feb. 1979 
D-21 

FORTH GLOSSARY 
: "# $ 6. I ( ) *+, -.10123456789: ; < .. >? @AZ [\ ]" _ 
B! 
<VALUE> 
<BYTE-ADDRESS> 
B! 
STORE 
THE 
LEAST 
SIGNIFICANT 8-BITS OF <VALUE> AT THE BYTE OF 
MEMORY POINTED TO BY <BYTE-ADDRESS>. 
B ) 
( A ) 
SETS THE VARIABLE MODE TO 6, 
SPECIFYING 
INDEXING 
OFF 
lHE 
B 
REGISTER FOR THE NEXT MEMORY REFERENCf. INSTRUCTION. 
B. 
<VALUE> 
B. 
BINARY 
OUTPUT. 
OUTPUT 
<VALUE> 
AS A BINARY (BASE 2) NUMBER, 
UNSIGNED AND PRECEDED BY A BLANK ON THE CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S TERMINAL). 
THE FORMAT SPECIFICATIONS 
GIVEN BY THE VARIA3LES FLD AND DPL ARE OBSERVED. 
BASE 
IS 
NOT 
CHANGED. 
8@ 
<BYTE-ADDRESS> 
B~ 
<RESULT> 
FETCH 
THE 
8-BIT 
BYTE 
FROM 
THE BYTE 
OF MEMORY POINTED TO BY 
<BYTE-ADDRESS> AND LEAVE THIS BYTE ON THE STACK. THE HIGH ORDER 
8 BITS OF <RESULT> WILL ALWAYS BE ZERO. 
BO 
(A) 
BASE 
BEGIN 
BEGIN, 
BELL 
D-22 
A CONSTANT WHOSE VALUE SPECIFIES THE JUMP-CONDITION FOR THE 
"B 
REGISTER .. 0" TEST. 
USUALLY FOLLOWED BY IF, END, JIF, JIFM, OR 
XIF,. REFER TO PAGE 20-18 OF THE VARIAN HANDBOOK. SEE NOT. 
A 
VARIABLE CONTAINING THE CURRENT NUMBER CONVERSION BASE. 
THE 
WORD DECIMAL SETS BASE TO 10, 
OCTAL SETS BASE TO 8, 
HEX 
SETS 
BASE TO 16, ETC. 
(CQ+,P) 
BEGIN 
••• 
<LOGICAL-VALUE> 
END 
BEGIN 
••• 
<LOGICAL-VALUE> 
WHILE 
••• 
REPEAT 
BEGIN 
MARKS 
THE 
START 
OF A SEQUENCE OF WORDS THAT ARE TO BE 
EXECUTED REPEATEDLY UNTIL A SPECIFIED CONDITION IS TRUE. IF THE 
BEGIN-END FORM IS USED, All THE WORDS BETWEEN THE BEGIN AND THE 
END ARE EXECUTED REPEATEDLY UNTIL THE <LOGICAL-VALUE> IS 
TRUE, 
AT WHICH POINT THE WORDS FOLLOWING THE END ARE EXECUTED. IF THE 
BEGIN-WHILE-REPEAT FORM IS USED THE WORDS BETWEEN THE BEGIN 
A~D 
THE 
REPEAT 
ARE 
EXECUTED 
REPEATEDLY 
AS 
LONG 
A~ 
THE 
<LOGICAL-VALUE> ENCOUNTERED 
BY 
WHILE 
IS 
TRUE. 
WHEN 
WHILE 
ENCOUNTERS 
A 
FALSE 
<LOGICAL-VALUE> 
THE 
LOOP 
IS 
EXITED 
IMMEDIATELY. THESE LOOPS MAY BE NESTED. 
(A) 
BEGIN, 
••• 
<JUMP-CONDITION> 
END, 
BEGIN, 
MARKS THE START OF A SEQUENCE OF 
MACHINE 
INSTRUCTIONS 
THAT 
ARE 
TO 
BE 
EXECUTED 
REPEATEDLY 
UNTIL 
THE 
SPECIFIED 
<JUMP-CoNOITIoN> IS TRUE. <JUMP-CONDITION> IS USUALLY SPECIFIED 
BY ONE OF THE WORDS A+, A-, AQ, BO OR OV. BEGIN,-END, lOOPS MAY 
Bt: NESTED. 
ACTIVATE THE TERMINAL BELL OR NOISEMAKER, AS APPROPIATE FOR THE 
TERMINAL DEVICE. 
Feb. 1979 

FORTH GLOSSARY 
BINARY 
BINEX 
BK 
BKS P 
BL 
BLANK 
BLK 
BLOCK 
BLOCt<-A5K 
( A ) 
A CONSTANT WHOSE VALUE IS THE MEMORY ADDRESS OF THE INTERPRETER 
ROUTINE IN FORTH TO POP TwO WORDS OFF THE STACK AND 
THEN 
PUSH 
THE 
CONTENTS 
OF 
THe A REGISTER ONTO THE STACK. 
THE SEQUENCE 
"BINARY 1-" LEAVES THE ADDRESS OF THE 
INTERPRETER 
ROUTINE 
TO 
POP THREE WORDS OFF THE STACK AND THEN PUSH THE CONTENTS OF THE 
A REGISTER 
ONTO 
THE 
STACK. 
THE 
NORMAL SEQUENCE IS EITHER 
"BINARY JMP," OR "BINARY 1- JMP,". 
A VARIABLE USED TO HOLD THE BINARY EXPONENT OF A FLOATING-POINT 
NUMBER BY THE FLOATING-POINT ROUTINES. 
INITIATE THE BACKSPACING OF A SINGLE MAG TAPE RECORD AND 
RETURN 
IMMEDIATELY. SEE BKSP. 
INITIATE THE BACKSPACING OF A SINGLE MAG TAPE RECORD 
AND 
WAIT 
FOR THE OPERATION TO COMPLETE. SEE BK. 
A CONSTANT WHOSE VALUE IS 32 (409)' NM1ElY AN ASCII SPACE. 
(OLD) 
RENAMED SPACE. 
A VARIABLE 
CONTAINING THE NUMBER OF THE GLOCK BEING LISTED OR 
EDITED. 
<8LOCK#> 
BLOCK 
FETCH THE SPECIFIED BLOCK 
OF 
FO~THIS 9LOCK BUFFERS. 
BLOCK IS THEN RETURNED ON 
ALREADY 
IN 
MEMORY 
THEN 
STORAGE. SEE HBLOCK. 
<ADDRESS> 
FROM DISC OR TAPE 
AND LEAVE IT IN ONE 
THE STARTING MEMORY ADDRESS 
OF 
THE 
THE STACK. 
IF THE SPECIFIED BLOCK IS 
IT NEED NOT BE READ IN FROM SECONDARY 
SETS A FLAG 50 THAT THE NEXT USE OF ANY ASKING WORD (SASK, DASK 
OR FASK) WILL FETCH CHARACTERS FROM 
THE 
BLOCK 
OUFFER 
RATHt:R 
THAN THE TERMINAL. SEE TERMINAL-ASK. 
BLOCK-WORD (OLD) 
RENAMED BLOCK-ASK. 
BLoCKPRINT 
<START-BLOCK#> 
<END-BLOCK#> 
BLoCKPRINT 
Feb. 1979 
OUTPUT 
THE 
SPECIFIED 
SEQUENCE OF BLOCKS TO THE LINE PRINTER. 
THE AP?ROPIATE LINE PRINTER 
CODE 
MUST 
HAVE 
PREVIOUSLY 
BEEN 
LOADED (SEE UTIL AND PRINTERS). 
0-23 

FORTH GLOSSARV 
ONOT 
(OLD) 
BOLDFACE 
RENAMFD COM. 
INCREASE 
THE 
SIZE 
OF 
THE 
CHARACTERS 
PRINTED 
BV 
THE LINE 
PRINTER. THIS WORD IS DEVICE DEPENDENT. 
BOXGRID 
<X-PHYSICAL-ORIGIN> 
<X-LOGICAL-ORIGIN> 
<X-LOGICAL-MAX> 
<X-PHYSICAL-SIZE> 
<V-PHVSICAL-ORIGIN> 
<Y-LOGICAL-ORIGIN> 
<Y-LOGICAL-MAX> 
<V-PHYSICAL-SIZE> 
BOXGRID 
BRACKET 
DEFINES A LOGICAL COORDINATE SVSTEM FOR THE 4010 BASED 
ON 
THE 
EIGHT FLOATING-POINT PARAMETERS. IN ADDITION, A BOX IS DRAWN TO 
SURROUND 
THE 
PLOT 
AND 
THE 
AXES 
ARE 
LABELLED. 
THE 
PHVSICAL-ORIGIN AND THE PHYSICAL-SIZE 
ARE 
GIVEN 
IN 
PHYSICAL 
COORDINATES 
(0.0 
THROUGH 
1023.0 FOR X; 0.0 THROUGH 780.0 FOR 
V). 
THE LOGICAL-ORIGIN AND THE LOGICAL-MAX ALLOWS THE USER 
TO 
IMPLICITLY 
DEFINE 
A LOGICAL COORDINATE SYSTEM WHICH THEN MAPS 
INTO THE SPECIFIED PHYSICAL COORDINATE SYSTEM. 
SEE 
LPLOT 
AND 
PPLOT. 
ORACKET 
<NAME> 
SEARCHES 
THE 
DICTIONARY FOR <NAME> AND OUTPUTS THE 
ADDRESS AND THE THREE CHARACTER/COUNT IDENTIFIERS OF 
WORDS 
THAT PRECEDE <NAME> IN THE DICTIONARY AND THE 
THAT 
~OLLOW <NAME> IN THE DICTIONARY. 
DICTIONARY 
THE 
FOUR 
FOUR WORDS 
BT, 
(A) 
<ADDRESS> 
<VALUE> 
BT, 
BUFFER 
BYTE 
D-24 
THE ASSEMBLER MNEMONIC 
FOR 
THE 
VARIAN 
BT 
INSTRUCTION 
(BIT 
TEST). 
<BLOCK#> 
BUFFER 
<ADDRESS> 
OBTAIN 
A CORE 
BUFFER 
FOR 
THE SPECIFIED BLOCK AND LEAVE THE 
STARTING ADDRESS OF THE BUFFER ON THE STACK. 
THE BLOCK IS 
~OT 
READ 
FROM DISC AND IS AUTOMATICALLY MARKED AS UPDATED (I.E. 
THE 
CO~TE~TS OF THE CORE BUFFER WILL BE WRITTEN 
ONTO 
DISC 
OR 
TAPE 
WHEN 
THE BUFFER SPACE IS NEEDED FOP ANOTHER BLOCK). 
USE 
THIS WORD RATHER THAN BLOCK WHEN AN ENTIRE BLOCK IS GOING TO 3E 
RE-WRITTEN, 
TO REDUCE DISC ACCESSES. 
<ADDRESS> 
BYTE 
<BYTE-ADDRESS> 
CONVERT THE MEMORY <ADDRESS> TO A BYTE-ADDRESS 
AND 
LEAVE 
THE 
BYTE-ADDRESS ON THE STACK. 
THIS CONVERSION IS A LOGICAL ROTATE 
OF 
THE 
MEMORY 
ADDRESS 
ONE BIT LEFT. 
NOTE THAT THIS WORD IS 
EQUIVALENT TO A MULTIPLICATION BY 2 ONLY IF THE MULTIPLICAND IS 
POSITIVE. IF THE MULTIPLICAND IS NEGATIVE THEN A LOGICAL ROTATE 
LEFT IS NOT EQUIVALENT TO A MULTIPLICATION BY 2. 
Feb. 1979 

FORTH GLOSSARY 
!"#$f.' ()*+,-.10123456789: j< .. >?@AZC\]"'_ 
C.ORG 
A VARIABLE WHOSE VALUE SPECIFIES 
THE 
STARTING 
ADDRESS 
OF 
A 
BUFFER 
CONTAINING THE DOUBLE-WORD DATA POINTS FOR AN FFT. 
SEE 
DFoURTRAN, DINVTRAN AND LENGTH. 
CASE 
(C2+,P) 
<VALUEl> 
<VALUE2> 
CASE 
••• 
THEN 
<VALUE1> 
<VALUE2> 
CASE 
••• 
ELSE 
••• 
THEN 
IF <VALUEl> EQUALS <VALUE2>, 
DROP BOTH <VALUEl> 
AND 
<VALUE2> 
AND 
EXECUTE THE WORDS DIRECTLY FOLLOWING CASE, 
UP TO THE NEXT 
ELSE OR THEN. IF <VALUE1> DOES NOT EQUAL <VALUE2> THEN <VALUE2> 
IS DROPPED BUT <VALUE1> IS LEFT ON 
THE 
STACK 
AND 
THE 
WORDS 
FOLLOWING 
THE 
ELSE 
(OR THE THEN, 
IF NO ELSE IS PRESENT) 
A~E 
EXECUTED. 
NOTE THAT EVERY CASE MUST HAVE A 
TERMINATING 
THEN. 
CASE 
IS 
EQUIVALENT TO THE SEQUENCE "OVER:: IF DROP". 
CASE IS 
USED TO COMPARE <VALUE1> AGAINST A LIST OF POSSIBLE VALUES, FOR 
EXAMPLE: 
<VALUE1> 
<VALUE2> 
CASE 
(ACTION FOR <VAlUE2» 
ELSE 
<VALUE3> 
CASE 
(ACTION FOR <VALUE3» 
ELSE 
<VALUE4> 
CASE 
(ACTION FOR <VALUE4» 
ELSE 
ELSE 
(NOT EQUAL TO 
ANY OF THE ABOVE) 
THEN 
THEN 
THEN 
THEN 
CELL 
<BYTE-ADDRESS> 
CELL 
<ADDRESS> 
CONVERT THE <BYTE-ADDRESS> TO ITS MEMORY ADDRESS, 
LEAVING 
THE 
MEMORY ADDRESS ON THE STACK. THIS CONVERSION IS A LOGICAL SHIFT 
OF 
THE 
BYTE-ADDRESS 
ONE 
BIT 
RIGHT. 
NOTE THAT THIS WORD IS 
EQUIVALENT TO A DIVISION 
~Y 2 ONLY IF THE DIVIDEND IS POSITIV~. 
IF THE DIVIDEND IS NEGATIVE THEN A LOGICAL SHIFT RIGHT 
IS 
NOT 
EQUIVALENT TO A DIVISION BY 2. 
CHAIN 
CHAIN 
<NAME> 
CONNECT THE CUPRENT VOCABULARY TO ALL DEFINITIONS THAT MIGHT BE 
ENTERED 
INTO 
VOCABULARY 
<NAME> 
IN 
THE FUTURE. 
THE CURRENT 
VOCABULt\~Y MAY NOT BE FORTH OR ASSEMBLER. 
ANY GIVEN VOCAI3ULARY 
MAY ONLY BE CHAINED ONCE BUT MAY BE THE OBJECT OF ANY NUMBER OF 
CHAININGS. 
FOR EXAMPLE, 
EVERY 
USER-DEFINED 
VOCABULARY 
MAY 
INCLUDE THE SEQUENCE "CHAIN FORTH". 
CHAR 
<MAX#CHARACTERS> 
CHAR 
<NAME> 
DEFINE 
A CHARACTER 
STRING. 
ENOUGH 
ROOM 
IS 
ALLOCATED FOR 
<MAX#CHARACTERS> AND THE 
DICTIONARY 
ENTRY 
IS 
IDENTIFIED 
BY 
<NAME>. 
<MAX#CHARACTERS> IS SAVED IN THE DICTIONARY ENTRY FOR 
<NAME> SO THAT ONE CAN ALWAYS DETERMINE THE MAXIMUM 
NUMBER 
OF 
CHARACTERS 
THE 
STRING 
MAY HOLD, 
REGARDLESS OF THE NUMBER OF 
CHA~ACTERS 
CU~RENTLY CONTAINED 
IN 
THE 
STRING. 
SUBSEQUENT 
EXECUTION OF <NAME> WILL PUSH ONTO THE STACK THE ADDRESS 
OF THE 
FIRST TWO BYTES OF THE CHARACTER STRING (THE COUNT BYTE AND THE 
FIRST 
CHARACTER), 
AS REQUIRED, 
FOR EXAMPLE, 
BY COUNT. 
SEE 
CMoVE. 
Feb. 1979 
D-25 

FORTH GLOSSARY 
!"#$f:' ()*+,-.10123456789: ;<:a>?@Al[\)"_ 
CHCURSOR 
CHCURSOR 
<Y-POSN> 
<X-POSN> 
TURNS ON THE 4010 CROSS HAIR CURSORS AND 
~AITS FOR THE OPERATOR 
TO ENTER ANY CHARACTER. 
TWO SINGLE-WORD INTEGERS ARE RETURNED, 
THE X AND Y POSITIONS OF THE CURSORS. 
CHFETCH 
CHFETCH 
<CHAR-CODE> 
RETURNS THE CHARACTER WHICH IS STORED IN THE BYTE POINTED TO BY 
THE BYTE-ADDRESS IN IP. IP IS ALSO INCREMENTED. 
CIA, 
CA) 
<DEVICE-CODE> 
CIA, 
CIB, 
CMOVE 
CODE 
COM 
COMP, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN 
CIA 
INSTRUCTION 
(CLtAR 
AND INPUT TO THE A REGISTER). 
(A) 
<DEVICE-CODE> 
CIB, 
THE 
ASSEMBLER 
MNEMONIC 
FOR THE VARIAN CIS INSTRUCTION (CLEAR 
AND INPUT TO THE B REGISTER). 
<SOURCE-ADDRESS> 
<DESTINATION-ADDRESS> 
CMOVE 
MOVE 
A CHARACTER STRING FROM THE SPECIFIED 
SOURCE 
ADDRESS 
TO 
THE 
SPECIFIED DESTINATION ADDRESS •. THE DESTINATION ADDRESS IS 
ASSUMED TO POINT TO THE DICTIONARY ENTR Y FOR 
A WORD DEFINED 
AS 
A 
FORTH CHARACTER STRING (SEE CHAR). 
THE DICTIONARY ENTRY FOR 
THE DESTINATION FIELD WIll THEN SPECIFY THE MAXIMUM 
NUMBER 
OF 
CHARACTERS 
THAT 
THE STRING MAY HOLD AND ANY EXCESS CHARACTERS 
IN THE SOURCE FIELD WILL NOT BE MOVED. 
BOTH 
<SOURCE-ADDRESS> 
AND 
<DESTINATIO~-ADDRESS> MUST POINT TO THE FIRST TWO BYTES OF 
THEIR RESPECTIVE CHARACTER STRINGS 
(THE 
COUNT 
BYTE 
AND 
THE 
FIRST CHARACTER). 
CODE 
<NAME> 
CREATE 
A DICTIO~ARY ENTRY DEFINING 
<NA~E> AS 
EQUIVALENT TO THE 
SEQUF.NCE OF ASSEMBLER CODE THAT FOLLOWS 
<NAME>. 
THE 
CONTEXT 
VOCABULARY 
IS 
SET 
TO 
ASSEMBLER. 
IT 
IS 
VERY IMPORTANT TO 
REMEMBER 
THAT 
FORTH'S 
COMPILATION 
FLAG 
IS 
NOT 
SET 
WHILE 
ASSEMBLI~G MACHINE CODE INSTRUCTIONS, THAT IS, FORTH REMAINS IN 
E X E CUT ION MODE. 
<VALUE> 
COM 
<RESULT> 
FORM THE ONES-COMPLEMENT OF <VALUE> AND LEAVE 
IT ON THE 
ST~CK. 
( A) 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
COMP 
INSTRUCTION 
(COMPLEMENT AND COMBINE REGISTERS). 
CONSTANT 
<VALUE> 
CONSTANT 
<NAME> 
CONTEXT 
D-26 
DEFINE 
A 
WORD 
<NAME> 
WHICH 
WHEN 
EXECUTED 
WILL 
PUSH 
ITS 
SINGLE-WORD 
VALUE 
ONTO 
THE 
STACK. 
THE 
VALUE OF <NAME> IS 
I NIT I A LIZ EDT 0 < V A L U E > • 
THE < V A L U E > OF 
THE 
CON S TAN T 
MAY 
B E 
CHANGED BY THE SEQUENCE "<NEW-VALUE> • <NAME> 
!". 
A VARIABLE 
CONTAINING 
A POINTER 
TO THE VOCABULARY IN WHICH 
DICTIONARY SEARCHES ARE TO BEGIN. SEE CURRENT. 
Feb. 1979 

FORTH GLOSSARY 
! U#$E:' () *+, -./0123456789: ; <. > ?Q)AZ[ \ JA_ 
CONTINUED (E) 
<BLOCK#> 
CONTINUED 
COUNT 
CONTINUE INTERPRETATION WITH THE SPECIFIED BLOCK. 
THE SEQUENCE 
"1 +BLOCK CONTINUED" CONTINUES 
INTERPRETATION 
WITH 
THE 
NEXT 
BLOCK. 
<ADDRESS> 
COUNT 
<COUNT> 
<ADDRESS> 
POINTS 
TO 
THE FIRST TWO BYTES OF A FORTH CHARACTER 
STRING AND COUNT WILL RETURN THE NUMBER OF 
CHARACTERS 
IN 
THE 
STRING 
ON 
TOP OF THE STACK AND THE BYTE-ADDRESS OF THE STRING 
WILL f3E STORED IN IP. 
IT IS ASSUMED THAT THE FIRST BYTE OF THE 
STRING IS THE CHARACTER COUNT AND THE ACTUAL STRING STARTS WITH 
THE SECOND BYTE. 
THIS WORD IS USUALLY FOLLOWED BY EITHER WRITE 
OR T YP E • 
( A ) 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
(COMPLE~ENT THE A REGISTER). 
VARIAN 
CPA 
INSTRUCTION 
CPU 
(A) 
<VALUE> 
CPU 
<NAME> 
CR 
CRATE 
DEFINE 
<NAME> 
AS 
A 
SINGLE-WORD 
MACHINE 
INSTRUCTION 
WHOSE 
MACHINE CODE REPRESENTATION IS <VALUE>. WHEN <NAME> IS EXECUTED 
IT WILL REQUIRE NO PARAMETERS ON THE STACK AND <VALUE> WILL 
BE 
STORED 
IN THE NEXT AVAILABLE DICTIONARY LOCATION. 
SEE Dl, 
10 
AND MIC PU. 
OUTPUTS A CARRIAGE-RETURN, 
LINE-FEED 
TO 
THE 
CURRENT 
OUTPUT 
DEVICE (USUALLY THE OPERATOR'S TERMINAL). 
A 
VARIABLE USED BY THE CAMAC WORDS TO CONTAIN THE CRATE NUMBER 
FOR 
CAMAC 
DEFINITIONS 
WHICH 
ARE 
BEING 
COMPILED 
INTO 
THE 
DICTIONARY. THE DEFAULT VALUE OF THIS VARIABLE IS 1. 
CUR 
(T) 
CURRENT 
A VARIABLE 
CONTAINING THE PHYSICAL RECORD NUMBER BEFORE 
WHICH 
THE MAG TAPE IS CURRENTLY POSITIONED. REWIND SETS CUR TO ZERO. 
A VARIABLE CONTAINING A POINTER TO THE 
VOCABULARY 
INTO 
WHICH 
NEW WORDS ARE TO BE ENTERED. 
THE SEQUENCE "CURRENT 
@ @" lEAVES 
THE LINK ADDRESS OF THE NEXT ENTRY TO BE DEFINED. 
CURSE 
CURSE 
<CHAR-CODE> 
<Y-POSN> 
<X-POSN> 
TURNS 
O~ THE 4010 CROSS HAIR CURSORS AND WAITS FOR THE OPERATOR 
TO ENTER ANY CHARACTER. THE CURSOR POSITION IS SAVED IN ICURSE. 
<X-POSN> 
AND <Y-POSN> ARE FLOATING-POINT VALUES SPECIFYING THE 
PHYSICAL POSITION OF THE CURSOR CROSS HAIR AND 
<CHAR-CODE> 
IS 
THE 
ASCII 
CHARACTER 
CODE FOR THE CHARACTER THAT THE OPERATOR 
E~TERED. 
THE TERMINAL IS PUT BACK INTO 
ALPHA 
MODE 
WITH 
THE 
CURSOR AT THE SAVED POSITION. 
Feb. 1979 
D-27 

FORTH GLOSSARY 
! U#$&' () *+,-.10123456769:; <=>?ilAZ( \]"_ 
D 
(OLD) 
A VARIABLE SPECIFYING EITHER THE NUMBER OF DIGITS TO THE RIGHT 
OF THE RADIX POINT IN THE LAST NUMBER INPUT (A 
NEGATIVE 
VALUE 
IF THERE WAS NO RADIX POINT ENTERED) OR THE NUMBER OF DIGITS TO 
FOLLOW 
THE 
RADIX 
POINT 
IN 
THE 
NEXT 
NUMBER 
TO BE OUTPUT. 
REPLACED 
~Y #0 FOR INPUT AND DPL FOR OUTPUT. 
01 
<OW-VALUE> 
<ADDRESS> 
01 
STORE <OW-VALUE> STARTING AT THE SPECIFIED MEMORY ADDRESS. 
0* 
<OW-FRACTIoN1> 
<OW-FRACTION2> 
D* 
<OW-FRACTION-RESULT> 
MULTIPLY 
TH~ TWO DOUBLE-WORD FRACTIONS LEAVING THE 
RESULT, 
A 
DOUBLE-WORD FRACTION ON THE STACK. NOTE THAT THE MULTIPLICATION 
OF TWO FRACTIONS WILL ALWAYS GENERATE A FRACTIONAL RESUL T. NOTE 
THAT 
THIS 
WORD 
DOES 
NOT 
MULTIPLY 
DOUBLE-WORD INTEGERS BUT 
MULTIPLIES DOUBLE-WORD FRACTIONS. 
0*1 
<OW-VALUE> 
<VALUEl> 
<VALUE2> 
0*1 
<OW-RESULT> 
MULTIPLY <OW-VALUE> BY <VALUE!> AND THEN DIVIDE THE 
RESULT 
BY 
<VAlUE2>, 
LEAVING THE RESULT, 
A DOUBLE-WORD INTEGER, 
ON THE 
STACK. 
D+ 
<DW-VALUEl> 
<DW-VAlUE2> 
0+ 
<DW-RESUlT> 
DOUBLE-WORD INTEGER ADDITION, LEAVING THE RESULT ON THE STACK. 
0-
<OW-VALUEl> 
<DW-VALUE2> 
D-
<OW-RESULT> 
DOUBLE-WORD 
INTEGER 
SUBTRACTION, 
LEAVING 
THE 
RESULT, 
<DW-VALUEl> -
<DW-VALUE2>, ON THE STACK. 
D-H 
(T) 
LOADS THE DISC HANDLERS. SEE UTIL. 
D. 
<OW-VALUE> 
D. 
01 
D-28 
DOUBLE-WORD 
INTEGER 
OUTPUT. 
OUTPUT <OW-VALUE> TO THE CURRENT 
OUTPUT DEVICE (USUALLY THE 
OPERATOR'S 
TERMINAU. 
THE 
FIELD 
WIDTH IS SPECIFIED BY FlD AND THE NUMBER OF PLACES TO THE RIGHT 
OF THE RADIX POINT ARE SPECIFIED BY DPL. 
<DW-FRACTIONl> 
<DW-FRACTION2> 
DOUBLE-WORD 
FRACTIONAL 
DIVIDE, 
<DW-FRACTION!> 
1 <DW-FRACTION2>, 
ON 
WJRD 
DOES 
NOT 
OIVIDE 
DOUBLE-WORD 
DOUBLE-WORD FRACTIONS. 
01 
<OW-FRACTION-RESlILT> 
LEAVING 
THE 
RESULT, 
THE STACK. 
NOTE THAT THIS 
INTEGERS 
BUT 
DIVIDES 
Feb. 1979 

FORTH GLOSSARY 
1"#$£.'( )*+,-.10123456789: ;< .. >?@AZ(\]A_ 
00 
(OLD) 
00, 
DO< 
DO-
RENAMED DO,. 
A 2CONSTANT WHOSE VALUE IS THE DOUBLE-WORD INTEGER O. 
COMPARE 
TRUE ON 
LEAVE A 
<OW-VALUE> 
00< 
<LOGICAL-VALUE> 
<DW-VALUE> 
DO= 
<LOGICAL-VALUE> 
<OW-VALUE> AGAINST ZERO AND LEAVE A <LOGICAL-VALUE> OF 
THE STACK IF THE INDICATED RELATION IS TRUE, 
OTHERWISE 
<LOGICAL-VALUE> OF FALSE ON THE STACK. 
01 
(OLD) 
RENAMED 01,. 
A 2CONSTANT WHOSE VALUE IS THE DOUBLE-WORD 
FRACTION 
1. 
THIS 
VALUE IS NOT THE DOUBLE-WORD INTEGER 1. 
o2T 
<BLOCK#> 
D2T 
TRANSFER 
THE 
SPECIFIED 
BLOCK FROM DISK TO TAPE. 
SEE O-H AND 
T-H. 
D< 
<OW-VAlUE1> 
<DW-VALUE2> 
0< 
<LOGICAL-VALUE> 
D= 
<DW-VAlUEl> 
<DW-VAlUE2> 
D-
<LOGICAL-VALUE> 
D> 
<OW-VALUEl> 
<DW-VAlUE2> 
D> 
<LOGICAL-VALUE> 
COMPARE <Dw-VAlUEl> AND <DW-VAlUE2> AND LEAVE A <LOGICAL-VALUE> 
OF TRUE ON 
THE 
STACK 
IF 
THE 
INDICATED 
RELATION 
IS 
TRUE, 
OTHERWISE LEAVE A <LOGICAL-VALUE> OF FALSE ON THE STACK. 
D@ 
<ADDRESS> 
D@ 
<OW-VALUE> 
FETCH 
THE 
DOUBLE-WORD 
VALUE 
STARTING 
AT 
MEMORY 
LOCATION 
<ADDRESS> AND PUSH IT ONTO THE STACK. 
DABS 
<OW-VALUE> 
DABS 
<DW-RESULT> 
FORM THE ABSOLUTE VALUE OF 
<OW-VALUE> 
AND 
lEAVE 
IT 
ON 
THE 
STACI<. 
DAR, 
(A) 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
DAR 
INSTRUCTION 
(DECREMENT THE A REGISTER). 
OASK 
DASK 
<OW-VALUE> 
REOUEST THE INPUT OF A DOUBLE-WORD VALUE FROM THE TERMINAL. 
Feb. 1979 
0-29 

FORTH GLOSSARY 
(A ) 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
(DECREMENT THE B REGISTER). 
VARIAN 
Df3R 
INSTRUCTION 
DCONSTANT (OLD) 
DECIMAL 
DECR, 
RENAMED 2CONSTANT. 
seTS THE NUMERIC CONVERSION BASE TO DECIMAL MODE, 
THAT IS, SET 
THE VARIABLE BASE TO 10. SEE OCTAL AND HEX. 
(A) 
<VALUE> 
DECR, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
DECR 
INSTRUCTION 
(DECRE~ENT AND COMBINE REGISTERS). 
DEFINITIONS 
<NAME> 
DEFINITIONS 
SET THE CURRENT VOCABULARY 
(INTO 
WHICH 
NF.W 
DEFINITIONS 
ARE 
BEING 
ENTERED) 
TO 
THE VOCABULARY <NAME>. 
<NAME> NEED NOT BE 
SPECIFIED EXPLICITLY, IN WHICH CASE <NAME> IS ASSUMED TO BE THE 
CONTEXT VOCABULARY. 
DELIMITER (OLD) 
OF I X 
DFLOAT 
DFOU R TR AN 
0-30 
A VARIABLF. SPECIFYING THE CHARACTER THAT TERMINATES A WORD. 
<FP-VALUE> 
DFIX 
<OW-RESULT> 
TRUNCATE THE FLOATING-POINT 
VALUE 
TO 
A 
DOUBLE-WORD 
VALUE. 
IF ONE wANTS TO ROUND THE FLOATING-POINT VALUE 
TRUNCATION, 
THE 
FLOATING-POINT 
VALUE 0.5 SHOULD BE 
<FP-VALUE> PRIOR TO EXECUTING DFIX. SEE SFIX. 
<OW-VALUE> 
DFLOAT 
<FP-RESUL T> 
INTcG'.:R 
PRIOR TO 
ADDEO TO 
CONVERT THE DOUBLE-WORD INTEGER TO A FLOATING-POINT VALUE. 
PERFORM A RADIX 2 FAST FOURIER TRANSFORM USING THE COOLEY-TUKEY 
ALGORITHM. 
THE STARTING BUFFER ADDRESS OF THE INPUT DATA 
MUST 
BE 
STOPED 
IN THE VARIABLE C.ORG ANO THE NUMBER OF DATA POINTS 
(A POWER OF 2) MUST HAVE BEEN SPECIFIED BY EXECUTING 
THE 
WORD 
LENGTH. 
THE 
INPUT 
DATA 
IS 
A VECTOR OF REAL, 
DOUBLE-WORD 
INTEGERS AND THE RESULT (WHICH OVERWRITES THE INPUT DATA) IS 
A 
VECTOR 
OF 
COMPLEX, 
DOUBLE-WORD INTEGERS. 
SINCE THE FOURIER 
TRANSFORM OF N REAL POINTS IS HERMITIAN 
(REAL 
PART 
EVEN 
AND 
IMAGINARY 
PART 
ODD) ONLY (N/2)+1 COMPLEX POINTS ARE RETURNED. 
THE IMAGINARY PART OF THE FIRST AND LAST DATA POINT WILL ALWAYS 
BE ZERO SINCE THE IMAGINARY PART IS AN ODD FUNCTION. THE BUFFER 
FOR AN N-POINT 
FFT 
MUST 
BE 
OF 
LENGTH 
(N*2)+4 
WORDS 
(THE 
ADDITIONAL 
4 
WORDS 
ARE 
REQUIRED FOR THE LAST OF THE (N/2)+1 
COMPLEX POINTS RETURNED). SEE D!NVTRAN. 
Feb. 1979 

FORTH GLOSSARY 
!"#$~·()*+,-.I0123456789:;<·>?@AZ(\]A_ 
DHALF 
DHSIN 
A ZCONSTANT WHOSE VALUE IS 0.5 WHEN CONSIDERED AS A DOUBLE-WORD 
FRACTION. 
<OW-FRACTION> 
DHSIN 
<DW-FRACTION-RESULT> 
REP LAC E THE < D W - f R ACT ION>, G I V E N I N HAL F C I R C L E S , WIT H I -:- S SIN E 
(IN RADIANS) ALSO A DOUBLE-WORD FRACTION. 
THIS 
WORD 
IS 
THt 
BUILDING BLOCK FOR THE FLOATING-POINT TRIGONOMETRIC FUNCTIONS. 
DIGILIGHTS 
<VALUE> 
<START#> 
<END#> 
DIGILIGHTS 
WRITE 
<VALUE> TO THE SPECIFIED DIGILIGHTS ON THE CAMAC DISPLAY 
PA NE L. 
DIGISWITCHES 
<START#> 
<END#> 
DIGISWITCHES 
<RESULT> 
DINVTRAN 
DISCARD 
READS IN A GROUP OF DIGISWITCHES FROM THE CAMAC DISPLAY 
PANEL. 
<START#> 
AND <END#> SPECIFY THE STARTING AND ENDING DIGISwITCH 
NUMBERS AND IF 
4 
OR 
FEWER 
DIGISWITCHES 
ARE 
SPECIFIED 
THE 
<RESULT> 
WILL 
BE 
A SINGLE-WORD 
INTEGER 
WHILE IF 5 OR MORE 
DIGISWITCHES ARE SPECIFIED, 
<RESULT> 
WILL 
BE 
A DOUBLE-WORD 
IN TE GE p. 
PERFORM 
A RADIX 
2 
INVERSE 
COOlEY-TUKEY ALGORITHM. 
THIS 
FFT PERFORMED BY DFOURTRAN, 
(N/2'+1 COMPLEX, DOU8LE-WORD 
DOUBLE-WORD INTEGERS. 
FAST FOURIER 
TRANSFO~M USING THE 
OPERATION IS THE INVERSE 
OF 
THE 
THAT IS, THE INPUT VECTOR CONTAINS 
INTEGERS AND THE RESULT IS N REAL, 
A NULL DEFINITION INTENDED FOR USE AS A STANDARD REMEMBER 
WORD. 
THIS 
NULL 
DEFINITION 
GUARANTEES 
THAT 
THE WORD DISCARD WILL 
ALWAYS BE FOUND. SEE FORGET AND REMEMBER. 
DISK 
(1) 
SETS THE DISC AS THE PRIMARY MASS STORAGE DEVICE. SEE D-H. 
DISK-TO-TAPE 
<START-BLOCK#> 
<END-BLOCK#> 
DISK-TO-TAPE 
DISKO 
TRANSFERS ALL NON-ZERO BLOCKS IN THE SPECIFIED RANGE FROM 
DISK 
TO TAPE. SEE D-H. 
ZERO 
BLOCKS 
1 
THROUGH 
511 
ON 
THE DISC. 
EQUIVALENT TO THE 
SEQUENCE "1 511 ZERODISK". SEE UTIL. 
Feb. 1979 
0-31 

FORTH GLOSSARY 
!"#$&' ()*+,-./0123456789: ;<->?@AZ(\]""_ 
OIV, 
(A) 
<ADDRESS> 
DIV, 
OL 
DLIST 
DMINUS 
DO 
D OU BL E 
DP 
o p* 
THE ASSEMBLER MNEMONIC FOR THE VARIAN DIV 
INSTRUCTION 
(DIVIDE 
THE A AND B REGISTERS BY MEMORY). 
(Al 
<VALUE> 
DL 
<NAME> 
DtFINE 
<NAME> AS A DOUBLE-WORD MACHINE INSTRUCTION WHOSE BASIC 
MACHINE CODE REPRESENTATION IS <VALUE>. WHEN <NAME> IS EXECUTED 
THE TOP NUMBER ON THE STACK 
IS 
INCLUSIVELY 
OR-ED 
WITH 
BOTH 
<VALUE> 
AND 
THE 
CURRENT VALUE OF MODE. 
THIS 16-BIT VALUE IS 
STORED IN THE NEXT AVAILABLE DICTIONARY LOCATION AS 
THE 
FIRST 
WORD OF THE INSTRUCTION. THE SECOND NUMBER ON THE STACK IS THEN 
STORED 
IN THE NEXT AVAILABLE DICTIONARY LOCATION AS THE SECOND 
WORD OF THE INSTRUCTION. SEE CPU, 1/0 AND M/CPU. 
eEl 
<ADDRESS> 
DLIST 
LIST ALL WORDS IN THE DICTIONARY, 
STARTING WITH THE DICTIONARY 
ENTRY POINTED TO BY <ADDRESS>. 
WHEN ONE 
WISHES 
TO 
LIST 
ALL 
ENTRIES 
BEFORE 
A SPECIFIC 
ENTRY, 
THE USUAL SEQUENCE IS "' 
<NAME> DLIST". 
<OW-VALUE> 
DMINUS 
<OW-RESULT> 
NEGATE <OW-VALUE> BY FORMING ITS TWOS-COMPLEMENT. 
CC) 
<ENDING-INCREMENT> 
<STARTING-INCREMENT> 
DO 
••• 
BEGIN A DO lOOP WHICH MUST THEN BE TERMINATED BY EITHER LOOP OR 
+LOOP. 
THE LOOP INDEX BEGINS AT 
<STARTING-INCREMENT> 
AND 
IS 
THEN 
EITHER 
INCREMENTED 
OR DECREMENTED EACH TIME THROUGH THE 
LOOP BY THE WORDS LOOP OR +LOOP. 
COLD) 
RtNAMED 2VARIABLE. 
A VARIA8LE WHOSE VALUE IS THE ADDRESS 
OF 
THE 
NEXT 
AVAILABLE 
WORD IN THE DICTIONARY. SEE HERE AND DP+!. 
THE 
ADDRESS 
OF A SUBROUTINE TO PERFORM DOUBLE-WORD FRACTIONAL 
MULTIPLICATION. 
THIS SUBROUTINE IS CALLED BY THE SEQUENCE "DP* 
6 JSR,". 
DP+ 
DP+ 
THE ADDRESS OF A SUBROUTINE 
TO 
PERFORM 
DOUBLE-WORD 
INTEGER 
ADDITION. 
THIS 
SUBROUTINE 
IS 
CALLED BY THE SEQUENCE "DP+ 6 
JSR,". 
DP+! 
<VALUE> 
DP+! 
D-32 
ADD THE SIGNED <VALUE> TO THE DICTIONARY POINTER, DP. SINCE THE 
DICTIONARY POINTER MAY BE AN INTERNAL REGISTER 
RATHER 
THAN 
A 
VARIABLE, IT SHOULD ONLY BE ACCESSED THROUGH THE WORDS HERE AND 
D P+! • 
Feb. 1979 

FORTH GLOSSARY 
DPL 
A VARIABLE 
WHICH 
ONE 
SETS TO THE NUMBER OF DIGITS THAT THEY 
WISH TO FOLLOW THE RADIX POINT IN A NUMBER TO BE OUTPUT. 
IF DPL 
IS SET TO A NEGATIVE 
VALUE, 
THE 
RADIX 
POINT 
WILL 
NOT 
BE 
PRINTED. SEE FLO AND W.D. 
DPLT 
<X-POSN> 
<Y-POSN> 
DPLT 
DRAWS 
A VECTOR 
ON 
THE 4010 FROM THE CURRENT POSITION 
TO THE 
SPECIFIED OFFSET FROM THE CURRENT POSITION AS GIVEN BY <X-POSN> 
AND <Y-POSN>. 
THE PARAMETERS TO THIS WORD ARE OFFSETS FROM THE 
CURRENT POSITION AND NOT PHYSICAL 
COORDINATES. 
<X-POSN> 
AND 
<Y-POSN> 
ARE 
SINGLE-WORD 
INTEGERS 
IN 
THE 
RANGE 0-1023 AND 
0-780. 
DPOLYVAL 
<#TERMS> 
DPOLYVAL 
<NAME> 
DEFINE <NAME> AS A WORD WHICH WHEN EXECUTED, 
WILL 
EVALUATE 
A 
POLYNOMIAL 
EXPRESSION. 
THE .POLYNOMIAL MUST BE OF THE FORM Y • 
AO + X(A1 + X(A2 + ••• » 
AND IS EVALUATED ACCORDING TO HORNER'S 
RULE (FROM THE INNERMOST LEVEL OUTWARDS). 
FOLLOWING <NAME> THE 
COEFFICIENTS AO, 
A1, 
A2, 
••• 
MUST 
APPEAR 
AS 
DOUBLE-WORD 
FRACTIONS 
(THE 
WORD 
FD, 
IS HANDY FOR THIS) IN REVERSE 
ORDER 
(THAT IS, 
THE LAST TERM FIRST AND AO LAST). 
SINCE THE 
HIGHER 
COEFFICIENTS 
ARE 
ALMOST 
ALWAYS 
THE 
SMALLEST IN VALUE, 
THE 
SMALLER TERMS ARE ADDED FIRST IN ORDER TO 
MINIMIZE 
TRUNCATION 
ERRORS. 
DPREC 
(OLD) 
SETS 
AN 
INTERNAL 
FLAG 
TO INDICATE THAT NUMBERS CONTAINING A 
PERIOD ARE TO BE INTERPRETED AS DOUBLE-WORD INTEGERS, 
NOT 
AS 
FLOATING-POINT NUMBERS. SEE FLOATING. 
DROP 
<VALUE> 
DROP 
DUMP 
DROP THE TOP <VALUE> FROM THE STACK. 
<STARTING-ADDRESS> 
<#CELLS> 
DUMP 
DUMP 
THE 
CONTENTS 
OF 
<#CELLS> 
OF 
MEMORY, 
STARTING 
<STARTING-ADDRESS> ONTO THE CURRENT OUTPUT DEVICE (USUALLY 
OPERATOR'S TERMINAL). BOTH THE ADDRESS AND THE CONTENTS OF 
WORD ARE PRINTED USING THE CURRENT NUMBER BASE. 
WITH 
THE 
EACH 
DUMP 
(OLD) 
<STARTING-ADDRESS> 
DUMP 
DUMP THE CONTENTS OF MEMORY, 
STARTING WITH <STARTING-ADDRESS>, 
ONTO 
THE 
CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAU. 
THE OUTPUT IS TERMINATED BY PRESSING 
ANY 
TERMINAL 
KEY. 
DUP 
<VALUE> 
DUP 
<VALUE> 
<VALUE> 
Feb. 1979 
DUPLICATE THE TOP <VALUE> ON THE STACK. 
( A , 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
DXR 
INSTRUCTION 
(DECREMENT THE X REGISTER). 
NOTE THAT THE X 
REGISTER 
IS 
THE 
STACK 
POINTER 
IN 
VARIAN 
FORTH, 
THEREFORE THIS INSTRUCTION 
ALLOCATES ONE MORE WORD OF THE STACK. 
D-33 

FORTH GLOSSARY 
E 
(OLD) 
<FP-NUMBER> 
E 
<VALUE> 
<FP-RESULT> 
THE GIVEN <FP-NUMBER> IS SCALED BY 10 ** <VALUE>. 
E ) 
( A ) 
SETS THE VARIABLE MODE TO 6, 
SPECIFYING 
INDEXING 
OFF 
THE 
8 
REGISTER 
FOR THE NEXT MEMORY REFERENCE INSTRUCTION. 
SINCE THE 
ADDRESS OF THE DICTIONARY ENTRY BEING EXECUTED IS CONTAINED 
IN 
THE 
B REGISTER THIS MNEMONIC IS MEANT TO INDICATE INDEXING OFF 
THE CURRENT DICTIONARY ENTRY. 
E. 
<FP-VALUE> 
E. 
OUTPUT THE FLOATING-POINT VALUE IN E-FORMAT, 
THAT 
IS, 
AS 
A 
FRACTION RAISEO TO A POWER OF 10, 
TO THE CURRENT OUTPUT DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAL). 
THE 
OUTPUT 
FORMAT 
IS 
SPECIFIED BY THE WORD W.O. 
THE FIELD WIDTH MUST INCLUDE THE 
5 
SPACES REQUIRED BY THE EXPONENT. 
E1 
<ADDRESS> 
E1 
EDIT 
EDITOR 
EJECT 
ELSE 
ELSE, 
D-34 
EQUIVALENT TO THE SEQUENCE "F@ E.". 
<BLOCK#> 
EDIT 
EDIT 
THE SPECIfIED BLOCK. 
IF THE EDITOR IS NOT ALREADY LOADED 
INTO THE DICTIONARY IT WILL BE LOADED. 
THE BLOCK BEING 
EDITED 
IS FIRST LISTED. 
( P ) 
EDITOR 
IS 
THE 
NAME 
OF 
THE EDITOR VOCABULARY SO THAT IF THE 
EDITOR VOCABULARY HAS BEEN LOADED INTO THE DICTIONARY 
ONE 
MAY 
USE 
THE 
WORD 
EDITOR 
TO 
RE-INVOKE 
THE 
EDITOR 
VOCABULARY 
(FOLLOWING THE SWITCH TO SOME OTHER VOCABULARY). 
HAVE THE LINE PRINTER PAGE EJECT TO THE TOP OF THE NEXT PAGE. 
(C2,P) 
THE WORD ELSE IS USED IN AN IF-THEN CLAUSE TO SPECIFY WHERE THE 
IF BRANCH IS TO GO ON A FALSE <LOGICAL-VALUE>. 
THE ELSE CLAUSE 
IS OPTIONAL AND MAY BE OMITTED. 
( A ) 
THIS WORD IS USED IN AN IF,-THEN, CLAUSE TO SPECIFY WHERE TO GO 
ON A FALSE <JUMP-CONDITION>. 
THE ELSE, 
CLAUSE IS OPTIONAL AND 
MAY BE OMITTED. 
Feb. 1979 

FORTH GLOSSARY 
END 
(C2-,P) 
<LOGICAL-VALUE> 
END 
THIS 
WORD 
MARKS 
THE 
END 
OF 
A BEGIN-END 
LOOP. 
IF 
THE 
<LOGICAL-VALUE> 
IS 
TRUE 
THE 
LOOP 
IS TERMINATED, 
OTHERWISE 
CONTROL RETURNS TO THE FIRST WORD FOLLOWING 
THE 
CORRESPONDING 
BEGIN. 
END, 
(A) 
<JUMP-CONDITION> 
END, 
ENDFILE 
THIS WORD MARKS THE END OF A BEGIN,-END, LOOP. IF THE SPECIFIED 
<JUMP-CONDITION> 
IS 
TRUE THE LOOP IS TERMINATED, 
OTHERWISE A 
JUMP IS MADE 
BACK 
TO 
THE 
FIRST 
INSTRuCTION 
FOLLOWING 
THE 
BEGIN,. 
WRITE AN 
E~D-OF-FILE ON THE MAG TAPE AND WAIT FOR THE OPERATION 
TO COMPLETE. SEE WF. 
ERA, 
(A) 
<ADDRESS> 
ERA, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
ERA 
INSTRUCTION 
(EXCLUSIVE-OR MEMORY WITH THE A REGISTER). 
ERASE-CORE 
MARK ALL BLOCK 
BUFFERS 
AS 
EMPTY. 
UPDATED 
BLOCKS 
ARE 
NOT 
FLUSHED. 
THE 
CONTENTS 
OF 
THE 
BUFFERS 
ARE 
SUBSfQUENTLY 
UNDEFINED. 
EXC, 
(A) 
<FUNCTION-DEVICE> 
EXC, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN EXC INSTRUCTION (EXTERNAL 
CONTROL TO A DEVICE). 
EXECUTE 
<ADDRESS> 
EXECUTE 
EXECUTE THE WORD SPECIFIED BY <ADDRESS>. 
<ADDRESS> MUST 
RE THE 
COMPILATION ADDRESS OF A DICTIONARY ENTRY, 
AS RETURNED BY 
THE 
WORD FIND. THE NORMAL SEQUENCE IS THEN "FIND <NAME> EXECUTE". 
EXIT 
(C) 
SKIP ONE LEVEL BACK, TO WHOEVER EXECUTED THE WORO IN WHICH EXIT 
EXISTS. 
THIS WORD PROVIDES A METHOD OF EXITING A WORD WITHOUT 
GOING ALL THE WAY THROUGH THE WORD TO THE SEMI-COLON. 
EXIT 
(OLD) 
RENAMED LEAVE. 
Feb. 1979 
0-35 

FORTH GLOSSARY 
F 
(OLD) 
RENAMED FLO. 
F! 
<FP-VAlUE> 
<ADDRESS> 
F! 
STORE <FP-VAlUE> STARTING AT MEMORY lOCATIQN <ADDRESS>. 
F* 
<FP-VALUEl> 
<FP-VAlUE2> 
F* 
<FP-RESUL T> 
FLOATING-POINT MULTIPLICATION, LEAVING THE RESULT ON THE STACK. 
F+ 
<FP-VAlUEl> 
<FP-VAlUE2>· 
F+ 
<FP-RESUlT> 
FLOATING-POINT ADDITION, LEAVING THE RESULT ON THE STACK. 
F+! 
<FP-VALUE> 
<ADDRESS> 
F+! 
ADO <FP-VALUE> TO THE FLOATING-POINT VALUE STARTING 
AT 
MEMORY 
LOCATION <ADDRESS>. 
<FP-VAlUE> MAY BE A POSITIVE OR A NEGATIVE 
VALUE. 
EQUIVALENT TO THE SEQUENCE "<ADDRESS> F@ <FP-VALUE> F+ 
<ADDRESS> F!". 
F-
<FP-VALUE1> 
<FP-VALUE2> 
f-
<FP-RESUlT> 
FLOATING-POINT SUBTRACTION, 
LEAVING THE RESULT, 
<FP-VAlUE1>-
<FP-VALUE2>, ON THE STACK. 
F. 
<FP-VALUE> 
F. 
FLOATING-POINT OUTPUT. 
OUTPUT THE FLOATING-POINT VALUE TO 
THE 
CURRENT 
OUTPUT 
DEVICE (USUALLY THE OPERATOR'S TERMINAL). 
THE 
OUTPUT FQRMAT MAY BE SPECIFIED BY THE WORD W.O. 
FI 
<FP-VALUE1> 
<FP-VALUE2> 
FI 
<FP-RESULT> 
F/620 
FLOATING-POINT 
DIVIDE, 
LEAVING 
THE 
RESULT, 
<FP-VAlUEl 
I 
<FP-VALUE2>, ON THE STACK. 
A CONSTANT 
-1 
o 
1 
2 
DENOTING EITHER THE CPU TYPE 
OR THE INSTALLATION: 
= SOLAR 620/F WITH TELETYPE AND TEKTRONIX 611 
= 620/L 
= 620/F 
= V74 
FO 
(OLD) 
RENAMED FO •• 
FO. 
AN FCONSTANT WHOSE VALUE IS THE FLOATING-POINT NUMBER 0.0. 
FO< 
<FP-VALUE> 
FO< 
<LOGICAL-VALUE> 
FO-
<FP-VALUE> 
FO: 
<LOGICAL-VALUE> 
D-36 
COMPARE 
<FP-VALUE> 
AGAINST 0.0 AND LEAVE A <LOGICAL-VALUE> OF 
TRUE IF THE INDICATED RELATION 
IS 
TRUE, 
OTHERWISE 
LEAVE 
A 
<LOGICAL-VALUE> OF FALSE ON THE STACK. 
Feb. 1979 

FURTH GLOSSARy 
FlO 
(JLD) 
RENAMED FlO •• 
FlO. 
AN FCONSTANT WHOSE VALUE IS THE FLOATING-POINT NUMBER 10.0. 
F180. 
AN FCONSTANT WHOSE VALUE IS THE FLOATING-POINT NUMBER 180.0. 
F2LOG 
<FP-VALUE> 
F2LUG 
<FP-RESULT> 
COMPUTE 
THE 
LOGARITHM, 
BASE 
2 
OF <FP-VALUE> AND LEAVE THE 
RESULT ON THE STACK. 
F2XP 
<FP-VALUE> 
F2XP 
<FP-RESULT> 
COMPUTE 2.0 ** <FP-VALUE> AND LEAVE THE RESULT ON THE STACK. 
F90. 
AN FCONSTANT WHOSE VALUE IS THE FLOATING-POINT NUMBER 90.0. 
F< 
<FP-VALUE1> 
<FP-VALUE2> 
F< 
<LOGICAL-VALUE> 
F= 
<FP-VALUEl> 
<FP-VALUE2> 
F2 
<LOGICAL-VALUE> 
F> 
<FP-VALUE1> 
<FP-VALUE2> 
F> 
<LOGICAL-VALUE> 
COMPARE <FP-VALUE1> AND <FP-VALUE2> AND LEAVE A <LOGICAL-VALUE> 
OF TRUE ON 
THE 
STACK 
IF 
THE 
INDICATED 
RELATION 
IS 
TRUE, 
OTHERWISE LEAVE A <LOGICAL-VALUE> OF FALSE ON THE STACK. 
F? 
<ADDRESS> 
F? 
EQUIVALENT TO THE SEQUENCE "F@ F.". 
FABS 
<FP-VALUE> 
FABS 
<FP-RESULT> 
REPLACE <FP-VALUE> BY ITS ABSOLUTE VALUE. 
FASK 
FASK 
<FP-VALUE> 
REQUEST THE INPUT OF A FLOATING-POINT NUMBER FROM THE TERMINAL. 
FCONSTANT 
<FP-VALUE> 
FCONSTANT 
<NAME> 
DEFINE 
THE 
WORD 
<NAME> 
WHICH 
WHEN 
EXECUTED 
WlLL PUSH ITS 
FLOATING-POINT VALUE ONTO THE STACK. 
THE VALUE 
OF 
<NAME> 
IS 
INITIALIZED 
TO 
<FP-VALUE>. 
THE VALUE 
OF THIS CONSTANT 
MAY BE 
CHANGED BY EXECUTING THE SEQUENCE "<FP-VALUE> , <NAME> F!". 
FD, 
<FP-VALUE> 
FD, 
Feb. 1979 
CONVERTS <FP-VALUE> TO A DOUBLE-WORD FRACTION 
AND 
PLACES 
THE 
FRACTION IN THE NEXT TWO DICTIONARY LOCATIONS. 
D-37 

FDATN 
FDCOS 
FDSIN 
FOTAN 
FEXP , 
FEXP10 
FHALF 
FORTH GLOSSARY 
<FP-VALUE1> 
<FP-VALUE2> 
FDATN 
<FP-RESULT> 
COMPUTE 
THE 
ARCTANGENT 
(IN 
DEGREES) 
OF 
<FP-VALUEl> 
I 
<FP-VALUE2>, 
LEAVING THE RESULT ON THE STACK. 
THE RESULT WILL 
BE IN THE RANGE 0.0 THROUGH 359.999. 
<FP-VALUE> 
FDCOS 
<FP-RESULT> 
COMPUTE THE COSINE OF <FP-VALUE> (IN 
DEGREES) 
AND 
LEAVE 
THE 
RESULT ON THE STACK. 
<FP-VALUE> 
FDSIN 
<FP-RESULT> 
COMPUTE 
THE 
SINE 
OF 
<FP-VALUE> 
(IN 
DEGREES) AND LEAVE THE 
RESULT ON THE STACK. 
<FP-VALUE> 
FDTAN 
<FP-RESULT> 
COMPUTE THE TANGENT OF <FP-VALUE> (IN DEGREES) 
AND 
LEAVE 
THE 
RESULT ON THE STACK. 
<FP-VALUE> 
FEXP 
<FP-RESULT> 
COMPUTE 
E ** 
<FP-VALUE> 
(WHERE E IS THE BASE OF 
TH~ NATUKAL 
LOGARITHMS, 2.71828 ••• ) AND LEAVE THE RESULT ON THE STACK. 
<FP-VALUE> 
FEXPIO 
<FP-RESULT> 
COMPUTE 10.0 ** <FP-VALUE> AND LEAVE THE RESULT ON THE STACK. 
AN FCONSTANT WHOSE VALUE IS THE FLOATING-POINT NUMBER 0.5. 
FIND 
FIND 
<NAME> 
<RESULT> 
IF A DICTIONARY ENTRY FOR <NAME> IS FOUND THEN FINO RETURNS THE 
COMPILATION ADDRESS OF <NAME> (THE ADDRESS 
THAT WOULD 
NORMALLY 
BE 
COMPILED WHEN <NAME> IS ENCOUNTERED IN A COLON-DEFINITION). 
IF THE DICTIONARY ENTRY IS NOT FOUND THEN FIND RETURNS A 
VALUE 
OF ZERO ON THE STACK. 
FIX 
<STARTING-BLOCK#> 
<ENDING-8LOCK#> 
FIX 
FL2 
FL2E 
D-38 
WORD REPLACEMENT. THE WORDS TO BE REPLACED MUST HAVE PREVIOUSLY 
BEEN 
SPECIFIED USING THE WORDS REPLACE AND $REPLACE. 
THE WORD 
FIX THEN GOES THROUGH THE DESIGNATED BLOCKS 
AND 
REPLACES 
ALL 
OCCURENCES 
OF 
THE 
WORDS 
THAT 
WERE SPECIFIED BY 
REPLA~E AND 
$REPLACE WITH THEIR NEW 
REPRESENTATIONS. 
A LISTING 
OF 
ALL 
CHANGES 
IS 
OUTPUT 
TO THE CURRENT OUTPUT DEVICE. 
BEWARE THAT 
THIS WORD REPLACES ALL OCCURENCES OF THE SPECIFIED WORDS, 
EVEN 
WITHIN COMMENTS OP CHARACTER STRINGS! 
AN 
FCONSTANT 
WHOSE 
VALUE 
IS 
THE 
FLOATING-POINT 
NATURAL 
LOGARITHM OF 2.0, THAT IS, 0.693147181. 
AN FCONSTANT WHOSE VALUE IS THE FLOATING-POINT LOGARITHM, 
BASE 
2 OF E (THE BASE OF THE NATURAL LOGARITHMS, 
2.71828 ••• ), 
THAT 
IS, 1.44269504. 
Feb. 1979 

FORTH GLOSSARY 
FLD 
FLIT 
A VARIABLE THAT ONE SETS TO THE TOTAL FIELD 
LENGT~I DESIRED FOR 
NUMERIC OUTPUT. SEE OPL AND W.O. 
STORE IN THE NEXT AVAILA8LE DICTIONARY LOCATION THE 
ADDR~SS 
OF 
THE 
ROUTINE 
WHICH PLACES FLOATING-POINT LITERALS ON THE STACK 
AT EXECUTION TIME. 
FLN 
<FP-VALUE> 
FLN 
<FP-RESUlT> 
COMPUTE THE NATURAL 
LOGARITHM 
OF 
<FP-VALUE> 
AND 
LEAVE 
THE 
RESULT ON THE STACK. 
FLOATING (OLD) 
SETS 
AN 
INTERNAL 
FLAG 
TO INDICATE THAT NUMBERS CONTAINING A 
PERIOD ARE TO BE INTERPRETED AS FLOATING-POINT NUMBERS, 
NOT 
AS 
DOUBLE-WORD INTEGERS. SEE DPREC. 
FLOG 
<FP-VAlUE> 
FLOG 
<FP-RESULT> 
FLUSH 
FMAX 
FMIN 
FMINUS 
FORGET 
FORMATTER 
Feb. 1979 
COMPUTE THE LOGARITHM, 
BASE 10 OF 
<FP-VAlUE> 
AND 
LEAVE 
THE 
RESULT ON THE STACK. 
wRITE 
ALL 
BLOCKS THAT HAVE BEEN FLAGGED AS UPDATED TO DISC OR 
TAPE. SEE UPDATE. 
<FP-VALUEl> 
<FP-VALUE2> 
FMAX 
<FP-RESULT> 
LEAVE THE GREATER OF <FP-VAlUE1> AND <FP-VALUE2> ON THE STACK. 
<FP-VALUE1> 
<FP-VALUE2> 
FMIN 
<FP-RESULT> 
LEAVE THE LESSER OF <FP-VALUEl> AND <FP-VAlUE2> ON THE STACK. 
<FP-VALUE> 
FMINUS 
<FP-RESULT> 
NEGATE <FP-VALUE> AND LEAVE THE RESULT ON THE STACK. 
FORGET 
<NAME> 
DELETE THE DICTIONARY 
ENTRY 
FOR 
<NAME> 
AND 
ALL 
DICTIONARY 
ENTRIES 
FOLLOWING 
IT (I.E., 
EVERYTHING THAT HAS BEEN ENTERED 
INTO THE DICTIONARY AFTER THE DEFINITION 
OF 
<NAME». 
THOUGH 
<NAME> MUST BE IN THE CONTEXT VOCABULARY, THE WORDS THAT FOLLJW 
IT 
IN THE DICTIONARY ARE DELETED, 
REGARDLESS WHICH VOCABULARY 
THEY BELONG TO. 
NORMALLY, 
FORGET SHOULD NOT BE USED WITHIN 
A 
COLON 
DEFINITION 
AS IT IS NOT A COMPILER DIRECTIVE. 
FOR SUCH 
APPLICATIONS THE WORD REMEMBER SHOULD BE USED. 
LOADS THE DISC FORMATTING WORDS, 
WHICH ARE 
SELF 
EXPLANATORY. 
SEE UTIL. 
0-39 

FORTH 
FPREAD 
FRAT f\J 
FREE 
FRESTORE 
FSAVE 
FSQRT 
FW 
FWSP 
D-40 
FORTH GLOSSARY 
!"#$f.' ()*+,-.10123456789: ;<">?@AZ[\l"'_ 
( P ) 
THE NAME OF THE PRIMAPY VOCABULARY. EXECUTION OF THE WORD FORTH 
CAUSES 
FORTH 
TO 
BECOME 
THE CONTEXT VOCA8ULARY. 
SINCE FORTH 
CANNOT 8E CHAINED TO ANY OTHER VOCABULARY, 
IT BECOMES THE ONLY 
VOCABULARY THAT WILL BE SEARCHED FOR DICTIONARY ENTRIES. UNLESS 
ADDITIONAL USER 
VOCABULARIES 
ARE 
DEFINED, 
NEW 
USER 
WORDS 
NORMALLY BECOME PART OF THE FORTH VOCABULARY. 
FPREAD 
<VALUE> 
READ 
THE 
FRONT 
PANEL SWITCH SETTING ON THE CPU AND LEAVE THE 
RESULTING 16-BIT VALUE ON THE STACK. 
<FP-VALUE1> 
<FP-VALUE2> 
FRATN 
<FP-RESULT> 
COMPUTE 
THE 
ARCTANGENT 
(IN 
REVOLUTIONS) 
OF 
<FP-VALUE1> 
1 
<FP-VALUE2>, 
LEAVING THE RESULT ON THE STACK. 
NOTE THAT THIS 
WORD 
DOES 
NOT 
COMPUTE 
THE 
ARCTANGENT 
IN 
RADIANS 
BUT 
IN 
REVOLUTIONS. 
SETS 
THE 
VARIABLE 
FLD 
TO 0 AND THE VARIABLE DPL TO -1 WHICH 
SPECIFY THAT NUMBRIC OUTPUT IS TO 
BE 
FREE 
FORMAT, 
THAT 
IS 
MINIMUM FIELD WIDTH AND NO RADIX POINT. 
THIS 
WORD 
MUST 
BE 
EXECUTED 
BY AN 
INTER~UPT PROCESSING WORD 
WHICH HAS PREVIOUSLY EXECUTED FSAVE. 
FRESTORE WILL RESTORE ALL 
THE VARIABLES SAVED BY FSAVE. 
THIS WORD MUST BE EXECUTED 
BY 
AN 
INTERRUPT 
PROCESSING 
WORD 
PRIOR 
TO 
THE USE OF ANY FLOATING-POINT OPERATIONS. 
THIS WORD 
WILL SAVE ALL 
OF 
THE 
NON-REENTRANT 
VARIABLES 
USED 
BY 
THE 
FLOATING POINT wORDS. SEE FRESTORE. 
<FP-VALUE> 
FSORT 
<FP-RESULT> 
COMPUTE 
THE 
SQUARE ROOT OF <FP-VALUE> AND LEAVE THE RESULT ON 
THE STACK. 
INITIATE THE FORWARD SPACING OF A SINGLE MAG 
TAPE 
RECORD 
AND 
RETURN IMMEDIATELY. SEE FWSP. 
INITIATE 
THE 
FORWARD 
SPACING OF A SINGLE MAG TAPE RECORD AND 
WAIT FOR THE OPERATION TO COMPLETE. SEE FW. 
Feb. 1979 

FORTH GLOSSARY 
G. 
G? 
GCH 
GO 
GO-TO 
GOOD 
GS 
Feb. 1979 
<FP-VALUE> 
G. 
GENERALIZED FLOATING-POINT OUTPUT. OUTPUT THE <FP-VALUE> 
TO THE 
CURRENT OUTPUT DEVICE (USUALLY THE OPERATOR'S TERMINAL). 
IF THE 
VALUE IS EITHER TOO LARGE OR TOO SMALL TO BE OUTPUT BY F. 
THEN 
E. WILL 
BE USED. 
<ADDRESS> 
G? 
EQUIVALENT TO THE SEQUENCE "F@ G.". 
GCH 
<CHAR-CODE> 
WAIT FOR A CHARACTER TO BE ENTERED ON THE TERMINAL AND PUSH ITS 
7-BIT ASCII CODE ONTO THE STACK. 
SEE WCH. SEE APPENDIX 
A FOR A 
LISTING OF THE ASCII CODES. 
(OLD) 
LOAD BASIC FORTH (BLOCK 8) INTO THE DICTIONARY. 
<LINE#> 
GO-TO 
INTERRUPT 
INTERPRETATION 
OF 
THE 
CURRENT 
BLOCK 
AND 
RESUME 
INTERPRETATION 
STARTING 
WITH 
THE 
FIRST 
CHARACTER 
OF 
THE 
SPECIFIED LINE IN THE CURRENT BLOCK. THIS WORD MAY ONLY Bt USED 
DURING THE LOADING OF A BLOCK. SEE IN. 
(C) 
GOOD 
woRDO WORD1 
••• 
WORDN 
THEN 
COMPUTED GO TO. WHEN THE WORD GOOD IS EXECUTeD THE VALUE 
ON TOP 
OF THE STACK SPECIFIES WHICH WORD IN 
THE 
SEQUENCE 
IS 
TO 
BE 
EXECUTED. 
IF THE VALUE <& 0 THEN WORDO IS EXECUTED; IF VALUE 
z 
1 
THEN WORD1 IS EXECUTED; IF VALUE • 2 THEN·WORD2 IS EXECUTED; 
••• IF VALUE >. N THEN WORDN IS EXECUTED. 
PUTS THE 4010 IN GRAPHICS MODE AND PRODUCES A 
DARK 
VECTeR 
ON 
THE NEXT COMMAND. SEE US. 
D-41 

H. 
HBLOCK 
HEAD 
HERE 
HEX 
D-42 
FORTH GLOSSARY 
<VALUE> 
H. 
HEXADECIMAL 
OUTPUT. 
OUTPUT 
<VALUE> AS A HEXADECIMAL NUMBER, 
UNSIGNED AND PRECEDED BY A BLANK ON THE 
CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S TERMINAL). 
THE FORMAT SPECIFICATIONS 
GIVEN BY THE VARIABLES FLO AND OPL ARE OBSERVED. 
BASE 
IS 
NOT 
CHANGED. 
<BLOCK#> 
HBLOCK 
READ A FORTH BLOCK FROM DISC. THIS WORD SHOULD BE USED IN PLACE 
OF THE WORD BLOCK IF THERE ARE HARDWARE ERRORS ON THE DISC. THE 
BLOCK IS READ BY SECTORS (TWO SECTORS COMPRISE EACH BLOCK) WITH 
UP TO FIVE RETRIES PER SECTOR, IN AN ATTEMPT TO RECOVER AS MUCH 
OF 
THE 
BLOCK 
AS POSSIBLE. 
THE DISC STATUS WORD IS OUTPUT IF 
ERRORS ARE ENCOUNTERED. NOTE THAT UNLIKE THE WORD BLOCK, HBLOCK 
DOES NOT RETURN AN ADDRESS ON THE STACK. INSTEAD, THE WORD PREV 
MAY BE USED TO OBTAIN THE MEMORY ADDRESS OF THE BLOCK. 
HEAD 
<ADDRESS> 
RETURNS A POINTER TO 
THE 
FIRST 
LOCATION 
OF 
THE 
LAST 
WORD 
DEFINED 
IN 
THE CURRENT VOCABULARY. 
HEAD IS EQUIVALENT TO THE 
SEQUENCE "CURRENT a". 
HERE 
<ADDRESS> 
PUSH 
ONTO 
THE 
STACK 
THE 
ADDRESS 
OF 
THE 
DICTIONARY 
LOCATION. 
SINCE 
THE DICTIONARY 
INTERNAL REGISTER RATHER THAN A VARIABLE, 
IT 
ACCESSED THROUGH THE WORDS HERE AND DP+!. 
NEXT 
AVAILABLE 
POINTER MAY BE 
AN 
SHOULD 
ONLY 
BE 
SET 
THE NUMERIC CONVERSION BASE TO HEXADECIMAL, 
THAT IS, 
SET 
THE VARIABLE BASE TO 16. SEE DECIMAL AND eCTAL. 
Feb. 1979 

FORTH GLOSSARY 
I 
(C) 
I 
<VALUE> 
PUSHES 
a~TO THE STACK THE CURRENT VALUE OF THE 
LOOP 
INDEX 
OF 
THE 
INNERMOST DO-LOOP CURRENTLY BEING EXECUTED. 
I MAY ONLY BE 
EXECUTED WITHIN THE WORD WHICH ACTUALLY 
EXECUTED 
THE 
DO-LOOP 
AND 
NOT 
FROM 
WITHIN 
SOME 
OTHER 
WORD WHICH HAS ITSELF BEEN 
EXECUTED FROM WITHIN THE DO-LOOP. SEE 1', THE FOLLOWING :XAMPLE 
WILL NOT WORK CORRECTLY: 
: A 
• • • 
I 
••• 
: B 
••• 
DC) 
••• 
A 
••• 
LOOP 
••• 
THIS WORD MAY ALSO BE USED TO PUSH ONTO THE STACK A VALUE WHICH 
wAS PUSHED ONTO THE RETURN STACK USING >R. SEE >R 
AND R>. 
I' 
(C) 
l' 
<VALUE> 
PUSHES ONTO THE STACK THE CURRENT VALUE OF THE 
LOOP 
INDEX 
OF 
THE 
IN~ERMOST DO-lOOP 
CURRENTLY 
BEING 
EXECUTED IN THE WORD 
WHICH HAS CALLED THE WORn IN WHICH I' RESIDES. SINCE THE WORD I 
MAY NOT BE 
EX~CUTED AT ANY LEVEL OTHER 
THAN 
WITHIN 
THE 
WORD 
WHICH 
EXECUTES 
THE 
DO-LOOP, 
I' GIVES ONE ACCESS TO THE lOOP 
PARAMETER AT ONE ADDITIONAL lEVEL. 
THE 
FOLLO~ING 
EXAMPLE 
IS 
VALID: 
A 
• • • 
: B 
• • • 
I ) 
( A) 
I ' 
00 
• • • 
••• . , 
A 
• •• 
LOOP 
; 
SETS THE VARIABLE MODE TO 7, SPECIFYING INDIRECT ADDRESSING FOR 
THE 
NEXT 
MEMORY 
REFERENCE 
INSTRUCTION. 
NOTE THAT THIS WORD 
DESIGNATES THE 
INSTRUCTION 
AS 
INDIRECT 
WHILE 
THE 
WORD 
0) 
DESIGNATES AN ADDRESS AS INDIRECT. 
I. 
<VALUE> 
<FIELD-WIDTH> 
I. 
SINGLE-WORD 
INTEGER 
OUTPUT. 
CONVERT <VALUE> ACCORDING TO THE 
CURRE~T NUMBER BASE AND OUTPUT IT TO THE CURRENT OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAL) 
USING THE SPECIfIED FIELD 
WIDTH. NO RADIX POINT IS PRINTED. 
110 
(A) 
<VALUE> 
110 
<NAME> 
DEFINE <NAME> AS A SINGLE-WORD MACHINE INSTRUCTION WHOSE 
BASIC 
MACHINE CODE REPRESENTATION IS <VALUE>. WHEN <NAME> IS EXECUTED 
THE TOP NUMBER ON THE STACK (USUALLY A DEVICE CODE, SHIFT COUNT 
OR 
REGISTER 
SPECIFICATION) 
IS INCLUSIVELY OR-ED WITH <VALUE> 
AND THE RESULT IS 
STORED 
IN 
THE 
NEXT 
AVAILABLE 
DICTIONARY 
LOCATION. SEE CPU, DL AND M/CPU. 
Feb. 1979 
D-43 

IAR, 
IBR, 
IC 
FORTH GLOSSARY 
!"#$&' ()*+,-.10123456789: ;<:>?OlAz(\ 1"'_ 
( A ) 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
IAR 
INSTRUCTION 
(INCREMENT THE A REGISTER). 
( A) 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
IBR 
INSTRUCTION 
( INC REM E N T THE B REGISTER). 
THE INTERPRETER INSTRUCTION COUNTER. 
A VARIABLE CONTAINING THE 
ADDRESS OF THE NEXT WORD TO EXECUTE. 
10. 
<ADDRESS> 
10. 
PRINT 
THE 
3-CHARACTER/LENGTH 
IDENTIFIER 
OF 
THE 
WORD WHOSE 
DICTION~RY ENTRY STARTS AT THE SPECIFIED 
ADDRESS. 
USEFUL 
IN 
ANALYZING DUMPS. 
IF 
(C2+,P) 
<LOGICAL-VALUE> 
IF 
(TRUE-PART) 
ELSE 
(FALSE-PART) 
THEN 
<LOGICAL-VALUE> 
IF 
(TRUE-PART) 
THEN 
IF 
IS 
THE 
FIRST 
WORD 
OF 
A CONDITIONAL 
BRANCH. 
IF 
THE 
<LOGICAL-VALUE> 
IS 
TRUE 
(NON-ZERO) 
THE 
TRUE-PART 
WILL 
BE 
EXECUTED. 
IF 
THE 
<LOGICAL-VALUE> 
IS 
FALSE 
(ZERO) 
THE 
FALSE-PART, 
IF 
PRESENT, 
WILL 
BE 
EXECUTED. 
IF 
THE 
<LOGICAL-VALUE> 
IS 
FALSE AND THERE IS NO FALSE-PART SPECIFIED 
THE ENTIRE IF-THEN IS SKIPPED OVER AND EXECUTION 
RESUMES 
WITH 
THE WORDS FOLLOWING THE THEN. 
IF-ELSE-THEN CONDITIONALS MAY BE 
NESTED. 
IF, 
(A) 
<JUMP-CONDITION> IF, 
(TRUE-PART) 
ELSE, 
(FALSE-PART) 
THEN, 
<JUMP-CONDITION> IF, 
(TRUE-PART) 
THEN, 
IF, 
IS 
THE 
FIRST 
WORD 
OF 
A CONDITIONAL 
BRANCH. 
IF THE 
<JUMP-CONDITION> 
IS 
TRUE 
THEN 
THE 
SEQUENCE 
OF 
MACHINE 
INSTRUCTIONS COMPRISING THE TRUE-PART WILL BE EXECUTED. 
IF THE 
<JUMP-CONDITION> 
IS FALSE THE SEQUENCE OF MACHINE INSTRUCTIONS 
COMPRISING 
THE 
FALSE-PART 
WILL 
BE 
EXECUTED. 
IF 
THE 
<JUMP-CONDITION> IS FALSE AND THERE IS NO FALSE-PART SPECIFIED, 
THE ENTIRE IF,-THEN, IS SKIPPED OVER AND EXECUTION RESUMES WITH 
THE FIRST INSTRUCTION FOLLOWING THE THEN,. THE <JUMP-CONDITION> 
IS USUALLY SPECIFIED BY ONE OF THE WORDS A+, 
A-, AO, BO OR av. 
IF,-ELSE,-THEN, CONDITIONALS MAY BE NESTED. 
0-44 
Feb. 1979 

FORTH GLOSSARY 
! "1/ $ & ' ( ) *+, -. 10123456789: ; <= > ? @A Z ( \ ] A_ 
!FEND 
IF TR UE 
IJMP, 
IME, 
(E) 
TERMINATE 
A CONDITIONAL 
INTERPRETATION 
SEQUENCE BEGUN BY AN 
IFTRUE. 
(E ) 
<LOGICAL-VALUE> 
IFTRUE 
••• 
OTHERWISE 
••• 
IFEND 
< l OG I C A L- V A L U E > 
1FT RUE 
• • • 
I FEN D 
THESE 
WORDS 
ARE 
SIMILAR 
TO 
THE 
IF-ELSE-THEN 
CONDITIONAL, 
HOWEVER 
THE IFTRUE-OTHERWISE-IFEND CONDITIONALS ARE TO BE USED 
DURING COMPILATION. 
ADDITIONALLY, 
UNLIKE 
THE 
IF-ELSE-THEN 
CONDITIONAL, THE IFTRUE-OTHERWISE-IFEND CONDITIONALS MAY NOT BE 
NESTED. 
(A) 
<ADDRESS> 
<VALUE> 
IJMP, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN IJMP INSTRUCTION (INDEXED 
JUMP). 
(A) 
<ADDRESS> 
<DEVICE-CODE> 
IME, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN IME INSTRUCTION (INPUT TO 
ME MO RY) • 
IMMEDIATE (OLD) 
IMOVE 
IMP 
IMP 
IN 
Feb. 1979 
MARK 
THE MOST RECENTLY CREATED DICTIONARY ENTRY SUCH THAT WHEN 
IT IS ENCOUNTERED AT COMPILE TIME IT WILL 
BE 
EXECUTED 
RATHER 
THAN COMPILED. 
<SOURCE-ADDR> 
<DESTINATIoN-ADDR> 
IMOVE 
MOVE A GROUP OF SEQUENTIAL MEMORY CELLS, IN 
INVE~SE ORDER, FROM 
THE 
<SOURCE-ADDR> 
TO 
THE 
<DESTINATION-ADDR>. 
THE LENGTH IS 
SPECIFIED BY <#CELLS>. 
INVERSE ORDER MEANS THAT THE LAST 
CELL 
IN 
THE 
SOURCE 
FIELD 
IS 
MOVED 
TO 
THE 
FIRST 
CELL 
OF THE 
DESTINATION FIELD, THE NEXT TO LAST CELL IN THE SOURCE FIELD IS 
MOVED TO THE SECOND CELL OF THE DESTINATION FIELD, 
ETC. 
SEE 
MOVE. 
IMP 
<NAME> 
IF 
<NAME> 
IS THE NAME OF AN OVERLAY WHICH HAS PREVIOUSLY BEEN 
DEFINED AND SAVED THEN THIS WILL SET THE PRECEDENCE BIT OF 
THE 
OVERLAY, IDENTIFYING IT AS A VARIABLE OVERLAY. 
WHEN A VARIABLE 
OVERLAY 
IS IN THE MEMORY OVERLAY REGION AND ANOTHER 
OVE~LAY IS 
TO BE READ IN, 
THE VARIABLE OVERLAY 
IS 
FIRST 
RE-WRITTEN 
TO 
DISC. 
(OLD) 
IMP 
<NAME> 
TOGGLES THE PRECEDENT BIT OF THE SPECIFIED DICTIONARY ENTRY. 
A 
VARIABLE 
CONTAINING 
THE 
INDEX 
OF 
THE 
CHARACTER 
BEING 
INTERPRETED. ALTHOUGH THIS INDEX IS INITIALIZED 
A~D INCREMENTED 
AUTOMATICALLY DURING INTERPRETATION, 
IT 
MAY 
BE 
MODI~IED 
TO 
AFFECT THE SEQUENCE OF INTERPRETATION. SEE GO-TO. 
D-45 

FORTH GLOSSARY 
!"#$f: 1 ()*+,-./0123456789: j<s>?@Al[\]"_ 
INCLUDES 
<NAMEl> 
INCLUDES 
<NAME2> 
INCR, 
INR, 
<NAMEl> 
MUST 
BE 
THE 
NAME OF AN OVERLAY WHICH HAS PREVIOUSLY 
BEEN DEFINED AND SAVED; <NAME2> MUST BE 
THE 
NAME 
OF 
A 
WORD 
WHICH 
WAS 
DEFINED 
IN 
THAT 
OVERLAY. 
<NAME2> THEN BECOMES A 
DICTIONARY ENTRY IN MEMORY SO THAT EXECUTION 
OF 
<NAME2> 
WILL 
FIRST 
READ THE NEEDED OVERLAY INTO MEMORY AND THEN 
EXECUT~ THE 
COpy OF <NAME2> IN THAT OVERLAY. REFERENCES MAY THEN BE MADE TO 
<NAME2> AS IF IT WERE PART OF THE DICTIONARY IN MEMORY. COMPARE 
THIS IMPLICIT LOADING OF AN OVERLAY WITH THE 
EXPLICIT 
LOADING 
PROVIDED 
BY O-LOAD. 
IF ANOTHER OVERLAY IS PRESENTLY IN 
ME~ORY 
AND IF ITS PRECEOENCE BIT IS SET (SEE 
IMP) 
THEN 
IT 
WILL 
BE 
WRITTEN TO DISC BEFORE <NAME1> IS READ INTO MEMORY. 
(A) 
<VALUE> 
INCR, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
INCR 
INSTRUCTION 
(INCREMENT AND COMBINE REGISTERS). 
(A) 
<ADDRESS> 
INR, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
(INCREMENT A WORD OF MEMORY). 
VARIAN 
I NR 
INSTRUCTION 
INTEGER 
(OLD) 
RENAMED VARIABLE. 
INTX 
<VALUE> 
INTX 
DEFINE 
A 
PSEUDO-VECTOR 
INTEGER 
VARIABLE, 
INITIALIZED 
TO 
<VALUE>. 
THE VALUE OF THIS VARIABLE MAY BE ACCESSED BY RCLX OR 
STORED 
BY 
STRX, 
AND 
IS 
ACCESSIBLE 
ONLY 
wITHIN 
A 
COLON 
DEFINITION. 
THESE 
WORDS 
ARE 
DESIGNED 
FOR 
CORE 
AND SPEED 
EFFICIENCY AND EACH 
INTX 
DECLARATION 
REQUIRES 
3 
DICTIONARY 
CEllS. SEE P-VX. 
I P 
( C ) 
ISR2 
D-46 
A VARIABLE CONTAINING THE BYTE ADDRESS OF THE NEXT CHARACTER TO 
BE RETURNED BY CHFETCH. SEE COUNT, TYPE AND WRITE. 
A 2CONSTANT WHOSE VALUE IS THE DOUBLE-WORD FRACTION 2 ** -0.5. 
( A ) 
THE 
ASSEMBLER 
MNEMONIC 
(INCREMENT THE X REGISTER). 
STACK 
POINTER 
IN 
VARIAN 
DEALLOCATES ONE WORD OF THE 
FOR 
THE 
VARIAN 
IXR 
INSTRUCTION 
NOTE THAT THE X REGISTER 
IS 
THE 
FORTH, 
THEREFORE THIS INSTRUCTION 
STACK. 
Feb. 1979 

FORTH GLOSSARY 
! II # $ f, • ( ) *+ , -. /0123456789: ; <. > 1@A Z ( \ ] A _ 
J 
(C) 
J 
<VALUE> 
WITHIN A NESTED DO-LOOP, 
THIS WORD PUSHES ONTO THE 
STACK 
THE 
CURRENT 
VALUE OF THE LOOP INDEX OF THE NEXT OUTER LOOP. 
J MAY 
ONLY BE EXECUTED WITHIN THE WORD WHICH 
ACTUALLY 
EXECUTED 
THE 
DO-LOOP 
AND 
NOT 
FROM WITHIN SOME OTHER WORD WHICH HAS ITSELF 
BEEN EXECUTEO FROM WITHIN THE DO-LOOP. SEE I. 
JIF, 
(A) 
<ADDRESS> 
<JUMP-CONDITION> 
JIF, 
JIFM, 
JMP, 
JMPM, 
THE 
ASSEMBLER 
MNEMONIC 
FO~ 
THE 
VARIAN 
JIF 
INSTRUCTION 
(CONDITIONAL 
JUMP). 
THE <JUMP-CONDITION> IS USUAllY SPECIFIED 
BY ONE OF THE WORDS A+, A-, AO, BO OR OV. 
(A) 
<A~DRESS> 
<JUMP-CONDITION> 
JIFM, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
JIFM 
INSTRUCTION 
(CONDITIONAL 
JUMP 
AND MARK). 
THE <JUMP-CONDITION> IS USUALLY 
SPECIFIFED BY ONE OF THE WORDS A+, A-, AO, 
SO OR OV. 
(A) 
<ADDRESS> 
JMP, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
(UNCONDITIONAL JUMP). 
(A) 
<ADDRESS> 
JMPM, 
VARIAN 
JMP 
INSTRUCTION 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
JMPM 
INSTRUCTION 
(UNCONDITIONAL JUMP AND MARK). 
JSR, 
(A) 
<AD9RESS> 
<VALUE> 
JSR, 
K 
THE ASSEMBLER MNEMONIC FOR THE VARIAN JSR INSTRUCTION (JUMP AND 
SET THE RETURN ADDRESS IN ONE OF THE REGISTERS). 
(e) 
K 
<VALUE> 
WITHIN A NESTED DO-LOOP, 
THIS WORD PUSHES ONTO THE 
CURRENT VALUE OF THE LOOP INDEX OF THE SECOND OUTER 
ONLY 
BE 
EXECUTED 
WITHIN THE WORD WHICH ACTUALLY 
DO-lOOP AND NOT FROM wITHIN SOME OTHER WORD 
WHICH 
BEEN EXECUTED FROM WITHIN THE DO-lOOP. SEE I. 
STACK 
THE 
LOOP. 
K MAY 
EXECUTED THE 
HAS 
ITSELF 
KCURSOR 
KCURSOR 
<Y-POSN> 
<X-POSN> 
TURNS ON THE 4010 CROSS HAIR CURSORS AND WAITS FOR THE OPERATOR 
TO 
ENTER 
ANY 
CHARACTER. 
THREE 
SINGLE-WORD 
INTEGEPS 
ARE 
RETURNED, 
THE X AND Y POSITIONS OF THE CURSORS 
A~D 
THE 
ASCII 
CHARACTER CODE FOR THE CHARACTER THAT THE OPERATOR ENTERED. 
Feb. 1979 
D-47 

L2B 1 0 
FORTH GLOSSARY 
AN 
FCQNSTA~T WHOSE VALUE IS THE FLOATING-PCINT LOGARITHM, 
BASE 
10 OF 2.0, THAT IS, 0.301029996. 
LAL, 
(A) 
<SHIFT-COUNT> 
LAl, 
THE 
ASSEMBLER 
MNEMONIC 
FOR THE VARIAN LASL INSTRUCTION (LONG 
AQ.ITHMETIC SHIFT LEFT). 
LA R , 
( A ) 
< S HI F T -C 0 UN T > 
LA R , 
LAST 
THE ASSEMBLER MNEMONIC FOR THE VARIAN 
LASR 
INSTRUCTION 
(LONG 
ARITHMETIC SHIFT RIGHT). 
A VARIABLE 
CONTAINING 
THE 
COMPILATION 
ADDRESS 
OF THE MOST 
RECENTLY MADE DICTIONARY ENTRY, WHICH MAY NOT YET BE A COMPLETE 
OR VALID ENTRY. 
IN ORDER TO EXECUTE A WORD 
RECURSIVELY, 
THE 
SEQUENCE 
n[p] 
MYSELF 
LAST @, 
;11 DEFI'lES THE WORD MYSELF 
WHICH MAY THEN BE USED WITHIN A COLON DEFINITION TO RECURSIVELY 
EXECUTE THE WORD BEING DEFINED. 
LOA, 
(A) 
<ADDRESS> 
LOA, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN LOA INSTRUCTION (LOAD THE 
A REGISTER FROM MEMORY'. 
LOB, 
(A) 
<ADDRESS> 
LOB, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN LOB INSTRUCTION (LOAD THE 
B REGISTER FqOM MEMORY'. 
LOX, 
(A) 
<ADDRESS> 
LOX, 
LEAVE 
LENGTH 
D-48 
THE ASSEMBLER MNEMONIC FOR THE VARIAN LOX INSTRUCTION (LOAD THE 
X REGISTER FROM MEMORY). 
NOTE THAT THE X REGISTER IS THE STACK 
POINTER IN VARIAN FORTH. 
(C ) 
FORCE TERMINATION OF A DO-LOOP 
AT 
THE 
NEXT 
OPPORTUNITY 
BY 
SETTING 
THE 
LOOP LIMIT EQUAL TO THE CURRENT VALUE OF THE LOOP 
INDEX. 
THE VALUE OF THE INDEX REMAINS UNCHANGED AND 
EXECUTIQN 
CONTINUES THROUGH THE LOOP WITH THE TERMINATION OCCURING AT THE 
NEXT 
EX~CUTION OF EITHER lOOP OR +LOOP. 
<#POINTS> 
LENGTH 
SPECIFY 
THE 
NUMBER 
OF 
POINTS 
FOR AN FFT. 
<#POINTS> IS THE 
NUMBER OF REAL, 
DOUBLE-WORD INTEGER DATA POINTS FOR 
DFOURTRAN 
AND 
MUST 
BE A POWER OF 2. 
FOR DINVTRAN, 
«npOINTS> I 2) + 1 
COMPLEX, 
DOUBLE-WORD INTEGER DATA POINTS WILL YIELD 
<#POINTS> 
REAL, DOUBLE-WORD INTEGER POINTS. 
Feb. 1979 

FORTH GLOSSARY 
! II # $ (. I ( ) *+, -. 10123456789: ; <: >?@ A Z( \ ] '" _ 
LINE 
LINEIN 
<LINE#> 
LINE 
<ADDRESS> 
PUSHES 
ONTO 
THE 
STACK 
THE 
ADDRESS 
IN 
MEMORY OF THE FIRST 
CHARACTER OF THE SPECIFIED LINE IN THE BLOCK WHOSE BLOCK 
NUMBER 
IS CONTAINED IN THE VARIABLE BLK. 
LINEIN 
<ADDRESS> 
PEQUEST A LINE 
OF 
INPUT 
FROM 
THE 
TERMINAL. 
THE 
LINE 
IS 
TERMINATED 
BY 
A CARRIAGE RETURN AND THE MEMORY ADDRESS 
OF THE 
CHARACTER STRING (WHICH IS STORED IN THE 
AVAILABLE 
DICTIO~ARY 
SPACE) IS 
R~TURNED ON THE STACK. 
LINELOAD 
<LINE#> 
<BLOCK#> 
LINELOAD 
BEGIN 
INTERPRETING 
AT 
THE 
SPECIFIED 
LINE 
OF THE SPECIFIED 
BLOCK. 
THE SEQUENCE 
II<BLOCK#> 
LOAD" 
IS 
EQUIVALENT 
TO 
THE 
SEQUENCE "1 <BLOCK#> LINELOAD". 
LINEWRITE 
<LINE#> 
LINEWRITE 
OUTPUT 
TO 
THE 
CURRENT 
OUTPUT DEVICE (USUALLY THE OPERATOR'S 
T E R MIN AUT HE S PEe I FIE D LIN E ( 64 C H A R AC T E R S) 0 F THE B L 0 C KWH 0 S E 
BLOCK NUMBER IS CONTAINED IN THE VARIABLE BLK. 
LIST 
<BLOCK#> 
LIST 
LIST THE ASCII SYMBOLLIC CONTENTS OF THE SPECIFIED BLOCK 
ON THE 
CURRENT OUTPUT DEVICE (USUALLY THE OPERATCR'S TERMINAL). 
LIT 
(OLD,e) 
RENAMED ILIT/. 
LIT, 
(OLD) 
LITERAL 
LLRL, 
llSR, 
Feb. 1979 
RENAMED ILIT/. 
THE WORD IN BASIC FORTH WHICH EITHER PUSHES A NUMBER 
ONTO 
THE 
STACK 
OR 
COMPILES 
IT 
INTO THE DICTIONARY, 
DEPENDING ON THE 
CURRE~T STATE (COMPILING OR EXECUTING). 
(A) 
<SHIFT-COUNT> 
LLRL, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN 
LLRL 
INSTRUCTION 
(LONG 
LOGICAL ROTATE LEFT). 
(A) 
<SHIFT-COUNT> 
LLSR, 
THE 
ASSEMBLER 
MNEMONIC 
FOR THE VARIAN lLSR INSTRUCTION 
(LONG 
LOGICAL SHIFT RIGHT). 
D-49 

LUAD 
LeADER 
LOG2(10) 
LOOP 
LPLOT 
LRL, 
LRLB, 
LS 
LSR, 
LSRB, 
FORTH GLOSSARY 
!"#$&' (,*+,-./0123456789: ;<z>?QJAZ[\]"'_ 
<BLOCK#> 
LOAD 
P.EGIN INTERPRETATION OF THE SPECIFIED 
FIRST LINE IN THE BLOCK. 
THE 
BLOCK 
INTERPRETATION WITH EITHER is, --> OR 
<BLOCK#> 
LOADER 
<NAME> 
BLOCK, 
STARTING WITH THE 
MUST 
TERMINATE 
ITS 
OWN 
CONTINUED. 
DEFINE 
THE 
WORD <NAME> WHICH, 
WHEN EXECUTED, 
WILL CAUSE THE 
SPECIFIED BLOCK TO BE LOADED. 
AN FCONSTANT WHOSE VALUE IS THE FLOATING-POINT LOGARITHM, 
BASE 
2 OF 10.0, THAT IS, 3.32192809. 
( C ) 
INCREMENT THE DO-LOOP INDEX BY +1, 
TERMINATING THE LOOP IF THE 
NEW VALUE OF THE INDEX IS EQUAL TO OR GREATER THAN THE LIMIT. 
<X-POSN> 
<Y-POSN> 
LPLOT 
DRAWS A VECTOR ON THE 4010 TO THE LOGICAL POSITION SPECIFIED BY 
<X-POSN> AND <Y-POSN>. 
THIS NEW 
POSITION 
IS 
THEN 
SAVED 
IN 
14010. 
<X-POSN> AND <Y-POSN> ARE FLOATING-POINT NUMBERS IN THE 
RANGE 0.0 -
1023.3 AND 0.0 - 780.0. 
(A) 
<SHIFT-COUNT> 
LRL, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN LRLA INSTRUCTION (LOGICAL 
ROTATE LEFT THE A REGISTER). 
(A) 
<SHIFT-COUNT> 
LRLB, 
THE ASSEMBLER MNEMONIC fOR THE VARIAN LRLB INSTRUCTION (LOGICAL 
ROTATE LEFT THE B REGISTER). 
<VALUE> 
<SHIFT-COUNT> 
LS 
<RESULT> 
ROTATE <VALUE> LOGICALLY LEFT OR RIGHT. IF THE <SHIFT-COUNT> IS 
POSITIVE 
THE 
SHIFT 
IS 
A LOGICAL 
ROTATE 
LEFT 
WHILE 
IF 
<SHIFT-COUNT> IS NEGATIVE THE SHIFT IS A LOGICAL ROTATE 
RIGHT. 
SEE 2L S • 
(A) 
<SHIFT-COUNT> 
LSR, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN LSRA INSTRUCTION (LOGICAL 
SHIFT RIGHT THE A REGISTER). 
(A) 
<SHIFT-COUNT> 
LSRB, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN LSRB INSTRUCTION (LOGICAL 
SHIFT RIGHT THE B REGISTER). 
LWA? 
LWA? 
<ADDRESS> 
READ 
IN 
THE 
LAST-WORD-ADDRESS 
COUNTER 
OF 
THE 
MAG 
TAPE 
CONTROLLER AND PUSH THIS ADDRESS ONTO THE STACK. 
D-50 
Feb. 1979 

FORTH GLOSSARY 
!"#$£'()*+,-./0123456789:;<:>?@AZ[\]"_ 
M* 
<VALUEl' 
<VALUE2> 
M* 
<DW-RESULT> 
M+ 
MI 
M/CPU 
MIMOD 
MIXED PRECISION MULTIPLY, 
FORMING A DOURLE-WORD 
PRODUCT 
FROM 
TWU SINGLE-WaRD MULTIPLICANDS. SEE 2M*. 
<OW-VALUE> 
<VALUE> 
M+ 
<Ow-RESULT> 
MIXED 
PRECISION 
ADDITION, 
ADDING THE SINGLE-WORD 
<VA~UE> TO 
<OW-VALUE> FORMING A DOUBLE-WORD RESULT. 
<OW-VALUE' 
<VALUE> 
MI 
<QUOTIENT' 
MIXED 
PRECISION 
DIVIDE, 
DIVIDING 
THE 
<OW-VALUE> 
BY 
THE 
SINGLE-WORD 
<VALUE' FORMING A SINGLE-WORD <RESULT>. 
NOTE THAT 
THE QUOTIENT IS TRUNCATED AND ANY REMAINDER IS lOST. SEE M/MOD. 
(A) 
<VALUE> 
M/CPU 
<NAME> 
DEFINE <NAME> AS A MEMORY 
REFERENCE 
INSTRUCTION 
WHOSE 
BASIC 
MACHINE CODE REPRESENTATION IS <VALUE>. WHEN <NAME> IS EXECUTED 
THE 
TOP 
NUMBER 
ON THE STACK IS EITHER A MEMORY ADDRESS OR AN 
IMMEDIATE OPERAND AND THE CURRENT VALUE OF MODE 
D~TERMINES 
THE 
ADDRESSING 
MODE OF THE INSTRUCTION. 
THE VALUE OF <MODE>, 
THE 
TOP NUMBER ON THE STACK 
AND 
THE 
LIMITATIONS 
OF 
THE 
VARIAN 
HARDWARE 
WIll DETERMINE WHETHER THF. SINGLE-WORD OR DOUBLE-WORD 
VERSION OF THE INSTRUCTION IS GENERATED. 
THE INSTRUCTION 
WILL 
BE STORED IN THE NEXT AVAILABLE WOROCS) 
OF THE DICTIONARY. 
SEE 
CPU, Dl AND !lO. 
<OW-VALUE> 
<VALUE> 
MIMOD 
<REMAINDER> 
<QUOTIENT> 
MIXED 
PRECISION 
DIVIDE, 
DIVIDING 
THE 
<OW-VALUE> 
BY 
THE 
SINGLE-WO~D <VALUE> YIELDING A SINGLE-WORD <QUOTIENT> ON 
TOP OF 
THE STACK AND A SINGLE-WORD <REMAINDER> BELOW. 
THE 
REMAINDER 
WILL HAVE THE SIGN OF THE DIVIDEND. 
MAPa 
(T) 
MAPO 
<ADDRESS> 
THIS 
WORD 
PUSHES 
ONTO 
THE 
STACK 
THE 
ADDRESS OF THE FIRST 
LOCATION IN THE TAPE MAP. 
MARK 
<SYMBOL> 
<SIZE> 
MARK 
DRAWS A SYMBOL 
ON THE 4010 AT THE CURRENT POSITION. <SYMOOl> IS 
A SINGLE-WORD INTEGER VALUE WHICH IS INTERPRETED AS FOLLOWS: 
1 
PLUS SIGN 
2 
CROSS 
3 
BOX 
4 
DIAMOND 
<SIZE> IS A SINGLE-WORD INTEGER THAT SPECIFIES THE SYMBOL 
SIZE 
IN POI NT S CAS TAN 0 A R 0 ALP HAC HA R A C TE R I S 14 POI NT S HI G H) • 
~AX 
<VALUE1> 
<VALUE2> 
MAX 
<RESULT> 
LEAVE THE GREATER OF <VALUEl> AND <VAlUE2> ON THE STACK. 
Feb. 1979 
0-51 

FORTH GLOSSARY 
!"#$€;.' ()*+,-.10123456189: ;<:>?@AZ[\]"_ 
MERG, 
(Al 
<VALUE> 
MERG, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN MERG INSTRUCTION (COMBINE 
REGISTERS). 
MFSSAGE 
<Ow-VALUE> 
MESSAGE 
A SINGLE 
LINE 
(64 
CHARACTERS) 
OF 
A BLOCK IS OUTPUT nJ THE 
CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAL). 
<OW-VALUE> 
SPECIFIES 
BOTH 
THE 
BLOCK# 
AND 
THE LINE#, 
WITH 
<OW-VALUE> = (BLOCK# * 100) + LINE#. 
IF <DW-VALUE> IS POSITIVE 
THEN A CARRIAGE RETURN WILL PRECEDE THE 
MESSAGE. 
A NEGATIVE 
<DW-VALUE> MAY BE USED TO SPECIFY NO CARRIAGE RETURN. 
MIN 
<VALUEl> 
<VALUE2> 
MIN 
<RESULT> 
LEAVE THE LESSER OF <VALUEl> AND <VALUE2> ON THE STACK. 
MINUS 
<VALUE> 
MINUS 
<RESULT> 
NEGATE <VALUE> BY TAKING ITS TWOS-COMPLEMENT. 
D-52 
Feb. 1979 

FORTH GLOSSARY 
!"#$f.f()*+,-./Ol23456789:;<=>,/@AZ[\]"'_ 
MOD 
<VALUEl> 
<VALUE2> 
MOD 
<REMAINDER> 
CALCULATE 
<VALUEl> 
/ <VALUE2> AND LEAVE ONLY THE REMAINDER ON 
THE STACK. THE REMAINDER WILL HAVE THE SIGN OF THE DIVIDEND. 
MODE 
(A) 
A VARIABLE WHICH SPECIFIES THE TYPE OF ADDRESSING 
TO 
B~ 
IJSED 
FOR 
THE NEXT MEMORY REFERENCE INSTRUCTION. 
THE VALUES 
OF MODE 
ARE: o 
DIRECT ADDRESSING (DEFAULT). 
1 
IMMEDIATE ADDRESSING. 
SEE #. 
4 
RELATIVE ADDRESSING (P REGISTER). 
SEE Pl. 
5 
INDEXING OFF THE X REGISTER. 
SEE X) AND S). 
6 
INDEXING OFF THE B REGISTER. 
SEE B) AND E). 
7 
INDIRECT ADDRESSING. 
SEE I). 
THE VALUE OF MODE IS RESET TO ZERO AFTER EVERY MEMORY REFERENCE 
INSTRUCTION IS COMPILED INTO THE DICTIONARY. 
MOVE 
<SOURCE-AQDR> 
<DESTINATION-ADDR> 
<#CELLS> 
MOVE 
MOVE 
A 
GROUP 
OF 
SEQUENTIAL 
MEMORY 
CELLS 
FROM 
THE 
<SOURCE-ADDRESS> 
TO 
THE <DESTINATION-AODRESS>. 
THE LENGTH IS 
SPECIFIED BY <#CELLS>. AN OVERLAPPING OF DATA CAN OCCUR AND THE 
MOVE IS PERFORMED BY MOVING THE 
CONTENTS 
OF 
<SOURCE-ADDRESS> 
FIRST (SIMILAR TO THE IBM MVC INSTRUCTION). 
THIS ALLOWS 
ONE TO 
ZERO 
AN 
ENTIRE REGION OF N CELLS BY SETTING THE FIRST CELL TO 
ZERO AND THEN MOVING N-l CELLS 
FROM 
THE 
FIRST 
CELL 
TO 
THE 
SECOND CELL. SEE IMOVE. 
MPY, 
(A) 
<ADDRESS> 
MPY, 
MS 
AN 
ASSEMBLER 
MACRO 
WHICH 
GENERATES 
A 
SEQUENCE 
OF 
MACHINE 
INSTRUCTIONS TO MULTIPLY THE CONTENTS OF THE 
B 
REGISTER 
wITH 
THE CONTENTS OF THE SPECIFIED MEMORY LOCATION. 
THE SEQUENCE OF 
INSTRUCTIONS GENERATED IS TZA AND MUL. 
DELAY 
WITHIN 
ON ANY 
OR DMA 
<VALUE> 
MS 
FOR 
APPROXIMATELY 
<VALUE> 
? PERCENT). 
THIS WAIT IS AN 
EXTERNAL CLOCK AND THEREFORE 
ARE OCCURING SIMULTANEOUSLY. 
MILLISECONDS 
(ACCURATE 
TO 
INSTRUCTION LOOP, 
NOT BASED 
ASSUMES THAT NO 
INTERRUPTS 
MSEC 
(OLD) 
RENAMED MS. 
MSGO 
(OLD) 
A VARIABLE CONTAINING THE BYTE-ADDRESS 
OF 
THE BEGINNING OF THE 
INPUT BUFFER. 
Feb. 1979 
D-53 

MTPERR 
MTR 
MTREAD 
MTREJ 
MTW 
MTWAIT 
FORTH GLOSSARY 
!"#$&'().+,-./01234567B9:;<.>?@AZ(\]~_ 
MTPFRR 
<LOGICAL-VALUE> 
TEST THE MAG TAPE fOR A PARITY ERROR (AFTER A READ OR A WRITE) 
AND 
PUSH A <LOGICAL-VALUE> ONTO THE STACK 
C~RRESPONDING TO THE 
PARITY ERROR FLAG. 
<ADDRESS> 
<#WORDS> 
MTR 
<ADDRESS> 
<#WORDS> 
INITIATE THE READING OF A 
MAG 
TAPE 
RECORD 
INTO 
THE 
BUFFER 
SPECIFIED BY <ADDRESS>. 
A MAXIMUM OF <#WORDS> WILL BE READ 
I~. 
RETURN 
IS 
MADE 
AS 
SOON 
AS THE OPERATION IS INITIATED. 
THE 
VARIABLF >8CO DETERMINES THE READING MODE OF THE 
7-TRACK 
TAPE 
(~INARY 
OR 
BCD). 
NOTE 
THAT 
THIS WORD DOES NOT POP ITS TWO 
PARAMETERS OFF THE STACK. SEE MTREAD. 
<ADDRESS> 
<#WORDS> 
MTREAD 
EXECUTE THE WORD MTR AND WAIT FOR THE 
OPERATION 
TO 
COMPLETE. 
ERROR 
CHECKING 
IS PERFORMED AND IF A PARITY ERROR IS DETECTED 
THE READ WILL BE RETRIED UP TO 5 
TIMES, 
AT 
WHICH 
TIME 
THE 
MESSAGE "PARITY" WILL BE OUTPUT AND THE OPERATION ABORTED. 
MTREJ 
<LOGICAL-VALUE> 
PUSH 
A 
<LOGICAL-VALUE> ONTO THE STACK DEPENDING ON WHETHER OR 
NOT THE LAST COMMAND TO THE MAG TAPE WAS REJECTED. 
<ADDRESS> 
<#WORDS> 
MTW 
<ADDRESS> 
<#WORDS> 
INITIATE THE WRITING OF A 
MAG 
TAPE 
RECORD 
FROM 
THE 
MEMORY 
ADDRESS 
SPECIFIED. 
<#WORDS> SPECIFIES THE NUMBER QF wORDS TO 
WRITE. 
RETURN IS MADE AS SOON AS THE OPERATION 
IS 
INITIATED. 
THE 
VARIABLE 
>BCO 
DETERMINES THE WRITING MODE OF THE 7-TRACK 
TAPE (BINARY OR BCD). 
NOTE THAT THIS WORD 
DOES 
NOT 
POP 
ITS 
PARAMETERS OFF THE STACK. SEE MTWRITE. 
WAIT UNTIL THE MAG TAPE UNIT IS READY AND THEN RETURN. 
MTWRITE 
<ADDRESS> 
<#WORDS> 
MTWRITE 
EXECUTE 
THE 
WORD 
MTW AND WAIT FOR THE OPERATION TO COMPLETE. 
ERROR CHECKING IS PERFORMED AND IF A PARITY ERROR 
IS 
DETECTED 
THE WRITE WILL BE RETRIED UP TO 5 TIMES, AT WHICH POINT A THREE 
INCH 
SECTION 
OF 
TAPE 
WILL BE ERASED, 
THE OPERATION STARTED 
AGAIN AND THE MESSAGE "WRITE ERROR" OUTPUT. 
MUL, 
(A) 
<ADDRESS> 
MUL, 
THE ASSEMBLER MACRO FOR THE VARIAN 
MUL 
INSTRuCTION 
(MULTIPLY 
THE B REGISTER AND MEMORY THEN ADD IN THE A REGISTER). 
D-54 
Feb. 1979 

FORTH GLOSSARY 
! "# $ S • ( ) * +, - • 10123456789: ; <= > ? @A Z[ \ J'" _ 
N 
A 
CO~STANT 
WHOSE VALUE IS THE MEMORY ADDRESS OF A ~EGION USED 
BY FORTH FOR TEMPURARY STORAGE. 
FOR EXAMPLE, THE SEQUf:NCE "N 6 
+ @" WILL PUSH ONTO THE STACK THE STATUS 
BITS 
FROM 
THE 
LAST 
DISC OPERATION, IF AN ERRQR OCCURED. 
N. 
<VALUE> 
<FIELD-WIDTH> 
<#PLACES> 
N. 
NDROP 
CONVERT <VALUE> ACCORDING TO THE CURRENT NUMBER BASE AND 
OUTPUT 
IT 
TO 
THE 
CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAL). 
FLO IS SET TO THE SPECIFIEC FIELD WIDTH AND 
OPL 
IS 
SET TO THE SPECIFIED NUMBER OF DIGITS TO APPEAR TO THE RIGHT OF 
THE RADIX POINT. 
VALUE 
OF THE 
NORDP" 
3DROP. 
<VALUE> 
NDROP 
SPECIFIES 
HOW MANY WORDS ARE TO BE DROPPED FROM 
THE TOP 
STACK. 
THE SEQUENCE "1 NOROP" IS EQUIVALENT TO DROP, "2 
IS EQUIVALENT TO 20ROP AND "3 NDROP" 
IS 
EQUIVALENT 
TO 
NEXT 
(A) 
NEWTAPF. 
NOP, 
A CONSTANT WHOSE VALUE IS THE MEMORY ADDRESS OF THE INTERPRETER 
ROUTINE 
IN 
FORTH 
THAT DOES NOTHING TO THE STACK. 
THE 
NORMAL 
SEQUENCE WOULD BE "NEXT JMP,". 
CREATES AN EMPTY TAPE WITHOUT LOADING THE BLOCK HANDLERS. 
THE 
TAPE IS REWOUND AND AN END-OF-FILE IS WRITTEN. SEE UTIL. 
(A) 
THE 
ASSEMBLER 
(NO-OPERATION) • 
MNEMONIC 
FOR 
THE 
VARIAN 
NOP 
INSTRUCTION 
NOT 
(A) 
<JUMP-CONDITION> 
NOT 
<RESULT> 
NEGATE <JUMP-CONDITION> WHICH IS ASSUMED TO BE A MACHINE 
JUMP 
CONDITION. SEE A+, A-, AO, 80 AND OV. FOR EXAMPLE, THE SEQUENCE 
"<ADDRESS> 
AO 
NOT 
JIF," WILL JUMP TO <ADDRESS> ONLY IF THE A 
REGISTER 15 NOT ZERO. 
NUMBER 
NUMBER 
<OW-RESULT> 
CONVERT THE CHARACTER STRING WHICH WAS LEFT IN 
THE 
DICTIONARY 
BUFFER BY WORD AS A NUMBER, RETURNING THE DOUBLE-WORD RESULT ON 
THE 
STACK. 
IF THE CHARACTER STRING CONTAINS CHARACTERS WHICH 
ARE NOT VALID IN A NUMBER, 
A "?Q" 
ERROR 
WILL 
OCCUR. 
AFTER 
CONVERSION THE VARIABLE #0 CONTAINS THE NUMBER OF DIGITS TO THE 
RIGHT 
OF THE RADIX POINT OR COMMA. 
IF THE CURRENT NUMBER BASE 
IS LESS THAN OR EQUAL TO 10 (DECIMAL) THEN A NUMBER 
TERMINATED 
BY THE CHARACTER B IS CONVERTED AS AN OCTAL NUMBER. 
Feb. 1979 
0-55 

O-BLK 
FORTH GLOSSARY 
A VARIABLE 
CONTAINING 
THE 
BLOCK NUMBER ON DISC OF WHERE THE 
NEXT OVERLAY REGION IS TO BE STORED. 
THE USER SHOULD 
STO~E THE 
STARTING BLOCK NUMBER Of THEIR OVERLAY REGION ON DISC IN 
O-BLK 
PRIOR TO EXECUTING A-SAVE. 
O-DEFINE 
<#CELLS> 
O-DEFINE 
<NAME> 
DEFINES 
AN 
OVERLAY 
AREA 
IN 
THE 
DICTIONARY WHOSE LENGTH IS 
<#CELLS> ANn WHOSE IDENTIFIER IS <NAME>. THE DICTIONARY POINTER 
IS ADVANCED BY <#CELLS>. THE NUMBER OF BLOCKS ON DISC THAT WILL 
BE REOUIRED BY EACH OVERLAY USING <NAME> WILL BE <#CELLS> I 512 
(ROUNDED UP TO THE NEAREST INTEGER). EXECUTING <NAME> WILL MOVE 
THE DICTIONARY POINTER BACK TO THE 
BEGINNING 
OF 
THE 
OVERLAY 
REGION 
SO 
THAT 
SUBSEQUENTLY 
DEFINED 
WORDS, 
UP TO THE 
~EXT 
A-SAVE OR O-SAVE, 
WILL COMPRISE AN OVERLAY. 
AFTER AN 
OVERLAY 
HAS BEEN DEFINED AND SAVED, 
THE DICTIONARY POINTER IS RESTORED 
TO ITS VALUE PRECEDING THE EXECUTION OF 
<NAME>. 
O-LOAD 
<NAME> 
O-LOAD 
O. 
<NAME> 
MUST 
BE 
A PREVIOUSLY 
SAVED 
OVERLAY (SEE A-SAVE AND 
O-SAVE) WHICH IS THEN EXPLICITLY LOADED INTO 
MEMORY. 
COMPARE 
THIS 
EXPLICIT 
LOADING OF AN OVERLAY WITH THE IMPLICIT LOADING 
PROVIDED BY INCLUDES. IF ANOTHER OVERLAY IS PRESENTLY IN MEMORY 
AND IF ITS PRECEDENCE BIT IS SET (SEE 
IMP) 
THEN 
IT 
WILL 
BE 
WRITTEN TO DISC BEFORE <NAME> IS READ INTO MEMORY. 
<VALUE> 
O. 
OCTAL OUTPUT. 
OUTPUT 
PRECEDED 
BY 
A BLANK 
OPERATOR'S TERMINAL). 
VARIABLES FLD AND OPL 
<VALUE> AS AN OCTAL NUMBER, 
UNSIGNED 
A~D 
ON THE CURRENT OUTPUT 1EVICE (USUALLY THE 
THE FORMAT SPECIFICATIONS GIVEN 
BY 
THE 
ARE OBSERVED. BASE IS NOT CHANGED. 
OAR, 
(A) 
<DEVICE-CODE> 
OAR, 
THt 
ASSE~BLER 
MNEMONIC FOR THE VARIAN OAR INSTRUCTION (OUTPUT 
THE A REGISTER). 
08R, 
(A) 
<DEVICE-CODE> 
OBR, 
OCTAL 
THE ASSEMBLER MNEMONIC FOR THE VARIAN OBR 
INSTRUCTION 
(OUTPUT 
THE B REGISTER). 
SETS 
THE 
NUMERIC CONVERSION BASE TO OCTAL, 
THAT IS, 
SET THE 
VARIABLE BASE TO 8. SEE DECIMAL AND HEX. 
OFF! 
<PUSHBUTTON#> 
OFF! 
OFFLINE 
D-56 
TURN OFF THE STATUS BIT OF THE SPECIFIED 
CAMAC 
DISPLAY 
PANEL 
PUSHBUTTON. 
<PUSHBUTTON> 
IS 
AN INTEGER VALUE IN THE RANGE 0 
THROUGH 31. SEE PBARRAY, ON!, PSTOGGLE AND PTOGGLE. 
FORCES THE MAG TAPE DRIVE OFF-LINE. 
Peb. 1979 

FORTH GLOSSARY 
OHE, 
(A) 
<ADDRESS> 
<DEVICE-CODE> 
OME, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN OME 
INSTRUCTION 
(OUTPUT 
FROM MEMORY). 
ON! 
<PUSHBUTTON.> 
ON! 
TURN 
ON 
THE 
STATUS 
BIT OF THE SPECIFIED CAMAC OISPLA ( PANeL 
PUSHBUTTON. 
<PUSHBUTTON> IS AN INTEGER VALUE IN 
THE 
RANGE 
0 
THROUGH 31. SEE PBARRAY, OFF!, PSTOGGLE AND PToGGLE. 
OP 
(C) 
A VARIABLE CONTAINING THE BYTE-ADDRESS OF THE NEXT CHARACTER TO 
BE PLACED IN CORE BY THE SUBROUTINE DEPOSIT. SEE O)S. 
OR 
<VALUEl> 
<VALUE2> 
OR 
<RESULT> 
CRA, 
ORCX 
COMPUTE 
THE 
BITWISE 
INCLUSIVE-OR 
OF 
<VALUEl> AND <VALUE2>, 
LEAVING THE RESULT ON THE STACK. 
CA) 
<ADDRESS> 
ORA, 
THE 
ASSEMBLER 
MNEMONIC 
FOR 
THE 
VARIAN 
ORA 
INSTRUCTION 
(INCLUSIVELY-OR MEMORY WITH THE A REGISTER). 
INITIATES AN ANONYMOUS CODE DEFINITION, 
PLACING ITS AODRESS IN 
THE PSEUDO-VECTOR ENTRY X, 
FOR SUBSEQUENT ADOPTION BY THE WORD 
AOOX. 
SIMILAR TO THE ANONYMOUS COLON DEFINITIONS INITIATEn BY 
:ORX. IT IS VERY IMPORTANT TO REMEMBER THAT FORTH'S COMPILATION 
FLAG IS NOT SET WHILE 
ASSEMBLING 
MACHINE 
CODE 
INSTRUCTIONS, 
THAT IS, FORTH REMAINS IN EXECUTION MODE. SEE P-VX. 
OTHERWISE CE) 
THIS 
WORD 
PRECEDES 
THE 
FALSE-PART 
OF 
AN INTERPRETER LEVEL 
CONDITIONAL. SEE IFTRUE. 
OV 
(A) 
OV! 
A CONSTANT WHOSE VALUE SPECIFIES THE 
JUMP 
CONDITION 
FOR 
THE 
"OVERFLOW SET" TEST. USUALLY FOLLOWED BY IF, END, JIF, JIFM, OR 
XIF,. REFER TO PAGE 20-18 OF THE VARIAN HANDBOOK. SEE NOT. 
( A) 
MODIFY 
THE 
PREVIOUS 
WORD 
IN THE 
REGISTER 
CHANGE 
INSTRUCTION) 
TO 
OVERFLOW 
BIT 
IS ON (I.E. 
-
BIT 8 
DICTIONARY IS TURNED ON). 
REFER TO 
HANDBOOK. 
DICTIONARY (ASSUMED TO BE A 
BE 
EXECUTED 
ONLY 
IF 
THE 
OF THE PREVIOUS WORD 
IN THE 
PAGE 20-33 
OF 
THE 
VARIAN 
OVER 
<VALUEl> 
<VALUE2> 
OVER 
<VALUE 1> 
<VALUE2> 
<VALUEl> 
PUSH 
A COpy 
OF 
<VALUE1> ONTO THE TOP OF THE STACK, 
WITHOUT 
REMOVING ANY WORDS FROM THE STACK. 
Feb. 1979 
0-57 

FORTH GLOSSARY 
!"#$£.'()*+,-.10123456789:;<s>?@AZ(\] .... _ 
P ) 
( A ) 
SETS THE VARIABLE MODE TO 4, SPECIFYING RELATIVE ADDRESSING OFF 
THE P REGISTER FOR THE NEXT MEMORY REFERENCE INSTRUCTION. 
P-vx 
P-VX 
<ADDRESS> 
PUSHES ONTO THE STACK THE ADDRESS OF ONE ELEMENT IN 
A 16-WORD 
TEMPORARY 
STORAGE 
AREA KNOWN AS THE PSEUDO-VECTOR TABLE. 
THE 
cOURTH CHARACTER OF 
THE 
WORD 
P-VX 
SPECIFIES 
WHICH 
OF 
THE 
SIXTEEN 
ELEMENTS IS BEING REFERENCED: 
THE LOWER 4-8ITS OF THIS 
CHARACTER, A VALUE BETWEEN 0 AND 15, IS USED, IMPLYING THAT FOR 
SXAMPLE, P-Vl AND P-VA BOTH REFERENCE THE SECOND ELEMENT. THESE 
SIXTEEN TEMPORARY LOCATIONS ARE USED DURING COMPILATION 
EITHER 
DIRECTLY 
FOR TEMPORARY STORAGE BY THE PROGRAMMER OR INDIRECTLY 
BY THE 
WORDS :ORX, <<LX, »LX, ADOX, INTX, ORCX, RCLX AND STRX. 
THE EOUIVALENCE BETWEEN THE LOWER 4-BITS OF THE CHARACTER X ARE 
AS FOLLOWS: 
00 
01 
02 
03 
04 
05 
06 
07 
10 
11 
12 
13 
14 
15 
16 
17 
,. 
• ,. 
• .. 
,. 
.. .. 
= 
,. 
.. 
,. 
• 
,. 
:: 
o 
1 
2 
3 
4 
5 
6 
7 
8 
9 
, 
< 
> 
? 
@ 
A 
B 
C o 
E 
F 
G 
H 
I 
J 
K 
l 
M 
N 
o 
P 
Q 
R 
S 
T 
U 
V 
W 
X 
Y 
Z 
[ 
\ 
] 
" 
Ii 
$ 
PERCENT 
£. 
* 
+ , 
• 
I 
PACK 
<OW-VALUE> 
PACK 
<DW-RESULT> 
PAGE 
D-58 
CONVERT <OW-VALUE> FROM 
A 
VARIAN 
DOUBLE-wORD 
INTEGER 
TO 
A 
PACKED, 
CAMAC 24-8IT VALUE, 
IN PREPARATION FOR CAMAC OUTPUT. 
SE E UN PK. 
ERASES THE OPERATOR'S TERMINAL SCREEN OR 
SOME 
SIMILAR 
ACTION 
APPROPIATE FOR THE PARTICULAR DEVICE. 
Feb. 1979 

FORTH GLOSSARY 
!"#$&'()*+,-./0123456789:;<=>?Q)AZ(\]"'_ 
PB# 
A CONSTANT 
WHOSE VALUE SPECIFIES THE PUSHBUTTON NUMBER OF THE 
CAMAC DISPLAY PANEL PUSHBUTTON THAT WAS PRESSED TO GENERATE 
AN 
INTERRUPT. 
THE VALUE OF PB# WILL BE IN THE RANGE 1 THROUGH 31 
AND SHOULD BE EXAMINED ONL Y WHEN THE VARIABLE PB@ 
IS 
NON-ZERO 
(TRUE). SEE PBENABLE AND PBDISABLE. 
PB@ 
PB@ 
<LOGICAL-RESULT> 
PBARRAY 
PBDISABlE 
PBENABLE 
PUSH 
A <LOGICAL-RESULT> ONTO THE STACK DEPENDING ON WHETHER A 
CAMAC DISPLAY PANEL PUSHBUTTON INTERRUPT HAS 
OCCURED. 
IF 
AN 
INTERRUPT HAS OCCURED, THE CONSTANT PB# WILL CONTAIN THE NUMBER 
OF THE PUSHBUTTON THAT WAS PRESSED. SEE PBENABLE AND PBDISABLE. 
A 32-WORD 
VECTOR WHICH MUST BE SET BY THE USER TO CONTAIN THE 
STATUS 13IT, 
INITI~L LIGHT STATUS AND 
TOGGLING 
BITS 
FOR 
THE 
CAMAC DISPLAY PANEL PUSHBUTTON LIGHTS. THE MOST SIGNIFICANT BIT 
OF 
EACH 
WORD 
IN PBARRAY IS THE PUSHBUTTON'S STATUS 
BIT~ 
THE 
NEXT 7 BITS ARE UNUSED, 
THE NEXT 4 BITS 
SPECIFY 
THE 
INITIAL 
LIGHT 
STATUS 
FOR EACH OF THE PUSHBUTTON'S FOUR LIGHTS AND THE 
LOWER 4 
BITS 
SPECIFY 
THE 
TOGGLING 
BITS 
FOR 
EACH 
OF 
THE 
PUSHBUTTON'S 
FOUR LIGHTS. 
WHEN THE LIGHTS ARE TOGGLED THE NEW 
LIGHT STATUS EQUALS THE CURRENT LIGHT STATUS EXCLUSIVELY 
OR-EO 
WITH 
THE 
TOGGLE 
BITS. 
SEE 
PLARRAY, 
PBLIGHTS, 
PLTOGGLE, 
PSTOGGLE, PTOGGLE, ON! AND OFF!. 
DISABLE INTERRUPTS FROM THE CAMAC 
DISPLAY 
PANEL 
PUSHBUTTONS. 
SEE PBENABlE. 
ENABLF 
INTERRUPTS 
FROM 
THE 
CAMAC DISPLAY PANEL PUSHBUTTONS. 
WHEN AN INTERRUPT OCCURS THE VARIABLE PB@ WILL 
BE SET 
NON-ZERO 
(TRUE) 
AND 
THE 
CONSTANT 
PB# 
WILL 
BE SET TO THE PUSHBUTTON 
NUMBER THAT WAS PRESSED 
(AN 
INTEGER 
VALUE 
IN 
THE 
RANGE 
1 
THROUGH 
31>. 
IT IS UP TO THE PROGRAM TO CONTINUALLY TEST 
PB@. 
NDTE THAT PUSHBUTTON NUMBER 0 IS HANDLED SPECIALLY BY FORTH 
AS 
A "?Z" ABORT. SEE PBDISABLE. 
PBLIGHTS 
<LIGHT-BITS> 
<PUSHBUTTON#> 
PBLIGHTS 
TURN 
ON 
THE 
SPECIFIED LIGHTS IN THE DESIGNATED CAMAC DISPLAY 
PANEL PUSHBUTTON. <PUSHBUTTON> IS AN INTEGER VALUE IN THE 
RANGE 
o THROUGH 31. 
<LIGHT-BITS> IS AN INTEGER VALUE WHOSE 
LOWER 
4 
BITS 
SPECIFY 
WHICH 
LIGHTS IN THE PUSHBUFFON ARE TO BE TURNED 
ON. SEE PLARRAY. 
PICK 
<INDEX> 
PICK 
<RESULT> 
<INDEX> SPECIFIES A LOCATION ON THE STACK (1 SPECIFIES THe 
TOP 
OF THE STACK, 
2 IS THE NEXT WORD ON THE STACK, ETC) AND A COpy 
OF THIS WORD IS PUSHED ONTO THE TOP OF THE STACK. 
THE 
SEQU~NCE 
"2 PICK" IS EOUIVALENT TO THE WORD OVER. 
Feb. 1979 
D-59 

PLARRAY 
PLT 
FORTH GLOSSARy 
! "# $ £. ' ( ) * + , - • 1 0123456789 : ; < ,. > ? Q) A Z ( \ ] " _ 
A 
VECT1R 
MAINTAINED 
BY 
THE 
CAMAC DISPLAY PANEL ROUTINES TO 
REFLECT THE CURRENT STATUS OF EACH LIGHT OF tVERY PUSHBUTTON. A 
4-BIT ENTRY IS RECUIRED FOR EACH PISHBUTTON, 
WITH 
THE 
4-8IT5 
SPECIFYING 
(IN 
DECREASING 
ORDER OF SIGNIFICANCE): UPPER LEFT 
LIGHT, 
UPPER RIGHT LIGHT, 
LOWER LEFT LIGHT 
AND 
LOWER 
~IGHT 
LIGHT. 
FOUR OF THESE 4-BIT ENTRIES ARE PACKED TO EACH WORD OF 
PLARRAY WITH WORD 0 CONTAINING THE LIGHT STATUS FOR PUSHBUTTONS 
0, 
1, 
? AND 3, 
WORD 
1 
CONTAINING 
THE 
LIGHT 
STATUS 
FOR 
PUSHBUTTONS 4, 5, 6 AND 7, ETC. SEE PBARRAY, PBLIGHTS, PLTOGGlE 
AND PTOGGLE. 
<X-POSN> 
<Y-POSN> 
DRAWS 
A VECTOR ON THE 4010 
BY <X-PO$N> AND <Y-POSN> AND 
<X-POSN> 
AND 
<Y-POSN> 
ARE 
0-1023 AND 0-780. 
PLT 
TO THE PHYSICAL POSITION SPECIFIED 
SAVES THIS NEW POSITION IN 
14010. 
SINGLE-WORD INTEGERS IN ThE RANGE 
PlTOGGLE 
<PUSHBUTTON#> 
PLTOGGLE 
TOGGLE THE LIGHT BITS OF 
THE 
SPECIFIED 
CAMAC 
DISPLAY 
PANEL 
PUSHBUTTON. 
THE 
NEW 
VALUE 
OF 
THE LIGHT BITS ARE STORED IN 
PLARRAY. 
<PUSHBUTTON> IS AN 
INTEGER 
VALUE 
IN 
THE 
RANGE 
0 
THROUGH 31. SEE PLARRAY AND PTOGGLE. 
POP 
(A) 
PPLOT 
P REV 
D-60 
A CONSTANT WHOSE VALUE IS THE MEMORY ADDRESS OF THE INTERPRETER 
ROUTINE 
IN 
FORTH TO POP ONE WORD OFF THE STACK. 
THE SEQUENCE 
"POP 1-" LEAVES THE ADDRESS OF THE INTERPRETER ROUTINE 
TO 
POP 
TWO 
WORDS 
OFF 
THE STACK. 
THE NORMAL SEQUENCE IS EITHER "POP 
JMP," OR "POP 1- JMP,". 
<X-POSN> 
<Y-POSN> 
PPLOT 
DRAWS A VECTUR ON THE 4010 TO THE PHYSICAL 
POSITION 
SPECIFIED 
BY 
<X-POSN> 
AND <Y-POSN>. 
THIS NEW POSITIGN IS THEN SAVED IN 
14010. 
<X-POSN> AND <Y-POSN> ARE FLOATING-POINT 
NUM8E~S IN THE 
RANGE 0.0 -
1023.3 AND 0.0 -
780.0. 
A VARIBALE CONTAINING THE 
ADDRESS 
OF 
THE 
LAST-wORD 
CURRENT BLOCK BUFFER BEING USED. THE SEQUENCE "PREV @ @" 
ONTO 
THE 
STACK 
THE 
BLOCK 
NUMBER 
AND 
UPDATE 
BIT 
SIGNIFICANT RIT) OF THIS BLOCK. 
THE SEQUENCE 
"PREV 
1+ 
PUSHES 
ONTO 
THE 
STACK THE BLOCK NUMBER AND UPDATE BIT 
AL TERNATE BLOCK. 
OF 
THE 
PUSHES 
(MOST 
@ 
@" 
OF THE 
Feb. 1979 

FORTH GLOSSARY 
! It # $ £. • ( , * +, -. 10123456789: ; <. >?@A Z C\ J A_ 
PRINTER 
PRINTERS 
SETS A FLAG DENOTING THAT OUTPUT IS TO BE DIRECTED TO THE 
LINE 
PRINTER RATHER THAN THE TERMINAL. SEE TERMINAL. 
DEFINES 
THE 
FOLLOWING 
WORDS WHICH, 
WHEN EXECUTED, 
LI~AD THE 
WORDS FOR THE CORRESPONDING LINE PRINTER (SEE UTIL): 
CEN 
CENTRONICS 
GOULD 
GOUL D 
TI 
TEXAS INSTRUMENTS SILENT 700 
T40 
TELETYPE MODEL 40 
PTC 
PRINTEC 
PSTOGGLE 
<PUSHBUTTON#> 
PSTOGGLE 
PTOGGLE 
TOGGLE THE STATUS BIT OF 
THE 
SPECIFIED 
CAMAC 
DISPLAY 
PANEL 
PUSHBUTTON. 
<PUSHBUTTON> 
IS 
AN INTEGER VALUE IN THE RANGE 0 
THROUGH 31. SEE PBARRAY, ON!, OFF! AND PTOGGLE. 
<PUSHBUTTON#> 
PTOGGLE 
TOGGLE THE STATUS BIT AND THE LIGHT -
CAMAC 
DISPLAY 
PANEL 
PUSHBUTTON. 
VALUE IN THE 
RANGE 
0 
THROUGH 
31. 
PLTOGGLE, PSTOGGLE, ON! AND OFF!. 
STATUS 
OF 
THE 
SPECIFIED 
<PUSH8UTTON> IS AN INTEGER 
SEE 
PLARRAY, 
PBARRAY, 
PUSH 
(ld 
A CONSTANT WHOSE VALUE IS THE MEMORY ADDRESS OF THE INTERPRETER 
ROUTINE 
IN 
FORTH 
TO PUSH THE CONTENTS OF 
THE A REGISTER ONTO 
THE STACK. THE NORMAL SEQUENCE IS "PUSH 
J~P,". 
PUT 
(A' 
A CONSTANT WHOSE VALUE IS THE MEMORY ADDRESS OF THE INTERPRETER 
ROUTINE IN FORTH TO POP ONE WORD FROM THE STACK AND 
THEN 
PUSH 
THE 
CONTENTS 
OF 
THE 
A 
REGISTER ONTO THE STACK. 
THE NORMAL 
SEQUENCE IS "PUT JMP,". 
OBF 
(A) 
QUIT 
A VARIABLE WHOSE VALUE IS THE BYTE ADDRESS OF THE BUFFER TO 
BE 
USED FOR OPERATOR INPUT. 
CLEAR 
THE 
RETURN 
STACK (IN CASE THIS WORD IS EXECUTED 
FROM A 
WORD WHICH HAS BEEN CALLED BY OTHER wORDS) 
AND 
RETURN 
CONTROL 
TO THE TERMINAL. 
OUIT 
(OLD) 
RENAMED ABORT. 
Feb. 1979 
0-61 

FORTH GLOSSARY 
R# 
R# 
<VALUE> 
R#VALUE 
RANDOM 
NUMBER GENERATOR, 
RETURNING <VALUE> AS THE NEXT RANDOM 
NUMBER IN THE PSEUDO-RANDOM SEQUENCE. 
THE ALGORITH USED 
IS 
A 
LINEAR 
CONGRUENTIAL 
SEQUENCE WITH A PERIOD OF 65536. 
<VALUE> 
WILL BE IN THE RANGE -32768 THROUGH 32767. 
IF A NUMBER SMALLER 
THAN <VALUE> IS REQUIRED THEN THE HIGH ORDER 
BITS 
OF 
<VALUE> 
SHOULD 
BE 
USED AS THE LOW ORDER BITS WILL BE MUCH LESS RANDOM 
THAN THE HIGH ORDER BITS. 
A VARIABLE WHOSE VALUE IS 
THE 
PREVIOUS 
PSEUDO-RANDOM 
NUMBER 
GENERATED 
BY 
R#. 
IF 
A REPEATABLE 
SEQUENCE 
OF NUMBERS IS 
DESIRED, 
THEN ONE MAY SET R#VALUE TO ANY DESIRED VALUE, 
PRIOR 
TO EXECUTING R# FOR THE FIRST TIME. 
Rl-2 
<VALUE> 
Rl-2 
<RESULT> 
<VALUE> MUST BE A 14-BIT FRACTION AND THE SQUARE ROOT OF 
(1 
<VALUE>**2) IS COMPUTED AND LEFT AS THE RESULT. 
R> 
(C ) 
POP 
THE 
TOP 
VALUE FROM THE RETURN STACK AND PUSH IT ONTO THE 
REGULAR STACK. SEe >R. 
D-62 
Feb. 1979 

FORTH GLOSSARY 
!"#$E.'(}*+,-./0123456789:;<=>?@AZ(\]"_ 
RCLX 
ec} 
RCLX 
<VALUE> 
PUSH ONTO THE STACK THE VALUE AT THE 
LOCATION 
ESTABLISHED 
BY 
INTX. SEE INTX, STRX AND P-VX. 
READ-MAP (T) 
READ 
FROM 
THE CURRENT POSITION ON TAPE TO THE NEXT FILt--MARK, 
CONSTRUCTING IN MEMORY THE 
~AP 
RELATING 
THE 
PHYSICAL 
BLOCK 
POSITIONS 
ON 
TAPE 
WITH 
THE 
LOGICAL BLOCK NUMBER. 
THE TAPE 
SHOULD NORMALLY BE REWOUND PRIOR 
TO 
EXECUTING 
READ-MAP 
(SEE 
REWIND) • 
REAL 
<FP-VALUE> 
REAL 
<NAME> 
RECOVER 
REDEF 
DEFINE A FLOATING-POINT VARIABLE. 
THE VALUE OF THE VARIABLE IS 
INITIALIZED 
TO <FP-VALUE> AND WHEN THE WCRD <NAME> IS EXECUTED 
THE 
ADDRESS Of THE FLOATING-POINT VALUE 
OF THE VARIABLE WILL BE 
PUSHED ONTO THE STACK. SEE VARIABLE AND 2VARIABLE. 
READS A 32K 
CORE 
IMAGE 
FROM 
DISC 
TO 
MEMORY, 
EFFECTIVELY 
REPLACING 
THE ENTIRE MEMORY WITH WHATEVER THE MEMORY CONTAINED 
WHEN THE CORE IMAGE WAS WRITTEN. SEE SNAPSHOT. 
SEARCHES EACH VOCABULARY IN THE DICTIONARY 
FOR 
REDEFINITIONS. 
SEE UTIL. 
REMEMBER 
REMEMBER 
<NAME> 
REPEAT 
DEFINE 
A 
WORD 
<NA~E> 
WHICH 
WHEN 
EXECUTED 
WILL 
CAUSE ALL 
SUBSEQUENTLY DEFINED WORDS TO BE DELETED FROM 
THE 
DICTIONARY. 
THE 
WORD <NAME> MAY BE COMPILED INTO AND EXECUTED FROM A COLON 
DEFINITION. 
THE SEQUENCE "DISCARD REMEMBER DISCARD" PROVIDES A 
STANDARDIZED PREFACE TO ANY 
GROUP 
OF 
TRANSIENT 
WORDS. 
SEE 
FORGET. 
(C 2-, P ) 
EFFECT 
AN 
UNCONDITIONAL 
JUMP 
BACK 
TO 
THE 
BEGINNING 
OF A 
BEGIN-WHILE-REPEAT LOOP. SEE BEGIN. 
PEPLACE 
REPLACE 
<WORDl> 
<WORD2> 
RESIDENT 
Feb. 1979 
REPLACE ALL OCCURENCES OF <WORDl> BY <WORD2> WHEN THE WORD 
FIX 
IS 
EXECUTED. 
NEITHER 
<WORDl> 
NOR 
<WORD2> 
MAY CONTAIN ANY 
SPACES. SEE FIX, $REPLACE AND WINIT. 
LOADS BLOCK ZOO. THE ACTIONS PERFORMED BY BLOCK 200 ARE TOTALLY 
USER DEPENDENT. 
D-63 

RETURN 
REW 
REWIND 
FORTH GLOSSARY 
(A) 
<ADDRESS> 
RETURN 
AN ASSEMBLER MACRO TO GENERATE A JUMP INDIRECT 
INSTRUCTION 
TO 
THE SPECIFIED MEMORY <ADDRESS>. 
THIS WORD IS TYPICALLY USED TO 
RETURN 
FROM 
A 
MACHINE 
LANGUAGE 
SUBROUTINE, 
IN WHICH CASE 
<ADDRESS> IS PUSHED ONTO THE STACK BY EXECUTING THE NAME OF THE 
SUBROUTINE. 
SINCE THE RETURN ADDRESS OF A VARIAN 
SUBROUTI~E IS 
STORED IN THE FIRST WORD OF THE SUBROUTINE, 
A JUMP INDIRECT TO 
THE 
FIRST 
WORD 
WILL 
RETURN 
CONTROL 
TO 
THE 
CALLER. 
SEE 
SUBROUTINE. 
INITIATES 
A REWIND OF THE MAG TAPE AND WAITS FOR THE OPERATION 
TO COMPLETE. SEE RW. 
( T) 
REwIND THE TAPE TO ITS LOAD POINT AND SET THE VARIABLE 
CUR 
TO 
1 • 
ROF, 
(A) 
THE 
ASSEMBLER 
MNEMONIC 
FOR THE VARIAN ROF INSTRUCTION (RESET 
THE OVERFLOw BIT). 
ROLL 
<INDEX> 
ROLL 
<INDEX> SPECIFIES A LOCATION ON THE STACK (1 SPECIFIES THE 
TOP 
OF 
THE STACK, 
2 IS THE NEXT WORD ON THE STACK, 
ETC) AND THIS 
wORD ON THE STACK IS MOVED TO THE TOP OF 
THE 
STACK 
WITH 
ALL 
WORDS 
ON THE STACK BETWEEN BEING MOVED DOWN ONE POSITION. 
THE 
SEQUENCE "1 ROLL" IS A NULL OPERATION, THE SEQUENC E "3 ROLL" IS' 
EQUIVALENT TO ROT AND THE SEQUENCE "0 ROLL" IS UNDEFINED. 
ROT 
<VAlUE1> 
<VALUE2> 
<VALUE3> 
ROT 
<VALUE2> 
<VAlUE3> 
<VALUE1> 
ROTATE THE TOP THREE POSITIONS ON THE STACK. 
<VALUE1> IS MOVED 
TO THE TOP OF THE STACK, 
<VALUE3> MOVES FROM THE 
TOP 
TO 
THE 
SECOND 
POSITION AND <VALUE2> MOVES FROM THE SECOND POSITION TO 
THE TH I RD. 
RP 
RP 
<ADDRESS> 
PUSHES ONTO 
THE 
STACK 
THE 
ADDRESS 
OF 
THE 
NEXT 
AVAILABLE 
LOCATION ON THE RETURN STACK. 
RS.C 
<VALUE> 
RS.C 
<RESULTl> 
<RESULT2> 
RW 
D-64 
<VALUE> 
MUST 
BE 
A 14-8IT 
FRACTION 
(REVOLUTIONS) AND IT IS 
REPLACED BY ITS SINE· AND 
COSINE 
(IN 
RADIANS), 
BOTH 
14-BIT 
FRACTIONS, 
WITH 
THE 
COSINE ON TOP OF THE STACK AND THE SINE 
BELOW. 
INITIATES A REWIND OF THE MAG TAPE AND RETURNS IMMEDIATELY. SEE 
REW. 
Feb. 1979 

FORTH GLOSSAR Y 
s ) 
( A) 
S. 
SETS 
THE VARIA8LE MODE TO 5 AND PUSHES A VALUE OF ZERO ONTO THE 
STACK 
(FOR THE NEXT MEMORY REFERENCE INSTRUCTION). THE VALUE OF 
ZERO SPECIFIES THE 
DISPLACEMENT 
AND 
THE 
WORD 
S) 
THEREFOKE 
SPECIFIES 
THAT 
THE 
NEXT 
MEMORY 
REFERENCE INSTRUCTION IS TO 
ADDRESS THE TOP WORD 
ON 
THE 
STACK 
(SINCE 
FORTH 
KEE?S 
THE 
ADDRESS OF THE TOP ELEMENT ON THE STACK IN THE X REGISTER). 
<VALUE> 
S. 
CONVERT <VALUE> ACCORDING TO THE CURRENT NUMBER BASE 
IT 
TO 
THE 
CURRENT 
OUTPUT 
DEVICE 
(USUALLY 
THE 
TERMINAL). 
FORMATTING OF THE NUMBER IS SPECIFIED BY 
OF THE VARIABLES FLO AND DPL. 
AND OUTPUT 
OPERATOR'S 
THE VALUES 
S@ 
(OLD) 
RENAMED PICK. 
SASK 
SASK 
<VALUE> 
SAVEDISK 
REQUEST THE INPUT OF A SINGLE-WORD VAluE FROM THE TERMINAL. 
<BLOCK#> 
TRANSFERS 
BLOCKS 
EFFECTIVELY SAVING 
IF NOT SPECIFIED A 
SAVEDISK 
1 
THROUGH 
<BLOCK#> 
FROM 
DISC 
TO 
TAPE, 
THE BLOCKS ON TAPE. <BlOCK4> IS OPTIONAL AND 
VALUE OF 511 IS USED. 
SAVER 
(A) 
A CONSTANT 
WHOSE 
VALUE IS THE MEMORY ADDRESS OF A SUBROUTINE 
THAT WILL SAVE THE SYSTEM'S STATUS ON THf STACK AND THEN 
START 
INTERPRETATION 
OF 
A SEQUENCE OF HIGH LFVEL WORDS. 
THE 
WORDS 
SAVER AND UNSAVER, 
ARE USED TO EXECUTE SOME HIGH 
LEVEL 
FORTH 
WORDS 
FROM 
WITHIN 
A MACHINE CODE INTERRUPT PROCESSING WORD. 
THIS SUBROUTINE MUST BE CALLED WITH A JSR INSTRUCTION USING THE 
B REGISTER TO HOLD THE RETURN ADDRESS. 
THE 
STANDA~O 
CALLING 
SEQUENCE WOULD BE "SAVER 6 JSR,". THIS SUBROUTINE WILL SAVE THE 
A REGISTER, 
OVERFLOW 
BIT, 
INTERPRETER INSTRUCTION COUNTER, 
FOREGROUND ADDRESS AND THE VARIABLE <T> (THE B REGISTER MUST BE 
SAVED BY THE CALLER BEFORE EXECUTING THE JSR). 
THE 
DICTIONARY 
LOCATIONS 
FQLLOWING 
THE 
JSR 
INSTRUCTION 
MUST 
CONTAIN 
THE 
COMPILATION ADDRESSES OF A SEQUENCE OF FORTH WORDS 
WHICY 
WILL 
THEN BE EXECUTED, 
AFTER THE SYSTEM STATUS HAS BEEN SAVED. 
THE 
FINAL WORD IN THE SEQUENCE MUST BE UNSAVER, 
WHICH WILL RESTURE 
THE 
SYSTEM 
STATUS 
THAT 
WAS 
SAVED 
BY 
SAVER AND THEN START 
EXECUTION OF 
THE 
MACHINE 
CODE 
FOLLOWING 
UNSAVER, 
IN 
THE 
DICTIONARY 
(USUALLY 
SOME 
CODE 
TO RESTORE THE B REGISTER AND 
RETURN FROM THE INTERRUPT). 
Feb. 1979 
0-65 

FORTH GLOSSARY 
SEN, 
CA) 
<FUNCTION-DEVICE> 
SEN, 
SENSE 
SET 
S FIX 
THE ASSEMBLER MNEMONIC FOR THE VARIAN SEN INSTRUCTION (SENSE 
A 
DEVICE). 
(A) 
<CQNDITION-DEVICE> 
SENSE 
AN 
ASSEMBLER MACRO WHICH GENERATES A MACHINE INSTRUCTION. 
THE 
INSTRUCTION 
GENERATED 
IS 
AN 
SEN, 
(USING 
THE 
SPECIFIED 
<CONDITION-DEVICE» 
WITH AN ADDRESS OF HERE+4. 
IT IS THEREFORE 
ASSUMED 
THAT 
A JUMP INSTRUCTION FOLLOWS THE SENSE INSTRUCTION 
AND IF 
THE 
SPECIFIED 
<CONDITION-DEVICE> 
IS 
TRUE 
THE 
JUMP 
INSTRUCTION IS BYPASSED, 
AND IF FALSE, THE JUMP INSTRUCTION IS 
EXECUTED. 
<VALUE> 
<ADDRESS> 
SET 
<NAME> 
DEFINE 
THE WORD <NAME> SUCH THAT WHEN IT IS EXECUTED, 
<VALUE> 
WILL BE STORED IN THE MEMORY LOCATION POINTED TO BY <ADDRESS>. 
<FP-VALUE> 
SFIX 
<RESULT> 
TRUNCATE <FP-VALUE> TO A SINGLE-WORD 
WANTS 
TO 
ROUND 
THE FLOATING-POINT 
THE FLOATING-POINT VALUE 0.5 
SHOULD 
PRIOR TO EXECUTING SFIX. SEE DFIX. 
INTEGER 
VALUE. 
IF 
ONE 
VALUE 
P~IOR TO TRUNCATION, 
BE 
ADDED 
TO 
<FP-VALUE> 
SFLOAT 
<VALUE> 
SFLOAT 
<FP-RESULT> 
CONVERT 
THE 
SINGLE-WORD 
<VALUE> 
TO 
ITS 
FLOATING-POINT 
REPRESENTATION AND LEAVE THE RESULT ON THE STACK. 
SIN.COS 
<VALUE> 
SIN.COS 
<RESULT1> 
<RESULT2> 
SKIPF 
SNAPSHOT 
<VALUE> IS A SINGLE-WORD INTEGER (MINUTES OF ARC) 
AND ITS 
SINE 
AND 
COSINE 
(BOTH 14-BIT FRACTIONS) ARE CALCULATED AND LEFT ON 
THE STACK WITH THE COSINE ON TOP OF 
THE 
STACK 
AND 
THE 
SINE 
BELOW. 
INITIATE 
THE FORWARD SPACING OF THE MAG TAPE ONE FILE AND WAIT 
FOR THE OPERATION TO COMPLETE. 
WRITES AN ENTIRE CORE IMAGE (32K WORDS) ONTO THE DISC IN BLOCKS 
2383 THROUGH 2447 (THE INNERMOST 
CYLINDERS 
OF 
THE 
REMOVABLE 
PLATTER). 
THIS CORE IMAGE MAY THEN BE RElOAOEC AT A LATER TIME 
USING THE WORD RECOVER. 
SOF, 
(A) 
THE 
ASSEMBLER MNEMONIC FOR THE VARIAN SOF INSTRUCTION (SET THE 
o VE R FL 0 W BIT). 
D-66 
Feb. 1979 

FORTH GLOSSARY 
! "# $ & ' ( ) *+ ,- • 10123456789: ; <2 > ? @A Z [ \ ] A _ 
SP 
SP 
<ADDRESS> 
SP AC E 
SPACES 
PUSHES 'JNTo THE STACK THE ADDRESS OF THE TOPMOST STACK VALUE. 
OUT?lJT A SINGLE SPACE TO THE CURRENT OUTPUT DEVICE (USUALLY THE 
OPERATOR'S TERMINAL>. 
<VALUE> 
SPACES 
OUTPUT A STRING 
OF 
SPACES 
(BLANKS) 
TO 
THE 
CURRENT 
OUTPUT 
DEVICE. THF NUMBER OF SPACES IS SPECIFIED BY <VALUE>. 
SORT 
<OW-VALUE> 
SORT 
<RESULT> 
COMPUTt THE SQUARE ROOT OF <DW-VALUE> AND LEAVE THE SINGLE-WORD 
RESUL T ON THE STACK. 
SRb 
(A) 
<ADDRESS> 
<VALUE> 
SRE, 
THE 
ASSEMBLER MNEMONIC FOR THE VARIAN SRE INSTRUCTION (SKIP IF 
REGISTER EQUAL). 
STA, 
(A) 
<ADDRESS> 
STA, 
THE 
ASS'=MBLER MNEMONIC FOR THE VARIAN 
STA 
INSTRUCnON 
(STORE 
THE A REGISTER IN MEMORY). 
STB, 
(A) 
<ADDRESS> 
STB, 
THE 
ASSEMBLER 
MNEMONIC 
FOR THE VARIAN STB INSTRuCTION (STORE 
THE B REGISTER IN MEMORY). 
STRX 
<VALUE> 
STRX 
STORE <VALUE> AT THE LOCATION ESTABLISHED BY THE PREVIOUS 
INTX 
DEFINITION. SEE INTX, RCLX AND P-VX. 
STX, 
(A) 
<ADDRESS> 
STX, 
THE 
ASSEMBLER 
MNEMONIC 
FOR THE VARIAN STX INSTRUCTION (STORE 
THE X REGISTER IN MEMORY). 
SUB, 
(A) 
<ADDRESS> 
SUB, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN SUB INSTRUCTION (SUBTRACT 
MEMORY FROM THE A REGISTER). 
SUBROUTINE 
SUBROUTINE 
<NAME> 
CREATES A DICTIONARY 
ENTRY 
FOR 
THE 
NAMED 
MACHINE 
LANGUAGE 
SUBROUTINE. 
ASSEMBLER BECOMES THE CONTEXT VOCABULARY. 
<NAME> 
BECOMES A VARIABLE WHICH CONTAINS THE SUBROUTINE ENTKY 
ADDRESS 
FOR USE WITH THE JMPM INSTRUCTION. 
THE RETURN ADDRESS WORD FJR 
THE 
JMPM 
INSTRUCTION 
IS 
INITIALIZED 
TO ZERO. 
THE SEQUENCE 
"SUBROUTINE <NAME> -1 DP+!" IS USED WHEN THE SUBROUTINE 
IS 
TO 
BE 
CALLED 
WITH 
THE JSR INSTRUCTION. 
IT IS VERY IMPORTANT TO 
REMEMBER 
THAT 
FORTH'S 
COMPILATION 
FLAG 
IS 
NOT 
SFT 
WHIL~ 
ASSEMBLING MACHINE CODE INSTRUCTIONS, THAT IS, FORTH REMAINS IrJ 
EXECUTION MODE. SEE RETURN. 
SWAP 
<VALUEl> 
<VALUE2> 
SWAP 
<VALUE2> 
<VALUE1> 
EXCHANGE 
THE TOP TWO VALUES ON THE STACK SO THAT <VALUE1> 
WIL~ 
BE 
THE TOP VALUE ON THE STACK AND <VALUE2> THE SECOND. 
Feb. 1979 
D-67" 

FORTH GLOSSARY 
T-H 
LQAD THE TAPt HANDLERS. SEE UTIL. 
T2D 
<BLOCK#> 
T20 
READ THE SPECIFIED BLOCK FROM TAPE TO DISK. 
THE TAPE MAP 
MUST 
BE 
CQ~STRUCTED BEFORE EXECUTING THIS WORD (SEE READ-MAP). 
SEE 
T-H. 
TAB, 
(A) 
TAPE 
THE ASSEMBLER MNEMONIC FOR THE VARIAN TAB INSTRUCTION (TRANSFER 
THE A REGISTER TO THE B REGISTER). 
SETS THE TAPE AS THE PRIMARY DEVICE. SEE T-H. 
TAPE-TO-DISK 
<START-BLOCK#> 
<END-BLOCK#> 
TAPE-TO-DISK 
FIRST ZERO ALL DISC BLOCKS IN THE SPECIFIED RANGE AND THEN COpy 
ALL BLOCKS IN THE RANGE FROM TAPE TO DISK. SEE T-H. 
TAX, 
(A) 
THE ASSEMBLER MNEMONIC FOR THE VARIAN TAX INSTRUCTION (TRANSFER 
THE A REGISTER TO THE X REGISTER). 
T8A, 
<A' 
THE ASSEMBLER MNEMONIC FOR THE VARIAN TBA INSTRUCTION (TRANSFER 
THE B REGISTER TO THE A REGISTER). 
TCH 
<CHAR-CODE> 
TCH 
TEMP 
TERMINAL 
TRANSMIT THE SPECIFIED ASCII CHARACTER CODE 
TO 
THE 
TERMINAL, 
REGARDLESS 
WHAT 
THE CURRENT OUTPUT DEVICE IS. 
SEE APPENDIX A 
FOR A LISTING OF THE ASCII CODES. SEE WCH. 
A VARIABLE USED FOR TEMPORARY 
STORAGE 
IN 
THE 
FLOATING-POINT 
ROUTINES. 
SELECT 
THE 
TERMINAL 
AS 
THE 
OUTPUT 
DEVICE, 
CANCELLING ANY 
PREVIOUS 
SELECTION 
OF 
THE 
PRINTER. 
THE 
TERMINAL 
IS 
AUTOMATICALLY 
SELECTED 
WHEN 
CONTROL 
IS RETURNED TO IT AFTER 
EXECUTING A LINE OF WORDS. SEE PRINTER. 
TERMINAL-ASK 
SETS AN 
<SASK, 
BUFFER. 
INTERNAL FLAG SO THAT THE NEXT USE OF THE ASKING 
WORDS 
DASK, 
FASK} WILL EXTRACT CHARACTERS FROM THE TERMINAL 
SEE BLOCK-ASK. 
TERMINAL-WORD (OLD) 
RENAMED TERMINAL-ASK. 
D-68 
Feb. 1979 

FURTH GLOSS AR Y 
! "# $£, • ( ) * +, -. 10123456789: ; < .. > ?@ A Z [ \ ) A _ 
TEX 
THEN 
THEN, 
TPABT 
TPlT 
TS A, 
n~ORD 
TYPE 
LOADS 
THE 
TE~MINAL EXCHANGE WORDS WHICH 
ALLOW 
Ot\lE 
TO 
SWITCH 
BETWEEN DIFFERENT TERMINAL DEVICES. SEE UTIL. 
(C 0- ~ P) 
TERMINATE AN IF-ELSE-THEN CONOITIONAL. SEE IF. 
( A) 
TERMINATE AN IF,-ELSE,-THEN, CONDITIONAL. SEE IF,. 
FORC ES A n?y" ABORT. 
<X-POSN> 
<Y-POXN> 
TPL T 
DRAWS 
A VECTOR 
ON 
THE 4010 FROM THE CURRENT POSITION TO THE 
SPECIFIED OFFSET FROM THE CURRENT POSITION AS GIVEN BY <X-POSN> 
AND <"(-POSN>. 
A DARK VECTOR IS THEN DRAWN BACK TO THE ORIGINAL 
POSITION. 
THE PARAMETERS TO THIS WORD 
ARE 
OFFSETS 
FROM 
THE 
CURR ENT 
POSITION 
AND 
NOT PHYSICAL COORDINATES. 
<X-POSN> AND 
<Y-PoSN> ARE SINGLE-WORD 
INTEGERS 
IN 
THE 
RANGE 
0-1023 
AND 
0-780. 
( A) 
THE ASSEMBLER MNEMONIC FOR THE VARIAN TSA INSTRUCTION (TRANSFER 
THE 
FRONT PANEL SWITCH SETTING TO THE A REGISTER). 
(OLD) 
REQUEST 
A LINE 
OF 
INPUT 
FROM 
THE 
TERMINAL. 
THE LINE IS 
TERMINATED BY A CARRIAGE RETURN AND THE FIRST WORD OF THE 
LINE 
IS 
THEN 
EXTRACTED 
AND PLACED IN MEMORY AT THE NEXT AVAILABLE 
DIe T ION A R Y L OC A T ION. 
( A ) 
THE ASSEMBLER MNEMONIC FOR THE VARIAN TXA INSTRUCTION (TRANSFER 
THE X REGISTER TO THE A REGISTER). 
<COUNT> 
TYPE 
OUTPUT A STRING OF CHARACTERS TO THE 
MUST 
CONTAIN 
THE 
BYTE-ADDRESS 
OF 
STRING AND 
<COUNT> 
SPECIFIES 
THE 
OUTPUT. SEE wRITE AND COUNT. 
OPERATOR'S 
TERMINAL. 
IP 
THE fIRST CHARACTER QF THE 
NUMBER 
OF 
CHARACTERS 
TO 
TZA, 
CA) 
THE ASSEMBLER MNEMONIC FOR THE VARIAN TZA INSTRUCTION (TRANSFER 
ZERO TO THE A REGISTER). 
TZB, 
CA) 
THE ASSEMBLER MNEMONIC FOR THE VARIAN TZB 
INSTRUCTIO~ (TRANSFER 
ZERO TO THE B REGISTER). 
Feb. 1979 
0-69 

FORTH GLOSSARY 
U. 
<VALUE> 
U. 
UNSIGNED 
OUTPUT. 
CONVERT 
<VALUE> 
ACCORDING 
TO THE CURRENT 
NUMBER BASE AND OUTPUT IT TO THE CURRENT OUTPUT DEVICE (USUALLY 
THE OPERATOR'S TERMINAL) 
AS 
A POSITIVE, 
UNSIGNED, 
16-8IT 
NUMBER. THE VARIABLE FLO SPECIFIES THE FIELD WIDTH. 
UNPK 
<OW-VALUE> 
UNPK 
<OW-RESULT> 
<OW-VALUE> 
IS 
ASSUMED TO BE A PACKED CAMAC 24-BIT VALUE WHICH 
IS UNPACKED TO YIELD A VARIAN DOUBLE-WORD INTEGER. SEE PACK. 
UNSAVER, (A) 
UPDATE 
US 
USER 
UTIL 
A WORD WHICH WILL RESTORE THE SYSTEM STATUS THAT WAS 
SAVED 
BY 
THE SUBROUTINE SAVER. THIS WORD MUST BE FOLLOWED BY THE 
MACHI~E 
CODE 
REQUIRED 
TO 
RESTORE 
THE 
B REGISTER AND RETURN FROM AN 
INTERRUPT. 
FLAG THE MOST RECENTLY REFERENCED BLOCK AS UPDATED. 
THE 
BLOCK 
WILL 
SUBSEQUENTLY BE TRANSFERRED AUTOMATICAllY TO DISC OR TAPE 
SHOULD ITS BUFFER BE REQUIRED FOR THE STORAGE 
OF 
A DIFFERENT 
BLOCK. SEE FLUSH. 
PUTS THE 4010 IN ALPHA MODE. SEE GS. 
LOAD 
ADDITIONAL 
WORDS 
INTO 
THE 
DICTIONARY, 
NOTABLY 
THE 
DOUBLE-WORD INTEGER WORDS, 
THE FLOATING-POINT 
WORDS 
AND 
THE 
CAMAC WORDS. 
DEFINES THE FOLLOWING LOADER WORDS (REFER TO THE DESCRIPTION OF 
EACH WORD FOR FURTHER INFORMATION): 
BRACKET, 
D-H, 
DISKO, FORMATTER, NEWTAPE, PRINTERS, 
REDEF, T-H, TEX, ZERODISK. 
UTILITIES (OLD) 
RENAMED UTIle 
D-70 
Feb. 1979 

FORTH GLOSSARY 
VARIABLE 
<VALUE> 
VARIABLE 
<NAME> 
VCHECK 
VLIST 
DEFINE 
A 
WORD 
<NAME> 
WHICH, 
WHEN EXECUTED, 
wILL PUSH TrlE 
ADDRESS OF THE VARIABLE'S VALUE ONTO THE STACK. 
THE 
VALUE 
OF 
THE VARIABLE IS INITIALIZED TO <VALUE>. THE SEQUENCE "<NAME> 
~" 
PUSHES 
THE 
VARIABLE'S 
CURRENT 
VALUE 
ONTO THE STACK AND THE 
SEQUENCE "<VALUE> <NAME> !" STORES A NEW VALUE IN THE 
VA~IABLE. 
PRINTS SOME RELEVANT INFORMATION 
CONCERNING 
ALL 
VOCABULARIES 
(WHAT 
WORD 
IS THE HEAD OF THE VOCABULARY, 
WHICH VOCABULARIES 
ARE CHAINED TO OTHERS, ETC.). 
START LISTING THE DICTIONARY, 
BEGINNING AT 
THE 
HEAD 
OF 
THE 
CONTEXT VOCABULARY. 
THE LISTING MAY 
BE STOPPED BY PRESSING ANY 
TERMINAL KEY. 
VOCABULARY (E) 
VnCABLUARY 
<NAME> 
DEFINE 
A VOCABULARY 
WITH 
THE 
SPECIFIED 
NAME. 
EXECUTION OF <NAME> WILL MAKE <NAME> 
THE 
CONTEXT 
THE 
$~QUENCE "<NAME> DEFINITIONS" WILL MAKE <NAME> 
VOCABULARY, INTO WHICH DEFINITIONS WILL 
BE PLACED. 
SUBSEQUENT 
VOCABULARY. 
THE CURRENT 
w.D 
<FIELD-WIDTH> 
<#DIGITS> 
W.D 
SPECIFY BOTH THE TOTAL FIELD WIDTH AND NUMBER OF DIGITS TO 
THE 
RIGHT 
OF THE DECIMAL POINT FOR PRINTING FLOATING-POINT NUMBERS 
USING 
THE 
WORDS 
E. 
AND 
F.. 
THESE 
VALUES 
ARE 
STnRED 
INDEPENDENTLY OF THE VARIABLES FLO AND OPL, 
HOWEVER, EACH TIME 
EITHER 
E. 
OR 
F. 
IS EXECUTED THE VALUES OF FLO AND DPl wILL 
CHANGE. 
STORING NEW VALUES IN FLO AND DPL DOES NOT AFFECT 
THE 
FLOATING-POINT 
FIELD SPECIFICATIONS. 
THE DEFAULT VALUES ARE A 
FIELD WIDTH OF 14 AND 4 DIGITS TO 
THE 
RIGHT 
OF 
THE 
DECIMAL 
POINT. 
WAIT 
(A) 
THE 
ADDRESS 
OF 
A SUBROUTINE WHICH SHOULD BE USED WHENEVER A 
PROGRAM MUST WAIT FOR ANY FORM OF 1/0. USER SWAPPING IS DONE IN 
WAIT. THIS SUBROUTINE MUST BE CALLED BY A JMPM INSTRUCTION. 
WCH 
<CHAR-CODE> 
WCH 
Feb. 1979 
OUTPUT THE SPECIFIED ASCII CHARACTER CODE TC THE CURRENT OUTPUT 
DEVICE (USUALLY THE OPERATOR'S TERMINAL). 
SEE APPENDIX A FOR A 
LISTING OF THE ASCII CODES. SEE TCH. 
D-71 

wF 
WG 
WGAP 
WHERE 
WHILE 
WINIT 
WORD 
WORDIN 
WR ITE 
D-72 
FORTH GLOSSARY 
INITIATES THE WRITING OF AN END-OF-FILE ON 
THE 
MAG 
TAPE 
AND 
RETURNS IMMEDIATELY. SEe ENDFILE. 
INITIATES 
THE 
WRITING 
OF 
A THREE 
INCH GAP ON THE MAG TAPE 
(REFER~ED TO AS ERASING THE TAPE) 
AND RETURNS IMMEDIATELY. 
SEE 
WG AP. 
INITIATE THE WRITING OF A THREE 
INCH 
GAP 
ON 
THE 
MAG 
TAPE 
(REFERRED 
TO 
AS 
ERASING) 
AND 
WAIT 
FOR 
THE 
OPERATION 
TO 
COMPLETE. SEE WG. 
OUTPUT INFORMATION ABOUT THE STATUS OF 
FORTH. 
THIS 
WORD 
IS 
USUALLY 
EXECUTED 
AFTER 
AN ERROR ABORT TO DETERMINE WHERE THE 
SYSTEM WAS (LAST WORD COMPILED AND LAST 
BLOCK 
ACCESSEO) 
WHEN 
THE ERROR OCCURED. 
(C2+,P) 
<LOGICAL-VALUE> 
WHILE 
TEST 
THE 
<LOGICAL-VALUE> 
AND 
IF 
FALSE, 
EXIT 
OUT 
OF 
A 
BEGIN-WHILE-REPEAT LOOP IMMEDIATELY. SEE BEGIN. 
INITIALIZE THE wORD 
REPLACEMENT 
ARRAY. 
THIS 
WORD 
MUST 
BE 
EXECUTED PRIOR TO A SERIES OF REPLACE AND/OR $REPLACE. SEE FIX, 
REPLACE AND $REPLACE. 
<CHAR-CODE> 
WORD 
READ THE NEXT WORD FROM THE INPUT STRING BEING INTERPRETED. THE 
WORD 
IS 
TERMINATED 
BY 
THE 
SPECIFIED 
<CHAR-CODE> 
AS 
THE 
DELIMITER (FORTH USUALLY SPECIFIES 
A 
BLANK 
AS 
A DELIMITER, 
ALTHOUGH 
ANY 
ASCII 
CHARACTER 
MAY BE SPECIFIED). 
THE PACKED 
CHARACTER STRING IS STORED IN THE DICTIONARY, 
BEGINNING AT THE 
NEXT AVAILABLE LOCATION (SEE THE WORD HERE) WITH THE 
CHARACTER 
COUNT IN THE FIRST BYTE. 
WORDIN 
<ADDRESS> 
REQUEST 
A 
WORD 
FROM 
THE 
TERMINAL. 
A STRING OF CHARACTERS 
TERMINATED BY A CARRIAGE RETURN IS READ IN 
FROM 
THE 
TERMINAL 
AND 
THE 
FIRST 
WORD (ALL CHARACTERS UP TO THE FIRST BLANK) IS 
STORED IN 
THE 
NEXT 
AVAILABLE 
DICTIONARY 
LOCATION 
AND 
ITS 
ADDRESS IS RETURNED ON THE STACK. 
<COUNT> 
WRITE 
OUTPUT 
A STRING 
OF 
CHARACTERS 
TO THE CURRENT OUTPUT DEVICE 
(USUALLY 
THE 
OPERATOR'S 
TERMINAL). 
IP 
MUST 
CONTAIN 
THE 
BYTE-ADDRESS 
OF 
THE FIRST CHARACTER OF THE STRING AND <COUNT> 
SPECIFIES THE NUMBER OF CHARACTERS TO OUTPUT. THIS WORD DIFFERS 
FROM TYPE IN THAT WRITE 
WILL 
OUTPUT 
TO 
THE 
CURRENT 
OUTPUT 
DEVICE 
(WHICH MAY OR MAY NOT BE THE OPERATOR'S TERMINAL) WHILE 
TYPE WILL OUTPUT ONLY TO THE OPERATOR'S TERMINAL. SEE COUNT. 
Feb. 1979 

FORTH GLOSSARY 
x ) 
XOR 
XY4010 
ZAP 
( A ) 
SETS THE VARIABLE MODE TO 5, 
REGISTER 
FOR THE NEXT MEMORY 
FORTH KEEPS THE CURRENT STACK 
SPECIFYING 
INDEXING 
OFF 
THE 
X 
REFERENCE INSTRUCTION. 
NOTE THAT 
POINTER IN THE X REGISTER. 
(A) 
<ADDRESS> 
<JUMP-CONDITION> 
XIF, 
THE ASSEMBLER MNEMONIC FOR THE VARIAN XIF INSTRUCTION 
(EXECUTE 
THE INSTRUCTION AT <ADDRESS> IF THE CONDITION IS TRUE). 
<VALUEl> 
<VALUE2> 
XOR 
<RESULT> 
FORM THE BITWISE LOGICAL EXCLUSIVE-OR OF <VALUEl> AND <VALUE2>, 
LEAVING THE RESULT ON THE STACK. 
<X-POSN> 
<Y-POSN> 
XY4010 
DRAWS 
A VECTOR ON THE 4010 TO THE PHYSICAL LOCATION SPECIFIED 
BY <X-POSN> AND <Y-POSN>. <X-POSN> AND <Y-POSN> ARE 
SINGLE-W~RD 
INTEGERS IN THE RANGE 0-1023 AND 0-780. 
DELETE THE ENTIRE DICTIONARY, 
RESET ALL INTERNAL POINTERS 
AND 
FLAGS, RELOAD BASIC FORTH (BLOCK 8) INTO THE DICTIONARY. 
ZERODISK 
<START-BLOCK#> 
<END-BLOCK#> 
ZERODISK 
ZEROES THE SPECIFIED RANGE OF BLOCKS ON THE DISK. SEE UTIL. SEE 
DISKO. 
[ 
( P ) 
[P J 
J 
STOP 
COMPILATION. 
THE 
wORDS FOLLOWING THE LEFT BRACKET IN A 
COLON DEFINITION ARE EXECUTED, NOT COMPILED. SEE 1. 
SET 
TH~ PRECEDENT BIT OF THE NEXT WORD DEFINED SO THAT THE WORD 
IS A COMPILER DIRECTIVE. 
RESUME COMPILATION. 
THE FOLLOWING WORDS IN A COLON 
DEFINITION 
ARE COMPILED, NOT EXECUTED. SEE (. 
Feb. 1979 
0-73 

FORTH GLOSSARY 
SINGLE-WORD INTEGER ARITHMETIC WORDS 
----------- ------- ---------- -----
* 
** 
*1 
+ 
I 
IMOD 
ABS 
MAX 
MIN 
t"11 NUS 
MOD 
DOUBLE-WORD INTEGER ARITHMETIC WORDS 
----------- ------- ---------- -----
ASHIFT 
0*1 
D+ 
0-
DABS 
DMINUS 
SORT 
MIXED-PRECISION INTEGER ARITHMETIC WORDS 
2M* 
M* 
M+ 
MI 
M/MOD 
D-74 
Feb. 1979 

FORTH GLOSSARY 
FLOATING-POINT ARITHMETIC WORDS 
*10** 
F* 
F+ 
F-
FI 
F2LOG 
F2 X P 
FABS 
FDATN 
FOCO S 
FOSIN 
FD TAN 
FEXP 
FEXPIO 
FLN 
FLOG 
FMAX 
FMIN 
FMINUS 
FRATN 
FSQRT 
14-BIT FRACTION ARITHMETIC WORDS 
*, 
I, 
Rl-2 
RS.C 
SIN.COS 
DOUBLE-WORD FRACTION ARITHMETIC WORDS 
0* 
01 
NUMERIC 
-------
.FIX 
.FLOAT 
OFIX 
DFLOAT 
SFIX 
SFLOAT 
Feb. 1979 
CONVERSION 
----------
FLOATING-POINT 
-> 
DW-FRACTION 
-> 
FLOATING-POINT 
-> 
OW-INTEGER 
-> 
FL OAT I NG-POI NT 
-> 
SW-INTEGER 
-> 
OW-F RAC TI ON 
FLOATING-POINT 
OW-INTEGER 
FLOATING-POINT 
SW-INTEGE R 
F LOATING- POIN T 
0-75 

FORTH GLOSSARY 
SINGLE-WORD LOGICAL OPERATORS 
AND 
COM 
MINUS 
OR 
XOR 
ONES COMPLEMENT 
TWOS COMPLEMENT 
INCLUSIVE-OR 
EXCLUSIVE-OR 
SINGLE-WORD 
STAC~ OPEARTORS 
DROP 
OUP 
LS 
NOROP 
OVER 
PICK 
ROLL 
ROT 
SWAP 
2-WORO 
------
2DROP 
20UP 
2LS 
20VER 
2PICK 
?ROLL 
2ROT 
2SWAP 
3-WOPO 
------
30ROP 
3DUP 
3 OVE R 
3PICK 
3ROLL 
3ROT 
3SWAP 
D-76 
ST AC K OPEARTORS 
----- ---------
ST ACK OPERATORS 
----- ---------
!"#$&' ()*+,-./0123456789: ;<->?@AZ(\]"_ 
Feb. 1979 

FORTH GLOSSARY 
!"#$&'()*+,-./0123456789:;<.>?@AZ(\)~_ 
NUMERIC OUTPUT WORDS 
SINGLE-WORD INTEGER, FREE FORMAT 
? 
SINGLI:-WORD INTEGER, FREE FO RM AT 
B. 
SINGLE-WORD INTEGER, BINARY 
D. 
DOUBLE-WORD INTEGER 
E. 
FLOATING-POINT WITH EXPONENT 
E? 
FLOATING-POINT WITH EXPONENT 
F. 
FLOATING-POINT WITHOUT EXPONENT 
F? 
FLOATING-POINT WITHOUT EXPONENT 
G. 
GENERALIZED FLOATING-POINT 
G? 
GENERALIZED FLOATING-POINT 
H. 
SINGLE-WORD INTEGER, HEXADECIMAL 
I • 
SING LE-WORD INTEGER 
N. 
SINGLE-WORD INTEGER 
o. 
SINGLE-WORD INTEGER, OCTAL 
S .• 
SINGLE-WORD INTEGER 
U. 
SINGLE-WORD INTEGER, UNSIGNED 
COLON DEFINITION CONTROL 
+LOOP 
BEGIN 
CASE 
DO 
ELSE 
END 
IF 
I 
I ' 
J 
K 
LEAVE 
LOOP 
REPEAT 
THEN 
WHIL E 
MACHINE CODE CONTROL 
BEGIN, 
EL S E , 
END, 
IF, 
THEN, 
Feb. 1979 
D-77 

FORTH GLOSSARY 
DIRECT MAG-TAPE 
WORDS (7-TRACK) 
>BCD 
?EOF 
?MTREADY 
BK 
BK SP 
ENDFILE 
FW 
FWSP 
LWA? 
MTPERR 
MTR 
MTREAD 
MTREJ 
MTW 
MTWAIT 
MTWRITE 
OFFLINE 
PEW 
RW 
SKIPF 
TPABT 
WF 
wG 
WGAP 
D-78 
FLAG FOR BCD OR BINARY MODE 
TEST FOR END-OF-FILE 
TEST FOR READY 
INITIATE BACK SPACE RECORD 
BACK SPACE RECORD AND WAIT 
WRITE 
AN EOF AND WAIT 
INITIATE A FORWARD SPACE RECORD 
FORWARD SPACE RECORD AND WAIT 
READ IN FINAL DHA ADDRESS 
TEST FOR PARITY ERROR 
INITIATE A READ 
READ AND WAIT 
TEST FOR REJECT 
INITIATE A WRITE 
WAIT fOR READY 
101 RITE A NO 
lolA IT 
TURN THE DRIVE OFFLINE 
REWIND AND WAIT 
INITIATE A REWIND 
SKIP ONE FILE AND WAIT 
FORCE A "1Y" ABORT 
INITIATE THE WRITING OF AN EOF 
INITIATE THE WRITING OF A GAP 
WRITE A GAP AND WAIT 
Feb. 1979 

