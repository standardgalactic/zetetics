arXiv:2301.10624v1  [cs.IT]  25 Jan 2023
JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
1
Energy-Delay Tradeoff in Helper-Assisted
NOMA-MEC Systems: A Four-Sided Matching
Algorithm
Mengmeng Ren, Long Yang, Hai Jiang, Jian Chen, and Yuchen Zhou
Abstract—This paper designs a helper-assisted resource al-
location strategy in non-orthogonal multiple access (NOMA)-
enabled mobile edge computing (MEC) systems, in order to
guarantee the quality of service (QoS) of the energy/delay-
sensitive user equipments (UEs). To achieve a tradeoff between
the energy consumption and the delay, we introduce a novel
performance metric, called energy-delay tradeoff, which is deﬁned
as the weighted sum of energy consumption and delay. The joint
optimization of user association, resource block (RB) assignment,
power allocation, task assignment, and computation resource al-
location is formulated as a mixed-integer nonlinear programming
problem with the aim of minimizing the maximal energy-delay
tradeoff. Due to the non-convexity of the formulated problem
with coupled and 0-1 variables, this problem cannot be directly
solved with polynomial complexity. To tackle this challenge, we
ﬁrst decouple the formulated problem into a power allocation,
task assignment and computation resource allocation (PATACRA)
subproblem. Then, with the solution obtained from the PATACRA
subproblem, we equivalently reformulate the original problem as
a discrete user association and RB assignment (DUARA) problem.
For the PATACRA subproblem, an iterative parametric convex
approximation (IPCA) algorithm is proposed. Then, based on
the solution obtained from the PATACRA subproblem, we ﬁrst
model the DUARA problem as a four-sided matching problem,
and then propose a low-complexity four-sided UE-RB-helper-
server matching (FS-URHSM) algorithm. Theoretical analysis
demonstrates that the proposed algorithms are guaranteed to
converge to stable solutions with polynomial complexity. Finally,
simulation results are provided to show the superior performance
of our proposed algorithm in terms of the energy consumption
and the delay.
Index Terms—Mobile edge computing, non-orthogonal multi-
ple access, user association, resource allocation.
I. INTRODUCTION
D
RIVEN by the proliferation of ﬁfth generation (5G) and
beyond networks, a variety of intelligent applications
and services have emerged, coexisting with a large num-
ber of delay-sensitive and computation-sensitive tasks [2]–
[4]. As a result, users may face great challenges in com-
putation/processing capability due to their limited computa-
tion/storage resources and battery capacity. Conventionally,
mobile cloud computing (MCC) is a promising technology to
serve resource-constrained users by using abundant computa-
tion resources deployed at central cloud servers [5]. However,
This paper was partially presented at the IEEE WCNC 2021 [1].
M. Ren, L. Yang, J. Chen, and Y. Zhou are with the State Key Laboratory
of
Integrated
Services
Networks,
Xidian
University,
Xi’an
710071,
China
(e-mail:
renmengmeng@stu.xidian.edu.cn;
lyang@xidian.edu.cn;
jianchen@mail.xidian.edu.cn; ychenzhou@163.com).
H. Jiang is with the Department of Electrical and Computer Engineer-
ing, University of Alberta, Edmonton, AB T6G 1H9, Canada (e-mail:
hai1@ualberta.ca).
as the central cloud is generally distant from users, MCC may
incur excessive delay due to the long-distance transmission
over backhaul/core-networks. To tackle this issue, mobile edge
computing (MEC) has been proposed to provide cloud-like
services by deploying servers at the network edge, called MEC
servers, with which multiple resource-constrained users will be
able to wirelessly ofﬂoad their tasks to MEC servers in close
proximity [6]–[8]. Therefore, assisted by proximate servers,
resource-constrained users can ofﬂoad and complete tasks with
much lower delay than the counterpart in MCC [9].
In MEC systems, according to the separability of tasks,
the task ofﬂoading can be classiﬁed into two categories:
inseparable task ofﬂoading [10]–[12] and separable task of-
ﬂoading [13], [14]. In the inseparable task ofﬂoading, each
user attempts to ofﬂoad the entire task to the MEC server.
Speciﬁcally, recent works investigated on the communication
and computation resources allocation to minimize the task
completion delay [10], [11] or maximize the computation rate
[12]. In [10], two algorithms based on Dinkelbach’s and New-
ton’s methods were proposed to minimize the overall delay
for two-user systems supported by a MEC server. Further,
for multi-server MEC systems, the overall delay of all users
was minimized by jointly optimizing the user association and
resource allocation [11]. Moreover, under the delay constraint,
the weighted sum computation rate of all users was maximized
by a proposed iterative algorithm [12]. In the separable task
ofﬂoading, each user ofﬂoads several portions of the task to
the servers while locally executing the remaining portion, in
order to fully utilize the local computation resource of users
and relief the burden of task ofﬂoading. For users supported
by single server, an enhanced online Lyapunov optimization
algorithm was proposed to maximize the long-term average
data rate [13]. Further, for users supported by multiple servers,
the long-term energy consumption of all users was minimized
by an enhanced deep reinforcement learning approach [14].
All aforementioned works [10]–[14] focused on enhancing
the performance of task ofﬂoading by properly utilizing the
inherent computation/communication resources offered by the
users/MEC servers. In fact, due to the burst nature of users’
trafﬁcs, each user is very likely to be surrounded by some idle-
state users with spare computation/communication resources,
especially in practical 5G and its beyond systems that support
massive users. Thus, if recruiting those idle-state users as
helpers to assist the task ofﬂoading/execution, the performance
of task ofﬂoading can be further improved by utilizing the
spare resources offered by idle-state users. Inspired by this
fact, the helper-assisted MEC has been investigated with using
the orthogonal multiple access (OMA)-enabled ofﬂoading, i.e.,

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
2
helper-assisted OMA-MEC [15]–[18]. In [15], a heuristic task
assignment scheme was proposed to minimize the overall
delay, with which a typical user sequentially ofﬂoads tasks to
multiple helpers via time-division multiple access (TDMA).
On the other hand, by employing frequency-division multiple
access (FDMA) for task ofﬂoading, the number of served
users was maximized in [16], where each user occupies
two subchannels for ofﬂoading to the MEC server and the
helper, respectively. Further, with the integration of TDMA
and FDMA, the work in [17] and [18] investigated hybrid
TDMA/FDMA ofﬂoading schemes to minimize the energy
consumption. Speciﬁcally, a helper-assisted ofﬂoading scheme
was proposed in [17], with which users ofﬂoad tasks to the
MEC server assisted by a selected helper. Likewise, a two-level
alternative method was proposed to jointly optimize the of-
ﬂoading decision, computation and communication resources
allocation [18].
In practice, since helpers may be geographically closer to
users than MEC servers, they can easily form a near-far effect
with MEC servers, thus naturally providing possibility for
implementing the non-orthogonal multiple access (NOMA)-
enabled task ofﬂoading. Inspired by this, the NOMA tech-
nique can be integrated into the helper-assisted MEC, termed
as helper-assisted NOMA-MEC. Speciﬁcally, each user can
simultaneously ofﬂoad subtasks to the helpers and the MEC
servers by using power-domain multiplexing. Compared with
the helper-assisted OMA-MEC, the helper-assisted NOMA-
MEC can achieve higher spectral efﬁciency and lower of-
ﬂoading/computing delay [15]–[18]. More recently, the helper-
assisted NOMA-MEC has been investigated with using a
single helper [20], [21] or multiple helpers [22], [23]. For the
single-user NOMA-MEC assisted by only one helper, the min-
imization of energy consumption was investigated in [20] and
[21]. In [20], an alternative iterative algorithm was proposed to
jointly optimize the delay, task splitting, and power allocation.
As an extension of [20], the computation frequencies of the
user and the helper were further jointly optimized in [21].
When multiple helpers are available, an interior-point-based
algorithm was proposed in [22] to maximize the ofﬂoading
data of one task-driven user. In [23], an adaptive computing
strategy with a helper scheduling scheme was proposed, in
which one helper is adaptively scheduled from multiple helpers
to assist task ofﬂoading.
From above works [20]–[23] on the helper-assisted NOMA-
MEC, it can be observed that the helper-assisted task of-
ﬂoading was investigated for only a typical user. However, in
multiuser NOMA-MEC systems, it is very likely that some
active users require computing services at the same time,
indicating that their tasks need to be ofﬂoaded/executed simul-
taneously. In this situation, how to fairly serve them is still an
open issue for the helper-assisted NOMA-MEC. Moreover, in
practical multiuser MEC systems driven by LTE/5G, multiple
orthogonal time-frequency resource blocks (RBs) are assigned
to different users, indicating that an appropriate RB allocation
can further improve the performance of ofﬂoading and com-
putation. Note that existing works [15]–[17] on helper-assisted
OMA-MEC mainly investigated the association between users
and servers. Therefore, how to jointly optimize the allocation of
RBs and the association among users, helpers, and servers to
improve the computation performance is also uninvestigated.
Motivated by the above observations, this paper develops
a novel paradigm for multi-helper assisted NOMA ofﬂoading.
To achieve a tradeoff between the energy consumption and the
delay, we introduce a novel performance metric, called energy-
delay tradeoff (EDT), which is deﬁned as the weighted sum of
the energy consumption and the delay. Then, from the perspec-
tive of min-max fairness, we formulate the joint optimization
of user association, RB assignment, power allocation, task
assignment, and computation resource allocation to minimize
the maximal EDT (mEDT) among user equipments (UEs).
Since the formulated problem is a mixed-integer nonlinear
programming (MINLP) problem with coupled discrete and
continuous variables, it is challenging to design an algorithm
with low complexity and low performance loss. The main
contributions of this paper are summarized as follows.
• Equivalent problem transformation scheme: We design an
equivalent transformation scheme to solve the formulated
MINLP problem. Speciﬁcally, under the condition of
given user association and RB assignment (UARA), the
original problem will be reduced to a subproblem with
only continuous variables (i.e., power allocation, task
assignment, and computation resource allocation), called
PATACRA subproblem. Then, regarding the continuous
variables as functions of the UARA, we equivalently
reformulate the original problem as a discrete UARA
(DUARA) problem.
• Alternating-free iteration algorithm for PATACRA sub-
problem: For the non-convex PATACRA subproblem, we
introduce auxiliary variables to transform it into a form
that can be approximated appropriately, and propose an
iterative parametric convex approximation (IPCA) algo-
rithm. Unlike existing alternating-based algorithms [24],
[25] that require further decomposition of the non-convex
problem, the proposed IPCA algorithm can be directly
applied to the non-convex PATACRA subproblem with
low complexity.
• Novel four-sided matching algorithm for DUARA prob-
lem: For the non-convex DUARA problem, we ﬁrst
model it as a four-sided matching problem with the aim
of ﬁnding the best matching with the highest objec-
tive value. To solve this matching problem, we propose
a novel four-sided UE-RB-helper-server matching (FS-
URHSM) algorithm, where a sequential swap operation
and a leaving and joining-in operation are designed.
Unlike conventional deferred-acceptance/swap-operation
based algorithms [26]–[28] that are only feasible for
two/three-sided matching problems, our proposed FS-
URHSM algorithm can efﬁciently generate a feasible and
stable four-sided matching.
•
Convergence and stability analysis:
To demonstrate
the convergence of the proposed FS-URHSM algorithm,
we ﬁrst prove that the proposed IPCA algorithm will
converge to a stationary point. Then, based on the con-
vergence of the IPCA algorithm, we theoretically show
that the FS-URHSM algorithm is guaranteed to converge

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
3
to a stable matching with polynomial complexity, which
is much less than the exponential complexity required by
exhaustively searching all possible matching conditions.
The rest of this paper is organized as follows. Section II
describes the helper-assisted NOMA-MEC system, along with
the helper-assisted ofﬂoading model and the task computing
model. Section III formulates the joint optimization problem
to minimize the mEDT, and equivalently reformulates the orig-
inal problem as a DUARA problem. Section IV proposes the
IPCA algorithm to solve the PATACRA subproblem and ana-
lyzes the convergence and complexity. To solve the DUARA
problem, Section V models this problem as a four-sided
matching problem and proposes a FS-URHSM algorithm.
Then, the convergence and complexity are analyzed. Section
VI illustrates the numerical results, followed by Section VII
concludes this paper.
II. SYSTEM MODEL
In this section, we ﬁrst introduce the helper-assisted
NOMA-MEC system, and then describe the helper-assisted
ofﬂoading model and the task computing model.
A. Helper-Assisted NOMA-MEC System
As shown in Fig. 1, we consider a helper-assisted NOMA-
MEC system consisting of N task-driven UEs, M active MEC
helpers, and K MEC servers. Let Un (n ∈N ≜{1, . . . , N}),
Hm (m ∈M ≜{1, . . . , M}) and Sk (k ∈K ≜{1, . . . , K})
denote the sets of UEs, helpers, and servers, respectively. We
assume that each UE, say Un, has a task to be executed,
represented by Ln ≜{Dn, In, T max
n
, ωE
n , ωT
n }, where Dn
denotes the input data size of the task, In represents the
computation intensity of the task (i.e., the required CPU cycles
for computing 1-bit data), T max
n
denotes the maximum delay
tolerance, ωE
n and ωT
n represent the weight factors to measure
the energy consumption and delay sensitivity with satisfying
ωE
n + ωT
n = 1, respectively. Since the decoding complexity
of the successive interference cancellation (SIC) technique in
practical downlink NOMA systems will exponentially increase
with the number of the receivers (i.e., helpers/servers) [19],
[29], we assume that each UE is associated with one server
and one helper to ofﬂoad subtasks by employing downlink
NOMA. Let xn,k denote the association indicator among UEs
and servers, where xn,k = 1 represents that server Sk is
associated with UE Un; otherwise, xn,k = 0. We assume that
each server serves at most N max
k
UEs, which is expressed as
N
X
n=1
xn,k ≤N max
k
, ∀k ∈K.
(1)
Each UE is served by one server, which is expressed as
K
X
k=1
xn,k = 1, ∀n ∈N.
(2)
Let yn,m denote the association indicator among UEs and
helpers, where yn,m
=
1 represents that helper Hm is
MEC server
MEC helper
UE
Task offloading
...
Fig. 1. Helper-assisted NOMA-MEC system.
associated with UE Un; otherwise, yn,m = 0. We assume that
each helper only serves at most one UE, expressed as
N
X
n=1
yn,m ≤1, ∀m ∈M.
(3)
Each UE is served by one MEC helper, and the association
variables are constrained by
M
X
m=1
yn,m = 1, ∀n ∈N.
(4)
Moreover, to avoid the inter-UE interference, we assume that
UEs occupy the orthogonal RBs for task ofﬂoading. More
speciﬁcally, the available spectrum is divided into L (L ≥N)
orthogonal RBs, denoted by RBl, l ∈L ≜{1, . . ., L}. Let
zn,l denote the RB assignment indicator, where zn,l = 1
denotes that UE Un is matched to RB RBl; otherwise,
zn,l = 0. Practically, each UE can be allocated to one RB,
which is expressed as
L
X
l=1
zn,l = 1,∀n ∈N.
(5)
Each RB is allocated to at most one UE, which is constrained
by
N
X
n=1
zn,l ≤1,∀k ∈L.
(6)
With the above constraints of user association (1)∼(4) and
RB allocation (5) and (6), for each UE (called Un), it will be
assigned to a helper, a server, and an RB, which can be denoted
as Hm, Sk, and RBl, respectively. Before task ofﬂoading, UE
Un will divide task Ln into three subtasks: 1) subtask ϕH
n
with ηH
n Dn bits; 2) subtask ϕS
n with ηS
nDn bits; 3) subtask ϕL
n
with (1 −ηH
n −ηS
n)Dn bits, where ηH
n and ηS
n denote the task
splitting coefﬁcients for helper Hm and server Sk, respectively.
The task splitting coefﬁcient satisﬁes 0 ≤ηH
n , ηS
n ≤1 and
ηH
n + ηS
n ≤1 (∀n ∈N). After the task is divided, UE Un
will ofﬂoad subtasks ϕH
n and ϕS
n to associated helper Hm and
server Sk by employing the downlink NOMA, while executing
subtask ϕL
n locally during this ofﬂoading phase. Then, after
successfully decoding the desired subtasks, MEC helper Hm
and server Sk will execute the decoded subtasks. Since the
computing results only include a few bits, it is reasonable to
assume that the duration of the result downloading is negligible

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
4
[19], [30]. Therefore, we generally pay more attention to the
design of optimization strategies from the perspective of users.
Note that the details of the helper-assisted ofﬂoading model
and the task computing model are described as follows.
B. Helper-Assisted Ofﬂoading Model
In the considered system, all the UEs/helpers/servers are
equipped with a single antenna and operate in half duplex
mode. Without loss of generality, we assume that all the
wireless channels experience independent but non-identically
Rayleigh block-fading distribution, which means that the chan-
nel gains remain unchanged in one transmission block but may
vary independently over different blocks [31]. The channel
gains of links from UE Un to MEC helper Hm and server
Sk over RB RBl can be denoted as |hH
n,m,l|2 and |hS
n,k,l|2,
respectively. Following the same assumption in [19]–[22], we
assume that SIC can be perfectly performed when imple-
menting the downlink NOMA. Considering the relationship
between channel gains |hH
n,m,l|2 and |hS
n,k,l|2, the decoding
order at the helper and the MEC server can be classiﬁed into
the following two cases: 1) If |hH
n,m,l|2 ≥|hS
n,k,l|2, helper Hm
can use the SIC technology to eliminate subtask ϕS
n that sent
to the server, and then decode its desired subtask ϕH
n . At this
point, server Sk will decode subtask ϕS
n with regarding ϕH
n
as the interference. 2) If |hH
n,m,l|2 < |hS
n,k,l|2, server Sk will
decode ϕS
n after subtracting ϕH
n , while helper Hm will decode
ϕH
n with regarding ϕS
n as the interference. Therefore, helper
Hm will decode subtask ϕH
n with the following data rate
rH
n,m,l = B log2(1 +
pH
n gH
n,m,l
On,k,m,lpSngH
n,m,l + 1),
(7)
where gH
n,m,l
≜
|hH
n,m,l|2/σ2, σ2 is the additive white
Gaussian noise (AWGN) power, B is the bandwidth of RB
RBl, pH
n denotes the transmit power of UE Un for helper
Hm, and On,k,m,l = 0 if |hH
n,m,l|2 ≥|hS
n,k,l|2, otherwise
On,k,m,l = 1. According to this data rate, the transmission
delay of ofﬂoading subtask ϕH
n is given by
τ tran-H
n
≜
ηH
n Dn
M
P
m=1
L
P
l=1
yn,mzn,lrH
n,m,l
.
(8)
Likewise, the data rate for server Sk to decode subtask ϕS
n is
given by
rS
n,k,l = B log2
 1 +
pS
ngS
n,k,l
(1 −On,k,m,l)pH
n gS
n,k,l + 1

,
(9)
where gS
n,k,l ≜|hS
n,k,l|2/σ2, and pS
n is the transmit power of
UE Un for server Sk. Hence, the transmission delay for server
Sk to receive subtask ϕS
n is given by
τ tran-S
n
≜
ηS
nDn
K
P
k=1
L
P
l=1
xn,kzn,lrS
n,k,l
.
(10)
To efﬁciently utilize the spectrum resources, pure NOMA is
emplyed for task ofﬂoading. Therefore, the transmission delays
from UE Un to helper Hm and MEC server Sk satisfy
τ tran-H
n
= τ tran-S
n
, ∀n ∈N,
(11)
and the transmission energy consumed by UE Un is given by
etran
n
= pH
n τ tran-S
n
+ pS
nτ tran-H
n
.
(12)
C. Task Computing Model
1) Computing at Helpers:
After successfully decoding
subtask ϕH
n , helper Hm will execute it with the following
computing delay
τ exe-H
n
≜
ηH
n DnIn
PM
m=1 yn,mf H
m
,
(13)
where f H
m is the CPU frequency of helper Hm. Since the
helpers are generally low-power compared to the MEC servers,
we consider the energy consumption required for computing
subtasks on different helpers. Note that the energy consump-
tion for helper Hm to compute subtask ϕH
n is given by
eexe-H
n,m = ηH
n DnInς(f H
m )2,
(14)
where ς denotes the effective capacitance coefﬁcient depend-
ing on the chip architecture [30].
2) Computing at Servers: After successfully decoding sub-
task ϕS
n, server Sk will compute it with the following delay
τ exe-S
n
≜
ηS
nDnIn
PK
k=1 xn,kf S
n,k
,
(15)
where f S
n,k is the CPU frequency allocated to UE Un. Since
MEC servers usually have a continuous power supply, we
do not consider the energy consumption of the server-side
task execution, which is also a general assumption in existing
studies [20]–[22].
3) Computing at UEs: UE Un (n ∈N) will simultaneously
compute subtask ϕL
n while ofﬂoading subtasks ϕH
n and ϕS
n,
and the local computing delay is given by
tL
n = (1 −ηS
n −ηH
n )DnIn
f L
n
,
(16)
where f L
n is the computational CPU frequency of UE Un.
Moreover, the energy consumption of UE Un for local com-
puting can be expressed as
eL
n = (1 −ηS
n −ηH
n )DnInς(f L
n )2.
(17)
III. PROBLEM FORMULATION AND REFORMULATION
To minimize the mEDT, this section ﬁrst gives the deﬁnition
of the mEDT, and then formulates the joint optimization prob-
lem of the user association, RB assignment, power allocation,
task assignment, and computation resource allocation. Finally,
the optimization problem can be equivalently reformulated as
a DUARA problem with only discrete 0-1 variables.
A. Maximal Energy-Delay Tradeoff
Since each MEC helper/server executes the desired subtask
after successfully decoding it, the delay of subtask completion
at helper Hm and server Sk can be deﬁned as
toff-H
n
≜τ tran-H
n
+ τexe-H
n
,
(18)

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
5
and
toff-S
n
≜τtran-S
n
+ τ exe-S
n
,
(19)
respectively. Therefore, the task completion delay of Un can
be deﬁned as
Tn ≜max{tL
n, toff-H
n
, toff-S
n
}.
(20)
Moreover, the corresponding energy consumption for UE
Un to complete task Ln is deﬁned as the sum of the local
computing energy consumption and the transmission energy
consumption, which is given by
En ≜etran
n
+ eL
n.
(21)
Hence, the mEDT is deﬁned as the maximal weighted sum of
energy consumption and delay among all the UEs, which is
given by
EDTmax(X, Y , Z, p, η, f) ≜max
n∈N{ωE
n En + ωT
n Tn},
(22)
where X
=
{xn,k|∀n
∈
N, ∀k
∈
M} and Y
=
{yn,m|∀n ∈N, ∀m ∈K} denote the user association vari-
ables, Z = {zn,l|∀n ∈N, ∀l ∈L} is the RB assignment,
p = {pH
1 , . . . , pH
N; pS
1 , . . . , pS
N} ∈R+ denotes the power
allocation, η = {ηH
1 , . . . , ηH
N ; ηS
1 , . . . , ηS
N} ∈R+ denotes the
task assignment, and f = {f S
n,k|∀n ∈N, ∀k ∈K} denotes
the computation resource allocation of the MEC servers.
B. Problem Formulation
From the perspective of min-max fairness, the joint opti-
mization problem can be formulated to minimize the mEDT,
which is given by
min
X,Y ,Z,p,η,f EDTmax(X, Y , Z, p, η, f)
(23a)
s.t.
(1), (2), (3), (4), (5), (6), (11),
(23b)
N
X
n=1
yn,meexe-H
n,m ≤Emax
m
, ∀m ∈M,
(23c)
ηS
n + ηH
n ≤1, ∀n ∈N,
(23d)
0 ≤ηS
n, ηH
n , ∀n ∈N,
(23e)
N
X
n=1
xn,kf S
n,k ≤F max
k
, ∀k ∈K,
(23f)
xn,k ∈{0, 1} , ∀n ∈N, ∀k ∈K,
(23g)
yn,m ∈{0, 1} , ∀n ∈N, ∀m ∈M,
(23h)
zn,l ∈{0, 1} , ∀n ∈N, ∀l ∈L,
(23i)
Tn ≤T max
n
, ∀n ∈N,
(23j)
0 ≤pH
n , pS
n, ∀n ∈N,
(23k)
pH
n + pS
n ≤P max
n
, ∀n ∈N.
(23l)
Constraints (23c)∼(23l) are explained as follows. (23c) rep-
resents that the energy consumption at each helper should
not exceed the maximum tolerance Emax
m
. (23d) and (23e)
represent the range of task splitting coefﬁcients of UEs. (23f)
means that the computation resources allocated by each sever
to the served users should not exceed its maximum thresholds.
Constraints (23g), (23h), and (23i) are 0-1 constraints of the
user association and RB assignment. Constraint (23j) indicates
that the overall delay of executing the whole task of UE Un
cannot exceed the maximum tolerance T max
n
. (23k) and (23l)
are the transmit power constraints.
C. Equivalent Problem Reformulation
The formulated optimization problem (i.e., problem (23))
is a mixed-integer nonlinear programming problem due to
the non-convex objective function and non-convex constraints
(11), (23g), (23h), (23i), and (23j). To tackle this challenging
problem (23), we equivalently reformulate it as follows.
Given the user association X and Y , and RB assignment
Z, problem (23) can be decoupled as a PATACRA subproblem
with respect to only continuous variables, which can be
expressed by
min
p,η,f EDTmax(p, η, f)
(24a)
s.t.
(11), (23c) ∼(23f), (23j) ∼(23l).
(24b)
As user association X, Y
and RB assignment Z are as-
sumed to be known in PATACRA subproblem, the solu-
tion obtained form PATACRA subproblem can be regarded
as functions of the 0-1 variables {X, Y , Z} denoted as
{p∗(X, Y , Z), η∗(X, Y , Z), f ∗(X, Y , Z)}. Therefore, by
applying {p∗(X, Y , Z), η∗(X, Y , Z), f ∗(X, Y , Z)} into
problem (23), we can equivalently transform the original
problem into a DUARA problem as follows
min
X,Y ,Z EDTmax(X, Y , Z, p∗, η∗, f ∗)
(25a)
s.t.
(1) ∼(6), (23g) ∼(23i).
(25b)
Therefore, the continuous variables and 0-1 variables in origi-
nal problem (23) can be jointly optimized by solving DUARA
problem (25).
IV. PROPOSED ITERATIVE PARAMETRIC CONVEX
APPROXIMATION ALGORITHM
In this section, we ﬁrst reformulate the PATACRA subprob-
lem into a tractable form, then propose an IPCA algorithm
to solve the reformulated subproblem, and ﬁnally analyze the
convergence and complexity of the proposed IPCA algorithm.
A. Reformulation of PATACRA Subproblem
Given 0-1 variables X, Y , and Z, we assume that UE Un is
associated with helper Hm, server Sk and RB RBl for notation
convenience. To tackle the non-convex objective function in
PATACRA subproblem (24) more conveniently, we introduce
an auxiliary variable φ to eliminate the max operation from the
objective function. Therefore, subproblem (24) is transformed
as
min
p,η,f,φφ
(26a)
s.t.
(11), (23c) ∼(23f), (23j) ∼(23l),
(26b)
ωE
n En + ωT
n Tn ≤φ, ∀n ∈N,
(26c)
which is still non-convex due to the non-convexity of con-
straints (11), (23j), and (26c).

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
6
Since (11) is an equality constraint, transmit powers pH
n and
pS
n can be converted to the following functions with respect to
τ tran
n , ηH
n , and ηS
n, indicating that original variables pH
n and pS
n
can be removed from problem (26). Accordingly, the converted
functions are given by
pH
n ≜An,2g
ηO,1
n Dn
Bτ tran
n

,
(27)
and
pS
n ≜An,1g
ηO,2
n Dn
Bτ tran
n

−An,2g
ηO,1
n Dn
Bτ tran
n

+ An,2g
ηH
n Dn + ηS
nDn
Bτ tran
n

,
(28)
where
g(x)
=
2x
−
1,
An,1
≜
(1 −2On,k,m,l)(1/gS
n,k,l −1/gH
n,m,l) ≥
0, An,2
≜
(1 −
On,k,m,l)/gH
n,m,l+On,k,m,l/gS
n,k,l, ηO,1
n
≜(1−On,k,m,l)ηH
n +
On,k,m,lηS
n, ηO,2
n
≜On,k,m,lηH
n + (1 −On,k,m,l)ηS
n, and
τ tran
n
= τ tran-H
n
= τ tran-S
n
for notation convenience. The proof
of deriving (27) and (28) can be referred to Appendix A
in [32]. Recall that Tn ≜max{tL
n, toff-H
n
, toff-S
n
}, which is
difﬁcult to deal with. Therefore, we introduce auxiliary
variables β ≜{βn|∀n ∈N} to eliminate max operation by
approximating the upper bound of Tn, i.e., βn ≥Tn, ∀n.
Then, by substituting (27), (28), and β into (26), we have
min
τ,η,f,β,φ
φ
(29a)
s.t.
(23c) ∼(23f),
(29b)
βn ≤T max
n
, ∀n ∈N,
(29c)
pH
n + pS
n ≤P max
n
, ∀n ∈N,
(29d)
(1 −ηH
n −ηS
n)DnIn
f L
n
≤βn, ∀n ∈N,
(29e)
τ tran
n
+ τexe-H
n
≤βn, ∀n ∈N,
(29f)
τ tran
n
+ τexe-S
n
≤βn, ∀n ∈N,
(29g)
ωE
n E′
n + ωT
n βn ≤φ, ∀n ∈N,
(29h)
where τ = {τ tran
n |∀n ∈N} is the transmission delay, and E′
n
in constraint (29h) is given by
E′
n ≜
 1 −ηH
n −ηS
n

DnInζ
 f L
n
2 + τ tran
n An,1g
ηO,2
n Dn
Bτ tran
n

+ τtran
n An,2g
ηH
n Dn + ηS
nDn
Bτ tran
n

.
(30)
Proposition 1. Constraint (29h) is a convex constraint.
Proof: Please see Appendix A.
Note that problem (29) is still non-convex due to the non-
convexity of constraint (29d) with respect to the coupled vari-
ables τ tran
n , ηH
n , and ηS
n, and the non-convenxity of constraint
(29g) with respect to coupled variables ηS
n and f S
n,k. To solve
this non-convex optimization problem, a general scheme is to
approximate the non-convex feasible set by using successive
convex approximation methods [33]–[36]. Speciﬁcally, denote
a non-convex problem as min Y (x) s.t. gi(x) ≤0, ∀i ∈
{1, ..., I}, where gi(x) is a non-convex function and I is the
number of constraints. The basic idea of the successive convex
approximation method is that non-convex gi(x) is replaced
by the upper convex and continuously differentiable function
Gi(x, yr) at iteration r, where yr is a appropriately selected
parameter [33].
However, for non-convex problem (29), since constraints
(29d) and (29g) have non-convex terms An,1g

ηO,2
n Dn
Bτ tran
n

+
An,2g

ηH
n Dn+ηS
nDn
Bτ tran
n

and τ tran
n
+ ηS
nDnIn
f S
n,k
, respectively, it is
difﬁcult to directly ﬁnd their upper convex approximations.
Therefore, in the next subsection, we ﬁrst transform these non-
convex items into the form that can be approximated by the
convex approximation methods, and then propose an IPCA
algorithm to solve problem (29).
B. Convex Approximation Transformation and Proposed IPCA
Algorithm
To construct the upper convex approximations of the non-
convex items in (29d) and (29g), we replace the intractable
non-convex items by introducing auxiliary variables, and then
transform the replaced constraints into the form that can adopt
the convex approximation. The transformation details of each
constraint are described as follows.
For non-convex constraint (29d), it can be transformed
as the following convex constraint by introducing auxiliary
variables {zn,1, zn,2|∀n ∈N}
An,1(2zn,1 −1) + An,2(2zn,2 −1) ≤P max
n
, ∀n ∈N,
(31)
where zn,1 and zn,2 should satisfy
(On,k,m,lηH
n + (1 −On,k,m,l)ηS
n)Dn
Bτ tran
n
≤zn,1, ∀n ∈N, (32)
and
(ηH
n + ηS
n)Dn
Bτ tran
n
≤zn,2, ∀n ∈N.
(33)
To transform introduced non-convex constraints (32) and (33)
into a form that can be approximated by the successive convex
approximation method, i.e., ﬁrst-order Taylor approximation
[34], we introduce auxiliary variables {un,1, un,2|∀n ∈N},
and then constraints (32) and (33) can be rewritten as follows
zn,iτ tran
n
≥u2
n,i, ∀i ∈{1, 2}, ∀n ∈N,
(34)
u2
n,1 ≥(On,k,m,lηH
n + (1 −On,k,m,l)ηS
n)Dn
B
, ∀n ∈N, (35)
and
u2
n,2 ≥(ηH
n + ηS
n)Dn
B
, ∀n ∈N.
(36)
Then, non-linear constraint (34) can be rewritten as a convex
linear matrix inequality (LMI) constraint

zn,i
un,i
un,i
τ tran
n

⪰0, ∀i ∈{1, 2}, ∀n ∈N.
(37)
For non-convex constraint (35) and (36), by using the ﬁrst-
order Taylor approximation, we introduce surrogate functions
Gn,r,i(un,i, u(r)
n,i) = 2un,iu(r)
n,i −(u(r)
n,i)2, ∀i ∈{1, 2} as convex
lower bounds for u2
n,i, respectively, which can be given by
Gn,r,i(un,i, u(r)
n,i) ≤u2
n,i, ∀i ∈{1, 2},
(38)

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
7
where u(r)
n,i = u(r−1)
n,i
at iteration r. Then, non-convex con-
straints (35) and (36) around points u(r)
n,i at iteration r can be
expressed by
(On,k,m,lηH
n + (1 −On,k,m,l)ηS
n)Dn
B
≤Gn,r,1(un,1, u(r)
n,1),
(39)
(ηH
n + ηS
n)Dn
B
≤Gn,r,2(un,2, u(r)
n,2).
(40)
Note that (39) and (40) are convex constraints since both sides
of the inequalities are afﬁne functions.
For non-convex constraint (29g), we introduce variables
{ξn|∀n ∈N} to tackle the non-convex term texe-S
n
, ∀n ∈N.
Therefore, (29g) can be transformed as
τ tran
n
+ ξn ≤βn, ∀n ∈N,
(41)
and
ηS
nDnIn
f S
n,k
≤ξn, ∀n ∈N.
(42)
Since (42) is a non-convex constraint, we can transform it as
a convex constraint by introducing variables {un,3|∀n ∈N},
which is given by
ξnf S
n,k
DnIn
≥u2
n,3, ∀n ∈N,
(43)
and
u2
n,3 ≥ηS
n, ∀n ∈N,
(44)
where (43) can be rewritten as a convex LMI constraint
" ξn
Dn
un,3
un,3
f S
n,k
In
#
⪰0, ∀n ∈N.
(45)
Likewise, for introduced non-convex constraint (44), by
using the ﬁrst-order Taylor approximation, we introduce sur-
rogate functions Gn,r,3(un,3, u(r)
n,3) = 2un,3u(r)
n,3 −(u(r)
n,3)2 as
convex lower bound for u2
n,3, where u(r)
n,3 = u(r−1)
n,3
at iteration
r. Then, constraint (44) can be transformed as
ηS
n ≤Gn,r,3(un,3, u(r)
n,3),
(46)
which is a convex constraint.
Overall, replacing (35), (36), and (44) by their correspond-
ing approximate constraints at iteration r, subproblem (29)
can be approximately transformed into a convex subproblem
shown as follows
min
τ,η,f,β,z,ξ,u,φ
φ
(47a)
s.t.
(29b), (29c), (29e), (29f), (29h),
(47b)
(31), (37), (39) ∼(41), (45), (46),
(47c)
where z = {zn,i|∀i ∈{1, 2}, ∀n ∈N}, ξ = {ξn|∀n ∈N},
and u = {un,i|∀i ∈{1, 2, 3}, ∀n ∈N} are the introduced
auxiliary variables.
It can be seen that subproblem (47) is a convex optimization
problem, which can be solved by the convex solver, i.e.,
CVX toolbox [34]–[37], at iteration r. Nevertheless, since
τ tran
n An,1g

ηO,2
n
Dn
Bτ tran
n

and τ tran
n An,2g

ηH
n Dn+ηS
nDn
Bτ tran
n

in convex
constraint (29h) are perspective functions with structure y2x/y,
they will be replaced and solved by using convex function tool
{x ln(2), y, z} == exponential(1) of the CVX toolbox [9].
Please refer to [38] for the details of this substitution.
With the above transformations and convex approximations,
we propose an IPCA algorithm to directly solve subproblem
(29) by iteratively solving a sequence of approximated con-
vex problem. Speciﬁcally, by solving approximated convex
subproblem (47) at each iteration, subproblem (29) can be
approximately solved until convergence, where the parameters
introduced for convex approximation of problem (47) are
dependent on the solution of the previous iteration. The
procedure of the proposed IPCA algorithm is described in
Algorithm 1, where ǫ is a small positive value to control the
accuracy of the proposed IPCA algorithm.
Algorithm 1: The Proposed IPCA Algorithm
1: Initialization: Initialize the initial feasible points u(0), φ(0),
and set r = 1;
2: While |φr −φr−1| ≥ǫ do
3:
Solve problem (47) and get τ (r), η(r), f (r), β(r), z(r), ξ(r),
u(r), and φ(r);
4:
Set r = r + 1;
5:
Update u(r) = u(r−1);
6: end while
7: Output: τ ∗, η∗, f ∗and φ∗.
9: Calculate p∗by utilizing (27) and (28).
C. Convergence and Complexity Analysis
To prove the convergence of the proposed IPCA algorithm,
the proposition is provided as follows.
Proposition 2. A sequence of non-increasing objective
values are generated by the proposed IPCA algorithm and
ﬁnally converges.
Proof: First, recall that
ηS
nDn
B
≤Gn,r,1(un,1, u(r)
n,1) ≤
u2
n,1,
(ηH
n +ηS
n)Dn
B
≤Gn,r,2(un,2, u(r)
n,2) ≤u2
n,2, and ηS
n ≤
Gn,r,3(un,3, u(r)
n,3) ≤u2
n,3. It can be concluded that the feasible
point of subproblem (47) at iteration r is also feasible for
subproblem (29).
Next, we will prove that a sequence of non-increasing
objective values can be generated. Recall that for itera-
tion r, convex constraints (39), (40), and (46) are trans-
formed from (35), (36), and (44). For constraint (35),
we have
ηS
nDn
B
≤
Gn,r,1(un,1, u(r)
n,1). Then, assume that
the optimal solution to subproblem (47) at iteration r
is {τ (r)∗, η(r)∗, f (r)∗, β(r)∗, z(r)∗, ξ(r)∗, u(r)∗, φ(r)∗}. By re-
placing u(r+1) with the solution obtained from iteration r, i.e.,
u(r+1) = u(r)∗, we have that
Gn,r,1(un,1, u(r+1)
n,1
) = 2un,1u(r)∗
n,1 −(u(r)∗
n,1 )2 ≥ηS
nDn
B
,
(48)
which indicates that the solution of subproblem (47) at itera-
tion r satisﬁes constraint (35) at the next iteration. Following
the same rationale, we can prove that the solution obtained at
iteration r also satisﬁes constraints (39) and (40) at iteration

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
8
r+1. Therefore, the solution obtained at iteration r is a feasible
point for subproblem (47) at next iteration r + 1, indicating
that the objective value is monotonically non-increasing with
the iteration index.
In a summary, it can be concluded that a sequence of fea-
sible solutions can be obtained with non-increasing objective
values. Additionally, since the feasible set of problem (29)
is nonempty and compact, the sequence of non-increasing
objective values is lower-bounded. Therefore, the proposed
IPCA algorithm will converge to a stationary point.
Since subproblem (47) is solved by the CVX toolbox using
interior-point method [34]–[37], the complexity of Algorithm
1 is O(δ) = O(l1
log(S/(ǫt))
log θ
) [37], where ǫ denotes a guar-
anteed speciﬁed accuracy, t is the initial centering point, θ
denotes the updating step size to increase t, S is the number
of constraints, and l1 is the iteration number of Algorithm 1.
V. PROPOSED FOUR-SIDED UE-RB-HELPER-SERVER
MATCHING ALGORITHM
In this section, we ﬁrst model DUARA problem (25) as
a four-sided matching problem. Then, using the objective
value provided by the IPCA algorithm to determine the utility,
we propose an FS-URHSM algorithm to solve the DUARA
problem. Finally, we analyze the stability and complexity of
the proposed FS-URHSM algorithm.
A. Modeling of Four-Sided Matching
Recall that DUARA problem (25) only contains discrete 0-1
variables X, Y , and Z, which is shown to be NP-hard and can
not be directly solved with polynomial complexity. However,
if the exhaustive search algorithm is used to ﬁnd the optimal
solution by traversing all possible combinations of variables
X, Y , and Z, it will suffer an exponential complexity of
O(δ2NM+NK+NL). Fortunately, as a promising approach for
dynamic resource allocation and network management [39],
[40], matching theory can offer a near-optimal solution with
much lower complexity than the exhaustive search. In speciﬁc,
matching theory utilizes preferences to describe the dynamic
relationship between different sets of players, improves play-
ers’ preferences by using deferred-acceptance/swap opera-
tions, and ﬁnally achieves a stable matching that no deferred-
acceptance/swap operation can improve the players’ utili-
ties/preferences. Conventional matching theory mainly focused
on the two-sided [29] or three-sided matching [26]–[28] with
cyclic/mixed preferences, e.g., one-to-one two-sided marriage
problem introduced by Gale and Shapley [39], many-to-one
two-sided college admission problem, and three-sided kidney
transplant problem [27]. However, since DUARA problem (25)
contains 0-1 variables X, Y , and Z, it can not be modeled as
a conventional two/three-sided matching problem, indicating
that a new four-sided matching problem should be designed.
Inspired by above observations, we model DUARA problem
(25) as a four-sided matching problem among UEs, RBs, MEC
helpers, and servers in Deﬁnition 1. Before this deﬁnition,
we give the following notations according to the conventional
two/three-sided matching [39] to better describe the modeling
of four-sided matching.
• Matching triple: If helper Hm, MEC server Sk, and RB
RBl are matched to each other, they can be deﬁned as a
matching triple, denoted as (Hm, Sk, RBl) ∈M×K×L.
Likewise, (Un, Sk, RBl) ∈N × K × L, (Un, Hm, Sk) ∈
N × M × K, and (Un, Hm, Sk) ∈N × M × K are also
matching triples, respectively.
• Matching unit: If UE Un matches to a matching triple
(Hm, Sk, RBl) ∈M × K × L, it indicates that helper
Hm, MEC server Sk, and RB RBl are matched to each
other, which can be viewed as a matching unit deﬁned as
µn ≜(Un, Hm, Sk, RBl).
With above introduced notations, DUARA problem (25)
with only discrete 0-1 variables can be modeled as the fol-
lowing four-sided matching model.
Deﬁnition 1: (Four-sided Matching Model) Four-sided
matching Ψ represents the mapping relationship among UEs,
RBs, MEC helpers, and servers, which satisﬁes the following
conditions:
1) Ψ(Un) = (Hm, Sk, RBl) ∈M × K × L, |Ψ(Un)| =
{1, 1, 1}, ∀n ∈N;
2) Ψ(Hm) = (Un, Sk, RBl) ∈N × K × L, |Ψ(Hm)| =
{1, 1, 1}, or MEC helper Hm is not matched to any UE,
server and RB, ∀m ∈M;
3) Ψ(Sk) = (Un, Hm, RBl) ∈N × M × L, |Ψ(Sk)| =
{N max
k
, N max
k
, N max
k
}, or server Sk is not matched to
any UE, helper and RB, ∀k ∈K;
4) Ψ(RBl) = (Un, Hm, Sk) ∈N × M × K, |Ψ(RBl)| =
{1, 1, 1}, or RB RBl is not matched to any UE, MEC
helper and server, ∀l ∈L;
5) Ψ(Un)
=
(Hm, Sk, RBl)
⇔
Ψ(Hm)
=
(Un, Sk, RBl)
⇔
Ψ(Sk)
=
(Un, Hm, RBl)
⇔
Ψ(RBl) = (Un, Hm, Sk), ∀n ∈N;
where the positive integers in right hand of equation |Ψ(·)| =
{1, 1, 1} and |Ψ(Sk)| = {N max
k
, N max
k
, N max
k
} denote the
number of matched players, respectively. Conditions 1)∼5)
can be explained as follows. Condition 1) indicates that
each UE is matched to one helper, one server, and one RB.
Condition 2) indicates that each MEC helper can be matched
to at most one UE, one server, and one RB. Condition 3) means
that each server is matched to at most N max
n
UEs/helpers/RBs.
Condition 4) means that each RB is matched to at most one
UE, one helper, and one server. Condition 5) indicates that UE
Un, helper Hm, server Sk, and RB RBl are matched to each
other.
Therefore, with the above deﬁnition of matching Ψ,
DUARA problem (25) can be equivalently viewed as ﬁnding
the best four-sided matching to minimize the utility function,
which is deﬁned as
U(Ψ) ≜EDTmax[X(Ψ), Y (Ψ), Z(Ψ), p∗, η∗, f ∗],
(49)
where X(Ψ), Y (Ψ) and Z(Ψ) denote the user associ-
ation and RB assignment based on Ψ. The elements in
{X(Ψ), Y (Ψ), Z(Ψ)} can be characterized by
{xn,k, yn,m, zn,l} =
(
{1, 1, 1},
for µn ∈Ψ, ∀n ∈N;
{0, 0, 0},
otherwise.
(50)

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
9
B. Proposed FS-URHSM Algorithm
In
conventional
two/three-sided
matching
theory,
the
deferred-acceptance/swap algorithms with cyclic/mixed pref-
erence are designed to ﬁnd the best feasible matching [26]–
[28]. For this four-sided matching problem, if the deferred-
acceptance/swap algorithms are directly utilized, the players
in each set need to establish the cyclic/mixed preference
of the players in the other three sets. However, since each
UE’s preference of server/helper/RB may change with the
matching conditions of other UEs matched to the same server,
it is difﬁcult to accurately describe this dynamic preferences
with using the cyclic/mixed preferences. In addition, if the
deferred-acceptance/swap algorithms are directly used to ﬁnd
the best four-sided matching, the feasibility of the four-sided
matching may be destroyed and some potential matchings
with better performance will be ignored. Speciﬁcally, due to
the dynamic nature of preferences in the four-sided matching
problem, some deferred-acceptance operations may be repeat-
edly performed, which may lead to the failure of the matching
process and result in the infeasible matching. Moreover, con-
ventional swap operations are suitable for players who are
already matched to each other [41], ignoring some unmatched
players with better performance. Therefore, we ﬁrst deﬁne the
matching utility of a feasible matching Ψ with the solution
obtained from PATACRA subproblem (24), and then propose
the FS-URHSM algorithm with the newly designed operations
as follows.
To ﬁnd the best four-sided matching, we use matching utility
to describe the competition behavior and decision process
among UEs, helpers, servers, and RBs, which is also from
utility function (49). Speciﬁcally, for matching Ψ, the match-
ing utility is given by
U(Ψ) ≜φ(∗),
(51)
where φ(∗) can be obtained by our proposed IPCA algorithm
in Algorithm 1.
With the matching utility deﬁned above, we propose a
novel FS-URHSM algorithm to ﬁnd out the best matching
by repeatedly performing operations in Deﬁnitions 2∼5 until
there is no deﬁned blocking matching.
Deﬁnition 2: (Sequential Swap (SS) Operation and SS
Matching) Suppose µ1 and µ2 are two different matching units
of matching Ψ, expressed as
µ1 ≜(Un, Hm, Sk, RBl),
(52)
and
µ2 ≜(Un′, Hm′, Sk′, RBl′),
(53)
where n ̸= n′, m ̸= m′, k ̸= k′ and l ̸= l′. Assume that two
players a ∈µ1 and a′ ∈µ2 belongs to the same set N, M, K
or L, respectively. The sequential swap operation over a and
a′ means that players a and a′ will exchange their currently
matched players Ψ(a) and Ψ(a′). Moreover, the matching
conditions of matching Ψ stay the same except for matching
units µ1 and µ2. After the sequential swap operation, we have
the following matching
ΨSS
a,a′ ≜Ψ \ {(a, Ψ(a)), (a′, Ψ(a′))}
∪{(a, Ψ(a′)), (a′, Ψ(a))},
(54)
called SS matching over {(a, Ψ(a)), (a′, Ψ(a′)}.
Deﬁnition 3: (SS-blocking Matching) In a feasible matching
Ψ, matching ΨSS
a,a′ can be a SS-blocking matching if and only
if
U(ΨSS
a,a′) < U(Ψ).
(55)
Deﬁnition 3 indicates that the SS operation will be performed
if and only if the utility of the newly generated SS matching
will be reduced after swapping.
Recall that when M > N, PK
k=1 N max
k
> N or K > N,
not all MEC helpers/servers/RBs can be fully matched to other
players in the opposite sets. Therefore, the unmatched MEC
helpers/RBs will not participate in the SS operation deﬁned
above, which may lead to a local optimal matching and cause a
large gap with the optimal solution. To tackle such a challenge
issue in scenarios where M > N, PK
k=1 N max
k
> N or K >
N, we have following deﬁnitions.
Deﬁnition 4: (Leaving and Joining-in (LJ) Operation and
LJ Matching) From the perspective of MEC helpers, the
set of matched and unmatched MEC helpers are deﬁned as
Hmatched and Hunmatched, respectively. The LJ operation
over {(Hm, Hm′)} means that a matched MEC helper Hm
leaves out its current matching players Ψ(Hm) and a new
unmatched MEC helper Hm′ joins in the same matching
players Ψ(Hm) while keeping other conditions unchanged.
The LJ matching ΨLJ
m,m′ generated after this operation can be
expressed as
ΨLJ
m,m′ ≜Ψ \ {(m, Ψ(m))} ∪{(m′, Ψ(m))},
(56)
where m ∈Hmatched, m′ ∈Hunmatched, and ΨLJ
m,m′ is called
LJ matching over {(Hm, Hm′)}.
Deﬁnition 5: (LJ-blocking Matching) In a feasible matching
Ψ, ΨLJ
m,m′ can be a LJ-blocking matching if and only if
U(ΨLJ
m,m′) < U(Ψ),
(57)
where m ∈Hmatched and m′ ∈Hunmatched.
Following the same idea, deﬁne the set of matched and
unmatched RBs as RBmatched and RBunmatched, we can
deﬁne the LJ matching over {(RBl, RBl′)} as
ΨLJ
l,l′ ≜Ψ \ {(l, Ψ(l))} ∪{(l′, Ψ(l))},
(58)
where l ∈RBmatched and l′ ∈RBunmatched. Then, ΨLJ
l,l′ can
be a LJ-blocking matching over {(RBl, RBl′)} if and only if
U(ΨLJ
l,l′) < U(Ψ).
(59)
Note that when PK
k=1 N max
k
> N, the set of matched
and not fully matched servers are deﬁned as Smatched and
Sunmatched, respectively. Denote NSunmatched as the number
of UEs that have been matched by server Sk (∈Sunmatched).
The LJ matching over {(Sk, Sk′)} is deﬁned as
ΨLJ
k,k′ ≜Ψ \ {(k, Ψ(k))} ∪{(k′, Ψ(k))},
(60)
where k ∈Smatched and k′ ∈Sunmatched. Then, ΨLJ
k,k′ can
be a LJ-blocking matching over {(Sk, Sk′)} if and only if
U(ΨLJ
k,k′) < U(Ψ).
(61)

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
10
Deﬁnition 5 indicates that the LJ operation will be per-
formed if and only if the preference utility of the generated
matching will be reduced after the leaving and joining in.
With the above Deﬁnitions 2∼5, the procedure of the pro-
posed low-complexity FS-URHSM algorithm1 is summarized
in Algorithm 2. In each inner “Repeat-Until” iteration, by ﬁnd-
ing the SS-blocking/LJ-blocking matchings, the corresponding
SS and LJ operations will be repeatedly performed to minimize
the utility function. Finally, a stable matching will be achieved
after several outer “Repeat-Until” iterations.
C. Convergence, Stability and Complexity
1) Convergence and stability: The stability and conver-
gence of the proposed FS-URHSM algorithm are analyzed as
follows.
Proposition 2. The proposed FS-URHSM algorithm con-
verges to a stable matching Ψ∗with local optimal solution
after a limited number of SS/LJ operations.
Proof: Assume that Ψ′∗is an unstable four-sided match-
ing obtained by a certain iteration. Hence, it means that there is
at least one SS-blocking/LJ-blocking matching after a certain
iteration. More speciﬁcally, if (a, Ψ(a)) and (a′, Ψ(a′)) satisfy
the swap condition, players a and a′ will exchange their
current matching players, and the matching result Ψ′∗will
be updated. Likewise, if there exists a LJ-blocking matching,
the LJ operations will be performed to reduce the utility.
Therefore, the utility will keep monotonically decreasing. On
the other hand, note that the number of UEs, MEC helpers,
servers, and RBs are limited. Therefore, the sample space
of matching is ﬁnite, which means that the number of the
SS/LJ operations is ﬁnite and the utility is lower bounded [29],
[42]. Recall that the utility keeps monotonically decreasing,
it can be concluded that the proposed FS-URHSM algorithm
will eventually converge to a stable matching after a limited
number of SS/LJ operations. The proof is completed.
2) Complexity: In the following, we analyze the complexity
of the proposed FS-URHSM algorithm.
Proposition 3. The overall worst-case complexity of the
proposed FS-URHSM algorithm is O(∆δ(4δ1N 2 +δ2N(M −
N) + δ3N(L −N) + δ4N(K −1))), where ∆denotes the
number of the outer iteration and δ denotes the complexity of
our proposed IPCA algorithm.
Proof: For the sequential swap operations in Algorithm
2, recall that each player in the matching unit µi ∈Ψ
(∀i ∈{1, . . ., N}) searches the corresponding player and then
decides whether to carry out the sequential swap operation.
Hence, the worst-case complexity of the sequential swap
operations is O(4δ1N 2), where δ1 is the number of inner
“Repeat-Until” iterations in Stage-1.
1Although we focus on the cases where M ≥N and L ≥N, our work
can also be extended to case M < N or L < N. For instance, when M <
N, we can add a number of dumb helpers to ensure the total number of
actual and dumb helpers is no less than N. Then, by using the proposed FS-
URHSM algorithm, the user association, RB assignment, power allocation,
task assignment and computation resource allocation can be obtained. Note
that dumb helpers are aware of the surrounding environment, but unable to
communicate with any other users in the network [43]. When UE Un is
matched to a dumb helper, the corresponding task splitting coefﬁcient is set
as 0.
Algorithm 2: The Proposed FS-URHSM Algorithm
1: Initialization: Initialize a four-sided feasible matching Ψ, and
generate the unmatched and unmatched sets according to Ψ;
2: Repeat
3: Stage-1 Sequential Swap Operations:
4:
Repeat
5:
for µi ∈Ψ ﬁnds ∀µj ∈Ψ \ µi do
6:
∀a ∈µi, a′ ∈µj, calculate U(ΨSS
a,a′);
7:
if ΨSS
a,a′ is a SS-blocking matching then
8:
Update matching Ψ = ΨSS
a,a′;
9:
end if
10:
end for
11:
Until There is no SS-blocking matching;
12: Stage-2 Leaving and Joining-in Operations:
13:
if M > N then
14:
Repeat
15:
for m ∈Hmatched ﬁnds ∀m′ ∈Hunmatched do
16:
if ΨLJ
m,m′ is a LJ-blocking matching then
17:
Update matching Ψ = ΨLJ
m,m′, Hunmatched
and Hmatched;
18:
end if
19:
end for
20:
Until There is no LJ-blocking matching;
21:
end if
22:
if L > N then
23:
Repeat
24:
for l ∈RBmatched ﬁnds ∀l′ ∈RBunmatched do
25:
if ΨLJ
l,l′ is a LJ-blocking matching then
26:
Update matching Ψ = ΨLJ
l,l′, RBunmatched
and RBmatched;
27:
end if
28:
end for
29:
Until There is no LJ-blocking matching;
30:
end if
31:
if PK
k=1 N max
k
> N then
32:
Repeat
33:
for k ∈Smatched ﬁnds ∀k′ ∈Sunmatched do
34:
if ΨLJ
k,k′ is a LJ-blocking matching then
35:
Update matching Ψ = ΨLJ
k,k′, Sunmatched
and Smatched;
36:
end if
37:
end for
38:
Until There is no LJ-blocking matching;
39:
end if
40: Until There is no blocking matching;
41: Output: A stable matching Ψ.
For the leaving and joining-in operations in Stage-2 of
Algorithm 2, the worst-case computation complexity comes
from ﬁnding the possible LJ-blocking matching during each
inner “Repeat-Until” iteration, which can be denoted by
O(δ2N(M −N) + δ3N(L −N) + δ4N(K −1)), where
δ2, δ3 and δ4 denote the number of inner iterations when
M > 2N, K > N and PK
k=1 N max
k
> N, respectively.
Therefore, the overall worst-case complexity of Algorithm 2 is
O(∆δ(4δ1N 2+δ2N(M −N)+δ3N(L−N)+δ4N(K −1))).
The proof is completed.
VI. SIMULATION
In this section, numerical results are provided to evaluate
the performance of our proposed algorithms. In the simu-
lation setup, all the UEs/helpers/MEC servers are randomly
generated within a disc centered at (0, 0) with the radius of
500 [19].The bandwidth of each RB is set to Bk = 1 MHz,

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
11
0
5
10
15
Iteration number
0
0.02
0.04
0.06
0.08
0.1
0.12
mEDT
Proposed IPCA algorithm,  
1
E  = 0.6,  
2
E  = 0.5
Proposed IPCA algorithm,  
1
E  = 0.3,  
2
E  = 0.8
Proposed IPCA algorithm,  
1
E  = 0.5,  
2
E  = 0.7
Dn = 4
 105 bits
Dn = 2
 105 bits
Fig. 2. Convergence behavior of the proposed IPCA algorithm, where N =
K = M = L = 2 and ωT
n = 1 −ωE
n .
∀k ∈{1, ..., K}, and the noise power is σ2 = −174 dBm/Hz
[30]. The channel gain between nodes i and j over RB k fol-
lows the exponential distribution with mean 1/[1+(di,j/d0)α],
where di,j is the distance between nodes i and j, d0 is the
reference distance, and α is the path loss exponent. According
to the standard parameters for urban cellular networks [44], we
set d0 = 10 and α = 4.7. The maximum transmit power of
each UE is set to Pmax = 28 dBm. For the task execution, we
consider the computation intensity for computing 1-bit data is
In = 103 cycles/bit and the delay tolerance T max
n
of each
UE is 0.9 s. For the computation of energy consumption,
the effective capacitance coefﬁcient is set to ς = 10−29
[45]. To reﬂect the heterogeneity of computation capability
of the MEC servers, MEC helpers, and UEs, the computa-
tion frequencies of MEC servers are generated from uniform
distribution [20, 25] in Gcycles/s, helpers are generated from
uniform distribution [15, 20] in Gcycles/s, and the computation
frequencies of UEs are generated from uniform distribution
[2, 8] in Gcycles/s, respectively. Considering that the MEC
helpers are always energy consumption limited, the maximal
energy consumption of each helper is randomly generated
from range [0.8, 1] Joule. Moreover, the accuracy parameter
of the IPCA algorithm is set to ǫ = 10−6.
A. Feasibility of Proposed Algorithms
Fig. 2 demonstrates the convergence behavior of the pro-
posed IPCA algorithm. It can be observed that the proposed
IPCA algorithm converges within about 5 iterations and ﬁnally
converges to a stationary point. On the other hand, it can
also be seen that even with different combinations of data
size and weight factors, the convergence requires nearly the
same number of iterations. This observation demonstrates the
convergence of the IPCA algorithm is insensitive to the values
of data size and weight factors.
To demonstrate the performance gain of our proposed IPCA
algorithm for solving non-convex problem (29), Fig. 3 com-
pares the mEDT gap between the proposed IPCA algorithm
and the alternative optimization (AO) algorithm [24], [25].
The basic idea of the AO algorithm is that it ﬁrst divides
the variables of (29) into two blocks {f} and {τ, η, β, φ},
where each of these blocks corresponding to a subproblem.
10
12
14
16
18
20
Frequency of each helper (Gcycles/s)
0.002
0.004
0.006
0.008
0.01
0.012
0.014
0.016
0.018
0.02
mEDT
Proposed IPCA algorithm, Dn =1
105 bits
AO algorithm, Dn =1
105 bits
Proposed IPCA algorithm, Dn =2
105 bits
AO algorithm, Dn =2
105 bits
Normalized gap 
 15.3%
Normalized gap 
 23.8%
Fig. 3. The mEDT comparisons of the proposed IPCA algorithm and the AO
algorithm, where N = K = M = L = 2 and ωT
n = 1 −ωE
n .
Then, the two subproblems are solved iteratively to obtain the
convergent solution.
Fig. 3 compares the mEDT gap between the proposed IPCA
algorithm and the AO algorithm versus the frequency of each
helper, where the normalized gap is deﬁned as the ratio of
the mEDT gap to the mEDT achieved by the proposed IPCA
algorithm. It can be observed that the normalized gap is
approximately equal to 23.8% and 15.3% under Dn = 2×105
bites and 1 × 105 bits, respectively, indicating that our pro-
posed IPCA algorithm with alternating-free characteristics can
achieve better performance. The reason is described as follows.
Compared with the AO algorithm that decomposes PATACRA
problem (29) into two subproblems, our proposed IPCA al-
gorithm solve it directly, thereby reducing some performance
loss. On the other hand, the normalized gap is increasing
with the data size. The reason is that when other parameters
remain the same, the increase of the data size will lead to a
smaller feasible domain, thus reducing the efﬁciency of both
algorithms. Thus, it can be inferred that the proposed IPCA
algorithm has better performance when the feasible domain is
reduced.
To demonstrate the near-optimality of our proposed FS-
URHSM algorithm for solving problem (25), Fig. 4 compares
the performance gap between the proposed FS-URHSM al-
gorithm and exhaustive search using the IPCA (called ES-
IPCA) algorithm. The basic idea of the ES-IPCA algorithm is
described as follows. By using the proposed IPCA algorithm
to determine the mEDT of the possible matchings, the ES-
IPCA algorithm searches all the possible matching conditions
and selects the matching with the minimum mEDT.
Fig. 4 compares the mEDT gap between the proposed FS-
URHSM and the ES-IPCA algorithm versus the data size,
where the normalized mEDT gap is deﬁned as the ratio of the
mEDT gap to the mEDT achieved by the ES-IPCA algorithm.
As shown in Fig. 4, under N = 2, K = 1, M = 2 and L = 2,
the normalized mEDT gap is approximately equal to 0.5%.
When N = 2, K = 1, M = 5 and L = 3, the normalized
mEDT gap is approximately equal to 2.9%, indicating that our
proposed FS-URHSM algorithm achieves nearly the optimal
solution. On the other hand, as shown in Fig. 4, the mEDT
gap increases slightly when the number of MEC helpers and

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
12
3
4
5
6
7
Data size at each UE (bits)
105
0.015
0.02
0.025
0.03
0.035
0.04
0.045
mEDT
Proposed FS-URHSM, N = 2, K = 1, M = 5, L  = 3
ES-IPCA,  N = 2, K = 1, M = 5, L  = 3
Proposed FS-URHSM,  N = 2, K = 1, M = 2, L  = 2
ES-IPCA,  N = 2, K = 1, M = 2, L  = 2
Normalized mEDT gap 
 0.5%
Normalized mEDT gap 
 2.9%
Fig. 4. The mEDT comparisons of the proposed FS-URHSM algorithm and
the ES-IPCA algorithm, where ωE
1 = 0.6 and ωE
2 = 0.3.
the RBs increase. This can be explained that the matching
space between UEs, RBs, MEC helpers, and servers increases
with the number of UEs/RBs/helpers/servers, thereby slightly
degrading the performance of the proposed FS-URHSM algo-
rithm. Recall that the worst-case complexity of the proposed
FS-URHSM algorithm is O(∆δ(4δ1N 2 + δ2N(M −N) +
δ3N(L −N) + δ4N(K −1))), which is much less than
the exponential complexity of the ES-IPCA algorithm, i.e.,
O(δ2NM+NK+NL). Therefore, it can be concluded that the
proposed FS-URHSM algorithm can achieve a near-optimal
performance with much less complexity.
B. Performance Comparisons
Next, we compare our proposed FS-URHSM algorithm with
the following schemes:
• FDMA-based ofﬂoading without Helpers (FDMA w.o.
Helpers): Inspired by [46], each UE associates with one
server, divides its task into two subtasks, and ofﬂoads
one subtask to the associated server while computing the
remaining subtask locally.
• NOMA-based ofﬂoading without helpers (NOMA w.o.
Helpers): Inspired by [19], each UE selects two MEC
servers and divides its task into three subtasks. Then, each
UE locally computes one of the subtasks while ofﬂoading
the rest two subtasks to the selected servers by employing
NOMA.
• TDMA-based ofﬂoading with helpers (TDMA w. Helpers):
Inspired by [15], each UE selects one helper and one
server, and divides its task into three subtasks. Then,
each UE sequentially ofﬂoads two subtasks to the selected
helper and the server while locally executing the rest
subtask.
• FDMA-based
ofﬂoading
with
helpers
(FDMA
w.
Helpers): Inspired by [16], each UE selects one helper
and one server, and divides its task into three subtasks.
Then, each of them executes one of the subtasks locally
and ofﬂoads the rest two subtasks to the selected one
MEC helper and one server over two orthogonal RBs.
Fig. 5 describes the tradeoff between the energy consump-
tion and the delay of proposed FS-URHSM algorithm and
other schemes under different weight factors ωE
n and ωT
n . As
shown in Region 1 of Fig. 5, the energy consumptions of the
2
4
6
8
10
12
14
Delay (s)
10-3
0
1
2
3
4
5
6
Energy consumption (Joule)
10-3
Proposed FS-URHSM
FDMA w. Helpers
TDMA w. Helpers
FDMA w.o. Helpers
NOMA w.o. Helpers
Region 1
Region 2
Fig. 5. The tradeoff region among energy consumption and delay of the pro-
posed FS-URHSM algorithm, FDMA w. Helpers, TDMA w. Helpers, FDMA
w.o. Helpers and NOMA w.o. Helpers, where ωE
n ∈[0, 1], ωT
n = 1 −ωE
n ,
N = K = M = L = 2, and Dn = 1 × 105 bits.
 U 1
 U 2
 U 3
 U 4
0
0.01
0.02
0.03
0.04
0.05
0.06
EDT
Proposed FS-URHSM
sumEDT
Fig. 6. The fairness comparisons of the proposed FS-URHSM algorithm and
the sumEDT, where N = K = M = L = 4, ωE
n = ωT
n = 0.5, and
Dn = 1 × 106 bits.
proposed FS-URHSM algorithm, FDMA w. Helpers scheme,
TDMA w. Helpers scheme and FDMA w.o. Helpers scheme
decrease with the delay, and our proposed FS-URHSM outper-
forms other schemes in terms of the delay when the energy
consumption is small. This observation can be explained as
follows. By using our FS-URHSM algorithm, the tasks can
be simultaneously ofﬂoaded to the helper and the server, and
performed in a parallel manner, indicating that our algorithm
can reduce the energy consumption of the local computing
and the delay of transmission more than other schemes. On
the other hand, as shown in Region 2 of Fig. 5, the proposed
FS-URHSM algorithm consumes nearly the same energy of
other schemes when the delay further increases to more than
0.012 s. This is because when users become insensitive to the
delay, each user is more likely to ofﬂoad its entire task to the
MEC server, in order to save the energy consumption incurred
by local computing and NOMA enabled ofﬂoading. Based on
the above observations, it can be concluded that our proposed
scheme is more suitable for MEC systems with strict delay
requirements.
Fig. 6 compares the user fairness between the proposed FS-
URHSM algorithm and the sum of EDT (namely sumEDT)
that minimizes the sum of all the UEs’ EDT. It can be

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
13
2
3
4
5
6
7
8
9
10
Number of helpers
0.01
0.015
0.02
0.025
0.03
mEDT
Proposed FS-URHSM
FDMA w. Helpers
TDMA w. Helpers
FDMA w.o. Helpers
NOMA w.o. Helpers
Fig. 7. The mEDT comparisons of proposed FS-URHSM algorithm, FDMA
w. Helpers, TDMA w. Helpers, FDMA w.o. Helpers and NOMA w.o. Helpers
versus the number of helpers, where N = K = L = 2, M = 10, Dn =
5 × 105 bits, ωE
n = 0.5, and ωT
n = 1 −ωE
n .
1
2
3
4
5
Data size at each UE (bits)
105
0
0.005
0.01
0.015
0.02
0.025
0.03
mEDT
Proposed FS-URHSM
FDMA w. Helpers
TDMA w. Helpers
FDMA w.o. Helpers
NOMA w.o. Helpers
Fig. 8. The mEDT comparisons of proposed FS-URHSM algorithm, FDMA
w. Helpers, TDMA w. Helpers, FDMA w.o. Helpers and NOMA w.o. Helpers
schemes versus data size at each UE, where N = K = M = L = 2,
ωE
n = 0.5, and ωT
n = 1 −ωE
n .
observed from Fig. 6 that the value of each UE’s EDT obtained
by our proposed FS-URHSM algorithm is nearly the same,
while the value of each UE’s EDT obtained by the sumEDT
is signiﬁcantly different. Moreover, the value of minimal
EDT obtained by the sumEDT is lower than that obtained
by our proposed FS-URHSM algorithm, indicating that our
proposed FS-URHSM algorithm can achieve the min-max
fairness among UEs at the cost of the EDT. This is because
the goal of our proposed FS-URHSM algorithm is to minimize
the maximal EDT among all UEs, while the sumEDT scheme
aims to improve the performance of the UE that is more likely
to reduce the energy consumption/delay.
Figs. 7 and 8 depict the mEDT of the proposed FS-URHSM
algorithm and other schemes versus the data size and the
number of MEC helpers, respectively. It can be observed
from all the ﬁgures that the proposed FS-URHSM algorithm
outperforms other schemes in terms of the mEDT. This obser-
vation can be explained as follows. 1) By properly choosing
helpers, MEC servers and RBs, the computation loads of
UEs can be transferred to the helpers and the servers that
have better computation capabilities than users. Therefore, the
energy consumption of local computing and the delay of task
completion can be reduced. 2) Although UEs should consume
more energy to handle the interference incurred by downlink
NOMA-enabled ofﬂoading, they can ofﬂoad/compute tasks
in a parallel manner, thus largely reducing the transmis-
sion/computation delay. 3) Since the UEs can harvest the
spare resources of helpers by using our proposed algorithm,
the transmission delay and energy consumption can be further
reduced compared with the NOMA w.o. Helpers scheme, and
the computation workload on the servers can also be reduced.
VII. CONCLUSION
This paper has investigated a communication and computa-
tion resources allocation scheme in a helper-assisted NOMA-
MEC system. We have formulated the joint optimization
of user association, RB assignment, power allocation, task
assignment, and computation resource allocation as a mixed-
integer nonlinear programming problem, in order to minimize
the mEDT. To efﬁciently solve this problem, the formulated
problem has been decoupled as a PATACRA subproblem, and
then the original problem has been equivalently reformulated
as a DUARA problem with the solution obtained from the
PATACRA subproblem. We have proposed an IPCA algo-
rithm to solve the PATACRA subproblem, with which a low-
complexity FS-URHSM algorithm has been proposed to solve
the DUARA problem. Numerical results have demonstrated
that the proposed FS-URHSM algorithm achieves the near-
optimal solution with much less complexity, achieves the min-
max fairness among UEs, and performs better than other
schemes in terms of mEDT.
APPENDIX A
CONVEXITY PROOF OF CONSTRAINT (29h)
Function
E′
n
has
terms
τ tran
n 2(ηS
nDn)/(Bτ tran
n )
and
τ tran
n 2(ηH
n Dn+ηS
nDn)/(Bτ tran
n )
with
the
perspective
structure
given by
f = y2x/y,
(A.1)
where x, y > 0. Hence, the second-order Hessian matrix of
(A.1) can be expressed by
H =
1
(ln 2)2y
"
2
x
y
−x
y 2
x
y
−x
y 2
x
y
( x
y )22
x
y
#
.
(A.2)
For all v = [v1, v2]H ∈R2, Hessian matrix H satisﬁes
vHHv =
1
(ln 2)2y (v1 −v2
x
y )22
x
y ≥0.
(A.3)
Therefore, H is a positive semi-deﬁnite matrix and (A.1) is
joint-convex with respect to variables x, y. Furthermore, recall
that An,1 ≥0, An,2 ≥0 and the rest terms in the left
hand of constraint (29h) are afﬁne functions. The left hand of
constraint (29h) is a linear combination of convex and afﬁne
functions, while the right hand of constraint (29h) is an afﬁne
function. As a result, (29h) is a convex constraint.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015
14
REFERENCES
[1] M. Ren, J. Chen, Y. Zhou and L. Yang, “Energy-delay tradeoff in device-
assisted NOMA MEC aystems: A matching-based algorithm,” in 2021
IEEE Wireless Communications and Networking Conference (WCNC),
Nanjing, China, Mar. 2021, pp. 1–7.
[2] Y. Zhou, F. R. Yu, J. Chen, and Y. Kuo, “Cyber-physical-social systems:
A state-of-the-art survey, challenges and opportunities,” IEEE Commun.
Surveys Tuts., vol. 22, no. 1, pp. 389–425, 1st Quart., 2020.
[3] J. Li, M. Dai, and Z. Su, “Energy-aware task ofﬂoading in internet of
things,” IEEE Wireless Commun., vol. 27, no. 5, pp. 112–117, Oct. 2020.
[4] J. Yao, T. Han, and N. Ansari, “On mobile edge caching,” IEEE
Commun. Surveys Tuts., vol. 21, no. 3, pp. 2525–2553, 3rd Quart., 2019.
[5] Y. Mao, C. You, J. Zhang, K. Huang, and K. B. Letaief, “A survey
on mobile edge computing: The communication perspective,” IEEE
Commun. Surveys Tuts., vol. 19, no. 4, pp. 2322–2358, 4th Quart., 2017.
[6] L. Xu, M. Qin, Q. Yang and K. S. Kwak, “Learning-aided dynamic
access control in MEC-enabled green IoT networks: A convolutional
reinforcement learning approach,” IEEE Trans. Veh. Technol., vol. 71,
no. 2, pp. 2098–2109, Feb. 2022.
[7] Y. Xu, T. Zhang, D. Yang, Y. Liu and M. Tao, “Joint resource and
trajectory optimization for security in UAV-assisted MEC systems,”
IEEE Trans. Commun., vol. 69, no. 1, pp. 573–588, Jan. 2021.
[8] Y. Wu, Y. Wang, F. Zhou and R. Qingyang Hu, “Computation efﬁciency
maximization in OFDMA-based mobile edge computing networks,”
IEEE Commun. Lett., vol. 24, no. 1, pp. 159–163, Jan. 2020.
[9] Q. Ren, J. Chen, O. Abbasi, G. K. Kurt, H. Yanikomeroglu, and
F. R. Yu, “An application-driven non-orthogonal multiple access enabled
computation ofﬂoading scheme,” IEEE Internet Things J., vol. 8, no. 3,
pp. 1453–1466, Feb. 2021.
[10] Z. Ding, D. W. K. Ng, R. Schober, and H. V. Poor, “Delay minimization
for NOMA-MEC ofﬂoading,” IEEE Signal Process. Lett., vol. 25, no. 12,
pp. 1875–1879, Dec. 2018.
[11] Y. Sun, J. Xu, and S. Cui, “User association and resource allocation for
MEC-enabled IoT networks,” IEEE Trans. Wireless Commun., pp. 1–1,
2022, doi: 10.1109/TWC.2022.3163809.
[12] S. Bi and Y. J. Zhang, “Computation rate maximization for wireless
powered mobile-edge computing with binary computation ofﬂoading,”
IEEE Trans. Wireless Commun., vol. 17, no. 6, pp. 4177–4190, Jun.
2018.
[13] X. Li, S. Bi, Y. Zheng, and H. Wang, “Energy-efﬁcient online data sens-
ing and processing in wireless powered edge computing systems,” IEEE
Trans. Commun., pp. 1–1, 2022, doi: 10.1109/TCOMM.2022.3186718.
[14] H. Zhou, Z. Zhang, Y. Wu, M. Dong, and V. C. M. Leung,
“Energy efﬁcient joint computation ofﬂoading and service caching
for mobile edge computing: A deep reinforcement
learning ap-
proach,” IEEE Trans. Green Commun. Netw., pp. 1–1, 2022, doi:
10.1109/TGCN.2022.3186403.
[15] H. Xing, L. Liu, J. Xu, and A. Nallanathan, “Joint task assignment
and resource allocation for D2D-enabled mobile-edge computing,” IEEE
Trans. Commun., vol. 67, no. 6, pp. 4193–4207, Jun. 2019.
[16] Y. He, J. Ren, G. Yu, and Y. Cai, “D2D communications meet mobile
edge computing for enhanced computation capacity in cellular net-
works,” IEEE Trans. Wireless Commun., vol. 18, no. 3, pp. 1750–1763,
Mar. 2019.
[17] Y. Li, G. Xu, K. Yang, J. Ge, P. Liu, and Z. Jin, “Energy efﬁcient
relay selection and resource allocation in D2D-enabled mobile edge
computing,” IEEE Trans. Veh. Technol., vol. 69, no. 12, pp. 15800–
15814, Dec. 2020.
[18] L. Tan, Z. Kuang, L. Zhao, and A. Liu, “Energy-efﬁcient joint task
ofﬂoading and resource allocation in OFDMA-based collaborative edge
computing,” IEEE Trans. Wireless Commun., vol. 21, no. 3, pp. 1960–
1972, Mar. 2022.
[19] F. Fang, K. Wang, Z. Ding and V. C. M. Leung, “Energy-efﬁcient
resource allocation for NOMA-MEC networks with imperfect CSI,”
IEEE Trans. Commun., vol. 69, no. 5, pp. 3436–3449, May 2021.
[20] Y. Huang, Y. Liu, and F. Chen, “NOMA-aided mobile edge computing
via user cooperation,” IEEE Trans. Commun., vol. 68, no. 4, pp. 2221–
2235, Apr. 2020.
[21] B. Li, F. Si, W. Zhao, and H. Zhang, “Wireless powered mobile
edge computing with NOMA and user cooperation,” IEEE Trans. Veh.
Technol., vol. 70, no. 2, pp. 1957–1961, Feb. 2021.
[22] S. S. Yilmaz and B. ¨Ozbek, “Multi-helper NOMA for cooperative mobile
edge computing,” IEEE Trans. Intell. Transp. Syst., pp. 1–10, 2021.
[23] M. Ren, J. Chen, B. He, K. Wu, Y. Zhou, X. Xuan, and L. Yang,
“Cooperative NOMA-MEC with helper scheduling,” IEEE Commun.
Lett., vol. 26, no. 7, pp. 1693–1697, Jul. 2022.
[24] Z. Zhang, L. Lv, Q. Wu, H. Deng, and J. Chen, “Robust and secure com-
munications in intelligent reﬂecting surface assisted NOMA networks,”
IEEE Commun. Lett., vol. 25, no. 3, pp. 739–43, Mar. 2021.
[25] Z. Zhang, J. Chen, Q. Wu, Y. Liu, L. Lv, and X. Su, “Securing
NOMA networks by exploiting intelligent reﬂecting surface,” IEEE
Trans. Commun., vol. 70, no. 2, pp. 1096–1111, Feb. 2022.
[26] N. Raveendran, Y. Gu, C. Jiang, N. H. Tran, M. Pan, L. Song, and
Z. Han, “Cyclic three-sided matching game inspired wireless network
virtualization,” IEEE Trans. Mobile Comput., vol. 20, no. 2, pp. 416–
428, Feb. 2021.
[27] C.-C. Huang, “Circular stable matching and 3-way kidney transplant,”
Algorithmica, vol. 58, no. 1, pp. 137–150, Aug. 2010.
[28] F. Zhang and L. Zhong, “Three-sided matching problem with mixed
preferences,” J. Combin. Optim., 2019, doi: 10.1007/s10878-019-00501-
2.
[29] M. Sheng, Y. Dai, J. Liu, N. Cheng, X. Shen, and Q. Yang, “Delay-aware
computation ofﬂoading in NOMA MEC under differentiated uploading
delay,” IEEE Trans. Wireless Commun., vol. 19, no. 4, pp. 2813–2826,
Apr. 2020.
[30] F. Fang, Y. Xu, Z. Ding, C. Shen, M. Peng, and G. K. Karagianni-
dis,“Optimal resource allocation for delay minimization in NOMA-MEC
networks,” IEEE Trans. Commun., vol. 68, no. 12, pp. 7867–7881, Dec.
2020.
[31] L. Yang, H. Jiang, Q. Ye, Z. Ding, L. Lv, and J. Chen, “On the impact of
user scheduling on diversity and fairness in cooperative NOMA,” IEEE
Trans. Veh. Technol., vol. 67, no. 11, pp. 11 296–11 301, Nov. 2018.
[32] B. Zhu, K. Chi, J. Liu, K. Yu, and S. Mumtaz, “Efﬁcient ofﬂoad-
ing for minimizing task computation delay of NOMA-based multi-
access edge computing,” IEEE Trans. Commun., pp. 1–1, 2022, DOI:
10.1109/TCOMM.2022.3162263.
[33] A. Beck, A. Ben-Tal, L. Tetruashvili, “A sequential parametric convex
approximation method with applications to nonconvex truss topology
design problems,” J. Glob. Optim., vol. 47, no. 1, pp. 29–51, May 2010.
[34] W. Zhang, J. Chen, Y. Kuo, and Y. Zhou, “Transmit beamforming for
layered physical layer security,” IEEE Trans. Veh. Technol., vol. 68,
no. 10, pp. 9747–9760, Oct. 2019.
[35] W. Zhang, J. Chen, Y. Kuo, and Y. Zhou, “Artiﬁcial-noise-aided optimal
beamforming in layered physical layer security,” IEEE Commun. Lett.,
vol. 23, no. 1, pp. 72–75, Jan. 2019.
[36] Z. Liu, L. Lei, N. Zhang, G. Kang, and S. Chatzinotas, “Joint beam-
forming and power optimization with iterative user clustering for MISO-
NOMA systems,” IEEE Access, vol. 5, pp. 6872–6884, 2017.
[37] S. Boyd, S. P. Boyd, and L. Vandenberghe, Convex optimization.
Cambridge university press, 2004.
[38] M. Grant and S. Boyd, CVX: Matlab software for disciplined convex
programming, version 2.0 beta. http://cvxr.com/cvx, Sep. 2013.
[39] S. Bayat, Y. Li, L. Song and Z. Han, “Matching theory: Applications in
wireless communications,” IEEE Signal Process. Mag., vol. 33, no. 6,
pp. 103–122, Nov. 2016.
[40] Y. Gu, W. Saad, M. Bennis, M. Debbah, and Z. Han, “Matching theory
for future wireless networks: Fundamentals and applications,” IEEE
Commun. Mag., vol. 53, no. 5, pp. 52–59, May 2015.
[41] J. Zhu, J. Wang, Y. Huang, F. Fang, K. Navaie, and Z. Ding, “Resource
allocation for hybrid NOMA MEC ofﬂoading,” IEEE Trans. Wireless
Commun., vol. 19, no. 7, pp. 4964–4977, Jul. 2020.
[42] X. Xue, Y. Wang, L. Yang, J. Shi, and Z. Li, “Energy-efﬁcient hybrid
precoding for massive MIMO mmwave systems with a fully-adaptive-
connected structure,” IEEE Trans. Commun., vol. 68, no. 6, pp. 3521–
3535, Jun. 2020.
[43] A. Roy, S. Misra, and P. Dutta, “Dynamic pricing for sensor-cloud
platform in the presence of dumb nodes,” IEEE Trans. Cloud Comput.,
pp. 1–1, 2019, doi: 10.1109/TCC.2019.2950396.
[44] A. Goldsmith, Wireless Communications, Cambridge, U.K.: Cambridge
University Press, 2005.
[45] Y. Pan, M. Chen, Z. Yang, N. Huang, and M. Shikh-Bahaei, “Energy-
efﬁcient NOMA-based mobile edge computing ofﬂoading,” IEEE Com-
mun. Lett., vol. 23, no. 2, pp. 310–313, Feb. 2019.
[46] X. Chen, Y. Zhou, L. Yang and L. Lv, “User satisfaction oriented
resource allocation for fog computing: A mixed-task paradigm,” IEEE
Trans. Commun., vol. 68, no. 10, pp. 6470–6482, Oct. 2020.

