The Speciﬁcation Language TLA+
Stephan Merz
INRIA Lorraine, LORIA
615 rue du Jardin Botanique
F-54602 Villers-l`es-Nancy, France
Stephan.Merz@loria.fr
1 Introduction
The speciﬁcation language TLA+ was designed by Lamport for formally de-
scribing and reasoning about distributed algorithms. It is described in Lam-
port’s book “Specifying Systems” [30], which also gives good advice on how
to make best use of TLA+ and its supporting tools. Systems are speciﬁed in
TLA+ as formulas of the Temporal Logic of Actions TLA, a variant of linear-
time temporal logic also introduced by Lamport [28]. The underlying data
structures are speciﬁed in (a variant of) Zermelo-Fr¨ankel set theory, the lan-
guage accepted by most mathematicians as the standard basis for formalizing
mathematics. This choice is motivated by a desire for conciseness, clarity, and
formality that beﬁts a language of formal speciﬁcation where executability
or eﬃciency are not of major concern. TLA+ speciﬁcations are organized in
modules that can be reused independently.
In a quest for minimality and orthogonality of concepts, TLA+ does not
formally distinguish between speciﬁcations and properties: both are written
as logical formulas, and concepts such as reﬁnement, composition of systems
or hiding of internal state are expressed using logical connectives of impli-
cation, conjunction, and quantiﬁcation. Despite its expressiveness, TLA+ is
supported by tools such as model checkers and theorem provers to aid a de-
signer carry out formal developments.
This chapter attempts to formally deﬁne the core concepts of TLA and
TLA+ and to motivate some choices, in particular with respect to competing
formalisms. Before doing so, an introductory overview of system speciﬁcation
in TLA+ is given using the example of a resource allocator. Lamport’s book
remains the deﬁnitive reference for the language itself and on the method-
ology for using TLA+. In particular, the module language of TLA+ is only
introduced by example, and the rich standard mathematical library is only
sketched.
The outline of this chapter is as follows. Sect. 2 introduces TLA+ by way
of a ﬁrst speciﬁcation of the resource allocator and illustrates the use of the

394
Stephan Merz
tlc model checker. The logic TLA is formally deﬁned in Sect. 3, followed by
an overview of TLA+ proof rules for system veriﬁcation in Sect. 4. Section 5
describes the version of set theory that underlies TLA+, including some of the
constructions most frequently used for specifying data. The resource allocator
example is taken up again in Sect. 6, where an improved high-level speciﬁ-
cation is given and a step towards a distributed reﬁnement is made. Finally,
Sect. 7 contains some concluding remarks.
2 Example: A Simple Resource Allocator
We introduce TLA+ informally, by way of an example that will also serve as
a running example for this chapter. After stating the requirements informally,
we present a ﬁrst system speciﬁcation, and use the TLA+ model checker tlc
to analyse its correctness.
2.1 Informal Requirements
The purpose of the resource allocator is to manage a (ﬁnite) set of resources
that are shared among a number of client processes. Allocation of resources
is subject to the following constraints.
1. A client that currently does not hold any resources and that has no pend-
ing requests may issue a request for a set of resources.
Rationale: We require that no client should be allowed to “extend” a pending
request, possibly after the allocator has granted some resources. A single client
process might concurrently issue two separate requests for resources by appear-
ing under diﬀerent identities, and therefore the set of “clients” should really be
understood as identiﬁers for requests, but we will not make this distinction here.
2. The allocator may grant access to a set of available (i.e., not currently
allocated) resources to a client.
Rationale: Resources can be allocated in batches, so an allocation need not
satisfy the entire request of the client: the client may be able to begin working
with a subset of the resources it requested.
3. A client may release some resources that it holds.
Rationale: Similarly to allocation, clients may return just a subset of the re-
sources they currently hold, freeing them for allocation to a diﬀerent process.
4. Clients are required to eventually free the resources they hold once their
entire request has been satisﬁed.
The system should be designed such that it ensures the following two
properties.
•
Safety: no resource is simultaneously allocated to two diﬀerent clients.
•
Liveness: every request issued by some client is eventually satisﬁed.

The Speciﬁcation Language TLA+
395
2.2 A First TLA+ Speciﬁcation
A ﬁrst TLA+ speciﬁcation of the resource allocator appears in Fig. 1. Short-
comings of this model will be discussed in Sect. 6, where a revised speciﬁcation
will appear.
TLA+ speciﬁcations are organised in modules that contain declarations
(of parameters), deﬁnitions (of operators), and assertions (of assumptions
and theorems). Horizontal lines separate diﬀerent sections of the module
SimpleAllocator; these aid readability, but have no semantic content. TLA+
requires that an identiﬁer must be declared or deﬁned before it is used, and
that it cannot be reused, even as a bound variable, in its scope of validity.
The ﬁrst section declares that module SimpleAllocator is based on the
module FiniteSet, which is part of the TLA+ standard library (discussed
in Sect. 5). Next, the constant and variable parameters are declared. The
constants Clients and Resources represent the set of client processes and of
resources managed by the resource allocator. Constant parameters represent
entities whose values are ﬁxed during system execution, although they are
not deﬁned in the module because they may change from one system instance
to the next. Observe that there are no type declarations: TLA+ is based on
Zermelo-Fr¨ankel (ZF) set theory, so all values are sets. The set Resources is
assumed to be ﬁnite – the operator IsFiniteSet is deﬁned in module FiniteSet.
The variable parameters unsat and alloc represent the current state of the
allocator by recording the outstanding requests of the client processes, and
the set of resources allocated to the clients. In general, variable parameters
represent entities whose values change during system execution; in this sense,
they correspond to program variables.
The second section contains the deﬁnition of the operators TypeInvariant
and available. In general, deﬁnitions in TLA+ take the form
Op(arg1, . . . , argn)
∆= exp.
In TLA+, multi-line conjunctions or disjunctions are written as lists “bul-
leted” with the connective, and indentation indicates the hierarchy of nested
conjunctions and disjunctions [27]. The formula TypeInvariant states the in-
tended “types” of the state variables unsat and alloc, which are functions that
associate a set of (requested or received) resources to each client.1 Observe,
again, that the variables are not constrained to these types: TypeInvariant
just declares a formula, and a theorem towards the end of the module asserts
that the allocator speciﬁcation respects the typing invariant. This theorem
will have to be proven by considering the possible system transitions. The set
available is deﬁned to contain those resources that are currently not allocated
to any client.
The third section contains a list of deﬁnitions, which constitute the main
body of the allocator speciﬁcation. The state predicate Init represents the
1 In TLA+, the power set of a set S is written as subset S.

396
Stephan Merz
module SimpleAllocator
extends FiniteSet
constants Clients, Resources
assume IsFiniteSet(Resources)
variables
unsat,
unsat[c] denotes the outstanding requests of client c
alloc
alloc[c] denotes the resources allocated to client c
TypeInvariant
∆=
∧unsat ∈[Clients →subset Resources]
∧alloc ∈[Clients →subset Resources]
available
∆=
set of resources free for allocation
Resources \ (union {alloc[c] : c ∈Clients})
Init
∆=
initially, no resources have been requested or allocated
∧unsat = [c ∈Clients 7→{}]
∧alloc = [c ∈Clients 7→{}]
Request(c, S)
∆=
Client c requests set S of resources
∧S ̸= {} ∧unsat[c] = {} ∧alloc[c] = {}
∧unsat′ = [unsat except ![c] = S]
∧unchanged alloc
Allocate(c, S)
∆=
Set S of available resources are allocated to client c
∧S ̸= {} ∧S ⊆available ∩unsat[c]
∧alloc′ = [alloc except ![c] = @ ∪S]
∧unsat′ = [unsat except ![c] = @ \ S]
Return(c, S)
∆=
Client c returns a set of resources that it holds.
∧S ̸= {} ∧S ⊆alloc[c]
∧alloc′ = [alloc except ![c] = @ \ S]
∧unchanged unsat
Next
∆=
The system’s next−state relation
∃c ∈Clients, S ∈subset Resources :
Request(c, S) ∨Allocate(c, S) ∨Return(c, S)
vars
∆=
⟨unsat, alloc⟩
SimpleAllocator
∆=
The complete high−level speciﬁcation
∧Init ∧2[Next]vars
∧∀c ∈Clients : WFvars(Return(c, alloc[c]))
∧∀c ∈Clients : SFvars(∃S ∈subset Resources : Allocate(c, S))
Safety
∆=
∀c1, c2 ∈Clients : c1 ̸= c2 ⇒alloc[c1] ∩alloc[c2] = {}
Liveness
∆=
∀c ∈Clients, r ∈Resources : r ∈unsat[c] ; r ∈alloc[c]
theorem SimpleAllocator ⇒2TypeInvariant
theorem SimpleAllocator ⇒2Safety
theorem SimpleAllocator ⇒Liveness
Fig. 1. A Simple Resource Allocator.

The Speciﬁcation Language TLA+
397
initial condition of the speciﬁcation: no client has requested or received any
resources. The action formulas Request(c, S), Allocate(c, S), and Return(c, S)
model a client c requesting, receiving or returning a set S of resources. In these
formulas, unprimed occurrences of state variables (e.g., unsat) denote their
values in the state before the transition, whereas primed occurrences (e.g.,
unsat′) denote their values in the successor state, and unchanged t is just
a shorthand for t′ = t. Also, function application is written using square
brackets, so unsat[c] denotes the set of resources requested by client c. The
except construct models function update; more precisely, when t denotes a
value in the domain of function f , the expression [f except ![t] = e] denotes
the function g that agrees with f except that g[t] equals e. In the right-hand
side e of such an update, @ denotes the previous value f [t] of the function at
the argument position being updated. For example, the formule Allocate(c, S)
requires that S be a non-empty subset of available resources that are part of
the request of client c, allocates those resources to c, and removes them from
the set of outstanding requests of c.
The action formula Next is deﬁned as the disjunction of the request, allo-
cate, and return actions, for some client and some set of resources; it deﬁnes
the next-state relation of the resource allocator. Again, there is nothing spe-
cial about the names Init and Next, they are just conventional for denoting
the initial condition and the next-state relation.
The overall speciﬁcation of the resource allocator is given by the temporal
formula SimpleAllocator. It is deﬁned as a conjunction of the form
I ∧2[N ]v ∧L
where I is the initial condition (a state predicate), N is the next-state relation,
and L is a conjunction of fairness properties, each concerning a disjunct of the
next-state relation. While not mandatory, this is the standard form of system
speciﬁcations in TLA+, and it corresponds to the deﬁnition of a transition
system (or state machine) with fairness constraints. More precisely, the for-
mula 2[N ]v speciﬁes that every transition either satisﬁes the action formula
N or leaves the expression v unchanged. In particular, this formula admits
“stuttering transitions” that do not aﬀect the variables of interest. Stutter-
ing invariance is a key concept of TLA that simpliﬁes the representation of
reﬁnement, as well as compositional reasoning, and we will explore temporal
formulas and stuttering invariance in more detail in Sect. 3.4.
The initial condition and the next-state relation specify how the system
may behave. Fairness conditions complement this by asserting what actions
must occur (eventually). The weak fairness condition for the return action
states that clients should eventually return the resources they hold. The strong
fairness condition for resource allocation stipulates that for each client c, if it
is inﬁnitely often possible to allocate some resources to c, then the allocator
should eventually give some resources to c.
The following section deﬁnes the two main correctness properties Safety
and Liveness. Formula Safety asserts a safety property [10] of the model

398
Stephan Merz
CONSTANTS
Clients = {c1,c2,c3}
Resources = {r1,r2}
SPECIFICATION
SimpleAllocator
INVARIANTS
TypeInvariant Safety
PROPERTIES
Liveness
Fig. 2. Sample conﬁguration ﬁle for tlc.
by stating that no resource is ever allocated to two distinct clients. For-
mula Liveness represents a liveness property that asserts that whenever some
client c requests some resource r, that resource will eventually be allocated
to c.2 Observe that there is no formal distinction in TLA+ between a system
speciﬁcation and a property: both are expressed as formulas of temporal logic.
Asserting that speciﬁcation S has property F amounts to claiming validity
of the implication S ⇒F. Similarly, reﬁnement between speciﬁcations is ex-
pressed by (validity of) implication, and a single set of proof rules is used
to verify properties and reﬁnement; we will explore deductive veriﬁcation in
Sect. 4.
Finally, module SimpleAllocator asserts three theorems stating that the
speciﬁcation satisﬁes the typing invariant as well as the safety and liveness
properties deﬁned above. A formal proof language for TLA+, based on a
hierarchical proof format [29], is currently being designed.
2.3 Model Checking the Speciﬁcation
Whereas programs can be compiled and executed, TLA+ models can be val-
idated and veriﬁed. In this way, conﬁdence is gained that a model faithfully
reﬂects the intended system, and that it can serve as a basis for more detailed
designs, and ultimately for implementations. Tools can assist the designer in
carrying out these analyses. In particular, simulation lets a user explore some
traces, possibly leading to the detection of deadlocks or other unanticipated
behavior. Deductive tools such as model checkers and theorem provers assist
in the formal veriﬁcation of properties. The TLA+ model checker tlc is a
powerful and eminently usable tool for veriﬁcation and validation, and we
will now illustrate its use for the resource allocator model of Fig. 1.
tlc can compute and explore the state space of ﬁnite-state instances of
TLA+ models. Besides the model itself, tlc requires a second input ﬁle, called
the conﬁguration ﬁle, that deﬁnes the ﬁnite-state instance of the model to
2 The formula P ; Q asserts that any state that satisﬁes P will eventually be
followed by a state satisfying Q.

The Speciﬁcation Language TLA+
399
TLC Version 2.0 of January 16, 2006
Model-checking
Parsing file SimpleAllocator.tla
Parsing file /sw/tla/tlasany/StandardModules/FiniteSets.tla
Parsing file /sw/tla/tlasany/StandardModules/Naturals.tla
Parsing file /sw/tla/tlasany/StandardModules/Sequences.tla
Semantic processing of module Naturals
Semantic processing of module Sequences
Semantic processing of module FiniteSets
Semantic processing of module SimpleAllocator
Implied-temporal checking--satisfiability problem has 6 branches.
Finished computing initial states: 1 distinct state generated.
--Checking temporal properties for the complete state space...
Model checking completed. No error has been found.
Estimates of the probability that TLC did not check
all reachable states because two distinct states had
the same fingerprint:
calculated (optimistic):
2.673642557349254E-14
based on the actual fingerprints:
6.871173129000332E-15
1633 states generated, 400 distinct states found,
0 states left on queue.
The depth of the complete state graph search is 6.
Fig. 3. tlc output.
analyse, and that declares which of the formulas deﬁned in the model rep-
resents the system speciﬁcation and which are the properties to verify over
that ﬁnite-state instance.3 Figure 2 shows a conﬁguration ﬁle for analysing
module SimpleAllocator. Deﬁnitions of sets Clients and Resources ﬁx speciﬁc
instance of the model that tlc should consider. In our case, these sets consist
of symbolic constants. The keyword SPECIFICATION indicates which formula
represents the main system speciﬁcation, and the keywords INVARIANTS and
PROPERTIES deﬁne the properties to be veriﬁed by tlc. (For a more detailed
description of the format and the possible directives in conﬁguration ﬁles, see
Lamport’s book [30] and the tool documentation [24].)
Running tlc on this model produces an output similar to that shown in
Fig. 3; some details may vary according to the version and the installation of
tlc. First, tlc parses the TLA+ input ﬁle and checks it for well-formedness.
It then computes the graph of reachable states for the instance of our model
deﬁned by the conﬁguration ﬁle, verifying the invariants “on the ﬂy” as it
computes the state space. Finally, the temporal properties are veriﬁed over
the state graph. In our case, tlc reports that it has not found any error. In
order to improve eﬃciency, tlc compares states based on a hash code (“ﬁn-
gerprint”) during the computation of the state space, rather than comparing
3 tlc ignores any theorems asserted in the module.

400
Stephan Merz
them precisely. In the case of a hash collision, tlc will mistakenly identify two
distinct states and may therefore miss part of the state space. tlc attempts to
estimate the probability that such a collision occurred during the run, based
on the distribution of the ﬁngerprints. tlc also reports the number of states
it generated during its analysis, the number of distinct states, and the depth
of the state graph, i.e. the length of the longest cycle. These statistics can be
valuable information; for example, if the number of generated states is lower
than expected, some actions may have pre-conditions that never evaluate to
true. It is a good idea to use tlc to verify many, even trivial, properties, as
well as some non-properties. For example, one can attempt to assert the nega-
tion of each action guard as an invariant in order to let tlc compute a ﬁnite
execution that ends in a state where the action can actually be activated. For
our example, the tlc run completes in a few seconds; most of the running
time is spent on the veriﬁcation of property Liveness, which is expanded into
six properties, for each combination of clients and resources.
After this initial success, we can try to analyse somewhat larger instances,
but this quickly leads to the well-known problem of state-space explosion. For
example, increasing the number of resources from 2 to 3 in our model results in
a state graph that contains 8000 distinct states (among 45697 states generated
in all), and the analysis will take a few minutes instead of seconds.
One may observe that the speciﬁcation and the properties to be veriﬁed
are invariant with respect to permutations of the sets of clients and resources.
Such symmetries are frequent, and tlc implements a technique known as
symmetry reduction, which can counteract the eﬀect of state-space explosion.
In order to enable symmetry reduction, we simply extend the TLA+ module
by the deﬁnition of the predicate
Symmetry
∆=
Permutations(Clients) ∪Permutations(Resources)
(the operator Permutations is deﬁned in the standard TLC module, which
must therefore be added to the extends clause) and to indicate
SYMMETRY Symmetry
in the conﬁguration ﬁle. Unfortunately, the implementation of symmetry re-
duction in tlc is not compatible with checking liveness properties, and in
fact, tlc reports a meaningless “counter-example” when symmetry reduc-
tion is enabled during the veriﬁcation of the liveness property of our example.
However, when restricted to checking the invariants, symmetry reduction with
respect to both parameter sets reduces the number of states explored to 50
(respectively 309 for three clients and three resources), and the runtimes are
similarly reduced to fractions of a second for either conﬁguration.
We can use tlc to explore variants of our speciﬁcation. For example,
veriﬁcation succeeds when the strong fairness condition
∀c ∈Clients : SFvars(∃S ∈subset Resources : Allocate(c, S))
is replaced by the following condition about individual resources:

The Speciﬁcation Language TLA+
401
∀c ∈Clients, r ∈Resources : SFvars(Allocate(c, {r})).
However, the liveness condition is violated when the strong fairness condition
is replaced by either of the two following fairness conditions:
∀c ∈Clients : WFvars(∃S ∈subset Resources : Allocate(c, S))
SFvars(∃c ∈Clients, S ∈subset Resources : Allocate(c, S)).
It is a good exercise to understand these alternative fairness hypotheses in
detail and to explain the veriﬁcation results. Fairness conditions and their
representation in TLA are formally deﬁned in Sect. 3.3.
3 TLA: the Temporal Logic of Actions
TLA+ combines TLA, the Temporal Logic of Actions [28], and mathemati-
cal set theory. This section introduces the logic TLA by deﬁning its syntax
and semantics. In these deﬁnitions, we aim at formality and rigor; we do not
attempt to explain how TLA is used to specify algorithms or systems. Sec-
tions 4 and 5 explore respectively the veriﬁcation of temporal formulas and
the speciﬁcation of data structures in set theory.
3.1 Rationale
The logic of time has its origins in philosophy and linguistics, where it was
intended to formalize temporal references in natural language [23,39]. Around
1975, Pnueli [38] and others recognized that such logics could be useful as a
basis for the semantics of computer programs. In particular, traditional for-
malisms based on pre- and post-conditions were found to be ill-suited for
the description of reactive systems that continuously interact with their en-
vironment and are not necessarily intended to terminate. Temporal logic, as
it came to be called in computer science, oﬀered an elegant framework to
describe safety and liveness properties [10, 26] of reactive systems. Diﬀerent
dialects of temporal logic can be distinguished according to the properties
assumed of the underlying model of time (e.g., discrete or dense) and the
connectives available to refer to diﬀerent moments in time (e.g., future vs.
past references). For computer science applications, the most controversial
distinction has been between linear-time and branching-time logics. In the
linear-time view, a system is identiﬁed with the set of its executions, modeled
as inﬁnite sequences of states, whereas the branching-time view also considers
the branching structure of a system. Linear-time temporal logics, including
TLA, are appropriate for formulating correctness properties that must hold
of all the runs of a system. In contrast, branching-time temporal logics can
also express possibility properties, such as the existence of a path, from every
reachable state, to a “reset” state. The discussion of the relative merits and
deﬁciencies of these two kinds of temporal logics is beyond the scope of this

402
Stephan Merz
paper, but see, e.g., Vardi [44] for a good summary, with many references to
earlier papers.
Despite initial enthusiasm about temporal logic as a language to describe
system properties, attempts to actually write complete system speciﬁcations
as lists of properties expressed in temporal logic revealed that not even a
component as simple as a FIFO queue could be unambiguously speciﬁed [41].
This observation has led many researchers to propose that reactive systems
should be modelled as state machines, while temporal logic was retained as
a high-level language to describe the correctness properties. A major break-
through came with the insight that temporal logic properties are decidable
over ﬁnite-state models, and this has led to the development of model checking
techniques [15], which are today routinely applied to the analysis of hardware
circuits, communication protocols, and software.
A further weakness of standard temporal logic becomes apparent when
one attempts to compare two speciﬁcations of the same system, written at
diﬀerent levels of abstraction. Speciﬁcally, atomic system actions are usually
described via a “next-state” operator, but the “grain of atomicity” typically
changes during reﬁnement, making comparisons between speciﬁcations more
diﬃcult. For example, in Sect. 6 we will develop a speciﬁcation of the resource
allocator of Fig. 1 as a distributed system where the allocator and the clients
communicate by asynchronous message passing. Each of the actions will be
split into a subaction performed by the allocator, the corresponding subaction
performed by the client, and the message transmission over the network, and
these subactions will be interleaved with other system events. On the face
of it, the two speciﬁcations are hard to compare because they use diﬀerent
notions of “next state”.
TLA has been designed as a formalism where system speciﬁcations and
their properties are expressed in the same language, and where the reﬁnement
relation is reduced to logical implication. The problems mentioned above are
addressed in the following ways: TLA is particularly suited for writing state
machine speciﬁcations, augmented with fairness conditions, as we have seen in
the case of the resource allocator. It is often desirable to expose only that part
of the state used to specify a state machine that makes up its externally visible
interface, and TLA introduces quantiﬁcation over state variables to hide the
internal state, which a reﬁnement is free to implement in a diﬀerent manner.
The problem with incompatible notions of “next state” at diﬀerent levels of
abstraction is solved by systematically allowing for stuttering steps that do
not change the values of the (high-level) state variables. Low-level steps of
an implementation that change only new variables are therefore allowed by
the high-level speciﬁcation. Similar ideas can be found in Back’s reﬁnement
calculus [11] and in Abrial’s Event-B method [9,13]. Whereas ﬁnite stuttering
is desirable for a simple representation of reﬁnement, inﬁnite stuttering is usu-
ally undesirable, because it corresponds to livelock, and the above formalisms
rule it out via proof obligations that are expressed in terms of well-founded
orderings. TLA adopts a more abstract and ﬂexible approach because it as-

The Speciﬁcation Language TLA+
403
sociates fairness conditions, stated in temporal logic, with speciﬁcations, and
these must be shown to be preserved by the reﬁnement, typically using a mix
of low-level fairness hypotheses and well-founded ordering arguments.
Based on these concepts, TLA provides a uniﬁed logical language to ex-
press system speciﬁcations and their properties. A single set of logical rules is
used for system veriﬁcation and for proving reﬁnement.
3.2 Transition formulas
The language of TLA distinguishes between transition formulas, which de-
scribe states and state transitions, and temporal formulas, which characterize
behaviors (inﬁnite sequences of states). Basically, transition formulas are or-
dinary formulas of untyped ﬁrst-order logic, but TLA introduces a number of
speciﬁc conventions and notations.
Assume a signature of ﬁrst-order predicate logic4, consisting of:
•
at most denumerable sets LF and LP of function and predicate symbols,
each symbol of given arity, and
•
a denumerable set V of variables, partitioned into denumerable sets VF
and VR of ﬂexible and rigid variables.
These sets should be disjoint from one another; moreover, no variable in V
should be of the form v ′. By VF ′, we denote the set {v ′ | v ∈VF} of primed
ﬂexible variables, and by VE, the union V ∪VF ′ of all variables (rigid and
ﬂexible, primed or unprimed).
Transition functions and transition predicates (also called actions) are
ﬁrst-order terms and formulas built from the symbols in LF and LP, and
from the variables in VE. For example, if f is a ternary function symbol, p is
a unary predicate symbol, x ∈VR, and v ∈VF, then f (v, x, v ′) is a transition
function, and the formula
C
∆= ∃v ′ : p(f (v, x, v ′)) ∧¬(v ′ = x)
is an action. Collectively, transition functions and predicates are called tran-
sition formulas in the literature on TLA.
Transition formulas are interpreted according to ordinary ﬁrst-order logic
semantics: an interpretation I deﬁnes a universe |I| of values and interprets
each symbol in LF by a function and each symbol in LP by a relation of
appropriate arities. In preparation for the semantics of temporal formulas, we
distinguish between the valuations of ﬂexible and rigid variables. A state is
a mapping s : VF →|I| of the ﬂexible variables to values. Given two states
s and t and a valuation ξ : VR →|I| of the rigid variables, we deﬁne the
combined valuation αs,t,ξ of the variables in VE as the mapping such that
4 Recall that TLA can be deﬁned over an arbitrary ﬁrst-order language. The logic of
TLA+ is just TLA over a speciﬁc set-theoretical language that will be introduced
in Sect. 5.

404
Stephan Merz
αs,t,ξ(x) = ξ(x) for x ∈VR, αs,t,ξ(v) = s(v) for v ∈VF, and αs,t,ξ(v ′) = t(v)
for v ′ ∈VF ′. The semantics of a transition function or transition formula E,
written JEKI,ξ
s,t , is then simply the standard predicate logic semantics of E
with respect to the extended valuation αs,t,ξ. We omit any of the super- and
subscripts if there is no danger of confusion.
We say that a transition predicate A is valid for the interpretation I iﬀ
JAKI,ξ
s,t is true for all states s, t and all valuations ξ. It is satisﬁable iﬀJAKI,ξ
s,t
is true for some s, t, and ξ.
The notions of free and bound variables in a transition formula are deﬁned
as usual, with respect to the variables in VE, as is the notion of substitution
of a transition function a for a variable v ∈VE in a transition formula E,
written E[a/v]. We assume that capture of free variables in a substitution is
avoided by an implicit renaming of bound variables. For example, variables v
and x are free in the action C deﬁned above, whereas v ′ is bound. Observe
in particular that at the level of transition formulas, we consider v and v ′ to
be distinct, unrelated variables.
State formulas are transition formulas that do not contain free primed ﬂex-
ible variables. For example, the action C above is actually a state predicate.
Because the semantics of state formulas only depends on a single state, we
simply write JPKξ
s when P is a state formula. Transition formulas all of whose
free variables are rigid variables are called constant formulas; their semantics
depends only on the valuation ξ.
Beyond these standard concepts from ﬁrst-order logic, TLA introduces
some speciﬁc conventions and notations. If E is a state formula then E ′ is
the transition formula obtained from E by replacing each free occurrence of a
ﬂexible variable v in E with its primed counterpart v ′ (where bound variables
are renamed as necessary). For example, since the action C above is a state
formula with v as its single free ﬂexible variable, the formula C ′ is formed
by substituting v ′ for v. In doing so, the bound variable v ′ of C has to be
renamed, and we obtain the formula ∃y : p(f (v ′, x, y)) ∧¬(y = x).
For an action A, the state formula Enabled A is obtained by existential
quantiﬁcation over all primed ﬂexible variables that have free occurrences
in A. Thus, JEnabled AKξ
s holds if JAKξ
s,t holds for some state t; this is a
formal counterpart of the intuition that action A may occur in state s. For
actions A and B, the composite action A·B is deﬁned as ∃z : A[z/v ′]∧B[z/v]
where v is a list of all ﬂexible variables vi such that vi occurs free in B or
v ′
i occurs free in A, and z is a corresponding list of fresh variables. It follows
that JA · BKξ
s,t holds iﬀboth JAKξ
s,u and JBKξ
u,t hold for some state u.
Because many action-level abbreviations introduced by TLA are deﬁned
in terms of implicit quantiﬁcation and substitution, their interplay can be
quite delicate. For example, if P is a state predicate then Enabled P is
obviously just P, and therefore (Enabled P)′ equals P′. On the other hand,
Enabled (P′) is a constant formula – if P does not contain any rigid variables
then Enabled (P′) is valid iﬀP is satisﬁable. Similarly, consider the action

The Speciﬁcation Language TLA+
405
A
∆= v ∈Z ∧v ′ ∈Z ∧v ′ < 0
in the standard interpretation where Z denotes the set of integers, 0 denotes
the number zero, and ∗and < denote multiplication and the “less than”
relation. It is easy to see that Enabled A is equivalent to the state predicate
v ∈Z, hence (Enabled A)[(n ∗n)/v, (n′ ∗n′)/v ′] simpliﬁes to (n ∗n) ∈Z.
However, substituting in the deﬁnition of the action yields
A[(n ∗n)/v, (n′ ∗n′)/v ′] ≡(n ∗n) ∈Z ∧(n′ ∗n′) ∈Z ∧(n′ ∗n′) < 0,
which is equivalent to false, and so Enabled (A[(n ∗n)/v, (n′ ∗n′)/v ′]) is
again equivalent to false: substitution does not commute with the enabled
operator. Similar pitfalls exist for action composition A · B.
For an action A and a state function t one writes [A]t (pronounced “square
A sub t”) for A ∨t′ = t, and dually ⟨A⟩t (“angle A sub t”) for A ∧¬(t′ = t).
Therefore, [A]t is true of any state transition that satisﬁes A, but in ad-
dition permits so-called stuttering steps that leave (at least) the value of t
unchanged. Similarly, ⟨A⟩t demands that not only A be true but also that the
value of t changes during the transition. As we will see below, these constructs
are used to encapsulate action formulas in temporal formulas.
3.3 Temporal formulas
Syntax.
We now deﬁne the temporal layer of TLA, again with the aim of giving pre-
cise deﬁnitions of syntax and semantics. The inductive deﬁnition of temporal
formulas (or just “formulas”) is given as follows:
•
Every state formula is a formula.
•
Boolean combinations (connectives ¬, ∧, ∨, ⇒, and ≡) of formulas are
formulas.
•
If F is a formula then so is 2F (“always F”).
•
If A is an action and t is a state function then 2[A]t is a formula (pro-
nounced “always square A sub t”).
•
If F is a formula and x ∈VR is a rigid variable then ∃x : F is a formula.
•
If F is a formula and v ∈VF is a ﬂexible variable then ∃∃∃∃∃∃v : F is a formula.
In particular, an action A by itself is not a temporal formula, not even in
the form [A]t. Action formulas occur within temporal formulas only in subfor-
mulas 2[A]t. We assume quantiﬁers to have lower syntactic precedence than
the other connectives, so their scope extends as far to the right as possible.
At the level of temporal formulas, if v ∈VF is a ﬂexible variable, then
we consider unprimed occurrences v as well as primed occurrences v ′ to be
occurrences of v, and the quantiﬁer ∃∃∃∃∃∃binds both kinds of occurrences. More
formally, the set of free variables of a temporal formula is a subset of VF ∪VR.

406
Stephan Merz
The free occurrences of (rigid or ﬂexible) variables in a state formula P, con-
sidered as a temporal formula, are precisely the free occurrences in P, consid-
ered as a transition formula. However, variable v ∈VF has a free occurrence
in 2[A]t iﬀeither v or v ′ has a free occurence in A, or if v occurs in t. Sim-
ilarly, the substitution F[e/v] of a state function e for a ﬂexible variable v
substitutes both e for v and e′ for v ′ in the action subformulas of F, after
bound variables have been renamed as necessary. For example, substitution
of the state function h(v), where h ∈LF and v ∈VF, for w in the temporal
formula
∃∃∃∃∃∃v : p(v, w) ∧2[q(v, f (w, v ′), w ′)]g(v,w)
results in the formula, up to renaming of the bound variable,
∃∃∃∃∃∃u : p(u, h(v)) ∧2[q(u, f (h(v), u′), h(v ′))]g(u,h(v)).
Because state formulas do not contain free occurrences of primed ﬂexible
variables, the deﬁnitions of free and bound occurrences and of substitutions
introduced for transition formulas and for temporal formulas agree on state
formulas, and this observation justiﬁes the use of the same notation at both
levels of formulas. Substitutions of terms for primed variables or of proper
transition functions for variables are not deﬁned at the temporal level of TLA.
Semantics.
Given an interpretation I, temporal formulas are evaluated with respect to
an ω-sequence σ = s0s1 . . . of states si : VF →|I| (in the TLA literature, σ
is usually called a behavior), and with respect to a valuation ξ : VR →|I|
of the rigid variables. For a behavior σ = s0s1 . . ., we write σi to refer to
state si, and we write σ|i to denote the suﬃx sisi+1 . . . of σ. The following
inductive deﬁnition assigns a truth value JFKI,ξ
σ
∈{t, f} to temporal formulas;
the semantics of the quantiﬁer ∃∃∃∃∃∃over ﬂexible variables is deferred to Sect. 3.4.
•
JPKI,ξ
σ
= JPKI,ξ
σ0 : state formulas are evaluated at the initial state of the
behavior.
•
The semantics of Boolean operators is the usual one.
•
J2FKI,ξ
σ
= t iﬀJFKI,ξ
σ|i = t for all i ∈N: this is the standard “always”
connective from linear-time temporal logic.
•
J2[A]tKI,ξ
σ
= t iﬀfor all i ∈N, either JtKI,ξ
σi
= JtKI,ξ
σi+1 or JAKI,ξ
σi ,σi+1 = t
holds: the formula 2[A]t holds iﬀevery state transition in σ that modiﬁes
the value of t satisﬁes A.
•
J∃x : FKI,ξ
σ
= t iﬀJFKI,η
σ
= t for some valuation η : VR →|I| such that
η(y) = ξ(y) for all y ∈VR \ {x}: this is standard ﬁrst-order quantiﬁcation
over (rigid) variables.
Validity and satisﬁability of temporal formulas are deﬁned as expected.
We write |=I F (or simply |= F when I is understood) to denote that F is
valid for (all behaviors based on) the interpretation I.

The Speciﬁcation Language TLA+
407
Derived temporal formulas.
Abbreviations for temporal formulas include the universal quantiﬁers ∀and ∀∀∀∀∀∀
over rigid and ﬂexible variables. The formula 3F (“eventually F”), deﬁned as
¬2¬F, asserts that F holds of some suﬃx of the behavior; similarly, 3⟨A⟩t
(“eventually angle A sub t”) is deﬁned as ¬2[¬A]t and asserts that some
future transition satisﬁes A and changes the value of t. We write F ; G
(“F leads to G”) for the formula 2(F ⇒3G), which asserts that whenever
F is true, G will become true eventually. Combinations of the “always” and
“eventually” operators express “inﬁnitely often” (23) and “always from some
time onward” (32). Observe that a formula F can be both inﬁnitely often
true and inﬁnitely often false, thus 32F is strictly stronger than 23F. These
combinations are at the basis of expressing fairness conditions. In particular,
weak and strong fairness for an action ⟨A⟩t are deﬁned as
WFt(A)
∆=
(23¬Enabled ⟨A⟩t) ∨23⟨A⟩t
≡
32Enabled ⟨A⟩t ⇒23⟨A⟩t
≡
2(2Enabled ⟨A⟩t ⇒3⟨A⟩t)
SFt(A)
∆=
(32¬Enabled ⟨A⟩t) ∨23⟨A⟩t
≡
23Enabled ⟨A⟩t ⇒23⟨A⟩t
≡
2(23Enabled ⟨A⟩t ⇒3⟨A⟩t)
Informally, fairness conditions assert that an action should eventually oc-
cur if it is “often” enabled; they diﬀer in the precise interpretation of “often”.
Weak fairness WFt(A) asserts that the action ⟨A⟩t must eventually occur if it
remains enabled from some point onwards. In other words, the weak fairness
condition is violated if eventually Enabled ⟨A⟩t remains true without ⟨A⟩t
ever occurring.
The strong fairness condition, expressed by the formula SFt(A), requires
⟨A⟩t to occur inﬁnitely often provided that the action is inﬁnitely often en-
abled, although it need not remain enabled forever. Therefore, strong fairness
is violated if from some point onward, the action is repeatedly enabled, but
never occurs. It is a simple exercise in expanding the deﬁnitions of temporal
formulas to prove that the diﬀerent formulations of weak and strong fairness
given above are actually equivalent, and that SFt(A) implies WFt(A).
When specifying systems, the choice of appropriate fairness conditions for
system actions often requires some experience. Considering again the allocator
example of Fig. 1, it would not be enough to require weak fairness for the
Allocate actions because several clients may compete for the same resource:
allocation of the resource to one client disables allocating the resource to any
other client until the ﬁrst client returns the resource.

408
Stephan Merz
3.4 Stuttering invariance and quantiﬁcation
The formulas 2[A]t are characteristic of TLA. As we have seen, they allow for
“stuttering” transitions that do not change the value of the state function t.
In particular, repetitions of states can not be observed by formulas of this
form. Stuttering invariance is important in connection with reﬁnement and
composition [26], see also Sect. 3.5.
To formalize this notion, for a set V of ﬂexible variables we deﬁne two
states s and t to be V-equivalent, written s =V t, iﬀs(v) = t(v) for all v ∈V .
For any behavior σ, we deﬁne its V -unstuttered variant ♮V σ as the behavior
obtained by replacing every maximal ﬁnite subsequence of V-equivalent states
in σ by the ﬁrst state of that sequence. (If σ ends in an inﬁnite sequence of
states all of which are V-equivalent, that sequence is simply copied at the end
of ♮V σ.)
Two behaviors σ and τ are V-stuttering equivalent, written σ ≈V τ, if
♮V σ = ♮V τ. Intuitively, two behaviors σ and τ are V-stuttering equivalent
if one can be obtained from the other by inserting and/or deleting ﬁnite
repetitions of V-equivalent states. In particular, the relation ≈VF , which we
also write as ≈, identiﬁes two behaviors that agree up to ﬁnite repetitions of
identical states.
TLA is insensitive to stuttering equivalence: the following theorem states
that TLA is not expressive enough to distinguish stuttering-equivalent behav-
iors.
Theorem 0.1 (stuttering invariance). Assume that F is a TLA formula
whose free ﬂexible variables are among V, that σ ≈V τ are V-stuttering equiv-
alent behaviors, and that ξ is a valuation. Then JFKI,ξ
σ
= JFKI,ξ
τ
.
For the fragment of TLA formulas without quantiﬁcation over ﬂexible
variables, whose semantics has been deﬁned in Sect. 3.3, it is not hard to
prove Thm. 0.1 by induction on the structure of formulas [6,28]. However, its
extension to full TLA requires some care in the deﬁnition of quantiﬁcation
over ﬂexible variables: it would be natural to deﬁne that J∃∃∃∃∃∃v : FKI,ξ
σ
= t iﬀ
JFKI,ξ
τ
= t for some behavior τ whose states τi agree with the corresponding
states σi on all variables except for v. This deﬁnition, however, would not
preserve stuttering invariance. As an example, consider the formula F deﬁned
below:
F
∆= ∧v = c ∧w = c
∧3(w ̸= c) ∧2[v ̸= c]w
-
σ
v
w
c
c
d
c
d
d
· · ·
· · ·
Formula F asserts that both variables v and w initially equal the con-
stant c, that eventually w should be diﬀerent from c, and that v must be
diﬀerent from c whenever w changes value. In particular, F implies that the
value of v must change strictly before any change in the value of w, as illus-
trated in the picture. Therefore, σ1(w) must equal c.

The Speciﬁcation Language TLA+
409
Now consider the formula ∃∃∃∃∃∃v : F, and assume that τ is a behavior that
satisﬁes ∃∃∃∃∃∃v : F, according to the above deﬁnition. It follows that τ0(w) and
τ1(w) must both equal c, but that τi(w) is diﬀerent from c for some (smallest)
i > 1. The behavior τ|i−1 cannot satisfy ∃∃∃∃∃∃v : F because, intuitively, “there
is no room” for the internal variable v to change before w changes. However,
this is in contradiction to Thm. 0.1 because τ and τ|i−1 are {w}-stuttering
equivalent, and w is the only free ﬂexible variable of ∃∃∃∃∃∃v : F.
This problem is solved by deﬁning the semantics of ∃∃∃∃∃∃v : F in such a way
that stuttering invariance is ensured. Speciﬁcally, the behavior τ may contain
extra transitions that modify only the bound variable v. Formally, we say that
two behaviors σ and τ are equal up to v iﬀσi and τi agree on all variables
in VF \ {v}, for all i ∈N. We say that σ and τ are similar up to v, written
σ ≃v τ iﬀthere exist behaviors σ′ and τ ′ such that
•
σ and σ′ are stuttering equivalent (σ ≈σ′),
•
σ′ and τ ′ are equal up to v, and
•
τ ′ and τ are again stuttering equivalent (τ ′ ≈τ).
Being deﬁned as the composition of equivalence relations, ≃v is itself an equiv-
alence relation.
Now, we deﬁne J∃∃∃∃∃∃v : FKI,ξ
σ
= t iﬀJFKI,ξ
τ
= t holds for some behavior
τ ≃v σ. This deﬁnition can be understood as “building stuttering invariance
into” the semantics of ∃∃∃∃∃∃v : F. It therefore ensures that Thm. 0.1 holds for all
TLA formulas.
3.5 Properties, reﬁnement, and composition
We have already seen in the example of the resource allocator that TLA
makes no formal distinction between system speciﬁcations and their proper-
ties: both are represented as temporal formulas. It is conventional to write
system speciﬁcations in the form
∃∃∃∃∃∃x : Init ∧2[Next]v ∧L
where v is a tuple of all state variables used to express the speciﬁcation, the
variables x are internal (hidden), Init is a state predicate representing the
initial condition, Next is an action that describes the next-state relation, usu-
ally written as a disjunction of individual system actions, and where L is a
conjunction of formulas WFv(A) or SFv(A) asserting fairness assumptions of
disjuncts of Next. However, other forms of system speciﬁcations are possible
and can occasionally be useful. Asserting that a system (speciﬁed by) S sat-
isﬁes a property F amounts to requiring that every behavior that satisﬁes
S must also satisfy F; in other words, it asserts the validity of the implica-
tion S ⇒F. For example, the theorems asserted in module SimpleAllocator
(Fig. 1) state three properties of the resource allocator.

410
Stephan Merz
System reﬁnement.
TLA was designed to support stepwise system development based on a notion
of reﬁnement. In such an approach, a ﬁrst, high-level speciﬁcation formally
states the problem at a high level of abstraction. A series of intermediate
models then introduce detail, adding algorithmic ideas. The development is
ﬁnished when a model is obtained that is detailed enough so that an imple-
mentation can be read oﬀimmediately or even mechanically generated (for
example, based on models of shared-variable or message-passing systems).
The fundamental requirement for useful notions of reﬁnement is that they
must preserve system properties, such that properties established at a higher
level of abstraction are guaranteed to hold for later models, including the ﬁnal
implementation. In this way, crucial correctness properties can be proven (or
errors can be detected) early on, simplifying their proofs or the correction of
the model, and these properties need never be reproven for later reﬁnements.
A lower-level model, expressed by a TLA formula C, preserves all TLA
properties of an abstract speciﬁcation A if and only if for every formula F,
if A ⇒F is valid, then so is C ⇒F. This condition is in turn equivalent to
requiring the validity of C ⇒A. Because C is expressed at a lower level of
abstraction, it will typically admit transitions that are invisible at the higher
level, acting on state variables that do not appear in A. The stuttering invari-
ance of TLA formulas is therefore essential to make validity of implication a
reasonable deﬁnition of reﬁnement.
Assume that we are given two system speciﬁcations Abs and Conc in
standard form
Abs
∆= ∃∃∃∃∃∃x : AInit ∧2[ANext]v ∧AL
and
Conc
∆= ∃∃∃∃∃∃y : CInit ∧2[CNext]w ∧CL.
Proving that Conc reﬁnes Abs amounts to showing the validity of the impli-
cation Conc ⇒Abs, and using standard quantiﬁer reasoning, this reduces to
proving
(CInit ∧2[CNext]w ∧CL) ⇒(∃∃∃∃∃∃x : AInit ∧2[ANext]v ∧AL).
The standard approach for proving the latter implication is to deﬁne a state
function t in terms of the free variables w (including y) of the left-hand side,
and to prove
(CInit ∧2[CNext]w ∧CL) ⇒(AInit ∧2[ANext]v ∧AL)[t/x].
In the computer science literature, the state function t is usually called a
reﬁnement mapping. Proof rules for reﬁnement will be considered in some
more detail in Sect. 4.5. A typical example for system reﬁnement in TLA+
will be given in Sect. 6.3 where a “distributed” model of the resource allocator
will be developed that distinguishes between actions of the allocator and those
of the clients.

The Speciﬁcation Language TLA+
411
-
in
-
out
q
(a) Pictorial representation.
module InternalFIFO
extends Sequences
constant Message
variables in, out, q
NoMsg
∆= choose x : x /∈Message
Init
∆= q = ⟨⟩∧in = NoMsg ∧out = NoMsg
Enq
∆= in′ ∈Message \ {in} ∧q′ = Append(q, in′) ∧out′ = out
Deq
∆= q ̸= ⟨⟩∧out′ = Head(q) ∧q′ = Tail(q) ∧in′ = in
Next
∆= Enq ∨Deq
vars
∆= ⟨in, out, q⟩
IFifo
∆= Init ∧2[Next]vars ∧WFvars(Deq)
(b) Internal speciﬁcation.
module FIFO
constant Message
variables in, out
Internal(q)
∆= instance InternalFIFO
Fifo
∆= ∃∃∃∃∃∃q : Internal(q)!IFifo
(c) Interface speciﬁcation.
Fig. 4. Speciﬁcation of a FIFO queue.
Composition of systems.
Stuttering invariance is also essential for obtaining a simple representation of
the (parallel) composition of components, represented by their speciﬁcations.
In fact, assume that A and B are speciﬁcations of two components that we
wish to compose in order to form a larger system. Each of these formulas
describes the possible behaviors of the “part of the world” relevant for the
respective component, represented by the state variables that have free occur-
rences in the component speciﬁcation. A system that contains both compo-
nents (possibly among other constituents) must therefore satisfy both A and
B: composition is conjunction. Again, state transitions that correspond to a
local action of one of the components are allowed because they are stutter-
ing transitions of the other components. Any synchronisation between the two
components is reﬂected in changes of a common state variable (the component
interfaces), and these changes must be allowed by both components.

412
Stephan Merz
As a test of these ideas, consider the speciﬁcation of a FIFO queue shown
in Fig. 4 that is written in the canonical form of TLA speciﬁcations. The
queue receives inputs via the channel in and sends its outputs via the channel
out; it stores values that have been received but not yet sent in an internal
queue q. Initially, we assume that the channels hold some “null” value and
that the internal queue is empty. An enqueue action, described by action Enq,
is triggered by the reception of a new message (represented as a change of the
input channel in); it appends the new input value to the internal queue. A
dequeue action, speciﬁed by action Deq, is possible whenever the internal
queue is non-empty: the value at the head of the queue is sent over channel
out and removed from the queue.
We expect that two FIFO queues in a row implement another FIFO queue.
Formally, let us assume that the two queues are connected by a channel mid,
then the above principles lead us to expect that the formula5
Fifo[mid/out] ∧Fifo[mid/in] ⇒Fifo
is valid. Unfortunately, this is not true, for the following reason: formula Fifo
implies that the in and out channels never change simultaneously, whereas the
conjunction on the left-hand side allows such changes (if the left-hand queue
performs an Enq action, while the right-hand queue performs a Deq). This
technical problem can be attributed to a design decision taken in the speciﬁ-
cation of the FIFO queue to disallow simultaneous changes to its input and
output interfaces, a speciﬁcation style known as “interleaving speciﬁcations”.
In fact, the above argument shows that the composition of two queues speci-
ﬁed in interleaving style does not implement an interleaving queue. The choice
of an interleaving or a non-interleaving speciﬁcation style is made by the per-
son who writes the speciﬁcation; interleaving speciﬁcations are usually found
easier to write and to understand. The problem disappears if we explicitly
add an “interleaving” assumption for the composition: the implication
Fifo[mid/out] ∧Fifo[mid/in] ∧2[in′ = in ∨out′ = out]in,out
⇒Fifo
(1)
is valid and its proof will be considered in Sect. 4.5. Alternatively, one can
write a non-interleaving speciﬁcationof a queue that allows for input and out-
put actions to occur simultaneously.
3.6 Variations and extensions
We discuss some of the choices that we have made in the presentation of TLA,
as well as possible extensions.
5 TLA+ introduces concrete syntax, based on module instantiation, for writing
substitutions such as Fifo[mid/out].

The Speciﬁcation Language TLA+
413
Transition Formulas and Priming.
Our presentation of TLA is based on standard ﬁrst-order logic, to the ex-
tent possible. In particular, we have deﬁned transition formulas as formulas
of ordinary predicate logic over a large set VE of variables where v and v ′ are
unrelated. An alternative presentation would consider ′ as an operator, resem-
bling the next-time modality of temporal logic. The two styles of presentation
result in the same semantics of temporal formulas. The style adopted in this
paper corresponds well to the veriﬁcation rules of TLA, explored in Sect. 4,
where action-level hypotheses are considered as ordinary ﬁrst-order formulas
over an extended set of variables.
Compositional Veriﬁcation.
We have argued in Sect. 3.5 that composition is represented in TLA as con-
junction. Because components can rarely be expected to operate correctly in
arbitrary environments, their speciﬁcations usually include some assumptions
about the environment. An open system speciﬁcation is one that does not con-
strain its environment; it asserts that the component will function correctly
provided that the environment behaves as expected. One way to write such
speciﬁcations is in the form of implications E ⇒M where E describes the
environment assumptions and M , the component speciﬁcation. However, it
turns out that often a stronger form of speciﬁcations is desirable that requires
the component to adhere to its description M for at least as long as the envi-
ronment has not broken its obligation E. In particular, when systems are built
from “open” component speciﬁcations, this form, written E
+−⊲M , admits a
strong composition rule that can discharge mutual assumptions between com-
ponents [4,16]. It can be shown that the formula E
+−⊲M is actually deﬁnable
in TLA, and that the resulting composition rule can be justiﬁed in terms
of an abstract logic of speciﬁcations, supplemented by principles speciﬁc to
TLA [5,7].
TLA*.
The language of TLA distinguishes the tiers of transition formulas and tem-
poral formulas; transition formulas must be guarded by “brackets” to ensure
stuttering invariance. Although the separation between the two tiers is nat-
ural when writing system speciﬁcations, it is not a prerequisite to obtaining
stuttering invariance. The logic TLA* [37] generalizes TLA in that it distin-
guishes between pure and impure temporal formulas. Whereas pure formulas
of TLA* contain impure formulas in the same way that temporal formulas of
TLA contain transition formulas, impure formulas generalize transition for-
mulas in that they admit Boolean combinations of F and cG, where F and
G are pure formulas and c is the next-time modality of temporal logic. For
example, the TLA* formula
2

A ⇒c3⟨B⟩u

t

414
Stephan Merz
requires that every ⟨A⟩t action must eventually be followed by ⟨B⟩u. Assuming
appropriate syntactic conventions, TLA* is a generalization of TLA because
every TLA formula is also a TLA* formula, with the same semantics. On
the other hand, it can be shown that every TLA* formula can be expressed
in TLA using some additional quantiﬁers. For example, the TLA* formula
above is equivalent to the TLA formula6
∃∃∃∃∃∃v : ∧2((v = c) ≡3⟨B⟩u)
∧2[A ⇒v ′ = c]t
where c is a constant and v is a fresh ﬂexible variable. TLA* thus oﬀers a
richer syntax without increasing the expressiveness, allowing high-level re-
quirement speciﬁcations to be expressed more directly. (Kaminski [22] shows
that TLA* without quantiﬁcation over ﬂexible variables is strictly more ex-
pressive than the corresponding fragment of TLA). Besides oﬀering a more
natural way to write temporal properties beyond standard system speciﬁca-
tions, the propositional fragment of TLA* admits a straightforward complete
axiomatization. (No complete axiomatization is known for propositional TLA,
although Abadi [1] axiomatized an early version of TLA that was not invariant
under stuttering.) For example,
2[F ⇒cF]v ⇒(F ⇒2F)
where F is a temporal formula and v is a tuple containing all ﬂexible variables
with free occurrences in F, is a TLA* formulation of the usual induction axiom
of temporal logic; this is a TLA formula only if F is in fact a state formula.
Binary Temporal Operators.
TLA can be considered as a fragment of the standard linear-time temporal
logic LTL [35]. In particular, TLA does not include binary operators such as
until. The main reason for that omission is the orientation of TLA towards
writing speciﬁcations of state machines, where such operators are not neces-
sary. Moreover, nested occurrences of binary temporal operators can be hard
to interpret. Nevertheless, binary temporal operators are deﬁnable in TLA
using quantiﬁcation over ﬂexible variables. For example, suppose that P and
Q are state predicates whose free variables are among the tuple w of vari-
ables, that v is a ﬂexible variable that does not appear in w, and that c is a
constant. Then P until Q can be deﬁned as the formula
∃∃∃∃∃∃v : ∧(v = c) ≡Q
∧2[(v ̸= c ⇒P) ∧(v ′ = c ≡(v = c ∨Q′))]⟨v,w⟩
∧3Q
The idea is to use the auxiliary variable v to remember whether Q has already
been true. As long as Q has been false, P is required to hold. For arbitrary
6 Strictly, this equivalence is true only for universes that contain at least two distinct
values; one-element universes are not very interesting.

The Speciﬁcation Language TLA+
415
TLA formulas F and G, the formula F until G can be deﬁned along the
same lines, using a similar technique as shown for the translation of TLA*
formulas above.
4 Deductive System Veriﬁcation in TLA
Because TLA formulas are used to describe systems as well as their properties,
proof rules for system veriﬁcation are just logical axioms and rules of TLA.
More precisely, a system described by formula Spec has property Prop if and
only if every behavior that satisﬁes Spec also satisﬁes Prop, that is, iﬀthe im-
plication Spec ⇒Prop is valid. (To be really precise, the implication should be
valid over the class of interpretations where the function and predicate sym-
bols have the intended meaning.) System veriﬁcation, in principle, therefore
requires reasoning about sets of behaviors. The TLA proof rules are designed
to reduce this temporal reasoning, whenever possible, to the proof of veriﬁ-
cation conditions expressed in the underlying predicate logic, a strategy that
is commonly referred to as assertional reasoning. In this section, we present
some typical rules and illustrate their use. We are not trying to be exhaustive,
more information can be found in Lamport’s original TLA paper [28].
4.1 Invariants
Invariants characterize the set of states that can be reached during system
execution; they are the basic form of safety properties and the starting point
for any form of system veriﬁcation. In TLA, an invariant is expressed by a
formula of the form 2I , for a state formula I .
A basic rule for proving invariants is given by
I ∧[N ]t ⇒I ′
(INV1)
I ∧2[N ]t ⇒2I
This rule asserts that whenever the hypothesis I ∧[N ]t ⇒I ′ is valid as
a transition formula, the conclusion I ∧2[N ]t ⇒2I is a valid temporal
formula. The hypothesis states that every possible transition (stuttering or
not) preserves I ; thus, if I holds initially it is guaranteed to hold forever.
Formally, the correctness of rule (INV1) is easily established by induction on
behaviors. Because the hypothesis is a transition formula, it can be proven
using ordinary ﬁrst-order reasoning, including “data” axioms that characterize
the intended interpretations.
For example, we can use the invariant rule (INV1) to prove the invari-
ant 2(q ∈Seq(Message)) of the FIFO queue that was speciﬁed in module
InternalFIFO of Fig. 4(b). We have to prove
IFifo ⇒2(q ∈Seq(Message))
(2)

416
Stephan Merz
which, by rule (INV1), the deﬁnition of formula IFifo, and propositional logic
can be reduced to proving
Init ⇒q ∈Seq(Message)
(3)
q ∈Seq(Message) ∧[Next]vars ⇒q′ ∈Seq(Message)
(4)
Because the empty sequence is certainly a ﬁnite sequence of messages, the
proof obligation (3) follows from the deﬁnition of Init and appropriate data
axioms. Similarly, the proof of (4) reduces to proving preservation of the in-
variant by the Deq and Enq actions, as well as under stuttering, and these
proofs are again straightforward.
The proof rule (INV1) requires that the invariant I is inductive: it must
be preserved by every possible system action. As with ordinary mathematical
induction, it is usually necessary to strengthen the assertion and ﬁnd an “in-
duction hypothesis” that makes the proof go through. This idea is embodied
in the following derived invariant rule
Init ⇒I
I ∧[Next]t ⇒I ′
I ⇒J (INV)
Init ∧2[Next]t ⇒2J
In this rule, I is an inductive invariant that implies J. The creative step
consists in ﬁnding this inductive invariant. Typically, inductive invariants con-
tain interesting “design” information about the model and represent the over-
all correctness idea. Some formal design methods, such as the B method [8,13]
therefore demand that an inductive invariant be documented with the system
model.
For example, suppose we wish to prove that any two consecutive elements
of the queue are diﬀerent. This property can be expressed in TLA+ by the
state predicate
J
∆= ∀i ∈1..Len(q) −1 : q[i] ̸= q[i + 1]
We have used some TLA+ syntax for sequences in writing formula J; in par-
ticular, a sequence s in TLA+ is represented as a function whose values can be
accessed as s[1], . . . , s[Len(s)]. The sequence formed of the values e1, . . . , en
is written as ⟨e1, . . . , en⟩, and the concatenation of two sequences s and t is
written s ◦t.
The invariant rule (INV1) is not strong enough to prove that J is an
invariant, because J is not necessarily preserved by the Enq step: there is no
information about how the old value in of the input channel relates to the
values in the queue. (Try this proof yourself to see why it fails.) The proof
succeeds using rule (INV) and the inductive invariant
Inv
∆=
let oq
∆= ⟨out⟩◦q
in
∧in = oq[Len(oq)]
∧∀i ∈1..Len(oq) −1 : oq[i] ̸= oq[i + 1]

The Speciﬁcation Language TLA+
417
which asserts that the current value of the input channel can either be found
as the last element of the queue or (if the queue is empty) as the current value
of the output channel.
4.2 Step simulation
When proving reﬁnement between two TLA speciﬁcations, a crucial step is to
show that the next-state relation of the lower-level speciﬁcation, say expressed
as 2[M ]t, simulates the next-state relation 2[N ]u of the higher-level one, up
to stuttering. The following proof rule is used for this purpose; it relies on a
previously proven state invariant I :
I ∧I ′ ∧[M ]t ⇒[N ]u (TLA2)
2I ∧2[M ]t ⇒2[N ]u
In particular, it follows from (TLA2) that the next-state relation can be
strengthened by an invariant:
2I ∧2[M ]t ⇒2[M ∧I ∧I ′]t
Note that the converse of this implication is not valid: the right-hand side
holds of any behavior where t never changes, independently of the formula I .
We may use (TLA2) to prove that the FIFO queue never dequeues the
same value twice in a row:
IFifo ⇒2[Deq ⇒out′ ̸= out]vars
(5)
For this proof, we make use of the inductive invariant Inv introduced in
Sect. 4.1 above. By rule (TLA2), we have to prove
Inv ∧Inv ′ ∧[Next]vars ⇒[Deq ⇒out′ ̸= out]vars
(6)
The proof of (6) reduces to the three cases of a stuttering transition, an
Enq action, and a Deq action. Only the last case is non-trivial. Its proof
relies on the deﬁnition of Deq, which implies that q is non-empty and that
out′ = Head(q). In particular, the sequence oq contains at least two elements,
and therefore Inv implies that oq[1], which is just out, is diﬀerent from oq[2],
which is Head(q). This suﬃces to prove out′ ̸= out.
4.3 Liveness properties
Liveness properties, intuitively, assert that something good must eventually
happen [10,25]. Because formulas 2[N ]t are satisﬁed by a system that always
stutters, the proof of liveness properties must ultimately rely on fairness prop-
erties assumed of the speciﬁcation. TLA provides rules to deduce elementary
liveness properties from the fairness properties assumed of a speciﬁcation.
More complex properties can then be inferred with the help of well-founded
orderings.

418
Stephan Merz
The following rule can be used to prove a leads-to formula from a weak
fairness assumption, a similar rule exists for strong fairness.
I ∧I ′ ∧P ∧[N ]t ⇒P′ ∨Q′
I ∧I ′ ∧P ∧⟨N ∧A⟩t ⇒Q′
I ∧P ⇒Enabled ⟨A⟩t
(WF1)
2I ∧2[N ]t ∧WFt(A) ⇒(P ; Q)
In this rule, I , P, and Q are state predicates, I is again an invariant, [N ]t
represents the next-state relation, and ⟨A⟩t is a “helpful action” [34] for which
weak fairness is assumed. Again, all three premises of (WF1) are transition
formulas. To see why the rule is correct, assume that σ is a behavior satisfying
2I ∧2[N ]t ∧WFt(A), and that P holds of state σi. We have to show that
Q holds of some σj with j ≥i. By the ﬁrst premise, any successor of a state
satisfying P has to satisfy P or Q, so P must hold for as long as Q has not
been true. The third premise ensures that in all of these states, action ⟨A⟩t
is enabled, and so the assumption of weak fairness ensures that eventually
⟨A⟩t occurs (unless Q has already become true before). Finally, by the second
premise, any ⟨A⟩t-successor (which, by assumption, is in fact an ⟨N ∧A⟩t-
successor) of a state satisfying P must satisfy Q, which proves the claim.
For our running example, we can use rule (WF1) to prove that every
message stored in the queue will eventually move closer to the head of the
queue or even to the output channel. Formally, let the state predicate at(k, x)
be deﬁned by
at(k, x)
∆= k ∈1..Len(q) ∧q[k] = x
We will use (WF1) to prove
FifoI ⇒
 at(k, x) ; (out = x ∨at(k −1, x))

(7)
where k and x are rigid variables. The following proof outline illustrates
the application of rule (WF1), the lower-level steps are all inferred by non-
temporal reasoning and are omitted.
1. at(k, x) ∧[Next]vars ⇒at(k, x)′ ∨out′ = x ∨at(k −1, x)′
1.1. at(k, x) ∧m ∈Message ∧Enq ⇒at(k, x)′
1.2. at(k, x) ∧Deq ∧k = 1 ⇒out′ = x
1.3. at(k, x) ∧Deq ∧k > 1 ⇒at(k −1, x)′
1.4. at(k, x) ∧vars′ = vars ⇒at(k, x)′
1.5. Q.E.D.
From steps 1.1–1.4 by the deﬁnitions of Next and at(k, x).
2. at(k, x) ∧⟨Deq ∧Next⟩vars ⇒out′ = x ∨at(k −1, x)′
Follows from steps 1.2 and 1.3 above.
3. at(k, x) ⇒Enabled ⟨Deq⟩vars
For any k, at(k, x) implies that q ̸= ⟨⟩and thus the enabledness condition.
However, rule (WF1) cannot be used to prove the stronger property that
every input to the queue will eventually be dequeued, expressed by the TLA
formula

The Speciﬁcation Language TLA+
419
FifoI ⇒∀m ∈Message : in = m ; out = m
(8)
because there is no single “helpful action”: the number of Deq actions nec-
essary to produce the input element on the output channel depends on the
length of the queue. Intuitively, the argument used to establish property (7)
must be iterated. The following rule formalizes this idea as an induction over
a well-founded relation (D, ≻), i.e. a binary relation such that there does not
exist an inﬁnite descending chain d1 ≻d2 ≻. . . of elements di ∈D.
(D, ≻) is well−founded
F ⇒∀d ∈D :
 G ; (H ∨∃e ∈D : d ≻e ∧G[e/d])

(LATTICE)
F ⇒∀d ∈D : (G ; H )
In this rule, d and e are rigid variables such that d does not occur in H and
e does not occur in G. For convenience, we have stated rule (LATTICE) in a
language of set theory. Also, we have taken the liberty to state the assumption
that (D, ≻) is well-founded as if it were a logical hypothesis. As an illustration
of the expressiveness of TLA, we observe in passing that in principle this
hypothesis could be stated by the temporal formula
∧∀d ∈D : ¬(d ≻d)
∧∀∀∀∀∀∀v : 2(v ∈D) ∧2[v ≻v ′]v ⇒32[false]v
whose ﬁrst conjunct expresses the irreﬂexivity of ≻and whose second conjunct
asserts that any sequence of values in D that can only change by decreasing
with respect to ≻must eventually become stationary. In system veriﬁcation,
well-foundedness is however usually considered as a “data axiom” and is out-
side the scope of temporal reasoning.
Unlike the premises of the rules considered so far, the second hypothe-
sis of rule (LATTICE) is itself a temporal formula that requires that every
occurrence of G, for any value d ∈D, be followed either by an occurrence
of H , or again by some G, for some smaller value e. Because there cannot
be an inﬁnite descending chain of values in D, eventually H must become
true. In applications of rule (LATTICE), this hypothesis must be discharged
by another rule for proving liveness, either a fairness rule such as (WF1) or
another application of (LATTICE).
Choosing (N, >), the set of natural numbers with the standard “greater-
than” relation as the well-founded domain, the proof of the liveness property
(8) that asserts that the FIFO queue eventually outputs every message it
receives can be derived from property (7) and the invariant Inv of Sect. 4.1
using rule (LATTICE).
Lamport [28] lists further (derived) rules for liveness properties, including
introduction rules for proving formulas WFt(A) and SFt(A) that are necessary
when proving reﬁnement.

420
Stephan Merz
(STL1)
F
2F
(STL4)
2(F ⇒G) ⇒(2F ⇒2G)
(STL2)
2F ⇒F
(STL5)
2(F ∧G) ≡(2F ∧2G)
(STL3)
22F ≡2F
(STL6)
32(F ∧G) ≡(32F ∧32G)
Fig. 5. Rules of simple temporal logic.
4.4 Simple temporal logic
The proof rules considered so far support the derivation of typical correctness
properties of systems. In addition, TLA satisﬁes standard axioms and rules of
linear-time temporal logic that are useful when preparing the application of
veriﬁcation rules. Figure 5 contains the axioms and rules of “simple temporal
logic”, adapted from Lamport [28]. It can be shown that this is just a non-
standard presentation of the modal logic S4.2 [20], implying that these laws by
themselves characterize a modal accessibility relation for 2 that is reﬂexive,
transitive, and locally convex (conﬂuent). The latter condition asserts that for
any state s and states t, u that are both accessible from s there is a state v
that is accessible from t and u.
Many derived laws of temporal logic are useful for system veriﬁcation.
Particularly useful are rules about the “leadsto” operator such as
F ⇒G
F ; G
F ; G
G ; H
F ; H
F ; H
G ; H
(F ∨G) ; H
F ⇒2G
F ; H
F ; (G ∧H )
In principle, such temporal logic rules can be derived from the rules of
Fig. 5. In practice, it can be easier to justify them from the semantics of
temporal logic. Because validity of propositional temporal logic is decidable,
they can be checked automatically by freely available tools.
4.5 Quantiﬁer rules
Although we have seen in section 3.4 that the semantics of quantiﬁcation over
ﬂexible variables is non-standard, the familiar proof rules from ﬁrst-order logic
are sound for both types of quantiﬁers:
F[c/x] ⇒∃x : F (∃I)
F ⇒G
(∃E)
(∃x : F) ⇒G
F[t/v] ⇒∃∃∃∃∃∃v : F (∃∃∃∃∃∃I)
F ⇒G
(∃∃∃∃∃∃E)
(∃∃∃∃∃∃v : F) ⇒G

The Speciﬁcation Language TLA+
421
In these rules, x is a rigid and v is a ﬂexible variable. The elimination rules
(∃E) and (∃∃∃∃∃∃E) require the usual proviso that the bound variable should not
be free in formula G. In the introduction rules, t is a state function, while c
is a constant function. Observe that if we allowed an arbitrary state function
in rule (∃I), we could prove
∃x : 2(v = x)
(9)
for any state variable v from the premise 2(v = v), provable by (STL1).
However, formula (9) asserts that v remains constant throughout a behavior,
which can obviously not be valid.
Since existential quantiﬁcation over ﬂexible variables corresponds to hiding
of state components, the rules (∃∃∃∃∃∃I) and (∃∃∃∃∃∃E) play a fundamental role in
proofs of reﬁnement for reactive systems. In this context, the “witness” t
is often called a reﬁnement mapping [2]. For example, the concatenation of
the two low-level queues provides a suitable reﬁnement mapping to prove
the validity of formula (1), which claimed that two FIFO queues in a row
implement a FIFO queue, assuming interleaving of changes to the input and
output channels.
Although the quantiﬁer rules are standard, one should recall from Sect. 3.2
that care has to be taken when substitutions are applied to formulas that
contain implicit quantiﬁers. In particular, the formulas WFt(A) and SFt(A)
contain the subformula Enabled ⟨A⟩t, and therefore WFt(A)[e/v] is not gen-
erally equivalent to the formula WFt[e/v](A[e/v, e′/v ′]). The consequences of
this inequivalence for system veriﬁcation are discussed in more detail in Lam-
port’s original TLA paper [28].
In general, reﬁnement mappings need not always exist. For example, (∃∃∃∃∃∃I)
cannot be used to prove the TLA formula
∃∃∃∃∃∃v : 23⟨true⟩v
(10)
that is valid, except over universes that contain a single element. Formula (10)
asserts the existence of a ﬂexible variable whose value changes inﬁnitely often.
(Such a variable can be seen as an “oscillator”, triggering system transitions.)
In fact, an attempt to prove (10) by rule (∃∃∃∃∃∃I) would require exhibiting a state
function t whose value is certain to change inﬁnitely often in any behavior.
Such a state function cannot exist: consider a behavior σ that ends in inﬁnite
stuttering, then the value of t never changes over the stuttering part of σ.
An approach to solving this problem, introduced in [2], consists of adding
auxiliary variables such as history and prophecy variables. Formally, this ap-
proach consists in adding special introduction rules for auxiliary variables.
The proof of G ⇒∃∃∃∃∃∃v : F is then reduced to ﬁrst proving a formula of the
form G ⇒∃∃∃∃∃∃a : Gaux using a rule for auxiliary variables, and then use the
rules (∃∃∃∃∃∃E) and (∃∃∃∃∃∃I) above to prove G ∧Gaux ⇒∃∃∃∃∃∃v : F. The details are
beyond the scope of this introductory overview.

422
Stephan Merz
5 Formalized Mathematics: the Added Value of TLA+
The deﬁnitions of the syntax and semantics of TLA in Sect. 3 were given
with respect to an arbitrary language of predicate logic and its interpretation.
TLA+ instantiates this generic deﬁnition of TLA with a speciﬁc ﬁrst-order
language, namely Zermelo-Fr¨ankel set theory with choice. By adopting a stan-
dard interpretation, TLA+ speciﬁcations are precise and unambiguous about
the “data structures” on which speciﬁcations are based. We have seen in the
example proofs in Sect. 4 that reasoning about data accounts for most of the
steps that need to be proved during system veriﬁcation. Besides ﬁxing the vo-
cabulary of the logical language and the intended interpretation, TLA+ also
introduces facilities for structuring a speciﬁcation as a hierarchy of modules,
for declaring parameters, and most importantly, for deﬁning operators. These
facilities are essential for writing actual speciﬁcations and must therefore be
mastered by any user of TLA+. However, from the foundational point of view
adopted in this paper, they are just syntactic sugar. We will therefore con-
centrate on the set-theoretic foundations, referring the reader to Lamport’s
book [30] for a detailed presentation of the language of TLA+.
5.1 Elementary data structures: basic set theory
Elementary set theory is based on a signature that consists of a single binary
predicate symbol ∈and no function symbols. TLA+ heavily relies on Hilbert’s
choice operator. The syntax of transition-level terms and formulas deﬁned in
Sect. 3.2 is therefore extended by an additional term formation rule that de-
ﬁnes choose x : A to be a transition function whenever x ∈VE is a variable
and A is an action.7 The occurrences of x in the term choose x : A are
bound. To this ﬁrst-order language corresponds a set-theoretic interpretation:
every TLA+ value is a set. Moreover, ∈is interpreted as set membership and
the interpretation is equipped with an (unspeciﬁed) choice function ε map-
ping every non-empty collection C of values to some element ε(C) of C, and
mapping the empty collection to an arbitrary value. The interpretation of a
term choose x : P is deﬁned as
Jchoose x : PKξ
s,t
=
ε({d | JPKαs,t,ξ[d/x] = t})
This deﬁnition employs the choice function to return some value satisfying
P provided there is some such value in the universe of set theory. Observe
that in this semantic clause, the choice function is applied to a collection that
need not be a set (i.e., an element of the universe of the interpretation); in
set-theoretic terminology, ε applies to classes and not just to sets. Because ε
is a function, it produces the same value when applied to equal arguments. It
follows that choice satisﬁes the laws
7 Temporal formulas are deﬁned as indicated in section 3.3; in particular, choose
is never applied to a temporal formula.

The Speciﬁcation Language TLA+
423
union
union S
∆=
choose M : ∀x : (x ∈M ≡∃T ∈S : x ∈T)
binary union
S ∪T
∆=
union {S, T}
subset
S ⊆T
∆=
∀x : (x ∈S ⇒x ∈T)
powerset
subset S
∆=
choose M : ∀x : (x ∈M ≡x ⊆S)
comprehension 1 {x ∈S : P}
∆=
choose M : ∀x : (x ∈M ≡x ∈S ∧P)}
comprehension 2 {t : x ∈S}
∆=
choose M : ∀y : (y ∈M ≡∃x ∈S : y = t)
Fig. 6. Basic set-theoretic operators.
(∃x : P) ≡P[(choose x : P)/x]
(11)
(∀x : (P ≡Q)) ⇒(choose x : P) = (choose x : Q)
(12)
TLA+ avoids undeﬁnedness by underspeciﬁcation [19], so choose x : P
denotes a value even if no value satisﬁes P. To ensure that a term involv-
ing choice actually denotes the expected value, the existence of some suitable
value should be proven. If there is more than one such value, the expression
is underspeciﬁed, and the user should be prepared to accept any of them. In
particular, any properties should hold for all possible values. However, ob-
serve that for a given interpretation, choice is deterministic, and that it is
not “monotone”: no relationship can be established between choose x : P
and choose x : Q even when P ⇒Q is valid (unless P and Q are actually
equivalent). Therefore, whenever some speciﬁcation Spec contains an under-
speciﬁed application of choice, any reﬁnement Ref is constrained to make the
same choices in order to prove Ref ⇒Spec; this situation is fundamentally
diﬀerent from non-determinism where implementations may narrow the set of
allowed values.
In the following, we will freely use many notational abbreviations of TLA+.
For example, ∃x, y ∈S : P abbreviates ∃x : ∃y : x ∈S ∧y ∈S ∧P. Local
declarations are written as let
in
, and if
then
else
is used for
conditional expressions.
From membership and choice, one can build up the conventional language
of mathematics [33], and this is the foundation for the expressiveness of TLA+.
Figure 6 lists some of the basic set-theoretic constructs of TLA+; we write
{e1, . . . , en}
∆=
choose S : ∀x : (x ∈S ≡x = e1 ∨. . . ∨x = en)
to denote set enumeration and assume the additional bound variables in the
deﬁning expressions of Fig. 6 to be chosen such that no variable clashes occur.
The two comprehension schemes act as binders for variable x, which must
not have free occurrences in S. The existence of the sets deﬁned in terms of
choice can be justiﬁed from the axioms of Zermelo-Fr¨ankel set theory [43],
which provide the deductive counterpart to the semantics underlying TLA+.
However, it is well-known that without proper care, set theory is prone to
paradoxes. For example, the expression
choose S : ∀x : (x ∈S ≡x /∈x)

424
Stephan Merz
is a well-formed constant formula of TLA+, but the existence of a set S
containing precisely those sets that do not contain themselves would lead to
the contradiction that S ∈S iﬀS /∈S; this is of course Russell’s paradox.
Intuitively, S is “too big” to be a set. More precisely, the universe of set theory
does not contain values that are in bijection with the collection of all sets.
Therefore, when evaluating the above TLA+ expression, the choice function
is applied to the empty collection, and the result depends on the underlying
interpretation. Perhaps unexpectedly, we can however infer from (12) that
(choose S : ∀x : (x ∈S ≡x /∈x)) = (choose x : x ∈{})
Similarly, a generalized intersection operator dual to the union operator
of Fig. 6 does not exist, because generalized intersection over the empty set
of sets cannot be sensibly deﬁned.
On the positive side, we have exploited the fact that no set can contain all
values in the deﬁnition
NoMsg
∆=
choose x : x /∈Message
that appears in ﬁgure 4(b). Whatever set is denoted by Message, NoMsg will
denote some value that is not contained in Message. If a subsequent reﬁnement
wanted to ﬁx a speciﬁc “null” message value null /∈Message, it could do so
by restricting the class of admissible interpretations via an assumption of the
form
assume (choose x : x /∈Message) = null
Because all properties established of the original speciﬁcation hold for all
possible choices of NoMsg, they will continue to hold for this restricted choice.
5.2 More data structures
Besides elementary set operations, functions are a convenient way to repre-
sent diﬀerent kinds of data structures. A traditional construction of functions
within set theory, followed in Z and B [8,42], is to construct functions as spe-
cial kinds of relations, which are represented as ordered pairs. TLA+ takes a
diﬀerent approach: it assumes functions to be primitive and assumes tuples to
be a particular kind of functions. The set of functions whose domain equals
S and whose codomain is a subset of T is written as [S →T], the domain
of a function f is denoted by domain f , and the application of function f to
an expression e is written as f [e]. The expression [x ∈S 7→e] denotes the
function with domain S that maps any x ∈S to e; again, the variable x must
not occur in S and is bound by the function constructor. (This expression
can be understood as the TLA+ syntax for a lambda expression λx ∈S : e.)
Thus, any function f obeys the law
f
= [x ∈domain f 7→f [x]]
(13)

The Speciﬁcation Language TLA+
425
and this equation can in fact serve as a characteristic predicate for functional
values. TLA+ introduces a notation for overriding a function at a certain
argument position (a similar “function update” is central in Gurevich’s ASM
notation [12,40]). Formally,
[f except ![t] = u]
∆= [x ∈domain f 7→if x = t then u else f [x]]
where x is a fresh variable. Again, this notation generalises to updates of
a function at several argument positions; also, the notation @ can be used
within the subexpression u to denote the original value of f [t].
Combining choice, sets, and function notation, one obtains an expressive
language for deﬁning mathematical structures. For example, the standard
TLA+ module introducing natural numbers deﬁnes them as an arbitrary
set with constant zero and successor function satisfying the usual Peano ax-
ioms [30, p. 345], and Lamport goes on to similarly deﬁne the integers and
the real numbers, ensuring that the integers are a subset of the reals. In par-
ticular, the arithmetic operators over these sets are identical rather than just
overloaded uses of the same symbols.
Recursive functions can be deﬁned in terms of choice, e.g.
factorial
∆=
choose f : f = [n ∈Nat 7→if n = 0 then 1 else n ∗f [n −1]]
which TLA+, using some syntactic sugar, oﬀers to write more concisely as
factorial[n ∈Nat]
∆=
if n = 0 then 1 else n ∗factorial[n −1]
Of course, as with any construction based on choice, such a deﬁnition should
be justiﬁed by proving the existence of a function that satisﬁes the recursive
equation. Unlike standard semantics of programming languages, TLA+ does
not commit to the least ﬁxed point of a recursively deﬁned function in cases
where there are several solutions.
Tuples are represented in TLA+ as functions:
⟨t1, . . . , tn⟩
∆=
[i ∈1..n 7→if i = 1 then t1 . . . else tn]
where 1..n denotes the set {j ∈Nat : 1 ≤j ∧j ≤n} (and i is a “fresh”
variable). Selection of the i-th element of a tuple is therefore just function
application. Strings are deﬁned as tuples of characters, and records are rep-
resented as functions whose domains are ﬁnite sets of strings. The update
operation on functions can thus be applied to tuples and records as well. The
concrete syntax of TLA+ oﬀers special support for record operations. For
example, one writes acct.balance instead of acct[“balance”].
The standard TLA+ module Sequences that has already appeared as a
library module used for the speciﬁcation of the FIFO queue in Fig. 4(b),
represents ﬁnite sequences as tuples. The deﬁnitions of the standard opera-
tions, some of which are shown in Fig. 7, is therefore quite simple. However,
this simplicity can sometimes be deceptive. For example, these deﬁnitions do

426
Stephan Merz
Seq(S)
∆= union {[1..n] →S : n ∈Nat}
Len(s)
∆= choose n ∈Nat : domain s = 1..n
Head(s)
∆= s[1]
Tail(s)
∆= [i ∈1..Len(s) −1 7→s[i + 1]]
s ◦t
∆= [i ∈1..Len(s) + Len(t) 7→
if i ≤Len(s) then s[i] else t[i −Len(s)]]
Append(s, e)
∆= s ◦⟨e⟩
SubSeq(s, m, n)
∆=
ˆ
i ∈1..(1 + n −m) 7→s[i + m −1]
˜
Fig. 7. Finite sequences.
not reveal that the Head and Tail operations are “partial”. They should be
validated by proving the expected properties, such as
∀s ∈Seq(S) : Len(s) ≥1 ⇒s = ⟨Head(s)⟩◦Tail(s).
6 The Resource Allocator Revisited
Armed with a better understanding of the language TLA+, let us reconsider
the resource allocator speciﬁcation of Sect. 2. We have already veriﬁed several
properties of the simple allocator speciﬁcation of Fig. 1 by model checking,
and we could use the deduction rules of Sect. 4 to prove these properties in
full generality. Does this mean that the speciﬁcation is satisfactory?
Consider the following scenario: two clients c1 and c2 both request re-
sources r1 and r2. The allocator grants r1 to c1 and r2 to c2. From our in-
formal description in Sect. 2.1, it appears that we have reached a deadlock
state: neither client can acquire the missing resource as long as the other one
doesn’t give up the resource it holds, which it is not required to do. Why then
didn’t tlc report any deadlock, and how could we prove liveness?
Formally, the model contains no deadlock because, according to require-
ment (3), each client is allowed to give up the resource it is holding. The
problem with the model is that it actually requires clients to eventually give
up the resources, even if they have not yet received the full share of resources
they asked for. This requirement is expressed by the seemingly innocous fair-
ness condition
∀c ∈Clients : WFvars(Return(c, alloc[c]))
whereas the informal requirement (4) only demands that clients return their
resources once their entire request has been satisﬁed. We should therefore
have written
∀c ∈Clients : WFvars
 unsat[c] = {} ∧Return(c, alloc[c])

Rerunning tlc on the modiﬁed speciﬁcation produces the expected counter-
example.

The Speciﬁcation Language TLA+
427
The bigger lesson of this example is that errors can creep into formal speci-
ﬁcations just as easily as into programs, and that a model can be inappropriate
even if it satisﬁes all correctness properties. Validation, for example by sim-
ulation runs or model review are extremely important to avoid this kind of
errors. We will now revisit the allocator speciﬁcation and present a corrected
model. We will then present a reﬁnement of that model that prepares an
implementation as a distributed system.
6.1 A scheduling allocator
Speciﬁcation SimpleAllocator is too simple because the allocator is free to
allocate resources in any order. Therefore, it may “paint itself into a corner”,
requiring cooperation from the clients to recover. We can prevent this from
happening by having the allocator ﬁx a schedule according to which access
to resources will be granted. Figures 8 and 9 contain a formal TLA+ model
based on this idea.
Compared to the speciﬁcation of the simple allocator of Fig. 1, the new
speciﬁcation contains two more state variables pool and sched. The variable
sched contains a sequence of clients, representing the allocation schedule. The
variable pool contains a set of clients that have requested resources but that
have not yet been scheduled for allocation. Consequently, the request action
merely inserts the client into the pool. The allocation action is restricted to
give out some resources to a client only if no client that appears earlier in the
schedule demands any of them.
The speciﬁcation contains a new action Schedule, which establishes the
allocation schedule. Because this is a high-level speciﬁcation, we do not com-
mit to any speciﬁc scheduling policy: we show the protocol to be correct if
the processes in the pool are scheduled in an arbitrary order. The auxiliary
operator PermSeqs(S) recursively computes the set of permutation sequences
of a ﬁnite set S. The idea is that ⟨x1, . . . , xn⟩is a permutation of a non-empty
ﬁnite set S if and only if ⟨x1, . . . , xn−1⟩is a permutation of S \ {xn}. The
formal expression in TLA+ makes use of an auxiliary, recursively deﬁned,
function perms that computes the set of permutations perms[T] of any subset
T ⊆S, in a style that is similar to the recursive deﬁnition of functions over
inductive data types in a functional programming language. We could have
used a simpler, more declarative, deﬁnition of the action Schedule, such as
Schedule
∆=
∧pool ̸= {} ∧pool ′ = {}
∧∃sq ∈Seq(Clients) : ∧{sq[i] : i ∈domain sq} = pool
∧∀i, j ∈1..Len(sq) : sq[i] = sq[j] ⇒i = j
∧unchanged ⟨unsat, alloc⟩.
In this formulation, the schedule is simply required to be any injective se-
quence (containing no duplicates) formed from the elements of pool. The two

428
Stephan Merz
module SchedulingAllocator
extends FiniteSet, Sequences, Naturals
constants Clients, Resources
assume IsFiniteSet(Resources)
variables unsat, alloc, pool, sched
TypeInvariant
∆=
∧unsat ∈[Clients →subset Resources]
∧alloc ∈[Clients →subset Resources]
∧pool ∈subset Clients ∧sched ∈Seq(Clients)
available
∆=
Resources \ (union {alloc[c] : c ∈Clients})
PermSeqs(S)
∆=
set of permutations of ﬁnite set S, represented as sequences
let perms[ss ∈subset S]
∆=
if ss = {} then ⟨⟩
else let ps
∆=
ˆ
x ∈ss 7→
˘
Append(sq, x) : sq ∈perms[ss \ {x}]
¯˜
in
union {ps[x] : x ∈ss}
in
perms[S]
Drop(seq, i)
∆=
SubSeq(seq, 1, i −1) ◦SubSeq(seq, i + 1, Len(seq))
Init
∆=
∧unsat = [c ∈Clients 7→{}] ∧alloc = [c ∈Clients 7→{}]
∧pool = {} ∧sched = ⟨⟩
Request(c, S)
∆=
∧unsat[c] = {} ∧alloc[c] = {} ∧S ̸= {}
∧unsat′ = [unsat except ![c] = S] ∧pool ′ = pool ∪{c}
∧unchanged ⟨alloc, sched ⟩
Allocate(c, S)
∆=
∧S ̸= {} ∧S ⊆available ∩unsat[c]
∧∃i ∈domain sched :
∧sched[i] = c ∧∀j ∈1..i −1 : unsat[sched[j ]] ∩S = {}
∧sched ′ = if S = unsat[c] then Drop(sched, i) else sched
∧alloc′ = [alloc except ![c] = @ ∪S] ∧unsat′ = [unsat except ![c] = @ \ S]
∧unchanged pool
Return(c, S)
∆=
∧S ̸= {} ∧S ⊆alloc[c]
∧alloc′ = [alloc except ![c] = @ \ S]
∧unchanged ⟨unsat, pool, sched ⟩
Schedule
∆=
∧pool ̸= {} ∧pool ′ = {}
∧∃sq ∈PermSeqs(pool) : sched ′ = sched ◦sq
∧unchanged ⟨unsat, alloc⟩
Next
∆=
∨∃c ∈Clients, S ∈subset Resources :
Request(c, S) ∨Allocate(c, S) ∨Return(c, S)
∨Schedule
vars
∆=
⟨unsat, alloc, pool, sched ⟩
Fig. 8. Speciﬁcation of an allocator with scheduling (part 1).

The Speciﬁcation Language TLA+
429
Allocator
∆=
∧Init ∧2[Next]vars
∧∀c ∈Clients : WFvars(unsat[c] = {} ∧Return(c, alloc[c]))
∧∀c ∈Clients : WFvars(∃S ∈subset Resources : Allocate(c, S))
∧WFvars(Schedule)
Fig. 9. Speciﬁcation of an allocator with scheduling (part 2).
deﬁnitions are logically equivalent. However, this deﬁnition would not be ac-
ceptable for tlc because the set Seq(Clients) is inﬁnite, even if Clients is
ﬁnite.
Looking at the fairness conditions, observe that the fairness requirement on
the return action has been amended as indicated above, so that it agrees with
the informal speciﬁcation. The fairness condition for the allocation action is
similar to the one adopted for the simple allocator speciﬁcation, but with weak
fairness substituted for strong fairness. The idea behind this change is that
the non-determinism present in the original speciﬁcation has been resolved by
the introduction of the allocation schedule, so that the simpler condition now
suﬃces. (Of course, this intuition will have to be formally veriﬁed!) There is
an additional weak fairness requirement for the scheduling action, asserting
that the allocator should periodically update its schedule when new clients
have issued requests.
6.2 Analysis Using Model Checking
We can again ask tlc to verify the safety and liveness properties described
in Sect. 2.3. For an instance consisting of three clients and two resources, tlc
computes 1690 distinct states and requires about 30 seconds for veriﬁcation.
What sets tlc apart from more conventional model checkers is its ability to
evaluate an input language where models can be expressed at the high level
of abstraction at which it has been presented in Figs. 8 and 9: neither the
deﬁnition of the operator PermSeqs nor the relatively complicated fairness
constraints pose a problem. (For better eﬃciency, we could override the deﬁ-
nition of PermSeqs by a method written in Java, but this is not a big concern
for a list that contains at most three elements.)
Given the experience with the veriﬁcation of the simple allocator model,
one should be suspicious of the quick success with the new model. As Lam-
port [30, ch. 14.5.3] writes, it is a good idea to verify as many properties as pos-
sible. Figure 10 contains a lower-level invariant of the scheduling allocator that
can be veriﬁed using tlc. The ﬁrst conjunct of formula AllocatorInvariant
says that all clients in set pool have requested resources, but do not hold any.
The second conjunct concerns the clients in the schedule; it is split into three
sub-conjuncts: ﬁrst, each client in the schedule has some outstanding requests,
second, no client may hold some resource that is requested by some prioritized
client (appearing earlier in the schedule), and ﬁnally, the set of outstanding
requests of a client in the schedule is bounded by the union of the set of

430
Stephan Merz
UnscheduledClients
∆=
set of clients that are not in the schedule
Clients \ {sched[i] : i ∈domain sched}
PrioResources(i)
∆=
bound on resources requested by i-th client in schedule
available
∪union {unsat[sched[j ]] ∪alloc[sched[j ]] : j ∈1..i −1}
∪union {alloc[c] : c ∈UnscheduledClients}
AllocatorInvariant
∆=
∧∀c ∈pool : unsat[c] ̸= {} ∧alloc[c] = {}
∧∀i ∈domain sched : ∧unsat[sched[i]] ̸= {}
∧∀j ∈1..i −1 : alloc[sched[i]] ∩unsat[sched[j ]] = {}
∧unsat[sched[i]] ⊆PrioResources(i)
Fig. 10. Lower-level Invariant of the Scheduling Allocator.
currently available resources, the resources requested or held by prioritized
clients and the resources held by clients that do not appear in the schedule.
The idea behind this last conjunct is to assert that a client’s requests can
be satisﬁed using resources that are either already free or that are held by
prioritized clients. It follows that prioritized clients can obtain their full set
of resources, after which they are required to eventually release them again.
Therefore, the scheduling allocator works correctly even under the worst-case
assumption that clients will only give up resources after their complete request
has been satisﬁed.
Veriﬁcation by Reﬁnement.
Beyond these correctness properties, tlc can also establish a formal reﬁne-
ment relationship between the two allocator speciﬁcations. The scheduling
allocator operates under some additional constraints. Moreover, it introduces
the variable sched, which did not appear in the speciﬁcation of the simple
allocator, and which is therefore not constrained by that speciﬁcation. More
interestingly, the scheduling policy and the (weaker) liveness assumptions im-
ply that the (original) fairness constraints are eﬀectively met. The scheduling
allocator therefore turns out to be a reﬁnement of the simple allocator, im-
plying the correctness properties by transitivity!
We can use tlc to verify this reﬁnement, for small ﬁnite instances, using
the module AllocatorReﬁnement that appears in Fig. 11. It extends module
SchedulingAllocator, thus importing all declarations and deﬁnitions of that
module, and deﬁnes an instance Simple of module SimpleAllocator, whose
parameters are (implicitly) instantiated by the entities of the same name in-
herited from module SchedulingAllocator. All operators Op deﬁned in the
instance are available as Simple!Op. (It would have been illegal to extend
both modules SchedulingAllocator and SimpleAllocator because they declare
constants and variables, as well as deﬁne operators, of the same names.)
The module then asserts that speciﬁcation Allocator implies the speciﬁcation

The Speciﬁcation Language TLA+
431
module AllocatorReﬁnement
extends SchedulingAllocator
Simple
∆=
instance SimpleAllocator
SimpleAllocator
∆=
Simple!SimpleAllocator
theorem Allocator ⇒SimpleAllocator
Fig. 11. Asserting a Reﬁnement Relationship.
SimpleAllocator. In order to have this implication checked by tlc, we again
deﬁne an instance consisting of three clients and two resources and stipulate
SPECIFICATION Allocator
PROPERTIES SimpleAllocator
in the conﬁguration ﬁle. tlc ﬁnds the implication to be valid, requiring just
6 seconds.
6.3 Towards a Distributed Implementation
The speciﬁcation Allocator deﬁned in module SchedulingAllocator of Figs. 8
and 9 describes an overall algorithm (or rather a class of algorithms) for re-
source allocation; analysis by tlc has indicated that this algorithm satisﬁes
the desired correctness properties, even under worst-case assumptions about
the clients’ behavior. However, the model does not indicate the architecture
of the system as a set of independent, communicating processes. Our next
goal is therefore to reﬁne that speciﬁcation into one that is implementable as
a distributed system. In particular, we will assume that the allocator and the
clients may run on diﬀerent processors. Therefore, each process should have
direct access only to its local memory, and explicit, asynchronous message
passing will be used to communicate with other processes. Instead of a cen-
tralized representation of the system state based on the variables unsat and
alloc, we will distinguish between the allocator’s view and each client’s view
of its pending requests and allocated resources. Similarly, the basic actions
such as the request for resources will be split into two parts, with diﬀerent
processes being responsible for carrying them out: in a ﬁrst step, the client
issues a request, updates its local state, and sends a corresponding message
to the allocator. Subsequently, the allocator receives the message and updates
its table of pending requests accordingly.
Figures 12 and 13 contain a TLA+ model based on this idea. It contains
variables unsat, alloc, and sched as before, but these are now considered to
be local variables of the allocator. New variables requests and holding repre-
sent the clients’ views of pending resource requests and of resources currently
held; we interpret requests[c] and holding[c] as being local to the client pro-
cess c. The communication network is (very abstractly) modeled by the vari-

432
Stephan Merz
module AllocatorImplementation
extends FiniteSets, Sequences, Naturals
constants Clients, Resources
assume IsFiniteSet(Resources)
variables unsat, alloc, sched, requests, holding, network
Sched
∆=
instance SchedulingAllocator
Messages
∆=
[type : {“request”, “allocate”, “return”}, clt : Clients, rsrc : subset Resources]
TypeInvariant
∆=
∧Sched !TypeInvariant
∧requests ∈[Clients →subset Resources]
∧holding ∈[Clients →subset Resources]
∧network ∈subset Messages
Init
∆=
∧Sched !Init
∧requests = [c ∈Clients 7→{}] ∧holding = [c ∈Clients 7→{}] ∧network = {}
Request(c, S)
∆=
client c requests set S of resources
∧requests[c] = {} ∧holding[c] = {} ∧S ̸= {}
∧requests′ = [requests except ![c] = S]
∧network ′ = network ∪{[type 7→“request”, clt 7→c, rsrc 7→S]}
∧unchanged ⟨unsat, alloc, sched, holding ⟩
RReq(m)
∆=
allocator handles request message sent by some client
∧m ∈network ∧m.type = “request” ∧network ′ = network \ {m}
∧unsat′ = [unsat except ![m.clt] = m.rsrc]
∧unchanged ⟨alloc, sched, requests, holding ⟩
Allocate(c, S)
∆=
allocator decides to allocate resources S to client c
∧Sched !Allocate(c, S)
∧network ′ = network ∪{[type 7→“allocate”, clt 7→c, rsrc 7→S]}
∧unchanged ⟨requests, holding ⟩
RAlloc(m)
∆=
some client receives resource allocation message
∧m ∈network ∧m.type = “allocate” ∧network ′ = network \ {m}
∧holding′ = [holding except ![m.clt] = @ ∪m.rsrc]
∧requests′ = [requests except ![m.clt] = @ \ m.rsrc]
∧unchanged ⟨unsat, alloc, sched ⟩
Return(c, S)
∆=
client c returns resources in S
∧S ̸= {} ∧S ⊆holding[c]
∧holding′ = [holding except ![c] = @ \ S]
∧network ′ = network ∪{[type 7→“return”, clt 7→c, rsrc 7→S]}
∧unchanged ⟨unsat, alloc, sched, requests ⟩
RRet(m)
∆=
allocator receives returned resources
∧m ∈network ∧m.type = “return” ∧network ′ = network \ {m}
∧alloc′ = [alloc except ![m.clt] = @ \ m.rsrc]
∧unchanged ⟨unsat, sched, requests, holding ⟩
Schedule
∆=
Sched !Schedule ∧unchanged ⟨requests, holding, network ⟩
Fig. 12. An implementation of the allocator (part 1).

The Speciﬁcation Language TLA+
433
Next
∆=
∨∃c ∈Clients, S ∈subset Resources :
Request(c, S) ∨Allocate(c, S) ∨Return(c, S)
∨∃m ∈network : RReq(m) ∨RAlloc(m) ∨RRet(m)
∨Schedule
vars
∆=
⟨unsat, alloc, sched, requests, holding, network ⟩
Liveness
∆=
∧∀c ∈Clients : WFvars(requests[c] = {} ∧Return(c, holding[c]))
∧∀c ∈Clients : WFvars(∃S ∈subset Resources : Allocate(c, S))
∧WFvars(Schedule)
∧∀m ∈Messages :
WFvars(RReq(m)) ∧WFvars(RAlloc(m)) ∧WFvars(RRet(m))
Implementation
∆=
Init ∧2[Next]vars ∧Liveness
theorem Implementation ⇒Sched !Allocator
Fig. 13. An implementation of the allocator (part 2).
able network that holds the set of messages in transit between the diﬀerent
processes.
Except for the action Schedule, which is a private action of the allocator, all
actions that appeared in speciﬁcation SchedulingAllocator have been split into
two actions as explained above. For example, client c is considered to perform
action Request(c, S) because only its local variables and the state of the com-
munication network are modiﬁed by the action. The allocator later receives
the request message m and performs action RReq(m). The fairness conditions
of our previous speciﬁcation are complemented by weak fairness requirements
for the actions RReq(m), RAlloc(m), and RRet(m) that are associated with
message reception (for all possible messages m); these requirements express
that messages will eventually be received and handled.
The observant reader may be somewhat disappointed with the form of
the speciﬁcation of this “distributed” implementation because the formula
Implementation is again written in the standard form
Init ∧2[Next]v ∧L
that we have seen so often in this chapter. From the discussion of system
composition as conjunction in Sect. 3.5, one could have expected to see a
conjunction of speciﬁcations, one for each process. There are two technical
problems with doing so: ﬁrst, the clients’ variables requests and holding are
represented as arrays such that each client accesses only the corresponding
array ﬁeld. The speciﬁcation of client c should really only specify requests[c]
and holding[c], but the composition should ensure the type correctness and
ensure that the remaining array ﬁelds remain unchanged. This is possible, but
cumbersome to write down. (Lamport discusses this issue in more detail in [30,

434
Stephan Merz
STATE 7:
/\ holding = (c1 :> {} @@ c2 :> {} @@ c3 :> {})
/\ alloc = (c1 :> {r1} @@ c2 :> {} @@ c3 :> {})
/\ requests = (c1 :> {} @@ c2 :> {} @@ c3 :> {})
/\ sched = <<
>>
/\ network = {[type |-> "return", clt |-> c1, rsrc |-> {r1}]}
/\ unsat = (c1 :> {} @@ c2 :> {} @@ c3 :> {})
STATE 8:
/\ holding = (c1 :> {} @@ c2 :> {} @@ c3 :> {})
/\ alloc = (c1 :> {r1} @@ c2 :> {} @@ c3 :> {})
/\ requests = (c1 :> {r1} @@ c2 :> {} @@ c3 :> {})
/\ sched = <<
>>
/\ network = { [type |-> "request", clt |-> c1, rsrc |-> {r1}],
[type |-> "return", clt |-> c1, rsrc |-> {r1}] }
/\ unsat = (c1 :> {} @@ c2 :> {} @@ c3 :> {})
STATE 9:
/\ holding = (c1 :> {} @@ c2 :> {} @@ c3 :> {})
/\ alloc = (c1 :> {r1} @@ c2 :> {} @@ c3 :> {})
/\ requests = (c1 :> {r1} @@ c2 :> {} @@ c3 :> {})
/\ sched = <<
>>
/\ network = {[type |-> "return", clt |-> c1, rsrc |-> {r1}]}
/\ unsat = (c1 :> {r1} @@ c2 :> {} @@ c3 :> {})
Fig. 14. Model checking the correctness of the implementation.
Chap. 10].) Second, the current implementation of tlc expects speciﬁcations
in standard form and does not handle conjunctions of process speciﬁcations.
Module AllocatorImplementation claims that the model obtained in this
way is a reﬁnement of the scheduling allocator speciﬁcation, and we can again
use tlc to verify this theorem for ﬁnite instances. However, tlc quickly pro-
duces a counterexample that ends in the states shown in Fig. 14.
In state 7, client c1 has returned resource r1 to the allocator. In the
transition to state 8, it issues a new request for the same resource, which
is handled by the allocator (according to action RReq) in the transition to
state 9. This action modiﬁes the variable unsat at position c1 although the
value of alloc[c1] is not the empty set – a transition that is not allowed by
the scheduling allocator.
Intuitively, the problem is due to the asynchronous communication net-
work underlying our model, which makes the allocator receive and handle the
request message before it receives the earlier return message. Indeed, it is easy
to see that if one allowed the allocator to handle the new request before releas-
ing the old one, it may become confused and deregister r1 for client c1 even
though the client still holds the resource (granted in response to the second
request). It depends on the underlying communication network whether such

The Speciﬁcation Language TLA+
435
RequestsInTransit(c)
∆=
requests sent by c but not yet received
˘
msg.rsrc : msg ∈{m ∈network : m.type = “request” ∧m.clt = c}
¯
AllocsInTransit(c)
∆=
allocations sent to c but not yet received
˘
msg.rsrc : msg ∈{m ∈network : m.type = “allocate” ∧m.clt = c}
¯
ReturnsInTransit(c)
∆=
return messages sent by c but not yet received
˘
msg.rsrc : msg ∈{m ∈network : m.type = “return” ∧m.clt = c}
¯
Invariant
∆=
∀c ∈Clients :
∧Cardinality(RequestsInTransit(c)) ≤1
∧requests[c] =
unsat[c]
∪union RequestsInTransit(c)
∪union AllocsInTransit(c)
∧alloc[c] =
holding[c]
∪union AllocsInTransit(c)
∪union ReturnsInTransit(c)
Fig. 15. Relating the allocator and client variables by an invariant.
a race condition can occur or not. If messages between any pair of processes
are delivered in order, the TLA+ model could represent the communication
network as a set of message queues. If communication is truly asynchronous
and message order is not guaranteed, one should add the precondition
alloc[m.clt] = {}
to the deﬁnition of the action RReq(m) so that a new request will be processed
only after the return message corresponding to the previous grant has been
received. With this correction, tlc conﬁrms the reﬁnement theorem for our
small instance in about 2 minutes.
Finally, we can assert the invariant shown in Fig. 15 to conﬁrm the in-
tuition about how the variables associated with the clients and the allocator
relate to each other. The veriﬁcation of this invariant for the usual small in-
stance of the model with three clients and two resources generates 64414 states
(17701 of which are distinct) and takes about 12 seconds.
6.4 Some Lessons Learnt
Starting from the informal requirements for the allocator problem presented
in Sect. 2.1, it would have been tempting to directly come up with a model
similar to the “implementation” presented in Sect. 6.3, or even a more de-
tailed one. However, a low-level speciﬁcation is at least as likely to contain
errors as a program, and the whole purpose of modelling is to clarify and
analyse a system at an adequate level of abstraction. The seemingly trivial
SimpleAllocator speciﬁcation of Fig. 1 helped us discover the need for ﬁxing
a schedule for resource allocation. It also illustrated the need for validating
models: success in model checking (or proving) correctness properties by itself
does not guarantee that the model is meaningful. A similar problem would

436
Stephan Merz
have been more diﬃcult to detect at the level of detail of the ﬁnal speciﬁcation,
where there are additional problems of synchronisation and message passing
to worry about. The speciﬁcation SchedulingAllocator introduced the idea of
determining a schedule and thereby ﬁxed the problem of the original speciﬁ-
cation while remaining at the same high level of abstraction. Finally, module
AllocatorImplementation introduced a step towards a possible implementa-
tion by attributing the state variables and the actions to separate processes,
and by introducing explicit communication.
For each model, tlc was of great help in analysing various properties. Al-
though only small instances can be handled by model checking before running
into the state explosion problem, doing so greatly increases the conﬁdence in
the models. Variants of the speciﬁcations can be checked without great eﬀort,
and various properties (invariants and more general temporal properties) can
be veriﬁed in a single run. Deductive veriﬁcation, based on the proof rules
of Sect. 4, can then establish system properties in a fully rigorous way. In
our own work, we have deﬁned a format of “predicate diagrams” for TLA+
speciﬁcations [14]. We have found these diagrams to be helpful in determining
appropriate fairness hypotheses. The format is supported by a tool [18] that
uses model checking to identify abstract counter-examples, indicating either
too weak an abstraction or missing fairness or ordering annotations.
7 Conclusions
The design of software systems requires a combination of ingenuity and care-
ful engineering. While there is no substitute for intuition, the correctness of a
proposed solution can be checked by precise reasoning over a suitable model,
and this is the realm of logics and (formalized) mathematics. The rˆole of a for-
malism is to help the user in the diﬃcult and important activity of writing and
analysing formal models. TLA+ builds on the experience of classical math-
ematics and adds a thin layer of temporal logic in order to describe system
executions, in particular to express fairness properties. A distinctive feature of
TLA is its attention to reﬁnement and composition, reﬂected in the concept of
stuttering invariance. Unlike property-oriented speciﬁcation languages based
on temporal logic, TLA favors the speciﬁcation of systems as state machines,
augmented by fairness conditions and by hiding.
Whereas the expressiveness of TLA+ undoubtedly helps in writing concise,
high-level models of systems, it is not so clear a priori that it lends itself as well
to the analysis of these models. For example, we have pointed out several times
the need to prove conditions of “well-deﬁnedness” related to the use of the
choice operator. These problems can to some extent be mastered by adhering
to standard idioms, such as primitive-recursive deﬁnitions, that ensure well-
deﬁnedness. For the speciﬁcation of reactive systems, TLA adds some proper
idioms that control the delicate interplay between temporal operators. For
example, restricting fairness conditions to subactions of the next-state relation

The Speciﬁcation Language TLA+
437
ensures that a speciﬁcation is machine closed [3], i.e. that its allowed behavior
is entirely described by the initial condition and its next-state relation. Having
an expressive speciﬁcation language is also helpful when new classes of systems
arise. For example, Abadi and Lamport [3] describe a format for specifying
real-time systems in TLA+, and Lamport [31] describes how discrete real-time
systems can be veriﬁed using tlc.
The main tool supporting TLA+ is the model checker tlc [45]. It can
analyse system speciﬁcations in standard form written in a sublanguage of
TLA+ that ensures that the next-state relation can be eﬀectively computed.
All the TLA+ speciﬁcations that appeared in this chapter fall into this frag-
ment, and indeed the input language of tlc is more expressive than that of
most other model checkers. Deductive veriﬁcation of TLA+ speciﬁcations can
be supported by proof assistants, and in fact several encodings of TLA in the
logical frameworks of diﬀerent theorem provers have been proposed [17,21,36],
although no prover is yet available that fully supports TLA+.
Lamport has recently deﬁned the language +CAL, a high-level algorith-
mic language for describing concurrent and distributed algorithms. The ex-
pressions of +CAL are those of TLA+, but +CAL provides standard pro-
gramming constructs such as assignment, sequencing, conditionals, loops, non-
deterministic choice, and procedures. The +CAL compiler generates a TLA+
speciﬁcation from a +CAL program that can then be veriﬁed using tlc [32]. A
useful complement could be the generation of executable code from a fragment
of +CAL for speciﬁc execution platforms.
Acknowledgements.
I am indebted to Leslie Lamport for providing the subject of this article, for his
encouragement of this work, and for his detailed comments on earlier versions.
Parts of this paper have their roots in an earlier paper on TLA, written with
Mart´ın Abadi [6]. I have had the opportunity on several occasions to teach
about TLA+, and fruitful discussions with students helped me prepare this
chapter.
References
1. M. Abadi.
An axiomatization of Lamport’s Temporal Logic of Actions.
In
J. C. M. Baeten and J. W. Klop, editors, CONCUR ’90, Theories of Concur-
rency: Uniﬁcation and Extension, volume 458 of Lecture Notes in Computer
Science, pages 57–69, Berlin, 1990. Springer-Verlag.
2. M. Abadi and L. Lamport. The existence of reﬁnement mappings. Theoretical
Computer Science, 81(2):253–284, May 1991.
3. M. Abadi and L. Lamport. An old-fashioned recipe for real time. ACM Trans-
actions on Programming Languages and Systems, 16(5):1543–1571, Sept. 1994.
4. M. Abadi and L. Lamport. Conjoining speciﬁcations. ACM Transactions on
Programming Languages and Systems, 17(3):507–534, May 1995.

438
Stephan Merz
5. M. Abadi and S. Merz. An abstract account of composition. In J. Wiedermann
and P. Hajek, editors, Mathematical Foundations of Computer Science, volume
969 of Lecture Notes in Computer Science, pages 499–508, Prague, Czech Re-
public, 1995. Springer-Verlag.
6. M. Abadi and S. Merz.
On TLA as a logic.
In M. Broy, editor, Deductive
Program Design, NATO ASI series F, pages 235–272. Springer-Verlag, 1996.
7. M. Abadi and G. Plotkin. A logical view of composition. Theoretical Computer
Science, 114(1):3–30, June 1993.
8. J.-R. Abrial. The B-Book: Assigning Programs to Meanings. Cambridge Uni-
versity Press, 1996.
9. J.-R. Abrial. Extending B without changing it (for developing distributed sys-
tems). In H. Habrias, editor, 1st Conference on the B method, pages 169–190.
IRIN Institut de recherche en informatique de Nantes, 1996.
10. B. Alpern and F. B. Schneider. Deﬁning liveness. Information Processing Let-
ters, 21(4):181–185, Oct. 1985.
11. R. Back and J. von Wright. Reﬁnement calculus—A systematic introduction.
Springer-Verlag, 1998.
12. E. B¨orger and R. St¨ark.
Abstract State Machines: A Method for High-Level
System Design and Analysis. Springer-Verlag, 2003.
13. D. Cansell and D. M´ery. The Event-B Modelling Method: Concepts and Case
Studies. Chapter 2 of this volume, pp. 33–138.
14. D. Cansell, D. M´ery, and S. Merz. Diagram reﬁnements for the design of reactive
systems. Journal of Universal Computer Science, 7(2):159–174, 2001.
15. E. M. Clarke, O. Grumberg, and D. Peled. Model Checking. MIT Press, Cam-
bridge, Mass., 1999.
16. W.-P. de Roever, H. Langmaack, and A. Pnueli, editors.
Compositionality:
The Signiﬁcant Diﬀerence, volume 1536 of Lecture Notes in Computer Science.
Springer-Verlag, 1998.
17. U. Engberg, P. Gronning, and L. Lamport. Mechanical veriﬁcation of concurrent
systems with TLA. In Fourth Intl. Conf. Computer-Aided Veriﬁcation (CAV
’92), volume 663 of Lecture Notes in Computer Science, pages 44–55. Springer-
Verlag, 1992.
18. L. Fejoz, D. M´ery, and S. Merz. Dixit: Visualizing predicate abstractions. In
R. Bharadwaj and S. Mukhopadhyay, editors, Automatic Veriﬁcation of Inﬁnite-
State Systems (AVIS 2005), pages 39–48, Edinburgh, U.K., Apr. 2005. to appear
in ENTCS.
19. D. Gries and F. B. Schneider. Avoiding the undeﬁned by underspeciﬁcation.
In J. van Leeuwen, editor, Computer Science Today: Recent Trends and Devel-
opments, volume 1000 of Lecture Notes in Computer Science, pages 366–373.
Springer-Verlag, New York, N.Y., 1995.
20. G. E. Hughes and M. J. Cresswell. A New Introduction to Modal Logic. Rout-
ledge, London, 1996.
21. S. Kalvala. A formulation of TLA in Isabelle. Available at ftp://ftp.dcs.
warwick.ac.uk/people/Sara.Kalvala/tla.dvi, Mar. 1995.
22. M. Kaminski. Invariance under stuttering in a temporal logic of actions. Theo-
retical Computer Science, 2006. to appear.
23. H. W. Kamp. Tense Logic and the Theory of Linear Order. PhD thesis, Univ.
of California at Los Angeles, 1968.
24. L. Lamport.
The TLA home page.
http://www.research.microsoft.com/
users/lamport/tla/tla.html.

The Speciﬁcation Language TLA+
439
25. L. Lamport. Proving the correctness of multiprocess programs. IEEE Trans.
Softw. Eng., SE-3(2):125–143, Mar. 1977.
26. L. Lamport. What good is temporal logic? In R. E. A. Mason, editor, Informa-
tion Processing 83: Proceedings of the IFIP 9th World Congress, pages 657–668,
Paris, Sept. 1983. IFIP, North-Holland.
27. L. Lamport.
How to write a long formula.
Formal Aspects of Computing,
6(5):580–584, 1994.
28. L. Lamport. The Temporal Logic of Actions. ACM Transactions on Program-
ming Languages and Systems, 16(3):872–923, May 1994.
29. L. Lamport. How to write a proof. American Mathematical Monthly, 102(7):600–
608, 1995.
30. L. Lamport. Specifying Systems. Addison-Wesley, Boston, Mass., 2002.
31. L. Lamport. Real-time model checking is really simple. In D. Borrione and W. J.
Paul, editors, Correct Hardware Design and Veriﬁcation Methods (CHARME
2005), volume 3725 of Lecture Notes in Computer Science, pages 162–175,
Saarbr¨ucken, Germany, 2005. Springer-Verlag.
32. L. Lamport. Checking a multithreaded algorithm with =+cal. In S. Dolev, ed-
itor, 20th Intl. Symp. Distributed Computing (DISC 2006), Stockholm, Sweden,
2006. to appear.
33. A. C. Leisenring. Mathematical Logic and Hilbert’s ε-Symbol. University Math-
ematical Series. Macdonald & Co. Ltd., London, U.K., 1969.
34. Z. Manna and A. Pnueli.
Veriﬁcation of concurrent programs: the temporal
framework.
In R. Boyer and J. Moore, editors, The Correctness Problem in
Computer Science, pages 215–273. Academic Press, London, 1982.
35. Z. Manna and A. Pnueli.
The temporal logic of reactive and concurrent
systems—Speciﬁcation. Springer-Verlag, New York, 1992.
36. S. Merz. Isabelle/TLA. Available on the WWW at http://isabelle.in.tum.
de/library/HOL/TLA, 1997. Revised 1999.
37. S. Merz. A more complete TLA. In J. Wing, J. Woodcock, and J. Davies, editors,
FM’99: World Congress on Formal Methods, volume 1709 of Lecture Notes in
Computer Science, pages 1226–1244, Toulouse, France, 1999. Springer-Verlag.
38. A. Pnueli. The temporal logic of programs. In Proceedings of the 18th Annual
Symposium on the Foundations of Computer Science, pages 46–57. IEEE, 1977.
39. A. N. Prior. Past, Present and Future. Clarendon Press, Oxford, U.K., 1967.
40. W. Reisig. Abstract State Machines for the Classroom. Chapter 1 of this volume,
pp. 1–32.
41. A. P. Sistla, E. M. Clarke, N. Francez, and Y. Gurevich. Can message buﬀers
be characterized in linear temporal logic? Information and Control, 63:88–112,
1984.
42. M. Spivey. The Z Notation: A Reference Manual. Prentice Hall, 1992.
43. P. Suppes. Axiomatic Set Theory. Dover Publications, 1972.
44. M. Vardi. Branching vs. linear time—ﬁnal showdown. In T. Margaria and W. Yi,
editors, Tools and Algorithms for the Construction and Analysis of Systems
(TACAS 2001), volume 2031 of Lecture Notes in Computer Science, pages 1–22,
Genova, Italy, 2001. Springer-Verlag.
See http://www.cs.rice.edu/~vardi/
papers/ for more recent versions of this paper.
45. Y. Yu, P. Manolios, and L. Lamport.
Model checking TLA+ speciﬁcations.
In L. Pierre and T. Kropf, editors, Correct Hardware Design and Veriﬁcation
Methods (CHARME’99), volume 1703 of Lecture Notes in Computer Science,
pages 54–66, Bad Herrenalb, Germany, 1999. Springer-Verlag.

440
Stephan Merz
TLA+ Indexes
Symbol Index
∆= , 395
@ , 397
′ , 404
· , 404
|I| , 403
ξ , 403
[A]t , 405
⟨A⟩t , 405
2, 405
2[A]t , 397
3 , 407
3⟨A⟩t , 407
; , 407
∃∃∃∃∃∃, 405 , 407
σ|i , 406
JAKI,ξ
s,t , 404
JFKI,ξ
σ
, 406
|= , 406
♮V σ , 408
≈, 408
≈V , 408
≃v , 409
[S →T] , 424
[x ∈S 7→t] , 424
m..n , 425
⟨t1, . . . , tn⟩, 425
◦, 426
Append, 426
choose, 422
domain, 424
enabled, 404
except, 397
Head, 426
Len, 426
LF, 403
LP, 403
Seq, 426
SF, 407
SubSeq, 426
subset, 423
Tail, 426
union, 423
until, 414
VE, 403
VF, 403
VR, 403
WF, 407
Concept Index
action (formula), 397, 403
action composition, 404
allocator
distributed, 431
informal requirements, 394
scheduling, 427
simple speciﬁcation, 395
always operator, 405
assertion, 395
assertional reasoning, 415
auxiliary variables, 421
behavior, 406
binary temporal operators, 414
bound variable
in temporal formula, 406
in transition formula, 404
branching-time temporal logic, 401
choice operator, 422
axiomatisation of, 422
composition, 411
conﬁguration ﬁle, 398
INVARIANTS, 399
PROPERTIES, 399

The Speciﬁcation Language TLA+
441
SPECIFICATION, 399
SYMMETRY, 400
constant formula, 404
constant parameter, 395
declaration
of parameters, 395
deﬁnition
of operators, 395
enabledness, 404
external speciﬁcation, 402
fairness
strong, 407
weak, 407
fairness condition, 397
ﬂexible variable, 403
free variable
in temporal formula, 406
in transition formula, 404
function, 424
construction, 424
recursive, 425
update, 397
interface speciﬁcation, 402
internal speciﬁcation, 402
interpretation
of ﬁrst-order logic, 403
invariant, 415
inductive, 416
proving, 415
leads to, 407
linear-time temporal logic, 401
liveness property, 398
veriﬁcation of, 417
model checking, 398
module, 395
next-state operator, 402
open system, 413
operator
deﬁnition, 395
of set theory, 423
parameter
declaration, 395
Peano’s axioms, 425
priming, 404
proof rule
(INV), 416
(INV1), 415
(LATTICE), 419
(TLA2), 417
(WF1), 418
quantiﬁcation, 420
temporal logic, 420
property
liveness, 398, 417
safety, 397
quantiﬁcation
over ﬂexible variables, 405, 408
proof rules, 420
race condition, 435
record, 425
recursive function, 425
reﬁnement, 398, 410
proof rules, 421
reﬁnement mapping, 410
rigid variable, 403
Russell’s paradox, 424
safety property, 397
satisﬁability
of temporal formulas, 407
of transition formulas, 404
semantics
of transition formulas, 404
sequence, 425
operations, 426
Sequences module, 425
set comprehension, 423
set theory, 422
set-theoretic operators, 423
signature, 403
similarity up to, 409

442
Stephan Merz
speciﬁcation
interleaving style, 412
of state machine, 397
of transition system, 397
state, 403
state formula, 404
state machine speciﬁcation, 397
state predicate, 397
state space explosion, 400
step simulation, 417
strong fairness, 407
stuttering equivalence, 408
stuttering invariance, 397
stuttering transition, 397
substitution
in temporal formula, 406
in transition formula, 404
symmetry reduction, 400
system speciﬁcation
standard form, 397
temporal formula, 397
temporal logic, 401
branching-time, 401
linear-time, 401
proof rules, 420
TLA*, 413
tlc
model checker, 398
conﬁguration ﬁle, 398
transition formula, 403
transition function, 403
transition predicate, 403
transition system speciﬁcation, 397
tuple, 425
type, 395
universe, 403
unstuttered variant, 408
validation
of formal speciﬁcations, 427
validity
of temporal formulas, 407
of transition formulas, 404
valuation, 403
variable
bound
in temporal formula, 406
in transition formula, 404
ﬂexible, 403
free
in temporal formula, 406
in transition formula, 404
rigid, 403
variable parameter, 395
weak fairness, 407
well-founded relation, 419

Contents
The Speciﬁcation Language TLA+
Stephan Merz. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
2
Example: A Simple Resource Allocator . . . . . . . . . . . . . . . . . . . . . . . . . . 394
2.1
Informal Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
2.2
A First TLA+ Speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395
2.3
Model Checking the Speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . 398
3
TLA: the Temporal Logic of Actions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
3.1
Rationale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
3.2
Transition formulas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
3.3
Temporal formulas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405
3.4
Stuttering invariance and quantiﬁcation . . . . . . . . . . . . . . . . . . . . 408
3.5
Properties, reﬁnement, and composition . . . . . . . . . . . . . . . . . . . . 409
3.6
Variations and extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
4
Deductive System Veriﬁcation in TLA . . . . . . . . . . . . . . . . . . . . . . . . . . 415
4.1
Invariants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
4.2
Step simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
4.3
Liveness properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
4.4
Simple temporal logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
4.5
Quantiﬁer rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
5
Formalized Mathematics: the Added Value of TLA+ . . . . . . . . . . . . . . 422
5.1
Elementary data structures: basic set theory . . . . . . . . . . . . . . . . 422
5.2
More data structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
6
The Resource Allocator Revisited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
6.1
A scheduling allocator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
6.2
Analysis Using Model Checking. . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
6.3
Towards a Distributed Implementation . . . . . . . . . . . . . . . . . . . . . 431
6.4
Some Lessons Learnt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
7
Conclusions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
TLA+ Indexes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440

444
Contents
Symbol Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
Concept Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440

